00:01:12 <kahlil29> Getting a text input from the front-end with Lucid which is of the type Data.Text.Internal.Lazy.Text   ... what is the best way to convert it to a String or [Char] so that I can append it a url for an API call? 
00:05:30 <well> kahlil29 unpack.toStrict? idk
00:05:36 <well> http://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-Lazy.html
00:08:39 <jle`> you can directly unpack lazy text
00:09:16 <well> oh yeah do that
00:09:28 <nshepperd> huh, stylish-haskell doesn't understand the TypeOperators use of *
00:09:31 <nshepperd> sad
00:13:31 <nshepperd> i guess that's probably a haskell-src-exts issue. tricky, what with * being all special and ambiguous
00:14:07 <jle`> TypeOperators use of * has been around for a while
00:14:14 <jle`> but yeah, parsing it is weird
00:14:53 <jle`> does haskell-src-ects re-implement a haskell parser?
00:18:39 <nshepperd> i think so
00:20:23 * hackagebot hw-bits 0.7.0.0 – Bit manipulation – https://hackage.haskell.org/package/hw-bits
00:22:01 <u-ou-> in new stack projects i see src/Lib.hs and import Lib in Main.hs but I can't seem to do src/Foo.hs and import Foo
00:24:48 <raichoo> morning
00:28:50 <geekosaur> u-ou: in the cabal file, hs-source-dirs: src
00:29:01 <geekosaur> bah
00:29:10 <geekosaur> @tell u-ou in the cabal file, hs-source-dirs: src
00:29:10 <lambdabot> Consider it noted.
00:29:46 <kahlil29> jle`, well: Thanks, worked! 
00:34:33 * hackagebot language-elm 0.0.10.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
01:06:19 <dminuoso> Given `Just 20 >>= half >>= half >>= half >>= half` is there some pattern to express this repeated bind?
01:09:01 <tdammers> dminuoso: you can write that as a fold
01:09:29 <tdammers> foldl (>>=) (Just 20) [half, half, half, half]
01:09:52 <tdammers> and then you can write that list as (replicate 4 half)
01:13:31 <nshepperd_> :t \f -> iterate (>>= f)
01:13:33 <lambdabot> Monad m => (a -> m a) -> m a -> [m a]
01:17:05 <dminuoso> tdammers: Ah, that seems to be exactly what I was looking for.
01:23:52 <tdammers> dminuoso: on a side note, why is half :: a -> Maybe a rather than just a -> a ?
01:24:57 <dminuoso> tdammers: for Integer -> Integer that would require implicit rounding :)
01:25:12 <dminuoso> At any rate, Im just trying out a variety of monads
01:25:52 <dminuoso> Oh well should have probably said that half :: Integer -> Maybe Integer
01:31:17 <BernhardPosselt> hi, if you chain Either can Left be of different types?
01:31:43 <BernhardPosselt> kinda wondering about the bind implementation
01:31:52 <cocreature> BernhardPosselt: if by chain you mean monadic binds then no
01:32:03 <cocreature> :t (>>=)
01:32:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:32:06 <BernhardPosselt> yep
01:32:14 <cocreature> the "m" is always the same
01:32:25 <cocreature> and for Either, "m" is "Either err"
01:32:37 <BernhardPosselt> i mean the a in Left a
01:32:40 <cocreature> so the type of the value in Left is fixed
01:33:06 <BernhardPosselt> so basically: can you combine Eithers with different error kinds
01:33:08 <cocreature> no
01:33:23 <BernhardPosselt> ok, so all errors need to be a string for instance
01:34:44 <BernhardPosselt> or at least a collection of errors
01:34:46 <BernhardPosselt> as in
01:35:08 <BernhardPosselt> data Error = IOErro | ValidationError
01:36:42 <cocreature> what you can do is given an "Either a b" and an "Either a' c" you can first transform them both to "Either (Either a a') b" and "Either (Either a a') c" by mapping Left/Right over the Left part and then you have the same types so you can combine them
01:37:42 * hackagebot hw-prim 0.5.0.0 – Primitive functions and data types – https://hackage.haskell.org/package/hw-prim
01:44:41 <BernhardPosselt> cocreature: right, but that gets messy with more than 2 exception types, right?
01:46:18 * hackagebot gi-gobject 2.0.15 – GObject bindings – https://hackage.haskell.org/package/gi-gobject
01:46:58 <cocreature> BernhardPosselt: in that case you make a sumtype for all errors that you want to combine so "data Err = FileNotFound file | HTTPRequestFailed request | ParseError input"
01:47:04 <cocreature> but yeah these types can grow quite large
01:47:21 <BernhardPosselt> thanks for the insights :)
01:48:52 <erisco> I don't know any of the Haskell IO functions, lol
01:49:19 <uwap> why would you need those?
01:49:21 <erisco> reading stdio is hard
01:49:39 <erisco> I mean stdin... stupid C
02:00:00 <BernhardPosselt> java exceptions and catch blocks are basically sum types and pattern matching, right
02:03:22 <Ferdirand> java exceptions are not closed types
02:05:18 <tdammers> is anything in java a closed type?
02:05:22 <Ferdirand> are you thinking of writing pattern matching code in java by abusing the exception system ?
02:05:35 <Ferdirand> i heard it was a really bad idea for performance
02:06:35 * hackagebot ekg-bosun 1.0.10 – Send ekg metrics to a Bosun instance – https://hackage.haskell.org/package/ekg-bosun
02:09:46 <ertes-w> lo
02:10:29 <Iceland_jack> hey
02:16:48 <erisco> okay, fun question... I feel like there is at least one clever and elegant solution to this
02:16:55 <erisco> drop every other element from a list beginning with the first
02:17:50 <erisco> if you give me something using explicit recursion... go play somewhere else :P
02:18:55 <opqdonut> erisco: I quite like the "evens (x:xs) = odds xs; odds (x:xs) = x:evens xs" mutual recursion
02:21:37 * hackagebot leancheck 0.6.5 – Cholesterol-free property-based testing – https://hackage.haskell.org/package/leancheck
02:23:09 <tdammers> concat . map (drop 1) . chunksOf 2
02:24:06 <mniip> :t fst . foldr ((swap .) . first . (:)) ([], [])
02:24:08 <lambdabot> Foldable t => t t1 -> [t1]
02:24:14 <mniip> > fst . foldr ((swap .) . first . (:)) ([], []) $ [1..10]
02:24:16 <lambdabot>  [2,4,6,8,10]
02:24:39 <opqdonut> nice
02:24:53 <opqdonut> the "enterprise" solution:
02:24:54 <opqdonut> > flip evalState True $ filterM (\_ -> modify not >> get) [1..10]
02:24:56 <lambdabot>  [2,4,6,8,10]
02:25:06 <ertes-w> opqdonut: doesn't work on infinite lists
02:25:07 <mniip> hahahha
02:25:19 <mniip> hmm
02:25:21 <mniip> > fst . foldr ((swap .) . first . (:)) ([], []) $ [1..]
02:25:25 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:25:27 <mniip> there ya go
02:25:33 <opqdonut> what's the name of the monad that reads from a stream of values? like Reader but with a stream
02:25:35 <tdammers> > map snd . filter fst . zip [True,False,..] $ [1..]
02:25:37 <lambdabot>  <hint>:1:40: error: parse error on input ‘..’
02:25:50 <opqdonut> tdammers: sorry, you need cycle
02:25:59 <tdammers> right
02:26:08 <ertes-w> @let bisect = foldr (\x ~(xs, ys) -> (x : ys, xs)) mempty
02:26:09 <lambdabot>  Defined.
02:26:18 <mniip> ertes-w, that's identical to mine
02:26:18 <ertes-w> > (fst . bisect) [1..]
02:26:20 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:26:27 <ertes-w> mniip: almost =)
02:26:32 <ertes-w> > (snd . bisect) [1..]
02:26:34 <ertes-w> this one is
02:26:35 <mniip> mempty = ([], [])
02:26:35 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:26:36 <tdammers> > map snd . filter fst . zip (cycle [True,False]) $ [1..]
02:26:38 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:26:45 <mniip> (\x ~(xs, ys) -> (x : ys, xs)) = ((swap .) . first . (:))
02:27:05 <ertes-w> mniip: i know…  i've written a tutorial on that particular function ;)
02:28:28 <mniip> I feel like there's a super conscise solution using traversals
02:30:20 <erisco> I am enjoying all of these :)
02:31:01 <tdammers> > catMaybes . zipWith ($) (cycle [fail,pure]) $ [1..]
02:31:04 <lambdabot>  error:
02:31:04 <lambdabot>      • No instance for (Enum String)
02:31:04 <lambdabot>          arising from the arithmetic sequence ‘1 .. ’
02:31:37 <tdammers> right
02:31:43 <erisco> fail and pure? now we're being a little obtuse :P
02:31:51 <tdammers> > catMaybes . zipWith ($) (cycle [const Nothing,pure]) $ [1..]
02:31:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:32:10 <tdammers> > catMaybes . zipWith ($) (cycle [const (fail ""),pure]) $ [1..] -- just because
02:32:12 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:32:32 <tdammers> > catMaybes . zipWith ($) (cycle [fail . show,pure]) $ [1..] -- to increase confusion
02:32:34 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:33:45 <mniip> :t iconcatMap (cycle [const empty, pure] !!)
02:33:47 <lambdabot> FoldableWithIndex Int f => f b -> [b]
02:34:29 <mniip> so far shortest
02:35:20 <erisco> taking no shame in the quadratic runtime cost :P
02:35:36 <mniip> :t iconcatMap (replicate . (`mod` 2))
02:35:38 <lambdabot> FoldableWithIndex Int f => f b -> [b]
02:36:34 <ertes-w> :t flip (foldr (\x go -> bool (x : go True) (go False)) mempty)
02:36:36 <lambdabot> Foldable t => Bool -> t a -> [a]
02:36:43 <ertes-w> :t flip (foldr (\x go -> bool (x : go True) (go False)) mempty) False
02:36:45 <lambdabot> Foldable t => t a -> [a]
02:36:50 <ertes-w> > flip (foldr (\x go -> bool (x : go True) (go False)) mempty) False [1..]
02:36:52 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:37:00 <ertes-w> > flip (foldr (\x go -> bool (x : go True) (go False)) mempty) True [1..]
02:37:02 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:37:25 <mniip> aha!
02:37:35 <mniip> :t traversed . indices odd
02:37:36 <lambdabot> error:
02:37:36 <lambdabot>     • Couldn't match expected type ‘a1 -> p0 a (f b)’
02:37:37 <lambdabot>                   with actual type ‘[i0]’
02:37:57 <mniip> huh
02:38:30 <mniip> wow the lens docs are incorrect
02:38:41 <mniip> ah
02:41:29 <mniip> @let import qualified Control.Lens.Indexed as CLI
02:41:31 <lambdabot>  Defined.
02:41:41 <mniip> :t toListOf (traversed . CLI.indices odd)
02:41:43 <lambdabot> Traversable f => f b -> [b]
02:42:43 * hackagebot extrapolate 0.2.2 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
02:42:46 <erisco> :t traversed . CLI.indices odd
02:42:46 <ertes-w> :t \x y -> fmap (($ y) . ($ x))
02:42:47 <lambdabot> Functor f => a1 -> a -> f (a1 -> a -> b) -> f b
02:42:48 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p b (f1 b) -> f b -> f1 (f b)
02:44:43 <mniip> hmm
02:44:51 <mniip> even without CLI. my replicate solution is shorter
02:45:03 <mniip> but
02:45:13 <mniip> not if I use ^..
02:45:21 <mniip> > [1..10] ^.. traversed . CLI.indices odd
02:45:24 <lambdabot>  [2,4,6,8,10]
02:46:05 <erisco> :t (^.. traverse . indices odd)
02:46:07 <lambdabot> error:
02:46:08 <lambdabot>     • Couldn't match expected type ‘(a1 -> Const (Endo [a1]) a1)
02:46:08 <lambdabot>                                     -> a -> Const (Endo [a1]) a’
02:46:15 <erisco> :t (^.. traverse . CLI.indices odd)
02:46:16 <lambdabot> error:
02:46:17 <lambdabot>     • Couldn't match type ‘Indexed Integer a1 (Const (Endo [a1]) a1)’
02:46:17 <lambdabot>                      with ‘a -> Const (Endo [a1]) a’
02:46:38 <mniip> needs more parens because precedence
02:46:41 <erisco> :t (^.. traversed . CLI.indices odd)
02:46:43 <lambdabot> Traversable f => f b -> [b]
02:46:51 <mniip> ah
02:46:52 <mniip> needs more d
02:46:56 <erisco> ;)
02:48:29 <erisco> that is very expressive, I like it, although I haven't a clue about traversals
02:48:38 <mniip> I know approximately how it works
02:48:41 <mniip> but not rigorously
02:49:29 <erisco> well when you can just read it as "traverse the odd indices and make a list" you don't necessarily have to know how it works
03:27:19 * hackagebot keystore 0.8.0.2 – Managing stores of secret things – https://hackage.haskell.org/package/keystore
03:51:35 * hackagebot fswatch 0.1.0.0 – File System watching tool with cli and slave functionalities. – https://hackage.haskell.org/package/fswatch
04:07:52 <Yotam_> Can someone help me with what I should put in the (?)? f a (a->b) -> (?) -> f c (c-> b)
04:09:18 <cocreature> Yotam_: what do you know about `f`? is it a bifunctor, a profunctor, …?
04:10:21 <Yotam_> I am not sure, "f" is a data I declared and I'm trying to see if it fits into an existing name
04:10:42 <Yotam_> by name I mean functor/bifnuctor/etc
04:11:14 <cocreature> can you show us the definition of your `f`?
04:11:49 <Yotam_> data Body a b = Body {unwrapList :: [(a -> b, a, a)]}
04:12:33 <Yotam_> and the type signature is for a function that will change the source domain a to a new one c
04:13:20 <cocreature> it’s kind of tricky to go from "Body a b" to "Body a' b". to get from "a -> b" to "a' -> b" you need a function "a' -> a". but you also have "a" itself so you need a function "a -> a'" as well
04:13:55 <mniip> Yotam_, it's covariant in b
04:14:03 <mniip> and invariant in a
04:14:16 <Yotam_> cool, I'll check it
04:14:57 <mniip> I suspect it could be a monoid if you wanted to
04:15:03 <mniip> and applicative in b, for a monoidal a
04:15:19 <mniip> the instances wouldn't necessarily be useful
04:15:48 <Yotam_> btw I have now a data type to express reversible functions, Do you have a better idea on how to encode this behavior?
04:16:12 <mniip> type Body a = ListT (ReaderT a (Writer (a, a)))
04:16:17 <mniip> it's a monad
04:16:59 <mniip> at least I think Reader and Writer are commutative
04:17:16 <mniip> ah no
04:17:24 <mniip> Writer is only commutative if the underlying monoid is commutative
04:19:29 <ertes-w> Yotam_: what are you trying to do?
04:19:36 <ertes-w> i.e. what are you using Body for?
04:20:35 <Yotam_> To express 3D bodies
04:22:13 <erisco> is there a data reification solution like http://hackage.haskell.org/package/data-reify which works for polymorphic recursion?
04:24:14 <ertes-w> Yotam_: what are the individual components of the triples?
04:24:33 <ertes-w> Yotam_: it looks like you're using a function as an array and giving it two indices of some sort
04:27:14 <Yotam_> Each element in the list is a function and its upper and lower bounds. A point is said to be in the body if the result of the function is below 0
04:27:43 <Yotam_> for every bounds that the point is in
04:27:46 <willbw> whats up 
04:31:44 <mniip> erisco, I'm sure you can (ab)use the one you linked to do what you need
04:31:50 <mniip> via existentials and/or typeable
05:04:27 <iomotoko> why when I try to run http://sprunge.us/IFaE I get http://sprunge.us/WEei ?
05:05:42 <merijn> iomotoko: Because there's already a function named 'sum' in Prelude
05:06:18 <iomotoko> merijn: so if I call it mysum it will work? lemme try
05:07:05 <iomotoko> merijn: yeah that works
05:07:22 <iomotoko> merijn: so basically 'sum' is built into haskell already?
05:08:03 <cocreature> iomotoko: "builtin" might be the wrong word here. it’s in the standard library but it’s not some builtin magic that you couldn’t implement yourself
05:08:21 <cocreature> you can "import Prelude hiding sum" to hide the implementation from the standard library
05:08:37 <tdammers> Prelude is just a module
05:08:54 <tdammers> the only thing special about it is that it gets implicitly imported unless you tell the compiler not to
05:09:46 <ertes-w> what would you call a representation that exposes extra structure (Vector), e.g. to support efficient operations, as opposed to one that is opaque (Int ->)?
05:10:23 <opqdonut> concrete vs. abstract?
05:10:57 <opqdonut> because (Int -> a) is kind of like the abstract data type of vector (in the traditional cs sense)
05:11:01 <hpc> define "exposes"
05:11:08 <hpc> i don't think Vector exports its constructors
05:11:11 <iomotoko> cocreature: merijn: tdammers: ah ok, thanks! and sry, will try to keep my stupid questions to a minimum :P
05:11:29 <cocreature> iomotoko: it’s not a stupid question at all :)
05:11:34 <ertes-w> Vector was a bad example
05:11:44 <ertes-w> (Map k a) vs. (k -> Maybe a)
05:11:54 <hpc> Map doesn't either :P
05:11:59 <hpc> perhaps you mean [] or something
05:12:03 <ertes-w> neither is more abstract than the other…  one is really just more efficient than the other in certain operations
05:12:12 <hpc> in which case concrete / abstract are definitely the words you're looking for
05:13:50 <ertes-w> hpc: the only difference between (Map k a) and (k -> Maybe a) is efficiency…  they express the same thing
05:14:06 <hpc> in which case you probably are looking for "optimized"
05:14:53 <hpc> Map k a is optimized for the kind of operations you usually perform on that sort of data structure
05:14:56 <cocreature> ertes-w: well you can trivially turn "Map k a" into "k -> Maybe a" so there doesn’t have to be a difference in efficiency
05:15:14 <hpc> and taking it a bit further, Intmap a is optimized even further for the special case of Map Int a
05:15:43 <ertes-w> i was leaning toward "extensional" vs. "intensional"
05:17:33 * hackagebot generic-lens 0.4.0.0 – Generic data-structure operations exposed as lenses. – https://hackage.haskell.org/package/generic-lens
05:17:48 <hpc> ertes-w: i think i know where you're going with this
05:17:51 <ertes-w> cocreature: you can't easily go from (k -> Maybe a) back to (Map k a) though
05:17:51 <jcjf> since type theory popped up: in languages like Rust and Swift, there's this notion of an "associated type" - is this an example of an existential?
05:18:03 <hpc> ertes-w: if you imagine that function application is a form of pattern matching on a lambda, then they're both "intentional"
05:19:27 <hpc> jcjf: it looks more like type families to me
05:20:02 <jcjf> hpc: Googling seemed to point me to that too but I never understood the link
05:20:25 <ertes-w> hpc: well, i don't mean internals in the sense of exposing the actual constructors, just operations that aren't available for the other representation
05:20:46 <hpc> jcjf: they're both more or less ways of writing functions from types to types
05:20:52 <hpc> to use the example on https://rustbyexample.com/generics/assoc_items/types.html
05:21:04 <hpc> Contains is a function from a container type to a tuple (A, B)
05:21:18 <hpc> the container type is what decides what those other two types are
05:22:14 <jcjf> hpc: I guess I got too hasty in assuming "something else decides the type" means existential
05:22:52 <ertes-w> jcjf: existential really just means "type together with a value of that type"
05:22:54 <hpc> when i hear "existential" i think of higher ranked types
05:23:04 <hpc> which have a different sort of appearance to them
05:23:35 <ertes-w> jcjf: or: "proposition together with a proof"
05:25:02 <jcjf> i suppose the examples shows "trait together with value of another type"
05:25:05 <ertes-w> you can represent existentials using higher-rank types, but it's really just a church-encoded version of the same thing
05:25:16 <jcjf> where "trait" is type class
05:25:54 <jcjf> so it's not a dependent pair, because the type class isn't a type
05:28:04 <ertes-w> "The use of 'Associated types' improves the overall readability of code by moving inner types locally into a trait as output types."
05:28:14 <ertes-w> this doesn't seem to be a type-level thing at all
05:29:11 <merijn> associated types is just "convenient syntax for type families"
05:29:20 <ertes-w> it's just a different way to write the same thing, unlike in haskell where the distinguishing feature of type families is that they are parametric, and that you can branch on the parameter
05:29:53 <jcjf> ok, i will dive deeper into type families
05:30:06 <iomotoko> mhm probably a similar error? http://sprunge.us/JeTc http://sprunge.us/WTKi
05:30:10 <jcjf> i need to keep asking stupid questions before i can internalise all this stuff
05:30:29 <ertes-w> although i'm not entirely sure what a "trait" is
05:30:42 <merijn> ertes-w: trait is rust speak for typeclass
05:31:02 <ertes-w> then those may actually be real ATs
05:31:53 <ertes-w> iomotoko: your error is in 'main'
05:32:21 <ertes-w> iomotoko: main = print (seqn [getChar, getChar, getChar])
05:32:31 <ertes-w> iomotoko: 'print' cannot print IO actions
05:32:55 <marvin2> :t seqn
05:32:57 <lambdabot> error:
05:32:57 <lambdabot>     • Variable not in scope: seqn
05:32:57 <lambdabot>     • Perhaps you meant ‘seq’ (imported from Prelude)
05:33:18 <iomotoko> ertes-w: but with the commented line above that one it doesn't work either
05:33:31 <iomotoko> and I thought I could use chars there...
05:33:55 <ertes-w> iomotoko: before we go any further write a type signature for 'seqn'
05:34:07 <ertes-w> it's important that you know and understand its type
05:34:14 <iomotoko> seqn :: Monad m => [m a] -> m [a] (for any monadic type m, of which IO is just one example, seqn maps a list of actions of type m a into a single action that returns a list of values of type a)
05:34:42 <ertes-w> iomotoko: good…  with your commented example you're giving it a [Char]
05:34:57 <ertes-w> saying that ([Char] = [m a]) for some 'm' and 'a'
05:35:09 <ertes-w> there are no such 'm' and 'a' though
05:35:44 <ertes-w> the active example gives it an [IO Char], so what's the result type of 'seqn' at that particular point?
05:36:03 <ertes-w> i.e. what's the type of (seqn [getChar, getChar, getChar])?
05:41:22 <iomotoko> ertes-w: that works http://sprunge.us/UUES but it only takes two characters...
05:41:28 <iomotoko> and I also would like it to print the output
05:41:30 <iomotoko> mhmh
05:42:22 <ertes-w> iomotoko: answer the question
05:42:36 <ertes-w> what's the type of (seqn [getChar, getChar, getChar])?
05:43:28 <iomotoko> ertes-w: I can't, I think I am doing sth which the book doesn't want me to at that point, since chapter 2 is largely about ghc/ghci and chapter 3 about types and classes
05:43:55 <ertes-w> iomotoko: allow me to help you with a hint: 'seqn' takes a value of type [m a] and returns a value of type (m [a])
05:44:15 <ertes-w> you have instantiated 'm' and 'a' to particular types…  which ones?
05:45:09 <ertes-w> (it wants an [m a], and you're giving it a [IO Char])
05:46:29 <ertes-w> iomotoko: if you're thinking, "it sounds straightforward, but …", just remove the "but" part =)
05:47:57 <iomotoko> ertes-w: value of type [m a] means any monadic type m for which IO is one example, char is another?, so it maps a list of actions of type m a (for example IO or char) into a single action and returns a list of values of type a (so char)?
05:48:13 <iomotoko> this is way over my head here :D
05:48:16 <iomotoko> shame be upon me
05:48:39 <ertes-w> iomotoko: you're on the right track…  you just need to adjust your way of thinking a little
05:49:11 <kahlil29_> Hey, When using lenses for JSON traversal, nth x will give me the xth value. But what if I need the first x values? Anything for that? 
05:49:18 <ertes-w> 'seqn' works for all 'm' and 'a', as long as 'm' is a Monad…  and that's why you're taking the freedom to use 'seqn' with (m = IO) and (a = Char)
05:49:33 <ertes-w> iomotoko: does that make sense?
05:50:11 <iomotoko> ertes-w: it does, but at the same time I don't know how that helps me here
05:50:53 <ertes-w> iomotoko: you're using 'seqn' with this type:  [IO Char] -> IO [Char]
05:51:08 <ertes-w> iomotoko: so what's the type of (seqn [getChar, getChar, getChar])?
05:52:12 <ertes-w> iomotoko: if (length :: [a] -> Int), then what's the type of (length [1,2,3,4])?
05:52:51 <iomotoko> ertes-w: well it would return an integer?
05:53:06 <ertes-w> iomotoko: yes (but be more precise: the answer is Int)
05:53:24 <iomotoko> in the other case the answer is Char?
05:53:28 <ertes-w> iomotoko: now apply the same logic
05:53:31 <ertes-w> not quite
05:53:46 <ertes-w> if (f :: A -> B), then (f x :: B), right?
05:53:48 <iomotoko> a string is the only possible option then?
05:53:55 <ertes-w> also not quite
05:53:56 <Psybur|Work> IO [Char] ?
05:54:19 <marvin2> [IO Char] -> IO [Char] tells you the type. you supplied [IO Char] to that function.. what type did it return?
05:54:19 <ertes-w> so if (seqn :: [IO Char] -> IO [Char]), then (seqn [getChar, getChar, getChar] :: ?)?
05:54:40 <ertes-w> iomotoko: it's a purely symbolic game – don't overthink it
05:55:22 <iomotoko> I don't want to sound ungrateful... but I don't think this leads to anywhere now... I have to study types in haskell first I guess
05:55:46 <ertes-w> iomotoko: just try it…  you will understand why your example fails once you do
05:56:45 <ertes-w> you're literally one step away from that =)
05:56:47 <iomotoko> a give a number of Chars and it returns a number of chars
05:57:04 <iomotoko> *I give it a number of Chars and it returns a number of Chars
05:57:14 <lyxia> kahlil29_: https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Traversal.html#v:taking
05:57:44 <ertes-w> iomotoko: yes, that one was correct…  now all you need to do is to apply the same logic to 'seqn'
05:58:06 <ertes-w> iomotoko: once again:  if (f :: A -> B) and (x :: A), then (f x :: B)
05:58:21 <ertes-w> you have a case where A = [IO Char], and B = IO [Char]
05:58:36 <ertes-w> and f = seqn, x = [getChar, getChar, getChar]
05:58:56 <ertes-w> and the question is: what is B?
05:59:37 <ertes-w> (hint: i just spoiled the answer) =)
06:00:09 <iomotoko> it returns an output action?
06:00:15 <iomotoko> I feel like the dumbest student of all times right now
06:00:40 <ertes-w> iomotoko: it does, but the question is: what's the *type* of that?
06:00:54 <ertes-w> iomotoko: you're just overthinking it
06:00:58 <Psybur|Work> I believe its the case that if you have a type  [IO Char] -> IO [Char] then the return type is after the farthest right arrow?
06:01:11 <Psybur|Work> The final return type anyway
06:01:13 <iomotoko> well I already said it was a Char
06:01:19 <ertes-w> iomotoko: Char is not correct
06:01:20 <iomotoko> and that was not "quite right"
06:01:25 <iomotoko> yeah
06:01:30 <Psybur|Work> After the last arrow, not the very last word
06:01:42 <ertes-w> iomotoko: the type of seqn is not ([IO Char] -> Char)
06:01:50 <ertes-w> it's ([IO Char] -> IO [Char])
06:02:04 <marvin2> iomotoko, Char is not the same as [Char], or IO Char, or [IO Char]. those are three different types
06:02:09 <iomotoko> well but that's what I meant when I said it returns an output action
06:02:16 <iomotoko> it gets a list of IO (input/output) actions
06:02:22 <iomotoko> and returns an output action...
06:02:41 <ertes-w> iomotoko: in terms of what it returns, there are two aspects: the thing it returns (which is indeed an action), and the type of the thing it returns
06:04:25 <iomotoko> it returns a list of Chars
06:04:26 <ertes-w> iomotoko: you just said that the return type is Char, which is "not quite" correct, because it would imply that (seqn :: [IO Char] -> Char)
06:04:53 <ertes-w> iomotoko: but (seqn :: [IO Char] -> IO [Char]), so it returns something of type …?
06:05:20 <ertes-w> keep in mind that the "IO" is not just decoration…  it's part of the type =)
06:08:34 <marvin2> a -> b function takes a and returns b. [IO Char] -> IO [Char] function takes [IO Char] and returns?
06:08:54 <iomotoko> apparently there is an IO type in haskell?
06:09:06 <ventonegro> :k IO
06:09:07 <lambdabot> * -> *
06:09:12 <ertes-w> iomotoko: yes, there is
06:09:23 <ventonegro> :k IO Int
06:09:25 <lambdabot> *
06:09:35 <ertes-w> iomotoko: the answer is: IO [Char]
06:09:50 <ventonegro> :k IO [Char]
06:09:51 <lambdabot> *
06:10:16 <ertes-w> Psybur|Work: (sorry for ignoring you, but i wanted iomotoko to figure it out for themselves)
06:10:32 <iomotoko> so I give it a list of Chars and it returns a list of Chars, and the return value of seqn as a whole is IO [Char]
06:10:35 <kody> Haskell noob here. Does Haskell have a proviso for dependent types?
06:10:55 <ertes-w> iomotoko: you don't give it a list of characters…  you give it a list of actions that result in characters
06:11:08 <iomotoko> k, right, I could give it anything
06:11:11 <ertes-w> and it collapses that list into an action that returns a list of characters
06:11:39 <ertes-w> iomotoko: "action" is an actual thing…  (IO String) is not the same thing as String
06:11:46 <ventonegro> iomotoko: "IO a" is the type of an IO action that. when executed by the runtime, will produce a value of type "a"
06:12:20 <ertes-w> iomotoko: an "action" is literally an action, a computer program…  and that's why 'print' won't accept it
06:12:44 <ertes-w> 'print' does not know how to print programs…  it could, if anything, print their result
06:13:02 <ertes-w> main = do str <- seqn [getChar, getChar, getChar]; print str
06:13:05 <ertes-w> that would work
06:13:51 <marvin2> which is the same as: print =<< seqn [getChar, getChar, getChar]
06:14:09 <ertes-w> in haskell actions are (and really have to be) first-class values, much like integers or strings…  or functions
06:14:39 <MarcelineVQ> kody: not sure what you're after but haskell isn't quiiite a dependently typed language yet, there's the status of things here https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell (especially relevant is the last 3 paper links at the bottom)   and a great primer on using the current tech here  https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html
06:16:15 * hackagebot servant-auth-client 0.3.0.0 – servant-client/servant-auth compatibility – https://hackage.haskell.org/package/servant-auth-client
06:16:15 * hackagebot servant-auth 0.3.0.0 – Authentication combinators for servant – https://hackage.haskell.org/package/servant-auth
06:16:38 <iomotoko> ertes-w: yeah I just tried printing it with putStr and it said
06:16:39 <iomotoko> • Couldn't match type ‘IO’ with ‘[]’
06:16:39 <iomotoko>       Expected type: String
06:16:39 <iomotoko>         Actual type: IO [Char]
06:18:17 <ertes-w> iomotoko: exactly…  you were trying to print a *program* that would result in a String, not an actual String
06:18:32 <ertes-w> there is a nice quote on this
06:18:35 <ertes-w> @quote /bin/ls
06:18:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:19:51 <ertes-w> iomotoko: the function you wrote is haskell's idea of a control structure:  you're taking a list of actions and transforming it into an action that is a composite of all the individual actions
06:21:29 <ventonegro> Besides, Haskell gives you powerful ways to compose IO actions
06:21:40 <ventonegro> :t printStrLn <$> getLine
06:21:42 <lambdabot> error:
06:21:42 <lambdabot>     • Variable not in scope: printStrLn :: String -> b
06:21:42 <lambdabot>     • Perhaps you meant one of these:
06:21:57 <ventonegro> ooops
06:22:24 <ventonegro> :t putStr
06:22:26 <lambdabot> String -> IO ()
06:22:37 <ventonegro> :t putStr <$> getLine
06:22:39 <lambdabot> IO (IO ())
06:22:56 <ventonegro> :t getLine >>= putStr
06:22:57 <lambdabot> IO ()
06:23:27 <boristheblade> .
06:24:27 <cheater> is there something like criterion that i could use for timing whole binaries from the command line?
06:24:36 <ignamv> time?
06:24:37 <barrucadu> cheater: 'bench'
06:24:48 <cheater> ignamv: time doesn't do the stats
06:24:51 <barrucadu> @hackage bench
06:24:52 <lambdabot> http://hackage.haskell.org/package/bench
06:24:53 <cheater> barrucadu: i'll try that, thanks
06:24:58 <barrucadu> It's built on top of criterion
06:25:23 <cheater> just noticed :) thank you
06:29:32 <iomotoko> ertes-w: don't really know how to thank you for the time I've just wasted
06:29:50 <iomotoko> ertes-w: guess I will thank you by keeping trying my best w/ understanding haskell :3
06:30:11 <iomotoko> *you've just wasted
06:30:53 <sm> cheater: also quickbench
06:33:18 <ertes-w> iomotoko: it's not a waste, if it contributes to your learning =)
06:33:39 <kahlil29_> lyxia: doesn't seem to be working for me
06:34:46 <kahlil29_> I'm currently doing this : castInfo ^? responseBody . (key "cast")  
06:35:06 <kahlil29_> how do i then take the first 5 entries from that? 
06:35:07 <mnoonan> it's a good thing refactoring is so fun in Haskell, because I'm glad to annihilate this "idiom": evalState (do { modify (\c -> c {field updates}); get }) someRecord
06:35:29 <lyxia> kahlil29_: taking 5 (responseBody . key "cast")
06:35:49 <kahlil29_> oh on the outside. silly me. hold on
06:36:30 <tdammers> mnoonan: you mean the evalState (... >> get) part, instead of just execState (...)?
06:37:12 <mnoonan> tdammers, the whole thing is just an obtuse record update
06:37:26 <lyxia> kahlil29_: hmmm... Does key "cast" give you a traversal of each element, or does it return a Vector?
06:38:05 <kahlil29_> I think Vector. It starts like this : Just (Array [Object (fromList [("credit_id",String "543ecb490e0a2667450001db"),
06:38:20 <kahlil29_> taking 5 gives me the whole thing still 
06:38:37 <kahlil29_> castInfo ^? taking 5 (responseBody . (key "cast")) 
06:38:53 <tdammers> mnoonan: that's even worse
06:41:32 <cheater> in my cabal project, my executable has no dependencies other than my library. can i somehow make the build-depends of the executable get copied over from the library? i tried adding my library name to the build-depends of the executable and removing duplicates but then the packages don't get found.
06:42:21 <cheater> sm: thank you
06:46:19 <lyxia> kahlil29_: okay so you need to traverse the vector before taking.   taking 5 (responseBody . key "cast" . traverse)
06:46:50 <BernhardPosselt> what can cause a function to be wrapped in a Maybe?
06:47:01 <BernhardPosselt> e.g why dont people do
06:47:09 <BernhardPosselt> > fmap (+) Just
06:47:11 <lambdabot>  error:
06:47:11 <lambdabot>      • No instance for (Typeable a0)
06:47:11 <lambdabot>          arising from a use of ‘show_M51550785038876084085511’
06:47:49 <erisco> BernhardPosselt, what does the example show?
06:47:56 <sm> cheater: is does making your exe depend on your lib enough ? If not, I know you can avoid the redundancy by defining a top-level build-depends in a hpack package.yaml file
06:47:57 <erisco> :t Just (+)
06:47:58 <lambdabot> Num a => Maybe (a -> a -> a)
06:48:02 <ventonegro> BernhardPosselt: currying
06:48:03 <sm> s/does//
06:48:20 <erisco> you construct Maybe with a function the same way you construct it with other values
06:48:38 <BernhardPosselt> i mean i could also just map a function over a maybe right?
06:48:42 <BernhardPosselt> fmap (+) Just 1
06:48:45 <BernhardPosselt> > fmap (+) Just 1
06:48:47 <lambdabot>  error:
06:48:48 <lambdabot>      • No instance for (Typeable t0)
06:48:48 <lambdabot>          arising from a use of ‘show_M31631562675298496035555’
06:48:56 <erisco> > fmap (+1) (Just 1)
06:48:59 <lambdabot>  Just 2
06:49:00 <Psybur|Work> :t fmap (+) Just 1
06:49:01 <erisco> yes, sure
06:49:01 <lambdabot> (Num (Maybe t), Num t) => Maybe t -> Maybe t
06:49:10 <BernhardPosselt> hm, doesnt fmap curry?
06:49:17 <srhb> BernhardPosselt: The problem is precedence.
06:49:17 <erisco> fmap is curried
06:49:38 <Psybur|Work> > fmap (+) Just 1 $ Just 2
06:49:40 <lambdabot>  error:
06:49:40 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M376165000475...
06:49:40 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
06:49:42 <Psybur|Work> :D
06:49:52 <srhb> BernhardPosselt: (+) Just 1, that's three arguments.
06:50:12 <ventonegro> :t fmap (+) (Just 1)
06:50:13 <lambdabot> Num a => Maybe (a -> a)
06:50:17 <BernhardPosselt> my real question is: why use <*> over fmap
06:50:19 <ventonegro> There you go
06:50:36 <erisco> because you cannot implement f (a -> b) -> f a -> f b with fmap
06:50:39 <BernhardPosselt> cant think of an example where id ever wrap the function in a Maybe first 
06:50:52 <ventonegro> :t (fmap (+) (Just 1)) <*> Just 2
06:50:54 <erisco> > (+) <$> Just 1 <*> Just 2
06:50:54 <lambdabot> Num b => Maybe b
06:50:56 <lambdabot>  Just 3
06:51:03 <erisco> you can't do that with fmap
06:51:12 <BernhardPosselt> why?
06:51:15 <erisco> try it
06:51:21 <ventonegro> BernhardPosselt: types
06:51:37 <BernhardPosselt> because function != value?
06:51:41 <Ferdirand> because you can't turn f (a -> b) into (a -> b)
06:51:43 <erisco> just try it
06:53:21 <BernhardPosselt> ah
06:53:27 <marvin2> :t fmap (+) (Just 10)
06:53:29 <lambdabot> Num a => Maybe (a -> a)
06:53:32 <BernhardPosselt> fmap (fmap (+) (Just 1)) (Just 3)
06:53:46 <BernhardPosselt> Couldn't match expected type ‘Integer -> b’  actual type ‘Maybe (Integer -> Integer)’
06:54:10 <BernhardPosselt> unless i made a mistake
06:54:51 <byorgey_> BernhardPosselt: you made a mistake =)
06:54:54 <ventonegro> BernhardPosselt: the types of <$> are <*> are similar, but they are not the same
06:55:05 <byorgey_> BernhardPosselt: what type is   (fmap (+) (Just 1))?   What type does  fmap  expect?
06:55:33 <BernhardPosselt> byorgey_: aaah
06:55:41 <erisco> :t \a b -> fmap (\x -> fmap ($) a) b
06:55:43 <lambdabot> (Functor f1, Functor f) => f1 (a1 -> b) -> f a -> f (f1 (a1 -> b))
06:55:54 <Iceland_jack> erisco: that's (??) btw :)
06:55:55 <erisco> I messed that up
06:56:18 <Iceland_jack> xs ?? a = fmap ($ a) xs
06:56:18 <erisco> :t \a b -> fmap (\x -> fmap ($x) a) b
06:56:20 <lambdabot> (Functor f1, Functor f) => f1 (a -> b) -> f a -> f (f1 b)
06:56:27 <Iceland_jack> A generalization of flip
06:56:35 <Iceland_jack> @let xs ?? a = fmap ($ a) xs
06:56:36 <erisco> this is as close as we're getting with fmap
06:56:37 <lambdabot>  Defined.
06:57:46 <Ferdirand> > ((+) <$> [0, 1]) <*> [0,10]
06:57:48 <lambdabot>  [0,10,1,11]
06:58:28 <byorgey_> > (+) <$> [0,1] <*> [0,10]   --  parentheses not required
06:58:28 <Ferdirand> clearly this cannot be implemented with fmap, or it would break the fact that fmap and length commute
06:58:31 <lambdabot>  [0,10,1,11]
06:58:32 <BernhardPosselt> so tl;dr: you cant use fmap because Maybe (a -> b) does not match (a -> b)
06:58:32 <cheater> sm: hmm i just noticed that in my Main i depend on a lot of other modules too. So I'll be doing this: https://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file
06:58:43 <byorgey_> BernhardPosselt: exactly.
06:58:45 <Ferdirand> the parentheses were intended
06:58:52 <byorgey_> Ferdirand: oh, I like that explanation.
06:58:56 <byorgey_> Ferdirand: ok, fair enough.
06:59:27 <kahlil29_> lyxia: with traverse I'm getting some type errors. not sure what's wrong :/
06:59:31 <BernhardPosselt> http://www.reactiongifs.com/wp-content/uploads/2013/10/tim-and-eric-mind-blown.gif
06:59:34 <erisco> Ferdirand, can you explain for me? what are fmap and length commuting over?
07:00:17 <Ferdirand> erisco: that was a bit awkwardly worded maybe, but
07:00:56 <Ferdirand> for all f :: (a -> b), (length . fmap f) == length
07:02:41 <erisco> is that called absorbing? I dunno. anyways, how does that connect with Applicative?
07:02:49 <lyxia> kahlil29_: can you paste it
07:04:02 <Ferdirand> well, in my example, you can see that [0,10] and [0,10,1,11] are not the same length
07:04:51 <Ferdirand> so if this property holds, then there cannot be a f such that (((+) <$> [0, 1]) <*>) == fmap f
07:05:59 <kahlil29_> what if i use fmap over the result instead of take? 
07:06:02 <Ferdirand> this can probably be reworded better
07:06:09 <kahlil29_> lyxia: 
07:06:11 <lyxia> erisco: It "commutes" in the sense that the polymorphic function length is a natural transformation between functors [] and Const Int, characterized by a certain commutating square.
07:06:49 <erisco> oh, category theory sort of commuting, love it, I'll have you explain that to me in a few months ;)
07:07:26 <BernhardPosselt> there's so much awesomeness hidden in haskell, its really a pity that its so inaccessible
07:07:39 <ventonegro> it's not, actually
07:07:55 <ventonegro> just takes more than 21 days to get there
07:08:13 <BernhardPosselt> documentation and naming is not as nice as it could be
07:08:18 <erisco> I see where you're going Ferdirand because length . ([a,b] <*>) == (*2) . length
07:10:05 <lyxia> erisco: as an equation you end up with   length . fmap @[] f == fmap @(Const Int) f . length   and fmap @(Const Int) f = id, more or less.
07:11:59 <erisco> so  (`div` 2) . length . ([a,b] <*>) == length == length . fmap f  thus  (*2) . length == length  which is absurd
07:14:31 <erisco> let me write that out on a page... seems weird
07:14:57 <erisco> that's the problem with aiming for an answer... the brain tends to find it whether it is logical or not
07:15:45 <iomotoko> does any1 know good example code? meaning a collection of "smaller" standalone haskell programs?
07:15:49 <iomotoko> maybe a github repo to check out?
07:16:13 <iomotoko> ofc there is a lot of stuff, but quite a lot of stuff also is quite complex (for example xmonad wm or such)
07:16:46 <iomotoko> (and the difficulty there is probably not so much w/ haskell and more with X.org itself (which is a mess to begin w/))
07:19:20 <erisco> yeah that is a load of rubbish now that I write it out
07:21:09 <erisco> the way it is supposed to work is we begin with the hypothesis length . ([a,b] <*>) == length . fmap f
07:21:32 <erisco> now after two substitutions we get (*2) . length == length and there's the proof
07:22:40 <[exa]> is there some reasonable LLVM binding for haskell?
07:23:08 <[exa]> (e.g. without IO everywhere?)
07:23:40 <alexbiehl> llvm-hs-pure and llvm-hs
07:24:01 <erisco> and this is a fine way to demonstrate "not all Functors are Applicatives"
07:24:14 <[exa]> yay, llvm-hs-pure is the thing
07:24:17 <[exa]> thanks alexbiehl
07:25:08 <erisco> by way of the equivalence there exists a Functor which is not an Applicative
07:25:43 <erisco> though we're being careful not to claim that lists themselves are not an Applicative, but rather than the list instance of Functor is insufficient to derive the Applicative instance of list
07:27:41 <erisco> this proof was done with LEM though, so do we really trust it? :P
07:30:32 <erisco> BernhardPosselt, that can be said of everything ever
07:32:55 <erisco> and don't be so surprised... if everything was easy and accessible then it would already be commonplace and you wouldn't even be talking about it ;)
07:37:32 <byorgey> erisco: I don't think the proof uses LEM.
07:38:17 <byorgey> erisco: why do you say it does?
07:39:43 <erisco> byorgey, maybe I do not understand the finer points which distinguish the law of noncontradiction from the the law of excluded middle
07:39:48 <lyxia> kahlil29_: sure, that works
07:40:31 <dolio> I don't think it actually establishes the stated result.
07:40:46 <erisco> okay, poke holes
07:41:06 <erisco> I'll just blame Ferdirand ;)
07:41:23 <dolio> Just because you can't use the functorial structure to derive the applicative structure doesn't mean that the latter structure doesn't exist in all cases.
07:41:38 <dolio> It doesn't, but you can't make that inference.
07:42:09 <erisco> I thought I worded it correctly... "not all Functors are Applicatives"
07:42:15 <erisco> you only require one example
07:42:30 <byorgey> but your proof does not show that lists are not Applicative!
07:42:36 <erisco> it doesn't have to
07:43:10 <byorgey> so then how do you conclude that not all Functors are Applicatives?
07:43:33 <erisco> because I have shown that the list instance of Functor cannot derive the list instance of Applicative
07:43:59 <dolio> And I already said that the inference from that to 'not all Functors are Applicatives' is a non sequitur.
07:44:03 <byorgey> all that proves is that an Applicative instance for list---if it exists---cannot be defined solely in terms of fmap.
07:44:26 <erisco> we know it exists, that is what we are using for the proof
07:44:42 <dolio> In this very case, List _is_ applicative, even though you can't use just the functor structure to show it.
07:44:44 <byorgey> ok, fine.
07:44:53 <erisco> and by showing it cannot be defined by fmap is exactly what we need to do
07:44:55 <dolio> So you have to prove that that doesn't always happen.
07:45:22 <erisco> I frankly do not understand the objection dolio, but I am trying to
07:46:22 <byorgey> erisco: one reason there might always be an Applicative instance for every Functor would be that we can always implement Applicative in terms of fmap.  The proof shows that is not the case.  But that does *not* imply that there is *not* always an Applicative instance for every Functor.
07:46:57 <byorgey> sigh, English is failing us.  We need to write down some quantifiers.
07:47:27 <cocreature> [exa]: llvm-hs-pure contains the AST, llvm-hs is used to operate on that AST and JIT it, compile it to object code or whatever else you want to do
07:50:16 <erisco> okay, you are saying that I have not shown being a Functor is necessary to being an Applicative
07:50:34 <dolio> No.
07:51:20 <dolio> Here's another example.
07:51:37 <cheater> if i have f: a -> b -> c and i have as = [a] and bs = [b] I can do f <$> as <*> bs right?
07:51:39 <dolio> You cannot produce a unit element from the binary operation of a semigroup.
07:52:06 <dolio> You cannot deduce from this that not every semigroup is a monoid.
07:52:10 <cheater> what if bs = Maybe b?
07:52:25 <cheater> er bs :: Maybe b
07:52:47 <kadoban> cheater: Use maybeToList first?
07:52:48 <marvin2> then as has to be Maybe a
07:52:50 <dolio> Because the first fact doesn't mean that there doesn't happen to exist a unit element in every semigroup.
07:53:07 <marvin2> ^^ or that
07:53:13 <dolio> Just that the binary operation is insufficient to produce it.
07:54:19 <erisco> okay, then I point to my second clarification I said when I gave the conclusion
07:54:19 <cheater> ok, what if i still have f: a -> b -> c and i have as = [a] and a single b? How do I go about this?
07:54:32 <erisco> <erisco> though we're being careful not to claim that lists themselves are not an Applicative, but rather than the list instance of Functor is insufficient to derive the Applicative instance of list
07:54:55 <kadoban> cheater: pure b   or [b]
07:55:16 <cheater> hm ok
07:55:28 <erisco> this is all I meant by "not all Functors are an Applicative". I could more clearly say that as "not all Applicative instances can be derived by a Functor instance"
07:55:34 <mnoonan> or (`f` b) <$> as
07:55:48 <erisco> the original question we were addressing was precisely whether (<*>) could be defined in terms of fmap
07:56:00 <dolio> Right. That's a different proposition, though. :)
07:56:08 <cheater> interesting mnoonan 
07:56:12 <dolio> Or, it is to me.
07:56:17 <erisco> well I said it poorly then which is why I also added that clarification
07:56:43 <cheater> erisco: Applicative has more assumptions than Functor so i'd say no
07:57:01 <dolio> They're both true propositions, though.
07:58:01 * hackagebot haskell-src-exts-util 0.1.0 – Helper functions for working with haskell-src-exts trees – https://hackage.haskell.org/package/haskell-src-exts-util
07:58:54 <choe_2> Given data Fix f = Fix (f (Fix f), why does Fix 3 work, evaluating to the type: Fix 3 :: Num (f (Fix f)) => Fix f  ?
07:59:12 <erisco> :t 3
07:59:14 <lambdabot> Num t => t
07:59:37 <erisco> 3 can assume any type, and later we figure out if a Num instance exists for that type
08:01:01 <choe_2> the type of the data constructor Fix is f (Fix f) -> Fix f; I don't understand how 3 is the type of f (Fix f), but 'A' isn't?
08:01:23 <dolio> > case 3 of Const x -> x
08:01:25 <lambdabot>  3
08:01:37 <mbw> Is there a straight-forward monadic function that allows to traverse a list and return a different number of results? Right now I have a large 'forM' loop, which does some side effects, and returns a Maybe. I filter on 'isJust' over this result list. I presume I could make use of the list Alternative instance somehow, but I couldn't get this to work, and I don't have a reasonable predicate for 'guard' either.
08:01:44 <dolio> 3 is overloaded and 'A' isn't.
08:02:08 <mbw> Would this be filterM?
08:02:11 <choe_2> and why does the type f (Fix f) mean an overloaded type?
08:02:56 <dolio> 3 has type `Num t => t`. The t matched with `f (Fix f)`.
08:03:16 <dolio> 'A' has type `Char`, which doesn't match with `f (Fix f)`.
08:03:29 <choe_2> oh. I think that helps.
08:03:42 <erisco> mbw, I don't know, is it? what do you want to do when traversing the list? return a different number of results I hear, but I don't think that is all you intend
08:04:27 <choe_2> so any concrete polymorphic type can match with f (Fix f), correct?
08:04:48 <cheater> is there a better idiom for f (zip (repeat x) (foo bar baz)) ?
08:04:50 <erisco> concrete polymorphic is like solid liquid
08:04:52 <dolio> That's kind of an oxymoron. :)
08:05:05 <choe_2> erisco: oh, I guess I mean of kind *
08:05:10 <choe_2> meant*
08:05:30 <mbw> erisco: I have a list of links. Each element of this is used for an http request, the result is parsed, some logging is done, etc. Each element can either yield a result, or not (in which just the logging is done and nothing is returned).
08:06:00 <mbw> "Nothing" in the sense that there is one result less to return...
08:06:32 <mnoonan> cheater: f ( (x,) <$> foo bar baz ) works, but seems like preference more than anything
08:06:46 <erisco> so you have some x :: [IO (Maybe A)] ?
08:07:22 <mbw> erisco: The type signature is:
08:07:38 <mbw> getAllLinks :: (MonadHttp m, MonadWriter Results m)$ 
08:07:39 <mbw>             => Parser$
08:07:39 <mbw>             -> [Link Gallery]$
08:07:39 <mbw>             -> m [[(JPG, Link TargetJPG)]]$
08:07:58 <mbw> (Ignore the '$', that's line endings displayed by vim).
08:08:06 <mbw> i.e. the Nothings are filtered out.
08:08:29 <mbw> So basically [a] -> IO [b].
08:08:31 <mbw> :/
08:08:54 <erisco> I am not sure what the question is. You have some list, yes? And you want to do something with that list, yes? What is it that you want to do?
08:10:15 <erisco> maybe you have something convoluted going on and you're not quite sure what it is you need
08:10:19 <mbw> erisco: I loop over this list with forM. However, in each iteration I have to return some result value, although I'm not able to. So I return a Maybe, and run filter on it again. Normally I could use something like 'guard'.
08:10:30 <cocreature> :t \f xs -> catMaybes <$> traverse f xs
08:10:31 <lambdabot> Applicative f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
08:11:24 <mbw> What I have right now works just fine. I just thought it could be done more elegantly/directly, using a special-purpose function.
08:11:50 <mbw> What cocreature suggested is basically what I have now.
08:13:02 <erisco> mbw, perhaps use mzero, i.e. []
08:13:08 <cocreature> extra seems to call it mapMaybeM https://hackage.haskell.org/package/extra-1.6/docs/Control-Monad-Extra.html#v:mapMaybeM
08:13:35 <cocreature> but tbh I wouldn’t bother searching for these special-purposes functions if you can just as easily compose existing functions
08:15:11 <mbw> I was trying to use empty/mzero, but didn't get it to work. Importing another library doesn't seem to be worth it either.
08:15:32 <erisco> mbw, so you have some f :: a -> Maybe b and some xs :: [a], then yes we can find xs :: [Maybe b], but instead if we g :: a -> [a] then we can find xs' :: [a] by xs' >>= g
08:15:43 <mbw> I think I will just stick with what I've got, i.e. forM + (r ^.. each._Just).
08:15:51 <erisco> so we're just swapping Just for (:[]) and Nothing for []
08:17:23 <mbw> erisco: Is this the same as using the MonadPlus/Alternative instance?
08:17:50 <erisco> mzero = empty = mempty = [] for lists
08:18:17 <tabaqui> have I a chance to define Eq instance for GADTs with constraints?
08:18:22 <tabaqui> like 
08:18:25 <tabaqui> data Foo where
08:18:29 <erisco> :t (maybeToList .) -- in case you want to keep your Maybes
08:18:30 <tabaqui>   A :: Maybe Int -> Foo
08:18:31 <lambdabot> (a1 -> Maybe a) -> a1 -> [a]
08:18:37 <tabaqui>   B :: -> Maybe Bool -> Foo
08:18:38 <ertes-w> mbw: do you need all the results in an actual data structure?
08:18:48 <mbw> erisco: The maybes were just a crutch
08:18:59 <tabaqui> how can I compare such type?
08:19:01 <ertes-w> mbw: or would it suffice to be able to process each result individually?
08:19:12 <cocreature> tabaqui: what problems did you run into when trying to write the Eq instance?
08:19:18 <cocreature> seems like it should work just fine
08:19:36 <cocreature> that’s not even a GADT, you are just using GADT syntax
08:19:44 <tabaqui> cocreature: when I write just "derive instance Eq..", I get 'Constructor ‘TA’ has existentials or constraints in its type'
08:19:50 <cocreature> oh I think you might have screwed up the "B" case
08:19:52 <erisco> trivial GADTs are GADTs too
08:19:57 <tabaqui> *TA is my type
08:19:58 <cocreature> something should probably go before the "->"
08:20:04 <tabaqui> *type constructor
08:20:23 <tabaqui> oh, no, B :: Maybe Bool -> Foo
08:20:25 <tabaqui> of course
08:20:59 <tabaqui> well, I hide some types inside type constructors
08:21:04 <cocreature> what do you hide?
08:21:06 <tabaqui> and cannot compare them
08:21:19 <mbw> ertes-w: The iterations are all independent.
08:21:22 <cocreature> A contains the concrete type "Maybe Int" and B "Maybe Bool"
08:21:26 <tabaqui> pastebin, wait a sec
08:21:27 <cocreature> I don’t see the existential
08:22:33 <tabaqui> https://pastebin.com/mvGV2SPg
08:22:43 <tabaqui> yeah, Foo example is wrong
08:23:45 * hackagebot HDBC 2.4.0.2 – Haskell Database Connectivity – https://hackage.haskell.org/package/HDBC
08:24:03 <ertes-w> mbw: in that case i would most likely use stream processing
08:24:21 <tabaqui> dunno, maybe I cannot cook GADTs, it works fine for my requirements before, but now I cannot event write tests for 'em
08:24:29 <ertes-w> mbw: e.g. the 'machines' library, if you don't mind the learning curve
08:25:00 <mbw> ertes-w: Is there a particular reason why you would recommend this?
08:25:43 <tabaqui> any thoughts? (FS, FA, JSON, NotJSON is usual bottom types)
08:25:45 <tabaqui> *are
08:26:16 <cocreature> tabaqui: can you please make an example that’s not missing all imports. I need to play with this in ghci
08:26:36 <tabaqui> cocreature: yeah
08:28:44 <ertes-w> mbw: concurrency…  usually with monadic loops either you lose composability (like 'traverse_'), or you lose concurrency and efficiency (because you need to collect *all* results before the next step can commence
08:28:46 <ertes-w> )
08:29:04 <cocreature> tabaqui: something like http://lpaste.net/357868 should do the job
08:29:15 <cocreature> you need a heterogenous equality on FromAgents and FromScans
08:29:25 <ertes-w> mbw: stream processing interleaves all steps and is still composable
08:30:25 * hackagebot network-transport-tests 0.2.4.1 – Unit tests for Network.Transport implementations – https://hackage.haskell.org/package/network-transport-tests
08:30:25 * hackagebot HDBC-postgresql 2.3.2.5 – PostgreSQL driver for HDBC – https://hackage.haskell.org/package/HDBC-postgresql
08:31:19 <cheater> is there a way to write a type function such that it takes a -> b -> c and returns a -> b -> [c]?
08:31:25 <tabaqui> cocreature: https://pastebin.com/8u8SCHgx
08:32:02 <erisco> cheater, sure can, what have you tried so far?
08:32:24 <erisco> show me your attempts and then show you a tool to see if we can cheat
08:32:43 <erisco> then I'll show you*
08:33:06 <erisco> malware detected in brain-to-text.exe
08:33:45 <tabaqui> cocreature: oh, I'm stupid, you've just defined generic comparsion and redefine Eq with it
08:34:14 <tabaqui> I think it fits
08:34:16 <tabaqui> thank you
08:34:23 <dsal> @pl \st -> filter (bit b) [1..16] where b = read2 120 st
08:34:23 <lambdabot> (line 1, column 40):
08:34:23 <lambdabot> unexpected " "
08:34:23 <lambdabot> expecting operator
08:34:24 <erisco> by the time I am 80 a 30 word sentence will come out as 20 words in all different tenses, homophones, pluralisations, and probably say the exact opposite of what I meant
08:35:43 <ertes-w> erisco: that's ok…  by the time you're 80 a 30 word sentence will be way above the average attention span
08:35:57 <erisco> haha, no one will notice, excellent :P
08:37:55 * hackagebot network-transport-tcp 0.6.0 – TCP instantiation of Network.Transport – https://hackage.haskell.org/package/network-transport-tcp
08:38:26 <tabaqui> cocreature: but it takes so much space, I'll try to reduce something
08:39:50 <mbw> ertes-w: Sounds reasonable. However I don't think I will need this for my particular case, since it's more or less just a toy program (at this stage). Also I still have to get my types in order.
08:41:24 <ertes-w> mbw: if you have enough time, it may pay off to learn it anyway…  it's a very thin yet very useful abstraction layer
08:41:29 <mbw> ertes-w: But is there a difference between the 'machines' library and something like pipes/conduit?
08:42:08 <ertes-w> mbw: they all do more or less the same thing, and the differences are subtle
08:43:37 <ertes-w> mbw: 'machines' has the PlanT/MachineT split that the others lack, which makes it both more efficient, and the MachineT API is simpler, while still being powerful enough to encode the whole Proxy type from 'pipes'
08:43:49 <ertes-w> whereas pipes relies on rewrite rules to achieve the same efficiency
08:44:59 <mbw> ertes-w: What I am writing is an interactive image scraper with a GUI frontend. Actually I already have a working and mostly robust implementation. However I decided to rework it to make it extensible with different parsers. The specific loop I was talking about previously was something containing a lot of state, describing when to load the next set of images etc. I was trying to instead use a function that 
08:45:05 <mbw> semantically loads everything at once, and hope lazyness would take care of the rest.
08:46:24 <ertes-w> mbw: stream processing will definitely help with that…  in fact it's something i have done myself in the past:  use a site API to load the first 50 items, yield them one by one, and once the 51st is requested, load the next 50, etc.
08:46:58 <ertes-w> i went as far as to separate even the 'list' step from the actual 'load' step
08:47:17 <Arguggi> anyone know if this pr https://github.com/benl23x5/gloss/pull/23 for gloss was accepted anywhere else? Or how to save a gloss Picture to a file?
08:47:52 <ertes-w> mbw: conceptually: listItems :: (MonadIO m) => SourceT m [Item]
08:48:20 <ertes-w> mbw: conceptually: loadItem :: (MonadIO m) => ProcessT m Item (Item, ItemData)
08:48:22 <ertes-w> etc.
08:49:06 <ertes-w> in pipes/conduit terminology SourceT becomes Producer/Source, and ProcessT becomes Pipe/Conduit
08:49:11 <cheater> erisco: i haven't tried anything, i wouldn't know how to start
08:49:17 <cheater> i'm not great with type families
08:50:05 <erisco> cheater, maybe I misunderstood. Are you sure you need type families? I thought what you wanted was to map a function f :: a -> b -> c to a function f' :: a -> b -> [c]
08:50:12 <cocreature> ertes-w just loves taking away the toys people love. first he tries to take away manual recursion from you, then he comes for the streaming libraries you know and love … I’m scared of what comes next :P
08:50:35 <mbw> ertes-w: On the other hand if I use a gtk frontend, I will have to synchronize between event handlers using IORefs. This makes everything more complicated.
08:51:12 <cheater> no erisco, i would like to transform a type to another type.
08:51:14 <mbw> cocreature: Probably all the Co* stuff?
08:51:47 <cheater> erisco: i have a lot of functions here that look like f1 :: a -> b -> c and then f1' :: a -> b -> [c]
08:51:55 <cheater> a lot of pairs of functions like these
08:51:56 <ertes-w> cocreature: the thing you don't realise is that i'm your redeemer…  it is by my advice that you are saved from the eternal abstraction hell
08:52:04 <erisco> cheater, okay. Is a -> b -> c to a -> b -> [c] just one example or is there a larger relation?
08:52:21 <erisco> I mean is that the only case
08:52:21 <cocreature> mbw: if you try to take the co from my name, there will be blood
08:52:54 <ertes-w> cocreature: and if you don't like it, there is one simple solution: just go with it…  you will praise me eventually
08:52:54 <mbw> cocreature: So you won't cooperate it seems...
08:53:24 <cocreature> ertes-w: I have another simple solution: I just stick with what I use :P
08:53:31 <ertes-w> mbw: i don't know your architecture, but i'd do frontends with FRP anyway =)
08:53:43 <cocreature> mbw: someone has to start building up the resistance
08:53:47 <ertes-w> cocreature: you can't do that…  i'm full of needful things!
08:56:47 <erisco> cheater, what I mean is, we wouldn't usually just write a function f 1 = 2
08:57:52 <mbw> ertes-w: frp sounds nice and all, but I don't want to run stuff in my browser or spend a day trying to get all of this to run with stack etc. Also, since this is my first semi-serious project using haskell, there already was a lot of learning involved. That is, url escaping rules, html/xml parsing, lenses, mtl (or rather, sensible use of), gi-gtk, different http-client libraries, etc. etc. I am not exactly 
08:57:58 <mbw> looking forward to adding more complexity at this time :/
08:58:24 <erisco> that is a wise decision
08:58:50 <erisco> decide what your project is. Is your project really to finish a product or is it to spiral off into learning more technologies?
08:58:56 <ertes-w> mbw: understandable
08:59:13 <erisco> there's a reason I can't finish a product
09:00:12 <trigone> hi! i was reading , and i read "Modules may be mutually recursive." yet sometime in the past i had asked here and they'd told me haskell did not permit cycling imports... so i'm wondering what is right :)
09:00:54 <ertes-w> trigone: both =)
09:01:14 <ertes-w> trigone: haskell doesn't support it, but GHC has a rather ugly facility to enable cyclic imports
09:01:22 <kadoban> trigone: You can do them in GHC at least. It's a bit of a pain in the ass though.
09:01:26 <ertes-w> through .hs-boot files
09:01:34 <MarcelineVQ> what does it mean for modules to be mutually recursive?
09:01:37 <ertes-w> trigone: i don't recommend doing it though
09:01:46 <ertes-w> MarcelineVQ: A imports B, B imports A
09:02:46 * hackagebot arrowp-qq 0.2 – A preprocessor and quasiquoter for translating arrow notation – https://hackage.haskell.org/package/arrowp-qq
09:02:47 <geekosaur> ertes-w, actually Haskell does explicitly support it, ghc is the one that doesn't (except via the hs-boot hack which is explicitly acknowledged as a wart)
09:02:50 <dolio> The Haskell Report says modules may be mutually recursive.
09:03:06 <ertes-w> ah, sorry
09:03:10 <tdammers> damn, TIL
09:03:34 <ertes-w> i wonder why GHC doesn't support it
09:03:42 <dolio> Because it's hard. :)
09:04:17 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#module-system-and-interface-files
09:04:29 <tdammers> It's not hard per se, but if you also want incremental builds, it is
09:04:38 <geekosaur> so ghc squeaks by on a technicality
09:04:40 <ertes-w> it would require a typical dependency resolution or constraint satisfyability algorithm, wouldn't it?
09:05:16 <geekosaur> and yes, the combination of separate compilation and recursive imports makes it painful at best
09:05:17 <tdammers> otherwise you could just do something simple like concatenate all the modules in the project into one large compilation unit, desugar module namespaces, erase module declarations, and compile the whole thing as one flat megamoule
09:05:22 <tdammers> megamodule*
09:05:32 <ertes-w> ah, separate compilation…  good point
09:05:34 <dolio> Right.
09:05:36 <geekosaur> jhc did that, essentially
09:05:54 <mud> tdammers: Ya I was wondering why that wouldn't work, I forgot that the user experience would suck a lot xD
09:06:32 <tdammers> mud: it would work, but then you'd have to recompile everything whenever any module changes
09:06:51 <mud> Yeah, that'd be pretty bad
09:07:06 <dolio> You could be less terrible about it than that.
09:07:23 <dolio> Find connected components and only recompile those.
09:07:43 <tdammers> not if you compile the whole thing as one module
09:07:57 <tdammers> unless you can dissect the compiler output and somehow replace parts of it
09:08:00 <dolio> Right, that would be what you're being less terrible than.
09:09:03 <trigone> thx all, i see more clearly now :) just to check, it's the same with levels of indirection, eg A => B => C => A (with => meaning imports)
09:09:10 <trigone> ?
09:09:34 <geekosaur> yes
09:09:44 <trigone> ok thx :)
09:10:11 <ertes-w> trigone: basically your import structure needs to look like a tree
09:10:45 <ertes-w> actually it can look like a DAG
09:10:47 <trigone> ertes-w: not like a DAG?
09:11:00 <ertes-w> trigone: ^
09:11:03 <trigone> k. are DAGs types of trees? or maybe the opposite
09:11:17 <ertes-w> trees are special cases of DAGs
09:12:01 <trigone> ok thx :)
09:15:41 <norc_> Can someone explain to me how haskell knows to produce a list out of nothing? https://gist.github.com/anonymous/7798a36ed53dcfa8c1327f3df037af10
09:16:39 <norc_> There is no empty list [] to : into, which is why Im confused as hell
09:17:39 * hackagebot arrowp-qq 0.2.0.1, distributed-process 0.7.0, distributed-process-tests 0.4.8
09:17:39 * hackagebot  → https://hackage.haskell.org/packages/recent
09:18:04 <dsal> > let f = 1 : f in take 5 f
09:18:06 <lambdabot>  [1,1,1,1,1]
09:19:09 <ertes-w> norc_: take 10 reqs = take 10 (client ini resps) = take 10 (0 : client …) = 0 : take 9 (client …)
09:19:27 <ertes-w> norc_: just follow your own definitions and read "=" as "equals"
09:19:31 <geekosaur> norc_, the trick here is that client has that ~ in the pattern match
09:19:44 <geekosaur> so, the first time it is run, it doesn't look at the list (which doesn't exist yet) but immediately produces ini
09:19:53 <geekosaur> which is used as the seed to create the list
09:20:09 <dsal> What's that ~ thing, btw?
09:20:10 <geekosaur> by the time the lazy pattern match is invoked, the first element of the list exists and can be processed
09:20:12 <ertes-w> for the first element understanding the "~" is not even necessary
09:20:16 <geekosaur> it makes the pattern match lazy
09:21:01 <geekosaur> instead of immediately matching the list (which doesn't exist yet and would if you are lucky throw an exception, or if not go into an infinite loop) it defers it so it can produce ini
09:21:40 <monochrom> A UML sequence diagram is in order. >:)
09:21:43 <geekosaur> laziness lets you pull off self-referential stuff like this
09:22:04 <dsal> Hmm...  I may remember that exists when I need it.  :)
09:23:01 <geekosaur> as long as you can produce the first element(s) needed to "bootstrap" the lazy list without looking at the list, you can do this.
09:23:45 <geekosaur> lazy memoized fibonacci uses the same trick, always generating the next list element "just in time"
09:23:51 <norc_> geekosaur: so at what time does the pattern match occur?
09:23:59 <norc_> geekosaur: And to what exactly?
09:24:06 <norc_> Only the outer most "shell" ?
09:24:25 <norc_> Because it clearly cant match into the entire recursion, because that would fail with the final element
09:24:48 <geekosaur> the pattern match occurs when client processes (next resp) which uses resp from the pattern match
09:25:09 <geekosaur> but before client gets there, it produces (ini : _|_)
09:25:19 <norc_> This example feels so out of place in the gentle introduction. Everything until that was crystal clear.
09:25:44 <dsal> I was trying to use https://hackage.haskell.org/package/HUnit-approx-1.1/docs/Test-HUnit-Approx.html yesterday, but found the operators confusing.  How does one use an operator that has an implicit parameter?
09:25:55 <geekosaur> that observation is why the "gentle" introduction isn't so gentle...
09:27:16 <norc_> Okay, time to annotate the code. Perhaps that will help me grasp it
09:27:33 <geekosaur> so anyway, whne something wants the next element of the list (here, it's forced by ghci printing the result, one item at a time), resp is defined (as 1), resps isn't but it's just passed on as a thunk. and client doesn't look at it the next time either, it computes (next resp) (which is 2) and produces it, deferring the rest again
09:28:28 <cheater> erisco: no it is just that case
09:28:42 <geekosaur> and just repeats that pattern, each time generating the next list element, which is just enough to let it generate the element after that...
09:28:42 <cheater> erisco: i mean the functions might make more or less parameters
09:28:50 <cheater> erisco: but i'd be happy with just a -> b -> c
09:29:02 <erisco> cheater, type family F a where F (a -> b -> c) = a -> b -> [c]
09:30:02 * hackagebot ticker 1.0.0 – A concurrent utility inspired by Ticker in golang – https://hackage.haskell.org/package/ticker
09:30:04 <erisco> f :: * -> *; f (a -> b -> c) = a -> b -> [c]   you can read it just like that
09:31:39 <erisco> is there any package like data-reify which works with polymorphic recursion?
09:32:24 <geekosaur> norc_, you might want to set up ghc-vis and single step the program to watch it work. it should show a progression in the value of reqs
09:32:39 <norc_> geekosaur: Ohh, ertes-w' tip actually helped me understand whats going on.
09:32:56 <norc_> but ghc-vis sounds like I should try it out
09:33:25 <geekosaur> _|_ --> ( _|_ : _|_ ) --> ( 1 : _|_ ) --> ( 1 : ( _|_ : _|_ ) ) --> ( 1 : ( 2 : _|_ ) ) --> ...
09:35:38 <ertes-w> norc_: BTW, (f ~(x:xs) = g x xs) is the same thing as (f xs = g (head xs) (tail xs))
09:35:52 <ertes-w> norc_: if you get rid of the pattern and use 'head' and 'tail' instead, it may become clearer
09:36:00 <erisco> there is a trick to replace self-recursive sites with a variable (in data types)
09:36:19 <erisco> this lets you have the original data type with Mu but also others
09:36:28 <erisco> but then consider a type such as  data Expr a where App :: Expr (a -> b) -> Expr a -> Expr b
09:36:52 <erisco> data Expr a s where App :: s -> s -> Expr b s
09:36:57 <erisco> that just doesn't work
09:37:18 <erisco> data Expr a s where App :: s (a -> b) -> s a -> Expr b s   this does work, but s :: * -> * now
09:37:43 <erisco> hopefully I am missing something obvious here
09:38:43 * hackagebot distributed-process-tests 0.4.9 – Tests and test support tools for distributed-process. – https://hackage.haskell.org/package/distributed-process-tests
09:41:01 <choe_2> Isn't 'Maybe a' somehow less polymorphic than the type 'a'? How can it match with f (Fix f)? Can someone explain the "base case" for this type level fixed point?
09:41:41 <johnw> f (Fix f) only has a base case if 'f' has a constructor that does not "recurse"
09:41:56 <erisco> choe_2, choose f = Maybe, then Maybe (Fix Maybe), and choose a = Fix Maybe, then Maybe (Fix Maybe)
09:44:03 <choe_2> johnw: and can we do something more with Fix that we can't do with recursively defined types?
09:44:14 <norc_> ertes-w: well my issue isn't really the pattern matching itself, that feels very natural 
09:45:08 <choe_2> erisco: That makes sense, but it still hurts my brain, because... I can't see it terminating? I'm not sure.
09:45:17 <johnw> choe_2: Fix "packages up" the recursion, so that you don't run into problems with infinite types.  For example, without it, there is no way to say Maybe (Maybe (Maybe (... (Maybe a)))), where you don't know how many levels "..." might be.
09:45:34 <choe_2> johnw: ah, that solves everything, thanks!
09:47:11 <ertes-w> norc_: an irrefutable pattern like that is actually inherently *unnatural* =)
09:47:25 <ertes-w> norc_: "irrefutable" = "lazy"
09:47:52 <ertes-w> norc_: much like 'head' and 'tail' are unnatural
09:49:44 <cheater> erisco: oh, so i can just pattern match on _ -> _ like that?
09:49:51 <choe_2> johnw: no wait, I take that back; when I define List a = Head a | Tail (List a); I don't need to worry about infinite types then either
09:50:06 <choe_2> so what does Fix have to offer?
09:50:28 <erisco> cheater, sure can. (->) is a type constructor, and so you can match on it just like you would a data constructor.
09:50:53 <cheater> thanks
09:51:15 <norc_> ertes-w: okay so if I dont make the pattern matching lazy, it seems to get "stuck". Is this because it tries to recursively match the pattern into the infinite list?
09:51:22 <cheater> that's nice really
09:52:01 <norc_> Or am I just producing bottom?
09:52:22 <norc_> My issue is, I don't understand whats happening when haskell gets stuck like this.
09:54:10 <erisco> the value of non-terminating programs is bottom
09:57:24 <monochrom> erisco: If you have polymorphic recursion like "data Whee a = WheeOf a (Whee (a, a))" you will also be forced to go *->*
09:58:44 <ertes-w> norc_: you need to evaluate this by hand to really understand it…  a regular pattern match happens *before* the rewrite, while an irrefutable match doesn't happen at all
09:59:03 <ertes-w> @let test (x : xs) = ()
09:59:04 <lambdabot>  Defined.
09:59:12 <ertes-w> @let test' ~(x : xs) = ()
09:59:13 <lambdabot>  Defined.
09:59:17 <ertes-w> > test undefined
09:59:19 <lambdabot>  *Exception: Prelude.undefined
09:59:20 <ertes-w> > test' undefined
09:59:22 <lambdabot>  ()
09:59:29 <erisco> I read the paper for data-reify and I tepidly understand it. Enough to have an idea for a way to use it... now I am faced with having to redo the work for polymorphic recursion if possible... yak shaving...
09:59:54 <erisco> monochrom, did you see my lpaste yesterday? I was hoping to at least get a pity laugh for wasting so much time
10:00:06 <monochrom> No, I didn't.
10:00:47 <monochrom> Also, someone please tell choe_2 about the story of "catmorphism :: Functor f => (f r -> r) -> (Meow f -> r)" :)
10:01:01 <erisco> but you're the storyteller
10:01:13 <monochrom> I have to go soon.
10:01:18 <MarcelineVQ> if you had an a in there you could have meow a r f
10:01:26 <erisco> monochrom, then just look at this http://lpaste.net/357870
10:01:53 <monochrom> Oh, that one. I saw it yes.
10:02:29 <ertes-w> BTW, that cat story is deeply related to how data-reify works =)
10:02:30 <monochrom> Dependent Haskell poisons many programmers' minds.
10:02:43 <norc_> ertes-w: Ohhhhhh!
10:03:20 <mniip> dependent haskell is the best thing since sliced bread
10:03:42 <erisco> well, a properly dependent Haskell should clean it up a lot
10:03:48 <mniip> yes
10:03:51 <mniip> not singletons
10:03:58 <erisco> I wouldn't have to do janky stuff like Sing and representing type families with data types
10:04:32 <ertes-w> norc_: BTW, you can't really grok this kind of crazy recursive pattern unless you study it for a long time…  personally i tend to just avoid it
10:04:51 <ertes-w> norc_: i prefer stateful unfolds
10:05:00 <ertes-w> like unfoldr, iterate, etc.
10:05:16 <mniip> () :: case putStrLn "hello" of IO f -> case f realWorld# of (# _, _ #) -> ^()
10:05:41 <norc_> ertes-w: haskell has managed to throw me from one "what what what?" into the next well. monads were very simple however
10:06:17 <mniip> monads are just monoids in an endofunctor category under composition
10:06:31 <norc_> mniip: And that makes perfect sense to me :P
10:06:44 <mniip> it can make perfect sense if you know all of those words
10:06:47 <norc_> That remark only seems scary if you don't know any CT
10:07:21 <mniip> join is just mappend and return is just mempty
10:07:44 <norc_> mniip: But then again 6 months ago I dived into ECC, so terms such as monoids, semi-groups, and the like are "boring
10:07:59 <mniip> elliptic curve crypto?
10:08:01 <norc_> Yeah
10:08:09 <mniip> haskell doesn't use semigoups much
10:08:14 <mniip> semigroupoids on the other hand however
10:08:22 <norc_> mniip: monoids are semi groups with identity
10:08:22 <norc_> :P
10:08:27 <norc_> oh well
10:08:31 <norc_> I see what you mean.
10:08:41 <mniip> monoids are just associative magmas
10:08:47 <norc_> Anyway. Gotta run catch the train
10:09:08 <mniip> magmas are just the category induced by a signature with a single binary operator
10:09:21 <mniip> ooops
10:09:28 <mniip> correction: semigroups are just associative magmas
10:09:33 <erisco> I don't recommend trying to catch a train
10:09:58 <mniip> erisco, what if it's The train - "the" train of your life
10:10:01 <monochrom> What, you're setting up a co-joke and say "you should let a train catch you"? :)
10:10:24 <mniip> monochrom, ah-ah
10:10:56 <BernhardPosselt> :t First
10:10:57 <lambdabot> Maybe a -> First a
10:11:23 <BernhardPosselt> :t First (Just 1)
10:11:25 <lambdabot> Num a => First a
10:12:21 <BernhardPosselt> newtype First a = First { getFirst :: Maybe a }
10:12:25 <BernhardPosselt> whats getFirst?
10:12:29 <BernhardPosselt> a getter?
10:12:31 <erisco> :t getFirst
10:12:33 <lambdabot> First a -> Maybe a
10:12:46 <BernhardPosselt> > getFirst (First (Just 1))
10:12:48 <lambdabot>  Just 1
10:12:52 <BernhardPosselt> ah
10:12:57 <erisco> getFirst . First = id,  First . getFirst = id  (mind the types)
10:13:15 <marvin2> > > getFirst (First [0])
10:13:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
10:13:22 <marvin2> > getFirst (First [0])
10:13:24 <lambdabot>  error:
10:13:24 <lambdabot>      • Couldn't match expected type ‘Maybe a’
10:13:24 <lambdabot>                    with actual type ‘[Integer]’
10:13:30 <iomotoko> what does it mean when a language lacks type inference? it means that there is no automatic deduction of the data type of an expression, so in C I could do sth like: int a; a = 'c'; ? but the compiler still throws a warning in that case most likely?
10:13:52 <marvin2> what is the purpose of First?
10:14:05 <erisco> it selects a... Monoid instance? something like that
10:14:07 <BernhardPosselt> marvin2: returns the first non empty Maybe
10:14:19 <erisco> maybe Alternative
10:14:25 <mud> iomotoko: I don't think that even warns, in C, char is an integer type.
10:14:28 <ertes-w> iomotoko: not True = False; not False = True  -- you don't need a type signature
10:14:39 <erisco> > First (Just 1) <|> First (Just 2)
10:14:42 <lambdabot>  error:
10:14:42 <lambdabot>      • Could not deduce (Alternative First) arising from a use of ‘<|>’
10:14:42 <lambdabot>        from the context: Num a
10:14:54 <ertes-w> iomotoko: languages with type inference are statically typed languages that can figure out types from context, so you don't have to spell out everything for the compiler
10:14:59 <erisco> > First (Just 1) <> First (Just 2)
10:15:01 <iomotoko> mud: guess depends w/ what options you compile
10:15:02 <lambdabot>  First {getFirst = Just 1}
10:15:13 <erisco> > Last (Just 1) <> Last (Just 2)
10:15:15 <lambdabot>  Last {getLast = Just 2}
10:15:19 <iomotoko> ertes-w: so in haskell the rules are such that haskell always knows beforehand what type an expression will have
10:15:31 <iomotoko> ertes-w: as witnessed before in my struggle with the IO char type?
10:15:36 <ertes-w> iomotoko: not always, but it rarely needs your help
10:16:04 <ertes-w> iomotoko: yeah, exactly…  your code didn't contain a single type signature, but still everything was statically typed
10:16:51 <iomotoko> ertes-w: in theory I could use explicit type signatures throughout a haskell program?
10:16:52 <marvin2> explicit top-level type declarations are still a good idea though. they serve as a documentation and can lead to better errors if you do something wrong
10:17:35 <BernhardPosselt> im looking for a monoid that collects Lefts
10:17:55 <BernhardPosselt> basically given a list of Either a b, give me [a]
10:17:58 <trigone> hi! i was trying to use `stack ghci app/Main.hs`, and it ended with an error i dont' understand: <command line>: cannot satisfy -package mypackage-0.1.0.0  (here obviously, "mypackage" is the package from which this Main.hs comes)
10:18:15 <ertes-w> iomotoko: yes
10:18:19 <iomotoko> ertes-w: btw I am now at a point in the book where it explains what you explained before :D
10:18:30 <BernhardPosselt> as in: give me a list of errors
10:18:42 <mud> trigone: In the context of a package, just do 'stack ghci'
10:18:51 <iomotoko> ertes-w: "if 'f' is a function that maps arguments of type 'A' to results of type 'B', and 'e' is an expression of type 'A', then the application 'f e' has type 'B'"
10:18:54 <iomotoko> ertes-w: :3
10:19:00 <trigone> mud oh ok? i'll be in the namespace defined by Main?
10:19:12 <eschnett> BernardPosselt: similar to: “map fromLeft . filter isLeft”?
10:19:33 <mud> trigone: Yeah, pretty much. If there's multiple things it can be in the context of, like a test-suite or multiple executables, it'll tell you and I think tell you how to choose.
10:19:38 <brisbin> BernhardPosselt: there's a validations package that does this iirc
10:19:38 <BernhardPosselt> eschnett: think so
10:19:44 <iomotoko> k, thanks again ertes-w :) - you too marvin2 :3 - I will annoy the hell out of this channel in the weeks to come it seems :D
10:19:56 <trigone> mud ok... i'll try that, thx :)
10:19:58 <iomotoko> (will try to keep it to a minimum)
10:20:11 <eschnett> BernardPosselt: also “import Data.Either”
10:20:38 <trigone> mud: it worked, thx! :)
10:20:46 <mud> 'welcome
10:20:51 <erisco> :t foldMap (either pure (const mempty))
10:20:53 <BernhardPosselt> right, looking for validation :D
10:20:53 <lambdabot> (Applicative f, Monoid (f a), Foldable t) => t (Either a b) -> f a
10:21:09 <dingus> hi
10:21:21 <BernhardPosselt> https://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html i guess
10:21:21 <dingus> this may be kind of a stupid question
10:21:43 <ertes-w> iomotoko: do it! ;)
10:21:51 <erisco> > foldMap (either pure (const mempty)) [Left "hello", Right 3, Left "world"]
10:21:54 <lambdabot>  error:
10:21:54 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M498063465347...
10:21:54 <lambdabot>        prevents the constraint ‘(Show (f0 [Char]))’ from being solved.
10:22:01 <erisco> > foldMap (either pure (const mempty)) [Left "hello", Right 3, Left "world"] :: [String]
10:22:03 <lambdabot>  ["hello","world"]
10:22:29 <erisco> c'mon where be your defaults Mr. bot.
10:22:35 <dingus> im learning haskell/programming for the first time. is there a way of faking limits and colimits by encoding all your types as hom(-, x) ?
10:22:55 <dingus> like, if I wanna pretend haskell has pushouts for examply
10:22:59 <dingus> *example
10:23:05 <ertes-w> iomotoko: annoy us all you want…  you'll get it back eventually…  step by step will you approach the point where you will be answering newbie questions yourself =)
10:23:12 <erisco> > foldMap (either pure (const mempty)) [Left "hello", Right 3, Left "world"] :: First String
10:23:15 <lambdabot>  First {getFirst = Just "hello"}
10:23:21 <erisco> > foldMap (either pure (const mempty)) [Left "hello", Right 3, Left "world"] :: Last String
10:23:24 <lambdabot>  Last {getLast = Just "world"}
10:23:24 <dingus> can't I just repackage every type via yoneda?
10:23:28 <erisco> I like this.
10:23:56 <dingus> like, theoretically that should be a thing
10:24:14 <dingus> I'm wondering what the programming reason is that people dont do that
10:24:14 <Cale> dingus: I'm not sure if that helps. Obviously Set^(Hask^op) is complete and cocomplete and such
10:24:24 <Cale> dingus: But that's because Set is
10:25:27 <dingus> I guess what im trying to get at is this
10:25:45 <dingus> Im new to programming and I dont like that I dont have equalizers and such at my disposal
10:26:16 <erisco> yeah, all new programmers go through that phase
10:26:17 <Cale> dingus: Well, you'd really rather be working in something dependently typed then.
10:26:19 <dingus> my instincts tell me to just use yoneda
10:26:57 <Cale> dingus: However, one thing you *can* do which doesn't require much machinery at all is just use modules to abstract
10:27:10 <ertes-w> > (foldMap First . lefts) [Left "hello", Right 3, Left "world"]
10:27:12 <lambdabot>  error:
10:27:12 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Maybe a’
10:27:12 <lambdabot>        Expected type: Either (Maybe a) Integer
10:27:30 <Cale> and have "smart constructors" which ensure that only certain values of your type are constructible from outside the module
10:27:44 <Cale> (only those satisfying whatever conditions it is that you wanted)
10:27:54 <ertes-w> > (getFirst . foldMap pure . lefts) [Left "hello", Right 3, Left "world"]
10:27:56 <lambdabot>  Just "hello"
10:28:00 <dingus> hmm ok
10:28:09 <dingus> is there somewhere I can read about that?
10:28:30 <erisco> :t lefts -- dare I ask this
10:28:32 <lambdabot> [Either a b] -> [a]
10:28:38 <erisco> oh, how quaint
10:29:07 <Cale> hmm...
10:29:39 <Cale> dingus: I'll have a look for you, but the idea is basically just not to export the data constructors for your type, and instead export only functions which construct valid values.
10:29:54 <dingus> oh ok that makes sense
10:30:00 <Cale> (or if you want coequalisers, only functions which regard equivalent functions the same way)
10:30:06 <Cale> equivalent data*
10:30:33 <dingus> cool thanks for the help :)
10:36:15 <erisco> so what is an equaliser?
10:39:50 <thimoteus> an equalizer is a limit object d of a functor F: D -> C where D is a category that looks like 2 parallel arrows
10:40:02 <nshepperd> :t getFirst . foldMapOf (traverse . _Left) pure
10:40:03 <lambdabot> Traversable t => t (Either b c) -> Maybe b
10:40:11 <johnw> in terms of sets: "Let X and Y be sets. Let f and g be functions, both from X to Y. Then the equalizer of f and g is the set of elements x of X such that f(x) equals g(x) in Y."
10:41:10 <ertes-w> > lastOf (traverse . _Left) [Left 1, Right "x", Left 2]
10:41:12 <lambdabot>  Just 2
10:41:32 <trigone> :t _Left
10:41:34 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
10:41:50 <trigone> ertes-w: where does this come from? lenses?
10:41:57 <nshepperd> oh, I should have expected that's a thing
10:42:00 <ertes-w> trigone: do you understand this type?
10:42:05 <nshepperd> :t firstOf (traverse . _Left)
10:42:06 <lambdabot> Traversable t => t (Either b c) -> Maybe b
10:42:14 <trigone> ertes-w: nah, i don't know of Choice
10:42:16 <ertes-w> trigone: then it's from lens
10:42:29 <erisco> truth
10:42:32 <trigone> ertes-w: ok ^^
10:42:38 <nshepperd> yesss
10:43:46 <ertes-w> trigone: if you see "p … … -> p … …" or "(… -> f …) -> … -> f …", and you don't know it from base (like 'traverse'), then it's most likely from lens =)
10:50:15 <erisco> thimoteus, I am too much of a simpleton to know what a limit object is, but I understand the sets example from johnw
10:51:27 <thimoteus> erisco, my bad, i was just copying the definition from my textbook
10:53:00 <monochrom> Indeed, limits and colimits are category-complete, in the sense that every definition is reducible to a limit or a colimit, that if you can solve limits or colimits you can solve all of category theory.
10:53:53 <monochrom> In other words, if you keep working on category theory, in the limit you will understand limit. :)
10:54:11 <erisco> and the coequaliser... the set of elements y from Y such that if f(a) = y and g(b) = y, then a = b?
10:54:14 <thimoteus> given two categories C, J and the diagonal functor Delta: C -> C^J (here, C^J is the category of functors from J to C, and the diagonal functor sends every object c to the constant functor F_c that has the value c for every object in J and the identity on c for every arrow of J), then ...
10:55:01 <thimoteus> a limit for a functor F: J -> C is a universal arrow (which is a pair <r, u>) from delta to F, where r is an object (the limit object) of C
10:57:11 <thimoteus> now, a universal arrow from Delta to F (here, regarded as an object of the functor category) is a pair <r, u> which is a terminal object in the comma category (Delta, F)
10:57:34 <trigone> ertes-w: k thx! though i don't see the connection with traverse, there's no `p` involved is there?
10:57:35 <dminuoso> Regarding the previous discusion, given let n = 1 : n in take 1 n, how does Haskell exactly know to construct a list?
10:57:53 <thimoteus> the co-equalizer is the dual, so it's an initial object in the comma category (F, Delta)
10:58:00 <dminuoso> Or does Haskell simply know what n = 1 : n means?
10:58:24 <monochrom> Yes, Haskell simply knows.
10:58:29 <verement> :t (:)
10:58:31 <lambdabot> a -> [a] -> [a]
10:58:41 <BernhardPosselt> :t <>
10:58:42 <lambdabot> error: parse error on input ‘<>’
10:59:02 <geekosaur> :t (<>)
10:59:03 <marvin2> haskell didn't make a special case for (:) if that is what you are asking.. it works with any other function that is lazy in the same way, including functions that you define yourself
10:59:04 <lambdabot> Monoid m => m -> m -> m
10:59:18 <johnw> erisco: limits give you a way to "find" an object, such that the object found is the "best" for the limit being sought, up to isomorphism.  It's a way to classify objects without saying anything about their internal nature.
10:59:28 <BernhardPosselt> is that the combine function?
10:59:31 <BernhardPosselt> <>
10:59:34 <monochrom> In most compilers, it knows to construct the list by constructing the cons cell, and oh the second field has to point back to the cons cell itself, we all know how to do that.
10:59:54 <geekosaur> it's infix mappend
11:00:00 <geekosaur> @src Monoid
11:00:00 <lambdabot> class Monoid a where
11:00:00 <lambdabot>     mempty  :: a
11:00:00 <lambdabot>     mappend :: a -> a -> a
11:00:00 <lambdabot>     mconcat :: [a] -> a
11:00:00 <BernhardPosselt> thanks :)
11:01:24 <dminuoso> monochrom, fair enough. I suppose its a bit naive to expect an empty list [] somewhere in there
11:01:43 <monochrom> Corollary: It actually takes more work to forbid n=1:n.
11:02:40 <tempay> has anyone ever had an issue with Intero where trying to load the project's test target "can't satisfy" the project's library?
11:03:11 <tempay> "stack test" works, but intero with the test target doesn't
11:04:35 <tempay> ah found a workaround..
11:04:47 <ertes-w> trigone: i gave two templates
11:06:18 <ertes-w> trigone: to be more precise it's "p a (f b) -> p s (f t)"…  that's almost the most generic template (there is one further generalisation, but ignore that)
11:06:40 <ertes-w> trigone: and 'traverse' does actually fit this template…  i'll let you figure out why =)
11:07:07 <ertes-w> trigone: hint: look at the kind of p and compare it to the kinds of types you know
11:08:07 * hackagebot dejafu 0.7.1.2 – Systematic testing for Haskell concurrency. – https://hackage.haskell.org/package/dejafu
11:12:14 <trigone> ertes-w: well i'd say that in traverse, p == (->) or sth
11:13:37 <trigone> but since i don't know the semantics of your generic templace (what it's supposed to do) it's a bit hard to see what that entails for traverse
11:14:54 <ertes-w> trigone: correct, and there are no semantics, it's just types
11:15:05 <ertes-w> (what's the plural of semantics?)
11:15:24 <monochrom> (is "semantics" even supposed to be countable?)
11:15:29 <dolio> It has no plural, I think.
11:15:31 <monochrom> (I hate English.)
11:15:53 <trigone> ertes-w: ^^
11:16:00 <trigone> semanticses? :P
11:16:07 <monochrom> (Like, if you have two pieces of code, you can't say "two codes". WTH. WTHIWWY.)
11:16:26 <dolio> Well, you wouldn't say "one code", either.
11:16:39 <dolio> At least, not for that sort of code.
11:16:50 <monochrom> Ah but just today I read on haskell-cafe someone writing "I have a code"
11:17:00 <nshepperd> it's a mass noun, like water
11:17:11 <nshepperd> a bucketful of code
11:17:12 <monochrom> I would love to lend support to that.
11:17:17 <ertes-w> when we imported "code" from english, we seem to have fixed it along the way =)
11:17:20 <ertes-w> "zwei codes"
11:17:39 <monochrom> \∩/
11:17:39 <trigone> ertes-w: what language?
11:17:43 <trigone> *which
11:17:52 <ertes-w> trigone: german
11:18:28 <ertes-w> we also have "semantiken", which translates to…  hmm…
11:19:05 <monochrom> semantiKenShan
11:19:09 * Clint twitches.
11:19:47 <trigone> ok :) well in french we more or less say "un code" (a code) too (relatively easily). tbh i don't really know much of the french translations since i learned nearly everything directly in english
11:20:18 <Tuplanolla> "Please give the codes."
11:21:05 <nshepperd> how much is one code
11:21:06 <trigone> Tuplanolla: actually, it's more like it's never plural either. it's "the code" more than "a code", as in, "the code of the app/project/etc"
11:21:36 <Tuplanolla> That's the form I've seen the most, unfortunately.
11:21:44 <ertes-w> i love the (alleged) story of the name Coq =)
11:22:10 <cocreature> ertes-w: oh I think I don’t know that story
11:22:12 <Tuplanolla> People who know what they're doing usually talk about programs.
11:22:59 <ertes-w> as a payback for the english "bit", which supposedly sounds like the french word for dick =)
11:23:21 <monochrom> Oh!
11:23:26 <ertes-w> i don't know if it's true though
11:23:35 <trigone> Tuplanolla: well yeah but there *are* those who don't know what they're doing (often without realizing it) so...
11:23:54 <cocreature> I thought inria just had a tendency to name things after animals
11:24:16 <trigone> ertes-w: it's vaguely true. it's not supposed to be the same vowel strictly speaking, but with a french accent it's the same indeed
11:24:17 <Tuplanolla> Thierry Coquand, our favorite animal.
11:24:57 <cocreature> heh
11:28:50 <trigone> i'd like to officially rant on some weird feature i really don't get: if you write (module Foo (module Bar) where), you're going to export everything from Bar if and only if it is accessible in Foo both in qualified (Bar.xyz) and unqualified (xyz). This, regardless of whether the unqualified version comes from importing another module than Bar or not. talk about undeterminable...
11:30:06 <trigone> erratum: i mean you're going to export everything from Bar for which the condition is true.
11:30:57 <BernhardPosselt> how are <*> and >>= different?
11:31:05 <cocreature> :t (<*>)
11:31:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:31:07 <cocreature> :t (>>=)
11:31:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:31:14 <BernhardPosselt> seems like >>= does not force you to use all arguments
11:31:17 <cocreature> the types are quite different
11:31:35 <trigone> that's actually standard behavior for some reason: "The form “module M” names the set of all entities that are in scope with both an unqualified name “e” and a qualified name “M.e”. This set may be empty."    https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
11:31:51 <BernhardPosselt> > (+) <$> Just 1 <*> Just 2
11:31:54 <lambdabot>  Just 3
11:32:08 <cocreature> if you are asking about the general difference between Applicative and Monad, the difference is that the "m b" can depends on the "a"
11:32:13 <BernhardPosselt> Just 1 >>= Just 2 >>= (+)
11:32:31 <cocreature> you can’t have such dependencies if you restrict yourself to Applicative code
11:32:34 <BernhardPosselt> maybe need do blocks
11:32:35 <tdammers> :t (Just 1 >>=)
11:32:37 <lambdabot> Num a => (a -> Maybe b) -> Maybe b
11:32:41 <cocreature> BernhardPosselt: Just 1 >>= Just 2 >>= (+) doesn’t typecheck
11:32:45 <BernhardPosselt> yep
11:32:57 <BernhardPosselt> probably needs a return (a + b)
11:33:07 <tdammers> BernhardPosselt: do the type checking yourself, using pen and paper
11:33:12 <BernhardPosselt> sec
11:33:21 <erisco> I recommend pencil with a fresh eraser
11:33:39 <trigone> BernhardPosselt: >>= requires a function (a -> m b)on its right side. "Just 2" does not qualify as such
11:33:48 <maerwald> cocreature: I think you can, but you lack join then, no?
11:33:54 <[exa]> anyone here who'd be writing type theory papers? which latex package is best for typesetting the deduction rules? standard \infer from proof package puts the (Var) and similar annotations on the wrong side
11:33:55 <ertes-w> trigone: the behaviour i have observed is that you reexport everything that you imported
11:34:13 <ertes-w> trigone: module X (module Y) where import Y (a, b, c)
11:34:23 <ertes-w> you only reexport a, b, c
11:34:25 <BernhardPosselt> https://dpaste.de/ZF9y
11:34:26 <maerwald> so you an depend on a, but you will nest stuff further
11:34:30 <cocreature> [exa]: I’ve used bussproofs
11:34:49 <ertes-w> trigone: not sure about qualified imports though
11:35:11 <BernhardPosselt> the paste above is identical right?
11:35:32 <cocreature> BernhardPosselt: yes
11:35:48 <maerwald> I think it's more useful to say that the "effect" control flow of Applicative is static, the result control flow can still be dynamic though
11:36:17 <maerwald> you can see that if you implement ifA vs ifM
11:36:45 <cocreature> BernhardPosselt: but now come up with some "Int -> Int -> Maybe Int" function that doesn’t just use "return". you can easily use that in the last line of your do block. you won’t be able to get it to work using only <*> and <$>
11:36:51 <trigone> ertes-w: say module C exports B.x
11:37:10 <trigone> ertes-w: then, you write module A (module B) where ...
11:37:23 <trigone> ertes-w: if you continue with import qualified B, nothing is exported
11:37:34 <trigone> ertes-w: if you continue with import C, nothing is exported
11:37:49 <ertes-w> trigone: correct
11:37:54 <BernhardPosselt> so when do people prefer applicative?
11:37:58 <trigone> ertes-w: if you continue with both import qualified B and import C, B.x will be exported!
11:38:07 <erisco> BernhardPosselt, whenever it is applicative!
11:38:11 <BernhardPosselt> i mean even for validation it seems that monadic style is easier and more powerful to read
11:38:19 <monochrom> trigone: You will want to read my http://www.vex.net/~trebla/haskell/module.xhtml
11:38:29 <cocreature> BernhardPosselt: Validation doesn’t have a Monad instance :)
11:38:32 <maerwald> afair applicative has performance advantages over monads too
11:38:35 <trigone> ertes-w: note that import C and be the implicit "import Prelude" on top of it...
11:38:41 <BernhardPosselt> cocreature: why?
11:38:44 <ertes-w> trigone: huh?  my instinct says that sounds like a bug
11:38:49 <BernhardPosselt> i mean its a wrapper around Either
11:38:51 <cocreature> BernhardPosselt: try writing one, you’ll see the problem
11:38:56 <trigone> ertes-w: and yet ^^
11:39:31 <maerwald> I'd say... use applicative whenever you can, use monad when you cannot do it applicative-style. "Programmatically" monads are more "powerful".
11:40:15 <BernhardPosselt> maerwald: why? because monads compose badly?
11:40:32 <erisco> BernhardPosselt, it is desirable to use the minimal. If you do not need the features of Monad then why have them?
11:40:36 <trigone> ertes-w: as i said it's standard behavior: "The form “module M” [[in an export list]] names the set of all entities that are in scope with both an unqualified name “e” and a qualified name “M.e”. This set may be empty."  --- And this, from experience, regardless of how e and M.e got put into scope.    https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
11:40:49 <maerwald> BernhardPosselt: as I said, afair monadic-style has performance implications
11:40:53 <cocreature> if you’re working with some concrete instance, 95% of the time it doesn’t matter what you use
11:41:02 <ertes-w> BernhardPosselt: if you can use the more general API, do it, because that makes your code both easier to reuse and easier to reason about
11:41:19 <trigone> monochrom: sounds interesting, i'll read it, thx!
11:41:20 <cocreature> if you’re writing polymorphic code, use Applicative since you’ll be able to use it in more places
11:41:29 <BernhardPosselt> ah i see
11:41:37 <monochrom> Oh, maybe ertes-w is the one who needs to read it. :)
11:42:06 <ertes-w> i have to admit, i have never read the report
11:42:12 <trigone> monochrom: well it still looks interesting, maybe i'll learn sth nonetheless :P
11:42:39 <BernhardPosselt> so basically: dont force api users to provide a higher "interface" than needed
11:42:59 <BernhardPosselt> higher as in: more extensive
11:43:17 <trigone> ertes-w: i just started but honestly i discovered this behavior via experimentation with different import/export. i wouldn't really have understood the manual given how it's phrased (not all the implications at least).
11:43:22 <BernhardPosselt> thanks!
11:44:29 <ertes-w> trigone: reading it would have saved me a few head-scratches, but ultimately i never find myself thinking that i really need to learn every detail =)
11:44:36 <monochrom> No, it is quite understandable. The obstacle is the keyword "module".
11:44:47 <cocreature> BernhardPosselt: for learning purposes it can definitely be helpful to write some code using do notation/>>= and Applicative to get a feel for what you can express with both and for what you really need the power provided by the Monad class
11:45:40 <monochrom> Meaningful names can be very distracting.
11:45:45 <ertes-w> trigone: the reason i never ran into this is probably that i don't reexport except from modules that only exist for reexporting stuff, so i never found myself mixing qualified and indirect imports like that
11:45:47 <trigone> monochrom: they don't explicitly say that `e` and `M.e` can come from different import statements or even from implicit Prelude. that's counterintuitive
11:46:17 <monochrom> IMO "in scope" already does that.
11:46:27 <monochrom> But I'm a logician.
11:46:30 <trigone> ertes-w: yeah there's that
11:46:34 <cocreature> I like reexporting the types exposed by my API so users don’t need to depend on a separate package just to provide explicit type signatures
11:46:51 <trigone> monochrom: that's what i meant: all the meaning is there, but the implications in details can surprise.
11:47:04 <dolio> trigone: I think that section may be the most confusing thing in the report.
11:47:17 <johnw> monochrom: you're a logician by training?
11:47:19 <dolio> And I still don't know what it's actually intended to mean.
11:47:35 <trigone> dolio: the section on import/export?
11:47:39 <dolio> Yes.
11:47:43 <ertes-w> cocreature: me too, and my module structure takes care of that:  Data.X.Core contains the core, and Data.X is just a reexport module
11:48:16 <dolio> For instance, you can import into a qualified namespace `Foo` and export `module Foo` even though no actual module `Foo` exists, I think.
11:48:44 <dolio> But it's not at all clear that that's what the text says.
11:48:58 <trigone> dolio: you mean renamed namespace? with qualified-as?
11:49:10 <monochrom> johnw: Yes. (Ah but that's a logician's answer. A more humane answer:) I am a formal methods person by training, therefore I am also a logician by training.
11:49:14 <dolio> Yeah, with `as`. `qualified` is irrelevant.
11:49:27 <ertes-w> dolio: oh?  so you can write (module X (module Y) where import A as Y; import B as Y)?
11:49:40 <trigone> ertes-w: i think so (but i'm not sure)
11:49:42 <dolio> ertes-w: You can in ghc, anyway.
11:49:46 <ertes-w> cool
11:49:52 <dolio> It's not very clear if that's what the report says you can do.
11:50:23 <ertes-w> well, if the report isn't clear, i'd say that GHC is the de facto judge =)
11:52:29 <trigone> dolio: they should have used the keyword "namespace" in that case (but then the whole module system could benefit from a full remake, which probably will never happen :`( )
11:53:08 <monochrom> module M(namespace Y) would make sense.
11:53:22 <ertes-w> i wish there was no difference
11:53:34 <ertes-w> haskell's module system could learn a thing or two from other languages
11:53:35 <monochrom> Also, import Data.List namespace Y
11:53:44 <ertes-w> most notably agda
11:53:54 <trigone> the irony is so far in haskell the import/export system is the thing i got the most trouble understanding, way before anything else ^^
11:54:32 <trigone> so when they say "haskell is too hard to understand" i'd wanna say "sure, but once you got past its horrendous module system it's a quiet walk in the park :)"
11:54:42 <monochrom> haha
11:54:46 <ertes-w> hehe
11:55:32 <ertes-w> i'd be happy if haskell even just had coq's 'Section'
11:56:16 <ertes-w> but then types are always module-scoped
11:56:55 <trigone> monochrom: i think namespace could be sort of like values in their own kind (no pun): you could write namespace Y = module X ++ module Y or sth (not necessarily with the symbol (++) ofc). that'd be rather cool...
11:57:12 <trigone> oops i meant namespace Y = module X ++ module Z
11:57:23 <ertes-w> isn't it kinda awkward that we have all those super-fancy type system features, but after almost three decades we still can't get names right?
11:57:31 <monochrom> Ah but you already have "import X as Y; import Z as Y"
11:57:51 <monochrom> this is why I suggest changing "as" to "namespace"!
11:58:20 <monochrom> Or we can go full-blown COBOL and make it "import X add to namepsace Y"!
11:58:49 <johnw> "going full COBOL" sounds like it should be its own phrase
11:59:11 <ertes-w> "but look, we have GADTs!" – "ok, can't i reuse this field name?" – "no, BUT LOOK!  we're about to get linear types!" – "nice, but can't i define a type in this function's local scope?  even PHP can do that" – "err…  no…  BUT LOOOOK!  WE'RE GETTING DEPENDENT TYPES!"
11:59:19 <trigone> ertes-w: there's always something that must break. better be the module system than anything else, in the end. i think the issue is, haskell got me used to too much logic and consistency (putting aside the weird typeclass hierarchy thingies here and there), so obviously the expectation falls short for the module system.
11:59:32 <monochrom> Wait, PHP has types?!
11:59:41 <ertes-w> not static ones
11:59:58 <trigone> monochrom: yeah but then the definition of the namespace Y is split across several statements. it's not anymore an expression, it looks like imperative incremental union.
12:00:02 <monochrom> If PHP has ADT, even non-static, that would be nice.
12:00:17 <trigone> monochrom: it has the type Spaghetti, and the type SOS (i think)
12:00:22 <marvin2> PHP has a type
12:00:46 <monochrom> Basically if any language has ADT, it would be nice.
12:00:58 <trigone> monochrom: you mean all languages?
12:01:38 <trigone> i don't think PHP is recoverable even if you add ADTs ^^
12:01:40 <ertes-w> monochrom: yeah, i can totally imagine myself writing "select $x { \\A($x): return $x; … }"
12:01:46 <monochrom> Oh I mean this: for each language L, if L has ADT, I will say "L is nice".
12:02:12 <ertes-w> monochrom: F# has ADTs, but it's a disaster
12:02:25 <monochrom> Because basically with an ADT you solve Hoare's billion-dollar mistake. And then some.
12:02:41 <erisco> tell me, what did Hoare do?
12:02:46 <monochrom> null
12:02:52 <erisco> oh, that bastard
12:03:24 <monochrom> https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
12:03:27 <trigone> who's Hoare?
12:03:27 <BernhardPosselt> is there a way to quickly run a file?
12:03:28 <erisco> has he repented?
12:03:38 <BernhardPosselt> like cargo run
12:03:39 <monochrom> YES! That's why.
12:03:56 <monochrom> He himself named it "my billion-dollar mistake".
12:03:56 <ertes-w> BernhardPosselt: "run a file"?  you mean execute it from a haskell program?
12:04:08 <BernhardPosselt> ertes-w: basically compile + execute in one step
12:04:24 <BernhardPosselt> or maybe interpret
12:04:27 <ertes-w> BernhardPosselt: if "compile" isn't necessary, you can do it with 'runhaskell'
12:04:44 <ertes-w> BernhardPosselt: otherwise my solution used to be to write a small Makefile
12:04:44 <BernhardPosselt> thanks!
12:04:55 <erisco> upon inventing a time machine, many people would go back and kill Hitler, but I have a different idea now
12:04:58 <monochrom> Hoare is Sir C. A. R. Hoare. You can call him "Tony Hoare" where "Tony" comes from A = Anthony. If you know of quicksort or communicating sequential processes, that's him.
12:05:48 <erisco> or Hoare logic
12:06:15 <monochrom> erisco: Please don't kill Hoare. He has positive contributions. Only the null thing was a mistake. But you may try to persuade him about that.
12:06:29 <monochrom> Yeah, precondition and postcondition.
12:07:19 <monochrom> Also, please don't kill Hitler either. I saw a Twilight Zone that explores what can go wrong.
12:07:31 <cheater> i have data Mode = A | B, data Result = ResA Int | ResB String. I have a list of functions f1, f2, f3 :: Mode -> Result. How can I get a list of Int's from that?
12:07:36 <monochrom> err, a Twilight Zone episode!
12:07:51 <cheater> monochrom: Red Alert was a game series about that.
12:08:02 <monochrom> Yeah that too.
12:08:16 <cheater> oh, btw, if the functions get A passed in they always produce ResA, and B always yields ResB, of course
12:08:29 <monochrom> That one is more realistic. If you kill Hitler, you'll have Stalin anyway.
12:08:40 <dminuoso> Im beginning to think this intuitive explanation of why https://gist.github.com/anonymous/2797afd7cf33793f1de08372d6cd1348 produces _|_ is beginning to suck. The more I look at it, it has nothing to do with "trying to pattern match too early"
12:09:05 <dminuoso> The more I look at it, I just see strict pattern matching happening in recursion
12:09:36 <cheater> oh, i could just use a tuple.
12:10:12 <monochrom> Usually, intuitive explanations suck, period.
12:10:46 <monochrom> But I'm a mathematician.
12:21:16 <manek> Hi! Is there any GHC lfag that I cannot find that would add HasCallStack to every function within a given module?
12:23:20 <manek> that would be dream come true
12:23:31 <manek> Or even better, if htere is function `f` with a constraint `HasCallStack => ...` , every function that uses `f` would inherit this constraint
12:25:44 <lyxia> manek: try compiling with profiling and -fprof-auto
12:26:08 <erisco> you can't have a type class with kind * last I knew of
12:26:21 <erisco> or I mean of kind Constraint
12:27:02 <erisco> you may be looking for some notion of annotated types though
12:27:57 <cocreature> manek: sadly there isn’t. the issue is https://ghc.haskell.org/trac/ghc/ticket/13360 but nobody has implemented it so far
12:28:54 <erisco> well clearly I don't know anything
12:29:08 <asthasr> Is there an easy way, given a type like "A | B | C |D | E", to generate a cyclic list starting at a particular element? I.e. cycleFrom C -> [C, D, E, A, B, C, ...]
12:29:16 <manek> cocreature: thanks for the link! that exactly what I want
12:29:58 <manek> lyxia: does -fprof-auto adds callstack constraints?
12:29:59 <mud> asthasr: I assume it's instances of Enum and Bounded ? should be able to build one from what those provide
12:30:41 <asthasr> mud: Ah, that's what I couldn't remember, thanks :p
12:31:58 <cocreature> manek: it doesn’t but profiling information gives you a different kind of callstacks
12:32:39 <Cale> asthasr: cycle [minBound .. maxBound]
12:33:04 <Cale> asthasr: Oh, well, that won't start you at a particular element...
12:33:34 <manek> cocreature: I see. But I dont want thsi information. I want a callstack for users of my library. I've created an edsl and I want people who do not know hasell well to use it. Unfortunetally it has to use many non-total functions and I want them to easily diiscover what happens
12:33:47 <manek> cocreature: then I want to compile it with such flag enabled by default
12:34:53 <erisco> drop (toIntegral x) (cycle [minBound..maxBound])  maybe?  or  [x..maxBound] ++ cycle [minBound..maxBound]
12:35:53 <cocreature> manek: sounds like you might be better off with a full-blown dsl rather than an edsl
12:36:21 <erisco> oh I am thinking "fromEnum" ... apparently they think you can't have an enum of more than 2^63-1 items or whatever it is
12:37:42 <erisco> the drop version sure don't work XD
12:37:51 <asthasr> looks like [el .. maxBound] ++ cycle [minBound .. maxBound] :: [Type] will work
12:38:47 <mud> Yeah, that one seems like the best version. I was thinking: dropWhile (/= whatever) (cycle [minBound .. maxBound]), but I'd be a little worried using that on like Int for example.
12:39:06 <mud> In that it'll probably take forever for no reason unless GHC is magic
12:44:49 <johnw> Has anyone ever used CMake to build a C++ project that links in a Haskell-built library that was cabal install'd?
12:46:01 <trigone> hi! which do you think would work fastest: f :: Word -> Word -> Word; f x y = max x y - min x y, or f x y = min (x - y) (y - x), or f x y = if x < y then y - x else x - y
12:48:52 <shapr> Any recommended tutorials on monad transformers?
12:49:18 <manek> cocreature: I dont think so. Why based ony on question regarding callstacks you think this edsl is wrong approach ?
12:49:38 <asthasr> trigone: I think the last is best. Fewer comparisons.
12:49:48 <manek> shapr: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
12:49:54 <manek> shapr: its the best one
12:50:21 <trigone> asthasr: hm yeah i guess you're right...
12:50:22 <asthasr> trigone: but why not just abs $ x - y
12:50:35 <trigone> asthasr: Word is unsigned
12:50:39 <asthasr> oh, of course.
12:50:45 <Tuplanolla> I'd expect the second one to be the best, trigone.
12:50:55 <trigone> Tuplanolla: why?
12:51:19 <Tuplanolla> Branching is usually the biggest cost and you can define a branchless minimum on unsigned integers, trigone.
12:51:47 <cocreature> manek: users who are not proficient in Haskell and the requirement to produce good error messages suggest that a full-blown dsl might be better to satisfy your requirements
12:52:00 <Tuplanolla> Then again, you're writing Haskell, so nothing is conclusive, trigone.
12:52:37 <trigone> Tuplanolla: hm... and it's cheaper to substract than to compare?
12:53:00 <Tuplanolla> I didn't say that, trigone.
12:53:18 <manek> cocreature: I want it to be USABLE by such users. Moreover, I strongly believe in spreading knowledge about haskell, so any EDSL that is easy to grasp, yet brings you the power of HAskell allows us (as a Haskell community) to introduce Haskell to broader audience
12:54:00 <shapr> my experience is that programmers of languages other than Haskell have to get over the "weird syntax" and then it's all doable.
12:54:15 <trigone> Tuplanolla: oh... well in the first version, there's one substraction, and two comparison (at least i guess, unless there's some reduction of graph or sth), and in the second, two substractions and one comparison...
12:55:00 <Tuplanolla> None of that matters, trigone.
12:55:30 <Tuplanolla> @google what is branch prediction
12:55:32 <lambdabot> https://en.wikipedia.org/wiki/Branch_predictor
12:56:29 <ertes-w> shapr: the best tutorial on monad transformers is your own editor: if you know how to implement State, now would be a good time to implement StateT
12:57:34 <trigone> btw, what's the simplest way to force evaluation of the elements of a list, in constant memory?
12:58:21 <ertes-w> trigone: full or WHNF?
12:58:22 <trigone> Tuplanolla: can you just tell me why the second version would work better than the first? both lack conditionals, at least as far as i can see.
12:58:48 <trigone> ertes-w: i'd say WHNF though it's probably the same in my particular case
12:58:57 <trigone> nevermind, yes WHNF
12:58:58 <ertes-w> trigone: in the former case just use deepseq, in the latter the easiest way is to use a strategy
12:59:16 <trigone> ertes-w: hm which is the former ^^
12:59:25 <trigone> ?
12:59:25 <ertes-w> full evaluation
12:59:36 <ertes-w> partial evaluation with strategies: https://hackage.haskell.org/package/parallel-3.2.1.1/docs/Control-Seq.html
12:59:38 <trigone> ertes-w: won't it save in memory the whole list?
12:59:43 <trigone> *to memory
12:59:47 <ertes-w> trigone: it will
13:00:00 <shapr> by constant memory do you mean contiguous?
13:00:00 <Tuplanolla> "Branching is usually the biggest cost and you can define a branchless minimum on unsigned integers, trigone."
13:00:32 <trigone> ertes-w: well when i said "in constant memory" i meant, without having to keep the whole list, just doing the job and discarding each element as soon as it's evaluated...
13:01:12 <ertes-w> trigone: well, you could just fold the list
13:01:30 <ertes-w> :t foldl' (\_ x -> x `seq` ()) ()
13:01:32 <lambdabot> Foldable t1 => t1 t -> ()
13:01:38 <dolio> Why even force the elements if you're just going to throw them away?
13:02:06 <trigone> Tuplanolla: oh sorry i misread you, i understand! but how can i tell if min was written without branches? unless i have to define one by myself?
13:02:15 <trigone> dolio: perf measurement
13:02:28 <Tuplanolla> "Then again, you're writing Haskell, so nothing is conclusive, trigone."
13:02:52 <trigone> Tuplanolla: so, i do have to define one by myself...
13:02:58 <ertes-w> trigone: just be strict in the resulting ()
13:03:06 <ertes-w> then you'll have evaluated each element
13:03:29 <trigone> ertes-w: be strict in the resulting ()? i don't understand your sentence
13:03:43 <ertes-w> sorry, i have to leave…  someone please fill in for me =)
13:03:45 <ertes-w> bye
13:03:56 <trigone> ertes-w: thx :) bye
13:04:36 <trigone> oh i got it
13:06:18 <Tuplanolla> You want the compiler to generate a single `cmovl` instruction, trigone.
13:06:48 <Tuplanolla> Alas, I don't think you can ever guarantee that.
13:08:17 <Tuplanolla> Now would be a good time to stop worrying and focus on better algorithms instead.
13:08:44 <trigone> Tuplanolla: oh... :/
13:10:41 <tdammers> stop worrying and trust the sufficiently smart compiler
13:10:49 <trigone> i'm trying to understand how :sprint works. i write "let list = take 50 $ fmap (+1) [1..]", then :sprint list gave me "list = _". i entered "head list" which gave me 2, but after trying again ":sprint list" i get the same result once more... shouldn't it's first element be evaluated already?
13:11:06 <dminuoso> Trying to setup ghc-vis, but Im getting stack invariant violations https://gist.github.com/anonymous/90b5542975d799ec0e7b93f4941671f1
13:11:39 <lyxia> trigone: :t list
13:11:59 <trigone> er what?
13:12:05 <lyxia> trigone: list is polymorphic
13:12:13 <trigone> oh! got it ^^
13:12:26 <trigone> thx lyxia 
13:14:04 <lyxia> dminuoso: your ghc is too new for ghc-vis
13:14:40 <lyxia> dminuoso: try lts-6.35
13:15:25 <dminuoso> lyxia, ah alright. Doesn't stack have explicit ghc version dependencies?
13:15:38 <dminuoso> I mean I feel like Im missing a useful diagnostic here
13:16:27 <geekosaur> resolvers have them. if ghc-vis is not from the resolver then you have a problem
13:24:11 <lyxia> dminuoso: the version of ghc is attached to the version of base that you see in the error message
13:27:53 <cocreature> someone should make a wrapper around cabal and stack that just replaces base versions with the corresponding ghc versions or at least displays both
13:28:09 <dminuoso> lyxia, ah so base-4.9.1.0 implies a ghc 9.1?
13:28:20 <geekosaur> nope
13:28:24 * dminuoso shrugs
13:28:28 <geekosaur> base versions are completely disjoint sadly
13:28:48 <mud> Why are base versions so annoying anyway? They could at least make a 1/2-assed stab at making them intelligible.
13:28:53 <cocreature> dmnhttps://wiki.haskell.org/Base_package has a table with the corresponding versions
13:29:02 <cocreature> ^ dminuoso 
13:29:08 <dminuoso> geekosaur, ah well. Im about to give up anyway, based on at least one github issue Im not sure whether ghc-vis can be trivially used in stack
13:29:37 <monochrom> base was meant to be applicable to other compilers too. In fact it was shared between GHC and Hugs.
13:29:39 <dminuoso> cocreature, fair enough. It's good to know this mapping exists. :)
13:30:07 <mud> monochrom: Yeah, but it's not anymore, right? And I don't think anyone would complain about it at least vaguely following GHC's version numbers even if other people use it.
13:30:50 <monochrom> Talk to the library committee.
13:32:44 <Tuplanolla> Has anyone ever proposed to put `eval :: String -> Maybe (IO a)` into `base`?
13:33:20 <tdammers> oy vey
13:33:37 <Taneb> Tuplanolla, if they have I really hope it didn't go very far
13:33:51 <dsal> That'd be a neat type class with multiple interpreters and stuff.
13:34:06 <geekosaur> considering it can't do what people would probably expect it to do (have the currently running program as its dynamic context)
13:35:59 <cocreature> not too long ago (1-2 years) there were plans to split base into a part that’s independent of the ghc version and a part that actually depends on fragile primitives
13:35:59 <cocreature> but I don’t think anybody’s actively working on that atm
13:37:48 <Tuplanolla> That's easy to fix: if the string starts with `|`, the current program will be pasted in it.
13:37:56 <Tuplanolla> We Perl now.
13:45:26 * hackagebot language-elm 0.0.10.1 – Generate elm code – https://hackage.haskell.org/package/language-elm
14:37:00 * hackagebot hdevtools 0.1.6.0 – Persistent GHC powered background server for FAST haskell development tools – https://hackage.haskell.org/package/hdevtools
14:53:25 <kaiserA> Hello, I'm having trouble using the class Bounded, I don't know how to use it for a bounded constant, for example a succ function that is: ``succ :: (Num a, Eq a, Bounded a) => a -> a`` \n ``succ maxBound = minBound`` ``succ n = n+1``, it all compiles, but when I try it on ghci I get ``succ 1 :: (Eq a, Bounded a, Num a) => a``
14:56:54 <geekosaur> ghci should be defaulting to Integer if you use it
14:57:31 <geekosaur> the type is generally determined by usage, but if it can't determine a type you can use a type ascription to force it e.g. minBound :: Int
14:58:08 <geekosaur> (parenthesize if using it in the middle of an expression as :: behaves as if it were very low precedence and will "claim" as much as possible)
14:58:34 <kaiserA> what happens if I don't know the type, for instance a generic Bounded type, which is what I need
15:01:28 <pavonia> I guess `succ maxBound = minBound` doesn't do what you think it does
15:01:47 <pavonia> It's equivalent to `succ _ = minBound`
15:02:02 <geekosaur> oh, you're defining succ
15:02:16 <geekosaur> your problem is not Bounded,your problem is pattern matches don't work the way you think
15:02:21 <geekosaur> what pavonia said, basically
15:02:35 <geekosaur> "minBound" there is not the minBound method, it is a new binding
15:03:44 <geekosaur> pattern matches match structure, not values. if you use an initial-lowercase name, it matches anything and binds it to that name within the value (after the =)
15:03:52 <kaiserA> ok so if I wanted the minBound of a type a, how would I do it? for example a function that takes a list and gives the smallest element, [] it gives the minBound of the list type, how would that be written?
15:03:56 <geekosaur> (using the name again *in the pattern* is not legal)
15:04:14 <geekosaur> you need to use guards and (==) because minBound is a value, not a constructor
15:04:41 <geekosaur> succ x | x == maxBound = ... | otherwise = ..
15:05:24 <argent0> hi, is this a sane definition of id, for a category? `(a:Obj) (id_a:a-->a), forall (b:Obj) (g:a-->b), g -o- id_a = g.` using an universal property? (from: http://lpaste.net/357876)
15:05:32 <kaiserA> ``suc n | n == maxBound = minBound`` ``       | otherwise = n+1`` :t suc 1 gives ``suc 1 :: (Eq a, Bounded a, Num a) => a``
15:06:56 <geekosaur> ok, if you want it as generic as possible then you need to use the succ method of Enum to define suc (assuming that is not a typo; if you intended "succ" then you have a problem)
15:06:56 <kaiserA> if I do ``n == (maxBound::a) = (minBound::a)`` it doesn't even complie
15:07:28 <dsal> What are you trying to express there?
15:07:32 <geekosaur> correct, type variable a is not in scope there so you have two fresh non-matching types "a"
15:07:34 <kaiserA> this is a different example of what I have to do
15:07:53 <kaiserA> I just want to get the min and maxBound of a generic type :/
15:08:08 <geekosaur> no, I think you need to do more based on what you are showing
15:08:34 <geekosaur> becuase (n+1) is not how you get the next value of a generic Enum; it assumes you are incrementing something with a Num instance
15:08:38 <geekosaur> this is what Enum's succ method is for
15:09:19 <kaiserA> it's not for an enum, I used this here because it was shorter than what I'm actually trying to do
15:09:47 <geekosaur> then show what you were actually trying to do
15:09:48 <kaiserA> ok change of example, given a list of type [a], how do I get the minBound of a?
15:09:51 <geekosaur> @paste
15:09:51 <lambdabot> Haskell pastebin: http://lpaste.net/
15:10:51 * hackagebot naperian 0.1.0.0 – Efficient representable functors – https://hackage.haskell.org/package/naperian
15:10:59 <geekosaur> if the list has at least one element, you can extract it via pattern match and use its type. if not, you get to dabble with ScopedTypeVariables extension
15:12:16 <geekosaur> thingy :: forall a. [a] -> a; thingy _ = minBound :: a -- need both ScopedTypeVariables extension *and* the "forall a." in the type for type variable "a" to be in scope there
15:12:24 <jle`> you can also use `asTypeOf`
15:12:46 <jle`> > let xs :: [Int]; xs = [] in minBound `asTypeOf` (head xs)
15:12:48 <lambdabot>  -9223372036854775808
15:13:36 <geekosaur> mm, right
15:14:23 <epta> does cabal2 support something like `nix-shell -p` for remote hackage packages?
15:14:53 <jle`> :t asTypeOf
15:14:55 <lambdabot> a -> a -> a
15:14:58 <jle`> asTypeOf x _ = x
15:15:09 <jle`> it's just there as a hint for the type checker
15:15:25 <jle`> but also the type signature for thingy should work without ScopedTypeVariables and the extra type annotation
15:15:51 <jle`> > let thingy :: Bounded a => [a] -> a; thingy _ = minBound in thingy [1,2,3 :: Int]
15:15:53 <lambdabot>  -9223372036854775808
15:20:40 <kaiserA> how does that work with the in, when I paste that in ghci it works, but I failed at adapting it for bounded list, I tried ``smallestList xs = minBound in xs`` and welp that didn't go well
15:22:26 <jle`> er, 'in' is only a thing in let .. in .. syntax
15:22:54 <jle`> `let x = ... in .....` is ....., where all occurences of x are replaced by the ...
15:24:30 <kaiserA> ah
15:27:11 <Tuplanolla> A thing with associativity is associative, a thing with left identity is...
15:27:35 <srhb> Tuplanolla: left identical!
15:27:44 <srhb> I'm good at this.
15:28:00 <Tuplanolla> ...not left identiful?
15:29:33 <monochrom> is an/the identity on the left
15:29:44 <monochrom> I am serious.
15:30:16 <koz_> Left identative?
15:30:52 <srhb> Left-unital!
15:30:55 <mniip> has left identity
15:31:02 <monochrom> No, you won't find the math literature trying to shoehorn "identical" or "identitative" or any other wording into this.
15:31:46 <koz_> monochrom: It's fun to dream.
15:32:02 <monochrom> You will only see "mappend is associative, mempty is an/the identity [on the left/right]".
15:32:37 <srhb> There has got to be a rule 34 for this.
15:32:45 <Cale> Yeah, "left unital"
15:32:52 <srhb> hooray!
15:32:56 <mniip> srhb, about <>? sure
15:32:58 <monochrom> as for "has identity" and "has associativity", you use them on the whole structure (e.g., the set of lists) rather than on mappend or mempty.
15:36:41 * argent0 answers his own question afirmatively :p
15:39:44 * hackagebot reflex-sdl2 0.1.0.0 – SDL2 and reflex FRP – https://hackage.haskell.org/package/reflex-sdl2
15:52:18 <epta> what does 'constraint from user target' mean in an error message like that? http://lpaste.net/3788371814627934208
15:56:26 <Cale> epta: The dependencies of whatever you asked it to build and install.
16:06:57 <cheater> is there a better way to print a newline than putStrLn "" ?
16:07:10 <hpc> putStr "\n"
16:07:16 <cheater> that's not a better way
16:07:25 <hpc> sure it is
16:07:35 <nisstyre> I doubt there's a function that's just newline = putStr "\n"
16:07:38 <cheater> no, you may make an error in typing \n and then you have a bug
16:07:40 <hpc> instead of saying you are printing a line that is ""
16:07:49 <hpc> you are saying you are printing a newline
16:07:52 <cheater> it's more difficult to make an error in ""
16:08:07 <srhb> nl = putStr ['\n'] -- job done!
16:08:10 <cheater> but yeah ok no function
16:08:15 <nisstyre> yeah but putStrLn is more likely to be misspelled
16:08:22 <nisstyre> putStrln putstrLn
16:08:24 <cheater> the compiler will catch that
16:08:41 <Tuplanolla> Might as well prepare for the day `String` is obsoleted and write `putStrLn mempty`.
16:08:45 <nisstyre> how would you typo \n ?
16:09:00 <cheater> it won't catch putStr "\m"
16:09:06 <Cale> Tuplanolla: Do you really think String will be obsoleted without OverloadedStrings?
16:09:10 <nisstyre> Tuplanolla: putStrLn uses the String type
16:09:14 <nisstyre> might as well use Text
16:09:20 <Tuplanolla> No.
16:09:48 <Cale> I don't think there's anything wrong with String continuing to exist, personally
16:09:54 <nisstyre> Data.Text.IO.putStrLn "\n" with -XOverloadedStrings is the future proof version
16:10:00 <cheater> i got super surprised today when i figured out after half an hour of confusion that Numeric.LinearAlgebra turns number literals into 1x1 arrays.
16:10:06 <Cale> Even though I use Text for pretty much everything anyway
16:10:08 <cheater> er matrices.
16:10:08 <nisstyre> I'm joking
16:10:38 <cheater> actually it wasn't even today haha, it was over the weekend
16:10:41 <cheater> i need some sleep :(
16:11:03 <nisstyre> yeah you should sleep
16:11:16 <nisstyre> also drink water
16:11:46 <Tuplanolla> On another note, it would be nice to have a function like `const`, but such that it lets the compiler choose the more favorable of the two arguments.
16:11:52 <hpc> it's got the electrolytes plants crave
16:12:49 <hpc> Cale: yeah, even if it's sub-optimal in nearly every situation it's easy to teach with
16:13:30 <srhb> Tuplanolla: unsafeAnySide
16:24:40 <Tuplanolla> You successfully tricked me into thinking that exists, srhb.
16:32:07 <Cale> Tuplanolla: unamb
16:32:24 <Cale> (though that doesn't let the compiler choose, just the runtime)
16:35:02 <Tuplanolla> That's it, Cale. It doesn't seem to be on Stackage though.
17:49:37 <trigone> re! some here told me import cycling wasn't supported by GHC (aside from some hacks with special files .hs-boot or sth). is that true even for this case: module A exports (x, y); module B imports A (x) and exports (A.x, z); can't A import B.z alone?
17:49:58 <MarcelineVQ> why not try it
17:50:16 <trigone>  MarcelineVQ honestly it'd be a bit complicated for me right now
17:50:25 <MarcelineVQ> then don't worry about it yet
17:51:28 <trigone> MarcelineVQ: ok, let me rephrase: if i try it, i'll have to refactor a big part of some package's structure, and i really don't want to do that unless i know it will work, so i need to know if it's doable bc it'd still be much easier on the long run...
17:51:38 <boj> trigone: write a small test project
17:51:44 <MarcelineVQ> why don't you try it on something fresh
17:52:01 <boj> prove to yourself your tiny example you posted works or not
17:54:07 <dsal> Hmm...  I'm trying to use aeson.  My type (Status) as a bunch of functions in the form of   Status -> t    I'm trying to avoid this:  object ["version" .= (version st), "cells" .= (cells st)]  -- is there a way to express something that looks like this:  object $ map (\(k, f) -> (k, f st)) [("version", version), ("cells", cells)
17:57:06 <boj> dsal: that would probably work if you applied lenses to your Status record
17:57:22 <boj> sadly record fields aren't first class citizens
17:57:29 <dsal> Shouldn't I be dreading lenses?
17:57:31 <dsal> These are fields.
17:57:51 <boj> embrace the lenses and love them for the pain they save you from
17:57:55 <dsal> newtype Status = Status B.ByteString
17:59:47 <dsal> I've not learned what a lens is yet.  Guess I'll need to get around to that.
18:00:50 <boj> they're quite a bit, but for starters "they make record access more sane"
18:01:17 <boj> they make mapping functions over arbitrarily nested records easy
18:01:39 <boj> and they allow you to pass accessor functions around like first class citizens (unlike actual record fields)
18:01:55 <boj> the latter seems close to what you want to achieve
18:04:29 <boj> the alternative is to hand right all of the accessors yourself, with the Status -> t bits, but that gets tedious for large records
18:05:04 <dsal> Does this not being an actual record have any relevance?
18:05:43 <boj> i may have misundstood your intent :)
18:06:02 <dsal> Well, I'm not using a record, but it looks like one
18:06:45 <eacameron> Is there a tool like stylish haskell that can get rid of needless parens on constraints, like (Eq x) => x
18:06:54 <boj> i assumed '(version st)' and '(cells st)' were accessing a record field, but i see now you posted a newtype. hmm
18:07:06 <dsal> I've got a lot of functions to access fields within a blob
18:08:38 <boj> gotcha
18:08:56 <dsal> I just need a list of strings to functions that take a status and return something that can json
18:09:34 <cheater> hey guys, how can i enable linking with -rtsopts from the command line when i do cabal install?
18:09:45 <cheater> i did cabal install --enable-profiling but that's apparently not enough.
18:10:07 <boj> dsal: the way you want to express it looks like it would work, assuming "version" and "cells" are functions that parse the Status blob out
18:10:09 <koz_> cheater: https://nikita-volkov.github.io/profiling-cabal-projects/
18:10:34 <cheater> thanks, looking
18:10:58 <dsal> I think I'm just having problems expressing it inline. I'll try it as a top level list
18:12:11 <cheater> koz_: i don't see anything in there about how to enable +RTS -K
18:13:46 <koz_> cheater: See the part 'Configuring the executable'?
18:14:10 <koz_> "-with-rtsopts=' sounds like what you want.
18:27:48 <cheater> hmm now it complains that -rtsopts is disabled with -shared. how do i turn off -shared?
18:33:16 <cheater> here's what it says exactly koz_ 'Warning: -rtsopts and -with-rtsopts have no effect with -shared.
18:33:19 <cheater> '
18:35:57 <boj> dsal: on thing to note with your approach is that each function in your [("field", field)] list need to have the same return type or it won't type check
18:36:54 <boj> the 'f' in your map (\(k, f) needs to be the same signature
18:36:57 <dsal> Yeah... Can't I make a class?
18:37:30 <boj> not sure how that would work
18:38:06 <dsal> Those two functions return different tripped and it works for building.
18:38:57 <dsal> Er, types. On the phone
18:39:33 <jerey> Hi! I'm hacking one thing and out of curiosity trying to do something crazy. Is it somehow possible to create pure function `foo`  that when used would be assigned with Int and would remember this Int? I mean `let a = [foo,foo,foo]` . These foo will create structures that contain numbers 0,1 and 2 respectively. I knwo this is an big antipattern and this function is not pure. But I'm just hacking things now
18:40:06 <cheater> no, it's impossible, that's the definition of pure function.
18:40:13 <cheater> no side effects.
18:40:28 <boj> well, you could partially apply the Int
18:40:49 <cheater> boj: he says it should have mutable state.
18:41:05 <boj> ah, right
18:41:32 <boj> wait, did he?
18:42:26 <boj> ah, the foo function is not pure
18:42:52 <cheater> yes, subsequent calls should change it
18:43:15 <cranej> jerey: perhaps what you want is a writer monad?
18:44:45 <jerey> cranej, boj, cheater : I know monads and transformers pretty well. I'm jsut thinking about creating a fancy edsl, that you could write `let a = b + c; x = a + a` and it will remmber these operations as Free-Monad thunks, so (b + c) would be a single thunk used twice. I know I can do it using monadic interface, I'm jsut trying to make it working in pure context
18:45:06 <jerey> I was trying to use unsafeperformIO and throwing mvars there but without success yet
18:45:21 <jerey> in fact the semantic of it is pure
18:45:55 <geekosaur> unsafePerformIO actually does the aopposite of what you want
18:46:23 <geekosaur> because the compiler is likely to trust your assertion that it is pure, and remember the result of foo instead of reinvoking it
18:46:40 <jchia> I'm trying to send a GET request with parameters and then get the status code and response body. What's a convenient library for that?
18:46:51 <MarcelineVQ> or even reinvoke it a few times and throw the whole thing off
18:47:13 <geekosaur> yeh, thgat's also conceivable
18:47:18 <boj> jchia: scotty is pretty quick to run with. servant if you want to head in a more advanced direction
18:47:38 <geekosaur> point is, un safePerformIO is not an escape hatch, it's a short route to weird behavior
18:48:53 <geekosaur> (and fancier versions are even worse. if you inline it, you can get *really* weird behavior.)
18:49:29 <cranej> jchia: wreq is a good http client library
18:49:44 <geekosaur> (the bytestring devds fondly call that one accursedUnutterablePerformIO, to give you some idea of what you're up against when you lie to the compiler like that)
18:50:07 <jerey> geekosaur: I understand it. I was rather thinking about creating some helper function, that before returning result from foo would create an mvar and while creating foo would change it 
18:50:26 <geekosaur> you still don't get it
18:50:35 <geekosaur> it can still be run only once ever, or more times than you expect
18:50:41 <geekosaur> it *is not an escape hatch*
18:50:51 <jchia> boj, cranej: Thanks. I'm checking out scotty & wreq.
18:50:53 <geekosaur> you are lying to the compiler and it *will* bite you back
18:51:17 <boj> jchia: sorry, what i mentioned were server libraries
18:51:38 <jerey> geekosaur: hm, ok, thanks! I have to think about it
18:52:16 <geekosaur> the compiler _understands_ purity and optimizes based on it. so the calls it makes will not match the ones you write
18:53:02 <geekosaur> if it thinks  it's faster to call it again rather then reuse an existing result, it will. if it thinks it's faster to save and reuse an existing result, it will
18:53:14 <geekosaur> becuase purity means it can do either one safely
18:53:38 <geekosaur> so if you lie to it about being pure, you will get nasty surprises. and the harder you lie, the nastier the surprises can get
18:54:10 <jerey> geekosaur: sure, but what if I slightly changethe situation and do `[foo 'a', foo 'b', foo 'c']` ? 
18:54:41 <boj> then you have what i suggested, which was to partially apply the values
18:54:48 <jerey> geekosaur: then I could create a no-inlinable "construction" function that could use this mvar and GHC would call it 3 times, because it does not have guarantee it could cache the results
18:54:49 <geekosaur> you're now gwtting into "what;s the point?" terriroty, for one
18:55:54 <jerey> geekosaur: the point is to write : `let e1 = var "a" + var "b"; e2 = e1 * e1` and build AST under the hood such that `e1` is a thunk that is there only once (ast based on a Map)
18:55:57 <geekosaur> anyway if you must play around with this, test at different optimization levels and examine the Core and don't be surprised if the compiler slips a knife into your back when you least expect it
18:56:27 <jerey> geekosaur: I dont have to, but I want, at least to better know ghc! :)
18:56:42 <geekosaur> yes, I get it, you want to know how far you can push lying to the compiler. the answer is always "not as far as you wish, and while you might be able to force the issue, the resulting overhead will likely be higher than just doing the right thing:
18:58:14 <geekosaur> read it and weep. be sure to read the linked tickets. then ask yourself whether you _really_ want to know. https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L566
18:58:29 <jchia> boj: OK, I'll just check wreq for now, then.
18:59:32 <geekosaur> in many ways, ghc's implementation of IO is a horrid hack that works only if you don't break the rules.
19:00:48 <geekosaur> the story of accursedUnutterablePerformIO is one of breaking the rules and finding out just how horrid and fragile a hack IO is
19:01:23 <jerey> geekosaur: oh, that looks crazy
19:02:14 <geekosaur> (even without any unsafe*PerformIO, it turns out that IO can break your program if you forkProcess with any threads running. But... the IO manager *always* has a thread running (even in the "non-threaded" runtime. So it's always risking a core dump.)
19:03:01 <geekosaur> because there's no safe way to avoid IO doing the wrong thing
19:03:19 <geekosaur> er, scrap "safe" there, not even *unsafe* ways
19:03:32 <jerey> geekosaur: wait, what do you mean? Do you mean that every haskell program can just core dump sometimes?
19:04:00 <geekosaur> most programs don't forkProcess
19:04:21 <geekosaur> ones that do should be careful not to have multiple threads running when they forkProcess
19:04:43 <geekosaur> (this actually is less of a problem than it sounds; even C can mishandle fork() with threads running.)
19:05:09 <jerey> oh ,interesting. I see warning about it in the docs
19:05:32 <jerey> geekosaur: thank you for all the information!
19:06:57 <geekosaur> the fundamental problem is that I/O channels ("file descriptors" on both POSIX and Windows) are process global, and therefore so are the I/O wrappers.
19:07:38 <geekosaur> forkProcess() does not copy threads, so if a thread somewhere is modifying the global I/O state, that will be forcibly terminated in the child, which will be left with inconsistent global I/O state
19:08:27 <geekosaur> if the next thing you do is exec() (C) or execProcess (Haskell), etc., then there isn't a problem. anything else, potentially including printing an error message about the failed exec, can trip over the inconsistent I/O state and core dump
19:11:03 <geekosaur> Winedows mostly voids this because it doesn't natively fork(), only spawn() which combines the two reliably. but fork() emulations common on Windows are even more at risk than the POSIX version
19:13:23 <geekosaur> and to tie this together: unsafePerformIO does some state manipulation since, being run from pure code, serialization isn't enough to make modifying the global I/O state safe. so it can be running undetectably, with a lock held on the global I/O state, and trip this. No way to stop it, and the child process will crash or hang
19:14:21 <geekosaur> (and iirc you can reliably wedge a ghc compiled program by forkProcess *inside* unsafePerformIO... and potentially confuse it badly by forkIO)
19:17:11 <jerey> geekosaur: very interesting! thanks for sharing this knowledge!
19:35:05 <cheater> i have a program that reads some json data, uses that to build a convex optimization problem (it tries to satisfy some constraints while trying to maximize some variables), and then it spits the result out via json to the standard output. i'm not sure what and how to unit test in this. what are some ideas that i could use here?
19:42:40 <u-ou-> how should I get [(1, 3), (2, 1)] from [1, 1, 2, 1,]
19:43:58 <geekosaur> > group . sort $  [1, 1, 2, 1,]
19:44:00 <lambdabot>  <hint>:1:29: error: parse error on input ‘]’
19:44:03 <geekosaur> > group . sort $  [1, 1, 2, 1]
19:44:05 <lambdabot>  [[1,1,1],[2]]
19:44:11 <geekosaur> hm, right
19:45:01 <geekosaur> > map (head &&& length) . group . sort $  [1, 1, 2, 1]
19:45:03 <lambdabot>  [(1,3),(2,1)]
19:45:15 <u-ou-> nice!
19:45:19 <u-ou-> I've never seen &&&
19:45:29 * u-ou- hoogles it
19:46:03 <geekosaur> also re your earlier question re stack/cabal and src/*: in the cabal file, hs-source-dirs: src
19:46:19 <geekosaur> this isn't even new, it's been in cabal for years and stack supported it from the beginning
19:46:28 <u-ou-> yeah, I found it =)
19:46:53 <geekosaur> (&&&) was originally Control.Arrow but now is Control.Category I think
19:46:56 <geekosaur> @index (&&&)
19:46:56 <lambdabot> Control.Arrow
19:47:25 <Clint> nobody loves arrows anymore
19:47:37 <geekosaur> it's the same operator in either case (Arrow is a weird mishmash of stuff that split up into Applicative, Category, and Profunctor)
19:51:17 <jchia> Question about wreq: Why is the value type for 'param' [Text] instead of Text? What exactly does an empty list or two-item list get translated to in the URL?
19:52:11 <halogenandtoast> quit
19:52:13 <halogenandtoast> sigh
19:52:56 <geekosaur> http://hackage.haskell.org/package/wreq-0.5.1.0/docs/Network-Wreq.html#v:param
19:53:11 <geekosaur> "A lens onto all query parameters with the given name (there can legitimately be zero or more)."
19:54:00 <jchia> yeah, so if I give an empty list it is the same as not using the param?
19:54:09 <Clint> i would assume it would be ?foo
20:00:47 <onethirtyfive> Does anyone know how to convert a Word32 (bitwise) to a signed int?
20:03:10 <`Guest00000> how do i do networking with lazy IO?
20:05:15 <`Guest00000> i want to decode and deserialize an encrypted protocol IO-transparently for the decoding and deserializing algorithms, which operate on lazy ByteStrings
20:05:30 <Clint> > fromIntegral (255 :: Word8) :: Int8 -- onethirtyfive, what do you mean by bitwise?
20:05:32 <lambdabot>  -1
20:06:28 <onethirtyfive> Clint: I'm reading bits using Data.Binary.Bits.Get, and they're being read into a Word32/64. But the bits sometimes specify a signed value.
20:07:28 <onethirtyfive> So I want to reinterpret those bits as signed.
20:07:37 <onethirtyfive> as a signed int, sorry
20:07:47 <Clint> so fromIntegral should be fine
20:08:13 <onethirtyfive> Hm, OK, let me plunk around in ghci a bit.
20:11:06 <onethirtyfive> https://gist.github.com/onethirtyfive/c4a7257a403bca6c818b3d7f26b342c4
20:11:30 <onethirtyfive> I needed to use Int32 to constrain the interpretation.
20:12:02 <onethirtyfive> Thanks!
20:41:35 <tabemann> I'm having trouble building the package gtk3 with cabal
20:42:23 <tabemann> specifically, I am getting errors about compilation with -fPIC being necessary, but when I use cabal to set -fPIC in ghc-options by default (and -static in ld-options) it still doesn't work
20:51:55 <tabemann> http://lpaste.net/357879
20:53:12 <cqrql> Has anyone encountered errors about bad interface files with backpack? `Something is amiss; requested module  tisch-0.1:Tisch differs from name found in the interface file tisch-0.1[Tisch.Internal.Record=<Tisch.Internal.Record>]:Tisch`
21:03:57 <remexre> Is there a way to set a global on program start that needs an IO?
21:04:38 <remexre> e.g. defaultHistoryPath = ioOnStart $ getXdgDirectory XdgData "coolprogram/history"
21:05:21 <tabemann> there is a way to do it, but it's highly deprecated
21:05:48 <jchia> Question about aeson: Why is there toJSON & toEncoding in the ToJSON typeclass? This seems to be requiring the user to repeat himself.
21:05:57 <remexre> tabemann: unsafePerformIO?
21:06:08 <tabemann> yes
21:06:25 <remexre> ugh
21:06:46 <tabemann> you're best off using a state monad
21:07:17 <remexre> like defaultHistoryPath :: ST FilePath ?
21:07:28 <tabemann> no no no not St
21:07:29 <tabemann> *ST
21:07:34 <tabemann> I mean StateT
21:08:26 <remexre> What would the type look like?
21:08:55 <remexre> If (getXdgDirectory XdgData) :: String -> FilePath, from a dependency (not my code)
21:08:58 <Cale> unsafePerformIO won't do it on program start either
21:09:12 <Cale> It'll do it on first evaluation of the constant
21:09:57 <tabemann> StateT FooType IO a
21:10:12 <tabemann> where FooType is your state type
21:11:46 <cqrql> jchia: `toEncoding` isn't strictly required. You can add it to improve performance
21:11:48 <tabemann> does anyone have any idea as to why ld is freaking out when I try to compile gtk2hs-buildtools?
21:12:08 <remexre> tabemann: I'm still confused... so my functions that would otherwise use defaultHistoryPath would instead use StateT, and get the "real" defaultHistoryPath value via the state monad?
21:13:39 <tabemann> StateT s m a is the monad in which those functions would execute, and they would use get to get the path
21:14:20 <remexre> tabemann: Couldn't I just pass the defaultHistoryPath in as a parameter, then?
21:14:55 <Cale> Yeah, the correct thing to do is just to define a Config type for your application, and make this thing a field of that, and obtain it at the top of IO, and pass it around somehow.
21:14:58 <tabemann> threading lots of things through gets to be a hassle
21:15:06 <tabemann> yes, what Cale said
21:15:19 <tabemann> you don't just put one thing into a StateT
21:15:20 <remexre> I'm actually passing this to my config parser :P
21:15:24 <cqrql> I thought I remembered that there's a flag to get GHC to print its time spent in each phase of compilation. Am I making that up?
21:15:35 <Cale> You don't even necessarily want StateT
21:15:37 <tabemann> you put everything possible in a data structure and then put that into the StateT
21:15:54 <Cale> I would usually not use a monad transformer over IO for this alone.
21:16:06 <remexre> I do need the IO to load the "real" config tho
21:16:10 <remexre> So should I do something like:
21:16:13 <Cale> (and if you are going to use a transformer for this, ReaderT makes more sense)
21:16:23 <remexre> loadConfig :: ReaderT Config IO Config
21:16:36 <Cale> nah, loadConfig :: IO Config
21:16:37 <remexre> where the reader'd config is the default?
21:16:48 <Cale> and then you runReaderT with the result of that
21:17:06 <remexre> hm, ok
21:17:13 <Cale> But honestly ReaderT for only this is probably not worth it
21:17:20 <tabemann> yes
21:17:26 <Cale> since you'll have to liftIO all over the place
21:17:31 <tabemann> and when monads start stacking it gets to be a pain
21:17:50 <Cale> If you have to think in terms of "stacking", you're doing it wrong
21:17:53 <tabemann> it's more when you have many things to pass around that you really want a ReaderT or StateT
21:18:22 <Cale> Well, it's more that IO has a lot of nice higher order facilities which you lose immediately if you transform it
21:18:34 <remexre> Yeah, I'll probably just pass through the defaults; I have enough pure functions that I don't want a bunch of IO-ness
21:18:40 <Cale> e.g. catch and forkIO
21:19:34 <Cale> and while there are libraries that try to help with that (MonadBaseControl), they usually just obscure the issue more than actually helping
21:20:19 <Cale> Mostly, I would only use ReaderT over IO if I already had a better reason to transform IO
21:20:29 <Cale> Otherwise, parameter passing isn't that bad
21:22:53 <Cale> There are some cases where perhaps I'll have a pretty good idea of exactly which primitive actions I want to provide in my monad, and they only require ReaderT -- for example, I might have a monad for constructing database transactions, within which I wouldn't expect much (or perhaps even disallow) liftIO
21:23:11 <Cale> and then, fine, newtyped ReaderT over IO it is
21:24:26 <Cale> But those sorts of things are usually better approached from the other direction, from writing all the operations you'll need with explicit parameter passing, and making sure they're all plausible that way before wrapping them up.
21:29:12 * hackagebot SVGFonts 1.6.0.2 – Fonts from the SVG-Font format – https://hackage.haskell.org/package/SVGFonts
21:44:01 <dsal> I'm trying to use Aeson.  It's got a class "ToJSON" for which it has instances for a ton of different types, including Double.  I'm confused as to why this doesn't do what I expect:  http://lpaste.net/357880
21:44:25 <dsal> version is   Status -> String  and avg_amps  is Status -> Double
21:45:07 <dsal> According to https://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson.html it's got a ToJSON instance for String and for Double.
21:46:31 <dsal> Oh, it can't match String either when I comment out the Double one.  So that's something.
21:46:49 <lyxia> dsal: A list must have elements of the same type
21:47:09 <lyxia> dsal: (Text, Status -> Double) is a different type from (Text, Status -> String)
21:47:32 <dsal> Well, I can't even have the same type.
21:47:33 <lyxia> dsal: The type you wrote means the caller gets to decide how to instantiate j
21:47:45 <lyxia> which can be yet another different type from Double and String
21:48:05 <dsal> Is there no way to do the thing I'm trying?  It seems pretty sensible.
21:48:12 <lyxia> just write a tuple
21:48:31 <dsal> It is a tuple.
21:48:39 <lyxia> this is a list
21:48:43 <dsal> It's a list of tuples.
21:49:07 <lyxia> I meant to make a tuple of tuples
21:49:14 <dsal> Oh.
21:49:37 <dsal> I'm not sure how to consume a gigantic tuple like that.  How does it work?
21:49:51 <lyxia> uh, you don't.
21:50:04 <lyxia> The example you showed is a tuple with two elements
21:50:10 <lyxia> is that what you call gigantic?
21:50:27 <dsal> I've just started.  If I only had two, I wouldn't be worried about this.
21:50:57 <dsal> aeson lets me do this:    toJSON st = object ["version" .= (version st), "cells" .= (cells st)]
21:51:37 <dsal> So this is a list of pairs where the right side is ToJSONable stuff.  I'm just trying to not have to spell  "f"   "(f st)" every time.
21:52:39 <lyxia> ToJSONable stuff, but all of the same type
21:52:43 <dsal> Having this list of kv sets is doubly useful because aeson requires the toJSON method, but benefits greatly from having a secondary encoding method that performs better.
21:52:55 <dsal> (version st) is a String.   (cells st) is a Double
21:53:15 <lyxia> what's the type of st
21:53:20 <dsal> Status
21:54:51 <dsal> So it's just not obvious to me why I can't have   jsonstuff ::(ToJSON j) => [(Text, Status -> j)]     where I map over that to pass the Status in for each second and end up with a ToJSON
21:55:20 <`Guest00000> [ f x | x <- fromIntegral <$> l ]   <--- how do i force x to be polymorphic (like Num a => a) instead of monomorphic (like Int) inside the comprehension expression?
21:55:42 <dsal> That sounds related to my issue.  heh
21:56:37 <lyxia> `Guest00000: [ f x | y <- l, let x = fromIntegral y ]
21:57:16 <`Guest00000> lyxia: why does the former syntax not work by default and can i make it work?
21:58:49 <lyxia> `Guest00000: if x has type (forall a. Num a => a), that makes (fromIntegral <$> l) have type [forall a. Num a => a], which is an impredicative type, which is not supported by GHC.
21:59:06 <`Guest00000> ok thank you
21:59:56 <lyxia> Even if it did it would still have to infer that type instead of forall a. Num a => [a]
22:00:18 <lyxia> which seems much more common
22:00:33 <lyxia> so you would probably need an annotation somewhere anyway
22:00:46 <`Guest00000> could have an -X... switch
22:01:23 <lyxia> Sure, the problem is noone figured out a good way to implement this
22:02:08 <`Guest00000> dsal
22:02:13 <lyxia> ACtually, there is currently -XImpredicativeTypes which was meant to do that, but it has not been maintained in a long time and the user manual warns that it is a half-assed feature.
22:02:35 <`Guest00000> it looks like you want ExistentialQuantification
22:04:31 <lyxia> It's an antipattern though
22:04:52 <`Guest00000> why is it an antipattern
22:04:56 <`Guest00000> it's a very nice feature
22:06:33 <lyxia> It's an antipattern because there's little you can do on an existentially quantified type only with a ToJSON constraint.
22:07:07 <dsal> I can convert it ToJSON, which is the only thing I want to do with it.
22:07:44 <pacak> dsal: Why not convert it to json before placing into container?
22:08:12 <dsal> Because that requires a ton of boilerplate.
22:08:50 <pacak> Is it?
22:08:52 <pacak> :t toJSON
22:08:54 <lambdabot> error: Variable not in scope: toJSON
22:09:14 <pacak> Hmm... In both cases you have something foo :: ToJSON a => a -> b
22:09:32 <pacak> but in one case b is your type with json dictionary inside, in second case - it's actual json...
22:10:44 * hackagebot mixed-types-num 0.3.1.3 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
22:11:14 <dsal> For each field, I have to pass the value to the accessor in order to get the ToJSONable thing back.
22:11:42 <dsal> [("version", version), ("avg_amps", avg_amps)]     vs.   ["version" .= (version st), "cells" .= (cells st)]
22:12:53 <dsal> But also, ToJSON toJSON that looks like   object ["x" .= x, "y" .= y]    and toEncoding that looks like   pairs ("x" .= x <> "y" .= y)
22:13:05 <dsal> So with a lot of fields, I end up with a lot of duplication.
22:13:28 <pacak> Hmm...
22:13:39 <pacak> I suspect that you are missing something.
22:13:59 <pacak> But if ExistentialQuantification works for you then just use it...
22:14:21 <dsal> Well, I'm surely missing something, but if there's a good way to do this, that's what I'd prefer.
22:16:29 <awoserra> anyone running haskell-platform on OpenBSD?
22:16:51 <awoserra> i've installed, can use runghc, but the entire tutorial uses the stack command, which is not in my path
22:17:51 <pacak> stack is not haskell platform.
22:17:58 <pacak> I think
22:18:27 <awoserra> i'm just going by https://haskell-lang.org/get-started
22:19:15 <pacak> awoserra: There's no openbsd on that page.
22:19:18 <awoserra> maybe i need to be https://wiki.haskell.org/Tutorials
22:19:23 <awoserra> i see that
22:19:26 <dsal> There's also no mention of haskell-platform
22:19:45 <awoserra> thats the OpenBSD pkg 
22:21:13 <pacak> awoserra: do you have cabal and ghci?
22:21:56 <awoserra> yes, both.
22:22:04 <pacak> Just use them.
22:22:08 <pacak> ghci
22:22:11 <pacak> print "hello world"
22:22:11 <awoserra> k
22:22:13 <pacak> try ^
22:23:39 <awoserra> just this right?:
22:23:40 <awoserra> main :: IO ()
22:23:42 <awoserra> main = putStrLn "Hello World"
22:23:49 <awoserra> in helloworld.hs
22:24:09 <pacak> about
22:24:20 <awoserra> then running ghci helloworld.hs gives me a *Main> prompt
22:24:25 <pacak> type main
22:24:26 <pacak> "main
22:24:28 <pacak> '
22:24:41 <pacak> or runhaskell helloworld.hs
22:24:54 <pacak> or ghc  helloworld.hs && ./helloworld
22:25:28 <awoserra> runhaskell works, but i get a permission denied with the second..
22:25:37 <awoserra> even if i chmod +x
22:26:04 <awoserra> ksh shell
22:26:54 <pacak> Hmm... Strange
22:27:01 <dsal> Are you in a noexec fs or something?
22:27:05 <pacak> Can you run other binaries from that partition?
22:27:17 <awoserra> yes, let me double check
22:28:05 <awoserra> ah hmmm... doesn't like the ./ lemme try sh
22:28:19 <dsal> It's definitely not a shell script.
22:28:34 <awoserra> yah no
22:28:39 <lyxia> dsal: You can write a version of (.=) and object that take care of passing st around.
22:29:03 <dsal> Yeah, I just read the .= thing to see what it did.
22:29:07 <lyxia> dsal: and you can then overload them to work with both toJSON and toEncoding
22:29:16 <awoserra> ./ is meaning something else in ksh shell
22:29:24 <awoserra> changing my path
22:29:25 <dsal> awoserra: Did you type ./ on its own?
22:29:37 <awoserra> $ ./
22:29:38 <dsal> Can you paste exactly what you typed?
22:29:39 <awoserra> ksh: ./: cannot execute - Is a directory
22:29:39 <dsal> @paste
22:29:39 <lambdabot> Haskell pastebin: http://lpaste.net/
22:29:44 <dsal> You can't run directories.
22:29:53 <dsal> That wasn't what pacak suggested you try.
22:30:06 <awoserra> i know, i tried that
22:30:13 <awoserra> $ ./helloworld                       
22:30:13 <awoserra> ksh: ./helloworld: Permission denied
22:31:01 <lyxia> dsal: .= is actually already overloaded so you're already halfway there.
22:31:02 <awoserra> exec helloworld same output
22:31:03 <dsal> You must have a noexec fs or something.
22:31:54 <dsal> lyxia: Yeah, I read the code.  Just a bit disappointed that I can't do the thing I was trying to do.  I'm sure there's a reasonable solution somewhere around here.  I just thought I'd be able to express this.
22:32:01 <awoserra> sec, let me check that
22:32:28 <dsal> exec means something else
22:33:44 <awoserra> i'm on default openBSD... 
22:34:10 <awoserra> would i find that info out with gpart? noexec flag on the partition?
22:34:29 <dsal> It's a mount flag.
22:34:31 <pacak> awoserra:  mount | grep noexec
22:34:52 <awoserra> nothing
22:34:53 <pacak> cp `which ls` .
22:34:55 <pacak> ./ls
22:35:24 <dsal> I've not touched an OpenBSD box in a while.
22:35:33 <dsal> It's possible they've made it so you can't execute stuff you built for security reasons.
22:36:26 <awoserra> works
22:36:43 <dsal> It's not missing the x bit is it?
22:36:50 <dsal> Maybe the compiler just doesn't work.
22:37:04 <pacak> ls -lha ls helloworld
22:37:12 <pacak> Anything different?
22:37:13 <awoserra> -rwxr-xr-x  1 awoserra  awoserra  2116803 Aug 21 23:24 helloworld
22:37:25 <dsal> lgtm
22:37:29 <dsal> I don't know what OpenBSD's doing there.
22:37:55 <pacak> Hmm..
22:38:01 * pacak is in Aug 22 already
22:38:11 <dsal> Mornin'!
22:38:23 <pacak> It's past midday...
22:38:27 <awoserra> heh
22:38:29 <pacak> But Mornin' :)
22:39:12 <awoserra> it's changing my path
22:39:16 <awoserra> ./ i mean
22:39:19 <awoserra> let me ask openbsd
22:54:40 <awoserra> dmesg now shows ./helloworld(80945): W^X binary outside wxallowed mountpoint
22:54:56 <awoserra> #OpenBSD says: Maybe you're violating W^X without "wxalloved" mount flag due to haskell being 
22:54:59 <awoserra>                 stupid
22:55:07 <awoserra> sorry, bad paste there
22:56:03 <Myrl-saki> something something... stupid.
22:56:42 <awoserra> i have nine entries in dmesg like that now ><
22:58:23 <Myrl-saki> :P
22:59:49 <pacak> awoserra: chmod -w helloworld ?
23:00:34 <awoserra> ok...
23:01:35 <awoserra> still same error
23:01:43 <awoserra> and now ten entries in dmesg ><
23:01:55 <pacak> I have no ideas then.
23:03:14 <dsal> awoserra: https://www.openbsd.org/faq/upgrade60.html
23:03:26 <awoserra> i'm in 6.1
23:03:59 <dsal> I assume they didn't get rid of that feature in 6.1
23:04:20 <awoserra> reading, thx :)
23:04:40 <pacak> Guys on #openbsd are being cryptic.
23:05:04 <awoserra> yes ><
23:05:06 <awoserra> it's not helpful
23:05:08 <awoserra> hahaha
23:05:13 <pacak> Maybe  they do have their reasons - to make you read documentation...
23:06:18 <awoserra> well, when a person has no idea where to start reading an awful lot of documentation...
23:06:49 <dsal> Having written this with an emacs macro, it feels like I should pick up template haskell before too long: http://lpaste.net/357881
23:07:46 <awoserra> ty dsal, very helpful :)
23:07:54 <cocreature> dsal: GHC Generics or something like generics-sop might also be worth a look
23:08:02 <cocreature> imho they are a bit nicer to work with than TH
23:08:25 <dsal> I've got a bunch of other probably more useful things to learn before this particular bit of code is useful.  :)
23:09:56 <norc_> Okay I have used an answer from stack overflow to work out how haskell transforms my program to see how this client/server example translates, and there was nothing surprising about it.
23:10:00 <norc_> https://gist.github.com/anonymous/8144df15fd0445aaee43f2b376d72b39
23:10:25 <norc_> However, that notion of lazy pattern matching still escapes me. Lets assume the pattern match of client was strict, how would that change anything in that?
23:11:47 <norc_> I have a feeling that if the pattern matching was strict, it would stop at line 18 and end up in an infinite recursive match for both server (req:reqs) and client initial (resp:resps).
23:12:01 <norc_> Because it turns out, making either (!) lazy is enough to make the program work
23:12:13 <norc_> So there must be a relationship between those two
23:13:26 <Cale> norc_: You can understand a lazy pattern like ~(x:xs) as just being the same as matching the list like vs and then writing head vs and tail vs in place of x and xs respectively.
23:13:50 <norc_> Cale: That I understand. Let me ask differently then.
23:14:02 <norc_> How does strict pattern matching work like?
23:14:40 <Cale> It evaluates the argument (outermost-first, more or less) up to determining which pattern is matched
23:15:29 <Cale> If you have something like  case foo a b c of [] -> ...; (x:xs) -> ...
23:15:46 <Cale> then the pattern match waits on the stack
23:16:16 <Cale> and the body of foo is entered with the parameters of foo bound to a, b, c
23:16:50 <Cale> and you basically follow evaluation along until either it becomes apparent that the result is [] or the result is some expression of the form x : xs
23:17:18 <Cale> at which point evaluation stops, and the potentially unevaluated expressions for the head and tail of the list are bound to x and xs
23:17:27 <Cale> (and you take that branch of the case)
23:18:49 <Cale> norc_: So let's imagine that client is doing a strict pattern match the same way server is
23:20:14 <Cale> Then if we try to evaluate resps, we'll have to evaluate server reqs, at which point reqs will get matched against the pattern (req:reqs) (annoyingly binding a variable of the same name, but whatever), so we need to evaluate reqs
23:20:26 <Cale> reqs = client initial resps
23:20:35 <Cale> So we evaluate client initial resps
23:20:53 <Cale> and then client won't have the lazy match on resps, so we'll immediately need to evaluate resps
23:21:01 <Cale> Oh, but that's what we were already trying to do
23:21:16 <Cale> So, evaluation will fail, we've detected an infinite loop.
23:21:41 <Cale> (which you may actually get as an "Exception: <<loop>>")
23:25:00 <Cale> The way this stuff is implemented, each variable (which may be bound to an as-yet-unevaluated expression) is implemented as a pointer to code. The first time the code is entered, what happens is that the pointer is rewritten to point at a bit of code which throws an exception if entered (a "black hole"), and then the value of the expression is computed (i.e. up to determining the outermost data constructor), and 
23:25:00 <Cale> finally the pointer gets rewritten to point at a short piece of code which will return the already-computed value immediately if the variable is re-entered.
23:27:07 <Cale> (There are some additional tricks to this, and in the threaded runtime, the black hole is replaced with a "grey hole" that blocks, because another thread may be evaluating the variable already, etc...)
23:30:29 <Cale> Oh, norc_ actually disconnected... oh well, hopefully 
23:30:41 <Cale> they'll be able to see it in the logs...
23:32:20 <boj> :)
23:36:54 <Cale> There needs to be something which is like halfway between IRC and a wiki, where the boundaries between messages become blurry after people talk, and anyone in the chat can go back and revise the conversations into documents which can be cut apart into hyperlinked pages.
23:37:10 <dsal> Ooh.  Can we call it Wave?
23:37:24 <Cale> I miss the way we used to use the old Haskell Wiki, the one before it became MediaWiki
23:41:31 <texasmynsted> Ryver?
23:41:48 <texasmynsted> do not know Wave
23:44:22 <boj> an old Google product that was hyped but killed
23:44:47 <yoneda> Cale: +1
23:57:26 <epta> http://lpaste.net/3788371814627934208 how should one read it? "Trying to build cabal-helper. Versions 0.8.0.0, 0.7.3.0, 0.7.2.0 are rejected because there is a constraint '==0.7.1.0'. Version 0.7.1.0 is rejected, because there is a constraint '==0.6.3.1'. The rest is rejected because there is a constraint '==0.7.1.0'". Where these constraints come from? How to solve this? 
