00:00:10 <Axman6> :'(
00:00:41 <pacak> Different people like different kinds of extreme sports.
00:00:54 <pacak> Some like ints disguised as pointers.
00:03:56 <ongy> best part about IntPtr, it will have fun with signed numbers, since it's Int, not Word. Oh, there's WordPtr
00:20:58 * hackagebot lens 4.15.4 – Lenses, Folds and Traversals – https://hackage.haskell.org/package/lens
00:39:11 <Marisa> Hello, I am having trouble understanding De Bruijn Index Partial Evaluation, can anyone help?
00:39:20 <Marisa> http://okmij.org/ftp/tagless-final/course/TTFdB_pe.hs
00:39:37 <Marisa> In particular, there's this line:
00:39:38 <Marisa>   -- Dyn is the identity transformer; applying it to P repr h a
00:39:39 <Marisa>   -- should convert P to a purely dynamic value
00:39:39 <Marisa>   Dyn  :: EnvT repr hin hin
00:40:10 <Marisa> I dont get why should it convert stuff to a dynamic value...
00:41:15 <Marisa> there's also this line of pattern matching, app_open e Dyn            = Unk (dynamic e), which is covered by all other cases. So what will happend if it is not there?
00:41:17 <pacak> okmij.com, having trouble understanding.
00:41:21 <pacak> Everything adds up.
00:42:18 <Marisa> I like to do hard stuff... also I am having a toy language in DBI, and is trying to do partial evaluation on it
00:45:26 <opqdonut> Marisa: as far as I can tell the "app_open e Dyn = Unk (dynamic e)" is precisely the implementation of "Dyn is the identity transformer; applying it to P repr h a
00:45:32 <opqdonut> should convert P to a purely dynamic value"
00:45:44 <Marisa> yes, that is correct
00:46:21 <Marisa> but why? My question is precisely "why does it need to convert P if it is doing nothing"
00:48:05 <opqdonut> this is the first time I see this code, sorry can't really help you
00:49:06 <Marisa> NP, I think I'd reach more people with r/haskell ... thx :)
00:54:39 <grr12314> hello. why does the repl on haskell.org fail for even simple string literals like "zzz"? mueval-core: Time limit exceeded ExitFailure 1
00:54:56 <grr12314> or once it returned just a single "
00:55:23 <opqdonut> heh, weird
00:55:29 <opqdonut> ['a','b','c'] works
00:55:41 <grr12314> "hello" works too
00:55:57 <opqdonut> really weird
00:56:06 <opqdonut> length "abc" fails too
00:56:14 <grr12314> but "hell" returned "h
00:56:46 <grr12314> and timeouts again
00:56:59 <opqdonut> maybe some server is overloaded
00:57:02 <pharaun> > length "abc"
00:57:04 <lambdabot>  3
00:57:09 <opqdonut> even length [1,2,3] is failing
00:58:07 <foldr> Very slow lazy evaluation :P
01:07:50 <butterthebuddha> I've got 2 types that have the same constructors
01:08:07 <butterthebuddha> How do I distinguish between the constructors
01:08:19 <foldr> butterthebuddha: Are the constructors defined in the same module?
01:08:24 <butterthebuddha> Nope
01:08:35 <foldr> Then you can import the modules they are defined in as qualified
01:08:51 <butterthebuddha> ?
01:08:52 <foldr> For example: import qualified Foo.Bar as Bar; import qualified Foo.Baz as Baz
01:08:59 <foldr> Then Bar.MyConstructor and Baz.MyConstructor
01:09:22 <butterthebuddha> Ah
01:09:27 <butterthebuddha> Any other way?
01:09:35 <butterthebuddha> that would break a ton of code
01:10:39 <foldr> The only other way to do it is to rename the constructors
01:11:00 <bvad> butterthebuddha: How will it break code? Maybe you can get away with just importing the newer module qualified
01:11:09 <foldr> Maybe you can do some trickery with type classes and pattern synonyms
01:11:12 <foldr> To get overloading
01:11:24 <foldr> But it's probably better to just rename one thing or import qualified
01:11:25 <butterthebuddha> bvad: the new types are in the same class as I am
01:11:30 <butterthebuddha> Or module rather*
01:12:12 <bvad> Well then.. At least renaming or importing qualified will give you compile-time errors ;) 
01:13:51 <butterthebuddha> Is there anyway I can 'embed' a type's constructors inside others?
01:14:08 <butterthebuddha> Because the new type is essentially the same as the old type but extends it with a new constructor
01:14:53 <bvad> data New = NewConstructor | OldContructor Old
01:15:25 <quchen> phadej: Did the matrix build for 0.6.8 yield anything?
01:15:44 <quchen> If not, I’d release the new version
01:16:40 <phadej> quchen: you got me wrong, the trifecta's old version might be affected - but we can fisx them after the release
01:16:46 <phadej> so go ahead from my side
01:16:58 <quchen> Alright!
01:17:01 <phadej> though you want to release new trifecta as well then
01:19:01 <phadej> ping RyanGlScott though about it
01:23:30 <cocreature> for a moment I was exited because I thought quchen managed to sneak prettyprinter into trifecta
01:24:36 <quchen> cocreature: I managed to sneak a change into ansi-wl-pprint that allows me to use Trifecta with prettyprinter.
01:25:11 <cocreature> quchen: oh that sounds pretty nice! so I guess I just need to call some conversion function?
01:25:24 <quchen> cocreature: Exactly
01:25:29 <cocreature> I actually have a project that uses trifecta and prettyprinter so that seems really useful!
01:25:59 <quchen> It’s not 100% isomorphic, but in order to find something that doesn’t work you have to be actively trying
01:26:10 <quchen> …up to bugs, of course.
01:27:52 * hackagebot ansi-wl-pprint 0.6.8 – The Wadler/Leijen Pretty Printer for colored ANSI terminal output – https://hackage.haskell.org/package/ansi-wl-pprint
01:28:26 <cocreature> everyone knows that Haskell code doesn’t contain bugs
01:28:41 <quchen> ლ(ಠ益ಠლ) 
01:28:55 <Myrl-saki> lol
01:29:11 <Myrl-saki> cocreature: If anything, it's the specification that's wrong right?
01:29:22 <tdammers> Haskell code doesn't contain bugs, it merely describes them in a pure DSL; the actual bugs are produced by the impure runtime that interprets the DSL
01:29:42 <Myrl-saki> tdammers: 1 `div` 0?
01:30:18 <pacak> % const ()
01:30:28 <pacak>  > const () 1
01:30:38 <Myrl-saki> :t const
01:30:39 <pacak> Oh noes. Both bots are dead
01:30:40 <lambdabot> a -> b -> a
01:30:45 <Myrl-saki> Oh cool.
01:30:46 <opqdonut> > const () 1
01:30:48 <lambdabot>  ()
01:30:53 <opqdonut> you just had a whitespace
01:31:23 <quchen> PHP code doesn't contain bugs, it merely describes them in a pure DSL; the actual bugs are produced by the impure runtime that interprets the DSL
01:32:09 <tdammers> quchen: exactly
01:32:57 <tdammers> quchen: the differnce being that PHP can describe *only* bugs
01:33:15 <Myrl-saki> lol
01:33:29 <quchen> It’s particularly efficient at not avoiding bugs, yes.
01:33:35 <Myrl-saki> PHP bashing is uncool, but it's still funny.
01:34:00 <Myrl-saki> How about C? :D
01:34:18 <quchen> I don’t think you can bad-mouth this language enough. A bad culture around it will hopefully make it die faster.
01:34:59 <quchen> There are many languages I don’t like, but very few of them are insulting.
01:36:00 <pacak> Is it a good idea to implement a system to serve a client 30Gb of some abstract data per 8 hours over 100 concurrent telnet sessions, each session handles some specific type of data - can be larger, can be smaller, each telnet session running a combination of netcat and tail -f? Number of consumers is limited by let's say 10, so 1000 telnets and 300Gb...
01:37:10 <Myrl-saki> What's the minimum amount of RAM that a GHC-compiled program requires?
01:37:36 <dmitrydzhus> 640KB should be enough for everybody
01:37:36 <foldr> Myrl-saki: Which platform?
01:37:37 <quchen> Not that much I think
01:37:51 <Myrl-saki> dmitrydzhus: :D
01:37:55 <Myrl-saki> foldr: Linux.
01:37:59 <foldr> Compile main = pure () with optimization and measure :3
01:38:22 <pacak> ghc version?
01:38:31 <pacak> 64 bit or 32 bit?
01:38:41 <Marisa> I think i get what it means, thx you all.
01:38:59 <Myrl-saki> 64-bit
01:39:10 <Myrl-saki> I'd set up cross compilation, but it seems like a pain.
01:39:11 <quchen> phadej: Do you have the link to the Trifecta issue?
01:39:15 <quchen> I can’t find the ticket
01:42:57 <jle`> is there a lib that lets me expand out ~/blah and ~adam/blah filepaths to their full paths
01:43:14 <jle`> i'm using my own custom function from the unix package right now that lets me do it manually
01:43:23 <jle`> by pattern matching on ~, and using span (/= '/'), heh
01:43:38 <ertes-w> elo
01:43:48 <Athas> That's risky, since '~' is a perfectly valid Unix filename.
01:44:02 <jle`> indeed i am not happy with this
01:44:11 <jle`> maybe i am XY-probleming this
01:44:16 <Athas> Probably valid on legacy operating systems too.
01:44:25 <ertes-w> jle`: that expansion is shell-specific functionality
01:44:40 <jle`> what i really want to be able to do is allow the user to pass in `~/foo.txt` as an argument, and for readFile to treat it properly
01:44:41 <ertes-w> and so is the precise syntax
01:44:53 <ertes-w> jle`: don't do that
01:44:57 <ertes-w> that's the shell's job
01:45:11 <jle`> so what should i make the user do
01:45:14 <jle`> enter the full path?
01:45:17 <grr12314> you can invoke realpath
01:45:27 <ertes-w> jle`: just open whatever path you get
01:45:38 <grr12314> but indeed the shell should have already substituted it when passing it to you
01:45:39 <jle`> doesn't that break some user expectations
01:45:44 <ertes-w> jle`: no
01:45:54 <jle`> by some user i mean me-as-a-user v.v
01:45:54 <ertes-w> jle`: try this in your shell:  cat "~/blah"
01:46:34 <Athas> If you want that translation, it should be done at the UI layer.
01:46:41 <ertes-w> if you were to create a directory named "~" in the current directory and put a file named "blah" there, 'cat' would print it
01:46:49 <Athas> Emacs, for example, does it that way.  The internal file open functions don't perform the translation.
01:47:46 <foldr> `~' is a character which may occur in file names. Therefore you do not want the lowest level open function to translate it.
01:47:48 <ertes-w> jle`: in any case, if you get the path from command-line arguments, don't do any translation at all, because the shell will do it, and by doing it yourself you will prevent your users from referring to certain (oddly named, but still valid) file names
01:47:49 <jle`> hm it looks like actually the shell does handle it for me when it is passed in as an argument
01:48:05 <jle`> but if i prompt the user for a directory using getLine, then i'm in trouble
01:50:03 <ertes-w> jle`: yes, in that case you will have to emulate your shell's behaviour
01:50:15 <grr12314> yeah and "invoke realpath" was wrong too - i just got confused by the shell fixing the path before passing it to realpath
01:50:16 <jle`> i could shell out into realpath
01:50:28 <ertes-w> but it's easy enough: if the path is relative, check the first component
01:50:30 <jle`> gross
01:50:30 <Athas> My experience is that if you start imitating _some_ shell behaviour, users will be annoyed unless you imitate _all_ shell behaviour.
01:51:15 <ertes-w> jle`: if you want to have some shell fun try this:  touch -- ~/"-rf *"
01:51:34 <grr12314> lol fun
01:52:20 <grr12314> well at least it can not contain /* :p
01:52:40 <grr12314> it could contain .. tho...
01:52:45 <jle`> i've actually accidentally touched '~' before
01:52:51 <jle`> rmeoving it was definitely...a stressful experience
01:53:22 <Athas> Emacs (at least with ido-mode) does this the right way: if you enter '~/' in the file selection prompt, it will interactively rewrite it to the path to your home directory.
01:54:02 <grr12314> Athas: the question is, does it do it itself or is there a simpler way to delegate it to the shell
01:54:09 <grr12314> especially for ~someotheruser
01:54:28 <grr12314> reading passwd yourself and trying to reimplement the wheel seems silly
01:55:38 <ertes-w> jle`: that command does something nastier
01:55:45 <revtintin> If I have 2 IO actions that returns some Maybe a, is there some elegant way to run one, if its Nothing, then return the other? `liftIO $ foo <|> bar` doesn't work for example. Thanks
01:56:16 <ertes-w> revtintin: MaybeT
01:56:34 <revtintin> @ertes-w: ah, thanks, Ill look that up
01:56:34 <lambdabot> Unknown command, try @list
01:56:45 <ertes-w> revtintin: runMaybeT (MaybeT c1 <|> MaybeT c2)
01:57:30 <merijn> Or "runMaybeT . asum . map MaybeT $ yourList" if you have more than two :)
01:57:43 <revtintin> thanks!
01:57:56 <merijn> Actually, maybet is a newtype, no? I guess you could get away with coerce instead
02:00:37 <foldr> > :info MaybeT
02:00:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:00:45 <foldr> lol i'm stupid
02:01:17 <merijn> lambdabot doesn't support :info anyway :)
02:01:27 <foldr> newtype MaybeT m a = MaybeT (m (Maybe a))
02:04:11 <jle`> revtintin: it's basically a newtype wrapper to give IO (Maybe a) the proper Alternative instance you want
02:04:36 <jle`> revtintin: if you're familiar with Product, Sum, All, Any, etc., used for giving things different Monoid instances, it's basically the same thing :)
02:05:05 <revtintin> thanks, that's new to me
02:06:01 <foldr> ala MaybeT asumMap -- asumMap doesn't exist ;_;
02:06:29 <jle`> > Product 10 <> Product 2
02:06:32 <lambdabot>  Product {getProduct = 20}
02:06:38 <jle`> > Sum 10 <> Sum 2
02:06:40 <lambdabot>  Sum {getSum = 12}
02:08:01 <ertes-w> merijn: it would be nice if there were a way to write a rule to rewrite 'fmap Ctor' and 'fmap fromCtor' to 'coerce'
02:08:58 <merijn> ertes-w: I don't think rewrite is smart enough for that, because you need to know none of the constructor fields are representational
02:09:24 * frerich jle`: I understand how that works, but I never really understood the benefit of it - it seems to me like folding values except that a type is used to select the function being folder over the sequence instead of passing that function directly.
02:09:57 <ertes-w> merijn: it bothers me to have to write 'coerce' explicitly into my code…  not sure why, but it does
02:10:12 <ertes-w> perhaps if it were in Prelude it would bother me less
02:11:47 <jle`> frerich: the benefit is being able to use it with polymorphic functions
02:12:02 <jle`> frerich: it's silly, of course, to use Product 10 <> Product 2 instead of 10 * 2
02:12:06 <merijn> ertes-w: coerce doesn't really bother me, unsafe bothers me :p
02:12:27 <jle`> frerich: but what about passing it to a useful function that's polymorphic over all Monoids ?
02:12:39 <jle`> like, using Sum/Product with Writer
02:12:45 <merijn> frerich: Well, using monoid of Product directly is not really useful, but they're VERY useful combined with my favourite Monoid instance
02:12:58 <jle`> i've also used Sum and Product with tuples and 'fold'
02:13:00 <merijn> frerich: "instance Monoid b => Monoid (a -> b)", which is the best Monoid ever :)
02:13:14 <jle`> > fold (\x -> (show x, Sum x)) [1..5]
02:13:16 <lambdabot>  error:
02:13:16 <lambdabot>      • Couldn't match type ‘(String, Sum a0)’ with ‘[Integer] -> t’
02:13:16 <lambdabot>        Expected type: a0 -> [Integer] -> t
02:13:20 <jle`> > foldMap (\x -> (show x, Sum x)) [1..5]
02:13:22 <lambdabot>  ("12345",Sum {getSum = 15})
02:13:45 <frerich> jle`: Ah, you can do different operations in a single pass. That's true
02:14:02 <merijn> :t \l -> mconcat $ coerce l
02:14:02 <ertes-w> merijn: it bothers me because it looks and works like 'id', but it definitely isn't 'id'…  basically it's a "type cut" point in my code, where i need to look at the context to see what it does – and the context may be complicated
02:14:03 <lambdabot> error:
02:14:03 <lambdabot>     • Variable not in scope: coerce :: t -> [a]
02:14:03 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
02:14:07 <jle`> well i mean, i'd like to just do \x -> (show x, x)
02:14:13 <merijn> :t \l -> mconcat $ Data.Coerce.coerce l
02:14:14 <lambdabot> (Coercible a1 [a], Monoid a) => a1 -> a
02:14:15 <jle`> but then foldMap doesn't know how to combine it
02:14:22 <jle`> *how to combine the x's
02:14:33 <jle`> by giving Sum, i'm saying "when you fold all these values up, use (+)"
02:15:01 <ertes-w> merijn: also it's really an optimisation…  whenever i write 'coerce' i feel like i'm doing GHC's job =)
02:15:07 <jle`> also the tuple instance for monoids is nice, Monoid a, Monoid b => Monoid (a, b)
02:15:45 <jle`> with foldMap it could possibly be considered silly as well, because you could always just foldl' and give your functions very very carefully
02:16:13 <Spriithy> hey :)
02:16:36 <jle`> > foldl (\(x1,y1) (x2,y2) -> (x1++x2, y1 + y2)) ("",0) $ map (\x -> (show x, x)) [1..5]
02:16:38 <lambdabot>  ("12345",15)
02:16:44 <jle`> frerich: but you can see how that gets really complicated really fast
02:17:13 <jle`> and also Writer and Const are powerful tools that rely on Monoid instances to tell them how to "combine" things
02:17:21 <merijn> frerich: Basically, the Monoid I just mentioned (the function one) passes it's input to all the functions it's mappend and then mappends their results
02:17:35 <jle`> Spriithy: hi!
02:17:53 <merijn> frerich: So if you have 5 functions that need an 'a' and produce some monoid, you can "mconcat" a list of those functions and get a single function as result
02:19:13 <frerich> merijn: Ok, but... I could do that with a plain 'map' and 'foldr' as well, no? :-) Can you give an example?
02:19:38 <merijn> frerich: Actually, it's even better, since "Monoid b => Monoid (a -> b)" means it recursively applies to function of ANY number of arguments that eventually produce a monoid :)
02:19:59 <merijn> frerich: ^^ that behaviour is hard to duplicate without map and foldr
02:20:12 <merijn> eh, with
02:20:27 <merijn> frerich: My favourite example is the Monoid instance of Ordering
02:20:34 <merijn> > mappend LT EQ
02:20:36 <lambdabot>  LT
02:20:39 <Spriithy> jle`: hey :P
02:20:42 <merijn> > mappend GT EQ
02:20:44 <lambdabot>  GT
02:20:52 <Spriithy> i'm at work. Will start Write you a Scheme soon
02:20:52 <frerich> merijn: That's the one which orders by multiple criteria?
02:20:54 <merijn> > mappend EQ LT
02:20:57 <lambdabot>  LT
02:21:05 <merijn> frerich: Yes, since you'll usually have
02:21:08 <merijn> :t comparing
02:21:10 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:21:15 <merijn> :t comparing fst
02:21:16 <ongy> >mappend LT GT
02:21:17 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
02:21:25 <ongy> > mappend LT GT
02:21:27 <lambdabot>  LT
02:21:34 <merijn> frerich: "comparing foo" returns a binary function
02:21:36 <frerich> merijn, I think that's a nice thing but it never occurred to me that it exploits the instance you just described :-)
02:21:43 <merijn> frerich: And you can mconcat a lot of those binary functions together :)
02:21:56 <merijn> frerich: And end up with a single binary function in the end :)
02:22:14 <ongy> > mappend GT LT -- is this lexicographic? or whatever the default list ordering is called
02:22:16 <lambdabot>  GT
02:22:26 <merijn> ongy: Basically the Monoid on Ordering always returns the left-hand side, unless the left hand is EQ, then it returns right hand
02:22:55 <merijn> ongy: Which corresponds to lexicographical ordering, yes. It orders by left most differing element
02:23:56 <merijn> frerich: It also combines well with coerce, because coerce can't just convert "a -> NewtypeOfA" but also "r -> a" to "r -> NewtypeOfA"
02:25:50 <merijn> frerich: I find myself using it quite a lot since it's often shorter than mapping first, then foldr, especially when dealing with functions
02:26:28 <merijn> It comes up quite frequently that I have a case of "apply all these functions to something and combine the results"
02:27:48 <frerich> merijn: I must admit that this 'mconcat [comparing this, comparing that]' thing is something which I have filed mentally as 'this is how you can sort by multiple criteria' but I never really bothered finding out why it works. Thanks! :-]
02:29:16 <frerich> What 'worries' me a bit sometimes is that with functions which work for any Monoid, I never really know what they do. mappend is so generic.
02:30:19 <tdammers> that's kind of the point thought, isn't it
02:30:22 <tdammers> being generic I mean
02:30:24 <frerich> So when reading the documentation I'm always left thinking 'Ok, this function combines the Monoid values like this and that, now what does that actually mean if I give it a tree of, say, lists'. :-}
02:30:52 <foldr> The function does the same no matter what type you give it.
02:30:59 <frerich> tdammers: I guess so, but I find it hard when I have some value and I want to transform it into something else and then want to find out which functions would be useful for the job. :-]
02:31:40 <tdammers> frerich: but in that case, you already know what the types are, right, so you also know what the Monoid instance is
02:31:58 <Spriithy> Hey, do you guys recommend a good on-save formating tool ?
02:32:13 <Spriithy> stylish haskell seems to have so few features...
02:32:14 * frerich tdammers: Well I could look up if/what the instance is, right. When reading the code, it's not always totally obvious to me.
02:32:26 * frerich curses this IRC client from doing /me when using Ctrl+Enter
02:33:15 <foldr> Then the code should be rewritten such that it becomes obvious.
02:33:27 <tdammers> ^ pretty much
02:35:54 <frerich> I have a sense this might quickly converge to the discussions surrounding the FTP. :-]
02:37:21 <frerich> I.e. when generalizing functions makes the behaviour of some function application more dependant on the type of value being passed.
02:38:03 <merijn> I don't agree, the behaviour is the same every time
02:38:29 <merijn> That's entire reason we're so obsessed with laws for typeclasses, so that we can actually reason about what those generic functions do...
02:39:13 <tdammers> merijn: the behavior depends on the type, it's just that by using the typeclass, we can enforce certain properties of the behavior, expressed in the types and law
02:39:17 <tdammers> laws*
02:39:39 <merijn> I think we disagree on what constitutes "behaviour" :)
02:40:36 <tdammers> mappend can do all sorts of things - concatenate lists, saturate booleans, form set unions, merge dictionaries, select from two Maybe's, etc.
02:41:04 <frerich> merijn: I find that the _less_ generic a piece of code is, the more it allows you to say about what it does, e.g. if you know that a function 'f' is of type '[String] -> Int' and you see a piece of code like 'print (f x)' then this tells you a lot about what's going on and what it will print and what 'x' is. Just the function type gives a lot of context.
02:41:27 <frerich> merijn: If 'f' is more generic, this makes 'f' more reusable but at the same time you have to consider the types of all the surrounding expressions into account to tell what's going on.
02:41:29 <ongy> tdammers: we can enforce them? That's news to me. We can state them and then asume they hold, but enforce?
02:41:51 <tdammers> ongy: we can enforce the types, not the laws obviously
02:42:28 <tdammers> the laws are "enforced" in the sense that we promise to abide by them when writing instances
02:42:48 <merijn> ongy: Well you can (and probably should, however informal) prove the laws hold for your implementations :)
02:43:30 <ongy> merijn: maybe I'm having a language barrier problem, but that's not enforcing any kind of behaviour, since that's purely optional, right?
02:44:30 * hackagebot bio-sequence 0.1.0.0 – Initial project template from stack – https://hackage.haskell.org/package/bio-sequence
02:45:32 <tdammers> merijn: if in doubt, say "it should be obvious to the reader that these laws hold"
02:45:37 <merijn> ongy: GHC doesn't enforce anything, no
02:46:52 <exio4> I am checking scaleway, would be there problems running GHC in their ARM cpus? (they all have >= 2GB of ram, and at least 4 ARM64 cores)
02:47:40 <merijn> exio4: Depends on the specific ARM chip
02:48:05 <merijn> exio4: See https://ghc.haskell.org/trac/ghc/wiki/Platforms for details on supported platforms and level of support
02:49:46 <wz1000> I don't undertand the point of the Something1, Something2... classes
02:50:00 <frerich> merijn: I think the point I'm trying to make is a little bit as in why I like 'f . g' better than 'f `fmap` g' (ignoring that the former is shorter): (.) is less generic than fmap, but it tells me more when reading the code (the callsite, that is). That's kind of like what I have with mappend and everything built on top of that, I struggle because I suddenly go and look for the types of the involved values and how Monoid is defined for them.
02:50:07 <wz1000> Like Generic1, Show1, etc
02:50:30 <foldr> Or you use (.) from Control.Category
02:50:38 <foldr> They just happen to be the same for functions
02:50:41 <exio4> merijn: ah!
02:51:41 <Spriithy> did they remove the MonadZero ?
02:51:51 <merijn> Spriithy: Yes, ages ago, apparently
02:51:52 <Spriithy> or is it somehow included in MonadPlus somehow
02:52:08 <merijn> Spriithy: mzero is now part of MonadPlus, but I didn't notice when this happened
02:52:26 <Spriithy> So I need mplus and mzero now :P
02:52:45 <Spriithy> okay thanks. They also changed the (++) of MonadPlus it seems
02:53:04 <merijn> I don't remember ++ ever being MonadPlus
02:53:49 <Spriithy> I'm reading a paper where they do write it that way ^^ http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf
02:53:51 <Spriithy> page 4
02:56:52 <ongy> when would I use MonadPlus over monoid?
02:57:19 <Spriithy> I have no clue what a monoid is tbh
02:57:19 <merijn> ongy: Note that the kind of MonadPlus is different than Monoid
02:57:42 <merijn> ongy: "Monoid :: * -> Constraint", "MonadPlus :: (* -> *) -> Constraint"
02:58:01 <merijn> ongy: MonadPlus is, effectively, a monoid on types of kind * -> *
02:58:30 <merijn> Note, for example the type of mzero
02:58:31 <merijn> :t mzero
02:58:33 <lambdabot> MonadPlus m => m a
02:58:51 <Spriithy> :t MonadZero
02:58:54 <lambdabot> error: Data constructor not in scope: MonadZero
02:59:10 <ongy> sure, but on a specific type what would be the difference? Outside of how the constraint is stated
03:00:06 <merijn> ongy: Well, "Maybe a" is a Monoid only IFF 'a' is a Monoid
03:00:19 <merijn> ongy: But Maybe is *always* MonadPlus, even if 'a' is not a Monoid
03:00:42 <ongy> > (Just 1) `mplus` (Just 2)
03:00:44 <lambdabot>  Just 1
03:01:05 <ongy> > Nothing `mplus` (Just 2)
03:01:07 <lambdabot>  Just 2
03:01:28 <ongy> hm
03:01:40 <ongy> not what I expected to be honest, but I guess it makes sense
03:02:01 <merijn> ongy: MonadPlus is related to Alternative too
03:02:34 <merijn> ongy: One example use case is Parsers, where you want to have a "failing parse" (mzero) and a left-biased "pick the first success"
03:04:03 <Darwin226> If I have a `class C a b | a -> b`, is there a way to create a synonym `type T a = C a b`? GHC complains about `b` not being in scope, but it's determined by `a`. I just don't want to bind it to anything
03:05:15 <[exa]> Darwin226: so what should 'b' be if you write (T a) ?
03:05:34 <Cale> [exa]: the only thing it could be
03:05:41 <Cale> But yeah, I don't think there's a way to do that
03:05:47 <Darwin226> Actually, it shouldn't even exist in the scope
03:06:00 <Darwin226> I want to discard that information and only care that an instance exists
03:06:13 <[exa]> oh so, got confused by the keyword
03:06:32 <Darwin226> Cale: So replace it with a associated type then? No other way?
03:06:37 <Cale> What you could do is instead define  class C a where type T a; ...
03:06:42 <Cale> yeah
03:06:58 <Cale> Or just live with the extra variable
03:07:05 <Cale> It's not really all that bad :P
03:07:28 <Darwin226> Cale: Today one extra variable, tomorrow a paragraph of unused variables
03:09:44 <slack1256> slippery slope
03:20:16 <quchen> Don’t name your variables, because when you’re adding 10000 letters it is unreadable
03:21:26 <quchen> cocreature: https://hackage.haskell.org/package/prettyprinter-convert-ansi-wl-pprint
03:21:30 <quchen> Just released
03:22:03 <ongy> Cale: how's the work on the ghc plugin you mentioned going?
03:24:57 <Cale> ongy: Oh, it sort of works, except that there are a few core passes (CoreTidy and CorePrep) which must occur after the plugin runs, and which tend to remove a bunch of stuff.
03:25:34 <ongy> is it in a state where I can try it on my project somehow?
03:25:56 <Cale> I can give you the code I have. It's really simple.
03:26:24 <ongy> that would be cool
03:26:48 <Cale> http://lpaste.net/357382
03:27:12 <Cale> It just finds all the lambdas which bind evidence variables
03:28:12 * hackagebot prettyprinter-convert-ansi-wl-pprint 1.1 – Converter from »ansi-wl-pprint« documents to »prettyprinter«-based ones. – https://hackage.haskell.org/package/prettyprinter-convert-ansi-wl-pprint
03:28:12 * hackagebot prettyprinter 1.1.0.1 – A modern, easy to use, well-documented, extensible prettyprinter. – https://hackage.haskell.org/package/prettyprinter
03:28:14 <Cale> The trouble is, you'll sometimes get spurious results that don't actually appear in the core, because of these extra passes which happen after
03:28:27 <Cale> But it should give some idea
03:30:01 <ongy> what's the easiest way to integrate it?
03:32:09 <ongy> GHC errors on the -package pragma
03:39:53 <Cale> ongy: You should be able to add an {-# OPTIONS_GHC -fplugin ListDictionaries #-} to some other module
03:40:15 <Cale> (you may also want to -ddump-simpl at the same time)
03:41:57 <ongy> oh, I just drop this into the project I want to use it in?
03:43:34 <ongy> do I need ghc 8.2 for this?
03:45:12 <Cale> ongy: No, I only have 8.0.2 myself
03:45:24 <Cale> and yeah, I didn't package it in any way
03:45:37 <ongy>     unknown flag in  {-# OPTIONS_GHC #-} pragma: -package
03:45:37 <Cale> You could make it into a cabal package and install that, might be easier to use
03:45:44 <Cale> oh, sorry, -fpackage
03:45:54 <Cale> er
03:45:56 <Cale> -fplugin
03:46:02 <Cale> wait what?
03:46:02 <ongy> yea same error, it's from the ListDirectories.hs
03:46:11 <Cale> oh
03:46:22 <Cale> That's odd
03:46:41 <Cale> well, try removing that
03:46:45 <ongy> ghc 8.0.2 and cabal 2.1.0.0, did they remove that from cabal?
03:46:50 <Cale> and just supply the -package ghc on the commandline then
03:46:59 <Cale> It's not a cabal thing
03:47:02 <Cale> Just a ghc thing
03:50:29 <ongy> ah, I just added the package to my build depends. Now it doesn't find a ListDictionaries.dyn_o (because it doesn't exist...) do you build with build or new-build?
03:59:22 <cocreature> quchen: thanks!
04:00:35 <Cale> ongy: I build with nix, so I dunno
04:01:27 <Cale> ongy: For me, just putting the module somewhere that it could be found by the compiler, and doing a build with the plugin enabled for some module was enough.
04:02:08 <Cale> ongy: You might want to create a separate cabal package for it, so that you can add that to your dependencies
04:05:19 <quchen> cocreature: Hackage build is broken, not sure why though. I suspect it’s a transient problem.
04:06:28 <phadej> quchen: https://matrix.hackage.haskell.org/package/trifecta
04:06:47 <phadej> quchen: do you want to make revisions constraining ansi-wl-pprint upper bound?
04:06:58 <quchen> phadej: That sounds like a good idea, yes
04:07:03 <quchen> I have to catch a train now though
04:07:12 <phadej> +1
04:07:16 <quchen> But I’ll have time at Hac Freiburg for stuff like this :-)
04:08:20 <ongy> Cale: are you using it in a library? I think that may make the difference
04:14:33 <ongy> well, it compiles now with the plugin :) and either it doesn't work, or it doesn't find anything :D
04:16:51 <Darwin226> Cale: What does the plugin do?
04:18:31 <Cale> Darwin226: It just prints out, for each (core) definition, all of the lambda abstractions which bind an evidence variable (like a class dictionary or type equality witness)
04:19:10 <Darwin226> Interesting. What's the usecase? Does it let you know when an abstraction isn't free?
04:19:48 <Cale> Well, for example, we have some benchmarks where if (>>=) doesn't get specialised, the program runs 60x slower.
04:20:20 <Darwin226> Oh. Very nice
04:20:25 <Cale> So, it's just a little thing to help us locate places where stuff like that might be happening
04:22:17 <Cale> There's a whole bunch of changes in 8.2 which look like they're going to be helpful. I've backported just one so far, and I suspect it's made things significantly better for one of our projects (but I'm still compiling the world to actually find out)
04:22:40 <Cale> (The main thing being that we're using GHCJS, so we're stuck on 8.0.2 for the time being)
04:22:52 <Darwin226> Well for starters, apparently plugins now actually work on Windows
04:23:22 <Cale> (The thing I backported isn't to do with plugins -- it's just a change to how the specialiser works)
04:23:52 <Cale> SPJ did a bunch of other refactors and rewrites to various parts of the specialiser too, which I want to backport, but those are more work.
04:24:52 * hackagebot prettyprinter-ansi-terminal 1.1.1 – ANSI terminal backend for the »prettyprinter« package. – https://hackage.haskell.org/package/prettyprinter-ansi-terminal
04:27:30 <Darwin226> Anyway, seems like a great project. I could imagine a whole suite of diagnostics telling you things like where ints are getting boxed and unboxed
04:28:25 <cocreature> Cale: fwiw I did actually start trying to get ghcjs to build with 8.2 and made a bit of progress. I’m more than happy to collaborate on this as I don’t know when or if I’ll be able to finish this
04:30:25 <hodapp> well, that's odd... ran 'stack install' for a package on my Raspberry Pi and it's been at "Progress: 0/58" for the last 12 hours, despite no CPU load
04:30:30 <hodapp> already killed it once and restarted
04:30:58 <saurabhnanda> very random question -- is there any way to specify that this function argument should be a lens?
04:31:27 <Axman6> make its type Lens s t a b?
04:31:48 <Gurkenglas_> saurabhnanda, can I see the code? I often find that I don't need to pass a lens as an argument
04:32:44 <Axman6> if you don't want to rely on the lens library, you can make it (forall f. Functor f => (a -> f b) -> s -> f t)
04:32:46 <kuttifunk> hodapp: it is probably because of the memory consumption. try to setup a qemu on a fast machine to cross compile stuff for raspberry. that is the route i followed. alternatively you can setup swap space but this will take ages
04:33:07 <saurabhnanda> Gurkenglas_: I don't have any code a.t.m. I'm toying with a very far fetched idea in my head right now. I basically need the ability to refer to a field in a record without losing type-safety.
04:33:48 <saurabhnanda> I tried looking at the types of _1, _Just, _Right, etc. but nothing seems common between them.
04:33:51 <hodapp> kuttifunk: it's only using a couple hundred MB and swap is available.
04:34:01 <cocreature> _Just and _Right are not lenses
04:34:02 <hodapp> kuttifunk: and it's showing no sign of thrashing or I/O stalls
04:34:05 <cocreature> they’re prisms
04:34:36 <Gurkenglas_> saurabhnanda, _1 goes into one argument of a constructor, _Just and _Right go into a constructor of a type
04:34:48 <kuttifunk> hodapp: hmm. so your system is still alive?
04:34:55 <hodapp> kuttifunk: yes.
04:35:09 <hodapp> that's how I'm checking things like CPU load and memory usage
04:35:15 <ertes-w> saurabhnanda: compare the types of lenses and traversals first to see how traversal is a more general concept
04:35:19 <kuttifunk> hodapp: which stack/ghc?
04:35:19 <cocreature> hodapp: have you tried --verbose?
04:35:33 <ertes-w> saurabhnanda: then compare to Iso to see that it's a less general concept than both
04:35:50 <ertes-w> saurabhnanda: then you might see where Prism fits in
04:36:28 <saurabhnanda> can this not run on REPL: makeLensesWith abbreviatedFields ''User
04:37:35 <Axman6> I don't think you can run template haskell expressions in the REPL
04:37:36 <hodapp> kuttifunk: 1.5.0 on Stack, and lts-6.5 (only using because I can't get newer LLVM that it seemed to require)
04:37:48 <Axman6> maybe with :set -XTemplateHaskell?
04:38:36 <kuttifunk> hodapp: try to follow this route: http://allocinit.io/haskell/haskell-on-raspberry-pi-3
04:38:41 <kuttifunk> if it applies...
04:39:02 <hodapp> cocreature: looking at http://lpaste.net/2435764554441949184 now
04:39:09 <hodapp> no idea if those exceptions mean anything or not
04:39:09 <kuttifunk> hodapp: alternatively https://wiki.debian.org/RaspberryPi/qemu-user-static
04:39:53 <kuttifunk> cross compiling on a fast machine nearly always is worth the setup pain.
04:40:07 <kuttifunk> (for me)
04:40:35 <hodapp> kuttifunk: did you read the section in the first link that says "Update: as of March 24th 2017 this script won’t work. See the section on Installing Stack"?
04:40:53 <kuttifunk> yes and how to copy llvm-3.7 to use ghc8
04:41:00 <Xandaros> I have a really simple package which I'm running on my Pi. The initial stack build took like 12 hours and every update still takes like 5 minutes. It's not quite worth setting up a cross compiler, but almost
04:41:18 <kuttifunk> still then you have to use a swap memory setup
04:41:30 <MarcelineVQ> Xandaros, hodapp, kuttifunk: interesting stuff from angerman on the subject https://medium.com/@zw3rk
04:41:32 <Xandaros> And yes, you definitely need swap
04:42:24 <hodapp> llvm-3.7 isn't in my repos for whatever reason, despite doing dist-upgrade yesterday
04:42:37 <kuttifunk> marcelinevq: brand new information! thanks
04:42:54 <hodapp> Xandaros: yeah, I've run on them before, just not lately
04:42:56 <kuttifunk> hodapp: you have to download it yourself (missing the link now)
04:42:58 <MarcelineVQ> kuttifunk: it's pretty active dev too
04:43:15 <MarcelineVQ> kuttifunk: If you have interest in the subject angerman is often making mentions in #ghc
04:43:34 <saurabhnanda> that's probably the best I can come up with -- (Control.Monad.Reader.Class.MonadReader mytype m) => m b
04:43:54 <hodapp> kuttifunk: that's curious, since the link talks about Raspbian Jessie and just says it's in the repos, which is exactly what I'm using
04:43:57 <kuttifunk> marcelinevq: will consider it. my problem is: i am still a haskell noob :)
04:44:57 * hackagebot avro 0.1.0.0 – Avro serialization support for Haskell – https://hackage.haskell.org/package/avro
04:45:32 <hodapp> the thing I'm trying to build relies on Language.Haskell.Interpreter so it'll need at least some level of non-cross-compiled support
04:46:36 <kuttifunk> hodapp: i don't know about raspbian, maybe you can use the http://releases.llvm.org/3.7.0/clang+llvm-3.7.0-armv7a-linux-gnueabihf.tar.xz binary and install it manually in the appropriate places
04:46:47 <kuttifunk> it  worked for me on ubuntu and rpi3
04:47:17 <kuttifunk> marcelinevq: thx
04:48:12 <tabaqui> is there any nice ring buffer implementation in hackage?
04:48:42 <tabaqui> or some simple message queue with confirmations?
04:49:03 <tabaqui> oh, bgamari/ring-buffer
04:49:14 <tabaqui> but just 395 downloads...
04:49:58 <hodapp> I guess I'd sort of rather figure out why stack is stalling indefinitely despite no signs of progress than do a bunch of speculative modifications to my configuration with no clear intention for why they'd work
04:50:42 <mniip> glguy, I figured out yesterday's issue with lambdas
04:51:05 <hodapp> strace has it stuck at a futex(0x5be72d4, FUTEX_WAIT_PRIVATE, 37, NULL)
04:51:31 <mniip> ghci assumed an ASCII encoding and was silently dying when asked to read utf
04:52:29 <kuttifunk> hodapp: maybe the best thing. yes. could be many possibilities. nevertheless, if you do not get further down this road, you can always clone your system and try the "speculative" things on another sdcard without breaking anything :) wish you good luck!
04:52:44 <angerman> MarcelineVQ, Xandaros, hodapp, kuttifunk: I definetly recommend cross compiling for rpi.
04:53:05 <kuttifunk> angerman: me too :)
04:53:06 <MarcelineVQ> tabaqui: bgmari's a pretty solid user, you should give that lib a try and see if it'll work for you, it's pretty small so easy to check. I've not used it so can't say more
04:53:16 <hodapp> angerman: still not sure how that'll interact with Language.Haskell.Interpreter. the local build environment, I would guess, still has to be working, even if I don't use it for the bulk of the work.
04:54:59 <tabaqui> MarcelineVQ: he is one of ghc developers, I know. But ring-buffer is quite popular structure, I would say that about his library
04:55:28 <tabaqui> less than 200 lines of code, though
04:55:33 <angerman> hackagebot: sorry I don't follow. If you want to run GHCi ON the raspberry pi, you'd essentially just compile ghci for raspberry pi and ship that to the rpi. I have doing that, and documenting it on my list. I also want to show that theoretically you could even have a remote ghci, however a few more ifdefs need to be lifted from ghc for that.
04:55:34 <tabaqui> I'll try it anyway
04:56:55 <MarcelineVQ> angerman: -opti isn't enough for that? pointing to a shim that does the remote communicating?
04:57:26 <MarcelineVQ> oops, that's not the flag I meant to link
04:57:29 <MarcelineVQ> -pgmi
04:57:46 <angerman> MarcelineVQ: -pgmi... in principle yes, but you can't build a ghci (cross compiled) yet.
04:58:31 <MarcelineVQ> It sure is a complicated subject, I'm rooting for you
04:58:42 <angerman> MarcelineVQ: it's all on my todo list. Just not high priority enough.
04:58:59 <angerman> MarcelineVQ: ghcjs has remote ghci. so it certainly is possible :)
04:59:28 <hodapp> angerman: the package I'm trying to build uses Language.Haskell.Interpreter but I have no idea how/if this ties in with GHCi
05:01:34 <Xandaros> Maybe I'll try setting up a cross compiler tomorrow, I still have a project that'll run on another Pi, so it would come in handy then
05:01:36 <angerman> hodapp: tbqh, I'm not too familiar with Language.Haskell.Interpreter. However cross compiler will produce an application capable of running on the target. And I do not yet see any restrictions such an application would have, that the application if compiled ON the target, instead of being cross compiled, would not have.
05:01:59 <angerman> Xandaros: I might have useable cross compilation bin dists soon.
05:02:38 <angerman> I have built these a while back though: https://dl.bintray.com/zw3rk/pkgs-x86_64-macos/
05:03:37 <Xandaros> Well, you do have something resembling a tutorial on your blog, so I think I'll try there first. Admittedly, though, I have had my experience with cross compilation. None of it pleasant, so I might rely on a bindist if it'll exist, after all :D
05:04:56 <angerman> I might get around cleaning the bin dist stuff up over the weekend. But there are currently a bit more pressing issues in ensuring that LLVM5 ships with at least the mach-o dead strip capabilities, and LLVM5's rc2 is on the 9th I believe.
05:05:09 <joe9> I am trying to figure out how to fail an Attoparsec parser. I tried returning Fail ("message") [] ""  code: http://bpaste.net/show/77f40cc85508 , error:  http://bpaste.net/show/92a3af930382
05:06:08 <joe9> I could not find a 'fail' function in attoparsec.
05:06:46 <Xandaros> angerman: It's not like it's a pressing matter. My current project is all but done, I just deployed the last version for probably quite a while and the other project is going to require some hardware first
05:07:35 <Xandaros> That said, more easily brining Haskell to other platforms would be a very nice thing to have :)
05:07:46 <joe9> got it, mzero.
05:09:08 <mniip> joe9, I'd rather use empty
05:10:22 <cocreature> angerman: crap rc2 is already on the 9th? I need to get off my lazy ass and update the changelog so I can merge llvm5 support in llvm-hs
05:10:52 <angerman> cocreature: llvm.org: August 9: -rc2.
05:11:09 <Myrl-saki> So
05:11:32 <Myrl-saki> This is not exactly Haskell, but why do I get a `not found` error when copying between computers?
05:12:06 <hodapp> copying how?
05:12:06 <cocreature> angerman: well, rc1 was already a week too late (https://lists.llvm.org/pipermail/llvm-dev/2017-July/115882.html) so … ;)
05:12:30 <Myrl-saki> hodapp: I used scp for this.
05:12:42 <Myrl-saki> hodapp: The distros are also different.
05:15:35 <Myrl-saki> `nterpreter /nix/store/cr09b6qlng28k3gjs1i622ymx7zv747j-glibc-2.25/lib/ld-linux.so.2`
05:15:38 <Myrl-saki> Perhaps it can't find that?
05:19:52 <joe9> mniip: Thanks, will try it.
05:20:23 <hodapp> Myrl-saki: did you already ask in #nixos on this?
05:20:36 <hodapp> oh, there you are
05:23:35 <Myrl-saki> hodapp: I think it's also because nixos doesn't do FHS.
05:26:48 <the_2nd> How can I receive the client's IP adress in happstack?
05:30:46 <Spriithy> Hey there :D
05:31:16 <Spriithy> I have stumbled across the type constructor "Maybe a" quite a lot 
05:31:26 <Spriithy> yet I can't really understand it
05:31:51 <Spriithy> is that some sort of "Maybe you will get a value of type 'a' or nothing" ?
05:32:48 <c_wraith> Spriithy: yes.  Maybe you will, maybe you won't.
05:32:54 <hodapp> that's the spirit of it.
05:33:15 <Spriithy> Why not define it as "Either a Nothing" ?
05:33:43 <opqdonut> more like "Either a ()"
05:33:50 <Spriithy> oh
05:34:03 <opqdonut> that would be isomorphic, yeah, but the Maybe alias is convenient
05:34:10 <Spriithy> I hate the "IO ()" stuff tbh
05:34:30 <opqdonut> Maybe is used in place of returning null
05:34:30 <Spriithy> can't just print a thing... without breaking everything
05:34:42 <mniip> Spriithy, why?
05:34:48 <opqdonut> I mean, in some other language you would return null, in Haskell you return Nothing
05:34:57 <opqdonut> and your type signature shows that the result might be Nothing
05:35:04 <mniip> also yes, not being able to "just print a thing" is one of the core principles of functional programming
05:35:18 <mniip> you can use debugging tools but those are just thtat
05:35:30 <Darwin226> And for debugging there Debug.Trace
05:35:38 <c_wraith> Spriithy: everyone says it's good to keep code that does IO separate from code that does logic in every language.  Haskell just helps you with that.
05:35:58 <Spriithy> I mean if I have a function :: Int -> String or whatever, in a guard I can't just 'putStrLn "xxx" '
05:36:02 <Spriithy> before returning
05:36:18 <c_wraith> You can use Debug.Trace for all the common reasons you'd want that
05:36:20 <hodapp> if you must do that, Debug.Trace will
05:36:23 <Spriithy> c_wraith: point
05:36:27 <Darwin226> Checkout `trace` from Debug.Trace
05:37:00 <Spriithy> thanks :)
05:37:14 <hodapp> in my own experience, coming from pretty much solely an imperative background, it didn't really hinder me. For one thing, I tended to build up the entire program in smaller components where it was easier to just test them in isolation than to try to stick debugging statements in their innards
05:37:45 <Spriithy> yeah that's what I do now hodapp 
05:38:20 <hodapp> on occasion I still needed Debug.Trace but mostly when something anomalous happened but only in the context of "real" data (in one case, it was a non-reentrant library that had been wrapped as if its calls were reentrant)
05:40:15 <Spriithy> I feel like I am so dumb
05:40:20 <Spriithy> with Haskell x)
05:40:52 <Spriithy> Like, I'm literally questioning all I have learned in my programming years...  
05:40:52 <hodapp> it's a lot of un-learning what other languages present as gospel
05:40:59 <joe9> Spriithy: you need IO in the function signature to use putStrLn
05:41:10 <joe9> Spriithy: function :: Int -> IO String
05:41:32 <joe9> Spriithy: better, function :: Int -> IO (); function = putStrLn "xxx"
05:41:35 <Spriithy> joe9: but that means I have to return an IO thing right ?
05:41:55 <Spriithy> joe9: yeah but then I can't return my string
05:42:02 <Spriithy> which was my original point
05:42:06 <joe9> Spriithy: I think you are looking for trace
05:42:13 <joe9> check out Debug.Trace
05:42:18 <Spriithy> yeah, that's what they told me already
05:43:06 <joe9> from the docs: trace ("calling f with x = " ++ show x) (f x)"
05:43:18 <joe9> https://hackage.haskell.org/package/base-4.10.0.0/docs/Debug-Trace.html
05:44:48 <kosmikus> do I have to do anything special to enable levity polymorphism?
05:44:58 <kosmikus> I'm trying  I# (negateInt# $ 3#)  in GHCi, and it fails
05:45:10 <kosmikus> yet :i $ shows ($) to be levity polymorphic
05:45:19 <foldr> Huh, (<<+=) is great for generating unique identifiers
05:45:25 <foldr> Why did I not know about this function before :D
05:45:32 <hodapp> in the meantime, hodapp is sad, because he has to use OpenCV for most of his computer vision work, and OpenCV is a giant blob of really ugly C++.
05:45:56 <Axman6> kosmikus: I usually just end up writing the parens when working with unboxed values
05:46:04 <hodapp> and, like most 'numerical' libraries, feels like it's just C++-flavored frosting over top of dusty FORTRAN.
05:46:35 <kosmikus> Axman6: sure, I can work around it. I just want to understand why and what is happening.
05:46:43 <kosmikus> Axman6: do I need a language extension?
05:46:51 <carter> hodapp: don't remind me :), need to fix it 😇
05:46:59 <hodapp> carter: ehhh?
05:47:32 <carter> Finish my numvericla stuff.  Got sucked into language engineering at work the past two years so I've been too busy
05:47:50 <hodapp> numvericla?
05:47:57 * hodapp looks at https://hackage.haskell.org/package/opencv
05:48:05 <carter> Numerical.
05:48:13 <carter> Is a package I've been working on
05:48:18 <carter> For too long
05:48:22 <carter> Need to release it
05:48:23 <carter> :)
05:48:25 <hodapp> oooh
05:48:28 <hodapp> interesting, Haskell's opencv package just uses inline-c
05:48:33 <saurabhnanda> has anyone used forms with Yesod? how does the form generation code generate unique field names, and how do they map back to the original records when the POST data is being handled? Specific confusion: Referring to https://www.yesodweb.com/book/forms#forms_monadic_forms what happens if I have TWO personForm on the same page?
05:48:33 <Axman6> carter: oi, get back to it!
05:48:35 <carter> Oh. Cool
05:48:44 <hodapp> carter: have a link?
05:49:02 <carter> Axman6: first I need to replace blockchain in finance with linear logical agda
05:49:11 <carter> hodapp: google numerical Haskell
05:49:15 <Axman6> nah mate, numerical first please :P
05:49:20 <cocreature> and random v2 :)
05:49:37 <carter> cocreature: some code review on v2 would be nice
05:49:40 <Spriithy> jle`: hey you there ? :D
05:50:30 <carter> I like the sampling combinator design I stumbled into
05:51:13 <carter> cocreature: join me on #numerical-haskell channel and given me code review some time
05:52:13 * hackagebot avro 0.1.0.1 – Avro serialization support for Haskell – https://hackage.haskell.org/package/avro
05:52:30 <cocreature> carter: I sadly know pretty much nothing about prngs but I’ll see if I can still take a look at it and provide some feedback. we should really try to get a release out sometime soon™
05:53:09 <carter> Yeah.  Don't worry about the prng part.  I want to make sure the the sampling tools on top are nice
05:53:11 <kosmikus> Axman6: btw, never mind. my mistake. negateInt# doesn't have the right type / kind.
05:53:13 <cocreature> carter: I guess https://github.com/cartazio/random/commits/v2-api-experiments is the branch I should be looking at?
05:53:29 <carter> Which ever branch is furthest along
05:53:36 <carter> I think master ? I forget
05:53:55 <cocreature> oh right master is further along
05:54:02 <carter> The module hierarchy is currently a mess too
05:55:48 <carter> I'm really happy with the nomadic sampler combinators. Need to add more
05:56:29 <carter> Also there's some stuff around rejection sampling I wanna work out
06:05:06 <danilo2> Hi! Is there any library that lifts attoparsec functions to monad trans ones? I don't believe nobody needed it yet, however I cannot find any library implementing it. I want for example to have `takeWhile :: MonadParser m => (Char -> Bool) -> m [Char]` instead of hardcoded `takeWhile :: (Char -> Bool) -> Parser [Char]` 
06:09:11 <grr12314> so... according to the samples on the homepage `"Name: " ++ getLine` is wrong but how do you correct it? is there a short and nice syntax instead of putting it in a do and a temp variable and such?
06:10:06 <mauke> I recommend not using 'do' if you're a beginner
06:10:15 <merijn> danilo2: That doesn't make sense, since attoparsec isn't a monad transformer
06:10:15 <mauke> things make more sense that way
06:10:20 <cocreature> grr12314: ("Name: " ++) <$> getLine would work
06:10:20 <Cale> hah, I recommend the opposite :)
06:10:38 <mauke> Cale: that's how you end up with confusion like ^
06:10:59 <merijn> Cale: I agree with mauke, in my experience using do-notation leads people to think do notation is "magic make it work" syntax, rather than a nice and systematic thing
06:10:59 <danilo2> merijn: I don't agree :) It does not have to be monad transformer to be used like `StateT Int Attoparsec.Parser a`, right ?
06:11:03 <Cale> I just mean, avoid the wide variety of operators
06:11:09 <grr12314> cool. i kinda feel like i understand do but all the mythical two-symbol operators are a bit over my head
06:11:09 <[exa]> grr12314: if you want it, you can do getLine >>= return.("Name:" ++)
06:11:17 <Cale> do-notation still shouldn't be magic
06:11:27 <mauke> 'do' notation is level 2
06:11:32 <Cale> It's good to know that it desugars into applications of (>>=)
06:11:33 <mauke> after you've understood IO
06:11:37 <merijn> danilo2: attoparsec is just a monad which means you can use it as a base for a transformer stack, but I don't think a MonadParser really makes sense
06:11:43 <Cale> but just as easily, (>>=) could desugar into do-notation
06:11:53 <Cale> (nearly as easily, anyway) :)
06:11:56 <merijn> Cale: In my experience people don't truly grok that it is sugar for >>= until they spend some time writing >>= by hand
06:12:32 <mauke> grr12314: >>= is the central operator you should become familiar with
06:12:52 <danilo2> merijn: If we implemnt functions like `takeWhile` in terms of `MonadParser` then they will be automatically lifted over all the monad trans layers (like StateT) to the bottom of the stack - to Attoparsec.Parser. Manual lifting is just worse in my opinion
06:13:21 <grr12314> are there other online repls?
06:13:31 <grr12314> since the one on homepage is broken now
06:13:37 <mauke> > "hi"
06:13:39 <lambdabot>  "hi"
06:13:40 <Cale> grr12314: I would recommend just getting GHC
06:14:01 <merijn> danilo2: You can just write "lift $ takeWhile f"?
06:14:07 <Cale> There are a bunch of ways to get set up with it -- lots of people like to start out with stack these days it seems.
06:14:31 <danilo2> merijn: sure I can and then add another State or something and write `lift $ lift $ ...` all over the place in not maintainable code :/
06:14:50 <merijn> danilo2: Why do you need so much state?
06:15:34 <danilo2> merijn: I need one transformer now, but I hate making my code "hardcoded" in any way. In fact I very strongly consider manual using of lift as something very, very wrong, because it makes code much less flexible and maintainable
06:16:03 <merijn> danilo2: Personally I find overly mtl'ed code really hard to use (Yesod and co)
06:16:26 <danilo2> merijn: I would probably never need another state in this code, but I prefer to create my typeclass and library with lifted attoparsec functions than allow in my code for a single "lift". But this is very personal opinion
06:16:29 <merijn> danilo2: I suppose you could use edwardk's parsers library and make instances for a newtype of attoparsec's Parser
06:16:50 <danilo2> merijn: no, parsers library is not maintained and lacks the core attoparsec concepts like `takeWhile` 
06:17:17 <cocreature> I’m not sure I’d call a library that has been update 5 days ago “not maintained”
06:17:55 <danilo2> merijn: but yeah, something like that is what I'm looking for. It seems I will roll my own then
06:19:14 <danilo2> merijn: Thank you very much for the conversation! It seems that I need to write it and I hope it will be usefull for somebody else too :)
06:19:37 <merijn> cocreature: Everything that hasn't updated in 2 hours is bitrotted
06:20:31 <locallycompact> is there an rss feed of stack lts releases?
06:20:35 <locallycompact> or something equivalent
06:20:39 <cocreature> merijn: great so I can stop maintaining all of my packages because their bitrotted anyway!
06:21:45 <grr12314> ok im emerging ghc. does it come with a repl or i need some other package for that?
06:23:35 <MarcelineVQ> locallycompact:  https://www.stackage.org/snapshots is the closest thing I'm aware of, which isn't super close
06:23:37 <danilo2> cocreature, merijn : right, I used to "strong" word here :) Its unmaintained in several senses to me: 1) the only changes for a very long time are only cabal config changes to allow new things / small fixes for new GHC builds 2) it forever requires attoparsec and parsec as dependency, while it should provide general interface
06:23:39 <opqdonut> grr12314: it comes with `ghci`
06:24:00 <Spriithy> would it be efficient to create a VM in Haskell ?
06:24:02 <Spriithy> could*
06:24:30 <opqdonut> Spriithy: http://programatica.cs.pdx.edu/House/
06:24:30 <danilo2> cocreature, merijn : there are some discusions online about removing these unnecesary dependencies form few years ago. A good example is the decision (thaat I completely agree with) of the creator of megaparsec - not to use parsers library because it "seems" unmaintained
06:24:52 <merijn> danilo2: It can't provide a general interface without orphan instances which is considered bad
06:24:56 <opqdonut> Spriithy: http://uhsure.com/halvm3.html
06:25:03 <Spriithy> opqdonut: is that even still maintained ?
06:25:30 <merijn> danilo2: It wouldn't actually work unless parsec/attoparsec start depending on parsers and implement it's classes, but that seems unlikely to happen
06:25:40 <opqdonut> Spriithy: I'm not sure anybody is using these for anything, but it has been done, multiple times
06:26:16 <Spriithy> well HaLVM is still maintained :D
06:26:22 <opqdonut> yeah
06:26:34 <danilo2> merijn: Sure, but then it should also include other parsers, like trifecta, megaparsec and tons of other. What you are refering to right now is a lack of creating "package mixins" in haskell package sytem (I dont know yet if bakpack could relate to this issue in any way), but including 2 chosen parser libraries and other not seems like a strange decision, especially when you dont use them and they are pretty big
06:27:04 <merijn> danilo2: Trifecta already has parsers instances
06:27:38 <Spriithy> but its just targeting the Xen
06:27:38 <danilo2> merijn: all the solutions have some weaknesses. We could create `parsers` and `parsers-attoparsec` with orphans. It will work. Orphan intances are horrible unless you pack them in a single, well defined place, then you could "somehow" live with them
06:27:55 <merijn> danilo2: megaparsec won't have them most likely, because either 1) parsers starts depending on megaparsec TOO, which makes things worse, or megaparsec add parsers as dependency which would include attoparsec/parsec
06:28:00 <piyush-kurur> I know this is not the sml list but I do not seem to be getting much response there does any one have a clue for thsi rather strange bug for SML/NJ  https://bitbucket.org/piyush-kurur/compilers/issues/1/the-getting-started-code-is-not-building
06:28:25 <Spriithy> If you were to compile a language to a VM, which would it be ?
06:28:26 <piyush-kurur> The point is that smlnj is not able to open files on NFS partition
06:28:30 <merijn> danilo2: Well, you could implement that and submit pull request to parsers. Knowing edwardk you'll have commit access in 10 minutes :p
06:28:32 <danilo2> merijn: ok, right, trifecta makes it the proper way. However we lak in general in haskell the ability to define "mixins". Mixin could not be the right word here, but I think you feel what Im refering to. Just create a pakcage that defines instances and this package oculd be automatically installed on demand
06:29:57 <danilo2> merijn: its not that easy. Design decisions in parsers are a little more fosilized when you look at it deeper. For example CharParser could be easily changed to TokenParser with type families so functions like "oneOf" could not only operate on Chars
06:30:17 <danilo2> merijn: but then youll have ot rewrite really a big part of it. I would love to but it will take too much time currenlty :(
06:30:31 <danilo2> merijn: and this is a very breaking change
06:30:58 <danilo2> (yet easily fixable in all use places)
06:31:12 <Spriithy> opqdonut: If you were to compile a language to a VM, which would it be ?
06:31:26 <merijn> Utterly unrelated question: Is there a common pseudo code for parallel loops?
06:33:02 <opqdonut> Spriithy: what do you mean by compiling a language to a VM?
06:33:13 <opqdonut> Spriithy: writing a VM in a language? what kind of VM?
06:33:19 <Spriithy> Well, Scala compiles to the JVM
06:33:31 <opqdonut> I see
06:33:51 <opqdonut> I thought we were talking about VMs as in virtualization
06:33:57 <Spriithy> ah no :P
06:34:07 <ongy> it is a form of virtualization :)
06:34:15 <opqdonut> well, yeah
06:34:22 <Spriithy> it is
06:34:29 <opqdonut> anyway I use clojure at work, that compiles to the jvm. I think scala is too complex
06:34:36 <Spriithy> I have written a MIPS interpreter in C when  I was in college
06:34:44 <ongy> and I would clearly use haskell and the HalVM
06:34:51 <opqdonut> I've never bumped into the requirement of running on "a VM"
06:34:57 <opqdonut> it's always some specific vm, usually the jvm
06:35:08 <opqdonut> you could think of the GHC runtime as "a VM"
06:35:14 <hodapp> Spriithy: there's always https://github.com/typelead/eta/
06:35:32 <Spriithy> What I mean with all that, is that I have a toy language that I want to compile down to something highly portable
06:35:42 <Spriithy> other than C ofc
06:35:51 <opqdonut> riiight
06:35:55 <opqdonut> I recommend LLVM
06:35:55 <hodapp> there's always LLVM
06:36:16 <Spriithy> yeah thought of that
06:36:25 <opqdonut> I've done JVM bytecode generation and it's not horrible, but you need to make everything javalike
06:36:37 <opqdonut> wouldn't fit e.g. a CPS-style compiler
06:36:54 <Spriithy> well LLVM has some high learning curve
06:36:57 <Spriithy> isn't it ?
06:37:05 <Spriithy> steep, rather
06:37:11 <opqdonut> it was pretty straightforward in my experience
06:37:17 <hodapp> if you are targeting any virtual machine directly it's probably going to have a learning curve
06:37:21 <opqdonut> I guess the usual thing these days is to compile to javascript
06:37:24 <hodapp> bleh
06:37:27 <opqdonut> ;)
06:37:30 <Spriithy> lol
06:37:37 <Spriithy> you gotta be kidding me x)
06:37:50 <opqdonut> LLVM doesn't have a GC, though I guess there are libraries, but I haven't used them. If you want a garbage collected language LLVM might not be the easiest option
06:37:57 <hodapp> no, JavaScript is basically ASM for the web (ignoring more recent efforts like webasm)
06:38:02 <merijn> opqdonut: Why not?
06:38:23 <opqdonut> let me rephrase, I don't know how easy or hard GC on LLVM is
06:38:25 <Darwin226> Sorry for the slight spam but if someone with experience could answer my SO question I'd appreciate it. It's about skipping GHC MinGW
06:38:26 <Darwin226> https://stackoverflow.com/questions/45460406/instruct-stack-to-use-the-already-installed-mingw?noredirect=1#comment77907012_45460406
06:38:27 <merijn> opqdonut: The usual way you do GC is to have a runtime library providing functionality via function calls
06:38:32 <Spriithy> what about Golang ?
06:38:53 <opqdonut> Spriithy: go is compiled to native code
06:39:01 <opqdonut> AFAIK
06:39:01 <Spriithy> ikr but it has a GC runtime
06:39:02 <merijn> opqdonut: So it's not more or less hard than doing GC while generating native code is
06:39:12 <opqdonut> sure
06:39:24 <Spriithy> I could basically generate some GO code out of my toy language
06:39:42 <opqdonut> but with JVM / javascript you get a GC out of the box
06:39:48 <Spriithy> true that
06:39:56 <merijn> opqdonut: But then you're stuck with their allocation model too
06:40:07 <merijn> opqdonut: Not to mention JS you have to work around the lack of proper integers
06:40:11 <Spriithy> Toy > go > native has the advantage of being both native & with a GC
06:40:25 <opqdonut> merijn: sure
06:43:22 <Spriithy> I think I'll try the Go alternative and will pick JVM if I face too much problem
06:54:46 <frerich> Spriithy: In case you do decide to give LLVM a try after all, I liked http://www.stephendiehl.com/llvm/ quite a bit
06:55:08 <Spriithy> already checked this out :P thanks for the attention frerich 
06:55:22 <Spriithy> will probably go with it
06:57:17 <Spriithy> By the way
06:57:55 <Spriithy> Is it better to do "type Token = (String, Kind, Int)" or "data Token = Token { text :: String, kind :: Kind, line :: Int }" ?
06:58:10 <opqdonut> latter usually
06:58:36 <frerich> Spriithy: Note that there's also an option 'inbeween': 'data Token = Token String Kind Int'
06:59:10 <Spriithy> thank you :) I will go with the Record i think
06:59:38 <frerich> Spriithy: I typically use that because a) the record field names clash easily (e.g. in your case you will probably want tokenText, tokenKind and tokenLine) and b) I end up using shorter names locally when pattern matching Token values.
06:59:58 <Spriithy> True that
07:03:05 <Spriithy> Haskell style question: better match empty string with "" or [] ?
07:03:20 <Spriithy> (i know that "" is syntax sugar for []"
07:03:39 <danza> Spriithy, i guess that it depends on what you want to express
07:04:11 <danza> for example if the code around is handling the string as a list or as text
07:04:26 <frerich> Spriithy: If it's an empty string, I think I use "". For lists of other things (other than Char), I use []. Don't' forget the "null" function. :-)
07:04:50 <Spriithy> frerich: what is the "null" function ?
07:05:03 <cocreature> > null []
07:05:05 <lambdabot>  True
07:05:07 <cocreature> > null [1,2,3]
07:05:09 <lambdabot>  False
07:05:14 <cocreature> that should give you an idea what it does :)
07:05:48 <Spriithy> null ""
07:06:15 <SolitaryCypher> > null ""
07:06:16 <Spriithy> obviously returns True I gues
07:06:17 <lambdabot>  True
07:06:26 <srhb> Spriithy: "> " triggers lambdabot.
07:06:33 <Spriithy> Oh right thx srhb 
07:10:16 <frerich> Spriithy: I'm mentioning it in case you plan to test for empty lists in places where you need a boolean value (e.g. guards or 'if'). The benefit of 'if null xs then this else that' over 'if xs == [] then this else that' is that the former does not require the elements of 'xs' to implement the 'Eq' class.
07:10:52 <Spriithy> that is smart I must say.
07:11:41 <Spriithy> My biggest issue right now with Haskell is all those Functor / Monoids / Monads / Maybe etc
07:11:48 <Spriithy> I really don't get a good grasp of those
07:12:48 * hackagebot alea 0.5.3.0 – a diceware passphrase generator – https://hackage.haskell.org/package/alea
07:12:57 <frerich> Spriithy: I think you might find that you can have a whole lot of fun with Haskell (and get something out of it which makes you a better programmer in other languages) even without fully understanding everything. I believe that as long as you're having a good time, you'll pick up knowledge along the way.
07:15:27 <Spriithy> yeah
07:19:19 <dramforever> Q: Any idea how to make 'stack exec' faster?
07:22:53 <dramforever> I mean for tooling that's going to be quite helpful
07:22:59 <dramforever> *editor tooling
07:23:10 <sm_> dramforever: what delay does stack exec cause ?
07:24:10 <dramforever> trying to write a 'check haskell code on save' vscode extension
07:25:07 <dramforever> on a small module (164 lines w/ comments) running 'stack exec ghc -- ...' takes about 700ms
07:25:10 <MarcelineVQ> stack exec adds a half second to most things, and often more
07:25:24 <dramforever> but if I 'stack exec code' then just 'ghc ...' it takes 300ms
07:25:42 <dramforever> MarcelineVQ: I guess that means my laptop is a bit faster than yours :)
07:26:00 <MarcelineVQ> just depends what you're doing and what's been cached by the os :>
07:26:58 <MarcelineVQ> for example if you run the same command a couple times, say   time stack exec ghc --version     it should be pretty darn speedy the second time, but probably take around 1s the first time
07:27:32 <dramforever> but it's still pretty slow compared to plain 'ghc --version', even later times
07:27:34 <MarcelineVQ> compared to ghc --version taking around 300ms here for bare first time
07:28:02 <lyxia> I have no idea how stack works. Would  stack exec myshell  allow you to run multiple commands by loading the modified environment just once?
07:28:03 <MarcelineVQ> yes it's annoyingly slow, especially if you're using it often, like some sort of editor integration
07:28:06 <dramforever> plans: 1. use 'GHCi'
07:28:21 <dramforever> 2. use 'stack exec cmd' (Windows) or 'stack exec sh' and pipe in commands
07:28:27 <cocreature> at some point "stack exec" was even worse but me complaining actually resulted in improvements :)
07:29:15 <MarcelineVQ> lyxia: it should
07:29:48 * dramforever is pretty excited about this -ddump-json thingy, tbh
07:29:58 <dramforever> if only it worked
07:30:02 <dramforever> in GHCi
07:30:19 <RedNifre> Hey there. What's this kind of list called? [1, 2, 3, "huh?"]
07:30:31 <MarcelineVQ> heterogenous
07:30:38 <Clint> "silly"
07:30:52 <cocreature> in Haskell it’s called “not a list” ;)
07:30:59 <ongy> typeerror :) but yea Heterogenous, and there's HList
07:31:01 <MarcelineVQ> I like cocreature's answer
07:31:02 <RedNifre> I'm looking for a professional sounding word for "silly", like "unsound" or something like that.
07:31:15 <opqdonut> or alternatively 'No instance for (Num [Char]) arising from the literal ‘1’'
07:31:17 <cocreature> how about “a type error”
07:31:22 <MarcelineVQ> ill-typed
07:31:23 <lyxia> instance Num String where fromInteger = show
07:31:29 <ongy> RedNifre: http://www.thesaurus.com/browse/silly :P
07:31:43 <dramforever> RedNifre: type error
07:31:53 <dramforever> Basically what 1 + "huh?" is called
07:32:15 <ongy> I like sheepheaded. Put the '🐏' char in there
07:32:33 <lyxia> It can be any type with OverloadedStrings and the appropriate context!
07:32:34 <RedNifre> "ill-typed" sounds good, thanks :)
07:33:34 * hackagebot dns 2.0.12 – DNS library in Haskell – https://hackage.haskell.org/package/dns
07:38:50 <shapr> Why would some Haskell code segfault in ghci, but work fine in a compiled program?
07:39:08 <ongy> something optimized out when compiling?
07:39:28 <shapr> or doesn't like being dynamically loaded?
07:39:38 <MarcelineVQ> because someone didn't make a trac ticket about it :O
07:39:53 <shapr> How do I diagnose such a problem?
07:40:47 <ongy> probably find out where it segfaults. Do you call into FFI or some other weirdness?
07:41:18 <shapr> Yeah, it's an issue reported for the hs-zstd package, but I thought it'd be interesting to dig into
07:41:22 <MarcelineVQ> Could be worth comparing core, you can enable core in ghci via  :set -ddump-prep -dsuppress-all  this becomes unweildy pretty quickly though so it's best to narrow it down first if you are able
07:41:50 <shapr> oh that's a good idea
07:43:10 <ongy> you could probably use ltrace to get a rough idea when it segfaults
07:43:35 <ongy> though I'm not well versed in ltrace, so can't give any specifics
07:44:06 <mniip> shapr, ghc version and do you use unsafecoerce
07:45:28 <dramforever> Is it possible to reliably parse error messages from GHCi
07:46:20 <ertes-w> RedNifre: it's called a (Num String) => [String]
07:46:30 <dramforever> I mean, get metadata
07:46:46 <dramforever> like foo.hs:17:5: error:
07:47:15 <shapr> mniip: ghc 8.0.2 and yes this wrapper uses unsafePerformIO
07:48:22 <dramforever> sometimes it's 'tmp.hs:line:col: error:' and the message goes on for some lines, sometimes it's just one line like tmp.hs:5:19: error: parse error on input ‘\’
07:50:34 <dramforever> uh oh now I feel sad: https://github.com/ndmitchell/ghcid/blob/master/src/Language/Haskell/Ghcid/Parser.hs#L27
07:51:02 <opqdonut> lol
07:55:53 <saurabhnanda> GHCJS quick question - what happens if an asyncCallback is not released via releaseCallback? And when exactly should releaseCallback be executed/
08:02:48 <quchen> phadej: Oh, here I am trying to fix Trifecta when your PR is already merged haha
08:03:05 <phadej> quchen: to many cooks...
08:04:36 <Spriithy> how to make a function fail
08:04:46 <Spriithy> if it is not a Monad, without using "erro"
08:04:58 <Spriithy> I mean, I don't want all the Exception text of ghc
08:05:00 <phadej> change a -> b into a -> Maybe b
08:05:33 <quchen> phadej: This should be a patch version bump in Trifecta, right?
08:05:33 <quchen> It doesn’t change observable behavior, just patches the orphan
08:05:52 <phadej> quchen: yeah, IIRC I already bumped it to 1.7.1.1 (and wrote changelog entry!)
08:06:01 <phadej> ... in my pr
08:06:47 * quchen is enjoying German countryside internet, hooray
08:06:49 <quchen> Responses to everything might be delayed by (literally) hundreds of seconds. Oh well
08:07:30 <quchen> phadej: Sooo I can just »stack upload« and be done with it? :-D
08:08:30 * hackagebot dotenv 0.4.0.0 – Loads environment variables from dotenv files – https://hackage.haskell.org/package/dotenv
08:09:11 <phadej> quchen: yeah
08:09:18 <phadej> git diff v1.7.1..master doesn't show anything weird
08:09:26 <phadej> quchen: https://twitter.com/Darep/status/892779100129177605
08:11:28 <ongy> quchen: what? you expect your messages to arrive at some point with German countryside internet? :)
08:13:12 <cocreature> his ping message definitely didn’t arrive
08:20:06 <quchen> phadej: Released! (After a long disconnect in the meantime)
08:25:40 * hackagebot trifecta 1.7.1.1 – A modern parser combinator library with convenient diagnostics – https://hackage.haskell.org/package/trifecta
08:27:33 <tabaqui> btw, why arrows in signatures and in case syntax has the same notation
08:28:04 <tabaqui> I mean, when it was realized that arrows is just another type?
08:28:24 <sproingie> a case can be thought of as a partial function
08:28:42 <sproingie> otherwise the overlap is pretty much coincidental
08:29:41 <tabaqui> overlapping is impossible, because it happens in "type layer" and in "data layer" in different cases
08:29:56 <mnoonan> there are other cases of type expressions mirroring the corresponding values though.. [a] vs [1,2,3], (a,b) vs (x,y), the canonical "newtype Foo = Foo etc"
08:30:26 <sproingie> the overlap i'm talking about is the overlap of similar notations
08:30:50 <tabaqui> right.. I don't think about such crossings
08:31:00 <mnoonan> it's like a less crappy version of C's "declaration mirrors use" :)
08:31:15 <sproingie> the type and term levels do try to look somewhat like each other.  thankfully.
08:31:40 <tabaqui> ok, what about '=' sign?
08:31:51 <sproingie> it signifies equality
08:32:08 <sproingie> binding, really
08:32:14 <tabaqui> but not in " | predicate = expression" syntax
08:32:32 <sproingie> sure it does, you pronounce '|' as "when"
08:32:39 <sproingie> "when predicate equals expression"
08:32:56 <tabaqui> right, why don't we use '=' in case syntax?
08:33:12 <sproingie> cases do pattern matching
08:33:37 <tabaqui> but functions do it too
08:34:01 <sproingie> there wasn't any really deep thought put into the morphology of haskell's syntax
08:34:08 <sproingie> it just evolved from previous languages
08:35:07 <tabaqui> satisfactory...
08:35:24 <tabaqui> but it was like shining in my mind when I realized that (->) is just a type
08:36:02 <sproingie> yep, and a very rich type at that
08:36:50 <tabaqui> I knew that there can be only one Perfect Language, but wanted to know how close haskell is
08:37:10 <sproingie> the Language that can be implemented is not the perfect Language
08:37:18 <tabaqui> lisp can be implemented
08:37:29 <sproingie> and it's nowhere near perfect
08:37:32 <cement> lisp isn't typed, ergo imperfect
08:37:34 <tabaqui> it doesn't have syntax, though
08:37:45 <sproingie> lisp has lots of syntax, they're called special forms
08:37:55 <sproingie> to say nothing of reader macros
08:38:11 <mauke> lisp has twice as much syntax as other languages
08:38:22 <tabaqui> cement: you can add types if you want
08:38:40 <cement> I know a guy who tried and went insane as a result
08:38:49 <sproingie> you can, the type system still isn't very rich
08:38:59 <sproingie> typed racket does a bit better.  qi better yet.
08:39:00 <cement> then again, he was already insane, so my data is a bit flawed
08:39:40 <sproingie> i wouldn't mind haskell with lisp syntax.  such a thing existed way back, probably bit-rotted now.
08:39:50 <mauke> @where liskell
08:39:50 <lambdabot> http://clemens.endorphin.org/liskell
08:40:01 <sproingie> it's 404-compliant
08:41:01 <sproingie> but it's not like i have serious gripes about haskell's syntax most days
08:41:56 <cement> I basically learned to program in haskell, but I've yet to get good enough to have a gripe that isn't "I don't actually know how any of this shit works"
08:42:05 <RedNifre> There's also hackett
08:42:12 <RedNifre> ...which is haskelly racket.
08:42:33 <sproingie> not heard of hackett
08:43:00 <RedNifre> It used to be called Rascal until the author noticed that there was already a programming language with that name.
08:43:10 <RedNifre> https://lexi-lambda.github.io/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/
08:43:23 <jan_path> Does someone know of an existing newtype, that lifts monoid instances through applicatives?
08:43:43 <quchen_> jan_path: Nothing in the standard lib at least
08:43:49 <quchen_> Edward surely has it somewhere
08:44:07 <quchen_> But I think you’re better off just writing down the 4-liner yourself instead of adding a whole dep for it
08:45:00 <jan_path> Yeah thanks. Or in this case just use foldMapBy.
08:47:36 <black0range> Hey i just asked the servant guys for help but its kinda quietin #servant... Trying to figure out how to use it but i cannot figure out what type "authentication" should be in order to compile! :( 
08:47:38 <black0range> http://lpaste.net/357384
08:48:01 <black0range> Haskell is unable to autoresolve it 
08:49:24 <cocreature> black0range: please show us the error
08:50:19 <black0range> cocreature: http://lpaste.net/357385
08:51:19 * hackagebot configuration-tools 0.3.0 – Tools for specifying and parsing configurations – https://hackage.haskell.org/package/configuration-tools
08:54:50 <black0range> The most logical type should be: authentication :: Handler a -> Maybe String -> Handler (WithToken a)
08:55:47 <black0range> but that returns the following http://lpaste.net/357386
09:04:44 <cocreature> black0range: `Handler (Headers '[Header "KTH_TOKEN" String] a)` makes the definition of `authentication` type-check but not the use-site. I sadly don’t have time to play more type-tetris to figure out what that should be
09:06:13 <cocreature> eh I guess it should be "SetCookie" not "KTH_TOKEN"
09:11:48 <cocreature> black0range: turns out type-tetris is additive: here’s the solution http://lpaste.net/357387
09:11:59 <cocreature> black0range: `Headers` needs to come after the verb
09:14:01 <Spriithy> what is the difference between "IO String" and "String" ?
09:14:22 <Spriithy> I am willing to use `readFile` but that "IO" makes me doubt ...
09:15:07 <mnoonan> one is a string, the other one is instructions about how to interact with the world to produce a string
09:15:25 <Spriithy> okay ? how do I extract the said string then ?
09:15:45 <Ferdirand> you don't
09:15:55 <Spriithy> `extract :: IO String -> String` extract _ s = s
09:15:58 <Spriithy> won't work ?
09:16:16 <cocreature> you create a new action that when executed first produces a string and then does something with that string
09:16:18 <Ferdirand> no, because IO String does not contain a tring
09:16:20 <Ferdirand> string*
09:16:25 <Entroacceptor> That question is equivalent to "How do I get my burrito out of my cookbook"
09:16:26 <cocreature> but you can’t escape the “action” (i.e. IO) part
09:16:33 <Ferdirand> it contains a sequence of actions that, when executed, will give you a string
09:16:43 <mnoonan> Spriithy, think of "IO X" like the literal text of a C program that, when run, would produce an X
09:17:06 <Ferdirand> remember that values in haskell are immutable
09:17:18 <mnoonan> asking to get a string out of an IO String is like having the text of a C program in front of you and saying "how do I get the output out of this C code?"
09:18:02 <tippenein> looking to move from hacky migration management to a library. Any recommendations?
09:18:19 <Spriithy> okay I understand 
09:18:34 <tippenein> It's within a yesod app; that may or may not matter
09:18:37 <Spriithy> and how could I retrieve the said text from the file given the IO String ?
09:18:39 <verement> Spriithy: you extract the string using the (>>=) operator: readFile path >>= \str -> …
09:18:48 <Spriithy> oh it's a monad ?
09:19:25 <byorgey> yes, it is.
09:19:45 <Spriithy> readFile "foo.txt" >>= print . foo
09:19:50 * byorgey is very happy to find someone who has learned about monads without yet encountering the fact that IO is one.
09:19:51 <Spriithy> would do it am I right ?
09:20:04 <[exa]> Spriithy: you might want to see an example here https://stackoverflow.com/questions/7867723/haskell-file-reading
09:20:21 <byorgey> Spriithy: sure, if  foo :: Show a => String -> a
09:20:29 <Spriithy> yap byorgey :) 
09:20:31 <Spriithy> Thanks all
09:20:36 <byorgey> Spriithy: you might need parentheses around (print . foo), I forget
09:20:57 <Spriithy> byorgey: I am very uncomfortable with the Monad thing anyways 
09:21:11 <byorgey> Spriithy: that's OK, just keep practicing
09:21:23 <Spriithy> just know they have `>>=` and `return`
09:21:46 <byorgey> Spriithy: that's a good start.  And do you know the types of (>>=) and return ?
09:22:27 <Spriithy> IIRC >>= * -> * 
09:22:37 <Spriithy> But I have no clue what this means
09:22:39 <byorgey> that is a kind, not a type.
09:22:48 <mbrock> it would be so cool to be able to use brick/vty with ghcjs...
09:22:54 <Spriithy> :t >>=
09:22:56 <lambdabot> error: parse error on input ‘>>=’
09:23:11 <byorgey> Spriithy: so, for your next level up, go memorize the types of (>>=) and return
09:23:32 <byorgey> :t (>>=)
09:23:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:24:34 <Spriithy> Well even reading them is obscure right now. It takes a Monad over 'a', a function that turns an 'a' into a Monad b and returns that said monad b
09:25:18 <Spriithy> So you give (>>=) a source Monad, a transformer, and it returns the result 
09:25:30 <Ferdirand> are you confident with Functor and Applicative ?
09:25:36 <Spriithy> Not at all
09:25:50 <[exa]> Spriithy: this is also worth reading http://www.learnyouahaskell.com/a-fistful-of-monads
09:26:02 <Ferdirand> you should perhaps start with them
09:26:13 <[exa]> Spriithy: (maybe one chapter backwards)
09:26:22 <Ferdirand> :t (<$>)
09:26:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:26:28 <Ferdirand> :t (<*>)
09:26:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:26:36 <mnoonan> (a C program that produces a String) >>= (a C program that produces a Foo, with some holes to plug in a String) gives you a (C program that produces a Foo)
09:26:40 <Spriithy> these functions look damn scary :')
09:26:55 <Ferdirand> but they are conceptually much simpler
09:27:21 <byorgey> Spriithy: then maybe you want to go practice more with things like polymorphism and type classes first
09:27:46 <Spriithy> I think I first have to unlearn my imperative programming background
09:28:00 <Spriithy> It retains me too much in old habits
09:28:05 <Spriithy> and concepts
09:28:19 <byorgey> Spriithy: well, sure, but the only way to unlearn old things is to learn new things.
09:28:27 <Spriithy> exactly
09:28:37 <Ferdirand> <$> (fmap) just applies a pure function to the inner type of a functor/applicative/monad
09:28:53 <Spriithy> Off topic: do you tures right nowsuggest any good code formatter ? Stylish haskell lacks so much fea
09:29:00 <Spriithy> (text got mixed up???)
09:29:14 <Spriithy> Off topic: do you suggest any good code formatter ? Stylish haskell lacks so much features right now
09:30:13 <Ferdirand> <*> is the same except instead of (a -> b) you have m (a -> b)
09:30:23 <Ferdirand> and (>>=) is the same except you have a -> m b
09:30:31 <[exa]> Spriithy: depends on your editor, e.g. here for vim https://wiki.haskell.org/Vim
09:30:40 <Spriithy> I use VS Code
09:30:54 <Spriithy> but am flexible
09:31:07 <Spriithy> (except vim & emacs ^^")
09:31:16 <Spriithy> tried too much
09:31:57 <Spriithy> :t (<|>)
09:31:58 <lambdabot> Alternative f => f a -> f a -> f a
09:32:03 <[exa]> probably hfmt then
09:32:34 <[exa]> or hindent, https://github.com/commercialhaskell/hindent#readme
09:38:41 <Spriithy> Oh and, why do I have to install everything with both stack and cabal .... ? 
09:38:44 <Spriithy> that's quite dumb
09:50:41 * hackagebot irt 0.2.0.0 – A Haskell library providing Item Response Theory functions for use in… – https://hackage.haskell.org/package/irt
09:54:06 <cement> afaik stylish has some options that make it more "feature-full"
09:54:31 <cement> just gotta generate stylish-haskell.yaml and change things
10:08:55 * hackagebot leancheck 0.6.4 – Cholesterol-free property-based testing – https://hackage.haskell.org/package/leancheck
10:16:01 * hackagebot linguistic-ordinals 0.1.0.2 – Express Integral types as linguistic ordinals (1st, 2nd, 3rd, etc) – https://hackage.haskell.org/package/linguistic-ordinals
10:24:07 * hackagebot irt 0.2.0.1 – Item Response Theory functions for use in computerized adaptive testing – https://hackage.haskell.org/package/irt
10:43:22 <hololeap> i'm looking for a sound library. i want it to be currently maintained, cross-platform (linux/win/osx), and i would prefer if it was written in a functional style, not just a wrapper over a c library. it would also be cool if you could add an effects chain (like libavfilter)
10:43:49 <hololeap> but just something maintained and cross-platform would be ok
10:48:50 <Spriithy> re
10:49:28 <erisco> you forgot your colon
10:49:39 <mnoonan> Spriithy, about your earlier comment.. if you're installing everything with both stack and cabal, you're doing something wrong
10:51:58 <chanakaudaya> what is the best place to learn haskell?
10:52:11 <erisco> here
10:52:58 <chanakaudaya> why it's type system is so great compared to Java?
10:53:53 <mniip> by design
10:54:15 <erisco> Haskell has much better inference (write less types!), type classes, polymorphic higher order kinds (so you can have F<A> where F is also a type parameter)
10:54:41 <erisco> I mean higher kinded types
10:54:53 <erisco> polymorphic higher kinded types
10:55:21 <mniip> (some pedantry about quantified vs polymorphic types)
10:55:24 <byorgey> also higher-order types, i.e. functions of functions etc.
10:56:07 <erisco> well Java has its wrapper class things so you can pass functions around
10:56:48 <erisco> mniip, I dunno man, I get lost in the terminology here
10:57:18 <mniip> id is a polymorphic value and its type forall a. a -> a is quantified
10:57:31 <mniip> Proxy is a polymorphic type because its kind is quantified
10:57:31 <pikajude> also true for ego and superego
10:57:48 <erisco> is that how they're saying it now? okay then
10:58:03 <mniip> well, as long as you're understood ;)
10:59:20 <byorgey> erisco: sure, I know you can simulate higher-order functions in Java.  The question was why Haskell's type system is better than Java's.
11:00:31 <erisco> byorgey, you can do a surprising amount in Java and other OOPs, to varying degrees of make-believe, so I emphasize the really impossible stuff
11:00:48 <mnoonan> just right off the bat, Java can have runtime type errors. so the type system doesn't even prevent type errors.
11:01:22 <erisco> mnoonan, does it? from things other than casts?
11:01:57 <mnoonan> erisco, yes, one of (co/contra)variance is messed up for arrays, so you have to check types going in and out
11:02:31 <erisco> ah yeah, sounds familiar ... you can take an array of integers and bring it up to an array of objects, or some such
11:03:03 <glguy> Java's type system is also unsound in other ways http://io.livecode.ch/learn/namin/unsound
11:03:20 <erisco> oh, oh, here is the best one... no null!
11:04:12 <glguy> Uses of the wildcard type (?) will (potentially incorrectly) assume that the wildcard is inhabited
11:04:33 <sqooq> erisco, you here?
11:04:55 <kuribas> Is a Data.Vector.Unboxed.Vector UInt8 packed?
11:05:18 <kuribas> so it takes 1/4 the space of a Vector UInt32?
11:05:19 <tabaqui> but haskell has unsafeCoerce, right?
11:05:43 <tabaqui> and new funny backpacks
11:05:46 <erisco> kuribas, iirc there is a class unboxed types have to inhabit
11:06:09 <kuribas> erisco: yes, Unbox
11:06:49 <erisco> so, you either have an Unbox instance or not
11:07:48 <tabaqui> :i unsafeCoerce
11:09:17 <glguy> tabaqui: unsafeCoerce is not a problem with the type system, and it's not part of the Haskell specification. It explicitly exists as an implementation detail used to override the type system
11:09:41 <erisco> kuribas, and yes, when it gets unboxed all the memory overhead goes away, so you're left with the exact size of the data
11:09:51 <kuribas> right thanks
11:10:02 <tabaqui> glguy: but it lies in Unsafe.Coerce, not in GHC...
11:10:15 <glguy> tabaqui: ok?
11:10:15 <tabaqui> it is not a part of Haskell 98?
11:10:54 <tabaqui> I mean GHC... modules are out of standart, but other base libriaries are in
11:11:34 <glguy> No, being in the base package doesn't mean it's part of the standard, but in any case it's an explicit escape hatch from the type-system, so not interesting as a flaw
11:11:52 <monochrom> I'm afraid this is only ending in a debate over "standard", "de facto standard", "non-standard", "really unsafe non-standard", and all the gray areas in between.
11:12:58 <sqooq> ghc won't derive instance show for my parser
11:13:02 <sqooq> is there some way I can do this
11:13:12 <tabaqui> anyway, you can always blow up your leg in almost any language
11:13:17 <tabaqui> describe it by yourself?
11:13:23 <monochrom> Parsers don't usually have a sensible "show". What is there to show?
11:13:25 <glguy> tabaqui: You might be missing the point of the question
11:14:01 <tabaqui> glguy: it starts from "java can raise type error in runtime, while haskell cannot"
11:14:30 <nshepperd> you can't use unsafeCoerce by accident
11:14:51 <monochrom> My angle is not "can it be done in principle", but rather the more social "how often do people actually do it".
11:15:05 <mniip> tabaqui, unsafeCoerce wouldn't be an error
11:15:11 <mniip> it would be a panic, an unrecoverable failure
11:15:15 <hexagoxel> with Typeable/Dynamic, i can raise "type errors" in haskell just fine.
11:15:38 <glguy> You can raise "type errors" but not actual type errors
11:15:53 <tabaqui> unsafeCoerce doesn't raise any exceptions
11:15:59 <hexagoxel> yeah, we certainly can argue that definition, too :p
11:15:59 <tabaqui> just UB
11:16:02 <tabaqui> well then
11:16:05 <monochrom> The Java people have erroneous upcasting much more often than the Haskell people have erroneous unsafeCoerce.
11:16:09 <glguy> hexagoxel: That's a pretty easy argument though
11:16:16 <erisco> unsafeCoerce does not exist because it has to, it is just there
11:16:29 <monochrom> Relatedly, the Java people use upcasting much more often than the Haskell people use unsafeCoerce at all.
11:16:42 <mniip> monochrom, indirectly though...
11:16:45 <erisco> so really it has nothing to do with the type system
11:16:58 <mniip> Dynamic uses unsafeCoerce
11:17:00 <nshepperd> you can avoid the unsafeCoerce 'problem' by not using unsafeCoerce. in Java, you can avoid the upcasting problem by... not... using generic containers? ever?
11:17:02 <mniip> ByteString uses unsafePerformIO
11:17:28 <erisco> yeah, libraries use it for efficiency reasons of one sort or another, that's why it is there
11:17:41 <frerich> Sometimes the Haskell documentation uses some awkward wording, e.g. 'Monoid under addition'. Why is it 'under' and not, say, 'in terms of'?
11:17:44 <erisco> but it is not necessary for the language to work... it is not linked to the type system in a necessary way
11:17:51 <monochrom> And yeah, unsafeCoerce is just a code optimization, if it were banned we only lost a bit of performance. Java cannot afford to use upcasting at all, they would lose most applications.
11:18:14 <monochrom> Err, s/upcast/downcast/g !
11:18:17 <tabaqui> frerich: your algebraic structure has f.e. two binary operations
11:18:30 <erisco> frerich, because it means you are adding the objects in question... like the integers are a monoid under addition (and 0, important to have your identity)
11:18:31 <tabaqui> but it is monoid "under" one of them
11:18:54 <monochrom> Also, s/afford to use/afford to lose/
11:19:27 <monochrom> Also, I've just shown that typos are infectious. If I write "upcast" for "downcast", everyone else starts doing it too :)
11:19:30 <kadoban> frerich: That's the usual wording AFAIK. Not quite sure why.
11:19:49 <frerich> tabaqui: Right, but my question is why it is 'under', i.e. the word 'under'.
11:20:05 <erisco> because they are subjected to it
11:20:08 <tabaqui> dunno, in Russin it is "over", actually)
11:20:11 <erisco> you work under your boss
11:20:12 <tabaqui> *Russian
11:20:19 <monochrom> Oh, the mathematicians started the "under addition" and "under change of coordinates" business.
11:20:20 <erisco> the integers are under addition
11:20:43 <frerich> In soviet russia, monoids are over addition?
11:20:53 <tabaqui> haha, classic
11:20:58 <monochrom> And the computer people started the "xchat runs under Windows" business. I don't understand it either. Clearly, xchat runs atop Windows.
11:21:13 <glguy> *in spite of*
11:21:19 <monochrom> But natural language. Meh. Idioms trump logic.
11:21:20 <cement> lmao
11:21:28 <monochrom> haha
11:21:51 <monochrom> And idioms are defined by the loudest people, who are usually the most illogical people. Meh.
11:21:58 <monochrom> Screw natural language.
11:21:59 <hexagoxel> (with the new Typeable interface of ghc-8.2, Dynamic no longer uses unsafeCoerce btw.)
11:22:04 <nshepperd> the integers are a monoid in spite of addition
11:22:09 <tabaqui> mathematicians are the most illogical people
11:22:16 <tabaqui> I should note it!
11:22:36 <frerich> I just never know when something is 'over' something else (I think people say you fold 'over' some data structure?) and sometimes it's "under" something.
11:22:40 <glguy> hexagoxel: I don't think that's the case
11:23:14 <erisco> frerich, you need a bit of synesthesia to make sense of this stuff
11:23:29 <glguy> hexagoxel: cast uses eqTypeRep uses unsafeCoerce
11:23:48 <nshepperd> :t under
11:23:50 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
11:23:50 <monochrom> frerich, it's idioms. You just have to rote-memorize it. There is nothing to understand. Such is the way of prepositions.
11:24:15 <cement> there is a twisted sort of logic between those two though
11:24:19 <erisco> frerich, someone came up with a word based on how they picture it in their head... it is a complicated process of analogy... it is what it is
11:24:25 <nshepperd> :t over
11:24:27 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
11:24:29 <nshepperd> ‾\(*_O)/‾
11:24:30 <cement> english is surprisingly consistent with prepositions, actually
11:24:41 <tabaqui> do you know any thread-safe search structure?
11:24:49 <erisco> frerich, figure out why we have a type named Clown and another named Joker
11:24:55 <frerich> monochrom: Seems so, but whoever started this surely had a reason to not, say, claim that 'monoid surrounding addition' or 'monoid enclosing addition' or so. For some obscure reason, 'under' seemed most appropriate. :)
11:24:56 <tabaqui> I can write my own with STM's but maybe there is better solution
11:25:36 <monochrom> Well I guess it started with "under such-and-such assumption" and it made sense at first.
11:25:52 <crucify_me> hi , here length returns an Int, but why is there no trace of the Ord constriction in the signature when we do the first type check? Shouldn't that be ' myCompare :: (Ord a, Int a) => Bool '  ? Is that under the hood somewhere?   https://ptpb.pw/ynSZ
11:25:53 <erisco> frerich, you are attaching the wrong thing to under... it is not "monoid under addition" it is "integers under addition are a monoid"
11:26:16 <frerich> erisco: 'monoid under addition' is actually a quote from http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html
11:26:17 <monochrom> I mean, rings are called "rings" because the French or German were calling it "annulus" because the first examples they thought up were the integer-mod-m ones.
11:26:21 <erisco> frerich, they have just moved the words in the sentence around to read "integers are a monoid under addition"
11:27:01 <monochrom> But surely there are torsion-free rings so the "ring" analogy breaks down very quickly.
11:27:04 <cement> crucify_me: Int is an instance of Ord
11:27:11 <nshepperd> yes, it's the integers that are under addition
11:27:25 <sqooq> o nvm i can't show functions
11:27:27 <sqooq> shoot
11:27:29 <nshepperd> Addition S = (S, +)
11:27:36 <monochrom> So basically naming and idioms "made sense" but only in a very short-sighted sense.
11:27:37 <nshepperd> instance Monoid (Addition Z)
11:28:06 <monochrom> And "dashboard" has an even more glorious story.
11:28:23 <frerich> monochrom: I guess at a certain level of abstraction, it's kinda hard to come up with plausible names so you may as well hijack existing words and demand that people free their minds in a Zen-like manner.
11:28:30 <tabaqui> when you say "Moufang loop" do you mean actual loop (cycle)?
11:28:31 <erisco> frerich, in natural language it is usually ambiguous as to what words are attached to what... such is the problems of flattening a map of associations to a linear media
11:28:39 <nshepperd> the integers, Z have been acted upon by adding addition. Z is the argument of this operator, and hence "under" it
11:28:41 <crucify_me> cement excellent thanks. Can you force the interpreter to list both or is that against the rules?
11:28:41 <erisco> frerich, but "under addition" is attached to "integer", not "monoid"
11:29:23 <crucify_me> ...I just need to know its an instance of Ord
11:29:28 <crucify_me> right?
11:30:04 <erisco> you will also read "the integers are closed under addition"... it is not "integers are (closed under addition)", it is "(integers under addition) are closed"
11:30:06 <monochrom> In ghci, enter either ":info Int" or ":info Ord" to discover that Int is an instance of Ord, among other information.
11:31:05 <cement> if something is already an instance, it won't show the constraint
11:31:07 <erisco> though you can talk about the property of "closed under addition", and in that sense integers belong to that group of things, using integer addition
11:31:18 <erisco> this is what makes natural language painful to describe technical concepts :P
11:31:36 <cement> ie. Ord is defined as class Eq a => Ord a where
11:31:53 <cement> so you always know that if something is Ord, it's also Eq
11:32:10 <cement> so you don't ever need to say (Eq a, Ord a) =>
11:32:21 <cement> just Ord a =>
11:32:28 <frerich> Are there mathematical concepts which are just so strange that people felt that not even words like 'group' or 'category' or 'semigroup' or so fit, so they decided to call it something made up, like, a cowabunga or so?
11:32:39 <frerich> Hm I guess I'm getting offtopic, ignore me. :-)
11:32:57 <cement> I feel like I've read a few Edward libraries with names like that
11:33:03 <erisco> well then you just insert your last name
11:33:24 <monochrom> Except when you look at the exercises at the back of the chapter, you see "Q3. Prove the closure-under-addition property for the following sets.  (a) Integers.  (b) Natural numbers.  (c) Rational numbers. ..."  So if you go by erisco's way, you have to conjure "closure-under-addition property = \s -> (s under addition) is close".
11:33:25 <nshepperd> in haskell we have Sum Integer, which basically reads literally "integers under addition"...
11:33:56 <crucify_me> cement excellent really appreciate that, this is sinking in.
11:34:12 <monochrom> frerich: You are asking the right channel! An example is "monad". :D
11:34:16 <erisco> monochrom, I just said you can have "closed under addition" as a property
11:34:35 <kadoban> frerich: Well, that's approximately where all the terms come from in the first place, someone makes up a word (or badly translates a word from another language) and then it just gets called that if anyone ends up caring about the concept.
11:34:52 <mnoonan> frerich, see a random john conway paper, probably
11:35:05 <cement> sometimes two people name things independently and start a holy war over which name is right
11:35:40 <cement> eg. curry vs schonfinkel
11:36:02 <kadoban> xD
11:36:25 <monochrom> schoefinkel? schöfinkel?
11:36:39 <monochrom> err I missed an n.
11:36:47 <kadoban> And thus it is clear why "curry" won.
11:37:03 <monochrom> Typing is hard. Where is my telepathy input device?
11:37:20 <Cale> frerich: Look to set theory if you want really hopeless naming
11:37:38 <Cale> https://arxiv.org/pdf/math/0002089.pdf
11:38:13 <Cale> They just start naming stuff after animals and weaponry and such
11:38:22 <Cale> because there's really nothing reasonable
11:38:31 <monochrom> Wow strong cardinals.
11:38:47 <cement> I start using synonyms for "funny" when I can't think of function names
11:39:00 <kadoban> "hand-grenade" "premouse"
11:39:09 <cement> I *usually* replace them with better names though
11:39:27 <mnoonan> "mouse" is one of the best
11:39:33 <kadoban> cement: I usually just start at f and go up.
11:39:40 <mnoonan> iirc it came from a type of "nice" -> "mice" in a paper
11:41:11 <Cale> Definition 4.1  Let W be a weasel. W is called full provided the following holds. Let α < β be any cardinals of W. There are no τ~ > β and a countably complete F~: P(α) /\ W -> P(β) /\ J_{τ~}^W such that (J_{τ~}^W, F~) is a pre-premouse, c.p.(F~) = α and F~(α) = β.
11:41:22 <cement> I should do that too, but I like looking at source files with things like "hilarious f a xs = ..." in them
11:41:40 <Cale> Yes, pre-premouse.
11:41:45 <monochrom> full weasel and preprepmouse
11:41:56 <erisco> the difference is whether you're talking about ∀x∈S,y∈S.x+y∈S i.e. "closed under addition", and {x+y|x∈N∧y∈N} i.e. "integers under addition"
11:42:12 <Cale> They also use various card suits (diamond and club at least...)
11:42:14 <MarcelineVQ> so, set theory is weird al song lyrics
11:42:33 <Cale> and well, the paper itself is about zero hand-grenade
11:43:04 <cement> so not all of these things are defined in the paper itself?
11:43:14 <cement> like, some of this stuff is from other papers?
11:43:16 <Cale> They got that way because there was zero sharp and zero dagger (the typographical symbol) and so someone realised "hey, this is getting kind of dangerous" and named zero sword
11:43:22 <Cale> yes
11:43:25 <monochrom> erisco, "closed under addition" is (\s -> {x+y|x∈s∧y∈s} ⊆ s)
11:43:30 <Cale> this is all standard terminology for the area
11:43:51 * frerich doesn't understand a word in the PDF but thinks it's hilarious :-)
11:45:01 <monochrom> How long before they advance to "zero napalm bomb"? :)
11:45:06 <[exa]> "less painful introduction into core model theory"
11:45:09 <[exa]> the paper is pure gold
11:45:31 <monochrom> Also, is it "core model theory" or is it "hardcore model theory"? :)
11:46:19 <erisco> monochrom, is that different?
11:46:46 <monochrom> I am showing you there is no difference.
11:46:57 <erisco> between what?
11:47:11 <monochrom> And I'm doing that because you said "the difference is" so you were stating there is a difference and I'm arguing the opposite.
11:47:20 <mniip> Cale, Every full weasel is universal.
11:47:23 <erisco> but one is a proposition and the other is a set
11:47:39 <monochrom> The set is used in the proposition.
11:47:57 <mniip> that's a good way to deal with an existential crisis
11:48:01 <mniip> eat a lot and become a weasel
11:48:18 <erisco> okay, don't see how they fail to be different then
11:48:51 <monochrom> I am actually skeptical about "integers under addition" being the set you said.
11:49:08 <erisco> I could be wrong, but that is what it means to me
11:49:43 <monochrom> "integers under addition is a monoid" does not mean "{x+y|x∈Z∧y∈Z} is a monoid". Rather, it means (Z, +) is a monoid. (Or (Z, +, 0).)
11:49:54 <monochrom> It looks to mean "integer under addition" is (Z, +).
11:50:13 <monochrom> s/mean/me/
11:51:03 <[exa]> oh my, they called [1,2,3,ω,ω+1] "almost linear"
11:51:58 <sqooq> do lambdas next to each other, go into each other?
11:52:11 <monochrom> Do they also have a name for [1,2,ω]? :)
11:52:28 <monochrom> sqooq: I don't know what you mean.
11:52:32 <sqooq> (\x y -> x + y)(\z d -> z + d)
11:52:37 <sqooq> is that sensical?
11:52:43 <sqooq> does the second lambda go into the first
11:52:56 <monochrom> I don't understand "go into".
11:53:00 <erisco> monochrom, you can talk about the monoid properties using that set, but you wouldn't be able to extract +, so it isn't completely transparent, you're right
11:53:01 <sqooq> or does the second lambda wait till it's done before going into the first
11:53:17 <[exa]> sqooq: unless there's something before the first one, the second () should substitute as x to the first one
11:53:28 <tabaqui> sqooq: you are trying to apply first lambda to second lambda
11:53:33 <monochrom> Oh, you go into a lambda.
11:53:36 <sqooq> so
11:53:38 <sqooq> (\y -> (\z d -> z + d) + y) 1
11:53:39 <sqooq> ?
11:53:44 <tabaqui> yes
11:53:50 <mnoonan> sqooq, are you talking about haskell, or about lambda calculus?
11:53:52 <sqooq> i put the 1 there
11:53:54 <sqooq> haskell
11:54:03 <erisco> monochrom, I agree then that (Z, +) makes more sense
11:54:14 <sqooq> then it becomes
11:54:15 <sqooq> (\z d -> z + d) + 1 
11:54:19 <tabaqui> and if you didn't describe "+" for function and "y" type, you'll get an error
11:54:27 <AWizzArd> Does Liquid Haskell have serious drawbacks over Dependent Types? Or can it for many pratical purposes achive +/- the same?
11:54:34 <sqooq> but then what
11:54:35 <erisco> monochrom, assuming by Z you mean the integers and not zero
11:54:44 <monochrom> integers, yeah
11:54:57 <cement> sqooq: now you've got a function with 2 arguments
11:55:01 <tabaqui> lambdas next to each other are apply next to each other
11:55:09 <tabaqui> *applying
11:55:30 <[exa]> sqooq: what should the code do, anyway?
11:55:30 <sqooq> cement, but it can't take in the + 1, that's not sensical right?
11:55:47 <sqooq> [exa] I'm using this simple example to understand something erisco gave yesterday
11:55:50 <tabaqui> *ghost whispers* remember of stable point functor
11:56:10 <tabaqui> *combinator
11:57:10 * hackagebot yesod-auth-oauth2 0.2.4 – OAuth 2.0 authentication plugins – https://hackage.haskell.org/package/yesod-auth-oauth2
11:57:38 <monochrom> AWizzArd: I say that Liquid Haskell achieves more than dependent types. Because when it comes to type-level arithmetic such as "is m+n >= n?" you do less work in Liquid Haskell than in dependent types.
11:58:04 <sqooq> this is what i'm trying to understand
11:58:05 <sqooq> s = (\a b c -> a : (b ++ [c])) <$> char 'a' <*> s <*> char 'a' <|> pure ""
11:58:42 <AWizzArd> monochrom: is there anything that you can do with dependent types and that you can not do with the LH refined types?
11:59:02 <tabaqui> :t char
11:59:04 <lambdabot> Char -> Doc
11:59:08 <monochrom> No. But in dependent types you (as programmer) work much harder.
11:59:22 <monochrom> Err, no? yes? I don't know.
11:59:30 <tabaqui> what "char" does?
11:59:54 <monochrom> There are things doable in dependent types and not doable in Liquid Haskell.
12:00:10 <sqooq> if that char is successfully parsed it returns Parser (\inp -> [('a', inp)])
12:00:13 <sqooq> tabaqui:
12:00:16 <[exa]> tabaqui: it seems like the one from parsing
12:00:20 <monochrom> At the moment I'm too lazy to think up what and why. But it sounds true.
12:00:36 <sqooq> by successfully parsed, I mean matches
12:00:47 <sqooq> if the input char matches that char it succeeds and returns what I wrote
12:00:47 <monochrom> However, if you thing is doable in Liquid Haskell, you are really better off with Liquid Haskell.
12:01:02 <mizu_no_oto> monochrom: could you create a proof of the 4 color theorem in LiquidHaskell?
12:01:04 <sqooq> I'm literally trying to follow this step by step
12:01:16 <sqooq> left to right (that's how I should do it right?)
12:01:27 <Tuplanolla> > char '\x61' -- This one is for pretty printing.
12:01:29 <sqooq> I Parser (\inp -> [((\b c -> 'a' : (b ++ [c])), inp)]) <*> Parser (\inp -> [((\a b c -> a : (b ++ [c])), inp)])
12:01:29 <lambdabot>  a
12:01:31 <monochrom> I can create a proof in Haskell. :)
12:01:38 <AWizzArd> Anyway, if „many things” can be done in LH this sounds that this is a very interesting tool to study.
12:01:39 <Tuplanolla> Your `char` is different.
12:02:08 <erisco> sqooq, you could chase it step by step but that could be so noisy as to tell you nothing
12:02:39 <sqooq> but then how do I understand it
12:02:47 <sqooq> in my head, it should go on forever
12:02:56 <sqooq> meaning it should successfully parse any list of a's
12:03:00 <sqooq> but no it only goes in doubles
12:03:21 <Spriithy> mnoonan: well I install with stack to have it work with stylish-haskell and with cabal for ghci
12:03:33 <Spriithy> haskero* no stylish sorry
12:03:36 <cocreature> Spriithy: use "stack ghci"
12:03:37 <mnoonan> Spriithy, "stack ghci"
12:03:43 <Spriithy> :AH:
12:03:57 <monochrom> I say (without evidence) that 90% of your use of "types are proposition" is integer linear inequalities such as array bounds check. Liquid Haskell (or anything that consults an SMT oracle) is going to be much less work than honest-to-God dependent types "let me actually write the proof".
12:04:00 <erisco> sqooq, do you know the BNF for that?
12:04:06 <sqooq> here's my code btw 
12:04:07 <sqooq> http://lpaste.net/357390
12:04:18 <AWizzArd> Yes, I would agree.
12:04:20 <Spriithy> so what's the point of cabal then ?
12:04:23 <sqooq> erisco: s ::= a s a | epsilon ?
12:04:29 <Spriithy> if everything goes through stack
12:04:33 <AWizzArd> monochrom: thx for your inputs on that topic.
12:04:34 <[exa]> sqooq: can <*> terminate? (to cause the recursion jump to the other alternative?)
12:04:51 <erisco> sqooq, yes, so tell me the relationship between the number of a's and how many times you use the first production
12:04:56 <mnoonan> Spriithy, stack is really just a fancy wrapper around cabal functionality, plus blessed package sets
12:05:14 <Spriithy> oh well then ^^
12:05:16 <Spriithy> Thank you
12:06:00 <erisco> sqooq, if you need to, start drawing parse trees
12:06:22 <sqooq> erisco, that's a good idea, but even if I figured out how it works to make doubles
12:06:38 <sqooq> the whole point in trying to understand is to figure out how you figured out \inp -> [((\b c -> 'a' : (b ++ [c])), inp)])
12:06:49 <sqooq> or sorry
12:06:56 <sqooq> (\a b c -> a : (b ++ [c]))
12:07:04 <sqooq> as the function that gets mapped
12:07:20 <sqooq> (so that I can do it for my own BNF)
12:07:53 <erisco> easy, do this   :t \f -> let s = f <$> char 'a' <*> s <*> char 'a' <|> pure "" in ()
12:08:48 <sqooq> o lmao
12:08:56 <sqooq> is that how you did yours?
12:08:59 <erisco> :t \f -> f <$> pure (1 :: Int) <*> pure "hello" <*> pure (3.5 :: Float)
12:09:01 <lambdabot> Applicative f => (Int -> [Char] -> Float -> b) -> f b
12:09:25 <erisco> no, I did it in my head, but it is the same thought process
12:09:51 <sqooq> o it makes sense
12:09:57 <sqooq> of course s will be [char]
12:10:58 * hackagebot serokell-util 0.3 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
12:11:46 <erisco> it is also  liftA3 f (char 'a') s (char 'a')   if that helps you think about it
12:11:51 <erisco> :t liftA3
12:11:52 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:13:00 <sqooq> if you happened to do many s, or s* (in bnf or whatever), would it require [[Char]]
12:13:06 <sqooq> ?
12:17:51 <erisco> sqooq, look at the type of many and tell me
12:18:49 <sqooq> the type of s is [char] for sure?
12:19:38 <sqooq> if that's the case [[Char]]
12:19:44 <erisco> s is a parser, but it is building an AST of some type... you get to pick the type
12:19:59 <sqooq> because many :: f a -> f [a]
12:20:05 <sqooq> in this case a is [Char]
12:20:20 <sqooq> so f [char] -> f [[char]]
12:22:13 <sqooq> hmm, strange
12:22:50 <sqooq> my BNF S ::= [ S S S' ] | v, says that S would need type [Char]
12:22:53 <sqooq> sorry
12:22:55 <sqooq> just Char
12:23:11 <sqooq> but I would expect it, since it's recursive, to be [Char] like in your example
12:23:21 <sqooq> S', is [Char]
12:24:01 <erisco> s is a parser and it constructs an AST of some type of *your* choosing
12:24:24 <erisco> you can construct a [Char] or an Integer or () or whatever you want
12:25:36 <erisco> the parser breaks the input into pieces. the 'f' we have been talking about puts those pieces back together in whatever way you want
12:26:28 <erisco> the whole objective of a parser is to turn a list of tokens into an AST
12:28:28 <ClaudiusMaximus> what's the situation with ghc 8.2.1 and cabal?  do i need to do anything special with cabal before/after upgrading ghc from 8.0.2 ?
12:28:56 <erisco> this AST could essentially be the same as the parse tree, but we have freedom to use something else
12:29:35 <erisco> for example if we are parsing an integer by digits the parse tree is going to look like a list of digits, but our AST can be Integer
12:29:53 <erisco> this isn't really a tree anymore, I suppose, but that is the kind of freedom we are afforded here with parser combinators
12:34:29 <Spriithy> if functional languages are that great a compiler making, why is still GCC and all the like written in C or w/e ?
12:34:47 <Spriithy> gcc is C++ actually mb
12:34:57 <erisco> why would someone go back and rewrite gcc in a new language
12:35:03 <[exa]> "it still works"
12:36:02 <erisco> that'd probably be a crazy thing to do because you'd throw everyone else under the bus
12:36:19 <Zowlyfon> The original C compiler was written in ASM
12:36:20 <sqooq> erisco, I get type errors with mine
12:37:00 <erisco> fix em, or pastebin your code and type error
12:37:02 <sqooq> I thought it was because digit would constrain Parser a to Parser Char which wouldn't work with Parser [Char] but converting it into a string didn't work
12:37:16 <sqooq> term = pure (\a b c d e -> a : b : c : (d ++ [e])) <*> char '[' <*> term <*> term <*> many term <*> char ']' <|> makestring digit makestring z = (\y -> y:"") <$> z
12:37:34 <erisco> here I go using pastebin as a verb again...
12:38:00 <sqooq> is that good or do you want me to paste?
12:38:13 <erisco> what is makestring?
12:38:17 <sqooq> semicolon between digit and makestring
12:38:21 <Spriithy> Zowlyfon: well, of course. but did it stay that way ? no :)
12:38:25 <erisco> oh, okay
12:38:33 <Spriithy> because it was simpler to rewrite it in C itself
12:38:44 <sqooq> maybe I wrote makestring wrong
12:38:47 <sqooq> but testing it, it seems to work
12:38:56 <Zowlyfon> imo compilers should be written in the language they are compiling
12:39:16 <erisco> sqooq, just rip out your lambda and stick in f, use the trick I showed you before
12:39:18 <mniip> Zowlyfon, I'm not so sure about the original compiler being written in assembly
12:39:32 <Spriithy> most of them are. Simply because <insert language name here> developers like to program using <same language name>
12:39:45 <erisco> sqooq, you have to pay attention to the argument types
12:39:57 <Tuplanolla> Especially true for Verilog, Zowlyfon.
12:40:03 <Spriithy> was it not written in B ? mniip 
12:40:06 <sqooq> erisco, I did and it said  (Char -> Char -> Char -> [Char] -> Char -> Char) -> ()
12:40:14 <EvanR> most langauges are not suitable for writing compilers in
12:40:23 <mniip> Spriithy, depends on which exact compiler are we talking about
12:40:28 <mniip> the K&R compiler?
12:40:28 <Zowlyfon> mniip: then wikipedia is wrong
12:40:31 <Spriithy> Dennis Richie's
12:40:33 <erisco> :t \a b c d e -> a : b : c : (d ++ [e])
12:40:34 <lambdabot> a -> a -> a -> [a] -> a -> [a]
12:40:46 <sqooq> ugh huh
12:40:49 <sqooq> well shit
12:40:53 <sqooq> lol
12:40:55 <[exa]> Spriithy: it also kindof depends on how hard it is to bootstrap the compiler. sufficient compiler that bootstraps gcc can be ridiculously tiny
12:41:02 <mniip> EvanR, fsvo most. fsvo suitable
12:41:05 <EvanR> and when you designed the language in such a way that it will probably have a horrendously slow implementation... now youre compiler is slow
12:41:19 <EvanR> mniip: i was only thinking of "fsvo language"
12:41:20 <mniip> EvanR, anything that can write bytes to stdout and is also turing complete is suitable
12:41:27 <EvanR> no it is not
12:41:33 <Spriithy> [exa]: yeah right
12:41:34 <mniip> sure is
12:41:37 <mniip> just output an elf file
12:41:47 <mniip> I mean
12:41:49 <mniip> $BFDNAME file
12:41:54 <EvanR> most languages probably cant even do that
12:42:07 <mniip> sure, english cannot
12:42:15 <[exa]> lol
12:42:21 <Spriithy> lol
12:42:29 <EvanR> i think Zowlyfon was talking about large community general purpose languages
12:42:32 <Spriithy> do you have an English compiler in the first place ?
12:42:46 <EvanR> and im thinking about the 100 languages a day you write as part of using haskell
12:42:46 <mniip> only an interpreter
12:42:52 <Spriithy> mniip: do you ?
12:42:57 <EvanR> not suitable for writing a compiler
12:43:09 <mniip> Spriithy, yeah, a hardware accelerated one
12:43:12 <Spriithy> is google Turing complete :thinking: ?
12:43:14 <mniip> it's written in ATGC
12:43:29 <Spriithy> mniip: sounds interesting
12:43:50 <EvanR> uh what does it compile to ?
12:43:51 <mniip> (Adenine, Timine, Guanine and Cytosine)
12:44:04 <Spriithy> ...
12:44:04 <erisco> Spriithy, some people are working on English compilers, or at least a subset of English
12:44:05 <sqooq> erisco, what, how could that last output possibly be Char, it needs to output the string that's been parsed
12:44:19 <Spriithy> erisco: do you mind sharing some link :D ?
12:44:32 <erisco> Spriithy, well, just look at NLP
12:45:05 <erisco> the "compiling" part is contingent on understanding the meaning of the sentence, and that is where all the trouble is
12:45:18 <erisco> after you know the meaning you can implement something to execute it
12:45:36 <sqooq> erisco, o I think I got it. Nvm. I do need to do makestring on digit, but then that changes the initial function, now it's more similar to your example
12:45:43 <erisco> I know augur has a project that is some slant on NLP
12:45:50 <sqooq> (Char -> [Char] -> [Char] -> [[Char]] -> Char -> [Char]) -> ()
12:46:09 <shapr> speech recognition in Haskell?
12:46:25 <shapr> or just NLP text stuff?
12:46:37 <erisco> text
12:47:13 <shapr> ah, ok
12:49:07 <sqooq> erisco: hmm, what the heck could i use for [Char] -> [[Char]] ?
12:49:27 <erisco> sqooq, const []
12:51:33 <sqooq> ?
12:51:45 <sqooq> i'm sorry erisco
12:52:40 <Spriithy> apologies accepted 
12:53:08 <erisco> well, I don't know, whatever you want to do with it... I said const [] because it has the type you specified
12:53:27 <erisco> return works, pure works
12:53:47 <erisco> repeat works
12:54:27 <sqooq> const?
12:54:43 <erisco> you get to choose how recombine the pieces you've parsed ... it is whatever you want
12:54:44 <sqooq> you mean concat?
12:54:50 <sqooq> concat seems to work
12:54:50 <sqooq> (\a b c d e -> a : (b ++ c ++ concat (d ++ [[e]])))
12:54:51 <nomeata> Hi. Does either `stack` or `cabal new-*` have a command `run foo`, where `foo` is an executable defined in my current project, that would rebuid the exectuable if there are any changes (like `stack build`) and then run it (like `stack exec foo`)? I’d like to avoid testing an old version of my binary.
12:54:54 <erisco> no, I mean const
12:55:06 <sqooq> a -> b -> a
12:55:19 <erisco> :t const [] :: [Char] -> [[Char]]
12:55:20 <lambdabot> [Char] -> [[Char]]
12:55:48 <[exa]> nomeata: cabal run?
12:56:14 <[exa]> (maybe I misunderstood the new-* part)
12:56:19 <sqooq> const just ignores the second argument?
12:56:31 <[exa]> sqooq: yep
12:56:45 <erisco> correct, it constructs constant functions
12:57:13 <[exa]> nomeata: oh, parametrized with the executable name, sorry :] getting late here
12:57:36 <sqooq> idk how it would help me in this case
12:57:40 <sqooq> but concat seems to work perfectly
12:57:43 <sqooq> I've done it
12:57:46 <sqooq> I can parse brackets
12:57:50 <sqooq> God bless america
12:57:53 <nomeata> [exa]: well, maybe `cabal run` does the right thing, but that requires all dependencies installed globally; I was hoping for the nix-style variant
12:58:06 <glguy> globally or in a sandbox
12:58:07 <[exa]> there's cabal sandboxes
12:58:20 <erisco> Canada deserves some credit here
12:58:32 <cocreature> nomeata: cabal HEAD has new-run
12:58:52 <glguy> nomeata: there's cabal new-run
12:58:54 <nomeata> cocreature: ah, great. I guess I’ll just have to be patient then :-)
12:59:07 <glguy> nomeata: you don't have to be that patient, it already works
12:59:29 <cocreature> nomeata: tbh if you’re using new-* I would recommend HEAD anyway.
12:59:37 <ClaudiusMaximus> what's the situation with ghc 8.2.1 and cabal?  do i need to do anything special with cabal before/after upgrading ghc from 8.0.2 ?
12:59:49 <cocreature> otherwise you’ll quickly run into major things that are still missing
13:00:34 * monochrom is Canadian! God save the Queen.
13:01:06 <erisco> well, save her proxy i.e. the Governor General
13:01:13 <monochrom> hehe
13:01:27 <sqooq> erisco: are you in Canada
13:01:35 <erisco> yeah, I live here too
13:01:35 <sqooq> I have a lot to thank you for
13:01:53 <monochrom> ooohhh I should stalk erisco.
13:02:08 <sqooq> as well as monochrom, Cale, i can't remember who else
13:02:12 <sqooq> lots though
13:02:15 <sqooq> y'all are great
13:02:16 <monochrom> Cale is also Canadian.
13:02:17 <erisco> entirely possible... I think you're only a few hours away monochrom
13:02:27 <sqooq> I mean I'm not done learning and questioning but I think I've completed the hardest part
13:02:38 <sqooq> of my current project at least
13:03:48 <monochrom> ClaudiusMaximus: If you like unreleased cabal-install 2.x, you can go get it from their github repo directly. Else, I think you can keep using your current cabal-install.
13:04:17 <sqooq> I have a lot of friends in Canada
13:04:28 <sqooq> should be visiting them in december, if I manage to get a job by then
13:04:35 <sqooq> Toronto
13:05:34 <sqooq> ok bye for now
13:06:34 * hackagebot generic-lens 0.3.0.1 – Generic data-structure operations exposed as lenses. – https://hackage.haskell.org/package/generic-lens
13:12:59 <ClaudiusMaximus> monochrom: thanks, will see how it works out to keep my current cabal-install
13:24:15 * hackagebot gotta-go-fast 0.1.3.0 – A command line utility for practicing typing – https://hackage.haskell.org/package/gotta-go-fast
13:40:52 <ClaudiusMaximus> monochrom: seems to work fine :)
13:41:41 <monochrom> Neato.
13:51:10 <Spriithy> hey
13:51:16 <Spriithy> what was the reading file thing earlier today ?
13:51:27 <Spriithy> readFile "foo.txt" >>= ...
13:51:35 <Spriithy> something like that
13:53:00 <EvanR> that exists
13:53:15 <EvanR> :t readFile "foo.txt"
13:53:17 <lambdabot> IO String
13:53:21 <EvanR> :t (>>=)
13:53:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:53:40 <EvanR> ... :: (String -> IO b) -> IO b
13:55:45 <nomeata> I have a project foo.cabal defining a library foo and an executable foo. Is there a way to use `cabal new-repl` to load both components, so that I can use :reload to reload any module in the library, but also use :main to run the program?
13:56:19 <nomeata> (And ideally have ghcid control that?)
13:56:46 <Spriithy> EvanR: earlier today someone showed me a way to extract the String from the IO String given by readFile what would the last function be ?
13:56:52 <Spriithy> other than just its signature
14:00:23 <ab9rf> "extract"?
14:00:57 <ab9rf> what mean you by "extract"
14:02:47 <Spriithy> well, readFile yields an IO String, right.
14:02:56 <Spriithy> so I need to retrieve the actual String
14:03:21 <ab9rf> you can't "retrieve" it, but you can apply a function to the value inside the IO value, yielding a new IO value
14:03:35 <erisco> Spriithy, probably >>=
14:03:40 <ab9rf> most likely this is >>=
14:03:57 <tdammers> "retrieve" is not a thing
14:04:12 <tdammers> you want to do something with the string, probably pass it to some function
14:04:23 <Spriithy> yes, but my function takes a String
14:04:26 <Spriithy> not IO String
14:04:30 <Spriithy> or am I getting this wrong ?
14:04:31 <erisco> :t (>>=)
14:04:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:04:36 <ab9rf> in some cases, you may instead want fmap or liftM
14:04:39 <tdammers> that's fine, but not all functions that take a String qualify
14:04:42 <erisco> :t fmap
14:04:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:04:46 <erisco> use one of those
14:05:29 <ab9rf> :t liftM
14:05:30 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:05:37 <tdammers> the IO works, you have to somehow combine your IO action of type IO String with something else such that the result is also an IO action
14:05:40 <amalloy> i was trying to finally understand Theorems For Free as part of my answer to https://stackoverflow.com/q/45487809/625403. i believe i can successfully apply the algorithm laid out in the paper, but i don't really understand what it means to view a type as a relation, so the results i get just feel like magic. i know functions are a subset of relations, but for non-function types i don't get it
14:06:05 <tdammers> this is on purpose; it makes sure that you cannot run IO actions in a context that isn't an IO action itself
14:06:22 <erisco> once you go IO you can't go back
14:06:51 <ab9rf> at least not safely :)
14:06:53 <Spriithy> you guys are just making it so obscure right now...
14:07:02 <Spriithy> why can't I just get a String out of my file ?
14:07:15 <erisco> because that wouldn't work in Haskell, it'd break everything
14:07:17 <ab9rf> Spriithy: because it's bound inside an IO action and you can't get it out of the IO action
14:07:19 <amalloy> because "read a string from a file" is not a pure operation
14:07:22 <verement> Spriithy: readFile path >>= \str -> …
14:07:36 <ab9rf> but you can push more things INTO the IO action
14:07:53 <ab9rf> and thereby transform that IO action into a different IO action that contains the result you want
14:08:11 <ab9rf> and then once you have an IO action that describes the result you want you execute that IO action and *poof* answers appear
14:08:15 <glguy> Spriithy: This goes into more detail about how IO works https://www.vex.net/~trebla/haskell/IO.xhtml
14:08:28 <mniip> Spriithy, the "contents of the file" isn't a String
14:08:39 <mniip> it's not pure, it's not constant, it's not referentially transparent
14:08:48 <Spriithy> so I have my lexFile :: Path -> [Token]
14:08:59 <mniip> can't do that
14:09:01 <Spriithy> Do I have to turn it into lexFile :: Path -> IO [Token]
14:09:03 <Spriithy> ?
14:09:05 <mniip> yes
14:09:12 <Spriithy> that's absurd >.>
14:09:15 <mniip> do you have a lexString?
14:09:16 <ab9rf> Spriithy: nom it's not
14:09:20 <Spriithy> mniip: I do :)
14:09:21 <ab9rf> Spriithy: it's necessary 
14:09:32 <glguy> Spriithy: No, you just don't understand it yet. Wait until you understand it before you worry about forming opinions
14:09:33 <mniip> then it's just lexFile = lexString <$> readFILe
14:09:35 <erisco> absurdity is exactly what we're avoiding in Haskell by doing this :P
14:09:53 <Spriithy> glguy: Sir, you're right !
14:10:09 <ab9rf> <$> is a synonym for fmap
14:11:29 <mniip> Spriithy, one of the nice properties of haskell is that  f x = f x
14:11:38 <Spriithy> purity
14:11:39 <Spriithy> right
14:11:50 <mniip> and with your proposed lexFile that would be invalid if the file were to change
14:11:53 <Spriithy> if the file changes, f x /= f x
14:11:56 <ab9rf> or if the file were mnissing
14:12:04 <mniip> mniissing
14:12:05 <ab9rf> or the OS decided to freak out and fail
14:12:17 <Spriithy> okay I didn't think this through
14:12:37 <mniip> IO might not be the best solution but it definitely solves some of the problems
14:13:09 <hexagoxel> brittany haskell source formatter candidate package at http://hackage.haskell.org/package/brittany-0.8.0.2/candidate
14:13:31 <hexagoxel> release is planned for tomorrow.
14:13:49 <erisco> well, you've also got those infinite lists... can't remember what that was called
14:13:57 <mniip> yeah those
14:14:17 <glguy> hexagoxel: Is the Paths_ module exposed on purpose?
14:15:00 <Spriithy> okay now, what if... say I have another argument that lexString takes but not lexFile i.e. lexString :: String -> a -> [Token]
14:15:23 <Spriithy> I have to change lexFile to lexFile :: Path -> IO [Token]
14:15:45 <mniip> ?
14:15:46 <hexagoxel> glguy: yes; the exe imports it from the lib
14:15:46 <Spriithy> and lexFile p = (lexString <$> readFile p) 1
14:16:06 <Spriithy> 1 here is just w/e to illustrate
14:16:13 <hexagoxel> also, how else would potential rev-deps get the version if they wanted to print it?
14:16:20 <mniip> Spriithy, not really no
14:16:29 <mniip> you either att ($ 1) <$>
14:16:31 <erisco> well, give it to lexString then... flip lexString 1 <$> readFile p
14:16:34 <ab9rf> it would be (lexString l) <$> readFile p, iirc 
14:16:34 <mniip> you either add ($ 1) <$>
14:16:42 <ab9rf> with a flip, yeah
14:16:54 <mniip> or write it out the long way with a lambda, or do-notation
14:16:56 <mniip> or use flip
14:17:00 <glguy> (\str -> lexString str 1) <$> readFile "path" -- or even better , do-notation
14:17:03 <mniip> or a thing that I like to do,
14:17:10 <mniip> (`lexString` 1) <$> readFile path
14:17:19 <ab9rf> do notation would porbably be clearer, although i like composing functions in cases liek this
14:17:29 <ab9rf> that section notation is nice
14:17:33 <amalloy> or change the argument order of lexString
14:18:11 <ab9rf> do contents <- readFile path; return lexString contents l
14:18:30 <ab9rf> need a $ in the return probably
14:18:49 <mniip> yes you do
14:18:56 <amalloy> lexString :: Int -> String -> [Token]; lexString 1 <$> readFile p
14:19:00 <ab9rf> i'm a bit ragged today
14:19:07 <ab9rf> been doing job interviews, i hate looking for work
14:19:24 <mniip> oh also
14:19:27 <mniip> :t (<&>)
14:19:29 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:19:40 <mniip> no that's not it
14:20:05 <mniip> basically
14:20:07 <Spriithy> okay so in the end, that means my Token list is bound to an IO action
14:20:11 <mniip> lexString <$> readFile p <*> pure 1
14:20:13 <Spriithy> that is triggered when ?
14:20:17 <Spriithy> upon call ?
14:20:32 <ab9rf> Spriithy: when it's evaluated by the RTS when the RTS evaluates the IO action retrined by main
14:20:40 <mniip> executes*
14:20:45 <mniip> important difference
14:20:48 <monochrom> I found an optimizer bug in 8.0.2 that was fixed in 8.2.1.
14:20:49 <ab9rf> yes, executes, pardon me
14:21:04 <Spriithy> executes /= evaluates ?
14:21:07 <ab9rf> Spriithy: yes
14:21:08 <mniip> yes
14:21:11 <Spriithy> how so ?
14:21:15 <mniip> getLine `seq` ()
14:21:18 <mniip> does not read a line
14:21:53 <ab9rf> well, yea, the IO action is "lost"
14:21:55 <monochrom> Yes, Spriithy, in Haskell you have to dissociate the happening of effects (so we call it "execute") from the crunching of numbers and data (so we call it "evaluate").
14:22:14 <ab9rf> it never gets incorporated into the return value
14:22:25 <mniip> ab9rf, uh that has little to do with it
14:22:34 <mniip> Spriithy, you can imagine IO as a recipe. A list of instructions for the RTS
14:22:40 <mniip> the recipe itself is a pure value
14:22:41 <monochrom> Because the data crunching side enjoys lazy evaluation but the effectful side follows standard imperative programming (code order says effect order).
14:22:45 <mniip> referentually transparent and all
14:22:58 <mniip> first you evaluate the recipe as a value, then RTS executes it by reading the instructions
14:23:32 <mniip> getLine is a recipe to read a line
14:23:38 <Spriithy> when would `Prelude> drop 2 "foo"`  be executed vs. evaluated ?
14:23:38 <mniip> getLine `seq` () evaluates the recipe
14:23:43 <EvanR> Spriithy: if your function takes a string, then use it where the ... was ? it has type String -> IO b
14:23:51 <EvanR> you jsut need to return an IO something
14:23:56 <mniip> Spriithy, your code contains no IO hence it's not "executed"
14:23:59 <mniip> merely evaluated
14:24:12 <mniip> however ghci adds a "print" which is an IO action which is executed
14:24:17 <Spriithy> are IO the only executed actions so to say ?
14:24:26 <mniip> by definition
14:24:35 <Spriithy> oh I think I get it
14:24:39 <mniip> (well actually, STM)
14:24:46 <EvanR> the only action to be executed is... main :: IO () 
14:24:54 <mniip> yeah
14:24:56 <Spriithy> evaluation happens internally and execution is the actually happening of things
14:24:58 <Spriithy> with values
14:24:58 <mniip> main is the toplevel recipe
14:25:24 <mniip> composed of the entire instructions for the operation of the whole program
14:26:13 <Spriithy> hmm
14:26:23 <mniip> Spriithy, evaluation is ultimately triggered by IO
14:26:31 <EvanR> the fact the the right argument to >>= is a function allows the next thing to happen to be not-predetermined
14:26:36 <Spriithy> mniip: let's say main = id
14:26:37 <mniip> hPutChar evaluates the Char that it is putting
14:26:41 <Spriithy> then nothing happens, right ?
14:26:46 <mniip> Spriithy, that's invalid
14:26:59 <EvanR> id is a function, main is not
14:27:07 <Spriithy> :t main
14:27:08 <lambdabot> error:
14:27:08 <lambdabot>     • Variable not in scope: main
14:27:08 <lambdabot>     • Perhaps you meant ‘min’ (imported from Data.Ord)
14:27:12 <EvanR> main :: IO ()
14:27:13 <mniip> main :: IO a
14:27:16 <Spriithy> Ohhh
14:27:23 <mniip> a discarded
14:27:38 <Spriithy> I would've thought main :: [String] -> IO ()
14:27:51 <mniip> nope, that's getArgs :: IO [String]
14:28:05 <ab9rf> nope, main is just IO a, for any a, and the type is discarded
14:28:07 <EvanR> thats one of many things that could be considered input to the program
14:28:08 <ab9rf> most people do IO ()
14:28:13 <Spriithy> in Haskell, one does not `call` main, one evaluates
14:28:21 <ab9rf> main is not a function
14:28:25 <mniip> first evaluates main then executes it
14:28:41 <Spriithy> mniip: now I see the difference 
14:28:44 <Spriithy> thanks
14:28:53 <mniip> I mean, obviously, there are IO-typed *expressions* that do not terminate when evaluating
14:29:03 <mniip> the RTS gets stuck trying to figure out the next step in the recipe
14:29:18 <mniip> as opposed to a recipe that tells it to loop infinitely
14:29:30 <EvanR> main :: [String] -> IO () is a valid way to do it, but they didnt do it that way
14:29:58 <EvanR> the RTS could first produce a string of arguments, then pass it into the main *FUNCTION* to get an action, which is then executed to start the show
14:30:33 <mniip> yeah, why not main :: [String] -> [(String, String)] -> Map AuxvKey Word -> IO ()
14:30:48 <ab9rf> heh
14:30:51 <EvanR> that is how it is in MOOs
14:30:58 <EvanR> you get the args in every which way
14:31:10 <ab9rf> argle bargle
14:31:20 <mniip> MOOs?
14:31:35 <EvanR> :: Verb -> Object -> Maybe IndirectObject -> Maybe (Prepsition, Object) -> ....
14:31:42 <Tuplanolla> :t (getArgs >>=) -- To convert your `main` function into our `main` action, Spriithy.
14:31:44 <lambdabot> error: Variable not in scope: getArgs :: m a
14:31:48 <ab9rf> which makes the RTS prep the arguments every possible way, even if the function has no interest in the arguments
14:32:04 <mniip> ab9rf, tbf the libc already does that
14:32:11 <Tuplanolla> :t (System.Environment.getArgs >>=)
14:32:12 <lambdabot> ([String] -> IO b) -> IO b
14:32:15 <ab9rf> mniip: when you run on linux, at least
14:32:18 <mniip> it copies the argv and auxvec
14:32:49 <mniip> environ especially so because it's mutable
14:33:28 <ab9rf> mniip: not all platforms provide an argument vector of strings. on ms-dos it's just one unparsed string
14:33:44 <ab9rf> in some platforms there's no mechanism at all for passing args
14:34:06 <mniip> right
14:34:15 <mniip> in some cases you don't even get a stack
14:34:18 <ab9rf> the approach in haskell is platform-agnostic
14:34:35 <ab9rf> it places no expectations on what the platform will provide
14:34:52 <mniip> (tbh the haskell runtime places too many expectations on the platform)
14:35:02 <mniip> (way too many)
14:35:07 <ab9rf> heh, now that's true enough
14:35:26 <EvanR> such as gigs of ram? :)
14:35:27 <ab9rf> you have to establish expectations somewhere
14:35:37 <mniip> EvanR, not really
14:35:52 <EvanR> such as OS either provided by megacorp 1 megacorp 2 or linus torvalds
14:35:54 <ab9rf> evan: i've managed to write some really ram-tight code in haskell
14:36:34 <ab9rf> ghc certainly expects your OS to hew pretty closely to specific flavors of POSIX compability
14:36:39 <mniip>  weird address space, lazy page mapping, weird signals, threading (!), crazy advanced dynamic linker, crazy advanced binary format
14:36:48 <monochrom> Yeah, a tera, not just a gig. :)
14:37:00 <ab9rf> i hate intel signalling
14:37:13 <ab9rf> but i hate pretty much everybody's signalling
14:37:28 <mniip> having written a sandbox for ghc.... I've battled most of those
14:37:44 <mniip> oh yeah and then there's unbounded memory
14:37:57 <ab9rf> i learned how to write async code in VAX/VMS
14:38:17 <ab9rf> and switching from that system to the rudimentary nonsense that are unix signals was... painful
14:38:22 * masaeedu[m] sent a long message: masaeedu[m]_2017-08-03_21:38:00.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/hSGPKDiBmKaIIzWCYHcuTiAG>
14:38:29 <mniip> I'm yet to find a way to tell GHC that *THIS AMOUNT OF MEMORY IS THE ULIMIT, perhaps consider outofheaping before RTS is unable to allocate a buffer for putchar???*
14:38:41 <masaeedu[m]> So that `:t undefined :: Flattened [[[Int]]]` is `[Int]`
14:38:48 <monochrom> ab9rf: How is VMS like on this aspect?
14:38:55 <masaeedu[m]> How do I implement `flatten :: a -> Flattened a`
14:39:10 <monochrom> (Feel free to continue in #haskell-offtopic at your discretion!)
14:39:17 <ab9rf> monochrom: it's been 30 years, and my memory is poor
14:39:23 <mniip> masaeedu[m], you need a typeclass
14:39:24 <ab9rf> monochrom: moving to -offtopic :)
14:39:52 <masaeedu[m]> mniip: What does the typeclass represent?
14:40:01 <mniip> masaeedu[m], a Flatten-able type
14:40:17 <masaeedu[m]> I was ultimately hoping to abstract out even the `[]` from `Flattened` so I could just have `b :: * -> *`
14:40:27 <mniip> though hm
14:40:30 <mniip> might be issues
14:41:02 <mniip> yeah I think you need both a typeclass and *overlapping*
14:41:27 <masaeedu[m]> Is "overlapping" an extension of some sort?
14:41:27 <mniip> or, at least some auxiliary families
14:41:29 <mniip> yes
14:41:35 <mniip> you're getting into many extensions here
14:42:11 <erisco> instance Flattened (f a) => Flattened (f (f a))
14:42:11 <masaeedu[m]> That's fine, this isn't production code or something
14:42:32 <Tuplanolla> :t join -- If only we had a simpler mechanism for flattening things...
14:42:33 <lambdabot> Monad m => m (m a) -> m a
14:43:22 <mniip> masaeedu[m], I'm trying to figure out the least...ugly solution
14:43:31 <masaeedu[m]> The idea is to have `:t flatten [[[1,2],[3]],[[4]]]` result in `[Int]`
14:43:47 <masaeedu[m]> Which I can already get with `flatten :: [a] -> Flattened [a]; flatten = undefined`
14:43:53 <masaeedu[m]> But I have no idea how to implement it
14:44:06 <mniip> you absolutely cannot implement it without a constraint
14:44:15 <masaeedu[m]> on `a`?
14:45:16 * hackagebot normalization-insensitive 2.0.1 – Normalization insensitive string comparison – https://hackage.haskell.org/package/normalization-insensitive
14:45:27 <mniip> yes
14:46:23 <masaeedu[m]> What would I constrain it to? I don't actually care what `a` is, I just want to project it through `Flattened`
14:46:28 <enthropy> seems like mniip's class won't reference the definition of Flattened
14:48:00 <masaeedu[m]> I guess you could have some class on flattenable types using fundeps
14:48:27 <masaeedu[m]> Where the implementation must describe how to unnest itself
14:48:38 <mniip> uhuh
14:48:42 <masaeedu[m]> E.g. for lists the implementation would probably use concat
14:48:44 * mniip gets a machien to test
14:49:13 <mniip> basically this but it's untested http://lpaste.net/3342423479088578560
14:49:36 <masaeedu[m]> Has anyone else noticed language extensions don't work in repl.it
14:49:45 <masaeedu[m]> Is there an equivalent where they actually work?
14:49:49 <mniip> s/x/a/
14:50:32 <erisco> type classes and base cases don't mix
14:50:44 <Axman6> they sort of do, see printf
14:51:09 <masaeedu[m]> Can you pipe from cat to ghci?
14:51:14 <masaeedu[m]> lol, I'm too lazy to make a new file
14:52:17 <Spriithy> it's useless ?
14:52:23 <Spriithy> ghci <filename>
14:52:26 <Spriithy> will do it for you
14:53:22 <Axman6> masaeedu[m]: :set -XExtention in ghci
14:53:31 <monochrom> language extensions can work in ghci. You just have to know the right flags.
14:53:32 <masaeedu[m]> Yeah, but there is no filename. I guess I can just use process substitution
14:53:44 <Spriithy> ah, what would you `cat` from then ?
14:53:58 <masaeedu[m]> When you just run cat it takes things on stdin
14:54:05 <masaeedu[m]> Which I use all the time to just copy paste crap into
14:54:13 <Spriithy> oh ok.
14:54:21 <masaeedu[m]> You can set it up to pipe to wherever you please
14:54:23 <mniip> hmm it doesn't work
14:54:40 <mniip> masaeedu[m], you can do the same without any cat
14:54:42 <mniip> cat abuse
14:55:17 <mniip> basically the issue is exactly as I'd expect
14:55:41 <mniip> if you have [a] it's not known whether a ~ [b]
14:55:56 <monochrom> https://unix.stackexchange.com/questions/382535/keyboard-set-to-cat-mode
14:56:15 <masaeedu[m]> mniip: Not on Windows unfortunately
14:56:41 <masaeedu[m]> You're not typing into exactly a tty in Powershell
14:56:50 <masaeedu[m]> So some things, like its reactions to newlines, are weird
14:56:57 <mniip> ah
14:57:01 <mniip> powershell...
14:57:04 <masaeedu[m]> Running cat from cygwin makes it exactly identical
14:57:33 <masaeedu[m]> Would you have a pastebin of your latest version?
14:57:48 <glguy> mniip: I annotated your paste with what I had
14:57:56 <masaeedu[m]> Having some trouble figuring out what extensions I need besides TypeFamilies
14:58:09 <glguy> masaeedu[m]: I included the extensions
14:58:15 <glguy> should be the about the same
14:59:00 <masaeedu[m]> Thanks
15:03:18 <erisco> see, we need closed classes
15:04:09 <masaeedu[m]> glguy: `:t flatten [[[1,2],[3]],[[4]]]` seems correct (`=> [Elem t (IsList t)]`)
15:04:23 <masaeedu[m]> But I guess the implementation is borked
15:04:33 <glguy> It's fine, you just need to specify th type of the numbers
15:04:55 <masaeedu[m]> Ah
15:08:30 <erisco> use a boolean to test for the base case... good idea
15:14:36 <masaeedu[m]> So because we're doing all this juggling in the type level
15:14:47 <masaeedu[m]> We need an extra type level function to tell us when we're done
15:14:53 <masaeedu[m]> i.e. what the base case is
15:17:14 <masaeedu[m]> What does `instance IsList a ~ 'False` mean?
15:17:28 <Axman6> I don't think that makes sense
15:17:51 <Axman6> unless IsList is not the OverloadedLists extension class
15:18:04 <masaeedu[m]> Sorry, might have copied a nonsensical chunk
15:18:11 <masaeedu[m]> `instance IsList a ~ 'False => Flatten a 'False where ...`
15:18:33 <masaeedu[m]> `IsList` is a type family
15:18:39 <Axman6> right, looks like that's a type family
15:18:40 <Axman6> yeah
15:20:20 <masaeedu[m]> My understanding was that a type family is a type-level function
15:20:43 <masaeedu[m]> So you can have the type `IsList [10]` is equivalent to the type `'True`
15:20:57 <masaeedu[m]> whoops, `[Int]`
15:21:29 <masaeedu[m]> And the type `IsList Int` is equivalent to `'False`. What does it mean to have an instance of a type family?
15:23:31 <erisco> glguy, that is such a good idea that I can now implement the "dot dot dot" operator from the other day
15:23:50 <glguy> masaeedu[m]: If you were looking for more things to learn, this one tries to hide the type family behind a type synonym http://lpaste.net/6533924242642173952
15:24:03 <glguy> and avoid repeated uses of concat
15:24:26 <masaeedu[m]> glguy: I'm barely absorbing your 10 line snippet as is, but thanks
15:24:29 <masaeedu[m]> I'll take a look
15:24:52 <jle`> masaeedu[m]: it's a constraint, there
15:25:04 <jle`> masaeedu[m]: the general syntax of typeclass instances is:
15:25:16 <masaeedu[m]> Oh, is `~` type-level "equals"?
15:25:16 <jle`> instance (some constraints) => MyClass (the instance)
15:25:28 <jle`> and (IsList a ~ 'False) is one of those constraints
15:25:35 <masaeedu[m]> Sweeet
15:25:38 <jle`> yeah, ~ is a constraint for type equality
15:25:38 <masaeedu[m]> Makes sense
15:26:14 <jle`> > let f :: (a ~ Int) => a -> a; f x = x + 1 in f 10
15:26:15 <lambdabot>  11
15:26:22 <jle`> :t let f :: (a ~ Int) => a -> a; f x = x + 1 in f 10
15:26:24 <lambdabot> Int
15:26:35 <jle`> it is admittedly a little confusing without the parentheses
15:26:38 <jle`> in your specific situation
15:26:40 <erisco> glguy, check this one out http://lpaste.net/357393
15:26:40 <masaeedu[m]> Interesting
15:26:50 <masaeedu[m]> Why would you do that rather than just inlining `Int` for `a`>
15:27:01 <erisco> someone was asking for an operator that was ., .:, .::, and so on all in one
15:27:38 <erisco> interestingly, (+) ... (+) :: Int -> Int -> Int -> Int, and  (+) ... (+) ... (+) :: Int -> Int -> Int -> Int -> Int, and so on
15:28:18 <erisco> because it fully applies the function, it takes the previous sum plus a new number
15:28:31 <erisco> not that bad of an operator maybe
15:28:34 <masaeedu[m]> :t let f :: Int -> Int; f x = x + 1 in f 10
15:28:36 <lambdabot> Int
15:28:57 <jle`> masaeedu[m]: nobody would actually type out my f, heh
15:29:00 <jle`> just an example here
15:29:11 <jle`> for a situation where you might like ~, the one you gave is already a good example
15:29:31 <jle`> just showing that ~ can be used anywhere a constraint is expected, since it's a constraint :)
15:29:42 <masaeedu[m]> Yup, just trying to play with it to understand; the example is very helpful
15:29:45 <Axman6> masaeedu[m]: IIRC it's a trick that's used to make the constraint resolution happen at the use site, not in instance resolution. in lens, you might see instance (a ~ b, a ~ c) => Ix (a,b,c) where, so that you can index into a tuple that when _used_ must have all the types the same
15:29:54 <jle`> (~) :: (a :: k) -> (b :: k) -> Constraint
15:30:10 <jle`> oh nvm
15:30:11 <jle`> :k (~)
15:30:13 <lambdabot> k -> k -> Constraint
15:30:14 <jle`> i'm silly
15:30:20 <glguy> erisco: turns out pretty short, doesn't it?
15:30:43 <masaeedu[m]> Axman6: Yeah, I guess that's a little bit like forall is for type holes
15:30:48 <erisco> glguy, the implementation? well I didn't expect it to be long, I just didn't think it possible because there didn't seem to be a way to have a base case
15:30:49 <masaeedu[m]> Except for constraints
15:31:09 <erisco> glguy, but leveraging the closed type family to produce a boolean which can select the correct instance... that is smart
15:31:15 <erisco> clunky as hell, but smart
15:32:06 <masaeedu[m]> By "closed type family" do you mean total wrt its domain?
15:32:31 <glguy> masaeedu[m]: I don't know if it's a feature or a bug, but check out: flatten True == [True]
15:32:50 <erisco> no, it means the cases listed are exhaustive
15:33:05 <erisco> versus an open type family where cases can be added willy nilly
15:33:28 <erisco> so with the closed type family you get to try the cases in order, which is how you can decide if something is a particular type or not
15:33:34 <glguy> closed type families can still get stuck
15:33:35 <masaeedu[m]> glguy: Yeah, it's kind of flatmappish
15:33:57 <erisco> I didn't mean exhaustive as in it is total on the domain ... bad wording
15:34:10 <erisco> I meant that all the cases you see as part of the definition are all there is
15:34:27 <glguy> consider, type family Stuck a where ; [] :: [Stuck Bool]
15:34:33 <dolio> Axman6, masaeedu[m]: The important part is that `instance (a ~ T2) => C (T1 a)` will cause a 'C t' constraint to be discharged whenever GHC knows that `t` is `T1 u` for some u.
15:35:02 <dolio> But `instance C (T1 T2)` will only discharge when it knows that `t` is `T1 T2`.
15:35:25 <erisco> a closed type family is more like our functions on values
15:35:27 <dolio> It cannot use the fact that it starts with T1 to know that u is T2 in the latter case.
15:35:49 <masaeedu[m]> dolio: Does "discharge" mean it admits the type?
15:36:13 <dolio> It means it selects that instance, and turns the obligation into obligations for whatever the context is.
15:36:49 <dolio> So `C (T1 z)` in the context turns into `z ~ T2` in the context.
15:38:35 <erisco> glguy, ... has the sort of strange case of f ... x = f x when x is not a function
15:47:52 <trem483> shapor
15:47:55 <trem483> shapr
15:49:05 <ab9rf> shapl
16:01:55 <mniip> shapMap
16:31:46 * hackagebot cabal-test-quickcheck 0.1.8.1 – QuickCheck for Cabal – https://hackage.haskell.org/package/cabal-test-quickcheck
16:31:51 <monochrom> shapl'
16:33:05 <Tuplanolla> :t shap
16:33:07 <lambdabot> (Foldable t, Monoid m) => t m -> m
16:33:21 <monochrom> heehee
16:34:06 <Tuplanolla> That actually reminds me...
16:34:10 <Tuplanolla> @hoogle Shapable
16:34:10 <lambdabot> Data.Array.CArray class Shapable i
16:34:10 <lambdabot> module Data.Ix.Shapable
16:34:10 <lambdabot> Data.Ix.Shapable class Shapable i
16:35:10 <Zemyla> I wish Data.Array had indexM like Data.Vector does.
16:35:53 <kadoban> :t indexM
16:35:54 <lambdabot> error:
16:35:54 <lambdabot>     • Variable not in scope: indexM
16:35:54 <lambdabot>     • Perhaps you meant one of these:
16:36:06 <Zemyla> Though is that even something that could be added to the current Haskell standard?
16:49:02 * hackagebot mbtiles 0.4.0.0 – Haskell MBTiles client. – https://hackage.haskell.org/package/mbtiles
17:04:41 <mjhoy> hmm. does lpaste still work?
17:05:34 <EvanR> sort of
17:05:34 <mjhoy> i am running into a GHC error: https://gist.github.com/mjhoy/4c86dfdaae47178a9992acff6ce09902
17:07:43 <mjhoy> i'm having trouble reproducing it outside of my project. has anyone seen this before? (I can fix it by removing a typeclass constraint, but I was curious to perhaps report a bug.)
17:08:24 <MarcelineVQ> panic is always a bug, please report :>
17:09:23 <jle`> finding ghc unique panics should be the basis of a cryptocurrency
17:09:29 <jle`> *unique ghc panics
17:09:38 <koala_man> haha
17:10:06 * EvanR greps for "panic" and becomes rich!!!
17:11:14 <jle`> well the source code that produces it would be the thing on the blockchain
17:11:48 <jle`> not the actual panic
17:17:23 <pacak> "Simplifier ticks exhausted" - sometimes you can get away with increasing simplifier ticks limit.
17:18:11 <pacak> Plus try newer ghc - it might be fixed there already.
17:25:31 * hackagebot call-haskell-from-anything 1.1.0.0 – Call Haskell functions from other languages via serialization and dynamic… – https://hackage.haskell.org/package/call-haskell-from-anything
17:43:17 <Nickaqui> hi
17:54:31 <EvanR> whats worse, doing a bunch of bigish integer math with doubles, or doing a bunch of fractional number crunching with integer-backed rationals/fixedpoint/something
17:56:08 <Cale> The former
17:57:06 <ClaudiusMaximus> (maybe if you can port gmp to use the doubles for integer implementation it wouldn't be so bad - i've successfully compiled gmp to js using emscripten...)
17:57:38 <EvanR> compiled gmp to js as-is ?
17:58:21 <ClaudiusMaximus> yeah mostly, the trick is to use 32bit environment otherwise it all goes pear shaped (and then pray that clang compiles in 4GB)
17:59:50 <ClaudiusMaximus> https://stackoverflow.com/questions/41080815/compiling-gmp-mpfr-with-emscripten has some notes
18:29:41 <trevortknguyen[m> How should a high school student get into type system research?
18:29:47 <trevortknguyen[m> Asking for a friend
18:30:14 <joe9> I have a haskell program which is bringing my system to a halt. I want to profile it to figure out the issues. I did stack build --profile, to build the executable. I started the executable using +RTS -N -p -sstderr -RTS. When I ^C out of the program, I get an empty .prof file.
18:30:28 <joe9> Any suggestions on how to get a proper .prof file, please?
18:30:45 <joe9> I cannot let the program continue to completion as it would just crash my system.
18:31:12 * arahael notes that this isn't the halting problem.
18:31:40 <EvanR> lol
18:31:52 <EvanR> this is merely *a* halting problem
18:32:11 <ClaudiusMaximus> joe9: heap profiles (.hp, for memory usage) are written while the program is running, and may be more useful than time profiles (.prof)
18:32:38 <joe9> ClaudiusMaximus: got it, need -h I guess for that. Thanks.
18:33:24 <ClaudiusMaximus> there are various -h options, iirc -hT works without needing to compile for profiling, and gives memory usage per type
18:34:17 <joe9> ClaudiusMaximus: I can recompile for profiling. Thanks for the hint about -hT.
18:35:47 <sqooq> hiya
18:36:15 <sqooq> what does monad offer that applicative doesn't
18:36:19 <sqooq> ?
18:37:20 <ClaudiusMaximus> sqooq: join, or other equivalent functionality like (>>=)
18:37:27 <ClaudiusMaximus> :t join
18:37:29 <lambdabot> Monad m => m (m a) -> m a
18:37:39 <sqooq> ok
18:37:47 <verement> sqooq: the behavior of one action can depend on the result of another
18:38:02 <sqooq> because it seems at least with the code I just wrote, that I could directly translate my do block into a linking of <*>
18:38:15 <EvanR> often yeah you can
18:38:26 <ClaudiusMaximus> there's an -XApplicativeDo i think
18:38:40 <EvanR> and then outsiders will complain that "haskell has too many operators"
18:38:44 <sqooq> it it bad that I'm doing it monadically when I don't need to?
18:39:04 <c_wraith> "outsiders"?  Next you'll be calling them "the unenlightened" or something.
18:39:08 <sqooq> will I gain performance or something by using applicative which isgood enough for my case
18:39:16 <sqooq> ?
18:39:19 <EvanR> the forgotten ones
18:39:23 <EvanR> lol
18:39:43 <c_wraith> sqooq: in some cases <*> can give performance benefits, but it's uncommon
18:39:44 <glguy> No, using Applicative operators isn't an automatic performance win
18:39:56 <sqooq> ok
18:39:58 <c_wraith> sqooq: and it depends on the type you're using it with
18:40:04 <sqooq> Parser
18:40:34 <glguy> that doesn't help
18:40:52 <cranej> clear
18:40:55 <glguy> Whether or not it has a performance impact depends on the specific type
18:41:00 <c_wraith> sqooq: as to your original question about what the extra part you get from Monad is, https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative/17412969#17412969  might be of use.
18:44:23 <sqooq> I see the difference
18:44:37 <sqooq> hmm maybe I wouldn't be able to write what I have with applicative only
18:44:47 <sqooq> I was thinking I could do something with \_ ->
18:44:53 <sqooq> but maybe not
18:45:05 <EvanR> why does pseudocode always use := and nothing else does
18:45:18 <sqooq> it looks like a lil skull
18:45:24 <sqooq> or spider
18:45:41 <arahael> EvanR: Pascal (Delphi) Syntax!
18:46:06 <sqooq> Is there something lower than monad?
18:46:11 <ab9rf> := has been used to signify assignment for a LOOOOOOOOOOOOOONG time
18:46:11 <sqooq> or higher than Functor?
18:46:15 <ab9rf> sqooq: "lower"?
18:46:19 <ab9rf> what means lower/higher?
18:46:32 <sqooq> like Monad subset of Applicative subset of Functor, no?
18:46:54 <sqooq> or is it the other way around
18:46:55 <ab9rf> ah more general/more specific?
18:46:59 <sqooq> ye
18:47:03 <EvanR> := ive seen elsewhere but not in programming
18:47:07 <mniip> sure you can construct an infinite hierarchy of useless typeclasses
18:47:20 <mniip> all proper subsets of eachother
18:47:23 <ab9rf> Monad has subclasses
18:47:29 <mniip> you have to be more specific
18:47:35 <ab9rf> MonadPlus atually has some utility
18:48:39 <sqooq> MonadPlus is almost identical to Alternative right?
18:48:53 <mniip> it closes the lattice
18:49:02 <mniip> of Applicative/Monad/Alternative
18:49:06 <ab9rf> MonadPlus is just a Monad that is also a Monoid
18:49:18 <mniip> MonadPlus is actually stronger
18:49:28 <mniip> it's a continuous family of monoids
18:49:43 <ab9rf> mm, yeah, that's not right at all, i'm not drunke nough yet i guess
18:49:52 <EvanR> "the loaded 'just'"
18:50:02 <mniip> in the sense that zero and mappend are universal in the inner type
18:50:04 <ab9rf> i'm not aware of any useful generalization of Functor just now, but i'm sure there is one
18:50:45 <sqooq> category theory probably has it worked out lmao
18:51:01 <EvanR> is this like asking for a generalization of magma
18:51:03 <ab9rf> i'm not really that knowledgeable of category theory
18:51:16 <EvanR> a binary operation .... 
18:51:24 <EvanR> thats isnt necessarily a binary operation
18:51:37 <EvanR> it can be anything
18:52:10 <EvanR> a morphism that isnt nec a morphism
18:52:51 <EvanR> of categories
18:53:03 <mniip> EvanR, class C (f :: * -> *) where {} is actually a generalization of functor
18:53:25 <mniip> just like a functor is a mapping of types and a mapping of morphisms,
18:53:29 <mniip> this is a mapping of types period
18:54:06 <mniip> EvanR, as for magmas, perhaps try digging into the groupoid direction?
18:54:08 <mniip> magmeoid?
18:54:26 <EvanR> magmaoid... what in the world
18:54:27 <mniip> that's probably the most boring structure
18:55:40 <mniip> now, slowly add homotopies
18:56:39 <EvanR> a groupoid, every morphism is an isomorphism, has a "reversal"... category, every object has an identity arrow... semigroupoid, valid composition is assoc... magmaoid, you just have valid compositions
18:57:00 <tarps> i saw an article on linear typing in scala, seemed interesting. anyone using it?
18:57:41 <EvanR> thats actually some structure left
18:57:58 <ab9rf> EvanR: at some point you just have to call it a blob and walk away
18:58:10 <mniip> you mean that if f . (g . h) exists then (f . g) .h must also?
18:58:33 <EvanR> sounds like a theorem
18:58:45 <ab9rf> mniip: please provide a proof
18:58:58 <mniip> ab9rf, it's an axiom/definition proposition
18:59:05 <ab9rf> meh, that's cheating!
18:59:07 <mniip> EvanR, then what
18:59:25 <EvanR> mamgaoid, you have a typed composition operation with no laws
18:59:47 <mniip> why is it typed
18:59:49 <EvanR> by analogy between magma and groupoid
18:59:55 <EvanR> er mamga and semigroup
19:00:02 <ab9rf> EvanR: a class of objects and some binary operation on those objects?
19:00:19 <EvanR> a magma is a magmaoid with one object
19:00:19 <ab9rf> that seems rather general :)
19:00:27 <EvanR> lol
19:00:34 <mniip> the typed structure of a groupoid arises precisely from the existence of composition axioms
19:00:45 <mniip> not sure if the same can be demonstrated in a magmaoid
19:00:50 <ab9rf> going to be finding mamgaoids under rocks and in the toilet tank at this rate
19:01:06 <EvanR> the composition operation comes with rules for when it must be defined, then you have the assoc law
19:01:27 <mniip> with assoc that's semigoupoid
19:01:34 <EvanR> right
19:01:40 <EvanR> drop that and its a magmaoid
19:01:48 <mniip> ok, when must composition be defined
19:02:10 <EvanR> compose :: (b -> c) -> (a -> b) -> (a -> c)
19:02:14 <tarps> its crazy to think that f . g doesn't necessarily exist if f . (g . h) does
19:02:25 <mniip> in the definition of a groupoid/semigroupoid that I have in mind morphisms don't actually have domains and codomains intrinsically
19:02:28 <ab9rf> nah, not at all crazy
19:02:32 <mniip> it's a fact that follows as a theorem
19:02:45 <ab9rf> i can imagine all sorts of silly things
19:02:48 <EvanR> theres different ways to define categories
19:02:49 <ab9rf> almost all of which are untrue
19:03:00 <mniip> tarps, I can almost imagine how that might work
19:03:16 <EvanR> maybe theres not one essentially unique version of magmaoid
19:03:32 <tarps> i just dont get how morphisms woudl compose in that manner
19:03:36 <tarps> im a category theory noob though
19:03:43 <tarps> like it seems obvious it would work
19:03:54 <EvanR> if the types match, composition must occur
19:04:01 <mniip> I'm thinking of levity polymorphism
19:04:07 <mniip> and calling conventions
19:04:12 <tarps> EvanR: that's what i'm thinking but supposedly it's not true?
19:04:13 <mniip> and their effects on function composition
19:04:25 <EvanR> shrug
19:04:31 <tarps> i mean let's say we just assume it's a category theory thing
19:04:33 <tarps> without bottoming or w/e
19:04:45 <mniip> actually system calls might just be a magmaoid
19:05:27 <mniip> except there's not many objects in the x86 world
19:06:27 <mniip> ok
19:06:30 <mniip> next comes
19:06:31 <mniip> ringoid
19:06:33 <tarps> whats the x86 category lol
19:06:39 <mniip> and fieldoid
19:06:39 <tarps> just 64 bit integers?
19:06:44 <mniip> tarps, kind of
19:06:47 <EvanR> fields... gross
19:07:01 <tarps>  man this channel is so much more hospitable than math
19:07:10 <tarps> ##math
19:07:38 <mniip> ok, so in a ringoid you have two compositions
19:07:55 <Cale> tarps: is it?
19:07:59 <mniip> one thing I see right away is that the compositions must satisfy the, I think, frobenius identity?
19:08:10 <Cale> tarps: Let me know if you see something questionable going on there
19:08:22 <sqooq> idk how to proceed with myself. I have a function already defined that takes a tree and a list of instructions to a leaf and returns an integer. I have a parser that parses a string and makes a tree, but I'm not sure if I should find the locations of the leaves separately, or build it into the parser.
19:08:23 <tarps> Cale: nothing questionable just your average IRC snark
19:08:40 <mniip> no, that's not the name
19:08:52 <mniip> Cale, I've got that feeling as well
19:09:01 <sqooq> Basically I want to do function . parser input
19:09:18 <EvanR> might not be the best place to call out ##math 
19:09:20 <mniip> I wouldn't say that it's bad or inappropriate. But it just feels a bit more strict and thus hostile
19:09:38 <tarps> yeah agreed with mniip 
19:09:45 <erisco> sup haters
19:09:51 <sqooq> sup erisco
19:09:57 <sqooq> thanks again
19:09:59 <EvanR> sip haterade
19:10:08 <mniip> erisco, basically,
19:10:12 <mniip> magmaoids
19:10:23 <sqooq> I got my parser to make a tree automatically from my bracket notation, all by myself this time
19:10:31 <EvanR> C* algebroid
19:10:31 <erisco> get some ointment for that
19:11:01 <erisco> sqooq, well done
19:11:03 <tarps> just saying haskell is probably more interesting to me to begin with because i mostly care about category theory as it relates to computing anyways
19:11:58 <sqooq> any thoughts on my predicament?
19:12:05 <arahael> Is "Category theory" fairly specific to Haskell, though?
19:12:17 <erisco> not remotely
19:12:45 <tarps> arahael: maybe not but it's probably useful based on the articles i read
19:13:02 <mniip> EvanR, latticeoid
19:13:10 <c_wraith> arahael: haskell only uses a very limited version of Category theory.  The idea of a functor is *far* broader than what haskell calls a Functor, for instance.
19:13:13 * mniip . o O ( cokmett )
19:13:36 <c_wraith> does a cokmett take haskell libraries and produce category theory?
19:14:20 <tarps> what's a kmett/cokmett
19:14:28 <mniip> https://cokmett.github.io/cokmett/
19:14:39 <arahael> c_wraith: I did notice that, though whilst I don't (really) understand category thoery, I noticed that the books and haskell weren't exactly in sync. (Then again, the books were old ,and predated haskell)
19:14:46 <edwardk> <- kmett
19:15:20 <edwardk> i still haven't figured out who put up that page =)
19:15:33 <arahael> tarps: As an example, I interpreted "cokmett" as "cok-mett", which indicates my lack of familiarity with cateogry thoery. ;)
19:15:38 <edwardk> i know a couple of people who know, but nobody is saying =)
19:15:41 <mniip> such mathmatcal
19:16:07 <EvanR> classic pic
19:16:16 <edwardk> the funny thing is the markov chain there actually predicted a couple of class names i used.
19:16:25 <EvanR> i imagine kmett is playing counter-strike
19:16:32 <tarps> lol
19:16:36 <tarps> boom headshot
19:16:51 <glguy> edwardk: The proper response is to find meaningful implementations of the names invented for that page. What do you suppose a Representableoid should be?
19:16:51 <edwardk> EvanR: it was taken by matthieu sozeau after boston haskell one night.
19:16:57 <edwardk> i was explaining the yoneda lemma in code form
19:17:03 <EvanR> haha
19:17:08 <mniip> tarps, nonono
19:17:11 <tarps> i'm very interested in the yoneda lemma but i think i lack the category theory to understand it
19:17:11 <mniip> to _Head shot
19:17:23 <tarps> edwardk: have you written any articles on it?
19:17:26 <edwardk> glguy: Representableoid just won't up being the profunctor version of representable.
19:17:59 <mniip> edwardk, well this is about the only piece of information there is https://github.com/cokmett/cokmett/commit/86e18bc1a73e573c87e01520535586c71df7ba34.patch
19:18:09 <edwardk> tarps: no need. dan piponi did a pretty good job writing up the obvious interpretation. and 'yoneda as cofree functor' as already written up by dan doel on my blog
19:18:50 <tarps> oh i've definitely seen stuff by dan piponi before i guess i'll start there
19:19:43 <edwardk> starting from the beginning of sigfpe (piponi)'s blog was a big part of how i got started in haskell
19:20:12 <mniip> edwardk, how many years ago that was?
19:20:17 <edwardk> mniip: 2006
19:20:24 <glguy> Whoa, you're really old then!
19:20:25 <mniip> oh, that's good to know!
19:20:27 <edwardk> the year that is, not the number of years ago =)
19:20:37 <ab9rf> heh
19:21:23 <ab9rf> coffee functors
19:21:25 <ab9rf> now i need coffee
19:21:33 <ab9rf> or more gin
19:21:39 <erisco> or more functors
19:22:25 <edwardk> ab9rf: as an irrelevant aside, it is quite easy to deface a sign that says COFFEE and make it say COFREE, just sayin
19:23:12 <erisco> you can use that trick to identity your local category theorists at the coffee shop
19:23:20 <ab9rf> edwardk: i'll keep that in mind
19:23:38 <EvanR> i could use it as a proof of non existence of category theorists at the coffee shop
19:24:34 <mniip> hey edwardk, do you think there's anything interesting in yoctoparsec
19:24:51 <ab9rf> there's a yoctoparsec?
19:24:56 <mniip> ofc there is
19:24:59 <ab9rf> isn't this getting a bit absurd?
19:25:13 <mniip> ab9rf, you'll understand when you see the code
19:25:36 <EvanR> luckily theres nowhere to go below yocto
19:25:48 <edwardk> EvanR: sadly the contrapositive is more boring, it just lets you use knowledge of the absence of a category theorists to imply the lack of a cofree sign.
19:25:59 <ab9rf> ha! 54 lines, with comments!
19:26:05 <ab9rf> EvanR: not yet, at least
19:27:05 * hackagebot time 1.8.0.3 – A time library – https://hackage.haskell.org/package/time
19:27:05 * hackagebot word-wrap 0.2 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
19:27:07 <EvanR> oh
19:27:28 <mniip> edwardk, no one expressed interest in it when I made it, but yesterday I think it was erisco who found it fairly interesting
19:27:29 <ab9rf> novemo- has been proposed for 10^-27
19:27:39 <EvanR> the electrons mass in grams undercuts yocto by over 1000
19:27:51 <EvanR> need another word
19:27:53 <edwardk> ab9rf: i was wondering what the opposite of hella- was going to be =)
19:28:00 <mniip> as it's the type that captures the critical concept that StateT [t] fails to capture
19:28:12 <ab9rf> edwardk: i think that's teeni-
19:28:25 <EvanR> lude
19:28:53 <edwardk> https://en.wikipedia.org/wiki/Hella#SI_prefix
19:29:00 <mniip> daily reminder that the SI unit of mass is kilogram and millikilogram is how you really pronounce gram
19:29:32 <ab9rf> edwardk: novetta- as 10^27 has a slightly better arguemnt for it
19:29:45 <ab9rf> since it's analogous to yotta/yocta linguistically
19:29:45 <edwardk> sure
19:29:57 <edwardk> but i still think of 10^27 as hella- =)
19:30:17 <ab9rf> hella- is kinda like bronto-
19:30:27 <ab9rf> big, but nobody really knows how big
19:30:46 <mniip> is there actually any logic behind the SI prefixes?
19:31:02 <edwardk> i mostly use it as a signpost and count down from there
19:31:10 <mniip> I remember atto-exa by heart but I never understood where they come from
19:31:35 <ab9rf> i can't recite the whole ladder
19:31:44 <EvanR> completely made up
19:31:54 <ab9rf> myria- is my favorite, but it's obsolete now :(
19:32:08 <mniip> kilomegagigaterapetaexa
19:32:10 <ab9rf> i used "decimyriad" once in an article i wrote just to be snarky
19:32:18 <mniip> millimicronanopicofemtoatto
19:32:30 <mniip> deci, centi, deca, hecta
19:32:34 <sqooq> no thought on my predicament?
19:32:45 <ab9rf> sqooq: hella thoughts, none useful
19:33:03 <sqooq> I have a feeling I have to do it either as a separate parser, or within the same parser I already have
19:33:15 <sqooq> there's no way I can find the leaves of a tree with basic functions
19:33:15 <erisco> sqooq, what is your question?
19:33:34 <ab9rf> if you're looking for leaves, use a caterpillar
19:33:52 <edwardk> i remember being disappointed when the nsa facility in utah turned out to only hold ~5 zettabytes. At yottabytes some of the succinct tricks I have basically have no overhead.
19:34:22 <sqooq> erisco, I have functions that take a tree and a list of instructions to a leaf, and returns an integer
19:34:35 <EvanR> if you make a book with all these tricks, i will buy it
19:34:54 <ab9rf> what's the integer?
19:35:00 <sqooq> I have a parser that parses my notation and makes a tree, but it does not find the locations of the leaves
19:35:02 <ab9rf> the leaf's phone number?
19:35:18 <sqooq> No, each function is different
19:35:25 <EvanR> (phone numbers are not integers)
19:35:36 <ab9rf> EvanR: they can be encoded as integers
19:35:49 <EvanR> godel isnt impressed
19:35:55 <ab9rf> no, he's dead
19:35:57 <EvanR> lol
19:36:16 <ab9rf> sqooq: i'm not understanding your problem
19:36:29 <mniip> wow
19:36:33 <ab9rf> sqooq: and in this case i don't think the gin is a major contributing factor
19:36:36 <mniip> encoding phone numbers as integers, in 2017
19:36:38 <erisco> sqooq, what is a list of instructions to a leaf?
19:36:44 <edwardk> ab9rf: until you need to store a leading 00 prefix.. deal with strange + pauses to deal with sufficiently exotic international calls....
19:37:02 <ab9rf> edwardk: that just makes it slight more complimicated.
19:37:17 <mniip> just store the damn string, it's not that hard
19:37:21 <EvanR> ok, maybe godel would be impressed
19:37:31 <sqooq> erisco, ab9rf, the list of instructions will be something like [0,1], where 0 is the first item of the top level branch, 1 is the second item of the next level
19:37:42 <ab9rf> so, phone numbers :)
19:37:57 <sqooq> why does lpaste have to be so slow
19:38:13 <erisco> it is sometimes slow, or completely down... that is what you paid for
19:38:25 <sqooq> here's one function
19:38:26 <sqooq> http://lpaste.net/357397
19:38:36 <sqooq> i made it so long ago so idk if it's nicely executed
19:38:45 <sqooq> it was literally made in my first week or two of haskell
19:39:04 <sqooq> but it works
19:39:13 <erisco> I gave up on apologising for my bad code
19:39:14 <ab9rf> sqooq: so this does what, takes a tree and aset of L/R choices, and returns the tree chopped off at that point?
19:39:15 <sqooq> o you need poslength too
19:39:47 <erisco> sqooq, so how does this relate to parsing?
19:39:51 <sqooq> http://lpaste.net/357399
19:40:07 <ab9rf> no, it returns some number that i don't get
19:40:51 <ab9rf> are you trying to assign rational numbers to each element of a tree?
19:40:55 <sqooq> erisco, I guess my question is whether I can make a function that automatically finds the instruction list for every leaf on a tree, or need a parser to do so
19:41:06 <sqooq> I'm guessing parser because I need to keep track of where I've been
19:41:12 <ab9rf> you don't need parser for that
19:41:20 <ab9rf> Writer is probably enough
19:41:46 <sqooq> but since I already have a parser setup, maybe it's easier to just build it in rather than trying to create this function?
19:41:50 <erisco> okay, parsers work on lists of tokens... are we working on a list or a tree?
19:41:59 <sqooq> what is Writer @ab9rf
19:42:09 <ab9rf> sqooq: a useful monad
19:42:24 <ab9rf> it's like the right half of State, the left half being Reader
19:42:29 <EvanR> a parser could also work on a tree
19:42:30 <sqooq> erisco: well if I do it the parser route, then as I'm parsing the text and building the tree I can also be keeping track of the locations of the leaves
19:42:32 <mnoonan_> well, there *are* tree grammars…
19:42:46 <erisco> sqooq's parser works on a list
19:42:48 <ab9rf> i've done tree parsers, although not in haskell
19:42:56 <ab9rf> i wrote one in perl
19:42:57 <ab9rf> fear me
19:43:00 <ab9rf> for i am insane
19:43:20 <mnoonan_> this guy knows how to party —> ab9rf 
19:43:24 <sqooq> so that the parser will return ((Tree a, [[Int]]),String))
19:43:36 <ab9rf> hah, don't tell my kids, they think i'm boring
19:43:42 <ab9rf> and i'm not a guy but no offense taken :)
19:43:42 <mniip> oooh ooh edwardk have you seen yahb
19:43:45 <erisco> sqooq, don't feel that you need to do everything when building your AST, you can always process it more later
19:43:52 <mniip> edwardk, it's a process-level sandbox around ghci
19:44:08 <edwardk> Hadnt
19:44:15 <mniip> % 123 + 4
19:44:15 <yahb> mniip: 127
19:44:23 <ab9rf> you could emit these rational indices during parsing i suppose but i'm not sure that's useful
19:44:43 <erisco> sqooq, just build the tree and be done with the parsing. Now, write a program that takes the tree and finds the paths to the leaves.
19:44:56 <sqooq> ok
19:45:02 <sqooq> shoot, this might be hard lmao
19:45:14 <erisco> that's why people hire us
19:45:19 <ab9rf> wait, why are we calling these integers, you use % in position, that's a ratio constructor
19:45:35 <sqooq> ab9rf, o sorry it is a ratio my bad
19:45:45 <sqooq> It's a ratio for one funtion
19:45:48 <sqooq> and int for the other
19:46:01 <crucify_me> hi the haskellbook states that when an a type declaration is made within a where clause that " the inference is strong in this one." if it's explicit like ' triple x = tripleItYo x ; where tripleItYo :: Integral -> Integral; tripleItYo x = x * 3 ' 
19:46:10 <ab9rf> how are these position rationals constructed? what are the recurrences?
19:46:20 <crucify_me> *when a type declaration*
19:46:30 <mniip> crucify_me, you can't say "Integral -> Integral"
19:46:34 <ab9rf> crucify_me: that is a TERRIBLE star wars reference, yhou should beat whoever wrote that with a wookie
19:46:36 <mniip> not sure where you've got that
19:47:04 <ab9rf> yeah, integral is a typeclass, not a type
19:47:11 <xcmw> What is the difference between these constraints? http://lpaste.net/357400
19:47:14 <ab9rf> it's (Integral a) => a -> a
19:47:32 <crucify_me> hold on sorry please wait 
19:48:04 <sqooq> Umm, idk how to explain it, basically Position1/Length1 + Position 2/(Length1*Length2) + Position 3/(Length1*Length2*Length3) + ...
19:48:23 <sqooq> in the direction of the leaf
19:48:37 <erisco> xcmw, they look really different to me... don't they to you?
19:48:39 <crucify_me> hold on it uses a y as a variable name, I'll paste it sorry.
19:49:35 <xcmw> erisco: They look like the should mean the same thing to me.
19:49:57 <ab9rf> sqooq: so if you have a tree with one root and two leaves, one left, one right, how would that tree be labeled?
19:50:00 <mniip> xcmw, I think polykinds is kicking in too hard
19:50:08 <mniip> xcmw, try kind-annotating your type families
19:50:31 <mniip> possibly at use site as well
19:50:41 <sqooq> [ 1 2 [ 1 2 ] ] : The 1 that's most within would have instructions [2,0], and the function basically does 2/3(length of top layer) + 0/2(length of current inner layer) = 2/3
19:50:53 <sqooq> 2/3 here basically tells you the rhythmic position of a note
19:51:04 <crucify_me> the code and a note: https://ptpb.pw/vgqb
19:51:22 <ab9rf> sqooq: so the left branch is 1/3 and the right branch is 2/3?
19:51:35 <sqooq> there are 3 branches so to speak
19:51:44 <sqooq> or really 2 leaves and a third Branch which contains 2 leaves
19:51:46 <ab9rf> sqooq: oh, i  thought this was a binary tree, my badly
19:51:52 <mniip> crucify_me, I think it's trying to say that the type of triple is easily inferred
19:51:58 <mniip> and so haskell does that
19:52:08 <ab9rf> sqooq: so if a node has n children, they're labeled 0/n, 1/n, 2/n etc.?
19:52:17 <ab9rf> sqooq: up to (n-1)/n?
19:52:34 <erisco> xcmw, I see the question now... not sure, let me think
19:52:35 <sqooq> so the first item has 0/3, the second, 1/3, and the first of the third 2/3, and then the next woulld have 5/6 i think
19:52:53 <ab9rf> sqooq: ok, so this can be defined recursively
19:52:56 <xcmw> mniip erisco: When I set the kind it works
19:53:02 <sqooq> ab9rf I literally already made it lmao
19:53:08 <sqooq> it's that lpaste
19:53:09 <sqooq> http://lpaste.net/357399
19:53:09 <ab9rf> sqooq: yeah, but i didn't udnerstand it :)
19:53:13 <sqooq> o ok
19:53:15 <erisco> xcmw, the kind of what specifically?
19:53:22 <xcmw> type family GetFun b :: * -> * where
19:53:25 <mniip> what kind of kind
19:53:27 <sqooq> yeah but my real problem is that I want to automatically calculate the list of instructions
19:53:29 <xcmw> type family GetArg b :: * where
19:53:35 <sqooq> to act as input for that function
19:53:38 <sqooq> so I need another function
19:53:48 <sqooq> but y'all already said not to take the parsing route
19:53:54 <sqooq> so I guess I'll just get to work on that function
19:54:07 <ab9rf> sqooq: on line 8, (walk ws) should be multiplied by (1 % poslength x w) i think
19:54:13 <mniip> xcmw, yeah no wonder
19:54:27 <ab9rf> oh, wait, no, that's not right
19:54:41 <ab9rf> sorry no, i'm wong
19:54:44 <mniip> xcmw, I can't pinpoint this exactly right now but with unrestricted polymorphic kinds, your code actually does contain a type error
19:54:59 <ab9rf> the gin is getting to me now
19:55:01 <ab9rf> i need food
19:55:04 <sqooq> lmao
19:55:09 <sqooq> i haven't eaten since morning
19:55:14 <sqooq> kitchen being renovated
19:55:17 <sqooq> jobless
19:55:17 <mniip> feed on haskell
19:55:20 <sqooq> so no food
19:55:23 <ab9rf> my wife wanted a drink and i used the wrong gin so i had to make myself one and now i'm drunk
19:55:26 <sqooq> and vegan, so food that family eats I don't eat
19:55:33 <crucify_me> mniip ok yeah thank you , so if we're talking about the outer function triple, than I understand what the book means. thanks
19:55:33 <sqooq> aka I starve myself
19:55:38 <mniip> > fix $ (0:) . scanl (+) 1
19:55:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:56:16 <sqooq> mniip I've been doing haskell with only breaks to hang out with friends for like a week now
19:56:23 <sqooq> I feel zombie-like
19:56:27 <sqooq> I literally dream 
19:56:29 <sqooq> haskell
19:56:43 <crucify_me> vegan life is the best. 
19:56:44 <ab9rf> i had a very lucid dream in german once, which is impressive since i barely know german
19:56:46 <mniip> do haskell with friends!
19:56:53 <mniip> I do that occasionally
19:57:09 <ab9rf> i'm fairly certain it came from cramming for a final exam
19:57:18 <sqooq> crucify_me it was up until I quit my job 
19:57:49 <mniip> sqooq, haskell is exciting isn't it
19:58:00 <sqooq> it was the first week or two
19:58:07 <sqooq> now I just want this stupid program to be done
19:58:11 <sqooq> so I can make some music already
19:58:15 <mniip> after 4 years I still feel excitement every so often
19:58:36 <mniip> fascination with some new discoveries
19:58:53 <sqooq> monads, functors, and applicative was pretty awesome not gonna lie
19:59:01 <mniip> it goes on
19:59:07 <mniip> have you seen lens
19:59:23 <sqooq> nope
19:59:23 <jared-w> mniip: I have absolutely no friends who care to learn Haskell that I know of :(
19:59:26 <pacak> profunctors, arrows, comonads...
19:59:29 <sqooq> need to learn State too probably
19:59:46 <pacak> representable functors, ajunctions, categories...
20:00:00 <pacak> recursion schemes...
20:00:03 <mniip> sqooq, it's the largest combination of marginally useless category theory results put to work
20:00:03 <pacak> :t cata
20:00:04 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:00:14 <sqooq> jared-w, mniip, my friend is OOP dude, but only because he's at school and that's what they push, but I talk to him about haskell all the time, and he always seems to get it
20:00:16 <sqooq> very quickly
20:00:17 <pacak> :t ana
20:00:18 <lambdabot> error:
20:00:18 <lambdabot>     • Variable not in scope: ana
20:00:18 <lambdabot>     • Perhaps you meant one of these:
20:00:29 <sqooq> so maybe if I sat with him i could teach him the basics
20:00:35 <sqooq> but we just talk about it
20:00:51 <sqooq> mniip: that sounds awesome
20:00:55 <mniip> always ask for consent before teaching haskell
20:02:04 <mniip> sqooq, yeah like
20:02:12 <mniip> > over each (+1) (1, 2, 3)
20:02:14 <lambdabot>  (2,3,4)
20:02:18 <mniip> :t over
20:02:19 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
20:02:22 <mniip> :t each
20:02:23 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
20:02:31 <mnoonan_> I was primed by my former life as a mathematician I guess, but working on a huge legacy C++ codebase really highlights the benefits of Haskell to me.
20:02:44 <erisco> xcmw, with polykinds it infers GetFun :: a -> b -> a  and  GetArg :: a -> b
20:02:45 <mniip> % :i ASetter
20:02:46 <yahb> mniip: type ASetter s t a b = (a -> Identity b) -> s -> Identity t -- Defined in `Control.Lens.Setter'
20:02:51 <mniip> % :i Each
20:02:52 <yahb> mniip: class Each s t a b | s -> a, t -> b, s b -> t, t a -> s where; each :: Traversal s t a b; default each :: (Traversable g, s ~ g a, t ~ g b) => Traversal s t a b; -- Defined in `Control.Lens.Each'; instance Each [a] [b] a b -- Defined in `Control.Lens.Each'; instance Each (Tree a) (Tree b) a b -- Defined in `Control.Lens.Each'; instance Each (Data.Sequence.Seq a) (Data.Sequence.Seq b) a b -- Defin
20:03:12 <mnoonan_> nothing like seeing how many ways you can shoot yourself in the foot to get a little appreciation for a language that can actually help you out
20:04:25 <mniip> that's not the worst even
20:04:29 <sqooq> woah
20:04:32 <sqooq> it's so much
20:04:34 <mniip> :t holesOf
20:04:36 <lambdabot> Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Control.Lens.Internal.Context.Pretext p a a t]
20:04:44 <sqooq> BAZAAR
20:04:46 <sqooq> LMAO
20:04:53 <ClaudiusMaximus> TIL cabal sandbox delete ; cabal sandbox init  # is not sufficient when upgrading ghc, also needs  cabal clean  (I got weird issues about sandbox 8.0.2 directory not existing, when i was using ghc 8.2.1)
20:04:55 <mniip> (now at this point I myself have only a marginal understanding)
20:05:16 <sqooq> I literally recognize nothing there
20:05:47 <sqooq> EACH s t a b
20:06:03 <sqooq> each stab you take, takes you one step closer to p u r e m a t h e m a t i c s
20:06:21 <erisco> xcmw, my hypotheses is that   GetFun a ~ Maybe  is not used to substitute in  (GetFun a) (GetArg a)
20:06:22 <mniip> I understand zippers and holes, hence I understand that a Pretext is like a -> s or something
20:07:09 <erisco> xcmw, I do not know everything about the solver but I think all it can get from  GetFun a ~ Maybe  is what 'a' might be, but I do not think it even gets anything there either
20:07:16 <erisco> xcmw, because GetFun is not injective
20:07:18 <mniip> but look what cool stuff can I do
20:07:22 <mniip> % map (peeks negate) $ holesOf each [1, 2, 3, 4]
20:07:22 <yahb> mniip: [[-1,2,3,4],[1,-2,3,4],[1,2,-3,4],[1,2,3,-4]]
20:08:27 <jared-w> sqooq: I go to a commuter school so the atmosphere is different; I don't have a whole lot of friends I know from my CS courses yet. Next year will be different, but this year I was a transfer student and I was taking a lot of lower division courses. Until then, I don't imagine being able to preach Haskell to too many people :p
20:08:42 <sqooq> I'm not even in school lmao
20:08:45 <sqooq> currently
20:08:54 * mniip is totally preaching haskell to everyone
20:08:57 <sqooq> I was going to go for music
20:09:11 <jared-w> hah, nice, how's that turning out?
20:09:11 <erisco> xcmw, I don't even think it can use GetFun a ~ Maybe in that way because it doesn't know it is even true
20:09:20 <jared-w> mniip: I'm, uhh, "shocked"? :p
20:09:43 <mniip> I've got a few people hooked
20:10:04 <xcmw> erisco: I lost you with the last statement. How would it not know?
20:10:10 <mniip> luckily the people around me are exactly the right kind of - open to new ideas and abstract thinking
20:10:10 <sqooq> jared-w alright, I don't think i'm going to go for music anymore. I hope it isn't a misjudgement but I literally think I'm even farther ahead that anything they could teach me, and being a good composer is not something you can learn in school, maybe learn from a teacher, but then I should just get a private composer teacher
20:10:17 <sqooq> so I'm going to go for math
20:10:21 <mniip> I've even explained lambda calculus from scratch to someone
20:10:25 <sqooq> gonna get a phd in math
20:10:44 <jared-w> Nice! I know someone who does erlang and knows FP pretty well; I should talk to them about Haskell more, maybe we can learn some together...
20:11:28 <mniip> sqooq, musical education is fairly important though
20:11:33 <jared-w> mniip: my school actually has a pretty decent Haskell and FP presence. One of the professors at PSU is the co creator of the Curry language and another one helps with the low-level kernel being written in a FP language based on Haskell
20:11:38 <mniip> like, I often wish I knew music theory
20:12:13 <erisco> xcmw, again, I do not know enough about the solver to be certain, but to know  GetFun a ~ Maybe  it has to know more about 'a', and I don't think it can figure out that  a ~ Maybe b  for some b because I don't think it tries at all for non-injective families
20:12:18 <mniip> eh
20:12:24 <ab9rf> math hates me
20:12:30 <ab9rf> :)
20:12:36 <mniip> the only presence of haskell in my uni I've detected is I've randomly saw my uni's name in an ICFPC scoreboard
20:12:43 <mniip> lol
20:12:48 <ab9rf> i was a math major until i encountered green's theorem and lost.
20:12:50 <jared-w> It's something!
20:12:59 <xcmw> erisco: Ok. Thanks
20:13:03 <mniip> (below my own team (!))
20:13:15 <jared-w> ab9rf: green's theorem isn't too bad; it really depends on whether or not you're calculus inclined
20:13:32 <ab9rf> jared-w: i could probably have understood it but i was having Issues at that point in my life
20:13:45 <mniip> ah green's theorem
20:13:49 <EvanR> [Issue]
20:13:51 <ab9rf> jared-w: i was fine with calculus up to that pint
20:13:54 <mniip> the special case of, what, the generic stokes theorem?
20:13:55 <jared-w> I think the math education at universities is kinda fucked. Calculus is useless for learning "higher math" because the proof-rigor approach to the rest of math fails in Calculus; the proper rigor is totally lost teaching it to undergrads
20:14:02 <jared-w> mniip: yup
20:14:11 <erisco> xcmw, and I am also saying that I do not think it will use a type equality to make substitutions
20:14:16 <jared-w> The only reason we even teach calculus to undergrads is because they need to know how to fake it for their engineering courses -_-
20:14:38 <ab9rf> the honors math program i was in was actually fairly proof-heavy and spent much less time on practical examples
20:14:48 <mniip> jared-w, wait what?
20:14:53 <mniip> they have us prove all calculus here
20:15:05 <erisco> xcmw, it would have to replace  (GetFun a)  within  (GetFun a) (GetArg a)
20:15:08 <ab9rf> i just didn't do well on green's theorem, largely because Life had me distracted at that time
20:15:18 <jared-w> Freshman calculus here is basically entirely proof free except for a few pretend proofs
20:15:49 <jared-w> It's not until you take "advanced calculus" (a senior level class) where they go "haha jk let's do calculus but for real this time"
20:15:49 <mniip> I think I can recall at least 30 theorems just in the first semester
20:15:50 <ab9rf> i more or less backed into it later on, when i was typing my ex's math stuff for her Ph.D.
20:16:02 <mniip> all with formal proofs
20:16:07 <ab9rf> jared-w: my freshman calc program was very little but proofs
20:16:09 <jared-w> I gotta go swim and cool off (it's currently like 100 degrees now and it sucks)
20:16:18 <jared-w> ab9rf: that would've been wonderful. Mine wasn't and it sucked :(
20:16:21 <ab9rf> jared-w: my professor had a rule: "Thou shalt not compute in public."
20:16:22 <erisco> xcmw, and even then if it could, I am not sure that is safe to do if we don't actually know  GetFun a ~ Maybe
20:16:45 <mniip> starting from stuff like 'sum of limits is limit of sums' and up to taylor's formula with largrange/cauchy remainder
20:16:52 <erisco> xcmw, there are false proofs based on subtle incorrect substitutions like this
20:17:08 <ab9rf> i remember when he was demoing some problem that had (3/2)^2 in it, which he expanded to (3^2)/(2^2)
20:17:10 <xcmw> erisco: Thats the part I don't get. GetFun is pure so you can substitute right?
20:17:35 <ab9rf> distributing the exponentiation over the division was allowed. actually reducing it to 9/4 was a violation of his oath.
20:17:38 <erisco> xcmw, there is a difference between definitional equality and propositional equality... ~ is propositional
20:18:12 <xcmw> erisco: What?
20:18:14 <erisco> xcmw, when you define a term there is no question about it, but when you write a proposition that something is equal to another then there is some procedure to verify it
20:18:22 <ab9rf> mniip: we discussed cases where the lebesgue integral and the riemann integral were different 
20:18:28 <ab9rf> mniip: in freshman calc
20:18:45 <mniip> lebesgue was sligtly mentioned in year two
20:18:47 <erisco> xcmw, a level lower, == is propositional and = is definitional
20:18:53 <mniip> and is only going to be covered in functional analysis in year three
20:18:58 <erisco> xcmw, if that helps you think about the difference
20:19:07 <EvanR> where is == propositoinal
20:19:10 <ab9rf> mniip: it wasn't formally defined for us, but he gave an intuitive definition and explained some cases where they differed
20:19:15 <mniip> well sure
20:19:17 <mniip> that's simple
20:19:31 <mniip> dirichlet is riemann-nonintegrable
20:19:31 <ab9rf> mniip: in second year, he demonstrated fractional differentiation for us
20:19:57 <ab9rf> mniip: oh, he found fiunctions that were both lebesgue-integrable and riemann-integrable, but to different vlues
20:20:15 <mniip> are we talking proper riemann integrals?
20:20:23 <mniip> or improper
20:20:28 <ab9rf> mniip: this was 30 years ago, might have been improper
20:20:32 <EvanR> ab9rf: sounds like something is broken about something in that case ... haha
20:20:39 <mniip> yeah for improper I'm sure you can construct something
20:20:44 <mniip> same double limit problem
20:20:49 <ab9rf> yeah
20:20:56 <ab9rf> he liked throwing edge cases at us
20:21:04 <ab9rf> weird functions that oscillate like made
20:21:14 <mniip> that's a good thing
20:21:20 <mniip> especially with improper integrals
20:21:20 <erisco> xcmw, so in that sense, you can write 3 == 5 and that is a valid program, but we can't go around substituting 3 for 5 everywhere
20:21:22 <EvanR> ooh ahh come see the exotic broken math
20:21:24 <ab9rf> we had lots of assignments with functions that were defined differently for rational and irrational x
20:21:35 <ab9rf> he was great
20:21:41 <ab9rf> i wish i hadn't washed out but it wasn't his fault
20:22:07 <xcmw> erisco: Is there type level definitional equality?
20:23:21 <mniip> I want to do research in theoretical CS/FP area - but I'm not sure how to pathfind my way there
20:23:26 <sqooq> Catching up with what I missed
20:23:37 <sqooq> mniip: music theory is all over the place
20:23:42 <sqooq> hence why I don't want to go to school too much
20:23:44 <ab9rf> i ended up doing mostly political science and went to law school for a while before i dropped out of that and got a development job
20:23:54 <erisco> xcmw, you should talk to someone around here who is a type theorist because I will mess it up
20:24:05 <sqooq> only musical set theory and this dude Tymoczsko's theory seems actually good
20:24:23 <sqooq> music theory as thought is very focused on one structure, and what sounds good in that structure
20:24:30 <xcmw> erisco: Who are the type theorists?
20:24:34 <ab9rf> i knew a woman who was doing a ph.d. in math after a ba in musical theory
20:24:45 * erisco lights the HoTT signal
20:24:47 <mniip> sqooq, you mean the 12 semitone major scale?
20:24:53 <sqooq> yuuup
20:25:03 <ab9rf> which one?
20:25:14 <mniip> well, not much research has been put into what sounds good outside of that
20:25:43 <sqooq> yes
20:25:48 <sqooq> that's what they want you to think
20:26:03 <sqooq> here's tymoczko http://dmitri.mycpanel.princeton.edu/files/publications/supplement.pdf
20:26:04 <ab9rf> there's actually quite a bit of research into that, it's just that nobody agrees on what it means
20:26:19 <sqooq> yeah music thoeyr when done like that, is subjective
20:26:28 <ab9rf> and since aesthetics is an area that is resistant to objective analysis....
20:26:33 <sqooq> that's why I prefer Tymoczko and Set theory because it only describes
20:26:37 <sqooq> and it can describe anthing 
20:27:14 <sqooq> traditional music theory is very bad at describing things outside diatonicism
20:27:20 <sqooq> even a little bit outside
20:27:30 <ab9rf> if we go by popular consumption, we might as well just scrap everything except G-D-Em-C
20:27:40 <glguy> This seems like a great topic for #haskell-offtopic
20:27:53 <EvanR> or #haskell-blah
20:27:59 <ab9rf> moop
20:28:02 <sqooq> ab9rf, nah more like I-V-VI-IV
20:28:06 <sqooq> I'm done
20:28:16 <sqooq> unless y'all want to continue or have questions
20:28:20 <ab9rf> sqooq: yeah, but you're broke, so noboody cares what you like :)
20:28:21 <glguy> You shouldn't stop talking about it, we just have a better channel for it
20:28:27 <sqooq> then yeah ping me in there because idk how to get there
20:28:48 <sqooq> o wait it's a literal channel
20:28:48 <sqooq> ok
20:28:55 <ab9rf> sqooq: oddly enough, yes
20:29:19 <sqooq> also who was talking about calculus being bad
20:29:31 <erisco> xcmw, from what I know, it wouldn't make sense as part of a context
20:29:44 <sqooq> in my school we learned the rigorous epsilon-delta definition of the limit and used it to build the definitions for everything else
20:29:48 <erisco> xcmw, definitional equality is the = you are writing when you are making a definition
20:30:13 <sqooq> and all theorems and definitions were written very clearly using the whole logic speak (but not symbolic for the most part)
20:31:48 <erisco> xcmw, but take that all with a grain of salt because there is a whole ecosystem of type theory and I don't know it
20:32:51 <EvanR> you could use := to mean definitional equality
20:33:03 <EvanR> x is defined as y
20:35:28 <erisco> A fundamental distinction is extensional vs intensional type theory. In extensional type theory definitional (i.e., computational) equality is not distinguished from propositional equality, which requires proof.
20:35:33 <erisco> https://en.wikipedia.org/wiki/Intuitionistic_type_theory
20:36:33 <erisco> no idea where Haskell lies
20:38:54 <xcmw> erisco: Ok. I kind of understand it now. It would be nice if Haskell let you write constraints using the same syntax as types.
20:43:42 <erisco> xcmw, what is an example of that? not sure what you mean
20:46:28 <xcmw> erisco: If something like   Eq a, Show b => (a -> b, a)   could be automatically converted to    * -> Constraint.
20:47:38 <erisco> but that isn't a constraint
20:47:57 <erisco> (Eq a, Show b) is a constraint and (a -> b, a) is a type
20:48:39 <erisco> is (=>) :: Constraint -> * -> * ? hm
20:48:48 <xcmw> erisco: It is possible to convert a type to a constraint
20:49:00 <erisco> xcmw, that doesn't make sense, so no
20:49:14 <erisco> what is Maybe Int as a constraint?
20:49:28 <xcmw> erisco: ((~) Maybe Int)
20:49:39 <erisco> what is Int as a constraint?
20:49:52 <xcmw> actually ((~) (Maybe Int))
20:50:02 <xcmw> ((~) Int)
20:50:16 <erisco> I don't really get it... why not just write (~) Int then
20:50:43 <erisco> which isn't a constraint yet anyways
20:50:52 <xcmw> What if I have   (a -> b, b)  ?
20:51:11 <erisco> I dunno, what about it?
20:51:15 <xcmw> That can also be * -> Constraint but it much trickier
20:52:39 <erisco> I dunno man, seems weird
20:54:21 <xcmw> erisco: Well I'm constrainting each element in a type level list using recursive type families so it is going to be weird.
20:55:36 <erisco> the promotion of types to constraints seems weird
20:55:55 <fearless_man> need some code review: do you think this is functional?(FP) https://paste.ubuntu.com/25237439/
20:56:14 <glguy> fearless_man: Oops, this is #haskell
20:56:23 <erisco> but you can put down how it'd work, and don't forget how to deal with free variables, maybe it is better than I am thinking
20:56:55 <fearless_man> glguy: yeah i know, you guys know fp 
20:57:19 <glguy> fearless_man: Sorry, the topic of #haskell is specifically Haskell
20:57:28 <erisco> how about join us in #haskell-offtopic
20:57:31 <fearless_man> i've been trying to learn haskell,  I still can't fully comprehend it
20:57:48 <fearless_man> so i turn back to python and apply wjhat i learned
20:58:30 <fearless_man> glguy: How can you run 2 functions in parallel if the other depends on the other's output for input?
20:59:42 <erisco> fearless_man, is there some demonstration of this?
21:01:15 <glguy> fearless_man: Yeah, as long as there's evaluation that the second one can do that doesn't depend on the first
21:03:01 <sqooq_> were my messages going through?
21:03:34 <Rotaerk> when?
21:03:42 <fearless_man> erisco: e.g. ls and grep ls -a | grep pattern, how can you run ls and grep in parallel if grep depends on ls (this is the only fp explanation i can provide, i can't still code on haskell)
21:04:34 <erisco> fearless_man, because grep can work incrementally on the output of ls
21:05:24 <erisco> fearless_man, imagine you are pianist and I am your page turner. We work in parallel through the piece. You don't wait for me to turn through all the pages before you start playing!
21:07:57 <fearless_man> erisco: mind blown :)
21:10:27 <fearless_man> erisco: now I understand, thanks
21:12:36 <mnoonan_> erisco: that’s a great analogy
21:15:58 * hackagebot brick 0.21 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
21:20:58 <jared-w> fearless_man: also, the #python irc channel is quite active and they would be able to help you out with the python part.
21:31:10 * hackagebot gmndl 0.4.0.4 – Mandelbrot Set explorer using GTK – https://hackage.haskell.org/package/gmndl
21:35:01 <ab9rf> erisco: that would be more fun to wathc
21:38:37 <erisco> ab9rf, something Victor Borge could have come up with
21:41:32 <fearless_man> jared-w: erisco helped me in haskell-offtopic
21:42:06 <fearless_man> can someone explain curring to me?
21:42:24 <erisco> currying, sure, so in Haskell all functions take one argument
21:42:55 <erisco> traditionally you are used to what we would write in Haskell as  (a, b) -> c
21:43:04 <ab9rf> why is it that so many things in haskell involve food-related metaphors?
21:43:17 <erisco> that is a function which takes a 2-tuple and returns something
21:43:34 <erisco> in Haskell we do this differently, instead we use  a -> (b -> c)
21:43:52 <erisco> so what goes on here is we apply it to one argument and get a b -> c back, then we apply that to another argument and get our c
21:44:15 <erisco> i.e. we write functions which return functions
21:44:22 <erisco> and that in a nutshell is currying
21:44:29 <erisco> :t curry -- currying incarnate
21:44:31 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:44:38 <ab9rf> :t uncurry
21:44:40 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:45:35 <erisco> fearless_man, you can do this in many languages, including Python, but it is nonstandard to do so
21:45:37 <fearless_man> erisco: you mean like map in python?
21:46:03 <fearless_man> erisco: when do we use currying?\
21:46:03 <ab9rf> > (curry (+)) (1,2)
21:46:05 <lambdabot>  error:
21:46:05 <lambdabot>      • No instance for (Typeable b0)
21:46:05 <lambdabot>          arising from a use of ‘show_M30815806236391403541191’
21:46:05 <ab9rf> damn
21:46:09 <ab9rf> > (uncurry (+)) (1,2)
21:46:10 <erisco> fearless_man, looking at the docs for map, no, doesn't seem related to me
21:46:11 <lambdabot>  3
21:46:26 <mnoonan_> fearless_man: it’s like this in python: http://paste.ubuntu.com/25237794/
21:46:42 <mac10688> https://stackoverflow.com/questions/45498425/how-to-upgrade-stack-ghc
21:46:55 <mac10688> if anyone can tell me how to upgrade the ghc of my stack, I would appreciate it
21:47:10 <mnoonan_> fearless_man: so you’d write add(1,2) or curried_add(1)(2)
21:47:11 <ab9rf> not sure if i'd call that currying
21:47:12 <mac10688> I'll give points on SO, it's the best I can do in return
21:47:15 <dysfun> mac10688: you change resolver to a newer one
21:47:17 <erisco> fearless_man, well, lets use map as an example. haskell also has a map
21:47:19 <erisco> :t map
21:47:19 <ab9rf> but i suppose so
21:47:20 <lambdabot> (a -> b) -> [a] -> [b]
21:47:28 <ab9rf> python confuses me
21:47:30 <mac10688> oh
21:47:46 <erisco> fearless_man, map needs a function of type a -> b, and a list of type [a]. Because it needs two things it uses currying to get them both
21:47:56 <dysfun> mac10688: a resolver tags a specific ghc and set of packages known to work together
21:48:00 <ab9rf> ok, yeah, tha tis currying in the weird universe that is python
21:48:09 <erisco> fearless_man, it could have been  (a -> b, [a]) -> [b]  instead but we like to curry stuff in Haskell
21:48:15 <ab9rf> curried python. now that's one dish i don't expect to eat anytime soon,
21:48:28 <mac10688> thank you dysfun I will look into this
21:48:40 <dysfun> and literally all you do is change that in stack.yaml
21:48:50 <mnoonan_> I guess it would be nicer to make the inner function a lambda, but given the context I don’t know if it would be clearer or not
21:49:08 <mac10688> the current resolver is lts-6.35
21:49:20 <mac10688> I'm trying to figure out what I need to replace that with
21:49:23 <dysfun> that's ancient
21:49:47 <dysfun> https://www.stackage.org/ # says LTS-8.24 is out since last week (with ghc 8.0.2)
21:50:25 <mac10688> I think I found it dysfun. lts-9.0
21:50:32 <mac10688> https://www.stackage.org/lts-9.0
21:50:36 <dysfun> ah yes sorry, there was 9.0 too
21:50:47 <ab9rf> were  up to 9.0?
21:50:52 <ab9rf> geez, i just switched to 8.0
21:51:01 <dysfun> apparently we're up to 9, yes
21:51:03 <ab9rf> well, not "just" but rwow.
21:51:24 <erisco> fearless_man, now the reason we like the curried version over the uncurried version is because when curried we can do what is called "partial application"
21:51:25 <fearless_man> erisco: why do we use currying?
21:51:28 <ab9rf> actualyl come to think of it that was like 7 months ago
21:51:51 <fearless_man> partial application sounds cool, but what is it?
21:51:54 <ab9rf> when you're pushing 50, a year doesn't seem like that long of a time
21:52:02 <erisco> fearless_man, partial application is when we apply less than the total number of arguments required
21:52:22 <ab9rf> partial application rocks!
21:52:23 <erisco> fearless_man, so for example, in Haskell we can write "plus one" as (+) 1
21:52:24 * ab9rf runs
21:52:41 <fearless_man> so a partial application is more reusable than a normal function?
21:52:58 <dysfun> a partially applied function *is* a function
21:52:59 <ab9rf> well, not more reusable
21:52:59 <mniip> in haskell there's no difference
21:53:11 <ab9rf> but the ability to partially apply functions to easily create new functions is very useful
21:53:27 <erisco> fearless_man, it is usually more convenient
21:53:27 <mnoonan_> fearless_man: you might want to check out Python’s functools to get a feel for some of this stuff in a more familiar context
21:54:19 <fearless_man> mnoonan_: i've tried map, reduce, filter, list comprehensions generators, immutable tuple, BUT I WANT MORE of this FP
21:54:53 <mnoonan_> fearless_man: functools has partial application & composition too, iirc
21:54:56 <ab9rf> someone dump a bowl of monad soup on him already
21:55:44 <mniip> well
21:55:56 <mniip> monads are just monoids in a category of endofunctors
21:56:13 <erisco> everyone knows that
21:56:16 <mniip> sure
21:56:31 <fearless_man> please start with the basics, no advance please
21:56:35 <Rotaerk> not mexican food?
21:56:45 <ab9rf> naked mexican food
21:56:54 <mnoonan_> “category”? you mean “monoidoid”?
21:57:11 <mniip> damn
21:57:14 <mniip> so it is
21:57:15 <ab9rf> avoid the (mo)noid
21:57:16 <erisco> fearless_man, they're just joking around
21:57:53 <fearless_man> hahaha
21:58:39 <erisco> fearless_man, it is not unfunctional to have uncurried functions, it is more or less just a convention Haskell has
21:58:58 <erisco> and I think usually turns out helpful, but some would argue not
21:59:48 <ab9rf> i don't like tuples
22:01:06 <Donovan> hi everyone, im new at haskell, and wondering if anyone can help me with the ad library: grad myFunc works just fine and has the correct type, but map grad [myFunc] does not, and I have no idea why!
22:01:30 <mac10688> https://stackoverflow.com/questions/45498573/upgrade-ghc-compiler-but-dependencies-are-not-within-the-specified-version
22:01:42 <erisco> Donovan, sure, paste your code and type error please to lpaste.net
22:01:54 <fearless_man> erisco: what are the fundamental, key components to build my FP knowledge, e.g. in progrmming (loops, if, else, variables etc.)
22:02:13 <ab9rf> fearless_man: well, most functional programming languages don't use explicit looping.... :)
22:02:42 <mac10688> I have posted another question. I upgraded my ghc, but now my dependencies are out of date. I want guidance for if I should try to change the constraints of my dependencies or add the dependencies in my extra-deps field in my yaml file like the stack tool suggests
22:02:44 <erisco> fearless_man, that is a good question. Have you worked in a typed language before?
22:02:55 <fearless_man> like c?
22:03:00 <erisco> a statically typed language, that is... I know Python has types
22:03:04 <ab9rf> c is barely typed.
22:03:19 <ab9rf> i mean, it has types, but just barely.
22:03:20 <erisco> sure, I guess C is an example, but it is one of the most rudimentary static type systems
22:03:38 <erisco> maybe Java or C#?
22:03:58 <fearless_man> never heard of them evil laugh
22:03:58 <ab9rf> C#, please, java generics make my butt itch
22:04:48 <erisco> fearless_man, in my experience a hurdle is becoming used to static types. I came from PHP
22:05:00 <ab9rf> i admit that i'm getting lazy in C++ lately, i tend to declare everything 'auto' and then change type declarations until it compiles
22:05:05 <Donovan> erisco: ok, my code is here: http://lpaste.net/357406, just let me get the error
22:06:05 * hackagebot proto-lens-protoc 0.2.2.2 – Protocol buffer compiler for the proto-lens library. – https://hackage.haskell.org/package/proto-lens-protoc
22:06:08 <erisco> fearless_man, so, your fundamentals are functions, static typing, product and sum types, pattern matching, recursion
22:06:14 <fearless_man> i think immutability, recursion, that's all I know about fb,
22:06:35 <erisco> probably not the ideal list... haven't really thought about it... but those topics should get you started
22:07:12 <erisco> well, sure, immutability too
22:07:35 <erisco> immutability and recursion sort of go hand in hand because where you think you need mutability you actually need recursion
22:08:41 <fearless_man> erisco: static typing is like duck typing in python but better right?
22:09:03 <ab9rf> fearless_man: no, duck typing is really the opposite 
22:09:24 <erisco> type systems are not just on a simple scale from "bad" to "great", they have different features and are better at different things
22:10:10 <Donovan> erisco: my error is there too now, cheers
22:10:19 <erisco> Donovan, thanks I'll look in a few minutes
22:10:24 <ab9rf> duck typing is a form of ad hoc interface inheritance: basically, if you name a method a specific name, it acts as if you inherited an interface that implements that method, whether or not you really did
22:11:02 <erisco> fearless_man, a duck type is something you write in documentation, like Python's File, iirc
22:11:17 <erisco> fearless_man, it is an agreed convention that an object has to follow to be compatible with an interface
22:11:40 <fearless_man> so there are no variable types in haskell?
22:11:56 <erisco> fearless_man, static typing takes the documentation and makes it actually part of the program, and now the compiler can verify if your object satisfies the type or not
22:12:05 <mnoonan_> you could make a case that row types are the static-type version of duck typing though
22:12:46 <ab9rf> fearless_man: the type of a bound identifier is always known precisely, and cannot vary
22:13:03 <ab9rf> although it could be a polymorphic type
22:13:33 <ab9rf> there's none of tis business of passing "either an integeor or a string" that you find in languages like python or perl
22:13:40 <ab9rf> er, python or php
22:13:56 <erisco> fearless_man, well, I am not quite sure what you mean by "variable type", but you cannot make a list [3, "foobar"] for example because 3 is an Int and "foobar" is a String, and lists can only hold something of one type
22:13:57 <ab9rf> no runtime tests "if a is an integer, do this else if it's a string do that"
22:14:20 <ab9rf> you can have a type that can contain either an integer or a string, though
22:15:53 <fearless_man> haskell really is weird, my mind can't take all thins info
22:16:00 <ab9rf> it's not weird, it's just different
22:16:10 <ab9rf> it's actually far less weird
22:16:13 <erisco> fearless_man, start with some simple practices and work up
22:16:32 <fearless_man> so what if you need a list [3, "foobar"] how do you do this in haskell?
22:16:42 <ab9rf> fearless_man: there are a lot of different ways
22:16:50 <erisco> [Left 3, Right "foobar"] is a possibility
22:16:51 <ab9rf> fearless_man: depends on why you need a heterogenous list
22:16:55 <mnoonan_> fearless_man: you might find that you don’t really want to do that after all
22:16:56 <ab9rf> (3, "foobar")
22:17:05 <mnoonan_> why do you usually do that in python, for example?
22:17:18 <ab9rf> tuples are not lists
22:18:03 <fearless_man> mnoonan_: I don't do that alot, just when building lists for output e.g. printing
22:18:12 <ab9rf> a lot of time, people use lists in python as ad hoc record types
22:18:24 <EvanR> "when you need a heterolist"
22:18:31 <EvanR> when you wish upon a heterolist
22:19:26 <EvanR> > show (3, "foobar")
22:19:29 <lambdabot>  "(3,\"foobar\")"
22:19:37 <EvanR> :t print (3, "foobar")
22:19:39 <lambdabot> IO ()
22:19:46 <mnoonan_> fearless_man: in that case, in haskell, you’d probably just put the string value of each item so that you had a uniform list of strings, like [show 3, “foo”] —> [“3”, “foo”]
22:20:01 <EvanR> i debug print tuples a lot
22:20:05 <EvanR> but not heterolists
22:20:42 <erisco> fearless_man, there are books for beginners which will walk you through the basics with examples
22:20:53 <ab9rf> :t [Left 3, Right "foobar"]
22:20:53 <fearless_man> erisco: cool let me know
22:20:54 <lambdabot> Num a => [Either a [Char]]
22:21:16 <ab9rf> heh, love haskell polymorphic numbers
22:21:24 <erisco> fearless_man, https://www.haskell.org/documentation at the top
22:21:24 <EvanR> for the use case exemplified... a list is not necessary
22:21:51 <fearless_man> cool
22:21:53 <EvanR> in python the weird distinction between tuples and lists is mutability
22:22:05 <EvanR> so if you dont care about mutability, they are interchangable
22:22:19 <EvanR> so its weird
22:22:20 <fearless_man> EvanR: yeah
22:22:31 <erisco> fearless_man, http://haskellbook.com/ is the new hotness but the authors would like some compensation for their time
22:23:15 <EvanR> in haskell the weird distinction is that tuples of different lengths have totally different types and are incompatible
22:23:27 <EvanR> so its weird
22:23:42 <ab9rf> tuples are a sort of weird stepchild type at times
22:23:52 <erisco> nested 2-tuples is where it is at
22:24:14 <EvanR> theres no one size fits all way to do (3,"foo") + (True, Nothing) to get (3,"foo",True,Nothing)
22:24:43 <EvanR> a nice record system would cover this!
22:24:52 <fearless_man> ok guys, thanks for your time, I'm go ahead and learn me some basic haskell
22:25:11 <erisco> that's why you do nested 2-tuples ... we had to munge tuples in my intro to FP ... was annoying
22:25:14 <fearless_man> *I'll
22:25:24 <erisco> a function per tuple length, ugh... was doing relational algebra
22:25:39 <erisco> project_1_from_3, project_2_from_3, project_3_from_3
22:25:42 <erisco> lots of fun
22:25:54 <EvanR> the HList solutions are kind of a hairy shirt
22:28:47 <EvanR> erisco: yeah the point at which your set theory or relational algebra produces a record (tuple with named fields!) is where you want a good extensible record 
22:29:47 * hackagebot separated 0.2.0 – A data type with elements separated by values – https://hackage.haskell.org/package/separated
22:32:02 <erisco> quite the logo on their package page
22:33:45 <erisco> not sure about the name because then it either includes leading or trailing separators
22:34:44 <ab9rf> that's a bit large
22:36:02 <EvanR> so their data structure is like... 1, 2, 3, 4, 
22:36:09 <EvanR> i totally agree with this
22:36:59 <erisco> 1:2:3:4:[]:
22:37:03 <ab9rf> pesarated
22:37:17 <EvanR> the [] is silent
22:37:22 <EvanR> 1:2:3:4:
22:37:53 <erisco> *shrug* okay... lots of things allow trailing separators so I am sure it has plenty of use in whatever they're doing
22:38:12 <EvanR> i decided to do somethig like that earlier
22:38:28 <erisco> it just isn't separating anything, y'know?
22:38:55 <EvanR> you can then use a comma to construct pairs... 1,2  = (, 1 2)
22:39:06 <EvanR> or to build a sequence
22:39:13 <erisco> wouldn't it be 1,2, ?
22:39:46 <Donovan> any luck erisco? :)
22:39:48 <EvanR> 1,2,3,4, = (, 1 (, 2 (, 3 (, 4 empty))))
22:40:04 <nshepperd_> Csiro has Haskell users huh
22:40:05 <EvanR> 1, is the singleton :)
22:40:19 <EvanR> blank is empty
22:40:28 <erisco> Donovan, thanks for reminding me... looking
22:41:15 <erisco> Donovan, what is grad? I don't see the definition for it
22:41:31 <Donovan> it's in the comments, i typed :t grad in ghci
22:41:45 <Donovan> sorry, in the annotation? can you see that? I've never used lpaste before
22:42:02 <Donovan> it comes from the ad packages
22:42:19 <erisco> Donovan, okay, I see the type of it down there, thanks
22:43:19 * hackagebot separated 0.2.1 – A data type with elements separated by values – https://hackage.haskell.org/package/separated
22:43:24 <erisco> Donovan, yeah, so there is special support with function application for dealing with RankNTypes
22:43:49 <Donovan> ok? I don't even know what RankNTypes really does, GHCI just asked me to use it =/
22:45:06 <Donovan> oh, it allows the foralls
22:45:22 <erisco> let me try and make a small example for you
22:45:24 <Maxdamantus> It makes it so values can have foralls.
22:45:40 <dibblego> nshepperd_: http://qfpl.io/ is under CSIRO
22:47:31 <Donovan> cheers erisco 
22:47:52 <Axman6> nshepperd_: there's dozens of us
22:48:00 <Axman6> or, like a dozen
22:48:11 <nshepperd_> Hehe. Cool
22:48:42 <mnoonan_> Donovan: does it work if you replace the [[a] -> a] in fList’s type with [forall a. [a] -> a] ?
22:50:53 <erisco> all impredicative like?
22:50:53 <Donovan> not like that mnoonan_, it says: Illegal polymorphic type: forall a1. [a1] -> a1
22:50:56 <Donovan> GHC doesn't yet support impredicative polymorphism
22:51:18 <mnoonan_> i like the “yet”, optimistic :)
22:57:39 <saurabhnanda> is there anything better than digestive functors for validations?
22:58:08 <saurabhnanda> better = easier to use with validating incoming JSON for a typical webapp backend API
22:59:52 <Axman6> I just use servant if it's going to be mostly json stuff
23:00:37 <Donovan> erisco: so what is this 'special support'? I don't think I can get by without RankNTypes
23:02:34 <Donovan> hmm, changing to Rank2Types didnt help either
23:02:48 <saurabhnanda> Axman6: what about simple (non-DB) validations after parsing? like length, email format, etc
23:03:57 <Donovan> actually, even if i remove RankNTypes and just import Numeric.AD i get the same error
23:07:10 <erisco> I actually don't know how to get the type of grad to check
23:07:50 <Donovan> damn
23:08:01 <erisco> anyways, there is some stuff that works when you use function application, i.e. f x, that doesn't work when you have to unify f with, say, a -> b
23:08:24 <erisco> so if you pass it to a higher order function, such as map, or a list comprehension (it is being done with >>=), then the types won't work
23:08:43 <erisco> beyond that I am unable to reproduce the exact problem here... talk to ekmett
23:09:27 <erisco> aka edwardk
23:09:46 <glguy> newtype Fun = Fun (forall a. (Num a, Ord a) => [a] -> a)
23:09:52 <glguy> >>> :t [ grad f | Fun f <- fList ]
23:09:52 <glguy> [ grad f | Fun f <- fList ] :: (Ord a, Num a) => [[a] -> [a]]
23:10:29 <erisco> when I just give minimal definitions so I can copy/paste the grad type sig into my program, ghci complains it is impredicative
23:10:31 <glguy> Once you wrap up your functions like test1 and test2 in the Fun newtype, you can make a list of the polymorphic functions
23:10:53 <glguy> http://lpaste.net/357408
23:15:33 <glguy> Donovan: Updated with a couple more things http://lpaste.net/357409
23:15:49 <Donovan> cheers glguy 
23:16:32 <erisco> I think I screwed up diagnosing where the problem was... thankfully we have glguy
23:16:56 <Donovan> still getting the same error =/
23:17:27 <glguy> the stuff I pasted loads in GHC
23:17:35 <Donovan> hang on
23:18:54 <Donovan> ahh it works!
23:18:59 <Donovan> thanks glguy 
23:19:14 <Donovan> now, would someone mind explaining to me why this suddenly works? :)
23:19:59 <erisco> grad requires a function which works with the forall, but lists don't contain stuff with a forall
23:20:22 <erisco> so grad wants it to work on any type and you are giving it a list of stuff that works on only one type
23:20:39 <erisco> that is why glguy added the wrapper which retains the forall on the items going into the list
23:21:25 <glguy> more generally than list, you can't instantiate a type variable with a quantified type
23:22:03 <erisco> now why does the head of the list work...
23:22:10 <Donovan> alright, so im still new, and not familiar with the syntax you use inside newtype, it looks like you're creating a..function?
23:22:28 <Donovan> no, a type?
23:22:35 <Donovan> you can specify types inline?
23:23:14 <erisco> newtype is defining a type... it is all types
23:23:30 <Donovan> works = [ grad f | Fun f <- fList ] so you're forcing f to be of type fun here?
23:23:44 <glguy> I'll let erisco explain the newtype, I'm on my phone
23:24:21 <c_wraith> Donovan: that's a pattern match
23:24:54 <Donovan> sorry c_wraith, what is? the list comprehension? or the Fun f part of it?
23:25:07 <c_wraith> Donovan: the Fun f
23:25:43 <erisco> I pass it to c_wraith... I am outta here soon
23:25:46 <c_wraith> Donovan: you can put a pattern to the left of the <-, as long as it's for the type of the elements of the list
23:26:36 <Donovan> so i can read it like "draw f from fList only where f is of type fun?"
23:26:38 <c_wraith> > [ show a ++ b | (a, b) <- zip [1..] "hello" ]
23:26:41 <lambdabot>  error:
23:26:41 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
23:26:41 <lambdabot>      • In the second argument of ‘(++)’, namely ‘b’
23:26:55 <c_wraith> > [ b : show a  | (a, b) <- zip [1..] "hello" ]
23:26:57 <lambdabot>  ["h1","e2","l3","l4","o5"]
23:27:06 <glguy> erisco: the head case worked because the whole value. (head fList) is polymorphic
23:27:31 <glguy> the elements all had the same mono type
23:27:45 <c_wraith> Donovan: it isn't a type annotation.  It's a destructuring operation.  "Match the constructor named Fun, name its first argument f"
23:28:17 <Donovan> i have no idea =/
23:28:59 <erisco> fst (a, b) = a -- that is an example of pattern matching
23:29:34 <erisco> unFun (Fun f) = f  -- same dealio
23:29:38 <Donovan> i thought patten matching was the stuff inside the "case x of" statements
23:29:46 <c_wraith> > let f xs = [ x | Just x <- xs] in f [Just 1, Just 2, Nothing, Just 3]
23:29:48 <lambdabot>  [1,2,3]
23:29:50 <erisco> yeah, it is another notation for the same thing
23:30:00 <erisco> fst ab = case ab of (a, b) -> a
23:30:08 <c_wraith> Pattern matches can be used syntactically just about anywhere that you can bind a name.
23:30:21 <Donovan> oh, man that's confusing
23:31:47 <erisco> c_wraith, I didn't know you could do that... gotta check how that desugars
23:31:53 <c_wraith> Donovan: well, it turns out to be fewer special cases.
23:32:14 <c_wraith> erisco: if the pattern doesn't match, it just tries the next element of the list.
23:33:31 <Donovan> well thanks either way c_wraith, glguy and erisco, i've been stuck on this one all day! At least I can keep going ahead now, and hopefully understand some of the finer points with time
23:33:41 <erisco> xs >>= \x -> case x of Just x' -> return x'; _ -> mzero   ?
23:34:16 * frerich hopes that Stephen Diehl eventually decides to write a Haskell book
23:34:38 <erisco> > [Just 1, Just 2, Nothing, Just 3] >>= \x -> case x of Just x' -> return x'; _ -> mzero
23:34:40 <lambdabot>  [1,2,3]
23:34:44 <c_wraith> erisco: I'm not sure comprehensions desugar to using >>= internally - but yeah, that's the right logic
23:34:48 <erisco> it works, at least, not sure if that is how it does it
23:35:20 <erisco> c_wraith, well I thought it was generalised to monads, but I would think you need mzero here
23:35:48 <c_wraith> erisco: unless you enable -XMonadComprehensions, I'm pretty sure it uses list-specific desugaring
23:36:25 <c_wraith> erisco: if you do enable -XMonadComprehensions, all sorts of constructs can add extra constraints above just Monad
23:36:39 <frerich> erisco: It's not mzero, it's because of the definition of 'fail'
23:36:55 <erisco> yeah I suppose you need guard too for the conditions
23:37:49 <erisco> frerich, oh... I did not know this gremlin existed
23:38:35 <frerich> erisco: [ x | Just x <- xs] desugars to 'do Just x <- xs; return x' and https://en.wikibooks.org/wiki/Haskell/do_notation#The_fail_method explains that in 'do' notation, if a pattern match fails, 'fail' is called. And fail for lists is '[]': https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#fail
23:39:05 <erisco> well I'll be damned... and here I would have thought the program would explode
23:39:06 <jared-w> Isn't the definition of fail the reason for the whole MonadFail typeclass and the whole convolted process to phase out fail in the Monad class?
23:39:11 <erisco> kind of a pity it doesn't
23:41:40 <frerich> erisco: I think it's actually very convenient in the context of list comprehensions.
23:44:40 * jared-w adds this to list of reasonns why list comprehensions are stupid
23:45:08 <frerich> erisco: I remember using it to very neatly define a function which gets you the local maxima, i.e. given a list of numbers, find all numbers which are larger than the immediate predecessor and the successor. So 'f [4,6,2,3,4,1,5,3]' gives '[6,4,5]'.
23:46:08 * hackagebot miso 0.5.0.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
23:46:43 <erisco> useful sure but it is a wart being in the Monad type class
23:47:22 <saurabhnanda> does anyone know if Aeson collects all parsing errors or bails on the first one? Is it possible to make it continue and report all errors?
23:48:46 <pacak> saurabhnanda: Are you sure you want to see 100500 different syntax errors or just the first one, when you forgot one "?
23:49:32 <saurabhnanda> pacak: not really expecting malformed json. I want to write a validating parser, where basic validations on individual json fields are done (eg. length/format checking, numeric range checking, etc)
23:50:15 <erisco> no idea about Aeson but generally speaking recovering from a syntax error is tricky
23:50:23 <erisco> though maybe it is more well developed than I know of
23:50:43 <erisco> for example, if someone opens a quote but fails to close it, is the rest of the document a string?
23:51:11 <erisco> and so similarly for anything between braces... is everything supposed to be part of that structure?
23:52:05 <erisco> and there is a question of how exactly you back up from the failure point
23:52:15 <pacak> Parser uses MonadPlus interface and it ignores braches with errors - failing when there's no more  branches to ry.
23:52:41 <erisco> you may need some of what you've partially consumed to get past the error, or at least in the best way
23:53:55 <saurabhnanda> erisco: assuming that it parses to a Value first (which means no syntax errors)
23:53:58 <pacak> So you either implement a separate pass over your data structure using monadwriter or implement your own monadplus with slightly different sematics
23:54:28 <saurabhnanda> is this how aeson works: json string => Value => custom type?
23:54:39 <erisco> yeah but you could already be at a point of no return
23:55:11 <erisco> say you have "a" S as a prefix of a production, and you've found the "a" and now you need to find an S
23:55:15 <erisco> but none of the S's work
23:55:27 <erisco> well, the error might be that there wasn't supposed to be an "a" there!
23:55:31 <pacak> operational-monad might help
23:55:46 <erisco> or it could be that there is junk after the "a", dunno
23:56:35 <erisco> ultimately what you could do is parse every subsequence of the input
23:56:52 <erisco> then from that, by some measure, find the parse which has least errors
23:58:47 <erisco> I guess you can reason that if no S works, and this is the only production for an "a", then "a" must be the error
23:59:26 <erisco> therefore skip and keep going... now I want to implement a parser that does this :3
