00:00:28 * hackagebot hw-xml 0.1.0.0 – Conduits for tokenizing streams. – https://hackage.haskell.org/package/hw-xml
00:25:23 * hackagebot lucid-extras 0.1.0.0 – Generate more HTML with Lucid – https://hackage.haskell.org/package/lucid-extras
01:36:23 <saurabhnanda> in cabal/stack is the 'library' automatically treated as a dependency of every executable? what if I want to compile an executable that doesn't depend on the library?
01:40:36 <jle`> in cabal you need to explicitly add the library as a dependency for an executable
01:40:40 <jle`> i believe
01:48:08 <boj> yup. you don't even have to define a library, just the executable section
01:48:23 <zekt> Hi guys, I m using Existential Quantification to define a List like this
01:48:24 <zekt> data MyList = EmptyList | forall a. Succ (Val a) MyList
01:48:24 <zekt> but I can't pattern match on Val a anymore, may I ask where's my problem?
01:48:35 <jle`> zekt: well
01:48:38 <jle`> Val is not a constructor
01:48:43 <jle`> it's a type
01:48:54 <jle`> are you pattern matching on the constructors of Val?
01:49:01 <zekt> yes
01:49:18 <jle`> what is the error you are getting?
01:50:15 <jle`> can you make a small self-contained example of the problem?
01:50:44 <jle`> it's hard to know what your problem is without seeing any code
01:51:00 <cocreature> unless Val is a GADT, existential quantification is probably not going to be useful here
01:51:06 <zekt> Ok my bad
01:51:11 <zekt> Yes Val is a GADT
01:51:38 <jle`> yes, knowing the actual error would be helpful
01:51:59 <jle`> it might not even be related to the pattern match
01:52:28 <jle`> you might have just left off a -> :)
01:52:40 <jle`> it could be a syntax error, or you might be loading the wrong file?
01:53:36 <jle`> also you can't do let/lambda/function-style pattern matches on GADTs in most cases
01:55:34 <zekt> I can construct a List like a = Succ (N 10) EmptyList
01:55:34 <zekt> but I can't get the value like case a of (Succ (N n) l) -> print n
01:56:00 <jle`> but,
01:56:06 <jle`>     what is the error?
01:56:28 <jle`>   this is the most important thing
01:56:37 <jle`> this should be the first thing you tell us :)
01:57:16 <jle`> there is no way for us to help you if you don't tell us your error
01:59:03 <jle`> i'm...assuming that you got an error of some sort
01:59:19 <jle`> maybe you are asking in a theoretical/philosophical capacity?
02:01:12 <zekt> sorry I messed up my ghci 
02:01:19 <zekt> trying to reproduce it
02:04:37 <zekt> https://pastebin.com/EH5LNh7w
02:04:37 <zekt> Here's what happened when I try to pattern match the value 
02:05:49 <jle`> ah yeah, this is an issue when ghci tries to infer what (case a of (Succ (N n) _) -> print n)'s type is
02:05:57 <jle`> you can just explicitly give it a type
02:06:01 <jle`> (case a of (Succ (N n) _) -> print n) :: IO ()
02:06:48 <jle`> this is what the cryptic 'Possible fix: add a type signature for ‘it’' part of the error message is suggesting; `it` is how ghci refers to the previous line
02:07:10 <jle`> if you were writing this in a normal source file then it would have given you a more useful name than 'it', heh
02:07:25 <jle`> ghci-isms i guess :)
02:07:36 <zekt> oh so I guess there's no problem of pattern matching
02:08:30 <jle`> well, the existential qualification in the constructor changes some of the typechecker rules for case statements/pattern matching
02:08:53 <jle`> *quantification
02:09:27 <jle`> but it isn't quite that you aren't allowed to pattern match, it's just that the typechecking works a bit differently
02:09:38 <zekt> thank you so much jle`, I just don't know how to read these bunch lines of errors
02:09:38 <jle`> this problem comes up a lot less in actual source code
02:09:57 <jle`> no problem!  usually i just skip to 'Possible fix:', if i see it :)
02:10:40 <jle`> but yeah, this comes up a lot less in normal source code because ghc can usually infer the type of what is expected out of the case statemen better
02:10:53 <jle`> cause you usually actually *use* the thing that you return in your case branches
02:11:13 <jle`> and so ghc can infer the type of the whole `(case ... of ... -> ...)` expression
02:11:33 <jle`> in this case, in ghci, it's completely polymorphic, and can be anything, so that leads to some of the complications
02:12:39 <nshepperd_> Type inference is limited for GADT pattern matching
02:24:03 <nshepperd_> If you see Int in the type of a case branch, and that branch's pattern refines some type variable b to Int, the type of the whole case statement could have b or Int there
02:25:21 <nshepperd_> I think ghc deals with this by just not doing type inference across a GADT pattern match
02:36:58 * hackagebot orgmode-parse 0.2.0 – A collection of Attoparsec combinators for parsing org-mode flavored documents. – https://hackage.haskell.org/package/orgmode-parse
02:49:07 * hackagebot sdl2-ttf 2.0.0 – Bindings to SDL2_ttf. – https://hackage.haskell.org/package/sdl2-ttf
03:32:26 <thorsten`> What's the syntax for the contravariant hom functor in haskell? The syntax (->Int) does not seem to be valid and ((->) Int) is the covariant hom functor
03:33:06 <Guest88506> Ciao!!!!!!
03:33:14 <Guest88506> !list
03:35:22 <merijn> thorsten`: You can't partially apply (->) in that way
03:35:32 <merijn> thorsten`: You could define a type synonym, I suppose
03:37:53 <cocreature> you can’t partially apply type synonyms so that doesn’t really help here
03:38:05 <merijn> I know
03:38:38 <thorsten`> so it seems I really have to 'newtype' it, and that's what https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#g:6 is doing
03:38:49 <cocreature> yep
03:39:53 <thorsten`> (I first tried 'type Op a b = b -> a' but then 'Op a' got rejected because 'Op' expected two arguments)
03:40:53 * hackagebot hmatrix-morpheus 0.1.1.0 – Low-level machine learning auxiliary functions. – https://hackage.haskell.org/package/hmatrix-morpheus
03:40:54 <thorsten`> Sorry for the question, I guess, you'll hear it quite regularly :)
03:43:16 <cocreature> nothing to apologize for, it’s a reasonable question :)
04:08:06 * hackagebot sdl2-ttf 2.0.1 – Bindings to SDL2_ttf. – https://hackage.haskell.org/package/sdl2-ttf
04:31:49 <athan> is there a pipes or conduit producer for a file which gets appended to, for logfile parsing?
04:33:06 <merijn> athan: Appended from a single process?
04:33:41 <athan> merijn: Eh yeah, but couldn't you receive updates from fs-notify?
04:33:41 <merijn> athan: Oh, you mean you want to block in a conduit/pipe until input is ready to consume further?
04:34:04 <athan> maybe the assumption that the file is monotone appended could help or something
04:34:28 <athan> yeah exactly merijn - are pipes and conduit pull-based?
04:35:18 <athan> hmm I wonder if a Handle position could just be kept, then scanning proceeds on fsnotify
04:35:25 <merijn> athan: pipes can be push or pull
04:35:30 <athan> oh wow
04:35:34 <merijn> athan: I think conduit is always pull?
04:37:25 <merijn> athan: The real problem is that read always returns succesfully with EOF when you hit the end-of-file
04:37:29 <merijn> Else it'd be easy
04:39:32 <merijn> athan: Do you control the log writer?
04:39:38 <athan> merijn: ehhh I'll see what I come up with. Thanks!
04:39:50 <athan> nah I don't - that's why I'm going to use fsnotify, hopefully
04:40:01 <merijn> athan: Not even which file it writes to?
04:40:20 <athan> oh well yeah there's that
04:40:41 <merijn> athan: If you can get it to write to a namedpipe (or anonymous pipe, for that matter) then the whole problem becomes trivial
04:40:59 <merijn> athan: Because those won't hit EOF until the writer exits, so you can just blocking stream like a file
04:41:19 <merijn> athan: I'd try that first before using fsnotify
04:41:36 <Fuuzetsu> combine with ‘tee’ for best results
04:43:12 <athan> merijn: Ahh I think I see what you mean - so just use a domain socket? I was thinking of that too
04:44:03 <wz1000> how do i build haddocks for all dependencies with cabal?
04:49:25 <kuribas> wz1000: I have documentation: True in ~/.cabal/config
04:54:00 <wz1000> I'm looking for a command that will build the docs for a project and all its dependencies
04:54:06 <wz1000> like stack haddock
04:54:35 <Athas> wz1000: so why not use stack haddock?
04:56:41 <wz1000> Athas: because I want to work with a plain cabal project
04:57:18 <Athas> It might be easiest to make a quick stack.yaml.  It's not invasive at all.
04:59:07 <wz1000> that is not the point. I'm working on something that works with both stack and cabal projects
05:04:07 <wz1000> s/works/should work
05:05:36 <Fuuzetsu> ‘cabal haddock’ is it not?
05:06:51 <Fuuzetsu> Perhaps you'll need to set haddock on in config file and rebuild deps or something.
05:07:55 <wz1000> as far as I can tell, cabal haddock only builds haddock for the current project
05:08:50 <Fuuzetsu> right, I don't think there's a flag to rebuild dependencies with haddock on unlike in stack
05:10:56 <cocreature> wz1000: you need to install dependencies via "cabal install --enable-documentation"
05:11:04 <cocreature> or set "documentation: True" in your cabal file
05:11:58 <wz1000> is there any command I can use to rebuild everything with docs?
05:12:07 <cocreature> afaik no
05:13:16 <[exa]> Hm guys, do you know about any conference posters about functional programming? My problem: posters are meant to be colorful & picture-ish, but well, deduction rules aren't a good pic. So I'm kindof searching for what the others would use.
05:13:50 <`Guest00000> replace symbols in the deduction rules by shiny things
05:15:21 <[exa]> I kindof wanted to include cake since there's a bit of linear logic, but I can't top this guy https://youtu.be/ij9DbNTr-B8?t=30s
05:15:56 <wz1000> anyone familiar with haddock internals here? I have a couple of questions
05:25:14 <erisco> "why should I use it?" questions are weird
05:25:22 <Fuuzetsu> wz1000: I am. Ask away.
05:26:29 <wz1000> Fuuzetsu: How do I get the module the documentation for a name lives in? Is the LinkEnv supposed to contain it?
05:28:01 <wz1000> 'map' is defined in GHC.Base, but its documentation lives in Prelude
05:31:27 <wz1000> Fuuzetsu: also, what is the structure of ArgMap? The Int indexes are the argument position?
05:31:35 <wz1000> where does the result type go?
05:34:18 <alexbiehl> wz1000 yes, it is the last one in ArgMap
05:34:23 <alexbiehl> the result type
05:36:41 <wz1000> alexbiehl: ok, thanks
05:37:27 <alexbiehl> wz1000 you are working on a contribution to haddock? 
05:38:55 <wz1000> my problem now is figuring out where the documentation for a name lives
05:39:12 <wz1000> alexbiehl: no, I'm working on haskell-ide-engine
05:39:37 <alexbiehl> I see, what is the big picture you are trying to achieve? 
05:39:57 <wz1000> alexbiehl: fetching docs for the symbol a user hovers over
05:40:57 * hackagebot hmatrix-morpheus 0.1.1.1 – Low-level machine learning auxiliary functions. – https://hackage.haskell.org/package/hmatrix-morpheus
05:41:46 <alexbiehl> do you create haddock interfaces for your source files on-the-fly? 
05:42:09 <wz1000> alexbiehl: no, those are supposed to be prebuilt by the user
05:42:30 <alexbiehl> Ah! So you are reading *.haddock files? 
05:42:35 <wz1000> yes
05:42:48 <erisco> why use 'Set a'? we already have 'Map a ()'
05:43:07 <zekt> https://pastebin.com/aiPwJgxX
05:43:08 <zekt> Hi, guys, I am defining my own list with Existential Quantification like in the pastebin, every element in a pair of String(Name) and value(Val a), but when I try to write a lookup function I got the errors, what am I doing wrong?
05:43:44 <cocreature> erisco: Map a () uses more memory
05:44:06 <erisco> oh cocreature why are you so crude
05:44:34 <cocreature> erisco: I’ve probably been exposed to too much C++, sry ;)
05:46:07 <cocreature> zekt: "lookupList :: String -> MyList -> Val a" says that the caller can choose an arbitrary a and you will give them something back of type "Val a"
05:46:55 <cocreature> zekt: but you can’t do that. you can only give him back something of type "Val a" for _some_ a (i.e. the one that’s existentially quantified)
05:47:24 <erisco> String -> MyList -> (forall a. Val a -> r) -> r
05:47:48 <cocreature> or "newtype SomeVal = SomeVal (Val a)" and then "String -> MyList -> SomeVal"
05:49:06 <cocreature> then you could also throw away your custom MyList type and just use [(String, SomeVal)]
05:49:37 <erisco> or newtype MyList = MyList [(String, SomeVal)]
06:03:28 * hackagebot structured-cli 0.9.0.3 – Application library for building interactive console CLIs – https://hackage.haskell.org/package/structured-cli
06:32:14 <trigone> hi! is there an instance of Arrow for (->)? i can't find it
06:33:07 <trigone> nevermind i found it... why was it called Arrow ((->) LiftedRep LiftedRep)?
06:39:50 <wz1000> alexbiehl: what is instSubMap?
06:53:20 <mrkgnao> trigone: if you understand kinds, (->) does not just have kind * -> * -> * 
06:53:31 <mrkgnao> * is the kind of "lifted types", like Int
06:53:41 <mrkgnao> there are also unlifted types, like Int#
06:54:03 <mrkgnao> and (->) is polymorphic in "liftedness" (which is called levity)
07:00:18 <alex-v> is ghc.haskell.org down?
07:00:52 <erisco> if you can't reach a website, does it exist?
07:01:44 <erisco> it is not responding for me either
07:08:14 <WinterFox[m]> What is an integral in haskell?
07:08:38 <erisco> WinterFox[m], a type class for integral types
07:08:56 <WinterFox[m]> What data do those types hold?
07:09:07 <erisco> numbers, particularly integrals
07:09:16 <erisco> such as 1, 2, 3
07:09:29 <erisco> maybe -1, -2, -3
07:09:33 <WinterFox[m]> How is it different to int?
07:09:46 <kuribas> WinterFox[m]: Int is a type, Integral a typeclass
07:09:51 <erisco> Int is a type, Integral is a type class, Int is a instance of Integral
07:10:24 <kuribas> WinterFox[m]: For example you have Integer, an unbounded integer, Word, a bounded unsigned integer, etc...
07:10:32 <bollu> https://github.com/bollu/tiny-optimising-compiler/blob/master/src/IR.lhs#L55 <- how do I write this nicely?
07:10:33 <kuribas> WinterFox[m]: they are all instances of Integral
07:10:38 <bollu> I keep having to pattern match and extract left and right
07:11:25 <erisco> bollu, maybe uniplate? I haven't played with it yet
07:11:41 * WinterFox[m] uploaded an image: photo_2017-08-27_23-37-49.jpg (30KB) <https://matrix.org/_matrix/media/v1/download/matrix.org/jxcODUUpRsRYSEBZKvOBWFyE>
07:11:49 <WinterFox[m]> wrong chat sorry
07:12:01 <bollu> erisco does it let you reduce things like this?
07:12:12 <bollu> erisco I don't really understand what problem uniplate tries to solve
07:12:25 <bollu> erisco the last time I drank a library kool-aid, I ended up with lens-o-rama :) 
07:12:26 <erisco> it generates common functions to manipulate data, as far as I understood it
07:12:32 <bollu> erisco I see. let me take a look
07:13:43 <kuribas> bollu: that doesn't look to bad
07:14:10 <bollu> kuribas There is a bug there, where I wrote InstStore as InstAnd on the RHS
07:14:21 <bollu> kuribas I dont' want boilerplate errors :) That prompted the question.
07:15:26 <[exa]> bollu: abstract out the shared <$> (.. lhs) <*> ..rhs.. ?
07:15:46 <bollu> [exa] I suppose, but I wanted some way to auto generate the data constructor names.
07:15:55 <bollu> [exa] I suppose uniplate is what I need to look at.
07:16:44 <kuribas> bollu: perhaps Inst = InstBin Op Value Value | InstUn Op Value?
07:16:57 <bollu> kuribas hm, yes, that seems reasonable
07:17:10 <bollu> kuribas I wish there was some way to enforce multiple "hierarchies"
07:17:15 <bollu> on the same underlying type
07:17:30 <bollu> I would also want to enfore something like Inst = InstBinArith .. | InstBinLogical ... | ..
07:17:37 <bollu> so depending on the situation, I want different "slices"
07:17:50 <bollu> (is there a lens for that?) :) 
07:18:06 <kuribas> bollu: if Value was a type variable, you could auto-derive Applicative
07:18:36 <bollu> kuribas: ah, interesting idea
07:18:40 <[exa]> bollu: couldn't Inst be a functor?
07:18:56 <bollu> [exa] it already is a monofunctor
07:19:05 <bollu> [exa] "mapInstValue" is omap
07:20:02 <ggVGc> what's the cure for lens-o-rama? I think I might have it too
07:20:09 <[exa]> oh i see :D sorry
07:20:40 <ggVGc> lens made my haskell quite a lot more comfortable to write
07:20:47 <ggVGc> but I'd say I hardly get it
07:21:01 <bollu> ggVGc really? I think lens complicated the haskell I wrote.
07:21:18 <bollu> it reminds me of my flirtation with template metaprogramming. Elegant, but eventually...
07:21:35 <ggVGc> definitely made things more complex, but more enjoyable to produce
07:21:36 <ggVGc> imo
07:21:51 <ggVGc> that's a very good analogy :)
07:22:01 <ggVGc> but with both there's a good middle ground I feel
07:22:09 <kuribas> isn't the core idea of a lens to turn an effect over the subpart into an effect over the whole part.
07:22:16 <kuribas> ggVGc: ?
07:22:30 <ggVGc> sure
07:22:43 <ggVGc> but that doesn't mean it's simple
07:22:45 <bollu> kuribas the core idea of lens is that you can use something that is universally quantified over profunctors for crazy shit :P 
07:23:08 <ggVGc> bollu: i did start feeling a bit like lens kind of "breaks" haskell a bit
07:24:02 <kuribas> ggVGc: I find the core reasonably understandable, but the whole lens zoo is unwieldy.
07:24:23 <bollu> I love that derivation of the final type of Lens, but holy shit, whoever realised that: Store s a ~= forall f. Functor f => (a -> f a) -> (s -> f s)  Forall f. Functor f, forall p. Profunctor p => p (a) (f a) -> p (s) (f s) | is so cool
07:24:44 <bollu> kuribas I like the lens zoo the most. Too bad I can't use them well
07:24:47 <ggVGc> it's quite great tbh
07:24:56 <ggVGc> but also feels a bit like magic in practice
07:25:00 <ggVGc> even though I know it's not
07:25:35 <Welkin> supposedly it could just be profunctor, like the profunctor-lens library in purescript
07:25:41 <ggVGc> either way, I do feel lens in practice fixes some holes in haskell forme
07:25:51 <ggVGc> where I feel haskell is not really expressive enough
07:26:17 <ggVGc> at the cost of a fair bit of added complexity
07:26:18 <erisco> is there a conversion of typelit naturals to promoted Peano naturals that I am missing?
07:26:37 * ggVGc zones out at "peano naturals"
07:27:02 <erisco> singletons gives SNat as typelits, Data.Type.Natural gives SNat as Peano nats
07:27:29 <kuribas> ggVGc: or you could say that haskell is so expressive that you can build lens on top of it.
07:27:40 <ggVGc> yeah that's true
07:27:54 <ggVGc> but, that's a bit of a gray area
07:28:03 <erisco> ah ha, they are hidden back here https://hackage.haskell.org/package/type-natural-0.4.1.0/docs/Data-Type-Natural-Builtin.html
07:28:10 <ggVGc> kuribas: I could also argue that C is so expressive and type safe that I can build haskell with it
07:28:28 <Welkin> ggVGc: C is not expressive compared to asm
07:28:35 <ggVGc> fair
07:28:38 <ggVGc> my bad
07:29:46 <kuribas> ggVGc: I suppose you can build a haskell interpreter in unlambda...
07:30:25 <Welkin> write an interpreter using nothing but the S and K combinators
07:33:12 <trigone> hi! how do i choose the infix precedence of custom operators?
07:35:01 <c_wraith> trigone: I only care about that when I intend them to be used with other operators.  And when I do intend that, it follows pretty quickly from the precedences of the other operators
07:36:17 <Welkin> trigone: https://wiki.haskell.org/Keywords#infix.2C_infixl.2C_infixr
07:38:44 <mrkgnao> trigone: did you see my answer to your question about (->)?
07:39:34 <trigone> mrkgnao: oh no sorry!
07:39:54 <piyush-k`> Is there an easy may to make the code examples in haddock compiles? (i.e. without a cut paste). Ideally this should be part of the tests cases.
07:40:47 <piyush-k`> *compile
07:41:15 <c_wraith> piyush-k`: there is tooling for using doctests
07:41:33 <c_wraith> @hackage doctest
07:41:33 <lambdabot> http://hackage.haskell.org/package/doctest
07:42:21 <trigone> c_wraith: hm... k thx
07:42:50 <piyush-k`> c_wraith: super thanks
07:44:02 <trigone> if i want whatever operator (*) to group as such (a * b) * c, is it infixl?
07:44:32 <c_wraith> yes
07:45:17 <trigone> k thx. and if i want it to act at the same level as another operator, i choose the same precedence, right?
07:45:34 <c_wraith> yes
07:46:02 <trigone> thx :)
07:46:04 <mrkgnao> trigone: wait.
07:46:08 <mrkgnao> trigone: if you understand kinds, (->) does not just have kind * -> * -> * 
07:46:12 <mrkgnao> * is the kind of "lifted types", like Int
07:46:15 <mrkgnao> there are also unlifted types, like Int#
07:46:17 <mrkgnao> and (->) is polymorphic in "liftedness" (which is called levity)
07:46:34 <bollu> mrkgnao TIL what levity means
07:46:36 <mrkgnao> you should look for "levity polymorphism" if you'd like to know more
07:46:48 <bollu> mrkgnao so levity polymorhism is the ability to mix boxed and unboxed types?
07:47:25 <mrkgnao> yep
07:47:35 <mrkgnao> for more, https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-1.pdf
07:48:11 <trigone> mrkgnao: thx, i'll look into it! :) sorry again for earlier
07:48:17 <mrkgnao> sure
07:48:32 <mrkgnao> it's a very readable paper (speaking as someone with no formal CS training)
07:49:32 * hackagebot concrete-haskell-autogen 0.0.0.2 – Automatically generated Thrift definitions for the Concrete data format. – https://hackage.haskell.org/package/concrete-haskell-autogen
07:50:04 <Welkin> mrkgnao: your name looks too much like mr magoo
07:50:15 <erisco> there are more readable papers than I thought
07:50:29 <trigone> mrkgnao: yes it does look readable :) so in the end, it more or less says that the instance of Control.Arrow for (->) does not work for unboxed types?
07:51:00 <c_wraith> mrkgnao: formal CS training doesn't help with papers unless it's graduate training, for the most part :)
07:51:21 <mrkgnao> trigone: indeed, it only defines an Arrow instance for the version of (->) which applies to lifted types
07:51:42 <erisco> I think part of it is that there are papers written to impress and others written to be understood
07:52:18 <mrkgnao> c_wraith: but then I do a lot of gradish--level math on my own (I'm a freshman in college), so I'm happy following arguments of a certain nature
07:52:25 <mrkgnao> s/ish--/-ish-/
07:52:31 <trigone> mrkgnao: why though?
07:53:00 <c_wraith> mrkgnao: Yeah, reading academic papers is just a skill to learn.  You can learn it at most any time, you just need to want to. :)
07:54:41 <mrkgnao> I think it's because of the tuples, which need to be unlifted ... or something.
07:54:45 <trigone> the other day i have started reading the paper on bananas, envelopes, etc (recursive schemes). well the main issue is the absence of standards in the symbols: you never know if it's a function, a type, a function on types... it's much less normalized than in a programming language (at least than in haskell)... is it a generalized situation in math notation?
07:54:55 <trigone> mrkgnao: oh ok
07:54:59 <mrkgnao> I don't have a good enough grasp of boxing; you need to ask someone more knowledgeable about this stuff.
07:55:11 <c_wraith> mrkgnao: that's pretty much correct
07:55:37 <mrkgnao> trigone: isn't there a list of notation at the beginning? "Greek letters for this, lowercase for that, ..."?
07:55:52 <mrkgnao> c_wraith: it was a total guess etc
07:56:43 <trigone> mrkgnao: don't think so because i still haven't found the logic. i mean obviously there is a logic, but it's like twenty five rules...
07:57:45 <mrkgnao> with math papers the "this is familiar to readers" or "obvious argument" problems are more significant than underspecified notation, which is not usually that bad
07:58:41 <mrkgnao> I suspect PLT papers are hard notation-wise because they do both math notation and programming language syntax together. idk.
07:59:24 <erisco> I think it depends on how much in-group jargon there is
07:59:51 <erisco> a single phrase can send you on a wild goose chase
08:00:49 <c_wraith> The papers that really annoy me in CS are the ones that use greek identifiers and unicode operators in all their code samples, as if no one might ever want to type them in.
08:01:35 <erisco> ςηατ ισ ςρονγ ςιτη τηατ?
08:01:43 <MarcelineVQ> what gets me is when they use those letters but then call them by their written name in the text,. it's not common but it's like.. great, now​ I have to google these
08:02:24 <mrkgnao> erisco: lol, I've gotten similar results when I accidentally switched keyboards on my phone
08:02:29 <MarcelineVQ> is this phi or gamma or lowercase something
08:02:31 <trigone> yeah... and, well i think you get used to it, but the fact it's never mentioned if whatever expression is at the set/type level or at the value/function level, yet they'll reuse the same operator in both places... well that's a little scarce in hints. you never know where you stand just by recognizing whatever symbol...
08:04:13 <c_wraith> in other words, all hail papers that don't do those things! :)
08:04:28 <padre_angolano> νοτηινγ ρεαλλυ
08:07:53 <trigone> the translation is really arbitrary (w -> ς, h -> η)
08:08:47 <trigone> unless it's bc capital sigma looks like an askew W
08:16:03 <erisco> oddly *w is ς and *v is ω
08:20:18 <erisco> I asked you guys on -offtopic I think for a couple symbols which are not on the unicode charts
08:20:32 <erisco> it is annoying not to have any pronunciation of a symbol when reading
08:21:20 <erisco> turned out to be from some special latex font thingie
08:39:09 <Hafydd> https://puu.sh/xg0cQ/04839b156e.jpg
08:46:03 <erisco> I understand it except for the clouds. Halloween clouds?
08:46:36 <[exa]> cloud computing doesn't scare you?
08:50:44 <kuribas> is there a structure that allows O(log(n)) indexing, and O(log(n)) insertion, deletion and concatenation?
08:51:47 <erisco> trick or treat, give me something indiscreet, here is your receipt
08:52:06 <lavalike> kuribas: maybe https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html 
08:52:10 <[exa]> kuribas: tree where nodes that remember # of elems in left subtree
08:52:28 <[exa]> oh, s/that//
08:53:00 <kuribas> lavalike: oh right, sequence has indexing :)
08:53:13 <lavalike> (:
08:53:51 <kuribas> lavalike: that's exactly what I wanted :)
08:54:05 <lavalike> kuribas: delightful.
08:54:28 <[exa]> wow I thought sequence is something vector-ish. cool
08:56:53 <kuribas> [exa]: it's like a vector with efficient concatenation
08:58:27 <erisco> I don't think you can consider O(logn) indexing to be like a vector
08:58:52 <mrkgnao> kuribas: more like a linked list with efficient concatenation
08:59:14 <kuribas> mrkgnao: linked list has O(n) indexing
08:59:37 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #1
09:00:35 <erisco> however, we can divide ourselves into right and wrong camps of thought on the question
09:00:59 <kuribas> well, O(log(n)) is not much worse than O(1)
09:01:21 <monochrom> Instead, I divide thoughts into the falsifiable and the unfalsifiable.
09:01:22 <erisco> what? that's, like, infinitely worse
09:02:42 <Welkin> kuribas: linked lists are not meant to be indexed
09:03:20 <erisco> they're not good at random indexing
09:03:22 <monochrom> #FirstWorldProblem
09:03:28 <erisco> on the other hand, they work quite well for sequential indexing
09:03:38 <kuribas> erisco: how infinitely?
09:04:04 <erisco> kuribas, I'll start counting and get back to you on that
09:04:39 <Welkin> lists are great for control structures
09:04:48 <Welkin> they have limited usefulness as data structures
09:05:16 <kuribas> log(n) for n = number of atoms in the universe is about 272
09:06:06 <Welkin> that reminds me of how in lua (and all scripting languages) you only have one data structure: the table (hashmap)
09:06:25 <Welkin> in that case you don't really have any options
09:09:44 <Welkin> [exa]: Sequence is still my favorite data structure. It's a layer over finger trees
09:12:14 <erisco> I never thought to have a favourite data structure
09:13:05 <monochrom> It's OK. A lot of people have favourite TV shows but I don't have any either.
09:15:17 <erisco> I choose Data.Void just for the humour
09:15:33 <erisco> it is also the fastest data structure around
09:17:28 <monochrom> You have be a bit more precise on that. It is the fastest for mutator operations such as "insert an element".
09:17:51 <[exa]> well mine is that kind of tree that remembers node counts, but I just realized that doing binary search on indexable sequence is just O(log^2(n))
09:18:02 <kuribas> what's the advantage of a finger tree over a balanced binary tree?
09:18:49 <[exa]> kuribas: balanced binary is log(n)-times faster for doing binary search
09:18:53 <monochrom> Don't worry, polylog time is the next best thing after log time. :)
09:19:46 <[exa]> monochrom: people in the department next to mine consider log(log(n)) a problem, I'm biased :D
09:20:02 <monochrom> Aw
09:20:26 <kuribas> [exa]: well, if I have a balanced tree with random order.
09:20:56 <[exa]> kuribas: then the advantage is probably zero
09:21:09 <erisco> [exa], in what capacity is that a problem? I am curious
09:21:42 <[exa]> erisco: the professor there was doing some high magic with hash structures and algorithms
09:23:20 <kuribas> [exa]: O(1) prepend, append and view it seems.
09:24:50 <monochrom> kuribas: Perhaps concatenation shows a difference.
09:25:35 <kuribas> monochrom: O(log(min(n1,n2))), that's the same for a binary tree?
09:26:24 <monochrom> How do you concatenate two balanced binary trees and the result is balanced?
09:26:26 <[exa]> kuribas: O(1) prepend/append on _balanced_ tree shouldn't be possible afaik
09:26:39 <kuribas> monochrom: by balancing them? :)
09:26:39 <exio4> [exa]: I think he's talking about Sequence
09:26:57 <kuribas> I am
09:27:24 <[exa]> oic :D
09:27:25 <monochrom> That's a nop.
09:27:46 <monochrom> And I still have two separate trees not one.
09:28:31 <lavalike> akin to noop, it's a loop: Lots Of OPerations
09:28:42 <monochrom> haha
09:30:12 <kuribas> monochrom: I mean a binary tree as sequence, not as search tree...
09:30:23 <monochrom> I mean that too.
09:30:47 <monochrom> (Why else would I talk concatenation?!)
09:33:58 <monochrom> Do you actually know what "concatenation" refers to? Because the output is one tree, not a pluraity of trees. So if you say "balancing them" not "balancing it", it is already wrong.
09:34:18 <kuribas> monochrom: so you balance the first tree so that the last element is at root, then you make the second tree the child of the first.
09:34:34 <kuribas> monochrom: or in reverse (depending on which tree is the largest)
09:35:45 <monochrom> That's log( max (n1, n2) ), not min.
09:36:09 <monochrom> Or at least it sounds like so to me.
09:36:26 <kuribas> hmm, right
09:37:34 <monochrom> Also you should have said "rotate until" not "balance". Your first stage is the opposite of "balance".
09:38:30 <kuribas> yes, balancing should be after joining...
10:01:34 <monochrom> It may be lg(min) afterall.
10:02:19 <monochrom> The first stage can be made lg(min) by choosing the smaller tree to work on.
10:04:18 <monochrom> The second stage doesn't walk any whole path from root to bottom of the former larger tree.
10:04:59 <monochrom> Take for example the extreme case of having a root and its right subtree but no left subtree. (And the right subtree is already balanced.)
10:05:30 <monochrom> One or two rotations are enough to rebalance the whole thing. Because one rotation already moves about half of the nodes to the left.
10:05:44 <kuribas> Would it be possible to use sequence to implement editable transformations?
10:06:11 <kuribas> Say sequence a -> b, and when I replace some part of the sequence, only a part needs to be recalculated.
10:06:40 <kuribas> For example a text editor...
10:06:57 <monochrom> Err, no, in that extreme case it is lg(max). My initial hunch is right.
10:07:30 <kuribas> say "sequence Char -> sequence Position" where Position = (Int, Int).
10:07:51 <kuribas> Then editing some chars will only recalculate positions which are actually changed.
10:16:25 <epta> what is the best way to call `cabal new-build' automatically on filesave in vim?
10:18:25 <Welkin> epta: use a file watcher instead
10:18:31 <Welkin> and recompile on change
10:18:53 <Welkin> or use something like ghc-mod
10:19:16 <monochrom> Oh! That reminds me. Consider https://hackage.haskell.org/package/ghcid and see if you can add a hook to call "cabal new-build".
10:19:16 <liste> epta: set it as makeprog and https://stackoverflow.com/q/3732657/1283954
10:19:42 <epta> Welkin: is file watching stack-specific? Is ghc-mod compatible with ghc-8.2?
10:24:50 <cocreature> epta: ghcid -c "cabal new-repl" works
10:29:19 <epta> monochrom: cocreature: thanks, looks good
10:31:59 <sm> pro tip: entr is the best file watcher
10:33:04 <ggVGc> yep
10:33:12 <ggVGc> entr revolutionised my life a few years ago
10:33:22 <ggVGc> litrerally changed how I deal with using my computer
10:33:27 <ggVGc> on many levels
10:33:50 <ggVGc> although it's not perfect
10:33:56 <Welkin> https://github.com/clibs/entr ?
10:33:58 <sm> yeah I still find the cli slightly awkward.. but better than all the others
10:33:58 <ggVGc> I occasionally get issues wiht it with some programs
10:34:17 <sm> also a pity it can't run shell commands
10:34:23 <ggVGc> it can?
10:34:39 <ggVGc> entr -cr bash -c "foo && bar"
10:34:39 <sm> I mean, it can't run an arbitrary shell command line ?
10:34:47 <sm> hmm. Thanks!
10:34:56 * sm has much to learn
10:35:15 <ggVGc> I mean, yes, entr can't run an arbitrary command line. but you can just launch bash..
10:35:25 <ggVGc> the issue is that tie /_ shortcut doesn't work, which is a shame
10:35:30 <ggVGc> but it can be worked around
10:35:34 <ggVGc> I never really need that though
10:35:38 <Welkin> bash? who uses bash anymore!
10:36:00 <ggVGc> probably about 99.9% of *nix users
10:36:11 <duncan^> real power users use emacs as their shell
10:36:33 <duncan^> anyone else is literal human scum
10:36:39 <ggVGc> real power users seem a bit idiosyncratic then
10:36:51 <sm> real power users use fish inside emacs then run bash to get stuff done
10:37:01 <Welkin> I can't ever seem to use the emacs shell
10:37:03 <Welkin> I use fish
10:37:09 <duncan^> I joke. But it's fun to make a system that is just Linux+Emacs
10:37:13 <Welkin> once you experience fish (or similar) you can't go back to plain bash
10:37:15 <duncan^> Emacs can be our shell
10:37:18 <duncan^> Emacs can do init
10:37:23 <duncan^> Emacs can do other shit
10:37:26 <duncan^> Emacs is the shit
10:37:33 <ggVGc> there's quite a big difference between shell for interactive use and shell for scripting
10:37:33 <kuwze> I ran "stack install" but it didn't install to ~/.local/bin, in fact I don't even have a ~/.local/bin, just a ~/.local/share
10:37:36 <ggVGc> imo
10:37:41 <ggVGc> I'd never use anything else than bash for a script
10:38:01 <duncan^> it's just posix shell scripts with horrific things tacked on
10:38:13 <duncan^> isn't it great how bash depends on itself to be build?
10:38:13 <ggVGc> that's not the point
10:38:23 <ggVGc> the point is writing some automated tasks and just running them anywhere
10:38:24 <sm> kuwze: if it completed, it should have
10:38:40 <ggVGc> duncan^: same goes for quite a bit of software
10:38:43 <ggVGc> how do you build ghc?
10:38:47 <Welkin> ggVGc: you mean, anywhere bash is installed
10:38:50 <kuwze> sm: yeah, it completed but nothing was written there
10:38:57 <ggVGc> Welkin: which is any *nix system practically
10:39:00 <duncan^> Well, if "anywhere"  means where bash is installed, then sure
10:39:10 <duncan^> eh, the BSDs don't have it
10:39:12 <sm> kuwze: disk full ?
10:39:17 <duncan^> embedded devices don't have it
10:39:24 <sm> bad permissions ?
10:39:26 <duncan^> my android phone doesn't have it
10:39:28 <duncan^> etc
10:39:30 <kuwze> sm: nope, turns out I'm an idiot
10:39:36 <ggVGc> fair
10:39:40 <dsal> I've only used bash for a script once. I used to use systems that didn't have it and was always annoyed that people wrote plain sh scripts that started with #!/bin/bash
10:39:41 <sm> you're an idiot ? aha :)
10:39:46 <sm> j/k
10:39:52 <duncan^> It's genuinely not nice to program in
10:40:02 <duncan^> and it does not give helpful error codes
10:40:09 <Welkin> ggVGc: "write once, run anywhere!" ™
10:40:17 <Welkin> that worked out great for java
10:40:28 <sm> there is a haskell EDSL for generating bash scripts
10:40:31 <duncan^> java's latest,um "collection" of CVEs was interesting
10:40:54 <iqubic> What is a CVE?
10:40:58 <sm> bash is a deployment language, like javascript
10:41:01 <monochrom> dsal: Lately ubuntu's sh (dash) dropped the pushd and popd commands, so I really switched to bash.
10:41:28 <geekosaur> iqubic, Common Vulnerabiltties and Exposures report/database
10:41:31 <ggVGc> yeah, I try to mostly stick with sh
10:41:36 <ggVGc> but sometimes I really need something from bash
10:41:39 <sm> or is sh that.. (so confused)
10:41:39 <dsal> monochrom: scripts specifically... I didn't use sh for interaction.
10:41:43 <monochrom> But I hear you. I try to stick to "#! /bin/sh" until I really want a bash feature.
10:41:49 <duncan^> iqubic: Common Vulnerabilities and Exposures
10:41:50 <ggVGc> but I think using somethin less common is irresponsible
10:41:57 <ggVGc> unless it's really only for yourself
10:42:05 <monochrom> Yes, I have a script that calls pushd and popd!
10:42:19 <duncan^> "irresponsible" <- lolwut
10:42:20 <dsal> Neat
10:42:37 <duncan^> I am irresponsible for using a differnent shell? ;;
10:42:44 <monochrom> And it worked in /bin/sh last year! Just not this year!
10:43:22 <ggVGc> depends on context as I said. If it's for personal stuff, sure, it doesn't matter. But if it's anything anyone else will be interacting with or maintaining, I think play sh or bash scripts is where it is
10:43:26 <ggVGc> there's value in common ground
10:43:28 <duncan^> monochrom: problem with that is that /bin/sh is often aliased or symbolically linked to bash or something like dash (which has certain bash extensions)
10:43:40 <iqubic> What even is dash?
10:43:43 <sm> yes exactly.. sh varies
10:43:53 <iqubic> dumb-bash??
10:43:54 <ggVGc> iqubic: one of the only actually used implementations of sh
10:44:01 <duncan^> so surely the argument should be just to use standard posix funcitons, then it literally runs anywhere with a posix-compliant shell
10:44:02 <sm> bash, less so
10:44:02 <ggVGc> since actual sh isn't available basically anywhere anymore
10:44:17 <monochrom> Yes duncan^, but on ubuntu it has been dash for years (and still is now, so I guess dash dropped it recently?)
10:44:20 <duncan^> rather than "use bash for muh standards"
10:44:34 <Welkin> I've heard this "posix-compliant" argument before
10:44:43 <monochrom> Hmm does posix has pushd and popd?
10:44:46 <Welkin> but then someone always points out that bash is not even posix-compliant
10:44:55 <duncan^> that's the point though
10:44:58 <ggVGc> personally fish rubs me the wrong way by having a web configuration interface
10:44:58 <duncan^> bash isn't
10:45:03 <Welkin> no one is posix-compliant
10:45:07 <ggVGc> I don't like the idea of my shell having a web server
10:45:12 <Welkin> who cares? Just install the shell that does what you need it to do
10:45:13 <duncan^> mksh is, to my knowledge
10:45:30 <duncan^> and busybox's sh
10:45:50 <duncan^> maybe the argument should be "don't use bashisms if you're going to share your script"
10:46:08 <Rembane> Why do you program in *sh? Why not use a nice language instead? Like Haskell.
10:46:14 <monochrom> stack scripts use stackism :D
10:46:54 <ggVGc> Rembane: because what I write in bash I'd not consider "programs" as such
10:46:54 <duncan^> because ghc is fucking huge :)
10:47:03 <monochrom> Rembane: Because I like pushd and popd. >:D
10:47:20 <Welkin> use lua then
10:47:26 <Welkin> it's *tiny*
10:47:27 <Rembane> All legit reasons. But still! :D
10:47:28 <Welkin> and very powerful
10:47:29 <hodapp> Use Hugs.
10:47:32 <hodapp> It's just a pile of C.
10:48:06 <ggVGc> Welkin: piping data between processes is a fair bit more cumbersome in lua than in bash
10:48:09 <ggVGc> or sh
10:48:13 <ggVGc> or whatever
10:48:16 <monochrom> There were two shell scripts that I replaced with Haskell programs, so there.
10:48:35 <hodapp> I once replaced a Lua script with 179 C++ classes, so there.
10:48:43 <hodapp> and a build system.
10:48:45 <monochrom> :S
10:48:55 <Welkin> hodapp: was that your decision?
10:49:00 <iqubic> Why? Just why?
10:49:11 <ggVGc> why did you stop at 179?
10:49:21 <hodapp> ggVGc: was trying to keep it minimal.
10:49:25 <ggVGc> fair
10:49:30 <monochrom> Because 178 was not enough and 180 was too many.
10:53:51 <Unode> how does one go about fixing http://dpaste.com/2045THJ ? I take it I need to add some type annotation but I'm not sure what and where.
10:54:33 <kuribas> Unode: there's only an error message...
10:55:26 <Unode> kuribas: the code is "outputListLno' InfoOutput ["Seeing:", show $ liftIO $ listDirectory $ dropFileName tpl_path]"
10:56:11 <dminuoso> ski, okay so it took me a while to realize why I was doing this because I could implement fix trivially without the Y combinator. :-)
10:56:18 <kuribas> Unode: a String and an IO String are not the same type
10:56:35 <dminuoso> This is really interesting stuff to understand recursion in terms of lambda calculus, it has a certain elegance to it
10:58:27 <Welkin> dminuoso: or using the S and K combinators
10:58:37 <kuribas> Unode: also show AnIOAction will not work
10:59:05 <Welkin> > show $ putStrLn
10:59:06 <Welkin> :D
10:59:07 <lambdabot>  "<[Char] -> IO ()>"
10:59:10 <Unode> kuribas: I'm trying to process that. I though liftIO was supposed to handle that part
11:00:12 <kuribas> Unode: you cannot go from IO a to a
11:00:26 <kuribas> Unode: well you can, but shouldn't
11:00:37 <geekosaur> no, liftIO gets you from the context of a monad over IO to IO. as a parameter top show, you are not in a monadic context
11:00:42 <geekosaur> *to show
11:00:46 <Welkin> anIOString >>= aString -> ...
11:00:46 <Welkin> :D
11:00:48 <geekosaur> you want >>=
11:01:15 <kuribas> Unode: but you can go from String to IO String using return or pure.
11:02:04 <Unode> kuribas: Thing is I'm using is outputListLno' function which I don't fully understand. It makes use of MonadIO among other things.
11:03:00 <kuribas> Unode: that's not a lot of information
11:03:13 <Unode> hold on
11:04:23 <Unode> https://github.com/luispedro/ngless/blob/master/NGLess/Output.hs#L129
11:05:07 <Unode> But in any case, I was wondering about the error itself. I don't know how to interpret that error message.
11:05:22 <Unode> How to go from that text to knowing what is incorrect.
11:05:33 <dminuoso> Welkin, yeah. I have a feeling it might be better to get a good book on LC, because this self-experimentation and learning might not be detailed enough
11:06:36 <Welkin> dminuoso: I just played around with S and K combinators using the wikipedia page
11:06:50 <Welkin> and then started playing with `fix` in haskell
11:08:12 <kuribas> Unode: so it wants a String, not a IO String
11:08:59 <Unode> kuribas: that's my understanding. But you just said I can't (shouldn't) get the string out of IO.
11:08:59 <dminuoso> Welkin, well I just lack a lot of the basic theory. Took me a while to understand what "free variable" really meant for example/.
11:09:20 <kuribas> Unode: do you know what Monads and Monad transformers are?
11:09:35 <Unode> Monads more or less. Monad transformers not yet.
11:09:54 <kuribas> Unode: then you'd better familiarize yourself before tackling that code...
11:11:25 <geekosaur> Unode, you dont get something out of IO, you bind pure code into IO
11:11:46 <geekosaur> this is done with the >>= operator or with fmap, or you can use do notation to pretend you're writing in an impure language
11:12:06 <geekosaur> do { x <- someIOAction; putStrLn (show x) }
11:12:09 <kuribas> Something like this: "do dir <- liftIO $ listDirectory $ dropFileName tpl_path; outputListLno' InfoOutput ["Seeing:", show dir]"
11:12:24 <Unode> geekosaur: the do notation gets me there. I have a working example. But I still don't understand what's going on :)
11:12:34 <Welkin> when talking about "pure code" it becomes confusing, because all haskell code is pure
11:12:40 <geekosaur> note that "do" does not let you arbitrarily do I/O, it just turns into uses of the >> and >>= operators
11:12:50 <geekosaur> @undo do { x <- someIOAction; putStrLn (show x) }
11:12:50 <lambdabot> someIOAction >>= \ x -> putStrLn (show x)
11:12:57 <kuribas> Unode: you should know the type of every part of that expression.
11:13:03 <kuribas> Unode: and understand it
11:13:24 <Welkin> it's more like IO and non-IO code
11:13:47 <Unode> the >>= operator I kind of understand. Instead of calling the function on something you put the function inside the something (context) and use what's there. Assuming something is some structure that 'has something inside'.
11:15:07 <kuribas> Unode: IO String doesn't mean there's a string inside, it's an action that returns a string
11:15:40 <erisco> analogies are useful until they're not
11:15:47 <dumptruckman> Hello
11:16:09 <erisco> hi
11:16:28 <Unode> kuribas: can you elaborate on the use of the word action?
11:16:41 <kuribas> Unode: in terms of IO you can think of >>= as take the result of one action, and pass it to the second action.
11:17:18 <kuribas> Unode: action in the context of IO means doing something that may have a side-effect, and return a value.
11:17:19 <Unode> So I'm building a pipeline. Structure on a promise that if everything works without errors I will have a String?
11:17:42 <Unode> Sorry bad choice of words
11:17:48 <dumptruckman> Anyone have experience getting atom set up for haskell on windows?
11:18:06 <dumptruckman> I'm very new and I've been at this for about a day now with little success :(
11:18:19 <dumptruckman> The repl opens but just doesn't do anything beyon that
11:18:22 <Unode> Pipeline yes, structure no. I mean to chain commands on a promise that ...
11:19:20 <kuribas> Unode: think of it this way, IO actions can be created and manipulated from haskell, but they can only be executed by "main".
11:19:45 <Unode> like an async loop?
11:20:21 <Unode> kuribas: keep going...
11:20:57 <kuribas> Unode: So the only way to do something with the result of an action is to pass it to another action.
11:21:04 <kuribas> Unode: using >>=
11:21:22 <kuribas> Unode: or do notation (which actually uses >>=)
11:21:56 <Unode> I'm still trying to process "the only way to do something with the result of an action is to pass it to another action"
11:21:59 <geekosaur> you are binding IO actions together, and the result of main :: IO a is a chain of IO actions bound together. you can think fo this chain as being passed to an impure runtime which executes it
11:22:29 <geekosaur> simply mentioning getLine, for example, does nothing; it has to be bound into main's chain of IO actions to do something
11:22:40 <erisco> not to another action, to a function which returns an action
11:23:05 <kuribas> erisco: yeah
11:23:15 <geekosaur> otherwise, you just have a bunch of programs. they don;t run themselves, they have to be assembled into a chain (bind) and then run (returned from main to the runtime)
11:23:16 <monochrom> Time to read my http://www.vex.net/~trebla/haskell/IO.xhtml . But it's consistent with all of the above.
11:23:47 <geekosaur> another way to think about it is as a chain of callbacks
11:24:03 <monochrom> Yeah, I support the callback view.
11:24:04 <erisco> how does a monochrom explain IO... I will read this as my bedtime story
11:24:06 <Unode> that analogy I can work with.
11:24:06 <geekosaur> where main is given an empty callback and you are chaining additional callbacks onto it
11:24:19 <erisco> do you have an ereader friendly version? :)
11:24:33 <dsal> That gets a bit more confusing to think about since my app has multiple threads.
11:24:43 <monochrom> "returns a string" is very ambiguous, especially after you have talked yourself into "f x = x+1 returns a number".
11:24:54 <geekosaur> (the callback story is why it's becming a popular way to work with JavaScript; do notation actually makes handling browser JS's callback nature easier to work with because it ends up looking like normal code)
11:24:57 <athan> Has anyone here seen any libraries for generating .service files for systemd? I feel like it could be useful for system automation
11:25:12 <athan> er really just a systemd service file parser / pretty printer
11:25:12 <kuribas> geekosaur: the continuation monad!
11:25:53 <monochrom> The beauty is that callback is not an analogy. It is the real McCoy.
11:26:10 <Unode> geekosaur: so in that case, when does the "main loop" actually perform work?
11:26:38 <kuribas> geekosaur: so you implemented the continuation monad in javascript?
11:26:53 <monochrom> erisco, I think you can find ways of converting HTML to epub. Because afterall epub consists of HTML plus moar metadata.
11:26:56 <geekosaur> in the callback case it's always running, but each IO action represents something that is dependent on an outside event in some way
11:27:14 <Welkin> erisco: use pandoc
11:27:16 <geekosaur> kuribas, I didn't, I just watched what purescript etc. did
11:27:17 <erisco> "It cannot be correctly summarized in a few words in layperson language; every sentence you think up now is wrong." this is everything I dreamed of
11:27:31 <dminuoso> Is do notation just syntactic sugar, or is there any subtle semantic difference?
11:27:40 <kuribas> dminuoso: just sugar
11:28:09 <Welkin> `a <- ma` is `ma >>= \a -> ...`
11:28:10 <geekosaur> although occasionally the sugar is a bit complex (e.g. when you do pattern matching in (a,b) <- ...
11:28:32 <geekosaur> becuase that desugars in a way that invokes fail if the pattern doesn't match
11:28:43 <kuribas> dminuoso: but redefining >>= doesn't change the meaning inside do
11:28:50 <kuribas> luckily
11:29:12 <dminuoso> kuribas, well using :i Monad I don
11:29:17 <dminuoso> dont see any <- so :)
11:29:18 <monochrom> I also have http://www.vex.net/~trebla/haskell/cont.xhtml which tells the story of going from callback passing style to do-notation, and then going crazy with that.
11:29:43 <geekosaur> dminuoso, <- is not an operator, it's a syntactic construct. it turns into the >>= operator
11:30:10 <erisco> monochrom, you could have given that to me yesterday
11:30:25 <monochrom> Oh! Sorry!
11:30:50 <monochrom> (How do I hack into the log-taking server so I could insert it into yesterday's log?)
11:30:55 <kuribas> monochrom: right, the continuation monad should be called the Callback monad :)
11:31:11 <erisco> no it shouldn't
11:32:11 * hackagebot executor 0.0.4 – Shell helpers – https://hackage.haskell.org/package/executor
11:32:39 <erisco> at least, I have never seen an abortive callback, whereas all the continuation examples I saw yesterday were
11:33:05 <tmciver> Hey folks. I'm trying to create a Map that accepts hetergenous keys (at first) and I'm also trying to make it so the key type is a type family. This shows the error I get when I try to do this: http://lpaste.net/358011.
11:33:55 <tmciver> I can get it to compile if I make FooKey a *data* family rather than a type family but I want to know if I can make it work as a type family.
11:34:20 <erisco> tmciver, well, analytically here, Maps cannot have heterogeneous keys and type families are not types, so cannot be a key type
11:35:12 <drlkf> hi there, is there a package to generate documentation like sphinx for python ?
11:35:23 <Welkin> drlkf: haddock
11:35:46 <tmciver> erisco: I *think* I'm trying to do something like this generic TrieMap: https://hackage.haskell.org/package/generic-trie-0.3.0.1/docs/Data-GenericTrie.html
11:35:56 <Welkin> https://hackage.haskell.org/package/haddock
11:36:49 <erisco> tmciver, okay, I don't know what that something is
11:37:11 <Unode> ok so a more generic question, when does one use (or should use) liftIO?
11:37:27 <erisco> :t liftIO
11:37:28 <lambdabot> MonadIO m => IO a -> m a
11:37:39 <drlkf> thanks Welkin
11:37:48 <Tuplanolla> When necessary, Unode.
11:37:50 <erisco> when you have an 'IO a' and you want an 'm a' instead, if 'm' has a MonadIO instance
11:37:56 <Unode> Tuplanolla: ...
11:38:10 <monochrom> Unode: ...
11:38:14 <Unode> erisco: ah! thanks
11:38:20 <Welkin> liftIO will `lift` as many times as necessary to get you an `IO`
11:38:26 <monochrom> I mean, you ask a broad question, you won't get a non-broad answer.
11:38:48 <Welkin> otherwise, if you use `lift`, you will need to do `lift . lift . lift` if you have a monad transformer stack 3 layer deep
11:38:52 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
11:39:00 <Welkin> you'll need different numbers of `lift`
11:39:28 <Unode> monochrom: you may realize that I am a beginner and lack the knowledge to assess how broad the question was. "When necessary" literally add no knowledge to my current state.
11:39:30 <Welkin> depending on how your stack is configured
11:39:45 <Unode> monochrom: your article is helpful. Reading through it as we speak.
11:40:29 <Tuplanolla> There are some functions you can use to express interesting ideas or reduce repetition; others are there merely out of necessity, Unode.
11:41:40 <kuribas> Unode: I think reading through a good haskell book or manual will make it easier for you.
11:43:17 <Unode> kuribas: I've read most of Haskell Programming from first principles. It helped but the more advanced concepts are difficult to grasp. The book focuses heavily on the theory of why things work the way they work and not so much on how does this work in practice.
11:43:52 <Unode> I'm trying Learn you a haskell for great good now. So far it's going a bit better but I haven't reached the hard parts yet.
11:44:40 <jared-w> Unode: that's an interesting perspective. I found that to be the opposite. HPFFP to me felt very heavy on practical application and much less focused on theory
11:44:42 <Unode> Also have CIS 194 that someone recommended but haven't got to it yet.
11:45:31 <jared-w> LYAH is... not really recommended. Its 'monkey see monkey do' style produces people who feel like they're learning when they're reading the book but all of the knowledge goes in one ear and immediately out the other
11:45:56 <erisco> how was this ascertained, jared-w?
11:46:03 <Welkin> LYAH is a great motivational introduction
11:46:05 <jared-w> CIS 194 is good, although it's not quite as beginner friendly as HPFFP; it definitely is recommended to do it while goigng through lectures
11:46:20 <Unode> jared-w: after 900 pages of the first. I still don't know enough to be self sufficient. As you can tell by my questions, my understanding is also rudimentary.
11:46:22 <Welkin> I feel like CIS 194 is getting old at this point
11:46:40 <Tuplanolla> I found LYH to be a good segue from Scheme to Haskell, jared-w.
11:46:56 <Welkin> Unode: that was my impression from just looking at the sample chapters, table of contents, and hearing other people's feedback on it. It seems extremely drawn out
11:47:02 <Unode> I have no prior on functional languages. Other that the little one can do with Python.
11:47:03 <jared-w> erisco: tons of second hand accounts have solidified the feeling I got when reading through some of LYAH a while ago. As for the HPFFP, that comes from my first hand experience reading through it
11:47:35 <Welkin> Unode: for HPFFP
11:47:51 <Welkin> there are other options these days
11:48:03 <monochrom> Unode, I think the real question is, have you done most of the exercises?
11:48:19 <Unode> At this point I understand some of it but it's hard to fight old habits. Even 'trivial' things in other languages such as "I'll store this in a hash here and reference to it later" is something I find hard to even think in haskell.
11:48:29 <Welkin> GRaham Hutton's Programming in Haskell 2nd edition is good and short (250 pages)
11:49:19 <jared-w> If it's the "thinking in haskell" you have trouble with, I can recommend Hutton's book or Bird's book (Bird's is the most theory-based beginner book, I think, but it's illuminating to give you a bit of insight to how functional programmers think)
11:50:23 <dminuoso> monochrom, in all honesty excercises in Haskell are tough, because there's so little you can do until you get to things like monads. At least that has been my experience.
11:50:24 <jared-w> (although I've found that, at least for the first half of Bird's book, it feels very "this is how FP programmers thought and went about things 10 years ago..." although it's still a very valid way to approach things. It just takes a bit of time to really get an appreciation for his approach since he has this giant fetish for lists and if/then/else
11:50:26 <kuribas> Unode: In haskell we typically don't use hashes, but Data.Map or Data.HashMap
11:50:37 <Unode> monochrom: about 40%, mostly on the first part of the book. The second half I read while commuting and didn't have a ghc with me to try it. I did them mentally as far as I could.
11:50:52 <monochrom> dminuoso, I'm referring to HPFFP's exercises, not exercises randomly obtained from the Internet.
11:51:00 <dminuoso> Oh okay
11:51:02 <erisco> dminuoso, that seems to be because "a thing to do" only counts if it involves IO
11:52:00 <monochrom> I'm wondering if 40% is enough.
11:52:05 <jared-w> No, it's not
11:52:10 <Unode> monochrom: some of the exercises were extenuating specially once "solutions" were no longer available. I felt a lot of frustration because often it was not even clear what the end-goal was supposed to be.
11:52:12 <erisco> I think I have written zero IO programs to date and somehow I am not bored
11:52:22 <erisco> well, I guess I used shake + Hakyll that one time
11:52:44 <jared-w> Starting with the Monad chapter, it /feels/ mostly theory, but you *really* need to do the exercises or nothing will stick
11:52:57 <Unode> erisco: I can't even envision what you actually do.
11:52:57 <dumptruckman> screw it
11:53:05 <dumptruckman> just gonna install mint dual boot
11:53:17 <Unode> erisco: literally everything I do on a daily basis is IO oriented.
11:53:23 <jared-w> Unode: although I do sympathize since I did share a lot of that frustration as well. I'm only on the Traversable chapter right now but having some solutions online really helps when I get really stuck
11:53:25 <monochrom> I guess there is still a difference between "uniformly randomly chosen 40%" and "consciously chosen, therefore biasedly chosen, 40%"
11:53:27 <kuribas> Unode: well, a good texbook should explain you why you cannot extract a value from an IO action.
11:53:43 <dumptruckman> suggestions for the best linux option for haskell for a beginner?
11:53:58 <monochrom> And Dunning-Kruger implies that virtually all conscious choices are wrong choices.
11:54:02 <Unode> monochrom: sure I won't argue on that. Make that 40% biased by whatever level of frustration I was on at the time.
11:54:09 <lbown> for a beginner you want something with a terminal and that is easy to install
11:54:12 <Tuplanolla> Not Arch, dumptruckman.
11:54:22 <dumptruckman> I'm gonna use Mint
11:54:23 <erisco> Unode, I bet it is less IO than you think
11:54:23 <kuribas> Unode: a lot of IO is done with combinators, so you don't actually have to do IO :)
11:54:26 <Tuplanolla> (Its GHC is broken.)
11:54:26 <jared-w> monochrom: the first 40% of the book is getting you a foundation so you don't panic when you learn monads. If you just do exercises from that part, you'll have a very beginner level of knowledge (although sufficient to start on toy projects)
11:54:27 <Welkin> (x)ubuntu
11:54:28 <bah-tum-tzz> dumptruckman: what do you mean by "best linux option"? which distribution is recommendable? or how to install haskell-stuff?
11:54:38 <dumptruckman> how to install haskell stuff
11:54:42 <dminuoso> dumptruckman, whatever floats your boat. Here I use linux mint because no effort. :)
11:54:51 <Unode> erisco: I don't know how to quantify that.
11:54:54 <lbown> I'm using zsh on windows 10
11:54:58 <dumptruckman> i want to use Atom for my editor
11:55:02 <kuribas> Unode: by using libraries like reactive-banana, pipes, binary, etc...
11:55:49 <bah-tum-tzz> dumptruckman: that depends on the distro. if you use linux mint, you might want to install stack with your package manager. then upgrade stack using `stack upgrade`. and then install ghc and everything with stack.
11:55:55 <monochrom> dumptruckman: Does it have to be best? Does it have to be perfect? How perfect does it have to be?
11:56:08 <Unode> erisco: for instance the problem I'm trying to solve now is processing a set of files with an external software, then collect all the outputs and merge them into a single file based on criteria that depend on the content of each output file.
11:56:11 <geekosaur> alternately you can install haskell via hvr's Ubuntu PPAs
11:56:28 <erisco> Unode, the objective of writing a program may be to send these bits to those bits, but only some parts of a program need actually deal with the reading of inputs and the writing of outputs
11:56:33 <dumptruckman> i mean, i just want to be able to use ide-haskell on atom and have the repl work
11:56:40 <dumptruckman> I got everything working except the repl on windows
11:56:46 <dumptruckman> and i'm just giving up on that pursuit now
11:56:59 <monochrom> Now there is a real question.
11:57:06 <Unode> erisco: sure, I get that. But often enough I'm calling out to system so IO ends up almost everywhere.
11:57:25 <monochrom> Always question askers "does it have to be perfect?", and they will spill the beans.
11:57:30 <Unode> but what do I know. It's probably all wrong since I'm writing it with poor understanding.
11:57:35 <monochrom> In fact, hell, s/question/challenge/
11:58:10 <dumptruckman> what do you even mean "perfect"
11:58:26 <dumptruckman> or you're not talking to me
11:58:27 <dumptruckman> ?
11:58:31 <monochrom> Yeah, I know right? What do you even mean "best"?
11:58:45 <n_blownapart> hi this func needs Integral because of the use of the func odd . I added Bool to the signature thinking that was surely correct. so I guess the function is not taking a Bool but the Bool is somehow only in the scope of the case statement? https://ptpb.pw/TcWi
11:58:47 <kuribas> Unode: say you want to read input, do something with it, then output it, then you can use the interact function : interact :: (String -> String) -> IO ()
11:58:52 <Unode> these days I find that wget url://stack and launch that is easy enough. Just recently moved from relying on the package manager for this.
11:59:08 <kuribas> Unode: you don't actually need to write any IO code, just define a function String -> String
11:59:44 <dumptruckman> monochrom: i was asking for opinions on what is best, surely people have opinions on what that means
11:59:53 <Unode> kuribas: about libraries, the framework already uses conduit so I was digging into it the other day. I sort of understand it now. But needs more practice.
12:00:00 <monochrom> Then that is also my answer.
12:00:04 <Tuplanolla> Correct analysis, n_blownapart.
12:00:32 <bah-tum-tzz> n_blownapart: use guards instead of the case-statement
12:00:38 <erisco> dumptruckman, I did not have luck keeping haskell-ide for Atom working. I would work for a bit and then break, in my experience, but I am a numpty for that sort of stuff
12:00:52 <n_blownapart> thanks Tuplanolla Oh my I'm catching on. thanks bah-tum-tzz this is a book example
12:00:54 <erisco> dumptruckman, I would rather keep my editor on half a screen and ghci on the other half
12:00:56 <lbown> if you don't know vi you should learn it
12:01:11 <c_wraith> You should at least learn how to quit vi
12:01:16 <lbown> lol
12:01:17 <erisco> :q!
12:01:20 <c_wraith> Because if you don't know, you'll *never* guess
12:01:21 <Tuplanolla> :t otherwise -- There's a nicer way to do it with guards and this, as bah-tum-tzz said, n_blownapart.
12:01:22 <lambdabot> Bool
12:01:24 <dumptruckman> i know vim enough to know that i don't want to learn more
12:01:25 <dumptruckman> :)
12:01:44 <dumptruckman> erisco: good to know
12:01:50 <n_blownapart> erisco how do you do that in xterm do you know? 
12:01:57 <Unode> kuribas: right, I understand that. My point was more that I call a lot of functions that have IO Something as output and I'm still not good with handling that.
12:02:18 <Unode> do syntax is fine but feels like I'm bypassing the learning.
12:02:19 <erisco> n_blownapart, I couldn't even tell you what xterm was
12:02:21 <n_blownapart> Tuplanolla, thanks I think I could do it with guards. I'll give it a shot
12:02:44 <kuribas> Unode: haskell is like a puzzle, once you understand how the pieces fall together, it becomes easy.
12:02:49 <n_blownapart> erisco,  sorry I use a debian gnome terminal is it not xterm? 
12:02:54 <merijn> Unode: My usual beginner recommendation is using explicit >>= and fmap until you're comfortable enough writing that way to understand how it desugars
12:03:17 <merijn> Unode: Also, in case you haven't read how the desugaring of do works, do that too. https://en.wikibooks.org/wiki/Haskell/do_notation
12:03:22 <Unode> kuribas: for instance in this ngless software, there's an NGLessIO monad, so MonadIO. And I find myself using liftIO all the time, without actually understanding why.
12:03:37 <kuribas> Unode: because NGLessIO isn't IO
12:03:50 <kuribas> Unode: it's a stack that uses IO.
12:03:58 <erisco> n_blownapart, I reiterate my previous statement
12:04:14 <monochrom> Sometimes abstraction means you don't "understand" a lot of things.
12:04:14 <kuribas> Unode: so you have to "lift" the IO action into the NGLessIO monad.
12:04:43 <merijn> Unode: MonadIO is a typeclass for monads that let you piggyback IO sequencing on whatever else they do. liftIO is just a convenient "turn something IO into any MonadIO" function
12:04:48 * bah-tum-tzz succeeded in building a package after 2 days of compiling on a raspberry pi 3
12:04:50 <Unode> kuribas: so something more like "IO (NGLessIO ...)" as opposed to "NGLess (IO ...)"?
12:04:55 <kuribas> Unode: but since you said you don't know Monad Stack, it's really recommended to read a good text about it.
12:05:11 <c_wraith> Unode: liftIO is defined to be "do the minimal conversion to make this IO action work here".  Except with a more specific version of "minimal" which means it really can't do anything except make the types work.
12:05:14 <johnw> monochrom: you mean, you know the answer but not the content of the answer? ;)
12:05:19 <c_wraith> Unode: so..  there really isn't anything else to understand.
12:05:31 <monochrom> haha
12:05:44 <n_blownapart> how would you split screens in a terminal to get ghci on one side and vim on the other is what I would hope to do..
12:05:55 <c_wraith> n_blownapart: depends on the terminal.
12:05:57 <Unode> c_wraith: "make it work", does that mean "perform the action"?
12:06:08 <monochrom> But I don't know how to implement Data.HashSet for example. That is a kind of "not understand".
12:06:12 <merijn> n_blownapart: Get tmux if it's not already installed on your system
12:06:36 <merijn> n_blownapart: It's a terminal multiplexer which (among other things) lets you splitscreen terminals anyway you want
12:06:39 <c_wraith> Unode: are you comfortable with the idea of laws for a class?
12:06:51 <Unode> c_wraith: more or less, yes.
12:06:54 <n_blownapart> thanks merijn checking that
12:07:02 <erisco> I am more of a class anarchist myself
12:07:12 <bah-tum-tzz> n_blownapart: you could also just open two terminal emulator windows, if you use Xorg or so
12:07:12 <monochrom> However, I know its external guarantees about insert, delete, and lookup for example, and I can demonstrate writing correct programs using it. That is a strong kind of "understand", i.e., predictive power.
12:07:24 <bah-tum-tzz> bah-tum-tzz: :D
12:07:27 <kuribas> Unode: it simply means, turn a "IO a" into a "NGLessIO a"
12:07:49 <c_wraith> Unode: have you looked at the laws for MonadIO?
12:07:58 <Unode> c_wraith: no, not yet.
12:08:01 <n_blownapart> bah-tum-tzz, I do that but I have rather large fonts on a laptop thanks
12:08:17 <c_wraith> Unode: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-IO-Class.html
12:08:28 <monochrom> And a main thesis of software engineering is that I don't want to worry about how to implement Data.HashSet.
12:08:47 <monochrom> So when I "not understand" it, I'm actually doing it right.
12:08:54 <c_wraith> Unode: the second law says that binding then lifting gives the same result as lifting then binding.
12:09:28 <kuribas> Unode: because you cannot fit an "IO a" piece where a "NGLessIO a" piece is needed.
12:09:31 <c_wraith> Unode: the only way that can possibly work is if lifting lifts the entirety of the effects.
12:09:37 <monochrom> But it's against human nature.
12:09:49 <erisco> alleviated from the burden of knowing one thing, monochrom is freed to know another
12:10:01 <monochrom> Human nature is to be an armchair philosopher and "understand" all the fundamentals and getting nothing done.
12:11:12 <Unode> c_wraith: so it's more of a wrapper rather than an alias? i.e. "MonadIO (IO ...)" as opposed to "MonadIO = IO" (where MonadIO extend functionality not present in IO)?
12:11:28 <monochrom> It is like everyone wants to talk about repairing cars but no one actually drives one.
12:12:00 <Unode> monochrom: that's a good phrasing of how I felt when reading the book we mentioned before. Like I was building a car from scratch.
12:12:06 <Unode> And I just want to drive it.
12:12:10 <kuribas> Unode: no, MonadIO is a typeclass, which means liftIO will work for many things.
12:12:56 <Unode> kuribas: sure, I was trying to simplify the jargon there.
12:13:25 <kuribas> Unode: a typeclass is neither a wrapper or an alias.
12:14:02 <c_wraith> Unode: "simplifying jargon" doesn't work.  The whole point of jargon is to be the simplest correct way to convey its meaning.
12:14:35 <kuribas> Unode: NGLessIO might be a wrapper, but it doesn't have to be.  And it doesn't really matter.
12:14:42 <Unode> c_wraith: interesting. Never thought of it like that.
12:14:44 <monochrom> Unode, #haskell is a pretty sane place where people already use jargons minimally. Be assured that with more than 95% probability you can't further simplify jargons.
12:15:10 <monochrom> (The 5% is when people start saying "thunk" and "closure"!)
12:15:20 <Unode> monochrom: sometimes it's not so much simplify. It's more like finding terms to which I can link the new ones.
12:15:29 <geekosaur> the point of a typeclass is to allow types to supply their own implementations of a common functionality. in this case, the MonadIO typeclass is providing the functionality "relay an IO action to an underlying IO monad and relay the result back"
12:15:37 <erisco> what about monoids in the category of endofunctors?
12:15:42 <Unode> closure I'm actually familiar with :)
12:15:45 <geekosaur> so IO provides its implementation: instance MonadIO IO where liftIO = id
12:15:46 <c_wraith> Unode: that also usually doesn't work.  The whole reason new terms are created is because the old ones don't work.
12:15:46 <Unode> (not the language)
12:16:22 <jared-w> You could possibly find some old terms that are a fuzzy approximation; unfortunately, rather than being a fuzzy (yet accurate) approximation, they are often afuzzy approximation that lead to incorrect mental models
12:16:30 <kuribas> Unode: btw, what language do you come from?
12:16:30 <jared-w> like "monads are burritos"
12:16:43 <Unode> kuribas: mostly Python
12:16:48 <monochrom> burrito is fairly new
12:16:54 <monochrom> But I guess I am the old one.
12:17:30 <Tuplanolla> :t getLine :: Burrito String
12:17:31 <monochrom> But before burrito there was spacesuit. From dons no less. Giants make horrible mistakes too.
12:17:32 <lambdabot> Burrito String
12:17:49 <geekosaur> wasn't the spacesuit one explicit mockery?
12:18:15 <monochrom> But I guess if Hoare got to invent null, dons got to invent spacesuit.
12:18:37 <monochrom> Naw, that's not my understanding. My understanding is that burrito was an explicit mockery.
12:18:39 <c_wraith> Burrito was also explicit mockery
12:19:15 <geekosaur> I thought burrito was mockery as well but have had others insist it was proposed seriously (and then *that* was mocked)
12:19:31 <monochrom> OK!
12:19:55 <c_wraith> iirc, burrito was first used in someone's (byorgey's?) blog post begging people to stop writing monad tutorials
12:20:01 <merijn> I liked the SIGBOVIK paper explaining burritos via monads :p
12:20:06 <kuribas> Unode: a lot of haskell stuff can be simply understood by looking at the types.
12:20:08 <erisco> we should found a monad analogy competition, complete with a website and prizes
12:20:25 <monochrom> In dons's infinite wisdom, he thought up the spacesuit explanation.  <--- Now this is a proposition or a mockery and you can't tell which! Take your pick! >:D
12:21:00 <Tuplanolla> Monads are like generalized monad tutorials.
12:21:09 <kuribas> Unode: often what the type tells you is all you need to know, like in the case of liftIO
12:21:31 <merijn> monochrom: dons' infinite wisdom is that he spends all his time skiing and taking pictures of sunsets, rather than spend his life here on IRC ;)
12:21:31 <monochrom> Tuplanolla: But how do I bind or join generalized monad tutorials?
12:21:50 <monochrom> True that.
12:22:07 <monochrom> Is dons at Facebook now?
12:22:15 <c_wraith> yes
12:22:31 <n_blownapart> Tuplanolla, et al this is close I think but getting indent error? https://ptpb.pw/cxaw
12:22:48 <Tuplanolla> Lifting is narration and joining is concatenation, monochrom.
12:22:54 <merijn> In a completely unrelated note: conduit is pull only, yes?
12:22:55 <monochrom> Need to refresh that new memory. Because I am kind of stuck with the stale state of "dons was chartered by a bank".
12:23:06 <erisco> merijn, speaking of which I was about to go outside to read this paper because you guys are too distracting for me ;P
12:23:27 <c_wraith> merijn: it was last time I looked, but that's the sort of thing that might change with a new major release
12:23:37 <Tuplanolla> You have written nonsense, n_blownapart.
12:23:41 <kuribas> Unode: it goes like this: why cannot I use a IO String here?  Because you need a NGLessIO String here.  How can I make an NGLessIO from an IO?  By using an higher order function.  Is there one that fits the bill?  In fact there is!  liftIO :: IO a -> NGLessIO a
12:24:00 <geekosaur> n_blownapart, your indent hygiene is pretty terrible there
12:24:09 <n_blownapart> dang so I can't write that
12:24:25 <merijn> c_wraith: damn...so what do I do when I need a push based solution? :p I could use pipes, but I already have/need a bunch of dependencies using conduit so using both conduit and pipes seems wrong :\
12:24:43 <n_blownapart> but is that the only problem  ? 
12:25:04 <monochrom> merijn: Is it OK to spawn a thread that converts pull to push?
12:25:22 <n_blownapart> why the hell can't I be crucify_me hexchat won't let me switch suddenly for no reason
12:25:27 <geekosaur> I *think* the only thing you need to do is indent the last two lines past the 'p' on the line above them
12:25:37 <merijn> monochrom: I already have a bunch of threads, so I guess
12:25:43 <n_blownapart> cool trying that thanks
12:25:43 <monochrom> :S
12:25:57 <geekosaur> do you have multiple connections again?
12:25:58 <c_wraith> n_blownapart: you are already logged in as crucify_me from another connection.
12:26:24 <zblkf> is it possible to generate documentation for your routes in yesod with haddock ?
12:26:28 <kuribas> Unode: you may say, but the type of liftIO is MonadIO m => IO a -> m a !
12:26:28 <c_wraith> n_blownapart: you can use "/whois crucify_me" to get information about it
12:27:00 <kuribas> Unode: since NGLessIO is an instance of MonadIO, you can substitute NGLessIO for MonadIO.
12:27:23 <monochrom> No. Substitute NGLessIO for m.
12:27:31 <n_blownapart> thanks
12:27:33 <merijn> monochrom: Basically, I have a fork-join pipeline where I have multiple threads (using conduit) pulling from a channel. I'm feeding the channel from another conduit, however the pull setup would flood the channel with way more values than makes sense (like, keeping 10k values in a channel where I'm processing 10 at a time kinda defeats the fixed memory processing dealio
12:27:36 <kuribas> monochrom: right
12:28:10 <merijn> monochrom: I could limit the insert by putting a QSem around the insert, but with a pull setup I might be able to ditch the channel entirely
12:28:33 <kuribas> Unode: substitute NGLessIO for m.  It's probably weird to think about things when coming from Python, which doesn't have static types at all.
12:28:44 <kuribas> Unode: think about types
12:31:01 <kuribas> Unode: surprisingly this "meaningless" puzzling with types often gets you far.
12:33:17 <n_blownapart> geekosaur, sorry not sure what's up. my work computer is asleep
12:34:32 <monochrom> That's what the computer tells you when it takes on an alter ego and go out and have fun.
12:34:51 <n_blownapart> Tuplanolla, yes it's nonsense. how would you write that with guards?
12:34:51 <monochrom> Bah, English is so hard.
12:35:52 <n_blownapart> word monochrom especially when you're reading text on a conveyor belt
12:36:18 <minn> I recently ported some lexers from flex to alex. I am noticing an order of magnitude performance difference (e.g., 1.0 versus 0.1 seconds to tokenize and print a large file that stresses the internal data structures to stdout). Profiling reveals that internal alex functions and record access/updates (using lenses) account for almost all time spent (50% of the time is spent performing alex's bind operation). Is this to be expected or
12:36:18 <minn>  does this indicate that I'm doing something wrong? I'm using lazy bytestrings with monadic user state.
12:37:07 <Tuplanolla> @let addOneIfOdd p | odd p = f p | otherwise = p where f p = p + 1 -- Like this, n_blownapart.
12:37:08 <lambdabot>  Defined.
12:37:42 <Tuplanolla> (I would inline `f` though.)
12:37:43 <Unode> kuribas, monochrom thanks for the help
12:38:23 <n_blownapart> one sec got disconnected ..
12:38:32 <kuribas> Unode: np, have fun learning!
12:38:40 <n_blownapart> thanks got the code
12:43:32 <geekosaur> minn, I'm checking, I think there's some known issues with inlining (>>=) in ghc 8.2.1 if you are running that version
12:44:40 <monochrom> Wait, was that an issue during release candidates and fixed before releasing?
12:45:01 <geekosaur> I thought someone mentioned it post-release
12:48:08 <kuwze> I am porting some code to haskell, and it makes heavy usage of inheritance for the data-structures. Is there a way to extend a record in haskell?
12:48:13 <geekosaur> sigh. ghc trac is 500ing
12:48:26 <monochrom> Yeah it's taking me forever too.
12:48:45 <merijn> I heard it was down earlier today
12:48:48 <merijn> maybe still issues?
12:48:54 <geekosaur> ryantrinkle has a benchmark that is ~60x slower in 8.2.1 because bind isn't being inlind
12:49:39 <c_wraith> kuwze: there's no good analogue.  You're going to have to port what the code does, not how it works.
12:50:07 <kuwze> but you can't extend records? I'm looking at vinyl hoping it can help
12:50:37 <merijn> I...would not recommend using vinyl to anyone just starting Haskell
12:52:24 <minn> geekosaur: I'm actually using ghc 8.0.2, so I shouldn't be running into issues with current versions of ghc. Thank you for checking, though :) (that seems like an odd issue).
12:53:03 <merijn> minn: Obvious first question: Did you doublecheck that you compiled with -O/-O2?
12:53:45 <c_wraith> kuwze: things like vinyl exist  That's why I said there's no *good* analogue.  I mean, vinyl works, but it's incredibly complicated and usually not the best approach.
12:55:18 <dminuoso> Is there a way to have ghci add explicit parens to see how an expression associates?
12:55:55 <kuwze> c_wraith: thanks for making it more explicit, I keep stumbling on things hoping there's a quick fix (or a good analog)
12:56:01 <dminuoso> Hoping for something along the lines of `:p foo bar` :-)
12:56:50 <minn> merijn: Yeah - I have stack configured to compile with -O2. I'm currently trying to ensure that I'm not running into issues with laziness (I hate to say this, but this is my first time trying to track down performance problems in Haskell).
12:57:30 <geekosaur> dminuoso, as far as I know the closest you can get is -ddump-parsed
12:57:39 <kuwze> c_wraith: what do you think of this tactic?: http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html
12:57:48 <geekosaur> but that's nbot going to dump it as Haskell code
13:00:27 <c_wraith> kuwze: I think that if you don't know haskell well, you're likely to introduce infinite loops you'll have trouble debugging with that approach.
13:01:42 <kuwze> c_wraith: I definitely don't know haskell well
13:01:53 <kuwze> c_wraith: thanks for the advice
13:02:34 <c_wraith> kuwze: there is a simpler thing you might consider - replace the hierarchy from the original code with a record of the operations it provides.
13:04:18 <c_wraith> kuwze: that's the most direct translation of OO objects to Haskell.  You can create all kinds of different behaviors in values of the same type.
13:05:37 <kuwze> c_wraith: what do you mean by "record of the operations in provides"?
13:06:07 <dminuoso> geekosaur, how do you reason about how code associates? Do you know the infixity declarations of all your operators?
13:06:26 <dminuoso> Or is that a thing you just quickly check in ghci while you code?
13:06:27 <geekosaur> generally, and if I dont then I can ask ghci (:i)
13:06:32 <dminuoso> k :)
13:06:39 <c_wraith> kuwze: you start with the operations the type should support, then create a data type that contains the set of operations as functions.
13:07:03 <n_blownapart> https://ptpb.pw/5KFu  no clue I tried to format Tup*anolla 's code differently
13:07:39 <n_blownapart> getting indent errors again
13:08:05 <geekosaur> that looks pretty wrong to me, if it's at top level then you do not want let, if it does require let then the type signature needs to be inside the let
13:08:06 <c_wraith> kuwze: this would be easier to demonstrate with a list of functions. :)
13:08:30 <n_blownapart> thanks checking that geekosaur 
13:08:33 <merijn> c_wraith, kuwze: If you need an example of that, I've got one here: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Channels.hs :)
13:08:47 <kuwze> c_wraith: thank you!
13:08:47 <c_wraith> merijn: thanks
13:08:57 <kuwze> merijn: thanks, I will look at that
13:09:02 <merijn> I'm to busy to help explain, but non-abstract examples help ;)
13:09:09 <merijn> Plus, it's fairly straightforward
13:12:21 <bah-tum-tzz> hackage down?
13:12:39 <kuwze> merijn: thank you so much, I'm actually working on a library that consumes an event stream from a file, so broadcast-chan looks very useful
13:12:39 <merijn> bah-tum-tzz: Looks like it
13:13:19 <geekosaur> http://auto-status.haskell.org/
13:13:25 <merijn> kuwze: The current version on hackage is a bit pointless, imo. The github version is looking much better, but haven't gotten around to finishing everything up nicely to distribute it
13:13:40 <merijn> Which means the entire API is completely unstable with no promises whatsoever :p
13:13:59 <merijn> kuwze: probably want something like pipes/conduit for streaming from files anyway
13:14:39 <kuwze> merijn: right now it will consume events from a file, but eventually it will be receiving events over the network
13:14:56 <kuwze> merijn: just got to make sure it works right with historical data
13:14:59 <n_blownapart> I'm just guessing geekosaur but this won't work either https://ptpb.pw/H3BR
13:15:41 <geekosaur> (a) that makes little sense, you are taking p as a parameter only to immediately shadow it with a lambda?
13:15:54 <geekosaur> (b) guards are not part of "where"
13:16:33 <n_blownapart> God I'm having a hard time. 
13:16:36 <geekosaur> if you have guards inside a "where" then they would have to attach to a binding in the "where"; they cannot attach to the outer binding
13:17:37 <geekosaur> and then your guard, if it did scope to the definition of ff, would infinite loop if p were odd
13:17:53 <geekosaur> in fact I have no idea what you're trying to accomplish there
13:18:32 <n_blownapart> http://lpaste.net/358015  this is the original exercise. it got thrashed . the idea was to rewrite the where statement
13:19:37 <n_blownapart> which I guess is just f = ( \n -> n + 1 )
13:19:37 <geekosaur> ... there is context missing here. "rewrite" in what way?
13:19:58 <n_blownapart> using a \n notation
13:21:56 <geekosaur> f = ( \n -> n + 1 )        is correct if that's all you;r;e supposed to do. no other changes needed
13:23:17 <geekosaur> if you wanted to also rewrite using guards: http://lpaste.net/358015#a2384509402573963264
13:24:17 <n_blownapart> geekosaur, I think I was trying to do that initially thanks alot
13:24:35 <n_blownapart> I mean write it using guards.. 
13:30:42 <mac10688> hackage is down for maintenance, I hope it doesn't last too long
13:31:04 <merijn> mac10688: Seems to be an intermittent issue
13:31:13 <merijn> mac10688: It's not actually down for maintenance
13:32:26 <mac10688> hmm
13:33:05 <merijn> Is it me or is gloss' GLFW support bitrotted?
13:35:59 <mac10688> it's back. yay!
13:36:59 <hpc> merijn: not just you
13:37:32 <hpc> i tried fixing it and ran into windows build environment issues
13:38:45 <ggVGc> how unusual
13:40:35 <merijn> hpc: I was looking into fixing it, but I'll probably leave windows issues as someone else's problem :p
13:41:21 <merijn> hpc: Annoyingly besides a bunch of renaming a bunch of the GLFW-b interface has just changed rather drastically
13:42:19 <monochrom> Oh God https://hackage.haskell.org/package/haddock how cute and neato and excellent!
13:42:44 <Rembane> Indeed. Nice!
13:42:48 <monochrom> The whole haddock cheatsheet right at the front page!
13:43:06 <monochrom> Whoever thought this up is a genius!
13:47:26 <merijn> Was hackage patched to support all haddock syntax properly yet?
13:47:33 <merijn> (on the package page that is)
13:48:20 <merijn> Anyone remember how to access the page of a candidate package?
13:51:15 <Tuplanolla> How do you dismiss the lack of type alias documentation with Haddock?
13:51:15 <monochrom> merijn: It gets better than that. It's a <<https://cdn.rawgit.com/haskell/haddock/master/doc/cheatsheet/haddocks.svg>>
13:52:22 <monochrom> in haddock.cabal, I mean
13:52:52 <dminuoso> Mmm, is there some quick utility [(a -> Bool)] -> (a -> Bool) for folding a list of predicates (with either OR or AND) into a single?
13:52:59 <dminuoso> (for filtering lists)
13:54:32 <platz> although seems to be missing basic things like -- ^ parameter docs
13:55:16 <lyxia> \ps x -> all ($ x) ps
13:56:04 <monochrom> Tuplanolla: Is it enough to have "The declaration following a documentation annotation should be one of the following:" and then one of the bullet points is "A type declaration"?
13:57:03 <monochrom> platz: Yeah, but I suppose most users already remember -- | and -- ^ and just can't remember the rest. I know because I'm one of them.
13:57:42 <Tuplanolla> No, I mean how to give an empty documentation string, monochrom.
13:57:45 <platz> true, fair enough
14:00:30 <lyxia> dminuoso: Data.Coerce.coerce (mconcat :: [a -> Any] -> a -> Any) :: forall a. [a -> Bool] -> a -> Bool
14:01:49 <hvr> monochrom: thanks =)  (-> https://github.com/haskell/haddock/commit/92d95c2121e0323884ce65133611f309bd13786f )
14:02:44 <dminuoso> lyxia, what's the purpose of that dollar in there in your first answer?
14:03:19 <Fuuzetsu> What book should I be recommending to new programmers? LYAH and RWH are what was relevant when I was starting-ish but they are pretty out of date now as far as things lining up with Prelude and working out of the box. I haven't read "Haskell book", is it any good? Anyone can wage for it? IIRC Byorgey's course was alright though I think it wasn't very exhaustive.
14:03:42 <lyxia> dminuoso: it's an operator section. ($ x) = \f -> f $ x
14:04:35 <Fuuzetsu> wz1000: Sorry I completely forgot I offered to help w.r.t. Haddock internals and switched workspace for whole day. Do you still need some answers? I have 30minutes-ish.
14:04:44 <geekosaur> Fuuzetsu, Hutton's book is well recommended (2nd edition is up to date with current ghc)
14:05:11 <dminuoso> lyxia, oh I see. Guess it will be covered later on in my learning resource. It feels unnatural to "partially apply the second argument"
14:05:51 <dminuoso> lyxia, Im guessing I can do that with any infix operator?
14:06:37 <lyxia> dminuoso: Indeed. I use them mostly for golfing though.
14:10:49 <mac10688> hmm
14:12:12 <mac10688> I tried using mysql simple for my project but when I go to build it can't get mysql package because I don't have libpcre. I ran sudo apt-get install libpcre++0v5
14:12:20 <mac10688> and it still complains about libpcre
14:12:29 <mac10688> is there another good mysql library out there?
14:12:31 <cheater> hi
14:12:33 <pikajude> all of the pretty-printing libraries kind of function the same way
14:13:07 <pikajude> how would i print out a list of key-value pairs while aligning all the values
14:13:10 <pikajude> even if the keys are different lengths
14:13:15 <cheater> is there a good way to program real time code for embedded devices using haskell? think stuff as simple as reading a serial port and displaying on an lcd.
14:13:18 <pikajude> i feel like this should be simple but something in the documentation isn't clicking for me
14:13:32 <cheater> this without linux, it has to be hard rt
14:13:52 <cheater> but i'm perfectly fine with it being a dsl or edsl that generates code for use in a c toolchain
14:15:10 <mac10688> what do you mean by aligning all the values pikajude? Like visually aligning the values when they are printed?
14:15:54 <pikajude> mac10688: ya
14:16:10 <pikajude> longername: foo
14:16:12 <pikajude> shortname:  bar
14:16:16 <pikajude> like so
14:16:29 <cheater> pikajude: pad?
14:17:54 <Fuuzetsu> geekosaur: the index seems pretty nice, thanks
14:18:30 <geekosaur> cheater, something like
14:18:33 <geekosaur> @hackage atom
14:18:34 <lambdabot> http://hackage.haskell.org/package/atom
14:21:15 <Fuuzetsu> pikajude: I think you'll need to do 2 traversals for that no matter what and if we assume that's the case, the solution becomes trivial: find longest key, pad the rest; you can do some work on first pass if you want though I don't think there's going to be an advantage to that
14:21:59 <pikajude> oh ok
14:22:56 <manjaroi3> Hello =) How should I refer to a constructed data type? In OOP I would call it an instance.. in Haskell? A value? (Writing a formal document)
14:23:09 <Fuuzetsu> Value is fine.
14:23:15 <Fuuzetsu> Value of type T
14:23:35 <manjaroi3> thanks!
14:30:35 <dsal> Anyone have a good serialization format handy?  Something I can stream through a compressor and could deal with minor corruption.
14:30:54 <hpc> json?
14:31:12 <cheater> o right i remember atom
14:31:21 <cheater> but is atom suited to do what i mention
14:31:31 <cheater> like, will i be easily able to interface an lcd?
14:40:29 <dsal> hpc: I used to use json in this project, but it took *significantly* more space since each record is a 149 byte blob that turns into a pretty large chunk of JSON.  Something that can store a timestamp and a blob with minimal encoding overhead would be ideal.
14:43:08 <benzrf> dsal: how about bson?
14:43:12 <benzrf> er, msgpack
14:43:21 <benzrf> whyd i write bson
14:44:41 <dsal> I'm not actually that familiar with "standard" things.  This is a port of a go program that used to use json and then used "gob" (go's native serialization).
14:45:17 <benzrf> dsal: http://msgpack.org/index.html
15:02:06 <trigone> hi! is there some tool which would take as input some package, and would output the DAG of all dependencies between modules of the package or even with other packages' modules?
15:02:26 <trigone> (dependencies relative to importing/exporting)
15:02:55 <c_wraith> technically that's impossible because the graph can be cyclic. :P
15:03:05 <c_wraith> But the question is still reasonable
15:03:46 <trigone> c_wraith: i thought without tricks of hs-boot thingies, the graph couldn't be cyclic (not with GHC)? mind you i don't know how much those hs-boot files are being used out there
15:04:02 <monochrom> GHC itself has to do that, and it is exposed in the GHC API, but it takes a week or two to learn that.
15:04:07 <trigone> and i don't really get why the program can't actually realize it's in a cycle...
15:04:17 <trigone> if it hits a second time the same file...
15:04:27 <trigone> monochrom: well, yay
15:05:31 <trigone> i guess it'd be easier to do it by myself just by parsing the files under the sources folder and getting all the import statements...
15:07:08 <monochrom> Here is another idea. ghc -M
15:08:04 <monochrom> Because there are people who use makefiles and they need this automated.
15:08:32 <monochrom> The beauty is if you have hs-boot cyclicy, ghc -M outputs the right things too.
15:08:54 <monochrom> So now you just have to parse a subset of makefile format. >:D
15:09:23 <trigone> monochrom: to use it with stack, do i put that option in cabal?
15:09:55 <monochrom> No, you run it by hand or by the program that wants the graph.
15:10:23 <monochrom> Run it by hand first, to get a feel of what the output looks like. And then decide how you use it in production.
15:10:46 <monochrom> Be a scientist. Experiment with it.
15:11:28 <monochrom> Oh sweet it also has -include-pkg-deps
15:11:50 <trigone> monochrom: ok, i'll try
15:11:51 <monochrom> Read the GHC users guide section "Using make".
15:12:26 <monochrom> It probably outputs to a file not stdout. Look for a new file you didn't create.
15:12:54 <trigone> you know what i really don't know how to use GHC manually... i'll look into it later... thanks for the idea :)
15:13:10 <monochrom> That is such a handicap.
15:14:48 <monochrom> Political history has taught us that if country X "protects" country Y, it means country X is handicapping country Y. In the very same sense, stack is protecting you. Even cabal tries to protect you.
15:15:34 <trigone> well i can't learn everything at the same time :) i also need to learn git, test suites... i don't plan on remaining "handicapped" all my life, just at this very second i can't really help it
15:15:34 <monochrom> Similarly, Windows and iPhones protect their users.
15:16:03 <monochrom> OK but supposedly stack's user guide tells you how to run ghc, too.
15:16:26 <trigone> monochrom: well i haven't read the whole stack user guide either, that's also on my to-learn list :P
15:16:42 <monochrom> At any rate the way I solved the information overload problem is I didn't learn stack or even cabal.
15:17:58 <monochrom> I just started with ghc itself.
15:18:37 <monochrom> Actually hugs first but I guess that ship has sailed.
15:21:23 <trigone> and you have no problem managing the compilation process of packages just with ghc? didn't you have to build at least some tools (with bash or whatever) to facilitate the process?
15:22:29 <monochrom> No. GHC already comes with half of cabal. (Look at the "Cabal" library.)
15:23:09 <trigone> ok
15:23:23 <monochrom> A typical package can be downloaded from hackage as a tar.gz. Unpack it, it has a Setup.hs program for building and installation. It works because it calls that half of cabal that comes with GHC.
15:23:54 <monochrom> This means I have to do my own dependency chasing so I build things in the right order, yes.
15:24:19 <monochrom> But it was not overwhelming.
15:24:38 <monochrom> Later, I adopted cabal-install.
15:26:05 <pikajude> you merely adopted the cabal-install. i was born in it
15:27:07 <monochrom> Yes. This is why I was objective enough to write http://www.vex.net/~trebla/haskell/sicp.xhtml
15:28:08 <monochrom> It is always an advantage to be an outsider.
15:29:31 <trigone> does anyone know a simple and readable way to render a DAG in ascii (aka plaintext) format? (so it be readable by humans ofc, not just for storage of the data)
15:30:05 <monochrom> No. At best you can do a tree.
15:30:27 <c_wraith> Just use dot.  It's nice.
15:30:29 <monochrom> Text is simply unsuitable unless you go ascii art.
15:31:38 <trigone> c_wraith: i thought dot was just saving the edges separately?
15:32:15 <c_wraith> as a format, it's basically just a list of edges, yes.  But it renders them really nicely.
15:32:33 <trigone> c_wraith: oh but you need some software don't you... what's the output format?
15:32:50 <c_wraith> it's configurable.  .png and .pdf have the best quality
15:32:59 <trigone> maybe i'll use it though...
15:33:04 <c_wraith> graphviz is the name of the overall package
15:33:21 <trigone> thx c_wraith 
15:33:31 <c_wraith> it has a bunch of different layout techniques.  dot is the one that works best for things that are almost trees
15:33:42 <monochrom> Make a png first. Then ask mplayer to put it through the aa filter to make ascii art.
15:34:53 <trigone> monochrom: oh? what's mplayer?
15:35:25 <trigone> it's a video player?
15:35:28 <monochrom> A popular media player and converter on linux.
15:35:50 <monochrom> Well, popular among the command-line people.
15:36:12 <monochrom> It is a rabbit hole.
15:36:58 <trigone> and it converts to ascii art? but will it not just tranform pixels into whatever characters? cuz in that case there's a risk of having a file of complicated proportions... unless the original function is say just 70 pixels of width... but...
15:37:31 <trigone> it's not worth it, png is good :)
15:37:42 <monochrom> Someone converted an excerpt of Star Wars into ascii art.
15:37:44 <c_wraith> it was mostly a joke.  aa is a library that converts images to ascii art.  It is.. sort of ok.
15:38:05 <jared-w> Besides, png can be inserted directly into terminals now (if your terminal is setup correctly) so there's no reason for ascii art :p
15:38:30 <monochrom> Oh that's neat.
15:40:19 <Clint> to get further off-topic, mpv -vo tct is better than mplayer -vo aa
15:41:11 <jared-w> monochrom: in fact, I have ranger (a cli file browser) setup to automatically display all images perfectly in the preview as if I was viewing them in feh or a web browser.
15:41:21 <jared-w> But yeah how 'bout them Monads n burritos?
15:46:50 <trigone> i never ate a burrito,  barely know what it is... i hope they have tutorials with good metaphors based on monads
15:47:48 <monochrom> Just eat. This is not a lobster. You don't need a tutorial.
15:48:32 <jared-w> Just eat food; hell you've probably eaten like 500 burritos in your life without knowing they were burritos. Eventually, you'll understand that sometimes the food you hold in your hands is classified as a burrito
15:48:53 <trigone> maybe i even invented burritos without realizing it
15:49:25 <trigone> can i use pipe-based conditionals with lambdas?
15:49:35 * JuanDaugherty pretty sure I remember seeing a burrito monad tutorial
15:49:44 <c_wraith> http://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf that one
15:49:52 <c_wraith> explains burritos nicely
15:55:28 <monochrom> What is pipe-based conditionals?
15:55:51 <trigone> i meant guards, with the pipe symbol
15:56:47 <iqubic> trigone: No. guards and lambdas don't work together
15:58:34 <monochrom> If you turn on LambdaCase you can write \case x | x>0 -> ... and now you have guards again (and general pattern matching again, that's how you get guards)
16:00:38 <trigone> yeah i just saw lambdacase... seems nice :)
16:25:35 <jean-lopes> What is the right way to "read" a haskell function top level definition? for instance this one: foo :: Eq a => a -> a -> Bool
16:26:19 <trigone> would it be a problem if i reversed the associativity of (>=>)?
16:27:18 <trigone> currently it's right associative, but the operation has bi-associative semantics, obviously, and it'd be better for me if it were left-assoc, but maybe there are caveats...
16:27:39 <trigone> :info >=>
16:28:02 <trigone> :i >=>
16:28:55 <geekosaur> jean-lopes, given some type a which has an Eq instance, foo takes two "a"s and produces a Bool
16:29:54 <mbw> jean-lopes: This function is defined for any type 'a', which is an instance of the 'Eq' typeclass, which defines (==) and (/=). If you had to implement foo yourself, this would be the only information about the arguments you would have available. So in this case, "foo x y" could only be "x == y" or "x /= y". It could of course ignore its arguments and always return "True" or "False", or be "undefined" / call 
16:30:00 <mbw> "error", if you are pessimistic.
16:30:53 <c_wraith> mbw: don't forget x == x, y == y, x /= x, y /= y
16:31:26 <c_wraith> mbw: which can do funny things if the Eq instance isn't reflexive, for some reason
16:31:32 <mbw> c_wraith: You're right. "foo" is more complicated than I thought :)
16:31:36 <trigone> along with comparing all these booleans... but that's only if the Eq class is askew
16:33:05 <trigone> so, is it for some reason a bad idea to reverse the associativity of (>=>)?
16:34:28 <trigone> it's not my use case but i just realized that for some reason you can't write ma >>= k >=> k'
16:34:58 <jean-lopes> I would "read" it as: foo is a function for all types member of the Eq typeclass, that receives two values `a` and return a `Bool` value... is that alright? or anything wrong?
16:35:05 <mbw> Does anybody know how to setup spacemacs/haskell-mode/intero via stack? I am having troubles getting this to work, due to incompatibilities between ghc/ghc-mod/cabal and what-not. I tried lts-8.17 and the latest nightly so far, but it just keeps getting worse...
16:35:41 <trigone> > Just 4 >>= (pure . (+ 4)) >=> (pure . (+ 5))
16:35:43 <lambdabot>  error:
16:35:43 <lambdabot>      Precedence parsing error
16:35:43 <lambdabot>          cannot mix ‘>>=’ [infixl 1] and ‘>=>’ [infixr 1] in the same infix e...
16:36:01 <geekosaur> jean-lopes, that falls apart as soon as you have more than one typeclass constrained type variable
16:36:41 <trigone> that choice for (>=>) associativity is a bit weird... but there must be a reason somewhere..
16:38:45 <glguy> mbw: I've been using dante instead, similar feature set and works with cabal build, stack, and cabal new-build
16:39:14 <glguy> dante has been added to spacemacs in the development version
16:40:02 <jean-lopes> geekosaur, in that case... how can I write it? the document I am writing has some functions with two typeclass constraints. It is supposed to be readable by non-haskellers 
16:40:19 <pacak> emacs. *sigh*....
16:41:03 <trigone> pacak: do you prefer vim?
16:41:11 <monochrom> What's wrong with emacs? :)
16:41:23 * monochrom hugs his emacs
16:41:28 <pacak> monochrom: A decent OS that lacks a good text editor.
16:41:29 <mbw> I am normally a vim user. But ghcmod-vim became too slow to the point where I can't work with it anymore
16:42:01 <monochrom> Actually it's a good editor for me but a poor OS. It doesn't have pre-emptive multitasking.
16:42:34 <monochrom> I do admit that if not for that, I would have made it my OS 20 years ago.
16:43:03 <monochrom> I was already about to adopt its web browser instead of Mozilla.
16:43:04 <pacak> mbw: Experimenting with hdevtools (had to submit a few patches) and ale (had to hack a few things to unfuck ghc error messages to it's original formatting) running in neovim. Works nicely on a sizeable project.
16:43:12 <trigone> personally i prefer vim by far (as editor), and i hesitate trying spacemacs, since they advertize they're a bit of the best of each world, but i don't know if they keep their promises... and there's neovim too...
16:43:58 <monochrom> (Oh but if the web browser is waiting, it blocks my other editting buffers too. Bummer. Show stopper. Back to X Window.)
16:44:21 <monochrom> (Oh yes let me speak like X Window and Windows are OSes to make you cry! >:D )
16:44:24 <sm> I think they're working on that
16:44:37 <sm> johnw is sorting it out!
16:45:40 <monochrom> ("Windows is an OS" is supposed to make you cry because it was Windows 3.x back then.)
16:46:02 <monochrom> Anyway what is johnw sorting out?
16:47:12 <sm> everything, I assume
16:47:20 <monochrom> Excellent!
16:47:36 <sm> preemptive multitasking in emacs!
16:47:52 <monochrom> Yes that's the final missing piece!
16:48:04 <sm> well, and a stronger language
16:48:17 <monochrom> Hrm, you may be referring to leksah.
16:49:02 <sm> it's pretty tough to match emacs
16:49:51 <monochrom> Don't try to match emacs. I think it takes programmability too far.
16:50:37 <sm> yes, some future-emacs will probably have more disciplined layering/customizability strategy
16:50:51 <rostero> new to haskell and am trying to start my own project.  i set it up with "stack new".  now i'm trying to add tests.  i see test/Spec.hs.  what type of tests are those?  Should I add the hspec dependency and import "Test.Hspec"
16:50:52 <sm> it won't let you break it
16:51:19 <sm> rostero: "stack test" should just work, no ?
16:51:54 <rostero> "Variable not in scope: hspec :: t0 -> IO ()"
16:52:07 <sm> sounds like a bad stack template
16:52:44 <rostero> it works straight out of the box, just not when I add `main = hspec $ do`
16:54:32 <trigone> how do i talk to lambdabot in private?
16:54:38 <sm> rostero: yes it seems that default template is missing some import statement and hspec package dependency
16:54:45 <monochrom> /msg lambdabot > 1 + 1
16:54:55 <hpc> /query lambdabot
16:54:59 <rostero> i'll try to update
16:55:10 <monochrom> Or generally use any private messaging mechanism in your client.
16:55:13 <trigone> thx hpc and monochrom 
16:55:28 <trigone> monochrom: i use the web, i haven't learned how to use a client either :P
16:55:55 <monochrom> That still probably has a menu or help page on available things to do.
16:56:47 <trigone> can i write multiline definitions with lambdabot?
16:56:55 <monochrom> No.
16:57:24 <monochrom> At some point it's easier to use your own ghci.
16:58:02 <sm> rostero: the hspec template is a better example. stack new myproject hspec
16:58:40 <rostero> sm:  thank you.  also, is hspec preferred over tasty?  i don't know the difference, just heard it mentioned
16:58:46 <trigone> hm it seems i can't redefine already defined operators with @let... is that normal?
16:58:54 <hpc> yes
16:59:05 <trigone> monochrom: yes but i was gonna try to demonstrate something
16:59:14 <hpc> think of @let as appending a line to a file somewhere
16:59:48 <sm> rostero: tasty is a front end for mixing hspec/hunit/quickcheck. hspec on its own is also fine if you like it
16:59:57 <monochrom> You can always begin with @undefine for a fresh start.
17:00:12 <trigone> hpc: well it if did it would refuse defining it in the first place. but here it allowed it, it just doesn't overwrite it, and afterwards when i tried using the shadowing value, it just kept using the predefined value
17:00:23 <sm> it's not clear what the most preferred testing setup is at the moment
17:00:31 <monochrom> There is actually a command that reads an lpaste. But I forgot what it's called.
17:00:49 <geekosaur> "@letlpaste"
17:00:51 <hpc> oh nice
17:01:34 <Eduard_Munteanu> I guess it's a curl wrapper.
17:02:02 <Eduard_Munteanu> Oh, in lambdabot? Hm.
17:02:46 <monochrom> Context!
17:15:09 <trigone> here: http://lpaste.net/358016 -- i'd like opinions
17:20:49 <trigone> nobody?
17:35:03 * jared-w hears crickets chirping
17:36:20 <trigone> i was reading the source code of (!!). i don't really get it: for (xs !! n), in the case (n >= 0), it's equal to
17:36:30 <trigone> foldr (\x r k -> case k of  0 -> x ; _ -> r (k-1)) tooLarge xs n
17:36:57 <trigone> i thought foldr was expecting (a -> b -> b) as first argument, but here the lambda has three arguments?
17:37:22 <trigone> https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.List.html#%21%21
17:38:05 <jared-w> That's some pretty low level code
17:38:09 <trigone> oh wait i think i got it...
17:38:16 <trigone> jared-w: what do you mean?
17:39:04 <jared-w> They use INLINABLE but don't want errors to inline, yet they're trying to not trip up known-bottom optimizations, so they define negIndex and tooLarge for their partial functions
17:40:14 <trigone> jared-w: oh that, well i mostly ignore all this for now :P i mean i understand the code, but not the inlining and so on
17:40:18 <jared-w> They're also using the lambda function to carry around the default erro (the x) for foldr
17:41:23 <jared-w> Which, seems stupid to use foldr instead of foldr1' but I'm guessing they're trying to trigger foldr related optimizations
17:42:04 <trigone> i'm mostly focused on trying to get how they build the function which takes n after foldr did its job...
17:43:43 <jared-w> what do you mean?
17:44:06 <trigone> hm i think i got it... but couldn't it have been written in a more intuitive way? (without skewering their optimization ofc)
17:44:34 <jared-w> "if n is less than 0, throw the negIndex error. Otherwise chew through the list until n is zero and return the current head."
17:45:25 <jared-w> The more intuitive way would've been explicit recursion with (x:xs) and a go function
17:45:29 <trigone> jared-w: the fact foldr outputs a function wasn't immediately clear to me, but then i have less experience in haskell than those who wrote that code
17:47:47 <jared-w> oh, hmm, I see. That's a bit clever actually
17:48:13 <jared-w> :t foldr
17:48:15 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:48:34 <trigone> here b = Int -> a
17:49:49 <trigone> but then i guess it's not really code written to be read by anyone but those who try to maintain it. as you said, it's low-level, so in theory nobody (else) cares how it works as long as it does :P
17:50:07 <jared-w> @src !!
17:50:08 <lambdabot> xs     !! n | n < 0 = undefined
17:50:08 <lambdabot> []     !! _         = undefined
17:50:08 <lambdabot> (x:_)  !! 0         = x
17:50:08 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:50:54 <trigone> maybe it's an old source
17:51:08 <jared-w> No that's the #ifdef USE_REPORT_PRELUDE version of the code
17:51:13 <jared-w> (scroll up a tiny bit)
17:51:52 <trigone> oh.. what decides which version is chosen? i mean, when is USE_REPORT_PRELUDE defined and when is it not?
17:52:16 <jared-w> Probably something to do with haskell98 or some sort of language pragma...
17:52:34 <geekosaur> iirc it's only there as documentation these days
17:52:43 <jared-w> makes sense
17:52:45 <geekosaur> used to be used byhugs and nhc98 back when they shared base with ghc
17:52:52 <trigone> hm ok
17:53:05 <geekosaur> (and, y'know, still existed)
17:53:14 <jared-w> (minor details really)
17:53:24 <jared-w> yeah I gotta say I thought I knew how this foldr worked and now I don't :p
17:56:42 <trigone> what do you mean?
18:06:07 <trigone> what's the extension to have polymorphic bindings in signatures work along the scopes of the value-level code? aka you define f :: a -> b, and inside f you can define g :: a -> c, and ghc recognizes `a` are the same type variable
18:07:29 <trigone> for that matter i don't really get why it's bothering ghc... 
18:10:35 <Lazersmoke> hi, can anyone recommend a good resource for learning how to publish Haskell packages? I have all the code done for my first library and I want to put it up on hackage I think so other people can use it, but I don't know what I need to do to make that happen
18:11:40 <Lazersmoke> is it just a matter of writing decent haddock documentation in the code and doing `stack upload`? or are there more steps involved? I looked at the hackage page for uploading packages and it looks pretty scary because uploading a package is very final and official
18:13:09 <JuanDaugherty> right they don't let you retract
18:13:15 <JuanDaugherty> it's just a quirk
18:13:40 <JuanDaugherty> the minimum thing is put ur stuff up on git hub and then on hackage and see what response you get
18:14:21 <JuanDaugherty> a purposeful quirk, with the obvious rationale
18:14:30 <JuanDaugherty> given they don't really filter stuff
18:14:42 <Lazersmoke> yes, but how do I put it on hackage?
18:15:47 <JuanDaugherty> http://hackage.haskell.org/upload did you start there? how far did you get?
18:16:22 <JuanDaugherty> also a good first step would be to use stack or review your cabal setup for your project
18:17:00 <Lazersmoke> yeah I'm using stack
18:17:20 <Lazersmoke> I guess my real question is what file am I expected to upload to this: http://hackage.haskell.org/packages/upload
18:17:57 <Lazersmoke> or can I just ignore the website entirely and `stack upload` will just do the right thing?
18:18:38 <JuanDaugherty> i've not yet produced one, but assume is same archive that cabal install gets
18:18:59 <JuanDaugherty> should be multiple write ups on this
18:19:37 <pacak> cabal/hackage is the main thing. stack - something invented by those who weren't happy with cabal but stack  got a bunch of problems of it's own.
18:29:06 <JuanDaugherty> i would not count on stack upload, I'd follow the sdist link on the upload page
18:30:21 <Lazersmoke> I have a file with a bunch of usage examples and comments in it. Should that be in exposed-modules, or even in the src folder at all?
18:30:43 <Lazersmoke> right not I have something like Data.<mylibrary> and Data.<mylibrary>.Examples
18:37:33 <trigone> hi! this code doesn't work on me, despite the Language pragma ScopedTypeVariables. can someone help me? http://lpaste.net/358018
18:38:29 <pacak> trigone: elemAt :: forall a. [a] -> Word -> Maybe a
18:38:37 <trigone> (btw the code works perfectly if i remove the signatures which are inside the function body)
18:38:44 <trigone> pacak: you mean i have to add a forall?
18:39:00 <jle`> yes, forall a. scopes the 'a'
18:39:09 <jle`> otherwise haskell doesn't know that the 'a' is scoped for all of the function
18:39:09 <pacak> Or read documentation on ScopedTypeVariables.
18:39:17 <jle`> you can think of it like a type lambda
18:39:26 <jle`> you have to do (\a -> ....) to refer to 'a'
18:39:45 <trigone> jle`: yeah but i thought that it was implicitly done in haskell anyway...
18:40:02 <jle`> just within the same type signature
18:40:08 <trigone> so i have to add ExplicitForAll?
18:40:13 <jle`> you don't
18:40:15 <jle`> you can just type it
18:40:18 <jle`> try it
18:40:31 <pacak> Or read documentation on ScopedTypeVariables.
18:40:52 <jle`> trigone: within the same type signature, forall a. is assumed, but if you want the 'a' binding to span the entire definition, you have to tell haskell that
18:40:53 <iqubic> Is glguy around
18:40:54 <pacak> And on ExplicitForAll
18:41:11 <trigone> oh right. i thought i had read it but it was just haskellwiki
18:41:16 <jle`> haskell's default behavior is to not scope type variables, and ScopedTypeVariables just gives you the *ability* to scope type variables
18:41:25 <jle`> it doesn't make all type variables scoped, that would probably break a bunch of existing code
18:41:39 <trigone> ok i get it! that's cool
18:41:55 <jle`> well, it actually breaks a bunch of existing code that already uses forall a. ... for some reason
18:42:04 <trigone> however it means you can't use forall without scoping the variable in question, right?
18:42:23 <iqubic> Anyone use glirc around here???
18:42:26 <jle`> you can also shadow type variables
18:42:33 <trigone> jle`: how can it break code if it's not on by default ?
18:42:48 <jle`> so if you want to re-use a inside the definition as a fresh type variable, you have to explicitly scope/shadow it inside that inner definition
18:42:51 <trigone> jle`: if i add a forall in a signature inside?
18:42:54 <jle`> yeah
18:43:06 <trigone> ok that's pretty cool :)
18:43:08 <jle`> forall a. inside will shadow 'a', inside a place where 'a' is scoped
18:43:22 <trigone> thanks! :)
18:43:27 <jle`> no problem!
18:45:30 <trigone> there's no perf issues with that right? just asking randomly
18:45:42 <jle`> with shadowing?
18:45:48 <jle`> types only exist at compiletime
18:46:02 <jle`> ghc doesn't internally refer to them as actually 'a' anyway, you would see something like a0, a1, a2, etc.
18:46:05 <jle`> also bye
18:46:08 <jle`> :)
18:47:00 <pacak> and welcome back.
18:47:03 <trigone> (sorry i lost the window, i'm back)
18:47:33 <jle`> ghc doesn't literally internally use type variable names you give, it actually assigns them random ones from a pool
18:47:41 <jle`> so that handles shadowing
18:47:56 <jle`> s/random/arbitrary but unique
18:48:39 <trigone> no i was saying perf issues with using scopedtypevariables in general... even if types are erased at runtime, i'm thinking types can still influence how the remaining code is factored or optimized, can't they?
18:49:21 <jle`> i think it's just basically hints for the typechecker
18:49:26 <jle`> if there was a perf issue that would be a bug
18:49:35 <trigone> ok
18:49:37 <pacak> Benchmarks are your best friend.
18:50:05 <trigone> yeah but i can't speak the language of my best friend yet ^^
18:50:23 <pacak> criterion is a nice one for microbenchmarks
18:50:27 <trigone> anyway, thx :)
18:50:43 <trigone> pacak: maybe in the future :)
18:51:22 <pacak> Otherwise +RTS -sstderr and just compare numbers if your program can run in non-interactive mode.
18:53:41 <trigone> for now i'm not too interested in learning how to benchmark :) but it's on my todo list for sure
18:54:37 <pacak> Then you shouldn't be worried about performance too much either.
18:56:51 <trigone> pacak: well yeah but i still prefer knowing all the pros and cons of any tool before starting to use it everywhere blindly... but you're right it's not really pragmatic purpose, it's just a "since we're talking of that, ..."
18:57:59 <bjarssus> hi guys, there is an internal error occured while im installing stylish-haskell by cabal on windows 10. Im tried to google it but no useful info found, how can i fix it?
18:58:06 <jle`> what is the error
18:58:16 <bjarssus> http://lpaste.net/9185485687955128320
18:58:55 <dfeuer> Does anyone know what michaelt is up to? He seems to have vanished from the face of the web a few months ago. There are `streaming` PRs awaiting his attention.
18:58:57 <jle`> oh boy
18:59:22 <jle`> i'd report it to ghc team
18:59:26 <jle`> maybe see if it works on ghc 8.0
18:59:37 <dfeuer> bjarssus: that's GHC 7.10?
18:59:39 <bjarssus> some it is a bug?
18:59:45 <jle`> it looks like a ghc bug
18:59:50 <dfeuer> Either it's a bug or your installation got hosed somehow.
18:59:52 <jle`> (it's on 8.2)
18:59:59 <bjarssus> version 8.2.1
19:00:16 <dfeuer> I just showed up and missed the intro.
19:00:20 <dfeuer> How do you reproduce that?
19:00:39 <dfeuer> And what platform is that?
19:00:44 <dfeuer> Oh, mingw....
19:00:45 <dfeuer> Ugh.
19:01:16 <dfeuer> I can't help much myself; it sounds like an issue with Windows-specific code.
19:01:43 <iqubic> Anyone know how to log IRC messages?
19:01:56 <iqubic> Or does that depend on the IRC client being used.
19:02:38 <iqubic> And if this is not the right channel for that sort of stuff, then can you direct me elsewhere
19:02:40 <iqubic> ??
19:02:59 <dfeuer> iqubic: it depends on the IRC client or IRC logging bot. And no, this is not the right channel for that sort of stuff, unless you want help writing a logging bot in Haskell.
19:03:12 <dfeuer> In which case this is definitely the right channel ;-)
19:03:40 <iqubic> dfeuer: I don't really want to write a haskell IRC bot 
19:04:28 <jle`> your irc client would usually be where you want look first to log channels
19:04:50 <jle`> but also writing a haskell irc bot is pretty straightforward and is often considered a beginner/intermediate project
19:05:25 <iqubic> jle`: It doesn't look like glirc can do logging for me.
19:05:29 <dfeuer> bjarssus: your issue *smells* like a problem with an overly long pathname, but I'm not familiar with the code in question.
19:05:35 <dfeuer> The error message is definitely awful.
19:06:07 <dfeuer> iqubic: https://wiki.haskell.org/Roll_your_own_IRC_bot
19:06:12 <iqubic> jle`: I'm only asking in here because glguy is the creator of glirc and knows it better than me.
19:06:49 <iqubic> dfeuer: Can I use that for logging stuff, and never chat with my own bot?
19:07:06 <jle`> mhm
19:07:18 <jle`> it's actually a good haskell learning experience
19:07:22 * dfeuer has never written an IRC bot, but knows how to google things. Also, iqubic, glirc seems to have logging facilities.
19:07:25 <dfeuer> At least the library does.
19:07:25 <jle`> most haskellers do an irc bot as a rite of passage
19:07:38 <jle`> i guess s/most/many
19:07:46 <dfeuer> See https://hackage.haskell.org/package/glirc-2.23/docs/Client-Log.html
19:08:02 <dfeuer> I took an odd trajectory, which has led to some ... challenges.
19:08:06 <MP2E> i wrote a silly markov chain irc bot as one of my first haskell projects too! was fun :)
19:08:12 <Clint> iqubic: glirc2 --config-format | grep log
19:08:14 <iqubic> Oh, so that's a thing. 
19:08:24 <dfeuer> Things that many find trivial/easy are utterly baffling to me, and sometimes the other way around.
19:08:44 <remexre> Is MonadFix "supposed to be" implemented for monad transformers? I have a largish stack that I want to use mfix on top of
19:09:08 <iqubic> Ah, I see how that works.
19:09:12 * pacak started by playing with parsers
19:09:16 <dfeuer> Since glirc is written in Haskell, by a good library designer, it's probably also very hackable.
19:09:18 <pacak> I still do
19:09:40 <iqubic> Now I just have to designate a directory to my logs.
19:10:01 <iqubic> pacak: I only just recently learned what a parser does.
19:10:34 <iqubic> It turns a string into an AST by following rules that you lay out with the parser combinators, right?
19:10:39 * dfeuer started playing with list fusion, moved on to data structures, then stream processing (machines), then GHC performance....
19:11:44 <iqubic> Clint: That seems to log everything for a certain server.
19:11:56 <pacak> iqubic: It turns String / ByteString into something with more structure, not necessarily AST.
19:11:58 <iqubic> Hw do I tell what channel the messages cam from
19:12:06 <iqubic> pacak: Ah I see.
19:12:30 * iqubic started by writing tic-tac-toe, and hasn't really gone anywhere else
19:12:40 * iqubic is stil pretty new to haskell
19:13:42 <iqubic> I did however learn of the arrays package and ix while writing my tic-tac-toe game
19:14:27 <iqubic> I made it so that you can play on an m-by-n board, and you need x in a row to win. Where m n and x are command line args
19:14:47 <Clint> iqubic: did you actually try it?
19:14:51 <iqubic> No.
19:15:02 <iqubic> I'm not sure where in my config it goes.
19:15:18 <Clint> you add it to the server stanza
19:15:25 <iqubic> I'll do that.
19:15:31 <Jonno_FTW> 32
19:15:55 <pacak> 33
19:26:46 <iqubic> 34
19:34:51 <jle`> remexre: usually an instance exists if it is possible
19:35:37 <remexre> jle`: I feel like it should be possible for my monad, ExceptT Error (StateT State IO) though
19:36:05 <remexre> Because there's instances for MonadFix IO, MonadFix (Either e), and (although it's different, yeah) MonadFix (ST s)
19:36:14 <remexre> But not the transformer versions
19:36:20 <jle`> ExceptT e (StateT s) should have a MonadFix instance
19:36:30 <jle`> *StateT s IO
19:36:58 <remexre> On my 'stack haddock' documentation, none of the transformers do
19:37:15 <jle`> what version of transformers are you using
19:37:24 <jle`> haddocks on hackage lists those instances
19:37:44 <remexre> Oh, I'm using mtl; is that the issue?
19:37:53 <jle`> it shouldn't be an issue
19:38:00 <jle`> mtl doesn't define any monad transformers
19:38:02 <remexre> Although I do have some modules listed as being from transformers-0.5.2.0
19:38:04 <jle`> it re-exports transformer's transformers
19:38:12 <remexre> hmmmm
19:38:26 <jle`> 0.5.2.0 should be fine too
19:38:35 <jle`> also did you try using mfix
19:39:47 <remexre> erm, no, lemme try that
19:40:11 <remexre> (this is probably gonna be an embarrassing lack-of-reading on my part...)
19:40:17 <jle`> i just tried it with transformers 0.5.2.0 and it works :o
19:40:56 <koz_> Could someone tell me how Data.Functor.Contravariant.Divisible relates to divide-and-conquer algorithms? I assume the naming is not coincidental.
19:41:17 * remexre facepalms
19:41:24 <remexre> jle`: Yeah, it totally just works
19:41:51 <remexre> Do the docs not list it because I don't explicitly depend on transformers?
19:42:53 <monochrom> transformers defines StateT etc. mtl re-exports that and defines MonadState.
19:45:20 <remexre> Yeah, I get that, I'm just wondering why the instance isn't listed in the docs I have locally
19:45:34 <remexre> (The MonadFix instance, not the MonadState one)
20:11:22 <johnw> monochrom: there are no plans for preemptive multitasking in Emacs, despite reports
20:11:33 <monochrom> haha OK!
20:12:04 <athan> If I have a named pipe, could I (in a process) create a new file descriptor, and sink the stdout of the named pipe to that file descriptor, so that my process's stdin isn't consumed? (I guess this isn't haskell specific :x)
20:12:47 <athan> Or would there be a better way to bind to the stdout of that named pipe?
20:13:06 <jle`> remexre: the docs for mtl show the MonadFix instance for me
20:13:15 <jle`> might be a bug in however you are generating your local docs
20:13:20 <jle`> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
20:14:06 <iqubic> Clint: How do I tell if I got logging to work correctly?
20:14:30 <iqubic> I'm not sure I got it to work right.
20:14:58 <Lazersmoke> how do I get stack to include haddock docs with my sdist?
20:18:43 <glguy> Lazersmoke: The docs don't go in the sdist
20:18:55 <Lazersmoke> then how do I get them on hackage?
20:19:21 <glguy> Lazersmoke: There's a separate upload, see the bottom of http://hackage.haskell.org/upload
20:19:25 <Lazersmoke> "You should check that your source bundle builds, including the haddock documentation if it's a library." from the upload page
20:19:43 <glguy> Yeah, you should check that your source builds, and your documentation builds
20:19:59 <glguy> That's different from "sdist", which is the source files tarball
20:20:14 <n_blownapart> https://ptpb.pw/TjWJ hi I'm getting a parse error on line 3, on the arrow.
20:20:17 <iqubic> glguy: I'm unable to get glirc to log IRC for me.
20:20:25 <iqubic> Can you help me?
20:20:33 <athan> Is there a `newFileDescriptor :: IO (Int, Handle)` function, which returns the next index starting at 3?
20:20:52 <boj> n_blownapart: those need to be =, not ->
20:20:52 <Lazersmoke> oh I see
20:20:55 <pacak> n_blownapart: = instead of ->
20:21:05 <glguy> athan: You get a new Handle with openFile
20:21:08 <Lazersmoke> there is a docs tarball in addition to the source tarball then?
20:21:26 <athan> glguy: Well, I'm trying to open a new input stream / pipe thing
20:21:33 <glguy> Lazersmoke: Yes, which is what is generated and uploaded by the commands at the bottom of the link I sent earlier
20:21:37 <athan> ...isn't that possible with POSIX?
20:21:48 <Lazersmoke> ok cool thank you
20:21:55 <n_blownapart> oh thanks,  one sec that is odd boj pacak 
20:22:26 <iqubic> glguy: this doesn't log anything.http://termbin.com/a9kt
20:22:35 <iqubic> http://termbin.com/a9kt
20:22:53 <iqubic> I typed "/reload" to load the new config.
20:23:20 <glguy> athan: You can get a new pair of linked file descriptors with pipe(2), but I don't know which Haskell package exposes that off the top of my head
20:23:38 <athan> ahhh okay, sorry & thank you!
20:23:44 <glguy> athan: and the unix package has fdToHandle
20:24:04 <glguy> Oh, unix package also has: createPipe :: IO (Fd, Fd)
20:24:39 <athan> ahh there we go, huh
20:24:55 <athan> so how would you open a named pipe? Calling readFile doesn't block :\
20:25:20 <athan> vs. readLn which would
20:27:30 <iqubic> glguy: Do you know how to get glirc to log chat?
20:28:29 <n_blownapart> boj pacak sorry why is the syntax different between these two exactly? https://ptpb.pw/lp4b
20:28:53 <pacak> yes, syntax is different
20:29:11 <glguy> iqubic: Have you restarted your client since adding that line to your configuration file?
20:29:58 <glguy> or reconnected to the network?
20:30:01 <iqubic> Do I need to?
20:30:09 <iqubic> Isn't reload enough?
20:30:16 <n_blownapart> they both resolve to booleans. so you just need equal signs with guards and functions with case statements? pacak 
20:31:06 <pacak> n_blownapart: = with guards, -> in case
20:33:42 <n_blownapart> thanks pacak got it
20:35:06 <iqubic> glguy: Do I really need to reconnect to freenode to get glirc to start logging for me?
20:41:05 * hackagebot brick 0.24.2 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
20:41:18 <iqubic> Brick is awesome.
20:42:27 <jle`> indeed
21:20:05 <iqubic> glguy: glirc still isn't logging stuff for me.
21:20:18 <iqubic> Oh, wait yes it is.
21:57:46 <dmwit> athan: The unix package also provides createNamedPipe.
21:58:40 <dmwit> I'm a bit hazy on what problem you're trying to solve by using a named pipe instead of an anonymous pipe, though.
21:58:50 <dmwit> Usually that's only needed for IPC.
21:59:15 <iqubic> dmwit: Somehow I read that as IRC.
22:00:31 <dmwit> (...I guess anonymous pipes are usually used for IPC, too, so I'm not capturing the distinction I meant to make carefully. Dangit.)
22:11:46 <iqubic> Why is a named pipe needed?
22:13:43 <dmwit> They are often used when a single input stream (i.e. stdin) is not enough.
22:14:44 <dsal> Hmm...  My lack of experience caught up with me again.  How do I define a type that has a field that's a function that can take any value (without constraints)?
22:15:17 <dmwit> data Fun a = Fun (a -> Bool)
22:15:33 <dsal> I tried       , write :: IO a -> IO Handle -> IO ()
22:15:38 <dsal> Oh.  I see
22:15:40 <dmwit> Or, to answer another way: "a function that can take any value without constraints" is non-Haskell-ic.
22:15:56 <dsal> Yeah, it's the a on the left of the equal that was the issue.  Thanks.
22:16:22 <dmwit> `IO a -> IO Handle -> IO ()` is a strange type. Why not `a -> Handle -> IO ()`?
22:16:59 <dsal> I'm not quite sure what I'm doing here yet.  Kind of sketching.
22:17:54 <dsal> Taking off all the IOs I don't need is a good start, though.
22:18:25 <dmwit> In fact, I bet even dropping the `Handle` argument will be worthwhile.
22:18:33 <dmwit> Include it in the closure defining the field, instead.
22:18:48 <dmwit> (Maybe. Depends what you want.)
22:19:02 <iqubic> dmwit: what's a closure? Is that like a record?
22:19:20 <dsal> This record is going to be holding the Handle itself, otherwise I would.
22:19:47 <dmwit> dsal: See, now I'm even more sure you don't want to take the `Handle` as an argument. Drop both the argument and the `Handle` field.
22:19:49 <dsal> I started down that path -- but I need to be able to open and close the log files under certain circumstances, and would like that managed cleanly into a single 'write' call.
22:20:09 <dmwit> Okay. =)
22:21:04 <iqubic> dsal: use @ to bind the fields of the record to names for this one function. Then you can use the handle all you want in that function.
22:21:39 <dsal> I'm unfamiliar with that concept.
22:22:04 <buttons840> mkWeakIORef r@(IORef (STRef r#)) (IO finalizer) = ...  <- What is the "r#" in this code? Looking for some terms I can google to help me find more
22:22:16 <buttons840> the hash (#) is new to me
22:22:30 <iqubic> that. That right there is an example of @.
22:22:48 <dmwit> dsal: I think they're just suggesting using as-patterns, as in `foo bar@(Constructor { field1 = foo, field2 = bar })`, which defines `bar` to be the whole record, `foo` to be the value of `field1`, and `bar` to be the value of `field2`.
22:23:00 <iqubic> I am.
22:23:00 <dsal> Oh.  I'm familiar with that, yeah.
22:23:10 <iqubic> I forgot the name of the concept.
22:23:15 <pacak> hash is usually used for unboxed things.
22:23:44 <dsal> I don't want the function to get the whole record, I just want it to know how to write a single 'a' to a Handle
22:23:52 <dmwit> buttons840: You might take a look at the documentation for the MagicHash extension.
22:23:57 <dsal> Most of the time, when the API is called to do such a write, that function won't be called.
22:24:10 <dmwit> buttons840: I suspect it's just part of the variable name in the case you're looking at, though.
22:24:16 <dsal> Sometimes it'll cause a file to be created, sometimes closed.
22:25:50 <buttons840> dmwit: ah, "The hash sign does not change semantics at all. We tend to use variable names ending in “#” for unboxed values or types (e.g. Int#), but there is no requirement to do so"
22:26:05 <buttons840> so "r#" is just a name in a patern match :)
22:26:29 <iqubic> Sounds good.
22:26:39 <dsal> Working with time in haskell is not as nice as I'd like.
22:26:50 <dsal> It's not the worst, but it's a bit odd.
22:26:57 <iqubic> Check if r# is used in the function body, buttons840.
22:29:10 <iqubic> if it really is just a binding for a pattern match, it should be used in the function body on the right hand side of the =
23:10:45 <remexre> What's the "best" way to include some files as strings into my executable?
23:10:58 <remexre> Template Haskell?
23:11:07 <cocreature> @hackage file-embed
23:11:08 <lambdabot> http://hackage.haskell.org/package/file-embed
23:11:09 <cocreature> ^ remexre 
23:11:23 <remexre> cool, thanks!
23:22:35 <timofonic> Hello
23:23:00 <timofonic> What happened to Timber language? It seems dead http://www.timber-lang.org
23:25:19 <Axman6> hmm, I remember that... I guess it died
23:25:50 <timofonic> Axman6: It seemed interesting. Are there an alternative?
23:41:35 * hackagebot columbia 0.1.1 – Enhanced serialization for media that support seeking. – https://hackage.haskell.org/package/columbia
23:51:41 <norc_> Good morning. I want to fold a Foldable but I don't have an identity element (yet) to fold into. Is there a generic way to fold into the `first` element?
23:52:02 <cocreature> :t foldr1
23:52:04 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
23:52:08 <cocreature> ^ norc_ 
23:52:11 --- mode: geekosaur set -o geekosaur
23:52:14 <norc_> cocreature: Oh beautiful thank you.
23:52:16 <cocreature> norc_: note that this will crash for non-empty lists
23:52:23 <cocreature> there is also foldl1'
23:52:41 <cocreature> eh it will crash for _empty_ lists
23:53:02 <norc_> cocreature: Unlike Haskell I corrected that in my head for you. :-P
23:53:25 <norc_> cocreature: Thank you. Where does foldl1' come from? It's not in my prelude
23:54:08 <boj> @hoogle foldl1'
23:54:08 <lambdabot> Data.List foldl1' :: (a -> a -> a) -> [a] -> a
23:54:08 <lambdabot> GHC.OldList foldl1' :: (a -> a -> a) -> [a] -> a
23:54:08 <lambdabot> Data.ByteString foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
23:54:51 <norc_> Oh I thought hoogle was just for searching types. This is getting better every day. :)
23:55:06 <boj> types, modules, functions :)
23:55:29 <cocreature> norc_: if you are not interested in the type search, I highly recommend that you use http://hoogle.haskell.org/ instead of http://haskell.org/hoogle
23:55:38 <cocreature> it indexes significantly more packages
23:55:39 <norc_> boj: It's really strange to think in terms of "I know what type signature it must have, but I don't know what its called".
23:55:50 <norc_> But also really relaxing because describing a type is concise, describing behavior is not. 
23:56:28 <boj> norc_: agreed. i had that happen the other day, "i know i want a function in this shape..." and hoogle turned it up
23:57:01 <boj> cocreature: oh, that is fancy
23:57:27 <boj> i've been going to hayoo for the weird things i couldn't find on regular ol' hoogle
23:57:38 <norc_> Is hoogle available offline as well?
23:57:55 <norc_> I mean not that it's a biggie in this day of age, but I frequently work on the train. :-)
23:58:21 <boj> not sure actually
