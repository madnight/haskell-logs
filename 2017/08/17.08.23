00:00:12 <tdammers> trigone: I prefer an overly simple module system over an unnecessarily complex one though
00:01:12 * hackagebot yesod-form 1.4.15 – Form handling support for Yesod Web Framework – https://hackage.haskell.org/package/yesod-form
00:01:14 * ski started with BASIC, assembler (6502) ..
00:01:19 <ski> @quote mutilated
00:01:19 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
00:01:19 <lambdabot> regeneration."
00:01:31 <halogenandtoast> ski: yup
00:01:31 <halogenandtoast> same boat
00:01:36 <BernhardPosselt> btw, OO was hard to learn as well
00:01:51 <ski> (perhaps it explains why i enjoy continuations so much ..)
00:02:09 <halogenandtoast> I don't see how anyone could "enjoy" continuations
00:02:13 <BernhardPosselt> as in "why would i ever want to use a class when i have functions"
00:02:39 <tdammers> OO is deceptive
00:02:57 <trigone> tdammers: yeah, but haskell's import/export rules are weird... and the syntax is verbose and repetitive
00:03:00 <tdammers> it gives you this intuition of thing in your code that can be modeled to be just like things in the real world
00:03:11 <tdammers> class Dog { public void bark(); } // and all that
00:03:55 <tdammers> trigone: the rules aren't weird, they're very consistent, and simple at that. Too simple, unfortunately, but there is little room for confusion there IMO
00:04:01 <halogenandtoast> tdammers: You can do that, do you have a counter example?
00:04:39 <BernhardPosselt> well the issue is that you unlearn OO again to use it :D
00:05:00 <BernhardPosselt> you have data objects (records) and services (functions)
00:05:03 <tdammers> halogenandtoast: you mean for the "things that are modeled just like things in the real world"?
00:05:20 <BernhardPosselt> because otherwise side effects get you
00:05:32 <halogenandtoast> tdammers: I guess I want to know why you think it's deceptive
00:05:40 <halogenandtoast> so I was looking for an example where I would have been deceived.
00:06:02 <tdammers> halogenandtoast: because not all things in the real world are actors, and not all things that happen in the real world can be pinned to a single actor in an obvious way
00:06:24 <tdammers> foot.kick(ball)? ball.kickedBy(foot)? human.kick(ball, foot)?
00:06:55 <tdammers> or what about collision checking and handling in, say, a space shooter game
00:06:59 <BernhardPosselt> btw how do you deal with the absence of annotations in haskell?
00:07:08 <tdammers> spaceship.collideWith(otherSpaceship)
00:07:12 <ski> annotations ?
00:07:25 <tdammers> that doesn't make sense, they're equal partners in this, and the "collide" method shouldn't be tied to either of them
00:07:28 <BernhardPosselt> e.g. easy ways of saying a record name should be validated to be not empt
00:07:28 <BernhardPosselt> y
00:07:42 <sssilver_> Anyone else gets annoyed by Haskell , formatting practices?
00:07:49 <BernhardPosselt> in java you do something like @NotBlank private String name;
00:08:04 <halogenandtoast> TimeSpaceContinuum.hasCollisionBetween(spaceship, otherSpaceship)
00:08:05 <sssilver_> I'm a bit of a typography nerd, so reading lines that begin with a comma just drive me into this primal rage
00:08:18 <BernhardPosselt> then a validation function checks the annotations on the object and runs validation functions
00:08:19 <speak> , interesting
00:08:24 * ski gets annoyed by lines ending with a comma
00:08:51 * cocreature gets annoyed by lines ending
00:09:18 <sssilver_> I guess I'm alone then, peculiar
00:09:32 <halogenandtoast> sssilver_: I'm sure someone somewhere agrees with you
00:09:38 * trigone thinks we should get rid of commas definitively (unless between items in the same line, just like `;`)
00:10:07 <trigone> s/in/on
00:10:17 <sssilver_> trigone that sounds great, except that'll probably never happen :(
00:10:27 <halogenandtoast> that is correct
00:10:42 <lyxia> Just keep in mind Haskell's not English.
00:10:57 <lyxia> It's Scottish.
00:10:59 <trigone> sssilver_: who knows...
00:11:03 <speak> lyxia: Haha
00:12:17 <sssilver_> well I'm not digging this whole scottish thing then, and English isn't even my first or second language
00:12:24 <trigone> lyxia: explains a lot :P "Monad. noun. Ancient Celt for ..."
00:12:45 <sssilver_> so if I wrote my code with commas at the end of lines instead of beginning, would most of you get pretty annoyed?
00:13:06 <dysfun> i have bigger fish to fry than comma placement, personally
00:13:31 <ski> not as annoyed, if you made sure to align them
00:13:32 <halogenandtoast> sssilver_: you do you man
00:13:53 <halogenandtoast> I agree about the alignment though
00:14:43 <ski> (perhaps now you'll see the error of your ways ..)
00:17:49 <xzhu> Does Haskell have a idiomatic way of organizing data/functions alternative to the way OOP does things? I feel that although OOP-like program is possible in Haskell, it's not a first-class paradigm.
00:18:23 <ski> it's called algebraic data types with pattern-matching
00:18:47 <sssilver_> xzhu what do you mean by saying "OOP-like program"?
00:18:51 <ski> (sum/variant type)
00:19:01 <xzhu> For example, let's say we are building a complex GUI program like Photoshop
00:19:04 <sssilver_> like Smalltalk kind of a deal or Java kind of a deal?
00:19:16 <xzhu> and we need a set of tools
00:19:29 <xzhu> in OOP maybe we have a class called "Tool"
00:19:42 <ski> (which is dual to the OO way of record types and "message-dispatching" (specifying how a record/object will behave when sent messages that it undrstands))
00:19:47 <xzhu> under which we have sub-classes like "Brush" and "Eraser"
00:19:50 <sssilver_> and then you inherit from it right
00:19:54 <xzhu> yes
00:19:59 <sssilver_> yeah you don't do that in haskell
00:20:05 <sssilver_> that's quite unidiomatic
00:20:16 <sssilver_> you shouldn't do that or try to achieve that design
00:20:36 <speak> And xzhu to be fair that is often not the best way to do things even in OOP
00:20:38 <ski> you can do it, if you really want to (but often there'sn't much need)
00:20:43 <sssilver_> speak +1
00:21:03 <sssilver_> xzhu imagine inheritance doesn't exist as a concept, how would you model it?
00:21:10 <sssilver_> "composition over inheritance" sort of a deal
00:21:22 <sssilver_> instead of saying "brush is a tool"
00:21:29 * ski . o O ( "Implementation inheritance, or interface inheritance?" )
00:21:47 <sssilver_> you'd think more in terms of "brush has a tool component to it"
00:21:58 <sssilver_> or "tool facet"
00:22:48 <sssilver_> or even say "there's this way of interacting with every tool (interface), and here's the implementation of that for Brush"
00:23:11 <sssilver_> if you think about it, it's a better paradigm
00:23:47 <sssilver_> you have a separate abstract concept of what it means to be a tool, and then you teach your brush how to act like a tool
00:24:13 <ski> .. as a bit silly example, suppose that we want to have a type "shape". a shape can be of various kinds : circles, rectangles, triangles, &c.. a shape also supports various operations, like perimeter, area, &c.
00:25:07 <xzhu> I see. I guess this solves one part of OO: inheritance. How about state reasoning? Having an object "concept" helps me reason: say we have a "Square" and a "Circle" on the screen, it's convenience for me to just say
00:25:08 <ski> we can visualize this as a rectangular diagram, with different shapes listed on different rows, while the operations they support are listed on the columns
00:25:20 <xzhu> square1.x += 1
00:25:37 <sssilver_> xzhu it's a nuisance masked as a convenience
00:25:47 <sssilver_> xzhu a bomb that's waiting to blow when you least expect it
00:25:53 <halogenandtoast> xzhu: I might get shunned but you can use lenses for something similar in Haskell
00:26:00 * speak shuns halogenandtoast
00:26:04 <halogenandtoast> damnut
00:26:07 <halogenandtoast> *damnit
00:26:23 <ski> in the OO approach, we cut this diagram up into separate lines. "shape" is an interface (or abstract base class), each particular shape kind (row) is a class that implements this interface. each class (shape kind) *groups* the implementations of the operations for that shape kind
00:26:37 <speak> xzhu: You can define a square and add 1 to it's x axis, if you want
00:26:53 <speak> You'll just get a new square as an answer
00:26:54 <sssilver_> (I can't believe I'm assisting someone with Haskell programming principles, yet I have no clue how to make a simple web app ROFL)
00:27:02 <xzhu> halogenandtoast: I know a bit of lens, but I feel that it's not first-class (if you know what I mean), like error messages for TH is not that easy to understand
00:27:19 <halogenandtoast> xzhu: A really fantastic talk about somehting like this is the protocol oriented programming at the 2015 WWDC
00:27:20 <speak> xzhu: Don't let the lens comment throw you off, that is irrelevant to this discusion :P
00:27:34 <speak> *discussion
00:27:40 <speak> I mean except as a joke
00:27:43 <ski> in the FP approach, we cut this diagram up into separate columns. "shape" is an algebraic data type (variant type / sum type), each operation is a pattern-matching function that *groups* the implementations of *that* operation on all the shape kinds (data constructors)
00:28:25 <speak> As a bonus, handling more things are just "data" helps up a LOT when you actually want to save the state of your program in some form
00:28:33 <speak> *more things as just "data"
00:28:38 <ertes-w> lo
00:28:57 <ski> if you want to add a new shape kind, then in the OO approach, you just add a new class, not touching the existing ones -- while in the FP approach, you need to modify *all* the pattern-matching operations (functions) to handle the new case (shape kind / data constructor)
00:29:27 <sssilver_> xzhu if you think of your problem less in terms of "I wanna tell the computer what to do" and more in terms of "I wanna tell the computer what I want", you'll realize that something.x += 1 doesn't even have any meaning
00:29:43 <speak> Well said, sssilver_ 
00:29:57 <ski> if you want to add a new operations, then in the FP approach, you just add a new pattern-matching operation, not touching the existing ones -- while in the OO approach, you need to modify *all* the classes to support the new operation
00:30:09 <BernhardPosselt> sssilver_: what if i just want to update registers
00:30:42 <ski> so, if you're more likely to add a new operation, the FP (variant type) approach may be better
00:30:47 <sssilver_> BernhardPosselt that's a side effect :) you wrap it
00:30:59 <BernhardPosselt> yep, but you need to wrap it somewhere :D
00:31:00 <ski> otoh, if you're more likely to add a new shape kind, the OO (record type) approach may be better
00:31:01 <jle`> don't wrap it, represent it :O
00:31:07 <ertes-w> (i just joined, so i have little context, but it seems like a reference to data types a la carte is coming up soon)
00:31:12 <ski> xzhu : makes any sense ?
00:31:24 <BernhardPosselt> what i mean is: you need to build an abstraction somewhere
00:31:31 <sssilver_> BernhardPosselt of course
00:32:00 <sssilver_> the question is, to what extent can we localize it, and be able to reason about our program as a whole, and make mathematically correct assumptions/conclusions
00:32:14 <tdammers> halogenandtoast: TimeSpaceContinuum is just another name for a God Class, isn't it
00:32:37 <ertes-w> is there any more context than "expression problem"?
00:32:44 <halogenandtoast> tdammers: might as well be.
00:32:45 <xzhu> ski: wait ... if I need a new operation for all tools, don't I just need to change the root class?
00:32:57 <sssilver_> xzhu what's root? what's class? :P
00:33:03 <sssilver_> ...what's change?
00:33:06 <ertes-w> xzhu: depends
00:33:13 <halogenandtoast> xzhu: It's unlikely that every instance would implement it the same
00:33:19 <tdammers> halogenandtoast: so might as well throw OOP out the window at that point, make hasCollision a free function, and just wrap related code in a module
00:33:26 <ertes-w> xzhu: sometimes inheriting an implementation is good enough, but often it's not
00:33:31 <sssilver_> does Haskell have default implementations like default protocol extensions in Swift? does anyone know?
00:33:34 <halogenandtoast> tdammers: yeah I was making a joke of course
00:33:35 <sssilver_> it might be what he/she needs
00:33:56 <tdammers> halogenandtoast: but it's actually how it's done in games, really
00:34:14 <halogenandtoast> tdammers: I use quadtrees myself
00:34:15 <halogenandtoast> :p
00:34:28 <speak> xzhu: In any case if you're worried about having to copy and paste stuff in Haskell because it doesn't have inheritance; that is not how it works, it's just done in a different way
00:34:34 <ski> xzhu : please note that the contrast i'm trying to draw here ignores lots of other "bells and whistles" of OO (and FP) (such as e.g. implementation inheritance, pervasive state) .. but i think it's good to know about this basic trade-off at the bottom of things
00:34:36 <tdammers> halogenandtoast: you have a World object that contains all the entities, and the entities don't really "do" anything, they just describe their physical properties, more or less
00:34:37 <speak> xzhu: You can make vastly reusable components
00:34:45 <halogenandtoast> tdammers: yup
00:34:54 <ertes-w> xzhu: in a language like haskell with ADTs and a functional approach it's best not to *change* types…  there are other extension mechanisms than *changing*
00:35:07 <ertes-w> xzhu: my personal favourite approach is *translating*
00:35:24 <tdammers> halogenandtoast: so the entire premise of OOP, namely "tie state (properties) and behavior (methods) together closely, and encapsulate at the object level" falls apart
00:35:36 <speak> tdammers: Exactly
00:35:41 <ertes-w> xzhu: rationale for not changing: every ADT represents a certain complete language…  it's not supposed to change
00:35:53 <speak> In doing OOP, the more I let go of what I learnt about OOP in uni, the better off I was
00:35:57 <tdammers> you game entities aren't objects, they're just baroque implementations of records
00:36:11 <ertes-w> xzhu: much like, say, Maybe should never add constructors beyond the standard Just and Nothing, because that would change the language of Maybe drastically
00:36:14 <speak> Tying data and functionality together is such a badly thought out thing
00:36:24 <halogenandtoast> tdammers: there are options though for a lot of these things, they just aren't pragmatic
00:36:28 <dysfun> that's quite arguable though
00:36:29 <ski> xzhu : by "a new operation for all tools" do you mean one which needs a specific (different) implementation for each tool, or rather a single common one (possibly itself calling (directly or indirectly) operations which are specific to each tool) ?
00:36:38 <sssilver_> I suppose xzhu has a bit of a point for modeling UI. Imagine you have a button and when you click it, a whole bunch of stuff happens, but you also want to let the particular button user customize the default implementation. Perhaps OOP lends itself more nicely for this than FP.
00:36:54 <halogenandtoast> like modelling Collision as it's own class.
00:37:03 <ertes-w> xzhu: in a game it would therefore not necessarily be a good idea to have *object* types, but rather *semantics* types…  the difference is that the latter describes something in a more intrinsic way
00:37:04 <tdammers> halogenandtoast: my point is, once you go beyond naive and overly simplistic toy examples, a clean OO design tends to gravitate towards "separate data from logic"
00:37:05 <dysfun> for example, in modern c++, the OO provides a scope for cleanup too
00:37:17 <halogenandtoast> tdammers: very true
00:37:35 <tdammers> sssilver_: yes, GUI programming has special needs that OOP could serve well
00:37:35 <speak> tdammers: Exactly
00:37:38 <ertes-w> xzhu: for a game object you're probably not that interested in the actual run-time properties, but in the way it behaves in relation to other objects…  that idea can be encoded as a type
00:38:04 <xzhu> ski: I guess if it is a single common implementation, it would be the same in both OOP and FP
00:38:11 <ski> yes
00:38:15 <tdammers> sssilver_: but even there, other paradigms (somethingreactivesomething) have become increasingly popular recently
00:38:21 <ertes-w> xzhu: it's actually not much different in OO, where you express this non-interest in the way you split your members into private, protected and public members
00:39:16 <ertes-w> xzhu: except that in haskell only what would have been your "root class" would be encoded as a type, and all subclasses would be encoded as *values* of that type
00:40:11 <xzhu> ertes-w: could you explain *semantics* types?
00:40:27 <ertes-w> this also implies the kind of openness you would expect from a class hierarchy: you can always add new *values* of a type, and existing values don't necessarily need to know about new ones popping up
00:40:44 <ertes-w> xzhu: well, my favourite mini-example is the good old hangman game
00:40:53 <ertes-w> it's an instance of a "guessing game"
00:41:07 <ski> xzhu : in the version of "OO" i was suggesting, there is no such thing as a class with at least some implementation code in it, being subclassed. (or if you prefer, we ignore being able to use such abilities of the language). there's only completely separate classes, implementing interfaces (or (fully) abstract base classes, if you prefer) (the latter can inherit, though (interface inheritance))
00:42:11 <ertes-w> xzhu: here is a very general notion of "guessing game": data GuessGame f a b = Won (f b) | Guess (f (Maybe b)) (a -> Maybe (GuessGame f a b))
00:42:39 <ertes-w> xzhu: as you can see it does *not* encode properties, but only the essence of what makes a guessing game
00:42:42 <ski> xzhu : being able to take a class with implementation in it, and subclass it, makes the picture here less "symmetric", wrt FP. (however, one could imagine a corresponding "coinheritance" of pattern-matching functions in FP. i don't know if anyone has ever tried implementing this. Erik Poll wrote some papers about this, though)
00:42:47 <ski> @where ErikPoll
00:42:47 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
00:42:48 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
00:42:48 <lambdabot> pdf>
00:42:58 <ski> (first two papers)
00:43:33 <ertes-w> xzhu: a hangman game would be a value of type (GuessGame [] Char Char)
00:43:38 <koz_> ski: Thanks! I will read those too.
00:43:47 <halogenandtoast> ertes-w: any chance you can extend that guessing game example into a working example?
00:43:55 <halogenandtoast> I know that's probably asking a lot
00:44:00 <halogenandtoast> but I'm intrigued
00:44:25 * ski notes ertes-w is addressing something related
00:44:54 <ski> @google copatterns andreas abel
00:44:56 <lambdabot> http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
00:44:56 <lambdabot> Title: Copatterns
00:45:00 <ski> koz_ : also see ^
00:45:14 <ertes-w> halogenandtoast: i'd encourage you to try to do it yourself, after this little explanation:  a guessing game is either won (with the full answer) or still running with a challenge (a *partial* answer) and a "guess function" that returns the updated game
00:45:44 <ertes-w> or doesn't, if the guess did not make any change
00:46:03 <halogenandtoast> ertes-w: I don't understand the data constructors though
00:46:12 <ertes-w> halogenandtoast: my explanation didn't help?
00:46:25 <halogenandtoast> I'll mess with it
00:46:33 <ertes-w> halogenandtoast: ok, let me give you a simple number guessing game:
00:46:57 <ertes-w> simpleGuess :: (Eq a) => a -> GuessGame Identity a a
00:47:05 <xzhu> ertes-w: Huh ... in this way the entire *space* of states is modeled as the type it self
00:47:35 <ertes-w> simpleGuess x = Guess (Identity Nothing) (\x' -> if x == x' then Just (Won (Identity x)) else Nothing)
00:47:36 <xzhu> ertes-w: I guess after all mathematically speaking a "type" *is* a structured *set*
00:47:55 <ertes-w> xzhu: exactly…  types and sets are in fact very related
00:48:23 <ertes-w> halogenandtoast: my first step would be to write an interpreter for that simple guessing game
00:49:28 * ski . o O ( material vs. structural sets <http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html> )
00:49:41 <xzhu> However, I think the FP's way of doing things requires that you know the "big picture" of the problem very well
00:49:57 <xzhu> Or at least it forces you to first figure out the big picture
00:50:03 <sssilver> it's quite sad that the most performant factorial implementation in Haskell is so drastically and conceptually different from the most elegant implementation (f = f * (f -1))
00:50:29 <sssilver> xzhu that's pretty much every programming in every paradigm
00:50:30 <xzhu> which, in some cases it's harder than following along a stream of steps
00:50:33 <jle`> sssilver: is that really the most elegant implementation
00:50:36 <ertes-w> halogenandtoast: simpleGuessStdio :: (Eq a, Read a, Show a) => GuessGame Identity a a -> IO ()
00:50:42 <jle`> sssilver: how about factorial n = product [1 .. n]
00:50:51 <jle`> which is the typical definition given when learning about factorial
00:50:53 <sssilver> xzhu although to be fair FP leaves you more flexibility down the road once decisions have been made
00:50:59 <ski> @where evolution
00:51:00 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
00:51:00 <sssilver> that's been my experience anyway
00:51:06 <jle`> sssilver: see https://en.wikipedia.org/wiki/Factorial
00:51:20 <sssilver> jle` fair point
00:51:43 <ertes-w> sssilver: well, classical mathematics rarely takes actual *computation* into account
00:51:48 <xzhu> sssilver: I would say much less so in imperative programming: for example to program a simple game like that
00:51:55 <ertes-w> sssilver: that's why the factorial function is so beautiful in math
00:52:13 <xzhu> sssilver: you could literally type as you imagine the game procedure
00:52:34 <xzhu> sssilver: "I do this, if this happends, then this would happen next ..."
00:53:00 <ski> it's easy to do that in Haskell
00:53:09 <sssilver> xzhu I mean, you literally type as you imagine it in Haskell too
00:53:10 <ski> (but may not be a good idea)
00:53:34 <sssilver> "let's imagine we have a board (codes the board type)"
00:53:36 <xzhu> not "data GuessGame f a b = Won (f b) | Guess (f (Maybe b)) (a -> Maybe (GuessGame f a b))"
00:53:40 <xzhu> at least not fore me
00:53:58 <halogenandtoast> ertes-w: alright trying to implement simpleGuessStdio, if I run into a question I'll ask
00:54:05 <ertes-w> halogenandtoast: feel free
00:54:38 <ertes-w> xzhu: actually the *implementation* of a GuessGame can be interpreted as imperative…  just look at simpleGuess
00:54:52 <sssilver> xzhu usually in iterative languages if I code as I think it ends up in a disaster :) but maybe I'm below average (which I probably am). 
00:55:05 <ertes-w> xzhu: "if the guessed value was correct, the game is won, otherwise we will ask again in the next iteration"
00:55:10 <sssilver> I find it easier to start modeling some core concepts first and then going from there
00:56:22 <ertes-w> xzhu: the main difference is that it doesn't include the main loop, but gives control back to a "coroutine" (the game interpreter, which presents the actual UI to the user)
00:56:35 <ertes-w> xzhu: so you get some nice separation of concerns along the way: game logic vs. UI
00:57:17 <xzhu> I guess these simple games are not the best examples. A better example would be many algorithms in Graph Theory, and maybe PDE algorithms
00:57:40 <sssilver> xzhu give us a graph algorithm that'd be more natural to code OOP-style
00:57:51 <sssilver> you're shooting yourself in the foot :)
00:58:13 <ertes-w> xzhu: you would be surprised how versatile GuessGame is =)
00:58:41 <xzhu> sssilver: not necessarily OOP, I we have somehow changed the topic to comparing between imperative and delarative (?) programming
00:58:49 <halogenandtoast> ertes: Something like this? http://lpaste.net/357905
00:58:51 <ertes-w> xzhu: i can encode many of the typical time-waster online games in just this definition of GuessGame, and then i can implement a web application interpreter =)
00:59:00 <sssilver> sure, my point still stands xzhu 
00:59:13 <halogenandtoast> I don't understand the first value of the constructor I guess
00:59:17 <ertes-w> xzhu: a more fitting name for "GuessGame" might be "Solitaire"
00:59:50 <xzhu> sssilver: hold on ... :)
01:00:23 <ertes-w> xzhu: the point is: i will not have to extend Solitaire or create a new type to make a new game…  i just have to write a new value
01:00:45 <mud> sssilver: Quite a few algorithms are usually expressed imperatively, including graph algorithms. Some of them you can do functionally, in a non-imperative way, but it's not often clear how. Even something like floyd-warshall, kind of hard to see how to do that without the performance going to hell.
01:00:54 <ertes-w> xzhu: as for the UI i have two options: either i *translate* a GuessGame into a form that an existing interpreter can handle, or i write a new interpreter
01:01:33 <ertes-w> the latter happens when a game is so different from existing games that it requires a new kind of UI
01:02:08 <sssilver> also yes UI sucks
01:02:15 <sssilver> building a UI system is not the problem
01:02:24 <ertes-w> halogenandtoast: the first value is the *challenge*
01:02:27 <sssilver> making an extensible UI system with decent ergonomics is the problem
01:02:28 <xzhu> sssilver: Yeah, just like @mud pointed out, take a look at https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Algorithm
01:02:43 <halogenandtoast> ertes-w: the (f (Maybe b)) ?
01:02:50 <ertes-w> halogenandtoast: hangman games would be of type (GuessGame [] Char Char)
01:03:00 <xzhu> how do you even *begin* to translate that into a more declarative paradigm?
01:03:03 <ertes-w> halogenandtoast: so: f (Maybe b) = [Maybe Char]
01:03:08 <ertes-w> halogenandtoast: this is a partial string
01:03:13 <ertes-w> a string with holes
01:03:14 <mud> sssilver: Thankfully I have no problem using ST and mutable arrays in haskell :) So it's not that uncomfortable.
01:03:28 <sssilver> xzhu I mean, this is a bit unfair -- you're giving us an algorithm that's inherently imperative
01:03:37 <ertes-w> halogenandtoast: or if you imagine a board with a bunch of letters and underscores, Justs are the known letters, and Nothing is an underscore =)
01:03:51 <halogenandtoast> ertes-w: okay that makes sense
01:04:12 <halogenandtoast> but how would you store the both the final word and missed guesses?
01:04:24 <halogenandtoast> That type doesn't seem to be able to hold all that information.
01:04:24 <ertes-w> > map (maybe '_' id) [Just 'H', Nothing, Just 'l', Just 'l', Nothing]
01:04:27 <lambdabot>  "H_ll_"
01:04:48 <mud> sssilver: But it's a nice algorithm (in certain contexts). What's the alternative we'd use in declarative settings? They exist, but they're not perfect replacements. A lot of the nice part of FW is how short and easy to express it is.
01:04:53 <ertes-w> halogenandtoast: it is able to hold all that
01:05:23 <xzhu> sssilver: but I guess my point is sometimes performance matters and you need an algorithm that has certain temporal complexity gaurantees ...
01:05:28 <ertes-w> halogenandtoast: GuessGame is intrinsic, it does not encode the internal state of the game
01:05:49 <ski> halogenandtoast : i think `g' should probably not be ignored
01:06:13 <sssilver> that's a fair point, nobody argues that Haskell/FP programming is always the most performant way of accomplishing things on a traditional computer
01:06:15 <[exa]> xzhu: there was implementation of floyd-warshall with zipper somewhere, it actually made sense
01:06:24 <ertes-w> halogenandtoast: can you write a single-letter hangman game?  just a single underscore on the board, and once that one is guessed, the game is won
01:06:41 <sssilver> however you can still "pull that implementation off", and yes it may look hairy but it'll be correct
01:06:45 <ertes-w> halogenandtoast: (you can almost copy simpleGuess for that)
01:06:47 <mud> sssilver: You can do bellman ford, but that has the same-ish problems, it's pretty imperative. You can do dijkstra's a few times, but that's annoying too (and I think slower)
01:06:52 <ertes-w> halogenandtoast: or even generalise it
01:06:57 <mud> sssilver: Or you can just realize that ST exists and it exists for a reason, heh.
01:07:18 <ertes-w> halogenandtoast: singleton :: (Eq a, Applicative f) => GuessGame f a a
01:07:23 <ertes-w> err
01:07:27 <ertes-w> halogenandtoast: singleton :: (Eq a, Applicative f) => a -> GuessGame f a a
01:07:40 <sssilver> practically speaking (and performance is always a practical matter), you can always code this in Rust and invoke it from Haskell :))
01:07:54 <ertes-w> halogenandtoast: this function can construct simple number guessing games as well as single-letter hangman games
01:08:24 <mud> Or you can just code it in ST. Haskell is a nice imperative language, there's no reason to be scared of that.
01:08:35 <xzhu> sssilver: I like that in that sentence you used Rust instead of C++ :D
01:09:08 <sssilver> xzhu I like to please the language hipster in me :P
01:09:17 <halogenandtoast> ertes-w: is the body exactly the same as simpleGuess then
01:09:29 <sssilver> also, "Rust" is just "Perl" with 4 typos :P
01:09:37 <halogenandtoast> oh without Identity
01:09:42 <ertes-w> halogenandtoast: not quite, but Identity is an Applicative, and there is a way to generalise the Identity constructor
01:09:43 <mud> sssilver: Hah
01:09:53 * ski idly wonders how easy it is to invoke Rust HOFs from Haskell
01:09:58 <halogenandtoast> ertes-w: I assume you mean pure
01:10:07 <ertes-w> halogenandtoast: exactly
01:10:09 <halogenandtoast> singleton a = Guess (pure Nothing) (\x' -> if x == x' then Just (Won (pure x)) else Nothing)
01:10:23 <ertes-w> halogenandtoast: correct =)
01:10:24 <halogenandtoast> except with a instead of x
01:10:42 <ertes-w> oh, yeah…  except for the typo =)
01:10:53 <ertes-w> halogenandtoast: now comes the part that is almost magic
01:10:56 <sssilver> "I don't always code in Rust, but when I do, it's always for invoking imperative algorithm implementations from Haskell"
01:11:15 <ertes-w> halogenandtoast: instance (Alternative f) => Monoid (GuessGame f a b)
01:11:27 <ertes-w> you can concatenate guess games =)
01:11:40 <ski> @quote when.I.do
01:11:40 <lambdabot> edwardk says: normally i don't bother with little things like "documentation", "benchmarks" and "tests", but I recently discovered that when I do, I get these curious things called "users".
01:11:54 <ertes-w> halogenandtoast: this instance is a bit difficult to write…  you may have to think for a while, if this is your first time
01:11:59 <mud> That's a nice quote xD
01:12:20 <ertes-w> halogenandtoast: but once you have it, you can construct arbitrary hangman games by using (foldMap singleton)
01:13:02 <ertes-w> you could even write:  instance (Alternative f) => IsString (GuessGame f a Char)
01:13:39 <ertes-w> then with OverloadedStrings "Hello World" would be a full hangman game =)
01:16:31 <halogenandtoast> ertes-w: what's the intent of returning Nothing on an incorrect guess, for a game like hangman would I not return Nothing, but instead return a new "unwon" guess?
01:17:21 <sssilver> probably better design, that
01:17:21 <ski> just keep the old state ?
01:17:41 <ertes-w> halogenandtoast: the rationale is that later you may write a new type Limited with an additional Lost constructor that encodes the additional semantics of only allowing a limited number of bad guesses
01:18:04 <ertes-w> halogenandtoast: that too will be a Monoid, and there is a monoid morphism from GuessGame to Limited
01:18:42 <ertes-w> Limited needs to know when a guess was bad
01:19:33 <halogenandtoast> ertes-w: this is as far as I got, but I think I am way off
01:19:34 <halogenandtoast> simpleHangman string = Guess (replicate (length string) Nothing) $ fix (\f s -> if s `elem` string then Just (Won string) else Just (Guess [Just s] f))
01:20:04 <halogenandtoast> basically my else branch doesn't seem to make sense as it only stores the last s
01:20:13 <ertes-w> halogenandtoast: that's not quite hangman
01:20:23 * ski . o O ( `map (const Nothing) string' )
01:20:26 <ertes-w> one correct guess and the game is won =)
01:20:37 <halogenandtoast> oh very true
01:20:46 <ertes-w> halogenandtoast: you don't need to write a full hangman game either
01:20:56 <ertes-w> halogenandtoast: (it's difficult to write, too)
01:21:09 <ertes-w> halogenandtoast: i would go with 'singleton' + 'mappend'
01:21:32 <ertes-w> singleton 'h' <> singleton 'e' <> singleton 'l' <> singleton 'l' <> singleton 'o'
01:21:39 <ertes-w> or shorter:  foldMap singleton "hello"
01:22:17 <halogenandtoast> I'd have to write the monoid instance for that though
01:22:56 <ertes-w> yes…  it will include the same logic you need for simpleHangman (which makes it far from simple), but doesn't have to deal with local state at the same time
01:23:09 <ertes-w> so mappend is still difficult to write, but much easier than simpleHangman
01:24:34 <halogenandtoast> I'm definitely out of my element now.
01:24:45 <ertes-w> halogenandtoast: you may need a mental picture
01:25:06 <ertes-w> halogenandtoast: imagine that a hangman game is not actually written out on a single board with a single game master filling in the letters
01:25:34 <ertes-w> but you have five boards, each only holding a single underscore, and you have five separate game masters, each listening to you in parallel
01:25:55 <ertes-w> when you make a guess, all of them will react to your guess in parallel
01:26:12 <ertes-w> mappend just glues those boards together
01:26:28 <halogenandtoast> Right, but I have to glue them inside of GuessGame
01:26:38 <halogenandtoast> so I need to know how to store games inside of games.
01:26:50 <ertes-w> and acts as a gamemaster that talks on your behalf to the individual gamemasters
01:27:17 <ertes-w> halogenandtoast: start with this:  mappend (Won xs) (Won ys) = …
01:27:30 <ertes-w> if you append two Won games, what's the result?
01:27:50 <halogenandtoast> Won xs ++ ys ?
01:27:54 <xzhu> A related question: If I were to develop a GUI program like MSPaint, which packages do you recommend me to look into?
01:27:55 <ertes-w> that's a type error
01:28:09 <halogenandtoast> Won (xs, ys) ?
01:28:13 <ertes-w> type error
01:28:42 <halogenandtoast> Won (xs <> ys)
01:28:48 <ertes-w> instance error
01:29:00 <halogenandtoast> Won xs
01:29:06 <ertes-w> wrong semantics
01:29:38 <halogenandtoast> do we even know anything about xs or ys?
01:29:39 <ertes-w> (xs, ys :: f b), and you know that (Alternative f)
01:30:04 <halogenandtoast> I don't actually know anything about Alternative
01:30:10 <halogenandtoast> does it define <|> 
01:30:11 <halogenandtoast> ?
01:30:13 <ertes-w> @src Alternative
01:30:13 <lambdabot> class Applicative f => Alternative f where
01:30:13 <lambdabot>     empty :: f a
01:30:14 <lambdabot>     (<|>) :: f a -> f a -> f a
01:31:10 <halogenandtoast> so Won (xs <|> ys)
01:31:19 <ertes-w> correct
01:31:39 <ertes-w> halogenandtoast: you can imagine that 'f' is just [], but instead of (++) you need to write (<|>)
01:32:08 <halogenandtoast> okay, so that's the easy case...
01:32:47 <halogenandtoast> the other cases are (won, guess), (guess, won), and (guess, guess)
01:32:53 <ertes-w> halogenandtoast: now try (mappend (Won xs) (Guess mys g))…  just try it on your own
01:33:12 <ertes-w> and highlight me when you're done/stuck
01:33:56 <ertes-w> halogenandtoast: just one hint: Alternative implies Functor – you'll need it =)
01:35:35 <halogenandtoast> ok I'll try it out. I expect to get stuck :p
01:43:22 <halogenandtoast> ertes-w:   mappend (Won xs) (Guess mys g) = Guess ((pure <$> xs) <|> mys) g
01:44:01 <ertes-w> halogenandtoast: not quite
01:44:13 <halogenandtoast> :(
01:44:14 <ertes-w> halogenandtoast: you're losing the composition after the first guess
01:45:03 <halogenandtoast> What do you mean by losing the composition?
01:45:44 <halogenandtoast> Basically we no longer have two or more games chained?
01:46:14 <ertes-w> halogenandtoast: if the game is (Won "He" <> foldMap singleton "llo"), and the player guesses 'l', then the new game will degenerate to (Won "ll" <> singleton 'o')
01:46:50 <ertes-w> (actually it will be worse (degenerating to a single character), but that's the gist of the problem)
01:46:57 <ertes-w> halogenandtoast: you need to use 'mappend' recursively
01:47:17 <ertes-w> i.e. you need to modify the result of 'g'
01:47:39 <ertes-w> because the new game returned by 'g' still needs to be composed with (Won xs)
01:48:09 <halogenandtoast> huh
01:49:02 <ertes-w> halogenandtoast: remember that 'g' has no idea that it is composed with anything, so it will only take care of the "llo" part…  it does not know anything about the preceding "He"
01:50:02 * hackagebot generic-random 1.0.0.0 – Generic random generators – https://hackage.haskell.org/package/generic-random
01:52:05 <halogenandtoast> ertes-w:   mappend (Won xs) (Guess mys g) = Guess ((pure <$> xs) <|> mys) ((mappend (Won xs) <$>) . g)
01:52:08 <halogenandtoast> ?
02:00:35 <halogenandtoast> and perhaps the other order is
02:00:35 <halogenandtoast>   mappend (Guess mys g) (Won xs) = Guess (mys <|> (pure <$> xs)) (\x -> mappend <$> (g x) <*> pure (Won xs))
02:01:53 <halogenandtoast> and the last one
02:01:53 <halogenandtoast>   mappend (Guess mxs g) (Guess mys h) = Guess (mxs <|> mys) (\x -> mappend (g x) (h x))
02:04:41 <ski> > getSum (mappend (Sum 2 *) (Sum 3 *) (Sum x))
02:04:44 <lambdabot>  2 * x + 3 * x
02:12:19 <halogenandtoast> Does that imply that I'm wrong?
02:13:10 <ertes-w> halogenandtoast: your (won, guess) case is correct
02:13:31 <ertes-w> halogenandtoast: your (guess, won) case is correct (but needlessly complicated)
02:14:02 <[exa]> just spent 10 minutes searching python for mapM_ equivalent
02:14:05 <[exa]> :(
02:14:06 <ertes-w> > mempty :: Just ()
02:14:09 <lambdabot>  error:
02:14:09 <lambdabot>      • Expected a type, but ‘'Just ()’ has kind ‘Maybe *’
02:14:09 <lambdabot>      • In an expression type signature: Just ()
02:14:16 <ertes-w> > mempty :: Maybe ()
02:14:19 <lambdabot>  Nothing
02:14:24 * ski was just suggesting a possible abbreviation
02:14:30 <ertes-w> halogenandtoast: your (guess, guess) case is correct
02:14:45 <ertes-w> halogenandtoast: but also needlessly complicated
02:15:05 <ertes-w> mappend (Guess mxs f) (Guess mys g) = Guess (mxs <|> mys) (f <> g)
02:15:17 * ski nods
02:15:32 <halogenandtoast> ah
02:15:52 <ertes-w> halogenandtoast: good job!  now what is the empty game?
02:15:57 <ertes-w> a.k.a. mempty
02:16:54 <ertes-w> [exa]: i've been searching for that, too, and ended up writing it myself
02:16:55 <halogenandtoast> ertes-w: well... since I needed to fill it in, I came up with a wrong answer
02:16:58 <halogenandtoast>   mempty = Guess empty (pure . const mempty)
02:17:06 <ertes-w> halogenandtoast: that's indeed wrong
02:17:22 <ertes-w> halogenandtoast: if there is nothing to guess, then …?
02:17:30 <dramforever> Your coworkers will be extremely happy if you call it mapM
02:17:39 <halogenandtoast> ertes-w: Oh it should be Won
02:17:44 <ertes-w> halogenandtoast: correct
02:17:56 <halogenandtoast> so
02:17:56 <halogenandtoast>   mempty = Won empty
02:18:00 <ertes-w> yep
02:18:38 <ertes-w> halogenandtoast: now all you need is an interpreter:  hangmanStdio :: GuessGame [] Char Char -> IO ()
02:18:52 <halogenandtoast> Yeah I wrote something but it doesn't work
02:18:56 <halogenandtoast> I win on the first guess
02:19:34 <ertes-w> halogenandtoast: try this:  hangmanStdio (foldMap singleton "hello")
02:19:35 <halogenandtoast> http://lpaste.net/357906
02:20:27 <ertes-w> halogenandtoast: that's incorrect…  what happens when you give it an empty game?
02:21:06 <ertes-w> halogenandtoast: there is no need to handle winning within the Guess case
02:22:01 * ski . o O ( mealy vs. moore )
02:23:01 <halogenandtoast> updated
02:23:08 <halogenandtoast> still win on the first guess though
02:23:32 <halogenandtoast> doing some cleanup
02:25:16 <ertes-w> halogenandtoast: why do you think the Nothing case can't happen?
02:25:40 <halogenandtoast> I realize now that it can
02:25:57 <halogenandtoast> I was thinking a guess is either correct or incorrect and you get a GuessGame back
02:26:22 <halogenandtoast> but that's because I didn't read my singleton instance
02:26:40 <halogenandtoast> so far it hasn't happened though
02:26:42 <halogenandtoast> ;-)
02:27:18 <halogenandtoast> But I assume I should just do        Nothing -> simpleGuessStdio game
02:27:34 <ertes-w> other than that it looks correct to me…  you may want to add this:  putStrLn ("Guess: " ++ map (maybe '_' id) acc)
02:27:42 <ertes-w> yeah, you can do that
02:28:18 <halogenandtoast> yeah one guess and the game terminates
02:28:22 <ski> @type fromMaybe
02:28:23 <lambdabot> a -> Maybe a -> a
02:28:40 <halogenandtoast> one correct guess
02:28:48 <ertes-w> halogenandtoast: i just realised that the (guess, guess) case is wrong
02:29:02 <ertes-w> problem is this:
02:29:41 <ertes-w> problem is that if the left component returns Nothing, there is no composition
02:30:02 <ertes-w> i.e. the left part is forgotten
02:30:39 <halogenandtoast> I assume that's the left or right component.
02:30:44 <ertes-w> so if 'g' returns Nothing, you need to compose with the original left game
02:33:04 <jonge> hey there, i am currently writing code in a ResIO environment and i need to run `forM (list :: [a]) (function :: \a -> ResIO b)` in it. but of course `forM` only knows `IO` and nor `ResIO`. What's the best way here? 
02:33:53 <lyxia> forM definitely knows more than IO...
02:33:58 <lyxia> :t forM
02:33:59 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
02:34:12 <halogenandtoast> ertes-w: so... this was my attempt but it doesn't typecheck (fromMaybe (Just g1) . g) <> (fromMaybe (Just g2) . h)
02:35:29 <jonge> lyxia: ok true. one moment, i need to recheck if i did not do a completely different mistake lol
02:35:51 <jonge> lyxia: ok this was stupid, something completely different. sorry for wasting your time
02:36:32 <lyxia> jonge: don't worry.
02:36:54 <ertes-w> halogenandtoast: it still needs to be Maybe, so you can't use fromMaybe
02:36:59 <lyxia> jonge: also "for" is better looking, does the same thing, and more.
02:37:03 <ertes-w> halogenandtoast: you need to use (<|>) for Maybe
02:37:26 <ertes-w> halogenandtoast: no, you can't do that either, because if *both* g and h return Nothing, you have to return Nothing
02:37:41 <ertes-w> halogenandtoast: honestly i would just pattern-match
02:38:59 <jonge> lyxia: ok i do not understand that. control.monad only contains "forM". i can find a "for" in data.traversable, but it depends on applicative. as what i do in the forM function has definitive IO-sideffects, i don't see how it could be used with applicative "for"?
02:39:59 * hackagebot schematic 0.1.5.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
02:40:00 <ertes-w> jonge: import Data.Traversable instead
02:40:45 <halogenandtoast> ertes-w: back to where I started
02:41:10 <halogenandtoast> updated: http://lpaste.net/edit/357906
02:41:18 <halogenandtoast> tried to pattern match but I get the same failure
02:41:21 <ski> jonge : there is an `Applicative' instance for `IO' (and presumably also for `ResIO', since you seemed to use a `Monad' instance for it)
02:41:33 <halogenandtoast> in that one correct guess terminates the program
02:41:36 <jonge> ertes-w: oh yes. it works. i just had a brainfart when i thought "but you can;t run IO actions inside applicative stuff" - although it's the other way around that would not work, right?
02:41:40 <ertes-w> halogenandtoast: you forgot *why* you're pattern-matching ;)
02:41:44 <halogenandtoast> oh
02:41:50 <halogenandtoast> I still am dropping the original
02:42:21 <halogenandtoast> okay
02:42:24 <halogenandtoast> It works now
02:42:29 <ertes-w> jonge: that…  doesn't really make sense
02:42:50 <jonge> ertes-w: ok maybe i will continue studying offline. i am not completely awake yet or so lol
02:42:55 <ertes-w> jonge: you may be confusing types with type classes here, but i'm not entirely sure
02:43:03 <jonge> ertes-w: that is possible
02:43:08 <halogenandtoast> I'd love to figure out how to keep track of how many times the player has guessed, but I'll need to implement that either later or tomorrow
02:43:14 <halogenandtoast> any hints on how to get started on that ertes-w 
02:43:16 <halogenandtoast> ?
02:43:35 <ertes-w> halogenandtoast: my approach would be a separate type that encapsulates GuessGame
02:43:41 <halogenandtoast> Noooo
02:43:45 <halogenandtoast> Alright
02:44:11 <ertes-w> halogenandtoast: data Counted f a b = Counted Natural (GuessGame f a b)
02:44:18 <halogenandtoast> Stages of haskell programming: Denial -> Acceptance
02:44:59 <ertes-w> halogenandtoast: you can make this a Monoid, but the semantics would be a bit weird
02:45:11 <ertes-w> you would have to choose between (+) and 'max' for the count
02:45:12 <halogenandtoast> ertes-w: thanks so much for the hand holding and the fun lesson
02:45:21 <ertes-w> and neither really makes sense
02:45:30 <ertes-w> halogenandtoast: my pleasure =)
02:45:41 <halogenandtoast> I'm still not entirely sure how it works, but I'm going to spend some time studying it
02:46:10 <ertes-w> halogenandtoast: however, instead of a count you may want to make a wrapper that encodes *limited* guesses…  that one has a useful Monoid instance
02:46:13 <halogenandtoast> It's right outside my comfort zone which is the perfect place for it to be.
02:46:35 <ertes-w> halogenandtoast: data Limited f a b = Limited (GuessGame f a b) | Lost
02:46:36 <halogenandtoast> Yeah I'd want limited guess
02:46:56 <ertes-w> this one should use the 'min' monoid
02:46:59 * ski . o O ( Haskell -- where you write working code first, and understand it later )
02:47:23 <halogenandtoast> ski: I blame the type system.
02:47:40 <ertes-w> hehe
02:48:18 <ertes-w> halogenandtoast: also just for fun you may want to try to encode the full hangman game in a single smart constructor, i.e. without using 'singleton' or Monoid
02:48:31 <ertes-w> halogenandtoast: just to see how difficult it would be without that compositional approach
02:49:03 <halogenandtoast> ertes-w: I was happy with https://github.com/halogenandtoast/hangman-haskell/blob/master/src/Hangman/Game.hs
02:49:25 <halogenandtoast> ;-)
02:50:25 <ertes-w> halogenandtoast: and now you're no longer happy with it =)
02:50:29 <halogenandtoast> ha ha we'll see
02:51:09 <halogenandtoast> Alright time to head home. Thanks again, you too ski 
02:51:17 <ertes-w> it doesn't generalise, it doesn't compose, and your interpreter now needs to deal with internals of the game, i.e. the actual state variables
02:51:40 <ertes-w> in fact just displaying the current challenge is awkwad with that approach
02:51:51 <ertes-w> *awkward
02:51:58 <ski> np
03:06:34 <zekt> Hi, guys, I am implementing my small language in Haskell as practice right now, I've encountered a problem when defining values, values of different types in the small language are represented with different constructors of the "Val" data type in Haskell, I am stuck with how do I define a list?
03:08:18 <Athas> zekt: a list would be a list of Vals, right?
03:08:28 <Athas> Maybe something like: data Val = ... | List [Val]
03:09:11 <erisco> does your language have recursion?
03:09:34 <zekt> Athas: Yes! but the problem is I want a list to be typed, like I can say it's a list of Int
03:09:58 <Athas> zekt: then you have an (interesting!) problem that can be solved with GADTs.
03:10:18 <erisco> zekt, you can just implement lists as functions
03:10:34 <lyxia> data Val a where ... | List :: [Val a] -> Val [a]  ?
03:10:55 <zekt> It looks like this right 
03:10:56 <zekt> `data Val = N Int
03:10:56 <zekt>          | B Bool
03:10:56 <zekt>          | P (Val, Val)
03:10:56 <zekt>          | L ([] Val) Type
03:10:56 <zekt>          | F (Val -> Val)
03:10:56 <zekt> `
03:11:06 <Athas> lyxia: has the right solution.
03:11:22 <Athas> But you might not want to pay the complexity cost for this degree of safety.
03:11:28 <erisco> zekt, how do you construct functions in your language?
03:11:46 <erisco> oh, derp, I am about 30 seconds slow right now :P
03:14:07 <zekt> erisco: thanks for the idea, but I have no idea how could that solve this problem right now,  trying with my slow working brain :p 
03:14:48 <Athas> zekt: why do you need the list to be typed?  You're writing an interpreter for your language, right?
03:15:26 <Athas> Haskell is not really a dependently typed language, so trying to write typed ASTs often becomes pretty complicated.
03:15:55 <lyxia> it's so much fun
03:16:27 <zekt> Athas: yes, but I just want to make sure when I do type inference I can see it's constructed with a single type, a "List" type seems too loose to me
03:16:40 <zekt> like most of the static language I guess?
03:16:46 <erisco> zekt, nil = F (\_ -> F id)  cons = F (\x -> F (\xs -> F (\f -> F (\z -> f x (xs f z)))))
03:16:51 <c_wraith> You don't need dependent types to do typed ASTs.  You just need them to do anything interesting with them.
03:17:17 <erisco> uh, you'll need L's in there
03:17:48 <erisco> oh, L is not application, dunno what that is
03:17:54 <erisco> you need application in your language
03:19:29 <Athas> c_wraith: right, I'm just still scarred by the time my own youthful optimism lead me to implement 'eval :: Exp a -> a' in Haskell. :-)
03:19:54 <c_wraith> Athas: if your AST only has two types, it's not so bad. :)
03:20:01 <Athas> c_wraith: or if it does not have variables.
03:20:04 <erisco> say your application is called A, then  f `A` x `A` (xs `A` f `A` z)
03:20:09 <c_wraith> that helps too
03:23:27 <erisco> why is writing typed ASTs complicated?
03:24:22 <c_wraith> erisco: here's an example without variables.  Try to extend it to also have variables.  http://lpaste.net/355742
03:25:25 <erisco> how do you want variables to work in this language?
03:26:35 <erisco> are we adding lambdas or just constructing propositions with quantifiers
03:26:47 <c_wraith> There's a pretty standard way - add a constructor for referring to a variable, and a constructor for binding an expression to a variable in an expression.  The details don't matter much.  Just make sure the variables can be multiple types.
03:27:47 * hackagebot listenbrainz-client 1.0.1 – A client library to the ListenBrainz project – https://hackage.haskell.org/package/listenbrainz-client
03:28:22 <c_wraith> As soon as your environment needs to track the types of variables, the pain starts to show up.
03:33:48 <zekt> lyxia: I think about your solution and find it very cool! what I'm doing right now:
03:33:48 <zekt> data Val a where N :: Int -> Val Int; B :: Bool -> Val Bool; L :: [Val a] -> Val [a]
03:33:49 <zekt> Maybe I should change Int and Bool to some self defined type to represent Int and Bool in my small language, but now it's seems pretty awesome to me
05:37:13 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
05:37:13 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
05:37:13 --- names: list (clog slacko_ tomphp Psybur|Work arthurwong exarkun mrkgnao Cogitabundus b005 eacameron gienah fizruk zph dgonyeo yaknyasn ajmccluskey rjungemann mbeidler arianvp2 mstruebing TyOverby__ ilyaigpetrov dddddd harfangk shayan_ Guest63210 sdothum ocharles Tritlo runeks houli Guest98673 NemesisD si14 niveus mkurkov_ feltnerm mystfox wizonesolutions grandy____ tazjin cdsmith TRManderson gornikm danthemyth Vietzer kvda mson emilypi eklavya ziyourenxiang dcoutts woffs)
05:37:13 --- names: list (Wizek jatcwang araujo acarrico MichaelBurge jeltsch mulk_ ixti pavonia jay__ tobhe ForgedPancake zariuq takle g2 xormor_ CurryWurst_ erisco quobo simukis_ theelous3 nathanic govg a3Dman oish zoey samrat beanbagula Sampuka e je5finger jwbuurlage cloudhead merijn acidjnk zero_byte Iceland_jack Yuras bsmt hsiktas gxt phadej sepp2k iw00t uelen aloiscochard a3f sektor biglama toby1851 mattyw Sose marvin2 ziocroc wespiser thc202 wonko7 danvet mekeor freusque)
05:37:13 --- names: list (Tesseraction Bashmetim connrs ertes-w albertid robotroll leat xzhu Associat0r feinerer raichoo btk mschristiansen saurabhn_ tsia coot____________ fuziontech meinside ryanbooker jonrh JoJoen paroxp osa1 hiredman shafox yoneda ubsan_ BernhardPosselt lambdaGrp SiCC [swift] RazorX guiben armyriad revprez dan64 aijony bazukas reinh1 discrttm Warrigal loupgaroublond ramatevish ynyounuo JoelMcCracken infinity0 Adeon unK_ Durbley_ Lynxium[] howdoi vlatkoB gleber_)
05:37:13 --- names: list (thimoteus ski xormor l_zzie jxv bytesighs Cir0X customminer rizary milessabin AlainODea adelbertc monad_cat ericbmerritt_ prizim metalrain twold darthThorik acfoltzer joedevivo shans_ micmus strmpnk jameseb Kamuela Scorchin_ baamonde tarcwynne__ Heero__ hansihe nbouscal prefork Tallenz fingerzam stephe yminsky poga sdemos nelll raibutera killtheliterate kgadek ongy ventonegro Taneb tekacs riatre lynn etrepum mikeplus32 stass squisher tortal frew xacktm no-n)
05:37:13 --- names: list (marcel Meow-J noobst twomix rom1504 mt Neo kipd pchiusano reem johtso reynir noxd paf31 incomprehensibly oberstein cschneid cmdv ephemeron gsingh93 afcondon_ jmct capicue akl avdi trig-ger cstrahan wenzowski gridaphobe Quintasan Jaxan x1n4u minad bananagram drdo cjwelborn mindtree sveit uwap mbrcknl_ isaac__ Bigcheese m00n zebrah xnyhps beaky gothos mniip billstclair Argorok flux PotatoGim ryanpcmcquen wyvern SuprDewd grayhatter staffehn iravid bwe dunecat)
05:37:13 --- names: list (Vbitz GreySunshine Klumben codedmart CARAM___ Bengi alem0lars Lord_of_Life nano- TabAtkins elvishjerricco dysfigured rotty nick1234 Zoddo intelux sdhand runde chriswk spicydonuts cdornan_ dsm__ stasku georgew angerman andrew_n_ tharper_ rgrinberg bbielsa_ dfranke dsal ij jinblack vimto Deadhand ab9rf akermu carc QuantumLogic chindy SaidinWoT nkpart mbrock kyagrd ReinH cansis Guest4509 zpconn__________ ebutleriv thi_ dstockwell jorendorff zgrepc saylu feepo)
05:37:13 --- names: list (carter pringlescan abbe bjs SLi pierrot Niamkik solarus bbaren bigs zmanian_____ caw_ lumimies _flow_ cocreature stig redcedar spinda solidsnack solatis sbrg stefan-__ cpape miklcct sivs Xorlev mikedlr dgpratt kloeri @ChanServ exferenceBot tomaw SolarAquarion karce Randy rann averell oldsnakey chelfi1 nisstyre sqrt2 pikajude iphy jzelinskie Saimeidae idupree noexcept chrzyki madknight Sigyn Majiir orcus dpepsilon jgornick_ armlesshobo mimi_vx SolitaryCypher)
05:37:13 --- names: list (bartavelle hexagoxel pacak ocramius_ tgeeky huonw oherrala zyla davean joehillen so \u PHO reptar_ twk- chaosdav vili ringer1 djanatyn ManiacTwister amx slabity exio4 kotangent mulk bvad hiptobecubic Forkk croben Hijiri wz1000 cheshircat MitchellSalad mnoonan Dykam jimmyrcom mak` sdlnv julmac mgaare Raptor8m3 nilOps mantovani ehubinette Guest63576 kfish shapr nikolah yahb bogdanteleaga jonge druidofluhn tromp yaiyan jared-w brolin_empey d3lxa kipras mero)
05:37:13 --- names: list (tdammers Immune betawaffle coeus ninja_in1 odamn myme __name__ ephemera_ obiwahn knmae suzu sleepynate eddsteel Amadiro ahf cic asm89 Ring0` lassulus BytesAndCoffee monochrom blackdog dyreshark verto Jello_Raptor hydraz edran przembot dschoepe cmr logcat ycheng Vq danboard mgttlinger jw358 zachary12 truncate thoros monty inr qz_ jorj JDevlieghere baetheus buoto1 CosmicRay Intensity RevJohnnyHealey centril mw salva MasseR linduxed LiaoTao niklasl Guest21541)
05:37:13 --- names: list (eL_Bart0 zymurgy rembo10 Guest95161 luigy jasonrobot64 aminb hrnz bbee cesardv srk user1 Purlox Guest37162 Frans-Willem Moyst vimalloc rootzlevel MalfaitRobin_ Xnuk jamiis Burnout641 luis tych0 kiboneu esph malt3 janne navilan emerson trevorriles_ comboy Xandaros tpreston cbaines DDR Fuuzetsu unsymbol relrod jluttine japesinator meck pita nekomune_ Belgarion0 marble_visions Squarism amuck Cthalupa bsima Xal Biohazard Guest60956 yarou ircbrowse gnusosa Oipo)
05:37:13 --- names: list (srhb flebron treehaqr greymalkin gabiruh epta absence bob_twinkles duncan^ Nik05 spion ralu Meanirelli nille chirpsal1 mattp__ quakestor joeytwiddle _cyril_ benzrf fairfieldt amerlyq ijp pasukon Sornaensis mrus tolt HalfEatenPie henrytill garphy`aw emmflo carbolymer bollu burp zekt slester hjklhjklhjkl datajerk Flonk TallerGhostWalt sigmundv Cathy tolt_ SCHAPiE icedev ctag earldouglas c_wraith statusbot iross happy0 wagle Benzi-Junior Tuplanolla dminuoso)
05:37:13 --- names: list (banjiewen swhalen knapptime SAL9000 pharaun Deewiant fxrs brixen jle` ezyang adamCS tibbe crosleyt niluje Guest49825 mk-fg sns Atlantic777 ljhms xxpor michalrus peddie trosa jrm ftop aib guios Cale stux|RC-only mryandao Brando753-o_O_o mitchty Raynes Fylwind tsani nurupo brent80_plow joeyh nullx002 kg xa0 akemot caasih ons marens lpsmith alpounet pinkmuffinere Desoxy runawayfive valkyr2e brisbin mrmenagerie fiddlerwoaroof cjh` c-rog kriztw lachenmayer)
05:37:13 --- names: list (fergusnoble skeuchel alek cyberlard baroncha1lus jchia Guest95115 Hafydd anderson bshelden platz ClaudiusMaximus clever Nikotiini wamaral numberten mauke cfoch-al1 thallada teto2 EvanR davl Levex tfc[m] M-berdario M-BostonEnginerd jmnoz bennofs[m] pellegrino spacekitteh[m] turt2live bb010g fabioberton[m] davidar_ monomon[m] unlmtd NickHu aspiwack[m] hendrik[m]1 sirius[m] aer[m] cutie scde angelbeats[m] tester668[m] davidar herzmeister[m] Magnap1 M-kevinliao)
05:37:13 --- names: list (TylerCecil[m] zaphar_ps[m] miviotros[m] hpd_m drasich[m] goodboy[m] Soif[m] MohdSKhoeini[m] lysgaard[m] Nuva[m] sn[m] idnar[m] thejonny[m] redviking[m] octalsrc[m] Alexander_Hansen sudoreboot[m] riadvargas[m] TFX[m] trikl[m] etcinit[m] ttt72[m] M-Illandan puffnfresh m3tti[m] equalunique[m] Mike[m] M-ms M-schmittlauch ycy[m] phil_frontal[m] mith[m] asm[m]1 ttk2[m] fib11235[m] rcat[m] levzhazeschi[m] AX3L[m] talesmantovani[m el_tejon[m] hiq[m] ninegua[m] abbiya)
05:37:13 --- names: list (Barnabas[m] laaksoan[m] M-herah Nerka[m] Akito[m] ThousandLions[m] zukonake[m] intheclouddan[m] mrhania[m] sebisebi[m] lucnx[m] Naughtmare[m] M-whoops rizo[m] moka[m] Obscurity[m] masaeedu[m] M-kitsune innaytool[m] thisLight[m] testtt55[m] Courage[m] thekyriarchy__ magnap Matthew[m] cuddly[m] Luguber[m] Maikel_Experius[ lonokhov[m] Monad[m] scanleft[m] saci[m] softashell BL[m] jacobleach[m] okkk riaqn polux[m] wisn[m] djquant[m] JohnnyReb[m] Verandetten[m])
05:37:13 --- names: list (jsgrant[m] JHBrannam[m] joncfoo[m] Levanx caro401 Drakonis[m] XertroV[m] km42[m] astronavt[m] Squidnyan[m] MarkusK[m] TimWolla[m] fgaz[m] antiless[m] rydia5[m] ya-alex[m] lixiang4u[m] am2on KevinMGranger Scubajump[m] M-HirmeS emme[m] nimbus[m] adziahel[m] ramirezD[m] dbramucci[m] howsiwei[m] boash[m] jvalleroy[m] psan[m] guest121[m] shekel[m] joakimf95[m] KENNYNR1[m] grahf[m] magog[m] ElliotKiyomizu[m kebertx[m] akshay7777[m] Guest312594[m] subz[m])
05:37:13 --- names: list (rprospero[m] M0xfiras[m] Rubas[m] Vipernet1220[m] eyenx Jasonjunsu[m] pikhq CGML2 akkad bjobjo tokik atomi pyrtsa raek soncodi sdx23 CindyLinz Liskni_si petercommand int-e zomg nullifidian hvr [exa] dh barrucadu speak dysfun opqdonut ec2-user_ mitch_ bus000 Elsi jdt baweaver suppi SlashLife cjay- swalladge earthy Bimmie[m] Guest98136 eagleflo Saizan nshepperd_ pmn phaazon liste bxc noctux Morgawr bengt_ SansFr[m] AWizzArd lopex bcoppens RGamma hackagebot)
05:37:13 --- names: list (DigitalKiwi Blkt JSharp rdococ nemesit|znc dpn` arkeet SegFaultAX froztbyte tessier gesindel Aidan[m] ArrayWindrunner[ kilian[m] dlandau[m] synopz[m] undu[m] jnonpony[m] sssi1ver[m] ollieh magicmushroom[m] WolfLightning[m] jyp[m] s0ra[m] moonrunes[m] pyrtheibarit[m] drcode WhereIsMySpoon_ psychicist__ hsyl20 hpc Clint vfs ziman zagura cchalmers orion Ninja3047 gareth__ anzuof wtw frontendloader pfoetchen andyo lokydor stelleg jix bitemyapp cynick sm Ranhir)
05:37:13 --- names: list (tek0 bgamari harmaahylje jlewis matthavener Deaddy oleks jrslepak nwf kmhn wrengr_away admwrd megaTherion ps-auxw wedify echoreply supki stoopkid_ nahra jfredett juri_ mendez aidecoe newsham robogoat tumdedum lstrano Bane^ divVerent lispy Drezil Solarion spoonm seliopou M2tias jzl Boreeas heinrich5991 hanna libbyk Jonno_FTW remexre Contessa padre_angolano sanitypassing rjeli aatxe mdarse Logio leah2 Fubar^ kek918 gargawel tv klugez magicman h30 Rembane Athas)
05:37:13 --- names: list (niko Zemyla avn toppler apeyroux esssing dave24 lavalike ncl28 aglorei1 NinjaTrappeur Adau[m] abra0 Unode dogui caro TseiTsei setre koz_ Ankhers sujeet pavlicek Tharbakim APic GGMethos geal boj jackhill leothrix ipv6 prooftechnique glguy electrostat przemkovv worch bs int0x27h Stratege jlouis Wamanuz AntiSpamMeta ensyde jud threshold kosmikus xplat fgaz dhtns implementation Tourist bmeynell reu m0rphism SuperW[m] Enigmagic brennie niklasb tomus noan_ yashi[m])
05:37:13 --- names: list (DustyDingo orzo tmciver yrid kculpis R0b0t1_ nitrix otto_s_ alexelcu andjjj23 alexbiehl catsup Laney Tehnix Foritus zeroed grumble Khisanth Unhammer texasmynsted scinawa hegge athan Zialus seanparsons alasi Qommand0r atk bydo jrabe Chobbes nathyong heath kyechou majoh_ MarcelineVQ owickstrom joe9 TunaTrky aweinstock bencryption justan0theruser eatman keep_learning mou Miroboru Jaak Chousuke mjo noplamodo ByronJohnson zv eikke sw1nn TimWolla jchia_ sdrodge)
05:37:13 --- names: list (m4lvin magthe martingale amiri cow-orker jdnavarro Psybur jophish byte512 joachifm byorgey m1dnight_ qmm DexterLB Lokathor obadz S007 cross Shatnerz jbalint onethirtyfive vin-ivar vikram__________ S11001001 edwardk Tspoon amatecha wedens tjpeden posco thoradam LnL dibblego toad_ AndreasK bendo johnw alx741_ lkolstad __main__ ntinos beerdrop mud lordcirth zipper staafl dolio johnpark_pj liyang slackman Gabemo diegoksp chu ashirase bod_ kini cyphase jimmyrcom_)
05:37:13 --- names: list (nshepperd Guest18244 polux ali_bush futpib[m] vikraman elpfen[m] Dunearhp prot[m] maerwald trevortknguyen[m goolord[m] wizzup[m] otulp ph88^ xinming ssarah nshepperd1 mathu Freundlich Fairy dredozubov michi7x7 bno2 ahihi2 dustinm- pdgwien tctara Voldenet kensan tjbp pygospa Ke kubrat Ewout Igloo quicksilver nesqi micro_ cheater StoneToad Profpatsch markhuge gspia greeny__ hodapp bind1 nikivi NocnaShada Jinxit bluepixel agrif Twey max-m Arguggi lyxia LeaChim)
05:37:13 --- names: list (catern cgfbee defanor acro kyren Zowlyfon fnurglewitz aaron7 schaeferpp schoppenhauer kimchi[m] hakan[m] Rifa[m] ItevNabdifNi[m] Cadey[m] peel[m] kritzcreek M-krsiehl rakete spotter[m] mascht[m] Guest1573[m] NickSeagull[m] mlainz[m] MikasiCoyote[m] felipeac[m] ElyKar[m] M-rgh khac[m] gylpm[m] superobserver[m] Dako300[m] srenatus[m] razvanc-r[m] reactormonk[m] ptek[m] ketanhwr unknownln lukky513 thekyriarchy michaelw erikd trcm rcat anhduy naudiz asthasr)
05:37:13 --- names: list (albel727 mkoenig _ashbreeze_ MindlessDrone polman besenwesen Milijus pelegreno dec0n pakettiale freeman42x[w] ft _kit_ yorick Natch rossberg_ kwantam1 cods geppettodivacin lafrenierejm agnki twandy geekosaur jedai lambdabot falafel hc spaceships Maxdamantus Sgeo richi235 dmwit Guest54652 Frankablu Pilfers danieli freeman42x hiratara stay_noided Mon_Ouie butterthebuddha theDon jamiecook_ jao perrier-jouet ggherdov markus1189 ixian nakal_ tabaqui thunderrd)
05:37:13 --- names: list (troydm drewbert gehmehgeh dozn Digit heurist mceier iomotoko Asiannoodles42[m neoncont_ kuttifunk Youmu hucksy_ banc Fekinox magistr brynedwards SkyPatrol_ Rotaerk pplorins zhangjiji[m] chominist[m] mtncoder[m] TristanBKildaire mrhunky[m] aniketd[m] mounty unclechu MatrixTraveler[m shutdown_-h_now Xe felixsch_ Swizec XorSwap hamishmack cpup CoderPuppy logicmoo in0perable flxw Netwolf verement ddbbuu[m] fbreitwieser[m] SuperTux88 ego Ferdirand dxtr async_prince)
05:37:13 --- names: list (lieven rootnode rbocquet asjo Guest291964[m] yushyin shyn StianL integral jelleke osfameron joel135 ericsagnes amf Takumo bitonic jokester nyuszika7h OliPicard mpickering bgyss simony ryantm sclv lukexi wavewave Robin_Jadoul dxld edofic jml heyj thoughtpolice lexi-lambda sbauman bendricklamar jfokkan__ dmj` angular_mike_ fall_ Geekingfrog Nycatelos da-x nek0 ubsan coup_de_shitlord urdh Sam__ ambrosia c0dehero Akii sword865 Cerise alanz langkid1 rootmos SCAV)
05:37:13 --- names: list (gpampara kmicu papapishu oldsk00l hanDerPeder raid dsantiago tnks Adluc tg fluxit acowley_away)
05:37:30 <erisco> of course I *want* to be ambivalent on Functor and whats-its but when push comes to shove I can usually admit there is only one or two instances we will actually be using
05:38:03 <erisco> kicking and screaming I make compromises
05:38:19 <ertes-w> and i just use haskell, whenever i can =)
05:39:52 <exarkun> Anyone know how to make a warp server stop?  https://stackoverflow.com/questions/45839972/how-do-i-cause-a-warp-server-to-terminate
05:41:35 <ertes-w> exarkun: killThread
05:42:05 <exarkun> Sounds harsh
05:42:36 <ertes-w> exarkun: it just throws a ThreadKilled exception at warp
05:42:55 <ertes-w> warp can and does handle it
05:43:20 <exarkun> I guess that might be sufficient.  It would be somewhat nice if the 500 response could go out first ... but I guess connection closed is also a kind of error response...
05:43:44 <ski> BernhardPosselt : iirc, `?' indicates (indirectly) an existential
05:44:05 <ertes-w> exarkun: the problem here is not warp, but the fact that when the main thread exits, all threads are instakilled
05:44:42 <exarkun> I kinda hoped there would be a warp `stopRunning` API, mirroring the `run` API
05:44:43 <ertes-w> exarkun: warp has no facilities to avoid that though, as far as i know
05:44:55 <ertes-w> exarkun: killThread is your stopRunning API
05:45:14 <ertes-w> despite the name it's the proper way to tell threads to exit
05:45:30 <exarkun> it's kind of an abstraction violation
05:45:36 <ertes-w> exarkun: why?
05:45:41 <exarkun> apart from this, I might not even know that there are threads involved
05:45:52 <exarkun> what if the server is configured to fork to handle connections instead
05:45:59 <cocreature> the problem kind of is warp since it doesn’t provide you with a way to say something like "serve this request and then execute this bit of code"
05:46:10 <ertes-w> you do know that, both from the documentation and the fact that warp handles multiple requests simultaneously
05:46:42 <ertes-w> forking would be kinda weird in a haskell program
05:47:15 <ertes-w> the problem here is that warp is probably just too quick to leave its main loop when it receives ThreadKilled
05:47:26 <ertes-w> it could just as well first wait for all request handlers to finish
05:47:56 <exarkun> I'm not really too worried about that part.  if I had to return something other than a 500, it'd probably be more of a problem.
05:48:09 <exarkun> I just don't want it to randomly break with a new version of warp or something
05:48:48 <cocreature> apparently there is also "runSettingsSocket" which allows you to shut down warp and claims that it closes all live connections "gracefully" whatever that means
05:49:15 <exarkun> Oh, interesting
05:49:31 * merijn mumbles something about crash only software
05:49:34 <exarkun> That is somewhat more appealing to my sensibilities
05:50:11 <ertes-w> it might be easier to use an MVar
05:50:27 <ertes-w> ah, no, you can't
05:50:37 <ertes-w> wait, actually you can!
05:50:45 <cocreature> yes no maybe!
05:50:58 <ertes-w> WAI uses CPS for Application these days, which allows you to do something *after* the request
05:51:14 <ertes-w> \send -> send … `finally` putMVar quitVar ()
05:51:46 <exarkun> I've had the Haskell CPS docs open in my browser for about 3 months but so far failed to read any of them
05:51:52 <ertes-w> err…  not quite like that
05:52:54 <ertes-w> basically the handler needs to set a TVar to "i want to quit", then send the response, then set the TVar to "ok, i can quit now"
05:54:17 <ertes-w> you can actually do that with an MVar
05:55:05 <ertes-w> ok, even simpler
05:55:19 <ertes-w> \send -> send response `finally` killThread mainTid
05:55:33 <ertes-w> exarkun: that should do exactly what you want without runSettingsSocket
05:55:35 <tdammers> huh, I thought the main reason for the CPS approach was so that middleware could be made more lazy
05:55:58 <ertes-w> tdammers: you can use it to do anything after the response is sent
05:56:26 <exarkun> ertes-w: What do I do with that?
05:56:26 <tdammers> ertes-w: yes, I realize that, but "make middleware more lazy" doesn't necessarily mean "do stuff after the response is sent"
05:56:44 <ertes-w> exarkun: are you using WAI/warp directly or as part of a framework?
05:57:10 <exarkun> ertes-w: As part of Servant, I think
05:57:23 <ertes-w> tdammers: i don't really know what it means…  originally i recall it being introduced to support resource acquisition
05:57:44 <ertes-w> exarkun: WAI itself does offer the facilities to do something after the response is sent
05:57:51 <ertes-w> not sure if servant exposes it
05:58:19 <BernhardPosselt> any idea how i install pcre on mac os?
05:58:31 <BernhardPosselt> was pretty easy on linux
05:58:34 <BernhardPosselt> cant find a brew package
05:59:22 <ahihi2> it's there though https://github.com/Homebrew/homebrew-core/blob/master/Formula/pcre.rb
05:59:28 <tdammers> ertes-w: IMO the most useful thing about CPS responses is that you can pass streaming responses through middlewares and routers without having to resort to lazy I/O or lazy bytestrings or stuff like that
06:15:41 <cheater> hi
06:22:47 * hackagebot haskey-btree 0.1.0.0 – B+-tree implementation in Haskell. – https://hackage.haskell.org/package/haskey-btree
06:26:28 <exarkun> Oh
06:26:48 <exarkun> runSettingsSocket doesn't take a pristine new socket that is used only to signal exit
06:27:07 <exarkun> it takes a listening socket to accept connections on and also treats the close event on that socket as signaling exit
06:27:11 <exarkun> not quite as good
06:31:24 <ertes-w> exarkun: https://hackage.haskell.org/package/servant-0.11/docs/Servant-API-Raw.html
06:32:05 <ertes-w> you can embed a generic WAI application into servant using this…  you can use that one to kill your main thread
06:38:49 * exarkun reads
06:40:21 <Axman6> BernhardPosselt: what's wrong with the pcre package in homebrew?
06:41:09 <BernhardPosselt> Axman6: cant find it
06:41:23 <BernhardPosselt> tried brew search pcre
06:41:29 <BernhardPosselt> no haskell specific results
06:42:41 <ahihi> why are you trying to install haskell packages from homebrew?
06:42:50 <ahihi> instead of stack/cabal
06:43:15 <BernhardPosselt> didnt really read into cabal yet and in archlinux there was already a package
06:43:28 <BernhardPosselt> i dont need it for a project but a simple demonstration
06:44:20 <neuro_> I'm looking for good Phd supervisor in functional programming in Brisbane
06:46:02 <Axman6> BernhardPosselt: I would not be installing haskell packages via homebrew - install stack using homebrew, and let it handle things
06:46:16 <BernhardPosselt> i see, ty
06:46:32 <Axman6> neuro_: Data61's Functional Programming Lab might be a place to start - ping dibblego
06:46:51 <Axman6> IIRC UQ does some FP stuff too
06:49:45 <neuro_> Axman6 Thanks 
06:50:33 <Axman6> I can't think of anyone at the FP lab who might actually be interested in supervising a PhD though, but they might know someone who is
06:51:51 <cheater> tdammers: why would lack of CPS cause that?
06:58:00 <tdammers> cheater: without CPS, you would have to return the response right away
07:02:22 <cheater> do things like channels count as cps?
07:08:10 <tdammers> no
07:13:50 * ski . o O ( Continuation-Passing Style )
07:17:59 <jchia_> lens question: How do I use a Prism so that it fails if the 'branch' cannot be found? E.g. how do I change this so that it fails because the input is not a Right? (Right 'a' :: Either (Int, Char) Char) & _Left . _1 .~ 1
07:18:16 <jchia_> I mean not a Left.
07:18:44 <ski> perhaps someone in #haskell-lens knows
07:19:55 <zekt> I am defining my simple language now, here is how the Values defined (thanks to some nice people here)
07:19:56 <zekt> data Val a where N :: Int -> Val Int; B :: Bool -> Val Bool; L :: [Val a] -> Val [a];
07:19:56 <zekt> here's another problem, how do I define a pair? I want to do something like P :: (Val a) -> (Val b) -> (a, b)
07:20:14 <erisco> zekt, you can use a function again, like I suggested for lists :)
07:20:33 <dredozubov> is it possible to abstract over two types of kind #?
07:20:45 <Cale> zekt: P :: Val a -> Val b -> Val (a,b)  sounds likely
07:21:58 <zekt> ohhhhh stupid me
07:22:01 <erisco> zekt, if you have lit :: a -> Val a and app :: Val (a -> b) -> Val a -> Val b then lit (,) :: Val (a -> b -> (a, b)) and for x :: A, y :: B, lit (,) `app` lit x `app` lit y :: Val (A, B)
07:22:03 <Cale> You could also have Either:  EL :: Val a -> Val (Either a b); ER :: Val b -> Val (Either a b)
07:23:45 <erisco> dredozubov, forall (a :: #) (b :: #). possibly? I don't know what # is
07:24:04 <zekt> erisco: exactly what I am scratching my head about, to define a Lit
07:24:18 <erisco> Lit :: a -> Val a
07:24:45 * ski . o O ( `Lit :: Literal a => a -> Val a' )
07:25:04 <phaazon> what’s the de facto lib for locale and time zone?
07:25:11 <phaazon> I guess time is okay for TimeZone
07:25:14 <phaazon> but what about locale?
07:25:33 <zekt> how could I have not think of it? thanks this is pretty inspring
07:26:38 <zekt> I was think about if I do P :: (Val a) -> (Val b) -> Val (a, b) I would need two argument for this GADT, seems I am thinking it wrong
07:28:04 <erisco> it depends what you want your language to be...  Lit :: a -> Val a  says everything is in your Val language
07:28:14 <ertes-w> jchia_: "fails"?
07:28:28 <sphinxo> How do I lift a function Int -> Int -> Int to work over newtype V = V Int
07:28:53 <erisco> sphinxo, deriving Applicative with GeneralizedNewtypeDeriving and then liftA2
07:29:00 <jchia_> ertes-w: 'fails' can mean to get an error, like with 'Left 1 ^?! _Right'
07:29:13 <ski> erisco : not parameterized
07:29:14 <ertes-w> jchia_: where?
07:29:16 <erisco> sphinxo, I am stupid, I thought there was a parameter
07:29:35 <erisco> correction, make it newtype V a = V a and then do that :P
07:29:44 <jchia_> ertes-w: where what?
07:30:01 <ertes-w> jchia_: where do you expect to see failure?  i.e. which function should "fail" and how?
07:30:32 <sphinxo> erisco: if I don't want a parameter?
07:30:48 <erisco> I took a peak at uniplate... I don't really know what it is all about but maybe it helps here
07:32:04 <ertes-w> jchia_: prisms are also traversals at the same time, so the way 'over' fails is by not changing anything
07:32:31 <dolio> uniplate was supposed to be a simpler generic programming library than SYB.
07:32:41 <ertes-w> jchia_: the way 'view' fails, when applicable, is to return mempty
07:33:10 <jchia_> ertes-w: Can I make it throw an exception like (^?!) if the 'part' doesn't exist?
07:33:16 <ertes-w> sphinxo: you do want a parameter…  just use V Int where you would have used V =)
07:33:36 <jchia_> i'm talking about when i'm trying to set something
07:34:22 <sphinxo> ertes-w: but supposing I didn't
07:37:04 <ski> @type \(+) (V x) (V y) -> V (x + y)
07:37:06 <lambdabot> (Int -> Int -> Int) -> V -> V -> V
07:38:07 <ertes-w> jchia_: you could use partsOf to check whether the traversal has any targets for a given value
07:38:17 <ertes-w> > partsOf _Left (Left ())
07:38:19 <lambdabot>  error:
07:38:19 <lambdabot>      • Couldn't match expected type ‘[a] -> f [a]’
07:38:19 <lambdabot>                    with actual type ‘Either () b0’
07:38:25 <erisco> sphinxo, if you are okay with a definition per arity then it is easy
07:38:26 <ertes-w> err
07:38:52 <ertes-w> > toListOf _Left (Left ())
07:38:53 <erisco> if you are okay with writing a repetitive expression proportional to the arity then that is also easy
07:38:54 <lambdabot>  [()]
07:38:56 <ertes-w> > toListOf _Right (Left ())
07:38:58 <lambdabot>  []
07:39:10 <ertes-w> jchia_: sorry, toListOf, not partsOf
07:39:19 <erisco> but, lets see, a better way...
07:39:31 <ertes-w> if that list is empty, then the traversal does not have targets
07:40:02 <ertes-w> sphinxo: that's a rather artificial restriction…  you can always define type V = V' Int
07:40:40 <Unode> if I want to have a type that behaves exactly like another type (e.g MyString = String) what keyword should I use if I want functions to accept myfunc MyString but if called with myfunc String it wouldn't type-check?
07:41:08 <byorgey> Unode: 'newtype'
07:41:35 <byorgey> newtype MyString = MkMyString String
07:41:47 <Unode> byorgey: doesn't newtype require new constructors ...
07:41:51 <Unode> yes I see
07:41:53 <byorgey> Unode: yes.
07:42:07 <Anon-kun> Hi everyone!
07:42:19 <byorgey> Unode: if you want it to be a type error when you mix them up, then you must have a new constructor.
07:42:32 <Anon-kun> I really want to learn Haskell, but don't know where to start, does anyone have any ideas?
07:42:45 <erisco> I feel an idea coming on...
07:42:45 <Anon-kun> Preferably text-based
07:42:46 <mnoonan> Unode, in that particular case, you can also use OverloadedStrings so that you can have string literals of type MyString
07:42:48 <Unode> Anon-kun: Learn you a haskell for great good is working out for me
07:43:01 <Unode> the book I mean
07:43:05 <Anon-kun> Thanks
07:43:12 <Anon-kun> I'll look into it
07:43:25 <byorgey> Anon-kun: https://github.com/bitemyapp/learnhaskell/blob/master/README.md is a meta-guide pointing you to a lot of learning resources
07:43:33 <hmrc> Anon-kun: Haskell Programming from First Principles by Chris Allen is good
07:43:33 <Unode> mnoonan: does that give me the type-check failing I mentioned?
07:43:47 <Unode> hmrc: I found that one too much
07:43:49 <Anon-kun> Thanks for the suggestions guys
07:44:15 <Unode> hmrc: a lot of theory, not enough "how to solve problem A in practice".
07:44:28 <ertes-w> Anon-kun: my personal favourite so far is CIS 194, though i haven't read the current (2016) version
07:45:02 <mnoonan> Unode: it just changes the type of "some string" from String to something like IsString a => a. Then you can implement IsString for your newtype to keep the safety. (I forget if that is exactly the right typeclass)
07:45:09 <ertes-w> Anon-kun: https://www.cis.upenn.edu/~cis194/fall16/
07:45:16 <byorgey> mnoonan: yes, IsString is right
07:45:36 <ski> @let infixr 1 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> g) h = g . h . f
07:45:38 <lambdabot>  Defined.
07:45:46 <ski> @type unV ~> unV ~> V  -- sphinxo ?
07:45:47 <lambdabot> (Int -> Int -> Int) -> V -> V -> V
07:45:56 <mnoonan> but it depends on how you want to use your newtype. a common idiom is to hide the constructor so that you can only get a MyString through certain blessed functions (say, that do validation)
07:46:12 <mnoonan> in that case, overloaded strings would not be so great
07:47:11 <Unode> mnoonan: yeah I'm still trying to wrap my head around it and due to having a few variables with same types I was hoping that I could just give them different names so that the compiler tells me if I'm mixing them up somehow. Behavior-wise they should act like String (or FilePath in this case)
07:47:44 <ski> Unode : you'll need to explicitly wrap and unwrap
07:47:49 <mnoonan> FilePath is a great example of something that should have been a newtype :)
07:47:54 <Unode> ski: I don't know what that means
07:48:26 <ski> Unode : when you have a `String' (or `FilePath'), but you want a `MyString', you need to wrap the value with `MkMyString'
07:48:48 <Unode> I see
07:49:00 <Unode> sounds unnecessary then
07:49:16 <ski> Unode : when you have a `MyString', but you want to treat it as a `String' (or `FilePath'), use pattern-matching on `MkMyString' (or define a helper function `unMyString' that does it for you)
07:49:29 <ski>   unMyString (MkMyString s) = s
07:49:54 <tdammers> the main use case for newtypes is having different typeclass instances for things that have the same internal representation
07:50:18 <Unode> tdammers: that reads like what I want
07:50:24 <ski> restricted type synonyms in HuGS would have been nice in GHC ..
07:53:23 <jchia_> ertes-w: Thanks. I could do that and check for empty list before doing the setting, but that's two steps. Someone in #haskell-lens suggested using failover.
07:54:44 <mnoonan> Unode: here are some examples
07:54:45 <mnoonan> http://lpaste.net/357912
07:59:38 <ertes-w> jchia_: ah, yeah, that's pretty much what failover does
08:02:54 <SepakoRayl> what is the best library for extensible records?
08:03:16 <sphinxo> Given data T = T Int Int and a fn Int -> Int -> Int
08:03:43 <sphinxo> how can I raise the fn so I can apply it to (T 1 3) and (T 2 5)
08:03:50 <ertes-w> SepakoRayl: probably vinyl, but "best" does not necessarily mean "good" here
08:04:01 <ertes-w> SepakoRayl: it's more like: "as good as it gets in haskell"
08:04:06 <sphinxo> which eg if the fn is (+) would yield (T 3 8)
08:05:37 <Iceland_jack> sphinxo: You get this for free if you add a type argument to T
08:05:53 <Iceland_jack> but you write: liftT2 :: (Int -> Int -> Int) -> (T -> T -> T)
08:06:07 <Iceland_jack> liftT2 f (T a b) (T a' b') = T (f a a') (f b b')
08:06:42 <Iceland_jack> By adding a type argument to T you can make it Applicative (data T a = T a a) and then liftT2 = liftA2
08:06:58 <sphinxo> huh ok i might go down that route then
08:07:15 <Iceland_jack> with the implementation: pure a = T a a
08:07:24 <Iceland_jack> T f f' <*> T x x' = T (f x) (f' x')
08:07:42 <Iceland_jack> It already exists in the linear library as V2
08:07:46 <Iceland_jack> sometimes called Pair
08:08:17 <Psybur|Work> https://wiki.haskell.org/Lifting
08:09:04 <Iceland_jack> why that Wiki uses a bespoke Liftable class is beyond me
08:10:11 <Iceland_jack> alright, see you everyone
08:10:14 <Iceland_jack> have a lovely day
08:10:25 <Unode> mnoonan: many thanks for all that. Exactly what I was looking for.
08:11:07 <ertes-w> you don't even need to write an Applicative instance by hand
08:12:46 <ertes-w> although it doesn't make much of a difference in this case
08:21:44 <cheater> tdammers: but channels allow things to be decoupled so that you don't have to return the response immediately, right?
08:22:55 <mnoonan> Unode: I should have also pointed out that 'newtype' is only a compile-time construct. at run-time, all of the wrapping and unwrapping becomes no-ops. so there run-time overhead associated with using 'newtype' (unlike 'data', which would introduce a level of indirection)
08:23:15 <mnoonan> so there *is no* run-time overhead, I mean :)
08:23:53 <Unode> mnoonan: ah ok I though there was some overhead there. Great!
08:24:22 <byorgey> doing something like  'map unwrap'  still has overhead.  But we have Data.Coerce is for that now =)
08:24:36 <byorgey> s/is//
08:25:23 <mnoonan> byorgey, interesting.. because the application of 'unwrap' is lazy (despite being effectively id), or for a different reason?
08:25:51 <ski> because `map' still traverses
08:26:21 <ski> repeating an `O(0)' operation, `n' times, is still `O(n)'
08:26:33 <peter___> hello
08:26:37 <ski> hello
08:26:47 <mnoonan> i guess i'd expect "map id" to get optimized away easily
08:26:52 <gvaerg> you mean O(1) probably
08:26:58 <ski> no
08:27:16 <gvaerg> not O(0)
08:27:32 <ski> a `newtype' constructor is `O(0)'
08:27:41 <ski> translates to a no-op
08:28:09 <gvaerg> Does it consume clock cycles?
08:28:13 <ski> but there's still iteration overhead (`O(1)') for each element reached by `map'
08:28:18 <ski> it does not
08:28:49 <gvaerg> Ah so there is some O(1) there and that is why it yields O(n)
08:28:54 <ski> right
08:29:50 * mnoonan realizes he should update justified-containers to use coerce for the recursive maps instead of fmapping a wrapper
08:30:29 <ahihi> are there not rewrite rules to optimize "map unwrap" to a coerce?
08:30:49 <ski> you could add it
08:31:16 <peter___> I'm getting this error when i build
08:31:17 <peter___>     Failed to load interface for ‘Data.List.Split’
08:31:17 <peter___>     It is a member of the hidden package ‘split-0.2.3.2’.
08:31:22 <peter___>     Perhaps you need to add ‘split’ to the build-depends in your .cabal file
08:31:57 <peter___> i'm having trouble finding information on how to configure a .cabal file
08:32:22 <peter___> even if you're doing a toy project, are you supposed to run cabal init
08:35:22 <ertes-w> peter___: you can set up a cabal sandbox without a cabal project and install everything you need there
08:35:34 <ertes-w> peter___: change into the project directory, then type: cabal sandbox init
08:36:11 <ertes-w> after that all 'cabal' installations will be within a hidden subdirectory there
08:36:18 <ertes-w> so you can just 'cabal install split'
08:37:11 <peter___> awesome
08:37:20 <peter___> i'll give it a go, thank you ertes
08:37:48 <peter___> what's the deal with cabal.. is it like pip/npm/etc
08:40:33 <ertes-w> peter___: pretty much
08:41:15 <ertes-w> peter___: note that for the sandbox to take affect 'cabal' must be run inside that directory
08:48:50 <peter___> ertes-w: makes sense.   Now that i have a cabal-sandbox, how do i update it with the appropraite dependancies. 
08:49:01 <peter___> ertes-w: i added : build-depends: split
08:49:14 <peter___> ertes-w: to .cabal-sandbox
08:49:20 <peter___> ertes-w: no luck
08:51:44 <ertes-w> peter___: you don't need to add anything…  just type:  cabal install split
08:51:57 <ertes-w> peter___: your goal was not to have to maintain a dependency file, right?
08:53:05 <peter___> ertes-w:  goal is to get around the 'stack build' error.  i have run cabal install split, still hitting the error
08:53:17 <peter___> ertes-w: maybe i'm going about this wrong
08:53:42 <peter___> ertes-w: goal is to split a string into a list, split on comma
08:54:45 <ertes-w> peter___: if you don't want to create a full cabal project, then you can't use cabal or stack to build…  you need to invoke 'cabal exec ghc' within the sandbox
08:54:58 <ertes-w> like:  cabal exec ghc -O -o blah blah.hs
08:55:37 <ertes-w> but you might also just not compile…  'cabal repl' gives you an interpreter in the context of the current sandbox
09:04:31 <peter___> ertes-w: this is a toy project that i'm writing in order to learn haskell. i am picking up a file, splitting it by commas, doing an api call based on data in each element, and building  a new file.  
09:06:19 <peter___> ertes-w:  nothing more elaborate than that.  but to make a callable script that has dependencies on libraries, is creating a full cabal project the right thing to do?
09:06:26 <ertes-w> peter___: yeah…  just switch into an empty directory, create a sandbox, then start writing a file, say 'blah.hs'
09:06:38 <ertes-w> peter___: then load that file into GHCi using the following command:  cabal repl blah.hs
09:07:23 <ertes-w> peter___: typically a cabal project is the way to go, but no need to learn cabal right now…  an ad-hoc sandbox is great for learning, because you can focus on the language
09:08:10 <ertes-w> peter___: … while still being able to install your dependencies
09:08:21 <ertes-w> when you're done just throw away the sandbox
09:11:00 <peter___> ertes-w: awesome. so i have: cabal sandbox init; cabal install split; 
09:11:12 <peter___> module Main where
09:11:12 <peter___> main :: IO()
09:11:12 <peter___> main = do
09:11:12 <peter___>                         let x = splitOn "," "asdf,1234,dfhg"
09:11:12 <peter___>                         print x
09:11:23 <peter___> cabal exec ghc runMe.hs
09:11:38 <peter___> Variable not in scope: splitOn :: [Char] -> [Char] -> t
09:12:05 <ertes-w> peter___: you forgot to import, and also please use a web pastebin like lpaste or gist for pasting longer examples
09:12:10 <ertes-w> @paste
09:12:10 <lambdabot> Haskell pastebin: http://lpaste.net/
09:12:11 <Welkin> peter___: please use lpaste instead
09:12:30 <peter___> ah
09:12:31 <peter___> got it
09:13:01 <peter___> thank you for getting me over that hurdle, still figuring out my mental map of all this.  Got it all working
09:15:38 <ertes-w> peter___: great, have fun learning =)
09:25:50 * hackagebot propellor 4.7.7 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
09:27:03 <pavonia> Not sure this is the right place to ask, but is there a way to set the title of an HTML document when converting from Markdown via pandoc?
09:30:50 <peter___> ertes-w: what is the intended difference between cabal and stack?
09:34:41 <erisco> what use is dropping the degree of time complexity if it is still above 1
09:35:05 <woffs> peter___, cabal is the basic build system and stack tries to reliable sets of modules on top, because of the cabal dependency hell
09:37:28 <erisco> there are algorithms used with awful worst cases but the point is that they're unlikely
09:37:55 <erisco> you wouldn't use that approach if the worst case was actually what you needed
09:38:31 <erisco> so you have some algorithm that takes O(n^10) time, and then figure out an O(n^8) way to do it instead, but what does it practically matter
09:38:45 <erisco> the only thing that addresses is the worst case which is unusable either way
09:41:04 <Athas> peter___: that question is complicated because there are three things all called more or less "cabal".  There is ".cabal the file format", "Cabal the library" (note the capital "C"), and "cabal-install the command-line program" (where the binary is confusingly actually called "cabal").
09:41:12 <Athas> It's a rather unfortunate circumstance...
09:43:44 <monochrom> erisco, at the abstract level of "O(n^10) vs O(n^9), both worst case", you still don't know how much the worst cases matter. For all you know, they may matter a lot.
09:44:14 <erisco> what is any practical example of this?
09:44:16 <monochrom> For your practical view, you need to start talking about probabilities.
09:44:25 <dsal> Well, I ran into this after a long time last night:  https://github.com/commercialhaskell/stack/issues/3051
09:44:33 <erisco> no, I am saying the probability of worst case is 100%
09:45:39 <monochrom> Bubble sort is worst-case quadratic and also highly-likely quadratic. You can't rationally say "oh that's just worst case, won't happen in practice". This is unlike quicksort. 
09:46:38 <pavonia> For the record: "title: ..." in the header of the .md file sets the <title> element in the resulting .html file; `-V title: ""` prevents it from also adding an extra heading element with the same text
09:46:47 <monochrom> Unfortunately, probability is too hard for undergrads.
09:47:23 <dminuoso> monochrom, considering the amount of people I see avoiding hash table based structures because they just see worst case O(n)..
09:47:52 <erisco> like I said, nothing to do with probabilities, we only care about worst case
09:48:09 <monochrom> Ha, I see the opposite: People flocking over hash tables because they just see the substring "O(1)" without context.
09:49:00 <dminuoso> monochrom, I can give you guaranteed worst case O(1) hash tables!
09:49:07 <dminuoso> (for lookup)
09:49:11 <monochrom> erisco, undergrad is only taught worst casses, only because it is the only thing easy enough to work out.
09:50:30 <monochrom> Even with quicksort, the proof of "O(n lg n) with such-and-such low probability" confuses the hell out of the undergrads. I tried teaching it once.
09:51:25 <monochrom> I settled down with just teaching the average time. Even that could easily lose half of the class.
09:51:25 <erisco> well, that's cool about undergrads and all, I am not one :P
09:52:04 <monochrom> And now try to learn treaps and prove time bounds and probabilities about them.
09:52:33 <monochrom> I actually may try that next year when I have to time understand it myself in the first place.
09:52:37 <erisco> so as I think about this, I think it really depends what size of input we can compute in our fixed time
09:52:44 <monochrom> s/to time/time to/
09:52:59 <monochrom> (Ha that's a new kind of typo I haven't made before.)
09:53:09 <erisco> because we know asymptotically the improvement is infinite
09:53:34 <erisco> so the more we can already compute with the slower algorithm the more significant the difference from switching to the new one
09:54:21 <nshepperd> the difference between O(n^10) and O(n^9) may not be very much
09:54:21 <erisco> far enough out you might be looking at a factor 10 improvement or more, and that might make something capable of real time
09:54:44 <erisco> or it means having work one in one day instead of 10
09:54:53 <nshepperd> because you can only afford to run up to about n=10 probably
09:55:09 <erisco> right
09:55:17 <monochrom> In fact I should also whine about how everyone uses O instead of Θ, again an indication of how hard it is to teach undergrads more than one thing.
09:55:50 <erisco> so I think the practical perspective is based on the fixed compute time
09:56:34 <monochrom> And yeah, to scientists who need to solve matrix systems of 500x500 or something like that, "one month vs half a month" matters too.
09:58:16 <monochrom> Although, "5 years vs 10 years" doesn't, because you're supposed to wait 5 years, buy a new computer, then it finishes in 1 year, so total just 6 years. XD
09:59:16 * hackagebot structured-cli 0.9.0.2 – Application library for building interactive console CLIs – https://hackage.haskell.org/package/structured-cli
09:59:20 <erisco> for large time spans we have to incorporate technological advancement into the calculation... like over large distances we have to calculate the curvature of the Earth
10:00:29 <erisco> monochrom, actually if you could predict accurately enough you could minimize the compute time, heh
10:00:39 <erisco> waiting for a faster computer vs getting started now
10:00:53 <monochrom> Yeah.
10:01:52 <nshepperd> from θ(n^10) to θ(n^9), you probably get a 10x speedup since i bet your n is around 10. or it adds 3 or so to the n that you can feasibly compute. I suppose whether that's useful is up to you
10:02:22 <nshepperd> (assuming the changes didn't cause a 10x constant factor slowdown at the same time)
10:03:15 <erisco> yes, right ;)
10:04:51 <nshepperd> you could write a checkpointing algorithm that lets you resume on a new machine, so that you can take maximal advantage of technological growth
10:04:53 <leshow> I'm trying to catch an exception and return a default in that case, but GHC is complaining about ambiguous type instances. handle (\_ -> pure "filepath") (pure (head pathlist)) 
10:05:06 <leshow> but I feel like this should be fine, the type returns an IO FilePath
10:05:13 <leshow> does anything jump out as obviously wrong there
10:05:24 <nshepperd> for anything that takes that long you'd better make sure it has no bugs :)
10:05:53 <monochrom> leshow, you need handle (\_ -> pure "filepath") (evaluate (head pathlist)). evaluate is in Control.Exception
10:06:04 <erisco> nshepperd, but now you have a projected income and depreciation for the hardware you by
10:06:14 <monochrom> Also, read the doc of evaluate, you will be happy.
10:06:30 <erisco> so you can buy a computer now, start some work, but to upgrade the best you can do is sell at a loss and buy another machine
10:07:18 <leshow> monochrom: that won't fix the type error though
10:07:25 <nshepperd> leshow: paste your actual code and also the error at lpaste
10:07:32 <monochrom> What type error?
10:07:44 <leshow> ambiguous instances, one sec ill paste
10:09:01 <leshow> http://lpaste.net/357915
10:09:06 <monochrom> Yeah I confess I ddin't read the question. I just saw how "pure (head whatever)" is not going to trigger an exception.
10:09:29 <leshow> monochrom: you're absolutely right it wouldn't have, I would have found that error at runtime, thanks
10:09:53 <leshow> why does it want a type annotation on the exception?
10:10:13 <monochrom> OK so you need to read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
10:10:16 <jarandaf> hi there, has anyone worked with the `statistics` library?
10:10:26 <glguy> Yeah, people have
10:11:20 <dsal> Man.  Stack build crashes one machine, and segfaults on another.  This is super not convenient.
10:11:44 <monochrom> Both machines have bad RAM chips? :)
10:12:25 <leshow> monochrom: but i'm ignoring the value in this case
10:12:34 <nshepperd> leshow: oh right, it needs to know what type of exception to catch. it can't just go catching all exceptions at once
10:12:55 <dsal> monochrom: One is too old of an ARM, I guess, and the other may just have insufficient RAM.
10:13:01 <monochrom> leshow, that is more reason, not less, to manually annotate types.
10:13:18 <monochrom> The more you ignore, the less type inference works.
10:13:33 <leshow> nshepperd: weird, they use handle (\_ -> ... in realworldhaskell without annotation
10:13:40 <ski> leshow : it doesn't know which types of exceptions you want to catch ..
10:13:50 <monochrom> That is because RWH was obsolete the day it was published.
10:13:54 <monochrom> Generally, all books are.
10:14:16 <monochrom> Or rather, s/Generally/Statistically/
10:14:23 <leshow> I thought exception was existentially quantified, can't i handle 'for some' exception
10:14:42 <monochrom> That is tangential.
10:15:14 <erisco> are you sure it isn't a secant?
10:15:21 <monochrom> At this point you really need to read my whole article from cover to cover.
10:15:40 <monochrom> Ah I'll reserve "secant" for cross-cutting concerns. :)
10:16:30 <monochrom> Example: <A> But I need to get a consensus from all department heads in my company.  <B> That's secantial.  :)
10:17:05 <dsal> I've not used exception stuff before, but I've got code that errors.  What's the easiest way to convert an error to a Maybe?
10:17:07 <nshepperd> leshow: even if you could handle 'for some' exception, it wouldn't know whether you wanted that or some specific type of exception, without some type annotation
10:17:08 <erisco> urban dictionary needs us
10:17:29 <dsal> i.e.      f (code that might error or return t) -> Maybe t
10:17:40 <monochrom> dsal: It is actually easier to convert to Either. Use the try* functions in Control.Exception.
10:18:10 <leshow> It's disappointing that RWH hasn't been updated 
10:18:20 <leshow> they have code that wont even run in ghci
10:18:27 <shapr> leshow: fork it?
10:20:52 <leshow> what's the syntax for putting an annotation on a lambda argument? \_ :: IOException -> ... ?
10:21:13 <Aruro> is F# commerically more successful than Haskell?
10:21:31 <monochrom> \ (_ :: IOException)  and turn on ScopedTypeVariables
10:22:23 <leshow> seems odd that i can't really use control.exception functions without turning on a language pragma?
10:22:38 <erisco> Aruro, and how would you measure that
10:23:17 <monochrom> But you can.
10:23:19 <Aruro> i mean just by usage in industry, seems f# has full support of .net
10:23:38 <Aruro> i consider its good if f# is successful more people will open up to haskell:)
10:23:52 <Aruro> thats why im asking, to understand if its the case
10:23:56 <monochrom> ((\_ -> whatever) :: IOException -> Whatever) is standard Haskell 2010. You are just ignoring this option.
10:24:36 <leshow> Oh ok. Well thank you. I'll give your article a read also
10:24:48 <monochrom> Using a "let" or "where" to give a name and type sig to that function instead of an inline lambda is also an option.
10:25:35 <monochrom> Not ignoring the argument is also an option. The way you use it can nail its type, so you don't even need to annotate.
10:25:46 <monochrom> But you're closing all those doors.
10:26:46 * hackagebot diagrams-core 1.4.0.1, dublincore-xml-conduit 0.1.0.0, text-cp437 0.2.0.0
10:26:46 * hackagebot  → https://hackage.haskell.org/packages/recent
10:27:30 <monochrom> People see a dust-size omission in the environment and not a big stick in their programming style.
10:28:33 <erisco> I like what you're saying but I don't trust trends
10:29:47 <Aruro> would be nice to see how many companies use f#
10:30:14 <Aruro> after uglinness of c# its a fresh air
10:30:52 <erisco> it isn't ugly. it just has character.
10:31:17 <Aruro> i still dont get how whole idea of OOP did fly
10:31:23 <Aruro> its so much nonsense
10:32:37 <erisco> I'll tell you why, and I wasn't even there
10:32:52 <erisco> it is because paradigms don't sell themselves
10:33:20 <cement> you're saying OOP had better salesmen?
10:34:09 <Cale> Eventually.
10:34:28 <Aruro> yes but sombody DID invent it as a concept
10:34:29 <maerwald> Aruro: it has relatively easy interfaces with most of the complexity hidden in state. So as long as you are not writing that state-machine, it's far easier than most APIs
10:35:46 <leshow> is there a way to inspect the type of an exception thrown? ghci only shows **exception
10:36:27 <cement> case/pattern matching?
10:36:32 <erisco> people sell themselves on paradigms
10:36:43 <Aruro> maerwald: i dont see how it is better than plain C
10:37:02 <maerwald> Aruro: passing state and context pointers explicitly everywhere is better?
10:37:18 <erisco> so somewhere along the way people found this way made more sense to them than that
10:37:31 <maerwald> Aruro: even in haskell people avoid that by using monad stacks
10:37:39 <maerwald> which is esentially already OOP
10:38:09 <Ojd> I missed part of the conversation about OOP, but I had a topic that is related
10:38:11 <erisco> we don't spend enough time trying to disprove ourselves to compare options on merit
10:38:21 <Ojd> actually it is a question
10:38:22 <Ojd> :)
10:38:32 <cement> something something confirmation bias
10:39:39 <erisco> how many things are not in your attention because you do not understand them? most things
10:39:56 <erisco> if option A makes sense and option B is confusing we're going to find more sense in option A even if option B is better
10:40:24 <Ojd> Some context first: I started studying Haskell a few weeks ago, and it is mainly because I want to try functional programming. I have worked in the past with Scheme/Lisp, but I believe that just recently I have the real "eureka"moment and it started to make sense the difference between imperative/functional approaches
10:41:27 <Aruro> haskell is imperative too
10:41:32 <erisco> why anyone bothers themselves to be confused about something for a long time until it makes sense is a wonder
10:42:07 <cement> the sense of victory one gets when one finally becomes unconfused
10:42:19 <byorgey> Ojd: cool, welcome =)
10:42:29 <erisco> our capacity for delayed satisfaction
10:43:07 <cement> also boredom
10:43:27 <cement> bein confused is usually less boring than doing something over and over again
10:44:27 * hackagebot text-cp437 0.2.1 – Conversion of Text to and from CP437 – https://hackage.haskell.org/package/text-cp437
10:44:31 <erisco> we're in a biased crowd ;)
10:44:31 * nshepperd handle (\e -> let _ = e :: IOException in whatever)
10:46:08 <Aruro> OOP makes no sense because it does not offer any useful/extensible means of abstraction, its a one project thing. IMO.
10:46:09 <erisco> but if you want something to succeed then focus on it effortlessly making sense
10:46:27 <erisco> whether the sense is true or complete or not
10:46:29 <Ojd> I have been following the first book recommended in haskell.org (http://learnyouahaskell.com/) and right now I am in Chapter 8, "Own types and typeclasses"
10:46:51 <Ojd> it has very challenging but a lot of fun
10:47:07 <cement> oh, you're just about to hit the fun part
10:47:12 <Ojd> so I start asking questions about the use of Haskell in real life appilcations
10:47:23 <jarandaf> has anyone worked with the `statistics` library?
10:47:31 <Ojd> to practice I have been "porting" some old python/c++ scripts
10:47:47 <shapr> Ojd: my employer primarily uses python and Go, but everybody in the office uses ShellCheck and pandoc, and several use xmonad
10:47:51 <erisco> the sense in Haskell when I decided to learn was not because I thought anything about the language. how could I? I didn't know it yet
10:48:21 <cement> I was gang-pressed into learning
10:48:32 <shapr> cement: lucky you
10:48:48 <Aruro> shapr: ShellCheck to check bash scripts?
10:48:48 <dsal>  Ojd Yeah, just start building stuff you need.
10:48:56 <shapr> Aruro: yup, everybody uses it here.
10:49:05 <Aruro> hm but u said python and go?
10:49:08 <Aruro> and shell?
10:49:15 <shapr> yes, we still write shell scripts for some things.
10:49:24 <dsal> I've got a web server that reads and parses a gross binary blob from a serial port, STMs it into a memory structure and serves it as JSON via HTTP.
10:49:44 <cement> I literally got a job writing haskell, which was a marked improvement over literally washing dishes, so I can't really complain
10:49:48 <dsal> (though I've not done the actual serial port yet -- the machine that I actually want to run this on may not actually be able to build it, which is a whole other concern)
10:49:51 <erisco> it was because I saw both the mystery and the kind of people involved, and it was obvious there had to be something worthwhile to it
10:50:28 <erisco> you feel left out when there's a group of people off to the side talking excitedly to each other about something you don't understand
10:50:33 <Ojd> yep, that is the point/question... I know my programs are not that elegant not efficient (yet), but I managed to make them work
10:50:33 <shapr> I actually gave up on learning Haskell and decided to learn scheme instead, but the person I was dating had already ordered Haskell books, so I thought I'd try it anyway.
10:51:05 <shapr> plus a friend of mine said "Why are you writing Haskell in Python?" so I had to figure out what that meant.
10:51:07 <cement> lisps are good fun, shame about them bein untyped
10:51:08 <Ojd> so I start thinking on more challenges while I am still reading this book... and I thought of Machine Learning
10:51:30 <dsal> Ojd: There are haskell bindings for tensorflow.
10:52:05 <MarcelineVQ> there's also a homegrown ANN lib called grenade
10:52:45 <cement> I think I'm about to start working with someone who'd be willing to homegrow another NN library
10:53:06 <erisco> at the same time, there is danger, because we can be mislead by something which seems sensible but isn't
10:53:31 <erisco> there is some mental check for reasonability and if it passes we don't keep thinking about it
10:53:53 <cement> sometimes we do get prompted to recheck tho
10:54:03 <erisco> if you've caught yourself spouting off something like you knew it for fact only to embarrassingly realise you have no idea what you're saying... that's that
10:54:09 <MarcelineVQ> there's also DeepDarkFantasy while you're checking out haskell ml stuff
10:54:37 <leshow> monochrom: apparently you can catch all exceptions, you just usually don't want to
10:54:38 <MarcelineVQ> erisco: cached answers take less effort than recomputing :>
10:55:07 <Ojd> well, after that long and boring introduction, my question is about the use of Haskell in real applications?
10:55:08 <Tuplanolla> Like the word "misled", erisco.
10:55:24 <Ojd> I have been looking in github for projects with haskell
10:55:28 <leshow> monochrom handle ((\_ -> pure "somefilepath") :: SomeException -> IO FilePath) (pure $ head p)
10:55:31 <cement> I'm writing a website and a network graphing app
10:55:41 <cement> they're both private repos tho
10:55:45 <Ojd> and reading some articles, but I thought this would be a good place to ask
10:56:07 <erisco> Tuplanolla, I frequently make tense errors when typing... I have a habit of thinking about the next thing before finishing typing the first
10:56:09 <Aruro> Ojd: nothing to ask, haskell is best thing
10:56:14 <Ojd> I have the advantage that I work in a totally different field, so I actually can use whatever tool I want as long as I can get a validated result
10:56:14 <Aruro> so far.
10:56:35 <Aruro> haskell is most mentally safe language
10:56:36 <dsal> Ojd: I used darcs many years ago, and just recently started using it again just because.  It's quite nice.
10:56:39 <Tuplanolla> I just wanted to let you know your philosophical monologue didn't fall on deaf ears, erisco.
10:57:43 <Aruro> Ojd: if u can use haskell of course, but if you are in buiseness you can make your company a bad favour if nobody will be able to support your code after you leave
10:57:55 <peter___> i'm trying to parse json
10:58:08 <maerwald> Aruro: do you care when you are leaving anyway? :P
10:58:17 <Aruro> its nice to be nice.
10:58:19 <Aruro> :)
10:58:23 <maerwald> in industry?
10:58:27 <maerwald> that's a new
10:58:34 <Ojd> MarcelineVQ :):):)  I google DeepDarkFantasy
10:58:50 <peter___> do you have to import a library to be able to use ^.
10:58:50 <Ojd> and I think the first page I visited wasn't the one you want me to see
10:59:02 <peter___> I'm geting Variable not in scope:
10:59:05 <peter___> Variable not in scope:
10:59:06 <peter___>         (^.)
10:59:17 <Tuplanolla> Yes, peter___.
10:59:38 <cement> is that aeson? it doesn't quite look like aeson
10:59:51 <peter___> i am importing aeson
11:00:05 <MarcelineVQ> Ojd: these are the things that have been mentioned so far   https://github.com/tensorflow/haskell   https://github.com/HuwCampbell/grenade   https://github.com/ThoughtWorksInc/DeepDarkFantasy
11:00:08 <cocreature> peter___: where did you get (^.) from?
11:00:11 <shapr> Ojd: what is the field that you work in?
11:00:24 <peter___> the internet :)
11:00:26 <erisco> I am just a layman, but have you heard of the experiments which influence a person's decision and then ask the person why they made that decision?
11:00:27 <cocreature> that looks like lens so maybe lens-aeson or something like that.
11:00:33 <peter___> i'll put it on pastebin
11:00:41 <peter___> i am following wreq's tutorial
11:00:46 <shapr> erisco: predictably irrational?
11:00:50 <peter___> to make api calls and parse the json i get back
11:01:05 <Ojd> I am a chemical engineer
11:01:15 <lyxia> :t (^.)
11:01:17 <lambdabot> s -> Getting a s a -> a
11:01:22 <lyxia> Definitely a lens thing.
11:01:50 <shapr> Ojd: I don't know anything about chemical engineering
11:02:35 <Ojd> so I can implement algorithms for energy balance or mass balance in whatever program I like (even excel, if you consider it as a VB program) and they don't care.. as long as the answer is correct
11:02:51 <erisco> it goes to show we do not reliably know why we do what we do despite feeling conviction
11:03:18 <shapr> Ojd: sounds like a case where you could end up with decently fast code that's easy to maintain
11:03:21 <geekosaur> yes, they got code for the lens interface to aeson
11:03:29 <cement> erisco: people are remarkably bad at self-evaluation
11:03:48 <shapr> cement: no I'm not! (thus proving your point)
11:04:14 <geekosaur> dunning-kruger to the left of me, impostor syndrome to the right...
11:04:18 <erisco> or that a person watching your brain activity can predict your thought before you know of it
11:04:20 <dsal> I wrote some code for my company years ago in ocaml because it was the only way I could reasonably think to solve a particular problem (it was mostly a java shop).  The ocaml code wrote a file that the java code read.  A year or so later, they needed a change to the code because they grew beyond the limits of the file format.  I wrote a doc describing the changes and told them I'd do the ocaml code.
11:04:27 <shapr> Ojd: if you get in far enough, you could use some of the libraries that make GPU calculations easier
11:04:41 <dsal> They couldn't figure out how to do the java parts and asked if I could do it (super simple hash and iterating an iterator).  I didn't feel bad about leaving them with ocaml after that.
11:04:44 <shapr> Ojd: or if you prefer making your own hardware, clash-lang compiles down to FPGAs
11:04:47 <peter___> https://pastebin.com/8fSuj5sM  
11:04:58 <peter___> regarding the variable not in scope (^.)
11:05:29 <cocreature> import Control.Lens ((^.))
11:05:56 <geekosaur> I suspect they didn't constain the Data.Aeson.Lens import originally, and got (^.) fromt here
11:06:19 <erisco> geekosaur, am I stuck in the middle with you?
11:06:23 <peter___> that was it. thank you
11:06:35 <geekosaur> erisco, everyone is, with those sides >>
11:06:53 <geekosaur> it's kinda the human condition
11:06:58 <cement> it's really weird for me since I consider myself a mediocre musician at best to realize that I'm somewhere in the 80th+ percentile for musicianship
11:07:02 <peter___> i don't know if this is unrealistic, but the stuff on the internet about lenses has not made sense to me.  How would you describe it?
11:07:21 <Ojd> well, still tons of things to learn before I can start thinking of efficiency and speed
11:07:38 <geekosaur> generics library for the masses, or record access library on steroids laced with a touch of acid >.>
11:07:38 <Ojd> just want to have a feel of applications made with Haskell
11:07:50 <dsal> I think aeson just requires more RAM to compile than this machine has.
11:08:00 <dsal> Are there any tricks to constrain compilation footprint?
11:08:03 <monochrom> One day a computer may pass the Turing test by simulating the imposter syndrome. XD
11:08:35 <cement> I'm holding out for someone to have a computer pass the reverse turing test
11:08:50 <cement> or was it turing test extra credit
11:08:52 <MarcelineVQ> where it puts a human in a small box?
11:09:01 <geekosaur> peter___, if you are using http://www.serpentine.com/wreq/tutorial.html then you missed the part at "A quick lens backgrounder" where they say they use lens *heavily* and then import it
11:09:09 <cement> nah, where it convinces the human that the human is the computer
11:09:13 <dsal> I think I've just reached the point of no return on this compile.
11:09:24 <erisco> anyways, my point is that despite my thinking that OOP took off merely because it was the most intuitive (make people feel the smartest), it could be wholly wrong
11:09:50 <MarcelineVQ> rational humans should already feel that way :>
11:10:03 <cement> people like heirarchies and categorization
11:10:10 <cement> and that's what OOP promises
11:10:17 <cement> content matters too
11:11:02 <peter___> geekosaur: ugh. egg on my face. i'll dig in there. thanks again
11:11:04 <erisco> it could be that we prefer alliterations "object oriented", or it could be something about the politics or the economy at the time, or it could be because key proponents had a certain personality
11:11:23 <dsal> Woah, I managed to abort it.
11:11:45 <cement> usually it's a mix, or a different thing for different people
11:12:26 <cement> shop A liked it because the boss likes heirarchies, shop B liked it because they liked proponent bob
11:12:32 <monochrom> dsal: GHC User's Guide section "RTS options to control the garbage collector" has memory flags.
11:13:10 <monochrom> Beware of GHC User's Guides you find on the web. They may mismatch the version you're using. Always read your local copy.
11:13:53 <Logio> OOP has the advantage that you can easily demonstrate the concept using cat examples, which instantly makes it popular on the internet
11:14:40 <monochrom> The "o.m()" notation is attractive to people who hate math.
11:14:54 <peter___> geekosour: in that tutorial, they run this in the ghci intepretor: :set -XOverloadedStrings
11:15:18 <mnoonan> Logio, but monads are burritos, and.. http://www.irenesinternet.com/wp-content/uploads/2012/01/BurritoCat.jpg
11:15:24 <monochrom> And the programmer community is full of math haters because those who like math have already become actuaries and quants and make more money.
11:15:32 <erisco> and the other point that we can create rationales for why things happened, but despite the sensibility of the rationale it does not make it true
11:15:54 <peter___> geekosour: if i'm running an hs script through cabal exec ghc, do i still need to set that OverloadedStrings flag in my env somehow?
11:16:27 <erisco> we can be biased to take an explanation, fill it in with a few examples that fit, and feel like it is true or probably true
11:16:43 <cement> confirmation bias
11:16:51 <erisco> it is a bit frightening how readily we do this to ourselves :P
11:17:02 <peter___> monochrom: Ha
11:17:22 <geekosaur> peter___, yes
11:17:34 <Unode> when a module is imported and re-exported, does this modify its type definition?
11:17:39 <geekosaur> cabal exec -- ghc -XOverloadedStrings ...
11:18:02 <geekosaur> or just add at the very top of the file:  {-# LANGUAGE OverloadedStrings #-}
11:18:18 <geekosaur> Unode, no
11:18:32 <Ojd> any other project that you recommend to check out in Haskell?
11:18:47 <peter___> geekosaur, i'll do the fancy comment, thanks!
11:19:04 <cement> xmonad is fairly popular, even outside the haskell community
11:19:05 <geekosaur> but when you import it via the re-exporting module, you still need to make sure you import everything needed (e.g. don't forget any constructors along with the type)
11:19:16 <geekosaur> it's a pragma, not a comment
11:19:23 <geekosaur> Haskell syntax is a bit ... precise
11:19:34 <maerwald> Ojd: I've written a boring file manager, maybe fix it :P 
11:19:41 <maerwald> there are probably 30+ issues on the tracker
11:19:42 <geekosaur> -- is a comment to end of line, --* is not (it's a user defined operator)
11:20:06 <maerwald> relatively small codebase
11:20:33 <cement> geekosaur: I didn't know that
11:20:50 <Unode> I'm seeing one case where the data type (newtype) is re-exported but not the data constructor. If I instead wanted to re-export only the data constructor, is this possible? if yes, what would be the syntax?
11:20:55 <geekosaur> {- starts a block comment, {-# starts a pragma, {-* actually appears to still be a comment but I'd distrust it as potential extension syntax
11:21:21 <Unode> {-| haddock also I think
11:21:29 <geekosaur> note that --- is still a comment (as long as it's *only* hyphens) and so is {---- (likewise)
11:21:48 <geekosaur> Unode, potentially unsafe. try --| as a haddock commentme
11:21:50 <geekosaur> er
11:21:57 <geekosaur> *comment sometime
11:22:01 <Unode> unsafe?
11:22:08 * geekosaur needs to replace this usb cable...
11:22:39 <cement> I remember when I didn't need n-key rollover
11:23:00 <geekosaur> Unode, because of Haskell's tendency to determine tokens based on character type transitions. like I said, --| is not a comment
11:23:05 <erisco> my cat appreciates n-key rollover
11:23:21 <geekosaur> given {-# I tend to treat it as potentiaal extension syntax
11:23:43 <geekosaur> cement, this isn't n-key rollover, just a bogus usb connector that keeps shifting and losing contact
11:24:09 <geekosaur> (at least I hope it's the cable end and not the keyboard end)
11:24:37 <geekosaur> I can tell because the charge light comes on briefly when it shifts
11:24:42 <cement> I know, I'm just making the observation that I don't have those problems because the PS/2 connectors are weirdly solid so long as you don't mess with the internal pins
11:24:55 <monochrom> PS/2!
11:25:12 <cement> might've messed up the name
11:25:24 <geekosaur> n-key rollover is something else
11:25:28 <monochrom> No, it's OK, it's just a bit yesteryear
11:25:38 <geekosaur> it's being able to press multiple keys simultaneously
11:25:48 <dsal> monochrom: Thanks for the pointers.  I think this may at least get me to machine-doesn't-crash-during-compile.
11:25:49 <monochrom> But not as yesteryear as what was before PS/2 :)
11:25:56 <geekosaur> gaming keyboards have it, most others don't because it complicates the keyboard hardware
11:26:18 <erisco> how else can I alpha strike if I can't mash all the attack buttons at once
11:26:30 <geekosaur> they can get away with scanning an x-y grid without rollover support
11:26:54 <cement> yes, and USB supports at most 15 simultaneous keys
11:26:58 <monochrom> Play the piano or the organ instead. :)
11:27:03 <Ojd> maerwald
11:27:03 <Ojd>  do you mind sending the link?
11:27:12 <erisco> monochrom, but analog, otherwise you have to worry about polyphony!
11:27:41 <maerwald> Ojd: https://git.io/v5Lu4
11:27:54 <cement> beh. I'd prefer a computerized keyboard for tuning reasons alone
11:28:10 <cement> at least you can make it do proper tuning
11:28:21 <monochrom> I have a Klavinova digital piano.
11:28:26 <Ojd> thanks
11:28:28 <erisco> monochrom, the entry level keyboard I bought has 128 polyphony
11:28:32 <cement> unlike that compromise that is standard piano tuning
11:28:49 <erisco> pretty important for playing sustained
11:29:23 <erisco> the keyboard I had about 15 years before that had, I think, 16 polyphony :P
11:29:41 <monochrom> Hmm I guess I see now why gaming keyboards have a higher price.
11:31:19 <cement> yeah, the one I have has a replaceable cord where I can hook up either a PS/2 or USB cable
11:31:32 <cement> and it wasn't even marketed as a gaming keyboard
11:31:45 <cement> it was marketed as a typist's(!) keyboard
11:32:00 <reactormonk> Is there a way to get a hold of Generic1 for HashMap?
11:32:05 <geekosaur> I can see that
11:32:46 <reactormonk> In the end, I want a Grouping1 instance for HashMap
11:33:00 <Ojd> maerwald a little bit outside my current knowledge but I will keep an eye on the issues list
11:33:35 <maerwald> Ojd: except for gtk, there is nothing really complex
11:33:58 <cement> something something dunning-kruger
11:35:05 <lyxia> reactormonk: what's Grouping1
11:35:18 <reactormonk> lyxia: Data.Discrimination from the discrimination package
11:36:20 <lyxia> reactormonk: how is it related to Generic1
11:37:04 <Ojd> cement, I am reading about the dunning-kruger effect, very interesting
11:37:30 <reactormonk> lyxia: it's got some code that allows me to derive said instance if I have a Generic1 lying around
11:37:47 <reactormonk> Writing it manually would also work, but I don't know how to do that
11:37:58 <cement> Ojd: I was aiming that more at the "nothing in this is really hard except..." comment
11:38:43 <cement> I find this website I'm remaking to be really easy, but the guy who assigned it to me feels beyond his depths
11:39:50 <cement> can you not just derive generic with the pragma, reactormonk
11:40:07 <reactormonk> cement: "data constructors not in scope"
11:40:25 <cement> you are importing Data.Generic, right?
11:40:35 <lyxia> Ah I see it's well hidden...
11:40:35 <erisco> cement, that's why they pay you the big bucks
11:41:12 <lyxia> reactormonk: but I don't think there is a sensible instance of Generic1 for HashMap
11:41:17 <Ojd> well, made me think about my own judgement... kind of scary too
11:42:12 <maerwald> cement: can you be more specific at what you were aiming at?
11:42:16 <geekosaur> HashMap deliberately hides its data constructors in order to maintain invariants, just like Data.Map does
11:43:17 <cement> maerwald: in general I was making the observation that everyone perceives different things to be difficult, and others to be easy
11:43:29 <maerwald> cement: complexity can be measured
11:44:00 <maerwald> I was referring to complexity, not difficulty
11:44:16 <reactormonk> lyxia: ok, gotta figure out how to use hashing https://hackage.haskell.org/package/discrimination-0.2.1/docs/Data-Discrimination-Grouping.html#v:hashing to define a Grouping1 in that case
11:44:29 <cement> just because mergesort has O(n log n) doesn't mean that it's easy for everyone to grasp how it works
11:44:38 <maerwald> cement: I meant complexity API-wise
11:44:48 <maerwald> (entry points, state, ...)
11:45:17 <maerwald> so gtk usually takes a "while" to get into (even if someone perceives it as easy)
11:45:21 <maerwald> the rest is not complex
11:45:42 <cement> I didn't read the actual library/api/app, so I can't speak much further
11:46:11 <maerwald> that's why I didn't see the correlation of your comment to what was said
11:46:54 <cement> he said that some parts of it were beyond him for now, and you said that except for a specific thing, it should be really easy
11:47:03 <cement> I was pointing out that difficulty is relative
11:47:04 <maerwald> no, I didn't
11:47:25 <cement> ah, "complex"
11:47:39 <maerwald> and he was talking about his knowledge, not his intellectual capacity
11:47:49 <maerwald> so I pointed out what is complext (as in: requires knowledge)
11:48:53 <monochrom> These distinctions or non-distinctions are beyond my intellectual capacity.
11:49:16 * maerwald must resist that joke
11:49:27 <erisco> where's Reggie Watts? he can clear this up for us
11:49:28 <maerwald> I know it's a trap :P
11:49:34 <cement> I concede the point, though I do admit I am thinking we're arguing parallel to each other
11:52:36 * hackagebot hobbits 1.2.4 – A library for canonically representing terms with binding – https://hackage.haskell.org/package/hobbits
11:52:55 <monochrom> Hmm why is it called hobbits?
11:53:34 <MarcelineVQ> gebrids sounded too strange
11:54:25 <monochrom> Sorry, what is gebrids?
11:55:02 <MarcelineVQ> I've no idea, but it sounds strange doesn't it?
11:55:25 <monochrom> Yes.
11:56:50 <MarcelineVQ> maybe that's what I'll call my first useful library, with a cryptic message in the readme "It turns out that hobbit is kind of weird sounding as well."
11:59:11 <monochrom> The place where Hobbits live, do you call it a hobbitat? :)
11:59:53 <dsal> Hobbit gentrification == Hobbitat for Humanity
12:00:20 <reactormonk> Trying to create said Grouping1 instance by hand - almost there https://gist.github.com/reactormonk/1d0e15ad7a72cb28c9f2a3700787143a
12:00:25 <cement> what is with programmers and puns
12:00:45 <dsal> We like playing with language.
12:00:53 <cement> fair
12:01:09 <MarcelineVQ> what is it with ravens and writing desks
12:01:10 <reactormonk> Not entierly sure where the b0 comes from
12:01:28 <monochrom> Those who can make real jokes have become real comedians and make more money...
12:01:53 <cement> there are real jokes in language that aren't puns
12:02:08 <cement> eg. English Orthography
12:02:42 <monochrom> I agree. But like I said.
12:04:11 <geekosaur> reactormonk, it can't unify some type
12:04:50 <geekosaur> but, more fundamentally, you have a list of values where a single tuple is expected. (I am assuming Item is a type family that will resolve to a tuple)
12:05:14 <reactormonk> makes sense.
12:07:24 <reactormonk> How would I apply the `divide` etc. to the whole list?
12:07:50 <geekosaur> yes, just found the definition of Item, that's not the problem. it's list vs. single that is the problem
12:11:03 <geekosaur> I... have no idea :/
12:20:08 <Tuplanolla> Left seminearrings have `x * (y + z) = x * y + x * z`, but do they have `0 * x = 0` or `x * 0 = 0`? Different sources seem to disagree.
12:20:39 <reactormonk> geekosaur: got it to compile \o/ had to insert a `grouping1`
12:21:17 * ski would assume `x * 0 = 0', for consistency
12:21:28 <dsal> Hmm...  My RTS flags don't show up anywhere on the ghc commandline when building packages.  That's... good?
12:22:18 <ski> (so that `x * sum xs = sum (map (x *) xs)')
12:22:33 <geekosaur> dsal, maybe. what exactly are you doing?
12:22:37 <Tuplanolla> It's just suspicious that `x * 0 = 0` is called right-absorption via a right zero, ski.
12:23:00 <dsal> geekosaur: I've got some dependencies... one of them is aeson.  aeson requires ~1GB or so of RAM to compile.  I don't have that much RAM.  Trying to give it a -M
12:23:26 <geekosaur> dsal, let me rephrase that. please show the *exact* command line you are using to build
12:24:11 <dsal> geekosaur: http://lpaste.net/5568100120563548160 <-- 'stack test'
12:24:32 <dsal> ghc-options don't seem to apply to dependencies.
12:24:40 <iomotoko> "Haskell does not permit the same name to be used for more than one argument in a single equation" - don't get that tbh, can any1 explain?
12:25:21 <geekosaur> iomotoko, "foo x x = ..." is not legal
12:25:31 <cement> beat me to it
12:25:43 <dsal> That's unfortunate.  It's useful in erlang!  :)
12:26:09 <geekosaur> dsal, no, it applies to stuff built by your cabal file, not dependencies
12:26:19 <geekosaur> you *may* want to put that in the environment instead
12:26:23 <cement> one of these days I'm gonna need to learn erlang
12:26:53 <lyxia> dsal: Maybe there's a section to add in stack.yaml
12:27:12 <dsal> Anyone know how to do this offhand?
12:27:26 <geekosaur> export GHCRTS=-M256m
12:27:41 <dsal> The watchdog on this machine also doesn't work, and it doesn't OOM correctly, so like, I have to walk upstairs when this fails.  heh
12:27:42 <dsal> thanks.
12:28:21 <iomotoko> geekosaur: but why?
12:28:36 <dsal> stack: Most RTS options are disabled. Link with -rtsopts to enable them.
12:28:55 <geekosaur> dsal, you can ignore that because youd on;t care about stack
12:29:07 <lyxia> dsal: https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-options https://docs.haskellstack.org/en/stable/yaml_configuration/#apply-ghc-options
12:29:09 <geekosaur> and there's no way to tell $GHCRTS to only apply to ghc vs. *any* Haskell program
12:29:09 <dsal> It just doesn't start.
12:29:23 <geekosaur> er. :/
12:29:41 <hexagoxel> dsal: if ghc uses 1gb to compile aeson, it is pretty likely that it _needs_ 1gb. you may want to pass -O1 when compiling aeson instead.
12:30:04 <peter___> asdf
12:30:13 <dsal> A future approach is to not use aeson since I don't need most of it...
12:30:29 <hexagoxel> (there is an open ticket to remove the -O2 from the package..)
12:31:00 <peter___> any suggestions for casting [Char] to a ‘Data.Text.Internal.Text’
12:31:11 <peter___> or vice versa
12:31:19 <lyxia> aeson is already at -O0 by default
12:31:21 <shapr> pack
12:31:22 <hexagoxel> (i have not checked how much ram it uses on -O1, so no promises.)
12:31:34 <byorgey> peter___: Data.Text.pack and unpack
12:31:44 <peter___> thank you
12:31:52 <dsal> Hmm...  Still doesn't pass the RTS options.  I guess I'll get rid of aeson...
12:32:52 * hackagebot dotenv 0.5.0.0 – Loads environment variables from dotenv files – https://hackage.haskell.org/package/dotenv
12:33:54 <iomotoko> geekosaur: ah I guess it's just to avoid an ambigous situation?
12:34:11 <geekosaur> iomotoko, there's somewhere a discussion about linear patterns
12:34:20 <geekosaur> non-linear patterns have some nasty edge cases
12:34:47 <iomotoko> geekosaur: for example in haskell a condition expression always has an else branch, this avoids dangling else problem
12:35:02 <geekosaur> dsal, there is no way to propagate ghc options to a different package with its own cabal file
12:35:10 <iomotoko> geekosaur: same w/ haskell not permitting same name for more than one argument in single equation, this avoids ambigous equations
12:35:20 <iomotoko> I guess
12:35:40 <iomotoko> like 
12:35:46 <geekosaur> https://stackoverflow.com/questions/35891663/what-are-nonlinear-patterns
12:36:03 <geekosaur> see at "As to why Haskell doesn't have"...
12:36:51 <iomotoko> geekosaur: yep, just read it
12:36:53 <iomotoko> :)
12:36:53 <geekosaur> http://code.haskell.org/~dons/haskell-1990-2000/msg04005.html more information
12:37:00 <iomotoko> so yeah, it's not a strict requirement or such
12:37:05 <iomotoko> it's a design choice on haskell's part
12:37:19 <iomotoko> that's basically what I wanted to know
12:37:22 <geekosaur> pretty much, yes
12:37:34 <iomotoko> geekosaur: thanks :)
12:37:51 <geekosaur> I think there's discussion in the ghc wiki about how it would complicate pattern matching for very little return
12:38:06 <MarcelineVQ> dsal: have you tried building just aeson or just its dependencies?  you can build the version your project needs by writing, in your project's root,  stack build aeson
12:38:29 <MarcelineVQ> if it gives you a list of dependencies it's going to have to build, you can do the same thing for them first to reduce overall load
12:55:10 <dsal> Yeah, it's still just about 1GB of RAM.  I need almost none of aeson, but it's blocking me from building, so I should just not use it.
13:06:51 <thoughtpolice> geekosaur: Actually, you can do that now with new-build in Cabal 2.0+. You can specify dependencies your cabal.project are compiled with overridden options. These options are incorporated into the hash of the pkg identifier, so changing the options changes the hash and implies rebuilds. It's quite useful in some cases.
13:07:43 <MarcelineVQ> dsal: did you see what I said?
13:08:07 <thoughtpolice> geekosaur: http://cabal.readthedocs.io/en/latest/nix-local-build.html#package-configuration-options as an example
13:08:15 <dsal> MarcelineVQ: Yeah, I tried building it on my laptop, only built aeson, but took 1023MB of RAM.
13:08:40 <MarcelineVQ> after building the dependencies yourself, or they were built already, it's still 1G to build aeson?
13:09:42 <monochrom> Hmm aeson eh, let me try too.
13:09:49 <dsal> I don't see any dependencies.  I deleted just the aeson bits from ~/.stack and built that.
13:09:57 <hexagoxel> dsal: just tested building just aeson, and with flags it succeeded it in 550M
13:10:07 <monochrom> First let me close Chrome just in case I need that much RAM :)
13:10:18 <dsal> hexagoxel: Hmm.... How did you get the flags to it?
13:10:50 <hexagoxel> cabal build (sorry, won't help you :D)
13:11:18 <monochrom> Oh yeah there are a lot of other things aeson depends on, such as text, that could take some RAM last time I tried.
13:11:19 <hexagoxel> as i said, i built _just_ aeson, so i unpacked and passed --ghc-options.
13:11:29 <dsal> Ah.  Yeah, stack build has a --ghc-options flag, but it just errors if you try to use it.
13:11:47 <Chobbes> Has anybody used gnuplot for Haskell? https://hackage.haskell.org/package/gnuplot-0.5.4.2/docs/Graphics-Gnuplot-Simple.html I assume the Palette attribute is how you would change the colour of the graph, but I'm not sure what all of the doubles are for?
13:11:54 <hexagoxel> lyxia linked to the proper approach above, i think.
13:12:17 <monochrom> I shall close Thunderbird too. This is a rough ride.
13:12:52 <hexagoxel> the flags i used were "+RTS -M400M -O1 -RTS". and i have to admit, the -M part _did_ matter.
13:13:54 <hexagoxel> it is a bit sad that when you say "-M400M", ghc itself reports that it used 450MB, and external observation reports it used 550..
13:16:11 <monochrom> Oh if there is parallelization you will also need more RAM because two GHCs are running together.
13:16:23 <monochrom> Even four.
13:17:15 <hexagoxel> good point. stack has -j as well to prevent that, i guess (?)
13:17:21 <hexagoxel> -j1 that is
13:17:23 <monochrom> Heh vector and text are in parallel and each takes 4xxMB
13:25:44 <MarcelineVQ> "<dsal> Ah.  Yeah, stack build has a --ghc-options flag, but it just errors if you try to use it." there's no reason for it to error, you should elaborate on that
13:26:04 <MarcelineVQ> it may not pass those flags onto a depdendency, they're for the project, but it shouldn't error
13:26:12 <dsal> $ stack build aeson --ghc-options +RTS -M256m -RTS
13:26:13 <dsal> stack: Most RTS options are disabled. Link with -rtsopts to enable them.
13:26:50 <dsal> Though now that I look at that, that may not have been interpreted the way I wanted.
13:28:04 <geekosaur> it wasn't
13:28:16 <geekosaur> stack build aeson --RTS --ghc-options +RTS -M256m -RTS
13:29:43 <dsal> I tried quoting the options.  They're not going through to compilation, though.
13:30:37 <geekosaur> no, quoting wont work, it only affects the shell not stack
13:30:43 <geekosaur> try what I typed
13:31:00 <dsal> Your suggestion gave me  Invalid option `-M256m'
13:31:22 <geekosaur> oh, extra quoting there, yes
13:31:27 <geekosaur> stack build aeson --RTS --ghc-options "+RTS -M256m -RTS"
13:32:19 <dsal> Yeah, I don't see the options coming through.
13:34:18 <MarcelineVQ> they probably aren't, you're building something from the resolver so it likely has default settings it builds with, it certainly has flags preset/locked-in, so it wouldn't surprise me if ghc-options aren't changeable
13:34:51 <dsal> I'm going to try to do my job for a bit, and then just get rid of the aeson dependency.
13:34:57 <MarcelineVQ> you can unpack it like hexagoxel did though
13:35:49 <Taneb> Has anyone done better implementing the indexed tardis monad better than I have?
13:36:35 <monochrom> Escape codes and quotes piled higher and deeper. >_<
13:36:56 <Taneb> I'm using newtype ITardis bw fw i j a = ITardis {runITardis :: (bw j, fw i) -> (a, (bw i, fw j))}
13:37:27 <monochrom> Can Command Lines Be Liberated From The Plain Text Files?
13:37:28 <dsal> Tardis sounds like something that would solve my problem.
13:37:35 <Taneb> But implementing (and using) putForwards/putBackwards is awkward because you can't change the index
13:37:49 <Taneb> dsal, honestly it almost never is
13:37:57 <Taneb> It normally gets you into problems, if I remember my Doctor Who
13:38:10 <dsal> heh.  I could just use more space.
13:39:00 <Taneb> dsal, as an aside, tardis is actually pretty cool: https://github.com/DanBurton/tardis
13:41:02 <reactormonk> Is there a fold for non-empty lists that only requires a semigroup?
13:43:30 <Taneb> reactormonk, there used to be but I can't seem to find it
13:45:18 <Taneb> reactormonk, found it! It's in the semigroupods library
13:45:19 <Taneb> http://hackage.haskell.org/package/semigroupoids-5.2.1/docs/Data-Semigroup-Foldable.html
13:47:42 <jle`> reactormonk: it should be in base
13:48:03 <jle`> reactormonk: yes it is indeed in base
13:48:25 <jle`> oh, do you mean the 'fold' function specifically?
13:48:54 <jle`> does 'sconcat' in base do what you need? http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Semigroup.html
13:53:40 <kamyar> How can I call a C++ dynamic Lib (So,dylib...) ? It has some hpp files with structs. How can I define them in Haskell?
13:55:55 <geekosaur> in general you can't, unless it has extern "C" hooks
13:55:58 <monochrom> My knowledge is you create a C interface (extern "C" { ... }) and call that from Haskell.
13:56:47 <monochrom> As for dylib, you do the normal dylib thing.
13:57:16 <geekosaur> (this is not a Haskell limitation; it applies to almost all languages. while specific platform specs are encouraged to define interoperability between C++ implementations, not all do and not all implementations pay attention to such)
13:57:19 <kamyar> Is this doc still valid? https://wiki.haskell.org/CPlusPlus_from_Haskell
13:58:04 <geekosaur> nope
13:58:10 <geekosaur> "My kdelibs is version 3.3.2 and was compiled with the g++ 3.x compiler. I think the name mangling scheme changed with g++ 4.0, so if you are using that version you will have to figure out the new mangled names."
13:58:21 <geekosaur> but it's worse than that; calling conventions changed with C++11
13:58:38 <monochrom> Wait, Haskell 2010 has cplusplus?!
13:59:00 <geekosaur> the original FFI listed it as a possibility; as that page says, it was never actually implemented
13:59:00 <monochrom> At any rate it's at the same status as jvm and dotnet, i.e., unimplemented.
13:59:10 <geekosaur> mostly because there is no reliable standard for C++ direct interop
14:00:09 <geekosaur> the C++11 calling convention on x86/x86_64 has been reverse engineered and could be implemented, which would give g++ and clang++ interop. but not msvc, which doesn't follow the common platform spec.
14:00:29 <geekosaur> and ARM is different again (multiply so since there are multiple ARM ABIs), etc.
14:00:48 <kamyar> geekosaur: I do not want M$/Windows! I just wanna use OSRM lib on mac/bsd
14:01:04 <kamyar> My platform is x86/64
14:01:15 <geekosaur> it si still not implemented for Haskell
14:01:28 <monochrom> M$ and MA€
14:01:58 <geekosaur> in fact the only langauge I know of to support C++ direct interop on x86 is rakudo's NativeCall
14:02:23 <kamyar> monochrom: Mac open seourced Darwin years ago! It is not Ma€
14:02:30 <geekosaur> and then re-closed it
14:02:55 <kamyar> geekosaur: Not true! D language does it very good!
14:02:56 <geekosaur> ..and even if it were implemented, it would have limitations. like, you have to actually compile C++ code to instantiate templates, you cannot simply dynamic link to one that was not already instantiated
14:03:53 <monochrom> Ideological people see the few hundred dollars charged by others and not the thousands of dollars charged by themselves.
14:04:21 <monochrom> MS only really became M$ when M$ Surface Pro tried to be more expensive than MacBook Pro.
14:05:57 <kamyar> monochrom: I do not paid any! I use Hackintosh on my PC! for about 10 years! I like darwin!
14:08:14 <lorenzo1> Hey guys
14:10:58 <monochrom> http://www.stickycomics.com/computer-update/
14:12:56 <lorenzo1> Guys is there a chance some of you took the cis194 course from upenn? If so, didn't you found it really hard? Or am I just too dumb for haskell?
14:13:29 <monochrom> Some are hard, some are easy.
14:13:48 <monochrom> And the rest are just you overthinking.
14:16:14 <lorenzo1> Yeah could be but f**k... I really could not wrap my head around it and I tried HARD... 
14:39:29 <peter___> hello
14:39:33 <peter___> i have a design question
14:39:43 <peter___> i have a list
14:39:48 <peter___> and, for each element in the list
14:39:52 <peter___> i want to make an api call
14:40:12 <peter___> my intuition is to push the list through a function via map
14:40:23 <peter___> and do the api call in the function
14:40:31 <peter___> which makes it an impure function
14:41:05 <peter___> so i'm getting an object ( a record type ) that i made: Obj
14:41:16 <peter___> and i'm returning a new, updated version of that OBj
14:41:22 <erisco> probably  forM xs f
14:41:30 <monochrom> Or forM_
14:41:38 <erisco> or mapM, or mapM_
14:41:41 <peter___> so my signature is:  apiCall :: Obj -> Obj
14:41:58 <peter___> but it has to be impure so i understand i need to put IO in there somewhere?
14:42:04 <peter___> or am i thinking about this wrong?
14:42:41 <erisco> no, you have it right, and so probably apiCall :: Obj -> IO Obj
14:42:52 <peter___> ahhhh
14:43:15 <monochrom> Obj -> IO Obj?  But I can never be sure. "api call" is informationless.
14:45:16 <monochrom> At this point probably even you don't have the necessary information.
14:45:45 <monochrom> Because clearly you don't have actual code for "api call".
14:46:13 <monochrom> Because if you had, your compiler would already tell you its type, or tell you you have a type error.
14:46:20 <peter___> i do
14:46:36 <monochrom> OK, so what does the compiler say its type is?>
14:46:59 <peter___> i'll put it on paste bin
14:51:57 <boristheblade> clear
14:52:12 <monochrom> All clear.
14:52:20 <tushigushi> sorry
14:52:49 <monochrom> (Did it work? Is the heart beating now?)
14:53:23 <boristheblade> it's alive!
14:53:29 <monochrom> OK good.
14:54:04 <peter___> pasted at
14:54:05 <peter___> https://pastebin.com/3MhW6v4q
14:54:15 <monochrom> Aw pastebin.com
14:54:34 <erisco> he did say he would put it on paste bin
14:55:44 <monochrom> What is the type of "get"?
14:55:57 <monochrom> Especially in "get preppedUrl"
14:56:23 <monochrom> Does this code compile?
14:56:41 <peter___> scroll down to see the compile error
14:57:33 <peter___> it r <- get preppedUrl is the wreq library
14:57:40 <peter___> that all works
14:57:59 <peter___> if i put it in main
14:58:26 <monochrom> OK so you need to learn about forM or mapM.
14:59:41 <peter___> ok, i'll dig on those. can you give me a very high level " the difference between map and mapm is ... "
15:00:37 <monochrom> No.
15:00:55 <peter___> haha..  i'll get to digging. THanks for pointing me in the right direction
15:00:57 <erisco> do you know sequence?
15:01:06 <peter___> i do not
15:01:15 <peter___> this is day 1 of haskell for me
15:01:22 <erisco> do you know >>= ?
15:01:34 <peter___> no
15:01:55 <peter___> but i'll put those two things on my list
15:02:06 <erisco> have you read any of the free Haskell books?
15:03:17 <peter___> learn you a haskell
15:05:08 <erisco> where did you stop?
15:06:10 <Logio> peter___: in LYAH terms, the difference between map and mapM seems to be about 6 chapters
15:06:19 <monochrom> Haha.
15:06:38 <peter___> i'm up to the 10th chapter, haven't gottent to the monad parts yet.. felt like i was ready to build something to make it real
15:07:18 <peter___> but i am at the point where i need to finish the book. this has all been very helpful though, thanks everybody
15:08:04 <erisco> I recommend to keep reading because if you want use IO it will help to know Monad
15:08:38 <peter___> will do :)
15:09:59 <erisco> I can tell you that mapM xs f is, loosely speaking, do f at each element of xs in order
15:10:08 <sm> peter___: you might like https://leanpub.com/haskell-cookbook , it's quicker
15:10:58 <erisco> :t mapM
15:11:00 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
15:11:03 <erisco> okay, it is mapM f xs
15:12:38 <erisco> this tends to trip people up... they want to do something in Haskell to get a feel for it but they want that something to be related to IO
15:14:35 <erisco> this is easier in languages where effects are much more laissez-faire
15:15:14 <erisco> in Haskell there are extra rules you have to learn to use them
15:15:39 <erisco> so, easier for beginning is to choose projects which do not involve IO, which is why examples are things like the fib function
15:17:03 <erisco> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems is a source of ideas though most are more mathy than anything
15:17:15 <erisco> still you might pluck out some interesting one
15:20:29 <erisco> programs can do more than shuffle files and download web pages, you know
15:26:10 <platz> would one prefer an http-client Manager to be bundled in a "config" record, or passed as a separate argument to a call to dispatch the request
15:32:22 <monochrom> erisco: But quantum computers cannot do more than shuffle qubits and measure them. :)
15:34:12 <erisco> monochrom, but Mr. Babbage, you can use these qubits to represent other objects!
15:35:18 <monochrom> And can I still get the right answer with the wrong qubits and/or the wrong unitary map. :)
15:35:40 <Tuplanolla> I can't tell #haskell from #haskell-offtopic.
15:36:11 <erisco> the waveform will collapse soon enough
15:36:25 <monochrom> You can use population count to tell. The ratio is about 50 : 1.
15:36:48 <monochrom> Err, 200 : 1. I can't do math.
15:37:09 <Tuplanolla> They both have more-than-fits-on-the-screen users.
15:37:48 <erisco> just extend the size of your monitor through time
15:37:59 <monochrom> This is what's wrong with "data N = Z | S N". For all you know, most values are more than fits on the screen.
15:39:09 <monochrom> If anything you should go for a binary tree representation.
15:39:37 <monochrom> This is why dependent type programming will not be practical soon.
15:39:49 <jle`> soon? :p
15:40:28 <erisco> are you acquiescing from "ever"?
15:41:02 <monochrom> I am too chicken to predict far into the future.
15:41:07 <jle`> was going to suggest "now"
15:41:26 <jle`> oh, you meant 'any time soon'
16:00:20 <wedify> so i'm trying to write a fps bot. i'm using ffmpeg to capture the screen into a movie file, using ffmpeg again to transform the movie into images. i then load up each of the images using juicy pixels. xdotool is used to send input between my bot and the game. pretty inefficient huh? is there a better way?
16:01:29 <erisco> you can intercept draw calls and use the geometry and textures instead
16:02:24 <wedify> erisco: more info?
16:03:09 <erisco> all I have for you is that that is possible. I do not know graphics programming well enough
16:04:51 <wedify> yeah i don't know graphics programming well enough either. guess i'll just see how far i get
16:06:15 <erisco> wedify, https://github.com/dtrebilco/glintercept
16:06:24 <erisco> that was easy for me to find. I am sure you can search for more options.
16:07:03 <erisco> it looks like it is based on dll injection, which is a common technique
16:09:02 <remexre> I'm having trouble adding a Git dependency to my stack.yaml file; I'm trying this syntax: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#git-and-mercurial-repos but getting Error in $['extra-deps']: failed to parse field 'extra-deps': expected [a], encountered Object
16:09:12 <erisco> also, depending on your game, there may already be specific libraries that can help you
16:09:42 <erisco> I know that existed for StarCraft Broodwar, so undoubtedly exists for other games
16:09:50 <remexre> erm, actually, `Error in $['extra-deps'][0]: failed to parse field 'extra-deps': expected PackageIdentifier, encountered Object`, the other one was from an older screw-up
16:12:58 <erisco> wedify, barring that I would look for some video streaming library for Haskell
16:14:25 <erisco> and if you don't have enough processing juice then try external capture and running the bot on another system
16:14:32 <sm> wedify: sounds fun
16:15:32 * hackagebot haskey 0.1.0.0 – A transcatoinal, ACID compliant, embeddable key-value store. – https://hackage.haskell.org/package/haskey
16:16:04 <sm> I was trying to write a 2d flyer bot in https://www.codingame.com/multiplayer/bot-programming/coders-strike-back , which was hard enough for me
16:16:31 <sm> game bots seem a great way to learn
16:39:56 <ab9rf> "transcatoinal"?
16:45:28 <Rotaerk> ab9rf, it's like transactional but exotic
16:48:43 <ab9rf> i've learned not to assume that an apparent misspelled word is actually a misspelling; i have a friend who does computational linguistics and writes papers with words like "binominal" in the title
16:49:47 <benzrf> lol
16:50:00 <benzrf> it took me like 20 seconds to notice that you didnt write binomial
16:50:45 <ab9rf> benzrf: that word is a test of whether you are a computational linguistics researcher :)
16:51:00 <dmwit> "shibboleth"
16:51:02 <ab9rf> benzrf: virtually everyone who isn't will read it as "bionomial" on first glance
16:51:13 <benzrf> ab9rf: what about people who dont know either word?
16:51:22 <ab9rf> benzrf: nobody cares :)
16:51:54 <ab9rf> benzrf: people who don't know what binomials are don't generally encounter papers that talk about things that are binominal
16:52:50 <dmwit> Ah, yes, having your eyes scan the letter sequence "binominal" is already strong evidence that you are a computational linguistics researcher.
16:53:18 <ab9rf> dmwit: or at least friends with someone who is
16:53:30 <dmwit> oh no, maybe it's contagious
16:53:33 <benzrf> how bayesian
16:53:35 <benzrf> probably
16:53:52 <ab9rf> i dunno, my degree is in political science :)
16:54:02 <dmwit> and yet here you are in #haskell
16:54:32 <ab9rf> well, i had both math and cs minors in there somewhere
16:54:41 <ab9rf> i have a weird degree
16:55:17 <johnw> maybe you're the One we've needed to settled the great editor disputes
16:55:40 <ab9rf> johnw: nah, all i can do is tell you why you won't be able to use an election to settle it :)
17:01:54 <koz_> Argh ST, why u interact so bad with type inference.
17:05:47 <koz_> Could someone suggest how I could reverse the bits in a Word8 in Haskell elegantly?
17:06:00 <koz_> All the algorithms I've seen are for 32-bit quantities, which is excessive for what I need.
17:13:45 <dsal> Argh.  I need a String instance and a [t] instance.  Is there a sensible way to accomplish this?
17:15:15 <pacak> String instance? O_o
17:15:51 <dsal> instance X String
17:16:04 <koz_> dsal: Do you mean IsString?
17:16:06 <dsal> FlexibleTypes gets me that, but then I also need it for other, non-String things.
17:16:40 <dsal> No, I'm just doing the least viable json encoder.  I've got arbitrary lists of things that can JSON themselves, but I can't express that String is slightly special.
17:17:03 <pacak> String is [Char]
17:17:19 <pacak> But when doing instance resolution ghc will look at [t] first.
17:17:33 <pacak> dsal: So it's not going to work.
17:17:34 <dsal> Is there a way to convince it to do something special with String?
17:17:42 <pacak> dsal: Newtype.
17:17:42 <AlainODea> I'm trying to refactor this verbose conduit code I wrote for taking every second line from each 4 line record group into something concise and readable. Any advice? http://lpaste.net/357926 
17:18:34 <dsal> Well, I mean without requiring code to use my special thing.  There's clearly some magic somewhere in aeson that does it...
17:18:45 <pacak> AlainODea: MaybeT?
17:19:19 <AlainODea> pacak: interesting. That would be a good a good option. I'll give that a shot
17:25:38 <koz_> Is there a way I can get GHCI to print hex?
17:25:46 <koz_> (yes, I'm bit twiddling in Haskell, sue me)
17:26:50 <Tuplanolla> If you had read the documentation, you would have found `toJSONList`, dsal.
17:27:37 <pacak> > (printf "%x" 12345) :: String
17:27:39 <lambdabot>  "3039"
17:28:43 <dsal> Tuplanolla: Possibly.  It's not intuitive to me that I'd need to read the aeson API documentation to understand a thing about how to to use classes in haskell.
17:29:01 <koz_> pacak: Ah, thanks!
17:29:24 <Tuplanolla> The exact same concept is used with `showList`, dsal.
17:29:38 <koz_> pacak: Where does printf live?
17:30:22 <pacak> @hoogle printf
17:30:22 <lambdabot> Text.Printf printf :: (PrintfType r) => String -> r
17:30:22 <lambdabot> Turtle.Format printf :: MonadIO io => Format (io ()) r -> r
17:30:22 <lambdabot> Data.Conduit.Shell.PATH printf :: ProcessType r => r
17:32:06 <geekosaur> the Numeric module also has showHex or sth
17:32:11 <geekosaur> @index showHex
17:32:11 <lambdabot> Numeric
17:32:20 <geekosaur> :t showHex
17:32:21 <lambdabot> (Show a, Integral a) => a -> ShowS
17:32:24 <dsal> TIL of showList
17:32:28 <koz_> geekosaur: Thanks - just found it.
17:52:39 <dsal> Well, my JSON encoder benchmarks a lot faster than aeson, and it's a lot smaller.  I'm not sure if it's just like, wrong or what, but I'll take it, I guess.
17:54:59 <AlainODea> pacak: MaybeT made a big difference, but I still have some awkward case statements. Are they removable? http://lpaste.net/357926http://lpaste.net/357926
17:56:51 <pacak> AlainODea: Add type signature for loop plox.
17:58:35 <AlainODea> pacak: I'll give that a try
17:59:17 <pacak> Just add a type signature - I don't want to figure out types myself.
18:00:05 <pacak> AlainODea: Also what is x on line 3?
18:02:52 <AlainODea> pacak: the x on line 3 is a clumsy workaround for loop returning a Maybe Text
18:03:48 <pacak> AlainODea: Are you sure? Both branches of case must be of the same type. If line 5 is correct then x is () and whole case expression is pointless.
18:05:23 <AlainODea> good point. It's a little surprising that that case expression type checks
18:06:06 <pacak> That's why - add type signatures.
18:06:54 <pacak> And test if it actually works.
18:08:00 <AlainODea>  Looks like loop :: Monad m => ConduitM Text Text m (Maybe ())
18:09:45 <pacak> What kind of info `Maybe ()` contains in your cse?
18:10:50 <AlainODea> Nothing useful. The Conduit effects (particularly yield'ed values) are what matters for me here.
18:12:08 <AlainODea> Ideally I could discard the values, but still ensure avoid non-terminating (which is what I had before I put the case statement on  lines 14-16)
18:12:33 <AlainODea> ensure is impossible. I mean avoid. I'm not solving the halting problem :p
18:16:20 <pacak> AlainODea: Do you ever define variables with names other than x?
18:16:54 <AlainODea> In real code yes. I'm just messing around with a script. I'll fix the variable names :)
18:17:41 <ab9rf> AlainODea: you say that, but do you actually ever DO it? :)
18:18:27 * AlainODea applies water to wicked burn :)
18:19:09 <AlainODea> pacak: thank you for your help. Gotta jet. I will name my variables :)
18:19:33 <pacak> Have fun. Proper names are really useful.
18:19:48 <pacak> And type signatures for all the functions.
18:20:02 <mnoonan_> is there a way to test if two values are the-same-location-in-memory identical? I want to write some tests that my library isn’t making copies when applying newtype wrapping/unwrapping.
18:20:40 <geekosaur> reallyUnsafePtrEq# --- the name means what it says
18:20:57 <mnoonan_> geekosaur: nice, thanks. that sounds like the kind of name I would expect it to have :)
18:21:38 <geekosaur> but I'mnot sure where it lives
18:21:45 <pacak> mnoonan_: reallyUnsafePtrEquality#
18:21:58 <pacak> GHC.Exts
18:22:17 <pacak> but the name is a bit misleading.
18:22:41 <mnoonan_> pacak: in what sense?
18:22:45 <pacak> It's really-we-mean-it-this-function-will-eat-your-cat-and-burn-your-house-PtrEquality#
18:22:54 <ab9rf> hehe
18:23:05 <geekosaur> oh, did I truncate it :/
18:23:10 <ab9rf> mnoonan_: why do you want to do this?
18:23:16 <pacak> ab9rf: Performance.
18:23:25 <ab9rf> ah, i see
18:23:56 <ab9rf> you are deliberately lifting the hood :)
18:23:57 <koz_> I keep thinking Haskells bitwise or looks like the code is flipping you off.
18:24:35 <mnoonan_> ab9rf: in https://github.com/matt-noonan/justified-containers, there are various types that are just newtypes + a phantom parameter, and I want to write tests to check that no copies are created
18:25:09 <mnoonan_> byorgey had a comment earlier today about mapping a newtype unwrapper possibly having a non-zero cost, which got me thinking about it.
18:25:18 <geekosaur> well, no, it's not quite accursedUnutterable bad
18:25:18 <mnoonan_> i suspect i need to throw some “coerce”s into the mix
18:25:20 <geekosaur> usually
18:25:41 <geekosaur> but gc a the wrong time could make you unhappy
18:25:41 <geekosaur> *gc at the
18:25:47 <mniip> the problem with reallyUnsafePtrEquality# is
18:25:52 <mniip> well,
18:25:59 <mniip> ignoring false negatives,
18:26:08 <mniip> the problem is there's now false positives
18:26:28 <pacak> Due to GC and tags in pointers
18:26:38 <mnoonan_> mniip: object X replacing object Y at the same address after a gc?
18:26:47 <mniip> yes
18:27:55 <mniip> do note that this doesn't require X or Y to be unreferenced
19:12:00 <mnoonan_> relating to my previous question.. I haven’t been able to google up a way to reliably avoid running the GC during evaluation of a certain expression. is it possible?
19:23:04 * hackagebot gnss-converters 0.3.13 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
19:29:39 <remexre> Hey, has the syntax for Git extra-deps in Stack changed recently?
19:33:48 <nitrix> mnoonan_: Not that I'm aware. GHC is fairly dependent on the 512kb nursery area of its GC to perform good and with the collecting turned off, that's going to fill up very quickly and become problematic.
19:36:03 <nitrix> mnoonan_: I think you're probably after disabling or postponing major GC as opposed to minor GC, but I'm not aware of how you would control this either. A large heap doesn't help here as some of the heuristics are time-based (e.g. every 0.3 seconds when all threads are idle).
19:36:43 <nitrix> I guess it could be a new feature.
19:37:14 <mnoonan_> nitrix: minor gc still can move objects, right? I mostly just am trying to avoid writing a flaky test that two objects are supposed to be identical.
19:37:24 <pacak> mnoonan_: Do you have any benchmarks showing that ptr equality will help?
19:37:40 <pacak> You might be barking at the wrong tree...
19:37:48 <nitrix> mnoonan_: Yes, minor GC will move objects from the nursery aread to the heap.
19:37:55 <mnoonan_> pacak: it isn’t for optimization, really 
19:38:11 <koz_> Is there a short-circuiting fold? I wanna bail out if the fold produces a particular value.
19:38:24 <nitrix> mnoonan_: And when I was a beginner with Haskell, I was trying to do pointer equality checks and after going all the way down the rabbit hole, I discovered that it'd break referential transparency to do so.
19:38:46 <mnoonan_> I’m tagging maps and keys with a phantom type in this library, and I don’t want the tagged versions to carry any run-time overhead. they should literally just be the same, untagged values
19:39:20 <mnoonan_> nitrix: I promise I’m not doing shenanigans :)
19:41:37 <pacak> "overhead"... "it isn’t for optimization"... ಠ_ಠ
19:41:48 <nitrix> Have you considered newtypes? Their whole purpose are to have different types during compile-time yet the same representation at runtime (eliminated, with no overhead).
19:42:25 <mnoonan_> nitrix: yes, that’s already what the library does.
19:42:56 <mnoonan_> the problem that I’m trying to solve now is stemming from a comment byorgey made earlier today, which is that mapping a newtype-unwrapper over a list still has nontrivial cost
19:43:13 <mnoonan_> there is a similar point made in the Coercible paper too, I think
19:44:03 <mnoonan_> pacak: point taken :) 
19:44:27 <mnoonan_> pacak: what I mean is, I’m not trying to squeeze some cycles out of a computation, I’m trying to make this library zero-cost for the user.
19:45:15 <nitrix> Additional cost than just a list? That shouldn't be... the newtype should get completely erased.
19:45:49 <pacak> mnoonan_: https://github.com/tibbe/unordered-containers/issues/147 + https://ghc.haskell.org/trac/ghc/ticket/13615
19:46:12 <pacak> mnoonan_: It was ghc bug though.
19:46:46 <mnoonan_> nitrix: see the first page of http://cs.brynmawr.edu/~rae/papers/2014/coercible/coercible.pdf starting at “Using newtype for abstraction in Haskell has always suf- fered from an embarrassing difficulty.”
19:48:00 <nitrix> Oh, interesting.
19:49:11 <mnoonan_> pacak: I’m not sure I follow what the connection is?
19:49:29 <mnoonan_> yeah, I was surprised too
19:49:58 <pacak> mnoonan_: If you are doing strange stuff for performance reasons - your users might be suffering from obscure bugs.
19:50:28 <pacak> I'm not saying don't do that just be careful about it.
19:50:32 <mnoonan_> fair enough
19:50:38 <nitrix> mnoonan_: You should be able to use `coerce` in that scenario if all things fail, but I thought GHC was able to eliminate this. I'd be very surprised. I'm tempted to look at Core.
19:51:10 <nitrix> mnoonan_: https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Coerce.html
19:51:47 <mnoonan_> nitrix: yeah, I’m working on sprinkling some “coerce”s in right now, and I wanted to write a test to ensure it was working as intended.. hence the original question :)
19:54:32 <nitrix> As long as you're not casting between boxed and unboxed values with unsafeCoerce# and trickery (which I think should be prevented by the type checker), I don't see how a garbage collection would break this.
19:55:14 <geekosaur> reallyUnsafePtrEquality# came up earlier
19:55:34 <geekosaur> and the answer there is, make sure both parameters are fully evaluated and force a gc before doing the comparison
19:55:52 <geekosaur> thta may end up being more expensive than just letting things go...
19:56:01 <mnoonan_> geekosaur: whnf is sufficient, I assume?
19:57:32 <geekosaur> I'm not sue it is, in a multithreaded context
19:57:52 <geekosaur> your thunk could be forced by another thread, which could trigger a gc which affects all threads
19:58:17 <nitrix> I'd think this is the kind of test that GHC probably has to maintain the intergrity of Data.Coerce. Seems strange to roll your own test.
19:58:45 <geekosaur> Coercible is always a no-op
19:59:44 <mnoonan_> the point of the test is to pin down the library’s API and give external evidence that is it zero-cost (and catch me if I screw that up), not to test Data.Coerce itself
20:00:27 <nitrix> Oh, as in forgetting to use coerce somewhere or something?
20:01:11 <nitrix> Mmmh.
20:01:41 <mnoonan_> right
20:06:18 <mnoonan_> awesome, I actually found a bug
20:09:43 <nitrix> I wonder if roles could help here. Never played with them.
20:12:07 <nitrix> Marking the type variables as nominal equality vs. representational equality so they can get erased properly.
20:20:24 <nitrix> mnoonan_: {-# LANGUAGE RoleAnnotations #-}      type role YourNewType nominal
20:27:27 <nitrix> That'll prevent users of your library to arbitrarily use `coerce` to cheat YourNewType, but then it still doesn't solve the zero-cost. I was expecting roles to solve this; looks like it's only Coercible that tackles the problem from what I read.
20:28:15 <c_wraith> Coercible uses type roles to determine whether or not an instance can exist
20:32:46 <nitrix> c_wraith: So looking at this isn't going to help. Is Coercible the only way to perform representational equality and erase the wrapping/unwrapping overhead of newtypes when there's a typed intermediate representation inbetween?
20:33:25 <nitrix> e.g. newtype N = MkN { unN :: Int };   map unN
20:35:07 <nitrix> It saddens me, GHC should have all the information it needs :(
20:54:33 <mniip> hmm
20:54:36 <mniip> good challenge
20:54:59 <mniip> implement zip with induction only
20:55:46 <mniip> it's definitely possible - there's a paper about it
20:55:55 <mniip> but deriving it explicitly is tricky
20:56:30 <exio4> I might be understanding induction wrong, but where's the tricky part?
20:56:51 <mniip> exio4, induction means foldr not uncons
20:57:15 <exio4> mniip: yeah, so?
20:58:02 <mniip> well, you can technically implement uncons using foldr/Maybe, but that's kinda cheating
20:58:12 <ski> there should be one call to `foldr' for each of the two initial lists, and otherwise no traversal of them
21:05:59 <exio4> ah
21:06:44 <c_wraith> nitrix: it's the only way the compiler knows how to prove is safe
21:07:42 <mnoonan_> ok, so I made some failing tests to start from, but my “check if mapping a newtype unwrapper is 0-cost” tests are unexpectedly passing. any ideas? https://github.com/matt-noonan/justified-containers/commit/fe6d81dc61f8bfcccba7f5ddda63bb7ec545fec3 
21:15:29 <exio4> mnoonan_: I jsut came up (\z f -> foldr f z ['a','b','c','d'] [1::Int,2,3]) (\_ -> [] :: [(Char,Int)]) (\c f is -> foldr (\i rs -> (c,i):f (foldr (\(_, x) xs -> x:xs) [] rs)) [] is)
21:15:47 <exio4> where is the cheat? 
21:15:53 <exio4> uh, sorry mnoonan_ 
21:15:59 <exio4> mniip: ** ^ :P
21:16:26 <noonan_comma_m> :)
21:17:06 <mniip> now if I could get mnemoc to do that too that'd be great
21:17:29 <exio4> who? :P
21:18:24 <mniip> noonan_comma_m, sorry for existing I guess!
21:18:27 <nshepperd> _ `isLiterally` [letters] should always be false unless there is cse, since that will be an entirely new list
21:18:48 <noonan_comma_m> nshepperd: doh!
21:19:40 <noonan_comma_m> wait, that just makes the “forgetting evidence” version passing even weirder..
21:22:08 <nshepperd> it's a mystery
21:22:19 <nshepperd> could you use StableNames instead
21:22:46 <nshepperd> instead of reallyUnsafePtrEquality# that is
21:24:55 <noonan_comma_m> nshepperd: I haven’t used stable names before, but I read a little bit. I have to seq x and y first, make the names, then compare?
21:25:42 <nshepperd> i don't think you even have to seq them with StableName
21:26:21 <nshepperd> unsafePerformIO ((==) <$> makeStableName x <*> makeStableName y)
21:27:07 <noonan_comma_m> the docs make it sound like you can get different stable names from the same object, so comparing stable names only will tell you “definitely the same” or “maybe not the same”
21:27:17 <nshepperd> oh yeah, might be better to seq them
21:28:04 <nshepperd> and performGC, yeah, so basically what you are doing now but instead with the above instead of pointer equality
21:29:05 <ski> exio4 : that calls `foldr' repeatedly, once for each `is'
21:30:23 <exio4> ski: hm, I guess I am missing something 
21:30:32 <exio4> either way I have to sleep, uni in a few hours :(
21:30:42 <exio4> is the paper online/public?
21:31:04 <ski> i'm not sure which paper mniip referred to
21:31:13 <ski> my solution is online
21:31:32 <noonan_comma_m> nshepperd: no change to the results!
21:31:34 <exio4> where? 
21:31:37 <ski> (and i'm aware of another solution, that i found out about, afterwards)
21:34:35 <nshepperd> noonan_comma_m: maybe... it really is optimising away! ‾\(*_*)/‾
21:34:49 <noonan_comma_m> argh
21:35:20 <nshepperd> i could believe that the forgetting evidence one might pass, with some clever optimisation
21:35:45 <nshepperd> map theKey -> map id -> id
21:36:17 <noonan_comma_m> except that the “map id -> id” stage in the previous test appears to fail
21:37:17 * hackagebot tasty-hedgehog 0.1.0.0 – Integrates the hedgehog testing library with the tasty testing framework. – https://hackage.haskell.org/package/tasty-hedgehog
21:37:24 <nshepperd> did you fix the [letters] thing
21:37:56 <nshepperd> (let ms = [m] in map id ms `isLiterally` ms) should pass
21:38:24 <noonan_comma_m> nshepperd: yeah, that works
21:38:39 <ski> exio4 : <http://lpaste.net/47814>
21:40:47 <nshepperd> seems reasonable
21:41:51 <noonan_comma_m> wait, no, maybe not. I think it may be time for sleep :/
21:49:25 <Koterpillar> If I have data Foo = One | Two and newtype Bar (thingy :: Foo) = Bar Int, how do I write a function Bar a -> Foo that returns the value of a?
21:50:11 <ski> no
21:52:36 <ski> if `Bar' was a GADT, then you could possibly do it
21:53:25 <ski> (or if you passed another GADT argument to the function, indexed by `a'. or constrained `a' by a type class)
21:55:53 <Koterpillar> Given how small `Foo` is, I can make this a typeclass, and write instances for `Bar One` and `Bar Two`… ah, is that what you said?
21:56:38 <nshepperd> class Thing (a :: Foo) where { ... }; then you can give instances for One and Two
21:57:10 <nshepperd> then your function will be like (Thing a) => Bar a -> Foo
21:58:06 <Koterpillar> I see. How would a GADT help?
21:59:29 <ski>   data Bar :: Foo -> *
21:59:31 <ski>     where
21:59:37 <ski>     IsOne :: Bar One
21:59:44 <ski>     IsTwo :: Bar Two
22:00:19 <ski>   toFoo :: Bar a -> Foo
22:00:25 <ski>   toFoo IsOne = One
22:00:30 <ski>   toFoo IsTwo = Two
22:01:07 <nitrix> That moment when you send a message to an academic/researcher you've been looking up to after reading many of their papers to discuss their work...
22:01:22 <nitrix> That email was so stressful to write.
22:01:41 <MarcelineVQ> everyone poops
22:01:43 <ski> of course, the type system won't know that `toFoo b' is equal to `a' in `b :: Bar a'
22:01:52 <nitrix> I feel lame for annoying him with my stupid question.
22:02:02 <Koterpillar> ski: can this work when Bar has that extra parameter?
22:02:16 <ski> which extra parameter ?
22:02:29 <Koterpillar> newtype Bar (thingy :: Foo) = Bar Int
22:02:42 <nshepperd> IsOne :: Int -> Bar One
22:02:49 <nshepperd> IsTwo :: Int -> Bar Two
22:02:58 <ski> i don't see how that is extra. i already included that parameter
22:03:09 <ski> (`thingy', i.e.)
22:03:25 <ski> oh, if you mean the `Int', then as nshepperd says
22:03:26 <nitrix> MarcelineVQ: I did sign it with my PGP key for the first time though! :D
22:04:28 <Koterpillar> ski: nshepperd: thank you, I'll see which solution looks better in the end
22:05:46 <cheater> hi
22:06:49 <cheater> i have a library that does something like gradient descent (more involved) on arrays. i would like to speed it up. what's the best way to find out where it's spending all its time?
22:07:04 <dysfun> profiling
22:07:04 <dmj`> cheater: profiling
22:07:08 <koz_> cheater: Tried profiling?
22:07:11 <cheater> not yet
22:07:12 <koz_> Damn, ninja'd.
22:07:19 <koz_> cheater: That is always step 1.
22:07:42 <cheater> what i did find is in every step of the optimization algorithm it computes the symbolic function every time
22:07:53 <cheater> so i might try and start with fixing that
22:08:53 <dysfun> or you could just profile and it would tell you exactly where the time and memory is going
22:09:07 <koz_> I would recommend profiling as well.
22:09:22 <koz_> Performance problems are never where you think.
22:10:04 <cheater> ok
22:10:34 <cheater> well that one is def a perf problem because it computes something on every loop iteration that it could compute just once outside the loop.
22:10:50 <koz_> cheater: How do you know GHC isn't lifting it out?
22:11:15 <cheater> i added a trace to the lookup function
22:11:37 <cheater> if it were lifted out it would only run that trace once, right?
22:11:45 <slack1256> cheater: nesterov's method?
22:11:48 <koz_> cheater: What do you mean by 'a trace' in this case?
22:11:59 <cheater> Debug.Trace.trace
22:12:29 <cheater> slack1256: subgrad minimization from disciplined convex programming which is the theory behind the cvx library
22:13:39 <slack1256> you just gotta love boyd
22:13:41 <cheater> subgradLoop here: https://github.com/chrisnc/hvx/blob/master/src/HVX/Internal/Solvers.hs
22:13:46 <cheater> slack1256: boyd?
22:13:54 <slack1256> dude behind cvx
22:14:12 <cheater> oh. ok
22:14:22 <cheater> well, i dunno about cvx, because this lib is written from scratch
22:14:28 <cheater> i picked it up and started making it better
22:14:41 <cheater> ported it to 8.2.1, fixed mem leaks, etc
22:15:43 <cheater> koz_: think trace would fire only once if it were lifted out as you say?
22:16:17 <slack1256> nice, glad to see somebody also thinking on convex optimizations & haskell :-)
22:16:36 <slack1256> I will checkout your code
22:17:40 <cheater> it's mostly not my code
22:17:49 <cheater> i just fixed and updated some things
22:18:30 <cheater> i am not chrisnc. he is a separate meat entity. meatity.
22:19:11 <slack1256> still
22:19:56 <cheater> there's an issue open in the gh issue tracker for improving hvx performance. you should take a look at it if you think you can improve it :)
22:27:47 <xzhu__> /join #clojure
22:27:53 <xzhu__> oops
22:27:53 <dysfun> good idea
22:51:42 <`Guest00000> are there any reliable/mature, runtimeless haskell compilers?
22:52:41 <`Guest00000> a better way to phrase is i need a freestanding haskell compiler
22:53:21 <pacak> There is only one mature/reliable haskell compiler.
22:53:37 <`Guest00000> ok, strike that out
22:56:34 <cocreature> what does “runtimeless” even mean?
22:56:50 <`Guest00000> cocreature: without runtime
22:57:05 <cocreature> are C compilers runtimeless? crt0 is a runtime library
22:58:26 <cocreature> `Guest00000: what is your actual goal? i.e., what are you hoping to achieve by having a “runtimeless” haskell compiler
22:58:40 <norc_> Good morning. So for 2 days I have been trying to understand the abstract definition of WHNF in LC, but it still escapes me. Is there some de-facto literature to read for LC?
22:58:55 <texasmynsted> anybody use hindent with the "extensions" switch?  Example hindent -XMagicHash
22:59:00 <norc_> I mean I can look at a haskell expression and say whether its in WHNF, but all those LC definitions look... different.
22:59:15 <texasmynsted> I am unclear what this would do to hindent
23:02:13 <`Guest00000> cocreature: i want to write a program in haskell and compile it into reasonably lightweight, that is, not carrying a huge chunk of utility code like GHC RTS, native code, and link it manually in my things
23:02:24 <`Guest00000> iow, i need a freestanding haskell
23:03:16 <`Guest00000> surely, some part of Haskell specification requires OS support, but no OS support is ever needed to concatenate two Int lists
23:03:33 <`Guest00000> hmm
23:03:44 <nshepperd_> You want to embed Haskell in another application?
23:04:02 <norc_> Guest18244: Are you sure? Where does the memory come from?
23:04:05 <cocreature> GC, threading, … needs some kind of runtime
23:04:32 <norc_> `Guest00000 I meant.
23:04:37 <nshepperd_> Or use Haskell code as some kind of library
23:04:47 <texasmynsted> `Guest00000: What exactly are you wanting?
23:05:06 <norc_> `Guest00000 freestanding makes sense in a language that closely models the underlying hardware, because it requires very little runtime.
23:05:17 <texasmynsted> Are you wanting something like HaLVM?
23:05:20 <texasmynsted> http://uhsure.com/halvm3.html
23:06:05 <texasmynsted> `Guest00000: are you wanting Haskell w/o IO?
23:07:29 <texasmynsted> `Guest00000: not sure what your compiler would be doing if the resulting code could not be executed
23:07:31 <`Guest00000> well, ok, excepting memory management
23:07:33 * texasmynsted shrug
23:08:08 <texasmynsted> WAT
23:08:43 <cocreature> `Guest00000: so you want your code to never allocate and free memory? that’s not going to get you very far
23:08:44 <texasmynsted> you don't want memory management?
23:09:10 <zekt> Hi guys I am now having a small language in Haskell whose value is defined as 
23:09:10 <zekt> data Val a where N :: Int -> Val Int; B :: Bool -> Val Bool; L :: [Val a] -> Val [a]; P :: (Val a) -> (Val b) -> Val (a, b)
23:09:11 <zekt> Is there a way to define an environment like  type Env :: String -> Val ? I find it hard to do so with parametric type
23:09:45 <cocreature> `Guest00000: what you could do is use some kind of EDSL in Haskell and compile that to C
23:09:54 <cocreature> but Haskell itself is never going to be super lightweight
23:10:20 <texasmynsted> maybe he wants an AST
23:10:28 <`Guest00000> cocreature: that's really pessimistic
23:11:12 <texasmynsted> `Guest00000: How do you plan to use Haskell that you need it to be so lightweight?
23:11:26 <cocreature> `Guest00000: I would call it realistic instead of pessimistic :) you don’t get GC and lightweight threading for free
23:12:21 <`Guest00000> cocreature: don't need threading
23:12:36 <texasmynsted> compile it to JavaScript then
23:13:24 <`Guest00000> i'm unaware of platforms which have JavaScript as native language
23:13:25 <cocreature> `Guest00000: well if you eliminate all features that make it hard to implement a Haskell compiler without a runtime then you can probably build one (for some definition of not having a runtime) but then it’s not a Haskell compiler
23:13:28 <texasmynsted> maybe you want purescript
23:13:37 <texasmynsted> native language?
23:13:51 <`Guest00000> machine code
23:13:56 <texasmynsted> sigh
23:14:08 <norc_> cocreature: Well, considering that C also has a notion of hosted and freestanding, I think it's fine.
23:14:37 <texasmynsted> `Guest00000: what would you do once you had this?
23:14:43 <norc_> cocreature: I mean in C++ we do the same thing too for osdev for example. You kind of have to start by disabling RTTI and exceptions :P
23:15:16 <texasmynsted> `Guest00000: Write your firmware or driver or whatever in Rust
23:15:36 <cocreature> norc_: the impact of disabling RTTI and exceptions is imho significantly smaller than removing automatic memory management from Haskell
23:15:48 <`Guest00000> i need to write a compiler which runs as a system component
23:16:00 <`Guest00000> i need a HL language to write it in
23:16:02 <norc_> cocreature: You automatically opt out of the entire standard library and memory management too.
23:16:11 <`Guest00000> because it compiles a HL language
23:16:23 <norc_> cocreature: In C++ its just a little more explicit, but things like smart pointers are just a handle on automatic memory manageent. :)
23:16:48 <cocreature> norc_: you don’t have to. you can use the standard library with -fno-rtti and -fno-exceptions just fine for the most part
23:16:59 <texasmynsted> what do you mean by system component?
23:17:03 <cocreature> and reference counting is not a substitute for GC
23:17:20 <yushyin> norc_: ref counting is automatic memory management? ^^
23:17:24 <pacak> > let ones = 1 : ones in ones
23:17:27 <texasmynsted> is this firmware that will be burned in?
23:17:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:17:33 <yushyin> I dunno about that!
23:17:36 <norc_> yushyin: And the automatic delete (!) that ensues, yes.
23:18:55 <norc_> yushyin: My point is just, to write a kernel you lose rtti, exceptions and basically the entirety of the standard library.
23:19:07 <texasmynsted> a non-strict compiler, w/o memory management or threading . . .
23:19:55 <cocreature> those features are much less integral to C++ than GC is to Haskell
23:20:17 <cocreature> pacak just showed you an example of code that we write all the time in Haskell and that doesn’t work with reference counting
23:20:43 <cocreature> and we also use threading all over the place. ever used "timeout"? you’ve used threads
23:21:05 <texasmynsted> `Guest00000: I am trying to persuade you not to do this thing.
23:21:18 <texasmynsted> heh
23:22:28 <`Guest00000> which thing
23:22:41 <Athas> Also, reference counting is easily slow in the presence of parallelism.
23:23:54 <mniip> actually
23:24:06 <mniip> it's much easier to get exceptions in bare metal
23:24:09 <mniip> than memory management
23:25:28 <codebje> I am getting a spurious "It is a member of the hidden package ‘base-4.9.1.0’" error - if I have lifted-base in my build-depends, the error appears; if I remove it, the error goes away
23:25:38 <codebje> but of course other errors about lfited-base being missing crop up instead
23:25:50 <codebje> "stack ghci" has no worries, but "stack build" fails
23:26:01 <mniip> (I mean, both are mediocre if your language is suited to be flexible for the environment)
23:26:21 <mniip> (I've run lua from basically an MBR bootloader)
23:26:40 <cocreature> codebje: please show us the full error and your cabal file
23:26:54 <pacak> codebje: Do you have base in your build-depends?
23:27:04 <codebje> pacak, yes
23:27:15 <codebje> one sec on full cabal + error
23:28:15 * hackagebot projectile 0.0.0.1 – Go to README.md – https://hackage.haskell.org/package/projectile
23:28:18 <`Guest00000> texasmynsted: 'system component' like 'OS component'
23:30:17 <pacak> codebje: ghc-pkg check?
23:31:06 <mniip> 8/24/2017 [09:14:21] <norc_> cocreature: I mean in C++ we do the same thing too for osdev for example. You kind of have to start by disabling RTTI and exceptions :P
23:31:15 <codebje> https://gist.github.com/anonymous/50f0ececfd7b051ed8a8651d8cdd3686
23:31:16 <mniip> can't you get RTTI by implementing a few libgcc hooks?
23:31:22 <mniip> same for exceptions
23:31:54 <codebje> @pacak, just warnings about haddock from the package check
23:31:54 <lambdabot> Unknown command, try @list
23:32:54 <cocreature> codebje: huh that’s weird. ghc shouldn’t find Data.ProtoLens.* in base
23:33:03 <pacak>     Failed to load interface for ‘Data.ProtoLens.Reexport.Prelude’
23:33:16 <codebje> no, it should not
23:33:17 <cocreature> oh the Prelude is confusing it
23:33:29 <codebje> the protolens reexports shouldn't even be part of that build phase
23:33:36 <pacak> Every time ghc gets better and better error handling nature creates better idiots...
23:33:41 <cocreature> codebje: try adding proto-lens to the built:epends in your executable
23:34:06 <pacak> Why would you want to reexport prelude?
23:34:22 <codebje> that particular part is not my code, pacak
23:34:52 <codebje> I haven't changed the LTS version since the last time this built, nor is the protobuf parts new or changed
23:35:02 <codebje> cocreature: giving that a go
23:35:08 <pacak> Before using a library I usually look at it's sanity. This behavior looks kind of insane to me.
23:35:51 <codebje> cocreature I think has found a solution, though I still can't understand how the problem arose when I started using lifted-base
23:36:51 * hackagebot tasty-hedgehog 0.1.0.1 – Integrates the hedgehog testing library with the tasty testing framework. – https://hackage.haskell.org/package/tasty-hedgehog
23:36:58 <codebje> pacak:       -- For forwards compatibility, reexport them as new module names so that
23:37:01 <codebje>       -- other packages don't accidentally write non-generated code that
23:37:03 <codebje> doesn't seem _too_ insane
23:37:06 <codebje>       -- relies on these modules being reexported by proto-lens-protoc.
23:41:31 <pacak> We reexport prelude because somebody might rely on fact that we reexport prelude?
23:41:56 <pacak> ಠ_ಠ
23:46:09 <kuribas> I am looking at esqueleto.  The type of query seems to be always query (). Aren't they making it a monad just to be able to (ab)use do notation?
23:46:14 <kuribas> Shouldn't it be a monoid instead?
23:47:50 <cocreature> making things an instance of Monad just to be able to abuse do-nottation is fairly common so I wouldn’t be surprised by that :)
23:47:57 <cocreature> a lot of HTML libs do it too
23:48:10 <kuribas> blaze?
23:48:21 <cocreature> not sure about blaze, I know lucid does it
23:49:20 <kuribas> right
23:49:22 <pacak> Monad is a monoid...
23:49:35 <pacak> in a category of applicative burritos.
23:51:24 <kuribas> is Monad () a monoid?
23:52:27 <pacak> I wonder if it's possible to coerce equeletto into generating bogus query/runtime error by abusing join from this monoid instance...
23:52:54 <Taneb> a -> m a is a monoid for every a and monad m but that's not the interesting thing about them
23:53:28 <Taneb> Or rather it's not quite what people mean by a monad is a monoid in the category of endofunctors
23:53:55 <pacak> kuribas: https://arxiv.org/abs/1406.4823
23:54:43 <Taneb> Ah, reading scroll back, m () is a monoid in the way you want it to be
23:54:45 <cocreature> kuribas: if you make a newtype for "m ()" you can make an instance for Monoid with mempty = pure (), mappend = (>>)
23:54:48 <kuribas> pacak: I'll need to read a good book about cathegory theory first...
23:55:20 <pacak> kuribas: There's no good books, they all filled with pain and suffering.
23:56:02 <kuribas> Taneb: I was thinking about (m ()) and (>>), but I suppose this is the same as "() -> m ()" and (>>=)
23:56:25 <pacak> :t (>=>)
23:56:27 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:56:40 <pacak> :t return
23:56:42 <lambdabot> Monad m => a -> m a
23:56:59 <kuribas> pacak: ah right
23:57:07 <pacak> mappend, unit, left and right identity.
23:57:34 <pacak> if you look at endofunctors
23:57:38 <pacak> a -> m a
23:58:06 <pacak> :t Kleisli
23:58:07 <lambdabot> (a -> m b) -> Kleisli m a b
23:59:01 <pacak> Hmm... Left and right identity - that's from category... In monoids it's called something else.
