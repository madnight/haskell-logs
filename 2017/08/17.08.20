00:00:15 <mustafa_> hey, is there any haskell library for web crawling?
00:00:47 <mustafa_> I found scapel https://hackage.haskell.org/package/scalpel
00:01:06 <mustafa_> is there anyone previously used it?
00:04:32 <lamster> erisco: sorry I didnt saw your response earlier
00:04:56 <lamster> erisco: Ive found a package: https://hackage.haskell.org/package/deriving-compat-0.3.6
00:05:11 <lamster> erisco: it was helpful as hell and did it job automatically
00:05:33 <erisco> great, thanks
00:06:47 <texasmynsted> not sure if this is more a #vim question or a #haskell question, but any vim users in here use ghcmod?
00:07:34 <texasmynsted> I installed stuff on a different machine and for some reason my ghcmod in vim is showing "ghcmod#command#type_insert: Cannot guess type" on everything I ask it the type
00:13:49 <texasmynsted> ohh I think this is the issue... http://blog.pangyanhan.com/posts/2017-07-02-haskell-vim-now-ghcmod-vim-resolving-ghcmod-command-type-cannot-guess-type-errors.html
00:26:28 <texasmynsted> hmm.  was not that but also kind of fixed.  
00:26:31 * texasmynsted shrug
00:34:01 <lasey> thoughtpolice: ty
00:47:23 <dminuoso> Mmmm, -> is not a regular data constructor, is it?
00:47:58 <[exa]> nope, it's a type constructor
00:48:36 <erisco> the constructor is lambda
00:49:30 <erisco> the data constructor
00:50:21 <dminuoso> erisco, does that mean foo x = x + 1 is actually some syntactical sugar for foo = (\x -> x + 1) ?
00:51:24 <erisco> I don't think it actually rewrites like that in Core, but I don't know Core
00:52:06 <erisco> but those two have equivalent meaning
00:52:17 <dminuoso> [exa], the reason I asked about it being a data constructor is because of its usage in lambda expressions
00:52:20 <dminuoso> It confused me
00:52:31 <[exa]> dminuoso: nope, it's pure syntactic sugar in that case
00:53:00 <[exa]> (also in case of 'case' iirc)
00:53:59 <erisco> what does case rewrite to?
00:55:49 <dminuoso> erisco, perhaps just function definitions with pattern matching?
00:56:01 <dminuoso> The gentle introduction to haskell called them two equivalent
00:56:07 <erisco> that would seem backwards
00:56:46 <dminuoso> erisco, oh I just found it. Indeed, the Report actually specifies it to be the other way around.
00:57:55 <erisco> which section?
00:59:47 <dminuoso> erisco, https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17c
01:00:08 <dminuoso> And Im quite surprised that the haskell report is actually readable. :-)
01:32:02 * hackagebot zifter-stack 0.0.0.6 – zifter-stack – https://hackage.haskell.org/package/zifter-stack
02:04:29 <f-a> is there a way to `trace` to a specified file?
02:05:15 <mniip> you'll have to write your own trace then most likely
02:06:13 <mniip> see https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Debug.Trace.html for insights on how to not mess it up
02:06:21 <f-a> mniip: I'll rephrase then. I am writing a small console application, trace is not that useful because it gets mingled with "normal" output. What's the correct way to address that?
02:07:07 <mniip> f-a, is it for debug purposes only?
02:07:17 <f-a> mniip: yes
02:07:36 <cocreature> f-a: does your application write to stderr?
02:07:40 <f-a> I don't think I can use :step for similar reasons
02:07:45 <cocreature> if not you can just redirect stderr
02:07:58 <mniip> f-a, then follow https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Debug.Trace.html and implement your own trace
02:08:12 <f-a> cocreature: no it doesn't. that could actually work
02:08:37 <cocreature> ./myexecutable 2> err
02:09:32 <f-a> thanks
02:14:27 <suitsmeveryfine> Hi! Does anyone here have experience with using haskeline or readline?
02:21:11 <f-a> suitsmeveryfine: tried it once, shoot your question and see if people can answer
02:24:43 <suitsmeveryfine> f-a: thanks. I'd like to use haskeline or readline instead of getLine to get string input for comparison
02:27:47 <f-a> and what's the problem suitsmeveryfine , are you looking for reviews / opinions on the package?
02:30:55 <suitsmeveryfine> What I'm after is something like
02:30:56 <suitsmeveryfine> str1 <- readline
02:30:56 <suitsmeveryfine> str2 <- readline
02:30:56 <suitsmeveryfine> if str1 == str2 then putStrLn "Good"
02:31:13 <merijn> suitsmeveryfine: You want:
02:31:14 <merijn> :t when
02:31:15 <lambdabot> Applicative f => Bool -> f () -> f ()
02:31:16 <Myrl-saki>  ((~) * b a, (~) * c a) => Vector ((,,) b c) a
02:31:27 <Myrl-saki> How is this different from Vector `((,,) a a) a`
02:31:42 <merijn> suitsmeveryfine: Which is basically: "if str1 == str2 then putStrLn "Good" else return ()
02:32:25 <erisco> Myrl-saki, it shouldn't be. Do you have an example of where it is?
02:32:46 <Myrl-saki> erisco: Ah, just curious as to why it was written that way.
02:32:54 <suitsmeveryfine> marijn: yes, but the trouble is that readline/haskeline doesn't work at all like getline where you can do like above
02:33:05 <suitsmeveryfine> *merijn, sorry
02:37:00 <f-a> suitsmeveryfine: what's wrong in this first example? https://hackage.haskell.org/package/readline-1.0.3.0/docs/System-Console-Readline.html
02:37:14 <f-a> just make a function which unwraps the maybeLine 
02:41:06 <suitsmeveryfine> f-a: do you mean a function that works with Maybe String instead of [Char]?
02:41:37 <f-a> > Just "babby" == Just "babby"
02:41:40 <lambdabot>  True
02:41:42 <f-a> > Just "babby" == Just "foo"
02:41:44 <lambdabot>  False
02:41:45 <f-a> > Just "babby" == Nothing
02:41:48 <lambdabot>  False
02:41:57 <f-a> Eq already works on maybe, suitsmeveryfine 
02:42:11 <f-a> if you need (unsafe) to unwrap that maybe use
02:42:13 <f-a> :t maybe
02:42:15 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:42:30 <f-a> maybe (error "heybby") yourMaybeVal
02:46:56 <suitsmeveryfine> f-a: ok, so I should use "Just" in the str comparison function, but how shall I return the line, "assign it" to str1, `return Just line`?
02:51:37 <f-a> suitsmeveryfine: one sec
02:51:57 <Myrl-saki> https://hackage.haskell.org/package/fixed-vector-0.9.0.0
02:52:06 <Myrl-saki> How do I use `(Vector v a) =>`
02:52:41 <Myrl-saki> Or is it not meant to be used like that?
02:54:46 <erisco> it is a constraint, so yes it is supposed to be used like that
02:55:50 <f-a> suitsmeveryfine: you pattern match against the type like this
02:55:54 <f-a> https://hastebin.com/caheqasuje.hs
02:57:04 <Myrl-saki> erisco: I get an error that `Dim v` =/= (S k)
02:57:19 <erisco> *shrug* okay
02:57:39 <suitsmeveryfine> f-a: prova means "try" in my native language. Thanks, I'll try this.
02:58:19 <f-a> suitsmeveryfine: in mine too :P
02:58:47 <suitsmeveryfine> f-a: så lämpligt
02:59:24 <f-a> =D and I am not swedish. But I guess there has been some exchange of words between svenska and italian
03:01:06 <suitsmeveryfine> :D
03:04:13 <suitsmeveryfine> f-a: It works! Thanks a million.
03:05:02 <f-a> ^^d
03:20:02 <Myrl-saki> Is there a `Lens' a b -> Lens' a b -> Lens' a b`?
03:20:59 <erisco> and what would that do?
03:21:11 <Myrl-saki> Errr. I'm pretty sure I'm missing some type variables there.
03:21:17 <Myrl-saki> Basically, it does it in parallel.
03:31:19 <lyxia> there isn't
03:33:30 <lyxia> Actually, it depends on what the missing variables are. There is https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Lens.html#v:alongside
03:33:59 <lyxia> but no    Lens' a b -> Lens' a c -> Lens a (b, c)
03:34:39 <Myrl-saki> lyxia: Thanks.
03:34:54 <Myrl-saki> I think alongside is what I need.
04:13:59 <Myrl-saki> Wait wat.
04:14:04 <Myrl-saki> makeLenses isn't working with foralls?
04:15:25 <lyxia> what do you mean
04:16:01 <Myrl-saki> https://stackoverflow.com/questions/17256091/existential-quantifier-silently-disrupts-template-haskell-makelenses-why
04:16:12 <Myrl-saki> Why does pattern-matching work, but not records?
04:18:02 <lyxia> what type would you give to the record accessor
04:18:26 <Myrl-saki> lyxia: Oh, right.
04:22:48 <Fendor> hey, why is repa not in lts?
04:25:11 <thimoteus> does anyone know of any literature about how to use the typical transformers comonads (Traced,Env,Store) similar to what exists for their monad counterparts? as in, how Reader is often used when you want access to a read-only configuration, Writer can be used for logging, etc
04:25:35 <cocreature> Fendor: https://github.com/fpco/stackage/blob/4c7ddb5e036af25e90d0d3a0366291d952075020/build-constraints.yaml#L860
04:26:26 <cocreature> looks like that has been fixed since but nobody has bothered reenabling it
04:27:51 <Fendor> cocreature, i see. welp, hopefully it will be enabled some time again, can't use a more recent lts currently :/
04:29:18 <cocreature> Fendor: why do you need it to be in lts?
04:29:52 <cocreature> just add it to extra-deps
04:38:22 <Fendor> cocreature, hm, yeah, you're probably right. then the dependecies are also fixed 
04:44:10 * hackagebot hsyslog-tcp 0.1.0.0 – syslog over TCP – https://hackage.haskell.org/package/hsyslog-tcp
04:48:23 <hexagoxel> in the "Trees that Grow" paper, I am confused about the usage of `Void`. If all constructors have a field that is instantiated to `Void`, isn't my data type essentially `Void`? (ignoring any bottoms)
04:48:50 <cocreature> hexagoxel: the confusing thing is that they don’t ignore bottoms and view Void as a constructor with one inhabitant
04:49:25 <rcat> I'm trying to enable profiling with 'cabal new-build' adding 'profiling: true' in cabal.project.local
04:49:49 <rcat> but it doesn't seems to work, also I'm using Arch Linux which uses dynamic linking by defualt, not sure if this matters
04:49:53 <hexagoxel> cocreature: would it not be much clearer to use a strict field?
04:49:57 <cocreature> which is just weird since if you accept the fact that you have bottom, you also need to accept that bottoms are not equivalent and then Void is also not what you want
04:50:02 <rcat> is tis supposed to work with the 'new-build'?
04:50:25 <cocreature> hexagoxel: I tried to convince them that this is a terrible idea but haven’t had much success
04:51:19 <cocreature> hexagoxel: iirc they also use Void as the uninhabited type in other places
04:51:45 <hexagoxel> cocreature: eh, strange. i really dislike this choice. well, thanks for the explanation.
04:59:42 <hexagoxel> also, they replace `Void` with `Typ` below.. i guess bottom then means type-checking failure? :S
05:04:06 <cocreature> I thought they had some code wich just used `Void` and `()` but I can’t find it
05:48:16 <ertes> thimoteus: Env is kind of a trivial Comonad, Traced is just Store in disguise, and Store is used for anything that is indexed and has a "current position"
05:48:54 <ertes> thimoteus: examples: videos, images, audio waves, …
05:49:45 <ertes> thimoteus: you might use StoreT over Env to encode an image with meta-data
05:49:58 <ertes> where you use ComonadEnv to access the meta-data
05:55:58 <Rembane> Good morning, have you ever run into problems using SQLite3 in Haskell in many threads concurrently?
05:58:56 <ertes> Rembane: using a single connection?  no…  using multiple connections?  yes
05:59:36 <Rembane> ertes: So if I pass around my single connection everywhere and use it in all my threads I will not run into trouble?
06:00:06 <ertes> Rembane: https://sqlite.org/faq.html#q6 (ignore the first paragraph, because it doesn't apply to haskell)
06:01:02 <Rembane> ertes: Thank you. My Google fu failed me. 
06:45:05 <Fekinox> I'm trying to install the MaybeT library using cabal, but it appears I get dependency errors http://lpaste.net/357830
06:50:38 <thimoteus> ertes, thanks
06:59:33 <fgaz> Fekinox: you probably want https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Maybe.html
06:59:57 <fgaz> that MaybeT library seems outdated
07:00:50 <temp_tense> GHC is giving "error: parse error on input ‘->’ " on the lowest line of http://lpaste.net/357831 . Is this a bug in GHC?
07:01:57 <fgaz> temp_tense: the _ is not aligned with the ' above
07:02:24 <temp_tense> It works!
07:02:50 <temp_tense> Thanks. Did not know you have to align those.
07:03:59 <erisco> when you increase indent it begins a block and when you decrease indent it ends one
07:04:30 <temp_tense> GHC should have not pointed out the "->".
07:04:45 <erisco> that is where the syntax error actually is, though
07:05:08 <erisco> it was treating it as a new expression, not part of the case/of
07:05:32 <erisco> > _ -> f result n
07:05:34 <lambdabot>  <hint>:1:3: error: parse error on input ‘->’
07:10:26 <erisco> well, it was part of the case/of in that it is part of your ')' case
07:53:33 <hexagoxel> is there a *plate implementation compatible with the "Trees that Grow" approach? I don't think uniplate in its current form would allow me to express `MyAST Stage1 -> MyAST Stage2`.
07:53:43 <hexagoxel> perhaps the lens one?
07:59:48 <cocreature> hexagoxel: can you make some minimal example of what you’re trying to do? it’s been too long since I’ve looked at the "trees that grow" paper
08:00:54 <cocreature> ah I think I see the problem
08:04:34 <hexagoxel> well uniplate assumes the recursive data type is monomorphic, but now you'd want the type argument that controls the type family selection to change.
08:05:25 <hexagoxel> e.g. take `rewrite :: Uniplate on => (on -> Maybe on) -> on -> on`
08:05:58 <hexagoxel> instead you now want `rewrite' :: Uniplate on => (on x -> ?) -> on x -> on y`
08:06:42 <hexagoxel> perhaps `rewrite :: Uniplate on => (on x -> Either (on y) (on y)) -> on x -> on y`
08:07:36 <cocreature> hm I think Biplate doesn’t help you either
08:08:16 <hexagoxel> it is a bit unfortunate that you'd no longer be able to default-case to Nothing, but i guess you have to invest something for the additional static safety :)
08:08:30 <cocreature> hm I’m not sure how this would even work.
08:08:50 <cocreature> let’s say you want to do a bottom up traversal
08:08:58 <cocreature> and you want to change the type during that somehow
08:09:26 <cocreature> so you start at the bottom and everything works out, then you move up but what should you operate on now?
08:09:42 <cocreature> in general it is not possible to _just_ replace the children to change the type
08:09:52 <cocreature> so things don’t fit together
08:10:48 <zaoqi> How can I implement microKanren?
08:11:52 <hexagoxel> cocreature: ah.. so my weird "further thought" has an application here: you have to let the type-level-function not determine the type of a field in each constructor, but (also) the type _constructor_ around the recursive stuff.
08:12:00 <hexagoxel> the paper did not go this far :D
08:12:20 <hexagoxel> (or is there any follow-up stuff already that i am not aware of?)
08:13:00 <cocreature> hexagoxel: I’m not sure how making even more things dependent on the type-level function helps
08:13:44 <cocreature> they’re still working on getting it into ghc and parts of it have already gone in but I’m not aware of any further writeups on it
08:14:32 <hexagoxel> i am not sure either.. i'll have to play around in a code sandbox a bit :)
08:18:05 <cocreature> hexagoxel: http://lpaste.net/357832 might be helpful to illustrate the problem. transform should should be a bottom up traversal. so you first recurse to the bottom and then you start applying the transformation. then you can’t apply it anymore since you you get an "Expr b" from the recursive case
08:19:44 * hackagebot Villefort 0.1.1.5 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
08:23:45 <cocreature> hexagoxel: do you really need to simultaneously do a traversal on the ast and change the type parameter? or asked differently, is it possible to separate your "(Expr a -> Expr b) -> Expr a -> Expr b" into a "(a -> b) -> Expr a -> Expr b" and a "(Expr a -> Expr a) -> Expr a -> Expr a"?
08:26:35 <hexagoxel> not if `b` can be Void, indirectly
08:27:07 <hexagoxel> but i see the problem. perhaps throw some recursion-scheme on it?
08:28:13 <cocreature> I’m not a fan of recursion-schemes but pulling out the recursion into a separate type parameter as required by recursion-schemes iirc would indeed be helpful
08:29:41 <hexagoxel> not only helpful, but necessary: as your example shows, you need to be able to express a `Expr a` but whose children are already `Expr b`s.
08:29:55 <hexagoxel> well, there may be other approaches for that, too.
08:32:54 <cocreature> I have my doubts that "(Expr a (Fix (Expr b)) -> Expr b) -> Expr a -> Expr b" is actually making things simpler than manual recursion but I guess trying it out doesn’t hurt :)
08:33:04 <cocreature> eh that’s missing a few Fix
09:01:03 <hexagoxel> cocreature: both work, and recursion-scheme is indeed not necessary. http://lpaste.net/357833
09:01:21 <hexagoxel> i like `transform2 :: (Exp2 a b -> Exp2 b b) -> Exp2 a a -> Exp2 b b`
09:02:00 <hexagoxel> the type signature even declares what kind of traversal is going on, i think.
09:02:50 <hexagoxel> topdown would be .. (Exp2 a a -> Exp2 b a) -> Exp2 a a -> Exp2 b b
09:06:32 <hexagoxel> and `rewrite :: (forall c . Exp2 a c -> Either (Exp2 b c) (Exp2 a c)) -> Exp2 a a -> Exp2 b b`  perhaps?
09:07:32 <hexagoxel> not sure about the forall there; i tried to encode that the type of traversal does not matter for rewrite.
09:08:29 <cocreature> I’m not sure that works. how do you get an "Exp2 b b" from an "Exp2 a a" if I give you "Right" as the argument to "rewrite"
09:09:00 <hexagoxel> by applying rewrite again. This is the same that happens with current uniplate rewrite, on Just
09:09:40 <hexagoxel> although.. you may have a point.
09:09:42 <cocreature> ah ok, I should have thought about what `rewrite` is actually supposed to do
09:10:41 * hackagebot twitter-conduit 0.2.2.2 – Twitter API package with conduit interface and Streaming API support. – https://hackage.haskell.org/package/twitter-conduit
09:23:58 <naddeoa> Does anyone have any experience with libraries  like https://hackage.haskell.org/package/cached-io-1.1.0.0/docs/Control-Concurrent-CachedIO.html that cache/memoize IO?
09:24:05 <naddeoa> I'm a little confused about how I should be actually using them
09:24:21 <naddeoa> Specifically, the way I'm using them doesn't seem to actually cache anything
09:24:42 <cocreature> it would be helpful if you tell usu how you are using them :)
09:25:00 <naddeoa> I have "getPassword :: IO String"
09:25:09 <naddeoa> its for a small cli that has to use sudo to install stuff
09:25:32 <naddeoa> I would like to be able to just  "password <- getPassword" wherever I need to shell out
09:25:43 <naddeoa> without having to enter passwords each time myself
09:26:03 <naddeoa> but getPassword is happening each time. I really want it to happen once ever
09:26:28 <naddeoa> and just return that same password each time
09:26:43 <glguy> Then only use getPassword once and then use the resulting password variable multiple times
09:27:08 <mbrock> I'm really struggling to understand, with Reflex-DOM, how to make a dynamic list of buttons that gets merged to one event (like a menu with dynamic entries)
09:27:15 <naddeoa> If I do that then I'll have to make a bunch of functions accept a password right?
09:27:56 <cocreature> with that cached-io library you would first use "getPassword' <- cachedIOWith isStillFresh getPassword" and then replace all uses of "getPassword" with "getPassword'"
09:28:13 <cocreature> but glguy is right. just passing the password itself around is a better solution
09:28:34 <cocreature> naddeoa: well if they need access to the password they _should_ accept a password
09:29:22 <naddeoa> they do *sometimes*. You're right, I can probably re architect it
09:29:36 <naddeoa> and I guess there is no harm in getting a password that you won't need to use
09:30:12 <naddeoa> before I give up on this, it looks like these libraries are all going to give me an IO ( IO String)
09:30:35 <naddeoa> I was accessing the password inside with "join getCachedPassword"
09:30:40 <naddeoa> is that how they intended it?
09:30:49 <cocreature> no, they give you back a version of "getPassword" that caches the result, they don’t give you back a password
09:30:56 <cocreature> take a look at what I wrote above
09:31:06 <cocreature> you get a "getPassword'" that you then use instead of "getPassword"
09:31:43 <naddeoa> Those two things look identical to me, what am I missing
09:32:18 <cocreature> the way you use them is identical. it’s just that the version you get from "cachedIO" will cache results.
09:32:36 <cocreature> and you’re missing a ' at the end of the name :)
09:32:46 <naddeoa> is that the convention for nested IO?
09:33:30 <cocreature> appending ' to names is generally quite common in Haskell if you have two very similar things and you are too lazy to come up with a better name :)
09:33:51 <naddeoa> lol I see
09:33:53 <cocreature> in this case "cachedGetPassword" might be a better name than "getPassword'" but naming things is hard :)
09:34:59 <naddeoa> so, I was thinking that these two were the same given "cachedPassword :: IO (IO String)"
09:34:59 <naddeoa> 1. password <- join cachedPassword
09:34:59 <naddeoa> 2. inner <- cachedPassword
09:34:59 <naddeoa>   password <- inner
09:35:15 <naddeoa> hopefully that formatting is ok...
09:35:22 <cocreature> they are the same. the point is that you can use "inner" multiple times
09:35:28 <cocreature> and then things will be cached
09:35:59 <naddeoa> ok I see what you're saying
09:36:38 <naddeoa> thanks!
09:39:36 <naddeoa> I think I was thinking this is more magical than it was
09:40:30 <naddeoa> I was hoping that this would result in only one pw request
09:40:30 <naddeoa> cachedPw1 <- getCachedPW
09:40:31 <naddeoa> pw <- cachedPw1
09:40:31 <naddeoa> cachedPw2 <- getCachedPW
09:40:31 <naddeoa> pw2 <- cachedPw2
09:41:58 <trigone> hi! something weird happened. i wrote a program taking a filepath, reading the file, and writing onto that same file acopy of its content, modified with some processing function. i made a small mistake in the processing function (forgetting a case in a pattern-match). the weirdest is, the program somehow ended up erasing the file instead of just halting with an error without writing on the file. does anyone got a theory?
09:42:22 <hpc> @lpaste
09:42:22 <lambdabot> Haskell pastebin: http://lpaste.net/
09:42:25 <Cale> trigone: Did you use readFile :: String -> IO () ?
09:42:31 <trigone> Cale: yeah, why?
09:42:47 <trigone> wait you mean writefile?
09:42:48 <Cale> trigone: If so, you're using magic lazy I/O, and the file is only read as needed.
09:42:51 <Cale> no
09:42:54 <Cale> writeFile is fine
09:42:55 <cocreature> naddeoa: where would you store the cached password? `cachedIO` caches it in the closure of the modified version it’s returning which is why you need to use the modified version everywhere
09:42:56 <trigone> :t readFile
09:42:58 <lambdabot> FilePath -> IO String
09:43:02 <Cale> er, sorry
09:43:13 <Cale> yeah, String -> IO String is what I'd meant to type :)
09:43:26 <Cale> (and FilePath is a synonym of that)
09:43:58 <trigone> Cale: the file is read since the processing function was used and encountered an error. the issue is the file is written despite that before getting the content to be written, an exception was encountered
09:44:10 <trigone> (written with an empty string or sth)
09:44:25 <Cale> uhh, well, that's odd
09:44:44 <Cale> I was assuming that what's happening is that it begins to write the file before much of it has been read
09:44:59 <Cale> and in so doing, truncates the file (effectively erases it)
09:45:10 <trigone> unless that's bc, when i called writeFile path (processing file), writeFile erased the file before even using processing?
09:45:14 <Cale> and then when it actually tries to read the file, there's nothing to read
09:45:21 <Cale> yes
09:45:50 <hpc> Prelude> writeFile "test.txt" (error "foo")
09:45:55 <hpc> this created test.txt
09:45:58 <hpc> with no contents
09:46:21 <Cale> trigone: readFile is sneaky
09:46:25 <hpc> and when i put contents in it and rerun, it's truncated
09:46:37 <hpc> moral of the story, don't try to write bottoms to files
09:46:44 <trigone> hpc: well that's relatively problematic actually... why was it not written to minimize the IO as long as the pure code was not ascertained to be valid?
09:46:49 <Cale> It doesn't actually cause the file to be read immediately, instead, it does some magic in order to construct a String whose *evaluation* causes the real I/O to occur
09:47:23 <Cale> which is sometimes kind of nice, but in cases where you're going to write to the same file, will screw everything up
09:47:33 <trigone> Cale: hm... you sure? cuz it had no trouble using processing over the content of the file even though apparently writeFile erases the file before using processing
09:47:38 <Cale> (also not so nice if you're opening lots of files, because you lose control of the filehandle)
09:47:42 <hpc> trigone: bug? i don't think they expected that function to receive bottom
09:48:10 <Cale> trigone: how are you checking?
09:48:15 <trigone> hpc: it's not like it can never happen. in which case, erasing the file first is kinda infortunate, i think...
09:48:36 <cocreature> hpc: calling lazy IO a bug is something that some people would agree with :)
09:48:48 <trigone> Cale: well if it erased the file before reading it, my program (which i fixed) could not work, would always erase files before doing anything with it
09:48:54 <hpc> lazy IO is a different issue here
09:49:13 <Cale> hpc: I'm not sure it is, but I haven't seen the program yet
09:49:14 <hpc> it could be what introduces the bottom (because it can embed IO errors in the resulting contents string)
09:49:22 <hpc> but in this case it's definitely writeFile that's at fault
09:49:35 <Cale> hpc: The error is quite possibly a consequence of the file becoming truncated
09:49:40 <hpc> maybe it should rnf the string it's given before it tries to mutate the filesystem
09:49:55 <Cale> I don't think it should
09:50:02 <hpc> Cale: run (writeFile (error "foo")) in ghci
09:50:13 <monochrom> If you aren't using one of those *getContents you are not having lazy I/O.
09:50:16 <hpc> it creates an empty file, then dies when it attempts to write
09:50:24 <Cale> hpc: Yeah, it makes sense to me that it would create the file and then error as soon as it tries to write the first byte to it
09:50:25 <naddeoa> concreature: I guess what I was looking for was to memoize any arbitrary functions. If this were another language It would have just been if(alreadyDone) { return alreadyDone} else { return alreadyDone = ...}
09:50:33 <Cale> That's sensible
09:50:40 <mustafa_> Hello everybody, My Haskell version of https getter is soooo slow compared to curl. Do you have any suggestion? https://stackoverflow.com/questions/45780131/why-is-my-https-getter-in-haskell-so-slow-compared-to-curl
09:50:52 <monochrom> If your output seems postponed, it is standard buffering, not lazy I/O. Even C does it.
09:50:57 <Cale> monochrom: readFile too
09:50:58 <hpc> i guess it depends on whether you consider writeFile to be an atomic operation, or a combination of creating a file and putting contents in it
09:51:06 <cocreature> monochrom: readFile uses hGetContents internally
09:51:13 <hpc> i would rather writeFile be as atomic as possible
09:51:36 <Cale> hpc: It's important that writeFile should be able to write more than you have in memory at once
09:51:49 <hpc> i hadn't thought of that
09:52:14 <monochrom> On Windows, writeFile is atomic, simply because Windows paranoidly locks every file.
09:52:32 <monochrom> (Just to put a spin on "atomic".)
09:52:48 <trigone> hpc: the first argument is the filepath
09:53:03 <Cale> Yeah, so the real correct thing to do is just to not overwrite the file you're reading, and instead write to a new temporary file, which you then move into place afterward
09:53:08 <Cale> There are a lot of good reasons to do that
09:53:11 <hpc> trigone: er, writeFile "test.txt" (error "foo") :P
09:53:15 <Cale> (not Haskell-specific reasons)
09:53:43 <Cale> But you could also just try using strict I/O -- possibly the easiest thing to do would be to switch to using (Strict) ByteString or Text
09:54:00 <trigone> the code btw: http://lpaste.net/357835
09:54:15 <trigone> (schematized)
09:54:44 <nickolay_> quick question - am I correct that in multi param typeclasses, the params of the class do _not_ imply the kind of each other? I mean Class Some a b c, does not mean that a :: * -> * -> * and b :: * -> * and c :: *  ?
09:55:05 <Cale> trigone: Okay, so actually *this* version, I would expect to work
09:55:14 <erisco> nickolay_, their kinds are independent
09:55:19 <trigone> Cale: you're right, in case of having to write lazily in a file, it makes sense to have writeFile erase the file first
09:55:24 <Cale> trigone: well, "work", apart from the fact that it's going to die
09:55:42 <nickolay_> erisco: ok, cool.. thanks!
09:55:51 <monochrom> It will use a lot of memory.
09:55:55 <erisco> nickolay_, you can introduce a kind variable with forall and have more than one kind depend on the variable
09:56:07 <Cale> and that, yeah
09:56:16 <trigone> Cale: well it does work, but it did part of the job of writeFile (which is to truncate/erase/overwrite the file into making it empty) before encountering the fatal blow
09:56:20 <Cale> The creation of the backup will force the entire file to be read
09:56:24 <nickolay_> erisco: I see
09:56:32 <trigone> Cale: oh true i hadn't thought of that
09:56:55 <Cale> take that out, and the file will get truncated before you read anything
09:57:01 <trigone> haha so it worked by mistake then
09:57:13 <Cale> yeah
09:58:14 <Cale> nickolay_: Usually the kinds of the type parameters to a class will be determined by the way they occur in the types of the methods
09:58:15 <trigone> so, is it better to actually write a file separated from the original, then overwrite it once everything is done? cuz strict IO is great but can have memory issues (not with my program mind you, but in other cases)
09:58:26 <Cale> Yeah, it's better for multiple reasons
09:58:42 <Cale> One is if some other program on your system is ever trying to read the file at the same time as you're manipulating it
09:59:09 <Cale> It's generally just considered good practice to always write to temporary files and move things into place once you're done (which is usually atomic)
09:59:13 <trigone> ofc then we get the happy job of having to file a filename which isn't used already. statistically easily, but deterministically it requires at least one test for if the file exists...
09:59:18 <nickolay_> Cale: aha, I see
09:59:33 <Cale> (It would be nice if there were a handy version of writeFile which just did that...)
10:00:28 <Cale> trigone: But another way to make things work is just to avoid using lazy I/O, since it's usually regarded as confusing and potentially harmful anyway
10:00:32 <trigone> Cale: maybe there is
10:00:56 <geekosaur> except that, the more moving parts, the more there is to go wrong... and lazy I/O cannot give you useful errors, at most it can throw an exception (possibly from pure code)
10:01:16 <trigone> Cale: but in strict IO, won't it have to read the whole file to memory?
10:01:34 <Cale> geekosaur: Even if you were using strict I/O, it would be nice to have a version of writeFile like that.
10:01:39 <trigone> geekosaur: moving parts?
10:01:41 <Cale> trigone: yes.
10:01:49 <Cale> trigone: You obviously can't have it both ways
10:01:51 <monochrom> You are supposed to use your own getBuf or pipes or conduits.
10:02:23 <trigone> Cale: yeah i guess ^^
10:02:25 <Cale> trigone: If you're going to begin writing to the file before you're finished reading it, you're going to need to be much more careful than this
10:03:00 <trigone> Cale: nah, i guess i'll write onto some temporary file, it seems the best.
10:03:51 <Cale> The nice thing about using a temporary file is that usually filesystems implement file moves on the same device as atomic operations, so nobody's going to see the file halfway-written then.
10:05:04 <hpc> usually it's just changing an inode reference in the index, even
10:06:17 <geekosaur> depends on the filesystem though. (and of course anything discussing inodes is meaningless on windows)
10:06:20 <trigone> Cale: hm that's good. btw, regarding lazy IO, maybe it's naive, but i'm wondering why readFile couldn't somehow block the file for writing *after*, at least in cases when writeFile requires reading the file first (but then maybe it's impossible to prove that some writeFile requires reading the file first?)
10:06:46 <geekosaur> and beware of "atomic" filesystem operations over remote filesystems
10:06:54 <Cale> trigone: Well, on Windows, I think you might see different behaviour
10:06:57 <trigone> (prove as in, by the compiler or even the runtime)
10:07:05 <monochrom> Yeah Windows does that for you.
10:07:22 <geekosaur> in fact, part of the reason this stuff isn't smarter is you can't portably do "smarter"
10:07:25 <trigone> Cale: oh, well i don't plan on coming back to hell any time soon
10:07:42 <trigone> geekosaur: yeah i guess. it's not terribly hard to do manually anyway.
10:07:49 <monochrom> And IIUC Unix simply doesn't have file locking.
10:08:09 <geekosaur> not portably
10:08:15 <iomotoko> any good (soft) introduction to lambda calculus you guys can recommend (I lack some math skills I suppose)?
10:08:17 <monochrom> At any rate you're at the mercy of the OS to lock a file for you.
10:08:30 <iomotoko> I really want to get it properly step by step
10:08:45 <trigone> as Cale said, maybe there's a function to write to a temporary file and overwrite the original once it's done? (i do hope even lazy IO can't end up overwriting a file not yet finished to be written, right?)
10:08:50 <geekosaur> there is advisory locking (that is, the program has to check for it specifically)
10:09:08 <geekosaur> but again all bets off for remote filesystems
10:09:24 <Cale> iomotoko: Well, first of all, are you familiar with lambdas in Haskell?
10:09:51 <iomotoko> Cale: I just started w/ haskell, so no. Should I wait till I am and go from there?
10:09:52 <geekosaur> in fact ghc is currently being bitten by this, there's an issue with locking in ghc-pkg seem by some poeple with in 8.2
10:09:59 <Cale> trigone: There should be, but I always end up doing it manually...
10:10:56 <Cale> iomotoko: Yeah, I mean, it's not necessary to do it one way or another, but if your goal is to learn Haskell...
10:11:08 <geekosaur> ( https://ghc.haskell.org/trac/ghc/ticket/13945 )
10:11:50 <Cale> iomotoko: The untyped lambda calculus is a very simple language, which only has variables, application (as in function application), and abstractions (lambdas)
10:11:59 <monochrom> iomotoko: www.haskellbook.com Chapter 1 is lambda calculus without prerequisites.
10:12:12 <monochrom> err prerequisite. I hate English.
10:12:23 <Cale> monochrom: s is fine there :)
10:12:26 <elpfen[m]> I'm also interested in lambda calc and 2/3 through LYAH but is it really necessary for Haskell if I'm not doing math-heavy stuff?
10:12:58 <hpc> programming is math-heavy stuff
10:13:04 <iomotoko> monochrom: nice, thanks a bunch <3 :)
10:13:07 <hpc> it's just not necessarily numeric math ;)
10:13:12 <Cale> elpfen[m]: I mean, it's "necessary" in that you'll end up learning it just by learning Haskell anyway.
10:13:59 <Cale> Well, you might not learn how to use an untyped lambda calculus to build up everything, Church encodings of data types and all that.
10:14:30 <erisco> it is retrospectively too simple to not know, so I suggest taking a look
10:14:43 <Cale> But I actually think it's much easier to understand Church encodings once you understand algebraic data types already
10:14:45 <trigone> if i use System.Directory.renameFile, will it seamlessly overwrite a file of the same name, or do i have to erase the to-be-overwritten one first? cuz if so it won't be atomic anymore
10:15:11 <Cale> trigone: It should.
10:15:29 <trigone> Cale: ok, i'll try
10:16:41 <Cale> In order to encode the terms of an algebraic data type in the untyped lambda calculus, you just consider what would be the constructors of the type as function parameters, and build the term in the body of the lambda in terms of them
10:16:43 <erisco> no one may agree but computer science is a branch of mathematics
10:16:54 <monochrom> ooohhhh haven't seen mpickering for a while.
10:16:55 <erisco> and it enjoys being as relevant to the real world as physics
10:17:11 <Cale> So, for instance, where you might encode natural numbers in Haskell with the type  data Nat = Zero | Succ Nat
10:17:33 <monochrom> Noooooo! Computer science is a branch of electrical engineering!
10:17:51 <hpc> it's a branch of quantum mechanics now
10:17:56 <AndroUser> CS is a branch of math.
10:18:13 <monochrom> And it enjoys being as relevant to the math world as physics!
10:18:13 <Cale> Where e.g. you would represent 5 as Succ (Succ (Succ (Succ (Succ Zero))))
10:18:34 <rrode> CS is a pseudoscience
10:18:45 <Cale> In pure lambda calculus, that might become (\zero succ -> succ (succ (succ (succ (succ zero)))))
10:19:06 <monochrom> Oh I'm actually fine with getting rid of the word "science" there.
10:19:22 <geekosaur> which CS?
10:19:27 <erisco> I took a course in AI and we had to discuss if CS was an actual science
10:19:34 <AndroUser> @Cale That looks like a liked list.
10:19:35 <lambdabot> Unknown command, try @list
10:19:45 <AndroUser> *linked
10:19:50 <geekosaur> the one proceeding from hardware, the one proceeding from theory, or the one proceeding from business analysis?
10:19:51 <cocreature> erisco: did you creat an ai to answer that question
10:20:02 <erisco> the funny thing about CS is that we don't actually need empirical data
10:20:17 <erisco> we know what is right and works analytically
10:20:58 <AndroUser> CS does'nt have to be practical.
10:21:17 <monochrom> I'm so glad I played devil's advocate.
10:21:23 <AndroUser> Programming is applied CS.
10:22:01 <trigone> hence the word "application" maybe ^^
10:22:13 <nshepperd_> Just like how thinking is applied chemistry
10:23:59 <AndroUser> By how much whitespace do you guys separate your functions by? I like to give 2  blank lines between each function.
10:24:04 <trigone> doing chemistry (in a lab) would be some applied thinking, therefore some doubly applied chemistry: chemistry in a brain modifying chemistry in a lab
10:24:46 <monochrom> The average programmer uses 1.018398 blank lines between two functions.  <-- empirical science!
10:25:20 <cocreature> monochrom: now I need to find a text editor that allows me to use 1.01 blank lines
10:25:50 <hpc> use a vertical tab, then the reader can decide how many lines they want
10:26:01 <AndroUser> When theres lots of functions in a file, it start becoming hard to read for me.
10:26:02 <monochrom> hpc wins :)
10:27:37 <hpc> vertical tab just might be the stupidest character in the whole of unicode
10:28:18 <monochrom> Well they really wanted to preserve ASCII because they don't want to offend the old-geezers.
10:28:41 <monochrom> So you now have to ask whether it was the stupidest character in ASCII too.
10:28:55 <AndroUser> There should have only been 1 newline character.
10:29:03 <cocreature> dafuq, vertical tabs are actually a thing
10:29:13 <geekosaur> there's a bunch of ASCII control characters that are there to avoid annoying BAUDOT geezers
10:29:29 <erisco> AndroUser, you know why there are two, right?
10:29:41 <AndroUser> Yeah.
10:29:55 <hpc> cocreature: it's amazing what you can discover by reading the entirety of a spec
10:30:04 <AndroUser> Microsoft and Apple's fault.
10:30:07 <geekosaur> I mean, shift-in./shift-out was how BAUDOT got a usable character set with only 5 bits
10:30:10 <monochrom> Just do a "man ascii" :)
10:30:26 <erisco> AndroUser, no... have you used a type writer?
10:30:37 <hpc> cocreature: bonus weird fact: in irc, the characters "[]`" are the lower-case versions of "{}~"
10:30:59 <AndroUser> Type writer? Nope. Please elaborate.
10:31:03 <monochrom> I have used two typewriters! Two because I have used a mechanical one and I have used an electrical one.
10:31:10 <Eduard_Munteanu> I wish Haskell (and other languages) weren't text-based, but binary-encoded and alllowed a smart editor to display the code with configurable layout/indentation.
10:31:15 <geekosaur> AndroUser, the original terminals were printers/typewriters (much of Unix console / terminal behavior derives from the KSR33 printing terminal)
10:31:27 <hpc> AndroUser: one moves the paper up, the other slides the mechanism to the right
10:31:42 <geekosaur> including being able to configure delays, because carriage return was a slow operation on those things
10:31:45 <cocreature> hpc: you really like destroying everything I believed to be true
10:31:46 <erisco> AndroUser, on a typewriter there is line return (go back to the beginning of the line, \r) and new line (go to the next line, \n) and these are independent functions
10:31:56 <monochrom> binary source code is politically incorrect heresy for programmers. (I support it, of course.)
10:32:14 <erisco> AndroUser, so for example if you are on column 30 and you hit the newline button on a typewriter it goes to column 30 on the next line
10:32:19 <geekosaur> monochrom, did you take over structured haskell mode? :p
10:32:27 <monochrom> No.
10:32:28 <erisco> AndroUser, hence \r\n to both go to the start of a line and to start a new line
10:32:54 <AndroUser> OK. But in computers it should have been one, right?
10:32:59 <erisco> you can date people based on whether they know the historical difference of \r and \n :P
10:33:10 <monochrom> hpc: To the left!
10:33:25 <erisco> AndroUser, no because you used to get print outs to see what was going on in the computer!
10:33:49 <geekosaur> AndroUser, one of the first things most console UIs do is turn off the mapping of \n to do both CR and LF, so it can position the cursor with the separate operations
10:34:04 <trigone> hpc: it seems that upper/lower-case thing follows the traditional querty keyboard (to be fair i don't have one before my eyes but i think so)
10:34:17 <AndroUser> Oh. That seem quite reasonable.
10:34:48 <monochrom> AndroUser, a lot of stdio programs use the \r trick to "update the line that says how many percent of your download is done". I'm sure their author would hate the unification you're proposing.
10:35:37 <trigone> System.Directory isn't part of Base?? is there a way to rename a file without importing any package?
10:36:04 <geekosaur> trigone, it's part of the directory package which comes with the compiler
10:36:20 <geekosaur> it doesn;t change as often as ghc does, so why combine it?
10:36:21 <trigone> geekosaur: oh ok
10:36:38 <geekosaur> (base, on the other hand, must because it is closely tied to the ghc runtime)
10:36:45 <erisco> that is also why you have all the other ASCII control characters
10:36:47 <AndroUser> Has anyone here programmed in C++ for over a year? I did.
10:36:55 <AndroUser> It was hell.
10:36:59 <geekosaur> 20 years ago :)
10:37:03 <erisco> this is what you used to send over the network to communicate with and control devices :P
10:37:15 <geekosaur> g++ didn't even support STL properly at the time
10:37:15 <trigone> geekosaur: thx
10:37:23 <trigone> geekosaur: "must because"?
10:38:05 <geekosaur> trigone, base must be part of ghc and change with it, because ghc runtime changes require corresponding changes in base to connect it to the RTS
10:38:17 <trigone> oh right yeah
10:38:31 <geekosaur> even though the RTS is technically a separate package, base has to know its current API
10:38:47 <hpc> trigone: that particular upper-lower case thing is because irc was designed by someone whose native language had accented characters
10:39:16 <hpc> and those ascii codepoints were meant to correspond to accented characters
10:39:17 <geekosaur> so there's a bit of an incestuous relationship between base, rts, and (ghc-)prim because they all need to agree on API and ABI or nothing works
10:39:19 <hpc> of which there were 3
10:39:20 <erisco> bell is certainly the best ascii character, hehe
10:39:36 <erisco> the only one which explicitly makes a noise
10:39:41 <hpc> bell has well-defined behavior, and is therefore boring
10:39:57 <monochrom> Oh! The typewriter has a bell too.
10:40:20 <geekosaur> trigone, IRC assumes the Scandinavian variant of ASCII (since ASCII was specifically a US standard, its support for non-US characters was nonexistent)
10:40:23 <AndroUser> What? typewriters have bell?
10:40:30 <erisco> hell yes
10:40:43 <Rembane> Bell: \b
10:40:44 <Rembane> :D
10:40:55 <geekosaur> on manual typewriters, the bell rings at column 72 to warn you to go to the next line son
10:40:57 <geekosaur> *soon
10:41:05 <erisco> you think your keyboard is so cool but typewriters used to ring
10:41:10 <monochrom> Here: https://youtu.be/jinGW7ZDGPM
10:41:26 * Rembane goes and bolts a bell to his mechanical keyboard.
10:41:30 <trigone> geekosaur: oh ok ^^
10:41:34 <geekosaur> I think original vi had a :set for that even
10:41:50 <geekosaur> (pretty sure neither nvi nor vim does)
10:42:14 <trigone> geekosaur: a set to ring when you reach a certain column?
10:42:15 <monochrom> Someone needs to write a vim plugin for that!
10:42:16 <erisco> https://www.youtube.com/watch?v=6tbLo3lIHEM
10:42:32 <geekosaur> yep
10:42:51 <dsal> Can anyone help me kill some repetition here?  http://lpaste.net/357837
10:42:57 <geekosaur> despite even old vi having (a poor version of) autowrap
10:43:06 <dsal> I'm trying to make a readn that will take a Get function and just do the right thing, but I can't seem to express it.
10:44:07 * hackagebot aivika-distributed 0.7 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
10:44:07 * hackagebot libgraph 1.13 – Store and manipulate data in a graph. – https://hackage.haskell.org/package/libgraph
10:44:09 <geekosaur> (I do wonder why we're discussing ancient history though. I mean manual typewriters were pretty much gone when *I* was in school...)
10:44:17 <dsal> oh
10:44:24 <dsal> man.  Nevermind.  I was pulling the value out of the monad.
10:44:38 <hpc> geekosaur: sometimes we need to take a collective break from talking about *good* technologies ;)
10:46:10 <dsal> Here's the problem I've run into when I thought I was doing it right:  http://lpaste.net/357838
10:46:30 <dsal> Couldn't match expected type ‘Int64 -> B.ByteString -> Word16’ with actual type ‘Word16’
10:46:40 <monochrom> dsal: Perhaps parameterize over getWord16be, getInt16be, and getWord32be.
10:47:05 <dsal> That's what I thought I was doing.
10:47:35 <monochrom> Ah, in your 2nd paste?
10:47:50 <dsal> Yeah.  I'm trying to pass those functions in, but it's giving me an error I don't understand.
10:48:41 <monochrom> read2 n x = readn getWord16be n x
10:48:43 <dsal> @undo do {  w <- f; return w }
10:48:43 <lambdabot> f >>= \ w -> return w
10:49:06 <dsal> *sigh
10:49:37 <dsal> monochrom: Thanks.  That was really dumb.
10:50:10 <dsal> read4 = readn getWord32be
10:50:12 <monochrom> Also you have a typo in read4
10:50:20 <dsal> Yeah, got to the next error.  :)
10:50:35 <dsal> Tests pass!
10:52:01 <erisco> monochrom, the modern version is the clicks of a mechanical gaming keyboard and the ringing of profanities :P
10:52:49 <monochrom> haha
10:53:35 <ignamv> howdy
10:59:32 <erisco> anyone read Tate & Lerner 2010 "A flexible semantic framework for effects"? I am wondering if a package has been made based on this yet
10:59:52 <mustafa_> Hello everybody, My Haskell version of https getter is soooo slow compared to curl. Do you have any suggestion? https://stackoverflow.com/questions/45780131/why-is-my-https-getter-in-haskell-so-slow-compared-to-curl
11:00:32 <erisco> I am only half way through but it is becoming clear to me there is a good chance this can be made substantially better than what we use monad transformers for
11:05:07 <erisco> mustafa_, did you try using a different library?
11:05:31 <mustafa_> erisco, no, do you have any code snipped?
11:05:39 <erisco> what does that mean?
11:06:50 <mustafa_> this is only solution that I found for https request, do you know any alternative code, library etc?
11:07:18 <erisco> not personally, no, but you can search Hackage and maybe someone else here has some suggestions
11:07:48 <erisco> there may be something silly external to the library that is causing it to be slow, but it can also just be the library itself
11:07:53 <mustafa_> even if there are other libraries, it is strange that such behaviour of wreq for this site
11:08:19 <erisco> when you're troubleshooting you always try the easiest things first
11:08:43 <erisco> and since you've just got a hello world for https clients it should be easy to just try another library
11:10:01 <erisco> in regards to the paper, what they're big on is effect systems with more than one effect
11:10:54 <erisco> this has an obvious relationship with monad transformers. Part of what they detail is how to flatten these stacks
11:11:43 <erisco> and the PITA with transformers is precisely dealing with the stack
11:12:51 <erisco> so, flatten the stack, keep the multiple effects, write better code
11:14:56 <srhb> mustafa_: I think you should probably consider doing a better benchmark. Are you sending the same headers etc.
11:15:17 <srhb> mustafa_: Testing out on a 100MB binary (already compressed) file from elsewhere, I can detect no noticeable difference between wreq and curl.
11:15:23 <srhb> mustafa_: My guess is you're measuring different things.
11:17:35 <mustafa_> srhb, this difference only relevant with the given url, for example both of them gives close result what I try with https://google.com, https://twitter.com 
11:18:08 <mustafa_> shrb, please look at the comments
11:19:03 <srhb> mustafa_: Yes, I've seen the comments.
11:21:51 <mustafa_> srhb, erisco, I'm going to try another library
11:28:10 <mustafa_> srhb, erisco, I tried with http-conduit package, nothing changed.
11:30:55 <srhb> mustafa_: You could try dumping the TCP data and try to figure out if the http communication is actually identical in both cases.
11:31:07 <erisco> well cool, then either they are mutually using the same dependency that is messed up or it is something other than libraries (likely)
11:31:47 <Zemyla> So how do I introduce changes to base?
11:31:58 <erisco> connections
11:32:05 <mustafa_> srhb, I'll try tcp dump
11:32:23 <srhb> mustafa_: Good idea. Unfortunately I can't check since I appear to be blocked from the site.
11:33:18 <platz> Is it possible to give a data declaration with no type parameters a kind other than *? e.g. something like "data K; data M :: K"
11:33:43 <[exa]> erisco, mustafa_, you were talking about some paper that flattens the transformer-induced stacks of effect systems, could you please share a link? I can't find it in scrollback :(
11:33:51 <platz> ghc says "Kind signature on data type declaration has non-* return kind"
11:34:11 <erisco> [exa], do you use DDG?
11:34:34 <lyxia> Zemyla: ask on the libraries ML
11:34:42 <[exa]> nope, I just like the general idea of that.
11:35:15 <[exa]> (what's DDG acronym anyway?)
11:35:25 <erisco> platz, if you want to have a custom kind then use DataKinds
11:35:55 <erisco> [exa], DuckDuckGo, the search engine that doesn't track you (they promise)
11:36:13 <[exa]> yeah, how do you know? :D
11:36:33 <SansFr[m]> also ddg is not really good
11:36:49 <platz> erisco: the error seems to occurs even with DatKinds?
11:36:51 <erisco> DDG does fine for me, and if I don't get what I want then Google is just a bang pattern ;)
11:37:06 <hpc> i tend to use bang patterns first
11:37:12 <SansFr[m]> I found myself using !g all the time
11:37:12 <hpc> ddg is great as a search engine consolidator
11:37:21 <SansFr[m]> and then switched to searx
11:37:23 <erisco> platz, because that notation is not what DataKinds supports. With DataKinds you write an ordinary data type and then it will promote it to the type level.
11:37:23 <SansFr[m]> searx.me
11:37:33 <hexagoxel> cocreature: only the "boring" version makes sense for `rewrite`, i am mildly certain now: (Exp2 a a -> Maybe (Exp2 a a)) -> Exp2 a a -> Exp2 a a
11:37:39 <hpc> before i resort to !g, i will use !a or !hoogle or whatever
11:37:55 <erisco> [exa], anyways here it is http://cseweb.ucsd.edu/~rtate/effectstr.pdf
11:38:10 <[exa]> thanks :]
11:38:24 <erisco> the paper is not explicitly on flattening monad transformer stacks but I think the application to that is clear
11:38:36 <hexagoxel> if the transformation function is supposed to be applicable multiple times, so other approaches don't work out too well.
11:40:06 <platz> erisco: I understand with DataKinds "data K" promotes K to the type level.  then i want to say that "data M" has kind "K"
11:40:39 <platz> instead of kind "*"
11:41:50 <erisco> platz, the type constructor becomes a kind constructor and the data constructors become type constructors. That is how the promotion works.
11:42:10 <monochrom> platz, promotes K to the kind level.
11:42:34 <monochrom> Next, you should start with "data K = M". Then you have type M of kind K.
11:42:44 <[exa]> erisco: it's very related to my problem here, contains a lot of naming I'd otherwise need to reinvent badly.
11:43:12 <erisco> [exa], what problem is that? I was reading it because I wanted some idea where language research is at
11:43:15 <remexre> I'm trying to "lift" an (ExceptT Error IO Foo) to a (ExceptT Error (StateT Bar IO) Baz); I've tried lift, fmap lift, and fmap return, and still nothing; is there a standard idiom I'm missing here?
11:43:21 <monochrom> It is also the only way to declare types to be of your kind.
11:43:58 <erisco> and it caught my eye because a lot of papers are talking about effect systems, and this paper purports to give a semantics, great
11:44:12 <[exa]> erisco: trying to destroy the implicit GC for good :D
11:44:19 <erisco> regions?
11:44:50 <[exa]> linearity, defunctionalization, some c++style wrapping of the painful parts
11:45:25 <mustafa_> shrb, erisco, I tried tcpdump, and it only prints when I started to run executable, after a while tcpdump prints nothing, but program continues to work.
11:45:55 <erisco> mustafa_, I can't help you debug SSL and HTTPS... I know a little about it but not enough
11:46:11 <mustafa_> shrb, erisco, can it be related with encoding of the html page? it is utf-8 page and it has turkish characters....
11:46:34 <[exa]> mustafa_: you might want to try ettercap, it can un-encrypt https if you provide keys
11:46:48 <[exa]> (no idea whether it's still maintained though)
11:47:08 <erisco> un-encrypt... if only there was a single word for that
11:47:21 <[exa]> it's actually not decryption, just a weird hack
11:47:56 <mustafa_> exa, I think it is not related with https, as I can see from the tcpdump it receives the data perfectly, but i think it is related with the content of the page
11:48:19 <[exa]> it was an idea :]
11:48:57 <mustafa_> do haskell have any problem with latin-extended characters?
11:49:15 <erisco> mustafa_, I can only see the encoding being relevant if it is being passed through a decoder, but if you're just saving it to file I don't see why that would be happening
11:49:45 <mustafa_> erisco, hımmm yes you are right
11:49:49 <hpc> mustafa_: as in latin-1 encoding, or unicode characters?
11:49:57 <erisco> it comes in as ByteString and is written to file as a ByteString
11:50:09 <hpc> oh, nvm
11:50:58 <monochrom> Haskell does not have a problem. But your OS may.
11:51:31 <monochrom> For example Windows console has an anti-Unicode default setting.
11:52:15 <naddeoa> If I have a type class of Foo and  two instances of it, Bar and Baz, can I pass Bar and Baz in where a Foo is expected?
11:52:26 <naddeoa> particularly in lists
11:53:10 <mustafa_> erisco, I also tried with another turkish website, and I don't see this problem, it fetched the page under 200ms (real).
11:53:19 <[exa]> naddeoa: "pass Bar in" is like "argument is of type in class Bar" or "function has Bar in type signature" ?
11:53:35 <mustafa_> This very interesting, by the way thanks for the comments :)
11:54:05 <[exa]> naddeoa: first one should work, second one will probably complain about "context too weak"
11:54:41 <naddeoa> Why doesn't this work "myShowable :: Show a => a
11:54:41 <naddeoa> myShowable = "string""
11:55:13 <remexre> naddeoa: that declares that myShowable is a member of *every* type that is Show
11:55:22 <remexre> rather than *any* type that is Show
11:55:23 <[exa]> the type signature is too general, it's actually monomorphic.
11:55:35 <monochrom> Because I'm going to use myShowable as (myShowable :: Int) and you can't stop me.
11:55:54 <naddeoa> because Int is showable
11:56:09 <monochrom> The type variable means the user (me) choose. You, the author, does not choose.
11:56:23 <naddeoa> what is the any syntax?
11:56:40 <monochrom> There is no "any syntax".
11:56:49 <hpc> just press the any key
11:57:06 <monochrom> "any" is ambiguous.
11:57:37 <naddeoa> What is the equivalent of an OOP language's interface types where subypes can be in collection of the interface type?
11:57:56 <monochrom> "any" is ambiguous because it still doesn't say which side (the user? the author?) makes the choice, which is the whole point.
11:58:03 <[exa]> naddeoa: can you provide c++/java equivalent of that idea?
11:58:14 <naddeoa> Sure
11:58:19 <monochrom> There is none.
11:58:38 <naddeoa> So, I can't have a List of things that I can call showable on in Haskell for example?
11:58:48 <naddeoa> if all I care about is showing them?
11:58:48 <monochrom> Right.
11:58:55 <monochrom> @quote monochrom river
11:58:55 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
11:58:55 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
11:58:56 <lambdabot> show the_boolean, show the_character, show the_integer]
11:59:28 <naddeoa> so then there is no type inheritance 
11:59:35 <monochrom> Right. None.
11:59:39 <naddeoa> interesting
11:59:44 <monochrom> Haskell is not a subtyping language.
11:59:44 <naddeoa> I guess somehow that's ok
12:00:15 <ignamv> the objects are immutable so why delay showing them?
12:00:23 <monochrom> Subtyping is clearly not the only solution to any of the world's software engineering problems.
12:00:48 <naddeoa> So, in cases where I want people to be able to make stuff and I provide functionality on that stuff, what would we do in haskell?
12:01:03 <naddeoa> Tell them to remember to implement a class on that type?
12:01:26 <monochrom> No. A record of values and functions.
12:01:50 <naddeoa> Can you elaborate?
12:02:06 <Tuplanolla> :t filter -- Like this, naddeoa.
12:02:08 <lambdabot> (a -> Bool) -> [a] -> [a]
12:02:21 <erisco> monochrom do you have a riddle saved for every dilemma?
12:02:28 <monochrom> Not yet.
12:02:30 <naddeoa> lol
12:02:34 <[exa]> :]
12:02:44 <naddeoa> Tuplanolla: you're saying just use the generic parameters?
12:03:06 <[exa]> naddeoa: if I get you correctly, you want to write generic code that will work on other people's data structures?
12:03:22 <naddeoa> right
12:03:28 <naddeoa> well, not specifically, but it would mean that as well
12:03:42 <naddeoa> basically, an OOP interface
12:04:04 <[exa]> naddeoa: then either don't give type signatures (and your will be generic enough for free), or call the required property a class name and require that classes' members
12:04:17 <[exa]> naddeoa: similar approach is e.g. "Foldable"
12:04:36 <[exa]> (at least it has more useful examples than Show)
12:04:46 <monochrom> Maybe a class is good. It depends on what you mean by "make stuff" and "functionality on stuff". At this point it's all fluff, not stuff.
12:05:09 <monochrom> The problem with how most people approach software engineering.
12:05:17 <Tuplanolla> You might need a class, but often a function as an argument is enough, naddeoa.
12:05:57 <[exa]> naddeoa: btw I guess that by "OOP interface" you mean something like purely virtual class from C++?
12:06:06 <naddeoa> Closer to Java
12:06:36 <[exa]> so the concept "Objects of type X have this interface implemented"
12:06:42 <nshepperd> oop is only necessary in languages that don't have first class functions
12:07:08 <naddeoa> It just says "this type has these things" and I can do this "List<Interface> bigList = sutypeAList ++ subtypeBList"
12:07:25 <naddeoa> I'm thinking this is a side effect of my choice to use a type class instead of a big data
12:07:27 <Tuplanolla> Contrast `HasInt s => s -> Result` with `(s -> Int) -> s -> Result`, naddeoa.
12:08:28 * hackagebot executor 0.0.2 – Shell helpers – https://hackage.haskell.org/package/executor
12:08:28 * hackagebot currencies 0.1.1.0 – Currencies representation, pretty printing and conversion – https://hackage.haskell.org/package/currencies
12:09:01 <naddeoa> lol I think that's above me Tuplanolla
12:10:10 <[exa]> naddeoa: well multi-type lists are doable with existential types AFAIK, but it's usually an overkill (observe that this is the reason for RTTI in otherwise pretty much purified C++)
12:12:05 <[exa]> the usual style is to name all the possibilities of the list contents as variants of a single datatype. Not very module-extensible, but usually brings some clarity to the code.
12:12:43 <naddeoa> So I'll make a new 'data' for this purpose essentially
12:12:49 <nshepperd> naddeoa: your function on the user's type can just accept extra arguments for all the "methods" that you need on that type
12:13:12 <naddeoa> Haskell is pretty old and people don't seem to miss that ability. I'll have to just think about it differently I guess
12:13:42 <naddeoa> It seems like all the pieces are there
12:14:00 <remexre> naddeoa: this might be helpful to read: https://two-wrongs.com/dynamic-dispatch-in-haskell-how-to-make-code-extendable
12:14:02 <monochrom> No, OOP is older.
12:14:22 <naddeoa> thanks I'll check that out
12:14:25 <[exa]> naddeoa: also, functional trick is to use the functions. Do you know you caan transparently "save" any kind of information in interface functions?
12:15:51 <naddeoa> exe, can you go on?
12:15:59 <naddeoa> remexre, that looks like exactly what I was doing
12:16:20 <remexre> naddeoa: the third ("Dynamic Dispatch in Haskell") section?
12:16:22 <[exa]> naddeoa: the funny example is something like this:  addToList l a = \s -> if s==a then True else l s  ;  emptyList = False ;  isInList l a = l a
12:17:09 <naddeoa> remexre just the setup so far, I haven't gotten to the solutions. I started with a big data, then moved to type classes and then ran into the issue he's talking gabout
12:17:28 <remexre> Yeah, the third section basically describes the idiomatic solution
12:17:38 <nshepperd> naddeoa: in java you might do 'printAListOfThings(List<Showable>)', in haskell you might do 'printAListOfThings :: (a -> String) -> [a] -> IO ()'
12:18:10 <nshepperd> or indeed 'Show a => [a] -> IO ()', or '[String] -> IO ()'
12:18:48 <[exa]> naddeoa: in other words, if the interface is the same and only the form of data differs, save the data in the interface and, instead of changing the data, modify the interface to reflect these changes
12:19:01 <nshepperd> all that java interfaces do really is provide functions. you can just give those as arguments instead
12:19:07 <[exa]> naddeoa: looks terribly wrong from java point of view, but it's surprisingly efficient in Haskell
12:20:10 <naddeoa> nshepperd, yeah that seems ok, but I was hoping to combine different collections of Show into a single one and then just run map on it
12:22:50 <Logio> naddeoa: only collections of a single concrete type are possible, so you'll need to apply show on the collections beforehand
12:23:28 <Logio> (or possibly something else that maps each collection to its')
12:23:41 <Logio> *to a single type, I meant
12:24:05 <naddeoa> So this must mean that when you make a type class you don't actually create a new type right
12:25:16 <Logio> correct
12:26:31 <naddeoa> Would that be bad?
12:26:40 <naddeoa> Do people specifically not want Haskell to be able to do that/
12:26:53 <naddeoa> (use type classes as types in and of themselves)
12:27:06 <tdammers> how would that even work?
12:27:10 <erisco> there is something called existential type classes where classes are types
12:27:13 <dolio> Type classes aren't types.
12:27:18 <geekosaur> typeclasses are not intended to be OOP types
12:27:31 <geekosaur> @google making ad hoc polymorphism less ad hoc
12:27:32 <lambdabot> https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf
12:27:34 <erisco> which makes them like OO types
12:27:46 <geekosaur> it's a way to constrain polymorphism
12:27:48 <nshepperd> usually you do not actually need to put different types of object in the same list. Generally 'a list of what?' has a single answer once you think about it harder
12:27:52 <tdammers> erisco: if you squint a lot
12:28:57 <tdammers> nshepperd: that, or else you can reformulate the problem as 'what are you going to do with the things in the list?'
12:29:04 <erisco> always wear your safety squints before looking at bad analogies
12:29:38 <naddeoa> Well, if type classes made types then those questions wouldn't be hard to answer right? Its a type and the only functions that work on it are ones defined in the type class
12:30:09 <naddeoa> Would it be any different from data types?
12:31:25 <nshepperd> these questions aren't hard to answer, you just need to unlearn oop
12:31:31 <nshepperd> type classes aren't types, they are predicates
12:31:45 <tdammers> naddeoa: that's not even how types work, actual types that is, not the stuff they teach you in OOP
12:31:48 <nshepperd> 'type a is Showable' is a fact
12:32:20 <Zemyla> But yeah, I was thinking that there really should be a type constructor added to the internal P type in Text.ParserCombinators.ReadP.
12:32:44 <Zemyla> It'd be data P a = ... {- stuff from before -} | Skip {-# UNPACK #-} !Int (P a).
12:35:16 <erisco> naddeoa, in OOP you can define functions which work on a class that are not methods of that class
12:35:48 <naddeoa> right, because of inheritance
12:36:38 <erisco> no, because you can just define a function that has a parameter type of a particular class
12:37:52 <erisco> mind you instead of "function" they might call it "class method" or "static method" but it is close enough
12:38:18 <Zemyla> And I think skipping that way is more efficient than doing Get repeatedly.
12:39:31 <nshepperd> iirc rust has syntactic sugar for pretending that traits (the equivalent of type clases) are types. imo this is a bad feature that encourages the bad habit of not unlearning oop. and also makes accidental existentials too easy to write
12:39:56 <naddeoa> oh you're talking about class methods erisco. In something like python it just passes the self variable to itself for you 
12:39:59 <erisco> you do this all the time anyways... you have methods which have parameter types of classes other than the one the method belongs
12:40:25 <erisco> in Python you can just define a function... doesn't have to be in a class
12:40:55 <erisco> in Java and C# everything has to be stuck into a class, for some reason
12:41:14 <erisco> so you essentially have classes serving as no more than namespaces, but whatever
12:41:14 <tdammers> erisco: the reason being that "OOP is good for you, you must use it at all times"
12:41:43 <dolio> I don't know if that's the reason.
12:41:46 <nshepperd> "everything is a class, except the stuff that matters"
12:42:02 <dolio> Seems like the reason might be the low level implementation leaking into the surface language.
12:42:07 <hpc> i wonder if in a more imaginative language, having types = namespaces would enable something more powerful
12:42:35 <ezrios> @pl \x -> x
12:42:36 <lambdabot> id
12:42:48 <tdammers> dolio: idk, it looks like a pretty conscious design decision to me - allowing `null` to be passed as the `this` parameter, and supporting syntax for free functions, isn't really difficult, is it
12:42:48 <erisco> hpc, I have wanted some system of open types
12:43:17 <dolio> I don't think it's difficult.
12:43:34 <ezrios> @pl \(x, y) -> (f x) `g` (f x)
12:43:34 <lambdabot> liftM2 g f f . fst
12:43:35 <naddeoa> tdammers, in Java, you would just use static methods for everything I suppose
12:43:47 <ezrios> @pl \(x, y) -> (f x) `g` (f y)
12:43:47 <lambdabot> uncurry ((. f) . g . f)
12:43:48 <dolio> But I think it's pretty well known that javac does very little fancy translation.
12:44:33 <dolio> And mostly the language is a nicer syntax for bytecode features, and classes are kind of units of code and data at that lower level.
12:45:01 <tdammers> sure, but you could easily model free functions with little more than syntax sugar
12:45:28 <tdammers> idk, make an implicit class for the current module, and make all free functions in that module static functions of that class
12:45:40 <tdammers> no changes to the bytecode layer needed, just some syntax sugar
12:46:33 <Camm> Hey anyone using cassava or cassava-megaparsec? Does anyone of you know how I could parse a CSV file and get a list of all the parsed errors? Both libraries fail in the first error occurrences and I'd like to continue parsing the whole file and collect the ParseErrors. May you know how could I do this?
12:46:34 <naddeoa> Yeah I suppose is just a philosophical thing. Clojure didn't have an issues doing it. I can't imagine Java doing that.
12:47:58 <dolio> I mean, of course you can do it. Scala lets you do something like that. There are objects that correspond to each package, and all their methods are in scope when importing that package.
12:48:14 <dolio> But Java doesn't do things like that, typically.
12:49:16 <tdammers> anyway, I'm still not convinced; if the designers of Java had wanted free functions, they could have added them to the bytecode. Java bytecode was modelled to support Java, not the other way around.
12:51:01 <naddeoa> tdammers I suspect they weren't interested 
12:51:07 <Zemyla> I'm thinking that the changes would mostly be internal, but that there would be a skip :: Int -> ReadP () function added to the public interface.
12:51:29 <tdammers> naddeoa: exactly; "everything happens inside a class" is a core language design principle in Java
12:51:38 <naddeoa> definitely 
12:51:54 <naddeoa> I mean, I'm ok with that I think
12:52:05 <naddeoa> I do have to use java most of the time for work
12:52:14 <Tuplanolla> That would probably be an easy change considering how few people use `ReadP` directly, Zemyla.
12:52:35 <tdammers> java has kind of spoiled a whole generation of programmers
12:53:18 <naddeoa> if by that you mean that they aren't interested in learning different programming styles, then I think that was going to happen no matter what the most popular language was
12:53:47 <hpc> the problem is there being a single most popular language
12:53:55 <hpc> which admittedly isn't the case anymore
12:54:03 <hpc> but the top 10 are still basically the same thing with different syntax
12:54:16 <tdammers> I mean that it has produced a monoculture that cemented certain ideas in the culture, so much that most people don't even question them
12:54:20 <naddeoa> Elm is what brought me here to be fair
12:54:22 <tdammers> and some of those ideas are pretty bad
12:55:29 <tdammers> hpc: I'd say the top 10 are flavors of the same two things; baroque semi-typed class based OOP languages, and dynamic untyped class-based or almost-class-based OOP languages
12:55:31 * maerwald tries to imagine how C and Java are the same thing with different syntax
12:55:36 <Zemyla> Tuplanolla: Yeah, and it doesn't have to be added to the ReadPrec module directly, since you can simply go readP_to_Prec $ const $ ReadP.skip n.
12:55:40 <tdammers> also, yeah, C
12:55:48 <hpc> tdammers: they're still the same thing
12:55:52 <maerwald> lol
12:56:10 <maerwald> like haskell and ocaml are the same thing, right
12:56:10 <hpc> i would argue that java is an untyped class-based OOP language with a picky compiler
12:56:13 <tdammers> then again, the recurring theme is "shared mutable state and glorified goto as the main drivers of program flow"
12:56:13 <hpc> the way most people use it
12:56:45 <hpc> is C still in the top 10?
12:56:49 <tdammers> yes
12:56:51 <tdammers> embedded
12:57:03 <hpc> ah fair
12:57:06 <tdammers> also systems programming, drivers and such
12:57:27 <hpc> it's surprising that there's still enough of that to keep it up there
12:57:35 <maerwald> not at all
12:57:40 <hpc> with how much web-based programming and such have exploded
13:01:37 <gauss> Hello
13:01:45 <tdammers> but then again, a lot of web programming is just glorified wordpress installation
13:01:55 <gauss> How does one learn how to implement CAS and theorem provers?
13:02:29 <erisco> gauss, what does CAS stand for?
13:02:40 <gauss> erisco: Computer Algebra System
13:02:52 <gauss> erisco: Think, maxima, mathematica, sage, axiom
13:02:59 <erisco> no idea what that is, but type theory is a good place to go for theorem provers
13:03:03 <gauss> s/Think,/Think/
13:03:22 <gauss> erisco: It's just a way to do symbolic (mostly) math on a computer
13:03:42 <erisco> okay. I don't know anything about such systems
13:04:09 <gauss> erisco: No worries :)
13:04:26 <monochrom> hpc: I am skeptical about type=namespace the same way I am skeptical about type=specification. The common reason: I will have a function that talks about several types---the interaction of those types, so now this function does not belong to any particular type, namespace-wise or specification-wise.
13:05:35 <erisco> monochrom, why can't you view (->) as a constructor of specifications?
13:05:52 <monochrom> Similarly die-hard hardcode OOP has the same problem. I will have a procedure that interacts several classes/objects and does not belong to any particular one of them.
13:06:18 <koz_> Yeah, single dispatch is crippling.
13:06:27 <koz_> And requires ugly hacks like the 'visitor' 'pattern'.
13:06:38 <koz_> (yes, two sets of air quotes are needed here)
13:07:05 <erisco> haha, that is how you end up with a meet-semilattice :P
13:08:15 <monochrom> erisco, clearly (->) is a constructor of specifications, one of many, and this is objectively true and does not need my view. But it doesn't refute my view either.
13:09:15 * hackagebot fizzbuzz-as-a-service 0.1.0.1 – FizzBuzz as a service. – https://hackage.haskell.org/package/fizzbuzz-as-a-service
13:09:24 <hpc> ahahahahaha
13:09:27 <erisco> for every set of classes there is a class whose purpose is the union domain of the set
13:10:16 <dmwit> monochrom: Are you objecting to "a dependent type is a specification", or "specifications should be connected to a type constructor" or something else?
13:10:44 <dmwit> Or: I don't understand the meaning of "type=specification". I believe I understand the meaning of "type=namespace".
13:12:38 <tdammers> the "class" concept in Java overloading multiple concerns is indeed a strikingly bad design decision
13:13:28 <dminuoso> why is 'return' called 'return' ?
13:13:39 <hpc> dramatic irony
13:13:59 <skeuomorf> dminuoso: To weed out imperative programmers
13:14:00 <Rembane> Somebody was unlucky
13:14:43 <dminuoso> skeuomorf, that does not sound convincing
13:15:00 <tdammers> "return a value 'into' the Monad"
13:15:17 <skeuomorf> dminuoso: It shouldn't, it was a joke
13:16:03 <dminuoso> tdammers, naively I would have expected this to be called `pure`, but based on my research that was not done for historical reasons
13:16:33 <tdammers> dminuoso: Monad was discovered before Applicative, and things weren't as obvious then as they are now
13:17:04 <tdammers> these days, return == pure
13:17:24 <hpc> incidentally, only in the past year or so has the Functor => Applicative => Monad relationship been fixed
13:17:24 <dminuoso> tdammers, is that a constraint or requirement?
13:17:57 <dmwit> What is the difference between a constraint and a requirement?
13:18:20 <tdammers> it used to be just a convention, but since AMP has hit, it's mandatory
13:19:21 <tdammers> every Monad automatically forms an Applicative (because you can write all Applicative methods in terms of Monad methods), but pre-AMP Haskell doesn't enforce it
13:21:45 <erisco> dmwit, I have not read a formal concept of specifications as types but in passing I have read that
13:22:33 <erisco> dmwit, the spirit is that the specification describes what a valid implementation must be, and therefore any of those implementations may be used
13:23:36 <erisco> dmwit, but saying types are specifications may be stretching what should be involved in a type or limiting what could be involved in a specification
13:24:36 <erisco> for example, we might specify that a function must be total, but this needn't be part of the type of the function
13:24:50 <erisco> we can do a different analysis other than type checking to determine if the function is total
13:26:15 <dminuoso> dmwit, I dont know. It just occured to me, that comparing the Haskell Report with the Gentle Introduction while I'm learning might be better. :-)
13:31:53 <monochrom> dmwit: I may have an equational specification, which means it consists of a lot of equations (with forall's over its variables). For example one of them may go like "f . g = id". Does this equation belong to: (A) the type of f? (B) the type of g? (C) the type of id? (D) none of the above?
13:32:23 <monochrom> So this is just another incarnation of the single-dispatch fallacy.
13:35:34 <monochrom> Type theory is also pretty clumsy for equational reasoning. (Generally, everything that looks like natural deduction is.)
13:47:11 <Tuplanolla> I was wondering how one should handle the situation that comes up with, say, semirings and monoids: for a given type, a semiring with (+, *, 0, 1) depends on (+, 0) and (*, 1) being monoids.
13:48:47 <Tuplanolla> We have `Sum` and `Product` representing those monoids, but we can't compose them in a meaningful way to form the resulting semiring.
13:54:40 <Logio> Tuplanolla: I remember being a bit miffed about this earlier
13:55:56 <Logio> there's only the related instances for Num a => Sum a, Prod a, which is backwards IMO
13:56:10 <Tuplanolla> I could form the classes `AdditiveMonoid` and `MultiplicativeMonoid` and lift the monoids in question manually, but that's disgusting and only works in this particular case.
13:56:40 <lyxia> http://lpaste.net/357843
13:57:10 <lyxia> Tuplanolla: ^  AdditiveMonoid = Monoid . Sum    MultiplicativeMonoid = Monoid . Product
13:58:28 <Tuplanolla> Oh, that's nice. lyxia.
13:58:52 <erisco> does that expire? darn, how do I keep this as a bookmark
13:59:49 <Tuplanolla> Does this implementation have any downsides?
14:00:55 <monochrom> erisco: I think it doesn't expire. Bookmark that url. (I do this all the time.)
14:01:31 <monochrom> Caveat emptor: There is of course always the possibility of accidental data loss at the server.
14:01:44 <monochrom> In fact I think it happened once a long time ago.
14:03:22 * hackagebot stratux-types 0.0.9 – A library for reading JSON output from stratux – https://hackage.haskell.org/package/stratux-types
14:04:36 <erisco> that's one of those ideas where you say "duh! why didn't I think of that!"
14:04:38 <lyxia> I haven't gotten the opportunity to use it, I can't think of any downside yet.
14:05:55 <monochrom> Yes, downside: Now how do I say "(Bool, &&, /=, False, True) is a ring because (Bool, /=, False) is a monoid and (Bool, &&, True) is a monoid"?
14:06:50 <koz_> Huh, I never considered Bool a monoid under /=. Interesting./
14:07:09 <monochrom> OK I guess "Sum Bool" and "Product Bool" are not that far-fetched.
14:07:20 <hpc> do (&&) and (/=) distribute?
14:07:26 <Eduard_Munteanu> koz_, that's just xor
14:07:35 <Tuplanolla> Aren't there several choices for those, monochrom?
14:08:13 <monochrom> There are several choices for Int, too.
14:08:38 <erisco> monochrom, well I think it could be possible if you were willing to define /= as GADT
14:08:56 <monochrom> In fact, (Word32, .&&., xor, 0, 0xffffffff) is a ring, too. :D
14:09:00 <erisco> and && of course :)
14:09:41 <koz_> Eduard_Munteanu: Good point.
14:09:59 <Tuplanolla> Everything has too much structure.
14:10:23 <erisco> lets talk about magmas
14:10:47 <Eduard_Munteanu> Things are getting hot in here.
14:10:51 <monochrom> It is why I proposed this crazy https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html
14:10:59 <Tuplanolla> How many recipes form magmas over food items?
14:11:18 <hpc> when a magma is above ground it's called a groupoid
14:11:54 <monochrom> haha
14:12:03 <monochrom> Not "volcanic vomit"?
14:12:18 <erisco> ah yes I did come across that idea but haven't had the chance to employ it
14:12:59 <lyxia> That downside applies to type classes in general, not just that ring thing.
14:14:00 * hackagebot stratux-http 0.0.9 – A library for using HTTP with stratux – https://hackage.haskell.org/package/stratux-http
14:14:00 * hackagebot stratux-websockets 0.0.9 – A library for using websockets with stratux – https://hackage.haskell.org/package/stratux-websockets
14:21:53 <erisco> ('True, 'True) :: *  how is that... is the syntax to pattern match a tuple different?
14:22:31 <lyxia> '( 'True, 'True) :: (Bool, Bool)
14:23:05 <erisco> ah you need a space! how sneaky
14:24:00 <trigone> hi! is this normal? -> i was trying to use the constraint Applicative f =>, after having imported (<|>) (with `import Control.Applicative ((<|>))`), and ghc tells me: Not in scope: type constructor or class ‘Alternative’     Perhaps you want to add ‘Alternative’ to the import list
14:24:31 <ignamv> ghc wants you to broaden your musical interests
14:24:44 <lyxia> haha
14:25:03 <trigone> i thought classes were automatically imported in the background?
14:25:09 <lyxia> trigone: did you mean to use the constraint Alternative f =>
14:25:14 <lyxia> No they aren't.
14:25:17 <trigone> lyxia: well yeah
14:25:17 <Tuplanolla> Only instances are, trigone.
14:25:34 <trigone> weird, it's the very first time i have come across that...
14:25:41 <trigone> how can i import a typeclass?
14:25:48 <trigone> (whatever that means)
14:26:07 <lyxia> import Control.Applicative (Alternative((<|>)))
14:26:26 <lyxia> import Control.Applicative (Alternative, (<|>))  -- either works, I believe
14:26:27 <trigone> lyxia: hm ok...
14:26:47 <trigone> thx!
14:26:55 <lyxia> Somewhat like a datatype and its constructors
14:27:11 <Tuplanolla> @let import qualified Control.Applicative (Alternative (..)) as A
14:27:12 <lambdabot>  Parse failed: Parse error: as
14:27:20 <Tuplanolla> @let import qualified Control.Applicative as A (Alternative (..))
14:27:22 <lambdabot>  Defined.
14:27:36 <Eduard_Munteanu> Typeclasses should qualilfy as type constructors.
14:28:36 * hackagebot stratux 0.0.9 – A library for stratux – https://hackage.haskell.org/package/stratux
14:55:20 <ezrios> how can I create a Word64 that is outside the Int range -9223372036854775808..9223372036854775807 ?
14:55:25 <ezrios> I'm trying to use toEnum
14:57:04 <bxc> ezrios: my ghci prompt lets me use 18446744073709551615 as a literal
14:57:27 <lyxia> > maxBound :: Word64
14:57:29 <lambdabot>  18446744073709551615
14:57:52 <nitrix> If Haskell was more distributed using message-passing (think cloud-haskell/distributed-process) and supporting hotpatching (think Erlang), how does one convert queued messages of older data types to newer data types?
14:58:16 <Rembane> I think acid-state tries to do this.
14:58:27 <Rembane> But in another context.
14:59:02 <nitrix> Apriori, one look at the AST and compares the old format and the new format, but all my attempts to consider a solution failed as soon as you introduce a user refactoring the name of the fields.
14:59:12 <nitrix> Rembane: Good call, I'll have a look :)
14:59:31 <Rembane> nitrix: Good luck! ^^
15:01:20 <nitrix> I think what's going to happen is that the arguments of functions will be numbered and if you change the signature in a way that's impossible for the compiler to infer if you've renamed something or deleted+added a new thing, it'll ask you to use the numbers to perform the association.
15:02:02 <bxc> you're going to have a hard time trying to make that work in general
15:02:07 <bxc> automatically
15:02:12 <Tuplanolla> What if, instead of editing your program, you wrote a program that does the editing and can thus do the conversions, nitrix?
15:02:26 <nitrix> A more clever system would look at the usage sites but nothing prevents someone from refactoring the name of an argument while also changing the function's body.
15:02:37 <nitrix> Tuplanolla: But isn't that how everybody does it? It's painful :(
15:02:37 <bxc> nitrix: what if I change the data without changing the name?
15:03:01 <Tuplanolla> It could be tied to semantic text editors, nitrix.
15:03:15 <Tuplanolla> I'm not saying this is a good idea.
15:03:30 <xzhu1> Hi, I was trying to read a csv file, parse the record, and insert the records into a sqlite database
15:03:32 <nitrix> Tuplanolla: Ohoh! I love when you give me new words to Google :) Let's get on an adventure!
15:03:52 <xzhu1> I'm using Cassava for CSV parsing and Persist for making SQL queries
15:04:16 <xzhu1> One question is: how do I derive generic from a type generated by TH?
15:04:29 <xzhu1> say I have this code
15:04:33 <xzhu1> share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
15:04:34 <xzhu1> Person
15:04:36 <xzhu1>     name String
15:04:38 <xzhu1>     employment Employment
15:04:40 <xzhu1> |]
15:04:53 <xzhu1> how do I derive "generic" for "Person"?
15:05:09 <lyxia> xzhu1: you can try StandaloneDeriving
15:06:02 <n_blownapart> just heard, FP:  Once you understand it, you lose the ability to explain it to others.
15:06:29 <Rembane> :D
15:06:52 <Rembane> n_blownapart: There are some who retain the ability.
15:07:53 * hackagebot executor 0.0.3 – Shell helpers – https://hackage.haskell.org/package/executor
15:08:54 <xzhu1> lyxia: so "deriving instance Generic Person"?
15:08:56 <monochrom> I don't think there is anything to lose.
15:09:23 <monochrom> Before you understood it, you never had the ability to explain it in the first place.
15:09:52 <monochrom> You did have the ability to misrepresent it, though.
15:10:00 <lyxia> xzhu1: yeah
15:10:11 <n_blownapart> funny
15:10:42 <monochrom> It is also not just FP. True for OOP, physics, chemistry... almost everything.
15:10:53 <monochrom> Cf. the Dunning-Kruger effect.
15:13:37 <stevenxl> Hi folks. I am trying to use stack to build a project. I have a .cabal file and I want to use set the -Wall flag to be used anywhere. Can this be set in the .cabal file?
15:13:41 <stevenxl> Or maybe in the .stack?
15:14:46 <xzhu1> lyxia: It doesn't seem to work ... first of all I had to also enable DeriveAnyClass
15:15:16 <xzhu1> lyxia: then it says "No instance for (GHC.Generics.Generic Movie)                                                                                                                                                                                             "
15:15:18 <xzhu1>         arising from a use of ‘cassava-0.4.5.1:Data.Csv.Conversion.$dmparseRecord’
15:15:41 <xzhu1> BTW the code I have is "share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|                                                                                                                                                                       "
15:15:42 <xzhu1> Movie                                                                                                                                                                                                                                          
15:15:44 <xzhu1>   color String                                                                                                                                                                                                                                 
15:15:46 <xzhu1>   director_name String                                                                                                                                                                                                                         
15:15:48 <xzhu1> |]                                                                                                                                                                                                                                             
15:15:50 <xzhu1>                                                                                                                                                                                                                                                
15:15:52 <xzhu1> deriving instance FromRecord Movie                                                                                                                                                                                                             
15:15:54 <xzhu1> deriving instance ToRecord Movie                                                                                                                                                                                                               
15:18:31 <pikajude> huh
15:18:32 <nitrix> xzhu1: It's good etiquette to use a paste site on IRC. Haskellers seems to use lpaste.net.
15:18:38 <pikajude> are those newlines inside the messages
15:18:49 <pikajude> how have you managed that
15:19:16 <xzhu1> nitrix: thanks I'm checking it out
15:19:26 <kadoban> pikajude: I think they're a bunch of spaces
15:19:32 <pikajude> oh
15:19:38 <pikajude> same question
15:19:53 <kadoban> Not sure how it's possible to copy/paste from any editor and end up with that
15:20:20 <Clint> you need to imagine an even worse editor or terminal
15:20:33 <nitrix> Terminal most likely.
15:23:05 <lyxia> xzhu1: You need DeriveGeneric to derive Generic. You don't need "deriving" for FromRecord/ToRecord.
15:23:19 <lyxia> xzhu1: and your paste doesn't include "deriving instance Generic Movie"
15:28:00 <xzhu1> lyxia: Oops ... wrote it too fast ...
15:29:59 <xzhu1> lyxia: still an erro this time: http://lpaste.net/357853
15:30:22 <lyxia> xzhu1: what error
15:31:04 <xzhu1> this time it's "    • No instance for (Generic (Key Movie))                                                                                                                                                                                                    
15:31:04 <xzhu1>         arising from a use of ‘aeson-1.1.2.0:Data.Aeson.Types.FromJSON.$dmparseJSON’"
15:31:29 <xzhu1> lyxia: seems like it's expecting (Key Movie) instead of Movie
15:31:32 <nitrix> Tuplanolla: Interesting, I think I'm being fooled. The name of the function arguments barely matter (other than finding the usages in the function's body). What you end up doing is building a directed acyclic graph, with nodes representing your arguments and nodes representing usage sites. Then adding/removing arguments/sites modifies the graph and in the end you're doing graph differential analysis.
15:31:35 <Camm1> Has anyone used cassava-megaparsec?
15:31:49 <xzhu1> I thought Movie is the type of the record?
15:31:50 <nitrix> Tuplanolla: Actually, this could probably be a category o:
15:32:06 <xzhu1> I'm investigating what is this (Key)
15:32:23 <lyxia> xzhu1: Well it did ask Generic Movie earlier. So you also need to derive Generic (Key Movie) somehow.
15:32:55 <lyxia> xzhu1: What I meant is that both may be necessary to derive whatever it is you're deriving.
15:34:19 <xzhu1> lyxia, looks like writing "deriving instance Generic (Key Movie)" is not legal
15:35:02 <lyxia> xzhu1: what is this Key thing
15:35:23 <Zemyla> Wait, (:[]) is called the orangutan face operator?
15:35:56 <xzhu1> lyxia, it's from Aeson
15:36:12 <Rembane> Can you combine that with FRP?
15:36:15 <xzhu1> :i Key
15:36:34 <xzhu1> lambdabot :/
15:37:25 <Clint> xzhu1: isn't it https://hackage.haskell.org/package/persistent-2.7.0/docs/Database-Persist-Class.html#t:Key ?
15:38:47 <koz_> Zemyla: That's the first I've heard of it. But then again, a lot of those operators don't seem to have canonical names.
15:38:49 <lyxia> xzhu1: ^ that looks more like it. What does your error say exactly
15:39:43 <xzhu1> Yeah it seems like so ... my Intero could not find the correct definition I guess
15:41:35 * hackagebot data-forest 0.1.0.5 – A simple multi-way tree data structure. – https://hackage.haskell.org/package/data-forest
15:41:35 * hackagebot mvc 1.1.5 – Model-view-controller – https://hackage.haskell.org/package/mvc
15:41:58 <xzhu1> Hold on, I'm cleaning my code a bit so it's easier for me to copy and paste
15:43:28 <Clint> xzhu1: you might want to have persistent-th make your instances for you
15:44:07 <xzhu1> Clint, how should I do that? I would like to actually
15:44:16 <Clint> xzhu1: https://hackage.haskell.org/package/persistent-template-2.5.2/docs/Database-Persist-TH.html
15:49:30 <xzhu1> Clint, I noticed that there's a function called "mpsGeneric :: MkPersistSettings -> Bool"
15:49:44 <xzhu1> This one sounds like what I need
15:50:01 <xzhu1> But I still don't understand how am I supposed to use it?
15:50:37 <Clint> it's a field of MkPersistSettings
15:51:17 <xzhu1> Wait ... it is enabled by default
15:52:33 <Clint> xzhu1: no, https://hackage.haskell.org/package/persistent-template-2.5.2/docs/src/Database-Persist-TH.html#mkPersistSettings
15:53:35 <xzhu1> Ha. In the documentation it says "... Default: True." But I guess that's a typo (or out-dated)
15:54:30 <Clint> you should file a bug
15:55:40 <xzhu1> You mean to file a bug to its github?
15:55:48 <Clint> yes
15:59:47 <xzhu1> Clint, https://github.com/yesodweb/persistent/issues/691
16:00:31 <ignamv> do real applications use this wonderful Peano types madness?
16:00:55 <Clint> xzhu1: good work
16:04:15 <xzhu1> Clint, seems like even after setting this option to "True", I would still have to "deriving instance Generic Movie"
16:04:32 <xzhu1> Even though "deriving instance Generic (Key Movie)" is no longer necessary
16:25:15 <xzhu1> Clint: I think mpsGeneric is not what I wanted
16:26:32 <xzhu1> Although it does generate instances for different *backend* types, it does not generate an instance for GHC.Generic
16:34:16 * hackagebot human-text 0.1.0.2 – A lawless typeclass for converting values to human-friendly text. – https://hackage.haskell.org/package/human-text
16:34:16 * hackagebot human-parse 0.1.0.2 – A lawless typeclass for parsing text entered by humans. – https://hackage.haskell.org/package/human-parse
16:45:43 <nitrix> Tuplanolla: Ah! I found previous related work!
16:45:46 <nitrix> http://www.cs.umd.edu/~mwh/papers/tos.pdf
16:47:46 <erisco> monochrom, to answer your question, something like this, I think http://lpaste.net/357855
17:30:41 <dsal> If I define a type as wrapping another type with "newtype" -- how do I convert back to the wrapped type?
17:30:54 <Lokathor> dsal, use pattern matching as normal
17:31:04 <dsal> Ah.  OK.  Thanks.
17:31:06 <Lokathor> or, if you like, you can expose an unwrapper function to the public
17:31:17 <Lokathor> depends on how you intend the newtype to be used
17:31:26 <dsal> This works pretty well.
17:53:16 <xzhu1> nitrix: Hi I hope you are still there. I still haven't gotten it to work
17:53:21 <siddhu> hey, quick question. I have a function, f a b = fmap a . b . a; I know I've seen this pattern, before, but I forgot what its called. any hints?
17:53:35 <xzhu1> Here is how my code looks right now: http://lpaste.net/357859
17:53:55 <koz_> :t fmap a . b . a
17:53:57 <lambdabot> error:
17:53:57 <lambdabot>     • Couldn't match expected type ‘a0 -> b’ with actual type ‘Expr’
17:53:57 <lambdabot>     • In the first argument of ‘fmap’, namely ‘a’
17:54:00 <xzhu1> GHC complains that "No explicit implementation for ‘CSV.parseField’"
17:54:12 <Rotaerk> :t \a b -> fmap a . b . a
17:54:14 <lambdabot> Functor f => (a -> b) -> (b -> f a) -> a -> f b
17:56:26 <siddhu> I should also mention that a is its own inverse. So (a . a) = id
17:58:00 <xzhu1> I'd be grateful if anyone seeing this could help, here is the question
17:58:35 <xzhu1> I'm write a simple program that reads records from a CSV and puts them into a sqlite database
17:58:41 <xzhu1> writing*
17:59:09 <xzhu1> I'm looking for a way to avoid writing the record parser
17:59:38 <xzhu1> This should be possible considering that all type information is written in the schema already
17:59:53 <xzhu1> here is what I have gotten so far: http://lpaste.net/357859
18:00:51 <xzhu1> so "Person" is the record type, in HT it's clear that it has two fields: name :: String, and age :: Int
18:03:31 <xzhu1> In this case I could have written an instance of "CSV.FromField" for "Person"
18:04:06 <xzhu1> Oh shoot ... I just found the problem in my code myself ...
18:04:23 <xzhu1> Alright it works now :)
18:05:11 <xzhu1> in case anyone is wondering I mistakenly wrote "Either String (Vector [Person])" for the parsed type instead of "Either String (Vector Person)"
18:05:17 <xzhu1> I feel stupid now
18:15:28 <dsal> Is there an hunit thing that is useful for doublees?
18:15:35 <dsal> expected: 4.2 but got: 4.199985961699856
18:16:42 <dsal> Ah, finally figured out how to search this.
18:22:07 <xzhu1> With a stack project, is it possible to exec without compile?
18:22:19 <xzhu1> Like a "intepret-only mode"
18:23:05 <xzhu1> compilation took a bit too long for quick exploring iterations
18:23:36 <dsal> Implicit parameters vs. operators is confusing.
18:28:19 <danilo2> Hi! are we able to implement `PrimMonad m` for a monadtrans with IO base using `liftIO`? (https://hackage.haskell.org/package/primitive-0.6.2.0/docs/Control-Monad-Primitive.html)
18:28:46 <danilo2> even in a hacky way. I'm looking for creating some automatic lifting for an internal library here
18:41:51 <xzhu1> Does anyone know in Persistent, how to make a query filter that works with Maybe types?
18:42:58 <xzhu1> for example, "selectList [PersonAge >. 24] [LimitTo 10]" is okay when age is Int
18:43:12 <xzhu1> but it doesn't work if in the schema age is "Int Maybe"
18:46:10 <xzhu1> Holy cow "selectList [PersonAge >. Just 24] [LimitTo 10]" works
18:49:01 * hackagebot brick 0.24 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
18:55:21 <remexre> Is there a replacement for llvm-general-pure that works with stack lts-9.1 and/or GHC8?
18:55:55 <remexre> wait, lol, just found llvm-hs-pure
19:54:41 <dsal> @pl (\c -> f st c)
19:54:41 <lambdabot> f st
20:10:14 * hackagebot repa-algorithms 3.4.1.2 – Algorithms using the Repa array library. – https://hackage.haskell.org/package/repa-algorithms
20:10:14 * hackagebot repa 3.4.1.3 – High performance, regular, shape polymorphic parallel arrays. – https://hackage.haskell.org/package/repa
20:12:50 <dsal> @pl \st -> read2f 38 st / 10
20:12:50 <lambdabot> (/ 10) . read2f 38
20:17:01 <dsal> @pl \st -> map (iR st) [1..f st]
20:17:01 <lambdabot> liftM2 map iR (enumFromTo 1 . f)
20:36:30 <dsal> @pl \st -> (2.5*(read2f 26 st)/4096) / 0.00355
20:36:31 <lambdabot> (/ 0 . 355) . (/ 4096) . (2 . 5 *) . read2f 26
20:36:41 <dsal> Neat.  I may never have to think again.
20:42:41 * hackagebot language-elm 0.0.1.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
20:53:17 <cantom> I'm not a Haskeller, but I wonder how do you folks model a very large unseekable stream (i.e. you can only read it once) in Haskell?
20:53:38 <cantom> Wouldn't immutability mean that the entire stream is stuck in RAM if potentially references somewhere?
20:56:36 <Rotaerk> cantom, basic example is the haskell list type.  it's kind of like a singly linked list.  [] is the empty list, a:xs is the list produced by prepending a to the list xs
20:57:03 <Rotaerk> except haskell is lazy, so you don't have to have xs fully evaluated before you prepend a to it
20:57:30 <Rotaerk> so what you end up with is an unevaluated list, you get the next value on the top of it, but the values just beneath that remain unevaluated
20:57:37 <Rotaerk> allows you to have infinite lists
20:58:12 <cantom> Rotaerk: I'm not sure how can Haskell safely dispose of previously queries values, or prevent someone trying to access them
20:58:16 <cantom> queried*
20:59:11 <Rotaerk> well if there aren't any references to the value, it can be eligible for collection, wouldn't it?
20:59:41 <cantom> Rotaerk: well one can very easily also keep a reference to the first item, which means all following values should remain in memory as well
21:00:43 <Rotaerk> cantom, you might have an unevaluated expression of type [Char] (i.e. a list of characters; also known as a String), and this expression might be bound to a variable named xs
21:01:16 <Rotaerk> but then you want to get the first character from the list, so you do:  let (x1:xs') = xs
21:01:33 <Rotaerk> now x1 is a reference to the first character in the list, and xs' is a reference to the rest
21:01:57 <cantom> Rotaerk: so what I want to do is I want to ensure no one can use xs again
21:02:02 <cantom> Rotaerk: only xs'
21:02:33 <Rotaerk> well then if this is inside of a function, return xs' and not xs
21:02:33 <cantom> Rotaerk: either this or some other solution that helps me free memory once a chunk has been read
21:02:42 <cantom> Well.
21:02:59 <cantom> Rotaerk: I can call the function again can't I
21:03:43 <Rotaerk> if that function is producing the xs, then the second call will produce a different instance of it (but if the parameters to that function are the same, it will be equivalent)
21:04:16 <Rotaerk> unless it's impure, of course... in which case it's not really a "function" producing it but an action of some kind
21:05:16 * hackagebot language-elm 0.0.2.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
21:05:36 <cantom> Rotaerk: here's a use case for what I'm talking about: I'm receiving terrabytes of data over a network. I can buffer some of it, waiting for code to consume it, but I can't buffer all of it, obviously.
21:05:45 <cantom> Rotaerk: so how to expose this to Haskell/
21:06:02 <cantom> Rotaerk: it's not impure, but also modeling it in a pure way would be extremely expensive I think
21:06:27 <cantom> Rotaerk: it's just an immutable stream, but I never have all of it local. It streams. I can't seek. I always have the next piece.
21:07:18 <Rotaerk> the concept seems like what the "pipes" library provides
21:07:38 <Rotaerk> https://hackage.haskell.org/package/pipes
21:08:04 <cantom> Rotaerk: I'll check. Thanks!
21:09:37 <pikajude> how do I get the current cabal builddir in code?
21:09:45 <Rotaerk> cantom, I'm curious; if you're not a haskeller, why are you asking?
21:10:58 <cantom> Rotaerk: Java, C#, JavaScript, Python, PHP. I'm writing a library where I try to model most of it in immutable to avoid some classes of bugs and surprises and I thought: only a Haskell user would know how to model a huge stream in an immutable way :)
21:12:11 <Rotaerk> of those, I'm only familiar with C#, and in that, you can represent that with IEnumerable
21:14:09 <cantom> Rotaerk: there are many mutable ways to do this.
21:14:22 <cantom> Rotaerk: unfortunately the problem begin if I shoot for immutability.
21:14:45 <cantom> Rotaerk: I'm modeling HTTP-like messages.
21:15:01 <cantom> Rotaerk: with multipart content type, these can be nested
21:15:26 <cantom> Rotaerk: for example when you submit an HTML form with files, you send one HTTP request message, and every upload inside is another HTTP message
21:15:35 <Rotaerk> IEnumerable, as an interface, is immutable; doesn't provide any mechanism for changing the sequence
21:15:35 <cantom> Rotaerk: well, another MIME message, but same deal
21:15:47 <Rotaerk> but of course the underlying type could be mutable
21:15:51 <Rotaerk> but not necessarily
21:16:03 <cantom> Rotaerk: well it's mutable because you can't call it and get the same result always
21:16:59 <cantom> Rotaerk: first, the cursor is mutable. Second, if I support Reset, then we're back to the problem of buffering
21:17:37 <cantom> Rotaerk: and if I don't support Reset, then it's even more mutable because I can't start over :)
21:18:11 <cantom> Rotaerk: looks like pipes is effectful
21:18:21 <cantom> Rotaerk: there's no magical way to solve my issue :D
21:19:03 <Rotaerk> http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#v:readFile
21:19:45 <Rotaerk> readFile will produce a String that equals the contents of the file
21:20:03 <Rotaerk> but it will not actually be evaluated; it will lazily extract the data from the file as you read the string
21:20:19 <dmwit> pikajude: Yow, that sounds dangerous if it's even possible. Why do you want to do that?
21:20:37 <cantom> Rotaerk: it's cool, but it has the same problem
21:20:46 <cantom> Rotaerk: I can't store the entire stream anywhere.
21:20:49 <cantom> File or RAM
21:20:50 <cantom> Too big.
21:21:50 * hackagebot language-elm 0.0.5.0, pandoc-types 1.17.1
21:21:51 * hackagebot  → https://hackage.haskell.org/packages/recent
21:22:13 <Rotaerk> cantom, but this String isn't storing the entire file in memory
21:22:26 <Rotaerk> it's lazily reading the file and loading it in as you need it
21:22:30 <cantom> Rotaerk: it isn't, because it's backed on disk.
21:22:38 <cantom> Rotaerk: but imagine it wasn't backed on disk.
21:22:50 <cantom> Rotaerk: imagine you lost all data once you read it once
21:23:03 <cantom> Rotaerk: then the string won't work if you get the original string and try to read this again
21:23:34 <pikajude> dmwit: for development purposes
21:23:35 <cantom> Rotaerk: so then what happens, we throw errors, dunno. But it becomes mutable.
21:23:43 <pikajude> running a warp server that serves my ghcjs executable
21:23:45 <pikajude> "executable"
21:23:45 <cantom> Rotaerk: because the result changes on the same variable
21:24:47 <dmwit> pikajude: Can you unpack that a bit? Why does that mean you will need to change cabal's build directory?
21:24:54 <pikajude> i don't need to change it
21:24:57 <pikajude> i just need to access it
21:25:05 <pikajude> so i know where the ghcjs distdir is
21:25:18 <dmwit> ah!
21:25:30 <pikajude> oh, did i say change it? :X
21:25:34 <pikajude> typ
21:25:35 <pikajude> o
21:25:55 <dmwit> No. I read it wrong! reado
21:26:07 <pikajude> phew
21:26:29 <pikajude> i found an envar named "$project_datadir" that i can access
21:26:32 <pikajude> so i'll just use that
21:26:38 <dmwit> nice
21:27:30 <Rotaerk> cantom, if I did:  x = readFile blah
21:27:50 <Rotaerk> x will immutably refer to the entire contents of the file (unless the file becomes inaccessible before we finishh reading)
21:27:51 <dmwit> pikajude: Anyway, my advice would have been: use `cabal configure --prefix /where/i/want/it/to/go`, then `cabal install` to build whatever and put it there.
21:28:12 <Rotaerk> even if you have partially evaluated it (and thus read the file)
21:28:15 <pikajude> yeah
21:28:17 <pikajude> that's fair
21:28:41 <Rotaerk> but once you've *used* the first elements of x, you'd generally stop referencing it, and reference something later down the file
21:28:51 <Rotaerk> but if you WANT to keep a reference to it, you can
21:29:00 <Rotaerk> and it'll immutably be the entire contents
21:30:00 * hackagebot language-elm 0.0.7.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
21:30:00 * hackagebot language-elm 0.0.6.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
21:32:24 <cantom> Rotaerk: well the "generally stop referencing it" is a problem, as I can't guarantee it
21:32:28 <Rotaerk> cantom, err... x <- readFile blah.  sorry.  this is in the context of a do-block
21:35:16 <Rotaerk> cantom, you mean, you think the earlier data will continue to be referenced unintentionally, when it's no longer actually needed?
21:35:38 <cantom> Rotaerk: yeah, either unintentionally, or intentionally, without understanding the implications
21:35:52 <cantom> Rotaerk: I'm starting to think the solution isn't immutability, but explicit object ownership
21:36:13 <cantom> Rotaerk: I need to change my "setters" to "passers" where the original reference is nuked when passed to another context
21:36:17 <cantom> Hmm 
21:36:49 <dmwit> cantom: Hm. Are you carefully differentiating between a reference to the first element of a list and a reference to the head of a list?
21:36:53 <dmwit> They are very different things.
21:36:54 <kadoban> cantom: Sounds like rust's ownership stuff a bit.
21:37:04 <kadoban> Though ... not really maybe.
21:37:10 <dmwit> Holding onto the first value in a list doesn't force the whole list to stay in memory.
21:38:10 * hackagebot language-elm 0.0.8.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
21:38:16 <cantom> dmwit: the use case for a network stream of very large quantity, so it can't be recomputed from a formula
21:38:24 <cantom> dmwit: means the entire thing stays in memory or disk
21:38:29 <cantom> kadoban: indeed
21:38:37 <cantom> kadoban: there's wisdom in what Rust does
21:38:55 <trigone> hi! does anyone know why in Prelude.hs, at the bottom of the file (where there are all the import statements), there are a couple of things ((<$>) among others) which are explicitly mentioned as imported, but nothing else. it seems completely random...
21:38:57 <dmwit> cantom: I'm sorry, I can't agree with "remembering the first value in a network stream forces me to remember the whole stream from the beginning".
21:39:04 <trigone> here -> https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Prelude.html
21:39:04 <Lokathor> cantom, if you have a list [1,2,3], holding on to the 1 doesn't hold on to the whole list
21:39:19 <kadoban> It does seem interesting at least. I haven't used it in practice enough to tell if I like it or find it useful.
21:39:30 <cantom> dmwit: we're talking about "a first value function, which returns the first value, and a function to take the second value etc."
21:39:45 <cantom> dmwit: so then recursively you can read the whole thing from that first value producer
21:40:08 <cantom> Lokathor: yes, we're talking about the producer of the value, not the naked value itself
21:40:46 <dmwit> cantom: That may be what you're talking about, but that's not what I'm talking about.
21:40:53 <Lokathor> heh
21:40:55 <cantom> dmwit: heh
21:41:15 <dmwit> cantom: If you have a function which produces both a first value and a function to produce the rest of the stream, that's a reference to the list itself, not a reference to the first element.
21:41:20 <kadoban> trigone: That's what you do when you only want to import certain things from a module. So they don't want to import *everything* from Data.Functor, just (<$>)
21:42:12 <dmwit> cantom: Once you apply that function, you get a reference to the first element and another list. Holding onto that first element doesn't force you to hold onto the entire list -- you can just stop referencing that function.
21:42:45 <trigone> kadoban: yet it exports Functor(fmap, (<$)), (<$>)? unless those are not in Data.Functor?
21:43:11 <cantom> dmwit: yes
21:43:26 <cantom> dmwit: thing is I can't guarantee as a writer of this function that users won't reference it.
21:43:34 <cantom> dmwit: and it becomes kind of dangerous.
21:43:37 <trigone> nevermind, indeed apparently they're located in GHC.Base (or at least exported from there into Data.Functor). joys of haskell's modular maze...
21:43:46 <cantom> dmwit: as in "out of memory" and "out of disk space' dangerous
21:43:49 <dmwit> Of course not. It's not your responsibility to. It is the user's responsibility to be memory efficient if that's a need.
21:43:55 <kadoban> trigone: That means fmap and (<$), which are class methods of Functor, and (<$>) specifically (and separately)
21:44:00 <cantom> dmwit: thing is the contract is very implicit.
21:44:08 <cantom> dmwit: it makes it easy to do the wrong thing.
21:44:17 <kadoban> I think ... I didn't think you actually had to specify they were class methods to export, but maybe you do.
21:44:24 <dmwit> Unavoidable. Not worth spending your time avoiding. Document it and move on.
21:44:37 <cantom> dmwit: this is what a Java dev would say about shared mutable state :D
21:45:04 <dmwit> I dare you to name a function which cannot be used to exhaust memory somehow.
21:45:18 <cantom> dmwit: degree of likelyhood matters
21:45:34 <cantom> dmwit: we're not talking about some extreme use of a function here, but a humble single reference
21:45:46 <cantom> dmwit: which if you keep around, boom - out of disk space
22:03:19 <Lokathor> isn't (<$) kinda a pointless method?
22:03:36 <Lokathor> like you can just define it in terms of const and such
22:04:26 <dmwit> Supposedly there are instances where (<$) can be quicker than `fmap . const`.
22:04:56 <pikajude> it's shorter than const too
22:04:57 <dmwit> The free functor seems like a likely candidate, e.g.
22:05:41 <dmwit> Hm. Not sure about that, actually. I don't know what the motivating instances are.
22:27:28 <trigone> are we allowed to end an export list with a comma? i'm asking because it's apparently the case for Prelude...
22:28:03 <nshepperd_> Trying it seems like the fastest way to find that out
22:29:13 <nesqi> Allowed by some compiler or some spec?
22:30:16 <tdammers> nshepperd_: if it works, it could still be an implementation bug though
22:30:35 <tdammers> nshepperd_: that's how they create "features" in PHP
22:33:15 <nesqi> could this be of interest? 
22:33:17 <nesqi> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
22:35:14 <kadoban> So yep, explicitly allowed
22:35:26 <nesqi> mmm
22:37:57 <trigone> does it say why? i didn't find it in the link
22:38:11 <nesqi> no not way
22:38:18 <nesqi> it's just that [,]
22:38:39 <nesqi> -- optional , at the end
22:39:29 <trigone> yeah i saw. it's kinda weird, given that trailing commas is forbidden in every other place in the language (to my limited knowledge)
22:40:00 <trigone> well apparently it's the same with import lists ^^
22:40:44 <trigone> thx nesqi
22:41:48 <nesqi> It's in the haskell 98 spec aswell so you can safely assume it's allowed.
22:42:37 <nesqi> I would guess it helps with generated imports/exports where you don't have to check if you should remove the last comma
22:43:18 <nesqi> so it could be nice if you write editor macros to handle imports/exports or something like that.
22:44:11 <nesqi> But as you said... it's not allowed anywhere else. It's kind of strange.
22:45:03 <trigone> is there any perf losses to using systematically more polymorphic functions (well, aliases anyway), like <> instead of ++, etc?
22:45:55 <trigone> though maybe there's no dictionary involved when the type is monomorphic at usage location?
22:46:27 <trigone> aka <> used with Strings, instead of with Monoid m => m
22:48:32 <lyxia> trigone: none if everything inlines properly
22:49:13 <trigone> lyxia: which is dependent on what?
22:49:46 <lyxia> using INLINE at the right places
22:49:59 <lyxia> which can sometimes be nowhere at all
22:51:19 <nshepperd_> If it the type is monomorphic at usage location then i would confidently say that there is no performance cost. It will be immediately inlined and replaced by (++)
22:52:40 <trigone> nshepperd_: ok i'll take that for truth value for now :)
22:53:04 <trigone> lyxia: what you're talking about, is a job for those who write the class/instances right, not for those who use them?
22:57:48 <lyxia> As a user I think you can still end up with accidentally polymorphic bindings that somehow don't get specialized.
22:58:06 <nshepperd_> If you write a polymorphic function, with Monoid m constraint, it may also be zero cost, if that function is eventually inlined into a monomorphic call site
22:59:11 <nshepperd_> That might depend on you using INLINE
22:59:34 <nesqi> In general optimizations are fagile and depend on compiler version, local conditions and current star locations. Don't bend your code over just to get a certain optimazitain to kick in and if you do, that should be your last step before putting the code in production.
23:02:15 <trigone> hm ok
23:02:23 <norc_> Good morning. Im trying to get some code from the gentle introduction working, but I'm left totally clueless with this error message: https://gist.github.com/anonymous/03bd0ed8c705fb6a443b6051e370496d
23:03:37 <trigone> nesqi: yeah i kinda agree but it's a rather omnipresent question: map vs fmap, etc, all the slew of specialized functions from Prelude, at some point one gotta make a choice. i prefer polymorphism for its consistency, so it's good the cost is probably not too bad, if any.
23:04:08 <well> norc_ just a quick reaction from me would be that you should try writing the types. i know it's not your code but it's a good way to understand the code anyway and would help you solve this
23:05:03 <norc_> well: argh! Found the mistake, I replaced `init` with `ini` but I had one left-over.
23:05:14 <norc_> But perhaps Ill try it anyway just to figure out what the issue is
23:05:30 <well> oh! good luck :~)
23:05:56 <nshepperd_> I generally trust ghc to do the right thing,
23:06:08 <nshepperd_> As long as it's not some tricky recursion
23:06:54 <trigone> nshepperd_: so will i. thx btw :)
23:07:08 <norc_> well: it's just so damn strange to make sense of haskell errors..
23:07:55 <well> you'll get used to it i think! esp if you go back to languages where the error messages are vague or nonexistent. it's not just you though lol
23:08:20 <well> (*vague or nonexistent you'll realize what you're missing, i mean)
23:08:34 <norc_> Well I kind of feel like learning C++ templates all over again.
23:08:50 <norc_> Pure functional, strange to get used to and error messages that don't seem helpful at all..
23:08:53 <norc_> :p
23:09:01 <well> :D
23:09:04 <nesqi> Hehe... C++ template-errors are much worse =)
23:09:19 <norc_> nesqi: Most of them due to lack of concepts (i.e. typeclasses)
23:09:59 <norc_> well: Oh interesting, adding type annotations gives me a different (earlier) error that is a bit more sensible
23:10:28 <well> always a good idea! ^^ both for you and the compiler!
23:10:30 <norc_> https://gist.github.com/anonymous/02717a949eeaa5ce294d9950c33273ee thus telling me init does not have the type I think it does
23:10:33 <norc_> :)
23:26:40 <u-ou-> hi
23:26:48 <u-ou-> how do i install ghc into ~ without sudo on OS X?
23:28:09 <norc_> u-ou-: let stack do it for you?
23:28:18 <u-ou-> how?
23:29:38 <speak> norc_: The error messages are definitely a _lot_ better than C++ template errors :D
23:29:56 <nesqi> u-ou-: do you have stack installed?
23:29:59 <nesqi> https://docs.haskellstack.org/en/stable/install_and_upgrade/
23:30:13 <u-ou-> I tried curl -sSL https://get.haskellstack.org/ | sh but it did sudo
23:30:31 <norc_> Okay wow. This particular excercise is tying a knot into my brain.
23:30:32 <nesqi> Ah.. I see.
23:30:32 <u-ou-> I need to install stack into ~ without sudo if I can
23:31:08 <norc_> https://gist.github.com/anonymous/cfa5bd45fc4b890b8a138ca27da6cf81 given this code, how exactly does that list come into existence?
23:31:38 <nesqi> u-ou-: you could go with the "Manual download" alternative
23:31:53 <norc_> I mean I can just do `take 10 reqs` and I somehow end up with a list, but where does the initial cons with an empty list come from?
23:32:42 <nesqi> Download, https://www.stackage.org/stack/osx-x86_64 unpack and set your path to that dir.
23:32:56 <nesqi>  <dir>/bin
23:33:11 <u-ou-> thank you
23:33:39 <u-ou-> w00t
23:34:13 <u-ou-> I have never used stack before
23:34:25 <u-ou-> anything I ought to know?
23:34:31 <u-ou-> or is it pretty straight forward
23:35:06 <nesqi> nah.. just read the quick start guide
23:35:09 <nesqi> https://docs.haskellstack.org/en/stable/README/#quick-start-guide
23:35:17 <u-ou-> thanks
23:36:21 * u-ou- is excited
23:46:01 * hackagebot language-elm 0.0.9.0 – Generate elm code – https://hackage.haskell.org/package/language-elm
