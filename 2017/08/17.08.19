00:00:20 <nshepperd> yes
00:00:34 <erisco> so unsafeCoerce x and \x -> unsafeCoerce x ... that is a bold thing to do
00:00:41 <nshepperd> well, the input is of type Void, and the output is type a
00:00:56 <nshepperd> the fact that there are no cases justifies the coercion
00:01:03 <erisco> for empty case it is not always Void
00:01:19 <erisco> it can be Int :=: String for example
00:01:37 <erisco> or Identity Void
00:02:02 <erisco> or 3 :<: 2 or whatever ;)
00:02:04 <Eduard_Munteanu> Is coverage checking supposed to be more or less sound?
00:02:57 <Eduard_Munteanu> My hunch is GHC's coverage checker makes no serious attempt to prove that.
00:03:12 <Eduard_Munteanu> (except for diagnostics and warning purposes)
00:03:16 <erisco> I would have just done x `seq` error "empty case" or something like that
00:03:43 <erisco> rather than crossing my fingers something else doesn't mess up and now we secretly have unsafeCoerce about the place
00:04:44 * hackagebot ihaskell 0.9.0.1 – A Haskell backend kernel for the IPython project. – https://hackage.haskell.org/package/ihaskell
00:05:06 <nshepperd> that would be the more careful approach, if you don't trust the coverage checker
00:05:11 <Eduard_Munteanu> Well, you put too much faith into statements like IO (), which are obviously true but nonetheless worthless.
00:06:13 <nshepperd> assuming the coverage checker is correct, however, the only way it could fail would be if you already had an actually incorrect unsafeCoerce somewhere else in the program
00:06:34 <erisco> Eduard_Munteanu, to prove what? it can figure out impossible cases, though I do not know how generally
00:06:42 <nshepperd> like where I unsafeCoerced an Int into a Void for demonstration purposes
00:06:45 <erisco> it does know that Int :=: String is only inhabited by bottom
00:08:06 <erisco> that is a good question though... isn't the coverage checker optional? so what is EmptyCase plus no coverage checking... =\
00:08:07 <Eduard_Munteanu> Hm, I expected it to be much weaker with GADTs.
00:09:00 <erisco> Eduard_Munteanu, yeah I don't know generally but it is easy for Refl :: a :=: a because trivially Int ~ String is false
00:09:16 <nshepperd> the coverage checker got improved in 7.8 or something
00:09:27 <erisco> and I have done other proofs with Peano naturals and didn't have a problem with coverage checking
00:09:35 <nshepperd> supposed to work for GADTs now
00:11:08 <nshepperd> i would expect EmptyCase to throw a compile time error of some kind if it couldn't prove coverage
00:11:51 <nshepperd> or maybe revert to the x `seq` error "incomplete case" behaviour that happens normally
00:13:32 <erisco> it throws Non-exhaustive patterns in case, whew
00:14:11 <nshepperd_> Yeah that
00:15:16 <erisco> it's like the person who implemented it thought about it
00:17:09 * hackagebot JuicyPixels 3.2.8.3 – Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and… – https://hackage.haskell.org/package/JuicyPixels
01:33:53 * hackagebot ansi-terminal 0.7 – Simple ANSI terminal support, with Windows compatibility – https://hackage.haskell.org/package/ansi-terminal
01:39:10 <hrnz> 1
01:40:35 <erisco> 2
01:47:38 <pacak> 3
01:52:37 --- mode: ChanServ set +o mauke
01:52:38 --- mode: mauke set -q *!*@ip5f5bf73c.dynamic.kabel-deutschland.de
01:54:38 --- mode: mauke set -o mauke
02:58:59 <shafox> I want to write a parser to parse this text https://gist.github.com/shadow-fox/292b954da837b5886ff3fa7218b01f44 . The format I want to have is in the gist itself.
03:13:45 <cheater> what are currently the best QuickCheck alternatives? Thinking about things that are relatively full-featured
03:16:36 <freeman42x> What is currently overall best plugin for Visual Studio Code? https://marketplace.visualstudio.com/items?itemName=hoovercj.vscode-ghc-mod | https://marketplace.visualstudio.com/items?itemName=UCL.haskelly | https://marketplace.visualstudio.com/items?itemName=Vans.haskero | https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server
03:26:51 <bjs> cheater: what "features" are you looking for?
03:27:12 <cheater> none really, just wanted to know what's really used out there
03:27:22 <cheater> hedgehog looks nice
03:27:26 <cheater> and there's smartcheck
03:27:34 <cheater> and there was something else as well
03:27:42 <cheater> but i'm not sure which of those to choose.
03:30:55 <bjs> cheater: quickcheck will probably be the easiest to use with the most mature api
03:31:20 <bjs> cheater: but there's stuff like smallcheck that can do technically more interesting properties
03:32:32 <cheater> how would you compare it to smartcheck and hedgehog?
03:35:49 <bjs> cheater: as far as I understand, hedgehog is a modern reimplementation of quickcheck, smartcheck I've not actually used but it appears to just call out to the real quickcheck anyway, smallcheck does generation different and so doesn't need to shrink anything
03:36:36 <cheater> smallcheck creates all combinations at once right?
03:37:13 <bjs> cheater: well it starts with the small ones first (hence the name)
03:37:35 <cheater> cool
03:39:25 <bjs> cheater: it is :)
04:12:02 <jgt> sometimes my webapp wants to send some email. This email sending is an IO (), and it can fail. If it fails, I don't want everything else to fail. What should I use here? throwIO?
04:29:17 <cheater> :)
04:31:37 <osa1> jgt: catch IOExceptions. something like `catch sendMail (\(e :: IOException) -> putStrLn ("IOException happened, ignoring: " ++ show e))`
04:33:07 <cocreature> if you are fine with the thread for your specific request dying, some web frameworks already have such a handler for all exceptions thrown by a request
04:35:42 <jgt> cocreature: if that happens enough times, aren't I leaking memory?
04:37:05 <cocreature> jgt: how so? threads that are dead will be garbage collected unless you are specifically retaining a reference to their threadid somewhere
04:37:34 <mbrock> I just discovered that my approach to modularizing a certain program is described in http://augustss.blogspot.fi/2008/12/somewhat-failed-adventure-in-haskell.html in the "associated data types" section
04:38:16 <mbrock> now I wonder if Backpack will help make these things nicer
04:39:03 <jgt> cocreature: I have no idea what I'm talking about, so I ask dumb questions all the time :)
04:39:33 <jgt> cocreature: so in that case, what do I do? forkIO?
04:39:58 <cocreature> jgt: depends on your webframework. most webframeworks will already run each request in a separate thread
04:40:06 <jgt> Yesod
04:40:40 <jgt> in this particular case, I'm sending email notifications to myself when exceptions happen, from the Foundation part
04:41:19 <cocreature> I’m pretty sure yesod runs each request in a separate thread and probably handles exceptions thrown by request handlers in some way
04:44:30 <jgt> I might be confusing myself here. What's happening is: I send a POST request to the app. The request is invalid (wrong params or whatever), and then the user sees a 500 because the email notification for the exception failed. I would want the email sending failure to happen silently, and the original exception sent back to the user.
04:45:09 <mbrock> yay, it seems that Backpack supports multiple instantiations of the same packages inside another package
04:45:19 <cheater> uhm, what am i missing? i remember there was a function that took a list of lists and just concatenated them
04:45:40 <cocreature> jgt: ah so you don’t want the request to fail due to email failures. in that case catch the failure as osa1 showed you
04:45:44 <cocreature> :t concat -- cheater
04:45:45 <lambdabot> Foldable t => t [a] -> [a]
04:45:51 <tdammers> jgt: the canonical solution is to not send the email directly from your request handler, but instead add it to a job queue and have a background process pick it up from there
04:46:00 <cheater> why doesn't hoogle find that? [] is foldable
04:46:06 <cheater> @hoogle [[a]] -> [a]
04:46:07 <lambdabot> Data.List subsequences :: [a] -> [[a]]
04:46:07 <lambdabot> Data.List permutations :: [a] -> [[a]]
04:46:07 <lambdabot> Data.List inits :: [a] -> [[a]]
04:46:39 <cheater> aha so it's here https://www.haskell.org/hoogle/?hoogle=%5B%5Ba%5D%5D+-%3E+%5Ba%5D
04:46:42 <cheater> just not on lambdabot
04:46:43 <cheater> bad bot
04:47:15 <jgt> tdammers: that's helpful. I should probably just do it The Right Way, rather than fight it
04:47:17 <cocreature> looks like lambdabot has switched to the new hoogle which has shittier typesearch but indexes vastly more packages and is significantly faster
04:47:24 <jgt> osa1: Thanks for posting your example!
04:48:14 <tdammers> jgt: also, I wonder whether you really want to send notifications for users submitting invalid information
04:50:26 <jgt> tdammers: I probably don't, but I want to start with catching everything (and making sure exception notifications work properly and unobtrusively), and then later filter out stuff I don't care about
04:51:27 <jgt> tdammers: playing DA with myself here, but I might want to send notifications for invalid requests at least initially. Maybe it points to some UX fail?
05:36:29 <tdammers> jgt: yeah, could be useful... but it could also lead to swamping yourself with relatively useless information
05:36:50 <tdammers> jgt: if anything, I'd make sure you have exception types in place that allow you to filter things easily
05:37:08 <tdammers> jgt: also, sending a separate e-mail per exception is a capitally bad idea
05:43:34 <kuribas> I just realized the continuation monad is a generalization of the list monad, using (flip concatMap).
05:48:14 <kuribas> > flip runCont id $ do a <- cont (`concatMap` [1, 3, 4]); b <- cont (`concatMap` [5, 6, 7]); return [a + b]
05:48:16 <lambdabot>  [6,7,8,8,9,10,9,10,11]
05:48:28 <kuribas> > do a <- [1, 3, 4]; b <- [5, 6, 7
05:48:30 <lambdabot>  <hint>:1:33: error:
05:48:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:48:41 <kuribas> > do a <- [1, 3, 4]; b <- [5, 6, 7]; return (a+b)
05:48:43 <lambdabot>  [6,7,8,8,9,10,9,10,11]
05:49:47 <kuribas> but you can change the behaviour at each step
05:53:54 <tsmish> Is there a good name for this function?: f m a = m >>= f m
05:54:48 <Rembane> tsmish: What types does it have?
05:54:56 <hpc> :t \f m a -> m >>= f m
05:54:57 <lambdabot> Monad m => (m a -> a -> m b) -> m a -> t -> m b
05:55:09 <hpc> you can drop the a parameter
05:55:12 <hpc> :t \f m -> m >>= f m
05:55:14 <lambdabot> Monad m => (m a -> a -> m b) -> m a -> m b
05:56:08 <erisco> :t (<*>) (>>=) -- I would call it this
05:56:09 <lambdabot> Monad m => (m a -> a -> m b) -> m a -> m b
05:56:29 <shafox> Where should I add the local modules in the cabal file ?
05:56:32 <Rembane> :t (=<<) (<$>)
05:56:34 <lambdabot> Functor f => (f a -> a -> b) -> f a -> f b
05:56:40 <Rembane> Interesting.
05:57:13 <tsmish> @def function m a = m a >>= function m
05:57:14 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
05:57:14 <lambdabot>      Pattern match is redundant
05:57:14 <lambdabot>      In an equation for ‘function’: function m a = ...
05:57:36 <tsmish> err..
05:58:29 <filthy_causual2_> @pl f x = fmap g (h x)
05:58:29 <lambdabot> f = fmap g . h
05:58:40 <filthy_causual2_> >.<
05:59:00 <erisco> :t (<*>) fmap
05:59:02 <lambdabot> Functor f => ((a -> b) -> f a) -> (a -> b) -> f b
05:59:39 <tsmish> :t function
05:59:40 <lambdabot> Monad m => (a -> m a) -> a -> m b
05:59:46 <tsmish> Rembane: ^
06:00:40 <erisco> well I messed that last one up
06:02:01 <filthy_causual2_> It is an interesting type though.
06:04:52 <Garreett> Hello, I have been using megaparsec and my exercise specifies that I write a function "parse" however since Megaparsec has its own "Text.Megaparsec.parse" function I am having to use "Main.parse" instead. Is there anything I can change/do so I can simply use "parse" instead of "Main.parse"?
06:05:37 <erisco> :t (.) (.) -- for \f x g y -> f x (g y)
06:05:39 <lambdabot> (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
06:07:42 <barrucadu> Garreett: You could import megaparsec qualified: import qualified Text.Megaparsec as P, P.parse ...
06:07:59 <barrucadu> Or import megaparsec without parse: import Text.Megaparsec hiding (parse)
06:09:57 <Garreett> barrucadu: I'll try that now thanks!
06:12:10 <Rembane> tsmish: Thank you
06:15:31 <Garreett> barrucadu: hmm I am still getting "an ambiguous occurence of parse" after trying both of your suggestions
06:16:20 <tsmish> Rembane: for what?
06:16:40 <Rembane> tsmish: The type
06:17:06 <lyxia> Garreett: the error tells you the source of duplicate names
06:18:05 <hexagoxel> Garreett: you probably still have the old import active; need to :m -Text.Megaparsec  (or restart the whole session..)
06:18:31 <hexagoxel> and then re-do the import qualified again
06:19:30 * hackagebot IPv6DB 0.2.2 – A RESTful Web Service for IPv6-related data – https://hackage.haskell.org/package/IPv6DB
06:22:03 <shafox> What is the correct way to read multi-gigabyte file ? 
06:22:31 <AlainODea> "[2017-08-10 19:03:14] <AlainODea> What is a good a constant time compare == (ie not short circuit false) for ByteStrings? I need it for secure hash comparison". I found an answer. https://hackage.haskell.org/package/crypto-api-0.8/docs/src/Crypto-Classes.html#constTimeEq
06:23:29 <lyxia> shafox: streaming with pipes or conduit
06:24:41 <shafox> thanks lyxia 
06:25:40 <Garreett> hexagoxel: Ah I still had "import Text.Megaparsec" and removed that which seemed to make things work. I am a little puzzled though... I am still using 'Text.Megaparsec.runParser' does this not require 'import Text.Megaparsec' to work? 
06:27:23 <hexagoxel> Garreett: no, see line 8 of the table at https://wiki.haskell.org/Import
06:27:43 <hexagoxel> oh, wait
06:28:14 <hexagoxel> what kind of import statement do you have now?
06:29:47 <Garreett> this is what I am using now https://pastebin.com/18ty5gE7
06:30:03 <Garreett> majority is from the megaparsec tutorial page
06:32:23 <hexagoxel> Garreett: ah, line 6 then. non-qualified import (with or without hiding) adds both qualified and unqualified bindings
06:34:00 <Garreett> hexagoxel: Ah okay thanks for explaining!
07:04:03 <cheater> hi
07:04:24 <cheater> how do i get a stack trace from something like this? main: src/Data/Foo/Util.hs:17:1-34: Non-exhaustive patterns in function bar
07:07:58 <lyxia> @wiki Debugging
07:07:58 <lambdabot> https://wiki.haskell.org/Debugging
07:08:28 <cheater> ty lyxia 
07:11:56 <mnoonan__> is there a testing library that would let me write a test of the form “rewrite rule X should fire on expression Y”?
07:13:14 <cheater> ok i made my ghc options on my executable like this: -prof -fprof-auto -fprof-cafs   but cabal configure says: Warning: 'ghc-options: -prof' is not necessary and will lead to problems when used on a library. Use the configure flag --enable-library-profiling and/or --enable-profiling.
07:13:37 <cheater> the wiki link says to use -prof -fprof-auto -fprof-cafs but i guess it hasn't been updated for 8.2.1
07:14:39 <lyxia> yeah the link is getting old
07:15:10 <cheater> so what flags should i use?
07:16:39 <cheater> ok now on the library i have   ghc-options      : -Wall --enable-library-profiling --enable-profiling -fprof-auto -fprof-cafs
07:16:56 <cheater> and cabal build says it doesn't recognize those two new flags :/
07:17:11 <cheater> ghc: unrecognised flag: --enable-library-profiling
07:17:11 <cheater> unrecognised flag: --enable-profiling
07:17:41 <lyxia> enable-profiling and enable-library-profiling are options for cabal
07:17:53 <lyxia> "configure flags"
07:18:05 <lyxia> I guess you'd use those then
07:18:08 <Clint> e.g. cabal configure --enable-library-profiling
07:18:09 <cheater> ah
07:18:15 <cheater> can i put that in the .cabal?
07:18:23 <lyxia> you can also add options for ghc on the command line
07:18:25 <lyxia> no
07:18:35 <cheater> should i still be using -fprof-auto and -fprof-cafs?
07:18:53 <Clint> you can put it in ~/.cabal/config
07:19:45 <cheater> ok, i reverted my ghc-options to -Wall
07:19:56 <lyxia> I don't know. You would need to if cabal doesn't set these flags for you.
07:20:21 <cheater> and when i run cabal install --enable-profiling --enable-library-profiling it tells me it can't find aeson and memoize packages (some of my deps)
07:20:33 <Clint> you have to build all the deps with profiling
07:20:40 <cheater> yeah but how do i tell cabal to do that
07:20:59 <Clint> rm -rf ~/.ghc and start over
07:21:20 <cheater> no
07:21:44 <lyxia> are you not just missing cabal install --dependencies-only ? Just guessing, I don't use cabal usually.
07:22:02 <lyxia> Also --enable-profiling implies --enable-library-profiling.
07:23:03 * hackagebot fmt 0.5.0.0 – A new formatting library – https://hackage.haskell.org/package/fmt
07:24:04 <cheater> http://sprunge.us/iNGj
07:24:06 <cheater> ^
07:25:39 <cheater> even --force-reinstalls is broken
07:28:37 <lyxia> it looks like cabal doesn't do profiling reinstalls at all.
07:29:05 <lyxia> cheater: what happens if you try to reinstall a package by hand with the profiling flag
07:29:23 <cheater> eh, wouldn't like to mess around like this
07:29:36 <cheater> lyxia: it looks like right now, cabal doesn't do any reinstalls
07:29:51 <cheater> anyways, i moved out my cabal sandbox and started a new build
07:29:58 <cheater> so, we'll see where that goes
07:40:30 <cinimod> *Main> fromNtoS ([[3,0],[0,3]] :: N.Matrix 2 2 Double)
07:40:30 <cinimod> Segmentation fault: 11
07:40:30 <cinimod>  
07:40:33 <cinimod> :(
07:40:58 <cinimod> Sometimes it happens; sometimes it doesn't
07:41:01 <alexbiehl> oh boy ghc-8.2.1? 
07:41:08 * cinimod goes to look
07:41:26 <cinimod> 8.0.2
07:41:54 <alexbiehl> Have you tried using 8.2.1? IIRC it has lots of improvements in its runtime linker
07:42:41 <cinimod> I will give it a go
07:43:02 * cinimod is new to nix and does not know how to do this
07:43:12 <cinimod> (using nix)
07:43:29 * cinimod will find out
08:06:13 <cheater> can i make tracebacks show the parameters passed into the functions?
08:52:24 <fosskers> hi all, is the flag to disable parallel gc `+RTS -gq`?
08:52:45 <fosskers> I remember reading the intial post about it, but now I can't find it for the life of me
08:54:07 <monochrom> Does the GHC User's Guide say anything?
08:55:29 <monochrom> Yes it does. Section 7.7.3 "RTS options to control the garbage collector".
09:02:21 <fosskers> Thanks monochrom 
09:03:06 <fosskers> it was 6.7.3, turns out
09:32:39 <enthropy> http://lpaste.net/331601110525542400 is an imagined feature to manage type variables. I'm unsure about recursion and kind inference
09:41:48 <enthropy> what is it called when you decide on `type Automaton = F210 T`? A seven constructor state machine becomes a 3+4 constructor state machine
09:50:54 <cheater> how is 7 different from 3+4 there
09:55:18 <enthropy> it's hopefully a correct refactoring. Yield :: o -> T p i o a x  is better than   Yield :: o -> Automaton p i o a -> Automaton p i o a
09:56:45 <lyxia> is it really better
09:57:08 <lyxia> and where did the second field go
09:57:11 <enthropy> more importantly, Phase no longer needs a rank 2 type
09:57:51 * enthropy guesses this is where the urge to eliminate extensions comes from
10:00:35 <enthropy> Yield :: o -> x -> T p i o a x -- thanks lyxia 
10:01:00 <enthropy> my mental :t isn't quite right
10:10:56 <alx741> hello everyone. How could I go about defining an Eq instance for a data type of kind (* -> *) and ignore the type variable in the equality comparison? This is what i get rith now: http://sprunge.us/DJID
10:11:51 <alx741> In that code I'd like the comparison to occur only upon the Doubles, but the type system won't let me
10:12:17 <geekosaur> tht sounds ... wrong
10:12:42 <erisco> alx741, you will need your own equality class
10:13:36 <alx741> I might be doing something inherintly wrong (at the reasoning level) and not seeing it... please point it out if that's the case
10:14:01 <alx741> erisco: I thought about it, but still curious about why it isn't possible that way (?)
10:14:22 <erisco> because as you said: the type system will not let you, i.e. it will not work with the type of ==
10:14:23 <alx741> Maybe some RankNType would allow it? 
10:14:25 <Tuplanolla> @hoogle Eq1
10:14:26 <lambdabot> Data.Functor.Classes class Eq1 f
10:14:26 <lambdabot> Prelude.Extras class Eq1 f
10:14:26 <lambdabot> Intro class Eq1 (f :: * -> *)
10:14:32 <Tuplanolla> You mean this, alx741?
10:15:15 <erisco> Eq1 does not work either, unless I'm too tired to see how
10:15:44 <enthropy> :t equating snd
10:15:45 <lambdabot> error:
10:15:45 <lambdabot>     Variable not in scope: equating :: ((a0, b0) -> b0) -> t
10:15:55 <enthropy> :t compare `on` snd
10:15:56 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
10:16:56 <erisco> well, RankNTypes can remove your type parameter, but that is probably not what you want
10:17:34 <alx741> Tuplanolla: mmm interesting... but as erisco said it will probably still fail. Will give it a try to see how it goes
10:19:05 <alx741> erisco: how would the RankNType be in this case? I need to think this a little bit more and yeah... it's probably wrong, but now that i've encountered this situation i'd still like to know if it's possible
10:22:44 <erisco> oh, I suppose Eq1 could work if you flipped the type parameters, though I am not sure if it violates laws
10:23:16 <erisco> I was thinking there was just eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool but actually it is defined on liftEq :: (a -> b -> Bool) -> f a -> f b -> Bool
10:23:17 <enthropy> flip which type parameters?
10:23:38 <erisco> oh right, it is constant Double, never mind
10:24:42 <enthropy> :t \x y -> eq1 (() <$ x) (() <$ y)
10:24:44 <lambdabot> error:
10:24:44 <lambdabot>     • Variable not in scope: eq1 :: f1 () -> f () -> t
10:24:44 <lambdabot>     • Perhaps you meant ‘eqT’ (imported from Data.Typeable)
10:26:40 <erisco> no I was thinking  liftEq _ (MyData _ x) (MyData _ y) = x == y
10:30:37 <alx741> wouldn't `forall a` allow it?
10:30:49 <erisco> where?
10:31:03 <alx741> mmhh but it would have to be in the type of (==) in the class declaration isn't it?
10:31:44 <erisco> I don't think it is going to do what you hope it will
10:31:46 <alx741> I was thinking `instance forall a Eq (MyData a) where ...` but that doesn't work
10:32:05 <erisco> it is already that way, alx741, the forall is implicit
10:32:26 <alx741> oh! you're right!
10:32:45 <alx741> will try with my own class i guess. Thanks a lot guys!
10:33:13 <erisco> data MyData = MyData (forall a. a) Double
10:33:34 <erisco> that is what I was saying by removing the type parameter, and now you can use ==
10:34:01 <erisco> but this isn't what you want for MyData
10:34:52 <erisco> alx741, did you see above? enthropy is suggesting you use a standard structural equality and define a different equality test based on it
10:35:10 <erisco> and I also suggested an Eq1 instance
10:38:49 <dsal> Is there an easy way in ghci to write out a [IO ByteString]?
10:39:22 <erisco> first sequence, now you have IO [ByteString]
10:39:28 <Tuplanolla> :t sequenceA -- This, dsal?
10:39:30 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
10:39:48 <shae`> dsal: ooh, what are you writing?
10:40:14 <dsal> I'm just trying to generate some test data to play against a reference implementation of something, and then bring back.
10:40:51 <dsal> sequence rids me of a ton of confusion.  heh
10:44:05 <enthropy> alx741, http://lpaste.net/357805 probably summarizes the options?
10:48:01 <enthropy> I like MYD3. The Eq instance is selected when you apply the (iMYD3 #) "constructor" by use of the Rank2 type
10:52:21 <cheater> erisco: how does RankNTypes remove a type parameter?
10:53:03 <erisco> cheater, it moves the binder inside
10:55:17 <cheater> i don't understand, what is a binder?
10:56:29 <erisco> cheater, the forall
11:09:55 <alx741> sorry, went AFK for lunch.
11:10:22 <erisco> I'll forgive you this once
11:11:53 <dsal> So, there's no way to free a variable from an IO monad, right?  Every time I read the head of this list, I get a different value.  That's not helpful.
11:12:21 <erisco> dsal, only unsafe ways
11:12:48 <dsal> I just want to generate a bunch of quickcheck data consistently.  variant doesn't work the way I thought it does, apparently.
11:13:30 <alx741> wow, that is very detailed. Eq1 seems straight forward, will experiment a bit with the MYDE and MYD3  ways. Thank you very much erisco, enthropy!
11:16:46 * hackagebot inline-c 0.6.0.5 – Write Haskell source files including C code inline. No FFI required. – https://hackage.haskell.org/package/inline-c
11:23:28 <SansFr[m]> hi everyone
11:29:28 <Cale> Hello SansFr[m]
11:34:28 <Digit> ideo: haskell implementation of diaspora federation "..., and we will push its wider adoption by providing support and an automatic tool to test its implementation in other languages. Apart from the reference implementation in Ruby, there are currently two implementations in PHP, one in Python and one in Go, which are at various stages of development."
11:34:43 <Digit> https://blog.diasporafoundation.org/43-our-federation-protocol-just-got-bigger-and-better 
11:37:41 <cheater> erisco: interesting
11:41:54 <shae`> Digit: are you writing such an implementation?
11:48:24 <Digit> i merely write idea.   ... oops, did i dyslexic up "ideo" instead of "idea" there.  derp.
11:49:31 <Digit> ....y'know.   incase capable interested parties like the idea, n have the time to do it with joy.
11:50:44 <Digit> (my haskell skills dont go far enough.  ... an xmonad n xmobar config... that's about all i've done in haskell, in 10 years)
11:52:26 <merijn> I got a question for windows users (if there are any here...) how do you interrupt an infinite loop in ghci on windows? (inside powershell)
11:52:53 <merijn> On *nix I'd just use ctrl-c for SIGINT, but I can't really find a powershell/windows equivalent
11:54:32 * hackagebot swish 0.9.1.10 – A semantic web toolkit. – https://hackage.haskell.org/package/swish
11:57:41 <cheater> in ghci, how can i look at what happens when i apply a type family to a type?
11:57:52 <cheater> that is, how can i evaluate a type family?
11:58:38 <lyxia> :kind!
12:06:00 <freeman42x> I'm stuck here: https://stackoverflow.com/q/45775326/750216 Anyone could help please? Missing some library I think, but not sure which and in what way I should install it.
12:11:38 <lasey> guys, i'd like to consume rest api.. is there any standart haskell lib/module for this?
12:21:06 <cheater> thanks lyxia 
12:22:40 <cheater> wow i really got tripped up by parametricity today
12:24:50 <cheater> i had a list that i folded with a function that's essentially + for a special data type. then i needed to add another value to that, so i thought i would prepend it to the list. but some parts of the type were not the same so fold made it throw errors. so i had to do x + (fold ... ys) 
12:33:39 <jackhill> lasey: maybe wreq would meet your needs: http://www.serpentine.com/wreq/tutorial.html
12:40:53 <mikail_> I'm writing a simple function but I am getting a parse error message. Not sure what it is. The guards all line up. http://lpaste.net/357810
12:41:13 <lyxia> otherwise    =    False
12:41:26 <mikail_> doh!!!
12:41:30 <lyxia> member2 x p Tip = x == p     would be shorter
12:41:52 <mikail_> why couldnt it just say I was missing the "="
12:42:19 <lyxia> it thinks the guard consists of an expression that starts with "otherwise" applied to "False"
12:42:31 <lasey> jackhill: ty 
12:43:08 <hpc> mikail_: in general, parser errors tend to be more about how they are surprised, than what you should have done differently
12:43:39 <mikail_> thanks guys
13:05:26 <lasey> jackhill: i've read a little bit about wreq, since i am not much familiar to haskell and it's ecosystem.. it'll be a bit hard for me to focus on another topic which is lens.. and i did a bit search too which wreq and servant client both built top of http-client and as far as i can see http-client does not support ssl.. so i am a bit stuck.
13:29:06 * hackagebot typed-process 0.1.0.1 – Run external processes, with strong typing of streams – https://hackage.haskell.org/package/typed-process
13:33:18 <thoughtpolice> lasey: Both wreq and servant-client do support support SSL, fwiw. But you do have to construct your own HTTPS manager for their APIs when creating the connection (which is annoying, admittedly.)
13:34:02 <thoughtpolice> lasey: There is also 'req' which is fairly new but has a nice API, no need for lenses etc, and it nicely hides most of the use of http-client https://github.com/mrkkrp/req
13:45:17 * hackagebot DeepDarkFantasy 0.2017.8.19 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
13:45:17 * hackagebot colonnade 1.1.1 – Generic types and functions for columnar encoding and decoding – https://hackage.haskell.org/package/colonnade
13:58:35 <platz> I'm not understanding why in this code (Proxy :: Proxy format) does not "pick up" the context from the instance, but the value "f" does "pick up" the context http://lpaste.net/357816
13:59:55 <platz> I thought with ScoptedTypeVariables, the type variable "format" would access the instance'c context too
14:01:01 <LysergicDreams> Is there a standard process for generating API tokens? Can I just use v4 UUIDs? Should I pass those to bcrypt? Something else entirely?
14:02:28 * hackagebot executor 0.0.1 – Shell helpers – https://hackage.haskell.org/package/executor
14:09:22 <dsal> This seems like a bad idea, but...
14:09:23 <dsal> @pl (\a x -> (a ↠ 1) ⊕ if odd (x ⊕ a) then 33800 else 0)
14:09:24 <lambdabot> (line 1, column 14):
14:09:24 <lambdabot> unexpected "\134"
14:09:24 <lambdabot> expecting variable, "(", operator or ")"
14:09:35 <dsal> well damn.  That didn't last long.
14:09:47 <dsal> @pl (\a x -> (a `shiftR` 1) `xor` if odd (x `xor` a) then 33800 else 0)
14:09:48 <lambdabot> ap ((.) . xor . (`shiftR` 1)) (flip flip 0 . flip flip 33800 . ((if' . odd) .) . flip xor)
14:09:59 <dsal> Yep, sucks.
14:14:37 <pavonia> platz: Where does your format come from in line 48?
14:16:19 <platz> pavonia: since on line 48 "format" is a type variable, I expect it to unify with the type variable on line 34
14:16:59 <c_wraith> pavonia: in theory, the signature of addParam
14:17:25 <pavonia> It doesn't know which instance to choose
14:17:31 <c_wraith> pavonia: except you need even more extensions to allow that
14:18:36 <platz> instanceSigs doesn't seem to help
14:20:00 <c_wraith> platz: did you include the forall?
14:20:02 <pavonia> I don't think more extensions help, unless you add some fun deps to RenderFormat or so
14:20:10 <MarcelineVQ> platz: I don't know much about proxy and fancy instances but to used scoped type variables you have to explicitly bring things into scope, the mechanism for this is using forall, you've not brought anything into scope explicitly since I don't see any foralls
14:21:19 <c_wraith> MarcelineVQ: that's not entirely true when dealing with instances.  With instance declarations, ScopedTypeVariables brings any type variable in the instance head into scope for the definitions inside the instance - but that doesn't apply here.
14:22:05 <MarcelineVQ> gosh :(
14:22:30 <MarcelineVQ> there's so much machinery crammed into classes, how does anyone write these things
14:23:23 <platz> I guess I can live with passing values
14:23:43 <platz> just don't quite understand the mechanism going on
14:24:33 <c_wraith> platz: did you try a version with forall on the type of addParam inside the instance?
14:25:28 <platz> oh wow, i think that may have done something right
14:26:04 <c_wraith> ScopedTypeVariables is sort of awkward to use sometimes...
14:26:36 <mud> It's very handy though
14:28:21 <c_wraith> It is, but it does at least 3 different things in different contexts, which makes it complicated to use
14:29:16 <platz> thanks all
14:29:17 <mud> Yeah. It usually only confuses me when I think about it too much personally, haha.
14:29:57 <c_wraith> my favorite use for ScopedTypeVariables is one of the more subtle ones - binding an existential type in a pattern match..
15:16:23 * hackagebot crypto-enigma 0.0.2.9 – An Enigma machine simulator with display. – https://hackage.haskell.org/package/crypto-enigma
15:16:23 * hackagebot http2-client 0.2.0.2 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
15:59:57 * hackagebot morte 1.6.10 – A bare-bones calculus of constructions – https://hackage.haskell.org/package/morte
16:07:23 <lamster> Hi! Does anybody know if there is a "lens-way" to access list of all elements of a map ?
16:08:14 <koz_> I'm a bit confused about how this example works: http://dev.stephendiehl.com/hask/#typelevel-numbers
16:08:40 <koz_> Specifically, I'm not sure I understand the 'data Vec :: Nat -> * -> *' part.
16:09:00 <Tuplanolla> :t toListOf each -- This, lamster?
16:09:02 <lambdabot> Each s s b b => s -> [b]
16:09:40 <hpc> koz_: if it helps, it's like any other type signature, but up a level
16:09:51 <hpc> :k Int
16:09:52 <lambdabot> *
16:09:54 <hpc> :k Maybe
16:09:55 <lambdabot> * -> *
16:09:58 <hpc> :k Either
16:09:59 <lambdabot> * -> * -> *
16:10:02 <hpc> :k Functor
16:10:03 <lambdabot> (* -> *) -> Constraint
16:10:22 <koz_> Ah, I think I get it. * means 'a polymorphic type' right?
16:10:31 <koz_> (or rather, 'anything')
16:10:39 <hpc> * is the kind of fully applied types
16:10:53 <koz_> And * -> * is?
16:10:56 <hpc> it's a specific sort of "anything", yeah
16:11:04 <hpc> * -> * is a type-level function sort of thing
16:11:08 <hpc> that takes a fully applied type
16:11:11 <hpc> and produces a fully applied type
16:11:34 <hpc> so for instance, Maybe isn't something you can have a value of by itself
16:11:41 <koz_> But Maybe Int is OK.
16:11:42 <hpc> but you can pass it something of the right kind (like Int)
16:11:46 <hpc> right
16:11:58 <koz_> Ah, OK. Next question: What's up with GHC.TypeLits?
16:12:09 <lamster> Tuplanolla: oh, sorry, I meant keys, not elements!
16:12:50 <hpc> koz_: it defines some stuff that's convenient to use at the type/kind levels with the DataKinds extension
16:12:59 <hpc> specifically stuff like Nat
16:13:13 <koz_> And what's DataKinds all about?
16:13:39 <hpc> it gives you the ability to do more elaborate computations at the type level
16:13:43 <hpc> so for the Vec example
16:13:49 <hpc> the Nat it takes as a type parameter
16:13:59 <hpc> is the length of the values of that type
16:14:19 <hpc> so Vec 0 Int is the type of empty vectors of integers
16:14:23 <hpc> it has one value, Nil
16:15:09 <koz_> So I could, for example, define a function only on 3D vectors?
16:15:28 <hpc> better than that, you can define a function that takes a vector of a specific length
16:15:35 <hpc> or of a generic length, and do things with it
16:15:49 <koz_> hpc: I meant 'vectors of exactly 3 elements'.
16:15:52 <koz_> But I see.
16:15:56 <hpc> yeah
16:15:58 <koz_> And It would be typed as something like:
16:16:09 <koz_> foo :: Vector 3 a -> Vector 3 a -> Vector 3 a
16:16:11 <koz_> ?
16:16:14 <hpc> yeah
16:16:23 <hpc> here's something that should get your imagination going
16:16:35 <hpc> vecAppend :: Vector n a -> Vector m a -> Vector (n + m) a
16:16:54 <hpc> safeHead :: Vector (1 + n) a -> a
16:16:59 <koz_> Yeah, that makes an awful lot of sense.
16:17:05 <koz_> What if you had something like:
16:17:14 <koz_> vectorNub :: (Eq a) => Vector n a -> ????
16:17:35 <koz_> Like, how do you write the type of what this would give?
16:17:44 <hpc> probably something like Vector m a
16:17:49 <hpc> where m is unconstrained
16:18:10 <koz_> Ah, I see. Makes sense.
16:18:41 <koz_> And you could define, like, a Matrix type, and then write functions that only work on square matrices, say, right?
16:18:48 <hpc> yeah
16:18:53 <hpc> Vector n (Vector n a)
16:18:58 <hpc> would be a fairly naive way to define it
16:19:21 <koz_> You'd wrap it up in a Matrix n m a.
16:19:25 <hpc> yeah
16:19:26 <koz_> (right?)
16:19:41 <koz_> And the kind would be Nat -> Nat -> * -> * ?
16:19:52 <hpc> yep
16:20:24 <koz_> That is really handy and I wish I knew this sooner.
16:20:34 <hpc> i suggest at this point a brief segue into agda
16:20:52 <hpc> specifically, trying all this stuff out with the full power of dependent types and the emacs "ide" plugin it comes with
16:20:52 <koz_> What's the TypeOperators extension for? Is it for writing stuff like the head and append examples you gave?
16:21:09 <hpc> it lets you syntactically write (+) at the type level
16:21:32 <hpc> and maybe other stuff, i haven't looked too deeply into that aspect of it
16:21:47 <koz_> hpc: Thanks - that's really cool and I will use it more often.
16:22:40 <hpc> yeah, imo this is the direction that the next 20 years of programming language design will take
16:22:47 <koz_> One last thing: suppose I wanted to write a thing for IntVectors, which would have a type-level length. Would that be something like IntVector :: Nat -> * ?
16:22:58 <hpc> yeah
16:23:07 <koz_> OK, just wanted to make sure I got that.
16:23:14 <Tuplanolla> Ideally you'd have `vectorNub :: (Eq a, m <= n) => Vector n a -> Vector m a`, but therein lies trouble, koz_.
16:23:34 <hexagoxel> > M.fromList [(2, "hello"), (1, "world")]^..ifolded.asIndex -- lamster 
16:23:34 <koz_> Tuplanolla: Wherefore lies there trouble?
16:23:36 <lambdabot>  [1,2]
16:24:06 <hpc> that gets into a tradeoff of sorts when writing dependently typed code
16:24:10 <Tuplanolla> In arbitrary computations as constraints, koz_.
16:24:16 <hpc> you're essentially programming in the type system
16:24:22 <lamster> hexagoxel: ah, yeah! that is whatI was looking for! thank you!
16:24:24 <hpc> and it can get quite complicated
16:24:25 <koz_> Tuplanolla: Ah, you end up having the halting problem at compile time.
16:24:27 <hexagoxel> lamster: Data.Map.Lens docs links to anything relevant.
16:24:43 <hpc> figuring out how to express useful constraints that you can use at the value level is an art
16:24:43 <koz_> (well, type-checking-time actually, IIRC)
16:24:45 <Twey> koz_: You can write as much or as little into your types as you want.  So you can still write vectorNub ∷ Eq a ⇒ Vec n a → ∃m. Vec m a.  But you could also give more interesting guarantees.  The best you'd get for Vec is probably something like Vec n a → ∃m. (Vec m a, m ≤ n).  But you could imagine making a new NubVec type defined such that no two consecutive elements are equal, and having your
16:24:47 <Twey> function be into that.
16:24:50 <lamster> hexagoxel: cool, I somehow didnt saw it and cannot find it. Thank you! :)
16:25:08 <hpc> for example, something you can do in agda is define a sort function with the following type (in pseudocode)
16:25:16 <hpc> take a list of elements of some type
16:25:39 <hpc> and produce a list of elements of that type which is a permutation of the original list, in which each element is greater or equal to the element before it
16:26:11 <hexagoxel> lamster: yeah, this example is not directly on Data.Map.Lens, you have to go through to FoldableWithIndex.
16:26:19 <hpc> it's hard to write that constraint at the type level, and it's hard to write code that behaves with respect to it
16:26:22 <koz_> hpc: Woah.
16:26:32 <hpc> but at the end of it you have a sort function that you know produces the right answer
16:26:59 <hpc> if it's too hard to write, and you know that you don't need that level of rigor in things that consume sorted lists
16:27:07 <hpc> you could as an implementor loosen the type a bit
16:27:15 <hpc> maybe sort just makes a list of the same length
16:27:23 <hpc> or it makes a sorted list of unknown length
16:28:18 <koz_> That sounds pretty damned amazing.
16:28:30 <hpc> where new languages fall on that scale of tradeoffs is going to be an interesting evolution to watch, i think
16:28:34 <Twey> koz_: This is why dependent types are not inferrable — the type carries *more* information than the code.  The contract the function adheres to may be looser than the actual behaviour of the code, and it may be looser in many different ways.
16:29:02 <hpc> i am very excited
16:29:25 <mikail`> if I have series of rseq's in a do clause, if one of the rseq computation returns a failure is it possible to force fail the following rseq's?
16:29:26 <Twey> koz_: But this is a nice solution to e.g. the semantic versioning problem.  Now you can specify the contracts your functions adhere to in the code itself.
16:29:51 <koz_> Twey: Yeah, make sense.
16:29:53 <Twey> Rather than depending on some coarse-grained approximation hopefully encoded as a standardized string of integers.
16:30:29 <Tuplanolla> I can't wait to see floating-point types ruin it all.
16:30:41 <koz_> Floating-point types ruin everything.
16:30:55 <Twey> Tuplanolla: I think we generally just try to avoid writing floating-point types ;)
16:31:03 <hpc> sometimes when you're drowning in types, you need something that floats
16:31:13 * hpc will let himself out now
16:31:16 <Twey> (TBH you can handle them in deptypes about as well as in anything else, i.e. with a lot of ugliness)
16:31:22 <koz_> hpc: It's not as bad as a joke I heard recently.
16:31:24 <Twey> (but rationals are often nicer)
16:31:38 <koz_> Something about how people who read category theory papers are co-authors. :P
16:31:47 <Twey> koz_: Heheh
16:31:50 <hpc> that is incredible
16:31:59 <hpc> i am never going to not use that joke
16:32:04 <koz_> I claim no credit for that one: jared-w is responsible.
16:32:31 <Tuplanolla> Imagine "this Monte Carlo process converges at this rate" as a type.
16:32:35 <koz_> But then again, I suspect most of my jokes are co-funny.
16:32:43 <Twey> If you've been in this channel and haven't picked up at least three stupid co- jokes, copumpkin has failed you
16:32:55 <koz_> Twey: I've only picked up two.
16:33:30 <Twey> koz_: If jokes are things you tell to make other people laugh, surely cojokes are the ones you tell to make yourself laugh.
16:33:40 <Twey> Tuplanolla: I'd rather not
16:33:49 <koz_> Twey: So the definition of a co-joke is an inside joke?
16:34:05 <Twey> Tuplanolla: Well, rather, the type isn't too bad
16:34:15 * koz_ wonders where Edward Kmett is to insist that co-jokes are strong lax semi-monoidal something-or-others.
16:34:17 <Twey> Tuplanolla: Writing a term for it, on the other hand…
16:34:31 <hpc> they're definitely lax
16:35:20 <koz_> On that subject: I know that Applicatives are lax monoidal functors - is there something in Haskell-land which is a non-lax monoidal functor?
16:35:35 <Tuplanolla> Even the type would be pretty disgusting, because it would depend on the statistical properties of the random number source, Twey.
16:35:51 <dsal> Anyone have a favorite function benchmark tool?
16:36:03 <dsal> I want to changes some stuff around here.
16:36:14 <koz_> dsal: I think criterion is what people use.
16:36:29 <dsal> That's what google brought up.
16:38:07 <Twey> Tuplanolla: I'm thinking ‘at this rate’ just means defining the properties of a step, then giving a Vec of steps to convergence.
16:39:07 <Twey> Tuplanolla: So only the length of the Vec depends on the properties of the source (or other execution details).  The tricky bit is proving that the length of the Vec is correct (given your chosen randomness source, &c.).
16:44:37 <Twey> koz_: You can write a strict version by giving an inverse to the lax monoidal functor maps
16:48:42 <naddeoa> Hey, beginner here. I have a quick question about type classes (let me know if this is the wrong place). Should I be using type classes for things that I don't intend to share? It seems like I can accomplish the same thing with a function with a case statement for my own code.
16:49:50 <Twey> naddeoa: You can't case on types
16:50:34 <Twey> naddeoa: There's no equivalent to 'foo x | x is an Int = …; x is a Float = …’.  For that you need to use a type class
16:51:27 <naddeoa> ah, so if I'm just trying to do different things for different "data" types (perhaps union types?) then it would be overkill
16:51:42 <naddeoa> I'm coming from Elm so I'm not sure how much of the language is the same
16:52:09 <naddeoa> data MyType = A | B  | C is what I have in mind
16:52:32 <c_wraith> the language is pretty similar, just with a lot more abstraction ability
16:52:34 <Twey> naddeoa: You can replace a type class with an enum in general, but you lose type information by doing so.  data IntOrFloat = Int Int | Float Float; foo ∷ IntOrFloat → IntOrFloat gives you less information than class IntOrFloat where …; foo ∷ IntOrFloat a ⇒ a → a because you don't know that the input and output are of the same type
16:53:29 <naddeoa> oh interesting, I didn't think about that
16:53:55 <c_wraith> naddeoa: a very rough guideline for creating a class is "don't". A less-rough guideline is "create a class when you want to be able to operate on different types without caring about what type you get"
16:54:39 <Twey> naddeoa: But the former ‘foo’ is in some sense more powerful than the latter because it's allowed to do different things depending on what's in the sum, whereas the latter must be parametric (i.e. do the same thing in all cases, up to the different definitions of the type class functions)
16:54:49 <c_wraith> naddeoa: when you care what type you get, a class is the wrong choice. :)
16:55:27 <naddeoa> I had thought of types a little differently I suppose
16:55:50 <naddeoa> With "data MyType = A | B", I considered there to be one type, "MyType"
16:56:01 <c_wraith> naddeoa: that's true.  A and B are constructores
16:56:29 <naddeoa> Oh and you're saying that a type class can just be any old type
16:57:06 <c_wraith> well, there are some limitations involving the shape of the class fitting the shape of the type, but that's a bit of a distraction
16:57:06 <naddeoa> oh, so this is the thing that map would use to allow people to define map on their own types
16:57:23 <Twey> naddeoa: But one type can *contain* multiple types.  So ‘data MyType = A Int | B Float’ is a type that contains either an Int or a Float, depending on which constructor was used to construct it.
16:57:45 <c_wraith> naddeoa: In fact, there's a built-in class for that.  Functor lets you define a slight generalization of map (called fmap) for your type.
16:58:20 <naddeoa> ah so, fmap. Elm has the Cmd type which I'm using to think about the Haskell IO type
16:58:41 <naddeoa> Elm also defines a Cmd.map function. In an effort to map between different IO types i was using fmap. Is that what I should be doing?
16:58:54 <c_wraith> naddeoa: that works
16:59:02 <naddeoa> Is it idiomatic?
16:59:04 <c_wraith> yes
16:59:20 <c_wraith> There is also an infix name for fmap, <$>
16:59:43 <naddeoa> oh, I thought that was a precedence operator (like <| in elm)
16:59:44 <c_wraith> Sometimes that feels nicer to use.  But it's exactly equivalent
17:00:03 <c_wraith> Elm's <| is probably $
17:00:41 <naddeoa> Oh, woops. I thought your < and > were to be disregarded 
17:00:48 <c_wraith> not in this case! :)
17:00:53 <naddeoa> my bad
17:00:59 <c_wraith> :t fmap
17:01:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:01:05 <c_wraith> :t (<$>)
17:01:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:01:10 <naddeoa> that's a nice bot
17:01:29 <hpc> > "the " ++ "nicest"
17:01:31 <lambdabot>  "the nicest"
17:01:35 <c_wraith> :t fmap read getLine
17:01:37 <lambdabot> Read b => IO b
17:01:47 <naddeoa> So, when I was looking for mapping IO, I came across mapM, which apparently not the same thing
17:02:06 <Tuplanolla> You can think of `Functor f` as an additional dictionary argument that contains the implementation of the interface for the given type, naddeoa.
17:02:23 <c_wraith> mapM is for when you want to apply a function that produces an IO action to every element of a list and collect the results.
17:02:33 <Tuplanolla> That's how the compiler does it and probably how you'd do it in Elm too.
17:03:37 <c_wraith> naddeoa: So, like...   if you had doesFileExist :: Filename -> IO Bool and wanted to check the existence of a list of files
17:04:09 <naddeoa> Why can't I just use map for that?
17:04:20 <c_wraith> the types work out differently.
17:04:28 <c_wraith> If you used map, you'd get [IO Bool]
17:04:33 <c_wraith> mapM gives you IO [Bool]
17:04:37 <naddeoa> ah
17:05:48 <naddeoa> I 'm rewriting a system setup script I use in Haskell arbitrarily and I'm finding its mostly IO. I'm wondering if I should have picked something else
17:06:04 <Cale> naddeoa: IO is good in Haskell
17:06:20 <dsal> Anyone have a pointer to a stack/cabal project that has benchmarks and tests?  I want to lay this stuff out sensibly.
17:06:29 <hpc> it's a lot like Maybe, the advantage of having it is the option of not using it
17:07:11 <hpc> another advantage is the ability to treat IO actions in a first-class way
17:07:43 <hpc> :t forkIO -- a trivial example of an operation that's full of "design pattern" hacks to implement in something like java
17:07:44 <lambdabot> error: Variable not in scope: forkIO
17:07:46 <naddeoa> Its looking kind of annoying so far. I'm going to have to make a lot of system calls and check result status
17:07:48 <hpc> :(
17:07:50 <hpc> @hoogle forkIO
17:07:50 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
17:07:50 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
17:07:50 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
17:09:21 <hpc> naddeoa: you can write something like interpretSyscall :: IO Int -> IO (Maybe String)
17:09:37 <hpc> interpretSyscall (exec "ls /etc") -- returns Nothing
17:09:50 <hpc> interpretSyscall (exec "ls /doesnt/exist") -- returns Just "error message of some sort"
17:09:53 <hpc> or something like that
17:10:28 <hpc> naddeoa: you have a lot of power to factor out similar operations
17:16:54 <Cale> naddeoa: By system calls, do you mean running external processes? There's readProcessWithExitCode in System.Process which you can probably use.
17:17:05 <trigone> hi! is there somewhere a library for parsing .hs files into whatever structure that would represent as-is haskell modules (without losses or modification)?
17:18:07 <trigone> (which for example would allow modifying some part of a module and outputting back a plain-text file)
17:18:11 <Cale> trigone: haskell-src-exts
17:18:43 <Cale> Or if that isn't enough for some reason, there's GHC-as-a-library, but that's more annoying to use.
17:19:14 <Cale> Also note that it's possible to write compiler plugins for GHC which do all sorts of stuff to transform the code at compile time.
17:19:41 <trigone> Cale: thx! how would one go to try to create such a plugin?
17:20:22 <naddeoa> Cale: yeah that's what I'm using, but now I have to check return codes everywhere
17:20:43 <hpc> naddeoa: check out ErrorT
17:20:44 <naddeoa> I mean, if I were doing it in shell I would just ignore them so I guess that's the entire point
17:20:50 <hpc> or EitherT, i forget which one is deprecated
17:21:36 <hpc> naddeoa: if you write some sensible wrappings around readProcessWithExitCode, that type will thread the error handling through your code
17:22:23 <hpc> (this is an almost ideal introduction to monad transformers too, if you haven't used them yet)
17:22:36 <naddeoa> I have not
17:22:41 <naddeoa> the most I've done is mapf
17:23:21 <Cale> Or even just use IO exceptions...
17:23:51 <Cale> Of course, you can just ignore the process exit codes too
17:23:52 <naddeoa> Is that something besides ExitCode?
17:24:18 <Cale> Well, you could throw an exception when the ExitCode isn't what you wanted it to be, and then catch it somewhere else
17:24:27 <Cale> But I don't really know what's going on
17:24:40 <trigone> Cale: i'm looking at stuff related to GHC plugins, and i see everywhere the word "core". does that mean you can only work with the version of the module rewritten in "Core" (the language)?
17:24:49 <naddeoa> Its really just setting up a bunch of symlinks and installing packages for when I reformat my boxes
17:24:56 <Cale> If you would normally just write a script which ignores the exit codes, it's just as easy to ignore the exit codes...
17:24:59 <naddeoa> so, making sure network installs happen, running apt, etc.
17:25:06 <naddeoa> yeah true
17:25:23 <naddeoa> I just wanted to make sure I picked a good project to showcase the strengths of haskell
17:25:44 <Cale> trigone: Well, yeah, your code gets inserted as a pass which acts on the core representation inside GHC
17:26:04 <cheater> if i see foo bar baz `quux` bloop, then how do i know what `quux` applies to?
17:26:11 <cheater> what is its left argument?
17:26:17 <Cale> It applies to foo bar baz
17:26:20 <cheater> always?
17:26:22 <Cale> always
17:26:24 <cheater> thanks
17:26:34 <Cale> Function application always binds more tightly than any infix operator
17:26:40 <cheater> OK
17:26:43 <cheater> that's good to know
17:26:46 <cheater> i wasn't sure of that
17:26:53 <trigone> hm... but if you want to write extensions of syntax? GHC won't be able to make sense of something which isn't "normal haskell" before you're allowed to have an effect with your plugin...
17:27:03 <Cale> trigone: That's correct
17:27:55 <Cale> trigone: Then again, if you're doing stuff that's syntactically invalid, haskell-src-exts won't help much either.
17:28:01 <cheater> i have updated a convex programming lib (hvx) to work on ghc 8.2.1, however when i run my problems against it, ghc runs out of memory. i suspect a memory leak. how could i find out what is eating the memory?
17:28:09 <Cale> (well, it might help generate Haskell source)
17:29:09 * hackagebot currencies 0.1.0.0 – Currencies representation, pretty printing and conversion – https://hackage.haskell.org/package/currencies
17:29:15 <naddeoa> Are there tools to search for libraries/functions by signature? If I have a [IO String] and I want to turn it into an IO [String} for example
17:29:26 <trigone> Cale: depends if i can use part of the library you pointed to create a translating function of sorts, for the part of the syntax which isn't normal. it's better than to start from scratch... (probably)
17:31:04 <alx741_> naddeoa: hoogle?
17:31:08 <trigone> Cale: do you know if the parser of the library erases comments or keeps them?
17:32:31 <trigone> nvm it does seem to at least potentially keep them :)
17:33:21 <naddeoa> alx741: should have tried that first, thanks
17:34:01 <orzo> I've got some code that compiles fine, but gives me a skolem escaping scope error when i try to enable TypeFamilies.  How does the absense of typefamliies help it compile?
17:37:02 <eschnett> orzo: it’s always easier to answer such a question if you can show some code?
17:41:49 <orzo> eschnett: http://lpaste.net/357823
17:42:58 <trigone> Cale: thx btw!
17:44:01 <naddeoa> I've been creating case statements to do tests on data types. If there a shorthand way of doing when (a == SomeType) ..
17:44:18 <naddeoa> where ' data MyType = SomeType | SomeOtherType'
17:45:15 <naddeoa> This particular case would actually be for the ExistCode type to test for ExitSuccess
17:46:01 <orzo> the infered type HandleHi a1 -> t0 seems wrong to me
17:46:08 <orzo> for await'
17:47:04 <orzo> eschnett: more context,  type HandleHi a = Maybe (Either String (Message, Tox.Address)) -> IO a
17:49:57 <eschnett> orzo: the inferred type seems right, if e.g. err = String
17:50:51 <eschnett> orzo: why do you have an explicit “forall a” there?
17:51:55 <orzo> Transport shouldn't be parameterized on a in my thinking
17:52:27 <tmciver> Hey folks. I'm struggling with trying to use TypeFamilies and ExistentialQuantification (but I think the problem I'm having is more general and has to do with type classes). This paste should help explain the problem I'm having: http://lpaste.net/357824
17:53:10 <orzo> if i did not explicitly quantify a that way, Transport would have another parameter and a lot more code would need to change.  What's wrong with letting a range free?
17:53:14 <tmciver> I guess my question is: must I create an existential type wrapper for all the type family data types I declare in a type class?
17:53:46 <tmciver> . . . if I want to return values from functions that have the type class constraint?
17:55:43 <orzo> eschnett: awaitMessage used to be different and I somewhat more recently switched to a continuation-passing style, and the type of a depends on the type of continuation passed, not on the Transport 
17:56:26 <dsal> Hmm...  My go implementation of this is 10x faster than my haskell implementation.  I think it's generating a list and folding over it vs. just a loop.
17:56:47 <orzo> you do both go and haskell?  Is that common?
17:57:12 <dsal> I wouldn't expect many people in here to only program in one language.
17:57:13 <orzo> heh
17:57:31 <eschnett> orzo: the forall is fine… this was just the line that reported the error; i was wondering whether the forall extension and the type family extensions had some bad interaction.
17:57:55 <eschnett> orzo: sorry — i can’t help further, i don’t see either what is wrong here.
18:00:08 <naddeoa> Can you destructure while retraining the original reference? Something like  func (MyType a b) as myType =...
18:01:21 <dsal> I guess I can see what unrolling does...
18:02:21 <geekosaur> naddeoa, func t@(MyType a b) = 
18:02:28 <naddeoa> thanks!
18:03:33 <remexre> Is there a way to turn IO (Either MyError a) into a single monad with mtl? I couldn't find a transformer for IO
18:04:35 <boj> @hoogle MonadIO
18:04:35 <lambdabot> Control.Monad.IO.Class class (Monad m) => MonadIO m
18:04:36 <lambdabot> Yesod.Core class Monad m => MonadIO (m :: * -> *)
18:04:36 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
18:05:19 <remexre> Is that @me? I, uh, don't know what that means
18:05:32 <boj> remexre: is that what you are looking for?
18:06:40 <boj> f :: MonadIO m => m (Either MyError a)
18:07:21 <remexre> Hm, let me try that; would that mean my function would be polymorphic in the return type
18:07:21 <remexre> ?
18:07:53 <boj> well, your return type stays the same. Either MyError a -- the 'a' is polymorphic
18:08:30 <remexre> Right now, I'm trying to simplify a function that's (FilePath -> IO (Either MyError Foo)) to not have to pattern-match on Either
18:08:37 <orzo> eschnett: I have another puzzle that seems similar but unrelated.  TypeFamlies are off now, and it compiles, but turning on PartialTypeSignatues and adding a :: _ signature somewhere causes a whole bunch of errors when it compiles fine without it
18:10:10 <orzo> maybe i should remove TypeApplications which is kind of new and maybe buggy
18:10:14 <penteract> remexre: I think (ExceptT IO) works
18:10:27 <boj> remexre: you could explicity ask for the Right. (Right r) <- myFunc
18:10:37 <remexre> penteract: And flipping IO to be on the inside instead of the outside doesn't break
18:10:51 <penteract> look at the definition of ExceptT
18:10:54 <dsal> Does anyone have any ideas on how to make this perform better?  http://lpaste.net/3950255024709304320
18:10:58 <remexre> boj: oh, didn't know that worked
18:11:47 <dsal> I suspect that thing on line 25 where I generate a list to do the per-bit stuff could be better, but I'm not entirely sure what a better structure would look like.
18:11:58 <remexre> penteract: oh, cool, that's exactly what I'm looking for; I'm new to using monad transformers, so I'm not 100% familiar with all the transformers, thanks!
18:17:38 * hackagebot currencies 0.1.0.1 – Currencies representation, pretty printing and conversion – https://hackage.haskell.org/package/currencies
18:18:23 <dsal> unsurprisingly, profiling tells me perbit is where I spend most of my time.
18:19:09 <penteract> remexre: They aren't always obvious, but do what you want surprisingly often :)
18:19:41 <naddeoa> What does it mean when a function is suffixed with an underscore_? 
18:22:59 <cheater> hi
18:23:13 <cheater> how could i rewrite subgradLoop so that it doesn't use recursion? http://sprunge.us/ZGRM
18:25:19 <orzo> making the magical variable that compiles when no signature is attached a top-level declaration triggers "ghc: panic! (the 'impossible' happened)
18:28:12 <MarcelineVQ> which version of ghc
18:28:40 <cheater> can i say that subgradLoop is some sort of fold?
18:29:31 <boj> orzo: i tend to see that when i put a makeLense def *after* where i use it
18:29:53 <boj> then all the TH hate becomes clear
18:31:03 <cheater> if i want to seq two values foo and bar, can i do seq (foo, bar) $ baz foo bar or will this not force them?
18:31:21 <orzo> boj, well, i'm not using TH
18:32:26 <geekosaur> cheater, pretty sure that forces only the tuple constructor
18:32:33 <cheater> geekosaur: thanks
18:32:36 <geekosaur> seq foo $ seq bar $ ...
18:32:59 <cheater> yep
18:33:22 <MarcelineVQ> $_$
18:36:51 <cheater> i am trying to find out where the memory leak comes from in this library i'm using, what are some good ways of doing that?
18:57:04 <dsal> Is there a way to tell whether a function is tail recursive?
18:59:13 <geekosaur> all functions are tail recursive
18:59:42 <geekosaur> haskell evaluation doesn't work like you are used to
19:00:08 <dsal> Hmm....  I'm trying to figure out why this inner loop is allocating.
19:00:43 <dsal> I made a thing to fold over bits in a byte.  33% of my allocations happen there, but it shouldn't need to allocate anything.
19:01:42 <dsal> http://lpaste.net/357825
19:04:14 <geekosaur> not enough information there. generally I'll inspect Core --- but that's not going to be very useful for beginners
19:05:46 <dsal> I'm just trying to understand how to measure and improve performance here.  My initial version is 10x slower than the go code I ported it from:  http://lpaste.net/3950255024709304320 (which makes sense because the go code is a lot lower level)
19:06:14 <geekosaur> in general, however, memory leaks in this kind of code are caused by excessive laziness --- building up unevaluated thunks. (remember that tings don't generally get evaluated until something actually needs the result)
19:06:21 <dsal> profiling points to what is basically folding over the bits, which, yeah, is the most run code.  It's the allocation that's annoying.
19:07:14 <dsal> The profile is over my test cases.  this code is [Word] -> crc16, and then it validates the result.  I don't think there'd be any excessive laziness.
19:10:20 <geekosaur> actually I'd think there would be unless the lowest level stuff (is (≫) a local alias for shiftR?) is strict
19:10:35 <cheater> damn i fixed the memory leak
19:10:38 <cheater> using deepseq
19:10:42 <cheater> very happy with myself!
19:11:23 <dsal> Hmm...  I guess I need to figure out what making something strict is all about.
19:11:42 <cheater> dsal: read the wiki page about foldl'
19:11:57 <cheater> here https://wiki.haskell.org/Foldr_Foldl_Foldl'
19:12:04 <cheater> also try reading this here https://wiki.haskell.org/Memory_leak
19:12:23 <cheater> although it's a bit outdated. now we have stuff like BangPatterns, strict data fields, and deepSeq.
19:13:31 <dsal> Thanks.  Let's see what this does.  My bitfold didn't really have much effect.
19:15:09 <geekosaur> sometimes just using ($!) in the right place (function application but with `seq` applied) helps
19:19:51 <dsal> Tossing one of those in shaved a bit off.
19:24:17 <cheater> do you have any recursion or iteration?
19:24:27 <cheater> or folds or anything like that?
19:25:40 <dsal> Yeah, this is like, two folds.
19:26:05 <cheater> what fold are you using?
19:26:10 <cheater> are you using foldl' ?
19:27:30 <dsal> I was originally using foldl on the inner loop, but I made my own fold.
19:27:49 <cheater> worst idea ever
19:27:52 <cheater> use foldl'
19:28:42 <dsal> ha.  Well, my fold is folding over bits in a byte.  Using foldl means I need to create a list to iterate over.  Then again, undoing that didn't make it better.  I'll just revert the things.
19:30:08 <Eduard_Munteanu> To operate on bits in a byte you might want to consider writing the whole expansion yourself.
19:30:35 <dsal> I thought about that.
19:31:15 <dsal> foldl' definitely seems worse than my own fold.
19:32:22 <Eduard_Munteanu> What is the actual operation you're applying on that byte?
19:33:16 <dsal> This is the complete working code:  http://lpaste.net/3950255024709304320
19:33:37 <dsal> It's computing a checksum, so it's doing some xors and stuff over each bit.
19:38:09 <Eduard_Munteanu> dsal, well, use foldl', not foldl
19:38:23 <dsal> I can't measure a significant difference.
19:39:29 <dsal> Seems a bit worse.   3.320 μs -> 3.426 μs
19:40:01 <Eduard_Munteanu> Are you measuring over many iterations?
19:40:33 <dsal> I'm using criterion.
19:40:52 <dsal> Doesn't seem to tell me how many it ran.
19:41:16 <dsal> My go test ran 5 million with an average of 325 ns
19:42:34 <Eduard_Munteanu> That list probably doesn't fuse away, might be significant.
19:42:58 <dsal> The generated one?
19:43:03 <Eduard_Munteanu> Yes.
19:43:17 <dsal> This was my custom fold I'd tried.  It did help some:  http://lpaste.net/357825
19:44:03 <Eduard_Munteanu> I'd try calling perbit manually 8 times.
19:44:21 <dsal> Yeah, the only issue there is I have to carry the return value around.
19:46:07 <Eduard_Munteanu> n `perbit` b `perbit` (b >> 1) ...
19:47:01 <dsal> Yeah.  it can't be that bad.  Will just be a lot less pretty heh.
19:50:49 <cheater> dsal: i think, with such small sizes, you're not going to see any sort of good behavior from this kind of function
19:51:09 <dsal> What do you mean?
19:51:12 <cheater> you'll need something that works with LUTs or indices into a memory region. stuff that doesn't need cache to warm up
19:52:59 <cheater> you only have up to 32 elements there
19:53:14 <dsal> 32 elements?
19:53:18 <cheater> yes
19:53:35 <cheater> your fold goes over a w32 right?
19:53:45 <cheater> and that's a 32 bit piece of memory
19:53:52 <cheater> so you perform perbit 32 times
19:54:06 <dsal> It's 8 times.
19:54:20 <dsal> It converts it to a w32, but just do the mathful.
19:54:22 <cheater> oh, even less important then
19:54:30 <cheater> foldl' is made to prevent stack overflows in situations where you have 500 000 elements
19:54:45 <cheater> it's not made for speed
19:55:03 <cheater> if you want speed, you want things like unboxed tuples, strict data fields, stuff like that
19:55:27 <cheater> you should look at the core output of this function and look into minimizing that
19:55:44 <cheater> but like, do you really need that tiny bit of performance? if so, why?
19:56:18 <Eduard_Munteanu> Surely there's an efficient CRC16 somewhere on Hackage, no?
19:56:50 <dsal> I translated this code from go. The go version is 10x faster.  I'm trying to learn how to measure and affect performance in haskell.
19:57:22 <dsal> It's this specific CRC16 I need.  It's kind of dumb, but it's needed for checksums in a protocol to talk to a device.
19:57:37 <mars0000> Hi, I was trying to configure Atom-Haskell. When I installed packages and set the parameters, I opened a hs file and hit “Haskell IDE -> Open REPL”, but got the following error msg “Error: ide-haskell-cabal is not defined while trying to get ide-haskell-cabal.builder”. Any idea? Thank you!
19:57:57 <lamster> Hi! Is it possible to derive Bifoldable / Bifunctor somehow similar to how we derive Foldable / Functor now ?
20:01:54 <cheater> dsal: there's a lot of boxing going on everywhere. be aware of this.
20:02:58 <cheater> dsal: it's very usual that direct translations will not perform well especially for tiny functions
20:03:21 <dsal> 1.975 μs   <--  that's manually appying each bit.  A bit better.
20:03:31 <dsal> Only about 5x slower.
20:04:08 <cheater> you generally don't want any branches and stuff like that
20:04:33 <dsal> I just want a sufficiently smart compiler.  :)
20:10:18 <dsal> @pl (\c -> f (t c))
20:10:18 <lambdabot> f . t
20:10:21 <dsal> heh
20:12:25 <dsal> @pl (\c a -> f c (t a))
20:12:25 <lambdabot> (. t) . f
20:31:07 <dsal> @pl (\a c -> perbit a (c b))
20:31:07 <lambdabot> (. ($ b)) . perbit
20:31:14 <dsal> I expected worse.
20:31:22 <dsal> but I don't quite understand that.
20:38:57 <Myrl-saki>       Expected type: Ordinal n
20:38:59 <Myrl-saki>         Actual type: Ordinal n
20:39:07 <Myrl-saki> GADT fun.
20:39:37 * nitrix licks Myrl-saki to make the pain go away.
20:39:52 <Myrl-saki> nitrix: b-baka.
20:39:59 <Myrl-saki> ' _ '
20:44:13 <Myrl-saki>     • Couldn't match type ‘n :<= Data.Singletons.Prelude.Enum.Succ n’
20:44:15 <Myrl-saki>                      with ‘'True’
20:44:19 <Myrl-saki> This hurts.
20:48:21 <geekosaur> have you considered one of the Nat plugins?
20:49:52 <Myrl-saki> geekosaur: Yep.
20:50:33 <cheater> dsal: why not look at what asm this code creates?
20:50:44 <cheater> dsal: look at it in ida, or something like that.
20:50:59 <cheater> or decompile.
21:43:45 <cocreature> can ghc efficiently convert between large enum-style (so no parameters) sumtypes (a few thousands branches) and integers or am I better off just making a newtype around Int?
21:45:50 * dramforever would expect Int to auto-unbox better
21:52:18 * hackagebot loc-test 0.1.3.1 – Test-related utilities related to the /loc/ package. – https://hackage.haskell.org/package/loc-test
21:52:18 * hackagebot loc 0.1.3.1 – Types representing line and column positions and ranges in text files. – https://hackage.haskell.org/package/loc
22:24:46 <dsal> Trying to work with ByteString -- is there an easy way to grab a slice out?  Also:  how do I read two bytes as a Word16?
22:27:10 <cocreature> dsal: I usually just use "take" and "drop" to get a slice
22:27:20 <cocreature> if I need it sufficiently often I define helpers for that
22:27:40 <dsal> Makes sense.  How do I get numbers out?
22:27:55 <cocreature> out of what?
22:28:49 <dsal> I've got a ByteString.  I want to slice out 2 bytes and then convert them to a word16
22:32:58 <Rotaerk> you can get a [Word8] with (unpack . take 2)
22:33:14 <Rotaerk> and then I guess find a way to combine two Word8s into a Word16
22:33:34 <dsal> Yeah.  I just figured that was a thing.
22:33:40 <dsal> The other way is available.
22:37:21 <cocreature> dsal: just bitshift one of them
22:38:00 <cocreature> for more complex stuff, the "binary" is probably helpful but if you just want to combine 2 bytes to a word16 bitshifting is the easier solutions
22:54:19 <lamster> Hi! Does ghc8.2 support deriving of Show1 etc?
23:00:31 <dsal> cocreature: Yeah, I'll see where this goes.  I've also got some that are signed it seems.
23:09:01 <erisco> lamster, no, it is not mentioned in the docs
23:09:40 <erisco> but it would be helpful because Show1 confused me to no end
23:10:07 <erisco> I just moved the pieces around for an hour until it compiled and called it a day
23:31:37 <cocreature> welp deriving Generic for giant sumtypes is not a good idea
23:38:53 <lyxia> cocreature: is it slow
23:39:10 <cocreature> lyxia: yeah and it ate all my memory
23:40:00 <cocreature> I’ve switched to a wrapper around CInt + pattern synonyms
23:41:48 <erisco> should that really happen? sounds like a bug
23:42:24 <cocreature> erisco: well I don’t think anyone argues that deriving should be slow but it’s a known “bug” and afaik it’s not easy to fix
23:42:51 <cocreature> the fact that Generics forces you to encode that large sumtype in a binary tree doesn’t help
