00:26:52 * hackagebot cabal2nix 2.4.1 – Convert Cabal files into Nix build instructions. – https://hackage.haskell.org/package/cabal2nix
00:48:12 * hackagebot numhask 0.0.9 – A numeric prelude – https://hackage.haskell.org/package/numhask
00:56:19 * hackagebot numhask-range 0.1.0 – Numbers that are range representations – https://hackage.haskell.org/package/numhask-range
01:12:33 * hackagebot stache 1.1.0 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
01:14:40 <guillaum2> I had a revelation (well, absence of) today. OverloadedLabels are just a new syntax and a already defined typeclass, but we can do exactly the same thing by creating a a typeclass per "label" and use the standard "function name" syntax. Did I miss something?
01:15:40 <pacak> setters?
01:15:54 <jle`> guillaum2: sounds about right to me
01:16:12 <pacak> s { blah = 100 }
01:17:13 <pacak> Or I'm missing something.
01:17:23 <jle`> guillaum2: kind of like how Symbol in GHC.TypeLits is just basically a bunch of separate and disjoint pre-made types with instances of typeclasses
01:17:37 <jle`> it's basically hooking onto existing haskell mechanisms
01:17:51 <jle`> pacak: referring to https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-OverloadedLabels.html
01:19:40 <codygman> Should Haskell code be almost twice as slow after dropping/flushing caches?
01:19:57 <guillaum2> jle`: ok, thank you ;)
01:22:57 <cocreature> codygman: are you talking about disc caches?
01:24:31 <[exa]> codygman: depends on how you measure it
01:25:39 <cocreature> without talking about a specific program it seems like the question is “can loading things from disk be twice as slow as loading them from memory” to which the answer is definitely yes
01:26:36 * koz_ just realized cocreature's nick is literally 'co-creature', like 'comonad' and 'coalgebra'.
01:26:40 * koz_ is very slow, apparently.
01:26:56 <cocreature> :)
01:27:35 <pacak> and coffe?
01:27:55 <cocreature> and covfefe
01:28:03 <koz_> pacak: I am unaware of what 'ffee' is. Likewise 'vfefe'.
01:28:09 <koz_> Although I am certain 'ffee' is better.
01:28:41 * koz_ just realizes that in Haskell-land, 'comorbid' has a very different definition.
01:29:00 <tsahyt> a comathematician is a comachine transforming cotheorems into ffee
01:29:45 <koz_> tsahyt: Much like a der is a comachine transforming de into ffee?
01:30:07 <tsahyt> I suppose so
01:32:24 <koz_> Today I just transformed coffee into a talk.
01:32:33 <koz_> (about recursion schemes)
01:32:51 <tsahyt> every time I get into trying dependently typed things in Haskell I eventually wonder why I'm doing this to myself...
01:32:54 <pacak> koz_: video/slides?
01:33:21 <codygman> cocreature: Yes, on linux you can use: echo 3 > /proc/sys/vm/drop_caches
01:33:26 <koz_> pacak: Slides. I'm hoping this talk will be recorded, but it depends if my uni's compsci club can arrange it.
01:33:29 <tsahyt> so I have a heterogenous list, indexed with a type level list. It can only contain types that satisfy a typeclass constraint which among other things tells me how to parse a single element from a string. now I want a parser for the whole list
01:33:43 <tsahyt> I feel like this should be possible
01:33:51 <koz_> tsahyt: It is. Let me pull up a link.
01:34:11 <koz_> tsahyt: https://wiki.haskell.org/Existential_type <-- this?
01:34:39 <tsahyt> I don't see how existentials would be helpful here. I already know the type of the list.
01:34:50 <tsahyt> or rather the type level list describing the element types
01:34:57 <pacak> koz_: Link to slides? Are you covering zygohistomorphic prepromorphisms?
01:35:04 <koz_> tsahyt: Ah, sorry then. I misread.
01:35:19 <cocreature> codygman: right. then without having seen the program a factor of 2 doesn’t seems unreasonable. if your programs runs sufficiently long and doesn’t perform file IO than the startup costs will be ammortized at some point but for short-running programs the overhead is significant
01:35:25 <koz_> pacak: Sure: https://notabug.org/aut-csc/talks <-- the one dated into the future
01:35:28 <tsahyt> hm. It'd be awesome if I could somehow solve this, because then the entire IRC protocol is basically just a bunch of type synonyms away
01:35:49 <tsahyt> e.g. type PrivMsg = Msg "PRIVMSG" '[NonEmpty Recipient, Text], etc
01:35:58 <tsahyt> with parsing and serialization taken care of
01:36:15 <tsahyt> now this is of course a massively overengineered solution to working with IRC, but it's weekend and I have nothing better to do
01:36:31 <koz_> tsahyt: Over-engineering is best engineering, after all. Gold-plate all the things.
01:36:31 <cocreature> tsahyt: what exactly is causing problems when you try to write the parser?
01:37:09 <tsahyt> cocreature: well I don't even know how to start. The type level list lays out the types of arguments to be accepted.
01:37:31 <codygman> cocreature: Okay, thanks.
01:37:45 <cocreature> tsahyt: can you show us some code? at least the part that defines the Msg type
01:37:57 <tsahyt> yes, let me clean this up a bit
01:38:00 <jle`> tsahyt: post some code
01:38:12 <jle`> oh
01:38:15 <jle`> i was beat to it
01:38:30 <cocreature> I suspect that the solution is either typeclass induction over the list or just recursion if that list is reflected at the value level
01:38:31 <jle`> it sounds kind of straighforward from how you've described it
01:39:01 <tsahyt> https://gist.github.com/tsahyt/2611d582e8f414ae5286545d3d4f24e7
01:39:08 <jle`> but i do know the feeling
01:39:20 <tsahyt> It's the parsers function that I'm currently struggling with. The individual parsers are straight-forward to write, but I've left them undefined for now until I can figure out how to piece them together
01:39:42 <tsahyt> Raw is the Msg type from above
01:41:04 <jle`> tsahyt: yes you do need some sort of witnesses for xs
01:41:18 <jle`> just PList isn't enough
01:41:38 <tsahyt> witness as in a proxy or something for it?
01:41:43 <cocreature> -XAllowAmbiguousTypes :P
01:41:43 <tsahyt> or rather as in a singleton
01:41:52 <jle`> more like a singleton
01:41:54 <jle`> or a typeclass
01:41:59 <jle`> that's or as in, one or the other
01:42:06 <cocreature> oh nvm I can’t read
01:42:09 <jle`> you can go some sort of GADT-witness route, or the typeclass route
01:42:17 <jle`> i prefer the former since it's more first-class to me
01:42:20 <tsahyt> hmm, yes that's what I was thinking. Then I started reading back into the singletons library and got frustrated again
01:43:17 <jle`> doesn't have to be singletons the library, just something with similar power/functionality
01:43:27 <tsahyt> but why can't I take xs from the parameter to PList?
01:43:40 <jle`> because 'xs' doesn't exist at runtime
01:43:42 <jle`> it's erased
01:44:01 <jle`> well, an ad-hoc typeclass might be the "fastest" route here
01:44:23 <tsahyt> ah so what you're saying isn't that I need to pass an additional parameter but that I can fetch a singleton via say a typeclass from xs
01:44:32 <cocreature> I’m not sure I buy that the problem here is that “xs is erased”. the type has to be known statically anyway
01:44:34 <tsahyt> the singleton being a value that is available at runtime
01:44:36 <jle`> either (1) you create an ad-hoc type class
01:44:44 <jle`> or (2) you pass some sort of singleton witness and pattern match on that
01:44:53 <jle`> cocreature: not necessarily
01:44:55 <tsahyt> jle`: what does the GADT-witness route look like? is there an example somewhere?
01:45:09 <jle`> the type of parsers is forall xs. Parser (PList xs)
01:45:24 <jle`> so it can be dynamically instantiated to any type xs
01:45:43 <jle`> if xs is known exactly at compiletime, you can get away with just using a recursively defined typeclass
01:46:17 <jle`> so if you never need to use a generic PList xs, but always a PList '[Foo,Bar] known at compiletime, you can just use a typeclass
01:46:21 <cocreature> the type of “parsers” seems too general anyway since there is no way to get a parser for an arbitrary x
01:46:44 <jle`> yeah, in that situation, xs doesn't exist.  you have to add more to the type
01:47:00 <jle`> tsahyt: i do something similiar in my short/incomplete dependent types tutorial
01:47:12 <jle`> to write a Random/Binary instance
01:47:29 <jle`> 'get' from Binary is basically a parser
01:48:39 <jle`> it's slightly different in your case because not only do you have to carry around a witness for xs, but also the witness for the Render instance for every item
01:49:50 <jle`> but yeah if you want something to "just work" now, you can write an ad-hoc typeclass.  write a Parseable '[] instance, and a (Render a, Parseable as) => Parseable (a ': as) instance.  i don't really like it because you basically create an ad-hoc typeclass for every operation though.
01:50:42 <cocreature> you don’t necessarily need a separate class here. you might just be able to reuse the "Render" class
01:50:57 <cocreature> assuming there is also a way to "render" PLists
01:51:00 <tsahyt> yes, the entire PList should actually also be renderable
01:51:12 <tsahyt> it just space separates the entries
01:51:21 <tsahyt> but that'd also allow nesting
01:51:25 <jle`> tsahyt: wait, how are you parsing each type?
01:51:35 <tsahyt> jle`: using the badly named Render class
01:51:45 <jle`> ah i see
01:51:47 <jle`> seize
01:51:50 <tsahyt> I've yet to rename it to something adequate
01:52:19 <tsahyt> I suppose I could try to write instances for PLists. I'll give that a shot. it seems like the least effort way right now
01:52:37 <cocreature> tsahyt: http://lpaste.net/357461 should do the job
01:53:35 <tsahyt> I'll try that
01:56:11 <tsahyt> except for a missing pure, this compiled
01:56:23 <cocreature> oh right
01:56:31 <jle`> by the way i do recommmend against the style of directly encoding Render x => in the gadt
01:56:41 <jle`> even though i do it in my tutorial, before someone corrected me
01:57:43 <tsahyt> why is that? How else would I encode that *all* entries in the type level list satisfy the constraint?
01:58:06 <jle`> you can separate it out
01:58:31 <jle`> so `PList xs` can be the hlist of xs's
01:58:34 <cocreature> the Render instance that I defined above already implicitely enforces that
01:58:52 <cocreature> by enforcing the constraint in the Cons case
01:59:05 <jle`> and `Renderable xs` can be a witness of each x being renderable. and yeah the typeclass method means you don't even need this one (they have the same power)
02:00:42 <tsahyt> hmm I see
02:01:27 <jle`> added a comment to the gist, using machinery from the type-combinators library
02:03:03 <jle`> using type-combinators, it becomes just a 'traverse1'
02:03:15 <tsahyt> I'll have to read into this library, I've actually never seen it before
02:04:05 <jle`> parsers = traverse1 (seized \\)
02:04:08 <tsahyt> but the typeclass method also had the advantage of not needing the special render function for the entire plist
02:04:46 <jle`> well
02:04:53 <jle`> you can just write the render function as the method of the instance
02:05:24 <jle`> instance Known blah => Render (PList xs) where seize = traverse1 (seized \\) known
02:05:34 <cocreature> it’s more the other way around: the typeclass method forces you to split the definition in two parts
02:06:45 <jle`> added the instance as a comment so you can see it with fancy highlighting, heh
02:07:00 <tsahyt> thanks!
02:07:20 <jle`> in the end you're implementing the same logic and i believe that the two methods are roughtly equivalent
02:07:22 <jle`> in power
02:07:32 <tsahyt> I'd really have to read into type-combinators, this does look like witchcraft atm
02:07:53 <jle`> all of the individual types are actually pretty straightforward and i think you'd understand most of them
02:08:52 <jle`> some of the typeclass stuff though is a bit like wizardry.  a lot of it borrows from the 'constraints' library
02:09:36 <tsahyt> nice, it even works too. The type that I request properly determines the parser.
02:10:36 * hackagebot stache 1.1.1 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
02:10:47 <jle`> one thing that is being hidden here is that 'Known (Prod (Wit1 Render)) as's instance is pretty much doing the same recursive typeclass business as cocreature's solution
02:11:06 <jle`> actually hm i think it does something slightly different with another layer of indirection
02:11:18 <jle`> tsahyt: that's a nice thing :)
02:13:33 <tsahyt> I still don't see much of an advantage of this whole approach over just encoding the protocol in much simpler types, other than a reduction in boilerplate at the expense of probably being very unwieldy to use. but as said before, it's weekend.
02:18:35 <bwe> Hi, I am coming from flask (Python). I value it for bringing clean and well tested solutions live in a considerable small amount of time. Which web framework in the haskell world comes nearest to the qualities of flask?
02:19:11 <cocreature> tsahyt: one advantage is that you can now be proud to have written one of the most engineered haskell libraries for working with IRC messages
02:21:00 <jle`> bwe: the most flask-like haskell web framework i've used is scotty
02:21:04 <jle`> but it's been a few years
02:21:12 <cocreature> Spock is also similar
02:21:21 <jle`> tsahyt: type safety i suppose :)
02:21:28 <tsahyt> cocreature: well I've written part of it. I'll explore this further, and if something comes out of it that's great. I was also thinking of putting a servant-like framework on top of it for building IRC bots
02:21:37 <jle`> i explain some advantages in my tutorial too
02:22:13 <tsahyt> one advantage is that with some lensy stuff I can write functions operating over all IRC messages that contain a channel parameter for example, so there's that
02:29:48 <Myrl-saki> How to symbolically write functors?
02:30:16 <Myrl-saki> Like, there are 2 parts of functors.
02:30:19 <Myrl-saki> So, do I go like
02:31:00 <Myrl-saki> Yeah. I have no idea.
02:33:22 <cocreature> Myrl-saki: can you rephrase your question? I sadly have no idea what the problem is that you are trying to solve
02:33:35 <Myrl-saki> cocreature: It's more math than Haskell.
02:33:56 <Myrl-saki> cocreature: This is going to sound weird, but I find English to get confusing when it comes to math.
02:34:37 <cocreature> Myrl-saki: oh so you are looking for the math notation used for functors?
02:34:41 <Myrl-saki> cocreature: Right now, to give a specific example, I'm trying to write this symbolically. https://ncatlab.org/nlab/show/hom-functor
02:34:48 <Myrl-saki> cocreature: Rather, how to define what a specific functor does.
02:35:04 <Myrl-saki> The math notation for defining what a specific functor does.
02:35:36 <cocreature> I’m not sure if there is a nice way to do this without any english words :)
02:36:36 * hackagebot wreq 0.5.1.0 – An easy-to-use HTTP client library. – https://hackage.haskell.org/package/wreq
02:37:48 <Myrl-saki> cocreature: Time to invent a new notation lol
02:39:06 <cocreature> just say something like “let F:C->D be the functor defined by the mapping on objects F(o)=… and the mapping on arrows F(f)=…”
02:40:51 <lyxia> You can try to write that without any words F:{ C -> D ; o |-> ... ; f |-> ... } but most readers will find that a bit dry.
02:44:34 <Myrl-saki> cocreature: lyxia: Thanks.
02:44:40 <Myrl-saki> lyxia: This is just for internal notes so far.
02:46:46 <lyxia> Okay :)
02:48:37 <quchen> edwardk: It is an Iteratee!
02:48:47 <quchen> edwardk: You may not recognize Trifecta ;-)
02:49:03 <quchen> (API wasn’t changed, so no worries)
02:53:27 <cocreature> quchen: woah better docs for trifecta \o/
02:54:53 <quchen> cocreature: We added mostly documentation (including doctests) and gave internal values more descriptive names though
02:55:19 <quchen> …hoping the barrier of entry, possibly also for other doc contributors, is lower now
02:55:31 <Profpatsch> dcoutts: We were wondering where the “Hac” naming for Haskell conferences/hackathons comes from and what it stands for. (Zurihac, Bayhac, Munihac, HacFreiburg …)
02:55:55 <quchen> Pull request is still open and being worked on
02:55:58 <quchen> Oh, you’ve seen it already
02:56:03 <Profpatsch> dcoutts: Since you co-organized the early conferences (just called “Hac” apparently); maybe there’s a deeper meaning. :)
02:56:23 <cocreature> quchen: that’s why I’m excited :)
02:57:17 <quchen> cocreature: There is a lot of work left to do, Trifecta is full of unused-but-exported definitions for example
02:57:24 <quchen> And many useful names are taken by functions nobody uses
02:57:37 <quchen> But still they’re part of the API, so we can’t just take them out without a major version bump
02:57:52 <cocreature> well just do a major version bump :)
02:57:55 <quchen> And the output rendering is horrendous :-s
02:58:11 <quchen> Small steps! First step was understanding the lib and proving it by writing docs. :-)
02:58:45 <cocreature> although I have to admit that now that megaparsec seems to have added caret-based error reporting I’m considering switching away from trifecta
03:23:23 <quchen> Megaparsec is nicely maintained these days, yeah
03:24:54 <quchen> Maybe one day Parsec is deprecated in favor of it
03:25:31 <quchen> But I doubt it – Parsec still ships with its own incompatible <|> operator and the maintainer doesn’t care
03:25:44 <quchen> (Maybe it’s also completely unmaintained?)
03:26:43 <cocreature> it moved to the haskell github organization and I think hvr makes sure that it still builds but that’s about it
03:26:55 <cocreature> it does link to megaparsec in the readme :)
03:29:28 <quchen> Hah okay
03:30:02 <quchen> Not in the Hackage release though.
03:30:36 <cocreature> good point
03:30:47 <cocreature> *shrug* as long as there are alternatives I’m happy :)
03:42:19 <avn> Hello folks! Anyone can explain, why this simple example not builds? What I done wrong? https://gist.github.com/avnik/a7ca30df0b85d936c2fad501a30dd3e0
03:42:59 <quchen> avn: What’s the error?
03:43:41 <lyxia> fmap f x   <- types don't match here
03:44:41 * hackagebot SSTG 0.1.1.4 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
03:46:24 <ltielen> avn: should be just 'f x'?
03:46:47 <bjs> how do you know "x" can be fmap'd ? :)
03:48:42 <avn> ahh, so error should be read "don't know how to `fmap f x`"
03:48:48 <avn> Got it, tyvm
03:49:44 <bwe> jle` cocreature: Thanks for your recommendations.
03:50:54 <avn> Looks like I need solve more examples to understand how basic stuff works
03:56:16 <joco42> how do u guy protect certain functions in the service layer from unathorized access? for example in the datastore/service layer / rest layer setup ? I mean, how do you tell each function in the service layer who (which user)and when and how is allowed to execute the function ? any best practices on this ?
03:56:45 <joco42> i mean, the server side of a rest web app
03:57:09 <joco42> where can i learn about this more?
03:59:05 <bjs> avn: I mean, what do ypu want your "Box" functor instance to do
04:01:10 <cocreature> joco42: most web frameworks provide some way of protecting parts of your application using various forms of authentication so it depends on which framework you use
04:01:48 <avn> bjs: correct question.  And "I need to solve example expression from my haskell book" is wrong answer ;)
04:01:50 <bjs> avn: if you just want to be able to do something like `(+1) <$> Box 3` to get `Box 4` then you don't want to fmap over x at all right
04:03:13 <avn> bjs: so if I want to have `fmap f x` on right side, I need add constrain in Box a, that my a should have functor instance as well?
04:04:05 <bjs> avn: right, Haskell doesn't let you do that easily though
04:04:28 <joco42> cocreature, thanks, i look into them for inspiration
04:06:38 <avn> bjs: instance Functor a => Functor (Box a)? 
04:07:24 <bjs> avn: Well that won't work because you need something of kind * -> *
04:07:33 <bjs> and so you can't really add constraints to it
04:07:40 <cocreature> avn: you probably don’t want fmap on the right side :)
04:07:44 <bjs> (for Functor)
04:08:02 <bjs> avn: this is because you probably don't want a Functor instance that does this ^^
04:08:16 <cocreature> avn: are you aware of typed holes? they can be really useful for figuring out how to write these instances
04:15:06 <Franciman> Hi
04:15:40 <Franciman> hey minn, yesterday my internet connection dropped. Did you manage to solve your issues?
04:16:30 <Franciman> Is there anybody using wx?
04:16:46 <Franciman> I need help for wxHaskell on macosx
04:16:53 <avn> cocreature: possible not yet.  My knowledge of haskell have some holes, which I trying to fill up
04:17:58 <cocreature> avn: you can use underscores for terms that you have yet to figure out. if you try compiling a file which contains them, ghc will tell you the type of the thing that belongs here and the types of local variables
04:18:40 <cocreature> avn: e.g. try "fmap f (Box x) = Box _" in your example and see if you can’t figure out what the underscore should be replaced with using the information ghc provides you
04:20:43 <joco42> join #haskhel
04:21:30 <pacak> joco42: You already here.
04:21:40 <pacak> Mostly.
04:31:47 <quchen> How do I submit pull requests for Base?
04:32:02 <quchen> I can do it for GHC, but Github says I can’t (or shan’t) for Base.
04:32:23 <quchen> Or is Base in GHC and it’s just a GHC PR?
04:40:24 <yorick> .pointless (\(a,b) -> (b,a+b))
04:40:46 <yorick> @pl (\(a,b) -> (b,a+b))
04:40:46 <lambdabot> uncurry (ap (,) . (+))
04:42:42 * hackagebot HTF 0.13.2.1 – The Haskell Test Framework – https://hackage.haskell.org/package/HTF
04:45:55 <joco42> any ideas on this question : https://stackoverflow.com/questions/45531583/access-authorization-control-akka-persistence-service-layer-akka-http-stack ?
04:46:48 <joco42> well its a scala question
04:47:00 <joco42> but its kinda general
04:47:22 <joco42> i guess the same question comes up in haskell web apps too
04:56:41 <barrucadu> For the Haskell side of things, Spock can use a type parameter: http://www.spock.li/2015/08/23/taking_authentication_to_the_next_level.html
05:26:30 <trigone> hi, i'm trying to find references on ways to adapt the safety found in pure languages to impure languages... and so far i didn't find much... anyone got any?
05:28:10 <blade2> ciao
05:28:15 <trigone> (as in to adapt the techniques for type and IO safety to languages which don't really have them, but which may allow partial/manual emulation)
05:28:25 <blade2> !list
05:30:17 <trigone> nobody?
05:31:43 <Rembane> trigone: Like, try to avoid side effects in your functions?
05:37:03 <trigone> Rembane: well, yeah, but maybe there are other additional techniques... at least i hope so. like, i just started learning about type uniqueness, and i'm wondering if we can manually emulate that...
05:38:06 <trigone> overall, i'm seeking ways to code better in impure languages. to come back to coding blind without ever actually controlling the final result of my programming is not appealing, and since i'll soon have to start coding again in impure languages...
05:39:05 <Rembane> trigone: Ah, I see.
05:39:13 <Rembane> trigone: I have no real useful tips. :)
05:39:59 <trigone> most books and stuff on impure languages don't seem to have that good ideas to enforce safety in languages, so i'm wondering if there are still attempts at studying *better* ways to code in those languages...
05:43:40 <blade2> ciao
05:44:49 <mauke> blade2: hi
05:45:32 <trigone> every design pattern or other programming technique/style out there in impure languages seems for example to indeed embrace mutability with glee... :/
05:45:43 <trigone> does ciao mean hello? i thought it meant bye
05:45:57 <mauke> it's polymorphic
05:46:19 <mauke> are you german?
05:46:39 <trigone> mauke: ok, i didn know
05:46:42 <trigone> me?
05:47:21 <Franciman> trigone, it means both hello and bye
05:48:14 <trigone> Franciman: does it mean something specific originally? mind you i suddenly wonder where "hello" comes from...
05:48:45 <mauke> IIRC "hello" was invented for the telephone
05:49:02 <trigone> apparently it's from french "ho-la", meaning "hey-there"
05:49:24 <trigone> iirc?
05:49:28 <mauke> ... or not
05:49:39 <mauke> its use in print predates the telephone
05:49:47 <Franciman> trigone, uhm, I don't know actually, it's a way to salut people both when you're coming and when you're going away
05:50:20 <mauke> https://en.wiktionary.org/wiki/hello#Etymology
05:50:43 <Franciman> oh trigone ok I found out its origin, it's cool. It comes from a venetian word, sciao meaning slave :P
05:51:01 <mauke> now that's cool
05:51:05 <Franciman> and implying I'm your slave
05:51:08 <trigone> Franciman: well that's a weird way to say hello
05:51:12 <mauke> "at your service"
05:51:23 <Franciman> yeah 
05:52:24 <Franciman> focus says it was "s'ciavo" and the meaning is slave (I'm your slave) and it was a way to express respect
05:52:42 <trigone> maybe that was the way the poorer were forced to address the richer, and it stuck and then became the (colloquial?) norm at some point...
05:53:33 <trigone> what's venetial?
05:53:39 <trigone> venetian?
05:53:43 <Franciman> The language spoken in venice
05:53:52 <Franciman> and places around there
05:54:17 <trigone> Franciman: a full fledged language or a dialect of something?
05:54:24 <mauke> very similar to https://en.wiktionary.org/wiki/servus
05:54:43 <Franciman> yeah! In fact focus references to that, if you understand italian, here's the article: http://www.focus.it/cultura/curiosita/come-e-nata-la-parola-ciao-1
05:54:59 <Franciman> trigone, I guess a dialect, though I'm not sure whether it was recognized as a language
05:55:40 <Franciman> for wikipedia it's a dialect
05:56:44 <Franciman> well, to be honest in italy dialects have a lot of history and also written productions, maybe they all could have te potential to be considered languages
05:56:53 <trigone> nah sorry, i barely speak italian... i know very useful stuff though, through smart methods to learn languages, so if i'm lost or in need of something in italy, i can say "tutte le camere hanno l'aria condizionata"
05:56:55 <Franciman> almost all*
05:57:06 <Franciman> ahah
05:57:06 <mauke> "italy" is a modern invention :-)
05:57:39 <trigone> mauke: the case for all modern things... except wheelsl
05:59:08 <trigone> was italy part of some empire at the beginning of 20th century?
05:59:08 * hackagebot cabal-cargs 0.8.1 – A command line program for extracting compiler arguments from a cabal file. – https://hackage.haskell.org/package/cabal-cargs
05:59:21 <Franciman> no
05:59:33 <Franciman> parts of it, yes, though
06:01:05 <mauke> "Only 2.5% of Italy's population could speak the Italian standardized language properly when the nation was unified in 1861."
06:01:05 <trigone> hm
06:01:47 <mauke> https://en.wikipedia.org/wiki/Languages_of_Italy
06:01:47 <trigone> mauke: wow... though that depends how much "proper" it has to be...
06:02:59 <Franciman> trigone, in south italy some old people still can't have conversations in italian, for example my grandmother, even if she understands it
06:03:17 <trigone> so many languages...
06:03:24 <trigone> Franciman: what does she speak?
06:03:32 <Franciman> Neapolitan
06:05:05 <trigone> wonder how many languages will survive this century
06:05:53 <Tuplanolla> Ideally only English would.
06:06:11 <trigone> ideally?
06:07:24 <mauke> >implying English is one language
06:08:08 <Tuplanolla> The point of languages is to get ideas across, so having more than one is a hindrance.
06:08:54 <ongy> so why would english of all the choices survive
06:09:23 <trigone> Tuplanolla: yet knowing more than one language has been known to broaden the way one thinks, bc you separate the concept from the word.
06:10:01 <Tuplanolla> Simply because English seems to be the language of technology and scientific communication.
06:11:01 <mauke> >gedankenexperiment
06:11:18 <quchen> >Röntgenbremsstrahlung
06:11:47 <Tuplanolla> Yes, historically it was German.
06:12:07 <trigone> i vote for french just to spite
06:12:32 <bollu> trigone that's a strange argument. I'm multi lingual, and I don't really see the benefit of separating the concept from the work
06:12:33 <bollu> word*
06:12:45 <bollu> trigone more often than not, I associate the concept with the word I use the most for it
06:13:09 <Tuplanolla> I speak three languages as well. It has been nothing but a waste of time.
06:13:47 <Logio> Tuplanolla: try a fourth one, away from the Germanic family
06:14:13 <Tuplanolla> Korean does look interesting in the abstract.
06:14:25 <trigone> dunno, that's what i heard (some sociological studies) and to me it felt rather accurate, but that's personal experience...
06:14:48 <trigone> you mean korean language or "alphabet"?
06:14:56 <Logio> learning Russian will already teach you a lot about color theory and psychology of perception
06:15:27 <trigone> i don't really see why someone would learn three languages (well, two), if you don't like learning languages...?
06:15:28 <Tuplanolla> The phonology mostly, trigone.
06:15:45 <trigone> Tuplanolla: ok. don't know much of it
06:16:35 <Logio> trigone: three is the minimum number of languages you have to learn, living in Finland (counting Finnish)
06:17:05 <sproingie> the other two being english and ... swedish?
06:17:07 <ongy> 3(native + 2) is the minimum to learn for higher education here.
06:17:08 <Logio> well, have to study, not necessarily learn
06:17:15 <Logio> sproingie: correct
06:18:22 <trigone> hm i see... maybe the experience is negative when you're forced by circumstances without spontaneously seeing the need or the interest...
06:18:35 <sproingie> most learning is unpleasant when interest is lacking
06:19:03 <Tuplanolla> Programming languages have much more to offer in terms of time invested versus new insights gained.
06:19:07 <sproingie> which is why most of us (probably) hated school
06:19:38 <Logio> Tuplanolla: which is why every school should start teaching COBOL!
06:19:42 <Tuplanolla> Yes!
06:19:46 <Logio> instead of swedish :P 
06:19:47 <trigone> i think it's like cooking. for the most part, you don't need much cooking skills to survive and eat well. and you may feel like learning more cooking is waste of time. yet others will learn lots about cooking and not see it as a waste of time
06:20:08 <trigone> Logio: i vote for haskell
06:20:09 <sproingie> being a good cook gets you laid
06:21:07 <Logio> trigone: actually, in Finnish schools they are moving toward trying to tie maths and programming, I wouldn't put that as a silly proposition to that end
06:21:41 <sproingie> in American schools, they're moving toward tying maths and bibles
06:22:18 <Logio> sproingie: it also gets you good food as well, which is even more important
06:23:01 <trigone> math and programming could be good, provided the potential distaste for either does not overflow over the other...
06:23:03 <AndreasK> In austrian schools, they are not moving anything xD
06:23:20 <Logio> as far as learning languages go, I am of the opinion that learning other languages definitely teaches one how much better a language Finnish is
06:23:22 <sproingie> AndreasK: sounds like the perfect place to teach static types
06:23:27 <sproingie> (sorry about that)
06:23:53 <Logio> actually quite in a similar fashion as learning Haskell teaches you how scary other languages are
06:24:02 <AndreasK> I'm out of school long enough, and far enough from having someone in school that it won't bother me for a while. But its a good joke :D
06:25:02 * hackagebot hlibsass 0.1.6.1 – Low-level bindings to Libsass – https://hackage.haskell.org/package/hlibsass
06:25:02 * hackagebot sdl2-cairo 0.1.1.0 – Render with Cairo on SDL textures. Includes optional convenience drawing API. – https://hackage.haskell.org/package/sdl2-cairo
06:25:14 <ongy> I learned java basics in school. And I was really surprised how hard some concepts are to other people
06:25:35 <trigone> Logio: i think we should adapt haskell to the usage of a natural language :P
06:25:35 <sproingie> everybody's different
06:26:11 <Logio> trigone: well for generating natural language it's nice
06:26:24 <trigone> Logio: generating? from what input?
06:26:39 <Logio> I was really surprised when someone pointed out the numerals library here
06:27:05 <Logio> ut's a language geek cornucopia of inflections of numbers
06:27:09 <Logio> *it's
06:27:17 <Tuplanolla> @hackage numerals
06:27:17 <lambdabot> http://hackage.haskell.org/package/numerals
06:27:41 <sproingie> perl's Lingua:: namespace in haskell would be pretty nifty
06:27:45 <trigone> funny
06:28:28 <Logio> it also demonstrates why Finnish is the superior language, twice the LOC in the FI module compared to the Chinese one at second place :P
06:28:59 <hpc> so how long until {-# LANGUAGE Finnish #-}?
06:29:34 <trigone> Logio: wait, a superior language is a language needing more code to describe it?
06:29:52 <sproingie> well bigger is always better, no?
06:30:30 <Logio> trigone: obviously, if one word of Finnish requires multiple lines of haskell to describe, it must be more expressive than Haskell
06:30:40 <trigone> did i fall onto some C++ irc by mistake? :P
06:30:51 <Tuplanolla> Ablative shielding means protecting your children from languages with grammatical case.
06:30:59 <trigone> Logio: try describing Haskel in Finnish first, then you can compare :P
06:31:26 <sproingie> 20 years ago i thought there'd be programming languages based on languages other than english
06:31:54 <hpc> well there's whatever APL is
06:32:05 <sproingie> ok greek
06:32:10 <trigone> APL?e
06:32:48 <sproingie> new programming languages then.  but i guess there's something to be said for 26 letters and an almost complete lack of accents
06:32:59 <AndreasK> There are localized versions of VBA, which is always fun in international environments ...
06:33:10 <cheater> hi
06:33:31 <cheater> what's the best way to get ghc 8.2 on a generic linux?
06:33:38 <cheater> 32 bit
06:33:46 <cheater> i'm on an older ubuntu based system
06:33:57 <hpc> are there still 32-bit builds of ghc?
06:34:18 <cheater> why wouldn't there be?
06:34:30 <hpc> https://www.haskell.org/downloads/linux
06:34:43 <sproingie> https://www.haskell.org/platform/#linux-generic
06:35:02 <cheater> that's platform, can i just get ghc?
06:35:14 <sproingie> Core should be just the compiler
06:35:58 <trigone> i'm happy i only needed to learn english to be able to read code... if i had to learn finnish on top of dozens of other languages... mind you that'd make new jobs: code translators. and from then, new ways to introduce amusing bugs :P
06:36:01 <sproingie> nothing wrong with using the platform though.  if you don't want its bundled stuff, use stack
06:36:12 <cheater> oh here we go https://www.haskell.org/ghc/download.html
06:45:28 <cheater> thanks
06:53:10 <rightfold> If I want to write a type checker and I use bound for my expression AST, what would I use for my type checking context? As opposed to e.g. `Map String Type`.
06:56:19 <rightfold> Or should I instead use one of the combinators like `traverseBound_`?
07:01:45 * hackagebot collection-json 1.0.0.0 – Collection+JSON—Hypermedia Type Tools – https://hackage.haskell.org/package/collection-json
07:09:13 <cheater> what's the best way to make cabal compile my package/executable with -Wall without actually making this -Wall when someone else installs it to use it?
07:11:57 <Anarchist666_> On #haskell-stack nobody is answering. I am cannot install libffi package over stack https://pastebin.com/5WMUNXRL
07:13:37 <Franciman> cheater, you could add a flag?
07:14:00 <Franciman> or
07:14:01 <Franciman> you can do
07:14:09 <Franciman> cabal build --ghc-options=-Wa
07:14:11 <Franciman> -Wall
07:14:20 <Franciman> without adding ghc-options to .cabal file
07:21:05 <cheater> good idea
07:21:23 <pplorins> hi
07:22:57 <Franciman> ehm sorry, cheater, I've been a little bit inaccurate. You can have ghc-options also in the .cabal, what I mean is without adding -Wall to ghc-options in the .cabal file
07:38:49 <sproingie> Anarchist666_: sounds like a bug in the packaging, might need to submit it as a bug against the libffi package.  basically, part of it failed to be compiled with -fPIC
07:39:12 <sproingie> as in they didn't pass the flag
07:40:46 <sproingie> interesting how only part of that error is localized.  can't read it, but i suspect it's suggesting to recompile with -fPIC
07:41:49 <Tuplanolla> Is there a difference between `-fpic` and `-fPIC` or is that a deprecated concept?
07:42:04 <sproingie> it's -fPIC
07:46:27 <glguy> man gcc mentions: When generating code for shared libraries, -fpic implies -msmall-data and -fPIC implies -mlarge-data.
07:47:39 <glguy> and a couple of the architectures have similar comments about the difference
07:51:34 <Myrl-saki> lyxia: I decided to go with F_ob and F_arr
07:51:45 <Myrl-saki> lyxia: With Ob/Arr as accessors.
07:56:32 <sproingie> ah.  -fPIC is all i ever see.  -msmall-data only seems to be relevant on a tiny number of arches
07:59:40 <Anarchist666_> Do I need to rebuild gcc?
08:01:37 * hackagebot HTF 0.13.2.2 – The Haskell Test Framework – https://hackage.haskell.org/package/HTF
08:03:34 <sproingie> Anarchist666_: gcc is not the problem.  the build configuration for the libffi package is.
08:04:16 <sproingie> you could try editing the cabal file to add the proper flags and doing stack install on your fixed version
08:05:22 <sproingie> otherwise you'll have to wait for a fix
08:17:50 * hackagebot fixed-vector-hetero 0.3.1.2 – Generic heterogeneous vectors – https://hackage.haskell.org/package/fixed-vector-hetero
08:17:50 * hackagebot monad-control 1.0.2.2 – Lift control operations, like exception catching, through monad transformers – https://hackage.haskell.org/package/monad-control
08:18:36 <Wizek> anyone has experience with haskell-gi/gi-webkit2? What muight be missing if I get an error of `Could not load typelib for "WebKit2" version "4.0"` during build? Is there something I need to `apt-get`?
08:19:25 <paolino> hello, I'm on debian trying to compile HDBC-sqlite3 but cannot find the 'C' dependency
08:21:16 <paolino> because for some reason they are under /usr/lib/x86_64-linux-gnu/
08:25:05 <paolino> I tried cabal install --extra-lib-dirs=/usr/lib/x86_64-linux-gnu/
08:32:50 <paolino> it's not doing it , any idea ?
08:34:10 <cocreature> paolino: please show us the full error message and the exact command you ran
08:36:29 <paolino> cocreature, http://lpaste.net/357464
08:37:20 <cocreature> paolino: hm so what’s the name of the lib in /usr/lib/x86_64-linux-gnu/?
08:37:46 <puregreen> does anybody know a monad that has MonadFail and MonadIO but the 'fail' doesn't happen in IO? E.g. if you take `MaybeT IO`, 'fail' will return Nothing, but if you take `ExceptT String IO`, 'fail' will return Right (error ...). I want a monad that lets me get the 'fail' text (so, MaybeT doesn't work).
08:38:18 <puregreen> (and sure, I know that the proper way is to use something other than MonadFail, but that's hard to do at the moment)
08:38:18 <paolino> cocreature, I think the problem is nix in the way
08:38:45 <Welkin> I thought `fail` was always `error`
08:38:51 <Welkin> which is bottom
08:38:55 <cocreature> paolino: if you’re using nix you should probably compile in a nix shell that has sqlite3 available
08:39:01 <cocreature> Welkin: no it’s a typeclass method of MonadFail
08:39:10 <puregreen> > fail "hi" :: Maybe Int
08:39:12 <lambdabot>  Nothing
08:39:16 <hpc> and before that, it was in Monad directly
08:39:31 <cocreature> well it’s still in Monad, I just pretend it isn’t :P
08:39:33 <Welkin> was `fail` removed from Monad?
08:39:39 <hpc> :t fail
08:39:41 <Welkin> oh
08:39:41 <lambdabot> Monad m => String -> m a
08:39:43 <hpc> cocreature: hahahahaha
08:39:51 <hpc> i will pretend too, i think
08:39:52 <cocreature> it will be removed soon™
08:39:53 <Welkin> :t error
08:39:54 <lambdabot> [Char] -> a
08:41:07 <MarcelineVQ> still seems weird that it's  String -> m a  even in Control.Monad.Fail
08:41:26 <MarcelineVQ> one change at a time I guess
08:41:31 <cocreature> well it’s not a general purpose typeclass. it’s for desugaring faling pattern matches in do notation
08:42:12 <cocreature> if you want a typeclass to represent failures in your own code use MonadError from mtl
09:07:29 * hackagebot fltkhs 0.5.3.6 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
09:11:10 <minn> How are you supposed to access the user state in an Alex predicate? The documentation is pretty sparse, but section 5.2 of the manual suggests the predicate and user states are independent.
09:56:32 <ab9rf> i gave up on using alex and happy
09:57:47 <ab9rf> not convinced that they're "better" than simply writing a parser/lexer with one of the flavors of parser
09:57:50 <ab9rf> er parsec
09:58:37 <glguy> I mostly think of parsec as a stop-gap until I can make a real parser
10:00:15 <glguy> I like how happy grammars have a clearer distinction between the grammar and the code
10:10:02 <cocreature> the main reason why I like happy is that I just really hate left-factoring grammars
10:12:02 <glguy> I prefer the refactoring I have to do for happy to what I have to do with parsec
10:14:11 <oherrala> I liked how binary/cereal offer nice way to write both parser and producer to get the symmetry usually wanted for network protocols
10:14:46 <glguy> The nice way being that you write it twice?
10:16:38 <oherrala> glguy: Would be lovely to write once and get both ways
10:17:03 <hpc> doesn't trifecta get you that?
10:18:24 * hackagebot wai-predicates 0.10.0 – WAI request predicates – https://hackage.haskell.org/package/wai-predicates
10:18:52 <monochrom> I suggest the radical position (but Hoare already said it decades ago) of writing twice but having the computer prove or disprove their equivalence!
10:19:41 <cocreature> hpc: that would be news to me
10:20:13 <hpc> oh, maybe i am being silly
10:20:59 <hpc> ah, it being in the "pretty printer" category confused me
10:21:13 <monochrom> wait what? haha
10:21:37 <hpc> because of how it outputs diagnostic information, i would guess
10:23:05 <[exa]> Hm guys, might we have a poll? Doing a bit of pop research. Q: What's your main reason to use lenses?
10:26:22 <monochrom> First-class getter-setter, i.e., I can pass a getter-setter as a parameter, my algorithm can be parameterized by what getter-setter it receives.
10:29:26 <monochrom> Recall your binary search tree rotations. At various places you say "I need to read the left child" or "I need to set the left child to...". And you have always hardcoded the leftness there. Imagine now you can make it a parameter. Now you don't need to code up one "left"-rotation and one "right"-rotation. You code up one "p"-rotation and then instantiate p to left or to right.
10:36:35 <MichaelBurge_> [exa]: Rewriting a syntax tree, especially using Control.Lens.Plated and Data.Data.Lens
10:36:48 <dmj`> [exa]: Record updates become unwieldy very quickly
10:38:42 * hackagebot sproxy2 1.96.0 – Secure HTTP proxy for authenticating users via OAuth2 – https://hackage.haskell.org/package/sproxy2
10:59:28 <[exa]> monochrom, MichaelBurge_, dmj`, thanks for opinion :]
10:59:57 <Tuplanolla> Here's another one, [exa]: it takes less effort than not.
11:26:53 <dmj`> Is it possible to embed an HTML iframe into haddocks (ideally before the HTML output is generated, so as not to “patch” after the fact), if that makes sense
11:27:20 <harwiltz> Hello all. Does anyone here happen to have any experience with hscurses?
11:27:51 <Tuplanolla> Would you like to use Brick instead, harwiltz?
11:28:06 <harwiltz> Tuplanolla: I don't know what that is, but unfortunately I'm already in the middle of this project
11:28:11 <Tuplanolla> @hackage brick
11:28:12 <lambdabot> http://hackage.haskell.org/package/brick
11:29:31 <crucify_me> someone pointed out that I was confusing currying with composibility. so I'm composing (f . g) with this program. In the uncomment func co = (.) , why do I not need arguments like in the commented version ? thanks   https://ptpb.pw/OME5
11:29:32 <harwiltz> Huh, that looks pretty cool actually. But I'm already using hscurses and I don't wanna restart the ui 
11:29:44 <crucify_me> *uncommented
11:31:01 <harwiltz> The problem I'm having with hscurses may not even be solved with brick, it's just that when my window resizes, my ncurses windows don't automatically resize, which is inconvenient...
11:31:12 <geekosaur> that may well be fixed, actually
11:31:26 <geekosaur> ncurses doesn't like the haskell environment much, SIGWINCH is a known pain point
11:31:36 <Tuplanolla> Since `\ f g -> f . g` is `\ f g -> (.) f g`, which is `\ f -> \ g -> (.) f g`, which is `\ f -> (.) f`, which is `(.)`, crucify_me.
11:31:39 <geekosaur> not to mention that the curses api was well named >.>
11:31:45 <harwiltz> Haha
11:32:05 <crucify_me> that looks awesome looking now thanks Tuplanolla 
11:32:08 <Tuplanolla> Brick can handle that automatically, harwiltz.
11:32:09 <geekosaur> crucify_me, you're seeing eta reduction. when you have foo x = (some expression) x, you can remove the x from both sides
11:32:24 <harwiltz> Man... i really don't wanna start rewriting my UI now though... but its looking like I should at this point
11:32:45 <Tuplanolla> I'm not saying you should, but you probably should, harwiltz.
11:33:39 <hpc> if all the software i have used is any indicator, 90% of programming is total UI rewrites
11:33:45 <crucify_me> geekosaur, eta reduction .. so the (.) is enough to express the entire idea. one thing is that there are no spaces in that expression....
11:33:47 <geekosaur> with operators the first parameter is on the left instead of the right, but it still works (that is, (x . y) is the same as ((.) x y)) so you can reduce both x and y away from co x y = (.) x y
11:33:51 <dmj`> hpc: lol
11:34:19 <harwiltz> This is so different from hscurses though... switching would mean I have to completely learn a new api
11:34:24 <crucify_me> excellent geekosaur  I can follow
11:35:20 <[exa]> +1 hpc
11:35:30 <crucify_me> so you're left with the infix operator version 
11:35:43 <crucify_me> or prefix notation I mean
11:36:21 <Tuplanolla> I need to abbreviate `assign` into three characters. Is `ass` my only option?
11:36:38 <hpc> have you tried not needing to abbreviate it?
11:36:56 <geekosaur> asg
11:36:59 <hpc> (and yes that's a serious question)
11:37:08 <Tuplanolla> Yes, hpc. It didn't turn out good.
11:37:12 <hpc> :/
11:37:44 <hpc> asn?
11:37:51 <geekosaur> set?
11:38:02 <geekosaur> or put
11:38:23 <harwiltz> Why not 'asn'? It kinda reads like assign
11:38:37 <[exa]> harwiltz: if you want to save yourself from the rewrite, the second good opensource practice is to look at Brick and assimilate its solution of the resizes
11:38:40 <harwiltz> But that being said, I like geekosaur's 'set' suggestion
11:39:02 <harwiltz> [exa]: Wow. That's a pretty cool idea actually, I might just have to try that.
11:39:37 <[exa]> borg-committee-approved
11:39:54 <geekosaur> [exa], that might be harder than you think since brick isn't wrapping a C library
11:40:00 <Tuplanolla> The concept I have in mind is analogous to the C operator `++`, which would translate to `succAss` for enumerations...
11:40:10 <geekosaur> and C + signal handling is a nightmare even without Haskell on top
11:40:17 <Tuplanolla> Not good.
11:40:19 <[exa]> Tuplanolla: if you aren't limited to 3 chars, I'd go with asgn
11:40:35 <harwiltz> Tuplanolla: Why are you limited to 3 chars?
11:41:35 * hackagebot svg-builder-fork 0.1.0.3 – DSL for building SVG. – https://hackage.haskell.org/package/svg-builder-fork
11:41:37 <[exa]> Tuplanolla: or in this case, maybe `succTo` ?
11:41:50 <edwardk> @tell quchen it is half of an iteratee. there is no 'consumption' notion.
11:41:51 <lambdabot> Consider it noted.
11:42:08 <Tuplanolla> I don't have a good explanation, harwiltz.
11:42:20 <harwiltz> Hahaha
11:42:33 <edwardk> @tell quchen that is why it has the shorter name. =) It started out as "Iter", then I started trying to figure out what it was... and eventually I was left calling it It.
11:42:33 <lambdabot> Consider it noted.
11:43:38 <[exa]> Nothing | Just It
11:44:01 <geekosaur> sounds more like bra|ket notation
11:44:27 <crucify_me> one thing, with this version, how do you read that in English, the part with the lambda : \x -> f (g x)    ?
11:44:34 <crucify_me> https://ptpb.pw/RevE
11:44:36 <ab9rf> C signals are evil
11:45:26 <geekosaur> mostly I don't try to read stuff like that in English as writing it down is clearer and less ambiguous
11:45:51 <Tuplanolla> It's just that I find `conditionallyPeriodicLatticeIndexVectorMooreNeighborhoodSuccessorAssign` a bit excessive, harwiltz.
11:47:22 <harwiltz> Tuplanolla: Well, I'd have to agree with that
11:48:05 <crucify_me> ok thanks, in the type declaration (b -> c) -> (a -> b) part, you could think of it like this, right? : (\b -> c) -> (\a -> b)   geekosaur 
11:49:23 <geekosaur> not exactly since that is type level
11:49:40 <geekosaur> the "lambda" notion is in the function arrow already
11:50:27 <crucify_me> right , so I have to learn to not read stuff out loud .. thanks!
11:51:46 <geekosaur> well, the more technical stuff gets, the less readable in a natural language it is, unless you want to spend most of your words saying "bracket" "arrow" "paren" (saying "open parenthesis" gets old _fast_) etc.
11:51:55 <geekosaur> "a picture is worth a thousand words" more or less
11:53:55 <Profpatsch> alexbiehl: I got the local hackage running within nix-shell again, but there is still the problem that some links are pointing to file:///nix/store/… and some to localhost:8000/file/nix/store
11:54:19 <Profpatsch> So links to file:/// are not clickable b/c of cross-site origin policy.
11:55:05 <crucify_me> word, thanks. ' f .g = \x -> f(g x) ' is redundant, the interpreter doesn't need  \x ->   part   geekosaur -- that is interesting that it works with it.
11:55:29 <crucify_me> 'f . g' *
11:56:05 <Profpatsch> alexbiehl: It would be awesome if you could try to spot an invocation error in the shell script lines below here https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/hoogle.nix#L91
11:56:44 <Profpatsch> Maybe rather in these lines: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/hoogle.nix#L91-L108
11:57:13 <crucify_me> however, in the type declaration, you cannot use alternate notations as in the function expressions. is that correct?
11:58:13 <geekosaur> type definitions can be eta reduced as well, at least in some circumstances. unlike value level, though, there is no partial application at type level; all types must resolve to fully applied
11:58:23 <[exa]> crucify_me: you can have some type synonyms that get auto-expanded for you, but basically not.
11:59:55 <[exa]> crucify_me: btw about reading out loud, human languages are not very good at reading strictly context-free grammars; most human languages have context sensitive modes to replace parentheses
12:00:03 <geekosaur> (but! some types are provided by other constructs. so in an instance definition for Functor, you often do not specify the type because the class adds it automatically. likewise type aliases can be partial as long as they are used in contexts that provide the missing type parameters)
12:00:07 <Profpatsch> alexbiehl: $out/share/doc/hoogle looks like this: http://lpaste.net/357465
12:01:15 <Profpatsch> It seems like the symlinks are not recognized by haddock and since the resolved symlinks start from a different folder they are put in as file:// links.
12:01:30 <crucify_me> geekosaur, [exa] holy smokes thanks ! got my work cut out for me. 
12:02:05 <geekosaur> yes, things can get fairly complex in a hurry
12:02:18 <geekosaur> but I don't think anyone is forcing you to look at the complex stuff right now
12:10:28 <crucify_me> geekosaur, yeah, I like to know what's going on but it slows me down considerably. [exa]   thank you both!
12:12:53 <Mudada> Hello everyone, im new to haskell and i would like to steal some of your precious time to help me with some Parsec probleme. I want to write a csv parser and i encounter a problem with the "empty" value (for exemple "something, ,something") there is the code https://gist.github.com/Mudada/db528735bf124d3f970b18cb8988fc5e i think "tel" is eating some of my data by matching the space char, so i tryed to use "try" but it change nothing
12:13:59 <koala_man> Mudada: your parseSF uses many1, so it requires at least 1 character. use many instead to allow 0 characters
12:14:40 <glguy> Mudada: it will help to only consume whitespace at the *end* of a parser, and only then when that parser has succeeded
12:14:47 <koala_man> oh nm, I didn't read further down
12:17:04 <Mudada> Ok but if i change many1 to many my "sf" now totally match in place of my empty
12:17:49 <koala_man> blerk. I had a few dozen Writer monad functions that passed a parameter. I replaced that with a ReaderT and it's 10% slower. I replaced both with a RWS and it's 20% slower. 
12:18:12 <geekosaur> tempted to say you need to make sure they get inlined
12:18:24 <[exa]> Mudada: I guess that this is the problem ---  parseSF = many1 $ noneOf ",\n"  -- it can easily eat the ' ' space
12:18:25 <koala_man> how do I do that?
12:19:25 * hackagebot word-wrap 0.3.3 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
12:19:42 <Mudada> [exa]: yea i know but i dont see any other way to allow string with space 
12:20:16 <geekosaur> koala_man, inspecting the generated Core, beyond that it's all too often mostly trial and error. I'd have expected some level of inlining to already exist but you may be defeating it somehow (e.g. recursion)
12:20:19 <glguy> once the parsers are updated to consume trailing spaces there won't be any leading ones
12:20:23 <[exa]> you want a string without whitespace that has a non-space character on both ends, right? I guess that ".. ,          , ..." also counts as empty
12:21:31 <[exa]> Mudada: so I'd continue just as with regex: ws, eat stuff except for ",\n", check if there was something reasonable eaten, strip whitespace from the end of the result
12:22:00 <[exa]> (and fail if the check fails, to force parsing as the other alternative)
12:22:20 <Mudada> I want to consider whitespace-only fields as "empty"
12:25:07 <Mudada> [exa]: How can i add such a condition witch parsec i didn't see that in the doc 
12:26:05 <[exa]> Mudada: what I wanted to say is that the distinction between '    ' and '   a  ' requires some more logic than what can be captured by noneOf
12:27:05 <[exa]> Mudada: what about ws, followed by one char except " \n,", followed by noneOf ",\n"?
12:27:39 <Mudada> hum
12:27:40 <[exa]> Mudada: btw this is a common problem with all grammar-like rules. Expressing negative conditions in grammars is simply weird.
12:27:52 <Mudada> let me try
12:28:52 * hackagebot servant-github-webhook 0.3.1.0 – Servant combinators to facilitate writing GitHub webhooks. – https://hackage.haskell.org/package/servant-github-webhook
12:28:57 <[exa]> Semantically, you want to say "not everything is space (except stuff like , and newlines)", but you have to say "there exists something that is not space"
12:34:14 <Mudada> yea thats really weird to describe such a behavior
12:35:07 <Mudada> it's *
12:36:45 <geekosaur> well, it's a logic way to describe it
12:37:02 <[exa]> Mudada: (btw if you want to see the whole related problem, the exercise is to try writing a regex for a sentence that doesn't contain five times 'a' in a row)
12:38:09 <tsani_> How do packages get on stackage?
12:38:28 <ongy> you upload them
12:38:42 <ongy> ah sorry, I was thinking of hackage -.- learn to read me
12:39:20 <tsani> yeah, hackage I can deal with, but I'm moving more to using stack at this point
12:43:27 <cocreature> you can use packages that are not in stackage just fine with stack
12:44:09 <cocreature> tsani: if you do want to add your package to stackage take a look at https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
12:47:05 * hackagebot transient 0.5.9 – composing programs with multithreading, events and distributed computing – https://hackage.haskell.org/package/transient
12:55:19 <Mudada> Hum look like it did the trick but now he told me that he want a "," as first char and i dunno why Oo (code updated here https://gist.github.com/Mudada/db528735bf124d3f970b18cb8988fc5e)
12:55:40 <monochrom> Who is "he"?
12:55:53 <Mudada> the compiler sorry
12:56:55 <Mudada> it's weird because if i use any of my parser alone (sf, tel or empty outside of parseLine) it work perfectly
12:59:58 <Guest46531> Hi, anyone fancies either criticise my couple of lines of code or steer me to an idiomatic solution of the next stage (print only new entries in subsequent iterations) https://pastebin.com/E1MAtd84
13:07:34 <glguy> Mudada: YOu still have parsers eating leading whitespace
13:09:11 <glguy> Mudada: Parsers shouldn't consume any input unless their going to succeed. If you can't factor the parser for that to be the case then you need to use try to allow parsing to backtrack over the allowed failures
13:09:21 <glguy> their/they're
13:10:35 <Mudada> oh shit sorry i didn't update the part of my code
13:13:23 <Mudada> there it is https://gist.github.com/Mudada/db528735bf124d3f970b18cb8988fc5e , really sorry for this mistake
13:14:01 <glguy> Mudada: parseTel and parseSF both consume leading whitespace still
13:14:18 <Mudada> yea but i "try" them
13:14:26 <glguy> where?
13:14:41 <Mudada> parseCell :: Parser Cell parseCell = try $ choice [tel, sf, empty]
13:14:43 <glguy> The try outside of the choice isn't helping
13:14:44 <Mudada> oups
13:14:49 <Mudada> really ?
13:15:56 <Mudada> OH
13:16:03 <Mudada> im fuckin' retarded
13:16:48 <glguy> Once you factor the leading whitespace out of your parsers you won't need the try
13:18:11 <Mudada> yea i just realise that
13:18:33 <Mudada> choice [try tel, try sf, try empty]
13:18:36 <Mudada> did the trick
13:18:40 <Mudada> thanks a lot mate
13:19:23 <glguy> the last try isn't doing anything
13:19:41 <Mudada> yes that's right
13:19:51 <Mudada> sorry im a bit tired aha
13:26:19 <greeny> short question: is it worth learning how to use lenses?
13:26:55 <cocreature> greeny: short answer: yes :)
13:28:01 <Tuplanolla> It's one of the best parts of Haskell, greeny.
13:28:05 <glguy> that was easy
13:28:17 <greeny> so i'm gonna watch this talk about lenses which is 2 hours long
13:28:31 <Mudada> gimme the link :D
13:28:46 <Mudada> look like something fun
13:28:56 <greeny> Mudada: https://www.youtube.com/watch?v=cefnmjtAolY&index=11&t=457s&list=WL
13:29:05 <Tuplanolla> The one with Kmett is rather incomprehensible to beginners, greeny.
13:29:06 <cocreature> assuming that’s the talk I’m thinking about, I would question whether that’s a good introduction
13:29:19 <Mudada> thx
13:29:32 <Tuplanolla> The one with SPJ is quite a bit simpler, greeny.
13:30:50 <greeny> Tuplanolla: can you give me a link?
13:31:15 <c_wraith> greeny: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation  (free account required for some reason, but the talk is worth it)
13:32:26 <greeny> c_wraith: thx. i'll watch it :)
13:32:28 <Tuplanolla> I know I had it somewhere...
13:34:33 <Tuplanolla> Oh, c_wraith found it.
13:34:51 <c_wraith> Tuplanolla: I've got your back. :)
13:37:10 <Guest46531> someone to help me? Or didn`t my code inspire any interest? :) Should I post the link again? (would it be intrusive/spamlike to just do that without asking?)
13:37:27 <monochrom> It is OK to re-ask.
13:38:22 <Guest46531> here it is https://pastebin.com/E1MAtd84
13:39:24 <Guest46531> I`d like to ask what would be an / the most idiomatic way to retain the titles retrieved so far and only print out the new ones
13:40:06 <Guest46531> also any suggestions regarding existing code are welcome
13:41:30 <Guest46531> regarding the first question, I think I could pull it of, I just don`t think it would be a particularly nice / idiomatic solution
13:48:39 <dolio> Oh man, it's Ed with long hair.
13:51:09 <monochrom> Who?
13:51:42 <dolio> Ed Kmett.
13:52:20 <hpc> in honor of that being on topic...
13:52:25 <hpc> @remember dolio Oh man, it's Ed with long hair.
13:52:25 <lambdabot> It is forever etched in my memory.
13:52:26 <monochrom> Ah. I have only seen a very-short-hair version in real life when he visited Toronto.
13:53:26 * hackagebot SSTG 0.1.1.5 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
13:56:15 <minn> Is there a nice way to load load R data files into Haskell (e.g., a dataframe or list of list of matrices)? I don't need R interoperability.
13:56:46 <hpc> @hoogle r
13:56:46 <lambdabot> Crypto.KDF.Scrypt r :: Parameters -> Int
13:56:46 <lambdabot> Formatting.ShortFormatters r :: Buildable a => Int -> Char -> Format r (a -> r)
13:56:46 <lambdabot> Text.RawString.QQ r :: QuasiQuoter
13:56:56 <hpc> if that had worked...
13:57:12 <Zowlyfon> I know there is an inline R library for Haskell if thats what your looking for.
13:57:35 <Zowlyfon> https://hackage.haskell.org/package/inline-r
13:59:37 <minn> hpc: haha, if only
14:01:35 <minn> Zowlyfon: This is going to sound pretty terrible, but I've been looking over the HaskellR documentation (tweag.github.io/HaskellR) for a while and can't figure out how I'm supposed to import a .Rda file :/
14:04:20 <minn> or maybe i just didn't understand how quasiquotes worked, hmm
14:05:01 <hexagoxel> Guest46531: even if "most idiomatic" wasn't subjective, people might be hesitant to answer when we have to guess what you want to achieve/what solution you have in mind. A good general approach to this kind of problem might just be "recursion" - you pass in the last items to the next iteration.
14:05:41 <Zowlyfon> minn: I've never used it, just know people who have
14:07:40 <minn> The examples actually look really slick and a million times more friendly than rpy2, which I'm familiar with.
14:14:16 <Guest46531> hexagoxel: thanks for your reply. I was thinking about a [String] -> [String] -> [string] function that would take the retrieved and the seen topics and return the new ones
14:14:54 <Guest46531> the problem is: if I want to do it that way, how do I hold onto the seen ones?
14:14:57 <geekosaur> actually, if you are just collecting unique topics, maybe you want a Set
14:15:59 <Guest46531> geekosaur: hmm, that sounds like a good idea, I somehow default to lists in haskell it seems
14:16:16 <Zowlyfon> hello matrix
14:16:50 <hexagoxel> Guest46531: in each iteration, don't the new ones become the old/seen ones, the old ones are discarded, and you retrieve the new ones?
14:17:13 <Guest46531> altohugh slightly different than what I said I want my program to do, but this is not an assignment, just finding new things to try
14:17:37 <hexagoxel> with your function to compare old/new in between? (that function makes perfect sense, btw).
14:18:38 <Guest46531> hexagoxel: yes ,I know I diverged here from what I said, I`ll explore that path with sets later. 
14:19:00 <Guest46531> ok so if I go down the route of discarding the old ones
14:20:51 <hexagoxel> go previous = do { new <- ..; let difference = _ previous new; (output difference; threadDelay; etc.); go new }
14:20:55 <Guest46531> mapM_ putStrLn $ filterseen listofSeen $ getTitles response
14:21:22 <Guest46531> where would listOfseen come from? how would I keep "updating" it?
14:21:43 <Guest46531> or am I regressing to thinking in state here?
14:23:26 <mniip> what's the fastest option for ser/des-ing data structures?
14:23:40 <mniip> I'm looking at Data.Binary which must be a huge improvement over Show/Read
14:26:17 <dmj`> mniip: cereal and store are others
14:26:21 <dmj`> @package store
14:26:21 <lambdabot> http://hackage.haskell.org/package/store
14:26:41 <mniip> more specifically, I need to write/read from Text (!) asap
14:27:34 <mniip> thanks will give it a shot
14:30:40 <EvanR> Guest46531: it comes from wherever you want?
14:31:05 * hackagebot preview 0.1.0.4, strict-data 0.2.0.2, util-plus 0.1.0.0
14:31:05 * hackagebot  → https://hackage.haskell.org/packages/recent
14:31:11 <EvanR> if you want to run that over and over, and use a different listOfSeen each time, then you could use recursion or keep it in a mutable variable
14:31:12 <hexagoxel> Guest46531: the "updating" that happens in `go` above happens via nothing other than recursion - the last thing the function does is calling itself with an updated "state".
14:31:36 <gremdrus> how would I print "1 2 3" instead of "print r" which gives [1,2,3]
14:32:13 <lyxia> :t intercalate
14:32:14 <lambdabot> [a] -> [[a]] -> [a]
14:32:16 <hexagoxel> :t unwords . fmap show
14:32:17 <lambdabot> Show a => [a] -> String
14:32:24 <EvanR> > unwords (map show [1,2,3])
14:32:27 <lambdabot>  "1 2 3"
14:32:52 <emmanuel_erc> is there a way to see the instances ghc derives when you use the derivefunctor pragma? 
14:34:34 <geekosaur> -ddump-deriv I think?
14:34:47 <geekosaur> may also want -ddump-to-file
14:35:11 <emmanuel_erc> oh thanks i'll try that
14:37:03 <mac10688> Does anyone know of a snap plugin that allows rest methods to be discoverable at run time instead of having to manually add each route at runtime?
14:37:12 <mac10688> I'm trying to figure out if web routes does this
14:37:21 * hackagebot text-plus 0.1.0.1 – Utils for text – https://hackage.haskell.org/package/text-plus
14:37:29 <hexagoxel> doesn't ghc produce just core and not actual source in other automatic-deriving cases (Show, Read, ..) ?
14:37:32 <emmanuel_erc> works thanks
14:37:54 <hexagoxel> ah, nevermind :)
14:39:09 <gremdrus> okay it seems like "unwords $ map show [1,2,3]" does what I want, but intero says "Couldn't match type ‘[]’ with ‘IO’"
14:39:29 <geekosaur> sounds like you are doing that in the wrong context
14:39:40 <gremdrus> here is my code: https://gist.github.com/gremdrus/b4dac61257ab2a930305fb016fe70f2f
14:39:51 <EvanR> unwords (map show foo) gives you a string
14:39:56 <EvanR> then you can print it with putStrLn
14:40:30 <EvanR> print is just putStrLn . show, which doesnt do what you want, so thats how you modify it
14:40:32 <gremdrus> EvanR: thank you that was it
14:43:31 <edwardk> monochrom: its slowly growing back out, but it mostly looks like i'm a wildman right now =)
14:44:03 <Guest46531> ok I think i`ll go and write some code, thanks for the answers
14:52:17 <nykros> @help
14:52:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:52:56 <nykros> @list
14:52:56 <lambdabot> What module?  Try @listmodules for some ideas.
14:53:10 <nykros> @help list
14:53:10 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
14:53:30 <nykros> > 23+2
14:53:32 <lambdabot>  25
14:54:02 <nykros> > map (+1) [1..10]
14:54:04 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
14:54:29 <nykros> :t map
14:54:31 <lambdabot> (a -> b) -> [a] -> [b]
14:54:45 <nykros> :t fmap
14:54:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:56:04 * hackagebot fltkhs 0.5.3.7 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
15:02:42 <gremdrus> how would I access an element in a 2d array such as [[1,2,3][4,5,6][7,8,9]]?
15:03:01 <Guest76143> I have a question about the Streaming library. in Streaming.prelude there is a breaks function that returns: Stream (Stream (Of a) m) m r
15:03:34 <Guest76143> is there any way for me to map through those inner Stream (Of a) m  values?
15:04:39 <hpc> gremdrus: the same way you would operate on any other list, just more of it
15:04:56 <Guest76143> eg [[1,2,3],[4,5,6],[7,8,9]] !! 2 !! 1  
15:04:57 <hpc> > [[1, 2, 3], [4, 5, 6], [7, 8, 9]] !! 2 !! 1
15:04:59 <lambdabot>  8
15:05:01 <hpc> haha
15:05:12 <gremdrus> but I mean I'm used to python where I can do a[2][2] or something in python
15:05:33 <Guest76143> eg [[1,2,3],[4,5,6],[7,8,9]] !! 2 !! 2 
15:06:09 <hpc> the same advice applies as usual, where you want to avoid using (!!) if something more suitable like a fold or map would make more sense
15:06:47 <hpc> the [] type isn't an array type, it's a singly linked list
15:07:20 <hpc> it has all the disadvantages you would normally think of, but an advantage combined with non-strict semantics in that you can operate on them as if they were streams
15:07:41 <hpc> > takeWhile (< 100) (map (\x -> x*x) [1..])
15:07:43 <lambdabot>  [1,4,9,16,25,36,49,64,81]
15:08:25 <hpc> if you're doing something linked lists would not be suitable for (for instance, matrix operations), i suggest picking a different base data type
15:08:34 <hpc> http://hoogle.haskell.org/?hoogle=array
15:08:53 <hpc> and especially if you're doing matrix operations, look into an existing matrix library
15:10:48 <sqooq> anyone here use ghc-mod?
15:11:07 <sqooq> It only seems to work in built stack projects, not individual files, wondering if that's correct
15:12:25 <geekosaur> ghc-mod has to be built for each ghc in use, if you are not working in a stack project then it may well be using a different ghc
15:12:47 <geekosaur> (stack will install an appropriate ghc for each project based on the resolver the project specifies)
15:12:57 <gremdrus> how do I return a value, this doesn't seem to work: https://gist.github.com/gremdrus/a7b9c347e174404d2ac8ca06586bd28d
15:13:41 <hpc> use t instead of [[t]]
15:14:02 <hpc> as written, you've given it a pattern saying to match a list of one element, and that element is another list of one element
15:14:09 <hpc> and then name that inner element t
15:18:08 <gremdrus> so how would I define the function to work on a 2d array of arbitrary length?
15:18:23 <hpc> use t instead of [[t]]
15:18:30 <gremdrus> hpc: ah, okay
15:19:17 <gremdrus> hpc: but how do I return a value in haskell? ending the function with a + b doesn't do anything, and I know 'return' is for IO functions right?
15:19:29 <nykros> :t IO
15:19:31 <lambdabot> error:
15:19:31 <lambdabot>     • Data constructor not in scope: IO
15:19:31 <lambdabot>     • Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
15:19:48 <hpc> oh, you need "in" as well
15:20:00 <hpc> the syntax is let <patterns> in <expression>
15:20:11 <hpc> so let a = blahblah; b = blahblah in a + b
15:20:21 <hpc> (replace ';' with a newline and correct indentation)
15:21:08 <geekosaur> the "let" without "in" is specific to "do" syntax, in a general expression, you need the "in" form
15:21:17 <gremdrus> hpc: okay
15:21:25 <gremdrus> geekosaur: thanks for clarifying, I was about to ask that
15:23:04 <sqooq> geekosaur: so is there a way to globalize it so that ghc-mod can work on individual files
15:23:54 <geekosaur> sqooq, no
15:24:08 <sqooq> ok
15:24:45 <geekosaur> ghc has very tight version constraints, a version of ghc-mod built for one ghc will generally conflict with a different version
15:25:27 <sqooq> ok fine
15:25:57 <sqooq> so when I make a project do I put my .hs files in \src?
15:32:54 <simeon> hi. while installing haskell ide (https://github.com/haskell/haskell-ide-engine#installation) I ran into "missing c libraries icuuc icuin icudt" after some searching I tried the first answer from https://stackoverflow.com/questions/16127710/how-do-i-get-text-icu-working-on-windows which seemed to solve the problem. When it finished installing however, running "hie" bring "this program can't start because [some dll] is missing" error
15:39:43 <hexagoxel> simeon: you can try asking directly in #haskell-ide-engine, too.
15:49:40 <QF-MichaelK> Anyone suggestions on how to more generally arrive at functional roots? Ex: For some function f, find f^(1/n), f = 4x, f^1/2 = 2x.
15:51:45 <EvanR> sqrt(f) = g s.t. g . g = f
16:02:29 <QF-MichaelK> EvanR: Thank you, having some trouble with syntax there: let sqrt(f) = g s.t. g . g = f; let h = sqrt(4x); h(2) //4
16:03:13 <QF-MichaelK> I didn't know s.t. was a thing, but failed to find documentation on it.
16:04:48 <gremdrus> okay I am having a bit of trouble... apparently I am not using let correctly? https://gist.github.com/gremdrus/3e90067b8fd81603cacf0155391fa5cd
16:05:30 <crucify_me> sorry back again with haskellbook questions. why do I ignore the first argument here... ie why is it written this way I thought this one had to do with identity : https://ptpb.pw/u-Pa
16:05:59 <crucify_me> so the notes say to ignore the f ?
16:07:33 <crucify_me> i.e. what is the pedagogical point here?
16:08:00 <nykros> what haskellbook?
16:08:22 <crucify_me> from first principles ie haskellbook  nykros thanks
16:08:46 <nykros> the a function looks like const, but specialiced in that the first argument is a funcion
16:09:14 <crucify_me> sorry please explain
16:10:16 <jmi2k_> Hello, I'm learning about PHOAS but I'm stuck because I don't quite understand it yet. Can anyone recommend me anything which covers the topic in depth?
16:10:22 <c_wraith> nykros: flip const
16:10:45 <EvanR> QF-MichaelK: that wasnt haskell code
16:11:39 <c_wraith> crucify_me: if you ignore the issue of why someone would ever write that function, does how the code works make sense?
16:11:40 <crucify_me> the (a -> c) part, do you call that transformative or similar?
16:12:07 <QF-MichaelK> EvanR: Ah, wishful thinking, thanks for clarifying.  But, yes, that's the sort of operation that I want to do.  Either by hand algebraically or via some haskell magic like what you wrote.
16:12:19 <gremdrus> is there an example of a let ... in if ... then in haskell?
16:12:24 <gremdrus> and if inside a let is what I mean
16:12:31 <gremdrus> an if inside a let is what I mean*
16:12:42 <EvanR> QF-MichaelK: i didnt understand what you wanted, you want to *compute* to square root of an arbitrary function?
16:12:47 <EvanR> compute the*
16:13:08 <EvanR> or just numeric functions
16:13:09 <c_wraith> gremdrus: there's nothing interesting about it..  let x = 5 in if x < 6 then "less" else "greater"
16:13:12 <crucify_me> c_wraith, um .. do you mean the signature part ?
16:13:39 <c_wraith> crucify_me: the whole thing.  If you don't worry about why you would ever do it, does what it does make sense?
16:13:44 <QF-MichaelK> EvanR: Basically, but it's the functional root.  So, f(x) = x^2; g . g = f; g = x^(2^(1/2))
16:14:06 <crucify_me> not really sorry its confusing
16:14:18 <QF-MichaelK> If I could get the algebraic expression that'd be nice, but a numeric solution would be cool too.
16:14:22 <EvanR> i can only assume you mean arbitrary functions now
16:14:28 <QF-MichaelK> Yup.
16:14:40 <EvanR> i suspect its uncomputable
16:14:49 <QF-MichaelK> Quite possible.
16:14:58 <EvanR> or if you had such an operation, you could solve every math problem, somehow
16:15:02 <crucify_me> it looks like all it does is apply identity
16:15:07 <c_wraith> crucify_me: ok, so if you ignore the type sigature, does the definition make sense?
16:16:04 <EvanR> you can probably figure something out with a limited vocabulary of how to define functions
16:16:36 <EvanR> like, if all you could do is multiply arguments together, you could exploit the rule sqrt(xy) = sqrt(x)*sqrt(y)
16:16:53 <crucify_me> a takes the identity function but does nothing further? c_wraith 
16:17:12 <nykros> crucify_me, can you tell me in what page does that function appears?
16:17:38 <c_wraith> crucify_me: if you're looking only at the body, where do you see that it takes a function at all?
16:18:00 <QF-MichaelK> EvanR: That'd be handy if I could find some properties that were valid.  I suspect this might end up needing to be exploratory, starting with g and see where it goes...
16:18:07 <crucify_me> it's a solution that is identical in two github solution repos nykros 
16:19:26 <crucify_me> you mean body, as in right of the = ?
16:20:04 <c_wraith> crucify_me: That is what body means, but I misspoke slightly.  I meant to say just the definition, not the type signature.
16:20:44 <EvanR> e.g. f x = 4*x. sqrt(4*x) = sqrt(4)*sqrt(x). sqrt(f) = (2*) . sqrt
16:22:03 <c_wraith> crucify_me: that is, say I just had the line "foo q r = r".  Do you understand the function foo as defined there?
16:22:14 <EvanR> > sqrt (sqrt 4 * 2) * 2
16:22:16 <lambdabot>  4.0
16:22:25 <EvanR> hmm nvm
16:22:39 <QF-MichaelK> EvanR: Yeah, I don't think they can be decoupled so easily.
16:23:01 <QF-MichaelK> Here's the wiki page on functional square roots: https://en.wikipedia.org/wiki/Functional_square_root
16:23:53 <crucify_me> foo takes two arguments , q and r   .. c_wraith 
16:23:54 <QF-MichaelK> Hm, the 4th example seems not far off.
16:24:12 <c_wraith> crucify_me: and what does it return?
16:24:19 <QF-MichaelK> (3rd*)
16:24:59 <zblkf> hi there, I'm having issues understanding how to use monad-logger, I don't think I understand what I'm supposed to do to make this snippet work http://lpaste.net/357472, do I have to make a new instance of MonadLogger or something like that ?
16:25:00 <crucify_me> it returns the second argument
16:25:07 <minn> Is it possible to derive lenses on records that depend on Alex types in Alex source files? I haven't been particularly successful...
16:25:41 <c_wraith> crucify_me: That's all correct.  So let's move to types.  What is the type of foo?
16:26:15 <mniip> how does HasCallStack debugging work?
16:26:35 <mniip> is a HasCallStack annotation similar to SCC?
16:27:53 <crucify_me> foo is just lambda , I believe, here
16:27:56 <crucify_me> c_wraith, 
16:28:05 <c_wraith> crucify_me: lambda isn't a type...
16:28:46 <QF-MichaelK> EvanR: https://mathoverflow.net/questions/17614/solving-ffx-gx seems to say no, not possible
16:28:55 <crucify_me> foo is the type in the paste I guess
16:29:15 <crucify_me> foo :: (a -> c) -> a -> a
16:29:31 <c_wraith> crucify_me: without adding a type signature, it actually has a more general type than that.
16:30:07 <crucify_me> one moment please c_wraith 
16:30:07 <c_wraith> crucify_me: You can always give a value a more specific type than would be inferred, which is what your example does
16:30:24 <crucify_me> ok that I understand
16:30:41 <crucify_me> so ok ..
16:31:10 <crucify_me> is it ...
16:31:31 <crucify_me> foo :: a -> b -> b   
16:31:37 <c_wraith> crucify_me: yes, exactly
16:31:58 <crucify_me> hooray one sec
16:33:59 <crucify_me> so the (a -> c) part, the c is arbitrary, (a -> c) just does something not related to the output. c_wraith   
16:34:47 <c_wraith> crucify_me: well, if you look at the definition, you can see that the argument f, which has type (a -> c), is totally unused.
16:35:21 <crucify_me> so left of the = sign, there is no composition. c_wraith 
16:35:35 <c_wraith> crucify_me: correct.  All it does is return the second argument.
16:36:21 <crucify_me> compose is only for the expression side. no expression can be on the left side
16:37:42 <c_wraith> crucify_me: I'm not completely certain what you mean by compose.  Do you mean applying functions?
16:38:34 <crucify_me> so there is no reason to write (a -> c), which would transform something, in a function there merely returns the second argument. ?
16:38:46 <crucify_me> that*
16:38:53 <crucify_me> in a function that*
16:39:35 <c_wraith> crucify_me: there is sometimes a reason to do that, when you care about requiring that types line up a certain way
16:39:55 <c_wraith> crucify_me: it doesn't do anything at the value level, but it *does* do something at the type level
16:40:19 <crucify_me> it does something at the type level? that I don't see
16:40:41 <Welkin> crucify_me: why do you want to be crucified?
16:40:58 <crucify_me> its not like a place marker meant to throw you off in the text question ? 
16:41:08 <c_wraith> crucify_me: the `a' type variable in (a -> c) is the same type variable in the rest of the signature
16:41:18 <crucify_me> Welkin, as long as it doesn't offend anyone
16:41:38 <crucify_me> c_wraith, damn, sorry I'm a bit confused by that
16:42:06 <crucify_me> my sister used to say that to me when I was growing up Welkin 
16:42:32 <c_wraith> @let ex :: (a -> c) -> a -> a ; ex f x = x -- crucify_me, I'm renaming it because the name "a" collides with stuff already in lambdabot
16:42:34 <lambdabot>  Defined.
16:42:52 <c_wraith> > ex (+1) "hi"
16:42:53 <crucify_me> c_wraith, yes that makes it hard to read
16:42:54 <lambdabot>  error:
16:42:54 <lambdabot>      • No instance for (Num [Char]) arising from an operator section
16:42:54 <lambdabot>      • In the first argument of ‘ex’, namely ‘(+ 1)’
16:43:06 <gremdrus> how do I map this function over a 2d array? https://gist.github.com/gremdrus/03a3567ac171a16b5cf47c34d890690c
16:43:14 <c_wraith> crucify_me: see how that got a type error?
16:43:46 <c_wraith> crucify_me: that's because the type of the first argument does matter, even if its value doesn't
16:47:03 <Welkin> :t bimap
16:47:04 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
16:47:27 <crucify_me> ok so (+1) , that represents the (a -> c) part? 
16:47:55 <crucify_me> the interpreter thinks a is a string
16:48:38 <c_wraith> crucify_me: it's just the first argument.  Its type is unified with (a -> c) during type checking
16:48:39 <Welkin> is there an equivalent for bimap for functions like how fmap is compose for functions?
16:48:53 <EvanR> a is not a string
16:48:57 <EvanR> a is string
16:49:00 <EvanR> a = String
16:49:20 <EvanR> subtle grammatic difference huge other difference
16:49:20 <c_wraith> Welkin: functions aren't an instance of Bifunctor..
16:49:24 <minn> is there a lightweight alternative to lens that will solve this problem: i have records in my alex/happy files that depend on alex/happy types, and makelenses isn't playing nicely with compilation of the lexer/parser sources (e.g., attempting to derive lenses for the alex user state leads to complaints about missing alex types). i know one solution is to make the types i'm trying to derive lenses for not depend on alex/happy types, 
16:49:24 <minn> but is there a better solution?
16:49:25 <crucify_me> right EvanR got that
16:49:55 <crucify_me> right , a is Stringhood
16:50:00 <c_wraith> minn: write the lenses by hand
16:50:22 <EvanR> like the value of a is String
16:50:39 <EvanR> compare x = 3, x is not "a 3"
16:51:03 <EvanR> man how does this work in russian :)
16:51:05 <crucify_me> ok right , f takes an a type as its argument c_wraith 
16:51:17 <minn> c_wraith: ooohhhh, right 
16:51:35 <crucify_me> so it must be a in (a -> c) correct?
16:51:52 <nykros> What are lenses for?
16:52:12 <Welkin> nykros: magnification using light
16:52:32 <nykros> What are lenses for, in Haskell?
16:52:39 <c_wraith> crucify_me: I think you've got it now, if I understood you correctly.  the function requires the types of its arguments to be related, even though it doesn't use one of those arguments
16:52:47 <Welkin> like a microscope lens, it lets you see deep into a structure (and change it) easily
16:52:58 <glguy> Lenses are first-class data access ಠ_ರೃ 
16:53:19 <Welkin> so you can do person.family.sister.name = "r2d2"
16:53:29 <Welkin> for some person record
16:53:31 <hpc> more like you can do
16:53:36 <hpc> foo = person.family.sister.name
16:53:41 <hpc> bar = set foo "r2d2"
16:53:52 <c_wraith> nykros: the short pitch is something like "lenses are a uniform interface for data manipulation that provide a broad set of pre-defined utilities"
16:53:53 <hpc> (and do much more with foo besides)
16:54:39 <nykros> oic.
16:54:45 <crucify_me> c_wraith, thanks a lot, so we could have had anything else in that first argument like (a -> d)
16:55:12 <c_wraith> crucify_me: sure.  the important part is that `a' is the same type variable everywhere, and the other type variable is different.
16:55:50 <zblkf> how can I make MonadLogger work in a simple IO function like this http://lpaste.net/357472 ?
16:56:27 <braulio> hi
16:56:44 <codebje> (MonadLogger m, MonadIO m) => ...
16:57:14 <braulio> I am trying to write a type family `type family (a :: Nat) >= (b :: Nat) :: Bool` that does the obvious thing
16:57:25 <braulio> using ghc type lits and type level naturals
16:57:56 <nykros> Using abreviations like oic is unpolite in this forum? It´s looks likes everyone likes to write in real English
16:58:10 <braulio> the thing is I cannot do a type instance like `type instance (a + 1) >= (b + 1) = a >= b`
16:58:43 <braulio> because that's an "Illegal type synonym familiy application"
16:59:01 <puregreen> nykros: well, I've no idea what oic means, despite, well, having been on the internet for some time
16:59:17 <glguy> nykros: People will take you more seriously if you write in whole words, generally.
16:59:20 <codebje> λ> let f log = do { logInfoN $ "log: " `T.append` log ; (liftIO . putStrLn . T.unpack) log }
16:59:22 <crucify_me> but one last thing c_wraith -- judging from the type signauture, f must have a transformative nature, it takes an a and does something that is not, in fact, returned by the function. why write it as if it were transforming?
16:59:23 <codebje> f :: (MonadIO m, MonadLogger m) => T.Text -> m ()
16:59:24 <hpc> braulio: imagine it's like writing a case of a function, and the type level doesn't have NPlusKPatterns
16:59:33 <braulio> I've been trying to see how base implements this very same functionality but can't find the type familiy instance in https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.TypeLits.html
17:00:24 <c_wraith> crucify_me: it isn't required that the type a and c be different.  Making them different type variables allows them to be different, but doesn't require it.
17:00:26 <zblkf> codebje: it gives the same error
17:00:48 <zblkf> oh I see, the liftIO
17:01:14 <braulio> hpc: ok I see, but then how could I "pattern match" against the type I want?
17:01:23 <zblkf> codebje: thank you
17:01:36 <codebje> np
17:02:04 <nykros> I think OIC means Ohh I See... But I think I will enjoy writing full sentences
17:02:22 <crucify_me> ok that is the part I keep forgetting. thanks c_wraith   -- I can't wait to have a better handle on this.
17:02:23 <hpc> hmm, i am having a hard time finding it
17:02:33 <braulio> if I had defined those types I could use `type instance (S n) >= (S m) = ...` but I can't find the type constructor type lits use for Succ
17:02:36 <zblkf> codebje: why do I have to liftIO somethine that is supposed to be IO already though ?
17:03:28 <hpc> braulio: looks like i am wrong - https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/src/GHC.Types.html#Nat
17:03:43 <hpc> my information must be out of date on that particular bit
17:04:35 <epta> whoa, it's possible to set a ghc dependency in cabal file? https://github.com/DanielG/ghc-mod/blob/master/ghc-mod.cabal#L207
17:04:45 <epta> for how long it's been a feature?
17:05:19 <braulio> hpc: ok, now I have absolutely no idea how the "pattern match" could be performed
17:06:00 <glguy> epta: That's a dependency on the ghc library itself
17:06:15 <glguy> for when you want to use the compiler inside your program at runtime
17:06:24 <hpc> https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.TypeNats.html#%3C%3D - braulio
17:06:45 <hpc> braulio: that's the definition of (>=) in base, looks like it's an alias on (>=?) which is defined a few lines down with no instances
17:06:54 <hpc> er, <=
17:07:01 <braulio> yes, that's what I saw
17:07:19 <braulio> but I wanted to implement a version of those type family instances myself
17:07:34 <braulio> and was surprised that there were no type instances
17:07:43 <braulio> in the source
17:08:19 <gremdrus> does let do lexical binding? so a let within an if can never be used outside of the if?
17:08:41 <hpc> gremdrus: it would be horrifyingly bad if it worked anyway else ;)
17:09:32 <braulio> maybe it's done that way so that ghc can use a more efficient representation of type level nats at the expense of not letting users handle the "raw" types
17:09:54 <jle`> braulio: GHC type nats aren't really that sophisticated
17:09:58 <jle`> they pretty much have no structure
17:10:27 <jle`> (>=) is more or less provided as a primitive
17:11:03 <jle`> braulio: imagine a type like data Nat = 0 | 1 | 2 | 3 | 4 | 5 | ...
17:11:16 <jle`> that's pretty much what the GHC TypeLits Nat is
17:11:34 <braulio> jle` so that means you cannot implement <= by yourself on type lits
17:11:45 <jle`> yes it's provided as a primitive
17:11:52 <jle`> kind of like implementing <= yourself for Int's
17:12:14 <braulio> ok I see
17:12:27 <jle`> +, <=, ==, etc. are not implementable for Ints, tehy are provided as primitive operations
17:12:28 <braulio> then I'll implement <= for my own type level nats I guess
17:12:39 <jle`> it depends on what you need
17:12:44 <jle`> you can just use the <= that is provided
17:13:05 <braulio> I was just doing this as a learning exercise
17:13:17 <jle`> ah, yeah, in that case you can write your own nat type
17:13:24 <jle`> if it's for fun :)
17:13:41 <braulio> don't roll your own type-level nats haha
17:13:49 <braulio> yes, thank you very much
17:13:58 <jle`> there are some advantages for alternative (peano) type level nats
17:14:16 <jle`> in a lot of projects i use both side-by-side.  unfortunately, heh
17:14:48 <braulio> I'm intrigued, what are those advantages?
17:15:04 <jle`> when you're working with, say, type level lits
17:15:13 <jle`> type level nats can be useful because they have the same structure
17:15:25 <jle`> if you are breaking down a list that's made using cons and nil
17:15:36 <jle`> and you don't care about its contents
17:15:47 <jle`> basically Nat ~ (forall a. [a])
17:15:51 <c_wraith> The big advantage to peano nats is that they're defined generatively, so GHC knows S n ~ S m implies n ~ m
17:16:03 <jle`> er wait i said something wrong
17:16:06 <jle`> Nat ~ [()]
17:16:12 <c_wraith> GHC has no idea (n + 1) ~ (m + 1) implies n ~ m
17:16:34 <gremdrus> I'm using linux atm, but does intero work well on windows?
17:16:39 <jle`> TypeLits nats are useful when you don't care about inductive structure
17:16:58 <jle`> to me it's kind of similar to [a] vs. Vector a
17:17:31 <braulio> ah, so you both c_wraith and jle` are saying the same thing right?
17:17:36 <c_wraith> braulio: yes
17:17:57 <jle`> yeah, there's a benefit and use situation for both inductive lists and Vector's
17:17:59 <jle`> within the same program
17:19:03 <braulio> I believed type level lits were under the hood defined inductively too
17:19:13 <braulio> or at least that the GHC knew about their structure
17:19:35 <jle`> yeah, it might be from seeing other types called 'Nat'
17:19:54 <jle`> i don't blame you :)
17:20:05 <jle`> for what it's worth, there are type checker plugins that exist
17:20:07 <c_wraith> the best part..  You know the KnownNat class?
17:20:12 <jle`> that allows GHC to deduce things like (n + 1) ~ (m + 1)
17:20:18 <jle`>  => n ~ m
17:20:21 <jle`> i think
17:20:29 <jle`> ...i might be wrong
17:20:45 <braulio> c_wraith I've seen that in the source of TypeNats but don't know what they are
17:21:00 <braulio> jle` that seems to keep the best of both worlds haha
17:21:00 <geekosaur> jle`, I think you're thinking of natnormalise?
17:21:14 <jle`> geekosaur: maybe, but i'm not sure if it's powerful enough to do that
17:21:21 <c_wraith> braulio: it's a class that lets you get the value at runtime
17:22:07 <geekosaur> actually this one is
17:22:13 <geekosaur> @hackage ghc-typelits-knownnat
17:22:13 <lambdabot> http://hackage.haskell.org/package/ghc-typelits-knownnat
17:22:20 <geekosaur> I think
17:22:24 <jle`> nice :)
17:22:34 <jle`> i've been manually constructing these instances at runtime
17:22:43 <jle`> which is not very fun
17:23:54 <braulio> c_wrath and why is that the best part?
17:24:10 <braulio> c_wraith
17:24:49 <c_wraith> braulio: the GHC implementation of KnownNat cheats a little bit.  Instead of using a standard dictionary, it just contains the Integer value
17:27:09 <gremdrus> I'm getting a run time exception for some reason: https://gist.github.com/gremdrus/27b34be5df49e2bcb024d9bcae762db2
17:27:23 <dolio> c_wraith: Dictionaries with a single value being just the value is the standard, I think.
17:28:13 <dolio> It's the basis of some reflection magic edwardk was talking about adding with SPJ (although I don't know if it happened).
17:28:22 <c_wraith> hmm.  I guess that does make sense.  They aren't manually generated, so the compiler probably won't mess it up
17:29:20 <c_wraith> except when they are manually generated or the compiler does mess them up. :)
17:29:35 <braulio> c_wraith what do you mean by standard dictionary?
17:29:52 <c_wraith> braulio: are you familiar with how GHC implements classes?
17:30:20 <braulio> ok that's why I didn't understand then haha
17:30:46 <braulio> no, I have a long way before getting into GHC internals I believe
17:31:47 * hackagebot otp-authenticator 0.1.0.1 – OTP Authenticator (a la google) command line client – https://hackage.haskell.org/package/otp-authenticator
17:33:11 <c_wraith> braulio: actually, it's not very complicated.  GHC more or less turns classes into records.  When it does type inference, it automatically finds and passes the correct record for the type in use.
17:40:48 <braulio> c_wraith I'm not sure what you mean by records in this context.  Is it that ghc "packs" every instance in a structure and then type inference finds the correct instance?
17:41:41 <jle`> braulio: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
17:42:48 <braulio> jle` thanks for the reference! there are definitely some blogs I need to _study_
17:42:59 <jle`> you're in for some fun :)
17:43:01 <braulio> and thank you all very much for the help
17:43:11 <braulio> I ended up learning about more things than I expected
17:43:30 <braulio> I'll keep lurking around in the future
17:44:31 <mniip> is it possible to tell cabal to list paackages in dependency order?
17:45:33 <pacak> mniip: There's a package called cabal-sort - it might or might not work with recent cabal though.
17:46:14 <mniip> lgtm
17:49:01 <mniip> yeah
17:49:04 <mniip> looks like it's too old
18:07:20 <pimlu> what's the difference in laziness between "zip [0..n] list" and  "[(i, list !! i) | i <- [0..n]]"?
18:08:27 <pimlu> looking at the prelude definition of zip I can't figure out why, but it seems like using the first is causing thunk elements of list to be evaluated, whereas the second does not
18:09:00 <pacak> !! is inefficient
18:09:15 <pimlu> sure, but that's not the main question here
18:09:56 <c_wraith> they should have equivalent laziness, if you ignore the horrible performance of the latter
18:09:59 <pimlu> what I'm asking is, these two expressions differ in whether elements of list are getting evaluated or not, and I'm trying to figure out why
18:10:45 <c_wraith> pimlu: neither of those should evaluate any *elements* of list - only the structure.
18:10:52 <pacak> > drop 1 $ zip [undefined, 1] [undefined, 2]
18:10:54 <lambdabot>  [(1,2)]
18:11:17 <pacak> pimlu: prelude version won't evaluate elements.
18:11:19 <pimlu> well, this is being used elsewhere in the program of course - it's being fed into an array in my case
18:12:54 <jle`> there's too much we don't know to be able to say for sure
18:13:06 <dramforever> Then it's something else's problem
18:13:17 <jle`> you should post some code that demonstrates what you're seeing
18:13:28 <pimlu> alright, I'll try to simplify it
18:13:30 <jle`> i don't think it's as simple as the example you're giving
18:13:52 <pimlu> if changing that particular expression changes the laziness behavior though, shouldn't it be representing the thunks differently somehow?
18:14:06 <pimlu> regardless of the context
18:14:08 <jle`> zip has some rewrite rules
18:14:12 <jle`> for fusion
18:14:29 <jle`> so if you're using it with other lists, the whole expression might be rewritten to be more efficient
18:14:41 <jle`> er, with other list functions
18:15:31 <pimlu> so if zip has some fusion rule related to constructing arrays it might compute it strictly?
18:15:37 <mniip> no
18:15:42 <mniip> it will never change strictness properties
18:15:54 <mniip> or rather, it will never change properties of functions wrt bottoms
18:16:11 <mniip> it can make functions strict as long as they remain mathematically the same in a given context
18:16:14 <pimlu> I see what you mean
18:16:18 <pimlu> so rather, to be more precise
18:16:30 <pimlu> it might evaluate in a different order, or evaluate the whole thing, as long as it's safe
18:16:47 <mniip> it might evaluation in a different order, yes
18:17:01 <mniip> s/tion/te/
18:21:12 <pimlu> (working on a simple example now)
18:30:22 <pimlu> the behavior goes away in the simpler example I constructed... I guess maybe I'll just accept this as sorcery
18:31:07 <pimlu> in the real code the usage of !! is bounded to a small constant length and only gets called once, so it's not that bad
18:51:41 <mac10688> I want to run my webservice written on top of the spock framework, so that I can access it with my other computer. Do I need to host my server with nginx or keter to accomplish that?
19:08:25 <Axman6> mac10688: just use warp
19:38:14 <nykros> I´m reading Hutton´s book. The "The game of Life" uses ESC sequences to control the screen, but it seems that doesn´t work on Windows 7.
19:39:15 <nykros> Any idea? 
19:44:04 * hackagebot cmark-gfm 0.1.1 – Fast, accurate GitHub Flavored Markdown parser and renderer – https://hackage.haskell.org/package/cmark-gfm
19:45:30 <geekosaur> use windows 10. 7's escape sequence support is not good enough.
19:45:44 <geekosaur> hutton was probably assuming a unix-ish terminal
19:45:56 <geekosaur> (alternatively, install linux or freebsd in virtualbox)
19:48:27 <mac10688> Axman6, I can use warp to host my webservice?
19:52:24 * hackagebot fltkhs 0.5.3.8 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
19:53:05 <Axman6> mac10688: yes, that is it's point, unless I'm misunderstanding the problem?
19:53:14 <nykros> so, there is no library for doing the translation to windows console?
19:53:26 <arahael> mac10688: No.  (Note: "host" means the box or server running the service).  Warp is merely a webserver implementation.
19:53:48 <arahael> mac10688: You can run it locally, in which case your host is your local box.
19:55:07 <mac10688> gotcha
20:01:59 <nykros> In hackage, what does it means? "All reported builds failed as of 2016-10-26" The package will not compile if I try to include it, isn´t it?
20:02:48 <glguy> It means that when the automatic build system tried to build it that it didn't build. This can be because it relies on an external library that the build system didn't have or because the constraints were wrong or because it was just broken. What package?
20:12:44 <nykros> YEAAAHH! I make it work with System.Console.ANSI. It is even better than I expected, because I dont need to remember ESC codes
20:13:26 <nykros> I had to include build-depends: ansi-terminal into the .cabal file
20:16:06 <nykros> The broken package are Win32-console-0.1.0.0 and The AWin32Console package
20:19:13 <mniip> uhhuh
20:19:25 <mniip> how would I read about 2MB of json from stdin quickly
20:19:35 <mniip> the approaches I am using are issufficiently fast
20:20:06 <EvanR> the json C lib has an interesting way to stream that
20:21:12 <mniip> well I'm trying to use aeson
20:22:05 <EvanR> it has to read in all MB before you can analyze the json 
20:22:29 <mniip> right
20:22:41 <EvanR> which, sucks
20:25:07 <EvanR> instead, you could make the construction of the Value lazy I/O done right
20:25:07 <mniip> the read takes 0.01s
20:25:18 <mniip> which is acceptable
20:26:40 <EvanR> you could also get some speedup by getting bytestring strings back
20:26:52 <EvanR> dont bother with text (yet)
20:27:13 <mniip> everything is working in bytestring already
20:27:31 <mniip> it takes 0.4s from ByteString to a Value
20:27:39 <EvanR> it converts to Value (Text) first
20:27:58 <EvanR> then you could get a ByteString by encoding
20:28:09 <EvanR> but thats an extra step
20:28:17 <mniip> I'm using eitherDecode (BL.fromStrict stuff)
20:28:33 <EvanR> decoding utf8 and checking for errors can be skipped
20:29:18 <EvanR> if you dont care about the string contents, or can detect a "shortcircuit" before you care about string contents
20:30:47 <mniip> what do you mean
20:32:03 <EvanR> before you can begin to analyze any json it has to validate every string in the json
20:32:29 <EvanR> in order to provide a parse error
20:32:34 <EvanR> up front
20:34:20 <EvanR> everything does this, but it potentially slows things down
20:36:13 <mniip> hmm
20:36:19 <mniip> can I decode Value into a FromJSON a
20:36:47 <jle`> parseJSON?
20:36:55 <geekosaur> Value's just an ADT
20:37:32 <mniip> ok then what the hell is a Parser
20:37:53 <EvanR> it looks at a Value and tries to convert it to something else
20:38:04 <jle`> mniip: oh nevermind, i meant fromJSON
20:38:20 <EvanR> but you have to have the value already
20:39:11 <nykros> How do u read/think fmap? "functor map"? 
20:39:21 <EvanR> F-map
20:39:56 <geekosaur> one of us is confused, a Value is a parsed value but still in internal representation. for basic types this has constructors for those types; a dictionary will be on the Object constructor, which wraps a HashMao
20:39:59 <geekosaur> *HashMap
20:40:14 <jle`> fromJSON :: FromJSON a => Value -> Result a
20:40:30 <jle`> nykros: i say fmap in my head
20:40:56 <mniip> anyway
20:41:13 <mniip> it's the "decodeWith json'" that takes away most of my time
20:41:17 <mniip> what could I do about it
20:42:20 <pacak> mniip: decodeWith - something that takes attoparsec's parser and applies it.
20:42:34 <pacak> Do you know anything about json you want to parse?
20:42:54 <mniip> yes, there's a couple megabytes
20:43:12 <pacak> Other than size?
20:43:19 <mniip> I know that it's well-formed 7-bit ascii json
20:43:46 <pacak> json - attoparsec's parser. Take a look at what it does, see if you can get rid of something.
20:44:09 <pacak> Parsing of numbers in any supported formats can be slow.
20:44:20 <pacak> You might be able to get rid of escaping, etc.
20:45:34 <kzhang> In Idris, functions can compute types. For example, isSingleton : Bool -> Type. Will Haskell be able to do this in future, with dependent types?
20:45:56 <EvanR> i have a feeling you want something besides Value
20:46:14 <EvanR> and a modified parser
20:46:36 <pacak> Yea, making Value can be expensive if there's lots of objects inside.
20:46:44 <mniip> not really
20:46:52 <mniip> 99% of the data is a huge string
20:47:04 <EvanR> and you know its ascii
20:47:11 <mniip> the json is ascii
20:47:15 <mniip> the string is binary garbage
20:47:15 <EvanR> right
20:47:20 <EvanR> er...
20:47:36 <mniip> escape codes duh
20:48:07 <EvanR> you can speed up the decoding of the json blob by not validating and converting that huge string
20:48:24 <EvanR> once you have it, you could use a faster or smarter decoder
20:48:48 <EvanR> by "have it" i mean a slice of the original buffer your data was in
20:49:29 <EvanR> a very large string within the json, might be a slow case of aeson
20:49:30 <mniip> ugh
20:49:53 <mniip> I just hacked it and added gzip which slashed the string's length by a couple orders of magnitude
20:50:08 <EvanR> haha
20:50:28 <mniip> well, just one actually
20:50:58 <EvanR> is gzip outputting escape codes for the ?
20:51:05 <EvanR> for the binary bytes
20:51:29 <EvanR> theres that "compressor" that converts binary data into unicode text
20:52:17 <EvanR> so it takes up less space in json
20:52:32 <nisstyre> that's hilarious
20:52:35 <pacak> I suspect it's not about space but about escape codes.
20:52:44 <nisstyre> I thought that was just because it was printable
20:52:52 <nisstyre> so you could put it in messages and stuff
20:52:57 <EvanR> the escape codes are much longer than the character themselves
20:53:06 <EvanR> encoded as utf8 or so
20:53:18 <pacak> EvanR: They are more expensive to parse.
20:54:15 <pacak> There's a difference between takeWhile (/= '"') and actively decoding every escape code and collecting them somewhere
20:54:16 <EvanR> but if youre gzipping for space... putting a bunch of 0-256 numbers in a string... with codes... whats that 4x bloat
21:14:49 * hackagebot exitcode 0.1.0.0 – Monad transformer for exit codes – https://hackage.haskell.org/package/exitcode
21:16:45 <sqooq> hey is ertes in here?
21:19:00 <mniip> ugh
21:19:04 <mniip> that did not help much
21:22:24 <pacak> mniip: Do you have any control how this json is created?
21:22:35 <mniip> no
21:22:41 <mniip> well, little
21:23:07 <pacak> A simple experiment - try replacing binary escaped garbage with "AAAAAAAAAAAAAAAAAAA..."
21:36:36 <mniip> pacak, reduces from 2.4s to 0.4s
21:37:03 <pacak> Here's your problem then.
21:37:24 <pacak> json is not very good for binary blobs...
21:38:04 <sqooq> what about monochrom, you here?
21:38:07 <pacak> If you can - try to get rid of all the escaping, leaving only " escaped.
21:39:34 <pacak> Or use gzip for that string (since it reduces length by some orders of magnitute), but on string with no escapes.
21:41:06 <mniip> pacak, anything faster?
21:41:37 <pacak> Probably, but I don't know your full situation.
21:43:27 <sqooq> leaffinder :: Tree a -> [[Int]];  leaffinder (Leaf _) = [[]];  leaffinder (Branch x) = zipWith (\x y -> x : concat (leaffinder y)) [0..] x
21:43:38 <sqooq> trying to find the locations of leaves on a tree
21:43:40 <sqooq> by index number
21:44:02 <sqooq> I thought this would work based on ertes and monochrom's advice a few days ago but it's not quite right
21:44:19 <mniip> pacak, ok, what do you need to know
21:45:40 <pacak> If you can change format, if you can insert something in some other language to preprocess stuff, if you can drop aeson and manually parse using attoparsec. Also I'd look at why exactly escaping is so slow.
21:48:03 <mniip> hmm
21:48:36 <mniip> chances are I'm not beatin aeson devs at parsin json
21:49:16 <pacak> Chances are you are.
21:49:23 <pacak> aeson tries to be generic.
21:49:39 <pacak> You only need to beat them at some very specific set of data.
21:50:14 <mniip> ok, let's add "rapid development" into the picture
21:51:07 <pacak> Change format.
21:52:03 <mniip> json is fixed
21:53:41 <pacak> Is it escaped by whatever source you use?
21:54:31 <mniip> yes
21:55:44 <pacak> Try unescaping it using any other library in any other language. Or any other program. If that's slow then there's not much we can do.
21:56:40 <sqooq> ayyy I fixed it !
21:56:47 <sqooq> if anyone's curious 
21:56:49 <sqooq> leaffinder (Branch x) = concat $ zipWith (\x y -> map (x :) (leaffinder y)) [0..] x
21:58:54 * hackagebot hw-rankselect 0.9.0.0 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
21:58:54 * hackagebot proto-lens-protoc 0.2.2.3 – Protocol buffer compiler for the proto-lens library. – https://hackage.haskell.org/package/proto-lens-protoc
22:21:11 <jared-w> You know what sucks? Having enough motivation to start work on an ongoing project but not enough motivation to make any real progress
22:29:48 <ab9rf> heh
22:30:14 <ab9rf> i usually have enough motivation to get started on a project, but by the time i get my build tools all updated and a workspace created, i'm out of motivation
22:30:18 <EvanR> motivation to start, motivation to make progress, how about lack of braincells to make progress...
22:30:29 <EvanR> at the moment its appropriate
22:31:10 <ab9rf> or indeed have forgotten what i was going to do in the first place
22:31:23 <ab9rf> that might be senility though
22:32:23 <jared-w> nah, I have that too--might be ADHD. Although you could be blessed with both, I guess :p
22:32:36 <jared-w> (or, rather, it's definitely ADHD in my case)
22:32:40 <ab9rf> i'm not sure, i can't remember anymore
22:32:48 <jared-w> ¯\_(ツ)_/¯
22:33:07 <jared-w> So what's everyone working on or wanting to work on or forgot to work on? lol
22:33:10 <ab9rf> my moosic ran out
22:33:27 <jared-w> Did you put a coin in the jukebox to keep it going?
22:33:45 <ab9rf> no but i'm poking at my phone to make it start again
22:36:55 <EvanR> a type system that lets you attach prices to operations and track how much "coinage" you have at which point, and what earns coinage
22:37:15 <EvanR> and fails to compile if you tried to go over budget
22:37:39 <EvanR> rather..... i guess only would go so far to fail to compile is you didnt prove you dont go over budget
22:38:41 <jared-w> oh neat, so somewhat like the nitro system the Rust compiler uses to know when to stop trying to optimize stuff?
22:39:17 <EvanR> something like this is on the books for use with tracking memory usage
22:39:28 <jared-w> EvanR: that last sentence lost a bit of coherence I think, but I got what you meant lol
22:39:57 <jared-w> EvanR: for your language or for Haskell? Because it'd be awesome to see some heuristic methods in place to tweak Haskell's memory usage and graph reduction
22:40:28 <EvanR> big neither
22:41:08 <EvanR> like, if you have 1k of ram, not only will haskell not run, but its probably silly to expect any generic functional language to run, unless the compiler can know you dont need more than 1k
22:42:07 <EvanR> so chains of typing rules would ultimately trace back to your original budget of 1k
22:42:38 <sqooq> I have token before every function in a do block except one
22:42:59 <sqooq> what do
22:43:41 <jared-w> sqooq: token the tokens?
22:44:05 <ab9rf> ?
22:44:08 <EvanR> sqooq what do you mean
22:44:29 <jared-w> EvanR: true, and that's neat. How are you implementing and tracking the "cost"?
22:45:02 <sqooq> I mean to ignore space when parsing, I use token on every function in the do block
22:45:13 <ab9rf> "token"? what is "token"?
22:45:14 <sqooq> but I know there's something I can do to simplify
22:45:18 <EvanR> you should consume extra space at the end of your token parser
22:45:18 <sqooq> token removes space
22:45:20 <EvanR> not the beginning
22:45:24 <ab9rf> oh, you're writing a parser
22:45:33 <EvanR> except at the very beginning
22:46:04 <jared-w> ab9rf: He's been on the irc for the past week or so about his parser so he probably forgot not everyone online actually knew what he was working on
22:46:10 <ab9rf> vaguely reminded of fortran, which completely disregards whitespace
22:46:20 <ab9rf> jared-w: i knew someone was doing that but i forgot who it was
22:46:37 <EvanR> jared-w: i dont have any paper or details in front of me... but your toolbox of operations would be pretty limited i guess
22:47:43 <jared-w> EvanR: I'd imagine lol. One thing I can think of is that there's an algorithm for calculating optimal graph reduction of a subset of lambda calculus, so in theory, one might be able to use that along with some heuristic to "guess" a computational cost. And I suppose tracking allocations might work for meomry?
22:47:54 <EvanR> even with malloc/free, and where free is equipped to know, in its type, how much space its freeing, theres fragmentation
22:48:39 <EvanR> haskell like LC cant be done, with general recursion no one can know how much work a function could do, and work = allocation
22:49:50 <jared-w> yeah, I know general recursion limits that, but some heuristics might be able to get you a reasonable starting point from which to go from? It's a difficult problem, assigning 'costs' in types, and I've got no idea how to do it :p
22:49:59 <pimlu> does GHCI perform rewrite rules?
22:50:08 <sqooq> here's parser code
22:50:09 <sqooq> http://lpaste.net/357474
22:50:14 <pimlu> or is that only with optimizations enabled
22:50:20 <EvanR> assigning costs in types in easy with dependent types, but making them mean anything, ... theres at least one paper that i cant find right now
22:50:35 <jared-w> pimlu: only with optimizations enabled. It often spikes compile times, so it's off by default
22:50:58 <EvanR> you can imagine an indexed monad, indexed by how much money you have
22:51:08 <EvanR> each operation changes that amount
22:51:19 <pimlu> I see, thanks
22:51:51 <Lokathor> Use {-# LANGUAGE NintiesEraMoneyMonad #-} to make sure the money never goes back down
22:51:58 <jared-w> Changing the amount with an indexed monad makes sense to me, I'm just not quite sure how to assign meaningful costs. Like, is it expected for a programmer to guess and say "this function is totally a three-fiddy"? :p
22:52:18 <jared-w> Lokathor: use {-# Language TrickleDownEconomics #-} to guarantee massive space leaks
22:52:29 <EvanR> type inference baby
22:52:47 <EvanR> primitives have a cost, so ...
22:52:55 <EvanR> combinations have a cost derived from that
22:52:56 <sqooq> ok turns out I only need 3
22:53:01 <sqooq> nevermind that's more believable
22:53:03 <dfordivam> Hey all.. what should be a simple way to create a random sub-set of a given size from a Data.Set
22:53:08 <sqooq> I redact my call for help
22:53:19 <jared-w> EvanR: So we define the primatives to have a certain cost manually?
22:53:26 <sqooq> is ertes back yet
22:53:36 <EvanR> if this is a platform provided to clients, the vendor does that
22:53:53 <jared-w> ahh gotcha, I see now, that makes sense
22:53:58 <EvanR> like, if it was the instructions for the microcontroller in question
22:54:07 <EvanR> no point in having a programmer "decide" that
22:54:22 <jared-w> Then the microcontroller spec should have some pretty clear cost analysis done on it. So yeah, sweet, I'm following ya now. Sounds cool
22:54:38 <EvanR> the manuals have the number of cycles they take...
22:54:51 <EvanR> so that would correspond to type-checking the real-timeness
22:54:56 <EvanR> rather than memory
22:55:14 <jared-w> That's what I meant, m'bad. I'm assuming cost analysis has a different meaning in hardware?
22:55:22 <EvanR> you have 3 microseconds before the nuke goes off
22:55:31 <EvanR> code must complete
22:56:03 <jared-w> spooky
22:56:04 <EvanR> compile failed. nuke went off :)
22:56:39 <jared-w> dfordivam: depends on what you mean by random sub-set, I guess
22:57:09 <Lokathor> sounds like you want a less abstract language with more predictable operating time :P
22:57:38 <nshepperd> that would be practical in like a haskell eDSL that outputs C or even assembler
22:57:40 <EvanR> operating time can be an aspect of the abstraction
22:57:47 <mibaz_1> In Stack, what's the difference between build-depends and extra-deps?
22:57:49 <nshepperd> like ivory
22:57:58 <EvanR> really... does C help?
22:58:36 <jared-w> EvanR: People have built real-time systems in C iirc
22:58:46 <glguy> mibaz_1: build-depends define the range of versions your package supports and goes in the .cabal file. The extra-deps is just the particular version of a package you're using in your local workspace
22:58:48 <jared-w> But like, correctness wise, of course C fights you every step of the way /s
22:58:59 <EvanR> not sure what kind of goggles you need to wear to see what C costs
22:59:05 <dfordivam> jared-w: a smaller Data.Set  with elements from bigger Data.Set chosen randomly... can there be multiple interpretation of this..
22:59:22 <jared-w> dfordivam: take x mySet  -- done :p
22:59:49 <nshepperd> yeah I guess even with C it's somewhat removed from the instruction set so it may not be obvious to calculate the running cost excatly
22:59:55 <joyfulmantis> Hey guys, could someone point me to where the datatype 'Chars' is defined? It pops up in Data61's fp-course (FileIO.hs), and I can't for the life of me find out exactly what it is.
23:00:06 <mibaz_1> glguy: So external libraries need to be in extra-deps while every dependency needs to be in build-depends?
23:00:34 <jared-w> joyfulmantis: can you click on the `source` thing in the haddocks?
23:00:35 <EvanR> im kind of more interested in memory usage
23:00:39 <ongy> for the applications where real time matters, they don't use the fancy gcc optimizer and all, so it's way closer than normal C. I've seen people count cycles on their C code
23:00:52 <glguy> mibaz_1: Only direct dependencies needs to be in build-depends. All the packages, direct and transitive, that you depend on must be either in the resolver you're using or in extra-deps
23:01:13 <ab9rf> joyfulmantis: Data.ListLike, most probably
23:01:35 <jared-w> ongy: and in RTS, don't they even disregard the entire stdlib and use their own hand-rolled code for most everything so they have more reliable cycle counts?
23:02:00 <mibaz_1> thanks glguy
23:02:01 <jared-w> EvanR: why memory usage over cycle counts?
23:02:37 <ongy> jared-w: I've only seen RTS done on odd platforms either way, so the stdlib degrades, no memcpy_sse and such.
23:02:37 <EvanR> if you only have 1k ram, doesnt matter how long a program that uses 1.2k ram takes?
23:02:47 <EvanR> might be interesting to know how long before it craps out though :)
23:02:55 <EvanR> automatically
23:03:16 <ongy> always depends on what constraints you have. sometimes you have hard time constraints and can upgrade memory
23:03:20 <nshepperd> yeah there are memory and time constrained devices
23:03:42 <ongy> I'd love to see a system that can do either reliably in a somewhat automated way
23:03:43 <jared-w> EvanR: fair enough. Although I guess I haven't really ever seen RTS-like code done without 100% manual memory management so it's often assumed you can already work within the memory constraints at all times
23:03:44 <nshepperd> memory will probably be constrained if your target is a homomorphically encrypted program!
23:04:04 <EvanR> hehe
23:04:10 <joyfulmantis> @jared-w yeah, but not sure which module to look in
23:04:10 <lambdabot> Unknown command, try @list
23:04:19 <jared-w> But yeah, being able to make a compiler that could constrain in memory or time in a semi-automated way would be awesome :p
23:04:48 <EvanR> jared-w: well... the thing i was just talking about may not feel much better than manual memory management... though manual managment also has these checks for if you run out of memory which... makes no sense for many programs
23:04:51 <joyfulmantis> ab9rf: I can find 'CharString' there, but no 'Chars'
23:04:55 <jared-w> nshepperd: usability will be constrained if your target is a quantumly homorphic encrypted program :p
23:05:09 <EvanR> its possible to look at a program and prove youll never run out of memory, for a given amount of memory
23:05:24 <EvanR> so the check is pointless
23:05:41 <ab9rf> joyfulmantis: it's right below CharString in the hackage module list
23:05:47 <ab9rf> http://hackage.haskell.org/package/ListLike
23:06:12 <nshepperd> jared-w: ah, but that's the user's problem :)
23:06:33 <ab9rf> joyfulmantis: to be fair, it's rather skeletal
23:07:33 * hackagebot GPipe-GLFW 1.4.1.1 – GLFW OpenGL context creation for GPipe – https://hackage.haskell.org/package/GPipe-GLFW
23:08:52 <joyfulmantis> ab9rf:ah found it, thanks!
23:28:34 <sqooq> crap
23:28:36 <sqooq> craaaap
23:29:21 <EvanR> cleanup on aisle #haskell
23:29:25 <sqooq> I forgot to consider multiple digits for my parser
23:29:37 <sqooq> made the whole thing only keeping in mind the simple example of a single number
23:29:45 <sqooq> now that I realize it, I don't know how to fix it
23:29:58 * EvanR waits until sqooq fixes the code... before mentioning negatives
23:30:54 <pimlu> okay, I'm totally lost...
23:31:25 <pimlu> so, I've been trying to improve some code that makes a growable array out of an infinite list
23:31:28 <pimlu> http://lpaste.net/4246550653658202112
23:32:35 <pimlu> but if I try replacing that last parameter on line 10 with "zip [0..64] arrs", it seems to allocate everything in advance instead of lazily
23:33:24 <pimlu> the behavior you see instead is, the moment you try to access an element, it will attempt to allocate what seems to be 2^64-1 elements of array memory lol
23:33:39 <pimlu> the thing is
23:33:56 <pimlu> if I shrink the size of the array so that it can allocate it all, the traces are the same
23:34:03 <pimlu> so it doesn't seem to be different with laziness
23:34:40 <jared-w> You mean replacing i <- [0..64] with i <- zip [0..64]? Or replacing the entire list comprehension with a zip?
23:35:01 <pimlu> replacing that whole list comprehension with the zip expression
23:35:40 <pimlu> if I do that, the program is functionally the same (and will work if you change the bits to 10 instead of 64), but it allocates memory
23:35:43 <pimlu> the weird thing is
23:35:53 <pimlu> if I put the traces in before the array constructors
23:36:06 <pimlu> the allocation happens before any traces occur
23:39:35 <pimlu> (to use it, just try "getvec (vector [1..]) 3")
23:41:46 <pimlu> this happens with -O0, so it's not the result of any optimizations
23:49:20 <tsahyt> Is it possible with (presumably) some kind of typeclass hackery to have constructors for arbitrary HList types, which are indexed on the type level? e.g. build :: Int -> Char -> HList '[Int, Char], and so on?
23:50:07 <nshepperd_> pimlu: array (0, 64) (zip [0..64] arrs) needs to see all of arrs before it knows how to fill the array
23:50:26 <tsahyt> I'm thinking that since all information required is statically know, this should be possible somehow
23:50:32 <nshepperd_> To be precise, it needs to see the spine of arrs
23:51:09 <pimlu> spine?
23:51:26 <sqooq> my parser hangs now.... :(
23:51:36 <nshepperd_> The list constructors
23:51:38 <phadej> tsahyt: single 'build' for all possible HList ?
23:51:51 <nshepperd_> It needs to know how long the list is, iow
23:51:51 <tsahyt> well, an overloaded one
23:51:55 <pimlu> I see
23:52:17 <pimlu> that makes sense, but it still doesn't need to access arrs itself
23:52:26 <lyxia> tsahyt: build :: A -> B -> C -> HList '[A, B, C]   too?
23:52:40 <pimlu> and indeed by the traces it actually doesn't
23:53:00 <tsahyt> lyxia: yes
23:53:06 <phadej> tsahyt: you'd need build :: Proxy xs -> SomeTypeFamily xs, where SomeTypeFamily '[Int, Char] = Int -> Char -> HList '[Int, Char]
23:53:14 <phadej> tsahyt: and there's simple reason for it
23:53:21 <nshepperd_> In your makevec function the list constructor (:) is not called until after "genericSplitAt size xs" is known to succeed
23:53:45 <phadej> tsahyt: without proxy / type-application the type is too ambigious
23:54:17 <nshepperd_> So it would read long lengths of your infinite list to try and split it into parts
23:54:18 <tsahyt> phadej: couldn't it be determined by the usage of the result?
23:54:18 <phadej> yet, e.g. Oleg has zipListN hackery, but IMHO it's not worth the trouble
23:54:31 <lyxia> it's not ambiguous as long as you know how long the list is
23:54:37 <phadej> I'd rather do build0, build1, build2, for some...
23:54:46 <phadej> lyxia: exactly, you have to know -- somehow
23:54:48 <nshepperd_> pimlu: it doesn't need to access the inner arrays themselves no
23:55:02 <pimlu> ohhh, I see
23:55:20 <tsahyt> phadej: luckily the length and element types are all know
23:55:22 <tsahyt> known*
23:55:32 <tsahyt> I was already thinking about the type family route. I'll give that another shot
23:55:36 <pimlu> so when I use a list comprehension, I avoid this by statically setting the size to 64 and only accessing certain depths of the list directly with !! inside the expression
23:55:52 <pimlu> that makes so much sense, thanks
23:56:18 <nshepperd_> !!n only observes the first n+1 list constructors
23:58:10 <nshepperd_> But more importantly yeah when you access it with !!n it's only the !!n part that depends on arrs
23:58:35 <nshepperd_> So the outer array can be entirely created without even looking at arrs
23:59:11 <pimlu> I see
