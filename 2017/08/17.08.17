00:00:24 <bvad> cocreature: you roll back the universe to a known good state?
00:00:41 <cocreature> bvad: good luck with that :)
00:00:51 <boj> in this specific case i need to update a file, a dns server, and a database. i was thinking of providing an update, and a rollback action
00:00:56 * Hafydd . o O (Does the universe have a known good state?)
00:01:04 <erisco> transcendental backups tapes are notoriously difficult to locate
00:01:07 <bvad> Hafydd: Before the big bang ;)
00:03:16 <boj> cocreature: the word "arbitrary" wasn't ideal there. i meant "any IO action paired with a rollback IO action"
00:03:35 <cocreature> boj: makes sense, sadly I don’t know of a library for that
00:04:29 <erisco> also there is no guarantee these rollbacks succeed, so rewinding is not a guarantee, and worse is you may not know if it succeeded
00:04:42 <boj> best effort i guess
00:04:42 <erisco> (or failed)
00:06:22 <boj> erisco: or this train of thought is futile even? either they all work, or one of them doesn't and the state of the system is broken
00:07:12 <Hafydd> If a train of thought fails, it is good to have a method to roll it back.
00:07:20 <boj> :)
00:07:46 <_ludat> you could make a kind of Writer and have each action write its rollback action into it, if some fails run the rollback functions that the writer collected
00:07:46 <cocreature> boj: if you can’t guarantee that things are actually transactional (e.g. because rollbacks could fail) it might be better to just accept that fact and try to recover from inconsistent states
00:08:10 <knmae> hay
00:08:16 <erisco> I am not an expert in this but you should be able to incorporate redundancy
00:09:46 <erisco> for example, if you had a local copy of the remote state then you could verify with the remote system that the states matched
00:10:09 <erisco> having a full copy may defeat the point of it, so instead you could use a checksum
00:10:56 <erisco> so when you issue an instruction to the remote system you include the state you see that system in
00:11:23 <erisco> the point being that the remote system can discern if you're making an informed decision or not
00:12:42 <erisco> if states do not match then the remote system says so together with its new state
00:12:55 <erisco> the transaction fails
00:13:44 <boj> given what i have i think cocreature touched on it - just try to recover the inconsistent states
00:16:12 <ertes-w> lo
00:19:03 <erisco> well you still have to do that ... rolling back is recovering from the inconsistent state in your case
00:20:44 <erisco> if your rollback works then you will see the initial state again
00:21:17 <erisco> if not then you'll have to fire off an automated email to the sys admin :P
00:21:39 <clever> i have seen that mysql's daemon will block when it runs out of disk space, and will continue to retry the writes until space is free'd up
00:21:50 <clever> and if you let it, the db will survive intact
00:21:57 <clever> but if you forcibly terminate the daemon, it can corrupt the db
00:22:36 <clever> i have made the mistake of trying to restart the daemon when it stopped responding for exactly that reason :P
00:25:36 <erisco> so for example you say "I see you do not have foo.txt, create foo.txt" and the other system either confirms foo.txt does not exist and creates it or fails
00:26:10 <erisco> "created foo.txt, I have foo.txt"
00:26:27 <erisco> now you rollback and say "I see you have foo.txt, delete foo.txt"
00:27:15 <erisco> "deleted foo.txt, I do not have foo.txt"
00:28:05 <erisco> the relevant state does not have to be affected by the action, mind
00:28:56 <xormor> unix.txt, vmlinux, vmlinuz
00:29:02 <xormor> rm vmlinuz-*
00:29:43 <ab9rf> probably not an important file anyway
00:30:41 <erisco> you might have some automated recovery... for example, trivially if the remote says "unable, I do not have foo.txt" when we try to delete foo.txt then we can call it a success
00:31:34 <erisco> actually in this case the triviality is seen in that we're back to the initial state of "I do not have foo.txt"
00:33:01 <boj> erisco: let me horrify you. the file in question is a vbscript which simply contains an options dropdown, and we use attoparsec to update the html and case statement in it. i'm not even going to dive into why beyond "fixing an inherited company's terrible, terrible practices"
00:33:21 <ab9rf> heheh
00:36:25 <boj> "why a vbscript with nothing in it?" on might ask. because a large number of other tools include this file... from a network drive... so they can get a DNS dropdown. (shoot me now)
00:37:02 <boj> naturally when this all needs updated, *two* departments get called. the one to update the file, the one to update the actual dns entry
00:37:29 <boj> so i am writing an intermediate tool to make a database an authritative source and do all of it at once
00:37:32 <ventonegro> holy shit
00:37:46 <srhb> boj: That is...
00:38:10 <boj> that is one of many, many processes i am having my team clean up :)
00:38:21 <erisco> and people think WTF stories are faked
00:40:11 <kahlil29> if a part of my API response is this : "production_companies":[{"name":"Paramount Pictures","id":4},{"name":"Marvel Studios","id":420}]  and I want to enter it into my custom data type. How would i define the data type? a list of what? 
00:40:31 <kahlil29> it's not allowing me to have an empty list [] and infer the type later
00:40:36 <erisco> a list of animation studios, I guess
00:41:44 <erisco> data ProductionCompany = ProductionCompany { name :: String, id :: Integer }
00:42:04 <erisco> then your list type is [ProductionCompany]
00:42:11 <kahlil29> so i'd have to define productionCompany seprately first and then have a list of production copanies 
00:42:21 <kahlil29> alright sounds good. thanks :) 
00:45:38 <bitonic> is there a name for the data structure that maps segments on the real line to values? e.g. `Map (Double, Double) a` but with the guarantee that there are no overlapping segments as the keys
00:46:08 <ventonegro> bitonic: An interval map?
00:46:38 <ventonegro> https://hackage.haskell.org/package/IntervalMap
00:47:18 <bitonic> ventonegro: right, in that case the segments might overlap
00:47:27 <bitonic> i guess my main constraint is that i want to guarantee that the segments do not overlap
00:47:46 <ventonegro> Ah, sorry
00:47:54 <bitonic> and actually i'm doing this on the unit circle, but i was looking for a name with the line version since it's probably more common :P
00:48:13 <ertes-w> bitonic: before adding a sequence, check whether it overlaps with an existing one
00:48:20 <ertes-w> bitonic: interval maps can do that efficiently
00:48:46 <bitonic> ertes-w: yes, i think i'll end up using an interval map to do what i need to do
00:49:18 <bitonic> ventonegro, ertes-w: thanks
02:27:23 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
02:27:23 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
02:27:29 <jle`> the great purpling
02:28:02 <tdammers> hypothesis: purple languages are either very good or very bad
02:28:33 <ertes-w> purplinuum hypothesis: all programming languages will be purple before AIs make them obsolete
02:29:39 * hackagebot ghc-typelits-knownnat 0.3.1 – Derive KnownNat constraints from other KnownNat constraints – https://hackage.haskell.org/package/ghc-typelits-knownnat
02:29:39 * hackagebot ogmarkup 3.0.1 – A lightweight markup language for story writers – https://hackage.haskell.org/package/ogmarkup
02:30:17 <Xnuk> What is the best way to compile Haskell code in Arch Linux?
02:30:18 <tdammers> ertes-w: I think it'll take a looooong time before we have an AI that can stomach PHP
02:30:47 <[exa]> Xnuk: what'd be wrong with using standard packaged GHC?
02:32:54 <Xnuk> I used stack but now it gives `ld` linking errors
02:33:21 <cocreature> Xnuk: hm I thought that has been fixed. what’s the exact error you’re seeing?
02:34:58 <Xnuk> It was like this https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-get-strange-ld-errors-about-recompiling-with--fpic
02:35:29 <cocreature> Xnuk: have you installed libtinfo?
02:35:32 <Xnuk> now I just removed `~/.stack` and getting fresh index
02:35:39 <cocreature> and/or ncurses5-compat-libs
02:35:43 <Xnuk> Of course I installed libtinfo
02:35:53 <ertes-w> tdammers: i'm pretty sure it would just identify a minimal core language in PHP, then write a haskell interpreter within it
02:36:30 <tdammers> would an AI benefit from a type checked language at all?
02:36:30 <ertes-w> that's basically what i did in my final days of PHP =)
02:36:43 <tdammers> interesting
02:36:46 <ertes-w> tdammers: jokes aside, not really
02:37:02 <Xnuk> `hardening-wrapper` seems to be gone, so I think the document should be updated
02:37:04 <ertes-w> it wouldn't benefit from human control structures either
02:37:06 <tdammers> ertes-w: that's what I thought. after all, the AI could just do its own typechecking
02:37:23 <tdammers> ertes-w: all it would have to implement is either a turing-style state machine, or untyped lambda calculus
02:37:37 <ertes-w> tdammers: i believe an AI would write programs very differently from us
02:37:40 <ventonegro> why not write machine code directly?
02:37:51 <tdammers> ventonegro: the challenge is to write PHP code
02:37:58 <ertes-w> tdammers: it wouldn't need all the modularity and locality features that we humans need
02:38:07 <Xnuk> I'll try to install ncurses5-compat-libs
02:38:16 <tdammers> definitely; it's just generate one huge unreadable .php file
02:38:20 <ventonegro> tdammers: that's a curse, not a challenge
02:38:23 <tdammers> s/it's/it'd/
02:38:28 <tdammers> ventonegro: my point exactly
02:39:15 <ertes-w> tdammers: you might find gene expression programming (GEP) interesting
02:39:39 <tdammers> ertes-w: I think I've discovered the concept myself at some point
02:39:50 <ertes-w> programs generated by cognitive AIs would probably be a bit cleaner, but not much
02:40:18 <ertes-w> tdammers: yeah, it's not exactly groundbreaking as a concept, but there is actually a lot of existing research
02:40:47 <tdammers> the biggest challenge in GEP, I believe, is finding a suitable mapping from genotypes to phenotypes
02:41:41 <cocreature> Xnuk: try removing libtinfo
02:42:01 <cocreature> Xnuk: if you only care about ghc 8.0 and 8.2, you shouldn’t even need ncurses5-compat-libs afaik
02:42:15 <ertes-w> tdammers: no, the biggest challenge in most cases is writing the fitness function
02:42:21 <tdammers> yeah, that too
02:42:31 <cocreature> ertes-w: I’ve stared at LLVM for too long to associate GEP with something else than "getelementptr"
02:42:39 <tdammers> the geno/pheno mapping is kind of performance critical though
02:42:53 <ertes-w> tdammers: you can't just say "good" or "bad", but you need a function that has a slope
02:42:53 <tdammers> to the point that a poor choice can make the whole thing infeasible
02:42:58 <tdammers> yes
02:43:17 <tdammers> you need to be able to tell whether you're evolving in the right direction
02:44:04 <tdammers> but PHP is actually perfect for that, because we all know you can't usually hope for a correct program, you just try to minimize the business-relevant impact of the incorrectness
02:44:32 <ertes-w> tdammers: one option is to use an 'id' mapping: don't have a separate genotype, but instead use clever mutation tricks to modify the phenotype directly
02:44:44 <tdammers> hmm, yes
02:44:46 <ertes-w> that's what i did for breaking classical crypto
02:44:56 <ertes-w> drawback: you can't do crossover (easily)
02:44:56 <tdammers> you could kind of use source code as the genotype
02:45:10 <tdammers> actually that's what you're doing anyway, you're just using a peculiar programming language syntax
02:45:39 <tdammers> and that syntax is designed to avoid malformedness
02:46:47 <ertes-w> a huge advantage of modifying the tree directly is that you can make more educated changes that race toward the local minimum
02:47:08 <ertes-w> modifying syntax in a stringly typed manner is usually very random and converges slowly
02:47:56 <tdammers> yes, and the syntax described in the wikipedia article kind of addresses this by at least encoding operations as single characters, so that you don't end up producing 99% malformed programs
02:57:26 <redfish64> In http://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.Prim.html#token , can anyone tell me what "(Stream s Identity t) =>" does?
02:58:08 <redfish64> I've seen "=>" used as a way to specify that a type must implement some class
02:58:19 <redfish64> but I don't understand this syntax
02:58:20 <Cale> That's exactly how it's being used here
02:58:33 <Cale> It says there must exist an instance Stream s Identity t
02:58:41 <quicksilver> only it's talking about two types here
02:58:41 <Cale> see: http://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.Prim.html#Stream
02:59:00 <Cale> Type classes can have as many parameters as you like
02:59:05 <quicksilver> so here it's a way to specify that two types (s and t) have a type instance
02:59:11 <Cale> class (Monad m) => Stream s m t | s -> t where
02:59:11 <Cale>     uncons :: s -> m (Maybe (t,s))
02:59:38 <Cale> So, no matter which types s and t might be, there must exist an operation  uncons :: s -> Identity (Maybe (t, s))
02:59:52 <Ferdirand> here "s" stands from stream and "t" for token
02:59:57 <Cale> yep
03:00:00 <Ferdirand> if that helps
03:00:11 <Cale> and uncons is the operation which separates the first token from the stream
03:01:05 <redfish64> Oh ok, so there must be a function uncons defined for whatever "s" and "t" is
03:01:12 <redfish64> thanks
03:02:19 <Cale> redfish64: For example, perhaps s = [Char] and t = Char, in which case, you'd want uncons [] = Identity Nothing; uncons (x:xs) = Identity (Just (x, xs))
03:02:57 <Cale> redfish64: and you'll note that in general, the monad in use might be something less trivial than Identity (though the constraint on the thing you were looking at initially set it to Identity specifically)
03:03:25 <Cale> redfish64: So, in some cases, you might actually want to have uncons perform some I/O to read from a stream.
03:05:15 <ertes-w> except uncons isn't really suitable for that =)
03:05:39 <ertes-w> unless you have extra state in 'm'
03:06:26 <ertes-w> well, i guess 's' could be a handle type
03:06:35 <Cale> yeah
03:06:54 <Cale> Or if you want to be fancy, some Producer shenanigans
03:11:56 <xa0> just freenode things
03:15:21 * hackagebot DeepDarkFantasy 0.2017.8.17 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
03:20:25 <srhb> Has anyone used project m36 for something akin to what you would use a traditional sql-y database for yet?
03:20:29 <srhb> It looks really interesting.
03:20:54 <srhb> (If nothing else than for the fun of utilizing something slightly more clean)
03:53:35 * hackagebot data-has 0.3.0.0 – Simple extensible product – https://hackage.haskell.org/package/data-has
03:57:04 <Aruro> is there good youtube api for haskell? maybe youtube-dl analog?
04:03:41 * hackagebot ogmarkup 3.1.0 – A lightweight markup language for story writers – https://hackage.haskell.org/package/ogmarkup
04:03:41 * hackagebot digit 0.4.0 – A data-type representing digits 0-9 and other combinations – https://hackage.haskell.org/package/digit
04:15:36 <merijn> Aruro: I would expect the youtube API to be HTTP based, so you should be able to use one of the HTTP packages for interacting with it. Not sure if someone wrapped it neatly yet, though
04:15:56 <merijn> Aruro: Also, try searching: https://hackage.haskell.org/packages/
04:16:17 <merijn> There appear to be several packages mentioning youtube SDK/API
04:17:23 <cocreature> https://hackage.haskell.org/package/gogol-youtube is probably worth a look
04:19:50 <jakub> hello, i have installed the system-wide dependencies of cabal with profiling enabled, I believe I have installed all dependencies of my project with profiling enabled, I believe I have installed my project (library) with profiling enabled, and now one of my tests missbehaves and I want to profile it, yet I seem to be unable to convince cabal to build the test with profiling, what can one do about it?
04:22:36 <merijn> jakub: Did you configure with profiling?
04:22:50 <merijn> jakub: i.e. run "cabal configure --enable-profiling" before building your tests
04:24:56 <jakub> merijn: I feel stupid now :), that seems to have worked
04:25:09 <merijn> jakub: First time for everything ;)
04:29:37 <jakub> merijn: does profiling account for exported functions only?
04:30:12 <merijn> jakub: Depends on what profiling options you used when compiling, afaik
05:28:15 <kahlil29> why can't I have two custom data types with the same inner attributes .. for e.g .  2 data types both with 'name' and 'id' . Program doesn't compile. but if i change the name then I have an issue with parsing the API response into my data type. 
05:29:47 <AWizzArd> I think the inner „attributes” are also functions.
05:30:23 <AWizzArd> When you define two records that share a name of (at least) one of their fields then the compiler will notice a conflict.
05:30:33 <opqdonut> kahlil29: you could try the DisambiguateRecordFields extension
05:30:46 <AWizzArd> kahlil29: what ghc version are you using?
05:30:47 <opqdonut> kahlil29: but you might just have to write custom deserialization for those types
05:30:58 <opqdonut> kahlil29: are you using aeson?
05:32:10 <opqdonut> kahlil29: if so, you can use a fieldLabelModifier to customize how json field names map to haskell field names
05:33:15 <kahlil29> yes i'm using Aeson 
05:33:50 <kahlil29> are you suggesting something like this : defaultToJSON defaultOptions{constructorTagModifier=(drop 2)} 
05:33:57 <kahlil29> in my data type definition?\
05:34:29 <opqdonut> yeah
05:35:51 <kahlil29> alright will try it out. thanks
05:39:20 <Phillemann> Hm, I just hit a "ghc panic" when using OverloadedStrings in default-extensions vs. on top of the file. Weird. o_O
05:40:29 <Phillemann> No, sorry, it's because of NoImplicitPrelude in default-extensions.
05:41:40 <kahlil29> any idea how exactly to use the constructorTagModifier for toJSON? Docs isn't helping me out much
05:42:23 <Phillemann> No, actually, import Prelude() is enough to trigger the ghc panic.
05:43:01 <opqdonut> kahlil29: sorry, never used it
05:43:36 <Marisa_> Hi, I am having trouble with hpc
05:44:00 <opqdonut> kahlil29: "genericToJSON customOptions" isn't working?
05:44:01 <erisco> what did hpc do this time?
05:44:16 <Marisa_> I tried doing stack build --coverage, and it report 'No tix file found in ...'
05:44:33 <Marisa_> What had I done wrong?
05:49:42 <kahlil29> opqdonut: trying it out but getting some compile errors 
05:49:48 <kahlil29> probably a silly mistake
05:52:14 <kahlil29> opqdonut:  instance ToJSON ProductionCompany where  toJSON = genericToJSON (defaultOptions {constructorTagModifier= Prelude.drop 2 })
05:52:19 <kahlil29> this is giving me two errors
05:52:24 <barrucadu> Marisa_: `stack build --coverage` gave that error?
05:52:32 <kahlil29> ‘toJSON’ is not a (visible) method of class ‘ToJSON’
05:52:34 <Marisa_> yes
05:52:38 <kahlil29> Not in scope: ‘constructorTagModifier’
05:52:57 <Marisa_> I cant find even a complete tutorial on using hpc with stack...sight
05:53:02 <erisco> once upon a time you just defined a data type and defined a function to convert from an intermediate JSON representation
05:54:27 <barrucadu> Marisa_: There's this, which I was able to follow to get working coverage: https://docs.haskellstack.org/en/stable/coverage/
05:54:45 <barrucadu> I put the commands here: https://github.com/barrucadu/dejafu/blob/master/CONTRIBUTING.markdown#test-coverage
05:55:31 <Marisa_> barrucadu, that is what I tried at zeroth
05:56:08 <Marisa_> But it is not helping... I will post the err message shortly after, so I thought I must be building it wrong
05:58:05 <Marisa_> Ooh, silly me
05:58:16 <Marisa_> I do stack clean && stack build && stack test --coverage
05:58:28 <Marisa_> stack clean && stack test --coverage is the right sequence
06:00:56 * hackagebot keystore 0.8.0.1 – Managing stores of secret things – https://hackage.haskell.org/package/keystore
06:31:00 <tesan> Excuse me... I'm trying to learn how to use Haskell's typesystem and made a trivial functions that just adds two numbers together, but with a type constraint... but I'm getting some error related to "expected one less"
06:31:32 <tesan> add :: Int a => a -> a -> a ; add a b = a + b     Where did I go wrong?
06:32:12 <ventonegro> :k Int
06:32:14 <lambdabot> *
06:33:36 <erisco> try Num
06:33:45 <merijn> Or Integral
06:34:02 <tesan> Yeah right... it gives me an error related to '*'.  So I guess I misunderstood the basics.  I thought "Int a =>" means "a in the following expression is of type Int"
06:34:10 <tesan> Num works but... why doesn't work Int?
06:34:33 <tesan> I wanted it to be restricted to non-floatingpoint arithmetic
06:34:34 <merijn> tesan: Num is a typeclass, Int is not
06:34:52 <merijn> tesan: Int is a specific type. Num is a typeclass (which described something about the types the function accepts)
06:35:00 <merijn> tesan: Integral is the typeclass for all integral types
06:35:53 <tesan> merijn: Ohh...  thank you very much. Now it all makes sense.
06:36:35 <merijn> tesan: The thing on the left of => should always be a constraint (the simplest and only one you'll regularly see as a beginner being a typeclass + typevariable combination)
06:37:19 <tesan> merijn: What is a specific type used in?
06:37:47 <merijn> tesan: I'm not sure I understand that question? :)
06:38:37 <tesan> merijn: What would 'Int' be used for?
06:39:13 <merijn> tesan: To specify type signatures involving, well, Int :)
06:39:52 <tesan> merijn: Thank you very much. :)
06:41:22 <kahlil29> toJSON = genericToJSON (defaultOptions {constructorTagModifier = Prelude.drop(Prelude.length "identity")} ) 
06:41:26 <kahlil29> gives me a Not in scope: ‘constructorTagModifier’ error
06:41:29 <kahlil29> why is this? 
06:41:38 <kahlil29> i'm following docs properly. 
06:42:04 <kahlil29> even if i replace the constructorTagModifier with fieldLabelModifier, it gives a Not in scope error
06:42:21 <erisco> what is the type of defaultOptions?
06:42:27 <mekeor> maybe you use a different version than the tutorial?
06:43:13 <phadej> probably you are missing some import (which I don't recall)
06:43:23 <phadej> Data.Aeson.Types would be my guess
06:43:53 <kahlil29> doesn't the generic import Data.Aeson take care of all the sub imports? 
06:45:21 <erisco> make a brand new file, import Data.Aeson, x = constructorTagModifier, load it in ghci and see what happens
06:45:22 <kahlil29> phadej, that worked. THANKS 
06:45:40 <kahlil29> imports are a bitch :| 
06:45:46 <kahlil29> thank you too, erisco
06:47:37 <erisco> well according to this, Options isn't even re-exported http://hackage.haskell.org/package/aeson-1.2.1.0/docs/src/Data-Aeson.html
06:47:57 <phadej> kahlil29: np
06:48:09 <erisco> I bet if you start a new ghci session, import Data.Aeson, :t defaultOptions, it will give a fully qualified name
06:48:27 <jchia_> stack haddock question: From some stack project directory using lts-9.1, I ran "stack haddock" followed by "stack hoogle generate --rebuild -- --local" so that I can run a hoogle server locally. This approach used to work at least for older resolvers, but now the "stack hoogle generate" complains about "Packages missing documentation". The packages it complains about are many and even include commonly-used packages like text and conduit
06:48:27 <jchia_> . Any idea how I can find out what exactly is wrong and debug the problem?
06:48:48 <erisco> seems strange to not also export the type of a definition you are exporting
06:50:01 <kahlil29> noob here, excuse the stupid errors
06:50:26 <erisco> I'm willing to say that is a mistake on the library authors
06:56:33 <mnoonan> erisco: I've seen that several times. Is there any reason you can think of not to make it a compiler warning if you export an identifier whose type references a non-exported type? It's pretty annoying..
06:58:14 <erisco> I would enable that flag
07:01:28 <mnoonan> I guess it could get gnarly.. e.g. if you have an exported "Maybe Foo", are you supposed to export Maybe?
07:02:21 <erisco> Prelude is an implicit import, so perhaps not
07:02:42 <erisco> but it wouldn't hurt
07:03:33 <jle`> people might be surprised to see Maybe re-exported by a seemingly unrelated import
07:04:29 <erisco> I am not thinking about that much because the first thing I do is import Prelude () and import explicitly thereon
07:04:56 <mnoonan> relevant discussion: https://mail.haskell.org/pipermail/libraries/2014-April/022793.html
07:07:38 <erisco> you have to get rid of (.) and id anyways, and if you're tinkering then you'll probably step on the toes of something
07:07:53 <erisco> like I wanted to give something else for +, *, and /
07:08:50 <erisco> and if you're publishing a package then it is more robust to version changes in dependencies
07:23:57 <bubu_> Hi! Where can I find any information about the `default` keyword below import statements? I was searching the GHC manual but all "default-related" things do not cover it
07:26:24 <jle`> bubu_: how about https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 ?
07:27:31 <erisco> I never heard of it
07:28:32 <jle`> default (X, Y, Z, A, B, C) lists types for ghc to try out when the type is ambiguous, in order of priority
07:28:41 <jle`> it's just for that module
07:29:19 <jle`> so if the type is ambiguous, ghc will try X, and if X doesn't fit, it'll try Y
07:29:54 <erisco> so the implicit default (Integer, Double) is why the Num ambiguities don't happen
07:30:13 <erisco> I thought it was a maybe a GHC thing
07:30:22 <jle`> i always used to think so too
07:32:57 * hackagebot listenbrainz-client 1.0.0 – A client library to the ListenBrainz project – https://hackage.haskell.org/package/listenbrainz-client
07:35:28 <merijn> erisco: They do happen, you even get warnings for them with -Wall :p
07:35:41 <merijn> It's just that it stays with a warning and not an error
07:36:54 <bubu_> jle`: interesting! Interesting evan more that I cannot find any word about it in GHC manual (latest version)
07:37:22 <jle`> bubu_: the ghc manual might just be about using GHC and about GHC extensions
07:37:44 <jle`> but it doesn'ta ctually describe Haskell itself
07:38:04 <jle`> like how the gcc manual is probably more about using gcc than about the C language spec
07:38:27 <bubu_> jle`: hmm, and can we create `default` declaration that is exported from module? Can I make it something bunlded with my library ?
07:38:54 <jle`> afaik default statements are only at the module level, for typechecking a module
07:39:01 <bubu_> jle`: right, I was just always sure that ghc manual covers almost everything 
07:40:18 <jle`> it might seem like everything, because ghc adds so much to haskell, heh
07:45:31 <np356> Hello ladies and gentlemen. My sister is sortof late on her masters thesis, that requires about ~80 filled survays left. Could you please help out? Its about "The impact of business analysis techniques on software quality": https://www.surveymonkey.com/r/W39T9TB
07:46:59 <jle`> not the right channel for that
08:08:27 <f-a> apparently cabal new-build (1.24) only rebuilds a module that has changed if is present in `other-modules:`
08:08:38 <f-a> is there a way to put an * in other-modules
08:09:09 <f-a> or to indicate I want to rebuild if any module has changed?
08:10:03 <merijn> f-a: You should list all modules in other-modules anyway, even without new-build
08:10:17 <merijn> f-a: Else it cabal gets confused even with old style builds
08:10:52 <f-a> merijn: I planned to do it, once I stop smudging modules :P
08:11:37 <brynedwards> hpack might be able to generate other-modules for you
08:11:44 <f-a> thanks
08:12:00 <nickolay> hello
08:12:06 <nickolay> is something like this possible? http://lpaste.net/357766
08:12:12 <nickolay> fails to compile..
08:14:18 <nickolay> I want to have a list of those "polymorhic type values"..
08:15:29 <eschnett> nickolay: “Var1” is not a type, it’s a constructor, i.e. a value. “Proxy MyType” would work.
08:17:03 <nickolay> eschnett: but you can say "typeValue = Proxy :: Proxy Var1" just fine
08:17:37 <nickolay> so in that sense Var1 is a type, of kind MyType
08:18:35 <Phillemann> I'm trying to build a program using gloss under NixOS and I'm getting the error: libGL error: unable to load driver: swrast_dri.so
08:18:45 <Phillemann> Is there anything I have to do to make it work?
08:18:52 <Phillemann> I tried using stack or plain nix package management.
08:19:42 <eschnett> nickolay: what is the error then?
08:24:38 <nickolay> eschnett: it says it can't match "a" with Var1
08:27:12 <nickolay> eschnett: updated the paste with error message
08:32:42 <eschnett> nickolay: i think your paste is mixed up, the error messages don’t match up with the code
08:34:16 <nickolay> eschnett: oh, you are right, fixed
08:35:14 <eschnett> nickolay: in this expression “Proxy :: Proxy Var1”
08:35:23 <eschnett> the first Proxy is a value (a constructor)
08:35:39 <eschnett> the second Proxy is a type constructor, and thus requires a type as argument
08:35:50 <eschnett> Val1 is a value constructor, not a type, hence the error
08:36:35 <eschnett> while MyType is a type, the two “branches” Val1 and Val2 are not types — they are only possible values
08:36:54 <eschnett> in C you woud write “enum MyType { Val1, Val2 };”
08:36:58 <nickolay> hm.. but with "DataKinds" or with "TypeInType" in this case, isn't every data constructor promoted to a type?
08:37:36 <eschnett> this can be done, but maybe not with the built-in “Proxy” type. that might be restricted to expect an actual type (didn’t check)
08:37:37 <nickolay> again, just: something = Proxy :: Proxy Var1 is find
08:37:41 <nickolay> *fine
08:38:12 <nickolay> and here Var1 is used in the type context
08:38:20 <eschnett> you mean, without the type declaration for type’?
08:38:52 <eschnett> if so — use ghci to write down this expression, then ask for its type.
08:39:13 <alex-edf> Hi
08:39:33 <nickolay> eschnett: good idea
08:39:46 <dsal> Is it possible to have a data constructor for a type that holds two Strings to have validation on the Strings it's supplied?
08:39:53 <c_wraith> nickolay, this error has nothing to do with DataKinds 
08:39:55 <alex-edf> What's the difference between 'let x = 1' and 'x = 1'?
08:40:14 <mud> alex-edf: In GHCI?
08:40:35 <c_wraith> nickolay, the error is that you are ascribing a polymorphic type to binding that isn't polymorphic 
08:40:48 <alex-edf> I'm testing in GHCI, but how does it matter?
08:40:53 <eschnett> nickolay: i see. the problem is that “Proxy Val1” and “Proxy Val2” are different types
08:41:13 <alex-edf> behaviour is different compiling from file?
08:41:41 <eschnett> nickolay: to help debug, define “data Type1” and “data Type2”, and then create a list that can hold elements of either type
08:41:51 <eschnett> that removes the DataKinds complication
08:41:52 <mud> alex-edf: Yes, behavior is different compiling a file. in GHCI, they're the same thing. Only  let x = 1 used to be allowed, but it eventually was determined that that was anonying.
08:41:55 <c_wraith> nickolay, this is the same error you get if you said "foo :: Maybe a ; foo = Just ()" 
08:42:26 <nickolay> eschnett: no, in that case Type1 and Type2 will be of different kinds or rather the same kind *
08:42:52 <jonge> hey there. i want to use System.Process to start a little "ssh foo@localhost -p 2222" command, enter the password via 'hPutStrLn process_stdin "mypassword"' and then read the output. but unfortunately, the ssh process just tells me three times that the password is wrong, although i only let it enter once. any ideas?
08:42:55 <alex-edf> mud: in regular Haskell, only 'let x = 1' allowed?
08:43:27 <c_wraith> nickolay, a polymorphic binding lets the *caller* choose what the type variables are, not the definition. the definition isn't allowed to make that choice 
08:44:01 <mud> alex-edf: Other way around. At the top level, x = 1      let x = 1   is part of do syntax, or let x = 1 in blah  is an expression (which can't be at the top level)
08:44:04 <eschnett> nickolay: “Proxy MyType” and “Proxy Val1” are different types
08:44:54 <nickolay> c_wraith: ok, this is usually can be handled with existential quantification
08:45:09 <nickolay> c_wraith: do you see how exactly in this case?
08:45:09 <eschnett> if you declare the type as “type’ :: Proxy Val1”, it should work
08:45:25 <nickolay> eschnett: right
08:45:39 <nickolay> eschnett: but I want to make a list of such values
08:45:59 <mud> alex-edf: By the way, I'd strongly recommend you don't do too much defining things in ghci itself. You should mostly write definitions in a .hs file and :load them to play with. (can :reload when you change the file)
08:46:01 <c_wraith> nickolay, the exact same way as normal. create a monomorphic data type to hide the type variable 
08:46:14 <dsal> Looks like you just have to not export the standard constructor.
08:46:29 <eschnett> nickolay: yes, you want to hold both the types “Proxy Val1” and “Proxy Val2” in one list
08:47:13 <alex-edf> mud: Thanks for the tips
08:47:19 <eschnett> nickolay: thus i suggested to create a list for the two types “Type1” and “Type2”, since this is conceptually simpler
08:49:06 <c_wraith> nickolay, but using an existential to create a heterogeneous structure is usually a bad call, unless you have some way to recover the types, like a GADT or a Typeable constraint 
08:49:55 <alex-edf> I'm totally newb to Haskell, but is it kind of Lisp with syntastic sugar for `function` and (operator) (for explicit function placed first)
08:50:23 <alex-edf> (+) 1 2 or 1 `add` 2
08:50:24 <mud> alex-edf: It's quite a bit more different than that
08:50:25 <c_wraith> alex-edf, not really. the different evaluation model makes things a lot different in practice. 
08:50:31 <alex-edf> mud: ouki
08:51:01 <nickolay> c_wraith: I see, ok
08:51:14 <nickolay> eschnett: c_wraith: thanks for the help!
08:51:36 <mud> And the type system stuff makes it feel *way* different from a lisp to me. And the syntax I suppose.
08:52:09 <c_wraith> alex-edf, also the pervasive inescapable typing. you can learn a lot about the behavior of value from its type, because types aren't just advisory. they are enforced at multiple levels. 
08:53:10 <eschnett> nickolay: i didn’t see at first where you got stuck. i hope i wasn’t too confusing.
08:53:30 <eschnett> nickolay: (i’d use “type ListElement = Either (Proxy Val1) (Proxy Val2)”)
08:54:59 <nickolay> eschnett: I'll be digging, thanks for suggestion
08:57:44 <norc_> How is "right" and "left" to be understood in foldl and foldr?
08:58:05 <norc_> As in "fold from right/left" ?
08:59:26 <eschnett> norc_: as in “(a <> b) <> c” vs. “a <> (b <> c)”
08:59:42 <eschnett> norc_: yes
08:59:56 <nickolay> c_wraith: wrapping with monomorphic type helped, thanks!
09:00:10 <nickolay> data SomeTypeValue = forall (a :: MyType) . SomeTypeValue (Proxy a)
09:00:50 <c_wraith> norc_, well, no. both fold from left to right. it's how they associate the binary function that changes 
09:01:33 <norc_> c_wraith: Ah, that sounds more intuitive.
09:01:40 <c_wraith> norc_, since lists are singly-linked, there is only one direction you can traverse them. :) 
09:02:22 <eschnett> i’d say that foldr first recurses to the end of the list, then folds on the way back out
09:02:33 <eschnett> so in a sense, it folds from right to left
09:02:35 <c_wraith> eschnett, that's notably untrue in Haskell 
09:02:48 <mud> eschnett: That can't be a good description, otherwise it would never work on infinite lists (it usually does)
09:02:48 <eschnett> c_wraith: good point.
09:02:51 <c_wraith> eschnett, it might be true in other languages, though. 
09:03:09 <nickolay> c_wraith: but why is that additional box is required ?
09:03:44 <nickolay> the type of "SomeTypeValue" is essentially the same I gave to "listOfValues"
09:04:21 <c_wraith> nickolay, the difference is that it doesn't have a type variable I  the type. 
09:04:27 <nickolay> type' :: forall (a :: MyType). Proxy a
09:04:27 <c_wraith> *in
09:05:38 <nickolay> type' :: forall (a :: MyType). Proxy a   <====>  data SomeTypeValue = forall (a :: MyType) . SomeTypeValue (Proxy a)
09:06:49 <c_wraith> nickolay, the difference is that the type variable is externally visible in one, but not the other 
09:08:01 <c_wraith> nickolay, also, if you work much with that type, you'll discover it's basically useless. you have no way of distinguishing between different types used to create a SomeTypeValue
09:08:35 <norc_> Is there some convention behind the single quote in names? My instinct says it's origin lies in math to denote a new value that is related to another
09:09:14 <c_wraith> norc_, that's exactly it. think f and f' (pronounced "f prime") in calculus 
09:09:17 <tdammers> norc_: yes, and that's pretty much all there is to it. sometimes the single quote (pronounced "prime") denotes an updated value
09:09:30 <nickolay> c_wraith: ah, I see, so this box provides sort of a "guarantee" that the "a" variable could not be used outside of it?
09:09:39 <c_wraith> nickolay, exactly 
09:09:52 <tdammers> norc_: think of x' as "x updated", or "new x", or "something derived from x"
09:10:00 <nickolay> c_wraith: but inside that box, it can be used?
09:10:08 <[exa]> norc_: luckily we can't go to carets/arrows/hooks and other weirdness above characters as actual mathematicians can :D
09:10:22 <c_wraith> nickolay, I'm not sure what your goal is, but I'm sure that type doesn't help you. :) 
09:10:35 <nickolay> c_wraith: well, a bit more clear now..
09:10:39 <mud> [exa]: Wellll, we probably could. They probably exist in unicode :-/
09:10:43 <nickolay> c_wraith: ok, I'll keep digging :))
09:11:02 <c_wraith> nickolay, well, there's really nothing you can do inside the box. it's just a constructor. it doesn't do anything else. 
09:11:28 <norc_> tdammers: Yeah. My initial instinct was something along the lines of: transform' = fmap transform
09:13:17 <[exa]> mud: oh you! :D
09:13:34 <norc_> Oh! Identifiers accept any unicode character?
09:13:58 <mud> Mostly, something like the "symbols" part
09:14:58 <norc_> Well. That should help me properly implement this cryptographic scheme that uses all these greek letters!
09:15:01 <norc_> :-)
09:15:06 <mnoonan> norc_: of course, there are other "uses": http://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
09:15:17 <mud> norc_: Yay
09:15:25 <norc_> Why don't we have (λ x - > x) though with unicode?
09:15:37 <c_wraith> norc_, there's an extension for that 
09:15:47 <c_wraith> I believe it's called UnicodeSyntax
09:15:50 <mud> https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
09:16:09 <norc_> Wow. Im looking forward for more details on that. Gotta run catch the train. Thank you so far :)
09:20:28 <dsal> Can anyone give me a hand writing a simple generator for quickcheck?  My type consists of two strings and I want to generate two strings to fill it.  I've got a character set from which I want the strings to be populated.  Ideally, I'll also have some basic form/length stuff.
09:32:20 * hackagebot newtype-generics 0.5.1 – A typeclass and set of functions for working with newtypes, with generics… – https://hackage.haskell.org/package/newtype-generics
09:34:52 <Garreett> hello is anyone familiar with parsec/megaparsec here?
09:35:33 <cocreature> Garreett: lots of people are. just ask your question directly and stick around for a bit to give people time to answer
09:37:35 <Garreett> Ah okay thanks wasn't sure if was commonly used! I have been using parseTest to test my parsers on strings. Is it possible to create function parse :: String -> Stmt instead? I am not too sure how to do this..
09:42:38 <cocreature> Garreett: what do you expect to happen if there is a parse error?
09:44:13 <Garreett> cocreature: would the parser not just give an error in that case?
09:44:28 <cocreature> Garreett: but your type signature doesn’t include the potential for errors
09:44:38 <cocreature> "Stmt" can’t be an error
09:45:28 <cocreature> Garreett: if you use "runParser" https://hackage.haskell.org/package/megaparsec-6.1.1/docs/Text-Megaparsec.html#v:runParser you’ll get back an "Either err Stmt" for some error type "err"
09:46:28 * hackagebot snap 1.0.0.2 – Top-level package for the Snap Web Framework – https://hackage.haskell.org/package/snap
09:48:05 <remexre> Actually, on the topic of Parsec, I'm trying to run a Parsec parser off the output of another (which serves as a lexer). How does one typically implement nextPos (The second argument to tokenPrim) in that case?
09:48:53 <Garreett> cocreature: does this differ to using "parse"? The types of ":t parse p stmt" and ":t runParser p stmt" seem to be the same
09:52:29 <sm> Garreett: if the type signature doesn't explicitly support errors, it probably calls the "error" function, which is considered a code smell except in throwaway scripts
09:52:41 <sm> as it terminates your program
09:55:18 <Garreett> Ah I see thanks
10:03:02 <amf> has anyone compiled a cheat sheet of advanced haskell features and when / how to use them?
10:06:21 <dminuoso> Is there a way to describe that a given binary operation must commute?
10:06:47 <cocreature> Garreett: runParser and parse are just two names for the same thing afaik
10:07:11 <sm> amf: there are so many, I don't think one cheat sheet covers them all. For typeclasses, eg, you should check out the typeclassopedia
10:07:36 <nickolay> amf: check this one: http://dev.stephendiehl.com/hask/#changelog
10:07:41 <sm> and, you know, search for haskell cheatsheet to find the rest :)
10:07:48 <mnoonan> https://ocharles.org.uk/blog/posts/2014-12-01-24-days-of-ghc-extensions.html might be useful, though not in cheatsheet form
10:08:39 <amf> totally forgot about sdiehls page! thanks!!
10:08:51 <sm> huh, maybe sdiehls does cover them all :)
10:25:00 <dsal> It seems I can't have have an Arbitrary instance of my class that I can use in tests and also not export the default constructor.  Is this true?
10:25:34 <johnw> not entirely true
10:25:44 <dsal> It may just be that I didn't export the type.
10:25:47 <johnw> you can export the class from an Internal module that the tests can import
10:26:21 <dsal> Yeah, I think I didn't export the class when I changed to a smart constructor and just didn't notice because my tests all passed.
10:32:29 <dsal> OK, this is kind of dumb, but does it even make sense to try to use quickcheck and hunit together?  I can't find any examples of this, and they don't seem to get along naturally.
10:32:58 <remexre> dsal: Look at test-framework
10:33:16 <remexre> (and test-framework-hunit and test-framework-quickcheck2)
10:34:16 * hackagebot master-plan 0.3.0 – The project management tool for hackers – https://hackage.haskell.org/package/master-plan
10:34:24 <dsal> Hmm...  OK, thanks.
10:56:45 <tdammers> or, alternatively, tasty
10:56:59 <tdammers> (and tasty-hunit and tasty-quickcheck, obv)
11:02:46 <Heffalump> some types have been made abstract in Cabal 2.0.0 and replaced with accessors that were only introduced in 2.0. I have a Setup.hs that needs them - is there any way short of Template Haskell to manage the transition?
11:04:22 * hackagebot rdf 0.1.0.2 – Representation and Incremental Processing of RDF Data – https://hackage.haskell.org/package/rdf
11:05:52 <dsal> I've managed to get through a combination of hunit and quickcheck successfully.  The tests weren't 100% convertable since my functions weren't assertions, but the results seem fine.
11:06:10 <dsal> Would be nice if it didn't try to colorize when running in emacs (or emacs handled the color correctly)
11:10:29 <sm> dsal: does M-x ansi-color-for-comint-mode-on help ?
11:10:36 <raynold> ahh it's a wonderful day :D
11:11:30 <dsal> sm: Don't think so...  I may be doing this wrong.  :)  I'm just running M-x compile with "stack test"
11:11:51 <sm> ah, right
11:12:12 <shapr> Heffalump: wow, long time no see!
11:12:17 <sm> yes it's wrong of it to try using color in that situation
11:23:30 <dsal> Last night I was wondering why maybe had the extra param that seemed to always  (in my one case) require id.  Today I needed this:   byName hdr field = maybe (\_ -> "") (\n r -> r V.! n) $ V.elemIndex field hdr
11:25:29 <mnoonan> dsal: there is also fromMaybe, if you just want to provide a default for the Nothing case
11:26:28 <dsal> Ah, so fromMaybe is basically what I thought maybe was.
11:44:57 <dsal> Is there a way to get this test-framework quickcheck thing to run in verbose mode?  I induced a failure and it just told me that something failed.
11:46:11 <texasmynsted> From my home directory (not in a project) I ran "stack upgrade" and upgraded.  I can run "hlint --version" or "stack exec hlint -- --version" and get v1.9.12
11:46:20 <texasmynsted> I think that is rather old though right?
11:46:55 <texasmynsted> iirc hlint is up to 2.0.9 release
11:48:50 <dsal> stack makes this extra difficult -- 'stack ghci' doesn't give me my tests.  And I can't load them because all the modules they need are hidden.
11:49:18 <shapr> dsal: do you have a test stanza?
11:49:46 <dsal> I'm not sure.  I have a working test suite.  It just fails with insufficient information.
11:49:50 <shapr> huh?
11:49:56 <shapr> are you using "stack test" ?
11:49:59 <dsal> Yeah
11:50:22 <dsal> It tells me one of my tests failed.  It's using quickcheck (via test-framework), but it doesn't tell me what input it failed on.
11:50:30 <shapr> huh, that's odd
11:50:40 <shapr> I'm using hspec in a current project and it does that: https://github.com/shapr/schrabble/blob/master/test/Spec.hs
11:50:48 <mnoonan> ++hspec
11:51:08 <mnoonan> (it's built on top of hunit, so you won't lose anything by using it)
11:52:08 <shapr> I use "stack test --file-watch" so my tests run whenever I save the file
11:52:15 <dsal> Oh neat.
11:52:46 <shapr> although intero complains early/often enough that compiler errors are rare for me
11:52:50 <dsal> I'm doubly curious on this test thing because I'm not totally sure my arbitrary is good enough.
11:53:06 <shapr> ooh, what's your arbitrary code look like?
11:53:07 <sm> stack ghci [PKG]:test[:suitename] or similar loads the tests
11:53:21 <shapr> bah, I don't really have enough spare cycles to help with an Arbitrary instance
11:54:12 <dsal> I've mostly figured it out, but I can't see what it does anymore because I've not figured out how to interact with the test code.
11:55:17 <texasmynsted> can anybody see my questions?  After the spam issue on freenode yesterday I am not sure if my messages are visible
11:55:27 <shapr> texasmynsted: roger, we are recving you
11:55:34 <shapr> texasmynsted: you are go for question
11:55:37 <texasmynsted> ok
11:55:39 <texasmynsted> LOL
11:55:42 <shapr> :-)
11:55:57 <texasmynsted> From my home directory (not in a project) I ran "stack upgrade" and upgraded.  I can run "hlint --version" or "stack exec hlint -- --version" and get v1.9.12
11:56:14 <shapr> dsal: if you're still having problems with quickcheck on Saturday, I'll be online to help out
11:56:34 <dsal> Oh hey, I figured out how to load it.  woo
11:56:35 <texasmynsted> I think that is too old for me to be able to do hlint --default > ~/.hlint.yaml to add custom criteria to hlint.
11:56:35 <shapr> or for non-QC questions, for that matter
11:56:38 <shapr> dsal: w00!
11:56:43 <texasmynsted> non-QC?
11:56:58 <shapr> non-quickcheck questions
11:57:18 <shapr> texasmynsted: sorry, QuickCheck is often shortened to QC in Haskell talks
11:57:32 <shapr> although I do read Questionable Content every weekday, in case that was your confusion
11:57:55 <dsal> Well, verboseCheck doesn't show me the bad input, either.  It shows me the good input, though, so I guess that's nice.
11:58:22 <shapr> texasmynsted: what resolver is listed in your ~/.stack/global-project/stack.yaml ? I have lts-9.0
11:58:59 <texasmynsted> lts-8.16
11:59:13 <sm> texasmynsted: stack upgrade only upgrades stack. Try stack install hlint
11:59:30 <texasmynsted> ok, but hlint is already installed.
11:59:32 <texasmynsted> trying 
12:00:28 <shapr> texasmynsted: looks like lts-8.16 has hlint 1.9.41, with lts-9.0 I have hlint 2.0.9
12:00:36 <sm> install is also upgrades. And also you may need to mention a specific hlint version if it's not in the stack resolver, as shapr says
12:01:00 <shapr> texasmynsted: if you don't have a special reason to stick with lts-8.16, change it to lts-9.0 and then stack install hlint ?
12:01:59 <texasmynsted> ok
12:02:03 <texasmynsted> thank you
12:02:32 <texasmynsted> it is still installing....
12:05:12 <shapr> I got really tired of compiling large Haskell projects on my Intel i3 laptop with 16gb of ram
12:06:06 <shapr> my new quad-core Xeon with 64gb is AMAZING! and I can use 10% of the battery in 10 minutes if I compile a bunch of stuff :-(
12:07:07 <k0ral> Hello
12:07:28 <SuViVoR> hii guys!
12:08:47 <k0ral> I need to design an open data type `OpenType a = OpenType Field1 Field2 (Fields a)`, how would you suggest I implement that ? is there any library abstracting over this pattern ?
12:09:48 <k0ral> (in my example above, `a` should be an open union of singletons)
12:10:12 <texasmynsted> shapr: so if I have no reason to stick with an older version of haskell (not sure exactly what lts is), should I be regularly updating the lts version in this file?
12:10:22 <texasmynsted> How do I know what to upgrade it to?
12:11:01 <shapr> texasmynsted: you can change the value for each project, so I use the latest as long as it builds the things I want
12:12:46 <texasmynsted> Also on this machine I see a ~/Library/Haskell/ directory with a version of hlint.  I do not recall how that got there (mac os).
12:13:07 <texasmynsted> anybody recognise it?
12:13:14 * shapr shrugs
12:22:20 <geekosaur> texasmynsted, that's the old haskell platform for macos
12:22:45 <geekosaur> (maybe also current ones, I haven't checked since they redid H-P)
12:22:49 <dminuoso> Okay this is getting scary. So I have been using monads for a real while already, without even knowing..
12:23:10 <dminuoso> Seems like the usual Promise interface in JavaScript is very monadic. :o
12:31:17 <EvanR> dminuoso: it uses callbacks yes, which makes it like a lazy data structure
12:31:26 <EvanR> with functions in it
12:31:52 <EvanR> not all such things are monadic
12:37:54 <texasmynsted> Thanks geekosaur, now I just need to see how to remove the Haskell platform so I can use stack only.
12:37:56 <texasmynsted> heh
12:38:58 <texasmynsted> ah, think I found it
12:42:58 <Tuplanolla> Is there a package that tries to capture the complete mess of algebraic structures (not just the useful ones) from magmas to inner product spaces?
12:44:28 <dolio> You can present promises as a monad.
12:44:52 <dolio> And lots of JS stuff is continuation passing, which can also be presented as a monad.
12:54:13 <texasmynsted> https://wiki.haskell.org/Monad_laws
13:12:20 <jared-w> Tuplanolla: hmm... I don't know. Perhaps the numeric prelude or one of those sorts of projects?
13:12:44 <Tuplanolla> SubHask goes quite far, but not as far as possible, jared-w.
13:14:30 <dsal> Figured out why my qc wasn't printing bad input... I had made my generator generate invalid input.  That's fair.
13:18:01 <Tuplanolla> While wondering why hpc is such suffering, I built this prototype that emulates parametric polymorphism in C sans `malloc`. Unfortunately it's extremely unwieldy to use, so I thought maybe I should explore extracting it from a Haskell dsl. This is the context, jared-w.
13:18:36 <jared-w> hpc == high performance computing?
13:18:40 <Tuplanolla> Yes.
13:19:26 <jared-w> hpc is suffering because life is suffering :p
13:19:34 <Tuplanolla> Great insight.
13:19:37 <johnw> at least he suffers quickly
13:20:44 <jared-w> But for real, you'll have luck asking edwardk about his deep embedding to GPU he wrote in Haskell, I think. You might be able to write something up like that which will allow you to write efficient and type-safe GPU MIMD/SIMD programs for certain things? Then you can start wrapping that up into nicer and larger boxes
13:22:21 <k0ral> looking at Data.Extensible.Product from the extensible package, what is `h` supposed to be in `data h :* s` ? Documentation shows that `h :: k -> *` but that doesn't help me
13:22:26 <Tuplanolla> I don't have the time and dedication to build anything that elaborate, jared-w.
13:22:53 <jared-w> Fair. Most people don't lol
13:23:53 <SuViVoR> somebody give me the link of blue whale please,thankyou!
13:24:06 <jared-w> I don't know of anything more comprehensive than SubHask for algebraic structures, though
13:24:14 <Tuplanolla> It would also be good if my colleagues (physicists) could understand the end result.
13:24:30 <Tuplanolla> Fat chance, but a man can dream.
13:25:06 <jared-w> Make sure to use too many semicolons, absolutely no white space, comments, or any variables more than 1 letter
13:25:31 <SuViVoR> yo bitchs!
13:25:38 --- mode: ChanServ set +o johnw
13:25:43 --- mode: ChanServ set +o johnw
13:25:44 --- mode: johnw set +b *!~androirc@203.192.219.83
13:25:44 --- kick: SuViVoR was kicked by johnw (Kicked)
13:25:44 --- mode: johnw set -o johnw
13:30:12 <jared-w> rekt
13:34:41 <infandum`> How is this possible: https://pastebin.com/Hw9Ley9v
13:34:46 <infandum`> It says "level" right there!
13:35:01 <infandum`> If I replace "level" with "sample" it works, but not with "level"
13:35:31 <geekosaur> show code
13:35:46 <geekosaur> it sees a name, from context it knows what type it should have, but there is no such binding
13:39:19 <geekosaur> or are you confusing the type level string with the type? if so, and since I see a "sample" type level string there as well, perhaps you are missing something that relates the two, which exists for "sample"
13:40:12 <infandum`> geekosaur: Here is the atomic example: https://pastebin.com/urFLbcwJ
13:40:45 <infandum`> geekosaur: I was using quotes to specify that's what I put in. I did not have quotes in the code.
13:44:22 <infandum`> geekosaur: When I print the head of that list, I get {level :-> "Yes", sample :-> "blah" ...
13:44:36 <infandum`> So it seems to know that "level" exists in these records
13:44:51 <Tuplanolla> Man, it doesn't help that modules for programming languages have nothing to do with modules over rings.
13:45:29 <geekosaur> I haven't worked with Vinyl so I don't know how type level lists get reflected into bindings at value level. I suspect it involves some TH glue
13:45:38 <infandum`> geekosaur: It does.
13:45:55 <infandum`> For some reason, a simpler example works in GHCI
13:46:00 <infandum`> (it detects level)
13:46:35 <infandum`> but here it's only level that it doesn't detect. It's using stack exec runghc, though
13:46:41 <infandum`> so it's a little different
13:47:15 <dsal> So, readsPrec -- I observe that any "leftover" input causes a parse error.  Is this expected?
14:02:31 <jle`> yes
14:02:49 <dsal> Hmm...  OK.  I guess that's good.
14:03:21 <dsal> I didn't get that from the docs.  I just assumed it'd let me read the next item from a stream or something.
14:05:57 <dminuoso> Is there a quick way to see how a given code associates in GHCi? Perhaps something that just adds parens in the right places?
14:06:27 <Tuplanolla> You can use `TemplateHaskell` to get the syntax tree, dminuoso.
14:07:04 <dminuoso> Tuplanolla, uh!
14:07:28 <Tuplanolla> It's not that bad, dminuoso. Just `import Language.Haskell.TH` and then `runQ [| x <> y <> z |]`.
14:07:28 <dsal> Is there a more sensible way to do this:     ctoi c = (toEnum . fromEnum) c ::Int16 
14:07:49 <jle`> ctoi = toEnum . fromEnum     ...?
14:07:51 <jle`> with a type signature
14:07:59 <jle`> or ctoi = toEnum @_ @Int16 . fromEnum
14:08:03 <dsal> Oh, like a separate one.  This is in a let...  Can I do that?
14:08:09 <dminuoso> Tuplanolla, does this require a specific GHC version to work?
14:08:30 <dsal> Oh, I can do that.  Neat.
14:08:31 <Tuplanolla> It should even work on 6-series, dminuoso.
14:08:43 <jle`> you can give type signatures for things in lets
14:08:52 <jle`> let ctoi :: Int -> Int16
14:08:54 <dsal> I just assumed I couldn't.  Neat.
14:08:57 <jle`>     ctoi = toEnum . fromEnum
14:09:02 <dsal> Though it now takes up more vertical space.  heh
14:09:46 <jle`> if you want to one-line it, ctoi = toEnnum . fromEnum :: Int -> Int16
14:09:55 <jle`> or these days i like the type applications way wit @Int16
14:11:04 <dsal> Oh, I stumbled upon that syntax earlier and didn't realize that's what I'd typed. heh
14:11:11 <dsal> I have this in a test:  
14:11:18 <dsal> prop_roundtrips x = (read $ show x) == x
14:11:31 <dminuoso> Tuplanolla, oh I also had to :set -XTemplateHaskell :)
14:11:51 <dsal> Then I was testing my type with:      testProperty "address round trips" (prop_roundtrips :: Address -> Bool)
14:13:44 <dsal> shiftL's arguments are backwards.  boo
14:14:59 <jle`> dsal: actually i think reasPrec does give leftovers
14:15:15 <dsal> It asks for leftovers, but if I provide any, stuff blows up.
14:15:34 <dsal> ERROR: Prelude.read: no parse
14:15:46 <dsal> (returning "x" instead of my computed leftovers)
14:15:53 <jle`> > readsPrec 1 "1     " :: [(Int, String)]
14:15:53 <dminuoso> Can someone help me out why exactly `fmap f x = x >>= return . f` ?
14:15:55 <lambdabot>  [(1,"     ")]
14:16:08 <jle`> dminuoso: try convincing yourself it's true for monads like Maybe
14:16:48 <dsal> Weird...
14:16:51 <dminuoso> jle`, Ive been drawing arrows all over the place, haven't though of that. :-)
14:17:01 <jle`> it won't tell you "why" at a deep level
14:17:11 <jle`> but it'll make you feel it, i suppose
14:18:04 <dsal> OK.  Mine does it, too.
14:18:26 <dsal> So, my read does the right thing interactively, but my test fails.
14:19:09 <dsal> Well, sometimes it does.  Space doesn't seem to bother it.
14:19:41 <dsal> > readsPrec 1 "KG6HWF-9 garbage    " :: [(Address, String)]      -->   [(KG6HWF-9," garbage    ")]
14:19:43 <lambdabot>  error:
14:19:43 <lambdabot>      Not in scope: type constructor or class ‘-->’error:
14:19:43 <lambdabot>      Not in scope: type constructor or class ‘Address’error:
14:19:58 <dsal> > read "KG6HWF-9 garbage    " ::Address   -->  *** Exception: Prelude.read: no parse
14:20:01 <lambdabot>  <hint>:1:61: error: parse error on input ‘Prelude.read’
14:20:15 <geekosaur> you need a space after tje -- for it to be a comment
14:20:23 <geekosaur> (or at least a non-operator character)
14:20:33 <dsal> Er, that was just the "I don't want to paste two lines" operator
14:21:26 <dsal> My readsPrec does what I expect, and my read does what I expect with good input.  The former does what I expect with bad input and the latter fails with (some) bad input.
14:21:36 <jle`> yeah read will reject leftovers
14:21:38 <jle`> readsPrec won't
14:21:47 <jle`> readsPrec is meant to be used as a parser combinator
14:21:56 <jle`> so you can like chain two readsPrecs together
14:22:19 <dsal> OK.  So my readsPrec is right, but read doesn't do exactly what I thought.
14:22:24 <dminuoso> jle`, oh it just hit me. Reordering the arguments made it so obvious
14:22:33 <cheater> is there a function f :: [a] -> [b] -> [(a, b)] that'll give me all possible pairs where fst is from the first argument and snd from the second argument?
14:23:09 <texasmynsted> shapr: and others.  Thank you.  :-)
14:23:14 <dminuoso> jle`, fmap and bind are almost the same thing, except bind "lifts" the final result into the structure, so the composition of the transformation passed to fmap with return does that!
14:23:42 <jle`> > flip evalStateT "1True" $ (,) <$> StateT (readsPrec 0) <*> StateT (readsPrec 0) :: [(Int, Bool)]
14:23:43 <jle`> 3
14:23:44 <lambdabot>  [(1,True)]
14:23:54 <jle`> ^ dsal 
14:24:02 <jle`> dminuoso: yeah :)
14:24:06 <dminuoso> jle`, now the one thing that I cant see based on types, is this guaranteed to preserve the same semantics? typewise it looks good, but semantically?
14:24:20 <boj> :t zip
14:24:21 <lambdabot> [a] -> [b] -> [(a, b)]
14:24:35 <jle`> dminuoso: well
14:24:38 <jle`> i believe it's actually a monad law
14:24:55 <sqooq> I need to do something zipWith, but not with 2 lists.
14:24:55 <boj> cheater: is that what you want?
14:25:02 <sqooq> something like zipWith**
14:25:25 <dsal> jle`: Oh, flip is the "that function has the arguments in the wrong order" tool?
14:25:42 <jle`> dminuoso: as in, >>= has to be defined in a way that fmap means what you say it means
14:25:43 <sqooq> The type is an instance of Functor, Foldable, and Traversable
14:25:50 <jle`> dsal: yes, heh.  don't worry if you haven't seen it with State
14:26:13 <jle`> it was just to demonstrate that the point of readsPrec was to chain the reading on the successive leftovers
14:26:24 <jle`> sqooq: what is your type
14:26:39 <cheater> boj: no. zip will pair the elements in sequence. i want all pairs.
14:26:53 <dsal> Yeah, that makes sense.  I'd seen flip, but didn't look at it.  It's almost an answer to my complaint about shiftL having its args in the wrong order.
14:27:11 <cheater> boj: so f [1, 2] [3, 4] = [(1, 3), (1, 4), (2, 3), (2, 4)]
14:27:20 <cheater> i'm looking for an f like that
14:27:30 <cheater> it's like a cartesian product or something like that.
14:27:40 <filthy_causual2_> @pl \ f g x = f x *> pure (g x) 
14:27:40 <lambdabot> (line 1, column 9):
14:27:40 <lambdabot> unexpected "="
14:27:40 <lambdabot> expecting pattern or "->"
14:27:46 <filthy_causual2_> @pl \ f g x -> f x *> pure (g x) 
14:27:47 <lambdabot> (. (pure .)) . liftM2 (*>)
14:27:50 <dsal> Actually, yeah, it feels a little cleaner to use    flip shiftL 8   than  (\x -> shiftL x 8)
14:27:51 <jle`> cheater: sounds like just liftA2 (,)
14:28:02 <cheater> oh yea
14:28:11 <jle`> or (,) <$> xs <*> ys
14:28:14 <jle`> or sequence [xs, ys]
14:28:19 <cheater> i just figured out it's a cartesian product and googled that and stumbled upon this: https://stackoverflow.com/questions/4119730/cartesian-product-of-2-lists-in-haskell
14:28:28 <cheater> :t sequence
14:28:30 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:28:47 <cheater> > sequence [[1, 2], [3, 4]]
14:28:50 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:28:55 <jle`> sequence is like a liftAN
14:29:07 <jle`> > liftA2 (,) [1,2] [3,4]
14:29:10 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
14:29:10 <cheater> > sequence ([1, 2], [3, 4])
14:29:13 <lambdabot>  [([1,2],3),([1,2],4)]
14:29:16 <jle`> > liftA3 (,,) [1,2] [3,4] [5,6]
14:29:18 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
14:29:25 <jle`> > liftA4 (,,,) [1,2] [3,4] [5,6] [7,8]
14:29:28 <lambdabot>  error:
14:29:28 <lambdabot>      • Variable not in scope:
14:29:28 <lambdabot>          liftA4
14:29:33 <jle`> > sequence [[1,2],[3,4],[5,6],[7,8]]
14:29:35 <lambdabot>  [[1,3,5,7],[1,3,5,8],[1,3,6,7],[1,3,6,8],[1,4,5,7],[1,4,5,8],[1,4,6,7],[1,4,...
14:29:35 <sqooq> jle` https://hackage.haskell.org/package/temporal-media-0.6.1/docs/Temporal-Media.html
14:29:35 <cheater> sequence is seemingly not what i'm looking for. But lift* and <$> .. <*> are
14:29:40 <sqooq> `Track`
14:29:48 <filthy_causual2_> Well notice that liftAN gives tuples, and sequence gives lists.
14:29:52 <cheater> yep
14:30:02 <cheater> those are really good tips
14:30:05 <jle`> yeah, sequence does it with arbitrary lengths by stuffing them into lists
14:30:06 <dminuoso> jle`, huh! "Monads are just monoids in the category of endofunctors" -> Could this is implied in this definition?
14:30:11 <cheater> i don't even have to import lift, i can just use <$> and <*>
14:30:13 <jle`> but liftA2 (,) would work with just tuples
14:30:28 <jle`> dminuoso: that definition isn't strong enough
14:30:33 <jle`> because there are many monoids in the category of endofunctors
14:30:38 <sqooq> I need to just take a simple list of numbers, and within track there are type `Single a` that fmap applies functions too, I just want to replace those a's with my numbers in turn. 1st number to first Single, 2nd number to second Single, etc.
14:30:39 <jle`> not just monads
14:31:02 <filthy_causual2_> No monads are exactly the monoids in the category of endofunctors.
14:31:41 <filthy_causual2_> "Monad" is specialized to the category of endofunctors _on_ Haskell types.
14:32:32 <jle`> Applicatives are also a monoid in the category of endofunctors
14:32:44 <jle`> but just with a different monoidal operation
14:32:59 <dminuoso> jle`, which just does not follow the monad laws as far as I can tell, right?
14:33:32 <dminuoso> the monad laws dont seem strong enough to guarantee that fmap f x and x >>= return . f maintain the same semantics thoguh
14:34:05 <filthy_causual2_> Thats because thats the law for Functor.
14:34:11 <jle`> filthy_causual2_: see http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad.html#t:Monad
14:34:26 <jle`> sorry, that was meant for dminuoso 
14:34:53 <filthy_causual2_> jle' Dont you have to change composition in the endofunctor category to get aplicative?
14:35:18 <filthy_causual2_> I mean the monad laws are literly the monoid laws lifted to the right kind.
14:36:01 <jle`> https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/clws90h/?utm_content=permalink&utm_medium=front&utm_source=reddit&utm_name=haskell
14:36:24 <cheater> why does liftAn exist if you could just repeat <*> over and over?
14:36:40 <hpc> jared-w: who you calling suffering :P
14:37:11 <jle`> cheater: different styles
14:37:15 <jared-w> hpc: lol Tuplanolla was talking about high performance computing and I said that the reason it was difficult is because high performance computing is suffering :p
14:37:20 <jle`> cheater: also liftA2 plays nicer with partial application
14:37:32 <dminuoso> cheater, according to the haskell documentation liftA2 has potentially more efficient implementations
14:37:32 <jle`> if you want to partially apply 'liftA2 f'
14:37:52 <jle`> it's not easy with <*>/<$> style
14:38:16 <jared-w> dminuoso: That being said, I don't think very many people actually write potentially more efficient implementations of liftA2 :p
14:41:33 <filthy_causual2_> jle` interesting, I didn't think of using a different tensor(?). Is that the right way to describe what (,) and Day Convolution both are?
14:41:43 <cheater> > (,) <$> [1, 2, 3] <*> [4, 5]
14:41:45 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:41:59 <cheater> > (,) <$> [1, 2] <*> [3, 4, 5]
14:42:02 <lambdabot>  [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
14:42:07 <cheater> hmm ok
14:42:09 <jle`> filthy_causual2_: i...trust the author on that point
14:42:10 <filthy_causual2_> Thats how I would write that.
14:42:34 <jle`> heh
14:42:38 <jle`> given his reputation
14:42:45 <jle`> but i am a blind man.
14:42:47 <dminuoso> jle`, am I to understand that the documentation you linked means "fmap f xs = xs >>= return . f" have the same semantics? Because the section only talks about types
14:42:58 <filthy_causual2_> jle` I just cant quite tell if that is how he is using the vocabulary.
14:43:18 <jle`> dminuoso: it says that the laws imply what you state
14:43:25 <dminuoso> Heh
14:43:36 <jle`> right after it lists the laws
14:45:11 <Guest82821> Hi there guys, thank for in advance for the help.
14:45:25 <Guest82821> I am trying to implement mempty for monoid
14:45:42 <filthy_causual2_> On what type?
14:45:58 <Guest82821> what if I have a newtype "Identity a"
14:46:07 <Guest82821> how can I say
14:46:22 <Guest82821> and ofc Monoid a => Identity a (missed that)
14:46:34 <Guest82821> how can I create mempty of that a parameter
14:46:44 <jle`> you can use mempty :: a :)
14:46:46 <Guest82821> I tried (mempty :: a)
14:46:57 <jle`> you don't need the actual type annotation
14:47:05 <jle`> it will be inferred, from the magic of type inference
14:47:11 <Guest82821> oh hm
14:47:14 <Guest82821> let me give a try
14:47:33 <jle`> the type annotation actually throws of haskell, because by default, the 'a' there is recognized as a fresh type variable, different from the 'a' in Monoid a => Identity a
14:47:56 <jle`> vanilla haskell type variables are not 'scoped' and you can't refer to them elsewhere
14:48:17 <jle`> you can turn on the ScopedTypeVariables extension though, and Identity (mempty :: a) should work.
14:48:35 <jle`> but without ScopedTypeVariables, haskell interpets the 'a' in mempty :: a to be a fresh type variable
14:48:48 <Guest82821> hm thanks for the info, but I want to still with what you suggested first, for some reason it is saying
14:49:04 <jle`> you mean `mempty = Identity mempty`, right?
14:49:52 <Guest82821> Could not deduce (Semigroup a) arising from use of <>
14:50:00 <Guest82821> yes that's right
14:50:04 * hackagebot ballast 0.2.0.0 – Shipwire API client – https://hackage.haskell.org/package/ballast
14:50:06 <Guest82821> but for <>
14:50:08 <jle`> ah that's probably unrelated to whatever you are writing for mempty
14:50:12 <Guest82821> i am reusing my semigroup method
14:50:26 <filthy_causual2_> (When you get a handle on type classes, you should try out Generalized Newtype Deriving)
14:50:34 <jle`> ah.  yeah, in all current versions of GHC, Semigroup is not a superclass of Monoid
14:50:37 <jle`> for historical reasons
14:50:47 <jared-w> jle`: I thought that changed in like 8.0-8.2 or so?
14:50:52 <jle`> it might be a superclass some day, maybe 8.6 or 8.8
14:51:00 <jle`> nope not yet heh
14:51:00 <filthy_causual2_> Yet that error says it is in his code.
14:51:10 <Guest82821> but the same thing is working for a Trivial type that I created
14:51:13 <jle`> we will probably have a really drawn out process like we did for Applicative and Monad
14:51:22 <Guest82821> that is just type and data constructor without parameters
14:51:28 <jle`> Guest82821: because your trivial type probably has a Semigroup instance already
14:51:44 <Guest82821> ooooo I seee mate
14:51:49 <Guest82821> that totaly makes sense
14:51:53 <filthy_causual2_> Never mind I was wrong.
14:52:00 <jle`> you should probably just use 'mappend'
14:52:04 <jle`> at this point in time it's the simplest way
14:52:52 <filthy_causual2_> Or just shadow the semigroup ('<>') in a file where you use monoids.
14:53:12 <filthy_causual2_> Unless you are messing around with non-empty lists and such.
14:53:21 <jle`> if you import Data.Monoid
14:53:29 <jle`> Data.Monoid exports a <> for monoids
14:53:33 <jle`> which is different than the <>, for semigroups
14:53:42 <filthy_causual2_> Do that then.
14:53:48 <dminuoso> jle`, wow this is crazy. Monads are suddenly clicking in to the point where I have been using 2 monadic interfaces for nearly a year now, which made me so appreciate the combination of side effects and pure functoinal programming..
14:53:58 <jle`> but it's not ideal because then you'd have two <>'s
14:53:59 <Guest82821> it worked by saying when implementing the instance (Semigroup a, Monoid a) => Monoid (Indentity a)
14:54:04 <dminuoso> And never knew that I was using monads.
14:54:17 <jle`> Guest82821: yes, that works
14:54:24 <Guest82821> thank you guys!
14:54:29 <jle`> but it's a little silly i think
14:54:38 <jle`> dminuoso: i love that moment :)
14:54:43 <remexre> Is there a library for "block-structured" printing?
14:54:45 <filthy_causual2_> But in practive lots of things don't have semigroup instances. (AFAIK).
14:55:30 <Guest82821> yee I see , well it is not the best, but still it compiles and I can continue with the excersises
14:55:32 <jle`> it looks like this is a learning excersize for implementing semigroup and monoid instances, so they're going to have Semigroup already imported
14:55:42 <filthy_causual2_> dminuoso: people argue that you need to understand monads before using them, and afaict its just pure elitism/one-true-wayism.
14:55:50 <jle`> Guest82821: i'd just do mappend (identity x) (Identity y) = Identity (mappend x y)
14:56:10 <jle`> remexre: maybe like one of those prettyprinter libraries?
14:56:27 <jle`> Guest82821: because you can already use mappend
14:56:40 <filthy_causual2_> Yeah that works.
14:57:13 <filthy_causual2_> I am throwing things at you you don't need to think about yet.
14:57:16 <remexre> jle`: Hm, looks... overengineered... (there's a flowchart!?) I'll give it a try though
14:57:21 <filthy_causual2_> Ignore me.
14:58:03 <dminuoso> filthy_causual2_, well with this sudden revelation I'
14:58:03 <Guest82821> jle` ye that's my semigroup implementation, didnt want to write it again and I was not sure why it was faling, but thanks for helping figuring out
14:58:03 <dsal> I saw something defining a type with    :: !String  -- what does that mean?
14:58:33 <dsal> It was the cassava examples:  https://hackage.haskell.org/package/cassava
14:59:34 <Alex__> Hi, I've just read this article https://ro-che.info/articles/2017-08-06-manage-allocated-memory-haskell and author mentions that declaring csum as pure would break this code. I can't see why, can someone help me to figure it out?
15:00:56 <dsal> Oh.  I found a doc.
15:03:33 <geekosaur> Alex__, pure means the same parameters produce the same result.
15:03:36 <mauke> Alex__: well, making it pure would claim that the result of csum only depends on the Ptr argument
15:03:40 <geekosaur> in this case, one of the parameters is a pointer
15:04:05 <geekosaur> and "pure" applies *only* to that pointer. change what it points to? the pointer itself didn;t change, so...
15:04:38 <mauke> I wouldn't be surprised if the "pure" csum ran lazily
15:04:48 <mauke> i.e. it would get and dereference the pointer after it's been freed already
15:04:54 <c_wraith> yeah pure csum is lazy
15:05:34 <c_wraith> meaning it is no longer ordered by IO sequencing 
15:05:48 <geekosaur> heh. yeh. that too
15:07:54 * dsal waits for this to return:  Prelude> maximum [1..]
15:08:47 <geekosaur> glwt
15:09:01 <c_wraith> > maximum [1..] :: Word8
15:09:04 <lambdabot>  255
15:09:12 <c_wraith> that doesn't take too long at all. 
15:09:23 <dsal> heh
15:09:30 <dsal> I'm surprised this doesn't return more quickly:  product [-11,-10..]
15:10:30 <Hafydd> Are you really?
15:10:54 <dsal> Yeah.  Why wouldn't it?
15:11:30 <Hafydd> > [-11,-10..]
15:11:32 <lambdabot>  [-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16...
15:12:05 <Hafydd> The Integer type (which this defaults to) doesn't short-circuit for multiplication by 0.
15:12:19 <c_wraith> ... in most versions of ghc 
15:13:08 <c_wraith> Integer actually had several shortcuts defined for one release or so. a lot of people objected. 
15:13:21 <Hafydd> Oh...
15:13:39 <dsal> Really?  Why?  At the point where you've got an arbitrarily long list that has a zero in it, your answer isn't going to change if you keep looking.
15:14:22 <c_wraith> among other things, I believe the shortcuts broke strictness analysis. 
15:14:30 <Hafydd> Multiplication is strict by default, so one might expect product [1,2,0,undefined] to also be bottom.
15:14:35 <filthy_causual2_> Uh, this is a bit of a long shot, but anyone remember the name of the unpublished paper that talked about a type system for reversible computations that defined type subtraction and division?
15:15:43 <Pandore> Hi I need to stream data from http://stream.meetup.com/2/rsvps. Does anyone know how to do it. Examples are welcome.
15:16:00 <EvanR> > product [1,2,0,undefined]
15:16:02 <Hafydd> (I would also imagine that adding a check for that kind of short-circuiting would incur a runtime cost that hardly ever is of any benefit.)
15:16:02 <lambdabot>  *Exception: Prelude.undefined
15:16:29 <dsal> I assumed bottom only referred to infinite loops.  I've got so much reading to do...
15:16:44 <EvanR> undefined is also a bottom
15:16:59 <EvanR> > product [1,2,0,let x = x in x]
15:17:05 <lambdabot>  mueval-core: Time limit exceeded
15:17:56 <EvanR> time = infinity, undefined results, etc all seem to come up at the same places
15:18:28 <EvanR> so bottom goggles simplify the analysis by considering them all the same thing
15:19:32 <c_wraith> they are all the same in some sense.. they're all failures to produce a result 
15:19:38 <EvanR> i think the unifying theme is "you dont get an actual answer of the type you asked for"
15:19:53 <EvanR> bottom being the lack of answer here
15:20:24 <Hafydd> In some cases, non-termination behaves similarly to undefined, resulting an exception called <<Loop>> or something like that.
15:20:48 <Hafydd> When it can be detected at runtime.
15:20:58 <Hafydd> (Or at compile-time? I'm not certain.)
15:21:53 <EvanR> another form of bottom, in the domain theory of haskell, is bottom is the least defined answer
15:22:12 <EvanR> but that seems like an essentially different picture
15:22:55 * Hafydd . o O (And "top" is the most-defined answer.)
15:23:14 <EvanR> but we dont have a single top
15:23:36 <danilo2> Hi! Does anybody know why (:) is not normal data constructor in haskell that we can hide from Prelude? I'm writing a DSL and would love to hide it and override, but as I see I'm unable to :(
15:24:14 <geekosaur> because various forms of list sugar need to know about it
15:25:15 * hackagebot haskell-src-exts-observe 0.1.0 – Observable orphan instances for haskell-src-exts – https://hackage.haskell.org/package/haskell-src-exts-observe
15:25:15 * hackagebot NoHoed 0.1.0 – Placeholder package to preserve debug ability via conditional builds – https://hackage.haskell.org/package/NoHoed
15:25:23 <jared-w> Is it just me or is the list sugar the source of a whole lot of pain and inconsistency in the language? :p
15:25:45 <EvanR> you dont have to use it :)
15:25:52 <jared-w> It'd be wicked cool to be able to make <1..5> the same way I can make [1..5]
15:26:07 <danilo2> geekosaur: which lsit sugar needs threating (:) in a special way ?
15:26:41 <jared-w> EvanR: sure I don't have to use it, but a lot of the sugar is very convenient and great. It'd be nice if the language was powerful enough to generalize the sugar in a way that I can make my own "nice behaving" syntax for different data structures
15:27:09 <EvanR> yeah customizable sugar is available in other languages
15:27:12 <jared-w> myMap = {(k,v),(k,v),(k,v)} :: Map  <-- wouldn't that be cool?
15:27:25 <EvanR> if you ask clojure, no it wouldnt
15:27:43 <jared-w> lol. I thought clojure had pretty extensible syntax?
15:27:46 <geekosaur> danilo, the compiler has to *know* about (:), because [1,2,3] compiles to applications of it
15:28:01 <danilo2> HAskell allows customizable sugar, like RebindableSyntax. However I do not see yet why (:) needs some special tratment
15:28:18 <geekosaur> doesn't mean it has to be treated specially as far as visible syntax, *does* mean the compiler knows what that operator is and it is therefore not replaceable
15:28:26 <danilo2> geekosaur: Hmm, really? do notation compiles to >>= but remibnadble syntax allows to define cusotm >>=, so why the list sugar is different ?
15:28:31 <geekosaur> (RebindableSyntax is not 100% coverage, see its documentation)
15:28:32 <EvanR> {:k v :k v :k v}
15:28:42 <EvanR> "down with commas"
15:28:55 <geekosaur> danilo2, yes and it requires special support in the compiler
15:28:59 <geekosaur> that support des not exist for (:)
15:29:01 <danilo2> geekosaur: sure, but (:) could behave in Rebindable syntax just like do notation and >>=
15:29:07 <jared-w> ahh right, commas are evil, forgot cojure hated them :p
15:29:08 <geekosaur> read the doucmentation
15:29:21 <danilo2> geekosaur: ok, so in fact it could exist theoretically
15:29:25 <EvanR> jared-w: i would like syntax for maps to somehow reflect their constructive properties
15:29:25 <geekosaur> it says RebindableSyntax does not allow rebinding *all* special syntax
15:29:46 <EvanR> right now, fromList [(a,b),(c,d)] does that... but yeah...
15:29:48 <geekosaur> someone has to do surgery on ghc to enable rebinding each construct the compiler has to know about
15:29:49 <danilo2> geekosaur: I read it already fewtimes! :) I know it does not allow. I'm just curious if it will be possible in the future
15:29:49 <jared-w> EvanR: that would be nice. What are you thinking of, theoretically?
15:30:02 <geekosaur> it says to talk to the ghc devs if you need something else, doesn't it?
15:30:02 <EvanR> im not sure
15:30:15 <geekosaur> it did last time I looked
15:30:19 <EvanR> jared-w: a map is either the empty map, or an operation done on a map
15:30:36 <EvanR> with a really complicated equivalence
15:30:38 <jared-w> danilo2: at some point, things have to be hard-coded into the compiler for things to work :p  I wouldn't be surprised if major optimization issues started happening if you try to generalize the sugar-abilities too far
15:31:26 <geekosaur> I'm not ure, OverloadedLists *may* have done much of the needed work and it only has to be wired into the extension
15:31:37 <geekosaur> but ou'll still need to talk to ghc devs about it
15:32:04 <EvanR> jared-w: in the syntax of contexts, they do like, empty context OR G, x:T
15:32:20 <EvanR> so, e, k1:v1, k2:v2, ...
15:32:41 <EvanR> i really like raw commas for constructing sequences of stuff
15:32:43 <danilo2> geekosaur: maybe im blind but this page does nto tell about talking to ghc devs if i need someting more: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#things-unaffected-by-xrebindablesyntax
15:32:44 <jared-w> Also, tbh, I don't really know if I like overloaded lists... At some point it just gets weird how overloaded [] becomes and how neglected {} and <> become. Although, I don't really think anything's super neglected except for {}...
15:33:13 <danilo2> geekosaur: I would love to talk to them! :) I'll ask about it on GHC channel
15:33:20 <EvanR> in the syntax of records, empty record OR r, field=value
15:33:41 <EvanR> {}, {field=value}, {field1=value1, field2=value2}
15:33:48 <dsal> Any idea how I can get stack using the correct llvm stuff on my linux box?  It wants llvm-3.7 which installs in an odd place and then puts opt-3.7 etc... in the path.  How can I convince stack to do the right thing?
15:35:25 <EvanR> jared-w: basically, if you dont reuse comma for pairing and appending, you dont need parens.
15:35:50 <EvanR> if you do like clojure and use spaces for both, seems easy to screw up
15:35:53 <dsal> I guess this worked:  PATH=$PATH:/usr/lib/llvm-3.7/bin stack setup
15:40:32 <dsal> I don't know why that'd work...  I don't see a reference to that in ~/.stack
15:43:13 <jared-w> EvanR: I can see that. I don't like the spaces for both approach but I do think comma for both pairing and appending is a bit excessive and can lead to too many parens
15:43:30 <jared-w> One of my issues with C++ and other languages like that is just /so much syntax/ everywhere that it just bleeds into your eyes and it's worse than not even having any
15:44:01 <EvanR> too much syntactic sugar rots the brain?
15:44:21 <boj> dsal: stack.yaml has an extra-include-dirs/extra-lib-dirs option you can add if you want to avoid passing things on the command line
15:44:51 <dsal> This is for bins.  Couldn't find opt
15:44:58 <boj> ah, right
15:45:32 <dsal> Yeah, it's still broken.  ghc: could not execute: opt
15:45:34 <jared-w> const <T>class::member(<T>const **stuf,<T>&thing,*&wtf); const /* Forget it */
15:46:05 <dsal> I guess I can put that in my path.  I'd hope I could stuff that in stack somewhere.
15:46:09 <dsal> I guess I still could.
15:46:37 <EvanR> a testament to the extensibility of C syntax
15:47:04 <jared-w> EvanR: you can make a skyscraper out of anything if you're willing to use enough cement to hold it together :p
15:48:19 <dsal> I assume these bins are statically linked...
15:51:03 <cheater> is there a way to get all elements of an Enum?
15:51:11 <cheater> or rather
15:51:21 <cheater> of a finite adt of the form data Foo = A | B | C
15:51:41 <jared-w> cheater: why would you want that?
15:52:29 <cheater> because i want to run a function against each of them
15:53:30 <jared-w> I suppose I should rephrase. Foo is something that can be only an A or a B or a C.
15:53:50 <cheater> obviously
15:53:51 <trigone> hi! best tutorial to understand creating and using one's own packages? i'm using stack
15:53:53 <jared-w> If you want to run a function against each of them you might want to pattern match on the constructors? Or perhaps rethink how you're storing the data?
15:54:01 <cheater> i want a list that contains A, B, and C
15:54:04 <boj> you want to create like a list of constructors? [A, B, C]?
15:54:08 <cheater> yes boj
15:54:39 <boj> hmm, not sure how you'd generate that
15:54:55 <cheater> this has little to do with pattern matching. i need to run a function against a list of all of those.
15:54:59 <remexre> How do I get an executable in the current directory with stack? It seems to place it in some hidden folder
15:55:16 <geekosaur> cheater, if it's of that form, can't you just derive Enum and Bounded for it?
15:55:31 <dsal> Not all Enum is bounded.
15:55:53 <jared-w> dsal: a sum type in Haskell has to be bounded, however. It only has a finite amount of constructors :p
15:56:23 <geekosaur> alternatively you derive Data and you can get representations of constructorrs, but I don't know if you can turn them into actual constructors
15:56:40 <cheater> geekosaur: i could do that
15:56:53 <cheater> this Enum is Bounded, dsal
15:56:53 <geekosaur> but if you control the enum involved, just derive Enum and Bounded and use [minBound .. maxBound]
15:57:06 <geekosaur> may need a type ascription
15:57:09 <cheater> :i Bounded
15:57:17 <geekosaur> no :i in lambdabot
15:57:19 <cheater> :(
15:57:29 <jared-w> @info Bounded
15:57:29 <lambdabot> Bounded
15:57:36 <cheater> :D
15:57:38 <jared-w> thx lambdabot, many helpful
15:57:41 <dsal> This is a similar question to what I was asking about recently with bounds.  I didn't internalize how to work with types like that. 
15:58:13 <rostero> someone on twitter asked for a name for `[a -> a] -> a -> a`, so I search on github and see that people call it compose, but some people implement it as `foldl (flip (.)) id` and others as `foldr (.) id`.  if you pass it `compose [(*2), (+5)] 2`, you will get two different results depending on the implementation.  is there anyway to guard against that?
15:59:34 <jared-w> rostero: [a -> a] -> a -> a is too vague of a type to have only one unique implementation
15:59:41 <glguy> No, it's similar to how there are lots of functions with type Int -> Int.
15:59:44 <trigone> > foldl (flip (.)) id [(*2), (+5)] 2
15:59:46 <lambdabot>  9
16:00:00 <trigone> foldr (.) id [(*2), (+5)] 2
16:00:06 <trigone> > foldr (.) id [(*2), (+5)] 2
16:00:08 <lambdabot>  14
16:00:25 <kadoban_> jared-w: It doesn't have that many sane ones though.
16:01:02 <cheater> it seems like Enum + Bounded have worked
16:01:04 <cheater> thank you
16:01:04 <jared-w> kadoban_: it has enough to mean that you can't "guard" against certain implementations
16:01:15 <trigone> kadoban_: actually it can be head, or (!! 2) or (!! 3) or ...
16:01:26 <kadoban_> trigone: Ya, I don't consider those sane
16:01:28 <kadoban_> jared-w: Yeah
16:01:28 <jared-w> :t (!! 2)
16:01:30 <lambdabot> [a] -> a
16:01:39 <jared-w> that's not [a -> a] -> a -> a :p
16:01:46 <glguy> :t (!!2) :: [a -> a] -> a -> a
16:01:48 <lambdabot> [a -> a] -> a -> a
16:02:14 <trigone> :t ([(*2), (+4)] !! 1)
16:02:15 <lambdabot> Num a => a -> a
16:02:19 * jared-w stands corrected
16:03:21 <rostero> is this something that dependent types could help out with?
16:03:35 <rostero> in idris, for example
16:03:44 <glguy> Not if you wanted to use lists
16:03:45 <trigone> still those are obviously arbitrary implementations, uselessly monomorphic (well moreso). i wonder if you have more than one logical implementation for that signature (one that cannot have a more general, polymorphic signature)
16:04:46 <glguy> a foldr and foldl' version are both quite sensible
16:04:49 <trigone> nvm i forgot there was already two options at least... along with any order of combination
16:04:49 <rostero> out of curiosity, then, how would you name this to help with this ambiguity?  composeL and composeR
16:05:40 <rostero> i guess it doesn't matter
16:05:42 <rostero> thanks
16:07:29 <trigone> so, nobody for a good tutorial on how to create/use packages of one's own?
16:09:29 <pacak> trigone: cabal init.
16:09:48 <pacak> That's probably all you need.
16:10:45 <trigone> pacak: i don't even know what that means... and i use stack since it seemed simpler at first sight
16:10:45 <dsal> yay, all my tests pass on my raspberry pi
16:10:53 <dsal> Took a long time, though.
16:17:33 <sm> https://duckduckgo.com/?q=haskell+stack+create+package+tutorial&t=ffab&ia=web
16:35:30 <sqooq> I solved my problem. If anyone's curious how I zipped a type that's not a list, I literally just used the module here : https://wiki.haskell.org/Foldable_and_Traversable#Generalising_zipWith
16:47:37 <trigone> Q: if i want to create a module Foo.Bar.Blah, but there's no other module underneath Foo, am i forced to create the folder Bar? if not, what's the method?
16:47:55 <trigone> *no other module underneath Bar
16:48:15 <geekosaur> you re forced to make it, yes
16:48:30 <geekosaur> module names have to map to filenames somehow
16:49:00 <geekosaur> everyone always wants magic where they can call a module's file whatever and the compiler consults an Ouija board to figure out what filename to use given a module name
16:50:22 <trigone> haha ouija
16:51:04 <trigone> still you're a bit stretching my question. it's not that absurd to imagine we could write a Bar.Blah.hs, is it?
16:51:31 <trigone> (unless dots are allowed inside normal module names but i doubt it, it'd be confusing and undecidable)
16:51:55 <trigone> but nvm, not big of a deal. thanks for the answer :)
16:55:27 <geekosaur> it is a big deal when you find both
16:56:06 <geekosaur> the more flexibility of that kind, the more chances for weirdness. a simple and consistent mapping is most reliable / least error-prone
17:14:48 * hackagebot recursion-schemes-ext 0.1.1.1 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
17:19:22 <AlainODea> Does OverloadedLists interact with type defaulting in a new way in GHC 8+? This used to compile and now gets a compile error: Couldn't match expected type ‘GHC.Exts.Item (t0 a0)’ with actual type ‘Int’ https://github.com/booksbyus/zguide/blob/master/examples/Haskell/peering2.hs#L231-L232
17:26:42 <dsal> Is there an operator for "approximately equal" or "similar" or something?  Trying to decide whether to do something like that for my Address type.  An Address has a callsign and an optional SSID.  I'm deriving Eq, but  I'd like to be able to ~= or something to  match when SSIDs are the same.
17:27:33 <boj> dsal: you could defined your own Eq instance and fuzzy check how you want
17:27:47 <dsal> Yeah, I think I still want exact matches to work.  Maybe.
17:28:00 <dsal> I don't actually know where I'm going with this code yet.
17:29:33 <kadoban> dsal: I don't think there's a well known one. You can just make one up. Though does it need to be an operator? A function is easier to come up with a name for that doesn't conflict, heh.
17:29:44 <dsal> heh.  yeah.
17:29:51 <dsal> I also may not even need this.
17:30:13 <dsal> ~= makes sense to me, though.  I spend my days in a language with no operator overloading.  I'm going to stop using letters for functions.
17:35:30 <dsal> (≊) (Address a _) (Address b _) = a == b
17:38:02 <sqooq> jesus this library makes no sense to me
17:38:03 <sqooq> https://hackage.haskell.org/package/temporal-media-0.6.1/docs/src/Temporal-Media.html#Track
17:38:35 <glguy> Then maybe don't use it?
17:38:45 <sqooq> According to the Track comment "'Track' is a set of 'Event' s" , but as far as I can tell, Tracks contain no flipping Events whatsoever
17:39:16 <sqooq> glguy: I'm somewhat forced to, or I should say that it's really unreasonable not to use it (it's a dependency of csound-expression)
17:39:56 <pacak> 2319 total (17 in the last 30 days)
17:39:58 <pacak> looks dead to me.
17:41:44 <glguy> sqooq: The Events are implicit in the Track structure
17:41:49 <glguy> See eventList , for example
17:43:31 <sqooq> ok
17:51:34 <sqooq> still seems weird to me
17:51:55 <sqooq> But I think I see why, it's to abstract away the notion of stretching and delaying
17:52:04 <sqooq> so you can stretch an entire track
17:52:08 <sqooq> or delay it
18:03:23 * hackagebot hw-rankselect 0.10.0.2 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
18:03:30 <cheater> hi
18:03:48 <cheater> is there a better way of doing this?     (uncurry f) <$> (zip xs ys)
18:06:00 <thoughtpolice> zipWith f xs ys
18:11:33 <erisco> saw an SO question asked by Oleg! turned out not to be *that* Oleg...
18:12:19 <erisco> is the community so large that we cannot disambiguate on a first name basis?
18:17:22 <pacak> erisco: Disambiguate Simon?
18:17:24 <geekosaur> has been for a while "_
18:17:25 <geekosaur> :)
18:20:33 <erisco> that must mean there are more Haskellers than Canadians!
18:29:23 <sqooq> I kind of want to work towards making my program work with haskell-implemented audio, rather than just outsourcing to csound
18:29:36 <sqooq> even though it technically works fine with csound
18:29:41 <sqooq> is that a bad idea?
18:29:57 <erisco> yup
18:29:58 <sqooq> seemingly my only option is https://hackage.haskell.org/package/synthesizer
18:30:21 <sqooq> yup it's a bad idea?
18:30:28 <erisco> yup
18:31:14 <erisco> now with the time you saved you can work on implementing something which isn't already working :)
18:32:05 <sqooq> lmao
18:33:48 <sqooq> The only thing I would want to implement now is line/curve based loudness control, but it seems really bloody hard. Would be easier lower level, but I wouldn't want to do it lowerlevel because in my mind, dynamics is one of the last things a composer adjusts
18:34:20 <sqooq> I could maybe do it right in between :thinking:
19:02:38 <jchia> Question about workflow. Is searching & reading library documentation a big part of your development workflow? If so, what do you use? www.haskell.org/hoogle ? I find it necessary to run hoogle locally as the Internet version is too slow for me and would like to know what other people use for searching documentation.
19:04:00 <pacak> About 0 time on hoogle, read documentation from hackage
19:10:11 <Cale> jchia: Yes, but also looking through source code for things. In reflex-platform, I added a script called docs-for which will open the documentation for any package which is available in the try-reflex environment
19:10:46 <Cale> e.g. ./docs-for reflex-dom-core
19:26:43 <crucify_me> https://ptpb.pw/Hh3K  hi this won't work. I'm getting error : No explicit implementation for either ‘Prelude.compare’ or ‘<=’   .. anything wrong? it's precisely the book's example
19:27:19 <pacak> crucify_me: move compare to the right
19:27:42 <glguy> crucify_me: same problem as your previous (==) implementation
19:29:17 <pacak> crucify_me: That is if we are talking about syntax. Other than that - this instance is wrong in some other ways. You won't be able to use type as a key in a Map.
19:29:47 <crucify_me> glguy, pacak sorry not following. its a book example to the T
19:30:12 <pacak> crucify_me: https://pics.me.me/impossibru-16341104.png
19:30:18 <glguy> crucify_me: It doesn't matter what's in the book, pacak told you how to fix it
19:30:26 <penteract> they mean indent it
19:31:13 <crucify_me> penteract dang thanks ALL -- stupid of me. pacak other problems. ?
19:32:05 <pacak> crucify_me: Haskell is somewhat indentation sensitive.
19:32:51 <pacak> crucify_me: It claims that Tue `compare` Wed = EQ
19:33:13 <pacak> And a bunch of other combinations.
19:33:30 <pacak> Eq and Ord instances disagree on that in fact.
19:34:58 <crucify_me> sorry gl*guy referred to earlier confusion I had with indents. I couldn't glean that from our conversation, yeah pacak I foresaw that, the example is trying to show that Friday is the "best" day. but that last compare is confusing
19:35:34 <pacak> Friday is the best day? What kind of herecy is it????
19:36:07 <pacak> I'd go with Saturday
19:36:41 <crucify_me> heresy ! I like tuesday since no tourists are around
19:37:37 <pacak> If you want to put it first in sorting order - reorder constructors
19:38:20 <pacak> Those basic instances are used in many places and it's nice to have them correct.
19:38:34 <crucify_me> pacak but isn't that last entry illogical for the purpose of the prog?
19:38:56 <pacak> Last entry is wrong
19:39:45 <penteract> The code will run, but you better not try to sort a list of them.
19:40:49 <crucify_me> oh, but it goes on to say that all other comparisons are equal, since Friday alone is the 'best' day
19:41:11 <crucify_me> so its just clever to put that there
19:41:17 <penteract> but the automatically derived instance for Eq contradicts that
19:41:22 <pacak> Put them in Map as keys and will be surprised.
19:41:42 <pacak> Words are hard.
19:41:45 <penteract> so if code uses (==), it will think they're different
19:42:25 <crucify_me> penteract, re: that, why won't this work if Ord is added to the data declaration in the parens .. such as ...
19:42:52 <crucify_me> ie in the previous example..
19:43:11 <crucify_me> we have deriving (Eq, Ord, Show)
19:43:14 <pacak> crucify_me: How about data DayOfWeek = Friday | InferiourDays InferiourDay ; data InferiourDay = Mon | Tue ...
19:43:49 <penteract> Tf you derive Ord like that, you can't redefine it later.
19:43:58 <crucify_me> this is encapsulated in a where statement, so at least it makes some sense to this beginner
19:44:26 <crucify_me> so thanks kindly everyone
19:50:11 <remexre> Is there a way to get stack to create an executable in the working directory?
19:52:16 <penteract> I've created symlinks.
19:52:32 <remexre> In what manner?
19:53:54 <penteract> On linux, ln -s .stack/whereveritputsstuff
19:54:17 <remexre> Oh, yeah. But detecting the whereveritputsstuff is the tricky part :)
19:54:37 <penteract> I don't have much experience with Stack, so there may be a better way.
19:56:44 <penteract> .stack-work/install/x86_64-linux/lts-9.0/8.0.2/bin/<name> in my case, which should work unless your executable names change frequently.
19:58:18 <remexre> for me it's .stack-work/dist/x86_64-linux-nopie/Cabal-1.24.2.0/bin/<name> on my laptop, but .stack-work/install/x86_64-linux/lts-9.0/8.0.2/bin/<name> on the desktop
19:58:19 <penteract> There are also files in .stack-work/dist and I have no idea what the difference is.
19:59:02 <remexre> erm wait, the laptop path isn't quite transcribed correctly
19:59:07 <remexre> but whatever, the laptop is -nopie
20:04:01 <boj> 'stack install' will drop the binary in ~/.local/bin
20:04:27 <boj> not sure if you can modify where it goes
20:06:41 <markasoftware> im trying to make a really basic card game thing, and I want to have a function which is run every turn, and it returns the new state (e.g, which cards are where). However, for different card games, the state will be in a different format, and I'm not really clear on how I would handle the return values of these game functions if the return values can be different types
20:10:51 <penteract> That's very similar to a problem I'm trying to deal with.
20:11:39 <boj> markasoftware: are the rules for each card game the same, just different states?
20:11:46 <markasoftware> boj: no, completely different
20:12:28 <boj> can you describe how you envision the run function to work?
20:12:30 <markasoftware> and each one has a different type for it's state, defined in the module file for the game
20:12:41 <markasoftware> well, you have a starting state, which is the initial game setup
20:12:55 <markasoftware> then, you have some sort of `gameTurn` function, which takes the input from the last player, and the state, then returns the updated state
20:13:57 * hackagebot DeepDarkFantasy 0.2017.8.18 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
20:15:01 <boj> maybe: data GameType = A | B | C, and then runGame :: GameType, which then calls runA, runB, runC with the correctly seeded state for each game type
20:15:42 <markasoftware> boj: each game is defined in a separate module, and the state is defined as an export (is that the right word?) of the module
20:15:53 <boj> that makes sense
20:16:02 <markasoftware> and, additionally, in my main file, i only want to have a list of all the modules
20:16:11 <markasoftware> i don't want to have a list of game names, then a list of gameTurn functions, and types
20:16:26 <boj> sounds like you still need some kind of overarching control function though
20:17:04 <markasoftware> my main file will import all the modules, let the user select which game to play based on a hardcode list of games, but the actual gameplay loop will be generic for any game
20:17:21 <markasoftware> which is where the problem comes out
20:17:35 <boj> are you familiar with the State monad?
20:17:46 <markasoftware> nope
20:17:59 <markasoftware> i think there's got to be a way to do this without that though
20:18:38 <boj> sure, you could handle state manually
20:18:50 <boj> sounds like you want a polymorphic state
20:19:14 <boj> :t runState
20:19:16 <lambdabot> State s a -> s -> (a, s)
20:19:24 <boj> you could write something similar to that
20:19:36 <dsal> I'm surprised there's no splitWith on lists.  I just made one and it's rad.
20:19:53 <markasoftware> ok give me a sec, I'm still getting used to using types as a replacement for documentation
20:19:54 <pacak> dsal: splitWith?
20:20:01 <dsal> splitWith :: (Char -> Bool) -> String -> (String, String)
20:20:03 <boj> runGame :: s -> (a, s) -- where 's' is your generic GameState, and 'a' is some result per call
20:20:09 <pacak> :t partition
20:20:11 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:20:12 <pacak> :t span
20:20:14 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:20:16 <dsal> I don't thin partition quite does it.
20:20:26 <pacak> > span 
20:20:28 <lambdabot>  error:
20:20:28 <lambdabot>      • No instance for (Typeable a0)
20:20:28 <lambdabot>          arising from a use of ‘show_M31020805112213227087343’
20:20:33 <boj> markasoftware: is there an example of the kind of documentation you are seeking in another language? :)
20:20:36 <pacak> > span  (> 3) [1..10]
20:20:39 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
20:20:41 <dsal> Yeah, span looks right.
20:20:45 <pacak> > span  (< 3) [1..10]
20:20:48 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
20:20:52 <dsal> I obviously wouldn't've guessed that name.  :)
20:21:16 <markasoftware> boj: ok, i think i understand what I'm trying to do now...i guess i don't even really need to specify the type of the runGame return is
20:21:23 <markasoftware> as long as it's always the same type. Thanks
20:21:35 <boj> markasoftware: happy to help :)
20:21:37 <penteract> :t splitWith
20:21:38 <dsal> Doh, it's the opposite of what I want.  But that's fine.
20:21:39 <lambdabot> error:
20:21:39 <lambdabot>     • Variable not in scope: splitWith
20:21:39 <lambdabot>     • Perhaps you meant one of these:
20:23:33 <dsal> No, span isn't right...
20:23:36 <boj> :t Data.ByteString.splitWith
20:23:37 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> [BSC.ByteString]
20:23:51 <boj> :t Data.ByteString.Char8.splitWith
20:23:52 <lambdabot> (Char -> Bool) -> BSC.ByteString -> [BSC.ByteString]
20:23:57 <boj> hmm
20:24:39 <dsal> Data.ByteString's is closest.  I'll just keep mine, I guess.
20:26:12 <dsal> span with negative tests is close, but then leaves me with the thing I was splitting on in the right side, which I didn't want.  I guess this is why it wasn't there.  It's easy to make, and everyone else's sucks.  :)
20:28:31 <dsal> e.g., I've got splitOn c = splitWith (== c)      which makes it so I can do something like     splitOn '-' "blah-blah-blah"    and get ("blah", "blah-blah")
20:28:48 <markasoftware> do you usually use type annotations for everything, even when it's very obvious what the type of something is?
20:29:13 <glguy> No, the type annotations are mostly limited to top-level definitions
20:29:15 <dsal> I've been putting them on the top of things before I write the functins.
20:29:32 <dsal> e.g., if I'm likely to mess up, I'll start with my intention.
20:30:50 <penteract> Types are usually easier to write than code and they help the compiler give nicer error messages.
20:32:03 <dsal> Heh.  My type definition for splitOn is much longer than the code. 
20:34:13 <penteract> That sometimes happens because I don't get to give types 1 character names
20:35:10 <penteract> (or use pointfree style)
20:35:22 <dsal> Also splitOn is splitWith partially applied using a partially applied ==
20:36:28 <penteract> :t flip (fmap.(=<<))
20:36:31 <lambdabot> (Functor f, Monad m) => f (m a) -> (a -> m b) -> f (m b)
20:45:41 <dsal> Is there an assertNotFailure ?
20:51:52 <dsal> Eh, just did it right.
20:54:16 <markasoftware> what's your favorite statically typed functional programming language
20:54:29 <monochrom> Haskell.
20:54:58 <pacak> Javascript!
20:55:39 <markasoftware> i always knew that Haskell was funcitonal pretty much from when i first heard of it, but now that I'm actually using it people seem to care about the type system more
20:55:43 <markasoftware> than the functional-ness
20:56:02 <monochrom> I care about the functionalness.
20:56:18 <boj> i think they go hand in hand
20:56:21 <pacak> You can functionalness in Javascript!
20:56:44 <monochrom> You don't see me using Modula-3 and Ada much.
21:01:03 <boj> markasoftware: keep in mind we use types to describe ideas i irc, or to our peers, because it turns out it's quite a convenient language
21:01:24 <boj> we still use those types to guide writing functional programs
21:01:48 <erisco> markasoftware, they're not disconnected though, because the research that has gone into producing type systems such as Haskell's naturally leads to a functional language
21:03:45 <penteract> Due to the fact that Haskell is functional, the types mean much more.
21:23:02 <dsal> How do I generate an arbitrary field when defining an arbitrary?
21:24:43 <erisco> markasoftware, hopefully one day, but right now types are not a replacement for documentation
21:27:47 <erisco> even with types which describe perfectly what everything is, it may still be desirable to have documentation to explain the intention
21:30:11 <erisco> if you have looked at a Hackage package documentation that has no comments it is difficult to see how more descriptive types will illuminate the intention of how the package is to be used
21:34:29 <dsal> Oh hey, I figured it out.  I might understand monads before too long.
21:36:10 <erisco> it is conceivable if we had a method of formal specification for the whole module
21:48:02 <n_blownapart> hi why must we move the Ord constriction to the instance declaration here? https://ptpb.pw/tVxi
21:48:23 <n_blownapart> in the 2nd example
21:48:35 <erisco> what do you mean by "move"? moved from where?
21:49:41 <n_blownapart> I mean we can no longer keep it in the data constructor in deriving (Eq, Ord, Show)  erisco 
21:50:17 <erisco> okay, well,  when Ord appears in deriving that means a standard instance will be created for you
21:50:21 <glguy> If you chose not to automatically derive the Ord instance, then you express that by not adding it to the deriving clause
21:50:41 <erisco> when you write an Ord instance you can free decide how it works
21:51:43 <erisco> in this case, the standard Ord instance for BestDayOfWeek is not equivalent to the instance defined
21:53:42 <erisco> hm, this isn't a quotient type... is there a kind of type involving strict total orders?
21:55:27 <n_blownapart> thanks erisco glguy   .. oh so we can leave out Ord in the second example altogether ?
21:55:30 <Heffalump> shapr: likewise :-)
21:56:15 <erisco> n_blownapart, it is not left out. As I said before, Ord appearing in the deriving list means a standard instance will be implemented for you. In this case we defined an Ord instance ourselves.
21:56:35 <erisco> i.e. in both examples an Ord instance exists
21:58:26 <n_blownapart> In this case, the second example will work without the Ord constriction, since there compare is just acting according to our biased liking of Friday, right? 
21:59:06 <erisco> deriving does not introduce constrictions. It instructs the compiler to make standard instances for you.
22:00:32 <dminuoso> This might be a silly question, but how does a functor guarantee structure preservation? What's to stop my functor to implement fmap as id?
22:00:37 <n_blownapart> erisco scratch that. I took out Ord and it worked as expected, but I think I failed to save my .hs file  . 
22:00:46 <n_blownapart> thanks for the help 
22:01:18 <erisco> dminuoso, well id cannot work because that would be a type error, but there is nothing preventing you from violating the Functor laws
22:01:19 <n_blownapart> I took out Ord *from the 2nd example
22:02:28 <erisco> dminuoso, you can, however, use -XDerivingFunctor and not worry about it ;)
22:02:40 <dminuoso> erisco, but id . id = id, so when fmap x = id, are they not still presered?
22:03:02 <erisco> dminuoso, that just will not type check, so I don't quite know what you are saying
22:03:13 <erisco> :t \x -> id
22:03:15 <lambdabot> t -> a -> a
22:03:19 <erisco> :t fmap
22:03:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:03:41 <penteract> that typechecks
22:04:04 <penteract> *oops
22:04:36 <erisco> if it would, then we would see this give the same type as fmap
22:04:43 <erisco> :t [\x -> id, fmap]
22:04:44 <lambdabot> Functor f => [(a -> a) -> f a -> f a]
22:05:09 <erisco> but we don't, we see for the two types to agree that fmap had to be specialised, so this implementation will not work
22:05:17 <penteract> Yeah, I'm up too late
22:05:51 <erisco> :t (\x -> id) `asTypeOf` fmap
22:05:53 <lambdabot> Functor f => (a -> a) -> f a -> f a
22:06:03 <erisco> I learned about that function yesterday so I may as well use it :P
22:06:54 <erisco> also we can just directly ask if \x -> id can be typed the same as fmap
22:07:02 <erisco> :t \x -> id :: Functor f => (a -> b) -> f a -> f b
22:07:04 <lambdabot> error:
22:07:04 <lambdabot>     • Couldn't match type ‘a1’ with ‘f1 a1’
22:07:04 <lambdabot>       ‘a1’ is a rigid type variable bound by
22:08:08 <erisco> dminuoso, if you're asking if it is possible to violate the Functor laws then, yes, they can be violated
22:08:29 <c_wraith> instance Functor [] where fmap _ _ = []
22:08:39 <c_wraith> it type-checks!
22:11:19 <dminuoso> erisco, ah okay I see what you are getting at. :)
22:11:34 <dminuoso> c_wraith, yeah I was thinking about something along those ways.
22:12:00 <dminuoso> c_wraith, but I think it still fully applies, its just that the structure embedded is just a kitchen sink.
22:12:21 <c_wraith> dminuoso: well, it utterly fails the law that fmap id = id
22:15:45 <erisco> but does not fail fmap g . fmap f = fmap (g . f) though you can fail that one too if you try
22:37:35 <ReinH> Not if you pass fmap id = I'd though. ;)
22:37:47 <ReinH> id. Thanks autocorrect.
22:59:02 <norc_> Trying to grasp why the monad interface of lists are useful, is there some common theme for it?
23:00:11 <norc_> I mean Ive played around with it for a while, and I see what it does and all examples I have seen have just been doing some list >>= \a -> [a, a*2] shenanigans, but that does not seem very useful
23:00:55 <erisco> norc_, don't use it then
23:01:07 <kadoban> norc_: It's a way to express non-deterministic computation. Or in simpler terms, you can write really concise brute-force searches and whatever nonsense in it.
23:02:56 <[exa]> norc_: apart of the fact that the list comprehension is a special case? you can also do prolog-ish stuff on that
23:05:49 <norc_> kadoban: Aha! Okay I got an idea then, let me go back to the editor. :-)
23:11:20 <norc_> kadoban: Aha, and by non-deterministic computation you mean a computation that has multiple possible outcomes, say the toss of a coin?
23:13:49 <kadoban> Yep
23:16:52 <pacak> > [(x, y) | x <- [1..10], y <- [1.. 10], x > y, x + y == 3]
23:16:55 <lambdabot>  [(2,1)]
23:17:25 <pacak> A brute force search. Not very efficient but simple. Just describe whatever you need.
23:23:33 <norc_> pacak: I see, not sure how that is >>=, but I have a program in the making!
23:24:12 <clmg> Looking for a language for distributed networking. Ideally functional, but speed is more important.
23:24:15 <pacak> > [1..10] >>= \x -> [1..10] >>= \y -> guard (x > y) >> guard (x + y == 3)
23:24:17 <lambdabot>  [()]
23:24:25 <pacak> > [1..10] >>= \x -> [1..10] >>= \y -> guard (x > y) >> guard (x + y == 3) >> return (x, y)
23:24:28 <lambdabot>  [(2,1)]
23:24:35 <clmg> I'm looking at Erland, Haskell, Go, and Common Lisp. Any others I should check out?
23:24:39 <norc_> clmg: Erlang/Elixir are obvious choices
23:24:51 <pacak> norc_: list comprehension is just a sugar.
23:24:55 <clmg> norc_: ah I forgot about elixir.
23:25:03 <pacak> clmg: Haskel, Haskell and Haskell.
23:25:11 <pacak> The rest is meh.
23:25:39 <clmg> pacak: Haskell is much faster than erlang
23:25:48 <pacak> Maybe CL is interesting to look at - but only to understand why you need types and stuff.
23:25:48 <clmg> right?
23:26:24 <clmg> pacak: I'm most familiar with lisp. haskell goes over my head sometimes but it's doable.
23:26:26 <pacak> Languages are not faster than each other. Implementations are. Plus they depend on algorithm used.
23:27:11 <clmg> pacak: why haskell > erlang?
23:27:36 <clmg> pacak: and why do you say "...only to understand why you need types and stuff." What "stuff"? Why types?
23:27:43 <pacak> For me - I can easily refactor a program with  100k LOC
23:27:51 <norc_> pacak: Trying to reason about how haskell performs seems incredibly complicated though.
23:28:46 <pacak> clmg: Change one thing - ghc will tell you exactly what else you need to change. Monads are possible even in javascript and php, but without help from typechecker you are going to suffer.
23:29:13 <pacak> Stuff - preexisting typeclasses with laws
23:29:47 <c_wraith> norc_: that's not really true.  It's just different.  You have a new set of performance habits to pick up, and a new model of performance.  But it's no more complicated than the model you've got for other languages.  It's just unfamiliar.
23:30:01 <halogenandtoast> clmg: When you say speed is important, do you mean how fast the program runs? I hear you can write the fastest programs in Assembler, but the speed at which you write said program is probably way slower.
23:30:38 <clmg> pacak: barring other features of a language, I'm really just looking at concurrency and peformance
23:30:55 <norc_> halogenandtoast: that is generally incorrect.
23:31:05 <pacak> clmg: Haskell can do both.
23:31:08 <halogenandtoast> norc_: I was just trying to make a point.
23:31:51 <halogenandtoast> And I stated it as "I hear you can"
23:31:57 <halogenandtoast> not that is was a truth :p
23:32:42 <clmg> Oh I forgot about clojure. that could work, too. and it's a lisp.
23:32:53 <dsal> I've enjoyed programming in erlang in the past.  There aren't that many types, but you can do neat things with them.
23:33:24 <dsal> I'm pretty happy not to be around JVMs anymore.  It's been years.  :)  And when I did play with them on occasion, it was via clojure just to make it bearable.
23:33:43 <halogenandtoast> the JVM is currently the only reason I won't use clojure.
23:33:53 <norc_> dsal: The thing erlang should be used for is OTP.
23:33:55 <dsal> My previous job was erlang + c++.  My current job is motly go.
23:34:03 <norc_> If you dont want OTP, erlang is a pretty annoying language. :P
23:34:07 * pacak likes Haskell
23:34:09 <clmg> halogenandtoast: yep. it's not really free software either, is it.
23:34:13 <clmg> jvm i mean
23:34:18 <dsal> heh.  OTP has some neat parts.
23:34:31 <dsal> I do really like erlang's binary matching, though.  Does haskell have anything like that?
23:35:14 <clmg> dsal, norc_: what's wrong with OTP?
23:35:17 <halogenandtoast> clmg: As far as I can tell, it's complicated.
23:35:54 <norc_> clmg: When people say "erlang is great for failsafe distributed systems that can scale" they really mean to say "OTP is great for...."
23:36:00 <halogenandtoast> norc_: to that point, I once tried to write a sokoban implementation in Haskell (a game where a guy pushed around rocks/crates) and I gave up.
23:36:05 <halogenandtoast> s/Haskell/Erlang/
23:36:33 <halogenandtoast> It can be done, but as you said it gets annoying.
23:36:33 <pacak> dsal: binary matching?
23:37:00 <dsal> pacak: erlang has a syntax for doing pattern matching over binary data.  e.g. http://dustin.sallings.org/2009/10/11/ememcached.html
23:38:27 <pacak> dsal: So in "process_message" it gets binary data and instantly parses it into those fields?
23:38:53 <dsal> Yeah.  It's just a big wad of bits.  They're all big endian, but you can specify that per field, too.
23:39:08 <dsal> <<x>> is raw binary blog syntax
23:39:29 <pacak> Attoparsec parser for that will be something (,,,,,) <$> int64 <*> int64 ...
23:39:35 <dsal> Note some of those values are constants.  It's doing value matching as well as assigning numbers and stuff into places.
23:39:36 <norc_> c_wraith: Fair enough, it feels like you have to understand GHC though.
23:40:02 <norc_> c_wraith: I mean in order to evaluate how my C++ program performs, very basic compiler and architecture knowledge gets you very far already.
23:40:32 <norc_> But perhaps my opinion will change when I learn more about Haskell
23:40:38 <c_wraith> norc_: you call it "basic", but there's a ton of it.
23:41:06 <norc_> c_wraith: Heh, well I have written my own C compiler already, a kernel.. so I understand precisely what happens for any C code I write.
23:41:09 <c_wraith> norc_: why is a pointer dereference slow?  That's really important, but not at all basic.
23:41:39 <kadoban> norc_: It does definitely get easier. I have no idea how it compares to other languages honestly, in terms of ease. I suspect that a lot of it comes from people spending years in C-ish model and then come to haskell though.
23:43:49 <norc_> c_wraith: the question of how cache affects your program is just as relevant in haskell, but in C its obvious that a pointer deference happens exactly in that place
23:46:54 <c_wraith> norc_: where pointer dereferences happen is just as obvious in Haskell..
