00:01:16 <pimlu> is this the "right" way to make an infinite array, btw? or is there a better way?
00:01:21 <jared-w> nshepperd_: so the trick here would be to make sure that only a certain static number of constructors needs to be observed, correct? (Either through !! or some other method) and most everything else shouldn't add much to the meomry usage?
00:02:05 <jared-w> pimlu: Well, to be honest... Why are you using an array anyway?
00:02:42 <pimlu> basically, a function was memoized using the list accessor style
00:02:51 <pimlu> but the problem is, that's O(n) automatically
00:03:14 <pimlu> so this makes it O(1) after calling it once using the same style of code
00:04:53 <nshepperd_> I don't know what the "right way" is. This is the sort of thing i would think of though. A lazy array of arrays that double in sized
00:05:33 <pimlu> I see, thanks
00:05:38 <nshepperd_> There's probably something similar in... the memoize library?
00:07:19 <nshepperd_> Normally when i memoize a function i just directly use an array, but that requires me to know how big the input gets
00:10:20 <pimlu> makes sense
00:14:53 <lyxia> tsahyt: http://lpaste.net/357479
00:15:05 <ertes-w> elo
00:15:24 <tsahyt> lyxia: thanks! why is HList a data family here?
00:16:50 <lyxia> No particular reason.
00:18:46 <pimlu> nshepperd_: so, following this route, if I make my own zip that has a lazy pattern on the second parameter, it now works
00:19:02 <pimlu> since it doesn't use info about the spine of arrs
00:22:55 <tsahyt> lyxia: it does work indeed, although the argument order is reversed
00:24:12 <lyxia> oh I forgot to reverse at the end
00:27:29 <jle`> i don't think HList as a data family is nearly as useful as it as a GADT
00:27:51 <jle`> since you can't pattern match on its constructors as a parameter
00:29:15 <butterthebuddha> Anybody here use Emacs?
00:29:31 <jared-w> Yup
00:30:12 <butterthebuddha> Which packages do you use?
00:30:28 <butterthebuddha> I need to set up completion and linting
00:30:30 <jared-w> Spacemacs with assorted odds and ends bolted on, but spacemacs does 99% of the work for Haskell
00:31:24 <cocreature>  if you use stack, intero is very easy to setup and provides pretty good tooling
00:31:48 <butterthebuddha> Never actually heard of stack
00:31:54 <butterthebuddha> (New to Haskell)
00:31:55 <lyxia> tsahyt: http://lpaste.net/357479 fixed
00:32:34 <tsahyt> oh, this became a much greater change than I thought. thanks! I guess I'll have some reading to do now
00:32:37 <jared-w> You should probably look into stack. It's fairly painless to use once you figure out how to use it for simple things and intero works great with emacs. It's basically 'out of the box' everything
00:33:50 <bvad> jared-w: when is something not simple enough for intero to work great? 
00:34:14 <bvad> wait, I think I misread 
00:34:25 <jared-w> bvad: it's not intero, it's stack. If you don't know how to use stack, setting up a multi-module stack project is a bit painful. Sorry, I could've been more clear in stating that
00:35:06 <jared-w> (I still have no idea how to do anything more complex in stack than very basic multi-module projects)
00:35:50 <bvad> jared-w: I don't think it's too hard, but figuring it out the first time might be a bit of a hassle 
00:35:59 <butterthebuddha> I'm currently using haskell-mode
00:36:02 <ertes-w> butterthebuddha: as an alternative there is also haskell-mode, which unlike intero does require a bit of setup, but does not depend on stack
00:36:15 <butterthebuddha> Which, yep, requires some setup
00:36:20 <ertes-w> butterthebuddha: (it requires setup, if you want GHCi integration)
00:36:52 <butterthebuddha> But I've already put in the work for ghc/ghci integration
00:37:52 * hackagebot req 0.4.0 – Easy-to-use, type-safe, expandable, high-level HTTP library – https://hackage.haskell.org/package/req
00:38:45 <jared-w> bvad: it's not really that it's /hard/ it's that I haven't really found a nice tutorial yet that explains what everything does, how to use it, and gives examples of increasingly complex projects. The documentation, for some reason, is fairly unhelpful for me even though I've read it before ¯\_(ツ)_/¯
00:40:21 <ertes-w> butterthebuddha: then you should already have completion…  i don't know about linting though
00:40:37 <butterthebuddha> Haskell-mode doesn't seem top provide completion
00:40:50 <ertes-w> butterthebuddha: there is probably hlint integration, if you like it…  personally i disagree with hlint more often than i agree, so it's a matter of taste =)
00:41:03 <butterthebuddha> They say they do in their manual but i can't figure out how to set that up
00:41:09 <ertes-w> butterthebuddha: it does, but you need to actually load the module
00:41:09 <butterthebuddha> Which is why I'm setting up company
00:41:31 <ertes-w> butterthebuddha: i don't use company, and it completes for me
00:41:57 <bvad> jared-w: yeah that's what I meant :) 
00:42:15 <bvad> butterthebuddha: There's also dante, it's a fork of intero that doesn't require stack
00:42:26 <ertes-w> butterthebuddha: which function are you invoking for completion?
00:42:34 <bvad> butterthebuddha: The completion doesn't seem quite as nice as intero's though
00:43:43 <butterthebuddha> I might end up using intero
00:43:49 <butterthebuddha> Is it still actively-maintained?
00:44:07 <bvad> https://github.com/commercialhaskell/intero/commits/master seems like it 
00:44:48 <butterthebuddha> How does it compare with haskell-mode in terms of feature parity?
00:45:20 <jared-w> ertes-w: I like hlint mostly because it shows me different ways I can write my code. I'm still enough of a beginner that its suggestions are often helpful
00:46:56 <ertes-w> jared-w: it does want you to use a particular style by default, and i don't want to put in the effort to encode my own style, if that's even possible
00:47:18 <butterthebuddha> I feel like that might be useful for a beginner
00:47:20 <jared-w> hlint?
00:47:26 <butterthebuddha> Because I don't have "my own style" yet
00:47:32 <butterthebuddha> And my code is more likely to be sphaghetti than not
00:47:38 <ertes-w> and some of its suggestions are just bullshit in my view: (maybe _ id) → "why not use fromMaybe?"
00:48:05 <jared-w> Why is that bullshit? 
00:48:23 <jle`> fromMaybe requires an import and is longer to type
00:48:40 <jared-w> Also, idk if I would really call the suggestions "style" but I can definitely see where you're coming from with that. Ahh right, if it require an import, that's a dumb suggestion
00:48:46 <ertes-w> because it wants you to import Data.Maybe and use a special case of a fairly simple function that is basically just a degenerated version of 'maybe'
00:49:23 <jle`> > (length "fromMaybe _", length "maybe _ id")
00:49:26 <lambdabot>  (11,10)
00:49:39 <jle`> i got to save rooms on my punch cards
00:49:52 <ertes-w> imagine that there were a function listToList that is basically just foldr, but with the second argument hard-coded to be []
00:50:06 <ertes-w> and you would have to import Data.List to use it
00:50:13 <tsahyt> lyxia: I've adapted the code to my use and it works beautifully, thanks a lot!
00:50:18 <ertes-w> any suggestion to prefer that function over foldr would be bullshit =)
00:50:34 <cocreature> “foldl is useless because it’s just a special case of foldr”
00:50:40 <cocreature> I’m not sure I buy that argument
00:51:05 <Axman6> it's technically true, but not really usefully true
00:51:13 <tdammers> by that logic, most Haskell programs are useless because they are just special cases of IO
00:51:18 <jared-w> That's a bit of a pedantic nitpick though. I'd be shocked if fromMaybe had wildly different performance and evaluation semantics :p
00:51:27 <ertes-w> cocreature: foldl is not as trivial a special case of foldr as fromMaybe is of 'maybe'
00:52:07 <ertes-w> cocreature: fromMaybe is literally just 'maybe' with one argument hardcoded, and it's longer to type as well…  so there is extra conceptual/mental complexity + more imports + more code
00:52:19 <cocreature> sure I was exaggerating. but I still think `fromMaybe` is a sufficiently common pattern that it’s worth having a separate name for it
00:52:50 <ertes-w> cocreature: there is a better pattern in those cases: Foldable =)
00:53:09 <jared-w> For what it's worth, I agree; however, I do think that having a linter suggest a code pattern which requires an extra import you don't have... kinda dumb. It's one thing if you already have Data.Maybe imported for whatever reason
00:54:02 <cocreature> just use a custom prelude that exposes fromMaybe :P
00:54:12 <ertes-w> i would still use 'maybe'
00:54:23 <jared-w> Brilliant. That'll totally save me all those lines of code
00:54:40 <jle`> call it `fromMay` and it'll be short enough to edge out maybe _ id
00:54:55 <jared-w> ertes-w: yeah but you're already like 2 years away from going 100% "get off my lawn" anyway, so...
00:54:59 <jle`> that'll save me all those columns of code
00:55:34 <ertes-w> jle`: even if it were called 'm' i would still use 'maybe _ id' =)
00:55:46 <jared-w> jle`: what about fm? It's short and to the point; plus it has the added benefit of being way too short to be a useful name so people will think Haskell sucks if they ever see it in code
00:56:04 <jle`> avoid success at all costs
00:56:20 <jle`> to be honest though having hlint when i started learning haskell did help
00:56:33 <jle`> since there were some objectively silly things i did
00:56:41 <jle`> foo = do
00:56:44 <jle`>   putStrLn "i'm foo"
00:56:53 <jle`> and i didn't realize i didn't need a 'do' there
00:57:11 <jle`> also i used to always do
00:57:16 <jle`> if x then return y else return z
00:57:25 <jle`> instead of just return (if x then y else z)
00:58:22 <jared-w> hlint is also pretty smart about suggesting simplifications whenever I'm stupid enough to write something like if (comparison) rather than just using the comparison straight out
00:59:22 * hackagebot hmpfr 0.4.3 – Haskell binding to the MPFR library – https://hackage.haskell.org/package/hmpfr
01:01:35 <frerich>  I think hlint sometimes gives nice food for though, but I also had cases where it actually suggested pessimizations (I had a very tight loop where it suggested to use 'foldM' but that made things slower by a factor of 3 because foldM apparently did not get inlined). I guess there's a reason after all why hlint merely emits 'suggestions' and lets the programmer decide instead of just applying the changes directly. :-)
01:01:46 <ertes-w> some of the suggestions make your code objectively better, but too many of them are opinionated
01:02:15 <cocreature> hlint is fine as long as you see it as something providing suggestions and not as strict rules that you should follow
01:02:18 <cocreature> at least in the default config
01:02:31 <jared-w> Clearly we need a config designed by ertes-w... :p
01:03:09 <ertes-w> heh
01:03:32 <cocreature> a config designed by henning that suggests that you rename all types to T and all classes to C
01:03:40 <ertes-w> i'm gonna write my own linter
01:03:42 <ertes-w> hcynic
01:04:01 <frerich> :^)
01:04:35 <ertes-w> hahaha yeah…  i remember trying to work with the 'sample-frame' library
01:05:22 <ertes-w> module-oriented programming
01:05:25 <jared-w> lol. I wonder if one could make a hlint config designed to make your code as obfuscated and annoying/painful to read as possible
01:06:01 <jared-w> point-free /all/ the things, rename everything to one letter functions, etc... It might be kinda funny
01:06:12 <ertes-w> jared-w: no, but lambdabot has an obfuscator built in…  it's called "perl-like", and the command is "@pl"
01:06:38 <jared-w> ertes-w: oh right, that one. I've used it to great effect before
01:08:03 <jared-w> anyway I'm off to bed. I've got 9 hours or so of driving to do tomorrow 
01:09:16 <jle`> drive safe! :)
01:16:40 <trigone> hi, is there a way to write a function polymorphic on the type of MonadReader, but monomorphic on the monoid? i can't get the signature right...
01:16:46 <mniip> how the hell does aeson 47 MB/s
01:16:54 <mniip> how the hell does aeson advertise* 47 MB/s
01:17:11 <jle`> trigone: not exactly sure what you mean
01:17:16 <jle`> what is 'the monoid'?
01:17:17 <cocreature> trigone: do you have some example code?
01:17:31 <trigone> oops i meant MonadWriter
01:17:58 <cocreature> something like "MonadWriter (Sum Int) m => …"
01:18:01 <cocreature> ?
01:18:27 <trigone> cocreature: well i guess, i couldn't get it right... it didn't allow it without adding extensions, and i was wary of doing so
01:18:27 <jle`> trigone: what have you tried, and what is the error?
01:18:33 <jle`> oh
01:18:40 <cocreature> trigone: FlexibleContexts is a pretty harmless extension
01:18:42 <jle`> MonadWriter itself isn't allowed without extensions, heh
01:18:49 <jle`> MonadWriter requires MultiParamTypeclasses
01:19:22 <trigone> hm ok... so it's the only way? just to check
01:19:26 <jle`> FlexibleContexts and FlexibleInstances are really things that haskell should have had/was probably intended to have in the first place anyway
01:19:33 <jle`> trigone: using MultiParamTypeclasses?
01:19:55 <jle`> in standard Haskell, typeclasses can only have one parameter
01:19:58 <trigone> jle`: ok! what is the meaning of "flexible" in "flexibleBla"?
01:20:06 <jle`> so MonadWriter does not exist in standard haskell at all
01:20:16 <jle`> you're already writing in ghc haskell just by using mtl :)
01:20:28 <trigone> jle`: no, i know, i meant it's the only way to write a function as i described above using flexiblecontexts
01:20:46 <mniip> trigone, in standard haskell contexts are fairly restricted
01:21:00 <jle`> without flexible contexts, you can only have polymorphic arguments
01:21:01 <mniip> to the a shape like '(C1 a1, C2 a2...)'
01:21:12 <trigone> jle`: it doesn't bother me, i'm just not yet sure what kind of extension is inevitable and useful without drawbacks, and what kind implies smell code or bad design
01:21:15 <mniip> with flexiblecontexts, Constraint behaves more like a category
01:21:15 <jle`> or, if you use a type constructor, the type constructor must have polymorphic parameters
01:21:24 <orzo> I'm needing to represent the property of a type that it is serialized always to the same fixed size.  I'm currently using Storable, but it feels like an imperfect fit.
01:21:35 <cocreature> FlexibleContexts and FlexibleInstances are two things that I turn on without even thinking about it :)
01:21:45 <jle`> FlexibleContexts and FlexibleInstances are things that i feel like haskell probably meant to include in the first place
01:21:49 <cocreature> the only downside is that it makes it slightly easier to write overlapping instances
01:22:00 <orzo> Anybody got a better idea for fixed-size serializations?  Something along the lines of Serialize/Binary
01:22:04 <jle`> like they didn't even realize that standard haskell didn't let us do this
01:22:19 <mniip> FlexibleContexts are cool, FlexibleInstances... eee gotta be careful
01:22:24 <trigone> cocreature: hm... what happens when you have overlapping instances? compile error or runtime problems?
01:22:24 <cocreature> but as long as you don’t actually add OVERLAPPING/ABLE pragmas ghc will still yell at you
01:22:31 <jle`> the haskell standard writers probably came back and said
01:22:36 <cocreature> and even with those pragmas it’s not a runtime error
01:22:41 <jle`> "what the heck i thought you could do that, i didn't realize that when we were writing the standard"
01:22:52 <cocreature> the behavior is just a bit weird and can easily break if you import modules
01:22:56 <trigone> cocreature: ok good :)
01:23:17 <jle`> trigone: normally, for instances, if you have a type consturctor, the instance has to be over a polymorphic type parameter
01:23:25 <jle`> trigone: so you can have an instance Show (Maybe a)
01:23:34 <jle`> and a constraint Show (Maybe a) =>
01:23:42 <jle`> the 'a' has to be polymorphic, in standard haskell
01:23:53 <orzo> i try to avoid UndecidableInstances too
01:23:57 <jle`> so you can write Show (Maybe Int) => ...
01:24:34 <jle`> trigone: you could probably write Num a => MonadWriter (Sum a) m => ..., without FlexibleContexts, actually
01:24:49 <trigone> well i tried MonadReader (Foo n) m, didn't work... at least i think so...
01:25:17 <trigone> i'm suddenly doubting
01:25:42 <orzo> ghc used to infer flexible contexts without allowing you to write them.  That's further evidence that it was an intended thing for Haskell
01:26:16 <cocreature> orzo: well it used to do that for all extensions so I’m not sure that’s evidence for anything.
01:26:20 <jle`> oh yeah it does require FlexibleContexts
01:27:00 <jle`> oh yeah, even Show (Maybe a) is illegal in vanilla Haskell
01:27:21 <orzo> dont understnad your point.  It's evidence that ghc authors figured these things ought to work even though haskell forbid writing them
01:27:25 <jle`> you can only have 'Show a', on like, a completely simple type variable
01:27:37 <jle`> so in vanilla haskell you can only have MonadWriter w m
01:27:38 <trigone> at any rate, what'd be the right side of MonadWriter X m => ? like, m is supposed to basically "contain" X, but i can't actually put X on the right side, so do i just use `m` and expect the context to imply that the monoid of the monadreader `m` is X?
01:27:54 <jle`> monadreader?
01:28:12 <jle`> m is your monad
01:28:18 <jle`> so look at something like tell
01:28:21 <jle`> :t tell
01:28:22 <lambdabot> MonadWriter w m => w -> m ()
01:28:48 <jle`> 'm' is a MonadWriter, whose context is w
01:29:03 <jle`> i actually like to think of those mtl types in their partially applied form
01:29:21 <orzo> how is the "alignment" method used for Foreign.Storable?  What's the impact of setting that oddly?
01:29:28 <jle`> a `(MonadWriter Int) m` constraint means that m has a (MonadWriter Int) instance
01:29:38 <jle`> where a (MonadWriter Int) instance means that you have an Int log
01:29:49 <jle`> er, Int accumulator
01:29:50 <trigone> jle`: ok, so m contains w implicitly, in an opaque way? including if w is partially or completely defined via flexibleContexts? just to check i understand
01:29:57 <orzo> Why not default alignment to sizeOf ?
01:30:07 <jle`> m doesn't have to contain w implicitly
01:30:13 <cocreature> orzo: “alloca” uses it to give you back aligned memory
01:30:38 <jle`> trigone: `(MonadWriter w) m` means that m can be "told" w's
01:30:47 <jle`> and this we only know because of what is in the MOnadWriter typeclass
01:31:13 <jle`> class MonadWriter w m | m -> w where tell :: w -> m ()
01:31:29 <jle`> it doesn't necessarily mean that `m ()` has to contain any w's
01:31:43 <jle`> all it means is that there exists a fucntion tell :: w -> m ()
01:31:47 <orzo> is that pretty much it, cocreature ?
01:31:54 <ertes-w> orzo: the impact of misalignment is usually worse performance on modern architectures
01:32:06 <jle`> trigone: m might potentially not contain any w's at all, implicitly or explicitly
01:32:15 <jle`> trigone: the only guaruntee is that there is some function available to you, tell :: w -> m ()
01:32:27 <jle`> what m does with that w is up to its whim
01:32:35 <trigone> jle`: ok, but that's what i meant (in a badly described way). anyway, sure tell could just be tell = const (pure ()), but it'd not really be very useful, would it? a priori, tell outputs a m() which somehow was built out of the w value, which is not really something you can do in tons of ways
01:32:45 <cocreature> orzo: there are probably some other methods that rely on it for allocating aligned method but I would say “alloca” is probably the most common one
01:33:32 <jle`> trigone: that's up to the person who wrote the MonadWriter instance
01:33:53 <trigone> jle`: sure :) thanks everyone!
01:34:24 <trigone> is Applicative superclass of monad or is it the opposite?
01:34:27 <jle`> no problem :)
01:34:33 <jle`> applicative is a superclass of monad
01:35:01 <jle`> oh, one example of a 'tell' to an m that might not contain any w's is the MonadWriter instance for `WriterT w Maybe`
01:35:05 <EvanR> monads are a special kind of applicative
01:35:11 <jle`> or better yet, `WriterT w Proxy`
01:35:42 <ertes-w> > (alignment (), sizeOf ())
01:35:44 <trigone> k :) so, is there a subclass (is that the correct term?) of Monoid that allows a tree-like structure to be built, with a special method to create a branch on a lower level of the tree? not sure if i'm very clear...
01:35:44 <lambdabot>  error:
01:35:44 <lambdabot>      Variable not in scope: alignment :: () -> t1error:
01:35:44 <lambdabot>      • Variable not in scope: sizeOf :: () -> t
01:35:52 <jle`> for instance MonadWriter w (WriterT w Proxy), tell = const (WriterT Proxy)
01:36:00 <ertes-w> @let import Foreign.Storable
01:36:02 <lambdabot>  Defined.
01:36:04 <ertes-w> > (alignment (), sizeOf ())
01:36:06 <lambdabot>  (1,0)
01:36:07 <jle`> see, it ignores the 'w' :)
01:36:23 <EvanR> trigone: is that really a class.. or more like a specific single data structure
01:36:26 <ertes-w> orzo: maybe an extreme example, but an example nonetheless =)
01:36:41 <jle`> > runWriterT (tell "hello") :: Proxy ((). String)
01:36:43 <lambdabot>  <hint>:1:39: error:
01:36:43 <lambdabot>      Illegal symbol '.' in type
01:36:43 <lambdabot>      Perhaps you intended to use RankNTypes or a similar language
01:36:45 <jle`> > runWriterT (tell "hello") :: Proxy ((), String)
01:36:47 <lambdabot>  Proxy
01:37:02 <jle`> there's a MonadWriter instance that doesn't contain any w's
01:37:05 <trigone> jle`: well that's weird, but i don't know what Proxy is so :) and Maybe is just cheating :P
01:37:29 <jle`> data Proxy a = Proxy
01:37:34 <jle`> and WriterT over Maybe is a very normal thing
01:38:40 <trigone> EvanR: i think there's more than one type of data that could have a tree-like shape where you'd mappend either at the same level, or you'd add a sublevel structured like the floor level... but ofc i can make it monomorphic, i was just wondering
01:38:45 <jle`> but yeah, my point was that the 'm ()' might not contain any w's, and the only requirement is that there is some function `tell :: w -> m ()` available to you, which may or may not be a silly one
01:39:27 <EvanR> you might be thinking of providing a record of functions as an interface... but because youre specifically talking about a tree, it sounds like you want a tree
01:39:28 <trigone> jle`: what's the usage of proxy?
01:39:47 <cocreature> mostly passing type arguments before we had -XTypeApplications
01:39:53 <jle`> those were dark times :)
01:41:07 <jle`> `Proxy a` is just `Maybe a` without a Just constructor
01:41:09 <jle`> what's the problem? ;)
01:41:18 <cocreature> lol
01:41:24 <cocreature> I hadn’t heard that explanation before :)
01:41:31 <trigone> cocreature: ok :) so basically, you'd call the function with say (Proxy :: Proxy Int) and it was expected to do something different depending on the phantom type?
01:41:45 <trigone> jle`: so, it's the PessimisticMaybe?
01:42:03 <orzo> Is there any type class that associates a byte-lenght with a type other than Storable?
01:42:06 <trigone> or perhaps Unlucky a = FatChance
01:42:43 <orzo> This is network code with serialization of packets, but I want to encoded the lengths in the types
01:43:41 <orzo> I guess I should just make my own
01:44:44 <trigone> is there a data Proxys a b = Proxy?
01:44:55 <cocreature> orzo: what exactly do you want that typeclass to do? just provide a sizeInBytes :: a -> Int method?
01:45:04 <trigone> s/Proxy/Proxys)
01:46:05 <orzo> yes, but I ant it pretty clear that it is on the type, not the vlaue, and also that it is general serialization, not cpu-dependent encoding
01:46:19 <orzo> but, yes, that's it's all
01:46:43 <trigone> well, thanks much again everyone, bye :)
01:46:54 <cocreature> orzo: tbh I would question whether you should make a typeclass for that instead of just requiring that users pass the size explicitely
01:47:14 <ertes-w> orzo: what's the purpose?  avoiding a length field in the serialised data?
01:48:18 <orzo> well, i have a type closely matching the serialization and i want it to be documenting of the protocol while also being a decent representation
01:49:18 <ertes-w> orzo: usually if you use 'binary', then length fields will only be present where they are necessary
01:51:17 <orzo> i'm not designing the serialization, i'm working forma fixed spec
01:54:27 <orzo> Actually, Itd be nice to use Serialize/Binary but have just an extra addon to indicate the type's width is known in advance
01:55:04 <dysfun> you mean a length field?
01:55:04 <orzo> and have it infer that known width with derived instnaces
01:55:42 <gargawel> barrucadu: Hi ! I am observing some huge memory consumption using dejafu on some proprietary code. Memory usage is increasing linearly over tests, reaching ~15 GiB on the original program (until crash). I actually have no idea if the problem is in my code or in deja-fu ; would you by chance have some suggestions on where to start to investigate ?
01:55:52 <cheater> hi
01:56:00 <cheater> i am having this issue when installing hmatrix: http://sprunge.us/QFdh
01:56:16 <cheater> does anyone know how to solve this? this exists both in 0.18.0.0 and 0.17.0.2.
01:56:32 <cheater> i am compiling this using 8.2.1.
01:56:34 <orzo> well, i want to be able to split out ByteStrings without parsing them, because they have to be decrypted
01:56:55 <orzo> I have a type Encrypted a
01:57:14 <orzo> which represents a bytestring that is serialized 'a' but encrypted
01:57:20 <cocreature> cheater: does adding the constraint solve this?
01:57:27 <orzo> so such a thing itself is serializable
01:57:36 <orzo> since its just a fixed number of bytes
01:58:03 <barrucadu> gargawel: Could you share some details of your tests?  Do you have a lot of threads?  Are they running for a long time?
01:59:16 <cheater> cocreature: i have not tried patching hmatrix yet.
01:59:47 <cheater> hmm looking at the hackage build matrix 0.17.0.1 does not fail, so let me just try to use that instead.
02:00:02 <ertes-w> orzo: Storable kinda does that, but unfortunately it's also tied to a platform-dependent memory layout…  you basically need to come up with your own variant of Storable that encodes exactly the format you need
02:00:16 <phz_> hey, does length evaluate to WHF or WF?
02:00:20 <phz_> I can’t never remember
02:00:26 <cocreature> cheater: https://github.com/albertoruiz/hmatrix/issues/232
02:00:33 <phz_> I’d say it’s WHF
02:00:37 <cocreature> looks like building from the master branch should already work
02:00:43 <gargawel> barrucadu: I am modeling a few servers handling requests asynchronously, so I do have a few threads, I'd say one or two dozens top
02:01:01 <cocreature> phz_: do you mean whf and nf? I’m not sure what wf is supposed to be
02:01:15 <phz_> weak form
02:01:16 <gargawel> The linear increase over the course of 100 tests happens no matter how many servers I'm modeling
02:01:21 <cheater> oh wait, that doesn't work on the new base. bollocks
02:01:26 <cheater> cocreature: looking, thanks
02:01:38 <cocreature> phz_: huh what’s that?
02:01:56 <gargawel> They're not running for a long time, the tests are themselves pretty short
02:01:59 <phz_> if you a list like fix (x + 1:)
02:02:08 <phz_> if you call length on that list
02:02:19 <phz_> well, let’s say
02:02:27 <phz_> length . take 4 $ fix (x + 1:)
02:02:29 <cocreature> google doesn’t find any reference for weak form
02:02:35 <gargawel> barrucadu: I can share a heap profile, if that may be helpful.
02:02:41 <cocreature> at least not in the context of haskell
02:02:47 <phz_> cocreature: well, what are the other forms besides WHF then?
02:02:58 <cocreature> phz_: there is weak head normal form and normal form
02:03:09 <phz_> hm, I can’t remember the difference then :D
02:03:30 <cocreature> weak head normal form is evaluating until you reach a constructor or a lambda
02:03:37 <ertes-w> phz_: there are WHNF, HNF and NF, and we typically only differentiate between WHNF and NF
02:03:49 <cocreature> nf is evaluating until everything is evaluated or you reach a lambda
02:03:50 <phz_> ok, so what does length x result to?
02:04:39 <ertes-w> phz_: 'length' is strict in the spine of the structure
02:04:42 <cocreature> are you interested in what it evaluates "x" to or what the result of "length x" will be evaluated to?
02:04:42 <phz_> I guess it’s WHNF
02:04:59 <phz_> cocreature: I know we use length to evaluate somehow its argument
02:05:02 <phz_> but it’s not a deepseq
02:05:07 <phz_> so I guess it’s WHNF
02:05:20 <cocreature> no whnf would stop after the first constructor
02:05:24 <cocreature> not sure if there is a name for it
02:05:31 <ertes-w> phz_: length ⊥ = ⊥; length (⊥ : []) = 1; length (⊥ : ⊥) = ⊥
02:05:42 <EvanR> length normal form
02:05:48 <phz_> well
02:05:50 <ertes-w> we usually call that "spine-strict"
02:05:52 <phz_> my example above gives an idea
02:06:04 <phz_> length . take 4 $ fix (x + 1:)
02:06:16 <phz_> the x + 1 won’t be evaluated
02:06:19 <phz_> however, the fix will
02:06:24 <phz_> so does the take 4
02:06:29 <EvanR> length (repeat ⊥) = ⊥
02:06:33 <phz_> isn’t that WHNF?
02:06:41 <ertes-w> phz_: no
02:06:49 <ertes-w> length (⊥ : ⊥) = ⊥
02:06:53 <ertes-w> that's not WHNF
02:07:15 <phz_> > length [undefined, undefined]
02:07:18 <lambdabot>  2
02:07:27 <ertes-w> [⊥, ⊥] ≠ ⊥ : ⊥
02:07:42 <phz_> yeah, you’re right
02:07:42 <EvanR> > length (1 : undefined)
02:07:44 <lambdabot>  *Exception: Prelude.undefined
02:07:54 <phz_> > length . take 4 $ fix (x + 1:)
02:07:57 <lambdabot>  4
02:08:31 <phz_> ok so a WHFN is related to function application, seems like
02:08:33 <EvanR> what the
02:08:45 <phz_> ctor with partially applied args, built-in or lambda
02:08:48 <phz_> so what is a NF then?
02:09:07 <EvanR> thats like, deepseqing
02:09:34 <phz_> ok so NF is like “nothing left to evaluate”?
02:09:41 <EvanR> yes
02:09:42 <phz_> why can’t I find any materials online about that
02:09:55 <barrucadu> gargawel: A heap profile might be useful, but I bet it's because you have two dozen threads and dejafu currently keeps a lot of scheduling data in memory
02:09:58 <EvanR> maybe look at deepseq docs
02:10:23 <barrucadu> gargawel: If you don't need it to be exact, you could try the random scheduling mode I added
02:10:24 <EvanR> "normal form" and "nothing left to evaluate" are pretty common when reading about lambda calc
02:10:46 <phz_> ok
02:11:12 <cheater> cocreature: that seems to be the error indeed, thanks
02:11:13 <phz_> I see it’s related to graphs
02:11:19 <phz_> it’s easier to understand now
02:11:20 <phz_> thanks
02:11:37 <phz_> I’m reviewing a colleague code
02:11:46 <phz_> and he’s pattern matching on length x
02:11:51 <phz_> with 0 ->, 1 -> and _ ->
02:11:59 <phz_> and I say it’s not the right way to do 
02:12:10 <ertes-w> phz_: i think you're asking the wrong question
02:12:25 <phz_> he rather wants to pattern match on [_], [_, _] and _
02:12:47 <phz_> ertes-w: I wast just curious about the name we give to such an evaluation scheme
02:12:53 <phz_> I know what length does to a list
02:13:01 <phz_> it doesn’t inspect the content of the cell
02:13:04 <phz_> so it’s not strict in the content
02:13:10 <phz_> but it’s strict in the cons
02:13:16 <phz_> so it evaluates the whole list
02:13:23 <phz_> which is silly in the case of my colleague
02:13:34 <phz_> since he only needs the first two cells (without even inspecting them)
02:13:43 <EvanR> [_] and [_,_] would avoid traversing the whole list, if it happens to be longer
02:14:26 <EvanR> you cant compare length numbers until the number is fully calculated, unless of course.... you have lazy natural!
02:15:00 <phz_> EvanR: yeah
02:15:01 <phz_> that’s my point
02:15:05 <ertes-w> phz_: your question is in terms of forms, but it should be in terms of strictnes
02:15:08 <ertes-w> *strictness
02:15:16 <phz_> ertes-w: well, I know how it works
02:15:28 <phz_> I just wanted to label such an evaluation scheme :)
02:15:31 <phz_> and you said it
02:15:37 <phz_> spine-strict evaluation
02:15:46 <phz_> however, what is the form of the resulting list?
02:15:50 <phz_> nothing particular?
02:16:04 <gargawel> barrucadu: we're actually already using random scheduling
02:16:08 <EvanR> phz_: half baked
02:16:18 <phz_> alright :D
02:16:35 <EvanR> if that list isnt use after you take the length, it might not be anything
02:16:42 <EvanR> because promptly garbage collected
02:16:46 <ertes-w> phz_: well, feel free to come up with a name =)
02:16:56 <phz_> LF
02:17:01 <phz_> Length-Form
02:17:02 <phz_> :–’)
02:17:12 <ertes-w> define what a spine is, then call it "spine-normal form"
02:17:24 <barrucadu> gargawel: Oh, then that's surprising.  I'd like to see that heap profile then.
02:17:42 <frerich> phz_: I'd say it's a perfectly fine, normal, mundane list. You can take its length, you can take the first n elements, you can get the n'th elements, you can reverse it. Anything you like. :-)
02:17:58 <EvanR> er, what if you take the length of an infinite list, then what form is it in :)
02:18:07 <EvanR> these questions might not make sense
02:18:27 <phz_> EvanR: it’s bottom, I guess
02:18:36 <dysfun> EvanR: impractical form
02:18:36 <phz_> because lenght it’s strict in the cons 
02:18:44 <phz_> length*
02:19:20 <phz_> > const 3 (length [1..])
02:19:23 <lambdabot>  3
02:19:24 <ertes-w> phz_: the problem is that this form is not "normal" in any usual formal sense…  remember that the terms WHNF, HNF and NF all come from lambda calculus
02:19:39 <phz_> I know WHNF and NF
02:19:41 <phz_> but not HNF
02:19:44 <phz_> what is that?
02:19:47 <cheater> how do I understand the | in here? class Build d f c e | d -> c, c -> d, f -> e, f -> d, f -> c, c e -> f, d e -> f where
02:19:54 <phz_> cheater: fundep
02:19:58 <cheater> this is a functional dependency, right?
02:20:01 <cheater> phz_: right
02:20:01 <gargawel> barrucadu: here is a simplified version with only two nodes, using less memory: http://svgur.com/s/2VW
02:20:04 <phz_> if you have d, you have c
02:20:05 <phz_> etc. etc.
02:20:09 <EvanR> the first thing to know about HNF, you dont need to know about HNF
02:20:17 <EvanR> the second thing to know about HNF, 
02:20:22 <cheater> i don't know what it means that "if i have d i have c", could you elaborate a bit more?
02:20:33 <phz_> cheater: Build Int …
02:20:37 <phz_> if you do something like
02:20:44 <gargawel> Each ascending slope corresponds to a deja-fu test
02:20:46 <phz_> Build Int Foo Coo Ew
02:21:01 <phz_> d -> c says that you don’t have to provide Coo, it’ll be infered based on Int
02:21:09 <phz_> if you have Build Int …
02:21:21 <phz_> then c is 100% sure Coo
02:21:37 <cheater> how is it infered?
02:21:37 <phz_> it’s a way to tell the type system how to guess types
02:21:43 <phz_> you stated it
02:21:48 <orzo> If I use Applicative Get/Put to define my serialize interfaces, maybe I could simply swap out Get/Put with an Applicative that keeps track of the size
02:21:48 <phz_> take an easier example
02:21:51 <cheater> where?
02:22:11 <phz_> class Foo a b | b -> a where …
02:22:26 <phz_> here, b -> a is a way to tell GHC “b gives you a”
02:22:47 <phz_> cheater: shortly, you cannot have surjective functional dependencies
02:22:50 <cheater> ok so i can only have only one instance Foo a Int is that correct?
02:22:53 <phz_> yes
02:23:00 <phz_> Foo Int Char
02:23:02 <cheater> ok
02:23:10 <phz_> Foo _ Char -> _ is Int
02:23:17 <phz_> Foo Bool Char -> forbidden
02:23:20 <phz_> etc.
02:23:24 <phz_> EvanR: yes? :D
02:23:28 <phz_> EvanR: the second thing?
02:24:20 <EvanR> goto firstThing
02:24:25 <EvanR> its an infinite loop
02:24:30 <cheater> thank you phz_ 
02:24:58 <phz_> cheater: there’s a very famous use of fundep
02:25:02 <phz_> I think it’s in MonadReader
02:25:06 <phz_> if you have the monad type
02:25:10 <phz_> you have the environment
02:25:14 <phz_> (the thing you read)
02:25:22 <phz_> I’ve always thought that was silly
02:25:39 <phz_> class Monad m => MonadReader r m | m -> r where
02:25:39 <phz_> yep
02:27:12 <ertes-w> phz_: i don't remember what HNF is, i've never needed it
02:27:57 <barrucadu> gargawel: It does rather look like a memory leak in dejafu.  I'm at work currently, but I'll see if I can spot anything obvious.  If not I'll have a closer look this evening.
02:28:17 <ertes-w> phz_: i think it's a slightly stricter form of WHNF, but it probably doesn't really make a difference in our usual data encoding
02:28:41 <gargawel> barrucadu: Thanks ! :)
02:28:50 <gargawel> That's much appreciated.
02:29:34 <ertes-w> phz_: to come up with a normal form that accurately defines something like spine-strictness would require talking about fixed points, so it would get a bit more complicated
02:31:34 <gargawel> barrucadu: If you need something, or if we can help, please get in touch: gael.deest@tweag.io . You can also ping me on IRC, but I an not active 100% on the time, so I may miss your update.
02:33:19 <barrucadu> Will do
02:33:26 <phz_> ertes-w: ok then :)
02:33:36 <barrucadu> It's good to periodically get these performance issues and know that at least Tweag is still using my code :)
02:34:07 <gargawel> barrucadu: We are :) I was actually stress-testing dejafu to see how far we could scale.
02:34:48 <sqooq> ugh
02:34:56 <sqooq> I'm trying to zipWith a function
02:35:15 <sqooq> but the function is actually map f
02:35:31 <sqooq> but the two arguments of zipWith need to form like map (f x) y
02:35:37 <sqooq> what do
02:36:03 <raek> zipWith (\x y -> map (f x) y) foo bar
02:36:05 <ertes-w> sqooq: (zipWith (map . f))?
02:36:40 <ertes-w> :t \f -> zipWith (map . f)
02:36:41 <lambdabot> (a1 -> a -> b) -> [a1] -> [[a]] -> [[b]]
02:37:31 <sqooq> hmm
02:37:47 <sqooq> . worked seemingly
02:38:05 <sqooq> yup works perfectly
02:38:16 <cocreature> . for multi-argument functions can be a bit confusing
02:38:27 <sqooq> ye
02:39:03 <sqooq> ah shoot!
02:39:14 <sqooq> forgot to update the function
02:39:19 <sqooq> for new type
02:43:27 <sqooq> there's no way to add elements to a tuple right
02:43:41 <sqooq> a tuple never changes size
02:43:44 <sqooq> that's annoying
02:43:54 <ertes-w> sqooq: f z (x, y) = (x, y, z)
02:44:12 <sqooq> yeah
02:44:23 <sqooq> I'm doing something similar but it just looks uglier
02:45:04 <sqooq> ertes, this was my version of the leafFinder based on your hints 
02:45:06 <sqooq> leafFinder (Branch x) = concat $ zipWith (\x y -> map (x :) (leafFinder y)) [0..] x
02:45:13 <sqooq> and of course [[]] for leaf
02:45:22 <sqooq> it works for me
02:45:32 <sqooq> is that what you did?
02:45:38 <sqooq> or similar?
02:46:09 <sqooq> ertes-w
02:47:29 <ertes-w> sqooq: yes
02:47:54 <cheater> in the instance of Build for Matrix that's here https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra-Data.html#t:Build   if I'm using Matrix Double, will the function passed to build be of type Double -> Double -> Double?
02:48:53 <cheater> it seems like this, does this mean that in hmatrix a Matrix Double now has indices of type Double? that sounds wrong
02:53:24 <lyxia> no the indices are still int
02:54:14 <lyxia> build  applies  fromIntegral  before giving the index to your function
02:54:49 <lyxia> or something equivalent from the Element typeclass instead of Num
02:57:36 <cheater> right yeah
02:57:43 <cheater> i need some way to get actual ints though
02:57:54 <cheater> looking through the docs i can't find anything of value
02:58:48 <sqooq> are things less efficient when you have to dig through lists of lists of tuples and stuff to make a change, rather than making that change earlier on before you have the end result?
03:00:28 <EvanR> modifying immutable data is always more expensive than constructing it correctly in the first place
03:00:44 <sqooq> i figured
03:00:57 <EvanR> proof by grammatical contradiction
03:01:02 <cheater> lyxia: do you see something like this?
03:02:08 <lyxia> cheater: I don't. Either round the index or convert from a list using (><).
03:02:44 <lyxia> or mess with the internals
03:04:32 <cheater> ok. i thought i was maybe missing something obvious.
03:05:56 <ertes-w> sqooq: it depends…  if your data is sufficiently lazy and your traversal sufficiently non-strict, typically you still need only a single traversal; but non-strict functions do pile up, so the traversals get more expensive the more individual traversals you apply
03:06:27 <ertes-w> sqooq: however, if you use list functions, chances are that your traversals will be fused
03:06:48 <sqooq> I think it's going to be easier to do it earlier on anyway
03:06:48 <ertes-w> sqooq: that's why you should rarely write recursive list functions
03:06:53 <cheater> is there currently a good way to make cabal choose a specific version of ghc that you have on your system, rather than just ghc?
03:08:42 <ertes-w> cheater: cabal configure -w
03:09:13 <cheater> thank you
03:12:29 <cheater> using cabal configure -w ghc-7.10.3, it still rejects hmatrix-0.16.* because of its dependency on a base that's from before ghc-8.2
03:12:37 <cheater> i'm not sure why?
03:13:57 <cheater> or does this just mean it'll have to download and build them? http://sprunge.us/TDWi
03:18:12 <manek> Hi! I've got a problem with a memory leak. I've implemented an Attoparsec "backend" which uses Unboxed.Vector Char instead of Data.Text. When I use it in a real example I get "out of memory" error. if I enable profiling and generate memory usage report I end up with tosmetihng like this: https://ibb.co/crDr2F
03:18:36 <cheater> try to use strict fields in your code
03:19:29 <manek> cheater: I've tried. In fact the attoparsec backend uses strict annotations exaclty where strict annotations were in the Data.Text backend. Moreover I've tried to compile every file with -XStrict, but without any change 
03:21:18 <manek> To be honest, I do not knwo what to do now. Should I blindly change functions? The report just tells me that the memory usage is high and the label suggest it is about memory allocated by Vector (which I know)
03:21:34 <cheater> manek: hm. i don't have any immediate ideas, but i'm sure others will
03:22:03 <manek> cheater: thank you. I'd be thankful for any further suggestions
03:22:11 <cheater> ertes-w: ok, cabal install -w ghc-7.10.3 has worked - however i need to get on the repl and i'm not sure how to do that. cabal repl doesn't take -w.
03:28:57 <cheater> i tried cabal exec -- ghci-7.10.3 but that said "/usr/local/lib/ghc-8.2.1/package.conf.d/package.cache: GHC.PackageDb.readPackageDb: inappropriate type (not enough bytes)"
03:35:07 <manek> Hi! I've got a problem with a memory leak. I've implemented an Attoparsec "backend" which uses Unboxed.Vector Char instead of Data.Text. When I use it in a real example I get "out of memory" error. if I enable profiling and generate memory usage report I end up with tosmetihng like this: https://ibb.co/crDr2F
03:35:37 <ertes-w> cheater: you should probably use an abstraction like nix or stack
03:35:52 <cheater> ertes-w: i can't do this right now
03:36:02 <ertes-w> i think cabal-install does not have good support for selecting compiler *versions*
03:36:03 <manek> I do not know how could I profile it now, should I just blindly test and change every function or is there any way to easier target whats happening here? 
03:36:22 <cheater> manek: your message is still on the screen. please don't repeat - this only makes people less inclined to help
03:37:10 <cheater> manek: most likely, almost everyone in europe is at lunch, so you'll have to wait it off and see what happens
03:37:54 <manek> cheater: of course. On my screen it disappeared so I thought I will post it again, but yeah, I've got short buffer here 
03:38:23 <cheater> most people can see that. repeating every 5 minutes in a channel that's fully inactive won't bring you anything
03:38:51 <cheater> the best way is to hang around, wait some time, and try rephrasing your problem with what you've learnt in the mean time
03:40:59 <cheater> ertes-w: i've seen some posts about using multiple config files, that might work, i'll try that now
03:45:11 <cheater> seems to be working so far
03:58:33 <Unhammer> if I have
03:58:35 <Unhammer> foo :: Ord a -> IO ()
03:58:37 <Unhammer> foo = go Set.empty where go :: Ord a -> …
03:58:39 <Unhammer> – how do I avoid the "Could not deduce a~a1" here?
03:59:30 <Unhammer> Ord a => a -> IO () -- that is
04:01:08 * hackagebot chatwork 0.1.1.2 – The ChatWork API in Haskell – https://hackage.haskell.org/package/chatwork
04:01:32 <Unhammer> full example http://sprunge.us/dJMf
04:01:45 <cocreature> Unhammer: enable ScopedTypeVariables and add a forall a. at the beginning of foo’s type signature
04:07:39 <Unhammer> aha, thanks cocreature !
04:08:40 <Unhammer> I think I've asked this one before, wish the error message would mention the extension :(
04:10:33 * hackagebot aeson-flowtyped 0.9.1 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
04:10:33 * hackagebot gi-gtk-hs 0.3.5.0 – A wrapper for gi-gtk, adding a few more idiomatic API parts on top – https://hackage.haskell.org/package/gi-gtk-hs
04:18:41 <manek> I think I
04:19:17 <manek> I think I've found out why I got memory leaks. It seems that Data.Vector.Unboxed.takeWhile creates a new vector everytime it is used (!), opposite to what documentation tells
04:19:47 <manek> When I replaced takeWhile with just taking values by indexes, memory dropped to 0
04:40:04 <cheater> nice
04:40:15 <cheater> you should open a bug in the related package
04:40:35 <cheater> maybe they can fix it or maybe they can tell you what you could be doing differently
04:43:21 <manek> cheater: its not nice :( Its not what documentation tells and Data.Vector is one of the "very basic" Haskell packages. Actually I see there is a bug very similar to my results: https://github.com/haskell/vector/issues/182
04:43:46 <manek> cheater: I will describe my findings in separate one ind link it there, however it's sad that `takeWhile` is so broken
04:43:48 <cheater> please comment on it that you were able to reproduce, and mention what versions of packages you were using
04:44:20 <cheater> thanks to this, the bug can be rotted out
04:44:40 <manek> cheater: sure. Btw I'm not a newbe here, but I'm glad you care so much about moving people in the right direction, thats super cool
04:45:05 <opqdonut> manek: where do the docs say takeWhile doesn't create a new vector?
04:45:14 <ertes-w> this looks like a documentation bug…  'takeWhile' is written for fusion, not for slicing
04:45:15 <opqdonut> manek: as far as I can tell it just says "O(n)"
04:45:22 <manek> opqdonut: "O(n) Yield the longest prefix of elements satisfying the predicate without copying." 
04:45:34 <manek> opqdonut: "without copying" does nto tell it ?
04:45:44 <opqdonut> lol I can't read
04:45:58 <opqdonut> but yeah, as ertes-w says, it's built for streaming,
04:46:13 <ertes-w> manek: in other words what you experienced was intended behaviour, but the documentation needs to be fixed
04:46:18 <opqdonut> so if you were to, say, sum the result of takeWhile it would be efficient
04:46:55 <manek> ertes-w, opqdonut : oh! Ok, but how han we achive what I want in an efficient way then ?
04:47:01 <opqdonut> interesting, take slices, but takeWhile streams
04:47:24 <ertes-w> manek: write a variant of 'takeWhile' that scans the list and then slices
04:47:36 <ertes-w> s/list/vector/
04:47:52 <opqdonut> or, write such a consumer for the takeWhile that stream fusion happens
04:48:00 <opqdonut> what are you doing with the result of takeWhile?
04:48:39 <manek> opqdonut: I'm running takeWhile on an input source file taking some parts of it. After consuming it I consume next part. It is backend for lexer-like tool. I dont want my vector to be replicated 
04:49:24 <manek> opqdonut: I didnt played with streams and stream fusion yet. are there any performance benefits between these 2 ways (scanning list + slicing / consumer + stream fusion) ? 
04:49:58 <opqdonut> for this use case, probably not
04:50:59 <manek> opqdonut: If you would tell me more in which use case it could happen , I would better understand it and woudl be thankful for such explanation. I understand that using streaming could apply stream fusion if I connect it to more operations, but could another differences appear?
04:51:52 <opqdonut> hmm
04:52:11 <manek> By the way, cannot stream fusion be more intelligent and slice when necessary? I know this could be very naive question but I prefer to ask than not knowing the answer :)
04:53:48 <opqdonut> let's say you want to do something like sum . takeWhile. if you use slices for this, you will iterate the vector twice: once to find the slice, and another time to sum
04:54:01 <opqdonut> if you use streams, you would just iterate once, doing the takeWhile and the sum at once
04:54:31 <opqdonut> if the data was big, one iteration would be faster since it does less memory loads
04:55:06 <opqdonut> but if your slices are small and fit in cache, there probably won't be a significant performance difference
04:55:06 <manek> opqdonut: I see it, however the real question to me is if we (even theoretically) would be able to create so inteligent stream fusion that would choose better way for us. If now, we should make the API in such way that it will allow user to choose what he wants
04:55:55 <opqdonut> using rewrite rules it would probably be possible to write a takeWhile that streams when possible, but otherwise returns a slice
04:56:09 <opqdonut> the downside is that then the performance would be less predictable
04:56:24 <opqdonut> maybe the library should just have a takeWhileSlice
04:56:28 <opqdonut> and the docs of takeWhile should be fixed
04:58:54 <ertes-w> manek: to process a file in chunks i would use a stream abstraction
04:59:02 <ertes-w> like pipes or machines
05:14:23 <manek> ertes-w: I'm using it as attoparsec backend, so streams are not suitable here I think
05:16:31 <ertes-w> manek: why not?
05:17:38 <manek> ertes-w: just because everything in attoparsec is written the way that it keeps a "position" and then slices to that position when necessary. We could maybe redesign it to use stream in this particular case but I dont know if its worth the effort
05:18:18 <ertes-w> manek: do you need absolute positions for something?
05:18:43 <ertes-w> usually positions are used for error reporting, but if you need that, attoparsec is the wrong choice in the first place
05:19:27 <manek> ertes-w: I know the available libs pretty well. I'm using attoparsec as a lexer outputting tokens with position information. I encode the position information using conduit on top of the lexer 
05:20:17 <manek> ertes-w: it gives me really good performance (parsing 10Mb of file under a second) with positon information encoded in outputted tokens
05:20:40 <cheater> using hmatrix, one of my matrices is being passed to eigSH, but that requires that the matrix is hermitian. in a previous version of the code, hmatrix only required that the matrix be real and symmetrical and didn't have a special type for hermitian matrices. the algorithm worked before, so the matrix is obviously hermitian. what are some ideas how i can make hmatrix know that this matrix is hermitian?
05:21:22 <opqdonut> cheater: eigSH'
05:21:27 <opqdonut> cheater: (just by reading the manual)
05:21:54 <cheater> oh, i have completely missed that one
05:22:01 <opqdonut> if that's too unsafe for you, you can create Herm matrices with sym, mTm or trustSym
05:22:04 <opqdonut> https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra.html#t:Herm
05:22:04 <cheater> i have gone reading in a different part of the manual
05:22:09 <cheater> yeah, i just noticed
05:23:03 <cheater> http://sprunge.us/OLEK
05:23:10 <cheater> this is the code i am trying to refactor to new hmatrix
05:24:04 <cheater> according to the author of the original code: quadform is the quadratic form: x'*Q*x for vector x and matrix Q, which is convex if Q is positive definite, but can't be recognized as such in DCP without the quadform primitive
05:27:08 <cheater> oh wait, just above, he already checks that the matrix is hermitian, by checking that it's square and that it's equal to its transpose
05:27:14 <opqdonut> yeah
05:32:48 <cheater> i'm a bit confused about where trans is defined in hmatrix 18. Can you see it somewhere? https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/src/Internal-Numeric.html
05:33:26 <cheater> i wanted to find the exact definition of tr', and it just says tr' = trans, but it never seems to define trans
05:33:27 <opqdonut> https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra.html#t:Transposable
05:33:30 <opqdonut> ah right
05:33:59 <cocreature> cheater: https://github.com/albertoruiz/hmatrix/blob/d2d0066d2ff3d8e66ce902ee1b9d1317f1710a2c/packages/base/src/Internal/Matrix.hs#L94
05:34:13 <cheater> ah, https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/src/Internal-Matrix.html#trans
05:34:16 <cheater> yeah
05:35:09 <cheater> so comparing this https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/src/Internal-Matrix.html#trans   and  this https://hackage.haskell.org/package/hmatrix-0.14.0.0/docs/src/Data-Packed-Internal-Matrix.html#trans   i guess the old trans was non-conjugate transpose?
05:35:20 <cheater> aka normal transpose, without conjugating the elements?
05:35:30 <cheater> because if so then there's a slight bug in the library i'm updating
05:36:02 <cheater> (i thought i'd ask what you guys think to double check this)
05:37:18 <phadej> ter
05:38:06 <manek> By the way, ertes-w : My attoparsec backend, which uses unboxed vector of chars instead of Text runs about 3 - 4 times faster than Text based attoparsec
05:38:23 <manek> ertes-w: We (me and my co-workers) will release it shortly
05:39:01 <cheater> manek: nice
05:39:27 <manek> cheater: :)
05:42:39 <ertes-w> manek: yeah, i use Vector Char myself for some things
05:42:56 <ertes-w> it's O(1) on many operations where Text is O(n)
05:43:27 <manek> ertes-w: encoding in UTF16 is stupid. It gives you almostn othing and brings pains of both UTF8 and UTF32
05:43:36 <ertes-w> yeah
05:43:38 <ertes-w> i agree
05:44:01 <phadej> https://github.com/text-utf8/text slowly, but steady
05:44:08 <manek> ertes-w: we'l be releasing text32 lib shortly, we use it internally for textp rocessing inside compiler
05:44:42 <cheater> text32?
05:44:45 <phadej> manek: one more String for Haskell :O (+1)
05:44:49 <ertes-w> manek: is it an opaque type, or is it just Vector Char?
05:44:50 <cheater> 32 bit utf?
05:44:50 <manek> I dont care about memory if Im loading source code of porgram and as fast as I transform it to AST it is thorwn away
05:44:51 <phadej> probably utf32 internal encoding
05:45:05 <manek> ertes-w: its newtype over Vector Char
05:45:13 <ertes-w> manek: why the newtype?
05:45:27 <ertes-w> manek: if you would just use Vector Char directly i would most likely use it
05:45:43 <phadej> Vector Char doesn't allow you to write instances
05:45:49 <phadej> which are "stringy"
05:46:09 <ertes-w> phadej: ah
05:46:27 <ertes-w> not sure if that's a real drawback though
05:46:29 <manek> ertes-w: because of just simple thing. If you work with a "text" you should think about it like about text, dont think whats under the hood unless you really need it. I know that powerful users can put Vectors everywhere, but  
05:46:52 <manek> designing the librayr in a way theat it gives you a type that is suitable for the work it has to be done is a good desinng decision
05:46:59 <phadej> ertes-w: there's quite a lot of pain with type String = [Char], and not newtype around it
05:47:20 <ertes-w> manek: honestly that's kind of a bullshit reason =)
05:47:41 <phadej> ertes-w: even aeson has to do `listToJSON` to support `String` without OverlappingInstances
05:47:59 <phadej> (which is painful on it's own)
05:48:04 <manek> ertes-w: I dont think so, really. I was thinking the other way around about 10 years ago, but my thinking changed drastically after working with many programmers uisng my libs
05:48:29 <manek> ertes-w: if you want to access a vector you can always do "unwrap txt" (unwrap is just view _Wrapped from lenses)
05:48:45 <manek> ertes-w: you can apply vector operations like (txt & wrapped %~ f)
05:49:01 <manek> ertes-w: but both type errors / inferencing/ everytihng is just nicer with newtype
05:50:17 <cheater> when i build this library, ghc says the code uses "unticked promoted constructors". is it possible that there's a legit reason for using constructors like this, or is this always what ghc thinks it is?
05:50:25 <manek> and for less advanced users it is much easier to think aobut it liek about "text container". There was a great post about it fro mthe author of Data.Text, I cannot find it now. He told that data.Text is logically jsut a container and it should not be obvious whats under the hood, this is implementation detail
05:50:28 <ertes-w> manek: to me personally a small add-on library with text operations for Vector Char would be more useful, ideally in a way that abstracts over the actual vector type
05:51:09 <ertes-w> manek: for example just hardcoding unboxed Vector would immediately reduce its usefulness for me
05:51:18 <cheater> here's an example: https://github.com/cheater/hvx/blob/master/src/HVX/Internal/Solvers.hs#L93 it says "Affine" should be "'Affine".
05:51:30 <cheater> same with Noninc
05:52:17 <manek> ertes-w: Maybe it will be good to abstract it. Hmm, But then I have to make a big typeclass / many typeclasses that abstract things from all vectors 
05:52:22 <ertes-w> manek: i'll probably write that library at some point…  same idea, different trade-offs
05:52:33 <manek> ertes-w: I mean - boxed / unboxed vectors / mutable ones etc
05:53:00 <manek> ertes-w: its pain that currently all the "kinds" of vector have almost the same API but it is not movable between them
05:53:33 <ertes-w> manek: hmm?  you must have missed Data.Vector.Generic =)
05:53:47 <ertes-w> lines :: (Vector v Char) => v Char -> [v Char]
05:55:28 <manek> ertes-w: right, I missed it, hmm, why the hell it is not exported by fdefault and all the function headers are just copy-pasted into specific modules? to make the types easier to read?
05:56:14 <ertes-w> very good question
05:58:21 <manek> ertes-w: just curious - are all optimisations working the same when using the generic version? They should however I've seen so many strange things in haskell (like newtypes adding runtime overhead) that Im not sure in anything without checking it
05:58:55 <gremdrus> does anyone have more than   (add-hook 'haskell-mode-hook 'intero-mode) for haskell in their emacs config? I'm looking for more stuff to add/configure.
05:59:13 <ertes-w> manek: yes, in fact the optimisations are defined for the generic versions, and the specialised versions just go away through inlining
05:59:37 <manek> ertes-w: If so then I find copy-pasting hte headers contr-intuitive
05:59:53 <ertes-w> manek: i agree
06:01:00 <ertes-w> the individual vector modules are all extremely bloated, and telling the generic functions from specialised ones is really difficult…  i would very much prefer if Data.Vector.Unboxed just reexported Data.Vector.Generic
06:01:54 <lyxia> cheater: This is to disambiguate between type constructors and value constructors
06:04:42 <manek> ertes-w: I completely agree, by the way, I think we'll move over type alias here. It might be a lot better. I was thinking to keep newtype also in order to abstract implementation from what user sees (so we can move over raw Array in the future if needed), but we can achive the same with typeclass if we ever woudl need it
06:05:42 <ertes-w> manek: also if you use Vector directly there is little benefit in using a raw array, unless you want to get rid of slice sharing
06:05:44 <cheater> lyxia: in this situation, can i fully rely on ghc to tell me the right thing to do?
06:05:57 <cheater> lyxia: i would just go through all those warnings and add ticks
06:06:54 <manek> ertes-w: this is an open quetion to me. We use Vectors also in another place in code. We use it as "raw memory" to store and read data to particular indexes very, very often. I was thinking if goinfg to raw arrays would give us any performance benefits 
06:07:11 <manek> ertes-w: in this particular place every bit is very important, so I have to test raw arrays too
06:07:22 <manek> ertes-w: (this is other topic than text lexing)
06:08:22 * hackagebot wreq-stringless 0.5.1.0 – Simple wrapper to use wreq without Strings – https://hackage.haskell.org/package/wreq-stringless
06:10:22 <daniel___> Hi! I'm new to Haskell and I'm not quite satisfied about how my code looks... I'm sure I could do better, if someone's so kind to give me some suggestion, here's a snippet: http://lpaste.net/1121058001231282176
06:10:47 <ertes-w> manek: if you don't need slice sharing, you should gain some extra performance, but depending on your application it may or may not be measurable
06:11:53 <Rembane> daniel___: What should the code do?
06:11:58 <manek> ertes-w: I'm just googling slice sharing right now but cannot find any concrete information about it. I know what is slicing and kinda know what is sharing, but what is slice sharing ?
06:12:06 <manek> ertes-w: sorry if thats stupid or very simple question
06:13:17 <daniel___> @Rembane given a list of time intervals, and a specification on where a hole should be, breaks the intervals so that nothing overlaps the hole
06:13:18 <lambdabot> Unknown command, try @list
06:13:25 <ertes-w> manek: if you slice a vector, the original vector is reused ("shared") by the new vector
06:13:47 <Rembane> daniel___: Cool. 
06:13:54 <ertes-w> manek: a new vector is only allocated if the actual content needs to change, or if you need to prepend/append something
06:13:56 <manek> ertes-w: yes, it has to remember two Ints (beggining and end of the slice)
06:14:16 <manek> ertes-w: so the performance difference is about removing these "ints" ?
06:14:26 <ertes-w> manek: pretty much
06:14:34 <Rembane> daniel___: Why do you have the (Maybe Config.Break) and not just Config.Break?
06:14:48 <manek> ertes-w: oh ok! thank you! I was thinking that maybe there is some deeper magic involved here
06:14:58 <ertes-w> manek: also you might get away without the slight overhead of a ForeignPtr
06:15:13 <ertes-w> by using ByteArray# and friends
06:15:14 <daniel___> Rembane: because there may be no "hole" at all to create
06:15:56 <ertes-w> manek: but it's all a difference in allocation/free performance, not in the actual vector operations themselves…  indexing will still have the same performance
06:15:59 <manek> ertes-w: how could I do that? I need my elements to be stored as unboxed values. The only way I found so far is to make Storable instance for them and then I have to use ForeignPtr, havent i?
06:16:38 <ertes-w> manek: Storable with Data.Vector.Storable would be one option…  another one would be Data.Vector.Unboxed with an Unbox instance
06:16:56 <ertes-w> yet another one would be Data.Vector.Primitive, but i wouldn't do that
06:17:44 <manek> Primitive is in fact an option, while Unbox instance is not, becuase it will store all of my elements as a set of vectors and not as vector of structures
06:18:08 <manek> ertes-w: ^^^  + I need often to copy the structures on disk and back to the vector. Copying to lets say 20 vectors would be killer 
06:18:13 <Rembane> daniel___: Why do you run the function to create a hole if there is no hole?
06:18:52 <ertes-w> manek: the way you design your Unbox instance is up to you
06:19:08 <ertes-w> there is no reason why you couldn't store a vector of structures
06:20:39 <daniel___> Rembane: because I read config' (which is a user provided specification) and just apply a bunch of functions in sequence over it. applyBreak is one of them, but sometimes there is no break to apply. I thought it was cleaner to call it anyway and just let it do nothing if no break was required.
06:20:44 <manek> ertes-w: Hmm, I have to try it! I was somehow sure it would not be possbile but hm, maybe I was blind! By the way, why Unboxed vectors would have any perf diff then storable ones? Arent they jsut represented ALMOST the same - one with pinned and the second with unpinned memory ?
06:20:58 <Rembane> daniel___: Ah. Interesting.
06:21:00 <manek> ertes-w: to me , logically, the pinned (Storable) might perform even faster
06:21:21 <ertes-w> manek: pinning can have a negative impact on performance, because GC needs to treat those vectors specially
06:21:48 <ertes-w> manek: the way GC works in GHC benefits from being able to move memory around
06:23:10 <dramforever> ...Not so sure it's a good idea to move large vectors around
06:24:08 <manek> ertes-w : thats very interesting topic. I'm going to read about GHC's GC this weekend ! :D
06:24:25 <manek> ertes-w: thank you so much for the onversation! 
06:25:12 <ertes-w> dramforever: it *can* have a negative impact =)
06:25:54 <ertes-w> also consider that copying once can be better than treating it specially every single time
06:25:59 <ertes-w> even for larger vectors
06:34:57 <xxoxx> hi. 
06:35:15 <xxoxx> just getting started in haskell. is win7 a viable dev platform ?
06:35:26 <phadej> should be
06:35:40 <xxoxx> leksah ?
06:36:06 <xxoxx> installation of leksah prooved to be a bit bumpy
06:36:11 <phadej> I'm not familiar with it
06:36:16 <xxoxx> missing lib, etc .
06:36:22 <xxoxx> ok
06:37:06 <xxoxx> if you don't mind, what environment do you develop in? and what execution evironment do you target ?
06:37:55 <phadej> co-worker uses vs-code and haskell ghc-mod plugin there
06:38:02 <phadej> that get's you quite far
06:38:06 <xxoxx> ok
06:38:26 <xxoxx> for web dev, or native desktop app ? win / Linux ?
06:38:48 <xxoxx> I got curious with Haskell from a CAD app written in Haskell
06:39:15 <dramforever> web app would be an easy way to get started
06:39:19 <xxoxx> worked with Lisp during ancient times ...
06:39:22 <xxoxx> ok
06:39:37 <dramforever> what's your prior programming e... oh that's good
06:41:11 <dramforever> xxoxx: I would suggest picking a book to learn the basics first
06:41:32 <cliffor> Hi, sorry, you guys probably get this a lot, but what advantages do you see to Haskell in comparison to something like Python?
06:41:52 <Rembane> cliffor: Type safety
06:42:02 <jcjf> Beginner Windows user - should I pick stack or Haskell Platform? The latter seems to contain the former?
06:42:06 <cliffor> safety
06:42:19 <dramforever> I find plain stack easier to work with
06:42:32 <Aruro> one thing more important than safety is refactoring
06:42:34 <cheater> plain as opposed to what?
06:42:36 <xxoxx> and expressiveness ?
06:42:43 <dramforever> Haskell Platform
06:42:50 <xxoxx> potentially you can do more with a lot less code
06:42:56 <dramforever> refactor safety :)
06:43:18 <lambdaGrp> xxoxx: ImplicitCAD?
06:43:39 <cheater> i don't like hp, i'm a ghc+cabal sort of guy
06:43:43 <cliffor> xxoxx: Sounds interesting, I'll definitely be learning a bit of Haskell. 
06:43:51 <cheater> i guess everyone's got their weakness
06:43:59 <Aruro> cliffor: not bit learn all
06:44:00 <xxoxx> lambdaGrp: yeah. implicitCAD
06:44:13 <cliffor> :Aruro hahaha fine, I'll learn /all/ of Haskell
06:44:27 <Aruro> agreed :)
06:44:42 <dramforever> pure functions working with immutable data scales up with program complexity pretty well
06:45:42 * hackagebot quantification 0.1.2 – Data types and typeclasses to deal with universally and existentially quantified… – https://hackage.haskell.org/package/quantification
06:45:43 <lambdaGrp> xxoxx: I was wondering if there is something new!
06:46:07 <dramforever> For newcomers I would suggest learning a fair bit amount of Haskell before trying to get started with Haskell.
06:46:16 <cliffor> thanks for your help guys, probably looking to hang around here a lot more. seeya. 
06:46:49 <dramforever> I've heard people claiming that one should learn Ruby *by* learning Ruby on Rails. No such thing for most people in Haskell-land.
06:47:04 <xxoxx> @lambdaGrp:  nothing big at the moment ... just thinking to extend OpenSCAD, adding bits of hardware support, e.g. 3D mouse
06:47:04 <lambdabot> Unknown command, try @list
06:47:07 <xxoxx> pet project
06:47:24 <tsmish> daniel___: breakStart and breakEnd are very similiar. I think you can replace them with function.
06:47:34 <Aruro> xxoxx: can openscad slice?
06:47:39 <xxoxx> nope
06:47:43 <Aruro> i would like it :)
06:47:45 <tsmish> s/similiar/similar
06:47:49 <xxoxx> well, not natively 
06:48:08 <xxoxx> @Aruro, you can program it to slice
06:48:08 <lambdabot> Unknown command, try @list
06:48:15 <dramforever> Read this list. https://github.com/bitemyapp/learnhaskell
06:48:15 <Aruro> openscad is goood really like it
06:48:31 <dramforever> Buy https://haskellbook.com if you're convinced
06:48:47 <xxoxx> cool... I will buy some haskell books
06:48:58 <dramforever> Ask here for answers
06:49:05 <dramforever> My bad, they don't have https: http://haskellbook.com
06:49:18 <Aruro> xxoxx: no need of buying all online
06:49:54 <Aruro> if money is an issue
06:50:25 <Aruro> wanted to buy for my library K&R C and amazong wants like 50 bucks for it, yeah.
06:52:02 <daniel___> tsmish: you mean another top-level function in the file?
06:52:04 <Aruro> does anybody know how to disable haskell-stack checker in flycheck?
06:52:15 <ertes-w> compared to python there are far more compelling reasons to switch to haskell than just type safety and ease of refactoring
06:52:20 <Aruro> on mac os 10.9
06:52:57 <dramforever> Like, super friendly people here?
06:54:30 <gremdrus> should I use intero and flycheck-haskell?
06:54:41 <ertes-w> no, the python community is very friendly, at least in my experience…  but python itself is super-frustrating to work with
06:55:20 <frerich> daniel___: You might find the 'Reader' monad interesting for passing your 'Config' value around.
06:56:03 <tsmish> daniel___: Doesn't matter. I meant factoring out (addUTCTime . realFrac . timeOfDayToTime). You can put this function in where block and partially apply it to day if you like.
06:56:07 <daniel___> frerich: hmmm, never used it. Going to read about it, thanks!
06:56:42 <daniel___> tsmish: perfect. That would reduce the clutter
06:57:30 <daniel___> tsmish: I wasn't convinced either about the fact of splitting applyBreak in applyBreak', but I guess that's a common idiom?
06:58:36 <frerich> daniel___: I think you could avoid a couple of parentheses (parenthesis? I can never remember...) by not using the 'start' and 'end' getters on the Config value but rather using pattern matching (i.e. define "applyBreak' config' timezone (Interval start end) = ..." and then use 'start' and 'end' directly instead of applying them repeatedly to 'x').
06:59:24 <sproingie> -ses is plural -sis
07:00:18 <ertes-w> "you've met my ses yesterday…  aren't they nice?"
07:01:18 * hackagebot transient 0.5.9.1 – composing programs with multithreading, events and distributed computing – https://hackage.haskell.org/package/transient
07:02:31 <daniel___> frerich: Got it. I'm always afraid of applying pattern matching because I always think that if one day I want to reorder the 'fields' then I'll screw everything up, but I'm probably just paranoid
07:03:47 <dramforever> Ah, transient
07:16:49 <minn> Is there a more idiomatic way to access the head and tail of a nonempty list inside a state monad than 'head <$> use l' and 'l %= tail' where l is a lens?
07:17:23 <phz_> is there a multimap out there?
07:17:59 <cheater> if i want my library to include a criterion benchmark, is it better to put it in an executable, or in a test executable?
07:18:41 <frerich> minn: I guess 'let (h:t) = xs in ...' would be too mundane? :-]
07:19:09 <osa1> cheater: there's a benchmark section for that stuff
07:19:28 <osa1> cheater: https://www.haskell.org/cabal/users-guide/developing-packages.html#benchmarks
07:19:31 <cheater> i didn't know that, it must be new
07:19:40 <cheater> ish
07:19:49 <osa1> I've been using it for years
07:21:13 <minn> frerich: point taken :)
07:21:40 <e2> haxx0r
07:22:45 <cheater> ty
07:23:01 <phz_> is there a way to make a map / hashmap construction fail on duplicates?
07:24:11 * hackagebot neko-obfs 0.1.0.2 – a TCP tunnel with packet length obfuscation – https://hackage.haskell.org/package/neko-obfs
07:24:11 * hackagebot HarmTrace 2.2.1 – Harmony Analysis and Retrieval of Music – https://hackage.haskell.org/package/HarmTrace
07:26:43 * frerich phz_: You mean, a function like '(k,v) -> Maybe (Map k v)' which yields Nothing in case any of the keys appears more than once?
07:27:02 <phz_> frerich: yep
07:27:03 <phz_> well
07:27:05 <phz_> we found a better solution
07:27:08 <phz_> `fromListWith`
07:27:14 <phz_> and replace values with NonEmpty v
07:28:37 <frerich> phz_: Not sure I understand that idea, what would 'NonEmpty v' do?
07:28:57 <phz_> frerich: imagine this:
07:29:09 <phz_> fromList [(1, "foo"), (1, "bar"), (2, "zoo")]
07:29:15 <phz_> map singleton 
07:29:30 <phz_> fromListWith cons
07:29:51 <phz_> then, if you traverse the map, you can quickly see which keys are duplicated (and what are the corresponding values)
07:30:11 <phz_> and what the corresponding values are*
07:31:52 <frerich> phz_: Ok, but wouldn't (2,"zoo") and anything after that gets inserted even though you already know that the overall map is invalid?
07:32:25 <phz_> yes it would
07:32:32 <phz_> the idea is that I can retrieve all errors
07:32:36 <phz_> instead of failing at the first one
07:32:46 <phz_> (which is great when reporting errors to another entity)
07:32:50 <phz_> here, the hashmap comes the front team
07:32:51 <phz_> so… :P
07:33:43 <frerich> phz_: Ok yeah, then I'd also do a M.fromListWith (++) on the singleton maps and then check for any value which has more than one elements.
07:34:20 <phz_> (<>), you fool!
07:34:21 <phz_> :P
07:35:31 <frerich> Whatever floats your boat. :-)
07:37:16 <phz_> semigroups!
07:37:22 <phz_> I sail on semigroups!
07:40:15 <jcjf> I keep forgetting what semi- means... is that the one without identity?
07:40:37 <frerich> jcjf: It's like Monoid, but without the identity element, yeah
07:40:58 <sproingie> isn't that also called a magma?
07:41:01 <Cale> No
07:41:05 <jcjf> With inverse
07:41:10 <sproingie> ah
07:41:13 <Cale> A magma is just an arbitrary set with a binary operation
07:41:21 <Cale> Semigroups add associativity
07:41:24 <Cale> (only)
07:41:37 <jcjf> Oh, no inverse either?
07:41:41 <Cale> Correct
07:41:48 <jcjf> Oh right, no identity means no inverse duh
07:41:52 <sproingie> ring adds inverse, right?
07:42:03 <Cale> ring adds a whole other operation and lots of stuff
07:42:24 <jcjf> Remember ring as numbers with times and plus
07:43:24 * hackagebot conduit-algorithms 0.0.1.0 – Conduit-based algorithms – https://hackage.haskell.org/package/conduit-algorithms
07:43:48 <Cale> You can *kind* of have an "inverse without identity" sort of situation, that's usually called a "quasigroup"
07:44:11 <Cale> Basically, you have the ability to "divide" even though there's no identity element
07:44:27 <[exa]> sproingie: rings add distributive monoid on non-zero elements to a group
07:44:30 <Cale> (See https://en.wikipedia.org/wiki/Quasigroup)
07:47:17 <Cale> Something else to note, in old references, you'll see "groupoid" used to mean what is usually called "magma" now
07:47:47 <Cale> Basically, the category theoretical sense of the word "groupoid" won because it's much more group-like and a much more important concept.
07:47:59 <Rotaerk> magma is a math term? coool
07:49:11 <mnoonan_> is there a single interesting theorem about magmas in general? I don’t think I’ve ever seen one.
07:50:07 <Cale> Well, there's not a whole lot, but sometimes you'd like to know something about a magma with properties that doesn't otherwise have a name
07:51:02 <Cale> There are a litany of special sorts of (non-monoid) magmas which have been studied to some extent
08:06:12 <jcjf> What's the difference between not (not True) = True in programming, but not in intuitionistic logic, and moreover type theory (which I thought many programming languages are based on)?
08:07:23 <jcjf> Is it some distinction between "internal logic" and Bool the data type?
08:07:30 <ezyang> yes 
08:08:10 <jcjf> Thanks ezyang!
08:08:39 <jcjf> I'm still trying to understand your blog post about the difference between induction and recursion as initial algebras
08:08:50 <jcjf> I'm hoping to get there one day
08:08:54 <ezyang> :) 
08:09:09 <ezyang> If you play around in Coq a little, the distinction between bool and Prop should become clearer 
08:09:36 <sproingie> just started playing with coq myself
08:09:55 <sproingie> (saying that stuff aloud around my friends tends to raise eyebrows)
08:26:44 <frankpf> I'm trying to parse a simple string with a ":" separator using Parsec
08:27:34 <frankpf> here's what I have so far:
08:27:49 <frankpf> http://lpaste.net/5115791930596261888
08:28:07 <monochrom> many (satisfy (':' /=)) `sepBy` char ':'
08:28:38 <Cale> noneOf ":" should also work
08:29:11 <frankpf> the example I gave parses each field separately though
08:29:21 <frankpf> how can I "chain" parseA and parseB
08:30:38 <monochrom> I don't understand the purpose of parseB. Unless you were thinking to apply both parseA and parseB in parallel on the same input.
08:31:13 <monochrom> Except parsec simply doesn't have parallel independent parsing.
08:32:11 <monochrom> Box <$> many (satisfy (':' /=)) <* char ':' *> many (satisfy (':' /=))
08:33:03 <monochrom> Or replace (satisfy (':' /=)) by letter if you require letters. (Recommended. Always be most specific.)
08:33:04 <frankpf> Those are a lot of symbols
08:33:23 <frankpf> Apparently the important part there are the <* and *> functions
08:33:41 <monochrom> You prefer do-notation? OK, there is one too.
08:34:13 <monochrom> do { a <- many (satisfy (':' /=)); char ':'; b <- many (satisfy (':' /=)); return (Box a b) }
08:34:34 <monochrom> Those are a lot of words and unnecessary temp names.
08:35:03 <sproingie> unnecessary for a simple case.  may help document more complex parses.
08:35:31 <monochrom> No. Meaningful names mislead too.
08:35:56 <monochrom> For this kind of things the best documentation is simply breaking into more lines and aligning nicely.
08:36:00 <frankpf> Ah, yeah. I understand it now
08:36:13 <frankpf> Don't know why I was trying to do it with two different parsers.
08:36:15 <frankpf> Thanks 
08:36:43 <c_wraith> I always liked that Haskell makes (x:xs) idiomatic, instead of forcing "meaningful" names that don't help anything.
08:37:13 <StoneToad> but x:xs *is* a meaningful name!
08:37:13 <monochrom> The best thing about standards is that there are so many standards to choose from.
08:37:30 <monochrom> The best thing about meaningful names is that there are so many meanings to choose from.
08:38:05 <monochrom> Case in point: Haskell's reserved words "data", "type", "newtype" were intended to be meaningful names. Now look at beginners' confusion.
08:38:09 <sproingie> x:xs is meaningful once you know.  "SomeClass p q r s a v c g l" usually isn't helpful
08:38:17 <StoneToad> ah true enough
08:38:57 <sproingie> names should have verbosity proportional to their scope
08:40:38 <monochrom> To a large extent, identifiers are a sorry excuse for conveying diagrams in text.
08:41:03 <sproingie> and language is a sorry excuse for mind melding
08:41:26 <Rotaerk> if only we had Vulcans
08:41:40 <monochrom> For example, the arrow do-proc notation is a sorry excuse for dataflow diagrams. And the monadic do-notation too, just for a different kind of diagrams.
08:41:53 <sproingie> meh.  their understanding of logic seems to be "utilitarianism 101"
08:42:09 <Rotaerk> vulcan logic vs emotion is stupid; but they're able to mind-meld
08:43:02 <ertes-w> -XHaskell2k
08:43:20 <ertes-w> allows ASCII diagrams in place of identifiers
08:43:52 <monochrom> Also look at module names Data.* and Control.*. People thought they were doing meaningful names too.
08:44:01 <sproingie> change the input format of the language to something not ASCII and diagram away
08:44:33 <Cale> monochrom: I feel like Data.* and Control.* are the result of over-enthusiasm with the ability to put '.' in module names, when that change went through.
08:44:55 <Cale> It used to be that there were a lot of really useful modules you could import which just had plain names.
08:45:09 <Cale> Like, you could just  import Set
08:45:20 <sproingie> polluting the global namespace with two identifiers still seems better than dozens
08:45:33 <sproingie> though there's package imports so it's never really "polluted"
08:45:43 <Cale> There's no namespacing here
08:45:56 <Cale> Modules are just allowed to have dots in their names
08:46:02 <ertes-w> i wonder how well diagram-based code (let's call it "diode") would work in practice
08:46:07 <sproingie> common prefix establishing a hierarchy is still namespacing.  it's just by convention.
08:46:15 <sproingie> see also perl
08:46:45 <Rotaerk> thing is, with how generic Control and Data are, they might as well be global namespace
08:46:47 <glguy> ertes-w: The 2006 ICFP contest http://www.boundvariable.org had an ASCII diagram programming language problem
08:46:59 <Rotaerk> as in, putting stuff under them is still really close tto polluting the global namespace
08:47:15 <Cale> Yeah, it's basically *two* miscellaneous junk drawers
08:47:30 <ertes-w> glguy: not talking about ASCII though, but an actual diagram language that requires a graphical editor
08:47:31 <sproingie> true, multiple libs will still compete for the generic names under Data.* and Control.*
08:47:47 <Rotaerk> though I guess for modules within application projects, I tend to put my modules in the global namespace
08:47:51 <c_wraith> I don't see the problem.  Everyone knows Monads are control flow structures and functors are data structures.
08:47:58 <Rotaerk> and so they don't have to compete with general library modules
08:48:01 <Cale> c_wraith: :D
08:48:07 <monochrom> Thank you! When people are forced to come up with "meaningful" names, their answers are generic names. The result is we are none the wiser, just more politicially correct and self-congratulating on the "meaningful name" party line.
08:48:17 <ertes-w> there have been experiements in the past, even commercial ones, but they turned out to be failures…  i believe they failed mostly because they were really just doing graphical control flow, and imperative programming doesn't really work there
08:48:23 <sproingie> and of course there's a perfect separation between data and logic
08:48:45 <sproingie> not all graphical languages have been failures, but the successful ones are specialized
08:48:45 <ertes-w> something like haskell might actually work graphically
08:48:54 <sproingie> *graphical dataflow
08:48:59 <glguy> ertes-w: Simulink?
08:49:02 <Cale> I'm also mildly unhappy with what happened with regard to removing suffixes from the identifiers in FiniteMap and Set
08:49:16 <Cale> (though I'm okay with the renaming FiniteMap -> Map)
08:49:25 <ertes-w> glguy: i mean a general purpose language
08:49:55 <Cale> Always having to write  import qualified Data.Map as Map; import Data.Map (Map)  is so much worse than just being able to import the thing and not having the names conflict.
08:50:33 <sproingie> Max is super popular for programmig synths, then there's unreal engine's Kismet.  both graphical.
08:51:11 <monochrom> c_wraith: What do you say about Control.Category and Data.Machine? :)
08:54:01 <c_wraith> monochrom: That they have perfectly meaningful names and questioning that is heresy and nevermind how many packages I've renamed historically because I got the first name really wrong.
08:54:34 <monochrom> heh
08:55:14 <monochrom> I am heretic alright.
08:55:38 <c_wraith> I'd call you more of an iconoclast, though the two obviously can go together.
08:56:02 <sproingie> indeed the latter is usually accused of the former
08:56:30 <monochrom> They have perfectly meaningful names, in the same sense as mathematicians saying there are perfect proofs in God's Book Of Proofs. I am saying this to get Cale to agree with me. :)
08:57:41 <AndreasK> ertes-w: Programming "languages" using a flow chart style seem to be somehwat common in automation
08:58:20 <sproingie> seen plenty of automation systems using godawful batch languages too
08:58:53 <sproingie> i may have invented one or two myself
08:58:58 <Cale> monochrom: haha
08:59:01 <AndreasK> LabView also kinda falls into this and i've seen that used for control/automation purposes as well
08:59:41 <ertes-w> sproingie: one of my first programming projects was to invent a terrible toy batch language in a terrible toy batch language (called QBASIC)
09:00:23 <monochrom> QBASIC was not all that terrible.
09:00:42 <sproingie> wrote a toy forth in perl to do json transformations, that was fun
09:00:58 <Cale> I remember trying to build a text adventure game in QBASIC and running out of space for code :(
09:01:04 <sproingie> probably still in use in that build system somewhere
09:01:35 <sproingie> qbasic wasn't bad at all compared to what i grew up with which was C64 BASIC
09:02:15 <Adeon> I thought qbasic was amazing
09:02:22 <Adeon> or rather the "IDE" that it had built-in
09:02:23 <sproingie> gorilla.bas
09:03:12 <AndreasK> ertes-w: Thats a screenshot of LabView: http://sql-lv.sourceforge.net/new_sql_LV.png which i would call diagram based. We used it in school for a bit and it works reasonably well although I wouldn't say it beats text based programming outside of certain niches
09:03:19 <Cale> Adeon: Yeah, the most amazing thing about it was how it was deployed on everyone's computer, and was reasonably accessible as far as that you could open up the help and learn everything right there.
09:03:59 <sproingie> i learned C by right-clicking all the things in turbo c on a 286
09:04:43 <sproingie> be awesome if a haskell environment could work that way
09:04:49 <monochrom> I learned OOP by doing that in Turbo Pascal 4.
09:05:28 <c_wraith> I "learned" OOP by editing ZZT levels.  I had a very distorted view of OOP.
09:05:46 <sproingie> i learned oop from a crippled c++ compiler that didn't even support templates
09:06:07 <zomg_> I learned OOP from PHP!
09:06:14 <sproingie> then later from lambdamoo, which is prototype-based
09:07:05 <ertes-w> monochrom: you're right…  QBASIC even differentiated between functions and procedures
09:07:14 <monochrom> :)
09:07:18 <ertes-w> AND IT HAD A BEAUTIFUL SYNTAX, TOO
09:07:21 <ertes-w> END SENTENCE
09:07:25 <zomg_> doesn't even VB6 still do that?
09:07:39 <sproingie> as do pascal dialects
09:08:08 <zomg_> I wonder if there's some practical reason/benefit of doing the split
09:08:34 <sproingie> pascal.  pedagogic reasons i imagine.
09:09:21 <sproingie> functions are ideally "pure", though being the dawn of structured programming, no one ever enforced it
09:11:05 <infandum> I'm a little confused with Template Haskell. if tableTypes :: String -> FilePath -> DecsQ (from the Frames library), then shouldn't I do $(runQ [| tableTypes "User" "file" |]) to run it in GHCI?
09:12:05 <ertes-w> zomg_: i think the main reason they did that was to have a special call form for functions that don't return anything
09:12:16 <ertes-w> sort of like 'void' in C
09:12:25 <glguy> infandum: You can do:  Prelude> $(tableTypes "User" "file");
09:13:04 <infandum> glguy: I tried that and got "Expected type: ExpQ; Actual type: DecsQ"
09:13:16 <glguy> infandum: try my versino then
09:13:18 <infandum> Oh, the semicolon solved that...
09:13:25 <infandum> huh
09:13:35 <zomg_> ertes-w: yeah that would make sense I guess
09:14:17 <infandum> glguy: Okay, everything's great now, thank you!
09:14:24 <infandum> I suppose it needed a newline or something
09:15:32 <ertes-w> zomg_: so i think it's a typical case of languages made for compilers rather than humans
09:16:54 <monochrom> The distinction came from Algol. Where is Peter Naur when we need him to recall the reasons behind their historical decisions? :)
09:17:46 <monochrom> But in retrospect, after learning Haskell, the distinction was silly.
09:18:31 <monochrom> My guess is it was yet another case of well-intention-gone-wrong.
09:21:49 <monochrom> In Haskell, "(\n -> replicateM n getChar) :: Int -> IO [Char]" is a perfectly uncontroversial thing. It is a function, and after supplying a parameter you get a procedure. And the procedure has a "return value" too. There is no conflict.
09:24:06 * hackagebot cabal-install 2.0.0.0 – The command-line interface for Cabal and Hackage. – https://hackage.haskell.org/package/cabal-install
09:24:59 <monochrom> But back then, people would actually fight wars over whether it should be "function f(int) :: string, with 'side' effects" or "procedure f(int, var string)".
09:25:01 <ertes-w> well, QBASIC is about as far from FP as you could imagine
09:25:25 <dramforever> 'IO' is how we dealt with talking to the outside world without compromising purity there.
09:26:13 <dramforever> (We compromised purity elsewhere. The most notable example is FFI where it doesn't seem very doable without, with our current Haskell)
09:27:35 <zomg_> monochrom: heh, never thought of that but I can definitely see it happening :P
09:27:53 <zomg_> considering all the things people argue over nowadays
09:27:59 <monochrom> The real fun begins when you ask, what if you want to call f for its effect, but you don't want the string?
09:28:18 <dramforever> The only comparable thing in a 'mainstream' language... is probably 'callbacks' in JavaScript
09:28:55 <dramforever> but making a Promise already starts it so that makes it nothing to do with the IO and its monad instance
09:29:09 <monochrom> Because back then, if you declare f to be a function, then the syntax does not allow you the bare "f(10);" statement, unlike flexible C. You have to do a "var tmp; tmp := f(10);".
09:29:31 <cocreature> oh cabal-2.0 is finally out
09:29:51 <monochrom> Dually, if you declare f to be a procedure with a var parameter for the result, you can't just say "f(10, null)".
09:30:22 <monochrom> In Haskell, this is all sorted out. "_ <- f 10" is just fine. Even "f 10" itself if you don't turn on the warnings.
09:31:23 * hackagebot hjugement 1.0.0.20170804 – Majority Judgment. – https://hackage.haskell.org/package/hjugement
09:31:54 <dramforever> ...which is because these things aren't handled by the language. It's the Monad instance of IO that is special
09:35:01 <monochrom> That's a bizarre library.
09:37:27 * hackagebot symantic-grammar 0.2.0.20170709 – Library for symantic grammars. – https://hackage.haskell.org/package/symantic-grammar
09:37:27 * hackagebot htirage 1.20170804 – Equiprobable draw from publicly verifiable random data. – https://hackage.haskell.org/package/htirage
09:40:11 <EvanR> hjugement
09:41:00 <grokkingStuff> Hi there!
09:41:15 <EvanR> one day you might be waiting in court not for legal bull... but for GHC to finish compiling your judgement :)
09:41:24 <dramforever> Hi I can see your trying to grok stuff
09:41:25 <grokkingStuff> Is HList still a thing? Was reading an article and realised it was ancient
09:41:46 <grokkingStuff> dramforever: :D That pretty much describes my life.
09:41:50 <dramforever> That was ancient but there's little to change
09:42:06 <grokkingStuff> is it still used? or is lens more favoured?
09:43:06 * hackagebot symantic 6.3.0.20170807 – Library for Typed Tagless-Final Higher-Order Composable DSL – https://hackage.haskell.org/package/symantic
09:44:10 <grokkingStuff> the reason i'm asking is because HList is pretty sweet in the way you can access information but lens is more modern and is being worked on.
09:44:42 <grokkingStuff> Also, it's got the name Kmett behind it, so I'm pretty sure it's decent.
09:58:45 <frankpf> I have a Parsec parser of type Parser Box (Box is the type of a record)
09:59:03 <frankpf> is it possible to apply this parser to every line of a function and "extract" the Box out of the Parser monad?
09:59:23 <frankpf> I've tried to do `boxes <- map parseBox (lines file)` inside a do-block
09:59:55 <frankpf> every line of a file*, sorry
10:00:25 <lifeisalive> what's the best way to die?
10:03:04 <dramforever> frankpf: let boxes = map parseBox (lines file)
10:03:35 <lifeboy> Anyone alive?
10:03:44 <cheater> you hopefully
10:03:58 <nek0> hi folks
10:04:10 <lifeboy> Only for next 5 mins
10:04:22 <frankpf> dramForever: but then I get a GHC error
10:04:42 <frankpf> Expected type: String -> b; Actual type: Parser Box; in first argument of 'map'
10:04:43 <lifeboy> What's the best way to die?
10:05:00 --- mode: ChanServ set +o monochrom
10:05:20 --- mode: monochrom set +b *!*@2405:204:*
10:05:26 --- kick: lifeboy was kicked by monochrom (lifeboy)
10:05:30 --- kick: lifeisalive was kicked by monochrom (lifeisalive)
10:05:50 --- mode: monochrom set -o monochrom
10:09:37 <duncan^> it's not even a bot, it's some stupid kid on an android phone
10:12:29 <nykros> Supose I have defined a funcion :: FileName -> IO () that performs some operation on a file. Is there a library where I can just plug my function and process all the files specified in the command line?
10:13:23 <nykros> I don´t want to parse and validate the command line myself.
10:13:52 <monochrom> getArgs gives you the command line as [String].
10:14:02 <monochrom> mapM_ works for lists.
10:14:06 <monochrom> Combine them.
10:16:01 <monochrom> getArgs is in System.Environment.
10:21:41 <Ojd> Hello, I am trying to learn how to program in Haskell (coming from Python) so I am reading "Learn You a Haskell for Great Good!"
10:21:55 <Zowlyfon> Ojd: good book
10:22:13 <sproingie> LYAH is good, it is a bit out of date with some of the library names though
10:22:22 <sproingie> imports, whatever
10:22:50 <sproingie> (i do find LYAH less good when it wanders into wall-of-text land)
10:22:51 <trigone> @src (*>)
10:22:51 <lambdabot> (*>) = liftA2 (const id)
10:23:00 <trigone> @src liftA2
10:23:01 <lambdabot> liftA2 f a b = f <$> a <*> b
10:23:13 <cocreature> it’s kind of annoying when books that are available online for free are not on some community managed git repository so they can be kept up2date
10:23:17 <ilyaigpetrov> Hi. Does haskell have streams based on infinite lists out of the box? I wander if `length` applied to infinite list is a obstacle for 'out of the box streams' in haskell
10:23:43 <Cale> ilyaigpetrov: You should generally avoid applying length anyway
10:24:12 <Cale> ilyaigpetrov: What exactly are you looking for in the way of streams?
10:24:22 <monochrom> Yes length is an obstacle. Now why do you ask for the length of an infinite list again?
10:24:53 <Cale> Obviously, computing the length of an infinite list or stream will take forever.
10:25:22 <Ojd> currently I am reading chapter 4, syntax in functions and I have a question about the typeclasses:
10:25:26 <Cale> Lists in Haskell may be infinite
10:25:32 <Ojd> https://thepasteb.in/p/66hVYAO6YGxiW
10:26:03 <Cale> Probably the second pattern should not be 7
10:26:12 <Cale> It should be _ or x or something
10:26:18 <Ojd> sorry, yes, x
10:26:18 <ilyaigpetrov> in streams values are drawn when needed from infinite source -- this is how I understand streams. So I thought streams should work out of the box in haskell only if you don't use length
10:26:19 <Ojd> typo
10:26:26 <Cale> Also, you're missing a :: in the type signature
10:26:32 <Ojd> https://thepasteb.in/p/KOh85vEQmogIJ
10:26:44 <Cale> but sure
10:26:47 <cocreature> it might be worth pointing out that lazy list in Haskell don’t really help with streaming once IO is involved (unless you’re willing to open the can of worms that is lazy IO)
10:26:48 <sproingie> cocreature: pretty sure LYAH does have some updated forks, but not having an official repo to take pull reqs... yeah
10:27:09 <monochrom> Why are there so many lucky 7 s?
10:27:22 <sproingie> i could fix LYAH, but then it'd be yet another fork floating out there
10:27:34 <Cale> ilyaigpetrov: Of course, if you use length, you're relying on the list actually being finite, or happy enough to let the program run forever in the case it's not.
10:27:43 <Ojd> I tried two approaches: first only with integer and second with any number
10:27:55 <Ojd> the first one (Integral a) worked just fine
10:28:27 <monochrom> OK, you also need Eq.
10:28:31 * geekosaur smells ghc-specific changes ahead
10:28:34 <monochrom> (Num a, Eq a) => a -> String
10:28:38 <Ojd> but Haskell complains with the second one. my understanding was that Num encompassesIntegral and Floating
10:28:51 <geekosaur> so, in standard Haskell, Num constraint implies Eq constraint. many books assume this.
10:29:06 <monochrom> No, Integral encompasses Num, not the other way round.
10:29:20 <the_2nd> when is Data.Vector more performant than list? I started using Data.Vector but might run into issues due to parallelization
10:29:20 <cocreature> huh I always thought that has been fixed in haskell2010 but I’ve never bothered to check
10:29:23 <Cale> geekosaur: That was true in Haskell 98... I'm not sure about 2010
10:29:28 <geekosaur> it's in 2010
10:29:37 <geekosaur> ths is a ghc-specific change post-2010
10:29:38 <monochrom> The change was post-2010.
10:29:57 <sproingie> the_2nd: because lists in haskell are linked lists, Data.Vector is packed into an array
10:30:08 <cocreature> ahrg it even has Show
10:30:13 <geekosaur> yes
10:30:22 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/21065/focus=21075
10:30:23 <sproingie> linked list is smeared all over the heap, to say nothing of every operation on it being lazy
10:30:27 <dfeuer> The top comment on https://www.reddit.com/r/haskell/comments/6lmlsx/learning_haskell_what_type_of_side_projects_to_do/ (by augustss) is really something.
10:30:31 <cocreature> luckily I don’t live in the past
10:30:45 <geekosaur> so, anyway using a numeric literal in a pattern match induces an Eq constraint, but your explicit signature omits it. in standard Haskell this would be ok because Num implies Eq.
10:31:07 <monochrom> hahahaha dfeuer
10:31:07 <geekosaur> in ghc 7.8 (iirc) and on, Num does *not* imply Eq, so you need to add the Eq constraint to your signature
10:31:27 <Ojd> thank you very much
10:32:21 <Cale> dfeuer: hahaha
10:32:22 <monochrom> I don't think it is GHC-specific. The Library Committee passed it.
10:32:40 <geekosaur> I don't think it's in a published standard yet
10:32:47 <sproingie> so basically it's part of Haskell' then?
10:32:58 <monochrom> No, it is unpublished for sure.
10:33:16 <geekosaur> it may well be in the *next* standard, but currently we have Haskell2010 as the standard and it still has Eq and Show on Num
10:33:16 <monochrom> Unless mailing list traffic counts.
10:33:29 <sproingie> having trouble thinking of a Num instance that would not be Eq
10:33:36 <dfeuer> Haskell 2010, for some reason, seems to be missing all the library documentation that Haskell 98 has.
10:33:50 <geekosaur> iirc it complicates reflecting KnownNat
10:34:09 <Cale> dfeuer: That's interesting about the Bits operations not inlining
10:34:19 <trigone> what's the deal with the reddit comment?
10:34:21 <dfeuer> sproingie: computable reals.
10:34:33 <Cale> dfeuer: We've had a lot of fun recently getting Monad instances to specialise and inline
10:34:41 <dfeuer> trigone: you'll have to read the post and then the comment....
10:34:52 <trigone> dfeuer: oh i just read the comment
10:35:23 <dfeuer> Cale: any luck?
10:35:31 <trigone> wait no actually i read both... still not sure to get it?
10:35:58 <Cale> dfeuer: We're getting there... there are still apparently a few binds and fmaps which aren't getting inlined, but Ryan's tracking them down
10:36:33 <dfeuer> trigone: the question was about side projects to learn Haskell. Lennart Augustsson (https://en.wikipedia.org/wiki/Lennart_Augustsson) explained that HBC was the side project he used for that purpose.
10:36:34 <geekosaur> heheh (re reddit)
10:36:45 <Cale> dfeuer: I backported a patch that Dan Haraj made, and Ryan rebuilt everything in the world with -fexpose-all-unfoldings
10:36:57 <monochrom> trigone: <Q> How do I learn Haskell by project? <A> By writing a Haskell compiler.
10:37:11 <dolio> That's what John Meacham did, too, I think.
10:37:23 <dfeuer> (specifically, the first Haskell compiler ever written...)
10:37:40 <trigone> oh ok i got it ^^ dunno why i didn't the first time
10:38:00 <trigone> is this an actually good advice?
10:38:02 <monochrom> The average people understand a sentence the 3rd time.
10:38:11 <trigone> monochrom: come again?
10:38:18 <monochrom> haha
10:38:26 <Cale> But yeah, it's pretty unfortunate, given the amount of performance degradation you see when stuff doesn't get specialised, that there isn't some syntax for constraints which *must* be specialised, or it's an error.
10:38:44 <monochrom> I actually have a theory of why people need 3 times to understand a sentence.
10:38:54 <Cale> It's like a factor of 60 if a Monad instance doesn't inline
10:38:54 <monochrom> The first time they aren't even paying attention.
10:39:09 <monochrom> The second time they refuse to believe it.
10:39:31 <monochrom> (And people do conflate "I don't understand" with "I don't want to believe".)
10:39:51 * geekosaur starting to think not inlining typeclass methods is a general problem with 8.2... seems to be coming up a fair amount :/
10:39:58 <Cale> trigone: If you're up to it, I think it's not terrible advice. Especially now that you can write that compiler in Haskell.
10:40:11 <Cale> trigone: But it is pretty extreme :)
10:40:51 <trigone> Cale: yeah i can imagine
10:41:02 <Rotaerk> best way to learn X ... much exposure to X
10:41:18 <dolio> augustss had already written compilers before, so he was kind of cheating.
10:41:22 <geekosaur> for some of us that's literal :p
10:41:39 <dolio> Compilers for languages like Haskell, even.
10:42:04 <geekosaur> (my route into actually writing Haskell being applying my X11 knowledge to xmonad...)
10:42:06 <trigone> monochrom: i don't get your understand/believe thingy... to understand a sentence and to believe it true are rather orthogonal issues...
10:42:21 <monochrom> Sure but people conflate them.
10:42:26 <geekosaur> trigone, most people don't think about it that way
10:42:58 <geekosaur> people hve set beliefs, if they read something that conflicts, their first response is that they must be misunderstanding the conflicting thing, because it doesn't agree with their set beliefs
10:43:00 <monochrom> I mean I don't conflate "trigone doesn't understand" with "trigone doesn't believe". But do you? How do you even know?
10:43:59 <trigone> monochrom: i don't understand :P seriously, your last sentence is weird. i don't believe in you
10:44:04 <monochrom> Think of the last time you had confusion when learning Haskell. And compare with my favourite saying "all confusions are due to wrong assumptions".
10:44:23 <Zowlyfon> monochrom: good saying
10:44:32 <dolio> It's false, though. :)
10:45:23 <Rotaerk> I'm confused
10:45:26 <Rotaerk> therefore I am
10:45:38 <trigone> Rotaerk: you're confused, how can you be sure?
10:45:45 <monochrom> Confuso ergo sum? :)
10:46:11 <monochrom> @quote monochrom carte
10:46:11 <lambdabot> monochrom says: data DeCarte = forall a. Think a => Exist a
10:46:20 <monochrom> Hmm, not that one
10:46:47 * geekosaur can't find the quote about confusion being the first step toward redemption...
10:46:48 <monochrom> Ah lambdabot doesn't have it.
10:47:01 <monochrom> CoCarte says: Coproduct ergo sum. :)
10:47:13 <monochrom> err, CoCartes!
10:47:29 <trigone> pretty sure it's written Descartes
10:48:16 <monochrom> Maximum irony when you recall Descartes being the one invention cartesian product!
10:48:24 <monochrom> s/invention/inventing/
10:48:29 * hackagebot shelly 1.6.8.4 – shell-like (systems) programming in Haskell – https://hackage.haskell.org/package/shelly
10:48:59 * geekosaur watches co-joke soar overhead...
10:49:10 <geekosaur> er. "co-"-joke
10:49:22 <monochrom> I also have a complex analysis joke. Do you want it?
10:49:32 <geekosaur> (now with bonus use/mention confusion!)
10:50:04 <sproingie> a cojoke is told by the audience to the comedian?
10:50:22 <sproingie> (thus making hecklers cocomedians?)
10:50:47 <monochrom> Ah no one wants my complex analysis joke. So I will give you a fold joke instead.
10:51:07 <cocreature> monochrom: can you fold the complex analysis joke and the fold joke into one joke?
10:51:11 <sproingie> as a worker, i turn Problems into Solutions.  i have coworkers.
10:51:13 <monochrom> catmorphism :: Fish f => (f r -> r) -> Meow f -> r
10:51:14 <JohannaHulten> Hi all, I'm studying for an exam in Haskell and could use some help explaining one thing from an old exam if anyone is up for it. As part of one question I'm given the following definition "data MyNatural = Empty | () :-: MyNatural deriving (Eq, Show) infixr 5 :-:" with infixr on its own line. What I don't understand is the second constructor and the last line
10:51:22 <monochrom> No, I can't.
10:51:48 <trigone> monochrom: meowling fish?
10:52:06 <lyxia> JohannaHulten: The second constructor is named (:-:)
10:52:51 <JohannaHulten> Ahh, and it takes a MyNatural 
10:53:09 <lyxia> JohannaHulten: infixr 5 :-:   sets its precedence to determine how to parse expressions with many infix operators
10:53:10 <monochrom> Not just that. It takes two parameters. MyNatural is 2nd.
10:53:18 <geekosaur> JohannaHulten, leading colon on a symbol marks a constructor, like leading uppercase on a name marks a constructor
10:53:26 <trigone> JohannaHulten: and a (), for some weird reason. () is a type, whose sole constructor/value is also written ()
10:53:37 <sproingie> () is pronounced "unit"
10:53:48 <trigone> it's equivalent in prefix notation to (:-:) () MyNatural
10:54:03 <trigone> oh nevermind it's not weird, i hadn't noticed the recursion
10:54:37 <sproingie> the last line is there to set the precedence and associativity of :-:
10:54:41 <sproingie> mostly for the associativity
10:55:10 <monochrom> Review how you can have data constructors in infix notation.
10:55:22 <monochrom> Because prefix is not spicy enough. :)
10:55:26 <JohannaHulten> Thanks
10:55:31 <sproingie> meh, gimme mixfix :)
10:55:40 <trigone> sproingie: what's mixfix?
10:55:54 <monochrom> if-then-else is an example of mixfix.
10:55:55 <sproingie> arbitrary intermixing of constructors and terms, basically
10:56:01 <monochrom> [1,2,3] is too.
10:56:24 <trigone> hm k
10:56:45 <trigone> i'd have called that interfix :P
10:57:10 <monochrom> intermix
10:57:26 <sproingie> sounds like DJ names
10:57:36 <trigone> lol that's so true
10:58:37 <trigone> what's a REST API?
10:59:04 <monochrom> look for "RESTful"
10:59:19 <monochrom> "RESTful web app" if necessary
11:00:11 <trigone> hm got it... i barely understand but then i don't know much on networking
11:00:27 <sproingie> it's not really to do with networking, it's an application architecture in general
11:00:47 <sproingie> the original paper is https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
11:00:52 <sproingie> it's very hand-wavey
11:01:48 <trigone> hand-wavey?
11:01:53 <sproingie> vague
11:02:21 <trigone> k... thanks for the link
11:03:49 <trigone> @src liftF
11:03:49 <lambdabot> Source not found. Abort, Retry, Panic?
11:03:50 <sproingie> the overall idea is you don't keep state on the server, you transfer the state to clients, preferably as part of some document or structure that describes the possible actions from there (e.g. "links")
11:04:55 <sproingie> stuff like .net or JSF viewstates would qualify as transferring state, but fail on the second (representational) part
11:05:12 <trigone> sproingie: you know i may have understated my ignorance, but it's not really important, it was just something mentioned in passing in something else, i'm not focused on that for now. thanks to have tried anyway :P
11:05:32 <trigone> *for having tried
11:05:40 <monochrom> sproingie: What does the "representational" part require?
11:05:49 <sproingie> more hand waving, apparently
11:05:56 <monochrom> haha
11:06:59 <sproingie> but the idea is it's self-contained, or at least expressed in a form requiring no extra mechanics beyond the standard verbs of http
11:07:14 <sproingie> tho RTF was always going about wanting to add more methods to HTTP so w/e
11:07:34 <trigone> w/e? whatever?
11:07:37 <sproingie> yep
11:07:40 <osa1> can I use injectivity annotations on associated types?
11:08:09 <trigone> > l
11:08:12 <lambdabot>  l
11:10:47 <trigone> @hackage test
11:10:47 <lambdabot> http://hackage.haskell.org/package/test
11:10:52 <trigone> @hackage Free
11:10:52 <lambdabot> http://hackage.haskell.org/package/Free
11:11:02 <trigone> @hackage free
11:11:02 <lambdabot> http://hackage.haskell.org/package/free
11:11:27 <sproingie> @hackage arbitrarythingamajig
11:11:27 <lambdabot> http://hackage.haskell.org/package/arbitrarythingamajig
11:11:35 <geekosaur> yeh, @hackage is dumb
11:11:49 <geekosaur> and the l thing is...
11:11:50 <geekosaur> :t l
11:11:52 <lambdabot> Expr
11:11:57 <geekosaur> @hackage simple-reflect
11:11:57 <lambdabot> http://hackage.haskell.org/package/simple-reflect
11:12:15 <Zowlyfon> lol
11:14:06 <trigone> is Expr a real type?
11:14:23 <tabaqui> funny
11:14:36 <tabaqui> there can be no Functor instance for GADT type, right?
11:14:57 <tabaqui> and any other class for * -> *
11:14:57 <geekosaur> trigone, http://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Expr.html
11:15:03 <geekosaur> which is why I pointed at that
11:16:07 <trigone> oh ok thx
11:17:03 <monochrom> tabaqui: Recently I discovered "data M a where C1 :: M Int; C2 :: M (Int -> Int)" so yeah I don't think I know how to make it a Functor.
11:17:07 <trigone> i actually typed a l just to test if it looked like the digit 1 or not ^^
11:17:52 <trigone> (for the font from where i stand)
11:19:21 <lmapper> hi everyone, I've written something this morning, which compiles, but I'd like to make it more concise
11:19:28 <lmapper> http://lpaste.net/357497
11:19:32 <trigone> i have trouble understanding the source of Free.liftF, by any chance could anybody write it in some simple form? (if it's possible)
11:19:53 <lmapper> I imagine I should use GADTs, but not sure how to approach it yet
11:20:52 <lmapper> I have also been experimenting with free monads, but haven't implemented anything with them yet
11:20:57 <Cale> lmapper: GADTs won't really make it more concise, but they will help you typecheck the expressions
11:21:23 <lmapper> Cale, would I be able to remove the "rInt" business?
11:21:53 <Cale> I'm not entirely sure what this Finish expression is about
11:23:34 <Cale> It looks like a weird identity function application?
11:23:55 <trigone> lmapper: personally i'd write eval :: Expr -> Int directly instead of separating the "end" of evaluation with rInt
11:24:32 <lmapper> I just tried to remove Finish, but I now realize, since I'm continually returning a Function, there needs to be a way to finish the computation instead of returning another function
11:25:04 <Cale> I'm not sure I understand
11:25:24 <Cale> Removing Finish doesn't seem like it would change much
11:25:27 <trigone> oh nevermind i hadn't realized you used rInt in other stuff...
11:26:04 <Cale> Oh, rAdd does evaluation
11:26:12 <Cale> Well, that's odd
11:26:14 <trigone> i'm not sure to understand the fact that rAdd seems to basically force interpretation then wraps back the result... but what's the point of systematically interpreting everything?
11:26:42 <Cale> Why not just have rAdd, etc. produce expressions that do the addition?
11:26:58 <lmapper> thanks, hold on, phone call
11:27:10 <monochrom> Perhaps GADT can get rid of the Finish case altogether.
11:27:25 <trigone> what's the semantics of the Finish thing?
11:27:39 <Cale> Well, it'll remove some of the awkward cases where you can't handle stuff, anyway
11:27:54 <monochrom> Because at present you can't say "eval :: Expr -> Int" or "eval :: Expr -> Double" or any other variation.
11:28:22 <trigone> aesthetically a top-level function called `i` is pretty much the worst possible choice...
11:28:25 <lmapper> ok, I'm back, sorry about that
11:28:25 <Cale> Right -- you currently have to know what type of result you want from evaluation, and have error cases
11:28:31 <monochrom> So you settle for "eval :: Expr -> Expr" but uses Finish to mark "I'm done".
11:28:52 <Cale> trigone: It's not a bad name for something you expect to use an awful lot
11:28:53 <monochrom> With GADT it is simply "eval :: Expr a -> a".
11:29:09 <lmapper> originally I wanted to have a way to have a list of arbitrary functions, with different kinds and arity
11:29:27 <lmapper> so I can call them programmatically from a config file
11:29:48 <monochrom> However, people already know how to live with ADT. They simply create a 2nd ADT for "finished" values.
11:29:49 <lmapper> but I can't yet grasp extensions like PolyKinds, etc
11:30:19 <trigone> Cale: dunno... it seems pretty rare nonetheless, usually if you use a function everywhere, there's some refactoring to think about (at least that's my intuition)
11:30:43 <trigone> (everywhere to the point that having a descriptive name would make things *that* verbose)
11:30:44 <Skyb0rg> Can anyone help with setting up Atom to find installed packages? It's not recognizing the control.lens import although ghci does
11:30:48 <lmapper> so I wrote this, in which I'm sort of doing my own "currying"
11:32:25 <lmapper> the "i" function was just a really temporary thing, I'm planning to refactor this, this is just a quick test to work out the logic
11:33:37 <trigone> lmapper: regardless of the rest, you can write eval by putting the three first pattern matches at the end, using just one case eval v = v.
11:33:52 <Cale> With a GADT, you could even just do something like this:
11:33:56 <Cale> data Expr a where Pure :: a -> Expr a; App :: Expr (a -> b) -> Expr a -> Expr b
11:33:57 <trigone> to englob every other cases beyond Finish and Function
11:34:27 <Cale> eval :: Expr a -> a; eval (Pure x) = x; eval (App f e) = eval f (eval e)
11:34:33 <lmapper> trigone, ah, so true, consider it done
11:34:49 <monochrom> Yeah that's neat.
11:35:39 <monochrom> Let's hack into the GHC website and facelift the user guide's GADT example to this. :)
11:35:49 <Cale> haha
11:35:59 <Cale> Well, you can't really do much analysis on this kind of expression type
11:36:14 <Cale> So it's higher order to the point of near-uselessness
11:36:43 <lmapper> Cale, that looks brilliant, I'll give it a try
11:36:47 <Cale> But it might be a good starting point anyway
11:37:06 <monochrom> I don't think that example really cares about the difference between Succ and IsZero.
11:37:54 <monochrom> It is eval all over again rather than something that really cares, such as "I want to do algebraic rewriting on your terms".
11:38:19 <Cale> Fair enough :)
11:41:01 <Cale> lmapper: What is this for?
11:41:20 <Cale> lmapper: I have a feeling that if my Expr type will work, then so would no expression type :)
11:41:56 <monochrom> Yeah, I was about to come to that conclusion as well. It only buys laziness, but we already have laziness.
11:42:38 <monochrom> But if the expressions are meant to be context-dependent, and get re-evaluated a million times under a million different contexts, then you need a recipe not a thunk.
11:43:07 <Cale> But yeah, you could add some constructors to this foundation, and make the expressions more possible to analyse before evaluation
11:43:38 <Cale> It's just the Pure terms will be black boxes for the most part
11:43:53 <monochrom> The a->b part is also pretty black.
11:44:12 <Cale> Well, something could have type Expr (a -> b) without actually containing Haskell functions.
11:44:24 <Cale> (if we're assuming that additional constructors get added to the type)
11:44:31 <monochrom> Ah OK.
11:44:33 <lmapper> I'm going to parse a "config" file, which contains a list of nodes, and other nodes they are connected to, where each node corresponds to a different Function
11:44:41 <Cale> e.g. you could introduce  Plus :: Expr (Int -> Int -> Int)
11:44:42 <lmapper> the nodes have different numbers of inputs
11:44:56 <lmapper> so the Functions also have different arity
11:45:36 <lmapper> thus, a map collecting those functions, would involve different kinds
11:45:52 <trigone> Cale: if you remove Pure, you end up with Expr b = App (a -> b) a, that's even more transparently useless :P
11:45:56 <Cale> Uh, shouldn't be different *kinds* if you meant that in the technical sense
11:46:18 <monochrom> Yeah, different types.
11:46:19 <Cale> trigone: Well, you could remove Pure and add in other primitive constructors
11:46:45 <lmapper> well, a function of a -> b , and function a -> b -> c , aren't they different *kinds*?
11:46:50 <Cale> trigone: Ones whose meaning could be understood prior to evaluation
11:46:54 <Cale> lmapper: no
11:46:55 <trigone> Cale: well sure, but Pure alone is absurd since there's no other primitive constructor to contrast with
11:47:00 <monochrom> different types
11:47:13 <Cale> lmapper: Any type with ordinary values in it has kind *
11:47:15 <trigone> (right?)
11:47:42 <monochrom> @kind Int->Bool
11:47:44 <lambdabot> *
11:47:49 <monochrom> @kind Int->Char->Bool
11:47:51 <Cale> trigone: I guess you could still make infinite trees of App constructors, but pretty much :P
11:47:51 <lambdabot> *
11:48:10 <Cale> trigone: If you don't have some way to get started, App isn't terribly useful
11:48:16 <dylukes> In general, what can be said about types which subscript themselves? e.g. a Bitmask type can define `m1[m2]` as mask checking,  and `m1[m2] = True/False` as setting/unsetting. 
11:48:21 <dylukes> I'm not sure of any other compelling examples.
11:48:22 <trigone> get started?
11:49:04 <Cale> trigone: I mean, it's true that if App were the only data constructor, the expression type wouldn't be very useful
11:49:27 <trigone> Cale: ok you mean, as base for more extensive vocabulary
11:49:29 <Cale> trigone: But you could include other mechanisms for getting hold of the constants you need
11:49:38 <monochrom> dylukes: Why is m1[m2] a type? Why is it not a value? reference? lvalue?
11:49:43 <dylukes> It is a value. 
11:49:47 <Cale> (rather than Pure which just injects a black box into the expression tree)
11:49:55 <dylukes> types whose values subscript themselves* 
11:50:02 <dylukes> As in, you can subscript a Mask with another Mask. 
11:50:16 <trigone> what does subscript mean?
11:50:26 <dylukes> Indexable by something. 
11:50:35 <dylukes> I'm not being specific to Haskell really.
11:50:41 <dylukes> Haskell's Ix only does Integer keys.
11:50:55 <Cale> That isn't true
11:51:57 <monochrom> OK, then you need to grow out of the funny syntax "m1[m2]" and see through it semantically as an expression "f m1 m2".
11:51:58 <Cale> Well, okay, it does keys of arbitrary types which translate into integer indices
11:52:28 <monochrom> in which m1 is a bit lens, m2 is a bit lens, and f is a combinator of two bit lenses.
11:53:07 <dylukes> I agree with that.
11:53:20 <dylukes> Except that such a Mask has a purpose beyond just being a lens.
11:53:30 <monochrom> And it is very possible f = (.) because (.) is also what I use to dig into a record and then dig into a deeper record again.
11:53:50 <mivael_> :t  let  repeatAsPair x = (x, x)  in  repeatAsPair
11:53:52 <lambdabot> t -> (t, t)
11:54:02 <mivael_> Are there point free ways to express repeatAsPair?
11:54:08 <Cale> join (,)
11:54:10 <dylukes> Anyhow, this is kind of ancillary... I'm more wondering what can be said about *data types* which index themselves in some sense.
11:54:18 <trigone> mivael_: @pl (,)
11:54:23 <monochrom> What? No way! lens already supercedes getter (mask checking) and setter (setting/unsetting)
11:54:24 <trigone> @pl (,)
11:54:24 <lambdabot> (,)
11:54:31 <Cale> @pl \x -> (x,x)
11:54:31 <lambdabot> join (,)
11:54:33 <trigone> @pl \x -> (x,x)
11:54:33 <lambdabot> join (,)
11:54:47 <Cale> Need a point to be able to remove a point :)
11:54:49 <mivael_> thank you!
11:55:02 <dylukes> monochrom I know... that's not the point though. If it's easier to talk about generalized to lenses then by all means. 
11:55:06 <mivael_> I forgot (again) about the @pl feature.
11:55:49 <trigone> wait how can (,) be of type Monad m => m (m x)? (is it again that horrible half-function monad?)
11:56:00 <trigone> :t join
11:56:01 <mivael_> Why the name, by the way (pl)?  How to memorize it?
11:56:02 <lambdabot> Monad m => m (m a) -> m a
11:56:19 <Cale> trigone: Yeah, pick m t = e -> t
11:56:30 <trigone> mivael_: it's like point free, except it's a l instead of f... :P
11:56:40 <Cale> join f x = f x x
11:57:40 <Cale> trigone: The function monad's just the same thing as the Reader monad, but unwrapped.
11:58:44 <trigone> Cale: hm... it's a bit clearer, tho to be fair i'm not used to join over Reader monad values...
12:02:14 <Squarism> ...back from vacation and my personal project of in-any-way-possible (runtime or TH or some other compile time trick). Take a value with a type list type (ie '[Int,String] ) and make that available as a Data.List of either String or type-that-addresses-types at runtime. Im sort of clueless on how to achive it though
12:02:35 <Squarism> ..from vacation to my pers...
12:02:36 <geekosaur> mivael, "pointless" which is a play on "pointfree" and the plugin's tendency to produce dotty, flippy insanity
12:03:30 <monochrom> @quote monochrom \$
12:03:30 <lambdabot> monochrom says: $ can't buy you love, but it can buy you function application
12:03:38 <monochrom> err not that one
12:03:40 <monochrom> @quote monochrom \$
12:03:40 <lambdabot> monochrom says: "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
12:03:40 <Cale> trigone: Here's another way to look at it: "running" a function in this monad just means applying it to the parameter (of the overall function being constructed)
12:03:46 <Cale> trigone: So:
12:04:02 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:04:04 <lambdabot>  ("hello","olleh","HELLO")
12:04:27 <Cale> trigone: join x will always "run" x, and then "run" the result of that
12:04:44 <Cale> So in our case, that just means applying the function to the parameter twice
12:04:55 <ongy> @pl ($)
12:04:55 <lambdabot> id
12:05:46 <Cale> > (do f <- (*); x <- f; return x) 5
12:05:48 <lambdabot>  25
12:06:10 <trigone> Cale: hm... what's the def of >>= for monadReader?
12:06:53 <phadej> f >>= g = \x -> g x (f x)
12:07:14 <trigone> f = partially applied (*)?
12:07:17 <trigone> oooh i get it
12:07:27 <trigone> i think
12:07:35 <Cale> trigone: yeah, f = (*) 5, and then x = f 5
12:07:49 <johnw> trigone: intuitively: It takes a value produced "within an environment (x)" plus a function that takes that same environment and that produced value
12:08:08 <johnw> in other words, the static environment is carried through all computations
12:08:09 <phadej> liftA2 :: (a -> b -> c) -> f a -> f b -> f c, is easier to understand: liftA2 f g h = \x -> f (g x) (h x)
12:08:36 <phadej> > liftA2 (*) (+1) (+2) 3
12:08:38 <lambdabot>  20
12:08:55 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
12:08:57 <lambdabot>  [5,7,10,25,32]
12:09:39 <phadej> you can abuse applicative/monadic operators to make your code "magical" ;)
12:09:51 <phadej> > join (*) 5
12:09:51 <trigone> and unreadable :P
12:09:53 <lambdabot>  25
12:10:14 <ongy> :t join (*)
12:10:15 <lambdabot> Num a => a -> a
12:10:58 <ongy> :t (<*>) (*) -- I hate that I still don't fully undersand the (->) instances -,-
12:11:00 <lambdabot> Num a => (a -> a) -> a -> a
12:11:25 <Cale> ongy: Well, start with Monad, look at that do-block I wrote above with "reverse"
12:11:29 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:11:31 <lambdabot>  ("hello","olleh","HELLO")
12:12:45 <Cale> Of course, another option is just to look at the types. If you substitute m t = e -> t throughout, you'll end up with a type which if you think about it, it'll tell you exactly what each of the basic combinators does.
12:13:14 <ongy> :t (>>=)
12:13:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:13:29 <Cale> So that becomes (e -> a) -> (a -> e -> b) -> e -> b
12:13:38 <monochrom> If you can't think about it, you can ask @djinn :)
12:14:39 <Cale> If we want to write this function, we have:
12:14:45 <Cale> f :: e -> a
12:14:49 <ongy> @djinn (e -> a) -> (a -> e -> b) -> e -> b -- let's see if we can
12:14:50 <lambdabot> Cannot parse command
12:14:51 <Cale> g :: a -> e -> b
12:14:54 <Cale> x :: e
12:15:00 <Cale> and we want b
12:15:09 <Cale> There's only one way to get b, which is to apply g
12:15:23 <Cale> (f >>= g) x = g ... ...
12:15:38 <Cale> now for the first argument to g, we need something of type a
12:15:47 <Cale> There's only one way to get something of type a, which is to apply f
12:15:54 <Cale> (f >>= g) x = g (f ...) ...
12:16:13 <Cale> and then the first argument of f needs to be something of type e, there's only one way to get it, x
12:16:17 <Cale> (f >>= g) x = g (f x) ...
12:16:31 <Cale> and then again, we need something of type e, and there's still only one way
12:16:34 <Cale> (f >>= g) x = g (f x) x
12:17:15 <ongy> :t (<*>)
12:17:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:17:38 <ongy> so that's: e -> (a -> b) -> (e -> a) -> e -> b
12:17:48 <Cale> you lost some parens
12:18:03 <Cale> (e -> (a -> b)) -> (e -> a) -> e -> b
12:18:04 <Cale> which is
12:18:07 <ongy> oh right, around the first
12:18:13 <Cale> (e -> a -> b) -> (e -> a) -> e -> b
12:18:36 <Cale> So this ends up being almost the same story, only the arguments to the thing are flipped
12:19:36 <ongy> > (const 5) >>= (*)
12:19:38 <lambdabot>  <Integer -> Integer>
12:19:53 <ongy> ah right
12:22:04 <trigone> to me it's clearer when defining that the output of f >>= k is k . f
12:22:31 <trigone> at least i think so?
12:24:14 <ongy> I don't think so. we had the \x -> k (f x) x earlier
12:28:21 <trigone> f :: e -> a, g :: a -> (e -> b), g . f :: a -> (e -> e -> b)
12:28:28 <trigone> oops
12:28:35 <trigone> i meant g . f :: e -> e -> b
12:28:39 <trigone> you're right
12:29:09 <ongy> :t fmap -- iirc that one's (.)
12:29:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:29:28 <ongy> :t (.)
12:29:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:32:54 <trigone> hm right
12:34:22 <trigone> f >>= g = join (fmap g f) = (\f x -> f x x) (g . f)
12:34:26 <ongy> I remember that one, because people seem to like
12:34:30 <ongy> :t fmap fmap fmap
12:34:32 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
12:37:03 <mivael_> geekosaur: oh, I see  :)
12:37:41 <Tuplanolla> One of the first things I'm going to do with Haskell's dependent types is define `deepFmap 0 = id; deepFmap 1 = fmap; deepFmap 2 = fmap fmap fmap; ...`.
12:39:08 <Cale> Tuplanolla: You'll have to write its type of course. :)
12:39:22 <dolio> You could already do that, I think.
12:39:47 <Tuplanolla> Let's see it, dolio.
12:40:21 <ongy> with tH?
12:40:24 <dolio> Nah, it's too much work for something I don't care about.
12:40:26 <ongy> or those type level Nats?
12:40:49 <Tuplanolla> I know how I'd splice it, but not much else.
12:42:50 <cocreature> Tuplanolla: can the argument be an SNat instead of an Int? :)
12:42:57 <dolio> Oh, maybe you can't do it because the type involves foralls.
12:43:28 <dolio> Anyhow, even in e.g. Agda it's annoying.
12:44:35 <bvad> Anyone using spacemacs + intero who's figured out how to get projectile to ignore .stack-work/intero/interoscript* files? Everything else in .stack-work is ignored
12:45:10 <cocreature> bvad: projectile respects gitignore
12:46:05 <bvad> cocreature: Well yes, just not .stack-work/intero/intero-script* files for some reason. 
12:46:41 <cocreature> bvad: sounds like a bug in projectile. I’ve never had that happen to me. sry for not being more helpful :/
12:48:34 <bvad> cocreature: Maybe it is. I wonder if it has something to do with the way those files are generated by intero
12:48:56 <cocreature> bvad: does "git ls-files" show them?
12:51:05 <bvad> cocreature: It does not 
12:54:41 * hackagebot DeepDarkFantasy 0.2017.8.7 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
12:55:52 <bvad> cocreature: My theory is that it has something to do with how the file is created and opened using `with-current-buffer` that tricks projectile.. code here: https://github.com/commercialhaskell/intero/blob/master/elisp/intero.el#L1318 
12:56:26 <cocreature> bvad: what is the exact projectile command that you are running?
12:56:53 <bvad> cocreature: `helm-projectile-find-file` 
12:57:28 <cocreature> bvad: just to be sure, does it also happen with projectile-find-file itself?
12:57:44 <cocreature> I’m confused why this w ouldn’t happen for everyone if the problem was the elisp of intero
12:59:00 <bvad> cocreature: I've actually just re-installed all elpa packages, same issue both before and after 
12:59:12 <bvad> cocreature: it may be a spacemacs bug 
12:59:20 <cocreature>  *shrug* I’m out of ideas
13:00:09 <bvad> thanks anyhow 
13:02:15 <Squarism> Anyone know ANY trick (TH or runtime) to achive the following. Given: a value "x" of type level list type (ie '[Int,Bool]). Wanted: y :: Typeable a => [a]  
13:03:11 <mivael_> > (=<<) id (++) [2,1,3]
13:03:13 <lambdabot>  [2,1,3,2,1,3]
13:03:26 <mivael_> > join (++) [2,1,3]
13:03:28 <lambdabot>  [2,1,3,2,1,3]
13:03:42 <cocreature> Squarism: that doesn’t make sense. "Typeable a => [a]" still forces the elements of those lists to have the same type
13:04:00 <cocreature> Squarism: you might be looking for [forall a. Typeable a => a]
13:04:14 <cocreature> that’s called impredicative polymorphism
13:04:19 <cocreature> but sadly it’s not supported by ghc
13:04:39 <cocreature> you can however make a newtype and use that
13:04:43 <Squarism> cocreature, oh.. really Wanted : y :: [TypeRep]
13:04:57 <cocreature> sry I’m not following
13:05:22 <cocreature> is that the TypeRep in GHC?
13:05:54 <Squarism> cocreature, no in Data.Typeable
13:06:16 <Squarism> ...which is https://hackage.haskell.org/package/base-4.10.0.0/docs/Type-Reflection.html#t:SomeTypeRep
13:06:23 <Squarism> ==
13:07:15 <cocreature> Squarism: can you provide some example of what exactly you’re trying to do? I’m also not entirely sure what a value of a type-level list type is supposed to be. do you mean an hlist?
13:07:27 <Squarism> cocreature, ok
13:08:32 <hrehf> I get linker errors when compiling with ghc --make -o a.out my.hs, how can I find out why?
13:08:48 <cocreature> hrehf: show us the actual error :)
13:09:26 <hrehf> cocreature: https://gist.github.com/553d906c2ab1e3e921870ba5b3ad588b ;-)
13:09:37 <ongy> archlinux?
13:09:51 <ongy> ^ hrehf
13:09:54 <cocreature> definitely archlinux
13:09:54 <hrehf> it's this file: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/LaTeX#recursiveparser.hs
13:09:58 <hrehf> ongy: yes
13:10:04 <cocreature> *sigh*
13:10:09 <ongy> do we have an faq entry for that somewhere?
13:10:09 <geekosaur> install the ghc-static package and pray
13:10:17 <geekosaur> arch broke ghc
13:10:24 <hrehf> what did they do? 
13:10:28 <geekosaur> alternately add -dynamic
13:10:42 <geekosaur> ghc links statically to haskell libraries by default. arch removes all static ghc libraries
13:10:51 <cocreature> they switched to distributing dynamically linked packages while leaving the default of ghc to link statically
13:10:51 <ongy> they made all packages dynamic and don't provide the static libs. which ghc wants to use by default
13:10:59 <geekosaur> and didn't rebuild ghc to default to dynamic haskell libraries
13:11:08 <hrehf> ah
13:11:24 <hexagoxel> Squarism: isn't that a class? like class HasTypeReps ts where getTypeReps :: Proxy ts -> [TypeRep]
13:11:26 <geekosaur> so simple uses of ghc now fail with that because dynamic libs are named differently from static libs
13:11:41 <hrehf> ok, -dynamic works. that just links everything dynamically? then I'll just use that as the default?
13:11:42 <cocreature> hrehf: step 1. get a statically linked version of cabal from somewhere if you intend to use that step 2. nuke everything haskell-related that you installed via pacman except for ghc and ghc-static
13:11:51 <geekosaur> (ghc has interesting dependency handling; dynamic Haskell libs are basically a lose)
13:12:25 <hrehf> that sounds like work :(
13:12:52 <cocreature> step 3. tell the arch maintainer to stop breaking shit
13:12:52 <ongy> if you first nuke, you can use cabal-install-git from the aur. works for me TM
13:13:02 <ongy> (I made the pkgbuild, it's not the best thing, but it works)
13:14:41 <Squarism> sorry, went away writing example here 
13:14:41 <mivael_> >  let  f = (=<<) id  in  [f Nothing, f (Just Nothing), f (Just (Just 3))]
13:14:43 <lambdabot>  [Nothing,Nothing,Just 3]
13:14:43 <Squarism> http://lpaste.net/357499
13:14:51 <Squarism> cocreature, ^
13:15:27 <hrehf> re: FAQ arch, here's basically the info from above: https://wiki.archlinux.org/index.php/haskell#Problems_with_linking
13:15:52 <hrehf> thanks for your help!
13:16:06 <cocreature> that’s missing the “nuke everything except for ghc and ghc-static” part if you want to keep using static linking
13:17:36 <jaseemabid> Anyone familiar with megaparsec? I'm trying to use the signed lexeme, but I *don't* want it to consume the spaces b/w the sign and the number. Basically I want it to fail for "- 10" and succeed only for "+1" or "-1". How can I do this? 
13:18:49 <jaseemabid> The implementation of signed seems to be using lexeme (https://hackage.haskell.org/package/megaparsec-6.0.2/docs/src/Text-Megaparsec-Char-Lexer.html#signed), which is consuming all the spaces after the initial sign even if I use an _empty_ parser like `symbol ""`. 
13:19:14 <Tuplanolla> Manually, I reckon, jaseemabid.
13:19:30 <Squarism> hexagoxel, where is that defined?
13:20:08 <jaseemabid> @Tuplanolla, alright. I can _not_ use signed combinator. I was wondering if there is any better way of doing it. Thanks
13:20:08 <lambdabot> Unknown command, try @list
13:20:14 <jaseemabid> Tuplanolla, alright. I can _not_ use signed combinator. I was wondering if there is any better way of doing it. Thanks
13:20:48 <hexagoxel> Squarism: nowhere yet.. i just mean that you are asking for a translation from type to value level, and there classes come in.
13:22:37 <cocreature> Squarism: how about http://lpaste.net/357500
13:25:57 <trigone> can i write a where clause right after one branch of a case-of expression? aka case x of { A -> x where x = ...; B -> ...}
13:26:30 <dolio> trigone: Yes.
13:26:33 <trigone> overall, is there any limitation to using where clauses instead of let-in?
13:27:03 <trigone> as in, is (x where y) an expression in the same way than (let y in x) or not?
13:27:07 <Cale> no
13:27:18 <Cale> where is part of the syntax of declarations (and case expressions)
13:27:26 <Cale> and it scopes over multiple guards
13:27:32 <dolio> No, the where is attached to the variable introductions.
13:27:38 <monochrom> "where" belongs to a binding rather than an expression.
13:27:54 <Tuplanolla> > (x where x = 42)
13:27:56 <Cale> Yeah, that's a good way to put it
13:27:56 <lambdabot>  <hint>:1:4: error: parse error on input ‘where’
13:28:14 <monochrom> By "binding" we mean things like "f x  = " and inside case-of "pattern -> "
13:28:15 <Tuplanolla> > (let x = 42 in x)
13:28:17 <trigone> hm... the binding you get from the pattern match?
13:28:17 <lambdabot>  42
13:28:28 <epta> With stack it's possible to point to a local/github dependency package. Does cabal 2 have the same functionality in new-build or something?
13:28:29 <Rotaerk> trigone, you might have something like:  f x = do { a <- m; let b = g a; h b }
13:28:32 <dolio> But not bindings in a lambda.
13:28:47 <Cale> (or a do-block)
13:28:52 <dolio> Right.
13:28:53 <Rotaerk> trigone, in that, a where clause for f would have access to x but not to a
13:28:54 <phadej> > let x = y where y = 42 in x
13:28:56 <lambdabot>  42
13:29:10 <monochrom> Yeah I need a name for those things that own "where".
13:29:33 <monochrom> But I want to avoid the tautological "contexts of where". :)
13:30:10 <trigone> Rotaerk: well sure, its scope is outside the lambda(s) implicitly created with the do-block
13:30:11 <phadej> epta: local yes, http://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
13:30:31 <phadej> epta: remmote locations are not implemented (yet)
13:31:18 <monochrom> I kind of regret that Haskell didn't go Landin's way. Because Landin had "where" owned by expressions.
13:31:24 <Rotaerk> I'll say that I use where a lot more than let
13:31:30 <Rotaerk> I don't use lets very often at all
13:31:38 <trigone> monochrom: owned means it was interchangeable with let-in?
13:31:40 <monochrom> And look what happens to all the beginners now. We have to tell them the unintuitive rule.
13:31:50 <monochrom> Own means own.
13:31:53 <Tuplanolla> I just tell them not to use `where`, monochrom.
13:32:03 <dolio> If it were attached to expressions, it wouldn't be able to do some things it can now.
13:32:10 <trigone> monochrom: you're not helpful
13:32:14 <Squarism> cocreature, needing to update base here so i havent been able to test yet
13:32:28 <trigone> dolio: like what?
13:32:36 <dolio> Like define something that appears in a guard.
13:32:48 <monochrom> Yes but we can always use another keyword or another syntax arrangement for what our "where" does.
13:33:03 <phadej> Tuplanolla: but they need where for module definition and type classes!
13:33:17 <jared-w> What's the unintuitive rule for 'where'?
13:33:18 <trigone> dolio: hm... what's the expression desugarized equivalent of guards?
13:33:32 <Tuplanolla> Yes, but they don't even notice, phadej.
13:33:34 <monochrom> jared-w, that "x + y where x=2; y=3" isn't a thing.
13:33:51 <dolio> if/then/else, or case statement stuff.
13:33:54 <jared-w> monochrom: idk, that never seemed unintuitvie to me
13:33:54 <phadej> Tuplanolla: that true, I noticed only afte years that I indented wheres differently
13:34:03 <monochrom> But you look at both veteran mathematicians and Haskell beginners, they all want it.
13:34:03 <Rotaerk> do you all find that you use lets a lot more than wheres, vice versa, or roughly even?
13:34:18 <dolio> if/then/else won't work if you use pattern guards, of course.
13:34:33 <Tuplanolla> I mostly use `let`, because of my Scheme habits, Rotaerk.
13:34:38 <trigone> dolio: hm, so where just amounts to a let before writing an if-then-else with guard-sugaring. i don't really see the specialness of where
13:34:48 <phadej> let 552, where 2651
13:34:54 <Cale> monochrom: I dunno, I was okay with 'where' as soon as I realised that it scoped over guards, when nothing else could do that
13:34:57 <jared-w> Rotaerk: I tend to use where far more often than let. I don't really like 'let' as it rubs me the wrong way for some odd reason ¯\_(ツ)_/¯  I suspect I'll starting using let more often as I write more "real world" code
13:35:03 <dolio> The difference is that where is good, and writing a bunch of if/then/else stinks.
13:35:21 <phadej> ah, crap, there's let in delete
13:36:03 <Cale> > do let in let in do 5
13:36:05 <lambdabot>  5
13:36:12 <jared-w> Right now, I basically hate if/then/else and use it as little as possible, I avoid 'let' as much as I can and use where only if each function I'm going to have in a where clause is one line with no type signature needed to be obvious
13:36:16 <trigone> dolio: yes, but if you made where an expression-maker, it would not intrinsically prevent the special way that guard "blocks" get sucked into the scope of the where below
13:36:22 <Rotaerk> Cale, wtf
13:36:35 <phadej> Cale: do { let x = 5; let y = 6; x + y }
13:36:39 <dolio> Guards aren't expressions, either.
13:36:40 <Rotaerk> didn't realize you could have empty let-ins
13:36:41 <phadej> > do { let x = 5; let y = 6; x + y }
13:36:43 <lambdabot>  <hint>:1:34: error: parse error on input ‘}’
13:36:51 <Rotaerk> > let in 5
13:36:53 <lambdabot>  5
13:37:12 <dolio> Actually, making guards into if/then/else is not trivial, either.
13:37:23 <dolio> You may have to further refactor your function.
13:37:33 <dolio> Because guards can fall through to subsequent pattern-matching cases.
13:37:35 <sqooq> wouldn't it be (let x = 5 in let y = 6 in x+y
13:37:39 <dolio> And if/then/else cannot.
13:37:46 <monochrom> I like Haskell and I even like the way it currently is. My little gripe about not following Landin's syntax is just a First World problem. Nevermind me.
13:38:13 <Cale> monochrom: otoh, I think it's a shame that nobody's written an ISWIM implementation
13:38:21 <jared-w> monochrom: which syntax is Landin's?
13:38:32 <Tuplanolla> > don't (do it)
13:38:34 <lambdabot>  error:
13:38:35 <lambdabot>      • Could not deduce (Num (m a0))
13:38:35 <lambdabot>        from the context: (Num (m a), Monad m)
13:38:35 <trigone> dolio: that's not the point. as long as you imply that the start of the where expression is before the start of the desugarized guards, you can (it seems to me) make where an expression-maker without losing any of its advantages... at least it seems like it
13:38:51 <sqooq> hey monochrom, Cale, I'm almost to the finish line for my parsing code. It correctly returns all the right musical information, next I would just have to insert it into csound.
13:39:03 <sqooq> and boom, music
13:39:56 <sqooq> but i'm pretty sure the most recent functions are some baaaaad code
13:40:13 <jared-w> That's the secret; all code is bad code :p
13:40:27 <sqooq> lot's of zipping and mapping 
13:40:29 <dolio> No, you can't, because you can't make guards expressions without losing some of their advantages.
13:40:49 <trigone> dolio: which advantages of what? i'm not following
13:40:55 <dolio> Or radically changing the language.
13:41:19 <Squarism> cocreature, so there is no base-4.10.0.0 for stack yet?
13:41:23 <monochrom> jared-w, Landin's is exactly "x + y where x=2; y=3"
13:42:23 * hackagebot vty 5.17 – A simple terminal UI library – https://hackage.haskell.org/package/vty
13:42:24 <jared-w> ahh gotcha. Just read the wiki page; basically it's just replacing the lambda with 'where' in lambda calculus (according to wikipedia?). Your example makes sense. I personally don't particularly like it
13:42:25 <hexagoxel> so, flip let?
13:42:34 <Rotaerk> "That's my secret, Captain.  I always write bad code."
13:42:38 <hexagoxel> it is rec i suppose?
13:43:04 <jared-w> hexagoxel: another way to think of it is that it removes let and makes every sort of binding or whatever use the word 'where' and hopefully it figures out the right way to desugar :p
13:43:07 <monochrom> Well, I would say the more intuitive "(let v=e in body) = (body where v=e)"
13:43:29 <dolio> trigone: `f 0 y | z < 50 = ... where z = y+y ; f x y = ...`
13:43:30 <monochrom> But then when ignoring types, it is also true (let v=e in body) = (\v -> body) e
13:43:56 <dolio> If that guard fails, the second f clause will be tried.
13:44:12 <phadej> monochrom: rather GHC rewrites it from right to left
13:44:58 <dolio> If you change it to if/then/else in the first clause, you need to copy the second clause's code into the else case of the first clause.
13:45:19 <cocreature> Squarism: the newest nightly comes with base 4.10
13:45:28 <monochrom> Ah, it is also true that back then there was no "let-in" to refer to, so it had to be explained as (\v -> body) e
13:45:36 <cocreature> Squarism: but it’s probably also not too hard to downgrade that example for base 4.9
13:45:49 <monochrom> But I really prefer revisionist history. :)
13:46:40 <monochrom> More seriously, I prefer to explain in your familiar terms, not historical terms.
13:46:53 <Rotaerk> I think the main reasons I prefer where over let are 1) let adds a level of indentation to the code in its context but where doesn't, 2) I prefer to have the details specified *after* the high level code using them
13:47:13 <monochrom> (Likewise, I wouldn't use Gödel numbering to explain Gödel incompleteness.)
13:47:38 <mivael_> >  let  tt elem list = (elem,list)  in  (>>=) head tt [4,3,7]
13:47:40 <lambdabot>  (4,[4,3,7])
13:47:44 <dolio> monochrom: You're forgetting that if we had expression where and something else that was what where is now, we'd have to be explaining the difference between those, plus let. :P
13:48:13 <dolio> It'd be even more confusing.
13:49:09 <Rotaerk> I keep finding myself struggling with syntax/formatting when dealing with complex multi-line expressions and $
13:49:41 <Rotaerk> like, trying to express it in the nicest way I can, while eliminating ()s with $, but taking into account that sometimes I don't wantt $ to cover the ENTIRE rest of the expression
13:50:05 <Rotaerk> ends up with me doing lots of iteration and recompilation to get it just right
13:50:42 <jared-w> Just write it with parens until it works and then eliminate all the parens you don't need and /then/ figure out whether or not it's clearer with $
13:51:00 <trigone> i have a problem with type synonyms. i have some data FooF a b c, then i defined type FooF2 c = FooF A B c, then i tried defining type Foo c = Free FooF2 c, but ghci tells me: The type synonym ‘FooF2’ should have 1 argument, but has been given none
13:51:51 <Rotaerk> jared-w, good idea
13:51:59 <jared-w> mkFoo $ a b c -- usually clearer;  (a . b) $ c $ d $ e $ f $ g $ (x . y . z) q $ a r -- Probably uglier with parens but also probably a huge indicator you should be refactoring this mess
13:52:00 <ab9rf> you may want to invest in some parentheses there, trigone
13:52:28 <trigone> ab9rf: what?
13:53:00 <trigone> ab9rf: parentheses where?
13:53:01 <jared-w> trigone: how does Foof2 know what belongs to Foof2 without parens?
13:53:32 <jared-w> data Foo a = Foo a a a a a -- Legal data definition
13:53:32 <ab9rf> Free takes one type-level argument, and you gae it FooF2
13:53:44 <hexagoxel> trigone: Free FooF2 c = (Free FooF2) c. you want Free (FooF2 c)
13:54:58 <ab9rf> jared-w: i get twitchy at so many dollar signs
13:55:28 <trigone> hexagoxel: no i don't want Free (FooF2 c). my functor is FooF2, not (FooF2 c)
13:56:00 <jared-w> ab9rf: I saw some code like that once and almost had an aneurysm
13:56:19 <ab9rf> jared-w: it starts to look like white noise at some point
13:56:50 <monochrom> dolio: I mean this: http://lpaste.net/357502  . No let-in in the alternate universe.
13:56:57 <dolio> trigone: You can't partially apply type synonyms. You can eta reduce FooF2, though.
13:56:58 <hexagoxel> trigone: ah, my mistake. you .. can't use a synonym like that, unfortunately.
13:56:59 <monochrom> And now please joke about "underwhere"!
13:57:04 <trigone> ab9rf: but, if i copy the definition of FooF2 (minus the c), aka Foo c = Free (FooF A B) c, it compiles nicely...
13:57:24 <trigone> dolio: hm, so maybe i can write FooF2 = FooF A B?
13:57:33 <dolio> trigone: Right.
13:57:45 <dolio> monochrom: I think 'having' is clearly the right keyword.
13:57:54 <trigone> monochrom: i'd use "with"
13:58:00 <dolio> That way you draw on people's SQL experience.
13:58:08 <monochrom> Oh! SQL...
13:58:09 <mivael_> > (>>=) head (,) [4,3,7]
13:58:12 <lambdabot>  (4,[4,3,7])
13:58:13 <trigone> in fact i think with would be better for a let-in replacement (one less character)
13:58:15 <monochrom> What does "having" do in SQL?
13:58:17 <geekosaur> :seti +XLiberalTypeSynonyms ?
13:58:26 <dolio> monochrom: It's like where, but occurs after aggregation.
13:58:31 <geekosaur> monochrom, conditions on aggregates
13:58:39 <jared-w> monochrom: But how is under any clearer than 'where'? :p
13:58:53 <trigone> dolio: thanks! why can't we have partially applied type synonyms btw?
13:58:57 <monochrom> Like "sum x from mytable having (x>0)"?
13:59:14 <trigone> jared-w: i think monochrom just wanted to make their bad pun :P
13:59:33 <monochrom> jared-w: I was out of good words, so I said "may as well use 'under' so you can make 'underwhere' jokes"
13:59:35 <jared-w> Figured :p why bike shed if you can't have fun doing it
13:59:48 <monochrom> But I am happier with "having".
13:59:48 <ab9rf> monochrom rarely passes up the opportunity for a pun
13:59:59 <dolio> trigone: Because that would allow you to write arbitrary type level combinator defnitions, and that makes inference impossible.
14:00:36 <Squarism> cocreature, fantastic. You did it!
14:00:40 <trigone> dolio: oh... ok, i don't get it intuitively but i trust you on the word :)
14:00:44 <dolio> Or things like type classes potentially ambiguous.
14:01:00 <trigone> dolio: i thought type classes refused type synonyms?
14:01:08 <Squarism> cocreature, thanks ALOT
14:01:36 <monochrom> "having" works more pervasively because "module X(y,z) having ..." and "class C a having..." is beautiful English. Pure beauty.
14:01:46 <dolio> Well, yeah. But if we're going to make them first-class things, instead of just like macros, why wouldn't they be allowed in classes?
14:02:17 <ab9rf> but using "having" will give anyone who has worked in SQL really bad flashbacks
14:03:29 <monochrom> OOOhhhhh I have a cunning plan! (I am having a cunning plan?!)   f x having x > 0 = x+x   having otherwise = x * x
14:03:40 <jared-w> I like 'with' better than having :p
14:03:45 <ab9rf> "having otherwise" is violence.
14:03:57 <jared-w> monochrom: that just sounds like a heavily accented foreign english to me :p
14:04:14 <ab9rf> no proper english speaker would say "having otherwise" 
14:04:15 <monochrom> But it's so SQL now...
14:04:47 <trigone> ab9rf: lol i agree. in fact i think having is virtually never used as adverb (preposition? i don't even know what it does here)
14:05:19 <trigone> "this function takes y and returns x having x = f y" -- yeah that's real poetry
14:05:19 <ab9rf> "having" is only used in SQL because a synonym for "where" was needed for a specific use-case that is arguably made redundant by subselects anyway
14:05:41 <ab9rf> any query written with HAVING can be written by enclosing the aggregation in a subselect and using where on that subselect
14:05:51 <jared-w> 'having' is never used in that manner in proper Western english, trigone, so you're fairly correct :p
14:06:01 <geekosaur> yes, it was a hint to help early query optimizers
14:06:05 <dolio> Except it will probably perform terribly on some databases. :P
14:06:14 <geekosaur> so is JOIN for that matter
14:06:18 <ab9rf> geekosaur: no, more a way to implement certain types of queries before subselects were a thing
14:06:41 <geekosaur> subselects were a thing in SEQUEL II
14:06:46 <ab9rf> geekosaur: but not widely implemented
14:06:56 <ab9rf> geekosaur: and when they were implemented, often impelemented poorly
14:07:00 <geekosaur> HAVING was also a thing in SEQUEL II
14:07:07 <monochrom> http://lpaste.net/357502#a357504
14:07:13 <geekosaur> ok, fine, yes, free software told IBM how to design SEQUEL II.
14:07:24 <geekosaur> before said free software even existed
14:07:29 <ab9rf> not talking about mysql
14:07:39 <ab9rf> geekosaur: i've been a DBA since 1986, i have some idea what i'm talking about here
14:07:52 <jared-w> monochrom: all of those sound wrong in english to me :p
14:08:13 <ab9rf> the state of database engines in the late 1980s was... amusing
14:08:28 <ab9rf> a LOT of things that were "supported" in early versions of SQL were "supported" very badly
14:08:32 <dolio> jared-w: They're pretty good. Need to update your heuristics.
14:08:36 <ab9rf> they worked, but were not remotely efficient
14:08:45 <geekosaur> yes, that is what I said
14:08:48 <jared-w> 'where' and 'with' sound more correct than having, though
14:09:01 <trigone> jared-w: monochrom is just very possessive
14:09:12 <geekosaur> and your response was "before subselects" which, no.
14:09:22 <ab9rf> "having" was included to allow one particular case that was common in practice to be expressed without using a subquery, because many early database engines did not handle subqueries well, or even at all
14:09:34 <dolio> We need 'with' for declaration-level let, though.
14:09:40 <ab9rf> geekosaur: mysql is not the only supposedly-sql compliant DB engine i've used that did not have subselects
14:09:46 <dolio> That scopes across multiple declarations.
14:09:50 <geekosaur> nevertheless
14:10:17 <trigone> is "having" not suppose to mean something like "query results which have / having those properties"? i don't know of SQL at all, but that's the intuition i'd have
14:10:19 <ab9rf> now i'm getting ugly flashbacks to the weird shit i used back in the 1980s
14:10:20 <geekosaur> you cannot talk about other DB engines when these things were in the only two SQL DB engines in existence at the time (DB9 and SQL-DS)
14:10:47 <jared-w> dolio: We only have let-in and where in Haskell. If we change let-in to 'where' we can change 'where to 'with' and keep the grammar flow of the statement the same without changing it by using 'having'
14:10:50 <geekosaur> ...and Oracle, because Oracle was Oracle from the beginning (theft, basically)
14:10:59 <dolio> trigone: It's a filter, but lets you filter later than 'where' does.
14:11:12 <ab9rf> trigone: having is just 'where' applied after aggregation
14:11:21 <trigone> ab9rf: hm ok
14:11:51 <monochrom> OK, one last cunning plan. You just need "where1", "where2", "where3" etc for various tiers of "where"s.
14:11:54 <trigone> ab9rf: still, the notion of having something is more logical to be used in the idea of filtering than the idea of defining/aliasing
14:12:01 <trigone> what?
14:12:10 <ab9rf> monochrom: heheh
14:12:29 <ab9rf> there are more synonyms for where than having
14:12:32 <trigone> if we're at it i'll vote for wherewolf
14:12:41 <monochrom> I mean, the Coq people are already doing "Type_1 : Type_2 : Type_3 : ..." so let's learn from them!
14:13:03 <ab9rf> having makes me think of havering, which is not at all the same idea
14:13:19 <trigone> what's havering?
14:13:35 <ab9rf> trigone: scottish verb meaning, roughly, to babble on aimlessly
14:13:49 <trigone> personally having makes me think of heaving, and well bleh
14:14:02 <monochrom> Yeah I have been havering, OK!
14:14:03 <trigone> ab9rf: cool
14:14:03 <geekosaur> haversine?
14:14:25 <hololeap> i saw something for the first time today: class BufferFormat f where;    type HostFormat f;     toBuffer :: ToBuffer (HostFormat f) f
14:14:36 <dolio> monochrom: Was ISWIM the one where guards went after the code, with a comma in between?
14:14:38 <hololeap> what does it mean when there is a type declaration inside a class?
14:14:46 <geekosaur> hololeap, associated type familiy
14:14:47 <monochrom> I forgot.
14:15:06 <hololeap> geekosaur: so it's the TypeFamilies extension?
14:15:08 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-type-families
14:15:12 <geekosaur> part of, yes
14:15:13 <dolio> f x = 3, x > 5 ; 4, x <= 5
14:15:20 <monochrom> Is it in the paper "the next 700 languages"?
14:15:27 <trigone> hololeap: when you declare an instance, you specify the value of the type synonym HostFormat f. just see `type` as being like a let-in, at the level of types
14:16:10 <hololeap> ok. thx
14:16:34 <trigone> wait, what's the advantage of having a type synonym in the class instead of as additional parameter? are those two things overlapping?
14:16:37 <geekosaur> oh, I think I pasted the wrong ref
14:16:51 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-data-and-type-families
14:17:11 <geekosaur> the first one was just how deriving works around them
14:17:21 <dolio> monochrom: Oh, actually, Miranda had that, but there's an `if` after the comma.
14:18:05 <trigone> what's the diff bwn class C f where { type T f; ...} and class C f t | f -> t where { ... }
14:18:20 <geekosaur> trigone, that's kinda the point
14:18:20 <dolio> gcd x y = gcd (a-b) b, if a>b = gcd a (b-a) if a<b = a, if a=b
14:18:31 <trigone> geekosaur: i don't get it
14:18:40 <monochrom> Oh God, "the next 700 languages" has both "x(x+1) where x=a+2b" and "let x=a+2b; x(x+1)". OK, we are screwed.
14:18:44 <geekosaur> associated type families are a more principled way to do that, plus they can do a few more things
14:18:47 <trigone> geekosaur: you mean, it provides a clearer syntax for functional dependency?
14:19:20 <geekosaur> trigone, you might want to compare the monads-fd and monads-tf packages on hackage
14:19:23 <jle`> trigone: what if you had like, twenty associated types
14:19:41 <geekosaur> they were both designed to work with the transformers package, as potential replacements for mtl (version 1)
14:19:47 <trigone> geekosaur: ok i'll look into it some time :)
14:19:52 <jle`> also look at mtl-tf, which is basically mtl with type families instead of fundeps
14:19:59 <trigone> jle`: dunno, what does that mean?
14:20:11 <jle`> an associated type is the type family in the typeclass
14:20:12 <geekosaur> ultimately, because type families weren't quite up to snuff yet, mtl2 stayed with fundeps. a future mtl might well switch
14:20:46 <jle`> if you had to use a conastraint for c, you'd have to type `instance C a b c d e f g h i j l m n o p => ...`
14:21:04 <jle`> instead of just instance C p => ...
14:21:16 <jle`> and having a a-o being associated types (type families) instead
14:22:30 <jle`> instaed of class C a b c d e f g | g -> a, b, c, d, e, f where ..., you can have `class C g where {type A g; type B g; type C g ...}
14:22:47 <trigone> so, a class statement is a bit like defining the signature of a type-level function, and instances are ways to add subdefinitions to that function for whatever specific type as input?
14:24:35 <trigone> jle`: does it allow default definitions of those type synonyms?
14:25:16 <jle`> what type synonyms?
14:27:01 <jared-w> There's a guy on reddit posting in circlejerk where he posted "IF THIS GETS X UPVOTES I WILL POST IT AGAIN BUT DOUBLE THE NUMBER" and started with 2 and hit 131072 so far. What a legend
14:27:13 <orzo> Is there a way using closed type families, to have GHC automatically infer that a constraint is satisfied for all possible values of a given constraint function?
14:30:27 <trigone> jle`: well all the type A g ....
14:30:48 <trigone> jared-w: double the number?
14:31:01 <trigone> what's circlejerk?
14:31:06 <dmwit> jared-w: In the future, that kind of announcement probably fits better on one of the off-topic channels.
14:31:22 <jared-w> whoops, I meant to post this in a different channel
14:32:02 <dmwit> orzo: I don't think so, unfortunately.
14:32:07 <jared-w> m'bad, dmwit, I was switching windows without paying enough attention apparently :p
14:32:40 <dmwit> orzo: In fact I think there's a type-level term which doesn't really satisfy any constraints (and which doesn't reduce when included in a type family), which blocks that kind of reasoning entirely.
14:32:40 <orzo> I have a type data Foo a = Foo Int64 a.  I'm writing instances for (Serialize (Foo a)) and FixedWidth (Foo a) where FixedWidth is my own class that is like Serialize, but has a byte count.
14:33:08 <orzo> I'm able to use the same polymorphic function to implement Data.Serialize.get and my own FixedWidth get
14:33:31 <orzo> But it clutters the type signature to references to Int64 having to satisfy the constraint
14:34:31 * hackagebot word-wrap 0.4 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
14:34:57 <dmwit> Hm, from testing, I appear to be wrong.
14:35:04 <orzo> oh?
14:35:06 <orzo> how wrong?
14:35:12 <orzo> can i do what i want?
14:36:20 <orzo> the infered type for my polymorphic get is: (GetThing r f, r a, r Int64) => f (Foo a)
14:36:33 <orzo> I'd like to eliminate the r Int64
14:36:48 <dmwit> Not wrong enough, I'm afraid. =)
14:37:10 <jle`> trigone: ah yeah, that's actually a type family
14:37:14 <jle`> it's called an associated type
14:37:31 <dmwit> Wrong that type families don't reduce when applied to `Any`. But not so wrong that I can think of a way to get GHC to eliminate the `Num (Foo a) => ...` context from a function just because all the clauses of `Foo` are drawn from `Int` and `Double`.
14:38:48 <jle`> trigone: and yes you can provide default instances for associated types
14:39:46 <orzo> but you're wrong enough so that the feature is at least possible to implement someday?
14:40:06 <dmwit> I don't know of any plans to enable that.
14:40:56 <dmwit> ...and I don't know of any academics who care enough about that feature to be thinking about how it would affect the theory.
14:41:16 <dmwit> (Which is probably a prerequisite of making plans to enable it.)
14:42:10 <orzo> well, the types would be so noisey that maybe it's not even worth the bother to do share code
14:43:26 <orzo> FixedWidth is handy because it has an Applicative Get-alike that keeps a running total of bytes
14:43:58 <jle`> like https://hackage.haskell.org/package/store ?
14:44:10 <trigone> jle`: k
14:44:13 <dmwit> orzo: Do you know about `Storable`, by the way?
14:44:53 <trigone> i just wrote a minimalist free-monad-implemented equivalent of the monad stack Read-Write-State. it's already incredibly short (the free monad is amazing) and using Coproduct stuff, i'm pretty sure one could write separately the implementations of R/W/S. my questions are, 1) is my code ok? (any constructive comment is welcome), 2) why to use monad transformers, when the free monad allows an extremely easy equivalent that seems just a
14:45:17 <orzo> dmwit, jle`, i guess you guys weren't here earlier when i was asking about this trouble
14:45:17 <jle`> i know right
14:45:18 <trigone> the code: http://lpaste.net/357505
14:46:49 <jle`> trigone: i think your type is probably equivalent to rws
14:47:01 <orzo> Storable is a bad fit for my use because it implies machine-dependent encodings
14:47:02 <jle`> the way you're using Free though has as a bit of boilerplate, maybe try using Operational instead
14:47:14 <jle`> which basically abstracts over the pattern you're using
14:47:22 <orzo> however, I was not familiar with https://hackage.haskell.org/package/store
14:47:35 <jle`> the "my functor is an ADT whose constructors are commands to interpret" pattern
14:48:54 <jle`> trigone: also you might be interested in the "data types a la carte" style
14:49:44 <jle`> you can define a separate Reader functor, a separate Writer functor, and a separate State functor, and combine them using (:+:)
14:49:44 <trigone> jle`: yes, obviously the final type is equivalent, but we don't use monadic lifts and so on, everything is flat and yet hardly unusable, even with the little amount of boilerplate that indeed could probably be abstracted away
14:49:57 <trigone> jle`: it's equivalent to Coproduct?
14:50:08 <jle`> yes
14:50:09 <trigone> jle`: what's Operational?
14:50:14 <jle`> by the way coproduct is usually called sum
14:50:37 <jle`> @hackage operational
14:50:37 <lambdabot> http://hackage.haskell.org/package/operational
14:50:51 <trigone> jle`: well i just read that on a very enlightening article, it's not my terminology :) http://degoes.net/articles/modern-fp
14:51:11 <jle`> ah i see
14:51:25 <jle`> yeah, Operational abstracts over the pattern you are using so you don't have to do some of the awkward things that seem kinda arbitrary
14:51:31 <jle`> like, for example, adding a 'next' parameter to every consturctor
14:52:03 <jle`> which feels more like an implementation hack than anything
14:52:47 <trigone> jle`: well, not really, that's the only thing you can feed to Free, so i don't see why it's a hack...
14:53:04 <jle`> taht's exactly why it's a hack
14:53:09 <trigone> ok...
14:53:19 <jle`> since you're basically making it just to fit wiht a pre-existing Free thing
14:53:20 <trigone> at any rate Operational seems cool
14:53:28 <jle`> even though it doesn't have to do with what you are trying to write
14:53:46 <jle`> basically refitting your circle peg to fit into a square one :)
14:53:52 <trigone> jle`: hm i get what you mean
14:54:04 <trigone> is Operational based on Free?
14:54:18 <jle`> Free the data type?
14:54:36 <jle`> not necessarily
14:54:58 <jle`> but yeah, one nice thing about the way you wrote it is that ActionsPolyF can be written completely anonymously
14:55:19 <trigone> what do you mean by "anonymously"
14:55:34 <jle`> type ActionsPolyF r w s = ((->) r) :+: ((,) w) :+: ((,) s) :+: ((->) s)
14:55:59 <jle`> combining functors by just using anonymous (unnamed) sums
14:56:13 <trigone> hm... and that definition would take care of having one same value s for both writing and reading?
14:56:32 <jle`> it's equivalent to your definition except the constructors are unnamed
14:56:38 <trigone> though i guess it all depends on the interpreter i guess
14:56:43 <jle`> yeah
14:56:45 <trigone> jle`: hm i get it
14:57:17 <trigone> so, the combinator :+: basically just writes the "hack" part automatically?
14:57:19 <jle`> then you can notice things like "State s is just Free (((,) s) :+: ((->) s)), what's the problem?
14:57:36 <trigone> what problem?
14:57:38 <jle`> :+: just combines constructors together
14:57:57 <jle`> trigone: oh, heh, just referencing a common haskell meme/joke
14:58:56 <jle`> https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-proble%E2%85%BF
14:59:22 <trigone> jle`: lol
14:59:48 <jle`> "<concept> is just <abstract and unhelpful way of describing concept>, what's the problem?"
15:00:15 <trigone> is it (A :+: B) a = A a | B a ?
15:00:23 <hpc> this is why <thing with weaker abstractions> is better
15:00:31 <joebobjoe> question: I'm wondering.. is there a "canonical" binary encoding (to primitive machine types that can be transported over the wire) given a type hierarchy?
15:00:42 <joebobjoe> like, could binary protocols be derived generically?
15:00:42 <jle`> trigone: essentially, although that's not valid haskell syntax
15:00:43 <trigone> where is (:+:) defined?
15:00:50 <jle`> in GHC.Generics, unhelpfully
15:01:00 <trigone> jle`: yeah i know. which makes me wonder how it's actually implemented. GADTs?
15:01:09 <jle`> but the non-operator form is in Data.Functor.Sum
15:01:21 <jle`> nah it's as vanilla a haskell type as it gets
15:01:32 <trigone> jle`: non-operator?
15:01:36 <jle`> data (f :+: g) a = InL (f a) | InR (g a)
15:01:45 <jle`> trigone: using letters, not symbols
15:01:51 <jle`> data Sum f g a = InL (f a) | InR (g a)
15:01:52 <trigone> oh right ^^
15:02:16 <monochrom> Yeah, that's but you use infix notation for "Sum f g"
15:03:26 <jle`> trigone: by the way, the style of constructing your functors for free by using :+:'s of simpler functors is the 'data types a la carte' style
15:03:45 <trigone> jle`: as opposed to?
15:04:00 <jle`> what you did, creating and naming a custom functor
15:04:09 <jle`> with all of the constructors directly baked in
15:04:33 <trigone> so, to get the big picture, Operational is an equivalent to Free for a more limited type of algebra that is based on the model of instructions?
15:04:39 <jle`> it's not an equivalent
15:05:11 <jle`> i'd say that it's an abstraction over a specific use case of Free
15:05:40 <jle`> or maybe that it provides a way to do something that people often do using Free
15:05:52 <jle`> but as types, i think they are different things
15:06:14 <trigone> jle`: so it's a restricted usage of Free? yeah i meant equivalent in functionality, not implementation
15:06:37 <jle`> well, something can't be a restricted usage and also have equivalent functionality
15:06:40 <jle`> so that's kind of a contradiction
15:07:04 <jle`> i guess you can think of it as a restricted free, but i like to think of it as a separate thing
15:07:17 <jle`> two things that just happen to both be usable for a specific style of programming
15:07:44 <trigone> jle`: i meant (Operational is equivalent to Free for the subset of usage of Operational)
15:07:46 <jle`> and this interpreter style is like the middle slice of the venn diagram
15:08:09 <trigone> what's the venn diagram?
15:08:18 <jle`> use cases of operational and use cases of free
15:08:55 <trigone> oh ok. so there are things that Operational does and Free can't?
15:09:17 <jle`> i don't know :3
15:09:21 <trigone> k :P
15:09:38 <monochrom> What is Operational again?
15:09:41 <jle`> i have a hunch there isn't much, though :)
15:09:49 <jle`> @hackage operational
15:09:49 <lambdabot> http://hackage.haskell.org/package/operational
15:10:08 <trigone> to come back to comparing with transformers: is there any advantage in not using this Free-based implementation of the functionality of transformers?
15:10:16 <jle`> for the interpreter-style usage of free, operational is just a tighter fit with a cleaner api
15:10:51 <monochrom> Oh, that.
15:11:31 <jle`> trigone: well, the monad instance for (s -> (a, s)) miight be more performant than the Free construction Free (((,) s) :+: ((->) s))
15:11:36 <trigone> monochrom: what's your views on Operational?
15:12:02 <jle`> i think i've read an article showing that (s -> (a, s)) is essentially the normalized form of Free (((,) s) :+: ((->) s))
15:12:14 <jle`> that is, if you apply reduction rules to the latter
15:12:16 <trigone> jle`: yeah, i heard there was (as of now) a certain difference in performance. but as long as it's not two times slower systematically...
15:12:23 <jle`> (like set x >> set x = set x)
15:12:41 <jle`> and yeah, actually, now that i mention it
15:12:54 <jle`> Free (((,) s) :+: ((->) s)) is *bigger* than (s -> (a, s))
15:13:05 <jle`> so it's up to the interpreter to normalize things like set x >> set x = set x
15:13:11 <monochrom> I don't know. I have a hunch that they are equivalent, but haven't tried a proof or disproof.
15:13:47 <jle`> (s -> (a, s)) is already self-normalizing
15:13:47 <trigone> jle`: yes, it's what i heard too. but the point is not about using the separated State monad, the point is using stacks of monads, with lifting stuff and so on, or, using Free, which among others also allows isolating and limiting the power of IO
15:14:52 <monochrom> Ah no, I can't even talk about equivalence, a free monad is induced by a functor. I don't know what operational is.
15:14:58 * hackagebot z3 4.1.1 – Bindings for the Z3 Theorem Prover – https://hackage.haskell.org/package/z3
15:15:12 <jle`> trigone: i think ocharles has written about this 
15:15:14 <jle`> trigone: https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
15:15:47 <jle`> it talks about replacing monad transformers with their representative functors, like you suggested
15:15:52 <jle`> and then "composing" them using :+:
15:17:43 <trigone> jle`: yes, that's what i read earlier, it (and the other article i mentioned above) is actually the reason that i'm wondering all this. so i was wondering in practice, if it ended up being true/workable/better
15:21:02 <trigone> jle`: for example do you yourself use transformers sometimes?
15:31:30 <trigone> wait, if i use :+:, will i end up having to pattern match over (InL (InR (InL ... ))) and so on?!
15:32:30 * hackagebot word-wrap 0.4.1 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
15:32:30 * hackagebot cabal-macosx 0.2.4.1 – Cabal support for creating Mac OSX application bundles. – https://hackage.haskell.org/package/cabal-macosx
15:36:10 <trigone> jle`: are you still here?
15:42:13 <JX7P> "Scala is useless, uglying FP with its object-oriented crap. Java and C++ were the worst things to happen to computing for inventing that shit. Scala should really be called the Hascalator because it shows you that the Functional way is better."
15:42:16 <JX7P> hascalator! lol
15:43:14 <geekosaur> bonus confusing the names of haskell and pascal!
15:43:36 <geekosaur> (on top of... java and c++ did not invent OO)
15:43:42 <hpc> this is why i only use C-hashtag
15:43:50 <hpc> zero chance of confusion
15:53:30 <trigone> geekosaur: was there OO class-based before c++? just wondering. cuz if i had to choose OO, the smalltalk model is reputed to not be that bad (not necessarily worth it but still)
15:53:50 <trigone> hpc: confusion?
15:54:07 <hpc> it's the dual of nfusion
15:54:21 <trigone> hpc: :P what's C-hashtag?
15:54:23 <dolio> Smalltalk has classes, doesn't it?
15:54:28 <hpc> C#
15:54:39 <trigone> dolio: well i thought it was prototype-based? like JS?
15:54:47 <geekosaur> trigone, simula
15:54:58 <trigone> geekosaur: simula is prototype based?
15:56:44 <trigone> aaaah i conflated smalltalk and self
15:57:02 <trigone> to my defense, it's practically the same name
15:58:43 <trigone> hpc: you actually advocate C# or it was a joke?
15:59:08 * hpc is all about the terrible jokes
16:00:14 <trigone> hpc: ok :P
16:06:09 <harwiltz> Hello all. I'm writing a function that uses the input of the function in two function calls that are composed, and I want to curry it somehow because it looks redundant. For example, I have foo :: a -> b -> c -> IO(), bar :: b -> c -> IO(), and baz :: b -> c -> IO(). Right now, I'm writing bar vb vc = foo (baz vb vc) vb vc. Is there a way to remove that "vb vc" repetition?
16:07:00 <harwiltz> Actually sorry, baz :: b -> c -> a
16:08:40 <trigone> harwiltz: the b and c are identical everywhere? just to be sure
16:08:44 <harwiltz> trigone: Yes
16:10:51 <trigone> @pl \f g x = (f x) (g x)
16:10:51 <lambdabot> (line 1, column 8):
16:10:52 <lambdabot> unexpected "="
16:10:52 <lambdabot> expecting pattern or "->"
16:10:59 <trigone> @pl \f g x -> (f x) (g x)
16:10:59 <lambdabot> ap
16:11:23 <harwiltz> trigone: What does ap mean?
16:11:29 <Cale> harwiltz: You might consider using Reader
16:11:50 <harwiltz> trigone: Oh nevermind, I see what you're doing. That's nice
16:11:53 <Cale> harwiltz: But that's a larger refactor than you probably want
16:12:59 <harwiltz> Actually, trigone's solution isn't actually saving the currying, I still need to keep writing the args
16:13:10 <trigone> the real question is, is there no way to refactor the code beyond that particular function to avoid such vaguely weird function. there are probably cases when it's normal and inevitable, but maybe here it isn't...
16:13:33 <harwiltz> trigone: I have a feeling it's probably avoidable, I'll try to rewrite it
16:13:35 <Cale> It's hard to talk about this abstractly
16:13:45 <harwiltz> Would it help if I gave the context of the functions?
16:13:46 <Cale> There are some fairly heavy things you could do
16:14:02 <Cale> yeah
16:14:10 <Cale> How much code are we talking about that's passing these things around?
16:14:16 <harwiltz> Cale: Not much
16:14:25 <trigone> harwiltz: well if you have bar :: (b, c) -> IO (), you can write bar = foo `ap` baz, and feeds it tuples of (b,c)
16:14:27 <Cale> If it's small, I just wouldn't worry about it
16:14:49 <harwiltz> trigone: What's ap?
16:14:59 <trigone> agreed with Cale, it's hardly boilerplate, and in fact, obscuring the code with point-free operators won't make things better
16:14:59 <harwiltz> Cale: Yeah, you're probably right, it just looks ugly ;)
16:15:02 <Cale> If you're passing these couple things to everywhere in your application, there are things which can be done to clean that up
16:15:06 <koz_> harwiltz: Applicative's apply operator.
16:15:12 <harwiltz> Ah
16:15:13 <koz_> Also spellable <*> (infix)
16:15:17 <trigone> harwiltz: it's a monadic function
16:15:20 <trigone> :t ap
16:15:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:15:35 <koz_> :t (<*>)
16:15:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:15:57 <Cale> In this case, it was getting used with f t = e -> t
16:16:38 <harwiltz> Ok lemme think about this...
16:17:37 <trigone> basically, it's the equivalent of (<*>) to monadic contexts (some told me there was a difference of functionality, i'm not really sure where). honestly, it's completely inappropriate for what you want to do, . you'd better go inlining it, bar = f foo baz where f g h = \x -> f (g x) x
16:18:16 <trigone> oops
16:18:19 <koz_> The 'standard' monad law explanation is done using >>=; is there a writeup somewhere which uses join (or more specifically, does not use >>=)?
16:18:29 <harwiltz> trigone: Yeah, you're probably right. Also the use of tuples there is probably a little counter-intuitive in this situation
16:18:57 <harwiltz> I know >>=, just somehow never saw ap and I haven't really looked into applicative yet
16:19:18 <trigone> i meant bar = f foo baz where f g h = \x -> g (h x) x, but at this rate, you can forget tuples and just write (f g h = \b c -> g (h b c) b c)
16:19:28 <harwiltz> Alright I think I'm just gonna leave it as it was, seems like it will end up being the most intuitive way to write it
16:20:16 <trigone> harwiltz: sometimes, verbosity is really a plus. a good balance must be found between terseness and the ability to still read your code in a month or six
16:20:47 <koz_> trigone has it right. CF anything in pointfree style from that bot.
16:20:50 <harwiltz> trigone: Yeah, that's it. It's pretty easy to read the way I had it before, so I'm just gonna leave it like that. I appreciate your suggestions, I just think they'll be much harder to read
16:20:52 <koz_> (I forget its name)
16:21:15 <harwiltz> Thanks all for the help
16:22:37 <trigone> koz_: CF?
16:22:44 <trigone> harwiltz: np
16:22:45 <koz_> trigone: c.f. is what I meant.
16:22:53 <trigone> koz_: oh ok ^^
16:23:04 * koz_ just realized he doesn't even know what that stands for.
16:23:32 <trigone> me either, though i do think i used to know it
16:24:33 <trigone> means "confer" (latin for "compare") apparently. honestly that's a weird way to abbreviate
16:24:45 <trigone> it
16:25:00 <koz_> trigone: Let me give you an example of what I mean.
16:25:11 <koz_> @pl \x y z a -> a z y x
16:25:11 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
16:26:11 * hackagebot persistent-mysql-haskell 0.3.3 – A pure haskell backend for the persistent library using MySQL database server. – https://hackage.haskell.org/package/persistent-mysql-haskell
16:27:01 <trigone> koz_: you... don't need to convince me. without the proper combinators (and even then, there's a steep curve), point-free style is just useless, short of shallow showing off
16:27:29 <koz_> trigone: Yeah... just wanted a chance to have lambdabot flip people off. :P
16:28:42 <trigone> koz_: there's worse... can't remember the example... wait
16:28:48 <trigone> @pl join
16:28:48 <lambdabot> join
16:28:52 <koz_> :(
16:28:54 <trigone> @pl liftA2
16:28:54 <lambdabot> liftA2
16:28:59 <trigone> rrr
16:29:40 <trigone> @pl \f g a b c -> f (g a) (g b) (g c)
16:29:41 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
16:29:53 <trigone> ;P
16:29:58 <koz_> trigone: Woah.
16:30:24 <trigone> i wonder...
16:30:32 <trigone> @pl \f g a b c d e -> f (g a) (g b) (g c) (g d) (g e)
16:30:34 <lambdabot> join . ((flip . ((flip . ((flip . ((flip . ((.) .)) .)) .)) .)) .) . join . ((flip . ((flip . ((flip . ((.) .)) .)) .)) .) . join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (
16:30:35 <lambdabot> .)
16:30:37 <trigone> haha
16:31:54 <pacak> lambdabot Wat R U Doin???? lambdabot Stahp!
16:32:08 <trigone> pacak: stahp?
16:32:19 <trigone> (=stop?)
16:32:31 <koz_> Huh, the S combinator is ap.
16:32:43 <Tuplanolla> You don't need pathological examples to get silly `@pl` output.
16:32:50 <pacak> trigone: it is.
16:33:04 <Tuplanolla> This is just `bimap`.
16:33:04 <Tuplanolla> @pl \ f g (x, y) -> (f x, g y)
16:33:04 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
16:33:14 <trigone> Tuplanolla: you're pathological. and i prefer my example
16:34:30 <koz_> Tuplanolla: Even bigger woah.
16:34:54 <trigone> (though i admit, the mix between dots and (,) is making things noticeably worse)
16:35:19 <jared-w> combinatorial logic is great for learning a new way to think about things
16:35:49 <jared-w> also, building up some more powerful operators such as .: (alias for (.).(.) ) helps a lot
16:36:19 <trigone> jared-w: but nobody can read them, so it socially isolates quite a bit
16:36:30 <Tuplanolla> We have a great package for combinatorial logic.
16:36:30 <Tuplanolla> @hackage data-aviary
16:36:30 <lambdabot> http://hackage.haskell.org/package/data-aviary
16:37:06 <jared-w> lol v0.4.0 removed the useful combinators to emphasize that the library is not to be used for real code :p
16:37:19 <koz_> Tuplanolla: Named after that Smullyan book's bird propensity?
16:37:25 <Tuplanolla> Yes, koz_.
16:37:50 <trigone> haha, great inspiration for value naming
16:38:03 <koz_> trigone: That book's quite a fun read actually.
16:38:42 <trigone> oh i meant the package, i don't know the book
16:38:43 <jared-w> But really, are there any--ahem--useful combinators that people use other than (.) ? I know there's the owl operator ((.).(.)) which often written as something like (.:) or (...) but are there any others?
16:39:21 <pacak> :t (>=>)
16:39:22 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:39:25 <koz_> jared-w: S is one.  You might know it better as ap or <*>.
16:39:34 <jared-w> koz_: I don't have his mockingbird book but I have his knights and knaves one (the newer one?) and I'm liking it a lot; I need to actually finish through it though
16:39:36 <koz_> K is also one - you might know it better as const. :P
16:39:56 <koz_> Or do you mean combinators in another sense?
16:40:14 <trigone> koz_: technically it's rare one uses ap with functions/readers directly and merely to compose plain functions
16:40:35 <koz_> trigone: I've used <*> quite a bit in the past.
16:40:38 <jared-w> eh, not really. I meant combinators that help with the clean composition of point-free code but that's basically what combinatory logic is for
16:41:08 <trigone> koz_: just to combine functions? as alias to \f g x -> f x (g x)?
16:41:09 <jared-w> (for example, the .: operator is a hell of a lot easier to read than a bunch of (.) . (.) everywhere)
16:41:17 <koz_> Combinators kinda clicked for me when I read SPJ's old book on implementng functional languages.
16:41:21 <trigone> @pl \f g x -> f x (g x)
16:41:21 <lambdabot> ap
16:41:25 <koz_> trigone: No - when working with applicatives.
16:42:07 <Tuplanolla> > ap zip tail [1 .. 4] -- It sometimes reads nicely.
16:42:10 <lambdabot>  [(1,2),(2,3),(3,4)]
16:42:31 <hpc> @quote aztec
16:42:31 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
16:42:34 <hpc> @quote aztec
16:42:35 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:42:37 <hpc> :D
16:42:45 <trigone> koz_: then is it really the same thing? i don't know much about those combinators, but they aren't meant to imply applicative functors, are they?
16:43:20 <koz_> trigone: I guess I misunderstood - I thought you meant usage in general, not specifically for comnbining functions togehter.
16:44:06 <trigone> koz_: well, ap as general usage is very useful. the monomorphic version (only on readers) which amounts to the S combinator is much less used, i think
16:45:36 <trigone> which functor is it, in (ap zip tail)?
16:45:42 <trigone> :t (ap zip tail)
16:45:43 <lambdabot> [a] -> [(a, a)]
16:45:52 <geekosaur> @quote aztec
16:45:52 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
16:46:05 <koz_> trigone: Having checked out the types of S written literally and ap, I get what you mean.
16:46:09 <trigone> is there an echo in here
16:46:14 <hpc> geekosaur: no fair, it comes up first when you do it!
16:46:42 <geekosaur> oh, didn't even notice it'd been done
16:46:49 * geekosaur just back from quick store run
16:47:03 <trigone> :P
16:47:14 <monochrom> Random numbers are random.
16:47:20 <koz_> Haskell truly is mind-expanding.
16:47:46 <hpc> it's a lot like a concussion in that way ;)
16:47:51 <koz_> Is there a formal definition of what it means for something (like monoid, functor etc) to be 'free'?
16:48:00 <koz_> hpc: I would argue concussions are mind-contracting.
16:48:02 <koz_> But YMMV?
16:48:11 <hpc> (a concussion causes the brain to swell)
16:48:29 <monochrom> yikes haha
16:48:34 <koz_> hpc: Now I know how you stand on mind-brain theory. :P
16:48:40 <trigone> koz_: formally, i think it's something realted to left adjoint of whatever (i know, useful right?)
16:49:07 <koz_> trigone: That might be useful, depending on how much category theory I feel like learning to prove such things.
16:49:12 <monochrom> Yes, there is a formal definition. Left adjoint of the forgetful functor.
16:49:25 <trigone> koz_: maybe that'll be useful: https://wiki.haskell.org/Free_structure
16:49:30 <koz_> monochrom: OK, thanks. Now to figure out what this means well enough to write proofs about it.
16:49:34 <geekosaur> koz_, more or less, the free X is a data structure that represents X as data. so applying fmap to a free Functor results in a data structure encoding a "program" that applies fmap when "run"
16:49:43 <geekosaur> free Monad encodes Bind and Return
16:49:47 <koz_> geekosaur: Yeah, that makes sense.
16:50:04 <koz_> I know that the free monoid is [], the free functor is Lan, etc. I guess I just wanted to understand more generally.
16:50:09 <koz_> Also, is there a free Foldable?
16:50:30 <monochrom> I haven't applied it to free monad. But it works nicely for free monoid, free group, free module.
16:51:03 <geekosaur> I am not sure Foldable is sufficiently well defined
16:51:27 <JX7P> "Hascal: A Functional Rehabilitation of Haskell" now this sounds cool - no language could ever be better than a haskell-pascal hybrid!
16:51:57 <trigone> geekosaur: (thankfully called Pure)
16:52:30 <pacak> [] is not quite a free monoid.
16:52:54 <Tuplanolla> Must we have this discussion every day?
16:52:58 <trigone> pacak: what breaks it?
16:53:05 <pacak> Infinite lists.
16:53:23 <trigone> tss i knew it was bottom related
16:53:42 <hpc> i miss when we would discuss confluence every day ;)
16:54:40 <trigone> i suppose it's the same thing for Free? infinite sequence or whatever
16:56:01 <trigone> so, in short, lists or Free would be true free structures, but only in a non-lazy language?
16:56:18 <JX7P> paskell = hascal
16:56:49 <splanch> rascal = hacket
16:56:54 <pikajude> OMG. GHC 8.2 has colorful error messages??
16:56:59 <pikajude> This changes everything!
16:57:02 <monochrom> Yes it does.
16:57:12 <monochrom> Do you like them? :)
16:57:18 --- mode: ChanServ set +o monochrom
16:57:24 <trigone> hascript = javaskell
16:57:36 <hpc> this breaks my workflow - my custom build system depends on the output of ghc being the same when piped through more :P
16:57:46 <pikajude> well
16:57:51 <pikajude> For some reason, the text is all in bold
16:57:53 <pikajude> which I find pretty distracting
16:58:01 <hpc> but yeah, i can see color making the error message much easier to read
16:58:10 <pikajude> I like it, it's rustc-ish
16:58:13 <pikajude> except for the boldness
16:58:22 <pikajude> maybe I'll just maintain my own version of the GHC builder that patches out the bold
16:58:27 <monochrom> Hmm there may be an option to turn it off.
16:58:33 <splanch> compiler writers really just want to draw pretty pictures
17:00:19 <jared-w> hpc: there's a relevant xkcd for that :p
17:00:22 <trigone> one day error messages will be 3D, with mission impossible soundtracks and a wiiboard to navigate the source code...
17:00:36 <trigone> jared-w: do tell!
17:01:30 <monochrom> -fdiagnostics-color=never (or always, or auto)
17:02:02 <monochrom> Related: -f[no-]diagnostics-show-caret  "Whether to show snippets of original source code"
17:02:16 <pikajude> nope, no bold options
17:02:38 <Tuplanolla> Caret? Are we Clang now?
17:02:54 <monochrom> Hlang
17:02:55 <geekosaur> and now I'm having a flashback to an odd dream where I was debugging a 3D extension to $other-project that had a crashing bug. that rendered very briefly as 3d text before the 3d ui aborted taking the error with it
17:04:06 <monochrom> Haha that sounds like some people's dumb IRC clients when I kickban them.
17:04:12 <trigone> is there an option to have unix's moo rant the error message?
17:04:30 <pikajude> you mean cowsay?
17:04:56 <geekosaur> followed by an option to say --voice Trinoid on macOS
17:05:09 <trigone> pikajude: dunno, i only know of aptitude moo, but maybe there are several version/whatever
17:05:15 <monochrom> Because maybe you kick them with a kick message (/kick monochrom RTFM) but their client responses by closing the tab/window altogether so the "RTFM" message is also lost.
17:05:47 <monochrom> Oh w00t cowsay
17:05:52 <trigone> RTFM?
17:06:04 <monochrom> http://www.vex.net/~trebla/tmp/nu.txt
17:06:27 <monochrom> "RTFM" is just a random example kick message.
17:06:51 <monochrom> Replace by "don't play with your monads" if you like.
17:07:18 <jared-w> trigone: https://xkcd.com/1172/
17:07:28 <trigone> why "nu"? and why RTFM? random letters?
17:07:43 <pikajude> it means "read the kama sutra"
17:08:12 <trigone> jared-w: haha lol
17:08:24 <monochrom> nu is Greek letter ν, greatest fixed point; mu is Greek letter µ, least fixed point.
17:08:32 <jared-w> RTFM is a common acronym in linux world. It means "read the fucking manual" (implying your question is so stupid it would be solved by you reading the man page and that you should do so rather than waste the developer's time).  nu is a greek letter of the alphabet. Often used in CS for things 
17:08:40 <monochrom> So I have a mu cow and a nu cow.
17:08:51 <monochrom> mu cow says "mu", nu cow says "nu".
17:09:03 <trigone> monochrom: ooh got it
17:09:38 <jared-w> There are just so many combinators in the data-aviary package. I didn't even realize there were this many lol; most people only talk about S, K and I
17:09:39 <monochrom> Also, work towards understanding "catmorphism :: Fish f => (f r -> r) -> Meow f -> r"
17:09:43 <trigone> jared-w: k thx
17:10:21 <trigone> monochrom: you still didn't explain the semantics. f is both a Fish and a "Meow", aka a Meowling Fish, and that's just creepy
17:10:32 <jared-w> trigone: at this point in time, RTFM is mostly used as humorous satire rather than as an actual thing people tell beginners to do
17:10:58 <monochrom> No, "Meow f" means the cat consuming the fish.
17:10:59 <pikajude> trigone: it's a catfish
17:11:08 <MarcelineVQ> joking aside one should always rtfm
17:11:17 <trigone> pikajude: well that does make sense
17:11:38 <trigone> monochrom: hm...
17:11:58 <MarcelineVQ> And I would surely reccomend to tell begginners to do just that, though in a more useful manner
17:12:46 <pacak> "A 'Divisible' contravariant functor is a monoid object in the category of presheaves from Hask to Hask, equipped with Day convolution mapping the cartesian product of the source to the Cartesian product of the target."
17:13:01 <pacak> How do you RTFM this?
17:13:39 <jared-w> pacak: by reading "Burritos for the hungry mathemetician", I guess?
17:13:45 <trigone> i heard there was some deal about fix and recursion, aka you could write recursion using fix (and maybe MonadFix?). any good tutorial on that topic?
17:14:03 <trigone> jared-w: don't you mean space suits
17:14:08 <jared-w> trigone: you're looking for recursion schemes (I think)
17:14:17 <trigone> jared-w: scheme?
17:14:37 <pacak> https://hackage.haskell.org/package/recursion-schemes
17:14:48 <jared-w> scheme == plan. So 'recursion schemes' is 'ways of writing, abstracting, and thinking about recursion'  No relation to the scheme language
17:14:59 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
17:15:05 <trigone> i've fallen into some weird place -- This package includes code for functional programming with bananas, envelopes, lenses, barbed wire and all that.
17:15:08 <hpc> your @ is showing
17:15:20 <trigone> i mean seriously? what's a barbed wire?
17:15:28 <pacak> There are several tutorials + paper this package mentions is  kind of easy to approach.
17:15:37 <trigone> jared-w: ah, you had me scared for a while
17:15:47 <jared-w> trigone: that's a normal reaction. It's a reference to the paper named "functional programming with bananas, envelopes, lenses, and barbed wire"
17:15:47 <pacak> trigone: brackets made of < and |
17:15:55 <trigone> pacak: you mean recursion-scheme?
17:16:06 --- mode: monochrom set +b $a:kastengraeber
17:16:07 <jared-w> The paper is called that because the notation they use is indistinguishable from gibberish :) 
17:16:11 <pacak> Notation.
17:16:12 --- kick: JX7P was kicked by monochrom (JX7P)
17:16:16 --- mode: monochrom set -o monochrom
17:16:30 <trigone> pacak: i'd have said ^ instead: [^|^|^|^|^|^|^|^]
17:16:51 <trigone> jared-w: haha lol
17:17:05 <trigone> i'll look into all this, thanks everyone
17:17:50 <jared-w> Don't get scared if the paper is gibberish. It's widely regarded as incomprehensible nonsense to most people--there are other much more approachable introductions to recursion schemes than the infamous paper :p
17:18:10 <koz_> Yay to someone mentioning the recursion schemes paper.
17:18:13 <koz_> it is so very cool.
17:18:23 <pacak> That paper is nice.
17:18:33 <jared-w> I mean, it's super cool, but I don't understand any of it and the notation they use doesn't help :p
17:18:48 * jared-w wishes for someone to translate it into Haskell notation
17:18:50 <koz_> jared-w: Yeah, academic (especially compsci) papers have this issue big-time.
17:19:06 <koz_> jared-w: http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
17:19:13 <koz_> Read that and be enlightened.
17:19:47 <trigone> where's the link to the paper? i can't find it on hackage
17:20:06 <jared-w> awesome, thanks! I've seen this link like 3 times now and I forget about it every time and I understand it more every time I read it
17:20:10 <trigone> koz_: hey thx
17:20:20 <jared-w> trigone: read the link koz_ mentioned and forget about the paper if you want to keep your sanity :p
17:20:28 <koz_> trigone: You're welcome. I'm actually giving a talk on recursion schemes to my uni's compsci club.
17:20:35 <koz_> So that proved an enlightening re-read.
17:20:45 <jared-w> That's awesome. What uni is that?
17:21:05 <koz_> But I hear ya on compsci papers being hard to make sense of. I recently had to implement a Vigna rank-select dictionary, whcih is actually a very obvious data structure. To make sense of that paper, I had to read it, like, seven times.
17:21:14 <koz_> And it involves basically no really difficult theory at all.
17:22:03 <pacak> jared-w: If you want to be able to read arbitrary papers you'll need to deal with arbitrary notations they use. It's meaning is usually explained in some what when it's introduced. Don't continue reading until you figure out all the things.
17:22:12 <Tuplanolla> It must be nice to have a university with active clubs.
17:22:13 <jared-w> Yeah idk I think people just see symbols like ⨀ ⨁ ⨂  and just get way too excited about splattering them everywhere for funsies :p
17:22:24 <koz_> Tuplanolla: It's only because I bothered founding it and constantly pushing it along.
17:22:33 <koz_> Like, all but two of the talks the club's had have been by me.
17:22:54 <Tuplanolla> Well, that explains it.
17:23:07 <jared-w> pacak: Oh I do plan to get better at reading difficult papers, but I'm still in undergrad and have never even touched anything close to FP in a university course yet, so I'm not horribly motivated to suffer undue amounts just yet :p
17:23:41 <koz_> jared-w: I will say this much - it gets easier, but the first few are just plain hell.
17:24:17 <jared-w> I'm sure. I wouldn't mind a course on how to read thick academic papers with arbitrary notations lol
17:24:34 <koz_> jared-w: I don't think any one course covers it.
17:24:52 <koz_> Or if one does, I've yet to see it.
17:25:06 <jared-w> They don't, but it'd be great if someone made a course and said "hey so this is gonna be important, let's teach you how to read papers made by people who never really learned how to write *cough STEM cough* "
17:25:50 * jared-w wonders if papers would become better written if research writing wasn't just one random course nobody took seriously
17:25:56 <trigone> jared-w: sanity's overrated
17:26:16 <koz_> jared-w: I think SPJ did a good talk on how to write a good paper.
17:26:29 <koz_> (in fact, SPJ's stuff is eminently readable)
17:26:50 <jared-w> I love SPJ--he could give a fascinating talk on how to watch paint dry and I'd still somehow learn useful things
17:27:01 <koz_> jared-w: Yeah, SPJ is pretty awesome.
17:27:14 <jared-w> He seems to be a rare gem in the paper writing area, unfortunately...
17:27:36 <trigone> who's SPJ?
17:27:46 <pacak> Simon
17:27:50 <koz_> Peyton-Jones.
17:27:54 <koz_> One of the godparents of Haskell.
17:27:58 <jared-w> The man, the myth, the legend
17:28:00 <koz_> Also looks great in a bowtie.
17:28:01 <trigone> jared-w: sounds like love :P
17:28:10 <trigone> what's a bowtie?
17:28:22 <trigone> nevermind
17:28:34 <jared-w> trigone: you should watch his "escaping the ivory tower" talk. You'll understand quite shortly :p
17:28:58 <trigone> i just have too many thiings to reaaad D:
17:28:59 <koz_> For Stack's config.yaml, do the author-name, author-email etc fields have to be strings?
17:29:00 <Tuplanolla> It's a wearable natural join, trigone.
17:29:07 <koz_> And if so, I do I have to quote-wrap them?
17:29:14 <jared-w> (☞ﾟヮﾟ)☞
17:30:17 <trigone> koz_: to my knowledge, yaml is the smart kind which does not require quoting, but you'd better RTFM :P (sorry i just wanted to test the usage)
17:30:41 <trigone> i never used yaml but i read the specifics some time ago
17:30:47 <koz_> trigone: OK, thanks.
17:30:59 <lordcirth> YAML strings can in theory not be quoted, but special characters can break that
17:31:15 <trigone> i guess then that in short: better ugly than sorry
17:31:16 <lordcirth> Or even special values like true/false/yes/no/1 etc
17:31:21 <lordcirth> So I quote everything
17:31:31 <jared-w> trigone: that sorta usage would be unduly harsh, fyi. RTFM is only used in cases of clear sarcasm (or satire) or in cases of legitimate annoyance at dumb questions--there's a reason very few people even use the phrase anymore
17:31:33 <koz_> lordcirth: Thanks, I shall keep it in mind.
17:31:40 <trigone> i think what is needed is a symbol to quote till the end of line
17:32:00 <trigone> jared-w: i knooooow that was not serious at all
17:32:25 <jared-w> I'm just pointing out that it still reads weird; it's not a very natural usage of the phrase :p
17:32:57 <trigone> jared-w: well hopefully that badly received joke will soon disappear into the darkness of lost chat history
17:33:21 <koz_> Could someone tell me wtf the 'params' field in my config.yaml for stack is meant to have?
17:33:30 <koz_> I've just freshly installed it, tried stack new then stack setup.
17:33:49 <jared-w> koz_: I always just use stack new $TEMPLATE to set all that up for me
17:33:58 <jared-w> try `stack new simple` instead of just stack new
17:34:02 <koz_> jared-w: Ah, OK. So if I did that, it's already done?
17:34:06 <jared-w> Yup
17:34:17 <jared-w> There's tons of templates out there and you can make your own
17:34:25 <koz_> I'm following this thing here: https://docs.haskellstack.org/en/stable/GUIDE/
17:34:26 <trigone> koz_: i think you should have setup first... but i'm not sure at all
17:34:35 <koz_> So I tried 'stack new helloworld new-template'
17:34:38 <trigone> ok then nevermind
17:34:42 <koz_> Does that mean I should be doing 'stack new helloworld simple'?
17:34:45 <koz_> What's the difference?
17:34:53 <jared-w> (You will have to cd into the directory and then use `stack setup` after)
17:35:13 <jared-w> It's `stack new (name-of-project) (name-of-template)`
17:35:13 <trigone> koz_: i think one has a bit less automatically created content. just test and compare, it's the best school :)
17:35:32 <koz_> trigone: OK, I think I've seen the issue. It wants me to pass it a Github username, even though I won't host my code there.
17:36:00 <jared-w> koz_: go to ~/.stack/config.yaml
17:36:07 <trigone> koz_: i filled random shit to it, i dno't have a github username either
17:36:11 <koz_> jared-w: Yeah, I commented it out.
17:36:14 <koz_> It seems to be OK/.
17:36:30 <jared-w> nah just fill it out with stuff. Stack uses those fields to auto populate templates
17:36:38 <koz_> jared-w: Yeah, OK I guess.
17:36:39 <jared-w> otherwise it'll prompt you every time for what you want to put in there
17:36:39 <trigone> i think new alone calls a default template, which you can probably choose somewhere
17:37:11 <koz_> Alrighty, thanks folks.
17:37:35 <jared-w> My global config.yaml, for example, has my name, email, copyright, github and a default category (Practice). If I don't put it on github, whatever, if I do put it on github, I'll be putting it on that one anyway so why not?
17:37:45 <koz_> jared-w: Point well-taken.
17:37:53 <koz_> Alrighty, things seem to be a-installing.
17:38:12 <koz_> Well, a-downloadin', rather.
17:38:15 <jared-w> But yeah, random stuff in the fields will also save you some time in using stack new, it's just string substitution in the template anyway
17:39:17 <koz_> Also, does anyone here use Neovim with Neomake? If so, does it do 'the right thing' with Stack automagically or do I have to do something else?
17:40:14 <jared-w> I got rid of neomake and switched it for a newer plugin
17:40:26 <koz_> jared-w: Oh? Link?
17:40:59 <trigone> is neovim the version of vim rewritten from scratch?
17:41:07 <koz_> trigone: Yeah, basically.
17:41:31 <jared-w> trigone: it's not rewritten, it's refactored--very large difference
17:41:32 <trigone> i was afraid of trying to make the switch... how stable and exhaustive is that implementation?
17:41:41 <jared-w> koz_: https://github.com/w0rp/ale
17:41:44 <trigone> jared-w: you mean they kept the original code...?
17:41:45 <koz_> trigone: Pretty much stable and exhaustive.
17:41:51 <koz_> At least I've not really seen any differences.
17:41:54 <koz_> YMMV.
17:41:58 <jared-w> trigone: they kept the original code and refactored it; there are no missing features
17:42:18 <koz_> jared-w: Woah, that's awesome!
17:42:20 <koz_> Thanks!
17:42:21 <jared-w> They then added some new shiny tools that vim didn't have until version 8 and they still have a better and cleaner codebase than vim overall. I like the project much more for many reasons
17:43:01 <jared-w> koz_: although if you need to run a vim on BeOS or Sun Microsystems... You might have to use vim and not neovim--neovim ripped out a lot of legacy code that was no longer tested and was actually broken for years :p
17:43:07 <trigone> but then vimscript remains the sole config language?
17:43:18 <koz_> jared-w: I find that somewhat improbable.
17:43:28 <jared-w> No, neomake has a vimscript <-> lua interpreter
17:43:28 <nisstyre> neovim is less portable than vim?
17:43:30 <koz_> I live in Arch Linux, aside from my Android tablet.
17:43:59 <jared-w> nisstyre: neomake is technically less portable than vim. In reality, the modern versions of vim probably don't compile on half the systems it claims to support :p
17:44:08 <nisstyre> that's very true
17:44:13 <trigone> jared-w: hm... is there any transpiler haskell -> lua or vimscript by any chance?
17:44:16 <jared-w> However, neovim hasn't had a GUI for windows until very recently iirc
17:44:26 <nisstyre> I'm assuming that's down more to esoteric hardware though
17:44:30 <jared-w> trigone: what they plan to do is they plan to support arbitrary languages for plugins in neovim
17:45:02 <jared-w> koz_: also, ALE works out of the box with Haskell :)
17:45:26 <koz_> jared-w: As I've observed.
17:45:29 <koz_> I'm just gonna set it up now.
17:45:32 <koz_> Yay yak shaving.
17:45:39 <trigone> jared-w: k, sounds good...
17:46:03 <jared-w> koz_: it's literally one line of code for me: Plug 'w0rp/ale' " no config needed
17:46:16 <koz_> jared-w: I use vim-plug also.
17:46:57 <jared-w> trigone: there are two extension directions in neovim. You can use vimscript or you can write a vim plugin. Neovim has a working vimscript to lua interpreter so the vimscript will run /far/ faster now. This will make all "native" vim plugins and vim features faster
17:47:36 <jared-w> Additionally you can write plugins in an arbitrary language and hook them into neovim just fine. It should eventually be possible (if not already) to write plugins in Haskell, C++, Java, OCaml, etc :p
17:48:18 <jared-w> The init.nvim file for your configuration will still likely be in vimscript, but I don't really consider that a huge loss
17:48:19 <trigone> jared-w: k thx :)
17:50:12 <koz_> jared-w: I'm getting a weird error post-ale installation when I try to save a Haskell file.
17:50:47 <koz_> Specifically: 'Error detected while processing BufWritePost Auto commands for *'
17:50:53 <koz_> Because 'Neovim' is not an editor command or something.
17:51:16 <jared-w> Do you have any auto commands setup on save?
17:51:21 <koz_> jared-w: Let me double-check.
17:51:39 <koz_> Oh, durrr.
17:51:44 <koz_> Still have leftover Neomake.
17:52:01 <koz_> OK, now it's good.
17:52:34 <koz_> I should install hlint.
17:52:51 <jared-w> Gotcha :) -- `stack install hlint` in your project directory is all you need to do, btw
17:53:12 <koz_> jared-w: Oh, neat!
17:53:34 <koz_> Also, is there a way to have ale defer linting until I :w? It's a bit disconcerting to have it pop up 'errors' as I type.
17:54:20 <jared-w> No idea; I like the 'as I type' linting, myself. You can probably solve this with a little rtfm here and there :p
17:54:32 <koz_> jared-w: Lol, OK. Thanks for the suggestion though.
17:54:46 <jared-w> np. Check out this while you're at it https://github.com/parsonsmatt/intero-neovim
17:55:13 <jared-w> it'll install intero for you automatically in any stack project when you start neovim and it'll give you typechecking, a built in REPL with neovim's :terminal, type information, jump-to-definition, etc
17:55:31 <koz_> Woah.
17:55:36 <koz_> That's ridonculously good.
17:55:51 <pacak> intero = stack.
17:56:12 <jared-w> You'll want to check out the example config--the plugin does a very 'vim' thing and does not give you any default keybindings
17:56:28 <pacak> stack becomes a problem once you start doing anything complicated.
17:57:01 <jared-w> It's great for learning and starting out, though. You have to get /really/ complicated before stack starts breaking down, from what I've seen
17:57:59 <pacak> I have two projects, one with 500+ modules, one with 2 modules. One uses stack, one doesn't. Guess which one uses stack and which one takes longer to compile if there's no changes.
17:58:02 <koz_> Also, what's 'the right way' to do something like protocols in Haskell? I've heard that type classes shouldn't be used without laws, and the protocol I have in mind doesn't have any I can see.
17:58:20 <koz_> pacak: Raw Cabal for the 500 modules?
17:58:42 <pacak> koz_: Custom build system. Cabal is also stupid.
17:58:46 <jared-w> pacak: I've seen you rant before about how your home grown ridiculous build system is faster for the 500+ modules than stack for the 2 modules. I mean, all the more power to you I guess :p
17:59:00 <koz_> pacak: Something hand-rolled?
17:59:24 <jared-w> koz_: it was hand forged lovingly in the fires of hell
17:59:26 <pacak> koz_: Yes, using shake.
17:59:40 <koz_> pacak: Ah, I see. I've not heard of shake.
18:00:03 <jared-w> pacak: I thought you weren't using shake? Is it somewhat recent that you switched to shake or did I just read wrong earlier?
18:00:38 <jared-w> I'm also somewhat confused between Hadrian vs Shake and why Hadrian even exists tbh ¯\_(ツ)_/¯
18:00:58 <pacak> It was using cabal initially with cabal file being generated by a script, then it switched to shake about 3 years ago.
18:01:11 <jared-w> gotcha
18:01:47 <jared-w> I'm hoping stack and cabal can start using shake in the backend when shake really fleshes out. It'll be nice to not have ridiculous build times after a first compile
18:01:51 <Zemyla> Huh, Proxy is not an instance of MonadFix.
18:01:54 <pacak> But was relying on ghc to compile stuff in parallel. Then we got into unique-id bug and as a workaround we moved parallelization part from ghc to shake - it became faster by  10-15%
18:02:00 <Zemyla> You'd think that'd be something they'd mfix.
18:04:22 <koz_> Zemyla: Hurr hurr. :P
18:04:36 <Zemyla> But yeah, it seems simple.
18:04:46 <Zemyla> @let instance MonadFix Proxy where mfix _ = Proxy
18:04:47 <lambdabot>  Defined.
18:05:07 <jared-w> But does it work? :p
18:06:31 <c_wraith> in all the important ways, yes. 
18:06:59 <jared-w> Hmm... no idea why it's not an instance, then
18:08:05 <koz_> Also, what's 'the right way' to do something like protocols in Haskell? I've heard that type classes shouldn't be used without laws, and the protocol I have in mind doesn't have any I can see. <-- anyone willing to field this one?
18:08:38 <c_wraith> because no one ever wanted to use do rec notation with Proxy. :) 
18:10:28 <c_wraith> koz_, what do you mean by "protocols" in this context? 
18:10:45 <koz_> c_wraith: A set of common abstract behaviours.
18:11:00 <koz_> What various languages call 'interfaces'.
18:13:11 <c_wraith> koz_, in some sense there are 1000 answers available. 
18:13:22 <koz_> c_wraith: I imagine so.
18:13:43 <Welkin> I remember someone mentioning that <*> (or `ap`) is the S combinator
18:13:51 <koz_> Welkin: I think that was me.
18:13:53 <Welkin> but I can't work out how that is true, if it is at all
18:13:53 <c_wraith> koz_, the most primitive approach that's still practically useful is the record of functions. 
18:14:08 <koz_> c_wraith: Similar to Gabriel Gonzales' 'scrap your typeclasses'?
18:14:09 <c_wraith> Welkin, it's true. just look at the type! :) 
18:14:11 <Welkin> \a b c -> a c (b c)
18:14:12 <c_wraith> koz_, yes. 
18:14:24 <jared-w> http://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html Welkin 
18:14:25 <koz_> c_wraith: Thanks, I'll do exactly tha tthen. Not sure why it didn't occur to me before...
18:14:58 <Welkin> lol
18:15:13 <Welkin> is this package supposed to be based on that one logic book about birds?
18:15:18 <jared-w> The s combinator is in the package as 'starling' 
18:15:29 <koz_> Welkin: Yes, it seems so.
18:15:35 <c_wraith> koz_, there are lots of other approaches, but that one is a simple starting point. if it starts to get awkward, there are other ways that make trade-offs to address some of its shortcomings. 
18:15:38 <koz_> (the one by Smullyan)
18:15:53 <koz_> c_wraith: Given that I'm doing exploratory work, it seems as good a starting point as any.
18:16:09 <jared-w> http://hackage.haskell.org/package/data-emoticons-0.1.0/docs/Data-PopCulture-Emoticons.html this package is amazing though
18:16:50 <jared-w> It's a copy-paste of the birds package but with all the combinators as japanese style emojis :p
18:16:52 <Welkin> koz_: I still don't see it
18:17:00 <Welkin> :t (<*>)
18:17:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:17:03 <Welkin> :t flip (<*>)
18:17:05 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
18:17:10 <c_wraith> > zip <*> tail $ [1..]
18:17:12 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
18:17:32 <Welkin> (c -> a -> b) -> (c -> a) -> c -> b
18:17:48 <Welkin> the variables looks off
18:17:59 <dramforever> Where?
18:18:03 <c_wraith> :t (<*>) `asAppliedTo` zip
18:18:05 <lambdabot> ([a] -> [b] -> [(a, b)]) -> ([a] -> [b]) -> [a] -> [(a, b)]
18:18:05 <Welkin> compared to \ a b c -> a c (b c)
18:18:17 <pacak> jared-w: Is it? I expect hackage to contain useful stuff with a separate acme category.
18:18:48 <koz_> Welkin: @pl \x y z -> x z (y z)
18:18:57 <koz_> @pl \x y z -> x z (y z)
18:18:57 <lambdabot> ap
18:19:01 <jared-w> pacak: that's what the Data.PopCulture.Emoticons package is, yes. Not quite sure why it's called that as I'd imagine it would be better served in acme since it's useless
18:19:01 <Welkin> o.o
18:19:13 <Zemyla> Here we are.
18:19:15 <Zemyla> :t \f -> (<*>) (\x -> f x)
18:19:16 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b
18:19:26 <dramforever> \cab ca c -> cab (ca c) c
18:19:51 <jared-w> No attempt was made to make the enojis representative--they just picked random cute ones, from what I can see. Ah well, I thought it was funny
18:20:51 * hackagebot gnss-converters 0.3.7 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
18:36:36 <Welkin> cool
18:36:43 <Welkin> I think I worked it out on paper
18:36:47 <Welkin> it was a bit messy
18:36:57 <Welkin> and I am not sure how to go about this more formally
18:37:03 <Welkin> I just guess how to do it
18:37:11 <Welkin> and substitute and eliminate variables
18:37:44 <Welkin> Sxyz = xz(yz) :: x -> y -> z -> c
18:38:13 <Welkin> (z -> b -> c) -> y -> z -> c
18:38:38 <Welkin> (z -> b -> c) -> (z -> b) -> (z -> c)
18:38:49 <Welkin> f (b -> c) -> f b -> f c
18:40:04 * hackagebot mathflow 0.1.0.0 – Dependently typed tensorflow modeler – https://hackage.haskell.org/package/mathflow
18:40:04 * hackagebot hw-bits 0.6.0.0 – Bit manipulation – https://hackage.haskell.org/package/hw-bits
18:40:15 <Welkin> does anyone have a better process for this?>
18:41:51 <jared-w> Do it often enough to get better at guessing, basically :p
18:42:24 <Welkin> I got quite a bit of practice when I derived (.) . (.)
18:45:47 <orzo> jle`: turns out Data.Store's Peek monad doesn't keep track of the byte count for you
18:45:53 <orzo> for some reason
18:57:13 <koz_> jared-w: I've installed hlint, but ale doesn't seem to be suggesting types for me when I write a function without a type sig. Something I'm missing?
18:57:14 <koz_> (or is it not hlint's job?)
18:57:56 <Welkin> what would be flycheck and/or ghcmod right?
18:58:35 <koz_> Welkin: Flycheck is an Emacs thing - I'm on Neovim.
19:00:11 <jared-w> koz_: it seems you might need to check which linters are enabled in neovim
19:00:21 <koz_> jared-w: You mean ale, right?
19:00:33 <jared-w> yeah
19:01:21 <koz_> jared-w: OK, let me check that. Dem yaks clearly aren't bald enough yet.
19:02:40 <koz_> jared-w: It seems that hlint should be auto-enabled.
19:03:12 <jared-w> It should be from my understanding
19:03:23 <koz_> Then why on earth am I not getting type sig suggestions?
19:03:30 <MarcelineVQ> hlint doesn't give type suggestions
19:03:36 <koz_> MarcelineVQ: What does?
19:04:27 <jared-w> intero does
19:04:35 <koz_> jared-w: Then I should install that.
19:04:46 <Welkin> use emacs :D
19:04:57 <koz_> Welkin: I did before. I got RSI.
19:05:04 <koz_> Had to wear a splint and everything.
19:05:05 <MarcelineVQ> ghc-mod or hdevtools or something similar like intero, there's also something liek intero that doesn't need stack somewhere
19:05:06 <pacak> hdevtools, mod-ghc, ghcid
19:05:21 <pacak> syntastic - for vim.
19:05:23 <jared-w> toList = foldMap (\x -> [x])  -- koz_, write this function into a stack file and then save it and see if hlint will give you a suggestion
19:05:30 <MarcelineVQ> ghcid and asking ghc using   foo  :: _   or something is a great option
19:05:33 <pacak> (I found syntastic to be a bit derpy though)
19:05:38 <ab9rf> derp
19:05:43 <Welkin> koz_: what does that have to do with anything o.o
19:05:53 <Welkin> you can make the bindings whatever you want, like evil-mode for vim bindings
19:06:13 <jared-w> koz_: there's spacemacs which uses vim bindings everywhere and is almost 100% 'out of the box' for haskell, if you want to shave even more yaks. However, you're almost there for vim so :p
19:06:20 <pacak> there's a MR for hdevtools that allows easy per-project configuration and removes stack dependency.
19:06:29 <koz_> jared-w: I like Neovim personally, so I'll be sticking with it.
19:07:02 <jared-w> anyway, koz_, does :ALEInfo show you enabled linters?
19:07:49 <jared-w> mine says that 'ghc-mod', 'stack-ghc-mod', 'ghc', 'hdevtools', 'hlint', 'stack-build', 'stack-ghc'    are all enabled (as in, they will be used if installed)
19:08:38 <koz_> jared-w: I have ghc-mod, stack exec ghc-mod, ghc, hlint, stack build, stack ghc.
19:08:47 <koz_> (in the Command History)
19:09:57 <koz_> I guess I can add hdevtools in my stack project?
19:10:45 <jared-w> eh, not needed if you're just after the type signatures
19:11:24 <koz_> jared-w: I have ghc-mod, stll not seeing any type sigs.
19:19:31 <koz_> How would I add hdevtools to my Stack project?
19:22:30 <jared-w> I've got no idea about ghc-mod or hdevtools tbh
19:23:27 <koz_> jared-w: I'm not entirely sure what I need to add to get lovely type sig suggestions.
19:25:59 <mac10688> I should be able to serve my spock framework with keter right?
19:26:11 <mibaz_1> how much slower is Integer than Int?
19:27:10 <Profpatsch> mibaz_1: Integer is an Int that dispatches to Int under if it fits otherwise uses the gmp-bigint library
19:27:19 <Profpatsch> -under
19:27:25 <jared-w> koz_: I got it working fine with the intero-neovim plugin
19:27:51 <Profpatsch> So as long as it’s <64bit it should be comparable.
19:27:53 <mibaz_1> Profpatsch: Got it
19:28:07 <Profpatsch> It uses the normal overflow-check tricks.
19:28:27 <mibaz_1> cool, thanks!
19:28:30 <Profpatsch> It’s an Int minus one byte so to speak.
19:28:46 <Profpatsch> s/byte/bit
19:29:36 <koz_> jared-w: Guess I will set it up after al.
19:29:38 <koz_> all*
19:30:17 <jared-w> koz_: it was super painless for me.  Plug 'parsonsmatt/intero-neovim' is the only configuration I needed
19:30:36 <jared-w> (other than changing the prompt regex since I customized my prompt to be 'λ '
19:30:56 <koz_> jared-w: Yeah, I'll do that now.
19:31:07 <jared-w> No need to install with stack either; intero manages its own self installation
19:32:07 * hackagebot gnss-converters 0.3.8 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
19:33:05 <koz_> jared-w: I get a warning about missing Neomake.
19:33:31 <jared-w> Do you have ALE installed? I had no warning about missing neomake ¯\_(ツ)_/¯
19:33:39 <koz_> I do have ALE installed.
19:33:42 <jared-w> in either case neomake should be optional since all it does is give you linting in the sidebar
19:34:32 <orzo> is ther a way to define a CPP macro that takes arguments a tthe ghc command line?
19:35:10 <jared-w> orzo: that sounds horrifically hackish. What are you attempting to do with that?
19:35:37 <johnw> jared-w: better would be to use template haskell to invoke CPP to process the source file it's in
19:36:10 <orzo> well i'veno cabal file but a little program i wrote bit rotted, so i added an ifdef
19:36:19 <orzo> i wanted to test the ifdef
19:36:45 <koz_> jared-w: Found the issue - missing neovim-python.
19:37:57 <koz_> Or rather, python2-neovim.
19:38:00 <koz_> Specifically.
19:38:47 <koz_> jared-w: I have intero set up. How do I get type sig suggestions?
19:39:14 <jared-w> Put the cursor over something and then :InteroGenericType or something like that
19:40:23 <koz_> jared-w: That infers something much too general to be correct.
19:41:14 <jared-w> Hmm, it looks correct to me
19:41:22 <koz_> jared-w: Let me paste my issue.
19:43:18 <koz_> jared-w: http://lpaste.net/357508
19:44:22 <jared-w> That's the right type, yeah
19:44:37 <koz_> jared-w: That's not the right type - it's too general to be correct in this case.
19:44:48 <jared-w> posMay says "given some random type, I will maybe give you that type back"
19:45:08 <jared-w> oh right, I see what you're saying now, nvm
19:45:10 <koz_> i > -1 isn't defined on any i which isn't an Integral.
19:45:26 <jared-w> yeah I missed that for a second
19:46:42 <jared-w> Odd. Mine shows (Num a, Ord a) => a -> Maybe a
19:46:52 <koz_> Weird. What am I missing then?
19:47:12 <jared-w> ¯\_(ツ)_/¯ 
19:47:36 <jared-w> Try :InteroReload and then try again?
19:47:36 <koz_> OK, I'll put it down to 'koz_ discovers bugs by existing'.
19:50:43 <Welkin> can you write a corecursive function using fix?
19:51:05 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
19:51:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:51:49 <Welkin> > let let fib' = fix fib where fib f a b = a : fib f b (a + b) in fib' 0 1
19:51:51 <lambdabot>  <hint>:1:73: error:
19:51:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:51:59 <Welkin> > let fib' = fix fib where fib f a b = a : fib f b (a + b) in fib' 0 1
19:52:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:52:05 <Welkin> o.o
19:52:06 <Welkin> wow
19:52:08 <Welkin> it worked
19:53:07 <Welkin> has anyone used `fix` in a real piece of software before?
19:53:17 <johnw> sure
19:53:18 <Welkin> or is it just for educational purposes?
19:53:21 <MarcelineVQ> it's kinda nice tbh
19:53:24 <johnw> anytime you want an anonymous recursive lambda
19:53:49 <Welkin> how would you write the function `fib` as above using `fix` without naming it?
19:54:26 <johnw> well, the traditional version: fix $ \fib n -> fib (n - 2) + fib (n - 1)
19:54:42 <Welkin> > let fib = fix (\f a b -> a : f b (a + b)) in fib 0 1
19:54:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:54:46 <Welkin> o.o
19:54:48 <Welkin> cool
19:55:05 <Welkin> I've always prefered the corecusrive version
19:55:16 <Welkin> but I guess that only worked with lazy evaluation
20:00:49 <jared-w> There's also fibs = 0 : scanl (+) 1 fibs which is fun
20:05:53 <Welkin> > scanl (+) 1 [1..5]
20:05:56 <lambdabot>  [1,2,4,7,11,16]
20:08:37 <jared-w> @let fibs = 0 : scanl (+) 1 fibs
20:08:39 <lambdabot>  Defined.
20:08:47 <jared-w> > take 15 fibs
20:08:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
20:14:06 <MarcelineVQ> jared-w: now make it use fix
20:15:09 <Welkin> > let fibs = fix (\f -> 0 : scanl (+) 1 f)
20:15:11 <lambdabot>  <no location info>: error:
20:15:11 <lambdabot>      not an expression: ‘let fibs = fix (\f -> 0 : scanl (+) 1 f)’
20:15:19 <Welkin> > let fibs = fix (\f -> 0 : scanl (+) 1 f) in fibs
20:15:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:15:23 <Welkin> :D
20:15:34 <MarcelineVQ> wooo
20:15:45 <MarcelineVQ> now get rid of the lambda :>
20:15:51 <Welkin> I started investigating fix by just adding an extra parameter `f` at the beginning of each function
20:16:23 <Welkin> > let fibs = fix . (0 : scanl (+) 1) in fibs
20:16:26 <lambdabot>  error:
20:16:26 <lambdabot>      • Couldn't match expected type ‘a1 -> c1 -> c1’
20:16:26 <lambdabot>                    with actual type ‘[Integer]’
20:16:52 <Welkin> > let fibs = fix . ((0:) . scanl (+) 1) in fibs
20:16:54 <lambdabot>  error:
20:16:54 <lambdabot>      • Couldn't match type ‘[a1]’ with ‘c1 -> c1’
20:16:54 <lambdabot>        Expected type: [a1] -> c1 -> c1
20:17:45 <Welkin> oh wait
20:19:07 <Welkin> > let fibs = fix ((0:) . scanl (+) 1) in fibs
20:19:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:19:40 <MarcelineVQ> now that's a fancy lookin fix I must say
20:20:00 <jared-w> > fix $ (0 :) . scanl (+) 1 -- nifty
20:20:02 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:55:25 <ReinH> My favorite is still the zip `ap` tail version, since it's useful for lots of things besides fibonacci sequence generation
20:55:34 <ReinH> @quote zip`ap`tail
20:55:34 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
20:56:45 <koz_> Is there a stack template for a library?
20:57:16 <ReinH> There are lots of them. Some of them also have an executable section, but you can remove it.
20:57:17 <Axman6> there's simeple or simple-library IIRC
20:57:29 <koz_> Axman6: Thanks - I shall try those.
20:57:42 <ReinH> It might be nice if templates allowed some configuration
21:02:12 <Axman6> there is limited configuration, basically just text splicing. they're using mustache templates IIRC, whcih means it's going to be extremely hard to do anything much more useful
21:03:39 <koz_> Axman6: simple-library works like a charm.
21:14:03 <mac10688> I'm trying to serve my server with keter. On Keter's documentation page it says "Modify your web app to check for the PORT environment variable". Does that mean I can import System.Environment and lookup Port to get the number?
21:15:05 <mac10688> Keter is also serving another webservice (written with yesod, so I can't tell how it's getting the PORT), so would I get two different PORT environment variables?
21:19:15 <koz_> Is there some kind of 'master list' of all the stack templates?
21:19:26 <Axman6> `stack templates` lists them all
21:20:12 <Axman6> there's also a git repo somewhere which houses them all
21:21:26 <koz_> Axman6: Thanks!
21:25:47 <IRC-Source_41903> Hello
21:26:26 <IRC-Source_41903> Here we talk about everything related to the Haskell Language
21:26:59 <Axman6> that's the plan, yes
21:27:00 <pacak> IRC-Source_41903: Is that a question?
21:27:05 <pacak> Or a statement?
21:27:07 <IRC-Source_41903> No
21:27:59 <IRC-Source_41903> Oh, hi Goplat
21:28:09 <IRC-Source_41903> Oh, hi forgottenone
21:29:19 <Fekinox> looks like a bot
21:29:36 <IRC-Source_41903> What did you Call me?
21:30:28 <koz_> IRC-Source_41903: Does the set of all sets contain itself?
21:30:41 <IRC-Source_41903> Yes, why not?!
21:31:25 <Axman6> but then it contains itself, so it cannot be in the set
21:31:35 <IRC-Source_41903> No, it can't
21:31:48 <Axman6> by definition it must
21:31:57 <IRC-Source_41903> Yes, it must
21:32:01 <Axman6> uh, actually, that's the wrong question
21:32:08 <IRC-Source_41903> What?
21:32:11 <koz_> Axman6: It is.
21:32:23 <IRC-Source_41903> It is what?
21:32:25 <Axman6> how about... does the set of all sets which do not contain itself contain itself?
21:32:27 <koz_> Since 'the set of all sets' cannot exist by definition.
21:32:45 <IRC-Source_41903> Then what?
21:33:42 <koz_> c_wraith: Got a question about the 'scrap your typeclasses' approach. How would you rewrite type classes which have other type classes as requirements? 
21:33:51 <koz_> I've read Gabriel's work a few times, and I'm still confused somewhat.
21:33:52 <ab9rf> why are we doing a primer on elementary set theory?
21:34:04 <IRC-Source_41903> I'm also confused
21:34:07 <Axman6> turing test
21:34:08 <koz_> ab9rf: There was some question about whether IRC-Source_41903 was a bot.
21:34:12 <koz_> Yeah, kinda.
21:34:15 <ab9rf> koz_: ah
21:34:15 <c_wraith> just add the constraint to the functions that need it.
21:34:17 <Axman6> we're trying to figure out if IRC-Source_41903 is a bot
21:34:20 <IRC-Source_41903> Hey
21:34:35 <ab9rf> logic is a little bird, chirping in a meadow
21:34:41 <koz_> c_wraith: So it'd be something like 'forall a . (Enum a) => a -> Maybe a', say?
21:34:43 <ab9rf> logic is a wreath of pretty flowers, that smell bad
21:34:52 <IRC-Source_41903> That smell good
21:35:08 <c_wraith> koz_: yeah
21:35:27 <IRC-Source_41903> I kind of agree
21:35:36 <koz_> c_wraith: And I guess if I had a type class implemented as a structure, it would be something like 'forall a . Foo a -> a -> Maybe a'?
21:35:48 --- mode: ChanServ set +q *!*@*/ip.84.211.229.153
21:36:03 --- mode: ChanServ set +o glguy
21:36:12 <c_wraith> koz_: Also, sometimes the requirement doesn't need to be in the type - sometimes you can just put it on polymorphic values of the type
21:36:20 <Axman6> glguy: ?
21:36:35 <koz_> c_wraith: Maybe it's better that I give an example. Please give me a moment to type it up.
21:36:44 <c_wraith> koz_: yes, that will help. :)
21:37:44 <glguy> IRC-Source_41903: Did you have a question about Haskell?
21:43:05 <ReinH> glguy: The bot? I doubt it.
21:43:16 <koz_> c_wraith: http://lpaste.net/357510 <-- this ought to clarify what I'm trying
21:43:58 --- mode: glguy set -o glguy
21:44:38 <koz_> s/trying/trying to do/
21:45:39 <c_wraith> koz_: oh, I see.  In that case, you have a couple options.  The simplest is just adding an Indexable value as an argument to each function in Iterator
21:46:05 <koz_> c_wraith: Oh, so that's how to do it? OK.
21:46:11 <koz_> Since it's the simplest, I'll do exactly that.
21:46:32 <c_wraith> koz_: alternatively, you could leave it out of the definition, but parameterize functions that construct Iterator values to work over any Indexable you pass in
21:46:55 <c_wraith> koz_: it just depends on what you want to make easy to do
21:47:19 <koz_> c_wraith: Not sure exactly yet. I'll start with 'include Indexable arguments' for now.
21:47:23 <koz_> I'll change it if I need to.
21:47:26 <koz_> Thanks!
22:02:48 <koz_> I have a Main.hs in src folder, and also Foo.hs and Bar.hs, and I want Foo.hs to import stuff from Bar.hs. However, stack (and the linters it uses) aren't happy, claiming Bar.hs can't be found. What do I need to add to the project's .cabal for this to work OK?
22:03:25 <glguy> koz_: All your modules will need to be listed in the .cabal file
22:03:49 <glguy> and hs-source-dirs must point to your source dirs
22:04:49 * hackagebot hw-rankselect 0.10.0.0 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
22:04:50 <koz_> glguy: So I need to modify the 'executable' section?
22:04:55 <koz_> Currently, that's all I have.
22:22:52 <koz_> OK, this is driving me up the wall.
22:24:17 <koz_> http://lpaste.net/357511 <-- any halp anyone could give owuld be greatly appreciated.
22:27:33 <mac10688> what is Data.Iterator koz_ ?
22:27:35 <MarcelineVQ> include the actual error you get, not your summary :>  hard to say what the import issue is without seeing how you're importing, how you've named the modules, and the file/folder stucture you have these modules in
22:28:04 <koz_> mac10688: It's a few bits and pieces I need for Main, kept in a separate file.
22:28:18 <koz_> MarcelineVQ: Will update.
22:28:22 <mac10688> ah ok, that you've programed and not from another package?
22:28:28 <koz_> mac10688: Yes.
22:28:39 <koz_> Data.Iterator lives in src/Data/Iterator.hs
22:28:55 <mac10688> I've tried nothing and I'm all out of ideas
22:29:10 <mac10688> well I'm just all out of ideas
22:30:16 <MarcelineVQ> and at the top of Iterator.hs you've written    module Data.Iterator where    ?
22:30:47 <koz_> MarcelineVQ: Yep.
22:30:51 <MarcelineVQ> alright, what's the error you get?
22:31:03 <koz_> http://lpaste.net/357511 <-- this
22:32:04 <glguy> koz_: You're not making it easier by trimming outputs, omitting directly listings, etc
22:32:24 <koz_> glguy: I'm not kidding - that's the entire error message I get in my editor.
22:32:53 <koz_> I can put the entire project in a repo and link that if it'd help?
22:33:01 <glguy> You should have specified that this was a problem with a particular editor plugin if that's what's going on
22:33:17 <koz_> glguy: I'm not sure that it is, that's the problem.
22:34:13 <glguy> get it working outside of your editor first
22:34:34 <koz_> glguy: Yeah, I think it is a broke editor plugin. Alrighty, let me go investigate that.
22:34:40 <koz_> Sorry for the confusion.
22:38:07 <koz_> Yep, appears ALE was screwing with me. All is fine now.
22:44:31 <jared-w> koz_: I'm guessing ALE did not have anything larger than a singule module in scope?
22:47:55 <koz_> jared-w: I have no clue. It was doing strange things.
22:48:01 <koz_> Neovim seems to be fine though.
22:48:10 <koz_> I'm getting type suggestions and everything.
22:50:34 <jared-w> nice
22:51:46 <jared-w> For further yak shaving, it is possible to modify your statusline to contain the output of a function called at the cursor (people do this to show the function name of the function you're in) -- you can modify this somehow to show the type in the statusline for haskell functions, if you're brave enough to figure out how :p 
23:02:12 <johnw> I decided to only buy bald yaks
23:05:57 * glguy discovers the Ren and Stimpy "Yak Shaving Day" video
23:06:31 <jared-w> How have I never seen this before? lol
23:09:36 <Marisa> Hi, a stack/cabal question.
23:10:12 <Marisa> I had developed a package, and upload it on hackage, all is well. I am currently making another package that depend on that.
23:11:09 <Marisa> However, I upgrade my code very frequently, so I am wondering, is there a way to let the other package specify to use only the newest dependency?
23:11:17 <tdammers> yes
23:11:42 <tdammers> instead of depending on a specific version on Hackage, you can point stack to your git repo and specify HEAD as the commit
23:11:46 <tdammers> in stack.yml, that is
23:12:04 <tdammers> the default one created by stack new has some documentation in the comments
23:12:08 <MarcelineVQ> you can specify head?
23:12:11 <tdammers> yes
23:12:17 <tdammers> I wouldn't recommend it, but it's possible
23:12:20 <Marisa> Ooh, I dont know we can specify head
23:12:20 <MarcelineVQ> since when :X
23:12:30 <boj> MarcelineVQ: forever ago
23:12:34 <tdammers> since forever
23:12:50 <tdammers> stack doesn't really care what the "commit" string means, it's just a string that it passes to git AFAIK
23:12:59 <tdammers> can be a hash, or a branch name, or a tag, or HEAD
23:13:05 <MarcelineVQ> that's so cheeky
23:13:12 <tdammers> right
23:13:27 <tdammers> obviously you'll only want to do this for dependencies you control, and only during development
23:13:40 <Marisa> Yes, which is the case here.
23:13:44 <MarcelineVQ> it's not wonder people keep getting the wrong idea about what stack is for :(
23:13:58 <Marisa> Once I have something solid I will use hackage with semvar
23:14:04 <tdammers> not semver
23:14:06 <tdammers> pvp
23:14:15 <tdammers> similar, but not entirely the same
23:14:28 <glguy> https://pvp.haskell.org
23:15:06 <glguy> You don't need to point to git, either. You can use a local directory as well
23:15:13 <Marisa> Thx, I confuse the two
23:15:26 <Marisa> But yes, I mean pvp
23:15:56 <tdammers> oh right, local dir also works, but it's even messier IMO, at least if that local dir is in a different repo
23:16:11 <tdammers> you could also use git submodules for that btw
23:16:29 <jared-w> git submodules suck just a little bit :p
23:16:46 <jared-w> But I  might be biased because they've bit me in the ass quite frequently the last few months since I'm not super familiar with them
23:17:12 <Marisa> right now I am just specifying everything to be -any, such a bad stack/cabal programmer :)
23:17:30 <jared-w> Marisa: fist step is to get it done, second is to make it pretty, third is to make it fast :p
23:17:36 <koz_> I'm a bit confused why 'replicateM i [False, True]' produces a list of all i-length combinations of trues and falses.
23:17:43 <tdammers> yeah, I don't really like submodules myself either
23:17:57 <pacak> @src replicateM
23:17:57 <lambdabot> replicateM n x = sequence (replicate n x)
23:17:58 <tdammers> I like keeping it simple, and submodules usually end up being not so simple
23:18:11 <jared-w> tdammers: it's one of those features (like git notes) which is just unpolished enough to really suck when compared to the rest of git which just flows so well in comparison
23:18:16 <pacak> > replicate 2 [True, False]
23:18:18 <lambdabot>  [[True,False],[True,False]]
23:18:25 <jared-w> it's like having a polished turd in the same display case as a diamond :p
23:18:27 <pacak> :t sequence
23:18:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:18:30 <tdammers> jared-w: yes, but I believe submodules are really hard to polish just right
23:18:39 <pacak> > sequence [[1,2], [3,4]]
23:18:40 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
23:18:55 <pacak> koz_: list monad?
23:19:19 <jared-w> tdammers: no argument there lol. Git notes are also hard to polish up since they're designed to be generic to the point of overly simple sometimes
23:19:24 <koz_> pacak: I guess I just don't quite 'get' how the list monad gives that result.
23:19:36 <pacak> [(a, b) | a <- [1,2], b <- ['a', 'b']]
23:19:39 <pacak> > [(a, b) | a <- [1,2], b <- ['a', 'b']]
23:19:42 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
23:19:49 <tdammers> jared-w: I think those are features that came to exist because someone figured out it could be added easily, so why not
23:20:09 <pacak> Hmm... with do notation is a bit more readable I guess....
23:20:12 <tdammers> jared-w: "hey, we already have 95% of what we need for that feature already, I'll hack up the other 5% in an afternoon"
23:20:21 <jared-w> Well I genuinely like git notes and it's useful for what I need it for. I'd agree with that regarding submodules though
23:20:50 <pacak> koz_: think of it as a bunch of nested loops?
23:21:27 <pacak> for (a in [1,2]) { for b in ['a', 'b']) { do stuf with a and b } }
23:21:36 <pacak> collect result.s
23:21:50 <koz_> :t replicateM
23:21:52 <lambdabot> Applicative m => Int -> m a -> m [a]
23:23:10 <koz_> @src replicateM
23:23:10 <lambdabot> replicateM n x = sequence (replicate n x)
23:24:58 <Marisa> wait a second, right now my version is 0.2017.8.7, does it follow the pvp?
23:25:45 <jared-w> The fact that the list monad goes [(1,a),(1,b),(2,a),(2,b)] is somewhat arbitrary, right? Could you make a different interpretation of the list monad which did something different?
23:26:07 <pacak> jared-w: Like what?
23:27:22 <jared-w> Well I do recall that there is two different ways to fold lists. The ZipList method and the 'default' method chosen
23:27:36 <johnw> ziplists are not monads
23:28:00 <Marisa> jared-w, list monad comprehension is monad comprehension under list monad, so it is do a <- [1, 2] b <- ['a', 'b'] (a, b), which is unambiguous
23:28:23 <jared-w> ah okay, so there's only one way to make a monad out of a list then? Gotcha, that makes sense
23:29:29 <Marisa> I think there's only one way (assuming we satisfy monad law)
23:29:38 <koz_> jared-w: ZipList is Applicative.
23:30:24 <jared-w> koz_: right, and not all Applicatives are Monads but some are, so I was just curious if ZipList was also a monad since that would give two different ways to create a monad for lists just like there are two differnt applicatives you can make for lists
23:30:54 <Marisa> let me try... map id = id, and with free theorem that mean map is unique
23:31:56 <Marisa> map f (return x) = return (f x)... it seems like return x = [x, x] also satisfy
23:31:57 <jle`> jared-w: ziplist is a monad if all your lists are infinite
23:32:26 <koz_> jle`: How do you define join in such a case? Diagonalization?
23:32:33 <jle`> yes
23:32:37 <koz_> jle`: Figures.
23:32:46 <koz_> I think I might have even written that at some point.
23:32:49 <jle`> for infinite lists, it's basically Reader Natural
23:32:51 <koz_> (with your guidance)
23:32:56 <jle`> ha :)
23:33:07 <jared-w> jle`: neat. Why is that the case? Is it something to do with bottom or is it non-laziness related?
23:33:25 <jle`> it has to do with truncation
23:33:35 <jle`> since zip truncates the shorter list
23:34:00 <johnw> dolio on ziplist monads (for infinite lists, or fixed-size vectors): https://mail.haskell.org/pipermail/haskell-cafe/2009-April/059088.html
23:34:09 <jared-w> And if both are infinite, nothing ever gets truncated so the equational reasoning holds?
23:34:41 <koz_> jle`: You'd be a good person to ask this - is there such a thing as a free Foldable?
23:34:54 <jle`> hm i'm not sure if equational reasoning would hold, the laws just work
23:35:05 <jle`> i'm talking about truncation for why finite lists aren't monads in the same way
23:35:29 <jared-w> koz_: I think edwardk mentioned at one point that Foldable didn't really have enough structures and 'laws' to say whether or not there was a free Foldable. It's not really a class that has tons of mathematical background iirc
23:35:44 <jared-w> jle`: gotcha, that makes sense
23:37:05 <koz_> Looking at the Foldable laws now - what's an Endo?
23:37:15 <jared-w> Probably endofunctor?
23:37:39 <MarcelineVQ> a newtype over  a -> a  iirc
23:37:49 <koz_> MarcelineVQ: Ah.
23:37:53 * jared-w has a flashback to the 'monad quote'
23:38:58 <edwardk> Koz: Given newtype Free p a = Free { runFree :: forall r. (a -> r) -> r }. Foldable is just the ability to convert f a -> Free Monoid a with no other laws
23:38:59 <koz_> jared-w: I believe all Haskell functors are endofunctors. From Hask to Hask if memory serves.
23:39:16 <jle`> all Functor instances represent endofunctors
23:39:26 <edwardk> Err
23:39:45 <johnw> hi edwardk 
23:39:58 <edwardk> forall r. p r => (a -> r) -> r
23:40:15 <koz_> edwardk: What's the 'p' all about?
23:40:16 <jared-w> koz_: I'm pretty sure that's right, because all of Haskell is in the category Hask last time I checked (has anyone actually constructed that?)
23:40:49 <edwardk> Fix p = Monoid and compare to foldMap
23:40:50 <jle`> well, the concept of functor is more general than the Functor typeclass
23:41:24 <jle`> the Functor typeclass specifically represents the idea of some endofunctor on Hask
23:41:32 <dbousamra> How long should a stack build take to install dependencies? I'm running stack inside a Docker container, and am seeing upwards of 10m for a clean build. I am on fairly fast internet
23:41:40 <jle`> it depends on how many dependencies
23:41:48 <jared-w> and on which dependencies
23:42:26 <dbousamra> @jared-w not sure which ones are eating time. How can I tell?
23:42:26 <lambdabot> Unknown command, try @list
23:42:28 <cocreature> 10m is definitely not unreasonable if no dependencies are cached
23:42:37 <koz_> If you need Lens, for example, 10m is very reasonable.
23:42:49 <koz_> (like, the all-singing, all-dancing variety)
23:43:22 <jared-w> dbousamra: you generally get a feel for which ones are taking the most time after watching the output. Alternatively, you can figure out how to time it automatically and read the timings to figure out which ones take the most time
23:43:28 <koz_> edwardk: Ah, I see now.
23:43:46 <koz_> What you just said is basically 'we can define foldMap, happy birthday'.
23:43:49 <edwardk> jared-w: there are lots of categories we think about when we talk about "hask" usually idealized in some fashion
23:43:52 <jared-w> But really, I think it would be productive to look at caching docker builds--someone posted about it semi recently on r/haskell I think.
23:44:23 <koz_> Right?
23:44:59 <dbousamra> Cool. Thanks @jared-w. While I'm on the topic, does anyone have any examples of using Stack within a docker container? Specifically, looking to see how people cache deps and stuff. The way I have it is that any change to the cabal file incurs a clean build.
23:45:52 <jared-w> edwardk: I'm not quite sure I follow. Most of the things I've seen about Haskell in a category were circa 2011 or so when people were up in arms about whether or not "fast and loose is morally correct" was really correct and whether or not "the" hask category was legit. Are there multiple categories in the Haskell language? Or is it just that one can construct categories inside of Haskell?
23:46:32 <jared-w> dbousamra: https://hackage.haskell.org/package/docker-build-cacher <-- what i was talking about earlier
23:47:03 <koz_> Also, am I the only one who needs to ponder any answer by edwardk for like, 10 minutes before I can say anything intelligent about it?
23:47:21 <jared-w> koz_: no, that's normal :p
23:47:38 <jared-w> (notice how jle`, cocreature, et al have mysteriously stopped responding...) ;)
23:48:06 <koz_> edwardk: I know you probably get this question a lot, but ... like, how do you even see this stuff?
23:48:17 <dbousamra> thanks @jared-w
23:48:25 <koz_> You seem to be able to pull category theory and associated Haskell code out of a hat more-or-less at will.
23:48:44 <Taneb> koz_, I believe the secret is that edwardk knows both a lot of category theory and a lot of Haskell
23:48:56 <Taneb> And spends like 60% of the time thinking about mashing the two together
23:49:08 <Taneb> So odds are it's not out of a hat, it's here's one I've prepared earlier
23:49:24 <koz_> Taneb: Fair enough, but I seem to be useless at both no matter how long I spend on either. :P
23:49:26 <MarcelineVQ> just like feynman
23:49:28 <jared-w> koz_: he has a great "learning how to learn" talk :) but also, some people just have a particular aptitude for things. I don't think I've seen anyone else have quite the same passion for comonads that edwardk does, for example, even though it's not quite a common thing Haskell programmers talk about :p
23:49:41 <koz_> jared-w: Link?
23:50:20 <jared-w> http://yowconference.com.au/slides/yow2014/Kmett-StopTreadingWater.pdf slides
23:50:33 <jared-w> https://www.reddit.com/r/haskell/comments/2yfris/stop_treading_water_learning_to_learn_by_edward/ talk :)
23:50:47 <Marisa> the comment is very good
23:50:48 <Taneb> koz_, I'd highly recommend that talk
23:51:00 <koz_> Taneb: Looking at it right now.
23:51:52 <koz_> "A consultant is a co-genuis." <-- brilliant
23:52:01 <koz_> s/genuis/genius/
23:52:10 <edwardk> jared-w: let's take an example
23:52:24 <edwardk> in category theory we often talk about a category with products. but haskell's products are a little wonky categorically.
23:52:31 <homesitter> Hi
23:53:00 <edwardk> you have an extra distinguishable member of (a,b)    _|_ is distinguishable from (_|_, _|_) so all the equations for products are _almost_ right.
23:53:23 <edwardk> but this means curry and uncurry aren't _quite_ inverses
23:53:29 <edwardk> etc.
23:53:39 <jared-w> edwardk: I'm following you so far :)  bottom is a bit tricky and I have a love/hate relationship with it, but you haven't lost me yet
23:53:55 <edwardk> and these sort of knock-on consequences just keep echoing through the category whenever you try to make "hask" a rigorous notion
23:54:02 <homesitter> The messian Niveau: map (singularity) {set oft all subsets oft vocabulary}
23:54:20 <edwardk> So we often ignore seq, or the extra _|_ in (a,b), etc. when we talk about "hask" and reason about it as if these things don't exist.
23:54:39 <jared-w> right, hence the 'fast and loose reasoning is morally correct' mantra
23:55:04 <cocreature> at some point I should read that paper to know what exactly it says :)
23:55:05 <edwardk> this is generally an okay thing to do for "moral correctness" reasons, but if you try to talk about it to people who aren't well acquainted with that style they'll usually just claim you're being sloppy
23:55:54 <edwardk> and its pretty easy to make arguments that hold in that "moral" category without the extra bottoms that don't hold in haskell for real, so you do need to be careful.
23:56:57 <edwardk> there's probably a paper title in there about moralizing about other people's bottoms or something
23:57:08 <jared-w> gotcha, so the multiple categories in this case are varying degrees of awareness of the propagation of 'bottom wonkiness' throughout the math?
23:57:08 <koz_> edwardk: LOL.
23:57:43 <jared-w> edwardk: Good one; I'm gonna write that one down in case my school will actually let me write something witty for a senior capstone :p
23:57:52 <edwardk> jared-w: yeah there are degrees of moralizing available to you ;)
23:58:10 <edwardk> er.. i guess if you use it for a senior capstone it would be a degree in moralizing
23:58:15 <jared-w> I moralize 6 days a week and twice on sundays :p
23:58:47 <edwardk> anyways, similar bottom issues show up with void not _truly_ being uninhabited, and so failing to be a proper unit for Either, etc.
23:58:56 <edwardk> so you also get somewhat wonky coproducts
23:59:59 <edwardk> to fix that you need to get rid of the mess that makes haskell a degenerate logic, after all fix :: (a -> a) -> a  -- is a logical fallacy given form. it is 'assuming the hypothesis'
