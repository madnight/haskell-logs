00:05:06 <sqooq> ah I'm so close
00:08:57 <jared-w> tdammers: that's definitely what I do in Java. If I use something literally more than twice, I write a utility function to do it. My red-black tree code was so nice in Java because I had all of the fixing up, rebalancing, and common-case if/statements factored out into utility functions. It read /almost/ declaratively in places
00:09:42 <tdammers> same for any language, really
00:09:48 <tdammers> refactor early, refactor often
00:12:13 <sqooq> is there a way to check the type of the <|> in my instance of Alternative
00:12:19 <sqooq> in ghci
00:12:25 <cocreature> clean up your java code with this one weird trick: extract things into functions
00:12:28 <sqooq> it gives the general alternative one
00:12:41 <jle`> sqooq: if you have ghc 8 and above
00:12:49 <jle`> you can do :t (<|>) @MyType
00:13:19 <sqooq>  Did you mean to enable TypeApplications?
00:13:22 <jle`> but usually it isn't too hard to do it by hand, heh
00:13:24 <sqooq> is what I got
00:13:33 <jle`> sqooq: yes, that's ghc's way of telling yo to enable TypeApplications
00:13:41 <jle`> oh, do you know how to enable extensions
00:13:45 <sqooq> not at all
00:13:45 <jle`>  :set -XTypeApplications
00:13:46 <sqooq> lmao
00:14:05 <jle`> but yeah, <|> usually isn't too hard to figure out by hand, heh, just plug in the type name every where you see 'f'
00:14:07 <sqooq> hmm the type is what I expect
00:15:27 <jle`> definitely good news :)
00:15:48 <sqooq> o "many" is the problem
00:15:52 <sqooq> derp
00:15:57 <sqooq> of course it's going to return a list
00:19:20 <sqooq> ok I don't think I understand my implementation of bind as well as I think I do
00:21:00 <sqooq> http://lpaste.net/357337
00:21:03 <sqooq> Very bottom
00:38:15 <bvad> My boss just told me that you can't solve problems just by using more types.. That's a challenge, isn't it?
00:38:26 <kadoban> Yes, yes it is.
00:39:58 <jared-w> Definitely a challenge
00:40:07 <frerich> bvad: You certainly cannot solve the problem of using too many types by using more types.
00:40:20 <jared-w> newtype T = ..., newtype Y = ..., newtype P = ...  ... ...
00:40:35 <bvad> frerich: But.. :(
00:40:39 <jared-w> data CantTouchDis = M O A R T Y P E S
00:40:52 <bvad> That's a good one
00:41:03 <jared-w> bvad: do it, pls, I need to see it
00:41:19 <bvad> jared-w: Yeah well, there's one problem
00:41:27 <bvad> It's in scala 
00:41:32 <jared-w> oh
00:41:58 <jared-w> Yeah you can't solve problems by just using new types in Scala, you have to use this magic called *ahem* "boilerplate"
00:43:04 <bvad> from my point of view, boilerplate is an abstraction that hides the ugly parts of scala where you actually have to write scala
00:45:15 <sqooq> ok what am I not getting here
00:45:26 <sqooq> do { item; item; 
00:45:30 <sqooq> do { item; item; }
00:45:42 <sqooq> just returns the second item
00:45:52 <sqooq> but what does return actually do then?
00:46:00 <bvad> :t return
00:46:01 <lambdabot> Monad m => a -> m a
00:46:02 <merijn> :t return
00:46:02 <jared-w> yeah you need to actually use return in do notation otherwise it guesses and just returns the last line
00:46:03 <lambdabot> Monad m => a -> m a
00:46:17 <merijn> sqooq: return takes some value and wrap it with whatever Monad you need
00:46:23 <merijn> > return 'c' :: Maybe Char
00:46:26 <lambdabot>  Just 'c'
00:46:27 <sqooq> ok that's what I thought
00:46:29 <merijn> > return 'c' :: [Char]
00:46:32 <lambdabot>  "c"
00:46:37 <merijn> > return 'c' :: Either Bool Char
00:46:40 <lambdabot>  Right 'c'
00:46:46 <sqooq> check my last lpaste
00:46:51 <sqooq> http://lpaste.net/357337
00:46:54 <sqooq> very bottom
00:47:29 <merijn> sqooq: The second one is missing a "char ']'"
00:47:42 <jared-w> I think that's intentional
00:48:03 <sqooq> my point is that that line shouldn't change anything if I'm just going to return x anyways
00:48:10 <jared-w> If I'm guessing right, the question is why x has a different value after char ']'
00:48:10 <sqooq> but I'm probably just misunderstanding somethign
00:48:16 <merijn> sqooq: Ah, but why do you think that lines shouldn't change anything
00:48:28 <merijn> sqooq: Let's rewind quite a bit to the basics :)
00:48:37 <merijn> @undo do { item; item; }
00:48:37 <lambdabot> item >> item
00:48:38 <jle`> sqooq: do you think `do putStrLn "hello"; return 10` is the same as `return 10` ?
00:48:39 <sqooq> o boy
00:48:45 <jle`> try it out on ghci and see :)
00:48:52 <merijn> sqooq: Do you understand how >>= works for Maybe?
00:48:58 <merijn> :t (>>=)
00:48:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:49:04 <sqooq> I understand how it works for my Parser
00:49:05 <sqooq> lmao
00:51:09 <bvad> sqooq: you know how `do` desugars?
00:51:28 <merijn> bvad: Let's not skip ahead :)
00:51:47 <bvad> Not trying to, just want to know if the connection has been made :)
00:51:51 <sqooq> x >>= (\x -> y >>= (\y -> ...
00:51:53 <sqooq> something like that
00:52:11 <merijn> @undo do { char '['; x <- many item; char ']'; return x }
00:52:11 <lambdabot> char '[' >> many item >>= \ x -> char ']' >> return x
00:52:51 <sqooq> yup I get all that
00:52:53 <merijn> sqooq: And since "a >> b = a >>= \_ -> b" the real trick here is in how >>= functions
00:53:15 <merijn> sqooq: So, are you familiar with what >>= does for Maybe?
00:53:15 <jared-w> bvad: merijn likes to take the slow and painful route to enlightenment ;)
00:53:27 <sqooq> merijn: not for Maybe no
00:53:32 <sqooq> but I can guess
00:53:40 <merijn> sqooq: Take a stab :)
00:53:54 <jared-w> but not a   s t a b   :p
00:54:36 <bvad> jared-w: I tend to agree, but if the student already understands a lot of it there's no need to not build on that :)
00:54:55 <sqooq> hmm
00:55:28 <merijn> bvad: The danger, however, is that often there's subtle gaps in the understanding of people and not first filling those leads to shaky fundamentals :)
00:55:49 <merijn> :t (>>=) `asAppliedTo` Just undefined
00:55:49 <jared-w> Haskell in particular seems quite prone to producing people with those subtle gaps
00:55:50 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
00:55:56 <bvad> merijn: Oh I completely agree 
00:56:08 <merijn> jared-w: Well, I think that's an issue with, for example, LYAH being rather incomplete
00:56:09 <sqooq> it probably just gives Nothing when the first is nothing
00:56:14 <merijn> sqooq: Right
00:56:16 <sqooq> but idk what it does if they're both just
00:56:17 <jared-w> I'm guessing this comes from 'muh burritos' and other need for concrete analogies of abstract concepts :p
00:56:18 <jle`> even if you both have your own pedagogically sound independent ideas, telling them both at the same time could potentially cause something even more confusing
00:56:28 <sqooq> Just returns Just
00:56:32 <sqooq> just as in
00:56:34 <sqooq> jesus
00:56:37 <merijn> sqooq: Well, note that the second argument isn't a Maybe, it's a function that returns a Maybe
00:56:38 <jared-w> merijn: yeah, I'd love to see it banished from the r/haskell sidebar... 
00:56:49 <bvad> LYAH?
00:56:50 <sqooq> too many justs
00:57:00 <sqooq> merijn: true
00:57:03 <merijn> > Just 3 >>= \i -> if even i then Just True else Nothing
00:57:06 <lambdabot>  Nothing
00:57:13 <merijn> > Just 4 >>= \i -> if even i then Just True else Nothing
00:57:15 <lambdabot>  Just True
00:57:54 <merijn> sqooq: So, basically it allows you to implement shortcutting, if you chain many >>= it returns the result of applying every function if ALL intermediate results are Just, else it shortcircuits to Nothing
00:57:55 <jared-w> bvad: yeah, LYAH and RWH both. They're already far too accessable for how 'useful' the materials actually are
00:58:48 <sqooq> ok I can see that
00:58:57 <bvad> jared-w: If you were to recommend two books to read after one another, which would you pick?
00:59:18 <merijn> sqooq: Now, We can think of "newtype Parser a = Parser (String -> Maybe (a, String)", that is "a parser is something that takes a String and returns either a result 'a' and a remaining String that's unparsed OR nothing"
00:59:49 <sqooq> yeah I instead use an empty list to indicate that
00:59:53 <bvad> I haven't actually read from first principles, but it seems to be the book that gets recommended the most 
00:59:56 <merijn> sqooq: Same thing :)
00:59:57 <jared-w> bvad: Right now? Haskell from first principles for the 'learning how to use the language' and Bird's "thinking functionally in Haskell" for absorbing the FP mindsetand learning how to break down and solve problems in a functional way.
01:00:09 <sqooq> merijn: Yup, a list is a monad anyway
01:00:12 <bvad> jared-w: how about parconc?
01:00:30 <jared-w> Hutton's book I haven't looked at yet so I can't say, and I don't think I've seen/read parconc yet
01:00:43 <merijn> sqooq: So, when we implement >>= for Parser we have to handle 2 cases: 1) we succeeded and have a remaining strings or 2) we failed. In the success case, you just pass the remaining string to the next parser, if you fail the entire parse fails
01:00:53 <bvad> jared-w: http://chimera.labs.oreilly.com/books/1230000000929/index.html Marlow's book :)
01:01:19 <sqooq> merijn: yes
01:01:30 <merijn> sqooq: Now, if we look back to your example the "char ']'" *can* affect the result, because if it FAILS it will cause the entire 'bracket' parser to fail
01:01:42 <merijn> (via the behaviour of >>=)
01:02:21 <jared-w> oh right, nvm, I know which one that one is. That one's the standard "after you finish HFFP, read this one" book from what I've seen
01:02:21 <jared-w> I'd suggest people reading Bird's and HFFP in parallel and whenever they get stuck in one, pick up the other (starting with HFFP). They'll probably finish Bird's book first since it's 1/4th the length of HFFP :p
01:02:30 <merijn> sqooq: So while the two versions of bracket don't produce different results, they do differ in WHEN they succesfully produce results
01:02:50 <sqooq> well that's not what happens
01:03:14 <bvad> jared-w: I'm not sure if the 'parconc' abbreviation is something I made up.. 
01:03:35 <bvad> jared-w: may come from the naming of https://hackage.haskell.org/package/parconc-examples 
01:03:56 <jared-w> bvad: from what I've seen and somewhat experienced so far, HFFP was really instrumental in getting me working and practical knowledge of Haskell and how Haskell works. Its typeclasses, how to use it, and so on. Bird's book, on the other hand, is helping me pick up the functional mindset more in a way that HFFP hasn't yet
01:04:01 <merijn> sqooq: What's the behaviour you see? (I have a sneaking suspicion :))
01:04:49 <sqooq> ah I'm stupid
01:04:54 <sqooq> you're right
01:05:28 <merijn> sqooq: One warning: "item" only fails at end of input, so it will happily consume any closing brackets you have :)
01:05:36 <jared-w> I'm a bit conflicted on Bird's book because it's *very* Ivory Tower haskell (the 5th chapter is a Sudoku solver walkthrough adapted almost verbatim from his functional perl; zero exercises, the types are just aliases of lists, and the entire thing is an exercise in equational reasoning; as such, he never even gives an example of how to use the code)
01:06:02 <sqooq> merijn: yes, I figured that, I was using this as a way to test how bind works
01:06:08 <merijn> sqooq: You probably wanna use "sat (/=']')" inside bracket :)
01:06:26 <sqooq> I'm trying to like simultaneously do many item and store it
01:06:39 <sqooq> while checking for closed brackets repeatedly until there's no more
01:06:44 <sqooq> that's my vague plan of aktion
01:06:49 <jared-w> But it's a nice breakdown on how to solve problems in a functional manner, which is what I'm interested in learning. It takes a somewhat old-school FP approach (equational reasoning and proof heavy) vs a more type-centric approach that seems more modern
01:07:13 <merijn> sqooq: "many (sat (/=']'))" should work, since many repeats until failure and 'sat' fails whenever you hit ']'
01:07:18 <bvad> jared-w: I guess I'll have to read it 
01:07:46 <sqooq> i don't understand "sat (/=']')" there, shouldn't that always be true
01:08:02 <sqooq> sat :: (Char -> Bool) -> Parser Char
01:08:25 <merijn> sqooq: Well, (/=']') isn't true for ']'
01:08:39 <merijn> sqooq: So it's not *always* true, unlike item which *is* always true :)
01:08:42 <lamefun> So this is what Yoneda lemma is about? https://paste.ofcode.org/33ZjGPEee5puBRTXPNevgwU
01:08:49 <sqooq> merijn: that I don't understand
01:08:54 <sqooq> maybe I don't understand blank lambdas
01:09:17 <bvad> sat (\c -> c /= ']')
01:09:19 <merijn> sqooq: What I wrote is just equivalent to "sat (\c -> c /= ']')"
01:09:29 <sqooq> really?
01:09:34 <bvad> I should just shut up :)
01:09:40 <jared-w> sure, what is a lambda anyway?
01:09:45 <merijn> sqooq: Yes, it's called operator sectioning :)
01:09:48 <sqooq> ok I definitely don't understand blank lambdas then
01:09:54 <sqooq> or whatever they're called
01:10:01 <sqooq> I always assumed they just ignored the input
01:10:06 <sqooq> and output what's inside
01:10:16 <merijn> sqooq: You can partially apply operators by wrapping them in parens and just adding an input on one side
01:10:17 <sqooq> A
01:10:18 <sqooq> AHHH
01:10:29 <sqooq> it's 4 am
01:10:35 <sqooq> lmao /=
01:10:39 <sqooq> not \ ->
01:10:46 <merijn> sqooq: So (*2) = (\i -> i*2) and (2*) = (\i -> 2 * i)
01:10:46 <jared-w> lol it happens
01:10:50 <MarcelineVQ> sqooq: that tends to happen around here :>
01:11:13 <merijn> sqooq: Incidentally, right now your parsers are broken for unicode, but it's trivial to fix them :)
01:11:14 <sqooq> merijn: Yes thanks, I acutally understand that, I had a freezup there lmao
01:11:39 <sqooq> acutally
01:11:51 <merijn> sqooq: You can fix digit, upper and lower by using Data.Char.isDigit, Data.Char.isUpper, and Data.Char.isLower :)
01:11:58 <merijn> Those work with all unicode characters
01:11:59 <ertes-w> elo
01:12:21 <merijn> > Data.Char.isDigit '9'
01:12:23 <lambdabot>  True
01:12:24 <jared-w> elo rtes owh rae yu?
01:13:09 <sqooq> merijn: well I'll only be using this for brackets, numbers, and possibly commas or other simple symbols
01:13:11 <merijn> sqooq: oh, and letter should be Data.Char.isAlpha. You'd think that "lower `plus` upper" is enough, but there's actually letters which are neither upper, nor lowercase :)
01:13:24 <sqooq> jesus
01:13:27 <merijn> sqooq: Yeah, I just like being pedantic whenever the fix is trivial :)
01:13:32 <dmwit> ertes-w: Yikes, you're losing even more letters every night!
01:13:39 <merijn> sqooq: Learn something scary everyday ;)
01:13:47 <sqooq> that's the goal
01:13:48 <dmwit> In four nights you'll be absorbing other people's letters.
01:14:27 <merijn> > Data.Char.isLower '‡≤†'
01:14:29 <lambdabot>  False
01:14:33 <merijn> > Data.Char.isUpper '‡≤†'
01:14:35 <lambdabot>  False
01:15:02 <dmwit> > length . filter (\c -> isLetter c && not (isLower c) && not (isUpper c)) $ [minBound .. maxBound]
01:15:05 <lambdabot>  99363
01:15:09 <dmwit> There's quite a lot of them, in fact.
01:15:46 <merijn> Due to the way the report is specified it's actually a "bug" that GHC accepts ‡≤† as part of an identifier, although I believe that'll be fixed in the next report
01:15:49 <sqooq> alright fixed
01:15:58 <sqooq> you pendanters
01:16:09 <merijn> sqooq: ;)
01:16:16 <sqooq> now
01:16:16 <dmwit> hm
01:16:19 <sqooq> where was i
01:16:31 <dmwit> > length . filter (\c -> isLetter c /= isAlpha c) $ [minBound .. maxBound]
01:16:33 <lambdabot>  0
01:16:36 <dmwit> ok
01:17:36 * hackagebot phone-numbers 0.1.1 ‚Äì Haskell bindings to the libphonenumber library ‚Äì https://hackage.haskell.org/package/phone-numbers
01:19:50 <jle`> til about libphonenumber
01:20:09 <sqooq> ouch
01:20:14 <sqooq> how do I get it to keep going
01:20:20 <sqooq> after the first success with ]
01:20:31 <sqooq> acutally I need to stop letting y'all spoon feed me
01:20:36 <sqooq> i'll figure it out
01:20:45 <sqooq> I think I have all the tools necessary
01:20:51 <bvad> sqooq: this is an awesome attitude
01:20:55 <sqooq> (let me know now if I'm missing something fundamental)
01:21:31 <sqooq> bvad: kek, I've been in here like every day for hours of the day for the past 3 or 4 days it feels like
01:21:36 <sqooq> just constantly asking questions
01:21:49 <sqooq> the minute I reach a roadblock
01:22:13 <bvad> sqooq: you HAVE to ask questions, but you also need to know WHEN to ask questions 
01:22:20 <sqooq> but then again, i realized 90% of the time that I definitely couldn't have figured it out on my own
01:22:28 <sqooq> bvad: yup
01:22:39 <sqooq> Yeah, this time I think I can handle this problem
01:22:56 <sqooq> Now that (I think that) I understand bind better
01:23:06 <sqooq> and I also have <|> to use
01:23:26 <sqooq> ok sleepy time, night and thanks so much. This irc is literally godsend
01:24:34 <jared-w> Well that was fun
01:26:12 <jared-w> I've spent the last like 4 hours watching the first 20 minutes of "Lenses, folds, and Traversals"
01:27:17 <bvad> jared-w: link?
01:27:27 <jared-w> https://www.youtube.com/watch?v=cefnmjtAolY it's a classic edwardk talk
01:27:56 <bvad> Neat
01:28:10 <jared-w> My favorite quote in the talk so far is in the introduction when the introducer throws some shade at Ed :p
01:28:12 <bvad> That guy's mind.. 
01:30:49 <jared-w> I'm enjoying the talk for learning the theoretical underpinnings and history behind lens
01:33:00 * hackagebot aeson-flowtyped 0.9.0 ‚Äì Create Flow type definitions from Haskell data types. ‚Äì https://hackage.haskell.org/package/aeson-flowtyped
01:33:01 <jared-w> and I'm finding that I can appreciate the 'laws' comments far more now that I've read a bit of Bird's book
01:33:55 <jared-w> "this was... it was named for a pun" lol
01:37:44 <bvad> aeson-flowtyped.. Well, TIL
01:41:07 <jared-w> I refuse to pronounce "Coq" with anything other than a strong french accent
01:42:54 <sgronblo> best/worst named programming language
01:44:19 <bvad> sgronblo: I mean, JavaScript is a pretty ridiculous name 
01:44:26 <quchen> jared-w: Lennart recently said that the inventor of Coq said that Coq is called Coq to annoy English speakers ;-)
01:44:46 <quchen> It was in the ¬ªhow do you pronounce Coq¬´ thread on Reddit, I think.
01:45:22 <jle`> it's revenge from the french for english giving us 'bit'
01:45:26 <jle`> apparently
01:45:31 <jle`> i don't know what that joke means but i've heard it
01:46:02 <ertes-w> i'm gonne write a todo manager called mereday
01:46:09 <ertes-w> just to annoy french speakers =)
01:48:04 <jared-w> jle`: bit is a french slang for dick, so Lennart used a french innocent word that is an english slang for dick.
01:48:21 <jared-w> (I could be wrong, but that's what turned up in my googling)
01:48:23 <jle`> oh that's kind of poetic
01:48:55 <jared-w> Now... "bit twiddling" takes on a bit of a second meaning there :p
01:49:11 <jared-w> What makes it even more poetic is you "massage the types" in coq ( Õ°¬∞ Õú ñ Õ°¬∞)
01:49:25 <quchen> jared-w: https://www.reddit.com/r/haskell/comments/6ocu5s/how_does_one_properly_pronounce_coq/dki6la4/
01:49:43 <jared-w> I read that :) I loved it
01:50:01 * ongy just decided to pronounce coq Richard
01:50:54 <jared-w> ertes-w: I like your todo manager name
01:51:23 <mivael> hi all
01:52:04 <ertes-w> or how about a cowsay variant that displays a little emo guy‚Ä¶  i might call it shysay
01:52:42 <ertes-w> germans will be delighted to type that into their shell
01:53:15 <mivael> > let  lm2 = liftA2 :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a;  bf f x y = lm2 f x y;  bm = bf (+);  actual = [bm (Just 6) (Just 7), bm Nothing (Just 8), bm (Just 9) Nothing];  expected = [Just 13,Just 8,Just 9]  in (actual, expected)
01:53:17 <lambdabot>  ([Just 13,Nothing,Nothing],[Just 13,Just 8,Just 9])
01:53:31 <mivael> Could someone give me a hint how to define 'bf' so that the 'actual' would be identical to the 'expected'?
01:53:47 <jle`> can you put it in a paste?
01:54:28 <mivael> jle`, me?
01:54:35 <jle`> yes
01:54:39 <jle`> might make it a bit easier to read :)
01:54:49 <ongy> newlines are a lot more obvious than ';' :)
01:54:52 <[exa]> mivael: in short you want null (or Nothing) to be treated as zero?
01:54:53 <jle`> @where lpaste
01:54:53 <lambdabot> http://lpaste.net/
01:56:01 <mivael> jle`, our firewall filters it, unfortunately... but I can paste it somewhere else
01:56:32 <ertes-w> mivael: mx <+> my = Just (sum mx + sum my)
01:56:53 <ertes-w> > Just (sum (Just 3) + sum (Just 4))
01:56:55 <lambdabot>  Just 7
01:56:59 <ertes-w> > Just (sum Nothing + sum (Just 4))
01:57:02 <lambdabot>  Just 4
01:57:19 <ertes-w> mivael: and yes, rewrapping that in a Just is rather pointless =)
01:57:53 <mivael> :t sum
01:57:54 <lambdabot> (Num a, Foldable t) => t a -> a
01:59:00 <ertes-w> for Maybe: sum = maybe 0 id
01:59:02 * hackagebot vado 0.0.9 ‚Äì Runs commands on remote machines using ssh ‚Äì https://hackage.haskell.org/package/vado
01:59:02 * hackagebot dictionaries 0.2.0.3 ‚Äì Tools to handle StarDict dictionaries. ‚Äì https://hackage.haskell.org/package/dictionaries
01:59:56 <mivael> [exa], not as zero in general but in case of (+) yes, as zero...
02:01:04 <mivael> [exa], jle`, ertes-w: what I really want is 'fromJustBinary' function defined at https://www.codechef.com/viewplaintext/14749872
02:01:45 <mivael> (+) is just an example function
02:02:03 <ertes-w> mivael: that doesn't look like a function one would *want* to have
02:02:08 <mivael> I should be able to use it with any (a -> a -> a) binary function
02:02:12 <ertes-w> mivael: the principled variant would be Monoid
02:02:46 <ertes-w> > Just (Sum 3) <> Just (Sum 5)
02:02:49 <lambdabot>  Just (Sum {getSum = 8})
02:02:51 <ertes-w> > Just (Sum 3) <> Nothing
02:02:53 <lambdabot>  Just (Sum {getSum = 3})
02:03:17 <mivael> ertes-w, it seems I'm starting to understand the idea...
02:04:08 <ertes-w> > Just (Product 3) <> Just (Product 5)
02:04:10 <lambdabot>  Just (Product {getProduct = 15})
02:04:11 <mivael> ertes-w, you mean ion case of 'max' I need something like (Just (Max 3) <> Just (Max 5))?
02:04:20 <ertes-w> yeah
02:04:22 <mivael> s/ion/in/
02:04:33 <mivael> ertes-w, thanks, I will try it
02:07:47 <mivael> ertes-w, is there a constructor which would allow to pass it my (a -> a -> a) function (like (+), (*), max, etc) and get an equivalent type (like Sum/Product/Max/Etc)?
02:08:18 <phadej> mivael: kind of
02:08:44 <ertes-w> mivael: check the Data.Align module from the 'these' package
02:08:47 <ertes-w> https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html
02:17:43 <mivael> ertes-w, mergeThese looks like what I want
02:18:31 <mivael> it is not a commonly used module, is it?
02:19:58 <ongy> I haven't seen it so far. And would probably go with a custom newtype and Semigroup/monoid instances. a bit more work though
02:20:42 <phadej> NIH-syndrome :/
02:24:22 <ongy> that and not feeling like pulling aeson into the dependency tree
02:24:45 <phadej> http://hackage.haskell.org/package/data-or
02:25:28 <phadej> depends on whether you want battaries-included or not
02:26:33 <phadej> in my projects it's almost impossible to avoid JSON and thus aeson
02:27:18 <ertes-w> mivael: i use it a lot
02:27:23 <phadej> ongy: but thanks for mentioning aeson, and not "virtually everything `lens` depends upon" ;)
02:27:44 <ertes-w> mivael: it's fairly natural for things like combining events that, at any point in time, may or may not occur
02:28:35 <phadej> (e.g. reflex depends on these)
02:29:15 <ongy> I don't mind lens. I know I should get to know that better. But I don't want json to even come near anything I do :)
02:29:58 <mivael> phadej, ertes-w: I mean that chances it would compile with mergeThese at, say, https://www.codechef.com, are low...  I maybe then better stich with 'fromJustBinary'-kind of defining such things when solving competitive programming problems.
02:30:04 <ertes-w> ongy: but you don't mind Read and Show being in the prelude? ;)
02:30:07 <jared-w> JSON is so great, though. Like, out of all the terrible serialization formats out there *cough XML cough* I'm glad JSON won lol
02:30:16 <mivael> s/stich/stick/
02:31:10 <ertes-w> mivael: well, if you're competing against other *languages*, you should know that haskell's base library doesn't have batteries included
02:31:40 <mivael> ertes-w, even when comparing to C++, you mean?
02:31:45 <ertes-w> mivael: yes
02:31:56 <ongy> ertes-w: why wouldI mind either of those? Show is nice, I tend to not use read
02:32:04 <ertes-w> mivael: the STL comes with a lot of stuff that the base library doesn't have
02:32:10 <mivael> ertes-w, what C++ 'batteries' examples you mean, then?
02:32:12 <ertes-w> mivael: consider for example that even the 'containers' library is separate
02:32:21 <ertes-w> mivael: data structures
02:32:42 <ertes-w> ongy: Read and Show are far more complex than JSON
02:32:51 <ertes-w> and far less principled, too
02:32:52 <ongy> so?
02:33:32 <ongy> it always struck me as odd, that containers isn't in base (and bytestring)
02:33:49 <ertes-w> yeah, even bytestring and text are separate
02:33:55 <tdammers> was about to mention that
02:34:03 <ertes-w> and vector and ‚Ä¶
02:34:10 <tdammers> even the "real" string type is implemented as an external library
02:34:56 <jared-w> Yeah haskell's base has like half a battery compared to C++ and feels damn near useless compared to Python's standard library
02:35:24 * jared-w is amused that such a 'useless base' still attracts so much controversy over its design *cough head and FTL cough*
02:36:26 <ertes-w> well, python's standard library is extremely bloated‚Ä¶  i think haskell's base should contain more than it does, but it shouldn't contain as much as python's stdlib
02:36:59 <ealthout> defeintely think haskell's base should contain a full webserver
02:37:00 <mivael> ertes-w, maybe you are right...  anyway, I use haskell at competitive programming sites not for gaining impressive results but rather for having a pool of problems on which I could practice basic haskell coding skills, with a possibility to test my results and compare (processing time, memory consumption) to other successfull solutions
02:37:01 <ealthout> don't you?
02:37:17 <jared-w> Oh python's is horrifically bloated; it comes from python wanting to be a scripting language that can't depend on people having the ability to install any packages other than the stdlib. But still... so much stuff lol
02:39:13 <tdammers> jared-w: the controversy is not so much about whether base in its current state is good; there is a lot of consensus that, for example, every Applicative should also be a Functor, or that it's bad to have partial functions like head in base; the controversy is about whether it's worth fixing those problems, and if so, how it should be done
02:39:39 <tdammers> and python's batteries are the way they are because Python puts beginners first
02:40:19 <ertes-w> mivael: well, even getting reasonable performance is very difficult with just base, because you don't even get a good type for text strings
02:40:48 <ertes-w> and base has no real data structures other than standard lists and tuples
02:41:11 <ertes-w> ironically you couldn't say that base is minimalistic
02:41:26 <mivael> ertes-w, usually the performance is good enough... when needed, I use ByteString's
02:41:38 <ertes-w> mivael: ByteString comes from a separate library
02:41:41 <jared-w> It's not even that it's minimalistic so much that it's selectively spartan :p
02:42:12 <mivael> ertes-w, but it is commonly supported by competitive programming sites (for a reason :)
02:42:34 <jared-w> I think anything labeled Safe in haskell is supported...
02:43:06 <mivael> jared-w, anyway I should probably check for Data.Align as well...
02:43:42 <ertes-w> it's a good library, but not exactly a common sight
02:44:23 <mivael> I see
02:44:52 <ealthout> wish I had something to write in haskell
02:44:55 <tdammers> bytestrings and String / Text do not represent the same thing
02:45:00 <ealthout> it's been more than a year :(
02:45:20 <ertes-w> tdammers: if you ignore chunking, lazy Text is pretty much equivalent to String
02:45:47 <tdammers> ertes-w: yes, but not to bytestring
02:46:05 <tdammers> String and Text conceptually represent the same thing (sequences of unicode code points), but bytestring doesn't
02:46:12 <ealthout> it's funny to me how dealing with text is basically the most difficult thing in programming, since forever and in any language. Yet it's a very fundamental thing for humanity
02:46:21 <ertes-w> ealthout: if you write a good *interactive* time tracking app, i'll be your first user =)
02:46:35 <ertes-w> tdammers: ah, i read that wrong, sorry
02:46:37 <tdammers> ealthout: that's because "text" is an informally defined concept IRL
02:46:59 <ealthout> ertes-w: I've actually thought about that. But writing my own time tracking software seems like a rabbit hole I'm not completely happy getting into
02:47:38 <jared-w> I'd say it's an even more basic reason than that. The more 'fundamental' a concept is to human nature, the more difficult it is to deal with it because dealing with it requires dealing with how we conceptualize it and humans conceptualize things in a very messy way
02:47:55 <ertes-w> ealthout: type name of task (bonus points for auto-completion of tasks done in the past), press enter, old timer stops, new timer starts
02:48:04 <ealthout> tdammers: partly, yeah. But it's also because text is actually quite complex and in most cases unbounded
02:48:27 <ertes-w> ealthout: enter ":day" instead of a task name to show an overview of the day
02:48:31 <ealthout> ertes-w: I'll put it in my todo. Might pick it up some weekend
02:48:46 <jared-w> crap, it's 3am... *sigh* I always do this lol
02:48:50 <ertes-w> ealthout: if you don't write it, i will at some point =)
02:49:33 <ealthout> ertes-w: I've also been wanting a fairly basic taask management system (like a mini version of JIRA), but with a terminal interface that I can easily run locally and with the data store being easily managed by git
02:49:40 <ealthout> rather than some crazy clicky web ui
02:50:04 <ealthout> I think it could overlap quite a lot with that time tracking thing
02:50:12 <ertes-w> ealthout: i'm currently using org-mode for task management, which is quite nice
02:50:28 <ertes-w> it even has time tracking, but it works differently from what i would like
02:50:39 <ealthout> yeah.. maybe it's time to get into emacs finally...
02:50:39 <jared-w> god bless org mode; it's the original reason I switched to emacs (spacemacs being the catalyst since I enjoy vim bindings more)
02:50:45 <ealthout> I've been living in vim for a decade though
02:51:04 <jared-w> Have you heard the good news about spacemacs, ealthout? /s
02:51:14 <ealthout> no what's new?
02:51:26 <ertes-w> ealthout: https://www.youtube.com/watch?v=JWD1Fpdd4Pc
02:51:40 <merijn> jared-w: Doesn't work great in the terminal and requires weeks of porting your vim setup to it :p
02:52:12 <ab9rf> i must be hungry, spacemacs sounds like a name for a foodstuff
02:52:14 <merijn> jared-w: Also, spacemacs isn't nearly as available as vim
02:52:17 <jared-w> spacemacs is a distribution of emacs based around the idea of "emacs is awesome, vim bindings are awesome, and crowd sourced configuration is awesome" with the eventual goal of "zero setup time required"
02:52:22 <ertes-w> emacs in a terminal?  no reason to do that =)
02:52:23 <jared-w> merijn: true on all accounts :p
02:52:48 <merijn> ertes-w: I work in the terminal almost exclusively because I work over SSH over 50% of the time
02:52:55 <jared-w> I eventually gave up on using a terminal for main text editing and use emacs in its GUI and havent' missed much. I do, however, keep my old vim configuration for the terminal
02:53:07 <jared-w> (although emacs has tramp to work remotely over ssh inside of emacs...)
02:53:22 <ealthout> I don't like spacemacs. Looked at it a while, and the idea of preconfigured editor isn't my jam
02:53:27 <cocreature> tramp is pretty neat since you don‚Äôt need to copy your config around
02:53:34 <tdammers> ealthout: the two go hand in hand - it's informally defined because it's complex, and it's complex because it's defined informally, with many different semi-compatible ad-hoc definitions mixed up
02:53:35 <ealthout> seems similar to the "vim distros" stuff
02:53:37 <ertes-w> merijn: i solved that problem by just using my local emacs to edit remote files‚Ä¶  and as you may have guessed, tramp-mode (for editing over SSH) comes with the distribution =)
02:53:50 <ealthout> tdammers: so, when are you fixing it once and for all?
02:54:02 <tdammers> ealthout: any minute now
02:54:03 <merijn> ertes-w: How do you compile/check remote code locally?
02:54:23 <jared-w> I also gave up the vast majority of my vim config when I switched to spacemacs because most of my setup revolved around a) extending the 'capabilities' of the vim paradigm and b) per-language configuration. Spacemacs gave me b and more, and enough of a that I didn't get annoyed using it
02:54:38 <srhb> merijn: Nix? :)
02:54:42 <ertes-w> merijn: customise the compile-command‚Ä¶  you can set it per-file or per-directory
02:54:47 <srhb> Oh, or what does ertes-w do specifically.
02:55:06 <merijn> srhb: Not sure how Nix remotely solves the issue of your local editor needing to compile remotely
02:55:12 <srhb> merijn: It does not. 
02:55:51 <merijn> ertes-w: That would require modifying any checker/highlighter to somehow deal with running the compiler over SSH, no?
02:55:53 <jared-w> ealthout: the difference between spacemacs and the other is that spacemacs uses the concept of 'layers' so you can turn off everything spacemacs gives you or turn it all on. I know a few people have just turned off all the stuff spacemacs does except for the evil bindings, for example.
02:55:56 <ealthout> wait, doesn't nix solve every problem?
02:56:22 <jared-w> merijn: tramp does that just fine
02:56:23 <srhb> ealthout: In this case, no. :(
02:56:26 <ealthout> jared-w: hm, okay, might be okay. I'll give it a shot again sometime soon
02:56:53 <srhb> ealthout: (I was thinking of making it unnecessary since you can just have it be deterministic and push the derivation back and forth. That just circumvents the problem though)
02:57:04 <jared-w> ealthout: each layer is specifically intended to be designed as a "sane set of defaults for X" (where X is either a language, or some package or whatever)
02:57:12 <jared-w> and then you can build on top of that or turn stuff off or whatever
02:57:57 <jared-w> It's very much not intended to be an "opinionated curation" even though it does aim to be a "batteries included" distro, if that makes sense
02:58:04 <ertes-w> merijn: it depends, but now we're getting into weird territory: why would you even edit source code remotely?
02:58:21 <ertes-w> merijn: use git and a proper deployment solution (this is where nix might come into play, as it does for me)
02:59:11 <jared-w> But also, does tramp not just edit the file remotely and call all the right commands as if you were "right there over ssh" doing it yourself?
02:59:55 <Sebivor> Are Haskell 1.0, 1.1, 1.2, 1.3, 1.4, 98 and 2010 all compatible?
03:00:22 <Sebivor> i.e. will Haskell 1.0 code run on Haskell 2010?
03:00:23 <tdammers> ertes-w: development server
03:00:27 <jared-w> Sebivor: no
03:00:39 <tdammers> ertes-w: run the editor locally, build toolchain remotely
03:00:56 <jared-w> However Haskell's later versions are *generally* supersets of previous versions... (with a few exceptions)
03:02:15 <Myrl-saki> jared-w: n + k
03:05:18 <jared-w> Myrl-saki: I have no idea what you meant by that, sorry
03:05:36 <Myrl-saki> jared-w: You could do things like `f (n + 1) = n`
03:05:44 <Myrl-saki> Could.
03:06:08 <jared-w> oh right, n+1 patterns. Yes, that's one of the exceptions I was thinking of; I don't know any others, though
03:07:22 <ongy> why did they scrap it?
03:08:10 <Myrl-saki> ongy: Had many problems.
03:08:17 <Myrl-saki> ongy: IIRC, for one, it only pattern matches on positive.
03:08:18 <jared-w> It was widely regarded as a stupid idea
03:08:42 <Myrl-saki> That, or it also pattern matches on negative.
03:09:06 <pacak> https://sites.google.com/site/haskell/notes/nkpatterns
03:11:13 <jared-w> yup, mathematically equivalent expressions having different computational semantics is a great indicator that it's a stupid idea and should be rid of
03:22:39 <jared-w> anyway off to bed for reals. I still haven't found my alarm clock so I'm gonna stare at my bed real hard and just tell myself I'll wake up naturally before noon. Hopefully it works
03:36:55 <Sebivor> From haskell2010.pdf: > After several years exploring the design space, it was decided that a single monolithic revision of the language was too large a task, and the best way to make progress was to evolve the language in small incremental steps, each revision integrating only a small number of well-understood extensions and changes.  Haskell 2010 is the first revision to be created in this...
03:36:56 <Sebivor> ...way, and new revisions are expected once per year.
03:37:12 <Sebivor> Is there a 2016 report?
03:41:07 <cocreature> Sebivor: nope looks like we failed pretty hard at releasing revisions once per year. the next revision is currently codenamed ‚Äúhaskell 2020‚Äù and who knows if it will actually be out by then
03:42:07 <Sebivor> Ah, irony, ha ha ha ha ha ha ha ha...
03:43:00 <cocreature> Sebivor: that said it‚Äôs not like Haskell is not evolving. GHC is implementing new features all the time and diverges more and more from the standard. it‚Äôs just that the standard is not updated
03:43:15 <cocreature> given that there is only one significant implementation, I personally don‚Äôt have much of a problem with that
03:47:49 * hackagebot pvss 0.2.0 ‚Äì Public Verifiable Secret Sharing ‚Äì https://hackage.haskell.org/package/pvss
03:48:16 <Xion_> Maybe it will *both* come out in 2020 *and* be a small incremental step!
03:49:23 <phadej> but even getting MPTC into standard isn't trivial :)
03:49:42 <Xion_> MPTC?
03:52:11 <phadej> Xion_: multiparamtypeclasses
03:52:17 <phadej> prerequisites for functional dependencies etc.
03:52:23 <phadej> "basic stuff" which been in GHC for ages
03:55:53 <tdammers> this is why purescript has managed to be better than haskell in some regards
03:56:18 <ertes-w> tdammers: i have no use for that (remote toolchain) other than CI and deployment
03:56:35 <tdammers> ertes-w: that's fine, but some people do, or even prefer such a setup
03:57:08 <ertes-w> even then i would come up with a way to do it from my local editor
03:57:11 <tdammers> ertes-w: particularly, lots of people prefer to not work "on metal", but run separate VMs for each project, which pretty much amounts to the same
03:57:33 <tdammers> after all, that's pretty much *the* problem Vagrant tries to solve
03:58:23 <ertes-w> a full VM?
03:58:50 <tdammers> yes
03:58:55 <ab9rf> yeah, i kno wpeople who do that
03:59:07 <ab9rf> avoids all risk of inadvertent pollution
03:59:30 <Xion_> phadej: oh lol I didn't even know that's an extension
03:59:37 <Guest10024> Hi everyone! Can somebody explain what is "Generic Haskell"?
04:00:11 <Guest10024> I've read several papers from 2003-2007 and they all reference "Generic Haskell", which seems to be an extension that was available at the time
04:00:31 <Guest10024> What happened to "Generic Haskell"? Was it integrated to GHC? Did it become part of some library?
04:00:54 <alanz> tdammers: fwiw, using a language server protocol backend should allow remote toolchain use.
04:00:58 <ab9rf> ghttps://wiki.haskell.org/GHC.Generics
04:01:05 <ab9rf> erg, ignore the 'g'
04:01:12 <alanz> e.g. haskell-ide-engine, when it matures
04:02:12 * hackagebot yesod-form-richtext 0.1.0.2 ‚Äì Various rich-text WYSIWYG editors for Yesod forms. ‚Äì https://hackage.haskell.org/package/yesod-form-richtext
04:02:13 <Guest10024> ab9rf: so you're saying that the extension that paper authors from 2003-2007 period refer to as "Generic Haskell" is now "GHC.Generics"?
04:02:31 <ertes-w> well, i use nix to solve this problem, which seems more productive to me than a full VM, because it derives environment information from where it belongs: the dependencies of the project
04:03:19 <alanz> ertes-w: I agree that a full vagrant-type VM is overkill, it uses too many resources
04:03:42 <ab9rf> Guest10024: not necessarily the exact same thing
04:03:54 <ab9rf> i haven't read every paper from that timeframe :)
04:04:24 <Guest10024> ab9rf: I just wanna know what specifically that "Generic Haskell" refers to and where I can I read more what happened to it
04:08:53 <alanz> Guest10024: why not provide a specific paper / page number that has a reference that you are unsure about?
04:11:19 <Guest10024> alanz: Well, for example paper "Inferring Type Isomorphisms Generically" by Frank Atanassow mentions "Generic Haskell" a lot and references papers from the same time period
04:11:42 <Guest10024> which also deal with "Generic Haskell". So I know now that something called "Generic Haskell" exists.
04:12:04 <Guest10024> What I can't find anywhere is what happened to "Generic Haskell" afterwards, what is left of it in 2017, you know
04:16:00 <alanz> Guest10024: having followed the link to the Andres Loh thesis, it seems that this is a specific compiler implementation, from utrecht university
04:17:38 <alanz> Guest10024: http://www.cs.uu.nl/research/projects/generic-haskell/
04:21:22 <Guest10024> alanz: Oh, Ok, thanks :)
04:22:18 <merijn> Guest10024: Utrecht has their own Haskell compiler UHC (Utrecht Haskell Compiler), it supports, afaik all of Haskell2010 and several GHC extensions
04:25:29 <Athas> merijn: do they support Template Haskell?
04:25:33 <kosmikus> Guest10024: Generic Haskell was a preprocessor for Haskell to allow datatype-generic programming back in the days
04:25:46 <merijn> Athas: Don't think so
04:25:47 <kosmikus> Guest10024: it is long dead though
04:25:51 <Athas> I have the hunch that TH is a massive barrier to constructing an alternative Haskell compiler (because so much code uses it nowadays).
04:26:14 <Guest10024> kosmikus: what would be the best modern replacement for it?
04:26:14 <kosmikus> Guest10024: these days, you can do most of the things you could do with Generic Haskell directly within Haskell via libraries and GHC support
04:26:32 <Guest10024> kosmikus: I see
04:26:32 <kosmikus> Guest10024: "best" is very subjective.
04:26:38 <merijn> Athas: I think the problem is that TH is rather implementation detail specific is the issue
04:26:56 <Guest10024> kosmikus: best is subjective, but what I mean is what should the first place to look at
04:27:03 <kosmikus> Guest10024: GHC.Generics supports the basics.
04:27:24 <kosmikus> Guest10024: which is based on "A generic deriving mechanism for Haskell"
04:28:08 <kosmikus> Guest10024: generics-sop is another library that follows a similar approach, as described in "Generic Programming with True Sums of Products"
04:28:33 <kosmikus> Guest10024: a different style of GP that is very popular is the "uniplate" / "multiplate" / "syb" family of libraries
04:29:13 <Guest10024> kosmikus: thanks a lot! :)
04:30:25 <kosmikus> Guest10024: there are lots of libraries doing similar things out there. a current comparison / survey is desparately needed. some older ones exist.
04:30:37 <kosmikus> Guest10024: such as this http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3330&rep=rep1&type=pdf
04:30:53 <kosmikus> Guest10024: or this: https://www.andres-loeh.de/FormalComparisonGP/FormalComparisonGP.pdf
05:15:01 * hackagebot idris 1.1.0 ‚Äì Functional Programming Language with Dependent Types ‚Äì https://hackage.haskell.org/package/idris
05:22:14 * hackagebot hledger-iadd 1.2.4 ‚Äì A terminal UI as drop-in replacement for hledger add ‚Äì https://hackage.haskell.org/package/hledger-iadd
05:38:28 * hackagebot hw-hedgehog 0.1.0.1 ‚Äì Extra hedgehog functionality ‚Äì https://hackage.haskell.org/package/hw-hedgehog
05:50:01 <earthy> kosmikus: ISTR generic haskell being slightly nicer to write than this new stuff though, am I right?
06:03:50 * hackagebot unicode-transforms 0.3.3 ‚Äì Unicode normalization ‚Äì https://hackage.haskell.org/package/unicode-transforms
06:14:03 <bezirg> hello, I recently read that IORef's act as roots during GC. So I guess that means that a lot of IORefs add pressure to the GC. Does the same hold also for STRef's? i.e. STRef is a GC root
06:15:03 <[exa]> [1;3C2ƒõ
06:15:38 <merijn> bezirg: Why would many IORefs add more pressure than, e.g. just a bigger live set?
06:21:36 <bezirg> merijn: I guess the pressure would be the same. My question is out of curiosity abou the GC in these cases: 1 thread running forever { modifyIORef' x (+1) } VS the not quite equivalent:  {do let x = 1; x<- pure (x+1); x <- pure(x+1)...}
06:23:58 <bezirg> merijn: in other words, for imperative-like local variables should I use IORef,STRef or try to avoid them by these not-quite-equivalent pure code? I am mostly interested about performance/memory/GC and not about correctness since the Haskell code will be generated
06:25:35 <merijn> bezirg: Profile it?
06:27:09 <bezirg> merijn: that is the best I guess. Sometimes the easiest way to learn about the behaviour of the runtime is just to experiment on it :)
06:39:01 <saurabhn_> how does one delete the nth element from a vector?
06:39:32 <quchen> bollu bgamari- ‚Äì I implemented something akin to $$, would you review the patch if you have a bit of time? https://github.com/quchen/prettyprinter/issues/34 ‚Äì I don‚Äôt want to merge something that‚Äôs not fixing the specific GHC issues :-)
06:39:49 <ertes-w> bezirg: IORef and STRef are technically the same thing
06:40:13 <opqdonut> saurabhn_: do you mean vector or list?
06:40:26 <saurabhn_> opqdonut: Data.Vector
06:40:30 <ertes-w> bezirg: if you look at the source code, you will find that IORef is actually defined in terms of STRef
06:41:40 <opqdonut> saurabhn_: you need to use splitAt, drop and ++
06:41:43 <opqdonut> saurabhn_: as far as I can see
06:41:45 <bezirg> ertes-w: thanks for this, although I already knew that. I was just wondering if the runtime does some "magic" on the background so that the STRefs are not GC roots like IORefs are
06:41:57 <saurabhn_> ouch... how inefficient is that going to be for large vectors?
06:42:40 <kadoban> saurabhn_: Deleting from the middle of a vector is fairly inefficient in general, just considering the data structure itself.
06:42:44 <opqdonut> yeah
06:42:51 <opqdonut> O(max(i,n-i))
06:43:05 <saurabhn_> deleting from the middle in a list vs a vector?
06:43:16 -frerich(~frerich@kde/raabe)- saurabhn_: splitAt and drop are both O(1) but concatenating the result is linear. I guess that's typical for deleting in the middle of a vector.
06:43:16 <opqdonut> it's roughly the same
06:43:38 <opqdonut> if you need efficient removal, IntMap might be better
06:43:40 <opqdonut> or perhaps Data.Sequence
06:44:19 <frerich> or perhaps you can tell where you will need to delete (e.g. typically at the end or the beginning)?
06:44:25 <opqdonut> right
06:44:30 <kadoban> saurabhn_: For haskell's actual list type, still inefficient in about the same way. If you have a certain type of ephermal list structure it can be fast.
06:44:32 <ertes-w> bezirg: no, they are literally the same thing
06:44:47 <ertes-w> the type-level difference vanishes at run-time
06:46:09 <saurabhn_> for deleting an element in a vector, what seems better, two calls to Vector.slice followed by a ++, or splitAt => drop => ++
06:46:13 <quchen> ertes-w: But IO and ST are different, right? I think I remember that they‚Äôre for some reason not defined via ¬ªtype IO = ST RealWorld¬´. Maybe because of error messages?
06:47:10 <opqdonut> saurabhn_: there shouldn't be any difference
06:47:28 <merijn> quchen: IO and ST are both implemented in terms of unboxed State, iirc
06:47:29 <opqdonut> saurabhn_: aesthetically I'd prefer two slices I guess
06:47:58 <bgamari-> quchen, great, I'll look in just a moment. Thanks!@
06:48:08 <tabaqui> I'm playing with GADTs now
06:48:23 <tabaqui> let we have data Foo a
06:48:24 <quchen> bgamari-: No hurries, I just wanted to let you know about it
06:48:27 <tabaqui> with two constructors
06:48:32 <tabaqui> F :: Foo Int
06:48:36 <tabaqui> B :: Foo Char
06:48:57 <tabaqui> and function "func :: Foo a -> Bool"
06:49:13 <tabaqui> no "isInt :: Foo a -> Bool" is better
06:49:31 <tabaqui> how can I make it fine without using constructors in definition?
06:49:35 <tabaqui> I mean without
06:49:47 <tabaqui> isInt (F _) = True; isInt (B _) = False
06:50:54 * hackagebot monoidal-containers 0.3.0.2 ‚Äì Containers with monoidal accumulation ‚Äì https://hackage.haskell.org/package/monoidal-containers
06:51:05 <opqdonut> tabaqui: well you can always define a class: class IsInt a where isInt :: a -> Bool; instance IsInt (Foo Int) where isInt _ = True; instance IsInt (Foo Char) where isInt _ = False
06:51:14 <opqdonut> tabaqui: but I'm not sure what you're after
06:51:27 <ertes-w> quchen: i think they are at least nominally different
06:51:33 <frerich> saurabhn_: I like splitAt & drop :-)
06:51:41 <tabaqui> opqdonut: I need to write some kind of input sort function
06:51:56 <tabaqui> and input has about 15 constructors in 4 types
06:52:14 <saurabhn_> well... went with splitAt and drop... let's see what the benchmark says now...
06:52:32 <tabaqui> and I want to split them before sending specific input type in specific function
06:52:57 <tabaqui> hmm, classes is fine to me, thanks
06:53:00 <tabaqui> *are
06:58:37 * hackagebot extrapolate 0.0.1 ‚Äì generalize counter-examples of test properties ‚Äì https://hackage.haskell.org/package/extrapolate
07:01:06 <tabaqui> opqdonut: not much, I cannot use "isInt :: Foo a -> Bool" because Foo a is not class instance
07:01:21 <tabaqui> it is for two specific types, but not for all of them
07:01:49 <tabaqui> strange, type checker can't determine that there are only two constructors for Foo a
07:07:32 <opqdonut> tabaqui: right, I see. I guess then you really do need the "isInt (F _) = True; isInt _ = False" function
07:12:03 <tabaqui> opqdonut: I'll try to mess with functional dependices a little
07:12:23 <tabaqui> hm, or not
07:12:37 <opqdonut> tabaqui: so what's the problem with the normal isInt function?
07:12:50 <tabaqui> general pattern matching rules don't work with types, right?
07:13:03 <tabaqui> I have 15 constructors for my type
07:13:07 <tabaqui> this is the problem
07:13:39 <opqdonut> what do you mean by general pattern matching rules?
07:14:19 <tabaqui> foo 1 = doSmth1; foo 2 = doSmth2; foo _ = doElse
07:14:27 <tabaqui> it is not working with class instances
07:14:41 <tabaqui> class IsInt (Foo Int) where smth1
07:14:47 <tabaqui> class IsInt (Foo Char) where smth2
07:14:53 <tabaqui> class IsInt (Foo a) where smthElse
07:15:45 -frerich(~frerich@kde/raabe)- tabaqui: I think opqdonut meant to suggest to drop the idea of using a class but rather using a 'plain' isInt function.
07:16:24 <tabaqui> who's there?!
07:16:28 <opqdonut> tabaqui: yeah if you want to do it with class you need OverlappingInstances
07:16:54 <tabaqui> opqdonut: then it solves the problem
07:17:17 <opqdonut> tabaqui: anyway I think the normal isInt function is a better solution, like this: https://gist.github.com/opqdonut/fdeb81a1a60e02c3198fb271a22ec888
07:17:19 <kadoban> frerich: You know a decent number of your messages come over as "Notice"s, right? Is your client wacky or something?
07:17:27 <willem> Im trying to create an instance of Num for my data type, but whenever i try execute the functions it gives me an error saying that it wanted an integer input for the functions, why is this happening
07:17:52 <opqdonut> willem: can you paste your code somewhere?
07:18:16 <willem> opqdonut, ok i will, i'll add some of the functions too so you can try test it
07:18:18 <tabaqui> kadoban: he was kicked just now
07:18:37 <kadoban> Ah
07:18:44 <tabaqui> opqdonut: again, I don't want to write 15 almost identical strings
07:19:05 <opqdonut> tabaqui: notice how I don't need to handle B and Q separately
07:19:06 <tabaqui> but thanks for the ideas, overlappinginstances looks promising
07:19:37 <tabaqui> opqdonut: well, I have 3 different types
07:19:56 <tabaqui> and have to split them in 3-pos tuple of Maybe's
07:19:59 <opqdonut> ah now I think I see what you mean
07:21:38 <opqdonut> tabaqui: have a look at isint2.hs on https://gist.github.com/opqdonut/fdeb81a1a60e02c3198fb271a22ec888
07:22:02 <opqdonut> no need for OverlappingInstances this way
07:22:12 <willem> this is the code, http://pasted.co/17d905f4
07:22:40 <opqdonut> :t fromInteger
07:22:41 <lambdabot> Num a => Integer -> a
07:22:56 <opqdonut> willem: fromInteger is meant to go the other way around, take an Integer, and return a Stream
07:23:18 <willem> opqdonut, oh thank you! I should have checked that
07:24:01 <tabaqui> opqdonut: you used constructors in isInt definition
07:24:09 <tabaqui> there is another solution
07:24:12 <opqdonut> tabaqui: but only for the cases I care about
07:24:35 <tabaqui> rewrite my big Foo a and hide all constructors in 4 separated types
07:24:47 <tabaqui> I care about almost all of them
07:26:12 <tabaqui> I don't want to hide constructors, because it becomes too lispy
07:26:52 <kurren> hi
07:26:58 <shapr> hi kurren, how's code?
07:27:25 <opqdonut> tabaqui: hmm, I'm not quite sure what you're after. perhaps you can show me some code once you have a solution you like
07:27:47 <tabaqui> ok, wait a sec
07:28:01 <kurren> hey :) thanks for replying. I'm new to haskell, but can't find which package I need to reference to import the state monad
07:28:05 <tabaqui> are you familiar with arrow-based frp?
07:28:12 <kurren> the tutorial just says import Control.Monad.State
07:28:55 <kurren> has control.monad.state been renamed to something else?
07:29:07 <Cale> kurren: No, but you need to use uppercase letters
07:29:12 <Cale> Control.Monad.State
07:29:26 <opqdonut> tabaqui: vaguely
07:29:47 <kurren> Yes I do that, but its coming back with failed to load interface
07:29:50 <tabaqui> well, I'm writing asyncronious application
07:30:03 <kurren> then making suggestions like Control.Monad.ST
07:30:09 <tabaqui> all input events can be divided in three independent groups
07:30:38 <tabaqui> that can be handled separately
07:30:45 <Cale> kurren: Do you have mtl installed?
07:30:57 <Cale> kurren: How are you running ghc?
07:30:59 <kurren> nope
07:31:04 <kurren> stack 
07:31:17 <kurren> i'm guessing mtl is what im missing
07:31:19 <Cale> I suppose try adding mtl you your dependencies
07:31:20 <Cale> yeah
07:31:25 <Cale> to*
07:31:31 <kurren> thanks! i'll try that
07:31:59 <opqdonut> tabaqui: so you have 3 different data definitions, do they match these three groups or not?
07:32:34 <tabaqui> I have many 15 different input events in three groups
07:33:03 <tabaqui> but only one input node, so the should have same type (or same gadt)
07:34:13 <tabaqui> hm, how can I create paste on pastebin, that can be viewed only by direct link?
07:34:18 <opqdonut> so one input gadt with 15 cases
07:34:34 <tabaqui> yes
07:34:36 <opqdonut> https://gist.github.com/ has secret gists that are visible only by link
07:34:50 <opqdonut> I'd just write out the pattern match that divided these into three cases
07:34:54 <tabaqui> https://pastebin.com/iVnX7DRY
07:34:59 <tabaqui> ten minutes expiration, ok
07:35:20 <opqdonut> ok I see
07:35:58 <opqdonut> yeah that's a bit inconvenient
07:36:11 <opqdonut> you need to use type equalities or type families or overlapping instances
07:36:31 <tabaqui> type families...
07:37:18 <opqdonut> but what I'd do is I'd split the datatype like this: data Message = MessageToAgents ToAgents | MessageToScans ToScans | MessageToControllers ToControllers; data ToAgents = Register | Unregister | ...; data ToScans = ScanReady | ScanNotReady | ...; data ToControllers = ...
07:37:42 <opqdonut> then all the code is nice and simple haskell, no need for any extensions (including GADTs)
07:37:44 <tabaqui> I thought about that
07:38:44 * hackagebot attoparsec 0.13.2.0 ‚Äì Fast combinator parsing for bytestrings and text ‚Äì https://hackage.haskell.org/package/attoparsec
07:38:54 <opqdonut> using GADTs, you only get access to the type information (ToAgents/ToScans/ToControllers) by pattern matching
07:38:58 <tabaqui> but then I'll get a lots of irritating stupid parenthesis in following functiongs
07:39:22 <opqdonut> you could just drop the Message wrapper in split
07:39:40 <opqdonut> so it'd be Message -> (Maybe ToAgents, Maybe ToScans, Maybe ToControllers)
07:40:08 <opqdonut> but it's hard to know what's best for the whole codebase by just looking at one part
07:41:11 <tabaqui> I probably do it in that way
07:41:42 <tabaqui> thanks a lot
07:43:02 <opqdonut> good luck, have fun
07:44:37 <danilo2> Hi! What is the reason GHC allows us to unpack only primitive fields? Why cannot I have for example `data Foo = Foo {-# UNPACK #-} !(Vector Int) {-# UNPACK #-} !Int` ? Is it a design decision that will always be kept or we could allow for it in the future?
07:48:44 <merijn> danilo2: Eh...you can unpack non-primitive fields, you just can't unpack polymorphic fields
07:49:36 <shapr> unpack removes a layer of indirection: https://stackoverflow.com/a/33933202 What would that do for !(Vector Int) ?
07:50:36 * hackagebot HaskellNet-SSL 0.3.4.0 ‚Äì Helpers to connect to SSL/TLS mail servers with HaskellNet ‚Äì https://hackage.haskell.org/package/HaskellNet-SSL
07:54:08 <danilo2> merijn: oh, wait ... ok. Sorry, I just confused something now. I know about polymorhpic fields (I hope it will be available in some time, however I see how it affects a lot of things under the hood - typeclass dynamics dicts etc have to know the represetnation depending on call-sides type inference)
07:54:39 <danilo2> merijn: hmm, thank you, sorry, I was thinking about it too long. If you sometimes think too long, you start talking without sense :P
07:55:01 <Cale> It doesn't make a whole lot of sense to unpack polymorphic fields, because the indirection is also part of the mechanism for the polymorphism.
07:55:51 <Cale> But I do think we need some sort of facility for producing specialisations of polymorphic data structures
07:55:59 <Cale> (explicitly)
07:56:05 <danilo2> Cale: It would however be nice to be able to write `data Foo a b = Foo {-# UNPACK #-} !a {-# UNPACK #-} !b` and when provided with types like `Foo Int Int` you'll have a "specialised version". 
07:56:31 <Cale> I don't think that should happen automatically, as in many cases it wouldn't be beneficial
07:56:34 <danilo2> Cale: yes, I'm talking exaclty about something like "specializations" for data structs
07:56:50 <Cale> But manual specialisation would be great
07:58:00 <Cale> For example, Data.FingerTree is lovely
07:58:23 <Cale> But if you want to have an application of it with good performance, you have to hand-specialise, which is why stuff like Data.Sequence exists
07:59:00 <Cale> Maybe backpack will help in some way here
07:59:21 <Cale> (in several years, once it's possible to use ;)
07:59:36 <ezyang> Backpack can absolutely help you specialize, it is specifically designed for this 
08:00:06 <Cale> ezyang: Like, specialise the data types themselves?
08:00:08 <shapr> ezyang: Is there a demo in your thesis or on github?
08:01:00 <ezyang> look at https://github.com/ezyang/backpack-regex-example/tree/multiple-packages 
08:01:09 <ezyang> which I believe should still compile 
08:01:19 <ezyang> accompanying blog post: http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/ 
08:01:38 <danilo2> ezyang: could you tell more aobut it? How can I use backpack to create specializations of datatypes? Can I use it now when using GHC 8.2 ? 
08:02:17 <danilo2> ezyang: oh I overlooked your links
08:03:02 <Cale> I suppose it *would* work, yeah
08:03:04 <ezyang> danilo2: so, if you want to UNPACK an unspecified type, you define the type in a signature, and then write your module with {-# UNPACK #-} on the abstract type 
08:03:11 <ezyang> I just confirmed the examples still compile 
08:04:16 <danilo2> ezyang: oh my god, that would be awesome. ezyang Im now waiting only for stack support for backpack!
08:04:17 <Cale> ezyang: Might be a good bit of marketing for Backpack to do a backpackified finger-tree, and use it to build a bunch of data structure packages by supplying various monoids at the package level :)
08:04:33 <danilo2> Cale: +1
08:04:38 <Cale> (and see how they perform)
08:05:13 <ezyang> sure :) 
08:06:24 <ezyang> even better, if one of you guys tries it out, and tell me aobut the experience ;) 
08:07:34 <c_wraith> Cale: is that a case that gets a big benefit from using backpack?  I don't see a lot of ways for the implementation to specialize things that can't be done with cross-module inlining.
08:08:05 <ezyang> c_wraith: The benefit you will get is the monoid operations will get inlined into the definitions of the finger tree operations 
08:08:24 <ezyang> similar to having uniformly applied {-# SPECIALIZE #-} to every declaration in the module 
08:09:06 <c_wraith> Oh, I see.  A lot of the things that typically handle inlining instances wouldn't apply without a bunch of care, because of recursive definitions.
08:09:24 <danilo2> ezyang: by the way, thank you so much for bringing backpack to life
08:09:34 <ezyang> danilo2: It's not alive without y'all :) 
08:10:32 <danilo2> ezyang: backpack is a big thing. Without you it would not exist. I jsut want to tell you that there is really a lot of people that are happy and thankful for bringing it to life! :)
08:10:42 <ezyang> thanks! 
08:11:45 * hackagebot derive 2.6.3 ‚Äì A program and library to derive instances for data types ‚Äì https://hackage.haskell.org/package/derive
08:12:00 <danilo2> I always want to tell the same to GHC devs, you guys are the best, thank you :)
08:13:47 <danilo2> ezyang: By the way it is great we can use backpack for specilaizing datatypes. It would be even nicer if we could do it more "localy" without using the whole module speicalization mechanism. Maybe is there a way to extend backpack / GHC with such functionality and provide some specialize pragma for dpolymorphic datatypes based on the same mechanism under the hood ?
08:16:21 <ezyang> That's tough, because you run into many of the technical problems Backpack solves by just being an extension to the package system 
08:17:02 <ezyang> for example, the specialized data type is not interconvertible with the unspecialized version, but what do you do if two clients specialize the type in the same way 
08:18:15 <danilo2> ezyang: sure, I see these problems and do not know how to solve them. However you and GHC devs have much clearer image of ghc internals than me, so I was just asking if you see any "way" to do it maybe. Until now almost everybody was sure it will not be possible to unpack polymorhpic fields at all
08:18:47 <danilo2> ezyang: 2 days ago I was speaking aexaclty about thison GHC channel and it seems nobody realized that backpack can solve it in any way
08:19:09 <ezyang> Yeah, Backpack doesn't change this situation at all: it just side steps the problem by literally compiling the data structure multiple times 
08:19:41 <ezyang> ok, clearly I need to do some advertising 
08:20:08 <danilo2> ezyang: so in fact it "solves" it in some way. It jsut allows you to create modular code, that wasn ot possible until now. Of course this is not a "real" solution that we would dream of, but it allows you to achieve the same goals with a little extra work
08:20:30 <ezyang> yeah 
08:21:30 * hackagebot Frames 0.2.1 ‚Äì Data frames For working with tabular data files ‚Äì https://hackage.haskell.org/package/Frames
08:28:00 * hackagebot wai-route 0.3.1.2 ‚Äì Minimalistic, efficient routing for WAI ‚Äì https://hackage.haskell.org/package/wai-route
08:28:44 <shapr> I'm gonna name one of my kids Laura Emma Yoneda.
08:33:28 <danilo2> ezyang: according to documentation, backpack introduces new file format bkp "This format is not suitable for large scale programming" - why it is not suitable? 
08:35:07 <ezyang> it violates all sorts of layering assumptions, which basically makes it impossible for Cabal to handle it in a reasonable way 
08:35:41 <ezyang> and there's all sorts of implementation problems with it, e.g., if you modify one module, everything needs to get recompiled 
08:36:58 <danilo2> ezyang: hm, ok. I will jsut clarify why I asked about it. If we could use it in production code, it would be possible (correct me if im worng) to create "locally type-parametrized" modules and then use them mimiking the data type s specializations that we want. It would jsut be more convininet to define such datatypes in single file than to have to scatter them between files
08:38:23 <ezyang> yeah. I spent a bunch of time trying to figure out how to make bkp files work "production", but the only known approach is to add a fairly complicated protocol between Cabal and GHC so that GHC can communicate when it's in the business of building multiple libraries, so Cabal can deal appropriately. We didn't implement it. 
08:39:22 <danilo2> ezyang: sure, I see why you didnt implement it, however if that would alow us to easier create high performance code by defining locally specializable datatypes that could be a huge win
08:40:08 <danilo2> ezyang: I'm jsut tlaking about it to show this way of seeing how it is useful. Maybe it would be good idea to implement it in some feature :)
08:40:42 <ezyang> Believe me, I am well aware :)	I also spent some time trying to get Backpack to work in GHCi. Also in the end dropped 
08:40:44 <danilo2> ezyang: btw Im sure you should add 1 - 2 sentences of explanation to the docs why uzing bkp in prod code now is not good idea (docs only tell you sohuldnt but not clarify why)
08:40:53 <ezyang> GHC docs? OK. 
08:41:22 <ezyang> (if you do try, you will find that there isn't actually any way to tell Cabal about the bkp file, so.....) 
08:41:26 <danilo2> ezyang: I kknow you are aware, but maybe if more people know what it would bring us, it woudl be easier to convince to build this protocol into ghc 
08:42:08 <danilo2> ezyang: aktually I was talking about theese docs: http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/, but yeah, ghc docs should metnion it too
08:42:18 <greencap> hi folks. any skilled enterprise architects here?
08:42:26 <ezyang> oh ok, that's easy enough 
08:43:10 <dmwit> ?where justask
08:43:10 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
08:43:47 <greencap> If you look at the site iFixit - what functions are you missing or would you love to see? I'm not working for them I just have to develop a target scenario according to the TOGAF framework
08:44:08 <dmwit> Is this related to Haskell somehow?
08:44:20 <greencap> Nah, but you guys are smartish
08:44:31 <dmwit> Okay. Let's try to stay on-topic.
08:46:19 <greencap> #reddit 
09:04:31 * hackagebot encoding 0.8.2 ‚Äì A library for various character encodings ‚Äì https://hackage.haskell.org/package/encoding
09:04:46 <[exa]> Hm. Is there a good http client that would be usuable within a Snap web app?
09:05:19 <[exa]> I'm building something that accepts json requests, asks a database that accepts some other form of json, and returns json
09:05:20 <dmwit> This is going to sound stupid, but... HTTP?
09:05:33 <[exa]> yeah I underspecified it :D
09:05:49 <dmwit> No, I mean, like...
09:05:51 <srhb> [exa]: No, https://hackage.haskell.org/package/HTTP
09:05:51 <dmwit> ?hackage HTTP
09:05:51 <lambdabot> http://hackage.haskell.org/package/HTTP
09:06:05 <srhb> But anything will do really.
09:06:17 <srhb> I've used wreq sometimes, when I didn't have very specific needs.
09:06:34 <dmwit> That page also suggests http-streams, http-client, req, and wreq.
09:06:57 <[exa]> looking at req now
09:06:59 <[exa]> thanks guys. :]
09:11:37 * hackagebot vinyl-gl 0.3.1 ‚Äì Utilities for working with OpenGL's GLSL shading language and vinyl records. ‚Äì https://hackage.haskell.org/package/vinyl-gl
09:18:58 <danilo2> Hi! Is there any way (without using TH) to derive everything the base datatype implements when creating newtype?
09:19:14 <tsani> GeneralizedNewtypeDeriving
09:19:17 <tsani> oh
09:19:21 <tsani> *everything* programmatically?
09:19:43 <ezyang> yep 
09:20:00 <danilo2> tsani: err, yeah, like newtype Span = Span Int deriving everything
09:20:03 <ezyang> oh, but you still have to give teh class list 
09:20:34 <tsani> I guess if you're deriving everything, what's the point of the newtype?
09:20:45 <danilo2> I know, but I want to make it better - I do not want to specidy the list, because if Ints get soemthing new, I would love to get it too
09:21:10 <danilo2> tsani: there are use cases where there isp oint, look, Span could be monoid, because it's mempty is 0, but otherwise it should behave like Int 
09:21:50 <tsani> Ah yes
09:21:58 <tsani> that is a reasonably good use case
09:22:07 <tsani> But no, I don't believe this is possible unless you use TH
09:22:35 <danilo2> tsani: I know, but discovering it in TH is cumbersome too. Hmm, im going to create feature request on it I think. I have too manuy such examples now
09:22:54 <tsani> Sure. `deriving everything` could be worthwhile to have
09:22:59 <danilo2> :)
09:35:55 * ealthout derives himself
09:42:01 * hackagebot mikrokosmos 0.5.0, pushbullet-types 0.4.0.0, servant-pushbullet-client 0.4.0.0, tpb 0.4.0.0
09:42:01 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
09:55:45 <shapr> @quote
09:55:45 <lambdabot> pylint says: Your code has been rated at -3.17/10 (previous run: -3.17/10, +0.00)
09:55:51 * shapr cackles cheerfully
09:56:48 <shapr> salut Deide, comment ca va?
09:56:57 <shapr> How's code terating you?
09:57:59 <Deide> Unfortunately I don't know much French, but code is treating me okay recently, haha
09:58:09 <shapr> writing anything interesting?
09:58:50 <Deide> I wish
09:59:09 <Deide> You?
10:02:25 <shapr> Deide: I was playing with hs-zstd last night, trying to reprocude the issues on github
10:06:17 <Deide> Oh nice. Reminds me of an article I recently read regarding calling into C and competing with C's performance in Haskell: https://two-wrongs.com/on-competing-with-c-using-haskell
10:15:12 <laserpants> Is there a way to simplify foo f x = fmap join (sequence (fmap f x)) ?
10:15:14 <cocreature> oh zstandard, I had already forgotten that exists
10:15:29 <cocreature> :t \f x -> fmap join (sequence (fmap f x))
10:15:31 <lambdabot> (Monad f, Monad m, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
10:17:28 <shapr> cocreature: yeah, facebook's PATENTS thing still makes me nervous, but I do like zstd
10:18:54 <cocreature> shapr: it seemed quite interesting when I looked at it but then I just never had a need for a compression algorithm so I forgot about it :)
10:21:24 <dysfun> shapr: what, the additional grant of patent rights to users?
10:21:38 <byorgey> laserpants: I can't think of any
10:22:19 <byorgey> laserpants: other than eta-reduction
10:22:24 <shapr> dysfun: it looks like it says "if you sue facebook for patent stuff, your patent grants are yanked"
10:22:27 <byorgey> simplify f = fmap join . sequence . fmap f
10:22:28 <shapr> if that's all, I'm fine with it.
10:22:51 <dysfun> shapr: so don't sure them over patents, software patents are bad anyway
10:23:00 <laserpants> byorgey: It is almost like a lifted >>=, but with the arguments reversed. Or maybe I am thinking wrong?
10:23:19 <shapr> dysfun: sure, I'm just not entirely sure that's exactly what the PATENTS file implies
10:23:28 <byorgey> laserpants: yes, it is, except the second argument has type  m a1  instead of   f (m a1)
10:23:51 <laserpants> hmm
10:24:39 <byorgey> :t \f x -> getCompose ((Compose . f) =<< (Compose (return x)))
10:24:41 <lambdabot> error:
10:24:41 <lambdabot>     Variable not in scope: getCompose :: m0 b0 -> t
10:24:41 <lambdabot> error:
10:25:41 * hackagebot word-wrap 0.1.1 ‚Äì A library for word-wrapping ‚Äì https://hackage.haskell.org/package/word-wrap
10:26:32 <byorgey> well, I'm pretty sure that would do the same thing, if Compose were in scope
10:26:50 <byorgey> because Traversable is exactly what you need for the composition to be a monad
10:27:39 <byorgey> :t \f -> fmap join . sequence . fmap f
10:27:41 <lambdabot> (Monad f, Monad m, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
10:27:45 <cocreature> how is that supposed to work given that Compose is not an instance of Monad?
10:28:21 <byorgey> cocreature: oh, there's no instance of Monad for Compose?  I thought there would be one.  But I guess not.
10:28:34 <byorgey> In theory there could be.
10:28:53 <cocreature> byorgey: huh? maybe I‚Äôm completely missremembering things but I thought you can‚Äôt write one
10:29:05 <byorgey> instance (Monad f, Monad g, Traversable ??) => Monad (Compose f g)   -- I forget whether ?? needs to be f or g
10:29:38 <cocreature> ah right if you add the Traversable constraint it works out
10:30:25 <byorgey> laserpants: maybe you want to take whatever your 'f' and 'm' types actually are, and make a newtype of their composition, with a Monad instance for it...
10:32:10 <isd> Hey all. I've got a type class I'm defining, and I want to define instances for both [a] and [Char], and have the latter be used where possible. Is there any way to achieve this?
10:33:26 <geekosaur> very bad way: OVERLAP pragmas and hope the compiler does the right thing
10:33:48 <geekosaur> proper way 1: wrap [Char] in a newtype so it can have its own instance
10:34:24 <geekosaur> proper way 2: one list instance which defers to a list method in the base instance: see showList
10:34:50 <laserpants_> Sorry, connection dropped.
10:35:41 <byorgey> laserpants_: the last thing I said was, maybe you want to take whatever your 'f' and 'm' types actually are, and make a newtype of their composition, with a Monad instance for it
10:36:03 <isd> geekosaur: thanks. (2) sounds like what I want in this case.
10:36:24 <geekosaur> (since your situation is precisely the same as the one that allows Show to handle [Char] differently from other lists
10:36:51 <isd> Yeah, it's the same thing almost exactly.
10:36:52 <laserpants_> byorgey: thanks, I'll give it a try.
10:37:52 * hackagebot propellor 4.7.4 ‚Äì property-based host configuration management in haskell ‚Äì https://hackage.haskell.org/package/propellor
11:07:28 <nshepperd_> I never thought about how Show String worked before. Has it always used showList?
11:08:41 <dolio> Yes.
11:14:41 <geekosaur> Haskell98 doesn't have overlapping instances, so showList is pretty much the only way to do that without a newtype
11:33:25 <cocreature> I‚Äôm never sure if it‚Äôs a gross hack or actually a pretty clever idea to avoid overlapping instances
11:34:40 * hackagebot language-sally 0.1.2.0 ‚Äì AST and pretty printer for Sally ‚Äì https://hackage.haskell.org/package/language-sally
11:35:49 <geekosaur> clever not bot very general
11:35:52 <geekosaur> er
11:35:59 <geekosaur> clever, but not very general
11:36:07 * geekosaur eyes his finfers suspiciously
11:36:46 <geekosaur> only works with container-y things, and you can't augment Show with your own showMyType
11:37:20 <geekosaur> (just imagine if you could. never mind orphan instances, how about orphan methods?)
11:38:36 <cocreature> geekosaur: now I‚Äôm going to have nightmares about orphan class methods
11:41:46 * hackagebot pretty-compact 2.1 ‚Äì Pretty-printing library ‚Äì https://hackage.haskell.org/package/pretty-compact
11:41:46 * hackagebot cheapskate 0.1.1 ‚Äì Experimental markdown processor. ‚Äì https://hackage.haskell.org/package/cheapskate
11:49:39 <danilo2> Hi! :) Am I overlooking something or there is no standard `liftST` function in our libraries? 
11:52:52 <kadoban> danilo2: What should its type be?
11:53:00 <danilo2> oh there is monad-st from EKmett
11:53:07 <danilo2> kadoban: like liftIO but more general
11:54:39 <geekosaur> I think ST is generally regarded as something you briefly dive into when you need to do dirty mutability, not something you'd use as the base of a monad stack
11:54:48 <geekosaur> (i.e. nobody thought about that use case)
11:55:06 <geekosaur> except, inevitably, ekmett...
11:56:06 <kadoban> Heh
11:56:25 <kadoban> Yeah, at most all I've ever done on top of ST was I think I maybe did ReaderT once.
11:58:16 <danilo2> geekosaur: err ,why ? if you write a function that operates on mutale vecotes you can create utils in some monad using STRefs. If osmebody would like to use it in IO, these STRefs would behave like IORefs, but if you want to convert it to "pure one", you can use runST. ST is just more general and without any performance peneatilies
11:59:09 <geekosaur> because pretty much all the documentation about ST assumes limited use cases, it doesn't encourage thinking generally about it as an IO replacement
11:59:53 <geekosaur> I'm not saying you're doing a bad thing, I'm saying nobody's really thought about the general case and extant documentation tends to reinforce that
12:00:44 <geekosaur> sometimes people need a kick in the butt to think more generally
12:01:11 <sqooq> abstraktion abstraktion abstraktion
12:02:08 <danilo2> geekosaur: sure, docs could better describe use cases of ST, but it doesnt change situation that ST is just more general than IO. Btw, maybe is there any class LiftM or something that would provide `class LiftM n m wherer liftM :: n a -> m a` that would be even fancier cause we could define `LiftM IO` and `LiftM (ST s)`, which could replace `MonadIO`
12:02:49 <geekosaur> (and then how about STM?)
12:03:37 <wz1000> danilo2: MonadBaseControl?
12:06:07 * hackagebot columbia 0.1.0.0 ‚Äì Enhanced serialization for media that support seeking. ‚Äì https://hackage.haskell.org/package/columbia
12:07:09 <danilo2> wz1000: yeah! MonadBase is what I was looking for 
12:07:11 <danilo2> thanks!
12:07:27 <sqooq> hey, this is pretty unrelated to haskell specifically, but I tried googling and couldn't find anything
12:07:39 <sqooq> in windows terminal, is there a way to like make a shortcut to a location or something
12:07:45 <sqooq> so I don't have to type cd ...... evertime
12:08:13 <danilo2> wz1000: but the fundep there makes little sense
12:08:14 <danilo2> :/
12:08:48 <wz1000> why? you can only have one base monad for any given stack
12:08:58 <Xion__> sqooq: If you get cmdr.net, you will have some basic Unix aliases including ln
12:09:14 <danilo2> I know it shows us bottom of the transformers stack , but in "modern haskell" it would be better to use closed type fmaily to discover it automatically than just put in constraint another variable that we cannot hide due to lack of impredicative context polymorphism
12:09:19 <geekosaur> you can drop a folder from explorer into a command window
12:09:23 <Xion__> (though this creates NTFS symlinks / junction points / w/e they're called, not Windows shortcuts)
12:09:26 <geekosaur> you'd stil have to type the "cd " first though
12:09:26 <danilo2> wz1000: ^^^
12:10:39 <sqooq> i'm ok with typing cd but typing the actual location
12:10:47 <sqooq> when it's like 7 layers deep, is annoying
12:11:40 <geekosaur> since vista windows has actual symlinks, although you may need tooling to create them; pre-vista administrator can create ntfs reparse points, which are more like linux bind mounts
12:12:08 <danilo2> wz1000: either we shoudl drop the fundep there and allow lifting not only from base monad or use type families do discover it without the need for the user to provide the same information the typechecker checks in the constraint
12:12:29 <geekosaur> sqooq, https://superuser.com/questions/224024/cdpath-in-windows-command-prompt
12:12:56 <danilo2> wz1000: like (type family BaseMonad m where BaseMonad (t m) = BaseMonad m; BaseMonad m = m) 
12:17:42 <tsani> danilo2: won't that type family compute BaseMonad (f (g a)) ~ a ?
12:18:15 <tsani> ah, but I suppose that's exactly what you want if f and g are monad transformers, and a is a monad.
12:18:31 <sqooq> ok here's my program related question. code is here http://lpaste.net/357345. I'm trying to parse text in the form "[ [ 1 2 3 ] [ 1 2 ] ]   [ 1 2 3 4 ] ..." and understand it as a tree. Since I was working with simple inputs, I forget there can be multiple sets of brackets. So here's my question: should I try to separate each group and what happens to it, from every other, or do it all in one list. 
12:18:43 <geekosaur> tsani, that's the point, yes
12:19:26 <sqooq> Also, is it smart to tackle the parsing of the tree by counting how many open and closes there are and when they're equal, stop there's a group
12:19:42 <geekosaur> sqooq, I'd generally have a parseThing that sees '[' and parses a list (recursing onto itself to parse elements), else parses a single value.
12:20:53 <geekosaur> the recursive invocation would pass ']' as a stop-parse-and-succeed marker; the top level one might pass nothing (i.e. Just ']'¬†vs. Nothing) or a parser that recognizes end of input (recursive case would then be (char ']'))
12:21:38 <Yuuri> Hello! A fellow Haskeller is looking for a vacant place in someone's team for the upcoming ICFPC.
12:23:24 <sqooq> hmm
12:26:40 <kadoban> Yuuri: Nice. I have a team I'm going to be a part of, but I'm the only haskeller, don't think we'll be using haskell.
12:27:54 <sqooq> geekosaur: What do you mean by "parses a list"
12:29:55 <geekosaur> if parseOneThing sees a '[', it calls itself recursively and captures the result of each call into a list, until it sees a ']', at which point it returns the list. otherwise it just parses (presumably) a number and returns that
12:30:11 <geekosaur> are you working woth a parser library, or do you need to write this yourself?
12:30:42 <sqooq> I wrote my own parser
12:30:47 <sqooq> that I think is pretty complete
12:31:06 <sqooq> the problem I think with what you're telling me, is that it would stop at the first ']'
12:31:15 <sqooq> if i understand what you're saying
12:31:54 <sqooq> group " [ [ ] ] " needs to return "[ ]", in Parser form of course
12:32:10 <sqooq> so it needs to somehow realize that that first ] is not the end of the group
12:32:25 <EvanR> lots of quit join traffic from matrix.org
12:33:13 <sqooq> geekosaur: http://lpaste.net/357345
12:33:42 <geekosaur> sqooq, if you write it the way I am talking about, you want that --- only on recursive invocations, which is why I said that.
12:33:54 <geekosaur> the top level one would stop at the end of the input
12:34:44 <geekosaur> this is also generalizeable because it can be made to handle something like dictionaries too (on '{', recursively parse value ':' value until seeing '}')
12:35:44 <sqooq> yeah I don't understand then
12:36:00 <geekosaur> parseOneThing with end-marker = EOI -> see '[', loop invoking itself recursively until it sees ']'
12:36:28 <sqooq> OOOOO
12:36:38 <sqooq> Ok it invokes ITSELF
12:36:46 <sqooq> I'm just thinking it recursively consumes items
12:36:50 <sqooq> ok let me see what I can do
12:37:06 <geekosaur> so [ [ ] ] would see '[', start loop, not see ']', recurse, recurseive instance sees '[', starts loop, sees ']' and returns empty list to parent, parent sees ']' and returns list containaining empty list
12:37:26 <sqooq> yup
12:37:35 <geekosaur> and parent then sees end of input and produces that result
12:37:42 <sqooq> God I was so close
12:37:45 <sqooq> to doing that myself
12:37:59 <sqooq> I was just having trouble wrapping my mind around how it would store the inbetween
12:38:07 <sqooq> and I kept thinking it would fail, maybe the way I was doing it
12:38:09 <sqooq> ok let me try again
12:39:10 * hackagebot propellor 4.7.5 ‚Äì property-based host configuration management in haskell ‚Äì https://hackage.haskell.org/package/propellor
12:40:21 <xcmw> What can I replace canbeanything with? type D = ((~) (ElField '(canbeanything, String)))
12:41:21 <ski> maybe parameterize `D' ?
12:42:02 <xcmw> ski: Can you explain?
12:42:17 <ski>   type D a = ((~) (ElField '(a,String)))
12:42:20 <ski> perhaps
12:42:36 <xcmw> ski: D must have type Constraint
12:42:41 <xcmw> kind*
12:42:44 <ski> then you could possibly say `D _ Blah', when you use it
12:43:23 <ski> your stated `D' already didn't have kind `Constraint'
12:43:36 <sqooq> geekosaur: I have to somehow do this with bind right
12:43:59 <sqooq> it just sucks because if a condition fails then the whole thing fails
12:44:13 <sqooq> O
12:44:16 <geekosaur> you can write it without a monad; most parser monads are glorified State monads
12:44:18 <sqooq> I can use <|> I think
12:44:22 <xcmw> ski: I meant to say * -> Constraint
12:44:29 <sqooq> well my whole parser is monadic lmao
12:44:45 <ski> why can't you use `D _' in place of where you currently want to use `D' ?
12:44:48 <geekosaur> you would prodice a Maybe or Either or Except/ExceptT or ...
12:44:59 <xcmw> ski: Wildcard ‚Äò_‚Äô not allowed in a constraint
12:45:16 <ski> oh .. that's interesting
12:45:19 <sqooq> I use [] as error
12:45:24 <sqooq> which i'm not so sure I like so much
12:45:30 <sqooq> I'm too afraid to change it now though lmao
12:45:40 <xcmw> ski: In  g :: RecAll ElField k (D _) => FieldRec k -> FieldRec k
12:45:46 <ski> i assume that you want to get the effect of `frob :: forall a. D a Blah => ...' (using my version of `D')
12:45:49 <sqooq> I just want to get everything working before I go trying to generalize and make better
12:46:08 <ski> ok, it's a parameter of another class
12:46:46 <ski> does `g :: RecAll ElField k (D a) => FieldRec k -> FieldRec k' work, or does it require something more specific than a tyvar `a' ?
12:47:19 <ski> hmm
12:47:25 <xcmw> There is more than one a
12:47:50 <xcmw> RecAll constraints a list in a weird way
12:47:55 <ski> oh, is `RecAll' some kind of `map' on records, and you want to apply this constraint to every record field type, with possibly different `a's in each case ?
12:48:09 <xcmw> ski: Yes
12:48:40 <ski> then, conceptually, you want `RecAll ElField k (\t -> exists a. D a t)'
12:48:47 <sqooq> I have to use bind
12:48:51 <xcmw> ski: Yes
12:48:53 <sqooq> this is hard
12:49:07 <ski> i'm not sure of a way to encode / achieve this
12:50:06 <ski> (a `_' wouldn't have worked, even conceptually, here, either)
12:50:27 <ski> hmm
12:51:47 * hackagebot hasmin 0.3.2.3 ‚Äì CSS Minifier ‚Äì https://hackage.haskell.org/package/hasmin
12:52:51 <ski> xcmw : perhaps you can define a type family `F' with an instance on  ElField '(a,b)  which yields `b', and then `D t' is defined as `F t ~ String' ?
12:54:19 <xcmw> ski: Will ghc allow a partially applied type alias? Will I have to make a wrapper typeclass?
12:55:22 <ski> you mean for `D' ?
12:55:36 <ski> you can try `LiberalTypeSynonyms'
12:56:06 <ski> i think that that (using a type family to encode an existential), at least conceptually, could work
12:56:59 <sqooq> this is as far as I got, but I already know it's wrong :    bracket = if (do char '[' ; x <- bracket) /= []  then return x     else if char ']' /= []
12:57:05 <sqooq> geekosaur
12:58:17 <cement> does anyone know about pseudoterminals a la expect/tcl?
12:58:19 <xcmw> ski: The type synonym ‚ÄòD‚Äô should have 1 argument, but has been given none
12:58:31 <xcmw> Will try making a typeclass
13:00:21 <xcmw> ski: I think the type class worked. Thanks for your help.
13:00:36 <sqooq> a stored variable from a do block can't be accessed elsewhere can it?
13:00:38 <geekosaur> cement, there's posix-pty on hackage and I think basic pty support in the standard unix library
13:00:43 <ski> xcmw : np
13:00:55 <geekosaur> sqooq, you can "return" (or "pure") something
13:01:21 <ski> sqooq : it's only in scope in the `do'-expression, yes
13:01:51 <sqooq> if I'm doing an 'if' expression then I would have to somehow get the return from the condition into the 'then'
13:02:02 <sqooq> this probably isn't even the way I want to do this tbh
13:02:30 <ski> i'm not sure what the `/= []' is supposed to do here
13:03:00 <sqooq> if any function fails [] is passed
13:03:02 * ski is pretty sure the type of `do char ...' is not a list type
13:03:26 <sqooq> newtype Parser a = Parser {fromParser :: String -> [(a,String)]}
13:03:51 <ski> oh, so you want to specify an alternative parsing path, to try in case  do char '[' ; x <- bracket; ..x..  doesn't work ?
13:04:16 <sqooq> wait I should do /= empty then
13:04:18 <ski> possibly you can use `<|>' to combine alternative parsing branches
13:04:25 <sqooq> since return will make Parser a
13:04:30 <sqooq> empty :: Parser a too
13:04:55 <sqooq> ski: yeah I have <|>, I was trying stuff with it too
13:05:05 <sqooq> You know what, let me keep workign on it, I'll figure it out
13:05:11 <ski>   do char '[' ; x <- bracket; ...; return x  <|>  ...
13:05:14 <sqooq> or I'll spend another hour and come back
13:05:19 <ski> perhaps something along those lines
13:05:25 <sqooq> i'll see
13:05:41 * ski hasn't read the discussion from the start
13:06:00 <geekosaur> sqooq, some helpers you might want to think about:
13:07:26 <geekosaur> until :: Parser b {- recognize end marker; reuslt ignored, only success/fail -} -> Parser a {- recognize a single item -} -> Parser [a] {- accumulated result -}
13:08:07 <ski> (but i'm also pretty sure `/= empty' doesn't work .. and is not the right thing to do, either. you don't want to check if the "parsing recipe" is the "empty (*always* failing) recipe". you seemed to want to check whether a previous portion of the parse *actually* failed, in this current parsing instance. i'm not sure how good it is to think of it like this, but it's probably better than `/= empty', at least)
13:09:03 <sqooq> geekosaur: how do y'all do this so effortlessly
13:09:06 <geekosaur> actually I think that's the only one since the other I was tjinking about isn't how most Haskell parser libraries work
13:09:22 <geekosaur> sqooq, I've been doing parsers for a couple decades :)
13:09:25 <ski> sqooq : practice, familiarity, conceptual understanding, experience
13:09:31 <sqooq> true
13:09:42 <sqooq> I'm literally only like 2 months in
13:09:53 <ski> it'll come easier, if you keep at it
13:10:04 <sqooq> it already feels easier everyday
13:10:13 <sqooq> I'm not nearly as frustrated and lost as I felt the first day
13:10:23 <cement> also listening to people blabber on and on about it helps
13:10:30 <sqooq> yup
13:10:31 <cement> and reading people doing the same
13:11:34 <geekosaur> sqooq, I think part of your problem here is not parsers, but understanding how to use the tools Applicative, Alternative, and Monad give you
13:11:43 <geekosaur> (for example, bind / >>= )
13:11:52 <sqooq> I know bind 
13:11:53 <sqooq> very well
13:12:10 <sqooq> (I think... i hope)
13:12:16 <sqooq> I know <|> decently
13:12:40 <sqooq> and many
13:12:50 <geekosaur> [01 20:01:29] <sqooq> if I'm doing an 'if' expression then I would have to somehow get the return from the condition into the 'then'
13:12:51 <sqooq> I have no clue what <*> does
13:13:07 <geekosaur> this sounds like you're missing some aspects, tbh
13:13:24 <geekosaur> @src (<*>)
13:13:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:13:28 <geekosaur> @src <*>
13:13:28 <lambdabot> Source not found. Abort, Retry, Panic?
13:13:36 <geekosaur> though that was there, oh well
13:13:41 <ski> @src ap
13:13:41 <lambdabot> ap = liftM2 id
13:13:42 <geekosaur> no, I'[m confused I think
13:13:45 <ski> (that ?)
13:13:49 <geekosaur> was thinking of <$>
13:13:56 <ski> ok
13:14:02 * geekosaur stilla  trifle weak on Applicative himself...
13:14:05 <sqooq> well I only tried if expressions because if I just did a do, then the minute the first char '[' fails, no further actions would matter, [] would be returned
13:14:07 <geekosaur> always ocnfuse those
13:14:25 <sqooq> and do boils down to bind
13:14:26 <cement> <$> is just fmap
13:14:42 <sqooq> so I was trying to somehow allow it to fail but still do something else
13:14:52 <sqooq> now thinking about it, of course <|> would be helpfl
13:14:52 <geekosaur> sqooq, that can actually be what you want, with the char '['
13:15:00 <geekosaur> think about invoking the thing doing that as part of a <|>
13:15:02 <geekosaur> yes
13:15:16 <Franciman> Hello
13:15:22 <sqooq> hi
13:15:49 <Franciman> I installed ghc from a binary package from haskell.org
13:15:52 <Franciman> Now I want to update ghc 
13:15:53 <geekosaur> although it still has some tricky parts, for example if you try to do parseBracket <|> parseNumber, think about what happens if you feed it something like "[ x"
13:15:59 <Franciman> what's the best way to do that?
13:16:04 <Franciman> How can I delete old ghc?
13:16:13 <Franciman> (I'm on arch linux)
13:16:34 <geekosaur> if you didn't install it into iots own tree, you get to chase down the parts manually
13:16:35 <cement> something something stack
13:16:36 <sqooq> geekosaur: it would return '[' right?
13:17:09 <geekosaur> sqooq, what happejs is the parser fails at the x and parseNumber will try to run at that, completely forgetting the bracket existed
13:17:40 <Franciman> geekosaur, manually? ok thanks
13:17:53 <geekosaur> granting that in this case the parse will fail, (a) you get better error messages if you don't "forget" stuff like that (b) if you later support something like that, you will get some *odd* results from typoes, including incorectly succeeding parses
13:18:33 <sqooq> what I thought <|> returns the first one that succeeds
13:18:42 <geekosaur> sqooq, since the parser as written is not smart enough to "back up" when it hits the error
13:19:29 <sqooq> unless parseBracket is not the same as checking once for [ or ]
13:19:47 <geekosaur> parseBracket would be a full bracketed list
13:19:52 <sqooq> is parseBracket the idealized result of what my function was supposed to be
13:20:11 <geekosaur> except if there's an error in the middle of that list, <|> would then try parseNumber *at the point where the bracket parse failed*
13:20:24 <sqooq> ah
13:20:25 <geekosaur> and completely forget that there was a bracketed list going on
13:20:25 <sqooq> i see
13:20:37 <geekosaur> so now your bracket parsing is out of sync
13:20:48 <Franciman> geekosaur, is everything installed in prefix?
13:20:53 <geekosaur> Franciman, yes
13:20:57 <Franciman> where prefix is by default /usr/local
13:21:00 <Franciman> oh, perfect
13:21:06 <masaeedu[m]> Can Haskell return actual values of polymorphic types?
13:21:07 <geekosaur> which is why it's best to isntall ghc in its own prefix. then you can just remove the prefix dir
13:21:25 <Franciman> I'll do it now
13:21:27 <Franciman> thank you for the advice
13:21:55 * masaeedu[m] sent a long message: masaeedu[m]_2017-08-01_20:21:33.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/HMoSzRuFGLmQSbiwAHlGSBAC>
13:22:34 <masaeedu[m]> So when I invoke `lensIndex` with a single value, what am I actually returning?
13:23:18 <sqooq> nested do's are the same as one do with ; right?
13:23:46 <geekosaur> :t (!!)
13:23:47 <lambdabot> [a] -> Int -> a
13:23:55 <masaeedu[m]> It doesn't make sense for `Lens [a] a` to be returned, because that's still an abstract type. There's no such thing as a `Lens [a] a` value; there can only be `Lens [Char] Char` or `Lens X Y` etc.
13:24:26 <geekosaur> :t (!! 3)
13:24:28 <lambdabot> [a] -> a
13:24:37 <geekosaur> now imagine ^ that is a Lens [a] a
13:25:10 <geekosaur> lenses are, in essence, wrappers for functions
13:25:58 <masaeedu[m]> Imagine the signature was `Int -> [a] -> a`
13:26:09 <masaeedu[m]> That's what's confusing me
13:26:59 <masaeedu[m]> I guess `[a] -> a` is still not so bad because you're returning a polymorphic function, i.e. `forall a. [a] -> a`
13:27:05 <geekosaur> what that is telling you is that, for any type a, if you give it a list of that type and an index, it will produce an item of that type
13:27:22 <geekosaur> it doesn;t have to know what the type is, all it cares about is the list
13:28:17 <masaeedu[m]> Right
13:28:27 <masaeedu[m]> But with `lensIndex :: Int -> Lens [a] a` I'm not going to give it anything
13:28:39 <geekosaur> any actual use of it will be at some particular type; but because it doesn;t need to know about anything other than the list, it can be implemented on any type that can be contained in a list
13:29:13 <geekosaur> but you have no problem with the type of (!!)?
13:29:15 <masaeedu[m]> I just give it an `Int` and it returns a polymorphic value? I guess
13:29:30 <geekosaur> it returns a function, because a Lens is a wrapper for (two, actually) functions
13:29:46 <masaeedu[m]> No, my mental problem is with values that introduce type parameters that are only used in the final return valuye
13:29:51 <masaeedu[m]> Ah
13:30:01 <roee30> @pl 3
13:30:01 <lambdabot> 3
13:30:13 <geekosaur> Lens [a] a is, here, isomorphic to ([a] -> a)
13:30:34 <roee30> @pl g f i xs = map fst $ tail $ scanl f i xs
13:30:34 <lambdabot> g = (((map fst . tail) .) .) . scanl
13:30:43 <geekosaur> it actualy can do more than that, but for the purposes of this, that's what you have
13:31:35 <sqooq> geekosaur, I still must be missing something. Am I right in thinking that a different action must be taken depending on whether or notchar '[' succeeds?
13:31:40 <geekosaur> (because a Lens [a] a can both retrieve and update the value at the specified list index)
13:31:53 <geekosaur> sqooq, you are right
13:31:53 <masaeedu[m]> Thanks, it seems like the pieces are falling in place a bit more. It still feels weird that this kind of thing works without higher ranked types
13:32:35 <masaeedu[m]> I'm actually trying to implement something similar in TypeScript, where you have to explicitly quantify over everything
13:32:36 <geekosaur> masaeedu[m], in some sense a function-valued record is the poor person's higher ranked type
13:32:52 <masaeedu[m]> I tried to use Haskell to actually understand it but of course everything works so beautifully I barely understand how
13:33:37 <geekosaur> function-valued records can be used to emulate OOP, can be (and, in ghc, are) used to implement Haskell typeclass instances, etc.
13:33:39 <sqooq> geekosaur, and if char '[' fails, then [] gets returned. AND if i did char <|> sat (/=']'), then for either the same further actions would be performed in the do block. No?
13:34:05 <kamyar> Hello guys! I have a question about using OSRM with Haskell FFI
13:34:33 <geekosaur> sqooq, I'm going to suggest you look at the definition of sat
13:34:33 <kamyar> I just want to use the method of compiling Haskell code + OSRM C Code! It is mentioned in FFI docs
13:34:53 <geekosaur> line 77-80 of your earlier paste
13:35:08 <kamyar> Keep in mind I do not want to call http services, I wanna mix OSRM C code with my Haskell code using GHC
13:35:17 <sqooq> o lol
13:35:19 <sqooq> LMAO
13:35:39 <geekosaur> all those nice examples you have in that file already
13:35:42 <sqooq> I'm guessing that the point you're trying to make is that an if expression can be within a do block
13:36:02 <sqooq> I think I need a break I'm getting pretty ridiculous
13:36:08 <geekosaur> it can, and you can do more than just "return x". llook at sepby and sepby1 for more examples
13:36:08 <sqooq> only got like 3 hours sleep
13:36:47 <sqooq> geekosaur, ooh, mentioning sepby, I promise I at least think I understand everything in that file EXCEPT sepby.
13:36:55 <kamyar> FFI Document has a sample with just a single C file. How can I add a while project along with header files 
13:36:57 <sqooq> If I understand it right, it alternates back and forth
13:37:11 <geekosaur> sepBy <item parser> <separator parser>
13:38:04 <geekosaur> kamyar, generally you build the C project separately and make a library of it, and then create FFI bindings to that library. look at hsc2hs and c2hs for that
13:38:11 * hackagebot generic-lens 0.3.0.0, multistate 0.7.1.2, pqueue 1.3.2.3
13:38:11 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
13:38:56 <kamyar> geekosaur: Yes I now! I have made a dylib (so in mac) from the cpp source! But I noticed a sample that mixes C code with the haskell in the FFI docs
13:39:00 <geekosaur> sqooq, so, take sepBy1 first as it's the conceptually simpler (and as the code shows, you can implement sepBy on top of sepBy1)
13:39:14 <sqooq> it does p
13:39:27 <sqooq> then does many dos of p then sep
13:39:33 <geekosaur> sqooq, it parses one item, it then tries to parse the separator. if that fails then it returns whatever it has accumulated
13:39:54 <geekosaur> if it succeeds then it parses another item, then tries to parse a separator again
13:40:21 <sqooq> when you say "then tries" you mean on the next char right
13:40:25 <geekosaur> and, it's sep then p not p then sep
13:40:50 <geekosaur> yes
13:41:07 <geekosaur> basically, any time it can parse a separator, it can then parse another item
13:41:21 <sqooq> like if it were char '[' as p and char ']' as sep on the input "[][][]" then it would return the whole thing
13:41:31 <geekosaur> many (do {sep; p})    which can also be written    many (sep >> p)
13:42:24 <geekosaur> sqooq, actually, with that one it will fail
13:42:47 <geekosaur> because when it sees the final ], matched by the separator parser, it will expect to parse another [, matched by the item parser
13:42:57 <geekosaur> so the string will always have to end with a [
13:43:06 <sqooq> o
13:43:25 <sqooq> "[]]][" would return the whole thing?
13:43:37 <geekosaur> no, they have to alternate
13:43:40 <sqooq> ok
13:43:43 <sqooq> that's what I thought
13:43:51 <sqooq> so the do block does sep first then p
13:43:54 <sqooq> over and over
13:44:03 <sqooq> the first line is only there so that it starts with p
13:44:05 <jchia_1> Question about optparse-applicative: I have a data type 'Foo (Maybe a) (Maybe b)'. How do I make a Parser Foo that rejects Foo Nothing Nothing?
13:44:06 <geekosaur> right. until it can't parse a sep
13:44:15 <sqooq> by first line i mean a  <- p
13:44:31 <sqooq> ok that was literally my initial understanding
13:44:35 <sqooq> so I guess I did understand it lmao
13:44:45 <sqooq> it's just not useful for what I'm doing I don't think
13:44:59 <jchia_1> Concretely, the (Maybe a) & (Maybe b) are from optional options, but I disallow them both being missing.
13:45:01 <geekosaur> it is, but not with the examples you gave
13:45:21 <geekosaur> think of p as the parser that recognizes either a bracketed list or a single number; and (many space) as the separator
13:45:42 <sqooq> ah you're right
13:45:51 <sqooq> couldn't I also use token somehow to do it as well?
13:46:26 <sqooq> token just sucks up all the space
13:46:29 <sqooq> at the end
13:46:29 <geekosaur> you could, but you'd have to do more work
13:46:36 <sqooq> i see
13:46:52 <sqooq> ok I'm taking a break
13:46:55 <geekosaur> actuallu the space combinator is what you want already, I was thinking of "space = char ' '"
13:47:01 <sqooq> I've been at this endlessly for what feels like days now
13:47:07 <geekosaur> so the separaot is the existing `space`
13:47:34 <sqooq> yeah
13:47:47 <sqooq> bracket `sepby` space, yah?
13:48:45 <sqooq> any last words
13:48:47 * hackagebot gotta-go-fast 0.1.2.0 ‚Äì A command line utility for practicing typing ‚Äì https://hackage.haskell.org/package/gotta-go-fast
13:48:47 * hackagebot DOH 0.1.1.1 ‚Äì Complete API bindings for DigitalOcean API V2 ‚Äì https://hackage.haskell.org/package/DOH
13:53:10 <geekosaur> not really, and I have to head up to the store soon (limited to wealking so it'll be a few hours)
13:53:22 <sqooq> geekosaur, wait
13:53:24 <sqooq> one last question
13:54:17 <sqooq> will an if expression in a do block still consume the first item if i did char '['
13:54:24 <roee30> @pl 3
13:54:24 <lambdabot> 3
13:54:39 <sqooq> or here:     do if char '[' then bracket ...
13:54:56 <sqooq> also can the else be the next line in the do?
13:55:21 <sqooq> maybe I should just write it with pure >>= and >>'s
13:55:23 <geekosaur> sqooq, it should be indented
13:55:29 <kamyar> Another related question:
13:55:32 <geekosaur> (or see the DoAndIfThenElse extension)
13:55:35 <kamyar> OSRM project is written in C++
13:55:40 <kamyar> the header files are hpp
13:56:02 <kamyar> Can I use GHC pragma #INCLUDE for hpp files?
13:56:05 <sqooq> geekosaur,  do { if char '[' then bracket ... ; ... } ???
13:56:09 <kamyar> Is INCLUDe pargma deprecated?
13:56:15 <Rotaerk_> hmm if I want to test out a module in ghci, but it depends on some other modules, is there an easier way to do it besides ghci <module1.hs> <module2.hs> etc
13:56:16 <kamyar> What should I use instead?
13:56:29 <Rotaerk_> as in, I don't want to build the entire project, just that module and what it depends on
13:57:02 <geekosaur> kamyar, in the old days ghc compiled to C code and #include could do something. these days it does not (compiles directly to asm or LLVM IR) and there is nothing for #include to include to
13:57:49 <kamyar> geekosaur: What about replacement? How can I use hpp files?
13:58:15 <geekosaur> kamyar, you need to be able to call code as from assembly language. you cannot use include files at all
13:58:25 <geekosaur> include files only do something in C/C++
13:58:49 <kamyar> geekosaur: I have to convert some structs into Haskell then
13:59:02 <geekosaur> you would have to anyway
13:59:12 <kamyar> geekosaur: The problem is that I was not able to convert hpp files using c2hsc
13:59:19 <geekosaur> that is why I pointed you to hsc2hs and c2hs earlier
13:59:37 <geekosaur> just #include-ing a file does not automagically convert everything therein to Haskell
13:59:40 <kamyar> geekosaur: Does c2hs suppoer c++?
13:59:46 <sqooq> ugh I really don't think if statements in do blocks is gonna work
13:59:53 <sqooq> or i'm still missing something
14:00:16 <geekosaur> C and C++ are ambiguous with respect to pointers; you can't autmatically translate anything involving a pointer since the translation is different based on whether it is *used* as a pointer or as an array
14:00:20 * roee30 a
14:00:36 <ab9rf> kamyar: not directly, but you can bind to C++ code through any "C" externs
14:00:48 <geekosaur> (c2hs will do so but makes assumtpions that are sometimes false. gtk2hsc2hs is a fork that knows how gtk handles the situation, but again can;t handle the generl case)
14:01:15 <ab9rf> you won't be able to export methods 
14:01:55 <geekosaur> kamyar, binding to C++ directly can only be done by C++, and even that is questionable; ther is no guarantee of compatibilityt between different C++ implementations, although ABI compatibility is strongly recommended by various ABI standards
14:02:09 <geekosaur> you need `extern "C"` wrappers
14:02:32 <kamyar> geekosaur: I have compiled the code into dynamic library 
14:02:56 <ab9rf> kamyar: you can only bind to functions that are declared extern "C"
14:02:58 <kamyar> geekosaur: Can u please take a look at OSRM code and tell me if it is possible to use it in haskell as FFI?
14:03:11 <geekosaur> sigh
14:03:21 <sqooq> aw poor geekosaur
14:03:24 <ab9rf> binding to global variables that are of a class type is likely to be Difficult.
14:03:29 <geekosaur> have you determibned I don't need to go to the store today for me?
14:03:37 <ab9rf> geekosaur: heh
14:03:50 <geekosaur> since I alrady said that, but apparently that didnt matter
14:03:58 <sqooq> lmao
14:04:33 <ab9rf> geekosaur: reminds me of a commercial i've been seeing lately where the guy asks his neighbor to get his roof fixed for him because he's too lazy to do it himself
14:05:08 <kamyar> ab9rf: I did my best with no luck! I am not lazy!
14:05:59 <roee30> anyone have an idea for an improvement on ((((map fst . init) .) .) .) scanr ?
14:06:09 <ab9rf> kamyar: i didn't say that you're lazy, just that hte guy in the commercial is
14:06:26 <roee30> @pl ((((map fst . init) .) .) .) scanr 
14:06:26 <lambdabot> (((map fst . init) .) .) . scanr
14:07:08 <ab9rf> congratulations, you've achieved pointlessness
14:07:22 <ab9rf> i have no idea what that does
14:08:22 * hackagebot columbia 0.1.0.1 ‚Äì Enhanced serialization for media that support seeking. ‚Äì https://hackage.haskell.org/package/columbia
14:08:50 <roee30> @pl g func initial xs = map fst $ init $ scanr func initial xs
14:08:50 <lambdabot> g = (((map fst . init) .) .) . scanr
14:09:04 <roee30> that's the pointful equivalent
14:09:16 <ab9rf> @unpl ((((map fst . init) .) .) .) scanr
14:09:16 <lambdabot> (\ x x0 x1 -> map fst (init (scanr x x0 x1)))
14:09:48 <ab9rf> still don't understand what it does
14:10:01 <ab9rf> well, i do, but i don't undersatnd how it's _useful_
14:10:13 <roee30> it justs does scanr, than drops the first element and take the first element of those tuples
14:10:23 <ab9rf> last element
14:10:23 <roee30> it became useful to me on euler #24
14:10:25 <ab9rf> not first
14:10:31 <roee30> yeah
14:12:26 <sqooq> eureka!
14:14:21 <kadoban> roee30: I remember that one. Are you generating all permutations and then seeing? You should see if you can figure out how to do it for the 10^16th permutation of [0 .. 20] or something.
14:15:16 <ReinH> I wouldn‚Äôt want to make that point free, but eliding xs and using composition is a bit better.
14:18:26 <ab9rf> most euler problems are best thought of as mathematical problems raht erhtan programming problems
14:19:05 <kadoban> Most of them I know how to solve are more interesting as algorithms/combinatorics/number theory/etc. at least.
14:19:15 <ab9rf> in most cases, the naive solution is too resource-intensive, and finding a quick solution requires examining the problem mathematically to identify a constraint that can be exploited to reduce the search space
14:20:02 <ab9rf> nothing wrong with euler problems, but they'r enot really "programming" problems
14:20:54 <kadoban> Yeah, they're not typically very programmy. I kind of cringe when people use them to learn a language, especially if they're not that interested in math.
14:21:22 <kadoban> I should do more of them though ...
14:22:27 <roee30> I like math and therefore they were very useful for learning haskell
14:23:19 <kadoban> I used hackerrank to IMO increase my haskell skills quite a lot, but it's not really something I'd recommend to everyone.
14:23:42 <kadoban> Which is just to say, ya it works for some, but I don't think it's generally good.
14:23:44 <phadej> all of them have "obvious" imperative solution, but discovering the functional one is a real puzzle
14:23:55 <phadej> euler problems, i mean
14:24:36 <kadoban> phadej: Not sure that's really true. The early ones it might be more obvious, but later ones it gets computationally intensive to do any kind of "obvious" solution, imperative or functional.
14:24:43 <roee30> discovering the most efficient functional ones
14:25:09 <phadej> kadoban: well, let's say "obvious" for decent competitive programmer :)
14:27:31 <kadoban> phadej: That sounds much more likely to be true. Though my sense is that they use slightly different sets of knowledge from most of the rest of competitive programming. (aka I'm 1/2way decent at competitive programming and still fairly bad at project euler)
14:31:50 <statusbot> Maintenance update: Hackage restarting now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5980f23a383934bd050005d6
14:36:53 <danilo2> Hi guys! Is readIORef optimized completely during compilation or does it provide any performance overhead (even slight)? I just want to keep "a memory address to a Vector" that I could share between threads. These threads will then often readthisIORef (but not write to it)
14:37:03 <statusbot> Maintenance update: Hackage operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5980f23a383934bd050005d6
14:38:01 <Cale> danilo2: why an IORef then?
14:38:15 <Cale> danilo2: If you're never going to write to it, why not just use the Vector itself?
14:39:39 <danilo2> Cale: Ok, I oversimplified the problem for this question :) Anyway I'm just wondering if IORefs are completely cut off during compilation time (I suspect not), however GHC might have some magic
14:40:05 <Cale> I don't know what you mean by "cut off"
14:40:28 <danilo2> Cale: I'm sorry, I meant "optimize away"
14:41:02 <davean> "eliminated" might be a better word?
14:41:05 <sbrg> wouldn't the runtime just share the vector internally between the threads if it's passed to them and never modified? 
14:41:49 <Cale> Well, if you readIORef multiple times, it's going to actually dereference the pointer multiple times.
14:41:59 <Cale> But it's essentially just a pointer
14:43:09 <Cale> Also, evaluation done to the contents of the IORef by any thread will be available to any thread which had read that IORef, even if they read it before (because they would have read a thunk)
14:43:28 <danilo2> Ok, I really oversimplified it. Here is full problem: I've got a "smart vector" - a datatype containing mutable vector and list of free keys. If you release a key, it is rmembered. If you need more than vector lenght, it is automatically resized. I need to pass this structure between threads, so using IORef would be a natural choice, and now (writing ...)
14:44:28 * hackagebot butcher 1.1.0.1 ‚Äì Chops a command or program invocation into digestable pieces. ‚Äì https://hackage.haskell.org/package/butcher
14:44:29 <danilo2> (...) and now these threads will often access the vector. I'm just wondering if I will benefit from reading the IORef once and then operate on the mutable vector or I can use utility functions that each time read this IORef
14:45:05 <davean> You will be very slightly better off reading it once
14:45:17 <Cale> The difference is going to be small, but it will be there.
14:45:36 <danilo2> Cale: so in fact your answer is what I was asking for. If that is a pointer and I will be dereferencing it, than yeah, as davean said, it would be slightly better to do it once
14:45:50 <danilo2> Cale, davean : great, thank you guys! :)
14:45:54 <Cale> GHC will never remove readIORef operations because some other thread may have written the IORef, so it has no way of knowing that the value will be the same on the next read.
14:46:05 <davean> you can't optimize away IORef because its explicitely external
14:46:33 <danilo2> Cale: sure, that makes sense. I was just wondering if it is a pointer or it could be an memory address (which would not bring any overhead then(
14:46:35 <davean> which actually raises a question - why is it in an IORef if its mutably internally?
14:46:52 <davean> danilo2: a pointer *is* a memory address
14:47:16 <Cale> danilo2: It really sounds like you shouldn't need the IORef here
14:47:33 <Cale> danilo2: Passing around a mutable vector would work too
14:48:06 <ezyang> weeeell 
14:48:07 <danilo2> Cale: sure, but sometimes these threads would need to resize the vector and update the outer strucutre, writing this IORef, but it will be very rare case
14:48:19 <Cale> ahh, right
14:48:21 <ezyang> Haskell doesn't actually have an IORef memory model, so one has to be careful about claims like this 
14:49:28 <Cale> ezyang: Worried about GHCJS?
14:50:01 <ezyang> GHCJS is gonna be totally sequentially consistent, no problem :o) 
14:50:17 <danilo2> davean: yeah, but it is a "pointer" in C meaning? 
14:50:36 <danilo2> davean: if so I was rather asking if we could have IORefs that behave like C references
14:51:07 <__monty__> Hi, working on my understanding of monads, more specifically their sequencing properties. I was thinking if the second argument to bind doesn't force evaluation of it's argument then there's no sequencing property at all, i.e. the value passed along could remain a thunk indefinitely. If this were the whole truth then >> would be somewhat nonsensical though. Where am I taking a wrong turn, so to speak?
14:51:29 <danilo2> ezyang: could you tell more what you mean ?
14:52:25 <roee> isn't that implementation dependent?
14:52:27 <phadej> __monty__: do you have something like:
14:52:29 <phadej> > Just undefined >> Just 1
14:52:31 <roee> i mean instance dependent
14:52:32 <lambdabot>  Just 1
14:52:34 <phadej> in mind?
14:52:36 <danilo2> __monty__: Monads do not have any "sequencing" properties. They are great to make code look like sequence operations and they are grrat to make it behave so, but you can easily create monad that does not make any sequencial operations
14:52:52 <ezyang> like, sure, GHC isn't going to optimize the readIORef away because it could have changed 
14:53:16 <phadej> or maybe
14:53:18 <ezyang> but your architecture can totally decide to make the write from the other thread visible or not, depending on its memory model. Or reorder it. Or something 
14:53:20 <roee> > scanl1 (*) [1..10]
14:53:22 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
14:53:28 <phadej> > Right undefined >> Left "error"
14:53:30 <lambdabot>  Left "error"
14:53:37 <phadej> > Right undefined >> Left "error" >> Right undefined
14:53:39 <lambdabot>  Left "error"
14:53:47 <phadej> it's sequenced
14:53:57 <roee> what you are demonstrating is not a Monad property, it's a haskell property
14:54:17 <danilo2> ezyang: of course, thanks for pointing it out
14:54:22 <glguy> We can't determine that the Monad class requires sequencing by showing a specific example where sequencing happens
14:55:03 <roee> "undefined" wasn't evaluated because you didn't write code that requires it to be
14:57:24 <phadej> I mean the "structure" of monad is evaluated (you get Left at the end), even the values in Right stay unevaluated
14:58:40 * hackagebot monad-mock 0.1.1.2, selda 0.1.10.0, selda-postgresql 0.1.6.0, selda-sqlite 0.1.6.0
14:58:40 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
14:59:57 <__monty__> What, danilo2 said is what I thought. I was mostly wondering about this because I started thinking from "IO was implemented with monads because of sequencing." Is that really the reason?
15:00:32 <dolio> No.
15:00:51 <danilo2> __monty__: do you know how IO is implemented?
15:01:55 <roee> the Right value wasn't evaluated because no function tried to
15:02:05 <roee> it wasn't printed to the screen, nothing was done with it
15:03:20 <dolio> There were I/O functions in Haskell that would give rise to the Monad structure before the type class was even defined.
15:04:44 <rntz> dolio: is that really true?
15:04:58 <dolio> Yes, of course.
15:05:04 <dolio> Monad wasn't in the report until 1.3.
15:05:22 <Tuplanolla> @google io is not a monad
15:05:25 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
15:05:28 <rntz> I thought the pre-Monad IO thing Haskell had was more ad-hoc, and had something to do with a lazy string as input producing a string of commands
15:05:28 <Tuplanolla> Here's some related reading.
15:05:35 <rntz> which is not a monadic interface
15:06:00 <Tuplanolla> They develop it beyond the list-to-list idea there.
15:06:07 <phadej> IO doesn't sequence "in the same way" either
15:06:10 <phadej> > return (undefined :: ()) >>= const (return 42) :: IO Int
15:06:12 <lambdabot>  <IO Int>
15:06:17 <phadej> that will print 42
15:06:30 <phadej> it sequences actions, not evaluation
15:06:44 <phadej> at least in GHCi :P
15:07:23 <phadej> works compiled too, so no magic...
15:07:37 * ski thinks `Monad' (as opposed to particular instances of it) expresses a kind of (conceptual) sequencing
15:07:43 <__monty__> danilo2: No, only the threading the world around hand wavy explanation. I do understand you do nothing but assemble IO actions and these represent what'll happen at runtime.
15:07:58 <danilo2> __monty__: do you know how State monad works ?
15:07:59 <dolio> rntz: Go find the Haskell 1.2 report, then find section 7.5: Continuation-based I/O
15:08:37 <dolio> Then consider all the 'FooCont' types, and imagine that they are instead more like 'Cont Foo'.
15:09:19 <dolio> And then consider 'type IO a = FailCont -> Cont a -> Dialogue'
15:09:37 <rntz> dolio: hm, ok. looking at that now.
15:10:06 <__monty__> danilo2: No. Have only really used maybe, list, random and parser combinators (and IO).
15:10:07 <dolio> And check out how many types in figure 15 would be '... -> IO T'.
15:11:07 * hackagebot propellor 4.7.6 ‚Äì property-based host configuration management in haskell ‚Äì https://hackage.haskell.org/package/propellor
15:11:21 <danilo2> __monty__: If youre using State monad, like so `foo :: State Int m Int; foo = do x <- get ; put (x + 1) ; return $ 2 * x` then you are "accessing" a variable of type Int that is in "local state around the function"
15:12:17 <danilo2> __monty__: what state really does is it transforms logically the funciton to one that have more arguemnts, so you can logically see `foo` as `foo :: Int -> Int; foo x = let a = x + 1; in 2 * x` 
15:13:29 <danilo2> if you for example then use `bar = foo >> foo >> foo` then you can thin k aobut it like about `bar x = let x' = x + 1; x'' = x' + 1; x''' = x'' + 1 in x'' * 2`
15:13:34 <__monty__> 2*a, right?
15:13:45 <__monty__> Oh, no.
15:13:52 <danilo2> __monty__: because you pass the arguments from one foo to another
15:14:41 <danilo2> __monty__: what I told you is how you can logically think about State If you read how it is implmented and how the (>>=) is implemented for it, you will see that what I told you now is actually true
15:14:53 * ski . o O ( `foo :: Int -> (Int,Int)' )
15:15:04 <__monty__> Ok, so in that case x''' would not be evaluated? And any sequencing just depends on the implementation of bind?
15:15:07 <danilo2> __monty__: IO is implemented just as `State RealWorld` (in fact it is a special State, but dont bother with it now)
15:16:13 <danilo2> __monty__: so if you are talking `print "hello" >> print "world"` haskell desugares it to `w = someRealWorldValue; w' = print' "hello" someRealWorldValue; w'' = print' "world" w'` and so one
15:16:29 <danilo2> so RealWorld is just a data that represent what io soutside of the program
15:16:35 <danilo2> go google it :) 
15:17:12 <ski> (this is how Clean and Mercury handles I/O, by explicitly passing around states of the world)
15:17:20 <danilo2> __monty__: everything would be evaluated when needed. when executiing main, haskell tells that it needs to evaluate the real world, so all prints will be evaluated because they modify "realworld" :)
15:17:33 <rntz> dolio: ok, I see what you mean
15:19:02 <dolio> rntz: The other thing to think about is when you see examples like 'readFile fn failure (\s -> ...)' with explicit continuation passing, you can instead use Cont (the monad) to package up continuation-passing functions into 'actions' where the monadic bind corresponds to doing the manual continuation construction.
15:19:03 <rntz> it lacks >>=, but they seem to basically inline the appropriate definition of >>= in their examples of using continuation-based IO.
15:19:09 <__monty__> I'm still having trouble with >>. a >> b = a >>= \_ -> b, how would a ever be evaluated for this?
15:19:09 <dolio> (You may have already known that.)
15:19:11 <rntz> and you could define a >>= over the type (IO a = FailCont -> (a -> Dialogue) -> Dialogue), I guess.
15:20:02 <dolio> And having two continuations, one for failure gives you MonadPlus/Exception structure.
15:20:03 <ski> __monty__ : typically `>>=' there would force the left argument
15:20:24 <ski> @src Maybe (>>=)
15:20:25 <lambdabot> (Just x) >>= k = k x
15:20:25 <lambdabot> Nothing  >>= _ = Nothing
15:20:30 <danilo2> __monty__: look at my state description
15:21:08 <rntz> (action >>= f) fail succ = action fail (\x -> f x fail succ)?
15:21:13 <ski> ("evaluating" `a' (an action) is different from "executing it", though)
15:21:31 <danilo2> __monty__: think about `a >> b` like about `(_, rw') <- a' rw; (_, rw'') <- b' rw'` 
15:21:50 <dolio> rntz: Yeah, something like that.
15:21:53 <danilo2> __monty__: where `rw` are realWorlds values passed silently between functions when you desugar how state works
15:24:57 <dolio> type IO = ReaderT (IOError -> Dialogue) (Cont Dialogue)
15:25:00 <dolio> Or something like that.
15:26:14 <dolio> Environment passing exception handler plus continuation passing.
15:27:15 <dolio> And the advantage of that API (which I think it says) is that it's easier to not write deadlocks than the 'real' API underlying it.
15:27:31 <__monty__> Most of these things I've read before. I think I just need more time to percolate the information.
15:27:57 <danilo2> __monty__: I was just about to say that. Go sleep with it and think about it. It will make much more sense in a while :)
15:28:11 <__monty__> Thanks though. I'll definitely think about more than just IO.
15:28:19 <ski> @unmtl ErrorT IOError (Cont Dialogue) a
15:28:19 <lambdabot> (Either IOError a -> Dialogue) -> Dialogue
15:28:40 <dolio> Oh yeah, that's better, actually.
15:28:45 <danilo2> __monty__: if you want ot understand it ocmpletely
15:28:54 <dolio> Duh.
15:28:56 <ski>   (IOError -> Dialogue) -> (a -> Dialogue) -> Dialogue  -- unpacking the `Either'
15:29:14 <danilo2> __monty__: please read this. VERY carefully, line by line, test it, try all the code there and after you carefully read it, you will understand everything: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
15:33:23 <dolio> Now, the point of the continuation passing is to package things up in a way so that you can't write tries to see the results of an operation you've said to happen yet.
15:33:37 <dolio> Which is a sort of sequencing.
15:35:08 <dolio> But recognizing that continuation passing is a monad just gives you an arguably nicer way to write down your continuation passing code.
15:35:54 <__monty__> danilo2: I will. (IO is not a monad as well.) I feel like I've had a better grasp of this before but I've somehow lost it.
15:36:13 <dolio> And factor things out in a way they didn't think to in Haskell 1.2.
15:36:17 <danilo2> __monty__: IO is monad
15:36:39 <danilo2> __monty__: State is monad as well
15:38:00 <__monty__> The blog post.
15:38:20 <__monty__> Anything implementing class Monad m is a monad of course.
15:38:33 <danilo2> davean, Cale, hmm, I've got one additional question. If IORef is just memory address (it is right?) why reading this memory address would give us any performance slowdown (even slight)? Is it memory address or it is a "pointer" in the meaning of C pointers? If the later, why it is not just a memory address ?
15:38:34 <Tuplanolla> It says `IO` doesn't have to be a monad, but it is helpful for it to be, __monty__.
15:40:42 <__monty__> I'll still read it. I need to rehearse the concept so I won't lose the concept again.
15:41:34 <Cale> danilo2: C pointers are just memory addresses, are they not?
15:41:56 <vimalloc> I 'finished' my first non-trivial haskell program, a brute force solver for the http://www.puzzle-bridges.com/ game! (finished in quotes, cause I'm sure I'll spend a lot more time tweaking stuff) :P
15:42:12 <Cale> danilo2: I'm not sure what distinction you're making here.
15:42:23 <vimalloc> I would love any feedback if anyone in interested in looking at it: https://github.com/vimalloc/bridges-solver/blob/master/bridges/bridges.hs
15:43:44 <Tuplanolla> I reckon you could cut it in half, vimalloc.
15:43:57 <dolio> They might not actually be memory addresses, but you'd have to be a real C afficionado to know.
15:44:34 <vimalloc> Tuplanolla: heh, probably. Just learning functional programming, still have a lot of stuff to wrap my head around I imagine
15:44:54 <Tuplanolla> For example `islandValueInt` is just `succ . fromEnum`, vimalloc.
15:45:15 <dolio> Like, can you do something with pointers where everything involved stays in registers, and thus doesn't have a 'memory address'?
15:45:24 <isd> vimalloc: line 61, s/insure/ensure/
15:45:34 <kadoban> vimalloc: IslandValue seems a little funny.   data IslandValue = IslandValue Int would seem a little more obvious to me.
15:45:43 <vimalloc> Tuplanolla: thx :)
15:45:58 <vimalloc> isd: Spelling will always be the thing that gets me :P Thanks!
15:46:02 <kadoban> (or it can be a newtype)
15:46:03 <davean> dolio: pointer chasing gives EVERYTHING a slowdown, ram access is slow
15:46:15 <davean> danilo2: sorry, I mean you not dolio 
15:46:38 <davean> dolio: yah, like the C compilation to LISP machines!
15:46:42 <davean> dolio: I love that one
15:46:50 <dolio> Heh.
15:46:54 <vimalloc> kadoban: I thought about that initially. I thought it made sense this way because it can only be between 1 and 8, and this way it is enforced by the type system instead of runtime checks when creating the islands
15:47:06 <vimalloc> Do you think it would still make more sense to have it be an int?
15:47:13 <davean> but I also have read the C spec, and related. I wasn't even going to TRY to explain how danilo2 is confused about C terminology
15:47:27 <danilo2> Cale, davean: Of course, I was just refering to C wording and after some thinking about it, it of course makes sense. I was just looking for having "C-like references" in haskell, but in fact reference is just an aliast for something we already loaded from ram
15:48:11 * ski idly recalls the den. sem. section of R‚ÅµRS, associating "location" identifiers with pairs and procedures
15:48:20 <Tuplanolla> If only we had `Word3`, vimalloc...
15:48:21 <isd> vimalloc: I would just make it an Int. But, if not, I would at least leverage toEnum/fromEnum instead of writing out every case.
15:48:26 <davean> Its only already loaded if its in a register ... or perhaps in a cache ... I don't think you understand the machine you are running on danilo2
15:48:26 <kadoban> vimalloc: Well, you can still have really just as many checks if you just don't use the IslandValue constructor itself anywhere except one place, have a islandValue :: Int -> Maybe IslandValue function that does that same check.
15:48:50 <kadoban> vimalloc: Oh like the intToIslandValue one
15:49:02 <vimalloc> Tuplanolla: /me hoogles word3
15:49:22 <isd> vimalloc: See also Word8/Word16/Word32/Word64
15:49:23 <vimalloc> kadoban: Right on. Thanks for the advice! :)
15:49:31 <kadoban> You can enforce that you don't accidentally use the IslandValue constructor anywhere else by putting it in its own module and not exposing it for example, if you're worried about that.
15:49:39 <Tuplanolla> Our puny register machines are too limited for such things, vimalloc.
15:49:46 <isd> But yeah, no 3 bit numbers
15:49:49 <vimalloc> Ah, I understand word3 now. Neat :)
15:50:57 <vimalloc> kadoban: That is my plan for the next step, want to build a part that grabs puzzles from the internet and uses this module to sovle them (only exporing toString, solve, and createGame)
15:52:04 * hackagebot postgrest-ws 0.4.0.0 ‚Äì PostgREST extension to map LISTEN/NOTIFY messages to Websockets ‚Äì https://hackage.haskell.org/package/postgrest-ws
15:52:23 <kadoban> vimalloc: islandToString is begging for factoring out that ANSI escape stuff
15:52:26 <evincar> Hey everyone, I've submitted a GHC proposal and I'd like to gather feedback on it: https://github.com/ghc-proposals/ghc-proposals/pull/64
15:53:03 <evincar> It concerns "inline bindings", allowing "do f (<- x) (<- y)" to be desugared to "do _x_ <- x; _y_ <- y; f _x_ _y_"
15:53:05 <isd> Yeah, islandToString could easily be a one-liner
15:53:25 <vimalloc> kadoban: Good call. Really, thanks for all the advice :)
15:53:35 <ReinH> davean: also, IORefs are lazy.
15:53:48 <evincar> Specifically I'd like to hear from beginner-intermediate users of Haskell about that proposal
15:54:00 <davean> ReinH: just like me
15:54:18 <evincar> Because part of the goal is to simplify things for people new to Haskell and still getting comfortable with monadic/applicative code
15:54:43 <ReinH> Point being, an IORef Int is not at all guaranteed to point to an Int stored in memory somewhere.
15:55:05 <isd> islandToString (Island n _) = "\ESC[94m\ESC[1m" ++ show (fromEnum n + 1) ++ "\ESC[0m"
15:55:42 <ReinH> I like Idris's approach to inline monad actions.
15:55:43 <kadoban> vimalloc: Really looks pretty good in general, especially for a first program. I don't see much else obvious
15:55:59 <vimalloc> sweet. Thanks! :)
15:57:09 * hackagebot word-wrap 0.1.2 ‚Äì A library for word-wrapping ‚Äì https://hackage.haskell.org/package/word-wrap
15:58:02 <Tuplanolla> I'm not sure adding more syntax is the way to go for simplifying code, evincar.
15:59:06 <danilo2> davean: I know about registers, cache and ram access. But you are right, I confused C wording here, especially how C references are implemented and I was somehow sure that C references refer to objects already loaded, without the overhead pointers have, but surely that was my mistake
15:59:46 <ReinH> What... What is a reference that isn't a pointer?
16:00:01 <evincar> ReinH: This proposal is very similar to the Idris !-notation
16:00:03 <davean> ReinH: In C++ ... but in C?
16:00:24 <davean> evincar: I think its a lot longer and uglier, and I'm not sure why one doesn't just use applicative here?
16:00:29 * Tuplanolla digs up N1570.
16:00:30 <davean> I haven't read the entire thing though
16:00:49 <ReinH> I personally would rather use idiom brackets.
16:01:04 <evincar> Tuplanolla: Ordinarily I would agree, but I feel the benefits outweighs the costs in this case
16:01:49 <Tuplanolla> I don't feel strongly either way, evincar.
16:02:25 <evincar> davean: My reasoning is that applicative notation is pretty heavy on symbols and unfamiliar to people coming from other languages, so it's not always a clear win just to avoid names
16:02:39 <davean> evincar: This looks like it just adds more symbols to me
16:02:50 <davean> So you're actually increasing the burden
16:03:26 <evincar> davean: It adds one (in an unused spot in the grammar) but the difference is that you can use it uniformly, instead of mixing <$>/<*>/join/>>=/>=>
16:03:30 <nshepperd_> I don't think adding syntax to make do notation look more like traditional imperative languages really helps beginners in the end
16:03:33 <isd> (a) I agree the the things mentioned in the pr about obscuring the monadic changes to evaulation order; idris doesn't have this issue because it's strict
16:03:51 <nshepperd_> It's just more stuff to learn
16:04:02 <kadoban> vimalloc: It's weird to me that even the hard puzzles have so many "forced" choices. I guess it's like sudoku in that you just do those first and then you still have a bunch of unforced constraints.
16:04:15 <isd> (b) I like it in idris as a convienience, but definitely *not* because it makes it easy to learn -- it's nicer to write, but it's one more bit of sugar you have to understnad.
16:04:18 <isd> *understand
16:04:46 <isd> My usual pedagogical approach is to explain everything in terms of the desugared operators, and then say "this is just a shorthand for that"
16:05:05 <isd> So I tend to think sugar is counterproductive from a pedagogical standpoint
16:05:15 <evincar> isd: That's fair, I might just want it because I'm *not* a beginner and I'm trying to rationalise it :P
16:05:17 <nshepperd_> You might have beginners imagining that (<- foo) is a way to dereference variables or something, and being surprised by things executing twice
16:05:59 <davean> what nshepperd_ is saying, I would like to echo 
16:06:37 <evincar> Good points
16:07:07 <vimalloc> Kadoban: I think the hard puzzles, at least on that site, aren't actually that bad. There are a few where you get to a point where you really need to think through them, but for the most part they aren't bad. Still a good time kill though :)
16:07:28 <evincar> As I mentioned in the comments on the PR, I think there's a lot of bang per buck to be had by allowing things to be syntactically inlined
16:07:54 <evincar> The examples I gave were string literals instead of pointers to the data segment, and lambdas instead of top-level functions
16:07:55 <ski> evincar : needs explicit delimiter, distinct from `do', imho
16:08:01 <MarcelineVQ> evincar: interesting, is there a reason this is restricted to having to be used in a do block? I've read the part about do desugaring but am unsure about whether that's related to my question
16:08:04 <isd> Also, I think the arrow is actually a lot more visually heavyweight than idris's !
16:09:11 * ski has been pondering something a bit like this, for years ..
16:09:17 <evincar> ski: What would you propose instead? I like "do" because it makes it easier to define the sugar as "do { f (<- x) }" <=> "do { _x_ <- x; f _x_ }"
16:09:51 <hpc> how is that better than f <$> x?
16:09:54 <evincar> MarcelineVQ: I figured it was a clear way to define the scope of it, rather than expressing it as "f (<- x)" <=> "x >>= \_x_ -> f _x_"
16:10:03 <ski> i care more about abstract than concrete syntax
16:10:07 <ski> hpc : nesting
16:10:36 <MarcelineVQ> I suppose it also removes syntax clash with PatternGuards
16:10:36 <evincar> hpc: That would be "f =<< x", the point is that you don't need to select different combinators based on which things have effects, you just mark the things that have effects with one symbol "<-"
16:11:00 <ski> evincar : exactly
16:11:44 <MarcelineVQ> or I guess the parens would do that anyway
16:11:51 <evincar> isd: The arrow is definitely heavier; I only chose "<-" because it's mnemonic (just move the "<- rhs" inline) and not taken (unlike "!", which is already a valid operator)
16:13:59 <evincar> ski: I was also in favour of an "ado" keyword for ApplicativeDo, rather than the implicit version we have now, so I'd be fine with delimiting inline bindings with a different sort of block than "do"
16:14:07 <EvanR> ski: not only is concrete syntax superficial... it seems to be stuck on grid-of-ascii technology
16:14:15 <EvanR> which is more and more annoying me
16:14:58 <evincar> The limitations of ASCII (and input methods for Unicode) frustrate me to no end as a language designer
16:15:27 <EvanR> exhibit 1. ->
16:15:41 <evincar> In a language I'm working on, I allow the real symbols, with ASCII fallbacks for everything
16:16:05 <ski> (in my version,  `‚åúf ‚åûact‚åü‚åù' becomes `f <$> act', while `‚åúlet x = ‚åûact‚åü in ‚åûf x‚åü‚åù' becomes `do x <- act; f x' / `act >>= \x -> f x')
16:16:14 <evincar> EvanR: When teaching beginners programming, I've had them get confused by "->" because it's not a real arrow ("Minus greater than? What does that mean?")
16:16:34 <EvanR> should really be http://i.imgur.com/e6YGtBm.png
16:16:49 <EvanR> evincar: lol
16:16:58 <MarcelineVQ> use ligatures, have your cake and throw it out with the bath water
16:17:09 <evincar> Bahaha
16:17:40 <hpc> now i want to see a language where you write one long line of whitespace
16:18:01 <evincar> I tried using fonts with programming ligatures for a while, but IMO they went too far, and failed to preserve width, so rectangular editing was out
16:18:05 <hpc> and use zalgo characters to visually spell out the rest of your code further down
16:18:21 <hpc> the interpreter for the language renders it with webkit, then runs OCR
16:18:21 <evincar> As hackish as it is, the grid can be very useful for editing
16:18:24 <ski> evincar : "leading to code that‚Äôs potentially less stable under certain refactorings" is really bad, imho. you can take that as an argument for a separate (explicit) delimiter
16:18:40 <MarcelineVQ> I've had good experience with ligatures, good fonts, good lineup, but in the end they just didn't end up adding value
16:19:33 <evincar> Also different languages use the same di/trigraphs for different operators
16:20:10 <EvanR> trigraphs are a hilarious thing exactly like this
16:20:13 <jared-w> I like doing ligatures n stuff with the text editor, not the font. Visual code studio, emacs, vim, all support virtual replacement
16:20:15 <evincar> And ligatures don't respect context; I'd like "Foo<Bar>" to render with angle brackets but leave "Foo < Bar" as a less-than
16:20:38 <splanch> font lock but for ligaturing
16:20:51 <EvanR> in 2017 we are stuck on a grid of ascii. in 1972 C felt the need to account for typewriter double striking ... from 1930s
16:20:52 <jared-w> then you can just put your cursor over it to get the original symbol back
16:21:00 <evincar> Yeah, emacs font-lock supports replacement
16:21:17 <ReinH> Some emacs support ligatures. Mine does.
16:21:34 <jared-w> EvanR: that's because C was widely regarded as a horrible hack. The fact that it succeeded is testament to our stupidity and stubbornness, not to C's greatness :p
16:22:14 <EvanR> sometimes you see monospace called "typewriter font"... do kids these days even know what a typewriter is
16:22:15 <evincar> In discussions about character sets in programming languages I like to bring up the fact that you can type C on a typewriter from 1960
16:22:41 <evincar> Before that they tended not to have curly braces...although there's always di/trigraphs!
16:23:12 <koala_man> so you /can/ write C on a 1960s typewriter
16:23:48 <koala_man> and also in ISO646-NO/SE/DK
16:24:18 <evincar> Type it up and OCR it like a real programmer
16:24:24 * ski idly recalls using a (subset of) C compiler on a Commodore 64. they patched the built-in font, to add curly brackets, pipe, backslash
16:24:48 <evincar> So like APL :P
16:26:00 <davean> type? Write it out and toggle it in
16:26:08 <evincar> Anyway, anyone with specific comments/objections/amendments to that proposal should add their comment there
16:26:25 <evincar> Or even just thumbs-up/down
16:26:29 <isd> I don't feel like being able to use symbols not on a typical keyboard actually buys you much, and not actually having a key for things is... no.
16:26:54 <koala_man> Word should be able to replace TeX, but it turns out that wysiwyg is not a good model for typesetting
16:27:19 <evincar> InDesign isn't bad for wysiwyg typesetting
16:27:44 <EvanR> wiziwig... i now see is entirely backwards
16:27:44 <evincar> I think it *can* be done well
16:27:54 <EvanR> what you see is not what matters
16:28:13 <evincar> What does, the actual structure of the document?
16:28:22 <EvanR> what your intended meaning is
16:28:59 <EvanR> sure yeah, like you could rearrange the document many ways and show letters various ways and its the same thing
16:29:02 <ski> SPJ : "My main new realisation is that GHC already has something a bit like this, in the form of Template Haskell splices" -- hehe, quasi-quotation was one of my inspirations
16:29:23 <isd> I tend to get kindof annoyed when I see something like `data <Some greek letter> = ...` in a paper. It feels like they're just doing it to give it this air of mathiness, and it's not actually sensible for any pragmatic reason, it's just another crappy variable name.
16:29:51 <EvanR> single greek letters *is* more efficient than LongNames
16:30:02 <EvanR> when its understood
16:30:09 <Tuplanolla> "Funding names", isd.
16:30:38 <koala_man> I used Word on a uni project, and it was miserable. Merging changes was entirely manual, it looked awful because of one vs two linefeeds after headings, anything written by the guy from Azerbajan was excluded from the index because Word translated semantic tags and couldn't handle two languages in the same document
16:31:06 <EvanR> so word is like the photoshop of documents
16:31:12 <EvanR> only not as good as photoshop
16:31:35 <ski> evincar : oh, i see you noticed the problem with lambdas :)
16:31:35 <EvanR> the information just isnt present
16:31:59 <evincar> ski: Mhm, if the desugaring is allowed to cross lambdas, that is
16:32:09 <koala_man> it's like designing a website in photoshop. it looks just fine, but coloring text blue with underline doesn't mean it's a link
16:32:27 <isd> Tuplanolla: :P
16:32:33 * ski thinks it should not be allowed inside a lambda, without an intervening delimiter ..
16:32:34 <evincar> I used to implement sites given to me by designers as PSDs...
16:32:59 <evincar> Sometimes they really considered the semantic structure of things and it was easy
16:33:10 <koala_man> evincar: did anyone ever see it on your screen and were like "oh, looks like it's almost done!"
16:33:10 <evincar> Most of the time it was awful
16:34:00 <evincar> koala_man: Haha, thankfully no, I was doing remote freelance at the time (for beer money in college)
16:35:23 <koala_man> there was a Swing theme that made everything look like paper and pencil. the purpose was so that you could prototype a screen without people thinking it was almost ready
16:35:34 <evincar> Also I've been typesetting inline bindings as "(<- x)" or "<- x" but you could just as well do "<-x", then it's only one more character than ! (except for precedence issues requiring parens)
16:35:57 <evincar> "‚Üêx" with UnicodeSyntax
16:35:58 <koala_man> it added work for the developer to make it look worse than it had to, just to manage expectations
16:36:31 <evincar> Yeah, to most people, UI = program
16:36:38 <kadoban> koala_man: That's quite clever.
16:36:51 <evincar> "All the buttons are there, so all the features must be there"
16:37:58 <hpc> https://www.youtube.com/watch?v=O_bVLhWwCCs - the best UI ever
16:38:15 <arahael> koala_man: Not to mention, those fricking numbered lists, man.
16:39:07 <isd> evincar: the precedence/parens are the main reason deeply-nested applicatives get annoying.
16:39:45 <isd> (You could probably just strike the word deeply there... it get's annoying fast)
16:40:12 <isd> I've mostly seen ! used with the parens in idris
16:40:40 <jared-w> what's ! for?
16:40:47 <evincar> isd: Yeah, I think inline bindings scale better in that regard
16:41:08 <isd> jared-w: it's basically what evincar is proposing the <- be used for; see the link above
16:43:00 <evincar> Actual example from a compiler of mine: "Lambda <$> go tref <*> pure name <*> go varType <*> recur body <*> pure origin" would become "pure $ Lambda (<- go tref) name (<- go varType) (<- recur body) origin"
16:44:22 * ski . o O ( `‚åúLambda ‚åûgo tref‚åü name ‚åûgo varType‚åü ‚åûrecur body‚åü origin‚åù' )
16:44:50 <evincar> Or "TypeVar origin <$> (Var name <$> freshTypeId tenv <*> pure k)" => "pure $ TypeVar origin $ Var name (<- freshTypeId tenv) k"
16:45:33 * ski . o O ( `‚åúTypeVar origin (Var name ‚åûfreshTypeId tenv‚åü k)‚åù' )
16:46:08 <evincar> Yup
16:46:14 <jared-w> interesting
16:46:38 <evincar> I don't care much about the syntax specifically, but I want *something* like this, be it your quasiquotation-like thing or idiom brackets
16:46:49 <ski> instead of annotating the path to the effectful part, you only annotate the place where you splice its result in, as well as the outer delimiter
16:47:17 <ski> my version started from generalizing idiom brackets
16:47:34 <isd> I like ski's idea, except for the part where I can't type it.
16:47:35 <ski> the problem with them is that they don't nest (iow you have to "annotate the path")
16:47:49 <evincar> So in my case, "‚åú" = "do {", "‚åù" => "}",  "‚åûx‚åü" => "<- x"
16:48:03 <ski> isd : i've not made any suggestion for concrete syntax, only abstract syntax
16:48:11 <isd> ski: fair enough
16:48:14 <ski> (also, `do' must be kept separate)
16:49:03 <ski> i may have started thinking about this around 2006
16:50:27 <jared-w> I agree with SPJ in preferring the 'everything is legal'
16:50:51 <ski> yes
16:51:59 <ski> evincar : for patterns, it's not clear how to (implicitly) delimit in any reasonable way (and i probably wouldn't like it anyway, on the grounds of being implicit)
16:52:00 <millew> Im having trouble compiling a program, Im typing "$ ghc --make foo " in the console but it gives me an error
16:52:15 <ski> here's an unrelated example
16:52:23 <ski>   data Person = MkPerson Name Age
16:52:31 <ski>   parseName :: Parser Name
16:52:38 <ski>   parseAge :: Parser Age
16:52:45 <ski>   parsePerson :: Parser Person
16:53:14 <ski>   parsePerson = ‚åúMkPerson ‚åûparseName‚åü ‚åûparseAge‚åü‚åù
16:53:25 <ski> instead of defining it like this, it would be nice to allow
16:53:36 <ski>   ‚åûparsePerson‚åü = MkPerson ‚åûparseName‚åü ‚åûparseAge‚åü
16:54:41 <evincar> jared-w: Please show your support by thumbing up or commenting :)
16:54:50 <evincar> I want this to show a representative sample of people
16:55:06 <ski> btw, note that while `parseName' has type `Parser Name', `‚åûparseName‚åü', otoh, has (apparent) type `Name', but with implicit `Parser'-effects (*side*-effects !), so that's why `MkParser :: Name -> Age -> Person' can be legally applied to it
16:55:23 <evincar> ski: You mean in ViewPatterns? Yeah, I don't think anyone would really want to use it there anyway
16:55:40 <jared-w> I want to understand it a little better first, and look at the idris version before I fully say I agree with the idea. Currently I just think SPJ is right that, if the idea is good, it's better to be as consistent with it as possible
16:56:25 <evincar> Alright, yeah, I agree
16:56:56 <ski> (we're introducing side-effects to Haskell here, but only *lexically local* ones ! the *only* way a side-effect can be introduced into an expression is by using `‚åû‚ãØ‚åü' somewhere inside it)
16:56:56 <evincar> I was surprised to hear him say that because I expected the core people to err on the side of footgun safety
16:57:16 <jared-w> also I'm not quite sure what ski is doing, but the unicode looks pretty
16:57:23 <millew> Im trying to compile a file and when I type "$ ghc --make helloworld  " it gives me a parse error on '$' does anyone know why
16:57:37 <evincar> They're not *exactly* side effects, just "direct style" monadic effects
16:57:38 <isd> millew: are you typing that directly at the shell?
16:57:46 <jared-w> millew: you don't want to actually type the $
16:57:47 <evincar> I would say a side effect is anything observable by safe code
16:58:00 <isd> If you're reading some tutorial, $ is commonly used to denote the prompt -- the command starts with "ghc"
16:58:00 <evincar> From outside
16:58:02 <millew> isd: im typing it at prelude>
16:58:26 <jared-w> ahh, that's another issue, you type that at the commandline, not the ghci prompt
16:58:26 <millew> jared-w: I've tried without but it says that ghc is an unknown function
16:58:27 <isd> millew: ah, you  want to back out of ghci first
16:58:45 <isd> jinx.
16:58:49 <millew> isd: Oh i see, how would i do that?
16:58:57 <jared-w> type :q
16:59:17 <ski> and i think `‚åú\x -> ‚ãØx‚ãØ‚åû‚ãØ‚åü‚ãØ‚åù' should be illegal. "unquote"/"splice" should not be allowed in a lambda, without an intervening delimiter ("quasiquote")
16:59:57 <millew> still the same error
17:00:19 <jared-w> ski: would it potentially be better to make haskell's syntax homiconic first? (I think you're talking about macros now? idk)
17:00:31 <jared-w> millew: are you out of ghci and into the shell now?
17:00:34 * ski . o O ( `:!...' )
17:00:59 <millew> jared-w: Haskell opens up automatically in prelude, im not sure what you mean by shell
17:01:03 <ski> jared-w : no, not macros. but yes, staged programming was an inspiration for it
17:01:26 <isd> millew: how are you getting into ghci?
17:02:03 <geekosaur> millew, the $ represents your shell prompt, it's not something you type
17:02:07 <ski> jared-w : if they weren't already used, i'd suggest "`" and "," as the delimiter and the splicer (without changing to sexprs, which i assume you had in mind ?)
17:02:28 * geekosaur sudden flashbacks to vms...
17:02:40 <isd> ski: yeah, this is the thing, haskell is somewhat low on spare symbols
17:02:53 <millew> isd: i'm opening haskell as you would, when i hover over the icon it says 'winghci' if that makes a difference
17:03:01 <isd> Ah, you're on windows
17:03:02 * ski nods slowly
17:03:17 <jared-w> Sorry, all of us are on Linux and we tend to assume most people are on Linux by default :)
17:03:21 <isd> :P
17:03:28 <isd> I'm sure not *all* of us
17:03:30 * arahael is on Mac OS X, running a windows VM!
17:03:35 <isd> (and I'm sure there are plenty of mac users...)
17:03:43 <isd> But in any case
17:03:56 <jared-w> s/linux/sane os/  (jk)
17:03:58 <isd> millew: you want to be using the OS's command line prompt for that one, not GHCi
17:04:03 <millew> haha sorry i didn't realise linux was convention
17:04:14 * arahael coughs.  Mac OS is perfectly sane.
17:04:16 <ski> millew : try "Run command" and enter "cmd.exe" ?
17:04:17 <isd> So, powershell I suppose
17:04:27 <isd> or cmd.exe. I guess they should both work
17:04:30 <jared-w> arahael: I know, that's why I wanted to include it :p
17:04:42 * isd hasn't run windows on his own machine for well over a decade...
17:05:15 <jared-w> https://www.youtube.com/watch?v=87haMtLLcJQ  millew here, look at this link
17:05:42 <jared-w> The video walks through how to startu pand use GHCi, then how to make a text haskell program
17:05:46 <millew> jared-w: thank you i will!
17:06:40 <jared-w> You'll be able to go a very long way in haskell programming before that setup starts to be insufficient :)
17:07:09 <millew> would it be worthwhile to make a linux virtual machine specifically for haskell?
17:07:26 <sm> all of us are not on linux
17:07:27 <jared-w> Nah, don't worry about it. If you don't already know how to use linux, now you have to learn *two* things to start using Haskell
17:07:38 <isd> millew: haskell works fine on windows
17:07:47 <jared-w> Just use Haskell on Windows, plenty of people do so just fine :)
17:08:11 <jared-w> sm: I should've said 'most of us on the IRC', m'bad
17:08:14 <millew> alright thanks :) 
17:08:27 <sm> I'd need to see data for that
17:08:54 <sm> lot of mac users around..
17:09:04 <jared-w> Didn't the last haskell survey show that the large majority of people used linux?
17:09:30 <sm> that would do nicely!
17:10:00 <sm> anyway, what I want to say is let's not short change haskell's terrific cross platformness.. improve it
17:10:17 <sm> "linux only" is lame
17:10:57 <jared-w> Agreed. I much prefer cross-platform capabilities even if Linux is more widely used by programmers in certain industries
17:11:01 <sm> and it's GNU/Linux :)
17:12:01 * hackagebot columbia 0.1.0.2 ‚Äì Enhanced serialization for media that support seeking. ‚Äì https://hackage.haskell.org/package/columbia
17:14:36 <jared-w> Odd, I could've sworn I saw a survey on the haskell community. It mentioend that r/haskell had like 70ish% of the community on it and things like that
17:16:40 <isd> r/haskell is not necessarily representaive of all haskell users
17:16:57 <isd> I've certainly seen plenty of macs at the Boston Haskell meetups
17:17:00 <jared-w> The survey I'm thinking of was larger than r/haskell
17:17:30 <jared-w> I can't find it anywhere and I'm starting to wonder if I fabricated it in my head somehow ‡≤†_‡≤†
17:17:30 <slack1256> I wold say meetups are not representive of all haskell users
17:17:42 <slack1256> yet r/haskell is more representative
17:21:30 <ReinH> 100% of people who responded to a Haskell survey on r/Haskell reported using r/Haskell.
17:22:30 * hackagebot language-ninja 0.2.0 ‚Äì A library for dealing with the Ninja build language. ‚Äì https://hackage.haskell.org/package/language-ninja
17:22:35 <davean> ReinH: that seems a bit high
17:23:02 <ReinH> 110%
17:26:43 <jared-w> r/haskell is more representative than meetups just from sheer volume of users. There's 28k subscribers on reddit. The IRC is the #4 largest irc channel on freenode but still doesn't even have 2k people signed on regularly iirc. Same sort of deal for the mailing lists
17:26:48 <Cale> isd: How many of those macbooks were just running nix or something though? :)
17:29:06 <jared-w> Good point. It's only been in the last 2-3 years in my experience that windows laptops have really been competetive with mac laptops
17:29:15 * jared-w says while hugging his Dell XPS 13
17:30:52 <isd> Cale: not many, actually. Not to say there aren't *also* plenty of machines running some version of linux (my own included)
17:31:26 * ski . o O ( "100% of people who responded to a survey reported responding to a survey" )
17:31:44 <jared-w> ski: what does the . o 0 thing mean?
17:32:00 <isd> I also wonder how many people we're missing who are using haskell but don't just spend time hanging out in haskell oriented spaces on the net.
17:32:42 <ski> perhaps monochrom should add something like that to their list
17:32:53 <jared-w> isd: probably a somewhat decent amount. I'd imagine most of the business that companies like FPComplete get is primairly people who don't care about haskell as a religion (/s) and just want to use it
17:32:59 <glguy> isd: "If a tree falls in a forest and no one is around to hear it, does it make a sound?"
17:33:03 <ab9rf> "hanging out" is not always conducive to learning
17:33:04 <ski> jared-w : it's meant to symbolize a thought bubble
17:33:27 <jared-w> gotcha
17:33:45 <jared-w> ab9rf: But it's *always* conductive to procrastination, which is basically the same thing in my experience
17:34:12 <isd> ab9rf: so, what you're saying is, we're only surveying people who don't actually get anything *done* with haskell? :P
17:34:40 <jared-w> isd: nah we're just surveying the extreme outliers
17:35:16 <jared-w> The extremely unproductive (like me) and the extremely productive, like edwardk, who can somehow spend 27 hours a day on Haskell before lunch
17:35:59 <ab9rf> isd: could be. i almost never get anything done with anything.
17:37:07 <bandit145> me irl
17:37:15 <Cale> jared-w: Pretty sure Ed has a time machine.
17:37:26 <jared-w> *but* I know so many shiny things about endofunctors now and that will surely come in handy someday
17:47:52 <boj> isd: yeah, probably a good handful missing. my team uses it because i asked them to, they aren't the social community types so aren't around
17:48:52 * hackagebot concurrent-dns-cache 0.1.0 ‚Äì Concurrent DNS cache ‚Äì https://hackage.haskell.org/package/concurrent-dns-cache
17:50:59 <saylu> Anyone used these two libraries and have a preference between them?
17:50:59 <saylu> https://github.com/plow-technologies/servant-auth
17:50:59 <saylu> https://github.com/zohl/servant-auth-cookie/
18:23:03 <millew> I'm having trouble using the `cat` function, im in the same directory as the .txt file im trying to open, but it says variable not in scope
18:26:05 <viniciusdf> Hi
18:27:21 <ski> millew : try switching to the `cmd.exe' window, and use `type' instead of `cat' ?
18:28:00 <millew> ski: that works perfectly, thank you
18:28:31 <ski> (`cat' is a *nix command)
18:30:44 <iqubic> It displays the contents of a file, right?
18:31:43 <ski> basically
18:33:56 <iqubic> If you give it multiple files, it'll print their contents one by one.
18:35:04 <EvanR> itll concatenate several files together
18:35:20 <EvanR> and stream the result out to stdout
18:35:51 <EvanR> now i realize why its called cat :)
18:36:20 <jared-w> lol I never realized that either
18:36:50 * ski thought this was taught in "Unix 101"
18:37:23 * iqubic know it was
18:37:51 <EvanR> fell asleep in that class
18:38:13 <EvanR> or it was called "Java 101" by that point
18:39:06 <jared-w> I mean, I know what cat does, I don't think anyone ever pointed out the reason for its name because it's fairly obvious if you use the word 'concatenate' to describe what it does
18:39:47 <EvanR> i thought the point was to mess up your terminal by dumping raw binaries
18:39:49 <jared-w> I also had a very unusual intro to programming experience, so... :p
18:40:10 <EvanR> as if the cat was walking all over the keyborad
19:02:37 <ab9rf> cat walking over the keyboard is how sendmail.cf files are written
19:16:36 <ski> jared-w : .. elaborate ?
19:17:33 <jared-w> Well let's see, my first university I went to had a fairly poor CS program, so intro to programming was taught using C++ and the lecture materials were powerpoints that were scanned overhead projector slides
19:18:15 <jared-w> Same thing for algorithms and data structures class; I spent more time fighting the language that I never properly learned than actually learning the algorithms.
19:18:57 <EvanR> wait, this is supposed to be unusual? :)
19:19:04 <ab9rf> heh
19:19:09 <jared-w> Fast forward to the university I'm currently at. I had taken quite a bit of math at this point (up through ordinary differential equations, and a few quarters of quantum mechanics) and so I took a much more rigorous course at PSU where I actually had to learn things :p
19:19:49 <jared-w> Still in C++ but by this time I already knew all the algorithms and data structures so I was able to semi-properly do things and enjoy myself. Then I started obsessively reading tons of theoretical CS stuff and started picking up Haskell.
19:20:32 <jared-w> (To zoom way back for a second--I picked up LaTeX in junior year of high school far before I actually learned how to program, so I was quite comfortable with a commandline and linux sysadmin things before I got started with everything else)
19:21:25 <EvanR> then you graduate, get a job web programming and never use a damn bit of data structures knowledge
19:21:55 <jared-w> it's funny 'cause I'm probably going to get a web dev internship in the next month...
19:22:02 <erisco> why do I live in a hyperbole
19:22:12 * jared-w cries quietly
19:23:06 <jared-w> EvanR: but I do actually want to get a PhD at some point for something in TCS--likely programming language theory or type theory of some sort
19:24:42 <EvanR> make it practical, get a phd in web programming
19:24:56 <jared-w> ‡≤†_‡≤†
19:25:18 <EvanR> Dr. Web
19:25:20 <jared-w> I actually suck at the whole 'practical' side of programming in general
19:25:24 <EvanR> it says on the business card
19:25:40 <erisco> I think they just call that "programming"
19:26:16 <jared-w> I'll rephrase, then: I'd die happy if I got paid to research weird shit nobody will ever use until 20 years after I die
19:26:21 <ab9rf> pregrooming
19:27:39 <EvanR> congramming, anti-programming
19:27:56 <ab9rf> there's this new trend of "unprogramming"
19:28:14 <EvanR> whats that
19:28:27 <erisco> jared-w, by then we'll have AI doing most of the programming, but I am sure a computer will appreciate your contributions
19:28:55 <jared-w> They better, I'll have slaved away so they could do more stuff in fewer CPU cycles
19:29:18 <ab9rf> the idea that you don't need any expertise to program a computer
19:29:30 <EvanR> hmm.
19:30:10 <EvanR> is there an idea that you need expertise to program a computer ?
19:30:11 <erisco> jared-w, a computer will live your whole life in less than an hour, so it will be like saving it a trip to the corner store
19:30:34 <EvanR> hasnt it always been like a random trade
19:36:47 * hackagebot proto-lens-protoc 0.2.2.1 ‚Äì Protocol buffer compiler for the proto-lens library. ‚Äì https://hackage.haskell.org/package/proto-lens-protoc
20:17:11 * hackagebot units-parser 0.1.0.1 ‚Äì A parser for units of measure ‚Äì https://hackage.haskell.org/package/units-parser
20:21:09 <trevortknguyen[m> Do people talk here?
20:21:50 <geekosaur> mostly at other times of day
20:23:04 <Lokathor> how do people feel about language pragmas?
20:23:08 <Lokathor> like at the top of the file, and all
20:24:52 <trevortknguyen[m> I didn't know they existed until I played around with Yesod web framework
20:24:53 <geekosaur> everyone has their list of pragmas they'd like to become standard. few of those ever will be.
20:24:54 <ab9rf> they feel very algolly
20:25:04 <trevortknguyen[m> I'm still kind of confused by them.
20:25:06 <geekosaur> and they kinda have to be at the beginning because they mutate the parser
20:25:09 <mnoonan_> {-# LANGUAGE TupleSections, LambdaCase #-} all day every day
20:25:37 <ab9rf> geekosaur: aw, you and your insistence on not having arbitrary multipass parsers!
20:25:50 <trevortknguyen[m> Doesn't it make it so that less people can understand your code potentially?
20:25:56 <ab9rf> fewer
20:26:11 <trevortknguyen[m> *fewer
20:26:16 <trevortknguyen[m> Thanks
20:26:34 <geekosaur> ghc serves two masters
20:26:35 <ab9rf> although if we were being truly algolly they'd be pragmats, not pragmas
20:26:38 <geekosaur> one is production Haskell code
20:26:43 <geekosaur> the other is type system research
20:27:31 <Lokathor> but are people strongly against the idea of pragmas?
20:27:49 <Lokathor> I heard from one non-haskeller that most people they talked to about them really hate them
20:27:56 <ab9rf> Lokathor: there are people strongly against the idea that the earth orbits the sun. do you care?
20:28:14 <Lokathor> Actually, I really do care
20:28:20 <ab9rf> for any idea or concept i can find someone who is really strongly against it
20:28:24 <Lokathor> I like to know what people think and why, basically all the time
20:28:29 <ab9rf> especially given enough budget
20:28:33 <Lokathor> :P
20:28:53 <mnoonan_> Lokathor: GHC pragmas specifically? because I don‚Äôt like C++ #pragma, but I don‚Äôt really have a problem with GHC pragmas
20:29:17 <ab9rf> i don't like all that much of C++ :)
20:29:43 <Lokathor> GHC pragmas, yes
21:03:58 * hackagebot justified-containers 0.1.2.0 ‚Äì Keyed container types with type-checked proofs of key presence. ‚Äì https://hackage.haskell.org/package/justified-containers
21:07:55 <EvanR> houston we have a problem
21:08:01 <EvanR> https://github.com/costajob/app-servers#results
21:16:20 <arahael> EvanR: Intriguing that Kestral is secon dplace there.
21:28:38 <EvanR> the problem being, where is haskell in that list
21:31:48 <butterthebuddha> https://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
21:31:55 <butterthebuddha> Anybody got any tips for exercise 5?
21:33:45 <Rotaerk_> hmm is there something like when but where the Bool comes from a monad
21:34:07 <Rotaerk_> trying to simplify:  do { a <- b; when (isNothing a) x }
21:34:57 <Rotaerk_> something like ... whenM (isNothing <$> b) x
21:36:44 <Rotaerk_> err, wait, the newer hoogle reveals whenM exists...
21:38:08 <geekosaur> widely (re)implemented but not standard
21:40:40 <mibaz_1> hey guys :) anyone who knows about gitit hang out here?
21:41:08 <mnoonan_> butterthebuddha: where are you stuck?
21:42:14 <mibaz_1> to clarify, that's gitit the wiki software, not git the version control software.
21:48:37 * hackagebot dns 2.0.11 ‚Äì DNS library in Haskell ‚Äì https://hackage.haskell.org/package/dns
21:54:06 <Lokathor> EvanR, you're forgetting: avoid success at all costs
21:54:10 <Lokathor> that's the Haskell way
21:54:22 <butterthebuddha> mnoonan_ I'm not a 100% sure what the task is
21:58:21 <Xnuk> butterthebuddha: make `instance Expr Program` and `compile :: String -> Maybe Program`
22:02:53 <Lokathor> EvanR, https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&hw=ph&test=json way more benchmarks
22:04:08 <Lokathor> has some haskell results, "Hkl"
22:10:58 * hackagebot vintage-basic 1.0.3 ‚Äì Interpreter for microcomputer-era BASIC ‚Äì https://hackage.haskell.org/package/vintage-basic
22:10:58 * hackagebot hw-bits 0.5.0.3 ‚Äì Bit manipulation ‚Äì https://hackage.haskell.org/package/hw-bits
22:11:59 <Axman6> acowley_away: ping
22:15:07 <piyush-kurur> Axman6: hi
22:15:29 <iqubic> He guys
22:15:40 <iqubic> s/he/hey/
22:16:09 <Axman6> piyush-kurur: hello!
22:16:34 <piyush-kurur> Axman6: just responed to your reddit comment. You think arc4random is well supported on MacOS?
22:16:54 <Axman6> I believe so, yes, but I'll see if I can find when it was added
22:17:52 <piyush-kurur> would you mind opening up a ticket and adding your find there?
22:18:06 <piyush-kurur> so that we have some documentation.
22:18:34 <piyush-kurur> the change is minor and if the consenses is that arc4random is the way to go then I can make this change for the release 0.2.0
22:19:39 <piyush-kurur> s/consenses/consensus/ 
22:21:08 <Axman6> it's hard to find exacly when arc4random was added to macOS, but it appears in docs from Xcode 5.0, which is quite old
22:23:05 <piyush-kurur> Axman6: arc4random in the previous incarnation used RC4 even on OpenBSD (hence the name arc4random). It is only recently they themselves have moved to chacha20. The RC4 based CSPRG is not that good (although it might be the same thing that is used by the /dev/urandom) because of known flaws of RC4 (aka ARC4).
22:23:52 <Axman6> Apple's uses AES
22:24:24 <piyush-kurur> Axman6: for their /dev/urandom ?
22:24:25 <Axman6> (since macOS 10.12 anyway)
22:25:18 <Axman6> for arc4random*
22:25:28 <piyush-kurur> okey 
22:25:35 <piyush-kurur> then I think it is fine to move.
22:26:06 <piyush-kurur> any case just open a ticket and I will fix this
22:26:12 <Axman6> yeah. perhaps put a check in for macOS >= 10.12 and use urandom otherwise, since I can't find enough information about when it was added
22:26:23 <piyush-kurur> thanks for your input
22:26:53 <piyush-kurur> is version check possible in cabal ?
22:27:23 <Axman6> I believe so, but can't remember how
22:28:30 <Axman6> hmm, stackoverflow seems to say now
22:28:31 <Axman6> uh, no
22:29:06 <Axman6> https://stackoverflow.com/questions/8024961/c-macro-for-os-x-version-lion-or-not-detection
22:29:46 <Axman6> so, maybe it's best to stick to urandom, or assume it'll be there (the docs are quite old so I'd be surprised if arc4random hasn't been around for a long time)
22:30:05 <EvanR> arc4random = RC4 = broken?
22:30:12 <piyush-kurur> Axman6: we can give a cabal flag to enable arc4random any way.
22:31:09 <piyush-kurur> EvanR: recent version of arc4random uses chacha20 not RC4
22:31:25 <Axman6> "A Replacement 4 Random". no one uses RC4 for arc4random any more
22:31:40 <Axman6> The original version of this random number generator used the RC4 (also known as ARC4) algo-
22:31:42 <Axman6>      rithm.  In OS X 10.12 it was replaced with the NIST-approved AES cipher, and it may be
22:31:43 <Axman6>      replaced again in the future as cryptographic techniques advance.  A good mnemonic is ``A
22:31:46 <Axman6>      Replacement Call for Random''.
22:32:06 <Lokathor> watching a tech talk about how functional programming is cool
22:32:27 <Lokathor> but his explanation of how haskell works is... almost embarassingly wrong :/
22:32:27 <Axman6> why would they lie to you liike that
22:32:30 <EvanR> FP was cool before it was cool
22:33:06 <piyush-kurur> EvanR: now it has become (too) hot?
22:33:22 <Lokathor> he said at the start that he's an F# programmer who just knows a little Haskell, and then he picked Haskell as the main language for his talk, and then his Haskell explanations are all wrong :(
22:34:01 <Axman6> piyush-kurur: I've found references to Mac OS X having arc4random as far back as 2011, so I thinnk you're safe to just enable it for macOS
22:35:21 <piyush-kurur> Axman6: thanks will do it. 
22:36:37 <nshepperd> hysterical raisins strike again. I assume it was easier to make the name "arc4random" be a lie than to migrate everyone's code to a different random function
22:36:51 <Axman6> pretty much
22:39:31 <Axman6> Lokathor: wrong how?
22:40:13 <Lokathor> characterizes IO in a very poor way, explaining that IO is how you tell a function is impure
22:40:17 <Lokathor> normal misconception stuff
22:40:55 <Lokathor> foo :: Bar -> IO Int -- "this function returns an Int, but it does it in an impure way"
22:41:05 <Axman6> :\
22:42:13 <Lokathor> yep
22:47:13 <jle`> is there a recommended pgp solution these days
22:47:28 <piyush-kurur> Axman6: FreeBSD seems to be lagging quite a bit on the arc4random thing. FreeBSD 11.11 man page says arc4random uses RC4 
22:47:29 <jle`> nowadays i just search on google and pick the package that was updated most recently
22:47:55 <boj> jle`: gnupg?
22:48:10 <jle`> i mean in haskell heh
22:48:17 <boj> that would make more sense
22:48:33 <piyush-kurur> even FreeBSD-12 is bad https://www.freebsd.org/cgi/man.cgi?query=arc4random&sektion=3
22:48:35 <jle`> so far i see two packages that offer just openpgp, hOpenPGP and openpgp
22:49:24 <jle`> hOpenPGP is more recent but has no docs and the project homepage doesn't load
22:50:06 <jle`> openpgp still works fine for me but it hasn't been updated since 2013
22:50:42 <EvanR> the OSX manpage for arc4random implies its RC4
22:55:18 <Axman6> noot the latest one
22:55:22 <Axman6> not*
22:55:51 <piyush-kurur> EvanR, Axman6 : I think it is safest to have a flag for arc4random on these platform as of now
22:56:03 <Axman6> yeah
22:56:59 <EvanR> the latest what
22:57:11 <EvanR> i typed man arc4random...
22:57:50 <EvanR> also, how is this possible https://twitter.com/1HaskellADay/status/892555311432781824
23:04:01 <ReinH> Anything is possible at zombocom, by which I mean "with bottoms".
23:04:19 <ReinH> also f = const Nothing, obviously.
23:04:53 <EvanR> o_o
23:06:54 <jle`> usually that account gives pretty neat puzzles
23:07:03 <jle`> a point-free puzzle tho i can't get behind
23:07:32 <ReinH> Conor's reply is ace.
23:07:44 <jle`> yeah
23:07:53 <jle`> fmap swap . sequence . swap
23:07:58 <jle`> not a very insightful puzzle
23:08:28 <ReinH> const Nothing
23:08:46 <jle`> much learning
23:09:00 <ReinH> @djinn (Maybe a, b) -> Maybe (a, b)
23:09:00 <lambdabot> f (a, b) =
23:09:00 <lambdabot>     case a of
23:09:00 <lambdabot>     Nothing -> Nothing
23:09:00 <lambdabot>     Just c -> Just (c, b)
23:09:15 <ReinH> That's more than I expected it to do.
23:10:15 <jle`> djinn tries its best to use all values it has
23:10:29 <ReinH> Hmm.
23:10:42 <jle`> @djinn a -> Maybe a
23:10:42 <lambdabot> f = Just
23:11:09 <jle`> feels dfs-y
23:15:26 <Axman6> @djinn a -> Maybe b
23:15:26 <lambdabot> f _ = Nothing
23:17:03 <nshepperd> does lambdabot have exference? that might be nice to add
23:17:27 <monochrom> lambdabot doesn't have exference.
23:17:31 <EvanR> @djinn Maybe (a, b) -> Maybe (a, b) -> (Maybe a, b)
23:17:31 <lambdabot> -- f cannot be realized.
23:17:52 <EvanR> ^
23:18:23 <mniip> what's exference o.o
23:18:28 <Axman6> @djinn Either Void a -> Either b Void -> (a,b)
23:18:28 <lambdabot> f a =
23:18:28 <lambdabot>     case a of
23:18:28 <lambdabot>     Left b -> void b
23:18:28 <lambdabot>     Right c -> \ d ->
23:18:28 <lambdabot>                case d of
23:18:30 <lambdabot>                Left e -> (c, e)
23:18:32 <lambdabot>                Right f -> void f
23:18:45 <EvanR> o_o
23:19:08 <nshepperd> mniip: djinn, but with cool polymorphism support and stuff https://hackage.haskell.org/package/exference
23:19:30 <EvanR> @djinn Maybe (a, Void) -> Maybe (a, Void) -> (Maybe a, Void)
23:19:30 <lambdabot> -- f cannot be realized.
23:19:53 <EvanR> haha not even absurd gets us out of this one
23:19:56 <nshepperd> however, not decidable because it does a more general kind of search
23:20:17 <EvanR> wtf 1haskelladay
23:20:21 <mniip> Maybe a * Void = Void....
23:20:37 <mniip> and clearly f Nothing Nothing is an inhabitant
23:20:49 <nshepperd> Maybe (a, Void) = Maybe Void = ()
23:21:07 <EvanR> Maybe (a * Void) = ()
23:21:21 <mniip> I meant the last (Maybe a, Void)
23:21:27 <mniip> the * associated differently
23:21:54 <EvanR> yeah and the question is going even further and generalizing to any type ther
23:22:03 <mniip> generalizing what
23:22:30 <EvanR> repositn this terrible question
23:22:33 <EvanR> https://twitter.com/1HaskellADay/status/892555311432781824
23:23:33 * hackagebot DOH 0.1.2.0 ‚Äì Complete API bindings for DigitalOcean API V2 ‚Äì https://hackage.haskell.org/package/DOH
23:24:35 <mniip> aha
23:24:50 <mniip> though with that f dual you can prove absurd
23:25:17 <Lokathor> f' :: Maybe (a, b) -> (Maybe a, b)
23:25:22 <Lokathor> can you implement this at all?
23:25:44 <EvanR> no
23:26:06 <pacak> > undefined :: Maybe (a, b) -> (Maybe a, b)
23:26:08 <lambdabot>  error:
23:26:08 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
23:26:08 <lambdabot>          arising from a use of ‚Äòshow_M515769054740412029513895‚Äô
23:26:15 <Lokathor> :(
23:26:23 <EvanR> haha
23:26:26 <mniip> @djinn (Maybe (a, b) -> (Maybe a, b)) -> Void
23:26:26 <lambdabot> -- f cannot be realized.
23:26:27 <pacak> > :t undefined :: Maybe (a, b) -> (Maybe a, b)
23:26:29 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
23:26:33 <pacak> Ugh.
23:26:35 <mniip> @djinn (Maybe (a, Void) -> (Maybe a, Void)) -> Void
23:26:35 <lambdabot> f a =
23:26:35 <lambdabot>     case a Nothing of
23:26:35 <lambdabot>     (_, b) -> b
23:27:04 <EvanR> djinn u so smart
23:27:05 <mniip> does djinn skolemize all tyvars?
23:27:11 <nshepperd> :t impossible
23:27:13 <lambdabot> Maybe (a, b) -> (Maybe a, b)
23:27:17 <nshepperd> > impossible Nothing
23:27:19 <lambdabot>  *Exception: Nice one, you win the prize. Oh... it's empty :(
23:27:49 <mniip> oh yes, djinn must because that's how HM works
23:28:16 <mniip> rank N exference is undecidable, right?
23:30:24 <nshepperd> I don't remember what skolemize means. i think it treats all type variables as free and unknown. which is the same as having outermost foralls in this case?
23:30:29 <mniip> yeah
23:30:48 <mniip> it instantiates all tyvars with tycons not equatable with anything else
23:30:57 <nshepperd> but it can't do rank ‚â•2, yeah
23:31:20 <mniip> also, in those tweets, what is the point of coming up with a point-free solution? You can always point-freeeize whatever you've got
23:31:24 <nshepperd> you can write (forall a. e) -> r but it just ignores the forall
23:32:26 <jle`> hm i can't get hOpenPGP to build because of some dependency on a c library, even though the lib claims to be pure haskell
23:33:55 <nshepperd> mniip: I guess its so you can show off your knowledge of combinators like sequence :)
23:34:10 <mniip> sequenceA or bust
23:34:29 <mniip> :t distribute
23:34:31 <lambdabot> error:
23:34:31 <lambdabot>     ‚Ä¢ Variable not in scope: distribute
23:34:31 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòdistrib‚Äô (imported from Control.Lens)
23:35:06 <mniip> :t [Data.Distributive.distribute, flip]
23:35:07 <lambdabot> [(a1 -> b -> a) -> b -> a1 -> a]
23:35:10 <mniip> :p
23:35:54 <cocreature> jle`: can you show us the actual error?
23:36:42 <jle`>     /tmp/stack1789/nettle-0.2.0/src/nettle-ciphers.h:5:28: fatal error: nettle/version.h: No such file or directory
23:36:46 <jle`>      #include <nettle/version.h>
23:36:47 <jle`> i might be interpreting this incorrectly
23:36:51 <mniip> nshepperd, somewhere up there I composed >>= out of S and K
23:37:35 <cocreature> jle`: nettle already has ‚Äúbinding‚Äù in the name so I‚Äôm not sure why you think it‚Äôs pure haskell :)
23:37:42 <cocreature> eh in the description not the name
23:37:53 <jle`> the nettle docs make it clear that it's not pure haskell
23:38:03 <jle`> but the hOpenPGP documentation claims to be pure haskell
23:38:04 <jle`> but uses nettle?
23:38:09 <jle`> i wonder if that still counts
23:38:26 <jle`> we're pure haskell, in which we mean we call a binding using pure haskell
23:38:53 <cocreature> ah yeah that‚Äôs a bit fishy
23:38:55 <ongy> the hOpenPGP package is pure haskell, they also have cryptonite as dependency, which uses implementations written in C. so it being pure Haskell is only about the PGP implementation
23:39:15 <jle`> ah i see
23:39:40 <jle`> the actual pgp implementation is pure haskell, but they might pull in typeclasses or things from libraries that have some c stuff
23:39:58 <jle`> unrelated to the functionality they are using from them
23:40:21 <cocreature> I‚Äôm not sure why they depend on nettle. cryptonite seems to have pretty much anything that nettle providese afaict
23:40:59 <jle`> also i suspect my issue with nettle building might be a stack bug but i've already moved on to other things
23:42:22 <ongy> I don't even think they don't use the "unpure" stuff. from what I can see it's more "the high level PGP stuff we implement is in haskell, the crypto libraries are whatever"
23:43:07 <jle`> yeah it sounds like the c stuff isn't even used, it just happened to be an unused part of a dep.  i was unjustified in my distrust
23:46:31 <pacak>                   (+# 24 (+# 4 ipv14_Xosx)) -- any ideas how to convince ghc to constant fold those?
23:50:03 <cocreature> pacak: do you need it to be constant folded in core? at least the LLVM backend will definitely constant fold this later (not sure about the native backend)
23:50:31 <pacak> cocreature: I'm trying to figure out if it's constant folded in generated asm code. We are not using LLVM
23:50:49 <cocreature> pacak: https://ghc.haskell.org/trac/ghc/ticket/9136 seems relevant but sadly not particularly helpful since there is no solution atm
23:50:56 <cocreature> apart from an outdated patch
23:52:31 <pacak> familiar people :)
23:54:07 <pacak> OK, it seems I need some benchmarks to revive this ticket.
