00:01:35 <kuribas> Monoid a, Monad m a is also a Monoid, with "liftA2 (<>)"
00:08:55 <kuribas> :t liftA2 (<>)
00:08:57 <lambdabot> (Monoid c, Applicative f) => f c -> f c -> f c
00:09:43 <kuribas> :t (liftA2 (<>) :: Monad m => m () -> m () -> m ())
00:09:45 <lambdabot> Monad m => m () -> m () -> m ()
00:10:38 <kuribas> Wouldn't this be a useful instance?
00:11:54 <lyxia> > (liftA2 (<>) [1,2] [3,4], (<>) [1,2] [3,4])
00:11:57 <lambdabot>  error:
00:11:57 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòc0‚Äô arising from a use of ‚Äòshow_M825727724264...
00:11:57 <lambdabot>        prevents the constraint ‚Äò(Show c0)‚Äô from being solved.
00:12:01 <lyxia> meh
00:12:18 <lyxia> > (liftA2 (<>) [1,2] [3,4], (<>) [1,2] [3,4] :: [Int])
00:12:21 <lambdabot>  error:
00:12:21 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòc0‚Äô arising from a use of ‚Äòshow_M232555281130...
00:12:21 <lambdabot>        prevents the constraint ‚Äò(Show c0)‚Äô from being solved.
00:12:25 <lyxia> > (liftA2 (<>) [1,2] [3,4] :: [Int], (<>) [1,2] [3,4] :: [Int])
00:12:27 <lambdabot>  error:
00:12:27 <lambdabot>      ‚Ä¢ No instance for (Monoid Int) arising from a use of ‚Äò<>‚Äô
00:12:27 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòliftA2‚Äô, namely ‚Äò(<>)‚Äô
00:13:11 <pacak> There are several possible implementations
00:13:19 <kuribas> (liftA2 (<>) [1,2] [3,4], (<>) [1,2] [3,4]) :: ([Sum Int], [Int])
00:13:24 <kuribas> > (liftA2 (<>) [1,2] [3,4], (<>) [1,2] [3,4]) :: ([Sum Int], [Int])
00:13:26 <lambdabot>  ([Sum {getSum = 4},Sum {getSum = 5},Sum {getSum = 5},Sum {getSum = 6}],[1,2,...
00:13:35 <lyxia> hahaha
00:14:00 <pacak> you can combine values inside a monad (or applicative) using monoidal properties, you can combine different branches  of Alternative/MonadPlus instance
00:14:12 <pacak> kuribas: Same as Monoid Int.
00:14:57 <pacak> It can be addition with 0, multiplication with 1 or max/min with minus/plus infinity
00:16:26 <kuribas> pacak: or minbound/maxbound
00:16:46 <kuribas> perhaps a semigroup makes more sense for max/min...
00:17:29 <pacak> kuribas: In Haskell - yes.
00:18:14 <kuribas> ah: instance (Ord a, Bounded a) => Monoid (Max a)
00:18:59 <zekt> Hi guys, I want to create a mapping from String to a parameterized type like `type Env = String -> Val a`, is there a way to do so?
00:20:23 <kuribas> :t read
00:20:26 <lambdabot> Read a => String -> a
00:21:13 <kuribas> zekt: yes, with a typeclass
00:23:27 <pacak> zekt: type Env a = Map String a....
00:24:36 <kuribas> or a GADT...
00:24:53 <zekt> keribas: yes? you mean dont use parameterized but define them as different of a typeclass?
00:25:16 <kuribas> zekt: well, I am not sure what you want to do...
00:26:05 <zekt> I'm implementing a small language in Hasell, now I am trying to define a Environment, which is a mapping from String to Val
00:26:28 <zekt> Val is defined like:
00:26:28 <zekt> data Val a where N :: Int -> Val Int; B :: Bool -> Val Bool; L :: [Val a] -> Val [a]; P :: (Val a) -> (Val b) -> (a, b)
00:28:59 <kuribas> string is the ID?
00:29:08 <zekt> yes
00:29:08 <ertes-w> lo
00:31:48 <zekt> pacak: that's what I thought, but it Env then requires a type to use, which is what I dont wnat for this mapping :(
00:32:18 <zekt> I'm thinking maybe I should define my Val in another way
00:36:11 <kuribas> wouldn't this work?  "type Env = [(String, forall a.Val a)]"
00:41:18 <zekt> never thought of using forall 
00:41:19 <cocreature> zekt: if you want to use a GADT for your terms you are probably going to need a GADT for your environments too, e.g, some kind of hlist
00:41:52 <zekt> kuribas: my GHC says 
00:41:53 <zekt> Illegal polymorphic type: forall a. Val a
00:41:53 <zekt> GHC doesn't yet support impredicative polymorphism
00:42:00 <kuribas> zekt: or data ValKey where ValKey :: String -> Val a -> ValKey
00:42:12 <kuribas> zekt: yeah, I didn't test it...
00:42:16 <cocreature> which is why enforcing that your types are typed correctly becomes kind of annoying once you have variables
00:45:59 <ski> kuribas,zekt : there's no total value of type `forall a. Val a'
00:46:58 <cocreature> zekt: how are you defining variables in Val? an environment without variables seems kind of useless
00:51:35 <zekt> cocreature: I have a Term defined as Var Name which means when I do eval (Var n) means the language would lookup n in the environment provided
00:51:59 <cocreature> zekt: what‚Äôs the type of Var Name?
00:52:20 <cocreature> and what exactly is Name? just a String?
00:52:37 <zekt> yes, type Name = String
00:53:23 <zekt> currently the type is data Term a where Var :: Name -> Term a, but apparently it's wrong
00:54:57 <zekt> some of my Term for example:
00:54:58 <zekt> data Term a where Lit :: Val a -> Term a; Var :: Name a -> Term a; Pair :: Term a -> Term b -> Term (a, b); Cons :: Term a -> Term [a] -> Term [a]; Lam :: Name -> Type -> Term a -> Term a
00:55:34 <cocreature> zekt: you might want to take a look at richard eisenberg‚Äôs glambda example
00:55:37 <cocreature> specifically https://github.com/goldfirere/glambda/blob/master/src/Language/Glambda/Exp.hs#L45
00:56:20 <cocreature> once you want to ensure that your expressions are well-typed using a GADT, you usually need to praametrize your Exp type by the typing environment
00:59:12 <zekt> concreature: thanks, reading it right away
00:59:47 <cocreature> zekt: richard also gave a talk about this if you want more detailed explanations https://www.youtube.com/watch?v=6snteFntvjM
01:24:33 <Unode> is there any way to have ghc/ghci "compile" code that doesn't type-check? I'd like to have some degree of code inspection ability even when types don't match.
01:25:07 <merijn> Unode: Yes, you can use -fdefer-type-errors, or, better yet, use typed holes
01:25:08 <ski> Unode : `-fdefer-type-errors' perhaps ?
01:25:29 <Unode> thanks I'll try that
01:25:40 <merijn> Unode: If you write _ (or any identifier that is not in scope starting with _) GHC will treat it as "undefined" and type check the rest, then in the end report the type of _
01:26:23 <merijn> Unode: So if you have some complicated expression and don't want to figure out how to fill one part you can just write "foo _ (Just True) bar xyzzy" and GHC will just typecheck it as if _ was right
01:26:57 <merijn> It's especially nice with -fdefer-typed-holes which lets you postpone the error from the hole until runtime so you can execute code with holes in it
01:28:20 <Unode> merijn: in this case is more like a function that should return one type but returns another. The function is still being prototyped. Is supposed to use a custom IO Monad but it doesn't do any IO so far (and I can't figure out a way to have it wrapped on this custom IO Monad)
01:29:01 <Unode> I'll give those two options a try. Been trying "Intero" with vim and it's quite nice to work with, but not when the code doesn't compile.
01:31:37 <merijn> Unode: Monadic function?
01:31:58 <merijn> Unode: Where you're not finished implementing yet, so it's not returning the right thing yet?
01:32:15 <Unode> I don't really know how to call it.
01:32:39 <merijn> Unode: Well, lpaste a small example? :)
01:33:12 <Unode> https://github.com/luispedro/ngless/blob/master/NGLess/NGLess/NGError.hs#L46
01:33:20 <merijn> Also, you managed to get Intero working with vim? How'd you do that?
01:33:43 <Unode> merijn: there' a neovim intero plugin https://github.com/parsonsmatt/intero-neovim
01:33:57 <Unode> still in early stages but mostly works.
01:34:02 <merijn> ah, yeah I saw that, but neovim is a no go for me :)
01:34:18 <merijn> Unode: Which function is the issue there? testNGLessIO?
01:34:24 <Unode> much better than ghc-mod which was giving me 5-10 seconds per inspection
01:35:12 <merijn> ghc-mod is reasonably fast for me
01:35:17 <Unode> merijn: I'm trying to create a function "func :: [NGLessObject] -> NGLessIO NGLessObject" possibly -> NGLessIO (Maybe NGLessObject)
01:35:24 <merijn> But it's crucial to set it to "-O0 -fno-code" :)
01:35:42 <Unode> -fno-code don't know that one either
01:36:12 <merijn> Unode: It does exactly what it says, doesn't actually produce code, just typechecking. But since optimisations and code generating are slow it makes typechecking MUCH faster :)
01:36:33 <Unode> ... sigh... why aren't these options set by default :)
01:37:21 <merijn> Unode: ah, so the issue is that you don't know which return type you want yet so you want to simply have part inferred?
01:37:26 <lavalike_> cd
01:38:25 <Unode> merijn: the Maybe is the doubt. I think I might need it for cases such as when the list is empty. The issue I was having before is this NGLessIO. I don't know how to explicitly wrap one function on it.
01:38:36 <Unode> Made me realize that I don't know how to do that for IO either.
01:39:06 <Unode> or I might simply be thinking wrong of the whole thing.
01:39:58 <merijn> Unode: I don't quite understand what you meany by "explicitly wrap one function on it"?
01:40:09 <Unode> exactly :)
01:40:13 <Unode> let me rephrase
01:40:37 <Unode> the function is supposed to do some IO. But in this early prototype it doesn't.
01:41:11 <Unode> and because of that when I return any result it returns NGLessObject instead of NGLessIO NGLessObject
01:41:37 <merijn> So, just wrap it with NGLessIO using "pure"? :)
01:42:12 <Unode> I tried "return NGLessObject" but that didn't quite work. Maybe I was doing it right and something else was failing.
01:43:12 * hackagebot ChasingBottoms 1.3.1.3 ‚Äì For testing partial and infinite values. ‚Äì https://hackage.haskell.org/package/ChasingBottoms
01:43:16 <Unode> well, more like "return $ head"
01:43:32 <Unode> as I was getting a [NGLessObject]
01:43:51 <merijn> "return $ head yourList"? that should work...
01:43:59 <merijn> So I think something else was going wrong
01:44:22 <Unode> ok then that tells me I was going in the right direction. Thanks.
01:44:40 <dredozubov> Is it possible to abstract over types of kind TYPE PtrRepUnlifted?
01:46:44 <merijn> dredozubov: Only one way to find out!
01:47:30 <dredozubov> I tried writing a typeclass for that, but I get weird errors from the instances
01:47:47 <dredozubov> I'm wondering if there's restriction implied somewhere
01:48:03 <dredozubov> I was thinking about trying out backpack, but I haven't tried it before, so I'm not sure
01:49:01 <merijn> dredozubov: Did you provide explicit kind signatures for your instances?
01:49:05 <merijn> and/or class
01:50:06 <dredozubov> yes
01:52:15 <dredozubov> https://gist.github.com/dredozubov/a6c03e1efc2572b8d5428c5c1e6e33d3 this is what I get
01:53:25 <merijn> hmmm, odd
01:55:39 <Iceland_jack> Because of Any
01:56:03 <Iceland_jack> I don't have a compiler with me but try: instance Any ~ any => Backend (SmallArray# any)
01:59:56 * hackagebot true-name 0.1.0.3 ‚Äì Template Haskell hack to violate module abstractions ‚Äì https://hackage.haskell.org/package/true-name
02:00:23 <dredozubov> Iceland_jack: it compiles. Can you explain why it happens?
02:01:05 <Iceland_jack> GHC doesn't let you have type families in the head (right of the =>) of instances
02:01:14 <Iceland_jack> and Any recently became a type family
02:01:27 <dredozubov> I wasn't aware that Any is a type family now
02:02:22 <paolino_> Hi, I'm looking at https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Moore.html
02:02:24 <Iceland_jack> Googling "Illegal type synonym family application in instance:" the first result is a GHC Trac ticket (https://ghc.haskell.org/trac/ghc/ticket/3485) shows the same constraint trick I used (http://chrisdone.com/posts/haskell-constraint-trick)
02:02:32 <paolino_> At the Applicative instance
02:02:56 <paolino_> why is pure :: a -> Moore a a ?
02:03:12 <paolino_> shouldn't it be b :: Moore a b ?
02:03:26 <mniip> is it not?
02:03:44 <mniip> Control.Applicative.Applicative's pure should never have such a type
02:03:50 <dredozubov> Iceland_jack: data Any <-- that's all I see in GHC.Prim
02:03:57 <dredozubov> doesn't look like a type familty to me
02:04:03 <paolino_> mniip what is broken then ?
02:04:08 <paolino_> haddock ?
02:04:12 <merijn> dredozubov: That's because GHC.Prim is filled with built-in magic and lies :)
02:04:17 <Iceland_jack> paolino_: It has the type you describe
02:04:19 <merijn> dredozubov: Don't trust any of it's source
02:04:25 <dredozubov> I get why this trick works with a type family, but why the error arises here eludes me
02:04:47 <Iceland_jack> paolino_: (data Moore a b = Moore b (a -> Moore a b)) is the same as (data Cofree f a = a :< f (Cofree f a))
02:05:04 <Iceland_jack> instantiated at a function type: Cofree (r ->) = Moore
02:05:15 <paolino_> Iceland_jack, so what's broken , haddock ?
02:06:41 <Iceland_jack> Yeah probably, here it is straight from the horse's (sorry Richard) mouth: https://typesandkinds.wordpress.com/category/type-families/
02:07:02 <paolino_> Iceland_jack, I'm still not a Cofree aware programmer, but thanks for the hint  :-)
02:07:23 <Iceland_jack> paolino_: A rose-tree is "Cofree []"
02:08:03 <tdammers> . o O ( A rose tea is coffee )
02:08:18 <merijn> Free is already confusing, cofree just fries my brain whenever I look at it
02:08:36 <Iceland_jack> I like the idea of a "Cofree-away programmer"
02:08:46 <Iceland_jack> something to put on your resume
02:09:23 <paolino_> merijn,  that's the smell I get wen I enter , fried brains 
02:09:54 <mniip> merijn, Do you have a minute to talk about our lord and savior FreeT?
02:10:49 <paolino_> btw, can we say haddock is horribly broken in computing the type of method instances ?
02:12:00 <paolino_> ehm *instance methods
02:14:07 <mniip> paolino_, it's possible it's outputting type variables incorrectly
02:14:09 <mniip> in that it conflates some of them
02:14:13 <mniip> maybe it doesn't tidy up the types?
02:16:25 <paolino_> mniip, I don't know how it computes those signatures, but it shouldn't because they are wrong
02:17:27 <paolino_> I understand that an 'a' has some appeal as a type variable
02:18:09 <will> Can anyone help me with a Yesod/Aeson thing?  Trying to solve the problem described in this SO question, using the linked answer: https://stackoverflow.com/a/42034461.  Struggling to create a FromJSON instance shown here: http://lpaste.net/357936.  Can anyone help, or suggest an alternative approach?
02:30:53 <Geekingfrog> will: you cannot deserialize a function from json
02:33:19 <will> Geekingfrog: OK, thanks... I'll look for another way :)
02:33:34 <Geekingfrog> I'm still not sure what you're trying to do though.
02:37:05 <cocreature> will: what‚Äôs the type of "insert"?
02:40:44 <will> cocreature: Text -> UserId -> HashMap Text Value -> HashMap Text Value.  I see that's another problem... 
02:41:50 <will> Though that problem seems surmountable - whereas I'm not sure how I could return Parser (UserId -> Requirement) as opposed to Parser (UserId -> Parser Requirement)
02:43:24 <cocreature> I don‚Äôt understand what you are trying to do. on an abstract level, you are given a JSON object and a UserId and now you want to extract Requirement. where does "insert" fit into the picture here?
02:43:30 <cocreature> and what do you need the UserId for?
02:44:39 <will> OK, so basically I am trying to write a handler to receive JSON data to add a Requirement.  the JSON will not contain the UserId, which is a field of Requirement
02:45:12 <will> An idea in the stackoverflow question I linked to was to write a FromJSON instance for (UserId -> Requirement)
02:45:24 <will> I thought I'd give it a shot
02:45:37 <cocreature> ah I think I‚Äôm beginning to understand :)
02:46:51 <cocreature> I would just write a function "UserId -> Value -> Parser Requirement" instead of trying to show it in a FromJSON instance
02:47:33 <will> OK, I see... that sounds more sensible
02:47:43 <will> I'll give it a shot, thanks
02:49:17 <cocreature> will: you might also want to split Requirement in a type that doesn‚Äôt have an UserId and a type that wraps that type and adds the Id field
02:51:02 <will> Yes... that was another suggestion I came across.  I am using the Persistent TH stuff to define Requirement, though, so it doesn't seem like it would be very straightforward to do that?
02:55:43 <cocreature> not sure I‚Äôve never really used persistent
02:56:29 <cocreature> but having types that only have an Id sometimes (e.g. there is no id you are inserting them in the db) seems quite common for a db lib so I would expect that it can deal with that somehow
02:58:20 <will> cocreature: Persistent deals nicely with the primary key of each row, in the way that you describe.  However it appears there's not the equivalent for foreign keys.
02:59:26 <will> Which is not always a problem, you can insert a User and then insert a Comment.  But when you have to decode JSON to a particular type (if you want to take advantage of generic FromJSON instances), it becomes an issue
03:22:38 <_sras_> Does postgresql connections in the connection pool (provided by Data.Pool), have an expiration period after which they cannot be used? Can one connection from a pool be used exclusively by a single process indefinetly?
03:25:37 <kuribas> will: I've heard esqueleton improves on persistent, but I haven't used either...
03:25:48 <`Guest00000> which is the easiest way to randomly generate haskell datatype definitions?
03:26:27 <kuribas> `Guest00000: erm, Template Haskell?  Also what are you trying to do?
03:51:47 <_sras_> Does postgresql connections in the connection pool (provided by Data.Pool), have an expiration period after which they cannot be used? Can one connection from a pool be used exclusively by a single process indefinetly?
03:55:54 <NotAChicken> Has anyone tried making a kernel in Haskell
03:56:16 <oherrala> NotAChicken: check out HalVM
03:56:20 <NotAChicken> I can't find anything about it online
03:56:28 <NotAChicken> oherrala: thanks
03:59:27 * ski . o O ( "Haskell User's Operating System and Environment" <https://wiki.haskell.org/House>,<http://programatica.cs.pdx.edu/House/> )
04:04:05 <phaazon> arf, that xml-conduit‚Ä¶
04:04:11 <phaazon> there‚Äôs a Prologue type
04:04:17 <phaazon> I can barely understand how to use it
04:04:37 <phaazon> I just want to have something like <?xml version="1.0" encoding="UTF-8"?>
04:04:50 <phaazon> I guess I put everything in the ‚Äúbefore‚Äù part?
04:04:55 <phaazon> why making that so complicated? :(
04:05:31 <amx> _sras_: no. yes. but I'm not sure whether what you plan to do is a good idea.
04:08:09 <_sras_> amx: The long running process is an event listner that process events coming over a notification channel (Postgres notify/listen). Do you see any potential issues?
04:12:21 <amx> I am not at all familiar with that. What I meant is: I do not see the point of using Data.Pool in this fashion.
04:14:13 <amx> You just ask for a connection and typically one will already be open and ready for you, incurring no overhead. If you intend to keep a connection per $whatever you can just as well open it then and there without Data.Pool.
04:23:39 <kuribas> Could you use a logic language like prolog as a static type system?
04:24:01 <kuribas> (possibly non-terminating)
04:24:04 <Athas> Yes.
04:24:07 <erisco> kuribas, you can use all sorts of things as types
04:24:26 <kuribas> I mean, a type is just a proof about the value, isn't it?
04:24:33 <kuribas> (or predicate)
04:24:42 <erisco> you just need a relation of terms to types and then the consequences of the meaning of types ensues
04:24:51 <hpc> i expect you'd need to make some small changes to prolog just so you can define types with values instead of just saying something is true
04:25:30 <cocreature> in some sense typeclass resolution is already a form of logic programming
04:25:35 <erisco> kuribas, well, I have seen it be the other way around
04:26:07 <kuribas> though types are deterministic (a value has just one type), while a prolog relation is non-deterministing (can have more values).
04:26:27 <cocreature> a value does not always have only one type
04:26:36 <ski> kuribas : rather the value is a proof of the type ..
04:26:45 <kuribas> cocreature: like in a typeclass?
04:26:46 <Younder> Objects have type. Not variables.
04:26:49 <cocreature> if you‚Äôre lucky it has a type that‚Äôs more general than all other types but even that does not always need to be the case
04:27:24 <cocreature> e.g. if you don‚Äôt have polymorphic types, "Left 1" has a lot of different types and none of them is more general than the other types
04:27:57 <ski> hpc : like Twelf ?
04:29:01 <Younder> Even if you put a procedural restriction of the type to say a number many different types of number can be used.
04:29:46 <lyxia> I really want to write a quasiquote to do functional type class programming.
04:29:50 <ski> kuribas : like in a polymorphic value, like `Nothing' having both type `Maybe Int' and `Maybe String'. or like with subtyping, or intersection types
04:30:29 <cocreature> lyxia: what‚Äôs functional typeclass programming?
04:30:53 <kuribas> ski: yeah, that makes sense
04:36:08 <phaazon> http://imgur.com/a/5sO4h
04:36:13 <phaazon> any idea with that error?
04:36:21 <phaazon> Node is clearly defined :(
04:36:27 <phaazon> oh fuck.
04:36:29 <phaazon> nevermind.
04:36:32 <phaazon> it has several ctors
04:36:33 <phaazon> :‚Äì‚Äô)
04:37:05 <hpc> try :i Node
04:37:06 <ski> Younder : depends on one's conception of "type", yes ?
04:37:07 <lyxia> cocreature: I would also like to know, but vanilla type classes make it cumbersome for me to do type-directed Generic metaprogramming.
04:37:25 <hpc> and if Node is a type, you need :k
04:38:11 <cocreature> lyxia: seems like what you really want is functional programming at the type-level so just throw away type-classes and add dependent types to Haskell :)
04:38:24 <cocreature> or are you specifically interested in the implicit aspect of type-classes?
04:40:25 <lyxia> Yes, the fact that it is implicit and extensible
04:40:40 <erisco> my annoyance with metaprogramming in Haskell, at least as I understand your meaning, is this this...
04:41:15 <erisco> what we want to do is implement  x -> F x  for some type family F
04:42:05 <lyxia> Yes.
04:42:13 <erisco> the only way to give this implementation is with a type class because we need the implementation overloaded for each F x
04:42:43 <erisco> but the problem is that type families can express more type mappings than type classes can
04:43:04 <erisco> precisely because one may be closed whereas the other cannot
04:43:38 <erisco> and there is plenty of circumstance to desire or even need a closed definition
04:45:57 <erisco> but there is a trick shown to me by glguy iirc which does help
04:46:24 <erisco> lyxia, you can see it exercised here http://hackage.haskell.org/package/control-dotdotdot-0.1.0.0/docs/src/Control-DotDotDot.html
04:47:27 <erisco> lyxia, particularly pay attention to IsFun
04:47:53 <lyxia> Oh that's neat.
04:48:59 <erisco> so you can use the closed type family to select the correct instance
04:51:51 <erisco> but we can still desire more from metaprogramming that is just not expressible right now
04:52:30 <erisco> for example, iirc, the dotdotdot concept should generalise to types which are both categories and functors
04:52:45 <erisco> but there is no access to contexts in type functions
04:52:45 <lyxia> It really is neater when the instances don't overlap.
04:53:14 <erisco> well that is the point of the type family to select instances... so there is no overlap
04:53:44 <erisco> the only thing a category looks like to a type function is f a b, and the only thing a functor looks like is f a
04:56:49 <lyxia> f (f (f (f x))) -> c x y -> f (f (f (f y)))  for Functor f and Category c ?
04:57:13 <lyxia> ActualFunctor f c   perhaps
04:57:41 <erisco> yeah I think that is what it looked like
04:58:38 <erisco> Kleisli has both these instances, so I wanted the more general interface for this
04:59:36 <erisco> maybe with a clearer head I can think of how to do this now
05:02:14 <lyxia> EndoFunctor c f => c x y -> c (f (f (f x))) (f (f (f y)))
05:02:43 <lyxia> erisco: You can do it :)
05:02:45 <erisco> the implementation is easy
05:03:10 <erisco> it is the having the correct type mapping and selecting instances correctly that I was struggling with
05:09:31 <erisco> do you know of any special name for t if t is a category and t a is a functor?
05:09:56 <mniip> erisco,  a category?
05:10:16 <mniip> covariant hom-functor is always, well, a functor
05:10:35 <erisco> if that is a natural consequence of being a category why is this not represented in the category class?
05:12:17 <Cale> erisco: wha?
05:12:49 <Cale> erisco: In what way do you mean?
05:13:07 <erisco> maybe that is not possible to have a quantifier in that position... can't recall
05:13:34 <erisco> I... don't know what else to say about it
05:14:02 <Cale> t a will be a functor t -> t
05:14:14 <Cale> (using a weird mixture of Haskell and mathematics notation)
05:14:56 <Iceland_jack> class (forall a. Functor (cat a)) => Category cat
05:15:11 <Cale> Yeah, that wouldn't have the correct sentiment.
05:15:16 <erisco> yes that is it Iceland_jack. is the quantifier allowed there?
05:15:20 <Cale> Because Functor is a class for endofunctors on Hask
05:15:29 <Iceland_jack> It would be with http://i.cs.hku.hk/~bruno/papers/hs2017.pdf
05:15:36 <Cale> You would need a class for functors on an arbitrary category to express what is desired here
05:15:47 <`Guest00000> is subtyping good?
05:15:47 <Iceland_jack> And I'm fine with that :)
05:15:59 <Cale> `Guest00000: It has a lot of downsides, to be sure.
05:16:28 <erisco> well I don't care about sentiment
05:16:41 <Cale> `Guest00000: Personally, I think we're better off without it, just because of all the problems it causes for type inference, which tend to force people to write types of things much more than is otherwise comfortable.
05:16:50 <erisco> I am saying what is a name for a type t such that t is a Category and forall a. t a is a Functor
05:17:09 <Cale> Yeah, there's no special name for that.
05:17:21 <Cale> Well, hmm
05:17:38 <erisco> because that is a generalisation of dotdotdot
05:19:05 <`Guest00000> Cale: if we throw away type inference, which downsides are remaining?
05:19:57 <lyxia> What an odd generalization.
05:20:02 <ski> @where O'Haskell
05:20:02 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjˆrn von Sydow, at <http://web.archive.org/web/20090517021445/
05:20:02 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
05:20:04 <ski> @where Timber
05:20:04 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
05:20:13 <ski> `Guest00000 : perhaps those ^ would be interesting
05:20:24 <`Guest00000> thanks
05:20:38 <erisco> lyxia, well your suggestion of EndoFunctor may work too. I am not sure if they are equivalent or not, but either way it is not a base module
05:21:07 <erisco> so I am saying if I can stay within base that is preferential
05:21:20 <erisco> and it is easy to do so, so I will
05:22:14 <cocreature> f(f(a)) will only capture "b->b->a" not "b->c->a" so it‚Äôs not strictly more general
05:22:23 <ski> `Guest00000 : Erik Poll also has some papers re inheritance (for record types (cf. object types, "interfaces" (or abstract base classes) in OCaml,Java,C++,C#,Smalltalk,&c.)) and coinheritance (for variant types, basically algebraic data types)
05:22:27 <ski> @where ErikPoll
05:22:27 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
05:22:27 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
05:22:27 <lambdabot> pdf>
05:22:29 <ski> (first two papers)
05:22:49 <lyxia> cocreature: ah, good catch
05:23:16 <erisco> yes but that is not actually the type
05:24:04 <erisco> the spirit of the demonstration is correct... the quantifiers are not ;)
05:25:04 * hackagebot cuda 0.8.0.0 ‚Äì FFI binding to the CUDA interface for programming NVIDIA GPUs ‚Äì https://hackage.haskell.org/package/cuda
05:25:32 <cocreature> erisco: not sure what you are trying to say
05:25:57 <Cale> `Guest00000: Well, beyond that, it begins to depend on the details of exactly what we mean by "subtyping". Coercions may or may not be coherent (i.e. perhaps A <: B and B <: D, but also A <: C and C <: D, and we'd like to conclude that A <: D, but perhaps there are two behaviourally different ways to manage that)
05:27:11 <Cale> It's also often unclear how, if at all, subtyping ought to interact with other features of our type systems.
05:27:31 <ski> implicit coercions ought to be coherent
05:27:41 <Cale> Yeah, one should hope :)
05:28:01 <erisco> cocreature, I'd rather clarify just with the specifics so I'll get back to you later
05:28:49 <ski> (there's some classic(?) paper on this, that i don't recall the title nor the author(s) of, i think)
05:28:51 <Cale> Let's say we have type classes. While we're doing instance resolution, if we have A <: B, and there's an instance of class C for B, does that imply that there's an instance for A?
05:28:54 <bartavelle> are there specific monad laws for state, reader or writer that are not given by parametricity or the standard monad laws?
05:29:11 <bartavelle> (and what are these laws anyway? I could find some for state, but none for the others)
05:29:16 <Cale> (The answer might be "sometimes")
05:29:26 <ski> Cale : depends on whether `C' is covariant, contravariant, both, or neither ?
05:29:44 <Cale> ski: Yeah
05:29:53 <bartavelle> (and I suspect the laws for state might be free)
05:29:57 <erisco> bartavelle, the exact wording of your question is incoherent... the monad laws are just the monad laws. none are specific to any instance
05:30:25 <bartavelle> erisco: alright, state/writer/reader specific laws that are not directly a consequence of parametricity/monad laws
05:30:31 <Cale> bartavelle: There are certainly additional laws (though not "monad laws") which probably ought to be satisfied by instances of those classes.
05:31:28 <bartavelle> I could find some in this blog for state http://www.cse.chalmers.se/~nicsma/no-state-monad.html
05:31:36 <bartavelle> (in the "Unintended consequences of the state monad laws
05:31:37 <bartavelle> ") part
05:31:44 <ski> bartavelle : stuff like `get >> get = get', `get >>= put = return ()', `put x >> put y = put y', `put x >> get = put x >> return x', &c. ?
05:31:49 <bartavelle> yes
05:31:53 <bartavelle> aren't these free ?
05:31:59 * ski doesn't know
05:32:10 <erisco> is question but not is valid... an exercise in judgments
05:32:11 <bartavelle> with parametricity, it looks like you can't change "s", so they should hold
05:33:03 <Cale> They're not "free"
05:33:09 <bartavelle> and are there other known laws for reader/writer ?
05:33:19 <Cale> You can certainly write instances of MonadState for which those would fail
05:33:36 <bartavelle> Cale: without resorting to bottom ?
05:34:01 <Cale> Sure, we could have 'get' obtain a different value every time.
05:34:03 <bartavelle> ah perhaps something with a put "memory"
05:34:46 <erisco> ski, did you read "A Flexible Semantic Framework for Effects"?
05:34:47 <Cale> There's nothing which ensures that get is actually reading from memory at all
05:34:56 <ski> erisco : i don't think so
05:34:57 <Cale> It might be obtaining its value from user input
05:35:17 <bartavelle> Cale: not for "forall s.", except if you have several "put" beforehand
05:36:17 * hackagebot haskey 0.1.0.1 ‚Äì A transcatoinal, ACID compliant, embeddable key-value store. ‚Äì https://hackage.haskell.org/package/haskey
05:36:25 <erisco> ski, I just thought it interesting because they describe those very things with a semilattice
05:36:33 <Cale> There's no guarantee of parametricity because you have a MonadState s m constraint
05:36:43 <opqdonut> yeah, you can't change s inside the omnad
05:36:48 <bartavelle> but can't you state the laws for all s ?
05:36:57 <Cale> Which laws?
05:36:57 <opqdonut> that doesn't matter
05:37:00 <ski> `newtype Supply s a = MkSupply (Stream s -> (Stream s,a))', `get = MkSupply (\(Cons s ss) -> (ss,s))', `put s = MkSupply (\ss -> (Cons s ss,()))', &c.
05:37:05 <bartavelle> "get >>= put = pure ()" for example
05:37:09 <Cale> You can add certain laws like that
05:37:16 <erisco> ski, the effect of a put followed by a get is a put, for example, as you also state
05:37:16 <Cale> But they don't hold "for free"
05:37:19 <Cale> You have to prove them
05:37:24 <ski> erisco : "those very things" being ?
05:37:29 <bartavelle> yes, I see it now how they do not for get
05:37:33 <Cale> It might be possible to use parametricity to prove them if your instances are polymorphic
05:37:42 <bartavelle> ski: that is a good example, but relies on a specific state
05:37:58 <erisco> ski, they give meaning to effects generally, and get/put/modify/return are examples they use
05:38:00 <Cale> It's possible that we have only MonadState Int MyMonad
05:38:12 <Cale> and that MyMonad implements get by asking the user for a number
05:38:21 <bartavelle> Cale: well, given that you can store all "put" and have get return a random value that it stored, parametricity is not enough, I see this now
05:38:42 <Cale> Ah, yeah, on its own for sure
05:39:10 <bartavelle> (or even just work like the reader monad, put being a noop)
05:39:13 <ski> bartavelle : "relies on a specific state" ?
05:39:43 <bartavelle> ski: no I am wrong, I did not read properly what you wrote, that is a good example!
05:39:46 <Cale> You might also have a runState which takes a nonempty collection of values of type s just so that it can start producing random results sooner :)
05:40:41 <Cale> Also, ask being a no-op is another thing you can't really guarantee
05:40:47 <Cale> without proving it
05:40:56 <bartavelle> yeah, I can see how I could devise laws for ask
05:41:03 <bartavelle> what about writer ?
05:41:26 * ski . o O ( lawless sequences )
05:42:12 <Cale> (do tell x; v <- act; tell y; return v) = (do tell (mappend x y); act)
05:42:31 <bartavelle> hum that is a nice one
05:42:47 <Cale> Well, you could see that as a composite of two simpler laws
05:42:57 <erisco> I thought it rather exciting because effects are important to programming and we can always use better ways to reason about them
05:43:15 <bartavelle> (and I did not get what ski said, if that was an answer to my question)
05:43:22 <Cale> tell x >> tell y = tell (x <> y)
05:43:23 <erisco> I also found http://hackage.haskell.org/package/effect-monad today and I am not sure how it relates to the semantic work (if at all). Haven't read the paper yet
05:43:44 <erisco> but they have exciting examples such as statically proving the linear time complexity of list mapping
05:43:49 <erisco> *in Haskell*
05:44:05 <erisco> by using a counting effect
05:44:07 <Cale> and  act >>= (\v -> tell x; f v) = tell x >> (act >>= f)
05:44:14 <Cale> oh, oops
05:44:18 <Cale> Yeah, that's actually not true
05:44:19 <bartavelle> no this one is wrongh
05:44:20 <Cale> haha
05:44:39 <Cale> It's only true in cases where act doesn't involve a tell
05:44:45 <bartavelle> yup
05:44:46 <Cale> So, perhaps we should just write it with lift
05:44:52 <bartavelle> the first one you gave looked better
05:45:10 <erisco> I have always thought that time and space analysis should be a static part of programs
05:45:18 <erisco> it has always been a relevant part of specifications
05:45:18 <Cale> bartavelle: But it fails in the same way
05:45:29 <bartavelle> ah indeed! !!!
05:45:58 <bartavelle> hum, that is a bit lame if we can only reason about subsequent tells
05:46:16 <bartavelle> or we would need something a bit stronger than monoid
05:46:37 <Cale> Well, there should at least be something regarding associativity.
05:46:42 * bartavelle is acutally learning coq, and proving laws for one of his monads
05:46:47 <Cale> I dunno
05:46:56 <Cale> actually, that might not be necessary
05:47:08 <bartavelle> tell x >> tell y >> tell z = tell (x <> y) >> tell z = tell x >> tell (y <> z) ?
05:47:09 <Cale> Yeah, the one with >> vs. <> is enough
05:47:13 <bartavelle> yes
05:47:45 <ski> erisco : a type (and module) system tracking (at least) time complexity would be interesting, yes. i suppose something like `(++) :: (xs ::) [a] -> [a] -> [a] is O(length xs)', perhaps
05:48:10 <bartavelle> Cale: thanks for humoring me!
05:48:14 <Cale> bartavelle: Those become laws of WriterT if we replace act by lift act though
05:48:34 <bartavelle> ah
05:48:36 <bartavelle> indeed
05:48:41 <Cale> It's just, we don't have an appropriate general method to be able to refer to that operation.
05:49:12 <bartavelle> why ?
05:49:32 <Cale> Well, there's no guarantee *in general* that lift act won't tell.
05:49:41 * ski . o O ( `(MonadTrans t,MonadWriter w (t m),Monad m,Monoid w)' )
05:50:01 <Cale> t m might get its MonadWriter instance from m
05:50:11 <bartavelle> but that would be another writer?
05:50:22 <bartavelle> you mean nested writers ?
05:50:23 <ski> bartavelle : "lawless sequences" was in response to "takes a nonempty collection of values of type s just so that it can start producing random results sooner"
05:50:25 <Cale> No
05:50:38 <ski> Cale : point
05:50:41 <Cale> I mean, any other transformer applied to something which is already a MonadWriter, and for which there's a lifting instance
05:51:09 <Cale> e.g. StateT s (Writer w)
05:51:10 <ski> e.g. `MaybeT (Writer w)'
05:51:15 <Cale> yeah
05:51:32 <bartavelle> but I am good for WriterT w (StateT s), right ?
05:51:36 <Cale> yes
05:51:49 <bartavelle> hum
05:51:54 <Cale> You're good if and only if WriterT is the transformer being applied
05:51:54 <ski> why do we want to state a law involving `lift' here ?
05:52:18 <bartavelle> ski: to make sure there is no "tell" in actions that are chained
05:52:19 <Cale> ski: Well, we can say that tells commute with any lifted action
05:52:27 <Cale> (in WriterT)
05:52:47 <Cale> But there's no way to write an analogous law for MonadWriter generally
05:53:05 <bartavelle> yeah, that makes sense now
05:53:09 <Cale> Even if we assume that WriterT is involved somewhere
05:53:29 <Cale> We'd have to know where, or define a special class for "lift things from below any WriterT"
05:53:30 <ski> well, the whole idea of refering to monad transformers by position is broken, imho
05:53:41 <Cale> yes
05:53:45 <Cale> I agree with that
05:54:36 <ski> i think we need to be able to name the components. some of them should automatically commute with each other, while others shouldn't
05:54:38 <erisco> ski, also cool about that semantics paper is it reveals how to flatten transformers
05:54:39 <Cale> But it's sort of sad in this case, that we have no way to state a law which we may want to use.
05:54:49 <ski> erisco : also handling `Cont o' ?
05:54:50 <erisco> ski, not explicitly, but I think it can be extrapolated to Haskell
05:55:07 * ski nods to Cale
05:55:25 <erisco> ski, well it only touches on a few effect examples and continuation-passing is not one they went into any depth on
05:56:02 <erisco> I am looking at http://hackage.haskell.org/package/effect-monad soon to figure out what they've accomplished
05:56:07 <ski> (istr looking a little at some other attempts of handling effects. often they seem to not work well for `Cont o')
05:56:16 <erisco> transformer stacks work but they're a royal PITA
05:56:26 <ski> agreed
05:56:51 <Cale> Oh, we *could* write a law like that for censor though
05:57:41 <ski> Cale : hm, i suppose the same issue occurs with `local' ?
05:58:09 <Cale> ski: local is, well, local though.
05:58:34 <Cale> So you can state non-interaction laws for ask without worrying about it much
05:59:25 <ski> i mean something like `local f (lift act) = lift act'
05:59:29 <Cale> ah
05:59:35 <Cale> yeah
06:00:35 * hackagebot nvvm 0.8.0.0 ‚Äì FFI bindings to NVVM ‚Äì https://hackage.haskell.org/package/nvvm
06:00:38 <Cale> listen (lift act) = fmap (\v -> (v,mempty)) (lift act)
06:01:34 <Cale> pass (lift act) = fmap fst (lift act)
06:02:01 <Cale> There are lots of laws satisfied by WriterT which can't be stated for MonadWriter
06:03:06 <Cale> We can use pass to get something analogous to lift though
06:03:26 <Cale> cancel = pass (fmap (\x -> (x,const mempty)))
06:03:33 <Cale> oops
06:03:40 <ongy> hm, I'm wrapping something into an ffi layer and I'm wondering... I have a module <path>.Backend which exposes functions to create/start/destroy. Currently I'm going with backend(Create/Start/Destroy) names close to the C function names, but it seems a bit doubled with modules
06:03:41 <Cale> cancel x = pass (fmap (\x -> (x,const mempty)) x)
06:04:05 <Cale> grr, I reused x ;)
06:04:16 <ongy> on the other hand, if we don't asume everyone uses the module qualified, the more verbose names would be more informative than just create/start/destroy
06:04:45 <Cale> ongy: It's quite common to want to import modules unqualified in Haskell
06:04:59 <Cale> ongy: I could go either way on that issue
06:05:02 <ongy> I'm aware. That's why I'm wondering which way would be better
06:05:36 <Cale> On the other hand, those *specific* names don't immediately conflict with other stuff
06:05:53 <Cale> So it's possible that you could get by importing the module unqualified *anyway*
06:06:12 <Cale> (even with the short names)
06:06:35 <ongy> I'm thinking more about how it would be to read than naming collisions
06:06:47 <Cale> right
06:07:04 <Cale> Maybe 'start' is a bit too vague on its own :)
06:07:22 <ongy> exactly
06:07:31 <Cale> So that's an advantage of using a more particular name and not relying on qualified imports
06:07:49 <ongy> I think I'll keep the verbose naming then
06:08:14 <bartavelle> ongy: maybe you can export them with the short names for a "low level" module, and export nicer facilities that hide the resource management and more informative names for the users? 5x the work thouhg ;)
06:09:14 * hackagebot speculate 0.2.9 ‚Äì discovery of properties about Haskell functions ‚Äì https://hackage.haskell.org/package/speculate
06:09:47 <Cale> -_- I have 270 followers on Google+ and my profile is completely blank.
06:10:52 <Clint> how many of them are spambots
06:10:54 <byorgey> Cale: there's only one possible explanation I can think of: you are just that cool.
06:11:20 * Ferdirand resists the urge to follow just for the pleasure of contradiction
06:11:33 <erisco> huh, glad you mentioned that paper Iceland_jack... seems I can't get this done with monomorphic constraints
06:12:19 <Cale> Clint: It's hard to tell, but many of them clearly aren't.
06:12:34 <bartavelle> Cale: they are just all waiting for your big reveal
06:13:03 <ski> erisco : ohh .. interesting paper :)
06:13:15 <erisco> ski, the effect semantics paper?
06:13:33 <Cale> I wonder if there's some way that people who have me in their contacts list in Gmail or Hangouts or something are automatically counted as followers.
06:14:22 <byorgey> Cale: that wouldn't surprise me.
06:14:45 <ski> erisco : "Quantified Class Constraints"
06:14:55 <ski> (haven't checked the other yet)
06:15:08 <Iceland_jack> erisco: You can fake it with https://hackage.haskell.org/package/constraints/docs/Data-Constraint-Forall.html from edwardk
06:15:08 <Cale> It's annoying because I don't know exactly what these people are notified of. Do all my random comments on YouTube go into someone's list of what's new somewhere?
06:15:59 <erisco> Iceland_jack, hey thanks!
06:18:03 <Cale> Apparently just one of my YouTube comments is possible to find if you search for my name on Google+, but none of my others for some reason. Oh well, whatever, this is offtopic :)
06:19:43 <ski> Iceland_jack : (re <https://typesandkinds.wordpress.com/category/type-families/>), i've been .. unnerved by this strange non-totality behaviour of type families as well
06:20:39 <Iceland_jack> ski: Richard addresses it with http://cs.brynmawr.edu/~rae/papers/2017/partiality/partiality-extended.pdf
06:20:43 <Iceland_jack> Constrained type families
06:20:54 <ski> ty
06:21:07 <Iceland_jack> captures their non-totality with a type class constraint, basically
06:21:57 <Iceland_jack> erisco: You have to manipulate the witnesses explicitly
06:22:09 <Iceland_jack> using Data.Constraint.Forall, either by pattern matching or (\\)
06:24:53 * hackagebot haskell-tools-ast 0.9.0.0, haskell-tools-backend-ghc 0.9.0.0, haskell-tools-prettyprint 0.9.0.0, haskell-tools-refactor 0.9.0.0, ‚Ä¶ and 1 more
06:24:54 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
06:29:57 * hackagebot cufft 0.8.0.0, haskell-tools-cli 0.9.0.0, haskell-tools-debug 0.9.0.0, haskell-tools-demo 0.9.0.0
06:29:57 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
06:31:02 <erisco> Iceland_jack, I have a suspicion there is a runtime component to it then
06:53:34 <NotAChicken> What are the best things you can do with Haskell?
06:54:03 <erisco> is there a class for things with  f a b -> a -> b  ?
06:54:53 <ski> sortof a `Copointed', but for `Arrow'/`Category', i suppose
06:55:01 <lyxia> NotAChicken: haskell compilers
06:55:18 <erisco> NotAChicken, the best thing you can do is type your programs and program without fear of effects
06:55:32 <mnoonan> erisco: ArrowApply, maybe?
06:55:40 <erisco> app :: a (a b c, b) c   so no
06:55:57 <mnoonan> huh, "such arrows are equivalent to monads"
06:56:29 <ski> erisco : <https://en.wikipedia.org/wiki/Concrete_category>, so perhaps `class Category cat => Concrete cat where underlying :: cat a b -> (a -> b)' ?
06:58:19 <ski> a law would be that `underlying' is injective, i suppose
06:59:15 <ski> (perhaps `Concrete' should be named `Construct', though)
07:03:04 <erisco> ski, thanks I'll think about it
07:04:18 * hackagebot safecopy 0.9.3.3 ‚Äì Binary serialization with version control. ‚Äì https://hackage.haskell.org/package/safecopy
07:04:56 <ski> (i suppose you could ask people, if you're unsure about whether your `underlying' is injective)
07:26:04 <jchia_> I have a ghc panic while building a large private code base. Is there a simple way to effectively report the bug without sharing the entire code base?
07:45:45 * hackagebot arrowp-qq 0.2.1 ‚Äì A preprocessor and quasiquoter for translating arrow notation ‚Äì https://hackage.haskell.org/package/arrowp-qq
07:52:28 <Unode> when using stackage vs hackage. Is there any special syntax to each? Sometimes when searching (i.e Data.Text.Internal.Text) on hackage I get a direct hit while on stackage I get nothing of the sort other times it's the other way around.
07:52:48 <Unode> so I end up search on both all the time...
07:56:09 <MarcelineVQ> things on stackage come from hackage. if you find things on stackage and not on hackage that sounds like a limitation of the search you're using
07:58:48 <MarcelineVQ> I tend to use http://hoogle.haskell.org/ since it's usually pretty good about finding something, if you have an idea of what you're after
08:00:41 <MarcelineVQ> now, there is special syntax, but it doesn't seem to improve the results for that particular item on stacakge :(  https://www.stackage.org/lts-9.1/hoogle?q=package%3Atext+Data.Text.Internal.Text    http://hoogle.haskell.org/?hoogle=package%3Atext+Data.Text.Internal.Text&scope=set%3Astackage
08:01:59 <MarcelineVQ> I think it's because text comes with ghc, at least I think it does, and things that come with ghc aren't listed in the resolvers
08:02:39 <MarcelineVQ> hmm, nah, that's not a good enough theory, it finds Data.Map just fine
08:03:37 <MarcelineVQ> and text is in the resolver, so that's surely not the right idea anyway :(
08:09:46 <sm> Unode: how are you searching ?
08:10:48 <Unode> https://www.stackage.org/lts-9.1/hoogle?q=Data.Text.Internal.Text vs https://www.haskell.org/hoogle/?hoogle=Data.Text.Internal.Text
08:11:38 <Unode> sm: sometimes with "TypeA -> TypeB"
08:12:33 <Unode> MarcelineVQ: thanks. I don't really get it either. Just that I get different results and since stackage is what was recommended by a co-worker I wonder if I'm doing something wrong.
08:13:02 <Unode> and since I'm still fresh to haskell, I use it all the time.
08:14:39 <sm> Unode: it might be that the stackage hoogles don't search module and package names
08:14:40 <mnoonan> Unode, they might be different hoogle versions. hoogle 5 seems to have a worse type search than hoogle 4 in many cases.
08:14:59 <sm> you might check/report it in their issue tracker
08:17:29 <Unode> mnoonan: if that's the case, how would you search something like this? I was actually looking for "Text -> String" at some point. hoogle pointed me in the right direction. Stackage didn't give anything useful.
08:18:34 <mnoonan> I don't know, that is pretty weird
08:19:26 <sm> also, not all hoogles do proper type searching. haskell.org/hoogle does, hoogle.haskell.org does not, stackage hoogles I don't know about
08:19:47 <Unode> sm: I'd rather not fight with issues right now. If stackage is used I figured other people might have encountered this problem and either a) have a workaround or b) reported it already. A quick search didn't return any report.
08:19:59 <mnoonan> but sure enough, I don't get much good if I search on haskell.org's hoogle 5 either: http://hoogle.haskell.org/?hoogle=Text%20-%3E%20String
08:20:22 <Unode> mnoonan: maybe what sm just said.
08:20:40 <mnoonan> anyway, that suggests it is a hoogle 5 issue, not a stackage vs hackage issue
08:20:50 <Unode> so is hoogle 5 a major regression or am I missing something? :)
08:21:16 <MarcelineVQ> only for type search :X
08:21:33 <mnoonan> ah, yes, but who would want to use hoogle for a type search :|
08:21:45 <Unode> <- a newbie
08:22:02 <Unode> @hoogle Data.Text.Internal.Text
08:22:03 <lambdabot> Data.Text.Internal data Text
08:22:03 <lambdabot> Data.Text.Internal Text :: Array -> Int -> Int -> Text
08:22:03 <lambdabot> Data.Text.Internal.Lazy data Text
08:22:08 <Unode> @hoogle+ Data.Text.Internal.Text
08:22:08 <lambdabot> Data.Text.Internal text :: Array -> Int -> Int -> Text
08:22:08 <lambdabot> Data.Text.Internal textP :: Array -> Int -> Int -> Text
08:22:08 <lambdabot> Data.Text.Internal showText :: Text -> String
08:22:08 <mnoonan> sorry, that was supposed to be heavily sarcastic. I think type search is one of the best aspects of Haskell, discoverability-wise
08:22:32 <Unode> @hoogle Text -> String
08:22:33 <lambdabot> Data.Text pack :: String -> Text
08:22:33 <lambdabot> Data.Text.Lazy pack :: String -> Text
08:22:33 <lambdabot> System.Console.CmdArgs.Text Line :: String -> Text
08:22:39 <Unode> @hoogle+ Text -> String
08:22:39 <lambdabot> System.Glib.UTFString stringToGlib :: String -> Text
08:22:39 <lambdabot> Text.Shakespeare pack' :: String -> Text
08:22:39 <lambdabot> Database.Persist.TH packPTH :: String -> Text
08:22:43 <Unode> yikes
08:23:07 <Unode> ok.. guess I found my answer
08:23:12 <Unode> thanks everyone
08:23:24 <sm> from my extensive testing just now: search by module name ? stackage/hoogle no, haskell/hoogle no, hoogle.haskell yes. search by package name  ? stackage/hoogle no, haskell/hoogle yes, hoogle.haskell yes
08:23:27 <Unode> I'll use Text.Shakespear from now on.
08:24:07 <mnoonan> Unode: wait, what? it sounds like you just want "unpack"
08:24:08 <Unode> accidental typo = accidental pun = more fun
08:24:51 <Unode> mnoonan: yes, that's what I found. But found other misleading answers in the meanwhile.
08:25:31 <Unode> Text.Shakespear (without the e) was me doing the same sarcasm you did back there :) with an accidental pun.
08:27:52 <Unode> It's still surprising though why Text -> String returns String -> Text ...
08:28:35 <Unode> alphabet type ordered?
08:29:35 * hackagebot ngx-export 0.6.1.0 ‚Äì Helper module for Nginx haskell module ‚Äì https://hackage.haskell.org/package/ngx-export
08:42:35 <tomasmu> hello
08:44:02 <tomasmu> so, i registered on hackerrank yesterday, and since i knew nothing about haskell i thought i'd try the "30 days of code" thing
08:44:14 <tomasmu> but i got stuck on day 0 :D
08:45:59 <tomasmu> however, i installed winghci, and have gotten the same program to work locally, so the problem is probably on hackerrank's end
08:46:24 <tomasmu> so uh, has anyone had any experience with this? :)
08:47:21 <Cale> tomasmu: I don't have any experience with it, but what is the problem?
08:47:24 <sm> walk us through it tomasmu :)
08:50:08 <Unode> tomasmu: some solutions on those kinds of websites are correct in terms of the result they produce but are incorrect in terms of "how long they take".
08:50:57 <Unode> I remember one case where you were supposed to solve a problem by only mapping/looping over the input once, instead of twice which would be the most common use-case.
08:51:25 <Unode> You might be hitting one of these cases.
08:51:35 <tomasmu> i'll resort to pseudocode to explain the problem to be solved; function somefunction(inputString) { print("hello world"); print(inputString); }
08:51:48 <Cale> huh
08:51:54 <Unode> tomasmu: that looks like javascript :)
08:52:09 <Cale> tomasmu: What was your solution?
08:52:10 <tomasmu> heh yeah, only that it's called console.log() :)
08:53:02 <Cale> Perhaps it has something to do with newlines?
08:53:10 <Cale> Did you use putStr or putStrLn?
08:53:50 <tomasmu> here it is, the one that is working locally with ghc -o etc: https://pastebin.com/RHrHujpP
08:54:01 <tomasmu> i gracefully stole the intercalate function from somewhere
08:54:08 <benzrf> ^_^
08:54:29 <Cale> and the program is supposed to get its input from commandline args?
08:54:39 <benzrf> tomasmu: pro tip: pastebin.com is arguably the worst pastebin out there; it has ads and kind of a gross layout and stuff
08:54:42 <Cale> You're sure it's not supposed to read standard in?
08:54:46 <benzrf> i'd recommend using lpaste.net
08:54:57 <tomasmu> but when i input this in hackerrank, it's an empty output
08:55:33 <tomasmu> benzrf: ah, good tip, apparently i didn't know because of adblocker :)
08:55:52 <Unode> tomasmu: how is the code supposed to receive its input?
08:56:16 <Unode> I don't remember this particular example, but most of the ones I recall involved reading from a file and not via getArgs
08:57:25 <benzrf> tomasmu: also it lets people search pastes, which is probably not what you want a lot of the time
08:57:29 <tomasmu> Cale: now when you mention it, it says "Input (stdin)"
08:57:38 <benzrf> aha, that'd be it
08:58:06 <Unode> tomasmu: don't they provide some template code? Usually the 'reading from stdin' part is already included in the solution.
08:58:36 <tomasmu> but in the C# solution, they have void Main(String[] args) in their template
08:58:47 <tomasmu> Unode: it's empty for haskell
08:59:01 <Unode> sad ... :)
08:59:14 <tomasmu> yeah :)
08:59:39 <tomasmu> could IO.readLn be what i want then?
09:03:28 <remexre> Is there any way to have a cyclic dependency graph?
09:03:39 <Cale> tomasmu: getLine perhaps? I don't know.
09:04:03 <Cale> remexre: You have to make hs-boot files if you really want to do that, unfortunately.
09:04:25 <remexre> Ok, can you (or someone else) help me structure something then?
09:04:49 <remexre> I'm making a compiled/interpreted language, and my Value type has a BuiltinFunction ([Value] -> InterpreterMonad Value)
09:04:51 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules
09:05:07 <tomasmu> perhaps it's time to actually open Learn you a haskell for great good, i did buy the physical book some time ago :D
09:05:16 <remexre> So the Value needs to depend on the Interpreter needs to depend on the Value etc...
09:05:26 <Cale> remexre: Usually the solution is to pull types out into their own module
09:05:44 <remexre> So separate the Interpreter monad from the Interpreter module?
09:06:14 <byorgey> remexre: yes, exactly.  I am developing a language like that too.   I have one module that defines the Value type, the interpreter monad definition, and a few utility functions
09:06:20 <byorgey> the actaul interpreter is in a different module.
09:06:25 <remexre> ok
09:06:28 <remexre> thanks!
09:07:14 <byorgey> in my case the definition of the interpreter monad depends on Value too =)
09:07:35 <byorgey> because it has (essentially) a   ReaderT (Map Name Value)  component
09:08:16 <remexre> Yeah, mine has an additional complication for non-builtin functions depending on an AST, which I'm passing in as a polymorphic parameter
09:08:29 <tomasmu> Cale: yep, getLine did the trick, readLn expects a string in haskell format apparently
09:08:34 <tomasmu> thanks everyone :)
09:09:43 <Cale> tomasmu: Yeah, readLn will parse whatever input provided as whatever type of result is demanded of it
09:10:18 <Cale> tomasmu: So if you were to use the result of readLn as an Integer, it would parse its input as an Integer
09:10:37 <tomasmu> ohh
09:10:41 <Cale> (and since you're using the result as a String, it reads a String as input, and expects it to be quoted)
09:12:40 <tomasmu> cool, thanks
09:12:55 <remexre> byorgey: ugh, wait, I have the same thing; how did you resolve it for yours?
09:49:23 <arkeet> edwardk: I was playing around with bound and thinking about the Bound class some
09:49:38 <Lokathor> will base ever get a newtype based set of types for time values and their conversions?
09:50:02 <Lokathor> so that you can say something like (Seconds 5) and it'll make it micro or milli for you as the function calls for?
09:50:34 <arkeet> so if we have Bound t, and t m is really a Monad, then t really is a MonadTrans, with lift m = return m >>>= id
09:51:11 <arkeet> so Bound and MonadTrans are almost the same thing
09:52:17 <lyxia> return m >>= id = m
09:52:55 <edwardk> arkeet: yes, this is why there is the default instance there.
09:53:08 <edwardk> there are just left modules that aren't monads
09:53:17 <edwardk> er s/default instance/default signature/
09:53:29 <lyxia> ah it's >>>=
09:53:59 <arkeet> sure, and I guess the only extra thing we get is that sums of Bounds are also Bound.
09:54:30 <edwardk> not the only extra thing
09:54:36 <arkeet> hm?
09:54:47 <edwardk> look in the examples for lots of other instances
09:54:55 <edwardk> patterns, alts, etc.
09:55:04 <edwardk> its a common pattern
09:55:38 <edwardk> if you have a list of case alternatives for a language you can often do substitutions into the bodies of those alts, even if they aren't monadic themselves
09:55:53 <arkeet> ok, not just sums, but we can precompose with any functor
09:56:03 <arkeet> er left compose
09:56:47 <arkeet> oh yeah, my other comment was going to be that they are really right modules. :p
09:57:18 <edwardk> if we moved Bound away from a class that had to be parametric in m to something that just required it to work for some m, then there'd be a whole lot more left modules you could express
09:57:45 <edwardk> t (m a) -> t a   t is on the outside
09:57:54 <arkeet> no, but t m . m -> m
09:57:56 <arkeet> m acts on the right.
09:58:01 <arkeet> from (>>>= id)
09:58:10 <arkeet> er, t m . m -> t m 
09:59:10 * hackagebot grakn 0.2.0 ‚Äì A Haskell client for <http://grakn.ai Grakn> ‚Äì https://hackage.haskell.org/package/grakn
09:59:17 <arkeet> yeah, I was playing around with non-parametric ones
10:00:17 <edwardk> you're right.
10:00:30 <edwardk> i'll take a doc fix =)
10:00:33 <arkeet> :-)
10:00:53 <arkeet> but e.g. anything that supports mapMaybe is a right module over Maybe, etc
10:01:27 <arkeet> I didn't come up with any other interesting ones I guess.
10:02:57 <arkeet> and the free m-module on a functor f which is just f . m
10:03:07 <norc_> Does haskell have the notion of free variables?
10:03:41 <ski> expressions (and definitions) certainly can have free variables, in Haskell
10:04:09 <norc_> ski: I mean it's a matter of perspective is it not? I mean ultimately it has to be bound
10:04:16 <ski> (what do you mean by something being a "free variable" ?)
10:04:19 <norc_> Heh.
10:04:41 <ski> certainly, being a free variable is relative to a certain subphrase that you're considering
10:04:44 <norc_> ski: Well GHCi wont let me define something like: a = \x -> y
10:04:47 <arkeet> curiously, monad transformers also give us actual left modules, by join . lift :: m (t m a) -> t m a
10:04:50 <norc_> (assuming y was not previously defined)
10:04:56 <arkeet> (and left module + monad is again monad transformer)
10:05:34 <arkeet> and m . f is a free left module
10:05:41 <norc_> ski: But okay, so it's the same notion as in lambda calculus, where freedom is just a question of "within that expression"
10:05:42 <arkeet> but I didn't come up with any others
10:05:43 <ski> `x' is not free in the definition (of `f') `f x = x * x', but it is free in the subexpression `x * x'. otoh `(*)' is free both in this expression, and in the whole definition
10:06:26 <norc_> ski: Right, but (*) is not free in.. well. The context of the program (is Prelude responsible for (*) existing?)
10:06:26 <ski> norc_ : right. and yes to "I mean it's a matter of perspective is it not? I mean ultimately it has to be bound"
10:06:52 <ski> @index (*)
10:06:52 <lambdabot> GHC.Exts, Prelude, GHC.TypeLits
10:07:18 <ski> if you don't import something else, then surely you access `(*)' by the implicit import from `Prelude'
10:07:39 <norc_> ski: Are there any intrinsics haskell provides if prelude was empty?
10:07:52 <ski> (whether it is defined in `Prelude', or in some other module imported by it, is immaterial)
10:07:58 <norc_> Yeah.
10:08:53 <norc_> Okay I gotta run catch the train, will be back in a bit. Thank you ski.
10:10:32 <ski> norc_ : there's the `NoImplicitPrelude' language extension you can play with (also see `RebindableSyntax'), <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XNoImplicitPrelude>
10:15:02 <byorgey> remexre: oh, sorry I missed your question.  The same way as the other problem: as long as the Value type and the interpreter monad type are defined in the same module, they can both depend on each other.
10:15:34 <remexre> Okay, so there's no way to do it while keeping the interpreter separate? Darn :(
10:16:11 <byorgey> no, just the definition of the interpreter monad *type* has to go in the same module with the definition of the Value type.
10:16:23 <byorgey> The actual implementation of the interpreter can go in a separate module if you want.
10:16:49 <remexre> Yeah, but I'm trying to keep everything about the interpreter separate
10:16:51 <remexre> ah well
10:17:13 <glguy> If the Value type and Interpreter type are inter-defined they you can't keep them separate because they aren't separate. You can still use recursively defined modules via .hs-boot to split up the files, however
10:17:14 <byorgey> well, but, it *isn't* separate!
10:18:26 * byorgey thinks of .hs-boot files as the nuclear option and has never used them
10:18:30 <remexre> glguy: Yeah, I'm trying to avoid hs-boot...
10:18:50 <glguy> I think people overestimate how much trouble they cause
10:19:03 <byorgey> I think it makes the code a lot harder to read & understand.
10:19:16 <byorgey> I'm sure they don't cause much trouble from a technical point of view.
10:19:17 <remexre> byorgey: yeah... wishful thinking... honestly, the normal value type "should" probably be separate from the RuntimeValue type too, but...
10:19:36 <glguy> It's a trade-off. Cramming everything into a single module isn't necessarily a readabilty improvement, even if the modules don't stand on their own
10:19:48 <byorgey> that's true.
10:20:01 <millew> Can someone please tell me how to import this package (https://hackage.haskell.org/package/wx-0.92.3.0/docs/Graphics-UI-WX.html#g:1), I'm using the 'import' command in Haskell but it says that it can't find the module
10:20:31 <glguy> millew: You'll have to install the package before you can import modules from it
10:21:16 <ski> remexre : perhaps you could parameterize `Value' on `InterpreterMonad'
10:21:16 <millew> glguy: how would I do that, is there a button on the webpage I am not seeing
10:21:51 <remexre> ski: hmmm... So data Value m = BuiltinFunc ([Value] -> m Value) | blah ?
10:22:20 <glguy> millew: Typically you do it by adding a dependency on the wx package to your particular .cabal file and then use 'cabal install --dep'
10:22:58 <millew> glguy: Thank you very much, I will do that :)
10:22:59 <ski> remexre : iow, instead of `data Value = .. | BuiltinFunction ([Value] -> InterpreterMonad Value) | ..' you do `data Value m = .. | BuiltinFunction ([Value m] -> m (Value m)) | ..', and then instead of using `InterpreterMonad Value', you use `InterpreterMonad (Value InterpreterMonad)'
10:23:21 <ski> remexre : basically yes, sans extra corrections needed to make that kind-check
10:23:34 <remexre> ski: erm yeah, forgot that :P
10:23:41 <remexre> thanks!
10:24:10 <ski> remexre : perhaps this is too much bother/clutter for your taste .. but it would be a way to decouple the cyclic dependency. so an option to be considered, at least
10:24:50 <remexre> Yeah, I think I'll actually try that; Value is already parameterized, so adding one more isn't too much work
10:24:59 <remexre>  / additional ugliness
10:25:22 <ski> remexre : this way, should you ever want it, you could possibly use the same `Value' with different versions/implementations/approaches to the interpreter monad
10:25:28 <ski> (in the same program)
10:26:08 <ski> (possibly behaving quite differently, not just internally, but observably)
10:26:47 <remexre> ok, thanks for all your help!
10:26:56 <ski> np
10:27:13 <remexre> (byorgey, you too!)
10:28:10 <ski> (one could probably phrase this in terms of `Fix'/`Mu', should one bother to)
10:28:44 <ski> (iow, it's related to replacing explicit recursion with a fix-point combinator)
10:36:36 <dsal> stack docs aren't... super awesome.  Is there a way to set flags in general?   e.g. --jobs=1   This seems like it'd go in stack.yaml, but I don't see where it'd fit.
10:53:25 <leshow> I read that the implementation of EitherT from transformers isn't well liked, but it didn't say why. Does anyone have insight into why that's the case
10:55:04 <cocreature> leshow: transformers doesn‚Äôt have a type called EitherT. you are probably either referring to ErrorT or ExceptT. given that you claim some people don‚Äôt like it, it‚Äôs probably ErrorT
10:58:19 <cocreature> leshow: the problem with ErrorT is that it constrains the first type argument to be an instance of Error in most instances. I haven‚Äôt heard any complaints about ExceptT at least not in that it‚Äôs worse than other implementations of EitherT. (some people prefer exceptions over ExceptT)
11:01:04 <leshow> ah you are correct it is ErrorT 
11:01:09 <leshow> "I can only guess that they did this because of the terrible EitherT implementation in the transformers package that goes by the name ErrorT"
11:01:29 <leshow> It was from a post by Gabriel Gonzalez
11:02:44 <cocreature> ErrorT is deprecated by now
11:02:50 <cocreature> ExceptT is the thing you want to use
11:14:07 <tdammers> exceptions and ExceptT meet different needs
11:21:57 <leshow> is ExceptT in transformers or do most people use mtl
11:29:16 <cocreature> leshow: mtl just reexports ExceptT from transformers
11:29:31 <cocreature> Control.Monad.Trans.Except is the module in transformers that contains it
11:33:56 <leshow> Not all it's modules are re-exported though? Which library do users tend to like more
11:35:45 <cocreature> you can‚Äôt use mtl without transformers
11:36:02 <cocreature> and I think mtl does reexport pretty much everything
11:36:11 <cocreature> or at least everything most people care about
11:36:37 <cocreature> mtl is basically a bunch of typeclasses that abstract over the concrete transformers defined in the transformers package
11:39:57 <abhiroop> Is it possible to derive generic automatically for existentials?
11:40:46 <lyxia> nope
11:40:52 <abhiroop> Eg this: data Value = forall a. Value a deriving (Typeable, Generic)
11:42:45 <lyxia> Generic only works for vanilla ADTs.
11:43:44 <dminuoso> For pattern  matching `f (x:xs) = ....`, does haskell need to evaluate the argument to WHNF, or does it need x and xs in WHNF?
11:44:13 <lyxia> just the argument
11:44:34 <lyxia> > let f (x : xs) = "Hello" in f (undefined : undefined)
11:44:36 <lambdabot>  "Hello"
11:46:09 <dminuoso> lyxia, ahh! I have a feeling where this is heading, may I see undefined as omega from lambda calculus?
11:47:28 <dminuoso> Or I guess the question is pointless. I got the answer, thank you.
11:48:40 <ski> abhiroop : did you try standalone deriving ?
11:48:42 <byorgey> dminuoso: it's not a pointless question.  both undefined and omega correspond to the semantic idea of "bottom", i.e. the completely undefined value.  Operationally, they are different: undefined will throw an exception if you try to evaluate it, and omega just recurses infinitely
11:50:21 <byorgey> let omega = omega; f (x : xs) = "Hello" in f (omega : omega)   -- this is another way to see that f does not need to evaluate x and xs at all
11:50:22 <dminuoso> byorgey, okay, so omega would be akin to `omega = omega`
11:50:27 <dminuoso> Oh heh. Same second. :)
11:50:29 <byorgey> dminuoso: right =)
11:51:03 * ski . o O ( `omega = (\t -> t t) (\t -> t t)' )
11:51:23 <dminuoso> ski, the problem is type inference will error out on that one
11:51:39 <dminuoso> I tried it before :P
11:51:51 <byorgey> that's probably why ski put it in an imagination bubble =)
11:52:00 <dminuoso> Oh :)
11:52:04 <ski> dminuoso : you can do it, with an auxilary `newtype'
11:53:30 <abhiroop> ski: Yes just tried Standalone deriving, doesn't compile, it says "Value must be a vanilla data constructor"
11:53:50 <byorgey> > newtype D = D { unD :: D -> D }
11:53:52 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äònewtype‚Äô
11:53:55 <byorgey> aww
11:54:05 <ski> @let newtype D = D { unD :: D -> D }
11:54:06 <lambdabot>  Defined.
11:54:17 <abhiroop> There is a ticket on this too: https://ghc.haskell.org/trac/ghc/ticket/10514
11:54:20 <jyu__> :window move DOWN
11:54:26 <ski> now make `omega' have type `forall a. a'
11:56:08 <dminuoso> ski, okay I have no idea what that.. does. But Im only in chapter 4 of the gentle introduction, so Im sure it will make sense soon.  
11:56:17 <ski> dminuoso : do you know `data' ?
11:56:20 <dminuoso> Wrote it down, so I can look at it later :)
11:56:21 <dminuoso> ski, yes.,
11:56:59 <ski> `newtype' is basically(*) like `data', except that only a single data constructor is allowed, and further, it must take exactly one argument
11:57:51 <dminuoso> ski, is this for custom "embellished types" ?
11:58:58 <dminuoso> ski, oh I see there's also a difference wrt strictness of the constructor 
11:59:00 <ski> ((*) except that a `newtype' has no run-time representation, the data constructor is a no-op. it's mostly used when you want a *new* distinct type, or when you need recursion (but want to avoid the extra (run-time) overhead of the data constructor). in the former case, it may or may not be an abstract data type)
11:59:17 * ski doesn't know the term "embellished type"
11:59:44 <ski> note that the `{ unD :: ... }' parts of the definition is "record syntax" (which is syntactic sugar)
11:59:54 <ski> it amounts to the same as plain :
12:00:00 <ski>   newtype D = D (D -> D)
12:00:08 <ski>   unD :: D -> (D -> D)
12:00:15 <ski>   unD (D d) = d
12:00:36 <ski> (and record syntax can also be used for ordinary `data' definitions)
12:01:20 <dminuoso> ski, interesting, so its a recursive type definition?
12:01:38 <ski> in addition, `D {unD = d}' (as both pattern and expression) means the same as plain `D d'. in the `data' case, you can have multiple "fields", and you don't need to remember the ordering, when using the record syntax
12:02:22 <ski> there's also `x {unD = d}', which makes an "update" (a copy) of `x', with the `unD' field replaced by `d' (all other fields, in this case none, staying the same)
12:02:40 <crucify_me> https://ptpb.pw/gPdx  hi trying to determine how to get an instance of Num into this code. (just added ski 's comment on newtype in comments)
12:03:07 <ski> dminuoso : correct. point is, you can't say `type D = D -> D', since `type' synonyms can't be recursive (without breaking the recursive cycle by a `data' or `newtype')
12:03:49 <dminuoso> ski, is there a special reason why you can do this with the record syntax?
12:04:02 <ski> `newtype' is like `type' in that you give a name to a type. except that in the latter case, it's merely a synonym, a shorthane, while in the former case, it's a *new* type (like with `data')
12:04:33 <ski> dminuoso : the record syntax here is a red herring, byorgey only used it for convenience (getting `unD' for free), i imagine
12:04:59 <ski> just `newtype D = MkD (D -> D)' would work just as well
12:05:44 <ski> dminuoso : .. can you figure out how to modify the definition of `omega', to make use of this type, to make it type check ?
12:06:07 <crucify_me> any takers re: above question? thanks https://ptpb.pw/gPdx
12:06:28 <dminuoso> ski, lets make it my "homework assignment". :-)
12:06:39 <dminuoso> Wouldn't want you to spoonfeed all the fun.
12:07:04 <lyxia> crucify_me: deriving (Eq, Show, Num, Fractional)
12:07:12 <ski> crucify_me : `(Nada x) / (Nada y) = ..x..y..' could be `Nada x / Nada y = ..x..y..'
12:07:20 <ski> dminuoso : that's the spirit :)
12:08:15 <crucify_me> thanks, sorry ski not following your suggestion.. thanks lyxia I thought I tried similar
12:08:36 <ski> crucify_me : as lyxia is hinting at, you need at least a `Num' instance, in order to be allowed to make the `Fractional' instance
12:08:51 <Psybur> Is (+5) a closure?
12:09:08 <Cale> Psybur: It might be implemented with one
12:09:09 <ski> `(+5)' is a function (value)
12:09:17 <Cale> But yeah, it's a function.
12:09:20 <ski> "closure" is an implementation-specific term
12:10:20 * hackagebot jukebox 0.2.20 ‚Äì A first-order reasoning toolbox ‚Äì https://hackage.haskell.org/package/jukebox
12:10:28 <ski> (one can have implementations which doesn't represent function values as closures)
12:10:50 <Psybur> For all intents and purposes it behaves like a closure though?
12:10:59 <Cale> Not for all
12:11:03 <Cale> A closure specifically refers to a pair of some code with an environment
12:11:19 <Psybur> (+5) has an environment right? The '5'
12:11:20 <Cale> An environment which will bind free variables in the code to values
12:11:31 <ski> if you're asking whether Haskell uses static/lexical scoping, the answer is yes
12:11:35 <Cale> If we have a closure, we can separate off its environment and inspect it
12:11:49 <Cale> If we have a function, we can't.
12:11:52 * ski would say "possibly"
12:12:30 <Cale> For me at least, that's the point at which things stop being closures and start being something else which a closure was used to implement.
12:13:07 <Cale> That is, when they stop looking like pairs with separable parts.
12:15:21 <ski> Psybur : e.g. if you have defined `makeAdder x = adder where adder y = x + y', then `makeAdder 2' (call it `addTwo') will make a function that remembers that the value of `x' is `2', not caring about other calls to `makeAdder', nor about other possible values of `x' in scope at the place where the function value `addTwo' is applied/called
12:17:14 <ski> Psybur : that's static/lexical scoping : the value of `x' in `adder', given `adder y = x + y' is determined by what value `x' had in the "lexical / static" context (scope), where `adder' was defined (inside the body of `makeAdder', where `x' has received a value); not by any value of `x' in the "dynamic" context ("scope") where `adder' (or `addTwo') is used (which would be "dynamic scoping")
12:18:14 <Cale> It's possible for example, for an implementation to compile special code with the 2 filled in, or when you're doing graph rewriting, to copy wholesale the graph for the body of adder, except replacing occurrences of x for 2.
12:18:28 <Cale> Neither of those looks very much like a closure
12:19:15 <ski> Psybur : one obvious way to implement such a function value is as a closure : a reference to the code `let adder y = x + y in adder' (possibly compiled), together with the environment remembering that `x' is bound to `2'
12:19:33 <Cale> GHC will often inline the definitions of small functions which will result in fewer closures being constructed at runtime.
12:20:13 <ski> what Cale was mentioning is another way to implement functions : substitution of actual parameters for formal parameters, in the body
12:20:16 <crucify_me> lyxia, thanks for your help. I pasted your correction as far as I could determine it. getting a similar error as before 
12:20:18 <crucify_me> https://ptpb.pw/KN4n
12:20:39 <ski> Psybur : makes any sense ?
12:21:35 <Psybur> ... :D
12:22:22 <ski> (abstractly, instead of having a closure (pair) `(let adder y = x + y in adder , { x = 2 })', substitution corresponds to replacing `x' with `2', getting (conceptually) `let adder y = 2 + y in adder')
12:22:22 <BernhardPosselt> how do lenses work? is it a macro?
12:22:31 <BernhardPosselt> makeLenses
12:22:36 <dminuoso> Cale, isnt the concept of a closure kind of similar to a lambda expression with a free variable? I mean in both cases you have some locally free variable that is bound in some outer context.
12:22:46 <Cale> BernhardPosselt: makeLenses is a Template Haskell macro, yeah.
12:22:59 <ski> (one can in fact consider the closure as *delaying* the substitution until one actually reaches the variable `x', when evaluating the body of `adder')
12:23:33 <Cale> dminuoso: Well, one way that you might implement closures is to have a lambda with variables occurring free, and then a map from the names of the free variables to values (or terms).
12:23:53 <ski> dminuoso : it's a lambda expression with some free variables, together with an environment that binds those free variables, yes
12:24:07 <monochrom> "similar" is a useless notion. Closure implements a lambda expression with free variables.
12:24:10 <Cale> dminuoso: However, you might also use a pair consisting of a function pointer and an array of pointers to the values...
12:24:18 <BernhardPosselt> are there non macro solutions to updating deeply nested records?
12:24:38 <Cale> There's a wide range of possible ways for closures to look, but they all look like pairs of some code with a finite map of some sort.
12:25:06 <ski> Cale : not clear to me how your latter alternative differs from the former (except in detail) :)
12:25:27 <Cale> ski: Well, in the former, we have the lambda as a tree or expression graph
12:25:34 <Tuplanolla> You can easily define the lenses yourself, BernhardPosselt. You don't even need a package to do that.
12:26:02 <Cale> ski: I'm imagining that the lambda is an AST
12:26:10 <ski> well, yes, you could have that. but one could also read your "lambda" as a (currently) unspecific term, possibly resolving to your latter example :)
12:26:28 <BernhardPosselt> so the macro is basically just DRY because you probably need to create lenses for each type that you want to use right?
12:26:30 <dminuoso> Cale, you know what's funny, "Ast" is the German word for "branch". There's a certain irony in that abbreviation.
12:26:40 <Cale> hah
12:27:03 <monochrom> Is there also "adt"?
12:27:13 <BernhardPosselt> n
12:27:33 <lyxia> BernhardPosselt: https://hackage.haskell.org/package/generic-lens you get lenses for records without TH.
12:27:51 <BernhardPosselt> lyxia: wow, ty
12:28:18 <Psybur> I'm seeing some people on stack overflow saying that partially applied functions are closures :{
12:28:47 <BernhardPosselt> Psybur: kinda
12:28:54 <ski> Psybur : unfortunately, the term "closure" is often used a bit inappropriatedly (confusing abstract semantics with implementation)
12:28:59 <monochrom> There are people, even prominent ones, who use "closure" to refer to every lambda expression.
12:29:58 <BernhardPosselt> Psybur: because a closure captures an argument similarily to how a partially applied function captured an argument
12:30:02 <Psybur> I guess you guys are saying closures are specific types of functions?
12:30:20 <ski> Psybur : in the `makeAdder' example above, one could have defined it as `makeAdder x y0 = adder y0 where adder y = x + y' (or renaming `y0' to `y', if you prefer), or even as `makeAdder x y = x + y'
12:30:20 <Cale> Psybur: They're something a compiler might use to represent functions at runtime.
12:30:22 <Psybur> That can be partially applied
12:30:33 <BernhardPosselt> closures just get the parameter by closing over it instead of having them in their argument list
12:30:39 <ski> Psybur : still, `makeAdder 2' will behave (observationally speaking) in the same way
12:30:58 <ski> Psybur : .. and one could say that this is a partial application of `makeAdder'
12:31:03 <Cale> Psybur: It's possible for GHC, for example, to implement (+5) as something which is not a closure, by compiling special code for that function.
12:31:26 <BernhardPosselt> lyxia: the syntax is actually way easier to read than lenses
12:32:25 <dminuoso> Psybur, a closure is any "function" with a free variable (a variable that is not among its parameters) in it. 
12:32:45 <Cale> Psybur: As a programmer, you can't really tell. Some people like to use the word "closure" to refer to all functions which have captured the value of a free variable from the scope in which they've been defined.
12:32:53 <Cale> But that's sort of an abuse.
12:33:03 <dolio> Why just functions?
12:33:14 <ski> dminuoso : a closure is a possible way for implementing a function value
12:33:18 <Cale> dolio: Also a good point -- it shouldn't be just functions.
12:33:40 <Cale> dolio: It seems like most such programmers are also fans of strict evaluation though, I think :)
12:33:58 <dolio> That doesn't preclude the question.
12:34:09 <ski> since Haskell is non-strict, closures are often used to implement non-function values as well
12:34:11 <BernhardPosselt> Psybur: still confused? need an example in js?
12:34:23 <Psybur> Since functions are curried, does it mean that any function that takes in multiple parameters has implicit closures?
12:34:30 <dminuoso> ski, considering how many discussions Ive had about "closures", I think the word might just lack a concise definition everyone can agree on.
12:35:04 <Cale> Psybur: Maybe, maybe not.
12:35:11 <ski> (in a strict language, other non-strict aspects (than functions), such as suspensions (delayed computations, without parameters), or non-strict records (think objects with methods. e.g. in OCaml) can be implemented with closures)
12:35:31 <Psybur> If you have f x y = ... then f x is a closure?
12:35:35 <Cale> Psybur: Usually the compiler will do all kinds of things to avoid forming closures as you apply a function to each successive argument.
12:35:42 <Psybur> I see
12:35:49 <ski> Psybur : `f x' can be implemented by a closure
12:35:51 <dolio> Java has let you define classes locally that capture values in the local environment for a long time, for instance.
12:36:07 <dolio> Even though it hasn't had first class function objects per se.
12:36:08 <Cale> Psybur: If you're only interested in what programs *mean* then "closure" is at the wrong level of abstraction, probably.
12:36:26 <Tuplanolla> Are you saying closure is an implementation technique, like stack or heap?
12:36:32 <Cale> Tuplanolla: yes
12:36:36 <Psybur> Ok I think I get what you guys are saying. Something can "seem" like a closure but not actually "be" one heh
12:37:16 <ski> dminuoso : that may be so. but for the purposes of terminology in the Haskell community, i think it's relatively accepted that "closure" refers to an implementation strategy for delayed computations
12:37:23 <ski> (or at least i hope so)
12:37:53 <dolio> I think that's probably agreed upon among PL academics.
12:38:06 <BernhardPosselt> Psybur: https://dpaste.de/4Bz0
12:38:25 <dolio> Which is probably where the term came from in the first place.
12:39:24 <BernhardPosselt> you see function solution closes over the a parameter
12:39:29 <BernhardPosselt> from the first call
12:39:31 <Psybur> BernhardPosselt, yes, I think I see why in Haskell (+5) might not be implemented as a closure but your example is definitely a closure.
12:39:51 <ski> Psybur : and you shouldn't care about whether it's a closure or not, unless you care atm about implementation details (like stack vs. heap, how garbage-collection is done, &c.)
12:39:54 <Cale> Psybur: Even still, no :)
12:40:00 <BernhardPosselt> so partial application is kinda a closure :D
12:40:05 <BernhardPosselt> at least in js
12:40:16 <Psybur> Well, it may or may not be one depending on that tricky compiler
12:40:18 <Psybur> ;P
12:40:21 <Cale> right
12:40:51 <Cale> It's a technique that a compiler may or may not choose to employ -- there's always other options, some of which are admittedly fairly drastic.
12:41:19 <Cale> Actually, even in real Javascript implementations, I bet they'll sometimes JIT compile a function rather than forming a closure.
12:41:26 <monochrom> The word "closure" is akin to the word "math". Sure, you will see no consensus on what the word "math" means. But it is only because there are two groups: One group is the actual mathematicians who know what they're talking about, the other group is outsiders who grossly misunderstand the situation but still want to give opinions.
12:41:28 <Cale> (but I haven't looked to be sure)
12:41:57 <ski> BernhardPosselt : in that paste, i'd imagine that both `addOne' and `add_One' could well be implmented as closures
12:42:49 <BernhardPosselt> right
12:43:03 <Cale> Also, if we bend our imagination a bit, perhaps even add is, with the free variable "+" :D
12:43:56 <ski> (with the difference that for `add_One', we can change `x', but we can't reach into `add' for `addOne', to change `a')
12:44:22 <onethirtyfive> Does anyone know of a direct way of reversing the order of bits in a Word8? (This is where I feel like a compsci fraud.)
12:44:22 <BernhardPosselt> yes, thats where things usually go south
12:45:06 <Cale> Oh, yes, in languages with effects, you always have the ambiguity as to whether a variable refers to the value contained in the memory cell, or the memory cell itself. 
12:45:08 <BernhardPosselt> as in: people wondering why things were updated or weren't updates
12:45:10 <BernhardPosselt> updated*
12:45:18 <monochrom> onethirtyfive: Is it OK to build custom hardware for it and plug it into a USB port? :)
12:45:20 <BernhardPosselt> pass by ref vs pass by value
12:45:33 <ski> (still, some language( implementation)s make sure that the current values of nonlocals like `x' and `a' are copied into new variables in the closure, when it is constructed. but if those values themselves are mutable objects, you can still affect the closure by mutating them)
12:45:36 <onethirtyfive> monochrom: uh oh :)
12:45:42 <Cale> This is a really good reason to prefer the way IORef looks in Haskell, with explicit reads and writes.
12:46:02 <Cale> It's much harder to accidentally capture an IORef when you meant to capture its value or vice versa.
12:46:23 <monochrom> But basically Data.Bits doesn't have a fast way of reversing bits other than writing your own loop.
12:46:36 <BernhardPosselt> or even stuff like creating closures in a loop and depending on the counter variable
12:46:42 <ski> in Haskell, this problem is solved by not allowing variables to change (not allowing assignment to variables. to be distinguished from mutation of a mutable data structure)
12:46:55 <BernhardPosselt> then wondering why all counters are the last counter value xD
12:47:09 <BernhardPosselt> good times
12:47:44 <onethirtyfive> monochrom: I have this situation where I have to read bits from a stream, but apparently I'm supposed to read from LSB to MSB for each byte... Data.Bits.BitGet doesn't have this capability.
12:47:47 <ski> in Scheme, the looping variable is a new variable, for each iteration round (even though you can assign to it)
12:47:50 <onethirtyfive> D:
12:48:50 * hackagebot apns-http2 0.1.0.0 ‚Äì Apple Push Notification service HTTP/2 integration. ‚Äì https://hackage.haskell.org/package/apns-http2
12:48:54 <ski> (thinking of `do' and "named" `let' .. and more advanced looping constructs (defined (often library) special forms, aka macros))
12:49:16 <ski> @remember monochrom The word "closure" is akin to the word "math". Sure, you will see no consensus on what the word "math" means. But it is only because there are two groups: One group is the actual mathematicians who know what they're talking about, the other group is outsiders who grossly misunderstand the situation but still want to give opinions.
12:49:16 <lambdabot> It is stored.
12:49:26 <Tuplanolla> Do you know how to do it conceptually, onethirtyfive?
12:50:07 <onethirtyfive> Only very naively. some recursion with an AND mask?
12:50:09 <ski> BernhardPosselt : *nod*
12:50:37 <BernhardPosselt> :)
12:51:40 <onethirtyfive> Tuplanolla: I was hoping against hope for some mathematical property of binary numbers that made it magically easy. Humanities scholar, here. rofl.
12:52:00 <Tuplanolla> I doubt there's a better option, onethirtyfive.
12:52:23 <onethirtyfive> ok, thanks for the knowledge. :)
12:53:05 <ski> (personally, i think the "copy values of nonlocals into fresh variables, when constructing a closure" is confusing. it might be less confusing if the language allowed declaring names of values ("constant/immutable variables"), in addition to names of locations, whose current value can change)
12:53:34 <ski> onethirtyfive : perhaps you could shift
12:54:07 <dminuoso> ski, okay after staring at the types long enough and trying out almost all the combinations, I finally succeeded! Just dont know why.
12:54:08 <Tuplanolla> As follows, onethirtyfive. Start with your accumulator at zero and index at word size in bits. First `and` your reversed byte with another byte that has only one bit set at the index, then `shift` the result by the index and finally `or` the result with the accumulator. Repeat until your index reaches zero.
12:54:23 <ski> dminuoso : heh
12:54:26 <dminuoso> newtype D = D (D -> D); unD :: D -> (D -> D); unD (D d) = d; omega x = unD x x
12:54:52 <ski> * ski . o O ( Haskell -- where you write working code first, and understand it later )
12:54:57 <dminuoso> Heh.
12:55:23 <ski> that's only half of it, right ?
12:55:24 <Tuplanolla> Another way would be to use a binary-tree-like traversal, a lookup table or both, onethirtyfive.
12:55:32 <ski> (the `\t -> t t' half)
12:55:44 <dminuoso> ski, I mean about the only thing that was clear that omega somehow has to be of type D -> D. But the right hand side was just the result of effortless brute force. :-)
12:56:16 <ski> dminuoso : by "effortless brute force" i hope you mean "mindlessly following the types"
12:56:23 * Digit wants to learn haskell while he sleeps and wonders if there's anything worth putting on that could do that... even if parsing docs/tutes through flite
12:56:24 <dminuoso> Man this is just like C pointer time all over again. Adding * and & to the left and right side of expression until the compiler stops complaining.
12:57:03 <jle`> so compact regions are pretty cool
12:57:09 <ski> dminuoso : now, how about the original `omega = (\t -> t t) (\t -> t t)' ?
12:57:32 <onethirtyfive> Tuplanolla: thanks, that all makes sense.
12:58:19 <dminuoso> ski, the possible combination of valid haskell expressions is limited, after all I suspect the solution to be expressible within 16 GiB of ram. I could either write a program (list monads surely should be great!) or step back and study the types.
12:58:24 <erisco> Digit, if you put a book under your pillow it will soak into your brain
12:58:31 <erisco> Digit, but you have to remember to open it up, don't leave it shut
12:58:51 <Digit> mmm.  learning through osmosis+
12:58:53 <onethirtyfive> Tuplanolla: I hadn't thought about a lookup table, but there'd only be 256 entries in it. I think that's the way to go for speed.
12:59:01 <ski> dminuoso : "study the types" is what i'd suggest :)
12:59:43 <Tuplanolla> You could even get away with a smaller one if you followed the binary tree idea, onethirtyfive.
13:00:18 <erisco> also, only the exposed pages will be absorbed, so you have to turn them each night. uptake is greatly increased if you first prime your brain by reading the pages before sleeping
13:00:35 <erisco> then to reinforce your overnight learning make sure to try the listed practices
13:00:46 <Tuplanolla> Hint, onethirtyfive: `reverse (xs ++ ys) == reverse ys ++ reverse xs`.
13:01:25 <dminuoso> ski, since I have been lost in recursion for a while now. Do you have a starting tip how to not get lost in recursion?
13:01:40 <dminuoso> I mean I see D and unwraped D -> D everywhere
13:01:41 <erisco> dminuoso, I recommend finding some base cases
13:05:42 <dminuoso> Oh. I feel stupid now.
13:06:16 <onethirtyfive> dminuoso: you're not alone :)
13:06:25 <dminuoso> ski, yeah that helped. I realize that my solution was a bit silly, that talk about "unD" led me to think it was necessary, so I tried to incorporate it.
13:06:42 <dminuoso> newtype D = Foo (D -> D); omega :: D -> D; omega x = x
13:07:40 * ski . o O ( "Follow the parameter types, follow the type of the result / Follow, follow, follow, follow, follow the types of your task / Follow the function types, follow the argument types / Follow the types of your task" -- Dr. Simon Seuss )
13:09:23 <ski> dminuoso : that doesn't have the same behaviour (ignoring `D' and `unD')
13:10:40 <ski> (your new `omega' is basically `\t -> t'. your old was basically `\t -> t t'. i'm still waiting for `(\t -> t t) (\t -> t t)')
13:13:12 <Tuplanolla> Does there exist something like `funmap :: Wrap f => (f a -> f b) -> a -> b` and `unliftA2 :: Wrap f => (f a -> f b -> f c) -> a -> b -> c`?
13:13:54 <jle`> Tuplanolla: is there a Wrap you are thinking of in particular?
13:13:58 <dolio> Not that I know of.
13:14:12 <dolio> That's the sort of thing that could legitimately be called a 'cofunctor' though.
13:14:13 <Tuplanolla> Take `Sum` or `Product`, jle`.
13:14:13 <jle`> funmap is kind of like 'over' or 'under' from lens for the _Wrapped/_Unwrapped lenses
13:14:33 <jle`> > under _Wrapped (\(Sum x) -> Sum (x + 2)) 4
13:14:35 <lambdabot>  6
13:14:48 <jle`> > over _Unwrapped (\(Sum x) -> Sum (x + 2)) 4
13:14:50 <lambdabot>  6
13:14:51 <jle`> s/lenses/isos
13:16:00 <EvanR> what is the difference if any between a witness and a proof
13:16:08 <jle`> if i'm interpretting "wrap" to refer to newtype wrappers
13:16:13 <johnw> EvanR: none
13:16:33 <jle`> EvanR: i was actually just writing about this but i've concluded that there is no rigorous definition for either of them, and they are informal words to describe things we use for certain roles
13:16:49 <johnw> EvanR: according to curry-howard, a proof in constructive type theory is given by a witness that a type is inhabited
13:17:34 <EvanR> so is the witness the tangible thing, for a proof which is the sort of thing you usually see spelled out informally
13:17:56 <Tuplanolla> > unliftA2 {- @Sum -} mappend 42 13 -- This was the idea, jle`.
13:17:57 <johnw> I couldn't quite parse that sentence
13:17:58 <lambdabot>  55
13:18:12 <dolio> EvanR: Depends who you're talking to. But for a proposition like 'there exists a number such that ...' the 'witness' is the number.
13:18:28 <EvanR> ok
13:18:29 <dolio> Sometimes, at least.
13:18:41 <jle`> EvanR: i think what is being said is that the witness is the actual thing and 'proof' is the description of its role 
13:19:04 <dolio> Just knowing the number isn't the complete proof.
13:19:20 <jle`> hm i wrote this before seeing what you had said before
13:19:29 <jle`> i was trying to elaborate on johnw's descrption
13:20:01 <dolio> And I guess if you're non-constructive, there might never be a 'witness' you can produce in that sense.
13:20:05 <EvanR> when an unconstructive proof contains like... LEM or axiom of choice, do those count as witnesses
13:20:05 <jle`> Tuplanolla: such a thing can be done using _Wrapped/_Unwrapped manually, but it might not be given as an explicit combinator
13:20:17 * ski recalls `funmap' coming up in the past, here
13:20:21 <dolio> You could have a proof of the statement even though it's impossible to give a witness.
13:20:24 <johnw> unconstructive proofs may only refer axioms in the logic
13:20:33 <jle`> funmap itself is over _Unwrapped/under _Wrapped
13:20:43 <Tuplanolla> It's a bit clunky.
13:21:03 <jle`> you mean `over _Unwrapped` ?
13:21:22 <Tuplanolla> How does it even work for the two-parameter case?
13:21:31 <jle`> you can manually unwrap and wrap, generically
13:22:09 <ski> EvanR : i think "witness" is often used for the value `v' (of type `T') in `(v,p)' of type `(v :) T * P v' (aka `exists v : T. P v'). `p' is a proof (and the whole pair is also a proof)
13:22:17 <jle`> view _Unwrapped $ mappend (view _Wrap 42) (view _Wrap 13)
13:22:27 <EvanR> yeah that usage makes sense for dependent pairs
13:22:57 <Tuplanolla> I guess it's not too bad, jle`.
13:23:06 <dolio> A definition of being 'constructive' could be that if you can prove a statement (like that), you can extract a witness from the proof.
13:23:15 <jle`> Tuplanolla: you can probably do something using 'ala'-liek techniques, to wrap it up
13:23:28 <dolio> Which is often known as the 'existence property'.
13:24:03 <johnw> ski: I would have used "witness" to describe the P v part
13:24:17 <EvanR> hrm
13:24:20 <ski> "existence property". if `|- exists v : T. ..v..', then there is a (closed) term `t' such that `|- t : T' and `|- ..t..'
13:24:21 <johnw> as in, { v : T | P v } is a value v of type T, paired with a witness that P holds for v
13:24:32 <dolio> johnw: Nah.
13:24:51 <jle`> > ala Sum foldMap [42,13]      -- Tuplanolla 
13:24:52 <ski> "disjunction property". if `|- A \/ B', then either `|- A' or `|- B'
13:24:54 <lambdabot>  55
13:25:06 <dolio> johnw: Although I've heard it both ways, really.
13:25:24 <Tuplanolla> Yeah, but now you're forcing the monoid structure, jle`.
13:25:35 <jle`> Tuplanolla: you can use other functions besides foldMap
13:25:44 <jle`> 'ala Sum' itself does not enforce anything monoidy
13:25:47 <jle`> it's the choice of foldMap that does it
13:25:49 <ski> johnw : that's not the same, though. that's a type, not a proposition
13:25:52 <jle`> but you could use other functions besides foldMap
13:26:13 <Tuplanolla> Cool.
13:26:14 <johnw> ski: I'm not sure what you're referring to
13:26:19 <dolio> johnw: I think the latter thing being called a 'witness' is an artifact of propositions as types', though.
13:26:22 <jle`> `ala Sum` itself has nothing to do with monoids
13:26:30 <jle`> it's just a combinator over wrapping and unwrapping the Sum newtype
13:26:34 <johnw> dolio: yes, I use it with the understanding of propositions as types
13:26:40 <dolio> Because the point of a 'witness' is that it's a value that shows the proposition is 'true'.
13:26:49 <johnw> exactly
13:27:48 <dolio> And more classically, the P part has no content, so the v is the 'witness'.
13:28:01 <dolio> If you can give something specific.
13:28:01 <ski> johnw : hm. i suppose the difference i'm after shows itself clearly when you distinguish between propositions and types (cf. Coq). so i should (only) have talked about the proposition `exists v : T. P v' (and proofs thereof), in the former case
13:28:12 <johnw> dolio: hmm
13:28:21 <johnw> I'll have to dwell on that
13:28:32 <johnw> ski: I see
13:28:51 <dolio> Like, 'there exists a prime number' is witnessed by giving a specific prime number.
13:29:09 <johnw> ah, I see where you're coming from now
13:29:37 <ski> johnw : hmm. in any case, you can make a distinction between two versions of `(v :) T * P v', one in which `v' is "blind" (forgotten), and one in which the proof of `P v' is blind
13:30:14 <johnw> ski: or both blind, or both kept?
13:31:13 <ski> johnw : "blind" might here mean that operationally, the value/proof has been discarded (so that you can't e.g. do induction on it, in order to compute something non-blind) .. or perhaps only that it must be ensured that different values/proofs of the blind thing will not make a difference in the end
13:31:18 <tommd> Any hackage admins feel like bumping a bound on ansi-wl-pprint?
13:31:33 <ski> johnw : yeah, there's also those possibilites
13:31:50 <johnw> ski: ok, I see what you mean
13:31:54 <johnw> thanks for clarifying
13:32:03 <ski> johnw : `P v' being blind seems to correspond closest to the idea of `{ v : T | P v }'
13:32:05 <EvanR> tommd: the owner of ansi-wl-pprint can change those bounds without an admin doing anything
13:32:36 <johnw> yes.  in Coq syntax, { v : T | P v } in the blind in P v in a computationally-relevant context, whereas { v : T & P v } is not blind in any context
13:35:05 <ski> johnw : perhaps "Notions of anonymous existence in Martin-L√∂f Type Theory" by Nicolai Kraus,Mart√≠n Escard√≥,Thierry Coquand,Thorsten Altenkirch in 2014-03-31 at <http://www.cs.bham.ac.uk/~mhe/papers/hj.pdf>,<http://red.cs.nott.ac.uk/~ngk/notions-of-existence-formalization/INDEX_NotionsOfAnonymousExistence.html>,<http://www.cs.bham.ac.uk/~mhe/papers/hj.zip>,<http://www.cs.bham.ac.uk/~mhe/papers/> could be interesting here
13:35:06 <EvanR> v is the witness as long as P v
13:35:15 <EvanR> a witness
13:38:00 <ski> (Japaridze's "Computability logic" also talk about blindness .. as does Dependent Haskell, istr)
13:38:30 <ski> (note that `forall' in Haskell is blind (in the quantified variable))
13:40:32 <monochrom> Ah, that. Parametricity. The author cannot ask how the user instantiates the type variable.
13:40:37 <EvanR> the second link probably doesnt work
13:41:38 <ski> EvanR : ok, appears to have moved to <https://github.com/nicolaikraus/HoTT-Agda/tree/master/nicolai/anonymousExistence>
13:44:14 <ski> monochrom : what does parametricity in `n' mean in `forall n : |N. 0 + n = n' ?
13:44:39 <monochrom> I don't know. But it's true of Haskell and System F.
13:45:36 <dolio> ski: Saizan has a paper about that.
13:45:37 <ski> could it be related to some partial order (or preorder) on `|N' ? the ordinary additive one ? the discrete one ?
13:45:51 <ski> dolio : do you have a link ?
13:46:07 <dolio> I do, but I don't know if I'm at liberty to give it out.
13:46:17 <ski> ok
13:46:28 <dolio> Also search for incremental lambda calculus for another possibility.
13:46:35 <dolio> Where parametricity is related to derivativies.
13:48:05 <monochrom> For all logical relations R between X and Y, for all x in X, for all y in Y, 0+x=x is R-related to 0+y=y? >:D
13:48:18 <dolio> Actually I had a conversation about the latter with the author of the paper...
13:48:35 <dolio> https://plus.google.com/+DanDoel/posts/caXnw5kGVKp
13:48:40 * ski found <https://bentnib.org/posts/2015-04-23-incremental-lambda-calculus-and-parametricity.html>,<http://www.informatik.uni-marburg.de/~pgiarrusso/ILC/>,<https://www.researchgate.net/publication/309854814_Evolving_the_Incremental_lambda_Calculus_into_a_Model_of_Forward_Automatic_Differentiation_AD>
13:49:02 <dolio> ski: Yeah, those are all good.
13:51:10 <EvanR> forwarded to my reading group
13:53:18 * ski recall thinking slightly about parametricity on "values" before, but doesn't recall any insight
13:57:32 <dolio> I'd thought about it before, and always got stuck when I had to think of what a 'relation between 2 and 5' would be.
13:58:12 <dolio> The derivative answer is that it's +3, basically.
13:58:47 <ski> (interesting that you think it may be related to Bernardy's work, though)
13:59:55 <dminuoso> ski, Im completely confused. I mean I've understood why œâ works (its annotated in the following code)
14:00:24 <dminuoso> But no matter how I approach it, haskell is hating me on Œ©
14:00:28 <dminuoso> https://gist.github.com/anonymous/fd3a3fcd391461da7654b60b39c5d1f3
14:01:03 <dminuoso> And wait a second, there's something wrong
14:01:32 <dminuoso> No ther e is not.
14:01:46 <dolio> The opposite direction is that if for each type A you have a change family DA : A -> Type...
14:02:08 <dolio> Then the 'tangent bundle' is Sigma A DA
14:02:09 <ski> dminuoso : `make1Dfrom2D' is `unD'
14:02:12 <monochrom> Does make1Dfrom2D type-check?
14:02:22 <monochrom> Ah so it does.
14:02:56 <dolio> And 'change families' on the universe, or *, are relations.
14:03:01 <ski> dminuoso : `lowerOmega make1Dfrom2D(lowerOmega)' is incorrectly bracketed ..
14:03:12 <ski> .. and one more problem/mistake is present
14:03:46 <ski> dolio : is this conception of derivatives of types related to the McBride one ?
14:04:41 <dolio> And maps between tangent bundles with a coherence condition are like derivatives, but if you fill in the 'relation' part, they end up with the same type as parametricity theorems.
14:05:17 * ski idly wonders whether there's an interesting comparision to SDG to make
14:05:21 <dolio> And I think 'internal parametricity' is like recognizing that a polymorphic function can also be instantiated to the tangent bundles to get you the parametricity theorem.
14:05:24 <dolio> Or something like that.
14:05:35 <dminuoso> ski, oh my! I did it again. It type checks!
14:05:42 * ski smiles
14:06:17 <dolio> ski: I'm not sure about the McBride thing. Off hand I'd say no. That's like a formal power series coincidence or something.
14:06:30 <ski> ok
14:06:31 <dolio> But maybe there's some connection. Who knows?
14:06:31 <dminuoso> Though probably wrong still. Seriously, this is exactly like when I was learning pointers in C.
14:06:53 <ski> dminuoso : what's your new definition of `upperOmega' ?
14:07:00 <monochrom> So people are doing differential geometry on lambda calculus...
14:07:12 <dminuoso> ski, upperOmega = Foo (\x -> unD x x)
14:07:30 <dolio> monochrom: Forward mode AD is just differential geometry, too. :P
14:07:37 <ski> dminuoso : sorry, that doesn't correspond to `(\t -> t t) (\t -> t t)'
14:08:00 <dminuoso> ski, its precisely like then. "It compiles. Now whats a seg fault?"
14:08:03 <ski> (it's just `\t -> t t', with some `MkD' & `unD' annotations)
14:08:07 <monochrom> What would Stokes's theorem say?
14:08:45 <ski> i wonder how "Evolving the Incremental {\lambda} Calculus into a Model of Forward Automatic Differentiation (AD)" relates this to AD ..
14:09:11 <monochrom> Actually, do they talk about the dimension of a manifold? And if so, what does dimension represent?
14:10:36 <dolio> monochrom: Dimension is related to how many types a type depends on, I think.
14:11:04 <dolio> monochrom: The differential geometry angle isn't really explored by the people in the papers as far as I know, though.
14:11:39 <dolio> But when I was showing the lambda calculus thing to a coworker, he said, "this looks a lot like differential geometry."
14:12:54 <dolio> monochrom: When you're a family over n types, your change family ends up being over 2*n+1 types, though.
14:13:15 <dolio> Which is similar to the vector bundle for an n-dimensional space being 2*n-dimensional, I think.
14:13:38 <dminuoso> ski, mmm. just a plain upperOmega = lowerOmega (MkD lowerOmega) makes sense, which just looking at the types would have given me all along.
14:14:09 <ski> dminuoso : correct ! :D
14:14:13 <dminuoso> Not sure why you would say the brakcets were off though
14:14:42 <ski> dminuoso : when you said `lowerOmega make1Dfrom2D(lowerOmega)', i was thinking you intended `lowerOmega (make1Dfrom2D lowerOmega)'
14:15:05 <monochrom> Ah, right.
14:15:14 <ski> dminuoso : however, `make1Dfrom2D' (iow `unD :: D -> (D -> D)') is the wrong direction there, you need the other one, `MkD :: (D -> D) -> D'
14:16:58 <ski> dminuoso : now, replace `newtype D = MkD {unD :: D -> D}' with `newtype Santa a = MkSanta {unSanta :: Santa a -> a}'. what is now the type of `upperOmega' ?
14:17:01 <dminuoso> ski, is this normal in Haskell, that you sometimes just try to make things fit by following types?
14:17:38 <ski> also compare this with <https://en.wikipedia.org/wiki/Loeb's_paradox>,<https://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem>
14:18:03 <Cale> dminuoso: yes, and it's also relatively normal that it actually works when you do
14:18:03 <ski> dminuoso : yes. especially for polymorphic operations (often HOFs)
14:18:49 <ski> dminuoso : this is what i meant by "follow the types" (if you now understand, at least a bit, what i meant by that)
14:20:50 <monochrom> Oh, so I was defining "newtype D a = Dof {deD :: D a -> a}" and it means I was reinventing Curry's paradox.
14:22:37 <monochrom> The fun thing is I didn't even think it up a priori. I derived it by starting with "D = D -> ???" and trying to get (\x -> x x) to work and solved for ???.
14:25:11 <ski> dminuoso : you can also try to define the Curry fixed-point combinator (`\f -> (\t -> t t) (\t -> f (t t)))'), or the Turing one (`(\t -> t t) (\u -> \f -> f (u u f))')
14:25:43 <dminuoso> ski, this has just gotten over my head since Santa.
14:26:09 <ski> (if you do it right, both of those should have type `(a -> a) -> a')
14:26:12 <ski> @type fix
14:26:14 <lambdabot> (a -> a) -> a
14:26:23 <ski> > fix (\ones -> 1 : ones)
14:26:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:26:53 <ski> > fix (\fib n -> case n of 0 -> 0; 1 -> 1; _ -> fib (n-1) + fib (n-2)) 12
14:26:54 <dminuoso> ski, until 2 days ago I didnt even know what lambda calculus was :)
14:26:56 <lambdabot>  144
14:27:40 <ski> fixed-point combinators (like `fix' in Haskell) are used to express recursion, without actually using explicit recursion
14:28:01 <jared-w> also known as the Y combinator iirc
14:28:19 <ski> (the above examples are equivalent to the explicitly recursive `let ones = 1 : ones in ones' and `let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 12')
14:28:23 <ski> yes
14:28:47 <jle`> hi people who use typelits often
14:29:00 <monochrom> Ah, today must be contention day. We barely survived a disagreement on "closure". And now, "Y combinator"...
14:29:00 <jle`> should we be switching wholesale to GHC.TypeNats at this point?
14:29:35 <jle`> jared-w: the y combinator is just one fixed-point combinator, so it's not quite the same as saying that fixed-point combinators are known as the y combinator
14:29:51 <ski> the idea is that `fix f' should be equal to `f (fix f)', being equal to `f (f (fix f))', being equal to `f (f (f (fix f)))', &c. ... essentially `f (f (f (...)))', infinitely many calls to `f'
14:29:53 <dminuoso> ski, is there a solution to the Santa problem by the way?
14:29:54 <jle`> that's like saying "dogs (also known as fido)"
14:30:18 <monochrom> But no, Y should refer to specifically (\f. (\x. f (x x)) (\x. f (x x)))
14:30:45 <jared-w> jle`: ah, right. I keep forgetting that there's a ton of different fix-point combinators since everyone seems to love demonstrating fixpoint with Y and only Y :)
14:30:46 <ski> iow `fix f' should be an `x' such that `x = f x' (this is what "fixed-point" means. a value `x' such that passing it through `f' doesn't change it. `fix f' is supposed to compute a fixed-point of `f')
14:31:02 <EvanR> and that lambda cant be typed in haskell
14:31:02 <michi7x7> > fix \f -> 0 : 1 : zipWith (+) f (tail f)
14:31:04 <lambdabot>  <hint>:1:5: error: parse error on input ‚Äò\‚Äô
14:31:30 <ski> the definition of `fix' in Haskell "cheats", it's just :
14:31:34 <ski>   fix :: (a -> a) -> a
14:31:37 <ski>   fix f = x
14:31:40 <jared-w> > fix (\f -> 0 : 1 : zipWith (+) f (tail f))
14:31:40 <ski>     where
14:31:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:31:42 <ski>     x = f x
14:32:04 <ski> (an alternative, but less efficient, definition is `fix f = f (fix f)')
14:32:27 <ski> this "cheats", because it uses explicit recursion (of `x', or of `fix')
14:32:56 <monochrom> https://en.wikipedia.org/wiki/Fixed-point_combinator#Other_fixed-point_combinators
14:33:20 <ski> dminuoso : the Curry and Turing fixed-point combinators are ways to implement it in lambda-calculus, without "cheating" by using any syntactic recursion present in the language
14:34:29 <dminuoso> ski, I have a feeling I might need a book on lambda calculus...
14:34:38 <ski> dminuoso : however, just like `(\t -> t t) (\t -> t t)', they don't type-check in a typed lambda-calculus (unless infinite (cyclic/rational)types are allowed. but that tends to hide many legitimate errors behind strange inferred types, so that's usually not desired)
14:34:39 <monochrom> And now, a comical relief: https://plus.google.com/u/0/102208456519922110915/posts/PC5W3XVtq5M
14:35:11 <ski> dminuoso : .. still, using `D' (or `Santa') above. one can express version of them, in Haskell
14:35:48 <dminuoso> ski, okay so there is a solution? Because when all those paradoxons were thrown into the room I got a bit unsure
14:36:35 <ski> dminuoso : "is there a solution to the Santa problem by the way?" -- if you mean the problem i posed, of replacing `D' with `Santa', and correspondingly adjusting `lowerOmega' and `upperOmega', then yes
14:36:46 <monochrom> Actually "newtype D = MkD (D -> D)" isn't going to do much for you. There is a big gap between (D->D)->D and forall a. (a->a)->a
14:37:03 <monochrom> But Curry's paradox will get you everything.
14:37:09 <jle`> i want it all
14:37:33 <monochrom> What is Santa?
14:37:36 <jared-w> *cue catchy music*
14:37:59 <ski> dminuoso : on the Curry/Loeb paradox WP page, `X' corresponds to `Santa a', and `Y' to `a'
14:38:05 <jared-w> monochrom: fabulous joke
14:38:23 <ski> <ski> dminuoso : now, replace `newtype D = MkD {unD :: D -> D}' with `newtype Santa a = MkSanta {unSanta :: Santa a -> a}'. what is now the type of `upperOmega' ?
14:38:27 <ski> monochrom ^
14:38:38 <monochrom> I am now actually investigating "newtype D = Dof{deD :: forall a. D -> a}"
14:39:26 <monochrom> "rank-2 Curry paradox" >:D
14:39:37 <ski> monochrom : "Define the sentence `X' as : `X' implies Santa exists."
14:40:06 <monochrom> But but but clearly Santa exists. Just ask NORAD and Canada Post.
14:40:32 <Tuplanolla> > ((. ord) . (!!) . permutations) "Santa" 'a'
14:40:35 <lambdabot>  "Satan"
14:40:57 <monochrom> Yeah yeah I know how to play that game.
14:41:13 <monochrom> > (\_ -> "Satan") "Tuplanolla"
14:41:15 <lambdabot>  "Satan"
14:41:49 <monochrom> I could come up with a less "trivial" formula, but why bother. Use Occam's razor and be done.
14:41:59 <ski> monochrom : `D = D -> (forall a. a)' should be similar to `D = D -> Void'. so `Void' holds, hence `forall a. a'
14:42:00 <jle`> the point is to obfuscate
14:42:02 <jle`> > id ['S','a','t','a','n']
14:42:04 <lambdabot>  "Satan"
14:42:22 <monochrom> Too bad I'm a scientist rather than a conjurer.
14:42:52 <jle`> was gandalf a scientist
14:43:43 <e1024> I'm trying to figure out a possible hash between username & password at a coffeee shop. You pay for 60mins and get a card with a random but short username & password. Wondering if they use a hash to generate these combinations and if so is there a way to reverse engineer it. Hvae been collecting cards and making notes of combinations.
14:44:28 <[exa]> jle`: he was in at least 3 movies without saying anything about categories, so obviously not
14:44:32 <dminuoso> ski, well naturally I would expect the type of upperOmega to be `Santa a`
14:44:47 <crucify_me> I'd like to describe this code as well as I can, and have that subjected to criticism.   https://ptpb.pw/KN4n
14:44:57 <crucify_me> any takers?
14:45:25 <monochrom> e1024: Have you talked to people who look for patterns in lottery?
14:45:36 <jle`> crucify_me: just describe it :)  it's not like we have anything better to do here
14:45:37 <[exa]> e1024: how many bits can you stuff to both?
14:46:01 <monochrom> haha [exa]
14:46:15 <ski> > (reverse . liftM2 (:) head ((\('r':'u':n) -> 'a':n) . tail) . reverse) "Saturn"
14:46:17 <lambdabot>  "Satan"
14:46:33 <dminuoso> ski, https://gist.github.com/anonymous/7557afe3db9a8b641f968acc5a1e036b
14:46:38 <e1024> 7 digit for username, 5 characters for password. All upercase and looks like no 1,0,I or O
14:46:48 <dminuoso> it looks no more different than the previous, except its less confusing
14:46:53 <crucify_me> thanks. we are creating something here similar to a new data type, that takes one argument, a double.
14:47:23 <monochrom> haha "basically(*)"
14:47:40 <[exa]> e1024: thats around 46 bits if I count right, still in the category "good luck with that"
14:47:56 <monochrom> But you can't have both "deriving Fractional" and "instance Fractional".
14:48:11 <crucify_me> that parts wrong?
14:48:14 <ski> dminuoso : try removing the type signature on `upperOmega', and infer the type .. or if you prefer, infer / figure out the (most general) type in your head
14:48:19 <e1024> 46 bits not undoable is it?
14:48:25 <monochrom> Yeah, just ask the compiler.
14:48:36 <crucify_me> I thought it was elsewhere
14:49:06 <[exa]> e1024: your best luck is to think that password is salted hash of the username with possibly less than 46bits of the hash; in which case you can try bruteforce (after you magically guess their padding)
14:49:08 <dminuoso> ski, pretty sure its equivalent to a
14:49:10 <crucify_me> ok so Fractional is not an instance of Num, so there lies the problem
14:49:28 <jle`> crucify_me: newtype is basically the thing you are describing, syntactically, except there are some different runtime characteristics with respect to laziness
14:49:28 <ski> dminuoso : "it" being ?
14:49:39 <dminuoso> ski, upperOmega
14:49:40 <jle`> crucify_me: that should be fine, since you already derive Num
14:49:50 <jle`> assuming you have GeneralizedNewtypeDeriving on
14:50:03 <dminuoso> ski, so wait. oh...
14:50:12 <ski> crucify_me : didn't we mention this before ?
14:50:16 <dminuoso> ski, How did this even typecheck with Santa a?
14:50:24 <crucify_me> ski sorry I'm lost
14:50:25 <e1024> I was figuring it would be a simple hash without salt as they are only securing wifi at a coffe shop. Just a bit of fun. I could probably get easier results spoofing someone elses MAC. Was just curious if some script existed that could crunch it for me
14:50:39 <dminuoso> Oh I see.
14:50:43 <ski> dminuoso : check the types of each subexpression in `lowerOmega (MkSanta lowerOmega)'
14:51:36 <dminuoso> ski, this is getting interesting. I mean its obvious it has to be a, for the same reason I deduced D originally
14:51:40 <[exa]> e1024: I'd actually bet they didn't invent it themselves, try googling for someone who sells it with source code :]
14:51:41 <dminuoso> ski, when lowerOmega is applied, it produces a.
14:51:51 <crucify_me> I tried this code with the { GeneralizedNewtypeDeriving ...} bit but it didn't work. I lost that code couldn't find it on searching (telling me how dangerous it is to use)
14:51:54 <ski> dminuoso : `upperOmega :: forall a. Santa a' is more specific than `upperOmega :: forall a. a' (the `forall a.' expresses that it's polymorphic in `a'. that part is optional here)
14:52:07 <e1024> OK thanks exa
14:52:24 <ski> dminuoso : you can always specify a more specific type signature than what could be inferred (as long as it's consistent with the more general one, of course)
14:52:52 <ski> dminuoso : *nod*
14:53:52 * hackagebot liquid-fixpoint 0.7.0.1 ‚Äì Predicate Abstraction-based Horn-Clause/Implication Constraint Solver ‚Äì https://hackage.haskell.org/package/liquid-fixpoint
14:53:57 <dminuoso> ski, this is interesting. I mean I have no idea what my code means anymore with those type changes, but I can at least reason about the types.
14:54:03 <ski> dminuoso : now, if you feel you're ready to tackle it, you could try one (or both) of the two fixed-point combinators i suggested .. possibly after playing them as lambda-calculus expressions to reduce by hand, on paper, to familiarize yourself with how they work
14:54:16 <jle`> generalizednewtypederiving is bad?
14:54:21 <ski> s/playing them/playing with them/
14:54:22 <crucify_me> jle`: ok that works !! , but for learning purposes I think I'm not supposed to use that..
14:54:45 <dminuoso> ski, well if I understand it right, its basically the same concept as `foo = 1 : foo`
14:55:01 <ski> crucify_me : why not just write an explicit `instance Num Nada where ...' ?
14:55:01 <jle`> crucify_me: yeah you can write a Num instance then and you'll be fine
14:55:16 <jle`> i've written so many Num instances in my haskell lifetime
14:55:21 <crucify_me> ski this is a book example, I can't write diddly
14:55:22 <jle`> sorry, just ranting
14:55:29 <dminuoso> ski, I think Ill do that tomorrow. gotta get some sleep. really just came into the channel for a quick question before I headed to bed. didnt plan on staying for 2 more hours fighting GHC :)
14:55:41 <ski> dminuoso : that `foo' could be defined as `foo = fix (\myself -> 1 : myself)', using `fix' (the standard Haskell fixed-point combinator), yes
14:55:43 <jle`> if the book example has deriving (Num), then it assumes GeneralizedNewtypeDeriving
14:56:58 <crucify_me> jle`: thanks, no the book says something like if you don't know how to use a Num here you cannot use Fractional. lyx*ia gave me a hint to put Num in the deriving parameters
14:57:37 <crucify_me> but I also had Fractional there which broke it
14:57:53 <crucify_me> so it compiles
14:58:33 <jle`> it must not have been meant to compile as-is, then
14:59:01 <crucify_me> no if you have time I'll paste the original and the error
15:01:57 <vagrant-> what's the right way to specify a "conditional default" instance of a type class? Something similar to how Aeson does it, where if a type is an instance of `Generic` you can just say `instance ToJSON X` or whatever. Basically I want to be able to define a class where an instance can be generated automatically (using other type classes) but it can also be written by hand
15:02:19 <jle`> the way aeson does it is pretty standard
15:03:00 <jle`> a lot of libraries do it the same way
15:03:31 <crucify_me> jle`: https://ptpb.pw/0HZJ
15:03:33 <vagrant-> jle`: using the `default` keyword?
15:03:52 <jle`> crucify_me: yes there is no way that will ever compile as-is
15:04:05 <jle`> it probably isn't meant to
15:04:13 <jle`> ther emight be a Num instance written somewhere else, or implied by the code
15:04:18 <jle`> *by the book
15:04:32 <crucify_me> here's what the book says after the error message ...
15:04:44 <jle`> vagrant-: yes
15:05:39 <crucify_me> You need a Num instance first. Can't write one that makes sense? Then you're not allowed to have a Fractional instance either. Them's the rules.
15:06:04 <vagrant-> jle`: cool, looks like that's working :)
15:06:08 <crucify_me> so I just don't get the point of what this is telling me
15:06:26 <jle`> hard to tell without more context
15:06:31 <jle`> is it a section about things you can't do in haskell?
15:06:38 <jared-w> It's telling you to try to not shoehorn random types into num instances if they don't clearly make sense
15:07:14 <jared-w> A lot of imperative programmers get into this habit of treating stupid shit like numbers because "if you squint hard enough, it works". Haskell /really/ doesn't want you to do this because its typesystem is expressive enough that you don't need to
15:07:17 <crucify_me> oh so its not expected that you correct the code then?
15:07:28 <jared-w> nope
15:08:06 <monochrom> vagrant-: In the GHC Users Guide, look for "Default method signatures".
15:08:48 <crucify_me> thanks, I'm still very sketchy about the type definitions like this. I was just getting used to type signatures and how to write functions based on them
15:08:51 <crucify_me> jle`: 
15:09:21 <crucify_me> at least that part is beginning to feel comfortable
15:11:20 <crucify_me> jle`: so if Num is a superclass of Fractional, why isn't it inherited when Fractional is implemented there? 
15:12:07 <dmwit> Inherited from where?
15:12:26 <monochrom> Who wrote the code of (+)?
15:12:29 <dmwit> That is, where should the implementations of `Num` methods come from?
15:12:35 * dmwit high fives monochrom
15:12:38 <crucify_me> ok , I see wait. because it is more specific than Num. so its not implicit
15:13:02 <jared-w> yes. People think of inheritance in a Java/OOP standpoint and it's really not the same thing in Haskell
15:13:21 <crucify_me> jared-w: worse: I don't know java either
15:13:31 <monochrom> This is why metaphors are useless.
15:13:32 <jared-w> No, no, that's not worse, that's a good thing ;)
15:13:40 <crucify_me> !!
15:14:26 <crucify_me> but ok so you cannot bake Num into that without using that (apparently dangerous) thingy at the top?
15:14:51 <jared-w> Well you can write num yourself as well, there's nothing wrong with that
15:15:38 <crucify_me> jared-w: please , I beg you, show me how .. that's all I was asking. I am thinking in terms of how inheritance works in the type signatures
15:16:09 <crucify_me> If that is not too badly worded
15:18:36 * hackagebot hol 1.1 ‚Äì Higher order logic ‚Äì https://hackage.haskell.org/package/hol
15:19:49 <crucify_me> I have only some experience with scheme, and I spent most of the time brushing up on maths
15:19:58 <monochrom> Oh neat hol.
15:20:13 <crucify_me> whats hol
15:20:31 <monochrom> The package up there.
15:20:46 <crucify_me> yeah no clue
15:25:22 <ski> dminuoso : *nod*. good night, pleasant dreams. good luck with further Haskell and lambda-calculus learning
15:46:01 <mbw> Is there any documentation whatsoever about the less-often used mtl/transformer functions, or examples of how to use them and in which cases it makes sense to do so? Specifically, I have the mapX/mapXT functions in mind, but since the documentation of these packages is just a *joke*, this could apply to any other function tomorrow...
15:46:34 <glguy> mbw: You need those functions when you need something that has their types
15:55:27 <mbw> glguy: But that could apply to any haskell function in general. But I have a concrete example. I have some function using the Writer monad (yeah yeah, space leaks, I know...). So f :: MonadWriter SomeType m => Input -> m Output. I call this function with another function which should apply a transformation to "SomeType", turning into "SomeOtherType", so ideally g :: MonadWriter SomeOtherType m => Input -> m 
15:55:33 <mbw> Output. While surely there are better solutions for this, let's stick with MonadWriter for the sake of argument. I can get the accumulated values transformed by either using mapWriterT, or binding the result of runWriterT and "tell"ing the modified value. Both approaches typecheck, but I have no indication whatsoever if this is in any way idiomatic, or what pros&cons comes with this in the long run, for 
15:55:39 <mbw> instance when I have to choose a concrete transformer stack.
15:58:47 <glguy> mapWriterT doesn't have anything to do with MonadWriter, so we can factor that out of the question
16:01:11 <glguy> transformers is just a core set of types people are likely to want to piece together. It's wrong to think of it as some kind of abstract framework for structuring your program
16:01:34 <glguy> You should use types and operations form it when they're the ones you wanted. Looking at the source code is in scope
16:02:03 <glguy> It's not an endorsement of any program structure
16:06:43 <mbw> Fair enough. Still, there are times when certain types or abstractions fit the bill, and times when they don't. I get that I can't expect a library auther to tell me what to do, but on the other hand, just staring at the types just doesn't cut it either.
16:06:59 <glguy> I don't think there are many general recommendations to be made about using these types. One could certainly write a tutorial on some uses of types and operations from transfomers
16:07:17 <glguy> But the transformers package doesn't exist as a recommendation for you to use it
16:07:31 <glguy> or need to endorse any particular use pattern
16:07:38 <epta> `data X = A X | B X | C X | Z'. how to express on type level `X without C'? The only thing that come to mind is to have additional `data X1 = A1 X1 | B1 X1 | Z1', but it doesn't scale. What would be great to have is some kind of a constraint. Can some fancy pseudo dependent types help here?  
16:08:38 * hackagebot hw-json 0.5.0.0 ‚Äì Memory efficient JSON parser ‚Äì https://hackage.haskell.org/package/hw-json
16:09:09 <glguy> epta: You can do: data X a b c = A a | B b | C c | Z; newtype XwithoutC = XwC (XwC XwC XwC Void)
16:09:22 <glguy> or some variation on that, if you find that you need extreme flexibility
16:10:20 <mbw> glguy: Would an example really be an endorsement or a recommendation? I don't think that is the case. On the other hand, you might not perceive the general quality of documentation in the majority of the popular packages as a problem either :/
16:11:55 <Cale> epta: Can you give a more concrete idea of what it is that you're representing with your type?
16:12:09 <glguy> mbw: I just think in this particular case that the types really are the correct descriptions of what the operations do. for this type-driven operations if the types of the operations aren't making sense, then you need to go back and study the types of things like Writer or State first
16:16:48 <epta> Cale: it's a recursive tree with various kinds of leaves. There is an operation which removes one particular kind of leaf. Thus, it'd great to express on type level whether this operation was already done or not
16:17:48 * hackagebot cusparse 0.1.0.0 ‚Äì FFI bindings to the CUDA Sparse BLAS library ‚Äì https://hackage.haskell.org/package/cusparse
16:17:48 * hackagebot cublas 0.3.0.0 ‚Äì FFI bindings to the CUDA BLAS library ‚Äì https://hackage.haskell.org/package/cublas
16:20:39 <mbw> glguy: I don't think I can agree to this. While a certain level of experience is to be expected for use of this library or the other, adding an example just doesn't hurt. Telling people to "go back and study" might come over as derogatory as well, like they have "no business using this function yet". I'm sure this is not your intention, but at what point do you draw the line? Would the lens library without 
16:20:45 <mbw> any examples or explanatory text be self-evident? I don't think so.
16:21:28 <glguy> No, I don't think there's a slippery slope argument to make here
16:21:59 <Cale> epta: One thing you might do is to factor the type such that it takes the type of leaves as a parameter -- though you're still faced with how to deal with two different types of leaves, perhaps the difference then is smaller.
16:22:44 <Cale> epta: Maybe the original tree is initially supplied something like (Either a b) as an argument, and after the transformation, b
16:24:01 <epta> glguy: Data constructor ‚ÄòXwC‚Äô cannot be used here (it is defined and used in the same recursive group)
16:24:42 <glguy> epta: I meant: newtype XwithoutC = XwC (X XwC XwC Void)
16:24:55 <Wizek> Hello! For first class pattern matches (i.e. have a pattern as a fn parameter) the lens package's `Prism`s can be used, right? And if so, how would you write a simple `case a of { Just b -> b + 1; Nothing -> 3}` with Prisms?
16:24:56 <glguy> errr
16:25:04 <glguy> epta: I didn't mean that either :) fixing:
16:25:21 <glguy> newtype XwithoutC = XwC (X XwithoutC XwithoutC Void)
16:27:06 <glguy> http://lpaste.net/2477925246204641280 
16:27:07 <epta> glguy: yep, got it
16:32:54 <monochrom> I view from the economics angle. How much money will you pay for more doc?
16:33:22 <glguy> epta: http://lpaste.net/357949 This is another approach using GADTs
16:33:38 <Wizek> Interesting. `Just 10 $> (undefined & outside _Just .~ succ & outside _Nothing .~ const 3)` => 11
16:33:49 <SwiftsNamesake> Hey people
16:33:54 <SwiftsNamesake> I need some help with conduit: https://stackoverflow.com/questions/45872285/conduit-parser-is-interrupted-prematurely
16:34:43 <epta> glguy: whoa, nice! Btw, I was thinking about `eqNat' in Idris trying to understand could it be related or not
16:40:27 <epta> glguy: can't we already have named type variables like `data X :: (hasA :: Bool) -> (hasB :: Bool) -> (hasC :: Bool) -> Type'?
16:41:08 <glguy> No, but what would that do if we could write it?
16:42:22 <glguy> You can write: data X (hasA :: Bool) (hasB :: Bool) (hasC :: Bool) where... but that just leads to confusion
16:46:02 <remexre> Is there a easy way to impl MonadReader for a type that is MonadState (contains a StateT)
16:46:52 <remexre> I'm getting type errors on ask...
16:46:53 <glguy> remexre: MonadReader is for lifting the use of ask to the outermost ReaderT
16:47:35 <remexre> My monad has a "mostly" immutable state, but it does get mutated occasionally
16:47:43 <remexre> And I want the local function of MonadReader
16:50:19 <ski> remexre : define your own "version" of `local' ?
16:52:02 <remexre> I suppose... I still feel like it'd make sense to define it, but OK
16:52:51 <ski> @let localState :: MonadState s m => (s -> s) -> m a -> m a; localState f act = do s <- get; put (f s); a <- act; put s; return a
16:52:52 <lambdabot>  Defined.
16:53:04 <remexre> :P
16:53:26 <ski> in case `act' may abort the computation, this may behave unexpectedly (no `finally' to use here)
16:55:31 <ski> (perhaps one could take this as an argument for `localState' being a method of `MonadState' (or perhaps a subclass), so that `instance MonadState s m => MonadState s (ExceptT e m)' can restore the state in `localState')
16:56:27 <remexre> So if I explicitly have an ExceptT, I should handle that too?
16:57:04 <ski> a potential law of `localState' might be `localState f act = do s <- get; a <- localState f act; put s; return a'
16:57:48 <ski> .. however, i think `StateT s (ExceptT e m)' (as opposed to `ExceptT e (StateT s m)') will probably fail this law .. hmm
16:58:18 <ski> remexre : depends on whether that's what you want to do .. but i think often one'd think that to be reasonable
16:58:25 <remexre> ok
17:00:26 <ski> (a similar problem would be interactions with `ContT'. in Scheme `dynamic-wind' (comparable to `finally') interacts with `call-with-current-continuation' (`callCC'), allowing the "finalization", and later possible restoration of a dynamic context)
17:01:26 * hackagebot cusolver 0.1.0.0 ‚Äì FFI bindings to CUDA Solver, a LAPACK-like library ‚Äì https://hackage.haskell.org/package/cusolver
17:02:20 <remexre> Huh, is that how the "green threads without a runtime" trick works?
17:04:54 <Maxdamantus> Could be.
17:06:05 <ski> "A Poor Man's Concurrency Monad" by Koen Claessen in 1999 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039>
17:06:13 <ski> remexre : do you mean something along those ^ lines ?
17:06:21 <ski> (Functional Pearl)
17:07:37 <Maxdamantus> related  code: https://gist.github.com/Maxdamantus/deba042bcbbdb76998a9ebbc68bb339d
17:08:10 <Maxdamantus> Assuming that's the right gist (haven't opened it), it's basically an implementation of threads in JS without any runtime.
17:08:32 <Maxdamantus> You just "run" an IO operation when you want.
17:09:00 <remexre> Maxdamantus: possibly? My JS skills are a bit rusty
17:09:11 <remexre> ski: I think so, but I saw a blog post in Scheme
17:12:16 * ski idly wonders how Maxdamantus' gist would look in typescript or purescript or something like that
17:12:45 <iqubic> Why? What does his gist look like right now?
17:15:55 <remexre> iqubic: it's https://gist.github.com/Maxdamantus/deba042bcbbdb76998a9ebbc68bb339d
17:17:26 <iqubic> Yeah, that's not Haskell.
17:34:18 <Maxdamantus> ski: you can pretty much just add types to that code to make it fully typed TS.
17:34:34 <Maxdamantus> though not the yield parts.
17:35:28 <ski> Maxdamantus : recursive ?
17:35:53 * Maxdamantus has wondered if it'd be nice to be able to write iterator functions with a given type for `yield`
17:36:08 <Maxdamantus> ski: what about recursive?
17:36:27 <ski> recursive types ?
17:36:52 <Maxdamantus> Sure, it would involve recursive types, which TS supports.
17:37:14 <Maxdamantus> It pretty much needs to support them since it doesn't have nominal types.
17:37:14 <ski> (when i last did something a bit similar, i ended up with recursive types. i was wondering how the recursive type(s), if any, would look in your case)
17:37:32 <ski> oh, it has equi-recursive types ?
17:37:43 <ski> (aka infinite/cyclic/rational types)
17:37:51 <Maxdamantus> Yes.
17:38:33 <ski> (while Haskell only has iso-recursive types. `ocaml -rectypes' has equi-recursive ones. without that flag, only if every cycle goes through at least one object type)
17:39:10 <Maxdamantus> type IO<T> = { bind<U>(fn: (r: T) => IO<U>): IO<U>; ... };
17:39:45 <ski> (the argument against equi-recursive types is that it turns lots of common type errors into type-correct code with very strange cyclic types. i assume you already know this)
17:39:56 <Maxdamantus> Indeed.
17:40:38 <ski> `bind' being polymorphic in `U' ?
17:40:48 * ski supposes so
17:40:51 <Maxdamantus> Though I suspect a lot of those cases don't apply to TS since it doesn't do something like HM.
17:41:04 * ski nods
17:41:17 <Maxdamantus> ski: yes, IO<T> is rank-2.
17:41:20 <ski> explicit declaration of types ?
17:42:05 <ski> i suppose i was more interested in the types of `read' and `write' (and then `make', in terms of those)
17:42:58 <Maxdamantus> Well, it does inference from the RHS of a declaration, basically.
17:43:02 <iqubic> "Inroduction to Automata Theory, Languages, and Computation" is a wonderful book
17:43:17 <Maxdamantus> So you an't write something like `let x = x;`
17:43:40 <iqubic> > let x = x in x
17:43:41 <Maxdamantus> or `let x = () => x;`
17:43:46 <lambdabot>  mueval-core: Time limit exceeded
17:43:56 <iqubic> > let x = () in x
17:43:58 <lambdabot>  ()
17:45:24 <Maxdamantus> Actually, it does allow that, but it infers the type as involving some `any`
17:47:23 <mnoonan_> does ocaml support rank-2 types? I thought I read somewhere that it did, but I couldn‚Äôt find the source when I was looking again recently.
17:52:15 <Maxdamantus> It apparently supports what rank-2 types provide in objects.
17:52:44 <Maxdamantus> from what I remember reading about it .. I'm not particularly familiar with it.
17:53:24 <Maxdamantus> (so it has some concept of objects, where an object might have a method with a universal quantification)
17:54:15 <mnoonan_> Maxdamantus: ah, that sounds sort of familiar from TAPL
17:55:00 <mnoonan_> I‚Äôve never sat down and figured out the object system, so it still makes me squeamish from a theoretical perspective. 
17:56:10 <remexre> How would I implement something like Rust's associated types in Haskell?
18:11:56 <adelbertc> remexre: assuming i understand associated type in rust, theyre the same as associated types in haskell arent they
18:12:09 <adelbertc> or type families i guess
18:18:09 <c_wraith> rust's associated types are the same as Haskell's
18:18:39 <c_wraith> though obviously there are differences like an associated type can be higher-kinded in Haskell. 
18:21:01 <remexre> Oh, didn't know Haskell has associated types
18:22:57 * hackagebot network-api-support 0.3.1 ‚Äì Toolkit for building http client libraries over Network.Http.Conduit ‚Äì https://hackage.haskell.org/package/network-api-support
18:25:24 <ski> does rust have real existentials, yet (by which i mean allowing `exists a. C a *> Foo a', and not just `exists a. C a *> a') ?
18:53:19 * hackagebot git-vogue 0.2.2.2 ‚Äì A framework for pre-commit checks. ‚Äì https://hackage.haskell.org/package/git-vogue
18:59:13 <mnoonan_> is there a way to constrain a polymorphic type so that it can only be used at a certain role? specifically, I have a Traversable f that (I think) I want to restrict to ‚Äúf‚Äùs that have a representational type parameter
19:01:06 <mnoonan_> or more concretely, I want to be able to do ‚Äúcoerce (f x)‚Äù rather than ‚Äúfmap corce (f x)‚Äù, but ghc complains that ‚Äúf‚Äù could have a nominal type parameter
19:07:43 <glguy> mnoonan_: No, that's one of the limitations of the role system
19:08:39 <glguy> You can add a constraint like: Coercible (f something) SomethingElse
19:09:09 <mnoonan_> oh, sure.. that‚Äôs probably good enough
19:11:00 <mnoonan_> out of curiosity, is there anything theoretical that would prevent us from being able to write role constraints, or is it just a limitation of the implementation?
19:14:29 <char2> b
19:17:26 <d34df00d> Hi!
19:18:31 <d34df00d> Let's say I want to write a function `spitSomeJSON` that would produce, well, some value that's encodeable into JSON. I cannot write `spitSomeJSON :: A.ToJSON a => a` because when I'll do the implementation, the typechecker won't match the expected `a` with the exact value I'm spitting out.
19:18:59 <d34df00d> Is there a way to solve this without resorting to a newtype with existentials?
19:20:46 <glguy> spitSomeJSON :: Value
19:21:21 <d34df00d> You mean Data.Aeson.Value?
19:22:15 <d34df00d> In any case, the overall API of my thing would seem cleaner if I only produce the encodable value at this point, not the final JSON (and IIRC the Value intermediate thing is costly in recent Aeson versions).
19:40:22 <jchia1> megaparsec 6 migration question: What happened to Text.Megaparsec.Error.Dec and Text.Megaparsec.String.Parser? What do I replace them with?
19:47:44 <jchia1> alternatively, is there a megaparsec 6 example? my old code doesn't even build
19:47:53 <jchia1> can't even import things
19:55:26 <trigone> hi! i'm stuck in trying to use stack. i don't find a way to just tell it that i don't want to build any executable, just a library to be used by other packages... it seems any project is inherently focused around creating an executable... :/
19:56:04 <mnoonan_> trigone: just use the simple-library template
19:56:20 <mnoonan_> ‚Äústack new my-project simple-library‚Äù
19:56:47 <mnoonan_> or do that, and then compare the .cabal file you get with what you have been getting
19:59:39 <trigone> mnoonan_: ok i'll try that, thanks! :D
20:02:21 <trigone> mnoonan_: hm i get it, so we just have to remove some parts in the cabal file? btw it also omitted a test subsection, is it inherent or just bc the template tries to be as simple as possible?
20:03:38 <mnoonan_> it‚Äôs just trying to be simple, you can add in whatever you like
20:04:09 <mnoonan_> it isn‚Äôt doing anything weird, just setting up some initial files and directory structure. you can do whatever you want from there.
20:04:31 <trigone> mnoonan_: ok thx! by any chance, would you know how i could use a library in a project into other projects?
20:04:53 <trigone> i read some stuff on the website of stack but to be fair i barely understood half of it...
20:06:02 <mnoonan_> a library of your own, or something on hackage / stackage?
20:07:31 <mnoonan_> you just add the package name to your build-depends and, if it isn‚Äôt something that can be grabbed from your resolver‚Äôs package set, you give a path or url for the package under ‚Äúpackages:‚Äù in your stack.yaml
20:07:54 <trigone> mnoonan_: hm... can i use absolute paths?
20:08:17 * mnoonan_ shrugs
20:08:24 <mnoonan_> there is an easy way to find out :)
20:10:07 <trigone> yeah, i'll try (after i sleep a bit). just, what about versions? it has a number included in cabal which you can change, but unless i make tons of copies of my project, i don't see how stack will be able to pull out previous versions of the library, unless there's a way to "install
20:10:27 <trigone> " them somewhere in a more "permanent" way...
20:10:46 <trigone> (somewhere locally on my computer)
20:11:09 <trigone> though i guess manual copy isn't that much of a hassle
20:12:03 <trigone> oooh nevermind, i just tried building the library test and it seems as if it installed it at a location accessible to the whole system
20:12:14 <mnoonan_> if you have a git repo, you can point it at a specific commit: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages
20:13:11 <trigone> actually it installed it inside the project directory, but it seems to imply that you could install several versions of the same library...
20:13:32 <trigone> mnoonan_: yeah but i still haven't found the time to learn how to use git..
20:14:26 <mnoonan_> that might be a better career move than learning Haskell :)
20:15:17 <u-ou-> hello
20:16:10 <trigone> mnoonan_: i learn haskell for my pleasure so far :P
20:16:46 <u-ou-> learn perl 6 too!
20:19:44 <trigone> u-ou-: how better than perl is it? cuz the latter has a rather bad reputation
20:21:32 <trigone> *how much
20:21:55 <u-ou-> Idk. I like it better than Perl 5.
20:22:01 <u-ou-> But I'm no good at selling things :p
20:37:39 * hackagebot raaz 0.2.0 ‚Äì The raaz cryptographic library. ‚Äì https://hackage.haskell.org/package/raaz
20:58:09 <tempay> So I'm trying to track down an exception (Prelude.maximum: empty list) in my test suite. I'm using stack test --profile to try to get the stack trace. But all it says is "CallStack (from -prof):   GHC.List.CAF (<entire-module>)"
20:58:22 <tempay> Any idea what that means or how to get more information?
21:03:41 <johnw> you need to build your own library with -fprof-auto
21:03:59 <johnw> otherwise, it doesn't know about cost centres in your own code
21:04:14 <johnw> dunno if stack handles that automatically or not
21:09:59 <texasmynsted> anybody use https://github.com/bitc/vim-hdevtools with stack?
21:11:23 <texasmynsted> oops nm, found this https://github.com/bitc/vim-hdevtools/issues/22
21:13:12 <tempay> johnw: thanks i'll try that
21:37:23 <pacak> texasmynsted: Most recent hdevtools supports hdevtoolsrc file where you can add extra options.
21:38:04 <pacak> (I added it to make sure it's working without stack, but it might help you to make it work with stack)
21:40:09 <texasmynsted> oh
21:40:38 <texasmynsted> That would likely be a better approach.
21:40:56 <texasmynsted> I created a shell function that takes over the calls to hdevtools
21:41:17 <texasmynsted> where did you see about hdevtoolsrc file?
21:42:12 <pacak> https://github.com/hdevtools/hdevtools/commits/master
21:42:42 <texasmynsted> oooh.  I was using an older version I think
21:42:43 <pacak> https://github.com/hdevtools/hdevtools/pull/59 - this
21:42:49 <texasmynsted> bitc/hdevtools
21:43:00 <texasmynsted> or at least that is what I was looking at in github
21:53:50 <platz> is there a way to tell haddock to generate links to external types via a url instead of a default relative file reference?
21:55:19 <platz> i'm using "--odir=./docs" to redirect the output but it also breaks the links to external libs, but it would also be ideal to ref those via url
22:01:45 * hackagebot rtcm 0.2.6 ‚Äì RTCM Library. ‚Äì https://hackage.haskell.org/package/rtcm
22:52:50 <char2> qfpl
23:07:36 * hackagebot aip 0.0.1 ‚Äì Aeronautical Information Package (AIP) ‚Äì https://hackage.haskell.org/package/aip
23:59:40 <kuribas> is duck typing parametric polymorphism for lazy programmers?
