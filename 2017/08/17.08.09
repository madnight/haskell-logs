00:00:04 <edwardk> i used it to implement PNG generating code in a little cellular automata example in like 50 lines
00:00:51 <edwardk> https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-2
00:01:10 <edwardk> see the adler32 moore machine in that article and the one for crc32
00:01:27 <cocreature> I’ll take a look at that later today, thanks!
00:01:45 <cocreature> at some point I read that article but revisiting things is always surprisingly useful :)
00:02:07 <[exa]> edwardk: wow that's super cool
00:02:16 <cocreature> I guess I don’t need to tell you that since you have a whole talk about it ;)
00:02:30 <edwardk> heh
00:02:32 <Axman6> damnit, stop adding things to my list of articles to read that's three more today
00:02:41 <Axman6> or, should I say... three moore?
00:02:45 <Axman6> >_>
00:03:45 * hackagebot separated 0.2.3 – A data type with elements separated by values – https://hackage.haskell.org/package/separated
00:03:45 * hackagebot cmark-gfm 0.1.2 – Fast, accurate GitHub Flavored Markdown parser and renderer – https://hackage.haskell.org/package/cmark-gfm
00:03:45 <edwardk> https://www.schoolofhaskell.com/user/edwardk/snippets/mandelbrot shows how to modify the tiny png generator i wrote inline in the previous file to produce incremental pngs so i can do a mandelbrot set that starts showing once 1/64th of the data is available.
00:04:05 <edwardk> maybe i should modify that with a more modern style of blending
00:04:16 <edwardk> we know how to do nice continuous mandelbrots now
00:04:56 <ex0th3rmic> you trying to builid an infinite fractal generator?
00:05:03 <edwardk> http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm
00:05:08 <edwardk> ^- no, just that
00:05:20 <edwardk> makes much prettier mandelbrots
00:05:39 <edwardk> its not even a lot of work
00:06:34 <jared-w> nice
00:07:02 <edwardk> i'm still sad that school of haskell disabled all the autorun features on the site
00:07:10 <edwardk> that was a huge draw for those articles
00:07:21 <edwardk> now i might as well rehome them to comonad.com so they can be found
00:07:59 <jared-w> yeah :( were they ever gonna re-enable that?
00:08:49 <edwardk> Axman6: if you want yet another article for the pile, https://www.schoolofhaskell.com/user/edwardk/parallel-crc talks about more crc stuff and uses a comonad for monoidal folds
00:09:18 <Axman6> stop, pls
00:09:24 <Axman6> (but ues, I really do)
00:09:52 <Axman6> someone (you?) did a really interesting talk on monoidal hashes, and had amazing results
00:10:17 <edwardk> finally, https://www.schoolofhaskell.com/user/edwardk/conquering-folds finishes out that approach and builds up the machinery for working on parallel computations using the third homomorphism theorem. never did anything with it though
00:10:41 <edwardk> i use hashes that have nice algebraic structure a lot actually
00:11:20 <edwardk> notably, the simple hash that uses say, residue modulo a prime has a great property that it can be computed monoidally
00:11:53 <Axman6> awesome
00:12:04 * jared-w makes a note to just go through sometime and spend a year or two going through every post by edwardk on schoolofhaskell
00:12:29 <edwardk> Hash a b <> Hash c d = Hash (a * 2^d + c) (b + d) -- gives you an updated hash and character count; Hash 0 0 is the unit.
00:12:31 <Axman6> ok, I have a fortnight off work next week, I know what I'm reading (as well as Seveneves)
00:12:54 <edwardk> if you squint at it and pick the right number system, e.g. working in Z_p for some prime you get a standard prime modulus hash
00:13:01 <edwardk> if you pick a galois field you get a CRC
00:13:12 <edwardk> that is what that parallel crc article is about
00:13:21 <edwardk> which is the same math as brent yorgey talked about in a paper
00:14:36 <ongy> parallel crc? what's the usecase?
00:14:38 <ex0th3rmic> what's a good hashing algorithm to use
00:14:54 <c_wraith> ongy: calculating crcs faster.
00:14:57 <edwardk> ongy: parallel is also a gateway to incremental once it is monoidal
00:15:00 <c_wraith> ex0th3rmic: for what purpose?
00:15:07 <edwardk> so you can make edits in the middle of a document and get the crc of the result
00:15:09 <ex0th3rmic> password encryption
00:15:18 <edwardk> without having to touch the whole thing
00:15:23 <ongy> ah, that makes sense
00:15:25 <edwardk> i use it in a modified setting for things like rolling hashes
00:15:28 <ongy> hashes aren't encryption
00:15:42 <c_wraith> ex0th3rmic: use scrypt, bcrypt, or PBKDF2 with proper parameters (in that order of preference)
00:16:02 <ex0th3rmic> k thanks
00:16:09 <edwardk> e.g. something like https://github.com/ekmett/hash/blob/b7131e68bd1ccea096dc9cacf980a3197496c4c5/src/Data/Hash/Rolling.hs#L63 can be used to find good split points for a merkle tree
00:16:36 <edwardk> 'good' in the sense that they only care about a local window, so inserts tend not to break the entire merkle tree
00:16:39 <edwardk> rsync uses this approach
00:16:50 <JuanDaugherty> edwardk, did you invent lenses, at least as far as hs is concerned?
00:16:50 <edwardk> the hash there is a simple prime hash like i described above
00:17:21 <jared-w> ongy: encryption doesn't have to be government-level security. Hashes can work as an encryption :p
00:17:23 <c_wraith> ex0th3rmic: an important goal for password hashing is that it be as slow as you can tolerate in your use case.  So tune performance parameters such that it's as slow as you can stand. :)
00:17:40 <cocreature> jared-w: no you can’t decrypt a hash
00:17:42 <ongy> jared-w: no. hashes aren't encryption. they lack the property of being reversable
00:17:53 <jared-w> oh right, nvm
00:18:01 <edwardk> JuanDaugherty: they were invented before me. they come out of the 'bidirectional transformations' community, and benjamin pierce wrote the version i started from as an afterthought in a paper about a different sort of lens.
00:18:29 <c_wraith> JuanDaugherty: you can even think of the https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf paper as sort of foretelling the coming of lenses. :)
00:19:07 <thimoteus> afaik there were several lens implementations before edwardk's became the standard
00:19:16 <edwardk> JuanDaugherty: there was an fc-labels package and a few others before i shipped data-lens. and then after i used data-lens for a while i got frustrated and stopped using them for a while. roconnor reinvigorated the discussion by removing the type signatures from van laarhoven lenses and noting some connections to traversable, and i added laws and wrote lens because i kinda hated the api he put into lens-family
00:19:58 <edwardk> the problem that i had with the lens implementations that everyone had before is that every single god damn person on the planet took a perfectly good lens and then tried to make it 'monadic' somehow, but couldn't tell me any laws for the resulting abomination.
00:20:17 <jared-w> lol
00:20:39 * koz_ has an image of edwardk as Judge Dredd.
00:20:41 <c_wraith> that's a large part of why the Essence of the Iterator Pattern paper is a precursor to lenses.  It demonstrates Applicative is enough
00:20:53 <jared-w> But at least they could use it in do notation, sorta? :p
00:21:04 <edwardk> I _am_ the (lens) law(s)!
00:21:17 <koz_> Yep, that exactly.
00:21:31 <c_wraith> If you were really about the lens laws, you'd shoot (change the type signature on) filtered.  :P
00:21:33 <edwardk> Essence of the Iterator Pattern really put Traversable on firm footing
00:21:43 <Marisa> It is reason, then.
00:21:53 <edwardk> and the few caveats that were left in it, where they weren't sure it was enough turned out to be non-issues.
00:22:21 <c_wraith> but filtered is so damned useful when you use it to violate the lens laws...
00:22:39 <edwardk> c_wraith: filtered only claims to be a Fold. =) what do you mean? =)
00:23:01 <Marisa> (do anyone get that starwars meme?) A very unrelated question, but is there some abbreviation for 'code example'? example seems a bit long for a directory name...
00:23:09 <c_wraith> > [1..10] & traverse . filtered even +~ 1
00:23:10 <jared-w> "filtered and loose folding is morally correct"
00:23:11 <lambdabot>  [1,3,3,5,5,7,7,9,9,11]
00:23:21 <edwardk> the entire lens package doesn't care about the lens laws. it all works if you ball them up and throw them out. the combinators cease to be canonical, but they remain perfectly usable
00:23:40 <edwardk> this is why there is a cottage industry describing lenses in terms of profunctor optics and ignoring the laws in the process
00:24:03 <edwardk> this reminds me i have an article to write on groupoid-encodings of lenses that fix that and enforce the laws
00:24:20 <jared-w> While keeping the profunctor shiny bits?
00:24:21 <c_wraith> I'm just saying.. a small change in the type of filtered and it's *actually* a Fold....  :)
00:24:58 <edwardk> jared-w: the profunctor bits can be viewed as a lobotomy of the groupoid encoding that is the 'real' notion of an optic we can't talk about in haskell
00:25:10 <c_wraith> (Please don't make that change.  It's too useful this way.)
00:25:19 <edwardk> c_wraith: i have zero intention to.
00:25:33 <jared-w> edwardk: ahh, gotcha. Haskell lacks the ability to fully encode groupoids, I'm guessing?
00:26:10 <edwardk> jared-w: its that you need to have some partially applied type families, control over forall, etc. its just not a thought haskell can really think
00:26:27 <edwardk> you can encode the 'real' version barely in agda or coq but its unusable because of the heaviness of the encoding
00:26:35 <orzo> I'm getting 'The type variable ‘r0’ is ambiguous' but it's one line of code and I used scoped type variables and proxy to make it clear.  Is there some kind of bug where ConstraintKind type variables cannot be disambiguated this way?
00:26:36 <jared-w> I see; that's unfortuante.
00:26:44 <edwardk> but the profunctor approximation is "good enough" for most usecases
00:26:50 <edwardk> and i can point out exactly when it isn't
00:26:57 <edwardk> we've known for years
00:27:04 <c_wraith> Marisa: "sample" isn't really much shorter, but it's a good name regardless
00:27:42 <Marisa> Yeah, that sounds better. (Quick bikeshadding)
00:27:45 <Marisa> quit*
00:27:46 <jared-w> The heaviness of encodings is something I've been thinking of a lot, lately. Humans have this remarkable ability to ignore everything except for the tiny little bit we care about at htat particular moment, so we can skip and dance around all of math and carry around very light-weight encodings and models, knowing full well that we can strap back on all of the guns if we need to. It'd be wonderful to see a
00:27:48 <jared-w> programming language with the same capabilities, somehow
00:28:05 <koz_> jared-w: Computers aren't quite as fast and loose as we are.
00:28:11 <c_wraith> orzo: the fact that it's naming the type r0 suggests that it's not unifying the type the way you expect it to.  If you're using ScopedTypeVariables, did you remember the forall?
00:28:52 <jared-w> koz_: right, but ideally we could design a formal way of creating a "sliding scale" of looseness
00:29:04 <koz_> jared-w: Except humans don't do that.
00:29:14 <orzo> c_wraith: yes, i did, i'm going to mak ea paste
00:29:16 <c_wraith> Does anyone think ScopedTypeVariables should enable a warning for the use of a type variable in a scoped context that matches the outer type variable without the forall?
00:29:17 <koz_> In theory, we can boil down every mathematical result into ZFC.
00:29:17 <jared-w> We don't?
00:29:31 <koz_> In practice, no-one would ever bother, since we go by 'good enough'.
00:29:51 <koz_> We just describe 'the bits we care about' and leave the rest implicit or to the reader.
00:30:21 <jared-w> Is that not a sliding scale of looseness then? Some papers go quite a bit more into detail about the 'bits they care about' and leave less implicit than others do. You can be as implicit or explicit as you want to be
00:30:32 <edwardk> koz_: one good (albeit very mathy) example of having to make things explicit to get the computer to be happy with it sussman's "Functional Differential Geometry" https://groups.csail.mit.edu/mac/users/wisdom/AIM-2005-003.pdf -- mathematicians leave out _so much_ when talking about differential geometry.
00:30:39 <orzo> c_wraith: here it is, https://bpaste.net/show/7fb9acf1d169
00:30:42 <koz_> I think Voevodsky actually said that this can cause serious problems, because when reduced low enough, some results are restatements of the theorems they're trying to prove.
00:31:49 <koz_> edwardk and jared-w: This topic reminds me of something a mathematician colleague of mine told me they had them do as their final assignment for first-year logic at Novosibirsk State.
00:31:54 <orzo> c_wraith: it's used with this type class, https://bpaste.net/show/3fa96daa7ac7
00:31:59 <koz_> 'Prove, using raw ZFC, the existence of a real number.'
00:32:12 <koz_> (well, raw ZFC and first-order logic obviously)
00:32:39 <orzo> lastlog -clear
00:32:41 <edwardk> kinda brutal for a first-year
00:32:45 <jared-w> Take a typing system, for example. You can have an incredibly simple system (like c) or you can have a full dependent type system with HoTT or other fancy shit all over the place like Coq or Agda. But what would be awesome would be to have all of the power of Coq but only occasionally pull it out. If a function's type system falls within the complexity of, say, the HM type system, infrence should be possible
00:32:47 <jared-w> should it not?
00:33:00 <koz_> edwardk: It's Novosibirsk State. They're the second-most hardcore math program in Russia.
00:33:02 <orzo> why doesn't it unify?
00:33:07 <koz_> (first most hardcore being Moscow State)
00:33:08 <thimoteus> raw ZFC is defined with FOL
00:33:14 <edwardk> yeah russian set theory is its own thing
00:33:28 <koz_> thimoteus: Yeah, good point.
00:33:46 <jared-w> Damn, first year? I can't even imagine lol. I doubt quite a few of the grad students here could do that off the top of their head
00:33:49 <koz_> edwardk: I'm wondering if I could construct such a proof.
00:34:18 <koz_> jared-w: Yeah, I was like o_O when I heard that.
00:34:28 <koz_> But then again, said colleague did his PhD in computable model theory.
00:34:35 <thimoteus> it sounds more tedious than anything
00:34:35 <edwardk> reminds me of a short tale by andrej bauer (that i'm mangling i'm sure) about how they had a russian set theorist show up in ljubjana, and talk for 2 or 3 days about his current research... at which point they realized he was talking about a particular applicative functor... encoded in set theory terms.
00:34:50 <koz_> edwardk: LOL.
00:35:00 <koz_> thimoteus: 'Cruel and unusual' would be the term I'd use.
00:35:06 <thimoteus> the construction of the reals isn't so hard to grasp, but if you can only use formulas in ZFC it's just ugh
00:35:17 <koz_> thimoteus: Yeah, it's a lot of very tedious build-up.
00:35:29 <Marisa> All I can think of, is that in Coq one can do admit to skip detail they dont like, and people even build tools around it (see https://arxiv.org/pdf/1506.04205.pdf)
00:35:35 <jared-w> it's like saying "hey write a nice small video game in only assembly mov instructions"
00:35:44 <earthy> fortunately, raw zfc + fol isn't all that big a set
00:35:45 <thimoteus> exactly
00:36:09 <earthy> (of axioms)
00:36:11 <koz_> earthy: ZFC is like, nine axioms if memory serves.
00:36:18 <jared-w> (you can actually write everything using only mov instructions :p)  https://github.com/xoreaxeaxeax/movfuscator
00:36:27 <koz_> jared-w: Yeah, I've seen that.
00:36:29 <thimoteus> well, a few axioms + axiom schemas
00:36:31 <earthy> however, to construct the integers and the reason the diagonalization that proves the existence of the reals...
00:36:37 <earthy> that's a bit of work. :)
00:36:39 <koz_> thimoteus: Just the one axiom schema, right?
00:36:47 <thimoteus> it could be, i can'tremember off the top of my head
00:36:56 <koz_> thimoteus: Neither.
00:37:01 <thimoteus> probably the separation axiom
00:37:08 <koz_> earthy: What's the typical set-theoretical construction for the integers?
00:37:11 <jared-w> My classes haven't covered ZFC yet so all I know is from wikipedia :p
00:37:23 <koz_> jared-w: Your classes probably won't, not in great detail anyway.
00:37:43 <earthy> koz_: IIRC it's based on 0 being equivalent to the empty set, and then the successor being the set containing the previous set
00:37:46 <earthy> or somesuch
00:37:47 <thimoteus> you don't need to use diagonalization to construct the reals, that's just a method to show they're uncountable
00:37:52 <jared-w> eh, true. I keep forgetting how few math courses are actually in most CS degrees :(
00:37:52 <koz_> earthy: That's naturals.
00:38:03 <c_wraith> orzo: what's the definition of TwoWay?
00:38:04 <earthy> koz_: sorry, integers aren't needed to get to the reals
00:38:17 <earthy> (this stuff was in our advanced logic class... which I took 20 years ago)
00:38:27 <koz_> earthy: I feel young hearing that. :P
00:38:27 <thimoteus> yes, the nats are constructed by iterating: n + 1 := {n, n-1, n-2, ..., 0}
00:38:49 <thimoteus> then you get the naturals proper by using the axiom of infinity
00:38:52 <koz_> thimoteus: Yeah, I'm aware. The nats are just the inductive set.
00:39:29 <thimoteus> then you keep going up the ladder of ordinal numbers until you get to the first uncountable ordinal, which is just defined as the set of all countable ordinals
00:39:51 <earthy> oh, yeah, then it gets hairy
00:40:03 <koz_> thimoteus: You're reminding me of a talk I attended when I was just starting out in compsci.
00:40:19 <koz_> It was by this German guy, and he was talking about something which held up to Omega^Omega
00:40:24 <earthy> as you can then make constructions on the uncountable ordinals and constructions on top of that
00:40:36 <koz_> That concept on its own blew my mind.
00:40:39 <orzo> c_wraith: https://bpaste.net/show/4e4c43216e6d
00:40:42 <jared-w> Omega^Omega?
00:40:45 <thimoteus> but the continuum hypothesis not being derivable in ZFC implies that the first uncountable ordinal isn't necessarily order-isomorphic to the reals
00:41:28 <jared-w> koz_: what is omega^omega?
00:41:29 <thimoteus> but it's not too bad to prove 2^X has greater cardinality than X, for any X, so you can embed the reals into any ordinal that looks like 2^X for some countable X
00:41:50 <earthy> jared-w: ask thimoteus, he knows. :)
00:42:05 <thimoteus> omega^omega is the limit of the sequence (omega, omega*omega, omega*omega*omega, ..)
00:42:06 <c_wraith> orzo: oh, I see the issue
00:42:17 <c_wraith> orzo: there's nowhere in the type of sync that actually specifies what r is
00:42:28 <jared-w> And what is omega here? Is it the ordinal number?
00:42:31 <thimoteus> and omega*omega is the limit of the sequence (omega, omega*2, omega*3, omega*4...)
00:42:36 <thimoteus> yes, it's the same as the naturals
00:42:36 <c_wraith> orzo: I should have caught on earlier with ghc saying "NB: ‘Put’ is a type function, and may not be injective"
00:42:42 <thimoteus> {0,1,2,3...}
00:42:58 <jared-w> gotcha. When I think of omega I tend to think of chatlin's constant first so I was just making sure since that didn't make much sense :p
00:43:01 <thimoteus> and omega*2 is the limit of the sequence {omega, omega+1, omega+2, ...}
00:43:17 <thimoteus> yeah, it's unfortunate that math overloads a lot of names and symbols
00:43:24 <JuanDaugherty> i c so you were the sherrif
00:43:25 <c_wraith> orzo: the only places r appears in the (non-context portion) of the type of sync is as an argument to Get or Put
00:43:38 <jared-w> even more so that most of those overloadings are completely unrelated
00:43:47 <thimoteus> yeah :(
00:43:49 <c_wraith> orzo: and since those are non-injective type families, you can't infer what r was from the knowledge of what Put r and Get r are
00:43:57 <jared-w> It's one thing where in physics you can usually expect c to be related to light, v to be related to some concept of velocity, etc...
00:44:14 <c_wraith> orzo: how do you feel about adding another proxy to the type of sync? :)
00:44:17 <jared-w> But nah, omega means whatever the fuck it's supposed to mean in X paper and whoever wins the field's medal first gets their omega used more often :p
00:44:24 <thimoteus> haha
00:44:43 <JuanDaugherty> thought/knew ja vue that was the factual report vs community lore
00:45:24 <koz_> thimoteus beat me to it.
00:45:39 <koz_> Said construction was explained using transfinite induction.
00:45:48 <koz_> My brain had never felt so warped.
00:46:12 <jared-w> There's a transfinite induction? duuuuuude
00:46:38 <jared-w> oh nvm that's not quite as amazing as I thought it was. The omega^omega thing is still awesome
00:46:40 <c_wraith> orzo: http://lpaste.net/357542 works
00:46:42 <thimoteus> i remember when i took my first set theory class it took us a few weeks to get to some ungodly large ordinals, like omega_omega_omega..., and the professor told us that those aren't even large cardinals, because "they're small enough that you can prove their existence in ZFC"
00:47:05 <koz_> thimoteus: Yeah, it gets really mind-bending.
00:47:13 <thimoteus> so, large cardinals are cardinal numbers that are so big you need to assume they exist to work with them
00:47:25 <jared-w> lol I loved it when I learned that there are numbers that big
00:47:36 <jared-w> The busy beaver function blew me away with that
00:47:38 <Marisa> I dont know set theory much, but is large cardinal used in other branch of math? just curious
00:48:15 <thimoteus> i'm not sure since i don't know all that much out of set theory :P
00:48:18 <jared-w> Marisa: number theory, perhaps?
00:48:38 <c_wraith> Marisa: a friend of mine is working on a PhD in non-standard analysis.  He uses large cardinals a lot
00:48:40 <thimoteus> i think number theory deals mostly with the set of naturals
00:48:52 <jared-w> Set theory is really just the "underlying foundation" of math, so it's not so much that you /use/ these things in set theory but that you prove their existence so you have more shiny things to use in whatever branch of math you're actually working on
00:49:10 <jared-w> (at least, that's my understanding so far :p )
00:49:17 <koz_> jared-w: It's like assembly language.
00:49:27 <Marisa> Oh that's cool. (I dont even know such a branch exist)
00:49:30 <c_wraith> Well.  Was working on.  He's paused it while he takes care of family things.  I hope he can get back to it eventually.
00:49:32 <koz_> Theoretically it underlies everything, and knowing it doesn't hurt, but very few people specifically work in it.
00:49:52 <jared-w> koz_: painful, verbose as hell, and should've been replaced with lambda calculus? ;)
00:50:00 <thimoteus> depending on the category theory textbook you use, sometimes they talk about "small categories" which are just categories that have sets (of objects and arrows) small enough where everything can be interpreted in a ZFC model
00:50:19 <koz_> thimoteus: Then there are locally small categories.
00:50:29 <koz_> (I believe Set is one)
00:51:00 <jared-w> It's funny, because that just gives me the impression that ZFC is actually really tiny and yet "all of math" is somehow contained inside of it. It helps me remember that there are still entire worlds and universes in math yet to explore and discover :)
00:51:11 <thimoteus> koz_, good point, it is
00:51:36 <thimoteus> since any object a and b in Set will be a ... set, and the hom-set hom(a,b) is just the set of functions from a to b, which of course is also a set
00:52:00 <koz_> thimoteus: Yeah, it's kinda amazing, in particular because ZFC can't handle 'the set of all sets'.
00:52:10 <koz_> jared-w: It's not that 'all of math' is contained in ZFC.
00:52:19 <koz_> It's more accurate to say 'ZFC can build all of math'.
00:52:37 <thimoteus> there's a fairly small fragment of ZFC that's big enough to do "most of" math in, but i can't remember what it is off the top of my head
00:52:44 <c_wraith> Nah.  ZFC can't build anything in ZF(negate C)
00:52:54 <koz_> thimoteus: Have you looked at reverse mathematics at all?
00:53:03 <thimoteus> koz_, i only know about it
00:53:09 <jared-w> Reverse mathematics?
00:53:10 <jared-w> wat
00:53:21 <koz_> jared-w: Basically, trying to prove stuff with the minimal axiom system possible.
00:53:27 <c_wraith> Well.  It can't build anything that depends on (negate C)
00:53:29 <jared-w> ahh gotcha
00:53:50 <Marisa> I am interested in it, but I dont know any tutorial, do you have some pointer?
00:53:58 <koz_> Basically, if you wanna prove X, you first prove 'axioms -> X', but then (the reversal) 'X -> axioms'.
00:54:06 <thimoteus> it's like instead of starting from axioms and generating theorems by feeding people coffee, you start at theorems and try to get a minimal set of axioms that prove them
00:54:12 <jared-w> c_wraith: and there are things which we know are 'outside' of ZFC, like the continum hypothesis; a fact that I find fascinating :)
00:54:13 <c_wraith> And since choice is logically independent of ZF, either choice or not-choice is a valid addition
00:54:34 <jared-w> thimoteus: only by feeding people ffee, of course ;)
00:54:38 <thimoteus> haha
00:54:55 * jared-w starts petition to name 'reverse mathematics' comath
00:54:57 <MarcelineVQ> there's a joke about paychecks in there somewhere
00:55:00 <koz_> Well, coffee for most, meth if you're Erdos.
00:55:20 <jared-w> My favorite CT joke. "What do you call people who read category theory journals?"
00:55:29 <jared-w> coauthors (☞ﾟヮﾟ)☞
00:55:32 <koz_> ...
00:55:33 <thimoteus> lol
00:55:52 <jared-w> (2 jokes for the price of 1! 50% off on burn)
00:55:59 <opqdonut> :D
00:56:03 <koz_> jared-w: With a side of groan?
00:56:30 <jared-w> of course. It helps hide the tears
00:57:43 <koz_> I've tried reading some category theory, but I never get anywhere.
00:58:20 <MarcelineVQ> it's a lot of dots and arrows
00:58:26 <koz_> I should watch those videos Edward suggested.
00:58:34 <thimoteus> i'm slowly going through mac lane, but i've yet to apply it to any haskell stuff
00:59:29 <orzo> c_wraith: what if i added a function to the type class that would give me a proxy for r given proxies for p and g?
00:59:40 <orzo> would that work?
01:01:27 <c_wraith> orzo: it would require pretty big changes.  At which point I'd ask if you've considered going to an MPTC and using explicit fundeps to control inference
01:04:30 <orzo> well, i'm thinking how to do it without MPTC
01:07:37 <koz_> orzo: MPTC = MultiParameterTypeClasses?
01:09:08 * hackagebot DeepDarkFantasy 0.2017.8.9 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
01:10:42 <orzo> koz_: yes
01:11:23 <koz_> orzo (and anyone else): Is that a controversial extension? If so, why?
01:11:34 <lyxia> orzo: to p and g uniquely determine r?
01:12:19 <lyxia> I don't think it's controversial at all. You can easily emulate MPTC with a type class on tuples.
01:13:04 <lyxia> orzo: and if so, can you write a type family mapping (p, g) to the corresponding r
01:13:44 <Marisa> Will the noncontroversial extension (like MPTC) become on by default?
01:14:29 <koz_> Marisa: I think GHC defaults to by-the-standard Haskell2010?
01:14:46 <jared-w> koz_: they're referring to Haskell' I think (the 2020 report)
01:15:45 <jared-w> I'm personally hoping dependent haskell hits before we get Haskell'. I'm not sure how on board I am with a ton of add-hoc pragmas getting bolted onto haskell' when their entire purpose is to funky-do and half-ass dependent types
01:17:31 <koz_> jared-w: If you want Dependent Haskell today, there's always Idris.
01:17:47 <orzo> i'm using fundeps
01:17:53 <orzo> seems simplest
01:18:14 <jared-w> I like the idea of Idris, I like Haskell more for now
01:18:40 <orzo> are fundeps supposed to be obsolste?
01:18:44 <orzo> obsolete
01:18:58 <jle`> fundeps are still pretty cool
01:19:12 <jared-w> What I don't like about all the addon pragmas is they add a ton of complexity to the language, the compiler, and so on, but only do so to try and get a tiny bit of the power of dependent types without breaking things like type inference "too badly" (although GADTs and such still mess with it)
01:19:25 <dolio> koz_: First you construct the naturals, then you define integers as quotients of pairs of naturals.
01:19:30 <dolio> Typically.
01:19:42 <jared-w> it'd actually simplify the language quite a bit to just get rid of all of that and have a dependent type system that you could 'optionally tap into'
01:19:53 <jared-w> s/optionally/incrementially/
01:22:40 <koz_> dolio: Uhh, you mean 'rationals' there, right?
01:22:55 <koz_> Quotients of pairs of naturals do not integers make, as far as I can tell.
01:23:12 <jle`> quotient as in set quotient, presumably
01:24:00 <koz_> jle`: Sorry if I'm being dense, but what do you mean by 'set quotient'?
01:24:45 <jle`> you split a set into equivalence classes
01:25:03 <jle`> and create a quotient set
01:25:44 <thimoteus> i guess you could make a tagged union of N with N\{0}, one copy is the nonnegatives and the other is the negatives
01:26:03 <jle`> NxN under the equivalence class (a, b) ~ (c, d) iff a + d = b + c
01:26:13 <jle`> is Z
01:26:13 <koz_> jle`: Ah, I see.
01:26:35 <koz_> TIL a derivation I should have known a while ago I guess. :P
01:26:50 <jle`> call two pairs of natural numbers "the same" if the relationship above holds, and you have the integers
01:28:00 <jle`> (i guess you also need to define the typical operations)
01:36:50 <trigone> hi, can somebody give me an intuition of the choice of terminology for "fixed point" in "fixed point of a functor"?
01:39:08 <trigone> btw is it correct to say that (some) parsers are anamorphisms, and (some) printers are catamorphisms by essence?
01:39:56 <lyxia> trigone: Traditionally a fixed point is a solution of the equation f x = x
01:40:57 <lyxia> For Fix, make f a functor and take = to mean "isomorphic"
01:41:05 <lyxia> f (Fix f) is isomorphic to Fix f
01:42:39 <dolio> Oh geeze.
01:44:45 <trigone> hm ok... thx!
01:44:48 <bvad> trigone: have you read http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/ ?
01:45:03 <trigone> bvad: i'm in the middle of it actually :)
01:45:16 <bvad> I suspected as much :) 
01:45:49 <trigone> unrelated note, if module A exports all of module B, and module C imports module A, is there a way to hide all of module B specifically, and not the rest of module A?
01:46:00 <bvad> There's a part 3! I should probably read it again
01:46:35 <thimoteus> ugh so many things to read
01:46:51 <trigone> yeah it's pretty good. i don't have yet pragmatic usage intuition of all that but it sure seems useful
01:46:52 <bvad> thimoteus: It's exciting, isn't it? ;)
01:48:34 * hackagebot signal 0.1.0.4 – Multiplatform signal support for Haskell – https://hackage.haskell.org/package/signal
02:05:18 <ertes-w> elo
02:05:45 <bvad> elo 
02:07:17 <Iceland_jack> Morning #haskell
02:14:31 <Iceland_jack> https://arxiv.org/pdf/1708.02328.pdf <-- Deriving Law-Abiding Instances
02:14:55 <cocreature> Iceland_jack: that looks pretty neat
02:15:16 <Iceland_jack> yes something similar had been in my brain
02:15:24 <Iceland_jack> I was glad to see that paper, even though I haven't read through it yet
02:16:59 <Iceland_jack> I get tingly
02:17:15 <Iceland_jack> class Ord a => VerifiedOrd a where { refl :: Refl a; total :: Total a; ... }
02:18:56 <mibaz_1> Whoever is working on haskell-ide for atom is seriously killing it.
02:19:14 <thimoteus> oh?
02:19:31 <Iceland_jack> I haven't tried it, is it something I can recommend to new Haskell users
02:20:11 <mibaz_1> absolutely. I couldn't get into emacs and this is perfect
02:20:42 <bvad> mibaz_1: You're making me install an editor written in JavaScript to try it out.. 
02:21:09 <mibaz_1> the only problem is it's a little weird to get working unless you come upon this guide (the only one that worked for me): https://github.com/simonmichael/haskell-atom-setup
02:21:22 <Iceland_jack> good to know mibaz_1
02:21:41 <Iceland_jack> I know someone at work was using Atom but they switched to vi(?)
02:22:24 <mibaz_1> lol I once tried to make a single function in javascript. Took like 1.5 hours. Never will again. But here we have an entire editor so
02:22:46 <mibaz_1> Iceland_jack: I can't speak for professional use. I'm a newbie and this seems newbie friendly.
02:22:59 <Iceland_jack> Excellent
02:23:21 <mibaz_1> Oh, and the built in repl doesn't work with stack. Only complaint really
02:23:35 <mibaz_1> At least it didn't out of the box
02:24:10 <Iceland_jack> Thankfully you can get very far with Haskell without a fancy editor
02:24:52 <mibaz_1> Iceland_jack: I agree. I tried emacs, but realized I spent more time thinking than typing so the potential efficiency wasn't worth it.
02:24:58 <Iceland_jack> Yes :)
02:24:59 <Iceland_jack> With large software imports become a particular nuisance
02:25:07 <ertes-w> honestly i think you're missing out by using haskell without a good editor
02:25:12 <thimoteus> every few months i try to get into emacs, my latest foray was this weekend. it did not go very far
02:25:16 <Marisa> Hey, I got a DSL in final tagless style, however writing code in Lambda Calculus is painful (no syntax sugar, like pattern matching from Haskell). is there a way to use haskell syntax sugar to do DSL? (basically, is there a mature 'Compiling to Category' that is usable?)
02:25:39 <ertes-w> so i would suggest to get a good editor for haskell rather sooner than later
02:25:56 <ertes-w> be it emacs with haskell-mode, whatever vim users use or, if it's really that great, atom
02:26:44 <ertes-w> Marisa: is it an embedded DSL?
02:26:44 <thimoteus> i guess we know what ertes-w uses
02:26:56 <Marisa> yes
02:27:04 <Iceland_jack> I write Haskell on my phone and email it to myself
02:27:06 <Marisa> final tagless is a technique for EDS
02:27:08 <Marisa> EDSL*
02:27:11 <ertes-w> Marisa: then you can use haskell's abstraction capabilities on the meta level
02:27:18 <Marisa> HOAS?
02:27:29 <ertes-w> Marisa: let x = expr1; y = expr2 in App x y
02:27:31 <ertes-w> stuff like that
02:27:51 <ertes-w> Marisa: or am i misunderstanding something?
02:28:03 <Marisa> No, you get it perfectly fine, I am already doing that
02:28:10 <mibaz_1> ertes-w: does the Church of Emacs really give you pinky-healing powers?
02:28:42 <Marisa> But more specifically, I want to find a way to do haskell style pattern matching. Right now I can only have some 'pattern matching function'
02:28:50 <ertes-w> mibaz_1: we believe that, but most of the older emacs users know that it's just religion…  in reality you just get used to the twisted pinky
02:29:12 <mibaz_1> Iceland_jack, still waiting on that much needed google chrome ghc plugin
02:29:22 <mibaz_1> gmail*
02:29:52 <ertes-w> Marisa: pattern-matching is fairly easy to encode in lambda calculus by using scott encoding
02:30:12 <Marisa> Yes, that is what I do right now
02:30:18 <Marisa> I just want better syntax
02:31:18 * hackagebot ansi-wl-pprint 0.6.8.1 – The Wadler/Leijen Pretty Printer for colored ANSI terminal output – https://hackage.haskell.org/package/ansi-wl-pprint
02:31:18 * hackagebot error-util 0.0.1.2 – Set of utils and operators for error handling – https://hackage.haskell.org/package/error-util
02:31:31 <ertes-w> Marisa: i can't think of many ways other than, say, make the application operator infix
02:31:46 <ertes-w> myList ~$~ consCase ~$~ nilCase
02:32:04 <Iceland_jack> Marisa: I feel your pain—embedding patterns and case statements is a bother
02:32:12 <ertes-w> Marisa: you could of course get nicer syntax by just writing a custom parser and a quasi-quoter
02:32:13 <tabaqui> is there a way to create generic to/fromJSON instances much flexible than Data.Aeson.TH?
02:32:31 <ertes-w> Marisa: if you want to go that far
02:33:07 <tabaqui> I have to rename some fields in resulting string, and some fields have type Maybe a
02:33:17 <tabaqui> (Nothing if key is not present)
02:33:37 <Marisa> Ooh, is there a lighter way? I am not very good at TH (just learned it yesterday)
02:34:17 <Iceland_jack> Marisa: This is 'bound', not HOAS but it shows once way to embed patterns https://github.com/ekmett/bound/blob/master/examples/Overkill.hs
02:34:23 <Iceland_jack> it may be enlightening nonetheless
02:34:37 <Marisa> Iceland_jack, Thx, looking at it
02:34:38 <ertes-w> Marisa: QQ is fairly easy to get into without learning TH, but it does come with all the inconveniences of TH, including that you need a separate module
02:35:00 <Iceland_jack> *one way
02:35:09 <Iceland_jack> Best of luck :--)
02:36:01 <Marisa> ertes-w, thx, QuasiQuoter? Really wish compiling to category is ready to use :(
02:36:28 <Iceland_jack> Marisa: Conal is hiring to implement Compiling to Categories into GHC :)
02:36:34 <Iceland_jack> if you want to speed up the process
02:37:09 <Marisa> Yes I know, my pal just informed me this morning, but we are already working.. so sad
02:37:46 <ertes-w> Iceland_jack: are 'bound' and HOAS in competition?  i was under the impression that 'bound' is a form of HOAS
02:37:58 <Marisa> Maybe I should just take the lazy approach: work on other stuff and wait for it to be ready
02:38:16 <ertes-w> (because 'bound' is basically type-safe de-bruijn indices)
02:38:44 <cocreature> I’m not sure why it follows from the fact that bound is debruijn indices that it is a form of hoas
02:38:54 <Iceland_jack> HOAS uses the host language (Haskell) to do the substitution
02:39:04 <ertes-w> ah
02:40:31 <Iceland_jack> I'm so torn between HOAS and bound
02:40:48 <Iceland_jack> bound gives your expression Foldable and Traversable instances
02:41:09 <Iceland_jack> So we get the following gem
02:41:14 <Iceland_jack> closed :: Traversable f => f a -> Maybe (f b)
02:41:14 <Iceland_jack> closed = traverse (const Nothing)
02:42:34 <Marisa> what is the benefit of HOAS? only convienient syntax?
02:43:36 <cocreature> are there any compilers for somewhat mature languages/theorem provers that use hoas?
02:48:27 <bitonic> Iceland_jack: generally you should not use bound to write interpreters, because it's too slow. HOAS can be better in that regard, but still not that great
02:50:03 <Iceland_jack> I'm torn between them on more of an abstract level
02:52:11 <Iceland_jack> it represents some kind of split in the Haskell community, simple (despite it being nested) data types with all the regular (Type -> Type) instances vs GADTs and fancier types that are incompatible with all our nice tools
02:52:36 <Iceland_jack> being able to get free variables with toList etc
02:53:03 <Iceland_jack> and
02:53:03 <Iceland_jack> isClosed :: Foldable f => f a -> Bool
02:53:03 <Iceland_jack> isClosed = all (const False)
02:56:09 <Marisa> wait, I dont think you can get free var with HOAS
03:02:19 <ertes-w> would the EDSL of 'accelerate' be a form of HOAS?
03:03:36 <Athas> Doesn't Accelerate use de Bruijn indices internally?
03:04:20 <Athas> I think most big compilers don't use any of these fancy techniques.  GHC doesn't.  Not sure why.
03:04:51 <ertes-w> i don't know whether it does, but it would be reasonable…  the main point is that it uses the host language for binding
03:05:45 <Athas> Well... Accelerate cheats a bit, in that it uses StableNames to recover more information than the host language would normally provide, to recover sharing.
03:06:50 <ertes-w> i guess the choice between locally nameless and HOAS boils down to whether you need to do any fancy AST transforms…  HOAS seems to benefit *authoring* ASTs, while locally nameless benefits *transforming* ASTs
03:07:08 <cocreature> Iceland_jack: aren’t you conflating two orthogonal issues here, namely hoas vs debruijn indices and typed gadt asts vs normal adts? you can use a gadt with bound just fine and you can use hoas without a gadt
03:07:12 <ertes-w> Athas: i'm trying to understand what exactly HOAS is
03:07:49 <Athas> ertes-w: I think your assessment of the differences is spot on.
03:07:56 <Athas> Working beneath a binder in HOAS can be painful.
03:08:17 <ertes-w> ok, thanks
03:08:17 <Iceland_jack> cocreature: Yes but it shares enough of the difficulties
03:08:32 <Iceland_jack> such as incompatibility with glorious type classes
03:09:02 <ertes-w> so HOAS is basically "what accelerate does" (for its array processing language) or "what GPipe does" (for its shader language)
03:09:21 <ertes-w> (cheating aside)
03:09:36 <Athas> To me, HOAS is "what Twelf does", but that's probably not very useful to you.
03:09:43 <Iceland_jack> I tend to use some for of HOAS for the surface syntax
03:09:45 <Athas> I'm not sure I would call Accelerate's approach HOAS.
03:09:50 <Iceland_jack> but then immediately degrade to something else
03:09:52 <Athas> They boil it away as quickly as they can.
03:10:32 <cocreature> Athas: that reminds me, I still want to check out twelf
03:10:33 <Athas> HOAS is the only nice way I know to _construct_ ASTs in an EDSL in Haskell, but it is too painful to operate on.
03:10:36 <ertes-w> Athas: why?  it does seem to have the primary characteristics of HOAS: it builds an AST, and it uses the host language for binding
03:11:16 <Athas> ertes-w: one reason is that it's only really first-order, IIRC.
03:11:41 <Athas> Accelerate evaluates the HOAS-based AST with some dummy values to recover a non-HOAS structure.
03:11:58 <Athas> Er, it's second-order, of course.
03:13:13 <Marisa> HOAS could be compiled to type safe(I had only tried with final tagless, dont know about bound) DBI with some cheating, so one can write code in HOAS but transform code with DBI. I think that get something good from both world
03:13:23 <ertes-w> Athas: what exactly is the "order"?
03:14:14 <Athas> ertes-w: the nesting of arrows in the type of the parameters.  In Accelerate, I don't think you can write a function that takes an argument that is itself a higher-order function.
03:14:28 <ertes-w> as far as i understood the only distinguishing factor between first-order and higher-order is whether names are concrete/chosen vs. abstract/generated
03:15:29 <ertes-w> Athas: i think that's a different kind of order
03:15:35 <ertes-w> not the O in HOAS
03:16:35 * hackagebot aeson-diff 1.1.0.3 – Extract and apply patches to JSON documents. – https://hackage.haskell.org/package/aeson-diff
03:16:35 * hackagebot fgl 5.5.4.0 – Martin Erwig's Functional Graph Library – https://hackage.haskell.org/package/fgl
03:17:28 <jle`> nice that fgl is still being updated?
03:18:19 <jle`> one day i'll come across a problem that i feel fgl would be really awesome for
03:18:39 <jle`> i just know it
03:19:10 <lyxia> tabaqui: is fieldLabelModifier not sufficient?
03:19:54 <ertes-w> jle`: smallcheck was also updated recently…  i'm glad it's not dead…  perhaps some day i return to it =)
03:22:30 <ertes-w> but the most surprising update to me was GPipe after many years; this time the author is taking a much more realistic approach, while keeping the main appeal of the original GPipe: an embedded DSL for GPU shaders =)
03:23:50 <ertes-w> (it's already two years ago, but there was a period of silence of three years)
03:24:59 <jle`> always nice to say hi to an old friend
03:43:12 <kuribas> how hard would it be to write a dependend typechecker for python in haskell?
03:45:04 * hackagebot postgresql-simple-migration 0.1.11.0 – PostgreSQL Schema Migrations – https://hackage.haskell.org/package/postgresql-simple-migration
03:47:47 <phadej> kuribas: designing the type-system "research grade task", implementing it "a week?", annotating code "too long", trying to come up with inferncing algorithm "close to undecidable"
03:48:31 <cocreature> using haskell to implement the typechecker is definitely not the thing making this hard :)
03:48:44 <kuribas> phadej: I'd say not every valid python program would typecheck, only a subset.
03:49:06 <kuribas> But a subset that doesn't cripple the language to much.
03:49:53 <phadej> kuribas: I did that exercise for a subset of JS
03:49:55 <kuribas> Or perhaps not dependend types, just a decent static typesystem.
03:50:02 <phadej> yet I had to annotate everything
03:50:11 <phadej> and it took me "Masters Thesis" amount of work
03:50:22 <kuribas> right...
03:50:38 <cocreature> there are already some standardized type annotations for python iirc and even some checkers
03:50:45 <phadej> and it was semi-dependent, it had type-level lists with some functions on them
03:50:48 <ertes-w> kuribas: it may be quite difficult, because python has lots of ad-hoc language features and none of them reduce nicely to typed expressions
03:51:16 <kuribas> right...
03:51:30 <kuribas> perhaps using row types like in purescript?
03:51:49 <ertes-w> kuribas: for example you need to tell the difference between regular functions, generators and coroutines, each using the same syntax in slightly different ways
03:52:07 <kuribas> python has coroutines?
03:52:10 <ertes-w> yes
03:52:36 <ertes-w> they are used for a primitive form of concurrency, e.g. asyncio
03:52:50 <ertes-w> things got a bit better with python 3.5, but it's still a mess
03:52:54 <kuribas> couln't you infer a generator with yield?
03:52:55 <ertes-w> very hard to type
03:53:55 <ertes-w> kuribas: you can, and you can also unify generators and coroutines, which is, practically speaking, your only choice
03:54:20 <Philonous> What's the difference between a generator and a coroutine anyway?
03:54:38 <ertes-w> and you also have to pay attention to the many syntax forms that python allows for that
03:54:39 <cocreature> just infer “object” as the type of everything
03:54:43 <ertes-w> "async def", etc.
03:54:58 <ertes-w> Philonous: generators are pulled, coroutines are pushed to
03:55:52 <Philonous> Is there a form that allows both?
03:56:08 <ertes-w> yes, technically generators allow both
03:56:32 <ertes-w> in some 3.x version 'yield' became an expression that not only yields a value, but also receives a result
03:56:55 <Philonous> Wait, it's an expression, not a statement?
03:57:11 <Philonous> I should brush up on my python
03:57:14 <ertes-w> it is now…  with a super-awkward syntax, because it still wants to look like a statement =)
03:57:23 <kuribas> ertes: so a generator is simply a coroutine that doesn't accept anything from yield?
03:57:43 <ertes-w> the docs basically tell you to always write parentheses around (yield x)
03:57:44 <Philonous> kuribas, Isn't it the other way around?
03:58:06 <ertes-w> kuribas: you can consider them to be equivalent on the type level
03:58:27 <Philonous> I've always thought about generators/coroutines in terms of ContT. I'm not sure how good an approximation it is.
03:58:31 <ertes-w> kuribas: (i think)
03:58:53 <ertes-w> Philonous: just use free monads or your favourite streaming abstraction
03:59:14 <Philonous> On second thought, you can express any effect in ContT, so that statement is vacuous
03:59:39 <ertes-w> "you can express any effect in ContT"…  is that really true?
03:59:48 <Philonous> Any algebraic effect at least
03:59:58 <Philonous> There's a paper that demonstrates it
04:00:12 <kuribas> ertes-w: row polymorphism like in purescript looks useful for python as well.
04:00:18 <ertes-w> Philonous: still i'm not sure it's true
04:00:46 <Philonous> http://www.diku.dk/~andrzej/papers/RM-abstract.html
04:01:00 <ertes-w> newtype AgainT f m a = AgainT { runAgainT :: m (a, f (AgainT f m a)) }
04:01:12 <ertes-w> this monad has the same structure as CofreeT, but with monadic semantics
04:01:26 <ertes-w> whenever 'f' is a Plus (from the semigroupoids package)
04:01:33 <ertes-w> it's a monad that lets you set up reentry points
04:02:05 <ertes-w> so you can repeat the action from arbitrary spots, potentially communicating something into it
04:02:15 <ertes-w> i have used this for an experimental web framework
04:03:00 <ertes-w> although now that i think of it, you can probably just return continuations from the ContT action
04:04:01 * hackagebot servant-iCalendar 0.1.0.0 – Servant support for iCalendar – https://hackage.haskell.org/package/servant-iCalendar
04:14:16 <ertes-w> @let here = ContT $ \k -> k (fix (ContT . const . k))
04:14:18 <lambdabot>  Defined.
04:14:20 <ertes-w> :t here
04:14:22 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m (ContT r m a)
04:14:33 <ertes-w> indeed, you can use ContT even for this =)
04:14:37 <ertes-w> and it's probably even more convenient
04:18:44 <ertes-w> @let here' x0 = ContT $ \k -> let this x = ContT (\_ -> k (x, this)) in k (x0, this)
04:18:46 <lambdabot>  Defined.
04:19:37 <ertes-w> > flip runCont id $ do again <- here' 0; when (x < 10) (here' (x + 1)); pure x
04:19:39 <lambdabot>  error:
04:19:39 <lambdabot>      • Couldn't match type ‘(Expr, Expr -> ContT Expr Identity a0)’
04:19:39 <lambdabot>                       with ‘()’
04:19:49 <ertes-w> > flip runCont id $ do (x, again) <- here' 0; when (x < 10) (here' (x + 1)); pure x
04:19:51 <lambdabot>  error:
04:19:51 <lambdabot>      • Couldn't match type ‘(c, c -> ContT c Identity a0)’ with ‘()’
04:19:51 <lambdabot>        Expected type: ContT c Identity ()
04:20:01 <ertes-w> > flip runCont id $ do (x, again) <- here' 0; when (x < 10) (again (x + 1)); pure x
04:20:03 <lambdabot>  10
04:22:05 <ertes-w> this goto is non-local
04:23:00 <tabaqui> lyxia: about aeson, well, fieldLableModifier has no documentation :)
04:23:04 <tabaqui> I'll check the source
04:24:08 <kuribas> :t callCC
04:24:09 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
04:26:04 <kuribas> ertes-w: aren't generators more like pipes?
04:28:49 <ertes-w> @let here'' x0 = callCC $ \k -> let this x = k (x, this) in pure (x0, this)
04:28:51 <lambdabot>  Defined.
04:28:54 <ertes-w> :t here''
04:28:55 <lambdabot> MonadCont m => t -> m (t, t -> m b)
04:29:00 <ertes-w> better =)
04:29:08 <ertes-w> kuribas: pipes is more general
04:33:15 <kuribas> so a yield using ContT would return a ContT?
04:37:13 <ik`> :[]
04:37:58 <Iceland_jack> how pure
04:39:05 <kuribas> But to implement yield, you need to change state, so it would need StateT and ContT?
04:40:56 <kuribas> Maybe store the current continuation in the state...
04:48:26 <ertes-w> kuribas: you're probably stuck representing python's coroutines by effects
04:48:47 <ertes-w> kuribas: but i'm not sure what that would look like, because python doesn't have first-class actions the way haskell does (IO)
04:49:07 <ertes-w> you probably have to represent them as *side* effects
04:49:07 <kuribas> ertesI think it would be easiest to represent a generator simply as an object performing side-effects.
04:49:15 <kuribas> right :)
04:49:15 <ertes-w> yeah, exactly
04:49:37 <kuribas> So more an sml type system, where functions can have side effects.
04:49:59 <ertes-w> kuribas: just as a data point, i ended up not using mypy (a fairly comprehensive type system for python)
04:50:10 <kuribas> why?
04:50:36 <ertes-w> because i didn't see practical value in it…  the upfront cost would have been massive
04:50:42 <ongy> mypy is still fairly limited imo
04:50:42 <sphinxo> roughly how long till  a lts is released for 8.2.0
04:50:45 <sphinxo> ?
04:51:37 <kuribas> ertes-w: I'd want at least inference for the contents of functions.
04:51:41 <cocreature> sphinxo: I don’t think there is any deadline but I would expect something around 2 months but that’s really just guessing
04:51:42 <ertes-w> ongy: it is, but at least it would have allowed me to actually design my program the way i do in haskell, but then python's abstraction capabilities are laughable
04:51:53 <sphinxo> ah ok thanks cocreature 
04:52:05 <ongy> I've been using mypy for a project, and just stopped updating type signatures halfway through
04:52:09 <cocreature> sphinxo: there is a nightly snapshot for 8.2
04:52:15 <ertes-w> ongy: same experience
04:52:32 <ongy> because it got more confusing than usefull (then again, I had the equivalend of a [[(Int, Int, String)]] which is really ugly in mypy syntax
04:53:32 * hackagebot servant-iCalendar 0.1.0.1 – Servant support for iCalendar – https://hackage.haskell.org/package/servant-iCalendar
04:54:36 <ertes-w> ongy: the lack of ADTs also shows…  types are super-confusing, and there is no way to actually use the type system for anything other than reporting type errors
04:54:43 <ertes-w> no type classes, for example
04:55:18 <ertes-w> neither can you use it to type actions, because there is no way to type them
04:56:33 <lyxia> tabaqui: look at a pre-1.2 version
04:57:43 <lyxia> tabaqui: The Options constructor was hidden in aeson-1.2 and that messes with haddock.
04:58:53 <lyxia> but it still works in code
05:04:04 <sphinxo> say I have two (Map.Map Name Type) how can I most cleanly get (Map.Map Name (ExpectedAndFound Type Type))
05:06:09 <frerich> sphinxo: If you have a function 'f :: Type -> ExpectedAndFound Type Type' you could use 'mapWithKey'.
05:07:27 <frerich> sphinxo: Or 'map' of course, in case you don't need the 'Name' value.
05:08:38 <frerich> sphinxo: Oh, wait - you wrote you have _two_ maps and you want to merge them into a single 'Map.Map Name (ExpectedAndFound Type Type)' value?
05:08:43 <sphinxo> yeah
05:08:50 <sphinxo> where the value doesn't match for the same key
05:10:43 <frerich> sphinxo: Then maybe you'd find the 'union*' group of funtions (e.g. 'unionWith') interesting.
05:11:14 <sphinxo> ooh yes
05:11:16 <sphinxo> thanks
05:12:40 <bvad> Just explained monads to one of our marketing guys.. Apparently they're easier to understand if you don't already know programming!
05:12:56 <Rembane> bvad: How did you explain it? :)
05:13:05 <manek> bvad: I'm also interested
05:13:31 <bvad> Rembane: bind/return and the three laws, and then implemented them for Maybe
05:13:40 <bvad> On a whiteboard
05:13:50 <manek> bvad: omg and marketing guys understood it?
05:14:02 <manek> what kind of marketing guys do you have there? :D
05:14:02 <Rembane> bvad: Cool! I'll try that with the new students before they do any Haskell.
05:14:28 <kuribas> In fact, bind is just fmap with effects, right?
05:14:50 <kuribas> :t fmap
05:14:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:14:55 <kuribas> :t (>>=)
05:14:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:14:56 <ertes-w> manek: you don't get into marketing, unless you're a fairly smart person =)
05:15:29 <bvad> manek: He's very philosophical, but not a programmer
05:15:48 <manek> ertes-w: I wish everybody would think so. Unfortunately mot of marketing guys I met would not grasp the idea of monads so easy I think. I might be wrong though and hope I am!
05:16:15 <manek> bvad: oh! philosphicals are grasping haskell with easy as far as I seen here
05:16:27 <ertes-w> it depends on whether you're a logical/philosophical person or more of an intuitive person
05:16:49 <bvad> It's a quite interesting observation actually
05:16:53 <ertes-w> intuitive/analytical
05:17:37 <bvad> Another fun thing: I explained to him why scala.concurrent.Future isn't a monad, and his immediate reaction was: "Then why do you use it?" 
05:17:42 <bvad> I liked that.
05:21:58 <manek> hehe
05:22:10 <manek> bvad: by the way, why it is not a monad? (I dont know scala well)
05:23:18 <bvad> manek: basically because it starts running as soon as it is declared
05:24:48 <manek> bvad: interesting. Thanks for the info!
05:26:28 <bvad> manek: Don't get into Scala ;)
05:27:08 <manek> bvad: I will not. Nobody forces me to and will not. But I will learn it some day, just to know what is broken and why
05:29:21 <kuribas> at least it's better then java, isn't it?
05:32:30 <bvad> kuribas: I guess.. 
05:33:12 <bvad> I can't recommend either though 
05:35:21 <manek> Java is better han JavaScript but for me this is not an argument to use it :P
05:36:07 <kuribas> I'd rather write JavaScript.  At least it's not as verbose...
05:38:04 <manek> kuribas: Id rather write it too, for really small things, but hey, if you'll decide to create a big enterprise applciation, would you chose JS over Java if only these 2 could be considered?
05:38:31 <bvad> manek: I'd probably quite programming 
05:38:35 <bvad> quit even
05:38:39 <kuribas> haha, me too
05:38:52 <kuribas> at least that enterprise
05:39:11 <manek> bvad: hahaha :D
05:39:21 <manek> bvad: ok, that was beter response that I was expecting
05:40:47 * hackagebot feature-flipper 0.2.1.2 – A minimally obtrusive feature flag library – https://hackage.haskell.org/package/feature-flipper
05:45:59 <ertes-w> manek: java better than JS?  how?
05:46:47 <bvad> ertes-w: has a type-ish-system 
05:47:07 <ertes-w> java's type system is useless
05:47:16 <bvad> If you're allowed to use something like flow on top of JS, that would make JS preferable 
05:47:34 <ertes-w> i would prefer plain JS over java
05:48:03 <manek> ertes-w: at least you have any type safety
05:48:05 <cocreature> java’s type system is useless for ensuring the actual correctness of your code but ime it can help significantly to get a feeling for how things fit together and enforce some kind of structure in your project
05:48:06 <bvad> ertes-w: why? 
05:48:27 <manek> ertes-w: I hate Java so much I cannot express it, dont think IIm its advocate
05:48:29 <tdammers> java's type safety is so bad it's hardly worth having
05:48:44 * frerich I'd prefer JS over Java any day for not forcing me into OOP but rather continueing to use functional programming. And Java's type safety is rather weak actually.
05:48:52 <tdammers> and at the same time it introduces a fuckload of boilerplate and ceremony
05:49:06 <bvad> tdammers: I think that's the main reason some programmers strongly dislike types 
05:49:15 <bvad> Because they've only experienced Java-like type systemns
05:49:17 <tdammers> bvad: I know
05:49:29 <ertes-w> bvad: when was the last time you tried to do software engineering in java?  or let me ask differently: what as the notation for an anonymous function again?
05:50:09 * frerich ertes: You just start typing 'new Run' and then your Eclipse will see that you're supposed to pass a new Runnable, so it'll generate an anonymous interface iplementation right there on the spot.
05:50:37 <bvad> ertes-w: a -> whatever
05:50:48 <ertes-w> frerich: i see…  so you don't *write* java, you *click* it…
05:51:03 <bvad> ertes-w: also, preaching to choir
05:51:10 <tdammers> (new Runnable { public void run() { /* the actual useful code */ } }) // AAAAA
05:51:15 <cocreature> ertes-w: that’s almost graphical programming! :P
05:51:20 <ertes-w> hehe
05:51:24 <frerich> ertes-w: You use a code generator, yeah. Which helps coping with the boilerplate for writing, but not for reading, of course.
05:51:48 <bvad> I always do drag'n'drop UML diagrams and generate code from that. It's how all real-world code is written
05:51:51 <tdammers> let alone modifying
05:52:20 <ertes-w> frerich: readability is not the only problem…  the main problem is maintenance
05:52:30 <bvad> It's quite scary that Java is pretty much unwritable without an extremely complex IDE
05:52:31 <frerich> tdammers: You let your favorite refactoring tool do the modifying, too. Rename this variable, extract that method, fold these classes. :-]
05:52:42 <ertes-w> sorry, but i have so little respect for java that i'd probably even prefer PHP over it
05:52:55 <tdammers> how can you modify code you don't understand? how can you understand code you don't read?
05:53:08 <ab9rf> java is quite nearly as verbose as cobol, without any of the actual benefits of cobol
05:53:11 <tdammers> ertes-w: no, PHP is strictly worse
05:53:13 <frerich> tdammers: See, that's why I wrote "but not for reading, of course".
05:53:13 <bvad> ertes-w: have you seem Optional in java? They didn't want it to be a monad 
05:53:20 <frerich> tdammers: Everything else follows from that.
05:53:20 <ab9rf> tdammers: PHP isn't strict at anything :)
05:53:27 <tdammers> frerich: from unreadable follows unmaintainable
05:53:50 <frerich> tdammers: Right
05:53:51 <tdammers> bvad: reminds me of people who wanted pi to be exactly 3.1
05:53:59 <bvad> tdammers: Hah
05:54:11 <ab9rf> tdammers: you mean it's not?
05:54:14 <ertes-w> tdammers: really?  i can do my FP in PHP, more or less (the same kind of "more or less" as JS) and just ignore all the bullshit features like OOP, again, same as with JS
05:54:21 <bvad> Readability is a bad word. People think it means "Has C-like syntax"...
05:55:03 <tdammers> ertes-w: in java I can write verbose cumbersome abstractions. in php, I have to accept that certain abstractions are completely impractical and do without them
05:55:14 <ertes-w> tdammers: like what?
05:55:24 <bvad> tdammers: I'd rather use incomprehensible than unreadable
05:55:35 <ab9rf> what does "C-like syntax" even mean?
05:55:35 <tdammers> ertes-w: like for example abstracting a recursive-descent parser over arbitrary data sources and token types
05:55:51 <bvad> ab9rf: Nothing, it's arbitrary bs 
05:56:09 <_sras_> http://lpaste.net/2263206439369572352, In this snippet how is 'PhotoPoly' able to appear in place of a type, when its kind is * -> * -> * -> *-> * -> * ? This code compiles. But when I try similar thing from another app, I get an error that says 'Expected a type, but 'PhotoPoly' has kind '* -> * -> * -> *''  ?
05:56:12 <ertes-w> tdammers: but then at the same time java doesn't have the most basic kind of abstraction i can think of: functions
05:56:29 <bvad> ertes-w: But.. Methods! 
05:56:30 <tdammers> ertes-w: a function can be approximated using objects
05:56:36 <tdammers> ertes-w: like Runnable does
05:56:42 <ertes-w> tdammers: that's impractical
05:56:52 <ab9rf> oh, you want it to be PRACTICAL now
05:56:55 <bvad> ertes-w: Surely you mean "pragmatic"
05:57:37 <ertes-w> tdammers: also that abstraction is very well possible, just easy to get wrong, because PHP lacks a type system
05:57:46 <ertes-w> now don't get me wrong
05:57:54 <ertes-w> PHP is a terrible language, and nobody should use it
05:58:03 <ertes-w> my point is that java somehow manages to be *worse*
05:58:15 <ab9rf> i can't accept that
05:58:36 <manek> I've seen some time ago "gold citations" from irc pinned to haskell website
05:58:36 <ab9rf> java has some baked in stupid, but it's NOTHING like the baked in stupid in PHP
05:58:49 <manek> how can we pin ertes-w comparison of php to java? :D
05:59:49 * hackagebot feature-flipper-postgres 0.1.1.1 – A minimally obtrusive feature flag library – https://hackage.haskell.org/package/feature-flipper-postgres
06:12:06 <_sras_> How is this possible? http://lpaste.net/2263206439369572352 ? A type constructor is used in place of a type (PhotoPoly)..
06:12:35 * frerich hopes that the audience appreciates how a discussion of JS vs. Java vs. PHP and imperative vs. functional in a room with 1600+ members has been going on for about half an hour without any serious injuries or anyone invoking Godwin's law.
06:12:58 <frerich> If this isn't a testament to the superiority of the Haskell community, I don't know what is.
06:13:09 <frerich> :-)
06:13:36 <bvad> frerich: or maybe this is just an echo chamber ;) 
06:14:07 <kuribas> frerich: because nobody here likes Java or PHP?  Or they are afraid to admit it? :-)
06:14:38 <cocreature> _sras_: note that types and constructors live in different namespaces. so the type synonym lives in the type namespace together with PhotoPoly while the Photo constructor lives in the value namespace
06:15:38 * hackagebot fgl 5.6.0.0 – Martin Erwig's Functional Graph Library – https://hackage.haskell.org/package/fgl
06:20:43 <_sras_> cocreature: I am not getting you. My question is how it is able to use PhotoPoly as an argument to PK (line 9)?
06:21:30 <cocreature> _sras_: then I don’t understand your question. PhotoPoly is a type (not a constructor) and presumably PK is a type of kind * -> *, so similar to how you can do Maybe PhotoPoly, you can also do PK PhotoPoly
06:22:52 <_sras_> cocreature: But isn't the kind of PhotoPoly  * -> *-> * -> * -> * ?
06:22:57 <barrucadu> PhotoPoly is neither a type nor a constructor, it is a type constructor.
06:23:06 <barrucadu> _sras_: What's the definition of PK?
06:23:39 <_sras_> barrucadu: data PK a = PK Int64 
06:23:53 <barrucadu> Do you have PolyKinds turned on?
06:24:02 <_sras_> Yes
06:24:04 <cocreature> oh right I should read the source properly
06:24:11 <barrucadu> Then PK has kind (k -> *)
06:24:22 <barrucadu> And (* -> * -> * -> * -> *) unifies with 'k'
07:13:57 <dolio> ertes-w: Java has functions now.
07:14:02 <dolio> Got them just before vimscript.
07:22:22 <tabaqui> I have "data Foo a" and try to 'TH.lookupTypeValue "Foo Int"' but receive Nothing
07:22:49 <tabaqui> how can I lookup any parametrized types with templates?
07:22:59 <tabaqui> * ''(Data Int) doesn't work
07:23:42 <tabaqui> ** ''(Foo Int)
07:25:42 <lyxia> what information do you want to get from it
07:27:18 <tabaqui> Exception when trying to run compile-time code:
07:27:20 <tabaqui>       Maybe.fromJust: Nothing
07:27:23 <tabaqui> and cannot use it in ghci
07:28:18 <lyxia> template-haskell's lookup functions only understand simple name like ''Foo
07:28:36 <tabaqui> so I have to use type synonim?
07:28:45 <lyxia> If you need to work with a fully applied type like (Foo Int), you're out of luck.
07:29:17 <lyxia> You kind of have to reimplement that part of the compiler logic using the other pieces.
07:29:29 <tabaqui> haha
07:29:43 <tabaqui> hmm, newtype is not an option too
07:29:49 <tabaqui> sad, thanks anyway
07:31:52 <tabaqui> ehm
07:32:08 <tabaqui> instance Quazi Q where qLookupName = lookupname
07:32:25 <tabaqui> but lookupName is implemented using qLookupName
07:34:23 <lyxia> yes
07:35:18 <c_wraith> tabaqui: if it's in a different type, that's just fine
07:35:44 <tabaqui> where?
07:37:19 <tabaqui> I'm out
07:37:54 <lyxia> lookupName ns s = Q (qlookupName ns s)
07:38:15 <lyxia> The argument of Q does not have type Q
07:39:24 * hackagebot quantification 0.2 – Rage against the quantification – https://hackage.haskell.org/package/quantification
07:42:53 <trigone> hi, i'm a bit lost on how to reference other modules when there is a hierarchy of folders: everything (including local modules) is always referenced from the ground floor?
07:43:22 <lyxia> yes
07:43:26 <shapr> trigone: yes, although you can import a module qualified
07:43:34 <shapr> "import Data.Map qualified as M"
07:44:34 * hackagebot fitspec 0.4.2 – refining property sets for testing Haskell programs – https://hackage.haskell.org/package/fitspec
07:46:03 <trigone> ok thx. and, if i have several modules but want them to share the same namespace (virtually), can i add a new module, make it import all others, and then import *that* module in all other modules? cuz then it means all modules will import a module which imports said modules (do you follow me? ^^)
07:47:06 <tdammers> yes
07:47:20 <tdammers> you make a module that imports all the other modules and also re-exports them
07:47:39 <tdammers> module Foo where (module Bar, module Baz); import Bar; import Baz
07:48:02 <trigone> tdammers: ok, there won't be trouble with import loops? i'm just asking in case
07:48:17 <tdammers> if you make loops, then there will obviously be trouble
07:48:26 <tdammers> circular imports aren't supported
07:48:34 <tdammers> so Bar can't import Foo, for example
07:48:37 <trigone> tdammers: well, if i import Foo in Bar, don't you think it'll make a loop?
07:48:44 <tdammers> yes it will
07:48:47 <tdammers> so don't do that
07:49:04 <trigone> tdammers: that was more or less the point: to have all modules share the same namespace (without having to add each modules to all others)
07:49:08 <tdammers> oh wait, you want to make one big namespace where everything can access everything else, but split up into separate files
07:49:18 <tdammers> no, that doesn't work
07:49:21 <trigone> tdammers: yep. i wish it were simple to do...
07:49:44 <tdammers> you could use CPP to concatenate them all together, I guess, but ugh
07:49:49 <trigone> tdammers: is there a way to import a module, but hide a re-exported module from it?
07:50:06 <trigone> sth like import Foo hiding Bar
07:50:10 <tdammers> you can hide identifiers
07:50:17 <tdammers> but that doesn't get you around circular imports
07:50:42 <tdammers> if Foo imports Bar and Bar imports Foo, you have a circular import, even if the import lists are completely empty
07:51:05 <trigone> tdammers: ok... sigh thx
07:52:02 <trigone> i don't *really* get why import loops cause trouble. i thought in haskell basically there was no order in programs, so i don't see why importing cannot be smart enough to not try importing something it already has (or sth)
07:52:27 <trigone> but whatever :) there must be some reason...
07:53:36 * hackagebot hprotoc 2.4.3, protocol-buffers 2.4.3, protocol-buffers-descriptor 2.4.3
07:53:36 * hackagebot  → https://hackage.haskell.org/packages/recent
07:53:49 <trigone> tdammers: apparently mutually recursive mudules is still partially allowed, but there seems to be caveats https://wiki.haskell.org/Mutually_recursive_modules
07:54:36 <trigone> i'll handle it differently. thanks tdammers 
08:00:17 <trigone> hi again, if i import everything from a module with the implicit notation (module F where), will it also export *everything* that was imported in F?
08:00:28 <tdammers> no
08:00:41 <tdammers> to re-export things, you have to export explicitly
08:00:44 <trigone> you sure? i thought someone told me so recently
08:01:01 <trigone> ok then nevermind :)
08:01:06 <trigone> anyway explicit is better
08:01:21 <tdammers> explicit exports include everything defined locally, but not anything imported
08:01:29 <tdammers> sorry, s/explicit/implicit/
08:01:39 <Ojd> Hello, can someone please provide an example of "where defined globally". I am asking based on the following sentence: "where bindings aren't shared across function bodies of different patterns. If you want several patterns of one function to access some shared name, you have to define it globally"
08:02:01 <dramforever> just do not put it in a where
08:02:18 <dramforever> define multiple functions like you would normally
08:02:18 <Ojd> my alternative interpretation is that I need to define the name somewhere else instead of the where
08:02:45 <trigone> dramforever: what?
08:02:58 <trigone> oh nm i thought you answered me
08:03:30 <manek> Hi! Would anybody be so nice and tell me how can we use :~: (from Data.Type.Equality) ? 
08:03:56 <manek> I understand what it does (more or less), but I cannot see any use case for it (probably because I did not use it yet)
08:06:00 <Iceland_jack> manek: Well it is a proof that two types are equal
08:06:02 <ertes-w> manek: see the way it's used in Data.Typeable
08:06:20 <Iceland_jack> so one example is when you need to determine that, let's say you have an expression "Exp a"
08:06:29 <ertes-w> manek: given a proof that two types are equal you can coerce from one to the other
08:06:30 <Iceland_jack> you could have: testEquality :: Exp a -> Exp b -> Maybe (a :~: b)
08:07:00 <Ojd> dramforever thanks
08:07:06 <Iceland_jack> data Exp :: Type -> Type where { I :: Int -> Exp Int; T :: Exp Bool; F :: Exp Bool }
08:07:17 <Iceland_jack> so you can have: testEquality I{} I{} = Just Refl
08:07:32 <Iceland_jack> testEquality T{} T{} = Just Refl, etc.
08:07:36 <manek> ertes-w: Ok, I will see Data.Typeable. Answering your second mesage, I can write `test :: a ~ b => a -> b -> b` and then coerce between the types. I just look for difference between this and that
08:08:12 <ertes-w> manek: well, it's not really a coercion in that sense
08:08:17 <manek> Iceland_jack: interesting, I have to think about it now, brb, thank you!
08:08:47 <ertes-w> manek: it's more like you pattern-match on Refl, and as long as the Refl match is in scope the types are equal
08:08:58 <johnw> manek: ~ provides the equality, :~: lets you produce it
08:08:58 <ertes-w> so you don't need to *convert*, but they literally are just the same type
08:09:03 <johnw> if you have :~:, you can use: gcastWith :: (a :~: b) -> (a ~ b => r) -> r 
08:09:54 <manek> ah, so if I pattern match on `a :~: b` then GHC knows (in this pattern match branch) that types of `a` and `b` are the same ?
08:10:02 <guillaum2> Hi. I'm trying to rebuild `vector` using `-fllvm` inside a stack project. I tried to add `ghc-options: vector: -fllvm` inside my stack.yaml, but it does not rebuild anything. Any idea ?
08:10:04 <ertes-w> manek: exactly
08:10:07 <c_wraith> manek: yes, that's exactly what GADTs get you
08:10:08 <manek> so in fact it is like defining an overlappable typeclass ?
08:10:22 <ertes-w> manek: that's a nice example of GADT type refinement
08:10:41 <dramforever> sorta
08:10:55 <manek> thats so cool!
08:10:58 <dramforever> you get constraints by pattern matching
08:11:12 <manek> ok, but then, what we use :~~: for? We cannot pattern match on kinds other than * right ?
08:11:26 <manek> Why nobody told me about it before! This is usefull as hell!
08:11:30 <Iceland_jack> :~~: is a new addition
08:11:57 <dramforever> you gotta learn more about GADTs
08:12:09 <dramforever> Then it will appear as merely a special case
08:12:15 <ertes-w> manek: (:~~:) is basically what (:~:) should have been from the start =)
08:12:38 <manek> dramforever: I can use GADTs and I know how they infer types ,but didnt know we've got other mechanism that allow for something like that without using fancy overlappable typeclases
08:12:51 <ertes-w> manek: HRefl :: ∀ (a :: k). a :~~: a
08:12:58 <ertes-w> the only difference is that this one is kind-polymorphic
08:13:06 <c_wraith> ertes-w: does (:~:) predate the Polykinds extension?  I think it does.
08:13:17 <ertes-w> manek: so you can test for the equality of non-* types
08:13:20 <ertes-w> e.g. natural numbers
08:13:24 <dramforever> like jmeq from elsewhere?
08:13:26 <ertes-w> c_wraith: not sure
08:13:42 <Iceland_jack> ertes-w: Not just that, the arguments can have different kinds
08:13:45 <manek> ertes-w: I completely understand it, however, how can we use it? As I understand we can use `:~:` in patern matches, but we cannot patternmatch on polykinds right ?
08:13:51 <dramforever> or just equality on any kind
08:14:02 <c_wraith> Maybe :~~: Int
08:14:13 <ertes-w> manek: you match on constructors
08:14:15 <c_wraith> (I good luck finding a constructor that refines that type)
08:14:22 <Iceland_jack> data (a::k1) :~~: (b::k2) where
08:14:22 <Iceland_jack>   HRefl :: forall (a::k).  a :~~: a
08:14:22 <Iceland_jack> unsafeCo...
08:14:28 <ertes-w> manek: once you find HRefl, you know that there is really only one type of one kind
08:15:49 <manek> Iceland_jack: I'm trying to parse your GADTs example
08:16:23 <Iceland_jack> It's basically the testEquality function (https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Type-Equality.html#t:TestEquality)
08:17:02 <sproingie> what's the difference between :~: and :~~:
08:17:28 <c_wraith> sproingie: Not trying to be mean, but we kind of just covered that.  :P
08:17:37 <manek> c_wraith: I have to not understand something very very simple. I can write `case a of Just x :~~: b -> ...` and it will pattern match only if b :: Maybe <typeof x>. However how could I have not * kinds in pattern matches? 
08:17:42 <Iceland_jack> (:~~:) allows (Either :~~: Int) (they have different kinds)
08:17:47 <c_wraith> sproingie: (The difference being that :~~: is poly-kinded in each argument)
08:17:58 <manek> Iceland_jack: yes I see that, but then we do not use it in pattern match, right ?
08:18:38 <c_wraith> manek: the thing is, you can write the type (Maybe :~~: Int), but you can't ever construct it.  The HRefl constructor has the wrong type
08:18:41 <sproingie> c_wraith: yah sorry my fingers were faster than my brain.  still not getting the full implications i guess.
08:19:01 <manek> Iceland_jack: you told me to learn more about GADTs - I think I read already everything Ive found in the past, are there any fancy articles I should read now ?
08:19:15 <c_wraith> manek: this is like saying you can write the type (Int :~: String), but you can't ever construct it because Refl has the wrong type.
08:19:24 <Iceland_jack> oh I don't know :) hm let me think
08:19:47 <Iceland_jack> Look at Richard Eisenberg's (goldfire, goldfirere) thesis: http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
08:19:55 <nshepperd_> manek: the constructor is just Refl
08:20:08 <nshepperd_> The type variables are phantom, so they can be anything
08:20:17 <manek> c_wraith: Ok, I'm with you. And now, in such case we can use `:~~:` only on type level / constraints. You've told that it "proves GHC" that left and right have the same type WHILE pattern matching. So if we cannot use it in pattern match syntax, how it behaves on typelevel ?
08:20:32 <manek> Iceland_jack: thanks for the paper!!
08:20:48 <Iceland_jack> manek: It's very readable, and it covers the "future" of Haskell in detail
08:21:02 <nshepperd_> case equality_proof of Refl -> {- type equality is in scope here -}
08:21:05 <Iceland_jack> high-level overview of a lot of existing features and how they fit in
08:21:05 <manek> Iceland_jack: thats great, after reading the title Im already in love
08:21:58 <sproingie> skimming the first few pages ... gotta say i wish more papers were that accessible
08:22:18 <c_wraith> manek: you can write a lot of type signatures that you can't provide values for.  The important thing is that while you can write the type signature, GHC will prevent you from calling the function.
08:22:22 <Iceland_jack> Richard is great
08:22:30 <Iceland_jack> very good face for the community
08:22:37 <c_wraith> (or doing whatever else with a value with an inaccessible type)
08:23:09 <c_wraith> SPJ also writes some of the best papers.  We're lucky to have *two* authors with that skill doing hard work.
08:23:54 <Iceland_jack> Yeah
08:23:58 <manek> c_wraith: I understand it of course. I'm missing something very basic here, but I will get into it. Basically I just need to see use cases of this syntax and everything will be clear
08:24:24 <sproingie> so "Maybe :~~: Int" is isomorphic to Void?
08:24:26 <manek> c_wraith, Iceland_jack thank you so much for all the explanations
08:24:28 <c_wraith> sproingie: yes
08:24:36 <c_wraith> sproingie: in that it's a type with 0 constructors
08:25:12 <c_wraith> manek: it's kind of amusing to go through the source for Data.Equality and see how many functions are essentially just foo Refl Refl = Refl
08:25:39 <c_wraith> Err, Data.Type.Equality
08:25:40 <Iceland_jack> This paper is also excellent manek: http://www.cse.chalmers.se/~josefs/publications/deepshallow.pdf
08:25:49 <Iceland_jack> I don't know how many times I've looked at it
08:26:12 <manek> Iceland_jack: thank you so much!
08:26:17 <sproingie> i have a folder full of pdf's of papers i've yet to read
08:26:20 <manek> c_wraith: im doing it right now!
08:26:21 <Iceland_jack> there is a more recent version somewhere but this version is great
08:26:38 <sproingie> some of which i can't comprehend yet, but still tickle my interest
08:27:25 <Iceland_jack> sproingie: Tickling your interest is the most important part
08:27:47 <Iceland_jack> sometimes I will drop some connections just to get people interested
08:27:55 <c_wraith> sproingie: do you have the hyperfunction papers in there?  Those are fun. :)
08:27:55 <sproingie> meanwhile i have to finish up a project ... in php.  i think binge drinking might kill fewer brain cells.
08:28:04 <sproingie> c_wraith: not familiar with those, got a url?
08:28:14 <c_wraith> yeah, just a minute
08:28:18 <shapr> where does clash-lang fit into language embeddings?
08:28:31 <Iceland_jack> like how.. Free f Void ~ Fix f .....
08:28:37 <Iceland_jack> and Cofree f () ~ Fix f...
08:28:43 <Iceland_jack> spoookyy
08:29:00 <shapr> sometimes I get frustrated writing Python, but at least it's not PHP
08:29:34 <sproingie> yeah and this code is fairly crap even by php standards (CodeIgniter ... ugh)
08:30:01 <c_wraith> sproingie: https://arxiv.org/abs/1309.5135 is one paper, there was another one.
08:30:47 <shapr> sproingie: on the other hand, I see people digging ditches in blazing hot rainy weather here in Atlanta, and I realize I'd rather be writing even PHP in an air-conditioned building.
08:31:10 <c_wraith> sproingie: ah, http://www.csee.ogi.edu/~krstics/psfiles/hyperfunctions.pdf
08:31:26 <sproingie> shapr: true, no matter how much i hate the code, i could be working at walmart
08:32:15 <shapr> I never did understand that hyperfunctions paper.
08:32:22 <sproingie> it's more like the experience of a teacher having to grade sub-par papers from students who don't care about the work
08:32:42 <sproingie> where the work in this case is, well, php
08:32:54 <shapr> sproingie: yeah, I understand that. That's one reason I prefer doing free classes, only truly interested people attend.
08:33:00 <manek> ertes-w, Iceland_jack : ok, just one more question - I understand almost everything here (that :~: produces equality if we have HRefl in "pattern match scope") but I cannot see any use case of it. I've been looking to Data.Typeable, but it is used in one place that does not clarifies exactly how we can use it
08:33:16 <c_wraith> shapr: I mostly used it as a reference while working through the other hyperfunctions paper, where it provided nice background.
08:33:24 <manek> ertes-w, Iceland_jack : Is there any simple example showing anything it can be used for / in contrast to typeclasses?
08:33:32 <shapr> c_wraith: do you have a list of hyperfunctions papers?
08:33:52 <c_wraith> shapr: just those two.  (my arxiv link a few lines up is the other)
08:34:10 <shapr> Hm, I think I've seen more than two
08:34:17 <c_wraith> I'm sure there are more than two. :)
08:34:25 <sproingie> i'm not even sure how to interpret [A,B] in that paper.  product type?
08:34:48 <c_wraith> sproingie: no, something...  different.  Treat it as unique syntax for the idea they're about to describe.
08:35:22 <Iceland_jack> manek: take a look at http://augustss.blogspot.co.uk/2009/06/more-llvm-recently-someone-asked-me-on.html
08:35:37 <manek> Iceland_jack: thank you!
08:35:39 <Iceland_jack> And take a look at the Equal type
08:36:01 <Iceland_jack> Especially when typechecking if: typeCheckExp (UApp "if" [c,t,e]) = do
08:36:16 <ertes-w> manek: there are actually not that many use cases for it
08:36:42 <Iceland_jack> Both branches must have the same type
08:37:26 <ertes-w> manek: the very few use cases that aren't already covered by unification are usually obvious when you encounter them ("oh, and i need an equality proof here!")
08:37:32 <Iceland_jack> So Lennart type checks the boolean (c' ::: TTBol <- typeCheckExp c)
08:38:03 <Iceland_jack> And the THEN (t' ::: tt <- typeCheckExp t) and the ELSE (e' ::: te <- typeCheckExp e).... this is all happening in the Maybe Monad
08:38:08 <rikmen> http://fpga2.tk/
08:38:18 <Iceland_jack> then makes sure that they coincide (Eq <- test tt te)
08:38:50 <Iceland_jack> and returns that as the type of the whole expression: return (TIf c' t' e' ::: tt)
08:38:55 <Iceland_jack> note that (:::) is a constructor
08:39:21 <Iceland_jack> data ATExp where (:::) :: TExp a -> TTyp a -> ATExp
08:40:10 <manek> ertes-w, Iceland_jack thank you again, very very much!
08:44:21 <sproingie> honestly, i think i need an intro course on abstract algebras
08:46:12 <shapr> me too
08:46:30 <Rembane> +1
08:46:45 <sproingie> (algebrae?  algubru?)
08:47:20 <sproingie> that trailing u wouldn't fly i guess
08:49:04 <sphinxo> say I have data A = B Int | C and [A] how keep only items of B
08:49:21 <sphinxo> ( how can I filter to only keep B values )
08:49:40 <Iceland_jack> [ int | B int <- as ] works
08:50:22 <sphinxo> is that not going to fail when it comes across C?
08:50:29 <Iceland_jack> no, it just drops it
08:50:36 <Iceland_jack> let me see if I remember lambdabot's syntax
08:50:38 <sphinxo> And I don't want to extract int
08:50:51 <Iceland_jack> @let data A = B Int | C deriving Show
08:50:51 <sphinxo> actually
08:50:53 <lambdabot>  Defined.
08:51:15 <Iceland_jack> > [ b | b@B{} <- [B 10, B 20, C, B 5, C, C, C, B 4] ]
08:51:18 <lambdabot>  [B 10,B 20,B 5,B 4]
08:51:24 <Iceland_jack> > [ b | b@C <- [B 10, B 20, C, B 5, C, C, C, B 4] ]
08:51:27 <lambdabot>  [C,C,C,C]
08:55:07 <minn> I have a bunch of code written in this style (https://pastebin.com/s1Hm5aB2). Is there a better and/or more idiomatic way to express this?
08:56:24 <sproingie> hard to say since i don't know what's in those ... parts
08:56:30 <Iceland_jack> agreed
08:56:33 <sproingie> got actual code to share?
08:56:58 <sproingie> some of these uses look like they could be mappend.  the boolean cases being identical look like const
08:57:18 <sproingie> but pseudocode will get you pseudoanswers :)
09:05:22 <minn> The actual contents are pretty varied - but point taken I suppose. If it's not an obvious pattern I suppose it's just taken on a case-by-case basis :)
09:06:01 <ertes-w> minn: i use (>>= foldr _ _) very often
09:06:29 <ertes-w> or special cases like (>>= traverse_ _) when applicable
09:07:08 <ertes-w> similarly (>>= maybe _ _)
09:07:28 <ertes-w> Maybe is also a Foldable
09:07:39 <ertes-w> and Bool…  just avoid it =)
09:08:10 <byorgey> Bool is the worst
09:08:33 <manek> ertes-w, Iceland_jack : Ok, I went trought Data.Typeable and see how there we use :~: , first to create whitness if types are the same (eqTypeRep  checks fingerprints and produces a:~~:b) and the nwe use it in `eqT` so we can get Just/Nothing on values of the same / different types. However his could be done by just outputting Bool from the first function
09:09:02 <manek> ertes-w, Iceland_jack I feel I completely understand and feel now how it behaves, however I do not see any real-world example code I would need to use it - and thats my problem :(
09:09:36 <manek> ertes-w, Iceland_jack If I'm asking too much, I will not disturb you anymore. Thank you so much for all the help so far!
09:10:10 <Iceland_jack> You won't need (:~:) unless you need to witness that two types are the same
09:10:27 <Iceland_jack> in most normal code you don't have to do that
09:10:51 <ertes-w> manek: as i said, there aren't too many use cases for type equality in haskell
09:11:26 <ertes-w> now if haskell were dependently typed and could be used as a fast and loose logic language things would change
09:11:48 <ertes-w> but that might take a few more years =)
09:12:11 <Iceland_jack> I have already shown a few examples where you are dealing with an expression language and you need to show that two expressions have the same type.... and also inform the type checker of that
09:12:25 <manek> ertes-w, Iceland_jack : I know there are not many places, but are there at last some places? Is it useful in ANY code right now or it is really jsut playground for dependent types and it brings us nothing unless we got dep types here?
09:13:03 <ertes-w> manek: it can be useful…  see Iceland_jack's example, see Data.Typeable and probably some of the libraries that do some type-level work
09:13:14 <ertes-w> like singletons or HList
09:13:52 <manek> Iceland_jack: right, I need to deeply look at that example. I'm so sorry, I left in a tab and started looking for everrything else I've got open here and forgot to look deeply at it. I'm reading it right now. Thank you guys once again
09:13:54 <Iceland_jack> Search for "Refl" through this https://github.com/goldfirere/cs380/blob/2447ebc4c7e509e8fa02b7f90365cb3fef50b901/15_singletons/Proofs.md.lhs
09:14:46 <Iceland_jack> Also GLambda which is also by Richard: https://github.com/goldfirere/glambda/blob/32b301aa2939ed4b42eb57508587c38f9cda269a/src/Language/Glambda/Check.hs https://github.com/goldfirere/glambda/blob/32b301aa2939ed4b42eb57508587c38f9cda269a/src/Language/Glambda/Type.hs
09:15:11 <Iceland_jack> these are similar to Lennart's example where he goes from an untyped expression to a typed one (type checking)
09:16:03 <Iceland_jack> GLambda itself is a great use of GADTs, very well written
09:16:24 <Iceland_jack> Here is an associated talk by Richard https://www.youtube.com/watch?v=6snteFntvjM
09:17:05 <manek> Iceland_jack: thank you, thank you!
09:18:53 <minn> ertes-w: ah, (>>= maybe) and (>>= traverse) are actually pretty nice :)
09:18:55 <nshepperd_> manek: you could compare type reps and produce a Bool, but that doesn't help you convert type a to type b
09:19:41 <manek> nshepperd_: yes, that's clear :)
09:21:25 <anelson-> does anyone know if there's a way to do a `cabal build` interpreted? I'm just doing development/hacking so I don't need fast binaries or anything, and `cabal repl` is so much faster than `cabal build`...
09:21:59 <anelson-> (btw what I'm building is ghcjs, but the same would be nice for regular ghc)
09:23:34 <hololeap> i keep reading that arrows are less powerful than monads, but i don't get what that means... "powerful" how? is a functor more or less "powerful" than a monad?
09:24:08 <anelson-> hololeap: a monad is more powerful than a functor in the sense that every monad is a functor but not the other way around
09:24:19 <mnoonan> hololeap, "less powerful" usually means something like "implements a smaller interface"
09:24:50 <hololeap> mnoonan: or maybe "less powerful" just means more general?
09:24:56 <mnoonan> same thing!
09:25:05 <hololeap> ok, just clarifying
09:25:07 <ertes-w> manek: another example: say you have a Dynamic (from Data.Dynamic), and you want to convert it to Int…  one (needlessly complicated) option would be to pattern-match on the Dynamic, then use eqT to compare its type to the type of Int, pattern-match on the resulting (Maybe (a :~: Int)), and if you find (Just Refl), you can use the value as an Int
09:25:50 <nshepperd_> GHC.TypeLits has a function to compare type level natural numbers at runtime, which produces Maybe (a :~: b)
09:27:34 <ertes-w> anelson-: why don't you just use repl?  many editors support integrating it as well
09:27:51 <ertes-w> anelson-: for example there is haskell-mode for emacs, and for most other editors there is ghc-mod
09:28:11 <anelson-> ertes-w: so I'm working on a project that uses ghcjs
09:28:22 <manek> ertes-w: yes, I see this use case. I see and feel why it works. However I was looking for use cases that we cannot express other ways in Haskell currently (using type classes / type families). It seems for me right now that using this syntax we can get some things easier ut it doesnt bring us completely new possibilities 
09:28:35 <anelson-> so I need to have a JS artifact that I can load in my browser
09:28:49 <anelson-> but it takes a long time to build, which means iteration is slow
09:28:53 <ertes-w> anelson-: not sure about GHCJS…  are you working with reflex-dom?
09:29:11 <anelson-> Miso, but it doesn't really matter for this
09:29:42 <cocreature> anelson-: ghcjs 7.10 has ghcjsi
09:29:46 <ertes-w> anelson-: reason i'm asking is that reflex-dom has a bare-metal variant that uses a native webkit widget during development
09:29:59 <cocreature> anelson-: the miso readme explains how to use it
09:30:08 <ertes-w> anelson-: in any case you should get your interpreter integration running
09:30:42 <anelson-> I'm not sure I'm making myself clear... I can use the repl just fine
09:30:50 <anelson-> but I need to be able to see the code running in a browser
09:31:06 <anelson-> and I need to be able to serve it through my backend, which is also in haskell
09:31:11 <cocreature> anelson-: you can execute code in the repl and it will run it in the browser
09:31:17 <ertes-w> manek: there are only two ways to express it, and they are equivalent:  either type equality ((~) constraints), or reflexivity ((:~:))
09:31:27 <ertes-w> manek: all others are just abstractions of this
09:31:29 <cocreature> ah serving through your backend is difficult
09:31:36 <cocreature> not sure if that’s possible
09:31:56 <nshepperd> manek: you can't do this with a type class or type family
09:32:14 <anelson-> the frontend and backend are pretty tightly connected so it's really important
09:32:43 <anelson-> up to now I've just been working with js on the frontent, so iteration is as simple as "save the JS + reload the page"
09:33:15 <anelson-> I'm excited to try out miso though...
09:33:18 <manek> nshepperd: I have to read all the linked papers. If then I still do not see it, I would kindly ask you for any simple example that is doable using :~: and is not doable using type families/classes 
09:33:29 <cocreature> anelson-: have you tried disabling optimizations? that often already helps with build times
09:33:47 <nshepperd> i don't understand how you would do any of these examples with a type family
09:34:12 <cocreature> but if you really need to serve through your backend, you can’t avoid compiling instead of using the repl afaik
09:34:24 <nshepperd> only a GADT can bring runtime information to the type level
09:35:39 <trigone> @pl \f g x -> f . g x
09:35:39 <lambdabot> (.) . (.)
09:35:44 <anelson-> cocreature: disabling optimizations helps a bit, but we're still talking about 30+ seconds even on a pretty fast machine
09:35:52 <ertes-w> manek: i just gave you such an example
09:36:23 <trigone> (+4) . (*5) 4
09:36:27 <trigone> > (+4) . (*5) 4
09:36:29 <lambdabot>  error:
09:36:29 <lambdabot>      • No instance for (Typeable a0)
09:36:29 <lambdabot>          arising from a use of ‘show_M24637927460657183624485’
09:36:44 <trigone> :t (+4) . (*5) 4
09:36:46 <lambdabot> (Num (a -> c), Num c) => a -> c
09:36:48 <ertes-w> manek: the only ways to do type refinement is via GADTs and RankNTypes + (~)
09:36:57 <trigone> :t ((+4) . (*5)) 4
09:36:58 <lambdabot> Num c => c
09:37:07 <ertes-w> manek: and this is in essence a case of type refinement
09:37:37 <ertes-w> manek: data Blah :: * -> * where IntBlah :: Blah Int; StringBlah :: Blah String
09:37:39 <cocreature> anelson-: yeah build times definitely leave something to be desired with ghcjs
09:38:00 <manek> ertes-w, nshepperd: hmm, ok. I think I have to read the things and play with them to fully feel it
09:38:00 <ertes-w> manek: f :: Blah a -> a -> a; f IntBlah x = x + 5; f StringBlah xs = xs ++ "!"
09:38:05 <anelson-> cocreature: what were you talking about with running the repl in the browser?
09:38:23 <cocreature> anelson-: although 30s seems unreasonably slow. do you have a large application? how exactly are you building?
09:38:23 <anelson-> If I do `cabal repl` and then run `:main`, it complains about `document is not defined`
09:38:25 <manek> ertes-w: yes, I know it and I see how it brings values to typelevel here
09:38:28 <ertes-w> manek: see how the type variable 'a' in 'f' is fully polymorphic, yet the implementation manages to view x as an Int in one equation and as a String in the other
09:38:40 <anelson-> cocreature: just building with `cabal build`
09:38:48 <cocreature> anelson-: read the miso readme. you need to install socket.io and open your browser before you run :main
09:38:54 <manek> ertes-w: yes, I know this behavior
09:39:02 <cocreature> the repl will tell you the address that you need to open
09:39:13 <ertes-w> manek: (:~:) is just this
09:39:17 <ertes-w> nothing more
09:39:42 <cocreature> anelson-: and the cabal build output looks reasonable, i.e., it’s not building more than you would expect it to?
09:39:54 <ertes-w> manek: and you can express it in terms of (~), too
09:40:29 <anelson-> cocreature: yeah it's only building what I expect. But because it's compiling some server code there's probably a lot of code it doesn't need, type class instances etc
09:40:44 <ertes-w> newtype a :~: b = Eq { fromEq :: forall r. (a ~ b => r) -> r }
09:40:46 <anelson-> still, in the repl the build times are totally fine
09:42:07 <ertes-w> manek: if you have a value (Eq f) of this type, then starting out you know nothing about 'a' and 'b', but with (f k), k has an equality proof in scope, so it knows that a = b
09:42:07 <anelson-> cocreature: when I connect to `localhost:6400` I see a notification in my repl that the browser connected... but I don't see anything in the browser...?
09:42:28 <cocreature> anelson-: you’ll only see things once you start running them in the repl. my default it’s empty.
09:42:28 <manek> ertes-w: Thank you. I'm really thankful for all the help I get here from you now. I understand what you tell now and there is no problem in my head i undderstanding how it works and why it works so. I see the relation to GADTs now and the newtype / forall example.
09:42:33 <cocreature> anelson-: try running "main"
09:42:35 <manek> ertes-w: Yes, thats completely clear
09:42:49 <cocreature> not sure if :main works, I just use main as an expression
09:43:22 <anelson-> cocreature: running `main` and `:main` both produce just blank white page...
09:43:48 <manek> ertes-w: The only problem I've got is with use cases of it. But it will be solved after I sit down and test things out. If I learn something I like to understand is a deep as I can and I cannot tell that I understand :~: so good to see immidiately places in my typelevel code where I woudl liek to use it instead of gadts / ~ syntax
09:43:53 <anelson-> but if I go to `index.html` after a build, I see actual elements (I'm running the +/- example)
09:45:25 <NemesisD> hi all, i use a function from a package that has 2 arguments it prompts for and i'm sick of answering its second prompt. is there a way for me to rename it or wrap it in a way that i can take 1 argument and supply the second argument as fixed?
09:45:37 <anelson-> cocreature: ah it loaded up. OK, maybe it'll just work now. I'll hack on it a bit
09:45:40 <ertes-w> manek: the problem with use cases is that you rarely actually equate *types*, but you would like to equate values *on the type level*, which of course haskell does not support…  you would have to emulate it awkwardly using singletons
09:46:30 <manek> ertes-w: I see that. Im reading this now: https://typesandkinds.wordpress.com/2012/12/01/decidable-propositional-equality-in-haskell/
09:46:36 <anelson-> ok, if I reload the page it disappears. This is less than ideal :|
09:46:38 <NemesisD> whoops wrong channel
09:46:45 <manek> ertes-w: and it seems that goldfire is doing exactly wat you've just described
09:47:37 <anelson-> also running `:r` hangs my repl
09:48:15 <manek> ertes-w: I cannot express how thankful am I for your time today
09:48:16 <ertes-w> manek: in a hypothetical future version of haskell you might have this:  inverseMod15 :: n :~: 17 -> (x :: Mod n) -> Not (x :~: 0) -> Mod n `SuchThat` (\y -> x * y :~: 1)
09:48:22 <manek> ertes-w: thank you once again!
09:48:35 <ertes-w> err
09:48:58 <ertes-w> manek: inverseMod17 :: n :~: 17 -> (x :: Mod n) -> Not (mod x 17 :~: 0) -> Mod n `SuchThat` (\y -> mod (x * y) 17 :~: 1)
09:49:01 <ertes-w> rather like that
09:49:13 <ertes-w> which might use some optimised algorithm to compute the inverse modulo 17
09:50:02 <ertes-w> something like this is actually possible with singletons, but it's super-awkward to do in haskell
09:50:06 <manek> ertes-w: I see it, very interesting
09:50:37 <manek> ertes-w: another paper I'm going to read today is about singletons from goldfire
09:50:38 <ertes-w> (SuchThat is also known as Exists or Sigma)
09:51:02 <manek> ertes-w: I'm feeling today like learning haskell once again years ago, so cool! :D
09:51:20 <ertes-w> manek: if you want to use this today, check out idris =)
09:51:36 <ertes-w> it's not fun to do in haskell
09:52:06 <cocreature> anelson-: with cabal new-build, I get rebuild times of 0.05s if nothing has changed and 3.9s if I change the simple example in miso. so I really suspect that you are building too much if your build times are over 30s
09:52:08 <manek> ertes-w: I will learn idris, definitely. I need some time to do it. I've got daily job and hard time to bring product to market, but in every free moment I will do it, its super interesting
09:52:29 <ertes-w> manek: i wrote this a few years ago, which you might find interesting: http://lpaste.net/109388
09:53:15 <cocreature> anelson-: are you using "cabal build" on the miso repo itself? that will relink all executables even if you only changed the simple one
09:53:19 <cocreature> which is why it’s so freaking slow
09:53:44 <anelson-> no, only in my project directory
09:54:09 <anelson-> it is pretty fast if the only thing that changed was the top-level module (also that module is tiny)
09:54:34 <cocreature> so so the 30s are not on the +- example
09:54:37 <cocreature> *oh so
09:54:41 <manek> ertes-w: thanks, I just fast look at it now and yes, thats definitively very interesting!
09:54:42 <anelson-> yes
09:54:56 <cocreature> *shrug* in that case I’m not sure what else to try sry
09:56:24 <anelson-> I mean, if the story is that build times are prohibitively long with anything resembling a complex module structure (and really my backend code that I'm sharing is probably under a thousand lines)... that's going to make iteration difficult
09:57:27 <anelson-> but, maybe I can trim things down
09:57:32 <anelson-> we shall see
09:59:56 <ertes-w> fun fact: i wrote: "So singletons work for now, but the long term solution is to get language-level support for dependent types.  This is unlikely to happen for Haskell, because it would change the language to such an extent that we couldn't really call it Haskell anymore."
10:00:07 <ertes-w> it has become a lot less unlikely recently =)
10:00:28 <drdo> Moving towards Agda one strange step at a time
10:01:44 <ertes-w> i wrote that code when TypeInType wasn't a thing…  today much of it could probably be simplified
10:19:57 <butterthebuddha> How does Haskell determine equality for integers?
10:21:28 <Ojd> I am wondering if there is any "Style guidelines" available for Haskell
10:22:28 * hackagebot recursion-schemes-ext 0.1.0.1 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
10:22:44 <cocreature> Ojd: the most popular one is probably https://github.com/tibbe/haskell-style-guide but even that is not rigorously followed by most people
10:23:46 <ertes-w> butterthebuddha: most likely using GMP, which does a limb-by-limb comparison, where a "limb" is GMP terminology for machine-sized integer
10:23:54 <geekosaur> butterthebuddha, do you mean Integer specifically, or integral types?
10:24:45 <Ojd> thanks cocreature, reading the .md
10:28:15 <Ojd> second, I start "translating" some of my python functions into Haskell, for experimenting purposes.  I have never used Haskell before, so I am wondering if you could please comment the following two:
10:28:34 <Ojd> https://thepasteb.in/p/Elh153mGM6Ncm
10:32:23 <joe9> need some advise with profiling, please?  https://gist.github.com/92a5c6e6c162fa5e334894886fe03b11  is the .prof file. I understand that parseDateTimeSuffix is the bottleneck. http://bpaste.net/show/8dff8f815cb7 is the function. any suggestions, please?
10:33:29 <Yuuri> What's the library of choice for parsing command line arguments?
10:34:23 <sproingie> Ojd: i suggest abstracting all those (a, String) into a newtype
10:34:49 <sproingie> or an abstract type of some sort, doesn't have to be newtype
10:35:32 <sproingie> might also want to look into a units library if you're using this code for practical purposes
10:35:38 <joe9> should I be using some kind of scanner instead of attoparsec?
10:36:04 <joe9> Yuuri: Options.Applicative
10:36:09 <cheater> hi
10:36:23 <ertes-w> Yuuri: optparse-applicative is ok…  not great, but ok =)
10:36:29 <joe9> Yuuri: optparse-applicative
10:36:32 <cheater> can i use criterion to check space usage of various implementations of an algorithm?
10:37:31 <Ojd> sproingie I don't know how to create new types  (yet) but I will include a comment to make the change in the future
10:38:31 * hackagebot composition-prelude 0.1.0.1 – Higher-order function combinators – https://hackage.haskell.org/package/composition-prelude
10:39:07 <Ojd> also, I don't know how to import libraries (yet) but that would be the second note ;)
10:39:21 <Yuuri> ertes-w: joe9: thanks!
10:39:46 <ertes-w> Yuuri: for simple applications the base library provides System.Console.GetOpt, which is often good enough
10:40:09 <cocreature> joe9: what makes you think that parseDateTimeSuffix is the bottleneck? parseDDFFormat seems to take up significantly more time according to your profile
10:40:16 <sproingie> Ojd: importing libraries is pretty simple, the "import" statement suffices.  getting and building and linking with such libs is a little more involved (i like stack for that)
10:40:33 <ertes-w> Yuuri: optparse-applicative starts making sense when you need commands with individual suboptions or other complicated logics
10:42:18 <LeanderK> hey, i have an AST modeled as lots of sum-types. Can i use lenses to process the AST? How do they handle the "partiality" of sum types and how can i handle every case?
10:42:25 <Yuuri> ertes-w: I once looked at base GetOpt, and got confused with "done in two different ways"
10:42:41 <joe9> cocreature: Thanks for checking up on this. parseDDFFormat is a choice function to parse different types of messages: http://bpaste.net/show/72a39149eee9
10:42:55 <Ojd> sproingie thanks. Any other comment about the pattern matching or the guards?
10:43:00 <joe9> cocreature: I presume that one of those choices is the cause of the bottleneck.
10:43:36 <cheater> what is the best way to profile heap/space usage of a program?
10:44:08 <ertes-w> Yuuri: the result of the parser can either be a list of option descriptors that you interpret (first example), or a list of functions that transform a starting "default" configuration (second example)
10:44:16 <cocreature> joe9: btw I highly recommend to use ghc-prof-flamegraph (https://github.com/fpco/ghc-prof-flamegraph) to look at those profiles, e.g., for your profile it gives you https://github.com/fpco/ghc-prof-flamegraph
10:44:24 <cocreature> ahrg, the second link should be https://purelyfunctional.org/downloads/joe9.svg
10:44:42 <ertes-w> Yuuri: i would more likely use the latter variant, but the former is easier to understand, especially if you're new to FP, so perhaps start with that
10:44:51 <joe9> cheater: stack build --profile, in the .cabal file: -O2, and then run the command:  stack exec your-exe -- +RTS -N -h -p -sstderr -RTS
10:44:52 <cocreature> cheater: ghc has heap profiling built in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-heap-prof
10:45:12 <cheater> sure but that just shows one run, i would like a statistical analysis like criterion does
10:45:17 <Yuuri> I'd like a kind of aeson approach, with structure for options and a possibility to parse it in a generic way or via some combinators
10:45:49 <cheater> does anything beyond using pure ghc exist?
10:45:51 <joe9> cocreature: that is cool. Thanks. did not know about it.
10:45:58 <ertes-w> Yuuri: there is optparse-generic, but it's kinda awkward to work with, because you need wrappers around your fields, if you want stuff like help strings
10:46:40 <ertes-w> Yuuri: and of course there is still the cmdargs library, which uses black magic, but is frighteningly easy to use
10:47:35 <cocreature> cheater: is your program non-deterministic? because if it isn’t memory usage should be mostly deterministic, so something like criterion doesn’t make a lot of sense
10:47:54 <sproingie> Ojd: the pattern matching and guards are probably fine, they're just surface syntax.  it's the logic around units that's the big concern, since you really want to be doing that with types at compile time, not runtime.
10:48:12 <joe9> cocreature: it says that fmap.\.succ' is taking a lot of time.
10:48:36 <cheater> cocreature: OK
10:48:51 <ertes-w> Yuuri: it uses the kind of black magic that messes with the laws of physics…  if you use it wrongly, your CPU might collapse into a black hole
10:49:19 <cocreature> joe9: yeah not sure what’s going on there. ghc sometimes attributes costs to things that you wouldn’t expect.
10:49:21 <joe9> cocreature:  this is the Price_2_8.parseDDFFormat http://bpaste.net/show/d9dc01b45e4f
10:49:37 <sproingie> Ojd: i'm also not a huge fan of "error", since it results in partial functions, but you can pretty easily convert that to MonadError later
10:49:49 <gremdrus> what are "->" and "<-" called in haskell so I can google them?
10:50:02 <sproingie> they're called -> and <-
10:50:26 <joe9> is there any way to drill down to what might be causing the issue in the Price_2_8.parseDDFFormat? cocreature
10:50:28 <Yuuri> ertes-w: like which one?
10:51:01 <Yuuri> unsafeParseArguments?
10:51:08 <sproingie> symbolhound can search all the things including funky punctuation syntax.  not quite the coverage of google of course.
10:51:44 <cocreature> joe9: compiling without optimizations can sometimes help. it will obviously screw with the results but the stacks will usually have more information so it can be useful.
10:52:01 <ertes-w> Yuuri: if you use the .Implicit variant (which is what you would typically do), you write a default value with "annotations"
10:52:22 <joe9> cocreature: cool. good idea. Thanks. without -O2, correct?
10:52:26 <ertes-w> Yuuri: those annotations work like identity functions, but add some extra information to the value that may vanish, if you're not careful
10:52:50 <ertes-w> Yuuri: in particular it can only be used once…  if you parse the command line twice with the same template, you will get an incorrect result the second time
10:53:23 <ertes-w> Yuuri: if you use .Explicit, cmdargs is safe, but then it's barely any different from optparse-applicative
10:53:27 <cocreature> joe9: yeah, try -O0
10:55:04 <ertes-w> Yuuri: optparse-generic does something similar, but without the unsafety of "identity-like functions"…  instead it makes you use explicit newtype wrappers with type-level information, which you need to unwrap after parsing
10:55:26 <joe9> cocreature: Thanks.
10:55:54 <Ojd> sproingie I guess I am using the very limited knowledge I have right now. My objective is to start with something decent and start improving as I learn more things
10:57:41 <Yuuri> ertes-w: too much libraries! >_<
10:58:32 <ertes-w> Yuuri: start with base/getOpt…  if you really don't like it or need something it can't do, switch to optparse-applicative
10:58:43 <ertes-w> if you find it too verbose, try optparse-generic
10:59:16 <ertes-w> and if that isn't satisfying either, try cmdargs…  or check out the other libraries that are on hackage…  there are actually many more libraries for this purpose
11:00:20 <sproingie> Ojd: you're off to a good start by writing real-world code.  long as you don't stop learning, you're on the right track :)
11:01:56 <sproingie> (whereas my learning is being slowed by not writing real-world code)
11:06:29 * hackagebot th-abstraction 0.2.5.0 – Nicer interface for reified information about data types – https://hackage.haskell.org/package/th-abstraction
11:20:18 <erisco> we should compile a list of problems that gradually introduce concepts in Haskell
11:20:32 <erisco> not a book, not a tutorial, just a list of problems
11:25:25 <kadoban> Then we should add some text around it explaining the concepts in case people aren't getting them. And then we should call it a tutorial. And if it gets big enough we should bind it together into some kind of book ;)
11:25:49 <lambdaGrp> like a 'you could have invented haskell'
11:26:13 <erisco> those resources exist. I just see frequently enough people looking for something to program in Haskell
11:26:27 <Tuplanolla> End the list with some open problems and hope nobody notices, erisco.
11:27:09 <Ojd> Well, other than my personal project I am using this : https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
11:27:36 <erisco> neat, looks like someone already had and executed the idea
11:28:11 <Tuplanolla> Are the problems meant to be so small?
11:30:04 <Ojd> and this: https://github.com/noelmarkham/learn-you-a-haskell-exercises
11:30:08 <geekosaur> that's actually a translation of an existing 99 problems thing, so it isn't really haskell specific
11:30:09 <ertes-w> i'm amazed how many people come here to learn haskell and have no problems at all =)
11:30:34 <ertes-w> do you only learn haskell when you have already solved everything in other languages?
11:30:52 <Ojd> I like the idea of gradual increment... like a coding game.
11:31:19 <Ojd> first parsing list for personages
11:31:39 <Ojd> strings and tuples
11:31:41 <Ojd> or lists
11:31:59 <Ojd> then using those small pieces to have more interesting things
11:32:02 <ertes-w> i'm not a huge fan of H-99…  it takes a lot of time to work through it, and at the and you still can't program in haskell
11:32:16 <ertes-w> same problem, though to a lesser degree, as project euler
11:32:40 <ertes-w> s/the and/the end/
11:33:29 <ertes-w> if i were to make such a list of problems i would call it "dirty haskell (or how i learned to stop worrying and love the IO)"
11:33:47 <Tuplanolla> That's because only half of the Project Euler problems are programming problems.
11:34:01 <Yuuri> A Dirty Introduction to Haskell
11:34:30 <kadoban> hackerrank is how I learned to love the IO/ST. Though it makes me wish there were more concise syntax for mutable array access and modification sometimes.
11:34:56 <ertes-w> kadoban: just define it
11:35:23 <kadoban> Like come up with my own? Not sure how :-/
11:35:43 <ertes-w> let (.=) = Vm.write myArray; infix .= 1
11:35:51 <ertes-w> i .= x
11:36:08 <kadoban> Yeah, that's probably worth doing. I'm just not sure the right operators and etc.
11:36:43 <ertes-w> kadoban: just pick the same name 'lens' uses, unless you need to work with 'lens', in which case just prefix yours by something =)
11:36:53 <ertes-w> *names
11:37:38 <kadoban> Yeah, I need to learn lens a lot better. At one point I hoped that lens's stuff would just directly be usable, but it doesn't seem like the types fit at all so it can't be. So I gotta learn so I can figure out what to copy, and what operators to avoid.
11:37:56 <ertes-w> 'lens' doesn't handle mutation
11:38:01 <kadoban> Right :(
11:38:10 <ertes-w> you can use it for pure state though, and it's quite comfortable
11:39:10 * hackagebot gnss-converters 0.3.9 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
11:39:10 * hackagebot serokell-util 0.3.1 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
11:39:16 <ertes-w> > execState (do zoom _1 (modify (+ 5)); zoom _2 (do _1 += 10; _2 += 20)) (0, (0, 0))
11:39:19 <lambdabot>  (5,(10,20))
11:39:41 <ertes-w> 'zoom' is one of my favourite features of lenses and traversals =)
11:39:55 <kadoban> Stuff is so cool, I really need to just buckle down and learn/start trying to use it.
11:40:33 <ertes-w> > execState (zoom traverse (do _1 += 1; _2 -= 1)) [10, 20 ..]
11:40:35 <lambdabot>  error:
11:40:35 <lambdabot>      • Ambiguous type variable ‘s0’ arising from a use of ‘show_M673028140515...
11:40:35 <lambdabot>        prevents the constraint ‘(Show s0)’ from being solved.
11:40:36 <ertes-w> err
11:40:38 <kadoban> One problem I guess is I don't think many of the competitive programming places allow lens itself, but whatever. hackerrank does at least.
11:40:56 <ertes-w> > execState (zoom traverse (do _1 += 1; _2 -= 1)) (zip [10, 20 ..] [10, 20 ..])
11:41:02 <lambdabot>  mueval-core: Time limit exceeded
11:41:12 <Ojd> this approach is also interesting (IMHO): https://www.bloc.io/ruby-warrior#/
11:41:14 <ertes-w> hmm?  is that strict state?
11:41:21 <Ojd> (sorry for the horrible music)
11:41:29 <Tuplanolla> @index execState
11:41:29 <lambdabot> Control.Monad.Trans.State.Strict, Control.Monad.Trans.State.Lazy, Control.Monad.Trans.State
11:41:48 <Tuplanolla> Not useful.
11:41:57 <ertes-w> > Control.Monad.State.Lazy.execState (zoom traverse (do _1 += 1; _2 -= 1)) (zip [10, 20 ..] [10, 20 ..])
11:41:57 <joe9> cocreature: Thanks for the suggestion about flamegraph and -O0. It makes the job so much easier.
11:41:59 <lambdabot>  error:
11:41:59 <lambdabot>      Not in scope: ‘Control.Monad.State.Lazy.execState’
11:41:59 <lambdabot>      Perhaps you meant one of these:
11:42:12 <ertes-w> @let import qualified Control.Monad.State.Lazy
11:42:14 <lambdabot>  Defined.
11:42:16 <ertes-w> > Control.Monad.State.Lazy.execState (zoom traverse (do _1 += 1; _2 -= 1)) (zip [10, 20 ..] [10, 20 ..])
11:42:23 <lambdabot>  mueval-core: Time limit exceeded
11:42:28 <ertes-w> huh?  why does that fail?
11:42:50 <ertes-w> > Control.Monad.State.Lazy.execState (do traverse . _1 += 1; traverse . _2 -= 1) (zip [10, 20 ..] [10, 20 ..])
11:42:52 <lambdabot>  [(11,9),(21,19),(31,29),(41,39),(51,49),(61,59),(71,69),(81,79),(91,89),(101...
11:42:59 <jle`> sometimes lambdabot fails randomly
11:43:02 <jle`> might be a disk i/o thing
11:43:04 <ertes-w> weird…  does 'zoom' somehow degenerate to strict state?
11:43:37 <kadoban> That seems odd
11:43:37 <ertes-w> jle`: i'm pretty sure this is not lambdabot's fault
11:43:52 <jle`> ah sorry, i jumped in without any context
11:43:58 <ertes-w> > Control.Monad.State.Lazy.execState (zoom traverse (_1 += 1)) (zip [10, 20 ..] [10, 20 ..])
11:44:05 <lambdabot>  mueval-core: Time limit exceeded
11:44:18 <ertes-w> seems like 'zoom' is too strict
11:46:20 <jackhill> pwd
11:46:24 <jle`> #haskell
11:46:29 <jackhill> ☺
11:47:38 <ertes-w> @let lazyZoom l (StateT c) = StateT (\s' -> do ~(x, s) <- c (view l s'); pure (x, (l .= s) s'))
11:47:40 <lambdabot>  .L.hs:181:23: error:
11:47:40 <lambdabot>      • Couldn't match type ‘Identity b’ with ‘Const b b’
11:47:40 <lambdabot>        Expected type: ASetter () () b b
11:47:47 <ertes-w> @let lazyZoom l (StateT c) = StateT (\s' -> do ~(x, s) <- c (view l s'); pure (x, (l .~ s) s'))
11:47:49 <lambdabot>  .L.hs:181:23: error:
11:47:49 <lambdabot>      • Couldn't match type ‘Const b s’ with ‘Identity s’
11:47:49 <lambdabot>        Expected type: ASetter s s b b
11:48:33 <ertes-w> err, wait…  that would only work for lenses
11:48:47 <ertes-w> i think i see what the problem is
11:51:25 <ertes-w> indeed, there is a bug in Control.Lens.Internal.Zoom
11:51:49 <ertes-w> it uses strict pattern-matches against the tuples
11:52:09 <ertes-w> time for my first contribution to lens =)
11:52:54 <Tuplanolla> Does this ruin it for strict state though?
11:52:58 <kadoban> ertes-w: Nice
11:54:16 <ertes-w> Tuplanolla: nope
11:54:58 <ertes-w> and it's only really relevant if you use traversals
11:55:09 <ertes-w> proper non-lens traversals that is
12:06:57 <Chobbes> Is System.Random the "best" interface for randoms in Haskell these days, or is there something else I should use? Seems like MonadRandom is a thing?
12:08:29 <shapr> oh hai Chobbes! How's code? You writing something interesting?
12:08:42 <kadoban> Chobbes: I've heard some use mwc-random, but I think that's more about speed than anything. I haven't looked into it yet.
12:09:27 * hackagebot gnss-converters 0.3.10 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
12:10:40 <Chobbes> shapr: yep! Writing a random number generator following a specific distribution for something. Kind of wondering if I should use System.Random, or something else... Not sure if I can define split for what I'm doing :|.
12:12:30 <jle`> i use mwc-random nowadays
12:12:53 <jle`> the MonadRandom package is basically a convenience wrapper over System.Random
12:13:31 <jle`> mwc-random is good for speed and it also integrates well with the statistics package, so i can generate random variables of different statistical distributions
12:13:38 <geekosaur> System.Random is fairly low quality. (note that better PRNGs also have MonadRandom interfaces)
12:15:40 <jle`> yes, System.Random is the absolute lowest standard of random numbers
12:16:29 <jle`> don't use it for anything that needs to be cryptographically secure
12:16:59 <geekosaur> it's simple, it's portable, it doesn't require external libraries. 'good, fast, cheap, pick two' --- or for cryptographically secure, usually pick one
12:17:59 <jle`> it's pretty good for pedagogy
12:18:24 <jackhill> geekosaur: does cryptographically secure not imply good or is that your point?
12:19:28 <geekosaur> mostly I was implyying that any cryptographically secure PRNG worth its salt is neither fast nor (programmer-)cheap (i.e. needs external deps, and don't try to design your own!)
12:20:02 <jle`> a+ pun
12:20:27 <eschnett> i can write “a ~ b” as a constraint when declaring a type signature. is there also a way to declare a stand-alone constraint, with kind “Constraint”? how?
12:20:46 <rblaze>  "/dev/urandom" is pretty easy to use
12:20:55 <geekosaur> ConstraintKinds extension, then use 'type'
12:20:58 <eschnett> e.g. “type IsInt a = a ~ Int” or so?
12:21:09 <jle`> eschnett: what happens when you try ?
12:21:31 <jle`> oh, sorry, misread
12:21:42 <eschnett> i had a type class with a parameter; maybe a “forall” is missing
12:21:50 <eschnett> “type IntervalPointConstraint p = p ~ IntervalPoint a”
12:22:07 <jle`> yes that doesn't make sense because there is no 'a' in scope
12:22:13 <geekosaur> yes, either that a needs to be a parameter or it needs a forall (and won't unify across multiple uses)
12:22:14 <jle`> it depends on what you really want to do
12:22:26 <jle`> did you want a synonym for (p ~ IntervalPoint a) => ... ?
12:22:32 <eschnett> yes
12:22:38 <jle`> then write type IntPoCon p a = p ~ IntervalPpoint a
12:22:38 <joe9> flamegraph gives me this error, though the .prof file seems ok. http://bpaste.net/show/7410e186cfd9
12:22:44 <eschnett> thanks!
12:22:44 <jle`> so you can do (IntPoCon p a) => ....
12:23:14 * jle` . o ( p `IntOpCon` a) => ...
13:01:17 <thomas_> Howdy folks
13:01:54 <koz_> thomas_: Hihi!
13:05:38 <joe9> geekosaur: I am using attoparsec for parsing binary data and it is being very slow. profiling is not being very helpful. Just want to check if there are other options that I can explore.
13:31:54 <NickHu> Hi all, I'm encountering this error when trying to compile like ghc -O2 Kmeans/GenSamples.hs -main-is Kmeans.GenSamples.main --make -prof -auto-all http://lpaste.net/357548
13:32:02 <raynold> ahh it's a wonderful day
13:32:25 <NickHu> I can't see at all what the problem might be
13:36:18 <tdammers> hmm, this is weird... I'm getting all sorts of linker errors trying to install cabal with cabal
13:39:41 <mibaz_1> hIsClosed blocks for a socket with no available information. Is there a way to check if a socket handle is closed without blocking? Trying to send data.
13:41:44 <tdammers> nm, figured it out... super old ghc and cabal in /usr/local/bin
13:44:07 <geekosaur> mibaz_1, (1) not in general, (2) a 'shutdown' may leave a socket closed for write but still open for read, so this won't help you anyway (that is, hIsClosed can only tell you if the socket is *fully* closed)
13:44:25 <gremdrus> why is it that > parenthesizeWords s = unwords $ map (\s -> "(" ++ s ++ ")") (words s) < works in ghci, but for intero I get the error:
13:44:26 <gremdrus> <interactive>:5:21: error:     parse error on input ‘=’     Perhaps you need a 'let' in a 'do' block?     e.g. 'let x = 5' instead of 'x = 5'
13:45:29 <cocreature> gremdrus: sounds like your build of intero might be using an older version of ghci
13:45:36 <cocreature> gremdrus: iirc that only exists since ghc 8.0
13:45:41 <mibaz_1> geekosaur: Ah, I see. How would you recommend going forward with 'if the socket's not closed, send some data'?
13:45:57 <gremdrus> cocreature: Intero 0.1.20 (GHC 8.0.2)
13:46:31 <geekosaur> mibaz_1, I'd just do the send/write with an exception handler. In general checking first leaves you with a race condition if the remote closes it after you checked but before you send
13:46:58 <geekosaur> so you'd need to catch a possible exception anyway
13:47:57 <mibaz_1> geekosaur: haha I have known that race condition all too well in the last half hour. I'll try and make this less pure
13:49:53 <Tuplanolla> Instead of turtles, networking is actually a horrible tangled spaghetti all the way down.
13:50:37 <geekosaur> always program as if anything that can possibly go wrong will go wrong
13:52:23 <Tuplanolla> Must every call to `accept` be followed by a 14-way `errno` branch?
13:52:31 <mibaz_1> Tuplanolla: That it is. Except turtles(?)
13:52:59 <geekosaur> https://en.wikipedia.org/wiki/Turtles_all_the_way_down
13:54:26 <geekosaur> Tuplanolla, only if you need to react differently to each of them. most of the time, it'd be go/no-go
13:54:42 <mibaz_1> Ah, turtles. Perfect.
13:54:42 <geekosaur> especially if errno can vary based on platform >.>
13:55:14 <Tuplanolla> Just 7-way, okay.
13:55:16 <mibaz_1> While on the exception subject, is there some kind of linter that will check that you have most (all?) possible exceptions covered?
13:55:36 <mibaz_1> Since I think we know what exceptions can be thrown by certain IO functions and whatnot
13:55:48 <geekosaur> "assume it will fail on you", not "assume every possible failure mode must be specifically handled". because the latter will be horribly platform dependent and you end up with the same problem again (errors all the way down...)
13:56:03 <joe9> mibaz_1: check out the safe exceptions package.
13:56:03 <Tuplanolla> The runtime system can throw you a handful of exceptions at any time, mibaz_1.
13:56:13 <joe9> mibaz_1: safe-exceptions
13:56:45 <geekosaur> (there's a reason all the I/O exceptions are the IOException type and extracting the errno is difficult. it *does* vary by platform and you should not rely on it)
13:56:56 <mibaz_1> Tuplanolla: Ah, right.
13:57:01 <mibaz_1> I'll look at safe-exceptions
13:57:12 <geekosaur> worse, it can vary on the same platform if the error was raised on a network filesystem
13:58:30 <mibaz_1> geekosaur: All the way down.
14:02:55 <NickHu> Okay I figured out my problem was from using -fplugin GHC.TypeLits.Normalise in conjunction with -prof
14:09:20 <nykros> Is there a function like unlines, but does not adds a '\n'?
14:09:41 <nykros> (concat .intersperse "\n") can do the trick, but maybe there is something better
14:10:00 <anelson-> nykros: intercalate
14:10:23 <koala_man> nykros: you want a \n separated lines instead of the normal \n terminated lines?
14:10:27 <anelson-> intercalate " " ["hello", "world"] == "hello world"
14:11:49 <nykros> thanks!
14:12:24 <anelson-> I think if you're doing it for strings you'll need to import Data.List. For text though I think it's just part of Data.Text
14:21:14 <jle`> nykros: if you actually want unlines with the '\n', that's just concat
14:21:41 <jle`> oh ah didn't read your last message
14:32:27 <NaN> is this the hard-to-troll haskell channel?
14:32:30 <NaN> :B
14:32:39 <johnw> indeed
14:33:04 <johnw> it doesn't mean we don't reserve the option to kickban people fairly readily, though :)
14:33:10 <NaN> lol
14:33:24 <NaN> I just read a gist with a troll history
14:33:31 <gremdrus> am I supposed to use haskell-mode with intero?
14:35:57 <jared-w> NaN: that's a good one :)
14:36:17 <jared-w> gremdrus: I think so. You can also just manually enable intero and it'll work just fine
14:36:19 <boj> NaN: are you interested in haskell?
14:36:26 <boj> because this is the place to be
14:37:53 <NaN> boj: more on FP but I was thinking on Lisp, Clojure or Scheme (in that order); why should I give Haskell a try?
14:38:21 <boj> NaN: if you are interested in strong typing it's worth looking into
14:38:31 <Tuplanolla> Our theory is more interesting and refactoring is less painful, NaN.
14:39:35 <NaN> I don't have a really good math background and I heard haskell is for maths friends
14:39:54 <boj> a common disconception. i have an art degree :o
14:40:01 <boj> mis*
14:40:13 <Tuplanolla> We're not SciPy, NaN.
14:40:37 <NaN> boj: do you use haskell for "art"? I mean, like C++ with OF
14:41:32 <boj> NaN: i run a development group at a telecom, we use it for everything
14:42:13 <anelson-> boj: what company? I didn't realize there were any telecom companies using haskell
14:42:40 <jared-w> NaN: Lisp is really good for learning how to think in a 'macro'-like way. You learn to build up everything out of very small parts and make your own meta-language inside of lisp quite quickly. It can be used to learn FP but that's not really its strength (imo)
14:42:49 <boj> anelson-: MTA out of Alaska. it's obviously not common :)
14:43:17 <anelson-> hah wow. haskell in alaska. Alaskell?
14:43:48 <NaN> jared-w: good opinion, thanks. What about scheme or clojure?
14:45:20 <anelson-> NaN: you mean as opposed to Common Lisp? Because scheme and clojure both are varieties of Lisp, with macros etc
14:46:26 <NaN> anelson-: so they are basically the same?
14:46:51 <boj> basically
14:47:21 <danilo2> Hi guys! Will the symbol `*` be removed in future of Haskell? Should I use `Type` instead of `*` in new code?
14:47:47 <anelson-> they are different as far as their implementations, their communities, their performance etc, but they have a lot in common with each other as far as syntax, usage of macros, the type of thinking involved
14:47:54 <danilo2> I found few sources talking about it, some state that `*` will be removed (like: https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1) 
14:48:45 <jared-w> Clojure has a much stronger data-structures library. You can use a million different data structures very cleanly. Scheme is a more 'pure' lisp that stays truer to the heart of what lisp is about (in my /very personal/ opinion :p). Lisp (common lisp, rather) has a lot of stuff bolted into its library.
14:49:02 <danilo2> but it is described as "eventual plan" (... "is to deprecate and remove * as a parsing oddity") which basically means it could not happen at all. So I'm just wondering if there is a trend right now not to use `*` at all 
14:49:11 <jared-w> But raelly, all of that kinda stuff is trivial in difference vs comparing any of those to a different language
14:49:31 <boj> danilo2: probably not worth worrying about until a new compiler breaks your code
14:49:57 <jared-w> danilo2: I do believe that * is going to be completely removed around the same time that we bolt on dependent types into Haskell. But yeah, I'd echo what boj said. Also, since Type is a drop in swap for *, it'll be painless to migrate to that should you need to later :)
14:51:01 <anelson-> with dependent typing how are things like undefined or universes going to work?
14:51:13 <Tuplanolla> Here's a vague analogy, NaN: Scheme is Common Lisp meets Forth and Clojure is Common Lisp meets Java.
14:52:02 <jared-w> lol that's hilariously accurate. Nice!
14:52:25 <danilo2> boj, jared-w : thanks, interesting. I think I will start dropping `*` and use `Type` instead in more places, it would just allow me to accustom to it. I'm still not convinced if dropping `*` is a good decision. It is a special case, but it makes the code so readable
14:52:27 <NewToFP> Hi smart people - quick question about notation: for (λx. f (x x)), does the f(x x) mean it takes x as input twice?
14:53:18 <jared-w> danilo2: * is a weird choice because 'Type' is what is used in the literature and in most other languages with dependent types. It's a bit like :: vs : in Haskell and how everyone else does it the other way. I'm glad Haskell is going to (hopefully) switch to Type vs * before things too set in stone
14:53:22 <boj> NewToFP: yes
14:54:11 <danilo2> jared-w: interesting
14:54:12 <jared-w> NewToFP: imagine this: (λx. x+x)  what would this do?
14:55:12 * hackagebot weeder 0.1.7 – Detect dead code – https://hackage.haskell.org/package/weeder
14:56:26 <NaN> wow thanks guys
14:57:20 <jared-w> @where learnhaskell
14:57:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:57:32 <jared-w> If you're ever interested in learning Haskell, this is a great place to start :)
14:58:53 <sqooq> I messed up bad
14:58:58 <sqooq> like REAL bad
14:59:05 <sqooq> ok maybe not that bad idk
14:59:08 <jared-w> sqooq: what did you do? :p
14:59:41 <sqooq> I did everything for my project and made it to the last step, then it hit me that I completely forget this entire time to implement something very important
15:01:05 <sqooq> my music notation using brackets can have blank spots. "[ 1-4 4-4 7-7 [ 3-4 _ 0-4 ] ]"
15:02:05 * hackagebot shakers 0.0.31 – Shake helpers. – https://hackage.haskell.org/package/shakers
15:03:49 <sqooq> I could wrap all my trees with Maybe, but some of the core functions would need some major reworking. Actually it's irrelevant how I implement the Blank spot, those functions would need to be majorly reworked because by forgetting to implement this, the way they will work changes quite a lot.
15:04:05 <sqooq> I'm thinking to use this to try to do more at parse time but last time I was advised against it
15:05:55 <codygman_> I read that profiling code that mostly uses a library with it's own fusion framework (such as vector) makes profiling useless. If you aren't getting adequate performance from such a library, what can you do?
15:09:16 <dmwit> Wait, what? `\x. f (x x)` doesn't mean "`f` takes argument `x` twice".
15:15:01 <trigone> hi, i'd like to know if, akin to being able to create heterogeneous lists (using constraints over constructors), we could create a Free monad heterogeneous on the internal functors? after all the Free monad does not really care of whatever's in it, from the moment it's a functor...
15:17:58 * hackagebot preamble 0.0.49 – Yet another prelude. – https://hackage.haskell.org/package/preamble
15:20:38 <koz_> trigone: Yeah, it should be possible. To be honest, you don't even need Functor technically.
15:20:47 <koz_> (because of the profitable cheat known as the left Kan extension)
15:22:03 <trigone> koz_: yeah i know but the free monad needs it itself (it's not privy on whether we created a functor thru cheating or not)
15:22:27 <koz_> trigone: You can construct the Free monad using the left Kan extension internally.
15:22:32 <koz_> Oleg's Freer monad does exactly this.
15:22:36 <trigone> (needs it as in, it needs a functor either way)
15:22:47 <koz_> (shouldn't it be 'Freeer'?)
15:23:02 <hpc> so who's going to write the Freest monad?
15:23:08 <trigone> koz_: no, two E are good enough :P
15:23:15 <koz_> hpc: The Murrica monad. :P
15:23:30 <trigone> what's murrica?
15:23:47 <koz_> trigone: It's a term to refer to the worse side of American exceptionalism.
15:24:29 <trigone> koz_: the freer technique isn't supposed to create a functor out of sth non originally functorial (just a random type cons) then feed it to Free?
15:24:40 <trigone> what's american exceptionalism?
15:24:57 <hpc> ask in -offtopic
15:25:03 <koz_> trigone: If you double-check the Freer monad as defined by Oleg, you'll see that he just embeds the left Kan extension into the structure, which makes the Functor constraint unnecessary.
15:25:16 <koz_> Let me just link you to the relevant section.
15:25:44 <koz_> trigone: http://okmij.org/ftp/Computation/free-monad.html#freer
15:26:00 <koz_> Look at the second block of code in that section, starting with 'data FFree g a'
15:26:53 <koz_> Then check out the third block (i.e. the one just after it), where Oleg defines the Big Three Type Classes on it.
15:27:10 <trigone> hm you're right, it's not Free much
15:27:35 <koz_> It's basically just incorporating one bit of cheating into another.
15:27:36 <trigone> i mean Freer is not concretely built on top of Free
15:27:45 <johnw> koz_: although, "Freer" being a free monad relies on there being no way to encode strong existentials in System F
15:27:53 <koz_> Compare their definitions - they are very similar.
15:28:17 <koz_> johnw: Yeah, that's fair enough.
15:28:26 <trigone> koz_: i'm wondering the cost on efficiency of all that though... that's a lot of plumbing, it feels
15:28:42 <koz_> But it's the same thing Edward was saying about how profunctor-based lens definitions are actually crippled groupoid-based definitions because we can't really talk about groupoids in Haskell properly.
15:28:48 <koz_> trigone: You'd be correct.
15:28:54 <koz_> This is what Edward was talking about before.
15:29:06 <koz_> Essentially, this 'naive' approach can be accidentally quadratic in some cases.
15:29:20 <koz_> Other takes on it avoid that problem, but introduce others.
15:29:28 <koz_> (c.f reflection without remorse, for example)
15:30:08 <trigone> so... is there a good compromise around all potential problems and advantages?
15:30:13 <koz_> trigone: Several.
15:30:19 <koz_> Edward mentioned them all.
15:30:22 <koz_> They all have tradeoffs.
15:30:35 <koz_> And you just have to pick the one that fits your particular use case.
15:30:40 <trigone> koz_: i'll keep reading then :)
15:30:51 <koz_> trigone: Oleg describes one in the paper on extensible effects I linked.
15:30:56 <koz_> Edward describes basically all the others.
15:31:06 <trigone> koz_: yes, it's on my to read list :)
15:31:09 <koz_> (you can ask him about them, because I don't even pretend to understand much of their detail)
15:32:41 <trigone> the problem perhaps with all these things is, there's not much on the snippet side. usually, for one paper on one technique, there's one, perhaps two examples. it's hardly always easy to adapt them to all potential cases... in short there's a lack (it feels, i may be wrong) of hands-on tutorials on all those program structuring techniques...
15:32:58 <koz_> trigone: Welcome to 'academics writing about algorithms/data structures'.
15:33:10 <koz_> The Haskell-using academic community is actually much better on this front than most.
15:33:18 <koz_> c.f. my earlier stuff about Vigna's rank-select array.
15:33:35 <koz_> The idea is very densely described for something as simple as that, and took me about seven readings to convert into actual working code.
15:34:04 <trigone> koz_: well haskell is not just for theory after all
15:34:16 <trigone> Vigna's array? was i there?
15:34:23 <koz_> trigone: I mentioned it with you around.
15:34:34 <koz_> Basiclaly, it's a bit set with the ability to do popcount in O(1).
15:34:54 <trigone> koz_: sorry, i'm slightly getting lost around these days, too many subjects, papers and conversations ^^
15:34:55 <koz_> And select 'the nth 1 bit up to some index i' in O(log(n)), with potentially better performance at the cost of more storage.
15:35:03 <trigone> wha's popcount?
15:35:08 <koz_> Number of set bits.
15:35:33 <trigone> sorry i don't get what you mean by set bits
15:35:37 <koz_> Vigna's improvements were basically 'works for 64-bit wordsizes' and 'has good cache performance'.
15:35:43 <koz_> trigone: Consider 001101
15:35:48 <koz_> That is a bitset with 6 bits.
15:35:54 <koz_> Three of them are 1s (set).
15:35:58 <koz_> So a popcount of that would return 3.
15:36:03 <trigone> hm ok
15:36:31 <trigone> what's the typical usage?
15:36:47 <koz_> trigone: Bitmap indices.
15:37:03 <koz_> (very useful for database indexes)
15:37:38 <Tuplanolla> You convert the number to a waveform, listen to it, count the number of pops you hear and dismay over how it doesn't actually tell you anything, trigone.
15:38:11 <trigone> Tuplanolla: that's vaguely funny but what's your underlying message?
15:38:12 <koz_> It's also useful for compactly storing sets of numbers and checking how many numbers you have in particular intervals.
15:38:24 <koz_> trigone: I think the message is 'Tuplanolla doesn't care about rank-select dictionaries'.
15:39:24 * hackagebot Villefort 0.1.1.0 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
15:39:24 * hackagebot hw-rankselect 0.10.0.1 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
15:39:29 <Tuplanolla> Perhaps that the question is rather silly.
15:39:29 <trigone> koz_: ok so it's pretty raw :) to resume, the point is to obtain means to make faster data structures?
15:39:54 <koz_> trigone: I'm not sure I understand your question.
15:40:20 <koz_> Also, could someone please tell me what the whole deal with 'Eq1' and 'Show1' type classes is?
15:40:23 <koz_> I keep seeing them everywhere.
15:41:12 <trigone> koz_: i don't get what they mean but maybe you will: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html
15:42:00 <glguy> koz_: It would probably worth trying to understand what the specific examples you already found are doing with them
15:42:22 <koz_> glguy: Ah, OK.
15:42:34 <trigone> koz_: well, indices, dictionary: is that not about storing and accessing data faster? doesn't matter anyway i got lots to study already :)
15:43:00 <koz_> trigone: Yes, that's true.
15:43:15 <koz_> Another use is 'I have a set of natural numbers, and I wanna see how many numbers are in that set from x to y'.
15:43:29 <koz_> If you have a rank-select dictionary, that query is O(1) no matter what x and y are.
15:43:57 <trigone> koz_: hm ok... sounds cool
15:44:06 <NemesisD> does anyone know of a data structure that has a few slots of differeing types that allows for all but one to be Nothing but not all of them to be Nothing?
15:44:07 <koz_> Well, assuming O(1) rank.
15:44:33 <koz_> NemesisD: Do you mean a fixed few slots, or a varying number few slots?
15:44:49 <NemesisD> koz_: fixed, 3 in my case
15:45:22 <koz_> trigone: Meanwhile, select in the above case could go 'give me the nth number in the set in the range of x to y' in (in this case) log time, no matter what x and y are.
15:45:49 <koz_> (again, assuming log-time select)
15:46:00 <hpc> NemesisD: so you want a type like (Maybe a, Maybe b, Maybe c) which excludes (Nothing, Nothing, Nothing)?
15:46:06 <trigone> koz_: ok! tbh i don't know much about data structures, measure of efficiency, etc
15:46:09 <hpc> or do you want a | b | c?
15:46:39 <koz_> trigone: Learn Big O.
15:46:50 <koz_> It's really easy and it means you can actually at least talk about this kind of thing sensibly.
15:46:53 <NemesisD> hpc: the first one. i can think of a trivial constructor data A a b c = A a (Maybe b) (Maybe c) but it will be really hard to use because i don't know statically which one is not Nothing
15:46:55 <trigone> NemesisD: well you could go enumerating all: Foo a b c = ABC a b c | AB a b | A a | BC b c ...
15:47:09 <koz_> trigone: That's a pattern-matching hell.
15:47:29 <hpc> maybe throw in a view pattern
15:47:33 <trigone> koz_: i get the idea of big o. i don't get much of the rest...
15:47:39 <trigone> koz_: well .... yeah ^^
15:47:54 <koz_> trigone: Well, Big Omega and Big Theta are just simple variations. What do you mean by 'the rest'?
15:48:01 <hpc> abcView :: Foo a b c -> (Maybe a, Maybe b, Maybe c)
15:48:29 <hpc> and then i forget the syntax for view patterns but it's something like foo (abcView -> (Just a, Just b, Just c)) = ...
15:48:33 <NemesisD> the only operation i'd need would be (a -> d) -> (b -> d) -> (c -> d) -> Foo a b c -> d and then converting it into (Maybe a, Maybe b, Maybe c) would be fine
15:48:35 <hpc> where you have access to a, b, c
15:48:46 <trigone> koz_: doesn't matter, honestly i'm more focused on Free monads and recursive schemes these days :)
15:49:03 <koz_> trigone: OK, figured I might be able to direct you somewhere. :P
15:49:31 <trigone> koz_: that's very kind, but honestly i already have waaay too many things to look up :P
15:50:27 <NemesisD> i was just curious if there was a CT idea or library that did this. i can always extract a newtype over (Maybe a, Maybe b, Maybe c) with a smart constructor in a separate module
15:50:37 <trigone> koz_: btw, what's your take on that: http://aaronlevin.ca/post/136494428283/extensible-effects-in-the-van-laarhoven-free-monad (hope i haven't already asked the question, i keep losing sight of articles and then i find them back but i'm not sure they're the same...)
15:51:22 <koz_> trigone: Honestly, I haven't read it.
15:51:25 <koz_> I might give it a look later.
15:51:52 <hexagoxel> NemesisD: and, just to make sure, you need "forall d" ?
15:52:09 <hexagoxel> would that operation not always take the first Just, by some order?
15:52:22 <NemesisD> hexagoxel: yeah it would take the first Just but it needs to be total
15:52:30 <trigone> koz_: k, that was just in case :) myself haven't yet read all of it (and the formatting doesn't help)
15:52:57 <hexagoxel> NemesisD: sounds like a | b | c ..
15:53:45 <NemesisD> hexagoxel: i'm not sure. all of the values may be present at once, but at least one must be present
15:53:48 <trigone> NemesisD: why not outputing a Maybe d? returning nothing if a b and c are nothing...
15:54:25 <hexagoxel> NemesisD: ah, so you also have other operations with which you can observe more than with (a -> d) -> (b -> d) -> (c -> d) -> Foo a b c -> d, too?
15:54:29 <NemesisD> trigone: my goal here is to figure out a structure such that a b and c cannot possibly all be Nothing
15:55:10 <NemesisD> hexagoxel: literally all i need is that operation and then Foo a b c -> (Maybe a, Maybe b, Maybe c)
15:55:25 <trigone> NemesisD: i think the best would be a non-empty list... provided you can somehow stash all your different types (with a wrapper a | b | c perhaps)
15:56:31 <NemesisD> hmm, perhaps a bit imprecise. this almost seems similar to a 3-case These
15:56:36 * hexagoxel .oO (a | b | c, Maybe a, Maybe b, Maybe c)
15:56:48 <NemesisD> These a b = This a | That b | These a b
15:57:12 <hexagoxel> (that's stupid, most likely :)
15:57:19 <glguy> A pair of complicated solutions to this: http://lpaste.net/5740655250633654272
15:57:22 <hexagoxel> (what i said, not you)
15:58:06 <NemesisD> maybe i'll just wait for dependent haskell :P
15:59:19 <NemesisD> glguy: i actually kind of like the GADT you did there. let me try that on
16:04:12 <hexagoxel> glguy: NonEmpty is unused there, it seems, hmm?
16:05:12 * hackagebot rtcm 0.2.5 – RTCM Library. – https://hackage.haskell.org/package/rtcm
16:19:24 <NemesisD> glguy: i think i'm going to go with that approach. it is the least likely to get eyebrow raises from coworkers http://lpaste.net/357560
16:19:31 <NemesisD> i'm kind of surprised this isn't a library
16:19:56 <koz_> NemesisD: Write one!
16:20:59 <lilred> Is there a name for the monad which hides an underlying (read-only) stream, such that `M a` is the type of operations which consume zero or more elements of the stream in the process of creating a value of type `a`
16:21:07 <NemesisD> whoops. looks like my firstOf1 has to be partial. i don't think its possible to write the Skip for firstOf1 :: (a -> b) -> AtLeastOneOf '[a] -> b
16:21:34 <hpc> lilred: pipe maybe?
16:21:46 <NemesisD> but i think its impossible to construct AtLeastOneOf '[] so i think that's ok
16:22:59 * hackagebot loup 0.0.15 – Amazon Simple Workflow Service Wrapper for Work Pools. – https://hackage.haskell.org/package/loup
16:23:00 <lilred> hpc: thanks for the tip, that looks like basically what I'm looking for. Though it seems a bit heavy-duty for what I'm trying to do
16:23:11 <dmwit> lilred: `Parsec`?
16:23:33 <dmwit> (Or one of the many other parser combinator monads.)
16:23:47 <lilred> dmwit: that's perfect, thanks
16:27:13 <jared-w> It's funny because I read an entertaining post about this one dude who was ranting about how stupid Haskell programmers are for thinking that monads make good parsers
16:27:36 <hpc> they're right, applicative parsers are way better
16:28:08 <jared-w> They weren't quite informed on the whole thing and they had some very, ahem, interesting ideas of how to parse things and the right way to make a parser for a language/compiler
16:28:45 <hpc> was it "write an LR parser because all automation should be done by hand"?
16:28:52 <jared-w> It was just funny because it was clear they were quite intelligent and that everything they were saying was coherent; it was also just... not coherent at the same time? Like they were from a slightly different parallel universe :p
16:31:18 <jared-w> I'm gonna see if I can find the post...
16:31:31 <proofskiddie> Anyone ever get the error "Unable to parse output of ghc-pkg dump" ???
16:32:26 <proofskiddie> When running cabal
16:33:14 <jared-w> aha, this dude: https://www.reddit.com/r/ProgrammingLanguages/comments/6qt8fd/do_you_think_its_important_for_a_language_to_have/dl07oq4/
16:34:26 <jared-w> "grammars, while a useful tool, are a product of their time"
16:35:01 <jared-w> (This is what I was thinking of, but I was mistaken about him actually talking about parsers. It was something else that mentioned monadic parsers as being silly)
16:36:05 <geekosaur> that one is to a certain extent true: tools like happy and yacc were designed to squeeze parsers into a PDP-11 user address space
16:37:14 <geekosaur> well, yacc certainly. not sure you could fit a Haskell implementation into that little space...
16:37:52 <Zowlyfon> I heard the first C compiler was written on a PDP-11
16:39:00 <jared-w> I wouldn't be surprised; C was invented to port Unix from one assembly to another without having to write it twice. It was just a giant hack, really
16:39:41 <geekosaur> I want to say PDP7, which was even smaller
16:39:52 <koz_> geekosaur: PDP8 wasn't it?
16:40:02 <geekosaur> (the numbers don't mean anything, PDP10 was a mainframe)
16:40:18 <trigone> hi, i've got jumbled thoughts. maybe my question is absurd or trivial: given some random ADT, is there any way to create a new ADT that would only allow *some* constructors of the previous one's sum
16:40:20 <koz_> geekosaur: Nope, PDP7 indeed.
16:40:31 <trigone> (allow as in, typecheck-wise)
16:40:47 <geekosaur> trigone, no.
16:40:56 <erisco> trigone, copy, paste, then delete
16:41:05 <trigone> erisco: eh?
16:41:20 <trigone> oh got it
16:41:32 <erisco> and you can have TH do that for you
16:41:49 <jared-w> Wouldn't it be possible to create your ADT in a 'trees that grow' manner and then start with the minimal set and add on constructors as necessary?
16:41:58 <trigone> erisco: TH is strictly compile time, no runtime overhead?
16:42:11 <erisco> that's right
16:42:41 <trigone> jared-w: yeah but stacks over stacks of additional constructors get messy so fast.. though i guess lenses may help with that... but i'm not konwledgeable in that yet
16:43:18 <erisco> trigone, if you are willing to use GADTs and other type extensions then there is maybe another solution depending on your problem
16:44:12 <trigone> erisco: well depends, is there any runtime cost in using GADTs? that's a question i had for a long time...
16:45:04 <erisco> I don't know. What are you creating that is high performance?
16:46:04 * hackagebot sbp 2.2.12 – SwiftNav's SBP Library – https://hackage.haskell.org/package/sbp
16:48:34 <danilo2> trigone: there is runtime overhead if you use GADTs that produce exystentials. Basically almost every GADT that you would be able to create using "standard" datatype syntax with exystentials uses exystentials under the hood
16:50:44 <trigone> what's "exystentials"? why the y?
16:52:03 <mibaz_1> idealistically, if something has an instance for both monad and applicative, should you always use the applicative? (generally speaking)
16:52:10 <lilred> Is a `Foldable` instance essentially a `toList` instance, or does it give additional properties/guarantees?
16:52:20 <danilo2> trigone: "y" is just a typo, https://wiki.haskell.org/Existential_type
16:52:45 <geekosaur> mibaz_1, ideally you use Applicative when the Applicative instance is enough.
16:53:06 <geekosaur> the point of Monad is that it can do more than Applicative can. but fewer types can have Monad instances as a result
16:53:16 <danilo2> trigone: basically if you write `data Foo where Foo :: Show a => a -> Foo` you'll get something that uses runtime dict to evaluate associated functions
16:54:20 <geekosaur> (in general when a mathematical abstraction gives you more ability in one direction, it is at the cost of some other direction. in this case generality (Applicative) vs. expressiveness (Monad))
16:54:57 <geekosaur> but if you are already using Monad operations in an expression, there isn't necessarily a reason to use Applicatives in the same expression.
16:56:02 <geekosaur> that said, there is a preference for using "pure" instead of "return", mostly because "return"'s name was a bit of a clever mistake. but if you need backward compatibility with older ghc versions for some reason, use "return"
16:56:08 <trigone> danilo2: ok thx... is the overhead really consequent in worst case scenarios?
16:56:40 <trigone> s/consequent/big/
16:58:22 <mibaz_1> geekosaur: Ok, cool. I'm trying to wrap my head around it. What can, for example, the IO monad do that the IO applicative can't?
16:58:30 <geekosaur> lilred, every so often laws for Foldable are discussed, but at present I think the only thing resembling a law is that you can define foldMap or foldr. which, because foldr is essentially swapping out (:) and [] in a list, is equivalent to being able to define toList
16:58:33 <mibaz_1> (I read that there was an IO applicative)
16:58:56 <mibaz_1> (there must be, I mean)
16:59:41 <lilred> geekosaur: if `Foldable` is about folding, is `Traversable` about scanning?
17:00:04 <geekosaur> Traversable is generalized map (actually, generalized mapM), yes
17:00:34 <geekosaur> mibaz_1, taking Maybe as an example, the Maybe Applicative must produce a Just if given a Just; the Maybe Monad can produce a Nothing given a Just
17:01:39 <geekosaur> :t (<*>) -- the core thing Applicative gives you over Functor
17:01:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:02:00 <danilo2> trigone: what do you mean by worst case scenario? The overhead is there ALWAYS if you "hide types" from typechecker. If Typechecker cannot solve what method you mean because you told "any type that have Show, but we will not keep track of this type anymore", then you've got method calling by dict
17:02:31 <danilo2> trigone: If you think about it, it makes sense and you cannot implement this any better. Anyway if you use GADTs without such "types hiding" then there will be no overhead
17:02:53 <mibaz_1> geekosaur: ah, ok, so an applicative determines the effect of a result only based on the input's effect, while a monad determines result effect based on input effect and input value, correct?
17:02:58 <trigone> danilo2: ok...
17:03:03 <trigone> thx
17:03:09 <danilo2> trigone: why the "..." ? Is it not clear ? :)
17:03:27 <mibaz_1> read that: applicative function and monadic function
17:04:26 <geekosaur> mibaz_1, I think you have things backwards. the effect applied with <*> is (a -> b); it can't change the Applicative (for Maybe, from Just to Nothing), it must produce a value and the Maybe Applicative will make a Just out of it
17:04:31 <trigone> danilo2: well i don't know if the overhead is very important or marginal... i know it depends on usage, but then the question is, can it become (easily) so heavy to truly be impractical?
17:04:54 <geekosaur> the effect with >>= is (a -> m b); it can now say Nothing instead of Just
17:05:31 <koz_> Is Semigroup in Base?
17:05:35 <geekosaur> but it requires more knowledge than <*> does
17:05:43 <geekosaur> koz_, as of 8.0 yes
17:05:50 <koz_> geekosaur: Thanks!
17:05:53 <danilo2> trigone: If yourr application bases almost only on accessing such existential fields than yes, it could become impractical. I you use it not in performance critical code, you'll be fine. However, remember that in 99% of normal code you will never need existentials and everything can be done without them.
17:07:23 <mibaz_1> geekosaur: So, for applicative, the input context must match the output context? It seems so from the type signature of <*>
17:07:28 <trigone> danilo2: yeah that's also one of my main issues: recognize when to use flashy extensions and when it's a bad idea... it's not always easy
17:07:43 <mibaz_1> by "context" I mean 'Just' or 'Nothing'
17:07:52 <geekosaur> yes, if you (again using Maybe as example) have Nothing in yo get Nothing out, if you have Just a in then you get Just b out
17:07:54 <mibaz_1> not sure if that's good terminology
17:08:43 <danilo2> trigone: its not aobut extension. GADTs will nto harm you in any way. Its about when to use static fields or dictionary. In every language you will have this problem. If you code in C++ sometimes you want to access fields from structures just by method name and sometimes you want to lookup by string from some dynamic map
17:08:54 <geekosaur> fmap has the same limitation (note that the action is actually f (a -> b) for Applicative; the *action* is inside the Applicative, instead of its result being in it as with Monad)
17:09:03 <danilo2> trigone: you rarery want the second, you also rarery want to use existentials
17:09:56 <danilo2> trigone: there are noe extensions that will harm you (apart of DeriveAnyClass, which in my opinion is just broken, until you use GHC 8.2)
17:09:58 <mibaz_1> geekosaur: Doesn't that make the Maybe applicative essentially useless? Would that be a situation where you would always use the monad? 
17:10:09 <trigone> danilo2: ok! thx :) --really, no extension?
17:10:22 <mibaz_1> If you can't switch between the contexts then you can't record early failure, off the top of my head.
17:10:39 <geekosaur> mibaz_1, actually one rarely uses either Applicative or Monad for Maybe; it's a bit too simple, mostly it is useful as a teaching example like this because of its simplicity
17:11:04 <geekosaur> you rarely go beyond Functor (fmap)
17:11:29 <danilo2> trigone: yes. They will at last make your errors less readable like AllowAmbiguous types. NoMonomorphismRestriction can harm you in one way - it could sometimes default to more general type then you need (for example to Integer than to Int). But appart of that, none
17:12:29 * hackagebot gnss-converters 0.3.11 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
17:12:29 <trigone> geekosaur: if you have three tests that can each yield Maybes, and you want to sequence them, don't you need Monad?
17:13:09 <jared-w> trigone: true. But geekosaur is implying that Maybe is often considered not the 'best' choice of error handling as most of the time, you want more information other than "well something went wrong lol"
17:13:20 <trigone> danilo2: k! good to know. thx :)
17:13:22 <geekosaur> ^
17:13:36 <trigone> jared-w: k got it
17:13:43 <geekosaur> pretty much, it is rare that all you actually care about is "oh, something went wromng somewhere" which is all Maybe can give you
17:13:54 <danilo2> trigone: yr welcome :)
17:13:55 <geekosaur> thus, Except / ExceptT
17:14:07 <jared-w> Maybe is perfect for something like taking the head of a list. But if you give 3-5 things to a mkRecord function and something blows up, you probably want to know what went wrong :)
17:15:02 <jared-w> And Except / ExceptT can do much more complicated things than just the mkRecord one, iirc. (The mkRecord one is handled pretty well with Either, I think?)
17:15:07 <trigone> well each tool has its use... but true, Maybe's inability to remember where it Nothinged is quite limitative...
17:15:15 <mibaz_1> So fmap can consider only the context of the input to the action, <*> can consider the context of the action and the input, and >>= can consider the context of the input and action and the value of the input; getting warmer?
17:15:21 <mibaz_1> geekosaur:
17:15:57 <crisistons> Heyy
17:15:58 <jared-w> mibaz_1: I'd say so. That's not quite how I think about those things, but it doesn't sound wrong to me
17:16:07 <geekosaur> mibaz_1, maybe I am misunderstanding you. the difference between Applicative and Monad is in the output: Applicative must forge ahead, Monad can say 'stop!'
17:16:25 <geekosaur> as I think about it at least
17:16:51 <crisistons> Whatchu guys talk about here
17:16:58 <jared-w> crisistons: haskell, the programming language
17:17:11 <crisistons> oh
17:17:21 <crisistons> never heard of that shit
17:17:31 <mibaz_1> jared-w: I'd love to hear about how you think about it
17:17:31 <jared-w> It's pretty great. Do you program at all?
17:17:34 <crisistons> i was just looking up for some irc servers online
17:17:45 <geekosaur> or otherwise make use of the additional context relative to Applicative. unless you are considering Monad vs. Applicative to be the value of the input? I'd consider it the context, but that contradicts wht you meant by "context of ..."
17:17:53 <trigone> geekosaur: i'm wondering if that meliorated Maybe exists: data MaybeMemory mem a = Just mem a | Nothing mem --and the field mem stays the same value as the first Nothing encountered
17:18:10 <mibaz_1> geekosaur: I'm discovering that the reason these types are so difficult is because there are so many different ways to think about them
17:18:13 <crisistons> I would say im still a beginner and i would love to get experienced with programming and all the stuff
17:18:22 <geekosaur> @src First
17:18:22 <lambdabot> newtype First a = First { getFirst :: Maybe a }
17:18:27 <jared-w> @where learnhaskell
17:18:27 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:18:36 <jle`> trigone: the first Nothing encountered doesn't have a value...
17:18:43 <jared-w> If you want to learn Haskell, that link has a pretty good start, crisistons :)
17:19:01 <crisistons> Its a language for what
17:19:10 <crisistons> Alright ill check it out once im on pc
17:19:12 <jared-w> General purpose programming. You can write anything you want to in it
17:19:18 <jle`> crisistons: it's a language for programming
17:19:20 <jle`> computers
17:19:34 <crisistons> Yeah but like what would it be used for
17:19:41 <mibaz_1> geekosaur: But I think I'm reading you; monad can 'stop!' because it can examine the value of the input to each chain of the function -> "can consider the... value of the input"
17:19:44 <jle`> what you would use any programming language for, heh
17:19:47 <jared-w> mibaz_1: I don't have a very concrete way I think about them yet. The more I learn about category theory, the more I tend to lean towards that way of thinking about things
17:19:50 <jle`> crisistons: how familiar are you with programming languages and computers?
17:19:53 <geekosaur> mibaz_1, all of them can see the value of the input
17:20:08 <jle`> crisistons: programs can do lots of things
17:20:12 <geekosaur> they just can't use it to signal anything other than "here's a new value for the same context"
17:20:18 <crisistons> Im not that good but i have a general knowledge on how things work
17:20:24 <trigone> jle`: no, i meant sth like: (,,) <*> Just "a" 5 <*> Nothing "b" <*> Just "c" 4 -- would yield Nothing "b"
17:20:25 <jle`> crisistons: they are the basis of the functionality of your computer
17:20:34 <crisistons> I know most of the definitions
17:20:37 <jle`> crisistons: like, you are probably using a program right now
17:20:39 <mibaz_1> geekosaur: but only monad can change the context of the output based on that value, right?
17:20:42 <jle`> to chat on IRC :)
17:20:51 <crisistons> yeah ofc
17:20:52 <jle`> even your operating system is a program! :D
17:20:55 <geekosaur> Monad, because it exposes the 'm' to the action, allows you to access stuff in m (think MonadReader, MonadState), and allows you to pick a different context (for Maybe, replacing the implied Just with Nothing)
17:20:59 <jle`> so that is the sort of things you wouild use programming languages for
17:21:04 <crisistons> haha yeah i know that
17:21:06 <jared-w> Like, monoid I understand in terms of its laws/properties. Then monad is just a monoid "one level up"; where monoids can compose values together, monads can compose effects together (The kleisli arrow is a particularly strong example of this)
17:21:07 <trigone> jle`: aka if all is good, it yields just, otherwise it gives you some message you provided to mark where Nothing occured
17:21:29 <crisistons> i was pretty interested to get into python but i didnt have the motivation
17:21:31 <jle`> trigone: that looks like a completely different type than what you gave, heh
17:21:34 <crisistons> I know html and css
17:21:36 <Zowlyfon> crisistons: Haskell has been used for a lot of things, From webservers to Facebooks anti-spam system.
17:21:36 <jle`> trigone: since Nothing doesn't have any values inside it
17:21:43 <mibaz_1> geekosaur: Yeah, that's right. I think we're on the same page, I'm just thinking about it in much more newbish terms.
17:21:44 <crisistons> Theyre coding
17:21:57 <crisistons> Aha
17:22:03 <jle`> crisistons: ah.  yeah, in general it's hard fo rme to get motivated too for programming unless i have an immediate thing i want to use it for/i want to program
17:22:07 <crisistons> I dont see that its that much popular
17:22:07 <trigone> jle`: yes it did, i wrote "Nothing mem"
17:22:17 <jle`> trigone: ah i didn't see it, sorry
17:22:21 <jle`> i just saw the mem in the Just
17:22:29 <trigone> np... i'm wondering the difference with Either...
17:22:33 * geekosaur already pointed at the First newtype
17:22:36 <mibaz_1> jared-w: One day maybe I'll have a concrete way of thinking about them
17:22:47 <trigone> geekosaur: well i didn't get your First newtype, what does it do?
17:22:55 <mibaz_1> The category theory way is probably the most powerful
17:23:05 <jared-w> trigone: Either a b = Left a | Right b. You stick the success value in the right and the error value is embedded in the structure of Either
17:23:08 <crisistons> dam irc servers can handle alot of users
17:23:22 <jared-w> mibaz_1: https://golem.ph.utexas.edu/category/2010/03/a_perspective_on_higher_catego.html if you want to blow your mind a bit on category theory, read this :)
17:23:43 <geekosaur> if you are working with a Monoid of Maybe values, you get the last result of a chain of evaluation. with the First newtype, we switch the Monoid instance so you get the first result
17:23:45 <jle`> trigone: what you gave looks a little bit like Either, except without the mem in Just
17:23:46 <jared-w> (it's very little actual math and more a philosophical article on what CT /is/)
17:23:55 <jle`> trigone: the Applicative instance for Either has the behavior you are expecting 
17:23:55 <trigone> jared-w: i guess my data type is just a stupid Either, since putting the error message inside Just is absurd
17:24:08 <jle`> > (,,) <$> Right 5 <*> Left "b" <*> Right 4
17:24:10 <geekosaur> note that Maybe by itself is not strong enough for this; you need additional support
17:24:10 <lambdabot>  Left "b"
17:24:11 <trigone> jle`: y i know
17:24:20 <trigone> i mixed things up in my head
17:24:24 <geekosaur> at minumum Monoid, but also Monad (which gives you MonadPlus)
17:24:44 <trigone> geekosaur: you mean the first non-Nothing one?
17:24:45 <crisistons> can i program robots using haskell?
17:24:47 <geekosaur> yes
17:24:55 <jle`> you can program robots using haskell
17:25:18 <crisistons> Nice, and is it easy to get used to
17:25:26 <jared-w> crisistons: it's Turing complete, so you can program anything that's possible to be computed on a computer by using Haskell
17:25:37 <Zowlyfon> crisistons: its probably easier to learn if you don't know any programming
17:25:46 <trigone> geekosaur: ok, got it. well that's not really related to Either-like stuff at first sight...
17:25:52 <geekosaur> trigone, think about it, the Maybe Applicative is a chain of calculations, it's not inherently short-circuit-able. Monad can short-circuit but only on an exceptional case
17:26:09 <trigone> exceptional?
17:26:14 <geekosaur> if you want the first of something, you need more structure, hence Monoid (or lists, which are almost the free monoid)
17:26:16 <mibaz_1> crisistons: It's definitely easier to learn if you've never programmed before, as Zowlyfon says.
17:26:20 <crisistons> Alright ill start with that i guess
17:26:22 <jle`> trigone: you also have something similar to what you're thinking of in MaybeT (Writer mem) a
17:26:29 <Zowlyfon> Dijkstra advocated teaching it to first year comp sci students
17:26:36 <geekosaur> trigone, Nothing vs. Just, Left vs. Right, etc.
17:26:39 <jle`> er, MaybeT (Writer (Last mem)) a
17:26:40 <crisistons> Can i use something like kali to program or any particular os
17:27:06 <Zowlyfon> You shouldn't really use kali
17:27:09 <mibaz_1> jared-w: I'll give that a read. Judging from the first paragraph it seems it directly addresses the fact that there are so many different ways to think about these abstractions.
17:27:09 <Zowlyfon> but you can
17:27:19 <crisistons> Whu
17:27:22 <crisistons> Why**
17:27:23 <jared-w> Zowlyfon: dijkstra would've preferred pure lambda calculus, I'm sure, but Haskell is a nice substitute if you need shiny things to run on the computer :p
17:27:25 <geekosaur> but you can't really specify 'first one' because the expression is all or nothing, it succeeds or it fails. "first" implies more structure than succeed/fail
17:27:35 <Zowlyfon> Kali is a pen testing distro with very little security 
17:27:42 <Zowlyfon> only really good for pen testing
17:27:47 <crisistons> Oh
17:27:56 <crisistons> Thats what i was trying to go for tbh
17:28:00 <crisistons> I had ubuntu as well
17:28:17 <Zowlyfon> Ubuntu would be far better for general use
17:28:29 <crisistons> What are you using rn
17:28:31 <crisistons> ?
17:28:38 <Zowlyfon> Fedora
17:28:40 <jared-w> I'm using Arch linux 'cause I'm a giant-ass nerd
17:28:45 <crisistons> Oh lmao
17:28:57 <trigone> hm yeah, but in the end Either is quite enough
17:29:05 <crisistons> All of your are masters in haskell?
17:29:17 <Zowlyfon> Some people here are masters, others like me are beginners
17:29:32 <jle`> we're not all haskell masters, we just like to sit around and talk about it
17:29:33 <crisistons> Oh then we can learn together 😂🌚
17:29:34 <mibaz_1> crisistons: Debian sid cause I used to be like jared-w but still have some pain receptors left
17:29:35 <jared-w> hah, no. I'm one of the more inexperienced and less proficient people in this room
17:29:37 <geekosaur> trigone, you can add more stiff on to get, say, first partial result and the final answer --- but now you have just implemented a monoid the hard way and then thrown part of it out
17:29:45 <Hafydd> I read that as "all of your masters are in haskell?" and was picturing someone who had taken multiple Master's Degrees in Haskell.
17:30:02 <crisistons> Lol
17:30:14 <earldouglas> If only such a degree existed...
17:30:16 <jle`> we like so much that we spend free time sitting in a chat room and talking about haskell for fun
17:30:23 <Zowlyfon> well
17:30:25 <crisistons> That would be sick tbh
17:30:30 <Zowlyfon> I know someone who wrote their masters project in Haskell
17:30:35 <jared-w> "my MS thesis was on 'burritos are just endobeans in the category of tortilla shells, what's the problem?' "
17:30:41 <jared-w> /s
17:30:41 <Hafydd> It's certainly possible to focus on Haskell (and related topics) in a master's degree.
17:30:45 <Zowlyfon> jared-w: lol
17:30:49 <mibaz_1> hafydd: I pictured the mental slave masters that punish me from the type system
17:31:00 <jared-w> mibaz_1: that's agda :p
17:31:02 <jle`> i mean there are definitely people whose masters theses are on haskell
17:31:19 <crisistons> Well, if anyone is down to start learning with me then im ready
17:31:23 <geekosaur> ...and then there are those of us who are degree-less
17:31:28 <crisistons> I just want motivation
17:31:32 <crisistons> A partner :)
17:31:48 <Zowlyfon> crisistons: this book starts pretty barebones: http://learnyouahaskell.com/chapters
17:31:55 <jared-w> @where learnhaskell
17:31:55 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:32:05 <crisistons> Alright
17:32:13 <jared-w> I much prefer this one, though, but perhaps LYAH would be better to start out with at first if you're super new to programming
17:32:16 <trigone> hm first partial result... not bad in theory. in practice, i don't see what you could do with it... you'd have to handle all cases for each potential point of failure... pretty sure it's counter productive, even if it somewhat has an effect of moving around some code
17:32:39 <jaseemabid> I'm parsing an indentation aware grammar with megaparsec. I'd optionally like to separate a list of items with ; instead of newlines and correct offset. Is there any docs/examples on how to do this? I have the non ; version working as expected so far. 
17:32:46 <trigone> well unless every partial result is basically of the same type and semantics
17:32:47 <crisistons> What about python ive been looking towards that aswell
17:32:57 <Zowlyfon> Python is a very different language
17:33:00 <crisistons> Or js
17:33:08 <Zowlyfon> js is more of a toy in my opinion
17:33:14 <jared-w> Those are the polar opposite of Haskell :)
17:33:21 <crisistons> Aha
17:33:27 <crisistons> Why are they the opposite
17:33:36 <jle`> js is a toy that ended up becoming the foundation of all front-end web programming
17:33:38 <crisistons> What makes haskell so different than others
17:33:38 <jle`> as a sick joke
17:33:54 <Zowlyfon> crisistons: The way programs are formed
17:34:02 <crisistons> Aha
17:34:05 <jle`> the way you approach problems is sort of different
17:34:15 <jle`> by sort of, i mean pretty much completely
17:34:19 <Zowlyfon> Haskell uses a lot of recursion where Python uses a lot of variable mutation
17:34:28 <crisistons> Ohh i see
17:34:36 <jle`> well...in haskell we try not to use too much explicit recursion
17:34:45 <jle`> i wouldn't say recursion is a particularly haskell thing
17:34:55 <mibaz_1> crisistons: https://stackoverflow.com/questions/17826380/what-is-difference-between-functional-and-imperative-programming-languages
17:35:07 <mibaz_1> Haskell is functional. Those others are imperative.
17:35:21 <jle`> also haskell has static types and the others have dynamic types
17:35:33 <jle`> meaning that if your program has errors, haskell will try to tell you before you try to run them
17:35:34 <crisistons>         What does that mean im sorry i cant open any links rn im on my shitty iphone 4 rn
17:35:58 <jle`> but in python and javascript, you won't find out about any errors in your programs until you run them in an important situation
17:36:06 <jle`> and it'll fail at the worst possible time
17:36:11 <jle`> and cost you billions of dollars
17:36:29 <trigone> jle`: and your dog will die of leprosy
17:37:07 <mibaz_1> trigone: or worse, you'll have to try and fix a javascript program
17:37:09 <trigone> so, save some puppies, code in haskell!
17:37:21 <trigone> (or kitties if you prefer)
17:37:57 <trigone> mibaz_1: pretty sure there's a room in hell dedicated to js debugging...
17:40:38 <trigone> i'm in deep thoughts about DSL, and the slight problem of wondering how to have strong control about what subpart of DSL can be used in this or that circumstance, without having to explode the DSL into tons of different/overlapping subDSLs, cuz it kinda sucks...
17:40:44 <mibaz_1> trigone: Can it even be considered debugging when the program does random things?
17:40:54 <mibaz_1> trigone: Can a rock fall down a hill the 'wrong' way?
17:41:21 <jared-w> trigone: why do only certain parts of the DSL need to be used in certain areas?
17:42:18 <trigone> mibaz_1: i think those languages are a way to bring back faith in computer science -- by making prayer as inevitable tool
17:44:00 <trigone> jared-w: well, maybe i'm being overly controlling, but, when you compose your DSL words together, sometimes you know most of the language is not expected to occur --unless your program is a simple random list of operations, each word/operation just as probable to be the next one
17:44:03 <jared-w> trigone: I believe in the holy trinity of computation
17:44:33 <mibaz_1> God is your typechecker now
17:44:47 <jared-w> trigone: so are you trying to make it impossible to create a ill-formed program in your DSL?
17:45:11 <trigone> mibaz_1: everytime it doesn't typecheck, you get flooded
17:45:45 <mniip> 8/10/2017 [00:40:16] <trigone> i'm in deep thoughts about DSL, and the slight problem of wondering how to have strong control about what subpart of DSL can be used in this or that circumstance, without having to explode the DSL into tons of different/overlapping subDSLs, cuz it kinda sucks...
17:45:51 <mniip> type-indexed dsls and type families
17:46:01 <trigone> jared-w: well i'm trying to reduce the allowed DSL to say the size of a function using the DSL. basically, i want to be able to say "now we're talking about that, we shouldn't be able to talk about this"
17:46:19 <trigone> mniip: do you have refs on that technique?
17:46:25 <mibaz_1> lol gotta run, thanks all for the help
17:46:37 <mniip> not really, it's kinda everywhere
17:46:55 <trigone> jared-w: basically i want to typecheck the idea of writing a program that says "cut the carrot. flush the toilet. put the carrot into the pan."
17:47:15 <trigone> mniip: what's type-indexed dsl?
17:47:49 <mniip> a gadt with type parameters that dictate or can be used to dictate how the DSL is to be used
17:48:17 <trigone> mniip: it uses HList?
17:48:43 <mniip> not necessarily?
17:48:45 <trigone> (or can if needed)
17:49:18 <trigone> mniip: is there runtime overhead to those methods?
17:49:19 <mniip> I mean, e.g an often used example is
17:49:58 <mniip> data Expr a where IntLit :: Int -> Expr Int; Less :: Expr Int -> Expr Int -> Expr Bool; IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
17:50:22 <mniip> then it becomes invald to say, IfThenElse (IntLit 3) x y
17:50:53 <mniip> and, a function accepting such a gadt can dictate what the gadt contains
17:50:54 <mniip> e.g
17:51:00 <mniip> eval :: Expr Int -> Int
17:51:13 <mniip> you cannot feed (Less (IntLit 3) (IntLit 5)) into it
17:51:26 <mniip> another example is the effects library
17:51:51 <mniip> extensible-effects(?)
17:52:05 <mniip> it puts the effects that the code uses into a type-level annotation on the monad
17:52:06 <trigone> mniip: hm... yeah but that's not the kind of control i meant. it'd be more about, say, in a subset of IO including among others creation and deletion of files, forbidding the use of the delete operation in a function dedicated to listing the files of a directory...
17:52:32 <trigone> mniip: yeah i just read that earlier... maybe it's what i'm looking for... it just feels heavy but maybe not
17:52:40 <mniip> well
17:52:47 <mniip> that could be done but I don't think that exists
17:52:53 <trigone> mniip: what?
17:52:57 <jared-w> trigone: you should be able to do that by paramaterizing each of the commands should you not?
17:53:03 <mniip> yeah
17:53:12 <mniip> I'm thinking of a selinux-like DSL
17:53:21 <trigone> selinux?
17:53:41 <mniip> where there are various actions, and usage of any such action taints the monad
17:53:57 <trigone> jared-w: how would you parameterize "delete file" to prevent its use anywhere an IO-like operation is allowed?
17:54:10 <trigone> what's selinux?
17:54:33 <jared-w> selinux is a security module for linux 
17:55:00 <trigone> the possibility of reducing the scope of "visible" DSL at will could really make things cool i think...
17:55:29 <mniip> trigone, imagine something like
17:55:45 <trigone> jared-w: hm, so you'd use sudo to call specific operations :P lol it's not too absurd... but not sure it's implementable
17:55:46 <jared-w> trigone: rather than making delete file have some IO () type, make it have IO Removal or something like that. You can't mix IO Removal with IO ListDir with IO Create, etc
17:56:17 <trigone> jared-w: well with (>>) in theory i can squeeze IO Removal before any single operation i want...
17:56:36 <mniip> um
17:56:40 <mniip> sudo?
17:56:46 <mniip> that's not related to selinux at all
17:57:05 <mniip> and I meant the permission system
17:57:13 <jared-w> Those aren't really the types you want; that was just an overly simple explanation since I haven't actually written a type indexed DSL yet
17:57:15 <mniip> not the implementation of the limiting bits
17:57:25 <trigone> say i have listDir :: IO [String], and an idiot writes evilListDir = listDir >>= \list -> deleteFileList list >> pure list. the typechecker will be happy with that still
17:57:35 <mniip> trigone, imagine this
17:57:40 <mniip> data Action :: *; data LimitedIO :: [Action] -> *
17:57:45 <mniip> no wait
17:57:47 <mniip> data Action :: *; data LimitedIO :: [Action] -> * -> *
17:57:49 <trigone> mniip: no, maybe not, it was just superficial connection of ideas...
17:57:52 <mniip> then
17:58:19 <mniip> deleteFile :: (Elem Delete l) => FilePath -> LimitedIO l a
17:58:59 <mniip> listDir :: (Elem OpenDir l, Elem ReadDir l) => LimitedIO l a
17:59:18 <mniip> judging by absence of Delete in listdir's constraints you derive that it cannot use deleteFile
17:59:34 <trigone> mniip: yeah, that was one solution i had thought earlier... the trouble is handling the content of `l` when you have many different contexts... and you have to put contexts everywhere which sucks in my opinion...
17:59:37 <mniip> also I missed  FilePath there but nevertheless
17:59:44 <mniip> well
17:59:47 <mniip> Eff does that iirc
17:59:57 <trigone> (but i know it's mostly psychological)
17:59:58 <mniip> the only other way is your own monad typeclass
18:00:01 <trigone> what's iirc?
18:00:08 <mniip> If I Recal Correctly
18:00:14 <trigone> ha ok ^^
18:01:03 * dramforever thinks that these LimitedIO/Eff stuffs are pretty close to useless
18:01:10 <trigone> the ideal would be, creating aliases for combinations of constraints (a kind of typeclass synonym). is it dooable?
18:02:27 <dramforever> Maybe you can have type LIO e a = forall effs. (Subset e effs) => LimitedIO effs a
18:02:29 <trigone> dramforever: if you had to choose, would you prefer a button to trigger the light on/off, or a supercomputer connected to missiles which you could launch if you do the wrong thing when trying to switch the light on?
18:02:53 <trigone> oh you mean as method of control, my bad
18:03:27 <dramforever> I prefer a supercomputer *and* a button to trigger light on/off *and* a missiles switch
18:03:32 <trigone> i'm not sure to understand your example...
18:03:40 <dramforever> not any 2 or three combined
18:03:51 --- mode: ChanServ set +o lambdabot
18:03:56 <dramforever> (I like that '2 or 3')
18:04:01 --- mode: ChanServ set -o lambdabot
18:04:04 --- mode: ChanServ set +o dibblego
18:04:10 --- mode: dibblego set +q lambdabot!*@*
18:04:16 <trigone> dramforever: yeah but not all together. my point is, if i write a function to switch the light on, it'd be cool that it'd not typecheck if i do more than switching the light on (it's a convoluted, trivial exampleofc)
18:05:35 <trigone> basically, you'd tell to the compiler the extent of capabilities of each environment where your operations are used, so it checks that the right sets of operations are used (waiting for the day it can understand the intention directly :P)
18:05:53 <dramforever> Well
18:05:59 <mniip> what's up with lambdabot :o
18:06:03 <trigone> s/the the right sets/that only the right sets/
18:06:10 <trigone> > test
18:06:59 --- mode: dibblego set -q lambdabot!*@*
18:07:09 --- mode: dibblego set +q hackagebot!*@*
18:07:24 <trigone> dramforever: could you expand your LIO example?
18:08:20 <dramforever> Then you would write FilePath -> LIO [ReadDir] [FilePath]
18:08:49 <dramforever> Then you would write FilePath -> LIO '[ReadDir] [FilePath]
18:08:51 <MarcelineVQ> why the quiet on hackagebot? it doesn't spam anymore
18:09:23 <trigone> dramforever: yeah it's the method that seems the most used around...
18:09:30 <dramforever> Yup
18:09:40 <mniip> dramforever, that requires your own monad
18:10:06 <trigone> mniip: what do you mean by your own monad? by contrast with what?
18:10:40 <mniip> by contrast with the Prelude.Monad typeclass
18:11:01 <mniip> sometimes you will want to >>= LIOs with differnt lists of effects
18:11:07 <mniip> which Monad will not allows
18:11:09 <mniip> which Monad will not allow
18:11:36 <trigone> what part of IO do you have access in an empty module which does not import anything, not even Prelude?
18:11:54 <dramforever> mniip: wait...
18:11:56 <trigone> mniip: hmmm...
18:12:04 <mniip> trigone, you can hang the processor and/or consume memory
18:12:19 <dramforever> type LIO effs a = forall e. (Subset effs e) => MniipLimitedIO e a
18:12:27 <trigone> mniip: just answer the question directly please ^^
18:12:27 <boj> trigone: i envy whatever it is you do that lets you sit in here all day asking these questions, lol
18:12:34 <dramforever> mniip: Does that require my one monad?
18:12:41 <trigone> boj: not sure how i'm supposed to take it
18:12:50 <boj> truly envious
18:12:50 <mniip> trigone, other than that nothing
18:13:11 <mniip> there's nothing in haskell or lambda calculus at all that can limit memory or cpu usage
18:13:17 <mniip> boj, hmm?
18:13:26 <mniip> boj, is your experience different?
18:14:00 <trigone> mniip: so, if you make custom careful imports for each module, you can control the extent of the power of each function, right? the only issue is ofc, there's no way to ask the compiler to check if too much has been imported...
18:14:54 <VitorCBSB> Hello everyone.
18:14:56 <boj> not really. maybe i've hindered myself by not asking as many questions as i should have
18:15:08 <VitorCBSB> Any Intero devs available?
18:15:22 <trigone> the ideal would be to be able to describe the kind of power for each module with a DSL, and that'd be translated into a haskell list of imports ^^
18:17:45 <boj> trigone: i was just noting that when i glance at my irc window throughout the day it's been you asking a lot of interesting questions. was curious what you actually do
18:19:08 * dramforever finds it easier to work with if the vast majority of my functoins dno't need to talk to anything outside
18:19:22 <dramforever> FS, stdio, whatever
18:19:33 <dramforever> I find things much easier to manage that way
18:19:36 <trigone> boj: what prompted your question answers it
18:20:16 <dramforever> Then your select few functions would use so much of available permissions that LimitedIO hardly matters anymore
18:20:26 <boj> trigone: so a.. phd student?
18:20:44 <trigone> dramforever: yeah. power control is one of the most important aspects of structuring programs... even in haskell, arguably, it's not easy to truly control thing as much as we could want...
18:21:24 <mniip> boj, I remember asking similar interesting questions in here back when I was in HS/early undergrad
18:21:42 <trigone> boj: lol no, officially i only did one year of computer science university
18:22:04 <trigone> it's not like you need anything beside a computer to learn haskell (and a lot of time)
18:22:07 <boj> was just genuinely curious :)
18:22:13 <boj> agreed
18:22:20 <mniip> you do need a lot of literature
18:22:40 <mniip> haskell is not limited to the syntax and the base package
18:22:50 <mniip> you also get to learn the myriad of cool functional tricks
18:22:58 <mniip> e.g profunctor optics
18:23:03 <trigone> mniip: obviously, i meant the resources are out there on the net
18:23:07 --- mode: dibblego set -q hackagebot!*@*
18:23:21 <trigone> in short, you don't need a university to learn haskell
18:24:18 <boj> or a relevant one at least
18:24:28 <trigone> and most of them don't seem to even remotely facilitate learning the subject. mine will teach me Java, Python, a teensy bit of OCaml, and a bit of C...
18:24:31 * boj holds up his art degree
18:25:02 <mniip> trigone, like that's a bad thing
18:25:23 <trigone> mniip: why is that not?
18:25:44 <mniip> um, there is nothing inherently evil in java or python
18:25:46 <boj> you still learn fundamentals. learning is never bad
18:25:49 <trigone> though i do agree, if haskell were more popular, it could end up "too successful"
18:25:50 <mniip> they're good languages worth learning as well
18:26:24 <mniip> I relearned java recently and understood it isn't as bad as I saw on the first glance
18:26:42 <boj> learn a non-haskell language so you can appreciate haskell that much more :)
18:27:05 <mniip> see I learned C++ before java, and OOP had that feeling of being not really necessary
18:27:30 <mniip> in java everything is a class and problems are solved differently, as you can't step away from the OOP
18:27:38 <trigone> mniip: technically the syllabus barely scratches the surface of either... and sure maybe it's not that bad... but to be honest i'm an abstraction-addict and i just don't have the patience to dive in depth into code which would be unmanageable without a huge IDE and tons of plugins and so on...
18:27:40 <mniip> there's a lot of quite interesting insights into that
18:28:01 <mniip> just like we have category theory concepts used in haskell they have OOP design patterns
18:28:11 <sphinxo> say I have two maps
18:28:11 <trigone> boj: haskell isn't my first language, though it's the first i actually enjoyed coding with
18:28:32 <sphinxo> how do I get values that are unique to the maps and are not common
18:28:45 <boj> trigone: i took a handful of CS courses. i think learning Big O, how assembler worked, how memory addresses worked, basic language terminology, etc. was useful. i don't use pascal/c++ at all, but i got a bit of out it
18:28:50 <mniip> sphinxo, Data.Map.Map?
18:28:52 <boj> trigone: same here
18:28:56 <trigone> mniip: but you don't have laws or formal definitions... that means things are kinda fuzzy around...
18:29:14 <sphinxo> mniip: so intersection a b, and intersection b a ?
18:29:17 <mniip> you have informal laws
18:29:23 <mniip> sphinxo, no, that's a question
18:29:31 <mniip> what "two maps" do you have
18:29:40 <trigone> boj: didn't say cs university was shit, far from it, but the programming part is lacking in (pure) functional programming
18:29:43 <sphinxo> two Map.Map Key Value
18:29:58 <mniip> so, Data.Map.Map?
18:30:00 <sphinxo> yeah
18:30:14 <boj> trigone: no disagreements there
18:30:59 <mniip> sphinxo, I'm thinking of merge
18:32:00 * hackagebot papa 0.3.0, papa-base 0.3.0, papa-base-export 0.3.0, papa-base-implement 0.3.0, … and 4 more
18:32:00 * hackagebot  → https://hackage.haskell.org/packages/recent
18:32:28 <sphinxo> is it ok to use .Internal ?
18:32:39 <mniip> anything based on inserting the elements one by one is going to be slow
18:33:14 <mniip> maybe, you could  union (difference a b) (difference b a)
18:33:42 <trigone> i'm wondering if metaprogramming wouldn't be a good path to the problem of controlling the power in the program in a fined grained manner
18:33:42 <mniip> should be roughly linera
18:34:06 <sphinxo> hmm ok thanks
18:36:37 <mniip> alternatively...
18:37:07 <mniip> mapMaybe id $ unionWith (\_ _ -> Nothing) (fmap Just a) (fmap Just b)
18:37:38 <mniip> but I like the other one better
18:38:33 <trigone> mniip: you meant, removing all common elements and merging the resulting maps? (just out of curiosity)
18:39:04 <mniip> that's what sphinxo asked for, if I read correctly
18:39:12 <cobreadmonster> any advice on implementing numerics in Haskell?
18:39:17 <trigone> k
18:39:18 <mniip> numerics?
18:39:22 <cobreadmonster> I don't know what functional machine learning would look like, for instance.
18:39:31 <cobreadmonster> mniip: Yeah, how would you implement an SVM?
18:40:25 <Zowlyfon> I know Haskell has bindings to Tensorflow if thats useful
18:40:51 <mniip> sadly I have no idea what that is
18:40:53 <moet> does anybody know how to use `using` from the managed package?
18:41:23 <mniip> reading the wikipedia article doesn't introduce me to any technical difficulties related to implementing one
18:42:21 <koz_> cobreadmonster: We can totally have mutable state in Haskell.
18:42:25 <koz_> Using State or ST.
18:42:32 <koz_> So I don't see the obstacle either.
18:42:37 <cobreadmonster> koz_: Sure, it's not that.
18:42:45 <cobreadmonster> But it's more a question of best practices and so on.
18:43:07 <koz_> cobreadmonster: Define 'best practices' in this instance.
18:43:12 <koz_> I'm not really sure what you mean.
18:44:57 <mniip> cobreadmonster, using an existing matrix/vector munching library so that your hands don't get dirty with handwritten unboxed io?
18:45:04 <mniip> that's about all I can suggest
18:46:44 <sphinxo> given a Map.Map Key (Maybe Value) what's the best way to get to Map.Map Key Value
18:47:03 <sphinxo> mapMaybe id?
18:47:08 <mniip> yes
18:47:23 <sphinxo> coolio
18:48:32 <HallaSurvivor> Has anyone else had trouble getting neco-ghc to recognize modules installed via stack?
18:54:34 <moet> i'm trying to use StateT with Managed as it describes in the package docs
18:54:52 <moet> don't have a specific question yet, as i'm trying to figure out how to fit them together :P
18:55:01 <joe9> need help profiling this program, please?  http://svgur.com/s/2YU the functions taking the most time seem to be attoparsec internal functions. I am not sure what I am missing.
18:56:18 <kadoban> HallaSurvivor: "installed via stack" sounds a little suspicious. Are you depending on them in your project, in the .cabal file for instance?
18:57:15 <HallaSurvivor> No, I don't do anything that I would publish, so I haven't run `stack new` ever
18:57:30 <HallaSurvivor> I just use stack to install packages, and manage ghc versions
18:57:35 <joe9> garbage collection is taking more than 90% of the time.
18:58:03 <pacak> joe9: optimizations?
18:58:26 <joe9> pacak: does not help. this is with -O2.
18:58:30 <HallaSurvivor> kadoban: It seems like overkill, especially when Stack creates a bunch of files that seem unrelated to my one haskell script
18:58:49 <pacak> joe9: How are you reading your data?
18:58:58 <kadoban> HallaSurvivor: 'stack install' isn't really even for that, you're relying on kind of weird semi-side-effect behavior that those packages happen to be available in some instances. I'm not all that surprised if other tools don't see them.
18:59:17 <kadoban> HallaSurvivor: stack is unopinionated in that regard, you can just have a .cabal file and a stack.yaml somewhere
18:59:31 <joe9> pacak. ByteString.hGetSome <handle> 16384
18:59:52 <pacak> And how big is  your file?
18:59:55 <kadoban> HallaSurvivor: I'm not really sure how/why neco-ghc would even know you have a stack project and it should look for things "installed via stack" for instance.
19:00:04 <joe9> 500MB
19:00:06 <HallaSurvivor> kadoban: What is the intended setup, then? Because all the articles I've read for setting up stack seem to be geared towards big projects
19:00:08 <joe9> pacak ^^
19:00:36 <joe9> pacak, sorry 78M
19:01:00 <joe9> pacak: http://bpaste.net/show/16bbaa08063a
19:01:10 <pacak> Try heap profiling to see what's in memory. Try increasing read size up to 16Mb
19:01:35 <kadoban> HallaSurvivor: You could look at other templates, 'stack new' has a few. I don't know if it has a minimal one. If you're here in a while I'll try to write out what the minimal ones might be.
19:02:04 <kadoban> HallaSurvivor: You could also try stack's script interpreter thing, it's in the user guide. But I don't know if neco-ghc or other tools will know how to handle that.
19:02:20 <pacak>             3611 MB total memory in use (0 MB lost due to fragmentation) - this looks like a lot
19:02:25 <joe9> pacak: heap profiling with -h, correct? it shows a graph and I could not figure out the details
19:03:13 <HallaSurvivor> kadoban: I'll look into the script interpreter, and I'm going to be here for a few hours more if you don't mind
19:03:17 <pacak> joe9: What kind of data are you getting back from your parser?
19:03:49 <pacak> heap profiling - there are several different options. It would be interesting to look at producer and constructors.
19:06:36 <joe9> parser: http://bpaste.net/show/eec20eaf472f  ,  http://bpaste.net/show/e6fee812441d , if it helps.
19:08:12 <pacak> joe9: It does. What's BaseCode, Exchange, Day, SessionCode?
19:10:46 <pacak> joe9: Are fields of Price_2_8 strict?
19:11:10 <joe9> pacak, no.
19:11:19 <joe9> pacak, good idea.
19:12:53 <pacak> So there's no bytestrings there?
19:14:07 <joe9> pacak, not in Price_2_8. but, there is a bytestring in Message data structure
19:14:19 <joe9> I pm'ed you , if you feel like continuing the discussion there.
19:14:50 <pacak> I saw it.
19:15:52 <pacak> You might need Data.ByteString.copy
19:28:56 <moet> ah ok.. i think i see what's wrong with my code
19:30:20 <moet> http://lpaste.net/357562
19:31:05 <moet> most of the MonadManaged instance contexts require the underlying Monad to also be a MonadManaged, but IO isn't
19:31:08 <moet> :/
19:31:47 <moet> i guess i could fix it by adding runManaged somewhere maybe...
19:35:56 <moet> changing the underlying monad to Managed seems like it should work
19:36:52 <moet> but it forces me to no longer have a return value, strangely
19:39:26 <trigone> hi again, i was wondering: what are the main disadvantages, in all possible ways, of having great numbers of very very small modules?
19:39:56 <koz_> For the functor law 'fmap id x == id x', does this mean '== in terms of Eq'?
19:40:08 <erisco> koz_, no, it means functional equality
19:40:22 <pacak> trigone: Linking time. Maintaining your sanity.
19:40:31 <koz_> erisco: What does this mean exactly?
19:41:06 <trigone> pacak: how much can linking time be worsened?
19:41:53 <pacak> trigone: If you want optimizations and inlining between you modules you'll need to mark a bunch of stuff as inline/inlineable.
19:42:01 <pacak> That will increase size of interface files.
19:42:16 <erisco> koz_, well, there are a few ways you might interpret that law, but lets say  fmap id == id  instead
19:42:17 <trigone> koz_: well, a priori, "forall x, fmap id x == x" (something you can't compute in haskell, to my knowledge)
19:42:27 <pacak> Linking time is linear to number of modules
19:42:32 <erisco> koz_, so we are trying to determine if two functions are equivalent and that is not something Eq can do
19:42:39 <trigone> pacak: what? optimizations?
19:42:50 <koz_> erisco: OK, I see.
19:42:53 <koz_> Thanks!
19:42:55 <erisco> koz_, two functions are equivalent if they give equal output for equal input, for all inputs
19:43:02 <pacak> trigone: inlining and stuff.
19:43:15 <trigone> pacak: yes, what's the connection with having lots of modules?
19:43:17 <koz_> erisco: Extensional equality, right?
19:44:47 <pacak> To inline something you need to have it's definition aroud. For that stuff you inline into needs to be in the same file. Or original definition needs to be placed in interface file with INLINE/INLINEABLE.
19:44:57 <Cale> koz_: Or semantic equality -- we can associate mathematical values to all Haskell expressions (in such a way that evaluation preserves the value of an expression), and then regard equations like that as equations of the mathematical values.
19:44:58 <erisco> koz_, yes
19:45:26 <koz_> Cale and erisco: Thanks!
19:45:28 <trigone> pacak: oh... why does that limitation exist?
19:45:55 <pacak> trigone: How else would you implement it?
19:47:14 <trigone> pacak: dunno, i barely know about inlining... nvm. so, if i split too much between modules, it'll possibly/probably screw up performances?
19:47:27 <trigone> s/between/into many/
19:49:57 <pacak> Why do you want to do it in the first place?
19:50:16 <joe9> pacak: as an fyi, the initial results look very promising. I changed the parser return to return $!
19:50:45 <erisco> speaking of id, I was wondering if you could construct the identity functions
19:51:06 <HallaSurvivor> kadoban: I was able to get it! Don't worry about helping. Thanks, though! <3
19:51:07 <pacak> joe9: You have Maybes in your data, $! won't handle them.
19:51:12 <trigone> pacak: "power" control. it seems one of the only ways you can easily prevent a function from accessing anything of the outside of what you want it to know...
19:51:42 <trigone> > let myid x = x in myid 5
19:51:44 <lambdabot>  5
19:52:26 <joe9> pacak: What do I do about Maybe data types?
19:52:40 <trigone> erisco: see?
19:53:02 <pacak> joe9: Make sure it's strictly evaluated by your maybeInteger parser. Also consider using Int.
19:53:21 <joe9> pacak: ok, Thanks.
19:53:58 <erisco> trigone, what I mean to ask is if there is a finite set of inference rules to construct all identity functions
19:54:19 <trigone> what do you mean by many identity functions?
19:54:36 <erisco> all the ones that are intensionally distinct
19:54:57 <trigone> erisco: what's your definition of an identity function? i don't get it
19:57:49 <erisco> trigone, f : A → A is an identity function can be defined as ∀x:A. f x = x
19:58:14 <trigone> erisco: ok, give me another one?
19:58:24 <erisco> that describes all of them
19:59:20 <trigone> erisco: ok... well in haskell, if you define (myid :: a -> a), the polymorphism of the type signature allows you to use this one function for every single type and thus value
19:59:29 <trigone> no need for more than one
19:59:58 <erisco> a need is if you want to show a function is equivalent to the identity function... we just had such an example :P
20:00:01 <erisco> fmap id = id
20:00:14 <trigone> ooooh i get it
20:00:29 <erisco> but there are many, such as  subtract 1 . (+1)  for numbers
20:01:27 <erisco> so if you can construct all identity functions then you can show  fmap id = id  just by constructing  fmap id
20:01:31 <dolio> Well behaved numbers, at least.
20:01:48 <trigone> erisco: well my bad, and i have no idea if you can generate them out of nowhere... to start maybe you'd need a way to list all potential functions, and that... i don't see how it's possible...
20:01:56 <erisco> heheh, okay, for Integer... let me not get worried about Num
20:02:18 <erisco> enumerating all functions is easy
20:02:45 <trigone> erisco: hm, when you mean "constructing", you mean in fact, reducing "fmap id" to "id" by logical, provable steps
20:02:46 <erisco> that's just a matter of taking the function grammar and generating all the sentences in the language
20:03:01 <erisco> no, I mean arriving at fmap id from logical, provable steps
20:03:48 <erisco> i.e. the only provable statements have the form "f is an identity function"
20:03:50 <dolio> For what functor?
20:04:26 <erisco> fmap has no definition until you choose a type, yes, so whatever type you're dealing with at the time
20:05:04 <trigone> not sure to follow you... the issue is, you can more or less write any very badly-behaved fmap as you want... that's the crucial issue with typeclasses in haskell, they don't force you to follow the intended rules. by itself, fmap is just a type signature, which thereafter is instanciated in many ways depending on the type...
20:05:36 <koz_> trigone: Type class laws aren't compiler-verifiable, yes.
20:05:51 <koz_> (unless you're jle` writing April Fool's jokes)
20:05:57 <trigone> koz_: that's what i said... right?
20:06:00 <koz_> (at least I think it was jle` who wrote that)
20:06:17 <trigone> koz_: jle` wrote what?
20:06:20 <koz_> trigone: erisco's point is that, every time we define a Functor, we have to make sure the laws are followed.
20:06:50 <koz_> trigone: I've lost the link, but someone recently did some deep Haskell magic to have the compiler verify the functor laws.
20:06:57 <koz_> (at least, I think that's what it was)
20:07:01 <trigone> koz_: well, yeah.... ykw, i don't get much of that conversation, and it doesn't matter to me, so i'll leave that to those who understand it :P
20:07:05 <koz_> (once it got into deep Haskell magic, I kinda glazed over)
20:07:06 <trigone> koz_: and that was a joke?
20:07:37 <koz_> trigone: I believe the exact article wording was 'an April Fool's joke that accidentally compiled'.
20:07:52 <trigone> koz_: lol i'll look into it later :)
20:08:26 <koz_> trigone: https://blog.jle.im/entry/verified-instances-in-haskell.html
20:08:38 <koz_> I'm almost 100% certain that this is jle`'s craft.
20:11:24 <trigone> koz_: that's way too high-level for me :P i'll put it in a corner, maybe one day i'll get what it means :)
20:13:58 <HallaSurvivor> Is there a canonical way to partially apply if/then/else?
20:14:07 <HallaSurvivor> say I want a function which takes a boolean and does one of two things
20:14:18 <HallaSurvivor> is there a better way than \b -> if b then e1 else e2
20:15:08 <erisco> trigone, you just have to understand singletons
20:15:25 <erisco> HallaSurvivor, yes, bool
20:15:33 <trigone> :t bool
20:15:35 <lambdabot> a -> a -> Bool -> a
20:16:15 <HallaSurvivor> erisco: Thanks a ton! In retrsospect, given maybe and either, that makes sense :P
20:16:28 <trigone> erisco: i think i'll understand singletons another day :P
20:17:28 * hackagebot pipes-interleave 1.1.2 – Interleave and merge streams of elements – https://hackage.haskell.org/package/pipes-interleave
20:18:31 <erisco> that we need an advisory not to use this code is the biggest problem with programming as a practice in my eyes...
20:21:46 <glguy> erisco: Advisory not to use which code?
20:21:57 <erisco> jle`'s
20:22:10 <erisco> see the link above from koz_ 
20:23:19 <glguy> thanks
20:30:34 <glguy> hexagoxel: I missed your comment earlier; NonEmpty was used in the first example
20:31:02 <erisco> that is a smart use of singletons... hadn't thought of it... possibly with a lot of TH magic you could clean it up
20:31:42 <erisco> just follow after Idris and have VerifiedFunctor, VerifiedApplicative, and so on
20:32:27 <geekosaur> ScarifiedFunctor
20:33:22 <erisco> but type class laws isn't where it stops, you could do the same for any function
20:34:03 <erisco> singletons does let you lift some function definitions but I have not tried it myself... not sure how complete it is
20:35:03 * hackagebot pipes-lzma 0.1.1.2 – LZMA compressors and decompressors for the Pipes package – https://hackage.haskell.org/package/pipes-lzma
20:35:03 * hackagebot pipes-s3 0.3.0.3 – A simple interface for streaming data to and from Amazon S3 – https://hackage.haskell.org/package/pipes-s3
20:49:00 <jle`> yeah that was me
20:49:21 <koz_> jle`: I thought so! Congrats on an awesome blog post.
20:49:24 <jle`> and yes it can be cleaned up with TH :)
20:49:57 <jle`> thanks!
20:50:10 <HallaSurvivor> I'm reading the protolude docs, and it mentions liftM is a common source of unexpected laziness
20:50:16 <HallaSurvivor> How is liftM unexpectedly lazy?
20:51:52 <glguy> Did you expect it to be lazy?
20:52:46 <HallaSurvivor> I expect most things to be lazy
20:53:14 <HallaSurvivor> But my guess is that liftM introduces extra laziness, and people wanting to be strict forget about it
20:53:33 <HallaSurvivor> because the intuitive way of implementing liftM would not add laziness there, but haskell intentionally made it lazier
20:53:35 <HallaSurvivor> bc haskell
20:53:37 <monochrom> What are you talking about?
20:53:45 <HallaSurvivor> though I came here to double check, or to be corrected. Cuz idk
20:53:51 <HallaSurvivor> monochrom: us?
20:54:02 <monochrom> Speak for yourself.
20:54:18 <HallaSurvivor> same
20:54:30 <glguy> > fmap undefined (Just undefined) `seq` ()
20:54:32 <lambdabot>  ()
20:54:37 <glguy> Perhaps that surprises someone
20:54:47 <HallaSurvivor> makes sense
20:54:58 <HallaSurvivor> I guess I've been doing this too long, haha
20:55:45 <erisco> I dare your to deepseq
20:56:14 <glguy> erisco: What would that show us?
20:57:14 * hackagebot html-parse 0.2.0.1 – A high-performance HTML tokenizer – https://hackage.haskell.org/package/html-parse
20:57:14 * hackagebot warc 1.0.1 – A parser for the Web Archive (WARC) format – https://hackage.haskell.org/package/warc
20:57:47 <erisco> glguy, an exception
20:58:12 <monochrom> Oh great tonight people prefer to make their points obtusely.
20:58:49 <chowie> #Haskell is by far the most active specific programming language channel on freenode
20:59:00 <chowie> Why is that?
20:59:30 <koz_> chowie: Haskell is awesome? :P
20:59:32 <jle`> good question
21:00:16 <chowie> I've been reading around about haskell after first noticing it near the top of the freenode channel list
21:00:33 <chowie> I'm still curious as to why it has such a relatively huge community.
21:00:36 <jle`> well
21:00:48 <jle`> it's a great language with a rich community
21:00:51 <jle`> but i wouldn't call it relatively huge
21:01:06 <jle`> cause like, relative to what?  python? ruby? java? javascript? c?
21:01:36 <chowie> you have 250 less users than python
21:01:49 <jle`> ah i'm talking about like, the community in general
21:01:51 <jle`> not just on freenode
21:01:51 <chowie> 750 more than javascript
21:01:57 <chowie> I'm just talking about freenode.
21:02:18 <jle`> ah.  yeah, the fact that haskell is disproportionately represented on freenode is kind of funny
21:02:29 <jle`> i think maybe the haskell irc is just one of the hubs of the greater haskell community
21:02:44 <jle`> but #python, #javascript, etc. aren't really hubs in the python or js community
21:02:52 <chowie> solid point
21:03:07 <erisco> those numbers are probably irrelevant... there is something like 97% or 98% of people here you could classify as idlers
21:03:08 <jle`> historically much of the development of the haskell community has revolved around the mailing lists and the freenode channel, so maybe that's why
21:03:46 <erisco> so first you need to establish that the proportion of idlers is similar between channels
21:04:06 <chowie> how old is haskell?
21:04:08 <jle`> a lot of the big movers in the haskell community often stop by the haskell freenode, but i'm not sure if it's the same as for python or js
21:04:15 <jle`> a little bit older than java i believe
21:04:28 <jle`> 1990
21:04:29 <chowie> woah really?
21:04:35 <chowie> I thought it was way younger.
21:04:44 <HallaSurvivor> monochrom: are you interested in why deepseq would raise an exception in the given case, whereas seq wouldn't?
21:05:00 <HallaSurvivor> monochrom: we aren't normally assholes, haha
21:05:14 <jle`> i know right
21:05:46 <jle`> well, there was a large resurgence in haskell in the greater programming community around like 2013-2016 kinda
21:05:53 <erisco> Miranda is the precursor ... first one I learned
21:05:54 <jle`> so a lot of people first learned about haskell then
21:05:58 <exio4> chowie: it has changed in the past 10 years than most languages have changed in their whole life
21:06:07 <exio4> more*
21:06:47 <erisco> the first spec for Haskell was 98
21:07:04 <HallaSurvivor> also jle`, that typeclass verification article was nuts O.o Hopefully one day I'll understand it all, haha
21:07:20 <Axman6> but Haskell is much older than Haskell 98
21:07:20 <jle`> erisco: haskell 1.0 was published in 1990?
21:07:24 <HallaSurvivor> Reall cool regardless! I'm a maths person, so all for formal verification
21:07:27 <jle`> you might be thinking of Haskell 98
21:07:31 <jle`> which is like the 98th version of haskell
21:07:43 <jle`> which happened to also be released in 1998
21:08:02 <jle`> HallaSurvivor: thanks :D
21:08:24 <jle`> i'm actually working on a singletons tutorial that should actually take readers to the point where my verification post becomes mundane, but much more slowly ha
21:08:43 <erisco> jle`, I don't know, I have not seen any published Haskell 1.0 document, but maybe that is locked away somewhere
21:08:56 <erisco> Haskell 98 is the earliest thing I have seen that specifies what the language is
21:09:08 <HallaSurvivor> jle`, if you can do that I'll love you even more than I already do
21:09:09 <geekosaur> reports back throiugh 1.2 are still on
21:09:43 <geekosaur> at least
21:09:52 <jle`> @google haskell 1.0
21:09:53 <lambdabot> https://www.haskell.org/definition/haskell-report-1.0.ps.gz
21:10:28 <jle`> haskell is eight months older than i am
21:10:41 <erisco> lol I guess Google is better than DDG at that search
21:10:51 <geekosaur> I was referring to the 1.4 report a couple times a week at one point for changes between it and '98
21:11:32 <jle`> i also always wonder how many people thought that haskell was an april fool's joke
21:12:30 <crucify_me> hi why does this work if compiled, but hang the ghci ? let ff :: [Char] -> [Char] -> Bool; ff = (==)    thanks
21:12:48 <jle`> crucify_me: maybe you have multiline input one?
21:12:54 <jle`> so if you press enter, it might be waiting for another line
21:13:13 <jle`> s/one/on
21:13:26 <crucify_me> sorry I thought the ';' took care of that
21:13:37 <jle`> try pressing enter again
21:13:48 <jle`> also i'd be surprised if that compiled in haskell source code
21:13:52 <jle`> unless you were in a do block
21:14:52 * hackagebot cmark-gfm 0.1.3 – Fast, accurate GitHub Flavored Markdown parser and renderer – https://hackage.haskell.org/package/cmark-gfm
21:14:52 <crucify_me> that exactly doesn't compile, but it does without the ';' on two separate lines jle` 
21:15:06 <jle`> even with the 'let' ?
21:15:16 <crucify_me> no  also without let
21:15:20 <jle`> ah ok
21:15:59 <crucify_me> sorry it accepts it in ghci, but it won't apply ie   > ff "Giraffe" "Pizza"
21:16:05 <crucify_me> it hangs there
21:17:06 <jle`> at this point i'm a bit confused at exactly what you wrote.  can you paste exactly what you typed?
21:17:10 <jle`> @where lpaste
21:17:10 <lambdabot> http://lpaste.net/
21:17:17 <crucify_me> sure
21:18:43 <crucify_me> http://lpaste.net/357564
21:20:22 <jle`> hm, seems to work for me
21:21:39 <crucify_me> dang thanks I never see it hang. usually I just get errors jle` 
21:23:12 <jle`> does...any other function work?
21:23:21 <crucify_me> weird after I restarted ghci it worked thanks for your help jle` 
21:23:24 <jle`> how about "Book" == "Seed" ?
21:23:27 <jle`> no problem heh
21:24:11 <crucify_me> jle`, hey have you ever watched the category theory videos of the physicist bartosz ?
21:24:19 <jle`> i've heard his articles
21:24:27 <jle`> but i haven't watched the videos
21:25:10 <crucify_me> It's really interesting how much that stuff looks like haskell. I really hope I can keep following it
21:25:37 <jle`> they're definitely fun :)
21:25:44 <crucify_me> thanks pax
21:25:59 <jle`> and yeah it's really neat how well-suited haskell is for describing a lot of the concepts
21:27:15 <crucify_me> jle`, I'm pretty giddy with excitement these days re: haskell.
21:27:41 <crucify_me> I seem to be getting it better than I ever did scheme lang
21:28:00 <jle`> i still feel the same way and i've been using haskell for years hah
21:28:10 <crucify_me> excellent
22:07:35 <jle`> hm, when did cabal.project files become a thing?
22:21:43 <ab9rf> heh
22:33:36 <eeasley> @pl \s l -> f s (l <> "x")
22:33:36 <lambdabot> (. (<> "x")) . f
22:34:13 <jle`> eeasley: \s -> f s . (<> "x")
22:48:41 <Marisa> Hey, what is the closest way to write forall (n :: Nat). Nat? Do I need some constraint to not break parametricity?
22:49:11 <jle`> what do you want forall (n :: Nat). Nat to even mean?
22:49:20 <jle`> are you using ScopedTypeVariables
22:49:23 <jle`> and TypeApplications
22:49:25 <srhb> There used to be a traverseInit in Data.List.Lens -- what's the alternative now?
22:49:27 <jle`> to refer to 'n' in a helper function?
22:49:32 <srhb> Probably something more generic over the traversal.
22:49:40 <Marisa> yes
22:49:47 <Marisa> I am doing datakind
22:49:57 <jle`> this isn't quite related to datakinds, though
22:50:00 <Marisa> and I want to get the n back to data level
22:50:21 <jle`> i'm not sure how to parse the type signature you wrote
22:50:23 <Marisa> that Nat is a ordinary data type lifted to kind via DataKind
22:50:34 <jle`> Nat doesn't have any inhabitants, though
22:50:39 <jle`> at the value level
22:50:48 <jle`> oh, sorry
22:50:51 <jle`> what Nat are you talking about?
22:50:53 <Marisa> I am not using singleton
22:50:58 <Marisa> ordinary peano
22:51:03 <Marisa> lifted via datakind
22:51:40 <nesqi> Is Data.Sequence the right tool for streaming data?
22:52:02 <jle`> oh, do you want `f :: forall (n :: Nat). Nat` to be a function where `f @'Z` is Z?
22:52:07 <Marisa> yes
22:52:07 <jle`> nesqi: no
22:52:21 <jle`> ah.  yes it's not quite possible, because of type erasure
22:52:21 <nesqi> I'm looking for something to replace my lists so that I can stream the data instead
22:52:31 <Marisa> so I need a constranit
22:52:37 <jle`> nesqi: lists are the natural type for streaming data
22:52:42 <jle`> they are optimized for streaming
22:52:52 <Marisa> like forall (n :: Nat). NatCon n => n
22:52:55 <jle`> Marisa: a constraint, or a singleton
22:52:57 <jle`> equivalent
22:53:18 <jle`> i prefer working with singletons here because they're just normal first-class values
22:53:31 <jle`> constraints in haskell are always magic
22:53:49 <Marisa> Isnt con also first class with Data.Constraint?
22:54:08 <jle`> and you probably meant forall (n :: Nat). NatCon n => Nat
22:54:13 <srhb> ah, _init . traverse, probably...
22:54:32 <Marisa> yes, my back
22:54:37 <jle`> Marisa: using Data.Constraint, you basically get the same thing as using singletons
22:55:01 <jle`> by turning your NatCon n constraint into a value witnessing that constraint, you're essentially re-implementing singletons in a roundabout way
22:55:50 <jle`> you can also use singletons to implement your constraint, so the two methods are interchangeable in power, pretty much
22:56:13 <Marisa> Ooh, nice, I had been using Data.Con quite a few time, but never really do singleton, I'll look at the source code and see the link between the two :)
22:56:22 <jle`> i'm not talking about the singletons library, by the way
22:56:29 <nesqi> ok.. so. I have a Parsec parser I use to read two imputs. I then compare the inputs and output a diff. (like the unix command diff) but it feels like since I'm using lists I don't stream the inputs but instead read the whole input and then pass over it. Maybe I do stream since it's all layzy but I cant realy tell. 
22:56:32 <jle`> i'm talking about the singleton concept/design pattern
22:56:50 <jle`> the singletons library is just machinery to make the design pattern easy to use and unites it across different kinds
22:57:13 <nesqi> I'm a making any sense? 
22:57:16 <Marisa> That's nice, I get the singleton design pattern (but not the library)
22:57:34 <jle`> ah, if you understand singletons but not the library, then the documentation for the library is perfect
22:57:42 <jle`> especially the README
22:58:04 <Marisa> Ooh, which I always skip, lol. Thx for the char*
22:58:11 <jle`> np :)
22:58:48 <jle`> nesqi: it doesn't necessarily have to be lazy
22:58:55 <jle`> but Seq is much worse than list at consecutive unconsing
22:59:54 <jle`> hm, actually, the docs say that uncosing is O(1), but there is probably a much higher constant-time overhead than for lists
23:00:17 <jle`> consecutive unconsing of lists is pretty much the cheapest thing imaginable in haskell
23:00:37 <jle`> (that's a bit of a hyperbole, but)
23:01:07 <Marisa> BTW, I dont know if this is appropriate or not, but GHC with all the LanguageExtension, adhocness(baking monad, list comprehension, ($), overloaded literal in) is a magnificent beast (IMO even more complex than C++/Scala, or Algol 68, knowing a little bit of all those). Do Haskell suffer and collapse from complexity just like "Emperor's old cloth" mention? Or how does it not?
23:02:14 <nesqi> ok? I'm more thinking I should choose a data-structure that limits me to only process the input in a sequential way. That way I can ensure the program will Parse the data lazily and will not end up parsing the whole thing before going to the next step.
23:02:33 <jle`> GHC has become a behemoth and is a bit infamous for being opaque/difficult for new contributors to get into, but there has been a lot of self-reflection and intenitional improvement to that over the past year or so, heh
23:02:41 <jle`> nesqi: lists are that data structure
23:02:47 <jle`> lists can only be processed in a sequential way
23:03:00 <nesqi> Currently I have been fiddeling with changing foldr with foldl back an forth to get better runtime but it's all so confusing.
23:03:03 <jle`> Seq can be processed from both sides, but the only way to do anything with any items in a list is to pop them off one by one
23:04:40 <Marisa> jle`, is there some ticket that I can look at, on making GHC more modular?
23:04:52 <nesqi> It feels like if I mix foldl and foldr on the input it will have to parse everything before going to the next step or am I wrong? 
23:05:52 <jle`> Marisa: i remember this last year https://ghc.haskell.org/trac/ghc/blog/ContributingToGhc
23:06:03 <jle`> nesqi: i'm not sure what you mean by mixing foldl and foldr
23:07:18 <nesqi> After parsing the inputdata I pass over it to analyze it. These analysis functions use foldr and foldl.
23:10:22 <nesqi> ouput result $ removeStuff $ groupThings $ parse input, where removeStuff and groupThings could either be using foldr or foldl
23:10:36 <nesqi> outputResult *
23:11:55 <jle`> could you do it in one pass?
23:15:03 <nesqi> That would probably get a bit messy
23:16:12 <jle`> you can combine foldl's with the foldl library, maybe, to make it easier to write
23:16:14 <jle`> hm
23:16:17 <jle`> it depends on what you're folding each time
23:22:08 <nesqi> Ah.. this is kind of confusing... reading https://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl
23:22:32 <nesqi> I go over the code again I try to reason about it.
23:22:41 <nesqi> and keeping the lists
23:23:05 <nesqi> I'll*
23:27:03 <quchen> Tail recursion isn’t very meaningful in Haskell.
23:27:39 <quchen> It’s something people are obsessed with in other languages because its absence breaks their functional-style code, but in fact GHC does not handle tail recursion at all.
23:27:48 <quchen> Instead, it uses an evaluation model in which tail recursion is meaningless.
23:28:38 <quchen> Sometimes, writing code in tail recursive style leads to better code, but it’s not because it’s tail recursive, but because that style happens to match GHC’s evaluation well.
23:29:10 <quchen> (Replace »Haskell« with »GHC/Haskell«; Haskell-the-standard does not specify this, I think)
23:31:06 <quchen> Tail recursion is for languages where you have a function call stack: when you call a function, you have to remember »where to jump back to«.
23:31:21 <quchen> Tail recursion allows optimizing this backjump away.
23:31:54 <quchen> GHC on the other hand jumps into functions, but never out of it – there is no way to return from a function. Hence, there is no need to have a function call stack, hence we don’t need tail recursion.
23:32:15 <quchen> Instead, GHC has a »pattern match stack«; the stack grows on pattern matching (i.e. »case«).
23:33:20 <quchen> So if you don’t want the stack to grow, don’t case-match within case blocks; this has nothing to do with tail recursion per se. Sometimes, tail recursive code satisfies this property, leading to the wrong conclusion that tail recursion is important.
23:33:42 <piyush-kurur> quchen: is that not the push/enter model that you are describing
23:34:26 <quchen> Eval/apply handles function calls differently, but it’s not much different with respect to tail recursion.
23:34:43 <quchen> The main difference between the models is how partial application is handled
23:34:55 <piyush-kurur> okey
23:35:01 <quchen> …I think ;-)
23:35:50 <piyush-kurur> my understanding is that in push enter model the call site needs not worry about the correct arity of the function that is called
23:36:07 <piyush-kurur> it is the job of the function to pick up necessary args from stack
23:36:54 <piyush-kurur> In eval apply the burden is on the all site not the called function
23:36:55 <quchen> Yeah, the heap stores PAP (partial application) frames instead of argument frames in eval/apply
23:37:34 <quchen> But still it doesn’t need to jump back to things, unless you have a program that supplies a function with infinitely many arguments to give you a PAP overflow, but I doubt that’s a program that could ever typecheck
23:37:44 <quchen> nesqi: By the way, the above was for you :-þ
23:38:08 <nesqi> quchen: that much I understood  =)
23:38:50 <quchen> FWIW I used Haskell for 4 years and was a bit surprised that GHC does not do tail recursion optimization
23:39:18 <quchen> But then again it also evaluates a functional language in which you cannot nest functions like f(g(x))
23:39:38 <quchen> If you’re interested in how Haskell is run, I implemented an educational version of it here: https://github.com/quchen/stgi/
23:39:54 <Axman6> \it doesn't explicitly do tail call optiminsation because it's evaluation basically does that for free IIRC
23:40:02 <piyush-kurur> quchen nesqi : but foldl should be more efficient than than foldr had id not been for the laziness 
23:40:06 <quchen> Axman6: Exactly
23:40:33 <quchen> piyush-kurur: I think it’s because foldr fuses better with the list range generator.
23:40:49 <piyush-kurur> yeah that is probably the reason
23:40:51 <nesqi> quchen: I think I played with that before.
23:41:19 <nesqi> I remember some very nice video about it atleast.
23:41:20 <quchen> Maybe I should have clicked that stack overflow post before writing.
23:41:45 <quchen> Yes, there’s a video by an absurdly handsome, charming, knowledgeable, and most importantly humble individual about it.
23:42:16 <piyush-kurur> What I meant is that if you implement foldr and foldl as the recursion (with no fusion) then foldl will be more efficient as there is no need for the stack to grow (but for laziness)
23:42:21 <MarcelineVQ> I don't recall making a vid
23:42:48 <nesqi> who could it be
23:43:28 <piyush-kurur> quchen: so humble that he hid that fact?
23:43:37 <quchen> piyush-kurur: Quite the opposite! Summing a list the naive way with foldr is better than with foldl, because foldr will only blow up your stack, while foldl will first blow up your heap and then your stack!
23:44:07 <piyush-kurur> quchen: what I meant is if you did not have laziness
23:44:26 <quchen> Ah, yes.
23:44:36 <piyush-kurur> you will not blow up the stack
23:44:49 <nesqi> and what about foldl'
23:44:56 <quchen> On the other hand, you’ll have a hard time implementing »head« with »foldl«
23:45:08 <piyush-kurur> foldl' is exactly foldl but strict in its stuff
23:45:30 <piyush-kurur> so for things like sum it is better to use foldl' (+) 0 
23:45:39 <nesqi> Yeah but the heap should now blow up right?
23:45:59 <quchen> Nothing blows up when you use »foldl' (+) 0«, yes
23:46:03 <piyush-kurur> nesqi: heap blows up due to thunks 
23:46:25 <piyush-kurur> stack blows up due to recursion
23:46:31 <nesqi> exacly
23:46:55 <nesqi> foldl would produce allot of thunks while foldl' would not
23:47:01 <piyush-kurur> yes
23:47:07 <quchen> Stack blows up due to pattern matching, not because of recursion.
23:47:27 <piyush-kurur> okey yes in the push enter model
23:47:27 <quchen> If you recursively pattern match then the stack blows up, but it’s because of the patterns, not because of the recursion.
23:48:07 <piyush-kurur> quchen: not if you do the reduction immediately after
23:48:14 <piyush-kurur> that is the point
23:48:20 <quchen> Sure.
23:49:45 <piyush-kurur> The way I see foldl going about its business is this. it inspects its list argument if it is null it pushes the start value
23:49:46 <nesqi> ok.. so? what would a f look like that blows up the pattern stack compared to a f that doesn't in the expr, foldr f [] l
23:50:47 <nesqi> Maybe a bit to open question..
23:51:17 <piyush-kurur> when it matches the (x:xs) pattern it creats a thunk which has foldl f (f start x) xs and pushes to the stack
23:51:48 <piyush-kurur> so as far as I see there is no stack blow up in foldl only heap blockup (due to thunking)
23:52:06 <seafood> Can you have a non-profiled and profiled version of a package installed at the same time?
23:52:09 <quchen> nesqi: The difference between foldr and foldl is that foldr consumes a list and incrementally and lazily builds a list as it goes; foldl on the other hand never returns anything before it has traversed the entire list. You can implement »take« with »foldr«, but not with »foldl«, for example. foldl-take 4 [1..] would never terminate.
23:52:15 <quchen> seafood: Sure
23:52:35 <quchen> s/lazily builds a list/lazily builds a result/
23:52:51 <piyush-kurur> quchen: yes that is what I wanted to say
23:53:40 <quchen> seafood: *.o are Haskell object files, *.p_o are Haskell object files compiled with profiling enabled
23:54:06 <seafood> Great, thank you!
23:54:06 <piyush-kurur> If f is a lazy operation though (say a constructor) then foldl will just be incrementally building the data structure as more of it is forced
23:55:32 <piyush-kurur> Which is the best it (foldl) can do actually
23:56:04 <quchen> nesqi: It might help to mechanically (with your hands, pen and paper) calculate »fold[lr] (+) 0 [1,2,3]« and »fold[lr] (flip (:)) [] [1,2,3]«
23:56:20 <piyush-kurur> the problem is with something like + on forcing has to force the entire computation where all the thunks are generated and then reduced
23:56:23 <piyush-kurur> this is really bad
23:56:38 <quchen> Mechanically as in »don’t try to be smart about it, just use the definitions of fold[lr] repeatedly«
23:56:50 <quchen> When you have to think it’s not mechanical ;-)
23:57:31 <quchen> There are plenty of blog posts that do this for you, but I think doing it yourself is probably more teaching
23:57:40 <quchen> Oh, I made a mistake in the (:) fold above.
23:57:54 <quchen> foldl (flip (:)) [] [1,2,3]
23:57:59 * piyush-kurur nods in agreement
23:58:02 <quchen> foldr (:) [] [1,2,3]
23:58:17 <quchen> The flip is required for foldl, but not foldr.
23:59:07 <nesqi> Sounds like a plan
23:59:52 <quchen> If you run into problems just ask here.
