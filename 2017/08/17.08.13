00:04:16 <Myrl-saki> Does GHC have new error reporting? I'm getting messages with `line number | warning'
00:05:26 <cocreature> Myrl-saki: yes, 8.2 provides fancier error messages
00:06:43 <crucify_me> hello
00:07:13 <Myrl-saki> cocreature: Looks cool. :D
00:07:20 <Myrl-saki> I love it. 10/10.
00:11:34 <koz_> Could someone please tell me what on earth I'm missing here? http://lpaste.net/357644
00:12:12 <koz_> Sorry, just edited it to fix an obvious typo: http://lpaste.net/357644
00:13:14 <crucify_me>  3 WHAT
00:13:21 <crucify_me> sorry
00:13:37 <MarcelineVQ>  2 YEAH
00:13:57 <koz_> I am very confused. Are those line numbers?
00:14:11 <koz_> (this was a result of me refactoring many very similar definitions, by the way)
00:14:18 <crucify_me> no koz sorry trying to configure my chat client
00:14:24 <koz_> Wait, sorry, one more typo.
00:14:55 <koz_> I should not be doing pastes of my code when I'm a) full of water-braised fish and b) half asleep because of a).
00:15:02 <koz_> http://lpaste.net/357644 <-- should be typo-free.
00:15:13 <crucify_me> 3WHAT
00:21:35 <Myrl-saki> koz_: `forall a . (Eq a, Hashable a) => HS.HashSet a -> HS.HashSet a -> d`
00:21:40 <Myrl-saki> koz_: Wouldn't `a` leak?
00:21:46 <Myrl-saki> koz_: From here. `FooEq :: (Eq a, Hashable a) => HS.HashSet a -> Foo a`
00:22:06 <koz_> Myrl-saki: So I need to use 'forall z' or something?
00:22:50 <Myrl-saki> koz_: Remove the forall?
00:23:02 <koz_> Myrl-saki: That won't compile at all then.
00:23:19 <koz_> Also, which forall are you referring to?
00:23:41 <Myrl-saki> koz_: caseFoos :: (forall a . (Eq a, Hashable a) => HS.HashSet a -> HS.HashSet a -> d) 
00:24:09 <koz_> Yeah, that won't compile then.
00:24:53 <koz_> You need a higher-rank type there, because there's no guarantee that any given Foo will have Eq and Hashable elements, and combine has to work uniformly across both kinds of Foo.
00:25:29 <koz_> If d is fixed (I originally had it fixed to Foo of the type of the other two arguments), it compiles fine.
00:25:38 <koz_> But I wanna be able to return anything, not just another Foo.
00:28:05 <Myrl-saki> Ah.
00:28:36 <koz_> I get the feeling I got the higher-rank function type wrong somewhere there.
00:29:28 <cocreature> the problem is that you force someone to provide you with a function that given two hashsets for arbitrary as can always give you back a fixed type b
00:29:30 <cocreature> eh d
00:29:46 <Myrl-saki> koz_: I'll second that. (d ~ Foo a), yet a should only exist in that scope.
00:29:47 <cocreature> but the return type of `combine` depends on the `a`
00:29:50 <Myrl-saki> I think?
00:30:40 <koz_> cocreature: OK, so how should I write what I want to say?
00:30:52 <cocreature> koz_: I’m not sure what exactly you want to say tbh :)
00:30:54 <koz_> (specifically, how should caseFoos be typed?)
00:31:15 <koz_> cocreature: Basically, if at least one of the arguments is FooEq, handle using the first function given; otherwise, handle with the second function given.
00:31:27 <koz_> In both cases, you have to return the same type back.
00:31:48 <cocreature> koz_: maybe "caseFoos :: (forall a . (Eq a, Hashable a) => HS.HashSet a -> HS.HashSet a -> f a) -> ([c] -> [c] -> f c) -> Foo c -> Foo c -> f c"?
00:32:16 <koz_> cocreature: The 'f' means a higher-kinded type. But what if I wanted to do a Bool-returning query, for example?
00:32:53 <cocreature> koz_: use "Const Bool" for f
00:33:09 <koz_> Aaaaah.
00:33:11 <koz_> I see now.
00:33:13 <koz_> Thanks!
00:34:12 <koz_> This is what I get for trying to refactor.
00:34:34 <Myrl-saki> lol
00:35:42 <algebra_> cocreature: why first order type doesn't work but higher order do in this case?
00:36:11 <cocreature> algebra_: "f a" depends on a. if it’s just "d" it can’t depend on "a"
00:36:16 <algebra_> Ah sorry I got it
00:36:18 <algebra_> Yes
00:36:21 <algebra_> Missed that
00:37:08 <cocreature> koz_: fwiw if you actually only had queries that returned fixed types like `Bool` independent of `a` then your original type works just fine. the problem is that `doOne` does not have a fixed return type.
00:37:47 <koz_> Yeah, I understand that now.
00:37:59 <koz_> (I've also learned 'why Const is needed in places that aren't called Control.Lens)
00:38:44 <cocreature> `Const` is basically the generic version of “add a phantom type parameter to your type that is not used”
00:39:44 * hackagebot DeepDarkFantasy 0.2017.8.13 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
00:44:08 <parsnip> want to make a docker image thinner. i can remove .stack/?
00:44:28 <parsnip> how about /opt/ghc/
00:44:43 <cocreature> parsnip: depends on what you want the docker image for. do you want an image for building things or for running the executable that you built?
00:44:45 <MarcelineVQ> sure, if you use stack though it'll redownload hackage and ghc and whatever libs it needs next time it's run
00:45:52 <parsnip> it will be a base image, so i'll push thin image to hub
00:46:07 <cocreature> base image for what?
00:46:09 <parsnip> just running the executable
00:46:40 <cocreature> https://hub.docker.com/r/fpco/ubuntu-with-libgmp/ is a pretty minimal image for running haskell executables
00:47:15 <parsnip> https://hub.docker.com/r/bradyt/docker-hledger-install/~/dockerfile/
00:47:44 <cocreature> that sounds like the image is for building things, not for running them
00:48:17 <parsnip> it builds them, another dockerfile can use that as base to run them
00:49:12 <parsnip> trying to make the base thinner, not sure what i can safely delete... just experimenting with `rm` on a container now.
00:49:35 <cocreature> it doesn’t really make sense to base the image for running the executable on the one used for building it
00:49:52 <cocreature> you don’t need any of the build dependencies when you just want to run things
00:51:34 <parsnip> sure, i don't need the build dependencies. but i need to build it at some point, haskell executables don't fall out of the sky.
00:52:25 <cocreature> right, what I’m trying to say is that the image used for building should be separate from the one used to run things
00:52:48 <cocreature> either use docker’s multistage builds for separating this or stack’s builtin docker support
00:53:29 <parsnip> "separate". they are. the image for building will build it, and that is pushed as one image. another docker file will use that as base. am i misunderstanding "multistage"?
00:53:59 <cocreature> https://docs.docker.com/engine/userguide/eng-image/multistage-build/
00:54:27 <cocreature> the idea is to have a potentially large image for building things and then you just copy the build results to a new much smaller image
00:54:45 <cocreature> the build image is not the base for that smaller image
00:55:22 <parsnip> ah
00:55:51 <cocreature> so in your case, your existing dockerfile forms the build image and then you add a section at the end that creates an image for running things which copies the hledger executables and is based on the ubuntu-with-libgmp image or something like that
00:56:34 <parsnip> ah, sounds ideal
01:03:21 <parsnip> working on it, thank you for the tip
01:03:41 <cocreature> yw
01:24:28 * hackagebot zifter-stack 0.0.0.5 – zifter-stack – https://hackage.haskell.org/package/zifter-stack
01:28:04 <koz_> cocreature: I'm having similar issues again: http://lpaste.net/357644
01:30:24 <cocreature> koz_: I don’t think that example is the code you’re using to produce the error message. 1. you’re missing an import and 2. that Foldable instance will fail since "Foo a" is of the wrong kind
01:31:48 <cocreature> so please give me an example which allows me to reproduce the actual error :)
01:33:53 <koz_> cocreature: Wow, I must be tired. Here, that should be better: http://lpaste.net/357644
01:34:22 <cocreature> that’s still missing imports. do you even try to compile the examples? :)
01:35:03 <koz_> cocreature: Clearly not. Sorry, I'll do it properly this time.
01:35:20 <cocreature> and even if I add the imports, the things that the comments claim compile fail with an error
01:35:40 <cocreature> koz_: sorry if I’m sounding harsh, but I think trying to compile the examples before you ask people to look at it is not too much to ask
01:35:52 <koz_> cocreature: You're right, and I'm sorry - that's me being careless.
01:44:01 <koz_> cocreature: This should be right: http://lpaste.net/357644
01:45:33 <barrucadu> I'd guess it's because the first argument of `caseFoo` is too polymorphic.  The type signature says "`caseFoo` get to choose what the `a` in the `HashSet` is", but the way you're using it is "Here's the specific `a` I want".
01:45:46 <cocreature> koz_: the problem is that "HS.member x" doesn’t work for all HashSet a, it only works for those of type HashSet c, where c is the type of x
01:46:48 <koz_> cocreature and barrucadu: So how would I need to modify the signature for caseFoo not to have this issue?
01:51:08 <cocreature> koz_: change the signature to `caseFoo :: (Hashable c => HS.HashSet c -> f c) -> ([c] -> f c) -> Foo c -> f c`
01:51:42 <cocreature> koz_: but tbh I would question if what you’re doing here is really a good idea. ime these kind of existential constraints are usually not really helpful for anything
01:51:54 <koz_> cocreature: Yeah, I'm starting to think that too.
02:38:26 * hackagebot threepenny-editors 0.5.2 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
02:47:58 <tsahyt> is there a name for Applicative without pure?
02:48:10 <tsahyt> i.e. <*> exists, but pure shouldn't
02:50:35 * hackagebot tasty 0.11.2.4 – Modern and extensible testing framework – https://hackage.haskell.org/package/tasty
02:52:33 <barrucadu> tsahyt: I think I've seen it called "Apply"
02:53:03 <tsahyt> ahh I think I remember that one
02:53:06 <tsahyt> semigroupoids or something
02:53:20 <tsahyt> thanks
02:56:51 <tsahyt> @hoogle (f a -> f b) -> f (a -> b)
02:56:52 <lambdabot> Text.ParserCombinators.Incremental more :: (s -> Parser t s r) -> Parser t s r
02:56:52 <lambdabot> Control.Exception.Lifted mask :: MonadBaseControl IO m => ((forall a . m a -> m a) -> m b) -> m b
02:56:52 <lambdabot> Control.Exception.Lifted uninterruptibleMask :: MonadBaseControl IO m => ((forall a . m a -> m a) -> m b) -> m b
03:00:34 <c_wraith> tsahyt: that operation is going to be exceptionally rare to have a sensible implementation.  Like, it works for Identity or...  reader, I guess?
03:01:07 <erisco> works for functions
03:01:19 <tsahyt> c_wraith: it's an identity functor with a phantom parameter
03:01:34 <c_wraith> reader is functions :P
03:02:31 <erisco> nonempty lists, but it is strange
03:04:40 <tsahyt> c_wraith: does that operation have a name? I suppose it's dual to (<*>)
03:04:44 <tsahyt> coapply?
03:16:03 <Eduard_Munteanu> tsahyt, there aren't any coapplicatives in Hask, AFAIK
03:16:23 <tsahyt> no nontrivial ones iirc
03:16:40 <Eduard_Munteanu> Hm, possibly.
03:17:55 * hackagebot hsparql 0.3.5 – A SPARQL query generator and DSL, and a client to query a SPARQL server. – https://hackage.haskell.org/package/hsparql
03:24:00 * hackagebot hslua 0.7.0 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
04:49:30 <bbear> do you have 2D matrix in haskell ?
04:52:11 <LKoen> there are lists of lists, there is Data.Matrix, and you can use tuples to index an array
04:52:39 <bbear> IArray doesn't have a show instance ?
04:53:20 <bbear> > :t (Array.array (1,100) [(i, i*i) | i <- [1..100]])
04:53:22 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
04:53:36 <bbear> I have a problem with this because of type ambiguity
04:54:17 <LKoen> :t (Array.array (1,100) [(i, i*i) | i <- [1..100]])
04:54:19 <lambdabot> error:
04:54:19 <lambdabot>     Not in scope: ‘Array.array’
04:54:19 <lambdabot>     No module named ‘Array’ is imported.
04:54:27 <bbear> http://vpaste.net/ulNxf
04:55:42 <cheater> bbear: there's hmatrix
04:57:43 <bbear> you can't replace an element in place ?
04:57:50 <bbear> I mean a row or a column.
04:58:07 <cheater> why would you want that?
04:58:36 <bbear> you can't have matrix of chars as well
05:01:20 <bbear> but Why I cant work with IAray ?
05:01:28 <bbear> it is really really strange
05:03:17 <krokodil> Hey! Can somebody give me a non-trivial example of a Haskell Functor that is not faithful?
05:03:38 <krokodil> Maybe is not full, for example. fmap : (Int -> Int) -> (Maybe Int -> Maybe Int)
05:03:53 <bbear> yes
05:04:04 <krokodil> there is a function that maps Nothing to Just 1, Just x to Nothing, it has a type Maybe Int -> Maybe Int, but is not in the image of fmap
05:04:06 <bbear> I found it I have to give a type annotation
05:04:16 <krokodil> so Maybe can be seen as a non full functor
05:06:13 * hackagebot lambda-sampler 1.1 – Boltzmann sampler utilities for lambda calculus. – https://hackage.haskell.org/package/lambda-sampler
05:07:06 <krokodil> In any case, Constant is a trivial example of a non-faithful functor, am I right?
05:28:24 <Axman6> bbear: tried Repa?
05:28:33 <bbear> I just had a look, thanks.
05:28:54 <bbear> I was wondering if anything was close to matlab for matrix manipulation stuff.
05:30:03 <bbear> how do you deal with the various 'Ambiguous occurence 'this function'' ?
05:32:15 <mniip> where can I find an in-depth explanation of what Generic is/isn't?
05:32:56 <L30NCH0L0> HI
05:33:08 <L30NCH0L0> hi
05:33:42 <L30NCH0L0> yo?
05:33:49 <bbear> yo
05:33:55 <L30NCH0L0> whatup
05:34:00 <bbear> capslock nick name raises suspicion
05:34:02 <L30NCH0L0> none replying 
05:34:08 <bbear> suspicion confirmed
05:34:15 <L30NCH0L0> whatt
05:34:49 <L30NCH0L0> ?
05:34:50 <Clint> L30NCH0L0: it's just that you asked such a good haskell question, no one knows how to answer it properly
05:35:25 <L30NCH0L0> okay
05:36:32 <L30NCH0L0> hmm
05:39:30 <mniip> what's the point of the *->* kind of Rep? judging by the definitions of V1/U1/:+:/:*:/K1/M1 the p parameter isn't actually used anywhere or even restricted to a * kind
05:40:13 <L30NCH0L0> i dont know
05:41:56 <L30NCH0L0> hi?
05:42:00 <L30NCH0L0> anyone here ?
05:42:24 <Axman6> L30NCH0L0: do you have a question about Haskell
05:42:43 <L30NCH0L0> no i dont
05:42:55 <Axman6> do you want to discuss Haskell
05:43:15 <L30NCH0L0> what is haskell?
05:43:43 <L30NCH0L0> ??
05:43:55 <Axman6> it's a programming language. I'm curious why would would be here if you didn't know that though
05:44:27 <L30NCH0L0> just wanted to learn something new
05:44:43 <Axman6> @where learnhaskell
05:44:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
05:45:37 <L30NCH0L0> okay..
05:46:46 <Axman6> how did you even find this channel? we're quite happy to help you with all your haskell needs, but if you're not interested in Haskell this is probably the wrong place to be
05:47:23 <L30NCH0L0> i am interested
05:47:49 <Axman6> Hve you done any programming before? ("no" can actually be an advantage btw)
05:48:27 <L30NCH0L0> no im building a pc for learning next week
05:49:07 <Axman6> great. I think the channel #hardware is a good place to get help with that
05:49:14 <mniip> ##hardware 
05:49:20 <Axman6>  thanks
05:49:32 <Axman6> L30NCH0L0: have you used IRC before?
05:49:51 <L30NCH0L0> i know about hardware
05:50:24 <Axman6> sure, but IRC channels are good places to talk about things, as well as asking for help
05:50:57 <L30NCH0L0> hmm
05:52:21 <mniip> L30NCH0L0, yeah, this channel (#haskell) is a support channel for haskell, dedicated to haskell discussions. You ask a question - someone who knows will answer.
05:54:24 <Axman6> and they're gone
05:54:39 <mniip> oops
05:54:53 <Entroacceptor> f
05:54:58 <Axman6> g
05:57:47 <bbear> how can I get rid of ghc from my distro and get the fresh stuff from cabal/stack whichever is favoured in teh community ?
05:59:16 <mniip> bbear, just install it locally for your user?
05:59:30 <mniip> (I think stack does that by itself)
05:59:33 <bbear> ok, why is it recommended over install ghc from your distribution ?
05:59:41 <Axman6> installing stack will let you install ghc locally, so just install stack
05:59:44 <mniip> it is?
05:59:45 <bbear> mniip: yes, you are right. I just checked and stack install it.
06:00:41 <freddie-freeload> Hi! :) Is there any plan for ghci to have syntax highlighting?
06:01:28 <Axman6> none that I know of, but it used to be possible to pipe ghci through... something to get syntax highlighing
06:01:50 <Axman6> maybe hscolour?
06:02:29 <Axman6> there's https://hackage.haskell.org/package/ghci-pretty too, but it's several years old
06:03:25 <Axman6> there's also https://wiki.haskell.org/GHCi_in_colour
06:03:50 <freddie-freeload> Is there a strong argument against having syntax highlighting and colorful output per default?
06:05:57 <cheater> ghci outputs colored output by default already.
06:06:48 <alton9989> 1/join #vim
06:08:16 <bbear> someone is paying the bill for https://s3.amazonaws.com/hackage.fpcomplete.com/    ?
06:08:56 <bbear> i'm quite surprised a commercial cloud provider like amazon is used to host hackage.
06:09:32 <Axman6> why not?
06:09:56 <Axman6> S3 is very cheap
06:10:09 <bbear> because it's expensive and open source project don't have so much funding. Excepted if this is provided by amazon as some kind of sponsoring.
06:10:24 <Axman6> that bucket name suggests that it should be serving https://hackage.fpcomplete.com
06:10:33 <bbear> ok if it is cheap :)
06:11:13 <Axman6> it's probably a few hundred to maybe a few thousand a month, which is not very much for a commercial entity
06:11:29 <bbear> that's definitely not cheap imho
06:11:51 <bbear> if fpcomplete.com can pay the bill
06:11:52 <Axman6> it is when you compare it to the cost of people
06:12:09 <bbear> Axman6: yes, you mean a sys admin and a bunch of ftp servers.
06:12:18 <Axman6> this is fpcomplete's infrastructure - it's not hackage proper
06:13:22 <Axman6> https://www.fpcomplete.com/blog/2015/03/hackage-mirror (though it doesn't seem to be resolving at the moment)
06:17:55 <bbear> then ok
06:18:04 <bbear> I wonder what to do in my life now.
06:18:29 <Axman6> write more Haskell!
06:19:07 <bbear> It took me some days to really dig into C++ and it is still really complex to me. Java is nicer in some ways. Haskell is still hard but consistent. Python is python. I need to know more about Ruby, C#, Java and Scala, Go and Crystal.
06:19:20 <bbear> Then I'll be good to go ?
06:19:35 <Axman6> this does not sound like a good course of action to me
06:19:40 <bbear> yeah :)
06:19:47 <Axman6> "days" of C++ gets you maybe 2
06:19:49 <bbear> what do you suggest instead ?
06:20:03 <Axman6> 2% of what there is in C++ to learn
06:20:07 <bbear> oh yes.
06:20:09 <bbear> Surely
06:20:21 <Axman6> Spend some time actually learning a language in depth
06:20:55 <Tuplanolla> I always recommend SICP.
06:21:01 <Axman6> never heard of Crystal
06:21:02 <bbear> Thing is that language is kind of messy. Learning Haskell is much more rewarding that learning C++ on the long term due to the mathematical consistence of the language. It gives you hell of a backbone.
06:21:14 <bbear> Crystal is a statically typed, compiled version of Ruby.
06:21:18 <kuribas> SICP is great
06:21:20 <Axman6> Go is uninteresting in pretty uch every way
06:21:22 <bbear> I heard it is the new trend.
06:21:27 <Axman6> yeah SICP is nice
06:21:46 <bbear> Axman6: probably. But you can find jobs = nice plates of indian food with it.
06:21:52 <Axman6> particularly watching the lectures with the wizard intro
06:22:07 <Tuplanolla> It will teach you good taste. Then you can make a better-informed decision.
06:25:03 <bbear> how to be successful professionnally as a computer scientist is a question that bogs me a lot right now.
06:26:28 <lordcirth> bbear, as an IT person who works with CS grads, please learn basic IT skills, and where ever you go, befriend IT :)
06:26:45 <Axman6> Honestly, being good at Haskell is likely to be quite useful for professional developers in the next few years (how many no one can know) - all modern languages are adopting FP ideas, and there are few better FP languages because all the others have,a dn encourage the use of, escape hatches
06:27:40 <Axman6> I wish our IT people would learn basic IT skills :( when they dome to our desks and they see a mac or linux machine, they're all stumped about what to do
06:29:59 <Axman6> the latest C++now conference was filled with topics which felt like "my first FP programming experience" - lots of talk about immutable data, and even a 1.5h talk about how things are done in Haskell by Ryan Newton
06:31:46 <bbear> C++ is a little bit like frankenstein you know ?
06:31:55 <Axman6> very much so
06:32:32 <kuribas> bbear: a little? :)
06:33:25 <kuribas> bbear: knowing C++ is good if you want a C++ job, otherwise I'd just learn C.
06:34:59 <bbear> C++ is quite the Frankenstein creature actually
06:36:00 <bbear> but yeah, I learn it because of the reputation it has, and it was asked for some specific job offer I applied to. I don't know if C++ experts are common nowadays, because it takes a huge amount of knowledge to work efficiently with it I suppose.
06:37:10 <bbear> Again I may not be the best example as computer science is not my primary field of study, and I am not exactly aware of where I stand in the crowd of programmers (I suspect to be quite below average)
06:40:49 <kuribas> for a lot of jobs you don't need a major in CS
06:43:11 <`Guest00000> can GHC optimize code for processor types, like march/mtune in gcc?
06:46:20 * hackagebot hmatrix 0.18.1.0 – Numeric Linear Algebra – https://hackage.haskell.org/package/hmatrix
06:46:29 <Axman6> not unless you use the LLVM backend I would guess
06:47:22 <cheater> hi
06:47:27 <cheater> what exactly does the ~ mean here? apply :: (ApplyVex vf mf ve me ~ vr, ValidVex vr) => Fun vf mf -> Expr ve me -> Expr vr (ApplyMon mf me)
06:47:28 <`Guest00000> ok, which GHC is faster: one build with LLVM or one built with native GHC backend?
06:47:38 <`Guest00000> cheater: type equivalence
06:47:41 <`Guest00000> equality
06:48:44 <cheater> how is type equality defined?
06:49:11 <Axman6> `Guest00000: the answer to that isn't simple, but llvm is generally better for numerical code. it also takes a lot longer to compile when using llvm
06:49:28 <fendor> `Guest00000, you mean whcih ghc-backend is faster? It depends on the use case. LLVM takes a longer time to compile, but might be able to vectorize instructions. In general speaking, if you do not need explicitly more speed, it probably doesnt matter
06:49:31 <Axman6> cheater: if two types are equal, then the constraint is satisified
06:50:20 <carter> Axman6: pedantically it's that llvm does better bit fiddling and array optimization ;)
06:50:39 <Axman6> cheater: ApplyVex is probably a type family which returns a type when passed in those parameters, and that constraint says as long as vr is equal to the type returned by that type family, you can call the function
06:50:54 <`Guest00000> i mean
06:51:05 <`Guest00000> GHC built with which GHC backend
06:51:10 <`Guest00000> is faster
06:51:18 <carter> Oh.  They will be the same
06:51:31 <cheater> Axman6: thank you
06:51:31 <Axman6> carter: well, that too, but GHC doesn't do a whole lot of register scheduling, nor know a whole lot about machine dependent optimisations
06:51:41 <`Guest00000> okay
06:51:57 <carter> `Guest00000: if you measure please share
06:52:20 <`Guest00000> carter: i think i won't, too lazy
06:52:23 <carter> Axman6 let's collect some stats: which is better on no fib? Please share ;)
06:52:41 <`Guest00000> also, to properly measure will need to build a lot of things
06:52:47 <cheater> any idea why the result of this type family is 'Affine and not 'Const? https://github.com/cheater/hvx/blob/master/src/HVX/Internal/DCP.hs#L64
06:52:57 <cheater> it doesn't make much sense to me..
06:53:55 <Axman6> carter: this is why I said it's not an easy question to answer, iirc there's no clear winner
06:54:55 <carter> True :)
06:55:15 <fendor> hey guys, some kinda unusal question for this channel, i'm trying to measure the arithemtic intensity (FLOP per Byte) of my haskell progam, is this somehow possible, without estimation? 
06:55:18 <carter> I think it depends on the app.  Also ghcs low level rep trolls llvm
06:55:26 <Axman6> but when I want SIMD there's only one choice ;)
06:55:31 <carter> Fendor oo
06:55:48 <carter> A Axman6 .... I'll work on that sometime eventually
06:56:01 <carter> Fendor : count the ops in the source
06:56:31 <cheater> here is the DCP ruleset that this code implements, btw: https://github.com/cheater/hvx/blob/master/src/HVX/Internal/DCP.hs#L64
06:56:34 <cheater> err, sorry
06:56:42 <cheater> here: http://cvxr.com/cvx/doc/dcp.html
06:57:02 <fendor> carter, can i do this? i dont actually know how many bytes have been loaded,since i have no glue about the memory layout of a haskell program
06:57:28 <fendor> i can count the FLOPs, but can i somehow measure, how many bytes have been loaded, stored, etc? 
06:57:38 <carter> Oh.  Use perf tools on Linux or instruments on Mac
06:57:52 <Axman6> instruments is junk these days
06:57:59 <Axman6> they keep taking things away
06:58:13 <carter> Or hiding it in GUI stuff
06:58:15 <Axman6> I can't even figure out how to get the performance counter numbers any more
06:58:21 <carter> Hrmmm.
06:58:37 <Axman6> even in the gui, I have no idea how to get the numbers for any counter now
06:58:46 <carter> You can still use the underlying cli too right ?
06:58:53 <fendor> carter, i'm using perf for the hardware counters, but how can i measure the memory traffic for a program? would perf mem be helpful?
06:59:02 <carter> Idk ! :)
06:59:36 <fendor> Axman6, i used libpfm, and executed showevtinfo or something like that, then searched for floating point arithmetic ^^
07:00:28 <fendor> carter, ok :/ do you have an idea who i can ask? i cant find anything appropiate :(
07:06:45 <carter> There's info on the ghc wiki about the heap rep of data types if you wanna compute it that way
07:07:07 <carter> And you can look at the dump to file version of core to see the optimized data types
07:08:31 <carter> Usually for those flops per byte measurements you use the input data size rather than internal size
07:08:44 <carter> And I assume you know the size of your inputs
07:09:47 <fendor> carter, yes, you are right, this makes sense for the flops per byte. But i also need the memory traffic, for the roofline model, if you know that
07:10:56 <fendor> but i struggle to understand what i need exactly, therefore my questions are probably weird and incomplete
07:11:45 <fendor> i think, valgrind or haskell profiler might give me the needed answer
07:33:42 <MichaelBurge> Does it make sense to have a version of Set that doesn't require an Ord constraint, using System.Mem.StableName or similar?
07:33:58 <MichaelBurge> It seems like it could be a monad like list if you did that
07:36:43 <Tuplanolla> Would it also come without `Eq`, MichaelBurge?
07:36:50 <c_wraith> MichaelBurge: StableName just checks for the same in-memory value.  That seems very counter-productive for a set
07:37:35 <MichaelBurge> List doesn't have an Eq constraint either: It keeps track of elements by order of insertion, which some kind of fancy data structure could do for Set.
07:37:48 <c_wraith> MichaelBurge: especially since it doesn't even always work.  It can have false negatives - telling you two values are different when they're not
07:38:16 <MichaelBurge> I suppose you couldn't actually remove duplicates then, which makes it equivalent to list
07:39:34 <MichaelBurge> Is there a built-in compiler notion of "These two values are structurally and bitwise identical in memory"?
07:40:02 <MichaelBurge> I vaguely remember the "roles" feature tracking something like that
07:41:07 <c_wraith> the "representational" role says that changes in a particular type variable imply the representation of the type the variable belongs to has changed.
07:41:20 <c_wraith> But that's pretty far from what you're looking for
07:41:52 <c_wraith> It mostly has to do with preventing the generation of unsafe instance of Coerce, or unsafe use of GND
07:42:31 <butterthebuddha> https://imgur.com/a/nKBCb
07:42:36 <butterthebuddha> What does that syntax mean?
07:42:50 <c_wraith> butterthebuddha: why are you linking to code as an image?
07:42:57 <butterthebuddha> It's from a book
07:43:01 <butterthebuddha> I took a quick screenshot
07:43:16 <MichaelBurge> That syntax automatically creates type instances for types that satisfy the constraints.
07:43:20 <c_wraith> butterthebuddha: also, which part are you asking about?  The data declaration, or the instances?
07:43:24 <butterthebuddha> The instances
07:43:45 <butterthebuddha> I'm a little shaky on the typeclass concept 
07:43:48 <c_wraith> butterthebuddha: the data declaration is invalid haskell, provided just as an illustration that it could be defined that way if the syntax was different.
07:43:48 <butterthebuddha> So this is kind of confusing
07:45:19 <c_wraith> butterthebuddha: So, "instance (Eq a, Eq b) => Eq (a, b) where ..." can be read as "There is an instance of Eq for the type (a, b). Using it imposes an Eq requirement on the types `a' and `b'"
07:45:51 <c_wraith> butterthebuddha: you have to read them a bit backwards.  Start after the =>
07:46:05 <c_wraith> butterthebuddha: the part after the => tells you what instance is being defined
07:46:28 <c_wraith> butterthebuddha: the part before the => says what instances the definition requires
07:46:31 <rostero> I'm going through a haskell book and it says that * -> * (or list) is a higher-kinded type.  i thought that was just first-order type and that something like (* -> *) -> * was a higher-kinded type
07:47:12 <bbear> Sometimes, some code is really too hard to write in Haskell, due to the lack of mutable object.
07:47:17 <butterthebuddha> Ohh
07:47:25 <butterthebuddha> c_wraith: can you give some other examples of this syntax?
07:47:35 <bbear> Do you think it is justified to think like that ?
07:48:20 <c_wraith> rostero: I think in principle you're right, but the book is implying an additional context where you are using the list type constructor as an argument to something.  Perhaps as an instance declaration.
07:48:45 <rostero> correct that was the usage case
07:49:04 <rostero> they were talking about class Foldable (t :: * -> *) where ...
07:49:19 <c_wraith> rostero: In which case, if you enable the ConstraintKinds extension, you would see this as Foldable :: (* -> *) -> Constraint
07:49:46 <rostero> ohh.. thanks
07:51:05 <c_wraith> butterthebuddha: a lot of the time, they're basic pass-through instances that delegate everything to a contained type.  Like, the Sum and Product types from Data.Monoid have things like "instance Num a => Num (Sum a) where..", etc.
07:54:08 <c_wraith> butterthebuddha: Sometimes you use them to demonstrate that one concept is enough to fully power another concept.  "instance Monad m => Category (Kleisli m) where ...", for instance.  (Don't worry about what that one means for now.)
07:55:02 <c_wraith> bbear: Sometimes it's awkward.  But often it's not backbreaking.  Haskell supports truly mutable references in IO or ST, if you really need them.
07:56:58 <c_wraith> bbear: you end up with most things having a fine representation without mutable references, and most of the remainder working fine in IO or ST.  There are a few cases where it's truly awkward, like implementing the Union-Find algorithm.
07:58:26 <c_wraith> butterthebuddha: another common case is that you just have a recursive (at the type level) requirement.  This is what the examples you linked to are about.  Other examples would include things like "instance Eq a => Eq [a] where..." or "instance Read a => Read (Maybe a) where ..."
08:01:12 * hackagebot HaTeX 3.17.3.1 – The Haskell LaTeX library. – https://hackage.haskell.org/package/HaTeX
08:01:44 <c_wraith> butterthebuddha: Those are especially useful, as the compiler will do a recursive search to resolve them.  This is why, for example, "instance Show Int where ..." and "instance Show a => Show [a] where ..." are enough to provide Show instances for the types Int, [Int], [[Int]], [[[Int]]], [[[[Int]]]], and so on.
08:02:13 <MichaelBurge> It looks like this guy made Set a monad by deferring all the operations in a data structure until they can be run with the Ord constraint:
08:02:15 <MichaelBurge> https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/src/Data-Set-Monad.html#Set
08:02:27 <c_wraith> yeah, that's a well-known trick.
08:02:30 <MichaelBurge> I wonder if that's actually any more efficient than using List, and converting to Set at the end
08:02:43 <c_wraith> It's basically identical
08:03:08 <carter> Fendor : I'll have to look that up
08:03:46 <carter> Fendor for perf engineering #numerical-haskell might be a good focused channel though it's much quieter
08:04:11 <fendor> carter, ok, thanks, then i will ask my next question there, thanky you a lot!
08:07:18 <bbear> c_wraith: think about matrix access and update
08:07:34 <bbear> do you know of a Haskell module that allow to modify single elements ?
08:07:41 <c_wraith> bbear: hmatrix
08:08:43 <carter> Or vector. Or a bajillion others. Like array
08:28:32 * hackagebot http2-client 0.1.0.0 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
08:36:07 <ThatGuy__> has anyone been able to rename a cabal project file when using the stack build tool?
08:36:21 <ThatGuy__> I renamed mine and it keeps wanting the old name
08:37:08 <cocreature> ThatGuy__: have you renamed the file and the project name in that file?
08:37:21 <ThatGuy__> cocreature: yup
08:37:31 <ThatGuy__> i even remove the stack-work dir
08:37:48 <cocreature> please show us the exact error message
08:38:02 <cocreature> and the cabal file and your stack.yaml file
08:38:33 <ThatGuy__> cabal file path .... does not match the package name it defines
08:39:14 <ThatGuy__> the "name:" field in the cabal file matches the current name
08:39:27 <ThatGuy__> but it keeps wanting the old name
08:39:27 <sm> maybe you've got a package.yaml file as well ?
08:39:36 <ThatGuy__> I did a full grep for the old ref and none exist
08:39:48 <cocreature> I said "exact error message" for a reason. it’s easy to miss something so please just show us the full output
08:39:48 <ThatGuy__> sm: where is te package.yaml stored?
08:40:03 <ThatGuy__> thats what I thought as well, but could not find it
08:40:10 <sm> in the same directory. You'd know if you had one
08:41:38 <ThatGuy__> ahh got it finally, found one more ref
08:41:56 <ThatGuy__> thanks!
08:42:01 <sm> quack!
08:46:27 <kuribas> are typeclasses typed ducktyping?
08:47:57 <mniip> no
08:48:24 <cocreature> you need to explicitely make an instance
08:48:39 <xieyuheng> where is the source code of Prelude in this repo ? :: https://github.com/ghc/ghc 
08:48:42 <mniip> it's contravariant ducktyping
08:48:52 <mniip> xieyuheng, libraries/base
08:49:52 * hackagebot legion-discovery-client 0.2.0.1 – Client library for communicating with legion-discovery. – https://hackage.haskell.org/package/legion-discovery-client
08:49:52 * hackagebot sdl2-cairo 0.2 – Render with Cairo on SDL textures. – https://hackage.haskell.org/package/sdl2-cairo
08:50:18 <xieyuheng> thanks
08:56:51 * hackagebot http2-client 0.1.0.1 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
09:10:00 * hackagebot bindings-libg15 0.2.0.0 – Bindings to libg15 – https://hackage.haskell.org/package/bindings-libg15
09:23:11 * hackagebot slack-web 0.2.0 – Bindings for the Slack web API – https://hackage.haskell.org/package/slack-web
09:26:51 <codeshot> Is there an equivalent to sequence for (Functor f => [f a] -> f [a]? Or whenever that makes sense should I be able to define an applicative ?
09:28:48 <codeshot> My functor has no (pure) that I can convince myself is sensible
09:28:59 <codeshot> so sequenceA is out of the question
09:29:29 <cocreature> but you can implement a "pure' :: f []"?
09:29:29 <mniip> pure x = fmap (const x) $ sequenceF []
09:30:13 <codeshot> so there is a pure but I'm just not imagining it?
09:30:15 <mniip> f <*> x = fmap (\[Left f, Right x] -> f x) $ sequenceF [Left <$> f, Right <$> x]
09:30:20 <codeshot> or my type is not even a Functor?
09:30:51 <cocreature> hard to say without seeing your type :)
09:31:09 <cocreature> but mniip has shown you how to implement the Applicative instance using your sequenceF operation
09:31:31 <codeshot> I think I know my pure :)
09:31:32 <codeshot> thanks
09:31:47 <codeshot> if it's even a Functor
09:32:09 <mniip> a lot of things are functors
09:32:23 <codeshot> here's mine:
09:32:25 <codeshot> data Equiv content = Equiv   { merged :: content }
09:32:25 <codeshot>                    | Inequiv { left   :: content
09:32:25 <codeshot>                              , right  :: content
09:32:25 <codeshot>                              } deriving Show
09:32:32 <mniip> yup it's a functor
09:32:49 <cocreature> ghc should even be able to write the functor instance for you
09:32:54 <cocreature> if you enable DeriveFunctor
09:33:27 <codeshot> I'm building up a comparison functor that (when enhanced) tracks the sources of the values being compared through a functor of your choosing
09:34:09 <codeshot> using a "unify" operator (<^>). I will also write a USet type which doesn't let you query the presence of items (a bit FRPish)
09:35:07 <mniip> I think I know what an applicative instance might look like for this
09:35:45 <mniip> just need to figure out the laws
09:35:53 <codeshot> I'm hoping to get a system with a very general algebra that can report how it produced it's result (eg, parsers that report agreement and disagreement, calculators that report *how* a divide by zero came to happen
09:36:07 <mniip> hmm
09:36:17 <mniip> does anyone have applicative laws in terms of unit and ** handy
09:36:42 <mniip> it's just assoc and identity isn't it
09:36:56 <mniip> and distributivity of unit
09:37:08 <codeshot> mniip, is this something fundamental to my challenge?
09:37:31 <mniip> codeshot, yes I'm trying to figure out if the instance I have in mind is lawful
09:38:40 <mniip> ok, here goes
09:39:00 <codeshot> I think, to be useful, Equiv needs to become parameterised by a Monad to track its history and that monad will be used in the instance
09:39:14 <mniip> Inequiv f1 f2 <*> Inequiv x1 x2 = Inequiv (f1 x1) (f2 x2)
09:39:23 <mniip> Inequiv f1 f2 <*> Equiv x = Inequiv (f1 x) (f2 x)
09:39:25 <codeshot> otherwise it's a very basic thing like Maybe
09:39:34 <mniip> Equiv f <*> Inequiv x1 x2 = Inequiv (f x1) (f x2)
09:39:44 <mniip> Equiv f <*> Equiv x = Equiv (f x)
09:39:48 <mniip> pure = Equiv
09:39:51 <codeshot> yup
09:40:35 <codeshot> hm, but how can a correct (Inequiv f1 f2) ever arise?
09:40:42 <codeshot> functions cannot be compared in haskell
09:40:44 <mniip> by hand?
09:40:52 <mniip> by fmap?
09:41:25 <mniip> I mean nothing prevents me from saying (Inequiv (+3) (*5))
09:41:45 <codeshot> but you can also say Inequiv (+3) (+3) which is wrong
09:42:03 <codeshot> my type is unsound :(
09:42:14 <codeshot> <sob>
09:42:21 <codeshot> sosad
09:43:09 <codeshot> well, if I export only the instances and not the data constructors then it will be okay !
09:43:12 <dmwit> Never fear, `Finite` is here! `instance (Finite a, Eq b) => Eq (a -> b)` http://hackage.haskell.org/package/universe-1.0/docs/Data-Universe-Instances-Reverse.html
09:43:14 <codeshot> I think
09:43:15 <dmwit> ;-)
09:43:16 <mniip> oh you have invariants on your type?
09:43:38 <mniip> which in particular?
09:44:43 <codeshot> well, I have a class that returns this type from one of its methods, and that classes instances have invariants which should be reflected in the values of "Equiv a"
09:45:25 <mniip> which invarinats
09:46:13 <codeshot> I haven't decided them yet
09:46:45 <codeshot> But I'm sure I'll want to get into "behaviours when two things are not the same, which only work when they're not the same"
09:47:24 <codeshot> like for an Integer instance, a function might divide by x when you give it Inequiv x 0
09:47:41 <codeshot> but that'll be no good if you can construct an "Inequiv 0 0"
09:47:54 <mniip> well
09:47:57 <mniip> it's no functor then
09:48:02 <codeshot> oh I see
09:48:06 <mniip> you can always fmap (const 0)
09:48:15 <codeshot> indeed
09:49:21 <codeshot> I guess if I parameterise it with an invariants function then it can always test and become "Bottom" instead of Inequiv
09:49:57 <dmwit> Aha, finally found it!
09:50:03 <dmwit> https://stackoverflow.com/q/43684258/791604
09:50:19 <codeshot> Maybe I just have to avoid writing functions that are partial when given Inequiv
09:50:32 <dmwit> mniip, codeshot: You may like that SO answer I wrote some time ago.
09:50:53 <dmwit> It discusses two `Monad` instances for the type you guys are talking about.
09:51:12 <bbear> *** Exception: stack overflow \o/
09:51:22 <dmwit> The first one would give rise to mniip's Applicative instance, I think.
09:51:33 <mniip> not...really
09:51:39 <mniip> it has Equiv
09:51:46 <mniip> which is sort of like join Inequiv
09:52:00 <mniip> except Inequiv is whatsitcalled
09:52:23 <mniip> absorbing?
09:52:34 <dmwit> Are you saying "the first one would [not really] give rise to my Applicative" or is that "not really" replying to something else?
09:52:58 <mniip> dmwit, the types are slightly different
09:53:07 <dmwit> Only in name.
09:53:12 <mniip> I was certain of how the Pair applicative/monad works
09:53:24 <mniip> but the Equiv/Inequiv adsorption has been bugging me
09:53:25 <codeshot> dmwit, aha, so your nick isn't txt-speak for "dimwit" then !
09:53:29 <mniip> dmwit, no actually not
09:53:31 <codeshot> I've been misreading it
09:53:38 <dmwit> mniip: Are we looking at the same link?
09:53:41 <mniip> a*a versus a+a*a
09:54:01 <dmwit> data Foo a = Bar a | Baz a a -- ...is also a + a*a
09:54:02 <mniip> oh
09:54:04 <mniip> right
09:54:21 <mniip> I skimmed over it and saw the definition of Pair
09:54:23 <dmwit> codeshot: The "dimwit" reading is intentional. =)
09:55:42 <codeshot> I've also been reading something as "mi nip" ;)
09:56:18 <mniip> ugh
09:56:56 <mniip> I should just make a page about it just like that ggVGd guy
10:00:33 * hackagebot dhall-json 1.0.5 – Compile Dhall to JSON or YAML – https://hackage.haskell.org/package/dhall-json
10:08:48 <bbear> I think I encounter a performance problem.
10:08:52 <bbear> with haskell
10:09:06 <bbear> I have like a bunch of (1 + (1 + (1 + ...) )
10:09:15 <bbear> how do you solve this usually ?
10:09:26 <bbear> (I got a stack overflow by the way.
10:09:30 <dmwit> ETOO_VAGUE
10:09:52 <bbear> I think strict evaluation would help.
10:09:59 <bbear> But I am not sure how to do that.
10:10:22 <dmwit> I think posting a 5- to 10-line program which demonstrates the problem would help [us understand your problem].
10:11:22 * hackagebot cairo-canvas 0.1.0.0 – Simpler drawing API for Cairo. – https://hackage.haskell.org/package/cairo-canvas
10:12:12 <bbear> dmwit: I can't state the problem fully, but imagine that you have an infinite list of letters, and you want to count the number of 'e'. Then you write this http://vpaste.net/dV9vs ; imagine now that the number of 'e's in your string is huge. How do you prevent the recursion stack to go wild ?
10:13:03 <bbear> by the way, my actual code is here : http://vpaste.net/5bJO6 ; if you have some advices to work in (i'm solving advent of code problems, url : http://adventofcode.com/2016/day/9)
10:13:55 <mniip> bbear, rewrite the fold into an accumulation
10:13:59 <mniip> a strict accumulation
10:14:02 <bbear> I'm sure a more academic solution exists about my code, sorry I didn't found it (there is some kind of folding involved, i am not too much good with that)
10:14:16 <bbear> mniip: foldl' ?
10:14:21 <mniip> could work
10:14:26 <mniip> but you can write it by hand as well
10:14:28 <bbear> I am not sure I could do this.
10:14:35 <bbear> yes, how do you do by hand ?
10:14:41 <mniip> countE = go 0 where
10:14:46 <mniip>  go n [] = n
10:15:10 <mniip>  go n (x:xs) = if x == 'e' then let n' = n + 1 in go $! n' xs else go n xs
10:15:21 <bbear> ok, I see
10:15:28 <mniip> woops, make that "(go $! n') xs"
10:15:29 <bbear> so using a strict accumulation is often better.
10:15:39 <bbear> ok, I'll try that.
10:16:38 <bbear> I often do this by writing the first function without accumulator and writing a helper function doing the real work with an accumulator as the argument.
10:16:43 <mniip> oh woops
10:16:47 <bbear> Do you think it is a good practice ?
10:16:47 <mniip> you don't need that let at all
10:16:49 <mniip> I was overthinking
10:16:59 <bbear> mniip: don't worry, I 'll work out something :)
10:17:07 <mniip> bbear, you don't make your code any more complex
10:17:11 <mniip> it's a trivial refactor
10:17:21 <mniip> and it yields performance improvement
10:17:23 <mniip> so, why not
10:18:35 <bbear> how do you force the evaluation ?
10:19:46 <mniip> $!
10:19:53 <mniip> f $! x = x `seq` f x
10:20:16 <bbear> ok
10:20:23 <bbear> > :t ($!)
10:20:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:23:01 <bbear> thanks.
10:23:06 <bbear> It should use less memory now.
10:24:06 <bbear> as a matter of fact it uses far less memory, I will maybe experience this stack overflow anyway.
10:25:08 <rostero> i don't understand how traverse and sequenceA can be defined in terms of one another.   how do those functions not call each other forever?  https://gist.github.com/anonymous/9159ef762a968d4806df81850588efac
10:26:50 <stevenxl> Hi folks. I recently read the paper Why Functional Programming Matters and really enjoyed it. I'm not a mathematician or computer scientist, but would love to find a paper of similar level of abstraction on monads.
10:27:03 <stevenxl> I found 3 papers by Phillip Wadler but don't know which one to read.
10:27:49 <stevenxl> hah - I guess given my goal this should do it
10:27:49 <stevenxl> Comprehending Monads
10:31:22 <rostero> or is it that they can be defined that way, but people provide instance definitions for traverse which aren't defined in terms of sequenceA and therefore the problem doesn't exist?
10:31:40 <rostero> i see {-# MINIMAL traverse | sequenceA #-}
10:31:50 <rostero> so i guess it's not an issue
10:31:50 <rostero> nm
10:36:27 <bbear> stevenxl: if you want to comprehend monad, I would suggest you read just a little bit about category theory (not especially about monad), and then play a little bit with (<$>), (<*>) to get a grasp of what is a monad.
10:37:20 <bbear> in fact it doesn't matter very much I think to understand what is a monad; you need it to do some actual stuff with Haskell, but once you get it, there is not that much interesting about that from a strict prosaic programmer.
10:37:50 <Xandaros> I just have one tip: Ignore IO for now. It's magic.
10:38:24 <Xandaros> I feel like many people get stuck on the fact that IO is a monad and believe monads are somehow linked to IO
10:38:31 <bbear> no
10:38:37 <bbear> Monad are quite ubiquitous in Haskell
10:38:43 <Xandaros> indeed
10:39:12 <bbear> as IO is probably the only thing that matter when you try to solve little puzzle, you get centered on this problem.
10:39:27 <mniip> rostero, that's the case in many typeclasses
10:39:29 <mniip> see Eq, Ord
10:39:33 <bbear> it's the bottleneck of doing Haskell for the first time when you come from imperative programming.
10:39:34 <mniip> Show
10:39:49 <Xandaros> I personally really like to use Maybe as an example Monad
10:40:25 <Xandaros> It's simple enough that beginners can implement it themselves, but complex enough that it has obvious uses (unlike Identity, for example)
10:41:06 <mniip> why not RWST
10:41:10 <mniip> RWS rather
10:42:45 <bbear> monads are boxes
10:42:56 <bbear> monads are type signature ?
10:42:57 <mniip> monads are monoids
10:43:04 <bbear> in the category of endofunctors
10:43:31 <mniip> with monoidal structure induced by composition and identity endofunctor
10:43:38 <bbear> argh
10:43:46 <Xandaros> Because RWS is far too complicated...
10:43:59 <mniip> bbear, it's simpler than it sounds
10:44:05 <bbear> I suppose
10:44:22 <bbear> well well
10:45:03 <bbear> endofunctors are arrows from A to A 
10:45:08 <mniip> no
10:45:14 <bbear> no ?
10:45:16 <mniip> you're thinking of endofunctions
10:45:22 <bbear> ha yes this arrows.
10:45:25 <Xandaros> stevenxl: My suggestion is to look at the Functor, Applicative and Monad classes in that order and see how they work on Maybe. That should give you an intuition of how they work.
10:45:29 <FjordPrefect_> http://lpaste.net/357654 Any tips on how I might rewrite this nested if-then-else?
10:45:30 <bbear> so what are endofunctors ?
10:45:38 <mniip> functors from C to C
10:45:43 <bbear> what are functors anyway. I skipped this chapter.
10:46:00 <Xandaros> FjordPrefect_: One thing that immediately stands out: Use when :P
10:46:02 <mniip> a mapping of objects and morphisms from one category to another
10:46:12 <bbear> ok
10:46:12 <mniip> that preserves categorical structure (composition and identity)
10:46:37 <mniip> category homomorphism!
10:46:56 <Xandaros> FjordPrefect_: http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad.html#v:when
10:47:33 <mniip> bbear, in haskell, the Functor typeclass is for endofunctors on Hask
10:47:43 <bbear> what is Hask ?
10:47:52 <mniip> the category of haskell types
10:47:55 <bbear> the guy was drawing this analagoy that categories are just types
10:48:08 <mniip> objects are haskell types, morphisms are haskell functions
10:48:46 <bbear> does it help to understand diagrams and stuff like that ?
10:49:10 <mniip> not sure what you're asking there
10:49:18 <bbear> sometimes when you read about CT, it seems they are overgeneralizing stuff without a real need for such hyperstructure.
10:49:48 <bbear> I mean, it was already ok with only groups, rings and such nice algebraic structure.
10:50:01 <mniip> well
10:50:04 <bbear> from where come the need to have a solid category theory ?
10:50:15 <mniip> originally from topology
10:50:34 <FjordPrefect_> Xandaros: thanks, when is pretty neat
10:50:43 <bbear> by the way, topology just sounds like analysis in many dimensions.
10:50:48 <bbear> (i'm just asking for the sake of discussing)
10:51:14 <bbear> topology seems far from algebraic structure (from my naive point of view). That's fascinating that they built such a bridge
10:51:33 <bbear> Because they went with algebraic topology and I don't know what it means :)
10:51:37 <mniip> well
10:51:47 <mniip> there's homology and homotopy groups
10:52:00 <mniip> describing various kinds of connectedness in a topological space
10:52:13 <mniip> the construction of either group from a topological space
10:52:14 <mniip> is a functor
10:53:08 <FjordPrefect_> Xandaros, but any ideas on what to do about the nested conditions?
10:54:53 <Xandaros> If you want to keep your prints, I don't much can be done
10:55:12 <Xandaros> Well, one print xD
10:55:48 <FjordPrefect_> don't think the print is needed
10:55:56 <FjordPrefect_> it was more of a check
10:56:26 <`Guest00000> can you install a package without cabal-install?
10:56:51 <Xandaros> Well, if possible, the easiest solution would be to move all your checks to the top and just do one check where you && them all
10:58:57 <`Guest00000> i'm trying to install cabal-install on gentoo, it failed, said "Encountered missing dependencies: process >=1.1.0.1 && <1.5", then died
11:02:16 * hackagebot twiml 0.2.0.1 – TwiML library for Haskell – https://hackage.haskell.org/package/twiml
11:19:00 <xieyuheng> after : 'type (State s a) = (s -> (a, s))', I tried : 'instance Monad (State s) where'.      
11:19:04 <xieyuheng> but I meet error : 'The type synonym ‘State’ should have 2 arguments, but has been given 1'
11:19:29 <xieyuheng> I had {-# LANGUAGE TypeSynonymInstances #-} enabled already
11:39:38 <qbit> hola
11:39:52 <qbit> i sthere a way to specify where cabal puts tmp directories? 
11:40:13 <qbit> when I do "cabal install shellcheck" - it does this: /tmp/cabal-tmp-53557
11:40:19 <qbit> and i would like to make it not use /tmp
11:42:27 <piyush-kurur> anyone here who has tried sml new jersey
11:50:14 <lyxia> xieyuheng: type synonym instances still don't allow you to partially apply type synonyms
11:50:37 <xieyuheng> I tried this :: https://gist.github.com/sdiehl/8d991a718f7a9c80f54b
11:50:53 <xieyuheng> I met error : No instance for (Applicative (State s))
11:51:36 <xieyuheng> what's wrong with sdiehl's code ? (from 3 years ago)
11:55:10 <NickHu> What's the syntax for dots in the cabal description field? I can't find it anywhere
11:55:28 <geekosaur> xieyuheng, you are using a newer version of ghc that requires an Applicative instance to make a Monad instance
11:56:45 <xieyuheng> I will try to imp. Applicative for State s
11:57:19 <xieyuheng> I need to do this for every Monad ?
11:57:59 <geekosaur> yes
11:58:26 <geekosaur> although there is a cheaty workaround intended for use when retrofitting older code
11:58:35 <geekosaur> instance Applicative (whatever) where (<*>) = ap; pure = return
11:58:56 <geekosaur> (which defines it in terms of Monad)
11:59:51 <koala_man> qbit: have you checked if it respects TMPDIR?
12:00:26 <geekosaur> it likely doesn't; it would efault to /var/tmp if it did
12:00:55 <qbit> i haven't, but easy enough to try really quick
12:04:08 <qbit> apparently it respects it!
12:04:11 <qbit> thanks koala_man 
12:13:27 <slack1256> anybody using haskell-session on emacs and nix-shell? how do you combine both?
12:14:15 <Infinisil> slack1256: Maybe starting emacs from the nix-shell?
12:15:14 <slack1256> that works, but I would like to not lose my buffers if possible
12:15:54 <slack1256> playing with haskell-process-wrapper-function seems to be the way, although my elisp-foo is weak
12:17:30 <Infinisil> slack1256: #emacs it is :D
12:17:47 <slack1256> uwu
12:19:05 <Infinisil> And I'm always over at #nixos
12:23:33 <monochrom> Oh oops GHC uses 1.4GB to compile the Cabal library.
12:23:55 <monochrom> Maybe I should go back to 32 bits. :)
12:26:20 <ongy> how much does that save on GHC? 1/3?
12:26:47 <Infinisil> I wouldn't be suprised if it's about the same size
12:26:47 <monochrom> 1/2 because 32-bit pointer vs 64-bit pointer
12:27:10 <ongy> Strings (the Text version), Integer and a few others would likly disagree
12:59:32 <Infinisil> Damnit, I have an exam about functional programming and formal methods tomorrow and I can't do shit
13:00:56 <Infinisil> Well actually that's not true, I am fairly confident in the former, and not bad in the latter, I just didn't learn much recently
13:02:51 <slack1256> are macros on elisp just lazy functions (that don't evaluate their arguments)?
13:05:28 <koz_> slack1256: If I remember correctly, Elisp macros are functions which are run at compile time to produce code.
13:05:30 <monochrom> I think macros are richer than laziness. But a lot of macros just do laziness.
13:05:42 <koz_> (basically, it's CTE with the full power of Elisp)
13:06:36 <ab9rf> people are generally not tested on their ability to do shit
13:06:43 <ab9rf> and when they are, it's not the best of circumstances
13:07:23 <slack1256> koz_: nice, that is a difference
13:08:03 <slack1256> afaik that extra power of macros comes from lisp being a really regular language, or am I wrong? what I am not seeing here?
13:08:13 <koz_> slack1256: Lisp is homoiconic.
13:08:18 <koz_> So everything looks like a list.
13:08:24 <koz_> Thus, if you can build lists, you can build code.
13:08:30 <koz_> And that's basically what macros do.
13:09:20 <koz_> So, for instance, (+ 2 3) is a list consisting of a symbol and two numbers, which also happens to evaluate to 5.
13:10:47 * hackagebot cubicbezier 0.6.0.4 – Efficient manipulating of 2D cubic bezier curves. – https://hackage.haskell.org/package/cubicbezier
13:10:56 <crucify_me> having tough time with chapt 6. the functionality of these two instances seem identical. why is Tuple set up differently from Pair here? https://ptpb.pw/7Sl3
13:11:23 <koz_> crucify_me: Pair is monotyped.
13:11:29 <koz_> Tuple doesn't have to be.
13:12:38 <dmwit> crucify_me: `Pair` makes sure that both contained values have the same type. So `Tuple "hi" ()` is okay, but `Pair "hi" ()` isn't.
13:13:16 <dmwit> crucify_me: In particular this is handy because `Pair` then only has one type parameter, so classes which operate on types of kind `* -> *` can have some interesting variant behaviors for `Pair` and `Tuple`.
13:13:36 <dmwit> crucify_me: e.g. the `Foldable` instance for `Pair` can inspect both contained values, while the `Foldable` instance for `Tuple` can only inspect the "right-hand" value.
13:15:11 <crucify_me> koz_, dmwit  thank you , so if Pair is monotyped ....
13:15:16 <dmwit> > length (1, 2)
13:15:18 <lambdabot>  1
13:15:22 <dmwit> > length (Product (Identity 1) (Identity 2))
13:15:25 <lambdabot>  error:
13:15:25 <lambdabot>      • Couldn't match expected type ‘Identity Integer -> [a0]’
13:15:25 <lambdabot>                    with actual type ‘Product (Identity Integer)’
13:15:35 <dmwit> :t Product
13:15:37 <lambdabot> a -> Product a
13:15:49 <dmwit> ...oh
13:15:51 <ongy> > Product 5 <> Product 3
13:15:53 <lambdabot>  Product {getProduct = 15}
13:15:56 <dmwit> > length (Pair (Identity 1) (Identity 2))
13:15:58 <lambdabot>  error:
13:15:58 <lambdabot>      Data constructor not in scope:
13:15:58 <lambdabot>        Pair :: Identity Integer -> Identity Integer -> [a0]
13:16:08 <dmwit> > length (Data.Functor.Product.Pair (Identity 1) (Identity 2))
13:16:11 <lambdabot>  error:
13:16:11 <lambdabot>      Not in scope: data constructor ‘Data.Functor.Product.Pair’
13:16:11 <lambdabot>      No module named ‘Data.Functor.Product’ is imported.
13:16:13 <johnw> i finally have a real use for the list monad, and it's pretty tripping writing code for it
13:16:15 <dmwit> ...okay, fine.
13:16:19 <johnw> trippy*
13:16:29 <johnw> instead of reaching for map/for, I can just use <-
13:16:41 <dmwit> johnw: Wow, you've come all this way without ever needing backtracking search?
13:16:47 <johnw> yep
13:16:52 <dmwit> neat!
13:17:00 <dmwit> And yeah, list monad code is fun. =)
13:17:14 <crucify_me> does that code ' <- ' actually mean Epsilon ?
13:17:30 <dmwit> What is epsilon?
13:17:33 <johnw> i've played around with it before, but never needed it as the only sane solution to my problem.  I could do this with nested maps, but the logic would become very hard to see.
13:17:37 <crucify_me> <-
13:17:51 <dmwit> I don't understand your question.
13:17:59 <johnw> for [1..5] $ \i -> code    vs.   i <- [1..5]; code
13:18:02 <crucify_me> re: what johnw posted
13:18:23 <crucify_me> I was told <- is Epsilon
13:18:23 <dmwit> That doesn't clarify anything about your question for me.
13:18:35 <crucify_me> it looks like an 'E'
13:18:47 <johnw> I'm walking through a DAG, using a monoid to compute the cost of all paths through the tree so I can find various minimum and maximums down various paths
13:22:57 <ab9rf> chirp
13:25:59 * hackagebot miso 0.7.2.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
13:30:22 <trigone> hi, what's your opinion on this book: http://www.apress.com/us/book/9781430262503 ("beginning haskell, project based approach")
13:32:55 <crucify_me> dmwit could you give a simple example (Foldable I haven't studied yet) regarding your earlier comment "because `Pair` then only has one type parameter, classes which operate on types of kind `* -> *` can have some interesting variant behaviors for `Pair` and `Tuple` "
13:33:31 <crucify_me> I'm not familiar with the notation '* -> *'
13:34:12 <MarcelineVQ> the book you have will explain that nicely if you keep going :>
13:34:38 <MarcelineVQ> ^ crucify_me
13:34:46 <crucify_me> yeah thanks MarcelineVQ 
13:35:08 <crucify_me> oh re: my question ? MarcelineVQ 
13:35:25 <MarcelineVQ> yes
13:36:00 <crucify_me> ok thanks , the exercises come first... (7 of them)
13:36:31 <trigone> crucify_me: what's the book you're studying
13:37:15 <crucify_me> each exercise has a different flavor, obviously the point is to illustrate how haskell is dealing with various types implementing Eq, but I feel lost in this section
13:38:08 <crucify_me> haskellbook from first principles.. I'm not a programmer this shit is hard
13:38:29 <crucify_me> trigone, 
13:38:53 <trigone> crucify_me: k thx
13:39:27 <jared-w> crucify_me: it's a good book. Chapter 6 is what you're working on, correct? Are you stuck on the Eq section still?
13:40:58 <crucify_me> yeah, I got into a long chat with a member sk*i , and the chat went onto the base case ... terminal case? .... of _:_ <= [  ] = False  ....so
13:41:02 <crucify_me> jared-w, 
13:41:30 <crucify_me> so my initial question was re: this section I'm stuck on and ..
13:42:16 <crucify_me> and although I was happy to be exposed to the notation _:_ <= [ ] = False  , I didn't see how it applied to this section of the book exactly
13:43:43 <jared-w> Hmm... to be honest, it sounds like they went way overboard into the implementation details of how equality and typeclasses are coded into the compiler
13:44:16 <crucify_me> yeah, I got something out of it for sure, was very appreciative towards that person
13:44:40 <jared-w> So do you have a particular exercise you're stuck on? Or something from the book? (I have it open right now)
13:45:40 <crucify_me> well I see no emerging pattern from these 7 problems that help me with the next (after looking the solution ! ) ...and
13:45:52 <crucify_me> looking *up
13:46:29 <jared-w> Are you on the "writing Eq instances for the provided datatype" exercises?
13:46:54 <crucify_me> yeah,
13:47:30 <jared-w> Well, let's see. The definition of equality for a particular data-type is that it is equal if all of its 'parts' are equal
13:47:48 <jared-w> So if I test two lists for equality (list a = [1,2,3], list b = [1,2,3]
13:47:50 <crucify_me> got that
13:48:09 <jared-w> The equality instance will see if 1 == 1, 2 == 2, 3 == 3
13:48:20 <crucify_me> cool
13:48:34 <crucify_me> so yeah hold on jared-w please
13:49:02 <jared-w> The pattern there is that you learn how to pattern match on a data-type and break it apart into its 'parts' in order to work with them
13:49:48 <crucify_me> so yeah it's just how its written that trips me up. each one seems to be different, some require a restriction, some don't require deriving Show to print. its strange.
13:50:28 <jared-w> ahh, okay, I can see how that's confusing you now.
13:50:59 <crucify_me> re: deriving Show, the solutions are not using deriving Show, but I thought I needed that  a few days ago
13:51:31 <jared-w> In Haskell, programmers prefer to think about the data structure "as a whole" and then strap on all the things they need to the data structure as they come to it. So the book isn't /telling/ you to add deriving Show, it's just hoping that you'll say "oh, I want to see them" and then add it yourself
13:52:01 <crucify_me> the other thing is, looking ahead to EitherOr a b ...
13:52:12 <crucify_me> ok cool thanks that is encouraging
13:52:18 <MarcelineVQ> you'll need to be more specific about what you mean by solution when you say "the solutions are not using deriving Show"
13:52:35 <jared-w> MarcelineVQ: I have the book open in front of me so I'm following him fine :)
13:52:57 <crucify_me> MarcelineVQ, I might be confusing my use of deriving Show with another problem stemming from somewhere else
13:52:59 <jared-w> Eventually the book will stop telling you what things to derive and it will expect you to know what deriving clauses you need to write. Eventually it'll even stop telling you what other instances to write (say you need to write a Monad instance... The book won't tell you that you need to also write Functor, Monoid, and Applicative)
13:53:22 <jared-w> (that won't be for a while; don't worry)
13:53:33 <MarcelineVQ> If you mean an example of using them, like     Pair 4 4 == Pair 2 2    that results in False, which is a Bool.  You don't need Show for Pair there, beause the expression is a Bool
13:53:49 <jared-w> (which already has a Show instance)
13:54:08 <crucify_me> right ok kindly forget the deriving Show inquiry
13:54:45 <crucify_me> its more about the structure of each exercise. my biggest problem is...
13:55:35 <crucify_me> for example with StringOrInt ..
13:56:11 <jared-w> (for reference to others, here are the exercises: http://i.imgur.com/mPQMEey.png)
13:56:14 <crucify_me> the data type is StringOrInt, then we use these two (what are they?) TisAnInt, TisAString ...
13:56:39 <geekosaur> sounds like data constructors for a type constructor
13:56:40 <crucify_me> in other examples, we use just the data type Pair, for example
13:56:45 <jared-w> Let's break that down a bit. StringOrInt is the name of the data type. The | means it's a "sum type"
13:57:04 <jared-w> TisAnInt and TisAString are the type constructors for the data type
13:57:43 <crucify_me> jared-w,  please go back to ..
13:57:49 <jared-w> So the StringOrInt data type means either "I am an Int. You can make this by using the constructor TisAnInt" or "I am a string. You can make this by using the TisAString constructor"
13:58:03 <crucify_me> the '|' .. the guard
13:58:19 <jared-w> | is not a guard in a data constructor. It's a bit confusing, I know.
13:58:38 <jared-w> | enumerates all of the possibilities
13:59:05 <crucify_me> ok got that. so that is fine  ... then the examples don't use the 'data constructors' as geekosaur called them
13:59:14 <jared-w> Look at the bottom of the page at the data DayOfWeek data type. It's saying "DayOfWeek is either Mon, Tue, Weds, Fri, Sat, Sun". In a data constructor, | can be thought of as "or"
13:59:23 <jared-w> crucify_me: they do :)
14:00:19 <jared-w> crucify_me: go back to page 120 for a second
14:00:36 <crucify_me> right I was reading that as 'or'
14:00:43 <crucify_me> tentatively
14:00:59 <crucify_me> ok going back
14:01:25 <MarcelineVQ> jared-w: best to use section numbers instead of page numbers, due to book versions
14:01:35 <crucify_me> yeah no clue re: page #
14:01:50 <jared-w> MarcelineVQ: true, I forgot about that. Chapter 4 section 4.2
14:01:55 <MarcelineVQ> 100 seems more relevant than 120 in the version I have, for example
14:04:56 <crucify_me> ok at 4.2 " Data constructors are the values that inhabit the type they
14:04:56 <crucify_me> are defined in. 
14:06:01 <jared-w> Did you also see the walk through of the data Bool declaration?
14:06:42 <crucify_me> yeah I would see the | as OR
14:06:49 <jared-w> crucify_me: Yup, the | is an "or" in a sum type. Product types are "and". So for example, `data Person = (Name String) (Age Int)` means Person is made from a name AND a string. Being able to build up and with or and make more complicated data structures is why they are called Algebraic Data Types :)
14:07:19 <MarcelineVQ> *data Person = MkPerson (Name String) (Age Int)
14:07:35 <jared-w> whoops, that's what I meant, m'bad
14:07:36 <crucify_me> ok yeah so we need two data constructors in the case of IntOrString
14:08:32 <jared-w> MarcelineVQ: I stared at that for like 2 minutes trying to figure out why it felt wrong and still missed it :p
14:08:44 <crucify_me> StringOrInt *
14:09:23 <crucify_me> ok the other thing that is confusing...
14:11:00 <crucify_me> when all is said and done, all these instances do is to do say, Pair 4 5 == Pair 4 6  -> True
14:12:03 <crucify_me> so we are writing code that I assume is already in GHCI, instead writing something that does , say  ....
14:12:08 <jared-w> Well, Pair 4 5 wouldn't equal Pair 4 6. However, yes, all Eq instances do is to test and make sure that the data constructors' values are equal
14:12:12 <crucify_me> instead of*
14:13:10 <crucify_me> Pair_Eq? Pair 1, Pair 2  -> False.
14:13:32 <jared-w> crucify_me: All of the Eq, Ord, etc instances you are writing can be replaced with `deriving (Eq, Ord)` at the end of a data type. The reason you are writing them here is to learn how they work :0
14:13:40 <crucify_me> sorry I meant Pair 4 5 == Pair 4 6  -> False    above
14:15:03 <jared-w> You're good :) I'm not quite sure what you mean by the Pair_Eq? line
14:15:41 <crucify_me> jared-w, very helpful that's what I thought. I am confused but yeah I see that. I need to just stare at the solutions for a while . thanks MarcelineVQ  ... yeah ok jared-w I meant 
14:16:37 <mibaz_1> I think I'm going to take a foray into agda to make this datakinds/etc. stuff more intuitive
14:17:15 <crucify_me> writing a function that takes two arguments that are being compared by Eq, instead of having to write out Pair 4 5 == Pair 4 5   , just to get a Bool
14:18:08 <MarcelineVQ> You are defining Eq for your type, that's what all these  MkPair 1 3 == MkPair 4 6 = False   lines are about
14:18:31 <MarcelineVQ> They're spelling out the cases where you want things to be True or False
14:18:52 <jared-w> > 1 == (0 + 1)
14:18:54 <lambdabot>  True
14:19:14 <jared-w> This works because Haskell knows how to compare two numbers. It knows this because there's an Eq instance for that type somewhere
14:20:03 <jared-w> If you wanted to write something like `MyDataType a == MyDataType b`, the compiler has no idea how to do that unless there's an Eq instance for that type
14:20:29 <jared-w> One thing that can be a bit confusing is that Bool is a value that can be returned
14:20:50 <bbear> :t MkPair
14:20:52 <lambdabot> error: Data constructor not in scope: MkPair
14:21:06 <bbear> instance Blabla
14:21:09 <jared-w> So in the book, there's an example instance:  instance Eq a => Eq (Identiyt a) where;    (==) (Identity a) (Identity b) = a == b
14:21:10 <crucify_me> ok, so yeah if the compiler has no idea then we..
14:21:31 <jared-w> You can also write that as:  (Identity a) == (Identity b) = a == b
14:22:05 <jared-w> Which can be read as "The result of two identity types being equal is the same result as if the 'a' and 'b' are equal"
14:22:29 <jared-w> So, a more verbose way to write it would be:  (Identity a) == (Identity b) = if a == b then True else False
14:23:18 <crucify_me> write out something like this to instantiate Eq manually, or use the deriving (Eq, Ord) . so yeah we are building the functionality of deriving (Eq, Ord) to see how it works
14:23:23 <jared-w> (In Haskell, the a == b returns either a True or a False, so the if/then/else is completely redundant. In a language like C, this is not the case and the if/then/else is required)
14:23:38 <jared-w> crucify_me: exactly
14:24:01 <crucify_me> thanks got it. really appreciate it.
14:24:16 <jared-w> You will be doing this with a lot of type-classes. Haskell is not super complicated with lots of different syntax and such. It's complicated because there are a lot of different layers of features that are enabled through the same features
14:25:01 <crucify_me> you mean in the sense of would otherwise be called inheritance jared-w 
14:25:15 <crucify_me> of what* would
14:25:15 <jared-w> For instance, you have Eq, Ord and Show, which you just learned about, but there's also Functor, Monoid, Monad, Traversable, Foldable, and so on. Rather than overwhelming you with all that, it's easier to start with simpler examples :)
14:25:37 <jared-w> crucify_me: yes, the concept of typeclasses in Haskell is very similar to "Interfaces" in other languages (especially Java)
14:26:09 <jared-w> You could think of instance Eq as being "implement the equality interface so the compiler knows how to compare my datatype for equality"
14:26:30 <crucify_me> yes good call
14:29:32 <crucify_me> jared-w, the example 'data TwoIntegers' has the data constructor 'Two' applied, whereas...
14:30:20 <crucify_me> in Pair, we just pass on using a data constructor of a different name from the data Type
14:31:06 <jared-w> TwoIntegers does not have an 'a' in the type declaration, Pair does
14:31:24 <jared-w> So for Twointegers you will write your instance like: Instance Eq TwoIntegers where....
14:31:50 <jared-w> but for `data Pair a`, it will be:  instance Eq a => Eq (Pair a) where...
14:31:58 <crucify_me> oh yeah because we already know theyre Integers, so we don't need to put a constriction on those
14:32:07 <jared-w> The => means "a must implement this typeclass"
14:32:54 <crucify_me> sorr yis my last statement correct
14:32:58 <crucify_me> ?
14:33:17 <jared-w> Yes. Some people might take issue with the wording but the overall idea is correct
14:33:47 <crucify_me> right that was one of my main perplexities . thanks a lot
14:34:03 <jared-w> TwoIntegers does not take a paramater in its type declaration so it won't need `Eq a =>` in the instance. The /reason/ for that is you don't need it because its data constructor is 'monomorphic'
14:34:23 <jared-w> Which is a scary looking word that means "it can only be one type and we know what that type is"
14:34:53 <crucify_me> right , both parameters are Integer, so that makes it monomorphic 
14:35:11 <crucify_me> its defined right away
14:35:26 <jared-w> In fact, `data Pair` is the polymorphic version of `data TwoIntegers`; `data Pair Integer` is isomorphic to `data TwoIntegers`
14:35:43 <crucify_me> excellent very helpful
14:35:59 <crucify_me> muchas gracias
14:36:02 <jared-w> No problem
14:37:02 * hackagebot rss-conduit 0.3.2.0 – Streaming parser/renderer for the RSS standard. – https://hackage.haskell.org/package/rss-conduit
14:37:07 <jared-w> For a cool (and unnecessary brain exploder). Haskell allows someone to use `newtype` instead of `data` for some type declarations when you can prove that the two types are isomorphic. It allows Haskell to "unbox" the new type and run it as the old type compile time so you have no performance hit :)
14:38:13 <jared-w> Haskell also allows someone to take advantage of this isomorphic property with a language extension called GeneralizedNewtypeDeriving which allows you to say "give me very single instance that this other type has and use it in my new type" without you having to write any code.
14:39:03 <jared-w> (But, again, all of this isn't stuff you'll need to even be aware of for a while. So if that was confusing, don't worry about it)
14:39:26 <crucify_me> yeah, pretty saturated right now :)
14:40:21 <crucify_me> one thing though jared-w as long as you're still shooting from the hip
14:40:43 <crucify_me> StringOrInt is the only one that requires a base case
14:40:46 <jared-w> np, that's normal totally normal :p come back to it in a month or so and you'll find yourself less confused. Then wait some time and come back to it again... etc. Eventually you'll get it. I've read some Haskell articles 3-5 times over the years
14:41:42 <crucify_me> those two _ _   ...
14:42:44 <crucify_me> (==) _ _ = False  how do those wildcards work there. what do they represent?
14:43:22 <jared-w> That, to me, is a bit of an ugly technicality about how pattern matching works in Haskell
14:44:11 <jared-w> But it's also an elegant solution
14:44:27 <MarcelineVQ> ski explained _ pretty well, do you keep chat logs?
14:45:00 <jared-w> So what they did was you have TisAnInt or TisAString. You have two things you're comparing. There are four possible comparisons. a is an int and b is an int, a is a string and b is a string, a is an int and b is a string, a is as tring and b is an int
14:45:00 <crucify_me> I did get sk*i 's example where _:_ <= [ ] = False shows that any x:xs is greater than [ ] , and how that would make a logical base case, to terminate the program.
14:45:29 <crucify_me> but here does that also mean _:_  ?
14:45:29 <MarcelineVQ> this was after that, <ski>   data PrimaryColor = Red | Green | Blue  and beyond
14:45:49 <jared-w> The only way StringOrInt is equal is if both things are the same type. So they wrote the two cases that StringOrInt is equal
14:45:59 <jared-w> and for all the other cases they used _ _ which is something called an 'ignore pattern'
14:46:28 <crucify_me> yeah but MarcelineVQ I couldn't see the trees from the forest there
14:46:55 <jared-w> You can think of that instance as saying "If the first and second thing are both ints, then if the two ints are equal, the StringOrInts are equal. If they're both strings, then.... Otherwise, there's no way they can be equal, so any other result is automatically false"
14:47:36 <crucify_me> ok that is different from _:_ , because _:_ is something populated
14:47:37 <jared-w> crucify_me: You can replace (==) _ _ = False with:   (==) (TisAnInt m) (TisAString t) = False;  (==) (TisAString t) (TisAnInt m) = False. That will satisfy every possible combination of inputs you have
14:48:00 <jared-w> _:_ means you have a list with at least two items but you don't care what they are
14:48:24 <MarcelineVQ> crucify_me, jared-w: then I'll prune a bit, http://lpaste.net/357656
14:48:30 <crucify_me> oh at least two items ! yes since it's not just the head
14:49:16 <jared-w> you can write the head function as:  head [x] = x; head (x:_) = x. It means 'give me the first item of the list'
14:49:17 <crucify_me> excellent thanks will read that MarcelineVQ many thanks !  ignore statement is a bit shaky will read up on that too!
14:50:02 <jared-w> But x:_ also matches on a singleton list I think? So it ends up being sufficient to define head as `head (x:_) = x`   (I could be wrong here)
14:50:52 <MarcelineVQ> > let hed (x:_) = x in hed (1 : [])
14:50:54 <lambdabot>  1
14:51:50 <MarcelineVQ> > let hed (x:_) = x in hed [1] -- I should have wrote it like this jared-w but yes :>
14:51:52 <lambdabot>  1
14:51:53 <jared-w> yeah, there we go. Lists feel like a bit of an odd case in Haskell since they syntax is so different from most other types
14:52:07 <jared-w> their**
14:52:57 <jared-w> When you think about it, it makes sense. It just took a bit for me to really unwrap all the fancy sugar for lists :p
14:53:01 <crucify_me> what a trip. this stuff is really interesting. I just keep things straight at this stage, so I forget stuff. It's all fuzzy but I see where it's going ...I hope!
14:53:16 <crucify_me> cant*
14:53:35 <crucify_me> cant keep things straight
14:53:48 <jared-w> It's all good. It'll take a bit and eventually you'll find yourself feeling less stupid than you used to :p
14:54:04 <MarcelineVQ> crucify_me: keep at it, don't be afraid to revisit things you've already read, chances are the thing that's confusing you was already explained and you missed it. section 4.2 for example for how datatypes are defined
14:54:07 <jared-w> Shit, not even 6 months ago I knew less Haskell than you did
14:54:13 <crucify_me> I work at UC Berkeley, this semester I'm going to find a tutor somehow
14:54:39 <crucify_me> the chats are great, but it is sort of brutal communicating.
14:54:56 <jared-w> Berkeley is a great place :) check for some Haskell meetups in your area? I'd be surprised if there weren't any
14:55:21 <MarcelineVQ> in the end it's you that needs to do the learning, a tutor won't be able to do much more than you get here, probably :>
14:55:32 <crucify_me> word
14:55:44 <mbw> I have a question about phantom types and GADTs. I've been trying to write a small webcrawler, in the process of which I abstracted over the network-uri library, which exports a type URI and some functions to work with it. Using XDataKinds and XKindSignatures, I defined a wrapper "newtype URL (t :: URLType) (p :: PointsTo) = URL URI", where "data URLType = Absolute | HostRelative | ..." and "data PointsTo = 
14:55:46 <jared-w> It's faster to talk to tutors than to type though, so they can help with the feedback loop sometimes :p
14:55:50 <mbw> TheHost | OneFurtherDown | TheTargetData" (or something along those lines). This actually helped me weed out quite a few logic errors. Unfortunately, I also have to write a lot of identical functions like "appendToHost :: URL 'HostRelative p -> URL 'Absolute 'TheHost -> URL 'Absolute p" or "appendToPath :: URL 'PathRelative p -> ... " You get the idea. I feel like I could maybe express this more succinctly 
14:55:56 <mbw> using GADTs. But maybe I'm wrong, since most examples I could find are about defining some sort of 'eval' function for an inductive data-type. So, could this be a use-case for GADTs, and if yes, how should I approximately go about this?
14:56:14 <crucify_me> yeah, in person is key, at least go to the person with a pile of questions and fire through them
14:56:22 <jle`> mbw: are the functions really identical?
14:56:47 <jle`> oh, i see what you mean
14:56:48 <MarcelineVQ> ehe, but then you have to remember the answers to a pile of questions
14:56:54 <mbw> jle` I would say some of them, but certainly not all of them.
14:57:04 <jle`> yeah this is a simple situation where you can use singletons to dynamic dispathc, to sort of emulate having a typeclass
14:57:09 <MarcelineVQ> with the exception of some typos you haven't ran into yet, it's all there in the book you have, keep plugging away and re-reading
14:57:12 <jle`> if you have singletons for URLType
14:57:42 <Donovan> jared-w: im going to take your advice from yesterday and ask here :) cheers again.
14:57:45 <jle`> you oculd write append :: Sing a -> Url a p -> Url 'Absolute 'TheHost -> URL 'Aboslute p
14:58:00 <jle`> and then pattern match ont he singleton
14:58:17 <Donovan> would anyone here be able to help me understand why this typecheck error happens from the code, and what needs to change to fix it? http://lpaste.net/357657
14:58:33 <mbw> What role does the singleton play, and how would it be defined?
15:00:16 <erisco> :t foldr
15:00:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:00:58 <mbw> Also, does this imply that GADTs are NOT applicable here? Just so I am able to make an informed decision...
15:01:11 <erisco> foldr :: Foldable [] => (Vector a -> b -> b) -> b -> [Vector a] -> b
15:01:26 <jle`> mbw: it lets the user pass in something that can determine what 'a' is, and append can patttern match ont it to dispasth the appropriate method
15:01:28 <erisco> Donovan, what is your b?
15:01:37 <jle`> mbw: well singletons in haskell are implemented using GADTs
15:01:42 <jle`> usually
15:02:03 <jle`> alternatively you can just skip the singletons and go to a GADT
15:02:06 <jle`> of "appendable" things
15:02:36 <jle`> data Appendable a b c where AppendHost :: Appendable 'HostRelatve 'Absolute 'TheHost
15:02:40 <jle`> or however you want t define your logic
15:03:03 <jle`> or it could even contain the URL's
15:03:31 <jle`> data Appendable a b c wher AppendHost :: URL 'HostRelative p -> URL 'Absolute 'TheHost -> APpendable 'HostRelative 'Aboslute 'TheHost
15:03:41 <jle`> and then yur function would be append :: Appendable a b c -> URL ? ? ?
15:03:48 <jle`> i'm not exactly sure what logic/relationship you wanted
15:03:52 <jle`> so my types are all proably wrong
15:04:18 <jle`> the "Appendable" GADT here is essentially the xact same thing as writing a typeclass for different appendable combinations
15:04:22 <jle`> a multi-parameter typeclass
15:04:40 <jle`> the singletons approach is more composable and re-usable, and you can use it for other things than besides just appending
15:05:40 * hackagebot pandoc-sidenote 0.19.0.0 – Convert Pandoc Markdown-style footnotes into sidenotes – https://hackage.haskell.org/package/pandoc-sidenote
15:06:36 <erisco> Donovan, look at the return type of the foldr you are defining
15:07:07 <Donovan> erisco: my b should be a vector
15:07:11 <Donovan> *Vector
15:07:20 <erisco> why?
15:07:43 <mbw> jle`: I'm afraid I can't make the mental transition from the typical expression tree examples to what you are trying to say. Sorry, if I'm being stupid, that's why I needed phantom types in the first place :)
15:08:16 <jle`> mbw: i'm not sure waht your actuall examples are, since you left them off with a "..." heh
15:08:21 <jle`> so i'm trying to infer what the '...'s are
15:08:24 <mbw> oh
15:08:27 <jle`> i might have bee inferring them incorrectly
15:08:30 <Donovan> erisco: because I want to fold Vectors through Matrices? Or are you saying that i cant?
15:08:34 <mbw> Okay I'll try to clarify.
15:08:55 <jle`> like you gave an example of one, but not the other
15:09:01 <jle`> so i'm not sure how to interpolate the two to a pattern
15:09:09 <jle`> so i just tried to guess what the pattern is, heh
15:09:55 <erisco> Donovan, lets start from the top... does this make sense? http://lpaste.net/357658
15:10:47 <Donovan> yep
15:12:16 <mbw> So, basically, I (as of now) have to type parameters. One stands for whether an url is absolute ("https://www.example.com/foo/bar"), relative to a host ("/foo/bar") or some general path ("/bar"). The other parameter stands for the actual problem. I parse starting from the top-level, then extract a link and follow it, until I get what I actually want. So for parsing pictures, I have something like "data 
15:12:22 <mbw> PointsTo = TheHost | TopLevel | PreviewPage | AThumbnailPic | TheActualPic".
15:12:27 <Donovan> oh wait
15:12:27 <mbw> s/to/two
15:12:37 <Donovan> erisco: so the problem is my definition of Matrix?
15:12:50 <erisco> Donovan, no
15:12:59 <erisco> Donovan, just a second why I write the types out
15:13:42 <jle`> what's the actual problem?
15:14:23 <mbw> jle`: So I have parsing functions of type getThumbNails :: Doc (and XML document tree) -> [Either URLError (URL 'HostRelative 'AThumbnailPic)], for instance.
15:14:53 <erisco> Donovan, http://lpaste.net/357658 does the annotation make sense?
15:15:00 <jle`> and what are the append functinos that you want to unite?
15:15:55 <mbw> The problem is that if I expand on this, it will get complicated quickly. On the other hand, just passing some additional data type around and do vanilla pattern matching, I have to basically write an analogue to error "urk" in a lot of places, since the functions would all become partial again.
15:17:04 <jle`> this last part i can't understand without any examples
15:17:14 <jle`> of how things get complicated
15:17:17 <jle`> or of how things become partial
15:17:56 <mbw> The append example was one thing. The other would be parsing functions "parseURLAbsolute :: String -> Maybe (URL 'Absolute p), parseURLRelative -> Maybe (URL 'HostRelative/PathRelative p) or some such.
15:18:34 <jle`> the append example was not a complete example, though?  i wasn't sure what you meant in the '...'s
15:18:39 <mbw> And like I said, I am not sure if GADTs are the way to go, it was just an idea.
15:18:58 <erisco> Donovan, that is why GHC is complaining 'a' is not 'Vector a', because that is precisely what has to be true to make your definition work
15:19:10 <erisco> [a] ~ Vector a  only if  a ~ Vector a
15:19:15 <jle`> i'm not even sure what your problem/issues are, sorry
15:19:24 <erisco> sorry,  [a] ~ [Vector a] only if  a ~ Vector a
15:19:41 <Donovan> it makes sense erisco, I just dont understand how I can tell it to expect Vector a, instead of a
15:19:42 <jle`> parseURLAbsolute :: String -> Maybe (URL 'Absolute p) seems very reasonable?
15:19:55 <jle`> or do you wan tone function that can parse *all* url types?
15:20:02 <erisco> Donovan, that just does not make sense :P
15:20:02 <jle`> in that case you can do something using singletons there
15:20:06 <Donovan> -_-
15:20:10 <Donovan> none of this makes sense!
15:20:19 <jle`> parseURL :: Sing type -> String -> Maybe (URL type p)
15:20:34 <jle`> so if the user passed in a 'Sing 'Absolute', it'd return a Maybe (URL 'Absolute p)
15:20:47 <mbw> The append problem at the moment are just two functions, "appendToHost :: URL 'HostRelative p -> URL 'Absolute p -> URL 'Absolute p" and "appendToPath :: URL 'PathRelative p -> URL 'Absolute p -> URL 'Absolute p", but other similar ones would probably be possible.
15:20:47 <jle`> and if the user passed in a 'Sing 'HostRelative', it'd return a Maybe (URL 'HoseRelative p)
15:20:52 <erisco> Donovan, that is like saying if you were writing the implementation for id :: a -> a that you want it to expect 'Vector a' instead of 'a'
15:20:59 <erisco> Donovan, well, that just isn't what the type of id is
15:21:08 <wilornel> Hey #haskell! I have `let uriPath = uriPath uri; putStrn uri_path`, and it does not work because IO does not match with Maybe, which I understand. However, I was wondering, how could I circumvent this issue?
15:21:22 <jle`> and yeah that full append thing can be combined using singletons too
15:21:38 <jle`> append :: Sing type -> URL type p -> URL 'Absolute p -> URL 'Absolute p
15:21:44 <wilornel>  `uri <- parseURI fullpath; let uriPath = uriPath uri; putStrn uri_path`, 
15:21:48 <Donovan> erisco: thats why I think my definition of matrix might be a problem
15:21:56 <erisco> Donovan, it isn't
15:22:14 <erisco> your implementation of foldr for Matrix is a problem though
15:22:21 <mbw> jle` But in the parseURL example, the decision on 'type' would be dependent on the actual contents of the String. (I'm thinking foralls...)
15:22:23 <Donovan> then i dont get it, a is supposed to be anything, right?
15:22:28 <erisco> correct
15:22:38 <jle`> these both emulate having a Appendable typeclass and a Parseable typeclass for things of kind URLTYpe
15:22:47 <jle`> mbw: oh, you don't want the user to decide
15:22:51 <jle`> you want the function to decide
15:22:51 <erisco> so you can't just decide to make it Vector a, it has to be any type
15:22:55 <jared-w> Donovan: the fact that 'a' could be anything also means you can assume nothing about 'a'
15:23:13 <mbw> jle`: The user is me, and I don't trust myself :)
15:23:26 <jle`> yeah, there's two types of quantification that people oftne mix up
15:23:36 <jle`> for universal qualification, the caller gets to pick what the type variables are instantiated as
15:23:47 <jle`> for existential quantifcation, the function decides what the type variables become instantiated as
15:23:49 <erisco> Donovan, if the type of id is a -> a then that means it works for all types
15:23:54 <jle`> and the caller has to handle whatever choice
15:23:58 <mbw> In the parseURL example, if the String was "/hello", a Sing 'Absolute would be a logic error.
15:24:04 <erisco> Donovan, if in the definition of id you assumed 'a' was 'Vector a' then your definition would only work for Vector a
15:24:11 <wilornel> Is there a concept that could solve this?
15:24:15 <jle`> well the String might not be parseable anyway
15:24:18 <erisco> Donovan, and if that were the case, giving id the type of a -> a would no longer make sense
15:24:24 <wilornel> It would be nice if I got a pointer to a name or a book's chapter
15:24:29 <Donovan> right
15:24:40 <jle`> mbw: but yeah, you can have the function decide what type to give by returnig it existentially quanified
15:24:43 <Donovan> but i -know- my Matrix is a [Vector a]
15:24:51 <jle`> one way to do this is to have a dependent pair like SomeUrl
15:24:52 <erisco> no, you don't, that is wrong
15:24:55 <Donovan> and once i unwrap it, i dont understand why i cant just foldr through it like a normal list
15:25:08 <jle`> data SomeURL p = forall t. SomeUrl (Sing t) (URL t p)
15:25:09 <erisco> the 'a' is the 'a' inside of [Vector a]
15:25:14 <Donovan> yes
15:25:15 <erisco> the 'a' is in the list, in the vector
15:25:16 <jle`> then you'd have parse :: String -> Maybe (SomeURL p)
15:25:19 <Donovan> and this is the issue im struggling with
15:25:23 <Donovan> which is why i think my types are wrong
15:25:38 <mbw> wilornel: If you're inside IO, the simplest solution would be to pattern match against the result of parseURI, i.e. case parseURI str of Nothing -> error "urk"; Just uri -> ...
15:25:46 <erisco> Donovan, sorry I misread slightly what you were asserting... 'a' the variable and 'a' the word got mixed up
15:26:12 <jle`> alternatively you can also squish your URL type and your singleton together so you don't need to pass an explicit singleton, but they're basically two ways of doing the same thing
15:26:18 <erisco> Donovan, you just have to get into the 'a' in your list of vectors. You can do that :)
15:26:46 <erisco> Donovan, start this way... say you just had  Vector a  rather than  [Vector a]   then how would you define foldr?
15:27:18 <jle`> mbw: with String -> Maybe (SomeURL p), if the parsing function decides it's an absolute url, it can return SomeURL SAbsolute theUrl
15:27:19 <wilornel> thanks mbw. I remember reading about case matching in Haskell programming from First Principles but I thought he explained that it was not so nice to work with
15:27:36 <mbw> jle`: I get the usage of existentials in this, I think. However, the Singleton type is still not clear to me. Since you said it is defined via GADTs, what would be an example definition?
15:27:37 <jle`> case matching is literally the best part about haskell, heh
15:27:58 <wilornel> He had nested a lot of cases one into another
15:28:38 <wilornel> He was able to get rid of them specifically because all his functions were all using the Maybe monad?
15:28:40 <jared-w> Donovan: you had an older version of the Foldable for Matrix that worked but was wrong. Can you update your paste with that older version as well?
15:28:42 <jle`> data SURLType :: URLType -> Type; SAbsolute :: SURLType 'Absolute; SHostRelative :: SURLType 'HostRelative; SPathRelative :: SURlType 'PathRelative
15:28:44 <erisco> Donovan, or alternatively think about how you can take [Vector a] to [a]
15:28:51 <mbw> wilornel: When starting a new function from scratch, I often start off using case matching, and only afterwards simplify if it makes sense, for instance by using a particular monad instance.
15:29:06 <wilornel> thank you!
15:29:59 <jared-w> wilornel: the example in that one was intended to show off the 'composition of effects' that monads allow and how it combines really powerfully with do notation
15:30:01 <erisco> Donovan, for the first approach it is actually easier to define foldMap instead of foldr
15:30:53 <jle`> a lot of this exact thing is actually covered in my singletons tutorial
15:30:56 <jle`> that i haven't released yet
15:31:05 <wilornel> and the 'composition of effects' works well when you use one monad within a do notation, right?
15:32:13 <mbw> lol
15:32:39 <jared-w> wilornel: the amazing thing about it is that it works with all monads pretty nicely; that's one of the most powerful aspects of monads
15:32:40 <jle`> mbw: it's "combplete" but i still need to rewrite a lot of it to get it to flow better, but maybe it will help
15:32:44 <jle`> mbw: https://gist.githubusercontent.com/Cedev/3ef669f809b3c2e771e57efb8771899e/raw/611f333364158b95e000a917c8f7ea7dd4142987/structrally-free-alternative.hs
15:32:48 <jle`> oh sorry, wrong link
15:32:51 <jle`> mbw: https://blog.jle.im/entry/introduction-to-singletons-1
15:32:56 <jle`> do not distribute please :)
15:33:07 <mbw> It's a promise ;)
15:33:31 <jared-w> "Some things are so private they can only be shared with your therapist or with 10,000 other people on #haskell"
15:33:46 <wilornel> jle` but it would have to be one specific modal within a do block, right?
15:33:53 <jle`> "do not distribute" i say, to the most active channel on freenode
15:34:25 <mbw> jle`: This use very useful, thanks for (really) sharing (soon?)!
15:34:25 <wilornel> you could not have composition of effects work nicely with two different monads in a do block
15:34:39 <jle`> no problem! let me know if you have any feedback too :)
15:35:21 <erisco> :t \f acc xs -> foldr (.) id (fmap (flip (foldr f)) xs) acc
15:35:23 <lambdabot> (Foldable t, Foldable t1, Functor t1) => (a -> b -> b) -> b -> t1 (t a) -> b
15:35:34 <erisco> I feel like there should be a better way to compose foldrs than that ... sounds like a lens thing
15:36:01 <jared-w> wilornel: you're right that you can only use one monad at a time in a do block. However, plenty of monads can be 'converted' into other monads quite nicely. Doing so is done with monad transformers
15:36:09 <pacak> :t foldl
15:36:11 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:36:12 <mbw> jle`: Does your definition of SURLType ... correspond to a particular part of the tutorial? (You said it did, but which one, in case I miss it and you're not around anymore)?
15:36:12 <pacak> :t foldl . foldl
15:36:14 <lambdabot> (Foldable t, Foldable t1) => (b -> a -> b) -> b -> t1 (t a) -> b
15:36:31 <jle`> mbw: yeah SURLType is the singleton pattern for URLType
15:36:48 <jle`> like data SBool :: Bool -> Type where STrue :: SBool 'True, SFalse :: SBool 'False
15:37:23 <jle`> s/singleton pattern/singleton
15:37:39 <erisco> :t foldr . flip . foldr . flip . flip
15:37:40 <lambdabot> (Foldable t, Foldable t1) => (a -> b -> b) -> b -> t1 (t a) -> b
15:37:45 <mniip> jle`, you should expand a bit on the "exactly one inhabitant"
15:38:00 <erisco> pacak, does that really work out to the same thing? amazing
15:38:14 <mniip> that 'SingDS s' is inhabited by exactly one inhabitant *once we pick the s*
15:38:23 <jle`> thanks , good note :)
15:38:30 <mbw> Is there also an example for the correspondence between the use for existentials and singletons? You implied that they both could be used to express the same thing?
15:38:44 <jle`> but yeahmost of this will be rewritten with a different introduction/conclusion
15:38:46 <jle`> and flow
15:38:55 <mniip> also typo doorStats
15:39:02 <erisco> pacak, so you can compose  foldr . flip  but you need an extra flip in front
15:39:16 <jle`> mbw: hm i mean that we usually implement singletons using GADTs in haskell
15:39:29 <jared-w> Seems ugly, honestly. I don't really like tons of flips in my equations :p
15:39:44 <jle`> well, in modern times, we use the template haskell from the singletons library
15:39:51 <jle`> which generates the GADT
15:41:31 <pacak> :t foldr >>> foldr . flip
15:41:33 <lambdabot> (Foldable t1, Foldable t) => (a -> b -> b) -> b -> t1 (t a) -> b
15:41:35 <jle`> and existentials and singletons are two different tools for differnt purposes
15:42:10 <Donovan> jared-w: I've updated the paste with the older definition that typechecked, but didnt do what i wanted
15:42:15 <pacak> Or is it <<<....
15:42:33 <jared-w> >>> is flipped (.), <<< is just (.) iirc
15:42:53 <jared-w> erisco: can you take a peak at Donovan's paste again?
15:43:49 <mbw> jle`: Ok, I scrolled back and I think I just misread "alternatively you can also squish your URL type and your singleton together so you don't need to pass an explicit singleton, 
15:43:57 <jared-w> also, Donovan, did you catch what erisco was mentioning about the foldMap earlier?
15:44:08 <mbw> but they're basically two ways of doing the same thing"
15:44:18 <Donovan> yeah i did thanks jared-w, I'll look into it a guess, seeing as im struggling this much with foldr
15:44:35 <erisco> Donovan, I think you'd have a much easier time defining foldMap instead of foldr
15:45:10 <erisco> foldMap composes nicely...
15:45:11 <trigone> drawing a sudden blank: to pattern-match over a 1-element list, what's the allowed syntax? ([x]), [x], (x:[])?
15:45:12 <erisco> :t foldMap . foldMap
15:45:14 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t1 (t a) -> m
15:45:39 <trigone> :t traverse
15:45:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:45:53 <trigone> :t traverse . traverse
15:45:55 <lambdabot> (Traversable t, Traversable t1, Applicative f) => (a -> f b) -> t1 (t a) -> f (t1 (t b))
15:46:09 <jared-w> trigone: [x] works, (x:[]) is the same as [x], and (x:_) matches any list with 1+ elements
15:46:09 <mbw> jle`: I think I will read your post now, and meditate on it. It's a good think you brought up the distinction between universal/existential quantification, since I think this matters for my problem.
15:46:17 <mniip> jle`, how exactly does one write a singlton typeclass incorrectly
15:46:36 <mniip> it's type-driven still
15:46:46 <trigone> jared-w: ok thx! didn't know you could use [x] without parentheses.. is it the sole exception to the syntax norm?
15:47:18 <trigone> :t traverse . foldMap
15:47:20 <lambdabot> (Foldable t, Monoid (f b), Applicative f, Traversable t1) => (a -> f b) -> t1 (t a) -> f (t1 b)
15:47:37 <trigone> :t foldMap . traverse
15:47:39 <lambdabot> (Foldable t1, Applicative f, Traversable t, Monoid (f (t b))) => (a -> f b) -> t1 (t a) -> f (t b)
15:47:52 <jared-w> trigone: I'm not sure, honestly. It's a bit of a weird case since so few data constructors 'wrap around' their variable so nicely
15:48:42 <trigone> jared-w: yeah, aside from tuples i guess, though i never know if the parentheses are special syntax or just priority-shift operator of sorts...
15:49:02 <mniip> jle`, another typo ";:"
15:49:20 <erisco> shame about the argument order for the cons case of foldr...
15:49:34 <mniip> and a [][] link attempt
15:50:10 <mbw> (But really, the extentions the singleton library needs... Scary...)
15:50:31 <trigone> > (\(Just [x]) -> x) $ Just 5
15:50:34 <lambdabot>  error:
15:50:34 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M872017398122...
15:50:34 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:50:47 <trigone> > (\(Just [x]) -> x) $ Just [5]
15:50:49 <lambdabot>  5
15:51:15 <trigone> mbw: what post? i may be interested
15:51:25 <carlos> Quick question: Is it possible to shorten the following?
15:51:59 <erisco> trigone, all the syntax rules for [] are special. Parentheses are, in contrast, regular
15:52:21 <carlos> data X = A | B X | C X | D X | ...
15:53:27 <mbw> trigone: It's a pre-release tutorial on singleton types by jle` and I literally promised not to share it like five minutes ago :( But I was talking about this library https://www.stackage.org/lts-9.0/package/singletons-2.2
15:53:29 <erisco> trigone, though (,) is special too as is (,,) and so on
15:53:38 <carlos> nvm, I can just make another constructor data Y = B | C | D | ...
15:53:40 <pacak> carlos: It's a [(X, E)] where E = B | C | D ...
15:53:42 <trigone> carlos: you could write data X = Cons Letter X and aside you'd write data Letter = A | B | C (but then might as well use char or int, right?)
15:54:07 <carlos> Yeah that makes sense, thanks
15:54:48 <trigone> carlos: mind you i'm not sure how different that is from [Letter]...
15:55:09 <erisco> trigone, I don't think it makes sense to view ( and ) as operators with precedence, but rather as grouping an expression
15:56:28 <trigone> erisco: no, you're right, the word operator was a poor choice, i didn't mean an operator as in, first class haskell operator. your description fits better
15:57:08 <trigone> (though in a way $ is both an operator, and a token which groups expressions in a different manner than if it weren't there)
15:57:27 <erisco> 3 * (1 + 2)  is kind of like you said   let x = 1 + 2 in 3 * x
15:58:01 <trigone> mbw: ok, no problem :)
15:59:21 <trigone> erisco: yes, that's true
15:59:59 <erisco> well, $ does that with precedence rules, I am saying ( and ) do not have an assigned precedence, or at least I don't know of an explanation that works like that
16:01:18 <erisco> in a grammar (that isn't written with fancy precedence features) the parentheses production goes alongside the highest precedence operators
16:02:05 <trigone> erisco: yes, as i said the word "operator" was not the right choice
16:02:32 <erisco> in that sense you might see it as opening a new precedence context
16:03:08 <trigone> yes, it's more a question of "precedence scope
16:03:14 <trigone> indeed
16:10:18 <trigone> re -- if i have a function which only expects a non-empty list, is it always worth it to use something like NonEmpty, or do i use Maybe even if it's a bit weirdish (bc at the extreme it'd be more logical to throw a runtime error)? i know it's a general question, but i'm just seeking general guidelines to handle partial functions
16:11:18 <erisco> trigone, no, it is not always worth it, nor is it always worth it to use Maybe, but I suspect it is worth the former most of the time
16:11:29 <erisco> you have to weigh the complication against the benefit
16:11:41 <mud> By "use Maybe" do you mean Maybe [a]  or something? I'm not sure where Maybe would come in to it.
16:12:01 <trigone> mud: no, i mean output a Nothing if the input is absurdly empty
16:12:12 <trigone> erisco: what's the former in your sentence?
16:12:13 <mud> Oh I see. Then yeah it depends
16:12:13 <erisco> if you have a partial function you can trivially make it total by changing the codomain from t to Maybe t
16:13:10 <erisco> of course, Maybe t doesn't say a darned thing because it is proved by Nothing
16:13:44 <erisco> trigone, using NonEmpty
16:14:07 <trigone> erisco: yeah, but it may feel weird in a sense. say it outputs nothing instead of whatever result: you can only interpret it if you know the function outputs a Nothing when its input is empty. at this rate then, why not test the list is non empty before calling the function?
16:14:13 <erisco> using Maybe to fix a partial function is a disaster in my opinion
16:14:25 <trigone> erisco: so what's your opinion?
16:14:49 <erisco> first is that now your codomain is Maybe t, which says squat
16:14:54 <trigone> i mean what would you do most of the time
16:15:08 <trigone> erisco: i don't know about codomain (is it the output domain?)
16:15:19 <erisco> then you have to figure out what to do with this Nothing value... if the function was partial to begin with then there is probably nothing sensible to do with Nothing
16:15:29 <trigone> just tell me in practice what you do in general
16:15:31 <erisco> trigone, I just mean the return type, yes
16:16:25 <erisco> trigone, first I try to restrict the domain so the function is total
16:16:32 <erisco> which is exactly what using NonEmpty would do
16:17:15 <trigone> at core, my function will get as input a list that is instrinsically meant to be nonempty. as in, my program throws an error if that list is empty. given the situation it may be logical to use NonEmpty...
16:17:16 <wilornel> If I see "Waiting for install task to finish..." when doing `cabal install`, how long should I wait?
16:17:51 <erisco> failing that I will stick in  f x = error ("f undefined on " ++ show x)  or whatever for the error message
16:18:07 <trigone> erisco: hm ok
16:18:19 <trigone> is the NonEmpty type well done?
16:18:29 <trigone> (and the library which goes with it)
16:18:45 <erisco> yes, and it was done by edwardk, so you know it is :)
16:19:01 <trigone> ok :) thx i'll use that then!
16:19:41 <erisco> if there was something sensible to do with a Nothing value then I would use Maybe, but this is not often the case
16:19:49 <mud> NonEmpty is about as nice to work with as it could be. That doesn't mean it's always satisfying though, there's still tradeoffs.
16:20:04 <erisco> and I am not going to weave a Maybe through the rest of my program just to spit out a useless Nothing ten miles later
16:20:13 <wilornel> dtruss is not showing any activity
16:20:17 <wilornel> is it hanging?
16:20:17 <EvanR> Maybe to fix a partial function, maybe
16:20:27 <erisco> if that made sense then probably an Either Error t would make more sense
16:20:40 <erisco> at least then I can get some information of where in ten miles the breakdown happened
16:21:04 <EvanR> tradeoff there is you now much wrangle the other Either errors somehow to combine them
16:21:23 <EvanR> must* and we dont have extensible variants :)
16:21:26 <erisco> yes, that is a reason I would like some concept of an open type
16:21:34 <erisco> this is one benefit of the exception system
16:21:53 <wilornel> Is there something else I should do instead of wait?
16:21:55 <trigone> to p-match over NonEmpty with a "singleton" list, is there something nicer than (x :| [])? asking just in case
16:21:59 <erisco> going down is products, coming up is sums, and sums are painful... products can be curried
16:22:00 <wilornel> Installed foundation-0.0.13
16:22:00 <wilornel> Ready to install memory-0.14.6
16:22:00 <wilornel> Waiting for install task to finish...
16:22:12 <wilornel> Does that mean I could just install the memory package myself?
16:24:14 <erisco> trigone, I haven't used view patterns in a long time but maybe that could make it better... ish
16:24:33 <trigone> erisco: what's view pattern? an extension?
16:24:38 <erisco> yeah
16:24:53 <trigone> also, is there an extension to create variables in the type signatures, somethings like :: let f = (a -> b) in ...
16:25:12 <erisco> I don't think it would really help here... would be more work to set up and it wouldn't get the match any shorter
16:25:15 <trigone> erisco: i don't think in my case it's worth it, but i'll look into it someday
16:25:47 <trigone> *local bindings in type sig
16:25:56 <erisco> I don't know of such an extension for that but I think it has been talked about
16:26:37 <erisco> as long as people can reasonably get by on type aliases it won't happen
16:27:05 <trigone> erisco: yeah i guess
16:30:51 <trigone> :t withFile
16:30:53 <lambdabot> error:
16:30:53 <lambdabot>     • Variable not in scope: withFile
16:30:53 <lambdabot>     • Perhaps you meant one of these:
16:31:00 <trigone> :t System.IO.withFile
16:31:01 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
16:44:19 <glguy> :t let f :: (a -> b) ~ c => c -> c; f = id in f
16:44:21 <lambdabot> (a -> b) -> a -> b
16:44:33 <glguy> trigone: There you go
16:44:44 <jared-w> oooh shiny
16:46:48 <trigone> glguy: ooh, is it the intended usage?
16:48:24 <johnw> trigone: it's type equalities, which the unifier can resolve easily at the call site
16:48:32 <jared-w> trigone: define "intended". It says "these two types are equal" 
16:49:21 <trigone> jared-w: well if the intended usage is different than local type alias, even if it's the desired behavior it could have caveats of sorts... (i dunno)
16:52:54 <trigone> btw, how do i go using NonEmpty if i want to recurse on it? is there a better way than this one: http://lpaste.net/357661
16:54:44 <erisco> trigone, what do you want to do to the list?
16:56:13 <trigone> erisco: use each element one after the other, what else?
16:56:19 <mud> trigone: I assume that's not the actual function? A lot of the time you can just transform it once into a normal list and run ... whatever it is you wanted to on it.
16:57:01 <trigone> mud: hm... but here my function is meant to call itself... though i *could* write an internal helper function which would work on normal lists
16:57:03 <jared-w> Also, NonEmpty has a monad, functor, applicative, foldable, traversable, IsList, .... (and like 20 other) instances. You should be able to do that sort of thing directly?
16:57:30 <jared-w> I can't see why `foldr1 (+) [my non empty list]' wouldn't work?
16:57:41 <erisco> trigone, what I mean is you usually use a fold, or a scan, or something like this, not explicit recursion
16:57:59 <trigone> jared-w: yeah but the example i gave was not what i'm working on, but i haven't sorted the details of my own function yet so i can't show it as example
16:58:49 <trigone> well my recursion is a bit special, but yet maybe you'll be able to refactor it, once i wrote it i'll ask you if you see a pattern
16:58:49 <jared-w> trigone: the point I was making is that in lists you usually use things like folds, scans, or what not. Those same things work with any data structure that 'implements' those features. List is not particularly "special" in Haskell
16:59:35 <trigone> jared-w: never said it was. all i say is: when i pattern-match with a NonEmpty, i must each time rebuild manually a NonEmpty, and it's a bit weirdish but if it's the way to do so
16:59:48 <trigone> (pattern-match with recursion)
17:00:51 <jared-w> Would it help if I said that NonEmpty is not really a list, but rather is a stream?
17:01:07 <jared-w> (well, it's a list, too...)
17:01:23 <erisco> trigone, you can define a local function on lists instead, if you want
17:01:49 <trigone> erisco: yeah that's my temporary solution (as in, unless i find better)
17:02:19 <geekosaur> I think you can also abuse type equality? (f ~ a -> b, ...) => ...
17:03:19 <trigone> type equality doesn't require any extension does it
17:03:26 <dsal> Hey, can someone point a ~noob at how to do really basic csv stuff?  Am I better off writing a parser?  cassava examples don't seem to get started.  All I really want is something like rows of named fields which I'd like to eventually add fields to and reemit.
17:04:07 <cheater> what can i use rather than error to get sane call stacks?
17:05:33 <Axman6> epper your code with HasCallStack constraints?
17:05:37 <Axman6> pepper*
17:05:53 <trigone> > reverse (1 :| [3])
17:05:55 <lambdabot>  error:
17:05:55 <lambdabot>      • Data constructor not in scope:
17:05:55 <lambdabot>          (:|) :: Integer -> [Integer] -> [a]
17:06:22 <pacak> dsal: Do you have any specific questions about cassava? Documentation seems sane to me.
17:07:01 <Axman6> dsal: you've exactly describes the NamedRecord view cassava offers
17:07:07 <Axman6> described*
17:07:52 <dsal> yeah, except I can't figure out how to get it working.  :)  Pasting examples into ghci gives me errors.
17:08:12 <pacak> dsal: Errors are good.
17:08:25 <pacak> As long as you can read/understand them.
17:08:27 <dsal> I was hoping to avoid creating a type just to pull a couple of fields.
17:08:39 <trigone> since functions like NonEmpty.length / reverse don't seem to be part of a class, do i have to use qualified imports to use them along those specialised for normal lists? (and why is there no class for some of those?)
17:09:15 <mud> Yes, usually qualified imports.
17:09:16 <dsal> pacak: I can sort of read them, but my experience with haskell is limited/aged, so things about types being wrong seems to require me to know what kinds of types exist and are needed to make progress.  Trying to work my way up to that.
17:10:15 <trigone> mud: ok :/
17:11:08 <pacak> dsal: Looks like you can use tuples to work with data so no data types are required.
17:11:27 <dsal> Yeah, that'd be fine if I could get a list of lists of tuples.
17:11:39 <Axman6> why not just a list of tuples?
17:12:03 <dsal> Isn't a list of tuples just one row?
17:12:16 <Axman6> no, the tuple represents the row
17:12:34 <dsal> Oh.  Oh, I see -- you mean without the names?
17:12:38 <Axman6> of, you can use the named record stuff to get a list of hashmaps to bytestrings
17:12:55 <Welkin> > let maybeToEither :: Maybe a ~> Either () a; maybeToEither (Just a) = pure a; maybeToEither Nothing = pure () in maybeToEither (Just 3)
17:12:57 <lambdabot>  error:
17:12:57 <lambdabot>      Not in scope: type constructor or class ‘~>’
17:13:00 <Welkin> hm
17:13:14 <Axman6> pue () is wrong
17:13:24 <Axman6> you want Left ()
17:13:51 <pacak> ~> - natural transformation?
17:14:02 <pacak> It should be Maybe -> Either () then...
17:14:10 <Axman6> beat me to it
17:14:12 <pacak> -~
17:14:14 <pacak> ~>
17:14:25 <trigone> if i use qualified imports, will it also force me into qualifying the operators?
17:14:37 <Axman6> you can import twice
17:14:37 <monochrom> Yes.
17:14:40 <pacak> trigone: You can import operators separately
17:14:47 <monochrom> > 2 Prelude.+ 3
17:14:50 <lambdabot>  5
17:14:51 <Welkin> what is the applicative instance for Either?
17:14:56 <Welkin> or, Either ()
17:14:58 <Welkin> for example
17:14:58 <Axman6> import qualified Foo  as F; import foo ((.@$#),(@$@))
17:15:05 <Welkin> the haddocks aren't helping here
17:15:15 <trigone> hm sucks a bit...
17:15:17 <Welkin> the link to the source just takes me to the hugefile for GHC.Base
17:15:27 <trigone> i'll do that
17:15:29 <Axman6> > (,) <$> Right True <*> Right False
17:15:31 <trigone> thx
17:15:31 <lambdabot>  Right (True,False)
17:15:36 <Axman6> > (,) <$> Right True <*> LEft False
17:15:38 <lambdabot>  error:
17:15:38 <lambdabot>      • Data constructor not in scope: LEft :: Bool -> Either a1 a
17:15:38 <lambdabot>      • Perhaps you meant ‘Left’ (imported from Data.Either)
17:15:45 <Axman6> > (,) <$> Right True <*> Left False
17:15:47 <lambdabot>  Left False
17:15:50 <Welkin> that is a tuple
17:16:24 <Axman6> Welkin: it's the "pick the first failure" implementation basically
17:16:25 <Welkin> and yes, I am investigating natural transformations
17:16:53 <trigone> Welkin: pure = Right, and f <*> a return either Right if both args are Right, or the first Left
17:17:15 <trigone> that is, the left which is equal to f
17:17:28 <Axman6> pure a = Right a; Right f <*> Right x = Right (f x); Left e <*> _ = Left e; _ <*> Left e = Left e
17:18:06 <monochrom> I don't think you can keep the e.
17:18:27 <Axman6> hmm?
17:19:07 <trigone> > Left "a"<*> Right 3
17:19:07 <monochrom> Oh, nevermind, it's good.
17:19:09 <lambdabot>  Left "a"
17:20:09 * hackagebot master-plan 0.1.0.0 – The project management tool for hackers – https://hackage.haskell.org/package/master-plan
17:22:11 <trigone> is it always legal to write constraints separately (aka a => b => c => x -> y)
17:22:22 <panthercat> what is a monad?
17:22:37 <Welkin> I've never tried
17:22:40 <Axman6> anything you can define the functions return :: a -
17:22:41 <Welkin> I was assume
17:22:57 <Axman6> > a -> m a, and join m (m a) -> m a, which abides by some laws
17:22:59 <lambdabot>  <hint>:1:3: error: parse error on input ‘->’
17:23:05 <Axman6> bleh
17:23:11 <erisco> panthercat, you can read here https://wiki.haskell.org/Monad or in a Haskell book and if you have a specific question ask here
17:23:14 <Welkin> panthercat: monads are like burritos
17:23:17 <Welkin> or tacos
17:23:29 <trigone> space suits
17:23:29 <panthercat> explain burritos?
17:23:32 <Axman6> can we please drop that shitty meme?
17:23:34 <Welkin> panthercat: they taste good
17:23:42 <panthercat> haha thanks
17:23:47 <monochrom> The burrito thing is an insider joke.
17:23:57 <trigone> i eat monads for breakfast
17:23:59 <Psybur> Another good way to describe them is that they are values wrapped up in a special context
17:24:35 <Welkin> http://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf
17:24:53 <monochrom> Fictional value and fictional wrapping.
17:25:29 <Welkin> http://chrisdone.com/posts/monads-are-burritos
17:25:31 <Welkin> there you go
17:25:33 <monochrom> Because for example if you're using parsec and you have "Parser Int", there is no Int value inside and there is no wrapping.
17:25:40 <monochrom> But you can pretend there is.
17:26:07 <trigone> Welkin: lol
17:26:14 <monochrom> which makes you feel comfortable but it doesn't work.
17:26:47 <monochrom> Because for example there can be a parse error so your Int value goes down the drain and the wrapping dream bursts.
17:26:47 <Axman6> it's a computation which may produce an Int, and if it does, because it is a monad, other computations can depend on that Int's value to make decisions
17:27:29 <Welkin> the easiest way to explain monads to a javascript programmer: monads are like promises
17:27:44 <Axman6> well, promices are monads
17:27:51 <systemfault> They're not...  :(
17:27:57 <Axman6> promises*
17:28:02 <systemfault> They f'ed them up...
17:28:04 <monochrom> Or more fundamentally, you have "xxx :: Parser Int" and you just let it sit there and you don't run it. So there is no Int value to begin with.
17:28:06 <Welkin> I'm not sure if they really are
17:28:09 <Welkin> but they sure are similar
17:28:11 <trigone> Axman6: well that's overbritish for you
17:28:11 <Axman6> bleh, of course they did
17:28:24 <monochrom> Instead xxx is a recipe for parsing.
17:28:30 <Axman6> promouces
17:28:34 <systemfault> Welkin: They're close but they have an auto "join" so you can't nest them
17:28:45 <Welkin> proumaeces
17:28:59 <Axman6> systemfault: why even does that >_<
17:29:06 <systemfault> Promise.resolve(Promise.resolve(10)) is equal to Promise.resolve(10) :(
17:29:18 <Axman6> that's retarded
17:29:23 <systemfault> Axman6: So you can have .then be both .map and .flatmap
17:29:29 <Axman6> it's like Java's Optional, where you can't have Just null
17:29:39 <Welkin> systemfault: there are people who claim that they are exactly monads, which other poeple who don't know what monads are continue to spread
17:29:40 <monochrom> And you do something like "xxx >>= \n -> replicateM n anyChar" to compose a bigger recipe from two smaller recipes. The whole thing is still a recipe, nothing wrapped inside.
17:29:49 <systemfault> Welkin: I know :/
17:30:38 <monochrom> A monad lets you write down a recipe by composing basic recipes into one compound recipe.
17:30:48 <Welkin> panthercat let
17:30:52 <Welkin> left*
17:31:18 <monochrom> A parser "wraps a value" as much as your unix ls "wraps a directory list".
17:32:41 <monochrom> And free monad means taking this recipe writing to the extreme, in which the recipe is just dead data sitting around incapable of acting.
17:33:28 <trigone> like a burrito as a box with all ingredients separated, displayed in order though
17:34:14 <monochrom> You are taking burritos too seriously. It was a joke. And there is no ingredient inside a parser or unix's ls either.
17:34:41 <trigone> monochrom: no, you are taking what i said too seriously, it was a joke.
17:34:52 <monochrom> OK har har har
17:35:04 <trigone> and i was talking of the free monad
17:35:18 <systemfault> ❤️🌯 
17:35:35 <monochrom> But I am tired of burrito jokes.
17:35:41 <trigone> it's like a poor burrito ingredient set not yet combined which you can't even chew on...
17:35:49 <Welkin> what about a deconstructed burrito?
17:36:04 <bbear> with which monad should I work ?
17:36:07 <trigone> monochrom: if you want i can try with space suits, though i still haven't gotten that one
17:36:12 <bbear> I don't do a lot of do notation
17:36:13 <Welkin> bbear: ContT
17:36:13 <monochrom> But I was the inventor of the "Applicative is curry burrito" joke.
17:36:21 <bbear> actually I prefer operators
17:36:30 <bbear> :t ContT
17:36:31 <lambdabot> forall k a (m :: k -> *) (r :: k). ((a -> m r) -> m r) -> ContT r m a
17:36:51 <Welkin> bbear: for long expressions with lots of variables it can get messy using combinators
17:37:00 <bbear> yes
17:37:23 <bbear> actually I fell like the proper use of the do notation is a strength rather than a weakness, but I can't understand it fully
17:37:31 <bbear> So I can't use it to its full potential.
17:37:38 <Welkin> understand what?
17:37:42 <monochrom> It is always a strength to use anything properly.
17:37:43 <bbear> do notation
17:37:54 <Welkin> it's just like this
17:38:02 <trigone> Welkin: though very often in my experience it means you should refactor, put some code away in some function etc
17:38:11 <Welkin> `a <- ma` is `ma >>= \a -> ...`
17:38:18 <bbear> I know how to use it with the IO Monad, but not with other monads, like lists, Maybe, etc.
17:38:28 <search> hello
17:38:30 <bbear> it can be quite useful with Maybe actually.
17:38:31 <Welkin> it's the same for anything
17:38:38 <trigone> do notation is just sugar. just learn how to read it in both sugared and unsugared form, and translate it.
17:38:50 <Welkin> what I typed above is the entire description of do notation
17:39:03 <monochrom> list example: do { x<-[1,2,3]; y<-[x .. x+3]; return (x*y) }
17:39:19 <trigone> Welkin: nah there's the let thingy too
17:39:30 <monochrom> But perhaps you mean you don't know what >>= does to list.
17:39:45 <koz_> I'm trying to follow this: http://dev.stephendiehl.com/hask/#typelevel-numbers to write something, but it's not happening for me: http://lpaste.net/357662
17:39:46 <Welkin> trigone: that works the same way, you just add an `in`
17:39:48 <bbear> monochrom: yes
17:39:48 <monochrom> "let" is simply translated to "let ... in ..."
17:40:09 <monochrom> >>= for list is concatMap flipped
17:40:35 <bbear> ha ok
17:40:43 <trigone> monochrom: not sure many people use concatMap very often
17:40:47 <Welkin> lol
17:40:49 <Welkin> concatMap
17:40:51 <bbear> I use it all the time
17:40:52 <Welkin> the source of evil
17:40:59 <search> can anyone recommend sites or a site for learning programming?
17:41:01 <bbear> why are you saying it is evil ?
17:41:07 <monochrom> Oh I don't need them to use it. I just need them to look at the name and guess what it does.
17:41:16 <Welkin> it's why some other languages (like scala) call >>= "flatmap" 
17:41:17 <Welkin> ew
17:41:27 <trigone> well then i just haven't fallen across many usage cases i guess
17:41:59 <Welkin> search: that is a very broad request. Porgramming what exactly?
17:42:01 <Welkin> programming*
17:42:21 <bbear> > concatMap (\x->http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x) [1,2,3]
17:42:21 <lambdabot>  <hint>:1:62: error:
17:42:21 <lambdabot>      parse error on input ‘=’
17:42:21 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:43:05 <bbear> > concatMap (\x->[x]) [1,2,3]
17:43:05 <lambdabot>  [1,2,3]
17:43:05 <monochrom> I don't think even "flatmap" is an evil name. It is a very honest and to-the-point name.
17:43:07 <systemfault> bind doesn't mean much to me...
17:43:07 <Welkin> :t concatMap
17:43:07 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
17:43:07 <Welkin> :t concat . map
17:43:07 <systemfault> flatmap is clearer... it's map and join
17:43:07 <monochrom> Because >>= is equivalent to fmap and then join. It's a monad law.
17:43:07 <lambdabot> Foldable ((->) [a]) => (a -> a1) -> [a1]
17:43:10 <koz_> systemfault: Wouldn't 'joinMap' be a better name by that logic?
17:43:22 <monochrom> And join really looks like flattening because the type goes "M (M a) -> M a" you are honestly collapsing two levels into one.
17:43:35 <systemfault> koz_ :p
17:43:49 <bbear> flatmap is flat 
17:43:52 <bbear> concatMap is shiny
17:43:53 <Welkin> :t concat (.).(.) map
17:43:55 <lambdabot> error:
17:43:55 <lambdabot>     • Couldn't match expected type ‘(a2 -> [a] -> [b]) -> c’
17:43:55 <lambdabot>                   with actual type ‘[a1]’
17:44:00 <search> well database is what i want to learn .. and python then some front end but start with whichever iv been to a few sites they are not great but they are also super basic ie w3schools codeacademy etc
17:44:11 <bbear> concatMap just concat the map
17:44:13 <trigone> concatMap is a kitty
17:44:16 <Welkin> search: this is a haskell channel
17:44:36 <koz_> I'm trying to follow this: http://dev.stephendiehl.com/hask/#typelevel-numbers to write something, but it's not happening for me: http://lpaste.net/357662 <-- if anyone could help direct me, I'd be awfully grateful
17:44:52 <search> yes .. ok not sure what that is i asked in a phthon channel a recomended channel someone pointed me here
17:45:05 <koz_> search: I believe this is what people call 'trolling'. :P
17:45:11 <bbear> systemfault: you know that bind is from the same indo-european root as the name « bandha » in sanskrit ?
17:45:17 <search> no i am not trolling trust me
17:45:22 <Welkin> bbear: what about behen di?
17:45:23 <koz_> search: I didn't mean that you were.
17:45:26 <Welkin> bhen di*
17:45:26 <systemfault> bbear: No, not at all
17:45:38 <search> oh they were messing me with?
17:45:39 <koz_> I meant that this is what you're undergoing as part of having Python folks refer you here.
17:46:09 <bbear> it seems to be the same root as for « bander » (french word that means « to tie »)
17:46:09 <Welkin> python programmers are snakes that cannot be trusted
17:46:17 <koz_> Welkin: Hurr hurr. :P
17:46:22 * koz_ mentions something about apples/.
17:46:25 <search> ok so i should stay away from phthon]
17:46:28 <search> noted
17:46:28 <Welkin> like bender?
17:46:29 <search> lol
17:46:48 <trigone> bbear: bander doesn't mean that at all
17:46:59 <bbear> trigone: it depends
17:47:06 <Welkin> "bhen di" is still better
17:47:16 <trigone> bbear: give me an example?
17:47:18 <bbear> what does it mean and from which language does it come ?
17:47:34 <Welkin> punjabi :P
17:47:39 <bbear> « bander ses muscles » « bander un arc »
17:47:44 <pacak> phthon... That's from Lovecraft...
17:47:52 <koz_> pacak: LOL.
17:48:03 <search> ok i will try to ask another question with more info this time...
17:48:07 <bbear> also the word « bandage »
17:48:08 <systemfault> Bander is french is to put a bandage... or to blindfold... etc.
17:48:27 <pacak> Short for Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn.
17:48:29 <bbear> ok but it is tied to bind semantically
17:48:34 <bbear> haa
17:48:46 <search> where would you recommend a newbie programmer .. knows some front end wants to expand knowledge to anything and everything.. 
17:48:53 <bbear> Java 
17:48:54 <trigone> bbear: you say "tie muscles" and "tie a bow"?
17:48:57 <bbear> no
17:48:58 <search> a website , channels etc
17:49:00 <bbear> you get the point
17:49:16 <koz_> search: 'Everything and anything' is horribly vague.
17:49:26 <bbear> search: the only stuff that could help you is a C programming book, a compiler and vim.
17:49:31 <bbear> Learn vim first :|
17:49:48 <search> ok i can get vim 
17:49:56 <search> does it work with my linux
17:50:05 <systemfault> Seriously... don't spend a year on vim if the idea is to learn Haskell..
17:50:05 <Welkin> search: well, you are here, so you may as well learn haskell
17:50:09 <monochrom> OK so you're saying if I translate >>= to English (so, "bind") and then translate to French and then to Russian then to Hindu and then to German and then to Italian and then ... etc etc ... and then finally back to English, it becomes "duct tape"? So monadic programming is duct tape?
17:50:09 <systemfault> Just get VSCode + Haskero and be happy.
17:50:11 <Welkin> it will equip you to learn any other kind of programming
17:50:16 <pacak> Haskell works just fine with linux.
17:50:23 <pacak> Better than on any other OS i think.
17:50:29 <pacak> Haskell - ghc.
17:50:58 <koz_> I'm trying to follow this: http://dev.stephendiehl.com/hask/#typelevel-numbers to write something, but it's not happening for me: http://lpaste.net/357662 <-- If anyone could have a look and advise me, I'd be very grateful.
17:51:14 <search> by everything and anything i mean c++ java and haskell  just examples 
17:51:29 <trigone> monochrom: in theory translation should not destroy meaning. that's not translation that's etymological transposition or whatever, regardless of the meaning of the words (like bbear's bander)
17:51:44 <search> ok ill get to reading on haskell ill download vim 
17:51:48 <bbear> monochrom: Bandha (Sanskrit: बंध) means "bond; contracting"
17:51:55 <search> and ill download vim***
17:52:17 <monochrom> But I like my duct tape idea so much!
17:52:21 <bbear> monochrom: I think you were to the point
17:52:37 <bbear> words are vehicles for ideas, sometimes the word stay the same and the idea is slightly modified.
17:52:48 <monochrom> Because if an engineers asks "what is a monad?" and if I answer "it is about duct tape" I think they will like it very much. :)
17:52:55 <bbear> duct-tape programming is a funny idea
17:53:11 <trigone> to me it rings a bit like duck typing
17:53:34 <Welkin> bbear: yes, but what about bhen di?
17:53:42 <monochrom> conduits and pipes do duct typing :)
17:54:01 <erisco> I come back and everyone is brandishing their pedantry pikes
17:54:13 <koz_> erisco: I favour a pedantry halberd myself.
17:54:22 <Welkin> search: c++ is only used in very specific kinds of programming (very low-level) and java is extremely outdated
17:54:35 <trigone> what's a pike?
17:54:41 <bbear> Welkin: no idea
17:54:43 <erisco> a type of fish
17:54:47 <Welkin> all languages are not alike, and you won't be able to (or have the motivation to) learn everything, nor should you
17:54:53 <trigone> erisco: what?
17:55:07 <search> shall i try to explain what i want to program maybe that would be a good idea
17:56:29 <koz_> erisco: In that case, a pedantry haddock. :P
17:56:29 <bbear> search: if I was you I'd start with python or Haskell
17:56:29 <trigone> a haddock is a fish?
17:56:29 * mniip slaps koz_ with a rainbow trout
17:56:29 <bbear> trigone: yes
17:56:29 <trigone> i thought it referenced tintin
17:56:29 <koz_> mniip: Ow.
17:56:29 <trigone> (for some reason)
17:56:29 <monochrom> I know for sure from playing AoE2 that a pike is an older, un-upgraded halberd
17:56:29 <bbear> it is kind of salted fish
17:56:29 <koz_> bbear: You can eat haddock unsalted too.
17:56:29 <bbear> captain Haddock is himself referencing to this kind of fish.
17:56:29 <trigone> bbear: yeah that's what i just gathered :)
17:56:29 <bbear> http://seafoodfromnorway.co.uk/contentassets/ad4cda9a1f7f4ee5846d2f1344c521b9/204261012
17:56:29 <Welkin> search: my reccomendation would be either learn haskell or javascript. Ideally, learn both.
17:56:29 <bbear> koz_: I don't eat so much haddock.
17:56:43 <Welkin> recommendation*
17:56:44 <pacak> Welkin: Most and least insane languages? O_o
17:56:54 <search> ok dokee
17:56:57 <trigone> lol you forgot bash :P
17:56:59 <bbear> I don't see how javascript could be a good beginner's choice.
17:57:02 <search> will look into it
17:57:03 <monochrom> No. Just web programming.
17:57:11 <bbear> yes, it is maybe a good choice.
17:57:22 <monochrom> Welkin is heavily invested in web programming, so that's all he will ever recommend.
17:57:24 <Welkin> pacak: javascript is probably the best "first language" that anyone can pick up quickly that can introduce them to functional programming (it has first-class functions) and is immediately useful with a huge ecosystem
17:57:26 <koz_> bbear: Perhaps you should.
17:57:30 <search> well the two things i want to do is program a app for android
17:57:39 <trigone> is purescript not a haskel-based js alternative? as in, compiles to the latter?
17:57:41 <monochrom> Likewise if you happen to ask a physicist, they may recommend Fortran instead.
17:57:44 <trigone> mind you i never used it
17:58:46 <search> and create my own search engine very basic one but in anycase a search engine not search everything there is out there just a few or one topic but a lot of info and websites in it .. all for personal use im not doing this for scchool or a job
17:59:08 <Welkin> trigone: yes
17:59:08 <bbear> the way you are doing prototyping of object in Javascript...
17:59:09 <mud> bbear: It has lowish barrier of entry (aka how long it takes until something you write actually does useful things), is used in a ton of places, has a decent community and okay learning materials (though you have to pick the right ones), etc.
17:59:09 <bbear> absence of strong typing.
17:59:09 <Welkin> bbear: I pretend prototypes don't exist
17:59:09 <bbear> what 
17:59:09 <Welkin> I never touch them or need to use them
17:59:09 <trigone> bbear: tss not one js prog out of ten knows how prototypes work, even if it's one of the simplest systems ever
17:59:09 <pacak> Welkin: Well.... With non-associative addition and a bunch of other funny things javascript feels like a wrong language to start with.
17:59:09 <bbear> ok so for basic algorithms it is ok.
17:59:09 <mud> It's not my first recommendation for languages though, it's one where you have to be careful you don't use a bunch of features, and it has some big surprises hiding all over.
17:59:12 <bbear> python is good for beginners but ultimately it doesn't learn you so much.
17:59:24 <search> i will definetly look into haskell javascript tho either way also c++
17:59:30 <trigone> bbear: teach. you french?
17:59:40 <bbear> yes
17:59:47 <trigone> me too ^^
17:59:52 <mud> C++ I'd specifically recommend you avoid unless you really need it. It's the one language I regret spending as much time on as I have.
18:00:01 <bbear> you don't learn so much from it
18:00:03 <Welkin> frenchies?
18:00:07 <bbear> I am living in Paris
18:00:09 <Welkin> prove it! speak french!
18:00:14 <trigone> Welkin: that's not an appropriate plural
18:00:15 <bbear> yes I can ! 
18:00:23 <search> ok no c++ got it
18:00:26 <monochrom> I thought they did. Bander etc.
18:00:51 <trigone> La vache produisait des pirouettes
18:00:56 <bbear> «It's the one language I regret spending as much time on as I have.» <- Could say the same with a lot of things in my life.
18:01:03 <search> basically i need to learn backend database and password protection stuff i can find and do some front end my problem is back end
18:01:12 <bbear> There has been a haskell meet up recently in Paris.
18:01:20 <monochrom> Yes I am very happy I never learned yacc.
18:01:22 <bbear> search: then learn a framework 
18:01:29 <trigone> bbear: i'm a southerner, it's too far away
18:01:45 <Welkin> bbear: so have oyu run into alpounet?
18:01:47 <bbear> node.js/javascript, django/python, play/scala
18:01:56 <bbear> alpounet ?
18:02:03 <bbear> qu'est-ce que c'est que cette chose
18:02:11 <bbear> je ne parle jamais français sur IRC
18:02:17 <erisco> there's no need to regret time spent... it just took that long to learn :)
18:02:24 <trigone> sounds like a cute little leprechaun's name
18:02:38 <trigone> moi non plus
18:02:57 <Welkin> oops
18:03:01 <Welkin> I meant alpmestan
18:03:13 <trigone> erisco: i think overall what you mean is there's no need to regret nothing
18:03:19 <Welkin> maybe they are the same person
18:03:41 <Welkin> he is in france
18:03:47 <trigone> alpmestan and alpounet walk into a bar...
18:04:57 <Welkin> oh!
18:05:00 <Welkin> game of thrones started
18:06:12 <bbear> I got to sleep 
18:06:14 <bbear> bye
18:06:30 <bbear> with construct are monadic a little bit isn't it ?
18:06:42 <bbear> when you put things between curly braces.
18:07:05 <erisco> what is "with construct"?
18:08:56 <search> i found a book i can read online a haskell book 
18:09:55 <bbear> when you put with { a=2; b=3 }
18:09:59 <bbear> behind your function.
18:10:16 <bbear> It looks like a special referential, you can do multiple assignation that work through all the curly brances
18:10:18 <bbear> braces
18:10:21 <erisco> bbear, are you talking about record notation? I don't know what you are referring to
18:11:20 <bbear> http://vpaste.net/0YdFX
18:11:42 <erisco> in that case both the braces and the semicolons are redundant
18:12:18 <erisco> alternatively to layout (i.e. line returns and indentations) you can use braces and semicolons
18:12:51 <bbear> yes
18:13:05 <erisco> I would not be surprised if GHC actually first translates layout to braces and semicolons
18:13:18 <erisco> well, it has nothing to do with Monad
18:13:50 <bbear> it is kind of imperative since you can chain operations depending on each others.
18:14:20 <erisco> there is nothing being chained, they are just definitions
18:14:30 <erisco> there is no operation between them
18:14:36 <bbear> http://vpaste.net/9UQtx
18:14:46 <bbear> ok
18:15:54 <erisco> note you can also have  { a = b * 2; b = 3; }
18:16:28 <erisco> the order the definitions are written in is not relevant
18:18:41 <trigone> hi again! could you tell me if i reinvented the wheel, or if you can build that function with notorious other function: http://lpaste.net/357663
18:20:14 <trigone> (actually i just annotated it cuz i had made a typo in a comment, but both versions are identical, don't try finding the difference)
18:22:55 <trigone> nobody?
18:23:02 <koz_> trigone: I'm lookin'.
18:23:21 <koz_> I have an idea, but I need to double-check first.
18:23:36 <dbousamra> Is it possible to use env vars from within GHCI? I.e. I want to call my main passing in vars: :main create-experiment -a $ENV_VAR
18:24:10 <trigone> koz_: ok thx :)
18:24:30 <eacameron> dbousamra: I'd recommend making an alternative main that takes arguments as a string instead of from getArgs
18:24:38 <eacameron> Then you can just pass the string in GHCi
18:25:08 <eacameron> devMain args = ...
18:25:16 <eacameron> main = devMain =<< getArgs
18:28:40 <dbousamra> eacameron: Thanks. I was hoping to test my parser interactively, but using env vars rather than hard coded strings
18:30:16 <dmj`> dbousamra: you can see what is present by doing > :! export
18:30:39 <trigone> koz_: in the end, the function acts a lot like a mix between fmap and a fold (i think), except it uses callbacks
18:31:03 <koz_> trigone: I had an idea about it, but now I realised it won't work. Sorry, not sure if there's anything pre-existing for this.
18:31:42 <trigone> koz_: hm ok, nvm... maybe there's sth to work with CPS, but i'm not really knowledgeable in that... what was your idea by curiosity? 
18:31:51 <koz_> trigone: Comonads.
18:32:25 <trigone> k, thx for trying :)
18:34:55 <search> thanks for all the info so far just downloading the things to get going on haskell now:}
18:35:55 * hackagebot composition-prelude 0.1.0.3 – Higher-order function combinators – https://hackage.haskell.org/package/composition-prelude
18:37:48 <trigone> koz_: oh, actually it already exists, i didn't try hoogle bc i doubted it could work but someone wrote one and called it withMany, which is rather apt
18:38:57 <trigone> and it's in base! in Foreign.Marshal.Utils. what does marshalling mean?
18:39:11 <koz_> trigone: Serialization, normally.
18:40:07 <trigone> what's serialization?
18:40:24 <koz_> Converting data into a form from which it can be 'read back in' again.
18:41:24 <trigone> ok... i don't really see why this function is there but whatever. and their definition is much better than mine.
18:41:49 <koz_> trigone: Given your use case, I'm a bit surprised you don't see it.
18:42:10 <trigone> well then maybe i didn't really get the notion of serialization...
18:42:18 <erisco> serialise :: A -> String; deserialise . serialise = id
18:42:43 <erisco> you want this to send data over a network or save it to disk
18:42:52 <koz_> Where 'String' could be binary.
18:43:06 <koz_> (as opposed to actual textual data)
18:43:06 <erisco> well it can be Text, a bit field, or whatever
18:43:31 <trigone> hm ok get it
18:44:49 <trigone> thx :)
18:48:27 <trigone> is there a library for basic Maybe utilities, like f n = if n < 0 then Nothing else Just n
18:50:48 <erisco> trigone, n <$ guard (n < 0)
18:51:58 <erisco> or  guard (n < 0) $> n   if you prefer :)
18:52:36 <koz_> trigone: Guard is actually more general than this, as it works with any Alternative. So it can be used for more things too.
18:53:13 <erisco> though I think I got the logic backwards, heh
18:53:17 <erisco> well that is easy to fix
18:56:09 <trigone> hm i didn't think of using guard... is there an equivalent to guard which would work as such: Just 4 >>= guard' (> 0)
18:56:19 <trigone> aka taking a function instead of a boolean value
18:56:54 <trigone> > a = Just 4 >>= _ (> 0)
18:56:57 <lambdabot>  <hint>:1:3: error:
18:56:57 <lambdabot>      parse error on input ‘=’
18:56:57 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:57:05 <trigone> > let a = Just 4 >>= _ (> 0) in a
18:57:07 <lambdabot>  error:
18:57:07 <lambdabot>      • Found hole: _ :: (Integer -> Bool) -> Integer -> Maybe b1
18:57:07 <lambdabot>        Where: ‘b1’ is a rigid type variable bound by
18:57:44 <erisco> > mfilter (> 0) (Just 4) -- trigone
18:57:46 <lambdabot>  Just 4
18:58:23 <trigone> :t mfilter
18:58:25 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
18:59:06 <trigone> erisco: thx that's perfect :)
18:59:36 <trigone> in which case, is there a library of utils for typical tests like (>=0)?
18:59:57 <trigone> is monadplus in base?
19:00:13 <erisco> you can look all of this up with Hoogle, Hayoo, and Hackage
19:00:21 <koz_> erisco: Is there an mfilter alternative for, well, Alternative? :P
19:01:12 <erisco> koz_, no
19:01:21 <koz_> erisco: :(
19:02:12 <trigone> koz_: don't you need the power of monads to choose an effect from the value of a monadic value?
19:02:37 <koz_> trigone: guard has an Alternative constraint. You tell me. :P
19:02:57 <trigone> :t guard
19:02:59 <lambdabot> Alternative f => Bool -> f ()
19:03:28 <trigone> koz_: bc guard takes a naked bool, it doesn't depend on the previous value, it's you who provide the n in guard (n > 0)
19:03:50 <koz_> trigone: Ah, I see. Point taken.
19:05:45 <trigone> mfilter is a bit of a mouthful though...
19:06:32 <koz_> trigone: I ... don't see how.
19:06:39 <koz_> I pronounce it 'muh-filter'.
19:06:56 <trigone> btw, is there a sugar syntax that is based on mfilter? like guard in list comprehensions
19:06:57 <koz_> Although I guess 'emm-filter' is also possible.
19:07:51 <trigone> koz_: i don't mean pronounced out loud, i just mean, seven letters :P
19:08:25 <erisco> are you golfing?
19:08:28 <trigone> @pl \f g h a -> f a `h` g a
19:08:28 <lambdabot> flip . (ap .) . flip (.)
19:08:38 <trigone> erisco: what? ^^
19:08:43 <koz_> trigone: Have you used Control.Lens? You'll love their .!^%&* operators! :P
19:08:46 <erisco> are you code golfing?
19:09:01 <trigone> koz_: lol you kid me, that's not a real op is it??
19:09:08 <trigone> erisco: what does that mean?
19:09:10 <koz_> trigone: No, but I exaggerate only slightly.
19:09:23 <koz_> trigone: Code golf = writing working code in as few characters as possible.
19:09:33 <erisco> it means you are trying to make the smallest program textually that accomplishes a given task
19:09:37 <trigone> koz_: you scared me cold for a while :P proof lens's reputation is pretty scary :P
19:10:35 <koz_> trigone: By way of example: http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Lens.html#v:-37--37--64--126-
19:11:05 <trigone> erisco: well, no, but if i got to repeat a function name several times... i prefer four letters to seven ^^
19:11:06 <koz_> By way of even more clear example: http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Lens.html#v:-60--60--37--64--61-
19:11:12 <trigone> koz_: thta's still only four characters
19:11:25 <geekosaur> lens's operators at least are consistent and easily understood once you know its naming convention
19:11:27 <trigone> and relatively readable (if you know the conventions which i assume exist)
19:11:32 <koz_> trigone: My point was that brevity isn't necessarily a virtue.
19:11:33 <geekosaur> they're not just random symbols
19:11:36 <erisco> trigone, let l = mfilter in ...
19:12:32 <trigone> erisco: i prefer avoiding aesthetic aliases, it just adds a new bunch of things to translate for no reason
19:12:38 <trigone> (in my mind)
19:12:51 <erisco> then what are you asking for
19:13:45 <trigone> :t \xs -> sequence $ fmap mfilter xs
19:13:47 <lambdabot> (MonadPlus m, Traversable t) => t (a -> Bool) -> m a -> t (m a)
19:14:11 <trigone> wait what
19:14:23 <trigone> :t mfilter
19:14:25 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
19:14:29 <trigone> :t traverse
19:14:30 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:14:56 <erisco> trigone, if you reorder your arguments to  \h f g a -> f a `h` g a  then this is liftA2
19:14:57 <koz_> :t sequence
19:14:58 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:15:19 <trigone> erisco: oh ok thx
19:15:37 <trigone> :t liftA2
19:15:38 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:15:58 <koz_> liftA2 is super-fmap. :)
19:16:02 <trigone> oh, again this evil (-> r) monad
19:16:18 <erisco> no, the (->)a Applicative
19:16:27 <wilornel> Cabal seems to hang a lot 
19:16:35 <trigone> yeah whichever, i can't bear it
19:16:46 <koz_> erisco: Yeah, for super-fmap, you need a super-Functor, which an Applicative is.
19:17:16 <erisco> koz_, is that a CT designation? doesn't sound obtuse enough
19:17:31 <koz_> erisco: Clearly it isn't, then. :P
19:17:42 <koz_> Not all of us can talk effortlessly about Joe zygomorphisms. :P
19:18:33 <trigone> :t mfilter (>0)
19:18:34 <lambdabot> (Num a, Ord a, MonadPlus m) => m a -> m a
19:19:10 <trigone> wait it's taking a monadic value as input?
19:19:28 <erisco> that seemed to be what you were asking for
19:19:38 <trigone> > Just 4 >>= mfilter (>0)
19:19:40 <lambdabot>  error:
19:19:40 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M597266017384...
19:19:40 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
19:19:54 <erisco> no,  mfilter (>0) (Just 4)  as I showed you :)
19:20:28 <trigone> erisco: yeah but i'd prefer using it as a kleisli arrow
19:20:50 <erisco> you're quite needy
19:21:03 <trigone> :P
19:21:22 <erisco> :t mfilter (>0) . return
19:21:24 <lambdabot> (Num a, Ord a, MonadPlus m) => a -> m a
19:21:39 <trigone> yeah that's what i just found
19:22:22 <trigone> maybe there's an existing equivalent
19:22:35 <trigone> @hoogle (a -> Bool) -> a -> m a
19:22:35 <lambdabot> BlockId mapFilter :: (a -> Bool) -> map a -> map a
19:22:35 <lambdabot> Data.Function.Tools applyWhen :: Bool -> (a -> a) -> a -> a
19:22:35 <lambdabot> Data.Function.Tools applyUnless :: Bool -> (a -> a) -> a -> a
19:22:54 <trigone> @hoogle MonadPlus m => (a -> Bool) -> a -> m a
19:22:54 <lambdabot> Control.Monad mfilter :: (MonadPlus m) => (a -> Bool) -> m a -> m a
19:22:55 <lambdabot> Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
19:22:55 <lambdabot> Data.List.Class filter :: MonadPlus m => (a -> Bool) -> m a -> m a
19:23:34 <Welkin> the new episode of game of thrones was great :D
19:23:51 <trigone> @hoogle MonadPlus m => [a -> Bool] -> m a -> m a
19:23:51 <lambdabot> Control.Error.Safe foldr1Z :: (MonadPlus m) => (a -> a -> a) -> [a] -> m a
19:23:51 <lambdabot> Control.Error.Safe foldl1Z :: (MonadPlus m) => (a -> a -> a) -> [a] -> m a
19:23:51 <lambdabot> Control.Error.Safe foldl1Z' :: (MonadPlus m) => (a -> a -> a) -> [a] -> m a
19:23:58 <Welkin> maybe someone can come up with a monad analogy related to game of thrones
19:24:06 <Clint> aren't we watching it right now
19:24:12 <trigone> weird names, what's the Z for?
19:24:24 <erisco> trigone, there is a website
19:24:40 <trigone> for control.error.safe?
19:24:46 <Welkin> for hoogle
19:24:47 <erisco> for Hoogle
19:24:55 <Welkin> you can also install local hoogle and run it on your machine
19:25:12 <erisco> was quantum entangled with Welkin for an instant there...
19:25:19 <trigone> erisco: got it sorry for clustering your game of throne conversation :P
19:25:47 <trigone> *cluttering
19:26:51 <trigone> thx for the help everyone :)
19:29:27 <wilornel> How would I install a local version of a library with cabal?
19:29:36 <koz_> wilornel: Cabal sandbox.
19:30:02 <wilornel> `cabal sanbox init` and then `cabal install` is what I was doing before to make sure my dependencies were installed in the sandbox
19:30:30 <wilornel> but then how would I install a library that I have in ~/wdev/some_library ? where some_library is a fork with my changes in it
19:30:44 <search> downloaded program some errors.. does anyone know linux at all .. i know its not a linux room but they are bit of aholes in linux room .. 
19:31:14 <Welkin> there is a command for cabal that does that
19:31:21 <Welkin> or you can set it up through stack
19:31:39 <Welkin> I forget the command just now, but it's not hard
19:32:00 <wilornel> I'd rather not use stack, the three times  I tried to use it it did not work
19:32:06 <wilornel> I'm not sure what `$ cabal install Cabal/ cabal-install/
19:32:08 <wilornel> ` does
19:32:14 <Welkin> search: use stack to install haskell https://docs.haskellstack.org/en/stable/README/#quick-start-guide
19:32:28 <wilornel> no no no, no stack :(
19:32:32 <Clint> wilornel: you can have multiple things share the same sandbox
19:32:38 <wilornel> alright
19:33:01 <search> i went to haskell.org downloaded it already took 1 or more hours
19:33:17 <wilornel> I'm on MAc OSX
19:33:17 <wilornel> $ cabal install Cabal/ cabal-install/
19:33:24 <wilornel> I have to be in the directory which has the sanbox and the install the package, right?
19:33:32 <wilornel> this page does not show how : http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
19:33:36 <search> it identified i was on linux told me to type in command i did now i cant find what i downloaded it always happens
19:33:40 <wilornel> reading this now: https://www.haskell.org/cabal/users-guide/installing-packages.html
19:33:42 <geekosaur> without the slashes, probably
19:34:08 <wilornel> Legacy repositories
19:34:12 <wilornel> is what I needed
19:34:34 <Welkin> search: installing the binary distribution is more complicated than just using stack. You also need to install cabal (And bootstrap ghc). I would not recommend it for a beginner
19:35:03 <Welkin> I don't even use the bin dist any more. I just use stack (or sometimes nix)
19:36:02 <search> fair enough its already done it should be here glaskow compiler cabal and the stack tool all are installed
19:36:04 <wilornel> What are `key-threshold` and `root-keys` ?`
19:38:22 <Welkin> search: `stack new my-project simple --install-ghc` will create a new (basic) project skeleton in the directory my-project/
19:38:35 <Welkin> and it will install ghc, too
19:38:38 <wilornel> add-source!!!
19:38:42 <Welkin> oh yeah
19:38:46 <Welkin> add-source. that was it
19:38:56 <search> in terminal 
19:39:38 <Welkin> use `stack templates` to list the available templates
19:39:53 <search> ok ty ill try that
19:40:17 <wilornel> cabal sandbox add-source ~/odev/github ; cabal install --dependencies-only ; gives me "All the requested packages are already installed"
19:40:52 <wilornel> how can I force reinstall
19:41:32 <search> its making me download or install it appears in anycase its working ty
19:43:06 <wilornel> why cabal whyyyy
19:43:32 <search> welkin are u using linux as well
19:43:47 <Welkin> search: linux and mac
19:44:40 <search> cool man i hate windows id like to strangle the creator so to speak  figuratively  speaking
19:45:47 <search> im so happy then that you know how to use it like i said i love how little it is how nothing runs unless i make it but do not understand it just yet
19:48:24 <search> sweet its working dude your the man
19:50:53 <trigone> hi, is there an extension to define a scope, and esp local bindings, at a level in-between top-level declarations, and module scope?
19:53:05 <geekosaur> no, or at least not currently. I think it's been proposed
19:53:25 <trigone> unless one can pattern-match at top level? in which case one could define an n-uple with some where clause
19:54:08 <geekosaur> you can pattern match, it's just not very useful :)
19:54:31 <trigone> geekosaur: you can write sth like (f, g) = (f,g) where f = ...; g = ...?
19:54:47 <trigone> and it's like defining f and g at top level?
19:55:14 <geekosaur> you can write that but it doesn't define f and g usefully outside that expression
19:55:26 <trigone> geekosaur: you mean you can't use f and g?
19:55:29 <geekosaur> er, "usefully" is redundant there
19:55:54 <geekosaur> you can't; pattern variables are only in scope in that definition
19:56:00 <trigone> well then what's the point of allowing such thing?
19:56:08 <geekosaur> so you could write it, the compiler with warningson would warn you it's unreachable
19:56:43 <geekosaur> because it's reusing elements of syntax that by themselves are useful, but happen to add up to nothing at top level
19:57:25 <geekosaur> one of the downsides of consistency is that sometimes it's a foolish consistency :)
19:57:27 <trigone> yet if it weren't top level, it'd allow reaching f and g in whatever other binding before or after
19:57:47 <trigone> so you're saying, they kept the syntax, changed the meaning, and somehow it's consistent?
19:58:02 <trigone> (a meaning which makes the feature useless on top of it)
19:58:19 <trigone> it's very weird ^^
19:58:36 <geekosaur> they did not change the meaning specifically for that
19:58:59 <geekosaur> in fact arguably they did not change meaning at all
19:59:07 <geekosaur> can you write exressions at top level?
19:59:31 <trigone> geekosaur: well, in a where clause, if i write where x = f; (f, g) = (f,g) ..., x has access to f
19:59:58 <geekosaur> top level is already different. you are claiming meaning was specifically changed in some way here when in fact it's just the normal way top level is different
19:59:59 <trigone> if it's clearer i can write (f,g) = (f',g')
20:00:05 <geekosaur> it doesn't matter
20:00:34 <geekosaur> you haveyour incorrect model and want to retain it and complain that someone deliberately spiked something your incorrect model thinks makes sense
20:00:34 <trigone> geekosaur: ok ^^ well still, if top level meaning is different, keeping the syntax does not keep consistency
20:00:42 <geekosaur> it's of course not possible that your model is wrong
20:01:08 <geekosaur> where rewrites to let/in
20:01:16 <trigone> hm no that's not what i said, i just said, why do they allow top-level pattern matching if you can't do a thing about it
20:01:24 <geekosaur> you can't do the *in* at top level, because that is expression syntax
20:01:41 <trigone> hm, so it does is another syntax
20:01:54 <geekosaur> it does top level syntax which is not an expression
20:01:59 <trigone> wait, no, top-level is at least aesthetically inside a where clause
20:02:07 <trigone> the where clause of the module
20:02:33 <trigone> we could imagine a let ... in module ...
20:02:34 <geekosaur> it is inside a module's where clause, yes. which has different semantics from where attached to a binding, which becomes a let-in *inside the binding*
20:03:25 <trigone> geekosaur: ok, so, they kept "where", changed its meaning, and when the time came to allow or not pattern-matching, they allowed it even though it allows nothing. that resumes it?
20:03:29 <geekosaur> and let ... in module wouldn't help here, the scope wuld be the whole module still, you wanted local regions in a module
20:03:34 <geekosaur> sigh
20:03:43 <geekosaur> ok, fine, your model is the only possible correct one
20:04:00 <geekosaur> go correct the haskell language committe
20:04:18 <trigone> er no, i wanted local regions an hour ago, then i wondered why you could pattern match if you can't get out f or g. i don't see why you don't find that weird
20:04:41 <geekosaur> because things defined in the where of a module are intended for access from both inside and outside the module
20:05:15 <trigone> you lost me
20:05:34 <trigone> you said, you can pattern match, but you can't use f and g in other top-level bindings
20:05:53 <trigone> or at least i thought you said that
20:06:36 <geekosaur> as for the rest, contemplate https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5
20:06:36 <geekosaur> I did way that
20:07:08 <geekosaur> you continue to apply that in some way that is not consistent with how Haskell is actually defined, but instead with some incorrect notion you have of it where what actually happens is "inconsistent"
20:08:05 <nshepperd> http://lpaste.net/357665
20:08:21 <nshepperd> i'm not sure what either of you are claiming, but the above is what actually happens
20:08:24 <trigone> ok, just to be sure to speak the same thing, can you answer that question: http://lpaste.net/357666
20:08:29 <nshepperd> it seems normal to me
20:08:35 <geekosaur> hm, wait. actually you can do (f, g) = ... at top level, f and g are both defined within the module
20:08:54 <geekosaur> but not scoped as you asked, which was the context in which I said that
20:08:58 <trigone> so... what the hell?
20:09:24 <geekosaur> then you changed the context... of course that's my fault for not reading your mind?
20:09:25 <trigone> ok we misunderstood each other :)
20:09:27 <koz_> What exactly is the Store comonad?
20:09:42 <geekosaur> koz_, State with all arrows reversed
20:10:11 <geekosaur> State is (s -> (a, s)), Store is ((a, s) -> s)
20:10:31 <koz_> geekosaur: What... exactly can you use it for?
20:10:32 <trigone> geekosaur: i wasn't clear enough, it was clear in my head that you wanted f and g part of the global scope, using the pattern-matching where clause to apply local binding. after all i don't see another purpose to creating sub-module local binding...
20:10:42 <nshepperd> i don't nderstand what it means to be between top-level and module scope, they seem like the same thing to me
20:11:03 <nshepperd> unless "module scope" means qualified imports
20:11:05 <MarcelineVQ> maybe they're referring to what's exported by module scope?
20:11:06 <trigone> (than to use it to define top-level binding with special local and esp *shared* namespace)
20:11:09 <geekosaur> nshepperd, I understood that to be like doing let ... in <top level bindings> at module level
20:11:25 <geekosaur> so you have bindings that are local to a group of definitions that are themselves top level
20:11:33 <geekosaur> I think smlnj allows that kind ofg hting?
20:11:38 <geekosaur> oy, whereis my typing
20:11:42 <trigone> geekosaur: well then was that not what having a where clause over a pattern-matched nuple would achieve?
20:12:03 <trigone> *is
20:12:20 <MarcelineVQ> geekosaur: idris has some things a tiny bit like that iirc
20:12:24 <nshepperd> ok yeah that's basically what you get if you do '(x, y, z) = (x, y, z) where { define the stuff... }'
20:12:37 <geekosaur> trigone, I think it's a bit more complex than that. in particular it may evaluate more than you expect
20:13:06 <geekosaur> althouugh I may not understand what you're asking at this point
20:13:13 <trigone> what would it evaluate and i'd not expect it to do so?
20:13:59 <trigone> geekosaur: well i'm not asking anything. at some point i thought you had said "yes you can pattern-match over a tuple, but you can't use the bindings created anywhere else in the top level"
20:14:00 <nshepperd> oh yeah if x is monomorphic and y is polymorphic with a constraint
20:14:24 <geekosaur> basically I'm not sure how this would interact with inlining, or various other things
20:14:29 <geekosaur> and I think at one point i may have made a misstatement that you ran with
20:14:41 <nshepperd> then x won't be shared even though it could be
20:14:54 <geekosaur> [23:08:14]  <geekosaur>	hm, wait. actually you can do (f, g) = ... at top level, f and g are both defined within the module
20:15:02 <trigone> geekosaur: hm i know nothing of inlining... :/
20:15:24 <geekosaur> cross-module inlining is "fun"
20:15:28 <geekosaur> and I am not sure what it does with a top level pattern
20:16:08 <geekosaur> it might inline the whole tuple and pattern match it, or something
20:16:26 <geekosaur> but I don't know how this would interact across modules
20:16:54 <geekosaur> (cross module inlining is pretty much the only reason haskell code is performant at all)
20:16:55 <trigone> yeah it's a good question
20:17:26 <geekosaur> (and we know this for certain because it's apparently broken under some circumstances in 8.2.1 and they've been chasing 90x performance losses...)
20:17:53 <trigone> is 8.2.1 the latest ghc version?
20:17:57 <koz_> Would someone be able to advise me? http://lpaste.net/357667
20:17:58 <geekosaur> yes
20:18:12 <trigone> you think they'll fix it?
20:18:14 <nshepperd> actually ghc is complaining to me if i try make any of the binds in a top level pattern match polymorphic
20:18:17 <erisco> meh, what is a couple orders of magnitude here and there
20:19:21 <trigone> nshepperd: even with rankNtypes?
20:19:55 <geekosaur> oh, sure they will fix it. but 8.2.1 is a new major version and the occasional glitch is normal. they'll track it down
20:20:24 <nshepperd> I don't see why RankNTypes would help, but no, not even with that
20:21:24 <trigone> nshepperd: dunno, i'm barely starting with this extension, and i thought, if you wrote (forall a. a -> a, forall b. b -> b) etc
20:21:58 <trigone> (as tuple of two polymorphic functions)
20:22:39 <trigone> > let (id, id') = (id, id') in id
20:22:43 <trigone> > let (id, id') = (id, id') in id 4
20:22:44 <lambdabot>  mueval-core: Time limit exceeded
20:22:48 <lambdabot>  mueval-core: Time limit exceeded
20:22:55 <trigone> oop
20:23:10 <trigone> > let (id_, id') = (id, id') in id_ 4
20:23:13 <lambdabot>  4
20:23:17 <trigone> :t let (id_, id') = (id, id') in id_ 4
20:23:19 <lambdabot> Num a => a
20:23:33 <trigone> :t \n -> let (id_, id') = (id, id') in id_ n
20:23:35 <lambdabot> a -> a
20:23:47 <nshepperd> i think the problem is with, uh, impredicative pattern matching or something
20:23:50 <nshepperd> i don't even know
20:24:09 <nshepperd> it's complaining about type variables being rigid and skolem
20:24:50 <trigone> oh... and you put forall inside the nuple type cons?
20:24:56 <search> ...
20:24:58 <nshepperd> no
20:25:23 <nshepperd> so anyway i guess what that means is there isn't really any performance concern, since the binds are monomorphic they can be shared
20:25:36 <nshepperd> and probably desugared the same way as irrefutable patterns
20:25:51 <mac10688_> http://lpaste.net/357668
20:26:02 <nshepperd> so inlining should work fine too
20:26:03 <mac10688_> anyone able to able to help me getPOSIXTime?
20:26:16 <mac10688_> nvm
20:26:31 <erisco> pattern matching in a let is maybe not what you expect
20:29:06 <trigone> nshepperd: i wrote (f, g) = (x, y) where x :: a -> a; x = id; y = x; and i got no problem, without rankNTypes... but maybe i didn't get what you meant
20:29:25 <nshepperd> trigone: check the types of f and g
20:29:34 <nshepperd> it probably defaulted to () -> () or something
20:29:45 <trigone> nah, with me it's a -> a, and it's usable and all that
20:30:06 <trigone> what's your code?
20:30:08 <nshepperd> oh, it's because it doesn't have a constraint
20:30:16 <trigone> aah maybe
20:30:35 <erisco> though now I can't remember the odd case monochrom had with patterning matching in a let/in block...
20:30:54 <trigone> i added Num a over x and got no problem
20:30:55 <erisco> it was something where it was evident the LHS was never constructed
20:31:00 <erisco> I mean the RHS
20:31:02 <trigone> including at usage
20:31:12 <search> ok so this is the part where im comfused .. it is done it created a file i search for the file .. nothing found{ not sure if the linux guy is still here or not}
20:31:39 <trigone> RHS?
20:32:17 <erisco> oh yes, it was probably something like this...
20:32:30 <erisco> > let [f,g] = [id,id] in (f "hello world", g 42)
20:32:32 <lambdabot>  ("hello world",42)
20:32:47 <trigone> what does RHS mean?
20:32:51 <trigone> right hand side?
20:32:55 <erisco> yes
20:33:20 <trigone> what did you mean then by "it was evident the RHS was never constructed"
20:33:34 <erisco> well, what is the type of [id,id] in that example?
20:33:37 <nshepperd> trigone: see annotation http://lpaste.net/357665
20:34:12 <trigone> erisco: [a->a] i'd say
20:34:34 <erisco> so how did I apply f to a string and g to a number
20:35:18 <trigone> nshepperd: well i didn't put a type signature before "where"
20:35:39 <nshepperd> trigone: taking it away doesn't help
20:36:22 <trigone> nshepperd: did you try using other letters than a and b? maybe it does some weird mirror thingy
20:36:22 <erisco> you would expect this to be equivalent, but it is not
20:36:36 <erisco> > (\[f,g] -> (f "hello world", g 42) [id,id]
20:36:38 <lambdabot>  <hint>:1:43: error:
20:36:38 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:36:43 <erisco> > (\[f,g] -> (f "hello world", g 42)) [id,id]
20:36:45 <lambdabot>  error:
20:36:45 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘42’
20:36:45 <lambdabot>      • In the first argument of ‘g’, namely ‘42’
20:36:55 <nshepperd> trigone: can you show me your code?
20:38:48 <trigone> nshepperd: http://lpaste.net/357670
20:39:36 <trigone> nshepperd: i'm not really sure what putting signature over the right side of the pattern match does...
20:40:39 <erisco> and I am not sure how that works... I haven't read the report in enough detail
20:41:06 <erisco> because it seems that it would be impredicative
20:41:27 <trigone> nshepperd: i think maybe i get it: don't you have another variable called "a" in your program? your error message starts by writing "a :: Num a => a" and it's not part of your snippet
20:41:29 <nshepperd> trigone: load that up in ghci
20:41:36 <erisco> but more likely there is something to do with desugaring that is rewriting the let block
20:41:42 <nshepperd> trigone: it says the type of f is Integer -> Integer
20:41:44 <trigone> nshepperd: my code? cuz mine works fine, i already did so
20:42:12 <nshepperd> trigone: load it up and check :t f
20:42:14 <trigone> nshepperd: oh, i get it
20:43:02 <trigone> or... no i'm not sure to get it. so, somehow, putting a Num constraint automatically is transformed into Integer monomorphism?
20:43:27 <nshepperd> that error message is what I get when i write 'a :: Num a => a'
20:43:50 <nshepperd> it's defaulting
20:44:00 <trigone> ok...
20:44:02 <geekosaur> x = ...
20:44:10 <nshepperd> it chooses a type from some built in list that fits the constraint
20:44:10 <geekosaur> this triggers the monomorphism restriction
20:44:41 <geekosaur> which then uses defaulting because it can't otherwise get past a Num constraint. defaulting then leads it to Integer because that's the first default candidate that typechecks
20:45:41 <trigone> geekosaur: what is the trigger? i didn't get it
20:45:59 <geekosaur> a binding with no parameters at top level
20:46:10 <geekosaur> @where dmr
20:46:10 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:46:19 <erisco> the only type that makes sense for  [id,id]  is  [forall a. a -> a]
20:46:58 <erisco> > let [f,g] = ([id,id] :: [a -> a]) in (f "hello world", g 42) -- annoyingly that still works, though
20:47:00 <lambdabot>  ("hello world",42)
20:47:22 <trigone> k i get it, so somehow we should put explicit signatures over f and g. i'm not sure i can do that in the left side of the pattern-match
20:47:23 <MarcelineVQ> the weirdness is probably related to let generalization
20:47:25 <geekosaur> but, to summarize: when you do that, you have given your expression a name that is visible throughout the module. it isnt parameterized, so it's a candidate for sharing
20:47:42 <geekosaur> if it is polymorphic, it will share separately for each possible type
20:47:54 <geekosaur> which can use a lot of memory
20:48:00 <sqooq_> Is there any way to use Double in a function but end up with a polymorphic num type. Or unDouble Double directly, or something.
20:48:03 <sqooq_> ?
20:48:17 <nshepperd> erisco: my guess - the type of [id,id] is (forall a. [a -> a]), and there are just two [id,id]s at different types
20:48:24 <geekosaur> and is often not what you expect if you were expecting that, say, Double and Integer would be shared (this is not possible)
20:48:43 <geekosaur> so the monomorphism restriction kicks in and picks a single type for "x"
20:48:50 <search> ill be back tommorow to get some help possibly
20:48:59 <sqooq_> my function :: Pitch -> Double, currently
20:49:00 <erisco> > [id :: String -> String, id :: Int -> Int] :: forall a. [a -> a] -- that is not valid though, nshepperd
20:49:03 <lambdabot>  error:
20:49:03 <lambdabot>      • Couldn't match type ‘a1’ with ‘String’
20:49:03 <lambdabot>        ‘a1’ is a rigid type variable bound by
20:49:40 <trigone> :t [id :: String -> String, id :: Int -> Int]
20:49:41 <nshepperd> erisco: let bindings are lazy, so you could desugar that into 'f = head [id,id]; g = head (tail [id,id])' without changing the semantics
20:49:41 <lambdabot> error:
20:49:41 <lambdabot>     • Couldn't match type ‘Int’ with ‘[Char]’
20:49:41 <lambdabot>       Expected type: String -> String
20:49:54 <geekosaur> sqooq, Num indicates the *minimum* requirement for a number
20:49:55 <nshepperd> which doesn't require f and g to be the same type
20:49:58 <trigone> :t [id :: String -> String, id :: Int -> Int] :: [forall a. a -> a]
20:49:59 <lambdabot> error:
20:49:59 <lambdabot>     • Illegal polymorphic type: forall a. a -> a
20:49:59 <lambdabot>       GHC doesn't yet support impredicative polymorphism
20:50:12 <sqooq_> why am I sqooq_
20:50:23 <MarcelineVQ> sqooq_: why not
20:50:50 <trigone> lol this is not #existentialCrisis
20:50:51 <sqooq_> anyway, geekosaur: does that mean that I'm screwed?
20:50:54 <geekosaur> anyway if you have a specific type, you cannot arrange for it to become any possible Num instance that a caller could request
20:51:07 <sqooq_> fuuuuuuuuu
20:51:24 <trigone> sqooq_: a priori the underscore means somebody else used that pseudo already
20:51:31 <trigone> or yourself on another tab
20:51:38 <erisco> nshepperd, hm, I can see that, that makes sense, but what does laziness mean here?
20:51:40 <trigone> (if that was what you meant)
20:51:52 <nshepperd> erisco: irrefutable patterns
20:51:56 <sqooq_> Is there anyway I can import a module that causes ambiguous name errors, without changing the name of everything in my file?
20:52:02 <geekosaur> or you got netsplit and rjoined before your original connection timed out
20:52:09 <nshepperd> erisco: the pattern match isn't checked until f or g and actually evaluated
20:52:11 <geekosaur> sqooq, import qualified
20:52:13 <sqooq_> trigone, ah it's me on another chat, forgot about that
20:52:22 <erisco> nshepperd, I know that, but why is laziness relevant to that refactoring?
20:52:24 <geekosaur> possibly with "as"
20:52:36 <geekosaur> sqooq_, you do know you can be in multiple channels at once?
20:52:36 <nshepperd> > let [f,g] = undefined in "hello"
20:52:38 <lambdabot>  "hello"
20:52:41 <geekosaur> even in webchat
20:53:03 <sqooq_> yes, but I literally forgot I had that tab open
20:53:12 <nshepperd> > let ![f,g] = undefined in "hello"
20:53:14 <lambdabot>  "*Exception: Prelude.undefined
20:53:22 <sqooq_> geekosaur: thanks for the advice about qualified, readinga bout it now
20:53:51 <nshepperd> > let ![f,g] = [id,id] in (f "hi", g 5)
20:53:53 <lambdabot>  ("hi",5)
20:53:54 <geekosaur> so, for example, we often do (and lambdabot does!) "import qualified Data.Map as M"
20:54:03 <geekosaur> because otherwise half of Data.Map would conflict with Data.List fnctions imported by the Prelude
20:54:09 <trigone> well all this is above my current level... for now i'll forget the idea of "top-level subscope", anyway it's not that intrinsically useful for me for now
20:54:16 <nshepperd> lol ok, that theory doesn't explain why it works then
20:54:24 <geekosaur> and then we can use e.g. M.union
20:54:55 <erisco> nshepperd, well I didn't see why laziness would be relevant to it
20:55:07 <erisco> we are using both f and g, so it is certainly being evaluated
20:55:42 <erisco> and you do not need to evaluate something before it has a type ... the type comes before :)
20:55:58 <nshepperd> erisco: well, 'let [a] = undefined in (a, a)'  doesn't throw exception until you look inside the tuple elements
20:56:37 <erisco> that is unsurprising
20:56:39 <nshepperd> erisco: 'let a = head undefined in (a,a)' works same
20:56:53 <erisco> tuples are not strict
20:57:13 <trigone> erisco: what do you find weird with the [id,id] binding already? i'm kinda lost
20:57:14 <nshepperd> if it was strict, 'let ![a] = undefined in (a, a)' you would need to put a seq in there to make it work same
20:57:42 <nshepperd> 'let a = head undefined in undefined `seq` (a, a)'
20:57:49 <erisco> trigone, the problem is that the only type you can give to [id,id] that makes sense is impredicative which GHC doesn't actually support
20:57:57 <nshepperd> because the strict one throws exception as soon as you look at tuple constructor
20:58:19 <erisco> evaluation really should have nothing to do with it
20:58:23 <erisco> we are just assigning types to things
20:58:41 <erisco> your earlier explanation made sense
20:58:45 <nshepperd> evaluation order does constrain how you can desugar syntax while staying correct
20:59:19 <erisco> [f,g] = [id,id]  is rewritten to  [f,_] = [id,id]; [_,g] = [id,id]
20:59:42 <nshepperd> anyway the concept that it is simply rewriting like that probably explains it
20:59:58 <nshepperd> the [id,id] never needs to have an impredicative type
21:00:46 <nshepperd> > let [f, g] = [\x -> x + 1] in (f 1 :: Int, f 10 :: Double)
21:00:49 <lambdabot>  (*Exception: <interactive>:3:5-26: Irrefutable pattern failed for pattern [f...
21:00:56 <nshepperd> er
21:01:06 <nshepperd> > let [f, g] = [\x -> x + 1, \x -> x + 1] in (f 1 :: Int, g 10 :: Double)
21:01:08 <lambdabot>  (2,11.0)
21:01:15 <erisco> I do not know if that is in the spec but it does seem to explain the behaviour correctly
21:01:53 <sqooq_> geekosaur: That worked perfectly. My program technically works as expected. I can input "[0 2 4] [ 5 4 2] [0 4 7] 0" and get music
21:02:01 <sqooq_> god bless y'all
21:02:11 <sqooq_> the feeling of accomplishment right now is amazing
21:02:24 <nshepperd> > let [f, g] = [\x -> x + 1, \x -> x + 1] in (f 1 :: Int, f 10 :: Double)
21:02:27 <lambdabot>  (2,11.0)
21:02:32 <angerman> wasn't there some brick/vty based (.prof) profile reader? I fail to remember the name :(
21:02:36 <nshepperd> er, hold on
21:02:45 <nshepperd> this is just ignoring the dmr
21:02:57 <sqooq_> but it's not perfect because I'm not entirely sure how csound-expression works and there doesn't seem to be any way to get help with it. I did some roundabout fmapping crap to get it to work, but pretty sure I don' need to do all that
21:03:06 <nshepperd> type of f and g is Num a => a -> a
21:04:19 <erisco> nshepperd, yes, it is just a question of where 'a' is bound
21:04:31 <angerman> ahh `viewprof`
21:05:08 <nshepperd> erisco: at the let binding presumably, there is one 'a'. [f,g] :: forall a. Num a => a -> a
21:05:30 <nshepperd> er
21:05:39 <nshepperd> [f,g] :: forall a. Num a => [a -> a]
21:06:27 <nshepperd> i would have expected DMR to mean f could only have monomorphic type, but apparently not
21:07:27 * hackagebot git-vogue 0.2.2.1 – A framework for pre-commit checks. – https://hackage.haskell.org/package/git-vogue
21:07:34 <erisco> oh, I think I see it now too nshepperd :)
21:09:08 <erisco> the fact there is both f and g is unimportant, so we can just talk about  we could have been talking about  Identity f = Identity id
21:09:43 <erisco> and yes, since the type parameter is bound there, it makes perfect sense
21:10:07 <erisco> somehow having both f and g made it confusing, but it is no different
21:12:30 <erisco> that is important to remember... that let/in and where allow us to introduce more type variables
21:12:32 <nshepperd> > let Identity f = Identity id in (f "hi", f 5)
21:12:35 <lambdabot>  ("hi",5)
21:13:01 <nshepperd> i guess monomorphism restriction doesn't apply to let bindings that do pattern matching?
21:13:28 <erisco> I don't know how monomorphism is relevant
21:13:49 <nshepperd> > let f id in (f "hi", f 5)
21:13:51 <lambdabot>  <hint>:1:10: error: parse error on input ‘in’
21:13:53 <nshepperd> > let f = id in (f "hi", f 5)
21:13:57 <lambdabot>  ("hi",5)
21:13:58 <erisco> the monomorphism restriction is about inference of type classes, iirc, and we have no type classes here
21:14:31 <erisco> the mechanism that lets  let f = id in (f "hi", f 5) work is exactly the same as letting (id "hi", id 5) work
21:14:45 <erisco> id :: forall a. a -> a;  f :: forall a. a -> a
21:15:00 <nshepperd> > let f = (1+) in (f "hi", f 5)
21:15:03 <lambdabot>  error:
21:15:03 <lambdabot>      • Could not deduce (Num [Char]) arising from a use of ‘f’
21:15:03 <lambdabot>        from the context: Num t
21:15:09 <erisco> the type var is bound the same way, it is applied when we use id or f
21:15:29 <nykros> Hi.  I want to use simple regular expressions. Where do I start? I seems there are several libraries that do the same
21:15:34 <erisco> we get a different one for different types we choose
21:15:38 <erisco> that's just polymorphism :)
21:16:17 <erisco> the reason  (\(Identity f) -> (f "a", f 0)) (Identity id)  will not work is because of where the type var is bound
21:17:24 <erisco> (\(Identity f) -> (f "a", f 0)) :: forall a. Identity (a -> a) -> (String, Int)
21:17:35 <nshepperd> > let f = (1+) in (f 1 :: Double, f 5 :: Int)
21:17:37 <lambdabot>  (2.0,6)
21:17:44 <erisco> that is incorrect, because we can choose a = String or a = Int but not both :)
21:17:50 <erisco> so the forall has to move inside
21:17:51 <nshepperd> O_O
21:18:04 <erisco> Identity (forall a. a -> a) -> (String, Int)
21:18:13 <erisco> but now it is impredicative
21:19:28 <erisco> nykros, I have used regex-tdfa
21:20:05 <erisco> nykros, and I also wrote a quasiquoter for it so you can have your regexps compiled and checked at compile time
21:21:23 <erisco> nshepperd, I am guessing the monomorphism restriction is not turned on for lambdabot
21:22:06 <nykros> thanks erisco, can u share any link to documentation?
21:22:20 <erisco> http://hackage.haskell.org/package/regex-tdfa http://hackage.haskell.org/package/regex-tdfa-quasiquoter
21:23:20 <nshepperd> or ghci
21:23:23 <nshepperd> ok, that makes sense
21:24:15 <nshepperd> 'let Identity f = Identity id in (f 1 :: Double, f 5 :: Int)' is allowed because f can just be 'forall a. a -> a'
21:24:48 <nshepperd> 'let Identity f = Identity (+1) in (f 1 :: Double, f 5 :: Int)' is not allowed because DMR requires a to be some fixed type
21:28:11 <sqooq_> erisco: are you curious how that function I've been trying to do turned out?
21:28:19 <sqooq_> it's literally 3 lines
21:28:21 <sqooq_> so simple
21:28:36 <erisco> sure, go ahead
21:29:08 <sqooq_> http://lpaste.net/357671
21:29:19 <sqooq_> someone helped me with it
21:29:47 <sqooq_> a lot actually, I told them my problem and they just did it right away within a minute or so.
21:30:43 <erisco> nshepperd, what is the "D" in DMR?
21:31:11 <nshepperd> 'dreaded'
21:31:20 <exio4> what's the "recommended" way to deal with the DOM in GHCJS?
21:31:26 <sqooq_> on a haskell discord server. Discord is a lot better for getting help tbh, because it has built in code layout. In here, because of how slow lpaste is, I'm disincentivized to use it and show things clearer.
21:31:27 <erisco> and... is that just a knock?
21:31:35 <nshepperd> alternatively, 'delightful' :)
21:32:11 <sqooq_> also in discord you can have multiple lines of text, italicize, bold, etc.
21:32:17 <erisco> I apparently do not program with it enabled, so I don't know what the difference between Identity id and Identity (+1) is
21:32:37 <nshepperd> Identity (+1) has a Num constraint
21:33:22 <erisco> sqooq_, well, glad you got help... if I understand what you were looking for then I could have helped you with that
21:33:29 <erisco> if I understood*
21:33:35 <sqooq_> yes, I tried to explain
21:33:39 <sqooq_> but it's hard in here lmao
21:33:45 <erisco> it isn't
21:33:56 <sqooq_> The guy didn't understand at first either
21:34:12 <erisco> well, a difference may be that I am not going to make any guesses
21:34:37 <sqooq_> it's harder by comparison at least
21:34:41 <sqooq_> to explain things
21:35:07 <sqooq_> erisco: and you helped me A LOT, with tons of stuff, so I appreciate that.
21:35:26 <sqooq_> you're the one who wrote the parser paper, or was that erin-something?
21:35:34 <nshepperd> explaining things is hard
21:35:41 <erisco> I did write a parser paper, but there is more than one, so I don't know :P
21:35:54 <nshepperd> put thoughts directly into someone else's brain, only through the power of words
21:36:34 <remexre> Is there a way to parse the output of a parser, with parsec?
21:36:43 <sqooq_> I'm pretty sure it was you, Brisco, you helped me the most with parsing for sure.
21:38:00 <erisco> sqooq_, also I encourage people to understand what they are doing before I do too much work to solve things for them
21:38:19 <sqooq_> erisco, yeah I was honestly kind of mad the guy solved it for me right away
21:38:37 <xormor> how do I create in Haskell something I created in C++? it calculated y=2*x+3 with x=0, x=1, x=2, ... I used int x,y; for (int x=0;x<=10;i++) { y=2*x+3; cout << y << " "; } How do I accomplish this in Haskell?
21:38:38 <sqooq_> i asked him for help a bit later with something else, and told him specifically to just tell me what NOT to do
21:38:56 <sqooq_> and that's what he did, and I figured it out by myself
21:39:07 <xormor> not i++, it was x++.
21:39:22 <xormor> how do I create a loop in Haskell?
21:39:22 <erisco> remexre, what does the output of the parser look like?
21:39:51 <sqooq_> erisco: you kept telling me to annotate, which is what this guy called the function so I guess that's what it's doing, and if that's the case then you already told me I just didn't know what annotating meant.
21:39:53 <remexre> xormor: Take a look at map, functional programming encourages higher-order functions over iteration
21:40:18 <remexre> erisco: The first one is Parsec String () String, the second is Parsec String () Symbol
21:40:37 <sqooq_> anyway, night, thanks again, to all who helped. I still got some little things to do, and need to better work with csound-expression, so I'll probably come back in here.
21:40:49 <erisco> sqooq_, have a good night
21:40:54 <sqooq_> you as well
21:40:55 <sqooq_> bye
21:41:54 <remexre> erisco: Ideally I'd like a more general (Parsec a () b -> Parsec b () c -> Parsec a () c), though
21:41:55 <erisco> remexre, sorry I don't understand. You said you wanted to parse the output of a parser. This should be some AST
21:42:38 <remexre> Yeah, I "probably" want a lexer instead, but I already have 90% working code as a Parsec String () Ast
21:42:54 <remexre> (I have a Symbol -> Ast too, the lexerish bit is only on one part)
21:43:29 <erisco> okay, so is it that you have a lexer (written with Parsec) and a parser (also written with Parsec) and you want to get the lexemes into your parser?
21:44:30 <remexre> No, I'm writing the last subparser for a Parsec, and it's easier to write that last rules as a lexer-ish thing
21:45:03 <remexre> Or rather a parser that lexes out a substring, which I want to compose with a different parser
21:45:16 <xormor> remexre, which one of the Map cases would work? https://www.haskell.org/hoogle/?hoogle=map
21:45:57 <remexre> xormor: The (a -> b) -> [a] -> [b] case; you'd write a function that does the 2*x+3 and that'd be the function argument
21:46:24 <erisco> remexre, hm, I am still having difficulty understanding... do you have a minimal example?
21:46:53 <xormor> remexre, can you give me an example so I can use it later with different function arguments and functions?
21:47:01 <remexre> The (Parsec a () b -> Parsec b () c -> Parsec a () c) is the most minimal thing I have right now; I can type something up in a second
21:47:35 <erisco> I see the type, but it doesn't tell me much... can be implemented by flip const, for example, so I need more detail on what it is supposed to do
21:47:48 <erisco> oh, I misread it, ah ha, let me try again
21:47:57 <remexre> xormor: e.g. map (\x -> 2*x+3) [1..3] = map (\x -> 2*x+3) [1, 2, 3] = map [5, 7, 9]
21:48:43 <erisco> remexre, so you have parsers working on different stream types... and somehow they are to coordinate?
21:48:56 <erisco> can you explain how that might work?
21:48:56 <remexre> erisco: yeah
21:49:02 <remexre> I can send a code sample now
21:49:30 <remexre> erisco: https://github.com/oftlisp/oftb/blob/rewrite-haskell/src/Language/OftLisp/Reader/Parser.hs#L65
21:50:04 <remexre> So I want to "greedily" grab all the isSymbolChar characters, then use the parser in the where-clause on it
21:50:30 <remexre> xormor: just realized I typoed; the result of that is [5, 7, 9], not map [5, 7, 9]
21:52:04 <erisco> remexre, ah ha, okay, I see
21:53:04 <erisco> I do not recall a Parsec function which does this but it is definable
21:54:29 <erisco> remexre, I assume you know how to define it but was just wondering if it was predefined?
21:55:07 <remexre> Eh, I can probably figure it out; would I use token? It's the first time I've actually used parsec, and the first time I've written Haskell in a while...
21:55:45 <xormor> remexre, How do I use a .hs file with it? It says perhaps I need HaskellTemplate.
21:56:08 <xormor> remexre, I tried equation.hs, equation2.hs and equation3.hs.
21:56:10 <remexre> xormor: Oh, don't type that whole thing in literally; I was showing what it evaluagtes to
21:56:30 <remexre> xormor: you'd just want e.g. the map (\x -> 2*x+3) [0..10] part
21:56:31 <xormor> remexre, yes. but when I use a piece of it, it works in the ghci commandline, not in  *.hs.
21:56:43 <remexre> xormor: pastebin?
21:57:27 <xormor> remexre, ok...
21:58:23 <erisco> remexre, use runParser or runParserT
21:58:59 <remexre> erisco: okay, thanks!
21:59:34 <erisco> or "parse", I suppose
21:59:38 <xormor> remexre, https://pastebin.com/UjnRK1ge
22:00:10 <erisco> once you have the 'b' out, which you can do with bind, you can do whatever you want to it
22:00:18 <remexre> xormor: I meant your .hs file, but that's enough to be able to tell; you need a main function
22:00:22 <erisco> there is nothing special about running another parser against it versus any other function
22:00:38 <remexre> erisco: Oh, okay, thanks a million!
22:00:41 <remexre> erisco++
22:00:51 <remexre> (hm, the wiki said that did something)
22:00:53 <xormor> remexre, what form was the main function again?
22:00:55 <erisco> bind or fmap or whatever
22:01:01 <remexre> xormor: IO ()
22:01:16 <erisco> maybe it was removed... too spammy
22:01:31 <erisco> human animals are drawn to Internet points like moths to a flame
22:01:41 <remexre> xormor: so you might want main = print (map (\x -> 2*x+3) [0..10])
22:01:59 <remexre> erisco: hah, makes sense. PlusPlus++ is the worst thing that ever happened to Slack
22:02:56 <xormor> remexre, thanks! :-)'
22:03:43 <pacak> remexre: I always thought that slack creation was the worst thing.
22:04:43 * hackagebot recursion-schemes-ext 0.1.0.4 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
22:04:44 * hackagebot composition-prelude 0.1.0.4 – Higher-order function combinators – https://hackage.haskell.org/package/composition-prelude
22:11:44 <remexre> erisco: sorry to keep being a bother, but runParser/runParserT/parse give me an (Either ParseError a), and I want to turn it back into the Parsec
22:11:57 <remexre> Am I missing something obvious in the docs?
22:12:23 <erisco> is it possible for it to fail?
22:12:35 <remexre> Not the "second" parser, no
22:13:05 <erisco> then just pattern match on  Right x
22:13:53 <remexre> How do I feed that into a (Parsec x () y) though?
22:14:37 <erisco> you started with  Parsec a () b
22:14:58 <erisco> you ran a parser on b, now you have  Parsec a () (Either ParseError c)
22:15:16 <remexre> Oh, yeah, fmap instead of bind, whoops
22:15:20 <remexre> thanks!
22:15:22 <erisco> you've guaranteed the parse succeeds and so just take the c out
22:23:01 * hackagebot recursion-schemes-ext 0.1.0.5 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
22:43:49 <dsal> What's a good way to manage a date like this  "2017-08-06","11:03:59.330"   (two fields from CSV, local timezone, milliseconds)
22:45:37 <erisco> haven't dealt with datetimes in a while (thankfully) ... this package looks reasonable dsal https://hackage.haskell.org/package/time
22:46:10 <dsal> Thanks, I'll give it a go.  There seem to be a lot of packages for everything.  I don't know what I'm doing here.  :)
22:46:20 <dsal> As long as I can subtract two timestamps, I'll be fine, though.
22:48:30 <tdammers> "subtract two timestamps" is kind of an ill-defined operation
22:48:55 <Axman6> dsal: are you using cassava?
22:49:01 <dsal> Yeah, sort of.
22:49:21 <Axman6> because it's pretty easy using applicative to join data from different columns
22:49:29 <tdammers> but yes, 'time' is the canonical choice
22:50:06 <dsal> I'm just using it to make a [Vector String] at this point.  Having it actually understand my data is kind of tedious.
22:50:32 <Axman6> you might want to look at something like the Frames library
22:50:43 <dsal> My field names are stuff like this:  2RSS(dB),RQly(%),RSNR(dB)
22:50:46 <Axman6> which can examine a CVS and take a good guess at the types of each column
22:51:33 <dsal> So named columns was kind of painful.  The types aren't too hard.  Date and Time being in different columns is a bit annoying, but most things are ints, except I've also got GPS coordinates which is a single space separated field.
22:52:40 <Axman6> dsal: anyway, with cassava, it looks like you want to use a LocalTime from the time package, which is a Day and a TimeOfDay
22:53:46 <Axman6> if you give a few minutes I can write up how you'd parse this. do you prefer using the column number or the name of the column?
22:54:05 <dsal> I'll see if I can get it to understand the types.  I only actually want two-three fields out of a CSV with a lot of fields.  This simple program (which will hopefully by my first actually useful bit of haskell) is going to read the csv, do a little bit of transformation of data and spit out a wider csv.
22:54:52 <dsal> Right now, I'm using number because the names are so awkward.
22:55:27 <Axman6> they're just strings though
22:56:01 <dsal> Yeah, the generic examples in cassava had it mapping them to matching field names.  I wasn't sure how all that magic worked.
22:56:21 <dsal> I'm still stumbling through syntax and packages at the same time.
22:57:31 <Axman6> I'll do it with the names because I think it'll be a bit clearer
22:58:44 <dsal> OK.  If you've got a sample that can read a csv with a date, time, and like, custom field type , I'd learn a lot.  :)
22:59:06 <dsal> e.g., my gps stuff is:       let coords = toCoord $ map (\x -> read x :: Float) $ words (x V.! 11)
22:59:09 <koz_> Argh do notation,w hy do you throw parse errors at me...
23:01:47 <Axman6> the parser would look something like: parseDate m = LocaLTime <$> parseTimeM True defaultTimeLocale "%F" =<< m .: "date" <*> parseTimeM True defaultTimeLocale "%H:%M:%Q" =<< m .: "time"
23:02:47 <Axman6> https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:formatTime has the format string info
23:03:02 <dsal> Thanks.  :)  I don't recognize most of those operators, so I've got a ways to go here.  :)
23:03:08 <jle`> mniip: it's pretty easy to write fromSing incorrectly
23:03:18 <jle`> fromSing STrue = False
23:04:35 <norc_> Hi, I just mistaking used mod as an infix operator and was wondering the meaning behind this seemingly cryptic error: https://gist.github.com/anonymous/1dc7a1042d9257bc8041949c7fb9a727
23:05:10 <dsal> Axman6: I'm on my way to bed, but I've taken a few notes here.  Thanks for the pointers.
23:05:10 <Axman6> norc_: you need to surround mod with `'s
23:05:18 <Axman6> > 32 `mod` 7
23:05:21 <lambdabot>  4
23:05:25 <Axman6> dsal: no worries
23:05:29 <norc_> Axman6: You misunderstand, I'm curious about what that error specifically is trying to tell me
23:05:42 <mud> norc_: For that to work, 25 would have to be a function of a fairly weird type. And since integer literals are of type :: Num a => a, that probably gets you to the weird error eventually.
23:06:16 <Axman6> norc_: it's saying that you're trying to apply the function called 24 to the function mod which has type (a -> a -> a) and the argument 24 which has tyoe Num b => b
23:07:13 <Axman6> it is perfectly possible that 25 actually is a function with that type, because we have the Num type class, and there's nothing stopping someone writing an instance of Num for the type ((a -> a -> a) -> t -> t1)
23:07:35 <norc_> Axman6: You mixed up 24 and 25 in that former sentence, right?
23:07:50 <Axman6> I don;t think so
23:07:50 <Axman6> no
23:08:37 <Axman6> what you wrore is (25 mod) 24, ie, apply the function 25 to the function mod, and apply the result of that to 24
23:09:45 <jle`> norc_: it's the same, syntactically, as if you wrote 'f x y'
23:09:54 <jle`> it's applying the function 'f' to the values x and y
23:10:02 <jle`> in this case, you're doing '25 mod 24'
23:10:04 <jle`> like 'f x y'
23:10:12 <jle`> 25 is the function, and you're applying it to the values mod and 24
23:10:27 <norc_> jle`: Well Axman6 just said "you're trying to apply the function aclled 24 to the function mod", and I'm still choking on that bit.
23:11:04 <Axman6> uh, yes, typo, I meant 25
23:11:06 <norc_> Axman6: Are you absolutely sure that first "24" was not supposed to be "25" ? Because I'm completely lost now.
23:11:09 <norc_> Oh.
23:11:30 <Axman6> let f = 25 in f mod 24
23:12:09 <Axman6> this is perfectly valid, as it's _possible_ to satisfy, there just doesn't happen to be an instance for that weird type in the Num class
23:13:17 <norc_> Axman6: Fair enough, the error is still a bit cryptic - but I have a feeling it might be easier to look over it for now and revisit it later.
23:14:51 <Axman6> maybe cryptic, but definitely accurate :)
23:16:06 <norc_> Axman6: I feel like part of the error message is due to ghci
23:16:18 <norc_> Particularly that bit: (Num ((a -> a -> a) -> t -> t1), Num t, Integral a) => t1
23:19:38 <jle`> check this out
23:19:45 <jle`> :t _ mod 25
23:19:46 <lambdabot> error:
23:19:46 <lambdabot>     • Found hole: _ :: (Integer -> Integer -> Integer) -> Integer -> t
23:19:46 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
23:19:56 <jle`> here we ask ghc what would go in the blank
23:20:19 <jle`> and it says that the blank must be able to take mod (an Int -> Int -> Int) and 25 (an Int) and return...whatever it all returns
23:20:36 <jle`> and you have 24 as '_'
23:20:48 <jle`> sorry, 25
23:21:05 <jle`> so whatever 25 is, its type has to be (a -> a -> a) -> b -> t
23:21:14 <jle`> aw bye
23:24:16 <jle`> we tried
23:30:31 <shafox> I am running stack solver at the home dir so that i can install hsdev, but it gives me error getSymbolicLinkStatus: invalid argument (File name too long) 
23:31:26 <norc_> Axman6: Actually screw it, it's bogging me too much. What exactly is a "constraint" in Haskell in this context?
23:31:54 <koz_> What are you meant to do with mutable vectors after you freeze them?
23:32:00 <koz_> Are you meant to runST or something?
23:33:20 <erisco> koz_, iirc, and I haven't used them in a while, yes
23:33:37 <koz_> OK, time to post (cut-down) code and hope someone can help...
23:34:01 <jle`> norc_: did you see what i typed above?
23:34:04 <jle`> i think you might have disconnected
23:34:33 <jle`> if you have 'f mod 25', then f is implied to be some (Num a, Num b) => (a -> a -> a) -> b -> t
23:35:27 <jle`> sorry, (Integral a, Num b) => (a -> a -> a) -> b -> t
23:35:47 <jle`> since you are giving it mod :: Integral a => a -> a -> a, and 24 :: Num b => b
23:36:09 <norc_> jle`: Yeah that makes perfect sense.
23:36:20 <norc_> And indeed I got disconnectd before I could see that.
23:36:21 <jle`> norc_: so whatever you give for 'f', it has to be some (Integral a, Num b) => (a -> a -> a) -> b -> t
23:36:32 <jle`> so, for f, you gave the literal '25'
23:36:49 <jle`> so ghc thinks that that '25' literal must have that (Integral a, Num b) => (a -> a -> a) -> b -> t type
23:37:00 <jle`> since numeric literals in haskell are polymorphic
23:37:05 <jle`> ghc has to infer what type you want them to be
23:37:26 <jle`> but, anything you want to use a numeric literal for must be an instance of Num
23:37:37 <jle`> so that ghc can "parse" 25 into that thing you want it to be
23:37:41 <koz_> If someone could help me figure out what I need to do here, I would be super grateful: http://lpaste.net/357672
23:38:04 <jle`> so the final value is (Integral a, Num b, Num ((a -> a -> a) -> b -> t)) => t
23:38:31 <jle`> koz_: well it depends on what your final goal is
23:38:56 <koz_> jle`: I... don't quite follow what you mean.
23:39:09 <jle`> you say that yuo don't know what you need to do
23:39:12 <jle`> well, neither do we
23:39:21 <jle`> unless you tell us what you want from your code, heh
23:39:31 <jle`> what do you want the code to do?
23:40:26 <koz_> jle`: OK, sorry. Currently, randomMins does not compile, because I have no idea what to do with the newly-frozen mv in the last line. I need it to give me a Bitvector in the combination Error and MonadRandom, but I don't want the PrimMonad that is needed for writeMins. I basically wanna 'run' just that part of the computation.
23:40:30 <koz_> (if that makes some sense)
23:41:10 <jle`> what's the compile error?
23:41:30 <erisco> also it should give you a type for the hole, which will help you figure it out
23:41:33 <koz_> jle`: There's two (one's for the hole) - I'll add both to the paste.
23:43:18 <halogenandtoast> So... what are brackets?
23:43:30 <halogenandtoast> I keep seeing them pop up from time to time.
23:43:42 <halogenandtoast> for example: https://vadosware.io/post/end-to-end-testing-with-hspec-almost/
23:43:58 <norc_> jle`: Okay I think I understand that. Im about to leave the train, so I'll be right back with a follow-up question.
23:44:03 <koz_> jle`: Updated the paste: http://lpaste.net/357672
23:44:09 <erisco> halogenandtoast, such as in the title?
23:44:26 <halogenandtoast> erisco: there's a section "WORKING TEST, WITH THE BRACKET PATTERN"
23:44:35 <koz_> (sorry about the lack of wrapping - this is what Neomake dumped into the gutter when checking)
23:44:36 <halogenandtoast> It was capitalized when I copied and pasted
23:44:45 <halogenandtoast> that is not my passive agressiveness.
23:45:46 <erisco> looks like RAII or what other languages typically call "using"
23:50:12 <cocreature> halogenandtoast: "bracket" is for safely allocating and freeing resources even in the presence of exceptions
23:50:14 <cocreature> :t bracket
23:50:16 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:50:45 <cocreature> the first argument allocates the resource, the second frees the allocated resource and the third does something with the resource
23:51:02 <cocreature> the resource will always be freed even if an exception is thrown sometime after allocating it
23:51:23 <erisco> I write all my code in finally blocks so it is definitely run
23:51:40 <nshepperd> it's cool how things like 'with' or 'using' that require special syntax in other languages, in haskell are just plain ol functions :)
23:51:46 <halogenandtoast> cocreature: thanks
23:51:55 <halogenandtoast> is this similar to resourceT?
23:52:20 <erisco> well, it doesn't necessarily have to be special in other languages, except if they want to support it for structured programming
23:52:50 <erisco> but some languages allow you to extend the language with these kinds of new structures
23:53:01 <cocreature> halogenandtoast: the usecases are similar but ResourceT is more general, it doesn’t enforce stack-based allocation/freeing and resources can be shared between multiple threads
23:53:21 <ongy> the implications of lazyness and IO can also mess you up with this kind of construct. I wonder if it would be reasonable to deepseq the result of bracket
23:53:22 <cocreature> so in that sense you can do everything you do with ResourceT with bracket but not the other way around (at least not easily)
23:53:39 <cocreature> ongy: just don’t use lazy io, problem solved :)
23:53:41 <halogenandtoast> Thanks
23:53:56 <halogenandtoast> I think that makes sense enough
23:53:59 <ongy> cocreature: :)
23:54:12 <cocreature> if you’re using lazy IO all hope for safe resource management is lost anyway
23:54:32 <ongy> I've learnt that early
23:54:38 <cocreature> we all have :)
23:54:55 <ab9rf> heg
23:55:15 <nshepperd> halogenandtoast: at its most basic, 'bracket' is just the concept of acquiring a resource, running some action using that resource, then freeing the resource afterward
23:55:18 <erisco> how are gou?
23:55:48 <nshepperd> as a function
23:57:43 <halogenandtoast> nshepperd: right, seems a lot like some of the closure forms of ruby methods (File.open { |file| ... }) for example
23:58:51 <nykros> Hi. Anyone can help me why "NothingElseMatters.mp3" matchs [re|[a-z]+\.(mp3|flac|aac)|]?
23:59:16 <erisco> nykros, it does match or does not match?
23:59:26 <nykros> I think [a-z] should be only lower cases
23:59:29 <nykros> It does
23:59:38 <nshepperd> normally you use it as a primitive to implement some withFoo function that abstracts it. withFile "filename" ReadMode (\handle -> do some stuff using the file handle)
