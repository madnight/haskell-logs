00:00:02 <tabemann> it seems to be working now
00:04:12 <tabemann> thanks
00:12:42 <tabemann> yep, gi-gtk built just fine now
00:12:52 <tabemann> thank you so very much
00:13:48 <tabemann> now I just need to wrap my brain around the gi-gtk docs, which don't seem as well-organized as (but at the same time seem more complete than) the gtk3 docs
00:16:18 <cocreature> tabemann: https://github.com/haskell-gi/haskell-gi#translating-from-the-c-api-to-the-haskell-gi-generated-api might be helpful
00:17:56 <tabemann> thanks
00:26:52 <joel135> Hi! When importing Graphics.UI.Gtk in ghci after installing haskell-gtk2hs-buildtools in archlinux I get the error "Could not find module ‘Graphics.UI.Gtk’".
00:29:08 <cocreature> joel135: that module exists in the "gtk" and "gtk3" package but not in "gtk2hs-buildtools"
00:29:38 <cocreature> joel135: also I would recommend to not install Haskell packages via your os’ package manager since that tends to lead to trouble at some point
00:29:56 <joel135> What should I do instead?
00:30:03 <cocreature> use "cabal" or "stack"
00:30:34 <joel135> Ok I have heard about stack, I will remove haskell-gtk2hs-buildtools and try that instead.
00:46:38 <BernhardPosselt> hi whats inside the curly braces when you define newtypes? the getter?
00:46:47 <BernhardPosselt> can there only be one function?
00:47:15 <BernhardPosselt> newtype Sum a = Sum { getSum :: a }
00:47:39 <boj> BernhardPosselt: yes, newtypes can only have one constructor. the function could be considered a getter (or unwrapper)
00:47:52 <cocreature> it’s the same syntax used for records
00:48:02 <BernhardPosselt> so the usecase for newtype is basically wrapping existing stuff to implement different typeclasses
00:48:23 <cocreature> not necessarily different typeclasses. sometimes you just want to make sure you don’t mix things up
00:48:41 <BernhardPosselt> you mean like type aliasing things?
00:48:49 <BernhardPosselt> type Username = String
00:48:51 <boj> helps give an extra level of indirection for type checking
00:48:57 <cocreature> e.g. "newtype Age = Age Int". you might not want different typeclasses but you don’t want people to accidentally use arbitrary Ints as ages
00:49:10 <BernhardPosselt> ah i see
00:49:27 <boj> type Username = String is simply an alias. f :: String -- this would still accept a Username
00:49:28 <cocreature> if you just had "type Age = Int" then I could still pass an arbitrary integer
00:49:59 <BernhardPosselt> ok, works probably differently in other languages then
00:50:02 <cocreature> you could also make "newtype Age = Age Int", not expose the constructor and instead expose a "mkAge :: Int -> Maybe Age" function that checks that the age is positive or something like that
00:50:32 <BernhardPosselt> after 3 years things start making sense :D
00:50:39 <boj> BernhardPosselt: for the most part "newtype" is like "data" - it's just slightly more efficient
00:51:03 <cocreature> it’s also strict
00:51:11 <boj> and limited to single constructors
00:51:22 <BernhardPosselt> strict as in fails at compile time?
00:51:33 <boj> strict as in its contents are evaluated strictly
00:51:40 <cocreature> if you have "data Age = Age Int" and you pattern match on Age the Int will not be forced
00:51:47 <cocreature> if you match on a newtype it will be forced
00:51:57 <xzhu> With Stack, is there a way to run the file without compiling?
00:52:03 <cocreature> newtypes simply don’t exist at runtime
00:52:16 <cocreature> xzhu: stack script/stack runghc
00:52:25 <BernhardPosselt> so newtypes are "unwrapped"?
00:52:26 <xzhu> thx
00:52:28 <BernhardPosselt> when compiling
00:52:58 <BernhardPosselt> how do typeclasses work for newtypes then?
00:53:06 <BernhardPosselt> typeclasses are dynamic dispatch right?
00:53:54 <boj> no, that is an OO concept
00:54:17 <boj> typeclasses add compile time constraints
00:54:29 <boj> they don't exist at runtime
00:55:08 <BernhardPosselt> oh wow
00:56:33 <ongy> is there a fromIntegral equivalent for floating point numbers?
00:56:52 <ongy> (I need Float -> CFloat)
00:57:03 <cocreature> :t realToFrac :: Float -> CFloat
00:57:04 <lambdabot> error:
00:57:04 <lambdabot>     Not in scope: type constructor or class ‘CFloat’
00:57:04 <lambdabot>     Perhaps you meant ‘Float’ (imported from Prelude)
00:57:16 <cocreature> @let import Foreign.C.Types
00:57:18 <lambdabot>  Defined.
00:57:18 <cocreature> :t realToFrac :: Float -> CFloat
00:57:20 <lambdabot> Float -> CFloat
00:57:22 <BernhardPosselt> ongy: check https://www.haskell.org/hoogle/?hoogle=+Float+-%3E+CFloat
00:57:22 <cocreature> ^ ongy 
00:57:43 <cocreature> BernhardPosselt: have you looked at the results that hoogle gives you here? they are pretty much useless :)
00:58:14 <BernhardPosselt> realToFrac is right there :D
00:58:25 <cocreature> yeah somewhere at the bottom :)
00:58:34 <cocreature> ongy: but CFloat is just a newtype, you can use the constructor
00:58:47 <nshepperd_> realToFrac goes through Rational though, so be careful of big or small numbers
00:59:03 <cocreature> nshepperd_: is there no rewrite rule for Float -> CFloat?
01:00:09 <nshepperd_> Oh, i don't know
01:02:04 <ongy> BernhardPosselt: thx
01:02:32 <ongy> cocreature: ohh, that makes things nicer
01:02:56 <BernhardPosselt> not saying everyone should always use hoogle but i underestimated its usefulness previously :)
01:04:17 <nshepperd_> There ought to really be a realFloatToFrac that goes directly via exponents
01:04:49 <cocreature> "realToFrac" is also a really shitty name for almost all usecases that we use it for
01:05:21 <ongy> does it have the amount of RULE that fromIntegral has? or will it do the roundtrip over Fractional?
01:05:33 <jle`> realToFrac has a bunch of rewrite rules
01:05:38 <cocreature> there are a few rules but I’m not sure what exactly they cover
01:05:40 <jle`> you might want to check
01:05:55 <jle`> i know at least basic cases like Double -> Double are rewritten as id
01:08:03 <ongy> I switched to applying the constructor for now. but I'll keep it in mind
01:10:06 <cocreature> looks like there is a rule for converting "realToFrac :: a -> CFloat" to "\x -> CFloat (realToFrac x)"
01:10:14 <cocreature> and then there is a noop rule for "Float"
01:10:22 <cocreature> so it should be just as fast as using the constructor
01:10:46 <cocreature> also we really need a better way to find the rewrite rules that are defined for some operation
01:10:52 <cocreature> at least within a specific package
01:17:11 <xzhu> have you guys tried adding a git repository as the dependency?
01:17:16 <xzhu> I got this error
01:17:17 <xzhu> Aeson exception:
01:17:17 <xzhu> Error in $['extra-deps'][0]: failed to parse field 'extra-deps': expected PackageIdentifier, encountered Object
01:17:45 <cocreature> xzhu: you are probably reading the docs in the master branch of stack instead of the one that you are using
01:18:15 <cocreature> xzhu: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep shows the syntax you need to use
01:22:01 <xzhu> thx
01:22:19 <xzhu> I tried the "location" syntax in the documentation link you gave
01:22:40 <xzhu> However, it seems that I got "permission denied"
01:22:48 <xzhu> (public key)
01:22:53 <cocreature> github repo?
01:22:59 <xzhu> yes
01:23:05 <cocreature> try the https link instead of the ssh one
01:23:56 <xzhu> Seems to be working. Thx cocreature 
01:23:57 <xzhu> !
01:33:00 <joel135> I downloaded this https://github.com/stackbuilders/tutorials.git and tried "stack setup" but I get "No information found for ghc-7.10.3".
01:33:22 <cocreature> joel135: is that the full error message?
01:33:49 <joel135> cocreature: no https://pastebin.com/1VYhL1QU is
01:34:03 <cocreature> joel135: archlinux?
01:34:06 <joel135> yes
01:34:17 <cocreature> also at some point I need to write a bot that asks people to post the full error message
01:34:34 <joel135> sorry
01:34:37 <cocreature> joel135: install ncurses5-compat-libs from the aur
01:34:55 <cocreature> nothing personal, I just get tired of having to ask everytime :)
01:36:22 <ski> @tell EvilMachine well, one reason for using a different (foreign, less common, or new invented) word is to avoid unwanted baggage (connotations, other meanings/nuances) of the "more obvious term", and to make it clear that we're using a technical term
01:36:22 <lambdabot> Consider it noted.
01:37:22 * ski annotated "My sorted vector merge" with "refactorings" at <http://lpaste.net/357966>
01:37:26 <ski> koz_ ^
01:41:27 <joel135> cocreature: I get a 404 error in makepkg because the mirror used has removed the old version. Do you know what to do? (=> ERROR: Failure while downloading http://invisible-mirror.net/archives/ncurses/current/ncurses-6.0-20170527.tgz     Aborting...)
01:42:11 <joel135> (https://pastebin.com/KGctWABE)
01:42:16 <cocreature> joel135: hm that sucks. you could try bumping the snapshot in "stack.yaml" to lts-9.1
01:42:37 <cocreature> I added archlinux builds for ghc 8.0.2 and ghc 8.2.1 so that should work
01:43:20 <cocreature> but I have no idea if the tutorials compile with 8.0
01:43:36 <koz_> ski: Thank you!
01:43:42 <koz_> I appreciate the input.
01:44:00 <koz_> Also, if anyone could inform me what hylomorphisms have to do with either matter or trees, I'd be very grateful.
01:44:11 <koz_> (trying to understand the use of the 'hylo' root in the name and why it was chosen)
01:44:38 <ski> (i just edited my annotation, having noticed i didn't finish one sentence. also added a little bit more in another place. reload the page if you don't see this)
01:45:38 <koz_> ski: Thanks - gonna re-read.
01:45:52 <koz_> Do you think my solution with the state monad use is sensible for something like this?
01:49:44 <cocreature> joel135: I guess I could also upload the package I built when the link was still working if you want to trust a package provided by a stranger on the internet :)
01:51:58 <joel135> No need, it works! (I also had to bump the transformers version.)
01:52:55 <joel135> I
01:53:07 <joel135> I'm building just the calculator example for now.
01:53:10 <ski> koz_ : i'm not sure, but i suspect "hylo" refers to "tree". the idea is to introduce (build) an intermediate data structure ("tree"), then tear it down. iow factoring the computation as computing this intermediary, then combining the information in (usually) some other way, to compute the result (otherwise we wouldn't need to keep track of all the intermediate information "at the same time" (remember non-strictness blurs this))
01:53:43 <koz_> Yeah, I guess that makes sense.
01:54:16 <koz_> I'm asking because I'm writing a blog post about divide-and-conquer algorithms and how hylos make them very easy to write.
01:54:21 <koz_> (using mergesort as an example)
01:54:27 <koz_> (hence the vector merge above)
02:06:11 <iqubic> koz_: You going to write about quick-sort too?
02:06:42 <DigitalKiwi> or any of the other useful sorts
02:08:22 <iqubic> DigitalKiwi: Are there any other useful divide-and-conquer sorts out there?
02:10:24 <DigitalKiwi> all of them
02:11:46 <DigitalKiwi> especially when you consider I intended sort as a pun and thus includes divide-and-conquer algorithms other than sorting
02:12:18 <ski> koz_ : yes, unless one goes "full imperative" and uses `create' with an explicit recursive loop that just mutates the output directly
02:12:56 <iqubic> I wonder if a divide-and-conquer pathfinding algorithm
02:12:58 <merijn> mergesort is best sort :)
02:13:20 <iqubic> I like quick-sort
02:13:22 <cocreature> odd-event-transposition-sort!
02:13:25 <cocreature> *even
02:13:54 <merijn> iqubic: I don't :p Merge-sort is nicer in many ways: Easier to parallelise, cache friendlier, MUCH simpler to implement without error
02:14:23 <ski> koz_ : atm, i don't see any other reasonable way to build your new vector by comparing the elements of the given ones (merging them) (whose exact index progress can't be predicted)
02:14:25 <merijn> The main argument is "needs extra memory", but in-place variants exist and don't lose any benefits
02:14:33 <koz_> ski: Good to know.
02:14:42 <merijn> iqubic: Oh, I forgot an important one: Mergesort's worst case complexity is better than quicksort too!
02:14:53 <koz_> merijn: I think mergesort is also cooler pedagogically-speaking.
02:15:23 <merijn> Mergesort is O(n log n) worst case, quicksort is O(n^2) worst case
02:15:42 <koz_> ski: I had the same suspicions, and there's no way I'm doing that kinda thing in ST - it's just too ugly.
02:15:46 <ski> koz_ : still, you always fill in the output elements in order, so the full power of `create' is not needed. perhaps this means that the `replicateM' (or `unfoldrN') solution is more efficient, then
02:16:00 <DigitalKiwi> one of my favorite CS courses was C++ III which was actually "data structures using c and c++
02:16:02 <DigitalKiwi> "
02:16:02 <koz_> I didn't consider using unfoldrN actually.
02:16:19 <ski> (in case the fusion, or whatever, can take advantage of the knowledge of that restriction of the generation)
02:16:21 <DigitalKiwi> but after that rarely have I had to implement data structures :(
02:16:37 <DigitalKiwi> except in FORTRAN for ME lololol
02:17:30 <iqubic> I wonder if a divide-and-conquer pathfinding algorithm. Does something like that exist?
02:17:41 <koz_> iqubic: Define 'pathfinding'.
02:17:42 <DigitalKiwi> where's the thing dibblego would give me with the list of things to learn haskell
02:17:58 <ski> koz_ : it may perhaps also be possible to compute it "compositionally", by (seemingly) using one (or more) intermediate vectors, and multiple vector operations. perhaps fusion could in such case remove the intermediate overhead. i'm not seeing atm what would be a candidate of this approach, though
02:18:16 <koz_> ski: Yeah, it seems very tricky, and I'm not sure if the benefits would be worth it.
02:18:28 <merijn> iqubic: I think it exists, but I don't think it'll be efficient
02:18:40 <merijn> iqubic: At least, not in the simple case
02:18:48 <merijn> (sequential implementation)
02:19:10 <ski> koz_ : any comments/questions on my comments/changes in the paste annotation ?
02:19:14 <merijn> There's a bunch of other optimisations, etc. for pathfinding, though
02:19:20 <merijn> Like precomputing hubs
02:19:32 <koz_> ski: It makes sense - thank you for the detailed response.
02:19:49 <koz_> I'll need to look at it when I'm less tired - I'll copy it into a file for further inspection tomorrow.
02:19:55 <ski> ok
02:20:13 <DigitalKiwi> use a quantum computer to calculate all of them at once!
02:20:14 <koz_> But I definitely appreciated the detailed feedback - especially stuff like sort stability.
02:20:33 <koz_> (it's something I tend to forget)
02:20:53 <cocreature> interestingly parallel multi-pivot quicksort and parallel multiway mergesort start to look remarkably similar
02:21:18 <merijn> cocreature: What do you mean by multiway mergesort?
02:21:28 <merijn> cocreature: merging more than 1 list at a time?
02:21:36 <merijn> eh, more than 2
02:22:09 <cocreature> merijn: yes, basically the one described in https://arxiv.org/pdf/1410.6754.pdf
02:22:50 <cocreature> and I guess by multi-pivot quicksort I’m really referring to samplesort
02:22:58 <merijn> Does that make a lot of sense?
02:22:59 <koz_> cocreature: That's a really cool paper.
02:23:00 <DigitalKiwi> hmm, is eta real Haskell on JVM or are there differences 
02:23:08 <iqubic> So you can turn [[4,0],[2,3],[1,2]] into [0,1,1,2,3,4]?
02:23:19 <ski> koz_ : btw, note that the `unfoldrN' version is almost the same as the state monad one using `replicateM'. perhaps it would be nice with a version of `unfoldrN' which skipped the `Maybe', relying on the given size to cut off. i suppose one could use `iterateN', but then one'd had to couple each element with the current two indices, in order to be able to compute the next two of them, then do a `map' to strip this off. quite possibly fusion would make this e
02:23:30 <merijn> I'd figure doing multiple 2way merges in parallel is better than doing 1 with many
02:23:38 <ski> er, cut off near : ".., in order to be able to compute the next two of them, then do a `map' to strip this off. quite possibly fusion would make this efficient"
02:23:42 <cocreature> merijn: it seems to perform pretty well but we’re talking about distributed sorting in large clusters not sorting in parallel on the 4 cores in your laptop
02:23:49 <merijn> cocreature: Acutally, is that still O(n log n)? Since you do more comparisons
02:24:12 <koz_> ski: I'll try sketching that tomorrow and seeing whether it looks more elegant.
02:24:32 <koz_> Haskell: The language where you spend time on the elegance of sorted vector merging. :P
02:24:50 <cocreature> merijn: I don’t remember, it’s been a while since I’ve looked at it
02:24:55 <merijn> koz_: I'm also doing that in C++... :p
02:25:14 <koz_> merijn: Sorted vector merging, or considering the elegance of said?
02:25:48 <ski> koz_ : iow, perhaps one reasonable attempt of the "compositionally, with fusion" approach would be `merge v1 v2 = V.map (\(f0,f1,a) -> a) (V.iterateN totalLength (\(f0,f1,_) -> ...))'
02:26:02 <merijn> koz_: Well, sorting vectors in general :)
02:26:23 <koz_> ski: What does 'iow' stand for again?
02:26:28 <koz_> Oh, if you want.
02:26:28 <ski> "in other words"
02:26:37 <koz_> Oh, wait, never mind, lol.
02:26:44 <koz_> Yeah, I kinda see that, but my brain's a bit slow right now.
02:27:45 * hackagebot ghc-proofs 0.1 – GHC plugin to prove program equations by simplification – https://hackage.haskell.org/package/ghc-proofs
02:27:45 * hackagebot stateWriter 0.2.9 – A faster variant of the RWS monad transformers. – https://hackage.haskell.org/package/stateWriter
02:28:28 <ski> (er, also providing a starting element to `iterateN' of `(0,0,undefined)', i also suppose we need to generate one more element, and then strip off the first one, due to how `iterateN' works .. this is getting more complicated than i was thinking :)
02:29:01 <ski> > iterate (2 *) 1 -- includes the `1' as well
02:29:03 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
02:29:42 <ski> > scanl (+) 0 [0,1,2,3]  -- also includes the initial state
02:29:44 <lambdabot>  [0,0,1,3,6]
02:56:02 <wagle> i'm wondering what ide to try today for really hacking haskell (code transformations, etc)?  (I haven't done much haskell programming in a couple years)
02:59:52 <taktoa> wagle: (structured-)haskell-mode for emacs, leksah
03:01:14 <wagle> taktoa: yeah, i saw that..  thanks
03:05:53 <iqubic> wagle: do you know emacs?
03:19:04 <ski> wagle : perhaps <https://wiki.haskell.org/HaRe> could be interesting (i haven't tried it)
03:21:29 <ski> (<https://www.cs.kent.ac.uk/projects/refactor-fp/>,<https://www.cs.kent.ac.uk/projects/refactor-fp/hare.html>,<http://haskelltools.org/>,<https://www.researchgate.net/publication/236330702_Tool_Support_for_Refactoring_Haskell_programs>)
03:31:53 <edwardk>  
03:32:55 <MarcelineVQ> ​
03:39:57 <boj>  
03:43:01 <wagle> not entirely sure what I'm looking for, but i think its a hybrid structure/text editor
03:43:28 <wagle> and its really gotta grok all the special ghc magic
03:43:41 <wagle> prolly will have to make this myself
03:44:16 <boj> wagle: maybe this sounds weird, but after coding for two decades it turns out a simple text editor and repl are all you really need
03:47:58 <boj> maybe i have a weird point of view. the moment you want an ide, or your editor to do all-the-things, it feels like you fly off into enterprise land. somewhere i desparately don't want to be, because the level of thinking involved seems to dip dramatically
03:48:28 <cocreature> even outside of enterprise land you sometimes want to do things like rename variables
03:48:34 <cocreature> or rename modules
03:48:40 <boj> a world where your life devolves into importing libraries and copy/pasting stackoverflow...
03:49:02 * boj is not 100% jaded... just 99%...
03:49:06 <iqubic>    
03:49:15 <wagle> wellm i uaed to be able to do that.  now the premise is that I have to externalize my brain in order to be productive.  not saying normals should do this
03:49:57 <ski> boj : the Alfa structural editor for Agda1 had some nice features, that i miss in the Agda2 Emacs mode
03:51:13 <wagle> in the past, I did massive global algebraic transformations of programs.  in my head.  cant do that anymore.
03:51:28 <wagle> but oh well.
03:52:25 <wagle> gotta get this non-verbal stuff out of my head so others can see/use it before i die
03:53:27 <wagle> very hard to explain non-verbal stuff...
03:54:33 <wagle> but just thought I'd poke the lazyweb for any new developments
03:54:48 <wagle> (ie, that google wasnt showing me)
03:55:38 <cocreature> haskell-ide-engine and intero are probably two of the more advanced editor integrations for Haskell but neither of them is particularly good at doing automatic code transformations
03:56:54 <wagle> cool
03:59:23 <ski> boj : Riastradh's paredit mode for navigating and editing sexps (also works with other kinds of brackets, though doesn't handle XML afaik) is also useful
04:00:18 <ski> ("zoinking" is something that i'd wished for)
04:00:21 <wagle> cocreature: haskell-ide-engine looks especially interesting
04:00:58 <wagle> been taking intellij's MPS pretty seriously, but would have to write a haskell/ghc parser
04:01:07 <cocreature> haskell-ide-engine integrates hare so it can do some transformations but it can’t do cross-module transformations which doesn’t make it particularly useful for me
04:02:03 <wagle> hmm  might be bad
04:02:30 <boj> ski: i gave up somewhere along the way and embraced unencumbered text editing (with vim commands)
04:03:20 <wagle> I need to comprehend/visualize large programs..  emacs does not help me do that
04:03:42 <wagle> even if I was borned and raized on emacs
04:04:01 <boj> everyone is different
04:04:04 <wagle> works great for small programs
04:04:22 <kuribas> wagle: you learn to understand large programs by looking at the components, not at the whole program at once...
04:05:06 <wagle> well, i dispute that dogma
04:05:11 <wagle> i guess
04:06:08 <kuribas> wagle: I don't have any trouble understanding large programs on emacs...
04:06:26 <cocreature> just because emacs works for you, doesn’t mean it works for everyone
04:06:42 <kuribas> I am not saying it does
04:07:07 <kuribas> Just that it's possible
04:07:18 <wagle> I used to be able to memorize medium sized programs in my head, and reason about them (while walking around) at all sorts of levels, and produced pretty-much-bug free programs, which I assume, you, due to your methodology, dont believe in
04:07:21 <boj> maybe haskell is helpful here. i've noticed it's easier to be interrupted because i don't need to maintain such a large mental model
04:07:22 <kuribas> emacs does have a lot of quirks
04:07:43 <wagle> at no point did i assert anything about emacs for other people
04:07:58 <cocreature> I don’t believe anyone that claims to produce “pretty-much bug-free programs” :)
04:08:04 <cocreature> regardless of the tools they’re using
04:08:14 <wagle> and thats why you all fails
04:08:16 <kuribas> wagle: I am very skeptical about that claim.
04:08:17 <wagle> and thats why you all fail
04:08:28 <boj> wagle: "you all", but not you huh?
04:08:48 <wagle> yes.. since 1980
04:08:48 <boj> never swapped a "<" with ">" on the rare occasion?
04:08:49 <kuribas> wagle: in any case, "I" don't produce bug-free programs, and I am happy haskell helps me with that :)
04:09:23 <wagle> but I can't do it in my head anymore
04:09:47 <boj> this is all fun and off-topic-y
04:09:53 <wagle> so I HAVE to externalize it onto my computer.  thats my purpose in life now
04:10:18 <kuribas> wagle: and even if you could, you would still work with people who can't.
04:11:06 <wagle> well, yeah, unless they can wrap their brains around my methodology
04:11:35 <ski> (boj : fwiw, i don't really use IDEs (i don't consider Emacs one). however, i can't help wondering if some ideas actually could help)
04:11:42 <wagle> which is in the non-verbal part of my brain, where noone can see it
04:12:16 <wagle> so I'm trying to get it out.  my grant pays for the next 3 years of that
04:12:29 <WinterFox[m]> Hi
04:12:36 <kuribas> wagle: in other words, it's useless to anyone but you...
04:13:12 <boj> ski: to be fair, ghc-mod and intero and their eta suggestions helped shape my thinking a bit. they were quite useful, and maybe i am missing something by not using them. maybe dante making it into the spacemacs release branch will make its way back into my config
04:13:37 <wagle> right now, yes.  hence the "get it out of my head" phrase I've used three times so far.
04:13:53 <boj> WinterFox[m]: hi
04:14:34 <iqubic> boj: I was using spacemacs for the past few months, but then I decided I wanted to write my own .emacs file.
04:14:35 <WinterFox[m]> Just getting started setting up Haskell for the first time.
04:14:55 <wagle> the masses believe that programs cannot be bugfree, so they don't even try, and try to shoot down anyone who questions that dogma
04:14:57 <iqubic> I also decided to get rid of evil at that time.
04:15:00 <WinterFox[m]> So the stack tool is like a package manager and make built in to one thing?
04:15:33 <boj> iqubic: i don't have a strong opinion there. i started writing my own, then found spacemacs later. i just wanted to get things done so went for the convention model
04:15:42 <cocreature> WinterFox[m]: yeah that’s a reasonable description
04:15:42 <iqubic> boj: Do you use Evil?
04:15:56 <boj> iqubic: yeah. long term vim user, lost without it
04:15:59 <wagle> but I just camae here to see what the latest in haskell programming was these days
04:16:18 <iqubic> boj: I learned emacs bindings yesterday.
04:16:43 <kuribas> wagle: the masses don't even know what bug-free means :)
04:16:58 <iqubic> Like it took me just a day to learn it.
04:16:59 <wagle> I very well understand that I need to proe my thesis
04:17:13 <iqubic> C-h ? is the best thing about emacs.
04:17:24 <wagle> prove
04:17:28 <iqubic> boj: Do you use org-mode too? Or no?
04:18:04 <wagle> proof-reading is a necessity, by the way
04:18:11 <kuribas> iqubic: C-h m is very useful.
04:18:23 <iqubic> Yeah it is.
04:18:26 <boj> iqubic: here and there. usually personal stuff
04:18:37 <wagle> proof-reading a million lines of code does not work very well
04:18:44 <kuribas> iqubic: it took me maybe a year to get comfortable in emacs.
04:19:16 <iqubic> kuribas: Do you use evil? Or do you use regular old emacs bindings?
04:20:03 <kuribas> iqubic: regular old
04:20:21 <kuribas> iqubic: well, with some customized behaviour in emacs lisp
04:20:41 <iqubic> Cool.
04:20:57 <boj> iqubic: i think buffer swapping via like ivy/helm, no tree view, no tabs, etc. are a huge win. but you'll have to rip vim modal commands from my dead hands. the reach of standard emacs commands are frustrating (although i can see the merit of non-modal editing)
04:21:09 <kuribas> the customization aspect is what I like the most about emacs
04:21:27 <iqubic> Guys, Guys... I, too, use emacs.
04:21:41 <boj> hugs all around
04:22:09 <iqubic> I used to use evil mode, but decided that I wanted to learn the regular bindings. I'll give it a few months before deciding what to use for long term
04:22:33 <boj> once you turn into a grouchy old man it's all over
04:23:07 <boj> pick your poison and stick with it
04:23:30 <kuribas> iqubic: the nice thing about emacs is that you don't have to stick to one choice.
04:23:35 <iqubic> I know.
04:24:46 <iqubic> boj: Why do you say that standard emacs is poison?
04:25:41 <kuribas> it's a patched up monster, but there's nothing like it
04:25:43 <boj> iqubic: i mean any choice is poison, in that as programmers we will never be satisfied as we continue to look for the next best thing. i imagine i'll die happy once i have a direct brain interface :)
04:25:52 <parable> iqubic: It's just a colloquialism (pick your poison)
04:26:15 <iqubic> boj: I know what you mean.
04:26:38 <iqubic> I switched to emacs for org-mode. A year later I still haven't learned it.
04:27:07 <Clint> iqubic: i only use emacs for org-mode
04:27:46 <iqubic> And does it work well?
04:27:56 <iqubic> What do you use for Haskell coding?
04:27:59 <Clint> vim
04:28:30 <iqubic> Ah.
04:28:38 <iqubic> Do you use evil mode in Emacs?
04:28:59 <iqubic> Along with org?
04:29:55 <boj> iqubic: if you are trying to determine if vim modal editing is the way to go, i'd say it's a deeply personal choice. i watch my colleague point and click his way around windows/code and it drives me insane, but that's how he gets things done
04:30:39 <boj> at least he is writing haskell :p
04:30:44 <iqubic> boj: Really what I'm trying to learn is how well the org+evil integration is.
04:30:46 <WinterFox[m]> On linux how would I run a program after building with stack? The documentation seems to be for windows.
04:31:03 <iqubic> stack exec programName
04:31:17 <boj> iqubic: i would say not an issue? you get the modal editing, but the org-mode commands to shift things around
04:31:22 <WinterFox[m]> "Executable named hello-world not found on path:"
04:31:31 <iqubic> But don
04:31:43 <Clint> iqubic: no
04:32:15 <parable> WinterFox[m]: https://docs.haskellstack.org/en/stable/GUIDE/
04:32:17 <boj> WinterFox[m]: either "stack exec programname" a iqubic said, or "stack install" and it will (be default) go to ~/.local/bin. if that is in your path you can execute it
04:32:24 <iqubic> But don't you have to learn the ctrl and meta keybinds?
04:32:43 <iqubic> To get org+evil working.
04:32:57 <boj> iqubic: for org-mode, yes. there are no evil mode bindings into it that i am aware of
04:33:18 <iqubic> I see.
04:36:55 <arich> I wantxdcc downloads
04:37:12 <arich> Wherethe fuck can iget
04:37:35 <iqubic> What is wantxdcc?
04:37:43 <iqubic> Also, no swearing.
04:37:49 <arich> Sorry
04:38:06 <arich> First time i got response
04:38:16 <arich> I want music via xdcc
04:38:22 <arich> Or dcc
04:38:31 <iqubic> What is xdcc?
04:38:47 <arich> Its file downloading
04:38:49 <cocreature> arich: you’re in the wrong channel. this channel is about the Haskell programming language
04:39:15 <arich> Ok
04:39:21 <arich> New here so
04:39:38 <iqubic> New to what?
04:48:01 <DarkLeggend> !list
05:00:34 * hackagebot cabal2nix 2.5 – Convert Cabal files into Nix build instructions. – https://hackage.haskell.org/package/cabal2nix
05:29:16 <tsahyt> what's the currently best way to use ghcjs with stack? is there some way that doesn't require a systemwide ghcjs installation?
05:30:01 <cocreature> tsahyt: https://docs.haskellstack.org/en/stable/ghcjs/#recent-versions-of-ghcjs-repacked-for-stack
05:30:33 <tsahyt> that is quite old. lts-7.15 is pretty ancient by now
05:30:42 <merijn> What's the recommended library for dealing with OpenGL?
05:30:47 <cocreature> merijn: gl
05:31:47 * hackagebot aivika-distributed 0.7.1.1 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
05:32:09 <cocreature> tsahyt: if you’re willing to get your hands dirty, https://github.com/tolysz/prepare-ghcjs/issues/10#issuecomment-324488966 contains some discussions about newer versions but I would recommend to jusut stick with the lts 7.15 snapshot and add newer things you really need to extra-deps
05:32:22 <tsahyt> hm okay
05:32:54 <merijn> tsahyt: Lemme know how ghcjs works out for you, because I've considered using it, but decided it seemed to huge :)
05:33:57 <tsahyt> merijn: for me atm it's between ghcjs, purescript, and idris. I'm heavily biased towards ghcjs though because it's the only one that is lazy by default, and for my usecase I don't mind having a 500k runtime js file
05:34:18 <cocreature> merijn: huge in what way? the generated js?
05:34:24 <merijn> cocreature: Yes
05:34:27 <tsahyt> I'm trying to work out whether it's feasible to write a gnome shell extension using a functional language
05:34:30 <tsahyt> preferably haskell
05:34:36 <merijn> cocreature: Also the amount of stuff I need to build to use it :p
05:34:59 <cocreature> compared to image assets and whatever else you’re going to include on your website, it’s really not so bad
05:35:49 <tsahyt> also having all of hackage (minus FFI stuff) available is quite a huge plus
05:35:52 <merijn> cocreature: eh...I don't believe in websites including such huge shit either :)
05:35:59 <cocreature> *shrug*
05:36:13 <akamaus> hello all. I've just installed haskell-platform-8.2.1 and I'm getting weird messages about shadowed dependencies. Like this: https://paste.ofcode.org/39in2mGqV89U8M8z4zSqEyW# .  Is it a known issue?
05:36:43 <tsahyt> merijn: but if you want smaller files, purescript is always an option I suppose
05:36:47 <merijn> cocreature: the gl package seems rather terifying tbh :)
05:36:52 <cocreature> merijn: how so?
05:37:27 <merijn> cocreature: No obvious entry point
05:37:58 <Athas> akamaus: can you provide the output of 'ghc-pkg list'?
05:38:01 <merijn> cocreature: Just 4 billion modules with no docs 
05:38:01 <cocreature> the bindings follow the C API very closely
05:38:14 <merijn> cocreature: Yeah, but I don't know the C API at all :p
05:38:47 <cocreature> merijn: sounds like what you want is something that provides you with a highlevel graphics API and not something to deal with OpenGL :)
05:38:49 <Athas> That's also how the X11 package works!
05:38:57 <merijn> cocreature: Well, yes
05:39:09 <Athas> Although the X11 package has the "feature" that it tends to hide error codes.
05:39:12 <cocreature> merijn: 3d or is 2d sufficient?
05:40:19 <akamaus> Athas, here it is: https://paste.ofcode.org/NKJzX3L63e43ZxhW7RFkPC
05:40:44 <akamaus> It's almost fresh install, as I said
05:40:48 <merijn> cocreature: preferably 3d, but if you know something that's super easy/nice but only 2d I'm interested
05:41:43 <cocreature> merijn: I have bindings for nanovg which are pretty straightforward https://hackage.haskell.org/package/nanovg-0.5.2.0/docs/NanoVG.html
05:43:05 <Athas> akamaus: I have no idea what is going on.  Have you tried -v to get more information from cabal?
05:43:38 <merijn> I'll have look
05:46:40 <akamaus> Athas, a bit more interesting :) https://pastebin.com/ewAamWDY 
05:47:48 <akamaus> text-1.2.2.2-EGUst8sqNAZCw1xLPcmcMH is precisely the same version as was installed with platform: /usr/local/haskell/ghc-8.2.1-x86_64/lib/ghc-8.2.1/package.conf.d/text-1.2.2.2-EGUst8sqNAZCw1xLPcmcMH.conf
05:48:15 <Athas> akamaus: yes, but it looks like '-package text' is not being passed in the GHC invocation.  No idea why that is.
05:48:44 <Athas> I am always willing to suspect some platform/cabal-install breakage...
05:48:53 <serses> can someone help me with this? https://p.teknik.io/Simple/0y1dt  I get " An opening format directive is never closed; expecting '}'."
05:49:16 <akamaus> Athas, ah, I see now...
05:50:07 <merijn> cocreature: basically I wanna experiment a bit with generating pretty pictures, procedural generation, etc. so I don't quite know what I want beyond 1) produce pictures 2) have the smallest amount of work between me and succesfully displaying something :)
05:50:25 <boj> serses: uh, wrong language?
05:50:32 <akamaus> Athas, let's try previous version of haskell-platform then
05:50:38 <serses> oh crap sorry
05:50:47 <Athas> akamaus: have you tried stack?
05:50:56 <cocreature> merijn: if you don’t need it to be too fast, diagrams might also be worth a look
05:51:00 <boj> serses: i mean, if you wanna convert it to haskell we are all over it :)
05:51:27 <merijn> cocreature: diagrams is fine for simple vector things, but not for interactive things, also you can't texture anything atm, so that's a bit limiting
05:55:12 * hackagebot hw-conduit 0.2.0.2 – Conduits for tokenizing streams. – https://hackage.haskell.org/package/hw-conduit
06:25:36 * hackagebot hw-prim 0.4.0.4 – Primitive functions and data types – https://hackage.haskell.org/package/hw-prim
06:35:40 * hackagebot hw-prim 0.4.0.5 – Primitive functions and data types – https://hackage.haskell.org/package/hw-prim
06:40:55 <brachiel> Hey all. Is there a framework for web apps where I can write both the server and client code in Haskell and communication is seamless?
06:42:45 * hackagebot hw-int 0.0.0.3 – Integers – https://hackage.haskell.org/package/hw-int
06:43:18 <peterhil> brachiel: Quickly looking at Haskell Web framework listing, I found Miso https://github.com/dmjio/miso, that I do not know from before, and it seems to do exactly that.
06:43:31 <peterhil> Also, I guess you now Elm?
06:43:55 <brachiel> I do not know anything about web apps in Haskell. So thanks for both of those suggestions
06:44:44 <cocreature> miso is great but it doesn’t really do client-server communication
06:44:46 <peterhil> Miso is inspired by  Elm, Redux and Bobril.
06:44:51 <peterhil> Aha, ok.
06:45:35 <cocreature> you can ofc do xhr, websockets and whatnot. but it won’t magically communicate between the server and the client
06:48:45 <brachiel> seems like it should be possible to abstract the communication away such that one writes client code as if one had direct access to the database and deciding the server/client border with a special compose
06:50:02 <cocreature> that breaks down as soon as there is a network error
06:50:29 <cocreature> it can also lead to code that performs badly because you are communicating between the server and the client without realizing it
06:53:02 <cocreature> brachiel: the transient lib gives you something like this if you really want it
06:53:48 <brachiel> thanks for the pointer, cocreature. Will look into it :)
06:58:58 * hackagebot hw-parser 0.0.0.3 – Simple parser support – https://hackage.haskell.org/package/hw-parser
07:03:58 <merijn> cocreature: Actually, I guess maybe SDL is interesting too?
07:04:58 * hackagebot hw-bits 0.7.0.1 – Bit manipulation – https://hackage.haskell.org/package/hw-bits
07:04:59 * hackagebot hw-balancedparens 0.2.0.1 – Balanced parentheses – https://hackage.haskell.org/package/hw-balancedparens
07:05:30 <cocreature> merijn: maybe, I’ve only used sdl to get opengl contexts so far :) but it does have some kind of graphics api that nobody seems to use
07:18:12 * hackagebot hw-rankselect 0.10.0.3, hw-rankselect-base 0.2.0.2, hw-string-parse 0.0.0.4
07:18:12 * hackagebot  → https://hackage.haskell.org/packages/recent
07:21:31 <trigone> hi! is there a way to automatically include the source code inside a haddock documentation, perhaps hidden in foldable sections? alternatively, is there a way to tell haddock that the source body of some function should be its very documentation?
07:22:51 <merijn> trigone: Not really, afaik?
07:23:18 <merijn> trigone: Why would the source be the docs? If they want that they can just click the source link in the haddocks?
07:24:04 <cocreature> docs should tell you how to use something, not how it’s implemented
07:24:55 <MarcelineVQ> there is another angle, haddock is made from source, if you want to read haddock and the source at the same time you can read the source
07:32:23 <trigone> sometimes there's not much more than the source which is needed to understand a function. not in all, or even most cases, but in some, you do nothing but read the source code in natural language... but anyway if there's no way, nevermind :) as for links to the source, well sometimes it doesn't seem to work very well when i'm on hackage. and reading the source directly is much less convenient than if you could access the source on d
07:32:32 <trigone> on demand from the documentation itself
07:55:15 <merijn> cocreature: ah, I forgot all about gloss!
08:18:23 <tsahyt> can ghcjs do foreign exports? e.g. I have some function foo :: IO (), and I want to export a js function foo that can be called from js. is that possible?
08:18:38 <merijn> tsahyt: AFAIK it is, but don't ask me how :)
08:18:47 <tsahyt> well at least that's not discouraging
08:19:14 <tsahyt> merijn: about size, hello world after minification and gzip weighed in at 111k
08:19:23 <tsahyt> does nothing but print hello world to the console
08:19:33 <tsahyt> so that's roughly the overhead of the rts and whatever other machinery is involved
08:19:44 <Welkin> did that also involve tree shaking or any other dead code elimination?
08:19:51 <Welkin> because that should reduce it a lot more
08:20:10 <tsahyt> not intentionally anyhow
08:20:23 <tsahyt> I used jscompress.com for minification because that was the first thing I found
08:20:48 <cocreature> tsahyt: https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Foreign/Callback.hs is probably what you are looking for
08:21:04 <erisco> but printing "hello world" twice does not cost 222k
08:21:27 <tsahyt> erisco: yes, I just wanted to have some kind of measurement for how big the baseline is
08:21:40 <Welkin> speaking of compile-to-js, have you looked at purescript as well?
08:21:56 <tsahyt> yes I have but strictness alone is enough to make me try ghcjs at all costs
08:22:03 <Welkin> bucklescript is also interesting, although it is ocaml (so not a great type system)
08:22:20 <erisco> sounds hipster
08:22:24 <Welkin> they seem to focus more on speed and small file sizes
08:22:28 <philr> MOTD
08:22:32 <Welkin> facebook uses it for their Reason language
08:22:41 <tsahyt> cocreature: I'm not dealing with a callback, I need to eventually end up with a js file that has a few functions with some given names. I'll look into it, maybe this can still work.
08:23:11 <dysfun> tsahyt: haste is quite good too
08:24:45 <cocreature> tsahyt: I don’t think there is something that lets you choose the name of the resulting function. but you could just do some kind of "foreign import javascript interruptible "functionName = $1;" setFunction :: JSVal -> IO () and then call that at startup
08:24:55 <dysfun> there's also fay (has a lovely ffi but no typeclasses)
08:25:31 <cocreature> eh s/interruptible/unsafe/
08:25:38 <cocreature> but it probably works with interruptible too
08:25:50 <cocreature> hm maybe not
08:25:53 <cocreature> *shrug*
08:27:40 <tsahyt> I see
08:28:07 <tsahyt> hmm, there is an init function being called by gnome when starting up an extension, I could wrap the runmain stuff there and do whatever is necessary to register the rest
08:28:26 <tsahyt> I don't mind having to write that manually.
08:28:45 <Welkin> what does gnome have to do with javascript?
08:29:32 <tsahyt> Welkin: gnome extensions are written in js
08:29:43 <tsahyt> actually a surprisingly large part of the whole UI runs on js
08:29:45 * hackagebot aivika-distributed 0.7.2 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
08:30:28 <tsahyt> so I was thinking that it might be possible to write an extension in haskell, compile it with ghcjs, build some hacky scaffolding and get it running
08:30:48 <tsahyt> just a stupid idea that seems worth wasting a weekend on
08:32:40 <Welkin> tsahyt: oh, I forgot about gnome shell
08:33:00 <erisco> what materials are there for learning how to extend GHC?
08:33:03 <Welkin> tsahyt: yes, that sounds like a very convoluted idea
08:33:12 <Welkin> you could just write it in javascript using es6 with babel
08:33:15 <dysfun> erisco: reading the source!
08:33:26 <Welkin> at least you get some resemblance of functional programming (without a type system)
08:33:52 <Welkin> I have seen people use rxjs to write things like that
08:34:53 <tsahyt> hm, I mean using haskell or at least something closely related is kinda the point
08:35:11 <tsahyt> if the choice is a js-like thing, I'd rather not write it at all, at least not in my spare time
08:36:11 <stevenxl> Hi folks. I am trying to create an abstract data type. I want to export the type constructor but not the data constructor. I have an export list with no data constructors, but when I import the module in ghci the data constructors are still in scope.
08:36:27 <tsahyt> stevenxl: are you importing it in ghci or are you loading it?
08:36:35 <stevenxl> tsahyt: Ah - I'm loading it. Using :l
08:36:45 <tsahyt> yes, that's to be expected then
08:36:45 <stevenxl> Is there a :i for import?
08:36:45 <stevenxl> let
08:36:57 <erisco> it is called "import"
08:37:07 <tsahyt> I just use import
08:37:14 <tsahyt> but :m +Module works too
08:37:26 <stevenxl> cool thank you!
08:37:27 <tsahyt> I'm not sure what exactly the difference is, if any
08:39:33 <geekosaur> import is more flexible
08:40:35 <geekosaur> :m still has two things you can't do the other way: you can un-import (:m -Module) or switch order/"focus" (:m alreadyLoadedModule)
08:42:14 <tsahyt> I suppose :m can't do qualified import?
08:44:02 <geekosaur> right, that's one of the things import has. also renamings (import .. as Foo)
08:44:54 <geekosaur> I haven't tested if you can do partial imports (import Foo (Bar(..), ...)) but I suspect that also works and has no :m equivalent
08:45:31 <stevenxl> OK - a question on idiomatic Haskell. If I have an abstract data type and a smart constructor, clients of the code can't create "wrong" values of that data type. However, they also can't pattern match on the value since the data constructors are hidding. The way I know to get around this is by creating another data type, isomorphic to the abstract data type, and then using view patterns to convert the adt to the
08:45:31 <stevenxl> non-adt, which can be pattern matched again.
08:46:03 <geekosaur> 7.10 introduced pattern synonyms
08:46:17 <Welkin> what do you mean by "wrong values"?
08:46:23 <Welkin> as long as the types match
08:47:30 <geekosaur> Welkin, consider Data.Map, you need to maintain an invariant of strictly ascending keys in the tree structure
08:48:23 <geekosaur> or data EvenInteger which is constrained via smart constructor and Num/Integral instances to only hold even numbers
08:48:56 <Welkin> won't dependent types help with that?
08:49:16 <Athas> stevenxl: what is the question?  What you are describing is the right way to do it.
08:49:22 <geekosaur> but they're not here now
08:49:40 <stevenxl> Athas: the question was if it was idiomatic to do that or not. ;)
08:50:02 <stevenxl> geekosaur: thanks I'll look into pattern synonyms. 
08:54:39 <monochrom> Dependent typing unhelps by the time you also care about abstraction and information hiding.
09:00:49 <monochrom> For example dependent typing applied to Data.Map.Map: BinTree k v (every node satisfies: left child key, if it exists, is <= my key && my key <= right child key, if it exists && 3*(left subtree weight) >= right subtree weight && left subtree weight <= 3*(right subtree weight))
09:01:07 <monochrom> Quite frankly, who cares.
09:03:55 <Welkin> lol, unhelps?
09:04:17 <monochrom> The antithesis of help.
09:11:32 <alanz> cocreature: what cross-module refactorings are you wanting to do?
09:13:34 * hackagebot hmatrix-morpheus 0.1.0.0 – Low-level machine learning auxiliary functions. – https://hackage.haskell.org/package/hmatrix-morpheus
09:26:42 * hackagebot hmatrix-morpheus 0.1.0.1 – Low-level machine learning auxiliary functions. – https://hackage.haskell.org/package/hmatrix-morpheus
09:32:07 <cocreature> alanz: the most important one is probably simply renaming identifiers
09:32:56 <alanz> cocreature: for HaRe renaming does go cross-module
09:33:00 <cocreature> oh nice
09:33:05 <alanz> including qualifying if needed
09:33:14 <cocreature> alanz: can hare also rename modules? that’s even more annoying since you also have to edit the cabal file
09:33:36 <alanz> not yet
09:33:45 <alanz> But it is definitely something that is needed
09:34:00 <cocreature> I really need to play around with hie sometime soon :)
09:34:18 <cocreature> sounds like you are really getting things in a usable shape
09:34:53 <alanz> yes, finally
09:35:34 <alanz> And wz1000 has taken it from a proof of concept to something useful, this summer
09:36:04 <cocreature> alanz: kudos for not giving up on this
09:36:16 <alanz> The key is to get it to the point of being usable by default, then it can start improving bit by bit
09:36:26 <alanz> cocreature: thanks. I play a long game :)
09:37:07 <sm> go alanz go
09:37:17 <alanz> tks
09:42:56 * hackagebot hmatrix-morpheus 0.1.0.2 – Low-level machine learning auxiliary functions. – https://hackage.haskell.org/package/hmatrix-morpheus
09:46:07 <bollu> Is there a book for abstract interpretation?
09:53:16 <Lokathor> bollu, there is, but no one can make sense of it
09:53:25 <bollu> lol
09:53:31 <bollu> so where do I study abstract interpretation from?
09:53:50 <dysfun> it is far too abstract a concept to be embodied by anything as real as a book
09:54:06 <Lokathor> Uhm, uh, "If You Meet the Buddha on the Road, Kill Him."
09:54:14 <Lokathor> wait, no, wrong situation
09:54:38 <Lokathor> bollu, what do you mean exactly by "abstract interpretation"
09:54:53 <Lokathor> I'm assuming you mean something Haskell related and not like, art related
09:54:56 <bollu> Lokathor I mean, the actual field, abstract interpretation
09:55:07 <bollu> where you construct abstract domains for program properties you care about?
09:55:12 <Lokathor> i was not aware that such was a field of programming
09:55:16 <bollu> and then transfer facts to and from the program domain to the abstract domain
09:55:23 <bollu> it's not, it's a comp sci math thing.
09:55:24 <Lokathor> that sounds fancy
09:55:25 <bollu> :) 
09:55:29 <bollu> yes, it is!
09:55:34 <bollu> which is why I want to learn more about it
09:55:52 <Lokathor> I'm just a Java programmer who learned one day to push bits with Haskell instead :/
09:55:57 <Lokathor> I shirk the fancy stuff
09:56:07 <erisco> bollu, coincidentally I was just reading on that this morning
09:56:25 <bollu> erisco I see
09:56:31 <bollu> erisco any ideas on where to look for a primer?
09:56:48 <bollu> erisco I would like to believe I have the math pre-requisites
09:57:20 <erisco> no idea. I was just looking at what it was about
09:57:25 <bollu> ah, I see
09:58:15 <erisco> and it seems to be about conservatively approximating program behaviour with semantics
09:58:39 <cocreature> bollu: given that you’re working on polly, you should already know quite a bit about abstract interpretation no? :)
09:59:02 <nshepperd_> That sounds like denotational semantics
09:59:05 <erisco> which means it is going to be a medley of techniques and theories
09:59:07 <bollu> cocreature we don't formally use abstract interpretation. We don't really "abstract interpret"
09:59:18 <bollu> cocreature like, we just model LLVM stuffs as polyhedral stuffs :) 
09:59:22 <nshepperd_> Or is it related but different
09:59:25 <bollu> cocreature which is not the spirit, as I understand it
09:59:33 <cocreature> bollu: huh ok, I thought polly was basically using abstract interpretation over a polyhedral domain
09:59:39 <bollu> nshepperd_ from what I understand, denotational semantics is one choice of abstract interpretation
10:00:03 <bollu> cocreature eh, I believe you can look at that way, but we don't abstract it out by much :P The criteria for abstract interpretation is quite weak
10:00:18 <bollu> cocreature you need a galois connection, which I'm pretty sure we can establish in Polly
10:00:24 <bollu> cocreature in polly's case
10:00:30 <bollu> cocreature but I was interested in the tools and techniques
10:00:33 <erisco> nshepperd_, the difference is it may not be denotational and it is only approximate
10:00:38 <bollu> cocreature but then again, I don't really know
10:01:16 <erisco> nshepperd_, for example, if you wanted to know if programs halted then you could decide so (approximately) with abstract interpretation
10:01:59 <erisco> nshepperd_, so the meaning given to the program only has to be relevant to the purpose of termination and it needn't only give meaning to terminating programs
10:02:24 <bollu> cocreature do you have a recommendation for a book? :) 
10:02:33 <erisco> nshepperd_, i.e. if the program terminates the abstract interpretation will say it does, but if the abstract interpretation says it terminates it does not mean it does
10:02:39 <cocreature> bollu: nope sry
10:02:49 <bollu> cocreature aw, okay
10:04:19 <erisco> nshepperd_, i.e. the semantics can only claim "possibly"
10:06:31 <erisco> so it is a wide umbrella indeed
10:08:20 <cocreature> erisco: are there actually good approaches for deciding termination using abstract interpretation? I don’t think I’ve ever seen it used for that but that doesn’t mean much
10:08:44 <erisco> good by what measure?
10:09:01 <cocreature> s/good//
10:09:07 <cocreature> I’m fine with any approach :)
10:09:25 <erisco> I haven't studied any of the literature but it is not difficult to imagine approaches
10:09:37 <erisco> again, the abstract interpretation is approximate
10:09:43 <cocreature> I’m not sure what your abstract domain would look like in this case
10:09:58 <erisco> it is only necessary that if the program has behaviour X that the semantics also says the program has behaviour X
10:10:09 <cocreature> and you also can’t just widening after coming back to the same point a number of times
10:10:40 <cocreature> which is what most approaches for abstract interpretation do
10:10:45 <erisco> so the most trivial approach is to say all programs terminate ;)
10:11:01 <erisco> well, the judgment would be "all programs possibly terminate"
10:11:12 <cocreature> I think your definition of abstract definition might be a bit more loose than the one I have in mind
10:11:48 <erisco> we can make it more precise by ruling out programs which definitely do not terminate
10:12:21 <erisco> or, we can oppositely and talk about non-terminating programs by ruling out ones which definitely do terminate
10:12:29 <erisco> (probably the more practical idea)
10:29:28 * hackagebot Euterpea 2.0.4 – Library for computer music research and education – https://hackage.haskell.org/package/Euterpea
11:06:06 <mekeor> i'm `stack build`ing my project on an AARCH64-device (raspi3) using the stack binary for ARM-architecture. it seems to work so far; do i have to expect problems in future? – also `stack build` takes very long; can i cross-compile/-build the dependencies of my project on a x64-machine first and copy everything over afterwards?
11:19:18 <erisco> I am having a hard time understanding the hoopla about callcc
11:19:34 <erisco> it looks like f (callcc g) is merely g f
11:19:57 <hpc> :t \f g -> f (callcc g)
11:19:58 <lambdabot> error:
11:19:58 <lambdabot>     • Variable not in scope: callcc :: t -> t2
11:19:58 <lambdabot>     • Perhaps you meant ‘callCC’ (imported from Control.Monad.Cont)
11:20:02 <hpc> :t \f g -> f (callCC g)
11:20:04 <lambdabot> MonadCont m => (m a -> t) -> ((a -> m b) -> m a) -> t
11:20:57 <hpc> hmm
11:22:12 <hpc> ugh, just the setup to explaining callCC is difficult
11:22:39 <erisco> I am just talking abstractly
11:23:31 <erisco> what is a "current continuation"
11:23:41 <hpc> ah, that's easier to explain
11:24:02 <hpc> in a very general sense, a continuation is "what happens next"
11:24:11 <hpc> @undo do {x; y; z}
11:24:11 <lambdabot> x >> y >> z
11:24:37 <hpc> so in something like that, when you're looking at the line of x, the continuation of that is (y >> z)
11:24:48 <hpc> normally you can't really do anything interesting with that
11:24:55 <hpc> but what Cont gives you is access to that continuation
11:25:03 <Welkin> @undo do { do { do { a } } }
11:25:03 <lambdabot> a
11:25:05 <Welkin> :D
11:25:16 <hpc> in x, you have the value (\_ -> y >> z) as a name
11:25:28 <hpc> that you can manipulate
11:26:22 <hpc> you can decide that you shouldn't call the continuation at all, in which case you get some sort of early escape mechanism
11:26:30 <hpc> or you can do something fancier like call it twice, or N times
11:27:08 <hpc> you can get access to the continuation by pattern-matching on ContT
11:27:36 <hpc> or you can use callCC, which threads it in for you
11:27:51 <Welkin> what exactly is callcc?
11:27:53 <hpc> when you write callCC $ \k -> do {some more stuff}
11:27:57 <hpc> k is the current continuation
11:28:00 <Welkin> I thought it was a C FFI thing
11:28:50 <applepies> \quit
11:29:10 <hpc> http://lpaste.net/4415278581320515584
11:29:49 <hpc> actually, that's not quite right
11:30:15 <hpc> http://lpaste.net/4415278581320515584
11:31:18 <hpc> in practice, calling (k x) inside a callCC block means drop out of that block and have the result of callCC be x
11:31:42 <hpc> if you get to the end of the callCC block without calling that continuation, control flow proceeds as normal
11:32:11 <hpc> actually getting this understanding out of the callCC source code is not easy
11:32:52 <hpc> i suggest trying things out in ghci, and actively following callCC's source code by hand to see why it does particular things
11:33:49 <hpc> as for the reason callCC gets so much attention, it makes a good bar to measure your understanding of weird control flow by
11:34:22 <hpc> if you can reach the point where you understand callCC, you should be able to understand many other more interesting control flow structures
11:35:05 <hpc> erisco: hopefully some of that helps with your question?
11:36:28 <dolio> People should just skip to delimited continuations.
11:36:42 <dolio> They're better, and they're less weird.
11:37:31 <Welkin> so what is callCC and why would you use it?
11:40:14 <hpc> Welkin: it's a thing that does stuff, and you should use it because you need the stuff it does ;)
11:40:30 <dolio> You probably don't, though.
11:40:35 <hpc> yeah
11:41:16 <hpc> it's one of those things that's more useful to learn than to actually use
11:41:54 <hpc> it's like long division
11:42:25 <Eduard_Munteanu> Welkin, typical usage goes like    callCC $ \exit -> ... something ... exit retVal ... something ...
11:44:48 <Eduard_Munteanu> Like   callCC $ \break -> forM [1..10] $ \i -> when (i == 3) (break ())   is a for-loop-like construct which quits on the 3rd iteration
11:45:25 <Eduard_Munteanu> Er, forM_
11:52:21 <hpc> it's impossible to write clean callCC code on one line too
11:53:03 <Welkin> :t callCC
11:53:05 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
11:53:29 <erisco> hpc, I take that it only really matters in effectful computation, which would explain why we see it related to Monad in Haskell
11:53:48 <Welkin> :t runContT
11:53:49 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m a -> (a -> m r) -> m r
11:53:54 <platz> though other monads (e.g. Maybe) hav some early-exit flavors too
11:54:03 <dolio> It's not a 'pure' function.
11:55:01 <platz> although not as powerful.. but for normal uses seem to be good enough
11:55:05 <erisco> there is otherwise no sense to "do it twice" or "never do it"
11:55:30 <dolio> Trying to reason about a lazy language with continuations is very tricky, too.
11:55:33 <Welkin> is callCC not referentially transparent?
11:55:37 <hpc> it is
11:57:07 <hpc> @src callCC
11:57:08 <lambdabot> Source not found. stty: unknown mode: doofus
11:57:28 <Welkin>  @src is a lie anyway
11:59:39 <dolio> 'Do it {zero,two} times' can have meaning outside of effects, though.
11:59:55 <erisco> so I am staring at this example which reads  callcc (λk. k 5 + 2) + 10
11:59:55 <dolio> You can duplicate or remove portions of your program using control effects.
12:00:04 <erisco> what do you think that should reduce to?
12:00:33 <hpc> you'd have a lot of trouble writing that in haskell
12:00:48 <erisco> (callcc (λ k. ((k 5) + 2))) + 10   if you like more parens
12:00:59 <hpc> but in an impure language, i would expect it to evaluate to 5
12:01:06 <hpc> er, 10
12:01:07 <hpc> er, 15
12:01:07 <dolio> No.
12:01:09 <dolio> 15.
12:01:09 <hpc> argh
12:01:12 <Welkin> o.o
12:01:13 <dolio> :)
12:01:21 <platz> wouldn't you need k + 5 not k 5
12:01:21 <erisco> can you explain?
12:01:44 <erisco> I expect the current continuation to be (+10)
12:01:49 <erisco> so k = (+10)
12:01:52 <platz> ah ok yes
12:01:57 <hpc> > (+10) 5
12:01:59 <lambdabot>  15
12:02:07 <dolio> erisco: Assuming that is the 'whole program' k is something that aborts what's going on and calls (+10) on its argument.
12:02:07 <Eduard_Munteanu> Won't really work like that in Haskell, though.
12:02:08 <erisco> ((+10) 5) + 2 is 17
12:02:29 <hpc> erisco: this is why you would have trouble writing it that way
12:02:33 <hpc> a haskell translation would be
12:02:51 <dolio> erisco: k gets rid of the + 2.
12:02:57 <erisco> oh
12:03:02 <hpc> do {v' <- callCC (\k -> do {v <- k 5; return (v + 2)}); return v' + 10}
12:03:08 <erisco> well that explains a lot of the weirdness
12:03:11 <Eduard_Munteanu> The continuation extends all the way to the end of the program.
12:03:22 <hpc> in which case one of the ContT-y effects of k is that it doesnt reach that next line
12:03:22 <dolio> This is part of why delimited continuations are better.
12:03:39 <hpc> > runContT return (do {v' <- callCC (\k -> do {v <- k 5; return (v + 2)}); return v' + 10}) :: Identity Int
12:03:41 <lambdabot>  error:
12:03:41 <lambdabot>      • Couldn't match expected type ‘ContT Int Identity a1’
12:03:41 <lambdabot>                    with actual type ‘a0 -> m0 a0’
12:03:52 <hpc> > runCont id (do {v' <- callCC (\k -> do {v <- k 5; return (v + 2)}); return v' + 10})
12:03:55 <lambdabot>  error:
12:03:55 <lambdabot>      • Couldn't match type ‘a0 -> a0’ with ‘ContT r Identity a1’
12:03:55 <lambdabot>        Expected type: Cont r a1
12:03:55 <dolio> At least, some versions of them.
12:03:57 <hpc> hmm
12:04:00 <erisco> Eduard_Munteanu, I see, so there is tacitly a "end of program" with (i.e. afteR) (+10)
12:04:04 <hpc> :t runCont
12:04:05 <lambdabot> Cont r a -> (a -> r) -> r
12:04:14 <hpc> > runCont (do {v' <- callCC (\k -> do {v <- k 5; return (v + 2)}); return v' + 10}) id
12:04:16 <lambdabot>  error:
12:04:16 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M847242256859...
12:04:16 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:04:21 <hpc> >:(
12:04:45 <Tuplanolla> > runCont (do {v' <- callCC (\k -> do {v <- k 5; pure (v + 2)}); pure (v' + 10)}) id
12:04:47 <lambdabot>  15
12:04:50 <dolio> erisco: So, the weird thing about abortive continuations is not just that `call/cc` is not a function, the continuations you get aren't functions, either.
12:05:12 <hpc> > (runCont (do {v' <- callCC (\k -> do {v <- k 5; return (v + 2)}); return (v' + 10)}) id)
12:05:14 <lambdabot>  15
12:05:19 <hpc> parens around (v' + 10)
12:05:23 <hpc> erisco: ^
12:05:37 <erisco> it is all sorts of weird to me but this is enough for me to understand the example now, thanks
12:06:02 <dolio> Yeah, if you write it in monadic style, it's considerably clearer.
12:06:36 <dolio> And otherwise you have to decide implicitly how things turn into the more explicit style.
12:08:26 <erisco> just a guess but does this give a way to define coroutines?
12:08:43 <dolio> Yeah.
12:09:38 <dolio> It's not so complicated in the example `callcc (...) + 5`, but if you did `callcc (...) + callcc (...)`, then you really have to start thinking.
12:10:06 <dolio> Which one happens first? Because that might matter.
12:10:38 <hpc> where it gets confusing is when you're looking at (k 5 + 2), imo
12:10:39 <erisco> all of them ;) okay thanks
12:10:49 <hpc> because you would expect that +2 to happen
12:11:05 <hpc> it's a lot like exceptions when written in an impure style
12:11:08 <Welkin> can you accomplish the same thing without callCC?
12:11:13 <Welkin> what si the benefit of callCC?
12:11:13 <hpc> any given piece of code has invisible gotos to everywhere
12:11:20 <erisco> hpc, it is like return
12:11:40 <hpc> callCC lets you write things without having to pattern match on ContT
12:11:50 <erisco> λreturn. (return 5) + 2
12:12:05 <dolio> Yeah, except you can't usually write that.
12:12:13 <dolio> In the languages with that sort of 'return'.
12:12:33 <erisco> no, you can't, but this is the same sort of abortive behaviour if I an understanding it correctly
12:12:58 <dolio> Yeah.
12:13:11 <erisco> though dynamic I suppose
12:13:13 <dolio> But you have to be careful.
12:13:33 <dolio> Because you can do stuff like `k (wrap k)`.
12:13:40 <dolio> Where wrap somehow fixes up the types.
12:13:50 <dolio> Or if you're untyped, it doesn't matter.
12:13:57 <erisco> so if you wanted coroutines, then λreturn. (callc (return 5)) + 2
12:14:10 <dolio> And then k has escaped the local scope, but calling it aborts stuff and goes back to the callcc.
12:14:11 <erisco> return receives the continuation +2, or I would think so
12:15:38 <erisco> well, return 5 does
12:17:30 <dolio> It depends what you want your coroutines to look like.
12:17:35 <dolio> I guess.
12:18:00 <hpc> a naive form of coroutines would be two thingies that are aware of each other's continuations and can yield between them
12:19:04 <dolio> I feel like a lot of this stuff is easier to make sense of with delimited continuations, too.
12:19:16 <dolio> Because you don't have to worry about the continuations being effectful.
12:19:20 <Welkin> what are "delimited" continuations?
12:20:02 <dolio> The most common formulation (I thinkO is a pair of operators, shift and reset.
12:20:17 <dolio> reset 'delimits' a computation.
12:20:20 <hpc> delimited continuations can represent things other than "the entire rest of the program"
12:20:22 <erisco> callcc (λk. callcc (k 5) + 2) (λx.λf. f (x + 10))
12:20:27 <dolio> And shift is like callcc, but never escapes reset.
12:20:35 <erisco> 17
12:20:41 <dolio> And the k that it gives you is just a function.
12:20:54 <Welkin> erisco: why are you using non-haskell notation?
12:21:13 <dolio> So, for example: reset (shift (\k -> k 5 + 2) + 10)
12:21:17 <erisco> because it is useful to speak abstractly
12:21:18 <dolio> That is 17.
12:21:36 <dolio> reset (shift (\k -> k (k 5) + 2) + 10)
12:21:38 <dolio> That is 27.
12:22:43 <erisco> you need an example where I can't merely ignore shift and reset
12:22:55 <dolio> What about the second one?
12:23:15 <dolio> It added 10 twice.
12:23:31 <erisco> > (\k -> k (k 5) + 2) ((+) 10)
12:23:33 <lambdabot>  27
12:23:47 <merijn> hmmm, anyone here try gloss on OSX? It doesn't seem to register the states of ctrl and alt keys
12:24:23 <dolio> erisco: How did you perform that transformation by understanding shift/reset.
12:24:24 <erisco> the first thing I thought was why is  f (callcc g)  not just  g f
12:24:28 <dolio> Except by, even.
12:24:51 <erisco> I ignored reset and used that wrong interpretation of callcc for shift
12:26:05 <dolio> Okay, what's: 5 + reset (shift (\k -> k (k 5) + 2) + 10)?
12:26:27 <erisco> no idea
12:26:33 <dolio> Why?
12:27:17 <erisco> well I can say 32 based on my previous interpretation, but I know it is wrong :P
12:27:29 <dolio> No, that's correct.
12:27:36 <dolio> Why did you think it's wrong?
12:27:39 <hpc> reset delimits k
12:27:46 <hpc> meaning when you do it twice, it only is +10
12:27:50 <hpc> 5+ happens once
12:27:54 <erisco> it isn't complicated
12:28:08 <erisco> I said I do not know what shift and reset do. I am asking for an example where my incorrect interpretation does not work.
12:29:04 <dolio> Okay, what's: 5 + reset ((shift (\k -> k (k 5) + 2) + 10) + 5)?
12:31:39 <erisco> 42
12:31:58 <dolio> How did you get that from your interpretation?
12:32:03 <erisco> I didn't
12:32:07 <dolio> Oh.
12:32:32 <erisco> so reset/shift is much more like return because return is usually scoped to a function
12:32:52 <erisco> and break is scoped to a switch or loop, continue scoped to a loop
12:32:54 <dolio> Yeah, it's nicer for implementing return, at least.
12:32:58 <akamaus> Athas, In case you interested, haskell-platform 8.0.2 works like a charm.
12:33:04 <dolio> You can reset around a function and then return is a shift.
12:33:51 <erisco> as a structural rule you can do that, even
12:34:11 <dolio> Also you can do a sort of multi-return by bundling up k.
12:34:49 <Athas> akamaus: I'll keep that in mind if I see anyone else with that problem.  I just use stack myself.
12:35:28 <akamaus> Athas, I tried, but I needed some exotic packages like astar. Stack seem to have troubles with them.
12:36:35 <akamaus> usually I'm happy with cabal and nix, stack seems to be a bit redundant in such setup
12:36:48 <dolio> Also you can fool around with shift/reset very easily with ContT.
12:37:14 <dolio> reset m = runContT m return ; shift = ContT
12:37:39 <dolio> And the types show you where the control effects can happen.
12:44:21 <dolio> Or if you just use Cont it will go back and forth between direct style for pure stuff and monadic style for places where control effects can happen.
12:44:47 <dolio> @let reset m = runCont m id
12:44:48 <lambdabot>  Defined.
12:44:56 <dolio> @let shift e = Cont e
12:44:57 <lambdabot>  .L.hs:183:11: error:
12:44:57 <lambdabot>      • Data constructor not in scope: Cont :: t1 -> t
12:44:57 <lambdabot>      • Perhaps you meant one of these:
12:45:02 <erisco> I am not sure I should really care about it... it seems kind of insane
12:45:03 <dolio> :t Cont
12:45:04 <lambdabot> error:
12:45:04 <lambdabot>     • Data constructor not in scope: Cont
12:45:04 <lambdabot>     • Perhaps you meant one of these:
12:45:13 <dolio> Huh.
12:45:22 <dolio> @undefine
12:45:23 <lambdabot> Undefined.
12:45:46 <erisco> I just wanted to understand the example given in this tutorial on K (a rewriting framework for language semantics)
12:47:40 <mauke> :t cont
12:47:42 <lambdabot> ((a -> r) -> r) -> Cont r a
12:47:52 <dolio> Oh. Right.
12:54:07 * hackagebot recursion-schemes-ext 0.2.0.0 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
12:57:49 <trigone> hi! i'm looking for an up-to-date graph representing the hierarchy among the basic classes Num, Eq, Ord, Enum, Bound, etc. i found one here https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Standard_classes but after experimenting with ghci, it appears Num does not imply Eq, and somehow Enum is not required if you have Bounded, Num, and Eq... so i'm a bit lost
12:58:35 <trigone> oh nevermind wrt Enum, i made a mistake in my code
12:59:08 <mauke> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3
12:59:19 <mauke> oh, hmm
12:59:44 <trigone> i still don't get why ghci inferred (Eq a, Num a, Bounded a) => if all Num are automatically Eq... redundancy?
12:59:57 <mauke> they're not (anymore)
13:00:39 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#numbers-basic-types-and-built-in-classes
13:01:15 <trigone> mauke: ok! thx :)
13:01:57 <trigone> btw, the tokens representing say integers (0, 1, 2, 3 ...), are they overloadable somehow? how are they defined?
13:02:23 <trigone> :t 0
13:02:26 <lambdabot> Num t => t
13:02:42 <erisco> surprise
13:02:52 <mauke> a numeric literal 42 actually means (fromInteger 42_as_Integer)
13:02:59 <mauke> but there's no syntax for 42_as_Integer
13:03:11 <mauke> :t fromInteger
13:03:12 <lambdabot> Num a => Integer -> a
13:03:22 <trigone> mauke: ok...
13:03:51 <geekosaur> basically youy overload it by creatinga Num instance and defining its fromInteger appropriately. but you also have to define the other Num methods
13:03:55 <trigone> can't you write it along the lines of (fromInteger (42 :: Integer))?
13:04:16 <trigone> geekosaur: ok thx :)
13:04:18 <geekosaur> it acts like that, but as compiled that just adds an extra fromInteger
13:04:19 <mauke> that would be a recursive definition
13:04:39 <dolio> But that's effectively: fromInteger (fromInteger 42_as_integer :: Integer)
13:04:56 <trigone> mauke: hm yeah
13:05:27 <geekosaur> in ghc specifically, with the right options and imports it probably ends up as something like (fromInteger (S# 42# ))
13:05:46 <geekosaur> but there is no standard for that, just a specification of how numeric literals should behave
13:05:56 <trigone> mauke: even if fromInteger is defined as `id` for Integers?
13:06:21 <trigone> wait i'm not srue it makes sense...
13:06:29 <mauke> trigone: even if you say "42 actually means id 42", that still contains a 42
13:06:38 <mauke> which would be expanded to id 42, and so on
13:06:54 <trigone> mauke: oh right
13:07:20 <trigone> geekosaur: ok
13:07:31 <dolio> As far as the Haskell report goes, it could be fromNatural, except the report doesn't have Natural.
13:07:32 <mauke> heh, I suppose you could define it as fromInteger (read "42")
13:07:41 <dolio> And ghc has negative literals now.
13:07:50 <dolio> As an option.
13:08:08 <trigone> dolio: really... you mean, overloaded unary (-)?
13:08:20 <geekosaur> (where "42#" when MagicHash is in effect is an unboxed machine word with that numeric value, and S# is the hidden constructor for "short" Integers)
13:08:26 <dolio> Unary (-) was already overloaded.
13:08:34 <dolio> GHC also has negative literals.
13:08:48 <trigone> dolio: oh.. so what's the definition of negative literals?
13:08:52 <trigone> (by contrast i mean)
13:09:03 <mauke> previously: -42 means negate (fromInteger 42_as_Integer)
13:09:11 <mauke> now: -42 means fromInteger minus_42_as_Integer
13:09:13 <dolio> Where `- 42` is unary minus of 42, and `-42` is the negative 42 literal.
13:09:57 <trigone> ok... and in practice, the difference?
13:10:28 <trigone> it means you can have different values for (negate x) and (- x) or something?
13:10:42 <trigone> (for custom Num classes i mean)
13:10:44 <dolio> No, (- x) is (negate x).
13:11:03 <mauke> it means f -42 applies f to -42
13:11:06 <dolio> You could have different values for (- 42) and (-42) if you were into bad ideas.
13:11:28 <trigone> mauke: oh you mean you can write negatvie literals without parentheses?
13:11:42 <trigone> cool, it's a (relatively) good idea
13:11:42 <mauke> :t ?f -42
13:11:44 <lambdabot> (?f::a, Num a) => a
13:11:53 <mauke> yeah, not in lambdabot :-)
13:12:14 <dolio> I'm not sure it's a good idea.
13:13:01 <dolio> But it exists as an option.
13:13:20 <mauke> I like it
13:14:12 <trigone> dolio: does it have perf efficiencies? since you don't have to go through negate to get the value (in case it's a primitive type like Int)? though maybe the optimization was already done
13:14:26 <dolio> I don't care about its performance.
13:15:06 <dolio> I care that, since it exists with the other unary negation, it introduces a lot of complicated distinctions.
13:15:23 <dolio> If it were the only unary negation, I'd be more on board.
13:17:14 <dolio> Making the old sort of negation 'fast' for literals is not a hard problem, and I'm pretty sure GHC does it.
13:17:18 <erisco> what really was the point of it?
13:19:21 <trigone> btw, what's the major reason why we couldn't add methods to classes in other modules? provided they're strictly defined in terms of pre-existing methods (aka provided they have a default definition). it'd allow adding ad-hoc polymorphic functions when needed, but also allow specializing them if a more efficient version would exist...
13:19:45 <trigone> (in other modules than the original module into which the class was written)
13:19:49 <geekosaur> because other modules don't know to, or how to, pass the functions
13:20:00 <trigone> geekosaur: what do you mean
13:20:02 <geekosaur> remember that methods are not attached to data, they are records
13:20:05 <geekosaur> this is not OOP
13:20:14 <geekosaur> when you define foo :: Eq a => ...
13:20:42 <trigone> geekosaur: the record could be built once all the modules have been parsed, couldn't it?
13:20:43 <geekosaur> the first parameter is a record containing (==) :: a -> a -> Bool and (/=) :: a -> a -> Bool\
13:20:56 <geekosaur> trigone, sure, a year later
13:21:02 <geekosaur> separate compilation is a thing
13:21:02 <trigone> geekosaur: what?
13:21:12 <geekosaur> also you lose inlining potentially
13:21:35 <geekosaur> trigone, your class is defined in a library that you installed a year ago
13:21:51 <geekosaur> now retrofit your new method into that already compiled library
13:22:12 <trigone> geekosaur: oh! i thought everything was always re-compiled for each executable or something
13:22:14 <geekosaur> this is not python, this is not javascript, separate compilation to native code is a thing
13:22:23 <trigone> ok
13:22:58 <geekosaur> *some* things get exposed for cross-module inlining
13:23:13 <int-e> > (a + (-1), a + fromInteger (-1)) -- ghc's options are limited if class instances are not law-abiding
13:23:16 <lambdabot>  (a + negate 1,a + (-1))
13:23:16 <geekosaur> but that has its own problems because anything so exposed must NOT change
13:23:57 <geekosaur> or you end up with missmatched behavior depending on whether something inlined or not
13:24:57 * hackagebot shift 0.2.0.0 – A tool to quickly switch between directories – https://hackage.haskell.org/package/shift
13:27:09 <trigone> geekosaur: that's beyond my knowledge of compilation, esp of haskell compilation. but i get, mostly, why it's not possible... it's a shame, classes allow name overloading but you can't have a specialized version if it's not already in the class... it lacks that flexibility... and ironically you end up with methods in classes which are only there in the case there's a more efficient implementation, otherwise semantically it's just w
13:27:42 <geekosaur> other languages actually have similar issues. in C++ if you don;t declare a method as virtual then extra information needed for overloading is not generated
13:27:49 <trigone> (like Data.Foldable.sum)
13:28:21 <geekosaur> Java does the reverse, declare something as final and it can't be overloaded. this is in both cases to allow optimizations because it can call directly isntead of having to look up a method at runtime
13:29:44 <trigone> geekosaur: i don't know much of either languages...
13:30:17 <geekosaur> you don't really need to, you just need to understand that it is not uncommon for languages to do things like this
13:31:04 <trigone> geekosaur: yes i get what you mean, but it's not bc it's a generalized issue that i can't be sad about it. i don't attack haskell, i just say "i wish it'd be different", regardless of if it's possible at all, so to spea
13:31:06 <geekosaur> dynamic languages like python always have to do the lookup, so there's no extra cost to supporting this kind of arbitrary overloading
13:31:28 <geekosaur> you're lkooking for typeclasses to be OOP. that's not what they are for, and it causes other problems
13:32:22 <erisco> no free lunches
13:32:43 <geekosaur> ...note that OOP really does work like records (there's a reason C++ models classes as C "struct"s), so in a certain sense the problem here is really Haskell's existing record problem
13:32:55 <geekosaur> for which HList is about the only general solution, but yuck
13:33:13 <geekosaur> (lens-like accessors are *not*; they still can;t extend a record type arbitrarily)
13:33:38 <trigone> geekosaur: hypothetically, if we always recompiled everything, could we not allow arbitrary extension of classes? obviously there'd be a cost of compilation time, but in a way it's a problem which doesn't harm the finished product...
13:34:17 <geekosaur> to a point
13:34:52 <geekosaur> arbitrary addition of methods as long as existing functionality is not changed and is sufficient to support them. which is more limiting than you realize, I suspect
13:35:13 <geekosaur> also note that, despite terminology abuse, we do not have subclasses or superclasses
13:35:19 <trigone> geekosaur: no, that's exactly what i meant
13:35:22 <geekosaur> we  have *prerequisites*
13:36:08 <trigone> geekosaur: you know i have an extremely limited knowledge of OOP. i know most who come to haskell have "OOP intuition" but honestly haskell is the first language which actually feels comfortable and understandable
13:36:17 <trigone> (to me)
13:36:23 <dolio> Once contexts can go on things in negative position, it gets extra tricky.
13:37:06 <dolio> Because that is like a record in positive position.
13:37:19 <geekosaur> right, I've been carefully avoiding that particular rat hole...
13:37:20 <dolio> So you cannot tell how to produce such records locally.
13:37:26 <dolio> If they can be extended.
13:37:36 <trigone> what's negative/positive position?
13:37:51 <dolio> In `a -> b`, a is negative and b is positive.
13:38:10 <geekosaur> veyr roughly, "something you receive" vs. "something you create"
13:38:22 <geekosaur> (or "consume" instead of "receive")
13:38:31 <trigone> so, wrt contexts?
13:39:20 <geekosaur> how does code in some library installed a year ago, know to create a record that you extended in your program using that library?
13:39:34 <geekosaur> as opposed to the record definition it knew when it was compiled?
13:40:43 <geekosaur> in the typeclass context case, that translates to "knows to include your additional method definitions"
13:41:14 <trigone> geekosaur: i don't get half you say sorry :) i lack understanding of the compilation process
13:41:21 <trigone> of what you say*
13:41:45 <geekosaur> this feels very "convenient"
13:41:51 <trigone> eh?
13:42:23 <geekosaur> sigh
13:42:26 <trigone> (i thought we were talking, not arguing)
13:42:54 <geekosaur> I am trying to figure out how to reprase this so you will understand it, given you claim not to understand very much
13:42:59 <trigone> i don't argue you're wrong you know, i just say i don't get what you try to tell me
13:43:22 <trigone> geekosaur: no, don't bother, i'll understand it another day :)
13:43:24 <geekosaur> short verison without elaboration you claim not to understand: you can define a way to "ad dmehtids", you can;t ever *use* those methods
13:43:29 <geekosaur> eek
13:43:58 <geekosaur> short version without elaboration you claim not to understand: you can define a way to "add methods", you can;t ever *use* those methods
13:43:59 <trigone> oh... what happens if you try using them?
13:44:48 <geekosaur> because code in the library compiled a year ago must, in order to call its own functions, create a record containing methods you have defined in your code that didn't exist when it was built
13:45:25 <geekosaur> I *think* you were assuming som magical method where the library provides a basic method record that you think everything uses until yoru code a year later somehow replaces it
13:45:51 <geekosaur> and, like someone who doesn't undertsand the realities of compiling, you imagine this is trivial
13:46:39 <trigone> ok
13:47:07 <geekosaur> it's only trivial in dynamic languages because they do *all* lookups at runtime, so adding and carryng around extra information egnerated at runtime by completely new code isn't an issue, because it's *all* created at runtime
13:47:29 <geekosaur> here, if I define a new type instance record with new methods, it cannot replace the existing oen
13:47:39 <geekosaur> and the existing one has no way to point to the new one
13:47:45 <geekosaur> and existing code cannot know about the new record
13:47:53 <trigone> no need to take it personally, i wasn't saying "compiler writers are dumb, they should be able to do that". i just said "wouldn't it be great if..." --again, regardless of whether it's possible, since i indeed have no clue whether it is so or not! but you told me it was impossible or very problematic at compile time, so it's ok, i got it
13:48:05 <geekosaur> --> there is no way for already compiled code to find out that it needs to include functions that didn't exist when it was compiled
13:48:43 <geekosaur> I am not taking this personally (aside from my apparent inability to explain)
13:48:49 <trigone> geekosaur: yes, i didn't take that into account, because i didn't even know there was separate compilation
13:49:33 <geekosaur> it's actually a known thing related to XY problems and Dunning-Kruger. or https://xkcd.com/1425/
13:50:01 <geekosaur> and it's a *human* thing, no point being embarrassed by it, we're all just as culpable, just in different areas
13:50:30 <dolio> Here's another question: what's the point of adding methods to a class elsewhere, instead of defining a new class?
13:50:58 <trigone> dolio: well you don't have to write a new instances for every already existing instance
13:51:44 <trigone> dolio: since whatever function you add will have to have a default definition (it's a necessity)
13:51:44 <dolio> You can write a default, overlappable instance.
13:52:01 <trigone> overlappable?
13:52:55 <trigone> oh you mean an instance implying the original instance?
13:53:14 <trigone> like say instance Num a => MoreNum a where
13:57:34 <trigone> what's the syntax when you write an instance but there's nothing to write in it because every default definition is chosen?
13:57:54 <Tuplanolla> Leave out the `where`, trigone.
13:58:14 <mauke> or leave it in :-)
13:58:28 <trigone> leave it in?
13:58:49 <trigone> Tuplanolla: thx. do i need flexible instances to add constraints on instances?
13:59:01 <Tuplanolla> > let in here
13:59:03 <lambdabot>  ok
13:59:19 <monochrom> "instance Eq X where" is valid syntax, trigone. So is "instance Eq X".
13:59:30 <trigone> Tuplanolla: eh?
13:59:37 <trigone> :t here
13:59:38 <lambdabot> Doc
13:59:47 <Tuplanolla> It's the same idea, trigone.
13:59:51 <trigone> > her
13:59:52 <trigone> > here
13:59:53 <lambdabot>  error:
13:59:53 <lambdabot>      • Variable not in scope: her
13:59:53 <lambdabot>      • Perhaps you meant one of these:
13:59:55 <lambdabot>  ok
14:00:06 <monochrom> "Her" is a movie, though. :)
14:00:08 <trigone> there's a "Doc" value which representation is "ok"?
14:00:17 <Tuplanolla> You explicitly bind nothing there, trigone.
14:00:35 <Tuplanolla> > do here
14:00:36 <lambdabot>  ok
14:00:42 <trigone> Tuplanolla: oh
14:00:51 <Tuplanolla> You can also explicitly do nothing, trigone.
14:00:54 <trigone> so, to clarify, you mean i could write where here?
14:01:00 <monochrom> Yes.
14:01:03 <monochrom> Try it.
14:01:13 <trigone> ok. what's the meaning of the type Doc?
14:01:20 <Tuplanolla> Just pretty printing.
14:01:21 <monochrom> That's a distraction.
14:01:41 <monochrom> I have no idea why they brought up "here" or "Doc".
14:01:43 <monochrom> > let in ()
14:01:45 <lambdabot>  ()
14:01:51 <monochrom> would be more effective.
14:02:06 <monochrom> Actually, let's also try this:
14:02:10 <trigone> monochrom: but i can't write instance Bla x where (), can i?
14:02:15 <monochrom> > let {x = 1 where} in x
14:02:17 <lambdabot>  1
14:02:19 <monochrom> \∩/
14:02:20 <Hafydd> Not by the hair of my chinny chin chin!
14:02:32 <monochrom> <monochrom> "instance Eq X where" is valid syntax, trigone. So is "instance Eq X".
14:02:48 <mauke> trigone: instance Bla X where {}
14:03:29 <trigone> monochrom: yeah i had gotten that. i think i just realized all your blabla about here and () was to tell me that both where and let-in allowed zero bindings as acceptable syntax... that was it?
14:03:44 <monochrom> Yes.
14:03:56 <Tuplanolla> See, I used `here` since `()` looks like syntax.
14:04:01 <trigone> well that was convoluted :P
14:04:07 <monochrom> Well you could use "1" too.
14:04:11 <monochrom> > let in 1
14:04:12 <lambdabot>  1
14:05:15 <trigone> yeah i'd have understood that better with literals of non-weird types ^^ btw, to get back to my other question, to write instance C t => A t, do i need flexibleconstraints? 
14:05:39 <monochrom> Is "C" literally "C"?
14:05:56 <trigone> monochrom: no it's just a randonm class. is there a class that is called C?
14:06:11 <monochrom> No.
14:06:26 <monochrom> OK you don't need FleixbleConstraints.
14:06:44 <trigone> monochrom: what would "literally C" mean?
14:06:52 <monochrom> Actually I should ask is "t" literally "t" instead, because that's the real point.
14:07:19 <trigone> monochrom: you mean, both t the same?
14:07:34 <monochrom> FlexibleConstraints is when you have "instace C [t] => ..." for example.
14:07:45 <geekosaur> trigone, many instances designed for use with Generics do exactly that
14:07:50 <monochrom> At any rate it is best to show actual code not mock code.
14:07:52 <erisco> Who's on first? Who's on first.
14:07:58 <geekosaur> (intance Blah C where)
14:08:30 <monochrom> Dunning-Kruger implies that your mock code always preserves the non-essence and loses the essence.
14:09:18 <trigone> geekosaur: do what?
14:09:28 <trigone> monochrom: i'm attempting to do so, two secs
14:09:37 <geekosaur> [26 21:07:35] <geekosaur> (intance Blah C where)
14:09:45 <monochrom> geekosaur probably means a "where" without anything after.
14:10:01 <trigone> oh
14:10:14 <trigone> here :) http://lpaste.net/357994
14:10:18 <geekosaur> you don't even need the empty braces, although they help avoid unexpetced errors if you mis-indent afterward
14:11:13 <monochrom> Oh, that. But it's FlexibleInstances, not FlexibleConstraints.
14:11:18 <trigone> geekosaur: true
14:11:26 <trigone> monochrom: oh right sorry!
14:11:51 <trigone> (and i just understood it's bc the type is not concrete)
14:12:26 <trigone> is it a benign extension to use?
14:12:36 <monochrom> It is. Just not for this.
14:13:03 <trigone> why?
14:13:05 <geekosaur> the Haskell standard is extremely conservative about what instances are valid. the only real price of FlexibleInstances is compatibility with other Haskell compilers... of which there are few because that pigeon flew the coop years ago
14:13:27 <geekosaur> and de facto you need to implement every extension ghc does if you want to implement Haskell :/
14:13:47 <monochrom> "instance MoreEnum (Maybe Int)" needs FlexibleInstances and is OK or not OK depending what other code you have. But at least there is a scenerio in which it's OK.
14:14:01 <trigone> geekosaur: ok thx :)
14:14:11 <trigone> monochrom: so what should i do for my problem?
14:14:19 <monochrom> "instance ... => MoreEnum a" is simply going to be a headache, and it does not matter what you have in the "...".
14:15:19 <monochrom> What is your problem?
14:15:39 <monochrom> (Or was it stated in the past so I just have to read the scrollback?)
14:16:39 * hackagebot haskdogs 0.5.1 – Generate tags file for Haskell project and its nearest deps – https://hackage.haskell.org/package/haskdogs
14:18:25 <monochrom> I guess it is also OK under some scenerio.
14:18:27 <trigone> dolio: what did you mean earlier when you said "you can write a default, overlappable instance"?
14:20:38 <trigone> monochrom: the general problem is: how to add overloadable methods to a pre-existing class (virtually since it's impossible as such)? one idea is to write a new class, but then how to tell haskell "this new class has an instance for every instance of that old class"?
14:21:32 <monochrom> I wonder if Backpack answers that.
14:22:39 <trigone> in my paste, i'd like to be able to use MoreEnum instead of Enum, the former basically implying Enum ++ additional methods which all have a default definition, and therefore any instance of Enum can automatically be an instance of MoreEnum, but if one wants you can create specific implementations for specific types
14:22:51 <monochrom> "this new class has an instance for every instance of that old class" is inexpressible in Haskell, even after extensions.
14:23:06 <trigone> monochrom: oh
14:23:18 <monochrom> In particular "instance X a => Y a" does not express that either.
14:23:45 <monochrom> You really have to enumerate all instances by hand. (Pun!)
14:24:00 <trigone> monochrom: doesn't it if you have class X a => Y a ?
14:24:56 <trigone> any Y a is a X a, and the instance X a => Y a *seems* to mean you have an Y a for any X a...
14:25:06 <trigone> but maybe it doesn't compile i didn't check yet :P
14:25:51 <monochrom> "instance X a => Y a" means: Every type is an instance of Y. And now if any type is not an instance of X, it is an error, compiler aborts.
14:25:52 <trigone> it tells me: The constraint ‘Enum a’ is no smaller than the instance head       (Use UndecidableInstances to permit this)
14:26:15 <trigone> monochrom: oh?
14:27:22 <koz_> trigone: That will happen. You need a newtype wrapper.
14:27:32 <trigone> i guess undecidableinstances is one of those bad ideas i shouldn't touch..
14:27:39 <trigone> koz_: a wrapper for what?
14:27:56 <trigone> for any type?
14:28:01 <trigone> like identity?
14:28:03 <trigone> Identity
14:28:12 <koz_> trigone: If you wanna do 'instance X a => Y a', you'll get the constraint is no smaller than instnace head issue.
14:28:29 <koz_> You have to make a newtype wrapper for instances of X, and then define Y for them.
14:28:39 * koz_ ran into this very thing recently.
14:29:02 <koz_> s/them/that newtype wrapper/
14:29:14 <trigone> koz_: hm... so i have to write instance X (Identity a), then i write instance X (Identity a) => Y a, and somehow it works?
14:29:33 <koz_> trigone: I don't think you got me.
14:29:36 <koz_> Let me write you an example.
14:29:50 <koz_> (if my web browser behaves itself)
14:30:10 <koz_> trigone: I'll just PM you instead of spamming the chan - my browser seems to be having odd lpaste issues.
14:30:19 <trigone> koz_: ok!
14:30:25 <trigone> thx i appreciate
14:32:01 <monochrom> ptpb.pw lets you paste from the comfort of the command line and curl or wget. :)
14:32:46 <monochrom> You even receive a secret key that you can use for authorizing editing and deletion. :)
14:32:51 <koz_> monochrom: I use ix.io for this, but PMing trigone was easier.
14:33:00 <monochrom> True.
14:33:10 <monochrom> w00t let me check out ix.io too!
14:33:33 <monochrom> Haha this is truer to the Unix archaic spirit!
14:36:06 <monochrom> Hahaha "set number of reads allowed before deletion" this is new!
14:36:20 <monochrom> "This paste will self-destruct after you read it once."
14:37:37 <monochrom> Heh "nonymous" as the negation of "anonymous".
14:37:37 <koz_> monochrom: It is pretty minimal, I agree.
14:38:17 <monochrom> Oh, by "truer to the Unix archaic spirit" I just mean the man-page like monospace text man page.
14:38:30 <koz_> Ah, OK. Yeah, that too I guess. :P
14:39:20 <monochrom> The features are actually pretty interesting. Haven't thought of "delete after n times fetched".
14:39:43 <hpc> it's great until some jerk mashes f5 ;)
14:39:50 <monochrom> Spy movies are fond of that feature with n=1 but why stop at 1. :)
14:40:48 <trigone> koz_: did you get my last message?
14:41:05 <trigone> (in the PM channel)
14:42:08 <koz_> trigone: Seemingly no.
14:43:03 <trigone> koz_: well i wrote sorry i don't get the "instance (Class x) (Tycon x) where" syntax... EEnum only takes one argument...
14:44:22 <[exa]> monochrom: #!/bin/rm -f
14:44:29 <[exa]> on pastebin, c00lz
14:44:54 <koz_> And I believe I mention 'my syntax might not be perfect, it's meant to be a demonstration of the concept'.
14:45:03 <koz_> The idea should be plenty apparent.
14:45:15 <geekosaur> trigone, I think you'll need to register with nickserv, currently most accounts are set to reject non-auth /msg
14:45:43 <geekosaur> https://freenode.net/news/spamwave
14:45:43 <trigone> koz_: sure but i don't get at all what you mean, sorry... did you mean instance (EEnum (WrappedEnum a))?
14:46:53 <trigone> geekosaur: depends... koz_ had you received my "ok" message at some point? from my side, at any rate, i saw koz_ is away: Auto away --so maybe it's not bc i'm not registered (but it's probably a good idea either way)
14:48:51 <koz_> trigone: Yes, sorry.
14:49:03 <koz_> This is what happens when I try to answer in a hurry, when sick.
14:49:13 <trigone> geekosaur: i can't find where to register...
14:49:51 <geekosaur> https://freenode.net/kb/answer/registration
14:49:58 <geekosaur> also: /msg nickserv help
14:50:08 <trigone> koz_: no problem :) at any rate, i still don't get how i can write that instance since there's no constraint on the type which could be wrapped into WrappedEnum...
14:50:19 <trigone> geekosaur: ok thx :)
14:51:19 <koz_> trigone: Give an Enum constraint to a then.
14:52:36 <trigone> hm... i see the idea... except, i'll have to constantly wrap if i want to use the methods...
14:53:57 <trigone> since the original need came from having the opportunity to write better implementations than the most polymorphic one (without having to use another name for the function)... i don't think wrapping and unwrapping, esp with a constraint, will make things better on that side :) but it's still a good trick...
14:54:15 <trigone> *seeking the opportunity
14:57:53 <trigone> thing is i don't know why Class1 a => Class2 (SimpleWrapper a) works but not Class1 a => Class2 a.... i mean obviously it doesn't work, but i don't know why...
14:58:18 <trigone> (wrt instances)
14:59:58 <monochrom> There are two reasons combined. I gave one reason.
15:00:36 <tabemann> I'm trying to find the functions for gi-cairo but the docs of gi-cairo contain almost nothing, and the actual package for gi-cairo basically contains a Setup.hs and nothing else
15:02:03 <geekosaur> you need to look at the upstream docs; the gi packages are autogenerated wrappers
15:03:18 <n_blownapart> hi this is a book example a member was helping me with earlier. they wrote out a book problem in lambda dot notation. my question is, at the bottom of the paste, which part of the lambda/dot notation signifies that y is "shadowed".? is that just another way to say it is unbound to z ? thanks     https://ptpb.pw/Qlzw
15:03:24 <tabemann> you mean that I should go off of the Cairo docs and mentally converting those into Haskell?
15:03:37 <n_blownapart> *the problem
15:04:37 <crucify_me> aka n_blownapart
15:04:56 <monochrom> I think yes, tabemann. A long time ago, I also had to read the original gtk+ docs a little bit.
15:05:23 <trigone> maybe, let's make things simpler: in this paste, do i have any other choice than write two functions with two different names? http://lpaste.net/357995
15:10:49 <crucify_me> rats, hoping to get a reply, thanks
15:12:00 <monochrom> crucify_me: I think the better angle is this: Somewhere we say "we use lexical scoping", which means whenever you see a usage of "y", you look for the lexically nearest binding site that binds "y".
15:12:41 <geekosaur> crucify_me, "shadowing" means there is a more recent binding
15:13:10 <geekosaur> in this case: defining z (let z y =) creates a new lexical binding "y" unrelated to your earlier one, which is in scope only to the right of the "="
15:13:20 <monochrom> Aw, not chronologically recent!
15:13:42 <geekosaur> it is back out of scope on the next line, and your original "y" is in scope. *at the prompt*. the definition of "z" continues to use *its* unrelated binding
15:14:11 <crucify_me> thanks both of you, so in the formal notation can you look at it and see that is what is happening?
15:14:28 <monochrom> Depends on what you mean.
15:14:54 <monochrom> "Yes" because we know we are supposed to read this formal notation with lexical scoping in mind.
15:14:57 <crucify_me> because y is switch hitting 
15:15:02 <geekosaur> z = (\my_new_y = my_new_y * 10)
15:15:09 <monochrom> "No" because someone has to tell you "we use lexical scoping".
15:15:15 <geekosaur> z makes no reference whatsoever to your 'y = x + 5'
15:15:32 <geekosaur> it uses *its* y, bound by the lambda
15:15:36 <monochrom> This is why I will evade every question of the form "can you tell from this notation?"
15:15:38 <vx> is there a servant add-on package that implements some commonly-used content types?
15:15:44 <crucify_me> right ok this is key
15:15:56 <vx> like i feel like text/html;charset=utf-8 must be a pretty common case
15:16:18 <vx> to be defining a content type from scratch
15:17:09 <erisco> crucify_me, fooling around on me, are you? ;)
15:17:16 <geekosaur> "shadowing" is when "z" defines its own "y" binding, completely hiding (shadowing) the original one within the definition of "z"
15:17:49 <crucify_me> erisco: no I gave you the implied credit !
15:18:00 <crucify_me> didn't want to ping you
15:18:03 <erisco> implied credit, lol
15:18:44 <crucify_me> erisco et al.   this has been very helpful 
15:19:24 <crucify_me> got that geekosaur thanks!
15:19:52 <erisco> keep your variables clean
15:20:02 <crucify_me> ?
15:20:20 <erisco> your text hasn't mentioned "variable hygiene"?
15:20:31 <crucify_me> not yet
15:20:47 <crucify_me> just dropped lexical scope.. I've heard of it
15:20:57 <crucify_me> dropped == introduced
15:21:53 <erisco> I'll introduce myself, then
15:22:17 <tabemann> back
15:22:22 <tabemann> I just figured out my problem
15:22:35 <tabemann> there is no real introspection data for Cairo
15:22:52 <tabemann> so practically no gi-cairo code gets generated
15:22:54 <erisco> crucify_me, that has to do with substitution
15:23:32 <tabemann> the solution is a hack to bridge between the old cairo package and the gi-gtk package
15:23:39 <crucify_me> I've done a lot of substitution in scheme, but I am trying to learn the formal notation only now erisco
15:23:54 <crucify_me> plus substitution looks way different here
15:23:54 <erisco> does scheme have a grammar?
15:24:08 <tabemann> am I just going to have to resort to gdkpixbuf?
15:24:48 <monochrom> I don't know whether scheme has a grammar, but I know that the question "input: string; question: is that a legal scheme program?" is decidable.
15:25:09 <crucify_me> I taught myself to write out linear and tail recursion step by step, with full expansion and contraction. but all that in the ether with haskell it seems erisco
15:25:19 <crucify_me> is*
15:26:17 <crucify_me> monochrom: that is above me
15:26:46 <erisco> 'cause she's so high, high above me ...
15:27:46 * hackagebot state-codes 0.1.2 – ISO 3166-2:US state codes and i18n names – https://hackage.haskell.org/package/state-codes
15:28:09 <erisco> crucify_me, I was just saying that scheme syntax should have a formal definition
15:28:33 <crucify_me> great song
15:29:37 <crucify_me> I could drop haskell for now and take a famous computer course at calBerkeley : SICP in python.
15:30:08 <crucify_me> I suck at programming , scheme seems like a lifetime in the past
15:30:29 <crucify_me> I think I have dyslexia
15:46:43 <crucify_me> yeah ok the crux of it is here: ' (\y -> let z y = y * 10 in z y) 
15:47:02 <crucify_me> * in z y *
15:48:36 <crucify_me> bingo I can see ti
15:48:37 <crucify_me> it
15:57:03 <jared-w> why no SICP in scheme? #bringBackScheme #schemeDidNothingWrong
15:58:28 <Eduard_Munteanu> #allLispsAreBad
15:59:22 <suzu> sicp isn't in scheme anymore?
15:59:28 <tabemann> I'm so fucking frustrated with GTK3 under Haskell
15:59:47 <Eduard_Munteanu> tabemann, how so?
16:00:16 <tabemann> I can't use gtk3, because the developers conspired to make it impossible to get a DrawWindow for an object and made it so the new "draw" event was useless
16:00:48 <tabemann> and I can't use gi-cairo because of gobject-introspection issues that made it so that practically nothing is automatically generated for Cairo
16:00:52 <Eduard_Munteanu> tabemann, are you going through gtk2hs or the gtk-gi?
16:01:00 <tabemann> I've been trying both
16:01:08 <Eduard_Munteanu> I hear GI is the way to go now.
16:01:19 <tabemann> I'm trying GI, and it's useless
16:01:30 <crucify_me> suzu nope mit and berkeley changed it like 5 years ago but 3 weeks at berkeley are taught in scheme each semester
16:01:48 <tabemann> so useless that I might just use the hack that allows using Graphics.UI.Cairo (?) from within gi-gtk
16:06:09 <suzu> oh what is it in now?
16:06:13 <suzu> is it Haskell? :)
16:10:25 <hamishmack> tabemann: Here is an example of how to use cairo with haskell-gi https://github.com/haskell-gi/gi-gtk-examples/blob/master/carsim/CarSim.hs#L262
16:10:36 <crucify_me> 12 weeks python, 3 weeks scheme for cs61a. taught this semester by old and new generation profs. hilfinger and denero. they are like rock stars around here suzu
16:17:05 <tabemann> hamishmack, thanks
16:17:08 <tabemann> I've gotta go though
16:18:47 <suzu> sicp in.. python?
16:18:51 <suzu> well, okay.
16:19:04 <erisco> for the excellent scoping rules
16:19:06 <suzu> personally: i used to think python was the bomb-diggity. until i found haskell
16:19:13 <suzu> now i dont know how i ever liked it
16:19:38 <crucify_me> suzu really ? please teach me haskell 
16:20:01 <suzu> i wonder if i'll think the same of haskell in 5 years after i come across ultim-haskell
16:20:10 <erisco> suzu charges $100 for the first hour and $30/hr thereafter
16:20:59 <suzu> crucify_me: how much haskell experience do you have?
16:21:21 <crucify_me> one second my new best friend...
16:21:26 <jared-w> He's on like chapter 5 or something of the haskell from first principles book
16:21:26 <erisco> Haskell will either be surpassed or unrecognisably evolved, that's inevitable
16:21:34 <suzu> oh
16:21:38 <suzu> well you're doing just fine then
16:21:46 <crucify_me> hell no, chapter 7 I beg your pardon :)
16:21:54 <erisco> there is only so much patch work you can do to keep up to new knowledge
16:22:32 <jared-w> erisco: I think the next /clearly superior/ language is going to be one that solves the pain points of dealing with very deep and fine-grained hierarchies as well as the pain points of dealing with multiple possible representations of something (especially with extremely expressive types)
16:23:19 <suzu> certainly Haskell will be surpassed someday
16:23:33 <suzu> just as it was well known that C/C++ would be surpassed someday for its purpose
16:23:43 <c_wraith> jared-w: but no one will notice it and everyone will flock to the next language that introduces no new ideas but has a big corporate backing.
16:23:45 <suzu> but it is only now that alternative bare-metal languages, such as rust, are picking up popularity
16:24:18 <jared-w> I don't think there /are/ any other alternative bare-metal languages other than Rust that anyone gives a shit about... /maybe/ D? sorta-kinda?
16:24:26 <suzu> 1978. to 2010
16:24:31 <erisco> D? no.
16:24:44 <suzu> 30 years right there
16:25:11 <suzu> but also it should be noted that programming itself only really took off in 1990
16:25:23 <dolio> Was D really better than C++?
16:25:26 <jared-w> c_wraith: I can't wait for the next corporate crappy language to be as great as Haskell is now. I mean, even if future languages are 20-30x better than Haskell now, it'll still be something...
16:25:28 <suzu> and the landscape changes every 3-5 years, especially because of hardware improvements
16:25:39 <dolio> I guess maybe at the time, but it probably isn't better than current C++.
16:25:55 <jared-w> dolio: D did a lot of cool stuff. It just never caught on and most of its improvements arguably sorta got rolled into C++
16:26:35 <suzu> c_wraith: i think there's examples both in favour and against
16:26:36 <erisco> just my two cents, but D would have only been a good language if it was invented earlier to compete with C++
16:26:45 <suzu> Go has adoption but is objectively a shit language, i'd say
16:27:04 <suzu> Erlang and OCaml have money in them but not as much penetration
16:27:06 <erisco> years after C++ has already proliferated D comes along and just does the same thing marginally better
16:27:15 <erisco> well, people don't go for marginal
16:27:18 <raynold> ahh it's a wonderful day
16:27:26 <cjay-> jared-w: there is still a big fortran community for physics code
16:27:34 <cjay-> Go is not bare metal either
16:27:44 <cjay-> Go and D have mandatory GC afaik
16:27:52 <jared-w> cjay-: that's cause fortran is friggin nuts with its tight loop optimization of certain types of numerical code :)
16:27:56 <suzu> i'm talking about corporate backing as compared to popularity
16:28:03 <jared-w> Also D has an optional GC; you can turn it off/on iirc
16:28:04 <suzu> not bare-metal programming
16:28:23 <jared-w> Right, which is why I said "sorta-kinda" :)
16:28:51 <erisco> mm, but that also caused a fractured library database jared-w
16:29:11 <suzu> there's a good talk by Philip Wadler (the guy who got IO into Haskell via Monads)
16:29:17 <suzu> where he talks about 'invented' and 'discovered' languages
16:29:20 <jared-w> But yeah, corporate backing? I don't see any of that happening for a few years. I wouldn't be surprised if F# or Scala became the corporate-backed FP language that others surpassed
16:29:31 <suzu> invented languages are people at corps pulling stuff out of their ass to solve X task better
16:30:00 <suzu> whereas 'discovered' languages are usually "found" by both a logician and a computer scientist simultaneously, and go backwards to ML and lambda calculus
16:30:29 <suzu> for instance, Lisp and Haskell are "discovered" languages
16:30:31 <jared-w> erisco: what caused a fractured database?
16:30:38 <suzu> whereas Go and Python are "invented"
16:30:42 <erisco> jared-w, optional GC
16:30:43 <Cale> Uhhh
16:30:48 <jared-w> erisco: oooh right, gotcha
16:30:51 <Cale> Haskell was devised by a committee
16:31:05 <suzu> after looking at a lot of ML-children, yes
16:31:15 <jared-w> True, but Haskell was "let's standardize our research on lazy and pure FP languages and see what magic happens"
16:31:27 <crucify_me> so wait, what language should I study?  
16:31:30 <jared-w> Go was "we need a language that is like C but sucks in a different way"
16:31:39 <suzu> crucify_me: that depends on what you want to do
16:31:40 <erisco> crucify_me, all
16:31:55 <suzu> and it should be languageS, not language, if you want to be a well-versed programmer i'd say
16:32:28 <Cale> Haskell was basically designed as an open source clone of Miranda(tm) (Miranda(tm) is a trademark of Research Software Ltd.)
16:32:33 <erisco> crucify_me, some will be easy. For example, go to php.net and look for the formal semantics. Heck, look for any semantics. Then conclude "this garbage isn't even wrong" and research another language :P
16:33:07 <suzu> most imperative languages are mostly isomorphic to each other in a lot of ways
16:33:16 <suzu> when you cross the border to FP-land is where everything changes
16:33:28 <suzu> remember to have your passport!
16:33:55 <monochrom> Why do I need a passport? There is no border guard...
16:34:19 <dolio> Was lambda calculus discovered? Or was it invented by Church to have a nicer syntax for SK combinators?
16:34:36 <dolio> Sounds like a hack. :)
16:34:51 <suzu> ok ok the abstraction leaks a bit
16:34:57 <suzu> yeah it was introduced by Church solely
16:35:13 <suzu> he also made the typed one too
16:35:30 <dolio> But Church was a logician and a computer scientist.
16:35:32 <dolio> Sort of.
16:35:45 <dolio> So does he count as both?
16:35:54 <suzu> wikipedia says yes
16:36:01 <suzu> Alonzo Church (June 14, 1903 – August 11, 1995) was an American mathematician and logician who made major contributions to mathematical logic and the foundations of theoretical computer science.
16:36:15 <suzu> he also teamed up with Alan Turing to slay some other hard problems
16:36:21 <suzu> he was a real gangster back in the day yo
16:36:38 <suzu> chug a whole bottle of hennesy and then drop some sick proofs
16:36:44 <suzu> up in the club
16:36:46 <erisco> to invent is to discover! we just distinguish the agency of the people involved
16:36:50 <monochrom> Church supervised Turing, so I would include Church as a computer scientist, posthumously.
16:37:27 <dolio> The earliest lambda calculus stuff is logic, though.
16:37:36 <suzu> CS didn't exist until later though
16:37:38 <dolio> But the computer science stuff isn't far after.
16:37:39 <suzu> so thats ok
16:38:23 <dolio> I think one or two years after the logic stuff, he published a paper about an unsolveable problem using lambda-definable functions.
16:38:52 <dolio> And the latter is what Turing ran with.
16:38:54 <carter> There's some interesting industrial fp stuff In the works. ;)
16:44:58 * hackagebot shift 0.2.0.1 – A tool to quickly switch between directories – https://hackage.haskell.org/package/shift
16:45:07 <erisco> I think we just have an ontological disagreement about ideas and their content.
16:45:39 <erisco> if an island pops into your view you're a discoverer, but if an idea pops into your head you're an inventor
16:47:12 <monochrom> No, I think it's simpler than that.
16:48:52 <monochrom> Mathematically inclined people like to say "I discovered" because they have a Platonic ideal. Corporately inclined people like to say "I invented" because they have a profit imperative.
16:50:01 <suzu> i think you're both right
16:50:05 <dolio> Platonism is silly, though.
16:50:21 <jnj> Hi, assume I have several stack projects depending on package X. Will this package be downloaded into each project's directory or is stack storing one copy in a global directory?
16:53:02 <jnj> (And is an external-deb on github treated the same way?)
16:53:36 <erisco> I say the mathematician created the idea but not the content of the idea, but what do I know ;)
16:54:03 <monochrom> Is there a distinction between an idea and the content of the idea?
16:54:20 <johnw> you can devise a structure, but not imagine all the ways it might be applied
16:54:55 <monochrom> Sure, I'm OK with the wording "all implications", but not with the wording "content".
16:55:02 <johnw> agreed
16:56:26 <sm> jnj: if it's from stackage, it'll be stored once under ~/.stack. Not sure about the other but I'd guess the same
16:59:07 <erisco> an idea is like a painting
17:02:12 * hackagebot feed 1.0.0.0 – Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds. – https://hackage.haskell.org/package/feed
17:04:36 <monochrom> Therefore "idea" = "content of the idea" because "content management system" refers to managing blog articles, and "we cannot serve you the following content in your country" refers to motion pictures and paintings. >:D
17:06:13 <monochrom> In particular, a CMS cannot possibly manage the consequences of a blog article, such as whether or not you will go out riot on the streets after you have read it.
17:08:45 <erisco> you think that, but now that news articles can be written by AI who knows what they'll get up to
17:10:13 <erisco> they'll be programmed to optimise clicks, which means terrible headlines, which means inciting terrible things
17:12:03 <monochrom> Time to invoke http://www.vex.net/~trebla/humour/tautologies.html #1 >:D
17:13:32 <monochrom> Oh damn I have "tautologies of blank content" right there which contradicts what I just said here. Retract! Retract!
17:14:17 <erisco> distract with this sharp comic http://cowbirdsinlove.com/43
17:15:23 * hackagebot numhask-range 0.1.1 – Numbers that are range representations – https://hackage.haskell.org/package/numhask-range
17:15:37 <monochrom> Oh I have a picture for #1 I took a while ago too.
17:15:45 * monochrom uploads more content!
17:19:41 <boj> you know it's time to take a break when you blow 15 minutes trying to figure out why the compiler isn't seeing your data type... only to realize you started explicitly exporting stuff the night before. sigh
17:20:28 * boj is such a noob
17:20:52 <erisco> with how my client broke the lines, my interpretation was "when you blow 0.15"
17:28:20 <suzu> i want to write some kind of project in haskell
17:28:32 <suzu> but i'm also feeling reeeall lazy
17:35:25 <markasoftware> so, does #haskell like Elm or treat it as shitty GHCjs?
17:35:45 <Hafydd> suzu: if you're feeling lazy, you should only write the program when it needs to be run.
17:35:52 <suzu> #haskell is made of more than a thousand people
17:35:58 <suzu> but personally i dislike Elm
17:36:00 <Hafydd> Or only run the parts that need to be executed at first.
17:36:05 <Hafydd> *only write
17:36:06 <systemfault> Elm is awful.
17:36:37 <systemfault> I became so sick of writing coder/decoders for everything.
17:36:59 <boj> i think people that come to Elm with no Haskell experience can appreciate it. going the other way is kind of terrible
17:37:40 <markasoftware> would you rather use js with some sort of framework or elm
17:37:43 <erisco> does #haskell have a consensus? a survey? polls?
17:37:47 <dmj`> markasoftware: Elm is ok, but you can’t share types, don’t have higher-kinded type polymorphism
17:38:26 <erisco> an elected group of official representatives?
17:38:46 <erisco> I guess rather appointed moderators ;)
17:39:30 <dmj`> markasoftware: miso tries to combine the best parts of Elm and Haskell
17:39:34 <dmj`> @package miso
17:39:34 <lambdabot> http://hackage.haskell.org/package/miso
17:40:45 <dmj`> you can use GHC.Generics to make json decoders for stuff
17:40:57 <dmj`> </sales pitch>
17:41:07 <schoppenhauer> hi. is there a haskell-binding for aalib?
17:43:27 <markasoftware> i heard GHCjs had pretty poor performance
17:44:34 <dmj`> markasoftware: you can write your own js and FFI into the parts where performance is critical
17:45:45 <dmj`> markasoftware: Also, at the end of the day, it comes down to user perception. 
17:45:46 <systemfault> Purescript seems to be the closest thing to Haskell that isn't painful to use.
17:45:55 <systemfault> But I haven't tried it... yet.
17:46:09 <markasoftware> what exactly is bad about Elm, i haven't gone much beyond the basic tutorials yet
17:46:21 <markasoftware> just less powerful type system?
17:46:27 <jared-w> markasoftware: Elm is basically "Haskell with all the 'complicated bits' removed"
17:47:03 <jared-w> (Turns out the complicated bits are not actually that complicated and are just really powerful tools)
17:47:10 <dmj`> w/ Elm and purescript you can’t really share types w/ the backend
17:47:27 <jared-w> (assuming you write the backend in Haskell, of course)
17:47:33 <markasoftware> with php backends people did just fine not sharing front/backend stuff
17:47:35 <systemfault> The FFI is annoying, no typeclasses, writing coders/decoders is painful (boilerplate...) were my main pain points with Elm.
17:48:11 <suzu> dmj`, are you dmjio?
17:48:21 <dmj`> suzu: yea
17:48:35 <suzu> oh man i've used a lot of your things
17:48:41 <suzu> :D
17:48:53 <suzu> what made you build miso?
17:48:57 <suzu> was reflex not good enough?
17:50:15 <dmj`> suzu: :D
17:52:53 <suzu> dmj`: ^
17:52:56 <jared-w> But seriously, the no typeclasses alone would make me quit a FP language so fast...
17:53:26 * jared-w wants to just fmap a Foldable and not worry about life
17:53:29 <erisco> and you'd go to what?
17:53:37 <suzu> back to haskell
17:54:07 <erisco> there is the technique where you explicitly pass around the dictionary
17:54:08 <jared-w> Or a language with a strong enough generic support, like (S)ML (which has its functors through its module system that can do most of the stuff you use typeclasses for)
17:54:43 <markasoftware> typeclasses are to elm as generics are to go?
17:55:04 <erisco> and the one instance per type has weakness
17:56:17 <dmj`> suzu: Always liked Elm, but didn’t want to use two languages. Regarding reflex-dom, it’s hard to compare the two, they’re just very different.
17:57:22 <u-ou-> I need to learn R for school, heh
17:57:32 <jared-w> erisco: it does, sure. I still haven't really found anything as powerful as Haskell's typeclasses in a non FP language, though
17:58:24 <markasoftware> well apparently elm has exactly three built in, non-modifiable typeclasses
17:58:50 <markasoftware> comparable appendable and number
17:58:59 <erisco> afaik Rust has type classes, which it calls traits, though I do not know if they are as good as GHC's with all the extensions
17:59:27 <erisco> obviously you are missing higher kinded type quantification but that is a separate issue
17:59:43 <erisco> though I don't know*
17:59:49 <jared-w> Oh right, Rust's traits. Yes I love Rust traits :) I also don't think they're quite as powerful, although they're getting closer to Haskell's level of power. I think there might even be a RFC for HKTs?
18:01:19 <erisco> and you can cobble together something in C++ to be like type classes, I think, which is also called traits
18:04:33 <erisco> and PHP has traits, though I stopped following that language about 7 years ago so I can't tell you what those are
18:05:48 <erisco> hm, look like mixins, so unrelated
18:06:13 <markasoftware> eh, JS works fine without typeclasses, who needs em :)
18:06:16 <sm> php might end up with haskell's features yet, I tell ya
18:07:10 <erisco> I started using the functional definitions PHP began providing and was laughed at for making unreadable code
18:07:42 <erisco> unreadable, unmaintainable, and some other un-ables according to one commenter
18:08:15 <erisco> oh, and "too many functions" said another person
18:09:16 <geekosaur> you can lead a brogrammer to knowledge...
18:10:25 <sm> ha. I have free rein, nobody cares what I do in PHP
18:10:49 <erisco> what happens in PHP stays in PHP
18:10:58 <sm> as long as it shows the right stuff on screen
18:55:54 <erisco> someone give me a pointed expression to make pointfree
18:56:06 <erisco> actually why is this not a video game
18:58:10 <koz_> erisco: Are you trying to become the new @pl?
18:58:22 <erisco> no, because it has no style
19:05:13 <erisco> okay, fine, I come up with \a b c -> a b (b c)
19:06:36 <c_wraith> that's almost, but completely not, <*>
19:06:56 <erisco> mhm :)
19:13:46 <erisco> :t \a b c -> a b (b c)
19:13:48 <lambdabot> ((t2 -> t1) -> t1 -> t) -> (t2 -> t1) -> t2 -> t
19:13:53 <erisco> :t flip (liftA2 (.)) id
19:13:54 <lambdabot> ((a -> b) -> b -> c) -> (a -> b) -> a -> c
19:14:04 <erisco> @pl \a b c -> a b (b c)
19:14:05 <lambdabot> ((.) =<<)
19:14:20 <sleblanc> gah, I have not been able to build my xmonad configuration for a while and I cannot figure out the problem. when I try xmonad --recompile, compilation aborts with message "gcc: error: unrecognized command line option '-no-pie'". the only hint I was able to find online is this https://bugs.archlinux.org/task/54561
19:14:39 <cobreadmonster> Hello.
19:14:46 <sleblanc> although it did not solve my problem
19:14:46 <cobreadmonster> I finally got a new laptop!
19:14:59 <cobreadmonster> I'm trying to figure out what the best way to install ghc on Fedora 26 is.
19:15:10 <cobreadmonster> Should I use dnf or stack?
19:15:21 <geekosaur> sleblanc, that's not related, no
19:15:46 <sleblanc> I am running Debian 8 (Jessie) and using The Glorious Glasgow Haskell Compilation System, version 8.0.1
19:16:35 <geekosaur> https://www.haskell.org/platform/#linux-generic
19:17:02 <geekosaur> the page is stupid so you have to click the "Generic" icon to get actual information... then see item #3
19:17:22 <geekosaur> if you didn;t install via the Platform then you will need to find the settings file and change it yourself
19:18:37 <erisco> :t (=<<) fmap -- an interesting definition
19:18:38 <lambdabot> Functor f => (f a -> a -> b) -> f a -> f b
19:19:23 <sleblanc> geekosaur, holy moly, was this an obscure fix
19:20:34 <geekosaur> yeh you actually need the opposite, tell it to not try to -no-pie
19:20:55 <geekosaur> I guess arch decided they'd broken things enough already >.>
19:20:58 <sleblanc> geekosaur, why would my distribution ship with a broken configuration file?
19:21:16 <geekosaur> I have no idea
19:21:51 <geekosaur> possibly someone backported the ubuntu one (which does need that) without changing it back?
19:23:05 <geekosaur> also whether you need it or not depends on what version of gcc you have installed
19:23:40 <geekosaur> and you may, for unrelated reasons, have a different gcc
19:23:57 <sleblanc> it seems like the version I am running (4.9.2) supports -fno-pie instead of -no-pie
19:24:18 <sleblanc> to me, it sounds like "-no-pie" is an old or obsolete way of setting the flag
19:28:34 <geekosaur> interesting. in any case, I don't think Jessie requires it
19:29:03 <geekosaur> yeh, per https://wiki.debian.org/HardeningWalkthrough they did not turn on requiring position independent executables in jessie
19:33:40 <whiterabbit> <whiterabbit> the government is messing with me and other mexicans i think in sacramemto california
19:33:42 <whiterabbit> <whiterabbit> they have some radio waves or something
19:33:44 <whiterabbit> <whiterabbit> with drones i think
19:33:46 <whiterabbit> <whiterabbit> it could be some gang members with microwave guns but im hella hot right now
19:33:50 <whiterabbit> <whiterabbit> ifykwim
19:33:52 <whiterabbit> <whiterabbit> meaning theyre watching me close
19:33:54 <whiterabbit> <whiterabbit> i think its some metal oxide chem or something that gets stuck on the nerve cells of the brain and its irritates me stronger than other people 
19:33:57 <whiterabbit> <whiterabbit> fuckin a dude 
19:34:15 --- mode: ChanServ set +o geekosaur
19:34:28 --- mode: geekosaur set +b whiterabbit!*@*
19:35:36 <c_wraith> huh.  I just saw that user get banned on another channel too.  They really were trying to get mass-banned, weren't they?
19:46:07 --- mode: ChanServ set +o glguy
19:46:07 --- mode: glguy set +b-bo *!*@76-14-164-44.wsac.wavecable.com whiterabbit!*@* glguy
20:25:07 <Rotaerk> hmm my program does both inter-thread communication and will also do inter-process communication; because of this I was going to use 0MQ, but ended up abandoning it for inter-thread
20:25:27 <Rotaerk> since there are better options for inter-thread... things that don't lose type information
20:26:00 <Rotaerk> is there a better haskell option for inter-process? or should I go ahead and use 0MQ
20:26:51 <boj> have you considered unix pipes?
20:27:20 <boj> or do you need to expand out to multi-machine scenarios?
20:27:21 <Rotaerk> I think named pipes are an option for the transport in 0MQ
20:27:29 <Rotaerk> multi-machine is unnecessary
20:27:33 <exio4> Rotaerk: I would use ZMQ mostly because it's .. uh, well-tested, not really nice or beautiful but it's known to work in multiple situations
20:27:59 <exio4> so if anything happens you know the problem isn't likely to be there but in your code :)
20:28:18 <Rotaerk> k
20:28:43 <Rotaerk> thanks
20:32:52 <Rotaerk> now I guess I just need to determine the protocol for the content of that IPC
20:33:00 <Rotaerk> thinking about just using the binary package
20:37:36 <monochrom> binary sounds good.
20:37:49 <monochrom> If you are lazy, show and read :D
20:39:09 <Rotaerk> heh
20:39:16 <c_wraith> If you trust all your nodes 100% and don't mind restricting yourself to GHC 8.2+ and don't mind requiring every node runs the exact same binary, you can use Compact Normal Forms!  (That's a lot of ifs for a reason)
20:41:19 <monochrom> What is Compact Normal Form?
20:41:35 <monochrom> It sounds too good to be true!
20:41:56 <c_wraith> It's what you get when you serialize a compact region
20:42:05 <monochrom> Oh neato.
20:42:43 <c_wraith> https://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact-Serialize.html
20:43:11 <monochrom> So I can put a highly cyclic graph in a compact region, then just ask to serialize it, and nothing will go wrong? :)
20:43:21 <c_wraith> You actually *can*
20:43:32 <c_wraith> But if you don't know it's cyclic... something can go wrong. :)
20:43:52 <c_wraith> https://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact.html#v:compactWithSharing
20:44:12 <c_wraith> That one will not go into infinite loops with cyclic data. :)
20:47:49 <monochrom> Ah but it's also a memory dump so it is bloater than hand-tuned binary because for example an Int is easily 16 bytes. Not so compact any more, eh? >:D
20:48:18 <c_wraith> "Contiguous" might be a better name.
20:48:29 <monochrom> haha compactWithSharing is 10x slower
20:48:33 <c_wraith> yep1
20:48:36 <c_wraith> er, yep!
20:49:08 <monochrom> I think it is the real analysis or topology kind of "compact": closed and bounded, no one really says it's small.
20:49:35 <c_wraith> I wanted to avoid thinking about whether closed requires uncountably many addresses. :)
20:49:49 <monochrom> (More accurately, every open cover has a finite subcover. More broadly, finitely generated FSVO "generated".)
20:50:48 <c_wraith> I've been learning the basics of measure theory - mostly properties of Lebesgue measure.  It amuses me that any countable set has Lebesgue measure 0.
20:53:23 <monochrom> Yeah you'll meet "this function has compact support" very soon. This means that { x | f(x) != 0 } is a compact set. This is cool to know because then you know that integrating this function over "all of the reals" is really a proper integral.
21:00:51 <cobreadmonster> c_wraith: have you looked at Stein and Shakarchi?
21:00:56 <monochrom> OK the 10x slower is just for using a dictionary for "have I seen this node?" which is fair. I mean Java has to do this too.
21:01:04 <cobreadmonster> everyone loves the book, though personally I find it infuriating.
21:01:16 <monochrom> Anyway so we can now say "we have finally caught up on Java"
21:01:44 <c_wraith> cobreadmonster: the only one I've looked at so far is the free pre-release version of Terrence Tao's measure theory book.
21:01:49 <c_wraith> cobreadmonster: I'm cheap.
21:02:00 <cobreadmonster> c_wraith: libgen is your friend.
21:02:24 <nisstyre> libgen is good for epubs
21:02:45 <nisstyre> not sure how much scientific literature is on there
21:03:49 <Rotaerk> hmm so what's the relationship between a bra and a cobra
21:04:09 <c_wraith> who gets poisoned.
21:06:47 <dolio> monochrom: The best definition is, X is compact if every space Y is closed under universal quantification over X.
21:09:17 <dolio> And X is overt if every other space is closed under existential quantification over X.
22:19:38 <dsal> I've got an exception handler seeming to fall through my try unscathed.  Can anyone help me understand what's going on here?  http://lpaste.net/358000
22:22:00 <c_wraith> dsal: looks like laziness.
22:22:18 <dsal> Man.  It's always laziness...
22:22:25 <c_wraith> well, not actually laziness in this case
22:22:32 <c_wraith> It's just that evaluating an IO value does nothing
22:22:40 <c_wraith> (not quite true, but close enough)
22:22:53 <c_wraith> You want to actually *execute* the IO value, I think
22:22:54 <cocreature> just remove the "evaluate"
22:23:34 <c_wraith> and make the other changes necessary
22:23:40 <dsal> Ah, I needed the evaluate where I had it before.
22:23:48 <cocreature> what you are doing is checking if _evaluating_ the IO action produces an exception. but what you are interested in is if _executing_ the IO action produces an exception
22:23:53 <dsal> Still haven't internalized these IO interactions.
22:24:25 <cocreature> if you use exceptions only inside of IO (which you should) then you shouldn’t need evaluate
22:25:19 <c_wraith> cocreature: look at line 18 there, though
22:26:09 <cocreature> oh right, that should be "throwIO"
22:28:28 <dsal> The laziness is certainly confusing to me.  I get parse exceptions in weird places.
22:29:25 <c_wraith> dsal: in general, people have mostly settled on "only use error to indicate that a precondition was violated, and then never try to recover from it. It indicates code is broken, not a condition that can be handled"
22:29:51 <c_wraith> dsal: if you want to actually use exceptions that can be handled, stick with throwIO
22:30:04 <dsal> Makes sense.
22:31:11 <dsal> The above suggestion at least got this bit of code working.  I don't completely understand where I'm seeing my parse exceptions here, though.  I'm getting them requesting data from my state, but my state should only include things that have been verified already.
22:32:11 <c_wraith> that probably *is* laziness.
22:37:57 <dsal> Adding a random ($!) didn't solve all my problems.
22:38:21 <cocreature> dsal: can you be a bit more specific? what exactly is the rpoblem you’re seeing?
22:39:10 <c_wraith> dsal: randomly adding bang patterns or seq calls usually makes things worse.  It's best to have an idea what's going on. :)
22:39:27 <dsal> So, I read some data from a serial port.  It's checksummed, so my "parser" basically validates the checksum and then returns it.  Let me paste slightly more.
22:39:54 <dsal> http://lpaste.net/358001
22:40:34 <dsal> So, loop reads the data line 8 is attempting to validate the data and then pass it along to a function that uses STM to set it into global state that can be retrieved from various places.
22:40:46 <cocreature> I would really recommend that you use throwIO instead of error
22:41:07 <dsal> One of those is a thing that spits it out in JSON format.  That one is getting the error.
22:41:26 <dsal> Hmm...  That's interesting.  The verifyPkt thing *isn't* actually in IO.
22:41:41 <dsal> That sounds like some refactorin'
22:42:47 <cocreature> as a good rule of thumb use "Either ErrorType" in pure code and use exceptions in IO (if you want to use them at all)
22:43:08 <cocreature> exceptions in pure code don’t tend to be a good idea
22:44:13 <dsal> Makes sense.  This has been fine so far.  I'm cleaning it up now.
22:45:14 <cocreature> if you use exceptions in pure code it’s really easy to accidentally hide them in the tail of a list or something like that and then they will be ignored until something forces that tail
22:45:25 <cocreature> and at that point things get really confusing :)
22:46:53 <dsal> Man.  Now I have to figure out how my verify thing works.  Either almost makes sense.
22:47:06 <c_wraith> dsal: also, compare to the earlier advice on the purpose of error.  Use it only to signal the violation of a precondition of using a function.  In your case, error isn't a good fit because there isn't a precondition.
22:48:50 <c_wraith> in fact, that's generally true of all parsers.  They should handle whatever garbage is thrown at them. :)
22:59:33 <dsal> What's the short path to  String -> Exception ?
23:00:54 <dsal> @hoogle String -> Exception
23:00:54 <lambdabot> Sound.File.Sndfile Exception :: String -> Exception
23:00:55 <lambdabot> Sound.File.Sndfile UnrecognisedFormat :: String -> Exception
23:00:55 <lambdabot> Sound.File.Sndfile SystemError :: String -> Exception
23:02:18 <dsal> I think I can just get rid of all the exceptions.
23:03:04 <c_wraith> that's almost certainly the best approach
23:03:11 <iqubic> Why are those all in the Sound.File.Sndfile? What even is that??
23:22:56 <dsal> @hoogle a -> IO a
23:22:57 <lambdabot> Control.Exception evaluate :: a -> IO a
23:22:57 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
23:22:57 <lambdabot> Test.QuickCheck.Exception evaluate :: a -> IO a
23:30:47 <iqubic> Why not just use return?
23:30:52 <iqubic> :t return
23:30:53 <lambdabot> Monad m => a -> m a
23:33:15 <dsal> Huh.  I hadn't quite understood what return means.
23:34:16 <dsal> I keep imagining it, you know, returns.
23:35:07 <jle`> yup return is pretty badly named
23:35:19 <iqubic> Nope. The only way to return from a haskell function is to reach the last statement.
23:35:31 <jle`> it's actually spectacularly bad naming
23:35:47 <jle`> literally as misleading as any name could be in programming, heh
23:35:49 <jle`> oh well
23:36:13 <iqubic> Return just takes a value and puts it into a monadic context. An IO action happens to be a monadic context.
23:36:13 * jle` walks away mumbling something about historical baggage
23:36:44 <dsal> monadify
23:37:18 <iqubic> It's usually at the end of a do block because all the statements in a do block must be of the monad.
23:37:23 <jle`> return is probably the worst name you could probably pick for such a function
23:37:48 <jle`> i spent a day thinking about worse and more misleading names you could possibly give it, and i couldn't think of anything worse
23:37:51 <dsal> My program fails read from the serial port a lot. This is expected.  I do wish this were a bit better.
23:37:55 <dsal> goto
23:38:04 <jle`> goto is also probably a bad name
23:38:06 <jle`> :)
23:38:09 <iqubic> :t goto
23:38:11 <lambdabot> error: Variable not in scope: goto
23:38:17 <iqubic> What does goto do?
23:38:31 <koz_> Can someone suggest any blogs/publications/something that gets updated regularly to follow for Haskell stuff?
23:38:48 <jle`> oh we were just thinking about other things they could have chosen to name the no-op `Monad m => a -> m a`
23:38:56 <jle`> that might have been an even worse choice than "return"
23:39:15 <jle`> koz_: there's that haskell weekly newsletter
23:39:20 <koz_> jle`: Link?
23:39:21 <jle`> it's become pretty good
23:39:28 <koz_> Also, I reckon we should just use 'pure'.
23:39:29 <jle`> https://haskellweekly.news/
23:39:43 <iqubic> koz_: Pure is already taken.
23:39:45 <iqubic> :t pure
23:39:47 <lambdabot> Applicative f => a -> f a
23:39:52 <koz_> iqubic: It's the same operation. :P
23:40:16 <jle`> gasp
23:40:37 <jle`> but yeah, most things that i've found worth reading have shown up in the haskell weekly
23:40:57 <jle`> it's mostly articles though
23:41:11 <iqubic> Are there any worthwile applicatives that have no monad instance?
23:41:18 <koz_> iqubic: ZipList?
23:41:19 <jle`> so like you might miss out on like, discussions, community discussions, some drama
23:41:28 <jle`> iqubic: yeah most of my favorite applicatives don't have Mmnad instances
23:41:32 <jle`> *Monad
23:41:44 <jle`> like, `Const w`
23:41:54 <jle`> my best friend and home slice
23:41:57 <koz_> Oh yeah, Const. The power behind lens. :P
23:42:05 <jle`> also Validation
23:42:09 <iqubic> And you can't use those in a do block.
23:42:11 <jle`> and that parallel IO type
23:42:18 <koz_> iqubic: You can with ApplicativeDo. :P
23:42:18 <jle`> you can use it in a do block as of ghc 8 :O
23:42:23 <koz_> jle`: Validation is what again?
23:42:28 <koz_> Also, what parallel IO type?
23:42:41 <jle`> Validation is an Either where <*>/sequence accumulates errors
23:42:43 <jle`> instead of short-circuits
23:42:52 <jle`> so it's good for like validation and parsing fixed schemas
23:43:06 <koz_> jle`: So is it kinda like having a Writer on the 'left side'?
23:43:09 <jle`> and you can write an Applicative instance for IO where <*>/sequence are all parallel/concurrent
23:43:21 <jle`> koz_: yeah, if all your things are Left's, it's basically Const
23:43:28 <jle`> or Writer
23:44:36 <jle`> the parallel IO applicative is nice, so sequence [x,y,z::IO a] :: IO [a], which executes x, y, and z at the same time concurrently and collects the results together when they all finish
23:44:45 <jle`> sorry, sequenceA
23:44:47 <jle`> silly names
23:44:55 <koz_> :t sequenceA
23:44:56 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
23:45:00 <koz_> :t sequence
23:45:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:45:06 <koz_> Ah, I see.
23:45:10 <jle`> sequenceA is implemented in terms of <*> and pure
23:45:20 <jle`> sequence is implemented in terms of >>= and return
23:45:36 <jle`> sequence shouldn't really exist anymore
23:46:00 <koz_> Yeah, it's like return shouldn't exist anymore, really.
23:46:19 <koz_> Since Applicative is now a prereq of Monad, we can just use 'pure' instead.
23:46:30 <jle`> :(
23:48:53 <iqubic> Most monad instances just write return = pure anyway.
23:49:08 <koz_> iqubic: Technically, this is something you should do.
23:49:14 <koz_> (according to the docs of the Monad typeclass)
23:49:59 <cocreature> we only have to wait until ghc 8.8 until return is dead :)
23:50:30 <iqubic> Why that long?
23:50:37 <koz_> cocreature: That's a joke right?
23:52:14 <cocreature> koz_: not really, see https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn#ReducedBreakageVariant
23:52:52 <koz_> cocreature: Huh, never thought I'd see that.
23:53:02 <koz_> I am happy to hear of this proposal.
23:53:24 <koz_> So Monad would just have bind or join as required?
23:53:32 <koz_> (in addition to an Applicative instance, of course)
23:53:46 <cocreature> I don’t think there are plans to move "join" into the Monad class
23:53:58 <jle`> i think there are some issues with 'join' and GeneralizedNewtypeDeriving
23:54:01 <jle`> which is kind of unfortunate
23:54:13 <koz_> cocreature: Huh, I was sure that you could define join instead of bind for a Monad.
23:54:16 <koz_> TIL I guess.
23:55:01 <ertes> iqubic: you don't even have to define that
23:55:12 <ertes> (return = pure) is the default
23:55:53 <iqubic> How can the compiler check if a monad definition is lawful or not?
23:56:07 <koz_> iqubic: It can't. Unless you use jle`'s hack.
23:56:12 <koz_> (which I am unsure applies)
23:56:13 <iqubic> And give a warning/compile time error.
23:56:53 <iqubic> But the proposal says that it will give a warning to unlawful definitions of return  and bind
23:57:34 <iqubic> So what am I missing here?
23:58:33 <cocreature> it’s just a syntactic check for "pure" afaik
23:59:28 <iqubic> Oh. I see.
