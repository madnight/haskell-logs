00:23:46 <jle`> huh :~~: in ghc 8.2 solves a problem that i didn't even know existed
00:24:20 <jle`> Type.Reflection has some nice tools
00:24:51 <jle`> i just used it to write safe code where i used to not be able to before
00:24:55 <jle`> life is good
00:39:12 * hackagebot inline-c 0.6.0.3 – Write Haskell source files including C code inline. No FFI required. – https://hackage.haskell.org/package/inline-c
00:52:25 * hackagebot x509-store 1.6.5 – X.509 collection accessing and storing methods – https://hackage.haskell.org/package/x509-store
01:11:06 <butterthebuddha> https://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
01:11:22 <butterthebuddha> I'm confused with exercise 5 while trying to implement Expr for Program
01:11:40 <butterthebuddha> Because the implementation for 'add' and 'mul' will take two programs as input
01:11:45 <butterthebuddha> How does that work?
01:13:39 * hackagebot extensible 0.4.3 – Extensible, efficient, optics-friendly data types and effects – https://hackage.haskell.org/package/extensible
01:13:39 * hackagebot med-module 0.1.1 – Parse song module files from Amiga MED and OctaMED – https://hackage.haskell.org/package/med-module
01:15:18 <ab9rf> "Some uses of type applications may cause GHC to panic." oops
01:17:51 <cocreature> butterthebuddha: so you are given two Programs and you need to produce a Program. a Program is just a list of StackExp. do you see anything in StackExp that might be helpful to implement "add"?
01:18:06 <butterthebuddha> Yeah the numbers are in the Program
01:18:16 <butterthebuddha> But what do the input programs look like
01:18:28 <butterthebuddha> Is it the same program passed in twice?
01:19:01 <cocreature> no why should it be the same program? you are given two potentially programs that should be added
01:19:22 <cocreature> StackExp has an "Add" constructor that you are going to need
01:19:43 <butterthebuddha> Am I adding programs or numbers in the programs?
01:20:01 <cocreature> you are given two programs and need to produce a new program
01:20:14 <geekosaur> you are combining programs that eventually will produce numbers when run, and incoirporating an additional program to add those results together
01:20:22 <cocreature> you probably have something like "class Exp a where add :: a -> a -> a"
01:20:42 <cocreature> and now you are trying to write "instance Exp Program w here add :: Program -> Program -> Program; add = …"
01:22:58 <butterthebuddha> Yeah but what are the inputs supposed to look like?
01:23:20 <cocreature> I’m not sure I understand that question. they are just Programs
01:23:21 <butterthebuddha> My `lit` function is simply `lit x = [PushI x]`
01:23:41 <butterthebuddha> Okay, diff question - what does "adding" programs mean?
01:24:34 <cocreature> alright let’s step back for a moment. given two programs that each produce a stack of one element when run, how can you create a new program that when run produces a stack containing both elements?
01:25:25 <ab9rf> "silicon goo"
01:26:42 <butterthebuddha> Oh so do i combine then and push "Add" on to the stack?
01:26:50 <cocreature> exactly!
01:28:12 <ab9rf> that looks like a nice little problem set
01:30:10 <butterthebuddha> So I can use parseExp to go from the String to a representation in terms of Expr
01:30:21 <butterthebuddha> ExprT*
01:31:25 <butterthebuddha> How do I convert that into a Program?
01:35:44 <cocreature> butterthebuddha: you should be able to write a function "Expr a => ExprT -> a" and then you can use that to convert to Program but also to anything else that is an instance of Expr
01:46:26 <francesco_> Hi
01:46:38 <francesco_> I'm having problems installing cabal after I updated to ghc 8.2.1
01:47:06 <francesco_> I first tried with cabal 1.24.0.2
01:47:08 <merijn> francesco_: GHC 8.2 requires a newer cabal and I'm not sure it's been released yet
01:47:23 <francesco_> neither the one from git repo works
01:47:26 <francesco_> oh got it
01:47:32 <francesco_> will get back to old ghc, then
01:47:33 <francesco_> thanks
01:48:33 * hackagebot binary-conduit 1.2.5 – data serialization/deserialization conduit library – https://hackage.haskell.org/package/binary-conduit
01:48:42 <merijn> francesco_: Honestly I usually recommend people to always lag the current GHC version by one release (i.e. switch to 8.2 when 8.4 comes out, etc.) unless you have a good reason not too
01:49:21 <francesco_> it makes sense. For now my reason was: Colorful errors!
01:49:52 <francesco_> one silly question, ghc 8.1 hasn't been released?
01:49:56 <francesco_> why directly to 8.2?
01:50:05 <francesco_> oh and I answered
01:50:07 <francesco_> it myself
01:50:13 <francesco_> sorry 
01:50:35 <merijn> francesco_: GHC uses even numbers for releases, odd for work in progress/HEAD
01:50:54 <merijn> francesco_: So 8.1 is the development version that will become 8.2, 8.3 will become 8.4, etc.
01:51:06 <francesco_> yes, ty
02:05:51 <ab9rf> i'm not convinced that "colorful errors" represents an improvement
02:06:06 <merijn> ab9rf: I do
02:06:14 <ab9rf> technicolor vomit
02:06:18 <merijn> Much easier to scan
02:06:25 <ab9rf> merijn: for you, maybe
02:06:35 <merijn> ab9rf: You can just turn them off, then :)
02:06:36 <ab9rf> some people actually find color noise makes it harder
02:06:42 <ab9rf> fairy nuff
02:07:32 <Rembane> If you can turn them off everybody wins.
02:07:47 <francesco_> yeah
02:07:53 <merijn> Rembane: iirc there's a flag for alway on/off/auto
02:08:16 <Rembane> merijn: Very good.
02:08:38 <srhb> Strawpoll on error colors needed, clearly.
02:08:42 <srhb> (I love them)
02:09:31 <merijn> Colours and fancy caret error reports almost makes me update to 8.2, but I just updated to 8.0 and new-build, so I'm letting my environment settle down for a bit
02:09:32 <ralu> I also like them like in clang
02:10:21 <ab9rf> color errors wil be a big lose with some types of synathesia, but people like that are used to disabling colors because their brains produce them all on their own
02:10:54 <merijn> ab9rf: To be fair, if colours are that big an issue I'm assuming they've switched off colours in their terminal anyway :)
02:11:33 <cocreature> funnily enough GHC also colors the output when there is an error in C code
02:11:44 <cocreature> it’s just not very good at it, it always colors only the first character …
02:11:52 <cocreature> but the carrets are useful even in that case
02:18:24 <ab9rf> carrots are also useful, but more for dealing with bunny invasions
02:19:04 <cocreature> I’m not sure carrots help with bunny invasions. I would expect that giving carrots to the bunnies only increases their population
02:22:08 <pacak> It's cocarrots you want....
02:24:32 * hackagebot weigh 0.0.5 – Measure allocations of a Haskell functions/values – https://hackage.haskell.org/package/weigh
02:31:41 <foldr> When I want to catch a bunny I go sit behind a tree and imitate the sound of a carrot
02:32:07 <merijn> I just leave work at dusk and I'll trip over a few without trying :p
02:33:05 <ab9rf> fine, carrots are for cobunnies
02:33:20 <[exa]> carrots are a linear resource
02:33:56 <[exa]> bunny invasion is doomed
02:34:31 <ab9rf> i do not approve of this weather forecast
02:35:35 <foldr> but the dining bunnies have an infinite supply
02:36:47 <ab9rf> yes, but if you only give them one fork each....
02:37:31 <foldr> bunnies don't use forks, and they just eat from eachothers plates without them caring
02:37:47 <ab9rf> so much for voluntary resource sharing
02:38:08 <foldr> bunnies are very efficient at concurrency and the invasion will be extremely successful
02:41:47 * hackagebot open-witness 0.4.0.1 – open witnesses – https://hackage.haskell.org/package/open-witness
02:55:57 * hackagebot inline-c 0.6.0.4 – Write Haskell source files including C code inline. No FFI required. – https://hackage.haskell.org/package/inline-c
03:09:27 <trigone> hi, how can i get a local html copy of the haddocs of some package?
03:10:35 <lyxia> (cabal|stack) haddock mypackage ?
03:12:25 <trigone> lyxia: i'll try that thx... where will it put it?
03:13:38 <trigone> lyxia: it worked, thanks :)
04:03:35 <Myrl-saki> This is going to be stupid.
04:04:06 <Myrl-saki> Is the code made in the paper about reflection(modulo) exported as a library?
04:05:03 <danilo2> Hi! is there any popular template haskell library that wraps primitive th functions into something easier to work with? I was writing tons of TH code in my life and I see how this api could be much improved using modern th features
04:05:13 <[exa]> Myrl-saki: which paper exactly?
04:05:35 <Myrl-saki> http://okmij.org/ftp/Haskell/tr-15-04.pdf
04:06:32 <merijn> danilo2: Easier in what way? What kinda operations are complicated that you think could be easier?
04:07:58 <danilo2> merijn: we could create many utils to create functions / datatypes / instances, we can create lenses to access / update some fields. it would be much nicer to write `mkInstance "Show" a & context .~ ctx` than using AST-like operations
04:08:28 <[exa]> Myrl-saki: they claim that their paper is actually literate haskell
04:08:47 <danilo2> merijn: In fact I've created something like this in the past, but it was never finished and ready for release, so if there is nothing like this, I will finish my lib then
04:09:04 <[exa]> Myrl-saki: so you could reconstruct the thing by just copypasting. :D
04:09:21 <quchen> [exa]: A thing is literate haskell iff I can put it into GHC directly. Otherwise it’s as much literate Haskell as an Excel file is.
04:09:50 <quchen> (Well, it has to be GHC compatible and not be a normal Haskell file.)
04:10:48 <Myrl-saki> [exa]: But that requires you to use the mouse!
04:10:58 <[exa]> what about this? http://web.archive.org/web/20070329204419/https://www.cs.rutgers.edu/~ccshan/prepose/Prepose.hs
04:14:05 <Myrl-saki>   signum         =  error "Modular numbers are not signed"
04:14:07 <Myrl-saki>   abs            =  error "Modular numbers are not signed"
04:14:09 <Myrl-saki> But why
04:15:09 * hackagebot iridium 0.1.5.7 – Automated Local Cabal Package Testing and Uploading – https://hackage.haskell.org/package/iridium
04:21:51 <srhb> Anyone got a DiffTime formatter handy? I mostly want hours:minutes
04:23:25 <merijn> srhb: Convert to NominalDiffTime and use Data.Time.Format?
04:23:47 <merijn> srhb: fromIntegral should work to convert
04:23:58 <srhb> merijn: Oh, yeah.
04:24:01 <srhb> merijn: Thanks :)
04:24:03 <merijn> oh, no, wait, not Integral
04:24:06 <merijn> realToFrac, then
04:38:22 * hackagebot monad-skeleton 0.1.5 – Monads of program skeleta – https://hackage.haskell.org/package/monad-skeleton
04:44:56 <foldr> Are there examples of monad-skeleton? It looks a bit like Free but different.
04:53:08 <ertes-w> elo
05:17:14 <BTreeeeee> Quick question, if I have a data type. Like  a simple Binary tree "data BTree a = Leaf | Fork (BTree a) (BTree a)"       when using the ghci how can I create a varibale that is that data, if that question makes sense. Like with "a=5"
05:17:51 <quchen> BTreeeeee: a = Leaf
05:18:06 <quchen> b = Fork Leaf (Fork Leaf Leaf)
05:18:16 <quchen> In older GHCi versions you have to prefix with a »let«.
05:18:38 <foldr> Your tree will never contain a value of type `a'
05:19:53 <BTreeeeee> Thanks, so if  I have a complicated tree that I have to input I would have to do it all in one line?
05:20:16 <foldr> You can name the individual parts
05:20:36 <foldr> For example `let { a = Leaf; b = Fork a a } in Fork b Leaf'
05:20:48 <foldr> Then it can be on many lines and readable
05:23:33 <BTreeeeee> thank you
05:26:33 <aphorisme> using esqueleto, binding together several statements (i.e. stuff of type `SqlPersistT m a`) and running them runs them as one transaction? 
05:28:06 <merijn> aphorisme: I think so, although I have to admit I just gave up on esqueleto and just switched to using persistent's rawQuery instead for more complex queries
05:29:16 <aphorisme> merijn: Thanks. Well, there is some deadline at the end of this week. I probably would change... Do you know if transactions get serialized within PostgreSQL? Or do I need to lock them?
05:29:47 <merijn> aphorisme: Eh, none of the above?
05:30:18 <merijn> aphorisme: The entire point of transactions is that they can run in parallel and you don't have to think about locking because that's what the SQL server does for you...
05:30:55 <merijn> The entire point of the A and I parts of ACID is "I wanna run complex queries in parallel and not think about shit" :p
05:31:44 <aphorisme> merijn: hm, okay... well, point is, I have to look up some key with recursively querying a table. There should happen no modifying of this table while looking up the key.
05:32:15 <aphorisme> I probably have to implement some fine-grained name locking on the backend side.
05:33:36 <merijn> aphorisme: The entire point of transactions is that none of the rows seen during a transaction is changed while it runs. All the things you're suggesting right now are *already* implemented inside postgres
05:34:04 <aphorisme> merijn: thanks! And thanks to that transaction stuff.  ; )
05:36:14 <merijn> On a completely different note: I have a large set of multi-dimensional datapoints, a lot of which are clustered within the parameter space. Are there any well-known methods on how I can drop datapoints in such a way that I end up with a more uniform sampling of the space?
05:39:44 <Logio> merijn: what's the reason for the more uniform sampling?
05:41:04 <merijn> Logio: Messy real-world sampling, so trying to eliminate bias introduces by same parts of the space being overrepresented
05:41:51 <merijn> Logio: I don't have an adequate way to get actual uniform sampling of the parameter space
05:42:26 <merijn> Oh, speaking of local coop, Jazz Jackrabbit 2 :p
05:42:39 <merijn> Although that uses splitscreen, I think
05:46:10 <Logio> merijn: what are you doing with the data that suffers from bias? I'm wondering if it's easier to skip sampling by using some method which deals with biased datasets natively.
05:47:19 <merijn> Logio: I'm trying to construct a model from the data so I can do predictions
05:48:31 <Logio> If you want a more uniform (random) set consisting of your datapoints, it's probably easiest to generate some sampling of the space and for each sample pick a nearest neighbor from your dataset
05:49:42 <Logio> but if there is no data at all in some parts of the dataset, you'll still be introducing bias
05:49:59 <merijn> Logio: Basically, I want to drop points so that I make the dense parts I have less dense (basically collapsing dense groups into single points)
05:50:56 <Logio> well, the method above picks one datapoint for each sampling point
05:53:00 <Logio> in some cases you could probably even just have a grid and interpolate your datapoints to it
05:53:26 <Logio> but not knowing the problem domain it's hard to say what's correct
05:55:28 * hackagebot hledger-iadd 1.2.5 – A terminal UI as drop-in replacement for hledger add – https://hackage.haskell.org/package/hledger-iadd
06:06:39 <quchen> edwardk: Hey Edward, did you receive my plea to release a patch bump for ansi-wl-pprint? :-)
06:07:39 * hackagebot plot-light 0.2.7 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
06:14:29 <edwardk> I didn't but I have no problem doing so
06:14:44 <edwardk> Or even empowering you to
06:17:02 <edwardk> quchen: you are now in the maintainer group
06:17:39 <quchen> edwardk: Hooray! Thanks.
06:17:40 <Geekingfrog> What's a ribbon width in the context of the pretty printer ?
06:18:02 <quchen> Geekingfrog: »Line length minus the leading whitespace«
06:18:34 <quchen> Geekingfrog: See the »Available width« section here: https://hackage.haskell.org/package/prettyprinter-1.1/docs/Data-Text-Prettyprint-Doc.html
06:18:41 <Geekingfrog> Thanks
06:20:56 <quchen> Geekingfrog: It’s usually a »ribbon fraction«. A value of 0.5 means that only half the line should be filled with printable content.
06:22:57 <merijn> quchen: Now hurry up and update trifecta so I can update my code to use prettyprinter! ;)
06:24:03 <phadej> prettyprinter doesn't have Pretty class, does it?
06:24:06 <quchen> trifecta is too central to »just update« it. The upside is that with the new ansi-wl-pprint I can release conversion functions from ansi-wl-pprint to prettyprinter (and back).
06:24:09 <quchen> phadej: It does
06:24:16 <phadej> it has, ok, it's a bit hidden
06:24:23 <quchen> Is it?
06:24:52 <quchen> It’s the second definition in the file, and the first under »basic functionality«
06:24:53 <phadej> well, kind of. but it's colorless Pretty?
06:25:38 <phadej> quchen: I'd have it in own module
06:25:48 <quchen> The Pretty class does not support coloring, yes. It only creates unannotated documents.
06:26:06 <quchen> If you want an annotated Pretty class, you’ll have to write it yourself. (It’s what Idris does, for example.)
06:26:20 <quchen> instance Pretty' Bool PhadejAnnotation where …
06:27:27 <phadej> but this <http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3/docs/Text-PrettyPrint-ANSI-Leijen.html#t:Pretty Pretty> is colorful! (the one used by trifecta)
06:28:09 <quchen> If you’re in an ANSI terminal it is, yes. If you want to generate HTML you’ve got a problem.
06:28:43 <quchen> ansi-wl-pprint can print ANSI terminal colors and nothing else. prettyprinter has extensible backends (ANSI being one of them).
06:28:50 <phadej> quchen: well, there is ToMarkup to write blaze...
06:29:45 <quchen> phadej: But you can’t convert an ansi-wl-pprint Doc to Blaze easily. Doc is abstract and very specific to ANSI features.
06:29:53 <masaeedu[m]> Is there a way to get ghci to show me the system f corresponding to my code?
06:30:03 <merijn> phadej: The problem is that there's a bunch of mutually incompatible prettyprinters and quchen is doing the lords work by writing the One Prettyprinter to Rule Them All
06:30:05 <quchen> You’d have to parse the generated output and guess which color is currently set from the ANSI codes encountered
06:30:22 <phadej> quchen: trifecta converts directly to Blaze's (don't remember the type name)
06:30:51 <quchen> I guess then it’s not using ansi-wl-pprint in the ->Blaze pipeline?
06:30:58 <phadej> quchen: it isn't.
06:31:09 <phadej> and it's a good question whether it should go thru pretty printer or not
06:31:53 <phadej> merijn: I know, and I challenge him periodically
06:32:16 <phadej> personally I might want lucid backend with trifecta...
06:32:46 <phadej> because there isn't onw html-markup library to rule them all either :/
06:32:52 <phadej> isn't single*
06:33:00 <quchen> There are two good alternatives.
06:33:14 <quchen> With prettyprinting there is a load of alternatives, all of them lacking. :-/
06:33:27 <quchen> You want Text? Well then you can’t have color.
06:33:40 <quchen> You want color? Well then you can’t have other annotations.
06:33:52 <phadej> quchen: I'm quite happy with http://hackage.haskell.org/package/pretty-compact-2.1 ;)
06:33:57 <LiaoTao> https://xkcd.com/927/  ?
06:33:59 <phadej> now as it's released!
06:34:05 <quchen> You want other annotations? Well then you can’t have the new layout like »nesting«.
06:34:17 <edwardk> Quchen: On the other hand, if you want to dive in and show trifecta a lot of love like you have prettyprinter/ansi-well-print active maintenance forgives a lot of changes
06:34:37 <edwardk> Er ansi-wl-pprint stupid autocorrect
06:35:38 <quchen> Yeah I thought about this, but so far I wasn’t fed up with Trifecta enough to go ahead and do it :-þ
06:35:56 <quchen> Trifecta is already decent, all it lacks is good documentation.
06:36:04 <quchen> But the feature set (combined with parsers) is fine.
06:36:31 <quchen> I don’t have to choose between backtracking and monadic parsing for example, which is something prettyprinters kind of made me do.
06:36:57 <quchen> phadej: Yeah Bernardy’s algorithm…
06:37:43 * edwardk not so subtly adds quchen to the maintainer group and github project for trifecta ;)
06:37:46 <phadej> quchen: and imho the interface in that library is ok-ish, you can have arbitrary annotations, you can have Text.Builder as render target, you can layout
06:38:13 <phadej> but it's different that what prettyprinter have
06:38:19 <quchen> Goddammit Edward
06:38:20 <quchen> Whyyyyy
06:38:28 <edwardk> Ask shachaf
06:38:41 <quchen> shachaf? Does he still exist?
06:39:01 <edwardk> he exists in a sort of limbo state where he tries to avoid me lest i give him commit access to more things
06:39:02 <quchen> Was shachaf not interested in Lens until you added him to the maintainers or something?
06:39:08 <edwardk> pretty much
06:39:32 <quchen> I just remember him getting grumpier by the day in here until he didn’t show up anymore :-/
06:40:37 <edwardk> he still hides out in #haskell-lens
06:41:41 <quchen> Glad to hear that. You never know why people don’t show up anymore on the internet.
06:42:00 <edwardk> there you are not added to trifecta. feel free to drag it forward into the modern age
06:42:03 <edwardk> er now
06:42:05 <edwardk> =)
06:42:05 <phadej> fwiw, i thought for a moment this is #haskell-lens
06:42:26 * quchen is now collecting maintainership for things Edward maintains
06:43:00 <phadej> I got only commit bits so far :(
06:44:58 <quchen> edwardk: Now that I know ansi-wl-pprint’s extensive testsuite I’m scared of releasing it to Hackage
06:45:03 <quchen> (It has ummmmm none)
06:45:23 <quchen> inb4 it typechecks ship it
06:45:47 <edwardk> it has a huge test suite. that test suite is called all of hackage. once released, you'll get issues filed about every little bug and behavior shift you can imagine
06:45:58 <edwardk> it'll be quite swift, too
06:46:15 <merijn> edwardk is my kinda programmer ;)
06:46:58 <phadej> quchen: I can at least test that "everything" compiles against yet-unreleased ansi-wl-pprint, if you mind
06:47:09 <phadej> I have "a system" in backing for that kind of tasks
06:47:23 <quchen> Those "quotes" are unsettling
06:47:28 <quchen> Do you hide an oracle?
06:47:46 <quchen> Anyway, if you could do that I’d appreciate it!
06:47:58 <quchen> Just use edward’s master branch
06:48:05 <phadej> k
06:48:07 <quchen> All I have ontop of that is the .cabal file version bump
06:48:20 <quchen> The only possible breakage is because <> has changed a bit, really.
06:48:34 <quchen> But given how central the package is it would be a good idea nevertheless.
06:48:54 <quchen> And since it’ll be a patch bump it’ll break the next LTS release if it’s horribly wrong
06:58:45 <quchen> phadej: I’ve got to leave, but when you’re done you can open a ticket or mail me (dluposchainsky at google) or catch me here tomorrow
06:58:52 <quchen> Thanks again!
06:59:21 <phadej> quchen: will do.
07:00:21 * hackagebot dbcleaner 0.1.3 – Clean database tables automatically around hspec tests – https://hackage.haskell.org/package/dbcleaner
07:54:57 <juanpaucar> I was reading the entry en the haskell Wiki about Point Free notation and they pointed something very weird for me
07:55:17 <juanpaucar> that (-> a) is a monad, could someone explain it?
07:57:37 <bvad> juanpaucar: it says `(->) a` right?
07:57:46 <foldr> (-> a) is a syntax error. But there is an instance Monad ((->) a)
07:57:53 <ehubinette> juanpaucar: I think this explains it pretty well: http://www.mjoldfield.com/atelier/2014/07/monads-fn.html
07:58:56 <juanpaucar> you are right it is (->) a
07:59:03 <juanpaucar> I'll read it
08:00:11 <c_wraith> juanpaucar: the monad instance is equivalent to Reader without the newtype wrapping.
08:03:30 <juanpaucar> c_wraith: can you send an example, i don't quite get it yet
08:05:30 <c_wraith> > let f = do { x <- (+1) ; y <- (+2) ; return (x * y) } in f 4 -- juanpaucar 
08:05:32 <lambdabot>  30
08:09:13 <c_wraith> juanpaucar: the idea being that you have some "environment".  The bind operation pulls the value out of the environment and applies a function to it.  The environment is provided when you actually use the function you've built that way.  So in the case above, (+1) and (+2) are applied to the value from the environment, then the product of those two operations is returned.  Finally, the value 4 is provided as the environment.
08:09:57 <juanpaucar> c_wraith: and thay it's equivalent to Reader, ooohhh
08:10:06 <juanpaucar> now I get it
08:10:21 <juanpaucar> thanks everyone, i'm also reading the link
08:10:31 <juanpaucar> *that
08:12:35 <dramforever> Mildly infuriating observation: GHCi in 8.2 supports -ddump-json, but that means all output from this GHCi run is gathered to be sent all at once
08:12:43 <dramforever> when you exit
08:13:28 <c_wraith> dramforever: that sounds like it should be filed as a bug report
08:14:49 <dramforever> Bug means unexpected program behaviour. -ddump-json is experimental, so that is totally expected
08:14:52 <dramforever> just kidding
08:15:12 <c_wraith> what does it do, anyway?
08:17:06 <dramforever> Instead of foo.hs:26:5 warning Can't match blah, it gives an array of json objects like { span: { startLine: 26, startCol: 5, ... }, doc: "Can't" }
08:17:32 <dramforever> So you don't have to try to parse pretty printed error meta-information
08:17:48 <c_wraith> ah, right
08:17:53 <dramforever> the error itself is still pretty-printed, though
08:18:10 <c_wraith> that sounds really useful to have printed interactively
08:18:30 <dramforever> Yes!
08:18:39 <c_wraith> though maybe everyone is using ghcid and it takes care of that.
08:19:02 <dramforever> It pre-processes errors?
08:19:55 <c_wraith> Well, I know you can ask it to typecheck without entering an evaluation environment
08:22:13 <halogenandtoast> Is there a way to hide (:) and define my own?
08:22:28 <halogenandtoast> For purely educational purposes
08:22:29 <dramforever> Pretty sure you can just use GHCi machine-interactively
08:22:47 <ReinH> halogenandtoast: no
08:22:56 <halogenandtoast> ReinH: Okay, thanks
08:22:57 <dramforever> If you use -fno-code then evaluation won't work but the rest seem fine
08:30:23 * dramforever is trying to see how far he can get with Haskell tooling, *without* the GHC API
08:33:24 <Myrl-saki> wtf does `cast` do?
08:33:52 <glguy> From Data.Typeable?
08:34:01 <Myrl-saki> Yeah.
08:34:06 <Myrl-saki> Oh wait.
08:34:16 <Myrl-saki> It only works if a == b?
08:34:22 <glguy> yeah
08:34:24 <dramforever> yes
08:34:36 <Myrl-saki> What's a coerce that's safe?
08:34:44 <Xnuk> If I wrote a function `map :: (Int -> Char) -> [Int] -> [Char]` and make a new function like `map' :: (a -> b) -> [a] -> [b]`, then how do you all say this? This is a git commit message problem.
08:34:51 <glguy> and it uses the typeRep to determine if a == b
08:35:44 <Myrl-saki> I'm trying to do https://hackage.haskell.org/package/finite-typelits-0.1.2.0/docs/Data-Finite.html using Peano numbers.
08:36:14 <MarcelineVQ> Xnuk: you've "generalized"
08:36:52 <Myrl-saki> But I don't think I can implement weaken/strengthen without either (a) coerce, (b) existentials
08:38:03 <Myrl-saki> ...wtf
08:38:06 <Myrl-saki> It just worked.
08:38:19 <Myrl-saki> I feel stupid now.
08:38:46 <Xnuk> MarcelineVQ: Thanks
08:41:41 <phadej> a
08:57:01 <Xnuk> a
08:59:41 <JX7P> "Dependent types? C++ has them. Don't see what the big deal is about Haskell and Agda." lol
09:02:16 <ertes-w> C++ has dependent types?  i highly doubt that
09:04:19 <harwiltz> Hello all. I'm having some trouble with the IO monad... I'm using the function doesDirectoryExist :: FilePath -> IO Bool from System.Directory, and I want to use that to edit a list of files. Right now I have modDir path = (doesDirectoryExist path) >= (\isDir -> if isDir then return (path ++ "/") else return path)
09:04:35 <Myrl-saki> >>=?
09:04:37 <harwiltz> Except, of course that returns IO [Char], and I just want [Char]
09:04:59 <harwiltz> Myrl-saki: Sorry, that's what I meant ;)
09:05:00 <Myrl-saki> harwiltz: The thing about IO is that you can't escape it.
09:05:23 <harwiltz> Myrl-saki: But then if you start combining IO actions you end up with obscene types...
09:05:43 <ReinH> ... no?
09:05:43 <Myrl-saki> harwiltz: If any part uses IO, then you'll have to use IO. That way, the "impure" part is isolated.
09:06:00 <Myrl-saki> ReinH: No to me or to harwiltz ?
09:06:19 <ReinH> combining IO actions is literally how you write Haskell programs.
09:06:24 <harwiltz> The main goal is to do getDirectoryList dir = (getDirectoryContents dir) >>= (\contents -> map (modDir) contents) kinda thing
09:06:39 <ReinH> All Haskell programs are IO actions.
09:06:41 <ertes-w> harwiltz: an (IO A) is not a value of type A that is "impure", but more a program that, when run, produces an A
09:07:11 <ertes-w> harwiltz: what you want is to convert that program into a value, which doesn't really make sense, does it?
09:07:25 <ertes-w> harwiltz: imagine writing a function that takes /bin/ls and turns it into a list of files
09:07:34 <harwiltz> ertes-w: Right, but I don't understand how to do it properly
09:07:45 <ertes-w> harwiltz: what's wrong with IO [Char]?
09:08:20 <Myrl-saki> harwiltz: If you have an IO [Char], you can "have" a [Char] by doing (m >>= (\xs -> ...))
09:08:21 <harwiltz> ertes-w: Nothing. But when I do map (modDir) contents, where contents is an IO [FilePath], I get IO [IO [Char]] or something
09:08:27 <ReinH> :t mapM
09:08:29 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:08:33 <ReinH> Then don't use map
09:08:38 <dramforever> that kind of proper way :)
09:08:39 <Myrl-saki> lol
09:08:41 <harwiltz> I think I'm actually using mapM... just a sec
09:08:47 <danilo2> Hi! I just want to ask if would it be possible to implement an efficient (in terms of both time as well as space) lexer using conduit + attoparsec. In fact my only concers are regarding the tokens length that I want to store. It seems that conduit could help with capturing that (attoparsec is missing this information). I'm asking just to know if it would be possible or should I jsut drop this idea
09:08:54 <ertes-w> harwiltz: that's what you should expect from 'map' =)
09:09:15 <ertes-w> harwiltz: it would be really weird if it gave you anything else
09:09:19 <harwiltz> Lol. I was doing return $ mapM ... instead of just mapM ...
09:09:26 <harwiltz> Yeah, this makes sense. 
09:09:29 <harwiltz> Thanks al
09:09:31 <harwiltz> *all
09:09:41 <MarcelineVQ> hooray for easy fixes!
09:09:55 <harwiltz> Indeed
09:10:33 <ertes-w> (BTW, i've started using traverse/traverse_ in new code, and i kinda hope that mapM/mapM_ go away at some point)
09:10:52 <ertes-w> (requires an import, but i hardly write a module that does *not* need Data.Foldable)
09:10:57 <Myrl-saki> ix.io/yQE
09:10:59 <Myrl-saki> REee
09:11:05 <ertes-w> JqUa
09:11:11 <Myrl-saki> I've been working on this specific function for 10 minutes laready.
09:11:23 <Myrl-saki> I have no idea how to write the `otherwise` clause.
09:11:29 <harwiltz> So does this look good to you guys? http://lpaste.net/357365
09:11:49 <dramforever> https://ghc.haskell.org/trac/ghc/ticket/14078 as a bug
09:11:59 <ertes-w> harwiltz: beside a few style points yeah
09:12:17 <ertes-w> harwiltz: for all f: (\x -> f x) = f
09:12:19 <dramforever> harwiltz: it looks great to me
09:12:41 <harwiltz> ertes-w: Hmm... so some of those lambdas are redundant? I'll take a look
09:12:44 <harwiltz> dramforever: Thanks!
09:13:00 <ertes-w> harwiltz: also i suggest using 'pure' in new code
09:13:04 <ertes-w> :t pure
09:13:06 <lambdabot> Applicative f => a -> f a
09:13:08 <ertes-w> :t return
09:13:09 <lambdabot> Monad m => a -> m a
09:13:28 <ertes-w> for the same reason i would suggest using (<*>) over 'ap' =)
09:13:35 <Geekingfrog> :t ap
09:13:35 <ertes-w> and 'fmap' over 'liftM'
09:13:36 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:13:56 <harwiltz> ertes-w: I found that dumb lambda redundancy, thanks. I properly have that a few times in my code ;)
09:14:13 <harwiltz> ertes-w: Why prefer Applicative over Monad?
09:14:26 <ertes-w> harwiltz: since GHC 7.10 Applicative is a super-class of Monad
09:14:30 <ertes-w> so 'pure' is more general
09:15:14 <ertes-w> in other words: Monads aren't the only things that have 'pure', but 'return' is 'pure' with an unnecessary Monad constraint on it
09:15:24 <harwiltz> Ok, so I can replace all instances with return with pure, without having to change anything else?
09:15:30 <ertes-w> yeah
09:15:44 <harwiltz> Yup, that worked
09:18:21 <dramforever> *And* the message output with -ddump-json have reversed order
09:18:34 <dramforever> That was some quality testing...
09:23:41 <ertes-w> harwiltz: if b then pure x else pure y = pure (if b then x else y)
09:24:00 <ertes-w> harwiltz: c >>= \x -> pure (f x) = f <$> c
09:24:10 <ertes-w> where (<$>) is a predefined infix alias for 'fmap'
09:24:24 <Myrl-saki> Reeeeeee
09:24:35 <harwiltz> ertes-w: Oooh, nice. I'll try to implement that
09:24:35 <Myrl-saki> It's an infinite loop. :(
09:24:51 <Myrl-saki> http://ix.io/yQG
09:25:17 <ertes-w> harwiltz: and in terms of operator precedence function application binds more strongly than any operator:  (f x) >>= g = f x >>= g
09:25:29 <Myrl-saki> unsafeCoerce is looking so nice right now.
09:25:54 <harwiltz> ertes-w: Ah, that's nice
09:26:40 <Fuuzetsu> unsure what you're doing but somehow I doubt unsafeCoerce is the solution
09:27:08 <Myrl-saki> Fuuzetsu: Peano version of https://hackage.haskell.org/package/finite-typelits-0.1.2.0/docs/Data-Finite.html
09:27:32 <ertes-w> harwiltz: and as a final library remark:  'getDirectoryContents' returns '.' and '..' as well
09:27:38 <Myrl-saki> Fuuzetsu: http://ix.io/yQH
09:27:56 <ertes-w> harwiltz: use 'listDirectory' instead, if you want to exclude those
09:28:07 <ertes-w> it's otherwise the same as 'getDirectoryContents'
09:28:08 <harwiltz> ertes-w: No, I actually wanna keep those
09:28:17 <ertes-w> ah
09:29:17 * hackagebot cmark 0.5.6 – Fast, accurate CommonMark (Markdown) parser and renderer – https://hackage.haskell.org/package/cmark
09:29:18 <Fuuzetsu> dunno why this would even typecheck -- unshift (FS x) = cast x
09:29:38 <Fuuzetsu> same with strengthen…
09:29:40 <harwiltz> ertes-w: I feel like there's a way I can apply that fmap to my code, I just don't see how...
09:29:48 <Fuuzetsu> oh it's cast from typeable, not coerce, misread
09:29:58 <ertes-w> harwiltz: first apply the previous rule
09:30:19 <Myrl-saki> Fuuzetsu: I forgot to delete the bottom block. Those are 100% outdated.
09:30:31 <ertes-w> harwiltz: for all b, f, x, y: if b then f x else f y = f (if b then x else y)
09:30:37 <harwiltz> ertes-w: This is what I have right now: http://lpaste.net/357366
09:30:42 <Myrl-saki> Fuuzetsu: Check the middle commented block. The one above finiteSucc.
09:31:16 <ertes-w> harwiltz: yeah, now apply the rule i just mentioned…  you should be able to find the application site easily, because you only have one =)
09:31:50 <harwiltz> Yeah I know where I should apply it, I just can't seem to fit it properly...
09:32:06 <ertes-w> harwiltz: what's 'b' in the equation?
09:32:26 <ertes-w> in your case that is
09:32:36 <harwiltz> doesDirectoryExist
09:32:39 <ertes-w> harwiltz: nope
09:32:41 <harwiltz> *doesDirectoryExist path
09:32:45 <ertes-w> harwiltz: nope
09:32:48 <ertes-w> look at your code
09:33:16 <harwiltz> ertes-w: I think I get it now... I had the wrong application site I think
09:33:38 <harwiltz> Well b would be isDir, right?
09:33:42 <ertes-w> correct
09:33:44 <Fuuzetsu> I don't get the point of strengthen, you have S (S n) so you can produce (S n) guaranteed, why is there a Maybe? Can you post full corrected code and test case?
09:34:13 <harwiltz> ertes-w: Then f is my lambda function there, if isDir then ...
09:34:24 <Fuuzetsu> surely it should be Finite (S n) -> Maybe (Finite n) or something..
09:34:35 <Myrl-saki> Fuuzetsu: I tried that but it didn't type check.
09:34:36 <ertes-w> harwiltz: now that you have instantiated 'b = isDir' the rule specialises to:  for all f, x, y:  if isDir then f x else f y = f (if isDir then x else y)
09:34:41 <Myrl-saki> Fuuzetsu: I should try again.
09:34:54 <ertes-w> harwiltz: nope, just look at your code
09:35:11 <CrispyCookie> Hi. Is there a convention or recommendations that people would give me for naming the ADTs of my compiler written in Haskell to not confuse the types that are meant for the source language, as opposed to the compiler.
09:35:16 <ertes-w> harwiltz: try to find this pattern:  "if … then f … else f …"
09:35:42 <Myrl-saki> Fuuzetsu: Anyways. Answer to your question. `strengthen` is "remove the highest value"
09:35:46 <Fuuzetsu> CrispyCookie: you could use separate modules and import qualified
09:35:55 <harwiltz> ertes-w: Isn't that just whatever is in pure( )?
09:36:06 <Myrl-saki> Fuuzetsu: So, if you have `strengthen (2 :: Finite 2)`, you get Nothing.
09:36:06 <harwiltz> Lol nvm
09:36:09 * CrispyCookie feeds Myrl-saki
09:36:10 <ertes-w> harwiltz: f = pure
09:36:17 <ertes-w> harwiltz: anyway, you have already applied this rule =)
09:36:19 <Myrl-saki> Fuuzetsu: But `strengthen (1 :: Finite 2)`, results in 1.
09:36:22 <Myrl-saki> CrispyCookie: Thanks.
09:36:30 <harwiltz> ertes-w: Ok hahaha
09:36:31 <ertes-w> harwiltz: i didn't read correctly
09:37:01 <ertes-w> harwiltz: now apply this rule:  c >>= \x -> pure (f x)
09:37:08 <ertes-w> harwiltz: now apply this rule:  c >>= \x -> pure (f x) = f <$> c
09:37:35 <ertes-w> harwiltz: this one is a bit more tricky, because 'f' is a bit obscure
09:37:53 <harwiltz> ertes-w: I think I'm almost there...
09:38:04 <CrispyCookie> Fuuzetsu: Good call!
09:38:07 <Fuuzetsu> then it should be F (S n) -> Maybe (F n)…
09:38:20 <ertes-w> harwiltz: if you can't find 'f', try to *write* it and refactor your code to use 'f'
09:38:23 <ertes-w> instead of an inline 'if'
09:38:32 <harwiltz> Isn't it just going to be a lambda?
09:38:33 <Myrl-saki> Fuuzetsu: I think it doesn't type-check because of the `FZ` case.
09:38:39 <Fuuzetsu> I mean you could probably just copy Data.Finite pretty faithfully, just working on peano (for whatever reason)
09:38:44 <ertes-w> harwiltz: well, all functions are lambdas =)
09:38:45 <Myrl-saki> Fuuzetsu: FZ :: Finite (S n)
09:38:55 <harwiltz> like (\x -> if x then <> else <>) <$> doesDirectoryExist path
09:39:05 <ertes-w> harwiltz: yeah, exactly
09:39:15 <harwiltz> ertes-w: Awesome, gonna try typing that in now ;)
09:39:31 <Myrl-saki> Fuuzetsu: This also makes sense, because you can't strengthen a `:: Finite 1` (except to Void).
09:39:31 <ertes-w> harwiltz: use underscores as placeholders, because (<>) is an actual operator =)
09:40:07 <harwiltz> ertes-w: It worked ;)
09:40:12 <ertes-w> harwiltz: side note: GHC will actually let you do that…  those underscores are called typed holes, and GHC will actually tell you their type, if you try to load/compile the code
09:40:18 <harwiltz> and yeah, I noticed the <> thing right after sending it
09:40:31 <harwiltz> ertes-w: Thanks so much for the help
09:40:33 <ertes-w> harwiltz: example:  main = putStrLn _
09:40:56 <ertes-w> (you can use any identifier that starts with an underscore)
09:41:52 <harwiltz> Ah, I see
09:41:58 <dramforever> :t if 1 == 2 then "Hello" else _
09:42:00 <lambdabot> error:
09:42:00 <lambdabot>     • Found hole: _ :: [Char]
09:42:00 <lambdabot>     • In the expression: _
09:42:26 <Fuuzetsu> strength FZ = Nothing
09:42:34 <dramforever> See GHC says 'you gotta fill in a [Char] (aka String) there'
09:43:00 <ondrejs> Hello, I am trying to build xmonad but I am getting some linking problems https://gist.github.com/anonymous/ece887a7f605c5eaade4bba2c0cd88f0 Do you please know where do they come from/how to fix them? I have stack 1.5, lts-9.0 (tried downgrading to 8.20) and I am on Arch Linux.
09:43:32 <ertes-w> harwiltz: you can even use -fdefer-typed-holes to turn those holes into run-time exceptions…  the main purpose of that is reveal that "static typing means less freedom" is a load of bullshit =)
09:43:40 <harwiltz> Hahahaha
09:43:45 <ertes-w> (just joking…  it's genuinely useful)
09:43:47 <Fuuzetsu> ondrejs: there's also #xmonad where you may be able to get more help if you can't get any here
09:44:37 <ondrejs> Fuuzetsu: thank you, I'll try that 
09:45:16 <Guest43> How long before we get FunctorDo??
09:45:24 <dramforever> You already have
09:45:34 <dramforever> It's just called ApplicativeDo
09:45:55 <harwiltz> ertes-w: one last thing... I'm having trouble reading that last line that I wrote (the one with <$>). How is that supposed to be read/understood?
09:46:12 <ertes-w> f <$> c = c >>= pure . f
09:46:39 <ertes-w> harwiltz: if you prefer words: it's 'f' mapped over the content/result/whatever of 'c'
09:46:46 <ertes-w> the precise wording depends on the monad
09:46:52 <Hafydd> (<$>) = fmap
09:46:53 <harwiltz> ertes-w: Yeah, that helps :)
09:47:00 <ertes-w> harwiltz: in the case of IO you would say "result"
09:47:23 <ertes-w> well, to be super-pedantic:  it's the same effect as 'c', but with 'f' mapped over the result
09:47:28 <Myrl-saki> Blargh
09:47:42 <Myrl-saki> I wonder if KnownNat would help or something.
09:47:53 <harwiltz> Yeah, I get it now
09:48:10 <Fuuzetsu> isn't Data.Finite using KnownNat? I thought the exercise was to not use it.
09:49:04 <mniip> sometimes it's not possible
09:49:29 <mniip> it's using as little as possible, I think
09:49:54 <Myrl-saki> Fuuzetsu: Nah, I mean reimplementing KnownNat and the like with Peano numbers.
09:50:11 <Myrl-saki> mniip: I'm trying to implement `strengthen` using Peano numbers.
09:50:16 <mniip> e.g unshift doesn't use KnownNat
09:50:16 <Myrl-saki> mniip: This seems... impossible.
09:50:25 <mniip> Myrl-saki, yes
09:50:30 <mniip> you need to pi-quantufy over your nats
09:50:40 <mniip> which in haskell is only achievable with a singleton
09:50:47 <Myrl-saki> mniip: http://ix.io/yQJ
09:50:49 <mniip> i.e a typeclass constraint
09:50:53 <Myrl-saki> mniip: I am using a singleton
09:50:59 <Myrl-saki> mniip: Well, not exactly sure how.
09:51:16 <mniip> you need to recurse I think
09:51:39 <Myrl-saki> mniip: I tried recursing, but then the type messes with me.
09:52:19 <Myrl-saki> mniip: Rather. I either have an improperly-typed program or something that doesn't terminate.
09:53:05 <harwiltz> Is there any way I can simplify getCurrentDirectory >>= (\dir -> setCurrentDirectory $ dir ++ "/" ++ path)?
09:53:43 <mniip> how is your datatype represented?
09:53:56 <dramforever> :t </>
09:53:56 <lambdabot> error: parse error on input ‘</>’
09:54:03 <dramforever> :t (</>)
09:54:04 <lambdabot> error:
09:54:05 <lambdabot>     • Variable not in scope: </>
09:54:05 <lambdabot>     • Perhaps you meant one of these:
09:54:13 <Myrl-saki> mniip: http://ix.io/yQK
09:54:15 <dramforever> nope, not how it works...
09:54:17 <mniip> something like
09:54:17 <mniip> data Finite (n :: N) where FZ :: Finite (S n); FS :: Finite n -> Finite (S n)
09:54:28 <Fuuzetsu> getCurrentDirectory >>= setCurrentDirectory . (</> path)
09:54:30 <Myrl-saki> mniip: Yep. :P
09:54:43 <mniip> right, exactl
09:54:48 <harwiltz> Ah... thanks
09:54:51 <Myrl-saki> mniip: Though, `N` is also implemented by me
09:54:54 <Myrl-saki> mniip: (And not TypeLits)
09:55:02 <mniip> yeah, I can see that
09:57:43 <harwiltz> I'm getting an error with </>, not in scope
09:58:35 <Geekingfrog> harwiltz: did you import System.FilePath (from the filepath package) ?
09:58:50 <harwiltz> Geekingfrog: Nope, just did that now haha
10:01:25 <mniip> Myrl-saki, I think I got it
10:02:16 <Myrl-saki> mniip: Oh nice.
10:03:51 * hackagebot rethinkdb-client-driver 0.0.24 – Client driver for RethinkDB – https://hackage.haskell.org/package/rethinkdb-client-driver
10:04:18 <mniip> Myrl-saki, first define this
10:04:21 <mniip> @let strengthenI :: NI n -> Finite (S n) -> Maybe (Finite n); strengthenI ZI _ = Nothing; strengthenI (SI s) FZ = Just FZ; strengthenI (SI s) (FS k) = FS <$> strengthenI s k
10:04:23 <lambdabot>  Defined.
10:04:25 <mniip> then
10:05:03 <mniip> @let strengthen :: KnownN n => Finite (S n) -> Maybe (Finite n); strengthen = strengthenI singN
10:05:04 <lambdabot>  Defined.
10:06:13 <Myrl-saki> mniip: I think we arrived at a pretty similar idea.
10:06:39 <Myrl-saki> mniip: My idea was to "reverse the direction" of the finite then just use unshift.
10:06:47 <mniip> uhhhh
10:06:56 <Myrl-saki> Not sure if that's possible.
10:07:10 <mniip> I don't think that's going to be any easier than this straightforward recursion
10:07:27 <Myrl-saki> Yeah.
10:07:42 <Myrl-saki> I'll give it a try.
10:10:27 <mniip> Myrl-saki, I think if you write out the free theorem for the Finite (S n) -> Maybe (Finite n) type (without the constraint) you might find out why it's impossible to define such a function
10:11:20 <Myrl-saki> mniip: The free theorem?
10:11:44 <mniip> strengthen' FZ :: Maybe (Finite n)
10:11:47 <mniip> can only be a Nothing
10:12:12 <mniip> Myrl-saki, https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf
10:12:20 <mniip> I forget the exact rules myself but
10:12:27 <mniip> it must be continuous fsvo continuous
10:12:35 <mniip> I understand intuitively
10:13:51 <Myrl-saki> mniip: Maybe Void?
10:14:02 <Myrl-saki> Oh wait no.
10:14:09 <Myrl-saki> Yes?
10:14:18 <mniip> no
10:14:24 <mniip> it's not related to type algebra
10:14:32 <Myrl-saki> mniip: I'm following your naming. Don't you mean unshift?
10:14:38 <mniip> well only marginally
10:14:39 <Myrl-saki> `unshift FZ = Nothing`
10:14:53 <Myrl-saki> mniip: w.r.t. https://hackage.haskell.org/package/finite-typelits-0.1.2.0/docs/Data-Finite.html
10:14:57 <mniip> no I mean that the types dictate that:
10:15:09 <mniip> x :: forall (n :: N). Maybe (Finite n)
10:15:17 <mniip> x can only be Nothing
10:15:32 <Myrl-saki> mniip: Oh. Right.
10:15:54 <mniip> and if strengthen' had no constraint then strengthen' FZ would be that x
10:16:22 <Myrl-saki> mniip: Yeah.
10:16:42 <Myrl-saki> I see.
10:17:49 * hackagebot publicsuffix 0.20170802 – The publicsuffix list exposed as proper Haskell types – https://hackage.haskell.org/package/publicsuffix
10:18:09 <Myrl-saki> mniip: Okay.
10:18:36 <Myrl-saki> mniip: I'm seeing it now. That's why I'm showering with (S n) so that I can have an FZ.
10:18:44 <Myrl-saki> mniip: `strengthen :: SingI n => Finite (S (S n)) -> Maybe (Finite (S n))`
10:19:01 <mniip> uhhh
10:19:05 <mniip> my function is more general
10:19:43 <Myrl-saki> Oh wow.
10:19:47 <Myrl-saki> How does this typecheck?
10:19:49 <mniip> Myrl-saki, also it's not the FZ that is the problem
10:19:55 <mniip> it's the polymorphic recursion
10:20:05 <infandum> :t over each fromJust
10:20:07 <lambdabot> Each s t (Maybe b) b => s -> t
10:20:21 <mniip> the inner strengthen called from the last branch is under assumption that n ~ S m and it's called at that m
10:20:24 <infandum> Okay, so how come this doesn't work:
10:20:31 <infandum> over each fromJust (Just 3, Just "hi")
10:20:31 <infandum>  
10:20:54 <infandum> oh, nevermind haha
10:20:56 <infandum> same b
10:22:00 <infandum> Is there a functions such that f fromJust (Just 3, Just "hi") == (3, "hi")
10:22:11 <infandum> for an arbitrary tuple size
10:22:47 <Myrl-saki> mniip: Thanks.
10:22:52 <Myrl-saki> mniip: Like. A lot. Thanks.
10:23:32 <mniip> Myrl-saki, no big deal?
10:24:18 <mniip> by the way, anyone participating in the icfpc?
10:24:40 <Myrl-saki> mniip: This was actually what caused a type-checking failure though.
10:24:52 <Myrl-saki> strengthen :: SingI n => Finite (S n) -> Maybe (Finite n); strengthen FZ = Just FZ
10:25:15 <mniip> that's not strong enough
10:25:23 <mniip> you need to know n ~ S k
10:25:31 <mniip> see in my code I pattern match on SI in that branch
10:26:19 <Myrl-saki> mniip: Ohhh
10:27:09 <Myrl-saki> mniip: Anyways, this just made me realize that I most likely don't want my helper functions.
10:27:44 <Myrl-saki> http://ix.io/yQN
10:29:14 <Myrl-saki> mniip: This is actually interesting. I've been working with types to values, but not values to types.
10:30:09 <ongy> infandum: different tuple sizes have different types and don't have any nice typeclasses to unify them. But it's possible for lists (or with some TH)
10:30:16 <Myrl-saki> mniip: I'd even go as far and say that I didn't know that was possible lol
10:30:41 <infandum> ongy: But they aren't the same type, one is a Num and the other is a String
10:30:45 <mniip> ongy, lens has the typeclasses iirc
10:30:52 <mniip> hence each
10:30:58 <ongy> lens has everything it seems
10:31:06 <mniip> > over each (+1) (3, 5, 7)
10:31:08 <lambdabot>  (4,6,8)
10:33:11 <infandum> Yeah, but only with the same type
10:33:24 <infandum> over each fromJust (Just 3, Just "hi")
10:33:34 <infandum> > over each fromJust (Just 3, Just "hi")
10:33:36 <lambdabot>  error:
10:33:36 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘3’
10:33:36 <lambdabot>      • In the first argument of ‘Just’, namely ‘3’
10:33:38 <infandum> there
10:34:09 <infandum> Maybe isn't good enough, because it's Maybe a and the a must agree
10:35:32 <infandum> :t beside
10:35:33 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f, Applicative (Data.Profunctor.Rep.Rep q), Data.Profunctor.Rep.Representable q) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f
10:35:34 <lambdabot> (r s s') (r t t') a b
10:35:42 <infandum> That's close to perfect, but it only works for two
10:35:46 <infandum> not arbitrary length
10:38:22 <mniip> huh
10:38:25 <mniip> how did this happen
10:38:33 <mniip> can't load .so/.DLL for: (.../lib/ghc-8.3.20170519/rts/.: cannot read file data: Is a directory)
10:38:56 <mniip> I am using -dynload deploy, and that dir is in my LD_LIBRARY_PATH, but why is it reading "."
10:43:23 * hackagebot fay-base 0.21.0.0 – The base package for Fay. – https://hackage.haskell.org/package/fay-base
11:41:10 * hackagebot matterhorn 40000.0.2 – Terminal client for the Mattermost chat system – https://hackage.haskell.org/package/matterhorn
12:03:07 <sqooq> Hier ich bin
12:05:05 <shapr> sqooq: god afton!
12:05:26 <shapr> hur mår du idag?
12:05:43 <sqooq> what is that
12:05:48 <sqooq> dutch?
12:05:51 <shapr> nah, Swedish
12:05:52 <Tuplanolla> Swedish, it looks like.
12:05:53 <sqooq> o
12:06:04 <sqooq> @shapr
12:06:04 * lambdabot smacks  about with a large trout
12:06:12 <shapr> minä en puhu suomea!
12:06:25 <sqooq> you were trying to help me with my parser yesterday right?
12:06:27 <Chousuke> :P
12:07:05 <shapr> maybe
12:07:24 <shapr> but I think Cale was actually giving you help while I was instead writing work code
12:07:46 <sqooq> I think Cale helped a bit, but geekosaur was too
12:07:50 <sqooq> I'm stumped
12:08:09 <Cale> Maybe not yesterday
12:08:23 <Cale> Wasn't that a couple days ago? :)
12:08:30 <sqooq> possibly
12:08:37 <sqooq> i've lost track of time at this point
12:08:42 <shapr> sounds like my life
12:09:13 <sqooq> I'm trying to parse brackets which represent trees
12:09:20 <Cale> I'm currently trying to cherry pick a bunch of commits to GHC, time is going very slowly
12:09:28 <sqooq> but because the options necessary are different depending on what has been parsed
12:09:55 <sqooq> I would think I need if statements or something equivalent, but if requires bool and I can't get my parsers to work with bool
12:10:05 <sqooq> unless perhaps I make them an instance of Eq
12:10:23 <Fuuzetsu> show code
12:10:42 <Cale> sqooq: Well, (>>=) fundamentally gives you the ability to decide how to parse what follows from what was parsed before
12:10:53 <Cale> sqooq: That's exactly a description of what it is :)
12:10:53 <zoey> any cool online interactive haskell tutorials? i did tryhaskell (which was cool, but less functional than the learngolang thing)
12:11:13 <sqooq> sqooq yeah but >>= fails if one thing fails
12:11:27 <sqooq> so I can't do something like "if this parser fails now do these"
12:11:28 <ertes-w> zoey: pick any programming challenge and do it in haskell
12:11:35 <sqooq> because once it fails [] is returned
12:12:01 <erisco> that is what <|> is for, or mplus
12:12:10 <ertes-w> zoey: or even write something you would actually find useful
12:12:46 <sqooq> I have <|> as well
12:12:58 <sqooq> but maybe I'm misunderstanding things
12:13:17 <zoey> ertes-w, i am doing that actually
12:13:17 <erisco> there are only two fundamental operators in executable grammars (parser combinators, whatever)
12:13:17 <sqooq> but if char fails, it's going to parse the next thing and then still jsut move on the same following code no?
12:13:28 <zoey> ertes-w, but i find guided study very useful too
12:13:30 <sqooq> char is my character check btw
12:13:34 <sqooq> http://lpaste.net/357369
12:13:36 <zoey> i like to do as many approaches at once as possible
12:13:37 <zoey> :3
12:13:46 <erisco> there is "this then that", usually <*>, and "this or that", usually <|>
12:14:03 <ertes-w> zoey: yeah, i understand, but unfortunately i don't think there is a lot of those available
12:14:14 <sqooq> <*> is applicative right?
12:14:20 <sqooq> I don't know what it does at all
12:14:24 <sqooq> OMG
12:14:36 <sqooq> wait
12:14:36 <erisco> so I just call them "then" and "or" respectively... so you have  S ::= aS | a  which is read as "S is an ('a' THEN S) OR is an 'a'"
12:14:58 <ertes-w> you should call it "and" rather than "then"
12:15:10 <erisco> and implemented as  S = char 'a' <*> S <|> char 'a'  usually
12:15:36 <ertes-w> (<*>) and (<|>) are surprisingly ring-like, and conjunction/intersection and disjunction/union form a ring
12:15:44 <ertes-w> or perhaps unsurprisingly
12:16:25 <erisco> uh, well <*> isn't going to work like that...
12:16:25 <erisco> f <$> char 'a' <*> S  and some f ni there
12:16:25 <erisco> ertes-w, no, because "then" is not commutative
12:16:38 <ertes-w> erisco: s/ring/semiring,
12:16:39 <ertes-w> /
12:16:42 <erisco> and with some parsers "or" is not commutative either, but ideally it is
12:16:56 <sqooq> the path for <|> is the same for each argument
12:17:02 <erisco> well, that's great... "and" suggests commutative to me and "then" does not, so I call it "then"
12:17:03 <sqooq> i don't think that helps me
12:17:14 <sqooq> right?
12:18:10 <erisco> if you don't know how to use <*> yet then I'd figure that out well before tackling >>=
12:18:21 <sqooq> me?
12:18:27 <erisco> you :)
12:18:33 <sqooq> I've tacked >>= long ago
12:18:37 <sqooq> tackled*
12:18:48 <erisco> for parser combinators?
12:18:53 <sqooq> yup
12:19:02 <sqooq> http://lpaste.net/357369
12:19:05 <erisco> okay then I guess I missed the question
12:19:08 <sqooq> I understand how it works
12:19:14 <sqooq> or at least I hope I do
12:19:18 <sqooq> lmao
12:19:27 <sqooq> I've gone through it many times step by step understanding how it works
12:19:53 <sqooq> it literally just performs a series of computations one by one, optionally storing their results, and if one fails they all fail
12:20:04 <ertes-w> sqooq: fs <*> xs = fs >>= (<$> xs)
12:20:14 <ertes-w> = fs >>= \f -> xs >>= \x -> pure (f x)
12:20:29 <ertes-w> = do f <- fs; x <- xs; pure (f x)
12:20:43 <sqooq> pure is = to return ja?
12:20:49 <ertes-w> ja
12:20:55 <erisco> sqooq, well when you say you have no idea what <*> does then there is a big hole in your understanding of parser combinators
12:21:04 <erisco> sqooq, as I said, <*> and <|> are your fundamental operations
12:21:20 <sqooq> well the paper I read didn't mention it at all
12:21:30 <sqooq> and asking for help in here for days
12:21:33 <sqooq> no one once mentioned it
12:21:39 <sqooq> i don't think...
12:21:42 <ertes-w> sqooq: Applicative is rather new compared to Monad
12:22:05 <sqooq> Monad is a subset of Applicative right?
12:22:05 <erisco> that's okay... my former prof who has a specialty in parsing agrees with me here, and he writes papers too :P
12:22:31 <erisco> in terms of how many instances there are, yes
12:22:34 <ertes-w> sqooq: every Monad is an Applicative, much like every group is a monoid
12:22:42 <sqooq> hai
12:23:55 <ertes-w> also you could argue about which operations are really fundamental to parsing…  (>>=) becomes more powerful than (<*>) at infinity
12:24:24 <erisco> you only need <*> and <|> to parse CFG
12:25:07 <sqooq> ok I will learn
12:25:09 <ertes-w> i wish we would live in such a beautiful world, where every grammar is context-free =)
12:25:11 <sqooq> thanks
12:25:31 <ertes-w> where crap like XML doesn't exist
12:26:44 <erisco> haha, well, I think it is a good starting point just because it is simpler and doesn't impede you from adding >>= later
12:26:50 <nm_> how can i make sure that programs installed by cabal-install are  on my shell's search path.
12:27:05 <ertes-w> nm_: add the installation path to your PATH
12:27:53 <nm_> ertes-w: please bear with me as i am new. What is the installation path?
12:28:04 <ertes-w> nm_: unless you use sandboxes and/or a custom configuration cabal-install installs into ~/.cabal/bin
12:28:55 <sqooq> i already have <*> btw
12:28:57 <nm_> i have added ~/.cabal/bin to my .bashrc file
12:29:09 <nm_> ertes-w: 
12:29:18 <sqooq> idk how to use it thoguh
12:29:35 <ertes-w> nm_: keep in mind that it only takes effect for new shells
12:29:38 <erisco> I suppose I should caveat that you can't take any CFG and translate it directly as an executable grammar because due to left recursion
12:30:00 <erisco> but there is an equivalent right recursive grammar for every left one, so it isn't a big deal
12:31:26 <erisco> I came up with a couple extra operators and a little method to do the refactor more or less easily by hand
12:32:04 <erisco> and the parse tree comes out with left association
12:33:24 <erisco> also if you have weird grammars like S -> S then that aint going to work either
12:33:56 <Niamkik> Hi everyone! I have a question about Concurrency/Parallel programming and Queue in Haskell, what library or package you prefer to make concurrent queue? I've see kazura queue... What do you think about that?
12:34:18 <ertes-w> Niamkik: the base library has MVar and Chan
12:34:47 <ertes-w> Niamkik: other than that the library i typically go for is stm, which has a bunch of them:  TBQueue, TChan, TMVar, TQueue
12:34:52 <Franciman> Hello
12:35:01 <marcusklaas> Hi y'all
12:35:01 <Fuuzetsu> I like unagi-chan too
12:35:11 <ertes-w> Niamkik: you should read The Book
12:35:15 <ertes-w> @where The Book
12:35:17 <Franciman> If I want to have a javascript engine in my desktop program, (In order to execute js plugins for my program) is jsaddle good for it?
12:35:23 <Niamkik> ertes-w: is Concurrent.Chan is safe for concurrency?
12:35:25 <ertes-w> Niamkik: http://chimera.labs.oreilly.com/books/1230000000929/
12:35:47 <Niamkik> ertes-w: Yeap, I have it :)
12:35:52 <ertes-w> Niamkik: if the word "concurrent" appears in the module name, you can pretty much assume that it's safe
12:36:16 <Fuuzetsu> I find that unless module says in big letters something is not thread safe, it's usually thread safe
12:36:33 <erisco> sqooq, I have my undergrad paper I wrote years ago on developing a CFG parser in Haskell... if you can believe it I was even more simple then than now, so it should be an easy time
12:36:40 <ertes-w> yeah, for example Data.IORef is clearly not thread-safe from the module name
12:36:45 <ertes-w> similarly Data.Vector.Mutable
12:36:55 <sqooq> erisco, it's alright
12:36:55 <Niamkik> ertes-w: I was thinking to see in another place, but yeah, I wasn't thiking about Concurrent.Chan...
12:37:01 <Niamkik> ertes-w: thanks! :)
12:38:00 <sqooq> I don't understand how <*> is used
12:38:06 <marcusklaas> Any idea on how to decode a json structure like this using Aeson?    { "aString": "{\"nestedJson\": \"foo\"}" }
12:38:08 <marcusklaas> My current parseJSON does
12:38:08 <ertes-w> Niamkik: concurrency is fairly well integrated into all of (GHC-) haskell =)
12:38:10 <erisco> well, read the paper... :P
12:38:10 <marcusklaas> aString <- o .: "aString"
12:38:12 <marcusklaas> innerObj <- parseJson aString
12:38:14 <marcusklaas> , but that fails on the example json object above. It does compile, however.
12:38:27 <sqooq> since it requires the result of the first argument to be a function
12:38:32 <erisco> sqooq, I start from the bare bones "what is parsing" and incrementally work up to the complete parser
12:38:56 <sqooq> I mean I guess it won't hurt if you want to send it
12:39:12 * erisco *squee* someone wants to read my work
12:39:36 <ertes-w> sqooq: you know how 'fmap' takes one action and maps a function over its result…
12:39:42 <sqooq> yes
12:39:46 <ertes-w> sqooq: Applicative generalises this to multiple actions
12:39:48 <ertes-w> :t liftA2
12:39:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:40:00 <ertes-w> you can write liftA2 in terms of (<*>) and 'pure'
12:40:07 <ertes-w> (or (<*>) and (<$>))
12:40:13 <sqooq> ok
12:40:13 <erisco> sqooq, https://github.com/erisco/acrid-parser/blob/master/doc/paper.pdf
12:40:38 <ertes-w> sqooq: compare the type signatures of 'fmap', 'liftA2' and 'liftA3'
12:40:54 <ertes-w> sqooq: in practical terms that's pretty much all there is to it (until you introduce Alternative)
12:44:57 <ertes-w> sqooq: given grammars c1, c2 and c3 with results x, y and z respectively you would like to put those in sequence and return (f x y z), a combination of the individual results
12:45:05 <ertes-w> liftA3 f c1 c2 c3
12:45:18 <ertes-w> or in terms of (<*>):  pure f <*> c1 <*> c2 <*> c3
12:45:31 <ertes-w> = f <$> c1 <*> c2 <*> c3
12:46:07 <ertes-w> combine that with (<|>) to get choice for individual components:  liftA3 f c1 (c2a <|> c2b) c3
12:47:33 <Spriithy> Hey there !
12:48:58 <byorgey> hi Spriithy, welcome
12:49:22 <sqooq> does <*> it takes requires a wrapped function, and a wrapped thing, and returns the function applied to the result of the wrapped thing
12:49:36 <sqooq> let me rewrite that
12:50:13 <sqooq> does <*> take a wrapped function and a wrapped thing, and returns the function applied to the result of the wrapped thing?
12:50:28 <ertes-w> yes
12:50:36 <ertes-w> follow the types:  f :: A -> B -> C -> D;  c1 :: F A;  c2 :: F B;  c3 :: F C
12:50:43 <sqooq> ok my problem is when would you have a wrapped function
12:50:47 <ertes-w> pure f :: F (A -> B -> C -> D)
12:50:51 <sqooq> in the context of parsing
12:51:01 <ertes-w> pure f <*> c1 :: F (B -> C -> D)
12:51:09 <ertes-w> (pure f <*> c1) <*> c2 :: F (C -> D)
12:51:18 <sqooq> hmm
12:51:19 <ertes-w> ((pure f <*> c1) <*> c2) <*> c3 :: F D
12:51:40 <ertes-w> and (<*>) is infixl, so:
12:51:47 <ertes-w> = pure f <*> c1 <*> c2 <*> c3
12:52:20 <mniip> and 'pure f <*> x' = 'f <$> x'
12:52:34 <ertes-w> sqooq: in other words: you initially wrap the function yourself deliberately, and then you can keep applying the partially applied function to more and more actions
12:52:47 <sqooq> yes
12:53:05 <ertes-w> s/actions/actions' results/
12:53:16 <sqooq> <$> is the same thing as fmap?
12:53:24 <ertes-w> yes
12:53:26 <danilo2> Hello guys! :) I was using Parsec'like parsers in the past, now Im uing attoparsec for the first time and it works a little strange. Is it its bug (I suspect not) that when I use `takeWhile` nothing gets parsed, but If I replace it to `takeWhile1` some chars are getting parsed? (this is the only change I do)
12:54:37 <ertes-w> danilo2: it might interact weirdly with something that comes *after* the takeWhile…  one major difference between parsec and attoparsec is that the latter has backtracking built into (<|>)
12:54:49 <ertes-w> although i can't think of any examples
12:55:36 <danilo2> ertes-w: hmm, maybe it is connected to the fact that I connected it to conduit ?
12:55:38 <erisco> are there any examples of a deeply embedded language which, due to limitations of Haskell types, embeds some additional type information as Haskell terms?
12:55:46 <Spriithy> I have a question. Quite philosophical actually. I am a Cloud Engineer at a pretty large Big Data company and have always worked with imperative languages such as C, Python and the like. I have quite often tried in vain to start off with Functional languages like Lisp, Scheme or Haskell. But never got a really good grasp at it. Until recently (a couple weeks) I have dedicated most of my work time to learning Haskell and I must say
12:55:56 <danilo2> ertes-w: thanks for pointing the backtracking in (<|>). It probably saved me form scratchin my head 
12:56:11 <Spriithy> I wonder why I will almost never have the chance to use it for production ready services ...
12:56:14 <erisco> Spriithy, you are cut off at "I must sa" on my client
12:57:07 <Spriithy> erisco: I must say I love it. Yet I wonder why ... 
12:57:18 <Spriithy> and the rest is in the 2nd message
12:57:32 <Fuuzetsu> how do you know you won't have a chance to use it?
12:57:49 <erisco> not sure what the philosophy is... your company doesn't use Haskell and so you won't be able to use Haskell in production
12:57:55 <Spriithy> Well, I don't see it fit in the environments we use & pipelines we have
12:58:18 <Spriithy> erisco: I overthought it I think x)
12:58:30 <sqooq> ok I understand it now
12:58:40 <erisco> work at a company that does use Haskell and you will use Haskell for production ;)
12:58:43 <Fuuzetsu> then there's nothing to wonder about, time to change workplace or try to convert some stuff; there are things like sparkle and inline-r and inline-java that you can start from, you don't have to convert whole company over on day one..
12:59:11 <Spriithy> Oh and, I always have this strange feeling I am doing everything bad in Haskell
12:59:18 <erisco> you are
12:59:23 <Spriithy> Although I got quite a good grasp of the Functional spirit
13:00:53 <erisco> though it is partly in the eye of the beholder... no one enjoys their own work
13:01:03 <danilo2> ertes-w: hmm, ok Im sure something is broken when using takeWhile and conduit (official conduit attoparsec bindings)
13:01:25 <Spriithy> erisco: can one consider Haskell a general purpose language ?
13:01:31 <danilo2> ertes-w: This code prints infinite empty stream `main = runConduitRes $ sourceFile "/tmp/input.txt" .| decodeUtf8C .| conduitParserEither (takeWhile (<'5')) .| printC` 
13:01:33 <Fuuzetsu> I enjoy my work; most of the time anyway…
13:01:45 <danilo2> ertes-w: bu if I replace the takeWhile with takeWhile1 it actually parses fine
13:01:48 <Fuuzetsu> not recently but should be back to enojying it in few weeks…
13:01:51 <Spriithy> I did enjoy my work before meeting Haskell
13:01:56 <erisco> don't use it for hard real time or for low memory devices, but otherwise sure, I think so
13:01:56 <Spriithy> Now I wonder ...
13:02:58 <marcusklaas> Hey folks! How would one decode a 'nested json string' using Aeson? For example { "aString": "{\"nestedJson\": \"foo\"}" }
13:03:12 <danilo2> Did anybody use attoparsec  and conduit and could tell me if something is wrong in this code? `main = runConduitRes $ sourceFile "/tmp/input.txt" .| decodeUtf8C .| conduitParserEither (takeWhile (<'5')) .| printC` ? It works If I replace takeWhile with takeWhile1, otherwise it prints infinite empty parse results
13:04:10 <erisco> actually the my own work I enjoy the most is the stuff I already know crappiness is part of the design
13:06:17 <erisco> sometimes you'd think I wasn't a native speaker
13:08:46 <harwiltz> Hello all. I defined a data type that has multiple parameters, like data MyType = MyType Int [Char], for example. Is there any way I can make make a Functor instance for that type?
13:09:08 <Fuuzetsu> your particular type is not a functor so no
13:09:10 <erisco> harwiltz, no, because Functors have kind * -> * and MyType :: *
13:09:19 <bbear> Hi, I have sort of a short question.
13:09:31 <bbear> Does ghci runs as fast as compiled haskell code ?
13:09:33 <Fuuzetsu> no
13:09:46 <glguy> erisco: What client are you using? It looks like it cut the long chat message off one more character than necessary. I'm curious if the code counted a null terminator against the length of the message
13:09:53 <erisco> in fact ghci can be amazingly slower with some libraries
13:10:07 <Fuuzetsu> glguy: I'm glad I wasn't the only person to have seen that…
13:10:25 <erisco> glguy, HexChat 2.12.1
13:11:05 <harwiltz> erisco: Oh yeah... that's true :D
13:11:43 <harwiltz> Is there some sort of type class that allows me to map over MyType?
13:11:52 <erisco> what do you mean by map?
13:12:38 <bbear> but in some case it is as fast as compiled code, right ?
13:12:45 <bbear> I mean in most standard case ?
13:12:51 <bbear> I didn't notice so much difference.
13:12:59 <Fuuzetsu> in rare case at best
13:13:32 <bbear> I mean for brute-force looping...
13:13:46 <harwiltz> erisco: Let's say I have data MyType = MyType Int Int Active, with data Active = A | B. Now I wanna apply a function that takes an Int to MyType, so I'd have (some map) f MyType a b A = MyType (f a) b A, for example
13:14:05 <bbear> oh by the way imagine i'm doing a computation and I stor the result in a variable
13:14:15 <Fuuzetsu> I suspect ghci to never run in comparable code to compiled code with optimisations in that case unless your code is very weirdly unoptimisable
13:14:18 <erisco> bbear, ghci uses no optimisations. Hard to imagine how it would compete with anything optimised
13:14:23 <bbear> then I display that variable. It means the code will be executed.
13:14:29 <Fuuzetsu> in comparable time*
13:14:36 <bbear> if I call back the variable, the computation is not repeated, right ?
13:15:01 <Fuuzetsu> it is not
13:15:16 <bbear> I mean if I do pi=(complicatedComputationThatTakesALongTime)
13:15:25 <Spriithy> Could haskell be good for Machine Learning ?
13:15:29 <bbear> then I just recall it after and it's ok
13:15:33 <erisco> harwiltz, probably lens can help you, but I am not a lens guy
13:15:37 <bbear> Spriithy: I think as good as anything.
13:15:52 <harwiltz> erisco: I've never heard of lens... I'll take a look. Thanks
13:16:02 <Spriithy> bbear: just that there probably are not as much resources as in python  
13:16:24 <Fuuzetsu> harwiltz: or just use records (which you'll want with lenses anyway) and use record update in place/helper
13:16:44 <Fuuzetsu> lens will basically give you many helpers for such things that you can do cool convenient things with
13:17:15 <bbear> Spriithy: Haskell is not really useful except if you want to use Haskell I'd say. It's a self-rewarding experience I'd say but it can be frustrating.
13:17:21 <harwiltz> Fuuzetsu: Hmm... I'm using records in another data type, but can you do pattern matching with records?
13:17:34 <Fuuzetsu> bbear: that sounds pretty subjective…
13:17:51 <bbear> You can do amazing stuff in Haskell but it's not your bread and butter pile packed inside generic purpose scripting language
13:18:00 <bbear> s/pile/battery
13:18:03 <erisco> there are businesses making money with Haskell. Don't say it is not useful!
13:18:14 <Fuuzetsu> mapInt f m(MapType { intRecord = i }) =  m { intRecord = f i }
13:18:26 <Clint> making money is only useful if making money is useful
13:18:26 <bbear> I'd say it's useful if you use it for something useful.
13:18:27 <Fuuzetsu> mapInt f m@(MapType { intRecord = i }) = m { intRecord = f i } -- correction
13:18:37 <erisco> I don't require "making money" in "useful", but seems many do
13:19:38 <bbear> making money is not totally void of usefulness but it can be alienating I think when you come to think of it with some distant perspective.
13:19:58 <bbear> At least it can provides some commodities
13:20:13 <bbear> but that's off-topic
13:20:20 <harwiltz> Fuuzetsu: huh, alright. Thanks. I'll look into that
13:20:50 <bbear> well machine learning with Haskell must be pretty awesome
13:20:58 <bbear> I'd love to see that.
13:21:50 <bbear> how do you multithread a program in Haskell ?
13:21:53 <Fuuzetsu> we have a project for that on-going right now
13:21:58 <Fuuzetsu> (ML/AI thing)
13:22:09 <Fuuzetsu> :t forkThread
13:22:10 <lambdabot> error: Variable not in scope: forkThread
13:22:19 <Fuuzetsu> well; but that and all the other libs…
13:22:24 <bbear> yes
13:22:26 <bbear> ok
13:22:32 <erisco> so... has anyone thought to embed types as terms with their eDSLs?
13:23:01 <bbear> I think the ecosystem must not be as mature as for other languages but still haskell is awesome.
13:23:20 <mniip> quiz: if a haskell bot could do IO, what modules should be in scope
13:23:28 <Spriithy> erisco: how do you mean?
13:23:32 <Fuuzetsu> I'm a bit confused about your somewhat wide-sweeping conclusions after asking what are basically fundamental questions…
13:23:34 <mniip> (I mean a haskell repl bot)
13:24:07 <Fuuzetsu> depends on your security policy…
13:24:10 <erisco> usually you just use Haskell types for your eDSL types, but say Haskell's types are not powerful enough, what then?
13:24:14 <mniip> assume none
13:24:22 <drw77> 'c <- connectPostgreSQL <connection string>' works in a compiled executable, but when I run it in ghci, I get a Windows error "ghc.EXE has stopped working".  Is there a way to make it work in ghci as well?
13:24:24 <Fuuzetsu> then any module user wants
13:24:37 <mniip> right but it would be useful to have some imported by default
13:24:43 <frankpf> hey, I'm trying to write to a file and I'm using this SO answer: https://stackoverflow.com/a/10801938
13:24:49 <mniip> say, System.Directory or Data.IORef
13:25:00 <frankpf> `stack build` errors with " Failed to load interface for ‘System.IO.Strict’"
13:25:04 <Fuuzetsu> Prelude; directory; filepath; System.IO; MVar, IORef, …
13:25:06 <frankpf> do I have to add anything to my build-depends?
13:25:13 <Fuuzetsu> just let user import
13:25:27 <erisco> I suspect the number of examples of people doing this is zero...
13:25:41 <Fuuzetsu> frankpf: presumably ‘strict’ package
13:27:17 <Fuuzetsu> frankpf: though depending on what you're doing it may be much better to understand why the "naive" way doesn't work, how to make it work, how to make it work efficiently &c.…
13:28:03 <frankpf> Fuuzetsu: I'm a beginner in Haskell
13:28:19 <frankpf> Fuuzetsu: the "putStrLn" solutions seem like a hack
13:29:01 <Fuuzetsu> frankpf: it is; there's a more in-depth answer at the top, the accepted one
13:30:42 <mniip> ok
13:30:48 <mniip> let's try this
13:31:17 <sqooq> erisco
13:31:30 <erisco> sqooq
13:31:39 <sqooq> A -> [ A ] | val 
13:31:41 <sqooq> val -> digit Val | digit
13:31:55 <sqooq> is that correct backusnaur for something like "[ [ 3 4 ] 3 4 ]
13:32:01 <sqooq> woops
13:32:24 <sqooq> notwoops
13:32:27 <frankpf> Fuuzetsu: I just looked up `seq` and that answer still seems like a hack
13:33:06 <erisco> that is not proper BNF syntax, no, because BNF uses "::=" rather than "->"
13:33:07 <Fuuzetsu> frankpf: sorry to disappoint but it's exactly what strict package does
13:33:14 <Fuuzetsu> hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
13:33:15 <frankpf> Apparently I could change "length contents" to any function involving contents
13:33:36 <sqooq> erisco lmao
13:33:39 <frankpf> would "id contents" work for example?
13:33:42 <erisco> but I have a habit of writing "->" too
13:33:56 <sqooq> either way is the grammar right?
13:34:07 <erisco> it is easy to verify... find a parse tree
13:34:08 <Fuuzetsu> the idea is to actually use the content, forcing it to be read out from the file; for example, to calculate the length of the content, we have to read it all out, that's why it works; we use seq to make sure we do that before we try to do something else to do the file
13:34:08 <mniip> sqooq, no
13:34:23 <mniip> sqooq, that only parses [^i digit^j ]^i
13:34:39 <erisco> get out a piece of paper, write  [ [ 3 4 ] 3 4 ]  at the bottom of it, and try and find the parse tree for it
13:34:51 <sqooq> lolol
13:34:55 <sqooq> i have no clue what a parse tree is
13:34:58 <erisco> space out all the characters as much as you can so you have enough room for the tree
13:35:06 <frankpf> Hmm. Wouldn't any pure function involving contents work?
13:35:18 <mniip> Fuuzetsu et al take a minute to look at this awesome ghci bot that lets you do ghci stuff
13:35:19 <frankpf> The documentation says that seq is "magically strict" in its first argument
13:35:29 <sqooq> erisco, or actually I do, but only in the context of english
13:35:32 <mniip> % 3 + 5
13:35:35 <yahb> mniip: 8
13:36:19 <erisco> sqooq, okay, well, parse trees are rudimentary to parsing, it would be good to read on what one is
13:36:28 <frankpf> `id contents` would also force the whole file to be read out, no?
13:36:33 <sqooq> ugh if only I knew
13:36:38 <Fuuzetsu> frankpf: no; for example function that does not do anything with content will not work; http://lpaste.net/6173917446781534208
13:36:38 <sqooq> the kind of rabbit hole I jumped into
13:36:45 <sqooq> with this seemingly simple project
13:36:53 <sqooq> I wouldn't have started
13:37:08 <sqooq> I think at this point i'm just willing to pay someone to make the program for me
13:37:19 <erisco> but by the end you'll know what a parse tree is, so that's a bonus
13:37:52 <sqooq> btw I do know parse trees
13:38:00 <sqooq> but I have no clue how to make one for non english
13:38:08 <sqooq> I read a few chomsky paper's
13:38:20 <sqooq> on bare phrase structure and X bar theory
13:38:30 <erisco> English is a natural language... we're way simpler here with just a CFG
13:39:12 <erisco> okay, here is roughly how it goes... and you can add layers to the onion as you wish but this is the basics...
13:39:17 <frankpf> Fuuzetsu: I see. So the function has to do *something* with its argument to force it to be available to the 2nd arg of seq
13:39:20 <Fuuzetsu> ‘id’ is not quite enough, it doesn't fully read the content, all the way until it can close the file; length works because we traverse over _everything_; ‘id x `seq` …’ is no better than ‘x `seq` …’
13:39:53 <erisco> you have regular languages at the bottom, then context-free languages, then context-sensitive languages, then recursively enumerable languages
13:39:56 <Fuuzetsu> frankpf: yes, we're basically forcing lazy I/O to yield by requesting the content because we want to do something;
13:40:17 <sqooq> chomsky's hierarchy 
13:40:20 <sqooq> ja
13:40:27 <erisco> yes, and we're only at context-free
13:40:40 <frankpf> Fuuzetsu: ah, I think I get it now
13:40:59 <frankpf> so take 2 contents would only make the first 2 characters available
13:40:59 <Fuuzetsu> if you do nothing with the content, nothing will be requested; if you just do a little bit, only a chunk may be requested… really it's ugly, you're right that it looks like a hack, because it sort of is; there are explicit streaming libraries available which give you back the control over this sort of stuff
13:41:30 <erisco> you can just skim through Wikipedia for CFG and see some examples of parse trees https://en.wikipedia.org/wiki/Context-free_grammar
13:42:01 <erisco> if there is a parse tree for a sentence, it is in the language
13:42:33 <erisco> and playing with the parse trees gives you a good intuitive sense of what language the grammar is describing
13:43:03 <frankpf> Fuuzetsu: thanks. I don't think I'm at the point where I should use or even would be able to understand libraries like conduit & pipes but I'll definitely keep that in mind
13:43:28 <Spriithy> I was wondering, I see a lot of non left recursive parsers... are there some ways to overcome that without modifying the grammar ? an algorithm maybe ?
13:43:35 <Spriithy> doable in Haskell I mean
13:43:45 <Fuuzetsu> sure thing; as long as you understand what the problems are, one day you'll seek them out (or re-invent!) yourself
13:44:09 <erisco> Spriithy, parser combinations are top down (all the ones I have seen) and that inherently will not jive well with left recursion
13:44:17 <sqooq> the tree comes from the recursion right
13:44:28 <erisco> Spriithy, there are things you can do, like limiting recursion depth, but it gets janky
13:45:06 <Spriithy> So *the* way is to just remove Left recursion
13:45:26 <erisco> sqooq, the tree comes from the grammar... the nodes are the terminals and non-terminals, and children are a production
13:46:43 <sqooq> ok
13:46:48 <erisco> Spriithy, I think you can figure out a maximum recursion depth beyond which you know to reject the sentence
13:47:20 <Spriithy> Yeah, but I believe that tracking this sort of info is just polluting the program
13:47:23 <Spriithy> isn't it ?
13:47:37 <erisco> I called it janky because yeah, that is how it feels to me
13:48:09 <erisco> consider  S -> Sa | a  then given a length of sentence you know how many left recursions it makes sense to try before rejecting it
13:48:12 <sqooq> but you'll only get a new branch if it's a nonterminal
13:48:14 <sqooq> right?
13:48:43 <sqooq> in the example S ::= S + S , a new tree can start for both those S's
13:48:48 <erisco> because for every time you recurse left on Sa you know you have to find some 'a' later, so if the sentence you are parsing has length n then it does not make sense to try any more than n productions of Sa
13:48:49 <sqooq> a new branch rather
13:49:18 <erisco> sqooq, that is right, you will have a subtree for each
13:50:21 <Spriithy> I am sure, mankind is missing something about parsers 
13:50:41 <sqooq> crap my grammar is wrong then
13:50:56 <erisco> there is lots to tweak with parsers, sure ... many possible implementations out there
13:51:08 <sqooq> it can't handle [ [ 1 2 ] 3 ]
13:53:43 <sqooq> aha my actual grammar never has [ [ ] ]
13:54:13 <sqooq> and it will never have [ 1 ] either
13:54:16 <sqooq> it's redundant
13:54:29 <sqooq> btw you won't understand, i'm proclaiming it 
13:55:00 <sqooq> comes from http://musicnotation.org/wp-content/uploads/2013/03/Gould_Equiton_Slides.pdf
14:07:33 <sqooq> wow this is actually pretty hard
14:08:03 <sqooq> I have to do infinite recursion but with the requirement of at least 2
14:10:51 <sqooq> I created something that I think works but there's a slight problem
14:10:59 <sqooq> T ::= [ val val ]
14:11:07 <sqooq> val ::= T | sym Val | sym
14:11:44 <bbear> do you know of another language with awesome operators like Haskell ?
14:11:48 <sqooq> the problem is that if you have sym sym, is that considered val val (within a T), or sym Val
14:12:26 <sqooq> bbear: this is BNF
14:12:30 <bbear> https://hackage.haskell.org/package/MissingH <- do you know this library ?
14:12:31 <sqooq> if you're talking about my symbols
14:15:24 <erisco> sqooq, I don't know what a sym is or a Val, but sounds like you've discovered an ambiguity
14:15:44 <erisco> sqooq, if there is more than one parse tree for the same sentence then the grammar is said to be ambiguous
14:15:53 <sqooq> crap
14:16:06 <erisco> some parsers can handle ambiguous grammars and some not
14:16:30 <sqooq> but my implementation can be what's ambigous no?
14:16:48 <erisco> what do you mean by your implementation?
14:16:55 <sqooq> the way I created the grammar
14:17:04 <sqooq> surely [ [ 1 2 ] 3 ] isn't ambiguous
14:17:08 <erisco> ambiguity is a property of the grammar
14:17:25 <sqooq> then my grammar is wrong
14:17:30 <sqooq> i think
14:17:36 <erisco> remember that parse trees come directly from the grammar
14:17:47 <sqooq> ye
14:18:15 <sqooq> I need infinite items but at least 2
14:18:17 <sqooq> how do
14:18:42 <Spriithy> how much effort do you think it takes to parse some C-like code from scratch in Haskell ?
14:18:50 <erisco> S -> aaT; T -> aT | epsilon
14:19:05 <Eduard_Munteanu> bbear, Agda has even more awesome operators
14:19:18 <phadej> Spriithy: depends on your Haskell skills
14:19:34 <Tuplanolla> About a day's work to just parse, Spriithy.
14:19:37 <sqooq> erisco: what notation is that btw
14:19:39 <phadej> if they are "awesome", then maybe one can accomplish that in a day
14:19:49 <Spriithy> Parse into a workable AST 
14:19:54 <bbear> phadej: I am not sure of it. 
14:19:55 <erisco> sqooq, well I am using your "->" and ";" is a line break
14:19:56 <Spriithy> without any specific work on it
14:20:06 <bbear> there is two kind of parsers : validating parsers and non-validating parsers
14:20:07 <sqooq> o i stopped using ->
14:20:13 <bbear> it depends on your scope.
14:20:18 <Tuplanolla> A week is a generous estimate, Spriithy.
14:20:28 <erisco> S ::= aaT
14:20:29 <bbear> I think it must be pretty hard if you want to cover all the C standard.
14:20:33 <jle`> Spriithy: if you're comfortable with parsers, probably a day
14:20:35 <erisco> T ::= aT | ε
14:20:43 <jle`> Spriithy: or do you mean the runtime
14:20:47 <bbear> what are you calling a parser : syntactic analyzer ?
14:20:47 <phadej> bbear: I guess the question was about hte language with c-like syntax
14:20:48 <jle`> in that case, it depends on the size of the text files
14:20:51 <Spriithy> Oh no, no runtime.
14:20:54 <erisco> I guess it is  S ::= "a" "a" T  all proper-like
14:21:03 <Spriithy> I just mean to produce an exhaustive AST of any C source file
14:21:05 <jle`> but it's probably decently fast
14:21:06 <bbear> if you mean just separate variable and function identifier.
14:21:11 <erisco> but really everyone has a little bit different way of writing a grammar, so I don't care
14:21:19 <erisco> if you're being tested on BNF though then get it right ;)
14:21:28 <jle`> Spriithy: if you aren't parsing many thousands of source files, then parsing will probably not be your bottleneck
14:21:38 <bbear> you want to write a syntactic analyzer. I suggest you start with a huge set of C files to test your analyzer.
14:21:49 <Spriithy> jle`: I didn't mean time efficiency of the parsing :) I was speaking of the implementation
14:21:54 <phadej> erisco: yeah, I abuse kleene-star in BNF-like syntax, and then remove it if it cannot be used
14:21:59 <bbear> test is the only way to know if you did it right.
14:22:09 <phadej> erisco: but it's useful as it transates into haskell directly (many)
14:22:16 <sqooq> erisco, ok i'm trying something out
14:22:20 <APic> 😎
14:22:24 <phadej> bbear: you overthink the question
14:22:27 <bbear> i'd be unable to do that, being from a theoretical or a practical point of view.
14:22:28 <Spriithy> But everyone seems to have varying opinions :P
14:22:35 <jle`> Spriithy: it depends on how simple this "c-like" syntax is, but if you're comfortable in haskell and with parser combinators, between a day and a week is a good estimate for something robust
14:22:50 <jle`> Spriithy: for simple toy languages, parsers for them are like a good afternoon coding session
14:22:51 <erisco> phadej, there is useful stuff to borrow from EBNF
14:23:26 <Spriithy> jle`: I have a DSL of mine I wrote when I was a teenager, I want to reimplement it in Haskell (which I started learning a week ago)
14:23:31 <jle`> parsing in haskell is much, much, much easier than most other languages
14:23:34 <Spriithy> and further extend it ofc
14:23:48 <jle`> hm, i'm speaking about one afternoon/one day for someone who uses haskell regularly
14:23:59 <jle`> if you're learning haskell at the same time, it might take longer
14:23:59 <sqooq> what is epsilon
14:24:23 <phadej> erisco: it is, but I don't know formalisms pedantically
14:24:36 <jle`> Spriithy: you're in luck, though.  i'm not sure if you know, but parsers and compilers/interpreters are a bit of a killer app for haskell
14:24:38 <phadej> i'd just write expr = [ expr expr *] | digit
14:24:52 <phadej> ah, [ expr expr expr* ] | digit
14:24:54 <Spriithy> jle`: I know right :p
14:25:00 <jle`> Spriithy: if you're learning haskell at the same time, though, it might take a bit longer
14:25:10 <jle`> if you're following a haskell course, there might be a section specifically on parsers
14:25:15 <Spriithy> I am both learnign haskell & functional programming in a broad sense
14:25:33 <jle`> if you take haskell in a class, there will probably be a week or two dedicated to parsers
14:25:37 <Spriithy> I'm working with this paper https://www.microsoft.com/en-us/research/wp-content/uploads/1992/01/student.pdf
14:25:39 <jle`> well, not for the sake of parsing
14:25:48 <jle`> but just because learning parsers teaches a lot about haskell when you're starting out
14:25:49 <Spriithy> (I haven't taken a class in years xD )
14:26:41 <sqooq> phadej, is that my grammar? what is *
14:26:42 <jle`> there's this famous tutorial about writing a parser and interpreter for a schemey language from scratch
14:26:44 <jle`> https://github.com/write-you-a-scheme-v2?language=haskell
14:27:10 <jle`> it was gathering some dust/bitrot, but i think it is recently being revamped
14:27:23 <jle`> https://www.wespiser.com/writings/wyas/home.html
14:27:35 <Spriithy> "write you a haskell" as well
14:27:47 <Spriithy> I've stumbled around it as well;
14:27:49 <Spriithy> not much a fan 
14:29:35 <jle`> write you a haskell is probably for the advanced haskeller
14:29:39 <jle`> intermediate at worst
14:29:44 <Spriithy> oh well
14:29:51 <Spriithy> I have written a tokenizer this morning
14:29:55 <Spriithy> Mind giving it a look ?
14:30:00 <jle`> i probably wouldn't use it for learning haskell
14:30:06 <jle`> feel free to post it here :)
14:30:17 <jle`> write you a scheme is more for beginners i think
14:30:41 <jle`> write you a haskell is sort of a full stack technical overview
14:30:51 <jle`> on like, compilers and the nature of compiling, llvm, computer architectures
14:30:54 <sqooq> phadej, hey that's it!!!
14:30:57 <jle`> write you a scheme is just a parser and a simple interpreter :)
14:31:02 <Spriithy> jle`: https://gist.github.com/Spriithy/89bd33c78c2468bbb6b70e6c310f42d5
14:31:03 <sqooq> assuming * means optional
14:31:18 <sqooq> wait
14:31:19 <sqooq> nop
14:31:30 <Spriithy> the code probably look terrible jle` 
14:31:33 <jle`> Spriithy: ah, you're parsing it just by streaming through characters?
14:31:41 <jle`> you're probably not going to be able to appreciate haskell too uch then
14:31:45 <Spriithy> that's the tokenizing part right now :)
14:31:45 <phadej> sqooq: a* meens "many a"
14:31:50 <jle`> you're also using regexes
14:32:00 <sqooq> phadej, is that proper
14:32:00 <jle`> wait until you get to parser combinators
14:32:05 <Spriithy> Oh wait
14:32:06 <Spriithy> holy
14:32:14 <Spriithy> wrong file, I'm sorry this is the older version
14:32:23 <sqooq> phadej, hmm i guess it is, it comes from <*> 
14:32:24 <phadej> sqooq: you can remove it by expr = [ expr expr expr' ] | digit; expr' = epsilon | expr expr'
14:32:36 <phadej> sqooq: no, it comes from regexp
14:32:36 <jle`> parsing in haskell means not having to deal with regexes haha
14:32:37 <sqooq> epsilon means nothing?
14:32:39 <Spriithy> jle`: there refresh
14:32:55 <Spriithy> sqooq: Epsilon is the empty production or the null string
14:32:57 <phadej> sqooq: epsilon = empty string, yes
14:33:03 <sqooq> ay
14:33:08 <sqooq> ok that works then I think
14:33:15 <jle`> Spriithy: hm, interesting
14:33:39 <jle`> i would probalby reocmmend that you hold off until you learn about parser combinators
14:33:43 <jle`> or learn about parser combinators now
14:33:44 <sqooq> wow, I think this will be what I finally need to actually parse muh brackets
14:33:57 <jle`> when people say haskell is good at parsing, they usually mean support for parser combinators
14:34:09 <sqooq> Spriither, ay you're working with parsers too?
14:34:15 <phadej> sqooq: or actually you'd rather write expr' = expr expr' | epsilon, because left recursion is usually bad
14:34:35 <jle`> Spriithy: but, hey, if you write your parser this way now, at laest you'll appreciate parser combinators more when you learn about them, ha ha
14:34:53 <Spriithy> jle`: how do you mean "combinators" ?
14:35:18 <jle`> 'parser combinators'
14:35:23 <sqooq> phadej, hmm I must not understand '|' then, I thought it was basically an OR operator, and order didn't matter
14:35:34 <Spriithy> yeah, how does it differ from just parsers ?
14:35:35 <jle`> Spriithy: from libraries like parsec, megaparsec, trifecta, attoparsec
14:35:41 <jle`> Spriithy: well, they are parsers
14:35:49 <jle`> but they are a way of building parsers
14:35:51 <Spriithy> jle`: Parser generators you mean :'D ?
14:35:55 <phadej> sqooq: in (E)BNF it doesn't, but in practice it does
14:35:56 <jle`> not parser generators, heh
14:36:12 <jle`> Spriithy: parsers you can manipulate first-class
14:36:13 <sqooq> phadej, that makes sense
14:36:27 <erisco> sqooq, BNF is a notation for CFGs. not all parsers can parse CFG. in fact, most can't
14:36:36 <jle`> Spriithy: say you have a token parser `tokenParser :: Parser Token`
14:36:45 <jle`> Spriithy: then you can make a parser of many tokens using 'many'
14:36:51 <jle`> many :: Parser Token -> Parser [Token]
14:36:59 <erisco> sqooq, you have to look out of left recursion, ambiguity, and yes, even the order of |
14:37:10 <Spriithy> Like a token iterator
14:37:15 <jle`> or say you have a parser for diferent types of tokens, tok1 :: Parser Token, tok2 :: Parser Token
14:37:16 <Spriithy> generator, rather
14:37:18 <sqooq> is my grammar CFG then
14:37:25 <jle`> then you can create a new parser that parses one or the other
14:37:33 <erisco> sqooq, if you wrote it in BNF then yes
14:37:36 <jle`> `tok1 <|> tok2`
14:37:43 <jle`> Spriithy: yes, but these are first-class values
14:37:52 <jle`> that you can manipulate in haskell
14:37:52 <sqooq> erisco, well.... phadej wrote it for me lol
14:37:57 <jle`> using common haskell idioms and abstractions
14:38:06 <erisco> sqooq, if it is written in BNF then yes
14:38:14 <Spriithy> Okay I recognize that <|> is for monads. Haven't looked into them yet
14:38:20 <jle`> it's not actually for monads
14:38:29 <erisco> sqooq, ebnf is fine also
14:38:34 <jle`> but yeah, parser combinators let you work with parsers as first-class values
14:38:43 <jle`> and it lets you generate complex parsers from simple parsers and simple primitives
14:38:48 <jle`> all within haskell
14:39:14 <monochrom> <|> is from Alternative. Look into the module Control.Applicative
14:39:21 <sqooq> erisco, that's not gonna be a problem for when I parse it right?
14:39:27 <jle`> `choice :: [Parser a] -> Parser a`, `optional :: Parser a -> Parser (Maybe a)`, etc.
14:39:37 <erisco> sqooq, the reason the order of operands over | matters in parsers may be because the parser has limited backtracking capability
14:39:38 <Spriithy> You quite triggered my interest jle` 
14:39:39 <jle`> being able to work with first-class parsers means not having to like...manually create complex parsers from scratch
14:39:45 <jle`> like waht you're doing
14:39:58 <jle`> you're basically writing your entire parser logic from manual iterating through a string
14:40:04 <jle`> and like, handling each case all in the same area
14:40:15 <Spriithy> No I am generating the text tokens
14:40:16 <jle`> parser cobminators let you make composible parsers
14:40:22 <Spriithy> that the parser then analyzes
14:40:25 <Spriithy> y'know
14:40:34 <jle`> ah, yeah. i mean parsing the string into tokens
14:40:40 <sqooq> ersico, shoot my parser has zero backtracking ability as currently implemented
14:40:42 <erisco> sqooq, again, BNF or EBNF let you write context-free grammars. Not all parser combinators are capable of handling context-free grammars (and in fact, most cannot)
14:41:02 <erisco> sqooq, instead you have many different parsers which work with some subset of CFGs
14:41:08 <phadej> usually https://en.wikipedia.org/wiki/LL_parser
14:41:12 <jle`> Spriithy: but yeah, if it works, go for it :)  it might help to approach the problem from different anglges
14:41:13 <erisco> sqooq, the reasons for this are performance
14:41:20 <jle`> and if anything, you'll appreciate parser combinators so much more
14:42:08 <erisco> sqooq, there are parsers which can though, and usually they're dubbed "general CFG parsers"
14:42:33 <Spriithy> jle`: I thought I'd do the same as in imperative languages ...
14:42:38 <erisco> sqooq, in practice it is so normal to only be capable of a subset of CFGs that "CFG" has somewhat become synonymous with those subsets...
14:43:20 <erisco> evidenced by any need to say "general CFG" :P
14:43:35 <phadej> Spriithy, jle`: parsing to tokens isn't always a bad idea. e.g. https://github.com/bos/aeson/pull/560
14:43:36 <jle`> Spriithy: yeah, if you do that, you'll gain an appreciation for haskell's type system and purity guaruntees, and its syntax
14:43:51 <phadej> Spriithy, jle`: there by writing "lexer" by hand, I outperform attoparsec
14:44:09 <Spriithy> phadej: hand written lexers are most always better
14:44:15 <phadej> Spriithy: not always
14:44:22 <Spriithy> hence I used "most" 
14:44:29 <Spriithy> I mean, well written ones
14:44:33 <jle`> phadej, Spriithy: yes, there is some value in writing things by hand.  but if the goal is to explore haskell and functional programming
14:44:38 <jle`> Parser combinators are a must-see stop :)
14:44:56 <Spriithy> Okay ! :)
14:45:01 <erisco> sqooq, it is a similar relationship between Integer and Int... usually no one bothers to distinguish the two
14:45:04 <Spriithy> Are you around often here ?
14:45:20 <phadej> jle`: well, I do use parser combinators to parse the token streama
14:45:23 <jle`> Spriithy: but yeah, writing them the imperative way, you'll appreciate some parts of haskll (the type system), but you won't see the functional programming parts, and also the really great haskell abstractions we all know and love and use every day
14:45:30 <phadej> jle`: and parsec can be used to parse [token]
14:45:43 <jle`> phadej: ah yeah.  so yay parser combinators :3
14:45:50 <jle`> Spriithy: i'm here oftne, but usually there are many people here to help :)
14:45:50 <phadej> jle`: you just need to write some of boilerplate, which is done for you when token ~ Char
14:45:56 <sqooq> erisco, can you at least tell me if I'm on the right track
14:45:57 <sqooq> http://lpaste.net/357369
14:46:12 <sqooq> for parsing what phadej wrote
14:46:31 <sqooq> expr = [ expr expr expr' ] | digit; expr' = expr expr' | epsilon
14:47:36 <phadej> sqooq: your alternative instance is weird
14:48:17 <sqooq> lmao
14:48:18 <erisco> try it for a few test cases, see what happens ... I don't really want to spend the time to verify a parser
14:48:23 <phadej> sqooq: (<|>) = plus should work for non-ambigious grammars
14:48:29 <Tirnak> HI, eveyone!
14:49:29 <Tirnak> I am rather new to Haskell, but I wa thinking: can we get compile-time check for aliased types? like
14:49:29 <Tirnak> type X = String type Y = String  main = do   let x = "qwerty" :: X   let y = "qwerty" :: Y   putStrLn $ show $ x==y   return ()
14:50:01 <Tirnak> type X = String; type Y = String;  main = do   let x = "qwerty" :: X  ; let y = "qwerty" :: Y ;  putStrLn $ show $ x==y ;  return ()
14:50:20 <Tirnak> so that x==y would be false?
14:50:25 <sqooq> phadej, what I have written just stops at the first result, the other one keeps going through every possibility
14:50:28 <glguy> Tirnak: No, that wouldn't be sensible
14:50:31 <sqooq> idk which is preffered
14:51:03 <phadej> sqooq: read thru http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html
14:51:05 <sqooq> the Graham Hutton paper I was following seems to prefer what I wrote
14:51:07 <glguy> Tirnak: If you want to introduce a distinct type rather than an alias for an existing type, you can use newtype
14:51:26 <phadej> sqooq: it doesn't use "Monad" or "Applicative" yet, so you see what happens
14:52:08 <erisco> sqooq, one test is to see if your parser will parse "ssssss" with the grammar S ::= "a" | "a" S  as well as the grammar S ::= "a" S | "a"
14:52:32 <erisco> um, parse "aaaaaa"
14:52:46 <jle`> Tirnak: you mght want to look at newtypes :)  they are distinguished at compiletime
14:53:32 <erisco> sqooq, both are going to tell you something about your backtracking
14:54:12 <Spriithy> anyways thanks jle` and all the other
14:54:14 <Spriithy> nice talks
14:55:02 <Tirnak> glguy, jle`, thanks! It makes sense.
14:55:07 <jle`> no problem!
14:55:11 <erisco> sqooq, but the best way to be sure is to design the whole thing from simple, well-understood principles
14:55:23 <jle`> Spriithy: for some context, the other day i wrote a one-off parser for a complicated spec just for fun
14:55:28 <jle`> in less than an hour
14:55:33 <Spriithy> ?
14:55:35 <Spriithy> how
14:55:38 <jle`> using parser combinators
14:55:46 <jle`> the whole thing was a breeze :)
14:55:59 <mniip> ye parsing combinators are magic
14:56:14 <mniip> I wound up the complete syntax of lua in under an hour once
14:56:17 <erisco> if something is too complicated to understand then you are not sufficiently prepared ... step back and begin simpler
14:56:28 <jle`> in another language i would probably put off writing a parser for a non-trivial ADT until like, the last step
14:56:39 <Spriithy> jle`: could you link me the sources :D ? please
14:56:43 <Spriithy> just to have a look
14:56:43 <jle`> but with parser combinator, the parser is by far the easiest (and maybe the most fun) part of the project haha
14:56:56 <erisco> i.e. if you have wrote a program but you really are not sure if it is the right thing then you have not prepared a specification that you know is right
14:57:05 <mniip> jle`, after haskell I'm not afraid to write  thing *parse_thing(char const **str) type parsers anymore :p
14:57:09 <erisco> so, step back and figure that out first
14:57:30 <erisco> not to say that writing code to get some ideas is a bad thing... it is a good thing and I encourage that
14:58:04 <jle`> https://github.com/simonmichael/hledger/pull/597/files#diff-908bc63a0acf224853d6422f7d0bc515R410
14:58:09 <jle`> understanding the code might take some understanding of the library
14:58:13 <erisco> but when you finally look up and see you're lost in a quagmire, time to reset
14:58:18 <jle`> one of the nice thing was that i was able to re-use other parsers that the library defined
14:58:22 <jle`> within my parser
14:58:41 <Spriithy> is that it xD ?
14:58:43 <Spriithy> 80 lines ?
14:59:15 <jle`> yeah it's a lot more verbose than it had to be
14:59:37 <jle`> a lot of the complexity was handled by the fact that i could re-use parser components from different parts of the library that were already written
14:59:44 <sqooq> erisco it's basically identical to http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf
15:02:01 <erisco> sqooq, well, try those two tests and see what happens
15:02:23 <sqooq> i mean
15:02:35 <mniip> I think I lpasted it somewhere
15:02:36 <sqooq> i can effectively get the same thing with many char 's'
15:02:39 <mniip> wonder if I can find it
15:02:51 <erisco> sqooq, that isn't the point of the test
15:03:30 <mniip> must've been at least 2 years ago
15:03:55 <erisco> s = (:) <$> char 'a' <*> s <|> pure <$> char 'a'
15:04:06 <Tuplanolla> The way you suggest returning a pointer worries me, mniip.
15:04:25 <mniip> Tuplanolla, if the structure is large it saves quite a lot of moves
15:04:25 <erisco> s = pure <$> char 'a' <|> (:) <$> char 'a' <*> s
15:05:18 <mniip> most rencently I implemented a lambda calculus like language with a reference counting collector - in it returning pointers to objects was absolutely fine
15:05:48 <mniip> such was the calling convention: function arguments have to have 1 ref which the callee consumes, return values have to have 1 ref which the caller consumes
15:06:10 <sqooq> erisco: that first one works 
15:06:15 <Tuplanolla> I'd prefer `bool *parse_thing(thing *ptr, size_t limit, char const *const *str)`, mniip.
15:06:17 <Spriithy> one last thing
15:06:21 <sqooq> with my code
15:06:21 <erisco> sqooq, it works on "aaaaaa" ?
15:06:27 <Spriithy> would that be possible to create a VM in haskell ?
15:06:32 <mniip> Tuplanolla, you mean bool
15:06:34 <sqooq> yup
15:06:36 <sqooq> any number
15:06:37 <Spriithy> since there is no way to carry out some memory space
15:06:42 <Tuplanolla> Ah, yes, mniip.
15:06:45 <mniip> Spriithy, sure is, Data.Array
15:06:49 <mniip> also see
15:06:52 <erisco> sqooq, okay, cool, that is something a recursive descent parser won't do
15:06:52 <mniip> @hackage h6152
15:06:52 <lambdabot> http://hackage.haskell.org/package/h6152
15:07:01 <sqooq> erisco: but how'd you know to write it like that?
15:07:03 <mniip> oops
15:07:05 <mniip> it's not on hackage
15:07:25 <mniip> also I forgot the name suddenly
15:07:44 <Spriithy> not found ^^
15:07:45 <monochrom> Data.Array is in base, isn't it?
15:07:53 <monochrom> Oh nevermind, misread.
15:07:54 <mniip> https://github.com/mniip/h6502
15:07:57 <mniip> Spriithy, ^
15:08:02 <monochrom> Ah!
15:08:07 <Spriithy> why thanks!
15:08:15 <erisco> sqooq, actually it may be  S ::= "a" S "a" | ε  that recursive descent doesn't do ... the years ago are foggy ...
15:08:21 <erisco> sqooq, try that one too anyways to see
15:08:25 <sqooq> erisco: the second one you wrote doesn't work
15:08:27 <sqooq> btw
15:08:31 <sqooq> only parses the first a
15:08:38 <erisco> yeah, so that probably means it is lookahead 1
15:08:58 <Spriithy> mniip: did you write a spec ?
15:09:08 <mniip> no
15:09:14 <mniip> it follows the 6502 spec
15:09:39 <erisco> sqooq, do you mean to ask how did I know how to translate the BNF grammar to an executable grammar (i.e. the applicative notation stuff)?
15:10:00 <mniip> not sure which, I think I combined it from multiple sources until I passed a benchmark that tests all documented instructions
15:10:14 <sqooq> erisco: yes
15:10:18 <sqooq> because if I can do that
15:10:22 <sqooq> then I can implement the parser I want
15:10:25 <sqooq> immediately
15:10:38 <sqooq> without having to think about how to use bind and <|> and stuff
15:10:48 <sqooq> well I mean
15:10:54 <sqooq> I'll still need to know how
15:10:59 <erisco> okay, well, you change juxtaposition of terminals and nonterminals to <*>, and you change | to <|>
15:11:00 <sqooq> but since I have the BNF, it will be easier
15:11:17 <sqooq> !!!!
15:11:20 <sqooq> if it's that simple
15:11:21 <sqooq> wow
15:11:37 <mniip> in in 'A B' A returns a function then yes
15:11:43 <erisco> well yeah, that is why they are called executable grammars ... because they look just like the grammar and you can execute them :P
15:11:54 <mniip> otherwise you might need extra glue to combine the attributes
15:14:19 <erisco> s = (\a b c -> a : (b ++ [c])) <$> char 'a' <*> s <*> char 'a' <|> empty   -- try that on "aaaaaa"
15:15:03 <monochrom> Wait, empty?
15:15:08 <monochrom> @type empty
15:15:09 <lambdabot> Alternative f => f a
15:15:10 <mniip> itym pure ""
15:15:19 <monochrom> Yeah.
15:15:22 <erisco> um, let me check
15:15:46 <monochrom> empty always fails. pure "" always succeeds. Do you want success or do you want to avoid success? :)
15:15:56 <mniip> avoid success at all costs
15:16:10 <sqooq> erisco, it fails
15:16:26 <sqooq> o wait do what monochrom says?
15:16:34 <monochrom> The truth.
15:16:42 <sqooq> btw why use pure over return?
15:16:51 <erisco> yeah, empty is failure, that's correct, my bad
15:16:56 <nisstyre> mniip: I agree with that. Mostly because what most people think success is, is awful
15:16:59 <sqooq> erisco: with that change it works
15:17:10 <sqooq> wait
15:17:19 <erisco> check that it parses the whole input, though
15:17:21 <sqooq> i've been assuming works means taking in the whole thing this entire time
15:17:36 <sqooq> yes it takes all 6 a's
15:17:49 <sqooq> [("aaaaaa","")]
15:18:05 <mniip> that shouldn't be the only parse
15:18:16 <erisco> yes it is
15:18:16 <mniip> is your <*> and/or <|> working correctly?
15:18:19 <monochrom> You can also give five a's and see what happens.
15:18:25 <erisco> it is not an ambiguous grammar
15:18:41 <sqooq> 5 a's only gets 4
15:18:46 <mniip> it is ambiguous up to unparsed suffix length
15:18:53 <sqooq> 4 only gives 2
15:19:09 <erisco> I am assuming that it is taking it up to the end, mniip, but okay
15:19:10 <sqooq> 3 gives nothing
15:19:15 <mniip> s/up to/with respect to/
15:19:19 <sqooq> so it doesn't work?
15:19:34 <erisco> the grammar only parses even length strings... analyse it a bit ;)
15:20:04 <erisco> but yes, if "aaaa" only gives "aa" then it is not capable of parsing this language
15:20:10 <erisco> not with this grammar, anyways
15:20:23 <sqooq> yeah and 8 a's gives "aa" too
15:20:29 <sqooq> only 6 a's works for whatever reason
15:20:43 <erisco> some parsers require you to force the end, so maybe check it isn't that
15:20:47 <erisco> not sure how your parser works
15:20:50 * mniip "imports" yoctoparsec
15:20:52 <mniip> oh wait
15:20:56 <mniip> int-e added FreeT
15:21:24 <mniip> :t let s = (\a b c -> a : (b ++ [c])) <$> char 'a' <*> s <*> char 'a' <|> empty in s
15:21:25 <lambdabot> error:
15:21:25 <lambdabot>     Ambiguous occurrence ‘char’
15:21:25 <lambdabot>     It could refer to either ‘Text.PrettyPrint.HughesPJ.char’,
15:21:41 <mniip> :t let s = (\a b c -> a : (b ++ [c])) <$> L.char 'a' <*> s <*> L.char 'a' <|> empty in s
15:21:43 <lambdabot> MonadPlus m => FreeT ((->) Char) m [Char]
15:22:22 <erisco> with the string of 4 a's, it will get to aaaa^Saaaa and I have put a caret for where the parser is looking right now
15:22:44 <erisco> then it tries aSa again but there are no more a's, so it uses epsilon, now you have aaaa^aaaa
15:23:16 <erisco> then it goes back up a level, having successfully used epsilon for S, and tries to find the next 'a', but that doesn't work!
15:23:33 <mniip> > let s = (\a b c -> a : (b ++ [c])) <$> L.char 'a' <*> s <*> L.char 'a' <|> pure [] in parseString s "aaaaaa" `asTypeOf` []
15:23:35 <lambdabot>  [("aaaaaa",""),("aaaa","aa"),("aa","aaaa"),("","aaaaaa")]
15:23:44 <erisco> so now backtracking takes place, or the parser gives up
15:24:14 <mniip> actually, I think I can fit all of yoctoparsec on one line
15:24:24 <erisco> basically, when you are just looking ahead one character at a time, you're liable to run into long dead ends
15:25:06 <erisco> how well does yoctoparsec handle ambiguous grammars?
15:25:18 <sqooq> erisco: fixed it
15:25:29 <mniip> > let token = FreeT . pure . Free $ FreeT . pure . Pure; parseStream next = runStateT . iterTM (StateT next >>=); parseString = parseStream (maybe empty pure . uncons); char x = mfilter (== x) token in parseString (char 'f') "foo" `asTypeOf` []
15:25:31 <lambdabot>  [('f',"oo")]
15:25:41 <sqooq> but now it stores all previous results
15:25:43 <mniip> erisco, depends on which backtracking monad you pick
15:25:49 <sqooq> which is kind of ugly but I guess not problematic
15:26:01 <erisco> mniip, how well *can* it handle ambiguous grammars
15:26:25 <erisco> it is just a question of whether it uses exponential space/time or polynomial space/time
15:26:28 <mniip> about as well as StateT p[
15:26:30 <mniip> about as well as StateT []
15:26:34 <mniip> ah that
15:26:36 <mniip> I have no idea
15:26:48 <sqooq> wait does that mean my parser is good now
15:27:02 <sqooq> can it parse S ::= [ S S S' ] | v ; S' ::= S S' | epsilon
15:27:15 <erisco> I wouldn't be surprised if yoctoparsec, if the idea it is quite simple, is actually not exactly the same thing I came up with (it is pretty obvious to find)
15:27:17 <mniip> I was never silly enough to concern myself with performance of an example of consciseness
15:27:26 <erisco> but I didn't go as far to make ambiguous parsing polynomial
15:27:45 <erisco> that requires sharing and stuff got too mucky for my understanding at the time
15:28:12 <sqooq> erisco: in your parser examples, how do you know what to make the first function for the fmap
15:28:50 <erisco> sqooq, if you've got n things sandwiching your <*>'s then it needs to take n arguments
15:29:03 <erisco> sqooq, and the types of those arguments correspond to the types of the n things
15:29:40 <mniip> erisco, it works just like the NTM-on-DTM emulation of a PDA for the grammar
15:29:41 <mniip> I think
15:30:33 <sqooq> erisco: so that's where the parser actually does something, I'm guessing
15:30:35 <mniip> NPDA, obviously
15:31:41 <sqooq> erisco: like in your case you just make a string of the same character
15:31:44 <sqooq> so you just use :
15:31:59 <erisco> not sure how that translates ... but the simple is your parser is  String -> [(a, String)], <|> is an interleave (a merging of two possibly infinite lists), and <*> is Cartesian product
15:32:30 <mniip> erisco, eeeno
15:32:32 <mniip> it's not
15:32:55 <erisco> *shrug* okay, I thought that version is an obvious one to find though
15:32:58 <ystael> is there a standard name for (f <$>) <$> x, connecting f :: a -> b and x :: (Functor g1, Functor g2) => g1 (g2 a) ?
15:33:16 <mniip> Parser b t a = b (Either a (t -> Parser b t a))
15:33:19 <mniip> erisco, ^
15:34:01 <erisco> what is Either used for? if it is about error information then that is more complicated than I am thinking of :P
15:34:10 <erisco> having reasonable errors is another matter entirely
15:34:30 <mniip> erisco, Left = here's the thing, Right = I need another token
15:34:45 <mniip> Either comes from FreeT itself, see FreeF
15:35:33 <mniip> if you squint real hard
15:35:39 <mniip> you can see the structure
15:35:48 <erisco> that is brief! https://github.com/mniip/yoctoparsec/blob/master/src/Control/Monad/Yoctoparsec.hs
15:36:04 <mniip> erisco, I copy-pasted it in irc a few lines above
15:37:04 <sqooq> erisco, my grammar has 5 things | 1 
15:37:26 <monochrom> Interesting.
15:37:48 <mniip> it is?
15:37:57 <mniip> it's a year old and when I made it no one batted an eye
15:38:11 <erisco> mniip, I think so ... will be fun to take a peek
15:38:23 <monochrom> But I am not always looking at IRC.
15:38:45 <mniip> one curious thing I had in mind while designing this is,
15:38:55 <mniip> someone was discussing String -> b (String, a) parsers
15:38:55 <erisco> I am not sure what merit having an intermediate result is
15:39:06 <mniip> and a point was made
15:39:14 <mniip> that the function is expected to return a tail of its input
15:39:24 <mniip> but it's not restricted by type to do so
15:39:26 <sqooq> Actually let me phrase this in 2 questions. First, is the first function supposed to do the thing that's parsed (for example, in a simple caclulator it adds 2 numbers or subtracts etc.)? Second, if I wanted to parse my bracket thing but just have the result be everything that succeeded, then I would do something similar to what you did with the lambda right?
15:39:35 <mniip> and I began my pursuit of the right type eventually finding this
15:39:58 <erisco> mniip, do you actually use the information that it needs at least one more character in any other meaningful way?
15:40:13 <mniip> sure
15:40:31 <mniip> in parseStream I take the character and feed it into the function in the Right
15:40:47 <mniip> and I know whether it's finally done or whether I need to take another
15:41:09 <mniip> if you mean other than that, not sure
15:41:10 <erisco> actually, let me play with it for a second
15:41:13 <mniip> I guess you could
15:41:32 <mniip> recently I found a couple combinators you could implement that are not implementable with these + typeclasses
15:41:44 <mniip> but as I started implementing them they grew larger than the whole library
15:42:06 <mniip> this includes e.g lookahead aka conjunction
15:42:55 <mniip> and then there were some issues with I think Applicative
15:43:08 <mniip> I wanted to keep everything Alternative but the typeclasses just wouldn't allow me
15:44:06 <dmitrydzhus> A package with some 20 reverse dependencies on Hackage without upper bounds is about to receive breaking changes (String -> Text everywhere). Am I right thinking that reverse dependencies' authors should be given notice (even though they couldn't expect this to never happen when not respecting PVP)?
15:44:39 <mniip> also would be useful to have peek :: (t -> b a) -> Parser b t a   because not everything has Eq
15:45:04 <mniip> wait nevermind, that's just a right application of mfilter
15:45:14 <glguy> dmitrydzhus: I'd be nice if you were to send out some emails about it, but this is what upper bounds and major version number changes are for
15:46:34 <erisco> mniip, it is iterating through the ambiguous parses, so that is good to see ... but it is using Cartesian product if it is doing so with the list monad
15:47:04 <mniip> not really
15:47:11 <erisco> how so?
15:47:17 <mniip> it appends the argument's parse tree everywhere in the function's parse tree
15:47:39 <hpc> dmitrydzhus: part of me wants to say they should have known better and they can deal with the breakage in their packages
15:47:43 <mniip> oh yeah, when evaluated strictly this parser represents a parse tree :o
15:47:53 <hpc> but part of me also thinks this will just lead to more "cabal breaks builds, let's use stack instead"
15:47:54 <mniip> er no
15:47:58 <erisco> I don't know what that means
15:47:59 <mniip> the other kind of parse tree
15:48:06 <mniip> nvm
15:48:39 <mniip> erisco, it's a prefix tree of all possible parses
15:48:48 <mniip> if you represent functions as Maps
15:49:44 <erisco> yes I see what it is spitting out, and it is also what you get with the Cartesian product :P
15:50:27 <erisco> you have a parser that returns a bunch of possible parses, THEN a parser which also returns a bunch of possible parses
15:50:37 <erisco> so the whole of that is the product of those two lists
15:50:38 <dmitrydzhus> hpc: I think the same, even though I'm a stack person: they should just automate upper bounds placement and release often using stack instead of not including upper bounds at all.
15:50:53 <mniip> erisco, well yes, semanticaly
15:51:28 <mniip> it is ever so slightly monadic though because the function can consume different amounts of tokens
15:51:28 <hpc> maybe cabal needs ~w.x.y.z syntax for "give me anything in the same semantic version range as this"?
15:51:45 <erisco> the fact you have a type that better represents the properties we expect is interesting, and especially since you then go on to give such a short implementation
15:52:43 <dmitrydzhus> hpc: Isn't it the same as `dependency == a.b.*`?
15:53:28 <hpc> it is, but sometimes you need a little sugar to convince people to use something correctly
15:53:38 <erisco> it will be exponential on ambiguous grammars, at least with lists, not I am not sure if you couldn't improve that with a different Monad, would have to look closer
15:53:41 <erisco> ultimately you need sharing
15:54:29 <mniip> erisco, should I bother to write a short article
15:54:32 <erisco> the reason I did not use the list Monad myself is because it hitches on infinite lists, and I was particularly interested in enumerating the sentences of a language
15:54:45 <hpc> having it in cabal also puts a bit more officiality on semantic versioning
15:55:03 <mniip> erisco, well this can enumerate fairly well
15:55:19 <mniip> assuming you go through the 't -> ...' layer
15:55:27 <erisco> can you give an example?
15:55:43 <dmitrydzhus> Isn't "semantic versioning" a term coined by JavaScript people? I therefore refuse to recognize it.
15:56:11 <erisco> though, I recently published a version of list which does not have the hitching problem
15:56:31 <erisco> so you could just plop in that and it should... chooch (anyone?)
15:56:32 <mniip> I could write an sentences :: (Enum t, Bounded t) => Parser [] t a -> [([t], a)]
15:56:57 <mniip> though not without the use of the Omega monad
15:57:07 <hpc> it looks like it's just some random creative commons thingy - http://semver.org/
15:57:34 <erisco> mniip, well if you can figure that out then I'll show you my different list monad and we'll see if it can work
15:57:36 <hpc> it is big in js land though
15:57:48 <mniip> erisco, is your list monad the Omega monad?
15:57:54 <erisco> no idea
15:58:05 <phadej> there is difference between "semantic versioning" and "Semantic Versioning"
15:58:27 <mniip> erisco, is it the one that can evaluate (,) <$> [0..] <*> [0..]
15:58:38 <erisco> mniip, yes, it can do that!
15:58:39 <erisco> http://hackage.haskell.org/package/data-list-zigzag-0.1.1.0/docs/Data-List-ZigZag.html
15:59:06 <mniip> looks a lot like Omega so far
15:59:13 <erisco> I needed a particular property for a solver I was working on (roughly that it would go through the product in an "even" way)
15:59:26 <erisco> so I puzzled a bit and came up with ZigZag ... Omega sounds a bit ominous
15:59:28 <phadej> givin version numbers some semantics is "semantic versioning", and "Semantic Versioning" is one variant of possible semantics
15:59:53 <phadej> lesson: do not give things generic names
16:00:02 <phadej> *generic names to things
16:00:03 <erisco> the big property is, wlog, fmap sum (sequence (replicate n (fromList [0..]))) is monotonically increasing
16:00:36 <mniip> Omega states only, More precisely, if x appears at a finite index in xs, and y appears at a finite index in f x, then y will appear at a finite index in each xs >>= f.
16:00:37 <mniip> This monad gets its name because it is a monad over sets of order type omega.
16:01:04 <erisco> okay, ZigZag is stronger
16:01:54 <mniip> can you condense it on an lpaste and import into lambdabot?
16:02:55 <erisco> well I am not claiming Omega doesn't do the same thing, just that the property it states is weaker
16:03:16 <erisco> I'll try and get it on lambdabot
16:04:06 <erisco> mniip, why do you say "in each xs >>= f" rather than just "in xs >>= f" ?
16:04:19 <mniip> not me, the author of the packge
16:04:36 <erisco> okay, well, not sure what the "each" is to mean
16:05:00 <mniip> maybe that's a sort of infix 'forall xs, f'
16:06:20 <erisco> ZigZag gives you a property over x1s >>= \x1 -> ... xns >>= \xn -> f x1 ... xn
16:06:33 <mniip> I figure
16:07:21 <erisco> and I needed that because I was taking the product of various things and each were ordered in some relevant way
16:07:36 <erisco> so for the search to be efficient I had to have it that the product also came out in some relevantly ordered way
16:08:13 <Spriithy> hey
16:08:21 <Spriithy> what editor do you guys use ?
16:08:38 <Spriithy> I am on VS Code + Haskero
16:08:42 <Spriithy> I don't like it much
16:08:45 <Spriithy> not very useful
16:09:21 <mniip> vim
16:09:45 <mniip> a gtk terminal and occasionally putty
16:13:40 <erisco> mniip, how am I supposed to give the Applicative definition which uses return and ap... =\
16:14:58 <mniip> actually
16:15:01 <erisco> if I give both at once I go over the max line length
16:15:07 <mniip> I think I might be ablle to produce an iterTM oneliner
16:15:17 <mniip> erisco, you can put it in an lpaste
16:15:27 <mniip> you've got 4K of space then
16:15:32 <erisco> then what?
16:15:42 <erisco> I'll just copy/paste the whole module source
16:17:28 <erisco> if Omega is already on lambdabot then that will work... that property is sufficient
16:19:52 <erisco> a version of Omega I wrote with my parser was based on a function I called "interleave" which is  interleave (x:xs) (y:ys) = x : y : interleave xs ys  (but done a bit differently because of strictness)
16:21:20 <erisco> so what you have is a finite list of infinite lists and then you fold interleave over them
16:22:28 <Welkin> has anyone worked out the type of (.) . (.) by hand?
16:22:28 <erisco> an infinitary product doesn't work iirc because you'll never figure out if the product is non-empty
16:22:33 <Welkin> I was trying it earlier today
16:22:45 <hpc> i once manually typed it into ghci :P
16:22:46 <erisco> Welkin, yes
16:23:00 <erisco> I showed fmap fmap fmap to a friend and we worked it out on paper
16:23:16 <erisco> variable hygiene was a PITA
16:23:18 <Welkin> erisco: can you link it?
16:23:26 <Welkin> or rewrite it/explain it
16:23:40 <erisco> I cannot link you to a piece of paper ... and actually I am pretty sure it was on a white board ... well erased by now
16:23:40 <Welkin> maybe I just made an error, but I got a huge expression that didn't look right
16:24:35 <erisco> do you want it from fmap fmap fmap or (.) . (.) ?
16:24:36 <Welkin> I ended up with too many different variables, yes
16:24:53 <Welkin> erisco: the latter, but the former looks interesting too
16:31:13 <mniip> erisco, see
16:31:26 <erisco> Welkin, will take me a few minutes
16:31:34 <erisco> mniip, what do I see?
16:31:35 <mniip> @let prefixTree :: (Enum t, Bounded t, MonadPlus b) => Parser b t a -> b (a, [t])
16:31:35 <mniip> ; prefixTree p = runStateT (iterTM (\f -> do t <- lift $ asum $ map pure [minBound .. maxBound]; modify (t:); f t) p) []
16:31:36 <lambdabot>  .L.hs:159:1: error:
16:31:36 <lambdabot>      The type signature for ‘prefixTree’ lacks an accompanying binding
16:31:36 <lambdabot>  
16:31:40 <mniip> @let prefixTree :: (Enum t, Bounded t, MonadPlus b) => Parser b t a -> b (a, [t]); prefixTree p = runStateT (iterTM (\f -> do t <- lift $ asum $ map pure [minBound .. maxBound]; modify (t:); f t) p) []
16:31:41 <lambdabot>  .L.hs:160:50: error:
16:31:42 <lambdabot>      Not in scope: type constructor or class ‘Parser’
16:31:57 <erisco> oh, I messed you up possibly =\
16:32:08 <mniip> @let prefixTree :: (Enum t, Bounded t, MonadPlus b) => Parser b t a -> b (a, [t]); prefixTree p = runStateT (iterTM (\f -> do t <- lift $ asum $ map pure [minBound .. maxBound]; modify (t:); f t) p) []
16:32:09 <lambdabot>  Defined.
16:32:41 <mniip> it takes a long time due to large search space of Char but for Word8 I expect it works reasonably fast
16:34:05 <Spriithy> How can I only take a given set of elements from a list only if they are of a given data constructor ?
16:34:21 <Spriithy> like [x | x <- xs, Foo x]
16:34:40 <Spriithy> where Foo would be the data constructor I want to have instances of
16:34:47 <mniip> [x | x@Foo{} <- xs]
16:34:51 <mniip> or something like that
16:35:37 <Spriithy> Oh okay thanks mniip :)
16:35:37 <mniip> yup
16:36:05 <mniip> might look a little cryptic
16:36:09 <Spriithy> yeah
16:36:13 <Spriithy> the @
16:36:21 <mniip> that's just the, uh, what's it called
16:36:28 <mniip> I have no idea
16:36:34 <monochrom> "as" pattern
16:36:35 <Welkin> the at-symbol
16:36:37 <Spriithy> "at"
16:36:46 <mniip> I didn't mean the symbol
16:36:49 <Welkin> confusingly called an "as" pattern
16:36:51 <mniip> as-pattern sounds good enough
16:36:53 <monochrom> In SML, they literally use the word "as".
16:36:58 <Welkin> I think as "at" pattern makes more sense
16:37:12 <Welkin> monochrom: then why is it an @ is haskell?
16:37:20 <mniip> Spriithy, when you pattern match something you don't have to throw the entire thing out, you can bind the entire thing to a variable with @
16:37:24 <Spriithy> hm my GHC asks me to add the TypeApplications to use it
16:37:42 <Welkin> in*
16:37:48 <mniip> Spriithy, something about spaces
16:37:50 <monochrom> Because ! # $ % ^ & * - + _ are all even worse.
16:37:53 <mniip> what exactly did you write
16:37:55 <Spriithy> well I knew to match lists like so list@(x:xs)
16:37:58 <Welkin> monochrom: why not "as"
16:38:04 <mniip> Spriithy, yeah this is exactly this
16:38:13 <Spriithy> mniip: concat [printTree t@Node{} (depth + 1) | t <- ts]
16:38:13 <mniip> but instead of : you're now matching Foo
16:38:16 <monochrom> They want to let you use "as" for user-defined identifiers
16:38:23 <mniip> and Spriithy yeah no that's not what I said at all
16:38:36 <Spriithy> Oh fml
16:38:56 <Spriithy> my brain is dead atm
16:38:58 <Spriithy> nevermind
16:39:04 <mniip> and {} serves as a wildcard of sorts
16:39:07 <Welkin> erlang has an interesting way of pattern matching for that case using =
16:39:15 <mniip> instead of 'Foo _ _ _ _' with however many arguments Foo has
16:39:25 <Welkin> mniip: I thought that was {..}
16:39:45 <mniip> no that's RecordWildCards
16:39:47 <Welkin> Spriithy: you mean SML
16:39:52 <mniip> {} is part of language
16:39:57 <Welkin> oh, okay
16:40:03 <Spriithy> Welkin: I mean no such thing ^^ I have no clue what it is
16:40:15 <mniip> @let xyz@True{} = True
16:40:17 <lambdabot>  Defined.
16:40:19 <Welkin> Spriithy: it was a language joke
16:40:43 <Spriithy> ah well... I'm not trained enough to understand ^^"
16:41:23 <Spriithy> Okay so I have a piece of code that works, yet I'm sure it sucks:  concat [printTree t (depth + 1) | t@Node{} <- ts] ++ concat [printTree t (depth + 1) | t@Leaf{} <- ts]
16:41:34 <Spriithy> how could I improve it ?
16:41:34 <erisco> mniip, I'll get back to you, I am just working on Welkin's thing
16:41:43 <Spriithy> is there something I should learn from it ?
16:41:54 <Welkin> erisco: :D
16:41:59 <Spriithy> The idea is to first render the Nodes then the Leaves
16:43:50 <mniip> Spriithy, can I look at the def of Node and Leaf?
16:44:04 <Spriithy> mniip: sure -> data Tree a   = Leaf a   | Node a [Tree a]
16:45:31 <mniip> ok
16:46:23 <mniip> Spriithy, you could sortBy isNode or something
16:46:31 <mniip> sortOn rather
16:46:47 <mniip> sortBy (comparing isNode)
16:48:43 <Spriithy> what packages are these in ?
16:48:49 <Spriithy> they ain't in Prelude iirc
16:50:46 <mniip> Data.List
16:50:51 <mniip> module from the base package
16:51:06 <mniip> comparing is Data.Ord I think
16:51:13 <mniip> might be List or Monoid but not sure
16:51:52 <EvanR> modeling a "pure" download situation, data Download = Chunk ByteString Download | Complete | Failed Error
16:51:59 <EvanR> is this reinventing something
16:52:04 <Welkin> erisco: I've done it! :D
16:52:12 <Welkin> It looks like I just made a stupid mistake before
16:52:18 <Welkin> but I'll be interested to see your process
16:52:24 <Welkin> mine is still kind of messy
16:52:30 <Spriithy> anyways I'm off to sleep
16:52:37 <Spriithy> thank y'all
16:52:50 <Welkin> I apply the first parameter, unify that part of the type, eliminate that part of the type, then substitute
16:52:51 <mniip> EvanR, FreeT (ByteString,) (Either Error) ()
16:52:52 <mniip> :D
16:54:28 <pacak> Hmm... Are tuple sections valid on type level? O_o
16:55:03 <mniip> I don't know
16:55:06 <mniip> unlikely
16:55:21 <mniip> :k ((),)
16:55:22 <lambdabot> error: parse error on input ‘)’
16:55:24 <erisco> Welkin, mine is not so great either because I don't know a formal way to lay out the process
16:55:29 <erisco> Welkin, anyways, here goes http://lpaste.net/357374
16:55:32 <pacak> Umlikely.
16:55:37 <pacak> Unlikely.
16:57:41 <EvanR> mniip: this is a funny instance of a free monad not being something like an imperative program with a set of commands
16:58:04 <mniip> I've never actually known what free monads are actually for :p
16:58:11 <EvanR> its a download whose behavior depends on quantum physics of fiber
16:59:03 <monochrom> EvanR: Basically every incremental parser library and every streaming library reinvents that.
16:59:04 <mniip> EvanR, if you look closely at the loop quantum gravity strings you can see recursion schemes and van laarhoven lenses
16:59:07 <EvanR> the outside universe makes up its mind on what the "continuation" is
17:01:04 <EvanR> whats the relation between this and parsing
17:01:08 <EvanR> or its just used for the input to a parser
17:01:40 <mniip> I suppose given the adjunction between reader and writer
17:02:38 <mniip> EvanR, also if you use EitherT IO, you can stick IO inbetween chunks for real
17:03:13 <EvanR> why would i do that
17:03:32 <EvanR> somehow the download is telling me what IO to do?
17:03:58 <mniip> no but to obtain the download you do IO
17:03:59 <erisco> mniip, did you find how to enumerate the sentences?
17:04:05 <mniip> erisco, yes
17:04:20 <EvanR> i do not know if thats true
17:04:29 <EvanR> the consumer cant tell if its true
17:04:40 <mniip> if you hoistFreeT Omega before enumerating you get a nice finitely enumerable answer
17:05:10 <erisco> enumerating the sentences is easier than the parser, so the answer should be within what you already have
17:05:33 <mniip> erisco, no like
17:05:36 <EvanR> i wonder what the precise justification is for producing a Download using unsafeInterleaveIO is
17:05:40 <mniip> if you have a concatenation of two infinite languages
17:05:48 <mniip> you need diagonalization to enumerate them both
17:06:03 <mniip> EvanR, and inside runQ
17:06:06 <erisco> you don't need that specifically, but you need some way to merge them, yes
17:06:29 <mniip> EvanR, now, actually, hold on a sec
17:06:46 <erisco> interleave folded over infinite lists is exponentially biased to the left, but it still works
17:07:46 <erisco> and if you just take the diagonal across two factors then that also works, but it is also biased based on your associativity
17:07:48 <mniip> EvanR, even better, when/if we have dependent types
17:08:17 <mniip> I've asked goldfire about promoting primops and he's said he has nothing against promoting unsafePerformIO and the like
17:08:24 <erisco> because (a * b) * c will treat a * b as just a list and a * (b * c) will treat b * c as just a list
17:08:54 <erisco> which is what ZigZag does differently, it does not treat those differently
17:10:45 <erisco> it is magically aware of how many factors it is finding the product of... spooky!
17:11:11 <hpc> /the killer was in the type system the whole time!/
17:12:29 * hackagebot union 0.1.1.2 – Extensible type-safe unions – https://hackage.haskell.org/package/union
17:12:30 <mniip> foo :: () -> (case print "hi" of IO m -> case m realWorld# of (# s, r #) -> r)
17:13:37 <hpc> is this the new face of template haskell?
17:13:46 <c_wraith> when do we get to promote all the types with simple native representations? 
17:14:21 <c_wraith> you can't even promote negative numbers right now. 
17:14:31 <c_wraith> let alone Float/Double
17:15:19 <erisco> the thing that drives me nuts is you cannot promote constructors which have constraints
17:15:35 <erisco> why? because if you're doing this sort of stuff you've probably got SingI constraints all over the place
17:16:23 <erisco> so now you have to choose... do I want types and a kind or do I want terms and a type...
17:16:30 <mniip> erisco, I'm fairly sure with TypeInType you can?
17:16:36 <erisco> nope
17:16:58 <erisco> and if you think of defining two versions of your data then sure, that works, but you have to find different names for everything...
17:17:28 <c_wraith> TypeInType allows promoting equality constraints, but apparently not any other constraints. 
17:24:44 <erisco> so I am in a struggle right now ... Haskell is a great language and I am familiar with it, but the type system is not strong enough (or at least not practical enough) for some things I wish to do
17:25:01 <erisco> not really strictly necessary things... but in the same way FP is not strictly necessary... but who wants to live without it
17:25:42 <erisco> and there are languages with stronger type systems but they're either not practical for programming or still too young
17:26:13 <EvanR> one day we will only have to specify the types
17:26:39 <EvanR> then a team of researchers will get back to us in maybe 9 years with the implementation
17:26:42 <erisco> which is why I thought to overcome Haskell's limitations with an eDSL wherein I embed the types of the language as *terms* in Haskell, or at least the part Haskell cannot do
17:27:07 <erisco> so for example I might have MyInt which holds an Int, but as a term I might have 0 < x < 100
17:27:09 <drewbert> @EvanR lol
17:27:10 <lambdabot> Unknown command, try @list
17:27:16 <drewbert> EvanR: lol
17:27:25 <erisco> then when interpreting or compiling this eDSL I can check and infer types
17:27:46 <erisco> the problem is that I'd be doing a lot of work to support that, and it seems a bit silly when other languages natively do so
17:28:01 <Welkin> erisco: you mean dependent types like idris?
17:28:07 <Welkin> but haskell is getting dependent types soon
17:28:35 <Welkin> erlang has some cool type features like that too
17:28:36 <erisco> winter is also coming soon, by some time scale, but I can't wait that long
17:28:52 <nisstyre> Welkin: "soon"
17:29:00 <EvanR> MyInt is really a regular Int paired with a Betweenness criteria
17:29:05 <nisstyre> the same way I'm becoming a millionaire soon right?
17:29:45 <erisco> you can have bounded naturals in Haskell, and I presume you can put together integers as well, but it is cumbersome right now
17:29:57 <arahael> EvanR: I'd call that a BoundedInt, then.
17:30:05 <EvanR> i cant imagine dependent types will make the code for this anywhere near as nice as a smart constructor
17:30:11 <erisco> and I have not really had the chance to explore how practical it is to work with these types in Haskell because it is so bothersome to get them defined
17:30:20 <EvanR> arahael: BoundedInt with no arguments?
17:31:05 <erisco> well, I don't care if it is DTs or something else, it is just that some things either not possible or not practical in Haskell at the moment
17:31:05 <arahael> EvanR: I don't know how you're using it, but BoundedInt expresses the intention much better than "MyInt" does.
17:31:05 <EvanR> you could do BoundedInt a b = (i : Int, i `Between` a b)
17:31:35 <EvanR> the important part being you really do have a regular Int if you need it
17:31:47 <EvanR> because most functions take Int
17:31:49 <erisco> arahael, this scrutinizing a single grain of sand on the beach right now
17:32:10 <EvanR> grains of sand look pretty weird
17:33:28 <erisco> EvanR, it is a deep embedding, so the integers are actually symbolic
17:33:40 <erisco> EvanR, it will take work to show it is actually in bounds
17:33:45 <arahael> erisco: Fine, I'll back out of this bikeshedding, then.!
17:34:20 <Welkin> you forgot your bicycle!
17:40:46 <erisco> that is why I would rather just use a type system that has already implemented this ... unusual for me I guess
17:41:48 <erisco> could also chuck it into Z3 but last time I used it I got a sour taste...
17:42:22 <erisco> not to mention it is what liquidhaskell uses and last I checked they were boasting 10 minute compile times
17:43:05 <EvanR> yes proving bounds sounds like not fun
17:43:52 <erisco> in a theorem prover you sometimes can just write in "auto" or whatever their "try everything and the kitchen sink" tactic is
17:43:58 <Welkin> erisco: still better than 3 hours like in c++
17:44:23 <EvanR> i doubt that will work for general bounds like ... i have here a number between -5 and +5
17:44:31 <EvanR> does it fit in this spot
17:44:50 <EvanR> i doubt it will work even in "simple" cases like 0 to n-1
17:44:52 <erisco> maybe... insane but maybe I can offload the type checking to another language
17:45:05 <erisco> if I could send it to Z3 I could also send it to any language compiler
17:46:41 <erisco> with a theorem prover you can be more or less verbose as necessary ... so a close mapping with that might solve most of my problems
17:46:48 <erisco> wouldn't have to actually design a type system
17:46:57 <erisco> or any solvers
17:47:42 <erisco> which makes me wonder if there is already software that presents this sort of type checking as a service to other programs
17:48:06 <erisco> like Z3 has a particular interface for IPC
17:48:07 <EvanR> math people are laughing at us because their proofs are like 3 sentences long for simple things
17:48:15 <EvanR> or less
17:48:23 <EvanR> or "its obvious"
17:48:40 <Clint> ∴ maths
17:49:19 <nisstyre> EvanR: except the four colour theorem
17:50:28 <erisco> EvanR, I am still in the phase where proving bounds is fun...
17:50:45 <erisco> my first week of work was the most self-ware honeymoon period I have ever experienced
17:51:21 <erisco> thrilled to be out of school and getting paid to do something and yet entirely aware that months later the sparkles will be gone...
17:52:16 <erisco> what the mind knows has little bearing on what it feels
17:54:15 <erisco> mniip, if you want something possibly challenging but meaningful to do then I suggest adding sharing to your parser so that it is polynomial on ambiguous grammars
17:54:39 <erisco> mniip, that was some of the work one of my profs did, though I think that got published as a Python library
17:54:58 <erisco> but also an avid Haskell user... not sure if that parser was ported to Haskell or not
17:55:45 <erisco> he was using it as part of NLP which involves highly ambiguous grammars, from what little I grasped of it
17:56:19 <erisco> "highly" I presume meaning that ambiguity is the point of it rather than an accidental slip in your grammar design
17:56:39 <Welkin> erisco: out of school? I thought you were already working fulltime long ago
17:56:52 <mniip> erisco, I'm really not sure what's the algorithms that are involved
17:56:52 <erisco> Welkin, yeah, that is true
17:57:00 <mniip> only had language theory as a passing course
17:57:27 <erisco> mniip, what you already have in bang on the right track
17:58:01 <erisco> mniip, what you need to add, or at least this is one idea, is a memo table for what you have already parsed
17:58:16 <Welkin> erisco: what was your "honey moon period"
17:58:51 <mniip> erisco, what would such a memo table contain
17:59:14 <erisco> the various parse trees share a great amount of subtrees, and that is how you get the polynomial behaviour
17:59:33 <erisco> the work has been to shave the exponent
18:00:26 <erisco> mniip, I didn't get to dig into the guts of his parser, but based on my own thinking it would at least be the nonterminal paired with the position
18:00:27 <mniip> yes but my thing is effectively already bascially a prefix tree
18:00:37 <erisco> then mapped to the parse tree, of course
18:02:15 <erisco> of course, the nonterminals are not opaque, so that would require something substantially different
18:03:20 <erisco> Welkin, the first week of work
18:03:49 <Welkin> why, what happened?
18:04:01 <Welkin> did you get to use haskell?
18:04:09 <erisco> lol, no
18:04:27 <Welkin> they finally started using version control?
18:04:27 <erisco> honestly I hated school, a lot, and it was tearing me up... being out was a huge relief
18:04:34 <erisco> what I had to work on was irrelevant
18:07:15 <erisco> mniip, it won't be sharing trees though
18:12:27 <erisco> mniip, one idea I had was to run the parser from the right
18:12:44 <erisco> you would parse every suffix until you had the whole string
18:13:05 <erisco> so by the time you go to parse the first token you've already parsed the rest
18:14:22 <erisco> it doesn't work out so simply once you scrutinize it, though
18:36:40 <EvanR> and... foldDownload :: Monoid m => (ByteString -> m) -> (Error -> m) -> Download -> m  ?
18:36:56 <EvanR> or is this a pain in the ass
18:38:23 <EvanR> maybe should be a scan so you get intermediate states
18:50:19 <erisco> okay... maybe I do this in another language but serialise the eDSL, load it with Haskell, then use Haskell to do code generation
18:51:41 <erisco> though the point of that is to use one of the Haskell libraries like Atom... doesn't look to me like Atom does parallelism thoug
18:54:10 <erisco> wasn't there a couple libs? Atom is one... can't remember the other
18:54:56 <EvanR> http://lpaste.net/357375
18:55:04 <EvanR> my fold and scan look backwards at first
18:55:16 <EvanR> but for a finite stream of chunks... monoid laws says its the same... i think
18:55:23 <EvanR> what about infinite stream
18:55:56 <erisco> there's imperative-edsl for generating C
18:59:06 <Welkin> it's called ivory
18:59:27 <Welkin> http://hackage.haskell.org/package/ivory
18:59:30 <erisco> yup, thanks
19:12:36 <mniip> so uh
19:12:42 <mniip> no one really checked out yahb :(
19:12:58 <mniip> which is an awesome haskell interpreter that can do IO
19:15:24 <EvanR> yahb yah say
19:21:08 * hackagebot papillon 0.1.0.5 – packrat parser – https://hackage.haskell.org/package/papillon
19:37:20 * hackagebot http-media 0.7.1.1 – Processing HTTP Content-Type and Accept headers – https://hackage.haskell.org/package/http-media
19:42:04 <mniip> yeah
19:42:24 <mniip> see
19:42:32 <mniip> % foldr (+) 0 [1..5]
19:42:32 <yahb> mniip: 15
19:42:37 <mniip> regular haskell stuff
19:44:02 <mniip> has lens stuff as well
19:44:04 <mniip> % :t conjoined
19:44:04 <yahb> mniip: conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
19:44:28 <glguy> % :i iso
19:44:28 <yahb> glguy: iso :: (s -> a) -> (b -> t) -> Iso s t a b -- Defined in `Control.Lens.Iso'
19:45:00 <glguy> That'll be nice; ":i" is better for looking at types for lens package definitions
19:45:15 <mniip> it is?
19:45:22 <glguy> it is
19:45:23 <mniip> does tcrn rename any tyvars?
19:45:46 <glguy> % :t iso
19:45:46 <yahb> glguy: iso :: (Functor f, Profunctor p) => (s1 -> a1) -> (b1 -> t1) -> p a2 (f b2) -> p s2 (f t2)
19:46:22 <mniip> ah it expands the type synonym
19:47:20 <mniip> this is pretty straightforwardly a ghci session for anyone wondering
19:47:34 <mniip> most of the quirks/features apply
19:51:17 <EvanR> % 1 % 1
19:51:17 <yahb> EvanR: 1 % 1
19:51:33 <EvanR> % (+1)
19:51:33 <yahb> EvanR: ; <interactive>:10:1: error:; * No instance for (Show (Integer -> Integer)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
19:51:44 <EvanR> % undefined
19:51:44 <yahb> EvanR: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:11:1 in interactive:Ghci4
19:51:50 <ab9rf> %
19:51:50 <yahb> ab9rf: 
19:51:57 <EvanR> very zen
19:52:07 <dramforever> What happened
19:52:28 <EvanR> its like hitting enter on the shell
19:52:40 <dramforever> I mean, what's the deal with yahb
19:52:46 <pacak> % fix error
19:52:49 <yahb> pacak: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
19:53:03 <dramforever> LOL
19:53:17 <pacak> > fix error
19:53:19 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:53:29 <pacak> Hmm... They seems to disagree a bit.
19:53:51 <ab9rf> they agree within the limitations of reported precision
19:54:22 <pacak> *** vs *. I wonder what versions of ghc they are...
19:55:00 <glguy> % "λx"
19:55:03 <yahb> glguy: 
19:55:31 <Hafydd> % "\nPRIVMSG #haskell :Hello."
19:55:33 <yahb> Hafydd: "\nPRIVMSG #haskell :Hello."
19:56:02 <iqubic> Are these all new bots?
19:56:07 <dramforever> % putStrLn "stuff"
19:56:07 <yahb> dramforever: stuff
19:56:20 <dramforever> % putStrLn "\r\nPRIVMSG #haskell:stuff"
19:56:20 <yahb> dramforever:  ; PRIVMSG #haskell:stuff
19:56:34 <dramforever> % putStrLn "a\nb\nc\nd\ne"
19:56:34 <yahb> dramforever: 
19:56:40 <pacak> % unsafePerformIO (system "rm -rf /")
19:56:43 <yahb> pacak: ; <interactive>:1:18: error: Variable not in scope: system :: [Char] -> IO a
19:56:45 <dramforever> ???
19:56:53 <dramforever> % putStrLn "\nPRIVMSG #haskell:stuff"
19:56:53 <yahb> dramforever: ; PRIVMSG #haskell:stuff
19:57:08 <dramforever> Sorry for that spam, will stop
19:57:14 <Hafydd> Not that it matters, but there should be a space before :.
19:57:23 <iqubic> Is yahb a new bot?
19:57:29 <glguy> You can try to break yahb in /msg rather than in channel
19:57:41 <dramforever> doing that, thanks
19:58:00 <glguy> Or at least I imagine it’s OK to try and break it
19:58:34 <pacak> % unsafePerformIO (return ())
19:58:34 <yahb> pacak: ()
19:58:38 <pacak> Brave.
19:58:41 <pacak> Or stupid.
19:58:44 <pacak> Or both.
20:01:03 <mniip> sure is
20:03:01 <iqubic> Why do we have both lambdabot and yahb?
20:04:16 <Axman6> % unsafePerformIO (print True)
20:04:16 <yahb> Axman6: 
20:06:02 <mniip> glguy, trying to figure out what's the deal with that unicode...
20:06:48 <glguy> % 42
20:06:49 <yahb> glguy: hii; nterrupting cow; 42
20:07:01 <mniip> eh, threads...
20:14:18 <dramforever> Rant: I appreciate the effort, but -ddump-json u no escape quotes???
20:14:24 <dramforever> sorry
20:15:11 <Axman6> hmm, does Gabriel Gonzalez hang around on IRC? I can't remember his nick if he does
20:16:52 * hackagebot dhall 1.5.1 – A configuration language guaranteed to terminate – https://hackage.haskell.org/package/dhall
20:22:52 <mniip> ok for whatever reason it's not flushing properly...
20:23:08 <mniip> might be a race condition
20:31:33 <mniip> no, this can't be
20:31:44 <mniip> an encoding problem? in 2017?
20:34:45 <XorSwap> @pl \(x,y) -> [x,y]
20:34:45 <lambdabot> uncurry ((. return) . (:))
20:46:50 <erisco> if they made a list section syntax extension you could write uncurry [,]
20:47:17 <jle`> i remember iceland_jack had a list sections extension implemented for ghc that was never submitted
20:47:49 <mniip> ugh
20:47:59 <mniip> maybe tomorrow :s
20:48:10 <mniip> it's just not writing the right bytes for some reason
20:48:47 <jle`> Axman6: he's Tekmo
20:48:57 <jle`> he used to be on often but isn't as much these days
20:52:37 <Axman6> jle`: ah yes, thanks
20:58:25 * hackagebot sensu-run 0.4.0 – A tool to send command execution results to Sensu – https://hackage.haskell.org/package/sensu-run
21:03:22 <erisco> I don't know much about parallelism... what is the status of automatic parallelism versus explicit?
21:04:12 <jle`> erisco: status as in implementation?
21:04:21 <jle`> or like, what people think about one or the other
21:04:32 <erisco> the latter
21:04:42 <jle`> from what i've seen, most haskellers seem to prefer explicit parallelism
21:05:46 <erisco> can't the compiler more accurately figure out your data dependencies, costs, and parallelise accordingly?
21:09:34 * hackagebot effin 0.3.0.3 – A Typeable-free implementation of extensible effects – https://hackage.haskell.org/package/effin
21:09:49 <c_wraith> erisco: in general...  no.
21:12:29 <erisco> because it doesn't know the sizes of things? well, say you had that information in the type
21:12:58 <erisco> is that the crux of the problem or is it something else?
21:13:34 <c_wraith> No.  Mostly because that sort of static analysis becomes *huge* if you try to do it exactly.  If you do it conservatively, it tends to miss the best uses.  If you do it liberally, it tends to make things slower.
21:14:56 <c_wraith> At the moment, no one (at least publicly) knows of a technique that has better results than having an expert spend some time on the problem.
21:15:53 <jle`> data dependencies the compiler can figure out, costs...maybe
21:15:58 <jle`> not in the general case
21:16:07 <jle`> and making the call when to parallelize is also difficult in the general case
21:16:16 <jle`> i'm just repeating what c_wraith said at this point tho
21:19:38 <pacak> erisco: If you can propose step by step algorithm how to transform arbitrary computation into a parallel one (without "a miracle occurs" part in the middle) - I'm sure it can be implemented. The problem is it's hard to do it even by hands and even when you looking at a very specific example.
21:20:38 * hackagebot monoid-subclasses 0.4.4 – Subclasses of Monoid – https://hackage.haskell.org/package/monoid-subclasses
21:22:01 <nshepperd> defer the decision to runtime? have some performance measurements in the running program, then randomly switch between evaluation strategies until the metrics improve :p
21:22:17 <pacak> erisco: imagine having a string "12345678901234567890123456789012345678901234567890" (as something in memory, a ByteString or Ptr) and you have to split it into 8 parts - and parse as 4 tuples (1234, 56789)
21:22:23 <Xandaros> I have a System.Posix.IO.Fd and a Data.ByteString.ByteString. Any way I can write said ByteString to the file descriptor?
21:22:31 <erisco> you don't need to wait until runtime
21:22:55 <pacak> nshepperd: Congrats, you just invented a derpy JIT.
21:23:01 <dmj`> Xandaros: convert it to Handle
21:23:04 <nshepperd> :D
21:23:52 <Xandaros> dmj`: Thank you! :D
21:24:02 <erisco> pacak, so how does your example end?
21:24:05 <dmj`> Xandaros: sure :) 
21:24:23 <pacak> A function ByteString -> [(Int, Int)]
21:24:49 <nshepperd> you can implement some level of parallelism by spamming sparks everywhere
21:25:10 <nshepperd> the question is where *not* to put sparks so that you don't spend 99% of computation just creating sparks
21:25:13 <pacak> I have a task where I need to construct a bunch of such parsers and I ended up writing corresponding AVX primitives and combining stuff from those.
21:25:30 <pacak> nshepperd: On this specific task you'll waste more time creating those sparks.
21:26:10 <erisco> okay, sure, what does this example tell us about parallelism
21:26:57 <pacak> That it's hard to do even if you know all about data, patterns and willing to support only one specific CPU.
21:27:27 <nshepperd> simulated annealing (what i suggested), or deep learning or something might work, to solve that problem. though it's still basically a way of saying "a miracle occurs"
21:27:48 <nshepperd> an expensive inefficient miracle
21:28:25 <pacak> I don't mind expensive miracles if I can enable it via -O111
21:28:45 <pacak> It takes 10 hours to compile but runs twice as fast? I'll take it.
21:28:47 <erisco> I just thought you were trying to show something specific with the example
21:29:57 <pacak> erisco: Yes. This specific example offers a bunch of stuff that can be computed at the same time. There's no dependencies between data, all you need to do is to read 8 numbers (and confirm that those are actually numbers).
21:30:04 <pacak> But it's hard.
21:30:53 <erisco> okay, well, I am not sure how it clarifies it being hard
21:31:11 <pacak> Hmm... How would you solve it?
21:31:13 <nshepperd> yeah, that sounds like the sort of parallelism you can't extract by using `par`
21:31:57 <nshepperd> you would need simd or something
21:32:40 <nshepperd> (maybe an OOO superscalar like an x86 already extracts that parallelism, if you write the code in the right way?)
21:33:40 <erisco> the point of parallelism, at least from what I can tell, is time
21:34:46 <erisco> so, you need to model program cost. the details of which I am not certain but this analysis can be done statically
21:34:55 <pacak> simd worked nicely. branch prediction kind of helped when i was generating loops in naive way. Loop unrolling, etc.
21:34:58 <nshepperd> for a small task like that, any kind of multi threading is probably a wash, because you will spend more time on the scheduling, than whatever small number of cycles actually reading the numbers
21:35:15 <erisco> there are unknowns about IO which you can assert to whatever degree of certainty you want, nothing special there
21:36:07 <pacak> erisco: Certainly. There's a bunch of different CPUs, a bunch of different cases. How much data you have? Is it all in L1? Or in L3? Or it only fits in main memory?
21:36:45 <pacak> a single mov can be anywhere from 1 tick up to (is it 100+ those days?)
21:37:13 <erisco> then the fundamental idea is that if program P costs X and program Q costs Y, then sequencing them costs X + Y, but parallelising them costs max(X,Y) + K where K is a constant cost of parallelisation
21:37:54 <erisco> now you have to minimize program cost by choosing where parallelisation happens
21:37:55 <pacak> No.
21:38:10 <erisco> at least that is the fast and loose framework I'd begin thinking about
21:38:23 <pacak> If both P and Q demand full size of L3 to work then running them in parallel will take more than max(X,Y).
21:38:28 <pacak> Even more than X+Y
21:38:38 <erisco> L3? CPU caches are not at all relevant here
21:39:29 <pacak> But they are. CPU cache is real. It doesn't matter if your cpu can perform 100500 operations per tick. If there's no data to operate on - it won't do anything.
21:39:37 <pacak> Memory access is expensive
21:39:45 <erisco> you're too far in the weeds then
21:40:11 <erisco> yes, if you start including every detail about how a particular computer works then I imagine it becomes unbearably complicated
21:40:29 <pacak> Probably. I'm spending a lot of time optimizing code because it helps in our case.
21:41:29 * hackagebot rank2classes 0.2 – a mirror image of some standard type classes, with methods of rank 2 types – https://hackage.haskell.org/package/rank2classes
21:43:09 <erisco> you're even making the assumption these programs are running on the same CPU
21:43:31 <erisco> parallelism is simply two things happening at the same time, that's all
21:43:57 <pacak> I am. Otherwise it's communication between different CPUs on the same machine or between different machines - that's latency.
21:45:37 <erisco> we can add latency to the mix, or CPU caches, or whatever other details, but having a basic picture correct first is the place to start
21:45:51 <nshepperd> such latency might or might not matter depending how large the work units are
21:47:06 <nshepperd> many programs have different levels at which things might be parallelizable
21:47:48 <pacak> Right. One more unknown for autoparallelizer to worry about.
21:48:12 <nshepperd> at the smallest work units, a hot loop with seven instructions, you would probably use simd or multiple instruction issue and hope for functional unit parallelism
21:48:39 <nshepperd> at the highest level you are running individual 15 minute jobs on different machines and you really won't care about inter-cpu latency
21:49:13 <erisco> well I can see why I might find the question more simple and others not :P
21:50:22 <nshepperd> but you may be able to solve one level of parallelism separately from the others
21:51:14 <nshepperd> my cloudhaskell mapreduce framework or whatever doesn't have to know have to insert SSE instructions, to provide value
21:52:32 <pacak> If you have a luxury of not having to bother about sub-millisecond latencies - that's nice :)
21:55:20 <nshepperd> the luxury of having problems so difficult you can't solve them within milliseconds ;)
21:57:55 <nshepperd> but actually i'm just saying that a sensible structure for such a system would be something hierarchical that treats each level separately. there's no need to be thinking about SIMD when you're wondering whether to schedule a job on one machine or three machines
21:57:55 <pacak> So are ours. It takes longer than that to solve, but using a miracle it's possible to react within a 100us.
21:58:17 <pacak> Right.
21:58:32 <nshepperd> and then once you've made the higher level decisions, you start worrying about cache size and ILP
21:58:36 <erisco> a millisecond is two weeks of work for a computer, that's a lot
21:58:51 <pacak> I don't think a general compiler can solve a problem of distributing stuff between machines.
21:59:53 <erisco> you're wrong
22:01:06 <pacak> You have two loops as a compiler. With all the source code. Do you know which one finishes first?
22:01:22 <erisco> do you?
22:01:25 <pacak> Nope
22:01:44 <kadoban> pacak: Sometimes
22:01:57 <pacak> kadoban: That's a good answer.
22:02:28 <erisco> well if you don't know and we can't know then I don't see the problem, other than we like to wish for stuff
22:02:38 <nshepperd> compilers already make kind of similar judgements when deciding whether to inline something
22:02:45 <nshepperd> it's heuristics all the way down
22:03:36 <pacak> \x -> if odd x then x * 3+ 1 else x `div` 2 ....
22:05:42 <erisco> I did say lets assume we know the costs
22:05:57 <erisco> if we don't know the costs, or can't know the costs, it isn't a sensible target for parallelism anyways
22:06:22 <erisco> if parallelism is going to be about reducing time cost then we have to know what the time cost is
22:07:15 <kadoban> This is about when you start wishing you were a JIT instead of a compiler. But then you have to try to figure out *why* something is slower/faster if it is. So ... ugh.
22:07:32 <nshepperd> just run the program, and measure the costs!
22:07:55 <erisco> that is a possible measurement, but it isn't necessarily the cost you want
22:08:30 <erisco> differently machines will behave differently, and may even run the same program differently, so you might want a different idea of what something costs
22:08:35 <nshepperd> when a human is distributing stuff between machines, they tend to use pretty crude heuristics
22:08:55 <nshepperd> "this part of the program runs for about 20 minutes"
22:09:27 <nshepperd> you don't need to pretend you can solve the collatz conjecture
22:09:43 <erisco> if you were to have an online algorithm that adjusted the parallelism to optimise running time then that'd be quite interesting though
22:15:17 <nshepperd> build systems that do parallel compilation tend to recommend "set the number of jobs to ${alpha * number of cpus}" where alpha is empirically chosen to trade off iops vs cpu vs memory vs cache most efficiently. it's pretty crude, but it outperforms doing everything sequentially
22:17:38 <erisco> has a bound relative to the size of starting number been found for Collatz Conjecture? would be interested to know
22:21:58 <kadoban> erisco: Well, it's not even known if it's finite, right, in terms of stopping time. And I don't think it's known if either cycles exist (that don't contain 1) or any go to infinity. So, I don't think so.
22:23:05 <erisco> if cycles existed that would disprove the conjecture ... cycles are known for variations of and also for negatives, but the conjecture is on non-negatives
22:23:40 <erisco> the bound would be on the hypothesis that if the number did converge to 1, it must do so in at most some number of steps
22:23:55 <kadoban> Ah
22:23:59 <erisco> so that fact would not discharge the question of whether all numbers actually converge
22:24:24 <erisco> but, might have some fun insight, who knows
22:24:58 <kadoban> That I'm not sure of. The only bounds I could think of were pretty close to solutions of the conjecture itself, but that one sounds more interesting/possible.
22:39:22 <nshepperd> https://oeis.org/A006577
22:50:54 * hackagebot cmark-gfm 0.1.0 – Fast, accurate GitHub Flavored Markdown parser and renderer – https://hackage.haskell.org/package/cmark-gfm
22:51:38 <jle`> oh hey, bitraversable is in base now
22:51:39 <jle`> neat
22:51:49 <jle`> i wonder what other neat things are in base that i didn't hear about
22:52:45 <jle`> but still no MonadIO instance for Proxy
22:52:51 <jle`> baby steps i suppose
22:53:14 <jle`> also still no proper non-orphan Alternative instance for Either
22:55:54 <jle`> fromLeft and fromRight are in Data.Either, which i found out by accident earlier today, but they weren't exactly what i was expecting
22:56:10 <pacak> :t fromLeft
22:56:11 <lambdabot> error:
22:56:12 <lambdabot>     • Variable not in scope: fromLeft
22:56:12 <lambdabot>     • Perhaps you meant one of these:
22:56:20 <jle`> liftA2 added to Applicative
22:56:23 <jle`> i'm happy with this
22:57:55 <jle`> Nat now reifies/reflects with Natural instead of Integer, which is nice i guess
22:58:30 <jle`> i should be taking this as good news, but i just don't like Natural very much
22:59:52 <jle`> thank you ghc libraries team
23:01:00 <jle`> AppendSymbol is nice but we really need a Take to be able to give us native type-safe printfs.
23:01:33 <jle`> that concludes this broadcast of jle`'s review of base 4.10, thanks for listening
23:01:41 * pacak still uses 7.10.1 + some fixes on top
23:02:13 <jle`> but how do you live without type applications
23:02:18 <pacak> Because some mysterious performance regressions. I guess I need to figure them out at some point.
23:02:57 <pacak> There's a bunch of nice stuff I'm missing.
23:03:15 <jle`> regressions in compilation, or of programs?
23:03:25 <pacak> programs
23:04:06 <jle`> i've heard that ghc 8.2 has some major improvements in performance over ghc 8.0, but i'm not sure if people are talking about compilation speeds or of the speed of the programs it compiles
23:04:21 <pacak> There was one regression in compilation (ghc used only 24 bits for uniq variables what wasn't enough in our codebase), but that was fixed.
23:04:59 <pacak> overflowing unique usually id resulted in all sorts of crazy type errors after 10-15 minutes of compilation :)
23:10:32 <jle`> i wonder if the new ghcs fix that?
23:14:25 <pacak> Still there in 8.2.1. Need to debug and report.
23:26:09 <Xandaros> I have an "A". I need a "Ptr A". What am do? :D (A is my own type based on a C struct. It has a Storable instance)
23:28:46 <pacak> Allocate some memory
23:28:54 <pacak> store it
23:29:10 <pacak> Foreign.something
23:29:28 <pacak> :t poke
23:29:30 <lambdabot> error: Variable not in scope: poke
23:29:58 <pacak> :t alloca
23:29:59 <lambdabot> error: Variable not in scope: alloca
23:30:40 <Xandaros> Ah, nice. I'll try that, thanks
23:30:42 <pacak> If you want to pass it to C you'll need to store it somewhere GC can't  touch it.
23:31:19 <Xandaros> passing it to C would be the plan, yes
23:31:47 <pacak> Foreign.*
23:31:53 <pacak> A bunch of useful stuff.
23:32:53 * hackagebot doctest 0.13.0 – Test interactive Haskell examples – https://hackage.haskell.org/package/doctest
23:35:35 <Xandaros> Next question: I have an Int and I need some kind of Ptr :D
23:36:50 <Xandaros> I guess I could have another foreign import with the argument being a CInt... Not sure I like that, though
23:37:59 <pacak> Int in haskell is not the same as int in C.
23:38:03 <pacak> So CInt.
23:38:25 <pacak> :k Ptr
23:38:27 <lambdabot> error:
23:38:27 <lambdabot>     Not in scope: type constructor or class ‘Ptr’
23:38:39 <pacak> * -> * seems like a good kind of Ptr anyway.
23:38:40 <Xandaros> Well, sure, but CInt is not going to unify with "Ptr a", is it?
23:38:56 <pacak> There's castPtr
23:39:22 <Xandaros> Ptr a -> Ptr b. Doesn't help much
23:40:12 <pacak> What's the problem exactly?
23:41:24 <Xandaros> The foreign function sometimes takes pointers and sometimes ints. (Disguised as pointers) So I want to turn an Int (or CInt, or Int32 or whatever) into a Ptr a to give it to it
23:49:06 <boj> Gotta run Gotta run Gotta run Gotta run Gotta run Gotta run Gotta run Gotta run ss eeeev e 
23:49:59 <ongy> Xandaros: https://hackage.haskell.org/package/base-4.10.0.0/docs/Foreign-Ptr.html#t:IntPtr
23:50:39 <Xandaros> ongy: Thanks!
23:50:40 <Axman6> Xandaros: that sounds horrific
23:51:55 <Xandaros> It does, but this way my foreign import represents the actual function. I have two wrapper functions, though
23:52:55 <Axman6> import it wtice?
23:52:58 <Axman6> twice*
23:53:22 <ongy> I did see IntPtr at one point and was wondering what it's used for. Now I know :D
23:59:21 <nshepperd> ints disguised as pointers? aiieeee
