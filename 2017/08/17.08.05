00:00:28 <geekosaur> MichaelBurge_, yes because they are constructors and pattern matches match structure. if you can't phrase it as a case, you'd need to use some form of generics
00:01:15 <MichaelBurge_> Yeah, plenty of practical ways to solve the problem. Was just thinking it was weird to have this "hidden" operator in the language
00:01:36 <MichaelBurge_> Though it's probably built into the lower-level ones
00:02:01 <glguy> it's not hidden, pattern matching is how the eq instance would be implemented
00:02:25 <geekosaur> it's not hidden, since case exposes it. but it exposes it as it is; it's not just a funny looking (==)
00:02:38 <geekosaur> as I said, patterns match structure and constructors make structure
00:02:39 <MichaelBurge_> Hidden in the sense that there is no "pattern-match equality" operator that you can use, though there is special syntax that lets you access it
00:03:16 <nshepperd> it's not really a form of equality though. not between Xs anyway
00:03:16 <geekosaur> when you have something like data X = A | B this may not be obvious
00:03:37 <geekosaur> when it's data X = A Double Char | B Int String, it is a bit more obvious what is going on
00:04:05 <glguy> == is just another function, not special beyond any other one other than being part of a type class
00:06:05 <glguy> I suppose it's uniqueness comes from some syntax desugaring to it, but it doesn't have a special way of comparing values available to it
00:10:16 <MichaelBurge_> Yeah, it looks like a regular pattern match interleaves the structural and Eq style equalities, which was throwing me off: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
00:10:51 <MichaelBurge_> For example, "case X of A 5 -> ..." sure looks like it's doing an equality check and not just a structural one, but it looks like it does desugar to a ==
00:11:14 <geekosaur> right, numbrs and strings are special cased
00:11:47 <geekosaur> because in some sense a number like 5 behaves like a constructor, but it's actually a function (because numeric literals desugar to applications to fromInteger)
00:12:09 <geekosaur> er, applications *of* fromInteger
00:24:44 <knupfer> Any reddit moderator here? It seems that my post triggerd the spam filter...
00:29:45 <butterthebuddha> How's it going guys
00:30:00 <butterthebuddha> http://lpaste.net/357433
00:30:07 <butterthebuddha> ^ that's what I have so far for problem 2 at https://www.seas.upenn.edu/~cis194/spring13/hw/06-laziness.pdf
00:30:19 <butterthebuddha> The issue is that the problem wants me to generate an infinite list
00:30:35 <butterthebuddha> And I'm not generating an infinite list, my solution so far needs you to input a number of elements
00:37:26 <knupfer> fibs = 0:1:zipWith (+) fibs (tail fibs)
00:37:40 <ongy> don't just give a solution.
00:38:20 <ongy> butterthebuddha: the idea is to havea  fibs :: [Integer]. And then get a single number by indexing that list
00:39:13 <butterthebuddha> Yeah, I tried to figure out how to compute fibonacci itself without recomputing any single term
00:39:45 <butterthebuddha> And then I realized that my solution doesn't make sense if I need to return an infinitelist
00:39:49 <knupfer> butterthebuddha: If you've got a top level constant, ghc will memoize it
00:40:21 <butterthebuddha> Yeah but those are just constants right
00:40:28 <knupfer> so you need a top level list, which indexes itself
00:40:40 <knupfer> yes, and that's the problem, no?
00:40:49 <knupfer> an infinite list is a constant
00:41:02 <knupfer> (it's not a function)
00:41:19 <butterthebuddha> I was thinking of applying fold to [0..]
00:41:21 <[exa]> butterthebuddha: imho, for the first try it's probably better to do it without memoization tbh; like:  fib somestate = nextfib : (fib nextstate) ; fibs' = fib 0 1
00:41:48 <knupfer> the memoization is specifically asked for in the pdf
00:41:54 <butterthebuddha> manual memoization for a function was kind of my first though but then I realized that I had no fucking idea how to implement memoization
00:42:15 <knupfer> ghc does that for you
00:42:23 <knupfer> if it's a constant
00:42:27 <butterthebuddha> The exercise doesn't ask for memoization?
00:42:39 <knupfer> well, it asks for efficiency
00:42:49 <butterthebuddha> I think I'll give foldr [0..] a whirl
00:42:53 <butterthebuddha> See how that works out
00:43:10 <knupfer> that solves problem 1, but not problem 2
00:43:30 <knupfer> You'll still compute fib new for every number
00:44:58 <[exa]> knupfer: where do you see the memoization requirement btw? (just curious)
00:45:37 <jared-w> So with exercise 1, you definitely want a streaming way to generate the infinite list of fibs in a naive streaming manner
00:45:48 <jared-w> (scanl is a great way to do that if you like one-liners)
00:46:08 <knupfer> [exa]: it says you should need for n fibs only n additions
00:46:15 <butterthebuddha> How do I pull the last two elements out from a list?
00:46:30 <butterthebuddha> Using pattern matching
00:46:32 <jared-w> Well exercise 1 wants you to translate directly the mathematical function
00:46:52 <butterthebuddha> does xs ++ [x, y] work?
00:46:55 <[exa]> knupfer: how does that imply memoization?
00:47:08 <[exa]> butterthebuddha: you don't, accessing last elements of a linked list is O(n) operation
00:47:08 <jared-w> so I'd expect for exercise 1 to have 3 lines of code. fibs 0 = 0; fibs 1 = 1; fibs n = fibs (n-1) + fibs (n-2)
00:47:27 <butterthebuddha> [exa]: Ik, but I need to for this
00:47:37 <jared-w> That is a hideously slow way to do it, but that's the way it's requesting for exercise 1
00:48:05 <knupfer> (\xs -> (last xs, init (last xs)))
00:48:34 <[exa]> butterthebuddha: the second question is if "incomplete" list actually has the "end" :]
00:48:36 <jared-w> Now, butterthebuddha, the problem statement wants "computing the first n elements of fibs2 requires only O(n) addition operations"--do you understand what it means by that?
00:48:39 <butterthebuddha> http://lpaste.net/357434
00:49:06 <butterthebuddha> I haven't tested that, but I feel like that should work
00:49:36 <butterthebuddha> jared-w: yep
00:49:39 <knupfer> hm
00:49:55 <knupfer> it's not valid haskell, and it would be very unefficient
00:50:24 <jared-w> butterthebuddha: your (xs ++ [x,y]) is a bit wonky; It's invalid haskell, but not invalid "code" persay. (I know it works in Curry, a separate language with logical capabilities)
00:50:35 <butterthebuddha> Yea the issue is that I am constantly acesing the back of the list
00:50:37 <[exa]> butterthebuddha: if you want it working, you could probably reverse the list of fibs and match it using last:secondlast:rest
00:50:38 <jared-w> It's not inefficient in Curry, either :p
00:51:07 <[exa]> butterthebuddha: because matching ++ doesn't work (pattern matching only works on exact constructors, which is : for lists
00:51:18 <jared-w> butterthebuddha: The problem here is that you are wanting to generate an infinite list using recursion
00:51:30 <butterthebuddha> That would still be very inefficient though, wouldn't it?
00:51:33 <jared-w> Do you understand the difference between recursion and corecursion?
00:51:35 <butterthebuddha> [exa] 
00:51:43 <butterthebuddha> jared-w: is corecursion when two functions call each other?
00:51:59 <butterthebuddha> I've heard it's a thing but I've never used it myself
00:52:10 <[exa]> butterthebuddha: not that much actually, you wouldn't need to traverse the whole list N times. But the problem would arise in the end (reversing an infinite list)
00:52:32 <butterthebuddha> [exa]: But i'm never reversing an infinite list?
00:52:56 <[exa]> well, you don't, but you can't match the end using ++ either
00:53:13 <butterthebuddha> Yeah, that was just to llustrate what was in my mind
00:53:39 <knupfer> you did already fib1, which is aswell an infinite list, no?
00:53:47 <butterthebuddha> Yeahp
00:53:52 <butterthebuddha> That was a simple map
00:53:57 <[exa]> anyways, about the fold... didn't you mean to use map? If you have function fib: N -> nth_fib, you can produce infinite list of fibs by:  map fib [0..]
00:54:36 <jared-w> butterthebuddha: recursion is when you reduce a problem to a base case
00:54:50 <jared-w> corecursion is when you go from a base case and make a well defined step towards the "next" case
00:55:31 <butterthebuddha> [exa]: that was problem 1, yeah
00:55:38 <jared-w> Example: Traversing a linked list is recursion, generating an infinite list of numbers is co-recursion
00:56:07 <jared-w> (This should help you make sense of why they immediately start talking about Streams after exercise 2)
00:56:49 <jared-w> butterthebuddha: can you think of a way to start from a 'base case' and then generate the next fibonacci number and append it to a list?
00:57:12 <[exa]> butterthebuddha: oh so. About the last 2 elements then -- what if you don't tear them out of the list, but instead "remember" them explicitly?
00:57:25 <knupfer> :)
00:57:33 <butterthebuddha> [exa]: that's kinda why I wanted to use foldr
00:57:47 <butterthebuddha> Maybe I'll use a tuple as an accumulator
00:57:50 <jared-w> butterthebuddha: is anything I'm saying making sense? :p
00:58:00 <butterthebuddha> jared-w: not really
00:58:21 <butterthebuddha> Wasn't what you just proposed the original fib1 function?
00:58:49 <butterthebuddha> Computing the nth fibonacci number and appending it to a list is horrendously inefficient
00:59:01 <jared-w> Not quite :) it's close
00:59:30 <[exa]> butterthebuddha: question is "what you need for the computation" and "can you easily derive it from previous step"?
00:59:52 <knupfer> 0:1: ...?
01:00:16 <jared-w> 1 : 1 : 3 : 5 : ... 
01:00:40 <knupfer> ?
01:00:41 <jared-w> can you think of a way to cons 1 : 1 with a function that would take, say, the last two items of a list and feed that back into a result?
01:01:09 <butterthebuddha> Isn't that what I tried to do?
01:01:13 <butterthebuddha> With the foldr solution?
01:01:38 <jared-w> fold is recursive, though, what I'm proposing is corecursive
01:02:28 <[exa]> butterthebuddha: yeah, partially. But it is still quadratic, you want it linear
01:03:10 <[exa]> (because you need to access the end of the list at each fold step)
01:03:13 <jared-w> butterthebuddha: there's a function `iterate` which returns an infinite list of repeated applications of f to x
01:03:25 <jared-w> > iterate (+1) 0 
01:03:28 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:03:35 <jared-w> This is a co-recursive function
01:03:43 <jared-w> @src iterate
01:03:43 <lambdabot> iterate f x = x : iterate f (f x)
01:03:57 <butterthebuddha> But isn't that inefficient too?
01:04:13 <butterthebuddha> It's gonna recompute f so many times
01:04:26 <jared-w> It uses O(n) calls
01:04:47 <jared-w> It's also just an example; you don't have to use `iterate` for your corecursive function
01:04:52 <jared-w> > repeat 0 -- also corecursive
01:04:55 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
01:04:58 <jared-w> @src repeat
01:04:58 <lambdabot> repeat x = xs where xs = x : xs
01:05:31 <jared-w> > cycle [1..5] -- Also corecursive
01:05:34 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
01:05:38 <jared-w> @src cycle
01:05:38 <lambdabot> cycle [] = undefined
01:05:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:05:44 <jared-w> Are you seeing a pattern?
01:06:16 <knupfer> > fix (0:)
01:06:19 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
01:06:21 <[exa]> butterthebuddha: well the whole point of the exercise is that you want to put something unevaluated-yet to the end of the infinite list, just like the xs in 'repeat' or xs' in 'cycle'
01:06:58 <butterthebuddha> Yeeah, I got that
01:07:21 <[exa]> (and it doesn't explode because haskell is lazy)
01:07:46 <jared-w> Right, and we have a well behaved function here where F(n) = F(n-1) + F(n-2); and F0 = 1, F1 = 1. So if we start from `1 : 1`, what can we cons to get element 3?
01:09:01 <butterthebuddha> http://lpaste.net/357434
01:09:08 <butterthebuddha> meanwhile, I came up with this monstrosity ^
01:09:35 <jared-w> fibs lst = xs where xs = lst : ...?
01:10:24 <jared-w> Can you see how one might fill that in? (and be careful to add base cases for fibs [], fibs [1], and fibs [1,1])
01:10:38 <butterthebuddha> Shouldn't it be `1 : 1 : 2`?
01:10:39 <[exa]> butterthebuddha: getting there, you just want to write the 'last' infinite list generator implicitly in one step (so that foldr and ++ becomes irrelevant and it runs in reasonable time)
01:10:57 <knupfer> yes, jared-w had an off by one
01:11:18 <butterthebuddha> Well, 1 + 1
01:11:20 <jared-w> whoops, my bad, it's 1am here :p
01:11:45 <knupfer> I thought, it was a joke
01:11:55 <butterthebuddha> so fibs [] = [0], fibs [0, 1] = fibs [0, 1, 1]
01:12:03 <[exa]> butterthebuddha: btw the problem here is that you're creating infinite list of finite fib-lists, not an infinite fib list
01:12:34 <butterthebuddha> [exa]: yeah I feel like that would not actually work
01:12:46 <butterthebuddha> Because the list itself is wrapped inside the tupel
01:12:50 <[exa]> butterthebuddha: that would work in mathematics with limits, not in haskell (but I'm doing a very sad face)
01:12:54 <butterthebuddha> tuple*
01:13:38 <[exa]> unwrapping it is not very hard, but which one of the fold's result would you unwrap?
01:13:52 <butterthebuddha> The first one of course
01:14:00 <butterthebuddha> my worry is that take woudn't work with it
01:15:22 <[exa]> does the first one ever get computed?
01:15:59 <jared-w> oh whoops, fibs2 is :: [Integer]
01:17:04 <butterthebuddha> [exa]: why wouldn't it?
01:17:46 <[exa]> butterthebuddha: fixed the fibs2' type here
01:17:47 <[exa]> http://lpaste.net/357434
01:18:08 <butterthebuddha> Ah
01:18:11 <butterthebuddha> Can I run that in here?
01:18:39 <[exa]> question is 'how does foldr know that the result is final and it can return first pieces of xs as the result?'
01:18:51 <butterthebuddha> Yeah it doesn't actually run
01:19:02 <[exa]> hint: it doesn't
01:19:08 <butterthebuddha> The part that generates the list
01:19:14 <butterthebuddha> should be the outermost computation
01:19:37 <[exa]> the list is generated just right, but is never finalized (because you explicitly run infinite steps of adding to the end)
01:19:53 <[exa]> it would work if you put [0..10] there
01:20:03 <butterthebuddha> jared-w: I guess we're back to your method
01:20:12 <butterthebuddha> Wow, I thought i had a breakthrough
01:20:17 <butterthebuddha> :sadface:
01:20:37 <[exa]> butterthebuddha: anyways if you look at the prototype I posted earlier, it's almost the same as jared's
01:21:15 <[exa]> but kindof more explicit :D
01:22:01 <Myrl-saki> Is there any category that concerns with indexed *?
01:22:33 <jared-w> [exa]'s prototype is probably easier to follow, so use that one :)
01:23:03 <butterthebuddha> [exa]: sorry, can you post it again?
01:23:03 <Myrl-saki> Indexed Monads for example.
01:23:11 <butterthebuddha> My head's hurting right now :/
01:23:50 <[exa]> butterthebuddha: fibs = makeFibList <initialstate> ;   makeFibList <someState> = nextFib : ( makeFibList <updatedState> )
01:23:53 <Myrl-saki> oh lol
01:23:56 <Myrl-saki> there are indexed categories
01:25:15 <[exa]> butterthebuddha: think about it as 'yield' list generator from python, the 'yield' result goes to nextFib, and you only need to rewrite your changes in local variables to the computation of <updatedState>
01:25:20 <jared-w> Myrl-saki: looking at lenses? :)
01:25:42 <butterthebuddha> makeFibList [] = [0, 1]
01:25:50 <butterthebuddha> Or rather, [0] perhaps
01:26:02 <butterthebuddha> makeFibList [0] = [0, 1]
01:26:09 <[exa]> butterthebuddha: no pattern matching, it must be always the same
01:26:27 <Myrl-saki> jared-w: subhask. :P
01:26:36 <[exa]> what 'state' do you need in C/Python if you're just printing the fibs one after other?
01:26:41 <jared-w> Myrl-saki: ooh I have no idea what that is, so good luck with that lol
01:26:56 <Myrl-saki> jared-w: https://hackage.haskell.org/package/subhask-0.1.1.0
01:27:02 <Myrl-saki> jared-w: It's an alternative Prelude.
01:27:13 <[exa]> Myrl-saki: oh lord.
01:27:39 <jared-w> oh nice, like a Numeric Prelude but redone?
01:27:50 <butterthebuddha> makeFibList x:y:xs = x + y : (makefibList (x+y):xs)
01:27:54 <butterthebuddha> Does that work?
01:28:02 <Myrl-saki> jared-w: Not sure how to say. It redoes *everything*
01:28:29 <jared-w> Myrl-saki: I see lol. It was also last updated 2016 so I'm not quite sure how on board I would be with that :p but it looks interesting
01:28:35 <[exa]> butterthebuddha: getting closer actually. The main point is that you only need to remember last 2 fibs
01:28:42 <Myrl-saki> jared-w: Mhm. Sadly. :C
01:29:00 <Myrl-saki> jared-w: This has been in development for a few years now. I wonder where the owner went.
01:29:19 <butterthebuddha> I feel like I need to transform an existing infinite list
01:29:19 <[exa]> butterthebuddha: so I give you a gentle push: fibs = makeFibList 0 1
01:29:42 <butterthebuddha> Ohh, makeFiblist x y = x + y : (makeFibList (x + y))
01:29:46 <jared-w> His dissertation was updated 13 hours ago, so I think I know where most of his free time went :p
01:30:00 <[exa]> butterthebuddha: even closer, but makeFibList has 2 args
01:30:47 <[exa]> butterthebuddha: look at the 2 args as on a shifting window
01:30:51 <butterthebuddha> Ohh, makeFiblist x y = x + y : (makeFibList y (x + y))
01:31:20 <[exa]> yep, this would work with fibs = 0 : 1 : makeFibList 0 1
01:31:41 <[exa]> just for the exercise, what about getting it directly, fibs = makeFibList 0 1 ?
01:31:56 <[exa]> (visualisation: throw out whatever leaves the "window")
01:34:44 <butterthebuddha> That visualization doens't make sense haha
01:34:50 <[exa]> what about
01:34:52 <[exa]> > let makeFL x y = x : makeFL y (x+y) in take 10 (makeFL 0 1)
01:34:55 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
01:35:28 <[exa]> the makeFibList looks a bit better when you have explicitly x, y, and (x+y) written in in one after each other
01:35:47 <butterthebuddha> oHh
01:35:59 <[exa]> x,y is the incoming window, x goes out and y,(x+y) is the new window ("window"="state")
01:36:01 <jared-w> In all honesty, that's one of the cleanest ways to write the fibs out
01:36:13 <butterthebuddha> Wow I never would have figured that out by myself
01:36:20 <jared-w> (Just for some fun... here's some clever ways to do it)
01:36:35 <jared-w> > fibs = 1 : scanl (+1) fibs
01:36:37 <lambdabot>  <hint>:1:6: error:
01:36:37 <lambdabot>      parse error on input ‘=’
01:36:37 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
01:36:56 <butterthebuddha> :t scanl
01:36:57 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
01:36:59 <[exa]> aaaaaaaaaaaaaaaand there's the thing with zipWith that one of you posted earlier that really abuses haskell
01:37:06 <jared-w> >let fibs = 1 : scanl (+1) fibs in take 10 fibs -- whoops
01:38:01 <jared-w> hmm, probably broke lambdabot mildly, oh well. The defintion works in a haskell file :p
01:38:11 <jared-w> butterthebuddha: the zipWith version is this one
01:38:22 <butterthebuddha> :t zip
01:38:25 <lambdabot> [a] -> [b] -> [(a, b)]
01:38:33 <butterthebuddha> :t zipWith
01:38:35 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:38:49 <butterthebuddha> Okay, that makes absolutely no sense to me
01:39:00 <jared-w> fibs = 1 : 1 : zipWith (+) lnms (tail fibs)
01:39:34 <jared-w> whoops. "fibs = 1 : 1 : zipWith (+) fibs (tail fibs)" 
01:39:45 <[exa]> butterthebuddha: visualisation of the zipWith one is adding the lists element-after-element in each column
01:40:20 <jared-w> I'll write it out in english: "fibs is the list starting with 1, then 1, then zip together the list of fibs with its tail"
01:40:55 <jared-w> So if you had a list [1,2,3,4] and you zipWith (+) [2,3,4,5] you'll get [1 + 2, 2 + 3, 3 + 4, 4 + 5]
01:41:46 <jared-w> In short, it neatly covers the idea of F(n) = F(n-1) + F(n-2) in a corecursive way ;)
01:42:13 <[exa]> butterthebuddha: always better with an image..  http://lpaste.net/357438
01:42:16 <jared-w> Although, [exa]'s function is a bit clearer about how it happens :)
01:42:49 <butterthebuddha> I'm still kinda confused, but I'm sure it'll come eventuallly
01:42:49 <jared-w> "scan" is a bit magicky looking at times. I like to think of it as a corecursive "fold"
01:42:52 <[exa]> even the zipWith is pretty clean if you draw it correctly
01:43:22 <jared-w> > take 10 $ scanl (*) 1 [1..] -- This is the factorials
01:43:25 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880]
01:43:49 <[exa]> my personal record is drawing StateM so that students did have no chance to code it wrong
01:44:35 <jared-w> [exa]: nice :) I'm a huge fan of visualization--I've always thought that to be good at math/CS you had to have the imagination of an artist
01:45:43 <Myrl-saki> lmao
01:45:51 <Myrl-saki> Can anyone read this? mizar.org/fm/1996-5/pdf5-3/index_1.pdf
01:45:52 <[exa]> imho not generally, but it _really_ helps for writing papers/teaching (there's the other kind of people who can't write a paper or express an idea concisely, but are genial nonetheless)
01:46:19 <Myrl-saki> It looks like it's symbolic math written in English.
01:47:12 <[exa]> Myrl-saki: please don't :D
01:47:47 <Myrl-saki> Every paragraph starts with "Let"
01:48:46 <[exa]> Myrl-saki: it's clearly the work of the "other kind of people" I was just talking about :D
01:49:30 <[exa]> There are two paragraphs added for better text-flow I see. One stars with "Next we can " and second starts with "One can verify"
01:49:32 <Myrl-saki> [exa]: Can I haff logs?
01:49:54 <Myrl-saki> I accidentally rebooted my computer, and I don't have a BNC running
01:50:16 <jared-w> lol
01:50:24 <Myrl-saki> Yep. I'm stupid.
01:50:48 <Myrl-saki> I was trying to do `nixos-rebuild switch`
01:50:55 <jared-w> I was loling at [exa]'s comment
01:50:56 <[exa]> Myrl-saki: not much, citing jared: '...I've always thought that to be good at math/CS you had to have the imagination of an artist' and you saw my response
01:51:03 <Myrl-saki> So I did `C-r re` and that autocompleted to `restart display-manager`
01:51:13 <Myrl-saki> Then I did `C-r reb` and that autocompleted to `reboot`
01:51:21 <Myrl-saki> Mind you. I pressed `enter` to both of those.
01:51:21 <[exa]> emacs is cool
01:51:28 <[exa]> oh that's bash
01:51:53 <Myrl-saki> [exa]: Yep. I'm amazed that I still haven't rm -rf /'d
01:52:09 <jared-w> nice
01:52:21 <[exa]> Myrl-saki: I disabled it in my root shell after a similar incident
01:52:22 <jared-w> Check out fzf, I have it bound to C-r and it's a fuzy autocomplete that's just /amazing/
01:52:26 <Myrl-saki> I have chmod -r / 'd though...
01:52:58 <Kteino> how do I install Haskell Platform 8.2.1 on Kubuntu 17.04 64?
01:53:40 <jared-w> Myrl-saki: http://i.imgur.com/k9MwyxS.png bottom right terminal is what my C-r output looks like after typing 'make' but I could also type akme and get something similarly useful
01:55:58 <Myrl-saki> jared-w: Oh cool.
01:56:14 <Myrl-saki> jared-w: Does the scrollback disappear when you press `return`?
01:56:31 <jared-w> It's real-time as you're typing too. Yup, the whole thing pops up and disappears--I can C-c cancel out of it as well
01:56:53 <Myrl-saki> jared-w: Font?
01:57:08 <jared-w> I can C-p C-n up and down the list or use the arrow-keys. My font is pragmata-pro since I like unicode :)
01:57:27 <jared-w> (although my emacs font-lock customizations for Haskell seem to have randomly decided to stop working this weel >_> )
01:57:27 <Myrl-saki> jared-w: Font-lock on Emacs?
01:57:35 <Myrl-saki> jared-w: Yep. :P
01:57:43 <Myrl-saki> jared-w: What OS?
01:58:51 <jared-w> I like muh lambdas lol. Arch Linux. Window manager is bspwm; keyboard shortcut manager is sxhkd; bar is lemonbar; terminal is st running a few patches and tmux in all of the terminals; emacs (far left) is spacemacs with the subatomic theme
01:59:50 <Myrl-saki> jared-w: Ah. :P sxhkd is veryy nice. I didn't even realize that your bar was textual lol
02:00:37 <Myrl-saki> jared-w: It'd be nice if there was official Emacs support for ligatures though.
02:01:55 <jared-w> Yeah, I really would like that. But then I'd get frustrated at how the ligatures aren't perfect and require the font to work. It'd be extra nice if it supported ligatures and if the font lock didn't suck ass and break randomly :p
02:02:40 <jared-w> Myrl-saki: my bar uses a wingding-like font for the icons. Shamelesly copy and pasted and hacked together from random bits on the internet lol
02:03:41 * hackagebot simple-sql-parser 0.4.3 – A parser for SQL queries – https://hackage.haskell.org/package/simple-sql-parser
02:04:11 <Myrl-saki> jared-w: The price of Pragmata Pro though. :C
02:04:43 <jared-w> *cough* yeah... that price... *cough*
02:05:06 <Myrl-saki> jared-w: lmao
02:05:22 <Myrl-saki> I need to search deeper, huh
02:05:50 <jared-w> https://be5invis.github.io/Iosevka/ <-- this is a free Pragmata-pro clone
02:06:39 <Myrl-saki> jared-w: I used to use Iosevka. Have you checked out Monoid?
02:06:50 <jared-w> There's a monoid font? :p
02:07:29 <jared-w> Aw. last updated 2016--It looks nice though
02:07:54 <Myrl-saki> jared-w: Yep. It'd have been better if they were 0-width so they'll write on top of each other though! :P
02:08:55 * hackagebot clr-bindings 0.2.0, clr-host 0.2.0, clr-inline 0.2.0, clr-marshal 0.2.0.0, … and 1 more
02:08:55 * hackagebot  → https://hackage.haskell.org/packages/recent
02:09:33 <jared-w> 0-width what?
02:17:30 <Myrl-saki> jared-w: Like, the cursor will not advance as you type things in.
02:17:48 <Myrl-saki> jared-w: So it's basically bitwise ORing the characters' render.
02:22:11 <jared-w> oooh gotcha
02:22:57 <jared-w> I gotta go to bed, it's 2:30am here. I was just getting some stuff done while my girlfriend was sleeping next to me but I think I'm gonna wander off too. Was nice chatting with you :)
02:23:25 <Myrl-saki> jared-w: Cya.
02:23:42 <jared-w> Can you query me your emacs font-lock configuration? Mine's semi-weird right now and it'd be nice to get it working again for Haskell :)
02:25:08 <Myrl-saki> jared-w: Sure. 
02:26:27 <Kteino> how do I install Haskell Platform 8.2.1 on Kubuntu 17.04 64? apt-get install haskell-platform only gives 8.0.2
02:29:29 <quchen> Kteino: I don’t think there is an 8.2 Platform yet, 8.2 is a fairly recent compiler release
02:52:35 <Kteino> quchen: Then how do I install ghc-8.2.1 and cabal-installer-2.0?
02:54:05 <quchen> Kteino: I would download it from the GHC homepage and install it manually
02:54:30 <quchen> It typically takes a couple of weeks for new compiler releases to make it into the official repos and other »one command convenience« channels
02:54:47 <quchen> You can also use Stack, which recently switched to using GHC 8.2 in its nightly resolver
02:58:31 <Kteino> thanks, then I will wait
03:02:15 <Myrl-saki> Is this rendering properly for anyone? https://ncatlab.org/nlab/show/horizontal+composition+-+SVG
03:11:41 <AndreasK> Myrl-saki: Well how should it render?
03:13:07 <AndreasK> Myrl-saki: https://i.imgur.com/aIbfT1T.png in firefox
03:13:46 <AndreasK> Myrl-saki: chrome https://i.imgur.com/wNMn3b7.png
03:14:39 <Myrl-saki> AndreasK: is a bit better, I think .https://ncatlab.org/nlab/show/Godement+product
03:27:55 <fendor> i have a question, someone once explained to me that due to referential transparency haskell can cache results of functions. If this is true, why is the naive implementation of fibonacci numbers e.g. fib n = fib (n - 1) + fib (n-2) still slow? In theory, haskell should be able to cache the results, with the consequence of essentially memoizing the computations. then the computation time shouldnt be exponential?
03:28:41 <lyxia> fendor: in theory it could but it's hard to know automatically when there's a benefit to it.
03:29:20 <fendor> so, it is just a problem of the optimizer?
03:29:39 <fendor> aka analyser?
03:30:23 <lyxia> I don't think it's actually a problem.
03:31:59 <fendor> well, yes and no, it could optimize code that takes a long time to evaluate, it is not actually a problem, but i could be better
03:34:20 <fendor> so, the reason why this is still efficient is, it just does not make use of caching? when does it make use of it?
03:37:16 <[exa]> fendor: the computation in haskell is just a reduction of graph structures, where some of the structures are thunks. When thunks get evaluated, they are _replaced_ (transparently for the environs) by the result, this ensures that one thing won't get evaluated twice in the same context
03:37:26 <lyxia> The compiler doesn't ever memoize functions by itself.
03:37:38 <[exa]> fendor: if you have fibs = ..., the actual result in runtime is one thunk
03:37:51 <[exa]> which gets evaluated once and is never forgotten because it's referenced by a global
03:38:23 <[exa]> fendor: on the other hand, fib n always generates a new thunk (or new thunks)
03:39:54 <[exa]> which can be optimized by some magic, but I'd also consider memoizing a table of function results for the whole integer universum kindof resource-intensive
03:43:02 <butterthebuddha> Is there a good guide on all the functional composition stuff?
03:43:17 <fendor> how is it determined which parts form a thunk?
03:44:44 <[exa]> fendor: by strictness analysis AND a gazillion of interesting side rules (eg. monomorphism restriction has similar purpose)... But that magic is black.
03:45:08 <[exa]> butterthebuddha: what do you mean by functional composition stuff btw?
03:45:16 <Cale> Thunk is just a generic word for the runtime representation for expressions, whatever that happens to be
03:45:44 <butterthebuddha> [exa]: There is a bunch of weird syntax and stuff when using the "." operator right
03:45:55 <butterthebuddha> Like there are a bunch of other weird operators
03:46:02 <Cale> butterthebuddha: hm?
03:46:06 <fendor> in other words, black magic, *whoosh* program is maybe optimized?
03:46:16 <butterthebuddha> I think <?> or <$> was one of them?
03:46:19 <butterthebuddha> I can't remember?
03:46:27 <Cale> In actuality, the compiler may be able to prove that an argument to a function will definitely be needed, and decide to evaluate it sooner
03:46:52 <Cale> Which will remove the need to allocate a thunk for the unevaluated expression that is the argument to the function
03:48:10 <[exa]> Cale: I actually hate using that word, but it's better than trying to talk rigorously about closures, indirects, continuations, etc
03:48:19 <Cale> But generally, despite the fact that such "strictness analysis" generally does a pretty good job, it's safe to ignore the fact that it's going on, because it pretty consistently improves things (so if you're a little pessimistic, you'll only be pleasantly surprised)
03:48:34 <Cale> [exa]: Which word? Thunk?
03:48:36 <[exa]> yes
03:48:48 <Cale> Yeah, I generally prefer to stay on the level of expressions
03:49:06 <Cale> Similarly with respect to "closure" vs. "function"
03:49:13 <Myrl-saki> `An indexed category is a 2-presheaf.`
03:49:29 <Myrl-saki> What does this mean?
03:49:38 <[exa]> Myrl-saki: were you here yesterday? there was a paper with weasels, daggers, swords and a hand grenade.
03:49:49 <Myrl-saki> [exa]: Nope lol
03:49:55 <[exa]> pre-sheaf is, like, lame.
03:49:57 <[exa]> :D
03:50:02 <Cale> haha
03:50:11 <Cale> Myrl-saki: Do you know what a presheaf is?
03:50:44 <Myrl-saki> Cale: Only by nLab's definition.
03:50:47 <lyxia> fendor: A naive Haskell compiler would turn every function application into a thunk. A lot of optimizations are about figuring out which are unnecessary.
03:51:17 <Myrl-saki> Cale: I haven't really internalized it, but something about contravariant functors.
03:51:50 <Cale> Myrl-saki: Okay, so a presheaf on C is a functor C^op -> Set (so a contravariant functor from C to Set, if you prefer that)
03:51:53 <fendor> thanks for the help, i dont think i really understand more now :D 
03:52:06 <Myrl-saki> Cale: Right.
03:52:37 <Cale> fendor: Maybe if you have a more specific question we could try better :)
03:53:17 <Myrl-saki> Oh wtf.
03:53:25 <Myrl-saki> I searched "weasel, dagger, hand grenade"
03:53:31 <Myrl-saki> https://arxiv.org/pdf/math/0002089.pdf
03:53:42 <Cale> sure
03:53:43 <Cale> heh
03:54:02 <Cale> That's the paper from the other day :)
03:54:02 <fendor> Cale, you dont have to try, i just think, i have not enough knowledge about compilers and ghc in general, it has nothing to do with your explanations :D 
03:55:45 <Cale> Myrl-saki: Lemma 4.4 (not zero hand grenade) Every full weasel is universal.
03:56:20 <Myrl-saki> Cale: Is everything here actually sound?
03:56:50 <Cale> Myrl-saki: I dunno, it's set theory. These are standard terms in particular areas of set theory.
03:58:03 <Myrl-saki> Cale: Anyways. So right. a presheaf is a Contravariant functor : C -> Set
03:58:26 <Myrl-saki> Err, bad notation?
03:58:31 <Cale> So one thing to get a handle on what those are like is Yoneda's lemma
03:59:55 <Myrl-saki> Cale: Wait, is a presheaf a specific functor?
03:59:56 <Cale> Which says that the functor  C -> Set^(C^op)  which sends an object X to the functor C(-,X) : C^op -> Set
04:00:22 <Cale> is fully faithful
04:00:42 <Cale> So there's a copy of C living in the category of functors C^op -> Set
04:00:59 <fendor> Cale, but if i were interested in more details, how would i proceed to learn more about that topic?
04:00:59 <the_2nd> Can someone explain how e.g. Data.Vec is implemented? Especially the mutability / copies?
04:01:01 <Cale> and all the arrows between objects in that copy of C come from C itself
04:01:03 <[exa]> butterthebuddha: imagine  (.) something like inverted unix pipe, instead of writing f (g (h (x))) you imagine it as piping x|h|g|f and write just the program `|h|g|f` as f.g.h, that's it
04:01:43 <Cale> fendor: If you want to learn about the low level details, there's a paper: https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
04:02:00 <Cale> fendor: It also starts off with a really good discussion of the design space
04:02:50 <fendor> Cale, thanks, already read soem papers by peyton jones, they were good reads! i will return to this topic if i have any question, for now thanks :)
04:02:59 <Cale> Myrl-saki: A presheaf is any given functor C^op -> Set
04:03:23 <Myrl-saki> Cale: Ah. I'll read about Yoneda's Lemma first.
04:03:33 <Cale> Myrl-saki: Anyway, a 2-presheaf, well, I'm not certain about this, but it's probably a 2-functor, C^op -> Cat
04:03:50 <Cale> Where C is now a 2-category
04:04:20 <Cale> Myrl-saki: I highly recommend reading Awodey's text for this
04:04:22 <bollu> could someone help me simplify this? http://lpaste.net/357440, It's some Data.Map juggling that I'm unable to write elegantly
04:04:50 <Cale> Myrl-saki: In particular, there's a lot of setup before Yoneda's lemma, which is important because it tells you lots about these categories of presheaves and how nice they are
04:05:03 <Cale> Myrl-saki: which then motivates Yoneda's lemma
04:05:04 <Tuplanolla> My lens sense tingles, bollu.
04:05:25 <bollu> Tuplanolla possibly. Could you give me an example that would sell me in this case? :)
04:05:49 <Tuplanolla> I don't see what the function is supposed to do yet.
04:06:29 <bollu> Tuplanolla, well, like it says: you have a (M.Map k [a]), but you want a (M.Map k a), so provide a function that given a count of the "a" and the current key, creates a new unique key
04:06:36 <Cale> Myrl-saki: The cool thing is that no matter how bad a category C might be, Set^(C^op) inherits all kinds of nice properties of the category of sets: it's complete and cocomplete (meaning it has all small limits and colimits), it's got exponentials, it's even a topos. You can basically interpret Coq in that category.
04:07:18 <Cale> Myrl-saki: and so this functor takes your arbitrary category, and embeds it in a category which has all the widgets you could ever want
04:08:01 <Cale> and it does it in a way that if you find an arrow between the images of two of the objects in your original category C, it must be the image of an arrow in C.
04:08:31 <Tuplanolla> That's quite a twist, bollu. It's too early for me to handle that.
04:08:39 <bollu> Tuplanolla :)
04:09:04 <bollu> Tuplanolla this is one of those things that would look nicer in python methinks
04:10:00 <Myrl-saki> Cale: That's more to learn. lmao.
04:10:14 <Myrl-saki> Cale: I should really bring a notebook next time.
04:10:53 <Myrl-saki> Cale: Are limits in cattheory related to limits in caluclus?
04:11:53 * hackagebot basement 0.0.0 – Foundation scrap box of array & string – https://hackage.haskell.org/package/basement
04:17:09 <butterthebuddha> Can someone explain Monoids?
04:17:35 <bollu> In a where clause, is it possible to refer to the type variables in the function definition itself?
04:18:04 <bollu> because if you try to do this, it creates fresh type variables for stuff in a where clause (as far as I understand
04:18:14 <[exa]> butterthebuddha: https://en.wikibooks.org/wiki/Haskell/Monoids
04:18:42 <Tuplanolla> Use `ScopedTypeVariables` with `forall`, bollu.
04:18:56 <bollu> Tuplanolla I see, ty
04:19:18 <[exa]> butterthebuddha: just a generalization of the set closed on addition that contains a zero element
04:22:54 <butterthebuddha> How are they useful tho?
04:24:21 <bollu> holy fuck writing a mutable based algorithm in haskell makes me want to kill myself
04:24:35 <[exa]> bollu: what are you implementing btw
04:24:49 <Myrl-saki> butterthebuddha: Mostly APIs.
04:25:07 <bollu> [exa] a compiler pass for this: https://github.com/bollu/tiny-optimising-compiler (I'm implementing placing Phi nodes)
04:25:09 <[exa]> butterthebuddha: it can sometimes smartly add the zero element somewhere etc.
04:25:15 <bollu> [exa] iterated dominance frontier algorithm
04:25:47 <[exa]> bollu: oh noes, SSA doesn't go with haskell :D
04:25:52 <bollu> [exa] xD 
04:26:04 <bollu> [exa] yeah, the algorithm is a pain to implement with no mutability
04:26:08 <bollu> [exa] I
04:26:22 <bollu> [exa] I'm basically writing an llvm-lite to show to myself that I can :) 
04:26:50 <Tuplanolla> We do have `ST`, bollu. Is that cheating?
04:27:01 <bollu> Tuplanolla ST tends to be just as unreadable
04:27:01 <[exa]> can you point me to the representation of program? (I guess it's basicblock-ish? )
04:27:07 <bollu> [exa] yep
04:27:16 <bollu> [exa] https://github.com/bollu/tiny-optimising-compiler/blob/master/src/IR.hs
04:27:38 <bollu> Tuplanolla I want mutation for readability, not really for performance. I think I can use the lens combinators in Ix and State to make it nice, but.. idk
04:27:43 <bollu> Tuplanolla always feel weird doing that
04:27:58 <Tuplanolla> I do!
04:28:06 <epta> how to (Traversable t, Functor t) => (a -> b) -> (t a c) -> (t b c) ?
04:29:01 <Tuplanolla> There are no easy answers to this.
04:29:02 <Myrl-saki> epta: Kind error?
04:29:16 <bollu> Tuplanolla yeah
04:29:22 <Myrl-saki> t :: * -> *
04:29:23 <[exa]> very error
04:29:31 <trigone> hi, if i want to make a function that is polymorphic on any MonadReader, but monomorphic on the specific monoid, what would be the type signature? do i really need FlexibleWhatever?
04:29:49 <bollu> Tuplanolla I'm actualy considering making my bachelor thesis on something like "immutable data structures / lazy algorithms for compilers or something" and hope I can contribute to the space :P 
04:29:55 <bollu> Tuplanolla because this is just painful
04:30:08 <Tuplanolla> That would be dandy.
04:30:32 <quchen> Bollu is the new Okasaki, you heard it here first
04:30:36 <bollu> lol
04:30:42 <quchen> O:-)
04:30:57 <bollu> I gotta read the book. I hate my reading list right now xD
04:31:14 <Myrl-saki> quchen: Purely imperative data structures?
04:31:23 <Rembane> bollu: Too much boring books?
04:31:35 <bollu> Rembane the opposite. Too much interesting nontrivial books
04:32:13 <bollu> Rembane it's frustrating because, "omg that's a cool idea. And that. And that!"
04:32:31 <Rembane> bollu: Ooooooh. 
04:32:31 <epta> how to (a -> b) -> (t a c) -> (t b c) ?
04:32:45 <trigone> seconded. i started okasai's book, it's really good, even when you barely know a thing about efficiency analysis (or whatever it's called). rumor has the author wrote many other papers and so on btw
04:32:47 <bollu> epta what is "t"?
04:32:56 <Rembane> bollu: Switch your diet to coffee and stop sleeping
04:33:04 <trigone> epta: that looks like a bifunctor to me... 
04:33:05 <[exa]> bollu: well, as I'm looking at it... phi nodes as usually defined are blatantly nonlocal and actually cause something near to unification; maybe you should introduce some abstraction that does it better
04:33:07 <epta> probably, that's bifunctor. Any way to do that with traversable?
04:33:20 <Tuplanolla> @hoogle Bitraversable
04:33:20 <lambdabot> module Data.Bitraversable
04:33:20 <lambdabot> Data.Bitraversable class (Bifunctor t, Bifoldable t) => Bitraversable t
04:33:20 <lambdabot> module Data.Semigroup.Bitraversable
04:33:22 <Myrl-saki> :k Traversable t => t
04:33:24 <lambdabot> error: Not in scope: type variable ‘t’
04:33:24 <lambdabot> error: Not in scope: type variable ‘t’
04:33:26 <Rembane> :t (<*>)
04:33:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:33:32 <bollu> [exa]  so, for example, Swift doesn't use phi nodes, it uses parameters for basic blocks
04:33:36 <Rembane> epta: You almost have <*>
04:33:37 <Myrl-saki> :k forall t. Traversable t => t
04:33:38 <bollu> [exa] so maybe I should use that
04:33:38 <lambdabot> error:
04:33:38 <lambdabot>     • Expecting one more argument to ‘t’
04:33:38 <lambdabot>       Expected a type, but ‘t’ has kind ‘* -> *’
04:33:48 <[exa]> bollu: afaik phi nodes actually compile to something that gets executed before the jump, right?
04:33:51 <Myrl-saki> Well, that wasn't what I was expecting.
04:33:57 <Myrl-saki> But there. `t has kind * -> *`
04:34:17 <Rembane> epta: I need more coffee, nevermind.
04:34:21 <bollu> [exa] eh, usually, you drop the phi nodes and just make all of them use the same register. So the Phi node is mostly an analysis abstraction
04:35:02 <trigone> nobody for my MonadReader polymorphism problem? i'd like to write a function for a specific monoid but not a specific reader monad, and i can't get the signature right
04:35:54 <[exa]> bollu: so for example you at least stuff the thing to the same register. Declaratively it means that some data need to share registers. Does your IR support such data?
04:35:59 <epta> holy smoke, bifunctor is in base! nice, great
04:36:43 <trigone> epta: yeah, your signature basically looks like Bifunctor.first... not really sure why you'd need (bi)traversable...
04:36:49 <bollu> [exa] yes, like ints :) 
04:36:50 <quchen> epta: Since 8.0
04:36:58 <quchen> epta: I think 8.2 has bitraversable even
04:37:10 <[exa]> bollu: a reasonable way would be to introduce indentifiers separated from their mutual binding and assign actual places to that sometimes in the next compile step
04:37:30 <bollu> [exa] I'm sorry, I lost you
04:37:41 <[exa]> AFAIK LLVM does the same, the variable numbers there are just for humans
04:38:34 <[exa]> bollu: abstract out variable names and save only location-sharing requirements
04:38:50 <bollu> [exa] I mean, they're different underlying pointers in LLVM
04:39:31 <bollu> [exa] it could be variable name / int / what have you, but I need some way to uniquely refer to a variable. I'm using the label itself. I don't see how sharing only the location info is any different?
04:41:07 <[exa]> bollu: you can do the non-local "unification" of where the result should go just by adding the requirement and forget about actual variable renaming everywhere
04:41:27 <bollu> [exa] ah, I see
04:43:27 <[exa]> I suspect LLVM removes as much variable naming as possible as well, but not sure about that (try looking at their internal IR)
04:44:28 * hackagebot hyper 0.1.0.2, prettyprinter-ansi-terminal 1.1.1.1, hyper-extra 0.1.0.2, hyper-haskell-server 0.1.0.2
04:44:28 * hackagebot  → https://hackage.haskell.org/packages/recent
04:46:22 <bollu> [exa] I'm not sure what you mean by "removes as much variable naming as possible"
04:48:55 <[exa]> oh sorry :] I meant that it abstracts the variable names over actual (more complicated) storage locations and transfers of the values. Names can be reconstructed from a list of data dependencies, and the list of data dependencies can be easily compiled to optimal register allocation/data moves
04:50:23 <Myrl-saki> `Representability is one of the most fundamental concepts of category theory`
04:50:27 <Myrl-saki> I didn't even know that exists.
04:50:30 <Myrl-saki> Whoops.
04:56:20 <[exa]> bollu: maybe I messed up what's the abstraction of what :D
05:01:18 <beckyconning> so I did this https://www.codewars.com/kata/dubstep/train/haskell using splitOn but I can't help but wonder what it would a solution using parsec would be like
05:01:29 <beckyconning> unfortunately neither can I actually work out such a solution
05:02:00 <beckyconning> any ideas on how to parse the strings between the "WUB"s using parsec?
05:09:32 <c_wraith> beckyconning: that looks basically like https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Combinator.html#v:sepBy
05:10:49 <Cale> There may be some trickiness to using Parsec proper, just because with Parsec, you have to be careful that if a parser not wrapped in 'try' successfully consumes one character, all the other branches get discarded (you can't backtrack then)
05:11:14 <Cale> If you use Attoparsec, it might be a little easier, since you won't have to think about that
05:11:41 <c_wraith> I'm also not sure what sepBy does if the parsers overlap
05:12:50 <c_wraith> Really, that problem is best solved by just doing a string replace, and replacing "WUB" with " ", then a second pass to clean up excess whitespace
05:13:44 <c_wraith> or, I suppose, using splitOn ' ' and then unwords
05:13:58 <c_wraith> err, splitting on "WUB"
05:16:55 <Myrl-saki> c_wraith: `unwords . words` ?
05:20:11 * hackagebot hssqlppp-th 0.6.1 – hssqlppp extras which need template-haskell – https://hackage.haskell.org/package/hssqlppp-th
05:20:11 * hackagebot hssqlppp 0.6.1 – SQL parser and type checker – https://hackage.haskell.org/package/hssqlppp
05:23:31 <beckyconning> yeah the most simple solution is  unwords . filter (not . null) . splitOn "WUB"  for sure just a weird challenge to think about how to do it with parser combinators.
05:32:19 * hackagebot haskintex 0.8.0.0 – Haskell Evaluation inside of LaTeX code. – https://hackage.haskell.org/package/haskintex
06:32:10 * hackagebot stm-containers 0.2.16 – Containers for STM – https://hackage.haskell.org/package/stm-containers
07:04:37 * hackagebot stack 1.5.1 – The Haskell Tool Stack – https://hackage.haskell.org/package/stack
07:15:21 <Franciman> has anybody used wx recently?
07:24:44 <minn> What is the difference between these Alex rules? The first part of the regular expression should match a backslash literal in each case, correct? https://pastebin.com/f9047K0U
07:26:50 <Franciman> minn, doesn't the second mean " followed by \ ?
07:27:13 <Franciman> the first, sorry
07:27:50 <Franciman> ah ok no
07:29:14 <Franciman> minn, I guess they are the same, then
07:30:27 <minn> I should be able to specify string literals using double quotes. They result in different tokenizations.
07:31:20 <Franciman> then the question is
07:31:28 <Franciman> is "\\" => \
07:31:29 <Franciman> or
07:31:33 <Franciman> "\\" => \\
07:31:34 <Franciman> ?
07:34:04 * hackagebot hablog 0.6.0 – A blog system – https://hackage.haskell.org/package/hablog
07:34:09 <minn> I hadn't thought of that. A quick test indicates that "\\" is being interpreted as \\. which I didn't expect.
07:39:58 <jmcarthur> I realize there are other ways to do this, but let's just assume I have reasons for doing this: http://lpaste.net/357446 . The main purpose is that the monad instance doesn't require a Monad constraint on m (similarly to Cont/Codensity). But my question is... what would be a good name for M?
07:47:59 <vonfry> quit
08:05:02 <eacameron> Is it possible to write type families that work on the kind level? I presume yes? I basically want curried type synonyms
08:10:17 <quchen> edwardk: Any hints as to what the 'It' type in Trifecta is?
08:10:34 <quchen> edwardk: We’re having trouble making sense of the type; any lead that’s not just a pun would be helpful :-)
08:13:24 <dramforever> Looks like a stream processor?
08:13:29 <nshepperd_> eacameron: you can't really partially apply type synonyms
08:14:42 <eacameron> nshepperd_: I know, but I'm hoping type synonyms will get me that
08:14:48 <eacameron> Sorry, I meant type families
08:16:27 <lyxia> eacameron: do you know about defunctionalization
08:16:37 <eacameron> lyxia: No
08:19:18 <monochrom> Oh ha, defunctionalization sounds good. Let me post my own study notes. (But I did it at the value level.)
08:20:14 <monochrom> http://www.vex.net/~trebla/tmp/defunctionalization.lhs
08:20:23 <eacameron> monochrom: lyxia: I assume it allows me to do something similar?
08:21:38 <lyxia> yeah. https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
08:22:16 <eacameron> Hahaha
08:22:25 <eacameron> Love that first sentence: "unimpeachably correct"
08:23:05 <eacameron> monochrom: lyxia: Are you implying that type families don't work at the type level (i.e. for kinds)?
08:25:40 <lyxia> I don't understand what that means.
08:26:30 <eacameron> > type Id x = x
08:26:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
08:27:20 <eacameron> type Api headers = SomeApiSpec :> headers NoContent
08:27:39 <monochrom> Oh neat, I think the Danvy & Nielsen paper is where I learned defunctionalization from, and forgot to write it down.
08:27:39 <eacameron> type ClientApi = Api Id
08:28:07 <jmcarthur> This defunctionalization trick can be used to add higher kinded types to ocaml, but it's pretty annoying to use.
08:28:33 <eacameron> lyxia: See above what I'm trying to do
08:28:48 <lyxia> Right.
08:28:50 <jmcarthur> http://ocamllabs.io/higher/lightweight-higher-kinded-polymorphism.pdf
08:31:06 <monochrom> Yeah all encodings are annoying. :)
08:32:13 <nshepperd_> Ea
08:33:21 <lyxia> eacameron: http://lpaste.net/357447 is what it might look like
08:34:27 <eacameron> lyxia: Whoa. I had not thought of that.
08:34:48 <nshepperd_> eacameron: doing stuff in the kind level is sort of an unrelated problem to whether you can partially apply or curry things afaik
08:35:52 <eacameron> nshepperd_: Yeah, I really just was using that to describe what I want. AFAIK there is no currying at the type level anywhere
08:39:59 <glguy> everything is curried at the type level
08:40:30 <glguy> I suppose unless you take lifted tuples as parameters...
08:41:55 <eacameron> glguy: Perhaps I mean partial application.
08:42:37 <eacameron> glguy: Hm, maybe it's just type synonyms then
08:43:03 <eacameron> But I also thought that type families did not support partial application
08:43:05 <glguy> yeah, it's just type synonyms have a special restriction
08:43:26 <glguy> type families are in the category of the synonyms
08:43:38 <eacameron> glguy: Oh I see. I suppose that makes sense
08:47:13 <eacameron> lyxia: Wow looks like that did the trick!
08:49:00 <eacameron> lyxia: Thank you!
08:49:34 <eacameron> This "function application" type families surprises me. I have not done much type-level trickery and it seems this kind of thing would be very common
08:49:44 <eacameron> I would imagine it is defined in base or something.
08:51:03 <monochrom> Hrm, I haven't thought of using a GADT.
08:51:28 <eacameron> monochrom: Ah is that what this is effectively? An "open" GADT?
08:51:54 <monochrom> No, I'm talking to myself about my own example 3'
08:52:20 <eacameron> lol oh
08:54:08 <c_wraith> eacameron: data families are much like open GADTs
08:55:54 <eacameron> c_wraith: Neat. "much like" implies "not exactly". GADTs proper cannot be "open" right?
08:56:09 <c_wraith> eacameron: that's correct
08:56:41 <c_wraith> a data family allows you to add new constructors for new types - but it doesn't let you add new constructors for the same types as existing constructors create
08:58:01 <jmcarthur> data families also allow you to mix newtype-style and data-style for the same family.
08:59:02 <eacameron> jmcarthur: c_wraith: I see. Makes sense. They're the "open" version of GADTs effectively and the tradeoffs for open vs closed are as normal
08:59:33 <jmcarthur> You can define multiple constructors for the same type, but you have to define them all at once, not one at a time.
08:59:44 <dramforever> I wonder if you could make 'PAP' symbols for under-saturated applications
08:59:56 <nshepperd_> data families are different from open GADTs also in that you can't refine the family index by pattern matching
09:00:26 <eacameron> nshepperd_: How does one define an open GADT?
09:00:35 <Welkin> what is an "open" GADT or data family?
09:00:55 <nshepperd_> Well, there aren't any open GADTs
09:01:10 <Welkin> is that somehow like open rows in row types?
09:01:14 <nshepperd_> Perhaps i should say they are different from GADTs in that respect
09:01:31 <eacameron> nshepperd_: Oh I see.
09:01:33 <c_wraith> Welkin: an open type is one that you can add to anywhere you like
09:01:49 <Welkin> c_wraith: what does that mean?
09:02:15 <eacameron> Welkin: type class instances are open. You can define them anywhere for type classes that exist elsewhere, even in a library.
09:02:44 <c_wraith> Welkin: for instance, if I had data Color = Red | Blue | Green, and then somewhere else I wanted to add a Yellow constructor.  If data types were open, there would be some syntax for just declaring that Yellow is also a constructor of Color
09:02:48 <eacameron> Welkin: type class methods are closed. You cannot add methods to a type class anywhere; only in the definition of the type classe
09:03:26 <Welkin> oh I see
09:03:40 <Welkin> it feels like open data types would not be a good idea
09:04:01 <c_wraith> they make exhaustiveness checking impossible
09:04:19 <c_wraith> They're not a good fit for Algebraic Data Types
09:04:23 <hpc> it makes a lot of other things very hard as well
09:04:39 <c_wraith> But you could see subclassing as form of open data types
09:04:46 <hpc> just defining a function on one is a chore
09:04:57 <eacameron> c_wraith: go oop!
09:05:01 <nshepperd_> They would be pretty useless, because your pattern matches would always be incomplete
09:05:10 <hpc> imagine the gymnastics you have to go through to define fmap, but everywhere
09:05:25 <monochrom> Oh My God! "data Whee a where {W1 :: Whee Int; W2 :: Whee ()}" allows me to write "whee :: Whee a -> a -> Int", and that "a" can depend on whether I have W1 or W2. So, "whee W1 :: Int -> Int" and "whee W2 :: () -> Int".
09:05:28 <dramforever> welcome to the expression problem
09:05:44 <c_wraith> This is why scala pattern matches usually are done with case classes, which specifically are not open to additional subclassing
09:06:00 <dramforever> monochrom: That's exactly what GADTs are for
09:06:47 <dramforever> a weird but clear and commonly used example is: data Eq a b where Refl :: Eq a a
09:06:52 <eacameron> monochrom: I don't think you would ever get the type checker to be happy without GADT
09:07:19 <dramforever> now you can have: safeCast :: Eq a b -> a -> b
09:07:49 <monochrom> Yeah, I have enjoyed Refl very much.
09:07:55 <dramforever> and that's about what GADTs can do
09:08:24 <monochrom> This may solve my undefined problem very well. :)
09:08:50 <dramforever> throw in some polymorphic recursion, and voila, nothing happened
09:10:54 <monochrom> So, Pottier and Gauthier in http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.9.4715&rep=rep1&type=pdf are right on about defunctionalization in Haskell needs GADTs for the general case.
09:11:36 <monochrom> I was running into ADT restriction problems when trying to do more ambitious defunctionalization examples.
09:27:36 * hackagebot brick 0.22 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
09:41:49 * hackagebot criterion 1.2.2.0 – Robust, reliable performance measurement and analysis – https://hackage.haskell.org/package/criterion
09:45:07 <beckyconning> so I worked out roughly how to do this https://www.codewars.com/kata/dubstep/train/haskell with parser combinators however the parser i wrote can leave a leading and or trailing space. can anyone figure out how adjust the parser so that it doesn't do this? https://gist.github.com/beckyconning/63b7ba8291d28d204e2e349a3cbca2e7
09:45:24 <beckyconning> (many $ (many1 (try (string "WUB"))) $> ' ' <|> anyChar)
09:46:03 <beckyconning> ^ this is the parser which can leave a leading and or trailing space
09:47:41 <beckyconning> I tried using [Maybe] as an intermediate representation and manipulate that to produce the desired result however I didn't do this with the parser itself it was just like [Maybe Char] -> String after the parser.
09:52:11 <edwardk> quchen: It is 'not quite an iteratee' it is a monad that is given successively better and better approximations of an input.
09:53:39 <edwardk> data It r a = It a (r -> It r a) | Pure a -- Pure a has had all of its questions answered. It gives back two results. One is the result if there was no more improvements to be made in 'r'. One is what we do to further refine 'r'.
09:54:13 <edwardk> If you compute something using 'r' it should be something that will always remain true through all the future 'refinements' of r.
09:54:42 <edwardk> simplifyIt feeds It a refinement
09:55:24 <glguy> beckyconning: I found 'manyTill' to be useful for implementing this with parsec
09:55:25 <edwardk> fillIt is the work horse. you tell it the position you want and it grabs the text forward in the rope from there
09:57:24 <edwardk> sliceIt gets all of the text in the rope between two positions.
09:59:14 <edwardk> The whole thing should be ripped out really, as nobody really uses the timetravel aspects of trifecta, which were what necessitated the rope. What it needs is a proper parsec style pipeline that holds onto a cache of the text of the current line for error reporting, delta to be replaced with just a forward stepping Pos, the rope to die, and some special support to ensure we can still slice.
10:11:58 <`Guest00000> has anyone written a EFI hello world in Haskell?
10:12:27 <monochrom> What does "EFI hello world" mean?
10:13:36 <`Guest00000> it's any EFI program, maybe even not useful in itself, but able to run in the environment
10:18:13 <monochrom> Oh, the UEFI kind of EFI. I haven't heard of an EFI program written in Haskell.
10:29:00 <t0by> Hi, I'm a semi-newbie to Haskell and pure FP in general. I am looking at an approximation algorithm which basically amounts to {timer := n; timer.start; approx := C; while(timer > 0) approx := improve_approx() }; Now, luckily (or not) I'm working in Scala, so I just threw a `var` and a `while` in, but it got me wondering: how would you do it in a pure language?
10:29:03 <t0by> Thanks
10:32:19 <Welkin> t0by: there are many ways. You can do it simply using recursion
10:32:40 <t0by> Welkin, how so?
10:32:53 <t0by> note that timer is an _actual timer_, not an int serving as ttl
10:33:36 <Welkin> t0by: for one, you could run it in IO
10:37:04 <beckyconning> @t0by could you send me the program?
10:37:04 <lambdabot> Unknown command, try @list
10:39:11 <t0by> beckyconning, I'm afraid it's an unfinished Scala mess you don't want to see. If you want a practical example, take one of the ten thousand implementations of MCTS on github.
10:39:20 <beckyconning> send me one?
10:39:33 <t0by> Welkin, oh, that's how you do it?
10:40:22 <`Guest00000> t0by: what does improve_approx do?
10:40:34 <`Guest00000> and what does it access
10:40:53 <t0by> nothing interesting, a bunch of computations that improve the precision of approx as long as there is time available.
10:41:05 <t0by> think of Netwton's method
10:42:00 <`Guest00000> ah, so you just need to run an iterated computation while there's some time left?
10:42:06 <t0by> Precisely
10:42:14 <t0by> The more time there is, the better the approximation
10:42:37 <`Guest00000> hmm
10:42:43 <`Guest00000> i already have some knowledge for this
10:45:43 * hackagebot Spock-lucid 0.4.0.1 – Lucid support for Spock – https://hackage.haskell.org/package/Spock-lucid
10:47:37 <kreetx> hi! Question: if I do 'stack repl' and I have the same module defined in more than one dependency, then even though they are in the 'other-modules' section in dot cabal files, I get a module name overlap error
10:49:05 <kreetx> and when I do --no-load and then load some package that uses this module, I get a cyclic dependency error, even though each package uses its own local module
10:49:55 <kreetx> i.e the cyclic dependency is not real
10:50:19 <kreetx> building with stack works, its just the repl that doesn't..
10:50:46 <kreetx> the module at hand is something aking to a package-local prelude
10:51:11 <tsahyt> Is there some available type that houses exactly one or two elements of the same type?
10:51:25 <tsahyt> i.e. something isomorphic to data T a = One a | Two a
10:51:30 <tsahyt> Two a a*
10:52:00 <Welkin> tsahyt: I've never seen one
10:52:04 <kreetx> tsahyt: just make a type alias or newtype for Either a a
10:52:09 <Welkin> it may exist somewhere, but if it's that obscure, just use your own
10:52:19 <tsahyt> kreetx: you mean Either a (a,a)?
10:53:03 <kreetx> tsahyt: if that's what you want, yes. (I was following the 'T a = One a | Two a' above)
10:53:10 <kreetx> that's an Either
10:53:23 <tsahyt> I mistyped that. I mean Two a a, sorry
10:53:29 <tsahyt> I'll just use my own I think
10:53:52 <jared-w> There's a `data Pair a a` somewhere, but I don't know of any "only one or two elements of same type" type
10:55:10 <jared-w> But yeah you would likely want `Either a (a,a)` or a type like `oneOrTwo a = One a | Two (a,a)`
10:56:42 <kreetx> I wouldn't be surprised if there existed a type level solution to this somewhere on hackage.. I.e I want a sum type with either one or two of these
10:57:05 <kreetx> someone else migh want two or three :)
11:00:29 <kreetx> tsahyt: even with the type alias you can define prisms to name the specific fields for "read/write", so the code stays nice and readable
11:00:53 <ab9rf> (a, Maybe a) is sorta an option, but that's even messier and doesn't scale well
11:04:58 * hackagebot hexml-lens 0.1.0.0 – Lenses for the hexml package – https://hackage.haskell.org/package/hexml-lens
11:11:02 * hackagebot idris 1.1.1, lens-family-th 0.5.0.1, selections 0.1.0.0
11:11:03 * hackagebot  → https://hackage.haskell.org/packages/recent
11:11:44 <fshman> hi
11:12:52 <jared-w> hey there
11:25:24 <dpren> Does anyone know how you could construct a graph data structure where the edges reference node parameters instead of the node itself?
11:29:18 * hackagebot rollbar 0.4.1 – error tracking through rollbar.com – https://hackage.haskell.org/package/rollbar
11:29:18 * hackagebot rollbar 0.4.0 – error tracking through rollbar.com – https://hackage.haskell.org/package/rollbar
11:32:18 <Guest0000> t0by: check out FRP
12:22:20 <tsani> I'm trying to build a Haskell shared library that's going to be called from C. I followed this guide https://www.vex.net/~trebla/haskell/so.xhtml but I'm getting a ton of undefined reference errors at the stage where the C library is being linked. Any advice?
12:25:07 <tsani> I'm using arch linux; could this be because of the now messed up haskell installation in the repos?
12:25:17 <tsani> Is there a way to leverage stack to get this to build?
12:25:56 <geekosaur> if you're seeing a bunch of missing -lHS* then yes, it's the arch issue. could try installing ghc-static
12:27:01 <geekosaur> or remove the regular repo's ghc and install via ArchHaskell (see the arch wiki)
12:27:28 <tsani> I installed ghc-static; no dice. I'll try ArchHaskell
12:27:42 <Welkin> why note with stack?
12:27:44 <Welkin> not*
12:27:49 <geekosaur> if you use stack and a stack-installed ghc, you probably need to prefix all commands with "stack exec --"
12:27:57 <tsani> I am using stack to build the haskell library, and that works fine
12:28:27 <tsani> the issue is when I try to build the C executable, which should dynamically load the haskell library
12:28:59 <jared-w> geekosaur: I don't think ArchHaskell has been recommended for a long time. I didn't even know it was still maintained
12:29:05 <cocreature> tsani: what exactly is the link error you’re seeing?
12:29:21 <tsani> for example: /home/tsani/.stack/programs/x86_64-linux/ghc-nopie-8.0.2/lib/ghc-8.0.2/base-4.9.1.0/libHSbase-4.9.1.0-ghc8.0.2.so: undefined reference to `stg_gc_pp'
12:29:21 <geekosaur> it hasnn't been recommended but it is reported to work currently with the main repo's haskell being hosed
12:29:49 <geekosaur> hm. that should come from HSrts, I think
12:29:56 <cocreature> that doesn’t look like one of the linker errors that I’ve seen from the arch updates
12:30:12 <geekosaur> no, that's not the same error
12:32:09 <geekosaur> and it's from HSrts, as I expected
12:32:20 <tsani> ah, I'm not linking the RTS into the C executable. That must be it
12:39:33 <monochrom> Today I witnessed the true power of GADTs.
12:39:46 <monochrom> http://www.vex.net/~trebla/tmp/defunctionalization.lhs  Example 3'
12:40:14 <tsani> Linking the RTS didn't solve *all* the problems. I'm left with this:
12:40:15 <tsani> undefined reference to symbol 'base_GHCziTopHandler_flushStdHandles_closure'
12:40:18 <monochrom> in which a phantom type variable in a GADT can morph the type of a function!
12:40:58 <quchen> monochrom lives! Wooo
12:41:15 <monochrom> Wait, what? You mean people thought I was dead?!
12:41:27 <monochrom> "The news of my death has been largely exaggerated"
12:41:34 <quchen> Well, I haven’t seen you around for some time now
12:41:37 <geekosaur> base:GHC.TopHandler.flushStdHandles is missing. but it ought to be in libHSbase, unless that symbol went away in ghc 8.0.2
12:41:38 <quchen> You were not not alive
12:41:49 <quchen> Or was it not not not alive?
12:41:51 <quchen> Anyway, hello
12:42:01 <monochrom> Oh OK, but I guess relativity explains why I haven't seen you for long, too.
12:42:03 <Tuplanolla> He's been here all day every day, quchen.
12:42:32 <quchen> Nyquist theorem maybe
12:42:42 <quchen> Anyway, nice “quotation marks” in your document
12:42:55 <monochrom> Anyway GADTs solved my worry of "in general I can't keep 'apply' the same type all the time"
12:43:25 <tsani> geekosaur: hm this is very odd. I'm ensuring that all the library search paths are coming from stack's GHC installation. It's surprising that there's some kind of internal inconsistency there with symbol names
12:44:11 <jared-w> monochrom: nice stuff
12:45:32 <geekosaur> I don't know that this is an inconsistency; I don't know enough about what is going on
12:57:25 <ons> http://lpaste.net/6247804391944880128
12:58:13 <ons> Are there anyone here that have an idea on why Haskell says that "NOT" has a wrong type signature?
12:58:30 <byorgey> ons: only types and type constructors can have names that start with a capital letter
12:58:50 <byorgey> ons: in particular, names of functions have to start with a lowercase letter
12:59:05 <byorgey> ons: other than that, your definition looks fine
12:59:51 <ons> byorgey: ah, I didn't know that. Thank you!
13:21:00 <NextHendrix> typeclasses too
13:27:04 <`Guest00000> ons: also, types / type constructors can't start with lowercase letters or non-colon symbols
13:27:44 <minn> Is there a better way to test for a unique match and extract capture groups using Text.Regex.TFDA than something like this (https://pastebin.com/zx5gTSGu)? I'm not really sure I'm using the library correctly.
13:41:47 <yorick> is there an inductive zipper-y datastructure for 2d spaces where left/right/up/down traversal remains constant? I was thinking zipper over hilbert curve
13:42:36 <yorick> but that's not constant. moving over [[]] is doable but not constant over position giving basically quadratic traversal
13:43:46 <erisco> store the 2D space in a vector and yes
13:47:29 <erisco> maybe you can have a coinductive structure for the 2D space that you can inductively traverse in constant time
13:50:17 <erisco> eh, the thing I was thinking of doesn't really help, because constructing it would be expensive
13:57:30 <conal_> Also fun to require that the 2D zipper covers *all* of infinite 2D space. 
13:57:46 <gnezdo> Anybody here is good at reading type errors from lens? http://lpaste.net/5518657496434081792
13:58:07 <gnezdo> Basically, I want a function like this: foo lens action = use lens >>= action >>= (\(o, q) -> do { lens .= q; return o })
13:58:35 <gnezdo> which is like %%= except with an action rather than pure function.
13:59:16 <gnezdo> oh, and by lens, I meant lens-family  :)
14:02:22 * hackagebot bit-stream 0.1.0.1 – Lazy, infinite, compact stream of Bool with O(1) indexing. – https://hackage.haskell.org/package/bit-stream
14:21:04 <monochrom> Oh interesting. For GADT-consuming functions to do that type refinement thing I found out, I need to give them explict type sigs.
14:48:59 * hackagebot brick 0.23 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
14:54:51 <millew> I'm missing the Text.XML module, does anyone know how to load it into haskell
14:55:23 <hpc> @hoogle Text.XML
14:55:23 <lambdabot> module Text.XML.HXT.Arrow.Pickle.Xml
14:55:23 <lambdabot> module Text.XML
14:55:23 <lambdabot> module Text.Pandoc.XML
14:56:01 <hpc> you probably need to install the package with that module
14:58:07 * hackagebot MagicHaskeller 0.9.6.7 – Automatic inductive functional programmer by systematic search – https://hackage.haskell.org/package/MagicHaskeller
15:09:17 <jle`> gnezdo: it'd help to post some code
15:09:42 <jle`> oh, it's there in the paste
15:10:07 <jle`> gnezdo: the issue might be that lens is being monorphised when you pass it as an argument
15:10:13 <jle`> gnezdo: try giving foo a type signature
15:11:39 <jle`> if you give it a type signature GHC will be able to keep it polymorphic/rankn
15:56:35 <augur> what are some essential data structures, type classes, etc. that every haskeller should learn about?
15:56:44 <augur> like, if you were teaching a class
16:01:49 <hpc> i liked the choice and ordering of concepts in LYAH
16:13:13 * hackagebot libmpd 0.9.0.7 – An MPD client library. – https://hackage.haskell.org/package/libmpd
16:25:02 <jle`> augur: good question
16:25:06 <jle`> maybe most of Prelude?
16:25:11 <jle`> and then containers
16:28:48 <beckyconning> with your help I worked out how to solve that kata using parserc! : ) https://www.codewars.com/kata/reviews/5528699c6e62d34b78000153/groups/5986542b709b677800001548
16:29:10 <beckyconning> if you know how to make it simpler using parserc please let me know!
16:29:49 <Welkin> parsec, you mean
16:31:27 <jle`> parserk is like parsec but crazier
16:40:21 <erlandsona> Anyone here able to help me figure out some errors I'm getting trying to work with Aeson?
16:46:22 <jle`> and that's why you should always just ask your question
16:47:29 <Tuplanolla> He got his answer, which is "no".
16:55:49 * hackagebot gi-ggit 1.0.1 – libgit2-glib bindings – https://hackage.haskell.org/package/gi-ggit
16:57:17 <bollu> so, I have a question that I'm not sure I can state well
16:57:24 <bollu> I have a branching, stateful computation
16:57:42 <bollu> let's say the state has two parts, s (the actual state), and p (for some `sPecial state`).
16:57:58 <bollu> when the computation forks, I want "s" to be the shared state, that all forks update sequentially
16:58:09 <bollu> but I want each fork to have a _local_ copy of `p`
16:58:18 <bollu> that is not shared across forks
16:58:22 <bollu> how do I structure this?
17:04:18 <geekosaur> s as an IORef in p?
17:04:31 <geekosaur> or maybe a STMish thing
17:20:26 <buglebudabey> could anyone tell me how to manually upload my stack project's haddock documentation to hackage?
17:21:56 <erlandsona> Can someone explain why this doesn't work? `(toJSON $ MyRecord "Austin" "Erlandson") .: "firstName"` I'm expecting the String "Austin" to be returned.
17:23:36 <erlandsona> I'm trying to utilize the From/ToJSON instances I've derived on my types to get at the properties on the types with a string. Effectively I'm trying to do Ruby's `.send(:method)` in Haskell.
17:26:32 <glguy> buglebudabey: Upload instructions are at the bottom of http://hackage.haskell.org/upload
17:27:23 <erlandsona> I realize I should have phrased that as a question. Anyone know how to do what I'm trying to do?
17:28:44 <jared-w> erlandsona: does toJSON work like you expect it to? Can you print out the output of toJSON $ MyRecord "Austin" "Erlandson"?
17:29:37 <buglebudabey> thanks glguy, i've been uploading my project to hackage and the documentation hasn't been building, that's why im trying to do it manually, is there a way to diagnose the cause of the problem somehow?
17:30:58 <glguy> buglebudabey: The package lists the build report/failure information
17:38:09 <d34df00d> Hi folks!
17:38:16 <d34df00d> It seems I have found a bug in ghc 8.2.
17:38:43 <d34df00d> http://bpaste.net/show/cd0a6d9ac660
17:39:35 <d34df00d> Running this as `foo 1000 +RTS -Nsmth -s` shows it has created 1001 sparks on ghc 8.0 (or 8.2, if built with -O0). ghc 8.2 -O shows zero sparks.
17:40:13 <d34df00d> Some further investigation (-ddump-simpl and friends) shows that original generated code for main has spark# stuff, but then spark# gets rewritten, apparently because of this rule: https://github.com/ghc/ghc/blob/7a74f5053fa0972b8ce191f7492e1692f09c2e1d/compiler/prelude/PrelRules.hs#L936
17:40:41 <d34df00d> But that rule is present for like 7 years at least, so probably it has something to do with the parts of the pipeline happened before.
17:41:04 <d34df00d> What should be my next steps if I'd like to get acquainted with ghc internals and try to debug this myself?
17:42:47 <buglebudabey> thanks glguy 
17:49:10 <geekosaur> d34df00d, (a) probably you want to ask in #ghc (b) https://ghc.haskell.org/trac/ghc/wiki/Commentary is the usual starting point
17:54:11 <d34df00d> geekosaur: oh thanks!
17:54:31 <d34df00d> That page is huge though, I probably still could use more direct pointers, but I'll ask that in ghc too :)
17:55:59 <geekosaur> yes, this is why you want to ask in #ghc, at minimum they can give you some idea of where to get started --- and uit's also possible they're already tracking something like this (could also check the tickets section of trac)
17:57:34 <d34df00d> Well, I did a quick search on parmap/rdeepseq, but didn't find anything. That was on Thursday though, when I originally discovered that and figured out a somewhat minimal reproducing example.
17:59:08 <Welkin> d34df00d: you need to perform the search on a tuesday
18:01:50 * hackagebot core-compiler 0.1.0.2 – compile your own mini functional language with Core – https://hackage.haskell.org/package/core-compiler
18:37:11 <buglebudabey> does anyone know how to draw fgl graphs to the screen?
18:43:43 <codygman> What am I missing to use Data.Vector.Generic with a Data.Vector.Unboxed.Mutable.MVector here: http://lpaste.net/357451     I feel like the instance for this simple case should already be defined and I'm just doing something else wrong.
18:48:27 <codygman> have been looking at this tutorial, but can't work out the solution with it yet: https://www.schoolofhaskell.com/user/commercial/content/vector#mutable-vectors
18:59:56 <glguy> codygman: That maxIndex function is not for mutable vectors
19:00:43 <glguy> codygman: You need operations with an MVector class constraint
19:01:02 <codygman> glguy: Oh, I thought that functions from Data.Vector.Unboxed.Mutable could be used with any of the vectors.... Ah, okay.
19:10:57 <codygman> Can I convert my mutable vector to an immutable vector so I can use maxIndex? I don't see freeze there either. So I guess I'd have to write my own version of maxIndex for Data.Vector.Unboxed.Mutable?
19:54:36 * hackagebot linear-accelerate 0.5 – Lifting linear vector spaces into Accelerate – https://hackage.haskell.org/package/linear-accelerate
20:32:18 <orzo> Hello
20:32:42 <dmj`> orzo: o/
20:33:04 <orzo> Question regarding imports:  If I do not export the constructor, but i do export it's fields, will I be allowed to use record update syntax to change a value?
20:33:20 <orzo> I thought not, but I accedentally just did this
20:35:03 <orzo> I have a type data SessionTokens = SessionTokens { tokenMap :: !TokenMap , lastUpdate :: !UTCTime , maxInterval :: !NominalDiffTime }
20:35:19 <orzo> And I exported SessionTokens, but not SessionTokens(SessionTokens)
20:35:30 <orzo> I also exported maxInterval
20:35:46 <orzo> and then elsewhere, I was allowed to do this:  toks { maxInterval = 20 }
20:36:00 <orzo> where tox :: SessionTokens
20:36:15 <crucify_me> https://ptpb.pw/MUz5 hi what is this code doing? there's a note saying that this version is the only one that will typecheck.
20:36:18 <orzo> shouldn't that be forbidden?
20:38:03 <crucify_me> (b -> c) -> (a -> b) .. first off, where do those functions as arguments?
20:38:21 <crucify_me> where do those functions *go as arguments
20:39:11 <geekosaur> co (fn1) (fn2)
20:39:21 <geekosaur> or: (fn1) `co` (fn2)
20:39:45 <geekosaur> (the parentheses there are metasyntax; whether you'd actually need them depends on context)
20:40:17 <crucify_me> parentheses in the signature, right geekosaur 
20:40:18 <crucify_me> ?
20:40:36 <geekosaur> no, in what I wrotew
20:40:43 <geekosaur> the (fn1) and (fn2)
20:42:43 <crucify_me> ok yeah so this is a currying with a . c  , which can be read a after c  .. is that wrong?
20:42:46 <crucify_me> geekosaur, 
20:43:52 <geekosaur> this is not currying
20:44:04 <Welkin> lol
20:44:13 <geekosaur> you can also read the signature as: (b -> c) -> (a -> b) -> (a -> c)
20:44:29 <geekosaur> composing two functions to make a new function
20:44:29 <Welkin> somehow, I have seen people mix up currying and composition before
20:44:58 <Welkin> such as with incorrect implementation of `curry` that are really just `compose`
20:45:29 <crucify_me> ok , composition...I was reading the bartosz site; is (a.c) to be read "a after c"  ?
20:45:44 <Welkin> `a . c`
20:45:50 <Welkin> with the space
20:46:00 <Welkin> sure, you could read it that way
20:46:06 <Welkin> I like to read it "a compose c"
20:46:21 <crucify_me> excellent Welkin one sec please sorting out something here
20:49:04 <crucify_me> so if you have it (b -> c) -> (a -> b) -> (a -> c) , based on that the interpreter knows to read it ... in what order ?
20:49:38 <crucify_me> Welkin, geekosaur  ^
20:50:38 <geekosaur> maybe it's just that I am tired, but I am not sure what you are asking
20:51:15 <okel> I get the impression that reactive-banana is not Conal Elliott approved. Why not? Is it failing his denotational criterion or his continuous time criterion somehow?
20:51:20 <geekosaur> :t (\x -> x + 1) . (\x -> x - 2)
20:51:22 <lambdabot> Num c => c -> c
20:52:02 <Welkin> f . g = \x -> f (g x)
20:53:01 <Welkin> (.) is just a regular function
20:53:09 <Welkin> but infix
20:54:33 <crucify_me> thanks kindly sadly I'm getting kicked out of a cafe Welkin geekosaur  thanks again, I get it the code is very sparse though
21:27:03 * hackagebot otp-authenticator 0.1.0.0 – OTP Authenticator (a la google) command line client – https://hackage.haskell.org/package/otp-authenticator
21:41:16 <koz_> Could someone help me get a penny drop? http://lpaste.net/357455
21:41:22 <koz_> I'm actually baffled wtf I'm missing.
21:45:54 <pavonia> koz_: You need two fmaps there as you are mapping over lists
21:46:42 <pavonia> Err wait
21:46:53 <kadoban> koz_: You'll have trouble with line 11. Ask yourself what the type of 'x' is, it can only have one type.
21:47:20 <kadoban> (ie, you need to pattern match those ones apart and put them back together)
21:49:50 <koz_> kadoban: Let me try that.
21:52:20 <koz_> kadoban: I tried that, but I get the same issue: http://lpaste.net/357455
21:52:29 <koz_> (assuming I did what you meant)
21:53:09 <jle`> koz_: it might help to try it in a source file
21:53:13 <jle`> so we can see what line ghc is complaining about
21:53:16 <koz_> jle`: OK, I'll try that.
21:53:24 <jle`> alternatively you can use ghc 8.2, which shows the text of the offending line
21:53:35 <jle`> in the error output
21:53:41 <jle`> in ghci
21:55:53 <koz_> Wtf. I just tried it in a file, and GHC compiled it fine.
21:55:55 <koz_> Wat.
21:56:00 <koz_> Let me just get the text of that file.
21:56:14 <jle`> might be a multiline entry error?
21:56:18 <jle`> in ghci?
21:56:25 <nshepperd> this might be specific to ghci syntax
21:56:40 <nshepperd> if it thought you were shadowing fmap instead of defining an instance
21:56:50 <nshepperd> because instance Functor FSEntry where
21:57:00 <nshepperd> by itself doesn't start a multiline entry in ghci
21:57:10 <koz_> nshepperd: I started with :{ before that line.
21:57:17 <jle`> :{
21:58:17 <koz_> OK, that seems to work. Thank you folks, I'm glad I'm not losing my mind.
