00:00:38 <dredozubov> I don't see how it can give you parametricity
00:05:52 <johnw> dredozubov: hello!!
00:05:58 <kuribas> because different values have different implementations for each method
00:06:39 <dredozubov> johnw: hi! 
00:07:30 <dsal> How do I find out where this OS key comes from, and what I can do to convince it to use one that works?  Unable to find installation URLs for OS key: linux-armv7-nopie
00:07:51 <dredozubov> kuribas: but parametricity in a typed language will dictate some implementations, such as id :: a -> a
00:09:23 <kuribas> so then it's simply polymorphism
00:09:49 <raek> kuribas: I'd say that duck typing is similar to ad-hoc polymorphism ("OOP polymorphism")
00:10:26 <kuribas> so unchecked polymorphism
00:13:42 <ski> does "duck typing" entail checking the "type", at run-time ?
00:14:50 <dredozubov> ski: it's orthogonal, it can be strongly or weakly typed
00:15:04 <kuribas> ski: not necessary.  Not in python or ruby.
00:15:05 <ski> or does it mean that you can pass any objects that supports/understands the expected messages (with appropriate/compatible types for parameters and result, fitting what's expected) ?
00:15:41 <dredozubov> kuribas: python and ruby are strongly typed, so in fact they have runtime type checks
00:15:46 <dyreshark> speaking strictly, duck typing requires the use of dynamic checks afaik.
00:15:58 <dredozubov> that's why you have TypeError in python
00:16:12 <dyreshark> people are starting to use it more loosely to mean compile-time or run-time checks, though
00:17:07 <kuribas> anyway offtopic, sorry
00:17:11 <ski> if the latter, then i think OCaml (which have structurally typed objects. it doesn't matter if an object isn't instantiated from a class inheriting from a particular class, what matters is that it has supports the expected methods, with compatible signatures) has duck typing
00:17:19 <ski> (OCaml is statically typed)
00:17:28 <dyreshark> https://en.wikipedia.org/wiki/Duck_typing#Comparison_with_other_type_systems
00:18:08 <kuribas> ski: then type classes are duck types?
00:18:40 <dredozubov> ski: it sounds like a row polymorphism duck typing flavor
00:18:43 <ski> type classes aren't structural (light-weight) record/object types
00:19:43 <ski> (you don't have to declare the object types, they can be inferred. can even be cyclic, as long as the cycle passes through at least one object type)
00:21:35 <johnw> am I the only one who imagines a duck struggling at a typewriter?
00:21:41 <ski> type classes (ignoring the at-most-one-instance-per-type part) can be seen as a particular stylized way of passing around records, whether the record types are parameterized over other type(s)
00:22:23 <ski> (also ignoring the implicit construction and propagation of dictionaries, of course)
00:24:01 <rk_> @pl \ a b c -> (*2) (f a b c)
00:24:01 <lambdabot> (((2 *) .) .) . f
00:27:21 <kuribas> ski: you could think of the records as being the duck typing part
00:27:45 <ski> yes, that's what i suspect
00:27:57 <johnw> kuribas: I wouldn't entirely agree with that
00:28:02 <ski> (crucially using structural typing, rather than nominal typing)
00:28:07 <johnw> because a record still narrows what you can to a known set
00:28:08 * ski . o O ( "Interface-passing style" <http://fare.livejournal.com/155094.html>,<https://common-lisp.net/~frideau/lil-ilc2012/lil-ilc2012.html#(part._sec-.I.P.S)> )
00:28:46 <johnw> duck typing is like treating an A as a B, so long as it has a meaningful answer for B's interface.  A haskell record is more like an object, but you can't arbitrary use a different interface on that object.
00:29:12 <johnw> however, if you throw Data.Dynamic into the mix, that gets a lot more ducky
00:29:49 <johnw> still my favorite paper on this stuff: www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
00:31:40 <johnw> maybe what ski meant by structural typing was what I was getting at, though
00:32:41 <raek> in my view the counterpart of parametric polymorphism in a dynamically typed language is is simply that the language allows you to write functions that don't care about the type of the data it deals with
00:33:25 <raek> for instance, the map function does not need to know about the element types of the input and output list
00:33:50 <iqubic> :t map
00:33:52 <lambdabot> (a -> b) -> [a] -> [b]
00:34:02 <raek> but simply typed languages (like C and Pascal IIRC) does not allow you to write such code
00:34:31 <raek> (well except that in C all pointers can be converted to and from pointer-to-void)
00:35:10 <raek> but then you have a map function that is simply typed: map :: (VoidPtr -> VoidPtr) -> [VoidPtr] -> [VoidPtr]
00:36:00 <iqubic> Right, but then the compiler can't tell what the resulting type should be. 
00:36:10 <ski> raek : except that in dynamically typed languages, there typically is a way to depend on how that data looks like, after all (iow, you can't forbid this). so you don't get the advantage of parametricity where you know that a HOF doesn't access "elements" in any way other than through the explicitly passed callbacks intended for that
00:36:26 <raek> yes, indeed
00:36:41 <raek> parametricity is insanely useful
00:37:06 <ski> (you can have parametric polymorphism (aka generic, or "templates"), without having parametricity)
00:37:32 <raek> it's a remarkable sweet-spot in not allowing bad programs and giving the programmer useful guarantees
00:38:10 <raek> oh, I though parametric plymorphism sort of implied parametricity
00:38:13 <ski> .. i wonder whether Racket contracts allow one to express parametricity, detecting violations of it, and placing blame on the correct party
00:38:24 <raek> but without it you get something like C++ templates?
00:39:13 <ski> (Racket supports higher-order blame, where it can determine whether a violation of a contract is due to the library HOF breaking the contract, or the callback passed to it breaking its contract)
00:39:30 <raek> the "generic" code can "try" to make assuptions about the parameterized types and if the result compiles after substituting the actual types, then the compiler is happy?
00:39:51 <raek> racket contracts sound interesting
00:41:25 <ski> raek : well, i'm not sure if (or to what extent) you can detect a template type `T' in C++ at run-time (assuming you run a single uniform piece of code, rathr than the template itself doing a `typecase' at compile-time .. though i suppose other templates that it calls could still do that)
00:41:40 <ski> in Java, you can always do `instanceof', though
00:43:14 <raek> in C++: let's say you have two functions void foo(int x) and void foo(string x). then in a template<typename T> function you can call foo on a value of type T
00:43:34 <ski> (racket contracts may feel a little like dependent types (in that they can involve any computation), except that it's not at all checked at compile-time. only in the case someone actually violates the contract is the problem notices (and blame assigned))
00:43:36 <raek> and that will not compile unless T is int or string
00:44:02 <ski> raek : right, i consider that effectively doing a `typecase' at compile-time
00:44:15 <ski> so let's suppose we have a template which doesn't do that
00:44:28 <raek> ah, so you were talking about parametricity being broken because you can use instanceof at run time... now I get you.
00:44:55 <raek> ok, so then Java generics is parametric polymorphism without parametricity?
00:45:03 <ski> i agree that this ability of C++ also breaks parametricity .. but in a different way than `instanceof'
00:45:08 <raek> yes
00:46:09 <ski> (compare with type families in Haskell)
00:48:18 <ski> (also, i believe one can use "reflection" on values being typed by a type variable, universally quantified over an operation (predicate or function), in Mercury, detecting their type (cf. `cast') albeit that is seldom done)
00:48:27 <ski> @type cast
00:48:28 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
00:49:07 <ski> (the difference being that this operation in Mercury doesn't have type class constraints (type classes do exist in Mercury, though))
00:50:32 <ski> @type fromDyn
00:50:33 <lambdabot> Typeable a => Dynamic -> a -> a
00:50:35 <ski> @type fromDynamic
00:50:36 <lambdabot> Typeable a => Dynamic -> Maybe a
00:50:39 <ski> @type toDyn
00:50:41 <lambdabot> Typeable a => a -> Dynamic
00:50:43 <ski> <https://www.mercurylang.org/information/doc-latest/mercury_library/univ.html>
00:59:38 <jchia1> Is there such a thing as a restricted functor that only accepts fmap functions f :: (a ->b) such that a & b are from a set of allowed types? Or a restricted functor that accepts only functions f :: (a -> a) for some specific a?
01:04:10 <lyxia> jchia1: https://hackage.haskell.org/package/constrained-categories-0.3.0.1/docs/Control-Functor-Constrained.html
01:06:16 <ski> @hackage rmonad
01:06:16 <lambdabot> http://hackage.haskell.org/package/rmonad
01:06:57 <ski> @hackage mono-traversable
01:06:57 <lambdabot> http://hackage.haskell.org/package/mono-traversable
01:07:15 <ski> jchia1 : perhaps one of those could be interesting
01:08:01 <lyxia> https://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
01:08:57 <jchia1> ski, lyxia: Thanks
01:59:40 <`Guest00000> what will happen to fail in future?
02:01:22 <`Guest00000> can we just let it be polymorphic? fail () = mzero; fail x = Left x
02:01:39 <cocreature> `Guest00000: it will be removed from Monad. do notation will instead desugar to "fail" from MonadFail (which already exists in base)
02:02:34 <mniip> `Guest00000, no, that doesn't work with the haskell typesystem
02:04:01 <Geekingfrog> I guess that's going to break a lot of code no? If a piece of code uses fail with only a Monad constraint that would fail to typecheck right ?
02:10:01 <quchen> Geekingfrog: Yup.
02:10:02 <cocreature> Geekingfrog: that’s why it’s done in multiple steps. MonadFail was added to base in GHC 8.0, there is already a warning that you can enable to warn you if you don’t have a MonadFail instance but use failible patterns in do notation or when you implement "fail" for Monad instances. GHC 8.4 will turn on these warnings by default, GHC 8.6 will change desugaring in do notation and only GHC 8.8 will remove
02:10:04 <cocreature> it from Monad
02:10:52 <cocreature> Geekingfrog: take a look at https://wiki.haskell.org/MonadFail_Proposal if you want more details
02:13:10 <`Guest00000> mniip: class Monad m => MonadFails m s where fail :: s -> m a; instance MonadFail m => MonadFails m String where fail = failStr; instance MonadZero m => MonadFails m () where fail () = mzero; instance MonadFails (Either s a) s where fail = Left -- how that doesn't work?
02:13:34 <`Guest00000> failStr will be the old fail
02:14:13 <mniip> ok, that does work
02:14:22 <mniip> except that your m has the wrong kind in the last instance
02:14:28 <`Guest00000> oops
02:14:40 <`Guest00000> instance MonadFails (Either s) s
02:15:09 <mniip> that's a flexible instance btw
02:16:50 <mniip> `Guest00000, I'm not sure it makes much sense to have a method with such a varying type
02:17:03 <mniip> it's easier to have each monad define a type it wants to use as an error
02:17:15 <mniip> with its own specific fail function
02:17:24 <`Guest00000> it's a generic interface
02:17:25 <`Guest00000> why not
02:17:37 <mniip> Data is a generic constructor interface
02:17:41 <mniip> you don't see anyone using it
02:19:38 <mniip> `Guest00000, it amounts to 'class DoSomething a b where doSomething :: a -> b'
02:19:58 <mniip> sure it is a generic interface, but it's too generic to be useful
02:20:21 <`Guest00000> that's an amusing class
02:20:32 <mniip> with your fail,
02:20:46 <mniip> to use the function fail you have to know what monad you're in, and what is its error type
02:21:05 <mniip> and with that knowledge you'd be able to invoke a monad-specfic error function aanyway
02:21:49 <mniip> with your fail I'd be surprised to see any polymorphism over m/s at all
02:22:11 <mniip> in a practical setting of course
02:22:22 <mniip> also
02:22:29 <mniip> how will do blocks desugar?
02:22:35 <mniip> into MonadFails m String?
02:22:54 <`Guest00000> yeah
02:23:16 <[exa]> oh noes, string errors
02:24:34 <mniip> `Guest00000, and so you introduce MPTCs into otherwise haskell98 code
02:30:20 <`Guest00000> i think i just want MonadError
02:31:45 <`Guest00000> but without m -> e dependency
02:58:49 <phaazon> is there a stack equivalent to Rust’s cargo watch -x run?
03:11:42 <lyxia> what does it do
03:13:08 <phaazon> lyxia: it runs the program and watches file changes
03:13:18 <phaazon> if you change a source, it kills the program, rebuild and rerun
03:15:25 <lyxia> stack build --file-watch is the closest thing I know of
03:16:25 <brynedwards> Maybe look at halive https://github.com/lukexi/halive
03:18:25 <beemo[m]> Looks just like what i needed
03:25:00 <beemo[m]> you can also try ghicd
03:25:32 <beemo[m]> ghcid*
03:36:45 <phaazon> hey, anyone using export-elm here?
03:41:30 * hackagebot schematic 0.1.6.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
03:55:31 <libscott> anyone know a library for working with 3d spaces? I want to take an angle, project it over an amplitude then get a tangential plane
03:55:35 <libscott> this kind of thing
04:06:42 <tdammers> linear?
04:08:40 <cocreature> linear doesn’t have anything for angles does it?
04:09:23 <cocreature> i guess you could use the quaternion stuff
04:09:49 <boj> you can calculate stuff with dot/cross/etc
04:10:38 <cocreature> apparently diagrams is working on extracting a geometry library build on top of linear out of diagrams-lib https://github.com/diagrams/geometry but it doesn’t have a hackage release so far
04:10:40 <libscott> can anyone help me briefly with a small project of vector algebra
04:10:41 <tdammers> yes... dot, cross, arctan -> angle
04:10:58 <libscott> problem*
04:11:02 <fizbin> Is there a name for the Haskell technique of solving some ambiguous type error by having a local definition for a type-restricted version of "id" or "const" and then calling that just to nail down the type of some value that's otherwise ambiguous?
04:11:54 <boj> libscott: you want the "linear" library
04:12:24 <boj> @hackage linear
04:12:25 <lambdabot> http://hackage.haskell.org/package/linear
04:12:34 <ubsan_> fizbin: the "why wouldn't you just use type annotations what the heck" method?
04:13:08 <libscott> fizbin: type witness? what's it called when you pass an argument into a function to resolve a type but then don't actually evaluate the argument
04:13:33 <ubsan_> oh, like `the` in idris?
04:15:31 <cocreature> fizbin: I don’t know a good name but you might be interested in the  "asTypeOf" function in the Prelude
04:15:34 <fizbin> ubsan_: Because sometimes the thing you have to nail down is just a small part of a longer type signature, and it's easier to have a locally typed `id` function that operates on type (b, [Int]) than to annotate the full thing as (Either String (Either (Map Word16 Word8) (Map Word32 Word8)), [Int])
04:15:51 <ubsan_> fizbin: ... okay, fair
04:16:20 <ubsan_> y'all haskell programmers have long types :P
04:16:23 <boj> huh, interesting
04:16:33 <boj> that's a neat trick
04:16:57 <ubsan_> I feel like the better solution would be to define a new type?
04:17:08 <ubsan_> but *shrug*, I dunno your code
04:17:19 <boj> usually you use a type synonym there if you want to reduce/reuse it
04:18:28 <fizbin> boj: Yeah, at the top level. If there were a way to define type synonyms inside "where" clauses that could capture over local ScopedTypeVariables, I'd use that.
04:18:32 <merijn> ubsan_: Pfft, haskell types aren't that bad, you should see my C++ types...
04:18:44 <merijn> I wish those where as short as my haskell types...
04:18:45 <ubsan_> merijn: I would argue the same thing for C++ -.-
04:18:54 <ubsan_> use type synonyms y'all
04:18:56 <lyxia> you can also use partial type signatures.  :: (_, [Int])
04:19:02 <boj> fizbin: yeah, makes sense
04:19:33 <fizbin> lyxia: ooh. Partial signatures. What ghc version does that need?
04:19:42 <cocreature> 8.0 iirc
04:19:56 <ubsan_> fizbin: wait, why can't you define local type synonyms?
04:20:05 <boj> ghc just infers the type of whatever was in _ ?
04:20:20 <lyxia> 7.10 already had it
04:20:33 <ubsan_> oh, do ScopedTypeVariables not work with them or something?
04:20:58 <boj> ubsan_: type synonyms are only a top level construct afaik
04:21:04 <ubsan_> boj: whyyyyy
04:21:26 <ubsan_> (probably the answer is "because the nineties" but stiiiillll)
04:21:30 <boj> ubsan_: you want to say - type X = Either String Int - in the middle of a function?
04:21:31 <fizbin> lyxia:	 Crud. Some day I won't need to build on Ubuntu 14.04 LTS, and I'll be able to modernize my code to that.
04:21:37 <ubsan_> boj: yeah, why not?
04:21:44 <merijn> ubsan_: Honestly, type synonyms are a bad idea a lot of the time
04:21:48 <boj> ubsan_: why? >.<
04:21:50 <lyxia> fizbin: ah bummer
04:21:51 <ubsan_> I mean, I'd prefer `X: type = Either String Int`
04:22:01 <merijn> ubsan_: That'd be horrific to read, tbh
04:22:08 <ubsan_> merijn: why?
04:22:16 <merijn> ubsan_: Because you don't know WTF anything
04:22:22 * ski thinks `type' synonyms ought to be allowed in `where' and `let'
04:22:30 <ubsan_> merijn: they're local variables
04:22:30 <ironChicken> when i run `$ cabal test`, the output seems to get wrapped at 80 columns. is there a way of disabling that?
04:22:46 <boj> ubsan_: they're _synonyms_
04:22:48 * ubsan_ thinks that local variables are completely reasonable
04:22:55 <merijn> ubsan_: Everytime I use a library with type syonyms liberally applied in the functions I just spend hour clicking through the names figuring out what things are
04:22:56 <ubsan_> boj: so is a let
04:23:03 <merijn> ubsan_: What problem does it solve?
04:23:05 <ski> (where the body ought to be able to refer to nonlocal tyvars)
04:23:05 <ubsan_> merijn: oh, I mean sure
04:23:11 <ubsan_> I meant like, in the body
04:23:14 <cocreature> either build proper abstractions and use newtypes or just use the types directly
04:23:31 <kgadek> ubsan_: things get out of hand quickly with synonyms. Requires more mental memory to work with. I agree with merijn
04:23:33 <ubsan_> I'd rather use proper abstractions at the API level
04:23:51 <ubsan_> kgadek: I feel like you and merijn aren't actually arguing against what I'm saying >.<
04:24:35 <ubsan_> I'm saying - local type synonyms seem reasonable
04:24:42 <ubsan_> like, C++ example:
04:25:00 <cocreature> I’m not sure C++ is a good example for what’s reasonable
04:25:17 <merijn> ubsan_: reasonable for what? Honestly I've never really though "wow, I really want this"
04:25:23 <ubsan_> { /* given some v which is iterable */ using iter = decltype(v.begin()); /* continue on to use the type `iter` through the rest of the function */ }
04:25:47 <ubsan_> merijn: giving a readable name to a local type
04:26:26 <ski> removing type duplication ("Don't Repeat Yourself")
04:26:32 <ubsan_> yeah
04:27:01 <ubsan_> does haskell have types in classes?
04:27:26 <ski> there are associated type synonyms, and associated data types
04:27:45 <ubsan_> okay, cool
04:28:24 <ubsan_> ... how do you refer to class members, given a class SomeClass and a type implementing that class `a`
04:28:45 <boj> ubsan_: time to crack open a haskell book :)
04:29:03 <ubsan_> boj: but laaaazy
04:29:04 <lyxia> ironChicken: does it get wrapped by cabal
04:29:09 <ubsan_> I hear y'all like that
04:29:49 <ubsan_> but basically, the idea is, in a where clause, you have a type synonym which refers to an associated type of a class that's passed it
04:29:50 <ubsan_> *in
04:30:02 <ubsan_> that seems entirely reasonable
04:30:09 <boj> ubsan_: i think the problem is we aren't speaking the same language
04:30:14 <fizbin> Huh. Apparently even in modern Haskell partial type signatures are a less-than-ideal replacement for the type witnessing aliases of id and const, because -Wall turns on warnings for partial type signatures.
04:30:29 <ubsan_> boj: very possible
04:30:31 <fizbin> Which seems weird to me.
04:30:34 <cocreature> fizbin: well you can turn that warning off :)
04:30:37 <ubsan_> I haven't done haskell in like, a few months
04:30:47 <ubsan_> and I've never really gotten into haskell
04:30:51 <ubsan_> for reasons like this :P
04:30:54 <cocreature> fizbin: I mostly use partial signatures during development so I want the warnings
04:31:01 <boj> ubsan_: reasons like this?
04:31:05 <fizbin> Huh. Okay.
04:31:07 <cocreature> although it’s yet another example where being able to locally turn off warnings would be great
04:31:17 <ubsan_> boj: not allowing local type synonyms!
04:31:42 <ubsan_> :P
04:31:43 <cocreature> I really should try to fix that at some point
04:31:56 <boj> ubsan_: the compiler can type infer everything though, you really don't need types in the body/let/where of a function unless you *really* need to help it out
04:32:08 <ski> ubsan_ : local type synonyms wouldn't be behaving like associated type synonyms. they'd just be ordinary type synonyms, declared in a restricted scope
04:32:30 <ubsan_> ski: right, you'd be using local type synonyms to refer to associated type synonyms
04:32:36 <ubsan_> for shorter typing
04:32:46 <boj> shorter typing of *what*?
04:32:57 <ubsan_> the types of the functions in the where
04:33:02 <ski> well, i suppose one *could* do that ..
04:33:04 * ubsan_ likes lots of typing
04:33:09 <boj> you normally wouldn't write out those types
04:33:20 <ubsan_> boj: see, this is why I don't get into haskell :P
04:33:26 <boj> shrug
04:33:36 <cocreature> nobody’s forcing you to use haskell :)
04:33:42 <cocreature> at least I hope so
04:33:43 <merijn> boj: I disagree, nowadays I write out every type signature
04:33:43 <ski> boj : sometimes you want to, for clarity .. or you're using polymorphic recursion, or GADTs
04:34:01 <boj> ski: right, not saying never of course
04:34:10 <ubsan_> cocreature: nah, I'm doing reasonml right now
04:34:18 <merijn> Although that's not really an argument since you can trivially write a type once for multiple names
04:34:20 <ubsan_> it's super fun
04:34:21 <ubsan_> modules <3
04:34:45 <ubsan_> merijn: it just seems like an arbitrary restriction to me
04:35:02 <ski> ("write a type once for multiple names" ?)
04:36:02 * hackagebot haskell-src-exts-util 0.2.0 – Helper functions for working with haskell-src-exts trees – https://hackage.haskell.org/package/haskell-src-exts-util
04:36:07 <cocreature> ubsan_: interesting, I’ve always had the impression that ml programmers write far less type signatures than Haskell programmers.
04:36:23 <ubsan_> cocreature: ml programmers have module signatures
04:36:38 <ubsan_> also, I'm not really an ml programmer, I'm a rust programmer :P
04:36:52 <ski> (what's "reasonml" ?)
04:36:59 <ubsan_> ski: it's reskinned ocaml
04:37:09 <ski> meaning ?
04:37:16 <ubsan_> it's basically ocaml, but with different syntax
04:37:19 <ubsan_> I mean
04:37:20 <cocreature> I know that ml has module signatures, that doesn’t change the fact that I’ve seen lots of top-level ml definitions without type signatures whereas in Haskell top-level definitions without signatures are really rare
04:37:24 <ubsan_> it is ocaml, but with different syntax
04:37:34 * ski thought OCaml already had two different syntices
04:37:53 <ubsan_> cocreature: I've seen lots of top-level haskell definitions without type signatures :P
04:38:02 <boj> cocreature: is that just an idiom we use? i see bare functions in like, xmonad configs all the time
04:38:02 <ubsan_> especially with stuff like monad transformers...
04:38:18 <ubsan_> ski: it has at least three
04:38:22 * ski str John Hughes other refrains from writing top-level signatures
04:38:35 <ubsan_> ski: https://reasonml.github.io/
04:38:50 <ubsan_> it's kinda weird, but the syntax is oh so much more consistent
04:38:54 <boj> i like writing out the full sigs so the intent is known well before the implementation
04:39:02 <cocreature> boj: I’m not sure xmonad configs are good examples of Haskell code. a lot of xmonad users only write Haskell in their xmonad configs
04:39:15 <ubsan_> also, they're focusing on the Web
04:39:24 <boj> cocreature: yeah, i couldn't think of anywhere else i see that though
04:39:31 <ubsan_> boj: type driven development, as it were ;)
04:39:40 <boj> ubsan_: yep!
04:40:03 <ubsan_> I feel like full type signatures is more of a recent-ish trend?
04:40:29 <marvin2> ubsan for top-level things?
04:40:50 <ubsan_> ... why is there a ubsan
04:41:05 * ubsan_ is confused
04:41:07 <ski> i'm not sure i like the sound of "Reason gives OCaml a familiar syntax geared toward JavaScript programmers"
04:41:09 <ubsan_> who has that nick...
04:41:44 <ubsan> well, w/e
04:41:50 <ubsan> marvin2: yeah
04:41:59 <ubsan> or maybe I just didn't get far enough into haskell
04:42:00 <cocreature> ski: the next step will be “reason gives ocaml familiar semantics geared toward javascript programmers”
04:42:16 <ubsan> ski: eh
04:42:43 <boj> ubsan: sounds like you are about to get farther into it since you are sitting here :)
04:43:06 <ubsan> ski: it basically just means braces, less insane semicolons, more semicolons, and record syntax is now { x: y } instead of { x = y }
04:43:18 <ubsan> the syntax is mostly just cleaned up
04:43:41 <ubsan> boj: yeah, I always try, but then I get annoyed at laziness by default :P
04:44:03 <ubsan> (not really)
04:44:16 <ubsan> (I just haven't found a project I'd be interested in doing in haskell yet)
04:44:23 <boj> fair enough
04:44:32 <ubsan> I did have fun writing a lambda calculus interpreter a while ago :)
04:44:47 <ubsan> although iirc, I ended up rewriting that in Rust?
04:45:02 <ubsan> which was a terrible mistake
04:48:06 <ski> ubsan : seems also `=>' instead of `->', in some places
04:48:16 <ubsan> ski: yeah
04:48:25 <ubsan> I think that was an inconsistency in ocaml
04:48:34 <ski> why ?
04:48:51 <ubsan> side note - wasn't there a language that used => for side-effecting functions, -> for pure functions?
04:48:51 <ski> (inconsistency with what ?)
04:49:05 * ski doesn't know
04:49:07 <ubsan> ski: reason just makes everything to do with functions use => basically
04:50:12 <ski> hm, i haven't seen how function types are written, yet
04:50:25 * ski doesn't follow ubsan's reasoning
04:50:51 <ubsan> ski: umm, there's a thing somewhere which explains their reasoning
04:50:59 <mniip> nope ocaml uses ->
04:51:37 <mniip> the single arrow notation comes from mathematics
04:51:51 <ski> ok, now i see function types are also changed to use `=>'
04:51:56 <mniip> and the => is kinda an implication
04:52:24 * ski is still wondering what the inconsistency in OCaml syntax here would be
04:52:43 <ubsan> ski: https://reasonml.github.io/guide/ocaml
04:52:53 <ski> mniip : iirc, it comes from category theory :)
04:53:13 <mniip> I'm pretty sure f:X->Y predates category theory
04:53:33 <ubsan> ski: search for "Functions"
04:53:49 <ertes-w> CT adopted the "f : X -> Y" syntax
04:53:59 <ertes-w> IIRC
04:54:43 <ubsan> I mean, x (arrow) y has been around forever, afaik
04:54:48 <ertes-w> but then in CT "->" could just as well mean implication =)
04:55:28 <mniip> X => Y usually means logical implication
04:55:33 <ubsan> curry howard correspondence :D
04:55:41 <ski> oi, why no `int * int' tuple types :/ ?
04:55:43 <mniip> ubsan, that's too new
04:55:54 <ubsan> mniip: I was responding to ertes
04:56:05 <ubsan> ski: because `int * int` tuple types are uuuugly
04:56:10 <ertes-w> ubsan: the idea of sets is not that old
04:56:22 <ski> well, reusing the same syntax as for tuple values is more ugly, imho
04:56:29 <cocreature> huh according to http://jeff560.tripod.com/functions.html it’s quite new
04:56:34 <ubsan> ski: ... doesn't Haskell do that?
04:56:41 <ski> it does, yes (and it's ugly)
04:56:42 <cocreature> “Saunders Mc Lane, in Categories for the working mathematician (Springer-Verlag, 1971, p. 29), says: "The fundamental idea of representing a function by an arrow first appeared in topology about 1940, probably in papers or lectures by W. Hurewicz on relative homotopy groups.”
04:56:52 <ubsan> ski: agree to disagree...
04:57:12 <ubsan> (declaration follows creation is, imo, a great way to design type syntax)
04:57:21 <ertes-w> cocreature: that would explain why CT adopted it
04:57:29 <ski> (it means it's harder to operate on type tuples (as opposed to tuple types), on the type level, for one thing)
04:57:55 <ubsan> ski: like, a value tuple of types?
04:58:03 <mniip> yes
04:58:05 <ubsan> (int, int) of type type * type
04:58:10 <ubsan> i mean sure
04:58:16 <ubsan> but ocaml was never really that language
04:58:17 <mniip> :k '(Int, Int)
04:58:19 <lambdabot> (*, *)
04:58:27 <mniip> :k (Int, Int)
04:58:29 <lambdabot> *
04:59:12 <ski> ubsan : no, i mean if we want to uncurry `Cont :: * -> * -> *', e.g., how would we apply it. `UncurriedCont (o,a)' doesn't work, since `(o,a)' isn't a type pair, it's a pair type
04:59:28 <ubsan> ski: right, but ocaml isn't really that language
04:59:33 <ski> leading to such ugly things as mniip just indicated
04:59:50 <ubsan> I can get why it'd be an issue in haskell
04:59:55 <ubsan> but ocaml, not really
05:00:32 <ski> cocreature : ok, i vaguely recall reading that passage
05:00:36 <ski> (ty)
05:01:00 <ubsan> although that does make a good point and I will have to figure out how to deal with that for my language
05:01:20 <erisco> what are the constituents of syntax?
05:02:35 <ski> hm, i also don't like `let foo x => x + 1'. it should be a `=' here, not a `=>'. `foo x = x + 1' ought to be able to interpret as an equality, holding for all `x'
05:03:41 <ubsan> ski: think of it more as a shortening of
05:03:46 <ski> (reversing type application is fine)
05:03:48 <ubsan> `let foo = fun x => x + 1;`
05:04:15 <ubsan> delete `= fun` and you have `let foo x => x + 1;`
05:05:13 * ski doesn't buy this
05:05:56 <ski> allowing curried types is fine, but passing a type tuple as argument should still be allowed ..
05:06:16 <ubsan> ski: it's not allowed in ocaml, afaik
05:06:32 <ubsan> `type * type` isn't a thing :P
05:08:34 <ski> (if it has `fun f x => x + 1', then i don't see why it doesn't do `type t 'x => list (option 'x)')
05:09:07 <mniip> ski, ye but type lambdas don't exist
05:09:11 <mniip> and are otherwise evil
05:09:26 <ubsan> I don't think they're evil, but they don't exist, yeah
05:09:49 <ski> (er, sorry, s/fun/let/)
05:10:23 <mniip> ubsan, pretty sure they are evil
05:11:01 <ski> ubsan : you can say `type ('a,'b) either = Left of 'a | Right of 'b' and then `(int,bool) either' .. however, these argument "type tuples" aren't first-class, granted
05:11:07 <ubsan> mniip: I generally think types being treated as basically values is good
05:11:20 <mniip> sure
05:11:31 <mniip> but does your value language always terminate
05:11:47 <ski> ubsan : that's a reason why tuple types should not be written similarly to (value) tuples
05:12:20 <ubsan> mniip: depends on effects
05:12:41 <ubsan> ski: I dislike that that's allowed
05:13:09 <ski> (i do think there's some merit to "declaration follows creation" -- but it can't be taken as is. one'd require some kind of mechanism to explicitly switch between the type and the value levels)
05:13:50 <ubsan> I think it's really important to take into account the actual language being discussed when we discuss type declarations
05:14:08 <ski> (not only allowed, it's the only way you can have multiple parameters to a type)
05:14:29 <ubsan> I don't expect Haskell-likes, DT languages, and Go-likes to have the same syntax, for example
05:14:42 <ubsan> ski: well, see
05:14:52 <ubsan> that's fixed by not using weird backwards syntax
05:14:53 <cocreature> mniip: I’m not sure I buy the termination argument. for all practical purposes you need to limit the runtime in some way if you care about things terminating in a reasonable amount of time.
05:15:55 <boj> maybe they are referring to the halting problem?
05:16:19 <ski> another negative point is "the = operator is available for mutable field update" :)
05:17:10 <cocreature> boj: sure, my point is that you don’t care about whether your typelevel program terminates, you care about whether it terminates within a reasonable timeframe
05:17:28 <boj> cocreature: what is reasonable though?
05:17:34 <cocreature> so even if you limit yourself to a language where you can decide if things halt, you still need to limit the number of steps
05:17:39 <cocreature> boj: just make it configurable :)
05:17:43 <ski> ubsan : i don't see why one couldn't technically allow  'a ('b either)  "fixing" it without avoiding the backwards syntax
05:17:47 <boj> cocreature: hah, indeed
05:17:49 <ski> (iirc MetaML did this)
05:18:05 <ubsan> ski: that seems like working around the problem, rather than fixing it?
05:19:28 <ski> i don't see how replacing  ('a,'b) either  by  'a ('b either)  doesn't "fix the problem", while replacing  either ('a,'b)  by  either 'a 'b  would "fix the problem"
05:19:55 <ski> (reversing the syntax of type applications is a separate issue)
05:20:16 <ubsan> the issue for me is backward syntax
05:20:26 <ubsan> like, it's ugly and it doesn't make sense
05:20:48 <ubsan> that's the issue I have with ocaml's syntax, mostly - it's kinda ugly, and often it doesn't make sense
05:20:53 <ubsan> reason gets around that :)
05:21:20 <ubsan> I just put a semicolon on the end of everything, and I no longer have to deal with `let () = ` or `;;`
05:21:29 <ski> well, then i misunderstood. i mentioned how the apparent tuple syntax is the only way you can have multiple type parameters, and you replied that that's fixed by not using backwards syntax
05:22:10 <ski> (which seemed like a non sequitur to me)
05:22:29 <ubsan> ... but it's not
05:22:31 <ubsan> because it is
05:22:41 <ubsan> it's fixed by doing `type x 'a 'b`
05:23:00 <ubsan> like, you can fix it in other ways, but reason fixes it by doing it type name first
05:23:32 <ski> i don't see how  type 'a ('b x)  wouldn't also fix the same issue
05:23:47 <ski> (or without the brackets, changing the associativity, if you prefer)
05:24:27 <ubsan> no see it *would*
05:24:41 <ubsan> but it's also fixed by not having backwards syntax
05:25:07 <ubsan> given A -> C, also having B -> C does not invalidate A -> C
05:25:15 <ubsan> it's just a different way of doing it
05:26:15 * hackagebot ngx-export 0.6.1.1 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
05:26:47 <ubsan> X fixes Y by Z
05:26:51 <ski> anyway .. from the things i've seen, i think "the = operator is available for mutable field update" is the most negative point for me, closely followed by replacing `=' by `=>' in function definitions and reusing tuple syntax for tuple types -- these are all steps backwards, imho
05:26:59 <ubsan> that does not mean that X' cannot fix Y by Z'
05:27:40 <ubsan> I disagree with all of your complaints
05:27:45 <ubsan> but agree to disagree
05:27:48 <erisco> > null ((:) {})
05:27:51 <lambdabot>  False
05:28:32 <ski> well, afai see it. you "fix the problem" (i don't recall exactly what the problem was) by using curried style, instead of tupled style. then, you additionally (unrelatedly) also decide to reverse the type application
05:28:58 <ski> (to me, these look like two independent changes)
05:29:29 <ubsan> ski: that seems... kinda ignorant?
05:29:40 <ubsan> of how it was actually solved?
05:30:05 <ski> i think mutation (also assignment, if present) should be clearly distinguished syntactically from binding
05:30:22 <ubsan> it was likely solved by these people going "type constructor syntax is confusing - let's make it look like functions"
05:30:29 <ski> ubsan : perhaps if i understood what the perceived problem was, i'd better understand your reasoning
05:30:59 <ubsan> ski: the problem is that type constructor syntax is confusing
05:31:06 <ubsan> and uses really weirdly nonstandard syntax
05:31:31 <ubsan> the issue has little to nothing to do with tuples
05:31:41 <ubsan> that they share a syntax is likely just a quirk of history
05:31:42 <ski> i assume by confusing and weird, you refer to the backwards application
05:31:59 <ubsan> I mean the entirety of it
05:32:02 <ubsan> the backwards application
05:32:04 <ski> "the issue has little to nothing to do with tuples" -- which is what i've been trying to say :)
05:32:15 <ubsan> do you know that you're terrible at this IRC thing?
05:32:15 <ski> (apparently violently agreeing, then)
05:32:24 <ski> that may be
05:33:16 <erisco> what's that? do I need to write someone up for careless typing and entering?
05:33:17 <ubsan> it's quite frustrating to talk to you, tbh
05:33:58 <ubsan> I've felt like I have to say the same thing about four times over -.-
05:35:25 <cocreature> if you have to say things four times over then maybe you should question if you’re explaining things well instead of blaming others
05:35:27 <ski> anyway, i wish you (and other people using this) all the best of luck. i was attempting to give my impression on the syntax. in fairness, i should say that some of the other syntactic quirks (precedences, e.g.) being fixed is good
05:36:19 <ski> in addition, i tried to give reasons why i personally didn't like a few of the changes made (some of the others i don't care that much about, either way)
05:37:10 <ubsan> ski: alright, then we clearly weren't communicating at the same level
05:37:12 * tabaqui test
05:37:21 <cocreature> tabaqui: passed
05:37:26 <ubsan> ski: sorry
05:38:01 <ski> no offense taken
05:39:27 * ski also apologizes to ubsan, in case it came across as overly abrasive
05:39:42 <ubsan> I think it's probably mostly to due with the time
05:39:46 <ventonegro> Now hug
05:39:52 <ubsan> given that I should have been asleep 5 hours ago
05:39:54 <ubsan> -.-
05:40:01 * ubsan hugs channel
05:40:05 * ski should probably sleep as well
05:40:18 <mnoonan_> does anybody know if ekmett’s proposed Representational typeclass is ok to use, and maybe have some pointers towards how to make and use “Coercion a b” s?  https://mail.haskell.org/pipermail/ghc-devs/2014-May/004974.html
05:40:19 * ski HuGS #haskell
05:40:29 <ubsan> friggin anime witches
05:40:37 <ubsan> bein' all cute and unionizy
05:41:13 <ironChicken> lyxia: i can run the testStub executable directly and that also wraps the output
05:42:42 <Darwin226> Say I'm implementing a type-level Ord class. Is there an advantage to doing `class TOrd k where type Compare (a :: k) (b :: k) :: Ordering` instead of just having an open type family without the class?
05:43:33 <cocreature> Darwin226: with GHC 8.2 you can derive the latter for newtypes.
05:43:47 <lyxia> ironChicken: If it's the test framework's fault perhaps it has a command line option
05:43:48 <cocreature> hm maybe not
05:43:58 <cocreature> I’m not sure what the exact rules are under which that works
05:44:12 <erisco> Darwin226, superior to either of those options is a data family
05:44:24 <ironChicken> lyxia: the test frame is just Distribution.TestSuite (the Cabal one)
05:44:39 <Darwin226> cocreature: Since you can't have a newtype of any kind other than Type, I don't see how this would work
05:44:48 <cocreature> Darwin226: yeah
05:45:01 <Darwin226> erisco: How so? I need to know the resulting kind
05:45:18 <lyxia> ironChicken: Oh, I forgot you could do that. I'm not sure how to troubleshoot that.
05:46:17 <ironChicken> i mean, i probably should try a better test framework. i'm sort of trying to wrote XSpec-style tests using Distribution.TestSuite :-/
05:46:30 <erisco> Darwin226, you construct a relation. The type family is more concise for some uses but useless in others where a data family will work
05:47:00 <erisco> Darwin226, also, there is no difference between the open type family and the member type in your example
05:47:30 <mnoonan_> ironChicken: try spec?
05:47:45 <Darwin226> erisco: I still don't understand. This TOrd works only on types. Data families involve writing value level constructors
05:47:52 <mnoonan_> *hspec
05:47:59 <cocreature> +1 for hspec
05:48:01 <phaazon_> in my stack.yaml, I cannot use a git: entry in extra-deps
05:48:06 <phaazon_> even though the documentation says so
05:48:20 <erisco> Darwin226, you are in for a treat then :) What are you comparing? Peano naturals?
05:48:34 <cocreature> phaazon_: you are probably looking for the documentation of the next release
05:48:48 <phaazon_> cocreature: what do you mean?
05:48:50 <Darwin226> erisco: No. The idea is to be able to compare any type. Just like with the regular Ord class
05:48:55 <phaazon_> ah
05:48:59 <cocreature> phaazon_: the next release of stack will support that
05:48:59 <ironChicken> mnoonan_: yeah, i should :-)
05:49:07 <phaazon_> so it doesn’t yet
05:49:08 <phaazon_> damn.
05:49:12 <erisco> Darwin226, I know, but what are you comparing in particular so I can make an example for you?
05:49:20 <cocreature> phaazon_: you can put it in "packages" and set "extra-dep: true"
05:49:30 <mnoonan_> ironChicken: it’s really easy to get going with, probably especially compared to whatever you are doing now :)
05:49:32 <Darwin226> erisco: Let's say `data ABC = A | B | C`
05:49:49 <erisco> Darwin226, and what is your ordering relation on that?
05:49:58 <Darwin226> left to right, lets say
05:50:02 <phaazon_> cocreature: I have other things in extra-deps
05:50:08 <cocreature> phaazon_: so?
05:50:17 <erisco> Darwin226, give me a few minutes
05:50:22 <phaazon_> cocreature: Error in $['extra-deps'][7]: failed to parse field 'extra-deps': expected PackageIdentifier, encountered Boolean
05:50:25 <phaazon_> so that ^
05:50:40 <cocreature> phaazon_: right, put the git package in "packages" and set "extra-dep: true" on that package
05:50:54 <cocreature> if that doesn’t work, you’ll need to show us your stack.yaml
05:51:11 <phaazon_> ah
05:51:12 <phaazon_> extra-dep
05:51:13 <phaazon_> :D
05:51:17 <phaazon_> I thought you said extra-deps
05:51:33 <phaazon_> Warning: /Users/dimitrisabadie/work/monorepo/vp/code/stack.yaml: Unrecognized field in PackageGitLocation: extra-dep
05:51:50 <cocreature> phaazon_: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
05:52:05 <phaazon_> wait I think I got it
05:52:26 <phaazon_> yeah, yaml is such a bad format
05:53:19 <phaazon_> cocreature: yeah, it works now
05:53:24 <phaazon_> thanks!
05:53:42 <phaazon_> is there a way to state I want master?
05:54:08 <phaazon_> hm, commit: master seems to work
05:54:10 <cocreature> "stack upgrade --git" will install stack from master but there is no way to state in your stack.yaml that it requires a certain version of stack afaik
05:54:14 <cocreature> oh you mean the package
05:54:18 <phaazon_> yep
05:54:20 <phaazon_> the dep
05:54:36 <cocreature> if you do that you give up on reproducability
05:54:45 <cocreature> and I think it’s also not guaranteed to work
05:54:59 <cocreature> and it’s unclear when it will refresh things
05:55:00 <phaazon_> cocreature: it’s for dev only now
05:55:08 <phaazon_> because that package I depend on is in my github
05:55:20 <phaazon_> once I stop adding commits to it, I’ll freeze the field 
05:55:30 <phaazon_> I’m trying to fix export-elm
05:55:49 <cocreature> even if it’s for dev only, you’ll be happy to have specified a commit if you stop working on it for a month and it still works when you come back to it :)
05:56:00 <phaazon_> yeah yeah
05:56:02 <phaazon_> I totally agree
05:56:06 <phaazon_> it’s just for the day
05:56:09 <phaazon_> or a few hours
05:56:13 <phaazon_> I’m iterating fast right now
05:56:15 <Psybur> Do any of you guys recommend real world haskell? I remember some people in here hating on it and learnyouahaskell
05:56:25 <cocreature> phaazon_: can’t you just specify your local version in that case?
05:56:26 <phaazon_> I love LYAH
05:56:33 <phaazon_> cocreature: I could, yeah
05:56:36 <Psybur> I already learnt me a haskell wondering if real world haskell would be a good read too
05:56:38 <phaazon_> it’s a better idea
05:56:44 <phaazon_> because it’d fail on our CI
05:56:47 <phaazon_> I’ll do that
05:58:58 <erisco> Darwin226, http://lpaste.net/357952
05:59:09 <cocreature> Psybur: rwh is a nice book imho but it’s quite out of date at this point. the ideas mostly still carry over but you’ll need to fix the example code and some of the libraries are probably also superceeded
05:59:27 <Psybur> cocreature, anything more modern that you can recommend?
05:59:47 <Psybur> And is there anything like Spring Boot for haskell?
05:59:58 <cocreature> Psybur: I’ve heard a lot of good things about http://haskellbook.com/ but I’ve never read it personally
06:00:01 <cocreature> @learnhaskell
06:00:01 <lambdabot> Unknown command, try @list
06:00:04 <cocreature> @where learnhaskell
06:00:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
06:00:10 <cocreature> that has a bunch of free resources
06:00:35 <Darwin226> erisco: I mean, this is pretty cool and all, but it wont really let me implement a type level sort function that can sort lists of any kind that supports orderings
06:00:56 <erisco> Darwin226, sure it will
06:01:05 <merijn> Haskell Book seems fine for people that know some languages already. I've heard people say that it's also good for people without programming experience, but my empirical experience shows that the structure feels its a bit illogical for people with no existing programming knowledge
06:01:51 <erisco> Darwin226, but go on and try it as you see it and keep this in mind for later
06:02:00 <ventonegro> +1 for http://haskellbook.com/
06:02:59 <Psybur> So I'm in the AWS world. EMR, Big Data and some web apps that orchestrate some jobs. I'm wondering how I can sneak haskell in here heh. I've already been redpilling people on scala xD
06:03:00 <Darwin226> erisco: Hmm, ok. I'll try
06:03:07 <fc5dc9d4> leaf
06:03:17 <lyxia> erisco: I also fail to see how you can write a Max type level function with that.
06:03:25 <erisco> Darwin226, as I said, there is no difference between an open type family and a class member type
06:04:12 <erisco> Darwin226, the syntax for having a type be a member of a class is sugar for defining instances of an open type family
06:04:24 <Darwin226> Well, I guess classes let me at least write things like class TEq k => TOrd k`, even though I can't really use this information
06:04:54 <erisco> lyxia, if you can more specifically explain what you mean I might be able to show you
06:08:37 <Psybur> So if I have a java web app that has certain classes that our services need to extend, could I use Frege to write these services? How would extending a Java class work in Haskell? haha
06:09:16 <sm> Psybur: Eta may be of interest
06:09:33 <ventonegro> Psybur: Maybe you can start with small stand-alone tools for deployment
06:09:53 <Psybur> ventonegro, we just use gradle for that
06:10:01 <lyxia> erisco: write a type family Max :: k -> k -> k that behaves like the value level max for the type ABC.
06:10:20 <erisco> why do I want to write a type family?
06:10:39 <ventonegro> Psybur: And don'
06:10:43 <erisco> I would just define this GADT http://lpaste.net/357953
06:10:48 <ventonegro> t need better tools? That would be a first
06:11:21 <Psybur> ventonegro, not yet. Maybe some aws lambda functions I could write with eta
06:11:34 <Psybur> Wondering if I can extend a class and override methods with Eta
06:11:49 <Younder> Tried Isabelle? A verification program from the dark ages, but in constant development and still useful.
06:12:29 <lyxia> erisco: I guess we don't have the same interpretation of what Darwin226 is looking for.
06:12:46 <ventonegro> Darwin226, Younder: There is also Idris
06:12:55 <Younder> and Coq
06:13:13 <ventonegro> Idris is very close to Haskell, though
06:13:23 <erisco> I know what he is looking for. I am mentioning another way.
06:14:23 <Darwin226> erisco: I'm interested. What would `Maximum` look like?
06:14:31 <Younder> Well in Isabelle  you have Haskabelle, A conversion program that turns Haskell into a format Isabelle understands.
06:15:45 <Younder> Stil Idris sounds intereting, can't say I have used it before.
06:16:08 <Younder> interesting
06:16:34 <merijn> I don't think I'd say Idris is "close to Haskell", although being easy to learn for people who know Haskell is an explicit goal
06:16:53 <Psybur> If anybody knows off the top of their head, does Eta compile to .class files? If nobody knows I can easily find out
06:17:47 <beemo[m]> with hspec and persistent-postgresql how do i test against an empty database?
06:18:08 <ventonegro> Younder: https://www.manning.com/books/type-driven-development-with-idris
06:21:00 <lyxia> erisco: How is a data family is superior to a type family here then?
06:21:42 <erisco> lyxia, because there is a witness to the truth
06:22:39 <lyxia> So what? Here is something you can do with a type family:  max :: _ => a -> b -> Max a b  for some omitted constraint.
06:22:54 <ventonegro> merijn: The syntax is very similar, you have Monad, Applicative, Foldable, etc. So I'd say "close" is justified
06:23:10 <ventonegro> Even `do` syntax
06:23:29 <Darwin226> lyxia: Well maybe if those a and b would be phantom type params
06:23:40 <Darwin226> otherwise it doesn't really make sense
06:24:10 <lyxia> Darwin226: What doesn't
06:24:11 <erisco> Darwin226, like this http://lpaste.net/357954
06:24:56 <Darwin226> lyxia: max :: a -> b -> Max a b implies that (a :: Type) and (b :: Type), and how exactly do you compare things of kind Type
06:25:56 * hackagebot arrowp-qq 0.2.1.1 – A preprocessor and quasiquoter for translating arrow notation – https://hackage.haskell.org/package/arrowp-qq
06:25:57 <Darwin226> erisco: Neat. It's kind of like the old way of computing with fundeps, but this gives you value level evidence. I'll think about it some more
06:27:09 <Darwin226> But this isn't really "computing" anything. You're just stating a fact and proving it manually
06:27:36 <lyxia> Darwin226: Fair enough, that wasn't the best example, but can we assume for the sake of it that there was some ordering on Type
06:30:55 <Psybur> What do you guys think about Lux?
06:32:45 <lyxia> OK,   max :: forall (a :: ABC) (b :: ABC). _ => f a -> f b -> f (Max a b)   there the kinds look better
06:38:49 <eklavya> is it possible to name a variable "data" in any way?
06:38:56 <eklavya> like `data` or something
06:39:30 <ventonegro> eklavya: data' ?
06:39:37 <erisco> Darwin226, it is a functional relation, as you say, and so for x R y, given x there is some way to derive y
06:40:05 <eklavya> ventonegro: actually I am using purescript and I need to FFI call a JS component which has a "data" field
06:40:19 <Younder> My kndle has in the past when I have plugged it in shown up as a device. Today It doesn't. Any ideas?
06:40:25 <eklavya> so it has to compile to "data"
06:40:44 <eklavya> I am asking here because I am assuming creating a label might work the same there too :P
06:40:45 <erisco> Darwin226, so what you can do is give different implementations for this
06:42:01 <erisco> Darwin226, an implementation f is correct for a functional relation R if forall x y, x R y => x R (f x)
06:42:43 <erisco> Darwin226, therefore, by this we can make a type family and prove it is correct
06:42:44 <nshepperd_> eklavya: purescript doesn't have the equivalent of foreign ccall "data" myFunctionName :: type?
06:43:21 <Darwin226> erisco: You say that compiler can see that the patters are exhaustive, as one of the benefits, but with type families the compiler basically writes those definitions for you.
06:43:25 <eklavya> nshepperd_: no idea, I barely know it :(. Also it's actually a prop for a component
06:43:26 <nshepperd_> In haskell you can rename a ffi imported function
06:43:46 <eklavya> so I need to pass a record { data : something ... } to it
06:43:49 <Darwin226> It's cool that it can check that my definition of Max is correct, but why should I bother?
06:44:25 <Darwin226> Or, well, it's not really checking my definition but my proof that some assertion holds
06:44:35 <eklavya> I guess I should wait till somebody replies in the purescript gitter
06:44:42 <eklavya> sorry for the noise :)
06:45:05 <nshepperd_> Ah, so it's a row type with "data" field or something
06:45:10 <lyxia> eklavya: there's a #purescript channel here too
06:45:12 <Darwin226> I guess I'm more interested in the compiler writing those assertions (and proving them via computation)
06:45:35 <eklavya> lyxia: it looked pretty dead last time
06:45:39 <erisco> Darwin226, I don't understand what you are saying the compiler does for you
06:45:40 <eklavya> let me check again
06:45:53 <eklavya> nshepperd_: yes, the name is the problem
06:46:04 <eklavya> the required field name is supposed to be data
06:47:42 <Darwin226> erisco: So with your method you're asserthing `p :: Maximum '[A, B, C] C` and then you're proving that fact in the definition. Compiler then checks your proof and accepts it.
06:48:26 <Darwin226> Then if you have `[A, B, C]` in some context you can use that proof to get that `C` is in fact the maximum
06:49:25 <Darwin226> On the other hand, with type families you just give the compiler a list and then the compiler compute the maximum, effectively asserting that it is the maximum, and proving that by computing
06:50:24 <Darwin226> Of course, the downside here is that computing only works for fully known types. 
06:50:51 <Darwin226> You can write more elaborate proofs that only use some known properties of a type, without knowing what exactly the type is
06:51:11 <Darwin226> Don't get me wrong, this is great, but it doesn't really fit the same usecases
06:51:20 <erisco> I said they didn't at the beginning :)
06:52:29 <erisco> I am mentioning it because it is possible to think you can get away with a type family and realise that isn't working
06:52:34 <Younder> ventonegro, Thank for the reference I bought the book
06:52:38 <erisco> because what you need is a witness
06:52:57 <erisco> the witness lets you recover some fact about types, by pattern matching
06:54:13 <ventonegro> Younder: You are welcome :)
06:54:19 <erisco> and it isn't ultimately about proving things, it is about having correct programs
06:54:39 <erisco> for example, indexing a fixed length vector may have the type  index :: Fin n -> Vec n a -> a
06:54:53 <lyxia> Type class constraints can also serve as a form of "witness". I guess I was shocked by the statement that data families are superior given that I almost exclusively use type families for generic programming.
06:55:00 <erisco> where Fin n is the type of naturals in the range [0, n)
06:57:36 <Younder> Well Haskell is a declarative language. So proving correctness doesn't make much sense. Instead you use assumptions in the place of tests. To prove the soundness of your specification.
06:59:53 <erisco> Younder, how do you get from "Haskell is a declarative language" to "proving correctness of Haskell programs does not make sense"?
07:00:28 <Younder> Well the Haskell program is already a formal spec.
07:00:36 <Cale> Younder: There are plenty of things which one might want to prove about Haskell programs, it certainly does make sense to prove their properties.
07:01:00 <Cale> There are a lot of properties which can't be encoded in the Haskell type system itself.
07:01:04 <erisco> Younder, I don't see how that can be true. That seems incoherent.
07:01:49 <erisco> Younder, the idea that you can use types to specify correct implementations I agree with, if that is what you mean
07:01:51 <Younder> They are all assumptions about how the program should behave. 'Do as I mean not as I say'
07:02:18 <erisco> the notion of "proving" is sensationalised here. There is nothing new going on other than type checking
07:02:28 <erisco> so the fact you type check your programs already says you are proving something
07:03:00 <erisco> all I am showing (and it ain't my idea or work) is that you can say more than you thought you could
07:03:39 <Younder> I am a little confused. I use Isabelle for program proving.
07:04:03 <Younder> The type systemhelps. But is not sufficient.
07:04:16 <erisco> are you referring to Haskell's?
07:05:12 <Younder> I use Haskabelle to convert as Haskell to Isabelle syntax
07:05:35 <erisco> lyxia, what might interest you then is you can show your type families are correct using the specification method I described to Darwin226
07:07:46 <erisco> Younder, Isabelle is also a language but based on a different type theory. We can agree it lets you do more, but for what you *can* say in Haskell, why does it not make sense to say it in Haskell?
07:07:50 <ventonegro> Younder:"I am a little confused" You said that proving correctness of Haskell programs doesn't make sense. How can you be sure you never call `head` on an empty list?
07:08:54 <Younder> That gives a runtime error
07:09:05 <barrucadu> Isn't a runtime error "incorrect"?
07:11:02 <Younder> No it is a input error to the function
07:12:06 <barrucadu> I don't see how a program can be correct if it provides erroneous inputs which cause runtime errors
07:12:17 <ventonegro> Younder: Don't shift blame to the input :)
07:12:35 <ventonegro> Programs must work no matter what
07:12:47 <Younder> It's all Garbage in garbage out. You have to guard against incorrect input.
07:12:56 <erisco> Younder, you are right, it is a problem with the input, and how do we specify what inputs we're allowed to give the "head" function?
07:14:03 <Younder> Well a list of at least one element
07:14:19 <erisco> we use the type
07:14:42 <barrucadu> You can say that a library is "correct" even if some of its functions would error on certain (documented) inputs, but I don't think you can describe an executable program which sometimes errors as "correct".
07:14:53 <ventonegro> Younder: "Well a list of at least one element" And this is what you need to prove
07:15:07 <barrucadu> Normally "correct" for a program excludes sometimes crashing.
07:15:09 <Younder> If it was required to accept no elements then it is a specification error, yes
07:15:47 <Younder> That would fall under the assumptions I mentioned earlier.
07:16:14 <Younder> barrucadu, a runtime error is not a crash
07:16:22 <erisco> I don't think Younder is confused on this. I think they are just taking the perspective that a specification can allow for "garbage in garbage out"
07:16:26 <erisco> i.e. undefined cases
07:16:37 <barrucadu> erisco: I agree that a specification can allow for undefined cases
07:16:48 <erisco> well then, head is correct
07:16:50 <barrucadu> But I don't think a program which can trigger such a case can be considered correct
07:16:53 <Adeon> hey...do I need to upload my own documentation to hackage?
07:17:00 <Adeon> IIRC quite some time ago hackage didn't build docs for a while
07:17:01 <barrucadu> head is correct, a program which calls 'head []' is not
07:17:03 <Adeon> not sure if that's still the case
07:17:19 <erisco> barrucadu, it depends on what your specification of head [] is!
07:17:24 <byorgey> Adeon: no, Hackage builds docs now
07:17:37 <byorgey> http://hackage.haskell.org/package/diagrams%2Dcore is a package I uploaded two days ago and it has docs
07:17:39 <erisco> "this program should crash" is a specification
07:17:51 <erisco> "this program should crash given input x" is another
07:17:53 <Adeon> byorgey: gotcha, thanks
07:17:55 <Adeon> I'll just be patient
07:18:02 <ventonegro> Ok, so let's just drop the erroneous inputs that were anticipated in the spec. That leaves out the real bugs
07:18:07 <byorgey> Adeon: yeah, I'm not sure how long it takes
07:18:34 <Adeon> well I uploaded only 5 minutes ago so I would be impressed if it built them that fast
07:18:56 <byorgey> Adeon: ah, yes =)  It probably takes on the order of a few hours.
07:19:00 <erisco> but we're inclined to make the improvement to not have undefined cases
07:19:14 <Myrl-saki> Sweet jesus, you can have record syntax under sum types.
07:19:18 <erisco> because practically speaking that is something we contend with when fixing programs
07:19:24 <ventonegro> Myrl-saki: Unlearn that
07:19:30 <Myrl-saki> ventonegro: I hope I can.
07:19:33 <Myrl-saki> ventonegro: :(
07:19:42 <byorgey> Adeon: note that if something does go wrong with building the docs, the 'Status' field on the hackage page will have a link to the build log
07:19:52 <Adeon> good to know
07:19:52 <Myrl-saki> I'm sorry for those who have learned it today too. Please unulearn it.
07:20:09 <erisco> you might specify that the program has undefined behaviour in a certain circumstance, but in practice our new task is to then prevent these circumstances
07:20:45 <erisco> because practically the boss and customers are not happy if the program misbehaves
07:21:04 <erisco> misbehaves by their implicit specification, which is to not blow up
07:21:25 <erisco> "just don't do that" is not a practical solution for user interaction
07:21:43 <erisco> and not even that practical for programmers
07:22:43 * hackagebot traildb 0.1.2.0 – TrailDB bindings for Haskell – https://hackage.haskell.org/package/traildb
07:22:48 <erisco> also in the implicit specification is "not too slow"
07:23:35 <erisco> everyone expects the program to finish the intended work at least within the lifetime of the people intended to receive the answer
07:25:45 <erisco> but more probably "before I get bored and watch another YouTube video instead"
07:26:00 <Younder> All assumptions as I metioned earlier. A spec has to be practical
07:26:22 <Younder> Not just mathematically correct
07:26:23 <ph88_> what are existential types useful for ?
07:26:28 <ventonegro> Younder: You cannot spec all possible errors
07:26:43 <ventonegro> Younder: Otherwise there wouldn't be bugs
07:27:00 <erisco> ventonegro, "bug" is a vague word
07:27:20 <ventonegro> Ah, come on
07:27:33 <ventonegro> You know what I mean, unintended behaviour
07:27:50 <ventonegro> Crashes, losing money, firing missiles
07:27:56 <erisco> it matters what it means, because what it means is the reason why your conjecture is true
07:28:02 <Younder> ventonegro, No, you can't so you keep adding assumptions. On the input on the behavior and on the output. There is no panacea
07:28:45 <Younder> But a applicative program is still a spesification in it's own right.
07:28:47 <erisco> the only formal meaning of a bug is an implementation incorrect as per the formal specification
07:28:47 <ventonegro> Younder: So your argument is, because we cannot prove all, we shouldn;t prove anything?
07:28:52 <trigone> hi! i got a stack project. i have several library files (B, C, D), and one which exports all which is needed (module A). Main imports module A only. in my cabal file i had only mentioned A in "exposed-modules". when i tried to `stack build`, it told me i should add B, C, D to either the exposed-modules or to the other-modules list. what's weird is, i have another project with a similar configuration, for which i wasn't asked to do 
07:29:01 <Younder> ventonegro, no
07:29:19 <ventonegro> Younder: I honestly cannot follow
07:29:23 <erisco> then we just have to see that a formal specification may not represent the actual desires
07:29:32 <barrucadu> All programs are specifications, in a very boring way
07:29:36 <barrucadu> Regardless of the language
07:29:37 <erisco> what you called "intended behaviour"
07:29:47 <ski> ph88_ : abstract data types. when types depend on run-time values
07:29:51 <byorgey> trigone: I don't know why you weren't asked to do that for the other project.  You should have been.
07:29:55 <erisco> i.e. there is a possible mismatch between what we formally specify and what we actually mean, and that is insurmountable
07:30:24 <erisco> unless we have humans with perfect intentions
07:30:39 <Younder> ventonegro, the assumptions are there to prove the soundness of the spec. People make mistakes when they specify things.
07:30:51 <trigone> byorgey: hm... so, the difference between exposed and other-modules is, the former implies it can be accessed by modules outside of the library part?
07:31:01 <byorgey> trigone: right
07:31:04 <trigone> (and the latter can't?)
07:31:09 <erisco> but that isn't the case... rather we both make mistakes in the present and fail to predict the future
07:31:54 <byorgey> trigone: right, other-modules are not exported from the package.
07:32:02 <ventonegro> Younder: can you agree that trying to get the head of an empty list is not desirable?
07:32:36 <erisco> barrucadu, specifications for machine code? :)
07:32:45 <trigone> byorgey: but wrt to Main.hs? (in the same stack project) is Main always seen as "outside the package of the library" so to speak?
07:33:29 <dmwit> Main isn't really special except that it's the default name of the module containing `main`.
07:33:38 <dmwit> You could write a library which exposed a module named `Main`.
07:33:43 <dmwit> It would just be antisocial to do so.
07:34:17 <byorgey> trigone: are you talking about a .cabal file with both a library section and an executable section, with the Main.hs specified as the source of the executable?
07:34:19 <dmwit> (Because it would be harder to write a program which depended on that package.)
07:34:22 <Younder> ventonegro, so what? If zero elements are an option then it should be a part of the spec. The difference between assumption generated at compile time. And tests tested at runtime are not that great. But input needs to be tested at runtime as it is not known at compile time
07:34:26 <trigone> byorgey: yes exactly
07:34:40 <byorgey> and the build-depends of the executable includes the library itself?
07:34:43 <trigone> dmwit: i'm not antisocial :P
07:34:46 <ventonegro> Younder: it's a simple question, yes or no?
07:35:23 <Younder> ventonegro, no it isn't. It depends on the context
07:35:32 <erisco> Younder, no, if it is statically checked then it does *not* have to be checked at runtime
07:35:35 <byorgey> ventonegro, Younder, erisco: This argument seems to be generating more heat than light.  Could you move it to #haskell-blah please?
07:35:37 <trigone> byorgey: oh actually it does. i don't remember when i added it... unless it was done by default?
07:36:20 <trigone> byorgey: hm in the other project when it didn't bug me, i hadn't added the library package name to the list of build-depends of the executable section...
07:36:23 <ventonegro> Actually, I give up. Life is short :)
07:36:55 <trigone> byorgey: should i remove the package name of the executable's list?
07:37:48 <byorgey> trigone: no, I think the best practice is to include the library in the build-depends for the executable, and list all library modules in either exposed-modules or other-modules
07:38:01 <lyxia> trigone: you don't need to if the executable doesn't depend on the library, but that's an odd thing to have.
07:38:13 <trigone> lyxia: no, it does depend on it
07:38:34 <lyxia> trigone: does it still compile without?
07:38:54 <trigone> byorgey: ok... what's the deal with having an executable in a project which somehow is not part of the package? i mean all this is really confusing... why separate the executable from its internal library?
07:38:57 <lyxia> I mean without the name in the build-depends
07:39:14 <trigone> lyxia: yes it does, that's the weird thing (well more or less i still don't get much of the big picture)
07:40:14 * hackagebot warc 1.0.2 – A parser for the Web Archive (WARC) format – https://hackage.haskell.org/package/warc
07:40:19 <trigone> lyxia: wait, now it doesn't anymore... i'm lost... it didn't need it in another project, but i don't know what makes a difference... 
07:40:38 <lyxia> trigone: you probably have all your source files in the same place if it still compiles
07:41:31 <trigone> lyxia: could it be a question of hierarchy? in the other project, i have "exposed-modules X" and all the modules which i don't mention are of the form X.Y.Z
07:41:33 <byorgey> trigone: This is a tricky area.  No one is claiming that the current behavior of cabal+stack is the best possible behavior.  (At least I'm not.)  I don't completely understand all the details myself.
07:41:34 <lyxia> in that case the executable doesn't think this code belongs to the library, and you end up recompiling the code.
07:41:42 <kgadek> anyone knows the place to learn about stackage for GHC 8.2.x? esp. when is it scheduled, what are the blocking tickets, etc
07:42:12 <lyxia> trigone: I don't think that plays a role.
07:42:17 <trigone> lyxia: sorry i don't understand what you mean...
07:44:07 <barrucadu> kgadek: Stackage nightly is already using GHC 8.2
07:45:02 <kgadek> barrucadu: yes. wondering when will that become LTS-10
07:45:04 <trigone> ok now the other project doesn't compile... nevermind, i give up, i'll just add all the modules in the cabal, and that'll be good :)
07:45:24 <trigone> thanks everyone :)
07:45:58 <dmwit> trigone: I don't think you can have "an executable in a project which somehow is not part of the package".
07:46:30 <dmwit> trigone: Either the package's cabal file includes an executable section for that program, in which case it's part of the package and in the project both, or it doesn't, in which case it's neither.
07:47:06 <dmwit> trigone: The normal way to have a program and a library, with the program using modules that are also in the library, is to list those modules in the `exposed-modules` part of the library and have the executable depend on that library.
07:47:15 <trigone> dmwit: so why do i need to tell to the executable section that it depends on the very package it resides in?
07:47:23 <dmwit> trigone: Modules which are needed to support the exposed modules but not needed by end users (including the program) go in `other-modules`.
07:47:42 <dmwit> trigone: The executable section can also have its own `other-modules` section if there are modules needed to build the executable but not needed in the library.
07:48:01 <dmwit> trigone: You don't depend on packages. You depend on libraries.
07:48:20 <dmwit> trigone: Libraries are just one component of a package. There can also be executable components, test components, benchmark components, ...
07:48:26 <trigone> ok...
07:49:02 <dmwit> It is a historical artifact that packages can only ship a library with the same name as the package, which is probably part of the cause of this confusion. =P
07:50:17 <trigone> dmwit: yeah i guess... the fact that you give the name of the package to the executable section of that same package to imply that it depends on the library of that same package is not really the first intuition :P
07:50:21 <dmwit> trigone: In any case, it would be possible (though unusual) to build package A, version 1.3.2's `foo` executable using package A, version 1.3.1's `A` library.
07:50:39 <dmwit> trigone: Wait, what? No, that's not how you do that. You can name the executable anything you want.
07:51:26 <dmwit> trigone: You make a dependency from executable to library in the usual way: you list the library's name, together with appropriate version bounds, in the `build-depends` section of the executable.
07:51:30 <trigone> dmwit: no i meant you add the name of the package (the first field "name" in the cabal file) to the list of build-depend of the executable section in that same
07:51:32 <trigone> file
07:51:59 <dmwit> Yep. But in reality you are adding the name of the *library* it installs, not the name of the package. It's just coincidence that they have the same name. =)
07:52:16 <trigone> dmwit: yes but the library is named implicitly when you name the package, there's no explicit way to name the library, so it really looks like you just give a package name ^^
07:52:23 <dmwit> yep
07:53:21 <trigone> as always, the most complicated about haskell is everything which is not the language itself..
07:54:14 <dmwit> =)
07:54:29 <trigone> thx dmwit  btw :)
07:59:02 <erisco> @tell Darwin226 this is an example of how to show a type function is correct http://lpaste.net/357956
07:59:03 <lambdabot> Consider it noted.
08:00:12 <erisco> lyxia, if you were interested in how to relate between data families and type families http://lpaste.net/357956
08:02:30 <erisco> this shows how to separate what we want from how to compute it, and how to show the one agrees with the other
08:03:40 <erisco> we can look at the meaning of Max and see obviously it is correct (as per our intention), but as per Darwin226's comment it is not a way to compute the max
08:04:13 <erisco> so we define Max' which computes the max, and it is not as obvious as to whether this does what we want it to
08:05:04 <erisco> and you can imagine as the complexity of the algorithm grows the obviousness of its correctness shrinks
08:05:50 <erisco> so to bring the two together we have a method to show the computation is correct as per the meaning
08:05:59 <lyxia> sure
08:19:30 * hackagebot warc 1.0.3 – A parser for the Web Archive (WARC) format – https://hackage.haskell.org/package/warc
08:19:30 * hackagebot haven 0.2.0.0 – Recursively retrieve maven dependencies – https://hackage.haskell.org/package/haven
08:20:11 <dsal> Does anyone know where stack's ghc builds come from?  I can't install stack on these arm docker images I've been playing with because the gcc enables default PIE and stack can't find an appropriate build.
08:20:29 <cocreature> dsal: https://github.com/fpco/stackage-content/blob/master/stack/stack-setup-2.yaml
08:20:53 <dsal> Awesome, I was looking for this last night.
08:21:03 <cocreature> dsal: they’re quite happy to accept PRs to add more builds
08:22:30 <dsal> cocreature: Do you happen to know a command I can type to get stack to tell me what that OS string is?
08:23:03 <cocreature> dsal: iirc the output of "stack setup" contains that if it fails
08:23:12 <dsal> Yeah, I was just hoping for something sooner.  :)
08:23:19 <dsal> I know what I need, anyway.
08:23:31 <cocreature> not sure what you mean by “sooner”
08:23:45 <dsal> stack something -> this system
08:23:57 <cocreature> why is that better than "stack setup"?
08:24:44 <dsal> Because stack setup takes a long time to fail by running out of disk or triggering corruption on the two machines I can theoretically succeed on.
08:24:59 <cocreature> ah ok
08:25:24 <JuanDaugherty> stack is apparently a pearl before you know what
08:25:25 <dsal> I can see what they are from that list you gave me, but last night, I just wanted to know what the thing was.
08:25:52 <monochrom> Oh w00t Haskell Platform.
08:26:05 * JuanDaugherty just loves stack
08:31:34 <ph88_> ski, do you know a good use case for it ?
08:55:55 * hackagebot hledger-api 1.3.1, hledger-lib 1.3.1, hledger-ui 1.3.1
08:55:56 * hackagebot  → https://hackage.haskell.org/packages/recent
09:09:05 * hackagebot hledger-web 1.3.1 – Web interface for the hledger accounting tool – https://hackage.haskell.org/package/hledger-web
09:21:15 * hackagebot hledger-web 1.3.2 – Web interface for the hledger accounting tool – https://hackage.haskell.org/package/hledger-web
09:21:15 * hackagebot hledger 1.3.1 – Command-line interface for the hledger accounting tool – https://hackage.haskell.org/package/hledger
09:38:34 <dsal> Heh, if I try to build on debian jessie, it works OK, except I need a newer llvm than I have a package available for.  If I try to build on stretch, it fails because of the nopie thing.  I may have to... do something.
09:41:41 <ab9rf> hehe
09:41:45 <ab9rf> dependency hell strikes again
09:43:00 <dsal> It works on raspbian because they build gcc differently.  Subtle difference.
09:44:33 <cocreature> dsal: obviously the solution is to build your own ghc :)
09:44:57 <dsal> I think that is the solution in the long term.
09:45:22 <dsal> However, I might just need to start this image from a raspbian image since that's what I actually want to run the binaries on anyway.
09:45:38 <dsal> I've got raspbian and armbian.  I'm going to guess they're slightly different.
09:54:25 <norc_> ski: myFix :: (a -> a) -> a; myFix f = (\x -> f (unD' x x)) (MkD' (\x -> f (unD' x x)))
09:54:43 <norc_> Typechecks, and it seems to work with all the things.
09:56:31 <lyxia> nice
09:59:07 <lyxia> Now redefine ($) to mean unD' and (. MkD')
10:03:21 <norc_> lyxia: Wait. What?
10:04:05 <[exa]> whoa, what's that good for?
10:05:18 <norc_> [exa]: myFix (1:)
10:06:17 <[exa]> what do unD' and MkD' do?
10:06:21 <norc_> [exa]: https://gist.github.com/anonymous/b8e9b47f3774dac33bf30eba9a959824
10:06:29 <norc_> Here is the full solution with a bit of cleanification.
10:06:43 <norc_> (it also contains the previous steps that led up to this)
10:07:18 <lyxia> norc_: that way you can write (\x -> f (x $ x)) $ (\x -> f (x $ x))
10:07:59 <lyxia> with even more craftiness, (\x -> f . x $ x) $ (\x -> f . x $ x)
10:09:32 <Darwin226> Is polymorphic recursion allowed with type families?
10:09:48 <Darwin226> Kind polymorphic in this case, I guess
10:12:15 <[exa]> norc_: oh so. :]
10:13:37 <byorgey> norc_: that link 404's for me
10:15:00 <lyxia> Darwin226: type family F k (a :: k) where F Type (Proxy (a :: k)) = F k a    ?
10:17:11 <lyxia> Ah I was missing an annotation, this doesn't need TypeInType:   type family F (a :: k1) :: k2 where F (Proxy a) = F a
10:18:31 <Darwin226> Hmm, does it work?
10:19:04 <lyxia> my ghci didn't complain with sufficient extensions, which don't include TypeInType for the latter
10:19:35 <Darwin226> What about type family F (a :: k) where F (c a) = F c
10:20:57 <lyxia> type family F (a :: k) :: k2 where F (c a) = F c
10:21:03 <lyxia> Somehow the two annotations matter
10:21:06 <Darwin226> Weird
10:21:12 <Darwin226> You're right
10:21:13 <Darwin226> Thanks
10:21:31 <cocreature> return kinds default to * iirc
10:21:33 <cocreature> even with PolyKinds
10:22:16 <lyxia> type family F (a :: k) where F (c a) = c   defaults to  k -> k1 -> k
10:22:33 <cocreature> huh ok, apparently I’m missremembering
10:22:54 <lyxia> Without the annotation it can't infer that you want F to be polymorphic in its result kind.
10:24:33 <Darwin226> Even though it might not be
10:24:36 <cocreature> I’m not sure I understand why you can make it polymorphic. it seems like k and k2 are not independent of each other
10:25:48 <filthy_causual2_> So..If I want a type that is a non-empty Vector, is that available somewhere? I know non empty lists are a thing..
10:26:26 <Darwin226> Now check this out: type family F useless (a :: k) :: k2 where F useless (c a) = F useless c
10:26:27 <Darwin226> doesn't work
10:26:35 <Darwin226> but if you put an annotation on useless it does
10:26:37 <lyxia> It might break down when you try to use F.
10:26:42 <Darwin226> Seems like you need to specify everything 
10:26:42 <jared-w> filthy_causual2_: I don't think so. However you can use a smart constructor to ensure that you never have empty vectors in your program
10:27:08 <Darwin226> Though actually, isn't this how it works for polymorphic recursion anyways? If you want inferrence, you can't do it
10:27:16 <jared-w> Darwin226: type inference kinda sucks when using the more advanced features of haskell, sometimes
10:32:36 <ph88> how can i install https://haskell-lang.org/intero#install ?
10:33:08 <ph88> i didn't use emacs before and i don't have .emacs file
10:33:38 <cocreature> create one?
10:34:14 <ph88> oh parsnip is helping me now
10:37:19 <tabaqui> I dunno, if ghc can even use dynamic linking for haskell projects
10:37:21 <tabaqui> can it?
10:39:24 <ertes-w> tabaqui: yes, it can
10:40:12 <tabaqui> ertes-w: I see -dynamic and -shared flags, but it looks that cabal and stack don't use 'em
10:40:46 <ertes-w> tabaqui: yes, it's not the default
10:41:00 <geekosaur> cabal and stack have options for that but they are not the same as the ghc options
10:41:16 <geekosaur> --enable-dynamic-{library,executable} iirc
10:41:58 <ertes-w> i wonder why haskell dynamic linking is still opt-in
10:41:59 <geekosaur> ...because they change how libraries are built, so may require building more stuff
10:42:56 <geekosaur> because it's a PITA and most of the advantages of dynamic linking don't apply to ghc because its cross-module inlining requires exact ABI matches (so you can't just drop in a "compatible" replacement shared object; they generally aren't)
10:43:47 <geekosaur> until very recently, if you built the same library dynamically the same way twice in a row, the results would be ABI-incompatible because generated names differed between them. (I think this has been fixed)
10:44:19 <geekosaur> (basically, library internals leak out via the .hi file for inlining)
10:44:29 <tabaqui> there is no fun to put the whole prelude in every executable
10:44:41 <jared-w> who says the entire prelude is in every executable?
10:44:51 <platz> is there a way to tell haddock to generate links to external packages via a url instead of the default relative file reference?
10:45:06 <geekosaur> tabaqui, one thing static linking can do that dynamic can;t is include only the parts that are actually used
10:45:09 <tabaqui> well, not entirely, but much of it
10:45:31 <Athas> I, personally, enjoy the satisfying *clunk* as 200MiB of binary code impacts my disk at the conclusion of 'stack install'.
10:45:37 <geekosaur> and linkers do that automatially with static libs unless specifically told not to
10:46:13 <platz> that way I wouldn've have to include the 164MB of haddock documentation for the external packages
10:46:36 <tabaqui> geekosaur: it is fine while you distribute binaries to other people, but not much for your own machine
10:46:37 <ertes-w> geekosaur: nix uses dynamic linking by default, which i suppose works, because of the way libraries are stored
10:47:02 <tabaqui> you should have full base in any case
10:47:45 <geekosaur> ertes-w, nix is precisely what was driving cleaning up the generated names issue, because the way nix works even static libraries ended up not being 100% compatible (good enough for ghc but not for how nix does things)
10:47:46 <ertes-w> however, static linking can reduce the closure of a haskell program from 1.5 GiB to a few MiB
10:48:24 <nshepperd_> I enjoy the simplicity of just copying a binary to install something
10:48:26 <ertes-w> geekosaur: yeah, i loosely followed it
10:48:53 <tabaqui> all that you say is true, because haskell doesn't rule the world as C does
10:49:07 <ertes-w> (can you say "loosely" here?  when you mean "not seriously" or "alongside other things")
10:49:07 <tabaqui> dynamic linking was invented to solve this problem
10:50:08 <geekosaur> but C does not have the issues ghc does, because people learned the hard way to enforce hygienic ABIs
10:50:55 <geekosaur> (early KDE did not, for speed it did a lot of things as cpp macros, then they discovered that they had to rebuild everything for small changes because the internals leaking into the ABI broke drop-in replacements)
10:51:23 <geekosaur> but ghc has to take the hit becuase performance is utterly abysmal if you don;t inline everything you possibly can even across modules
10:51:56 <geekosaur> this gets tested regularly (often inadvertently because someone broke inlining in some case)
10:52:30 <tabaqui> but slow compile of GHC is one of the main problem for now, right?
10:52:38 <geekosaur> I am not talking about compiling
10:52:42 <geekosaur> I am talking about runtime
10:52:50 <tabaqui> and the source of almost all alternative haskell compilers
10:52:50 <Athas> Compilation time is certainly my #1 Haskell problem.
10:52:59 <geekosaur> I am talking about 250%+ runtime performance loss without inlining
10:53:25 <Athas> I would accept that cost easily for development, but even 'stack --fast' is not all that fast.
10:53:38 <dolio> C compilers are adding in this feature, though.
10:53:43 <dolio> They just call it something else.
10:54:40 <nshepperd_> Runtime is very bad if you can't inline basic things like (>>=)
10:54:55 <geekosaur> they are but they can't and don't inline across shared object boundaries
10:55:18 <geekosaur> only across static objects
10:56:02 <ertes-w> i solved the "compiling is slow" problem by not compiling at all =)
10:56:11 <ertes-w> my development cycle only uses GHCi
10:56:22 <nshepperd_> You could have cross module inlining that falls back to non inlined slowpath if the dynamically loaded lib is a different version. I think that would be pointless though :)
11:04:01 <monochrom> Interpreters are free of cabal hell and DLL hell. Also stack hell.
11:04:15 <monochrom> This is the only reason why python does not have cabal hell.
11:05:25 <geekosaur> actually even python has it. which is why virtualenv/pyenv was created
11:05:27 <mniip> ertes-w, I've had load times of ghci exceed 5 seconds
11:05:28 <JuanDaugherty> stack hell is what you get when you use it where you should have used hp?
11:05:35 <JuanDaugherty> (i.e. in a global env)
11:05:43 <tabaqui> monochrom: easy, just change interface of your library and wait a little, while Python gets inside new function
11:05:43 <JuanDaugherty> rather than a single project
11:05:43 <geekosaur> stack hell is when you have to nuke your ~/.stack{,-work}
11:05:56 <JuanDaugherty> oh
11:06:11 <geekosaur> and start over from scratch
11:06:14 <JuanDaugherty> that's more like stack fucked gotta redo
11:06:24 <JuanDaugherty> up
11:06:31 <monochrom> C is an exception because C programmers learned to perform inlining and fusion by hand.
11:06:48 <JuanDaugherty> cabal hell you get through no fault of your own
11:07:04 <tabaqui> stack test --ghc-options -O0 helps on debug phase
11:07:09 <ertes-w> mniip: i had those, too, but that's still much better than a minute
11:07:19 <tabaqui> after it just wipe stack and go make some tea
11:07:34 <geekosaur> everyone's got sme form of this, interpreters use things like virtualenv/rvm/perlbrew/etc. to get around it, C mostly works around it with enforced hygiene and pkgconfig (and overly-versioned libraries e.g. foo-1.2.so.2), etc.
11:08:21 <geekosaur> btu ghc deliberately defeats hygiene in the name of performance so it has worse problems than everyone else
11:08:45 <geekosaur> because 400% runtime performance regression when you do things hygienically kinda sucks
11:09:33 <geekosaur> ...sometimes up to 2000% (someone found a case during 8.2.1 prereleases where (>>=) wasn't being inlined and the program got 20x slower)
11:10:13 <monochrom> Yeah, while Python only suffers "django 5.1 vs django 5.2", GHC suffers the additional "django 5.1 91NbsYmAW3YHFFSyOss7u4 vs django 5.1 48OogeCJMUc1lcYcm9OQtr"
11:10:22 <jared-w> Yeah GHC has to do some absolutely ridiculous mangling of code in order to extract sane performance... 
11:10:35 <monochrom> (Fictional version numbers. I don't actually know django.)
11:11:02 <jared-w> The extent of my django knowledge involves making 'django unchained' puns on reddit for easy karma
11:11:11 <monochrom> haha
11:39:48 <tdammers> I've used django once. It was not pretty.
11:39:58 <tdammers> I blame Guido.
11:41:54 <robin> tdammers i like the haskell frameworks better
11:43:27 <jared-w> I like most things Haskell does better
11:43:39 <jared-w> like, shit, I didn't even think I would like lenses more than getter/setters and here we are...
11:43:40 <ertes-w> i can't imagine how something like django *could* be great just from my experience on how terrible python's concurrency frameworks are
11:43:49 <tdammers> robin: I also like Haskell bettter
11:44:21 <tdammers> jared-w: indeed, lenses sit in some of Haskell's darker corners, and yet...
11:44:48 <tdammers> ertes-w: django doesn't do much concurrency itself AFAIK, it offloads most of it to WSGI
11:45:18 <tdammers> then again, WSGI is somewhat underspecified as far as concurrency is concerned, so this alone routinely fucks up nontrivial web apps
11:45:51 <tdammers> test on one WSGI host, run on another, boom, thing blow up because the production host implement concurrency differently, and your code can't handle that
11:46:05 <jared-w> Underspecification and undefined behavior in general is something that, honestly, I think is likely the #1 software-related killer on the planet
11:46:26 <tdammers> undefined behavior is fine, as long as it is specified as such
11:46:33 <tdammers> (fsvo "fine")
11:46:48 <tdammers> in the case of C, it is necessary in order to allow compilers to generate efficient code
11:46:58 <jared-w> untold suffering has happened because of 'null' and undefined behavior in general. I don't really think it's fine even when specified as such :p
11:47:31 <jared-w> Like, Rust has been doing pretty good getting efficient code out without having lots of UB... That might be because it offloads the UB to LLVM? I'm not sure
11:47:38 <tdammers> 'null' was a huge mistake, no argument there
11:48:08 <[exa]> pretty hard to do it correctly on an instruction set that contains undefined behavior.. :]
11:49:00 <tdammers> I'm talking about undefined behavior of the kind where, say, the actual size of an integer type is left to the implementation
11:49:20 <ertes-w> tdammers: so it basically does PHP?
11:49:35 <ertes-w> i always thought that django has a main loop like typical haskell frameworks
11:49:55 <tdammers> ertes-w: uhm, no - C still has fairly reasonable rules wrt integer sizes, it just doesn't mandate a *specific* size for each of them, just minimum sizes and relative sizes
11:49:55 <ertes-w> that makes it even less appealing
11:50:20 <tdammers> oh wait, you mean django
11:50:23 <ertes-w> [exa]: (redirecting tdammers) =)
11:50:43 <ertes-w> …  or…  not…
11:50:45 <tdammers> ertes-w: you didn't set the right caching headers
11:51:52 <jared-w> I'd much rather C didn't do that
11:52:30 <jared-w> I'd vastly prefer that C defined i8, i16, i32, i64, etc., and forced people to use those. If your machine doesn't use those sizes, the code breaks until you make the code correct for that machine again
11:53:03 <ertes-w> i'd vastly prefer if C's popularity just died out
11:53:54 <jared-w> Well yeah, same,, but you don't /need/ integer sizes n such to be UB when you can just design the behavior correctly :p
11:53:56 <ertes-w> however, i wouldn't prefer it to force the programmer to specify the size…  sometimes "the architecture's native size" is the best option
11:54:11 <ertes-w> but then of course (GCC-) C doesn't even have that
11:54:19 <ertes-w> int is 32 bits even on 64 bit architectures
11:55:09 <jared-w> Exactly. Besides, most code that depends on native sized integers likely changes behavior slightly when moving from 64 to 32 bit or such anyway... Doesn't make sense to not code for a specific number and then use guards to switch code out for different architectures
11:55:48 <[exa]> I always thought that the underspecification of C integers was meant as a big fat warning that you should use <stdint> if you really want to hit it to limits
11:56:23 <ertes-w> well, sometimes it makes sense…  the length of a Vector should be Int
11:56:34 <ertes-w> sometimes it doesn't though…  the length of a list should be at least Int64
11:56:58 <jcjf> would you prefer Nat?
11:57:15 <ertes-w> lazy Text picked the correct type for indices and lengths: Int64
11:57:21 <[exa]> Size_T :D
11:57:27 <ertes-w> (well "correct" in the "practically correct" sense)
11:57:33 <ertes-w> jcjf: no =)
11:57:50 <ertes-w> [exa]: you mean SSizeT ;)
11:58:03 <jared-w> [exa]: the underspecification of C integers always, to me, was a warning that C is originally a big fat hack to save effort when porting Unix to different assemblies so they didn't care about specifying certain things :p
11:58:16 <[exa]> yeah, haskell port of size_t. :D
11:58:17 <ertes-w> (it's not a typo)
11:58:18 <jcjf> not ULONG_PTR?
11:58:25 <ertes-w> [exa]: no, of ssize_t
11:58:55 <jcjf> (thanks Windows API, I still hate you)
11:59:03 * [exa] just discovered ssize_t
11:59:13 * [exa] eyeburn
11:59:54 <jcjf> ptrdiff_t
11:59:57 <[exa]> jared-w: take it as a primitive form of generic programming, it was, like, 1980, right? :D
12:00:35 <dolio> ML was around in 1973.
12:00:47 <ertes-w> jcjf: how can you hate the inherent poetry in MsgWaitForMultipleObjectsEx and LPCWSTR?
12:01:21 <jcjf> LPCTSTR :)
12:01:57 <ertes-w> jcjf: https://msdn.microsoft.com/en-us/library/cc230352.aspx
12:02:18 <jared-w> ML and lisp are based gods of programming
12:02:29 <ertes-w> pick any random sequence of up to eight capital letters…  it's probably a data type in windows =)
12:02:36 * jared-w stares sadly at the popularity of... C...
12:02:37 <[exa]> btw was WORD FAR PASCAL WinMain(INT,LPSTR) this in msvc5 or before?
12:02:48 <jcjf> oh has MS gotten rid of TCHAR now? yay!
12:03:04 <[exa]> they have WCHAR
12:03:06 <jared-w> jcjf: if they've gotten rid of it, it's only because they found something worse to replace it with :p
12:03:14 <jcjf> anyway I better leave before I break down in tears
12:03:19 <[exa]> :D
12:04:10 <ertes-w> i think redmond got redundancy wrong
12:04:39 <ertes-w> usually the purpose of redundancy is to *keep* things in memory…  windows redundancy is there so you can forget
12:05:01 <[exa]> s/can/want to/
12:05:10 <geekosaur> they were using redundancy as in data communications >.>
12:05:13 <ertes-w> s/want to/will/
12:05:26 <[exa]> :]
12:05:39 <[exa]> anyway guys, any of you going to ICFP 17?
12:05:44 <ertes-w> the only API name i can remember is MsgWaitForMultipleObjectsEx, and only because i regularly make fun of it =)
12:06:28 <robin> tdammers good :)
12:08:18 <jared-w> ICFP?
12:08:31 <Psybur> Multiple object sex TEEHEE
12:09:10 <[exa]> jared-w: the conference with haskell and so
12:09:10 <jared-w> ertes-w: that's a pretty great API name lol
12:09:31 <jared-w> [exa]: oh sweet. Where's it at? (although I 99% can't go since I don't imagine it's anywhere near me)
12:09:59 <geekosaur> oxford, looks like
12:10:07 <[exa]> http://icfp17.sigplan.org/ oxford, sep 3rd
12:15:52 <jared-w> so much for that :p
12:16:07 * jared-w is but a poor student and can't really travel outside of the PNW
12:17:29 <iqubic> jared-w: I live in the PNW.
12:17:37 <iqubic> Pacific Northwest.
12:17:50 <jared-w> Really? Sweet. I'm in the Portland area
12:18:03 <jared-w> I like Seattle a lot but don't go up there as often as I want to
12:18:09 <[exa]> well I'm also a poor student (currently trying to patch together a poster for that occasion btw)
12:18:33 <[exa]> they got student's grants etc, if you show some research
12:22:48 <iqubic> jared-w: I live in Seattle.
12:23:40 <jared-w> oh that's neat. I don't have any research done since I'm still a junior in my CS degree and the only big Haskell thing I've done is my HSOC project
12:23:59 <geekosaur> time to borrow another idea from the perl community: YAHC-NA >.>
12:24:16 <jared-w> iqubic: Seattle is great. I'm thinking about moving there for a bit after I graduate, if I can find anything. I don't know of any places in Seattle that do Haskell or FP though. And the only place I know of in Portland is Galois
12:43:24 <Tuplanolla> What are metric spaces with non-real-valued distances called?
12:45:49 <dmwit> Tuplanolla: Metric spaces are categories enriched over a special category built on the reals. Perhaps you can make a parallel construction of categories enriched over a similarly-structured category built on a space other than R.
12:46:09 <jared-w> https://proofwiki.org/wiki/Complex_Plane_is_Metric_Space this seems relevant
12:46:16 <Tuplanolla> All you seem to need is order, zero and addition, dmwit.
12:46:25 <dmwit> The wikipedia page for "Metric Space" has the details of the construction.
12:46:30 <dmwit> Tuplanolla: Agreed.
12:47:14 <dmwit> jared-w: The distances there are still real-valued, though, no?
12:48:54 <jared-w> dmwit: yeah, they are. I crossed a wire and thought we were talking about metric spaces built on something other than R (ie one built using C) and forgot we were looking for something with non-real-valued distances :p
12:49:08 <lavalike> Tuplanolla: it reminded me of this https://en.wikipedia.org/wiki/Non-Archimedean_ordered_field
12:49:13 <jared-w> I don't think there is a metric space with non-real-valued distances although I must admit I'm quite out of my element with these
12:49:31 <dmwit> Tuplanolla: Anyway I think it's easy to cook up a suitable definition, and I don't know of any widely-accepted name for the obvious such definition.
12:51:43 <lavalike> equipped with one of those, as well as a notion of completion, you're set to do analysis
12:52:43 * hackagebot gnss-converters 0.3.14 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
12:52:44 * hackagebot haskell-src-exts-util 0.2.1 – Helper functions for working with haskell-src-exts trees – https://hackage.haskell.org/package/haskell-src-exts-util
12:53:45 <Tuplanolla> Things like this make me feel that most mathematicians have no taste.
12:55:16 <jared-w> lol why?
12:55:39 <Tuplanolla> Why would you impose more structure than you need, jared-w?
12:56:03 <jared-w> ahh, that. Yes, I don't like having more structure than needed for anything
12:56:17 <Tuplanolla> It's like depending on jQuery just to do arithmetic.
12:56:52 <jared-w> It feels necessary often in programming because using fine grained hierarchies is still a pain in the ass in languages, but for pure math? The world's your oyster, why settle for less than the most beautiful and cleanest, minimal way to do something?
12:57:52 * hackagebot haskell-src-exts-util 0.2.1.1 – Helper functions for working with haskell-src-exts trees – https://hackage.haskell.org/package/haskell-src-exts-util
13:02:00 <jared-w> lol I hate doing that (pushing a revision 2 minutes after I pushed something)
13:03:38 <Tuplanolla> It's major, minor, revision and oh-yeah-that-thing-I-forgot.
13:05:14 <jared-w> For me it's major, minor, revision, oh-yeah-that-thing-I-forgot, and one extra symbol reserved for "I suck at git I'm sorry for my transgressions pls no hate"
13:07:21 <Rembane> Pi-base.
13:12:31 <iqubic> I want to have a base Pi counting system.
13:13:00 <Rembane> It's quite good for trigonometry, and quite bad for almost everything else.
13:15:54 <dolio> Is it actually even good for trig?
13:17:00 <lyxia> e^i = 1
13:17:13 <lyxia> e^10i = 1
13:17:29 <lyxia> e^10i = -1
13:17:31 <lyxia> phew
13:17:44 <iqubic> e^(pi*i) = 1
13:17:53 <geekosaur> -1
13:17:57 * lyxia resigns from math.
13:18:10 <geekosaur> e^{pi*i) + 1 = 0
13:19:16 <Rembane> dolio: Yes, you just have to pick the right angles. 
13:19:56 <dolio> It doesn't seem like most of the angles that come up regularly would actually have nice representations.
13:20:07 <dolio> Other than pi and 0.
13:21:07 <Rembane> dolio: For all the angles that are a fraction or multiple of pi, you can remove the pi. For instance pi/4 becomes 1/4.
13:21:20 <dolio> 4 isn't base pi.
13:21:27 <geekosaur> pi rationals
13:21:44 <lyxia> pi = 1 * pi^1 + 0 * pi^0 = 10
13:22:34 <Rembane> > pi**(-1)
13:22:36 <lambdabot>  0.3183098861837907
13:22:41 <hodapp> I thought various things were only defined for rational radices
13:23:03 * Rembane has probably gotten this wrong.
13:23:10 <hodapp> dolio: perhaps Rational Trigonometry is more what you want
13:25:26 <dolio> Rembane: I think what you want is a 'unit' that incorporates the pi.
13:25:39 <dolio> Not base-pi numbering.
13:26:12 <dolio> Because you only ever want to factor out 1 copy of pi.
13:26:15 <hodapp> dolio: degrees of pi-ness, even?
13:26:35 <dolio> You can kind of just look as pi as that unit, though.
13:26:56 <dolio> 1/4 pis.
13:28:58 <dolio> Maybe it's better to choose some smallest fraction of pi such that everything that gets used is an integer multiple, though.
13:29:41 <dolio> Since that's what degrees gets you.
13:30:58 <Rembane> dolio: Yes. I got it all wrong. :D
13:31:23 <Rembane> dolio: Hm... what about pi/360 as the smallest fraction?
13:31:38 <dolio> 360 is more than necessary, I think.
13:31:50 <Rembane> 60?
13:32:02 <geekosaur> ob https://www.sciencedaily.com/releases/2017/08/170824141250.htm
13:32:08 <jfischoff> My project depends on another Haskell project that also has a c header file (.h file). How can I can #include a header file in haskell project I depend on?
13:32:10 <geekosaur> which suggests 60 :p
13:32:14 <dolio> I don't really remember the smallest number of degrees that has a nice (co)sine, though.
13:32:32 <dolio> 30?
13:32:43 * ski . o O ( egyptian fraction ratioonal trigonometry )
13:33:16 <geekosaur> jfischoff, you'd have to install it as a data file in some location the other project can find
13:33:47 <jfischoff> geekosaur: okay is there an example of a project that does that?
13:33:56 <iqubic> Let's try my favorite game: Pi degrees of Bacon.
13:34:08 <geekosaur> I don't know of one offhand
13:34:56 <jfischoff> alright I’m just going to hack it for now then
13:35:09 * ski . o O ( <https://en.wikipedia.org/wiki/Exact_trigonometric_constants> )
13:36:32 <dolio> Okay, yeah, 30 degrees.
13:36:45 <dolio> So pi/120, I guess.
13:37:00 <Rembane> ski: Nice! Trigpron!
13:37:08 <dolio> Er, pi/12.
13:43:28 <dsal> Is there a way to get a dependency tree out of a stack project?
13:43:39 <ski> > map (360 /) [1.5,1.875,2.25,2.8125,3,3.75,4.5,5.625,6,7.5,9,11.25,12,15,18,21,22.5,24,27,30,33,36,39,42,45,54,60,67.5,72,75,90]
13:43:41 <lambdabot>  [240.0,192.0,160.0,128.0,120.0,96.0,80.0,64.0,60.0,48.0,40.0,32.0,30.0,24.0,...
13:43:42 <dsal> My project seems to require aeson, but I don't know why.
13:44:43 * dsal learned how to search
13:45:38 <dsal> "http2" -> "aeson";
13:46:02 <dsal> heh, I wrote that json encoder for nothing.
13:46:12 <dsal> But it's still 3 orders of magnitude faster than aeson for my uses, so I'm OK with it.
13:47:11 <mnoonan> has anybody played around with ekmett's 'roles' package (and specifically, the Representational typeclass)?
13:49:08 <dsal> "stack dot" either displays ~nothing or ~everything.  This feels like a bug.
13:55:28 <Tuplanolla> Try `stack exec ghc-pkg -- dot | tred | dot -Tsvg > /tmp/ghc-pkg.svg`, dsal.
13:56:41 <jfischoff> geekosaur: adding the header file `install-includes` allowed my package to import it FWIW
13:57:48 <dsal> Tuplanolla: That shows me a lot -- I get a similarly large graph with --external.  If I target a specific package, I get no edges.
13:59:35 <mnoonan> Tuplanolla, if your distance order satisfies the property that there is a countable set M such that for all x, y: x < y => exists m in M . x <= m <= y, then the domain of your distance function embeds into R
14:00:15 <mnoonan> so in some sense, R-valued metric spaces are the whole story unless you start to care about distances that take values in some set with really excessive cardinality
14:01:15 * hackagebot gnss-converters 0.3.15 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
14:01:57 <Tuplanolla> I expected that, but I still don't like it, mnoonan.
14:02:47 <dolio> Isn't that condition trivial, because you can always pick m=x or m=y?
14:03:44 * ski . o O ( "Metric Spaces, Generalized Logic, and Closed Categories" <https://golem.ph.utexas.edu/category/2014/02/metric_spaces_generalized_logi.html> )
14:03:59 <ski> dolio : i suppose `x' and `y' needn't be in `M' ?
14:04:11 <dolio> Oh.
14:07:17 <dolio> In that case, you can't do it for distances that are an uncountable ordinal, I think.
14:07:30 <dolio> Even of equal or lesser cardinality to the real numbers.
14:16:54 <Tuplanolla> I should probably crash the next upcoming local abstract algebra course with these silly questions.
14:18:06 <Tuplanolla> I'm sure a department that prides themselves in classical analysis will be able to appreciate theories without reals.
14:37:35 <c_wraith> Tuplanolla, I'd think you'd be better off crashing analysis and measure theory courses. 
14:38:39 <Tuplanolla> I already went to those and they were set theory and set theory, c_wraith.
14:40:40 <hodapp> Tuplanolla: are you one of those hippie constructivists?
14:41:11 <Tuplanolla> Sometimes, hodapp.
14:41:54 <c_wraith> they have a point. if something can't be constructed, how can you claim it exists? 
14:41:56 <hodapp> sometimes to the constructive part or the hippie part?
14:42:44 <hodapp> c_wraith: the point that I kind of see is that it may still be a useful abstraction that greatly eases certain things, but there may be ways to get all of this without relyingon nonconstructive concepts
14:45:02 <c_wraith> hodapp, I think super strict constructivism is overkill. (exponentials aren't the end of the world, OK?) But I have to admire the philosophical underpinnings, if not the extremes. 
14:45:35 <hodapp> c_wraith: what's this about exponentials and constructivism?
14:46:33 <Radj> is xmonad wm good start for learning haskell?and... what can I do with haskell in linux?
14:47:51 <c_wraith> hodapp, exponentials are dangerous for constructive approaches. if you allow unfettered exponentials, you can easily convert a countable-length construction into an uncountable-length construction. 
14:47:54 <hodapp> most anything you can do with any other language
14:48:25 <filthy_causual2_> I mean getting to attached philosophically to either is silly when they can both talk about the other. There is more then one useful idea of truth, deal with it.
14:48:36 <Tuplanolla> The complement of real-time and low-memory programs, Radj.
14:49:07 <c_wraith> Radj, xmonad is a bit idiosyncratic. it does give you nice motivation to learn what's going on, but it's not much like most haskell code. 
14:49:07 <hodapp> filthy_causual2_: not sure anyone here is too attached philosophically to either one
14:49:21 <filthy_causual2_> Fair.
14:49:43 <hodapp> filthy_causual2_: this has very little to do with "truth", but more to do with what's a useful model
14:50:13 <filthy_causual2_> "convert a countable-length construction into an uncountable-length construction. " Can you give an example I am not sure what you mean?
14:50:40 <Radj> which one book is the best for beginners?
14:50:59 <filthy_causual2_> Are there logics where (N -> N) is internally countable?
14:53:05 <c_wraith> filthy_causual2_, well, that's exactly what I meant.. N is countable, but N -> N isn't. so some of the more radical constructivist positions forbid even talking about exponentials, such that you never have to deal with that. 
14:53:47 <filthy_causual2_> Hmm.
14:54:07 <filthy_causual2_> That does seem like over kill.
14:54:25 <c_wraith> I'm sure it does have some uses. 
14:54:37 <c_wraith> but it's pretty strict. :) 
14:55:18 <hodapp> ultrafinitism ftw
14:56:14 <filthy_causual2_> You might be able to get a weird LEM. Like anything you can talk _about_ is decidable?
14:56:17 <ski> filthy_causual2_ : there are logics where `(N -> N) -> N' is in bijection with `N'
14:57:33 <c_wraith> Radj, that's a bit contentious. a lot of people like http://haskellbook.com/ but some really dislike it. I haven't even read it, so I'm not sure. but I do think the authors have a good philosophy of educational approach. 
14:57:56 <c_wraith> Radj, other people here might have other recommendations 
14:59:18 <filthy_causual2_> ski: in fact they are the logics I have been looking for for a while.
14:59:41 <Tuplanolla> We don't have the problem that most books are garbage, so the choice doesn't matter much, Radj.
15:00:05 <ski> filthy_causual2_ : so i suppose you're familiar with bar induction, fan theorem
15:00:32 <filthy_causual2_> I have read about them, but can never remember them.
15:00:56 <ski> (iirc Escardó suggested somewhere that it's related to Double-Negation-Shift)
15:03:29 <Radj> tnx a lot, i would like to try.
15:04:44 * ski . o O ( "Constructive gem: double exponentials" <http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/> )
15:07:20 <mauke> we've secretly replaced their constructive gems with functional pearls, let's see if they notice
15:11:00 <hodapp> nonconstructive mush
15:22:18 <filthy_causual2_> Can you prove that N^N is not isomorphic to N constructively?
15:24:26 <ski> filthy_causual2_ : Cantor ?
15:25:17 <ski> every `f : N -> N^N' fails to be surjective
15:25:38 <filthy_causual2_> Ah, yeah that is constructive isn't it. Wasn't unpacking what "constructive" actually means. >.<
15:26:50 <ski> (we even construct an explicit point which is not in the image)
15:44:44 * hackagebot haskell-src-exts-util 0.2.1.2 – Helper functions for working with haskell-src-exts trees – https://hackage.haskell.org/package/haskell-src-exts-util
16:03:30 <remexre> Stack question: is it possible to use GHCJS with a recent LTS resolver (e.g. 9.1)
16:03:48 <jle`> you'd have to use one of the ghc-8 builds
16:03:56 <jle`> but i don't see why not
16:04:16 <remexre> Okay, I was unsure because the docs use LTS 7.19
16:04:16 <jle`> you might have some issues when ghc 8.2 comes onto lts though
16:04:40 <jle`> be aware that ghcjs HEAD is ghc < 8
16:04:58 <jle`> but there are some precompiled binaries of ghc 8.0 available, and also the ghc-8 branch is very buildable
16:05:11 <remexre> ok
16:05:16 <jle`> disclaimer i haven't tested it on lts-9
16:08:03 <remexre> Where do I get a list of the GHCJS versions? The latest one listed on the docs is compatible with GHC 8.0.2
16:08:33 <geekosaur> the newer one is a branch in its git repo
16:08:38 <geekosaur> not a release
16:09:11 <jle`> back when i was briefly involved with ghcjs dev, i don't remember them having any real versioning
16:09:25 <remexre> erm, lemme rephrase that
16:10:15 <remexre> what are the legal values for the compiler field in the stack.yaml, and how do I find which one corresponds to a version of GHCJS compatible with GHC 8.0.2?
16:27:55 <jle`> remexre: i'm not sure, but you might get some better help at #ghcjs :)
16:29:25 <remexre> Oh, cool, didn't know that was a thing, thanks!
16:29:59 <jle`> no problem!
16:30:08 <jle`> there's also the github issue tracker, which is pretty active iirc
16:31:34 <remexre> ok, thanks!
16:38:07 <slui> Hey, can anyone lend me a hand? I've started programming in Haskell 2 days ago and was wondering if there is any way to run a function multiple times with the same parameters.  I wanted to run a function that gives me a random number in a range, but I don't want a simple Ad-Hoc solution for this function. Preferentiably a more flexible one, that may be used for any kind of function and parameters. Just a newbie question here...
16:39:30 <ski> well, if you run a function multiple times with the same parameters, you always get the same result value
16:39:37 <HallaSurvivor> slui: anything with randomness should take place in the IO monad, as haskell functions must be pure, namely what ski said
16:39:47 <jle`> it doesn't have to be IO
16:39:48 <Rembane> slui: What type does your function have?
16:39:55 <jle`> it could just be parmaeterized by some source of randomness
16:39:56 <HallaSurvivor> what exactly are you looking to do, i'm not sure I understand what you want
16:40:06 <ski> you don't need I/O for randomness. you could pass around a PRNG state explicitly (or not) as well
16:40:09 <HallaSurvivor> jle` fair point!
16:40:14 <slui> giveRand :: Random c => c -> c -> c , giveRand m n = unsafePerformIO . getStdRandom $ randomR (m,n)
16:40:37 <ski> you should not use `unsafePerformIO' like this
16:40:47 <HallaSurvivor> s/like this/at all
16:41:11 <jle`> that's...now how you are supposed to make a random value
16:41:11 <ski> using `unsafePerformIO act' promises that `act', when executed, will always compute the same result
16:41:23 <ski> if you're not prepared to make such a promise, you should not call it
16:41:28 <jle`> that's not how functions are supposed to work in haskell
16:41:31 <HallaSurvivor> slui: What are you trying to do with random numbers?
16:41:48 <HallaSurvivor> why did you decide to use unsafePerformIO?
16:42:25 <slui> Just for educational purposes, and I wanted to use randomList to test other functions
16:42:36 <slui> to create random Lists
16:42:39 <slui> sorry
16:42:52 <HallaSurvivor> slui: No worries! It took me a while to feel comfortable with randomness in haskell
16:43:08 <mniip> just use mapM or replicateM
16:43:14 <HallaSurvivor> One of haskell's big selling points is that you know exactly what a function will do.
16:43:23 <ski> slui : do you know how to use `random' and `randomR' ?
16:43:34 <HallaSurvivor> There's no difference between a function and an infinite lookup table of inputs to outputs
16:44:01 <HallaSurvivor> so randomness is weird, because the same input can give you multiple outputs (provided you don't explicitly pass around some state, as others pointed out)
16:44:12 <ski> @type random
16:44:13 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
16:44:14 <ski> @type randomR
16:44:15 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
16:44:39 <ski> slui : e.g., can you define `randomTwice :: (RandomGen g,Random a) => g -> ((a,a),g)', that will generate *two* (independent) random values of type `a' ?
16:44:43 <mniip> > (`evalState` (mkStdGen 0)) $ replicateM 10 $ state random
16:44:45 <lambdabot>  [9106162675347844341,-5782012937088350469,3531325756418318423,-5618565702727...
16:45:09 <jle`> slui: but yea,h one of the "points" of haskell is that calling the the same function with the same values should always give the same results
16:45:15 <jle`> it's a 'function' in the mathematical sense
16:45:32 <jle`> you might be thinking about 'function' in the imperative programming sense, which is what we would typically call a "subroutine"
16:45:49 <jle`> imperative programmers are bad with naming :)
16:46:10 <ski> > ((`evalState` mkStdGen 0) . replicateM 10 . state) (randomR (0,9))
16:46:12 <lambdabot>  [3,3,3,8,0,7,1,1,1,6]
16:46:30 <jle`> slui: but you should be able to use randomR twice to get two values
16:46:36 <jle`> all you have to do is use the new key that it gives
16:46:37 <jle`> :t randomR
16:46:39 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
16:46:50 * ski idly wonders whether slui will respond
16:46:58 <jle`> slui: see how randomR gives you a new g?
16:47:03 <jle`> you can use that new 'g' and pass it to randomR again
16:47:22 <mniip> > (`evalState` (mkStdGen 0)) $ replicateM 10 $ state random :: String
16:47:25 <lambdabot>  "\589059\462557\49287\35934\235848\784755\136809\233345\533545\544822"
16:47:30 <mniip> nice
16:47:36 <HallaSurvivor> (ski: how do you do the idle wondering thing?)
16:47:48 <mniip> /me
16:47:58 * HallaSurvivor i guess we can test that
16:48:02 <HallaSurvivor> whoa
16:48:14 * Rembane hands HallaSurvivor a third person transmogrifier.
16:48:22 * mniip got jinxed
16:48:25 <ski> > ((`evalState` mkStdGen 0) . replicateM 40 . state) (randomR (' ','~'))
16:48:27 <lambdabot>  "}-7sfJqvb:_R;WVMH5*J6bCW?V93ICTT7`M99iK)"
16:48:32 <slui> Yeah saw it, interesting approach, just didn't understand what does the state function does in it
16:48:45 <jle`> you probably don't have to use the state function or State here
16:48:46 <ski> slui : one step at a time. can you define `randomTwice' ?
16:48:52 <mniip> slui, state/replicateM might be a bit over your head for now
16:49:00 <Rembane> Hm...
16:49:01 <HallaSurvivor> I'm with mniip
16:49:01 <Rembane> > ((`evalState` mkStdGen 0) . replicateM 40 . state) (randomR (' ','~'))
16:49:03 <lambdabot>  "}-7sfJqvb:_R;WVMH5*J6bCW?V93ICTT7`M99iK)"
16:49:08 <Rembane> :D
16:49:09 <jle`> slui: ski and mniip (and Rembane) are just having some fun
16:49:13 <mniip> Rembane, what did you expect
16:49:33 <Rembane> mniip: I hoped for the same result.  And I got it! :D
16:49:49 <ski> HallaSurvivor : i don't know, i don't think about it
16:50:00 <Rembane> mniip: http://wasdarwinwrong.com/images/464988a-i1.0.jpg :D
16:50:30 <HallaSurvivor> ski: are you a wizard? :O
16:50:35 <slui> I just know that randomR gives me a function g -> (a,g), that when I pass it to getStdRandom returns me an IO a
16:50:52 <HallaSurvivor> slui: How do you feel about the IO monad?
16:50:56 <jle`> slui: you give randomR a 'g' to get a random 'a'
16:51:06 <mniip> slui, what does getStdRandom have to do with anything
16:51:15 <jle`> slui: to randomR also gives you a new 'g'
16:51:20 <jle`> slui: so...you can use it again :D
16:51:25 <mniip> Rembane, that doesn't load
16:51:29 <jle`> but yes, write randomTwice earlier
16:51:47 <jle`> that'll give you an understanding of how to call randomR twice with different g's
16:52:06 <jle`> randomRTwice :: (a, a) -> g -> ((a,a), g)
16:52:16 <jle`> randomRThrice :: (a, a) -> g -> ((a,a,a), g)
16:52:18 <HallaSurvivor> jle`: I typically use randomRIO, so i don't actually know. Presumably if you give it a g explicitly and then continue passing your output around its deterministic, right?
16:52:33 <jle`> and, at that point, you can jump to the next level:
16:52:34 <ski> slui : you can use `mkStdGen' to generate a `StdGen' (suitable for passing to `random',`randomR',`randoms',`randomRs',`randomTwice',&c.), when testing
16:52:45 <HallaSurvivor> mniip: Which presumably is why slui was looking into getStdRandom
16:52:54 <jle`> randomRNTimes :: (a, a) -> Int -> g -> ([a], g)
16:52:56 <ski> @type mkStdGen
16:52:58 <lambdabot> Int -> StdGen
16:53:22 * mniip admits to having used unsage unsafeperformio-ed randoms during ICFPC
16:53:25 <jle`> once you write randomRTwice and randomRThrice, you should be ready to tackle randomRNTimes
16:53:34 <jle`> which is what you originally wanted
16:53:42 <ski> slui : but, obviously, if you call `mkStdGen' on the same `Int' seed, you get the same PRNG state back (and hence the same sequence of random numbers will be generated, if you perform the same random number computation)
16:54:42 * hackagebot dotenv 0.5.0.1 – Loads environment variables from dotenv files – https://hackage.haskell.org/package/dotenv
16:55:07 <ski> slui : so, in the end, you want your actual `StdGen' that you start with to depend on something which changes over time (such as, e.g. clock) .. however Haskell takes care of this, if you get it from the `IO' monad. still, for testing in the interactor (GHCi), `mkStdGen' is useful, to "fake" it
16:57:02 <HallaSurvivor> slui: Sorry, by the way, if we're a lot, or if this is hard to follow. The haskell community is super helpful, and when we see something we know we can help with, a lot of people want to get in on it
16:57:26 <HallaSurvivor> which is good, except you end up with 5 different sets of advice running in parallel :P
16:57:58 <ski> @quote contrapuntal
16:57:58 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
16:58:30 <ski> (it used to be something about "majestic stereo")
16:58:38 <mniip> ski, needs more nitpick
16:59:04 <mniip> technically we're not answering his question
16:59:05 <ski> nitpick is forthcoming when we see the actual code
16:59:19 <ski> don't you worry
16:59:26 <lavalike> @quote remember's
16:59:26 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
17:02:18 <ggVGc> HallaSurvivor: is that because haskell is so good at concurrency?
17:02:47 <hpc> i would correct you and say parallelism, but irc is anything but pure ;)
17:03:09 <ggVGc> I approve the correction
17:03:45 <ski> (don't tell anyone, but the universe is actually only operating with cooperative concurrency)
17:04:11 <mniip> cooperative?
17:04:19 <mniip> are you sure there isn't a scheduler
17:04:48 <hpc> it's running on the eve online engine
17:05:00 <hpc> you can tell because if you put too much stuff in one place, time slows down
17:05:01 <EvanR> "Floating point numbers are not exact, and may yield strange results when compared. For example 6.0 / 3.0 may not equal 2.0" is this completely wrong
17:05:22 <mniip> EvanR, this specific division yes
17:05:37 <EvanR> thought so
17:05:39 <mniip> however I remember something like 2.8-0.8 != 2.0
17:05:46 <hpc> > 6 / (3 :: Float) == 2
17:05:46 <EvanR> sure
17:05:48 <lambdabot>  True
17:05:49 <mniip> > 2.8 - 0.8 == 2.0
17:05:51 <lambdabot>  False
17:06:05 <EvanR> but 6.0/3.0 is like, extra paranoid
17:06:18 <mniip> hpc, integer arithmetic up to 2^52 is basically guaranteeed
17:06:25 <erisco> afaik whole numbers are supposed to be lossless in a particular range
17:06:28 <hpc> if you use Float instead of Double, it's really easy to get bad results
17:06:55 <hpc> Float is the same size as Int32, so in exchange for decimal numbers it loses a ton of precision in the outer range
17:07:14 <ggVGc> hpc: can I go through walls if I run really fast
17:07:14 <ggVGc> _
17:07:15 <ggVGc> ?
17:07:26 <hpc> it's very easy to write real-world code that uses integers that will experience float rounding
17:07:32 <erisco> ggVGc, yes
17:07:53 <EvanR> quantum tunneling and antitunneling
17:07:59 <hpc> whole numbers are lossless for the number of bits in the mantissa
17:08:02 <ggVGc> nice
17:08:06 <ggVGc> I'll start trying
17:08:07 <erisco> though it is more like both you and the wall become an atomised mist together
17:08:08 <hpc> which for Double is 2^52
17:08:16 <hpc> and for Float is something ridiculously small like 2^11
17:08:27 <EvanR> o_O
17:08:28 <ski> ggVGc : collision detection is hogged and bypassed, <https://en.wikipedia.org/wiki/Quantum_tunneling>
17:08:39 <ggVGc> yeah I read about that years ago
17:08:43 <ggVGc> pretty cool
17:09:01 <ggVGc> ski: question is
17:09:05 <ggVGc> how fast do I need to run
17:09:14 <EvanR> how much weight do you need to lose
17:09:26 <ggVGc> all the atoms
17:09:29 <ggVGc> I guess
17:09:42 <erisco> no, you just need to lose your protons and electrons
17:09:49 <ggVGc> oh well then
17:09:52 <erisco> neutrons interact weakly with other matter, so you'll pass through just fine
17:09:53 <ggVGc> that makes it a lot easier
17:10:09 <hpc> EvanR: i suggest reading up on IEEE floats, it teaches a pretty important lesson on the tradeoffs of trying to stretch an encoding in a particular direction
17:10:23 <EvanR> is it really up to 2^11
17:10:34 <hpc> don't quote me on that specific number, but yeah
17:10:38 <hpc> it's smaller than 2^32
17:10:43 <hpc> > maxBound :: Float
17:10:44 <lambdabot>  error:
17:10:45 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
17:10:45 <lambdabot>      • In the expression: maxBound :: Float
17:10:49 <hpc> hmm
17:11:03 <EvanR> i figure they would use similar proportion for mantissa and exponent
17:11:04 <dmwit> ggVGc: Pretty sure you can go darn slow compared to quantum tunneling needs by just hitting a fast enough speed that you smash the wall to smithereens.
17:11:05 <ggVGc> very early in my programming life I started comparing floats within tiny ranges rather than equality
17:11:18 <dmwit> ggVGc: 200-300 mph ought to be sufficient for most walls
17:11:23 <ggVGc> dmwit: I have a feeling I will also smash
17:11:29 <dmwit> details
17:11:36 <hpc> single precision is accurate up to 2^23
17:11:37 <EvanR> ggVGc: which... somehow doesnt make me feel any better about that operation
17:11:41 * ski . o O ( Neutronium man, fimfiction )
17:11:51 <erisco> now you statically check error bars, right?
17:11:53 <hpc> if you encoded an RGB pixel as an integer
17:11:58 <hpc> you could not precisely represent it with a Float
17:12:22 <dmwit> However, if you encoded an RGB pixel as a Float you probably could precisely represent it.
17:12:29 <dmwit> You could probably even do RGBA!
17:12:39 <hpc> dmwit: you can, the encoding is just ridiculous
17:12:48 <EvanR> erm, 
17:12:48 <hpc> but it's by definition possible because they're the same number of bits
17:12:59 <hpc> OH NO WAIT IT IS NOT POSSIBLE STILL
17:13:03 <EvanR> do the variety of NaNs survive ?
17:13:15 <hpc> i just remembered, NaNs are considered to be all the same
17:13:16 <hpc> ish
17:13:23 <EvanR> so they might not survive
17:13:42 <hpc> so encoding RGBA as a float depends on how you interpret the extra NaN bits
17:13:46 <hpc> but you could do RGB
17:13:52 <hpc> maybe
17:14:06 <EvanR> we should repurpose this channel to be about floats
17:14:11 <hpc> yeah, just don't max out the exponent and you're in the defined range
17:14:21 <ggVGc> I'd like to state for the record that I disagree with EvanR 
17:14:30 <ggVGc> I think we should abolish floats
17:14:34 <ggVGc> and do only fixed point math
17:14:35 <ggVGc> forever
17:15:04 <EvanR> fixed point has its own numeric issues
17:15:13 <hpc> we should keep talking about them until someone says "i am drowning in floats"
17:15:16 <hpc> and then never speak of it again
17:15:25 <mniip> double that
17:15:58 <EvanR> we should only use rationals!!!
17:15:58 <hpc> banks tend to use fixed point math because of how silly floats can be
17:16:20 <hpc> it's easy to make a fixed point math library with the right rounding scheme
17:16:27 <mniip> any bank not using decimals should be laughed at
17:16:44 <EvanR> should be shut down?
17:16:55 <hpc> fun fact: how money is rounded is heavily regulated
17:16:56 <mniip> should be abused to bankruptcy?
17:17:09 <hpc> because people have actually tried to pull the scheme in office space
17:17:10 <ski> > decodeFloat (encodeFloat (2^24 - 1) 0 :: Float)
17:17:12 <lambdabot>  (16777215,0)
17:17:14 <ski> > decodeFloat (encodeFloat (2^25 - 1) 0 :: Float)
17:17:16 <lambdabot>  (8388608,2)
17:17:37 <erisco> EvanR, what about infinite sequences of rationals?
17:17:48 <EvanR> those are cool
17:18:11 <erisco> can we actually compute with that?
17:18:18 <mniip> yes
17:18:24 <mniip> there was a library
17:18:29 <hpc> erisco: who cares about that, are they webscale?
17:18:37 <mniip> CReal is effectively that, iirc?
17:18:46 <EvanR> you can, but they dont necessarily correspond to the computable reals
17:18:53 <erisco> well, they're infinite, so that's pretty big. not sure if that's as big as a web.
17:19:17 <EvanR> only some sequences count as a real
17:19:29 <mniip> most of them don't
17:19:30 <ggVGc> what do I do with a fake sequence
17:19:51 <erisco> fake reals
17:19:56 <mniip> you mean if it doesn't covfefe
17:19:57 <EvanR> unreals
17:19:59 <hpc> report it to the math police
17:20:16 <erisco> mniip, heh, I know what you mean
17:20:38 <dmwit> > showCReal 50 pi
17:20:41 <lambdabot>  "3.14159265358979323846264338327950288419716939937511"
17:20:45 <EvanR> the notion of convergence is subtly dependent on a notion of reals already existing
17:21:00 <ski> how so ?
17:21:07 <mniip> EvanR, no?
17:21:15 <xzhu_> Is there a way to construct an unnamed R list with HaskellR?
17:21:17 <mniip> convergence can be defined on rationals
17:21:21 <EvanR> yes
17:21:29 <xzhu_> In Language.R.Literal there's "toPairList"
17:21:32 <EvanR> theres different ways
17:21:54 <xzhu_> but it only generates a named pairlist
17:22:02 * ski . o O ( <https://en.wikipedia.org/wiki/Surreal_number>,<https://en.wikipedia.org/wiki/Supernatural_number> )
17:22:19 <xzhu_> and empty names are not allowed
17:22:46 <ggVGc> EvanR: why is convergence dependent on reals?
17:22:47 <EvanR> i am thinking of equality of reals, not validity of a sequence of rationals
17:22:54 <EvanR> so ignore that
17:23:01 <hpc> if a surreal number and hyperreal number collide, they create an entangled pair of real and imaginary numbers
17:23:04 <hpc> just ask CERN
17:23:14 <HallaSurvivor> mniip, ski, ggVGc, if you want to be convergent in your set, I think EvanR means
17:23:14 <ggVGc> but are any of them fake?
17:23:15 <mniip> hpc, fibrated pair
17:23:25 <HallaSurvivor> consider the set of x s.t. x < sqrt(2)
17:23:28 <HallaSurvivor> in Q
17:23:36 <EvanR> i was not talking about sets
17:23:44 <HallaSurvivor> sorry, sequence
17:23:46 <HallaSurvivor> I misspoke
17:23:59 <HallaSurvivor> the one that is obviously cauchy and converges to sqrt(2) (in R)
17:24:05 <HallaSurvivor> in Q, it's cauchy, but not convergent
17:24:06 <ski> HallaSurvivor : you can define convergence without having a prior notion of reals
17:24:15 <HallaSurvivor> because sqrt(2) is not a rational
17:24:20 <mniip> HallaSurvivor, hmm, the sequence I had in mind did not converge to sqrt(2)
17:24:27 <HallaSurvivor> ski: I completely agree! I may have misunderstood the problem
17:24:54 <EvanR> the notion of equality of reals in hott book uses a recursive reference to the reals
17:25:00 <EvanR> during its own definition
17:25:15 * ski has in mind a sequence that converges to zero iff peano arithmetic is consistent
17:25:16 <mniip> EvanR, are you sure it's not rational equality
17:25:23 <mniip> ski, likewise
17:25:25 <EvanR> thats the base case
17:25:53 <mniip> I should finish Mac Lane and resume HoTT sometime
17:28:35 <ski> HallaSurvivor : you may already know this, but you can call cauchy sequences "convergent". then you define reals as represented by such sequences, with equality defined by a suitable equivalence relation on the underlying sequences representing the reals
17:29:10 <ski> (so this is a quotient type)
17:29:53 * ski looks at slui
17:32:58 <mniip> he probably continued messing with unsafePerformIO and went bind
17:32:59 <EvanR> cauchy reals in hott makes use of something called a cauchy approximation, x : Q+ -> R such that for all eps,delta : Q+, x(eps) and x(delta) are epsilon+delta-close to each other
17:33:40 <EvanR> you can get a cauchy approximation from any cauchy sequence
17:34:05 <ski> mm, that's similar
17:35:02 <EvanR> the kicker is the target is R and epsilon-closeness is a relation on reals, defined inductively along with the reals
17:35:41 <EvanR> so that avoids cauchy sequences
17:36:43 <EvanR> and setting up a metric
17:37:13 <ski> "epsilon-closeness" being ?
17:37:43 <EvanR> a relation between reals
17:37:50 <ski> what's it used for ?
17:37:52 <EvanR> it amounts to being closer than epsilon
17:38:02 <mniip> that sounds l ike a metric
17:38:15 <EvanR> its not, since a metric gives you a real
17:38:47 <HallaSurvivor> ski: Cauchy sequences are my preferred constructive defn of the reals!
17:38:54 <ski> you appear to be saying that reals and "epsilon-closeness" are defined together, an inductive-recursive definition
17:38:56 <EvanR> ski: its used in the construction of the reals, since you cant finish the job without explaining how two reals are equal
17:39:05 <EvanR> yes
17:39:33 <HallaSurvivor> Though I'm the kind of person who would say "consider the only complete ordered field" and be done with it :P
17:39:34 <ski> EvanR : can't you explain that in terms of the "epsilon+delta-close" relation (on cauchy approximation, not on reals), that you mentioned ?
17:39:57 <EvanR> the target of a cauchy approximation is the reals we are defining
17:39:58 <dolio> I didn't think anyone had proved induction-recursion compatible with univalence and whatnot.
17:40:19 <EvanR> its a higher inductive type, dunno if its proven compatible or what
17:40:40 <dolio> Oh, I see.
17:40:48 <EvanR> hot book page 383
17:40:49 <dolio> That's not really the same thing.
17:41:27 <EvanR> in that induction recursion is a well defined thing and hitts arent? 
17:41:37 <EvanR> HIT
17:41:48 <dolio> No, induction-recursion is a specific thing, and higher inductive types are a specific other thing.
17:41:51 <ski> HallaSurvivor : <http://paultaylor.eu/ASD/analysis>
17:42:05 <EvanR> they are now?
17:42:14 <dolio> Yeah, ASD with Dedekind cuts is pretty money.
17:42:38 <EvanR> i havent seen a allowed grammar of HITs yet
17:42:51 <EvanR> theres things you can naively do and get nonsense
17:43:28 <ski> HallaSurvivor : "Synthetic Differential Geometry" (2nd ed.) by Anders Kock in 2006 at <http://home.imf.au.dk/kock/sdg99.pdf>
17:43:46 <dolio> EvanR: Yeah. Higher inductive types are where you give 'generators' of 'higher' parts of the type, just as you're allowed to give generators for the 0th (or whatever) level.
17:44:40 <dolio> Induction-recursion is where you simultaneously give generators for a type and a recursive function on that type that is allowed to be referred to by the constructors.
17:44:49 <EvanR> ok
17:45:13 <dolio> Induction-recursion is a generalization of the definition of the universe in Martin-löf type theory.
17:45:37 * ski . o O ( Mahlo universe )
17:45:53 <dolio> Yeah, it's having a universe that is closed under universe-formation, sort of.
17:46:07 <EvanR> in the case of the hott reals above, its actually 2 HITs being defining with mutual induction
17:46:09 <erisco> sort of properties
17:47:03 <dolio> Mahlo is a similar property of large cardinals in set theory.
17:47:04 <ski> that's just two inductive types being mutually defined, then
17:47:24 <dolio> Which gets used to model induction-recursion.
17:47:25 <EvanR> higher because of the equality
17:47:35 <EvanR> so called higher inductive
17:48:09 <EvanR> eps closeness also contains a rule for equality, which propositionally truncates it
17:49:43 <EvanR> if p,q : x eps-close-to y then p = q
17:53:23 * ski . o O ( "w, ww, www. PS: ordinals, mahlo" <http://www.dcs.ed.ac.uk/home/pgh/wwwwww.html> )
17:56:27 <dolio> ski: Oh, that makes it a lot clearer why Mahlo is related to induction-recursion.
17:57:16 * ski is reading about holy trinities
18:01:32 <koz_> I'm a little unclear on something with recursion schemes as described here: http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/ . Basically, suppose I have 'data Tree a = Leaf a | Bin (Tree a) (Tree a)'. I can define a Functor for it, but I'm not sure how it interacts with the recursion scheme machinery (especially Fix). Could someone please enlighten me?
18:03:35 <erisco> koz_, data Tree a s = Leaf a | Bin s s;  Fix (Tree a)
18:03:51 <ski> koz_ : you'd probably instead define `data TreeF a tree = Leaf a | Bin tree tree', and then `type Tree a = Fix (TreeF a)'. `TreeF a' is a functor
18:08:10 <dolio> ski: You've seen the agda definition of the ordinals that's the Ord, R, S from that article, right?
18:18:14 <koz_> erisco and ski: Ah, I see, that makes sense now.
18:18:32 <koz_> I assumed you'd need the extra type parameter, but I wasn't too sure how to precisely define it.
18:24:18 <koz_> ski: I'm not clear how the fmap for (Bin x y) shoudl be written in this case. Is it just 'fmap f (Bin x y) = Bin (fmap f x) (fmap f y)'?
18:28:58 <koz_> ski: Never mind, I am apparently of low intellect.
18:29:02 <koz_> Sorted now.
18:40:35 * ski . o O ( <https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/>,<http://www.dcs.ed.ac.uk/home/pgh/holy-trinity.html> )
18:40:43 <ski> dolio : hm, not that i can recall
18:41:18 <ski> koz_ : or just unfamiliar with this
18:42:31 <koz_> ski: Either or.
18:42:47 <koz_> I just used Haskell's 'holes' feature and checked what types were needed.
18:42:52 <koz_> Then the answer became obvious. :P
18:43:51 <ski> with some practice, you should be able to run the type-inferences in your head, at least for simpler examples like this
18:44:23 <koz_> ski: Yeah, I should be capable of this by now. More practice is clearly what I need.
18:46:52 <onethirtyfive> I think I have an idea of what the "!" strictness operator does, but does anyone know of any guidance/tutorial on when it's appropriate to use it? What benefits does it provide, etc?
18:47:08 <onethirtyfive> as a noob, I am seeing it in library code and wondering why the author elected to use it.
18:47:15 <onethirtyfive> and when I should :)
18:47:23 <erisco> for speed and less memory use
18:47:50 <koz_> onethirtyfive: Do you know about laziness vs non-laziness? There's a good bit of literature on this: http://dev.stephendiehl.com/hask/#laziness
18:47:51 <c_wraith> onethirtyfive: https://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html is a good guide for how to think about what it does
18:47:55 <mniip> onethirtyfive, !n is a pattern that evaluates the matched value to whnf
18:48:25 <mniip> the rest you can derive yourself!
18:48:36 <erisco> lol
18:48:45 <onethirtyfive> A wealth of information. :) Thanks.
18:48:54 <koz_> onethirtyfive: We do our best. :)
18:54:12 <crobbins> is there something like traverseM out there?
18:54:43 <erisco> :t traverse
18:54:45 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:54:46 <crobbins> something like cats' flatTraverse - https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Traverse.scala#L50
18:54:51 <koz_> crobbins: Any Monad is also an Applicative.
18:55:37 <crobbins> erisco, koz_ i need something that does >>= inside of the traverse
18:55:39 <crobbins> so
18:55:51 <erisco> sure, do that :)
18:55:58 <crobbins> f a -> (f -> m (f b)) -> m (f b)
18:56:11 <erisco> read koz_
18:56:37 <koz_> erisco: Are you saying I should read, or crobbins should read?
18:56:48 <crobbins> oops i mean: f a -> (a -> m (f b)) -> m (f b)
18:56:59 <erisco> reading is good for everyone
18:57:37 <crobbins> well alright then
18:58:01 <c_wraith> :t \f -> sequence . traverse f
18:58:01 <erisco> that is the signature you desire? for Monad m and Applicative f?
18:58:03 <lambdabot> (Applicative t, Traversable m, Traversable t, Monad m) => (a1 -> t a) -> m a1 -> m (t a)
18:58:51 <c_wraith> oh, no
18:59:25 <erisco> I don't read Scala so it is a bit difficult for me to know what that example is
18:59:34 <crobbins> (a -> t a) is not (a -> m (t a))
18:59:56 <crobbins> erisco: i thought reading is good for everyone? ;)
19:00:12 <erisco> yeah, it would be good if I could
19:00:40 <erisco> so the signature you gave, if I am understanding the context correctly, is not implementable
19:01:12 <c_wraith> :t \x f -> fmap join $ traverse f x
19:01:13 <lambdabot> (Applicative f, Traversable m, Monad m) => m a1 -> (a1 -> f (m a)) -> f (m a)
19:01:38 <erisco> you require  f (m (f b)) -> m (f b)  which is not possible for general Applicative f
19:02:41 <erisco> crobbins, maybe you should describe what you want to do instead
19:02:45 <c_wraith> my code matches the actual scala
19:03:18 <c_wraith> the scala is f a -> (a -> g (f b)) -> g (f b)
19:03:24 <koz_> Suppose I have two sorted vectors and I wanna merge them together to make a big sorted vector. I wanna do this in O(n). My current thought involves folding in the state monad to track indices in the two arrays being merged, but I suspect that's overcomplicating things. Is there a better/easier way?
19:04:03 <erisco> and what context? we'd be smart not to leave contexts out of the discussion right now
19:04:33 <c_wraith> Applicative g, Monad f
19:04:41 <c_wraith> For some reason they call Monad "Flatmap"
19:05:14 <slack1256> bind = join . fmap , so it makes sense the Flatmap :-)
19:05:26 <c_wraith> yes, but Monad is more than bind
19:05:48 <slack1256> maybe calling the structure by their more representative operation?
19:06:05 <erisco> one is not more representative than the other
19:06:36 <slack1256> which other?
19:06:55 <c_wraith> crobbins:  "fmap join $ traverse f x" is even a direct translation of that code to Haskell.
19:07:31 <erisco> there is bind and there is return
19:08:16 <slack1256> maybe they have some Applicative class with "pure" on it
19:08:27 <c_wraith> :t \f -> fmap join . traverse f -- crobbins, this would be the more natural argument order in Haskell, though
19:08:28 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
19:10:10 <c_wraith> Oh, that's in the definition of the Traverse trait in the scala code, so it also has the equivalent of the Traversable constraint
19:10:19 <c_wraith> That's why it can work.  Got it.
19:12:19 <crobbins> nice thanks c_wraith, so i guess this doesn't exist as a function already, you basically have to roll your own. hence why hoogle had no idea what i was talking about :D
19:12:31 <ski> koz_ : is a recursive loop too involved ?
19:12:45 <c_wraith> crobbins: well, given that it's just an "fmap join" away, it's pretty low-effort.
19:12:49 <koz_> ski: I don't think I quite follow.
19:13:23 <ski> koz_ : keeping the two indices in two parameters, "updating" them on recursive calls
19:13:30 <c_wraith> crobbins: function composition has very low syntactic overhead in Haskell.  It makes naming a lot of these things less urgent.
19:13:37 <koz_> Ah, I see. let me try and write that.
19:14:07 * ski assumes koz_ is really working with "vectors", and not lists ..
19:14:18 <koz_> ski: I am working with Data.Vector.Vector.
19:14:22 * ski nods
19:30:31 <trigone> hi! is there a way to tell hackage to define the source of the function as its automatic documentation? in a lot of cases it's just as concise and easy to understand, if not better, as natural language... and this way there's no way to update the documentation in case the function changes (provided it's still easy to understand)
19:30:36 <trigone> sorry i mean haddock
19:30:43 <trigone> *meant
19:31:05 <trigone> *there no need to update
19:31:40 <trigone> (i should really read myself before keying enter)
19:32:37 <koz_> ski: I ended up writing one using a State monad, which looks kinda sorta OK.
19:36:21 <koz_> ski: This is what I have: http://lpaste.net/357966. I welcome comments and improvements.
19:42:42 * hackagebot turtle 1.4.2 – Shell programming, Haskell-style – https://hackage.haskell.org/package/turtle
19:57:22 <EvilMachine> Hmm, I’m still wondering how to solve the following problem properly: Having a core program, with runtime-loadable modules with functions that can use types that were not know at core compile time, but whose class *is*. I’m falsely assuming that the core can handle a concrete data structure whose size it cannot know, just because it knows which functions it could use on them. But how do I handle structures of unknown size
19:57:22 <EvilMachine>  in general?
19:58:58 <EvilMachine> In C, you’d of course just use a pointer to void, and cast. But I use Haskell because I dislike that!
20:00:04 <EvilMachine> All I can think of, is having the modules use structures made only from known base types (Like Int, Char, [].)
20:11:33 <koz_> The name 'hylomorphism' comes from the Greek root meaning 'trees'?
20:11:48 <koz_> Or is it the Greek root meaning 'matter, substance'?
20:11:54 <koz_> Or am I wholly off-base.
20:11:57 <koz_> s/./?/
20:13:05 <EvilMachine> More like wholly off-topic. ;)
20:13:17 <EvilMachine> Even off-language. :P
20:14:50 <koz_> EvilMachine: I don't think it's wholly off-topic - there has to be a reason that name got chosen, and hylomorphisms, like all recursion schemes, are kinda important in functional programming.
20:15:12 <koz_> I was just curious if anyone knew, because unlike the others (catamorphism, anamorphism, etc), I don't see the connection.
20:43:18 <EvilMachine> koz_: Don’t worry. When nobody’s here, anything goes, really. ^^
20:44:08 <koz_> EvilMachine: Nearly 1500 people is hardly 'nobody', lol.
20:44:38 <EvilMachine> koz_: Well, online doesn’t mean sitting in front and reading. :)
20:44:49 <EvilMachine> especially not any moderators. :D
20:45:22 <EvilMachine> koz_: I, on principle, boycott such snobist inkhorn terms though. So I can’t help you, beyond translating the term to English and seeing what that gets you.
20:45:23 <koz_> EvilMachine: Point taken.
20:45:40 <EvilMachine> koz_: Usuall
20:45:52 <koz_> EvilMachine: The descriptivist in me says 'that's the terms everyone else uses, so if I wanna be understood, I should use them too'.
20:46:21 <EvilMachine> koz_: Usually, the best time to ask, is in the UK evening. From my experience, that’s when the most people are active here.
20:46:34 <koz_> EvilMachine: I'll keep that in mind, thanks!
20:47:39 <EvilMachine> koz_: Well, I do what I think is right, and have no interest in having contact with people who don’t, as that means they harm me. If that means I have no contact with any humans, then good. :) Different philosophies … :)
20:49:54 <EvilMachine> I never understood Grammar, due to all the weird words for its concepts. So I wrote a small greasemonkey script that replaces all those words by plain German (I’m from Germany) translations on Wikipedia. (And “bad word” censoring Greasemonkey script can be re-purposed for this.) Suddenly, everything became easy and understandable.
20:50:33 <EvilMachine> I’m trying to do the same with medical terms, and some day with math and its horrible horrible one-obscure-character identifiers. :)
20:51:04 <EvilMachine> Oh, gotta go. Wish you luck in 2+ hours here, when the first people wake up. :)
21:22:56 <dsal> @undo  args <- getArgs; (opts, _) <- parseOpts args
21:22:56 <lambdabot> <unknown>.hs:1:6:Parse error: <-
21:23:08 <dsal> @undo { args <- getArgs; (opts, _) <- parseOpts args }
21:23:08 <lambdabot> <unknown>.hs:1:1:Parse error: {
21:23:23 <dsal> You're not very helpful, lambdabot
21:25:55 <geekosaur> you need the do
21:26:10 <geekosaur> @undo do { args <- getArgs; (opts, _) <- parseOpts args }
21:26:11 <lambdabot> <unknown>.hs:1:52:Parse error: Last statement in a do-block must be an expression
21:26:16 <geekosaur> also true...
21:26:46 <iqubic> @undo do { args <- getArgs; (opts, _) <- parseOpts args; return opts }
21:26:46 <lambdabot> getArgs >>= \ args -> parseOpts args >>= \ (opts, _) -> return opts
21:26:53 <iqubic> Is that what you want?
21:38:04 <dsal> Oh.  Kind of.  I actually found a good article in the haskell wiki about how to do this, because after my program worked, it still seemed kind of dumb. heh
21:46:22 * hackagebot numhask 0.1.0 – A numeric prelude – https://hackage.haskell.org/package/numhask
21:58:31 * hackagebot numhask 0.1.1 – A numeric prelude – https://hackage.haskell.org/package/numhask
22:03:07 <jared-w> oh hey, numhask got updated!
22:03:47 <iqubic> Twice in fact.
22:18:47 * hackagebot numhask 0.1.2, projectile 0.0.0.2, teardown 0.2.0.0
22:18:47 * hackagebot  → https://hackage.haskell.org/packages/recent
22:49:22 <koz_> jle`: Thanks for the updated post! https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
22:52:13 <jle`> koz_: no problem!  it has been long overdue :)
22:52:24 <koz_> I will definitely read it.
22:54:25 <jared-w> ooo, sweet post jle`
22:55:20 <koz_> jle`: I think you have a typo. 'By having our mapVec :: (a -> b) -> Vec n a -> Vec m b' <- you mean 'Vec n a -> Vec n b', right?
22:56:00 <jle`> koz_: ah yes definitely
22:56:25 <jle`> leave it to the one line that i didn't typecheck
22:56:39 <jared-w> tsk tsk :p
22:56:51 <koz_> jle`: It's OK, I'm just a pedant for such things.
22:57:40 <jle`> definitely understandable, because the fact that it's Vec n a -> Vec n a is a major pedagogical point
22:58:47 <jle`> it's like the whole point of the example haha
23:03:02 <koz_> Definitely need to lern me some singletons.
23:03:59 <jle`> it can come in handy :)
23:04:08 <Lokathor> so say i have an "m (Maybe a)", and I want to just do it over and over until I get a (Just a) back
23:04:20 <Lokathor> is there some fancy combinator for that built into base somewhere
23:05:01 <koz_> Lokathor: You mean an 'm (Just a)'?
23:05:58 <Lokathor> no i have an action that gives back (Maybe a), and i want it repeated every time Nothing comes back until a Just comes back
23:06:15 <koz_> Ah, sorry, I misread.
23:06:17 <jle`> Lokathor: might be one in monad-loops
23:06:21 <jle`> hm
23:06:34 <koz_> monad-loops: The left-pad of Haskell. :P
23:06:39 <Lokathor> i will just do it by hand, it's probably easier :P
23:06:49 <jle`> you might be able to use MaybeT with 'many'/'some'
23:07:04 <Lokathor> actually, come to think of it, i need to do either >_>
23:07:20 <Lokathor> the top level signature of the function overall is
23:07:20 <Lokathor> runMenu :: MonadException m => [String] -> InputT m (Either SelectError String)
23:07:53 <Lokathor> and i can do it with recursion but there's some setup and tear down that's a little costlier than i'd like to repeat a bunch
23:09:25 <jared-w> can you setup everything and then jump out to a function that does the looping-until-(Right a) part?
23:09:38 <Lokathor> yeah that's what i'm gonna do
23:16:23 <tabemann> does anyone here know anything about Gtk2Hs, specifically the gtk3 version of it?
23:16:44 <iqubic> tabemann: Why not use gtk-gi?
23:17:03 <iqubic> It's maintained, and Gtk2Hs isn't.
23:17:24 <tabemann> well then - that I didn't know
23:17:40 <tabemann> I was encountering problems with trying to draw to drawing areas, which seemed completely broken
23:17:57 <iqubic> At least I think that's what's up. You'll have to ask someone more knowledgable than I.
23:19:01 <tabemann> I can't find any package named gtk-gi
23:19:54 <iqubic> https://hackage.haskell.org/package/gi-gtk
23:20:02 <iqubic> Sorry, got that backwards.
23:20:09 <iqubic> I think that's the right thing to use.
23:20:31 <iqubic> jle`: You use gi-gtk, right? Can you help out here?
23:21:18 <tabemann> gi-gtk didn't even compile for me
23:21:28 <tabemann> at least gtk3 compiled
23:21:42 <iqubic> Oh, I'm sorry about that.
23:22:30 <tabemann> dumped a pile of errors about ManagedPtr and ForeignPtr
23:23:06 <jle`> iqubic: i don't remember using gi-gtk
23:23:09 <iqubic> I'm not sure how to help you there.
23:23:10 <jle`> sorry :|
23:23:29 <iqubic> Oh, I thought there was someone in the channel who used it.
23:23:41 <iqubic> Must not have been you I guess.
23:24:08 <tabemann> but basically, out of the two options, gtk3 has been made so there's no way to draw to a drawingarea and gi-gtk just doesn't compile... yay
23:24:27 <iqubic> Sounds fun :( :( :(
23:25:41 <tabemann> so now I don't know how I'm gonna implement what I am working on, unless I resort to wx or something like that
23:29:16 <Lokathor> jared-w, koz_, jle`, http://lpaste.net/357968
23:33:36 <iqubic> Looks good lokathor. Does it work?
23:33:49 <Lokathor> tabemann, https://github.com/deech/fltkhs ?
23:34:01 <Lokathor> iqubic, yep, seems to work well
23:38:17 <tabemann> I could try fltkhs
23:38:31 <cocreature> tabemann: what’s the exact error you’re seeing? “a pile of errors about something” is not a sufficient amount of information for us to be able to help you
23:38:46 <tabemann> cocreature: I'm getting errors like:
23:39:03 <tabemann> GI/GLib/Callbacks.hs:1298:25: error:
23:39:04 <tabemann>     • Couldn't match type ‘ManagedPtr OptionGroup’
23:39:04 <tabemann>                      with ‘ForeignPtr OptionGroup’
23:39:04 <tabemann>       Expected type: ManagedPtr OptionGroup -> OptionGroup
23:39:04 <tabemann>         Actual type: ForeignPtr OptionGroup -> OptionGroup
23:39:04 <tabemann>     • In the first argument of ‘newBoxed’, namely ‘OptionGroup’
23:39:06 <tabemann>       In a stmt of a 'do' block: group' <- (newBoxed OptionGroup) group
23:39:08 <tabemann>       In the expression:
23:39:10 <tabemann>         do { context' <- (newPtr OptionContext) context;
23:39:12 <tabemann>              group' <- (newBoxed OptionGroup) group;
23:39:14 <tabemann>              _cb context' group' data_;
23:39:16 <tabemann>              maybeReleaseFunPtr funptrptr }
23:39:29 <cocreature> please use a pastebin service for that
23:39:44 <cocreature> also just show us the full error output and the exact command you ran to end up with this
23:41:26 <tabemann> http://lpaste.net/357971
23:44:07 <cocreature> that’s an ancient version of gi-glib. 2.0.14 is the most recent one
23:44:30 <cocreature> that’s an ancient version of gi-glib. 2.0.14 is the most recent one
23:44:41 <tabemann> that's what I got from a fresh cabal update
23:45:03 <Lokathor> try stackage perhaps?
23:45:27 <cocreature> or "--constraint gi-glib==2.0.14"
23:46:07 <Lokathor> i bet the old version was picked because of some other package having a conflict, and that'll tell you what
23:46:47 <cocreature> "cabal install gi-gtk-3.0.17" might also just be sufficient
23:47:03 <cocreature> it looks like that has bounds on gi-glib that would prevent it from picking up that ancient version
23:48:28 <tabemann> http://lpaste.net/357974
23:50:23 <Lokathor> tabemann, https://www.stackage.org/lts-9.1/cabal.config save that whole thing as "cabal.config" in your project root and give it a try
23:50:39 <Lokathor> all of those packages as a whole should all agree with each other version-wise
23:50:57 <cocreature> tabemann: looks like you don’t have gobject-introspection installed or you have an ancient version. which os are you on?
23:51:06 <cocreature> that’s not a cabal dependency so stackage won’t save you here
23:51:11 <Lokathor> oh no!
23:51:21 <Lokathor> :(
23:52:02 <tabemann> I just installed gobject-introspection and I am still having problems
23:52:19 <tabemann> and I am using Debian 9
23:52:33 <cocreature> “i am still having problems” is not a good description of the error you’re seeing
23:53:59 <tabemann> the error messages I'm getting now are identical to those I was getting before
23:54:12 <cocreature> which version of gobject-introspection did you install?
23:54:32 <tabemann> 1.50.0-2
23:54:52 <Myrl-sak1> Found this on ReaderT design pattern.
23:54:56 <Myrl-sak1> "we have the right to perform any side-effects, including launching the missiles, or worse, throwing a runtime exception."
23:55:13 <cocreature> tabemann: what’s the output of "pkg-config gobject-introspection-1.0 --modversion"
23:56:26 <cocreature> tabemann: there might also be some gobject-introspection-dev package on debian that you need to install
23:57:02 <tabemann> http://lpaste.net/357975
23:58:09 <tabemann> nope, no such package
23:58:15 <cocreature> tabemann: looks like the package is called libgirepository1.0-dev
