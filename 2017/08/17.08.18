00:15:10 <jle`> have to modify someone else's python script
00:15:15 <jle`> really missing types
00:15:17 <jle`> atm
00:15:47 <erisco> it is like programming blind, isn't it
00:17:37 <jle`> yeah it's like fixing a car in the dark
00:17:54 <jle`> or rather, making modifications in the dark
00:35:19 <ertes-w> lo
00:42:28 <pacak> jle`: Exciting.
00:42:33 <pacak> Is it going to explode?
00:43:34 * hackagebot ginger 0.6.0.0 – An implementation of the Jinja2 template language in Haskell – https://hackage.haskell.org/package/ginger
00:44:26 <jle`> trying to prevent an explosion :)
00:45:43 <[exa]> kindof reminds me the java style that includes short type signature in all variables' names
00:46:02 <[exa]> int iCount; unsigned char ucLetter;
00:46:45 <yushyin> [exa]: so called hungarian notation
00:47:09 <ventonegro> [exa]: That's older than Java
00:47:32 <ventonegro> Look at the Windows C API
00:49:53 <[exa]> my bad I tend to call all these styles 'java'
00:50:07 <[exa]> sorry :]
00:50:24 <ventonegro> heh
00:51:10 <[exa]> with python I usually get the type information by stuffing 'print' into the code
00:51:43 <[exa]> the similarity to hs _ is radical
00:52:06 <kadoban> [exa]: Unfortunately that fails when things decide to print like things they aren't, which is fun.
00:53:08 <kadoban> There's that thing to get the type I guess, but I always forget.
00:53:31 <ventonegro> type(...)
00:54:32 <[exa]> "fun" :]
00:54:50 <[exa]> ok let's stop hating duck types
00:56:33 <[exa]> what I wanted to ask -- is there some good article with as-simple-as-possible modification of Hindley-Milner for linear types?
01:38:07 <phadej> erisco: which? :)
01:38:17 <dminuoso> Is having the concept of "optional arguments" (perhaps just Maybe wrapped) sensible in the world of haskell?
01:38:32 <dminuoso> Also that pun "just Maybe" was not intentional. :-P
01:38:54 <tdammers> dminuoso: not really; all Haskell functions are unary, so no arguments can be truly optional.
01:39:11 <phadej> dminuoso: yes, but put Maybe arguments first, so you partially apply them away
01:39:21 <tdammers> patterns that you see sometimes include using Maybe, or having callers pass a list of options
01:39:39 <tdammers> or providing an "option combinator" that allows users to compose an "option set"
01:39:41 <phadej> genFun :: Maybe Text -> Int -> Text; gen = genFun Nothing :: Int -> Text
01:40:06 <phadej> *fun  =
01:40:17 <tdammers> but usually you'll just get multiple flavors of the same function with different names and different signatures
01:41:03 <erisco> you possibly need to make smaller functions if you're finding optional arguments are needed
01:41:03 <jle`> dminuoso: you see some emulation of it using records
01:41:05 <jle`> here and there
01:41:20 <jle`> foo fooArgs { arg1 = "hello", arg2 = "world" }
01:41:32 <jle`> this is essentially uncurrying
01:41:42 <tdammers> oh, yes, records also, especially when paired with `def` (or a custom `defaultSomething` value)
01:42:00 <tdammers> foo def { arg1 = "hello" } -- arg2 and arg3 come from def
01:42:18 <jle`> to be clear, that's associated as foo (def { arg1 = "hello" })
01:44:47 <jle`> it's not exactly a prevalent idiom, but it comes up often enough and is recognizable when it does
01:56:33 <ertes-w> dminuoso: usually the desire to have an optional argument is a result of using the wrong model for your problem, or even flat-out misunderstanding it
01:58:22 <BernhardPosselt1> :t <*>
01:58:24 <lambdabot> error: parse error on input ‘<*>’
01:58:32 <BernhardPosselt1> :t (<*>)
01:58:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:58:41 <BernhardPosselt1> :t fmap
01:58:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:58:48 <BernhardPosselt1> ah :D
01:58:54 <BernhardPosselt1> f (a -> b)
01:59:44 <ventonegro> BernhardPosselt1: When you fmap a partial application, you usually end up with f (a -> b)
01:59:59 <BernhardPosselt1> right, trying to build that stuff into our java code
02:00:24 <BernhardPosselt1> Result monad basically
02:00:44 <ventonegro> :t fmap (+) (Just 5)
02:00:46 <lambdabot> Num a => Maybe (a -> a)
02:00:59 <BernhardPosselt1> regarding Either applicative 
02:01:17 <BernhardPosselt1> only applies the function if both Eithers are not "errors" right?
02:02:17 <ventonegro> BernhardPosselt1: The Left data constructor is left alone by Functor and Applicative
02:02:28 <tdammers> ertes-w: I think there are perfectly valid use cases
02:03:00 <BernhardPosselt1> Left is the "error" usually right?
02:03:08 <ventonegro>  BernhardPosselt1yes
02:03:08 <tdammers> ertes-w: e.g., you want to expose an API that supports a convenient concise form for the most likely use case, but still gives the caller control over some details when they need it
02:03:12 <ventonegro> BernhardPosselt1: yes
02:04:11 <ertes-w> tdammers: sure, but compared to other languages those APIs come up far less often in haskell
02:05:11 * hackagebot hexml-lens 0.2.1 – Lenses for the hexml package – https://hackage.haskell.org/package/hexml-lens
02:05:19 <ventonegro> > fmap (+) (Left 5)
02:05:21 <lambdabot>  Left 5
02:05:59 <BernhardPosselt1> > (<*>) (Right (+ 1)) (Left 5)
02:06:02 <lambdabot>  Left 5
02:06:22 <BernhardPosselt1> > (<*>) (Right (+ 1)) (Right 5)
02:06:24 <lambdabot>  Right 6
02:06:27 <dminuoso> ertes-w: That was somehow the feeling I've had. In mathematics the concept of an optional argument simply does not make sense.
02:06:57 <dminuoso> Partial application seems to address the same idea of providing a specialized case while leaving a generalized
02:07:40 <dminuoso> Which incidentally is what I have been doing a lot in my JavaScript code recently as it feels far more powerful (and less prone to errors)
02:07:44 <tdammers> ertes-w: yes, because in Haskell, you are encouraged to model it as "this is the default configuration, and this is how you can modify its details" instead, i.e. the def { ... } approach
02:09:12 <ventonegro> BernhardPosselt1: Functor has kind * -> *, and Either has kind * -> * -> *, so necessarily the Functor must be (Either a)
02:37:18 <Saizan> are there known memory-use regressions with ghc-8.2.1?
02:40:46 <cocreature> Saizan: are you referring to runtime memory usage or memory used by ghc during compilation?
02:42:32 <Saizan> cocreature: runtime
02:45:24 <cocreature> Saizan: I haven’t seen any but that doesn’t mean much. if you have a somewhat minimal example, open an issue.
02:49:21 <Saizan> cocreature: it's huge :)
02:55:55 <piyush-kurur> oops
02:55:55 <piyush-kurur>  
02:56:14 <piyush-kurur> did some junk hit this channel
02:56:45 <piyush-kurur> ?
02:57:33 <piyush-kurur> I am sorry if it did.
02:57:56 <opqdonut> I saw only "oops" and an empty line from you
02:58:08 <piyush-kurur> okey good.
03:07:51 <MarcelineVQ> ​
03:09:53 <Profpatsch> How does one do IO-task-pooling with interleaved output once a task is finished?
03:10:10 <Profpatsch> I’m using https://hackage.haskell.org/package/async-pool-0.9.0.1/docs/Control-Concurrent-Async-Pool.html#v:mapTasks atm
03:10:52 <Profpatsch> The results are only returned when *all* tasks have finished.
03:10:57 <Profpatsch> cc johnw 
03:11:10 <cocreature> Saizan: then try to make it smaller. providing minimal examples helps immensely in getting ghc devs to take a look at your bugreport :)
03:11:28 <Profpatsch> Maybe it’s because I’m not consuming the output traversable eagerly?
03:12:01 <cocreature> Profpatsch: just have them write their output to a Chan
03:22:09 <butterthebuddha> I can't wrap my head around typeclasses and the syntax
03:22:16 <butterthebuddha> Is there a good tutorial out there?
03:22:33 <erisco> any of the Haskell books
03:22:56 <ventonegro> butterthebuddha: Do you have an example that confuses you?
03:23:25 <erisco> and the wiki defers to https://en.wikipedia.org/wiki/Type_class
03:39:24 <manek> Hi guys! What is the status of OpenGL in Haskell? There are few libraries `gl`, `OpenGL` and `GPipe`. `GPipe` looks like designed really well, but it bases on old Opengl (3.3) versus OpenGL lib (4.5). From the other hand, I would like it to work on Linux, Mac and Windows and I know Mac supoport for OpenGL is pretty weak
03:39:58 <manek> By the ay, I know that ekmett played with it, so if you Edward have any tips, I'd be thankful to hear them
03:40:45 <Tomsky> Hello, I'm trying to get some kind of stack trace out of a Haskell program so that I can work out where an error is happening. I noticed the wiki suggests using +RTC -xc however, I can't get it to work with stack, which says I need to compile with -prof (which I did, and stack build --profile).
03:42:42 <jle`> manek: you might have some luck on #haskell-game, where some of the people working on opengl+haskell live
03:43:23 <MarcelineVQ> how are you passing +RTS to your program? are you passing it to stack accidently instead?
03:45:02 <Tomsky> Aha! stack exec prog +RTC -xc tries to pass it to stack, but stack exec prog -- +RTC -xc works!
03:45:33 <MarcelineVQ> woo
03:45:41 <Tomsky> thanks for your help :-)
03:45:50 <MarcelineVQ> I'd go so far as to have the -- before prog even
03:45:51 <manek> jle`: thank you for the info!
03:46:02 <jle`> no problem, and good luck on this journey
03:46:19 <manek> jle`: thank you so much! :)
03:46:51 <Tomsky> Still not used to stack, it was ghc --make last time I did any serious work with Haskell :-)
03:47:02 <jle`> (you'll need it)
03:47:16 <jle`> (sorry, referring to manek, not Tomsky)
03:47:36 <jle`> Tomsky: we're all still getting used to stack :)
03:47:54 <Tomsky> jle`: :-)
03:48:06 <jle`> it is a communal learning experience
03:48:28 <jle`> s/communal/collective?
03:53:35 <BernhardPosselt1> how does <*> typecheck for either?
03:54:30 <erisco> BernhardPosselt1, do you have an example that is confusing you?
03:54:34 <BernhardPosselt1> > (<*>) (Right (replicate "a")) (Right 5)
03:54:36 <lambdabot>  error:
03:54:36 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
03:54:36 <lambdabot>      • In the first argument of ‘replicate’, namely ‘"a"’
03:54:40 <BernhardPosselt1> ah
03:54:54 <BernhardPosselt1> my issue is this
03:54:57 <cocreature> :t (<*>)
03:54:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:55:02 <erisco> :t replicate
03:55:03 <lambdabot> Int -> a -> [a]
03:55:04 <BernhardPosselt1> a -> b
03:55:12 <cocreature> replace f by "Either c"
03:55:26 <BernhardPosselt1> f a is Left a, f b is Left b
03:55:27 <erisco> > (<*>) (Right (replicate 5)) (Right 'a')
03:55:31 <lambdabot>  Right "aaaaa"
03:56:26 <BernhardPosselt1> so Either Int becomes Either String 
03:56:33 <BernhardPosselt1> using the function
03:56:42 <BernhardPosselt1> but what happens in this case:
03:56:43 <cocreature> BernhardPosselt1: "f a" is a type, "Left a" is a value, so that comparison doesn’t make sense
03:56:47 <erisco> no, that's not the case
03:56:49 <BernhardPosselt1> > (<*>) (Left (replicate 5)) (Right 'a')
03:56:51 <lambdabot>  error:
03:56:52 <lambdabot>      • No instance for (Typeable a0)
03:56:52 <lambdabot>          arising from a use of ‘show_M327643724881172194519478’
03:56:59 <brynedwards> :t (<*>) (Right (replicate 5))
03:57:01 <lambdabot> Either a1 a -> Either a1 [a]
03:57:28 <erisco> > (<*>) (Left "hello world") (Right 'a')
03:57:31 <lambdabot>  Left "hello world"
03:57:51 <BernhardPosselt1> does that only work if both are the same type?
03:57:52 <BL[m]> > (<*>) (Right (flip replicate "a")) (Right 5)
03:57:54 <lambdabot>  Right ["a","a","a","a","a"]
03:58:20 <erisco> :t (<*>) :: Either z (a -> b) -> Either z a -> Either z b
03:58:22 <lambdabot> Either z (a -> b) -> Either z a -> Either z b
03:58:48 <BernhardPosselt1> maybe to elaborate
03:58:50 <erisco> the first argument to Either stays the same throughout
03:59:03 <erisco> and that is the type of the value contained in the Left constructor
03:59:15 <erisco> the second argument to Either is the type of value contained in the Right constructor
03:59:15 <BernhardPosselt1> if i got a -> b
03:59:24 <BernhardPosselt1> then b must be the result
03:59:37 <BernhardPosselt1> but if a -> b is never executed, then a is the result
03:59:50 <BernhardPosselt1> because it keeps the current value
04:00:17 <erisco> if you have a function with type a -> b and you never apply the function to anything, you don't have any result from the function
04:00:23 <erisco> I am not sure how you reason that 'a' is the result
04:01:04 <BernhardPosselt1> because a is the type of the existing Either, right?
04:01:29 <erisco> I do not know what you mean
04:01:33 <BernhardPosselt1> :t (<*>)
04:01:34 <erisco> are you following a particular tutorial?
04:01:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:01:39 <BernhardPosselt1> lets fill in :D
04:01:59 <erisco> well I just showed you how to fill it in for Either
04:02:07 <BernhardPosselt1> Either (a -> b) -> Either a -> Either b
04:02:10 <erisco> (<*>) :: Either z (a -> b) -> Either z a -> Either z b
04:02:27 <erisco> no, see, you are missing an argument to Either
04:02:33 <BernhardPosselt1> ah
04:03:22 <BernhardPosselt1> what is z?
04:03:26 <BernhardPosselt1> the original type?
04:03:34 <brynedwards> The Left's type
04:03:38 <erisco> it is a type variable
04:03:43 <BernhardPosselt1> ah, ty
04:03:48 <BernhardPosselt1> everything clear now :D
04:03:49 <erisco> as I also explained, it is the type of the value contained in the Left constructor
04:05:42 <BernhardPosselt1> i got confused from implementation analogies in different languages
04:05:57 <BernhardPosselt1> that basically specialized Either like Result
04:06:04 <BernhardPosselt1> and only used one type parameter
04:06:19 <BernhardPosselt1> namely the one for Right in that case
04:10:15 <Zemyla> So why did I get K-lined earlier?
04:10:47 <ertes-w> Profpatsch: for the output part you may want to check out my library progress-meter
04:11:01 <hpc> i heard it happened to everyone who was ipv4
04:11:04 <opqdonut> Zemyla: there was some mistake by freenode staff, lots of people got klined
04:11:11 <opqdonut> hpc: ah, interesting
04:11:11 <erisco> Zemyla, there was a spambot episode on Freenode and they accidentally k-lined a bunch of innocent people
04:11:12 <ertes-w> Profpatsch: it should work with any concurrency abstraction
04:11:23 <Zemyla> Ahh, okay.
04:11:50 <ertes-w> Profpatsch: it can display a status line and also make sure that regular output lines are not disturbed by it
04:12:05 <Profpatsch> ertes-w: Not quite what I need.
04:12:20 <Profpatsch> I don’t want a progress bar, just normal logging output.
04:12:41 <ertes-w> Profpatsch: in that case just create a logger thread
04:14:04 <ertes-w> Profpatsch: there is some potential for race conditions that would result in lost log lines, but it's easy to fix with an STM-based logger
04:17:28 <BernhardPosselt1> kinda shitty that you cant do: data Either a b = Left a | Right b
04:17:32 <BernhardPosselt1> in java
04:17:54 <BernhardPosselt1> if you use an interface you need to pass both type parameters for both Left and Right
04:18:58 <BernhardPosselt1> e.g. Left<A> implements Either<A, …>
04:19:10 <ertes-w> kinda shitty that you can't do (instance Bifunctor Either) in java…  kinda shitty that you can't do (map (+ 1)) in java…  kinda shitty that you can't do…
04:19:24 <erisco> you mean that Java cannot infer the other type? yes, that is true, because Java's inference mechanisms are weak and very localised
04:20:12 <erisco> what you just showed does not really emulate how it actually works in Haskell either though, BernhardPosselt1
04:20:14 <erisco> :t Left
04:20:16 <lambdabot> a -> Either a b
04:20:34 <erisco> both type parameters are very much relevant
04:21:04 <BernhardPosselt1> :t Right
04:21:06 <lambdabot> b -> Either a b
04:21:17 <BernhardPosselt1> where does the other parameter come from?
04:21:33 <erisco> you can annotate it explicitly or have it be inferred
04:23:02 <BernhardPosselt1> i see
04:23:38 <Zemyla> Don't have Either be an interface. Have it be a tagged union and make it cast from Object internally.
04:58:15 <foldr> I have a CPP macro that uses multiple lines. Currently I end my lines with ;\ and {\ and }\ as appropriate so that it'll parse.
04:58:20 <foldr> Is this the usual way to do it?
04:58:46 <foldr> In particular, the lines are a bunch of standalone derivings and custom instances that I do not want to repeat for each type manually.
05:01:41 <foldr> Example: http://lpaste.net/5594708284775858176
05:12:14 * hackagebot http-reverse-proxy 0.4.5 – Reverse proxy HTTP requests, either over raw sockets or with WAI – https://hackage.haskell.org/package/http-reverse-proxy
05:28:28 <BernhardPosselt1> > (<*>) Just (+) ((Just 1) (Just 3))
05:28:31 <lambdabot>  error:
05:28:31 <lambdabot>      • Couldn't match type ‘Maybe Integer’
05:28:31 <lambdabot>                       with ‘(Integer -> Integer) -> t’
05:29:43 <BernhardPosselt1> hm, if you prefix <*> how would things look like?
05:30:23 <BernhardPosselt1> > (<*>) ((<*>) Just (+) (Just 1) (Just 3))
05:30:26 <lambdabot>  error:
05:30:26 <lambdabot>      • Couldn't match type ‘Maybe (Maybe a0)’
05:30:26 <lambdabot>                       with ‘(Maybe a0 -> Maybe a0) -> Maybe Integer -> f (a -...
05:30:45 <foldr> Not sure what you are trying to do.
05:31:05 <BernhardPosselt1> trying to understand the infix operator
05:31:15 <foldr> > (+) <$> Just 1 <*> Just 3
05:31:15 <BernhardPosselt1> by not putting it into infix position
05:31:18 <lambdabot>  Just 4
05:31:21 <phadej> > (<*>) ((<*>) (Just (+)) (Just 1)) (Just 2)
05:31:24 <lambdabot>  Just 3
05:31:32 <phadej> i.e. "don't" :)
05:31:34 <BernhardPosselt1> ty
05:31:41 <foldr> > (<*>) ((<$>) (+) (Just 1)) (Just 3)
05:31:44 <lambdabot>  Just 4
05:31:56 <phadej> > ap (ap (Just (+)) (Just 1)) (Just 2)
05:31:59 <lambdabot>  Just 3
05:32:16 <phadej> ap ~= (<*>)
05:32:16 <foldr> :t (+)
05:32:18 <lambdabot> Num a => a -> a -> a
05:32:29 <foldr> :t (<$>) (+)
05:32:31 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
05:32:44 <foldr> :t (<$>) (+) (Just 1)
05:32:46 <lambdabot> Num a => Maybe (a -> a)
05:32:50 <foldr> :t (<*>)
05:32:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:33:07 <foldr> so `Maybe (a -> a)' fits into `f (a -> b)'
05:33:23 <foldr> That's why `(+) <$> Just 1' can appear on the left of <*>
05:33:49 <phadej> note: <*>  and <$> are infixl 4
05:33:58 <phadej> not right, like (:)
05:34:51 <foldr> Is there a reason to not do `default-extensions: ApplicativeDo'?
05:37:25 <cocreature> broken applicative instances? :)
05:37:31 <foldr> :(
05:37:41 <foldr> cue blaze
05:37:43 <jle`> sometimes people like to see the extensions in a file at the top of a file
05:37:53 <cocreature> I’ve given up on that
05:38:21 <cocreature> I still add some of the more esoteric extensions to individual files but I can’t be bothered to add things like FlexibleContexts everywhere
05:38:31 <foldr> I have eight different extensions for parsing configuration lol
05:38:59 <phadej> hmm
05:38:59 <foldr> I am wondering about using applicative do with record wild cards
05:39:17 <cocreature> generally my rule of thumb is “if an extension does not change the behavior of code that was previously compiling, you can put it in default-exnesnions”
05:39:37 <phadej> https://gist.github.com/phadej/43f76b41f1ec0a09065b824a0a8b570c is this by design?
05:39:53 <foldr> If ApplicativeDo worked with MonadComprehensions: [ Lol {..} | lolFoo <- foo, lolBar <- bar ]
05:39:55 <foldr> :D :D :D :D :D
05:40:19 <foldr> phadej: You need pure $ as the last statement I think
05:40:27 <foldr> try adding pure ()
05:40:38 <cocreature> pure or return
05:41:04 <phadej> foldr: nope
05:41:10 <foldr> phadej: weird
05:41:27 <foldr> what if you write _ <- Const n instead of Const n?
05:41:52 <phadej> foldr: then it compiles
05:41:56 <foldr> lol
05:42:00 <foldr> lame
05:42:32 <phadej> IIRC simonmar told that you should use _ <- ... to get explicit bind, but it seems that then you get >>
05:42:39 <foldr> why not *>?
05:42:58 <phadej> foldr: because then there's no reason for ApplicativeDo ?:)
05:43:03 <cocreature> if I understand the docs correctly, this is expected
05:43:43 <foldr> phadej: I don't see why not
05:43:44 <cocreature> “If the do-expression has the following form: `do p1 <- E1; ...; pn <- En; return E` where none of the variables defined by p1...pn are mentioned in E1...En, then the expression will only require Applicative. Otherwise, the expression will require Monad.”
05:43:45 <phadej> cocreature: probably, but I have haxl-like code, where I need explicit bind (concurrent code, and I need a checkpoint so everything before is completed)
05:43:50 <foldr> (*>) works with applicatives that are not monads
05:43:56 <cocreature> your expression does not have that form
05:44:27 <foldr> and (*>) is always equivalent to (>>) unless broken
05:44:31 <cocreature> ApplicativeDo always feels a bit too fragile to be useful
05:44:46 <phadej> foldr: in haxl it's broken
05:44:55 <foldr> How does ApplicativeDo work with Strict?
05:45:08 <foldr> Oh right, Strict doesn't change laziness of (<*>) and (>>=)
05:45:15 <phadej> or more correctly, x >> y /= x >>= \_ -> y
05:45:24 <foldr> what :(
05:46:05 <foldr> I should use Haxl one day. It seems to be all the rage.
05:46:08 <ertes-w> cocreature: you don't like putting the extensions at the top, even if you have good editor support for doing that?
05:46:20 <cocreature> ertes-w: yes
05:46:43 <phadej> I put Derive* in the default-extensions, at least at work
05:46:56 <foldr> I wrote an applicative batching and caching library once but I have no idea how it compares to Haxl
05:46:56 <phadej> (i.e. not so public code)
05:46:59 <ertes-w> i'm kinda torn there…  i like the flexibility of writing the extensions at the top, because that makes the modules self-contained
05:47:21 <foldr> self-contained up to imports :')
05:47:36 <ertes-w> and i know: if i start listing default-extensions, i will most likely use a template with a bunch of extensions predefined
05:47:37 <cocreature> Derive* and Flexible* are pretty much always in my default-extensions
05:47:58 <foldr> I'd like MonoLocalBinds in my default-extensions because typed holes
05:48:15 <foldr> But it's one of the more obscure extensions
05:55:52 <ertes-w> … and i won't bother cutting them down to the required ones =)
05:56:20 <ertes-w> nobody uses haskell anyway
05:56:45 <foldr> My colleagues do vOv
05:56:48 <cocreature> if you’re fine with putting them at the top of every file then don’t let me stop you :) I was only expressing the way I handle it personally, not suggesting that everybody does it like this
05:57:20 <ertes-w> cocreature: no, i'm just looking for inspiration
05:57:50 <ertes-w> technically if i have a default set of extensions in default-extensions i can still move my modules around between projects, so i wouldn't really lose much
05:58:02 <c_wraith> default default-extensions?
05:58:08 <ertes-w> yeah =)
05:58:17 <ertes-w> personal default
05:59:10 <BernhardPosselt1> :t traverse
05:59:10 <ertes-w> i don't think i've written a single project that doesn't use FlexibleContexts and RankNTypes in the past two years
05:59:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:59:38 <ij> Suppose I parse my string with megaparsec into token newtypes. Can megaparsec then parse that list of newtypes too?
05:59:39 <BernhardPosselt1> traverse can turn a list of Maybe into a Maybe of list, right?
05:59:47 <ertes-w> BernhardPosselt1: right
05:59:50 <ertes-w> :t sequenceA
05:59:52 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:00:57 <BernhardPosselt1> so basically a generic Promise.all() (from javascript)
06:01:10 <BernhardPosselt1> promise which resolves after all other promises resolved
06:02:06 <BernhardPosselt1> isnt <*> kinda similar?
06:02:18 <c_wraith> BernhardPosselt1: traverse uses <*>
06:02:26 <BernhardPosselt1> ah :)
06:02:36 <c_wraith> BernhardPosselt1: that's why it has the Applicative constraint in its type
06:06:50 <texasmynsted> what is the best way that you have haskell ligatures working in vim?  I feel like I solved this already somehow but can't recall how.  https://github.com/enomsg/vim-haskellConcealPlus
06:06:59 <texasmynsted> I see that haskellConcealPlus
06:08:05 <grokkingStuff> Hi there. I have a bit of a challenge for y'all. Given two lists with elements of some type a which cannot be sorted, what's the quickest way to identify that the two lists are equal?
06:09:07 <mac10688_> the elements have Eq class?
06:09:18 <grokkingStuff> mac10688_: yeah! Sorry I forgot to mention that.
06:09:24 <foldr> grokkingStuff: equal in any order?
06:09:43 <marvin2> :t (==)
06:09:45 <lambdabot> Eq a => a -> a -> Bool
06:10:14 <grokkingStuff> foldr: two elements of type a have Eq class but there isn't a greater than or less than
06:10:19 <mac10688_> [1,2,3] == [3,2,1]
06:10:29 <grokkingStuff> assum that the lists are not in order
06:10:30 <foldr> You don't need ordering to determine list equality
06:10:31 <tabaqui> where can I find functions to get system cpu/ram usage?
06:10:38 <grokkingStuff> mac10688_: yeah.
06:10:41 <tabaqui> I don't see any in unix/base libraries
06:10:54 <grokkingStuff> foldr: it's more that I sort and then compare.
06:11:13 <foldr> Can you hash the elements?
06:11:16 <grokkingStuff> what's the quickest way to do it when you can't sort
06:11:22 * texasmynsted facepalm
06:11:34 <texasmynsted> vim-haskellConcealPlus, seems to just work
06:11:46 <grokkingStuff> foldr: the elements are hella small, i don't think there's a need to hash it?
06:11:58 <mac10688_> i would fold over one list and use the elem function into the other list grokkingStuff . I don't know if it's the quickest
06:12:00 <marvin2> grokkingStuff is == too slow?
06:12:04 <BernhardPosselt1> i dont think theres a quickest
06:12:19 <BernhardPosselt1> you need to traverse all elements of both rows
06:12:23 <BernhardPosselt1> lists*
06:12:34 <mac10688_> I'm with BernhardPosselt1 on this one
06:13:31 <BernhardPosselt1> mac10688_: elem has O(n) right
06:13:54 <grokkingStuff> marvin2: == on a list assumes that the elements have some order.
06:13:59 <BernhardPosselt1> and you can have the same element in there multiple times
06:13:59 <mac10688_> I would assume so. I'm not an algorithms expert but that seems plain to me
06:14:06 <grokkingStuff> i want a list and an (==) that doesn't care.
06:14:16 <barrucadu> Are you sure you want a list?
06:14:21 <marvin2> grokkingStuff, I see, I misunderstood your question
06:14:22 <grokkingStuff> BernhardPosselt1: but that would take so long!
06:14:28 <barrucadu> Because that sounds more like a (multi)set
06:14:40 <BernhardPosselt1> so basically you need to record which elements exist how many times in the lists
06:14:43 <BernhardPosselt1> then compare that
06:14:44 <marvin2> grokkingStuff is the missing Ord instance the only reason they can't be sorted?
06:15:20 <grokkingStuff> marvin2: they can't be compared because they're inherently equal-ish
06:15:44 <grokkingStuff> marvin2: like kg^1.m^1 in a dimension system
06:15:46 <ertes-w> grokkingStuff: Ord is not allowed?
06:15:52 <grokkingStuff> ertes-w: nope
06:16:03 <grokkingStuff> can't implement Ord because the logic doesn't exist
06:16:04 <ertes-w> grokkingStuff: in that case i would bend the problem such that Ord is allowed =)
06:16:17 <ertes-w> without Ord this is going to be very ugly
06:16:25 <grokkingStuff> barrucadu: what's a (multi)set
06:16:46 <tdammers> re the hashing: you can produce small hashes for small things
06:16:50 <barrucadu> grokkingStuff: A set is an unordered collection of elements.  A multiset allows duplicates.
06:17:02 <barrucadu> So if you want duplicate elements, just a set wouldn't work
06:17:14 <ertes-w> :t \xs ys -> M.fromListWith (+) (map (, (1 :: Int)) xs) == M.fromListWith (+) (map (, 1) ys)
06:17:15 <grokkingStuff> ertes-w: this issue is that i'm gonna be using quantities that are defined on compile time. template haskell. 
06:17:16 <lambdabot> Ord k => [k] -> [k] -> Bool
06:17:51 <grokkingStuff> barrucadu: nah, i don't think that's what i'm looking for
06:18:07 <grokkingStuff> i guess you could say i'm looking for set equality
06:18:14 <grokkingStuff> the order of elements don't matter
06:18:31 <grokkingStuff> set {A,B} should be equal to set {B,A}
06:18:35 <barrucadu> What are you actually trying to do?
06:18:43 <barrucadu> Where does the constraint that you need lists come from?
06:19:12 <grokkingStuff> using a list isn't a constraint, i kinda assumed that it would be the best way
06:19:53 <grokkingStuff> i have a set of elements of type a. kinda like a list, i guess
06:20:26 <grokkingStuff> ertes-w: you're probably right, without ORd, this is going to be ugly
06:20:33 <byorgey> grokkingStuff: if you can only compare elements for equality, and you can't even put some arbitrary ordering on them, or hash them, then the fastest you can possibly compare two lists/sets of size n for equality, where you don't care about the order, is O(n^2).
06:20:56 <byorgey> because there's literally nothing you can do other than compare each pair of elements.
06:21:27 <grokkingStuff> hmmm, i'm gonna try to figure this out before i get to that.
06:21:37 <byorgey> however, this is nonsensical.  If your elements have decidable equality, then you can hash them or put some arbitrary total order on them.
06:21:52 <byorgey> Because fundamentally they are represented by bitstrings, and you can always hash or compare those.
06:22:13 <grokkingStuff> byorgey: how would i do that? how would i hash them and compare that in haskell?
06:22:36 <nshepperd_> What are your elements
06:22:38 <grokkingStuff> i only care about the assertion that they're equal, so you're probably right about the hash.
06:23:35 <mac10688_> length xs == length ys && foldr (\item acc -> acc && (item `elem` ys)) True xs
06:23:40 <mac10688_> I think that's the best you can do
06:24:04 <grokkingStuff> nshepperd_: it's a datatype Expr = Expr | Product Expr Expr | Quotient Expr Expr
06:24:04 <mac10688_> foldr or foldl, I don't know if one's better than the other
06:24:39 <ertes-w> :t insertWith
06:24:40 <foldr> that's O(n * m)
06:24:41 <lambdabot> error:
06:24:41 <lambdabot>     • Variable not in scope: insertWith
06:24:41 <lambdabot>     • Perhaps you meant one of these:
06:24:51 <foldr> if you can hash the elements you can do it in O(n + m)
06:25:18 <byorgey> grokkingStuff: in that case I would just do  deriving Ord, throw the elements in two Sets, and compare the sets for equality.
06:25:56 <byorgey> grokkingStuff: I understand why you are concerned that the Ord instance does not make sense, semantically.  If you wanted you could make a newtype wrapper for Expr and make an Ord instance for that.
06:26:07 <grokkingStuff> byorgey: but how would deriving Ord work for something like that? genuinely curious.
06:26:21 <grokkingStuff> Equality is a no-brainer. but Ord?
06:26:35 <marvin2> > let xs = [1,2,3]; ys = [3,2,1] in and $ map (`elem` ys) xs
06:26:37 <lambdabot>  True
06:26:38 <byorgey> grokkingStuff: Expr < Product < Quotient, and if you have two Products it compares the first Expr recursively, if those are equal it compares the second Exprs recursively, and so on.
06:26:39 <grokkingStuff> byorgey: oops, saw your message too late
06:27:35 <byorgey> grokkingStuff: basically think of the two Exprs as trees, and it walks down the trees recursively until it finds the first place where they have different constructors.  Then it uses the arbitrary ordering  Expr < Product < Quotient.
06:28:04 <ertes-w> @let insertWith f k x [] = [(k, x)]; insertWith f k x (kx'@(k', x') : xs) = if k == k' then (k, f x' x) : xs else kx' : insertWith f k x xs
06:28:05 <byorgey> this is a generalization of lexicographic order for lists.
06:28:06 <lambdabot>  Defined.
06:28:06 <grokkingStuff> alright! i'm gonna try that and get back to you! So in essence the ordering doesn't really matter, it could be any arbitrary ordering!
06:28:15 <byorgey> grokkingStuff: right, exactly.
06:28:24 <grokkingStuff> sweet. gonna do that.
06:28:28 <grokkingStuff> Thanks byorgey!
06:28:31 <byorgey> sure!
06:32:46 <ertes-w> :t \xs ys -> foldr (\x go -> go . insertWith x 1) (foldr (\y go -> go . insertWith y (-1)) (all (== 0)) xs) ys []
06:32:48 <lambdabot> error:
06:32:48 <lambdabot>     • Couldn't match expected type ‘[(t1, t2)] -> [(t1, t2)]’
06:32:48 <lambdabot>                   with actual type ‘[t0]’
06:33:00 <ertes-w> :t \xs ys -> foldr (\x go -> go . insertWith x 1) (foldr (\y go -> go . insertWith y (-1)) (all ((== 0) . snd)) xs) ys []
06:33:02 <lambdabot> error:
06:33:02 <lambdabot>     • Couldn't match type ‘(a0, Integer)’ with ‘[(t1, t2)]’
06:33:02 <lambdabot>       Expected type: ([(t1, t2)] -> [(t1, t2)]) -> Bool
06:34:02 <Xnuk> :t insertWith
06:34:04 <lambdabot> Eq t => (t1 -> t1 -> t1) -> t -> t1 -> [(t, t1)] -> [(t, t1)]
06:34:35 <ertes-w> :t \xs ys -> foldr (\x go -> go . insertWith (+) x 1) (foldr (\y go -> go . insertWith (+) y (-1)) (all ((== 0) . snd)) xs) ys []
06:34:37 <lambdabot> (Eq t1, Foldable t2, Foldable t) => t2 t1 -> t t1 -> Bool
06:34:49 <ertes-w> @let equalElems xs ys = foldr (\x go -> go . insertWith (+) x 1) (foldr (\y go -> go . insertWith (+) y (-1)) (all ((== 0) . snd)) xs) ys []
06:34:51 <lambdabot>  Defined.
06:35:16 <ertes-w> > (equalElems [1,2,2,3,4] [3,1,2,4,2], equalElems [1,2,3,4] [1,2,2,3,4])
06:35:19 <lambdabot>  (True,False)
06:35:30 <ertes-w> grokkingStuff: that's about how i would implement it
06:35:57 <ertes-w> with some additional strictness perhaps
06:36:01 <grokkingStuff> ertes-w: huh, sweet
06:36:42 <ertes-w> @let equalElems' xs ys = foldr (\x go -> (go $!) . insertWith (+) x 1) (foldr (\y go -> (go $!) . insertWith (+) y (-1)) (all ((== 0) . snd)) xs) ys []
06:36:43 <lambdabot>  Defined.
06:36:46 <ertes-w> this should perform much better
06:36:59 <byorgey> but it's still O(n^2) since it doesn't use Ord.
06:37:11 <ertes-w> yes, it's as best as you can get
06:37:16 <ertes-w> s/best/good/
06:38:54 <manek> When I try to use stack with empty project but with resolver nightly with ghc-8.2, i get error: Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing
06:39:01 <manek> there is no cabal file (yet) generated
06:39:08 <manek> does anybody know how to resolve it?
06:39:39 <byorgey> manek: https://mail.haskell.org/pipermail/haskell-cafe/2017-August/127686.html
06:39:49 <byorgey> manek: try upgrading to stack-1.5.1
06:40:04 <markus1199> 3ls
06:40:10 <manek> byorgey: <3
06:40:10 <markus1199> ups sorry ;)
06:40:28 <manek> byorgey: how did you do this. You're just a better google 
06:40:33 <manek> :D
06:40:55 <byorgey> manek: no, I remembered seeing a link to it on the Haskell reddit yesterday
06:41:01 <manek> byorgey: thank you! :)
06:41:04 <byorgey> so I knew to google for 'stack 1.5.1 cabal 2.0'
06:41:10 <byorgey> sure =)
06:41:45 <Xnuk> @help
06:41:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:41:57 <manek> byorgey: it works, awesome!
06:42:05 <grokkingStuff> \\\
06:42:05 <grokkingStuff> \
06:42:06 <grokkingStuff> \
06:42:08 <byorgey> great!
06:42:10 <nshepperd_> You can also implement a hash recursively. hash Expr = whatever; hash (Product x y) = hash ("product", x, y); etc
06:42:10 <grokkingStuff> |
06:42:12 <grokkingStuff> |
06:42:34 <Xnuk> oh
06:42:47 <byorgey> was that grokkingStuff's cat, or what?
06:43:06 <ertes-w> freenode killed grokkingStuff's cat
06:43:11 <ertes-w> meow
06:43:26 <Xnuk> woof woof
06:43:39 <nshepperd_> Good grief
06:43:40 <ertes-w> they should have given it some better to eat
06:43:52 <erisco> lets moove on from this silliness
06:44:04 <nshepperd_> Services have a real hair trigger now
06:44:09 <byorgey> nshepperd_: true.  You still need a hash table structure to make use of it though.
06:45:28 <Xnuk> @help list
06:45:28 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:45:30 <Xnuk> @list
06:45:31 <lambdabot> What module?  Try @listmodules for some ideas.
06:45:38 <Xnuk> @help
06:45:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:45:40 <Xnuk> um
06:45:52 <tabaqui> is there some fine library like psutil in python - with wide system information, memory/cpu stats, process tree and so other
06:45:54 <tabaqui> ?
06:46:25 <Xnuk> <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands 
06:46:39 <Xnuk> how can i get all commands
06:46:48 <ertes-w> tabaqui: i was looking for something like that recently for monitoring purposes, but ultimately i ended up parsing some commands' output and some /proc files
06:47:26 <byorgey> Xnuk: it suggested @listmodules .  I think you can then say @list <module>  to get commands in that module.
06:47:29 <tabaqui> when it goes wrong...
06:47:36 <tabaqui> ertes-w: I cannot find something, too
06:47:40 <tabaqui> ok, thanks
06:47:43 <byorgey> Xnuk: note also you can open a private /query with lambdabot
06:49:07 <ertes-w> tabaqui: i might be able to write such a library with commercial support, but no promises
06:49:33 <ertes-w> tabaqui: we're in the process of moving from zabbix to sensu, which will require refactoring our monitoring code
06:51:41 <tabaqui> ertes-w: I don't want so much, just system cpu/ram usage, so I guess I will write it self
06:51:48 <tabaqui> not a big deal
06:51:55 <tabaqui> just wondering
06:59:27 * hackagebot decimal-arithmetic 0.5.0.0 – An implementation of the General Decimal Arithmetic Specification – https://hackage.haskell.org/package/decimal-arithmetic
07:06:04 <verement> Chobbes_: In case you're still interested, I've implemented the missing trig functions.
07:15:15 <Guest36749> Guys, I have (MonadIO m) => m a , I want a function m a -> IO a, possible?
07:16:41 <cocreature> Guest36749: no
07:16:56 <manek> Hi! Is it possible to define explicite bidirectional record pattern synonyms in Haskell adn use expressions for their construction / deconstruction ?
07:18:07 <Darwin226> Hey guys, guess the complexity of the Without family https://gist.github.com/8e9a1af8ce2ca0b09c6902208650a6b6
07:19:44 <osa1> isn't that Data.List.nub at the type level?
07:20:06 <Darwin226> Well, not nub, but sure
07:21:04 <osa1> is it or is it not? because if it is it's O(n^2) as documented in Data.List.
07:21:46 <Darwin226> Well, it's not nub since it doesn't do the same thing. nub is for removing duplicated, this is a list difference
07:22:04 <Darwin226> but I said sure because I assumed you were talking about the quadratic complexity
07:22:19 <Darwin226> and it's what I expected
07:22:28 <Darwin226> Turns out: it's exponential
07:22:37 <Darwin226> the If is not lazy so both branches get evaluated anyways
07:24:14 <osa1> ah, nice catch :)
07:24:32 <Darwin226> Have to say I'm pretty bummed about this hah...
07:29:43 <manek> By the way, is there ANY hack in haskell that would allow me to use `:=` as alias for expression? 
07:30:08 <erisco> can't you?
07:30:08 <Darwin226> manek: What do you mean?
07:30:23 <nshepperd_> Alias for what?
07:30:26 <manek> no I cant, I cannot define `a := b = b` 
07:30:37 <manek> for expression, normal expression, not constructor
07:30:51 <manek> like (:=) = const 
07:30:57 <erisco> oh, complains it is a data constructor... yeah that may be reserved for infix data constructors
07:31:01 <Darwin226> Yeah, :something operators are reserved for constructors
07:31:10 <nshepperd_> : starts an operator that is a constructor
07:31:13 <manek> I know it, because of that I was asking for a hack
07:31:24 <erisco> well, just make it a constructor :)
07:31:26 <manek> I can create a data pattern synonym, but I want just expression here (for a EDSL)
07:31:43 <manek> erisco: I cannot make it a constructor, cause it should return a polymorphic value :(
07:31:47 <Darwin226> Anyone know why this restriction exists? What does the parser care about what it is?
07:32:02 <erisco> data types can be polymorphic
07:32:28 <erisco> what about using =:
07:32:50 <nshepperd_> Darwin226: constructors start with an uppercase letter
07:33:32 <Darwin226> So?
07:33:40 <nshepperd_> For parsing reasons or something. Anyway : was arbitrarily chosen as the only uppercase operator symbol
07:34:15 <manek> erisco: hmm, it is impossbile here to make thsi datatype polymorhpic. expresion of form `a := b` should create a datatype and then lift it to free monad
07:34:20 <nshepperd_> That's why you can use (:) as the list constructor
07:34:24 <manek> erisco: I just dont see how it oculd be done
07:34:38 <manek> nshepperd_: actually (:) is even more strange, you cannot override it
07:34:48 <manek> nshepperd_: so it is just magic :P
07:34:55 <nshepperd_> Eh?
07:35:10 <manek> nshepperd_: you cannto hide (:) from Prelude and create your custom constructor named (:)
07:35:11 <ventonegro> Ok, I vote for %=
07:35:50 <manek> ventonegro: ugly :( Im creating css preprocessor as edsl and it would be awesome to use `background := red` 
07:36:01 <manek> using %= is just ugly
07:36:16 <manek> however `=:` is interesting indeed
07:37:53 <erisco> you can use the C preprocessor...
07:38:04 <ventonegro> Then I raise you |=
07:38:17 <ventonegro> Ah, the | is probably reserved
07:38:37 <erisco> no, <|>
07:38:47 <ventonegro> true
07:38:52 <Zemyla> ventonegro: Nope, ||
07:39:01 <Cale> I can't see |= without reading "models"
07:39:28 <manek> erisco: no way, I want this library to be usable by humans :P I dont want tell people to include some header files on top of their files
07:39:51 <manek> erisco: (you cannot embed and auto-include CPP pragmas / rules automatically)
07:39:51 <erisco> be careful what you wish for, then
07:40:22 <manek> erisco: Im careful, however I also want syntax to be easy and understandable
07:40:34 <manek> erisco: anyway, thanks for the idea with `=:` I think Ill go with it
07:40:42 <manek> erisco: it suits very nice this situation
08:18:42 <remexre> Does the unix package work on Windows?
08:19:18 <geekosaur> no. there's a unix-compat with a subset on hackage iirc
08:19:26 <remexre> ok, thanks
08:20:26 * hackagebot speculate 0.2.8 – discovery of properties about Haskell functions – https://hackage.haskell.org/package/speculate
08:22:21 <Yuuri> Is there a way to quickCheckAll polymorphic properties with default type parameter other that Integer?
08:23:45 <Yuuri> This polymorphic property is constrained with my typeclass which has a finite number of instantiations. Ideally I'd want to check them all.
08:24:45 <dmwit> Yuuri: propBool = polyProp @Bool
08:25:09 <dmwit> (One such for each instance. Sorry about the repetition.)
08:25:44 <Yuuri> dmwit: what's that @ notation?
08:26:20 <geekosaur> -XTypeApplications
08:27:20 * hackagebot git-annex 6.20170818 – manage files with git, without checking their contents into git – https://hackage.haskell.org/package/git-annex
08:54:10 <rycole>  /join #go-nuts
08:54:15 <rycole> Whoops, sorry
08:55:07 <aisqwe> it seems its not mandatory to write "forall t" in this code when there is a constraint? why is writing "forall t" important?
08:55:09 <aisqwe> data TypedExpr where   (:::) :: forall t. Eq t => Expr t -> Type t -> TypedExpr
08:56:56 <mniip> aisqwe, toplevel foralls are optional
08:57:03 <geekosaur> that seems like a bug, since t is not mentioned in the head
08:57:13 <mniip> geekosaur, not at all
08:57:38 <mniip> aisqwe, but once you have different quantifications (not toplevel) you might want to explicitly state that for clarit
08:57:39 <mniip> y
08:58:24 <c_wraith> aisqwe: Is ScopedTypeVariables enabled?
08:59:49 <Yuuri> dmwit: geekosaur: thank you!
09:00:22 <c_wraith> Oh, right, it's a data constructor.  ScopedTypeVariables would be irrelevant
09:00:41 <smakarov> Can someone help me with this dbus library?
09:01:37 <c_wraith> aisqwe: Well, that's an encoding of an existential.  The person who wrote it was probably familiar with doing that via the ExistentialQuantification extension, which requires the forall.  GADTs don't require the forall to encode an existential, but sometimes the habit sticks
09:02:02 <geekosaur> smakarov, generally you should ask a more complete question including error output or what you got vs. what you expected
09:02:03 <geekosaur> @paste
09:02:03 <lambdabot> Haskell pastebin: http://lpaste.net/
09:02:10 <geekosaur> ^ code to pastebin not to IRC
09:02:45 <dolio> It could be that the person thinks it's a good idea to write your quantifiers, too.
09:09:44 * monochrom loves explicit quantifiers
09:09:59 <monochrom> Oh damn, self inconsistency.
09:10:09 <smakarov> http://lpaste.net/357794
09:10:23 <monochrom> for all quantifier Q, monochrom loves Q made explict.  There!
09:10:35 <smakarov> getReply "org.mpris.MediaPlayer2.spotify" returns Nothing, but Spotify is running
09:10:59 <dsal> Porting some code from go to haskell, I've found the second bug in my go code because haskell didn't agree with the results.
09:15:22 <dsal> I guess it's not reasonable to test a function in a module without exporting the function.
09:16:53 <monochrom> Use Template Haskell to do compile-time self-tests so the tests are run when compiling the module so you don't have to export the testee for external tests. :)
09:17:34 <dsal> Is that a thing people do?  Seems reasonable.
09:17:45 <monochrom> No, I haven't heard of anyone doing it.
09:18:04 <dsal> I've got this base 91 decode function and a couple samples that should be correct.  A static assert of sorts would be fine.
09:18:07 <monochrom> I thought up this "cunning plan" just this minute. :)
09:18:11 <dsal> heh
09:18:20 <dsal> I've had numerous jokes that turned into products.
09:19:52 <smakarov> dsal, but function getReply is exported.
09:20:46 <dsal> You mean just test the higher level things?
09:21:23 <mniip> monochrom, Q Q. Q
09:21:46 <geekosaur> "Q-te"
09:22:04 <dsal> Is there an easy way to print a string as a list of characters?  Many of these strings have nulls and stuff in them.
09:22:30 <monochrom> The C kind of "string"?
09:22:40 <dsal> No, it's really just [Char] * 4
09:22:50 <monochrom> Actually try this:
09:23:10 <monochrom> print "abc\NULdef\n"
09:23:16 <dsal> This is just in my test code.  It's telling me what each exemplar got, but I can't see them outside of emacs.
09:23:43 <dsal> I'm getting this in the tests:      
09:23:46 <dsal> well that didn't paste.
09:23:52 <dsal> in emacs, it shows ^@^@^@^@
09:23:54 <geekosaur> strated with / ?
09:24:08 <monochrom> ^@ is null, yeah
09:24:08 <eschnett> ^@ is NUL
09:24:17 <dsal> Yeah, but it's not actually showing up anywhere other than emacs.
09:24:30 <monochrom> Try my idea.
09:24:45 <dsal> Oh, turns out show does it.
09:24:51 <dsal>   "\NUL\NUL\NUL\NUL" -> -25144152: [OK]
09:24:55 <monochrom> Yeah. It escapes.
09:25:03 <dsal> I was just doing   a ++ ...
09:25:44 <phii> Since I upgraded to GHC 8.2.1 I have getting "ghc:out of memory" errors when compiling with -O or -O2 but it works fine without any optimization flag. Any ideas about why that might be the case?
09:26:13 <monochrom> There is also map show "\NUL\NUL" if you like to see this instead:
09:26:19 <monochrom> > map show "\NUL\NUL"
09:26:21 <lambdabot>  ["'\\NUL'","'\\NUL'"]
09:26:35 <geekosaur> > text $ concatMap (init . tail . show) "\SOHa\US\n5\0x"
09:26:37 <lambdabot>  \SOHa\US\n5\NULx
09:26:41 <mniip> I was thinking,
09:26:51 <mniip> @let newtype SChar = SChar Char
09:26:52 <mniip> @let instance Show SChar where show (SChar c) = show c
09:26:53 <lambdabot>  Defined.
09:26:54 <lambdabot>  Defined.
09:27:02 <mniip> > map SChar "hello"
09:27:05 <lambdabot>  ['h','e','l','l','o']
09:27:17 <geekosaur> not perfect because it doesn't know to add \& when needed
09:27:44 <mniip> ?
09:27:50 <mniip> not sure this needs \& anywhere
09:27:59 <mniip> chars are separated with ','
09:28:13 <Zemyla> What does \& do?
09:28:14 <geekosaur> > text $ concatMap (init . tail . show) "\SO\72a\US\n5\0x" -- bug
09:28:17 <lambdabot>  \SOHa\US\n5\NULx
09:29:12 <geekosaur> Zemyla, stops a sequence that would otherwise be ambiguous. in the bug example, \SO followed by H showed as \SOH which is a *different* escape
09:29:36 <geekosaur> so it would need to be \SO\&H or some other representation like the one I used to enter it
09:29:55 <geekosaur> > show "\SO\72a"
09:29:57 <lambdabot>  "\"\\SO\\&Ha\""
09:30:04 <geekosaur> whjoops
09:30:09 <geekosaur> > "\SO\72a"
09:30:11 <lambdabot>  "\SO\&Ha"
09:38:13 <Xnuk> > text "\SO\72a"
09:38:15 <lambdabot>  Ha
09:39:34 <smakarov> http://lpaste.net/5018822053067751424
09:39:43 <geekosaur> the \SO is invisible (ASCII control code "shift out", a holdover from BAUDOT, 0x0E)
09:39:48 <smakarov> Why fromVariant (head body) returns Nothing?
09:40:48 <geekosaur> because you're using it in the wrong type context, likely
09:42:27 <geekosaur> fromVariant is a typesafe cast, if the value can be converted to the type the caller is expecting then you get Just the_value, otherwise you get Nothing
09:43:04 <smakarov> How can I get values from there so?
09:44:46 <monochrom> What is fromVariant?
09:46:30 <geekosaur> http://hackage.haskell.org/package/dbus-0.10.13/docs/DBus-Internal-Types.html#v:fromVariant
09:46:43 <monochrom> thanks
09:48:31 <geekosaur> return $ fromVariant (head body) >>= fromVariant
09:52:26 * hackagebot master-plan 0.3.1 – The project management tool for hackers – https://hackage.haskell.org/package/master-plan
09:52:59 <smakarov> gekosaur, it also returns Nothing
09:53:55 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2017-August/127748.html  :S
09:54:09 <monochrom> Oh darn that's two days ago already :)
09:54:32 <geekosaur> that wasn't  suggestion, it was showing the context
09:54:58 <geekosaur> I think I want to see the inferred type of getReply but I am going to be busy/away from keyboard for the next little while
09:56:58 <hsiktas> noob question: what is the difference between this: https://chocolatey.org/packages/ghc
09:57:09 <hsiktas> and this: https://chocolatey.org/packages/haskell-stack
09:57:38 <hsiktas> if I just want to install some tools from cabal
09:58:14 <hsiktas> which can be installed with a separate package https://chocolatey.org/packages/cabal
09:58:20 <dsal> stack is a different thing altogether.  If you just want to install tools, then any cabal install should probably work.
09:59:49 <hsiktas> thx. I just saw that the downloads package answers all my questions https://www.haskell.org/downloads
10:01:17 <smakarov> geekosaur, getReply type is (IsVariant a) => BusName -> IO (Maybe a)
10:01:53 <shapr> dsal: you enjoying Haskell so far?
10:02:10 <dsal> Yeah, quite a bit.
10:02:31 <dsal> I'm not being super productive, but I'm making everything harder than necessary.
10:02:41 <shapr> do you think it'll all pay off later?
10:02:49 <shapr> I mean, you wrote unit tests your first week, right?
10:02:52 <dsal> Well, if I keep doing haskell for things, sure.  :)
10:02:56 <shapr> ha!
10:03:19 <shapr> dsal: any particular reason for learning Haskell?
10:03:21 <dsal> Yeah, I didn't have unit tests for my first program, but the second thing I'm working on is pretty much just unit tests at this point.
10:03:53 <dsal> I used to do different things with different languages.  I've toyed with haskell a long time ago, but not much you couldn't do interactively in ghci/hugs.  No idea why I decided to just write code in haskell this week.
10:04:08 <dsal> The first thing I was doing would've been just a few minutes in R, I think.  heh.
10:04:30 <dsal> This is the second bug I found in my go code, though:  https://github.com/dustin/go-aprs/commit/4900abfc32d73700f6271902623eae803b64a90b
10:05:02 <dsal> I couldn't figure out why my haskell version was giving me "wrong" results:   decodeBase91 all@(a:b:c:d) = foldl (\a (c, i) -> i * ((toEnum . fromEnum $ c) -33) + a) 0 $ zip all [91^x | x <- [3,2..0]]
10:05:46 <dsal> (Also, [3,2..0] looks funny.  Too bad [3..0] doesn't work)
10:06:47 <dsal> My big challenge from last night was implementing arbitrary for a packet type that contains other arbitrary types that needed to be generated.  The confusion was kind of specific to the quicktest package, but figuring it out was generally helpful.
10:08:26 <sm> PSA: avoid https://www.codingame.com/ide/puzzle/coders-strike-back 
10:10:02 <dsal> (just realized I don't need to name those list elements *and* that matches a three element list)
10:11:51 <dsal> I made a type class last night, too.  I probably won't need it, but I do at least have a use case in mind:    class Similar a where (≈) :: a -> a -> Bool
10:25:48 <mniip> sm, what's wrong with that
10:26:16 <mniip> it is slightly unidiomatic but what's the problem
10:31:53 * hackagebot clingo 0.2.0.0 – Haskell bindings to the Clingo ASP solver – https://hackage.haskell.org/package/clingo
10:49:19 <sm> mniip: it is addicting.. don't go there I tell you
10:55:54 <shapr> sm: what's addictive? top level foralls?
10:56:09 <monochrom> A coding puzzle website.
10:56:13 * shapr skolemizes sm
10:56:28 <shapr> hackerrank?
10:56:32 <shapr> do they support ghc 8 yet?
10:57:00 <monochrom> www.codinggame.com
10:57:30 <sm> https://www.codingame.com/ide/puzzle/coders-strike-back , found via the "what are you working on" reddit thread
10:57:35 <Wizek> I've read "One consequence is that diagrams is optimized for simplicity and flexibility rather than for speed; if you are looking to do real-time graphics generation you will probably be best served by looking elsewhere!" here: http://projects.haskell.org/diagrams/doc/quickstart.html What other options could I look into if real-time generation is of interest for me?
10:58:20 <shapr> speaking of diagrams, I want to generate state diagrams; is there a diagrams project for that?
11:15:17 <geekosaur> smakarov, then the question becomes what type are you using it at?
11:15:28 <geekosaur> in paritcular, if you are using it in ghci, it is probably IO (Maybe ())
11:16:02 <smakarov> geekosaur, ghci deduces type (IsVariant a) => IO (Maybe a)
11:16:02 <geekosaur> you will need to explicitly specify
11:16:21 <geekosaur> (or turn off ExtendedDefaultRules so ghci won't assume () instead of telling you it doesn't know what tyoe you want)
11:16:29 <geekosaur> smakarov, yes, that ois not what I was talking about
11:16:40 <geekosaur> this is Haskell. it will not change its type based on the data
11:16:53 <geekosaur> you mus tell it the type to try to decode the data as
11:17:42 * geekosaur may actually be stably here for a little while...
11:18:49 <smakarov> Variant data constructor is not exported, which type I should tell it?
11:19:04 <geekosaur> you don;t need the Variant
11:19:23 <geekosaur> it's an IO (Maybe a). you must specify the a you wanted it to decode
11:19:47 <geekosaur> if you just type ``` getReply <whatever> ``` in ghci, ghci will pick () as the a
11:20:18 <smakarov> http://lpaste.net/5018822053067751424
11:20:30 <smakarov> There are two nested Variants
11:20:55 <geekosaur> yes. Variant is an internal thing, you are using fromVariant to *get rid of the Variant*.
11:22:18 <geekosaur> and Variant itself has an IsVariant instance. so that is not the problem
11:23:48 <smakarov> I'm beginning to understand
11:23:52 <smakarov> getReply :: (IsValue a) => BusName -> IO (Maybe [a])
11:24:09 <smakarov> is this signature correct?
11:24:49 <geekosaur> your paste shows you to have something which is probably a dbus Dictionary, or Haskell type Map String <something>. not sure how you specifgy the <somethingh> here
11:25:22 <smakarov> Second type is Variant
11:26:35 <geekosaur> yeh, probably. so you use, in the Maybe monad: (m :: Map String Variant) <- fromVariant >>= fromVariant -- this syntax requires ScopedTypeVariables
11:27:01 <geekosaur> you then have to use fromVariant again to extract Haskell values from the Variant-s in the Map
11:27:49 <smakarov> getReply :: (IsValue a, IsVariant a) => BusName -> IO (Maybe (Map String a))
11:28:05 <geekosaur> if it's always that, yes
11:28:08 <geekosaur> I think you are missing a point
11:28:13 <smakarov> This signature doesn't work too
11:28:22 <geekosaur> getReply is polymorphic currently. That is not a problem
11:28:33 <geekosaur> but it does reqire you to say *at use sites* what type you expect
11:29:34 <geekosaur> sometimes it can be inferred. sometimes a thinko means the type it infers is not the one you expected (you should get into the habit of specifying type signatures explicitly, so the compiler will catch this sooner instead of only realizing it has the wrong type later)
11:29:56 <geekosaur> > read "1"
11:29:59 <lambdabot>  *Exception: Prelude.read: no parse
11:30:24 <geekosaur> this is, I think, your problem. the type () is inferred, and "1" is not a valid representation for ()
11:30:32 <geekosaur> > read "1" :: Int
11:30:35 <lambdabot>  1
11:32:49 <smakarov> In dictionary from (head body) values are of different types
11:33:33 <geekosaur> but they are wrapped in Variant, specificallyy to hide that
11:33:43 <geekosaur> which is why you need to use fromVariant on the result of a lookup
11:33:53 <geekosaur> [18 18:26:40] <geekosaur> you then have to use fromVariant again to extract Haskell values from the Variant-s in the Map
11:35:06 <smakarov> But (fromVariant (head body) >>= fromVariant) returns Nothing, will I be able to lookup the result map?
11:35:08 <geekosaur> maybe the right thing to do here is to point you to the documentation for aeson. It has the same problem and uses a type Value= to solve it
11:35:28 <geekosaur> again it produces Nothing most likely because you have specified it at the wrong type
11:35:43 <geekosaur> I would need to see more complete code, not just the snippets you've pasted so far, to know exactly
11:36:01 <geekosaur> but at one point you said you were testing this in ghci, and that is why I pointed to the () business
11:36:25 <geekosaur> because the Dictionary will not decode as a Maybe ()
11:37:22 <smakarov> I should to specify right type to fist fromVariant or both?
11:37:35 <geekosaur> the whole expression
11:37:52 <geekosaur> (fromVariant (head body) >>= fromVariant) :: Maybe (Map String Variant)
11:38:17 <geekosaur> that *should* get you a proper decoding
11:38:26 <smakarov> Didn't know that this expression is correct
11:38:51 <geekosaur> I should reparenthesize so it works more than just standalone though
11:38:56 <geekosaur> (fromVariant (head body) >>= fromVariant :: Maybe (Map String Variant))
11:40:10 <smakarov> Yes, it worked finally, thank you
11:42:09 <smakarov> I thought, that Variant is also internal type for dbus library and not available in my code.
11:45:46 <geekosaur> the *type* is exported. the *Data constructor* is not
11:46:05 <geekosaur> you cant build a Variant yourself or poke around inside it; you must use toVariant / fromVariant
11:46:16 <geekosaur> in the same way you can't poke around inside a Map
11:46:38 <geekosaur> or poke around "inside" an IO a
11:48:41 <geekosaur> you might want to take a look at the documentation for aeson; it has much the same problem, and uses a similar solution (except that the data constructors for aeson's Value are exported, unlike dbus's Variant)
11:49:07 <geekosaur> but its documentation might do a better job of explaining how to work with such things and what's going on
11:49:43 <smakarov> Yes, thanks, now I understand
11:52:05 <geekosaur> also I suspect the Show instance for Variant should use toVariant instead of Variant for the internal values, to make it clearer what's going on
11:52:31 <geekosaur> and conform to the convention that a Show instance produces valid Haskell code
11:57:49 * hackagebot pandoc-citeproc 0.11.1 – Supports using pandoc with citeproc – https://hackage.haskell.org/package/pandoc-citeproc
12:07:57 * hackagebot ginger 0.6.0.1 – An implementation of the Jinja2 template language in Haskell – https://hackage.haskell.org/package/ginger
12:19:48 <checkmateing> Hi guys!
12:24:35 <cocreature> hey checkmateing 
12:26:24 <checkmateing> What's up cocreature? :)
12:31:33 <johnw> is there a way to specify --with-gcc, but in the .cabal file?
12:33:14 * hackagebot xml-conduit 1.6.0 – Pure-Haskell utilities for dealing with XML with the conduit package. – https://hackage.haskell.org/package/xml-conduit
12:36:07 <geekosaur> hopefully "with-gcc: ...."
12:39:19 * hackagebot concrete-haskell 0.1.0.15 – Library for the Concrete data format. – https://hackage.haskell.org/package/concrete-haskell
12:42:10 <phadej> there isn't with-gcc in cabal file :/
12:43:24 <phadej> I'm not even sure you can specify that in cabal.project
12:44:50 <phadej> yes, looking at the code looks like  you can
12:45:58 <phadej> johnw: http://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project, with-gcc field isn't documented, but I hope I intepret the code right
12:46:20 <phadej> johnw: but if you don't want / can't use new-build, then I don't know
12:46:48 <phadej> maybe you can specify it in cabal.config
12:46:48 <johnw> phadej: thanks!
12:47:34 <phadej> at least "In general, the accepted field names coincide with the accepted command line flags that cabal install and other commands take."
12:49:49 <PaperclipMaximiz> anyone interested in joining a Gitter group about artificial general intelligence / strong AI? https://gitter.im/artificial-general-intelligence/Lobby
12:51:34 <checkmateing> Why is IO not done with uniqueness types?
12:51:49 <cocreature> because we don’t have uniqueness types in haskell
12:52:34 <dolio> Also uniqueness token passing is not a valid model of IO.
12:52:34 <checkmateing> What's the reason behind that? To ensure pureness?
12:52:39 <geekosaur> maybe you're looking for Clean
12:53:39 <dolio> At least, if you don't want IO in your semantics of the entire language.
12:54:19 <checkmateing> I see. But as it is now, you really need get used to it, lol
12:58:00 <johnw> is there a decent way Double -> Ratio Int? I only find Double -> RAtional
12:58:21 <johnw> I guess I can try fromRational...
12:58:52 <johnw> then I guess I wonder, does fromRational . toRational have a better name?
12:59:40 <DigitalKiwi> it would help if I was connected when I said stuff :(
12:59:51 <DigitalKiwi> [14:56:59]  <DigitalKiwi>	haskell web framework that's easy to learn with but also can make useful crap?
12:59:52 <DigitalKiwi> [14:58:16]  <DigitalKiwi>	I think any of snap yesod or happstack would satisfy my needs but I don't know many others... I'm used to playframework most lately
13:01:09 <geekosaur> @src realToFrac
13:01:10 <lambdabot> realToFrac = fromRational . toRational
13:01:16 <johnw> ah!
13:01:26 <johnw> been wondering where that was
13:01:41 <geekosaur> although RULES rewrite it to more optimal forms for various types
13:03:53 <DigitalKiwi> is glguy around
13:04:11 <DigitalKiwi> like obviously that name isn't here but I don't know if he's around in general...
13:04:57 <np356> Good Evening!
13:05:29 <DigitalKiwi> hi
13:05:32 <cocreature> DigitalKiwi: yeah he comes here quite often
13:05:59 <np356> I'm contracting with this company and I have a stronge urge to write some part pf their system in haskell, just don't want to freak the fuck out of them....
13:06:31 <shapr> np356: ok?
13:06:35 <np356> (just thinking out loud)
13:07:25 <DigitalKiwi> job security
13:09:26 * DigitalKiwi puts glguy on notify list
13:10:21 <shapr> np356: what are you building?
13:10:55 <np356> a deployment script
13:11:10 <shapr> er, in Haskell?!
13:11:13 <shapr> you using nixos?
13:11:35 <np356> yeah, what wrong with using python for that?
13:11:42 <np356> no just ubuntu
13:11:50 <np356> *using haskell for that
13:12:06 <checkmateing> I'd like to use NixOS, but it's unstable as hell
13:12:14 <shapr> np356: are you using joeyh's propellor?
13:12:35 <shapr> checkmateing: I was thinking of switching to it, I like it running in a VM
13:14:09 <checkmateing> I really like the concept of it, but I need a stable system and not something I have to debug for a weekend every once in a while
13:15:03 <np356> shapr: yeah, in haskell. I think that one of the beautiful things about haskell is its versatility. Like the build system for haskell is configurable through haskell (Setup.hs), unlike say c++ where you have a language for the code and a language for instructions on how to build the code (i.e. cmake).
13:15:13 <np356> Then why not make the deployment scripts in haskell as well?
13:15:32 <np356> the cpp way is to have c++ + cmake + python (for that script)
13:15:33 <shapr> np356: have you seen https://propellor.branchable.com/ ?
13:15:46 <np356> shapr: not yet. loooking
13:16:46 * hackagebot hslua-aeson 0.3.0 – Allow aeson data types to be used with lua. – https://hackage.haskell.org/package/hslua-aeson
13:16:47 <checkmateing> np356: naah, qmake, boost.build, premake, make, ... cmake is not a necessity
13:17:54 <checkmateing> But I get your point, since that is actually worse. Got like >10 different "languages" to describe how it'll be built
13:39:02 <dogui> Is there any way to get the unleying address (or any unique ID, really) from an IORef?
13:39:08 <dogui> underlying *
13:39:39 <np356> like the Handle?
13:40:10 <dogui> np356: probably.. I'm not very familiar with them :)
13:41:58 <np356> I would search along those lines I guess: https://www.google.com/search?client=safari&rls=en&q=haskell+IO+monad+file+handle&ie=UTF-8&oe=UTF-8
13:42:55 <np356> because that's the only thing that's unique about an IO object in a garbage collected language
13:43:06 <np356> what's your scenario? why you need this ID for?
13:44:26 <dogui> np356: thanks! I'm searching but nothing yet
13:44:48 <verement> dogui: since IORef has an Eq instance, you can use the IORef itself as a kind of unique ID
13:44:58 <dogui> I want to have a map relating references (of varying types!) to their underlying value
13:44:59 <np356> ok.. lets stap back a bit. Why you need an unique identifier for an IORef?
13:45:10 <dogui> to implement transactions over them
13:45:25 <Cale> np356: An IORef is just a pointer
13:45:38 <dogui> the variation of types makes it impossible to use ==, as I need an heteregeneous comparison
13:45:56 <np356> Data.Map IORef String ?
13:46:08 <np356> ahhh
13:46:22 <np356> the value needs to have some common-denominator-type
13:46:24 <Cale> dogui: Just to check, are you aware of STM?
13:46:31 <np356> either serialize it and reconstruct
13:47:04 <dogui> Cale: yes, thanks for mentioning it! however I want to this from within a single thread and rollback arbitrary changes
13:47:12 <dogui> Cale: as far as I understand, STM won't let me do that
13:47:14 <np356> or let's step back a little bit more. Why you need a map of IORef -> SomeOtherType? Are you implementing a cache?
13:47:17 <Cale> correct
13:47:30 <Cale> Well, wait, hmm
13:47:32 <DigitalKiwi> is snap a good web framework to start with
13:47:41 <Cale> DigitalKiwi: It's not too bad
13:48:21 <DigitalKiwi> it's been a while since I've looked at them and I think I usually tend to decide that one...
13:48:37 <dogui> np356: I want to build a log of all writes to IORefs, so I can then revert them all
13:49:06 <dogui> np356: A naïve solution is to make the log a [IO ()], and execute them one-by-one, but I want something better
13:49:56 <np356> you're implementing "undo"?
13:50:09 <Cale> dogui: You could have an IntMap of IORefs as a kind of virtual heap, and use the Ints to refer to the references
13:50:17 <barrucadu> Will you need to revert a transaction at some arbitrary future point, or only during the transaction itself?
13:50:18 <DigitalKiwi> out of all of the other languages/frameworks I've used I liked/was most productive with playframework 2 but I have an excuse to actually get something going with haskell...
13:50:18 <Cale> dogui: There's also StableName
13:50:21 <dogui> np356: basically yes, I think
13:50:39 <Cale> https://hackage.haskell.org/package/base-4.10.0.0/docs/System-Mem-StableName.html
13:50:50 <Cale> hmm... does this give you enough of a guarantee? Maybe not.
13:50:53 <dogui> Cale: thing is I want to retrofit this into a huge codebase, and I want a little impact solution
13:50:57 <dogui> (reading the stable name thing now)
13:50:58 <barrucadu> dogui: Have you considered just computing the undo action as you make your changes?
13:50:58 <np356> dogui: https://en.wikipedia.org/wiki/Persistent_data_structure
13:51:25 <np356> dogui: make a persistent queue/list/etc..
13:51:27 <barrucadu> eg, writeIORefWithUndo ref a = do { old <- readIORef ref; writeIORef ref a; return (writeIORef ref old) }
13:51:46 <barrucadu> So every function which modifies an IORef also gives you an action to undo that change
13:51:47 <dogui> Maybe I should have made this clear before: I want to do this to retrofit transactions into some legacy, thousand of lines long software using IORefs
13:51:53 <dogui> barrucadu: that's exactly what I'm doing now
13:52:06 <dogui> barrucadu: but several writes to the same reference get logged needlessly
13:52:08 <platz> is there an advantage to using "data MyType" with "(Proxy :: Proxy MyType)" over "data MyType = MyType" and passing MyType values around?
13:52:17 <Cale> dogui: I think what I'd do first is abstract over all uses of IORef
13:52:26 <platz> the latter seems simpler for callers
13:52:32 <Cale> dogui: Instead of passing around IORefs, pass around IO actions for interacting with them
13:52:42 <barrucadu> dogui: Is it a problem if you have multiple undo actions for the same IORef?
13:52:50 <dogui> barrucadu: It's slow
13:52:52 <Cale> dogui: i.e. readIORef r and writeIORef r
13:53:08 <Cale> dogui: Then, once that's done, you can change the implementation of the actions to do whatever you like
13:53:29 <barrucadu> Ok, I can see it being slow if you have large transactions you want to undo
13:53:43 * barrucadu notes this down as a possible performance issue in dejafu's STM implementation...
13:55:32 <Cale> dogui: (You may also want to invent some abstraction around that pair a -> IO () and IO a, but whatever works)
13:56:03 <dogui> Cale: thanks
13:56:05 <Cale> dogui: Might be a bit of a refactoring, but it shouldn't be insanely difficult, just mildly tedious
13:56:18 <dogui> Cale: yeah, I think it might be a lot in this case..
13:56:51 <dogui> Cale: a compromise would be to change from `IORef a` to `MyIORef a = (UniqueID, IORef a)`, which allows for a compact log
13:57:00 <dogui> Cale: if I understood correctly..
13:57:40 <Cale> Well, if you're going to do that, that'll involve changing the types everywhere anyway, which will amount to as much refactoring work
13:58:16 <dogui> yeah, you're right, I was confused
13:58:20 <Cale> So, might as well change the type to be something nicely general so that you can experiment with different strategies for logging freely
13:58:28 <dogui> yes, makes sense
13:58:40 <dogui> I'll try it out, thanks a lot!
13:59:54 <np356> barrucadu: woudn't that keep all those IO resources hanging and prevent the gc from collecting it and freeing the handles?
14:00:13 <barrucadu> np356: It depends on how long you want to keep around the undo action
14:00:20 <np356> smells like a perf / memory / out of handles exception
14:00:46 <barrucadu> In my STM implementation, it either gets used immediately at the end of the transaction or thrown away.
14:00:51 <dogui> np356: it will, and in this case for sure
14:01:00 <Cale> Wait, which handles?
14:01:05 <dogui> np356: I noticed this on a different compiler
14:01:06 <np356> dogui said thats is thousands of lines long, so I guess its mid-term store
14:01:11 <Cale> These are just IORefs, aren't they?
14:01:55 <kritzefitz> Are there version of quot and rem that can work on RealFracs?
14:02:20 <np356> dogui: your problem is a bit higher on the abstraction level I feel.
14:03:21 <Cale> kritzefitz: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/Data-Fixed.html#v:divMod-39-
14:03:23 <np356> lets start from the beginning: you have a list of arbitary actions that need to be performed, for each action: the result should be logged, the invocation instructions should be saved, and the order of execution should be known.
14:03:48 <Cale> kritzefitz: Hopefully you don't mind the sign convention
14:03:58 <np356> then there is a function called "undoUntil listOfAllActionsPerformedSoFar rollbackPoint"
14:04:03 <np356> right?
14:04:23 <kritzefitz> Cale: I'm only working with positive numbers, so it doesn't matter. Thank you very much!
14:13:04 <dogui> np356: pretty much
14:13:19 <np356> I would start here: https://en.wikipedia.org/wiki/Persistent_data_structure
14:14:51 <np356> however, if your actions perform mutation on uncontrolled objects, they will also have to produce the "undo" action.
14:15:16 <np356> Because you can't just roll-back the OS back to X
14:15:24 <np356> (unless you're using docker :) )
14:16:18 <np356> actually... https://docs.docker.com/engine/reference/builder/
14:16:26 <np356> This is exactly what you're trying to build.
14:16:38 <np356> See how docker saves a version of the image on every command invocation
14:16:48 <np356> and then just pulls it from cache on subsequent runs
14:17:17 <np356> but if you change something in the dockerfile, it will pull everything from cache up to the point of the changed line.
14:18:29 <Cale> Once he has the interface abstracted, he'll be able to do whatever he wants, e.g. just maintaining things in a Data.Vault, and swapping the old vault for the new when a transaction commits
14:18:38 <Cale> https://hackage.haskell.org/package/vault-0.3.0.7/docs/Data-Vault-Lazy.html
14:20:19 <Cale> (i.e. you'd have an IORef Vault which all the IORefs involved in your transaction would actually be manipulating, and you'd hang on to the original contents of that IORef until you were ready to decide whether to commit)
14:21:26 <np356> I don't think that IORef is the right way of identifying an action.
14:21:54 <np356> the action should be identified by the same thing that defines its execution instructions.
14:22:02 <nilof> I just read that GHC haskell is getting linear types?
14:22:29 <Cale> np356: I'm only talking about solving the problem that dogui mentioned
14:22:49 <np356> let's try to solve it for him in the right way :)
14:22:52 <Cale> (which shouldn't involve keeping track of actions)
14:23:15 <np356> I actually think that you don't need to keep track of actions 
14:23:41 <np356> you just need to have a cursor that keeps track of the last successfully executed action from the list of action to be executed.
14:23:49 <np356> thats const vs linear 
14:24:31 <Cale> We don't need that even. Just carry out IO directly, but, having abstracted what it means to read from and write to the IORefs that were being manipulated before
14:25:04 <Cale> instead of reading and writing memory directly, accumulate a data structure containing all the stuff which is meant to be transactional
14:25:41 <Cale> and hang on to the old version of that structure until a commit occurs
14:26:04 <Cale> so you can immediately roll back just by replacing your working version of the structure with the old one
14:26:28 <np356> dogui: please tell us more about the types of actions that are executed
14:26:36 <barrucadu> I just profiled the time cost of accumulating a million undo actions for the same ref, and it was still under 2s.
14:26:38 <np356> and the type of undo operations they might need?
14:26:57 <np356> barrucadu: that is physically impossible
14:27:16 <np356> do a million "mkdir ./x && cd x"
14:27:21 <np356> and roll it back in 2s
14:27:26 <np356> and I will suck your dick.
14:27:54 <barrucadu> np356: Well, we're not talking about making directories on a filesystem, we're talking about IORef writes
14:28:04 <johnw> such language is not wanted here
14:28:07 <np356> IORef is an uncontrolled IO operation.
14:28:08 <Cale> np356: Are you familiar with what IORefs are?
14:28:11 <Cale> no.
14:28:15 <np356> It could as well be reading from a tape drive
14:28:18 <Cale> IORefs are simply pointers to a memory cell
14:28:19 <barrucadu> No
14:28:31 <Cale> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-IORef.html
14:28:33 <np356> oh, so IORefs are not file handles?
14:28:35 <Cale> They're just mutable variables
14:28:38 <Cale> absolutely not
14:28:46 <np356> ah, then my apologies.
14:29:05 <Cale> It makes sense why you were saying lots of confusing things now though :)
14:29:38 <np356> so why its IORef not IntPtr?
14:29:57 <Cale> Well, because pointer arithmetic is usually a bad idea
14:30:19 <np356> so IORef is IntPtr - the Number interface?
14:30:37 <Cale> and not every type of Haskell value has an exposed means of being serialised to memory in a deterministic format -- some of that is left up to the implementation.
14:30:42 <geekosaur> because it's STRef specialized to IO, and it's impure in the sense that the thing it references can change by means other than the current execution thread
14:31:17 <Cale> I'm assuming by IntPtr, you mean a numerical memory address?
14:32:27 <Cale> Internally, an IORef is essentially just a memory address, but that's hidden from the programmer
14:32:28 <carter> IntPtr would just be an int that large enough to hold the difference between two addresses.
14:32:36 <carter> Usually.
14:32:50 <Cale> carter: Would it? I don't think I've seen that term used anywhere.
14:33:16 <carter> C standard. And it's kinda mentioned In the ffi appendix to Haskell
14:33:19 <Cale> oh
14:33:19 <Cale> C
14:33:20 <Cale> hah
14:33:56 <carter> WordPtr would be the type of unsigned ints large enough to exactly hold a memory address
14:35:02 <carter> But neither is a memory address. That's Addr
14:37:26 <np356> I come from a cpp background. and in c++ every object has an identity. The common-denonominator for all identities is the memory address of the object. That's why even struct x {}; has sizeof(x) =/= 0. In GC collected languages its usually something like "obj-id". If IORef is just a pointer to a fixed memory cell, then I don't understand why its not an IntPtr (the numberic value of the memory address of 
14:37:32 <np356> the IO object).
14:38:05 <np356> Why Haskellers felt compelled to create a new IORef type instead of reusing IntPtr?
14:39:08 <geekosaur> because C/C++ let you address off of such things arbitrarily
14:39:30 <geekosaur> Haskell doesn't, for good reason (there is a different mechanism for whn you need that, as part of the FFI)
14:40:24 <np356> wait a second.
14:40:25 <geekosaur> C programmers think a language that encourages coding segfaults is a good thing?
14:40:38 <np356> 1. Data.IORef: Mutable references in the IO monad.
14:40:53 <np356> 2. IO MOnad: A value of type IO a is a computation which, when performed, does some I/O before returning a value of type a.
14:41:13 <np356> So the reason that you think that it is just a pointer to a memory cell is because you are aware of the implementation.
14:41:28 <geekosaur> what?
14:41:36 <np356> if you'd follow what the doc says then IORef could be "mkdir x && cd x" just as well.
14:41:52 <Cale> np356: IORef couldn't, really
14:42:05 <geekosaur> move those goalposts, now your problem is that IO itself tends to be a sewer that collects *all* impurity
14:42:06 <Cale> np356: Well, its interface is pretty abstract, I guess...
14:42:10 <geekosaur> but then that is why STRef exists
14:42:34 <np356> IO operation: "mkdir x && cd x", its mutable variant is probably something that would let me edit it or roll it back?
14:42:45 <barrucadu> np356: An IORef is just a memory cell containing a value
14:42:59 * np356 feels like they need to think about haskell in a very different way than cpp
14:42:59 <Cale> np356: A value of type IO a can express whatever a program on your computer could normally do, but an IORef a is just a mutable value of type a
14:43:04 <Cale> (which you can read and write)
14:43:10 <geekosaur> that, or you are (possibly deliberately) conflating IO the type with specific uses of IO
14:43:25 <Cale> We have
14:43:52 <np356> ok, let's step back a bit...
14:44:06 <np356> what does "a mutable value of x" mean in your vocabulary?
14:44:08 <Cale> readIORef :: IORef a -> IO a  which is a function that, given an IORef containing a value of type a, constructs the IO action which, when executed will read the IORef, obtaining a result of type a
14:44:30 <Cale> writeIORef :: IORef a -> a -> IO ()
14:44:45 <Cale> is a function which given an IORef containing a value of type a, and a new value of type a
14:45:02 <Cale> will construct an IO action which, when executed, will replace the contents of the IORef with the given value
14:45:12 <Cale> (and produce an empty tuple as its result)
14:46:17 <Cale> There are a bunch of ways in Haskell to glue IO actions together into more complicated IO actions, and ultimately the 'main' of your program is such an action which will be executed when the program is run
14:46:25 <np356> cool. Thats for the interesting discussion. its 11.45pm. Time to go home.
14:46:31 <np356> bye.
14:46:34 <Cale> Evaluation of expressions cannot cause IO actions to be executed, ordinarily
14:46:37 <Cale> Okay, see you
14:47:32 <bjs> Cale: "evaluation" vs "execution" of IO actions is something fairly peculiar to Haskell it feels like
14:47:38 <Cale> yes
14:47:45 <Cale> Well, somewhat anyway
14:47:58 <Cale> Evaluation usually refers to the process of turning expressions into values
14:48:04 <geekosaur> distinguishing between them is, certainly. most  languages conflate them and make you deal with the fallout
14:48:41 <Cale> It's just that in Haskell, we tend to keep this side-effect free (as much as possible, and just from the programmer's point of view -- there are plenty of effects and mutation going on under the covers to make it go)
14:49:07 <Cale> Whereas we have these special values in Haskell called IO actions which describe effects to be performed
14:49:38 <Cale> and "execution" (which really is more of a Haskell thing, I suppose) then refers to carrying out the instructions described by the IO action values
14:50:16 <Cale> Execution of IO actions can cause your computer to do anything that computers do
14:50:54 <Cale> Evaluation of expressions just results in a value depending only on what the expression was and the values of the variables occurring free in it, and your CPU gets warm
14:51:39 <Cale> So e.g. in Haskell, if I have a function Integer -> Integer, I know it's not going to write to the network when I apply it to compute some stuff.
14:51:59 <Cale> and I know that if I apply it to 5 and obtain some result, I'll obtain the same result next time I apply it to 5 as well
14:52:33 <Cale> This makes testing a whole lot easier and more reliable, and makes it way easier to think about what programs are doing
14:54:35 <bjs> Cale: modulo order/strictness of said evaluation ^^
14:55:01 <Cale> Well, you can show that any two orders of evaluation which terminate will produce the same result
14:55:17 <Cale> and if any order of evaluation terminates, then outermost-first evaluation terminates
14:55:53 <Cale> (lazy evaluation being outermost-first with an additional caveat that work done to evaluate a bound variable will be shared between all occurrences of the variable)
14:56:31 <Cale> GHC doesn't actually do lazy evaluation exactly, it mixes up the evaluation order a bit when it can discover it's safe to do so
14:57:06 <Cale> (evaluating things that it knows it will need later, sooner, so as to avoid hanging on to unevaluated expressions in memory when it's not necessary)
14:59:04 <Cale> In order to facilitate that, bound variables get implemented at a low level as pointers to code (for the expression in question, at first). The first time you enter the code, it first rewrites the pointer to point at a bit of code which throws an exception (infinite loop detected), then computes the value of the expression, and then rewrites the pointer to point at a short piece of code which will immediately return 
14:59:04 <Cale> the already-computed result
15:00:22 <Taneb> That's really cool
15:01:05 <Cale> https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf -- this paper is really good if you want more details
15:01:26 <Cale> It also has a really good little section on exploring the design space of possible implementations for this kind of thing
15:02:01 <Cale> This paper is not exactly up to date with GHC (and there are some details in my explanation which aren't always true in GHC even), but it's still a really good starting point, and is mostly true :)
15:03:37 <Cale> For example, data types with few constructors will have their pointers tagged -- the low order bits of the pointer get used to encode which data constructor the result was built with, so you don't need to dereference it if that's all you want to know
15:04:06 <Cale> Since code pointers are aligned to multiples of 4 or 8, it can reuse the low 2 or 3 bits that way
15:04:35 <Cale> (for types having at most 3 or 7 constructors)
15:18:46 <Wizek> Multi-threading question: is it possible/easy to return a kind of thunk from a `forkIO` (or an `Async.async` to that matter) where any computation due to forcing will be computed by the separate thread? Initially I was baffled by the main thread of my program got bogged down until I figured out to `async $ do foo <- getData; foo2 <- evaluate $ expensivePureFn foo; return foo2`. Which works, but afaik this might compute
15:18:46 <Wizek> more than necessary.
15:19:44 <np356> we don't need transactional memory. We need transactional OS
15:19:50 <np356> Docker is getting pretty close.
15:20:02 <np356> essentially, we need a revision-control built into the fs.
15:20:11 <np356> that would solve so many of humanity's problems
15:22:53 <dsal> We had that in Solaris.
15:22:59 <dsal> It worked really well.  That's why it's dead.
15:23:06 <np356> So here's my little hypotheis: i know that there's the halting problem and it would never work, but if we were able to estimate exactly how much memory an arbitary uncontrolled action will take, then its entirely possible to build transactional computing at any level.
15:23:20 <np356> dsal: haha
15:25:04 <Cale> np356: NixOS is a lot closer
15:25:40 <Cale> (than docker)
15:26:13 <dsal> NixOS is intel only, right?
15:26:46 <Cale> dsal: If so, I wouldn't think there's a really good reason for it. It's Linux based.
15:27:21 <dsal> All my linux machines are ARM.
15:28:16 <dsal> And they're like, a solid C.  I'm pretty frustrated with modern Linux (and I didn't really like linux back in the day).
15:28:46 <Cale> https://github.com/nixos-users/wiki/wiki/NixOS-on-ARM
15:29:26 <np356> NixOS is just a different approach to apt-get. Docker has that.
15:29:30 <dsal> Neat.  I'm all about orange pi these days.  Hopefully this will be a good option someday.
15:29:44 <Cale> Personally, I couldn't really stand to use NixOS on my desktop machine, but a bunch of my coworkers do, and it's really cool what it does for deployment of our software
15:29:45 <np356> Cale: Not convinced. ;)
15:29:52 <thoughtpolice> NixOS is far more than apt-get.
15:30:02 <dsal> NixOS has an awesome log.
15:30:23 <np356> do you have a good link to a tutorial that explains all that?
15:30:49 * np356 is back home and rolling a bigass joint.
15:31:29 <dsal> I liked that I could do a full Solaris upgrade, wreck it so that it can't boot, and then just undo the whole thing.  That felt like the future back then.  Still can't do that.
15:31:38 <Cale> np356: Basically, Nix is a build system for deterministic reproducible builds and system configuration replication.
15:31:45 <np356> that's exactly what I need
15:32:16 <Cale> I don't actually use nixos, but I still use the nix package manager, because it's awesome to be able to run a script and get dropped into a shell with a custom bunch of software and then throw it all away a moment later.
15:32:43 <np356> So I'm working on some AI for robotics, and we have Intel NUC on the vehicle and I would like to have this setup: Everytime a build that is code-reviewed passes all the tests, it gets automatically deployed to headless physical machines.
15:33:37 <np356> so far each robot runs ubuntu + ros:kinetic
15:33:38 <Cale> We use it where I work to build all our software, and it's nice to have some guarantee that everything, down to the system libraries in use, are byte for byte the same in development and production. (Though on my machine, I guess the kernel is different since I'm not running the OS version.)
15:33:43 <dsal> Something about the words "robotic AI automatically deployed headless physical" makes that unsettling.
15:33:46 <thoughtpolice> dsal: You can do that fine in NixOS, although it depends on what you mean by 'wreck'.
15:34:08 <dsal> thoughtpolice: Full system upgrade, all /lib/* kernel, etc...  Kernel didn't boot.  Undo.
15:34:31 <thoughtpolice> Trivial. Easy as booting into grub and selecting the prior configuration.
15:34:45 <dsal> Do the filesystems undo as well?
15:35:01 <thoughtpolice> Generally you can avoid that, even. You can just create a virtual machine to test your system configuration without rebooting and swap.
15:35:20 <np356> dsal: don't worry, they're in a controlled environment. They won't go and f*ck around with random people in residential areas.
15:35:28 <Cale> We just have a script which does a nix-copy-closure to an AWS machine, and it copies a configuration which includes an entire system config (which will fire up our application backend), and then we tell it to switch to the config and reboot, and that's all there is to deployment.
15:35:48 <thoughtpolice> dsal: Depends. Do you mean "my database magically went back to where it was 5 minutes ago"? No. It doesn't handle things like that, but if you have a COW filesystem, sure. If you mean "all of the broken files disappear and the filesystem looks like it did last time", e.g. same programs, layout, etc, then yes.
15:36:28 <dsal> Yes.  Solaris was built on ZFS, so it's snapshot -> upgrade -> oops -> rollback
15:36:36 <thoughtpolice> Generally "mutable data" rollbacks like a database would need to be handled separately or at the filesystem level. But system-level stuff -- the programs you have installed, the users and their group configurations, etc -- are all kept in check.
15:37:05 <thoughtpolice> You can IIRC pretty easily integrate COW snapshotting into nixos rollbacks, I think. In general Linux's various COW solutions are pretty poor.
15:37:07 <dsal> Sure, understood.  Sounds good.  Just need that on my orange pis.  :)
15:37:12 <thoughtpolice> (NixOS might support ZFS-on-root now, idk)
15:37:42 <dsal> Yeah.  I tried btrfs bak in the day.  My main reaction to the whole thing (for a few months was)  "I can't believe it's not better"
15:38:03 <boj> thoughtpolice: ooo, that would be nice
15:38:33 <thoughtpolice> dsal: IMO bcachefs is the way of the future for Linux but that's quite off topic; NixOS already is but it comes up here a lot dspite that...
15:38:41 <np356> see... if people didn't change their opinions, we wouldn't have to deal with all this transactionality shit...
15:38:44 <np356> just sayin'
15:40:23 <thoughtpolice> dsal: In theory though it'll check all the boxes... including a few ZFS can't (like a codebase that's portable by design, w/ adapters like direct drivers, or FUSE layers -- imagine a COW flash drive, but one you can actually mount on Windows and plug back into your Linux machine, etc)
15:43:30 <np356> as a cpp guy, what do haskellers think of Rust?
15:49:12 <np356> any of your dear irc random people are in Germany? or at least in the EU?
15:49:21 <np356> looking for devs.
15:49:29 <np356> remote/frelance
15:49:55 <dsal> I know some erlang programmers in .de
15:49:55 <np356> if you're interested hit me up at: hello@karimagha.de
15:58:59 <platz> is there an advantage to using "data MyType" with  "(Proxy :: Proxy MyType)",  over "data MyType = MyType" and passing MyType values around?
15:59:34 <np356> no
16:00:45 <copetti> @pl (\x -> (x, 0))
16:00:45 <lambdabot> flip (,) 0
16:01:22 <dsal> What's @pl ?
16:02:15 <Hafydd> It writes expressions in point-free style.
16:02:59 <platz> hrmm. one thought might be Proxy allows creating a value without knowing which constructor is needed
16:04:35 <dsal> Is that a lambdabot thing?  I could've used that last night.  Then again, I'm better off doing that myself for now.
16:07:22 <Hafydd> dsal: it is a feature of lambdabot, obviously. I'm sure there are other programs that have the same capability.
16:08:12 <dsal> I found the manual.  :)
16:13:46 <dsal> @pl \(c, f) -> f (ctoi c)
16:13:47 <lambdabot> uncurry (flip id . ctoi)
16:13:50 <dsal> dam
16:13:51 <dsal> n
16:14:34 <trigone> can i put import statements anywhere in a module? aka can i insert top-level definitions between import statements? (don't tell me it's a bad idea, i know that)
16:14:40 <mniip> no
16:14:44 <dsal> @pl (\c -> if c == ',' then ' ' else c)
16:14:44 <lambdabot> flip if' ' ' =<< ((',') ==)
16:14:47 <trigone> :t ctoi
16:14:48 <lambdabot> error: Variable not in scope: ctoi
16:14:51 <dsal> woah.  I don't even know what that is.
16:15:05 <dsal> trigone: ctoi = toEnum . fromEnum :: Char -> Int16
16:15:20 <trigone> dsal: ok thx
16:15:26 <trigone> mniip: did you say no to me?
16:15:32 <mniip> trigone: yes
16:15:48 <trigone> mniip: hm sigh... ok thx
16:15:53 <dsal> I can't read that suggestion.  heh.
16:15:54 <mniip> dsal, liftA3 bool (pure ' ') id (== ',')
16:16:11 <dsal> That's closer to readable.
16:17:03 <dsal> Huh.  My code is mostly point-free.  I wonder how I got into this habit.
16:17:34 <dsal> @pl (\n r -> r V.! n)
16:17:34 <lambdabot> flip (V.!)
16:17:45 <dsal> Oh yeah.
16:17:49 <dsal> Man, this golf robot is nice.
16:24:57 <mniip> dsal, not always
16:25:06 <mniip> @pl (\x y z w -> w z y x)
16:25:06 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
16:25:14 <mniip> @pl (\x y z w -> w z z y y x x)
16:25:14 <lambdabot> flip =<< ((flip . (flip .)) .) . flip (flip . (flip .) . (flip =<< (flip .) . flip (flip . (flip =<< flip id))))
16:31:28 <dsal> @pl (╯°□°）╯︵ ┻━┻
16:31:28 <lambdabot> (line 1, column 3):
16:31:28 <lambdabot> unexpected "\149"
16:31:28 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
16:32:07 <Clint> ...
16:32:47 <mniip> I'm pretty sure it's subexponential though
16:33:02 <mniip> oh er, I'm confusing with djinn
16:33:09 <mniip> this might as well be exponential
16:40:19 <dsal> If I have a file.hs declaring no module or anything, can I write a test that uses stuff from it?
16:42:07 <dsal> related:  What is the relevance of source files in haskell?
16:42:57 <dsal> e.g., they have almost none in go, other than limiting import visibility/aliases.  A package naturally spans multiple source files (but not multiple directories).
16:47:35 <nshepperd_> It's one module per file
16:47:53 <nshepperd_> Ghc searches by filename to find imports
16:48:32 <dsal> Can I test stuff from a file that doesn't declare itself a module?
16:48:40 <dsal> e.g., something "scripty"
16:50:51 <nshepperd_> If you don't put a module declaration it assumes module Main by default
16:51:20 <nshepperd_> And expects it to have your programs entry point
16:54:39 <nshepperd_> By "test stuff" you mean writing unit tests?
16:56:00 <dsal> Yeah, I want to test some of the functions in this file without creating two more files.  :)
17:01:02 <nshepperd_> Maybe you could put the tests in the same file and have a flag to run them or something
17:02:00 <dsal> I'll just do the two-more-files thing.
17:14:52 <cheater> what are currently the best QuickCheck alternatives? Thinking about things that are relatively full-featured
17:29:29 <dsal> Converting my little program to use stack makes it harder for me to like, just build and run the program.
17:44:38 <dsal> How do I get stack install to default to    --local-bin-path $PWD/bin
17:48:00 <trigone_> i was wondering why Int was so ubiquitous in Prelude or Base, even when a number that can be negative makes no sense (take, length, etc). Why not use Word, or any unsigned alternative?
17:49:34 <dolio> Word isn't in the Haskell report.
17:49:40 <dsal> take -3 [0..10]
17:49:40 <dsal> [-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
17:55:27 <geekosaur> also because having to fromIntegral stuff all the time is annoying enough as it is
17:58:39 <pacak> > length [1..3] - length [1..5]
17:58:42 <lambdabot>  -2
17:58:51 <pacak> > fromIntegral (length [1..3] - length [1..5]) :: Word
17:58:54 <lambdabot>  18446744073709551614
17:58:57 <c_wraith> And I don't trust that if I'm using arithmetic on Word that I'm doing anything sane.
17:59:03 <c_wraith> ... as pacak was kind enough to demonstrate
18:01:12 <tesan> I think I just made ghci hang itself. Any idea what was so bad about this?  take 20 [sqrt x | x <- [1..], ( x > 3.0 && x < 5.5)]
18:01:33 <dmj`> @tesan [1..] is an infinite list
18:01:33 <lambdabot> Unknown command, try @list
18:01:54 <tesan> And I used "take 20"
18:02:00 <tesan> Isn't that enough safety?
18:02:01 <dmj`> ah :)
18:02:02 <dsal> Yeah, but it hasn't found 20 yet
18:02:49 <tesan> It displayed 2 numbers, then my PC started to overheat.
18:03:11 <dsal> It's trying to find the next number > 3.0 and < 5.5 in the list.
18:03:52 <trigone_> geekosaur: wait we need "fromIntegral" to use literal numbers with type `Word`?
18:04:06 <dsal> > take 20 [sqrt x | x <- cycle [1..13], ( x > 3.0 && x < 5.5)]
18:04:08 <lambdabot>  [2.0,2.23606797749979,2.0,2.23606797749979,2.0,2.23606797749979,2.0,2.236067...
18:04:20 <trigone_> pacak: hm i see
18:04:25 <geekosaur> you will probably need it if you are doing computations on or involving the result
18:05:04 <trigone_> it still seems kinda weird to use (-) with natural numbers. in theory you only ever want to have the absolute value of the difference, don't you?
18:05:26 <trigone_> semantically speaking i mean
18:05:38 <tesan> Did the lambdabot hang itself too?
18:05:41 <tesan> I don't see 20 numbers
18:05:55 <geekosaur> if it's an intermediate result that will ultimately be positive?
18:06:11 <geekosaur> tesan, it didn't hang, it chopped off at the length limit
18:06:12 <pacak> tesan: It looks for more values less than 5.5.
18:08:54 <trigone_> wait how is take defined to output a bigger list than its input?
18:08:59 <trigone_> @src take
18:08:59 <lambdabot> take n _      | n <= 0 = []
18:08:59 <geekosaur> ghci doesn't have a built-in length limit, so it doesn't have that "escape hatch" from an infinite computation
18:08:59 <lambdabot> take _ []              = []
18:08:59 <lambdabot> take n (x:xs)          = x : take (n-1) xs
18:09:41 <trigone_> i think take -3 should not have outputed what it did
18:09:48 <mac10688_> is there a way to short circuit a foldr function?
18:09:51 <trigone_> > take (-3) [0..10]
18:09:53 <lambdabot>  []
18:10:23 <geekosaur> I have no idea what you did, 'take -3 ...' seems a type error to me
18:10:44 <dsal> mac10688_: I think you can short circuit foldr, but I've not done it
18:10:45 <trigone_> geekosaur: actually dsal copy pasted, didn't used lambdabot
18:10:49 <tesan> geekosaur: Is the escape hatch part aimed at me?
18:11:10 <dsal> Also, I lied
18:11:11 <geekosaur> tesan, yes. and I was talking about [19 01:03:45] <dsal> > take 20 [sqrt x | x <- cycle [1..13], ( x > 3.0 && x < 5.5)]
18:11:16 <geekosaur> and lambdabot's response
18:11:20 <geekosaur> which truncated
18:11:29 <mac10688_> dsal, lol?
18:11:35 <trigone_> dsal: yeah we saw :P you evil
18:11:54 <dsal> take with a negative n == give
18:11:57 <tesan> geekosaur: Yet I do not see how it should become a problem when I limit it to 20 numbers to display for a simple sqrt list.
18:12:10 <geekosaur> meanwhile consider that list comprehensions do "filer" not "takeWhile"
18:12:16 <geekosaur> *"filter"
18:12:48 <boj> tesan: because your condition never reaches 20 numbers
18:12:59 <trigone_> dsal: not everything is ordered. how do you take (-3) showers?
18:13:09 <dsal> trigone_: skill
18:13:13 <geekosaur> filter will keep iterating an infinite list forever, producing results lazily. if you do something that demands the results strictly (like 'print' with no, or too high, a limit) then it'll go on forever
18:13:25 <mniip> trigone_, dive into a mud puddle
18:13:47 <geekosaur> so it found the first two values, and then kept cranking the infinite list looking for values that will never match the filter
18:14:00 <trigone_> mniip: hm... not bad ^^
18:14:33 <geekosaur> laziness is not self-awareness, it does not know that it will never get any more small values that pass the filter
18:14:34 <dsal> i.e., there's no special knowledge of that particular model of infinite list with that particular filter
18:14:42 <c_wraith> It's such a challenge to teach people that lazy evaluation is still just mechanically following rules.
18:14:48 <c_wraith> They're just different rules
18:14:53 <tesan> Ohh okay. So how could I prevent it from happening that the system strictly wants the 20 numbers when it can't ever get them?
18:15:21 <dsal> tesan: you could not give it numbers that won't pass your filter
18:15:49 <geekosaur> for starters, I don'rt use filter in cases liek this, I use takeWhile because I (unlike the computer) know that once it goes False it will never go True again
18:16:04 <geekosaur> (you used a list comprehension, which is implicitly "filter")
18:16:10 <dsal> Almost every number you gave it doesn't pass your filter
18:16:35 <c_wraith> There is no way to induce termination without taking advantage of domain knowledge
18:16:53 <mniip> yay halting problem
18:17:50 <geekosaur> a computer algebra system, for example, *could* introspect the generator and see that the expression will never become True once it has become False and short-circuit at that point
18:18:04 <tesan> Ohh right, I just applied the filter in the wrong spot. I actually intended to do a:
18:18:09 <geekosaur> (doesn't mean it necessarily *will*; that depends on how it is written)
18:18:11 <c_wraith> It does that by adding domain knowledge to the evaluation model. :)
18:18:58 <tesan> Hmm now thinking about it it would also be troublesome. Anyway I wanted to apply the filter to the end result anyway.
18:20:08 <tesan> take 20 [ x | x <- [sqrt x | x <- [1..]], not ( x > 3.0 && x < 5.5 ) ]
18:20:14 <tesan> At least it'll work with a not
18:20:41 <tesan> Now why doesn't lambdabot calculate that?
18:21:11 <trigone_> tesan: you forgot >
18:21:12 <dsal> You didn't ask it to
18:22:01 <tesan> > take 20 [ x | x <- [sqrt x | x <- [1..]], not ( x > 3.0 && x < 5.5 ) ]
18:22:04 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.4494897427...
18:23:04 <tesan> Wonderful. Now I'm almost tempted to know if I could get lambdabot to crash with some ridiculous operation. Does that make me a bad person?
18:23:59 <dsal> It's hopefully reasonable constrained
18:25:17 <dsal> > product [7..]
18:25:24 <lambdabot>  mueval-core: Time limit exceeded
18:25:32 <tesan> Ahh good.
18:25:50 <tesan> That would have molten my laptop for sure.
18:26:30 <dsal> You need a faster computer
18:27:42 <c_wraith> > product [7..] :: Word8  -- or a faster data type!
18:27:44 <lambdabot>  0
18:27:53 <c_wraith> haha
18:27:54 <tesan> I have one right besides me, sadly the power socket it was attached to blew up. Kind of. I'll be able to use it again next month
18:27:59 <c_wraith> yes, it would be 0, wouldn't it?
18:28:21 <tesan> c_wraith: What is that Word8
18:29:00 <c_wraith> tesan: an unsigned 8-bit integer
18:29:04 <c_wraith> tesan: aka a byte
18:30:41 <tesan> Well, if lambdabot has a time-constraaint, such faster operations could surely increase its temperature if abused in a systematic way.
18:31:19 <c_wraith> "faster" in my claim above was a joke.  Really the important part is that it's a type where "all of them greater than 7" is a short list. :)
18:32:14 <tesan> I guess that is stuff I'll learn in my first year [this/next year] in the IT degree
18:33:01 <tesan> > :q
18:33:03 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:33:17 <mniip> tesan, all irreversible computation can be used to increase temperature
18:34:55 <Xandaros> I (will) have something resembling this: https://hastebin.com/oqocixugom.hs. Any suggestions for a less verbose way of the parsePacket function?
18:40:28 <jackhill> cd .domtool
18:46:09 <tesan> Btw, I paid Udemy a few bucks to get some courses to learn Haskell programming... as I felt kind of lethargic about continuing to read in LYAH despite the author having a somewhat cheap yet existant sense of humor.  But the introduction course from Packt apparently is garbage as the instructor uses some features he forgot to explain!
18:46:59 <onethirtyfive> Hi all! I have three different enum definitions (from generated code) that look like this: https://gist.github.com/onethirtyfive/f6ddaf41c79dc56c10830802b6b86e7b. In my code, I get an integer corresponding to one type from the union of those enumerations. Is there some inbuilt way to combine these types into one, or an easy way to ask each enum if it has a type for a given integer and take the first one found? (Or can I define 
18:47:00 <onethirtyfive> f these idiomatically?)
18:47:01 <tesan> Does anyone else have experience with Udemy or knows where I could boost my Haskell learning speed without so much frustration?
18:48:16 <onethirtyfive> I'd happily accept "please google concept X" kinds of answers, too, if there's something basic I should learn about.
19:01:00 <np356> Elements of Programming
19:01:13 <np356> This is the book
19:02:20 <np356> when I was woeking at Apple, I made a workshop for like 150 cpp devs for 6 mnths. That workshop sparked the most wonderful debates I had in my career.
19:02:46 <tesan> Were they eager to learn FP?
19:03:51 <np356> tesan: I think that the path to FP is the following: Learn C/C++, learn Haskell, Learn C++ templates. Learn how to integrate them and when.
19:03:55 <np356> in this order
19:05:29 <np356> I mentored few devs already and this way of twisting their minds worked for both of us.
19:06:11 <np356> you need to become a fanatic of one approach, then become a fanatic of oner, and then make fun of fanatics.
19:06:21 <tesan> I only wrote some basic algorythms in Python so far... so I guess I should rather say that I have no idea of programming so far. Am I doing wrong to learn Hakell first?
19:08:02 <tesan> silence == "yes"
19:08:09 <tesan> True
19:08:12 <mac10688_> what's your goal tesan ?
19:08:16 <mac10688_> you looking for a career?
19:08:46 <tesan> Certainly.
19:08:47 <np356> ok, so here's my homework for you: Write a video streaming system for an interview homework: UI: web, Backend: Whatever. Metrics: Efficency (we optimize for the lowest $/h compute time), Storage (Also, costs), Long-term Good Design (Nothing is more expensive than shit devs).
19:09:33 <tesan> np356: You made me laugh with the last parentheses
19:09:35 <np356> €95k/yr in Berlin
19:09:41 <np356> hello@karimagha.de
19:10:01 <tesan> omg... that looks like a formidable income
19:10:04 <mac10688_> tesan, probably not a popular opinion here. But I think the haskell field is very narrow. I think it's a great language that deserves more but I don't think there are a lot of job opportunities right now. Haskell isn't an industry buzz word and will be looked over by a lot of recruiters
19:10:10 <np356> you can rent a descent place in Berlin for €500/m
19:10:18 <mac10688_> tesan, unless you know of a specific company hiring
19:11:27 <tesan> mac10688: I'll have to deal with IoT and the data I have to analyze. It looked like Haskell is very efficient at data analysis and other things... and as Haskell is not very popular amongst a big bunch of people, I thought it would be just the perfect tool to... "differentiate" if I am going to make some projects on my own.
19:12:12 <mac10688_> tesan, sounds like a legit use case and if you can sale yourself that's all that matters
19:12:38 <tesan> mac10688: Also seeing that even Facebook used Haskell in Sigma project, I highly assumed that many people who made fun of Haskell just don't know Haskell at all and are frightened of learning it... so I'd really enjoy to prove those people wrong and make something really nice with Haskell.
19:13:24 <mac10688_> yeah that's cool and you definitely can. But I was just answering from a very practical standpoint. I'm not sure what you said is all that practical.
19:14:57 <np356> tesan: dont listen do mac10688_!! do what you feel like.
19:14:58 <tesan> Well, at the University they will teach me a bunch of OOP languages for sure... so I just wanted to make sure that I know some Haskell before that happens so I won't fall into the "People know know OOP take longer to learn Haskell"
19:15:21 <mac10688_> if haskell is part of your tooling then definitely
19:15:22 <tesan> np356: That's the Haskeller spirit, isn't it?
19:15:32 <np356> When it comes to dev, you can't listen to anyone else than you. Because nobody else than you will be spending the 8h a day debugging and building shit.
19:15:45 <np356> if you like haskell... go for it.
19:15:54 <np356> Think about employability later.
19:16:14 * jmcarthur doesn't even think of OOP and FP as being at odds with each other. It's rather easy to encode most definitions of OOP using functional primitives.
19:16:17 <mac10688_> I disagree, but it sounds like haskell is just going to be a part of his tooling and I totally agree with that
19:16:32 <np356> If youre smart enough, by the time you're 21, you'll really know what it is like to be a hot redhead.
19:17:29 <tesan> By those means, I have 11 months to become that.
19:17:48 <mac10688_> I just think if you are looking to write beautiful code, learn haskell. If you need a job because you don't want to live off food stamps or in your Mom's basement it would bet a better bet to go with an industry standard language first
19:18:33 <mac10688_> because when I go on my interviews, no one cares about all the haskell I've been learning. They just care about their buzz words and the tech stack in their company
19:18:43 <sm> I got a php job from having haskell on my resume
19:18:54 <tesan> Really? How come?
19:19:26 <elpfen> honestly I think employers like to hear/see haskell on a resume (but never use it).
19:19:27 <mac10688_> well ok, that's just my perspective. It sounds like other people have different experiences than me
19:20:41 <elpfen> I'm still a student though, so it's probably just because it shows some kind of greater than average interest
19:21:01 <tesan> mac10688: Would C, Rust and Go be possible buzz words? I'll have like 4 years to learn coding before having to deal with an actual job. I will nee to attend to practices though.
19:21:46 <boj> tesan: honestly it's less about the language, and more about understanding software engineering. at least that is what i look for when i hire
19:21:47 <elpfen> tesan: where do you live? whatever you learn in university will more than likely be enough to get you a job
19:22:17 <boj> it's more useful to have built a crud app in some language than it is to know any specific language
19:22:38 <boj> obviously replace "crud" with whatever field you tend to aim for
19:23:21 <mac10688_> yeah what's your goal? What kind of work do you want? Are you willing to wait a few months after graduation? Are you an awesome student with good projects to showcase?
19:23:46 <boj> open source contributions are golden for showing passion and skills
19:23:50 <mac10688_> if you are just getting by, my advice is C# or java. If you are going above and beyond then I don't think it matters. especially because you'll be a junior
19:23:54 <XorSwap> @pl f a b c d = a (b c d)
19:23:55 <lambdabot> f = (.) . (.)
19:24:09 <mac10688_> one question though boj
19:24:31 <mac10688_> before you saw someone with haskell skills wouldn't you have to be contacted by a recruiter about that candidate?
19:24:53 <mac10688_> and would that recruiter be searching for the word haskell in their list of buzz words
19:25:05 <boj> we don't use recruiters, so it's typically people sending us apps directly
19:25:25 <mac10688_> you must work at a prestigious and good company then
19:25:26 <boj> for companies that do use recruiters, yeah, it's all a game at the end of the day
19:25:29 <np356> tesan: no, I live within 100m of the US enmbassy, I have the most luxurious address in Berlin for 1.2k
19:25:38 <boj> mac10688_: hah. not exactly
19:25:50 <np356> I had to pay 4k for a 2 bedroom shithole whithout a washing machine in SF.
19:25:59 <np356> and Berlin is just more fun.
19:26:06 <boj> mac10688_: not even a software shop (at least not yet). primarily a data center out of alaska :)
19:26:12 <mac10688_> boj, I still think we landed on agreement there. I wish more companies were like yours
19:26:32 <boj> mac10688_: there are a lot of companies out there like that
19:27:10 <tesan> I take interest in FOSS and would like to contribute it in the future. It represents my philosophy, so I will be very eager. My goals... well, I had some but now I'll just say "improve things". Possibilities should be limitless, for instance... Haskell could be used in a Traffic analysis service to possibly prevent accidents and what not?  I just don't want to end up stuck with repairing some dull old programs to work with the newer standards for some company 
19:27:12 <tesan> that is too stingy to just get the software anyone would use then.
19:27:12 <mac10688_> boj, well i'm only a 6 year dev. Sounds like I need more experience
19:27:18 <ipv6>  use flags got you down? cant figure out fdisk? Named your child after Richard Stallman or Linus Torvalds? areyou on irc from UBUNTU? If Gentoo has got you down take a break and chat with l0de live https://chaturbate.com/l0de/ PRAISE JESUS !
19:28:15 <boj> tesan: sadly, there's a good chance that is where you end up unless you apply for high risk startups
19:28:38 <elpfen> that is a very narrow view
19:28:48 <boj> yeah, that was a bad comment
19:28:50 <tesan> boj: Then I'll have to do that. I want my life to mean something, idc about the money-- just about the purpose.
19:28:57 <tesan> And maybe some recognition.
19:29:11 <mac10688_> tesan, in that case. Stick with haskell
19:29:15 <boj> tesan: there are a lot of great opportunities out there :)
19:29:26 <np356> mac10688_: then youre going to the wrong interviews.
19:29:35 <elpfen> This may be out of scope for this conversation, but your programming career does not have to be your purpose or meaning
19:29:42 <mac10688_> np356, teach me daddy?
19:32:28 <boj> p.s. we're hiring for another role if anyone thinks moving to Anchorage, AK is a good move :p
19:32:56 <mac10688_> boj, I would actually apply if I didn't just buy a house
19:33:18 <np356> tesan: Given that you're still a young and excited cookie, I think that you should start your computer science education by reading: https://www.amazon.com/Chaos-Monkeys-Obscene-Fortune-Failure/dp/0062458191
19:33:22 <mac10688_> I've always wanted to see Russia
19:33:35 <tesan> boj: Btw, what are your company's goals? Under which category does yours fall?
19:33:36 <np356> This is waaaaaaay more important than whatever you actually know.
19:34:53 <boj> tesan: kind of a weird story, but primarily we are a data center/MSP (do all the IT for various companies), however we support a decent sized telecom (our parent company), so between that and potential consulting there's a good bit of industry programming going on there
19:35:36 <mac10688_> lol np356 I love the first review I read for that book
19:36:04 <np356> just sayin'... :)
19:36:11 <elpfen> Know a guy who works at FB...this sounds pretty accurate
19:36:16 <tesan> np356: I am reading the description on the amazon site and bookmarked it... but my eyelids are a bit heavy after all the hours. The title suggests that it shows failures and what should not be done... but what does the book talk about?
19:36:23 <mac10688_> creepy corporate propoganda lol
19:36:59 <np356> I actually have some personal connections with some entities in that book ;-)
19:37:27 <np356> I rembmer having beer with my friend talking about his time somewhere over tequila :)
19:37:48 <mac10688_> lol it's like at my company when my manager calls us team but I work in a silo and have nothing to do with the other people on my team. They just like to use buzz feel good words
19:38:44 <elpfen> QQ: My proglang class will be using lisp for the FP section, how well does it relate to haskell?
19:39:05 <tesan> Lisp is being used nowadays?
19:39:29 <elpfen> Haha when i told my coworker he said "it's probably what he was using when he started teaching." I think that's the case.
19:39:32 <boj> tesan: clojure is still big i think
19:39:59 <boj> there's lisp for erlang, although it think elixir won the game there
19:40:01 <tesan> boj: But wasn't that a more recent language? It supposedly climbed the tiobe in the last months.
19:40:15 <boj> tesan: well, afaik it's just lisp bolted onto the jvm
19:40:34 <boj> so learning lisp alone would apply towards skills there
19:41:25 <tesan> boj: I see quite a bunch of languages being bolted onto the jvm... is there really a benefit from it or is it just some trend?
19:41:39 <elpfen> You get the benefits of the jvm :^)
19:41:41 <mac10688_> you get a lot of library support
19:41:46 <np356> actually, after some JD I revise my strategy:
19:41:49 <boj> i think people want the expressiveness of non-java languages, but the power of the billions of dollars invested into the jvm
19:42:05 <boj> and library support, as mac10688_ pointed out
19:42:49 <boj> the problem with jumping to new languages is their potential lack of an ecosystem
19:43:00 <np356> 1. learn C/C++, 2. Learn FP. 3. Learn CPP Templates 4. Learn "The way of the reighous man" and fucking grow up. 5. Teach some of what you know. 5. Go to step 1.
19:43:02 <boj> staying on the jvm means you can still pull in crazy dependencies
19:43:02 <tesan> Which requiers them to use ffi
19:43:30 * boj isn't suggesting using anything related to java, just pointing it out
19:43:48 * np356 thinks that java is for pussies.
19:44:02 <tesan> I have political reasons not to use Java ^^ [Oracle]. Can I live by avoiding Java?
19:44:05 <boj> np356: your language isn't terribly welcome in this channel
19:44:18 <mac10688_> scala works?
19:44:43 <elpfen> tesan: same. OpenJDK is pretty good though
19:44:55 <tesan> I wondered about that... but some on reddit complained about bad decisions and really long wait times on some schedules.
19:45:05 <np356> boj: I have noticed that since I moved from the US to EU. You amerikans need to grow some fucking thick skin if you want to have deeper connections with people.
19:45:17 <tesan> And I would reason about "Why else would even more FP languages built ontop of jvm come out if Scala was really good"
19:45:19 <mac10688_> tesan, people are always going to complain about any language.
19:45:23 <boj> np356: a mod asked you to tone it down earlier today
19:45:37 <boj> but sure, don't be respectful. up to you
19:46:27 <np356> boj, trust me I'm not trolling. I'm really just trying to have a conversation. I'm happy to create a private channel only for the people interested in this discussion.
19:46:31 <boj> tesan: i'm not sure everyone agrees scala is good ;)
19:46:43 <elpfen> On a similar note, what's the point of F#? If you're using .NET libraries which are stateful, doesn't that defeat the point?
19:46:57 <emilypi> . learn C/C++, 2. Learn FP. 3. Learn CPP Templates
19:46:58 <emilypi> LOL
19:47:00 <boj> elpfen: expressiveness?
19:47:13 <MarcelineVQ> luckily one exists if an off-topic convo needs a place to live #haskell-offtopic 
19:47:13 <emilypi> god, what is this, finance circa 2005?
19:47:17 <mac10688_> elpfen, it brings in ideas of immutable structures and function compisition
19:47:44 <tesan> I'd think that F# is a way of being happy with FP while still being demanded to use the .NET framework.
19:47:55 <boj> tesan: yep
19:48:17 <elpfen> Hmm, I can see that.
19:48:29 <np356> boj: its because of peple like you the US is having this natzi shit agina. because when I tried to even step a little bit out of your agenda you threatened to ban men.
19:48:50 <np356> Sure. Ban me from IRD, then I'll go to the street.
19:48:59 <np356> Convince me here, then I'll stay home.
19:48:59 --- mode: ChanServ set +o mauke
19:49:15 <MarcelineVQ> can you phrase that in a way that involves haskell the programming language?
19:49:15 <mauke> np356: you need to slow down
19:49:16 <np356> chmod is not a good weapon among civilized people.
19:49:31 <tesan> np356: Well, that is generalizing... honestly, I think you're deep in the danger zone here in the chat for mentioning "nazi" though...
19:49:45 <boj> or ad hominem attacks, heh
19:50:05 <tesan> I suggest dropping it here unless you'll move it to a private discussion with mac10688_
19:50:18 <mac10688_> what did I do?
19:50:32 <np356> well.. what's wrong in saying "pussy" that makes it warrant a channel-level warninig? WTF?!
19:50:36 <tesan> I thought he had the discussion with you, sorry if I wrote the wrong one
19:50:39 <erisco> we'll tell you down at the station mac10688_, in the car
19:50:54 <mac10688_> LOL!! erisco 
19:51:17 <mauke> np356: you didn't just say "pussy". you said "java is for pussies". you also said a lot of other things
19:52:07 <np356> yes,, java is for pussies. what is fucking offeinsive in it to warran a ban on the most popular haskell channel on the intenet?
19:52:17 <tesan> mac10688_: Yeah sorry... Sleep deprivation made me mistake your username for boj's for a moment.
19:52:22 <np356> and you are fucking surprised why you have trump?!
19:52:22 <boj> so, about that haskell
19:52:37 --- mode: mauke set +q *!*@ip5f5bf73c.dynamic.kabel-deutschland.de
19:52:44 <MarcelineVQ> there is a channel for crafting hills and soapboxes to stand and make stands on #haskell-offtopic 
19:52:55 <tesan> Is that np356?
19:53:00 <mauke> yes
19:53:00 <tesan> The german ip
19:53:19 <mac10688_> the IRC gods have spoken
19:53:21 <mauke> he's (temporarily) silenced
19:54:05 <mac10688_> I only go as far off topic as other fp languages. I actually care about not getting in trouble here. I get too much help
19:54:31 <boj> i think we were having a nice discussion helping tesan think about career choices
19:54:40 <mauke> I'd just like to clarify that this is an international (mostly) technical channel about Haskell
19:54:50 <tesan> Yeah, that's how it started anyway.
19:54:51 <mauke> it's not an American political stage
19:54:58 --- mode: mauke set -o mauke
19:57:05 <elpfen> How is haskell with ncurses? I've got a python terminal app i'm thinking of moving to haskell
19:57:18 <mac10688_> what's an ncurse?
19:57:24 <tesan> It's a terminal driver library.
19:57:41 <tesan> Remember those really old games for the terminal? Chances are they're using ncurses or something like it.
19:57:56 <elpfen> "Window" renderer for terminals.
19:58:11 <mac10688_> oh wow I didn't know about this
19:58:15 <mauke> elpfen: related: http://hackage.haskell.org/package/vty
19:58:24 <elpfen> YES
19:58:32 <tesan> Isn't there also hcurses?
19:58:34 <c_wraith> I thought brick was the current hot choice for terminal apps
19:58:38 <c_wraith> @hackage brick
19:58:38 <lambdabot> http://hackage.haskell.org/package/brick
19:59:05 <elpfen> I gave up trying to use https://hackage.haskell.org/package/ncurses for a minute
19:59:09 <tesan> :/  I wish they made it easier and just kept 1 ncurses-esque library that just does the job well in Haskell.
19:59:28 <mac10688_> tesan, choices are daunting. I agree
19:59:42 <c_wraith> tesan: that's kind of like wishing there was only one number type that just does the job well
20:00:48 <boj> tesan: i seem to use this way too much, but https://xkcd.com/927/
20:01:36 <c_wraith> I know the author of vty, vty-ui, and brick
20:01:53 <tesan> boj: Haha yeah, exactly...
20:03:41 <boj> maybe a better example are the haskell sql libraries. postgresql-simple, esqueleto, opalaye, tisch (built on opaleye) - each have different/opinionted ways of doing things
20:03:51 <boj> (there are a few more)
20:04:25 <boj> there was someone in here the other day happy with none of them, so is writing their own
20:04:32 <boj> nature of the beast
20:05:03 <mauke> "tisch" :-D
20:05:27 <boj> :D
20:06:09 <c_wraith> I want a production-quality version of goldfiere's dependent-haskell demo SQL library.
20:07:01 <erisco> go to a mall and say that on Santa's lap
20:07:18 <tesan> Ugh... I kind of get the feeling of "The straight line is the fastest way". And please no Brachistochrone curve joke.  Well... given that you have experience in the topic, could you please name me a newb-friendly sql [PostreSQL, maybe SQLite3 support please] and a tk/ui library?
20:07:31 <mac10688_> can someone explain to me the value of arrows? I went to a page dedicated to teaching it but I still didn't understand.
20:07:48 <tesan> Because overwhelming ammounts of packages to choose from to do "the same job" is highly intimidating.
20:08:00 <mac10688_> the only tidbit I got is if you are using a something as a Monad but it isn't quite a Monad, it's probably an arrow
20:08:09 <mac10688_> and I see that yampa library is built with arrows
20:08:41 <erisco> mac10688_, more or less it models a function language
20:09:19 <erisco> to that end, the lack of observable sharing is an issue
20:09:21 <mac10688_> I was looking for a general statement like that, bad thing is I don't know what you mean by function language
20:09:26 <mauke> mac10688_: I haven't seen arrows used much
20:09:36 <mauke> so I've pretty much ignored them
20:09:42 <erisco> mac10688_, a language where you use functions ;)
20:09:53 <mac10688_> hmm
20:10:01 <mac10688_> thinking about it now
20:10:22 <boj> tesan: not sure about noob friendly. my shop uses tisch. esqueleto looks and smells like sql, so may be more familiar. can't really help with tk/ui
20:11:22 * hackagebot ihaskell 0.9.0.0 – A Haskell backend kernel for the IPython project. – https://hackage.haskell.org/package/ihaskell
20:11:29 <erisco> so if you wanted to have a dsl within Haskell, you might implement it as an arrow
20:11:33 <xzhu_> hideclear
20:12:10 <mac10688_> erisco, thank you. As I look more into arrows I will try to fit your statements into it. That's enough for tonight, I just need to stew on that for a bit
20:12:13 <erisco> note there are other classes such as ArrowChoice which adds sum types
20:12:43 <boj> mac10688_: tisch uses arrows, apparently because it creates constraints on the SQL which can be satisfied at compile time
20:12:51 <erisco> ArrowLoop adds, unsurprisingly, loops
20:13:26 <erisco> you've probably seen pictures of flow graphs when reading about Arrow... it is a good visualisation
20:13:35 <mac10688_> yeah I saw the pictures
20:13:40 <mac10688_> still digesting them
20:16:49 <erisco> and if I am understanding correctly, ArrowApply makes it higher order
20:17:18 <erisco> i.e. now you can usefully have arrows of arrows
20:17:28 <boj> if edwardk was here he'd explain to you how Arrows are just Applicative + Profucntor (i get the impression "not worth learning")
20:18:11 <mac10688_> i would go with the not worth learning phase but it's all over the yampa library which I hear is gaining steam in frp realm. I really like frp
20:18:23 <mac10688_> phase = part
20:18:23 <boj> ah, yampa is fun
20:18:50 <tesan> What is yampa? [Just a short definition and without sending a link]
20:19:03 <Xandaros> frp library
20:19:06 <Xandaros> short enough? :P
20:19:09 <boj> Ivan has been pushing game-specific fixes to Yampa (even an iOS/Android deployment tool in the future)
20:19:18 <erisco> well, at least arrows give you ways to manipulate 2-tuples :P
20:19:23 <mac10688_> functional reactive programming = frp
20:19:56 <mac10688_> yeah and I'm a mobile dev. Yeah boj that's where I heard this news too and why I started looking into yampa
20:20:06 <boj> may help to note that Yampa uses Arrows, but Arrows aren't necessary for FRP
20:20:09 <tesan> Yeah, thanks. Now I remember.  And thanks mac10688_ , I guessed what he meant but I very appreciate your help
20:20:58 <boj> mac10688_: cool. if you reach out to him you may be able to get access to those tools. i poked him the other month, he's willing to chat
20:21:11 <Xandaros> So, Yampa is the new netwire?
20:21:21 <boj> actively maintained at least
20:21:27 <mac10688_> what happened to reactive-bannana?
20:21:48 <tesan> Unmaintained, isn't it?
20:22:02 <boj> i think it's seen some recent activity as well
20:22:20 <Xandaros> Last hackage push was over a year ago
20:22:50 <Xandaros> There's activity on the github, though
20:27:19 <boj> mac10688_: you may also want to look into Reflex. Cale has mentioned they have a branch that builds out to mobile
20:28:11 <boj> arguably the more prominent frp library right now due to the Reflex-Dom stuff
20:29:00 <erisco> so what are yampa's semantics?
20:29:52 <Myrl-saki> Omg what
20:29:55 <Myrl-saki> boj: Where?
20:30:15 <Myrl-saki> boj: I use Reflex all the time and I wanna make a mobile app.
20:30:32 <boj> Myrl-saki: i don't know the specific branch, just saw chat in here the other day about it
20:31:01 <erisco> it is possibly proprietary since it was developed at his work place, but maybe we'll get lucky
20:31:14 <Myrl-saki> Awww. :C
20:31:18 <Myrl-saki> Let's hope.
20:31:36 <erisco> iirc he talked about open sourcing their mobile compatibility stuff
20:32:15 <erisco> their UIs are done with the web browser, mind
20:32:59 <erisco> which I can't fault because the native UI libraries are gnarly and inconsistent
20:33:18 <erisco> and, frankly, poorly designed (now largely due to legacy no doubt)
20:33:32 <erisco> have you seen an Android Activity? worse than spiders
20:34:59 <erisco> it takes multiple 3rd party libraries just to make the bar at the top (where you might have a logo and a couple icons) work
20:42:57 <erisco> what is our state of the art for observable sharing?
20:44:18 * hackagebot ipython-kernel 0.9.0.0 – A library for creating kernels for IPython frontends – https://hackage.haskell.org/package/ipython-kernel
20:44:18 * hackagebot ghc-parser 0.2.0.0 – Haskell source parser from GHC. – https://hackage.haskell.org/package/ghc-parser
20:45:05 <erisco> is that Andy Gill 2009?
20:54:39 <Myrl-saki> erisco: Observable sharing?
20:54:55 <erisco> yeah, that thing that violates referential transparency
21:02:58 <erisco> why is it always called "the IO monad" and not just "IO"
21:03:21 <mac10688_> isn't IO taken by the datatype?
21:03:50 <erisco> IO is a data type, yes. not sure what you mean
21:04:09 <mac10688_> that was my best answer
21:04:17 <mac10688_> if that ain't good enough, I don't know what is ;)
21:04:32 <erisco> well it was a rhetorical question to begin with :P
21:04:43 <mac10688_> I was duped!
21:09:55 <geekosaur> actually I suspect it's a reminder "use (>>=)"
21:14:55 <slack1256> wow, I can use nix-shell on a #! script and use haskell without writing a cabal file
21:15:36 <erisco> you're a renegade
21:15:38 <geekosaur> you "just" have to write a nix derivation instead?
21:23:55 <dsal> @pl (\i -> x == pf i)
21:23:56 <lambdabot> (x ==) . pf
21:23:56 <slack1256> I got a template. I just change the packages
21:24:25 <slack1256> btw, how do I expand a type synonim on ghci?
21:24:48 <slack1256> err, type family, but a saturated call
21:25:24 <slack1256> nvm, :kind! works
21:26:35 <erisco> dsal, that is close to Data.Function.On. What is x?
21:27:24 <dsal> I think Vector String
21:27:33 <dsal> pf plucks a field out of it.
21:27:37 <erisco> not the type, the term
21:28:19 <dsal> The entire function is      dropDup pf (x:xs) = x:(dropDup pf $ dropWhile (((pf x) ==) . pf) xs)
21:28:22 <erisco> if x = pf y for some y then on (==) pf
21:28:30 <dsal> So you could imagine pf == id 
21:28:33 <erisco> on
21:29:51 <erisco> (pf x ==) . pf = on (==) pf x
21:30:10 <dsal> Hmm....
21:30:18 <dsal> I'm in the process of making this testable, so I'll see that in a sec.  :)
21:31:48 <erisco> if you also state your base case then this could be an easy fold
21:32:36 <dsal> Well, my test still passes, but I don't quite understand what I've done.
21:33:41 <erisco> oh, this is nubBy
21:34:07 <dsal> I'm not sure that's true.
21:34:19 <erisco> :t nubBy . on (==)
21:34:21 <lambdabot> Eq a => (a1 -> a) -> [a1] -> [a1]
21:34:26 <dsal> But I'm not sure my test would validate that.
21:35:03 <erisco> > (nubBy . on (==)) (`mod` 2) [1..10]
21:35:05 <lambdabot>  [1,2]
21:35:56 <erisco> you're right, it is not nubBy, now that I look again, because of dropWhile's behaviour
21:36:24 <erisco> nubBy does a global filter but dropWhile is only going to filter up to the first mismatch
21:37:49 <erisco> :t \f -> foldr (\x a -> x : dropWhile (on (==) f x) a) []
21:37:51 <lambdabot> (Eq a, Foldable t) => (a1 -> a) -> t a1 -> [a1]
21:37:59 <erisco> > (\f -> foldr (\x a -> x : dropWhile (on (==) f x) a) []) (`mod` 2) [1..10]
21:38:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:38:11 <dsal> nodups_notuniq = assertEqual "can has dup" (dropDup id [1, 1, 2, 1, 1, 3]) [1, 2, 1, 3]
21:38:20 <erisco> well that is an unexciting example, heh
21:43:02 <erisco> I would change the function
21:43:43 <erisco> :t \f -> foldr (\x a -> x : dropWhile (f x)) []
21:43:45 <lambdabot> error:
21:43:45 <lambdabot>     • Couldn't match expected type ‘[t1]’ with actual type ‘[a] -> [a]’
21:43:45 <lambdabot>     • Probable cause: ‘dropWhile’ is applied to too few arguments
21:43:51 <erisco> :t \f -> foldr (\x a -> x : dropWhile (f x) a) []
21:43:53 <lambdabot> Foldable t => (t1 -> t1 -> Bool) -> t t1 -> [t1]
21:47:11 <erisco> > (\f -> foldr (\x a -> x : dropWhile (f x) a) []) (\x y -> y < x*x) [1..10]
21:47:14 <lambdabot>  [1,2]
21:48:03 <dmwit> What is the spec for the function we're trying to write?
21:48:31 <dmwit> :t groupBy
21:48:33 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:48:56 <dmwit> > (groupBy . on (==)) (`mod` 2) [1..10]
21:48:58 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
21:49:04 <dmwit> ok ok
21:49:09 <dmwit> > (map head . groupBy . on (==)) (`mod` 2) [1..10]
21:49:12 <lambdabot>  error:
21:49:12 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
21:49:12 <lambdabot>                    with actual type ‘[b0]’
21:49:21 <erisco> dsal, also, the way you want to write tests is by property, not test cases
21:49:44 <dmwit> > map head (groupBy (on (==) (`mod` 2)) [1..10])
21:49:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:49:54 <dsal> Well, I have a property test, but it doesn't guarantee that there's a case where there are still duplicates.
21:49:59 <dsal> So I added that one.
21:50:00 <erisco> if you do it by property then you do not need to know any answers! you only need to know how to synthesize values for the type of input
21:50:13 <erisco> well then you're missing a property perhaps ;)
21:50:20 <dsal> Can I express "can have a duplicate" as a property?
21:50:41 <erisco> absolutely
21:50:55 <erisco> how do you determine if a list has a duplicate in it?
21:51:19 <dsal> Are you referring to quickcheck?
21:51:25 <erisco> no
21:51:37 <dsal> OK.  I might not get the whole idea of property tests, then.
21:52:04 <dmj`> :t \xs -> length xs /= length (nub xs)
21:52:05 <lambdabot> Eq a => [a] -> Bool
21:52:27 <dmwit> dmj`: Probably faster to skip the `length`s.
21:52:34 <dsal> Yeah, that's what I was thinking for the property, but for the test?  Do you still give it manual test cases?
21:52:38 <dmj`> dmwit: fair
21:53:16 <dmwit> I don't think "MAY have a duplicate" is a sensible property. What list does *not* have that property/
21:53:27 <dmwit> -property/ +property?
21:53:53 <erisco> well, instead of forall you have exists
21:54:48 <erisco> and ∃x.P(x) ≡ ¬∀x.¬P(x)
21:54:53 <dmwit> I feel very lost. Perhaps I should not be trying to contribute to this discussion -- there appears to be too much missing context.
21:55:41 <erisco> I don't know anything about quickcheck, but the outer negation has to be handled by it
21:56:00 <erisco> it has to understand everything is okay so long as one test fails
21:56:10 <slack1256> @where lpaste
21:56:10 <lambdabot> http://lpaste.net/
21:57:29 <erisco> or if it directly understands exists then it is okay if just one passes
21:57:57 <erisco> it seems a bit unusual to have such a thing as a property you are relying upon, though
21:58:24 <slack1256> http://lpaste.net/357801 can anybody help me? I don understand why the `n` variable doesn't unifies with the type Int
21:58:36 <slack1256> on the definition of natsum
21:58:57 <erisco> dsal, out of curiosity, why do you care if the list can have a duplicate?
21:59:24 <dsal> Because you mentioned nub, and that solves a different problem.  :)
21:59:31 <erisco> is it adequate merely having the absence of a uniqueness property instead?
21:59:38 <dmwit> slack1256: Because you explicitly said `alg :: NatF t -> Int`, that is, `alg` must be able to work on `NatF`s containing any type.
21:59:54 <dmwit> slack1256: Perhaps you wanted `alg :: NatF Int -> Int`?
22:00:23 <slack1256> I wanted ghc to yell at my that my `t` is not arbitrary, that it must be an Int
22:00:36 <erisco> dsal, does it? you should be able to state the problem you are solving just in terms of foralls (in likelihood)
22:01:33 <erisco> dmwit, I see what you are doing... now if only groupBy returned [NonEmpty a]
22:01:34 <dmwit> slack1256: But you didn't use `n` at all, so of course it's arbitrary.
22:02:12 <slack1256> dmwit: but the `t` type is constrained by the unification on cata
22:02:53 <dmwit> slack1256: Yep. The type of `alg` must be at least as general as the type `NatF Int -> Int`, and it is. So no problem worth reporting on there.
22:03:21 <erisco> dsal, if your only reason for this duplication test is to exclude solutions such as nubBy then you certainly do not have enough properties to sufficiently describe what you are implementing
22:03:27 <slack1256> Oh
22:03:42 <slack1256> you're right
22:03:56 <erisco> blacklisting possibilities is not really a tenable way to define something
22:04:13 <dsal> erisco: Kind of?  I don't want to accidentally delete the same entry if it's later down the list.
22:04:31 <slack1256> thank you dmwit
22:04:45 <erisco> ah, see, now that sounds like a forall, and it shows your exists variation is too weak
22:04:59 <dsal> I don't know forall.
22:05:11 <erisco> by merely requiring at least one list to have duplicates that leaves the door open to all sorts of wrong implementations
22:05:32 <erisco> dsal, you know logic, yes?
22:05:49 <dsal> I've like, heard of it.  heh
22:05:59 <dmwit> dsal: Perhaps you want to test that `foo (a ++ [b] ++ c ++ [b]) == foo (a ++ [b] ++ c) ++ [b]` whenever `c` has a value not equal to `b`.
22:06:33 <dmwit> Or something like that.
22:06:40 <dmwit> Actually that exact one probably isn't quite right.
22:07:02 <dmwit> Hm. It is tricky to say what the right property is. =)
22:07:06 <erisco> dsal, okay, there are two quantifiers to know about... and a quantifier introduces a variable
22:07:29 <dmwit> (Assuming what you are trying to implement is `groupBy`, of course.)
22:07:30 <erisco> dsal, there is forall x, i.e. ∀x, and exists x, i.e. ∃x
22:07:59 <erisco> dsal, ∀x.P(x) means that "for all choices of x, P(x) is true" and ∃x.P(x) means that "for at least one choice of x, P(x) is true"
22:08:24 <dmwit> Perhaps `foo (a ++ [b,c] ++ d) == foo (a ++ [b]) ++ foo ([c] ++ d)` whenever `b /= c`.
22:09:17 <erisco> dsal, which is why ∃x.P(x) is the same as ¬∀x.¬P(x) because "for not all choices of x is P(x) not true" is the same as "there is at least one x such that P(x) is true"
22:10:15 <erisco> dsal, so, connecting with Haskell and your tests here, ∀ corresponds to \, i.e. λ i.e. lambda
22:10:24 <dsal> Yeah.  I did the forward test with quickcheck (along with a couple manual tests).  I'm not sure how to ask something like quickcheck to validate a property that there might exist a list with some duplicates with other items between.
22:10:56 <erisco> dsal, when you write  \x -> \y -> x < y * y  you are saying "for all x, for all y, x is strictly less than y * y"
22:11:14 <erisco> dsal, and here we also know what x and y range over by their type
22:11:34 <dmwit> ?check let foo = map head . group in \a b c -> foo (a ++ [b,b+1] ++ c) == foo (a ++ [b]) ++ foo ([b+1] ++ c)
22:11:37 <lambdabot>  +++ OK, passed 100 tests.
22:12:01 <erisco> dsal, so that is how you can connect your tests here with logic
22:12:03 <dmwit> ?check let foo = nub in \a b c -> foo (a ++ [b,b+1] ++ c) == foo (a ++ [b]) ++ foo ([b+1] ++ c)
22:12:06 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 5 shrinks):
22:12:06 <lambdabot>  [-3,0,-3,0] -1 [3,0]
22:12:37 <dmwit> dsal: There is a quickcheck property that distinguishes between group and nub, in case you care.
22:13:24 <erisco> dsal, the thing quickcheck does is take your proposition (your function) and tests if it is true for all cases it chooses
22:14:12 <dsal> Yeah, that doesn't fit a "and sometimes this can be true, but it isn't required" case.
22:14:12 <erisco> if so then it says it is true universally (unsoundly)
22:14:51 <erisco> well, quickcheck would need a different judgement other than "is true for all cases tried"
22:15:24 <dmwit> dsal: Your "don't throw away later stuff" property was much better, in my opinion. "You're allowed to do X" doesn't rule out any buggy implementations. Only "you're not allowed to do X".
22:15:42 <dmwit> dsal: (And the property I wrote above is intended to reflect the "don't throw away later stuff" property.)
22:16:33 <erisco> it needs "is true for at least one case tried"
22:16:57 <dmwit> erisco: That's "you MUST do X on at least on input", which is a very different property.
22:17:10 <erisco> or "is not true for all cases tried"
22:17:31 <erisco> dmwit, different from what?
22:18:42 <dmwit> Moving from "You're allowed to do X" to "You must do X at least once" is a big change, and may not reflect what's wanted. (I absolutely also recognize that moving from "You're allowed to do X" to "You're not allowed to do Y" is also a big change.)
22:19:17 <erisco> dmwit, but "you're allowed to do X" is unfalsifiable, so what is the point
22:19:22 <dmwit> I guess "...is a different property" is not my real objection.
22:19:46 <dmwit> My real objection is that I don't think your "you must have duplicates for at least one input" is not the property dsal cares about. =)
22:19:54 <dmwit> ugh
22:20:13 <dmwit> s/is not/is/
22:20:13 <erisco> it isn't, I am just explaining the logical connection and what quickcheck would need to support an existential quantifier
22:20:27 <erisco> I haven't used it but it probably only has forall
22:20:56 <erisco> which is fine, that is probably all you need, and it is janky to hope random test cases find the special case for an exists
22:22:31 * dmwit tries to think of a "good" exists-based property
22:26:09 <dysfun> while you can't test specifically for that, on average, you'll get plenty of repetition with enough runs
22:26:31 <dysfun> so your tests will likely fail if it misbehaves even though you aren't testing precisely that
22:27:46 <erisco> dmwit, ∃x. f x = 0
22:27:54 <nshepperd> usually you can 'test' an exists-property by naming the satisfying value, can you not?
22:29:11 <erisco> you can just have it as a test case, sure
22:29:53 <erisco> that is if the value is to be constant ... and I am not sure in what circumstance it wouldn't be
22:30:11 <koz_> I'm playing with Control.Comonad stuff and NonEmpty in GHCI, but I get a very odd error: http://lpaste.net/357802
22:30:19 <koz_> Could someone fill me on on why this is doing that?
22:30:26 <erisco> because if it weren't then ultimately you're saying that somewhere in your program you are relying on the existence of a zero, but you don't know where it is
22:30:45 <dmwit> erisco: Okay. That's a pretty convincing example, though I had to invent some backstory to convince myself. =)
22:31:04 <nshepperd> instead of 'forall x. exists y. f x y', 'forall x. f x (the_y x)'
22:31:23 <dmwit> erisco: e.g. "this function has zero derivative somewhere" would be a pretty good property for a program that tries to do some optimization.
22:31:55 <nshepperd> right, and for the cases where the location of the zero is hard to calculate, probably random testing is unlikely to find it anyway
22:31:59 <dmwit> (And you wouldn't want to have to find the zero for the test to pass, as you really only care that it exists -- if later you pick another function, you shouldn't have to update the test.)
22:32:11 <dmwit> I also agree that quickcheck is not the right tool for this. =)
22:36:40 <nshepperd> although! you can also prove the existence of a zero by (assuming continuity) observing 'exists x y. f x <= 0 <= f y'
22:36:46 <dsal> So what's the preferred method for writing a test for this case?  I like my currently seemingly correct one.  :)   nodups_notuniq = assertEqual "can has dup" (dropDup id [1, 1, 2, 1, 1, 3]) [1, 2, 1, 3]
22:36:55 <nshepperd> if you can't be bothered writing the program to find the zero :p
22:38:36 <erisco> nshepperd, smart!
22:38:53 <erisco> good old mean-value theorem
22:41:17 <erisco> dsal, well you have to let your creative juices flow. dmwit offered a suggestion earlier
22:41:54 <dsal> Sure, but is that generally better than just demonstrating a concrete case?
22:42:35 <erisco> yes, if you can afford the time to figure it out
22:43:01 <erisco> ideally you would start with these properties already so you know what it is you are implementing
22:43:18 <erisco> but some things can be intuitive but difficult to figure out how to say formally
22:43:37 <dsal> I'm not accustomed to saying anything formally.  :)
22:44:02 <dsal> I'm trying to get some form down here.  Learning how to do teesting and what-not.
22:44:48 <koz_> I'm playing with Control.Comonad stuff and NonEmpty in GHCI, but I get a very odd error: http://lpaste.net/357802 <-- can anyone advise me what's up with this?
22:45:06 <erisco> dsal, the difference can be seen as thus... for a given input output pair I can merely define the function which maps that input to that output
22:45:15 <nshepperd> dsal: here's another good property you can test: dropDup id x = dropDup id (dropDup id x)
22:46:08 <erisco> dsal, whereas with a property that is not sufficient because the function will be tested on many inputs
22:46:16 <nshepperd> removing duplicates twice should be the same as removing duplicates once!
22:46:53 <dsal> nshepperd: Hmm...  Yes.  I guess I could see how I might get that wrong.  I wouldn't think to care about that, though.
22:47:00 <erisco> dsal, and the difference between a bunch of input/output pairs and a property is that you can effortlessly add inputs to test a property
22:47:11 <erisco> dsal, and you can randomise them
22:47:37 <erisco> and by "effortlessly" I suppose I mean "automatically"
22:47:57 <dsal> erisco: Sure, I think I get the property concept at a high level.  It just seems insufficient.
22:48:40 <erisco> it requires you to think carefully about the relationship between input and output
22:48:59 <erisco> for example, how would you describe a comparison sort?
22:49:00 <dsal> What is this  "where types ..." thing, btw?
22:50:18 <erisco> dsal, what nshepperd showed you is called idempotency
22:51:12 <nshepperd> idempotency is a good property. one of my favourites
22:51:21 <erisco> whenever you can identify a common property it is probably helpful to include it in the tests, unless you really don't mean it (i.e. it holds for the particular implementation but you don't expect it generally)
22:52:09 <erisco> the idempotency of boolean logic is crucial to computers :)
22:52:19 <dsal> yeah, that makes sense.
22:56:28 * Eduard_Munteanu . o O (can we call P omnipotent if P -> _|_?)
22:58:58 <pacak> :t absurd
22:59:00 <lambdabot> Void -> a
22:59:11 * pacak pokes lambdabot
22:59:46 <mac10688_> lol what's with the absurd function?
23:00:30 <erisco> if you have a Void you pass it to absurd and that concludes your proof of 'a'
23:00:36 <pacak> Eduard_Munteanu: P is False (in a logical sense, not Bool) as in ex falso quodlibet.
23:00:36 <Eduard_Munteanu> mac10688_, https://en.wikipedia.org/wiki/Principle_of_explosion
23:01:03 <pacak> Bottom mess things up a bit in Haskell...
23:01:22 <pacak> This make it less useful on theorem proving even with dependent types.
23:01:27 <Eduard_Munteanu> I meant false/Void by _|_.
23:01:58 <nshepperd> by analogy with 'idempotent' and 'nilpotent', I imagine an 'omnipotent' P would be such that (P, P·P, P·P·P, ...) would contain all… automorphisms or something
23:02:22 <mac10688_> lol Eduard_Munteanu I've never heard of this concept before. Thanks for the enlightenment
23:05:16 <nshepperd> dsal: if you can define a function 'nodups' that checks whether a function has duplicates, you can also express the probably important property that 'nodups f (dropDup f xs)' is True
23:05:16 <pacak> Eduard_Munteanu: Can P be anything other than False/Void/Bottom?
23:05:41 <dsal> nshepperd: Yes, I did that for my testing.
23:05:43 <nshepperd> which means just: if you remove duplicates from a list, the result better not have duplicates!
23:05:55 <mac10688_> is this kind of info really useful in every day programming or is this just theoretical fun?
23:05:57 <dsal> quickCheck liked that.
23:06:21 <Eduard_Munteanu> pacak, P is a false proposition. This implies void, which implies anything. Hence omnipotent. :)
23:06:53 <pacak> So it's False.
23:07:22 <Eduard_Munteanu> pacak, well, one of many different false propositions.
23:09:45 <erisco> mac10688_, that depends on what your everyday is, but yes it is applicable to programming
23:10:49 <mac10688_> what's a real use case for it, in non set theory terms?
23:12:01 <Eduard_Munteanu> mac10688_, you can use 'absurd' to prune out cases with false premises from a proof
23:12:01 <mac10688_> oh nvm
23:12:04 <mac10688_> oh
23:12:30 <mac10688_> I also found a stack overflow post asking the same thing
23:12:31 <mac10688_> gonna read it
23:13:16 <erisco> though GHC is also good at recognising impossible cases
23:13:30 <Eduard_Munteanu> mac10688_, for example, if you need to prove 'n > 0 -> P' and you have 'n = 0', you deduce falsehood from that, and invoke 'absurd' on it to get a P.
23:13:32 <mac10688_> https://stackoverflow.com/questions/14131856/whats-the-absurd-function-in-data-void-useful-for
23:14:10 <Eduard_Munteanu> Basically, it converts a contradiction to whatever you need in that place.
23:14:22 <mac10688_> ok
23:14:31 <mac10688_> I thought that's what Either's or Maybes were for
23:14:36 <mac10688_> guess this is a level deeper
23:14:56 <pacak> Suppose you have a function that returns Either x a where a is something specific like Int and x - is something that you know you'll never get.
23:15:16 <pacak> And function you have returns Either x a (or Either x Int)
23:15:41 <pacak> If you applying case expression on this result - you'll need to handle both cases.
23:15:57 <pacak> If you know that x is impossible you can change it to Either Void a
23:16:14 <pacak> and on case foo { Left v -> absurd v ; Right v -> .... }
23:16:25 <mac10688_> oh ok that's pretty concrete
23:16:36 <pacak> this way it will typecheck, if you change your function - typechecker will poke you
23:16:37 <pacak> etc, etc.
23:16:44 <mac10688_> so I guess it's the most robust you can get. You aren't even interested in handling it
23:16:47 <mac10688_> you just want to move on
23:16:56 <dsal> Is absurd related to 'amb' from "teach yourself scheme in fixnum days" ?
23:17:13 <erisco> is that the ambiguous choice operator?
23:17:18 <dsal> yeah
23:17:22 <erisco> no
23:17:39 <pacak> You know that it's not noing to be there right now, but you don't want to plop stuff like Left _ -> error "Impossibru!" because after some refactors things might  be different.
23:18:24 <pacak> It's a type safe way of handling  impossible scenarios.
23:18:26 <erisco> ambiguous choice is when you have two ways to compute the same thing, say f g, then amb f g is equivalent to f and g but intensionally it runs both simultaneously and gives you the first result
23:18:31 <mac10688_> that's a really good example pacak I really thought this was higher dimensional theory. Now it's really concrete for me
23:18:42 <erisco> and there is some nice way to explain this all with a lattice, or some such
23:18:57 <erisco> I think conal has material on it
23:19:08 <erisco> if he wasn't the one to actually come up with it
23:20:07 <erisco> oh, I am thinking of unamb, I am not sure if that is different, heh :P
23:20:26 <pacak> come up with - unlikely. At most repurposed from math.
23:20:42 <dsal> amb runs whichever path isn't bottom, basically.
23:21:15 <pacak> :t either absurd id
23:21:17 <lambdabot> Either Void c -> c
23:21:28 <dsal> (amb (/ 5 0) (/ 5 1))  => 5
23:21:29 * pacak pokes lambdabot
23:21:32 <erisco> yes and unamb is the same, so I don't know if it is different or not
23:22:26 <erisco> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice
23:22:35 <pacak> Either - is a sum type, Either a b is a + b, Void is zero, 0 + a = a, Either Void a is a. Isn't it cute?
23:22:40 <Eduard_Munteanu> Also think about how you'd implement absurd nicely.
23:22:56 <pacak> @src absurd
23:22:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:23:37 <Eduard_Munteanu> Well, in Haskell you can't do much, but in Agda or other languages they provide an abxurd pattern just so you can claim a type to be empty when there are no cases to handle.
23:24:04 <Eduard_Munteanu> absurd ()     -- note there's no equals and righthand
23:24:05 <erisco> dsal, but at any rate, it is unrelated to absurd. Bottom is not really something you want in these logical analogies
23:24:24 <erisco> :t undefined :: Void -- because of this
23:24:26 <lambdabot> Void
23:24:42 <pacak> absurd a = a `seq` spin a where    spin (Void b) = spin b
23:24:55 <erisco> hence Haskell is inconsistent... but we pretend it isn't at times ;)
23:25:06 <pacak> Where newtype Void = Void Void
23:25:13 <glguy> Generally we just don't pretend that it's a logic
23:26:52 <erisco> is there something else which is similar but agrees with bottom?
23:27:45 <erisco> lattices, but I don't know a lot about them so I am not sure what you can leverage with one
23:27:54 <mac10688_> interesting
23:27:56 <mac10688_> :t absurd
23:27:58 <lambdabot> Void -> a
23:28:08 <mac10688_> if a doesn't inherit from memoid
23:28:13 <mac10688_> how does it know what a should be?
23:28:31 <Eduard_Munteanu> mac10688_, it can be any 'a'
23:28:33 <mac10688_> how does it know the default value, or mempty
23:28:51 <Eduard_Munteanu> :t undefined
23:28:53 <lambdabot> a
23:29:04 <mac10688_> so it will return undefined?
23:29:05 <nshepperd_> http://www.randomhacks.net/2005/10/11/amb-operator/ what the heck
23:29:19 <Eduard_Munteanu> mac10688_, or some error, in Haskell, probably
23:29:20 <pacak> mac10688_: It won't return anything since you can't pass it Void.
23:29:32 <mac10688_> ohhh
23:29:39 <Xandaros> erisco: Shhh, undefined is an illusion. There is no such thing
23:29:39 <mac10688_> so this is just to appease the type checker
23:29:51 <pacak> But you can pretend that it would return if you could.
23:29:52 <Eduard_Munteanu> This is all about type checking.
23:30:05 <mac10688_> ok I'm back in the game again
23:30:20 <mac10688_> but seems like you could always return undefined
23:30:29 <mac10688_> unless absurd came before undefined was introduced
23:30:38 <erisco> :t absurd = \case {} :: Void -> a   -- this is another implementation
23:30:40 <lambdabot> error:
23:30:40 <lambdabot>     parse error on input ‘=’
23:30:40 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
23:30:44 <Eduard_Munteanu> You could, but absurd is there so you can pretend undefined doesn't exist.
23:30:56 <erisco> :t let absurd = \case {} :: Void -> a in absurd   -- this is another implementation
23:30:58 <lambdabot> Void -> a
23:31:15 <pacak> Void respects algebra of datatypes, undefined does not.
23:31:25 <Xandaros> TIL lambdabot supports LambdaCase
23:31:26 <erisco> we do not require undefined to define absurd
23:31:38 <erisco> we instead use the "no cases of Void" to define absurd
23:31:57 <Xandaros> It's not really hard to define undefined in any case. "undefined = undefined"
23:32:21 <Xandaros> "define undefined". I didn't even realise... lol
23:32:42 <erisco> :t let x = x in x
23:32:43 <lambdabot> t
23:32:47 <erisco> this is why we can't trust anything
23:32:47 <Eduard_Munteanu> Well, that would kinda suck... it would spin if you ever gave it a value instead of erroring out
23:33:22 <erisco> so you have to put your fingers in your ears and sing "lalala" to believe anything about a Haskell program
23:33:36 <mac10688_> yeah I think I would prefer to just throw a descriptive error and be explicit about something like that
23:33:39 <Eduard_Munteanu> I think even case expressions result in a default case with undefined in there somewher.
23:33:55 <Xandaros> Well, the definition of bottom is more or less "does not return". Whether it aborts due to an exception and blows up everything (assuming you don't cheat with IO) or it just loops forever doesn't really matter
23:34:19 <erisco> Eduard_Munteanu, well when I read the "unofficial semantics" that is semantically absurd x = case x of ⊥ -> ⊥
23:34:51 <Eduard_Munteanu> > let absurd = \case {} :: Void -> a in absurd (let x = x in x)
23:34:57 <lambdabot>  mueval-core: Time limit exceeded
23:35:05 <Xandaros> Honestly, though, I just pretend undefined doesn't exist. And I'm doing pretty well with that
23:35:22 <nshepperd_> absurd x = unsafeCoerce x
23:35:35 <erisco> Eduard_Munteanu, you were seeing if the strictness agreed? :)
23:36:20 <Eduard_Munteanu> I was trying to ascertain what it returns if given an input.
23:36:31 <mac10688_> :t error
23:36:33 <lambdabot> [Char] -> a
23:36:53 <mac10688_> yeah, I would prefer a nice descriptive error over absurd
23:37:00 <Xandaros> > absurd undefined
23:37:02 <lambdabot>  *Exception: Prelude.undefined
23:37:03 <Eduard_Munteanu> It seems consistent with what nshepperd_ saidd.
23:38:03 * hackagebot pretty-compact 3.0 – Pretty-printing library – https://hackage.haskell.org/package/pretty-compact
23:38:12 <erisco> that seems... bold
23:38:20 <Eduard_Munteanu> > absurd (error "this is what you gave me")
23:38:23 <lambdabot>  *Exception: this is what you gave me
23:38:49 <mac10688_> > error "this is what you gave me"
23:38:51 <lambdabot>  *Exception: this is what you gave me
23:39:21 <erisco> that definition is saying we're completely confident in the type system and implementation thereof
23:39:27 <mac10688_> > absurd "this is what you gave me"
23:39:30 <lambdabot>  error:
23:39:30 <lambdabot>      • Couldn't match expected type ‘Void’ with actual type ‘[Char]’
23:39:30 <lambdabot>      • In the first argument of ‘absurd’, namely
23:39:31 <nshepperd_> It could just be const undefined, but it's a better user experience if you get the original error
23:39:43 <erisco> it isn't, because it is strict on the argument
23:40:10 <Eduard_Munteanu> Is it?
23:40:34 <erisco> > let absurd = const undefined in absurd (error "this is what you gave me")
23:40:35 <Eduard_Munteanu> You need some (strict / non-irrefutable) pattern to be strict.
23:40:37 <lambdabot>  *Exception: Prelude.undefined
23:40:55 <nshepperd_> I know it's not const undefined
23:41:00 <nshepperd_> But it could be
23:41:57 <nshepperd_> The reason it is not, is because getting the original error message would normally be more useful than a generic undefined
23:42:24 <erisco> I would say it is strict because that is what makes sense
23:42:57 <erisco> and if we look in the library, it is indeed written with EmptyCase
23:43:00 <Eduard_Munteanu> Because you have a case expression?
23:43:26 <erisco> no, because the point of absurd is not that bottom is in the language
23:43:32 <erisco> the point of absurd is that there are no cases of Void
23:43:37 <erisco> you can define absurd in a language without bottom
23:43:42 <nshepperd_> It's "strict" either way in the sense that absurd ⊥ = ⊥
23:44:23 <erisco> no, because the value is not bottom... never mind
23:44:46 <nshepperd_> heh, how do you think EmptyCase is implemented
23:44:48 <erisco> we're conflating the fact Haskell has bottom (which gives us more options of how to define this) and the logical meaning of absurd
23:47:47 <erisco> nshepperd, I don't actually know but I will take a look at the docs
23:48:24 <erisco> it shouldn't actually have to return undefined because the only inhabitant of the empty type (which EmptyCase applies to) is bottom
23:49:47 <erisco> semantically I expect it to be case x of ⊥ → ⊥ but what actually happens is our program aborts or hangs on the pattern match
23:50:31 <erisco> because that is the effect of evaluating bottom
23:50:32 <Xandaros> Let's just pretend bottom is not a thing and that calling absurd is absurd.
23:52:21 * nshepperd checks in ghci
23:52:40 <nshepperd> yup, (absurd (unsafeCoerce (3 :: Int)) :: Int) = 3
23:52:44 <nshepperd> :D
23:54:13 <nshepperd> the reason ghc can do absurd x = x, basically is because there are no cases, so it can only be bottom, and all bottoms are the same
23:54:15 <Xandaros> Oh god why
23:54:51 <erisco> it at least has to be  absurd x = x `seq` x
23:55:08 <nshepperd> eh? seq x x is the same as x
23:55:14 <Eduard_Munteanu> x `seq` x never works.
23:55:34 <erisco> nshepperd, hm, yeah, lol
23:56:28 <Eduard_Munteanu> Now that's a weird assumption.
23:57:16 <erisco> I don't know how to find the docs for EmptyCase other than in the user manual (which says nothing about implementation)
23:57:30 <erisco> presumably there is a feature request or something on the bug tracker but I don't see it
23:58:06 <erisco> nshepperd, I suppose seq is idempotent, then ;)
23:59:05 <erisco> so 'case x of' is simply desugared to 'x', heh, well that's interesting
23:59:34 <erisco> and then \case {} is presumably desugared to \x -> x
23:59:56 <erisco> nshepperd, but you need an unsafeCoerce as well?
