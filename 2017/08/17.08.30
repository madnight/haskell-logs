00:00:47 <boomshroom> cocreature: Hmm... I'm currently translating code from Rust and it was pretty ugly. I'm trying to make the Haskell version less ugly, but I don't think that will happen.
00:00:47 <wogi> cocreature I just found https://github.com/Gabriel439/post-rfc/blob/master/sotu.md this is what I was looking for :-D
00:01:29 <Cale> wogi: Where I work, we use Haskell to build web and mobile applications, and we use it both for the backend (compiled to native x64 code), and for the web frontend (compiled to Javascript), and for the mobile frontend (compiled to ARM)
00:01:32 <cocreature> boomshroom: if you want suggestions on how to make it less ugly, you’ll need to give us more information :)
00:02:02 <Cale> wogi: (and in fact 99% of the code for mobile and web frontends can be shared that way, which is pretty nice)
00:02:07 <boomshroom> cocreature: Storing a CHIP-8 program as something more useful than a stream of bytes.
00:02:17 <wogi> Cale Sounds interesting. I am trying to get into it a little right now, my last real functional programming experience was a few years ago with scheme. haskell feels so different than any of the usual stuff I do. 
00:02:35 <cocreature> boomshroom: that still doesn’t tell me anything about how your current code looks and what makes you consider it to be ugly
00:03:16 <mbrock> we use Haskell for making developer tools for Ethereum, including an interactive terminal debugger for its virtual machine
00:03:22 <Cale> wogi: Yeah, back when I started learning it in 2001-2002 or so, it took me a couple months before I really felt like I could do useful things with it, and about a year to be comfortable.
00:04:09 <boomshroom> When writing my Elm emulator, I just skipped the middleman and interpretted the raw bytes. Currently, I have an Op enum that should hold a value for each instruction including each combination of arguments for each instruction.
00:05:37 <boomshroom> The rust version includes peusdo registers in the same enum as regular ones and has separate enums for the Opcode and Argument patterns.
00:08:27 <boomshroom> Is there a data type for nybbles?
00:08:38 <boomshroom> ie: range 0 to 15
00:09:33 <Axman6> not that I'm aware of, but a newtype over Word8 wouldn't be too hard to make
00:09:53 <mbrock> wogi: I'm no historian, but I think Haskell was growing slowly and steadily for a long time, and a while ago people in the mainstream started realizing (1) that functional programming is neat and (2) that GHC is a capable compiler with a good runtime
00:10:27 <remexre> Is there a way to derive Read such that e.g. "foo" => Foo (rather than "Foo" => Foo and "foo" => error) ?
00:12:26 <boomshroom> The only reason I could think of for why I prefer Rust over Haskell is memory management. I love that there's no background garbage collector waiting to strike when I'm not looking.
00:19:43 <zomg> remexre: it can be done with a custom instance at least but usually Read and Show are meant to map one to one and if you need parsing from some other format you should use something else
00:20:01 <remexre> Eh, I'm just trying to parse a CLI arg into Foo|Bar|Baz
00:20:10 <remexre> With optparse-applicative
00:20:25 <remexre> and https://hackage.haskell.org/package/optparse-applicative-0.14.0.0/docs/Options-Applicative.html#v:auto seemed like the right way
00:21:17 <cocreature> remexre: write your own parser and use `eitherReader` or `maybeReader`
00:21:44 <remexre> cocreature: Okay, the pattern match isn't hard, I just hoped there was a "free" way
00:21:51 <remexre> zomg, cocreature: thanks!
00:24:44 <boomshroom> How do I convert between 2 differently sized integers?
00:24:44 <boj> Cale: is your guys mobile frontend branch public?
00:25:09 <boomshroom> (aka, destruct a word into 4 nybbles)
00:27:37 <remexre> Continuing on my goal of not having to update strings whenever I change data structures, is there a way to get the different "branches" of a data as a [String]?
00:30:26 <mud> remexre: The constructor names or something?
00:30:32 <remexre> Yeah
00:30:54 <mud> You should be able to do that via deriving Generic. Or maybe Data? One of those
00:32:03 <boomshroom> One thing that was bothering me when reading about the various integer types is that Real is defined by toRational which requires "full precision." Does that mean that pi, a "real" number can't implement the Real typeclass?
00:32:49 <remexre> mud: okay, I'm looking at Data now (Generic's docs were scarier)
00:32:52 <cocreature> remexre: generics, Data.Data or template haskell but as long as you don’t have too many places that you need to change I probably wouldn’t bother.
00:33:11 <ertes-w> lo
00:35:26 <ertes-w> i have no context whatsoever, but Generic being scarier than Data?  that sounds very suspicious =)
00:35:35 <mud> boomshroom: Yeah, Real is pretty weird honestly.
00:35:54 <cocreature> ertes-w: if all you want is a list of constructor names, Generics is scarier than Data.Data
00:36:03 <remexre> ertes-w: The docs are, at least? Or at least unintuitive to me with little sleep
00:36:11 <ertes-w> ah, that might be true indeed
00:36:22 <remexre> cocreature: Yeah, but I'm scared I'll forget to update the two/three places
00:36:27 <ertes-w> remexre: it helps to be familiar with data types a la carte
00:36:49 <ertes-w> remexre: i.e. constructing types from a base set of primitives
00:37:07 <remexre> ertes-w: Like, algebraic data types?
00:37:18 <remexre> Or should I just read http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
00:37:25 <cocreature> depending on how familiar you are with fancy Haskell typelevel machinery, generics-sop might also be worth a look and is in some sense more intuitive than GHC.Generics
00:37:26 <ertes-w> remexre: specifically sum types in this case
00:37:48 <ertes-w> remexre: (:+:) is Either on steroids
00:37:55 <mbrock> boomshroom: there's for example the `exact-real' package that gives `Real' instances for arbitrary but finite precision chosen at compile time, e.g. `CReal 256' is accurate to within 2^-256 
00:38:33 <ertes-w> remexre: well, just go with Data *and* read the paper when you have some spare time…  it pays off in many ways
00:38:52 <remexre> ertes-w: So (:+:) <-> Either as tuples <-> the basic 2-item product type?
00:38:57 <mbrock> (or something like that, sorry if my math is inaccurate)
00:39:18 <ertes-w> remexre: (:*:) <-> tuples
00:39:33 <ertes-w> but (:+:) is relevant, if you want a list of constructor names
00:40:00 <remexre> okay, thanks!
00:40:55 <dminuoso> So Kind is to Types, what Types are to values?
00:41:40 <ertes-w> remexre: here is a high-level overview of Generic: it provides a way to translate back and forth between your concrete data type and an algebraic composition of a bunch of base types that also include meta information (like constructor names) on the type level
00:42:26 <ertes-w> remexre: so you write your generic functions for that generic composition, and to apply them to your concrete data types, you translate into the generic type, apply, then translate back
00:43:13 <jle`> best way to interpret the first four bytes of a ByteString as a Word32 ?
00:43:33 <ertes-w> jle`: use the 'binary' package
00:43:37 <remexre> ertes-w: Okay, I think that makes sense. The actual docs are just a bit less readable than I'd've hoped they'd be
00:43:45 * remexre shrugs
00:43:47 <jle`> is that the instance for Word32 ?
00:44:18 <jle`> ohlooks like it is
00:44:20 <jle`> neat :)
00:44:22 <jle`> thanks!
00:44:36 <ertes-w> jle`: you should use an explicit Get though, because you may want to be explicit about the byte order
00:44:47 <jle`> how do I do that?
00:44:57 <jle`> runGet ?
00:45:07 <jle`> ah i see
00:45:19 <ertes-w> jle`: or the awkwardly named runGetOrFail
00:45:40 <jle`> runGet getWords32be, or whatever endian
00:45:50 <ertes-w> yeah
00:46:01 <jle`> useful library :)
00:48:01 <mbrock> hey, is there a way for me as a channel maintainer to provide my users with an overlay that's accessible if someone just adds my channel? right now I'm maintaining a fork of nixpkgs instead which is kind of tedious
00:48:57 <mbrock> uhh, sorry, wrong channel. that's a question about Nix!
00:49:35 <mbrock> sometimes I think Nix and Haskell are one big project of purity and goodness
00:50:35 * hackagebot json-stream 0.4.1.4 – Incremental applicative JSON parser – https://hackage.haskell.org/package/json-stream
01:05:58 <boomshroom> It seems as though you can't mix how many arguments to match on. I wanted to be able to match on the first few and then return a function to consume the rest, but other branches match on all the arguments.
01:08:07 <boj> boomshroom: can you show an example?
01:08:14 <cocreature> boj: yep that’s correct
01:08:18 <cocreature> eh ^ boomshroom 
01:08:30 <boomshroom> parseNybbles 0 0 0xE 0 = CLS
01:08:37 <boomshroom> parseNybbles 1 = JP . buildAddr
01:08:44 <cocreature> boomshroom: use a lambda + case on the rhs of `=`
01:08:48 <cocreature> or LambdaCase
01:08:50 <boj> ah
01:13:40 <boomshroom> I searched for lambda case and not I'm sad I don't have a unicode keyboard. (I found a list of syntax extensions and boy are there a lot of supported unicode characters for various functions)
01:14:06 <Cale> You don't need unicode for lambda-case
01:14:16 <kuribas> what's a unicode keyboard?
01:14:19 <cocreature> text editors often have a way to enter easily enter unicode characters if you really want to :)
01:14:23 * kuribas didn't know that exists
01:14:24 <boomshroom> Cale: I figured, but the unicode extensions look so cool
01:14:42 <boomshroom> I just got sidetracked
01:15:01 <cocreature> what even is the unicode variant of LambdaCase?
01:15:53 <kuribas> https://wiki.theory.org/index.php/YourLanguageSucks#Haskell_sucks_because
01:15:54 <boomshroom> I don't know, but I got a list of syntax extensions by searching LambdaCase and unicode was on the page that came up before LambdaCase
01:16:10 <cocreature> ah right but that’s a separate extension
01:16:54 <kuribas> "Which extensions are enabled isn't obvious when you're reading a file." => Just look at the file header?
01:17:09 <cocreature> kuribas: default-extensions
01:17:43 <kuribas> cocreature: hm, I suppose I don't use them.
01:17:53 <Cale> Using Agda for a little while should straighten anyone out if they think unicode syntax is really nice. Every time I mess around with Agda, my hands start to ache from the unnatural typing.
01:18:26 <kuribas> it's nice to look at, not type :)
01:18:48 <xzhu> Which FRP packages are worth looking at as of now?
01:19:07 <kuribas> xzhu: reactive-banana
01:19:16 <mbrock> if Agda could just find all those pesky terms automatically so you didn't have to type anything but types...
01:20:03 <ertes-w> "Hierarchical modules are really just flat modules with dots in their names."
01:20:05 <ertes-w> sad but true
01:20:08 <xzhu> kuribas: Does the work banana stand for something?
01:20:11 <kuribas> xzhu: the others I don't know...
01:20:12 <xzhu> *word
01:20:27 <cocreature> xzhu: reflex is also quite popular these days
01:20:32 <ertes-w> xzhu: reactive-banana and reflex
01:20:37 <kuribas> xzhu: well, there was a FRP package with fruit...
01:21:00 * mbrock started to learn Reflex recently and is happy about it
01:21:07 <kuribas> xzhu: this one: https://wiki.haskell.org/WxFruit  Perhaps it's a play of words with that...
01:21:29 <Cale> xzhu: I highly recommend https://github.com/reflex-frp/reflex-platform
01:22:13 <mbrock> there's also the #reflex-frp channel
01:22:29 <xzhu> Does anyone know the current status of GHCJS? Years back I heard that it was slow and big in size
01:22:31 <ertes-w> xzhu: i'd gravitate towards reflex, but it's a bit more difficult to learn due, because it does some type-level magic, but has a good reason for doing it…  reactive-banana is great, if you want a simple package that is still flexible
01:22:42 <ertes-w> s/ due//
01:24:05 <kuribas> I found my numerical code 1000 times slower in ghcjs
01:24:29 <Cale> You can clone that repo, and run the ./try-reflex script in it, and it'll download and install the appropriate GHC and GHCJS and all the relevant dependencies and such. So at least it's easy to get going.
01:24:45 <xzhu> I looked into PureScript and Elm, and disliked both
01:24:47 <ertes-w> kuribas: how much slower is the equivalent JS code?  i suspect that the true difference factor is much smaller
01:25:08 <Cale> It does require a bunch of disk space, and well, the compilation times depend on how large your project is. Compiling with GHCJS is definitely slower than compiling with GHC, but not by a whole lot.
01:25:11 <ertes-w> xzhu: what are you going to use it for?
01:25:12 <boj> Cale: is your guys mobile frontend branch public?
01:25:13 <kuribas> ertes-w: well, I don't have equivalent JS code, but maybe a factor of 10?
01:25:32 <ertes-w> kuribas: may still be a factor of 100, depending on the JS engine
01:25:58 <boomshroom> Is it possible to compose a function with a case?
01:26:23 <xzhu> ertes-w: I guess just for front-end development in general. For something as small as TodoList or as large as Gmail
01:26:24 <Cale> boj: Some of that stuff is public. There's a mobile branch of reflex-platform which has some of the iOS stuff in it already. There's stuff under way to open source all our mobile support.
01:26:57 <boj> Cale: ok cool, look forward to it. we're hoping to use it by beginning of next year. imagine it will be stable by then?
01:27:17 <ertes-w> xzhu: web or native?
01:27:21 <kuribas> boomshroom: what do you mean?
01:27:35 <xzhu> ertes-w: Mostly web.
01:27:54 <ertes-w> xzhu: then reflex is pretty much your only option anyway =)
01:27:55 <Cale> Most stuff compiled with GHCJS is only a factor of about 4 to 10 slower than the GHC-compiled native code in my experience.
01:27:56 <xzhu> ertes-w: By native you mean mobile-native?
01:28:10 <ertes-w> xzhu: no, native, as in using a toolkit library like GTK+
01:28:29 <boomshroom> kribas: LambdaCase lets you wrap a case in a lambda. I was to compose f . g where f is the case
01:28:31 <ertes-w> xzhu: i guess mobile-native would count as that, too
01:29:05 <ertes-w> xzhu: there are some AFRP options as well, but i strongly recommend not going into those, unless you have a good reason
01:29:25 <boomshroom> I really should get to bed soon.
01:30:19 <Cale> boj: Yeah. We've already been using it a bunch in our client projects, it's just a matter of packaging it neatly and making sure it's all presentable, and that any of our internal dependencies are also in shape for being open sourced. :)
01:30:24 <xzhu> ertes-w: Thx. I'm going to look at Reflex. I'm just worrying about the viability of the performace of GHCJS in general (comparing to something like clojurescript maybe)
01:30:56 <Cale> xzhu: Most of your performance hit is relative to running native code is just from the fact that you're running JS in an interpreter.
01:31:56 <ertes-w> xzhu: well, this may help you: there is at least one company that is using GHCJS in production with great success, as far as i can tell as an outsider =)
01:32:20 <ertes-w> GHCJS + reflex that is
01:32:58 <boj> we're writing a complete billing system for a telecom with it, hopefully add our name to that list beginning of next year
01:33:23 <boj> and if Cale and team pull off the mobile stuff, wrap it up in mobile
01:34:01 * boj crosses fingers
01:34:13 * ertes-w should try mobile development in haskell
01:34:54 <Cale> ertes-w: There's more than one :)
01:35:36 <boj> Ivan from Yampa has a lot of (closed for now) mobile dev tooling going on as well
01:35:46 <ertes-w> Cale: cool, although personally i'm glad that i only need native GHC for my work =)
01:36:05 <xzhu> ertes-w: May I have the name of the company? :)
01:36:34 <Cale> xzhu: Well, the company I work for, Obsidian Systems, is responsible for Reflex and Reflex-DOM.
01:36:53 <Cale> xzhu: and we use it in production for various client projects
01:38:00 <xzhu> Cale: Wow that's good to know. I have dabbled with http://reactivex.io/. Is Reflex completely different or similar?
01:38:32 <Cale> xzhu: It attacks the same problem space
01:38:50 <Cale> and there are superficial similarities
01:39:45 <ertes-w> xzhu: [query] we use haskell together with nix for container-related tasks
01:40:08 <xzhu> Cale: If you don't mind I would like some elaboration
01:40:51 <xzhu> What is different between ReactiveX and Reflex?
01:40:52 <Cale> In Reflex (and proper FRP generally), there are (at least) two fundamental types you're working with:
01:42:01 <Cale> You have things which occur at particular points in time, and when they occur, have a value of some type a, we call those events, and they're values of type Event t a (we can ignore the t parameter for now, it specifies the implementation of reflex)
01:42:43 <Cale> and then you have things which at any moment in time you care to observe them, will always have a value, we call such things behaviours, and they're values of type Behavior t a
01:43:15 <Cale> and then there are a bunch of operations which take Event and Behavior values and combine them somehow to produce further Events or Behaviors
01:44:02 <Cale> For example,  attach :: Behavior t a -> Event t b -> Event t (a,b)
01:44:17 <ertes-w> here is a nice mental model (it's not fully accurate):  type Event a = (Time, [(DTime, a)]);  type Behaviour = (Time ->)
01:44:39 <ertes-w> where Event has a reference point and then a list of "occurrences" with deltas from that reference point
01:45:03 <Cale> takes a behaviour and an event, and produces an Event which occurs at the same moments in time when the input event occurs, but whose value is augmented with the value of the behaviour at those moments
01:45:48 <Cale> You also have:  hold :: (MonadHold m) => a -> Event t a -> m (Behavior t a)
01:45:59 <ertes-w> (2, [(3, 'a'), (1, 'b'), (2, 'c')]) :: Event Char  -- this represents an event that occurs three times: once at 2 + 3 = 5, once at 5 + 1 = 6, once at 6 + 2 = 8, with payloads 'a', 'b' and 'c' respectively
01:46:02 <Cale> which takes an initial value of type a, and an Event of values of type a
01:46:19 <xzhu> Cale: Wait .. as you said `t` does not stand for time does it?
01:46:44 <xzhu> Cale: then where is time in `Event t a`?
01:46:47 <ertes-w> xzhu: pretend that 't' doesn't exist
01:46:54 <Cale> xzhu: If you like, you can think of it as a type level representation for the timeline, but it's really a way of selecting the implementation of the interface these things belong to
01:47:14 <Cale> xzhu: Time is implicit, and it's not specified what times actually are
01:47:55 <xzhu> Is `Event` fired by a source?
01:48:46 <dminuoso> Mmm, so when I see a type such as (Functor f) => f a it implies that Functor is of kind * -> * right?
01:48:47 <Cale> An Event is a representation for something which can occur at zero or more points in time (at most once at any particular moment), and which at those times, will have a value.
01:49:10 <Cale> e.g. the sequence of keystrokes, or mouse clicks
01:49:16 <Cale> the sequence of attacks made by a monster
01:49:26 <Cale> the sequence of audio clips which ought to be played
01:49:40 <Cale> the sequence of requests to make to a network server
01:49:49 <Cale> the sequence of replies you get back from it
01:50:19 <xzhu> Cale: This is I think I understand .. just like events fired in JavaScript isn't it?
01:50:29 <Cale> Almost but not quite
01:50:48 <Cale> In Javascript, you can tell which order the handlers run in -- events are never really simultaneous
01:51:21 <Cale> In Reflex, different Events may occur at the same moment in time
01:51:43 <ventonegro> dminuoso: The Functor typeclass already implies that
01:52:00 <Cale> and it is impossible to tell that one is occurring before the other then -- all the consequences of their firing will take place simultaneously
01:52:14 <dminuoso> ventonegro, Im trying to fully understand the concept of kinds
01:52:28 <Cale> (even if internally, those consequences are being computed in one order or another)
01:52:29 <ertes-w> xzhu: there are two parts to a reflex application: the IO-bound host/controller and the pure application…  from the controller's perspective, events are kind of like handles that you indeed "fire" (via the fireEventsAndRead API), but that is invisible to the pure side
01:52:34 <dminuoso> Can I explicitly declare a kind for a type?
01:52:48 <tdammers> dminuoso: yes, with -XKindSignatures
01:53:26 <ertes-w> xzhu: from the pure side's perspective events are just values that represent the whole time line with certain points marked as occurrences (together with payloads for each)
01:54:51 <ventonegro> dminuoso: Kinds are the types of types, but in plain Haskell they are very simple: They only care about arity
01:54:54 <ertes-w> xzhu: in other words: operationally events are triggered, but semantically they just "are"
01:55:07 <Cale> xzhu: So for example, in Reflex-DOM, when you create a button, it gives you an Event t () as the result, which represents all the future clicks on that button. You can then pass that Event around and work with it to determine other values in the application.
01:55:16 <ventonegro> dminuoso: *, * -> *, * -> * -> * etc.
01:56:14 <dminuoso> tdammers, huh. That is interesting.
01:56:18 <Cale> xzhu: On the other side of things, we have lots of examples of things which are behaviours:
01:56:28 <Cale> The current contents of a text box
01:56:37 <Cale> The current hitpoints of the player in a game
01:56:44 <Cale> The current location of the mouse
01:56:45 <xzhu> How about an example? How would you do "alert 'Hi!' when double click a button, but only alert three times maximumly"?
01:57:05 <xzhu> Just pseudo-code would be enough
01:58:07 <ertes-w> xzhu: type Application = forall m t. (MonadHold t m, Reflex t) => Event t () -> m (Event t Text)
01:58:20 <ertes-w> xzhu: runApp :: Application -> IO ()
01:58:32 <Cale> Well, to do a Javascript alert box, you presently have to escape reflex-dom a bit. You'd use performEvent, which lets you queue IO actions to be performed when an Event occurs (not so different from attaching a standard event handler then)
01:58:36 <ertes-w> xzhu: runApp would be the link between the button and alerter and the pure application
01:59:04 <xzhu> Cale: I mean you can replace alert with, say, print to stdout
01:59:07 <Cale> It might be a little more interesting to just put the messages in the DOM
01:59:25 <xzhu> Cale: That'll work too if it's easier
01:59:36 <zomg> (please don't use alert() if you have other options, it's ugly and usually has poor UI)
02:00:31 <xzhu> zomg: No no ... lol, I was just saying for the simplicity sake. I don't care what form the output is in
02:00:58 <zomg> yeah just wanted to mention it in just in case :) as someone who works on web apps a lot, I see way too many ones with poor UI/UX
02:02:22 * ertes-w could link a small pure-reflex (i.e. non-reflex-dom) example, but feels ignored anyway, so won't =)
02:02:45 <xzhu> Back to the question, first, how do you express double click (defined by two clicks separated by no more than 0.5 seconds)?
02:03:02 <xzhu> ertes-w: No I have been waiting for you to finish :))
02:03:58 <ertes-w> xzhu: ah, well, that was pretty much it =)
02:04:54 <boj> ertes-w: i was waiting too. that was anti-climatic :p
02:05:35 <boj> xzhu: i don't think you are going to get a 1 liner type answer here
02:06:20 <xzhu> I am hoping something like `consume (print "Hi!") . take 3 . filter ((== 2) . length) . groupWithin (Second 0.5) $ event`
02:07:16 <xzhu> That would have been cool ..
02:07:22 <boj> agreed
02:07:27 * ertes-w is trying to find the example
02:07:42 <ertes-w> xzhu: note that time is not first-class
02:07:45 <boj> i spent all my thinking points today, so no answer from me
02:08:30 <ertes-w> if you want to have actual time in your system, you need the controller to provide it in a suitable form (like a behaviour that holds the current time, or an event that ticks at regular intervals)
02:09:07 <ertes-w> the application can't just pull a (Behaviour t Time) out of thin air, even though the mental model i provided earlier would technically allow it
02:09:39 <Cale> xzhu: Here's something of that sort http://cale.hn.org/Demos/xzhu.jsexe/
02:10:15 <Cale> xzhu: Let's make it a little more interesting...
02:12:34 <ertes-w> and here is a pure-reflex one with real time: http://lpaste.net/159333
02:12:56 <ertes-w> it doesn't quite do the same thing, but it should get the idea across
02:13:25 <ertes-w> myApp is the actual application that takes the tick event and turns it into a behaviour that is the "current output string"
02:13:30 <ertes-w> runMyApp is the controller
02:14:02 <Cale> http://cale.hn.org/Demos/xzhu.jsexe/ -- now it takes the "Hello!" bit from the contents of a textbox
02:15:16 <Cale> So here, we have value greetingBox :: Dynamic t Text  which gives us both the current value and the update event to the value of the input field as a Dynamic, which is effectively a combination of an Event and a Behavior
02:15:39 <Cale> and then  current (value greetingBox) :: Behavior t Text  will be just the current value
02:15:53 <Cale> and then tag :: Behavior t a -> Event t b -> Event t a
02:16:09 <ertes-w> BTW, using FRP makes you really pedantic about the concept of "now" =)
02:16:14 <Cale> will make an Event which fires at the same times as the given one, but with the value of the given Behavior as its value
02:16:53 <Cale> and  foldDyn  then takes that Event, and folds its values through time :)
02:17:05 <Cale> It produces for us a Dynamic t [Text]
02:17:08 <Cale> (in this case)
02:17:22 <Cale> which starts out as the given initial value []
02:17:43 <xzhu> Cale: What's this Dynamic?
02:17:51 <xzhu> it that a new concept?
02:17:56 <Cale> Dynamic is like a combination of Behavior and Event
02:18:36 <Cale> Given some  d :: Dynamic t a, we have  current d :: Behavior t a, which is the current value of the thing
02:18:45 <Cale> and  updated d :: Event t a  which tells us when the thing updates
02:18:54 <Cale> (and which value it is changing to)
02:19:30 <Cale> an important semantic distinction is that while conceptually a Behavior might be changing continuously, a Dynamic can only change at discrete moments, because the Event has to occur each time it changes
02:20:11 <Cale> (In Reflex at present, there's unfortunately no way to create a Behavior which changes continuously, but the possibility is intentionally left open)
02:21:14 <Cale> Dynamic tends to show up a lot in Reflex-DOM in place of Behavior simply because of the way that the DOM API works
02:21:15 <xzhu> BTW how come Reflex is not available on stackage?
02:21:52 <Cale> Because none of us happen to use stack -- I think some people have managed to get it working with stack though.
02:22:08 <Cale> We all use nix to build stuff.
02:22:29 <AndChat181649> hello?
02:22:34 <Cale> Hello
02:22:36 <ongy> Hi
02:22:42 <xzhu> Huh? I though nix is an OS?
02:22:55 <xzhu> *thought
02:22:55 <ongy> there's the nix package manager used by nixOS
02:22:56 <Cale> xzhu: It's a package manager and build system. NixOS is the OS built on it.
02:24:03 <Cale> xzhu: But given the annoyance of getting GHCJS and all the various Webkit-related dependencies and such all just so, nix is really nice in this space.
02:24:31 <Cale> xzhu: It's nice to be able to have the package manager handling not only the Haskell dependencies of your code, but the system dependencies.
02:24:43 <AndChat181649> I agree. Also, a lot of GNU/Linux distro's are bloated as fuck.
02:24:49 <dibblego> Our team uses nix+cabal. We have some blog posts on it. https://qfpl.io/posts/nix/introducing-nix/ https://qfpl.io/posts/nix/getting-started-with-nix/
02:25:40 <AndChat181649> Seems good.
02:26:17 <AndChat181649> I've used Arch for a long time.
02:26:22 <xzhu> How does nix solve the dependency problem? Does it use snapshots as well?
02:26:24 <AndChat181649> What are your opinions on it?
02:26:36 <xzhu> I am using Arch also lol
02:26:42 <AndChat181649> Nice.
02:27:00 <Cale> xzhu: It's like stack in that it hashes the result of everything, but it extends that to everything, not just Haskell packages.
02:27:24 <Cale> xzhu: and there are binary caches
02:27:39 <Cale> (so you don't actually have to compile it all yourself, hopefully!)
02:28:43 <xzhu> dibblego: Wait .. why is cabal needed when you have nix?
02:29:06 <Athas> Doesn't Nix solve most/all of the problems with Cabal?
02:29:20 <Cale> xzhu: You still use cabal for cabal build
02:29:20 <Athas> The impression I get is that most of the people who prefer cabal are on Nix.
02:29:22 <opqdonut> you can still use cabal as a build system under nix
02:29:24 <cocreature> nix is terrible at incremental rebuilds
02:29:31 <Cale> xzhu: You just don't use it for cabal install
02:29:51 <cocreature> generally you use cabal for development but get the dependencies via nix
02:29:53 <Cale> cocreature: I hope we can eventually do something about that.
02:30:08 <cocreature> Cale: the people at awakesecurity seemed to work on that
02:30:32 <tdammers> hmm, is there a generalized version of zipWith that works across different container types?
02:30:42 <dibblego> tdammers: liftA2
02:30:55 <tdammers> dibblego: that doesn't do *quite* what I want
02:31:05 <tdammers> > liftA2 (+) [1,2,3] [4,5,6]
02:31:07 <lambdabot>  [5,6,7,6,7,8,7,8,9]
02:31:08 <dibblego> https://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Functor-Zip.html
02:31:20 <cocreature> > liftA2 (+) (ZipList [1,2,3]) (ZipList [4,5,6])
02:31:22 <lambdabot>  ZipList {getZipList = [5,7,9]}
02:31:25 <tdammers> right
02:32:22 <tdammers> hmm, but then ZipList doesn't generalize to other containers either
02:32:44 <Cale> xzhu: anyway, here's another little demo program I wrote http://cale.hn.org/Demos/PrismataUnits/PrismataUnits.hs
02:32:50 <cocreature> tdammers: what should zipWith do for arbitrary containers
02:33:06 <tdammers> well, not *that* arbitrary
02:33:09 <cocreature> if there is a reasonable implementation of zipWith for your container you can probably make a newtype like ZipList
02:33:10 <Cale> xzhu: It accesses a web api for a strategy game that I like, and provides a searchable list of units from that game
02:33:16 <Cale> http://cale.hn.org/Demos/PrismataUnits/PrismataUnits.jsexe/
02:33:23 <Cale> ^^ the running version
02:33:50 <cocreature> tdammers: specifically what property do you expect your "zipWith" implementation to have that can’t be satisfied by an applicative instance for the containers you’re interested in
02:33:50 <Cale> (Images may take a moment to load, I didn't bother doing anything fancy to ensure they were loaded)
02:34:25 <cocreature> tdammers: https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html#t:Align might also be worth a look if you don’t want the “throw away elements missing in the other container”-behavior of zipWith
02:34:26 <tdammers> cocreature: what I want to express is "this is a component-wise operation on vector-like operands"
02:34:46 <tdammers> the throwing away is a lesser concern right now
02:35:11 <cocreature> tdammers: but does your code actually rely on that behavior? what happens if you just accept Applicative and leave it up to the instance to decide what exactly happens?
02:35:21 <tdammers> cocreature: then it does the wrong thing for lists
02:35:31 <cocreature> well that’s what ZipList is for :)
02:36:04 <tdammers> then the burden is on the caller
02:36:05 <Cale> xzhu: http://cale.hn.org/Demos/Audio/Audio.jsexe/ -- here's a demo showing the implementation of a very simple audio player widget with a clickable progress bar (no dragging though... I should make that work)
02:38:58 <xzhu> Cale: Found a bug in your audio app lol ... click play -> click stop -> click anywhere in the scroll bar -> click play : music won't play
02:39:15 <Cale> xzhu: oh, that's interesting :)
02:39:52 <Cale> ah, the <audio> element doesn't like its time being set to NaN :)
02:40:33 <Cale> Or something
02:40:55 <Cale> "Failed to set the 'currentTime' property on 'HTMLMediaElement': The provided double value is non-finite."
02:42:48 <xzhu> Can't help but a feel little concerned that the entire app just "gave up" when a small bug like this happened ...
02:43:31 <Cale> Well, it's just the underlying <audio> element being unhappy with the position we're telling it to seek to.
02:43:56 <Cale> I should probably handle that better :P
02:44:34 <xzhu> Cale: No I'm okay that this it fails to perform one operation, but how come I simply cannot do anything else after that?
02:45:29 <xzhu> Did the runtime just quit? That would have been bad ...
02:46:33 <Flonk> "The provided double value is non-finite." that sounds pretty stoic.
02:48:02 <Flonk> Especially since js doesn't have doubles
02:48:12 <Flonk> But maybe it's just a value that's doubly non-finite
02:50:16 * hackagebot conduit-algorithms 0.0.3.0 – Conduit-based algorithms – https://hackage.haskell.org/package/conduit-algorithms
02:51:11 <Cale> Flonk: Yeah, it might be an error from the DOM binding that I'm using
03:20:44 <WinterFox[m]> What is the reason for many variables in haskell being named xs?
03:21:13 <barrucadu> "xs" is typically a list
03:21:35 <Cale> WinterFox[m]: That's the plural of x
03:21:44 <barrucadu> eg, "map f xs = ..." <- all we know about "xs" is that it's a list, so there is no more meaningful name
03:21:51 <WinterFox[m]> Cale: Ah
03:22:37 <Athas> It can also aid readability if you are strict about the convention that elements of 'xs' are bound as 'x'.  It generalises to xss, xsss, etc.
03:28:34 <kuribas> isn't xs a convention from prolog?
03:29:26 <Cale> perhaps
03:29:32 <Athas> It certainly also exists there, but it might be even older.  Can't remember if I ever saw it in 70s LISP.
03:32:30 <Myrl-saki> Is it possible to have Compose as a type family?
03:32:36 <Myrl-saki> Something something
03:32:44 <Myrl-saki> type instance Compose f g x = f (g x)
03:33:54 <cocreature> Myrl-saki: you can make a type family but then you can’t make instances for it
03:34:47 <Myrl-saki> cocreature: Oh, no wonder :(
03:34:54 <Myrl-saki> cocreature: How about a typeclass?
03:35:16 <cocreature> Myrl-saki: not sure how you want to replace a newtype by a typeclass
03:36:30 <Myrl-saki> Mmm wait.
03:36:48 <Iceland_jack> You can make give it a polykinded return type in the latest GHC..
03:36:57 <Myrl-saki> class Compose f g a x | f, g -> h; instance Compose f g (f (g x)) x
03:37:00 <Myrl-saki> Is that possible lol?
03:37:03 <Myrl-saki> f, g -> a
03:37:19 <Myrl-saki> I'm not so sure how to do multiple fundeps.
03:37:29 <Iceland_jack> newtype instance Compose f g a = Comopse (f (g a))
03:37:30 <Iceland_jack> newtype instance Compose f g a b = Comopse (f (g a) b)
03:37:52 <cocreature> Myrl-saki: what would be the purpose of that class?
03:37:54 <Iceland_jack> Where the constructors have different names
03:37:55 <Myrl-saki> Iceland_jack: What does the `instance` do?
03:38:08 <Iceland_jack> It's a data family
03:38:22 <Iceland_jack> the feature is described https://ghc.haskell.org/trac/ghc/ticket/12369
03:38:25 <Myrl-saki> cocreature: Same purpose as Compose, but less type unwrapping.
03:38:52 <Iceland_jack> The unwrapping is essential because of the instances
03:39:00 <Myrl-saki> Oh true.
03:39:06 <Iceland_jack> the unwrapping is usually not a problem, if you play it right
03:39:07 <cocreature> Myrl-saki: the purpose of Compose is to choose a different instance for Functor, Applicative, …. I’m not sure how you accomplish that using your class
03:39:26 <Iceland_jack> newtype TicTacToe a = TTT (Compose V3 V3 a)
03:39:28 <Myrl-saki> cocreature: Oh wut
03:39:45 <Iceland_jack> now you can derive Functor, Applicative, Monad, ... for TicTacToe (to cocreature's point)
03:40:10 <Myrl-saki> cocreature: There's no `instance (Functor f, Functor g) => Functor (Compose f g) where fmap = fmap . fmap . fmap
03:40:12 <Myrl-saki> ?
03:40:27 <Myrl-saki> I'm pretty sure I messed up the fmaps there.
03:40:52 <Iceland_jack> fmap f (Compose xs) = Compose (fmap (fmap f) xs)
03:40:59 <Myrl-saki> Right, thanks.
03:41:34 <cocreature> Myrl-saki: that instance exists, that’s the main point of Compose. but your typeclass doesn’t help you with providing a custom functor instance
03:42:53 <Myrl-saki> Oh wait. I just realized that `a` in my typeclass is *
03:42:56 <Myrl-saki> Rather than * -> *
03:43:36 <Myrl-saki> cocreature: Thanks.
03:45:06 <angerman> what are my options for a constantSpace mapAccumL?
03:45:34 <Myrl-saki> Iceland_jack: Thanks too.
03:46:44 <cocreature> angerman: given that mapAccumL produces a list (or some other traversable container) of the length of the input I’m not sure how you expect it to be constant space
03:47:18 <angerman> cocreature: my heap profile tells me it's not :-/
03:47:30 <angerman> cocreature: https://dl.dropbox.com/s/ydf9k89bceu1dhw/Screenshot%202017-08-30%2017.57.07.png
03:47:35 <cocreature> angerman: it can’t me constant space.
03:48:06 <cocreature> > mapAccumL (\x y -> (x+y,x+y)) 0 [1,2,3,4,5]
03:48:08 <lambdabot>  (15,[1,3,6,10,15])
03:48:18 <angerman> cocreature: if my accumulator doesn't grow but just carries state?
03:48:20 <cocreature> the list in the result will never be constant space
03:48:48 <cocreature> angerman: are we talking about lists or some other traversable container?
03:48:51 <cocreature> :t mapAccumL
03:48:53 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
03:48:58 <cocreature> i.e. what is the "t" in your code
03:50:07 <cocreature> I suspect that you probably want it to be strict in "a" but that still won’t make it constant space
03:50:23 <cocreature> but it might improve things
03:50:54 <cocreature> I don’t know of a "mapAccumL'" so you are probably going to need to write it yourself
03:51:29 <angerman> cocreature: dfeuer has one here: https://stackoverflow.com/questions/33318868/most-generic-possible-meaningful-signature-for-a-generic-sorting-function :)
03:53:04 <angerman> cocreature: or maybe I should just go with lists... and use something like `z f b (x:xs) = let (x',b') = f b x in x':o f b' xs`
03:53:17 <angerman> err. that's `:z f b' xs`. 
03:53:20 <Cale> For anyone interested, I updated the Audio demo here: http://cale.hn.org/Demos/Audio/Audio.jsexe/
03:53:30 <cocreature> I’m not sure dfeuer’s mapAccumL' is as strict as you might want it to be
03:54:09 <angerman> cocreature: it's not :)
03:54:18 <cocreature> strict state is not strict in the accumulator, it’s strict in the tuple
04:03:17 <merijn> hmm, anyone here use monad-logger? Seems to me that you can't really guarantee that all log messages have been flushed before the program exits when using a logging Chan
04:06:52 <reactormonk> I'm using lts-9.2 - /usr/bin/ld: .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-1.24.2.0/build/Codec/Compression/Zlib/Stream_hsc_make.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
04:07:55 <merijn> reactormonk: Which distro?
04:07:58 <reactormonk> Here's the full error: https://gist.github.com/reactormonk/8b8f5c862e8bed9bad923c4b8ccf4ee3
04:08:00 <reactormonk> archlinux
04:08:15 <reactormonk> Worked fine on my other computer with arch, so I must have different settings somewhere
04:08:15 <merijn> reactormonk: And...exactly what I expected
04:08:36 <reactormonk> Time to switch to ubuntu?
04:08:36 <merijn> reactormonk: arch has made their GHC distro completely fucky recently
04:08:50 <reactormonk> Stack doesn't protect against that?
04:08:52 <merijn> reactormonk: Well, or just install the GHC binary distro instead of the arch provided one
04:08:57 <merijn> No clue, I don't use stack
04:09:13 <reactormonk> It does give you its own ghc
04:10:41 <brynedwards> reactormonk: Are you using arch's cabal-install package?
04:11:06 <reactormonk> it's installed
04:11:32 <brynedwards> Follow these instructions https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
04:15:45 <osa1> anyone aware of a program for manipulating Haskell terms for proving equalities? to be used when e.g. proving typeclass laws
04:17:57 <reactormonk> osa1, not sure about the first half, but what about quickcheck for testing and/or liquid haskell for proving?
04:21:12 <osa1> I was imagining something like Coq tactics that. for example if I have the term `State (\s -> runState v s)` and apply `eta` tactic it'd give me `State (runState v)` if that's valid or an error message otherwise.
04:21:44 <osa1> I'd rather not rely on correctness of my test program or Arbitrary instances :) also, this stuff works on open code too. testing is really not a substitute for this.
04:25:36 <Freundlich> I thought about proving something about a Haskell program and I was very disappointed to find out that there is no (official) denotational semantics for Haskell, and the only operational semantic we have is in the form of GHC.
04:25:42 <Freundlich> So good luck proving anything.
04:26:11 <merijn> Freundlich: We have a denotational semantics for most of the safe bits of Haskell
04:26:26 <merijn> Freundlich: The main tricky bit is that IO lacks a denotational semantics, as does all the unsafeX
04:26:40 <Freundlich> And it probably doesn't fit in well with 'seq' either.
04:26:55 <merijn> seq has a denotational semantics
04:27:10 <Freundlich> Ok, alright.
04:27:31 <merijn> seq a b = _|_ IFF a and/or b is _|_, else it's equivalent to b
04:29:01 <Freundlich> Can you point me to where this is written down?
04:31:04 <merijn> Freundlich: Haskell Report 2010
04:31:12 <merijn> I forget the chapter
04:31:16 <Freundlich> Ok, thank you.
04:41:48 <fvh> I'm doing web parsing with http conduit, and one of the js files are hosted on s3 and not available, while web browser loads it normally ( just ignore that file), doin `httpLBS` function lead to error on that s3 wrong page. What I need add to download web page as is even with errors?
04:47:55 <Rembane> fvh: What error do you get?
04:49:53 <fvh> I get no error, I just get wrong response body, instead of page I'm downloading I get access denied html file from S3
04:50:33 <fvh> because it tries to load js file in the end of body and somehow redirected there
04:51:23 <fvh> maybe there is some option that can stop it from loading 3rd party files as I only need html structure
05:02:40 <Axman6> fvh: have you confirmed you can access that file in a browser under private browsing mode? you might be using credentials that give you access to the file in your browser which you aren't in the haskell app
05:03:58 <fvh> I'm looking at browser console and it just can't load the file, I can see error, but browsers always load html structure even with errors
05:04:50 <fvh> but running httpLBS somehow tries to load this file gets html response and decides it's final html structure
05:06:00 <fvh> I think this is not relevant to Haskell lib, maybe I need specific header to say in request that I don't want to follow links
05:08:41 <ertes-w> fvh: note that there are different APIs in http-conduit with different redirection semantics
05:09:23 <ertes-w> your browser follows redirects, but with http-conduit you need to make sure to select the correct API to follow them
05:10:06 <ertes-w> fvh: is it an actual error (4xx or 5xx)?  or is it a 3xx response?
05:14:15 <fvh> it's 404 from s3 not from web page I'm trying to download
05:16:54 <merijn> hmmm, anyone here know how to get ghc-mod faster in the presence of TH?
05:24:57 <Psybur> Is this good haskell? http://mcfunley.com/haskell-mandelbrot-set
05:26:31 <merijn> Anyone know if there's any kind of library for running conduit sinks in parallel?
05:32:41 <ventonegro> Psybur: `vertices` with IO? Hmmm....
05:40:28 <pacak> Psybur: No.
05:41:07 <Psybur> pacak, why isn't it good haskell?
05:42:34 <pacak> Psybur: Lack of type signatures.  vertices in IO.     "color3 r g b = Color3 r g b" - just meh. 
05:42:56 <Ferdirand> the chunkify is non-idiomatic as well
05:57:08 <supercynic> merijn: if you aren't stuck with conduit you can use concurrent-machines
05:57:23 <merijn> supercynic: I am stuck with conduit
06:28:02 <reactormonk> merijn, conduit puts a heavy emphasis on resource safety, which makes parallelism slightly harder than required
06:28:25 * mekeor discoveres @hackage servant-reflex
06:29:41 <reactormonk> http://brandon.si/code/announcing-unagi-chan/
06:30:35 * mekeor wonders if ghcjs run on linux-arm
06:35:22 <orion> Hi. I need to stream data from postgres (opaleye) to elasticsearch (bloodhound). I have the following functions at my disposal: BH IO a -> IO a
06:35:35 <orion> (previous message sent prematurely)
06:36:06 <orion> runQueryFold :: Default QueryRunner columns haskells => Connection -> Query columns -> b -> (b -> haskells -> IO b) -> IO b
06:36:56 <orion> The first function is withBH :: ManagerSettings -> Server -> BH IO a -> IO a, however I will be providing the ManagerSettings and Server.
06:37:24 <orion> I need to tie these two together so that I can use one HTTP manager within the streaming interface of opaleye.
06:37:25 <reactormonk> I wonder if you can rewrite either of these as sink/source of some streaming library
06:38:22 <orion> One thing I am trying is the following: allEventsSinceBHFold :: Connection -> (BH IO () -> IO ()) -> (Event -> BH IO ()) -> IO () -- where "Connection" is a postgresql connection handle.
06:38:24 <trigone> hi! if i have a multi-parameterized type constructor, is there a way to derive a functor instance automatically over one of its parameters? (using `deriving` etc)
06:39:43 <orion> I also have: indexEvent :: Event -> BH IO ()
06:40:14 <orion> It's not apparent to me how to tie indexEvent in to withBH and runQueryFold.
06:40:38 <reactormonk> trigone, possibly via https://hackage.haskell.org/package/generic-deriving-1.11.2/docs/Generics-Deriving-Functor.html
06:41:04 <reactormonk> I'm looking for a library that does parallel Fold (as in beautiful folds), any recommendation?
06:41:37 <lyxia> trigone: -XDeriveFunctor
06:42:55 <trigone> lyxia: but will it accept it if there's more than one type variable?
06:44:50 <trigone> reactormonk: don't know about this library, sounds complicated...
06:45:27 <reactormonk> trigone, deriving functor works on the last argument only IIRC - it'll make a functor varying that one
06:47:33 <trigone> hm well then it's enough for me :) thx
06:50:23 <barrucadu> Functors can only vary the last type parameter anyway
06:51:23 * hackagebot scientific 0.3.5.2 – Numbers represented using scientific notation – https://hackage.haskell.org/package/scientific
07:08:29 <pussyslayer> yo
07:08:44 <shapr> Looking for introductory Haskell propaganda?
07:09:01 <pussyslayer> yes 
07:09:07 <shapr> haskellbook.com got updated last week to 1.0-RC1
07:09:25 <shapr> Graham Hutton's Programming in Haskell was updated to 2nd edition in the past few monthns
07:09:35 <pussyslayer> hi
07:09:41 * byorgey just got a review copy of Hutton's book, it looks pretty good
07:09:46 <shapr> byorgey: second edition?
07:09:51 <byorgey> yes
07:10:05 <shapr> I bought a copy, but I've been busy working through all the homework in haskellbook
07:10:08 <pussyslayer> need help
07:10:11 <byorgey> the only thing I disagree with is how late he puts declaring your own data types.  not until like chapter 8 or 10 or something.
07:10:26 <shapr> pussyslayer: If you have a question about Haskell, go ahead and ask.
07:10:45 <[exa]> shapr: does it have cool images like 'learn yourself a haskell' ?
07:10:45 <shapr> byorgey: I've decided I just don't know the 'best' way to teach Haskell
07:11:05 <shapr> [exa]: nah, for that you should read kosmikus' PhD thesis, it has the best pics
07:11:07 <byorgey> [exa]: no, but unlike LYaH, it has lots of great exercises!
07:11:25 <shapr> salut eatman, comment ca va?
07:11:46 <byorgey> shapr: neither do I.  But that doesn't stop me from thinking my way is better than everyone else's ;-)
07:11:57 <shapr> I do like explaining the monoid -> functor -> applicative -> monad approach
07:12:04 <shapr> byorgey: also, don't you get paid to teach Haskell?
07:12:16 <byorgey> yes, yes I do =D
07:12:20 <[exa]> byorgey: oh, exercises
07:12:31 <[exa]> shapr: is it online somewhere?
07:12:41 <shapr> I like the exercises in haskellbook.com, now I want to do the exercises in PiH next
07:12:44 <shapr> [exa]: yes it is!
07:13:14 <shapr> [exa]: look for "thesis" on this page: https://www.andres-loeh.de/
07:13:22 <[exa]> oh found it, thanks
07:14:09 <orion> Does anyone have any insight in to how I could tie opaleye and bloodhound together using each library's streaming interface?
07:14:10 <shapr> byorgey: so whether or not you've found the best way to teach Haskell, you are still obligated to do that
07:14:36 <orion> Bloodhound operates within the Monad BH IO a, but Opaleye operates within IO a.
07:14:58 <orion> And I'm beginning to think that what I want to do is mathematically impossible.
07:15:04 <shapr> oh, I found a surprising Haskell project yesterday. Turns out I need to do some integration with the Avaya PBX system, and I considered writing a lib using the XML api, but there's already a big pile of Haskell code for that!
07:15:25 <shapr> I was surprised at the quality and invisible-ness of this project https://github.com/f-me/dmcc
07:16:04 <byorgey> shapr: nice!
07:19:00 <Zemyla> orion: Can you have Opaleye stream into an TVarQueue and BH stream from it, or vice versa?
07:20:23 <supercynic> i wish integer-gmp exported mutable variants of all the functions
07:21:41 <orion> Zemyla: I never considered that! Do you mean a TQueue?
07:26:27 <Ojd> Hello,  I just started a project to practice Haskell (I am really new to Haskell and functional programming in general), and if anyone has some spare time I would appreciate some feedback.
07:27:04 <Ojd> I am reading LYAH (currently Chapter 9) and working on exercises in parallel
07:27:19 <Ojd> https://bitbucket.org/lijantropique/engineering
07:29:06 <ClaudiusMaximus> supercynic: do you want to ffi to libgmp directly?  i wrote the hgmp package that helps with that (though it seems it's currently unbuildable on ghc < 8, going to try to fix it this week)
07:31:10 <lyxia> Ojd: in terms of style, it's more common to put spaces around operators and no unnecessary parentheses around function applications
07:31:36 <lyxia> Ojd: 4 * flow fluid * density fluid / pi / idP pipe / viscosity fluid
07:31:47 <supercynic> ClaudiusMaximus: that would be too slow…  i need bit operations
07:31:57 <supercynic> ClaudiusMaximus: well, "need"…  i'm just playing around
07:32:45 <lyxia> Ojd: there's not much to say otherwise because it's mostly numerical formulas
07:35:11 <Ojd> lyxia yes I know
07:35:16 <byorgey> Ojd: looks nice.  One other comment is that Show is really designed to produce machine-readable rather than human-readable representations of values.
07:35:20 <Ojd> I started playing with modules
07:35:23 <byorgey> Ojd: so if I were you, I would put   deriving Show   after the declarations of Pipe and Fluid, and turn the existing Show instances into functions like  formatPipe :: Pipe -> String
07:35:50 <Ojd> and I hope with the end of this week to add IO actions
07:36:02 <byorgey> if you want, you could even make a class Pretty p where   pretty :: p -> String   and then make Pretty instances for Pipe and Fluid
07:36:11 * mbrock uses a Haskell script to get all the local rental flat listings into a map...
07:36:46 * mbrock wishes landlords would have APIs so he wouldn't have to, like, call people on the telephone...
07:37:30 <Athas> That _is_ the API!
07:37:57 <Athas> The application protocol is English, and the transport layer is the telephone network.
07:38:08 <Athas> Now, you might say that is a horrible design.  But so is SOAP over SMTP.
07:40:10 <byorgey> it's not a horrible design.  It's inefficient, but extremely flexible/extensible.
07:40:12 <mbrock> well, let's say I wish the protocol were English ;)
07:41:17 <Ojd> byorgey: I don't get the machine-readable part.  My understanding is that show produced the string representation of the values in the data type
07:41:23 * byorgey shudders at horrible memories of writing SOAP applications in Java
07:41:47 <Ojd> and I like the idea of Pretty
07:41:50 <byorgey> Ojd: yes, and the idea is that you should be able to paste those strings into the ghci prompt
07:42:43 <byorgey> so for example when you do   show (1,2) it produces the string "(1,2)" which you can paste into the ghci prompt to produce that pair again. It does not produce a string like "You have a pair: the first element is 1 and the second is 2."
07:43:03 <Ojd> Ohh I see
07:44:02 <byorgey> Ojd: it's not that big of a deal, there's nothing about the Show class that actually forces you to do this.  It's more of a social convention.
07:45:07 <Zemyla> byorgey: Well, if you also have a Read instance for a type, then you should have it be defined such that read (show a) == a.
07:45:53 <Ojd> byorgey: I will fix it anyway. I am interested in the actual use of the language, but also the "etiquette"
07:46:42 <byorgey> Zemyla: right, good point
07:46:59 <byorgey> Ojd: yes, I thought so, which is why I said something about it =)
07:51:10 * hackagebot ngx-export 0.7.0.0 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
07:53:24 <sjdfa> cassava can only encode/decode 15 columns.. How can I process more than 15 columns?
07:55:24 <glguy> sjdfa: Don't use tuples, make a custom record type with instances of FromRecord and ToRecord
07:56:28 <sjdfa> Right,
07:56:33 <sjdfa> Thanks!
08:05:27 <irrep> When I do `(i - 20) / 80.0`, it seems that `(/)` cannot do `Int -> Float -> Float`. What would I have to use instead?
08:08:03 <supercynic> irrep: fromIntegral :: Int -> Float
08:08:35 <irrep> supercynic: thanks, I had found fromInteger on Hoogle, which is not what I wanted either.
08:08:43 <irrep> supercynic: now that part works :-)
08:09:45 <supercynic> irrep: to go from integral types to arbitrary numeric types you use fromInteger/fromIntegral…  for the opposite direction there are functions like 'round', 'floor', 'truncate'
08:10:12 <supercynic> irrep: and to go from a fractional type to another fractional type there is realToFrac
08:10:34 <irrep> supercynic: a fraction is something like `(Int, Int)`?
08:10:52 <irrep> So it can represent something like 2/3 exactly?
08:11:02 <supercynic> irrep: a fractional type is any type that can represent something that is not integral
08:11:26 <supercynic> Double is a fractional type and can't represent 2/3 exactly, but Rational is also a fractional type, and that one can
08:11:27 <irrep> so that is a type class that contains like Double and Float (if I use the words correctly)(?
08:11:37 <irrep> okay, I see!
08:11:43 <supercynic> yeah
08:12:25 <supercynic> for another example see Data.Fixed, which can represents a certain fixed decimal precision, so you can represent 0.1, but not 2/3
08:12:33 <supercynic> (Double can't represent 0.1 exactly)
08:12:36 <Hafydd> I'm not sure if not Integral => Fractional always holds...
08:12:45 <Hafydd> What about the Gaussian integers?
08:12:56 <irrep> What are Gaussian integers?
08:13:06 <supercynic> Hafydd: gaussian integers are not Integral
08:13:17 <Hafydd> supercynic: yes, and they are not fractional.
08:13:27 <supercynic> so there is no issue =)
08:13:32 <Hafydd> So "not Integral => Fractional" does not hold.
08:13:44 <irrep> Is that some Haskell concept or something mathematical?
08:13:49 <Hafydd> supercynic> irrep: a fractional type is any type that can represent something that is not integral
08:13:51 <supercynic> you can't go from arbitrary Num to Fractional
08:13:54 <Hafydd> So that is not true.
08:14:28 <Hafydd> irrep: the Gaussian integers are the integers of the form a + bi, where a and b are integers and i is the imaginary unit.]
08:14:44 <Hafydd> I mean the complex numbers of that form.
08:14:46 <irrep> »arbitrary« num is just something that has `+` and `*` defined?
08:14:56 <irrep> Hafydd: okay, that is the name that I am familiar with.
08:15:33 <supercynic> Hafydd: yes, yes, sorry…  i will spell out the actual class definitions next time…  and sorry in advance for a VERY long explanation of what an Integral is =)
08:15:56 <Hafydd> supercynic: it will suffice just to not say things that are not true, if that's too much trouble.
08:16:49 <tushigushi> clear
08:17:03 <supercynic> Hafydd: we could now take apart the exact structure of my sentence, and both of us could prove themselves correct…  that doesn't lead anywhere…  intuitive explanations are intuitive
08:17:30 <supercynic> s/themselves/ourselves/
08:17:49 <irrep> I think it will take me a couple more weeks to fully understand where the ambiguity lies. I am just happy that I can do the division now =)
08:18:13 <supercynic> irrep: haskell's numeric type classes take some getting used to
08:18:33 <supercynic> irrep: it pays off to learn them, i.e. what the actual class definitions are
08:19:01 <irrep> That means I should learn what operators (+, -, ...) I can use with these types?
08:20:01 <supercynic> irrep: what operators belong to which type classes…  just read the actual class definitions
08:20:44 <irrep> supercynic: Like this one? https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#t:Integral
08:21:16 <supercynic> irrep: yeah, exactly…  and you might have some fun along the way, if you can appreciate the irony in the toRational function =)
08:21:24 <supercynic> :t toRational
08:21:26 <lambdabot> Real a => a -> Rational
08:24:09 <irrep> I fear I don't get that yet.
08:26:07 <JuanDaugherty> just the obvious, irrep, the rational is the real/reality
08:27:22 <irrep> So the mathematical real numbers R are represented by Rational?
08:27:33 <JuanDaugherty> no it's a pun/joke
08:28:48 <michalisko> irrep: Just a bit hard to represent Irrational numbers on the computer. Unless by a chain of approximations...
08:30:16 <irrep> Of course we have limited precision on a computer, so the uncountable wealth of irrational numbers will not be representable. However, I could imagine that Haskell has a 32-Bit and 64-Bit floating point type and some arbitrary (but then fixed) precision type
08:30:44 <mlehmk> a computer can only calculate with a subset of rational numbers
08:30:56 <irrep> I'm well aware of that :-)
08:31:29 <dolio> The rationals are Q.
08:32:24 <dolio> And floating point numbers, even arbitrary precision ones, are a subset of Q.
08:32:55 <irrep> dolio: yeah, that is correct. They are a subset of R as well, but that's not really hard at this point :-)
08:34:49 <dolio> I wouldn't say you can only compute with a subset of Q, though. Unless you're going to be a real stickler, and say that every computer is only a finite state machine.
08:35:08 <mnoonan> wait, which rational is NaN, and which is -0? :)
08:35:26 <dolio> I'm not talking about IEEE floating point.
08:35:34 <mnoonan> ah
08:35:36 <barrucadu> mnoonan: My favourite rational is negative infinity
08:38:32 <irrep> My ASCII Mandelbrot set now works, just needed 37 lines. At some point I want to compare the performance against the Python and C++ implementation that I have.
08:39:51 <ggVGc> dolio: everything in the world is just a finite state machine!
08:40:00 <dolio> Right.
08:40:20 <BernhardPosselt> > traverse [] :: [Maybe Int]
08:40:22 <lambdabot>  error:
08:40:22 <lambdabot>      • Couldn't match expected type ‘[Maybe Int]’
08:40:22 <lambdabot>                    with actual type ‘[a0] -> f0 [b0]’
08:40:38 <ggVGc> we should rename IO to FSM
08:40:48 <BernhardPosselt> :t traverse
08:40:49 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:41:28 <BernhardPosselt> what happens if you traverse an empty list?
08:41:44 <BernhardPosselt> e.g. of Maybes
08:41:55 <BernhardPosselt> will it return a Maybe holding an empty list?
08:42:01 <BernhardPosselt> or Nothing
08:42:18 <ventonegro> :t traverse
08:42:19 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:42:30 <ventonegro> f is Maybe, t is []
08:42:50 <BernhardPosselt> i dont get the first parameter
08:43:34 <BernhardPosselt> doenst traverse simply turn a list of maybes into a maybe of a list?
08:43:43 <ventonegro> In the signature, `f` will be `Maybe`, and 't' will become `[a]`
08:43:58 <ventonegro> So you can just substitute in the type of the result
08:44:48 <BernhardPosselt> (a -> Maybe b) -> [a] -> Maybe [b]
08:45:07 <BernhardPosselt> so whats my a -> Maybe b function?
08:45:22 <ventonegro> BernhardPosselt: you tell me :)
08:45:26 <BernhardPosselt> no idea :D
08:45:34 <erisco> I need help with RankNTypes... why is this
08:45:42 <erisco> :t id :: (forall a. a) -> a
08:45:43 <lambdabot> (forall a1. a1) -> a
08:45:53 <ventonegro> :t traverse Just
08:45:54 <lambdabot> Traversable t => t b -> Maybe (t b)
08:46:06 <ventonegro> :t traverse Just []
08:46:08 <lambdabot> Maybe [b]
08:46:15 <BernhardPosselt> ah
08:46:54 <BernhardPosselt> its the type constructor
08:46:55 <ventonegro> > traverse Just []
08:46:57 <lambdabot>  Just []
08:47:11 <ventonegro> BernhardPosselt: no, it was an example
08:47:31 <ventonegro> any function with type `a -> Maybe b` will do
08:47:41 <BernhardPosselt> :t Just
08:47:43 <lambdabot> a -> Maybe a
08:47:56 <BernhardPosselt> ty
08:48:18 <ventonegro> > traverse (Just . (+1)) []
08:48:20 <lambdabot>  Just []
08:48:50 <lyxia> erisco: sounds like a bug, related to https://ghc.haskell.org/trac/ghc/ticket/14160
08:50:13 <lyxia> or maybe not...
08:50:31 <erisco> the example of id is given, seems like it to me
08:50:47 <erisco> :t (\x -> x) :: forall a. a -> b
08:50:49 <lambdabot> error: Not in scope: type variable ‘b’
08:50:58 <erisco> :t (\x -> x) :: forall b. (forall a. a) -> b
08:51:00 <lambdabot> (forall a. a) -> b
08:51:06 <erisco> :t undefined :: forall b. (forall a. a) -> b
08:51:07 <lambdabot> error:
08:51:07 <lambdabot>     • Cannot instantiate unification variable ‘a0’
08:51:07 <lambdabot>       with a type involving foralls: (forall a. a) -> b1
08:51:26 <erisco> or maybe it is saying the former is *supposed* to type check
08:51:32 <erisco> and so is the latter... I don't know
08:52:13 <lyxia> the former looks fine
08:52:31 <erisco> it does
08:52:32 <lyxia> I'm unsure about id
08:52:57 <erisco> yeah the fact that id :: a -> a then makes saying id :: (forall a. a) -> a  strange, to me
08:53:57 * hackagebot threepenny-gui 0.8.1.0 – GUI framework that uses the web browser as a display. – https://hackage.haskell.org/package/threepenny-gui
08:53:57 * hackagebot salve 0.0.0 – Semantic version numbers and constraints. – https://hackage.haskell.org/package/salve
08:54:31 <erisco> but is that definitely a bug or just wontfix weirdness or does it have a rational explanation?
08:54:50 <erisco> I am trying to understand what the rules of RankNTypes are
08:55:42 <johnw> (forall a. a) -> a is not id
08:55:52 <johnw> that's the same as: forall b. (forall a. a) -> b
08:56:15 <johnw> this could be called "absurd"
08:56:30 <erisco> then why does it type check
08:56:55 <johnw> you used undefined, that's a possible definition for absurd
08:57:00 <johnw> or, do you mean the other one?
08:57:15 <johnw> can you please reask the question?  I'm missing context
08:57:18 <erisco> :t id :: (forall a. a) -> a -- the first thing I gave
08:57:20 <lambdabot> (forall a1. a1) -> a
08:58:08 <lyxia> undefined having type    forall b. (forall a. a) -> b    sounds impredicative.
08:59:20 <erisco> :t (+) :: Num a => (forall a. a) -> (forall a. a) -> a
08:59:21 <lambdabot> Num a => (forall a1. a1) -> (forall a1. a1) -> a
09:00:16 <johnw> ok, now I don't know why that's type-checking
09:00:33 <hexagoxel> those are just specialized versions of `id`.
09:00:35 <erisco> :t fmap :: Functor f => (forall a1. a1) -> f a -> f b
09:00:37 <lambdabot> Functor f => (forall a1. a1) -> f a -> f b
09:00:51 <johnw> :t absurd :: forall b. (forall a. a) -> b
09:00:53 <lambdabot> (forall a. a) -> b
09:01:06 <johnw> :t id :: forall b. (forall a. a) -> b
09:01:08 <lambdabot> (forall a. a) -> b
09:01:15 <erisco> I am getting the impression that if  f :: a -> b  then  f :: (forall a. a) -> b
09:01:16 <hexagoxel> if you pass `forall a . a` to a function, you promise to provide a value of any type.
09:01:42 <johnw> hexagoxel: so the types just automatically unify?
09:01:51 <johnw> (forall a. a) seems to unify with any type
09:01:57 <johnw> which would then explain what we're seeing
09:02:16 <hexagoxel> so if `id :: (forall b . b) -> a`, you promise to provide any value, and the implementation will of course use `a`.
09:02:33 <johnw> except that forall b. b isn't just any value
09:02:38 <johnw> it's the inhabitant of *every* type
09:02:45 <hexagoxel> yeah
09:03:35 <erisco> somewhere someone has the rules for this and I am just trying to uncover what they are
09:03:37 <dolio> `forall a. (forall a. a) -> a` is the canonicalized form of `(forall a. a) -> (forall a. a)`.
09:03:49 <johnw> dolio: ah, of course!!
09:03:55 <supercynic> absurd :: Void -> a  -- give me a Void and i give you anything you want
09:03:55 <johnw> sanity restored
09:03:57 <hexagoxel> generalizing in negative positions will specialize a signature, and vice versa, i think.
09:03:59 <lyxia> But how is that not impredicative
09:04:12 <erisco> it is impredicative
09:04:14 <dolio> It is. I don't know why GHC allows that case exactly.
09:04:31 <supercynic> (forall a. a) -> b  -- show me that you can prove anything, and i give you anything you want
09:04:49 <erisco> I get the logical meaning of it
09:05:00 <supercynic> sounds like the same, but isn't quite the same:  the former is the empty function, while the latter is identity
09:05:03 <erisco> I am just trying to figure out what is and is not allowed with RankNTypes
09:05:31 <erisco> because sometimes it whines about impredicativity and other times it seems fine
09:05:38 <dolio> The empty function is the identity on empty types.
09:06:38 <hexagoxel> erisco: do you have some example where it whines?
09:06:43 <erisco> :t id :: ((forall a. a) -> a) -> (forall a. a) -> a
09:06:44 <lambdabot> error:
09:06:44 <lambdabot>     • Cannot instantiate unification variable ‘a0’
09:06:44 <lambdabot>       with a type involving foralls: (forall a2. a2) -> a1
09:06:57 <erisco> GHC doesn't yet support impredicative polymorphism
09:08:46 <supercynic> huh?
09:08:55 <supercynic> :t id :: ((forall a. a) -> b) -> (forall a. a) -> b
09:08:57 <lambdabot> error:
09:08:57 <lambdabot>     • Cannot instantiate unification variable ‘a0’
09:08:57 <lambdabot>       with a type involving foralls: (forall a. a) -> b1
09:09:34 <johnw> supercynic: there is no symmetry
09:09:54 <dolio> It doesn't make a ton of sense to reject that but allow the simpler example.
09:09:57 <johnw> that's forall b. ((forall a. a) -> b) -> (forall a. a) -> b, and not (forall b. ((forall a. a) -> b)) -> (forall b. (forall a. a) -> b)
09:10:21 <supercynic> sure, but why is that not allowed?
09:10:32 <johnw> dunno
09:10:40 <erisco> :t id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b)
09:10:42 <lambdabot> error:
09:10:42 <lambdabot>     • Cannot instantiate unification variable ‘a0’
09:10:42 <lambdabot>       with a type involving foralls: (forall a. a) -> b1
09:10:42 <johnw> maybe because it doesn't "obviously" unify with a -> a
09:10:54 <johnw> ok, n/m
09:11:02 <erisco> but smart idea ;)
09:11:26 <dolio> It's not allowed because impredicative instantiation is hard to do, and GHC's algorithm isn't designed to enable it.
09:11:53 <dolio> The question is why the `(forall a. a) -> b` one actually works.
09:13:19 <dolio> I think it's because it's doing a different check.
09:15:36 <dolio> To check if `a -> a <= (forall a. a) -> b` you might end up doing checks that just require instantiating (forall a. a).
09:15:56 <dolio> Rather than instantiating a to (forall a. a).
09:16:35 <dolio> But for the higher order examples, you need to set a to (forall a. a) -> b.
09:17:02 <lyxia> That makes sense.
09:18:49 <ski> dolio : `<=' ?
09:21:11 <dolio> You need to check that the ascription is 'more specific' than the inferred type of the expression.
09:21:25 <ski> oh, i suppose "is more specialized than" .. but shouldn't it be `>=' in this case ?
09:22:05 <ski> (i initially parsed it as `a -> (a <= (forall a. a)) -> b', wondering whether `<=' was a converse constraints arrow or something ..)
09:22:20 <ski> (considering `->' is contravariant to the left, i mean)
09:22:24 <dolio> I don't think so.
09:22:44 <dolio> The induced subtyping order usually has (forall a. a) less than everything.
09:24:48 <ski> HM infers most general types. the type `forall a. [a] -> [a]' is more general than `String -> String'
09:25:01 <ski> similarly, `forall a. a' ought to be more general than `Char'
09:25:51 <ski> (if a more general type signature is valid, then a more specific one is also valid)
09:25:54 <dolio> More general is subtype.
09:26:37 <ski> if `f :: Int -> Int' is valid, then also `f :: (forall a. a) -> Int' should be valid (simply specialize the argument setting `a' to `Int')
09:27:15 <dolio> The collection of terms that satisfy a more general type is the intersection of the collections of terms that satisfy instantiated types.
09:27:30 * ski nods
09:27:33 <dolio> So that collection is 'smaller' in some sense.
09:27:54 <dolio> And if you add existential quantification, it's the union, and is bigger.
09:28:19 <ski> i wasn't aware "more general/specific" was treated as subtyping, rather than being its own thing, though
09:28:29 <erisco> so, when I learned is, if it works then rejoice and if it doesn't then don't worry about it
09:28:37 <dolio> Well, there's kind of two different things.
09:29:13 <dolio> There's the ordering of the types you can give a particular term, and there's the subtype ordering of types viewed as the collection of all terms that have a given type.
09:29:21 <ski> (and without that connection, it would seem natural to me to say `sigma' is more specific than `tau' is phrased as `sigma =< tau', rather than the other way around)
09:30:38 <dolio> And the former is flipped relative to the latter, I think.
09:31:02 <ski> hm. that may be the reason for the cognitive dissonance, then
09:31:28 <ski> erisco : it ?
09:32:02 <erisco> ski, if it type checks
09:32:07 <ski> it being ?
09:32:13 <erisco> whatever
09:32:21 * ski smiles
09:32:48 <erisco> I was looking for a rhyme and reason in RankNTypes and didn't find it
09:32:54 <erisco> so, if it works then great, and if not I won't worry about it
09:33:53 <dolio> ski: Also, I'm not sure if 'most general type' still makes sense for rank-n types, but the subtyping order does.
09:35:03 <dolio> Most general type might still make sense if you have enough structure (both forall and exists, maybe), but might not be decidable (the subtyping order isn't, either).
09:42:32 <monochrom> Oh haha neat cabal-install accepts both --only-dependencies and --dependencies-only
09:43:13 <hexagoxel> (and any non-ambiguous prefix of either, such as --dep)
09:47:17 <ski> dolio : well, "most" was for HM. in the more general picture, i'm satisfied with "more", i.e. having the the specificity/generality ordering
09:47:25 <ski> (which i don't tend to think of as subtyping)
09:47:39 <erisco> maybe it should then use, as a final measure, minimum levenstein distance
09:47:47 <ski> erisco : ok, read backlog, and experimented a bit. i think i know what's going on
09:48:03 <AndreasK> Does anyone know by chance if there have been languages before ML/Miranda/Hope that had the same style of pattern matching?
09:48:31 <ski> erisco : given a value of type `forall a. ..a..', we can treat it as having type `..T..', replacing `a' with some specific type `T'
09:48:40 <ski> @type length :: forall a. [a] -> Int
09:48:41 <lambdabot> [a] -> Int
09:48:44 <ski> @type length :: String -> Int
09:48:46 <lambdabot> String -> Int
09:49:18 <ski> in fact, `T' could itself contain new (fresh) type variables, which we then implicitly quantify the whole type over
09:49:24 <ski> @type length :: forall a b. [(a,b)] -> Int
09:49:26 <lambdabot> [(a, b)] -> Int
09:49:41 <ski> (here the previous `a' was replaced by `(a,b)', and then we generalized the whole result on `a' and `b')
09:51:06 <ski> now, just because we can treat something of type `forall a. ..a..' as having type `..T..', it doesn't at all automatically follow that we also can do this in "nested contexts" / "not at toplevel", iow treating something of type `..(forall a. ..a..)..' as having type `..(..T..)..'
09:51:50 <ski> (though it could be reasonable to ask whether this would make sense, and not be too much of a bother to implement .. also to ask about any potential problems with allowing this)
09:52:49 <ski> e.g. if we have a value of type`[forall a. [a] -> [a]]' (impredicative), it's not obvious that the system would allow us to treat it as having type `[String -> String]'
09:53:49 * hackagebot tweet-hs 1.0.1.3 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
09:54:11 <ski> (even though, logically speaking, this would make sense .. and implementation-wise, it would work fine, assuming that no run-time code&representation is used for polymorphism and the associated generalization&specialization for it)
09:55:39 <erisco> okay, so how does this get around to explaining id :: (forall a. a) -> a
09:56:32 <ski> (however, one can imagine implementations which pass at run-time some info corresponding to the type variable in `forall a.'. e.g., this could be done to support unboxed representations, so the size of cons-cells in `[a]' depends on the size of values of the type `a' being use. polymorphic operations must be passed the size (and perhaps more about the representation), then
09:56:37 <ski>   then one would have to apply a non-`O(0)' conversion operation on a value of type `[forall a. [a] -> [a]]', in order to turn it into a value of type `[String -> String]')
09:57:17 <erisco> we're well familiar with quantifiers at the top level, or at least I thought
09:57:20 <ski> now, let's go back to the question of allowing a value of type `..(forall a. ..a..)..' to be treated as having type `..(..T..)..'
09:58:01 <ski> a specific instance of this would be whether one should allow a value of type `(forall a. a) -> Int' to be treated as having type `Int -> Int'
09:58:23 <ski> i hope you agree that we should definitely *not* allow it, in this instance !
09:58:58 * ski looks at erisco
09:59:50 <ski> do you see the problem ?
09:59:53 <erisco> yes that is wrong, it needs to be contravariant there
09:59:58 <ski> exactly
10:01:13 <ski> so, an adjustment (restriction) of the question then would be whether it would make sense to allow a value of type `..(forall a. ..a..)..' to be treated as having type `..(..T..)..' -- when the outer context is *covariant* (aka the `forall' occuring positively in it)
10:01:54 <ski> we know GHC doesn't allow it in the `[forall a. [a] -> [a]]' to `[String -> String]' case (impredicative types)
10:02:22 <ski> @let take' :: Int -> forall a. [a] -> [a]; take' n xs = take n xs
10:02:24 <lambdabot>  Defined.
10:02:47 <ski> @type take' :: Int -> forall a. [a] -> [a]
10:02:48 <lambdabot> Int -> [a] -> [a]
10:02:52 <ski> @type take' :: Int -> String -> String
10:02:54 <lambdabot> Int -> String -> String
10:03:18 <ski> this is a rather trivial case, allowing it to the right of an `->' (if it's allowed outside it)
10:03:49 <ski> now, to the left of an arrow, we're contravariant
10:03:58 <ski> so it makes sense for the direction to flip
10:04:43 <ski> iow, we could possibly treat a value of type `..T.. -> ...' as having type `(forall a. ..a..) -> ...'
10:05:30 <erisco> maybe the source of my confusion was not clear
10:05:58 <ski> @type System.IO.openFile :: FilePath -> System.IO.IOMode -> IO System.IO.Handle
10:06:00 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
10:06:00 <akamaus> Hi there. I need to efficiently read Word32s out of huge binary file. What's the best way to do it? So far I tried lazy bytestrings with Get monad's readWord32le, but it gives me just about a couple of MB per second which looks sluggish.
10:06:05 <ski> @type System.IO.openFile :: (forall a. [a]) -> System.IO.IOMode -> IO System.IO.Handle
10:06:06 <lambdabot> (forall a. [a]) -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
10:06:24 <erisco> I gave an example where id does have a higher ranked type (type checks) and an example where it does not (does not type check)
10:06:41 <erisco> but just by inspection it is not clear why the latter example does not type check
10:06:52 <ski> so, because `FilePath' is a specialization of `forall a. [a]', `FilePath -> IOMode -> IO Handle' is a *generalization* of `(forall a. [a]) -> IOMode -> IO Handle' !
10:07:28 <erisco> I expected neither to type check or both to type check
10:07:39 <ski> hm, i didn't pay much attention to the non-checking ones
10:07:44 <erisco> and regardless of which happened the logical meaning made sense
10:07:46 <ski> which of them was the interesting one ?
10:08:13 <erisco> id :: forall b. (forall a. a) -> b   type checks
10:08:27 <erisco> id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b)  does not type check
10:08:59 <geekosaur> that makes sense to me
10:09:12 <ski> i *think* the latter requires instantiating a tyvar to a `forall'-type
10:09:25 <ski> the former does not
10:10:20 <geekosaur> to me, I see the latter saying that the internal foralls are not related to the outer ones, thus talking about a more general type than it actually is (because each one can change independently, according to the signature)
10:10:52 <geekosaur> the first one, we have the internal forall but nothing needs to relate to it, so it does not allow a type to change
10:11:00 <ski> (one could reach it from `forall a. a -> a', by instantiating `a' to `forall a. a', getting `(forall a. a) -> (forall b. b)' (after renaming the latter `a' to `b'), then reordering the latter `forall' to get `forall b. (forall a. a) -> b' .. which would be an impredicative instantiation. however i don't think this is what is happening here)
10:12:37 <ski> rather, `forall b. (forall a. a) -> b' is more specific than `forall b. b', because `forall a. a' is more general than `b'
10:13:01 <ski> given a value of type `forall a. a', you can treat it as a value of type `b' (if you have the tyvar `b' in scope)
10:13:24 <ski> er.. is more specific than `forall b. b -> b', that ought to say
10:14:26 <shapr> Is there a tutorial for calling Haskell code from Python code?
10:14:27 <ski> so, given a value of type `forall b. b -> b', we can treat it as a value of type `forall b. (forall a. a) -> b' (when we get an argument of type `forall a. a', we treat it as having type `b', then pass it to the former `forall b. b -> b' version)
10:15:08 <shapr> CosmicRay: did you ever call Haskell from Python?
10:15:15 * ski isn't quite following geekosaur's argument
10:15:21 <ski> erisco : makes any sense ?
10:15:34 <geekosaur> id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b)
10:15:54 <ski> the source and the target types are equal
10:15:56 <geekosaur> this asserts that the b and a can *change*
10:15:58 <shapr> oh man, I was just using the wrong search terms
10:16:07 <geekosaur> because the internal forall-s make them independent
10:16:34 <geekosaur> so they can be instantiated independently in each parameter, which is not consistent with the original id :: a -> a
10:17:07 <ski> @type let id' :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b); id' f x = id f x in id'
10:17:08 <lambdabot> error:
10:17:09 <lambdabot>     • Cannot instantiate unification variable ‘t0’
10:17:09 <lambdabot>       with a type involving foralls: forall a. a
10:17:10 <ski> @type let id' :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b); id' f x = f x in id'
10:17:11 <lambdabot> (forall b1. (forall a. a) -> b1) -> (forall a. a) -> b
10:17:28 <geekosaur> concrete example, as written (id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b)) I can pick the b in the first parameter to be Int and the second to be Char, and this signature will still typecheck
10:17:30 <ski> @type let id' :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b); id' f = f in id'
10:17:31 <lambdabot> (forall b1. (forall a. a) -> b1) -> (forall a. a) -> b
10:17:33 <geekosaur> but (id :: a -> a) will not
10:17:45 <geekosaur> thus they are not compatible signatures
10:18:28 <ski> s/first parameter/argument type/,s/second/result type/ ?
10:18:36 <geekosaur> er, yes
10:18:43 * geekosaur still working on first coffee
10:18:50 <ski> then i don't agree with "I can pick the b in the first parameter to be Int"
10:18:55 <shapr> In case anyone else wants to call Haskell code from Python, so far I like: https://github.com/nh2/call-haskell-from-anything
10:18:58 <geekosaur> "before the outermost arrow"
10:19:02 <erisco> I can't follow these long explanations
10:19:08 <ski> because that `forall b.' is in contravariant position (wrt the whole type)
10:19:43 <geekosaur> but I don't do this stuff from type theory, I don't know it wwell enough
10:20:04 <erisco> we have figured out that if  f :: a -> b  that  f :: (forall v1 ... vn. a) -> b  where v1 ... vn are free in 'a'
10:20:23 <erisco> so,  id :: a -> a  thus  id :: forall a. a -> a  and that's swell
10:20:48 <erisco> id :: (a -> b) -> (a -> b)   and therefore   id :: (forall a b. a -> b) -> (a -> b)   also swell
10:20:51 <iqubic> :t flip id
10:20:53 <lambdabot> b -> (b -> c) -> c
10:21:03 <iqubic> :t const id
10:21:05 <lambdabot> b -> a -> a
10:21:08 <ski> geekosaur : the point is that if we have a value of type `... -> (forall a. ..a..)', then we can treat it as having type `... -> ..T..'
10:21:27 <erisco> now to get   id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b)  we have to do something else, and I am not sure what yet
10:21:36 <ski> geekosaur : otoh, if we have a value of type `..T.. -> ...', then we can treat it as having type `(forall a. ..a..) -> ...'
10:21:54 <ski> geekosaur : note that these are opposite in direction
10:22:16 <geekosaur> erisco, you can't get there because the type variables are asserted to be independent, when they in fact are not
10:22:42 <geekosaur> ski, I don't think I'm actually addressing you, I[m trying to address erisco's confusion
10:22:42 <ski> erisco : where is `a' and `b' in `id :: (a -> b) -> (a -> b)' bound ?
10:22:46 <erisco> that's not really an explanation I can follow, sorry
10:23:00 <erisco> ski, I included all necessary binders
10:23:08 <ski> geekosaur : it sounded to me you were saying something incorrect, though
10:23:21 <ski> erisco : no binder for `a' and `b' in `id :: (a -> b) -> (a -> b)'
10:23:41 <erisco> ski, you know how implicit binding works
10:24:05 <ski> yes, but i'd prefer you to be explicit about binding, when discussing this, in order to avoid misunderstandings
10:24:13 <ski> (and not just you, of course)
10:24:18 <geekosaur> erisco, you assert an internal (forall a. a) in each one. this makes each a independent of the other; they do not have to mean the same thing. but if the original signature requires the whole type to match, then they cannot be independent; they *must* agree for the whole type to match
10:24:30 <geekosaur> id :: a -> a -- being the oriiginal type
10:24:37 <ski> (because binding is one of the crucial points here)
10:24:57 <butterthebuddha> Hey peeps
10:25:04 <erisco> I don't really get this independence stuff, geekosaur, but if you can think of an explanation in logic why this is wrong then maybe I can follow that
10:25:07 <geekosaur> and I think where ski's tripping up is I am not being specific enough about this
10:25:11 <butterthebuddha> Wondering why don't functional languages in general use arrays?
10:25:20 <geekosaur> covariance vs contravariance
10:25:39 <erisco> butterthebuddha, we do use arrays
10:25:43 <ski> i'm sorry, it's not the original type. it's a *shorthand*/*abbreviated* notation, for something slightly longer
10:25:47 <geekosaur> erisco, this *is* logic.
10:25:48 <ski> erisco ^
10:26:15 <geekosaur> and I think the point here is you are reading a forall as an exists, possibly
10:27:02 <erisco> geekosaur, if it is wrong you should be able to find a counter-example, and that would help me understand your reasoning
10:27:32 <geekosaur> id :: (forall b. (forall a. a) -> b) -> (forall b. (forall a. a) -> b) lets me instantiate the first 'forall a. a' as Int and the second as Char
10:27:47 <ski> geekosaur : not the same "me" in the two cases
10:27:52 <erisco> it doesn't follow from the obvious inference rule we came up with earlier so I am skeptical, but not sure either way
10:28:08 <ski> in the first case, it's the implementor of this `id'. in the second case, it's the caller of it
10:28:22 <geekosaur> ski, me as someone looking at the signature, not as someone implementing it.
10:28:41 <ski> (er, flip those around. you said `forall a.' now, not `forall b.')
10:28:57 <ski> geekosaur : ok, then the second is wrong
10:29:39 <geekosaur> I suppose you could say I'm doing typographical type theory :p
10:29:53 <ski> geekosaur : the implementation of `id' can decide to treat the second argument, having type `forall a. a', as having type `Int'
10:30:01 <geekosaur> yes
10:30:10 <cocreature> butterthebuddha: I wouldn’t say that they don’t use arrays, e.g., the Haskell vector library is quite popular but you are right that they are used less than in imperative languages.
10:30:10 <ski> the caller of `id' can't pass an `Int' as second argument to it
10:30:36 <cocreature> butterthebuddha: the reason for this is mostly that you can’t implement persistent arrays that give you O(1) update and O(1) index
10:30:50 <geekosaur> butterthebuddha, if your actual question is "why does FP default to lists?", the answer is not about lists vs. vectors. the answer is about lists as iterators described in data
10:30:57 <cocreature> butterthebuddha: so you need to give up persistence and move to ST and IO
10:31:08 <ski> the caller of `id' can decide to pass a first argument which only accepts an `Int' as argument, not a general `forall a. a'. the implementor of `id' can't decide to call the first argument (callback) with an `Int'
10:31:39 <ski> geekosaur : non-strict FP ?
10:31:41 <geekosaur> but newcomers tend to think of lists, vectors, etc. as positional data structures
10:31:58 <geekosaur> and thus conflate them in ways FP doesn't
10:32:13 <ski> for some applications, immutable arrays are fine
10:32:22 <geekosaur> ski, I'd argue this also applies to Lisp which is strict
10:32:41 <geekosaur> Lisp cons lists aren't vectors either, they're iterators
10:32:48 * ski . o O ( ..,Scheme,Erlang,SML,OCaml,Clean,&c. )
10:33:07 <ski> well, they're sometimes used to build trees
10:33:27 <erisco> geekosaur, this may come down to the constructiveness of the logic, particularly no LEM, I am not sure
10:33:48 <ski> erisco : no, it'd be the same in classical logic
10:34:08 <erisco> okay, then I am just confused
10:34:38 <ski> at what point in my explanation attempt did you lose track ?
10:34:45 <dolio> There's nothing wrong with `(forall b. (forall a. a) -> b) -> ...` as a tyep for id.
10:34:53 <geekosaur> I did say earlier that this *is* logic. ski's harping on me because I'm tryingt  simplify away the covariant vs. contravariant, becuse I thinkt hat is the part that is confusing you and I want to try to show the problem without invoking it, then work up to how covariance vs. contravariance is involved in it
10:35:08 <dolio> GHC just isn't designed to allow you to do that.
10:35:11 <erisco> I can't really follow the exchange of caller and callee through this
10:35:34 <erisco> so, ∀a. a ⇒ a is true, yes?
10:35:57 <erisco> I guess lets get brackets in there... ∀a.(a⇒a) is true
10:36:22 <ski> geekosaur : if you'd prefer, i could step back and avoid interrupting you .. however, when you weren't clear about the "directions", i was fearing erisco would be even more confused ..
10:36:35 * ski nods to erisco
10:36:45 <erisco> so, if we can agree that ought to be true, what does 'a' range over
10:37:00 <ski> (concrete) types, in this Haskell case
10:37:06 <erisco> forget Haskell
10:37:12 <ski> if you're talking logic, then i suppose it ranges over propositions
10:37:19 <dolio> It ranges over mono-types.
10:37:22 <geekosaur> no, I'm thinking I'm the one that needs to step back, since I'm not sure where I'm going any more :/ today si not shaping up to be one of my better days, I'm having trouble keeping track of it all
10:37:54 * ggVGc gives geekosaur a hug
10:38:13 <ggVGc> tomorrow your types will resolve
10:38:14 <erisco> and if it ranges over propositions, I might choose the proposition  (∀a.a)⇒(∀b.b)  yes?
10:38:20 <ski> yes
10:38:39 <erisco> and if we can agree to that, then  ((∀a.a)⇒(∀b.b))⇒((∀a.a)⇒(∀b.b))  is true
10:39:00 <erisco> now if we do a direct naive transplant to Haskell, it suggests id should type check as that
10:39:51 <erisco> but we know things such as LEM do not make sense for our logic of types
10:40:57 <erisco> and lets recall a way to explain a⇒a is ¬a∨a
10:41:16 <erisco> I know we're mixing and matching logic systems at a whim here, but this is the sort of danger I am sensing right now
10:42:46 <ski> @type let id :: ((forall a. a) -> (forall b. b)) -> ((forall a. a) -> (forall b. b)); id x = x in id  -- type-checks in Haskell
10:42:48 <lambdabot> ((forall a. a) -> forall b1. b1) -> (forall a. a) -> b
10:43:21 <ski> @type let id' :: ((forall a. a) -> (forall b. b)) -> ((forall a. a) -> (forall b. b)); id' = id in id'  -- but attempting to reuse the standard `id :: forall a. a -> a' for this doesn't work
10:43:22 <lambdabot> error:
10:43:22 <lambdabot>     • Cannot instantiate unification variable ‘a0’
10:43:22 <lambdabot>       with a type involving foralls: (forall a. a) -> b1
10:43:26 <iqubic> äåéëþüúííóöáßðïœø¶¹²³¤€¥×æœ©®µç¿Á§ÐÄÅÉËÞÜ¡£
10:43:27 <iqubic> I finally got altgr working
10:43:49 <lavalike> congratulations
10:44:22 <ski> (because GHC doesn't allow specializing `a' in `forall a. a -> a' with a type containing `forall's, namely here `(forall a. a) -> (forall b. b)')
10:45:12 <iqubic> erisco: How are you typing all those fancy characters?
10:45:29 <dolio> I made my own keyboard layout to type stuff like that.
10:45:41 <erisco> iqubic, WinCompose, based on XCompose
10:45:51 <iqubic> Ah. You use windows?
10:46:02 <erisco> like all serious programmers do
10:46:12 <iqubic> I don't
10:46:13 * ski grins
10:46:35 <erisco> no I just like my video drivers to work, so that's why
10:46:50 <mud> A couple of IRC clients I've used allow "replacements" on outgoing text. You can set it up so you can just type LaTeX or something and have it change it to symbols.
10:46:55 <erisco> and I need to run Visual Studio now and then
10:47:18 <iqubic> \rightarrow
10:47:48 <iqubic> mud: I'd like to be able to type fancy caharaters everywhere.
10:48:05 <drdo> → ← ∀∃ □ ◇ ■
10:48:08 <drdo> Like this? :P
10:48:09 <mud> What else is there except IRC? ;)
10:48:14 <iqubic> yes
10:48:21 <iqubic> mud: emacs
10:48:23 <drdo> just use xcompose and xmodmap
10:48:30 <erisco> ski, which is fine, other than I am not sure how to predict this behaviour
10:48:50 <dsal> I use C-\ in emacs most of the time.
10:48:51 <raynold> ahh it's a wonderful day :D
10:48:56 <erisco> someone was trying to convince me such a type was wrong i.e. only inhabited by bottom, or something like that
10:49:25 <drdo> erisco: What type?
10:49:34 <erisco> so I became worried about LEM to try and figure out why
10:49:41 <iqubic> drdo: I have a used xmodmap to set a compose key.
10:50:05 <iqubic> I haven't set up a .xcompse yet.
10:51:02 <dsal> How do those mechanisms work?  I tend to just do C-\ or M-x insert-char
10:52:17 <erisco> drdo, long story at this point
10:52:54 <drdo> dsal: xmodmap just rebinds keys, with xcompose you bind strings of keys to characters and then press the "compose key" followed by the string
10:53:32 <dsal> drdo: Ah, so you can just name them TeX style (how I do C-\).  That's interesting.
10:53:59 <drdo> dsal: sure, you can do whatever you want. It's nice that it works everywhere rather than just emacs though
10:54:18 <iqubic> drdo: would it be fine if I looked at your .xcompose?
10:54:41 <dsal> drdo: Sure, it's kind of dumb that I go into emacs to generate text to copy and paste into something else.
11:06:16 <iqubic> drdo: I'd like too see your .xcompose, if you'd be willing to share it.
11:07:10 <drdo> iqubic: ah, yes, sure
11:07:42 <dminuoso> What semantics does <=< use to compose the two functions? Does this operator just serve for composing a function h = f <=< g that ... (f >>= g) ?
11:08:07 <dminuoso> The type would imply that its a possibility, but Im not sure.
11:08:31 <iqubic> :t (<+<)
11:08:33 <lambdabot> error:
11:08:33 <lambdabot>     • Variable not in scope: <+<
11:08:33 <lambdabot>     • Perhaps you meant one of these:
11:08:34 <iqubic> :t (<=<)
11:08:35 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:08:39 <erisco> well the definition is  (<=<) f g x = g x >>= f
11:09:06 <drdo> iqubic: http://lpaste.net/4906341365006204928
11:09:50 <erisco> it is called a Kleisli arrow, and there is reading you can do on that (you'll have to search for it yourself)
11:10:09 <erisco> they form a category
11:10:38 <erisco> id = return  and  (.) = (<=<)
11:10:45 <erisco> so it is also called "Kleisli composition"
11:10:50 <jared-w> That's a nice compose key setup
11:11:13 <erisco> drdo, thanks I will steal some of those :P
11:11:25 <erisco> do you know how hard it is to find documentation for the key names? good grief
11:11:50 <iqubic> drdo: Not all the APL symbols are in that compose map.
11:12:08 <drdo> iqubic: I don't really use or know anything about APL :P
11:12:11 <iqubic> drdo: how do you type greek?
11:12:16 <drdo> iqubic: AltGr
11:12:27 <iqubic> How does that get you greek
11:12:29 <drdo> AltGr+a = α, AltGr+b = β
11:12:32 <drdo> etc
11:12:38 <drdo> I just defined it in xmodmap
11:12:52 <iqubic> drdo: I have a different set-up
11:13:04 <monochrom> erisco: xev can help.
11:13:08 <iqubic> AltGr+a = á for me.
11:13:23 <drdo> iqubic: that's just ´ key followed by a for me
11:13:26 <iqubic> AltGr+Shift+a = Á for me
11:13:28 <drdo> (portuguese keyboard)
11:13:35 <erisco> monochrom, Windows probably doesn't help me with xev, though
11:13:37 <ontop> Hey guys. I'm trying to do something insane. But indentation/nested cases are fighting me. It says line 17 is a parse error (possible incorrect indentation): http://lpaste.net/5682892089440862208
11:13:46 <iqubic> No, I have an american keyboard.
11:13:51 <ontop> If I remove line 17 just to see what happens, line 18 becomes the problem.
11:14:02 <erisco> so, is that American Apple or... ?
11:14:28 <jared-w> iqubic: I'd suggest  looking for a specific xmodmap APL binding set if you're dead set on having all of the APL bindings
11:14:44 <iqubic> jared-w: I don't use xmodmap.
11:14:54 <monochrom> erisco: Hrm, if you're on Windows, what do you need xcompose notation for? :)
11:14:55 <jared-w> whoops, I meant xcompose
11:14:55 <iqubic> I use setskbmap.
11:15:04 <erisco> ontop, Atkinson?
11:15:15 <iqubic> monochrom: he uses wincompose
11:15:28 <ontop> erisco: Sorry?
11:15:29 <c_wraith> ontop: line 10
11:15:33 <c_wraith> ontop: you forgot a )
11:15:36 <ontop> O
11:15:37 <ontop> MY GOD
11:15:41 <ontop> c_wraith: Thank you.
11:15:41 <ski> ontop : line `16' missing a closing bracket
11:15:53 <ski> er, `10', not `16', right
11:16:00 <erisco> ontop, he did a skit involving "ontop". Thought maybe you knew that
11:16:02 <monochrom> OK so you can still go to a linux box (or run linux and X in a virtual machine) then use xev there to discover names you need for wincompose.
11:16:09 <ontop> Hah. Nah I didn't know :)
11:16:17 <ski> ontop : in fact, you can remove the outer brackets around `(Just ...)'. they are redundant
11:16:18 <iqubic> drdo: Do you have a not equals siqn in your .xcompose?
11:16:25 <jared-w> hah it's always the small things :)
11:16:34 <drdo> iqubic: ye
11:16:37 <ontop> ski: Oh, why have I picked up that habit, if it's a deconstruction I always put () around it
11:16:42 <drdo> ≠
11:16:52 <monochrom> Or perhaps wincompose also comes with a corresponding winev?
11:16:54 <iqubic> What's the binding for that?
11:17:02 <drdo>  / =
11:17:06 <erisco> monochrom, haha I don't know, I could look
11:17:14 <erisco> I managed to cobble together and guess what I've needed so far
11:17:27 <monochrom> Oh w00t Rowan Atkinson?
11:17:36 <drdo> iqubic: I didn't give you my full setup to be honest :P
11:17:41 <erisco> yes, that Atkinson... do you know the skit involving ontop? :)
11:17:42 <iqubic> Why not?
11:17:46 <drdo> I don't know what happened, but it's over 6000 lines long
11:17:51 <drdo> I must have copied it from somewhere
11:17:54 <ontop> I should look it up.
11:17:58 <ontop> Seems relevant to my nickname.
11:17:59 <drdo> I only pasted the things I added
11:18:02 <erisco> I don't know if it is appropriate to link it here, lol
11:18:07 <iqubic> Added t what?
11:18:12 <monochrom> No, but I am glad I recognize that name. Because normally it's just "Mr. Bean". :)
11:18:13 <ski> ontop : i dunno. a lot of newbies appear to think the brackets in a `(x:xs)' to be an inherent part of it (rather than protecting the `:' from whatever is outside (typically application) that binds more tightly) .. i suppose it's similar in your case
11:18:17 <drdo> iqubic: I added what I gave you
11:18:34 <iqubic> Added to what? Is there a default .xcompose?
11:18:39 <ontop> ski: I am a newbie. And so I fall into that generalization. Bam.
11:18:42 <erisco> monochrom, haha I am excited when I recognise a celebrity name too... I am such a cultural dunce
11:19:04 <jared-w> drdo: your xcompose is over 6,000 lines long? damn
11:19:17 <erisco> people stare mouth agape in amazement that you don't know this famous person
11:19:23 <erisco> like you're lying to them
11:19:25 <drdo> jared-w: Yeah I don't even know what's in it or how I got it
11:19:47 <drdo> I just try reasonable composes, and if they don't work I add it!
11:19:47 <ski> ontop : also, it seems lots of people write like `(Blah x) +++ (Blah y) = ..x..y..', rather than `Blah x +++ Blah y = ..x..y..', when they're defining a new infix operator `+++' (just an example)
11:19:54 <monochrom> "GoldenEye" also has a character called "Xenia Onatopp" and it was a pun on what the character did.
11:20:16 <ontop> ski: Ah, I don't have that problem. I understand the infixizisation.
11:20:23 <ski> good
11:20:31 <jared-w> ski: I do that to be more explicit and obvious about what the operator is. I'll probably drop that habit soon
11:21:05 <monochrom> 6000-line xcompose is probably 90% legacy code you're too lazy to delete and 10% relevant code.
11:21:23 <drdo> monochrom: yep
11:21:24 * ski also does `Eq a => ..a..' rather than `(Eq a) => ..a..', and `deriving Show' rather than `deriving (Show)'
11:21:43 <drdo> monochrom: But I didn't write it, I copied it from somewhere
11:21:47 <erisco> I am always conflicted about that because when I want to add something I have to put the parens in, and that is annoying
11:21:56 <erisco> and then if I take something away do I also take away the parens?
11:22:12 <erisco> so I've been using the parens explicitly
11:22:28 <ski> that's a valid reason to put them it (at least if you think it's relatively plausible that you will in the future want to add another constraint there)
11:22:55 <erisco> well I usually don't know what I'm doing so I just have my shortsightedness as an assumption :P
11:22:55 <c_wraith> drdo: system configuration by lore passed down from the ancients?
11:23:08 <jared-w> I'd probably put parens in explicitly with deriving and constraints if I was starting a semi large project and wanted the git diffs to be as clean as possible, but since the git diff just marks the entire line as changed anyway... meh
11:23:09 <drdo> c_wraith: oh yes
11:23:09 <ski> (but of course, possibly one doesn't want to consider this, instead just go by a simple set-up habit ..)
11:23:21 <ontop> Guys.
11:23:23 <ontop> I just parsed JSON.
11:23:27 <ontop> Do you know how long that took?
11:23:27 <jared-w> nice
11:23:30 <ontop> It's incredible.
11:23:55 <ontop> Polymorphic JSON makes everyone sad.
11:23:58 <jared-w> Look up the Validation variant of Either and have your mind blown
11:25:01 <c_wraith> ontop: edwardk said something yesterday about having spent a bunch of time using aeson and suddenly understanding why so many people use aeson-lens instead of doing things "right"
11:25:35 <jared-w> What does aeson-lens do "wrong"?
11:25:36 <ontop> I've still managed to avoid lens, kind of wanted to continue doing that.
11:25:52 <c_wraith> jared-w: it uses Value instead of a domain-specific type
11:25:57 <ontop> Mostly because of fear of death after the lens xkcd spoof comic.
11:26:28 <cheater> it's always a good idea
11:27:07 <erisco> correctness is an affliction
11:27:09 <jared-w> There's nothing wrong with lenses and nothing too scary about them either. It's like a lot of Haskell, there's a very small subset required to become 'practically proficient' in lens and then there's the "mast0r h4x0r 1337 ascii gibberish" level of lens that you /could/ do
11:27:13 <ski> ontop : which one's that ?
11:27:24 <monochrom> Oh haha wait, seriously? People stick to the Value type and pretend they're writing Perl? And that's why they use lens to mitigate their Perl mindset?
11:27:41 <erisco> it takes hell of a lot of inconvenience before I'd consider being more loose
11:27:54 <jared-w> monochrom: apparently :p
11:27:58 <ontop> ski: https://pbs.twimg.com/media/B58DjdCCQAASQrI.jpg:large
11:28:06 <monochrom> ("Perl mindset" means a record is encoded as a dictionary from field names to field values.)
11:28:24 <c_wraith> monochrom: they don't use lens to *mitigate* the perl mindset, they use it to make it *easy*.  :)
11:28:33 <ski> ontop : nice :)
11:28:34 <jared-w> ontop: I can't see that image for some reason
11:28:42 <ontop> Odd?
11:28:55 <ontop> ski seems to have seen it fine.
11:29:29 <c_wraith> ontop: what's strange is that lens really isn't more complicated than Traversable. :)
11:29:41 <jared-w> it might be because I have my privacy settings and filters n such really jacked up to help prevent procrastination :p 
11:29:42 <ontop> :D
11:29:44 <erisco> I am not sure if the axes make sense on that comic
11:29:53 * jared-w just procrastinates on the IRC instead
11:30:35 <erisco> I'd expect the lens curve to be near flat-line rather than a cliff
11:31:06 <erisco> if "programming skill" means "proficiency in x"
11:31:17 <monochrom> It's a joke. Expect the irrational. :)
11:31:22 <drdo> jared-w: I really need a figure out a way to use IRC without letting it consume my day
11:31:43 <jared-w> Joining the most active channel on Freenode is definitely the way to do it /s
11:31:47 <monochrom> For example it fails the "vertical line test" but meh perhaps that's part of the joke in the first place.
11:31:53 <erisco> monochrom, I finished laughing before I started dissecting the frog
11:32:13 <drdo> jared-w: The small active channels are the hard ones
11:32:29 <jared-w> true, those are also difficult. You get to know everyone and then it's harder to just not talk as much...
11:32:31 <erisco> I think suggesting lens defies the expectations of a function is subtly humorous
11:32:34 <drdo> jared-w: yep
11:32:46 <monochrom> "I finished laughing before I started dissecting the frog" sounds like a case of using laughing gas to stun the frog but it leaked so you laughed first. :)
11:34:17 <erisco> the "learning curve" is usually set as difficulty over time
11:34:18 * ski . o O ( "Structured Procrastination: Do Less, Deceive Yourself, And Succeed Long-Term" by John Perry in 2016-02-27 at <https://web.archive.org/web/20160227122619/http://www.structuredprocrastination.com/> )
11:34:33 <erisco> so on the y-axis you have difficulty and on the x-axis you have time
11:35:04 <erisco> the idea being that a steep slop means the task becomes difficult quickly and a shallow slope means it becomes more difficult slowly
11:35:32 <iqubic> drdo: How did you set your altgr key to input greek?
11:36:00 <jared-w> ah there we go, it's an image connected to twitter so I can't see it on my computer. Just loaded it on my phone. Quite funny
11:36:21 <jared-w> iqubic: the same way you set it up to input anything else. A lot of these questions should be able to be answered with some really simple googling
11:36:31 <monochrom> erisco: No, wait, the slope (time derivative) is the difficulty. A learning curve is a cumulative density thing.
11:36:48 <jared-w> ski: oh hey I've read that article before! I thought it was great
11:37:30 * monochrom finally understands learning curves!
11:38:00 <dolio> Yeah, I thought it was 'how much you know' vs. 'difficulty/time spent'.
11:38:12 <dolio> That's not a fraction.
11:38:25 <iqubic> dolio: That what I thouht too.
11:38:29 <iqubic> Is that not true?
11:39:05 <jared-w> I need to get some good university tasks that I can suffer on for ages...
11:39:06 <hexagoxel> and "steep" does not really make sense with that interpretation, but got accustomed anyways.
11:39:26 <dolio> If you plot time vertically, steep makes sense.
11:39:28 <dolio> I think.
11:39:33 <monochrom> jared-w: Apply for hundreds of scholarships. That will take a while. :)
11:39:44 <hexagoxel> vertically? on the y axis?
11:39:45 <jared-w> ooooh good one
11:39:53 <dolio> Yeah.
11:40:00 * ski idly wonders whether there's such a thing as a linear relation
11:40:13 <erisco> monochrom, I am not sure of what you said
11:40:29 <jared-w> And I can schedule a bunch of papers and books and such to read! Since they're all on my own time, it's pretty hard to actually be overdue but I feel terrible if I never do it :p
11:40:42 <dolio> It's kind of a weird thing to do, though.
11:41:24 <dolio> I assume 'steep' was chosen because it's hard to walk up a steep hill, though.
11:41:38 <jared-w> Learning curves are really misunderstood a lot
11:41:41 <dolio> Not because of the way the graph looks.
11:41:50 <monochrom> Yeah it's a landscape and hiking metaphor.
11:42:09 <jared-w> A steep learning curve /should/ mean that something is very hard to pick up but you get to the top of the 'skill level' very quickly
11:42:37 <jared-w> So, something like piano does /not/ have a steep learning curve even though people often say it does
11:42:43 <iqubic> Does it mean that?
11:42:45 <monochrom> Your current distance from sea level is not a measure of your current difficulty. Instead, the gradient of the road is.
11:43:01 <erisco> based on https://en.wikipedia.org/wiki/Learning_curve I'll have to concede the term "learning curve" to Hermann Ebbinghaus who apparently came up with the thing
11:43:09 <erisco> so let me instead say "difficulty curve"
11:43:16 <jared-w> that's what people should be saying when they talk about the "steepness" of a curve
11:43:23 * hexagoxel dreams of monotonically increasing landscapes
11:43:23 <monochrom> On that note, I recently thought up one more reason why the journey is more important than the destination.
11:43:37 <monochrom> Because you might not make it to the destination! Bwhahahaha...
11:43:40 <jared-w> Instead what they mean is "it's really hard to pick up and it takes a long time to get good" which is the opposite of a steep learning curve
11:44:17 <ski> monochrom : or perhaps that there is no destination point, just a path
11:44:41 <jared-w> What I mentioned is literally the last sentence of the wiki article right above the table of contents lol
11:45:05 <erisco> soooo the comic does have an accurate representation of the lens learning curve
11:45:34 <jared-w> Where very steep means "extremely rapid progress in a short amount of time"
11:45:40 <monochrom> Another one is http://www.vex.net/~trebla/humour/tautologies.html#14 ("Life---nobody gets out of it alive") after I watched The Hitman's Bodyguard yesterday and heard that ending song. :)
11:45:43 <erisco> the problem is the common idiot like me doesn't know "learning curve" as was in 1885
11:45:50 <erisco> instead we're thinking of "difficulty curves"
11:46:17 <jared-w> Right, people conflate the two because learning is often assumed to be difficult
11:46:29 <erisco> a learning curve is the learning had over experience gained, whereas a difficulty curve is the challenge presented over progress
11:47:20 <erisco> so the two end up looking quite different, because a steep learning curve would actually mean the task is readily learned with little experience
11:47:35 <erisco> whereas a steep difficulty curve means great challenge is presented early on
11:48:14 <dolio> How is challenge measured?
11:48:39 <erisco> in "wtf" units
11:48:41 <jared-w> Although they are not necessarily exclusive concepts. You can have a steep learning and steep difficulty curve, like when learning how to juggle. Takes you a while but once you hit 3 balls you're usually about "done" with the expertise level
11:48:52 <jared-w> "wtf"s per second
11:49:47 <monochrom> challenge is measured by a function of how many people get it after how much time.
11:50:13 <erisco> though I guess the comic is maybe misleading equating "time spent coding" with "experience"
11:50:31 <erisco> I'd have to look more closely as to what you can qualify as "experience"
11:50:52 <monochrom> Therefore, a function from time to challenge is a functional and you use functional analysis. :)
11:51:21 <erisco> their graph suggests that little experience is required to learn lens
11:51:47 <erisco> which could mean, depending on what "experience" is, that effective experience of lens is difficult
11:52:15 <erisco> i.e. either you experience the right things and get it all immediately or you miss it entirely
11:52:40 <hexagoxel> so.. difficulty curves should hopefully approach zero given enough progress?
11:53:12 <erisco> that depends on whether you're measuring difficulty as presented or difficulty as perceived
11:53:44 <erisco> and for difficulty perceived that is subjective, though I am not sure how you'd have an objective measure of difficulty
11:54:34 <erisco> for example, on some objective measure, multivariate calculus is difficult, but subjectively to the person who already knows univariate calculus it is less so
11:55:07 <monochrom> That's just conditional probability not "cannot be objective".
11:55:19 <erisco> for example, as we progress through a course we expect the difficulty on an objective measure to go up, but the subjective measure to remain relatively constant
11:55:51 <dolio> That's because 'knows multivariate calculus' consists in large part of the same stuff as 'knows univariate calculus.'
11:55:52 <erisco> so we're challenged in an effective manner at all times
11:57:33 <monochrom> Anyway "cabal new-build" disppoints me. It refuses to build documentation despite me ordering it 3 times.
12:05:46 <u0_a17> test
12:07:10 <erisco> Message "test" received at 15:04:04 EST
12:57:23 <iqubic> My compose key works properly. ≠ ≥ ≤ 
13:01:01 <iqubic> ⋄_⋄ ⋄_⋄ ⋄_⋄
13:02:26 <[exa]> λωλ
13:02:41 <dminuoso> [exa], so real haskell programmers dont use US layout but greek?
13:03:40 <iqubic> How the heck did [exa] do that?
13:03:48 <[exa]> dminuoso: reminds me to APL
13:04:06 <jared-w> lambda, omega, lambda. Just type it out if you have your xcompose defined correctly
13:04:10 <iqubic> I want to learn APL. Step 1: config .xcompse
13:04:12 * boj is JP layout
13:04:23 <[exa]> :D :D
13:04:31 <jared-w> dminuoso: real haskell programmers use whatever layout they want to. Very few people actually type greek letters for anything in Haskell :p
13:04:36 <[exa]> iqubic: in fact <Multi_key> <g> <l>    : "λ"
13:04:55 <iqubic> [exa]: That's not working for me.
13:05:00 <jared-w> I have mine as <m> <l> because it's 'math' not 'greek' for me ¯\_(ツ)_/¯
13:05:03 <iqubic> compose g l does nothin.
13:05:05 <jared-w> iqubic: you haven't defined it yet
13:05:17 <iqubic> jared-w: I know that i need to define it.
13:05:25 <[exa]> iqubic: lemme paste the bin
13:05:43 <iqubic> ≤ ≠ ≥ work for me.
13:05:57 <iqubic> Where is the default .xcompose?
13:06:00 <[exa]> https://pastebin.com/S9nS6aXT
13:06:13 <[exa]> iqubic: see top of that ^
13:06:23 <jared-w> There is no default, there's only a default for your particular linux distro (/if/ it has one)
13:06:39 <nisstyre> jared-w: I sometimes use λ in Racket because the IDE maps Ctrl+\ to λ
13:06:50 <nisstyre> I would do the same in Haskell if I had a mapping for it set up
13:06:58 <nisstyre> it would probably infuriate other people though
13:07:02 <jared-w> But, again, all of this could likely be answered with some simple google queries :p
13:07:31 <jared-w> nisstyre: that's a nice binding. You'd have to use the unicode syntax language extension but it doesn't really infuriate others in my experience (having seen a few files that use unicode syntax)
13:07:46 <nisstyre> maybe I'll start then
13:09:19 <iqubic> [exa]: Why don't you have a way to switch to greek input?
13:10:56 <iqubic> Why have a load of .xcompose mappings when you could just have a macro to switch input modes?
13:11:39 <[exa]> iqubic: didn't find it useful enough to google it yet :D
13:15:33 <rostero> is the following an endofunctor?  `let f :: [Int] -> [[Char]]; f = fmap (\a -> "f")` or only if it's also returning [Int]?
13:16:07 <benzrf> rostero: an endofunctor of what category
13:16:18 <rostero> that's what i'm trying to understand
13:16:23 <rostero> is the category []?
13:16:36 <jle`> also, all functors have an object mapping and a morphism mapping
13:16:41 <jle`> so you need two things
13:16:51 <jle`> rostero: did someone claim it was a functor?
13:17:03 <jle`> what you posted doesn't really resemble any sort of functor in any meaningful category
13:17:42 <rostero> yeah, good point.  so, i guess my question is is any instance of Functor also an endofunctor?
13:17:58 <jle`> in fact i don't think it could be a description of a  functor because a functor has two parts
13:18:10 <jle`> rostero: ah, yes, the Functor typeclass represents endofunctors in the category Hask
13:18:17 <jle`> but what you gave is...not the functor typeclass
13:18:20 <jle`> it's a function
13:18:33 <rostero> realized that after you mentioned it
13:18:54 <rostero> i was just trying to understand what a category means
13:19:01 <rostero> in the case of a functor and assumed it was the type
13:19:05 <jle`> but yes, the Functor typeclass (we usually write it with a capital F) is supposed to represent/model functors in the category of Hask
13:19:28 <rostero> what does Hask represent?
13:19:34 <jle`> a category is a thing with a set of objects and a set of morphisms, associated with two objects
13:19:39 <jle`> *each associated with two objects
13:19:42 <rostero> all haskell types?
13:19:55 <jle`> Hask is the category whose objects are the set of Haskell types, and whose morphisms are the set of Haskell functions
13:20:05 <dolio> Haskell types are objects, arrows are Haskell functions between them.
13:20:16 <xzhu> What do you guys think of https://hackage.haskell.org/package/foundation
13:20:21 <jle`> and a function of type (A -> B) represents a morphism from type A to type B
13:21:12 <jle`> a Functor is a mapping from category to category, which transforms the objects in those categories, as well as the morphisms in those categories
13:21:35 <jle`> so the Maybe instance of the Functor typeclass represents a functor from Hask to Hask
13:21:53 <jle`> it maps the object (type) 'A' to the object (type) 'Maybe A'
13:21:58 <rostero> ok, so my confusion was that a functor is morphism from * -> *, and i was wondering what happened if it was from Int -> [[Char]], but does that not make any sense
13:22:17 <jle`> it also maps functions (A -> B) to functions (Maybe A -> Maybe B)
13:22:33 <jle`> yes Int -> [[Char]] is not the same thing as * -> *
13:23:03 <jle`> `Int -> [[Char]]` describes the type of functions from values of type Int to values of type [[Char]]
13:23:23 <jle`> `* -> *` describes the "kind" of *types* that take a *-kinded type, and returns another *-kinded type
13:23:56 <jle`> examples of Int -> [[Char]] are things like `\n -> replicate n "hello"`
13:24:04 <iqubic> :k Maybe A -> Maybe B
13:24:06 <lambdabot> error:
13:24:06 <lambdabot>     Not in scope: type constructor or class ‘A’
13:24:06 <lambdabot> error:
13:24:07 <jle`> examples of * -> * are things like Maybe, IO, Either Int, etc.
13:24:25 <iqubic> What is the kind of Maybe A -> Maybe B
13:24:36 <jle`> :k Maybe Int -> Maybe Bool
13:24:37 <lambdabot> *
13:24:47 <jle`> it's *, because it's a type that you can have values of
13:24:52 <jle`> also because (->) :: * -> * -> *
13:25:38 <iqubic> So (Either A) is of kind * -> *?
13:25:44 <jle`> mhm, because Either :: * -> * -> *
13:26:14 <jle`> assuming A :: *
13:26:46 <iqubic> And for something to have an instance of Functor it needs to be kind * -> *?
13:27:06 <iqubic> What in the code defines that?
13:27:20 <c_wraith> iqubic: it can be inferred from the type of fmap
13:27:28 <iqubic> :t fmap
13:27:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:27:38 <iqubic> How does that follow?
13:27:53 <jle`> the Functor is the 'f'
13:28:00 <jle`> and 'f a :: *', right?
13:28:02 <geekosaur> because "f a" and "f b"
13:28:08 <jle`> also we know that (a :: *)
13:28:12 <jle`> because we see (a -> b)
13:28:16 <c_wraith> well, and (->) :: * -> * -> *
13:28:28 <geekosaur> a and b must be kind *, else there are no values to apply f to. f only has values when applied to a or b, so must be * -> *
13:28:30 <jle`> ah yes that too
13:28:31 <iqubic> Oh I see.
13:29:13 <iqubic> So if a :: * then (Either (Maybe a)) :: (* -> *) -> *?
13:29:25 <geekosaur> (and what c_wraith said, which basically means you can only apply something to a type with values, hence kind *)
13:29:26 <jle`> :k Either
13:29:28 <lambdabot> * -> * -> *
13:29:39 <iqubic> :k Maybe
13:29:41 <lambdabot> * -> *
13:29:44 <jle`> if you give Either one * argument, you get a * -> *
13:29:49 <jle`> Either :: * -> (* -> *)
13:29:59 <jle`> so, Either (Maybe a) :: ......?
13:30:17 <iqubic> * -> * -> *?
13:30:32 <jle`> if you give Either a *, you get an * -> *, right?
13:30:37 <jle`> Either :: * -> (* -> *)
13:30:43 <jle`> so, 'Maybe A' is *
13:30:50 <jle`> and we gave it to Either, Either (Maybe A)
13:30:54 <jle`> so, we get...
13:31:07 <iqubic> * -> *?
13:31:09 <jle`> yes
13:31:13 <jle`> :k Either (Maybe Int)
13:31:14 <lambdabot> * -> *
13:31:19 <iqubic> Right.
13:31:30 <iqubic> :k Either (Maybe)
13:31:31 <lambdabot> error:
13:31:31 <lambdabot>     • Expecting one more argument to ‘Maybe’
13:31:32 <lambdabot>       Expected a type, but ‘Maybe’ has kind ‘* -> *’
13:31:52 <iqubic> Can we have something of kind (* -> *) -> *?
13:31:58 <jle`> yeah
13:32:03 <jle`> well, Proxy is poly-kinded
13:32:07 <jle`> Proxy :: k -> *
13:32:09 <jle`> so that's like an easy answer
13:32:23 <jle`> but there are also non-polykinded things too, like
13:32:38 <jle`> newtype MaybeT f a = MaybeT (f (Maybe a))
13:32:47 <jle`> er wait that's wrong
13:32:48 <lyxia> :k Fix
13:32:49 <lambdabot> error:
13:32:49 <lambdabot>     Not in scope: type constructor or class ‘Fix’
13:32:57 <jle`> that's (* -> *) -> (* -> *)
13:33:06 <jle`> newtype Fix f = Fix (f (Fix f))
13:33:12 <jle`> good example :)
13:33:27 <c_wraith> @let newtype Fix f = Fix (f (Fix f))
13:33:28 <lambdabot>  Defined.
13:33:32 <c_wraith> :k Fix
13:33:33 <lambdabot> (* -> *) -> *
13:33:37 <jle`> also a contrived one, newtype OnInt f = OnInt (f Int)
13:33:44 <jle`> @let newtype OnInt f = OnInt (f Int)
13:33:45 <lambdabot>  Defined.
13:33:47 <jle`> :k OnInt
13:33:48 <lambdabot> (* -> *) -> *
13:33:48 <iqubic> Kinds are the weirdest
13:33:53 <jle`> they're aight
13:34:27 <iqubic> jle`: that works because (->) :: * -> * -> *
13:34:49 <jle`> :t OnInt
13:34:50 <lambdabot> f Int -> OnInt f
13:34:52 <jle`> yeah
13:34:54 <geekosaur> they're just the "types" of types
13:35:16 <lyxia> . o O (Fix :: (* -> *) -> *   fix :: (a -> a) -> a)
13:36:09 <iqubic> :t fix
13:36:11 <lambdabot> (a -> a) -> a
13:36:14 <jle`> fix f = f (fix f)
13:36:20 <iqubic> That's cool
13:36:30 <jle`> data Fix f = F (f (Fix f))
13:36:37 <jle`> pretty much the same thing except for that pesky newtype wrapper
13:36:44 <jle`> er, pesky constructor
13:36:49 <jle`> also s/data/newtype
13:39:26 <iqubic> How do you create an object of type Fix?
13:39:40 <c_wraith> the normal way. :)
13:39:48 <monochrom> First pick an f.
13:39:48 <iqubic> Which is?
13:39:58 <iqubic> f is Maybe
13:40:11 <c_wraith> Fix (Just (Fix (Just (Fix Nothing))
13:40:15 <monochrom> OK, do you see the data constructor of Fix?
13:40:20 <iqubic> Oh, yeah.
13:40:21 <c_wraith> err, except with the right number of close parens
13:40:29 <mauke> c_wraith: not in scope: Fix
13:40:30 <monochrom> tl;dr use logical inference.
13:40:37 <iqubic> Why is that even useful ever?
13:40:52 <mauke> oh, wait
13:41:04 <mauke> we have two Fix definitions around :-)
13:41:12 <monochrom> Because catamorphsim :: Functor f => (f r -> r) -> (Fix f -> r) is a thing.
13:41:46 <lyxia> I love this word.
13:42:11 <lyxia> Very greek.
13:42:23 <c_wraith> form of down!
13:42:25 <monochrom> Also the joke version: catmorphism :: Functor f => (f r -> r) -> (Meow f -> r)
13:47:22 <monochrom> Fewer people use Fix but more people use Free for free monads.
13:47:36 * ski . o O ( "The Joy of Cats" )
13:48:04 <cmd-johnson> Hey there, I'm trying to parse 6 digit hex string into a Word8 triplet, is there a standard way of doing that? read happily accepts hexidecimal strings when they start with 0x, but prepending this to every pair of hex characters doesn't seem very nice.
13:48:45 <merijn> cmd-johnson: how much parsing are you doing?
13:48:46 <monochrom> Look for readHex in Numeric
13:51:05 <monochrom> GHC 8.2.1 ghci has changed ":set prompt2" to ":set prompt-cont". This confuses emacs haskell-mode because haskell-mode sends ":set prompt2 λ|" and ghci replies "wut?" and haskell-mode thinks "wut?"
13:51:34 <monochrom> I'm going to just go into my installed copy of haskell-mode and fix that. :)
13:52:34 * hackagebot serokell-util 0.4.1 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
13:53:50 <lysergia> I've got a peristent db schema with "Product" and a "ProductVariant" that has an productId field. Is it possible to select every Product & it's variants like (Product, [ProductVariant]) in a single query? Or do I need to pull them all then manually sort them, or perform multiple queries?
13:54:16 <cmd-johnson> merijn: Right now, I'
13:55:24 <cmd-johnson> merijn: Right now, I'm heading for around 5000 lines parsed via stdin per second, containing various kind of data, including hex-colours.
13:57:46 <monochrom> Eh? It is not because of that.
14:00:42 <merijn> cmd-johnson: Be warned that read is pretty damn slow :)
14:01:39 <jared-w> What would be faster than read, then?
14:02:21 <merijn> jared-w: My default solution would be attoparsec
14:05:50 <merijn> jared-w: For any sort of parsing you should always assume that Read is god awfully slow and ANY parsing library (parsec, megaparsec, attoparsec) is probably going to kick it's add
14:05:53 <merijn> *ass
14:09:41 <jared-w> Good to know. I actually forgot about parsing libraries for a second because it never occurred to me that one would even use read to parse things... whoops
14:11:33 <cmd-johnson> merijn: attoparsec sounds way nicer than the naive approach I had in mind. Thanks for that!
14:12:19 <jared-w> There's also megaparsec and parsec. Any of those will be great. One might be much easier than the others for your specific use case ¯\_(ツ)_/¯
14:13:27 <merijn> jared-w: megaparsec and parsec are probably slower than attoparsec, since they're aimed at good diagnostics for users
14:13:31 <Tuplanolla> Parsec is only around for compatibility.
14:14:05 <merijn> attoparsec is trying to be superfast, but with shitty error reporting. Which makes sense for parsing file formats/protocols that you don't expect humans to write
14:14:09 <trigone> hi! i'm wondering something about classes. maybe it's obvious and i'm just not seeing it right now ... http://lpaste.net/358090
14:14:39 <jared-w> ahh gotcha. I just remembered recently reading about how megaparsec's big update managed to make it almost the same speed as attoparsec for a lot of things (and maybe a bit faster here and there? idk)
14:18:34 <trigone> nobody?
14:21:05 <cmd-johnson> I'll definitely look into those. This whole thing is actually part of my effort to get to know Haskell a bit better and I already have the same program implemented in C++ (not by me though). I'm pretty interested in how the Haskell implementation's performance will compare to that.
14:21:06 <dmwit> trigone: The standard difference is that with the full type you can add constraints to instance heads, whereas for the * -> * class you get to rely on it working on all supplied types.
14:21:16 <geekosaur> ^
14:21:40 <mud> trigone: Not a lot the way they're written. The kind of foo in the second one is different, which restricts which instances you can actually make. But based on just that code that's the only difference. You could add more ... ya constraints and whatever.
14:21:53 <dmwit> trigone: e.g. `instance Monoid a => Monoid (IO a)` say that `IO a` is only a `Monoid` when the contained type is. But `instance Alternative IO` say that `IO a` is a monoid (in another way) regardless of the contained type.
14:22:38 <dmwit> trigone: Each is useful in different situations. See e.g. `Traversable` and `MonoTraversable` for a particularly relevant example.
14:23:11 <ericdwhite> I have a general question: I have one API method that performs some IO and returns IO Either ApiError (ApiResult TypeA) and then another call to another API which needs data from TypeA.  How do you normally go about digging the data out of Tp
14:23:13 <ericdwhite> ype
14:23:16 <dmwit> `MonoTraversable` admits an instance for, say, `ByteString` -- but there are a few things that you can't do with a `MonoTraversable` instance as a result.
14:23:18 <ericdwhite> TypeA
14:23:55 <trigone> dmwit, mud: i understand! thanks a lot :)
14:24:19 <dmwit> ericdwhite: I would use `ExceptT ApiError IO (ApiResult TypeA)` instead, and possibly even `ApiResultT (ExceptT ApiError IO) TypeA` if that's possible.
14:24:57 <trigone> by contrast if i'd needed some constraint on `a` in the method `f`, i'd prefer the latter version, right?
14:25:29 <trigone> (constraint independent on foo)
14:25:52 <dmwit> ericdwhite: See also: https://stackoverflow.com/q/28857745/791604 https://stackoverflow.com/q/33705941/791604 https://stackoverflow.com/q/33005903/791604
14:26:39 <dmwit> trigone: Maybe. Or maybe you'd add that to the class, as in `class Foo f where type Constraint f; foo :: Constraint f a => f a -> Bool`
14:27:36 <ericdwhite> @dmwit thx! Let me read those and then come back if I have more questions.
14:27:36 <lambdabot> Unknown command, try @list
14:27:37 <dmwit> Uh, actually, I think even if you don't do this wizardry version, you'd still prefer the former for this than the latter.
14:27:43 <krail> hello. would you guys review a haskell script i wrote?  It's working, but i don't know if very "haskelly", and i'm wondering what haskell developers would think of it
14:27:51 <dmwit> ?where justask
14:27:52 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:28:15 <trigone> dmwit: hm... but how could i put a constraint on `a` if i don't have "access" to it?
14:28:16 <dmwit> krail: In that spirit, just post (a link to) your code.
14:28:19 <krail> https://pastebin.com/qZs1anNC
14:28:39 <dmwit> trigone: You would do it in the instance declaration.
14:28:58 <krail> it takes a json file of imdb movie id's, does api calls on them, and writes out a file with the movie title and description
14:29:01 <dmwit> trigone: `instance MyConstraint a => C (Foo a) where f = {- something that uses MyConstraint -}`
14:29:43 <trigone> dmwit: yes but i'm talking of in the case when the constraint does not depend on the instance (or does it never happen?)
14:29:53 <trigone> :t sum
14:29:54 <lambdabot> (Num a, Foldable t) => t a -> a
14:30:09 <dmwit> krail: I think I would write `getFields` without do notation or `let`s. Just `Movie { title = unpack $ ..., imdbID = unpack $ ..., ... }`.
14:30:12 <trigone> see there's a constraint on `a` independent from t
14:31:01 <dmwit> trigone: Okay, I think I've lost track of the question now. Can you say the whole setup carefully in one spot again?
14:31:02 <lavalike> krail: you might like to use what's shown in the `changeDir` example here with your record https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
14:32:03 <Fekinox> curious to know if there's a function that returns a function with a unary function applied to each argument, basically of the form (b -> b -> ... -> bn -> c) -> (a -> b) -> (a -> a -> ... -> an -> c)
14:32:06 <dmwit> krail: In `apiCall`, you can update just one field with the syntax `return parsedMovie { desc = unpack $ ... }`; this will preserve any fields of `parsedMovie` that you don't mention.
14:32:41 <Fekinox> it's... not too tough to implement but it's probably already made
14:33:02 <dmwit> Fekinox: There isn't, and there are pretty good reasons that it can't be written, namely: `c` might later get specialized to `b -> d` and wouldn't that be weird?
14:33:19 <Fekinox> fair point, I guess
14:33:36 <dmwit> Fekinox: If you know how many `b`s there are in advance you can write it without trouble. But writing it generically for any number of `b` arguments isn't really feasible.
14:34:02 <krail> dmwit: I'll update those in place. Didn't know that was supported syntax. Thank you!
14:34:41 <dmwit> krail: I think I'd use a proper JSON parser as well, instead of this hand-written and, frankly, fragile-looking stuff for finding the calls to make.
14:34:43 <krail> lavalike: are you refering to the error handling in the changeDir example?
14:34:54 <dmwit> krail: Check out aeson as a pretty decent off-the-shelf solution for that.
14:35:34 <ski> @let infixr1 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (inp ~> outp) f = outp . f . inp
14:35:34 <lambdabot>  Parse failed: Parse error: ;
14:35:38 <krail> dmwit: yeah, the source is a borky thing i picked up that isn't proper json.. seemed like a good excuse to practice text manipulation
14:35:49 <ski> @let infixr 1 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (inp ~> outp) f = outp . f . inp
14:35:51 <lambdabot>  Defined.
14:36:08 <ski> Fekinox : how about `f ~> f ~> ... ~> f ~> id' ?
14:36:27 <dmwit> cute =)
14:36:54 <trigone> dmwit: well if i want to write a method f :: Constraint a => t a -> b, i think i need to write `class C t where`, bc if i write `class C u where f :: u -> b`, i can't put a constraint on the `a` which is implicitly inside of `u`: only the instances have access to it (when u is actually shaped as `t a`). i guess that's the difference: class C u where f :: u -> b does not care if u is `t a` or merely `Int` or whatever
14:37:24 <ski> > (reverse ~> reverse ~> id) (++) "abc" "de"
14:37:24 <dmwit> krail: Okay. Even if it isn't proper JSON, I'd prefer a real parser for whatever format it's actually in. Parsec is a pretty decent starting point if you don't have a good reason to prefer one or the other of the many libraries and tools out there for parsing.
14:37:26 <lambdabot>  "cbaed"
14:38:16 <dmwit> trigone: Agreed on all points under the assumption that type families don't exist.
14:38:53 <dmwit> trigone: Uh, actually, no, I think I don't agree at all. =P
14:39:22 * ski concludes there were zero points to agree/disagree with
14:40:01 <trigone> dmwit: ?
14:40:08 <dmwit> trigone: Okay, so. If there's a connection between two types, then you want to make that connection explicit. Making your class be over * -> * types is one way; type families are another. But you can also have constrained methods with no connection.
14:40:28 <krail> dmwit: I'll check it out, thank you
14:40:47 <shae> Is there something like coderpad.io that has a shared editing *and* ghci in a browser?
14:41:08 <lavalike> krail: nope, to the record update syntax that dmwit also mentioned
14:41:10 <dmwit> trigone: e.g. in `class C u where f :: u -> Int` it is up to the instance provider to check whatever constraints they want on `u`. So I could write like `instance Num a => C (T a) where f = ...`.
14:41:55 <dmwit> trigone: (Compare to `class CArrow tf where f :: Num a => tf a -> Int` and `instance CArrow T`.)
14:42:49 <trigone> dmwit: yeah you said that already, but take the example of class Foldable t where sum :: (Num a) => t a -> a -- how do you write that by writing the class over a simple *? (putting aside type families which i'm not familiar with)
14:43:10 <dmwit> trigone: However, in `sum` there is a connection between two subterms of the method's type. So: `class Traversable t where sum :: Num a => t a -> a` connects the input type `t a` with the output type `a`. This can also be done with type families, as in `class MonoTraversable t where type Sum t; sum :: t -> Sum t`.
14:44:11 <trigone> what i was talking about, are constraints *independent* from the instance, not dependent on each instances's personal choices. `sum` has the same constraint set for any Foldable t.
14:44:46 <trigone> oh that's interesting
14:44:52 <trigone> (the type family thing)
14:45:27 <dmwit> In `class MonoFoldable t where type Sum t; monosum :: t -> Sum t`, `monosum` has the same constraint for any MonoFoldable `t` (namely no constraint).
14:46:26 <trigone> dmwit: yeah but i said *putting aside type families* ^^ we're running in circles, and i think we both agree on the same things :)
14:46:30 <dmwit> Oh, I see you were not objecting, our posts merely crossed paths. Please ignore my response about having the same constraint for any MonoFoldable. =)
14:46:50 <krail> dmwit:  when taking the do notation out of the getFields function, i get this error when setting the url field with:
14:46:53 <krail> dmwit: url = "https://getimdb.herokuapp.com/get/?id=tt" ++ unpack $ source ^. key "id" . _String,
14:47:12 <krail> dmwit: Couldn't match expected type ‘[Char]’
14:47:12 <krail>                   with actual type ‘Text -> String’
14:47:13 <krail>     • Probable cause: ‘unpack’ is applied to too few arguments
14:47:35 <dmwit> Ah, yep, I didn't notice that you were reusing `id`.
14:47:41 <dmwit> I don't object to naming things that get used twice. =)
14:48:01 <krail> cool
14:48:05 <dmwit> However, if you want to inline it both places, the problem you're facing is that `$` and `++` aren't mixing the way you intended.
14:48:14 <krail> yes
14:48:28 <dmwit> So you should write `"..." ++ (unpack $ ...)`, or `"..." ++ unpack (...)`.
14:48:39 <krail> huh, i'll give that a go
14:49:37 <trigone> dmwit: thanks again :)
14:52:23 * hackagebot yesod-auth-hashdb 1.6.2 – Authentication plugin for Yesod. – https://hackage.haskell.org/package/yesod-auth-hashdb
14:52:23 * hackagebot universum 0.6.0.0 – Custom prelude used in Serokell – https://hackage.haskell.org/package/universum
14:54:35 <krail> dmwit: all that works. Thanks!  regarding the api function, since it's doing an (<-) action , is it still posible to put that inline?
14:55:39 <krail> dmwit: something like: desc = unpack $ ( r <- get $ url parsedMovie  ) ^. responseBody . key "storyline" . _String
14:55:56 <krail> dmwit: the compiler doesn't like that
14:56:55 <boj> ( get $ url parsedMovie >>= \r -> doSomethingWith r )
14:56:57 <trigone> is there an existing method to reduce the boilerplate associated with using DSL+Free? for every DSL constructor, i gotta create a function which liftF's the constructor into the Free monad so i can properly use it. is there any way around this? some auto-generated code or whatever?
14:57:47 <boj> krail: the "r <-" bit isn't a final expression, nor inside do-notation, which is why that is failing
14:58:31 <krail> whoa 
14:58:43 <krail> thats cool
14:58:52 <krail> i'll give that a go
15:02:28 <dmwit> krail: No, I wouldn't inline that one.
15:07:20 <trigone> anyone?
15:27:50 <dmwit> Does `setLocaleEncoding` work in ghci? I can't get it to do anything...
15:28:12 <dmwit> Like, `getLocaleEncoding` reports the encoding I set, but `putStrLn` keeps using utf8 no matter what I pick.
15:29:59 <dmwit> I'm trying `setLocaleEncoding char8 >> putStrLn "\51088"` and expecting this to behave like `putStrLn "\144"`, but I get an actual Japanese character instead.
15:31:14 <monochrom> That's probably because setLocaleEncoding doesn't change the settings of existing handles such as stdout.
15:32:52 <dmwit> How come it works in a compiled program?
15:33:11 <monochrom> Ah then I don't know.
15:33:46 <dmwit> Interesting: it works *if* I call `setLocaleEncoding` before printing anything, but not if I print something and then try to change the encoding.
15:33:54 <dmwit> nasty!
15:38:06 <c_wraith> it's global mutable state.  of course it's nasty. :)
15:38:07 <jared-w> hmm, I'm guessing it's got to do with some weird magic in the extended defaulting rules GHCi has?
15:39:17 <dmwit> I'll be honest: I wouldn't have expected this state to be connected to handles at all.
15:39:46 <geekosaur> encoding state is certainly connected to handles
15:40:02 <c_wraith> dmwit: does your observation hold in compiled programs?
15:40:23 <c_wraith> If you set the encoding after calling putStrLn does it work in a compiled program?
15:40:35 <dmwit> Aha, there is `hSetEncoding` which seems to do the trick.
15:40:47 <dmwit> c_wraith: no
15:40:47 <geekosaur> in theory you could change it whenever a handle has nothing buffered. in practice I suspect it's easier to just require it to be done before any I/O
15:41:16 <c_wraith> dmwit: I think geekosaur is right.  It just is a no-op if the encoding has been used
15:41:34 <c_wraith> though I'd prefer it signal its failure in one way or another...
15:42:06 <duog> Hi all, I know one can use Codensity to right associate monadic binds, is there a similar tool to left associate monadic binds?
15:42:59 <c_wraith> duog: that's a good question and I don't know the answer.  I'm curious why you want to do that, though.  Do you have a use case where it works better?
15:43:29 <duog> c_wraith: I'm not sure, it looks like it
15:45:02 <dmwit> c_wraith: hSetEncoding seems to work reliably. Presumably the locale encoding is consulted only when opening a handle, which would more or less explain all the behavior I'm seeing (under the assumption that runhaskell/ghci speculatively open the standard handles, but compiled programs wait until you use them).
15:45:23 <c_wraith> dmwit: that does sound probable.
15:46:29 <c_wraith> dmwit: actually, it's not even speculative in ghci.  It shares stdin/stdout with the interpreter process.  once you type something in, it's used stdin.  Once it displays the welcome message, it has used stdout
15:46:41 <dmwit> right
15:50:25 <srpx> Hey guys, help me think. EAL terms have only linear functions (i.e., function vars can only appear once). You can duplicate terms with `let`, but only if those terms are closed. Under that setup,
15:50:52 <srpx> as long as the starting variables are all different, doesn't that mean that variable capture is impossible?
15:52:34 * hackagebot Villefort 0.1.1.10 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
15:56:39 <Welkin> someone realesed an application on hackage?
15:56:45 <Welkin> released*
16:21:40 <Axman6> there are plenty of there
16:21:44 <boj> i suppose a web app up there is kind of odd, but not really much different than say, hledger, or pandoc
16:21:48 <Axman6> hledger for example, warp too
16:41:07 <ontop> Hey guys, the regex libraries in Haskell seem insane. How do I just get the subgroup matches from a match? Do I really have to do :: (String, String, String, [String]) to get these?
16:41:13 <ontop> Surely there's a less... ridiculous way :D
16:42:48 <c_wraith> no one really uses regex libraries in Haskell, which is why the ones that exist are insane.
16:42:58 <ontop> How do you not use regex libraries? :|
16:43:07 <Axman6> by using parsers
16:43:34 <ontop> Seems... like it'll be harder.
16:43:38 <Axman6> which are nearly universally better than regexes, except in the case where you need to allow a user to provide a pattern to search for in N pplication
16:43:49 <Axman6> in an application*
16:44:00 <ontop> I mean - are they succint enough? I don't want to make anything huge here.
16:44:16 <ontop> I've got a one liner now, with some insanity to munge around the poor interface.
16:44:21 <Axman6> they're maintainable, which is more important
16:44:34 <ontop> Well, let me explain my use case and you can tell me if it's a good fit for a parser
16:44:58 <ontop> I've got some crap data coming in from crap Trello. And sometimes the title of the card will have a (#) where # is 0-9 at the start of it.
16:45:27 <ontop> So the regex looks something like ^\(([0-9]+)\)
16:45:32 <ontop> Is this a good time to use a parser?
16:46:45 <Axman6> dropWhile (/= '(') *> some digit?
16:48:25 <ontop> Could be two digits :\
16:48:32 <ontop> I suppose I could dropWhile and takeWhile
16:48:52 <ontop> Though, it's sorta ugly if the thing isn't there. Since it isn't quite frequently.
16:49:07 <Axman6> some gives you 1 or more of the values parseed by the parser passed to it
16:49:30 <ontop> Oh, I was confused by the syntax there.
16:49:52 <Axman6> there probably needs to be a char '(' in there
16:50:53 <ontop> Where does *> come from?
16:51:03 <Axman6> Applicative
16:51:13 <Welkin> :t (*>)
16:51:14 <lambdabot> Applicative f => f a -> f b -> f b
16:51:20 <Welkin> *> is like >>
16:51:48 <ontop> Ah. I'd forgotten.
16:52:48 * hackagebot uri-templater 0.2.2.0 – Parsing & Quasiquoting for RFC 6570 URI Templates – https://hackage.haskell.org/package/uri-templater
17:01:51 <ontop> If I have a newtype that's just a string basically, is there any way for me in regular syntax land to deconstruct it back out? Without a case/if/function etc?
17:02:40 <ontop> I guess a let statement would work right?
17:07:58 <koz_> ontop: You could implement IsString for it and use OverloadedStrings, maybe?
17:08:06 <lyxia> how's that better than using a function
17:08:47 <koz_> lyxia: No constant unwrapping/rewrapping to work with it?
17:08:50 <geekosaur> why would you make a newtype if you don't want to deconstruct it
17:09:01 <geekosaur> koz_, OverloadedStrings only applies to constants
17:09:52 <koz_> geekosaur: Oh, derp.
17:09:57 <koz_> Shows what I know, lol.
17:10:24 <ontop> geekosaur: I've been given the newtype, and disagree that it should have been made in the first place. Not in my ability to change.
17:10:41 <dsal> What's the deal with language extensions, btw?  Do they get folded back into the language?  Should they be avoided in general?
17:10:46 <dsal> Feels kind of wrong.
17:10:50 <ontop> ^
17:10:57 <Welkin> dsal: many of them are almost standard these days
17:11:05 <koz_> dsal: It depends on the extension and what you're trying to do.
17:11:30 <geekosaur> there is a language standard. Extensions do get proposed for the standard, but the keepers of the standard are fairly conservative
17:11:37 <dsal> Yeah, I realize my question was a bit general.  I want to write more standard stuff in general.
17:11:40 <koz_> There's a world of difference between FlexibleContexts and UndecidableInstances. :P
17:11:55 <pacak> dsal: If you like to think of haskell == ghc - use whatever you like, just make sure you understand the meaning.
17:12:01 <geekosaur> whereas ghc is all about type system experimentation and tends to move quickly, much more quickly than standards bodies
17:12:05 <Welkin> really, there is nothing else but ghc
17:12:08 <pacak> dsal: If you think haskell /=  ghc....
17:12:14 <dsal> Is there a haskell /= ghc?
17:12:16 <Welkin> so it doesn't make sense to *not* use extensions
17:12:19 <Welkin> use as many as you need
17:12:31 <dsal> Is something like OverloadedStrings likely to become standard?
17:12:42 <Welkin> dsal: no, because it is useful to turn it on and off
17:12:54 <geekosaur> additionally, there are persistent questions about some of the most common extensions (notably MultiParameterTypeClasses, which means all of mtl)
17:12:55 <dsal> When is it undesirable?
17:13:16 <dsal> OverloadedStrings is kind of intuitive to me coming from go.
17:13:24 <ontop> Hey, a Go friend :D
17:13:27 <geekosaur> when it forces polymorphism down your throat and thus requires you to insert type annotations
17:13:29 <dsal> heh
17:13:47 <dsal> Ah, I see.  I've barely used it and haven't run into that.
17:13:52 <koz_> geekosaur: That's a ... very interesting mental image. :P
17:14:53 <dsal> But is there more than one haskell these days?
17:14:56 <dsal> (implementation)
17:15:06 <ontop> dsal: No. There's barely the one Haskell.
17:15:42 <amf> Is there any library / typeclass that allows you to find the "index" of the record in a data type. As in, `data A = A { a1 :: Int, a2 :: Char }; let a = A 1 'A'; dindex a a2` would be 2?
17:17:59 <amf> Use case: I have some custom types with lots of fields 50+, and some documentation that is referenced by the types "slot", I could do it by hand, but that seems silly when I have so many fields
17:20:05 <MarcelineVQ> http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Data.html provdies way to refer to parts of datastructures, I've not used them though. things like  indexConstr, constrIndex
17:20:18 <MarcelineVQ> there's probably a tutorial or two out there about it
17:20:23 <koz_> amf: Lenses might also help.
17:22:36 <lyxia> Data.Data should be deprecated in favor of GHC.Generics
17:24:43 <MarcelineVQ> generics always looked like an awfully big hammer, but that's a pretty uninformed opinion
17:29:25 <lyxia> http://lpaste.net/358092 is what it might look like
17:33:07 <Rotaerk> I think Data.Data should be kept, and then expanded to Data.Data.Data.Data
17:33:48 <monochrom> haha
17:36:49 <amf> interesting... where is Nat defined?
17:38:05 <pacak> Data.Data and GHC.Generics are kind of different. Main problem with generics - superlinear cost to compile them as you increase number of fields/constructors.
17:38:21 <amf> getting: Failed to load interface for ‘GHC.TypeNats’
17:38:35 <amf> pacak: not concerned about compile time, concerned about having to implement by hand time
17:38:47 <ggVGc> yeah
17:38:49 <ggVGc> I hate that time
17:39:02 <geekosaur> amf, what ghc version?
17:39:20 <amf> geekosaur: 8.0.2
17:39:20 <MarcelineVQ> TypeNats is 8.2 but you can get them from GHC.TypeLits in earlier ghc iirc
17:39:28 <geekosaur> ^
17:40:44 <pacak> amf: I had a module that took ~10+ minutes to compile that had nothing in it but a single datatype declaration + some generic derived stuff. And it wasn't especially stupid datatype either.
17:42:28 <pacak> amf: I'm still not sure if I understood your question... What exactly are you trying to make?
17:44:52 <amf> lyxia: how do you handle the `Proxy a`? I have all the extensions enabled and a custom type deriving Generic, but I'm not sure how to call `arity`
17:47:05 <lyxia> amf: arity (Proxy @MyHugeRecord)
17:48:05 <dsal> \x y -> union (difference x y) (difference y x) = (∆)    -- what is that called?  I've not seen that used before.
17:49:34 <lyxia> amf: actually that shouldn't have been :+:... I corrected it (the previous version counted constructors). http://lpaste.net/358092
17:49:58 <lyxia> amf: arity (Proxy :: Proxy MyRecord) without TypeApplications
17:50:12 <MarcelineVQ> dsal: you'd have to look at the rest of the code, it's referring to an operator ∆ which will be defined elsewhere
17:50:22 <amf> lyxia: hazah! that is very neat
17:50:38 <MarcelineVQ> > let (∆) a b = a + b in 5 ∆ 2
17:50:41 <lambdabot>  7
17:50:53 <dsal> MarcelineVQ: This is the operator definition from UnicodeSyntax
17:51:20 <lyxia> amf: Compilation time is a concern with this flavor of generics, it's true.
17:51:23 <dsal> I can see what it does but it seems kind of unusual.
17:51:32 <dsal> It's like the anti-intersection.
17:51:54 <dsal> "symmetric difference"
17:52:11 <amf> lyxia: now is there a way to find which arity of a record?
17:52:17 <dsal> Oh, it's supposed to be △ not ∆ 
17:52:22 <MarcelineVQ> I've no clue what you're referring to, the function, the delta, some specific webpage with all this info on it..
17:52:41 <dsal> Sorry, it's here:  https://hackage.haskell.org/package/containers-unicode-symbols-0.3.1.1/docs/Data-IntMap-Strict-Unicode.html#v:-8710-
17:52:56 <dsal> It was a from a doc describing the UnicodeSyntax extension.
17:55:24 <MarcelineVQ> dsal: alrighty, so are you asking what the function  (∆) :: IntMap α -> IntMap α -> IntMap α   does?
17:55:42 <lyxia> amf: what do you mean
17:55:47 <dsal> Oh, it's neither delta nor △ -- man, math has too many symbols.    Δ ▵ ∆ Δ
17:56:09 <dsal> MarcelineVQ: No, I think the definition was clear, I just didn't know "symmetric difference"
17:57:27 <amf> that was terribly worded, given a fully evaled `data A = A { a1 :: Int, a2 :: Char, a3 :: Int32 } deriving (Generic, Show)`, and i want to know the arity of a2?
17:57:47 <c_wraith> dsal: just think of it as set xor. :)
17:58:21 <lyxia> amf: you mean the fact that a2 is the second field of A?
17:58:27 <dsal> I'm going to start calling it outersection.  We'll see if that catches on.
17:58:37 <amf> im going to be displaying some parsed data and i want to know the arity of any fields so that i can look that up in the documentation array
17:58:55 <MarcelineVQ> I think the triangle is pretty smart, delta d for difference, triangle suggesting things falling to either side
17:59:02 <lyxia> amf: "arity" is the wrong word for that. "index" or "position" perhaps
17:59:13 <amf> yeah, position would be better
18:05:21 <dsal> MarcelineVQ: Yeah, I think it makes sense.  Some of this is clearly better written down than typed since ▵ ∆ Δ are all different characters.  The first one came up in a search for symmetric difference and the docs for the unicode module calls the character it chose "increment" (which, I think, is just \Delta)
19:53:15 * hackagebot bizzlelude 0.0.3 – A lousy Prelude replacement by a lousy dude – https://hackage.haskell.org/package/bizzlelude
20:21:41 <crucify_me> hi regarding the upvoted answer here: https://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell   : 
20:22:05 <crucify_me> I'm trying to understand the answer vis a vis this book example https://ptpb.pw/8EEy
20:22:35 <crucify_me> I don't understand ...
20:23:28 <crucify_me> how User (which is lazy according to the answer), uses the newtypes ,which are strict.
20:25:57 <crucify_me> I'm hoping for a step by step explanation
20:26:15 <crucify_me> thanks
20:27:09 <boj> newtypes actually get erased, so point directly to the value they represent. data has an extra layer of indirection, so can lazily compute the value on demand
20:28:02 <iqubic> Data als allows multiple constructors.
20:28:15 <iqubic> Either and Maybe must be data for just that reason
20:28:45 <crucify_me> iqubic, haven't gotten to Either and Maybe, though
20:28:55 <crucify_me> I do get your first point.
20:29:58 <crucify_me> boj so they get erased, but data User has them stored to be used later?
20:30:11 <crucify_me> or User has them stored
20:30:35 <boj> essentially. this is what they mean when they say "thunks" - uncomputed expressions
20:31:01 <crucify_me> right, I heard of that. is that similar to a closure?
20:32:44 <boj> i believe that is a different concept? anonymous function, lambda, etc.
20:34:10 <crucify_me> boj so insofar that newtype "renames the original type" , is the original type in the book example String and Integer? ie. what do they mean by "renaming" 
20:34:52 <dsal> I think of closures as binding locals as well.
20:36:16 <boj> crucify_me: you typically "wrap" basic types in a newtype to get an extra level of type safety. i.e. newtype Email = Email { unEmail :: String }
20:36:25 <boj> internally it is still a String
20:37:57 <boj> given data Fullname = Fullname { unFullname :: String }, updateFullname :: Fullname, now you get an error if you try updateFullname (Email "my@email.com")
20:38:56 <boj> s/data/newtype
20:39:47 <boj> at compile time that all gets erased though, and your value is a raw String that is strictly evaluated
20:40:21 <crucify_me> boj thanks one moment please
20:43:10 <boj> data on the other hand can have multiple constructors. that means a value you are passing around can't be a single thing, so it gets an extra level of indirection
20:43:25 <boj> data Maybe a = Just a | Nothing
20:43:31 <boj> Maybe is pretty straightforward
20:43:39 <crucify_me> extra level of indirection?
20:43:52 <ski> crucify_me : "is that similar to a closure?" -- yes
20:44:07 <ski> dsal : that's not necessary. it just needs to close over some non-locals
20:44:10 <boj> we can't determine at compile time that "let v = getAMaybe :: Maybe a" is (Just a) or Nothing
20:45:16 <boj> i'm basically saying "now you have lazy values"
20:45:55 <crucify_me> ok hold on ...
20:46:47 <ski> crucify_me : do you know `case' ?
20:47:38 <MichaelBurge> If adding -O to your program causes it to have different behavior, that's always a compiler bug right? (Or a bug in a library if it exports rewrite rules.)
20:48:34 <ski> MichaelBurge : i'd say so
20:48:35 <crucify_me> so with data, there is indirection, which means that in this case User may be registered or unregistered. right?
20:49:24 <crucify_me> yeah I'm learning case statements with predicates and such ski
20:49:29 <ski> well, typically people by "indirection" means an extra "layer" that one has to go through, in order to access some data
20:50:09 <ski> > case Just undefined of Nothing -> "none"; Just _ -> "some"
20:50:10 <lambdabot>  "some"
20:50:13 <ski> > case undefined of Nothing -> "none"; Just _ -> "some"
20:50:15 <lambdabot>  "*Exception: Prelude.undefined
20:50:42 <ski> trying to match an `undefined' here fails
20:50:47 <ski> however
20:51:09 <ski> @let newtype Username = MkUsername String
20:51:10 <lambdabot>  Defined.
20:51:32 <ski> > case MkUsername undefined of MkUsername _ -> "name"
20:51:34 <lambdabot>  "name"
20:51:38 <ski> > case undefined of MkUsername _ -> "name"
20:51:40 <lambdabot>  "name"
20:52:31 <ski> trying to "peek inside" a constructor (`MkUsername') for a `newtype', in an `undefined', is no problem
20:53:08 <ski> this is because, at run-time, there is no representation for `MkUsername'. it's just gone, you're just dealing with a `String' (undefined in this case), doing nothing with it
20:53:31 <crucify_me> ski very sorry I'm a bit confused
20:54:40 <ski> if you use a `data', then (even if there's only one data constructor) there is a representation of that at run-time. so, if you try to match a `undefined' with a pattern involving that data constructor, it will try to evaluate the `undefined' (in order to reach inside the representation of the data constructor) -- but that fails
20:54:56 <ski> crucify_me : ok ?
20:58:09 <crucify_me> hold on please
20:58:12 <boj> these details probably aren't that important to note really
20:58:24 <boj> at least not until you get further into haskell
20:59:11 <crucify_me> I need to understand it just based on how the data constructor User utilizes the two newtypes, and when... thanks for all the help
21:00:00 <crucify_me> I don't understand the part about the undefined and where it came from
21:00:33 <boj> it's a function you can use to stub things as "i'll add the real logic later" - it lets things typecheck without filling in blanks
21:00:59 <crucify_me> got that
21:01:18 <boj> ski was using it an example to show the difference between how a newtype and data get evaluated
21:02:31 <boj> anything that needs to "reach in" and actually evaluate undefined will error out and fail
21:02:55 <crucify_me> a newtype is erased, meaning that its abstraction by naming it quickly is discarded and the String or Integer value is stored in the User in a "raw" form  ?
21:03:14 <boj> we may have overexplained things
21:03:16 <geekosaur> a newtype is a note to the typechecker
21:03:26 <geekosaur> a data is an actual "thing"
21:03:28 <boj> as a programmer, you still have a newtype to work with
21:03:37 <boj> as a compiled program, it is gone
21:04:55 <crucify_me> geekosaur, could you elaborate on "a note to the typechecker" ?
21:05:26 <geekosaur> I wonder if you are overthinking thos
21:05:45 <boj> (RegisteredUser (Username name) (AccountNum acctNum)) is still a data type with two newtypes in it. you still need them to pattern match on, or pass to functions which safely manipulate them
21:05:47 <crucify_me> its happened before
21:05:48 <geekosaur> newtype exists only for the typechecker. it has no other existence.
21:06:33 <geekosaur> newtype Foo = MkFoo Int = "hey typechecker, when you see MkFoo, pretend the Int is a Foo"
21:06:40 <geekosaur> and that is *all* it does
21:06:50 <boj> checkUsernameLength :: Username -> Bool; checkUsernameLength (Username username) = length username >= 10
21:07:33 <geekosaur> now, that pretense enables some other things (specifically, you can give it different typeclass instances). but there is no MkFoo in the final program, only the Int
21:07:54 <geekosaur> once the typechecker is done with Foo and MkFoo, they cease to exist
21:08:17 <geekosaur> leaving the Int that was all that was actually there
21:12:23 <crucify_me> but it is a form of assignment, because User winds up using both the String and the Integer in one of the cases (RegisteredUser)
21:12:27 <crucify_me> right?
21:13:12 <geekosaur> huh?
21:13:14 <crucify_me> its it form of temporary assignment, just to get the raw data into the User data type
21:15:20 <boj> if i understand your goal crucify_me, that is the gist of it yes
21:15:47 <boj> you can't put a raw String into User, it has to be a Username which wraps a String (newtype)
21:17:41 <crucify_me> thanks ALL    I can work with that .. one thing ...
21:18:26 <crucify_me> why is newtype referred to as strict? is it because it doesn't hang around long enough to be used in lazy evaluation?
21:18:50 <boj> right, that was kind of what we explained. the type gets erased at compile time, and what is left is a raw pointer to the actual value
21:19:10 <boj> nothing to evaluate, so no laziness
21:19:32 <crucify_me> the raw pointer is more like in a machine language?
21:19:49 <boj> yeah
21:20:01 <crucify_me> excellent really appreciate it .
21:20:17 <geekosaur> something liek that. the point is more that a data introduces *more* laziness; a newtype doesn't
21:20:55 <geekosaur> because if I have data Foo a = MkFoo a -- the possible "states" here are: bottom, MkFoo bottom, MkFoo someValueHere
21:21:33 <geekosaur> if it's a newtype, that newtype only exists in the mind of the typechecker, so it's either bottom or someValueHere --- same as if you didn't have the newtype
21:22:10 <geekosaur> the first bottom was introduced by the data, because the "slot" occupied by MkFoo could be undefined/nontermination
21:23:16 <boj> well, i definitely learned some better ways to explain all that today
21:23:42 <ski> crucify_me : there's no assignment present, only (matching and) binding
21:24:04 <ski> "assignment" means putting a value in a mutable location/box
21:24:47 <crucify_me> ok I understand most of everyone's comments except for the bottom aspect which is foggy
21:25:18 <crucify_me> as a potential state
21:25:19 <ski> "bottom" means the "value" of an expression which doesn't terminate normally
21:25:33 <ski> such as an infinite loop, or a pattern-match failure
21:26:23 <crucify_me> right ok so its really a type of failure. we would hope for a value I guess
21:26:32 <boj> yep
21:26:33 <ski> (for the purposes of determining the semantics (meaning) of evaluating an expression, these are considered equivalent. this is called denotational semantics. it is concerned with the "what", the value, not the "how", how to get to it)
21:26:53 <malkser> How can I write a script that will filter out a .txt file that is similar to: https://pastebin.com/FMQ8BZLM but I only want the values (User Name, User Number) 
21:27:07 <ski> so, in order for every (well-typed) expression to have a value, we invent this fake value, "bottom"
21:27:40 <boj> malkser: you probably want to look at parsers, like parsec, attoparsec, etc
21:28:12 <malkser> boj: I only want the values beetween () then , seperated in csv file
21:28:34 <boj> @hackage attoparsec
21:28:34 <lambdabot> http://hackage.haskell.org/package/attoparsec
21:28:39 <crucify_me> ski right so if you don't finish the patterns with a ' _ ' wildcard, you could potentially have a bottom
21:28:52 <ski> yes
21:28:56 <ski> now, for a `newtype' such as `Username', `MkUsername un' is represented in the same way as `un' itself
21:29:21 <crucify_me> I dont understand the 'un' business
21:29:37 <malkser> boj:  not sure how that would work in this case
21:29:55 <ski> so, `MkUsername _|_' is represented the same as `_|_' (an ascii representation of ⌜⊥⌝, which is the traditional symbol used in den. sem. for "bottom")
21:30:26 <ski> so, denotationally speaking, `MkUsername _|_' is equal to `_|_', because `Username' is a `newtype'
21:30:40 <boj> malkser: i imagine you would consume the file, and then parse the relevant bits you want with attoparsec, then dump the result into a csv
21:30:55 <ski> therefore, in `case undefined of MkUsername x -> ..x..' the match will succeed (binding `x' to `_|_')
21:31:01 <boj> malkser: if it's a huge file, using some streaming library (pipes, conduit)
21:32:16 <ski> otoh, if `Username' had been a `data' type, then `MkUsername _|_' would have been represented differently from `_|_'. in the former case, we could "unwrap" the `MkUsername', in the latter case we can't (we just get stuck in the "beer trap", trying)
21:32:48 <ski> crucify_me : `un' is just a random variable name ("uSER nAME")
21:33:05 <ski> crucify_me : makes any sense at all ?
21:33:23 <crucify_me> ski I'm losing you but got a lot of this session. could we pick up on it again some day?
21:33:34 <ski> sure
21:33:45 <crucify_me> thanks !
21:34:23 <ski> np
21:48:52 <halogenandtoast> Program design question. I'm trying to program a game. The game has 9 factions, these factions have unique rules, units, pieces, actions, etc. Is there a suggestion on how best to model this?
22:28:42 <halogenandtoast> I wonder if it would make sense to make each faction it's own type and then have a typeclass to represent the shared behaviour
23:00:50 <norc_> https://gist.github.com/anonymous/e38ecb4d279d338c28ecab8f52f68898 what's that percentage doing there in the output?
23:03:01 <cocreature> norc_: are you sure that this is not just your shell prompt?
23:03:35 <cocreature> putChar won’t insert a newline so whatever comes next, i.e., the shell prompt, will be printed directly after the char
23:03:38 <pacak> Looks like shell to me.
23:03:47 <norc_> cocreature: http://i.imgur.com/w3flJMZ.png
23:03:56 <norc_> Could absolutely be, Im not making any assumptions.
23:04:30 <cocreature> try "echo -n 3"
23:05:05 <norc_> blob:http://imgur.com/e6ec377e-a0e2-4452-ae01-d697b5ae3aeb
23:05:07 <norc_> err
23:05:11 <norc_> http://i.imgur.com/bKDHD9i.png
23:05:20 <cocreature> looks like that is your shell
23:05:40 <norc_> cocreature: Ohh it could be \c ?
23:05:51 <norc_> Seems like it. Whatever that may be.
23:05:56 <cocreature> not sure what \c is supposed to be.
23:06:11 <cocreature> your shell seems to display % if your program doesn’t output a trailing newline
23:06:59 <norc_> cocreature: Yeah, \c seems to be a posix thing for exactly that
23:08:57 <cocreature> \c seems to be used to suppress newlines even if they are actually present in the output. your program just doesn’t output a newline
23:24:21 <geekosaur> zsh outputs a reverse video (if it knows how) % to indicate that the previous program didn't end its output with a newline
23:24:41 <geekosaur> I've heard at least some recent versions of bash may do something similar
23:53:57 * hackagebot miso 0.7.5.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
23:53:57 * hackagebot digit 0.5.0 – A data-type representing digits 0-9 and other combinations – https://hackage.haskell.org/package/digit
