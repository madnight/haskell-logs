00:05:01 <kuribas> what's the _functional_ way to create a text editor?
00:05:48 <bvad> kuribas: https://github.com/yi-editor/yi might give you an idea :)
00:05:52 <kuribas> For example, a function (Text -> Pages (Paragraphs (Lines (Words)))) would be pretty functional, but updating a word in a 1000 page text will require recalculation of the whole text.
00:06:20 <cocreature> ropes
00:07:18 <u-ou-> is that like really tough strings
00:07:39 <kuribas> would it be possible to create combinators that automatically handle the dependencies?
00:07:54 <cocreature> I’m not sure if the data structures even change fundamentally when modelling things in a functional language
00:07:57 <ubsan> ropes are super cool
00:08:06 <cocreature> you can’t just use a vector in imperative languages either since you want fast inserts
00:08:12 <kuribas> cocreature: why not sequence?
00:08:35 <cocreature> afaik Sequence is pretty bad when it comes to constant factors
00:11:08 <cocreature> norc_: https://github.com/ndmitchell/hoogle#command-line-version explains how to use hoogle offline (hoogle generate). if you use stack, you can also use "stack hoogle"
00:12:14 <norc_> cocreature: Wow. I just tried `stack hoogle ...`, and it even installs it automatically.. a lazy language for lazy people.
00:13:20 <kuribas> cocreature: I was actually thinking about music notation, which is much more complex.
00:14:27 <kuribas> cocreature: Which is basicly a function from "MusicEvents -> GraphicalBars"
00:15:15 <kuribas> So updating an event (like changing a music note), would only need to update the bars that are affected.
00:16:03 <cocreature> that’s not really different from changing a character in the middle of a text document
00:16:47 <u-ou-> how do we do that in haskell? (change a character in a book without reevaluating the whole book)
00:18:14 <cocreature> u-ou-: use a datastructure that supports efficient modifications :)
00:19:01 <kuribas> cocreature: but modifying it is still imperative?
00:21:06 <cocreature> depends on the data structure, usually it’s some kind of tree (or a tree + vectors in the case of ropes) and then updating it is not significantly different from updating Data.Map or something like that
00:23:40 <cocreature> and having a persistent data structure means that you can get undo for free which is pretty neat
00:29:12 <iqubic> Can Haskell parsers deal with weird things like the APL symbols.
00:30:16 <tdammers> iqubic: you mean parsers written in Haskell? or parsers written to parse Haskell?
00:30:37 <liste> iqubic: parsers written in Haskell? sure. APL symbols are just characters like any other
00:32:48 <iqubic> tdammers: I'm talking about Haskell parser combinator libraries.
00:34:23 <kuribas> iqubic: of course
00:34:29 <tdammers> iqubic: no problem there. APL symbols are just unicode codepoints, any Haskell parser-combinator that can deal with String (or Text) will be able to consume them; and if you use ByteString instead, you get more control even, but you have to do the charset stuff yourself
00:34:38 <tdammers> iqubic: short answer, absolutely no problem whatsoever
00:35:09 <kuribas> cocreature: I know emacs can become very slow with long lines.
00:37:52 <ertes-w> lo
00:38:39 <kuribas> cocreature: so I was thinking it wouldn't be to hard to create a combinator that tracks dependencies.
00:38:43 <cocreature> ertes-w: now that you’ve dropped the "e" at the beginning of your greeting, I wonder when you will start dropping the "l" :)
00:38:58 <cocreature> kuribas: I’m not sure what dependencies you are talking about here
00:39:00 <merijn> monochrom: I think you misunderstood my question last night. That cheat sheet shows what *haddock* supports, however the package page listing the package description is generated by Hackage atm and (on paper) is supposed to support all of Haddock markup, but doesn't last I checked
00:39:27 <kuribas> cocreature: well, for example in a text document, which positions change when editing a word.
00:41:29 <kuribas> cocreature: so the combinator would continue evaluating new positions, until the new position at a word matches the old one.
00:41:47 <ertes-w> cocreature: how do you know which one i'm gonna drop?
01:23:19 <purpleP> Hi, can someone help me with ghc-mod
01:23:19 <purpleP> ?
01:23:37 <purpleP> It seems like it can take read input from stdin
01:24:00 <purpleP> but it gives me this error instead ghc-mod: <stdin>: hGetLine: end of file
01:24:52 <purpleP> I run it with this command cat src/Changes.hs | ghc-mod --with-stack "stack" --map-file "file.hs" check -
01:42:02 * hackagebot relational-query 0.8.8.0 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
01:42:02 * hackagebot ginger 0.6.0.2 – An implementation of the Jinja2 template language in Haskell – https://hackage.haskell.org/package/ginger
03:08:35 <goalboy> Hello
03:09:28 <goalboy> I found all images in the online free book are broken, do you also have this problem?
03:10:18 <goalboy> Like this image "http://s3.amazonaws.com/lyah/bird.png", it got the error of "AllAccessDisabled".
03:18:37 <gehmehgeh> goalboy: Got the same error
03:46:01 <mekeor> goalboy: are you referring to the book "learn you a haskell for great good"? i guess it would be good to mail bonus@learnyouahaskell.com as described http://learnyouahaskell.com/faq
03:50:08 <goalboy> mekeor: Thanks for advice. I'll do that soon.
04:16:18 <toadofsky> Strange, I wonder how dependency resolution works: http://lpaste.net/3227152153206325248
04:16:55 <toadofsky> Apparently HTTP-4000.3.7 doesn't satisfy HTTP >=4000 ?
04:18:27 <cocreature> toadofsky: why are you manually compiling Setup.hs instead of using "cabal build"?
04:18:46 <toadofsky> ah, because I didn't know better. My mistake
04:19:09 <cocreature> try "cabal install --only-dependencies" followed by "cabal build"
04:19:55 <toadofsky> Thanks
04:42:24 * hackagebot attoparsec-time 0.1.4 – Attoparsec parsers of time – https://hackage.haskell.org/package/attoparsec-time
05:10:47 <myname_> :q
05:29:29 <athan> Are there any bindings to `dup()` for creating a new file descriptor? I know I asked this before ._. - if not, do you think an FFI would be too hard to try?
05:30:06 <merijn> @hackage unix
05:30:07 <lambdabot> http://hackage.haskell.org/package/unix
05:30:09 <merijn> athan: ^^
05:35:03 <athan> Ahh!! Thank you merijn, sorry I missed that
05:36:18 <cocreature> athan: ffr, http://hoogle.haskell.org/?hoogle=dup%20is%3Aexact
05:41:22 <rcat> my distro (Arch) enables dynamic linking of Haskell libs in GHC by default, how can I force static linking back? from cabal or ghc-options?
05:42:05 <cocreature> rcat: actually Arch doesn’t do that. they distribute dynamic libs but GHC still links statically by default which is why things are broken
05:42:44 <merijn> rcat: There was an article on the arch wiki iirc
05:42:52 <athan> Why isn't Fd an instance of IODevice? https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-IO-Device.html#v:dup
05:42:55 <merijn> rcat: Also, yell at the arch maintainers to stop doing stupid shit
05:43:00 <rcat> ah!, I see, yeah I read somewhere about the mess with cabal that can't handle at the same time the same lib in statica and dynamic fashion...
05:43:12 <athan> or really... why aren't there any instances?
05:43:39 <rcat> merijn: yeah, I think I'll start writing in the mailing list, for distributing packages in the Arch repos, I don't really care
05:43:42 <cocreature> rcat: basically nuke everything Haskell related that you installd via pacman except for ghc and ghc-static, get a statically linked cabal from somewhere and everything will work
05:43:47 <rcat> but for writing my own code it's a real mess
05:44:01 <merijn> athan: Not portable
05:44:08 <athan> ahh hm
05:44:11 <merijn> athan: File descriptors are only a thing on unix
05:44:28 <merijn> athan: That instance would have to be defined in the unix package
05:47:01 <athan> hmm, I like the idea though, thank you!
05:47:11 <yushyin> rcat: I just use stack (from the community repository) for all dev stuff (and even let stack download its own ghc).
05:49:07 <cocreature> merijn, athan: ghc does actually provide an instance in "GHC.IO.FD" which is in base
05:51:20 <Clint> iqubic_: well, you having logs would be a good clue
05:52:00 <rcat> yushyin: yeah, I know, it's jut I've been using cabal new-build and it was working great so far, and I wanted to keep using plain cabal with that
06:07:01 <reactormonk> edwardk, I'm playing around with discrimination (for nub) and I want to know if I'm creating my own instances in a way that makes sense and not running my head against a wall - can't autoderive any of these, needs Generic1 apparently. https://gist.github.com/3b6f314983c600313e5955da66a1980c
06:11:32 <phaazon> hey, is there a package for handling / parsing timezones as Continent/Country?
06:12:52 <yoneda> qqqqqreset
06:13:36 <merijn> phaazon: I'm not sure what you mean by that?
06:13:48 <merijn> phaazon: You mean converting from a country to a timezone or the other way around?
06:13:57 <merijn> phaazon: Because, either way, you're most likely fucked
06:14:03 <trigone> hi! i'd like to know if some reversed (->) operator is defined, or usable via some extension, so one could write types in the reversed order, aka say f :: (x <- a) <- b <= Class a. the advantage is, when you write a long type signature over several lines, one the first line you can put the most typical resulting type of the function (modulo currying). it's a bit more useful than putting the class constraints on that first line inst
06:14:09 <merijn> phaazon: I strongly recommend wanting different things instead :p
06:14:25 <trigone> s/one the first line/on the first line
06:14:36 <phaazon> merijn: yeah, well
06:14:40 <merijn> trigone: Well, you can easily define a type synonym for that, I think
06:14:41 <phaazon> I guess I’ll go my own way
06:14:49 <phaazon> I have “to send something” to an endpoint
06:14:54 <trigone> merijn: really?
06:14:55 <phaazon> which requires such a shitty TZ format
06:15:10 <phaazon> so I have a product type with two free Text fields
06:15:11 <trigone> hm but it'll have to start with `:` right?
06:15:16 <phaazon> though, I don’t really like that
06:15:28 <phaazon> I’d rather like two algebraic types
06:15:33 <phaazon> Continent and Country
06:15:51 <merijn> phaazon: I mean, besides the obvious multiple timezones per country situation there's even places where the exact same specific place has 2 different relevant time zones
06:16:10 <phaazon> oh wait it’s Continent/City
06:16:13 <phaazon> like Europe/Paris
06:16:30 <phaazon> merijn: yeah, well, not my spec :D
06:17:50 <trigone> merijn: wait, it won't reverse the position of the class constraints, will it?
06:18:14 <merijn> trigone: I don't think you can move those, no
06:19:17 <cocreature> phaazon: hoow about https://hackage.haskell.org/package/tzdata-0.1.20170320.0/docs/Data-Time-Zones-DB.html#v:fromTZName
06:19:27 <trigone> merijn: well that's not too problematic... thanks for the idea :)
06:19:53 <trigone> merijn: the syntax for infix declaration is the same btw?
06:20:05 <cocreature> phaazon: hm no I don’t think you can actually do something with these labels
06:20:21 <cocreature> oh you can with the "tz" package
06:20:57 <cocreature> in fact the "tz" package is all you need
06:22:08 <merijn> trigone: Not quite sure what you mean?
06:23:46 <phaazon> cocreature: thanks
06:24:05 <trigone> merijn: nvm i found the answer somewhere else. i have trouble finding if you need an extension or not to enable them...
06:25:24 <trigone> (apparently you do, ghci demands -XTypeOperators)
06:27:43 <trigone> stupid question: do i need to enable the option when i use the operators or only when i define them?
06:27:51 <trigone> (type operators)
06:30:50 <lyxia> both
06:32:35 <merijn> bgamari: ping?
06:33:17 <zekt> hi might be a silly question, I want to create a type with constructor to different type, 
06:33:17 <zekt> data Var a where VarInt :: String -> Var Int; VarBool :: String -> Var Bool; VarChar :: String -> Var Char
06:33:17 <zekt> all the constructor does the same thing, they just produce different types, is there a better way to do this?
06:34:22 <ventonegro> zekt: GADTs
06:36:37 <cocreature> zekt: sometimes "data Var a = Var String"  + a bunch of smart constructors can be a bit easier to work with but in general, there is nothing wrong with just enumerating the constructors
06:37:42 <phaazon> hm
06:37:55 <phaazon> is there a way to have XML types in servant types (API)?
06:39:29 <cocreature> phaazon: I don’t know of a builtin one but providing it yourself just requires a MimeRender and a MimeUnrender instance afaik which is fairly easy to supply
06:39:44 <phaazon> yeah, I’ll do that
06:39:48 <phaazon> I just thought it already existed
06:40:03 <zekt> but is it possible to give a type parameter to my GADT constructor to produce different type? 
06:42:15 <duncan^> n
06:42:21 <duncan^> ack
06:43:21 * hackagebot wai-secure-cookies 0.1.0.1 – <i>Added by alaminium, Mon Aug 28 12:42:03 UTC 2017.</i> – https://hackage.haskell.org/package/wai-secure-cookies
06:43:21 * hackagebot charsetdetect-ae 1.1.0.3 – Character set detection using Mozilla's Universal Character Set Detector – https://hackage.haskell.org/package/charsetdetect-ae
06:47:17 <phaazon> I guess application/xml should do it
06:50:57 <lyxia> zekt: data T a where { Int :: T Int ; Bool :: T Bool ; Char :: T Char }     data Var a where Var :: String -> T a -> Var a
06:53:37 <edwardk> reactormonk: i don't see anything particularly crazy there
06:54:57 <reactormonk> edwardk, alas, I'm not sure how to write instance Grouping1 for the ADT JSONTypeF
06:55:16 <reactormonk> Here's the corresponding SO: https://stackoverflow.com/questions/45920612/creating-instance-for-adt-with-contravariant-divisible-and-decidable
06:56:05 <edwardk> you can always convert those element to lists and just run through them that way if you can't introspect better
06:56:41 <edwardk> HashMap has a toList with key value pairs, Maybe already has an instance, etc.
06:57:31 <reactormonk> Ah, coerce everything into a List and run that?
06:57:35 <edwardk> using 3 calls to divide to break things up into Left (Left x) for JObject, Left (Right x) for JArray Right (Left and Right Right ...
06:57:51 <reactormonk> Yeah, I thought of that but it felt a bit crazy
06:57:57 <edwardk> then you can contramap to convert to a List in each case and use the list handler
06:58:22 <reactormonk> So there's no n-ary divide?
06:58:25 <edwardk> well, you _can- copy all the logic in grouping from the sum case ;)
06:58:49 <reactormonk> sum case?
06:58:52 <edwardk> there's no way to give it
06:59:05 <edwardk> https://github.com/ekmett/discrimination/blob/master/src/Data/Discrimination/Grouping.hs#L70
06:59:11 <edwardk> see the code for divide there
06:59:33 <edwardk> er for choose
06:59:34 <edwardk> not divide
06:59:53 <edwardk> you can copy that choose logic logically to write your own group instance
07:00:05 <reactormonk> Ahh, that was specifically the example I was looking for, thanks!
07:02:09 <eikke> what's the preferred 'solution' nowadays for the mtl-style instances blowup problem?
07:02:47 <edwardk> eikke: accepting that n = 8 isn't that big a deal? ;)
07:03:29 <eikke> edwardk: fair enough, but meh :P
07:03:41 <edwardk> see https://www.youtube.com/watch?v=GZPup5Iuaqw
07:04:17 <edwardk> that goes through the whole (HasFoo s, HasBar s MonadState s m) => ... pattern that rather drastically reduces the pressure on the mtl
07:04:34 <edwardk> its not a panacea, but its enough that the only time i think about it is when someone is complaining on the internets
07:04:50 <edwardk> or when i go to use !*@)(#)(!@*#) haskeline
07:05:21 <eikke> will watch the vid later, thanks
07:21:51 <tabaqui> wtf
07:21:57 <tabaqui> I'm building containers and get
07:22:04 <tabaqui> Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: Missing dependency on a foreign
07:22:06 <tabaqui>     library:
07:22:08 <tabaqui>     * Missing (or bad) header file: cwiid.h
07:22:12 <tabaqui> yaourt -Si cwiid
07:22:18 <tabaqui> community/cwiid 0.6.00+svn201-1
07:22:20 <tabaqui>     Linux Nintendo Wiimote interface
07:23:11 <tabaqui> oh, no, I'm building hwciid
07:23:20 <rcat> cocreature: thanks a lot for the tip about how to get my own copy of cabal-install for using static linking again \o/
07:23:26 <tabaqui> but I don't need it!
07:23:42 <rcat> cocreature: I added some notes in the Arch wiki for other people :)   https://wiki.archlinux.org/index.php/Haskell#Using_Cabal_with_static_linking
07:26:09 <cocreature> rcat: nice, then I can finally stop repeating myself and just link to that page :)
07:29:30 <tabaqui> brilliant, Yampa/examples want wii controller, and now it is the dependency of the whole library
07:32:31 <MarcelineVQ> how are you building it? yampa examples are disabled by default
07:33:33 <tabaqui> MarcelineVQ: my project depends on it
07:34:01 <MarcelineVQ> I mean the literal how, are you using stack for example?
07:34:03 <tabaqui> so, I just have yampa >= 0.10 in build-depends
07:34:12 <tabaqui> in my .cabal file
07:34:23 <tabaqui> stack build then
07:36:05 <tabaqui> dunno, should I say more?
07:36:17 <MarcelineVQ> stack isn't good with excluding non-reachable deps at the moment I believe. if you want to get around it I'd reccomend unpacking yampa and editing the .cabal file to be slightly more explicit about deps:
07:36:25 <tabaqui> no flags, no other yampa dependencies
07:36:30 <MarcelineVQ> line 160-161 is what I ​mean by that http://lpaste.net/2184720086743384064
07:37:05 <MarcelineVQ> then you'd point to your unpacked yampa in your packages section of your stack.yaml
07:37:11 <cocreature> just to be sure you could try setting the "examples" flag explicitely to false using https://docs.haskellstack.org/en/stable/yaml_configuration/#flags
07:37:28 <MarcelineVQ> that won't work on a resolver dep :(
07:37:43 <cocreature> MarcelineVQ: I’m pretty sure it does work
07:38:14 <MarcelineVQ> Not in my experience, but if you can solve it with that please let me know, that issue comes up a lot
07:38:20 <cocreature> stack has some weird behavior when it comes to flags but so far I’ve only seen it leave flags disabled even if they have "default: True" not the other way around
07:38:39 <MarcelineVQ> Oh it's not about flags cocreature, it's about how it treats deps
07:38:43 <cocreature> oh sure
07:38:50 <cocreature> that might still be a problem
07:39:00 <MarcelineVQ> It thinks those deps matter even if the flag doesn't say they do
07:39:17 <MarcelineVQ> iow 'buildable' isn't treated nicely
07:39:56 <MarcelineVQ> I think cabal itself only dealt with this issue a little while ago as well
07:44:37 <tabaqui> cocreature: I'm not sure, but it looks like stack will build Yampa/examples either way
07:45:20 <tabaqui> because examples flags is set as False by default
07:45:24 <cocreature> then you’ll probably have to follow MarcelineVQ’s suggestion
07:45:47 <tabaqui> yeah, it seems so
07:45:56 <tabaqui> thanks to all
07:46:28 <cocreature> MarcelineVQ: afaik buildable: false worked for quite some time with cabal. what’s new is that even without buildable: False, cabal now does per component builds which means that it won’t build executables if you just depend on the lib
07:47:08 <cocreature> although it might only be new-build that does that
07:47:56 <MarcelineVQ> buildable: false  works fine but the dependencies in an non-buildable stanza were still considered as neccesary build deps
07:48:07 <MarcelineVQ> I'd have to find the ticket about that to be more specific
07:48:40 <shapr> if you're in the Atlanta / Georgia Tech area, one of yaxu's understudys is teaching TidalCycles classes over the next few months.
07:48:55 <cocreature> MarcelineVQ: what happens if you put the build-depends in a conditional?
07:48:56 <MarcelineVQ> TidalCycles is neat
07:49:08 <MarcelineVQ> cocreature: then everything works
07:49:36 <MarcelineVQ> in fact that's my suggestion above :>
07:49:58 <shapr> MarcelineVQ: coming to visit Atlanta before December? :-)
07:50:11 <MarcelineVQ> nosir
07:50:33 <MarcelineVQ> but  I've seen footage  and it's neato
07:54:19 <cocreature> MarcelineVQ: oh sorry, I should have read your previous message more closely
08:12:46 <edwardk> i wonder how many wall-clock hours i can save myself by just filtering doctest running to modules that contain the string '>>>'
08:13:08 <edwardk> i don't use the combinator very often, and false positives just bring me back up to current runtimes
08:14:23 <c_wraith> edwardk: sounds like something trivial to do.  might as well check!
08:14:29 <edwardk> yeah
08:14:41 <edwardk> takes 30 seconds to run my toy project's doctests now, let's see
08:15:11 <erisco> who is dfeuer
08:17:48 <c_wraith> erisco: um.  that's basically his name. :P
08:18:15 <erisco> his IRC name?
08:18:35 <c_wraith> if you expand the d to David, it's his real name too.
08:32:46 <edwardk> c_wraith: makes about a 10:1 difference in this little test case
08:32:47 <edwardk> nice
08:33:07 <c_wraith> that will pay off the implementation time very quickly then
08:34:05 <ski> dminuoso : ok
08:34:55 <edwardk> c_wraith: https://github.com/ekmett/coda/blob/0e09a37adcacabeb61fbb23024feea542f3ad61f/test/main/doctests.hs#L29
08:35:18 <norc_> Is there a way to make this any shorter? hasParity Odd e = e `mod` 2 == 1
08:35:50 <norc_> For a given hasParity :: Parity -> (Integer -> Bool)
08:36:05 <edwardk> if Odd and Even are eums you could probably share the logic
08:36:29 <edwardk> hasParity p e = e `mod` 2 == fromIntegral (fromEnum p)
08:37:00 <edwardk> Integer made that uglier. with Int it drops the fromIntegral
08:37:07 <c_wraith> norc_: you could replace the body with "odd e"
08:37:13 <edwardk> or that
08:37:20 <c_wraith> > odd 1
08:37:22 <lambdabot>  True
08:37:25 <edwardk> hasParity Odd = odd
08:38:06 <norc_> c_wraith: I guess I could drop the entire function then. :)
08:38:17 <edwardk> or that. 'odd' is even shorter =)
08:38:25 <dsal> @undo do { f l t a; return l }
08:38:25 <lambdabot> f l t a >> return l
08:38:39 <norc_> (odd) is a little more readable than (hasParity Odd) heh.
08:38:44 <bartavelle> completely OT, but there was an "unreliable boyfriend" meme with category theory/job opportunities, would be awesome if someone could /msg me the link
08:39:19 <edwardk> bartavelle: i'm pretty sure my wife would love to see that if you find it 
08:39:50 <bartavelle> heh
08:39:54 <norc_> edwardk: Yeah. `foldFilters And [odd, (> 10)]` is actually not too horribe. :)
08:43:07 * hackagebot attoparsec-data 1.0.3, currency-codes 1.0.0.3, attoparsec-time 1
08:43:07 * hackagebot  → https://hackage.haskell.org/packages/recent
08:44:49 <c_wraith> :t getAll . foldMap (All .) [odd, (> 10)] -- norc_ Not that I really think you should use this instead, but it's amusing how close existing pieces are.
08:44:50 <lambdabot> Integral a => a -> Bool
08:46:25 <glguy> :t au (mapping (_Wrapping All)) foldMap :: [a -> Bool] -> a -> Bool
08:46:27 <lambdabot> [a -> Bool] -> a -> Bool
08:46:50 <c_wraith> glguy: I was sticking with things in base. :P
08:47:03 <glguy> I was adding to the category of solutions that wouldn't be used
08:47:37 <c_wraith> quick, someone provide a recursion-schemes solution
08:48:03 <c_wraith> preferably using something less sane than cata
08:48:41 <glguy> flip (all . flip id) :: [a -> Bool] -> a -> Bool
08:51:07 <edwardk> sad that there isnt a way to really use ala or alaf there
08:51:08 <edwardk> :t alaf
08:51:10 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
08:51:14 <edwardk> :t alaf All
08:51:16 <lambdabot> (Functor f, Functor g) => (f All -> g All) -> f Bool -> g Bool
08:52:17 <edwardk> :t alaf All foldMap
08:52:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:52:42 <c_wraith> is alaf ever used with anything other than foldMap?
08:52:51 <edwardk> probably not =)
08:52:54 <reactormonk> edwardk, I'm somewhat stuck with the part that the inner part of my obj depends on getGroup, which depends on the innards of obj... https://gist.github.com/reactormonk/3b6f314983c600313e5955da66a1980c
08:52:58 <reactormonk> (see bottom)
08:53:10 <marvin2> is there a function like this in module that ship with ghc? could swear I saw it somewhere. fromEither :: Either a a -> a
08:53:24 <c_wraith> marvin2: I don't think so.  but it's just either id id
08:53:39 <edwardk> reactormonk: the result needs to be build lazily, it looks circular, but works
08:53:44 <edwardk> er built
08:54:05 * geekosaur wonders how often such a thing is usefukl
08:54:07 <reactormonk> The types don't match up that way however, because I need to put the monad type up top
08:54:18 <reactormonk> So I can't simply flip it
08:54:37 <geekosaur> Either a a, but you need to collapse it at some point? seems weird
08:54:51 <reactormonk> https://gist.github.com/reactormonk/d3441aca136f22bb05d4319728383ed6
08:55:22 <nshepperd> :t alaf Const traverse
08:55:24 <lambdabot> (Monoid a', Traversable t) => (a -> a') -> t a -> a'
08:55:43 <nshepperd> it's foldMap!
08:56:15 <c_wraith> so instead of using alaf with foldMap, you used it to build foldMap. :P
08:57:04 <edwardk> reactormonk: 'getGroup grouping'  or grouping1 passed an arg appropriately, etc.
08:57:14 <edwardk> grouping will go find the thing
08:57:17 <reactormonk> edwardk, ... duh, thanks.
08:57:55 <c_wraith> geekosaur: I kind of like that it forms a nice demo of algebraic manipulation working well.  Either a a = a + a = 2 * a = (Bool, a)
08:59:28 <reactormonk> edwardk, beautiful, now it compiles \o/
08:59:35 <edwardk> woot
09:00:40 <nshepperd> > ala ZipList traverse [[1, 2, 3], [4, 5, 6]]
09:00:43 <lambdabot>  [[1,4],[2,5],[3,6]]
09:01:12 <reactormonk> I'm kinda averse to running it though, then I'll have to debug the rest of the code ^^
09:04:34 <whittle> There’s no general solution f :: m n a -> n m a, right? 
09:04:49 <c_wraith> :t sequence
09:04:51 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:04:58 <whittle> Ah. 
09:04:59 <c_wraith> Oh, that's not at all the same
09:05:43 <c_wraith> The kinds are crazy in what you provided, actually.  Maybe you meant sequence
09:05:55 <c_wraith> :t sequenceA
09:05:57 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:06:00 <whittle> Sorry, c_wraith, you said what I meant. 
09:06:02 <c_wraith> Or the slightly more permissive form
09:06:21 <whittle> My brain hasn’t quite woken up yet. 
09:06:28 <whittle> Thank you. 
09:06:44 <c_wraith> whittle: yeah, there's no general solution.  You need some set of classes involved.  Applicative and Traversable is a nice general pair that solves it.
09:07:47 <whittle> That makes sense. 
09:15:43 <`Guest00000> is NoNegativeLiterals considered good?
09:18:08 <glguy> There are surprises to be had with and without negative literals, but the default of not having them is less bad
09:18:14 <dminuoso> c_wraith, it's interesting. Actually foldMap is a step in the right direction. What I really want is something along the lines of Monoid m => (a -> m) -> t a -> a
09:18:47 <dminuoso> foldMapAndUnwrap :-)
09:19:28 <dminuoso> Otherwise the output is not composable the same way
09:21:10 <guest529> Apart from Stephen Diehls and Scheme in 48 hours, are there any other resources related to Compiler Design in Haskell?
09:30:25 <dminuoso> How does GHC parse code, when infixity declarations can arbitrarily change how code associates?
09:31:13 <kadoban> By doing fixity declarations first?
09:33:35 <c_wraith> ghc actually does worse than that. it parses first with some arbitrary fixity, then goes back and fixes previously parsed things after finding a fixity declaration 
09:34:05 <c_wraith> well, not "some arbitrary". it pretends operators have the default fixity unless it knows otherwise 
09:34:24 <dminuoso> c_wraith, is that guaranteed to always parse properly with the default fixity?
09:35:10 <c_wraith> it will always be a syntactically valid parse. it will probably be wrong. 
09:39:56 <geekosaur> put otherwise, it will always produce an AST, it may well produce an invalid AST but that's not a problem as long as it goes back and rearranges tree nodes based on discovered fixity
09:43:16 * hackagebot biohazard 0.6.16, stackage-curator 0.15.0.0, threepenny-editors 0.5.3
09:43:17 * hackagebot  → https://hackage.haskell.org/packages/recent
10:14:24 <miscyb> is anyone here experienced with servant
10:14:59 <fendor> are there resources for template haskell that are up to date?
10:15:05 <fendor> except for module documentation?
10:15:08 <cocreature> miscyb: lots of people are, you are going to get a better answer if you just ask your question and stick around for a bit
10:15:39 <miscyb> well i'm wondering how to differentiate between endpoints that have similar routes, but different QueryParams
10:15:41 <miscyb> for example
10:16:09 <miscyb> if I have an endpoint "ajax.php?action=foo" responds "GET '[JSON] Foo"
10:16:29 <miscyb> and another, "ajax.php?action=bar" responds "GET '[JSON] Bar"
10:16:38 <miscyb> how do i tell these apart?
10:17:51 <Guest340521[m]> I like Haskell
10:21:57 <cocreature> miscyb: the easiest solution is probably to just use the same endpoint, have it return some kind of sumtype of Foo and Bar and differentiate in the handler. alternatively you could write your own combinator
10:22:36 <miscyb> cocreature: i think that makes the most sense, what would i need to do to write my own combinator
10:23:16 <cocreature> miscyb: take a look at the existing QueryParam combinator. the most important thing is probably the HasServer instance
10:23:46 <miscyb> all right i'll give that a shot
10:27:40 <cocreature> miscyb: https://hackage.haskell.org/package/servant-server-0.11/docs/src/Servant-Server-Internal.html#line-322 is the instance for QueryParam. in your case, you might want to change the Handler to not receive the parameter (it’s a constant afterall) and then in the "Just (Just v)" case you need to compare if that is the parameter specified in your combinator and fail otherwise
10:32:41 <miscyb> cocreature: that's in the server part, am I going to need to do something else for the client part?
10:34:24 <cocreature> miscyb: oh yeah, in that case https://hackage.haskell.org/package/servant-client-0.11/docs/src/Servant-Client.html#line-291 is what you should be looking at
10:36:10 <miscyb> cocreature: also do I have to define my own type like QueryParamConst or can I just make a new instance where the type 'a' is a KnownSymbol?
10:40:52 <cocreature> miscyb: make your own type. theoretically you might be able to reuse QueryParam with an overlapping instance but that’s asking for trouble without a good reason
10:42:11 <miscyb> cocreature: ok thanks i'll see how this goes
10:43:26 * hackagebot Yampa 0.10.6.2 – Library for programming hybrid systems. – https://hackage.haskell.org/package/Yampa
11:40:25 <reactormonk> edwardk, is there a way to use hashing to speed up a on a Grouping1? Not that easy to attach a `Hashable` instance.
11:43:36 * hackagebot distributed-static 0.3.8 – Compositional, type-safe, polymorphic static values and closures – https://hackage.haskell.org/package/distributed-static
11:43:36 * hackagebot codec-rpm 0.1.3 – A library for manipulating RPM files – https://hackage.haskell.org/package/codec-rpm
11:50:35 <cocreature> oh new release of distributed-static. I still need to take some time to play around with static pointers
11:50:52 <jared-w> oh neat
12:03:33 <miscyb> hi i was here earlier trying to create a combinator for servant that would let you specify a constant query parameter
12:03:43 <miscyb> i'm having some trouble so here's a past of what i was doing
12:03:48 <miscyb> http://lpaste.net/358034
12:05:07 <miscyb> i'm kinda new to this advanced type stuff so if anyone could explain that error that would be awesome
12:07:23 <miscyb> the idea for that code is that you'll be able to differentiate from "route.json?action=foo" and "route.json?action=bar"
12:09:18 <remexre> With Haskeline, is there any way to change the base monad of InputT?
12:09:55 <remexre> The type of mapInputT is (m a -> m a) -> InputT m a -> InputT m a, rather than the expected (m a -> n b) -> InputT m a -> InputT n b
12:23:48 <ocharles> remexre: It doesn't look possible to me
12:24:43 <remexre> Hmm, that's what I feared. I guess I'll make a stub function and file an issue
12:45:38 <filthy_causual2_> miscyb: I think you need ScopedTypeVariables. Though I am not sure why it can't unify them...I would into where the class is defined too.
12:59:13 <tikhon> What's a good type for maintaining a sorted sequence of items?
13:00:06 <APic> No Idea?
13:00:18 <APic> ✝ Volt_
13:03:24 <cocreature> tikhon: what operations do you want to perform on that sequence?
13:03:48 <tikhon> mostly inserting things and keeping it sorted
13:04:07 <cocreature> do you need duplicates?
13:04:17 <tikhon> yeah, I think so
13:04:24 <cocreature> and why do you need it to be sorted? do you just want to be able to enumerate them in order?
13:05:06 <tikhon> well, that and getting the first/last, probably
13:05:25 <cocreature> sounds like you want a multiset 
13:05:30 <cocreature> e.g. https://hackage.haskell.org/package/multiset-0.3.3/docs/Data-MultiSet.html
13:06:17 <tikhon> oh yeah, wouldn't have thought of that
13:06:19 <tikhon> thanks
13:08:39 <lavalike> remexre: what happens for m = IO, n != IO ?
13:08:56 <remexre> n would have to be MonadIO, so it gets liftIO'd?
13:09:30 <lavalike> where does that constraint come from?
13:09:44 <remexre> InputT requires m to be MonadException, which requires MonadIO
13:10:07 <lavalike> I see!
13:11:40 <lavalike> controlIO has a funny type
13:25:01 <trigone> hi! do i need an extension to use Phantom types?
13:25:07 <tikhon> no
13:25:34 <tikhon> phantom types are a specific usecase of normal type parameters, they're not a language feature unto themselves
13:27:03 <trigone> ok thx! and there's no way to use them with type synonyms, aka without having to wrap the values with data constructors?
13:27:17 <raynold> ahh it's a wonderful day :D
13:27:26 <johnw> trigone: you can use them with newtype
13:27:55 <tikhon> trigone: think of type synonyms as something you can completely replace throughout your whole program
13:29:35 <edwardk> reactormonk[m]: isn't there a hashing combinator in the lib?
13:29:41 <johnw> tikhon: hello!
13:29:43 <trigone> tikhon: yeah i know... but it'd still be cool if we could enforce some type-level metadata without having to wrap and unwrap values... is it really impossible to implement? there's no way to do so in haskell?
13:29:56 <tikhon> johnw: hey :)
13:30:03 <edwardk> https://github.com/ekmett/discrimination/blob/master/src/Data/Discrimination/Grouping.hs#L112
13:30:18 <tikhon> trigone: I think it's mostly a matter of wanting type inference
13:30:31 <tikhon> where every expression has a single most-general type
13:30:50 <edwardk> reactormonk[m]: you can basically just mappend that to the front of your existing grouping
13:32:02 <mnoonan> I just tried "type Test a = Int" in ghci 7.10.3 and all seems well
13:32:29 <mnoonan> but if you're trying to use the phantom type to carry information, doing it with 'type' instead of 'newtype' will give all kinds of ways to subvert it
13:38:14 <trigone> mnoonan: really? how could it be subverted? (in a non artificial way, in a way which can happen as a mistake)
13:39:32 <tikhon> here's an example, using type Foo a = ()
13:39:38 <tikhon> λ> f :: Foo Int -> Foo Int; f () = ()
13:39:38 <tikhon> λ> f ()
13:39:38 <tikhon> ()
13:39:38 <tikhon> λ> f (() :: Foo Double)
13:39:41 <tikhon> ()
13:39:44 <tikhon> λ> f (() :: ())
13:39:47 <tikhon> ()
13:40:00 <mnoonan> trigone: well, if you define "type Test a = Int" as above, and then "let x = 3 :: Test String" and "let f = (+1) :: Test Char -> Test Char", then "f x" is still well typed
13:40:01 <tikhon> basically, it gives you no type safety at all, because there's no way to distinguish Foo a from Foo b from plain ()
13:40:47 <trigone> tikhon: oh! so it doesn't work at all like phantom newtypes... indeed not very useful
13:41:07 <tikhon> yes
13:42:05 <trigone> there's no extension to sort of implicitly wrap parameters? i don't really get the issue, in the cases when there's only one wrapper whose identity is given by the type (and i don't really care about type inference, i like writing the types)
13:42:13 <johnw> right, just 'id' would be able to convert between any two of your type synonyms
13:42:17 <trigone> s/wrap parameters/wrap values
13:42:46 <erisco> also, a partially applied newtype is a higher kinded type, and a partially applied alias is nothing
13:43:21 <tikhon> trigone: there's nothing general like that, but you can get close with typeclasses and overloaded literals (numbers, strings... etc)
13:43:48 <trigone> tikhon: i don't really see what you mean...
13:44:12 <tikhon> I mean, if the type you want to wrap is a number, you can implement Num and use numeric literals without the constructor
13:44:17 <trigone> oh, you mean say create a tagged Num' wrapper and use overloaded literals to imply the wrapping
13:44:23 <tikhon> yes
13:44:28 <mnoonan> trigone: you'd have to either do implicit or explicit casting instead. explicit casting is basically the same as wrapping and unwrapping, and implicit casting seems to always end up as some kind of tarpit ugliness 
13:44:34 <mnoonan> *of ugliness
13:45:29 <trigone> mnoonan: yeah, but the syntax for pattern matching with too many wrappers look like lisp >P
13:45:56 <erisco> I liked the idea for multiple newtype constructors
13:46:04 <erisco> though I forget who came up with that now
13:46:12 <mnoonan> erisco, what was that?
13:46:13 <trigone> erisco: multiple newtype constructors?
13:46:41 <trigone> you mean newtypes accepting more than one possible constructor?
13:47:17 <tikhon> there are some other options for making it more manageable
13:47:29 <tikhon> if you're using the same nested constructors a lot, you could define a pattern synonym
13:48:02 <tikhon> there's also the newtype package which some people like
13:48:02 <erisco> yes, that's right. the idea is that a constructor can be added if its field is trivially equivalent
13:48:03 <tikhon> https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
13:48:27 <tikhon> I believe lens also exposes most of the same functionality, if you're already plugged into the lens world
13:48:31 <erisco> the trivial equivalence can quickly be explained as unsafeCoerce
13:49:24 <erisco> so, for example, 'Identity a' is trivially equivalent to 'a' because they are safely coercible to each other via unsafeCoerce
13:49:57 <trigone> erisco: wait, but `a` has no constructor at all?
13:50:14 <erisco> trigone, it is a type variable
13:50:35 <erisco> this means you can have a newtype which provides various ways to view data, and so includes the possibility of reducing many wrappers to less (or none)
13:50:43 <trigone> erisco: you mean left side or right side of the newtype definition?
13:51:10 <trigone> you'd have sth like newtype Identity a = a | Identity a ??
13:51:47 <erisco> 'a' is not a constructor
13:52:47 * hackagebot text-short 0.1.1 – Memory-efficient representation of Unicode text strings – https://hackage.haskell.org/package/text-short
13:52:47 * hackagebot deburr 0.1.0.1 – Convert Unicode characters with burrs to their ASCII counterparts. – https://hackage.haskell.org/package/deburr
13:52:52 <trigone> tikhon: nah i'm not plugged into lens world yet... and i think pattern synonyms could make things very quickly very hard to code... i wouldn't even know how to name patterns :P
13:54:04 <trigone> erisco: ok, so you mean perhaps sth like newtype Identity a = Identity a | Identity' (Identity a), so you can have as many layers of Identity as you want? even if i got this right, how do you achieve the "no wrapping" stage?
13:55:00 <monochrom> newtype cannot have |
13:56:29 <trigone> erisco: wait, you were talking of Control.Newtype?
13:56:46 <erisco> trigone, maybe I was unclear by saying that. What I meant was that you could remove wrapping up to a single newtype constructor
13:56:57 <erisco> I don't know, I never heard of that
13:57:50 <erisco> I am not sure what to make of having no constructor because it flies in the face of discriminated union
13:58:18 <erisco> now you have problems like tikhon was mentioning
13:59:46 <trigone> erisco: hm ok, a kind of lift-like unwrapper? what did tikhon say, i can't find what you refer
13:59:50 <trigone> ?
14:01:06 <erisco> tikhon was showing problems with an implicit conversion
14:01:35 <erisco> this is not so unrelated, because what the tag i.e. constructor makes explicit is the type
14:01:52 <erisco> so not having constructors leaves you with the same sorts of questions
14:04:56 <erisco> trigone, your identity example is just the sort of thing this proposed feature would permit
14:05:40 <trigone> what i don't get is, say we invent a syntax with (*) having a special meaning of "implicit constructor" if i give ghc  (*wrappedval :: Foo), with Foo having only one constructor, why would ghc have trouble extrapolating the constructor i meant to use? (and we could have a special syntax to say "deduce the right constructor yourself", like just wrapping the variable in parentheses because i guess otherwise it could be confusing very
14:05:43 <trigone> is it impossible theoretically?
14:06:06 <trigone> erisco: which identity example? the one with optional recursive wrapping?
14:06:18 <erisco> trigone, yes, your latest one
14:07:39 <trigone> honestly i don't get why there's no way to create some sugar which would allow, for any newtype, to omit (explicitly) the data constructor (in pattern-matches)...
14:08:00 <johnw> trigone: idris has this
14:08:05 <johnw> so technically, there's nothing infeasible about it
14:08:09 <trigone> johnw: really? what's the syntax?
14:08:17 <johnw> you register coercions
14:08:19 <johnw> Coq has it too
14:08:30 <johnw> I don't program in Idris, though, so I can't give you an example; Google may know
14:08:43 <erisco> well, before investigating the other implications of your feature, what is the hope of (*wrappedval :: Foo)? It does not seem shorter than using a constructor name
14:08:49 <trigone> johnw: ok thx i'll check that out :)
14:09:33 <johnw> trigone: note that there is a newtype-generics package that will get you down to wrap/unwrap in Haskell.  If you want '*' to become sugar for wrap, you could do that with a preprocessor if you really wanted to.
14:09:56 <trigone> erisco: you rarely put types on your pattern-match, do you? it was just a way to say "i either explicitly put the type somewhere, or ghc inferred it without trouble, so ghc _knows_ that (*wrappedval) is of type foo
14:10:14 <trigone> *Foo
14:10:29 <johnw> trigone: one thing to bear in mind is that, when dreaming up a feature like this, it's easy to focus only on the simple examples you have in mind
14:10:36 <johnw> the reality is always far more complicated
14:10:38 <trigone> johnw: unwrap with functions or directly in pattern-matches?
14:11:01 <johnw> you have to also consider view patterns, pattern guard, records, etc.  What does '*' mean in every context where it might possibly appear?
14:11:20 <johnw> trigone: I didn't understand the context of that last question
14:11:21 <erisco> trigone, so was that a pattern match?
14:11:30 <geekosaur> let's not forget the lessons of unary - in Haskell
14:11:33 <trigone> johnw: i never pretended my idea was sound :) and the * is just a random choice which could be replaced by whatever
14:11:41 <geekosaur> whish is likely the *real* problem with this idea
14:11:49 <trigone> geekosaur: what's the lessons of unary?
14:12:00 <erisco> pained and tortured
14:12:06 <geekosaur> "unary -"
14:12:11 <geekosaur> which you can look up if you want
14:12:24 <johnw> the reason i like *not* having implicit coercions in Haskell is that code is more upfront about what's going on.  Once you know the types, you can understand the code.  Any type of automated coercion means there are invisible transformations going on, picked by some logic inside the compiler.
14:12:28 <trigone> erisco: yeah, you'd write f :: Foo a -> a; f (*a) = a or maybe just f *a = a
14:12:35 <geekosaur> hint, both the default behavior anf ghc's extension to try to "fix" it have different stupidities.
14:12:42 <geekosaur> and both conflict with sections
14:13:01 <erisco> trigone, okay, what is the type of \x -> case x of (*y) -> y ?
14:14:25 <trigone> erisco: can't you just raise "ambiguous use of implicit constructor" when the type isn't known at compile time?
14:15:39 <trigone> erisco: i don't say it'd be a truly semantical feature, just a way to imply things already obvious. if i write f :: Identity a -> a, why do i need to explicitly say that the argument must be matched with the data constructor Identity? there's no other way to create an (Identity a)! see what i mean?
14:15:47 <erisco> sure, but I wouldn't presume the simplicity of that
14:16:06 <crucify_me>  /nick n_blownapart
14:16:30 <crucify_me> xx
14:16:34 <erisco> I don't think GHC type checks programs that is conducive to that sort of ambiguity
14:16:43 <erisco> though I could be wrong, I do not know how its type checking works
14:16:52 <trigone> erisco: what ambiguity?
14:17:08 <erisco> I look at the state of duplicate record fields and suspect this similar feature would be difficult at the moment
14:17:31 <geekosaur> this is just a unary operator for Data.Coercible.coerce really. if it typechecks, which is unproven.
14:17:35 <erisco> trigone, the ambiguity of the constructor
14:18:07 <erisco> what you have demonstrated by saying to raise an exception is that such a program has no meaning
14:18:34 <trigone> erisco: i don't see why. ghc must have at some point a list of all constructors mapped with the list of all types, mustn't it?
14:18:45 <erisco> no type, is what I mean
14:18:47 <trigone> erisco: well yeah but then it just means (*) is not applicable everywhere
14:19:18 <erisco> have you written an algorithm before trigone?
14:19:34 <trigone> erisco: you know it's like saying we need parentheses every single where because precedence can't handle cases like (ma >>= k >=> k')
14:20:16 <erisco> maybe you missed it but I am not arguing that it is impossible, I am arguing that it is probably not easy
14:20:32 <erisco> and there is the case study of duplicate record fields to look at for this
14:21:22 <trigone> it seems simple to me: when ghc encounters a *, it go check if the type is fully known. if not, raises an error. if so, go find if it got only one constructor. if not raises an error. if so, replaces * with constructor. (obviously i don't deny i have no knowledge of how haskell is compiled, but it doesn't seem so far-fetched to me..)
14:21:41 <erisco> it is a similar problem. There is a projector such as "name" which we cannot give any type to
14:21:53 <erisco> instead we have to look around for another hint as to what "name" should be
14:21:59 <trigone> name?
14:22:05 <erisco> an example field
14:22:25 <erisco> this kind of inference is probably much different than anything else GHC does at the moment
14:23:15 <trigone> overall you mean it bothers type inference? bc that seems to me like an issue unrelated to implementation. it's simple: say you use a (*), and ghc can't infer the type. you then simply have a choice: add the type yourself, or add the constructor.
14:23:55 <erisco> go tell GHC how easy it is, then, because I am not going to do it
14:24:57 <trigone> what did i say was easy? i just said, if it can't infer, the solution is manually convey the type, with the data con or a typesig
14:25:49 <erisco> I don't follow
14:26:06 <trigone> erisco: well maybe i didn't understand what you meant earlier...
14:26:11 <erisco> and as to what you said was easy, you began that with "it's simple: ..."
14:27:01 <erisco> and maybe it is, I am just not the one to convince about it :P I am merely showing you possible issues and also related cases
14:27:11 <trigone> erisco: that was not about what ghc could do, but what you could do if ghc can't infer the type of some (*aa) pattern
14:27:44 <trigone> it's simple for you to solve: replace the (*) or add a signature.
14:28:10 <erisco> what is the type of \x. x ?
14:28:22 <erisco> sorry, \x -> x
14:28:32 <trigone> :t \x -> x
14:28:34 <lambdabot> t -> t
14:28:43 <trigone> erisco: i don't get what you mean
14:28:51 <erisco> now, how do you think it knows that?
14:30:18 <trigone> erisco: i don't know but i don't see the connection. replacing data constructors by stars imply that you just force ghc to infer more types from the context and signatures. it doesn't imply it's never gonna work. even if it only worked for functions for which you'd have manually given the signature, it'd still be, in my opinion, useful sugar
14:30:22 <erisco> if you haven't thought carefully about how how to check types, or how to infer types, then you probably can't appreciate the possible difficulties
14:31:23 <erisco> learn about type systems and you might have some of the same concerns others have been expressing here
14:31:40 <erisco> no one is saying it is impossible, they're just pointing out potential issues
14:32:09 <erisco> especially because you are expounding how straightforward it should be
14:33:14 <trigone> erisco: well, just think about this: in the expression (f :: Identity a -> a; f (Identity a) = a), how could ghc validate that code as well-typed as opposed to writing (f :: Identity a -> a; f (Foo a) = a), aka using a wrong data constructor, if it doesn't know the list of constructors that the type (Identity a) accepts?
14:34:33 <erisco> it needs to know that
14:34:57 <trigone> erisco: you're right, i very possibly don't see potential caveats, but at the same time, that sugar seems very straightforward to me: if the type is unknown or has more than one data cons, error. if not, replace the star by the only known data cons associated with the known type.
14:35:20 <geekosaur> it's rarely straightforward
14:35:31 <erisco> you do not know how a type becomes known
14:36:06 <trigone> ok... if you say so... at any rate even if it's harder than i think, i believe it's possible...
14:36:26 <erisco> you said so, not me ;)
14:38:41 <trigone> just, i dunno, how could my sketchy algorithm not work? the only prerequisite is that it knows all the data cons of whatever type the pattern-matched value is supposed to have. i don't think it could typecheck a pattern-matched value without knowing the valid data constructors of the type in question...
14:39:25 <jared-w> Look up the ML inference algorithm and then one for lambda calculi more powerful than System-F and compare the two :)
14:39:26 <geekosaur> trigone, when you have studied the ghc Commentary, you may be in a position to make such suggestions *with* "how could my sketchy algorithm not work"
14:39:56 <geekosaur> until then, you are making assumptions about how the compiler works that may not be applicable
14:40:56 <trigone> ok nevermind
14:44:06 * hackagebot var-monad 0.1.0.2 – The VarMonad typeclass, generalizing types of references. – https://hackage.haskell.org/package/var-monad
14:44:06 * hackagebot keystore 0.8.1.0 – Managing stores of secret things – https://hackage.haskell.org/package/keystore
14:47:00 <geekosaur> seriously: the compiler is driven by *types*, not by lists of data constructors. There is in fact a type constraint it could apply there... but resolving it is another issue
14:48:22 <erisco> what if we could have case analysis be polymorphic on data types
14:48:44 <erisco> they just need a certain shape
14:48:50 <MarcelineVQ> what could we call such a thing, a view perhaps?
14:49:15 * jared-w is not sure if that was tongue in cheek or not
14:49:32 <MarcelineVQ> gosh :(
14:50:20 <ggVGc> what's the type of type theory
14:50:37 <erisco> first problem I can think of is how we distinguish constructors with the same shape, because union is commutative
14:50:54 <erisco> or at least it should be... I don't think we want to start having constructor orders
15:01:38 <seanparsons> I'm confused as hell, switched a line of code from using traverse to mapConcurrently and now pretty much any operation relating to the filesystem blows out with an exception.
15:03:03 <seanparsons> I even tried putting a semaphore around those specific bits thinking it might be things like System.Directory somehow not being thread safe, but it still does it...
15:04:16 <seanparsons> Now I switch it back and it's still doing it, that's...Odd.
15:04:51 <MarcelineVQ> I recall using uninterruptibleMask with mapConcurrently and file operations at some point
15:04:58 <MarcelineVQ> *having to use uninterruptibleMask
15:05:31 <MarcelineVQ> so have a look at that to see if it's appropriate for what you're doing
15:11:33 <xzhu> What does the prime ' mean in
15:11:34 <xzhu> instance Literal [R.Logical] 'R.Logical where
15:11:57 <xzhu> https://www.stackage.org/haddock/lts-9.2/inline-r-0.9.0.1/src/Language.R.Literal.html#Literal
15:13:56 <MarcelineVQ> Datatype promotion, via -XDataKinds https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion
15:14:14 <xzhu> thx
15:18:21 <jchia_> Data.Map question: Is it better for performance to use something complicated/powerful like insertLookupWithKey instead of lookup & insert separately? I find insertLookupWithKey harder to read (For updateLookupWithKey, I even think the documentation is wrong.) and would like to use it only if it performs better. Is ghc smart enough to optimize separate lookup + insert to avoid two tree seeks?
15:18:36 <jchia_> I could lookup and conditionally insert
15:25:36 <ReinH> jchia_: GHC wouldn't optimize that on its own and I don't know if it would be possible with RULES pragma. The source certainly doesn't seem to have any such RULES. Maybe the strongest argument that insertLookupWithKey is more performant than lookup + insert is that it exists at all.
15:25:38 <dsal> I try to make it a habit not to ask people what computers are better at.
15:25:54 <dsal> haskell has reasonably good benchmarking tools.
15:26:09 <dsal> Then again, I don't know enough about haskell to know what it *would* do.
15:27:49 <erisco> that said, make it work before you make it fast
15:28:48 <Lazersmoke> is there a standard library providing `class Iso a b where {to :: a -> b, from :: b -> a}`?
15:29:07 <Lazersmoke> (or rather, a most popular and widely used one of those)
15:29:24 <jchia_> ReinH: thanks
15:29:52 <dsal> Lazersmoke: I've had good luck with criterion, though I don't think it does exactly that. 
15:30:05 <ReinH> If I want to work with an iso I usually use lens.
15:31:12 <Lazersmoke> so `type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)` is isomorphic to `(a -> b,b -> a)`, more or less? So I can just provide one of those and people can use it as a lens?
15:31:56 <dsal> Lazersmoke: Doh, sorry, I misread your request entirely.
15:41:46 <Lazersmoke> hmm, how does one represent an isomorphism between polymorphic types? Am I required to throw a type constructor in the way at that point? I'm trying to write `Iso' (forall x. f x -> g x) (forall c. MyType c f -> MyType c g)`
15:42:09 <Lazersmoke> I have both of the functions ready to be passed to `Iso'`, but I get an impredicative types error if I actually try it
15:44:16 * hackagebot gnss-converters 0.3.16, hsass 0.4.2, mysql-simple 0.4.1.0
15:44:16 * hackagebot  → https://hackage.haskell.org/packages/recent
15:44:59 <kolinsol> i'm sorry didn't want to interrupt the conversation. Can anybody please explain to ma how i can globally install a package using stack so that i can use it in ghci? Thanks in advance
15:45:28 <mud> kolinsol: stack ghci --package whatever  ?
15:46:20 <Lazersmoke> make sure you run that outside all of your stack packages though
15:54:13 <kolinsol> thanks for help
16:04:42 <Lazersmoke> Also: Does anyone know of a library that already provides a type class like: `class Is a b where {}` and an instance `instance Is a a where {}`?
16:05:17 <Lazersmoke> I'm defining this internally right now, but it's not particular to what I'm doing, so it might already exist somewhere else
16:06:04 <erisco> Lazersmoke, how about the constraint a ~ b?
16:06:10 <MarcelineVQ> Lazersmoke: http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Type-Equality.html got anything good?
16:07:06 <Lazersmoke> I need to be able to partially apply it. So what I really need is `Is (x :: k) :: k -> Constraint` where the constraint makes sure it is actually x
16:07:37 <erisco> :k (~)
16:07:38 <Lazersmoke> afaik I can't partially apply type operators ever
16:07:38 <lambdabot> k -> k -> Constraint
16:07:46 <erisco> :k (~) Int
16:07:48 <lambdabot> * -> Constraint
16:08:04 <trigone> hi, is there an alternative to the type Handle which would not typecheck errors like trying to write using a read-only handle?
16:08:21 <Lazersmoke> oh I can just do that? I was trying to take a section like `(~ X)` lol
16:10:22 <Lazersmoke> thanks erisco. My syntax highlighter hates me for doing `@'[(~)x]` now haha
16:10:44 <erisco> syntax highlighters tend to be wrong
16:11:17 <Lazersmoke> yup, the code compiles and works great, though, so no problem
16:11:27 <jared-w> Hmm... Is there a way to write a compiler that will attempt to check a program in stages? First by assuming it is a simplified subset of a language, then by "upgrading" to a more complicated subset to check anything it couldn't figure out the first time, and going up the ladder to more complicated subsets of the language until the entire program is checked. I'm not sure what I would actually call this
16:11:28 <jared-w> (google isn't being super useful right now)
16:11:50 <erisco> they're often defined by global matches of various regexps
16:12:28 <pacak> How would you go about measuring GC costs about individual data structures in your program?
16:13:15 <jared-w> pacak: benchmark it?
16:13:18 <erisco> jared-w, I do not understand. How can it assume it is a simplified subset of the language? That may just be untrue.
16:14:26 <pacak> jared-w: Assume it's impossible to separate individual data from the program itself while keeping usage pattern similar.
16:15:32 <jared-w> Well, as an example, what if the compiler just assumed all types were Rank-1 until it encountered a function which mandated rank-N types (either by type signature or because it was impossible to compile using rank-1 types). Then the compiler would try to finish the compiling by using rank-N types on anything it couldn't use rank-1 types for
16:15:37 <pacak> Ideally I want something like profiling report but about GCing things. Is there anything like tit out there?
16:16:05 <jared-w> In this case, Rank-1 is merely a special case of Rank-N, ie a 'simplified subset'.  I've got no idea if this sort of thing is actually possible (or if I'm even explaining myself well)
16:16:51 <erisco> GHC does know if RankNTypes is required, it just does not enable it automatically
16:17:14 <jared-w> pacak: something like this? https://making.pusher.com/memory-profiling-in-haskell/
16:17:26 <erisco> I suppose you are thinking you can have a more optimised or a better optimising compiler when the program is identified as belonging to a simplified sublanguage?
16:17:43 <jared-w> Yes, that's one potential area I'm thinking of
16:18:21 <erisco> there is a similar case in parser generation where given an arbitrary BNF grammar it decides what parsing algorithm is necessary
16:18:24 <jared-w> Another is better error messages, better performance, etc., when programming in the "simple sublanguage" (particularly if the full language has, say, dependent types or Calculus of Constructions)
16:18:33 <erisco> preferring to use more efficient algorithms when possible
16:19:05 <Lazersmoke> actually it's not my syntax highlighter; it's like ghc-mod or hlint or one of those (don't remember which), so it's probably actually a bug
16:20:12 <erisco> adaptive algorithms may be related
16:20:34 <jared-w> sweet, more words to google :) thanks!
16:21:50 <jared-w> I'm envisioning a language which has all the eye-candy and shiny PLT stuff (like CoC, dependent types, other esoteric barely-usable kinda stuff) but allows you to program in many levels of complexity. So you could use ML level of types, lower than ML, System F, and all the way up the ladder...
16:22:17 <pacak> jared-w: That's profiling 101, I want something more advanced :) I know that there's no memory leaks,  I know that gc takes this and this time to process all the things. I'm more interested in a breakdown - "this GC 40% (xxxus) was taked by copying Foo.Bar  retained in Bar.Foo... "
16:22:39 <erisco> jared-w, have you paid attention to the evolution of Prelude?
16:23:12 <jared-w> and if the language was a functional-logical language, when certain logic 'features' or type 'features' are used, it triggers the appropriate checking (ie Linear types and Linear Logic, or other types of logic used wherever)
16:23:31 <jared-w> erisco: what in particular are you thinking of? I've paid a bit of attention to it
16:24:01 <erisco> the features are infectious, not always contained
16:24:36 <jared-w> pacak: ahh, gotcha. Just wanted to know if I was on the right track :) I don't know if Haskell even has the capability to inspect its GC that deeply because of how mangled everything gets during compiling... I'd imagine you'd have to ask #ghc to get a satisfying answer
16:24:36 <erisco> Prelude has become more sophisticated, more abstract, and so programs written using Prelude inherit this
16:25:11 <jared-w> erisco: that's true
16:25:16 <erisco> generally speaking you will have to fight using certain libraries to keep within a particular language level
16:25:37 <pacak> jared-w: Will do, wanted to check if I'm missing something (probably not so) obvious.
16:26:47 <jared-w> erisco: you have a point. I'll have to keep that in mind. I was mostly interested in whether such a behavior was even possible in the compiler, but the practical implications are also relevant :p
16:27:51 <jared-w> I did imagine this sort of thing to be used to help people write code at a level somewhat independent of library complexity; like, if a library uses dependent types and linear types and other fancy magic, it shouldn't /force/ the user of that library to be aware of all the implementation details if they want to stick to a "haskell '98"-like subset of the FP language
16:44:26 * hackagebot threepenny-editors 0.5.4.1 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
17:43:47 <mnoonan_> so I’m a little stumped about how best to proceed: there is an ekmett library on github that provides a typeclass that I need for a certain library function, but ekmett’s library is not on hackage and hasn’t been touched in 3 or 4 years. It also has fairly heavy dependencies (e.g. lens), whereas I really just want dependencies on base and containers.
17:44:47 * hackagebot liquid-fixpoint 0.7.0.2 – Predicate Abstraction-based Horn-Clause/Implication Constraint Solver – https://hackage.haskell.org/package/liquid-fixpoint
17:44:50 <Rembane> mnoonan_: Can you copy paste the tpye class?
17:45:03 <mnoonan_> should I (a) make a minimized version of the library and stick it on hackage myself, (b) just add the typeclass and basic instances to my own library, or (c) stick a pointer to the github repo into stack.yaml or something?
17:45:16 <mnoonan_> Rembane: yes, it is relatively small.
17:45:22 <Cale> Which type class?
17:45:27 <mnoonan_> Representational
17:45:36 <mnoonan_> https://github.com/ekmett/roles/blob/master/src/Data/Roles.hs
17:46:07 <Cale> ah, interesting
17:46:15 <Cale> Yeah, I don't know if that got put anywhere else
17:46:36 <mnoonan_> yeah, it seems like a useful typeclass
17:46:50 <mnoonan_> and it really is rather orthogonal to the rest of my library, so it seems weird to include it
18:07:51 <Rembane> mnoonan_: This might be a stupid question but why do you want to include it?
18:10:05 <mnoonan_> Rembane: in justified-containers, I have these newtypes around Data.Map.Map and keys, that add phantom type parameters. like “newtype Key ph k = Key k” and “newtype Map ph k v = Map (Data.Map.Map k v)”
18:10:49 <mnoonan_> the idea is that you can think of the phantom type as if it were representing exactly the set of valid keys, so a key :: Key ph k can always be found in any m :: Map ph k v
18:11:11 <mnoonan_> it is supposed to be 0-cost, and with the newtypes it mostly is
18:11:44 <mnoonan_> but there is a function for dealing with recursive maps, where the values can reference keys that are supposed to be in the map, like you might do to make a directed graph
18:12:24 <mnoonan_> so instead of a Data.Map.Map Node [Node], you could do Map ph Node [Key ph Node] to guarantee that each edge target is actually present in the map
18:13:44 <mnoonan_> the function that promotes a recursive Data.Map.Map to one of those things is a little more general, like Data.Map.Map k (f k) -> Map ph k (f (Key ph k))
18:14:29 <mnoonan_> but to get a 0-cost coercion of the whole thing, you have to be able to go from Coercible a b to Coercible (f a) (f b), and that’s not true for all fs
18:14:54 <mnoonan_> e.g. if f was a type family or something
18:15:25 <mnoonan_> but if the type parameter of f has a representational role, everything is kosher
18:16:33 <mnoonan_> buuuuttttt… there is no way to put a role constraint into the signature, so Representational lets you plumb in the Coercion a b -> Coercion (f a) (f b) for f’s with representational type parameters
18:16:59 <iqubic> What are we talking about here?
18:17:06 <mnoonan_> Rembane: obvious, right? :) 
18:20:34 <mnoonan_> iqubic: I’m trying to make a certain function truly 0-cost, but to do so I need to restrict a certain functor to ones where I can lift a coercion of a -> b to a coercion of f a -> f b
18:44:47 * hackagebot var-monad 0.2.0.0 – The VarMonad typeclass, generalizing types of references. – https://hackage.haskell.org/package/var-monad
18:44:47 * hackagebot Villefort 0.1.1.6 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
18:52:58 <urshanabi> has anyone managed to get hpack to take a file path for a dependency?
18:53:14 <urshanabi> it's killing me that there's no documentation out there for this. none that i can find, anyway
18:53:34 <c_wraith> is there any particular reason you're using hpack?
18:55:15 <urshanabi> is it not well-regarded?
18:55:32 <urshanabi> it was what the template i used for the project used
18:55:44 <c_wraith> It's just too new to have any reputation
18:55:46 <halogenandtoast> I'm using Text.XML.Cursor and I have         titles = items >>= (child >=> element "name" >=> attributeIs "type" "primary" >=> attribute "value")
18:55:56 <halogenandtoast> But now I want the attributeIs to be an "OR"
18:56:07 <halogenandtoast> Basically where type is primary or alternate
18:56:17 <halogenandtoast> Is there a way to combine axis like that?
18:56:19 <c_wraith> Using it seems like chasing the bleeding edge.  It's ok if you have a reason, but if you don't know why you're doing it, you probably shouldn't.
18:56:33 <urshanabi> what would you recommend i use instead/
18:57:15 <erisco> come back edge, I have a bandage...
18:57:29 <c_wraith> urshanabi: a cabal file for the basic information, adding in a stack file if you are using stack.
18:58:15 <mac10688> I'm looking at https://hackage.haskell.org/package/persistent-2.7.0/docs/Database-Persist.html. I have been through the package but can't find the definition for the share function.
18:58:21 <mac10688> Can someone tell me how to find it?
19:00:02 <urshanabi> cabal is going to be a no-go
19:00:12 <c_wraith> mac10688: well, my first stop was https://hackage.haskell.org/package/persistent-2.7.0/docs/doc-index-S.html  which agrees it's not in that package.
19:00:21 <urshanabi> as far as i can tell, this whole stack business is about allevaiting the user-hostility of cabal
19:00:37 <c_wraith> urshanabi: cabal isn't user-hostile.  And stack uses .cabal files
19:00:49 <urshanabi> stack uses cabal so i don't have to, yes
19:01:12 <c_wraith> But more importantly, cabal the tool isn't what .cabal files are for.
19:01:26 <c_wraith> .cabal files are for the *library* named Cabal
19:01:28 <pacak> urshanabi: As long as you are not doing anything strange. stack is derpy in strange situations.
19:01:46 <urshanabi> i don't think i'm up to doing strange things yet
19:01:48 <halogenandtoast> Actually what I want is far more complicated, nevermind.
19:02:20 <c_wraith> The .cabal file format is well-documented and easy to use.  If you want to avoid that, go ahead, I guess...
19:02:48 <mac10688> c_wraith, I found it in the Database-Persist-TH package
19:03:05 <mac10688> I mean persistent-template package
19:03:17 <c_wraith> mac10688: ah, nice.  Yeah, related packages were the next place to check.
19:03:58 <sssilver> hey guys, anyone here knows Haskell?
19:04:19 <mac10688> I'm the residential expert, what's up?
19:04:21 <geekosaur> one would hope so...
19:04:30 <urshanabi> it is well-documented, but it's intimidating as all hell. i need to see a few hundred more generated cabal files before i'm up to writing them
19:05:18 <sssilver> I don't like this whole returning functions business. I find it counterintuitive and complicated. Do y'all share this sentiment?
19:05:35 <urshanabi> ha! i think i've got it
19:05:46 <geekosaur> Haskell is a functional programming language. passing and returning functions is normal.
19:05:48 <sssilver> problem is, everything I read related to Haskell at some point starts returning functions
19:05:55 <sssilver> and never goes back to normalness
19:06:07 <sssilver> (normalty? normaldom?)
19:06:23 <urshanabi> that's functional programming, yes
19:06:36 <geekosaur> if you really have that much trouble with first class functions, then you want to avoid the whole functional programming paradigm
19:06:50 <sssilver> so if someone isn't feeling particularly inclined to return functions out of functions, is it fair to say that they should stop trying to learn to program in Haskell?
19:06:58 <urshanabi> or you can stick through it and have it add another wrinkle to your brain
19:07:27 <geekosaur> not Haskell, not Scheme, not ML, not Ocaml, not F#, not ...
19:07:50 <geekosaur> there's a whole bunch of languages you will have to avoid completely if you don't like *function*al programming
19:07:56 <c_wraith> Hell.  These days, not even Java or C#
19:08:03 <geekosaur> I mean, it's kinda the whole point
19:08:10 <c_wraith> They do it in the most clumsy ways possible, but they do it.
19:08:17 <sssilver> I don't mind functions. I just don't feel comfortable writing functions that return functions. It feels like brainfuck to me.
19:08:30 <urshanabi> sssilver, how you phrased your complaint reads to me like that's your point of greatest returns
19:08:34 <urshanabi> pun intended
19:08:56 <urshanabi> get comfortable. make it intuitive. etc.
19:09:03 <c_wraith> sssilver: funny fact - you can always pretend a function that returns another function is actually just a function with more arguments. :)
19:09:03 <geekosaur> *first class* functions. things you can pass and return
19:09:10 <geekosaur> and manipulate
19:09:28 <geekosaur> this is the heart of functional programming, and why it's called that
19:09:36 <urshanabi> i mean, at least it's not lambda calculus. even primitive values are functions in that
19:09:37 <mac10688> sssilver, there could be many reasons to not like haskell, but passing around functions probably shouldn't be it. It's coming to a mainstream language near you, like it or not
19:10:00 <sssilver> so would you say that you all routinely return functions out of your functions?
19:10:09 <erisco> sssilver, do you think you could bear your own reflection if you gave up on Haskell?
19:10:10 <urshanabi> and i suppose primitive values are 0-ary pure functions in haskell...
19:10:30 <geekosaur> Haskell can be seen as related to the simply typed lambda calculus. Not so much the untyped lambda calculus that is usually presented
19:11:02 <mac10688> sssilver, that's really a technicality because of currying, most functions that take more than one parameter return a function
19:11:03 <urshanabi> sssilver, no way around it. it's the whole point. it's the mechanic that enables functional languages to do what the "normal" languages do
19:13:00 <ski> urshanabi : .. every Haskell function takes exactly one argument
19:14:15 <geekosaur> I thought that was exactly what urshanabi was talking about. but it's not FP-specific,, it's a Haskell (and Curry)-ism
19:14:23 <erisco> sssilver, besides, how are you going to enjoy returning types from functions?
19:14:28 <geekosaur> most FP languages aren't quite so uncurried
19:14:57 <urshanabi> "i suppose" should hint that i'm not speaking literally
19:15:05 <urshanabi> you could model it that way and get away with it
19:15:12 <urshanabi> at least, i've been able to so far
19:15:18 <sssilver> erisco I don't mind a function that returns a number, or even a string
19:15:19 <ski> sssilver : do you feel uncomfortable with a compiler accepting a source program and producing an executable, which in turn can accept input and produce output ?
19:15:47 <sssilver> but in haskell more than elsewhere I get these functions that return functions, and that's a slippery slope
19:15:56 <sssilver> because then what if you return a function that returns a function that returns a function also?
19:15:58 <sssilver> and so on
19:16:10 <sssilver> suddenly you find yourself in this conundrum 
19:16:11 <urshanabi> it's not a slippery slope. it's vertical. haskell is the epitome of this
19:16:27 <geekosaur> every time you write a fucntion thatakes multiple parameters" you are doing exactly that
19:16:54 <sssilver> you may suddenly have like a chain of a million functions returning functions, and that seems ridiculous
19:17:00 <erisco> sssilver, but just one string? just one number? why not enjoy returning the whole thing? string and int themselves!
19:17:21 <geekosaur> f a b c: f = (\a -> (\b -> (\c -> whatever)))
19:17:27 <ski> sssilver : do you feel uncomfortable with the derivative function, which accepts a (differentiable) function, and produces a new function (it's derivative) ?
19:17:32 <urshanabi> expanding on ski's bit on compilers
19:17:38 <sssilver> idk, it's difficult to explain to people who haven't done it, but it's so much nicer when you just return scalar values
19:17:41 <urshanabi> how do you feel about compilers compiling other compilers?
19:17:49 <sssilver> like you can actually reason about your program
19:18:06 <erisco> I miss the days when I could reason about my programs
19:18:23 <erisco> but I just can't give up these functions... these blasted functions...
19:18:55 <sssilver> urshanabi I have no idea, I don't program compilers, and I assume most people don't. I don't even have a clue how I would program one, If I had to. I'd probably need to go get a degree for that.
19:19:04 <ski> "reason about your program" -- reason operationally/procedurally ?
19:19:14 <pacak> http://quasimal.com/images/funsh/funsh.png - kind of accurate
19:19:15 <urshanabi> it's a program that takes in text and produces other programs
19:19:20 <urshanabi> like a function that returns functions
19:19:23 <sssilver> yeah like "here's a function. It returns a number." -- pretty reasonable.
19:19:38 <sssilver> "here's a function. It returns another function. Which maybe returns another one." -- pretty complicated
19:19:57 <sssilver> Im not venting, I am just trying to understand why everyone here prefers it that way
19:19:57 <urshanabi> you're never in the dark about whether a function returns functions
19:19:59 <pacak> sssilver: It's not.
19:20:00 <urshanabi> its type signature spells it out
19:20:09 <pacak> :t (+)
19:20:11 <lambdabot> Num a => a -> a -> a
19:20:12 <pacak> :t (+) 1
19:20:12 <monochrom> It sounds complicated because of poor wording.
19:20:13 <lambdabot> Num a => a -> a
19:20:15 <pacak> :t (+) 1 1
19:20:17 <lambdabot> Num a => a
19:20:21 <erisco> I once told someone to send me half the payment up front, but they said partially applied division was too complicated, so they didn't
19:20:44 <pacak> Currying - function that returns function.
19:20:58 <urshanabi> count up the arrows `->`. each one is a layer of returning functions
19:21:01 <ski> sssilver : how's that that much more complicated than "here's a record/struct/object/hashmap/dictionary/map. At a particular field/key/&c. it contains another record/.... Which maybe contains another one." ?
19:21:03 <sssilver> inferring who's actually invoking what when where becomes a whole quest
19:21:05 <urshanabi> well... minus one
19:21:12 <urshanabi> you always know just how deep in you are
19:21:18 <ski> sssilver : or file systems, with directories containing directories containing directories ?
19:21:19 <sssilver> coz returning a function is one thing; invoking it is another
19:21:29 <pacak> :t print
19:21:31 <lambdabot> Show a => a -> IO ()
19:21:34 <pacak> urshanabi: Do you?
19:21:40 <pacak> :t printf
19:21:42 <lambdabot> PrintfType r => String -> r
19:21:58 <pacak> :t printf "%i %i %i"
19:22:00 <lambdabot> PrintfType r => r
19:22:04 <urshanabi> pacak, ?
19:22:20 <erisco> sssilver, did that make sense to you?
19:22:22 <ski> sssilver : "why everyone here prefers it that way" -- because it's helpful to avoid boilerplate-code / code repetition. and for abstraction (separation of concerns, separating interface from implementation, &c.)
19:22:34 <pacak> this printf takes 3 arguments, there are 0 arrows in type signature
19:22:37 <urshanabi> i am often shocked by how concise haskell code is
19:22:40 <monochrom> Real world compilers are complicated because we expect so much from them---insane language syntax, incredible code optimization---but apart from that they are algorithmically simple.
19:23:08 <monochrom> Philosophically unsettling but engineering-wise straightforward, doable, has been done.
19:23:49 <monochrom> But armchair philosophers conflate philosophically unsettling with complicated.
19:23:58 <sssilver> alright well, I guess I need to return my first 10000 functions before I complain about this
19:24:17 <ski> sssilver : if by "inferring who's actually invoking what when where becomes a whole quest" you mean the exact sequence of calls and returns, then that indicates a too heavy reliance of operational/procedural understanding of the program ("what things do")), and too little of denotational/declarative understanding ("what things are")
19:24:29 <urshanabi> are you comfortable with passing in functions as arguments?
19:24:50 <sssilver> ski yeah guess why, because computers perform sequences of operations -- it's how they work, kinda
19:25:14 <erisco> sssilver, you already understand the sense of returning functions because you understand the sense of a task where not all the parameters have been filled in yet
19:25:16 <monochrom> "Wow a program that outputs a program!" That's exactly the kind of imprecise, distracting speech that magicians use to impress gullible people.
19:25:23 <ski> sssilver : while important, it's only half the story. focusing too much on that misses important points about computation
19:25:47 <sssilver> urshanabi yeah I mean I write async code for networking all the time
19:25:55 <sssilver> urshanabi so I pass in closures that get invoked whenever
19:26:01 <sssilver> but that whenever is pretty well defined in the code
19:26:10 <erisco> monochrom, great for news media too... "Program that writes programs spirals out of control. Programmers rush to shut it down..."
19:26:12 <urshanabi> so do you want to have to write every single function, or would you enjoy a layer of abstraction over that?
19:26:16 <urshanabi> e.g., function factories
19:26:46 <monochrom> Oh yeah, I have long since lost track of the difference between journalists and conjurers.
19:27:14 <urshanabi> conjurers are entertaining. journalists not
19:27:18 <urshanabi> boom. line drawn
19:27:26 <sssilver> urshanabi I mean I get the idea (I think) of returning functions. I just feel like it gets out of control, which is why in practical languages most people don't program that way 99% of the time.
19:27:49 <sssilver> you define functions, maybe you pass them as arguments sometimes (rarely), even more rarely you return them...
19:27:54 <sssilver> most of the time you kinda return scalar values
19:27:57 <sssilver> of whatever types
19:28:03 <urshanabi> if you can parse the signatures, you always know where you are
19:28:09 <pacak> sssilver: But.... Haskell is a practical language.
19:28:11 <urshanabi> i'm not sure what your practical complaint is
19:28:14 <erisco> sssilver, you're just dead wrong.
19:28:36 <urshanabi> i get that it's new to you and you're not comfortable yet. that's natural when encountering anything new
19:28:39 <sssilver> I mean practical languages like Java, C++, etc
19:28:47 <ski> sssilver : sometimes, a function can take a description of a task to do (e.g. a regex description), and *compute* and return a function that specially optimized to match its input strings according to this regex. one could think of this as a simple "run-time compiler". in general, it can sometimes be helpful to, from a given "configuration", generate a (hopefully) more efficient version of some code, that doesn't have to "interpret" the config each time it 
19:29:08 <ski> (er, cut off near : ".., generate a (hopefully) more efficient version of some code, that doesn't have to \"interpret\" the config each time it operates")
19:29:10 <monochrom> Practical languages like C++ are routinely used to write practical compilers.
19:29:25 <sssilver> I don't intend to make anyone angry or disappointed in here. I admit that my view on this is probably shallow.
19:29:35 * ski . o O ( conjournalists )
19:30:12 <sssilver> I wrote multiple toy programs in Haskell, and it always so happens that every time I have to return a function, it feels weird and uncomfortable and scary and my heart rate goes up. Hence I came here.
19:30:22 <erisco> sssilver, you intend something, because you want to explain to us why functions are too confusing and impractical
19:30:31 <monochrom> You may as well surmise on how recursion is the end of the world.
19:30:33 <geekosaur> sounds like functional programming is not for you :)
19:31:09 <sssilver> recursion is my biggest fear lol, every time I have to implement a recursive algorithm in any language I wanna go throw myself off the bridge
19:31:10 <ski> sssilver : however, most of the time (in Haskell), it's just a matter of style/taste/convention/culture. basically, since there's no inherent concept of "multiple arguments" in Haskell, you can choose to represent/encode it as either "curried" or "tupled" style. the former is most commonly picked
19:31:22 <erisco> sssilver, alternatively, you can believe that we understand your confusion, i.e. we have all felt it, and then we can move on to learning about functions, which we all like doing
19:32:00 <sssilver> you guys are probably those people that eat recursion for breakfast
19:32:00 <nshepperd> sssilver: well then, if it feels scary, the only thing we can do is reassure you that as you continue learning it will stop being scary
19:32:27 <EvanR> recursion rocks
19:32:27 <ski> sssilver : learning recursion is just as important as learning pointers, imho. iteration is a special case of recursion
19:32:40 <mnoonan_> sssilver: honestly, that kind of sounds similar to when students are learning an OO or procedural language, but are afraid to make new classes or functions because it seems like a big scary hassle.
19:33:08 <EvanR> functions for life
19:33:09 <ski> sssilver : with enough practice, recursion becomes a no big deal
19:33:21 <erisco> sssilver, I've felt this, you might feel this, we can work past it https://www.youtube.com/watch?v=rmNERNEzqu8
19:33:42 <monochrom> Pointers are not free of recursion either. Routinely you code up a binary search tree in which a parent node points to a child node and that child node has a "parent pointer" pointing back to the parent node.
19:33:48 <urshanabi> sssilver, recursion and iteration are equivalent
19:33:56 <urshanabi> at a logical level
19:34:05 <monochrom> In fact the irony is that you do this "parent pointer" thing in C++. You don't do this in Haskell.
19:34:30 <ski> it's called zippers
19:34:52 <ski> (somewhat inaccurate, but useful enough as a comparision)
19:35:03 <urshanabi> zippers are badass. i recently implemented one because the haskell wikibook chapter was annoying about it
19:35:24 <urshanabi> no offense to the writer. the story just wasn't my style
19:35:30 <monochrom> Zippers don't exhibit self-loops either.
19:36:27 <monochrom> Anyway you have more recursion in C++ than in Haskell if you look at your data structures instead of your algorithms.
19:38:15 <erisco> and C is a functional programming language
19:40:17 <sssilver> it's pretty non-idiomatic to return functions all the time in C code
19:40:46 <erisco> that's a joke that I thought monochrom might know
19:41:15 <geekosaur> you can do anything in C if you are masochistic enough.
19:41:25 <monochrom> I might know. :)
19:41:41 <geekosaur> see for example gtk which implements a while OOP framework for itself
19:42:11 <geekosaur> (with a whole lotta unsafeCoerce-equivalents hidden in macros)
19:43:07 <monochrom> I learned that in a simpler, older setting: Win16 API.
19:43:32 <erisco> my favourite line is the bit about char*
19:43:40 <monochrom> Marvel at this: struct X { int field1; long field2; char extensions[1]; }
19:44:05 <erisco> I don't read too many truly programming jokes, but that is definitely one
19:44:17 <geekosaur> X11 does a simpler version of what gtk does, for that matter
19:44:21 <monochrom> The idea is you can malloc(sizeof X + 100) and now you have 100 bytes at the "extensions" locate for extra fields for subclasses.
19:44:32 <monochrom> s/locate/location/
19:44:44 <geekosaur> libXt in particular
19:44:44 <ski> except `sizeof' is now borken
19:45:04 <monochrom> Yeah I wouldn't be surprised if it all started at Xerox PARC
19:45:20 <pacak> monochrom: Yea, also all sorts of security issues.
19:45:40 <monochrom> Aw you're all supposed to write perfectly correct code. :)
19:45:43 <urshanabi> sssilver, pragmatically...
19:45:51 <urshanabi> how does this hang-up enable you to do more?
19:46:13 <pacak> I'm better at writing perfect code when compiler complains.
19:46:20 <sssilver> urshanabi you mean the whole conversation? sorry English isn't my first language; what does "this hang-up" mean?
19:46:23 <urshanabi> sometimes life is about saying fuck-you to our sensibilities and doing what has returns
19:46:36 <urshanabi> a hang-up is a limitation. something you won't let yourself get past mentally
19:46:39 <sssilver> (hell it isn't even my second language, now that I think about it)
19:46:58 <urshanabi> man, i am punning hard on 'returns' :P
19:47:14 <sssilver> so in this case the hang-up is the mental barrier of returning functions?
19:48:32 <sssilver> I feel like the whole paradigm of declarative programming is somehow making time disappear. And that's extremely unusual. Because I get it, yes x is A, and y is B, but how do you program for *when* does stuff happen? pretty tricky
19:48:38 * ski supposes sssilver has already seen <https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/>
19:49:00 <sssilver> *when* does stuff *happen* rather (adding more asterisks)
19:49:44 <erisco> I would give my speech on how declarative programming and imperative programming are only an inch apart but I want to sleep instead
19:50:04 <remexre> sssilver: I guess what Haskell (and laziness) does for you is let you ignore that 99% of the time, and for the 1% that does matter you've got a nifty monad
19:50:15 <urshanabi> sssilver, the pure part of haskell doesn't need to be sequenced
19:50:27 <urshanabi> the impure stuff is in the monads, which you do sequence to ensure one thing happens before the other
19:50:56 <sssilver> and I guess that helps us, because if we're sequencing *all* the time, that can be a major source of bugs
19:51:01 <erisco> but succinctly: you can declare when something is to happen as much as you can command it to
19:51:02 <sssilver> ...for when we get the sequence wrong
19:51:05 <ski> as mentioned, declarative programming tends to add more focus to "what","is" over "how","when","do" -- that's a liberation. and in fairness sometimes also a curse
19:51:33 <urshanabi> it doesn't matter that the pure computation you wrote doesn't get run until the absolute last second before it's needed. it's pure, it doesn't mutate state or create side effects. the result of pure functions is always the same for the same arguments
19:51:41 <ski> @quote value.of.everything
19:51:42 <lambdabot> newsham says: functional programmers know the value of everything and the cost of nothing
19:51:44 <sssilver> somebody the other day offered me to implement https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Algorithm in Haskell as a proof that Haskell sucks
19:51:51 <ski> @quote value.of.nothing
19:51:52 <lambdabot> newsham says: C programmers know the cost of everything and the value of nothing.
19:52:16 <ski> hm, i suppose
19:52:18 <ski> @quote LISP.programmer
19:52:18 <lambdabot> cmccann says: Ruby is a fine language if you're secretly a lisp programmer but want to hide behind perl and smalltalk so nobody catches you
19:52:32 <newsham> ?quote lambdabot
19:52:33 <lambdabot> lambdabot says: there is nothing going on in your pants that the dictatorship of the proletariat will not solve
19:52:33 * ski sighs .. decides to ignore this venture
19:52:37 <remexre> hey, as a lisp programmer and ruby hater I resent that
19:52:41 <newsham> ?nixon
19:52:42 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
19:52:54 <newsham> yikes
19:53:02 <remexre> yeah, that was a bit more...
19:53:21 <erisco> to declare when something is to happen is to trust in the understanding of dates and times
19:53:26 <c_wraith> I thought Nixon was removed once.
19:53:42 <newsham> ?farber
19:53:42 <lambdabot> They'll dazzle you out of your socks.
19:53:53 <erisco> to command something to happen when you want it to is to wait until that time and then order it so
19:54:06 <newsham> thats the great thing about lambdabots, there are so many (forks) to choose from
19:54:42 <erisco> so, declaring uses a mutual understanding, commanding does not
19:54:56 <ski> sssilver : "for when we get the sequence wrong" -- the default needs to be that sequencing doesn't matter (is not specified), so that you can *rely* on it (in those cases)
19:56:08 <erisco> declaring delegates responsibility, commanding does not
19:56:15 <ski> (can rely on it not mattering, that is)
19:57:19 <erisco> commanding means having done *your* way and declaring means having it done *some* way
19:58:06 <urshanabi> having it done your way even when your way is stupid and wasteful
19:58:17 <erisco> but the reason they are an inch apart is because the language in which we command relies upon mutual understanding of the words
19:58:20 <urshanabi> and paying an overhead to mitigate that
19:58:48 <erisco> so regardless of how specific we want to be we must eventually give up and rely on the other to understand
19:59:40 <erisco> did you command the CPU when to fetch the memory? or where to cache it? or what branches to predict? nope
19:59:42 <EvanR> i still dont really understand why imperative code is harder to reason about
20:00:22 <EvanR> some kind of emergent complexity
20:00:31 <monochrom> erisco: Ah, that's what I think too, though usually I put it differently: "they're relative notions".
20:00:31 <urshanabi> constant state mutation
20:00:38 <urshanabi> i'm shocked by how easy it is to read pure code
20:00:55 <mnoonan_> argh, I just realized that my unanswered email went to poor, hapless emkett@gmail.com
20:00:57 <urshanabi> whereas whenever i'm reasoning about imperative code, i have to run it in my head to know the current state
20:01:30 <EvanR> a hidden state or something is just one way to understand certain kinds of imperative code
20:01:43 <remexre> urshanabi: Actually, I know a trick that makes pure and imperative code just as easy to read
20:01:47 <remexre> unsafePerformIO
20:01:59 <EvanR> o_O
20:02:13 <urshanabi> thankfully the definition of pure would disagree with that, remexre :P
20:03:05 <urshanabi> yep, i make no progress today
20:03:07 <monochrom> Perhaps "just as easy" is equivalent to "just as hard".
20:03:13 <urshanabi> on account of this dependency silliness
20:03:48 <monochrom> haha mnoonan_ oops
20:09:17 <sssilver> so, is the fact that Haskell isn't as performant as C++/Rust/C just a temporary implementation problem that wouldn't exist if the Haskell compiler engineers did a better job?
20:09:49 <sssilver> because while on CPU you don't sit down and think about branch prediction, it's ultimately a behind the curtains thing that makes your program faster
20:10:29 <EvanR> or slower if your program defies expectations of cpu designers
20:10:36 <remexre> afaik Haskell is slower because GC and laziness, mainly
20:10:40 <c_wraith> The data model implies some things will be a bit slower.  There are just more pointers, even when you do smart things.
20:10:45 <urshanabi> if you want to rank languages on the single dimension of performance, you'll find yourself making some ugly sacrifices to come out ahead
20:11:07 <remexre> https://fortran.io/ <-- ugly sacrifices
20:11:37 <c_wraith> But at the same time, why would you compare haskell to C, C++, or rust?  It's designed to work in the realms where garbage collection is a win.
20:11:40 <mnoonan_> remexre: oh my god, that is amazing
20:12:32 <monochrom> This is excellent.
20:12:33 <remexre> c_wraith: Eh, Rust has been competitive in expressiveness with Haskell for me. I actually just finished rewriting a semi-legacy Haskell codebase into Rust
20:12:36 <urshanabi> hahaha
20:13:29 <c_wraith> remexre: do you do nothing interesting in your code?  I tried rust occasionally, but I wanted a low-level equivalent to Haskell, and it's...  not.  It just isn't.  You can't write code the same way.
20:13:54 <DawnWhite> hello there
20:14:09 <remexre> c_wraith: It's basically a middleware+cache; I definitely don't do anything "fancy" in it
20:14:23 <remexre> The Haskell vs. Rust wasn't the reason for the rewrite though
20:14:39 <DawnWhite> I need some help to learn haskell
20:14:51 <DawnWhite> can someone help me!!
20:14:59 <monochrom> Lua is less performant than both Haskell and C. Lua is used in games all the time. The world is strange. Don't ask why.
20:15:14 <remexre> monochrom: Easy to embed
20:15:14 <c_wraith> Not that I have anything against Rust, I just wouldn't use it for things that Haskell is good for.
20:15:40 <c_wraith> DawnWhite: people here will happily help out with specific questions you might ask.
20:15:58 <remexre> idk, what would you see Haskell as being good for that Rust isn't?
20:16:01 <sssilver> DawnWhite are you just looking for http://www.seas.upenn.edu/~cis194/spring13/lectures.html ?
20:16:06 <urshanabi> what is lua's selling point?
20:16:10 <urshanabi> i've heard of it but never used it
20:16:22 <remexre> urshanabi: It's *really* easy to embed
20:16:27 <remexre> e.g. in a game engine
20:16:31 <urshanabi> i see. that'd explain it, then
20:16:32 <monochrom> From my angle Norman Ramsey is Lua's selling point. :D
20:16:45 <urshanabi> it'd also explain lua in redis
20:17:02 <c_wraith> remexre: anything that requires long-term maintenance and doesn't care about GC overhead, I'd much rather use Haskell.
20:17:54 <DawnWhite> yes guys can I some question in specific!!
20:18:25 <wedify> DawnWhite: just ask your question
20:18:37 <monochrom> It sounds to me how easy to embed is up to someone writing a runtime system for embedding rather than language design.
20:18:49 <remexre> c_wraith: eh, if it's a matter of personal preference, then /shrug. I like that it uses an LLVM backend, macros (that feel less "bolted on" than TH), and better FFI with other languages
20:19:08 <DawnWhite> I've installed Haskell by following the instructions from https://docs.haskellstack.org/en/stable/README/ this link
20:19:18 <c_wraith> monochrom: both are needed.  You need a language design that isn't full of back doors to make embedding sane.
20:19:20 <sssilver> well lua is also a tiny, no-bullshit scripting language, which is a huge win if you wanna get some people who call themselves "game designers" to write minimal code
20:19:29 <remexre> monochrom: I believe Lua's also supposed to be highly predictable, too
20:19:31 <sssilver> Python is close, but Python is a much bigger language
20:19:35 <Hafydd> I'm not sure about the "no bullshit" part.
20:19:49 <c_wraith> monochrom: this is why python makes for a horrible scripting language.  It's too dynamic.  You can't sandbox anything effectively.
20:19:50 <monochrom> Haskell isn't full of backdoors either...
20:19:52 <Hafydd> It has some fucked up almost regular expressions.
20:20:00 <sssilver> "no bullshit" aka "you don't need to reread any paragraph twice in order to understand what to do when"
20:20:02 <Hafydd> And strange scoping.
20:20:06 <c_wraith> monochrom: it's true.  haskell falls down on the runtime side. :)
20:20:17 <glguy> Lua's exceedingly "dynamic", it's anyone's guess what any particular bit of code does because everything can be overloaded
20:20:27 <DawnWhite> I have to where to code and do I need to do all the stack setup, stack build stuff again?
20:20:59 <remexre> DawnWhite: You use `stack build' whenever you want to recompile the project; you can write Haskell in any plain text editor
20:20:59 <sssilver> DawnWhite https://www.haskell.org/downloads
20:21:39 <glguy> But Lua has a clean C API for integrating callbacks from Lua back into a C interface that doesn't leak internal Lua memory representations and a small library that needs to be linked in and makes it easy to load code at runtime
20:21:55 <monochrom> Although, Haskell may be a bit too disciplining for most game designers.
20:23:23 <c_wraith> remexre: I dunno.  I just am not happy in a language that can't even express an idea like traverse.  (That is not a sufficient condition - I'm not happy in Scala either.  But that's for other reasons)
20:23:26 <DawnWhite> I'm using Mac can someone tell me and send me some link about procedures for writing, compiling, running Haskell 
20:24:03 <sssilver> DawnWhite https://www.haskell.org/platform/mac.html
20:25:11 <systemfault> I personally take the "use homebrew to install the haskell-stack package to get ghc" way.
20:25:41 <urshanabi> brew abandoned haskell-stack
20:25:45 <urshanabi> it's no longer being packaged
20:25:49 <systemfault> Oh, really? :(
20:25:51 <systemfault> That's sad.
20:25:54 <remexre> c_wraith: I guess I'm not using the category theory "fun stuff" in the Rust project, and I am in the Haskell project I'm working on now, but... I dunno, when would you use traverse vs. map() with side-effects being legal?
20:26:09 <urshanabi> yep. i tried to install it on my work computer today. no dice
20:27:00 <urshanabi> btw, i figured out that dependency stuff
20:27:12 <urshanabi> just added the other repo as a source directory
20:27:16 <ski> EvanR : "i still dont really understand why imperative code is harder to reason about" -- loss of commutativity, idempotence, cancellability
20:27:37 <urshanabi> should work for packaging and all, i figure
20:27:54 <urshanabi> the alternative was running a git server locally and giving the dep as a git ref
20:27:59 <urshanabi> fuck all of that
20:28:00 <jared-w> ski: you can say that about non-pure mutable code as well. Imperative doesn't directly assume non-pure and mutability, although it's certainly a correlation
20:28:06 <ski> EvanR : of course, at a conceptual level, the same issues are still there with `IO'. but since it's cleanly separated from the evaluation part of the language, even (only) this is a huge win
20:28:36 <urshanabi> i rather like knowing i'm in IO-land
20:28:41 <urshanabi> or State-land
20:28:55 <ski> (one important aspect of using monads for effects in Haskell is that you can easily tell when you're *not* using one)
20:29:09 <urshanabi> that stuff just flies under the radar in imperative languages. you don't differentiate the clean, simple subset from the complex one
20:29:32 <DawnWhite> sssilver I unable to understand what is happening in the installing process you've sent me a link to download then what am I doing in terminal?!?!
20:29:40 <ski> jared-w : all Haskell code is pure (not counting abuses of `unsafePerformIO' and the like)
20:29:51 <sssilver> DawnWhite you're gonna need some code editor to write Haskell code
20:29:55 <sssilver> many people use vim
20:30:02 <sssilver> there are other options
20:30:12 <sssilver> Sublime, IntelliJ IDEA, Visual Studio Code
20:30:24 <urshanabi> spacemacs
20:30:27 <jared-w> right, and its pureness, non-mutability, and laziness is what allow equational reasoning to hold unconditionally. (I probably missed some of the conversational context)
20:30:29 <sssilver> ^ blasphemy
20:30:34 <sssilver> (spacemacs+
20:30:43 <systemfault> Visual Studio Code is really great with Haskero (If you don't use the classics: vim/emacs)
20:30:43 <remexre> ^^
20:30:46 <urshanabi> blasphemy is the best part
20:31:00 <urshanabi> i don't think DawnWhite is asking about an editor, though
20:31:12 <urshanabi> i don't know what DawnWhite is asking specifically, but i don't think that's it
20:31:23 <ski> jared-w : .. so i'm not sure what you're referring to by "non-pure mutable code", in the context of Haskell
20:31:29 <ski> (perhaps we're violently agreeing ?)
20:31:46 <c_wraith> remexre: there are many different Applicative instances than IO.  The main point of most of them being that they don't allow IO.
20:32:42 <remexre> c_wraith: Sure, but I feel like unintended mutation is more often the issue than unintended IO, and Rust restricts mutation such that you're strongly discouraged from doing it "secretly"
20:32:42 <ski> remexre : "when would you use traverse vs. map() with side-effects being legal?" -- persistent vs. ephemeral values
20:33:13 <ski> (iiuc what you were after)
20:33:37 <remexre> c_wraith: I guess that's basically the Rust vs. Haskell distinction; Rust encourages you to write Haskell, but you can write C if you want
20:33:44 <ski> remexre : another answer would be -- when you want to option of doing non-standard interpretations
20:33:59 <remexre> ski: What other Applicative would you use? Is there a small example I could see?
20:34:09 <ski> would i use for what ?
20:34:28 <remexre> For traverse, if not IO... wait, c_wraith said that
20:34:35 <remexre> I'm not quite sure what you're getting at, either though
20:34:48 <c_wraith> remexre: Const and Identity are really important Applicative instances, for my uses.  (I may be using traverse as a proxy for many other things)
20:35:25 <monochrom> If you want to do IO over a list, Applicative is fine. (sequenceA, traverse, ...)
20:35:26 <ski> remexre : how about a parser idiom (or monad) ?
20:35:56 <remexre> ski: Would I traverse over my input, then?
20:36:19 <ski> perhaps
20:36:39 <remexre> Hmm.
20:36:57 <remexre> I guess if I keep learning more Haskell, I'll eventually bump into it
20:38:50 <c_wraith> remexre: mostly..  if a language allows you to write traverse, it allows you to write the parts of lens that make the library really good, and make it far more than just accessors.
20:39:39 <remexre> c_wraith: What are those parts? I kinda get lenses-as-accessors, and I know there's something in those murky depths, but I don't know what
20:40:31 <c_wraith> remexre: the ability to work over arbitrarily many targets within a data structure simultaneously.
20:41:02 <remexre> ? I assume you don't mean foo.a = foo.b = 4;, but I'm not sure what you mean
20:41:41 <c_wraith> > [1..10] & traverse . filtered even +~ 2
20:41:43 <lambdabot>  [1,4,3,6,5,8,7,10,9,12]
20:42:01 <remexre> woah
20:42:02 <remexre> okay
20:43:28 <jared-w> Do you get what that's doing? It's pretty neat :p
20:43:40 <monochrom> I don't.
20:44:04 <remexre> Adding two to every even element, right?
20:44:17 <monochrom> Yikes
20:44:25 <pacak> Looks like shit because of & and +~
20:44:29 <systemfault> Neat or evil?
20:45:04 <jared-w> "take this data structure, traverse through it, and increment all the even items by 2"
20:45:04 <systemfault> @src (&)
20:45:05 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
20:45:05 <pacak> traverse creates an traversal into list, filtered - filters even elements.
20:45:15 <pacak> systemfault: flip ($)
20:45:21 <systemfault> Thanks!
20:45:33 <monochrom> This sounds like perfect for those pesky CIS194 "wholemeal programming" questions and the credit card question.
20:45:35 <pacak> :t traverse . filtered even
20:45:36 <lambdabot> (Integral a, Applicative f, Traversable t) => (a -> f a) -> t a -> f (t a)
20:45:47 <jared-w> The mnemonic for & is "and then", so (data structure) "and then" (do thing)
20:46:00 <urshanabi> :t &
20:46:01 <lambdabot> error: parse error on input ‘&’
20:46:04 <urshanabi> :t (&)
20:46:05 <jared-w> which tends to flow a bit better mentally than (do thing) "to" (data structure)
20:46:06 <lambdabot> a -> (a -> b) -> b
20:46:16 <pacak> :t (traverse . filtered even) (\x -> pure x + 1) [1,2,3,1,1]
20:46:18 <lambdabot> (Num (f a), Integral a, Applicative f) => f [a]
20:46:23 <pacak> > (traverse . filtered even) (\x -> pure x + 1) [1,2,3,1,1]
20:46:26 <lambdabot>  error:
20:46:26 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M68429...
20:46:26 <lambdabot>        prevents the constraint ‘(Show (f0 [a0]))’ from being solved.
20:46:29 <urshanabi> i see. kind of like infixing the operation
20:46:34 <pacak> > (traverse . filtered even) (\x -> pure x + 1) [1,2,3,1,1] :: [Int]
20:46:36 <lambdabot>  error:
20:46:36 <lambdabot>      • Couldn't match type ‘[a0]’ with ‘Int’
20:46:36 <lambdabot>        Expected type: [Int]
20:46:42 <ski> `Num (f a)' is suspicious, pacak
20:46:46 <pacak> > (traverse . filtered even) (\x -> pure (x + 1)) [1,2,3,1,1] :: [Int]
20:46:48 <lambdabot>  error:
20:46:48 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Int’
20:46:48 <lambdabot>        Expected type: [Int]
20:47:01 <pacak> Hmm... Something along those lines anyway.
20:47:02 <c_wraith> pacak: maybe take it to private until you get it working right? :)
20:47:07 <ski> (also, it may be better to ask lambdabot in private)
20:47:23 <jared-w> > traverse . filtered even +~ 2 $ [1..10]
20:47:26 <lambdabot>  [1,4,3,6,5,8,7,10,9,12]
20:47:52 <c_wraith> > over (traverse . filtered even) (+2) [1..10] -- if you want to get rid of most infix operators
20:47:54 <lambdabot>  [1,4,3,6,5,8,7,10,9,12]
20:48:16 <jared-w> c_wraith: but that's too readable... /s
20:48:23 <monochrom> haha
20:48:39 * pacak dislikes all the things in Control-Lens-Operators
20:49:06 <jared-w> Symbolic notation is quite powerful for abstraction. The fact that it's all ascii is unfortunate...
20:50:06 * hackagebot ghost-buster 0.1.1.0 – Existential type utilites – https://hackage.haskell.org/package/ghost-buster
20:51:38 <iqubic> jared-w: Do you like APL?
20:51:53 <iqubic> Seems like you would.
20:51:53 <jared-w> friggin love APL
20:51:53 <pacak> jared-w: Using non-ascii seems like a good idea until some program you've been using (that was written by idiots) dies because some other program (that's written by other kind of idiots) decides that using "foo :: a -> b" as a type signature is not l33t enough and it must be "foo :: α -> β".
20:52:03 <jared-w> (or rather, I want to learn it)
20:52:51 <jared-w> pacak: Not /everything/ needs to be unicode, but sometimes the mathematical operators just do a way better job of conveying the concept symbolically
20:53:26 <iqubic> jared-w: I'm still trying to figure out how to type those non-alphnumeric ascii chars.
20:53:57 <glguy> Try a* then alt-K  or b* alt-K
20:54:10 <iqubic> glguy: That only works in glirc.
20:54:27 <iqubic> I want to be able to input stuff like that in any program.
20:54:27 <glguy> in Vim it's very similar
20:54:34 <iqubic> glguy: I use Emacs.
20:54:50 <glguy> ouch, but you can input it in emacs, too!
20:54:51 <pacak> iqubic: compose key or separate layouts.
20:55:10 <iqubic> pacak: Yeah, I'm trying to figure out xmodmap, so I can get a compose key.
20:55:12 <pacak> <compose_key>CCCP gives  ☭
20:55:24 <mnoonan_> i’m vaguely remembering some latex -> unicode input mode in emacs.. was i dreaming?
20:55:29 <iqubic> What does CCCP mean?
20:55:54 <pacak> setxkbmap -option compose:menu
20:56:11 <pacak> iqubic: Союз Советских Социалистических Республик.
20:56:12 <geekosaur> fake-Cyrillic for the Russian phrase translated "Union of Soviet Socialist Republics"
20:56:16 <pacak> Soviet Union.
20:57:06 <iqubic> pacak: That works. However I also want to map Caps to Esc, and Shift-Caps to Caps Lock.
20:57:23 <iqubic> And I don't think setxkbmap will do that for me.
20:57:26 <jared-w> pacak: that's only if your compose key is setup with defaults (like in Ubuntu or something)
20:57:45 <geekosaur> iqubic, it can but you'd have to write the rules for it yourself
20:58:03 <geekosaur> instead of using predefined ones
20:58:08 <jared-w> iqubic: I have my caps mapped to both escape and control
20:58:09 <iqubic> Oh, sounds like a pain. xmodmap seems simpler.
20:58:21 <geekosaur> it is simpler but it does less
20:58:23 <jared-w> If I tap the caps key, it's escape; if I chord it with another key, it's a control key
20:58:28 <iqubic> jared-w: I don't want caps mapped to control
20:58:39 <iqubic> or perhaps I do.
20:58:45 <iqubic> How do you do that jared-w?
20:58:58 <geekosaur> otoh Xkb is such a monstrous mess that the Wayland folks picked it up as is and wrote their keyboard handling around it, rather than try to understand or replace it
20:59:15 <iqubic> And could I add shift-caps to toggle Caps Lock State?
20:59:28 <iqubic> Or is that too much to ask for?
20:59:28 <jared-w> I use setxkbmap (or xmodmap) along with a small program called xcape
20:59:29 <geekosaur> actually I'm not sure you can do that with either one
21:00:00 <iqubic> what's xcape?
21:00:11 <iqubic> don't you mean escape?
21:00:26 <jared-w> No the program is called xcape; it allows you to do some pretty  nifty keybind modifications
21:00:33 <geekosaur> https://github.com/alols/xcape
21:00:57 <jared-w> I use it to bind the tapping of the caps-lock to escape, and then I rebind capslock as ctrl so it works for both
21:01:10 <iqubic> I see.
21:01:22 <iqubic> And how do you turn caps lock on and off?
21:01:48 <geekosaur> I generally don't even bind caps lock
21:02:12 <iqubic> No, not at all?
21:02:12 <pacak> geekosaur: BUT WHAT IF YOU WANT TO TYPE IN LARGE LETTERS?????
21:02:43 <jared-w> I don't even have a caps lock on my system at all tbh
21:02:44 <geekosaur> shouting usually doesn't help :p
21:03:05 <jared-w> I use vim's gU when I want to translate things to caps ¯\_(ツ)_/¯
21:03:27 <iqubic> jared-w: How does that work?
21:03:50 <jared-w> gUw capitalizes a word, guw lowercases a word
21:04:29 <iqubic> jared-w: I want to emulate your setup.
21:04:32 <jared-w> you can replace 'w' with any vim 'object' like sentence, paragraph, until-end-of-line, etc
21:04:32 <pacak> Hᴍᴍᴍ... Hᴏᴡ ᴀʙᴏᴜᴛ ᴀ sʜᴏᴜᴛɪɴɢ ᴍᴏʀᴇ ǫᴜɪᴇᴛʟʏ?
21:04:41 <urshanabi> i'm out of here. will return in the future
21:04:46 <urshanabi> night night
21:05:02 * ski . o O ( <https://en.wikipedia.org/wiki/Small_caps> )
21:05:03 <jared-w> /usr/bin/xcape -e 'Caps_Lock=Escape'  <-- I have this in my ~/.xinitrc
21:05:22 <iqubic> And how did you get the ctrl thing to work?
21:07:01 <jared-w> in my /etc/X11/xorg.conf.d/ directory
21:07:07 <jared-w> I have a 00-keyboard.conf
21:07:44 <iqubic> Why not use setxkbmap?
21:07:59 <jared-w> This is merely the manual version of that command
21:08:22 <iqubic> But how did you get ctrl to work?
21:08:26 <jared-w> setxkbmap works only for the current session. You have put that setxkbmap command in your ~/.xinitrc
21:08:58 <jared-w> in the xkbconf I have a line that reads:   Option "XkbOptions" "caps:ctrl_modifier,compose:rctrl"
21:09:10 <iqubic> Is that all?
21:09:19 <jared-w> (that is, "caps lock is my control key, and my right control key is the compose key")
21:09:41 <iqubic> Is menu the button that opens a context menu?
21:09:42 <jared-w> Well, that's the relevant line of the configuration :) look at the xample keyboard.conf
21:09:55 <iqubic> Where is the example located?
21:10:09 <jared-w> oh whoops, I thought I pasted it, m'bad
21:10:13 <jared-w> https://wiki.archlinux.org/index.php/Keyboard_configuration_in_Xorg#Using_X_configuration_files
21:10:14 <iqubic> Also, I'm installing xcape via package manager.
21:10:21 <jared-w> sounds good, that's what I did
21:11:09 <iqubic> That example doesn't look like it's tailored to my keyboard layout. How do I find the right values to use for my keyboard?
21:13:52 <jared-w> What keyboard layout do you have? US english?
21:14:05 <iqubic> Yeah.
21:14:17 <iqubic> But I'm not sure if it's 104 or 105.
21:14:24 <iqubic> I've had that issue in the past
21:15:08 <jared-w> http://lpaste.net/358038  <-- just copy this one 
21:15:15 <jared-w> (it's my setup)
21:15:50 <iqubic> What does altgr-intl do?
21:16:35 <iqubic> I don't think I have an altgr key. Unless that's just another name for R_Alt
21:18:50 <jared-w> altgr is similar to a compose key, you can chord it with other keys and get different characters
21:18:57 <jared-w> é is altgr+e for example
21:19:19 <jared-w> (it's my right alt key).  altgr-intl sets the "international" keys for the altgr layout
21:19:54 <iqubic> Ah, I see.
21:20:11 <iqubic> So how do I set altgr to right alt?
21:20:23 <iqubic> Or does that config do that already?
21:23:32 <jared-w> it already does that
21:23:39 <iqubic> Cool.
21:23:52 <jared-w> altgr is implicitly the right-alt key
21:23:53 <iqubic> How do I get those changes to take effect? Restart X?
21:24:08 <jared-w> Yup
21:24:26 <jared-w> There /might/ be some weird hacky way to do it without restarting X... but easier to just restart X
21:24:43 <iqubic> And what do I do for xcape?
21:24:54 <iqubic> WHat was the command you added to .xinitrc?
21:26:35 <jared-w> /usr/bin/xcape -e 'Caps_Lock=Escape'
21:26:58 <jared-w> (use where your xcape is actually installed, but it's probably the same location)
21:27:12 <iqubic> Why do you need the fully qualified path? Isn't /usr/bin/xcape in $PATH?
21:28:10 <jared-w> You don't need a fully qualified path, technically, but it's good practice for your ~/.xinitrc and other very early system files because sometimes people set their $PATH later on and it might not be in there... etc
21:28:29 <iqubic> Ah I see.
21:33:39 <iqubic> jared-w: What's the menu key?
21:33:49 <iqubic> How do I determine where my menu key is?
21:33:50 <pacak> ghc-events (event log viewer) is written by strange people...
21:33:52 <pacak> :(
21:34:15 <iqubic> pacak: That is weird.
21:34:22 <jared-w> GHC itself is written by strange people ;)
21:34:34 <jared-w> iqubic: what menu key?
21:35:37 <iqubic> pacak: suggested that I could do menu:compose
21:35:41 <iqubic> for xkb
21:36:07 <jared-w> oh, nah you don't need to do that, your compose key is already the right ctrl key
21:36:09 <pacak> what's the point in having both incremental parser and all-at-once parser (and using incremental only to print stuff) if 16Gb memory is not enough to handle eventlog created over 15 minutes of running time when parsing all-at-once?
21:36:20 <Hijiri> what do you call the stuff to the left of Γ in symbolic logic?
21:36:24 <Hijiri> hypotheses?
21:36:36 <iqubic> Hijiri: How did you type that?
21:36:40 <Hijiri> latex IME
21:36:58 <iqubic> But how did you get it to show up in freenode?
21:37:14 <Hijiri> why wouldn't it show up?
21:37:18 <Rotaerk> hmm should I specially design types for use with cereal, and then after deserialized, convert them to types more appropriate for use elsewhere
21:38:00 <jared-w> Hijiri: He's confused as to what the IME is. Like, how did the \Gamma show up in unicode
21:38:10 <Rotaerk> I want to send a serialize/deserialize a HostName, but that's defined as a String, and I'm not sure how well those serialize...
21:38:16 <Hijiri> what IMEs are or what this particular IME is?
21:38:20 <Rotaerk> seems to want me to use ByteString or Text
21:38:33 <jared-w> Probably both; to be fair I don't quite know what an IME is either
21:38:41 <Hijiri> the IME changes how your keyboard input is processed
21:39:03 <jared-w> Rotaerk: strings don't serialize super well. ByteString or Text is usually preferred. That being said, there's nothing wrong with serializing Strings other than efficiency concerns
21:39:08 <iqubic> jared-w: No, what I'm confused by is: What did he send to the freenode server to get the symbol to show up on my screen.
21:39:26 <jared-w> iqubic: you can just paste in unicode to irc server and it works fine
21:39:29 <Hijiri> iqubic: literally just the character in my client's typing buffer
21:39:30 <Rotaerk> jared-w, hmm k; so it sounds like I should have data type specifically for communication, then
21:39:37 <jared-w> ¯\_(ツ)_/¯   ಠ_ಠ   <-- example
21:39:38 <Rotaerk> and then convert from them to what I need for the actual logic
21:39:57 <Rotaerk> ty
21:40:06 <iqubic> jared-w: I don't see the symbols to the right of that face there.
21:40:07 <jared-w> Rotaerk: one potential (and popular) option is to use something like toJSON and fromJSON for your serialization
21:40:32 <Hijiri> I think I see jared-w's whole message
21:40:38 <iqubic> pacak: What is a menu key and what does "menu:compoes" do?
21:40:46 <jared-w> iqubic: there are only two faces there, one with arms, one without. It's not uncommon for people to not see the second face :p
21:40:47 <Hijiri> maybe it's just a client problem
21:41:04 <jared-w> Hijiri: it's a font problem. Most people don't have an Indic font installed if they're on Linux
21:41:15 <iqubic> What the heck is Indic?
21:41:29 <Hijiri> I probably have a bunch of random foreign fonts installed from when I tried to play h games in wine
21:41:30 <jared-w> One of the many /many/ Indian languages/dialects
21:41:49 <jared-w> in this case these eyes are famous for the `look of disapproval`
21:42:24 <iqubic> Oh yeah. I don't even see kanji either.
21:42:26 <jared-w> http://i0.kym-cdn.com/entries/icons/mobile/000/000/428/1.jpg this was the second face I posted:  ಠ_ಠ
21:42:40 <jared-w> iqubic: you can just install a kanji font if you want to
21:43:11 <iqubic> But how will that help me see the kanji, don't I need to patch my current font, or no what?
21:44:08 <geekosaur> freetype has the concept of font substitution, where if it knows the current font doesn't have a character but it also knows that another font it has loaded does have the character, it will get it from there
21:44:28 <iqubic> Oh interesting. I didn't know that.
21:44:52 <boj> ほんまや
21:44:54 <geekosaur> but you generally have to restart programs after installing a new font for it to work. and some programs can specify their own fallback fonts for such characters
21:45:13 <iqubic> But I have a config file for my terminal that sets the current font. Will that interfere with my kanji stuff.
21:45:25 <geekosaur> depends on the terminal
21:45:37 <iqubic> Also, boj what sorcery is that? I can see that kanji
21:45:47 <iqubic> geekosaur: I use termite.
21:45:50 <boj> well, hiragana
21:46:03 <boj> 日本語はどうですか？
21:46:10 <boj> kanji and hiragana
21:46:14 <iqubic> Whatever it's called I can see all of the characters you have typed.
21:46:17 <Rotaerk> jared-w, hmm; suppose the json option *would* make it more friendly to other languages...
21:46:34 <Rotaerk> not that I'll be using them but...
21:46:40 <iqubic> But they look more pixelated than the other characters.
21:46:47 <Rotaerk> good idea anyway
21:46:52 <boj> maybe my client is sending the correct character set?
21:46:53 <geekosaur> that sounds like substitution may be happening
21:47:03 <pacak> iqubic: bad fonts.
21:47:13 <iqubic> pacak: yeah most likely.
21:47:30 <geekosaur> but the katakana characters are generally simpler, since they represent syllables instead of words (like kanji) and the kanji word glyphs are often fairly complex
21:47:32 <pacak> boj: That's one of the reasons I moved away from Tokyo...
21:47:38 * boj is using boring urxvt + weechat
21:47:42 <geekosaur> er hiragana
21:47:54 <geekosaur> hello brain, try to keep working for a few more minutes >.>
21:47:59 <boj> pacak: why is that?
21:48:27 <pacak> Language :)
21:48:43 <pikhq> Though in history, all the kana come from kanji, just mutated and simplified.
21:49:06 <pikhq> e.g. む and ム both come from 無.
21:49:15 <ongy> hiragana and katakana both fit for that sentence :)
21:49:36 <iqubic> All the foreign language symbols are showing as pixalated for me,
21:49:49 <boj> iqubic: probably your font
21:49:49 <iqubic> I though nerd-font would be better than this.
21:50:00 <pikhq> Matter of the fonts you have installed. It's probably font-substituting something else.
21:50:04 <pacak> iqubic: ß Ы
21:50:24 <iqubic> pacak: That looks fine.
21:50:31 <pacak> iqubic: 你好
21:50:39 <iqubic> and that's pixalated.
21:51:15 <ongy> ß is probably in more "normal" fonts than kanji
21:51:19 <pikhq> Are you on Windows?
21:51:28 <iqubic> Nope. Gentoo Linux.
21:51:32 <pikhq> Well. Linux. Probably not.
21:51:39 * hackagebot miso 0.7.4.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
21:51:50 <iqubic> Using this: https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Hack/Regular/complete/Knack%20Regular%20Nerd%20Font%20Complete.ttf
21:51:55 <pikhq> On Windows, and I think *just* Windows, the font renderer actually renders CJK fonts un-antialiased.
21:52:05 <iqubic> Yeah, well not here.
21:52:20 <pikhq> Yeah, don't recall Freetype doing that. Certainly not by default.
21:52:32 <iqubic>  
21:52:42 <iqubic> And I can send and see stuff like that.
21:52:53 <iqubic>  
21:53:02 <iqubic>   
21:53:13 <iqubic> Symbols like that all look fine.
21:54:41 <pacak> What's the latency of communication between capabilities in ghc?
21:54:57 <boj> 0.10ms
21:55:24 * boj goes back to work
21:56:32 * iqubic wants to figure out how to fix his fonts
21:58:57 <iqubic> How do I get my fonts to work properly
21:58:59 <iqubic> ???
21:59:08 <iqubic> This is not the right channel is it?
21:59:33 <ongy> hm, can I get the address (Foreign.Ptr) of a struct defined in a C header over the ffi? or do I have to wrap that into a 1liner function and ccall into that for the pointer?
22:02:07 <Hijiri> I feel like haskell being easy to refactor lulls me into letting everything turn into functional spaghetti
22:02:35 <iqubic> Hijiri: I agree with that
22:03:07 <slack1256> I used tot think the same way, until I understood refactoring != re-architecturing (if that word exists at all)
22:04:10 <Hijiri> my definition of refactoring is any change that doesn't change the outward functionality
22:04:25 <Hijiri> but maybe there is some subset of that that is worth distinguishing
22:07:02 <Hijiri> The kinds of spaghetti I am thinking of are things like using tuples instead of named product types
22:07:25 <Hijiri> but maybe that is something common in other languages with tuples as well
22:07:41 <Hijiri> since I don't use many non-haskell languages that have tuples as a standard feature
22:08:42 <slack1256> I am currently on this situation. I got to change a core ADT and is generating breaking everywhere (understandable). I don't know how to make this change to get manageable changeset, so that after each step I stay in a compilable state
22:10:05 <slack1256> how I am progressing only the start and finish of a rather big change are compilable. I would like to get a series of step so I can have feedback that I am doing the right thing with the changes
22:19:05 <iqubic> jared-w: Do you have a reference image for your key mapping?
22:37:00 <jared-w> iqubic: https://en.wikipedia.org/wiki/AltGr_key#US-International
22:39:30 <iqubic> What about compose key mappings?
22:40:28 <jared-w> compose key mappings you define yourself or (depending on your linux distro of choice) some are provided for you
22:40:35 <iqubic> Oh, I see.
22:41:24 <iqubic> do you know if gentoo provides any compose key mappings
22:45:27 * hackagebot stache 1.1.2 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
22:45:27 * hackagebot NoTrace 0.3.0.2 – Remove all the functions come from Debug.Trace after debugging – https://hackage.haskell.org/package/NoTrace
22:46:27 <iqubic> Debug.Trace is dangerous
22:46:34 <iqubic> :t trace
22:46:36 <lambdabot> error: Variable not in scope: trace
22:49:49 <pacak> iqubic: Not really.
22:50:06 <iqubic> How is it not dangerous?
22:50:19 <iqubic> It can launch a missle from the middle of a do block
22:50:58 <pacak> It can dump something into stderr, but that's about it.
22:51:19 <iqubic> Oh. Is that all it does?
22:51:52 <pacak> trace :: String -> a -> a
22:52:05 <iqubic> Right, I see.
22:52:21 <pacak> Where do you load your missle to?
22:52:28 <iqubic> And it uses unsafePreformIO to do it?
22:52:46 <iqubic> pacak: clearly the missle is the a and the String is the co-ords
22:52:47 <pacak> You tell me.
22:53:09 <iqubic> pacak: It must use unsafePerformIO to work.
22:53:44 <jared-w> mfw you write the if statement so wrong that everything breaks for hours ;-;
22:54:22 <jared-w> iqubic: considering the philosophy of gentoo... I'd be surprised if it did.
22:54:47 <norc_> Im trying to figure out whether a function is also an applicative or ven a monad, but I can't figure out how to describe a function in generic terms.
22:54:54 <jared-w> iqubic: check this out. https://github.com/kragen/xcompose
22:55:04 <iqubic> jared-w: Yeah I suppose that's right.
22:55:17 <norc_> Is there some type constructor for functions?
22:55:30 <norc_> or is -> itself that type (and data) constructor?
22:55:43 <jared-w> a function or a functor?
22:55:54 <iqubic> jared-w: That's just a way of sharing .Xcompose files.
22:56:11 <norc_> jared-w: a "function"
22:56:27 <jared-w> Right, and .Xcompose keybinds are what give your compose key its shiny symbols :)
22:56:42 <iqubic> Do you have a .Xcompose file?
22:57:01 <jared-w> iqubic: I do, it just has lambda, and some smilies in it and the greek delta
22:57:18 <iqubic> Oh, that's not too fancy.
22:57:36 <iqubic> I want all the APL symbols as a bare minimum
22:58:07 <norc_> I mean (*2) <$> (+5) seems to work, so it appears to be a functor at the least - but I dont even know which type to look at to see that it really is an instance of Functor.
22:58:08 <jared-w> look at all the files inside of that repository; it has /tons/ of different xcompose bindings
22:58:21 <iqubic> I'll look into that.
22:58:31 <jared-w> norc_: ahh, I think I see what you're trying to do
22:58:38 <jared-w> :t (<$>)
22:58:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:58:49 <jared-w> <$> is nothing but an infix fmap
22:58:57 <iqubic> I assume that altgr just works though, no need to mess with settings?
22:59:00 <jared-w> >(*2) `fmap` (+5)
22:59:08 <jared-w> iqubic: yup, no need to mess with settings
22:59:22 <norc_> jared-w: When I type `:i Maybe` in ghci, I can see that its a Functor amongst a gazillion other things.
22:59:36 <norc_> jared-w: What is the `Maybe` for a function in this place?
22:59:40 <jared-w> That's slightly different
22:59:56 <jared-w> Maybe is a datatype. People have written instances for it for different typeclasses
23:00:23 <jared-w> similar to Java's "... implementing Y"
23:00:33 <jared-w> @src maybe
23:00:34 <lambdabot> maybe n _ Nothing  = n
23:00:34 <lambdabot> maybe _ f (Just x) = f x
23:00:35 <norc_> jared-w: I do not think we are on the same page.
23:00:39 <jared-w> @src Maybe
23:00:39 <lambdabot> data Maybe a = Nothing | Just a
23:00:42 <jared-w> there we go
23:01:01 <jared-w> Maybe is not a function, it is an algebraic datatype
23:01:07 * norc_ sighs
23:01:21 <norc_> Im just looking to learn about *functions*
23:01:24 <norc_> Not Maybe.
23:01:31 <jared-w> I'm trying to get you there :p
23:01:40 <pacak> You can look at Maybe as a type level function.
23:01:47 <pacak> :k Maybe
23:01:49 <lambdabot> * -> *
23:02:05 <jared-w> when you type :i Maybe you'll see that there is an instance of Maybe written for different typeclasses. One of which is Functor, another which is Monad, there's Monoid, etc...
23:02:19 <pacak> Something that takes something of kind * (a regular type) and creates a regular type
23:02:23 <norc_> You and I are really not on the same page.
23:02:58 <norc_> (*2) <$> (+5)
23:03:13 <norc_> Whats the thing I have to pass to :i to see that whatever (+5) represents typewise is a functor?
23:03:26 <iqubic> :t (+5)
23:03:28 <lambdabot> Num a => a -> a
23:03:36 <jared-w> See, the reason that you and I are not on the same page is that you are spouting gibberish in a barely coherent sentence
23:03:52 <iqubic> norc_: (+5) is not a functor.
23:04:03 <iqubic> It's a function as I just demostrated.
23:04:10 <pacak> iqubic: Is it not?
23:04:16 <norc_> Okay I just think I figured it out.
23:04:21 <norc_> (->) is what I was looking for.
23:04:21 <iqubic> :t <$>
23:04:22 <lambdabot> error: parse error on input ‘<$>’
23:04:29 <iqubic> :t (<$>)
23:04:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:04:37 <jared-w> norc_: that doesn't do what you think it does
23:05:08 <pacak> > (id <$> (+5)) 10
23:05:10 <lambdabot>  15
23:05:18 <norc_> jared-w: is (->) not the type constructor for functions and lambdas?
23:05:18 <pacak> iqubic: Explain this plox?
23:05:35 <iqubic> Oh, (+5) is a function anda functor
23:05:54 <iqubic> norc_: you can't create functions.
23:06:03 <iqubic> There is no constructor for a function.
23:06:22 <pacak> :t Just
23:06:24 <lambdabot> a -> Maybe a
23:06:29 <jared-w> norc_: no, it's not; I'm getting the impression you do not understand the difference between functions, data, typeclasses and their instances, etc.
23:06:35 <jared-w> Where have you been learning Haskell from?
23:06:36 <pacak> iqubic: Explain this plox?
23:06:52 <iqubic> pacak: Oh, am I wrong. 
23:06:56 <iqubic> I suppose I am
23:07:11 <norc_> jared-w: and Im getting the impression you are desperately hoping that Im just an idiot.
23:07:35 <pacak> iqubic: Your terminology is a bit off. And functors come in all sorts of shapes.
23:07:55 <pacak> iqubic: Start by explaining my functor example with +5
23:08:07 <iqubic> What do you want me to explain?
23:08:29 <pacak> What kind of functor is it, where is it useful, etc.
23:09:03 <iqubic> It's a functor of type (-> r)
23:09:24 <norc_> Well. Im just gonna blindly assume that (->) is the type constructor for functions, and that :i (->) does indeed demonstrate that functions are a functor, applicative and a monad
23:09:27 <iqubic> Or I think so.
23:09:37 <pacak> Is there a name for this functor? Also (-> r) is not a valid syntax.
23:09:47 <iqubic> It's a functor of type ((->) r)
23:10:29 <ahihi> norc_: correct
23:10:44 <ahihi> where "functions" = (->) r
23:10:51 <pacak> (_ -> r) and (r -> _) are two very  different things.
23:10:54 <pacak> :t (->)
23:10:55 <lambdabot> error: parse error on input ‘->’
23:10:57 <pacak> :k (->)
23:10:59 <lambdabot> * -> * -> *
23:11:34 <iqubic> pacak: am I right that (+5) is a functor of type ((->) r)?
23:11:49 <iqubic> :k ((->) r)
23:11:51 <lambdabot> error: Not in scope: type variable ‘r’
23:11:59 <iqubic> :k ((->) String))
23:12:00 <lambdabot> error: parse error on input ‘)’
23:12:03 <iqubic> :k ((->) String)
23:12:05 <lambdabot> * -> *
23:12:26 <norc_> ahihi: currently curious about the implementation of <$>, <*> and >>= for functions, can ghci give me this or do I have to dig it up from the depths of haskell?
23:12:30 <pacak> iqubic: I don't know, it's you doing research and explaining things, not me :) That is if you want to learn something on your own.
23:13:04 <iqubic> norc_: I don't think ghci can give that info to you.
23:13:30 <pacak> norc_: They are different for different datatypes, ghci won't give it to you. Hackage will.
23:14:10 <jared-w> norc_: https://stackoverflow.com/questions/5310203/how-to-use-instances-of-monad-and-confusion-about is this sort of thing helpful?
23:16:05 <jared-w> (sorry for the aggressive tone earlier; the way you phrased your questions threw me off since it looked indistinguishable from gibberish. I probably shouldn't be on the IRC this late anyway since I'm clearly a bit more tired than I thought I was)
23:20:15 <iqubic> I really hate not being able to see foreign symbols in my browser
23:20:17 <ahihi> norc_: as pacak suggested, the instance lists in the hackage docs for Functor/Applicative/Monad might be the best place to find them
23:21:21 <ahihi> though (->) apparently now takes RuntimeRep parameters which add some noise
23:22:25 <ahihi> i.e. the instances are for "(->) LiftedRep LiftedRep r"
23:23:40 <jared-w> iqubic: install the necessary fonts and you'll be fine :)
23:24:08 <iqubic> jared-w: I'm not sure which fonts are needed though.
23:24:33 <iqubic> Also, I'm not sure Chrome understands the concept of fallback fonts
23:24:54 <jared-w> https://wiki.archlinux.org/index.php/fonts#Font_packages  <-- go through these and find a few gentoo equivalents of the appropriate categories
23:26:18 <jared-w> You'll want something like noto-fonts-cjk for sure, an arabic font, Unifont for sure
23:26:52 <iqubic> jared-w: Yeah I was just suggested that in #gentoo
23:26:54 <jared-w> A cryllic font, a Greek font, and an Indic one. Then you'll probably want a math font and some emoji font
23:27:11 <jared-w> after that you'll have pretty much 100% font coverage except for obscure languages :)
23:27:11 <iqubic> Yeah, I think I have an emoji font already.
23:27:32 <jared-w> > join (+) 2
23:27:34 <lambdabot>  4
23:27:37 <jared-w> heh
23:27:56 <iqubic> jared-w: Stop messing with me.
23:28:05 <jared-w> > join (-) undefined
23:28:07 <iqubic> Also, I don't actually have an emoji font
23:28:07 <lambdabot>  *Exception: Prelude.undefined
23:28:17 <jared-w> > join (-) 1005823
23:28:19 <lambdabot>  0
23:28:23 <jared-w> > join (-) 2
23:28:26 <lambdabot>  0
23:28:33 <iqubic> > join (-) 1
23:28:35 <lambdabot>  0
23:28:48 <iqubic> > join (-) 123456789
23:28:50 <lambdabot>  0
23:29:01 <jared-w> > join div 234 -- any number returns the same
23:29:03 <lambdabot>  1
23:29:11 <pacak> > join div 0
23:29:13 <lambdabot>  *Exception: divide by zero
23:29:18 <pacak> iqubic: reader monad.
23:29:20 <pacak> jared-w: any?
23:29:25 <jared-w> I suppose I shouldn't have said /any/... *sigh*
23:29:35 <jared-w> Clearly odd things happen if you divide by zero :p
23:30:09 <jared-w> > join div ( -9245)
23:30:11 <lambdabot>  1
23:30:41 <iqubic> How do I specify that the input of a lambda must be an int when using @check?
23:31:06 <pacak> @check \x -> x == True
23:31:09 <lambdabot>  *** Failed! Falsifiable (after 1 test):
23:31:09 <lambdabot>  False
23:31:20 <pacak> Oh noes. failed...
23:31:22 <johnw> \(x :: Int) -> ...
23:31:31 <johnw> if you enable ScopedTypeVariables
23:31:42 <johnw> or, just use x :: Int elsewhere
23:31:45 <norc_> ahihi: Im really unsure how Hackage helps me understand the definition of say fmap for (->)
23:32:19 <iqubic> johnw: I'm trying to get lambdabot to run the check for me.
23:32:25 <ahihi> norc_: there's a source link next to each instance
23:33:15 <pacak> Except that (->) is deeply magical.
23:33:36 <pacak> Hmm... actually no, link works
23:33:38 <pacak> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-693
23:33:43 <mud> It's not that magical. It's just  fmap = (.)
23:33:52 <iqubic> Yeah. that's simple
23:34:10 <mud> Which is ... a bit magical, but only because it's surprisingish until you ponder it.
23:34:40 <norc_> pacak: That! How did you find that?
23:34:55 <pacak> mud: -> is magical in a sense it works for boxed and unboxed things so before liftedrep ghc was doing magical things.
23:34:56 <norc_> mud: That's what I observed too, but I wanted to see the definition for myself. :)
23:35:09 <pacak> norc_: http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor.html 
23:35:26 <pacak> start here, scroll down to functor, keep scrolling until Functor ((->) ...
23:35:30 <pacak> click Source
23:36:22 <iqubic> ((->) r) is just odd in general.
23:44:37 <pacak> iqubic: Are you still doing your research on it?
23:45:11 <pacak> It's not odd. It's useful in some cases.
23:46:11 * hackagebot network-api-support 0.3.2, relational-schemas 0.1.3.5, reprinter 0.1.0.0
23:46:11 * hackagebot  → https://hackage.haskell.org/packages/recent
23:46:12 <iqubic> No. I'm working on fixing my system fonts now.
