00:00:44 <saurabhnanda> erisco: what is 'a' what is 'S'
00:00:47 <erisco> hm, that may fall on its face though, because the error could be that S is just missing
00:01:14 <erisco> so if you have "a" S "b", say, and "a" and "b" are present but S is missing, or invalid, then you've skipped the wrong thing by skipping "a"
00:01:25 <erisco> so, back to the subsequences idea... but that is insanely expensive
00:01:44 <erisco> saurabhnanda, a terminal and nonterminal respectively
00:02:48 <erisco> you have to deal with both additive errors, i.e. this is here but shouldn't be, and subtractive errors, i.e. this should be here but isn't
00:04:10 <erisco> and the problem is you can explain any error with different mixes of those
00:08:21 <saurabhnanda> erisco: wow, this is going way over my head....
00:08:41 <saurabhnanda> so, pragmatically, if there's a **syntax** error in the JSON -- bailing early is acceptable.
00:09:04 <saurabhnanda> however, if there is no syntax error in JSON, I'd like to run all my validation functions on each field and report all errors together.
00:09:58 <erisco> saurabhnanda, sorry, I was going off on a tangent about parsing... not relevant to your issue
00:12:35 <saurabhnanda> would I be correct in assuming that it is because of https://www.stackage.org/haddock/lts-9.0/aeson-1.1.2.0/Data-Aeson-Internal.html#t:IResult that Aeson cannot collect all errors?
00:13:09 <saurabhnanda> this seems to be lowest building block of the parser. The Monad instance of IResult does not allow collection of more errors.  It short-circuits the entire monadic computation on the first error that occurs.
00:16:28 <foldr> saurabhnanda: Yes; IError p e <*> IError p ignores p' and e'
00:16:34 <foldr> saurabhnanda: Yes; IError p e <*> IError p' e' ignores p' and e'
00:17:07 <saurabhnanda> hmmm... is this one of the reasons why something like digestive functors was required?
00:17:55 <foldr> I believe it could be done by using `Compose (Parser ...) (AccValidation ...)'
00:18:05 <foldr> At least, this is how I do carrying of multiple errors when doing I/O.
00:18:26 <foldr> But that only gives you an applicative, not a monad
00:19:03 <saurabhnanda> foldr: is this the Compose you're referring to? https://www.stackage.org/haddock/lts-9.0/base-4.9.1.0/Data-Functor-Compose.html#t:Compose
00:19:22 <saurabhnanda> and https://www.stackage.org/haddock/lts-9.0/validation-0.5.4/Data-Validation.html#t:AccValidation ?
00:19:53 <foldr> yes
00:21:36 <saurabhnanda> foldr: what is the # symbol that AccValidation keeps referring to?
00:21:37 <foldr> It takes two applicatives and gives an applicative
00:22:08 <foldr> Oh it uses optics in the example, and (#) = flip ($). You don't have to use that, you can just use the constructors directly
00:23:08 <foldr> actually (#) = review
00:23:19 <saurabhnanda> for example https://github.com/NICTA/validation/blob/bf648b213b01148451aaf3c1c7c3eecde5c1bab3/examples/src/Email.hs#L25-L28
00:23:31 <foldr> It is unfortunate that the example uses this instead of the constructors
00:23:33 <saurabhnanda> what would be a simpler way to write that without a #
00:24:05 <foldr> AccSuccess (AtString x) else AccFailure [MustContainAt]
00:24:36 <saurabhnanda> are those lenses being used there?
00:24:42 <saurabhnanda> why?!
00:24:45 <saurabhnanda> anyways, let that be...
00:26:33 * hackagebot separated 0.2.2 – A data type with elements separated by values – https://hackage.haskell.org/package/separated
00:30:23 <saurabhnanda> is there any way to specify a function at the type level?
00:30:44 <saurabhnanda> a function to be part of the type spec?
00:31:53 <opqdonut> you can use type families for type-level computation
00:32:45 <saurabhnanda> opqdonut: let me rephrase... is there a way to define a newtype along with a validation function that validates the value of that type?
00:33:00 <opqdonut> no
00:33:07 <opqdonut> not like that
00:33:13 <opqdonut> types disappear during compilation
00:33:52 <opqdonut> however you can define a "newtype MyPrecious = MyPrecious String", and a 'smart constructor' "myPrecious :: String -> Maybe MyPrecious" that does the validation
00:34:05 <opqdonut> and then you only export the myPrecious function and not the MyPrecious constructor
00:34:27 <opqdonut> some examples here: https://wiki.haskell.org/Smart_constructors
00:36:16 <saurabhnanda> hmmm... that doesn't quite cut it for my crazy idea. I'd like to do something like this data User (state :: ValidationStatus) = User { _name :: TypeFamilySelector state Text (..validation functions...), _age :: TypeFamilySelector state Int (... validation functions ...)}
00:55:30 <frerich> saurabhnanda: What would that do?
00:56:26 <saurabhnanda> give you the ability to have a TWO types of the same shape, one to hold unvalidated data, and the other to hold validated date. With the type itself telling you the functions to validated each field.
01:00:04 <frerich> saurabhnanda: What would the validation functions return in case the value is invalid? I think opqdonut's suggestion might still be applicable if you have e.g. 'data Account' and a 'newtype Validated a = Validated a' you could define a function 'validateAccount :: Account -> Maybe (Validated Account)' and the rest of your code operates on 'Validated Account'. I.e. the data structure as a whole is valid or invalid.
01:00:40 <opqdonut> mhmm
01:01:37 <saurabhnanda> hmm... still thinking this through...
01:02:18 <frerich> saurabhnanda: I think I did something like this in a game once where I had a 'Move' type and I wanted the rest of the code to ensure that a Move is valid; the only way to construct a 'Valid Move' was to go through such a 'validateMove :: Move -> Maybe (Validated Move)'
01:03:03 <frerich> Hm yes, I had a 'data Action' and a 'data ValidAction = ValidAction Action'; same idea.
01:04:28 <frerich> A silly TH exercise implementing a generator for smart constructors: https://github.com/frerich/smartconstructor :-)
01:05:53 <erisco> frerich, nice!
01:18:54 <Spriithy> hey
01:19:54 <Athas> Ohh, the Par monad looks like a parallel Haskell success history.
01:20:01 <Athas> It has nontrivial dependencies on Hackage.
01:27:03 <Zemyla> frerich: You can use foralls to make sure moves are valid.
01:27:23 <Zemyla> validateMove :: Move -> Board s -> Maybe (ValidatedMove s)
01:27:50 <Zemyla> applyMove :: Board s -> ValidatedMove s -> (forall t. Board t -> r) -> r.
01:34:54 <laserpants> What is this function? fun f g x y = f x (g y). For a moment, I thought it was `on`, but it is not.
01:36:33 <EvanR> @pl \f g x y -> f x (g y)
01:36:33 <lambdabot> flip . ((.) .)
01:36:47 <EvanR> @unpl flip . ((.) .)
01:36:48 <lambdabot> (\ x x0 y x2 -> x y (x0 x2))
01:37:07 <EvanR> :t \f g x y -> f x (g y)
01:37:08 <lambdabot> (t3 -> t2 -> t1) -> (t -> t2) -> t3 -> t -> t1
01:37:34 <EvanR> @pl \f x g y -> f x (g y)
01:37:34 <lambdabot> ((.) .)
01:39:04 <laserpants> Ok. Maybe no pointfree style in this case then.
01:43:45 <lyxia> :t fmap fmap
01:43:47 <lambdabot> (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
01:57:30 <frerich> laserpants: If you change the order of the arguments 'f' and 'g' then I think 'fun' is '(.:)' aka '(.) . (.)'.
01:58:10 <frerich> laserpants: A function taking one argument composed with a function taking two arguments
01:59:10 * hackagebot data-diverse 0.9.0.1 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
01:59:10 * hackagebot vector-sized 0.6.1.0 – Size tagged vectors – https://hackage.haskell.org/package/vector-sized
02:01:00 <frerich> Zemyla: I don't understand what "forall" does there. I think my function to apply moves was 'applyMove :: ValidatedMove -> Board -> Board' (I usually make the thing being changed, i.e. the 'Board', come last such that I can use 'foldr applyMove board moves')
02:08:39 * hackagebot miso 0.6.0.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
02:14:14 <jle`> :t \f g x y -> f x (g y)
02:14:16 <lambdabot> (t3 -> t2 -> t1) -> (t -> t2) -> t3 -> t -> t1
02:14:18 <lordik> hello
02:14:22 <lordik> i am lordik
02:14:36 <lordik> havent been using mirc for years now since i was 16 lol
02:14:50 <jle`> welcome back! :)
02:15:11 <lordik> thanks :)
02:15:37 <lordik> i was wondering
02:16:33 <lordik> i am looking for some softwares or computer expert that can help me even by payment to get some specific softwares in the automotive industry?
02:18:49 <cocreature> lordik: this channel is about the haskell programming language not about finding people that pirate software for you
02:19:48 <lordik> its not pirated just really old and hard to get
02:20:06 <lordik> so maybe you can redict me to a channel that will help?
02:25:46 <tabaqui> back to yesterday discussion
02:26:20 <tabaqui> I've remembered that (->) in signatures has mirroring image in terms layer
02:26:25 <tabaqui> it's lambda functions
02:27:22 <tabaqui> " | predicate = expression" use '=' sign, because "predicate -> expression" doesn't correspond function type
02:29:35 <saurabhnanda> is it possible to have a monad without having a functor/applicative? Or, in other words, what is something that has the equivalent of a bind operator, without necessarily being a functor/applicative?
02:31:14 <Geekingfrog> saurabhnanda: you can't have that. Because if you have bind (and return), you can implement fmap, <*> and pure
02:31:48 <tabaqui> free monads maybe
02:32:13 <tdammers> saurabhnanda: technically, on older GHCs you could; but conceptually, it doesn't make sense because they are superclasses of one another
02:32:20 <tabaqui> but they are functors too
02:32:26 <tabaqui> not sure about applicative
02:32:47 <tdammers> tabaqui: you can implement <*> in terms of bind and return too
02:32:55 <saurabhnanda> so, remove the term "monad" from my question. What type/type-class has the equivalent of a >>= without being a functor/applicative?
02:33:07 <tdammers> so basically, bind, but not return
02:33:23 <jle`> saurabhnanda: i mean, you can define whatever typeclass you like
02:33:33 <jle`> haskell is nice in that you can define new typeclasses within the language
02:33:47 <jle`> using 'class Foo a where ...' syntax
02:33:59 <saurabhnanda> jle`: I'm struggling with a very higher-order problem here, and looking for some existing examples.
02:34:36 <jle`> if you're struggling for a higher-order problem, it might be hard to help with so little details
02:34:41 <tabaqui> saurabhnanda: what about Monoid + Foldable?
02:35:10 <tabaqui> I mean
02:35:29 <tabaqui> I always thought about monads like structures that we map using transformer
02:35:32 <tdammers> monoid is *, not * -> *
02:35:39 <tabaqui> and then glue with some operation
02:35:44 <saurabhnanda> jle`: yeah, I know... I'm deep into data kinds, type families, and recursive stuff right now.
02:35:51 <jle`> are you looking for typeclasses that are literally *just* bind, that are defined in some library somewhere?
02:35:57 <saurabhnanda> jle`: yep
02:36:00 <tdammers> so you can't write bind in terms of monoid
02:36:11 <tabaqui> tdammers: I know, I know, we're just theorize
02:36:36 <tabaqui> let's image, we are all algebraists here
02:36:40 <tabaqui> *imagine
02:37:40 * hackagebot brittany 0.8.0.2 – Haskell source code formatter – https://hackage.haskell.org/package/brittany
02:39:17 <jle`> saurabhnanda: there's monad-without-return, but it's a Functor in this package
02:39:19 <jle`> http://hackage.haskell.org/package/semigroupoids-5.2.1/docs/Data-Functor-Bind.html
02:40:04 <angerman> is there something to automatically generate `isX` that matches on the constructors of a data type? data X = A ... | B ..., isA :: X -> Bool, isB :: Y -> Bool?
02:40:08 <saurabhnanda> this one? http://hackage.haskell.org/package/semigroupoids-5.2.1/docs/Data-Functor-Bind.html#t:Bind
02:40:16 <jle`> yes that's the one i was referring to
02:40:38 <jle`> angerman: there are some packages that give you template haskell that can generate it for you
02:40:47 <jle`> angerman: lens is one of the more well-established ones that does
02:41:05 <angerman> so, nothing built in I'm missing.
02:41:06 <jle`> if data X = A | B | C, then isX = has _X
02:41:32 <jle`> yeah, haskell doesn't actually have any mechanisms to dynamically generate *names*/bindings, without template haskell
02:42:01 <jle`> so there's no way to get functions whose names correspond to those things w/o TH
02:42:25 <jle`> but if you are willing to give up the naming, there's other 'generic' (heh) or parameterized ways to refer to constructors
02:42:45 <angerman> I actually don't care for the body of the constructor.
02:43:12 <jle`> yeah, you can use Generics to get the constructor #
02:43:17 <jle`> the first, second, or third, etc.
02:43:35 <angerman> I keep writing `isA :: X -> Bool`, with `isA (A{}) = True; isA _ = False`.
02:43:44 <jle`> the only thing that's actually technically out of reach is generating a function called 'isX' with the *name* isX, generated from the constructor
02:44:04 <jle`> but you can automatically write functions to test for a certain constructor
02:44:05 <angerman> I guess I'll keep plumbing by hand for now :)
02:44:07 <jle`> it just won't be named isX
02:44:32 <angerman> jle`: moduleInstructions mod `shouldSatisfy` any isMyInstruction.
02:44:37 <jle`> if you're willing to do a little bit of boilerplate, you can do `isX = isCOnstructor 1`
02:45:05 <jle`> so you could do moduleINstructions mod `shouldSatisfy` any (isConstructor 2), maybe
02:45:08 <jle`> with built-in tools
02:45:54 <angerman> yea, but that's going to be messed up, once someone comes along and extend the datatype somewhere in the middle.
02:46:06 <angerman> jle`: thanks for the hints though.
02:46:18 <jle`> yeah.  it's a fundamental haskell issue; without template haskell, you can't generate function names programmatically
02:46:39 <jle`> angerman: but if you're looking for a practical solution, lens is definitely a great way to go
02:46:54 <jle`> how many things you do in haskell are "built-in", anyway?
02:47:17 <jle`> then you can do moduleInstructions mod `shouldSatisfy` any (has _MyInstruction)
02:47:18 <angerman> jle`: I'm trying to keep lens out of this. Even though with some trickery this could be achieved compartmentalized.
02:47:36 <angerman> jle`: I've got too many dependencies already anyway.
02:47:38 <jle`> are you trying to avoid the concept of lenses, or the actual library?
02:47:46 <saurabhnanda> does the kind of a functor HAVE to be of * -> *
02:47:54 <angerman> jle`: building something to be put into ghc :)
02:48:12 <jle`> saurabhnanda: of a Functor, yes, because that's the definition of the Functor typeclass in the Data.Functor module
02:48:20 <angerman> jle`: I guess I could start generating lenses (via TH) in a separate package, that only the test suite depends on.
02:48:32 <jle`> saurabhnanda: but it's not necessarily true for the general concept of functors
02:49:12 <jle`> angerman: perhaps :)  well if you're not using anything else of lens and you're re-implementing the TH froms cratch, you might as we  just write TH to generate isX
02:49:49 <angerman> jle`: using lens would have made writing the `moduleInstructions` function less painful :)
02:50:01 <cocreature> > toConstr (Just 1) == toConstr (Just 3)
02:50:03 <lambdabot>  True
02:50:08 <cocreature> > toConstr (Just 1) == toConstr (Nothing :: Maybe Int)
02:50:11 <lambdabot>  False
02:50:13 <cocreature> ^ angerman does that do the job?
02:50:23 <angerman> nah.
02:50:28 <saurabhnanda> I have a bunch of validationsResults of type  ==> data ValidationResult (a :: State -> *) = ValidationError [Text] (a 'Errors)  | ValidationSuccess (a 'Validated) ==> I need to define some form of combinator which allows me to create a record of type (a ‘Validated) only if all of the validationResults are ValidationSuccess, else it should create a record of type (a ‘Errors) ==> how do I do that?
02:50:51 <angerman> cocreature: I want to keep readability as well, and I don't want to fully specify the constructor.
02:51:10 <jle`> saurabhnanda: pattern matching?
02:51:21 <jle`> with a fold maybe
02:51:28 <angerman> cocreature: did you see that LLVM has BitCode (version: 2) for some time now?
02:51:39 <angerman> Not sure when that came about, probably with LLVM4 I guess.
02:51:40 <saurabhnanda> jle`: won't that blow up in complexity with a lot of fields?
02:51:52 <angerman> cocreature: it can still read bitcode v1 though :)
02:51:53 <jle`> what fields are you talking about
02:52:06 <cocreature> angerman: do you actually need the functions or do you just want to avoid having to specify all parameters in a pattern match?
02:52:36 <cocreature> angerman: for the latter you can use record syntax in pattern matches even if the constructor is not defined using record syntax
02:52:59 <cocreature> > case Just 1 of Just {} -> True; Nothing -> False
02:53:01 <angerman> cocreature: yea I do this isA (A{}) = True; isA _ = False dance.
02:53:01 <lambdabot>  True
02:53:03 <jle`> oh hey, if your constructors are strict, you can even use that to construct blank values
02:53:13 <jle`> > toConstr (Just 1) == toConstr (Just{})
02:53:15 <lambdabot>  error:
02:53:15 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘toConstr’
02:53:15 <lambdabot>        prevents the constraint ‘(Data a0)’ from being solved.
02:53:22 <jle`> *if your fields are not strict
02:53:24 <jle`> aw man
02:53:31 <jle`> > toConstr (Just 1) == toConstr (Just{} :: Maybe Int)
02:53:33 <lambdabot>  True
02:53:53 <angerman> so isA = (== toConstr (A{}))
02:53:54 <jle`> > toConstr (Just 1) == toConstr (Nothing{} :: Maybe Int)
02:53:56 <lambdabot>  False
02:54:17 <jle`> gross
02:54:22 <jle`> but kinda neat
02:54:28 <angerman> wait isA = (== toConstr (A{})) . toConstr
02:54:29 <saurabhnanda> jle`: validationresult holds the result of validating a single field in a record. 
02:54:56 <jle`> :t (== toConstr (True{})) . toConstr
02:54:57 <lambdabot> Data a => a -> Bool
02:55:07 <jle`> what hath man wrought
02:55:29 <angerman> > :t isJust = (== toConstr (Just{})) . toConstr
02:55:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:55:40 <saurabhnanda> jle`: what're you doing?
02:55:42 <angerman> > isJust = (== toConstr (Just{})) . toConstr; isJust (Just True)
02:55:42 <jle`> :t (== toConstr (Any{})) . toConstr
02:55:44 <lambdabot>  <hint>:1:8: error:
02:55:44 <lambdabot>      parse error on input ‘=’
02:55:44 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:55:44 <lambdabot> Data a => a -> Bool
02:56:00 <jle`> saurabhnanda: horrible things
02:56:02 <lyxia> </3 Data
02:56:10 <saurabhnanda> :)
02:56:18 <angerman> > let isJust = (== toConstr (Just{})) . toConstr in isJust (Just True)
02:56:21 <lambdabot>  error:
02:56:21 <lambdabot>      • Could not deduce (Data a0) arising from a use of ‘toConstr’
02:56:21 <lambdabot>        from the context: Data a
02:56:45 <lyxia> saurabhnanda: do you have an example of a record type you have
02:56:47 <angerman> > let isJust = ((== toConstr (Just{})) . toConstr) :: Maybe -> Bool in isJust (Just True)
02:56:49 <lambdabot>  error:
02:56:49 <lambdabot>      • Expecting one more argument to ‘Maybe’
02:56:49 <lambdabot>        Expected a type, but ‘Maybe’ has kind ‘* -> *’
02:56:51 <jle`> you need to give Just{} a type
02:57:00 <angerman> ok. I just give up and pick up my daughter from day care.
02:57:01 <jle`> since it's unrelated to the type of the input
02:57:07 <jle`> you should also do that first
02:57:14 <jle`> :)
02:57:24 <angerman> > let isJust = ((== toConstr (Just{})) . toConstr) :: Maybe Bool -> Bool in isJust (Just True)
02:57:27 <lambdabot>  error:
02:57:27 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘toConstr’
02:57:27 <lambdabot>        prevents the constraint ‘(Data a0)’ from being solved.
02:57:35 * angerman is gone
02:58:23 <saurabhnanda> lyxia: https://gist.github.com/saurabhnanda/2308072fa6689ba7db7de6af5b06020f
02:58:36 <mivael> hello all
02:58:42 <mivael> Does (last . takeWhile myCondition . iterate myFunc $ myValue) look like a sane (memory efficient) way to go if I'm not interested in the intermediary values of a multistage calculation?
02:58:48 <jle`> angerman: it's (Just{} :: Maybe ())
02:58:52 <mivael> Only the last value (of a generated list) matters.  This fact considered, should I really use Data.List functions in this case?  Or maybe there are efficient alternatives?
02:59:02 <jle`> angerman: when you go toConstr, you lose the original type completely
02:59:19 <jle`> mivael: nah that's fine
02:59:31 <jle`> make sure to benchmark though
02:59:34 <lyxia> saurabhnanda: What can you instantiate "a" with
02:59:37 <jle`> or monitor memory
02:59:55 <jle`> but i think you should be ok.
03:00:04 <saurabhnanda> lyxia: a :: State -> *
03:00:09 <jle`> mivael: takeWhile f . iterate g should fuse, anyway
03:00:30 <jle`> mivael: but, it should be pretty easy to detect if you're leaking memory or not.
03:01:17 <lyxia> saurabhnanda: I mean, in   ValidationResult a   what concrete type can go in place of   a   ?
03:01:54 <saurabhnanda> from my example, either User or Address
03:02:05 <mivael> jle`, thank you
03:02:29 <jle`> mivael: no problem!  for what it's worth, this sort of stuff is actually what Data.List was made for
03:02:41 <jle`> it's kind of the only real purpose of lists in haskell
03:02:51 <jle`> so i'd hope it does work
03:04:58 <lyxia> saurabhnanda: Aren't those whole records? How does ValidationResult hold a single field?
03:05:35 <saurabhnanda> lyxia: sorry, just added that. 
03:05:40 <saurabhnanda> https://gist.github.com/saurabhnanda/2308072fa6689ba7db7de6af5b06020f#file-validation-hacking-hs-L21
03:06:02 <mivael> jle`, I believed I'm fine with that, just wanted to be a bit more sure  :)
03:06:41 <saurabhnanda> x :: Int -> ValidationResult (ValidationWrapper Int) 
03:08:21 <lyxia> Why should the record types hold errors like that?
03:10:17 <saurabhnanda> to get field specific errors in the same shape as the original record
03:11:17 * hackagebot DeepDarkFantasy 0.2017.8.4 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
03:12:39 <lyxia> saurabhnanda: would it be possible to make ValidationWrapper a GADT
03:13:02 <saurabhnanda> anything is possible right now :) 
03:13:09 <saurabhnanda> I'm in the initial phases of design
03:34:19 <saurabhnanda> is there any library which takes values of the same "shape" and combines them via a function of the same shape? eg: User{email=emailValidator, name=nameValidator} -> User{email=rawEmail, name=rawEmail} -> User{email=validatedEmail, name=validatedName}
04:07:31 <lyxia> saurabhnanda: Here's an idea. https://gist.github.com/Lysxia/fa92a66cdeea2a0310a817fc989ff0e2
04:08:13 <lyxia> (see main at the bottom for the expected usage/result)
04:13:11 <saurabhnanda> lyxia: thanks!
04:13:21 <saurabhnanda> lyxia: do you think this is better achieved via Generics?
04:14:51 <saurabhnanda> lyxia: btw, how did you manage to wrap your head around this?!
04:16:09 * hackagebot filelock 0.1.1.1 – Portable interface to file locking (flock / LockFileEx) – https://hackage.haskell.org/package/filelock
04:56:37 * hackagebot SSTG 0.1.1.3 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
05:48:44 <lyxia> saurabhnanda: It can be done with Generics. I'm not sure of the trade-offs, but either approach doesn't seem absolutely better than the other.
05:53:28 * hackagebot speculate 0.2.6 – discovery of properties about Haskell functions – https://hackage.haskell.org/package/speculate
05:53:39 <lyxia> In both cases you have to do logic programming with type classes and type equality constraints.
06:18:43 <saurabhnanda> lyxia: you still around?
06:19:40 <lyxia> saurabhnanda: hello
06:21:26 <saurabhnanda> lyxia: do you know if the following is possible using Generics: run functions on all fields of a record, if any of the function returns a Left, then the generic function should evaluate to a Left which collects all the internal Left values, else it should evaluate to a Right. BUT, one NEEDS to run the function on all fields, no short-circuiting is allowed (because of an early Left value)
06:21:59 <phadej> Validation...
06:22:18 <phadej> that's the type one should google for ^
06:23:17 <saurabhnanda> phadej: is that for me?
06:23:41 <saurabhnanda> phadej: referring to https://hackage.haskell.org/package/Validation ?
06:24:25 <lyxia> with a small v
06:25:43 <saurabhnanda> have looked at that... but the problem is that the errors are returned as a flat list. I'm trying to come up with something where the errors are returned in the same shape as the incoming record.
06:26:22 <saurabhnanda> and the record fields are polymorphic to allow this, i.e. data User n a = User {name::n, age::a}
06:26:33 <saurabhnanda> type UserInput = Text Int
06:26:34 <MichaelBurge_> What's a good way to derive a Data instance for Cofree? https://hastebin.com/raxefuyomu.hs
06:26:45 <saurabhnanda> type UserErrors = User [Text] [Text]
06:26:47 <phadej> saurabhnanda: write a non-generic function first
06:26:56 <saurabhnanda> phadej: have already done that
06:27:15 <phadej> saurabhnanda: did you wrote it for few types?
06:27:22 <phadej> saurabhnanda: is there a pattern?
06:27:39 <saurabhnanda> phadej: I can see the pattern emerging, but unable to proceed beyond a point...
06:27:47 <saurabhnanda> phadej: wait, let me write that for a record with 3 fields
06:27:54 <saurabhnanda> I have done it with 2 fields
06:31:03 <phadej> saurabhnanda: I think it's possible, especially if you rather do data User f = User { name :: f Text, age :: f Int }
06:31:11 <Sose> on windows, how can I tell where stack should install its stuff? I have a small SSD drive for my C-drive and stack is apparently taking multiple gigabytes of it
06:31:15 <phadej> and default is User = User Identity
06:31:16 <Sose> I'd prefer it on my HD
06:31:32 <saurabhnanda> phadej: and have to use runIdentity everywhere?
06:31:43 <lyxia> MichaelBurge_: deriving instance (Data a, Data (f (Cofree f a)), Typeable f) => Data (Cofree f a)
06:31:44 <phadej> saurabhnanda: that's the price.
06:31:58 <saurabhnanda> phadej: don't want to give up so easily :)
06:32:45 <phadej> saurabhnanda: yet, validate :: User (Const Text) -> Either (User (Const [Error])) (User Identity) is way easier to write
06:32:52 <lyxia> saurabhnanda is already halfway there by defining the type of fields with a type family.
06:32:52 <phadej> and generalise
06:33:04 <cocreature> MichaelBurge_: wow that error message is attrocious
06:33:22 <cocreature> MichaelBurge_: http://lpaste.net/357413 should do the job
06:33:42 <saurabhnanda> phadej: lyxia: 2-field case -- https://gist.github.com/saurabhnanda/124e656b3f563c1d2868943cb061a003
06:34:08 <phadej> lyxia: true! one could use something like "trees that grow" - approach
06:34:11 <cocreature> MichaelBurge_: hm maybe not I think that will result in an infinite loop
06:34:26 <cocreature> meh why is there no Data1
06:34:32 <MichaelBurge_> lyxia, cocreature: Yeah, it looks like that did it. Would've taken a lot longer to figure that one out.
06:35:07 <cocreature> does it not run into an infinite loop?
06:35:26 <cocreature> or does it reach some kind of fixpoint?
06:36:12 <lyxia> It depends on f.
06:36:32 <cocreature> sure but in most case the data instance of f is probably Data a => Data (f a)
06:36:40 <cocreature> and I would have expected that this results in a loop
06:37:30 <saurabhnanda> phadej: lyxia: 3field validation - https://gist.github.com/saurabhnanda/124e656b3f563c1d2868943cb061a003#file-3field-validation-hs
06:37:45 <lyxia> GHC can tie the knot here
06:38:02 <cocreature> lyxia: ah nice, thanks!
06:39:02 * hackagebot yesod-bin 1.5.2.5 – The yesod helper executable. – https://hackage.haskell.org/package/yesod-bin
06:42:50 <MichaelBurge_> cocreature: I wanted to work through a backlog of error messages before confirming that it worked. It looks like neither ghc nor the program have an infinite loop
06:44:14 <sproingie> Sose: set the STACK_ROOT environment variable to where you want to move stack's cache then run stack-setup again
06:47:27 <Sose> sproingie: thanks, I'll try that
06:51:20 <sproingie> Sose: also "stack path" will show you where stack is currently putting everything so you can verify the fix
06:51:28 <sproingie> (also so you can see what to clean up when you move it)
06:55:38 <phadej> saurabhnanda: http://lpaste.net/357415
06:55:57 <phadej> I think you can get generic version out of that, but I have no idea how.
06:57:49 <RedNifre> Is Unit () the empty tuple or just equivalent to the empty tuple?
06:57:52 <saurabhnanda> phadej: had thought about that... in the validation case you've made each field an Either Error originaType, right?
06:58:29 <saurabhnanda> phadej: where is `first` coming from?
06:58:48 <phadej> saurabhnanda: from the single import.
06:59:03 <saurabhnanda> ah okay...
06:59:21 <saurabhnanda> I got confused with fst... let it be
07:00:28 <Sose> sproingie: that seemed to work but I still have stuff like `compiler-exe: C:\Users\x\AppData\...\stack\` in `stack path`
07:01:11 <lyxia> RedNifre: It's okay to call it the empty tuple.
07:04:07 <saurabhnanda> phadej: have I grokked this correctly? `first (const errorUser) $ User <$> a' <*> b' <*> c'` -- run the validations on each field to get an (Either Errors User). If it evaluates to a Left value, then construct a User record where each field has errors or []. If it evaluates to a Right value, then just use that?
07:04:35 <Sose> sproingie: I wonder what will happen if I rm that directory? %appdata%\Programs\stack\x86-64-windows\.. it has bunch of stuff (almost 2GB in total)
07:05:35 * hackagebot amqp 0.16.0, inflections 0.4.0.0, yesod-core 1.4.36
07:05:35 * hackagebot  → https://hackage.haskell.org/packages/recent
07:05:41 <phadej> saurabhnanda: yes
07:05:50 <madknight> is there a function like fmap but so: Functor f => (a -> a) -> f a -> f a and would this actually make sense?
07:07:01 <saurabhnanda> in its current form it will reuse all the validation results, I presume. But in a generic form, will it re-run all the validations in the case where the first field errors out?
07:07:10 <phadej> madknight: fmap can be specialised to that type
07:07:19 <phadej> what yo mean by "actually make sense" ?
07:08:27 <madknight> phadej, i would like too see a use case (example)
07:09:09 <c_wraith> :t fmap `asAppliedTo` id
07:09:11 <lambdabot> Functor f => (b -> b) -> f b -> f b
07:12:31 <sproingie> Sose: you should be able to nuke the stack dir with no ill effects, stack will rebuild it.  only thing you'll lose is global settings if you changed any.
07:13:51 <sproingie> and if you want to keep those, just keep $STACK_ROOT/config.yaml and $STACK_ROOT/global-project/stack.yaml
07:14:31 <Sose> sproingie: thank you so much :)
07:15:33 <sproingie> stack is a breath of fresh air after working with the repulsive mess that is npm
07:15:33 <sproingie> thankfully i found yarn which is what npm should be
07:17:50 <Axman6> madknight: how is the function you describe different from fmap's behaviour?
07:18:55 <madknight> Axman6, i want a type preserving fmap
07:19:01 <Axman6> madknight: what you're describing appears to just be fmap, where the a's and b's happen to be the same type. Remember that there's nothing saying that a and b need to be different, only that they can be
07:19:10 <Axman6> :t fmap id
07:19:11 <lambdabot> Functor f => f b -> f b
07:19:24 <Axman6> :t fmap `asAppliedTo` id
07:19:25 <lambdabot> Functor f => (b -> b) -> f b -> f b
07:20:14 <Axman6> madknight: Functor f => (a -> a) -> f a -> f a is _the same type_ as Functor f => (a -> b) -> f a -> f b, but more restricted
07:20:32 <Sose> sproingie: heh, I'm still using npm. heard about yarn but never looked into it :P thanks anyways
07:21:10 <sproingie> upsides are yarn caches globally, and its solver actually works
07:21:19 <Axman6> madknight: the type of be is determined by the type of the function passed as the first argument, so if that function has type a -> a, then you get a function of type f a -> f a
07:22:12 <tdammers> a dependency solver that actually works? heresy!
07:22:22 <madknight> Axman6, https://www.haskell.org/hoogle/?hoogle=asAppliedTo No results found
07:22:36 <Axman6> it's just something defined in lambdabot
07:22:37 <sproingie> less broken anyway.  dependency solving is always kinda broken.
07:22:44 <Axman6> @src asAppliedTo
07:22:44 <lambdabot> f `asAppliedTo` a = f where _ = f a
07:22:44 <lambdabot> infixl 0 `asAppliedTo`
07:23:08 <Axman6> :t asAppliedTo
07:23:10 <lambdabot> (a -> b) -> a -> a -> b
07:24:38 <mnoonan> madknight, is MonoFunctor in monotraversable what you're looking for?
07:25:33 <Axman6> mnoonan: to be really clear, the answer to " is there a function like fmap but so: Functor f => (a -> a) -> f a -> f a?" is "Yes, it is fmap"
07:25:39 <Axman6> uh, madknight
07:25:47 <sproingie> :t asAppliedTo
07:25:48 <lambdabot> (a -> b) -> a -> a -> b
07:26:38 <aphorisme> Hello! Is there a way to introduce type variables within the type definition of a GADT? Something like `data G a :: * where Example :: String -> G a`?
07:26:52 <mnoonan> Axman6: yes, if the "Functor" constraint is really what they meant. but if the implicit question is "is there a function like fmap but so: Something f => (a -> a) -> f a -> f a", then there are more possibilities
07:27:21 <mnoonan> I guess this is prime XY problem territory
07:27:30 <Xion___> aphorisme: I think this requires ScopedTypeVariables
07:27:36 <lyxia> aphorisme: Doesn't what you wrote work already
07:27:41 <sproingie> i thought type variables were always scoped in a GADT
07:27:52 <Axman6> the real problem here is a lack of communication back to us from madknight so we can actually tell what the problm is mnoonan =)
07:27:55 <Xion___> Or yeah, it should probably work already
07:27:55 <madknight> Axman6, fmap allows me to make this fmap (\x -> True) [1,2,3]  so its not type preserving its converting Int to Bool in this case, i want a fmap that does not allow this
07:28:07 <aphorisme> uhm, maybe my flycheck stopped working ... let me try.
07:28:29 <ab9rf> :t fmap
07:28:30 <madknight> Axman6, where i can only put in list of ints and get list of ints or put in lists of string and get lists of string
07:28:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:28:32 <Axman6> madknight: endoMap :: (a -> a) -> f a -> f a; endoMap = fmap
07:28:43 <ab9rf> ^
07:28:58 <Axman6> all you need to do is restrict the type of fmap
07:28:59 <lyxia> @let data G a :: * where Example :: String -> G a
07:29:00 <lambdabot>  Defined.
07:29:14 <lyxia> aphorisme: ^
07:29:37 <aphorisme> uhm, thanks you all!  ; )
07:31:22 <sproingie> just out of curiosity, is there a way to define endoMap such that a and b aren't necessarily the same type but satisfy the same constraints?
07:31:49 <sproingie> i guess if i know the constraints i can just put the same constraint on both
07:32:52 <Axman6> madknight: does that make sense? all you need to do is give a new name with a more restricted type to fmap
07:33:00 <madknight> Axman6, yup thx endoMap was what i was looking for
07:33:52 <madknight> Axman6, i think it makes sense to use a restricted version of fmap to avoid errors if you actually only want a -> a and not a -> b
07:34:42 <Axman6> well, there are other ways too. I don't see much point, it's not like you can later accidentally use the wrong type if your code expects a to be a specific type
07:34:48 <sproingie> usually you'll hit that restriction based on the type of whatever's using fmap and not actually need it for fmap itself
07:35:22 <sproingie> but i could see a reason for wanting to restrict fmap itself sometimes
07:35:46 <madknight> sproingie, but thats not generalized then if i restrict it to a certain type like Int
07:35:49 <Phillemann> Does anybody use nix + something that depends on opengl (such as gloss) and has an nvidia GPU? I get errors regarding libGL not being found.
07:37:05 <sproingie> madknight: doesn't mean it has to be restricted to a concrete type, just that the signature of some other function that uses fmap will most likely constrain it anyway
07:37:33 <sproingie> but anyway, making your intent explicit is usually a good thing
07:39:35 <madknight> sproingie, so its recommended to stick away from generalizing functions and use the most restricted (low level type signatures) when programming in haskell?
07:40:06 <sproingie> not really.  you don't want to go overboard in either direction.
07:41:24 <Axman6> only restrict things where they _must_ be restricted for some reason. 
07:42:02 <roberth> Phillemann, are you on NixOS?
07:42:27 <Phillemann> roberth: Yes.
07:42:36 <tabaqui> looks like haddock is broken
07:42:38 <tabaqui> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList
07:42:45 <tabaqui> or it is a new format?
07:42:47 <Phillemann> roberth: I added freeglut and mesa to my "packages:" in stack.yaml.
07:43:31 <Axman6> tabaqui: i'd report that in #haskell-infrastructure and/or #hackage
07:43:35 <Axman6> looks broken to me
07:43:48 <roberth> Phillemann: you should probably use the drivers in /run/opengl-driver/lib/ instead
07:43:56 <Axman6> hmm, maybe not? hard to tell
07:43:58 <sproingie> could be sketchy haddock in base
07:44:02 <Phillemann> roberth: You mean via LD_PRELOAD or something?
07:44:08 <tabaqui> Axman6: there are new syntax in it's source code
07:44:17 <tabaqui> *is
07:44:25 <roberth> Phillemann: yes, maybe LD_LIBRARY_PATH
07:44:54 <Axman6> doesn't look like new syntax to me, afaict
07:44:55 <Phillemann> roberth: I'll try.
07:45:40 <madknight> sproingie, hmm okay cause sometimes i see libs that seems to be overly type restricted whereas if the functions would be described in a more general way they could be used for different useful stuff
07:45:53 <tabaqui> are you the op of #haddock?
07:47:04 <tabaqui> *#hackage of course
07:47:32 <Axman6> I am, but only because I created the channel many years ago, not because I have anything to do with hackage
07:47:40 <sproingie> madknight: authors don't necessarily know what generalizations might apply.  long as they're using type classes properly, you can usually write an instance and submit it as a patch
07:48:29 <sproingie> and if they're not using classes, then the library probably needs more work
07:53:34 <Phillemann> roberth: Doesn't work, unfortunately.
07:54:07 <Profpatsch> quchen: ohai
07:55:57 <shapr> Anyone doing the ICFP contest this year?
07:56:32 <madknight> sproingie, class Endofunctor f where endomap :: (a -> a) -> f a -> f a :)
07:56:39 <Athas> shapr: sadly, I have to write my dissertation... my colleagues were mighty disappointed.
07:56:44 <Athas> It's the only programming contest worth doing.
07:56:46 <roberth> Phillemann: what does ldd say about your binary?
07:57:32 <sproingie> madknight: eh, all Functors are endofunctors in Hask
07:58:01 <sproingie> that one is endo in a different and less useful way
07:58:31 <madknight> sproingie, how would you name the functor i just described?
08:03:30 <shapr> Athas: that's too bad, the contest looks like a simple adversarial graph problem
08:06:36 <Phillemann> roberth: Hm, it's linked to /run/opengl-driver/lib/libGL.so.1, looks fine actually.
08:10:44 <phadej> shapr: indeed, rules doesn't look too complicated
08:10:54 <phadej> I have no time to participate either :/
08:12:06 <c_wraith> the statement that they will be changing the rules up to 4 times is interesting
08:13:40 <phadej> c_wraith: it's not so uncommon, weren't previous ICFP contents also revealing additional rules / info during the contest
08:14:34 <sproingie> madknight: can't think of a name for it offhand, it would seem to be a Functor in a much more restricted Category, but we don't really define Functor that way
08:14:36 <c_wraith> I suppose it is getting common now... It makes it especially clear that the current simplicity of the rules won't last
08:14:49 <phadej> Unfortunately the ICFP contents always overlaps with my birthday party or/and assembly (https://en.wikipedia.org/wiki/Assembly_(demoparty)) so I hadn't ever managed to participate :/
08:16:22 <phadej> c_wraith: it's the trick to get people on hook "Oh, we have built the program already, now we only have to adopt to the new rules"
08:16:40 <sproingie> is the challenge specifically to adapt to changing rules?
08:16:41 <Rembane> phadej: Is Assembly still running? Nice! :D
08:16:42 <shapr> I like that realism
08:16:44 <sproingie> (sounds a lot like real life)
08:16:48 <shapr> yeah!
08:17:12 <sproingie> i'd expect one of the changes to be a whopper then
08:18:12 <phadej> Rembane: e-sports is a thing there now
08:18:25 <phadej> Rembane: but they do have demos too
08:23:18 <[exa]> shapr: which contest btw?
08:23:55 <[exa]> oh I guess it's this https://icfpcontest2017.github.io/ ?
08:23:58 <shapr> yup
08:27:28 <Athas> shapr: well, they are usually some dressed-up NP-complete problem, aren't they?
08:28:03 <Athas> It's a good way to design a contest!  Either it remains interesting because nobody finds the optimal solution, or someone does and that's OK too.
08:28:27 <c_wraith> A lot of them are interactive between participants now.  The current one pairs participants.
08:29:39 <[exa]> shapr: i thought you meant the poster content :] good to know about this thing too btw
08:29:45 <[exa]> *contest
08:38:22 <sproingie> if if's NP-complete and someone found *the* optimal solution, that might win more than a contest award ;)
08:39:47 <tabaqui> Basin with cement, you mean?
08:40:44 <tabaqui> or combortable cell in some hidden prison :)
08:48:28 <Zowlyfon> tabaqui: or a cushy job at the NSA
08:48:34 <Zowlyfon> which you can never leave.
08:55:27 <cheater> hi
08:55:48 <cheater> is there a simple way to generate aeson instances using a TH macro rather than using generics?
08:56:18 <phadej> cheater: http://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson-TH.html
09:03:45 <cheater> ty
09:17:56 <shapr> Athas: this year is especially nice because a working solution looks like it'll take an hour, and a good solution could take forever
09:22:13 <ziman> an hour to compute or an hour to implement?
09:22:29 * hackagebot filelock 0.1.1.2 – Portable interface to file locking (flock / LockFileEx) – https://hackage.haskell.org/package/filelock
09:23:22 <shapr> ziman: you could write a working (but clueless) player in an hour
09:25:33 <phadej> yeah, pick "first" (so you don't even need to bother with randomness) shouldn't take long to write
09:26:15 <cement> dammit
09:26:28 <shapr> cement: you got sucked into ICFPc?
09:26:35 <phadej> cement: it was your tactic? :)
09:26:51 <cement> no, if you say cement as a word, my client flashes
09:27:13 <cement> someone about an hour ago said something about filling a basin with cement
09:27:41 <phadej> :D
09:27:49 <cocreature> that’s what you get for choosing common words as your nickname :)
09:28:07 <phadej> cocreature, cement: my client flashes whenever someone mentions Oleg's papers :/
09:28:19 <shapr> cement: change your nick to cocement?
09:29:12 <cocreature> phadej: why do you have it flashing on “oleg”? do people actually use that name to mention you on irc instead of “phadej”?
09:29:44 <shapr> phadej: isn't that your first name?
09:29:59 <shapr> phadej: puhutko suomea? talar du svenksa?
09:30:12 <sproingie> oleg ambiguity error
09:31:17 <phadej> shapr: puhun suomea, jag kan använda google translate too
09:31:49 <phadej> cocreature: they do, especially on Finnish speaking channels
09:31:50 <shapr> haha
09:31:54 <Tuplanolla> Does our Oleg density exceed our Simon density yet?
09:32:13 <phadej> Tuplanolla: Simon density is over immortality level already
09:32:21 <phadej> threshold
09:32:26 <shapr> phadej: I tried to learn Finnish for two years of living in Tornio; but failed. I did learn Swedish from five years of living outside of Lulea
09:32:34 <shapr> so, not google translate :-P
09:32:40 <cocreature> phadej: well just disable it in #haskell then. the finish channels probably don’t reference oleg’s papers that much :P
09:33:09 <phadej> cocreature: I'm too lazy to read manual even to disable joins and parts :/
09:33:35 <cocreature> heh fair enough
09:33:44 <phadej> shapr: depends on your language background I guess
09:34:05 <shapr> I speak southern American fluently.
09:34:17 <sproingie>  /ignore #haskell JOINS PARTS
09:34:40 <sproingie> least that's how irssi does it
09:34:42 <phadej> shapr: I know one slavic, one uralic, one germangic
09:35:05 <phadej> I conjecture that fact did help me to learn functional after imperative
09:35:15 <shapr> germagic, woo
09:35:22 <phadej> germanic*
09:35:43 <shapr> still a nice word
09:36:02 <phadej> :)
09:39:54 <phadej> shapr: are you still somewhere there up north?
09:42:07 <shapr> Nah, I'm in the southeast USA now.
09:42:31 <shapr> Seven years was long enough to spend that close to the arctic circle.
09:42:56 <shapr> Though I still have a few friends floating around in southern finland and southern sweden.
09:43:27 <Tuplanolla> Floating? It doesn't rain that much.
09:43:39 <shapr> Finland is the land of lakes, right?
09:43:50 <AWizzArd> In GHCI I did  :m +Data.Vector  and then  let v = fromList["a", "b"].   Now, why is unsafeIndex v 2  => ""?
09:44:04 <Tuplanolla> Start from zero, AWizzArd.
09:44:21 <AWizzArd> Tuplanolla: sure, for 0 and 1 it works. And for 3 it segfaults, which is kind of expected.
09:44:27 <AWizzArd> But why does it not segfault for 2?
09:44:39 <Tuplanolla> By accident.
09:44:46 <Tuplanolla> That's the `unsafe` part.
09:49:03 <joebetz> is there a haskell library for autogenerating urls and handlers for a RPC http api?
09:51:25 <sproingie> to consume such a service or implement one?
09:51:26 <joebetz> ideally, it would generate client libraries too, a la Servant. but what I'm mostly trying to get around is having to manually define the mapping from http requests to function calls
09:51:50 <joebetz> both :)
09:52:23 <sproingie> servant seems to be the big one there
09:52:47 <joebetz> yeah
09:53:10 <joebetz> but it still requires that you manually define urls / handlers
09:54:51 <shapr> Is there an English translation of Ridoux's Habilitation A Diriger Des Recherches?
09:55:35 <shapr> I bet Cale would know... or maybe he just read that in the original French.
09:57:48 <Guest43> I have a subclass and a superclass. The superclass has a type family. I'm trying to use the type family in the subclass, but I get type errors and it suggests I try AllowAmbiguousTypes.
09:57:49 <Guest43> code:
09:57:49 <Guest43> class A x where type Assoc x :: *
09:57:51 <Guest43> class A x => B x where function :: Assoc x -> Int
09:57:51 <Guest43> error: 
09:57:53 <Guest43> Couldn't match 'Assoc x' with 'Assoc x0'
09:57:53 <Guest43> NB: ‘Assoc’ is a type function, and may not be injective
09:57:55 <Guest43> The type variable x0 is ambiguous.
09:57:55 <Guest43> Is there a reason for this error? Seems perfectly disambiguous to me. If I switch Assoc to a data family, the type error goes away. It doesn't seem like data vs type should make a difference in this case...
10:00:22 <testing123> pl \x y -> x y
10:00:23 <joebetz> ideally, you'd just collect all the functions you want to serve over HTTP into a list and pass it to a server, and bam, all of those functions can now be called via GET /<function_name>. and all you'd need to do is make sure that all the inputs and outputs can be serialized / deserialized to / from json
10:00:26 <testing123> .pl \x y -> x y
10:00:40 <testing123> @pl \x y -> x y
10:00:40 <lambdabot> id
10:00:48 <testing123> @pl \x y -> x + y
10:00:48 <lambdabot> (+)
10:01:02 <testing123> @pl \x y z -> if x == 3 then y + 2 else z - 2
10:01:02 <lambdabot> flip flip (subtract 2) . ((.) .) . (. (2 +)) . if' . (3 ==)
10:01:45 <sproingie> automagically exposing methods to the web tends to be babby's first web API
10:01:45 <michi7x7> @pl \x y z -> z x y
10:01:45 <lambdabot> flip . flip id
10:01:51 <testing123> @pl \x y z -> map x y ++ z
10:01:51 <lambdabot> ((++) .) . map
10:02:04 <testing123> @pl \x y z -> x + 10 * y - z
10:02:04 <lambdabot> ((-) .) . (. (10 *)) . (+)
10:02:20 <testing123> @pl \x y -> x + x + x
10:02:20 <lambdabot> const . ((+) =<< join (+))
10:02:21 <sproingie> still, some means of generating the stubs would be nice
10:02:28 <testing123> @pl \x -> x + x + x
10:02:28 <lambdabot> (+) =<< join (+)
10:02:34 <testing123> @pl \x -> x + x + x + x
10:02:34 <lambdabot> (+) =<< (+) =<< join (+)
10:02:36 <joebetz> yes
10:02:36 <testing123> @pl \x -> x + x + x + x +x 
10:02:36 <lambdabot> (+) =<< (+) =<< (+) =<< join (+)
10:03:07 <joebetz> and really, what are the alternatives?
10:03:35 <joebetz> RPC, REST, ... 
10:06:20 <c_wraith> joebetz, if you're comfortable with more advanced ghc type features, the servant library can do most of that, starting from a type that describes your api 
10:09:42 <joebetz> yeah, I've looked into that. I just wondered if something could do the final step of deriving those types for me :)
10:12:00 * hackagebot extrapolate 0.1.0 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
10:27:18 <joebetz> sproingie: automagically exposing methods to the web tends to be babby's first web API <-- what do you propose as a more mature solution? obviously, there should be auth and some sanitation of input, but at the end of the day, it's still just RPCs.
10:29:32 <fresheyeball> jyp[m]: hey there, are you the author of Dante?
10:47:28 * hackagebot pusher-ws 0.1.0.1 – Implementation of the Pusher WebSocket protocol – https://hackage.haskell.org/package/pusher-ws
10:55:59 <sproingie> joebetz: the more mature solution tends to be avoiding straight up RPC and using a designed REST interface instead.  of course if you're publishing pure functions, then the RPC already *is* pretty darn RESTful
10:57:44 <joebetz> when you say RESTful, are you including the HATEOS principle? or do you just mean URLs representing operations on resources rather than RPCs?
10:57:49 <sproingie> so a lot of my prejudices don't necessarily apply in haskell-land
10:58:10 <sproingie> i'm by no means a fan of HATEOS, other than the funny name
10:58:34 <sproingie> but of course the idea of avoiding implicit state is a good one
11:00:30 <sproingie> or HATEOAS i guess ... whatever, ya can't spell it without "hate" :)
11:02:04 <JuanDaugherty> pronounced like "hate yo ass"
11:02:06 <erisco> the point of HATEOAS is so a client can discover how to use the service
11:02:37 <JuanDaugherty> a lot of baggage for such a simple paradigm
11:02:48 <sproingie> primarily it seems to be for RESTifarians to always find a way to describe some service as not sufficiently orthodox
11:02:50 <joebetz> which is useful if you have multiple clients, but not if you're just serving data to a single application
11:03:47 <erisco> the grand is as follows... a human visits a web site, looks around, and figures out how to use the service it provides
11:04:17 <erisco> and so similarly, a machine should be able to visit a web site, look around, and figure out how to use the service
11:05:14 <sproingie> a lot of how humans navigate the site has to do with conventions.  similar for apps.
11:05:44 <erisco> the grand vision*
11:05:58 * JuanDaugherty meant REST not that particular carry-on
11:06:26 <sproingie> i pronounce it "hate-e-o's", like some kind of breakfast cereal
11:06:27 <erisco> what instead happens is people pick and choose from REST but end up with something none other than RPC
11:06:38 <joebetz> ^ exactly
11:07:22 <joebetz> and at that point, the distinction between /getUser?name=bob and GET /users/bob is trivial
11:07:43 <erisco> which is not entirely senseless... it doesn't hurt to learn the HTTP protocol and how to use it properly
11:08:09 <sproingie> shoehorning everything into a single protocol not designed for it rather than designing a proper application layer
11:08:40 <sproingie> and I *like* REST, i just don't care for its True Believers
11:09:06 <joebetz> <shrug> I'd rather my URLs look exactly the same as my function names, and not have to shoehorn everything into a resource model
11:09:55 <joebetz> sproingie: the authors do have authority (see http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)
11:10:23 <erisco> I doubt many people who think REST is a good idea have ever read anything by Fielding :P
11:11:21 <erisco> a guy comes up with a concept and everyone else mishears and bastardises it
11:11:30 <erisco> a true FRP story
11:21:32 <kzhang> is "HList" no longer maintained?
11:23:47 <iw00t> is http://learnyouahaskell.com/ any good?
11:24:37 <shapr> it's somewhat out of date
11:24:53 <shapr> I prefer haskellbook.com, others prefer Programming in Haskell (2nd edition) by Graham Hutton
11:25:44 <iw00t> shapr Which would you recommend? I am starting university in September and wanted to get an idea before I start. I am confident in Python and PHP.
11:27:06 <hanna> I like byorgey's cis course
11:27:28 <hanna> cis194
11:27:32 <hanna> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
11:28:06 <hanna> as a bonus, this will probably prepare you for pretty much anything you're likely going to cover in a university course
11:28:32 <iw00t> awesome thank you @hanna
11:28:56 <ab9rf> also, forget everything you learned from PHP and nearly everything from python, it's all wrong
11:29:08 <hanna> not wrong, just doesn't necessarily apply to haskell
11:29:22 <ab9rf> or many other languages
11:29:30 <ab9rf> PHP especially tends to teach bad habits
11:29:57 <ab9rf> i'm not sure if we're better now with PHP being most people's first "language" than we were when most people's first language was BASIC
11:30:53 <dolio> Better in some ways and worse in others.
11:31:43 <iw00t> Python was my first
11:32:43 <hanna> I don't think the first language you learn matters. It depends more on the programmer than the language
11:32:50 <hanna> Bad programmers will always be bad programmers, regardless of which language they're stuck in
11:32:52 <hanna> </opinion>
11:33:36 <ongy> bad/good habbits are a thing. I would love to see people that start out in the functional world
11:34:36 * hackagebot qchas 1.0.0 – A library for implementing Quantum Algorithms – https://hackage.haskell.org/package/qchas
11:35:00 <iw00t> A good programmer should have good habits in any language, but also the willingness to adapt to different languages or methodologies (that may be used by a software company etc.).
11:35:19 <hanna> Habits depend on how much you use a language. You'll have bad habits in any language you don't use extensively; and learn good habits in any language you do. (At least for typical open source development where you read others' code in addition to writing your own and receiving feedback on your pull requests)
11:35:33 <hanna> Agree with iw00t
11:35:46 <ab9rf> erisco: i remember once i put together a small website and had someone comment "Wow, nice RESTful interface" and i was "wtf is that" because i'd never heard of REST
11:36:01 <ab9rf> erisco: my response on reading about REST was "well, duh, isn't that fucking obvious?"
11:38:40 <iw00t> so hanna and ab9rf what book would you recommend?
11:38:48 <ab9rf> i have no book recommendations
11:39:09 <iw00t> okay :P
11:39:49 <dolio> Some languages are not capable of expressing things that are good habits.
11:39:55 <dolio> Like BASIC.
11:40:02 <ab9rf> it kinda annoyed me that something that was obvious to me as someone not even that practiced in the art got someone a PhD 
11:40:09 <hanna> (Also, as a whole I found metadiscussions on learning programming languages to be unproductive armchair didactics :p)
11:40:39 <hanna> ab9rf: I think the definition of a good programmer is one who can come up with good practices on their own
11:40:45 <hanna> without needing it drilled into them
11:40:49 <hanna> Simply by virtue of it making sense
11:40:56 <hanna> That's what it means to have intuition, for me
11:41:04 <[exa]> how's learning programming languages different from learning human languages?
11:41:05 <dolio> (Depending on the BASIC, probably.)
11:41:12 <ab9rf> i remember noting that the worst students in the intro CS class I TAed for back in the 1980s were the ones who had a history of being self-taught, combined with a strong belief that they knew more than anyone else including the professor
11:41:17 <[exa]> algorithms&math stay the same just as the logic stays same
11:41:34 <ab9rf> i think it's the latter factor that was more the issue
11:41:50 <AndreasK> When you stop questioning yourself you stop looking for better solutions
11:41:58 <ab9rf> some of the self-taught students were great, but the key was the willingness to question what they had already learned
11:42:46 <ab9rf> they would refuse to write their assignments using the strategy recommended by the instructor because they "could do it better their own way" 
11:42:57 <ab9rf> and would code themselves into corners
11:46:56 <hanna> [exa]: I think focusing on the language is a red herring. The language is just a tool to express an idea - the difficult part with programming languages is being able to mentally comprehend the concepts involved in programs
11:48:05 <hanna> Learning a new natural language, you have words that are trivial translations of concepts you already know (easy memorization) and words that express concepts or mindsets unique to the culture you're learning (“difficult”, usually only learned via cultural exposure)
11:48:34 <hanna> Programming languages are the same - you can have trivial syntactical replacements of concepts you know, and more difficult changes in ideology / concept / viewpoint; functional vs imperative is difficult because it involves much of the latter
11:49:55 <jle`> kzhang: i use type-combinators for most stuff like that now
11:53:45 <cocreature> jle`: oh that looks like a neat package, thanks for mentioning it!
11:54:31 <jle`> no problem :)  the maintainer can be a bit unresponsive on pr's/issues though so i've been considering making another one these days
11:54:40 <jle`> but i've been pretty much using it for everything
11:55:02 <cocreature> meh it’s missing viny’ls rmap for Prod
11:55:23 <jle`> cocreature: htat's map1
11:55:54 <jle`> http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Type-Class-Higher.html#t:Functor1
11:56:13 <cocreature> jle`: ah nice
11:58:50 <chaoticlambda> Hi, would anyone happen to know where I could find a paper that explicly defines System FC? I'm trying to understand how witnesses are stored, and generally how it is implemented on hardware. I'm hoping this clarifies how kind polymorphism and dependent types are realized on the hardware. 
11:59:40 <[exa]> hanna: I actually meant the tiny subtle difference that the humans won't pretend to understand you. :]
12:00:34 <[exa]> but I guess that correctly grasping the similarity is crucial for good learning/teaching
12:03:06 <swhalen> Hello everyone. Is there a book that's regarded as the "SICP of Haskell"?
12:03:42 <JuanDaugherty> art of FP maybe
12:04:13 <JuanDaugherty> s/art/craft/
12:04:14 <hanna> [exa]: are you sure about that? ;)
12:05:19 <dolio> chaoticlambda: Most of the stuff about FC doesn't make it all the way through the compilation pipeline.
12:06:20 <swhalen> JuanDaugherty: thanks; I'll take a look
12:06:34 <JuanDaugherty> (it's not free)
12:06:36 <cement> there's also Programming in Haskell
12:06:43 <cement> (also not free)
12:07:13 <swhalen> I'm not concerned as to free/not free
12:07:56 <JuanDaugherty> good, half the time that's the expectation/complaint
12:08:02 <cement> Programming in Haskell presumes no prior knowledge, at least as far as I've gotten (Monad Transformers)
12:08:12 <chaoticlambda> @dolio any idea where material concerning the bridge to llvm/svg is?
12:08:12 <lambdabot> Unknown command, try @list
12:08:17 <swhalen> does anyone have any experience with this book? http://haskellbook.com/
12:08:27 <cement> that's the one I recommended
12:08:31 <dolio> llvm is far below where anything from FC touches.
12:08:38 <dolio> And I have no idea how documented it is.
12:08:53 <hanna> chaoticlambda: Keep in mind that the majority of system FC is a type system, which is erased at runtime
12:08:53 <swhalen> cement: I see; sorry. Looks like there's more than one book with that title
12:09:17 <cement> nah, I mixed up the title
12:09:31 <hanna> GHC's nonstruct execution model (STG machine) does not depend strongly on the details of the type checking
12:09:36 <dolio> From something comparable to FC, you go to STG, then to Cmm, and then to llvm, probably.
12:10:03 <dolio> But the FC stuff might be gone by STG already.
12:10:12 <hanna> chaoticlambda: The only really fundamental interaction between the type system and the runtime in Haskell is the fact that GHC translates type class instances into dictionaries (conceptually)
12:10:19 <hanna> Of course in practice, this is often eliminated - but that's just an optimization
12:10:32 <cement> swhalen: it's pretty good as an intro to functional programming, but it is perhaps a bit light on giving examples of applying what it teaches
12:11:07 <cement> though I did skim the chapter that was only for examples XD
12:11:23 <hanna> chaoticlambda: If you want to know how to implement Haskell on hardware, you should read the STG papers by SPJ et al
12:11:51 <dolio> I think most of the coercion stuff in FC doesn't actually turn into anything at the lower levels. It's just around to check stuff, and can be completely erased.
12:12:00 <swhalen> cement: that's good advice. I find that the best way to learn a programming language is to have a good project to work on, but I have had trouble coming up with something substantial to use haskell for 
12:12:03 <hanna> Haskell is not dependently typed, no matter how hard it tries to be
12:12:10 <hanna> If you're determined enough you can still turn everything into type class instances and values
12:12:27 <dolio> Well, not everything.
12:12:28 <hanna> For which standard STG semantics apply
12:12:31 <cement> haskell is maybe the language where you don't wanna try a project first thing
12:14:21 <dolio> Oh, you mean everything in Haskell.
12:14:25 <hanna> Yes
12:14:30 <dolio> Okay.
12:14:49 <chaoticlambda> Thank you hanna and dolio. I will check out the paper on implementation. It's confusing to keep track of the aspects of the pipeline as they relate to the intermediate representation, so hopefully that will clarify. It's also difficult to see how the primops organize the structure of stg, unless I'm backwards on that
12:15:05 <dolio> Even with dependent types, you're just doing more stuff during type checking.
12:15:16 <dolio> Not really doing more stuff at runtime.
12:17:06 <chaoticlambda> Are the papers relevant to compiling to logic blocks of a fpga? I'm trying to see how to represent sys fc directly
12:17:48 <chaoticlambda> Sys fc pro*
12:18:51 <hanna> If you want to compile haskell to FPGA see the reduceron project ;)
12:19:15 <tommd> Or Clash
12:20:15 <chaoticlambda> Huh, epic. Thanks everyone 
12:40:52 * hackagebot type-of-html 0.2.1.1 – High performance type driven html generation. – https://hackage.haskell.org/package/type-of-html
12:42:43 <erisco> what is the truth of an implication called when the consequent is always true?
12:45:07 <Logio> trivial?
12:45:59 <ziman> vacuous?
12:46:19 <erisco> vacuous is when the antecedent is always false
12:46:41 <ziman> oh, I misread you
12:47:03 <chaoticlambda> It sounds like  a tautology 
12:47:18 <erisco> well yes, but vacuous truths are also tautologies
12:51:04 <chaoticlambda> Is it Same consequent thats true for each sequent?
12:54:24 <chaoticlambda> I guess an invariant if so
12:56:05 <Tuplanolla> I have a naming question too.
12:56:15 <Tuplanolla> :t recip . sum . fmap recip -- Does this function have a name?
12:56:17 <lambdabot> (Functor t, Foldable t, Fractional c) => t c -> c
12:57:19 <Tuplanolla> It comes up all over the place.
12:59:20 <ab9rf> you can have vacuously true statements as well
12:59:40 <ab9rf> vacuous statements are those which are true or false because they are quantified over an empty set
13:01:25 <ab9rf> forall x in S. P(x) is true when S is empty, without regard to what P(x) is
13:01:40 <ongy> :t recip
13:01:42 <lambdabot> Fractional a => a -> a
13:02:14 <erisco> I am just trying to think of what that is, Tuplanolla... what do you use it for
13:03:03 <Tuplanolla> We have sum, which gives rise the arithmetic mean; product, which gives rise to the geometric mean and then this thing, which gives rise to the harmonic mean.
13:03:38 <erisco> oh, I am not familiar with harmonic means
13:03:55 <Tuplanolla> It's common in physics, where you calculate effective mass or parallel resistance for example.
13:03:56 <ab9rf> erisco: it's just the reciprocal of the mean of the reciprocals
13:04:08 <erisco> thanks, I can read it ab9rf :P
13:04:25 <ab9rf> i first encountered it with resistances
13:04:30 <ab9rf> but it shows up in other places too
13:04:55 <ab9rf> often shows up when dealing with frequencies
13:05:22 <ab9rf> since you should really be dealing wth period which is the reciprocal of frequency
13:05:50 <Cale> shapr: Nope, sorry (neither)
13:06:50 * hackagebot cabal-cargs 0.8.0 – A command line program for extracting compiler arguments from a cabal file. – https://hackage.haskell.org/package/cabal-cargs
13:06:58 <ab9rf> for parallel resistances, it's because the total conductance of parallel conductors is the sum of their conductances
13:07:08 <ab9rf> and because resistance and conductance are inversely proportional
13:09:10 <Tuplanolla> It's the zeroth power mean or the f-mean whose generating function is invariant wrt `recip`.
13:09:31 <Tuplanolla> Surely such an important thing has a name and I just don't know it.
13:16:22 <ab9rf> just make one up for it, maybe you'll become famous
13:16:47 <Tuplanolla> @let edward = recip . sum . fmap recip
13:16:49 <lambdabot>  Defined.
13:17:46 <ab9rf> harmonic mean is also called subcontrary mean
13:30:27 * hackagebot gnss-converters 0.3.5 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
13:58:08 <ab9rf> also a note: the geometric mean is exp . sum . fmap log 
13:58:19 <ab9rf> well, with a divisoin in there somewhere
13:59:10 <jared-w> ab9rf: so the geometric mean is that except it isn't that? :p
14:01:18 <lyxia> exp . mean . fmap log
14:02:34 <ab9rf> yeah
14:04:59 <davr0s> dependent types look interesting, should i learn idris.. or just focus on trying to actually master haskell and wait for haskel to get them
14:05:57 <ab9rf> jared-w: picky pucky
14:06:11 <ab9rf> davr0s: yes, those sound like good idas
14:06:35 <davr0s> ab9rf yeah but which is better. path (a) or (b)
14:06:55 <ab9rf> davr0s: what is better, grasshopper?
14:09:45 <Tuplanolla> If you want dependent types now, you should probably use the language that has dependent types now, davr0s.
14:11:07 <davr0s> conversely, would i be right in thinking haskell has a much more fleshed out ecosystem to explore.
14:11:26 <davr0s> and more practical use
14:11:37 <Tuplanolla> Yes, but our dependent type story is currently a big mess.
14:12:20 <davr0s> am i right in thinking dependant types would be able to do a lot of the template-metaprogramming stuff in C++ in a more elegant/direct way
14:12:30 <glguy> If you want to write programs you should not worry about dependent types and learn more Haskell. If your goal is actually just to learn more about types, there are lots of directions to go. If you specifically want to learn about dependent types there's also Agda
14:12:52 <Tuplanolla> Coq is not a bad option for that either.
14:13:48 <glguy> I think Agda is better for learning about dependent types than coq, but I think coq is better for being a productive theorem proving environment
14:14:05 <davr0s> my goals are a bit vague. if i want to write programs that do things.. i'll just jump back into c++. but there's a sliding scale, between 'absorbing new ideas' and 'being able to do things'. maybe haskell is in a sweetspot where i still have some new ground to cover whilst getting familiar enough to actually do something.
14:14:39 <davr0s> i guess i should put some time into it .. then i can tell if i want them or not :)
14:15:19 <glguy> dependent types aren't a replacement for C++'s templates, to your earlier question
14:16:05 <hanna> davr0s: I think DT in haskell is more so “well this is ugly as sin but it's the best we got if you've got to use haskell because you're developing a real world program”
14:16:13 <hanna> If you just want DT for the sake of DT, use idris etc.
14:16:26 <hanna> but idris isn't as mature as haskell in terms of being able to develop high-performance real world programs in it :/
14:16:51 <erisco> thing is, learning Haskell is not going to take you away from learning DT
14:17:19 <hanna> Haskell is certainly a sweet spot of allowing you to absorb advanced FP concepts while writing real programs that run on your computer and solve real problems
14:17:33 <erisco> so you can learn many functional concepts in Haskell first and once you are comfortable with types in Haskell you can start to see where DTs fit into the picture
14:17:46 <davr0s> hanna yeah thats what kind of gives me reservation..  haskell is going to be a better balance.. different enough, and useful
14:17:58 <hanna> It also has a lot of libraries which present you with more or less advanced FP concepts, which will help you learn them (by seeing them)
14:18:47 <hanna> davr0s: Also I might be slightly biased here but I think understanding non-dependent functional programming is a necessary step towards understanding dependent typing anyway
14:18:53 <hanna> so you might as well start with a non-DT language
14:21:18 <hanna> davr0s: also make no mistake, you can improve on C++'s template system even without DT
14:22:18 <davr0s> yeah i've been using rust, the middle ground, something a bit like c++ but with typeclass inspired traits
14:23:00 <davr0s> there are some things c++ can do that rust can't do so easily yet, and there's the simple use of values for buffer sizes, dimension-checking
14:24:12 <hanna> I see rust as a better C++ but I don't think it really comes that close to functional programming
14:24:20 <davr0s> what TMP seems to be able to do is pick entirely different codepaths based on type traits, rather than just plugging in components provided by the type
14:24:58 <davr0s> yes i'd agree rust is not FP, but there's also a sliding scale in how people define 'functional programming' (e.g. drop the 'pure'). there's all the lazy iterator stuff
14:25:24 <hanna> you mean something like type dispatch? i.e. write a function that does switch (typeOf value) { case Integer: do something; case Bool: do something Else }  ?
14:25:32 <erisco> functional without purity? I dunno, that isn't negotiate to me
14:26:26 <erisco> negotiable... I don't know what it is with my thought-to-text circuit but it keeps putting the wrong suffixes on words
14:26:41 <davr0s> you can write pure subsets of rust/c++, but you can still mutate where it helps;   rust can also restrict globals more
14:27:15 <davr0s> sliding scale..  'pure functional' <---  --->  'unconstrained mutation imperative everywhere'
14:27:40 <davr0s> hanna  yes
14:28:13 <erisco> one drop of impurity contaminates everything
14:28:36 <hanna> type dispatch is “impossible” in haskell etc. as well
14:28:40 <erisco> IO is a quarantine for a reason
14:28:41 <davr0s> 'vector of type T.. if this type is trivially copyable, resize with memcopies , which in turn use SIMD registers..; else use a codepath that moves each item individually' .. that sort of thing
14:28:57 <hanna> I put impossible in quotes because it's technically possible these days (even without external type constraints, I'm pretty sure), but it's a pretty bad idea since it breaks parametricity
14:29:02 <davr0s> i tend to think the middle ground is usually best
14:29:35 <davr0s> pure OOP = fail,  pureFP.. it might become too convoluted to do simple things (lenses)
14:29:49 <davr0s> in the middle ground you can use ideas from either side and still reason about time and space
14:30:11 <johnw> or you end up avoiding the best qualities of either side
14:30:56 <davr0s> my bckground is gamedev, i got interested in FP for parallelism.. but pragmatically as soon as you can constrain globals, thats enough
14:30:58 <erisco> davr0s, how much Haskell do you know
14:31:34 <davr0s> erisco not  a huge amount , but it makes a lot more sense to me now having used rsut as a bridge
14:31:53 <davr0s> hence the dilemna.. *master haskell* or ditch one new toy and move onto another..
14:32:03 <erisco> davr0s, well, it seems you have a mighty number of opinions about FP
14:32:37 <hanna> I mean if you consider a language which mixes pure functions and impure functions by using a type annotation on something if it's allowed to do impure calls
14:32:41 <hanna> then you've arrived at the IO monad :D
14:32:42 <davr0s> i genuninely like 'multiparadigm'. i definitely dont like pure-OOP
14:32:43 <erisco> if you think lenses are just doing a simple thing in a convoluted way, for example
14:32:46 <erisco> that is just not true
14:33:07 <hanna> (and without the type annotation to separate pure from impure, you lose the pure functional benefits)
14:33:15 <davr0s> i gather there's ideas on teh way like 'linear types' that might close some of teh gaps
14:33:15 <Tuplanolla> You cannot ditch ideas without amnesia, davr0s.
14:33:24 <hanna> But I agree there are some things which are just difficult even with the conveniences bought to us by something like STM
14:33:27 <Tuplanolla> I'm currently exploring how algebraic structures should be implemented in assembly. Functional programming did this to me.
14:33:34 <hanna> s/STM/ST/
14:34:11 <hanna> Tuplanolla: easiest I'd say is probably either STG or scott encoding
14:34:45 <davr0s> basically my view is there are some tasks that map more naturally to FP, and others to OOP.. hence an ideal language will have aspects of both
14:34:53 <Zowlyfon> Tuplanolla: I wonder if its possible to make a toy CPU which is programmed using FP
14:35:04 <hanna> Zowlyfon: Reduceron
14:35:12 <Tuplanolla> I'm more interested in operations and their interfaces, hanna. No allocation.
14:35:34 <davr0s> what happened was the OOP people went without lambdas and tagged unions for years, and there was a reaction toward the exact opposite in FP
14:35:38 <Zowlyfon> I want to make another CPU out of logic gates
14:35:43 <erisco> davr0s, based on what? how many programs have you written completely using FP that are on scale with the programs you wrote in OOP?
14:35:46 <hanna> basically what you want is a (parallel?) reduction machine that collapses an expression tree
14:35:57 <hanna> instead of an imperative stepping machine that iterates an internal state
14:36:08 <Zowlyfon> hanna: ooh
14:36:08 <hanna> it's a completely different approach to hardware design
14:36:12 <Zowlyfon> I'll take a look
14:36:19 <Zowlyfon> because at this level performance doesn't matter :P
14:36:33 <Zowlyfon> tops I can get is about 1-2Mhz
14:36:56 <davr0s> erisco i haven't done anything serious in pure FP really admitedly
14:37:45 <davr0s> there are some parts of 'things i've done' that clearly do map to fp
14:38:26 <davr0s> nonetheless i remain worried by the memory aspect of haskell. 
14:38:38 <davr0s> sometimes reasoning about how something maps to time and space is important
14:38:39 <erisco> you are talking to a channel where many people know Haskell to a high level
14:38:41 <monochrom> davr0s: You may like the OCaml way. It has both sum types and subclass polymorphism.
14:39:04 <erisco> I understand you have a feeling, but it sounds kind of silly telling it to experts on the subject
14:39:23 <davr0s> even rust takes  a small step out of the comfort zone in that they do not have inheritance
14:39:45 <monochrom> It also has open sum types (they call it open variants). which is dual to open product types (row polymorphism, the way they get subclassing to work IIUC).
14:40:00 <davr0s> i'm sure haskell is awesome and worth learning, that isn't in question
14:40:18 <davr0s> i'm just stating I dont beleive its the answer to *everything*.
14:40:29 <Tuplanolla> That's good, because it's not.
14:40:53 <davr0s> there's some cases where i can clearly see it's a superior way to look at things.
14:41:13 <weabot> I for one believe that the last good functional programming language was the 60's version of lisp. Thank you for listening.
14:41:31 <monochrom> Over here in Haskell land, there was TREX (extensible records) which was our stab at row polymorphism and subclassing. It was OK while it lasted.
14:42:18 <davr0s> well i'm seeing how rust traits can do things without c++ style inheritance. losing inheritance isn't a problem
14:42:32 <davr0s> i'm assuming haskell typeclasses can do the same and more
14:42:37 <erisco> Haskell has some good features and is missing some others, no doubt, and on a "what can you make with it" basis you can't make hard real time or low memory programs
14:42:44 <davr0s> they are more elegant in the multiparameter case
14:42:52 <erisco> though you can use an eDSL to sort of circumvent that weakness
14:43:16 <davr0s> yeah i have a crazy idea for something to build.. probably too convoluted but i bet it could theoretically work
14:43:28 <ab9rf> davr0s: you'll find that very few people in here will question your position 
14:43:29 <erisco> if you're coming from game development then you may find it difficult to achieve similar performances
14:43:44 <davr0s> a DSL to generate a runtime system with preprocessing of data into different formats
14:43:53 <ab9rf> i don't know any reasonable programmer who believes that there is one language that is the answer to every programming problem
14:44:39 <erisco> there have been real time games made in Haskell but it doesn't seem to be a popular use case
14:44:39 <davr0s> i've heard a lot of people claim haskell *could* handle games, pointing out most of memory is basically immutable data (textures/vertex buffers), the gamestate is actually small
14:44:40 <Tuplanolla> It's a shame, too.
14:44:43 <ab9rf> there's a reason why most experienced programmers know doezens of languages
14:45:09 <Tuplanolla> One language to rule them all would solve lots of logistical problems.
14:45:31 <ab9rf> Tuplanolla: knowing the industry, it would end up being a dialect of javascript
14:45:41 <davr0s> thats why i'm interested in the middle ground, something that may not be the most extreme of either, but takes inspiration from both sides
14:46:05 <davr0s> my intuition is being able to stay in one environment would pay dividends
14:46:11 <Zowlyfon> I know someone who made an asteroids clone with FRP
14:46:45 <ab9rf> there are a number of haskell-implemented games out there
14:46:45 <Tuplanolla> If I could live to see the day a dialect of JavaScript does hpc and theorem proving, I wouldn't mind dying in a fire fueled by said dialect of JavaScript, ab9rf.
14:46:56 <Zowlyfon> Theres a company which makes android games using Haskell
14:46:57 <davr0s> i've seen 'monadius'
14:47:07 <hanna> (okay I take back what I said about type dispatch being possible in haskell without external constraints - even with every “unsafe” extension I can think of, you still can't seem to violate parametricity in haskell)
14:47:47 <davr0s> the type dispatch thing is waht the extreme c++ proponents say to dismiss rust
14:48:13 <hanna> type dispatch is a bandaid used to fix a lack of parametric polymorphism
14:48:17 <monochrom> Tuplanolla: Your dream is half true. http://www.umsu.de/logik/trees/ runs javascript in your browser to search for a tableau proof or counterexample.
14:48:17 <hanna> just like void* in C
14:48:27 <hanna> and object in OOP
14:48:56 <Tuplanolla> Half true is the worst kind of true, monochrom.
14:49:09 <Clint> nothing is true
14:49:17 <hanna> davr0s: actually if you're interested in haskell graphics, GPipe is really, really cool
14:49:30 <monochrom> I don't think this one is that bad. All you need now is a crazy optimizer such as those in Fortran compilers. :)
14:49:46 <Cale> Back in 2010-2011, I worked on an ARPG in Haskell using FRP. We got it to the point where there was a dynamically loaded open world, and some reasonably decent combat with melee and ranged AIs -- but most of the world was relatively empty, and a lot of the content was yet to really get built.
14:49:48 <davr0s> heh gl is pretty horrible
14:50:02 <davr0s> overly stateful
14:50:14 <Cale> Also, it needed a bit more performance still to run on the phones at the time.
14:50:25 <Cale> (though maybe it would be more okay today)
14:51:23 <Cale> (It ran fine on desktop though)
14:51:34 <davr0s> one big step forward of rust over c++ is the way they treat globals.. global mutation needs an unsafe block. so you can guarantee any global use goes through abstractions (grep unsafe, reject that)
14:51:53 <hanna> davr0s: GPIpe is entirely high-level and purely functional
14:52:05 <Zowlyfon> I normally do my rust comparisons with C
14:52:06 <davr0s> there's no way in c++ to mark globals 'const' in blocks of code. just crappy oop private static stuff
14:52:51 <hanna> it even transforms haskell expressions like “dot vec1 vec2   where dot (V3 a b c) (V3 x y z) = a*x + b*y + c*z” into GLSL automatically, and does other cool things like automatically generating the VAO format, ensuring your shader inputs/outputs all match, and so on
14:53:04 <hanna> basically you don't even have to think about graphics in terms of low level GL operations anymore
14:53:04 <davr0s> ok that does sound very neat
14:53:37 <davr0s> this IS something that interests me, how you could get type information/ code generation that crosses the CPU / GL shader divide,
14:53:47 <hanna> Zowlyfon: as a C programmer, rust seems completely unlike C to me :p
14:54:09 <davr0s> writing a calculation and splitting off parts of it to be done at the vertex level etc
14:54:10 <hanna> (which is sort of a shame because C desperately needs a modern replacement)
14:54:24 <ab9rf> i've seen glsl codegens for haskell somewhere
14:54:25 <jared-w> hanna: for a modern C replacement, I think Rust is currently the best shot
14:54:29 <davr0s> i think c will live on becuse there's no consensus on how to replace it
14:54:45 <davr0s> all the contenders will continue to interface via C
14:54:49 <jared-w> davr0s: C will live on for no other reason than nobody in their right fucking mind is gonna rewrite all of Linux :p
14:55:01 <monochrom> :)
14:55:03 <davr0s> 'rewrite it in rust!!!!'
14:55:05 <hanna> davr0s: in GPipe you think about graphics in terms of “streams”, for example you would take a bunch of vertices and turn them into a “vertex stream”; then you can call the (configurable) rasterize function on this to turn it into a “fragment stream”
14:55:07 <Zowlyfon> hanna: I don't use C++ on purpose, so C is the closest thing I have to compare it to.
14:55:14 <monochrom> Is the Windows kernel in C too?
14:55:15 <Zowlyfon> also, I think its closer to C than rust
14:55:15 <ab9rf> C will live on because there is no consensus that it needs to be replaced
14:55:18 <jared-w> What I do think will eventually happen is that people will stop using C/C++ as anything else than a targeted "high level assembly"
14:55:27 <ab9rf> monochrom: pretty much the entire windows kernel is in C
14:55:29 <Zowlyfon> ab9rf: apart from safety.
14:55:30 <hanna> http://tobbebex.blogspot.de/2015/09/gpu-programming-in-haskell-using-gpipe.html
14:55:48 <jared-w> and will write in languages that guarantee memory safety and other things like that, even if they're just thin wrappers around C
14:56:10 <ab9rf> monochrom: there may be some glued-in bits that are in C++, but not many, and obviously some small parts are in assembly because C has no way to represent most CPU control instructions
14:56:24 <Zowlyfon> I think some people wrote a kernel in Rust
14:56:34 <davr0s> ab9rf my view is : yes it's clearly flawed, but , when you look at the complexity of other languages, its harder to settle on what they should look like ; so a layering approach is best. and this is why we have C++.. a high level language bolted onto the low level one
14:56:38 <hanna> part of the problem with C is that you can only clean up all of the historical warts by breaking backwards compatibility, but having backwards compatibility is sort of the reason why C is still alive
14:56:44 <lijero> Zowlyfon, https://www.redox-os.org/ IIRC
14:56:50 <davr0s> i still think c and C++ are superior to rust for the lowest level code
14:56:55 <monochrom> Yeah, actually I just mean whether the Windows kernel is heavily stuck in C.
14:56:55 <jared-w> Honestly, I think things such as self driving cars are going to motivate this quite a bit. Hardware development is decades ahead of software in terms of testing, correctness, verification, etc., and programming languages are going to have to catch up in that area at some point--one of the ways they'll do so is by making memory safety
14:56:59 <ab9rf> jared-w: nobody genreates C or C++ as a taret language anymore, though
14:57:10 <hanna> also the C standard committee seems completely unwilling to add reasonable extensions to he standard in newer versions, instead focusing on completely unnecessary bloat APIs that nobody uses anyway
14:57:15 <jared-w> davr0s: That's changing, finally! Lots of work is being done to make rust work well on embedded systems
14:57:16 <hanna> instead of focusing on stuff like intrinsics every compiler provides anyway
14:57:21 <hanna> so you can actually us ethem in portable code..
14:57:29 <ab9rf> jared-w: we USED to do that, but there are better IR target languages than C now
14:57:45 <davr0s> i dont mean how effective it is, i mean that rust just doesnt' target that 'aesthetically'
14:57:48 <hanna> but this is not the place to complain about C :p
14:57:57 <jared-w> ab9rf: True, but I meant "compile to C" for platforms such as, say, the Linux Kernel where it's written in C and will continue to be extended in C
14:58:01 <Zowlyfon> davr0s: C yes, C++ no
14:58:12 <ab9rf> monochrom: yeah, i'm sure it is. it's a colossal hunk of code, ost of which is not going anywhere
14:58:21 <davr0s> well C++ has a near-as-dammit C subset
14:58:29 <Zowlyfon> hmm
14:58:32 <davr0s> so you can do 'C with some extra conveniences here and there
14:58:35 <jared-w> I wouldn't be surprised if someone wrote a nice "c-wrapper" like language that wrote excellent memory-safe C and allowed for safe generation of C code for projects such as the Linux kernel
14:58:35 <Zowlyfon> C++ is backwards compatible with C
14:58:41 <Zowlyfon> but Compiling C with G++ is herecy
14:58:46 <davr0s> not 100% but close enough
14:59:05 <jared-w> Zowlyfon: It's "backwards compatible" but undefined behavior and holes in standards are a bitch to deal with :p
14:59:15 <davr0s> jonathan blows JAI language is interesting 
14:59:25 <Zowlyfon> You wouldn't want to use C++ for kernel development according to Linus
14:59:30 <jared-w> eh... idk, I think JAI is way overhyped
14:59:35 <Tuplanolla> Does Rust have trapping unsigned overflow?
14:59:38 <ab9rf> jared-w: you don't have to write something in C to use it with the linux kernel, you just have to be compatible with its calling conventions
14:59:46 <davr0s> jared-w i agree with his motivation and criticisms of rust
14:59:48 <jared-w> Zowlyfon: for the record, I agree with his reasonings
14:59:56 <Zowlyfon> jared-w: Linus?
15:00:01 <jared-w> davr0s: is there a link to his motivation and criticisms of rust?
15:00:04 <ab9rf> dunno about linux device drivers, but there are kernel-mode devbice drivers for windows for some devices that are not written C
15:00:07 <davr0s> yes 1min, 1min,
15:00:09 <jared-w> Zowlyfon: yeah, Linus, sorry for the clarification :p
15:00:22 <Zowlyfon> Yeah I do to, I can't remember them atm, I just remember agreeing with them
15:00:35 <jared-w> ab9rf: but that's all "shim" like binary blob code nonsense, iirc.
15:00:47 <davr0s> https://www.youtube.com/watch?v=TH9VCN6UkyQ&t=5952s about 10mins in, 
15:00:55 <jared-w> Tuplanolla: rust attempts to guarantee memory safety at compile time, so overflow wouldn't happened
15:01:21 <ab9rf> jared-w: that's just because those drivers are closed-source
15:01:24 <Tuplanolla> Those are unrelated concepts, jared-w.
15:01:25 <mauke> jared-w: what does integer overflow have to do with memory safety?
15:01:31 <jared-w> davr0s: 10 minutes in or 10 minutes in past the 1:39:26 timestamp? 
15:01:37 <ab9rf> jared-w: usually firmware code that is not actually run on the host
15:01:41 <EvanR> stack overflow, integer overflow
15:01:47 <EvanR> overflow overloaded
15:01:56 <ab9rf> jared-w: but instead is loaded into the firmware of the device; as far as the OS is concerned, that's opaque data
15:01:59 <jared-w> Overflow of any kind is a memory safety issue, really
15:02:03 <davr0s> jared-w he goes on to explain how in his view even std::vector is too 'high level' ,he wants to use raw pointers more often for joint allocations, but more than that he explains a lot about maleability
15:02:10 <mauke> jared-w: how so?
15:02:30 <davr0s> rust front loads work to eliminate *certain classes of error*, which aren't always the most important errors early on when exploring
15:02:39 <Tuplanolla> This attitude makes me sad and plagues many languages, jared-w.
15:02:51 <davr0s> a game which is fun which crashes is better than a game that isn't fun , that doesn't crash
15:02:57 <jared-w> mauke: it's fine if it's intended, but combine overflow with implicit type conversions and you have a nightmare waiting to happen. The fact that Rust works explicitly with sized types and doesn't have a 'int' random type prevents pretty much every overflow-related error
15:02:58 <ab9rf> jared-w: that's not what i'm talking about
15:03:02 <EvanR> davr0s: sounds familiar
15:03:19 <mauke> jared-w: you've lost me
15:03:44 <davr0s> the way i put it is .. you've got other things to test for, as such the frontloading taht rust does for one set of issues isn't actually a win
15:03:55 <jared-w> mauke: pointers can be referred to as ints in C, and if you use a float with an int, you'll get implicit conversion; each type also has different overflow points and different precision levels
15:04:07 <ab9rf> i haven't been sold yet that rust actually does anything useful
15:04:07 <mauke> jared-w: nonsense
15:04:08 <EvanR> if you write code thinking "this is an integer (ZZ)" then it may have an overflow bug, because its not ZZ
15:04:37 <jared-w> On the other hand, if you follow 'best practices' and always use sized types, you're fine because at least the compiler will make sure you're aware of what you're doing
15:04:48 <davr0s> ab9rf well, I am convinced we can improve on c++. rust gives me a few things I always wanted, like a way to control globals, and immutable-by default
15:04:56 <jared-w> Especially with a compiler like Rust's which enforces size checking and doesn't allow non-explicit casting (iirc)
15:04:59 <EvanR> the compiler cant tell if youre thinking this is a math integer
15:05:09 <mauke> jared-w: I don't think you know what you're talking about
15:05:11 <EvanR> or if your computation would oveflow
15:05:15 <jared-w> mauke: why do you say that?
15:05:24 <davr0s> bounds checks are something i criticise rust about
15:05:34 <Zowlyfon> ab9rf: Safety is useful
15:05:44 <Tuplanolla> Then your number theoretical library produces bogus results because you wrote `n * (n + 1) / 2` and it wrapped around, jared-w.
15:05:45 <jared-w> I've taken several low level assembly courses; are we talking past each other somehow?
15:05:48 <davr0s> to me bounds checks are for debug builds
15:05:51 <Tuplanolla> This is not a type issue and this is not a memory safety issue, jared-w.
15:05:56 <davr0s> if you think you need bounds checks, that says you aren't yet confident that the program is logically correct - you have more testing to do
15:06:04 <mauke> jared-w: assembly has nothing to do with C
15:06:21 <mauke> and everything you said has nothing to do with memory safety
15:06:23 <Cale> davr0s: That's a very antimodular way to think about things
15:06:24 <ab9rf> jared-w: amd i've written entire production applications in assembly. means jack/shit.
15:06:26 <jared-w> Sorry--I took some assembly courses, some low level C courses, had some computer security sprinkled in, etc
15:06:46 <EvanR> davr0s: if you dont "know" the program is correct, you have more testing to do?
15:06:56 <ab9rf> hell, i've written text processing apps in FORTRAN :)
15:06:56 <davr0s> sure
15:07:03 <jared-w> EvanR: clearly, if you haven't written a formal proof for its execution, are you even trying?
15:07:05 <EvanR> that sounds like two half-asses combining to get quarter-ass
15:07:27 <davr0s> if you get through enough 'stress tests'/'extreme cases', the chances that you have a flaw in index logic is vastly reduced
15:07:45 <jared-w> mauke: are you guys picking at my usage of 'memory safety'? Because I do admit I'm stretching the definition of memory safety a little bit. Machine integers have nothing to do with actual "memory safety" by common definition
15:07:46 <EvanR> memory test programs run extreme tests
15:07:49 <davr0s> if your meshes even look right, their indices are probably logicallt sound to the extend you can ditch the bounds check..
15:08:03 <EvanR> but have no hope of finding 1 problem in N gigs
15:08:17 <jared-w> davr0s: Or the compiler can do bounds checking and rewrite the assembly output to not include it :p
15:08:30 <davr0s> basically you have to know more about your indices than the fact they're merely 'in bounds'
15:08:43 <ab9rf> "in bounds" doesn't mean "correct"
15:08:47 <davr0s> exactly
15:08:54 <EvanR> yeah bounds is just one of many possible requirements
15:08:54 <ab9rf> it just means "not really badly incorrect"
15:09:22 <davr0s> and of course a bounds check is a nice debug assert to have, in your stress tests, to narrow down where it broke if it broke
15:09:23 <EvanR> "doesnt overflow" is another not-really-badly-incorrect, if you think youre dealing with integers
15:09:26 <monochrom> https://plus.google.com/u/0/102208456519922110915/posts/DZsZ6mvA4T6  --- example of eliminating bound check.
15:09:33 <ab9rf> all bound checking does is prevent you from scribbling over data that isn't yours when your code misoperates.
15:10:01 <davr0s> an out of bounds index in a mesh would be a glitch
15:10:08 <ab9rf> to be fair, this does prevent you from writing a version of sendmail that's vulnerable to the Morris worm, but it's not 1987 anymore.
15:10:26 <EvanR> blantly wrong graphics is pretty bad
15:10:32 <davr0s> and if your game has to display an error message 'sorry i can't draw this mesh, it has an out of bounds index..'
15:10:37 <davr0s> or dropping an obejct..
15:11:13 <davr0s> i understand the rust people's logic , for their use case
15:11:14 <EvanR> but the idea of errors which are not fatal is pretty interesting
15:11:19 <jared-w> ab9rf: The challenger shuttle exploded because someone got a for loop wrong. Sometimes it's nice to have a compiler verify things like this
15:11:41 <ab9rf> jared-w: the challenger shuttle exploded because it was too fucking cold on the launch pad.
15:11:43 <EvanR> wait what
15:11:46 <ab9rf> jared-w: it wasn't a computer failure
15:11:56 <davr0s> and this  is the sort of thing i thought haskell could map well onto.. the pipeline for generating meshes in the first place
15:12:08 <monochrom> Yes, it is 2017 already. And yes, index out of bound is still the #1 way to exploit programs.
15:12:22 <ab9rf> it was an o-ring that shrank too much under adverse thermal conditions to provide adequate joint sealing. 
15:12:42 <davr0s> i can certainly see why peopel want bounds checks there.
15:12:50 <davr0s> a game engine can test the indices on loading.
15:13:07 <davr0s> it doesn't need to do it every frame once an asset is aquired and setup
15:13:17 <EvanR> and something else can test them again, if its supposed to be modular and rely on tests :)
15:13:24 <monochrom> Oh! I don't do bound checks in my programs. I just think that other people need to do it. :)
15:13:24 <EvanR> each module can run that test again
15:13:51 <EvanR> i guarantee you theres a way to trigger a failed test, if you run that test each frame
15:14:18 <EvanR> something be wrong here
15:15:07 <enthropy> has haddock given types for GADT constructors as if they are fully applied to arguments?
15:15:35 <jared-w> ab9rf: I might've switched my explosions up. There was /a/ shuttle or something that exploded because of a for-loop somewher
15:16:08 <EvanR> if we rely on tests to "ensure" validity, rather than arguments for why its already valid, then we end up doing tests over and over
15:16:15 <monochrom> enthropy: No. I think it's more like function types.
15:16:16 <enthropy> https://hackage.haskell.org/package/turtle-1.4.1/docs/Turtle.html#t:FoldM vs. my ghci FoldM :: (x -> a -> m x) -> m x -> (x -> m b) -> FoldM m a b
15:16:23 <ab9rf> jared-w: best you actually know what you're talking about before you talk about it
15:16:30 <jared-w> https://raygun.com/blog/10-costly-software-errors-history/
15:16:31 <ab9rf> jared-w: you might run into someone who knows more than you do 
15:16:34 <mauke> ariane?
15:16:35 <ziman> perhaps the Ariane? https://around.com/ariane.html
15:16:46 <monochrom> For example "data D a where D1 :: Int -> D Int" the haddock says "D1 :: Int -> D Int".
15:16:59 <EvanR> jared-w: no the other shuttle died from a hole in the wings heat shield, caused by ice (during launch)
15:17:13 <EvanR> man launches suck
15:17:13 <ab9rf> there's been a number of space missions lost or compromised due to software errors
15:18:04 <ab9rf> one of the mars probes smacked into the planet because of a sign error, iirc
15:18:29 <EvanR> one was famous for messing up the american/metric units
15:18:31 <ab9rf> but for me the worst was the proton beam device with the UI coding error
15:18:35 <jared-w> ahh I was thinking of the Mariner 1 spacecraft
15:19:00 <EvanR> man if only these probes ran haskell
15:19:10 <ab9rf> the one where there were two means to switch it from proton mode to x-ray mode, and only one of them properly changed the beam intensity
15:19:22 <ab9rf> meaning that if you used the wrong one, patients would be grossly overexposed and would generally die
15:19:23 <Zowlyfon> Apparantly space probes have really strict programming requirements
15:19:33 <jared-w> Zowlyfon: they do /now/ :p
15:19:43 <Zowlyfon> Stuff like allocating all memory on the stack
15:19:52 <ab9rf> the apollo 11 CMC has some really gnarly code in it
15:20:01 <jared-w> They had to waste a lot of money and destroy a lot of expensive machinery before they got around to getting serious about their code
15:20:07 <ab9rf> including the ability to adaptively ignore interrupts
15:20:10 <davr0s> yes i view dynamic memory allocation as dodgy
15:20:22 <davr0s> we got lazy and did it in games, but in the early days we did not
15:20:47 <ab9rf> jared-w: again, you need to stop talking ab out this before someone punches you in the face
15:20:49 <EvanR> in the early days, there was garbage collecting lisps
15:21:01 <davr0s> you need to resason about buffer sizes updfront IMO, if you think you are going to have a consistent framerate
15:21:04 <jared-w> ab9rf: why are you so hostile about this?
15:21:13 <ab9rf> jared-w: because you have NO IDEA WHAT YOU ARE TALKING ABOUT
15:21:53 <ab9rf> jared-w: i was actually alive when man landed on the moon for the first time
15:22:17 <davr0s> dynamic allocation -> fragmentation -> unpredictable behaviour
15:22:36 <davr0s> fixed buffer sizes reasoned about upfront = more stable
15:22:37 <EvanR> fragmentation should only at worse cause lower performance?
15:22:53 <davr0s> lower performance might mean someone throwing up in VR
15:22:59 <MarcelineVQ> performance isn't as important as consistency for games
15:23:10 <EvanR> is VR the new "web scale"
15:23:21 <Zowlyfon> VR is the new adult / rich kid toy
15:23:34 <EvanR> this is a best practice because VR
15:23:53 <EvanR> unpredictable behavior sounds a lot worse
15:23:55 <davr0s> VR does have a valid use for the world IMO:
15:24:04 <Zowlyfon> games?
15:24:06 <davr0s> energy saving, if it's done right
15:24:15 * EvanR checks out of the VR convo
15:24:21 <jared-w> lol
15:24:23 <davr0s> 3watt screen 
15:24:28 <Zowlyfon> I'm waiting for VR to be viable for programming
15:24:31 <MarcelineVQ> that derailed quickly
15:24:43 <jared-w> *cough* so how about them functors amirite?
15:24:44 <davr0s> moves the pixels closer to the eyes, so less energy is required to beam the information into your skull
15:24:48 <ab9rf> there was a VR lab at the university i went to law school at
15:24:51 <davr0s> less energy, less material
15:25:22 <EvanR> in the future monitors will be like CRTs are now 
15:25:28 <ab9rf> that was in 1997
15:25:36 <EvanR> old people will lament the days you could watch TV without a thing on your head
15:25:42 <MarcelineVQ> EvanR: desireable for gaming on?
15:25:43 <EvanR> lament... what
15:25:55 <EvanR> the vocab server died
15:26:06 <ab9rf> EvanR: i still have a CRT in my house, actually in service (although it's usually off)
15:26:20 <EvanR> all my monitors are off by this one...
15:26:23 <EvanR> but
15:26:37 <EvanR> alternatively, this monitor is off paradox
15:27:21 <monochrom> fragmentation also means your memory is unusable.
15:27:21 <dolio> EvanR: Better than what we currently have? :P
15:27:54 <EvanR> ab9rf: i have 3 CRTs now... been collecting them off the street
15:27:54 <davr0s> yeah exactly
15:28:01 <davr0s> unpredictable amount of useable space
15:28:10 <EvanR> when you have infinite space....
15:28:11 <ab9rf> EvanR: mine is an old viewsonic. those beasts are RELIABLE
15:28:26 <ab9rf> EvanR: i might still have the bigger viewsonic somewhere, that one i've had since like 1999
15:28:34 <davr0s> and yes on pcs peopel rely on vitual memory, they can get sloppy
15:28:36 <EvanR> infinite space, such as on video cards
15:29:00 <davr0s> real devices have fixed amounts of memory and you have to plan how to fit
15:29:00 <Zowlyfon> my graphics card doesn't properly fit in my case :/
15:29:06 <ab9rf> i'm stingy with memory, comes from cutting my teeth on architectures that had fewer address line bits than I have fingers and toes.
15:29:57 <ab9rf> virtual what?
15:30:05 <monochrom> Haha, I was alive when the address bus had only 16 bits, too. :)
15:30:05 <hpc> virtudyne?
15:30:10 <EvanR> im really glad we dont have to "be unsloppy" with most code
15:30:24 <earthy> I started programming with a whopping 128k of RAM
15:30:35 <ab9rf> earthy: wow, that's like decadant
15:30:36 <earthy> ofcourse, that was not addressable all in one go...
15:30:52 <davr0s> obviously the definition of 'sloppy' varies per domain.
15:30:56 <earthy> (the extra 64k was on the 80-column text card ;))
15:30:56 <ab9rf> earthy: my first computer came with 16k, and 5k of that was used by the operating system.
15:31:04 <monochrom> 36 machine words here. (Casio FX-3600P)
15:31:16 <Zowlyfon> I don't know what my first computer had
15:31:18 <Zowlyfon> I was 3/4
15:31:28 <ab9rf> i'm not counting the HP-9100A i played with as a kid
15:31:36 <EvanR> i had 3 bits, round hole, square hole, triangle hole
15:31:40 * monochrom begins the "my member is shorter than yours" pissing game!
15:31:45 * earthy laughs
15:31:54 <mauke> my first computer ran windows 98
15:31:58 <mauke> come at me, bro
15:32:00 <Zowlyfon> I might start work on a new toy CPU soon
15:32:17 <davr0s> i wish masks weren't so expensive
15:32:31 <Zowlyfon> mauke: same
15:32:32 <EvanR> log 2 bits, probably as low as you can get
15:32:36 <earthy> davr0s: well, you can run your own ASIC for on the order of 3k USD
15:32:44 <earthy> depending on the size
15:33:01 <earthy> that gets you some 10 to 15 chips, IIRC
15:33:05 <Zowlyfon> I didn't discover linux till Debian 5
15:33:32 <monochrom> Also, I proved my programs correct.
15:33:53 <monochrom> But only because I didn't own the calculator.
15:34:26 <Zowlyfon> I like my nspire cx cas
15:34:29 <monochrom> So I had to write my program on paper at home, prove it correct, so that the next day when I borrowed the calculator from a classmate, it had to work the first time.
15:34:30 <Zowlyfon> does algebra for me
15:34:38 <ab9rf> heh
15:34:43 <earthy> davr0s: there's services that let you combine your design with other's designs so the cost of making the mask is shared
15:34:47 <EvanR> monochrom: good idea...
15:34:57 <EvanR> we should do that nowadays
15:35:15 <ab9rf> earthy: what, if your design doesn't use up the whole mask space, they'll put two independent designs on the same mask?
15:35:20 <earthy> I remember coding on paper in the sun with a good glas of beer
15:35:26 <earthy> ab9rf: yup.
15:35:34 <earthy> actually more like 10 or 20
15:35:36 <monochrom> It played a simplified version of Blackjack. (Vastly simplified, e.g., Ace did not have two interpretations. Because 36 machine words, meaning 36 low-level instructions, that's how big a program could be.)
15:36:08 <ab9rf> the TI-55 we had was like that
15:36:16 <ab9rf> like 80 program steps or something
15:36:21 <ab9rf> you could still do quite a bit
15:36:52 <monochrom> Oh yeah 80 is a luxury compared to 36. XD
15:37:06 <earthy> e.g. mosis does that kindof stuff
15:38:06 * hackagebot gnss-converters 0.3.6, uri-bytestring-aeson 0.1.0.2, word-wrap 0.3
15:38:06 * hackagebot  → https://hackage.haskell.org/packages/recent
15:38:06 <earthy> or cmp https://lobste.rs/s/1jg82m
15:38:19 <earthy> http://cmp.imag.fr
15:38:24 <earthy> (damn cut buffer)
15:38:58 <ab9rf> monochrom: well, it depends on what you can encode in a single machine word :)
15:39:49 <ab9rf> ha, the hp-9100 could be turned off in mid-calculation and it would resume when turned back on
15:39:52 <monochrom> Oh! There was also no such thing as "edit-test-debug cycle". Because there was no "edit". You re-enter the whole program again if you want to change anything.
15:40:00 <ab9rf> because it used nonvolatile core memory
15:40:44 <Eduard_Munteanu> Funny how we have file watchers triggering recompiles these days.
15:41:27 <monochrom> Yeah but with these programmable calculators, "x + y = " is "4 steps" because "read x" is one, "+" is one, "read y" is one, "calculate now" is one.
15:41:51 <ab9rf> monochrom: there was one programmable calculator that had some means to combine steps into a single word, forget which one that was
15:42:02 <EvanR> crystal compiler recompiles the entire project each time
15:42:07 <monochrom> So basically imagine Fortran but you have to count tokens.
15:42:08 <EvanR> no per file per module
15:48:15 * hackagebot gotta-go-fast 0.1.3.1 – A command line utility for practicing typing – https://hackage.haskell.org/package/gotta-go-fast
15:48:15 * hackagebot HsHTSLib 1.3.2.1 – High level bindings to htslib. – https://hackage.haskell.org/package/HsHTSLib
16:17:46 <bollu> if I have a Data.Map k [a], how do I idiomatically turn it into a Data.Map a [k]?
16:17:50 <bollu> as in, do the "reverse mapping"
16:17:59 <bollu> There is some clever Traversable usage for this, I feel :) 
16:18:02 <bollu> foldable / traversable
16:18:14 <bollu> but I'm not able to phrase it "nicely" in code
16:20:40 * hackagebot word-wrap 0.3.1 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
16:33:55 <dmwit> bollu: \m -> fromListWith (++) [(a, k) | (k, as) <- toList m, a <- as]
16:34:05 <dmwit> bollu: But see also the Hackage package for bidirectional mappings.
16:34:13 <bollu> dmwit let me check that out
16:34:43 <bollu> dmwit: TIL about 'fromListWith', that is super slick
16:35:14 <bollu> dmwit does it not need to be (a, [k]) ?
16:35:25 <bollu> \m -> fromListWith (++) [(a, [k]) | (k, as) <- toList m, a <- as]
16:35:27 <bollu> ?
16:35:34 <Tuplanolla> This Jonathan Blow's talk was quite interesting, because many of these problems also crop up in physics simulations, jared-w.
16:36:44 <dmwit> bollu: Oops, yes. =)
16:36:59 <bollu> dmwit cheers, thanks. Much appreciated
16:37:00 <dmwit> bollu: https://hackage.haskell.org/package/relation
16:37:09 <bollu> dmwit looks bad complexity theoretically though, with ++ and all
16:37:11 <bollu> oh well :P
16:37:31 <dmwit> The (++) is always prepending singletons, so it's cheap.
16:37:35 <bollu> dmwit cool
16:37:41 <bollu> dmwit ah, fair point.
17:18:19 <harwiltz> Hello all. I'm making a program that's launching a pdf viewer, but whenever I close my program, the pdf viewer closes as well. I'm using createProcess from System.Process. Do you know of any way to avoid this behavior?
17:18:43 <harwiltz> I tried forkProcess, but that didn't change anything
17:24:25 <geekosaur> that sounds wrong to me, unless your program is the only thing running in a terminal in which case you need to put it in a different session
17:25:27 <harwiltz> geekosaur: Yeah, I want to put it in a different session. But when I try editing the new_session record of CreateProcess, ghc tells me that new_session is not a visible constructor or something
17:27:54 <geekosaur> are you sure you have a recent enough version of the process library? (remember that it comes with ghc, so e.g. stack will refuse to use a newer one than comes with the ghc your current resolver uses)
17:28:56 <harwiltz> geekosaur: I installed ghc probably a few weeks ago, when I installed a new OS 
17:29:08 <harwiltz> Using version 7.10.3
17:29:17 <geekosaur> hate to say it but that is old now
17:29:17 <monochrom> That's old
17:29:29 <monochrom> Was also old a few weeks ago.
17:29:32 <geekosaur> 8.2.1 just release and most folks have been running 8.0.1/8.0.2
17:29:48 <harwiltz> Really... I wonder why, I'm using a rolling release distro even
17:30:02 <monochrom> If you use 8.0.x you will have new_session.
17:30:35 <harwiltz> My distro's official version of ghc is 7.10.3, for some reason. I guess I'll go ask on their channel...
17:30:36 <monochrom> Impeach your distro.
17:30:48 <harwiltz> monochrom: So you think new_session would be a valid approach?
17:31:07 <monochrom> However, I wonder if it suffices to just create a new process group (look at create_group).
17:31:22 <geekosaur> not if it's a terminal that is killing the session on exit
17:31:31 <monochrom> I don't know. I am only telling which version has what.
17:31:38 <geekosaur> you need to dissociate from the tty, which is one of the things setsid() does
17:32:03 <harwiltz> geekosaur: Hmm... do you know of any haskell function that does that?
17:32:55 <monochrom> To be fair, we don't even know what "close my program" means.
17:33:09 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/unix-2.7.2.2/System-Posix-Process.html#v:createSession but i don't know if that is in 7.10's unix package
17:33:55 <monochrom> 7.10.3 uses 2.7.1.0
17:33:57 <geekosaur> ok, it is
17:35:51 <harwiltz> geekosaur: Cool, I'll look into that
17:36:16 <harwiltz> Strangely enough, I was actually just staring at this function, I just don't know what to do with the ProcessGroupID
17:36:25 <monochrom> Oh nice, setsid also creates new process group.
17:36:46 <harwiltz> Do you guys think 8.0.2 will suffice?
17:37:02 <geekosaur> yes, a session is a process group plus some functionality (notably dissociating from controlling terminal, possibly more on systems with e.g. cgroups or labels)
17:37:11 <geekosaur> monochrom already said it would
17:43:58 <joebetz> to everyone I was discussing HTTP-RPC with before, it seems we already have a superior solution to servant: http://ku-fpg.github.io/2016/02/09/remote-json/
17:44:49 <ertes> elo
17:46:49 <mac10688> does anyone know if snap works with ghc 8?
17:47:54 <joebetz> the disadvantage being that your api is coupled to haskell clients, of course
17:48:18 <dmj`> mac10688: it does
17:48:23 <joebetz> and I don't know how it handles RPCs that require some sort of datastore which the client doesn't have access to
17:48:35 <mac10688> thanks dmj` I'll give it another shot
17:49:29 <Welkin> joebetz: "superior solution"?
17:50:09 <joebetz> yes :) in that it's designed for RPCs, rather than any given semantics of a URI
17:50:40 <Welkin> how is that different from distributed haskell (cloud haskell) or erlang?
17:51:35 <ertes> one thing about it is intriguing: automatic collection of multiple requests into a list request
17:51:50 <ertes> with JSON-RPC you usually have to be explicit about that
17:52:18 <Welkin> I don't see how that has anything to do with servant
17:52:21 <Welkin> servant is for web apis
17:52:25 <Welkin> this is totally different
17:52:36 * ertes doesn't have much experience with servant
17:52:58 <ertes> TBH i don't think there is any difference between "web API" and "RPC"
17:53:02 <Welkin> that wasn't directed toward you ertes, sorry if that was confusing
17:53:12 <Welkin> it was meant for joebetz 
17:53:36 <joebetz> well, in practice, most web apis are just rpcs
17:54:21 <ertes> much like most apples are just apples =)
17:54:28 <harwiltz> Alright, well I gotta compile ghc 8.0.2, so this will probably take a while. Good night, and thanks geekosaur, monochrom 
17:54:39 <joebetz> and I'm thinking specifically of a rpc from a client running ghcjs to a server running haskell
17:54:56 <Welkin> joebetz: looking at json-rpc, this looks like a subset of what you can already do in erlang and cloud haskell
17:55:32 <ab9rf> some apples are funny-shaped pears
17:55:37 <ertes> Welkin: i don't think cloud haskell is really designed for untrusted RPC
17:56:06 <ertes> i wouldn't use it (and highly doubt that i even *could* use it) for client-server communication in a web application
17:56:12 <ertes> neither would i appreciate its binary protocol
17:57:52 <Welkin> so, you would use json-rpc instead of standard http get/post/etc
17:58:08 <joebetz> yes
17:58:14 <Welkin> but you need a client that can handle it
17:58:29 <Welkin> wouldn'tthe browser need to implement it at some level too?
17:58:38 <Welkin> or does it use some lower level interface
17:58:48 <joebetz> I assumed that it was all just marshalled into http
17:59:11 <joebetz> but I don't know
17:59:16 <joebetz> that's a good question
17:59:21 <Welkin> this is interesting though
17:59:23 <Welkin> thanks for the link
17:59:27 <Welkin> I didn't know about json-rpc
17:59:30 <ertes> Welkin: JSON-RPC is not tied to any particular protocol; you can use it over HTTP as well as raw TCP or e-mail or even paper mail, if you really want to
17:59:44 <ertes> so JSON-RPC vs. HTTP is apples vs. oranges
17:59:48 <monochrom> Perhaps there is no web browser or web server. Perhaps two non-web programs are talking to each other, but they pretend to use HTTP and JSON for that talking, just for the sake of reusing existing libraries.
17:59:49 <Welkin> okay
18:00:02 <Welkin> so you could send your json-rpc messages as http post if you wanted to
18:00:19 <ertes> that's the most common use case
18:00:34 <sqooq> hi
18:00:42 <ertes> hi sqooq
18:00:53 <sqooq> i think i wrote bad code
18:01:29 <monochrom> You know, the only reason I learned stdio was that it was the only communication medium they told me to use.
18:01:30 <Welkin> sqooq: you mean "forgive me father lambda, for I have sinned"
18:01:44 <monochrom> I can imagine that today they tell you the only medium is HTTP.
18:01:52 <Welkin> monochrom: who is they?
18:02:05 <monochrom> "real world programmers"
18:02:13 <Welkin> I assume a web browser is using http for all communication
18:02:14 <ertes> sqooq: i think about six impossible programs before breakfast every day
18:02:18 <monochrom> or some kind of authority
18:02:38 <joebetz> json-rpc-client: "This library does not handle transport, so a function for communicating with the server must be provided."
18:02:59 <Welkin> I have been learning erlang recently
18:03:22 <Welkin> mostly as a stepping stone to learning cloud haskell
18:03:42 <Welkin> the binary protocol is pretty cool
18:03:50 <Welkin> json sucks in comparison
18:03:51 <ertes> "HTTP is stateless…  how do i do state?" – "easy: use cookies"
18:04:01 <Welkin> you can send closures over the wire
18:04:15 <ertes> "but then i need to keep track over cookies…  how do i do that?" – "use a database backend"
18:04:16 <MarcelineVQ> ertes: browser storage these days
18:04:33 <Welkin> who needs cookies or localstorage?
18:04:39 <Welkin> just store in RAM
18:04:54 <ertes> "but my data doesn't fit the database model, what do i do?" – "use BSON"
18:05:00 <joebetz> lol
18:05:17 <monochrom> ertes, that's funny because I now think "English is stateless (any communication encoding is), so how have I done state all along? I mean clearly I am stateful but English is stateless."
18:05:27 <ertes> "but doesn't that open up a security hole?" – "yes, but no problem, use an anti-CSRF method"
18:05:47 <ertes> "wow, that's getting complicated!" – "no problem, use an integrated web framework"
18:06:23 <harwiltz> That sums up why I don't like web dev quite well :D
18:06:54 <sqooq> ok is this bad code
18:06:54 <sqooq> http://lpaste.net/357425
18:08:23 <dysfigured> it's a dirty job, but someone's gotta make those websites you visit
18:08:24 <ertes> sqooq: not entirely sure what it does (the name is not very enlightening), but my first guess would be that it can be done much simpler
18:08:25 <monochrom> So the way I solved that is this. So I created an assignment (new state!) for my students. I called it "Assignment 4" and distributed the PDF file to my students. Henceforth whenever they or me mention the magic spell "Assignment 4" we know which state we're talking about.
18:08:36 <monochrom> So I guess next time I can call it a cookie?!
18:08:54 <harwiltz> dysfigured: Yeah, I can't disagree with that
18:09:25 <Welkin> web programming has a lot of ugly parts
18:09:28 <ertes> monochrom: filesystems started that way, too, they came up with an inductive key type
18:09:31 <ertes> "paths"
18:09:33 <Welkin> mostly the network and the browser
18:09:43 <ertes> s/they/until they/
18:09:48 <Welkin> but that makes it more exciting
18:09:56 <geekosaur> languages use redundancy as error encoding, too. what does web call that? (aside from "wasteful")?
18:09:56 <dysfigured> i think javascript is getting significantly less terrible
18:10:18 <Welkin> dysfigured: I actually love using es6 (and es2017, etc.)
18:10:56 <dysfigured> Ramda is pretty sweet. if JS had a pipe operator i'd be ecstatic
18:11:06 <ertes> sqooq: it returns a list of lists…  what exactly does it encode?
18:11:11 <sqooq> ertes: it finds leaves and stores the instructions to get there
18:11:20 <ertes> ah
18:11:33 <monochrom> geekosaur: I know right? https://www.amazon.com/Java-Rocks/dp/1316626229/
18:11:34 <ertes> sqooq: so a list of index trails
18:11:40 <sqooq> so [0,1] means first leftmost branch, then second branch on that branch
18:12:16 <ertes> sqooq: yes, that can be done *much* simpler i think…  let me try
18:12:28 <ertes> sqooq: it's Tree from Data.Tree, right?
18:12:34 <sqooq> no
18:12:41 <ertes> yeah, no =)
18:12:43 <sqooq> data Tree a = Branch [Tree a] | Leaf a deriving (Show)
18:16:37 <sqooq> give me a hint on what I should do to simplify
18:18:17 <sqooq> I knew while writing it that this was a bad way to do it
18:18:20 <sqooq> but it was my first idea
18:19:59 <monochrom> You are also missing other cases, for example Branch (Branch something : Branching somethingelse : [])
18:20:15 <c_wraith> sqooq: the data definition would be a massive help
18:20:31 <c_wraith> But I think it's essentially Free []
18:21:02 <monochrom> Overall while you should recurse on Branch, I don't think you want to recurse over the list.
18:21:03 <ertes> λ> paths (Branch [Leaf (), Leaf (), Branch [Leaf (), Leaf ()]])
18:21:04 <ertes> [[0],[1],[2,0],[2,1]]
18:21:09 <ertes> sqooq: is that what you expect?
18:21:21 <sqooq> c_wraith I gave it already
18:21:27 <sqooq> data Tree a = Branch [Tree a] | Leaf a deriving (Show)
18:21:35 <c_wraith> sqooq: oh, I meant in the paste.
18:21:58 <monochrom> Yeah it's Free[], c_wraith.
18:22:13 <c_wraith> sqooq: so yeah, that's Free [].  Not that I really recommend that you use that representation, but it does sometimes help to think in terms of Free or Cofree
18:22:23 <sqooq> well it matches my data
18:22:29 <sqooq> really well
18:22:30 <sqooq> so idk
18:22:39 <monochrom> OK, what I mean is, use a list function on the list, don't write your own recursive-list code.
18:22:46 <ertes> sqooq: my implementation is very simple and only has two cases
18:23:58 <ertes> sqooq: tell me if you want to see the code
18:24:03 <monochrom> I'll go with ertes's name "paths" too. It's shorter and it's more standard for this.
18:24:18 <sqooq> ertes: I prefer to try and do it myself but I need a little hint at least
18:25:02 <ertes> sqooq: if you receive a (Branch ts), then (zip [0..] ts) gives you a list of indexed pairs
18:25:05 <monochrom> If you see "paths [x,y,z]", here is what you want happen. You want the answer to be [ 0:paths x, 1:paths y, 2:paths z ].  There is a list function for that.
18:25:52 <sqooq> I think I can figure it out with those hints
18:25:53 <sqooq> thanks
18:25:53 <monochrom> Err, If you see "paths (Branch [x,y,z])"!
18:26:21 <ertes> what you need to do is to apply 'paths' to the individual subtrees…  the result is a list of paths that are missing the top index
18:26:32 <ertes> that top index just happens to be the left component of the zip
18:27:44 <sqooq> lol
18:27:47 <sqooq> i'm getting too drunk
18:27:50 <monochrom> Or two list functions.
18:28:14 <sqooq> but tomorrow I'll figure it out lmao
18:28:17 <sqooq> bye y'all
18:28:24 <monochrom> OK!
18:28:31 <ertes> sqooq: good night =)
18:28:48 <ertes> paths (Leaf _) = [[]]
18:28:48 <ertes> paths (Branch ts) = concat (zipWith (\i -> map (i :) . paths) [0..] ts)
18:28:50 <ertes> here is mine
18:29:31 <monochrom> Hmm we need a concat?
18:30:08 <ertes> yes
18:30:22 <ertes> it's clearer to see in monadic style
18:30:28 <monochrom> @type \(Branch ts) -> zipWith (:) [0..] (map paths ts)
18:30:30 <lambdabot> error: Not in scope: data constructor ‘Branch’
18:30:46 <monochrom> @type \ts -> zipWith (:) [0..] (map paths ts)
18:30:48 <lambdabot> error:
18:30:48 <lambdabot>     • Variable not in scope: paths :: a1 -> [a]
18:30:48 <lambdabot>     • Perhaps you meant ‘path’ (imported from Data.Graph)
18:31:01 <ertes> @let data Tree a = Branch [Tree a] | Leaf a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
18:31:02 <lambdabot>  .L.hs:163:23: error:
18:31:02 <lambdabot>      Ambiguous occurrence ‘Tree’
18:31:02 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
18:31:04 <monochrom> Oh, you used your own ghci
18:31:13 <ertes> @let data RTree a = Branch [RTree a] | Leaf a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
18:31:15 <lambdabot>  Defined.
18:31:15 <MarcelineVQ> you boys are full of beans today
18:31:23 <Welkin> name it Treee
18:32:30 <monochrom> @type let paths (Branch ts) = zipWith (:) [0..] (map paths ts) in paths
18:32:31 <lambdabot> error:
18:32:32 <lambdabot>     • Occurs check: cannot construct the infinite type: a1 ~ [a1]
18:32:32 <lambdabot>       Expected type: RTree t1 -> [a1]
18:32:40 <monochrom> Ah.
18:32:59 <ertes> @let paths' (Leaf _) = [[]]; paths' (Branch ts) = do (i, t) <- zip [0..] ts; p <- paths' t; pure (i : p)
18:33:01 <lambdabot>  Defined.
18:33:08 <ertes> monochrom: ^ the monadic version
18:33:17 <ertes> it's easy to see there why you need concat
18:35:10 <monochrom> Also consider zipWith (\i t -> i : paths t) [0..] ts  :)
18:35:37 <monochrom> FIFY = fused it for you :)
18:36:02 <ertes> huh?  that looks like a type error to me
18:36:13 <ertes> paths _ :: [[Int]]
18:36:15 <ertes> i :: Int
18:36:34 <c_wraith> so make it a map (i:)
18:36:41 <monochrom> @type let paths (Branch ts) = concat (zipWith (\i t -> i : paths t) [0..] ts) in paths
18:36:43 <lambdabot> (Num a, Enum a) => RTree t -> [a]
18:36:56 <ertes> c_wraith: that's what i've done above, in which case you need 'concat'
18:38:56 <monochrom> Ah, right, strange.
18:39:33 <ertes> not that strange, if you consider that 'paths' returns a list of paths to each of which you need to prepend 'i' =)
18:40:08 <monochrom> OK, need "map (i:)". "(i:)" alone is not enough.
18:40:19 <dysfigured> is #haskell into FRP?
18:40:40 <ertes> dysfigured: some of #haskell
18:40:50 <Welkin> yes, but it's really just a buzzword
18:41:00 <Welkin> it means different things to different people
18:41:01 <ertes> i don't think it's a buzzword
18:41:17 <dysfigured> i've been having a lot of fun with RxJS and Ramda, trying to get into haskell and find similar
18:41:24 <Welkin> at least in javascript land (and elm) it's a buzzword
18:41:39 <conal_> that's recent use of the term "FRP" by people who didn't know the background.
18:41:50 <ertes> it is often used as a buzzword, but it's not a buzzword, if you do what some of us consider real FRP (as initially defined by conal elliott and paul hudak)
18:41:54 <Welkin> dysfigured: the most popular (true) frp library in haskell is probably reflex
18:41:58 <Welkin> there is a channel #reflex-frp 
18:42:21 <Welkin> lol conal_ 
18:42:29 <Welkin> you must have frp on alert
18:42:40 <ertes> dysfigured: the only thing that even came close to real FRP in JS land was bacon.js and flapjax
18:42:55 <ertes> flapjax was actually *really* close
18:42:56 <dysfigured> bacon is pretty similar to rx as i understand
18:43:13 <dysfigured> and kefir and most, i think they all do the same thing?
18:43:14 <ertes> with bacon you need to be really careful to use the proper FRP subset of it
18:43:18 <ertes> as bacon is overpowered
18:43:34 <Welkin> I haven't done much frp
18:43:34 <ertes> it allows things that aren't FRP
18:43:43 <Welkin> never used any js frp libraries
18:44:12 <ertes> also elm has never been proper FRP and is even less now (since the "farewell to FRP" article)
18:44:23 <ertes> elm is essentially an event handling framework now
18:44:35 <Welkin> ertes: yes, which is why I said it's a buzzword
18:44:42 <dysfigured> Welkin: is this totally foreign to you then? https://gist.github.com/DanielFGray/b8232e1cfef54c3575596ae8fc66be89
18:45:02 <Welkin> dysfigured: looks like normal functional code to me
18:45:05 <ertes> dysfigured: if you're interested in real FRP, you should check out the haskell libraries reactive-banana and reflex
18:46:05 <Welkin> dysfigured: one thing I notice is you are not using the es6 imports, but you are using es6 arrows, lol
18:46:09 <Welkin> why is that?
18:46:12 <conal_> Welkin: I guess you could say that about every term, but it's perhaps more about some people's (mis)use of the term than about the term itself.
18:46:25 <ertes> if you're more into JS, check out flapjax…  it tries really hard to be real FRP, but you need to be careful where you place your effects, because FRP is completely pure
18:46:31 <dysfigured> Welkin: because node doesn't understand import yet without compiling it with babel first
18:46:53 <ertes> JS doesn't have the type system to prevent you from abusing flapjax in a way that is not FRP
18:46:55 <Welkin> dysfigured: oh, it's node.
18:48:00 <dysfigured> Welkin: yeah. it's just a simple bar script, it runs a couple commands in the background that continuously output data, and parses and draws them to screen in a little bar widgets on your screen
18:48:16 <dysfigured> eh words are hard
18:49:39 <Welkin> yeah I see now, using dzen
18:49:41 <monochrom> Words would be so much easier if people stopped for a minute to think "what community am I in now, and therefore what does this word mean to them context-sensitively?"
18:49:44 <Welkin> I only write javascript for the browser
18:51:55 <dysfigured> that's where i started, trying to get outside my bubble
18:52:20 <dysfigured> FP in general has been a lot of fun, or at least what i've learned using Ramda and such
18:52:37 <Welkin> I have been meaning to try out rxjs
18:52:56 <Welkin> and yes, ramda is cool, but I wish there was something even more haskell-like in js
18:53:21 <Welkin> without being a disaster (like fantasy-land, which tries to make algebraic data types and all that available in a messy way)
18:53:51 <Welkin> something normal js developers can actually use
18:54:25 <dysfigured> what do you find lacking?
18:54:29 <Welkin> there is purescript, which compiles to very lean, readable javascript
18:55:01 <ertes> (you could just compile haskell to JS and save yourself the trouble)
18:55:03 <dysfigured> yeah i looked into purescript, but i thought, well why not just haskell and use ghcjs
18:55:08 <Welkin> dysfigured: I just find it kind of clunky, and the naming conventions are odd sometimes
18:55:54 <Welkin> dysfigured: the reason to use purescript instead is that it is as easy to install as node and it is much closer to the model of javascript, so it is easier to understand what it will compile to
18:56:15 <Welkin> ghcjs is still a huge pain to even install
18:56:51 <Welkin> but it has its own advantages, namely having the entire haskell ecosystem and having a multi-threaded runtime with lazy evaluation
18:56:53 <dysfigured> maybe i'll give purescript more of a chance after playing with haskell a bit more
19:09:42 <harwiltz> Hello all. I upgraded to ghc 8.0.2 and now it can't find Data.List.Split anymore... any suggestions?
19:11:03 <harwiltz> Nevermind... my mistake
19:12:09 <harwiltz> And for those that were there when I was asking about the pdf viewer closing when I closed my haskell program - the upgrade to 8.0.2 with the use of new_session in CreateProcess worked! Thanks a lot
19:16:25 <geekosaur> Data.List.Split is in the split package, which doesn't ship with ghc
19:16:55 <harwiltz> geekosaur: Yeah, it didn't work with cabal install split this time, but I found my distro's package for it and now it's fine
19:17:08 <harwiltz> Upgrading to 8.0.2 on my distro was quite ugly
19:18:24 <Welkin> harwiltz: never install ghc through your package manager
19:18:35 <harwiltz> Welkin: Too late, haha
19:18:35 <Welkin> always use stack, or nix, or the binary distribution
19:18:52 <harwiltz> Why though?
19:19:27 <Welkin> because they are slow to update it, and they can break it
19:19:32 <Welkin> get it from the source instead
19:19:54 <Welkin> also, letting stack manage your ghc installations is so much easier
19:19:58 <Welkin> having a global ghc sucks
19:20:47 <harwiltz> Welkin: I'm running a rolling release, source based distro, and usually everything is up to date. This is the first major issue I've had. I've never heard of stack though, sounds interesting
19:20:59 <Welkin> o.o
19:21:05 <Welkin> stack will change your life
19:21:24 <Welkin> harwiltz: https://docs.haskellstack.org/en/stable/README/
19:21:26 <harwiltz> Do you have a link? I think if I just google 'stack' I might not get to the right place ;)
19:21:28 <ertes> harwiltz: i think having a global GHC is fine
19:21:28 <harwiltz> Oh
19:21:36 <ertes> harwiltz: (even though i use nix myself)
19:21:56 <hololeap> if i define untilM = flip untilM_ (from the monad-loops packge), i get a bunch of "Ambiguous type variable ‘m0’" errors unless i explicitly use the type signature. why is this?
19:22:29 <hololeap> i'm only importing untilM_
19:22:49 <ertes> hololeap: usually that means the monomorphism restriction is at work
19:23:13 <ertes> hololeap: and usually the best way to fix it is to write a type signature
19:23:27 <harwiltz> Hmm, interesting. I'll have to look into stack some more. Anyway, I better go off to sleep now, it's been a rough night ;)
19:23:38 <harwiltz> Thanks for the suggestion, Welkin
19:24:44 <hololeap> ertes: is there something similar that works in reverse, where you get errors unless you _remove_ the type signature? i've ran into that as well
19:24:53 <ertes> > ping
19:24:55 <lambdabot>  pong
19:25:19 <hololeap> ?
19:25:45 <ertes> hololeap: i don't think so…  writing a type signature is always a valid thing to do (if the type is correct)
19:26:34 <hololeap> there was one specific instance where i was several "where" levels deep and it broke if i added a type signature to an inner element. somebody said something about the curry-howard isomorphism i think... idk
19:27:05 <hololeap> by inner element i mean function
19:27:06 <ertes> hololeap: in standard haskell you can't refer to type variables defined in an outer scope
19:27:17 <ertes> that requires an extension called ScopedTypeVariables
19:27:24 <hololeap> ok..
19:28:06 <ertes> quad :: (Num a) => a -> a; quad x0 = double x0 + double x0 where double :: a -> a; double x = x + x
19:28:07 <hololeap> but why would it break if it's inferring the same type then?
19:28:10 <ertes> hololeap: ^ this is wrong
19:28:20 <ertes> quad :: (Num a) => a -> a; quad x0 = double x0 + double x0 where double :: (Num a) => a -> a; double x = x + x
19:28:31 <ertes> hololeap: ^ this is correct, but a rather unfortunate way to write it
19:28:46 <ertes> quad :: forall a. (Num a) => a -> a; quad x0 = double x0 + double x0 where double :: a -> a; double x = x + x
19:29:17 <hololeap> ok so the forall binds the type for all levels below it?
19:29:19 <ertes> hololeap: ^ this works when ScopedTypeVariables is enabled, and it's the proper way to write it…  the inner 'a' is actually identical to the outer 'a'
19:29:28 <ertes> the inner function does not actually abstract over any types…  it's monomorphic
19:29:56 <ertes> quad :: (Num a) => a -> a; quad x0 = double x0 + double x0 where double x = x + x
19:30:20 <ertes> hololeap: ^ and this does exactly what the STV variant does automatically, if the monomorphism restriction is enabled
19:30:41 <ertes> and yes, that's what the forall does
19:31:57 <hololeap> so, let me get this straight... is it basically true that ScopedTypeVariables is enabled by default for inferred types but disabled by default when you explicitly define the type?
19:32:24 <hololeap> and then you have to include the forall. thing
19:32:29 <ertes> no, it's the MMR that decides what happens for values without type signatures
19:32:42 <ertes> STV gives you the notation to do explicit type bindings
19:35:32 <hololeap> well, now i know when to use that extension... or would it be safe to turn it on globally? is there a way to do that?
19:37:36 <ertes> you can turn it on for a whole cabal package by using the 'default-extensions' field
19:38:01 <ertes> personally i prefer to enable extensions per-module…  that interacts better with tools
19:38:01 <hololeap> ok. i haven't looked into cabal yet, except for downloading
19:38:16 <hololeap> ertes: gotcha. thanks :)
19:39:48 <ertes> hololeap: also don't be afraid to leave out type signatures for local definitions…  if the types are fairly straightforward, brevity wins over explicitness
19:40:26 <ertes> sometimes type signatures are useful (sometimes even necessary), but often they are just redundant line noise
19:41:01 <ertes> in the case of the 'quad' example above i would prefer the version without a local type signature
19:41:25 <hololeap> they were especially useful when i was first starting to understand the type system
19:41:38 <hololeap> and i needed them pretty much everywhere :)
19:42:15 <ertes> yeah, it's a trade-off
21:01:13 <jle`> is anyone else getting sudden build failures in osx on travis
21:01:23 <jle`> with the stack-based travis script
21:12:06 <Myrl-saki> How do dependently typed languages use semigroup + static length?
21:12:19 <Myrl-saki> Right now, I'm just existentially quantifying.
21:16:09 <Myrl-saki> (I also mean concatenation)
21:18:24 <EvanR> time to do some research on what a length-indexed semigroup is
21:19:35 <Myrl-saki> EvanR: lol
21:20:17 <Myrl-saki> EvanR: That sounds way too specific tho.
21:21:17 <EvanR> maybe the research was already done
21:21:19 <jle`> Myrl-saki: semigroup + static length?
21:21:23 <jle`> what do you mean?
21:21:24 <EvanR> and theres a paper on it
21:21:40 <Myrl-saki> jle`: (<>) :: ISemigroup n a -> ISemigroup m a -> ISemigroup (n + m) a
21:22:30 <Myrl-saki> Errr, just assume that I don't know how to typeclass.
21:22:32 <jle`> hm, sounds like some sort of concatenative option
21:22:49 <jle`> if it's a semigroup, what's the set?
21:23:11 <jle`> what set is it a semigroup over?
21:23:24 <EvanR> sized semigroup
21:24:01 <Myrl-saki> EvanR: There's this, but I haven't read it yet. https://link.springer.com/article/10.1007/BF02573609?no-access=true
21:24:28 * EvanR removes the ?no-access=true and continues
21:24:55 <EvanR> i was half joking earlier
21:25:00 <Myrl-saki> jle`: `instance ISemigroup s => Semigroup (s n) where`
21:25:14 <jle`> Myrl-saki: what wuold (<>) be then?
21:25:20 <jle`> since it wouldn't be a -> a -> a
21:25:25 <Myrl-saki> Oh right. True.
21:25:42 <jle`> it looks like what you're talking about isn't really the same as a semigroup...it's some different mathematical structure altogether
21:25:49 <jle`> maybe something like a type of semigroupoid
21:26:09 <jle`> a "partial" semigroup
21:26:27 <Myrl-saki> Yeah.
21:26:32 <jle`> but the issue isn't related to dependently typed languages...
21:26:37 <jle`> it seems like a mathematical thing
21:26:44 <Myrl-saki> Idris's instance for Semigroup is also `zipWith (+)`
21:27:10 <jle`> for vectors?
21:27:16 <jle`> yes that's a reasonable instance
21:27:18 <Myrl-saki> Mhm.
21:27:40 <jle`> (<>) :: Semigroup a => Vec n a -> Vec n a -> Vec n a
21:27:48 <jle`> that's actually the instance that Haskell has for tuples
21:28:04 <jle`> (<>) :: (Semigroup a) => (a, a) -> (a, a) -> (a, a)
21:28:10 <Myrl-saki> Ah. Makes sense.
21:28:32 <jle`> in general, the instances for fixed-size types are different than the instances for non-fixed-size types
21:28:39 <jle`> for most typeclasses
21:29:09 <Myrl-saki> I'll need to think of a way to do this. :P
21:29:23 <jle`> well, you can just use (++) :: Vec n a -> Vec m a -> Vec (n + m) a :)
21:29:45 <Myrl-saki> jle`: Mhm, but extensionability!
21:29:59 <jle`> if you want to use (<>), you can jump into unsized vectors
21:30:00 <Myrl-saki> I guess I could instead have `Vec vec => ...`
21:30:01 <jle`> and use <>
21:30:08 <jle`> and then jump back out when you care
21:31:08 * hackagebot word-wrap 0.3.2 – A library for word-wrapping – https://hackage.haskell.org/package/word-wrap
21:32:04 <Myrl-saki> If a the size of a fixed-size type is existentially quantified, is it the same as non-fixed type?
21:35:51 <jle`> yeah
21:36:01 <jle`> that's one of the nice things :)
21:36:13 <jle`> Myrl-saki: (n * Vec n a) is equivalent to [a], roughtly
21:36:24 <jle`> roughly, heh
21:36:45 <Myrl-saki> jle`: Infinity \nin n?
21:36:54 <jle`> ther emight be some differences in efficiency
21:37:12 <jle`> ah yeah that too, it's equivalent to finite lists
21:37:50 <Myrl-saki> * for tuples?
21:37:57 <jle`> i'm using 'dependent pair' syntax
21:38:16 <Myrl-saki> Ahh
21:38:18 <jle`> but it's relaly like `exists n. Sing n -> Vec n a`, in haskell
21:38:53 <jle`> it's existentially quantified, along with a witness for what the quantified variable is
21:39:14 <Myrl-saki> I believe you were the one who told me to write it as data Black n = Black String 
21:39:15 <Myrl-saki> data AnyBlack = forall n. AnyBlack (Black n) (SNat n)
21:39:15 <jle`> hm i guess (exists n. Vec n a) is something like [a] too
21:39:25 <jle`> that might have been me yes
21:39:47 <jle`> AnyBlack would be a dependent pair there
21:40:06 <jle`> there are some libraries that offer generic "anonymous" dependent pairs, like (n ** Vec n a) in idris
21:40:26 <jle`> but nothing baked into the language
21:41:26 <jle`> actually i wonder if there's really anything stopping anonymous dependent pairs from being in haskell
21:42:06 <jle`> ah well aside from the fact that 'n' has no runtime witness
21:42:19 <Myrl-saki> jle`: SingI n => ?
21:42:33 <Myrl-saki> Whoops, no.
21:42:39 <jle`> yeah, but then we'd have to basically bake singletons into haskell
21:42:52 <Myrl-saki> jle`: Oh, you mean as an actual feature?
21:42:53 <jle`> it'd work but it wouldn't be good for like, syntax.
21:42:55 <jle`> yeah
21:43:06 <jle`> as a language feature
21:43:25 <jle`> see (n ** Vec n a) isn't very clean to express anonymously in haskell either
21:43:39 <jle`> the closest direct translation is DSum Sing (Flip Vec a)
21:44:15 <jle`> or even if type DS = DSum Sing, you'd need `DS (Flip Vec a)`
21:45:27 <Myrl-saki> jle`: Isn't that clean enough?
21:47:27 <jle`> manually flipping
21:47:33 <jle`> basically forcing things to be point-free
21:47:41 <jle`> it gets complicated for non-trivial parameter orders
21:47:54 <Myrl-saki> On the other hand, I used to think that dependent sums were arcane magic. I miss things. :(
21:48:08 <jle`> (n ** F n (G n X)), definitely harder
21:48:14 <jle`> you'd need to flip and ap and stuff
21:48:17 <Myrl-saki> Oh right.
21:48:35 <jle`> sometimes i miss simpler times too :)
21:48:47 <MarcelineVQ> you can never go home again
21:49:37 <Myrl-saki> jle`: Are there times where n is not a phantom type?
21:52:36 <jle`> could be (a ** [a])
21:52:58 <jle`> hm, are COMPLETE pragmas missing from the ghc 8.2 changelog?
21:53:07 <jle`> i see them in the user manual now
21:53:11 <jle`> and i'm pretty sure they're new
21:55:31 <Myrl-saki> jle`: I'm not showing it, but this is actually blowing my mind. :P
21:57:09 <jle`> COMPLETE pragmas, or (a ** [a])?
21:57:41 <Myrl-saki> jle`: The whole conversation about types. What are COMPLETE pragmas though?
21:59:04 <jle`> for pattern synonyms so you can tell ghc what set of pattern synonyms are exhaustive, heh
21:59:24 <jle`> like for Seq
21:59:26 <jle`> https://ghc.haskell.org/trac/ghc/ticket/8779
22:00:03 <Myrl-saki> jle`: Oh cool.
22:01:06 <Myrl-saki> Oh. Minimal is also a pragma.
22:03:54 <jle`> mhm, that one has been pretty nice for a while
22:04:54 * hackagebot metrics 0.4.1.0 – High-performance application metric tracking – https://hackage.haskell.org/package/metrics
22:11:02 <Myrl-saki> ...
22:11:15 <Myrl-saki> Why is there no `KnownNat n => KnownNat (n + 1)` ?
22:13:29 <nshepperd> because type families can't have typeclass instances. + is a type family
22:13:50 <Myrl-saki> Oh.
22:14:27 <nshepperd> in practice you use a ghc type checker plugin to create an instance like that on demand
22:14:28 <Myrl-saki> What should I do if I have an infinite 1+ ? then?
22:14:37 <Myrl-saki> Can the type checker do that?
22:14:46 <nshepperd> (KnownNat a, KnownNat b) => KnownNat (a + b)
22:14:49 <Myrl-saki>    • Could not deduce (KnownNat (1 + (1 + n)))
22:14:50 <Myrl-saki>         arising from a use of ‘HAH’
22:14:52 <Myrl-saki>       from the context: (KnownNat n, KnownNat (1 + n))
22:15:34 <MarcelineVQ> n + 1 = S n   can haskell do S n?
22:16:15 <Myrl-saki> nshepperd: Oh right. Were you the one who also linked the plugin which can do `1 + n = n + 1`? I forgot the name.
22:17:07 <nshepperd> ghc-typelits-natnormalise & ghc-typelits-knownnat
22:17:13 <Myrl-saki> Thanks.
22:17:48 <nshepperd> oh neat, there's https://hackage.haskell.org/package/ghc-typelits-extra now too, which does even more operations
22:18:35 <nshepperd> -natnormalise solves the equalities for you, -knownnat gives the KnownNat instances
22:25:51 * hackagebot bindings-libg15 0.1.0.0 – Bindings to libg15 – https://hackage.haskell.org/package/bindings-libg15
22:34:45 <jle`> Myrl-saki: you can get KnownNat n => KnownNat (n + 1) using singletons
22:35:02 <jle`> but yeah a typechecker plugin is probably the easiest way to do it
22:38:50 <Myrl-saki> How do I use multiple plugins in ghc through cabal?
22:39:40 <Myrl-saki> Oh, apparently, I needed an = sign.
22:43:47 <akamaus> hi
22:44:16 <dmj`> akamaus: hi
22:45:29 <akamaus> Just a quick question. I have cabal file defining multiple executables with different dependencies. Is it possible to instruct cabal to build just a single executable?
22:46:05 <akamaus> I mean, dependencies for some executables are not satisfied, so it fails on configure stage.
22:47:33 <dmj`> akamaus: you can set flags, setting Buildable: false, this way those deps would be ignored. Otherwise, it will attempt to build all executables and therefore need all deps
22:50:05 <akamaus> dmj`, is it possible to manipulate this setting from cli?
22:50:45 <dmj`> cabal configure -f<flag-name>
23:00:18 <jle`> ls
23:01:33 <dmj`> jle`: o/
23:02:29 <jle`>  \o
23:36:22 <Lokathor> so
23:36:31 <Lokathor> minBound and maxBound don't take an argument to give their output
23:36:43 <Lokathor> but genRange takes an argument that you're told you must ignore
23:37:02 <Lokathor> so does sizeOf
23:37:03 <Lokathor> what gives
23:37:46 <Axman6> sizeOf can's possibly know what type you're talking about based on its context
23:38:03 <Axman6> these days it should probably take a Proxy a instead of a
23:38:10 <geekosaur> minBound, maxBound, and sizeOf know their types by being typeclass methods, so the instance picks the implementation
23:38:42 <Lokathor> Axman6, but the Bounded values know
23:38:45 <geekosaur> genRange has to work with an (undefined :: theType) --- this is actually a deprecated mechanism these days, (Proxy :: Proxy theType) is preferred
23:39:01 <Axman6> Lokathor: yes, because the Bounded values are used somewhere
23:39:11 <geekosaur> since it won't blow up if the impl is bad (in fact Proxy generally won't let the impl be bad)
23:39:15 <Axman6> sizeOf :: Storable a => a -> Int right?
23:39:28 <Lokathor> oh okay
23:39:34 <Lokathor> so
23:39:43 <geekosaur> :t Foreign.Storable.sizeOf
23:39:44 <Lokathor> the "output" of maxBound is pickable
23:39:45 <lambdabot> Foreign.Storable.Storable a => a -> Int
23:39:48 <Axman6> so sizeOf needs an a to know which type it is returning the type of
23:39:54 <Lokathor> but.... alright yeah
23:40:05 <Axman6> uh, size of
23:40:10 <geekosaur> yeh
23:40:55 <Lokathor> so haskell doesn't really have associated constants that can be of other types
23:41:23 <EchoLogic> Hi all, I'm trying to write a function that splits a sentence into an array of words. All I've got so far is splitting a sentence into characters... I need some way of "remembering" as I recurse what has been stored. Can anyone point me in the right direction? http://lpaste.net/357430
23:41:52 <Axman6> EchoLogic: you could use the words function
23:42:26 <EchoLogic> Axman6: So I simplified my problem a bit. The function I need to write needs to have an arbitrary whitelist of good characters, so words is too specific.
23:42:42 <EchoLogic> But what I said above is essentially the MVP
23:42:59 <Axman6> well,  I would start with the implementation of words and work from there
23:43:19 <Axman6> if it gets more sophisticated, a parser might be a more senible thing to use
23:44:04 <EchoLogic> Axman6: looking at source code is a _bit_ on the complicated side right now
23:44:27 <Axman6> @src words
23:44:27 <lambdabot> words s = case dropWhile isSpace s of
23:44:28 <lambdabot>     "" -> []
23:44:28 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
23:44:35 <Axman6> looks pretty simple to me :)
23:46:29 <EchoLogic> Axman6: why is `{-partain:Char.-}` in the Haskell source code for words, but it's not in lambdabot?
23:47:20 <geekosaur> because the @src database is hand built, mostly snippets from the Language Report, and doesn't necessarily match what ghc uses
23:47:41 <geekosaur> it's more tutelary than reality (the real sources tend to be heavily optimized)
23:48:03 <EchoLogic> geekosaur: so when trying to parse the actual source code to understand... may I ignore it?
23:48:20 <Axman6> EchoLogic: that's just a comment btw
23:48:36 <geekosaur> I would stick with what @src said since it's there to be understood
23:49:11 <geekosaur> whereas ghc's is there to be fast and may well stop being fast if modified
23:58:31 <MichaelBurge_> Is there a way to check for "pattern-match equality" for two elements? "data X = A | B" has no Eq instance, but the pattern matcher is still implicitly able to compare Xs for equality in a case statement.
23:59:38 <cocreature> MichaelBurge_: if you have a Data instance you can use toConstr and the Eq instance on Constr
23:59:47 <cocreature> if you don’t then not really
23:59:52 <cocreature> a Generic instance probably works too
