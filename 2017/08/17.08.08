00:00:02 <jared-w> and it's also the reason why bob harper rants about haskell's ADTs being "totally broken" iirc :p
00:00:20 <edwardk> jared-w: let's just say that Bob has a point, but its not a useful point =)
00:01:00 <jared-w> I realize that :) it was a useful and enlightening point for me to learn (and the 'usefulness' of that point was another enlightening moment)
00:01:16 <edwardk> its really all about where you bury the extra bottom in your semantics, meh
00:02:15 * jared-w is thankful that his ~~religion~~ programming language buries its bottoms in the RIGHT spot
00:02:24 <jared-w> (/s)
00:02:52 <koz_> Also, is there any writeup of the monad laws in terms of return, fmap and join instead of the usual return and bind?
00:03:01 <jared-w> But out of curiosity, where else do you bury the extra bottom?
00:03:02 <edwardk> Taneb: actually i think my secret is that i _don't_ know a lot of category theory. so every time i find a new category theory term i have to fumble around to find lots of examples in non-standard domains. all the usual examples don't work for me because my math background is so horridly frankensteined together. ;)
00:03:28 <jared-w> koz_: there is a writeup of the monad laws in terms of the kleisli (sp) arrow if you haven't seen that one before
00:03:32 <koz_> edwardk: If your background is Frankensteined together, I dread to think what mine must be.
00:03:33 <edwardk> koz_: yes, every single textbook on category theory that makes it to the concept of a monad =)
00:03:34 <koz_> jared-w: I have.
00:03:49 <koz_> edwardk: Oh. I ought to look that up and translate it to Haskell then. :P
00:04:04 <jared-w> koz_: that would be the kleisli arrow one then, iirc :p
00:04:34 <koz_> jared-w: The Kleisli arrow one doesn't refer to fmap, return and join IIRC.
00:04:35 <edwardk> koz_: join = (>>= id);   m >>= f = join . fmap f   -- thats all you need to move between them
00:04:53 <koz_> edwardk: I knew of the second, but not the first.
00:05:02 <koz_> Although now that you put it that way, it's shockingly obvious.
00:05:09 <jared-w> oh whoops, I was thinking of something unrelated, nvm
00:05:12 <edwardk> Because >>= 'bakes in' an fmap, you can use it and return to figure out how to define fmap  (via liftM)
00:05:32 <edwardk> this is why >>= and return are kinda nice. you only have to define two things and get everything else for free
00:05:47 <koz_> edwardk: I dunno, I find join much easier to think about.
00:05:52 <edwardk> join on the other hand, depending on the monad can require two different traversals of the 'm' structure to get down to the leaves that may not fuse.
00:06:39 <edwardk> but join has a nice separation of concerns. the fmap part is 'forced', there's at most one law abiding definition for a given type, well modulo some morally indistinguishable choices you can make
00:07:05 <koz_> edwardk: I'm gonna be giving a talk about monads at some point for my university's compsci club.
00:07:14 <edwardk> if i can't figure out >>=. i write 'join' then manually fuse in fmap
00:07:28 <koz_> Which is why I'm asking all this stuff.
00:10:40 <edwardk> jared-w: re bottoms, in a strict language you get f _|_ = _|_ for every 'f', this causes things like Mu and Nu to split apart, knot tying becomes a big mess, because now you need a form of mutation to tie knots, then strictly fewer programs can be written with good asymptotics without adding mutation, and you pick up a bunch of other consequences because of an unwillingness to allow that _|_ in all your domains, but now it sort of
00:10:40 <edwardk> lives in that assumption about all functions.
00:10:59 <koz_> http://www.stephendiehl.com/posts/monads.html <-- looking at this, and just to make sure I get it, in the definition of monad, T = fmap, eta = return/pure, mu = join?
00:10:59 <jared-w> The usual way to write >>= always feels a bit convulted to me, like you're describing the behavior of monads in a sideways fashion and leaking all the fiddly bits of the implementation details of how to pipe the effects together
00:11:15 <edwardk> koz_: yeah
00:12:09 <edwardk> koz_: i recommend watching https://www.youtube.com/watch?v=9fohXBj2UEI
00:12:53 <edwardk> and then after you make it through her series on Monads, watch the catsters videos on string diagrams to get an awesome pictorial explanation of the connection between monads and adjunctions https://www.youtube.com/watch?v=USYRDDZ9yEc
00:13:49 <edwardk> if the monad stuff seems dense, feel free to take a sort of random walk through the other catsters videos by eugenia, they are all pretty darn good and for the longest time they were basically the only category theory material online in video form where you could actually see how a category theorist draws a damn diagram.
00:13:49 <jared-w> google's automatic captions have gotten better at british accent, that's nice
00:14:15 <edwardk> in my experience, its the act of _drawing_ the diagram that is informative. once it is drawn it is sort of 'dead'
00:14:42 <jared-w> Makes sense; I find that to be true of a lot of imagery
00:14:53 <edwardk> that is the thing you can't pick up from category theory textbooks, that sort of 'how does a category theorist approach this sort of problem'?
00:15:17 <jared-w> Kinda like almost all haskell and FP materials suck at teaching you 'how to approach problems in a FP manner' :p
00:15:46 <edwardk> watching lectures like that you can get a sense for how they work. i need a functor from here to there, let's start by figuring out how it maps objects, what it does for arrows, prove composition, identities, etc. then we can look around for adjoints, inverses, etc
00:16:06 <edwardk> the best book for learning how to approach problems in an FP manner is bird's book on pearls of functional algorithm design
00:16:14 <edwardk> that book is amazing if you go through it slowly
00:16:43 <edwardk> if you try to breeze through it? then you just take it as a bunch of disconnected cute stories
00:16:50 <jared-w> Good to know :) I'm reading his "thinking functionally in haskell" book and it's alright for picking that up. The algorithm design one is next on the list
00:17:21 <edwardk> gone through in depth you get the same sense of how a working haskeller works you get about category theory from watching the catsters videos
00:18:02 <edwardk> i've yet to find a category theory text that gives the same sense of pace and insight into the practice of doing category that that book gives about haskell
00:19:00 <jared-w> Sweet, I'm excited now. I got a little annoyed with Bird's beginner haskell book so I might start the algorithm one now
00:19:43 <jared-w> http://www.keithschwarz.com/darts-dice-coins/ this remains one of my favorite learning expositions I've ever read on anything CS related. The introduction, motivation, building up of everything, etc., all just wonderful
00:21:08 <jared-w> Also, edwardk, do you eat your corn on the cob in rows or spirals? I gotta know
00:21:34 <cocreature> quchen: it looks like you have released a new version of prettyprinter-ansi-terminal which uses `panicPeekedEmpty` but haven’t yet released a new version of `prettyprinter` which exposes that function.
00:21:44 <cocreature> quchen: which results in build errors such as https://travis-ci.com/cocreature/reduceq/builds/51878728#L443
00:21:50 <edwardk> jared-w: clearly the answer is columns.
00:22:38 <jared-w> So is that columns lengthwise or do you spin the corn on the cob around as you chew on it slowly and work from one end to the other? :p
00:22:56 <Taneb> ...I eat my corn on the cob by random attack
00:23:09 <jared-w> ಠ_ಠ 
00:23:34 <jared-w> http://bentilly.blogspot.com/2010/08/analysis-vs-algebra-predicts-eating.html --  motivation for the question :)
00:23:49 * jared-w suspects Taneb studies chaos theory
00:24:48 <Taneb> Ha! It's more I'm just not a very methodical person
00:25:03 <koz_> edwardk: Thank you for all that - I will watch and/or read those things.
00:25:12 <edwardk> Count the rows, then eat every n/2th column, then every the n/4th.... the problem with this method is you need to lift your face from the cobb. I'd recommend a Hilbert curve or other space filling curve, but its too much mental arithmetic to keep track of the current orientation and so I always get spun around. Morton order might be a suitable replacement.
00:25:16 <Taneb> I've definitely leant more heavily towards algebra
00:26:12 <jared-w> edwardk: have you considered just investing in glasses instead? Seems easier
00:26:20 <EchoLogic> so I've got this small function called `split` that accepts a filter and a string, and splits the strings on spaces... https://pastebin.com/raw/DKm5kdDA. How can I access the index of the character to create a list of tuples of words+index where the word started instead of just a list of words?
00:26:37 <aphorisme> Is there any sensible way to pattern match on a Network.WebSockets.PendingRequest header path? It's just a strict bytestring, containing probably everything of the uri... 
00:27:35 <edwardk> EchoLogic: modify your function to track the current index as you go. this is going to require you to replace some of the existing bits, because dropWhile won't tell you how much it dropped, etc.
00:28:01 <EchoLogic> edwardk: how do I "track" the current index when I'm recursing though?
00:28:15 <quchen> cocreature: Fixed the constraint on Hackage; I’ll release the new prettyprinter when Travis is OK
00:28:27 <jared-w> If you have a normal item 'a', you can track the index by making a tuple (index, 'a')
00:28:37 <cocreature> quchen: thanks!
00:28:58 <jared-w> so ['a','b','c'] can be "indexed" by making a list of tuples [(1,'a'), (2,'b'), (3, 'c')] and so on
00:29:13 <EchoLogic> jared-w: my input data has no indexes though, I have to make them myself
00:29:29 <edwardk> EchoLogic: start with an index of 0, then whenever you drop a character  add one to your index argument. another way would be to modify the list you're given to just zip it with its index
00:29:36 <jared-w> Yup, but you know what order it came in originally :)
00:29:55 <EchoLogic> what's the "easier" solution here, I feel there's two different ideas...
00:29:55 <edwardk> > zip [0..] "hello"
00:29:58 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
00:30:07 <EchoLogic> okay, zip looks cool
00:30:07 <jared-w> EchoLogic: we're talking about the same thing, actually
00:30:10 <edwardk> this makes it easy to track the index at the expense of being a bit slower over all
00:30:22 <EchoLogic> so you're saying zip the string before I even start parsing it?
00:30:34 <jared-w> Yeah
00:30:54 <EchoLogic> okay, I didn't think of that, I was going to go down the route of looking up the index in `split` directly, but that's really clever
00:30:57 <jared-w> String is just a list of characters. So rather than giving your function a list of characters, you're giving it a list of (index, character). Does that make sense?
00:31:27 <EchoLogic> Yep, I have no qualms about strings being arrays of chars, it's not exactly unique to haskell, just tracking indices in haskell itself was more daunting
00:31:38 <jared-w> EchoLogic: a common refrain in Haskell and functional programming in general is to transform the data into a convenient form for processing :)
00:31:47 <koz_> And let laziness do the rest. :P
00:31:58 <EchoLogic> jared-w: okay that's a fair point. Thank you!
00:31:59 <edwardk> zipping is the easier solution that doesn't require you to rewrite all the bits and pieces you build on top of
00:32:02 <jared-w> "gee I wish I had an index somewhere..." -> transform the data into a form that has an index :p
00:32:15 <edwardk> its not the fastest solution, its cute though
00:33:01 <jared-w> edwardk: Isn't Haskell's method that whenever the cute solution isn't the fastest, it just throws more PhDs at the compiler until it is? :p
00:33:28 <edwardk> pretty much. i mean it worked with dcoutts and stream fusion and we keep hoping it'll work again.
00:33:49 * jared-w is hyped for join points and future linear type magickery
00:34:23 <edwardk> the join point stuff seems to me like something that is awesome, right up until you go back and read olin shiver's much better ancient paper on multi-return function calls
00:34:31 <edwardk> er olin shivers'
00:34:42 <trigone> hi, i'm reading this on use of free monad to replace mtl stacks -> https://ro-che.info/articles/2014-06-14-extensible-effects-failed  -- it basically ended with saying "free monads are so terribly slower, they're a failed attempt at replacing monad stacks". i'm wondering how much it is true: for example, maybe the benchmarks ended up with code that never take up much space in a real-life program?
00:34:54 <edwardk> http://www.ccs.neu.edu/home/shivers/papers/mrlc-jfp.pdf
00:35:02 <koz_> trigone: I think Oleg Kiselyov may have something to say about that.
00:35:18 <jared-w> ooh nifty. I've heard of multi returns before. I think SML had them?
00:35:35 <jared-w> oh nvm, I think this is different than what I was thinking of
00:35:38 <edwardk> i don't know that they ever really made it into a real language
00:35:54 <edwardk> well, they are used in the back end of intel's haskell research compiler after a fashion
00:35:55 <jared-w> J doesn't count as a real language? lol
00:36:01 <koz_> trigone: http://okmij.org/ftp/Haskell/extensible/more.pdf
00:36:10 <koz_> Check the benches at the end.
00:36:11 <edwardk> ok, let me rephrase that. a language with users ;)
00:36:35 <jared-w> oooh, harsh but true :p  although the finance community would have a word with you--all four of them lol
00:36:58 <koz_> jared-w: If I'm not much mistaken, edwardk is in said community.
00:37:06 <koz_> (finance, not J)
00:37:09 <koz_> (at least AFAIK)
00:37:16 <trigone> koz_: actually, the benchmark also includes sth called "freer" so i dunno... https://rawgit.com/feuerbach/freemonad-benchmark/master/results.html
00:37:19 <edwardk> koz_: that said, those benchmarks are against building up towers of reader monads... which isn't a usage pattern anybody does
00:37:27 <koz_> trigone: Freer = Free + Lan.
00:37:52 <jared-w> I thought it was Freer = Free + Er, it's right there in the spelling /s
00:37:59 <koz_> Basically, Free let's you cheat your way up to Monad with only Functor, while Lan lets you cheat your way to Functor with only * -> *.
00:38:21 <trigone> koz_: well it doesn't look like it helps performances?
00:38:32 <trigone> that's my question and (potential) issue
00:38:51 <trigone> i'll rewrite one of my program with the free monad, and see how slower it performs...
00:38:53 <jared-w> trigone: I wouldn't be surprised. If you can go from * -> * to functor to monad with basically anything, there's likely tons of overhead here and there in shuffling things around
00:38:53 <edwardk> I always figure the few APL programmers left in the industry that use languages of that sort are using K and Q.
00:39:20 <edwardk> koz_: Free + Codensity technically
00:39:22 <jared-w> right; I always wanted to learn one of those languages (APL, K, Q)
00:39:35 <edwardk> er
00:39:38 <edwardk> Coyoneda
00:39:44 <trigone> jared-w: well yeah but i waaaant my free monads! *throws ten PhD's to the haskell compiler*
00:40:01 <koz_> edwardk: True, but the criticism that 'extensible effects are 3 slow 5 me' seems unfair given those results. 
00:40:01 <koz_> (or should that be '1 slow 3 me'?)
00:40:01 <koz_> s/let's/lets
00:40:01 <koz_> I must be getting tired...
00:40:02 <jared-w> I have a fondness of esoteric and semi-useless languages that break brains in new ways of thinking about problems :)
00:40:10 <Taneb> I remember I once tried to learn APL and the manual began "plug your typewriter into your telephone and dial the number of your computer"
00:40:23 <jared-w> lol
00:40:28 <edwardk> and thats not quite right either. as freer = free made with reflection without remorse + coyoneda, while operational = free + coyoneda
00:41:00 <koz_> edwardk: I guess. I'm restating my understanding based on Oleg's writeup.
00:41:18 <koz_> http://okmij.org/ftp/Computation/free-monad.html <- this one to be exact
00:41:19 <edwardk> koz_: its almost 4am my time, so i'm not about to go into a screed about more accurate benchmarks around these things right now
00:41:26 <trigone> koz_: what's your final comment on perf issues? cuz i have trouble understanding what you mean...
00:41:31 <edwardk> but reflection without remorse is _slow_
00:41:38 <jared-w> edwardk: I've just read the abstract and I can already tell I'm going to enjoy this paper, thanks! :)
00:41:44 <koz_> trigone: Basically, it's probably not as slow as you think.
00:41:52 <jared-w> edwardk: guess it should've been reflection with only a tiny bit of remose then :p
00:41:55 <trigone> koz_: ok, good :)
00:42:17 <koz_> trigone: I do encourage you to read that paper I linked though.
00:42:35 <koz_> edwardk: Wow...
00:42:39 <koz_> Aren't you feeling sleepy?
00:42:44 <edwardk> i spent 3 months trying to get net performance wins out of reflection without remorse using a fully optimal tarjan-mihaescu deque for machines before i gave up
00:42:58 <edwardk> and i failed by a factor of 20
00:43:05 <jared-w> damn. That's impressively slow
00:43:16 <trigone> koz_: i was wondering. if you can interpret the free monad model to whatever, can you interpret it to a hs source file that would use monad stacks? so you'd use the free monad to test the solidity of the code, and compile it seamlessly to faster performances? (one can dream)
00:43:35 <koz_> trigone: Way way above my head.
00:43:35 <trigone> koz_: i will :)
00:44:00 <trigone> edwardk: you saying the free monad way is always too slow?
00:44:01 <jared-w> trigone: that'd require some massive arbitrary rewriting. I can't think of a way one could even begin to make some translation between the two since (iirc) freer monads allow strictly more constructions than monad transformers
00:44:20 <edwardk> trigone: no. i'm saying that reflection without remorse is more of a niche solution than we thought when it first came out
00:44:28 <trigone> jared-w: well i didn't necessarily mean freer, i don't even know yet what it does
00:44:50 <edwardk> it is a solution to a problem we previously thought was completely intractable, so in that respect, its awesome.
00:44:56 <edwardk> but the constant factors are large
00:44:56 <trigone> edwardk: and reflection without remorse is what free is, or just freer?
00:45:40 <jared-w> edwardk: so for super large transformer stacks, you eventually start to win by using the free monad?
00:45:44 <edwardk> reflection without remorse is an implementation strategy for the free monad that fixes up the asymptotic costs of both left associated binds _and_ inspection that normally you have to choose between by using codensity or the naive encoding of free monad
00:46:06 <edwardk> jared-w: i never said that. oleg has some benchmark that says that
00:46:15 <jared-w> gotcha
00:46:28 <trigone> edwardk: k so it's much more specific than the free monad?
00:47:01 <edwardk> there are 4 main implementation techniques for the 'free' monad. two make inspection expensive, one makes left associated binds expensive, one has big constant factors. pick
00:47:06 <jle`> mfw my program takes forever to compile because of obscene type level stuff going on, and fails at runtime immediately because of an improper printf format string
00:47:21 <jared-w> jle`: lol
00:47:32 <trigone> mfw?
00:47:35 <edwardk> you can turn this from a discussion of 'free monads' to 'all effect systems' if you want, the result still holds
00:47:41 <jared-w> mfw = "my face when"
00:47:54 <trigone> edwardk: constant factors? which is fastest?
00:48:02 <trigone> jared-w: that's a weird expression
00:48:02 <jared-w> trigone: it depnds on... everything
00:48:06 <koz_> trigone: I believe edwardk's point was 'depends on what you want'.
00:48:11 <jared-w> trigone: it comes from 4chan green text
00:48:44 <edwardk> trigone: depends on your usecase. if you construct the thing once and only consume it one time? you can probably just use Codensity (Free f) a. if you always right associate anyways? the naive free monad lets you inspect multiple times without consequence.
00:49:00 <cocreature> jle`: obviously the solution is to replace printf by obscene type level stuff
00:49:12 <edwardk> usually folks have some kind of phase separation in many programs that let them build up and then finally run a bunch of interpretations, so using Codensity (Free f) and lowering to Free f can be good
00:49:16 <jle`> on my wishlist
00:49:18 <jared-w> Typing the printf statement
00:49:29 <jared-w> a tuorial on how to get kicked out of a C-shop
00:49:32 <quchen> cocreature: released
00:49:56 <cocreature> quchen: thanks again! :)
00:50:01 <Axman6> I remember the day when printf _was_ obscure type level stuff
00:50:19 <edwardk> but Codensity f is bigger than f so there is F f in the free package that handles the size issue by being the same size as 'Free f' and having the performance of 'Codensity (Free f)'
00:51:05 <edwardk> Reflection without remorse lets you have both O(1) inspection and left associated binds by explicitly using a catenable deque of 'things to do next'
00:51:22 <jared-w> edwardk: you should go to bed. If you're anything like me you'll get sucked into 2 more hours of explaining and talking if you're not careful :p
00:51:28 <edwardk> but the cost is that manipulating such catenable deques is expensive
00:51:42 <edwardk> jared-w: i have a work call at 10am anyways, so i'm thinking i might just stay up =)
00:51:44 <trigone> k... well i think the best is read the given links and test the code itself. my current idea of using the free monad is rather benign i believe, i'm not yet at the stage of having multiple interpreters and so one (well maybe i'll have an IO one and one to test my code in a pure world)
00:52:04 <edwardk> trigone: you can always just use the MonadFree class in the free package and then pick one later
00:52:19 <edwardk> code against the constraint, then pick and impl when you know your usecase
00:52:26 <jared-w> edwardk: fair enough :p The cut off for mentally restful sleep is 3 hours--any less and you might as well not bother
00:52:26 <edwardk> er pick an
00:52:38 <trigone> edwardk: maybe...
00:52:59 <edwardk> trigone: i recommend reading a few things on the topic of free monads first:
00:53:46 <jared-w> I'm always a fan of the "less code and do it easy" method for starting out. Sort of the "YAGNI" principle for functional programming :p
00:54:02 <trigone> edwardk: yeah sure i still got lots to learn. currently i'm specifically excited on the use of it in this article: http://degoes.net/articles/modern-fp
00:54:10 <trigone> yagni?
00:54:14 <jared-w> Derive all the things! Get all the free stuff! Strap on all the bolts and rockets and blingy shit! Then deal with performance later by refactoring :)
00:54:28 <trigone> you guys throw around an acronym every two sentences :P
00:54:32 <edwardk> https://s3.amazonaws.com/academia.edu.documents/30914785/Philippe_Audebaud_Mathematics_of_Program_Constr.pdf?AWSAccessKeyId=AKIAIWOWYYGZ2Y53UL3A&Expires=1502182403&Signature=xKF5iWFV%2FnDaJX9VTnd7YQe3wtQ%3D&response-content-disposition=inline%3B%20filename%3DUnfolding_abstract_datatypes.pdf#page=396 is janis voigtlaender discovering codensity by accident and using it to make faster free monads when you only construct it once
00:54:36 <edwardk> its a nice intro to the topic
00:54:52 <edwardk> http://comonad.com/reader/2011/free-monads-for-less/
00:54:52 <jared-w> YAGNI == ya ain't gonna need it. In OOP programming it's the idea of "don't implement features just because they sound cool. You aren't going to need them until you need them and it just hinders your progress"
00:55:07 <EchoLogic> Okay so... still adapting that function to have indices... I'm getting this error: `Couldn't match type ‘(Integer, Char)’ with ‘Char’` with `In the second argument of ‘dropWhile’, namely ‘(zip [0 .. ] s)’`
00:55:21 <EchoLogic> So, how can I make dropWhile okay with what I'm trying to do?
00:55:28 <edwardk> http://comonad.com/reader/2011/free-monads-for-less-2/ and http://comonad.com/reader/2011/free-monads-for-less-3/ talk about the 'church free' encoding i use a lot
00:56:00 <trigone> edwardk: your link is a nice intro you mean?
00:56:03 <edwardk> then you can skim the stuff on 'operational' and atze's paper on 'reflection without remorse'. then 'freer' is a much easier read.
00:56:24 <edwardk> the first link is a nice intro by janis. he didn't know codensity existed and just sort of invented it by analogy to 'cont'
00:56:26 <jared-w> EchoLogic: think about the type for a second. dropWhile was working on a list of chars. You started giving it a list of (index, char). How would you change that (,) so that dropWhile gets what it expected to get?
00:56:29 <edwardk> so its a nice accessible read
00:57:07 <EchoLogic> jared-w: I did change the cases though, after the dropWhile?
00:57:16 <trigone> edwardk: ok, i saved your links, i'll study them, thanks a lot :)
00:57:26 <jared-w> EchoLogic: can I see your updated code?
00:58:15 <EchoLogic> jared-w: sure thing! The haskell specific paste tool in the topic doesn't seem to be working... https://www.irccloud.com/pastebin/URUlACd4/
00:58:43 <jared-w> It goes down every now and then, unfortunately
00:59:43 * hackagebot prettyprinter 1.1.1 – A modern, easy to use, well-documented, extensible prettyprinter. – https://hackage.haskell.org/package/prettyprinter
01:01:20 <jared-w> EchoLogic: your dropwhile is recieving a (Char -> Bool) function and (zip [0..] s)
01:01:25 <jared-w> so that's equivalent to
01:01:53 <jared-w> > dropWhile (\_ -> True) [(0,'a'),(1,'b')] -- something like this
01:01:55 <lambdabot>  []
01:02:32 <EchoLogic> what... am I looking at there? dropWhile is taking a function which always returns true, on a list of tuples
01:02:35 <jared-w> > dropWhile (\x -> x == 'b') [(0,'a'),(1,'b')]
01:02:37 <EchoLogic> isn't that exactly what I have?
01:02:37 <lambdabot>  error:
01:02:37 <lambdabot>      • Couldn't match expected type ‘Char’
01:02:37 <lambdabot>                    with actual type ‘(Integer, Char)’
01:02:50 <jared-w> My first example was a bit weird, my bad :)
01:03:33 <trigone> is there a default implementation of return in terms of pure? i'm not clear on whether now Monad automatically implies Applicative or not
01:03:35 <jared-w> _ -> True doesn't have to actually look at the argument so it'll typecheck even when it's not "supposed to"
01:03:42 <EchoLogic> I'm still confused 
01:04:10 <jared-w> The problem here is dropWhile expects a list like ['a','b','c'] but you're giving it a list of [(1,'a') ,...]
01:04:47 <jared-w> So you need to figure out a way to give dropWhile only the character part of the tuple
01:05:00 <lyxia> trigone: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#Monad
01:05:42 <jared-w> > dropWhile (\x -> x == 'a') ['a','b','c'] -- works fine
01:05:44 <lambdabot>  "bc"
01:05:58 <EchoLogic> What's the `\x` syntax, sorry?
01:06:06 <lyxia> trigone: Applicative is a superclass of Monad, so every Monad is an Applicative.
01:06:08 <jared-w> oh sorry, \x is a lambda function
01:06:21 <trigone> lyxia: thanks! :)
01:06:24 <Axman6> > (\x -> x + x) 7
01:06:27 <lambdabot>  14
01:06:42 <EchoLogic> okay, so simple anonymous function like js or any other modern language
01:06:43 <jared-w> > (\x -> x) "anything you give me I give you back"
01:06:45 <lambdabot>  "anything you give me I give you back"
01:06:47 <Axman6> > (\x y -> x*y + x) 7 10
01:06:50 <lambdabot>  77
01:06:52 <quchen> \x -> stuff  ===  function(x) { stuff }
01:06:53 <jared-w> EchoLogic: exactly :)
01:07:04 <quchen> \ is an ASCII approximation to λ.
01:07:25 <EchoLogic> why is dropWhile "hard coded" to accept an array of chars though? That seems silly
01:07:33 <jared-w> :t dropWhile
01:07:35 <lambdabot> (a -> Bool) -> [a] -> [a]
01:07:48 <EchoLogic> okay so essentially I can't do what I want to do
01:07:49 <jared-w> dropWhile accepts any list as long as that list is of type 'a'
01:07:59 <jared-w> EchoLogic: you can! Don't give up hope :)
01:08:13 <jared-w> > fst (1,'a')
01:08:15 <lambdabot>  1
01:08:34 <sumyunseal> '
01:08:38 <jared-w> > map fst [(1,'a'),(2,'b'),(3,'c')] -- Do you understand map?
01:08:40 <lambdabot>  [1,2,3]
01:08:44 <sumyunseal> "
01:08:52 <jared-w> > map snd [(1,'a'),(2,'b'),(3,'c')]
01:08:52 <EchoLogic> I understand map, but not `fit`.
01:08:54 <EchoLogic> *fst
01:08:55 <lambdabot>  "abc"
01:08:59 <sumyunseal> `hey`
01:09:10 <jared-w> fst (a,b) = a  .  snd (a,b) = b
01:09:11 <Axman6> sumyunseal: you ok?
01:09:15 <sumyunseal> `O.O`
01:09:16 <trigone> EchoLogic: fst (x,y) = x
01:09:17 <jared-w> Think of them as "accessor functions" if you want to
01:09:25 <sumyunseal> NO IM CODING 2
01:09:32 <sumyunseal> w u guys
01:09:52 <sumyunseal> fst(x,~)
01:09:57 <quchen> ?where ops
01:09:57 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
01:10:11 <EchoLogic> so if tuples in haskell approximate structs in say C, is there no... non `fst`, `snd`, way of accessing them?
01:10:18 <EchoLogic> like (x,y).x
01:10:24 <jared-w> EchoLogic: so, with `snd` and map, can you think of any way to transform your list of tuples back into a list of characters? :)
01:10:33 <trigone> quchen: what doe that command do?
01:10:43 <Axman6> EchoLogic: there are, but you should learn about this first
01:10:45 <EchoLogic> what happens I have a tuple with 100 things in it, and I want to access the 85th
01:10:59 <jared-w> EchoLogic: eh... Not really. There are some ways to do that (sort of) but the syntax is always going to be more haskelly; eventually you end up preferring the Haskell method for most things
01:11:01 <EchoLogic> ghtyfth (...,...) :P
01:11:01 <quchen> trigone: It makes Lambdabot ping all Ops.
01:11:08 <sumyunseal> u cant
01:11:08 <Axman6> well, tuples are limited to 63 items in GHC, so you can't :P
01:11:10 <trigone> quchen: what's an Ops?
01:11:20 <Axman6> trigone: channel operator
01:11:20 <sumyunseal> tupple u acess with prop
01:11:22 <jared-w> Also, tuples in Haskell are not really generic "heterogenous lists" like they are in Pythin
01:11:24 <sumyunseal> not numbers
01:11:30 <quchen> trigone: Channel operators, AKA people who can kick others.
01:11:30 <trigone> Axman6: like a kind of moderator?
01:11:38 <trigone> k :)
01:11:54 <sumyunseal> tuple.x
01:11:58 <sumyunseal> thats how
01:12:02 <EchoLogic> okay, so do I need `dropWhile fn snd (zip [0..] s)`?
01:12:24 <jared-w> not quite, but very close; that's the right idea.
01:12:31 <EchoLogic> brackets?
01:13:04 <trigone> does it ping by virtue of the special command, or merely bc lambdabot printed their name?
01:13:06 <trigone> > trigone
01:13:07 <sumyunseal> y u r guys so savage?
01:13:09 <lambdabot>  error: Variable not in scope: trigone
01:13:15 <jared-w> snd works on a tuple, not a list of tuples. If you apply snd to every item in zip [0..] s you just get s back
01:13:16 <trigone> lol that's funny
01:13:18 <sumyunseal> do u want to hang me too?
01:13:31 <EchoLogic> uhm... so?
01:13:47 <EchoLogic> `dropWhile fn (zip [0..] snd (s))`
01:13:52 <quchen> trigone: It’s probably a hardcoded string.
01:13:55 <sumyunseal> how bout u just gun me down
01:14:15 <trigone> quchen: yeah it seems like it, i got pinged by lambdabot's variable not in scope
01:14:17 <EchoLogic> haskell is not clicking for me at all I'll be honest
01:14:31 <sumyunseal> EchoLogic, u learning for fun?
01:14:37 <phadej> most likely it won't click in an hour :)
01:14:39 <jared-w> It's fine, it takes time. This isn't the most obvious modification to make to a program :)
01:14:40 <sumyunseal> or to solve a problem
01:15:01 <jle`> EchoLogic: remember how long it took you to learn your first programming language
01:15:05 <sumyunseal> ur brains learns much easier if u have a problem to solve
01:15:08 <EchoLogic> nope, because I was 11
01:15:13 <EchoLogic> and it was probably PHP lol.
01:15:15 <jle`> heh
01:15:20 <jle`> how long was it before you were comfortable with php?
01:15:26 <lambdaGrp> EchoLogic: divide your function in small parts
01:15:27 <EchoLogic> so ofc I block those memories out
01:15:29 <jle`> three, four years?
01:15:30 <ongy> people get comfortable with PHP? :)
01:15:39 <EchoLogic> ongy: > block those memories out :P
01:15:51 <jared-w> ongy: for varying degrees of 'comfortable' :p
01:15:51 <sumyunseal> EchoLogic, seems like there is too much hate in you
01:15:57 <trigone> ongy: insensibilization to trauma yeah
01:16:01 <sumyunseal> i doubt ull be good at anything
01:16:06 <jared-w> sumyunseal: seems lke there is too much trolling in you
01:16:19 <quchen> Please don’t interact with trolls.
01:16:25 <jle`> learning haskell in a lot of ways is like learning programming from scratch, so it's helpful sometimes to temper your expectations on how fast you'll pick it up
01:16:46 <sumyunseal> ahh same old story w the egomaniacs programming
01:16:58 <ongy> especially when you switched between languages and got the gist in days, because it's mostly the same. Haskell tends to be a bit different
01:17:10 <trigone> jle`: in my case i never learned faster how to actually write programs instead of writing prayers
01:17:53 <jared-w> I learned Java in like a week--if that, because I had enough experience with C/C++ that it was basically just the same language almost. Haskell... different story lol
01:18:12 <trigone> but then i discourage myself pretty fast, and all other languages before haskell always looked like the wrong design by design...
01:18:21 <bitonic> jared-w: the good news is that after haskell you can learn Agda or Coq in only a couple of years!
01:18:38 <jared-w> woo! So excite!
01:18:42 <sumyunseal> omg r u guys mental?
01:18:51 <trigone> i'd go for clean personally next
01:18:55 <sumyunseal> i mean look at this conversation?
01:19:02 <quchen> Agda is fairly simple to learn, applying it is where the problems are
01:19:04 <sumyunseal> its nothing but bashing 1 thing or another
01:19:08 <bitonic> quchen: i disagree
01:19:37 <sumyunseal> i learn java in 1 week!
01:19:37 <trigone> quchen: math is fairly simple too, but simplicity is a complex, subjective notion
01:19:46 <jared-w> trigone: clean looks a little weird to me. I think I'd almost prefer Rust because it also has uniqueness/affine types but has more community going for it. If you're just learning it for the paradigm thinking, might as well learn a more popular language? :p
01:19:49 <sumyunseal> i hate C++
01:19:57 <bitonic> learning how Agda or whatever equivalent works is a similar jump from imperative programming to haskell, imo, which is why is so fun :P
01:20:12 <sumyunseal> haskel so much beta than D
01:20:23 <trigone> jared-w: dunno, i heard rust was a bit wet behind the ears... but rust does is also in my list of future wishes
01:20:37 <sumyunseal> rust is the best
01:20:38 <trigone> jared-w: but it's not really pure functional, and i thought it was the implied theme
01:21:04 <ongy> "a bit", it's in a pool...
01:21:08 <jared-w> It's a bit wet behind the ears only because of age. It's got a hell of a lot going for it than Clean which is about as dead as a language can get without reaching tcl status :p
01:21:15 <trigone> bitonic: wah that does sound cool. i certainly don't wanna make blob out of haskell (was that blob? or bleb?
01:21:25 <bitonic> blub
01:21:33 <trigone> bitonic: thx ^^
01:22:06 <ongy> agda is dependent types? How else is it a huge step from Haskell?
01:22:10 <trigone> jared-w: oh i didn't know... any other pure functional language which uses type uniqueness?
01:22:13 <jared-w> trigone: also, pure functional isn't necessairly the theme.  With clean you're really investing in learning how to use an affine type system for effects vs using monads to handle effects
01:22:31 <trigone> ongy: i bet there's more to it... but to be fair i don't know a thing of it
01:22:33 <bitonic> ongy: dependent types have a ton of fallout on the type checking and generally on the language
01:22:45 <jared-w> ongy: the fact that agda is total also fucks with the mind a bit :p
01:22:48 <raichoo> bitonic: +1
01:22:59 <sumyunseal> i hope 1 of you guys can actually code in 1 lang
01:23:09 <trigone> jared-w: and you say rust has the same type uniqueness as clean?
01:23:18 <koz_> sumyunseal: I don't quite get what you mean.
01:23:31 <ongy> oh totality. that's a nice feature... Does it have a proof assistant? or how do you proof totality for the more complex cases?
01:23:32 <sumyunseal> just listen to these guys 
01:23:38 <jared-w> koz_: they're trolling nonsense. We're not feeding the troll here :p
01:23:41 <EchoLogic> So, does the `snd` go in the filter function? I mean, I got that to work in prelude :P
01:23:53 <jared-w> trigone: similar systems, yes. It's not exactly the same, but both are certainly in the same spirit
01:23:58 <EchoLogic> but working != correct
01:24:11 <jared-w> ongy: Agda /is/ a proof assistant, basically
01:24:25 <koz_> jared-w: Sorry, I ducked out for a while.
01:24:30 <koz_> Teaches me to leave IRC I guess. :P
01:24:39 <jared-w> nah you're fine, I made the mistake too :p
01:25:10 <ongy> EchoLogic: do you have a current paste for what you are working on? Not quite sure form current backlog
01:25:18 <trigone> jared-w: cool :) i had wondered if you could apply the safety of type uniqueness to very impure languages. i'll have to relearn c soon, i'll try applying the principles of it (even if i can't type check it)
01:25:48 <trigone> (rust is impure right? i mean type uniqueness put aside, if that means something)
01:25:52 <jared-w> trigone: Rust is definitely not 'very impure'--it is immutable by default, has a ML inspired type system (very similar in spirit ot Haskell's actually)
01:25:58 <ongy> jared-w: I thought agda was closer to programming than theorem proofing. Maybe I need to look at it
01:26:06 <trigone> jared-w: ha oh hm...
01:26:09 <EchoLogic> I gotta' say, Haskell _looks_ kinda like Rust, which I have used
01:26:09 <koz_> ongy: You might be thinking of Idris.
01:26:21 <EchoLogic> if there's one thing I noticed as a beginner it was that
01:26:27 * koz_ still thinks it was named after Idris Elba.
01:26:28 <cocreature> well compared to Coq agda is definitely closer on the programming side
01:26:32 <jared-w> ongy: it has the potential to be closer to programming, but its pedantic and unholy focus on making you write /everything/ out explicitly... makes it more of a theorem proving tool :p
01:26:36 <raichoo> koz_: It's not ;)
01:26:42 <koz_> raichoo: I know, I know.
01:26:44 <raichoo> ^^
01:26:49 <EchoLogic> ongy: I really don't understand what I'm doing well enough to aptly describe it to you
01:26:51 <koz_> It's some singing dragon from some kids' show.
01:27:00 <jared-w> Dragon tales!
01:27:40 <jared-w> That was my jam when I was a kid
01:27:40 <EchoLogic> ongy: essentially I want `dropWhile` to work over an array of tuples
01:27:40 <koz_> jared-w: Am I the wrong age for this?
01:27:40 <jared-w> Rust has the ability to /be/ impure and unsafe, but it's definitely not anywhere in the same league as C/C++ as far as impurity and mutable state goes
01:27:40 <trigone> wait did i fall asleep without realizing? why the dragon metaphors?
01:27:40 <EchoLogic> I got this to work. `dropWhile (\a -> snd a == 'a') [(1, 'a'), (2, 'b')]`
01:27:40 <jared-w> EchoLogic: looks right to me :)
01:27:40 <ongy> that looks about right
01:27:40 <koz_> trigone: The language Idris is named after a singing dragon.
01:27:40 <ongy> what's the current problem?
01:27:41 <EchoLogic> But why is it right
01:27:44 <trigone> koz_: haha didn't know
01:27:49 <jared-w> Think of it this way
01:27:51 <EchoLogic> and I'm not sure if right == correct
01:28:04 <ongy> EchoLogic: that's the (==) from Eq
01:28:08 <jared-w> "for every tuple in the list, take the second item in the tuple and compare it to a and return the result of the comparison (either T or F)"
01:28:17 <ongy> so you get True when the two characters you compare are equal
01:28:42 <jared-w> and "if true, then drop it, otherwise keep the item and exit the function"
01:28:54 <ongy> cocreature: ah, that may be why I thought of it as more programming. isabelle/HOL is the context where I first heard about it :)
01:30:24 <trigone> in haskell monad terminology, what's eta meant to be?
01:30:27 <cocreature> ongy: isabelle/hol or coq don’t even pretend to not be proof assistants :)
01:30:53 <ongy> EchoLogic: just as a note, we don't say array often in Haskell, it's usually lists (or vectors, when using continous memory)
01:31:02 <cocreature> agda is somewhere on the middle and idris is on the programming side of the “proof assistant - programming language” spectrum
01:31:12 <jared-w> trigone: I'm not aware of any eta in Haskell outside of 'eta reduction'
01:31:14 <koz_> trigone: return/pure
01:31:22 <jared-w> oh nvm, what koz_ said :p
01:31:26 <koz_> trigone: mu is join.
01:31:34 <koz_> And T is fmap.
01:31:34 <trigone> koz_: k and T is fmap?
01:31:43 <trigone> k thx :)
01:32:02 <koz_> trigone: You're welcome. I'm busy trying to understand the monad laws in that formulation in Haskell-speak.
01:32:07 <koz_> (because I'll have to present that)
01:32:14 <koz_> On a relevant note: http://www.stephendiehl.com/posts/monads.html
01:32:18 <ongy> cocreature: but it's still possible  to write applications in isabelle. to some extend at least
01:32:54 <trigone> koz_: do you know if the def of eta in http://okmij.org/ftp/Computation/free-monad.html fits the monadic eta or just the subjective idea of a pure-ifying function?
01:32:55 <quchen> »Functor T« in Haskell is the tuple (T, fmap). T maps objects (types) to objects, fmap maps morphisms (functions) to morphisms of Hask.
01:32:56 <cocreature> ongy: I’m not sure I would call program extraction “writing applications _in_ isabelle” tbh
01:33:37 <koz_> trigone: At a glance? I think it's just a pure-ifying function.
01:33:40 <jle`> ongy, EchoLogic: other languages distinguish between arrays and lists too
01:33:52 <koz_> Basically it takes a functor of something and Free-monadifies-it.
01:34:16 <EchoLogic> ongy: yup, I'm just falling into "traditional language" traps :P
01:34:35 <jared-w> It's all good, there'll be a lot of that at the start. It'll happen less often fairly quickly :p
01:35:02 <trigone> koz_: yeah that was my intuition too, thx
01:35:17 <EchoLogic> then I got distracted thinking about how browsers should implement an open source method of being language-agnostic with respect to the DOM.
01:35:18 <koz_> trigone: No worries - Oleg's work has been my commute reading for weeks now.
01:35:25 <EchoLogic> so we don't just use JS all thetime
01:36:16 <trigone> koz_: ^^
01:37:07 <ongy> jle`: sure, but for a lot of languages List isn't the default container type. for better or for worse
01:37:13 <ertes-w> elo
01:37:35 <ongy> cocreature: extraction?
01:37:50 <jared-w> ongy: that's why all of those languages are inferior to lisp ;)
01:38:02 <ongy> s/inferior/superior
01:38:20 <koz_> jared-w: All modern Lisps distinguish arrays and lists.
01:38:20 <jared-w> fite me
01:38:31 <ongy> unless you like your mountain of parens :P (I only know lisp from emacs, and got confused why *so* many parens are required)
01:38:38 <jared-w> koz_: I know, but I couldn't pass up the joke :p
01:38:52 <ongy> wait, they didn't? how was it determined what to use?
01:38:53 <jared-w> ongy: that's because there is no true syntax in lisp and the parens directly represent the AST of lisp
01:39:00 <trigone> ongy: each paren is a prayer. the more you pray the better your program works
01:39:03 <koz_> jared-w beat me to it.
01:39:41 <phadej> ongy: if you remove infix operators from haskell, there will be about the same amount of parens ;)
01:40:08 <ertes-w> phadej: no, haskell will still use less parens
01:40:14 <jared-w> Turns out when a language is homoiconic and has first class macros, you want to be able to very clearly and easily visualize the AST :p
01:40:26 <phadej> ertes-w: but close to
01:40:34 <ertes-w> phadej: not even close
01:40:40 <ertes-w> (let ((x1 y1) (x2 y2)) …)
01:40:46 <ertes-w> let x1 = y1; x2 = y2 in …
01:40:50 <ertes-w> compare for yourself
01:40:59 <phadej> ertes-w: in clojure you have (let x1 x2 x2 y2 expr0
01:41:04 <phadej> ertes-w: in clojure you have (let x1 x2 x2 y2 expr)
01:41:14 <jared-w> clojure is kinda stretching the definition of a lisp though :p
01:41:16 <koz_> Yeah, that second paren set isn't really necessary, since bindings are paired anyway.
01:41:20 <jared-w> :w
01:41:21 <trigone> jared-w: technically, you nearly always write down the code in an indented manner that to me seems virtually isomorphic. one single line for a lisp program is unreadable so
01:41:23 <phadej> or (let (x1 y1 x2 y2) ...)
01:41:27 <phadej> can't remember
01:41:51 <jared-w> trigone: true, but significant indentation/whitespace hadn't become en vogue for PLs yet :p
01:41:57 <ertes-w> phadej: that's fine, but lisps use parentheses for every kind of structuring
01:42:06 <trigone> phadej: i thought it was sth like (let ((x y) (a b))
01:42:07 <koz_> c.f. all the people who cry tears about Python's semantic whitespace.
01:42:15 <koz_> trigone: In Scheme, yes.
01:42:19 <phadej> trigone: nope, clojure doesn't group pairs, scheme does
01:42:22 <koz_> (Common Lisp too I think)
01:42:29 <ertes-w> and that's why even with a very shallow lisp there will still be many more parentheses than in haskell
01:42:32 <jared-w> koz_: python's is fine. Haskell's is a bit fucky to be honest.
01:42:36 <ertes-w> *haskell without infix operators
01:42:57 <EchoLogic> so I'm still a bit confused. I got the `zip` bit working, but I'm getting about 3 different errors, now, none of which I understand... https://www.irccloud.com/pastebin/QKN1ZhcX/
01:43:01 <tdammers> jared-w: haskell's is fine, and somewhat optional; python's is fucked up
01:43:05 <phadej> ertes-w: in your let example you used `;` ;)
01:43:08 <EchoLogic> actually, 5 errors
01:43:10 <trigone> ok
01:43:24 <jle`> EchoLogic: post your errors :D
01:43:28 <ertes-w> phadej: that's because i don't have layout on an IRC line ;)
01:43:31 <jared-w> EchoLogic: Your first couple of errors are related to your case statement :)
01:43:32 <koz_> tdammers: Why do you think so?
01:43:40 <ertes-w> phadej: also ";" is not an operator
01:43:52 <trigone> haskell is fine as long as you don't write the first expression at the level of the keyword. reads much better but then that's a bikeshed debate
01:43:53 <ertes-w> jared-w: python's layout syntax is terrible
01:44:03 <EchoLogic> https://www.irccloud.com/pastebin/KnyDugCh/errors
01:44:13 <phadej> ertes-w: well, without layout you do let { a = 1; b = 2 } in ...
01:44:17 <jared-w> case (expression) of ... means you have a case of a list in your case, not an individual tuple
01:44:32 <phadej> ertes-w: one can argue whether layour or parens (curly or not) is better
01:44:35 <phadej> even in Haskell
01:44:59 <tdammers> koz_: mainly practical experience. Haskell's whitespace rules have only ever bitten me in one way (accidentally lining things up with a layout-introducing keyword), and it's easy to detect and fix
01:45:04 <jared-w> ertes-w: I haven't noticed Python's, honestly. I've had Haskell's bite me in the ass several times, though. Perhaps I'm just unlucky :p
01:45:05 <phadej> but I'll stop trolling :)
01:45:32 <Geekingfrog> I was looking into postgresql-simple, which was looking nice until I realised there is no connection pool support. Is there another lib I can use to provide this feature ?
01:45:36 <ertes-w> phadej: that's not the point…  the point is that in haskell there are many more syntactic forms to choose from than parentheses, and parentheses are only used for grouping, so if the grouping isn't ambiguous you don't need them
01:45:45 <ertes-w> phadej: example:  y = f x
01:46:04 <phadej> ertes-w: wrong. Haskell has overloaded parens, e.g. (1,2)
01:46:08 <ongy> tdammers: I'd say the static typechecks/visibility in haskell make *a lot* of the sanity in whitespace sensitivity
01:46:09 <phadej> so not only for grouping
01:46:24 <phadej> and that kind of tricks beginners too
01:46:26 <phadej> fst (1, 2)
01:46:27 <tdammers> ongy: interesting point, never thought of it that way
01:46:29 <ertes-w> phadej: right…  that doesn't change too much though
01:46:29 <phadej> > fst (1, 2)
01:46:32 <lambdabot>  1
01:46:47 <jared-w> ongy: I'd agree. If I didn't have static typechecking and other things like that, I'd go crazy with figuring out Haskell's whitespacing rules until I had absolutely religiously memorized them :p
01:47:10 <ReinH> Layout is like 3 rules.
01:47:21 <ongy> you barely ever get something ghc accepts as valid, when you mess up your indents. probably never outside of nesting do blocks
01:47:27 <phadej> ertes-w: I personally dislike that () is overloaded (and comma, and dot)
01:47:40 <ReinH> It isn't hard to memorize them. The only reason I haven't is that it's even easier to look them up.
01:47:41 <phadej> ertes-w: in lisp you have only () for making ast nodes
01:47:53 <jared-w> Sure, but 3 rules can show up in far more than 3 different contexts. If nobody ever explictly points out those rules and walks you through them, you're unaware of them until they bite you in the butt
01:48:04 <ertes-w> jared-w: the problem with python's layout is that it's too inflexible…  sure, it's simple, but it will get in your way all the time, if you're used to the flexible layout of haskell
01:48:11 <trigone> phadej: you can make aliases for (,) and (). some prelude alternative seem to do so
01:48:23 <ertes-w> jared-w: try writing a multi-line lambda or a compact 'if/else'
01:48:32 <phadej> trigone: I dislike, but not that much :)
01:48:33 <trigone> phadej: but i'm not sure it works with pattern matchings...
01:48:38 <ReinH> If you are continuously having problems with indentation and you don't look at the indentation rules, I find it hard to feel bad for you.
01:48:46 <phadej> trigone: there is pattern synonyms, so you could...
01:48:52 <phadej> but I won't go there
01:49:06 <trigone> phadej: pattern synonyms?
01:49:09 <ertes-w> phadej: you are free to dislike that, but that's not the point…  you said that haskell without infix operators would have just as many parentheses as a lisp, which is not true
01:49:12 <jared-w> ReinH: No beginner materials out there that I was aware of when I started learning covered or even mentioned any of it
01:49:23 <ReinH> @google haskell indentation
01:49:24 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
01:49:29 <ReinH> It really only requires looking.
01:49:37 <phadej> ertes-w: I was pointing more to (\x -> x) (lambda (x) x) cases
01:49:41 <jared-w> Yeah, yeah, I'm aware of that now, I'm just saying it's not exactly the first thing you start googling when type errors explode in your face
01:49:43 <trigone> the wikibooks article is pretty well written
01:49:46 <phadej> ertes-w: and not whole language, but that's nice that you like to argue!
01:50:04 <ReinH> jared-w: that's a fair point
01:50:15 <ertes-w> phadej: kind of an unfortunate example, because even that one has more parens in the lisp version, and in some contexts even those outer parens will be optional in haskell ;)
01:50:48 <phadej> ertes-w: well you right, happy?
01:50:55 <ertes-w> yeah
01:51:01 <phadej> I said "not significally more"
01:51:23 <ertes-w> now that that argument's won…  how is everybody this fine tuesday? =)
01:51:26 <jared-w> ReinH: the hardest part for me was really, honestly, that no beginner material that I looked at ever went "oh by the way, the layout rules are a little weird in Haskell if you don't know them. Look at 'x' or 'y' resource when you get the chance" -- it's a super small papercut, but it adds up when learning the language and everything's weird and confusing and you're not sure what makes what go wrong :p
01:51:50 <trigone> ertes-w: i bet some people aren't tuesday yet :P but to be fair i'm not sure
01:52:07 <jared-w> Alaska doesn't have tuesday for 8 more minutes
01:52:10 <ReinH> jared-w: I don't disagree. I'm just saying the rules are easy to learn... once you know about them.
01:52:31 <jared-w> Plenty of things are easy once you know about them lol. I do see your point though :)
01:53:00 <koz_> Are unboxed Vectors of Bools represented as bitvectors?
01:53:16 <ReinH> Storables are.
01:53:17 <phadej> jared-w: it's 0:52 in alaska alreaday
01:53:28 <koz_> ReinH: Ah, thanks!
01:53:41 <jared-w> Hmm... is it hawaii I'm thinking of? It's not 2am here yet and one of those two is -2 hours from my time
01:53:55 <phadej> yet, https://time.is/Anywhere_on_Earth
01:54:00 <ReinH> You can mmap a region directly into a Storable.
01:54:01 <ertes-w> … how is everybody this fine UTC+2 tuesday?
01:54:04 <jared-w> ahh, hawaii is the one that's off :)
01:54:18 <ertes-w> koz_: no
01:54:21 <ReinH> This also works for Word8, etc.
01:54:32 <ertes-w> koz_: the 'array' library does that though
01:54:50 <ertes-w> koz_: personally i would just use Vector Word64 and do the bit operations myself
01:54:53 <phadej> "The last place on Earth where any date exists is on Howland Island, "
01:55:06 <koz_> ertes-w: I thought ReinH said Storable Vectors of Bools are bitvectors though?
01:55:19 <koz_> I can do this stuff by hand, but I was just wondering if someone's already done all the hard work for me.
01:55:31 <ertes-w> are they?  i highly doubt that…  let me check
01:55:50 <phadej> unboxed are probably bitvectors, not storable
01:57:07 <trigone> what's a *definitional* interpreter? vs a non-def one?
01:57:24 <mac10688> Can anyone tell me if haskell could make for a good game server for an mmorpg?
01:57:44 <koz_> mac10688: Could? Probably - it has really good concurrency.
01:57:51 <phadej> unboxed vector of bools seems to be Word8 though, but that code is tricky
01:58:05 <jared-w> trigone: a def one uses sign language, a non-def one uses a verbal language :p
01:58:10 <koz_> phadej: So each entry is Word8? Or is it 8 Bools to a Word8?
01:58:18 <phadej> koz_: one entry is Word8
01:58:23 <trigone> jared-w: er... what?
01:58:27 <koz_> phadej: Ah, so eight times larger than what I want.
01:58:32 <mac10688> koz_, but what about memory? A server will need to hold the state of everyone's position and such.
01:58:32 <trigone> jared-w: haha got it tss
01:58:38 <koz_> trigone: Read the examples Oleg gives.
01:58:46 <koz_> mac10688: That's just a data structure issue.
01:59:01 <koz_> If you need better memory use, it's a problem of 'use better data structures', not 'use a different language'.
01:59:02 <jle`> the only thing about haskell the language is probably that it's a garbage collected language
01:59:08 <jle`> so you'll have GC pauses
01:59:21 <ertes-w> koz_: i can't confirm that storable Bool vectors are compact
01:59:24 <trigone> jared-w: some deaf people use verbal language (assumingly they send it, don't receive it, though they may read lips)
01:59:26 <koz_> jle`: Does Haskell use an actual GC? I thought they just refcount.
01:59:54 <pacak> koz_: generational compacting GC
02:00:02 <koz_> pacak: My dreams are ruined. :P
02:00:08 <jle`> i guess i should say GHC, not haskell
02:00:11 <jared-w> trigone: I'm aware :p most don't, especially in America (I'm mostly deaf myself)
02:00:12 <mac10688> koz_, thanks jle` . That's what I was just reading about tonight. How the gc has big pauses. So if I have a lot of memory in use, the gc pausing the server would be a deal breaker right?
02:00:17 <jle`> but it'd be pretty hard to implement haskell without GC
02:00:17 <Nanjizal> Is haskell used for graphics much?  
02:00:28 <jle`> mac10688: it's not necessarily a huge pause
02:00:31 <koz_> mac10688: I would say 'profile and see'.
02:00:37 <trigone> jared-w: really? why the american specificity?
02:00:42 <koz_> Too many other factors.
02:00:44 <jared-w> mac10688: not necessairly; it depends on what you're doing with it. You might not notice the pauses at all. It also depends a lot on what you're writing
02:00:47 <ertes-w> ReinH, koz_: in fact storable Bool vectors being compact makes the least sense to me…  i would be very surprised if those had turned out to be compact
02:01:03 <ertes-w> even unboxed ones, where it's possible in principle, are not compact
02:01:10 <jle`> mac10688: the issue depends on scale, too ... if your game server has maybe like ~1000 concurrent users, i don't think it'd make a big difference
02:01:24 <jle`> it also depends on what the server is communicating to the clients
02:01:35 <mac10688> jle`, I would want to shoot for like 3000-10,000
02:01:45 <jared-w> trigone: America has a very strong ASL presence. Other countries have their own sign languages, but America also has a particularly strong and prevalent deaf community as well, which makes it more likely that its deaf citizens will speak a sign language, rather than a verbal language (although this is quickly changing to become more equal around the globe) -- this is off topic though
02:01:55 <ReinH> Hmm. The instance definition for Storable Bool is confusing.
02:02:01 <trigone> jared-w: hm i get it
02:02:02 <koz_> ReinH: This is why I asked.
02:02:05 <mac10688> jle`, and maybe it just calculates if the players actions are legal and then returns data based on that
02:02:11 <ReinH> But I guess they aren't compact. 
02:02:12 <ReinH> w
02:02:18 <mac10688> jle`, i've never written a game server but I imagine it would do something like that
02:02:20 <ReinH> Word* are compact.
02:02:28 <trigone> jared-w: equal as in most deaf people everywhere only using sign languages, or the opposite?
02:02:30 <ertes-w> ReinH: they couldn't be, because Storable only has byte granularity
02:02:39 <ReinH> and Int*
02:02:43 <ReinH> ertes-w: ah, right
02:02:52 <ReinH> My bad.
02:03:03 <jared-w> trigone: as in more deaf people everywhere are learning sign languages. The internet has been the best thing that has ever happened to the Deaf world. A purely visual way to connect the world together helped a lot in spreading sign languages :)
02:03:09 <jared-w> (especially with YouTube)
02:03:40 <trigone> jared-w: i admit :) learning sign language from books mustn't be that easy... but doable i *guess*
02:03:55 <ReinH> What is HTYPE_INT?
02:04:21 <jle`> mac10688: look up some difference between hard realtime and soft realtime
02:04:57 <jared-w> It's really not. Most of the nuance of sign language is actually conveyed through facial expressions and the character of how you sign, rather than the sign itself. It's like how written text is terrible for conveying tone of voice or for carrying nuanced conversations in. Sign language needs to be learned in a visual medium just as hearing languages need to be learned in an auditory one
02:04:58 <jle`> mac10688: actually, maybe GC pauses might be insignificant compared to network latencny
02:05:37 <mac10688> jle`, to test it could be expensive. I'm basically talking about load testing right?
02:05:58 <jle`> mhm
02:06:01 <mac10688> jle`, I would need about 50 or so computers to ping my server and log the time it takes to process all the results right?
02:06:19 <jle`> not just ping, but play the game
02:06:52 <ertes-w> mac10688: i suggest that you write a small toy game, perhaps a telnet game or something like that
02:07:02 <ertes-w> mac10688: make sure it has a lot of state
02:07:43 <ReinH> There are scaling issues that only occur in MMO games, though, so you'll want to simulate them too.
02:07:50 <boj> mac10688: i've written a realtime fps in haskell that handled ~16 players. it's possible, and performant, but not remotely easy
02:08:13 <ReinH> This is why, e.g., you can drop items in Diablo 3 but not in World of Warcraft.
02:08:41 <ReinH> But those issues will be the same no matter what language you use.
02:08:48 <jle`> also throw in the fact that making an mmo is probably one of the single most complex and difficult things in programming/software engineering
02:09:04 <jle`> and they are usually written by entire departments, not individuals
02:09:26 <koz_> And even they get it wrong quite often.
02:09:29 <Nanjizal> Just downloading Stack as there is a meetup locally exploring haskell, not a haskell coder, I am visually focused so I am wondering about haskell and graphics - can you use stack to make visual stuff?
02:09:37 <koz_> Nanjizal: You can.
02:09:41 <koz_> There's a bunch of things.
02:09:46 <ertes-w> the scaling issues are related, but of a different nature (in that they occur to a similar degree in every language)
02:09:47 <mac10688> right, I'm just trying to think of the simplest way I can test it
02:09:49 <koz_> Depends on what you mean by 'visual stuff'.
02:10:02 <jle`> Nanjizal: yeah, graphics libraries are pretty mature in the haskell ecosystem
02:10:39 <Nanjizal> I am used to Haxe, so stuff like Kha, WebGL, flash, canvas 
02:10:57 <mac10688> I just want to see if I can write a small haskell server that handles state and see how it compares to an elixir program. I always hear about how great elixir is as a web programming language. I've been consumed thinking about this the past few hours. I can't get it out of my head
02:11:30 <jared-w> elixir and erlang are basically made from the ground up for this sort of thing. I wouldn't be surprised if your initial results are discouraging in that regard
02:12:07 <ReinH> You will mostly be testing your ability to write performant Haskell rather than Haskell's capabilities per se.
02:12:24 <ReinH> or GHC's capabilities, rather.
02:12:38 <koz_> Or just calling into C all the time.
02:13:03 <tdammers> also, raw application code performance is rarely the bottleneck for web application performance
02:13:11 <ertes-w> mac10688: FWIW i would most likely do it in haskell
02:13:35 <ertes-w> even if it means that i need some tweaking
02:13:48 <ertes-w> also GHC 8.2 introduced compact regions, which should help with this
02:13:55 <Nanjizal> so in haxe I have been experimenting with drawing -> triangles and then rendering them with webgl or with kha and any gl.  If you want to make a quick haskell app with mouse keyboard some vector and image on screen where would be the best place to look in the haskell ecosystem and with this stacks thing, I am on a mac if it matters?
02:14:04 <ertes-w> (not introduced, but finished)
02:14:07 <tdammers> in the classic case, I'd reckon more than 90% of time is spent waiting for the network, filesystem, and database
02:14:15 <mac10688> ertes-w, I just read a simon marlow post from a year ago saying he was hoping he could introduce that in ghc 8.2
02:14:23 <tdammers> and the remaining 10% often overlap with that, too
02:14:31 <ertes-w> mac10688: it has happened =)
02:14:42 <tdammers> so if you speed up your application code by, say, 50%, your real perceived gain may only be on the order of 1% or so
02:14:51 <mac10688> tdammers, I think with a game server there won't be as much filesystem and database touching. Mostly just in memory and network
02:14:52 <ReinH> tdammers: If we're talking about an MMO server, what's going on between the client and server will be very far removed from what pixels to draw on the screen.
02:15:05 <koz_> Nanjizal: For drawing stuff, this is pretty sweet: https://hackage.haskell.org/package/gloss
02:16:05 * hackagebot protolude 0.2 – A small prelude. – https://hackage.haskell.org/package/protolude
02:17:34 <ertes-w> mac10688: apparently we're also getting linear types "soon"…  this is going to be a type safety at first, but i would expect it to turn into an optimisation (for in-place update) as well
02:17:48 <mac10688> https://www.quora.com/Is-Haskell-feasible-for-implementing-a-game-server-Which-framework-may-I-use
02:17:59 <mac10688> that was the best most recent answer I could find on quora
02:18:13 <ertes-w> mac10688: in other words, even if haskell is not entirely suitable at this point, very soon it will be =)
02:18:34 <ertes-w> so personally i would pay the upfront price
02:18:36 <jle`> haskell would be my choice if i ever decided some day to write an multiplayer online game by myself
02:19:03 <tdammers> I was thinking more in terms of http servers
02:19:15 <AndreasK> Afaik turning linear types into in places updated would require some major work
02:19:40 <Nanjizal> thanks koz_ the github seems to have good readme, stack is still downloading stuff 
02:19:41 <tdammers> but even for a game server, I believe network overhead is significant, and parallelizing the problem is the ultimate strategy to make it perform and scale
02:20:21 <koz_> Nanjizal: No worries - hope you like it!
02:20:22 <ertes-w> parallel code in haskell gives me nose bleeds
02:20:27 <mac10688> tdammers, what exactly would a game server need to parallelize? Each request?
02:20:38 <ertes-w> (in the good sense)
02:20:53 <mac10688> lol i didn't know there were good nose bleeds
02:20:57 <ertes-w> mac10688: calculations
02:21:06 <jared-w> mac10688: you haven't seen enough anime yet :p
02:21:10 <mac10688> like if a player position is legal?
02:21:27 <ongy> tdammers: lag reduction and all those prediction stuff exists for a reason...
02:21:33 <mac10688> I'm not a game developer either lol. I don't think about game servers much, so I'm kind of a newbie on both fronts
02:22:22 <trigone> btw, with jared-w's joke i forgot about my question! :P what's a definitional interpreter by contrast with one which isn't?
02:22:35 <tdammers> mac10688: for a massively multiplayer game, you will need to be able to serve multiple players in parallel
02:22:37 <ertes-w> mac10688: feel free to join our quiet little hideout, #haskell-game =)
02:22:47 <koz_> trigone: Have you looked at Oleg's example?
02:22:51 <koz_> It'll explain it pretty well.
02:23:00 <trigone> koz_: oh, right i forgot your answer, sorry ^^ nevermind then
02:25:49 <ReinH> mac10688: here are some things you should probably read: https://gafferongames.com/
02:26:51 <mac10688> thanks ReinH !
02:27:14 <ReinH> Starting with http://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/
02:27:15 <mac10688> Are you guys able to keep IRC running while you sleep?
02:27:23 <mac10688> Do you just keep your computer running?
02:27:30 <ReinH> I use irccloud.
02:27:33 <koz_> I use a bouncer on a BPi.
02:27:45 <ReinH> This message has been brought to you by irccloud.
02:27:50 <ReinH> Literally.
02:28:13 <mac10688> This is cool ReinH . I'm gonna try to set this up now
02:28:50 <trigone> can (>>>) be used as synonym to (>=>) in some monomorphic circumstances? i'm lost on some thingy
02:29:11 <pacak> :t (>>>)
02:29:13 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
02:29:18 <pacak> :t (>=>)
02:29:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:29:31 <pacak> :t (>>>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:29:33 <lambdabot> error:
02:29:33 <lambdabot>     • Couldn't match type ‘b1’ with ‘m1 b1’
02:29:33 <lambdabot>       ‘b1’ is a rigid type variable bound by
02:29:51 <pacak> Hmm...
02:30:09 <trigone> pacak: i know there much be some correspondance when using Kleisli arrows (the Kleisli instance of arrows) but without newtype wrapping it's not possible is it?
02:30:45 <trigone> > 3 & (\x -> Nothing) >>> (\y -> Just y)
02:30:48 <lambdabot>  error:
02:30:48 <lambdabot>      Precedence parsing error
02:30:48 <lambdabot>          cannot mix ‘&’ [infixl 1] and ‘>>>’ [infixr 1] in the same infix exp...
02:30:49 <lyxia> You need to do unwrapping
02:30:57 <trigone> > ( (\x -> Nothing) >>> (\y -> Just y) ) 3
02:30:59 <lambdabot>  Just Nothing
02:31:14 <pacak> :t (>>>) :: Monad m => Kleisli  m a b -> Kleisli  m b c->  Kleisli m a c
02:31:15 <lambdabot> Monad m => Kleisli m a b -> Kleisli m b c -> Kleisli m a c
02:31:35 <trigone> oh hm, without wrapping, it takes the (->) instance of Category...
02:31:44 <ReinH> Yes.
02:33:28 <trigone> it's in some def of FFree (the Freer monad), FImpure u k' >>= k = FImpure u (k' >>> k)   -- with (k :: x -> FFree g a), and k', assumingly, having a similar signature (unless i mixed everything up), so to me k and k' looked like kleisli arrows (without the wrapping)
02:34:24 <trigone> http://okmij.org/ftp/Computation/free-monad.html
02:34:35 <trigone> oooooh
02:34:52 <trigone>  nevermind, i should have continued. (>>>) was not Category.>>>
02:35:13 <trigone> it was precisely the unwrapped equivalent of the instance of (>>>) for kleisli arrows
02:36:11 <trigone> aka it was (>=>). i don't really get why not using that operator but well
02:40:45 * hackagebot hjugement 1.0.0.20170808 – Majority Judgment. – https://hackage.haskell.org/package/hjugement
02:44:59 <trigone> well i just read http://okmij.org/ftp/Computation/free-monad.html -- seems even cooler than the Free monad. coming back to the discussion of before, how big of a perf hit must be expected though (between Freer and Free)?
02:45:24 <koz_> trigone: As per Edward's earlier statements - it depends on what ops you need to be fast.
02:45:32 <koz_> There are several choices, all with their own tradeoffs.
02:45:46 <trigone> koz_: k... well i'll see that along the way then
02:46:00 <koz_> For now, I'd try the 'obvious' way and see if that kills you too much.
02:46:00 <trigone> unless you got a good 
02:46:30 <trigone> *a good "map" of the usage x tradeoff
02:46:42 <koz_> Not me, but Edward would.
02:46:46 <koz_> You could also email Oleg.
02:47:49 <trigone> yeah... nah i'll learn it sooner or later. it's not really that urgent for pragmatic usage
02:47:55 <trigone> (for me for now)
02:48:17 <koz_> They are pretty awesome.
02:48:49 <trigone> koz_: yeah but i doubt i'd get half of their answers. i still gotta read more general stuff on the free world first
02:49:08 <trigone> (i doubt i'd understand half of each of their answers)
02:50:03 <koz_> trigone: You'd be surprised. It just takes time and thinking.
02:53:08 <mivael> @pl let f 7 = True; f _ = False in f
02:53:08 <lambdabot> const False
02:53:27 <mivael> "const False"?  Really?
02:53:59 <trigone> :t let f 7 = True; f _ = False in f
02:54:00 <barrucadu> I wonder how lambdabot's Show instance for that is defined
02:54:01 <lambdabot> (Eq a, Num a) => a -> Bool
02:54:21 <barrucadu> Oh, I misread, that's pl, not showing
02:54:31 <trigone> that's kinda weird...
02:54:38 <koz_> Wait, how is that 'const False'?
02:54:45 <jle`> it's probably a @pl bug
02:54:46 <barrucadu> Does pl cope with functions with multiple clauses?
02:54:50 <ertes-w> mivael: well, there are infinitely many possible arguments, and infinitely many of the will yield False
02:54:50 <trigone> @pl let f 7 = True; f _ = False in f 7
02:54:50 <lambdabot> False
02:54:59 <trigone> indeed there's something fishy
02:55:07 <ertes-w> mivael: so it must be (const False)
02:55:07 <trigone> > let f 7 = True; f _ = False in f 7
02:55:09 <lambdabot>  True
02:55:36 <trigone> ertes-w: nah, it's just infinitely improbable that it be true. no need to be that pessimistic
02:55:37 <mivael> :t let f 7 = True; f _ = False in f
02:55:37 <jle`> i mean, if f :: Double -> Bool, it might as well be const False
02:55:38 <lambdabot> (Eq a, Num a) => a -> Bool
02:55:40 <cocreature> @pl let f x = case x of 7 -> True; _ -> False; in f
02:55:40 <lambdabot> (line 1, column 25):
02:55:40 <lambdabot> unexpected '>'
02:55:40 <lambdabot> expecting operator
02:55:48 <ertes-w> trigone: stop destroying the universe!
02:56:17 <koz_> I preferred it when @pl was just flipping people off.
02:56:38 <trigone> ertes-w: but if you vote for me to rewrite the universe, i'll make candies replace apples :P and haskell replace java, yay!
02:57:26 <mivael> ertes-w, sounds reasonable but "const False" is not the same function as "f", is it?
02:58:06 <trigone> mivael: no it's a bug. pl is not really meant to handle pattern matching (i think)
02:58:10 <koz_> :t (.) . (.)
02:58:11 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
02:58:51 <trigone> @pl let f () = 3; f _ = 4 in f
02:58:51 <lambdabot> (line 1, column 9):
02:58:51 <lambdabot> unexpected " "
02:58:51 <lambdabot> expecting pattern or "="
02:59:16 <trigone> @pl let {f () = 3; f _ = 4 }in f
02:59:16 <lambdabot> (line 1, column 5):
02:59:16 <lambdabot> unexpected "{"
02:59:16 <lambdabot> expecting "()", natural, identifier or "in"
03:00:10 <trigone> @pl (\x -> case x of () -> 3; _ -> 4)
03:00:10 <lambdabot> (line 1, column 20):
03:00:10 <lambdabot> unexpected " "
03:00:10 <lambdabot> expecting variable, "(", operator or ")"
03:00:15 <cocreature> trigone: well then the bug is that it accepts definitions containing pattern matches ;)
03:00:28 <hrehf> Can I retrieve the source position for every token from parsec?
03:00:35 <trigone> cocreature: yeah, well it doesn't even seem to accept all pattern matches
03:02:44 <Nanjizal> Sorry very basic question, when using goss the readme says ... stack exec gloss-boids   but do I need to install goss somehow?  Or is it just assuming I have cloned ( recursively ? ) the github ?
03:03:25 <koz_> Nanjizal: I think it'll pull it in as a dependency.
03:04:01 <jle`> it depends on what's in gloss-boids
03:04:27 <mivael> @pl let f n | n == 7 = True | otherwise = False in f
03:04:27 <lambdabot> (line 1, column 9):
03:04:27 <lambdabot> unexpected "|"
03:04:27 <lambdabot> expecting pattern or "="
03:04:30 <jle`> but you can stack exec with specific dependencies, too, stack exec --package gloss gloss-boids
03:04:33 <Nanjizal> gloss-boids is in the example folder?
03:04:48 <jle`> what are you looking at, exactly?
03:05:28 <Nanjizal> oo that line might be the right magic :)  seems the readme needs adjusting.
03:05:55 <Nanjizal> still doing it's thing....  8/14
03:06:05 <jle`> oh, do you mean https://github.com/benl23x5/gloss
03:06:37 <jle`> i think you should just be able to do `stack exec gloss-boids`; if not, try 'stack install' instead of 'stack build'
03:07:04 <Nanjizal> there is a meetup on haskell this evening so thought I would take a look and visual always focuses my interest
03:07:11 <jle`> i'm not even sure what gloss-boids is
03:07:42 <Nanjizal> probably some 'boid' type thing bouning circles or something not looked at source yet
03:09:00 <Nanjizal> https://github.com/benl23x5/gloss/blob/master/gloss-examples/picture/Boids/Main.hs   waits to see ...
03:09:51 <Nanjizal> mmm ok still complaining about the paths
03:11:08 <Nanjizal> Executable named gloss-boids not found on path: ["/projects/haskell/my-project/.stack-work/install/x86_64-osx/lts-9.0/8.0.2/bin","/Users/***/.stack/snapshots/x86_64-osx/lts-9.0/8.0.2/bin","/Users/***/.stack/programs/x86_64-osx/ghc-8.0.2/bin","/usr/local/bin","/usr/bin","/bin","/usr/sbin","/sbin","/opt/X11/bin"]
03:13:47 <cocreature> Nanjizal: have you run "stack build" before?
03:14:27 <Nanjizal> stack build yes
03:15:06 <Nanjizal> So I followed the stack instructions
03:15:11 <Nanjizal> stack new my-project
03:15:12 <Nanjizal> cd my-project
03:15:14 <Nanjizal> stack setup
03:15:15 <Nanjizal> stack build
03:15:17 <Nanjizal> stack exec my-project-exe
03:15:38 <cocreature> so you are not trying to build gloss after all?
03:15:44 <cocreature> those instructions are for creating your own project
03:16:29 <Nanjizal> ok so if I cd up a level what would I need to do to run boid 
03:17:06 <cocreature> if you want to build and run the gloss examples. clone the repo, cd into that repo, run "stack build" and then "stack exec gloss-boids"
03:17:43 <Nanjizal> that is what I asked if I should do earlier, will try that :)
03:20:59 <Nanjizal> ok it's downloading a different version of ghc I think... off to get milk as this took awhile last time
03:31:39 <ertes-w> mivael: i was just kidding
03:34:30 * hackagebot megaparsec 6.1.0 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
03:34:32 <mivael> ertes-w, I hoped so  :)
03:44:06 <jle`> huh ghc ran out of memory
03:44:10 <jle`> that happened i guess
03:44:20 <batterynurse> Hi all. I'm relatively new to Haskell and just wrote my first small application (~30 lines) involving IO - would anyone mind giving me a bit of feedback on it?
03:44:45 <sphinxo> How can I make a optparse applicative parser for sometype A, where I have my own  function along the lines of String -> Bool, or String -> Either Error String
03:44:59 <sphinxo> sorry the last type was mean't to be String -> Either Error A
03:45:27 <jle`> batterynurse: just post it :)
03:45:33 <jle`> *paste
03:45:38 <jle`> @where lpaste
03:45:38 <lambdabot> http://lpaste.net/
03:46:12 <jle`> sphinxo: do you mean having A as an argument/option?
03:46:29 <sphinxo> yes
03:46:56 <jle`> you can use 'option' to make an option
03:47:02 <jle`> for an arbitrary type
03:47:13 <jle`> and 'argument' to make a positional argument
03:47:20 <batterynurse> jle`: http://lpaste.net/357517
03:47:22 <jle`> both of them expect a readM
03:47:30 <jle`> to parse the string/argument/option
03:47:43 <jle`> you can use `eitherReader :: (String -> Either String a) -> ReadM a` to make one
03:54:54 <ongy> batterynurse: the nested where looks a bit odd (and you are breaking your indention style for it) otherwise I think it looks fine.
03:55:29 <batterynurse> I did think the nested where was a bit iffy... how else could I structure it?
03:56:34 <ongy> I'd inline both of those. but I think that's mainly personal preference
03:57:55 <sphinxo> How can I turn a maybe into an either nicely, supplying a value for the left
03:58:28 <sphinxo> so Just a becomes Right a, and Nothing becomes Left <some_hardcoded_value>
03:58:39 <srhb> :t maybe
03:58:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:58:54 <srhb> :t maybe (Left "Oh noes") Right
03:58:55 <lambdabot> Maybe b -> Either [Char] b
03:59:07 <srhb> sphinxo: ^
04:02:54 * hackagebot qchas 1.0.1.0 – A library for implementing Quantum Algorithms – https://hackage.haskell.org/package/qchas
04:33:20 <hc> hi, i'm looking for a formal definition of the term "first class citizen", could you point me to some definition of the term? :)
04:34:16 <oherrala> hc: did you try scholar.google.com already?
04:35:16 <hc> not yet, but a brief search there showed only papers using the term, not defining it
04:35:17 <ertes-w> hc: "value"
04:38:49 <Nanjizal> Just going through running the gloss examples, I can't seem to escape mandel I have got terminal back but the window remains open it does not respond to 'esc' and the corner close on all examples is not enabled.
04:39:40 <oherrala> hc: SICP has this in footnote: "The notion of first-class status of programming-language elements is due to the British computer scientist Christopher Strachey (1916-1975)."
04:39:44 <Nanjizal> ok can close it from task bar but it should have an esc key right?
04:39:48 <oherrala> hc: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#footnote_Temp_121
04:40:37 <hc> thank you! :)
04:40:51 <oherrala> hc: also the text itself has more definition
04:41:08 <oherrala> hc: "In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the ``rights and privileges'' of first-class elements are:" etc
04:43:25 <hc> thanks, appreciate it!
04:44:07 <oherrala> np :)
04:46:01 <oherrala> hc: I looked Wikipedia's first class citizen page and went through the References section. That's probably the way I found most of the references for my thesis :D
04:47:32 * hackagebot rset 1.0.0 – Range set – https://hackage.haskell.org/package/rset
04:59:26 <jcjf> In functional programming in say Haskell, why do we use the classical True/False (Boolean algebra) and not intuitionistic True/False (Heyting algebra)
04:59:50 <lyxia> what's the difference
05:00:30 <jcjf> My understanding is that intuitionistic negation mean "proves a contradiction"
05:00:37 <quchen> True and False are both values of type Bool; they do not represent truth and falsehood.
05:00:54 <quchen> »Inhabited and not inhabited« is what corresponds to logical truth/falsity.
05:01:10 <quchen> Void is logically uninhabited (has no values).
05:01:20 <quchen> Void is our »falsity«.
05:01:50 <quchen> Our »truthness« is whether a type has any values.
05:01:50 <phadej> falsehood
05:02:00 <quchen> Int is true, because »1« for example.
05:02:02 <jcjf> So Bool is just some special sum type of two units with a special function called not?
05:02:14 <quchen> Yeah.
05:02:31 <ertes-w> jcjf: in FP ideally you don't use booleans at all…  you cover cases by construction
05:02:38 <jcjf> That seems to sit with me a bit better
05:03:04 <quchen> There’s nothing special about Bool, it’s defined in the standard library (and not as a compiler directive), have a look at GHC.Bool (or Data.Bool?) – there’s literally a »data Bool = True | False« in there
05:03:32 <jcjf> But we connect to the notion of if-else which is a law of excluded middle sort of thing, right?
05:03:41 <jcjf> I mean we have a syntactic construct for it
05:04:00 <quchen> There it is: https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Types.html#t:Bool
05:04:45 <ertes-w> jcjf: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
05:04:47 <quchen> No, the law of excluded middle is that any type is either inhabited or uninhabited.
05:05:26 <quchen> The law that »for all Booleans b, b or not b« holds even in constructive logic.
05:05:48 <ertes-w> jcjf: if/then/else is a computation…  it has nothing to do with truth or falsity
05:06:16 <ertes-w> jcjf: at best it implements a decision procedure for a logical statement
05:06:37 <ertes-w> but by itself it's completely oblivious to that statement
05:07:20 <quchen> if/then/else is a proof for »∀ a. Bool => a => a => a« from a logical standpoint
05:07:49 <quchen> It’s not a very good proof, because »f _ _ x = x« is much simpler than ifThenElse, and also proves the proposition.
05:07:52 <LinArcX> Hi friends. I want to developer.android.com a gui desktop application with haskell. Is there any native gui to achieve this goal? I don't want use something like "Gtk2hs" or "hsqml". Is there any pure framework or library?
05:08:29 <LinArcX> Sorry. *Develope a desktop.
05:08:48 <hpc> the keys are right next to each other ;)
05:08:52 <jcjf> Ah, so it's a valid proof because Bool is inhabited and `a` is also inhabited
05:09:11 <ertes-w> jcjf: no, because you're concluding 'a' from the assumption 'a'
05:09:16 <ertes-w> :t id
05:09:17 <lambdabot> a -> a
05:09:25 <ertes-w> the Bool is completely irrelvant
05:09:40 <quchen> :t id :: Void -> Void
05:09:42 <lambdabot> Void -> Void
05:09:42 <ertes-w> it's another assumption, but you can ignore it
05:09:45 <lambdaGrp> LinArcX: for simple stuff, there is libui: https://github.com/beijaflor-io/haskell-libui
05:10:28 <hpc> LinArcX: what makes gtk unsuitable for you?
05:10:43 <quchen> »Assuming Bool exists, and assuming a exists, and assuming a exists, it can be proven that a exists«
05:10:49 <ertes-w> jcjf: a true assumption does not yield a true conclusion, but if you assume the conclusion, then the conclusion is trivially true (because you assumed it to be true)
05:11:22 <LinArcX> I don't want to depend on c, c++ or any other library from imperative languages.
05:11:27 <ertes-w> jcjf: in other words: "for every proposition A, given that A is true, A is true"
05:11:35 <ertes-w> :t id
05:11:36 <lambdabot> a -> a
05:11:50 <jcjf> Right, so it's better to think of Bool as a type with two inhabitants
05:12:03 <ertes-w> yes
05:12:19 <quchen> Bool is not any different from the FooBar type that has two values, Foo and Bar.
05:12:20 <ertes-w> jcjf: think of it as Word1
05:12:21 <jcjf> With no connection to truth/falsehood, but a confusingly suggestive notion due to its value constructors
05:12:35 <ertes-w> jcjf: yeah
05:12:58 <jcjf> Thanks folks, you helped so much
05:13:11 <quchen> Well, Bool is a type all programmers know and understand.
05:13:15 <ertes-w> jcjf: read the article i linked about boolean blindness
05:13:17 <quchen> 1 < 2 gives you a bool.
05:13:17 <jcjf> You wouldn't believe how many circles I ran in my head
05:14:00 <LinArcX> hpc: why there is no native gui framework for haskell? Is it a technical issue?
05:14:02 <quchen> We could have defined the type »2« with two values »mouse« and »helium«, but that would hardly help understandability of the language.
05:14:32 <quchen> And on a computational level, Bool = True | False is fairly useful, it’s the »arbitrary default« for a type with two values.
05:14:54 <mauke> LinArcX: you can't escape libc or the OS
05:15:00 <quchen> We frequently define our own types with two values though – because those can have better names, and cannot be mixed up with other types of two values.
05:15:17 <quchen> data FileStatus = Open | Closed
05:15:20 <quchen> …for example
05:15:33 <ertes-w> and most of them are problematic
05:15:57 <LinArcX> mauke :why? Can you you explain more?
05:16:01 <ertes-w> FileStatus is an awful type, probably more awful than Bool
05:16:01 <barrucadu> Problematic?
05:16:24 <quchen> data IsErtes = Ertes | NotErtes
05:16:32 <ertes-w> well, say you want to write to the file…  you need to check whether it's currently open, right?
05:16:38 <quchen> data ExampleQuality = Good | Bad
05:16:51 <mauke> LinArcX: well, are you going to write your own operating system from scratch?
05:16:55 <jcjf> quchen: I found "the judgement that p is true is not the same as saying p is equal to true" very helpful
05:17:11 <jcjf> I never made that mental distinction before
05:17:12 <barrucadu> ertes-w: yes
05:17:23 <opqdonut> ertes-w: you mean it's prone to race conditions?
05:17:35 <ertes-w> no, it's prone to boolean blindness
05:17:36 <mauke> data Boolean = True | False | FileNotFound
05:17:43 <jcjf> I've read some of Bob's stuff before, but this is great
05:17:51 <quchen> Well, it’s a new way to introduce Boolean Blindness :>
05:18:00 <ertes-w> if null xs then … else … head xs …  -- why is this bad?
05:18:05 <Iceland_jack> Boolean Blindness 2.0
05:18:10 <opqdonut> ertes-w: how is it more prone to blindness than Bool?
05:18:50 <opqdonut> ertes-w: and what would be your favourite way of implementing this?
05:18:56 <ertes-w> opqdonut: because the name suggests that it's *always* used to introduce a boolean-blind context
05:19:01 <LinArcX> muake : yes. You mean this issue will remain forever? We must use wrapper libraries because we don't have any declrative OS?
05:19:09 <hpc> ertes-w: what happens if you put (head xs) in the wrong branch?
05:19:13 <ertes-w> opqdonut: data File = Open Handle | Closed
05:19:24 <ertes-w> hpc: exactly
05:19:25 <opqdonut> ertes-w: right
05:19:38 <hpc> oh whoops, you were making an example
05:19:40 <mauke> LinArcX: ?
05:19:50 <ertes-w> hpc: yeah
05:20:51 <barrucadu> Being open or closed is a property of the handle, so that File type is misleading (unless there is no "close" function and the handle is closed by the garbage collector)
05:21:28 <opqdonut> ertes-w: how about "data HandleStatus = Open Handle | Closed; handleStatus :: Handle -> HandleStatus"?
05:21:43 <opqdonut> ertes-w: I mean if we're stuck with the Prelude Handle type and its semantics
05:22:06 <ertes-w> check 'null', then conditionally use 'head': that's a classic example of boolean blindness: the code i wrote above is correct, but its correctness is not by construction, but rather by me, the programmer, not having made a mistake…  it reduces the information the 'else' branch needs to a single bit, and then it needs to use the uninformed 'head' function, which performs another reduction and crashes if it fails
05:23:00 <ertes-w> fix: use pattern-matching on the list
05:23:15 <ertes-w> (or any of the proper list reduction functions like 'foldr')
05:23:18 <Iceland_jack> Or NonEmpty
05:24:01 <lambdaGrp> oh thanks! I might need to fix something now..
05:24:35 <lambdaGrp> it's good to hang around here :)
05:24:43 <jcjf> I was quite fond of pattern matching before, but I'm sold now!
05:24:53 <jcjf> Deconstruct the same way you construct!
05:25:31 <mniip> naw
05:25:35 <mniip> that would be induction
05:26:14 <jcjf> Induction on a sum type is essentially a case analysis, right?
05:26:27 <opqdonut> yes
05:26:44 <opqdonut> or rather, case analysis is induction on a sum type :)
05:26:49 <jcjf> Awesome, that probably means I'm starting to learn the terminology correctly
05:27:18 <quchen> :t bool
05:27:20 <lambdabot> a -> a -> Bool -> a
05:27:26 <quchen> There’s your induction on Bool :-)
05:27:45 <opqdonut> aka if-then-else
05:27:49 <barrucadu> `bool` has one of my least favourite type signatures
05:28:10 <barrucadu> I can never remember which way around the arguments are
05:28:15 <quchen> Nooo I didn’t mean to start a bikeshed war about bool’s argument order
05:28:19 <barrucadu> heh
05:28:24 <ertes-w> barrucadu: mnemonic: Enum =)
05:28:30 <ertes-w> > [False ..]
05:28:32 <lambdabot>  [False,True]
05:28:50 <ertes-w> but yes, i understand your point, and i agree =)
05:29:04 <opqdonut> it mirrors maybe and either, and is nicer to partially apply in that order
05:29:06 <opqdonut> :t maybe
05:29:07 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:29:08 <opqdonut> :t either
05:29:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:29:19 <opqdonut> see also
05:29:23 <opqdonut> :t foldr
05:29:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:29:56 <ertes-w> it's like if/then/else, but reversed in all aspects =)
05:32:02 <quchen> maybe and either are also terrible functions
05:32:21 <quchen> Very rarely lead they to good code
05:32:31 <ertes-w> quchen: i use them all the time
05:32:47 <ertes-w> (>>= maybe (throwIO …) pure)
05:33:08 <ertes-w> maybe 0 id
05:33:09 <ertes-w> etc.
05:33:32 <quchen> flatten_ (Cat x y) = maybe (maybe Nothing (Just . Cat x) $ flatten_ y)
05:33:32 <quchen>                            (\x' -> maybe (Just $ Cat x' y) (Just . Cat x') $ flatten_ y)
05:33:32 <quchen>                          $ flatten_ x
05:33:40 <opqdonut> :D
05:34:23 <Iceland_jack> oh god
05:34:47 <barrucadu> I also use `maybe` and `either` all the time, but I like to thin my code isn't that bad :p
05:34:50 <barrucadu> *to think
05:34:57 <quchen> Only pointfree, which also rarely leads to good code, could have made that definition worse
05:35:10 <opqdonut> quchen: the three nested pattern matches wouldn't be that much better
05:35:23 <quchen> flatten_ (Cat x y) = case (flatten_ x, flatten_ y) of
05:35:23 <quchen>     (Nothing, Nothing) -> Nothing
05:35:23 <quchen>     (Just x', Nothing) -> Just (Cat x' y )
05:35:23 <quchen>     (Nothing, Just y') -> Just (Cat x  y')
05:35:23 <quchen>     (Just x', Just y') -> Just (Cat x' y')
05:35:31 <opqdonut> right, that's nice
05:35:40 <quchen> That’s that much better.
05:35:51 <barrucadu> Like most things, it's a matter of using these combinators with judgement
05:36:07 <quchen> Like napalm in the bathtub.
05:36:13 <the_2nd> I have many a -> b calculations which might be reoccuring. It seems like my program is not caching the results. Is there a way to flag them as "longer living" ? I also thought about defining some sort of endless map from a -> b which might always hold the newest x elements
05:37:13 <cocreature> the_2nd: there are various packages for memoizing the results of functions
05:40:16 <the_2nd> cocreature, checked the wiki page. I could basically define a map a (a -> b) and use that as intermediate?
05:40:32 <ertes-w> quchen: the flaw of your definition is that you used 'maybe' where (>>=) or (<*>) would have fit much better
05:40:33 <the_2nd> I guess this will grow forever?
05:41:15 <ertes-w> quchen: i wouldn't use 'maybe' like that, but i wouldn't resort to pattern-matching either
05:42:31 <cocreature> the_2nd: you probably want a "map a b" for memoization and then you check if you’ve already evaluated it or not
05:43:03 <cocreature> the_2nd: and yes it will grow forever, if you don’t want that, you can use some kind of lrucache like https://hackage.haskell.org/package/lrucaching-0.3.2/docs/Data-LruCache.html
05:43:48 <trigone> hi, i need help in my free-based implementation of the reader monad. i can't find how to implement an equivalent to Reader.local. here's my paste, with holes where there's "???" http://lpaste.net/357505 -- i have several hunches but nothing conclusive and i didn't want to clutter the snippet with half-made attempts
05:44:45 <trigone> wait i think i have the intuition of the solution...
05:45:43 <the_2nd> cocreature, looks good, thanks
05:46:08 <the_2nd> cocreature, I'll try implement via a map for now and hold the link in source in case I run into memory issues
05:46:43 <tabaqui> I apologize for my Franch
05:47:05 <tabaqui> is it fine practice to use GADT in such form:
05:47:22 <tabaqui> I split my logic to some (3-4) layers
05:47:38 <tabaqui> and incapsulate types in each layer from next one
05:47:57 <tabaqui> so my main function doesn't know anything about all magic inside
05:48:49 <tabaqui> and each underlying layer can extract dependent types and do what it wants to
05:48:58 <tabaqui> *French :)
05:51:00 <tabaqui> I handle many errors in compile-time now, but get a lot of parenthesis and many "data"s
05:51:04 <hrehf> is it ok to ask noobie questions in here? ;-)
05:51:20 <tabaqui> hrehf: there is no better place as I know
05:53:44 <quchen> hrehf: Yes.
05:53:59 <hrehf> awesome. I'm trying to compose monad actions(?), but I'm a bit unclear about the types. I'm using parsec, and my parsed strings are supposed to be wrapped in Node values that save the begin/end source positions. I can write concerete functions/parsers like this: https://gist.github.com/31c279c792b023c43c4a89f324028e2d 
05:54:07 <quchen> This channel is about Haskell, and »beginner Haskell« is Haskell.
05:54:45 <mauke> .oO( https://raw.githubusercontent.com/mauke/poly.poly/master/yes.c is "perl haskell" also haskell? )
05:55:05 <hrehf> Now I'd like to write something higher order that pulls out the node wrapping as in here: https://gist.github.com/hrehfeld/6a32106f1b7bcd9885ef5f2b53b6fd65 but I'm struggling with how I can compose the monad actions
05:55:38 <quchen> hrehf: Enable compiler warnings and you’ll get a hint.
05:55:49 <quchen> hrehf: The solution is correct, up to a small programming mistake.
05:56:01 <hrehf> my impression is that nodeParse :: Parser Node -> Parser Node? 
05:56:36 <quchen> It’s »Parser a -> Parser (Node a)« or something along those lines.
05:56:57 <quchen> It takes any »p« and returns a »Node«.
05:57:07 <quchen> But you can simply ask the typechecker once you fix the typo ;-)
05:57:24 <kuribas> isn't "(->) a" a Functor?
05:57:28 <quchen> Hint: what does the »r« variable do?
05:57:29 <quchen> kuribas: Yes
05:57:41 <kuribas> but it's not implemented?
05:57:47 <lyxia> it is
05:58:00 <hrehf> maybe my error is with how I use it then? https://gist.github.com/c25c15697bcd450e5978977e7443021d
05:58:06 <quchen> > (do { x <- (*4); pure x }) 5
05:58:09 <lambdabot>  20
05:58:14 <kuribas> :t map show (+1)
05:58:15 <lambdabot> error:
05:58:15 <lambdabot>     • Couldn't match expected type ‘[()]’
05:58:15 <lambdabot>                   with actual type ‘Integer -> Integer’
05:58:21 <kuribas> :t fmap show (+1)
05:58:23 <lambdabot> (Num a, Show a) => a -> String
05:58:27 <kuribas> ah neat...
05:58:43 <quchen> hrehf: No, the error is in the first piece of code you wrote.
05:59:04 <quchen> hrehf: You’re not using the »r«.
05:59:09 <quchen> That’s the result of performing »p«.
05:59:20 <trigone> i can't find the solution after all, i need help :) (http://lpaste.net/357505)
06:00:19 <lyxia> EnvLocal (r -> r) next ?
06:00:26 <trigone> oh wait
06:00:47 <hrehf> quchen: oh dang
06:00:58 <trigone> lyxia: hm... i'm not sure...
06:01:03 <hrehf> thanks :-)
06:01:04 <lyxia> me neither
06:01:32 <lyxia> trigone: That's not it :(
06:01:52 <trigone> lyxia: i don't think it works, bc local is meant to basically take a subprogram as inert parameter, separate from the rest of the sequence 
06:03:04 <trigone> i *think* maybe envLocal has to be a simple function, something modifying a Free value to incorporate the plan that the environment value be modified for that subprogram (i doubt i'm clear)
06:04:08 <phz_> hey peeps, I have a newtype over a hashmap for FromJSON
06:04:24 <phz_> I’d like to add a test so that it cannot parse empty hashmaps (it builds non-empty hashmaps)
06:04:33 <phz_> how should I fail in the fromJSON implementation?
06:04:40 <phz_> with MonadFail?
06:04:44 <phz_> or is there a better combinator to use?
06:05:31 <quchen> I think MonadFail is what Aeson intends to be used, yeah
06:05:33 <hrehf> quchen: awesome, now it's working. Glad I wasn't totally off about something ;-)
06:05:43 <quchen> hrehf: Conclusion, enable -Wall.
06:05:44 <phz_> that’s cool, danke schön
06:06:13 <trigone> i think i found the solution, though i think there's a better way to structure it
06:06:23 <lyxia> phz_: https://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson.html#t:FromJSON "The basic ways to signal a failed conversion are as follows: ... fail ..."
06:06:40 <phz_> lyxia: ok, so fail
06:06:46 <phz_> thanks <3
06:06:52 <lyxia> yw <3
06:06:53 <phz_> λ3
06:06:55 <hrehf> quchen: hmm, that didn't seem to give me more info before I fixed the error?
06:07:13 <quchen> It should report the unused variable.
06:08:36 <trigone> hey it worked but honestly i don't really (completely) know how... how can i add a snippet below an existing lpaste snippet? when i edited it totally overwrote the previous version
06:08:58 <quchen> trigone: »annotate« it
06:09:26 <trigone> quchen: ok! thx (honestly it's not a really transparent term, is it?)
06:11:13 <trigone> http://lpaste.net/357505
06:11:41 <sphinxo> if I have some newtypes, all with the same  value type, how can I get a list of the actual values
06:12:18 <quchen> You can’t do that easily.
06:12:22 <sphinxo> ok
06:12:42 <quchen> You can do something with coerce and existential types, but I don’t think it’s very elegant.
06:13:01 <quchen> You can also write »[coerce val1, coerce foo2, coerce blabla]«.
06:13:28 <the_2nd> I wanted to have a map to cache function results
06:13:36 <trigone> is there a way to incorporate local inside the rest of the DSL? it seems hard to do bc it seems id have to write down the monomorphic type of the final Free monad directly in it, since it's basically one of its parameter (something like EnvLocal (r->r) (Free Actions a) (a -> next))
06:13:36 <the_2nd> does this look good? : http://lpaste.net/2831266879887114240
06:14:17 <trigone> :t lookup
06:14:18 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:14:30 <trigone> :t maybe
06:14:32 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:15:05 <trigone> the_2nd: i think you can use those two to make things more compact (but i haven't checked)
06:15:17 <wz1000> Is there a simple way to read a bytestring from stdin until I see a particular character?
06:16:07 <trigone> :t takeWhile
06:16:09 <lambdabot> (a -> Bool) -> [a] -> [a]
06:16:37 <hrehf> now I have this working example that builds upon the 48h scheme tutorial: https://gist.github.com/hrehfeld/bdc18a10de0d2f2579aa176e7bb62859 Is there an elegant/easy way to pull out the parseNode $ ... parts of the individual parse funs?
06:17:40 <hrehf> I'm unsure how to compose the parsers with parseNode while still preserving the complex expression in parseExpr at the bottom?
06:21:29 <quchen> hrehf: I would probably build a parser that also results in the source span and work with that, like do { p1 <- getPos; x <- p; p2 <- getPos; pure (SourceSpan p1 p2, x) }
06:21:43 <quchen> hrehf: That is the most general »parse this and annotate it with its span« parser.
06:21:57 <quchen> You can then transform this to a Node later.
06:22:24 <quchen> Unless Node is the only thing you’re annotating with the source span.
06:22:47 <quchen> …which it is. I should have looked at the code some more.
06:23:06 <quchen> hrehf: By the way, have a look at the »between« function.
06:23:21 <hrehf> quchen: yep, currently it is. I was wondering if I can get rid of the individual parseNode $ <parser> parts and just apply it once to every part of the complete parsing expression
06:24:20 <nshepperd_> trigone: forall a. EnvLocal (r->r) (Free (ActionsPolyF r) a) (a -> next)
06:24:28 <nshepperd_> Is one way to do it
06:25:08 <hrehf> quchen: hmm, how does between help if it throws away open and close?
06:25:29 <quchen> hrehf: You’re throwing them away as well
06:25:36 <quchen> _ <- char '"'
06:25:41 <quchen> That throws away the parsed character.
06:25:44 <quchen> It still parses it though.
06:25:49 <hrehf> ah, yes
06:26:06 <quchen> between begin end thing = do { _ <- begin; result <- thing; _ <- end; pure result }
06:26:34 <hrehf> I see. So far I was only working on the position parts
06:26:52 <quchen> Oh, for the position function that won’t help, yes :-)
06:27:34 <hrehf> Hmm, it's kindof annoying that parsec's SourcePos saves line/col instead of just point
06:28:03 <quchen> Write your own one based on it then :-)
06:28:32 <hrehf> my own pos? Haven't found a function that gives me SourcePos -> Point yet  
06:28:48 <quchen> What’s Point?
06:28:59 <hrehf> just index of char in string
06:29:02 <BernhardPosselt> hi, when I've got a Maybe that contains a Maybe and I want to map over the inner maybe, i need MaybeT right?
06:29:21 <polux> you can just fmap (fmap f)
06:29:46 <trigone> nshepperd_: the forall thing implies gadt or something? cuz i basically just fell onto this and the compiler tells me "unknown a"
06:29:47 <polux> fmap (fmap (+1)) (Just (Just 1))
06:29:48 <quchen> hrehf: I don’t think Parsec tracks that, no
06:30:36 <nshepperd_> trigone: the forall requires ExistentialTypes or something.
06:30:49 <trigone> nshepperd_: hm, and is that a harmless extension or not?
06:31:07 <trigone> there's no other way to handle this? :(
06:31:10 <quchen> :t fmap -- BernhardPosselt 
06:31:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:31:12 <quchen> :t fmap . fmap
06:31:14 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
06:31:17 <quchen> :t fmap . fmap . fmap
06:31:18 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
06:31:43 <phz_> arf
06:31:55 <nshepperd_> trigone: EnvLocal (r->r) (Free (ActionsPolyF r) next) would probably also work. Only mildly less performant
06:31:56 <phz_> I thought that PartialTypeSignatures could be used with ScopedTypeVariables
06:31:57 <phz_> a bit like in Rust
06:32:11 <phz_> let x :: Either _ QuantifiedProducts = eitherDecode json
06:32:19 <phz_> the _ is easy to infer based on eitherDecode
06:32:22 <BernhardPosselt> reason im asking is java 8 stream of optionals, someone suggested this https://dpaste.de/QpJy vs my original https://dpaste.de/Hi57
06:32:42 <trigone> nshepperd_: ExistentialQuantification? or it's sth else?
06:32:57 <trigone> nshepperd_: oh quite true i hadn't thought about that...
06:33:05 <nshepperd_> Uh that seems right yeah
06:33:11 <lyxia> phz_: what goes wrong
06:33:30 <BernhardPosselt> kinda wondering if there is some sort of pattern for that
06:33:48 <polux[m]> BernhardPosselt: both seem fine, yours looks more like idiomatic java code I'd say
06:33:50 <trigone> nshepperd_: is there no way to abstract the specific Free in the definition of EnvLocal?
06:34:18 <polux[m]> BernhardPosselt: wait actually they're not equivalent
06:34:22 <phz_> lyxia: wildcard type
06:34:49 <polux[m]> the one that uses optional doesn't account for when getAddress or getStreet return null
06:35:00 <trigone> nshepperd_: or in the end, have a Free monad that natively allows the possibility of containing itself in that fashion?
06:35:16 <polux[m]> and the one that doesn't use Optional doesn't account for null customers
06:35:22 <BernhardPosselt> polux[m]: yeah, java optional broke functor laws
06:35:36 <nshepperd_> You could add it as another type variable lol
06:35:38 <BernhardPosselt> every null from a map method makes it empty (Nothing)
06:35:40 <lyxia> phz_: What about it? AFAICT there is no incompatibility between PartialTypeSignatures and ScopedTypeVariables.
06:35:47 <phz_> lyxia: it just doesn’t work 
06:35:52 <phz_> it says that the type is String
06:35:52 <polux[m]> BernhardPosselt: why would you say that?
06:35:56 <phz_> and that I should enter it
06:36:13 <polux[m]> BernhardPosselt: seems to me that java optionals are functors in the haskell sense
06:36:21 <BernhardPosselt> polux[m]: https://developer.atlassian.com/blog/2015/08/optional-broken/
06:36:28 <sphinxo> simple way to, based on an Either, if right apply to function using IO, otherwise do nothing
06:36:31 <sphinxo> for several eithers
06:37:00 <trigone> something like data Free' f = Free (f (Free' f))
06:37:04 <dibblego> the original one didn't break any laws
06:37:22 <trigone> (with the functor taking the type of the final Free monad as parameter systematically)
06:37:39 <trigone> nshepperd_: how do you know which version is more or less performant?
06:37:52 <polux[m]> BernhardPosselt: right ok
06:37:53 <lyxia> phz_: http://lpaste.net/357522 this compiles
06:38:05 <BernhardPosselt> polux[m]: so both cases are roughly equivalent :)
06:38:37 <BernhardPosselt> (findFirst is missing)
06:38:45 <polux[m]> If you ignore nulls I suppose, but otherwise they're not
06:38:49 <trigone> nshepperd_: i'm feeling like it amounts to a free monad structured as a tree instead of a linear construction...
06:39:05 <polux[m]> if, say, getStreet returns null
06:39:13 <polux[m]> the version with optional will crash
06:39:18 <BernhardPosselt> nope
06:39:18 <polux[m]> won't it?
06:39:27 <phz_> lyxia: https://gist.github.com/phaazon/c798ce0f7c1adf10e6665430248e8a64
06:39:32 <BernhardPosselt> optional.map(v -> null) == Optional.empty()
06:39:40 <polux[m]> oh ok
06:39:46 <polux[m]> that's super weird
06:39:48 <polux[m]> wasn't aware of that
06:39:53 <polux[m]> I misread your link
06:39:57 <lyxia> phz_: PartialTypeSignatures turns the error into a warning.
06:40:13 <phz_> I added it, and it shouldn’t be a warning
06:40:14 <phz_> anyway
06:40:17 <phz_> I just put in String.
06:40:18 <BernhardPosselt> didnt accept it at first but nulls are a huge issue in our production code
06:40:24 <trigone> nshepperd_: if we abstract all this, i think we can just write the underlying functor in function of itself, and have some appropriate mapping to take care of the fact that it's going to be a "monadic tree"
06:40:32 <BernhardPosselt> mostly because the ORM returns null for empty lists
06:41:08 <trigone> nshepperd_: is there an official implementation of Reader in terms of Free and some abstract DSL?
06:41:30 <BernhardPosselt> polux[m]: btw, thats the reason for another issue: Stream.of(null).findFirst() crashes with a null pointer exception
06:41:34 <lyxia> phz_: If you don't want to see the warning at all you can disable it with -Wno-partial-type-signatures
06:41:50 <lyxia> but anyway, it works.
06:42:50 <polux[m]> BernhardPosselt: I would wrap the ORM with something that get rids of the nulls
06:43:25 <polux[m]> by replacing them by Nothings or by empty lists depending on the original intent
06:43:50 <BernhardPosselt> polux[m]: proxies, good idea
06:44:02 <sphinxo> how can I either apply an IO action to an either or do nothing
06:44:08 <nshepperd> trigone: here's an option. data ActionsPolyF free r next = EnvQuery (r -> next) | EnvLocal (r -> r) (free (ActionsPolyF free r) next)
06:44:29 <sphinxo> eg if it's right then print it else do nothing
06:44:37 <BernhardPosselt> like wrap it in an object that always wraps the getters with Optional.ofNullable(value) or Collections.emptyList()
06:44:45 <sphinxo> for many eithers where it's annoying to case of every one
06:44:49 <hrehf> another noob q: how can I create a parsec parser that parses a whole word?
06:44:51 <BernhardPosselt> not sure though if coworkers would like that :D
06:45:00 <hrehf> err, a specific word
06:45:01 <trigone> nshepperd: hm not bad :)
06:45:40 <nshepperd> trigone: btw i would personally name my parameters like ActionsPolyF free env r. the normal convention seems to be that the 'next' parameter is called 'r' usually
06:46:35 <trigone> nshepperd: can we not generalize the recursivity with Fix? (i just started on that other topic so i dunno)
06:47:35 * hackagebot sandi 0.4.1 – Data encoding library – https://hackage.haskell.org/package/sandi
06:48:07 <trigone> nshepperd: yeah, i know, i guess i'll have to follow the norm. it's just, r is hardly descriptive, and does not imply the fact that the structure is hardly meant to be used as is. i bet we could even consider a language where its definition is local to the definition of the corresponding Free monad
06:53:04 <nshepperd> ‾\(*_0)/‾
06:53:16 <nshepperd> idk, I always just do it this way
06:53:45 <trigone> nshepperd: which method?
06:54:31 <trigone> so it's a case that does happen often then?
06:56:19 <nshepperd> with the functor just hardcoding in the final free monad
06:56:21 <nshepperd> https://github.com/nshepperd/funn/blob/master/AI/Funn/CL/Code.hs#L68
06:56:26 <nshepperd> heres an example
06:56:50 <nshepperd> (it's gadt syntax, but it's actually just a normal ADT, not using any fancy gadt features)
06:57:27 <nshepperd> there i'm writing (Expr Int -> CL ()) which refers directly to the free monad Free CLF ()
07:00:11 <trigone> nshepperd: ok! well that's not too bad a system... it's a bit annoying that i need ExistentialQuantification... does that reflect something haskell should allow by default? is there any performance issue linked to this extension to expect?
07:01:38 <trigone> nshepperd: do you use DSL+free a lot to structure your programs?
07:01:49 <nshepperd> trigone: you don't need ExistentialQuantification if you don't use the forall. but afaik it's perfectly safe. it's just a subset of what GADTs allow
07:02:32 <trigone> nshepperd: it won't compile without forall (note that i haven't tested with forall yet), it tells me  error: Not in scope: type variable ‘a’
07:02:49 <nshepperd> i mean if you use EnvLocal (r->r) (Free (ActionsPolyF r) next)
07:03:13 <nshepperd> instead of the one with forall a. EnvLocal (r->r) (Free (ActionsPolyF r) a) (a -> next)
07:03:57 <trigone> nshepperd: hm but you said there could be perf loss? how do you know that btw?
07:06:08 <nshepperd> well, the difference is, when you want to fmap over the plain one, it recursively fmaps over that inner Free and so takes however long it takes to fmap over a Free
07:06:32 <tabaqui> why don't you change "replicate :: Int -> a -> [a]" to "replicate :: Num n => n -> a -> [a]"
07:06:37 <tabaqui> and in similar functions
07:06:38 <tabaqui> ?
07:07:16 <nshepperd> whereas when you go to fmap over the existential one, it's just composing a function pretty much like your EnvQuery case
07:07:37 <phadej> local coyoneda?
07:07:45 <Ferdirand> tabaqui: what would "replicate 1.5 ()" do ?
07:07:55 <trigone> nshepperd: hm i see...
07:08:11 <kadoban> tabaqui: I think you mean a different typeclass, but there exist generic versions of a few of those cases at least.
07:08:12 <nshepperd> trigone: the difference probably doesn't matter. and they're both efficient if you use the church free monad from `free` package
07:08:17 <kadoban> :t genericReplicate
07:08:19 <lambdabot> Integral i => i -> a -> [a]
07:08:26 <nshepperd> instead of plain ol' Free monad
07:08:38 <kadoban> I think they're not the usual ones because of something about efficiency.
07:09:20 <nshepperd> but that's something to mess with later i think
07:09:38 <trigone> nshepperd: i thought Free was in free? i don't know about the church free monad yet... yes as you said it's not important right now
07:11:32 <nshepperd> trigone: yeah, `free` package supplies the normal Free, and also this "fast" church encoded one in Control.Monad.Free.Church
07:16:31 <trigone> nshepperd: same interface?
07:17:24 <nshepperd> trigone: yep
07:17:32 <trigone> nshepperd: k thx :)
07:19:16 <ertes-w> glguy: nitpick about config-value: if it used "-" instead of "*" for lists i could use my editor's YAML mode =)
07:22:00 <trigone> nshepperd: still i'm wondering if in my case it's really a semantically sound approach to put local inside the DSL. to me local sounds more like an interpreter than an effect/action
07:22:50 <tabaqui> Ferdirand: right, Enum is almost perfect, it has pred, but doesn't have zero, hmm
07:23:14 <nshepperd> it's an action that modifies another action. imo it makes sense
07:23:34 <tabaqui> kadoban: Data.List, ok, what about replicateM?
07:24:07 <trigone> nshepperd: maybe... 
07:24:18 <tabaqui> I don't think that genericReplicate is slower than replicate for Int's
07:24:58 <tabaqui> actually it uses genericTake and genericTake just decrements input while it more than 0
07:24:58 <kadoban> tabaqui: No idea about replicateM, I'd have to look.
07:25:41 <trigone> nshepperd: thanks for all th
07:25:55 <trigone> all the help! :)
07:31:01 <trigone> nshepperd: wait, i don't get it, in your code, you have a variable `a` inside all these (Exp a) parameters, yet it's not a parameter of CLF... how come?
07:31:35 <nshepperd> oh
07:31:45 <nshepperd> uh
07:31:58 <nshepperd> i guess I am doing gadt stuff with those Exps
07:32:01 <trigone> nshepperd: unless... your definition of Exp is weird, looks like a phantom parameter
07:32:08 <nshepperd> yeah that a is an existential
07:32:50 <trigone> nshepperd: ok :)
07:33:41 <nshepperd> yeah, I added that parameter so that I wouldn't get different types of expressions mixed up
07:35:02 <the_2nd> I have a f :: a -> State b c   and now would like to map it    such that g :: [a] -> State b [c]
07:35:26 <the_2nd> which should change the state in sequence 
07:35:32 <jchia_1> What's an elegant way to do short-circuiting && à la C on two "m Bool" values, particularly two "IO Bool"? I don't think "liftA2 (&&)" will short-circuit.
07:36:39 <trigone> :t traverse
07:36:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:37:13 <Iceland_jack> > :t traverse @[] @(State _)
07:37:13 <Iceland_jack> traverse @[] @(State _) :: (a -> State t b) -> [a] -> State t [b]
07:37:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:37:41 <Ferdirand> jchia_1: i think that you need at least monad, not applicative, for this
07:38:28 <jchia_1> Ferdirand: I think so, too. The decision to 'evaluate' the second part depends on the result of the first part.
07:39:47 <jchia_1> I could do something like "x >>= \b -> if b then y else pure False" but that's looks clumsy.
07:41:03 <phadej> ifM :: Monad m => m Bool -> m a -> m a -> m a -- in 'extra'
07:41:29 <phadej> ... and few other libs
07:41:42 <phadej> ifM x y (pure False)
07:42:52 <jchia_1> phadej: Thanks. Learned a new thing.
07:43:20 <phadej> you can always define your own combinators, often they are somewhere already
07:44:26 <jchia_1> phadej: I could, but if it's somewhere already, I try to not reinvent the wheel and add more code.
07:46:01 <phadej> jchia_1: extra is reasonable collections of "not really belongs to base" stuff
07:48:17 <dolio> johnw: That's a little out of date now. I'm not sure you can't write a valid monad instance. :)
07:50:03 * hackagebot conduit-iconv 0.1.1.2 – Conduit for character encoding conversion. – https://hackage.haskell.org/package/conduit-iconv
07:50:22 <the_2nd> within State, how do I simply update a field?
07:50:29 <the_2nd> foo { bar = newBar }
07:50:43 <phadej> :t modify'
07:50:44 <lambdabot> MonadState s m => (s -> s) -> m ()
07:51:46 <Xion_> How do you refer to a typeclass function from a particular instance?
07:52:06 <phadej> :t fromIntegral :: Int -> Double
07:52:08 <lambdabot> Int -> Double
07:52:11 <phadej> :t fromIntegral
07:52:13 <lambdabot> (Num b, Integral a) => a -> b
07:52:18 <ertes-w> jchia_1: if you get rid of the Bool, then (>>) is your "and"
07:52:23 <Xion_> E.g. I have: class ToUUID where toUUID :: a -> Maybe UUID, and I want to compose toUUID for where a ~ Text
07:52:34 <ertes-w> jchia_1: and (<|>) is your "or"
07:52:43 <Xion_> Is it (toUUID :: Text -> Maybe UUID), with the entire signature spelled out?
07:52:51 <the_2nd> phadej, thanks
07:52:53 <phadej> Xion_: that's one way
07:53:05 <Xion_> Seems a little redundant.
07:53:37 <phadej> Xion_: do you get ambigious type -errors or why you want to spell it out?
07:53:43 <ertes-w> jchia_1: (or going fully applicative, (<*>) is your "and")
07:54:04 <phadej> sorry, s/spell out/pin point to single instance/
07:54:07 <Xion_> Yeah actually now that I think of it, I have (toUUID :: Text -> Maybe UUID) . Text.pack
07:54:14 <Xion_> That should be enough for GHC to figure it out
07:54:19 <Xion_> (the Text.pack part :) )
07:54:21 <jchia_1> ertes-w: But that won't short-circuit, will it?
07:55:03 <ertes-w> jchia_1: it will in the right monad, where 'pure' corresponds to True, and 'empty' corresponds to False
07:55:30 <ertes-w> jchia_1: e.g. MaybeT IO
07:58:01 <ertes-w> jchia_1: (in fact even IO itself is Alternative, but you might not want to use that)
08:02:53 <dolio> johnw: I'm _now_ sure, even.
08:05:49 <jchia_1> ertes-w: Now I see what you mean by "get rid of Bool". I think you mean replacing Bool/True/False with Alternative/pure/empty and using the <|> for the short-circuiting semantics.
08:06:56 <jchia_1> If I have to operate with Bool, I have to do conversion to Alternative first and finally convert back to Bool.
08:12:00 <ertes-w> jchia_1: (<*>)/(>>) and (<|>)
08:12:15 <ertes-w> jchia_1: since you want "and" semantics (<*>) is what you need
08:13:01 <ertes-w> also:
08:13:02 <ertes-w> :t when
08:13:04 <lambdabot> Applicative f => Bool -> f () -> f ()
08:13:22 <ertes-w> or rather:
08:13:23 <ertes-w> :t guard
08:13:25 <lambdabot> Alternative f => Bool -> f ()
08:13:41 <ertes-w> that quite literally converts a Bool to (f ())
08:37:36 <sphinxo> if FromJson exists for A and B
08:38:25 <sphinxo> why can't I do Data.Aeson.decodeEither str :: Either String (Map.Map A B)
08:39:16 <sphinxo> oh wait nvm
08:39:34 <gremdrus> is there an easy way to get ghci history to persist across intero/ghci sessions?
08:40:54 <geekosaur> ghci history persists for me; no idea if intero is doing something special
08:43:08 <Xion_> Inside IO, can I easily convert a Nothing into a `fail` and get the value from Just if it's there?
08:43:20 <Xion_> Preferably without using case
08:44:07 <geekosaur> do Just foo <- something_producing_IO_Maybe -- ?
08:48:52 * hackagebot snap-extras 0.12.1.0 – A collection of useful helpers and utilities for Snap web applications. – https://hackage.haskell.org/package/snap-extras
08:50:00 <jchia_1> geekosaur: Generally, what happens in a Monad (not just IO) when there's a pattern match failure?
08:50:12 <geekosaur> it invokes fail
08:50:21 <jchia_1> i c
08:50:23 <geekosaur> which is the whole reason fail was dragged into Monad
08:50:52 <sphinxo>    aeson-0.11.2.1 must match ==1.2.1.0 (latest applicable is 1.2.1.0) ?
08:51:03 <jchia_1> if fail gets moved to MonadFail, what would be a reasonable thing to do for pattern match failure?
08:51:27 <geekosaur> sphinxo, that's incomplete, the rest of the message should say why it can't use 1.2.1.0. (usually it's telling you 1.2.1.0 is not in your current resolver)
08:51:30 <Xion_> Detect it at compile time and disallow refutable patterns'
08:51:36 <geekosaur> the "latest applicable" just means a version is known to exist
08:52:19 <sphinxo> jmm, I just get plan construction failed
08:52:19 <geekosaur> jchia_1, I believe the MonadFail proposal just adds a MonadFail constraint
08:52:55 <sphinxo> http://lpaste.net/7027696742669746176
08:53:02 <geekosaur> which is more or less what happened before fail was added to Monad (although I think it had a different name then. MonadZero?)
08:53:04 <sphinxo> ( output of stack build )
08:54:07 <geekosaur> that's not what you said earlier. but I stand by my translation: your resolver has 0.11.2.1, your dependencies say >=1.2
08:54:21 <sphinxo> yeah I tried to change it
08:54:23 <geekosaur> you either need to specify the newer version in stack.yaml, or switch to a newer resolver
08:55:26 <sphinxo> oh sorry you're right https://www.stackage.org/lts-7.16/package/aeson-0.11.2.1
08:56:06 <geekosaur> current lts is 9.0, latest lts for 8.0.1 is 7.24 (its aeson is still too old: 0.11.3.0)
08:56:30 <geekosaur> 9.0 has 1.1.2.0 so still too old
08:56:53 <geekosaur> nightlies have 1.2.1.0
08:57:17 <gremdrus> geekosaur: could you paste your haskell config for emacs? you must be doing something special because the default setup of intero is not capturing history
08:57:30 <geekosaur> gremdrus, I said I don't know what intero does
08:57:41 <geekosaur> I do not use intero, or stack for that matter
08:57:53 <gremdrus> geekosaur: really? what do you use instead?
08:57:58 <geekosaur> I just ran ghci and pressed uparrow
08:58:22 <geekosaur> I don't use IDEs, generally, in emacs I just use plain haskell-mode
08:58:44 <gremdrus> do you have stuff in ~/.ghc/ghci_history? mine is completely empty despite using ghci/intero for the last few days
08:59:16 <ehubinette> I've made a new blog post on my discoveries while working with linearly typed streams if someone is interested: https://m0ar.github.io/safe-streaming/2017/08/08/take-and-zip.html
08:59:41 <ehubinette> Or rather, what did I have to pay for the safety of linear streams :o
09:00:14 <shapr> ehubinette: häftig
09:00:16 <Iceland_jack> I enjoyed your blog post ehubinette
09:01:08 <geekosaur> gremdrus, that was what I tested by pressing uparrow. there is definitely stuff in my history
09:01:19 <Phillemann> What's the (.:) operator called again and in which library is it defined?
09:01:33 <gremdrus> yeah stack ghci seems to persist stuff, I guess it's something to do with intero
09:01:35 <Phillemann> It's defined as (.) . (.)
09:01:36 <geekosaur> intero may be deliberately clearing it, in which case forcing persistence may break intero
09:02:08 <ehubinette> shapr: tack! swedish? (:
09:03:03 <Ojd> hello, I am wondering if you can help me to understand the purpose of pattern and guards.  I am using "Learn you a Haskell for great Good!", and it's my first book on Haskell.  My understanding is that patterns are used to verify the type of data received by any function conforms to certain rule (e.g., if the function expects a tuple provides a tup
09:03:03 <Ojd> le instead of a list) and guards to verify that the data has certain property (e.g., positive number, odd, length ==3). However, the very first example of pattern matching compares data to the number 7.
09:03:28 <Ojd> (I would use guards for that)
09:03:54 <ehubinette> Iceland_jack: I'm glad! The hardest one to get together cohesively, the earlier have had a more concrete conclusion, while much of this is open which is confusing when writing :) 
09:04:13 <geekosaur> Ojd, types ensure tuple vs. list, not patterns
09:04:28 <shapr> ehubinette: nah, just lived there a bunch of years
09:04:31 <Iceland_jack> Ojd: To understand patterns you need to understand constructors
09:04:53 <geekosaur> patterns match against constructors. numeric literals act like constructors --- but note that they induce an Eq constraint, because they do indeed turn into guards internally
09:04:55 <Iceland_jack> Ojd: Defining a type (data ABC = A | B | C) you have three constructors (A, B, C)
09:05:15 <geekosaur> (because a numeric literal is actually a function!)
09:05:20 <geekosaur> :t 1
09:05:21 <lambdabot> Num t => t
09:06:12 <geekosaur> that actually is `` fromInteger (1 :: Integer) `` so that it can be used anywhere without specifying a type every time
09:06:21 <Iceland_jack> Ojd: So if you want to write a function to check for a B, you have a function from (ABC -> Bool)
09:06:25 <Iceland_jack> isB :: ABC -> Bool
09:06:28 <Iceland_jack> isB B = True
09:06:31 <geekosaur> or having to add type suffixes like C/C++
09:06:31 <Iceland_jack> isB _ = False
09:06:55 <cocreature> ehubinette: nice post! looking forward to seeing how this ends up being solved
09:07:29 <Xion_> geekosaur: I ended up doing  a <- fromMaybe (fail "Wrong!") $ return <$> produceMaybeA  because I wanted to control the error message
09:08:22 <Iceland_jack> The type (ABC) determines the type of data, the patterns ('A' and the wildcard-pattern '_' which always matches) indicate which branch to pick
09:08:24 <Iceland_jack> *'B'
09:09:16 <Iceland_jack> You could alternatively write that with a guard, or an if-then-else (isB abc = if abc == B then True else False)..... or simply (isB abc = abc == B)
09:13:00 <ehubinette> cocreature: right! I probably won't have time though D: Maybe I'll keep taking care of this after the internship too
09:13:05 <Ojd> OK, the type of the function ensures the type of the data received. Got it.
09:13:24 <Ojd> The pattern is related with the constructor
09:13:34 <ehubinette> shapr: ah! :) 
09:17:12 * hackagebot zip 0.2.0 – Operations on zip archives – https://hackage.haskell.org/package/zip
09:18:37 <av> edwardk: Edward, are you around?
09:22:27 <cocreature> ehubinette: just get tweag to hire you and you can keep working on it :P
09:24:17 <Ojd> still I am having issues with the difference between pattern matching and guards. I google it and this is the post that I found : https://stackoverflow.com/questions/2225774/haskell-pattern-matching-what-is-it#2225811
09:24:39 <tdammers> geekosaur: numeric literals are not functions, they are polymorphic values.
09:24:47 <Ojd> I will read the section suggested and come back later
09:25:30 <ehubinette> cocreature: that is kinda my plan, but I've got my MSc thesis this spring first :) 
09:28:31 <nshepperd> tdammers: polymorphic values with typeclass constraints are functions! secretly. in core.
09:31:21 <kora9> Hi. How does Haskell stack up to Common Lisp?
09:31:23 <Iceland_jack> nshepperd: -in Core-, I don't view (=>) as a function in Haskell
09:31:35 <cocreature> Iceland_jack: "reflection" does :)
09:33:08 <Iceland_jack> Reflection is quite cheeky!
09:34:23 * hackagebot smallcheck 1.1.2 – A property-based testing library – https://hackage.haskell.org/package/smallcheck
09:35:07 <Iceland_jack> ooh smallcheck release
09:35:53 <cocreature> I had completely forgotten that smallcheck exists
09:43:59 <tdammers> nshepperd: who cares about implementation ;)
09:47:46 <Iceland_jack> type family IsFunction (fun :: Type) :: Bool where { IsFunction (_ -> _) = 'True; IsFunction _ = False }
09:47:47 <Iceland_jack> fight me
09:48:49 <Iceland_jack> also, don't fight me since I'm heading home
09:48:50 <Iceland_jack> bye
09:49:55 * byorgey fights Iceland_jack because they put a tick on 'True but not on False
09:50:07 <Iceland_jack> Yes I know!!
09:50:16 <Iceland_jack> I'm very upset with myself
09:50:24 <Iceland_jack> oh, but maybe
09:50:37 <Iceland_jack> I added the tick so that length "True'" == length "False"
09:50:41 <Iceland_jack> so they align
09:50:56 <byorgey> a likely story.
09:51:02 <Iceland_jack> It's what happened
09:51:15 <byorgey> anyway, don't let me keep you from going home =)
09:52:00 <Iceland_jack> Take care yall :)
09:52:01 <kubrat> c++ type suffixes
10:24:19 <sphinxo> How do I write a newtype wrapper around bytestring
10:25:26 <sphinxo> so I can write "V" :: SomeType
10:27:54 <wz1000> sphinxo: IsString
10:29:36 <sphinxo> I do
10:29:46 <sphinxo> but I get a lot of  Couldn't match type ‘Sometype’ with ‘ByteString’
10:30:12 <sphinxo> if I say do Map.lookup on :: Map.Map SomeType Key
10:30:37 <sphinxo> but with the first param as a bytetring
10:30:47 <sphinxo> wz1000: any ideas?
10:31:47 * hackagebot find-clumpiness 0.2.2.0 – Find the clumpiness of labels in a tree – https://hackage.haskell.org/package/find-clumpiness
10:45:19 * hackagebot extrapolate 0.2.0 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
10:55:24 <mivael> :t  let  f = (`ap` snd) . (. fst) . (const .) . (==) . fst;  g x = f x x  in f
10:55:26 <lambdabot> Eq a1 => (a1, b) -> (a1, a) -> Bool
10:58:22 <crucify_me> hi the two last elements of the signature -> x -> w , how does the x show up here before the w is returned (solution from internet, not mine) thanks    https://ptpb.pw/h1_c
11:09:46 * hackagebot bit-stream 0.1.0.2 – Lazy, infinite, compact stream of Bool with O(1) indexing. – https://hackage.haskell.org/package/bit-stream
11:21:32 <dmwit> crucify_me: I'm not sure I understand the question.
11:22:11 <dmwit> At a guess: maybe you haven't seen the "definition" side of partial application.
11:22:39 <dmwit> e.g. if `f x = g x` is a good definition, then `f = g` is a fine definition and means the same thing (to a first approximation).
11:22:59 <dmwit> So we could also write `munge f g x = (fst . g . f) x` if we wanted.
11:23:09 <rampion> I need a sanity check - does anyone else get an error in GHCi 8.2.1 when they try `:set prompt2 "..."`
11:23:24 <Tuplanolla> :t const (const (fix id)) :: signature -> x -> w -- What do you mean by "how", crucify_me?
11:23:24 <dmwit> rampion: It was renamed. I think there's a comment about it in the release notes.
11:23:25 <lambdabot> signature -> x -> w
11:23:37 <dmwit> Tuplanolla: (Do check out his link.)
11:24:15 <rampion> dmwit: thanks. Didn't see anything in the 8.2.1 notes. I'll check the 8.2 notes
11:24:20 <Tuplanolla> Ah, I didn't even notice it, dmwit.
11:24:43 <crucify_me> Tuplanolla, one moment sorry thanks ...
11:25:20 <crucify_me> dmwit thanks please stand by. I'm rude on both channels
11:25:33 <dmwit> rampion: It's called `prompt-cont` now.
11:25:36 <Tuplanolla> Yeah, it's eta reduction as dmwit said, crucify_me.
11:25:39 <rampion> thanks!
11:25:57 <dmwit> rampion: I have not managed to find proof that this is mentioned in the release notes. =P
11:27:02 <rampion> dmwit: thanks! it's in the user's guide https://downloads.haskell.org/~ghc/master/users-guide/ghci.html#ghci-cmd-:set%20prompt-cont
11:36:47 <crucify_me> dmwit Tuplanolla thanks I think those explanations cinched it ! with help from kado*ban as well.
11:39:15 <nano-> Is Groundhog db thingie intended to be only used with a self-managed db schema, or can it be used without administrating db schema?
11:46:36 <crucify_me> pardon , dmwit , in lambda terms that x outside the parentheses is bound, correct? (in your last solution ' munge f g x = fst (fst . g . f) x '      ?
11:59:30 <av> Hi fellows, I need some help with AD -- can anyone help me please?
11:59:58 <ongy> av: it's usually better to just ask your question. don't ask to ask. someone will answer when they can help you
12:00:09 <shapr> Active Directory? Automatic Differentiation?
12:00:26 <Clint> anno domini
12:00:41 <shapr> oh look, Yesod can be used with active directory
12:01:14 <shapr> or you can use CosmicRay's ldap client to read Active Directory
12:01:27 <shapr> CosmicRay: how's code? you still writing Haskell?
12:11:38 <av> ongy: OK
12:12:27 <shapr> av: what AD are you using?
12:12:32 <av> I'm wondering whether there's a way of adding two Jets in AD, and whether there's a way of multiplying a jet with a constant
12:12:49 <av> shapr: Numeric.AD from Edward Kmett
12:13:43 <edwardk> the problem is that you have no way of knowing that the 'f's are of the same shape without knowing more about 'f'
12:14:10 <edwardk> zipping Jet [] a requires you to know that you can zip lists.
12:14:22 <edwardk> mutatis mutandis for maps, etc.
12:14:30 <edwardk> and in theory you really want union like semantics for most things
12:14:45 <av> Hi edwardk -- so there's no way of adding two Jets?
12:15:03 <edwardk> you can write such a combinator. i can't supply it in sufficient generality that it is worth writing directly in ad
12:15:41 <av> edwardk: OK, thanks, that was what I feared
12:16:11 <edwardk> zipJetWith :: (a -> b -> c) -> Jet [] a -> Jet [] b -> Jet [] c; zipJetWith f (a :- as) (b :- bs) = f a b :- zipJetWith (zipWith f) as bs
12:16:18 <edwardk> gives you the [] case
12:16:27 <edwardk> assuming you want zip-like semantics
12:16:38 <edwardk> if you have f as a representable functor then you can always safely and soundly zip
12:18:37 <edwardk> zipRepJetWith :: (a -> b -> c) -> Jet f a -> Jet f b -> Jet f c; zipRepJetWith f (a :- as) (b :- bs) = f a b :- zipRepJetWith (\x y -> rep $ \i -> f (index x i) (index y i)) as bs
12:18:46 <edwardk> er for Representable f =>
12:20:02 <av> edwardk: thanks a lot, I think I need to digest this a little
12:20:45 <shapr> semiautomatic differentiation
12:21:34 <Aphara> I'm considering make a text-based web browser with JavaScript support in Haskell. Would anyone be willing to work on this with me? Hackage has a DOM implementation package and a package that interfaces with JavaScriptCore, so I think making the browser would be doable.
12:23:02 <shapr> anyone have a favorite Haskell package for reading nearby volume levels from a microphone?
12:23:20 <shapr> alternatively, is there a recommend audio device cabbage on hackage?
12:24:45 <zomg> Aphara: I'm pretty sure I recently saw some basic browser implementation posted on /r/haskell or something 
12:24:58 <zomg> unless that was yours, perhaps the person who made it would be interested
12:26:11 <Fuuzetsu> I know there's an actual browser (graphical) but not text one
12:30:55 <dmwit> ?tell crucify_me That question ("In lambda-calculus terms, is `x` bound in `munge f g x = (fst . g . f) x`?") is a bit tricky. Lambda calculus itself doesn't have declarations at all, so it can't talk about this. Even so, I think it would be very natural to call `x` "bound" on the right-hand side of the equals sign, with the `x` on the left-hand side being the binding site. Or, writing `munge = \f g x -> (fst . g . f) x`, the entire right-hand s
12:30:55 <lambdabot> Consider it noted.
12:32:34 <Aphara> zomg: Yup, you were presumably referring to the web browser wish, which is at github.com/chrisdone/wish. Though it's unfortunately not terminal based and lacks JS support, it is text-based, so thanks for mentioning it. I'll look into it.
12:36:04 <tommd> dmwit: Thanks to line lengths in IRC your message was cut short "the entire right-hand s".
12:36:42 <tdammers> that's not line lengths, it's message length limits
12:37:09 <tdammers> good IRC clients deal with it by splitting the message up, and asking you to confirm if it's very long
12:49:43 <dolio> Wouldn't work for @tell, though. :)
12:50:19 <shapr> and that's why slack was invented
12:51:08 <Fuuzetsu> I used IRC gate for Slack when I started using it ;^)
12:51:25 <Zemyla> I kind of wish IntSet had intervals, so that it could have a complement function.
12:53:24 <shapr> I wish I the PortAudio binding were maintained, but not enough to pick it up myself.
13:01:35 <timofonic> Hello
13:01:48 <Fuuzetsu> salutations
13:03:42 <timofonic> A stupid question: Is this programming language common mostly to maths or are there linguists? If not, do you know what one can have certain percentage of linguists? I want to ask about a very advanced text cheking tool (not only grammar, a lot more... the most similar to a grumpy teacher that memorized "The Elements of Style Book")
13:06:17 <kadoban> timofonic: I don't know of any particular programming language that is known for being used by linguists much. Maybe look for linguists that can program.
13:06:45 <cocreature> one of the authors of haskellbook.com is a linguist :)
13:07:16 <timofonic> Oh
13:07:55 <timofonic> I found LanguageTool and Expresso, but I'm not sure about them. I'm afraid "big data" could be a big advantage to SaaS service, because they can be heavily trained...
13:08:06 <byorgey> timofonic: don't know how up-to-date the info is, but check out https://wiki.haskell.org/Libraries_and_tools/Linguistics
13:09:08 <byorgey> http://www.grammaticalframework.org/  seems to be a very actively developed and is implemented in Haskell
13:11:01 <timofonic> byorgey: Has it been deployed in end-user software? Text editors, text checkers for teachers...
13:11:56 <koz_> Hi byorgey - thank you for writing (and maintaining) the Typeclassopedia. Every time I read it again, I learn something new.
13:12:07 <frankpf> why is a simple fibonacci program compiled with "stack build" using all my cores?
13:12:36 <frankpf> is GHC doing some kind of parallelism magic?
13:12:42 <byorgey> timofonic: I have no idea.
13:12:46 <kadoban> frankpf: How simple is it?
13:12:57 <byorgey> koz_: thanks!  I'm very glad to hear that.
13:12:58 <Fuuzetsu> maybe your OS is just context-switching?
13:13:06 <Fuuzetsu> so it looks like all cores are being used
13:13:17 <frankpf> kadoban: fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
13:13:18 <koz_> frankpf: If you post the sauce, it'd be very helpful.
13:13:24 <koz_> Ah, thanks.
13:13:26 <cocreature> frankpf: potentially parallel gc
13:13:28 <frankpf> Also, compiled with GHC it runs faster
13:13:32 <frankpf> and uses only one core
13:13:55 <byorgey> 'stack build' just calls GHC.  But maybe it inserts some extra flags by default.
13:14:12 <cocreature> stack initializes new projects with -threaded -rtsopts -with-rtsopts=-N
13:14:52 <frankpf> Ah
13:14:59 <kadoban> frankpf: Just so you know, that implementation is *very* bad for most uses. My guess would be garbage collection.
13:15:00 <frankpf> Those two flags -rtsopts and -with-rtsopts=-N 
13:15:06 <frankpf> are making the program use all my cores
13:15:25 <koz_> frankpf: Gotta Fibonnaci fast. :P
13:15:49 <cocreature> you can disable parallel GC but in this case using an implementation of fib, that’s not terribly slow is probably the better solution :)
13:15:50 <frankpf> kadoban: Yeah, I know. I was just wondering why it was using all 4 cores 
13:16:07 <frankpf> Oh, so that's just the GC. 
13:16:19 <frankpf> I thought it was parallelizing fibonacci somehow :p
13:16:24 <timofonic> https://github.com/GrammaticalFramework/linguist/tree/master/samples <---- I see it's for programming languages. I did mean human languages
13:17:24 * hackagebot fltkhs 0.5.3.9 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
13:19:39 <byorgey> timofonic: that particular repository is using GrammaticalFramework to process programming languages.  As far as I can tell GrammaticalFramework itself is much more general than that, and is used for human languages
13:35:05 <orzo> Is there anywhere that the {-# LANGUAGE TemplateHaskell #-} syntax changes are officially documented?
13:36:08 <cocreature> orzo: https://hackage.haskell.org/package/template-haskell-2.12.0.0/changelog
13:36:59 <orzo> that's not exactly documentation
13:37:21 <michi7x7> is there a library function for http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a,b],[c],[d -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a,c,d],[b,c,d ?
13:37:23 <cocreature> what other documentation do you expect for documenting changes than a changelog?
13:37:38 <orzo> I wanted a section under "9.3. Syntactic extensions" on https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
13:37:41 <danilo2> Hi guys! I'm just wondering why we have MonadIO and liftIO if we can use more general PrimMonad and primToPrim funciton which works like liftIO but also works in ST ?
13:37:44 <michi7x7> oh, sorry
13:38:09 <orzo> i was asking for syntax changes to Haskell
13:38:14 <orzo> not syntax changes over time
13:38:31 <cocreature> oh ok, sorry I missunderstood your question
13:39:07 <cocreature> orzo: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=templatehaskell#ghc-flag--XTemplateHaskell
13:39:17 <cocreature> “Template Haskell has the following new syntactic constructions. …”
13:39:17 <michi7x7> again, is there a library function for [ [a,b],[c],[d] ] -> [ [a,c,d],[b,c,d] ] ?
13:39:33 <jle`> danilo2: historical reasons perhaps
13:39:45 <jle`> michi7x7: what would that even do?
13:40:12 <orzo> thanks, cocreature 
13:40:13 <danilo2> jle`: I suspect so. Hmm Im wondering if there is any proposal to merge it, I cannot find any
13:40:21 <glguy> > transpose [ [a,c,d],[b,c,d] ] -- this is close
13:40:23 <lambdabot>  [[a,b],[c,c],[d,d]]
13:40:30 <jle`> oh, are those meant to be values
13:40:38 <glguy> > transpose [[a,b],[c,c],[d,d]]
13:40:39 <lambdabot>  [[a,c,d],[b,c,d]]
13:43:02 <michi7x7> jle`: yeah sorry, values of the same type. I'm working in a List Monad and have a list of candidates for each 0 < i < n. I wan't to work on every possible array [x_0, x_1, x_n] where x_0 is either a or b in my example
13:44:21 <jle`> can you maybe write an implementation from scratch
13:44:28 <jle`> and maybe we can identify if there's a library function that does it
13:45:07 <michi7x7> I'll try
13:45:52 <jle`> or maybe a couple more examples, it's not exactly clear what you want i think
13:45:56 <Tuplanolla> > sequenceA [[a, b], [c], [d]] -- Let me try mind reading, michi7x7.
13:45:58 <lambdabot>  [[a,c,d],[b,c,d]]
13:46:19 <sphinxo> How can I add some pragma to ignore a specific orphan instance
13:46:25 <sphinxo> if this is possible
13:46:35 <sphinxo> which I seem to remember seeing
13:46:53 <michi7x7> jle`: https://gist.github.com/michi7x7/cf6c2cd15a4d525712862658e337b8f3
13:47:15 <michi7x7> Tuplanolla: oh, that's about right. thanks :)
13:47:47 <jle`> what you gave is close to sequenceA
13:48:38 <michi7x7> I still don't understand Applicative very much, but I'm learning
13:56:10 <jle`> michi7x7: if you understand monad, you can understand it in terms of applicative :)
13:56:18 <jle`> i mean, you can understand applicaive in terms of monad
13:56:23 <jle`> initially
13:56:34 <jle`> and then realize that the pattern applies to other things that aren't monads, as well
13:56:55 <jle`> michi7x7: also, for lists ([]), sequenceA is the same thing as sequence
14:00:53 <orzo> what would it take to ensure unsafePerformIO is safe with a given use of template-haskell's runQ ?
14:01:39 <orzo> can ST implement Quasi?
14:05:23 <orzo> hmm, Quasi demands qRunIO
14:05:32 <orzo> making it somewhat useless
14:07:03 <orzo> maybe i could simply error out for qRunIO in an Quasi ST instance?
14:07:20 <orzo> it says "(dangerous)" in the doc
14:07:35 <orzo> i can probably assume that it's not fundamentally used
14:09:16 <orzo> maybe i could just put the IO action into a list without running it
14:10:13 <michi7x7> jle`: yeah, but there is still a small gap between understanding the concepts and identifying places to use them. Guess I stil have to work on that. Thanks anyway :)
14:13:37 * hackagebot hapistrano 0.3.2.3 – A deployment library for Haskell applications – https://hackage.haskell.org/package/hapistrano
14:25:47 * hackagebot universum 0.5.1.1 – Custom prelude used in Serokell – https://hackage.haskell.org/package/universum
14:40:58 * hackagebot conduit-algorithms 0.0.2.0 – Conduit-based algorithms – https://hackage.haskell.org/package/conduit-algorithms
15:01:07 <crucify_me> hi this is in a textbook, and I don't know what 'well-typed' means in this -- or any -- case  " There are, is some cases, terms in Haskell which can be well-typed but which have no principal type. In those cases, an explicit type annotation must be added."
15:01:48 <Jake_Smith> I can't say for sure but I'll take a whack
15:01:54 <byorgey> crucify_me: well-typed just means there is some type that can be assigned to them, which is valid according to the type system being used
15:02:05 <byorgey> that is, according to the typing rules
15:02:19 <Jake_Smith> That typically means that in some cases you can figure out a values type. For example, "Hello" is a String
15:02:32 <Jake_Smith> 1 on the other hand could be an Int, Double, etc.
15:03:04 <byorgey> but 1 does have a principal, i.e. most general type in Haskell, namely   Num a => a
15:03:20 <byorgey> so that's not an example of what that sentence is talking about
15:03:30 <crucify_me> ok, thank you, this is under a synopsis of type inference.  oh ok so principle means most general.
15:03:36 <byorgey> right.
15:04:27 <crucify_me> one moment
15:06:14 <crucify_me> so this is saying that a String must  be explicitly defined in an annotation because it doesn't have a principal type ? I think I have that backwards.
15:09:06 <jared-w> Hmm
15:11:17 <crucify_me> no String can be inferred easily , so I had it backwards
15:11:27 <jared-w> In Unboxed Vector, why is the index paramater an Int?
15:14:22 * hackagebot viewprof 0.0.0.8 – Text-based interactive GHC .prof viewer – https://hackage.haskell.org/package/viewprof
15:14:31 <Logio> as opposed to what, jared-w?
15:15:03 <Tuplanolla> `Integer`, for all your infinite-memory needs!
15:16:29 <jared-w> The real reason I'm asking is that https://gist.github.com/Porges/9ca15a9ec01bf055edcd88394496dbe3 the code here seems to break at a size of around 10^7 and it's giving an error of "foo: ./Data/Vector/Generic.hs:245 ((!)): index out of bounds (-2147483648,1000) " which just screams "integer overflow" to me
15:18:21 <MarcelineVQ> looks like http://chrisdone.com/posts/twitter-problem-loeb
15:18:23 <kadoban> jared-w: Any particular one? There seems to be like 20 code listings.
15:18:58 <jared-w> oh, sorry, any of the ones involving Data.Vector.Unboxed have the issue, I believe. I'm compiling the code on my laptop right now to test it out for myself
15:19:12 <kadoban> Oh okay *looks*
15:21:10 <jared-w> Does it bug anyone else that you have to guess the package name if you're given a list of imports and want to put them in a cabal file?
15:21:19 <sm> sure
15:21:32 <hpc> cabal init can figure it out to some extent
15:21:40 <sm> stack script too, I think
15:21:43 <jle`> if the package is in scope, ghc should tell you what packages have a given import
15:22:19 <jle`> i mean, if the package is visible to ghc
15:22:22 <jle`> even if it isn't included in the cabal file
15:22:47 <jared-w> oh neat, didn't know that. Learn something new everyday :)
15:23:06 <jle`> sometimes the package isn't installed yet (if you're in a clean stack cache) so it doesn't show up
15:23:13 <jle`> also for some reason ghc 8.2 isn't showing this to me anymore
15:24:11 <Tuplanolla> It seems a little suspicious that your vector has only 1000 elements, but the index already rolls over, jared-w.
15:24:18 <sm> https://github.com/commercialhaskell/stack/issues/1944#issuecomment-313910059
15:24:21 <jared-w> Yeah I'm not quite sure what's up with that ¯\_(ツ)_/¯
15:24:44 <jared-w> I'm gonna run the code on my computer and see if I can reproduce the error--the guy who had the issue is running GHC 7.6 so it might've been fixed already
15:25:09 <Tuplanolla> My hunch is that it's a bug in `vector` itself.
15:28:27 <Tuplanolla> > -2147483648 + 2 ^ 31 -- This also suggests that the wrong index is constant instead of an overflowed intermediate.
15:28:29 <lambdabot>  0
15:29:29 <jared-w> yeah, I think you're right. I'm about to find out, either way :p
15:33:48 <jared-w> Yup, 10^7 doesn't break on my computer.
15:35:16 <phadej> jared-w: in fact you don't need to guess he package name if you're given a list of imports
15:36:08 <jared-w> You don't?
15:36:30 <phadej> jared-w: stack exec ghc-pkg -- find-module Control.Lens
15:36:45 <jared-w> oh nice, I'll keep that in mind
15:36:59 <Tuplanolla> Does that only search installed packages, phadej?
15:37:26 <phadej> Tuplanolla: yes
15:37:33 <phadej> Tuplanolla: for the whole world one can use https://www.stackage.org/lts-9.0/hoogle?q=Control.Lens
15:38:33 <phadej> well, not "whole world", but useful part of it
15:39:11 <jared-w> ahh, so it wouldn't be super useful for me if I don't have any installed packages then
15:43:45 * hackagebot hapistrano 0.3.2.4 – A deployment library for Haskell applications – https://hackage.haskell.org/package/hapistrano
15:44:15 <jesyspa> Hi, I'm on Arch Linux and have had GHC installed for a while, and it used to work.  But now, when I try to compile even a simple hello world, I get http://codepad.org/rYUoh2Lc .  Any idea what might be causing this or how I could fix it?
15:45:13 <jared-w> So, yeah...
15:45:51 <jared-w> Arch Linux has started dynamically linking GHC and it's a pain in the ass to get anything working with it. I recommend purging your entire system of all GHC/haskell stuff and then using ghc-static (or just pure stack)
15:45:58 <koz_> jesyspa: I guess someone forgot to recompile a bunch of packages in the Arch repos. My suggestion is 'wait for an update'.
15:46:05 <koz_> And the 'use stack' makes for good advice.
15:46:11 <koz_> I do it and I've never looked back.
15:46:21 <jesyspa> Hmm, thanks, I'll take a look at that.
15:46:41 <jared-w> koz_: no it's really the whole mess with dynaic linking. Haskell expects static linked things and Arch forces dynamic linked things. You need to explicitly tell GHC to expect dynamically linked stuff or the linker won't be able to find anything
15:46:46 <jesyspa> Purging everything is an option, but I'm using XMonad, and I'd rather not be stuck in a terminal when I get it wrong...
15:47:01 <koz_> jesyspa: For your own Haskell dev work I mean.
15:47:04 <jared-w> oh right, xmonad... That complicates things
15:47:26 <koz_> jared-w: Ah, I see.
15:47:35 <jared-w> I'd install ghc-static from the repos
15:47:56 <jared-w> Hopefully that'll fix everything for you
15:48:01 <jesyspa> Thanks, let me try.
15:48:17 <jesyspa> Well, it links the test file, that's a start :)
15:48:35 <jesyspa> Yep, looks like it all works now, great!
15:48:54 <koz_> jesyspa: Yay!
15:49:06 <jared-w> awesome. If ghc-static works for you, feel free to keep using it. In any case, it might be worthwhile figuring out how to use a pure stack or pure sandboxy sort of solution, but that's a little trickier with xmonad
15:49:40 <jared-w> (for what it's worth, I have a static version of stack installed and then I use stack to install a version of ghc which I manually stick in my global path. Not the, ahem, best solution... but it works for me)
15:50:01 <jesyspa> I've heard stack mentioned, but never really looked into it; is there some quick intro I could read?
15:50:10 <koz_> jesyspa: Check their website.
15:50:23 <koz_> They have a user's manual with a 'getting started' section which is eminently readable.
15:50:42 <Tuplanolla> It's too bad their documentation is seriously lacking everywhere else.
15:50:42 <jesyspa> Thanks, will give that a try.
15:50:58 <koz_> Tuplanolla: Yeah, I'm starting to notice that now...
15:52:24 <koz_> Is the naming of different recursion schemes an exercise in how much Greek people know?
15:52:38 <koz_> I'm reading one paper about it, and it talks about zygomorphisms and histomorphisms.
15:52:44 <koz_> And I'm like 'huh?'.
15:53:29 <jared-w> lol
15:53:51 <jared-w> http://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/ this series goes through the greek meanings of all the names so you can decipher it a bit, if that helps
15:53:52 <exio4> I just want to rant, https://hackage.haskell.org/package/midi-0.2.2.1/docs/Sound-MIDI-File-Load.html - the type signatures are a bit ... hard, to read
15:54:15 <koz_> jared-w: I don't think it mentions zygo or histomorphisms.
15:54:27 <koz_> It goes through ana, cata, para and hylo, I think.
15:54:36 <jared-w> oh, no, it doesn't. I don't think that series goes quite as far as that :p
15:54:53 <koz_> jared-w: At least this paper presents some Haskell code.
15:55:01 <koz_> Which makes it about 100% more comprehensible.
15:55:10 <jared-w> lol which paper is that?
15:55:14 <Tuplanolla> Yeah, it's Thielemann's, exio4. Don't use it.
15:55:43 <exio4> Tuplanolla: why not? and what packages would be recommended for reading/writing MIDI files?
15:55:47 <koz_> "Recursion schemes from comonads"
15:55:56 <koz_> By Uustalu and Vene.
15:56:03 <koz_> (yes, I had to double-check the spelling)
15:56:43 <jared-w> sweet, I'll give that a read sometime
15:56:56 <Tuplanolla> I don't know, but he calls all types `T` and all classes `C`, exio4.
15:56:59 * jared-w adds to gigantic ever-growing list of papers to read before he dies of old age
15:57:16 <koz_> jared-w: If you do, maybe you and I can compare notes. I like the sound of its premise, but I'm having trouble making sense of it even with a large coffee in my system.
15:57:39 <exio4> Tuplanolla: alright, I am not going to keep checking this haha
15:57:46 <koz_> Although it might be because I've not read it enough times.
15:59:00 <jared-w> good god, that midi library is a nightmare to read through
15:59:28 <koz_> jared-w: How bad could it be?
15:59:34 <jared-w> https://hackage.haskell.org/package/midi-0.2.2.1/docs/Sound-MIDI-KeySignature.html
16:00:26 <koz_> Is this person a Java programmer perchance?
16:00:29 <koz_> I see a lot of T.
16:00:39 <jared-w> and every class is called C
16:00:48 <MP2E> yeah this is quite confusing
16:00:59 <geekosaur> no, just someone who believes the module name should identify the tyoe
16:01:02 <geekosaur> *type
16:01:32 <koz_> So wait, you'd have stuff like:
16:01:34 <jared-w> The other thing that bugs me is the ridiculous amount of type aliases
16:01:41 <jared-w> https://hackage.haskell.org/package/midi-0.2.2.1/docs/Sound-MIDI-File-Event-Meta.html
16:01:54 <jared-w> Semi useful for /writing/ code but does absolutely nothing for type safety and makes error messages utterly useless
16:01:59 <koz_> baz :: (Foo.C f, Bar.C g) => f Foo.T -> g Bar.T -> Baz.T ?
16:02:09 <jared-w> koz_: yeah. See: https://hackage.haskell.org/package/midi-0.2.2.1/docs/src/Sound-MIDI-File-Load.html#fromFile
16:02:26 <MP2E> ah ok well that at least makes a bit more sense
16:02:39 <jared-w> parse :: Parser.C parser => Parser.Partial (Parser.Fragile parser) MIDIFile.T  -- for example
16:02:42 <exio4> T (T T) -> T -> T -> T T 
16:03:34 <koz_> exio4: You mean (C c, C d) => c T (T T) -> d T -> T -> c T
16:03:36 <koz_> >
16:03:38 <koz_> ?
16:03:45 <exio4> koz_: hah
16:04:00 <koz_> Should have used c and c'.
16:04:10 <jared-w> But don't worry; you can stick anything anywhere because they're all the same T and C -_-
16:04:21 <koz_> It's like the type signature for 'confusing'.
16:04:25 <koz_> :t confusing
16:04:26 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
16:04:45 <glguy> % :i confusing
16:04:46 <yahb> glguy: confusing :: Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b -- Defined in `Control.Lens.Traversal'
16:05:10 <hpc> is that a real thing?
16:05:15 <koz_> hpc: Very much so.
16:05:20 <koz_> It's in Control.Lens.
16:05:26 <koz_> The all-singing, all-dancing one.
16:05:42 <jared-w> Of course, Control.Lens is basically cheating if you're trying to find examples of "scary type signatures" :p
16:05:51 * koz_ loves the 's t a b' type sigs in Lens.
16:06:04 <koz_> My favourite is probably the one which is 's t a b -> b a t s'.
16:06:10 <jared-w> lol
16:06:21 <koz_> I think it's in Iso, but I forget exactly what.
16:06:29 <glguy> % :i from
16:06:29 <yahb> glguy: from :: AnIso s t a b -> Iso b a t s -- Defined in `Control.Lens.Iso'
16:06:40 <koz_> Thanks glguy!
16:07:17 <koz_> jared-w: I think 'confusing' gets picked out as a good example because it's so appropriately-named.
16:15:52 <Profpatsch> Is there someone megaparsec knowledge around?
16:16:08 <Profpatsch> I have a parser using nested indentBlocks
16:16:19 <Profpatsch> And somewhere inside the second nesting a symbol parser fails.
16:16:57 <Profpatsch> Now my parser backtracks into the first indentBlock layer and reports an “indentation is 5 but should be 3” error.
16:17:16 <Profpatsch> Ideally, it should tell me “expected symbol”
16:17:43 <Profpatsch> How can I prevent the unnecessary backtracking?
16:18:29 <Profpatsch> https://hackage.haskell.org/package/megaparsec-5.3.1/docs/Text-Megaparsec-Lexer.html#v:indentBlock
16:31:51 <anelson-> hi guys, is there any reason why I would be able to see a package (servant) listed in the output of `ghcjs-pkg list`, and yet not be able to `import Servant` when I'm in `cabal repl`?
16:32:16 <glguy> anelson-: Only the packages listed in a package's build-depends will be available inside cabal repl
16:32:28 <anelson-> glguy: yeah, it's in the list
16:32:49 <glguy> and cabal repl probably isn't using ghcjs
16:33:00 <glguy> but I don't use much ghcjs, so I could just be wrong about that
16:33:01 <anelson-> well I'm using cabal configure --ghcjs
16:33:13 <anelson-> and it certainly appears to be using ghcjs, ghcjsi actually
16:33:51 <anelson-> there's one other weird thing which is that when I run `cabal configure` it tells me that a bunch of fields are unrecognized, like "name", "version", "author", etc
16:34:23 <glguy> Sounds like your cabal file has a problem, put it on a pastebin?
16:35:22 <anelson-> glguy: http://lpaste.net/7074389930599776256
16:36:30 * hackagebot hexml-lens 0.1.1 – Lenses for the hexml package – https://hackage.haskell.org/package/hexml-lens
16:36:51 <glguy> anelson-: It looks like the problem is: Warning: my-frontend.cabal: Unknown fields: cpp-options (line 8)
16:37:00 <glguy> you need to move that into the executable section
16:37:11 <anelson-> hmm, lemme give that a shot
16:37:25 <glguy> The rest of the message is telling you what the valid fields are, not that they aren't recognized
16:38:12 <anelson-> ah, ok I guess I was misreading that
16:38:22 <anelson-> cool, so the unrecognized field stuff went away
16:38:28 <anelson-> but, I still can't import servant...
16:38:30 <anelson-> :(
16:39:09 <anelson-> how does ghc(js) discover modules to import?
16:39:12 <glguy> anelson-: the servant package doesn't export a Servant module
16:39:48 <anelson-> glguy: it does when I'm using ghc...?
16:39:51 <glguy> no
16:39:56 <anelson-> I can run `import Servant` in my repl
16:39:59 <anelson-> and in my code
16:40:05 <glguy> Then that's a different package
16:40:15 <anelson-> ohhh... womp womp
16:40:17 <anelson-> any idea which one?
16:40:23 <glguy> ghc-pkg find-module Servant
16:40:44 <anelson-> ohh that's super helpful! teach a man to fish and all that :) thanks!
16:43:36 * hackagebot cmark-patterns 0.1.0.0 – Pattern synonyms for cmark – https://hackage.haskell.org/package/cmark-patterns
16:43:36 * hackagebot smartcheck 0.2.3 – A smarter QuickCheck. – https://hackage.haskell.org/package/smartcheck
16:55:19 <Welkin> what about the balance of the ecosystem!
16:55:24 <Welkin> you can't teach everyone to fish
16:55:28 <Welkin> then there will be no more fish
16:55:32 <Welkin> and the ecosystem will collapse
16:56:02 <hpc> this is why you teach everyone to fish poorly
16:56:24 <hpc> then there will be more fish than if nobody was fishing
16:56:28 <hpc> that's how it works you know
16:56:54 <Welkin> how would there be *more* fish than is no one was fishing?
16:57:03 <Welkin> do the fish breed out of fear?
16:57:28 <hpc> because the bad programmers make more problems for the good programmers to solve
16:57:46 <tommd> So bad fishers make more fish?
16:57:57 <hpc> that's how it works
16:58:00 <hpc> metaphors are never wrong
16:58:06 <glguy> Maybe bad fishers are actually just fish
16:58:10 <glguy> and fish make fish
16:58:24 <hpc> teach a man to fish and he blub blub blub
16:59:00 <exio4> just be careful, you might teach someone about phising 
16:59:14 <Welkin> I'm reminded of David Foster Wallace's graduation commencement speech "What (the fuck) is water?"
16:59:24 <hpc> link?
16:59:49 <hpc> oh right, i can google things too!
17:00:01 <Welkin> oh
17:00:02 <Welkin> https://www.youtube.com/watch?v=8CrOL-ydFMI
17:00:06 <Welkin> it's called "This is water"
17:00:16 <Welkin> he opens with a short story about fish
17:01:16 * hackagebot concrete-haskell 0.1.0.14 – Library for the Concrete data format. – https://hackage.haskell.org/package/concrete-haskell
17:35:20 * hackagebot collection-json 1.0.1.0 – Collection+JSON—Hypermedia Type Tools – https://hackage.haskell.org/package/collection-json
17:51:49 <Lokathor> Two random variables were talking in a bar. They thought they were being discrete but I heard their chatter continuously.
17:53:20 * c_wraith throws tomatoes
17:54:37 <hpc> could you even tell them apart? in my experience random variables are impossible to differentiate
17:55:24 <MarcelineVQ> boo-urns
18:03:29 <koz_> I have something similar to 'foo (foo (foo x 9) 11) 19'. Can I write this in a less hideous manner?
18:04:19 <Cale> foldl foo x [9,11,19]
18:05:33 <koz_> Cale: D'oh! Thanks.
18:05:46 <Welkin> lol
18:05:47 <Welkin> yeah
18:05:52 <Welkin> that's exactly foldl'
18:11:40 <Koterpillar> I want to tokenize some strings, and have made a string-like type that stores information about the source location of each character. Is there a nice typeclass I can reuse to have at least some goodies from, say, Data.Text (splitOn, isSuffixOf, etc.)? I can do everything from mono-traversable but it doesn't help much.
18:15:02 <koz_> Are there operators (other than freezing and thawing) for working with mutable unboxed vectors? I can't seem to find them anyplace.
18:15:09 <Cale> Welkin: Well, it's exactly foldl, foldl' would involve doing a bunch of explicit seq'ing
18:15:24 <koz_> Cale: I happen to need strictness in my case.
18:15:35 <koz_> So Welkin successfully read my mind. :P
18:34:39 <dmwit> tommd: Thanks.
18:35:09 <dmwit> ?tell crucify_me ...the entire right-hand side is indeed a lambda-calculus term, and the `x` in the body of that lambda is definitely bound.
18:35:09 <lambdabot> Consider it noted.
18:38:57 <koz_> What package is 'unless' from again?
18:39:05 <koz_> GHC is suggesting I need mtl, which can't be right.
18:40:14 <dmwit> ?hoogle unless
18:40:15 <lambdabot> Control.Monad unless :: (Applicative f) => Bool -> f () -> f ()
18:40:15 <lambdabot> Shelly unless :: Applicative f => Bool -> f () -> f ()
18:40:15 <lambdabot> Shelly.Lifted unless :: Applicative f => Bool -> f () -> f ()
18:40:24 <koz_> dmwit: Thanks!
18:44:20 <koz_> Writing an in-place, initializing, Fisher-Yates on a bitvector based on a mutable vector of unboxed Words is ... hurting my brain.
18:49:43 <kadoban> That shuffle thing?
18:51:22 <koz_> kadoban: Yes, that shuffle thing.
19:07:23 <AnjiBaiCha> Hey, could anyone recommend a good Haskell learning resource, preferably a textbook? I'm using Learn You a Haskell right now, and I really don't like it.
19:08:41 <Jeanne-Kamikaze> The other popular one is Real World Haskell, and for more resources you have: https://wiki.haskell.org/Learning_Haskell
19:08:55 <koz_> The Wikibook for Haskell is also pretty good.
19:11:57 <AnjiBaiCha> koz_: Is this what you're talking about? https://en.wikibooks.org/wiki/Haskell
19:14:39 <koz_> AnjiBaiCha: Yes.
19:16:23 <koz_> Also, is there something like when (or unless, I suppose) where I do one action if f is False, and a different one if it's True?
19:16:41 <Jeanne-Kamikaze> :t unless
19:16:43 <lambdabot> Applicative f => Bool -> f () -> f ()
19:17:11 <koz_> Jeanne-Kamikaze: Both when and unless have a 'do nothing' if the Bool is False and True respectively.
19:17:21 <Jeanne-Kamikaze> Hmm
19:17:23 <koz_> I want something like Bool -> f () -> f () -> f ()
19:17:34 <Jeanne-Kamikaze> :t Bool -> f () -> f () -> f ()
19:17:36 <lambdabot> error: parse error on input ‘->’
19:17:45 <Jeanne-Kamikaze> I thought it did reverse lookups
19:19:19 <AnjiBaiCha> koz_: Yeah this looks like a really good resource. Thanks!
19:19:58 <koz_> I can do it with an if-then-else, but I was wondering if there was some monadic sorcery I could employ instead.
19:20:12 <koz_> AnjiBaiCha: You're welcome - hope it helps you as much as it helped me.
19:29:08 * hackagebot lmdb-simple 0.3.1.0 – Simple API for LMDB – https://hackage.haskell.org/package/lmdb-simple
19:31:51 <koz_> ?hoogle forM_
19:31:51 <lambdabot> Control.Monad forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
19:31:51 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
19:31:51 <lambdabot> Data.Vector forM_ :: Monad m => Vector a -> (a -> m b) -> m ()
19:37:15 * hackagebot recursion-schemes-ext 0.1.0.0 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
19:41:04 <XorSwap> @hoogle Bool -> f () -> f () -> f ()
19:41:05 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
19:41:05 <lambdabot> CorePrelude until :: (a -> Bool) -> (a -> a) -> a -> a
19:41:05 <lambdabot> FRP.Elerea.Simple.Pure until :: (a -> Bool) -> (a -> a) -> a -> a
20:10:08 <dfeuer> edwardk?
20:19:10 <ReinH> :t bool
20:19:11 <lambdabot> a -> a -> Bool -> a
20:27:45 <jared-w> dfeuer: he's probably still sleeping since we kept him up until like 4-5am :p
20:28:00 <dfeuer> jared-w: why'd you do that? And how?
20:29:11 <jared-w> Well someone mentioned category theory and it went downhill from there lol
20:32:25 <jared-w> But for real, he mentioned that he had a work appointment at 10am his time so he might've been a bit too tired to get on the IRC? ¯\_(ツ)_/¯
20:44:15 * hackagebot metrics 0.4.1.1 – High-performance application metric tracking – https://hackage.haskell.org/package/metrics
20:47:50 <jle`> just what i always needed, a library to convert centimeters to meters
20:51:19 <jared-w> in *high performance*
21:00:57 <pacak> In IO monad O_O
21:06:36 <joe9> stack build --profile: does it add the -prof flag?
21:06:42 <mniip> jle`, nonono
21:06:51 <mniip> it tracks general relativity spacetime metric for you
21:07:10 <mniip> like, how else are you going to find out you're approaching a compact body?
21:07:22 <mniip> can you distinguish a swarzchild metric from a kerr-newman?
21:09:36 <jared-w> only if you measure in parsecs, clearly
21:10:22 <joe9> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when used on a library. Use the configure flag --enable-library-profiling and/or --enable-profiling.
21:10:33 <joe9> is what I get when I add -prof to the ghc-options of cabal
21:10:48 <joe9> does stack build --profile , add the --enable-profiling flag?
21:13:37 <mniip> jared-w, eeeeh maaaaybe milliparsecs
21:13:46 <mniip> for the largest blackholes out there ever
21:15:36 <jared-w> Is it really the best metric though? How can you tell if the black-hole is webscale by using parsecs? Not sure you really can...
21:15:39 <mniip> normally you'd be looking at picoparsecs
21:16:49 <mniip> if your blackhole isn't webscale you could use devnull as a service
21:21:55 * hackagebot composition-prelude 0.1.0.0 – Higher-order function combinators – https://hackage.haskell.org/package/composition-prelude
21:35:06 * hackagebot vivid-osc 0.3.0.0 – Open Sound Control encode/decode – https://hackage.haskell.org/package/vivid-osc
21:41:41 <xyh> can stack delete some file to save space ? ::  https://fars.ee/0Wu0
21:42:06 <MarcelineVQ> not really when it comes to indices
21:43:23 <MarcelineVQ> you can remove anything else in .stack/ to save space, particualrily things in the snapshots folders, they'll be rebuilt as needed. indiced is always basically that size though
21:43:29 <MarcelineVQ> *indices
21:50:18 * hackagebot selections 0.1.0.2 – Combinators for operating with selections over an underlying functor – https://hackage.haskell.org/package/selections
21:50:46 <zekt> Hi guys, I'm implementing a simple language in Haskell as practice,  I'm now defining the behavior of evaluation, I'm wondering if there's a way to check if two values of the same data type are constructed by the same constructor?
21:51:21 <jle`> zekt: if your type is an instance of Data
21:51:46 <jle`> > toConstr (Just True) == toConstr (Just 'a')
21:51:48 <lambdabot>  True
21:52:21 <jle`> Data basically just automatically generates utility functions like these
21:52:23 <jle`> for your types
21:52:32 <xyh> try to run 'stack setup', but it seem my disk (16G) is not enough to run it.
21:52:55 <xyh> how much space is need for stack ?
21:53:59 <MarcelineVQ> not that much. but stack often uses /tmp  so if for some reason there isn't enough space there it might fail
21:54:08 <pacak> xyh: stack will take all the space it can reach :)
21:54:28 <kadoban> xyh: GHC uses a lot, I wouldn't be surprised if 16G is not enough.
21:54:56 <MarcelineVQ> there's really no reason for   stack setup  specifically to use more than 2 gigs on a bad day, it downloads binaries
21:55:35 <zekt> jle`: oh thanks, it's just a normal data type for now,  I think I can achieve that by pattern match all the same constructors, but since I can do that it somehow seems weird to me I can't do it all in once
21:55:55 <zekt> would try to use toConstr
21:56:10 <jle`> it's a normal data type but you can derive Data
21:56:21 <jle`> @let data MyData = MD1 | MD2 deriving Data
21:56:23 <lambdabot>  Defined.
21:56:32 <jle`> > toConstr MD1 == toConstr MD2
21:56:34 <lambdabot>  False
21:56:52 <xyh> alas ~
21:57:23 <jared-w> what does deriving Data do?
21:57:30 <jle`> it derives an instance of the Data typeclass
21:57:41 <jle`> just like deriving (Show, Eq, Ord, Data, Generic, Functor,  ... etc.)
21:57:53 <jared-w> Well, I got that part. I should've asked what the Data typeclass does :p
21:58:24 <davidthomas> Is there any way, from a postBuild cabal hook in a custom Setup.hs, to tell what executables have actually been rebuilt?
21:58:54 <pacak> jared-w: Data.Data
21:59:33 <jle`> Data.Data has utility functions for dealing with like, constructors and stuff like that
21:59:44 <jared-w> ahh, scrap your boilerplate kinda stuff, I gotcha
22:00:08 <MarcelineVQ> > toConstr 12 -- :>
22:00:10 <lambdabot>  12
22:00:34 <jle`> cute
22:00:34 <MarcelineVQ> But which 12!
22:00:55 <jared-w> :t toConstr 12
22:00:57 <lambdabot> Constr
22:01:01 <joe9> attoparsec seems to be killing my performance with garbage collection.  http://bpaste.net/show/69348881587e . just want to check if I am reading this correct
22:01:16 <jared-w> MarcelineVQ: it's the "Constr" 12, apparently :p
22:01:48 <jle`> i mean, if you think of data Int = ... | -2 | -1 | 0 | 1 | 2 | ...
22:02:04 <pacak> joe9: Are you compiling with optimizations?
22:03:04 * hackagebot selections 0.1.0.3 – Combinators for operating with selections over an underlying functor – https://hackage.haskell.org/package/selections
22:03:49 <jared-w> oh hey, examples in the readme!
22:03:53 <jared-w> +1 selections
22:05:22 <joe9> pacak: no, I thought optimizations are added in by default.
22:05:34 <joe9> pacak: do I need to add -O2 to ghc-options of the cabal file?
22:05:45 <jared-w> yup
22:05:49 <pacak> Or -O1
22:05:52 <pacak> Or -O
22:47:06 * hackagebot DeepDarkFantasy 0.2017.8.8 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
22:49:24 <jared-w> Quick, somebody make a convolutional neural network and call it MyBeautifulDarkTwistedFantasy
22:51:02 <Marisa> Hi, I am writing hs with a lot of LanguageExtension, and I have to type them in everytime I add new hs file, can I use TH or something to automate that?
22:51:19 <mac10688> add them to cabal file
22:51:30 <[exa]> Marisa: automatically pass them as options to ghc
22:51:59 <Marisa> Oh cool, I'll look it up, thx
22:52:52 <pacak> Is there anything faster than attoparsec out there? ByteString, no backtracking, don't care about errors, return leftovers?
22:53:05 <Axman6> there are tools which can add them for you, but I can't remember which ones offer that
22:53:31 <Axman6> pacak: check out the Zepto parser in attoparsec: https://hackage.haskell.org/package/attoparsec-0.13.2.0/docs/Data-Attoparsec-Zepto.html
22:53:44 <jared-w> iirc stack will do it for you in the stack.yaml? There might be one or two other tools out there but they're fairly niche I think
22:54:23 <pacak> Axman6: No leftovers plus I already have something that's faster.
22:59:17 * hackagebot hasmin 0.3.2.4 – CSS Minifier – https://hackage.haskell.org/package/hasmin
23:01:11 <cocreature> pacak: https://github.com/winterland1989/binary-parsers claims that it’s faster than attoparsec but I have never tried it myself
23:04:46 <[exa]> btw are there parsers that would basically compile down to flex-like parser tables?
23:07:23 <pacak> cocreature: Looks about right, thanks.
23:08:37 <cocreature> [exa]: afaik happy compiles down to that
23:08:54 <cocreature> I might be wrong
23:09:12 <[exa]> cocreature: yeah happy is compiler-compiler
23:09:45 <[exa]> I was expecting something that only requires ghc and partially evaluates to the table
23:10:13 <[exa]> like Accelerate compiles data structures to cuda or similar
23:11:25 <glguy> Earley has such a pass, I think
23:12:01 <Athas> You could do that, but you would get shift/reduce errors and the like at run-time.
23:13:03 <cocreature> that should make the people that like dynamic languages happy
23:15:03 <[exa]> Athas: yeah I guess it would be hard for a package to present shift-redure errors as ghc errors :D
23:15:11 <[exa]> good point though, thanks
23:15:20 <[exa]> glguy: gonna check it out, thx
23:18:50 <Athas> [exa]: you could abuse Template Haskell/quasiquoting to do it at compile-time.
23:18:56 <Athas> But it's a lot of complexity to avoid Happy!
23:19:55 <[exa]> yeah
23:19:59 <[exa]> TH is an overkill I guess
23:20:14 <[exa]> "I had a dream about in-language compiler-compilers"
23:20:21 <[exa]> :]
23:28:33 * koz_ finally knows of a use for comonads.
23:28:41 <koz_> I somehow feel like that's progress.
23:28:59 <thimoteus> right now i'm reading http://dlaing.org/cofun/posts/free_and_cofree.html
23:30:21 <koz_> thimoteus: Thanks - that looks very interesting!
23:32:16 <koz_> :t liftF
23:32:17 <lambdabot> error:
23:32:17 <lambdabot>     • Variable not in scope: liftF
23:32:17 <lambdabot>     • Perhaps you meant one of these:
23:32:29 <[exa]> koz_: please share the use! :]
23:32:34 <koz_> [exa]: Streams.
23:32:54 <koz_> There's a very good paper, with very good Haskell to go with the category theory, on exactly how comonads apply.
23:33:03 <koz_> Called 'the essence of dataflow programming'.
23:33:08 <[exa]> hm, yeah
23:33:17 <koz_> It also had the convenient effect of helping me see FRP in a new light.
23:37:55 <hulufei> Hello, I'm confused with `$ 5`, I suspect `($)` can only partial apply to it's first argument which is a function, how can `$ 5` happened?
23:38:38 <Axman6> that's the same as (\x -> x $ 5)
23:38:39 <thimoteus> it's infix notation, shorthand for \ f -> f $ 5
23:38:52 <Axman6> infix functions can be partially applied on either side
23:39:18 <pacak> :t $ 5 -- invalid syntax
23:39:19 <lambdabot> error:
23:39:20 <lambdabot>     parse error on input ‘$’
23:39:20 <lambdabot>     Perhaps you intended to use TemplateHaskell
23:39:24 <pacak> :t ($ 5)
23:39:26 <lambdabot> Num a => (a -> b) -> b
23:39:26 <[exa]> koz_: that's a good read, thanks
23:39:35 * pacak pokes lambdabot
23:40:32 <koz_> [exa]: It is pretty awesome, although the category theory parts are heavy.
23:40:48 <hulufei> Axman6: that's make sense, thanks
23:40:51 <koz_> Luckily, unlike their 'recursion schemes and comonads' paper, you can actually skip them completely and still get the point.
23:42:24 <jared-w> koz_: have you seen the cannonical example of comonads? (Finite automota a la conway's game of life). I'm sure you have, but that's one use of comonads at least :p
23:42:32 <[exa]> yeah, looks a bit like reviewer intervention :D
23:42:36 <koz_> jared-w: I found that one impossible to follow.
23:42:42 <jared-w> Not sure if it's sufficiently 'motivativating' for many people, though
23:42:51 <koz_> Whereas the one in the 'essence of dataflow programming' is like, amazingly screamingly obvious.
23:43:11 <[exa]> koz_: btw have you seen the object notation for comonads?
23:43:17 <jared-w> koz_: even the series that edwardk wrote on school of haskell?
23:43:24 <koz_> [exa]: Gabriel's blog post you mean?
23:43:41 <jared-w> [exa]: I saw it. It was nifty, but then I read the rebuttal post "comonads are not objects" and became both mildly amused and mildly confused :p
23:43:41 <koz_> jared-w: Anything Edward Kmett writes is amazingly insightful, as long as you have about 10 years to ponder it. :P
23:43:53 <jared-w> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/cellular-automata
23:43:55 <MP2E> hah
23:44:00 <MP2E> :p
23:44:00 <jared-w> idk, I thought this one wasn't impossibly dense lol
23:44:14 <koz_> jared-w: I guess we have different definitions of density.
23:44:18 <[exa]> koz_, jared-w: yes, that one. I wonder if the notation could get fixed to handle streams better
23:44:21 * koz_ mumbles something about Density.
23:44:22 <cocreature> that one is actually reasonably easy to understand
23:44:52 <koz_> Maybe I just don't care enough about cellular automata?
23:44:53 <jared-w> I can sorta skip things in my brain and not fully understand them and then just come back to them later as they sink in slowly ¯\_(ツ)_/¯ so I can read things I don't fully understand and just know I'll get it in a few days
23:45:09 <jared-w> koz_: highly likely. It's a bit abstract and "useless" :p
23:45:14 <koz_> I dunno, never really understood any cellular-automata-based explanations of comonads.
23:45:27 <koz_> But when I saw that stream-based presentation? Instant click and motivation.
23:45:41 <edwardk> koz_: i pretty much started blogging about 10 years ago. i'm expecting that delay to start paying dividends any day now.
23:45:42 <koz_> With the nice effect of also making me see FRP in a new light.
23:45:53 <koz_> edwardk: I haven't started reading your work 10 years ago.
23:46:01 <edwardk> koz_: your loss. =)
23:46:02 <Axman6> koz_: link rto the stream thing?
23:46:05 <koz_> So I won't be getting dividends for a while. :P
23:46:17 <koz_> Axman6: http://cs.ioc.ee/~tarmo/papers/essence.pdf
23:46:35 <koz_> edwardk: However, I still appreciate your work, inasfar as I'm able to understand it. :P
23:46:35 <jared-w> "don't have permission to access"
23:46:47 <koz_> jared-w: Weird, I have no issues.
23:46:48 <jared-w> I'm guessing it's the "essence of the iterator pattern" paper?
23:46:48 <edwardk> actually, i wrote some graphics articles and some magazine articles before that long before i started blogging about haskell, so i guess other communities have had the benefit of the decade lag =)
23:46:55 <thimoteus> i can't access either
23:47:04 <koz_> jared-w: The Essence of Dataflow Programming.
23:47:18 <jared-w> https://pdfs.semanticscholar.org/ad77/ebcb739925559b48adc441d86ea45e7b9900.pdf thimoteus try this one
23:47:28 <thimoteus> ah yep that's working
23:47:30 <thimoteus> thanks jared-w 
23:47:41 <Axman6> koz_: apparently forbidden?
23:47:48 <Axman6> uh, never mind
23:47:56 <edwardk> the main problem with the essence of dataflow programming is the ending is nonsense
23:47:59 <edwardk> up until then it is awesome
23:48:12 <edwardk> but the moment it starts talking about BiKleisli it loses it
23:48:17 <thimoteus> great, now i know how it ends
23:48:23 <jared-w> My guess is that koz_ is on a uni wifi of some sort :)
23:48:29 <jared-w> edwardk: let me guess, the dog dies too? :(
23:48:54 <edwardk> distributive laws for monads and comonads is a terrible way to compose them. if you work out the asymptotic cost of using the semantics they desire in that paper, it is ridiculous
23:49:22 <edwardk> its far better to think about a comonad that lives in a kleisli category or a monad that lives in a cokleisli category.
23:49:34 <jared-w> "but it works, so it can't be that terrible" :p
23:49:40 <koz_> edwardk: I basically ignored the BiKleisli stuff as not relevant.
23:49:50 <koz_> jared-w: I'm not on a uni wifi right now, no.
23:49:59 <edwardk> "it works but won't terminate for any non-trivial examples in my lifetime"
23:50:18 <Axman6> edwardk: pfft, details
23:50:29 <koz_> I loved the fact that the paper actually gave me a concrete reason to care about comonads
23:50:30 <edwardk> sigfpe who is otherwise absolutely amazeballs also wrote up an article on the BiKleisli approach, and missed the plot as well.
23:50:40 <edwardk> koz_: it had the same effect on me
23:50:58 <koz_> edwardk: Well, glad to know I'm following in your footsteps. :P
23:51:09 <jared-w> koz_: now to publish 200 libraries!
23:51:09 <koz_> (even if I understand barely any of the category theory stuffs)
23:51:13 <koz_> jared-w: LOL.
23:51:13 <edwardk> note: they used comonads to talk about semantics. i started using comonads to just talk about normal day to day code, because i didn't understand that about the paper at first =)
23:51:34 <edwardk> my best example of a comonad is the comonad for folds
23:51:51 <edwardk> its probably the best "working man's comonad" i know
23:52:09 <koz_> edwardk: That Estonian duo also published a paper on how distributive comonads generalize recursion schemes.
23:52:18 <koz_> I guess your example is a restricted case of this?
23:52:25 <jared-w> also, edwardk did you ever get any sleep? I'm not sure how you're awake right now :p
23:52:36 <koz_> (I read that paper too, but I have no clue what a zygo-or-histomorphism are)
23:52:43 <edwardk> koz_: they basically stopped thinking about recursion schemes after uustalu's comrec paper
23:52:45 <koz_> jared-w: I could ask you the same question.
23:52:58 <koz_> edwardk: Does that mean there's more work to be done there?
23:53:00 <jared-w> koz_: I'm in the pacific time zone, so it's only midnight here :)
23:53:00 <Axman6> edwardk: folds as in foldl package style folds?
23:53:04 <edwardk> koz_: dynamorphisms let you contort yourself into knots to do some dynamic programming
23:53:10 <edwardk> Axman6: yes, foldl, folds, etc.
23:53:13 <cocreature> Axman6: the foldl package even has a comonad instance :)
23:53:25 <Axman6> cool, thanks
23:53:38 <edwardk> data Fold a b where Fold :: (r -> a) -> (r -> a -> r) -> r -> Fold a b
23:53:47 <edwardk> cocreature: nice, i didn't realize i'd finally shamed him into that =)
23:54:16 <Axman6> (r -> b)?
23:54:17 <cocreature> edwardk: I just found it out myself :)
23:54:20 <edwardk> er r -> b
23:54:27 <edwardk> data Fold a b where Fold :: (r -> b) -> (r -> a -> r) -> r -> Fold a b
23:54:36 <edwardk> i guess gabriel uses the other (wrong) order ;)
23:54:47 <edwardk> r last makes the comonad prettier
23:55:00 <edwardk> and saves a reduction step or two
23:55:02 <cocreature> (x -> a -> x) -> x -> (x -> b) -> Fold a b is the one in foldl
23:55:06 <Axman6> heh
23:55:32 <dfeuer> edwardk: your input on https://github.com/ghc-proposals/ghc-proposals/pull/69 would be appreciated.
23:55:34 <edwardk> duplicate (Fold step begin done) = Fold step begin (\x -> Fold step x done)
23:55:35 <edwardk> becomes
23:56:07 <edwardk> duplicate (Fold done step begin) = Fold (Fold done step) step begin
23:56:32 <cocreature> hm what would you use that instance for?
23:56:48 <Axman6> don't you go breaking my foldl-statistics package. changing that might literally minutes to refactor!
23:56:55 <edwardk> dfeuer: that is more than i can unpack just this moment, but i've added it to my 'i should do something about this' list
23:57:13 <edwardk> cocreature: consider a crc32 calculating fold
23:57:37 <edwardk> crc32 = fold complement updatecrc32 0 . -- or whatever
23:57:41 <edwardk> er Fold
23:57:50 <dfeuer> edwardk: thanks, hopefully, in the future.
23:57:59 <edwardk> now duplicate lets you feed it a prefix of the input and get a 'residue'
23:58:20 <cocreature> oh that makes sense
23:58:23 <cocreature> thanks!
23:58:25 <edwardk> so given feed :: [Word8] -> Fold Word8 a -> a
23:58:46 <edwardk> extend (feed sometext)  -- will give you a Fold that starts from the seed you left off at.
23:58:59 <edwardk> you get 'access' to the intermediate state without knowing anything about its type!
23:59:14 <cocreature> that’s pretty neat
23:59:38 <edwardk> this serves as a good working model for things like CRCs, cryptographic hash functions, etc.
