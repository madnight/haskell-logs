00:02:24 <cocreature> epta: where are you running this command? in a clone of the cabal-helper repo?
00:02:40 <epta> cocreature: yes
00:03:41 <int-e> stabbing into the dark, is cabal-helper 0.6.3.1 already installed?
00:03:42 <dminuoso> Cale: This is norc, lost track of time and had to run to catch the train.
00:03:52 <dminuoso> But I see what you wrote and Im going through it.
00:03:54 <cocreature> epta: do you have a .ghc.environment.* file in your current directory?
00:04:58 <epta> int-e: `ghc-pkg list cabal-helper` says it's not
00:05:19 <epta> cocreature: nope
00:06:46 <cocreature> epta: I guess you also don’t have a cabal.config, cabal.project, cabal.project.local or something like that in the current directory?
00:07:48 <epta> cocreature: `git clean -xfd` of the master of this repo https://github.com/DanielG/cabal-helper
00:08:50 <cocreature> epta: sry I’m lost here. fwiw I can reproduce this
00:15:09 <dminuoso> Cale: an and these as-yet-unevaluated expressions, are they called thunks?
00:16:17 <cocreature> epta: seems to go away when you add a cabal.project file with "packages: ./"
00:16:56 <ertes-w> lo
00:17:18 <dminuoso> Cale: Also your explanation made so much sense. So in an abstract manner the issue is that both `client` and `server` are mutually recursive, an in order to evaluate their argument (needed for strict pattern matching) they have to recurse into the other
00:17:28 <cocreature> epta: ah the problem is that by default, all directories with .cabal files are added. but the repo includes a hackage-metadata directory with multiple cabal files for cabal-helper leading to this conflict
00:18:17 <cocreature> maybe "new-build" should warn if it’s adding more than one package.
00:18:26 <epta> cocreature: oh lord, great catch. Thank you
00:19:22 <epta> cocreature: yes, it looks extremely weird, probably worth at least an issue
00:19:47 <cocreature> epta: feel free to open one, otherwise I’ll make one sometime later today
00:21:41 <int-e> epta: One possible source of these weird constraints could be cabal-helper's preferred versions: cabal-helper <0.1.0.0 || >0.1.0.0 && <0.5.2.0 || >0.5.2.0 && <0.7.0.1 || >0.7.0.1 (0.6.3.1 is the latest version in the >0.5.2.0 && <0.7.0.1 range and 0.7.3.0 is the latest version in the >0.7.0.1 range, as released on hackage.
00:21:51 <int-e> )
00:22:14 <cocreature> int-e: I think you’vem issed parts of the conversation, we’ve already sorted this out :)
00:22:35 <dminuoso> So let me get this straight, the idea to replace a thunk with a blackhole, what is the purpose? To detect when there's this kind of recursion going on, where evaluation depends on evaluating itself?
00:22:37 <int-e> well that would be typical me.
00:24:23 <epta> int-e: whoa, there is a 'preferred versions' thing. Never heard about it, thanks
00:24:46 <int-e> (It takes time to go down these rabbit holes and I often fail to check whether anybody has gone down the same way before reporting my findings.)
00:26:04 * hackagebot fswatch 0.1.0.1 – File System watching tool with cli and slave functionalities. – https://hackage.haskell.org/package/fswatch
00:31:09 <epta> cocreature: https://github.com/haskell/cabal/issues/4715
00:32:45 <opqdonut> dminuoso: I think it also serves as a sort of locking, for multithreaded evaluation
00:33:16 <opqdonut> when a thread hits a blackhole, it either waits, or errors <<loop>> if the blackhole is its own
00:33:39 <dminuoso> opqdonut: ah, so it's kind of like a mutex
00:34:38 <opqdonut> dminuoso: also, it lets the gc start collecting parts of the thunk that are no longer needed
00:35:22 <opqdonut> but I'm no expert
00:36:39 <dminuoso> opqdonut: Mmm fair enough. Well Im really not concerned with the GC at the moment. Mostly trying to get a grasp of how haskell executes my code.
00:38:10 <dminuoso> opqdonut: Though the more I read about it, the more interesting this gets!
00:38:31 <dminuoso> opqdonut: It is implied that the way blackholes works, its possible for the same thunk be evaluated twice in parallel.
00:40:14 * hackagebot miso 0.7.3.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
01:01:39 <Athas> dminuoso: yes, but that's supposedly harmless.
01:04:25 <dminuoso> Athas: Indeed, I mean thunks dont have side effects so Ö=
01:04:27 <Axman6> dminuoso: iirc there's a fair amount of into about this in Simon Marlow's book on parallel and concurrent haskell
01:04:27 <dminuoso> :)
01:04:56 <dminuoso> Axman6: If only I was at the competency to read that. :)
01:05:03 <Athas> dminuoso: they might have!  unsafePerformIO, remember.  This is why there is a difference between eager and lazy blackholes, where one is synchronised and the other is not.
01:05:25 <Axman6> it's pretty approachable, I wouldn't call a an advanced text
01:05:30 <Athas> dminuoso: it's quite a readable book.  It's not about GHC implementation details, but libraries that are (mostly) pretty simple.
01:06:02 <Athas> The Repa and Accelerate stuff uses some funky type hackery, but the other chapters is fairly basic Haskell.
01:06:05 <Axman6> not beginner level, but also not a deeply technical tome
01:06:40 <Athas> I mean, people keep saying that FP makes parallelism simple, so it would be a shame if the main Haskell book on parallelism was incomprehensible...
01:07:18 <dminuoso> Athas: well, Im maybe a week into haskell so :)
01:07:31 <Axman6> it's definitely broader than it is deep (though deep enough to get a good idea of how things are actually implemented in GHC)
01:10:20 <Freundlich> It is claimed here https://bartoszmilewski.com/2017/02/28/f-algebras/ that in Haskell, given any functor F, there is an initial F-algebra and a terminal F-coalgebra, and they conincide. Is there a proof of this somewhere?
01:10:46 <Freundlich> I can imagine that this is only true because Haskell is lazy.
01:15:35 <supercynic> Freundlich: see the types Mu and Nu in https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html
01:15:47 <supercynic> Freundlich: there is an isomorphism between them
01:18:42 <lyxia> I find Fix more intuitive for that though
01:22:51 <Freundlich> Let me see if I understand this.
01:24:47 * hackagebot yesod-form 1.4.14 – Form handling support for Yesod Web Framework – https://hackage.haskell.org/package/yesod-form
01:26:21 <Freundlich> Ok, I get the part why they coincide (up to isomorphism) and in the case of Fix they are even the same. Now I still don't understand why Fix f gives us an initial algebra / terminal coalgebra. Are the proofs of this so obvious?
01:26:55 <Freundlich> I'd imagine that you need to proof: Given any algebra, we have an algebra morphism f, and given any other algebra morphism g, you show that f = g.
01:29:49 <halogenandtoast> http://lpaste.net/357883
01:29:53 <halogenandtoast> Is there any way to clean that up ^^
01:30:25 <lyxia> Freundlich: that's how it begins indeed.
01:31:25 * hackagebot yesod-auth 1.4.17.3 – Authentication for Yesod. – https://hackage.haskell.org/package/yesod-auth
01:42:46 <cocreature> how can I get ghc and cabal to compile C code (as in c-sources) using clang instead of gcc? I tried "-pgmc=clang" which apparently makes GHC think it’s using clang and it decides to pass "-Qunused-arguments" but then it still calls gcc which fails with “gcc: error: unrecognized command line option ‘-Qunused-arguments’; did you mean ‘-Wunused-parameter’?”
01:44:12 <merijn> cocreature: Wouldn't it be easier to do that using make/whatever and hook cabal to call that?
01:44:49 <cocreature> merijn: I’m not going to change my hole build process just because I want to diagnose a macOS build error :)
01:44:57 <cocreature> *whole
01:45:26 <merijn> cocreature: Are you building on macOS or trying to use clang on linux?
01:46:05 <cocreature> merijn: someone has reported a build error on macOS which is related to clang/gcc differences so I’m trying to use clang on linux since I don’t have access to a macOS machine
01:46:38 <merijn> cocreature: Honestly, I don't know the "proper" solution, all I got is convenient hacks ;)
01:46:57 <merijn> cocreature: Just put a new directory in your path where gcc is just a shell script passing all arguments to clang
01:47:08 <halogenandtoast> Might be a silly question, but did you try setting the CC environment variable?
01:47:16 <cocreature> I’ve also tried passing --with-gcc=clang to cabal but that had no effect
01:47:20 <merijn> That might work too
01:47:38 <cocreature> halogenandtoast: I’ve tried that but ghc doesn’t care about that afaik
01:48:22 <erisco> shell scripting is the bomb
01:49:22 * hackagebot minio-hs 0.3.1 – A Minio Haskell Library for Amazon S3 compatible cloud storage. – https://hackage.haskell.org/package/minio-hs
01:49:30 <cocreature> merijn: messing with the path seems to work, now I need to figure out how to stop ghc from passing -no-pie :)
01:49:41 <mud> erisco: That would explain why it mostly blows up spectacularly when I try it.
01:55:20 <erisco> was damn tired yesterday... opened up my Haskell file today, looked at the code, said "nope", and deleted it all :P
01:55:33 <speak> Hehe
02:04:41 <lyxia> halogenandtoast: http://lpaste.net/357883
02:07:40 <halogenandtoast> lyxia: looking
02:07:57 <lyxia> To avoid continuation passing, you can also use exceptions or ExceptT to short-circuit, and StateT to handle the Game state.
02:08:42 <lyxia> but it's a lot of LOC-overhead
02:10:12 <halogenandtoast> lyxia: how does that work without a binding for play'
02:10:25 <lyxia> halogenandtoast: I fixed a few typos, you might want to refresh. That should have been play
02:11:59 <halogenandtoast> Interesting
02:12:33 <halogenandtoast> I'm not yet sure how I feel about it.
02:12:59 <halogenandtoast> Less repitition is nice though.
02:14:38 <halogenandtoast> I keep wanting to use StateT, but I still can't wrap my head around it.
02:25:39 <halogenandtoast> lyxia: why did you choose the name k for the function?
02:27:18 <boj> halogenandtoast: not sure how i feel about it (haven't touched it in awhile), but feel free to poke around this for StateT/game logic inspiration. uses an Entity Component System https://github.com/uncannyworks/hack-slash/blob/master/src/HackSlash/Game.hs
02:28:20 <boj> oh, i guess i simply used State
02:30:05 <dminuoso> Aha, so a lazy pattern is not "just irrefutable", it is matched if at any point the argument has been evaluated enough to do the matching?
02:30:52 <erisco> dminuoso, "irrefutable" refers to the branch selection
02:32:05 <halogenandtoast> boj: Thanks, still cool to see.
02:32:11 <erisco> dminuoso, for example, f [] = m can be "refuted" by f [x] because x:[] does not match []
02:32:49 <erisco> dminuoso, but f ~[] = m cannot be refuted by f [x]
02:32:52 <dminuoso> erisco: I see, so by making a pattern irrefutable I separate the pattern matching from the branch selection
02:33:01 <erisco> dminuoso, correct
02:33:43 <erisco> dminuoso, the only reason you do this is for notational convenience
02:33:50 <dminuoso> erisco: Ahh, so the effect of a failed pattern match depends on whether its just trying to select a branch or not (the latter would produce a runtime exception)
02:34:18 <dminuoso> erisco: Gotcha. Im beginning to see these irrefutable patterns more as "destructuring" like JavaScript has it
02:34:23 <dminuoso> Except far more powerful
02:38:25 <erisco> a typical use looks like f ~(x:xs) = C (g1 x xs) (g2 x xs) ... (g3 x xs)
02:38:35 <erisco> where C is some data constructor
02:39:50 <erisco> without the irrefutable pattern notation you would instead have to write  f xxs = C (case xxs of x:xs -> g1 x xs) ... (case xxs of x:xs -> gn x xs)
02:40:17 <erisco> or  f xxs = C (g1 (head xxs) (tail xxs)) ... (gn (head xxs) (tail xxs))
02:41:41 <erisco> by default, data constructors are non-strict on their arguments, and that is essentially how we use laziness effectively in Haskell
02:42:04 <erisco> not exclusively but it is often the case
02:43:32 <erisco> but  f xxs@(x:xs) = C (g1 x xs) ... (gn x xs)  makes all the arguments of C strict on xxs
02:43:59 <supercynic> halogenandtoast: you could just use a pair of mutually recursive functions
02:44:30 <dminuoso> erisco: When you say that data constructors are non-strict on their arguments, that's just another way of phrasing that its in weak head normal form, right?
02:46:50 <erisco> dminuoso, whnf is a term evaluated up to a data constructor
02:49:38 <erisco> dminuoso, what I mean by saying the data constructor is non-strict on its arguments is that the constructor applied to bottom is not bottom
02:49:59 <dminuoso> erisco: Ah.
02:52:31 <dminuoso> erisco: Why would you have to write it differently though? What stops you from say f (x:xs) = C (g x xs)
02:52:51 <erisco> you can say that, but the strictness is different
02:52:55 <zorin-os> can haskell do what bash cannot? http://codepad.org/ZBiKIKgR/raw.txt
02:53:56 <erisco> say f ~(x:xs) = C (g x xs) then f undefined = C (g undefined undefined)
02:54:06 <erisco> but say f (x:xs) = C (g x xs) then f undefined = undefined
02:55:02 <srhb> zorin-os: What are you talking about?
02:56:01 <erisco> so in the former, f is non-strict on its argument, and in the latter f is strict on its argument
02:56:30 <zorin-os> read the output ._.
02:56:39 <erisco> and the case we often care about this is when our function takes a form like that, i.e. we're constructing some lazy data, but this is not the only case
02:56:42 <dminuoso> erisco: Oh I remember! The black box where if you put undefined in and get undefined out, it's strict. If not, it's not strict.
02:56:58 <erisco> dminuoso, that is the definition of strictness, yes
02:57:36 <zorin-os> i want to do var$i=$link as if i was executing var1=$link and so on
02:57:51 <dminuoso> erisco: This is interesting. So it's even possible for these to behave differently, because if C (g undefined undefined) is produced, I suppose its possible for g to have some definition g _ _ = 1
02:58:01 <erisco> Haskell does not have variable variables, thank goodness
02:58:25 <zorin-os> what you mean
02:58:29 <erisco> instead, you may build a list, or a vector, or some other indexable container
02:59:00 <erisco> dminuoso, g may or may not be strict on those two arguments, yes
03:00:21 <srhb> zorin-os: You'd have to use template haskell in order to build names like that, and that would be at compile time. Otherwise, abstract over something like a Map Name Value, where you can manipulate Name however you want.
03:00:22 <erisco> so another case not involving data is, for example, _if True x y = x; _if False x y = y;
03:00:41 <srhb> zorin-os: (And Value, of course)
03:01:00 <erisco> _if is strict on the bool, but the strictness on x and y is dependent on the bool
03:02:45 <zorin-os> for example if the array was (gmail.com google.com) it would make var1=gmail.com and var2=google.com and so on with additional info if provided and coded
03:02:59 <srhb> zorin-os: As said, use something like a Map.
03:09:39 <dminuoso> erisco: So I just realized the reason f undefined = undefined is that its just a diverging pattern
03:09:53 <erisco> diverging?
03:10:00 <dminuoso> *pattern match
03:11:04 <erisco> bottom is a member of all types. f undefined = undefined because bottom does not match (x:xs). it does not match in the same way (x:xs) does not match []
03:11:32 <dminuoso> erisco: yeah the latter would produce a runtime exception
03:11:47 <dminuoso> though I guess semantically that still gives me _|_ ?
03:12:40 <erisco> it refutes that function clause and will try the next one
03:12:47 <erisco> it is not immediately a runtime exception
03:13:19 <erisco> all of your functions secretly have a last clause f _ = ⊥
03:13:59 <erisco> so if you hit that one it always succeeds and produces bottom, and that is how a runtime exception can happen
03:15:20 <erisco> hence you preferentially want exhaustive cases, which is why we don't recommend using functions like head and tail.
03:19:06 <zorin-os> haskell is compilable right?
03:19:29 <erisco> yes
03:20:28 <zorin-os> howld u provide me with a link to a guide on Maps
03:20:31 <dminuoso> erisco: Does a total function require me to handle _|_ explicitly too? Or any non bottom value?
03:21:05 <erisco> zorin-os, I can direct you to the documentation for the package, but only if you explain "howld" to me ;)
03:21:10 <dminuoso> Think there was a wiki article on haskell.org that said to not use partial functions like head/tail because they produce bottom for empty lists
03:22:11 <erisco> dminuoso, think about the implications if Haskell let you write a different clause for bottom
03:22:58 <erisco> dminuoso, remember that bottom is the value of nonhalting programs
03:23:09 <dminuoso> erisco: Funny that you mention it. Im staring at an article about denotational semantics on wikibooks, and the paragraph I just reached talks about exactly that.
03:23:38 <dminuoso> erisco: Okay, so it would allow me to turn a non halting program into a halting program
03:23:43 <dminuoso> Halting problem solved.
03:24:45 <erisco> well, yeah, you could write a function which determines if a program halts
03:25:15 <kgadek> hi all. I want to multiplex multiple sources (namely: websocket and two Chans). Is there a ready procedure to do that, or do I need to forkIO+ADT my way to get this?
03:25:31 <erisco> and elitist computer scientists don't want you to do that, so you can't write such a thing in Haskell
03:27:57 <DigitalKiwi> I thought elitist computer scientists used Haskell why wouldn't they want that...
03:28:22 <kgadek> re self: ok, seems that forkIO+ADT is indeed the way to go (at least as of 2009): https://mail.haskell.org/pipermail/beginners/2009-September/002221.html
03:29:33 <erisco> they use a version which is far more advanced than we have publicly
03:30:28 <erisco> all the features you see being added to GHC is just old stuff to them. they keep us behind with an illusion of progression so they keep control
03:31:02 <Unode> Is there any filter-like function that can do (a -> Bool) -> IO a -> IO a ?
03:31:14 <opqdonut> what would it do?
03:31:15 <kgadek> erisco: wait, what channel am I in? #haskell-conspiracy?
03:31:25 <Unode> opqdonut: same as filter
03:31:35 <opqdonut> Unode: if the predicate is false, what would it return?
03:31:42 <opqdonut> how would it get the `a`?
03:31:46 <dminuoso> erisco: Well. I think that paragraph spanning single page rushing in and out of lazy patterns deserves much more text.
03:31:46 <erisco> hehe :P lets call it fan fiction
03:31:51 <Unode> hum...
03:31:57 <dminuoso> erisco: With what I have learned right now, the article is just super confusing.
03:31:59 <opqdonut> :t guard
03:32:01 <lambdabot> Alternative f => Bool -> f ()
03:32:15 <opqdonut> Unode: ^ there's stuff like that to maybe run a monadic action
03:32:38 <Unode> opqdonut: actually the signature would be more like (a -> Bool) -> IO [a] -> IO [b]
03:32:39 <opqdonut> err sorry that's wrong
03:32:45 <opqdonut> :t when
03:32:46 <lambdabot> Applicative f => Bool -> f () -> f ()
03:32:51 <opqdonut> ^ that maybe runs an action
03:32:58 <DigitalKiwi> erisco today I learned Haskell is developed at Google
03:33:07 <opqdonut> :t \f -> liftM (filter f)
03:33:08 <lambdabot> Monad m => (a -> Bool) -> m [a] -> m [a]
03:33:15 <erisco> dminuoso, you are reading https://en.wikibooks.org/wiki/Haskell/Denotational_semantics correct?
03:33:19 <opqdonut> Unode: you can just lift filter to a monad, see above
03:33:26 <Unode> I see
03:33:41 <dminuoso> erisco: Yeah. A lot seems very abstract outside my reach, but some portions of it make sense
03:33:42 <kgadek> DigitalKiwi: sure about that? For all I know, GHC is supported by Microsoft Research and Google basically hates anything FP-related
03:33:42 <opqdonut> Unode: that's basically the same as just writing out "do xs <- op; return (filter f xs)"
03:33:57 <Unode> yeah, that's what I had but though there should be a better way
03:34:14 <opqdonut> it's liftM, also known as fmap, also known as liftA, also known as <$>
03:34:19 <erisco> dminuoso, well if there is a part that is particularly confusing I'll do what I can to understand it with you
03:35:05 <dminuoso> erisco: Ah you misunderstand. Yesterday I just hit 4.4 in https://www.haskell.org/tutorial/patterns.html 
03:35:41 <Unode> :t filter
03:35:43 <lambdabot> (a -> Bool) -> [a] -> [a]
03:35:47 <erisco> what am I misunderstanding?
03:35:52 <DigitalKiwi> kgadek I just meant based on that Google is known for having significantly more advanced versions of stuff us laymen won't get for many years if ever
03:36:09 <dminuoso> erisco: Nevermind, perhaps its me. Thank you your explanations, if I have further questions Ill ask. :)
03:36:56 <DigitalKiwi> They probably have python 4
03:37:29 <erisco> the good news is you can mostly forget about strictness and just write your program
03:38:39 <Unode> opqdonut: many thanks I get it now. I was looking at it in the wrong direction.
03:39:56 <erisco> in imperative programming you have to worry about evaluation order much more (in my experience)
03:40:37 <erisco> precisely because evaluation can be effectful, and the order of effects matters
03:41:01 <Unode> fmap (filter func) also lifts but I wasn't seeing how I would make filter match the same type. Defining (filter func) would then give me [a] -> [a] which fits perfectly with IO [a] -> IO [a] when lifted.
03:41:24 <opqdonut> Unode: yeah
03:41:30 <opqdonut> you got it
03:42:09 <Unode> I was trying to compose fmap and filter which wasn't quite working. Was getting more confused about it.
03:42:20 <Unode> composition is still not at an intuitive level...
03:42:31 <erisco> for a lot of pure programs you could evaluate eagerly or lazily and it wouldn't make a difference
03:46:50 <erisco> when it matters in effectful programs the thought is "is it do X then do Y?" and in pure non-strict programs the thought is "do I need to know X to know Y?"
03:52:16 <erisco> Unode, did the assembly line analogy not work well for you?
03:55:28 <zorin-os> i found it ^-^         
03:55:30 <zorin-os> hput () { var=$1 && shift 1 && eval hash"$var"='($@)'; } ; hput Japan 1 2 3 4 5 6 ; declare -p hashJapan
03:55:31 <zorin-os> declare -a hashJapan='([0]="1" [1]="2" [2]="3" [3]="4" [4]="5" [5]="6")'  # https://stackoverflow.com/questions/688849/associative-arrays-in-shell-scripts (while it is not an associated array wich is tipically defined as echo ${newmap[name]}, it was in this post)
03:57:01 <Unode> erisco: assembly line?
03:57:04 <erisco> what does this have to do with Haskell, zorin-os?
03:58:16 <Unode> erisco: do you mean for composition?
03:58:37 <erisco> Unode, yes, you can take an imperative perspective on composition. (g . f) x is "do f to x as x', then do g to x' as x''"
03:59:05 <erisco> and so on for as many functions you put onto the line. also I hear it called the "pipeline"
03:59:08 <merijn> erisco: He was asking random questions in ##c++ earlier, so likely nothing
03:59:10 <Unode> yeah that's sort of how I think of it but sometimes I mix types that shouldn't be mixed and the thing gets more complicated than it should :)
04:01:14 <erisco> so you ended with fmap . filter func there?
04:01:49 <erisco> sorry, I mean fmap . filter
04:02:41 <erisco> then I imagine the confusion is when we start sending functions down the line
04:02:49 <erisco> and admittedly I have no idea why that is more confusing than other values
04:03:41 <erisco> but with practice you can warp your brain around it
04:05:12 <erisco> it may be because we want to think about functions in their fully applied form
04:05:49 <erisco> we want to think of filter as traversing a list and tossing out elements
04:06:22 <erisco> rather than thinking of filter as a function which produces list maps
04:07:02 <erisco> when you think in the curried way then fmap . filter is not at all surprising nor confusing
04:07:42 <erisco> filter takes a predicate and produces a list map, fmap takes a map and produces a map on functors
04:10:00 <erisco> Unode, does that help you?
04:11:40 <Rembane> :t fmap . filter
04:11:41 <lambdabot> Functor f => (a -> Bool) -> f [a] -> f [a]
04:11:52 <Rembane> :t filter
04:11:53 <lambdabot> (a -> Bool) -> [a] -> [a]
04:12:02 <Rembane> Oh
04:12:04 <Rembane> Nice
04:18:18 <erisco> (.) takes a map and produces a map on returns, so (.) . (.) is taking a map, producing a map on returns, then taking the map on returns and producing a map of returns on returns
04:18:35 <erisco> :t (.)
04:18:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:18:39 <erisco> :t (.) . (.)
04:18:41 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
04:19:01 <erisco> the map of returns on returns is (a1 -> a -> b) -> (a1 -> a -> c)
04:19:24 <erisco> (a -> b) is the return of a1 -> a -> b, and the return of a -> b is b, and we map that to c
04:20:29 <erisco> from this explanation it is easy to extrapolate (.) . (.) . (.) and so on
04:24:10 <Darwin226> Is there something analog to Debug.Trace but for types? Something like `Trace :: k -> Constraint` that's always satisfied but prints out the argument when it's solved.
04:26:05 <Rembane> Darwin226: x :: _ 
04:26:43 <Rembane> Darwin226: Or rather: let x = y :: _ 
04:27:13 <Darwin226> I don't really want to print out a type of some value, I want to print out the type that a type variable gets specialized to
04:27:22 <Rembane> Darwin226: Why? :)
04:27:29 <unclechu> hey guys, in which version of ghc -Wtabs warning appeared?
04:27:57 <unclechu> how i can check if this flag supported and only then disable it?
04:28:24 <Darwin226> I have a constraint on a variable that fails to solve. The variable ultimately gets filled with some type computed by a few type families
04:28:39 <Darwin226> and I'm not sure which exact type it is
04:28:44 <Rembane> Darwin226: Do you need it runtime or compile time?
04:28:49 <Darwin226> compile time
04:29:07 <Rembane> Darwin226: Then you can just use the name for that variable and type this: name :: _ 
04:29:10 <Rembane> Darwin226: ...somewher.
04:30:00 <lyxia> I don't think there is such a thing.
04:30:02 <Darwin226> it's something like `instance SomeConstr t => SomeOtherConstr t`. Putting that anywhere in the instance will just tell me `t`
04:30:36 <lyxia> Maybe some hacking by inserting an incoherent instance at the right place with a TypeError?
04:30:38 <Rembane> Ah, meh. :)
04:31:25 <Darwin226> lyxia: If there isn't something like this already available, I'm guessing it would be super easy to do with a typechecker plugin
04:31:57 <erisco> you should find out
04:32:04 <Darwin226> Meh, I guess I'll have to debug it the old fashioned way.
04:32:43 <Darwin226> I'd try making the plugin but they don't work on Windows in 8.0.2 and I haven't yet upgraded.
04:44:37 <Myrl-saki> Well...
04:44:39 <Myrl-saki> This just happened.
04:44:45 <Myrl-saki> 924 myrl       20   0  1.0T 2646M  3224 S  0.0 17.7 26:04.11 /home/myrl/.xmonad/xmonad-x86_64-linux
04:45:08 <Myrl-saki> xmonad is consuming 2.832 GB.
04:45:16 <Myrl-saki> Has this errr... happened to anyone before?
04:45:28 <thimoteus> yes, it was a bug when ghc 8.0 came out
04:45:43 <thimoteus> not sure if it was ever resolved 
04:45:48 <hpc> just download more ram
04:45:56 <Clint> sounds more like taffybar to me
04:46:00 <thimoteus> somehow caused by destroying/creating a lot of windows
04:46:21 <Myrl-saki> thimoteus: Ah, thanks. :P
04:46:56 <raynold> ahh it's a wonderful day :D
04:47:13 <Myrl-saki> hpc: I was going for a "lowest RAM usage" challenge, and I saw 7.8 GB usage, and firefox probably couldn't consume that much alone (especially after a restart.)
04:48:31 <Myrl-saki> thimoteus: Oh wow. This happened literally a year ago, and it's still not resolved.
04:49:04 <thimoteus> Myrl-saki, :\ i stick to 7.10.3 on my laptop that uses xmonad
04:50:09 <Myrl-saki> thimoteus: Now that you say that, I should change my laptop's WM, considering it only has 3 GB of ram. :C
04:50:21 <hpc> btw you can have multiple ghcs on a box at once
04:50:26 <hpc> in case xmonad is stopping you from upgrading
04:50:35 <Unode> erisco: yeah that's what I was also trying but I think my issue had to do with precedence rules and not having $ or ( ) in the right places.
04:50:48 <Myrl-saki> hpc: How does xmonad invoke the compiler?
04:50:54 <thimoteus> yeah, i would probably just compile with an earlier ghc
04:51:12 <cocreature> maybe try 8.2, if your lucky something has been fixed :)
04:51:13 <Unode> It's like I understand the examples, but when I'm deep in the code , I need to break it down to even follow it.
04:51:16 <hpc> Myrl-saki: don't remember
04:52:24 <Myrl-saki> cocreature: Thanks. I'll try it when it becomes an actual problem. My reboots are kinda frequent anyway.
04:53:45 <ongy> Myrl-saki: if you have a recent enough xmonad there's support for custom build scripts. check the xmonad-testing repo, it has (rather sparse) explanation
04:54:43 <thimoteus> i remember seeing someone's xmonad.hs that had a custom recompile/restart command
04:55:24 <Myrl-saki> ongy: Oh yay. I've always had problems with paths considering that I don't have any globally-installed libraries, which results in Emacs and a looot of errors. :C
04:56:21 <thimoteus> Myrl-saki, something like this https://github.com/windelicato/dotfiles/blob/master/.xmonad/xmonad.hs#L173
04:57:24 <Myrl-saki> thimoteus: Ahhh
04:57:59 <Myrl-saki> thimoteus: Right. Because the xmonad executable just calls the ~/.xmonad/* file?
04:58:12 <thimoteus> looks like it
04:59:30 <srk> I think there's a shortcut to calling ghc directly.. xmonad --recompile 
05:05:15 <supercynic> thimoteus, Myrl-saki: you might be interested in this: http://ertes.eu/tutorial/s6-xsession.html
05:06:17 * hackagebot extrapolate 0.2.3 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
05:08:19 <thimoteus> ooh interesting
05:15:24 <vktec> Why is getContents allowed to be lazy? Since characters are read on-demand, non-monadic functions using the string can cause side-effects by asking for characters that haven't been read yet. I feel like that's breaking Haskell's own rules, but I'm probably missing something. Anyone up for explaining how and why this works?
05:15:53 <merijn> vktec: It is breaking rules :)
05:16:00 <merijn> vktec: It's using unsafeInterleaveIO internally
05:16:02 <namosca> Hi all
05:17:07 <namosca> I instalelled HDBC to use databases (mysql) by using cabal install hdbc and cabal install hdbc-mysql, but when I am in prelude and I type import Database.HDBC, I get the error "Could not find module"... how can I fix this problem? I am new to Haskell
05:17:08 <merijn> vktec: Although, it's not as bad as you're making it sound. Note that Haskell doesn't ban "side-effects" (hell, there's allocations, copies, thunks, etc. all being mutated all the time)
05:17:20 <merijn> vktec: The standard bans *observable* side-effects
05:17:20 * vktec tuts
05:17:33 <vktec> But yeah, I guess that's fair enough
05:17:45 <Rembane> merijn: So if you have really sneaky side effects it's cool?
05:17:46 <vktec> It's more bending the rules than breaking them
05:17:58 <merijn> vktec: i.e. it's only bad if you can notice the side-effect from within haskell. Which, in the case of unsafeInterleaveIO it's actually somewhat reasonable
05:18:00 <cocreature> vktec: there is a reason why lots of people hate the implementation of getContents that’s in base :)
05:18:23 <merijn> vktec: It's basically "pretending" to do all the IO at once, but in reality does it bit-by-bit, in theory that doesn't really affect the purity of anything
05:18:45 <Axman6> namosca: any particular reason to use HDBC? (and for that matter, mysql?)
05:18:56 <merijn> vktec: In practice lazy IO like this (and all other uses of unsafeInterleavIO) are considered bad, not because of purity reasons, but because of resource usage reasons
05:19:23 <cocreature> it can fuck up your program but hey at least you can pretend it’s pure!
05:19:31 <merijn> vktec: For example, when you use hGetContents the file descriptor/handle doesn't get closed until you read until the end of file. If you never do, you leak the file descriptor (which is a limited resource)
05:20:06 <merijn> vktec: Also, error handling now happens in the middle of your pure code (since an unexpected EOF/terminated socket result in an exception) and it's usually nicer to handle the errors whenever you do IO
05:20:30 <merijn> vktec: OTOH, it makes writing streaming processing code rather easier, which is a bonus
05:20:40 <vktec> Okay. Thanks for the explanation
05:20:59 <merijn> vktec: Of course these days we have pipes/conduit and similar libraries which combine the nicety of stream processing with strict IO so you get best of both worlds
05:21:06 <namosca> Axman6: MySQL because that is what I have in mzy pc.. HDBC because its the only one I found a tutorial for, but I am open to other possibilities, as long I can find good training material for it
05:21:32 <ongy> does GHC still produce code that has issues with FDs > 1024?
05:21:44 <merijn> ongy: Did it ever? That sounds odd
05:21:52 <merijn> ongy: Sounds more likely to be a ulimit issue, tbh
05:22:06 <ongy> select...
05:22:21 <Axman6> namosca: afaik, HDBC isn't really really used much at all any more. I would start out with mysql-simple
05:22:30 <merijn> ongy: GHC doesn't use select, normally
05:22:35 <ongy> at least in the non-threaded runtime it use(s/d) select, which defaults to that limit
05:22:39 <merijn> ongy: It uses epoll/kqueue if available
05:22:46 <Axman6> namosca: you might find https://www.reddit.com/r/haskell/comments/4z08z5/the_state_of_mysql_in_haskell/ useful
05:22:56 <cocreature> a year ago it still used select in the non-threaded rts iirc
05:23:01 <merijn> could be
05:23:13 <ongy> not just a year ago
05:23:23 <cocreature> that was the last time I checked :)
05:23:26 <merijn> ongy: Well, if you know a bit of C it shouldn't be to hard to fix that, I think?
05:23:48 <ongy> it uses epoll/kqueue for the IO manager stuff, but selects before actually going into read
05:23:53 <cocreature> we should just make the threaded rts the default so nobody needs to care what happens in the non-threaded rts :)
05:24:23 <merijn> cocreature: The threaded RTS can be rather slower for a whole bunch of primitives
05:24:51 <cocreature> merijn: sure it’s not always the right thing to use but imho it’s the better default.
05:26:55 <namosca> Axman6: I installed mysql-simple by doing cabal install mysql-simple, but when I do import Database.MySql.Simple (as told in https://hackage.haskell.org/package/mysql-simple-0.2.2.2/docs/Database-MySQL-Simple.html), I get the error "Could not find module"
05:27:16 <cocreature> namosca: are you working on a cabal project?
05:27:36 <Axman6> namosca: can you explain how you installed it, and what you're trying to do to import the module? sounds like you're having a more fundamental problem
05:30:08 <namosca> Axman6, cocreature: I installed on the bash by inputting the command cabal install mysql-simple, and then opened ghci and tiped the import... Maybe cabal is not what I need?
05:30:36 <namosca> Axman6, cocreature: I thought cabal was a package installer
05:30:44 <Axman6> it is
05:30:56 <Axman6> but that doesn't mean the package is visible to your project
05:31:15 <cocreature> namosca: try "cabal repl"
05:31:18 <cocreature> instead of ghci
05:31:30 <ongy> merijn: I remember that I tried once and the dupTo from System.Posix.IO threw an exception with FDs >1024 (threaded and unthreaded). not sure if that's still a thing
05:33:56 <namosca> cocreature: Cabal repl worked! Thanks
05:34:12 <cocreature> ongy: looks like it is still a thing sadly
05:34:55 <ongy> still a thing, even with threaded
05:35:00 <cocreature> ongy: but I’m not sure if that’s really related. dupTo is just a straight ffi call
05:35:23 <cocreature> that should be independent of whether ghc uses select in the rts
05:37:40 <aloiscochard> is there a reference/doc about the convention around using even/odd number for release/snapshot?
05:39:22 <cocreature> aloiscochard: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/intro.html#ghc-version-numbering-policy
05:39:35 <aloiscochard> thanks a lot cocreature!
05:39:51 <ongy> cocreature: right. that's interesting
05:40:22 <cocreature> aloiscochard: it’s not ghc specific, other projects use it too. gnome is the first one that comes to mind but I’ve seen it a few times.
05:41:03 <aloiscochard> cocreature: yeah indeed, a coworker says that linux kernel is doing the same. I want to apply the same policy at $WORK, this text you shared is just a perfect source of inspiration :)
05:41:49 <cocreature> ongy: I think it’s just ulimit. "ulimit -Sn" shows 1024
05:42:23 <namosca> cocreature: now i have to change my emacs haskel-run to cabal repl... do you know how to do it?
05:44:21 <DigitalKiwi> linux being on version 3 would imply it is not stable then right?
05:44:49 <cocreature> yeah linux doesn’t follow this policy, aloiscochard 
05:45:04 <cocreature> maybe they did at some point but they don’t do this atm
05:45:04 <c_wraith> DigitalKiwi, in the same way as ghc 7 wasn't stable. 
05:45:10 <aloiscochard> DigitalKiwi: it is about the minor version though, not the major
05:45:25 <cocreature> yeah but they are all stable as well afaik
05:45:46 <aloiscochard> I'm on stable 4.9, so yeah indeed!
05:46:12 <cocreature> they have lts releases but I think that’s more a “this release looked somewhat solid, let’s make it an lts”
05:46:19 <DigitalKiwi> wait what version is linux up to D:
05:46:35 <cocreature> “The linux kernel dropped that practice with the start of the 2.6 kernel in 2003”  according to https://stackoverflow.com/questions/1266411/which-open-source-projects-use-odd-unstable-even-stable-style-of-versioning
05:47:16 <cocreature> DigitalKiwi: I’m on 4.12 and I think that’s still the latest but maybe 4.13 has already been released and I’ve missed it
05:48:08 <DigitalKiwi> 4.12.8 is the latest stable according to wikipedia
05:48:30 <cocreature> I think I’ve even rebooted since I updated to 4.12.8 :)
05:49:42 <DigitalKiwi> so for the majority of my life of using linux it was on 2.4/2.6 and now it's gone to 4.12 and I didn't even notice 3... :/
05:50:04 <MarcelineVQ> the 3 was inside of you all along
05:52:06 <Rembane> There is no 3.
05:53:56 <DigitalKiwi> so when they get to 4.19 are they jumping to 5 ?
05:54:20 <ongy> skipping 4 20? I doubt it
05:55:46 <mekeor> once there was 2.6.39
05:56:59 <DigitalKiwi> they literally took a poll
05:57:47 <DigitalKiwi> they got to 3.19 and linus was like...should we keep going or go to 4.0 and people are like "I can't count past 20!"
06:12:09 <Tehnix> Grasping a bit at straws here: would anyone have any idea why I would get this error? -- https://gist.github.com/Tehnix/e70062ef28fb01da87fb955322b9ae6f
06:13:54 <mekeor> apparently CPackageIndex needs two arguments, Tehnix 
06:14:15 <mekeor> like `CPackageIndex ModuleName Foobar`
06:40:11 * hackagebot rank1dynamic 0.4.0 – Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types – https://hackage.haskell.org/package/rank1dynamic
06:40:11 * hackagebot distributed-static 0.3.6 – Compositional, type-safe, polymorphic static values and closures – https://hackage.haskell.org/package/distributed-static
06:41:08 <ezyang> cqrql: I'd love to look into this. Do you have a repro? 
06:42:47 <royal_screwup21> What be a good starter project for a beginner to Haskell?
06:42:51 <royal_screwup21> would be*
06:43:45 <merijn> royal_screwup21: Depends on your interest, previous experience, and how long you've been studying
06:44:48 <royal_screwup21> merijin I'm pretty experienced with Python and C++ and I've mid way through "learn you a haskell"
06:44:56 <royal_screwup21> merijn: *
06:44:59 <merijn> royal_screwup21: A lot of people want to do webstuff, but honestly that's a bit painful in many languages. Areas where I think Haskell compares very nicely with other languages would be: stream processing, any programs that involves lots of parallel operations/networking
06:45:09 <merijn> Anything that involves writing parsers
06:45:35 <royal_screwup21> cool, thanks!
06:45:45 <merijn> Simple webscraping could be nice
06:45:49 <amx> royal_screwup21: I enjoyed adventofcode, or just do any of the other countless coding challenges on the web
06:46:05 <merijn> Let's you use lightweight threading to easily parallelise, you can use some stream processing, etc.
06:46:15 <amx> not really a 'project', but it gets you up to speed quickly
06:46:56 <royal_screwup21> amx thanks for the suggestion, I'm currently looking it up, and the website seems a little...cryptic lol
06:48:15 * hackagebot distributed-static 0.3.7 – Compositional, type-safe, polymorphic static values and closures – https://hackage.haskell.org/package/distributed-static
06:55:56 <vktec> Is there a way of hooking happy and alex into a cabal file so that cabal build will compile .x and .y files to .hs prior to compiling using GHC?
06:56:59 <merijn> vktec: Pretty sure cabal should already do that automatically?
06:57:51 <kgadek> vktec: I guess that you could use build-type: custom and write arbitrary stuff in Setup.hs
06:58:23 <merijn> oh
06:58:30 <merijn> You need to list them
06:58:36 <merijn> vktec: https://stackoverflow.com/questions/4465666/using-alex-happy-with-cabal
06:58:51 <merijn> kgadek: cabal-install already has code for that
06:59:04 <vktec> merijn: Thanks. I'll give that a shot
06:59:08 <kgadek> merijn: nice. wasn't aware of that
07:00:00 <merijn> kgadek: I knew the code was there (because I ran into it while reading the code), I just didn't know how to invoke it :)
07:02:12 <vktec> Yep, that's worked perfectly. Cheers merijn 
07:15:32 * hackagebot distributed-process-simplelocalnet 0.2.4 – Simple zero-configuration backend for Cloud Haskell – https://hackage.haskell.org/package/distributed-process-simplelocalnet
07:17:38 <xormor> I have this code: "hypo2 a b = (a * a) + (b * b)<next_line>hypoc a b = sqrt((a * a) + (b * b))". How do I use "main" in the context of it?
07:17:59 <xormor> I can run it in ghci fine, but runhaskell requires main.
07:19:28 <lyxia> main = print (hypo2 34 42)
07:19:33 <Myrl-saki> xormor: How do you plan to use it with runhaskell?
07:19:52 <Myrl-saki> lyxia: I'm thinking that he might want input.
07:20:14 <xormor> Myrl-saki, I want it to take a and b and give both answers.
07:20:38 <xormor> Myrl-saki, either from commandline, or the program asks for numerical values for a and b.
07:20:54 <Myrl-saki> :t print
07:20:55 <lambdabot> Show a => a -> IO ()
07:21:17 <Myrl-saki> xormor: https://gist.github.com/anonymous/842d99904b9a86260fbc342b9e480e3c
07:21:30 <Myrl-saki> xormor: Depending on the type of hypo2.
07:22:30 * hackagebot network-transport-composed 0.2.1 – Compose network transports – https://hackage.haskell.org/package/network-transport-composed
07:27:30 <xormor> Myrl-saki, the type of hypo2 would be floating point
07:27:38 <xormor> Myrl-saki, I could not get your code to work correctly.
07:28:10 <Myrl-saki> xormor: What's the error?
07:28:47 <iomotoko> Ord "This class contains types that are instances of the equality class Eq, but in addition whose values are totally (linearly) ordered, and as such can be compared (...)" - what does "totally (linearly) ordered" mean here?
07:29:25 <Myrl-saki> xormor: Also, there's no subtyping in Haskell, so it'd be better to say Float, Double (the types) or Floating (the typeclass).
07:29:49 <Myrl-saki> iomotoko: Don't quote me on this, but totally ordered means that all elements can be compared to each other.
07:29:55 <MarcelineVQ> iomotoko: I read that as: given some number of things you can sort them in the same way every time
07:30:13 <xormor> Myrl-saki, hulu.hs:4:1:    Parse error: naked expression at top level    Perhaps you intended to use TemplateHaskell
07:30:38 <Myrl-saki> xormor: Can you pastebin it?
07:32:08 <erisco> iomotoko, it means that forall a, b that a ≤ b or b ≤ a
07:32:36 <iomotoko> Myrl-saki: but that can't be true since 'a' < 0 will give an error, but ('a',0) < ('a','b') works  ... it doesn't work...!
07:32:36 <Myrl-saki> iomotoko: Here's an example of a partial ordering. The type (Int, Int), where the implementation will only allow you to compare if the first elements are equal.
07:32:44 <iomotoko> Myrl-saki: so I guess you were right :)
07:33:10 <Myrl-saki> (Note that there's an implementation that is total for (Int, Int), and that Haskell defaults to that.)
07:33:35 <Myrl-saki> iomotoko: Every element means every element of the same type. :P
07:33:46 <Myrl-saki> > 'a' < 'b'
07:33:48 <lambdabot>  True
07:33:54 <Myrl-saki> > ('a', 'a') < ('a', 'b')
07:33:56 <lambdabot>  True
07:33:56 <erisco> iomotoko, it is forall (a :: t) (b :: t), a ≤ b or b ≤ a
07:34:02 <xormor> Myrl-saki, https://pastebin.com/FTSdn7vx
07:34:14 <erisco> iomotoko, so you are only comparing objects of like type
07:34:33 <iomotoko> erisco: Myrl-saki: MarcelineVQ: thanks!!! :3
07:34:38 <iomotoko> got it
07:34:40 <Myrl-saki> iomotoko: No problem. ^_^
07:34:54 <Myrl-saki> xormor: `print` should be on the same indention (do notation is indention-sensitive)
07:35:00 <Myrl-saki> xormor: And `let` should be erased.
07:35:25 <erisco> iomotoko, if it were partial that would be the same as saying ≤ is a partial function, meaning that if we tried to compare some objects we'd get an error
07:36:24 <xormor> Myrl-saki, thanks. it works now.
07:36:44 <iomotoko> erisco: don't confuse me now that I got it
07:36:44 <iomotoko> :D
07:37:40 <Myrl-saki> Example of partial ordering. https://gist.github.com/adrianparvino/f590dfa112b98aa399b0b881f0249672
07:38:09 <Myrl-saki> (The error condition is completely arbitrary.)
07:38:23 <erisco> iomotoko, actually I am wrong on that
07:39:06 <erisco> I am trying to think now how a partial function would relate
07:39:36 <Myrl-saki> erisco: Which part are you wrong on? That seemed sound to me.
07:40:01 <Myrl-saki> (On the other hand, all total functions are actually also "considered partial")
07:40:10 <erisco> a partial order does not mean the function is partial
07:40:22 <mnoonan> erisco, it still works in one direction. ≤ for a partial order could be treated like a partial function a -> a -> Ordering. but if you just take a partial function a -> a -> Ordering, it might not satisfy the right axioms
07:40:36 <mnoonan> e.g. x ≤ x had better be defined
07:40:53 <Myrl-saki> Ahhh
07:41:26 <erisco> I am not sure if there is anything to be said about two things... brain is thinking about parsing at the moment
07:41:44 <erisco> anyways, the reason this is goes to the meaning of the compare function
07:43:19 <erisco> iomotoko, an ordering relation ≤ is a set of pairs. We say a ≤ b is true if (a, b) ∈ ≤
07:44:42 <jaseemabid> Anyone familiar with megaparsec? I've an indentation aware (python alike) grammar, but I'd like to optionally separate statements with ; as well. I can correctly parse 'a\nb', but 'a;b' fails with the error "incorrect indentation (got 2, should be equal to 1)". Are there any docs explaining how to achieve this? 
07:45:10 <erisco> iomotoko, conversely, we say ¬(a ≤ b) is true if (a, b) ∉ ≤
07:45:43 <jaseemabid> Relevant code: https://github.com/jaseemabid/Olifant/blob/56bbe97a8107f256aa57332357331802eed137a9/src/Olifant/Parser.hs#L140
07:47:04 <dolio> Megaparsec has built-in indentation parsing?
07:47:04 <erisco> iomotoko, so, a <= b (talking Haskell code now) means (a, b) ∈ ≤
07:47:40 <jaseemabid> dolio, Yes. But its a bit too tricky to get right :/ 
07:47:42 <erisco> therefore total means a <= b || b <= a is True
07:48:17 <erisco> it also means that a <= b && b <= a implies a == b
07:48:28 <dolio> jaseemabid: What's handling the semicolon?
07:48:33 <dolio> Is that also automatic?
07:49:04 <erisco> with a partial order, we are not guaranteed that a <= b || b <= a is True
07:49:12 <erisco> that is, they may both be False
07:49:22 <jaseemabid> dolio, No its not. I have to do that myself, but I'm not very sure how to handle it correctly. 
07:49:37 <mnoonan> erisco, I don't think a <= b && b <= a implies a == b a priori, you have to impose that
07:49:51 <mnoonan> (I think)
07:50:02 <erisco> mnoonan, that comes from total orders being partial orders, it is called antisymmetry
07:50:55 <dolio> Yeah.
07:50:57 <erisco> if you don't have that then you just have a preorder
07:51:01 <dolio> Right.
07:51:37 <mnoonan> erisco: sure, I'm just saying it doesn't follow immediately from thinking of <= as a set of pairs, which I thought was what you were implying
07:52:02 <erisco> so "partial" in "partial order" means that there may be some pairs objects for which we cannot decide if one is larger or smaller than the other
07:52:11 <jaseemabid> dolio, I dont understand what megaparsec means with the various kinds of lexems and space consumers and I'm not sure where I should fit in the ; logic
07:52:41 <dolio> jaseemabid: I don't really know megaparsec. I was going just going to see if I saw anything obvious.
07:52:55 <erisco> mnoonan, that is a way you can model it. To be a total order you then have to add antisymmetry, transitivity, and totality
07:52:58 <dolio> I don't really see where you're even doing semicolon stuff, though, aside from `sep` which isn't used.
07:53:09 <dolio> So I don't understand why it gives you the error message it does.
07:53:21 <dolio> I'd expect it to complain about the semicolon being unexpected.
07:53:41 <dolio> Unless it has some kind of built-in handling.
07:54:07 <jaseemabid> dolio, I see. I tried various options and none worked; like consuming it as part of sc, rewriting ; as \n + appropriate space etc. 
07:54:27 <jaseemabid> I was wondering if anyone has experience with such a problem and give me some hints
07:55:14 <erisco> iomotoko, I am sure that is clear as mud now.
07:56:26 <dolio> It depends how you want it to behave. If you just want it to break up lines as part of a block, I might parse a laid-out block with semi-separated stuff in it, and then flatten.
07:57:08 <dolio> But that might not work if you need to be able to nest things inside something that comes after a bunch of semi-separated stuff on a line.
07:57:54 <dolio> I mean, it wouldn't work at all. Definitely.
07:58:44 <dolio> I also don't know anything about megaparsec's indentation stuff, though. It's possible it can just handle this.
07:59:25 <dolio> Because Haskell allows this sort of thing, and if you're building an indentation-aware parser in Haskell, it'd make sense to build it in a way that it could handle Haskell.
07:59:27 <jefrey> Hi guys! Is there any simple way to setup ghci in such way that it will constantly and listen on stdin? I want to create something that will watch a files for change, after chagne will send ":r" (reload) to ghci and execute "main" function inside (which writes files to disk)
08:00:24 <jaseemabid> dolio, looks like I have to go back to the basics one more time. This is way harder than I expected it to be. 
08:00:31 <tdammers> jefrey: I think you may be pushing ghci to the limits of what it was designed for here
08:00:47 <jefrey> tdammers: I know it
08:01:03 <jefrey> tdammers: but hm, it seems like a really easy thing to do if we can send text to ghci
08:01:38 <dolio> jaseemabid: Indentation-aware parsing isn't easy. At least, not the Haskell kind.
08:01:45 <dolio> Python's version might be easy.
08:05:25 <jefrey> tdammers: omg, it seems it just works : (echo "print 1"; sleep 3; echo "print 2") | ghci
08:06:49 <dolio> Of course, that's implementing indentation-aware parsing from scratch. One would hope that once someone's done that, they could present something easy.
08:07:13 <dolio> But if semicolons are supposed to behave similarly to layout, I'd kind of expect that to be baked in.
08:07:45 <iomotoko> sorry for another stupid question, about the class Read "This class is dual to the class Show", what does "dual" mean here? 
08:08:01 <iomotoko> Maybe it's cause english is my 2nd language? or does _dual_ have a special meaning in mathematics I am not aware of
08:09:03 <iomotoko> for me "dual" means roughly the same as "double"?
08:09:09 <Myrl-saki> Nope.
08:09:13 <Myrl-saki> Dual is more of opposite.
08:09:16 <Myrl-saki> f . g = id
08:09:26 <monochrom> "dual" is a favourite word in mathematics but doesn't have a set-in-stone meaning apart from some kind of opposite.
08:09:35 <ggVGc> good old math, inventing new meanings for our words
08:09:40 <Myrl-saki> ggVGc: Lmao
08:09:43 <iomotoko> k, so that makes more sense
08:09:44 <MarcelineVQ> it's shorter than counterpart
08:09:45 <tdammers> math is often surprisingly ambiguous
08:09:52 <iomotoko> yeah, counterpart, k, got it :)
08:09:55 <iomotoko> was confused there for a sec
08:09:59 <iomotoko> thanks again
08:10:05 <Myrl-saki> Never take any arbitrary word as its actual meaning. :D
08:10:08 <monochrom> But you are supposed to recall dualism from theology.
08:10:13 <iomotoko> lol
08:10:14 <tdammers> anyway, in Category Theory, "dual" is defined fairly rigidly
08:10:15 <ggVGc> I feel math often is a whole other dictionary of meanings for words that I know normally
08:10:35 <erisco> the mind floats outside the skull
08:10:38 <iomotoko> ggVGc: actually was looking for some online mathematics dictionary or something
08:10:48 <iomotoko> to look for the meaning _dual_
08:10:48 <dolio> It's 'dual' because it's a pair of related, 'opposite' things, and everything you prove/constructor for one automatically gives you something for the other.
08:10:49 <iomotoko> :D
08:11:54 <dolio> At least in this case.
08:12:14 <iomotoko> does this channel have a patreon page?
08:12:15 <monochrom> But you are not supposed to read word by word. You are supposed to use the context to interpret a word.
08:12:38 <iomotoko> by the end of my haskell adventure (hopefully there won't be an end) I will have to pay quite some people quite many beers to thank them
08:12:45 <erisco> phft, doesn't sound referentially transparent
08:13:08 <brynedwards> pay it forward :) help people in your 1st language
08:13:18 <iomotoko> monochrom: which lead me here and spot the discrepancy to begin w/
08:13:19 <monochrom> Human writing has referential transparency? Don't kid me.
08:13:33 <iomotoko> monochrom: and of course sometimes words (especially programming language, science, mathematics) have a fixed meaning
08:13:42 <erisco> okay, I won't baby goat you.
08:13:58 <iomotoko> *especially in
08:14:17 <ggVGc> would you rather be referential or transparent
08:15:00 <erisco> would I rather people refer to me or not see me at all, hm
08:16:38 <Myrl-saki> lol
08:17:25 <Myrl-saki> iomotoko: I wish I could say "you could get in jail for coercing a minor to drink," but I'm now an old hag. :( I miss a year ago.
08:18:59 <iomotoko> Myrl-saki: I won't sugar coat it, it's only down-hill from there
08:19:20 <iomotoko> Myrl-saki: or w8, actually it isn't, when I consider how immature I was back then in so many ways and only now I can appreciate said fact
08:19:43 <iomotoko> (that being said I am not that much older)
08:19:58 <Myrl-saki> iomotoko: At least I can now spread the word of Haskell!
08:20:01 <monochrom> Take your pick: It's downhill from there. It's an uphill battle from now on.
08:21:13 <iomotoko> Myrl-saki: and you do a fine job at it :)
08:21:20 <Myrl-saki> monochrom: So basically... we're in a valley?
08:21:39 <iomotoko> surrounded by mountains of infinite height
08:21:47 <Myrl-saki> :: Integer
08:21:48 <monochrom> Saddle point.
08:22:24 <erisco> the geometry semantics of life
08:22:27 <Myrl-saki> infinity :: IO Integer; infinity = oom
08:22:29 <Myrl-saki> :D
08:22:34 <monochrom> Or more simply, just poking fun at all those "downhill" "uphill" metaphors.
08:24:15 <erisco> I think the way it works is you are climbing a mountain as the continental plate subducts under the ocean
08:24:19 <Myrl-saki> monochrom: downhill dependencies and uphill dependencies...
08:24:40 <Myrl-saki> Oh cool. I like that idea.
08:24:52 <Myrl-saki> Either the dependency has been abandoned, or it is hard to use. :D
08:25:39 <erisco> to the effect that for all your effort your altitude to sea level is unchanging
08:26:18 <sssilver_> hey guys, what's a pretty good Haskell IDE?
08:26:23 <sssilver_> not just a code editor
08:26:34 <sssilver_> like someplace where I could place breakpoints and have a watch etc etc
08:26:38 <monochrom> leksah maybe?
08:26:56 <monochrom> no, I don't know that leksah does that.
08:27:05 <monochrom> But ghci has it.
08:27:21 <Myrl-saki> sssilver_: I'll be *that* person.
08:27:25 <Myrl-saki> sssilver_: Why do you need breakpoints?
08:27:32 <sssilver_> :)
08:27:32 <monochrom> Also, ghci is not a code editor at all, so there. :)
08:28:01 <sssilver_> well how do you guys debug your code?
08:28:12 <sssilver_> if not with conditional breakpoints and watch and things
08:28:26 <dsal> What kinds of bugs are you experiencing?
08:28:32 <monochrom> Unit testing.
08:28:35 <dsal> The worst I've had to deal with is Debug.Trace
08:28:48 <jaseemabid> dolio, Makes sense. Let me go through this again carefully. 
08:29:38 <Myrl-saki> sssilver_: The biggest project I've worked with is at most 1000 lines, but the only problem I've really had w.r.t. debugging was infinite loops.
08:30:05 <Myrl-saki> sssilver_: Most things were easily fixed with ghci and fabricating inputs.
08:30:09 <sssilver_> dsal to be fair I haven't really experienced any bugs. I know some Haskell, but wanna get into it more substantially, and I usually prefer to work in IDEs with proper debuggers
08:30:37 <erisco> I debug with my noodle.
08:30:38 <dsal> I used to work in IDEs with proper debuggers ten or so years ago.  I'm so much happier now.  :)
08:30:39 <ventonegro> sssilver_: Never felt the need myself
08:30:41 <barrucadu> I think unit testing is the standard approach.  Although, GHC has been improving its debugging output in recent releases, I think
08:31:05 <Myrl-saki> erisco: You eat your noodles after you debug them? That's disgusting. You should cook a new one.
08:31:20 <Myrl-saki> erisco: Botched the joke. Should have said "you should eat them with the noodles."
08:31:40 <ventonegro> sssilver_: There is not much hidden state to watch in a debugger :)
08:32:18 <Myrl-saki> ventonegro: Well explain `MonadState s m => m a`!
08:32:30 <Myrl-saki> Checkmate.
08:33:01 <erisco> think abstractly what a debugger does for you
08:33:13 <erisco> why do you start it up? what are you hoping it does for you?
08:33:14 <cocreature> sssilver_: I think there is a place for better debuggers for Haskell. the problem is that the standard "breakpoint+step through your code" model doesn’t work very well with lazy evaluation
08:33:37 <Myrl-saki> erisco: Fix my code. :D
08:33:57 <erisco> yeah, well, they are poorly named because they do not actually debug your code ;)
08:34:06 <erisco> if a debugger does not debug code then what does it actually do
08:34:18 <ventonegro> There is this old joke that if it compiles, it works :)
08:34:44 <Myrl-saki> ventonegro: That's (mostly) true for Haskell though!
08:34:51 <Myrl-saki> ventonegro: it's the specs that are wrong, not the program.
08:35:05 <Myrl-saki>  /s
08:35:40 <ventonegro> Myrl-saki: Just translate the specs to types
08:35:46 <MarcelineVQ> erisco: why it narrows down the problem and then you can split up your function and nar- wait a minute...
08:37:50 <Myrl-saki> ventonegro: "So, this is the type of the function. We don't know what are the values though."
08:45:32 * hackagebot amqp-utils 0.2.1.4 – Generic Haskell AMQP Consumer – https://hackage.haskell.org/package/amqp-utils
08:48:28 <barrucadu> Myrl-saki: Values are overrated
08:49:25 <ventonegro> Obligatory: https://aphyr.com/posts/342-typing-the-technical-interview
08:49:26 <Myrl-saki> barrucadu: Ikr. Let's throw morality out of the window!
08:49:39 <Myrl-saki> Oh wait, different values.
08:50:08 <Myrl-saki> ventonegro: Thanks. :D I forgot the link to that. I'm happy to see it again.
08:50:56 <Myrl-saki> ventonegro: Would it be possible to have what he had if some stuff were changed to type families?
08:54:16 <ventonegro> Myrl-saki: No idea, I am not familiar with them
08:54:22 <remexre> Does anyone have an example of using haskeline with ansi-wl-pprint? It seems that if I want to use ansi-wl-pprint on Windows, I need to give it a Handle, but haskeline seems to discourage using IO functions "raw", instead using its own outputStr/outputStrLn?
09:07:02 <erisco> the point is that a debugger cannot show you anything more than you could see using your brain and maybe some paper
09:09:05 <erisco> so the utility of the debugger is based on the convenience of automation, having to think and do a little less
09:09:39 <remexre> Yeah, at my work we use an in-house lazy pure-functional language, and our debugging policy is "stand up and walk over to the whiteboard, then *think* about what your problem is"; the 'newbies' tend to panic and make bad choices when debugging in front of a keyboard
09:10:23 <erisco> because imperative programs can be effectful it may be impractical to consider everything manually
09:11:00 <erisco> and this is because effects can be far reaching
09:11:41 <erisco> with purity and referential transparency, on the other hand, we can be highly localised
09:11:57 <erisco> what happens in an expression says in the expression
09:12:49 <erisco> so our ability to tease apart problematic code manually is much easier
09:13:40 <dolio> Your brain and paper are a lot slower than a proper debugger would be, though.
09:13:44 <dolio> And might make mistakes.
09:14:25 <erisco> that said, a debugger for Haskell can still be helpful because expressions can be large, and there is benefit simply to reducing your work load
09:14:47 <dolio> But the proper debuggers aren't really maintained.
09:14:58 <erisco> no, that is not strictly true dolio, because your brain still has to process what the debugger is saying
09:15:33 <dolio> I guarantee that the computer is much faster at evaluating Haskell code than your brain is.
09:16:19 <erisco> I say what I said again
09:16:58 <erisco> once the debugger has shown you something which disagrees with your expectation your job is not done
09:17:03 <cheater> hi
09:17:23 <cheater> i would like to integrate hedgehog tests with classic unit tests. what is a good test runner that can do both?
09:17:32 <erisco> now you have to understand why this has happened, which means understanding your program
09:18:37 <dolio> A good debugger would help visualizing why it happened, and it would compute the relevant information faster than pen and paper.
09:19:55 <remexre> dolio: What language has a "good" debugger? The only debugger I can *tolerate* is the Chrome JS debugger, and that's mainly because of a lack of types/sanity in JS
09:20:14 <dolio> Haskell has had multiple good debuggers in the past, at least as research projects.
09:20:57 <erisco> a debugger can save you time on the manual work of writing or typing, and it can also save you time by skipping over irrelevancies as you determine them
09:21:40 <dolio> But they no longer work to my knowledge.
09:21:45 <dolio> Buddha, hat, hood.
09:22:02 <erisco> I am not saying there is no benefit. I am saying that using a debugger is not strictly faster than just using your head and possibly some paper, because the latter is sometimes, and obviously nearly always, faster.
09:22:39 <erisco> if the debugger could actually correct your program then it would be a different story
09:24:19 <dolio> I don't see why that's obvious at all.
09:24:31 <erisco> observe yourself the next time you write a program
09:24:53 <dolio> Is it faster to have the compiler output 'type error' and then you use pen and paper plus the formal rules to figure out what the problem is yourself? Why not?
09:24:57 <barrucadu> Tangentially related: there has been some research into avoiding concurrency bugs by having some monitoring process observe the system state and pause/resume threads to avoid known bad things, because sometimes actually fixing the bug is too difficult.
09:24:57 <erisco> how many times do you type in some code and then delete it because you realise a mistake or a better way to go about things?
09:25:16 <erisco> how many thoughts come into your head which you discard before it ever hits the keys?
09:25:35 <erisco> or is programming just a mindless process and only a debugger can tell you when something is wrong?
09:26:52 <erisco> it is much faster to make a type correct program by understanding types than it is to have no understanding of types and rely only on type errors to guide your corrections
09:27:50 <erisco> remember, these are just tools and the objective is to have a working program, not just to get an error the fastest
09:29:38 <cheater> barrucadu: haha
09:29:41 <cheater> barrucadu: interesting
09:29:51 <cheater> barrucadu: got a paper on that?
09:30:44 <cheater> using hedgehog, can i somehow easily make generators for records etc? how do i do that?
09:37:35 <cocreature> cheater: is using the Applicative instance of Gen easy enough?
09:37:58 <`Guest00000> can i install a cabal package manually overriding its 'exposed' cabal flag, without editing its .cabal file?
09:40:00 <cheater> cocreature: i have a lot of boring records. i would like this to be done via TH or generics.
09:40:29 <cheater> cocreature: it's really fairly much to write generators for by hand, but they're also very simple data structures.
09:42:48 <cocreature> cheater: given that hedgehog doesn’t have an analogue of the Arbitrary typeclass, it is not clear where you would get the generators for the individual fields from
09:43:31 <cheater> well, the fields are only ints and strings and nullary ADTs
09:43:54 <cheater> but maybe i should be using some other property testing lib instead
09:44:04 <cheater> it seems like hedgehog isn't necessarily suited for this
09:44:18 <cocreature> shouldn’t be too hard to write some TH or GHC.Generics to generate these. I don’t think hedgehog has anything builtin for that.
09:44:59 <cheater> hmm, i don't have a lot of time for that, though
09:47:35 <cheater> i'll have to think of something. thanks.
09:56:06 <tabaqui> is there a library for dictionaries with repeated keys?
09:56:28 <tabaqui> I want fast searching for *any* record with given key
09:56:46 <tabaqui> and fast inserting record without replacing old with the same key
09:56:54 <Psybur|Work> tabaqui, why not make a map where the value is a list?
09:58:15 <tabaqui> Psybur|Work: I have to rewrite all methods for new type then
09:58:23 <tabaqui> maybe someone already did it
09:59:13 <Psybur|Work> https://hackage.haskell.org/package/multimap-1.2.1/docs/Data-MultiMap.html ?
09:59:17 <tabaqui> and Eq instance has no transparent derivation
09:59:51 <akr> Hello, I wonder of anyone could help me with cabal
10:00:12 <tabaqui> Psybur|Work: meh, it even have no Show instance!
10:00:12 <Psybur|Work> tabaqui, ^
10:00:16 <Psybur|Work> D;
10:00:28 <tabaqui> *has
10:00:45 <akr> at work we use this really old version since no-one's been able to update our system, but anyway, it was working fine until yesterday. Now suddenly whatever operation I try to perform, I get a crash with an error: "cabal: Couldn't read cabal file "cassava/0.5.1.0/cassava.cabal""
10:00:57 <akr> any idea what could be wrong / where is cabal looking for this file?
10:03:13 <Psybur|Work> tabaqui, https://hackage.haskell.org/package/hydrogen-multimap-0.3/docs/Hydrogen-MultiMap.html ?
10:03:27 <akr> hmm, it seems that 0.5.1.0 is a really new version
10:03:47 <akr> this is suspicious; this system should be having like 5-year-old packages
10:04:47 * hackagebot brick 0.24.1 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
10:05:04 <tabaqui> Psybur|Work: looks better
10:06:58 <tabaqui> Psybur|Work: well, it looks fine, but no votes and 500 downloads, it scares me a little
10:07:04 <tabaqui> thanks, anyway
10:07:14 <Psybur|Work> np
10:09:21 <akr> ooh
10:09:23 <akr> okay
10:09:25 <akr> I have a huge problem
10:09:43 <akr> running `cabal update` somehow messes up this old version of cabal I'm using
10:10:05 <akr> I was using a package list from 21 days ago, everything was fine
10:10:20 <akr> now I run update, and suddenly cabal doesn't work anymore
10:13:41 <geekosaur> akr, ask in #hackage
10:14:00 <geekosaur> it should be giving you a compatible hackage index, sounds like it's not
10:14:58 <akr> geekosaur: thank you, I'll do that
10:23:50 <cheater> cocreature: i guess making generators for just a few of the datatypes that i'll need is fine
10:26:03 <yorick> how do I set environment variables for stack exec and stack ghci?
10:26:59 <cheater> you mean like this?  FOO=2 stack exec foo bar
10:27:13 <yorick> cheater: yeah. I think nix-shell is stripping them out
10:27:50 <jefrey> Hi guys! I've got an Int and want to display it in the shortest possible form of alphanum chars (just for the user to be able to compare visually if these are similar). How would you implement it ?
10:28:08 <yorick> oh, pure: false
10:28:30 <erisco> jefrey, show?
10:29:07 <mud> jefrey: Use base 62?
10:29:59 <jefrey> erisco: heh, sorry, I see my description was messy. Show would show me the Int but not in the shortest possible form, a better algorithm would be to show the Int, chunk it into strings of length 2, convert them to Ints, use Char.chr on them and we get a string that is visually 2 times shorter than show on the Int
10:30:22 <jaseemabid> What is the general opinion about parser combinators here? I've spend a *LOT* of time with megaparsec now trying to make a reasonably simple grammar work but I find it way too convoluted and very painful to understand. Should I consider alex+happy? Are there any other approaches? 
10:31:35 <jefrey> mud: base62 floks like what I want! thanks
10:31:45 <sm> they're usually the least hassle jaseemabid. If you're starting with megaparsec, I think the types can be a bit tricky to learn. Have you worked through their tutorials ?
10:31:53 <jaseemabid> The indentation APIs are painful to understand. Whitespace handling is weird. Debugging is painful. Error handling machinery is over engineered. I'm on the verge of letting it go. 
10:32:07 <glguy> jaseemabid: I find parser combinators OK for messing around and alex+happy better for building anything large
10:32:14 <sm> and are you also starting with haskell ?
10:32:16 <jaseemabid> sm, Yes. I'm fairly comfortable with the types now. 
10:32:31 <jaseemabid> sm, I'm comfortable with the haskell bits too. 
10:32:36 <erisco> jefrey, so that would be a base 100 encoding
10:33:14 <sm> ok. I'd be interested to know what you think of other haskell parser combinator libs then
10:33:16 <suitsmeveryfine> Hi! What do I need to do to write a function that on the one hand returns an IO String and on the other hand performs IO () actions such as calling ExitSuccess
10:33:48 <sm> I think parsec was a bit simpler than megaparsec is now, but is not as attractive
10:33:50 <jaseemabid> sm, I had a lot of trouble making it handle whitespace consistently for example. 
10:33:52 <jefrey> erisco: yes, indeed. Are there any standard hs implementations? I can easily roll my own, but it would be nicer to use something existing (and hoogle gives me 0 results)
10:33:55 <suitsmeveryfine> I'm able to do either one of these things, but not both.
10:34:01 <glguy> suitsmeveryfine: You don't need to do anything in particular, exitSuccess already has the type IO a
10:34:04 <erisco> jefrey, base62 is maybe not a good idea because it is case sensitive
10:34:12 <cheater> yorick: i don't know about nix-shell, sorry
10:34:27 <sm> jaseemabid: I think they have a tutorial about lexing, addressing that ?
10:34:38 <jaseemabid> glguy, I'm probably at that stage now. The time I'm wasting on megaparsec is probably not worth it. 
10:34:58 <erisco> jefrey, also 0 and O look similar, as do 1 and I
10:34:58 <glguy> jaseemabid: It's much nicer to use a separate lexer than to merge it into your parser if your language allows for it
10:35:26 <jefrey> erisco: right, do you know about any library implementing such nice conversion ?
10:35:36 <srhb> yorick: You had a nix-shell question?
10:35:45 <erisco> jefrey, I don't know of any particular encoding for this task but I am sure one and probably many have been created
10:35:47 <jaseemabid> sm, I was trying to make it work with a haskell like grammer. Optionally separate statements with ; or go with indentation aware grammar. Its becoming a bit too complex to get all cases right. 
10:35:54 <erisco> whether anything is on hackage is another question
10:36:21 <jefrey> erisco: right, I'm trying to find something. Thank you for your help! :)
10:36:33 <jaseemabid> glguy, Its a bit sad to throw away all the code though :/ But I should probably consider megaparsec as a bad mistake and sunk cost
10:36:58 <sm> I wouldn't. But no harm in taking a break in happy-land and maybe a fresh start later
10:37:21 <danilo2> jaseemabid: youre probably using it wrong. 
10:37:48 <danilo2> jaseemabid: I would never choose another way than monadic parser combinators, wheter it is megaparsec / trifecta/  anything
10:37:57 <yorick> srhb: I solved it
10:38:00 <jaseemabid> sm, I've been trying this on and off since a long time. I'd come back, try for a couple of hours and let it go once more :/
10:38:27 <glguy> jaseemabid: It's not that bad. I tossed out a parser combinator implementation of Lua and implemented it in Happy. The result was faster at parsing and clearly separated the parsed grammar out of the code
10:38:35 <jaseemabid> danilo2, I really liked this approach when I started, but very often would get stuck on something for unjustifiable long periods 
10:38:56 <danilo2> jaseemabid: show small code with a problem , i (or others) will try to help you 
10:39:14 <danilo2> jaseemabid: take in consideration taht the problem might be your lack of knowledge, not the tool
10:39:40 <erisco> code is not to be loved
10:40:27 <sm> you get stuck on unexpected parser behaviour, I assume, rather than coding and resolving type errors
10:40:29 <jaseemabid> danilo2, I accept that and I've probably spend over 30-40 hours on this already. Either the tool is bad or I'm stupid. Either way I need a new approach :)
10:41:01 <jaseemabid> https://github.com/jaseemabid/Olifant/blob/master/src/Olifant/Parser.hs#L6. Line 6 describes what I'm trying to do. The code is fairly simple
10:42:02 <suitsmeveryfine> Hi! What do I need to do to write a function that on the one hand returns an IO String and on the other hand performs IO () actions such as calling ExitSuccess
10:42:53 <jaseemabid> danilo2, line 135 explains what I have. 
10:43:30 <erisco> the good solutions you do not have to be that smart to understand
10:44:11 <danilo2> jaseemabid: to understand whats going on there somebody would have to spend about an hour, thats too much I think. If youll have any smaller code, that runs standalone, we would sovlve the issuespretty fast
10:44:53 <tabemann> I asked about this yesterday, but I'm having an issue compiling gtk2hs-buildtools
10:45:00 <tabemann> http://lpaste.net/357879
10:45:41 <erisco> suitsmeveryfine, how would you terminate the program and then return IO String? I do not understand the meaning of that.
10:45:48 <tabemann> when it ries to build Main, it spews out a bazillion of errors like:
10:45:55 <jaseemabid> danilo2, Oops. I understand. I've a couple of simple tests. Will that help? https://github.com/jaseemabid/Olifant/blob/master/test/Test/Parser.hs#L65
10:46:45 <tabemann> /usr/bin/ld: /usr/local/haskell/ghc-8.0.2-x86_64/lib/ghc-8.0.2/base-4.9.1.0/libHSbase-4.9.1.0.a(Base__165.o): relocation R_X86_64_32S against symbol `stg_bh_upd_frame_info' can not be used when making a shared object; recompile with -fPIC
10:47:23 <danilo2> jaseemabid: I would not be able to downlaod and compile the whole repo and play with it now, it's to big task for me at the moment (I'm very time limited) however, maybe there is someone whou would like to try
10:47:51 <danilo2> jaseemabid: anyway if you'll have a single file with no other deps and short code showing a problem, I should be able to help
10:48:26 <iomotoko> I know what it does and how it works, but what does 'abs' stand for?
10:48:29 <iomotoko> meaning the full term?
10:48:35 <suitsmeveryfine> erisco: If the user inputs a string, then the string is returned and if not the program terminates
10:48:40 <cocreature> iomotoko: absolute
10:48:45 <iomotoko> cocreature: thanks :)
10:49:04 <iomotoko> why not 'neg' for negate then?
10:49:19 <erisco> suitsmeveryfine, do by "returned" do you mean "printed to stdout"?
10:49:32 <tabemann> because "abs" is a conventional abbreviation
10:49:55 <suitsmeveryfine> erisco: no, that's not that hard, but I want to return it so that it can be "assigned" a value
10:50:09 <erisco> return it to what?
10:50:15 <suitsmeveryfine> erisco: to be more specific, I want to use the readline or haskeline library
10:50:31 <iomotoko> tabemann: ah k, didn't know :)
10:50:45 <suitsmeveryfine> erisco: string1 <- readline (instead of string1 <- getLine)
10:51:22 <erisco> okay, so what is the question?
10:52:33 <suitsmeveryfine> erisco: the only way I can make it return a string is by writing an IO String type declaration
10:52:45 <erisco> what do you mean by return a string? where is this string going?
10:53:28 <suitsmeveryfine> erisco: it's being assigned a variable which is then later used as an input in another function
10:53:43 <erisco> what if we start from the top and talk about what your program is suppose to do? i.e. how should it behave as a black box? then we can talk about implementing it
10:54:26 <geekosaur> tabemann, what platform are you on?
10:55:24 <erisco> I think you have a sensible idea but need some help translating it to Haskell, so lets start with the idea
10:55:27 <suitsmeveryfine> erisco: ok. it's a CLI questions and answers game. The user answers questions printed to the screen, and these answers are trimmed (e.g. any trailing punctuation is removed)
10:56:34 <erisco> okay, so the program prints a question and prompts the user for an answer
10:56:34 <suitsmeveryfine> erisco: the programs is almost ready, it's just that I want to replace getLine for getting user input by readline
10:56:39 <erisco> the user types an answer and the program reads it
10:56:48 <suitsmeveryfine> erisco: yes
10:56:48 <erisco> what then happens?
10:57:22 <tabemann> geekosaur: Debian on x86-64
10:57:35 <geekosaur> mm. can you link other executables?
10:57:40 <geekosaur> other haskell executables
10:58:05 <geekosaur> because this is sounding like the PIE business and yourr installed ghc isn;t dealing with it properly
10:58:07 <suitsmeveryfine> erisco: the inputs are compared with correct answers. If any question is incorrect the program ends, if all of them are correct the game also ends.
10:58:27 <geekosaur> (essentially, all executables are now shared libraries, and you can;t link a static library against a shared library on x86_64)
10:58:58 <suitsmeveryfine> erisco: the answers are sent to this function:
10:58:58 <suitsmeveryfine> trim :: String -> String
10:58:59 <suitsmeveryfine> trim = dropWhileEnd isPunctuation . map toLower
10:59:30 <tabemann> geeksaur: no
10:59:34 <tabemann> *geekosaur
10:59:38 <erisco> okay, so your program currently prints a question and reads an answer with getLine, and now you want to use readline instead of getLine, correct?
10:59:38 <geekosaur> there's some tweaks possible to the ghc settings file if that's the case, but installing a compatible ghc is a better solution
10:59:50 <geekosaur> how did you install ghc?
10:59:59 <tabemann> this is just straight Haskell Platform 8.0.2
11:00:28 <suitsmeveryfine> erisco: correct
11:00:40 <iomotoko> what does 'recip' stand for?
11:00:41 <erisco> why is that?
11:00:57 <Tuplanolla> Reciprocal, iomotoko.
11:01:01 <iomotoko> Tuplanolla: ty
11:01:05 <geekosaur> tabemann, https://www.haskell.org/platform/#linux-generic point 3
11:01:39 <geekosaur> apparently they didn't make a separate distribution, you have to edit the settings file but it's simpler than it used to be
11:01:53 <suitsmeveryfine> erisco: with readline or haskeline you get a nicer user experience, e.g. you can use the arrow keys to go back and forth, and the input answers can be saved in a history.
11:02:36 <erisco> neat, never knew that... I don't do IO... but okay, lets use readline then
11:02:38 <Tuplanolla> If your needs are modest, you might be able to get away with `rlwrap`, suitsmeveryfine.
11:02:43 <tabemann> geekosaur: so what do I have to do to make ghc compile anything?
11:03:03 <erisco> so you replaced getLine with readline and then what happened?
11:03:29 <geekosaur> tabemann, should I read to you the thing I pointed to?
11:03:39 <geekosaur> never mind, andwer clearly ess
11:04:05 <geekosaur> "3. If you have a system with position independent executables by default (such as Ubuntu 16.10 and above), you should edit the GHC settings file at usr/local/haskell/ghc-___/lib/ghc-___/settings and change the " compiler supports -no-pie" flag from "NO" to "YES"."
11:04:27 <suitsmeveryfine> erisco: then GHC complained about the types
11:04:49 <erisco> right, and do you see what is different about the types of readline and getLine?
11:05:21 <suitsmeveryfine> well, the example that hackage gives is that readline normally returns  IO ()
11:05:36 <erisco> you misread
11:05:39 <iomotoko> the latest haskell report is the one from 2010 I suppose?
11:05:54 <dolio> Yes.
11:05:56 <erisco> read the type of the readline function from http://hackage.haskell.org/package/readline-1.0.3.0/docs/System-Console-Readline.html
11:06:09 <dolio> Man, 7 years old already.
11:06:13 <`Guest00000> is there an easy way to understand Distribution.PackageDescription.GenericPackageDescription? i.e. a guide
11:06:16 <erisco> alternatively, ask :t readline in ghci
11:06:28 <iomotoko> dolio: time flies
11:06:40 <dsal> :t readline
11:06:41 <lambdabot> error:
11:06:41 <lambdabot>     • Variable not in scope: readline
11:06:42 <lambdabot>     • Perhaps you meant one of these:
11:06:49 <suitsmeveryfine> erisco: I see that it's IO (Maybe String)
11:06:57 <`Guest00000> :t readLine
11:06:58 <lambdabot> error:
11:06:58 <lambdabot>     • Variable not in scope: readLine
11:06:58 <lambdabot>     • Perhaps you meant one of these:
11:07:00 <erisco> no, look again
11:07:46 * dsal was about 50% sure that wouldn't work
11:08:12 <tabemann> qeekosaur: thanks
11:08:37 <tabemann> the only thing is the page you linked me didn't contain the text you read off to me
11:09:32 <suitsmeveryfine> erisco: String -> IO (Maybe String)
11:09:56 <erisco> suitsmeveryfine, correct, and what is the type of getLine?
11:09:58 <geekosaur> tabemann, that's odd considering I cut and pasted it from that page
11:10:15 <geekosaur> oh, wait
11:10:16 <suitsmeveryfine> erisco: IO String
11:10:21 <geekosaur> damned AJAXpy pages
11:10:39 <geekosaur> you have to actually click the "Generic" icon to get the text :/
11:10:45 <erisco> yes, so we used to have an IO String and now we have a String -> IO (Maybe String), so we need to do something a bit different
11:11:14 <erisco> does that clear up the issue for you?
11:12:05 <geekosaur> that really needs to be somewhere obvious, not hidden behind an AJAX action *and* beneath the fold.
11:13:05 * hackagebot distributed-process-tests 0.4.10 – Tests and test support tools for distributed-process. – https://hackage.haskell.org/package/distributed-process-tests
11:13:05 * hackagebot distributed-process 0.7.1 – Cloud Haskell: Erlang-style concurrency in Haskell – https://hackage.haskell.org/package/distributed-process
11:14:24 <dminuoso> o = (\x -> x x) (\x -> x x)
11:14:27 <dminuoso> Why wont haskell let me do that?
11:14:38 <erisco> what type do you give that?
11:15:33 <suitsmeveryfine> erisco: I've tried to read quite a bit about this but still been unable to find a good solution. Another member here sent me a different function that works, but then I'm unable to many of the other features in the readline library, such as history
11:15:51 <erisco> dminuoso, just start with \x -> x x i.e. self-application. What type does this function have?
11:16:22 <dminuoso> erisco, I see. So essentially this produces a -> a -> a -> a ....
11:16:44 <suitsmeveryfine> erisco: http://paste.lisp.org/display/354101
11:16:53 <dolio> dminuoso: Because not allowing you to do that catches tons of errors.
11:17:40 <Tuplanolla> :t (\ x -> x x) :: (forall a. a -> a) -> a -> a -- You can start with this, if you must, dminuoso.
11:17:41 <dolio> Also it keeps the optimizer from looping.
11:17:42 <lambdabot> (forall a1. a1 -> a1) -> a -> a
11:20:23 <erisco> suitsmeveryfine, is that not a good solution? what is the issue?
11:20:30 <suitsmeveryfine> erisco: something I'd like to do is to add
11:20:30 <suitsmeveryfine> "Just line -> do addHistory line", but this is incompatible with the type declaration "IO String". add history requires String -> IO ()
11:20:49 <dminuoso> dolio, so essentially type inference is not halting, and haskell detects that?
11:21:37 <erisco> suitsmeveryfine, Just l -> addHistory l >> return 1
11:22:34 <dolio> No.
11:23:02 <erisco> Tuplanolla, you bring madness
11:24:44 <dolio> During type inference there is a check for unification between a variable `a` and more complex expressions containing `a`. And failure is reported if such a thing is found.
11:25:05 <suitsmeveryfine> erisco: wow, thanks, it works!
11:25:42 <erisco> suitsmeveryfine, look at the type of >> to learn why
11:25:43 <suitsmeveryfine> erisco: the ">>" syntax is new to me. What does it do exactly?
11:26:10 <suitsmeveryfine> erisco: yeah, I guess that I should do some more reading on my own now. Thank you!
11:26:12 <erisco> it is the name of a function, an operator, it isn't syntax in the sense of being a keyword
11:26:51 <erisco> the meaning of x >> y is "do x then do y"
11:27:42 <suitsmeveryfine> erisco: oh
11:29:44 <suitsmeveryfine> erisco: so in other words, there is no problem having a function perform various different IO actions at the same time
11:30:01 <suitsmeveryfine> you just to do things in a certain order
11:30:19 <suitsmeveryfine> But I'll do some proper reading on my own. Thanks again
11:31:59 <erisco> there are several free Haskell resources including books
11:32:40 <suitsmeveryfine> erisco: yes, I'll consult those
11:33:38 <erisco> Tuplanolla, I need to understand RankNTypes better
11:34:52 <erisco> I get this example now, it is id id, but it didn't cross my mind
11:40:29 <suitsmeveryfine> Tuplanolla: thanks for the `rlwrap` tip. It seems useful in other situations.
11:42:45 <dminuoso> May I ask a (implicitly haskell related) lambda calculus question in here?
11:43:03 <Tuplanolla> You just did, dminuoso.
11:43:05 <erisco> *shrug* I won't tell
11:43:08 <dminuoso> Tuplanolla, heh.
11:44:18 <erisco> Tuplanolla, we can play this game with any polymorphic function which is well typed when applied to itself
11:44:34 <dminuoso> So according to the wikipedia a redex r (\x.A) is in head position for \x1...\xn.(\x.A)M1....
11:45:06 <Tuplanolla> Indeed, erisco.
11:45:20 <dminuoso> My question is, why that specific part? I mean somehow I would have expected the entire expression \x1...\xn.\x.A to be in head position
11:45:23 <erisco> and what do we learn from that?
11:45:51 <Tuplanolla> Do we have to learn anything, erisco?
11:46:50 <dolio> `\x1...\xn.\x.A` isn't a subexpression of your larger expression.
11:47:03 <erisco> or dually, what did you learn that lead to that intuition?
11:47:56 <cheater> hi guys
11:48:34 <cheater> how come the executable can find the modules in packages used by the library, and the bench too, but the test cannot? http://sprunge.us/LYOC
11:49:24 <dminuoso> dolio, call it \x1...xnx.A then
11:49:32 <dminuoso> okay that looks a bit unreadable
11:49:52 <Tuplanolla> I sometimes use combinators like `\ p f x -> (p f) (p x)`, where the type forces `p` to be a projection. This is just an extreme case of the same idea, erisco.
11:50:07 <dolio> That still isn't a subexpression of your larger expression.
11:51:43 <dolio> `\f x -> f` is not a subexpression of `\f x -> f x`.
11:52:11 <dolio> For example.
11:52:29 <cheater> oh ok it's because the test suite had src in the hs-src-dirs
11:52:53 <dminuoso> dolio, maybe Im associating things wrong. \a.\b.M N  how does this associate?
11:53:17 <erisco> Tuplanolla, hm, well p can have the type a -> a, and I am trying to think of what other interesting types it may have
11:53:19 <dolio> \a. (\b. (M N))
11:53:23 <erisco> I don't feel very imaginative right now
11:54:15 <Tuplanolla> Hint: `fst` and `snd` work as `p`, erisco.
11:54:22 <dolio> Otherwise there would be no need for the parentheses in your original expression.
11:55:30 <dfssner> Is this the right place to ask questions about hspec+QuickCheck?
11:55:41 <erisco> Tuplanolla, right, projections, heh
11:56:28 <dminuoso> dolio, so application is left associative, abstraction right associative, and applicatoin has higher precedence than abstraction.
11:56:40 <dminuoso> dolio, okay yeah I had this wrong in my head, no wonder it couldnt compute :)
11:57:02 <Cale> dminuoso: Generally lambdas extend as far to the right as possible
11:57:30 <dminuoso> Oh hey Cale. Thank you for your lazy explanation yesterday, it was really helpful. :)
11:57:54 <erisco> a compliment only a programmer could appreciate
11:57:59 <London_jack> How to translate this https://gist.github.com/nickspinale/27e63107bbe7890d17b2bf30d181c1f6 into Haskell using /singletons/
11:59:15 <erisco> London_jack, what does the underscore mean on line 4?
11:59:32 <London_jack> That it's inferred by the compiler
11:59:45 <London_jack> or not used
12:00:17 <London_jack> I'm primarily concerned with how to reflect term-level functions to the type level and back
12:00:47 <London_jack> but I haven't really used the /singletons/ library 
12:01:06 <crucify_me> hi the second function here seems to override the sort func. but still returns the head of a string. I don't understand what happens there, its like Ord class and sort cancel eachother out.
12:01:09 <crucify_me> https://ptpb.pw/_y2P
12:01:11 <erisco> I don't get that about the underscore
12:01:34 <erisco> singletons has some TH facilities to translate term functions to type functions, but the capability is limited
12:01:57 <erisco> and afaik you don't get to go from type functions back to term functions
12:02:43 <London_jack> Will that be a restriction of -XDependentTypes as well?
12:02:54 <London_jack> *on
12:03:12 <erisco> there is possibly something in here (and related paper) for you but I only looked for a moment a couple days ago http://hackage.haskell.org/package/reflection-2.1.2/docs/Data-Reflection.html
12:04:00 <London_jack> That would work but I did nae expect to have to go outside of singletons
12:04:10 <erisco> and there could be facilities in singletons that I am not aware of
12:05:58 <erisco> you could presumably translate lambdas to biCCCs and then have a promotion to types and back again
12:06:55 <erisco> I have also used GADTs to represent the desired functional relation
12:09:56 <London_jack> thanks, reflection will do for me
12:10:38 <bobismijnnaam> hey everyone, I hope it's not inappropriate but i've been struggling with a problem for 2 days and I could use a pointer or two. Anyone here mind taking a look? https://www.reddit.com/r/haskell/comments/6vco7r/problem_with_uniplate_and_a_polymorphic_type/
12:11:12 <cocreature> bobismijnnaam: that post shows only "[removed]"
12:11:22 <London_jack> I don't know why it was removed
12:11:25 <dminuoso> Okay, so a WHNF is if the body of the abstraction is not in normal form?
12:11:29 <erisco> maybe that is the problem
12:11:39 <London_jack> I'll approve it
12:11:44 <Tuplanolla> It would probably fit Stack Overflow better.
12:11:54 <bobismijnnaam> Wow, really? Did I do that? I certainly hope not
12:12:09 <bobismijnnaam> I thought it would be interesting cause it seems kind of a fundamental problem
12:12:48 <bobismijnnaam> Thanks London_Jack
12:14:04 <bobismijnnaam> as a taster, it involves using a polymorhpic function with transformBi from uniplate. it seems that I've made a very stupid design decision, but maybe not all is lost!
12:31:24 <lyxia> Is London_jack Iceland_jack 
12:38:03 <London_jack> lyxia: yes
12:38:39 <lyxia> bobismijnnaam: what version of GHC are you using
12:40:24 <bobismijnnaam> glorious ghc, 7.10.3. stock ubuntu 16.04 version I imagine
12:43:26 <bobismijnnaam> are you on to something?
12:43:55 <lyxia> I'm installing uniplate for this version of GHC to get the same error because it's not the same on 8.0
12:44:09 <bobismijnnaam> huh. cool
12:44:41 <lyxia> bobismijnnaam: is your question why your first line of code refers to a type a0? Or is it that even the second one doesn't compile?
12:45:50 <bobismijnnaam> I think I understand why the first doesn't compile. I would like it to, though. I'm curious where the a0 comes from but that's not the main point of the question.
12:46:31 <bobismijnnaam> (unless it's very interesting. Then it might become the main point)
12:46:46 <lyxia> Actually I had simply not realized to import the module with the right instances
12:46:59 <glguy> bobismijnnaam: I posted a response to your question on reddit
12:47:04 <bobismijnnaam> shucks
12:48:25 <bobismijnnaam> I
12:48:30 <bobismijnnaam> I'll give it a shot
12:49:57 <akr> Hi, isn't there a function to get the product of two functions in the standard library?
12:50:13 <akr> hayoo couldn't find anything, but I could swear I saw something like it some time ago
12:50:14 <bobismijnnaam> Wow. With the forall it compiles! Time for some testing!
12:50:52 <erisco> akr, how do you define the product of two functions?
12:51:01 <mud> :t (.) -- akr this?
12:51:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:51:14 <akr> no, that's function composition
12:51:23 <akr> product of functions has the type (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:51:37 <akr> (I think it should be the only function with such a type, btw., is that true?)
12:51:38 <lyxia> :t bimap
12:51:39 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:51:42 <erisco> :t (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:51:44 <lambdabot> (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:51:52 <erisco> or bimap, you know
12:51:53 <akr> oh, nice
12:52:29 <akr> thank you very much :)
12:53:00 <erisco> you didn't find that because those search engines don't do type unification, or so it seems
12:53:25 <akr> :(
12:53:56 <bobismijnnaam> glguy: a few quick tests show it works perfectly. why is the forall needed? can't haskell infer which types I mean?
12:53:58 <geekosaur> hayoo's type search is limited, hoogle 5's is broken, use hoogle 4
12:55:07 <akr> hmm, that's sad
12:56:22 <bobismijnnaam> in any case, thanks for the help fellow haskellers :)
12:56:28 <glguy> bobismijnnaam: The forall is needed because you wanted to use scoped type variables
12:56:50 <glguy> and you need to use those so that the outer parameter on AST matches the inner one on Expr
12:57:20 <bobismijnnaam> okay, that makes sense. And haskell is not smart enough to see that the outer param fits in the place of the inner one just fine, but needs me to tell it that?
12:57:23 <glguy> bobismijnnaam: There's nothing else to inform transformBi what the inner type you'd intended was
12:57:43 <glguy> It's not that it's not smart enough, they don't have to match
12:57:50 <glguy> It's up to you to decide what you meant
12:57:56 <erisco> defaults?
12:58:13 <bobismijnnaam> Hmm, interesting.
12:58:17 <thoughtpolice> Technically, there was a time when 'forall' was not needed for ScopedTypeVariables to work. You could say 'f :: a -> b' and use 'a' inside the body and they would unify if it was enabled. But it made the implementation in GHC more complicated and weird, and it was later changed to require explicit introduction of the variables.
12:58:51 <thoughtpolice> So, in theory: yes, you could get away without the 'forall'. But in practice 'forall' isn't a big burden, is more explicit and easier to deal with.
12:58:57 <bobismijnnaam> very cool
12:59:27 <mud> The forall in Scoped* used to annoy me, but then I realized that sometimes you *don't* want it to happen, and picking unique type variables just gets awkward.
13:00:07 <erisco> just add '
13:00:15 <thoughtpolice> Right, ergonomically it's a lot easier to explain. It also works out better if you do things like float variables or top-level bindings around
13:00:25 <mud> :: a''''' -> a'''''''
13:00:33 <bobismijnnaam> Heh :)
13:00:33 <thoughtpolice> (E.g. if you enable it and move some top level function into the 'where' of another function, and they use the same type variables)
13:00:50 <erisco> only a Miranda programmer could understand
13:00:58 <bobismijnnaam> I still think it's weird that I have to explicitly state that the inner param is the same as the outer param. I figured it's easy to see that my doStrLit function works on all the children of CAST just fine
13:01:32 <bobismijnnaam> (weird as in I don't really understand it. but maybe glguy's explanation just needs to sink in a little bit)
13:03:17 <cheater> with hedgehog, can i somehow make a list of strings that are different from each other? my property fails when hedgehog creates a list of strings that are the same. but that actually shouldn't be happening.
13:05:09 <simony> what's an image processing library I should look at if I want to process some images and extract say a color palette?
13:06:03 <lyxia> cheater: use filter
13:06:34 <lyxia> cheater: or apply a function that deduplicates
13:06:54 <bobismijnnaam> nub does that right
13:07:09 <lyxia> right
13:07:49 <lyxia> simony: juicypixels, perhaps
13:08:13 <cheater> @type nub
13:08:15 <lambdabot> Eq a => [a] -> [a]
13:08:20 <simony> lyxia: thanks
13:08:23 <bobismijnnaam> sweet
13:11:00 <bobismijnnaam> good night guys
13:12:08 <mud> cheater: Note that if the lists are long, 'nub' isn't so good (it's inefficient enough to matter). Doesn't sound like that'll matter to you, but just in case.
13:17:37 <Psybur|Work> Cant you just make a Set and turn it back into a List?
13:18:38 <mud> Yes
13:19:01 <erisco> if you mean Data.Set specifically, sure
13:20:40 <Psybur|Work> Or would Data.HashSet be better in this case if we don't care about ordering?
13:22:17 <Psybur|Work> Nvm, it appears HashSet is just a Set
13:23:05 <Psybur|Work> Unless I just read this doc wrong lel
13:23:23 <mud> In general which is better between a BST-ish set and a hashtable-ish set depends on what your elements are and how hard it is to compare them and I guess how well they're implemented.
13:24:40 <Psybur|Work> If you want to get a unique list of strings, I think maybe the bst would be faster since when you compare strings you may not have to traverse the whole string whereas with a hashset you do have to traverse the whole string to generate a hash
13:25:03 <erisco> if you want a unique list of strings, use a trie
13:26:47 * hackagebot http2-client 0.3.0.0 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
13:27:01 <Psybur|Work> erisco, fascinating
13:27:16 <Psybur|Work> Never heard of that structure before
13:29:29 <erisco> oh, don't worry, there are more data structures than lifetimes
13:41:10 <cheater> thank you lyxia and mud
13:43:39 <cement> I know the "canonical" usage for tries (word prompts on phone keyboards) but I've seen very few examples of other uses
13:44:17 <erisco> tries were around longer than that
13:45:22 <jle`> i thought the canonical usage for tries was boggle solvers
13:45:38 <jle`> ;)
13:45:39 <mud> cement: programming contests xD
13:46:39 * hackagebot datarobot 0.1.1 – Client for DataRobot API – https://hackage.haskell.org/package/datarobot
13:46:39 * hackagebot datarobot 0.1.0 – Client for DataRobot API – https://hackage.haskell.org/package/datarobot
13:46:42 <dminuoso> given `foo a b = a + b`, is the expression (foo 1) in WHNF?
13:47:24 <dminuoso> Does this fall under "lambda abstraction" in https://wiki.haskell.org/Weak_head_normal_form ?
13:48:03 <erisco> (\a -> \b -> a + b) 1 => \b -> 1 + b
13:48:07 <erisco> now it is in whnf
13:48:08 <jle`> yes, you can think of it as foo a = (\b -> a + b)
13:48:22 <jle`> so foo 1 = (\b -> 1 + b)
13:48:35 <dminuoso> jle`, okay. I was not sure about the exact equivalence between the two
13:49:12 <erisco> you just reduce (evaluate) as much as you can but only from the outside, don't go in
13:50:13 <dminuoso> erisco, if I understand it correctly arguments can be redexes, and even the body of an abstraction can be a redex (this seems to make the difference between HNF and WHNF)
13:52:05 <erisco> you mean the normal form?
13:53:03 <jeltsch> cabal-install 2.0 does not build a local documentation index. Why?
13:53:16 <jeltsch> It used to work with previous versions of cabal-install.
13:53:27 <erisco> I dunno, I forget what head normal form is
13:56:02 <erisco> to be in normal form you have to make all possible reductions, or eliminate redexes, however you want to say it
13:59:11 <jeltsch> erisco: In head normal form, all “outer” values of ADTs have their data constructors evaluated.
13:59:23 <jeltsch> By “outer”, I mean that they are not part of other such values.
13:59:50 <jeltsch> For example, 1 + 1 : repeat 0 is in HNF.
13:59:57 <jeltsch> Because the (:) is there.
14:00:20 <jeltsch> This also has to be the case under abstractions (“lambdas”).
14:00:40 <jeltsch> For example, \ x -> repeat x is not in HNF.
14:00:47 <jeltsch> But \ x -> x : repeat x is.
14:01:10 <jeltsch> In *weak* head normal form, it does not matter what is under a lambda.
14:01:17 <jeltsch> So \ x -> repeat x is also in WHNF.
14:01:23 <jeltsch> This is at least how I remember it.
14:02:00 <dminuoso> jeltsch, "it does not matter what is under a lambda" means it was not beta reducedf
14:02:54 <erisco> okay, so if we're weak we don't go snooping in abstractions, and if we're non-weak we do
14:02:56 <jeltsch> dminuoso: And abstraction (“lambda expression”) is in WHNF. So the thing to the right of the arrow can be anything.
14:03:04 <jeltsch> erisco: Yes.
14:03:24 <jared-w> erisco: Some people prefer to think of behavior in WHNF/HNF in terms of 'undefined'
14:03:52 <jared-w> Since it doesn't matter what's under a lambda, bottom can exist in a lambda that's in WHNF. It will explode quite violently if it's present in a lambda expression that's in HNF, though (iirc)
14:04:05 <jeltsch> Haskell’s seq function reduces to WHNF. It will reduce repeat 0 to 0 : repeat 0, but it will reduce functions only to an abstraction.
14:05:07 <jeltsch> jared-w: Yes, \ x -> undefined is in WHNF, but not in HNF. Attempting to reduce it to HNF will fail.
14:05:49 <erisco> I don't know what use HNF has to me but good to know
14:05:53 <dminuoso> jeltsch, so every term is in WHNF if you have nothing to the right side of an abstraction?
14:06:11 <dminuoso> jeltsch, I mean if you had (A B) its reducible, whatever A may be
14:08:15 <jeltsch> erisco: If you look at the definitions of HNF and WHNF in plain λ-calculus (without ADTs), the definition of HNF looks very smooth, while the definition of WHNF looks rather ad-hoc. So HNF is somehow more sensible, but in Haskell, WHNF is the one that is more important.
14:08:38 <jeltsch> dminuoso: I don’t understand.
14:09:02 <jared-w> jeltsch: WHNF is the important one due to the presence of laziness, I believe
14:09:12 <jeltsch> dminuoso: I meant that every term of the form \ x -> e is in WHNF, no matter what expression e is.
14:10:32 <jeltsch> jared-w: Not really. If you would apply lazy evaluation to an expression of the form \ x -> e, it would start reducing the e, I believe.
14:10:41 <dminuoso> jeltsch, okay. is \x -> e in HNF then?
14:10:52 <jeltsch> jared-w: The question regarding WHNF vs. HNF is more about how long you evaluate.
14:11:05 <dminuoso> If I go straight by this definition which says for a term to be in HNF it may not be beta reducible (which a lambda abstraction very much is)
14:11:08 <jeltsch> dminuoso: \x -> e is in HNF if and only if e is in HNF.
14:11:46 <jeltsch> dminuoso: For example, \ x -> \ y -> \ z -> x : y + z : undefined is in HNF, because x : y + z : undefined is in HNF.
14:11:48 <jared-w> jeltsch: well if you have an infinite list of `ones = 1 : ones` you can take 10 from the infinite list without breaking things because it's in WHNF not in HNF but the 1 is always in HNF
14:12:17 <jeltsch> jared-w: For ADTs and base types (like Int), WHNF and HNF are the same.
14:12:22 <jeltsch> They only differ for functions.
14:12:32 <jared-w> ah, gotcha
14:13:20 <jeltsch> jared-w: In the case of functions, \ x -> e is always in WHNF, but it is in HNF if and only if e is in HNF.
14:13:39 <dminuoso> jeltsch, so in LC notation (\x.(\y.a)A) is in WHNF but not in HNF
14:13:59 <jeltsch> dminuoso: Yes.
14:14:49 <dminuoso> jeltsch, oh interesting. And likewise (\x.(\y.a)A)B would be neither.
14:15:02 <jeltsch> dminuoso: Exactly.
14:26:24 * hackagebot xxhash-ffi 0.1.0.0 – Bindings to the C implementation the xxHash algorithm – https://hackage.haskell.org/package/xxhash-ffi
14:36:23 <cheater> other than haddocks, property tests, and benchmarks, what other things do you think a well made haskell code base should feature?
14:38:09 <lyxia> users
14:38:38 <cheater> i can't put those in git
14:38:53 <lyxia> :(
14:39:23 <sm> good readme & changelog
14:39:36 <sm> tutorial 
14:41:05 <sm> website
14:41:39 <sm> maintained presence in hackage, stackage, distros
14:41:42 <lyxia> continuous integration, linting
14:42:05 <cheater> oh can i add a call out to hlint to my cabal file?
14:42:22 <cheater> btw, another question, what's the best way to get a list's head or a default value for an empty list?
14:43:02 <cheater> or rather than that: what's a good command line args library?
14:43:20 <cheater> i want to be able to do ./myprog or ./myprog 1000  and that number should be passed to a function as an int.
14:43:34 <johnw> I like optparse-applicative
14:43:59 <mud> cheater: The 'safe' package has functions like headMay, for the original question. But yeah, argument parsing library probably better.
14:51:58 <cheater> thx
14:52:58 * hackagebot xxhash-ffi 0.1.0.1 – Bindings to the C implementation the xxHash algorithm – https://hackage.haskell.org/package/xxhash-ffi
14:54:24 <tsaka_> does anyone have real-world experience using the haskell bindings for tensorflow? are they good enough for production work or writing a thesis?
15:05:38 <jle`> tsaka_: have you seen that recent blog post about using the haskell bindings for tensorflow
15:17:09 <grants> If I run `sequence [[1,2] [3,4]]` I get [[1,3],[1,4],[2,3],[2,4]]. I want to do something like `foo [(a, [1,2]), (b, [3,4])]` and get [[(a,1), (b,3)],[(a,1), (b,4)],[(a,2),(b,3)],[(a,2),(b,4)]]
15:17:31 <grants> That is, I want to sequence based on the list that is second in the pair, and have the first element of the pair sort of carried along
15:17:40 <grants> Any clever ideas on how to do this elegantly?
15:18:08 <Cale> do (x,xs) <- ps; y <- xs; return (x,y)
15:18:36 <Cale> There's probably something good for that...
15:19:17 <grants> > do (x,xs) <- [('a', [1,2]), ('b', [3,4])]; y <- xs; return (x,y)
15:19:19 <lambdabot>  [('a',1),('a',2),('b',3),('b',4)]
15:19:24 <grants> Not what I want
15:19:39 <Cale> er, sorry
15:20:44 <Cale> > do (x,xs) <- [('a', [1,2]), ('b', [3,4])]; return [(x,y) | y <- ys]
15:20:46 <lambdabot>  error:
15:20:46 <lambdabot>      • Variable not in scope: ys :: [t]
15:20:46 <lambdabot>      • Perhaps you meant one of these:
15:20:58 <Cale> > do (x,ys) <- [('a', [1,2]), ('b', [3,4])]; return [(x,y) | y <- ys]
15:21:00 <lambdabot>  [[('a',1),('a',2)],[('b',3),('b',4)]]
15:21:02 <byorgey> grants: sequence . map sequence
15:21:11 <Cale> hah
15:21:32 <Cale> yeah, and then you want to sequence that
15:21:36 <Cale> heh
15:21:39 <grants> magical
15:21:50 <byorgey> > let ps = [('a', [1,2]), ('b', [3,4])] in sequence . map sequence $ ps
15:21:52 <lambdabot>  [[('a',1),('b',3)],[('a',1),('b',4)],[('a',2),('b',3)],[('a',2),('b',4)]]
15:21:55 <jared-w> > sequence . map sequence [(5,[1,2]),(6,[3,4])]
15:21:56 <Cale> I see, that's sequence for pairs
15:21:58 <lambdabot>  error:
15:21:58 <lambdabot>      • Couldn't match expected type ‘a1 -> t (m a)’
15:21:58 <lambdabot>                    with actual type ‘[[(Integer, Integer)]]’
15:22:21 <grants> had no idea sequence for pairs was defined
15:22:22 <byorgey> Cale: indeed
15:22:37 <jared-w> whoops, forgot the $, byorgey already gave the better example anyway :p
15:24:54 <grants> thanks byorgey, super clever 
15:25:11 <byorgey> glad to help =)
15:25:40 <grants> Where is the monad instance for pair defined?
15:26:27 <byorgey> grants: it's not a monad instance for pair that's relevant, it's the Traversable instance
15:26:38 <byorgey> :type sequence
15:26:46 <byorgey> @type sequence
15:26:49 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:27:04 <grants> Ah..
15:27:08 <byorgey> in this case  t = (,) a  and  m = []
15:27:44 <Cale> It of course traverses the second component of the pair, which is also the part that fmap acts on.
15:28:08 <Cale> You can think of a pair as being like a container with a label and a single element
15:28:26 <byorgey> yeah, so my code is 'cheating' a little bit, in the sense that I was lucky you put the stuff you wanted to be carried along first, and the lists second =)
15:28:50 <Cale> I suppose if he hadn't, you could just write the traversal for the first component
15:29:26 <byorgey> true
15:30:55 <Cale> > let ps = [('a', [1,2]), ('b', [3,4])] in sequence . map (_2 id) $ ps
15:30:56 <lambdabot>  [[('a',1),('b',3)],[('a',1),('b',4)],[('a',2),('b',3)],[('a',2),('b',4)]]
15:31:13 <Cale> > let ps = [([1,2],'a'), ([3,4],'b')] in sequence . map (_1 id) $ ps
15:31:15 <lambdabot>  [[(1,'a'),(3,'b')],[(1,'a'),(4,'b')],[(2,'a'),(3,'b')],[(2,'a'),(4,'b')]]
15:31:57 <byorgey> right, and you can use e.g.  sequenceOf _1  instead of   _1 id  if you want to be a bit less cryptic.
15:32:20 <byorgey> > let ps = [('a', [1,2]), ('b', [3,4])] in sequence . map (sequenceOf _1) $ (map swap ps)
15:32:22 <lambdabot>  [[(1,'a'),(3,'b')],[(1,'a'),(4,'b')],[(2,'a'),(3,'b')],[(2,'a'),(4,'b')]]
15:44:16 <jle`> there's bitraverse in base now
15:44:30 <jle`> but annoyingly no lefttraverse / righttraverse
15:44:55 <mniip> bitraverse pure?
15:45:55 * hackagebot dump-core 0.1.3.1 – A plug-in for rendering GHC core – https://hackage.haskell.org/package/dump-core
15:46:28 <jle`> that's only righttaverse
15:54:47 <mniip> (`bitraverse` pure)
16:09:08 <schoppenhauer> hi. is there a monad transforming version of Control.Monad.ST? I need an STArray inside another monad.
16:09:51 <schoppenhauer> more specifically, I want to change it randomly, and I am in a monad for the randomizer
16:11:12 <mniip> schoppenhauer, much like IO, ST can only be at the end of a monadic stack
16:11:58 <schoppenhauer> mniip: ok, but then, I have a typeclass class Monad m => MonadIntSequence m where getInt :: m Int
16:12:21 <schoppenhauer> mniip: how can I have something that is in ST and another monad which is part of that typeclass
16:13:07 <mniip> I don't see a problem
16:13:07 <schoppenhauer> mniip: I tried to specify changeRandom :: (MonadTrans m, MonadIntSequence (m (ST s))), but then I get errors when trying to do readArray
16:13:30 <mniip> yeah you need to lift $ readArray
16:13:45 <schoppenhauer> ah
16:13:49 <schoppenhauer> mniip: ok, sorry, yeah
16:13:53 <schoppenhauer> mniip: thank you!
16:14:01 <mniip> for convenience you might need to define a MonadST analogous to MonadIO
16:14:06 <mniip> assuming this doesn't exist yet
16:14:29 <johnw> it's in monad-st
16:14:58 <mniip> yeah was just looking for it
16:42:05 * hackagebot alex-tools 0.3 – A set of functions for a common use case of Alex. – https://hackage.haskell.org/package/alex-tools
17:05:42 <koz_> Could someone tell me why I'm getting this from 'stack build'? http://lpaste.net/357897
17:05:56 <koz_> I've tried searching for that error message, but I'm not getting this end of anywhere.
17:06:48 <mud> koz_: Sounds like you're using some cabal feature that requires version 2.0, which stack still doesn't support in a released version. The dev branch has started to? I don't know how far along it is.
17:07:06 <koz_> mud: Ah, I see. That's annoying, but I guess them's the breaks.
17:07:18 <c_wraith> backpack is one feature that will definitely cause that
17:07:28 <koz_> c_wraith: I'm trying to use protolude-0.2
17:07:49 <koz_> Which isn't in the LTS resolver (but is in the nightly), but that's how I got this error in the first place.
17:09:18 <koz_> Guess I can use an older protolude, but it's kinda irksome. Also, I'm a bit confused as to how you can have 'doesn't work with stack' and 'is in the nightly resolver' at the same time.
17:12:47 * pacak fails to understand those people who use non-standard prelude.
17:21:28 <geekosaur> koz_, trnalsates to "needs a stack which was built against Cabal 2.x"
17:21:57 <koz_> geekosaur: Clearly mine wasn't. OK, thanks. Gonna just use an older protolude for now.
17:23:07 <geekosaur> you might try upgrading stack
17:26:22 <jared-w> pacak: non standard preludes are kinda nice for wrapping together a lot of small changes you'd probably want to make anyway like getting rid of partial prelude functions, making "best practices" the default practices, etc.
17:30:23 <koz_> Could someone help me figure out this typelevel number-related issue? http://lpaste.net/5680466566789988352
17:30:25 <pacak> jared-w: I find partial prelude functions useful in some cases. In fact removal them in yesod was one of my main wtfs with it.
17:31:22 <pacak> koz_: data Blah :: (x :: Nat) -> .... ?
17:31:59 <koz_> pacak: Sorry, I don't quite follow.
17:33:02 <erisco> koz_, (->) :: * -> * -> *
17:33:41 <dsal> If I want to serve a static dir and a couple endpoints that spit out some JSON, is yesod the goto?
17:33:56 <pacak> It looks like you are trying to promote value level value to type level value. Haskell isn't dependently typed...
17:34:02 <jared-w> dsal: yesod sounds a bit heavy if you have something super simple you want to do
17:34:28 <koz_> pacak and erisco: So am I misunderstanding this? http://dev.stephendiehl.com/hask/#typelevel-numbers
17:34:32 <jared-w> pacak: Haskell isn't dependently typed, but you can employ some judicious hasicism to get you most of the way there ;)
17:34:34 <erisco> BV :: V.Vector Word8 -> Bitvector i  is an option with TypeApplications,  BV @Z v  for example
17:34:41 <pacak> dsal: Yesod is not really haskell. Yesod is yesod.
17:34:50 <pacak> jared-w: Sure enough, just not directly.
17:35:09 <dsal> I'm porting a go program I wrote a long time ago to haskell.  It reads a serial port and keeps a few recent values it's pulled off the port and serves them up as JSON.  Also has some static bits.
17:35:16 <erisco> another option is  BV :: proxy i -> V.Vector Word8 -> Bitvector i   BV (Proxy :: Proxy Z) v
17:35:32 <pacak> koz_: This example uses Nil and Cons so no values are promoted directly.
17:35:45 <erisco> or however that thing is defined
17:35:50 <jared-w> koz_: does compiling work? Ghc-mod might just not be typechecking things correctly due to lacking support for something?
17:36:01 <koz_> pacak: Ah, I see. But what about the vec3 definition below?
17:36:17 <erisco> or you can use singletons, so BV :: Sing i -> V.Vector Word8 -> BV i   BV SZ v
17:36:24 <pacak> koz_: Those cons/cons/cons....
17:37:00 <koz_> pacak: Ah, I think I see it now.
17:37:11 <koz_> Thanks - I was really confused as to why what I was trying to do wasn't working.
17:37:20 <koz_> erisco: Could you link me to something on singletons?
17:37:31 <pacak> @hackage singletons
17:37:32 <lambdabot> http://hackage.haskell.org/package/singletons
17:37:44 <erisco> the singletons paper, but all you need from it for this is way simpler than that
17:38:44 <koz_> erisco: OK, thanks for that. So I should add singletons to my deps, and import what exactly? Just Data.Singletons?
17:39:22 <erisco> this is all you need from singletons, really http://lpaste.net/357898
17:39:39 <erisco> just the data family Sing, and I gave an example instance, and the type class SingI
17:40:07 <erisco> I do not use that package because it is a monster
17:40:11 <erisco> I just use those two pieces
17:40:12 <xcmw> Is there a function of type String -> String -> String -> String that replaces the last occurrence of a string with a new string?
17:40:24 <erisco> so if you can find those in the singletons package and import them, go for it
17:40:25 <pacak> Read the paper. There are some downside to using singletons...
17:40:27 <koz_> erisco: I... kinda noticed it was big. What extension(s) do I need to introduce your code?
17:40:34 <koz_> pacak: Such as?
17:40:47 <erisco> a few, ghc will tell you
17:41:01 <koz_> erisco: Thanks.
17:41:16 <pacak> koz_: A bunch of stuff will be performed during runtime.
17:41:46 <pacak> xcmw: I think there was something like  that in text library, not sure.
17:41:50 <erisco> I couldn't care less about that myself so don't listen to me for performance
17:42:33 <pacak> xcmw: Even less sure about "the last occurence" part.
17:42:39 <erisco> you can just use a type  data Proxy a = Proxy  like I said... I gave three ways to do it
17:42:55 <erisco> TypeApplications is the more hip way to do it
17:43:14 <koz_> erisco: Let me have a read of the TypeApplications description.
17:44:06 * pacak is stuck with ghc 7.10 for now, no TypeApplications for /me
17:44:41 <erisco> the point of singletons is that your type has a value, it isn't phantom
17:47:48 <koz_> erisco: So... which one should I use? I'm a bit confused about all of these things, as I'm only hearing about them for the first time today.
17:48:05 <erisco> you're going to have a problem with statically checking index bounds unless you are using singletons
17:48:27 <koz_> erisco: That basically means I'm using Singletons, then.
17:48:34 <erisco> but such checking can become complicated
17:53:22 <erisco> index :: Fin n -> Bitvector n -> Word8   will be the type of your indexing function
17:55:07 <erisco> then your trick is to convince GHC that for your i :: Fin m and v :: Bitvector n that m ~ n
17:56:44 <koz_> erisco: OK, I'll try and see what happens.
17:57:26 <erisco> and like pacak said, this probably has frightening performance characteristics
17:58:10 <koz_> Sadface.
17:58:26 <erisco> well, we're kinda encoding numbers as a list of unit
17:58:28 <pacak> koz_: Using Cons is free.
17:58:39 <erisco> 0 [], 1 [()], 2 [(),()], 3 [(),(),()] ...
17:59:19 <koz_> pacak: I don't think the Cons approach will work in my case, though.
17:59:25 <koz_> It's fine - I'll just do without this time.
17:59:33 <pacak> Also frightening - might be not as bad... Just make sure to do some benchmarks.
17:59:37 <koz_> That example of typelevel numbers kinda got my hopes up.
18:00:58 <erisco> pacak, when we have Peano naturals beside a Vector of Word8's I have to chuckle at the irony
18:02:55 <pacak> erisco: You can use proper type level naturals to merge vectors with known sizes.
18:03:10 <pacak> So Cons can use +1 instead of Succ
18:05:38 <erisco> I haven't used them. I am not sure what the overall capability is particularly when it comes to proving an index is in bounds
18:28:10 <koz_> If you have potential failure (such as someone asking for a vector of negative size), is the correct way to wrap it in an Alternative or to use Except?
18:30:43 <jared-w> ಠ_ಠ
18:32:22 <koz_> jared-w: ??
18:33:06 <jared-w> Just a quick sanity check. People can see and hear my messages on #haskell but I can't seem to query bgamari on #ghc for some reason and I'm not sure if anyone's seeing my messages on that channel
18:34:06 * hackagebot palette 0.1.0.5 – Utilities for choosing and creating color schemes. – https://hackage.haskell.org/package/palette
18:35:09 <MarcelineVQ> sanity?
18:35:48 <MarcelineVQ> query isn't channel specific
18:38:46 <monochrom> koz_: I don't think you have to choose. Except is an instance of Alternative too, is that right? But if you already have a Maybe, you can already use Maybe's Alternative-ness. It's up to you which one is more convenient for the rest of your code, Except or Maybe.
18:38:48 <pacak> jared-w: O_o
18:38:55 <jared-w> Yes, I know, which is why I was was making sure it worked on both #ghc and #haskell. I never got a reply to my prior message on #ghc (it was just a random comment)
18:39:24 <jared-w> The problem ended up being that ben must've changed his settings to only allow queries from registered users and I just realized I never actually registered this nick (forgot to do so)
18:39:30 <monochrom> Ohai jared-w I see you too. But I mean here. I don't know about #ghc.
18:39:45 <monochrom> Or PM, yeah.
18:40:02 <jared-w> Yeah I figured the issue out :p
18:40:31 <pacak> koz_: If vector size is encoded with peano numbers - there are no vectors with negative size.
18:43:47 <ClaudiusMaximus> jared-w: freenode recently changed the default user mode for "only receive pms from registered users" due to spam attacks
18:44:41 <geekosaur> ^
18:44:55 <geekosaur> someone was spamming child porn links in /msg
18:45:05 <jared-w> ClaudiusMaximus: gotcha. I'll wager that I've lost quite a few PMs due to that if non registered users can't get PMs :|
18:45:15 <monochrom> Oh yikes.
18:45:31 <pacak> When was it?
18:45:41 <monochrom> I guess it will last until all the spammers bother to register!
18:45:49 <ClaudiusMaximus> 17 august
18:46:29 <pacak> I see. We have a bot that sits on our channel and forwards messages into internal chat - it got banned on that date as well.
18:46:35 <jared-w> monochrom: registering requires having an email so it makes it much easier to limit this sort of thing because you can block the email address or even entire domains from registering new nicknames
18:46:56 <MarcelineVQ> ClaudiusMaximus: I wasn't aware they made a general change like that, are you sure?
18:47:15 <geekosaur> you ca  probvably get it unbanned; the news article also notes that a malfunctioning utility tried to ban all freenode users while they were trying to mass-ban the spammer
18:47:16 <ClaudiusMaximus> 11:23 [freenode] -christel(christel@freenode/staff/exherbo.christel)- [Global Notice] In light of the wave of spambots sending links to child pornography images, we have chosen to update our default umodes to include +R (blocking messages from unregistered users). To allow such messages, /mode yournick -R. Apologies  for the disruption and the inconvenience.
18:47:36 <geekosaur> https://freenode.net/
18:47:46 <geekosaur> iit's still the most recent news item
18:48:13 <MarcelineVQ> :(
18:48:14 <geekosaur> second paragraph is about the umode change, third mentions the malfunctioning ban
19:10:57 <halogenandtoast> > 1 + 1
19:10:59 <lambdabot>  2
19:11:06 <halogenandtoast> Okay good, at least lambdabot is here
19:11:43 <MarcelineVQ> @bot
19:11:43 <lambdabot> :)
19:12:24 <jared-w> @bot
19:12:24 <lambdabot> :)
19:12:27 <jared-w> sweet
20:03:33 <koz_> Argh, why does do-notation keep throwing parse errors for me...
20:04:27 <Clint> you're doing it wrong?
20:04:52 <koz_> Clint: Clearly, but I'm not sure how.
20:05:12 * Clint nods.
20:05:33 <koz_> Indentation, got it.
20:05:39 <Clint> good work
20:06:04 <koz_> I never understood the indentation rules for do-notation.
20:06:29 <jle`> just indent to the first line
20:06:31 <jle`> in the do notation
20:07:19 <jle`> https://en.wikibooks.org/wiki/Haskell/Indentation
20:07:22 <jle`> :D
20:07:35 <jle`> a lot of haskell rules are just "the first line in the block sets the rest of the block"
20:08:08 <koz_> Ah, I see. Thanks jle`!
20:08:23 <jle`> that critical first character of the first line
20:12:27 <koz_> When I do stuff with mutable vectors, is the pattern something like 'runST (do v <- unsafeNew x; initializeVInST; unsafeFreeze v)'?
20:12:40 <koz_> :q
20:12:44 <koz_> Whoops
20:14:03 <`Guest00000> what are any notable compilers written in haskell outputting x86 / x64 native code? preferably for simpler languages than haskell
20:14:58 <jle`> koz_: looks roughly like 'modify'
20:15:10 <pacak> `Guest00000: ghc....
20:15:15 <jle`> oh, i thought you asked if that pattern existed anywhere
20:15:26 <koz_> jle`: I'm having a bit of trouble with runST after doing that.
20:15:39 <jle`> any specific issues?
20:15:56 <koz_> I get an error saying I have 'ST s0 (V.Vector Word8)', but apparently it wants 'forall s . ST s (V.Vector Word8)', and I'm not even sure I understand what the issue is.
20:16:26 <jle`> paste some code
20:16:32 <koz_> jle`: One sec.
20:16:36 <jle`> the issue is that you seem to have written an ST for some specific 's'
20:16:39 <geekosaur> koz_, I think you will have to show code. but: understand that you cannot take something out of ST and put it back in again, if it refers to "s".
20:16:45 <geekosaur> and you will get errors like that if you try
20:16:53 <geekosaur> or if you try to control the "s"
20:16:54 <jle`> but runST can only take things that are polymorphic for s's
20:17:23 <geekosaur> ST *works* by supplying an "s" that you cannot touch
20:17:41 <jle`> that kind of error happens when you accidentally fix/monomorphise s
20:17:56 <jle`> which is easy to do accidentally if you aren't watching out for it
20:18:43 <koz_> jle` and geekosaur: http://lpaste.net/357902
20:18:50 <koz_> I assume the issue is wtf fixing an s?
20:19:23 <geekosaur> no, I thin it's implicitg there
20:19:31 <jle`> ah yeah it looks like you're being hit by the DMR
20:19:36 <koz_> DMR?
20:19:40 <jle`> the old nemisis of every new haskeller
20:19:43 <jle`> and old haskeller
20:19:47 <jle`> alike
20:19:49 <jle`> @where DMR
20:19:50 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:20:01 <koz_> So LANGUAGE NoMonomorphismRestriction?
20:20:04 <geekosaur> oh, theNeedful
20:20:08 <geekosaur> possible.
20:20:13 <jle`> no, you probably want the monomorphism restriction on
20:20:16 <jle`> in general
20:20:17 <geekosaur> also possible: BV i . runST $ theNeedful
20:20:22 <jle`> just give theNeedful a type signature
20:20:25 <jle`> a polymorphic type signature
20:20:29 <jle`> so GHC knows to keep it polymorphic
20:20:38 <geekosaur> is possibly not enough like the evil hack that makes runST $ ... typecheck
20:20:46 <jle`> haskell tries its best to monomorphise let bindings
20:20:47 <koz_> Let me try said evil hack.
20:20:55 <geekosaur> huh?
20:21:06 <geekosaur> said l hack is in the typechecker, it is not a user program trick
20:21:12 <koz_> Oh, never mind, I misread.
20:21:17 <koz_> I'll try and give theNeedful a type sig.
20:21:22 <geekosaur> the point is that the parameter to runST is impredicative
20:21:42 <geekosaur> there is an evil hack in the typechecker to make ($) impredicative in precisely that case
20:21:42 <jle`> using $ will probably work too, $ has sort of magic syntax attached to it to keep things polymorphic like that
20:22:03 <geekosaur> it doesn't apply to (.) and more complex combinations might not look enough like the specific case where the impredicative hack is triggered
20:23:29 <koz_> http://lpaste.net/357902 <-- is this what you meant, jle` and geekosaur?
20:23:57 <geekosaur> and if the hack doesn'y trigger, both ($) and (.) will try to make it a monotype, which violates the (forall s.)
20:24:20 <jle`> same error?
20:24:36 <koz_> jle`: Yes.
20:24:52 <jle`> and it's with theNeedful in generate?
20:24:57 <jle`> not in wtf ?
20:25:18 <koz_> The error I get is on the line with runST specifically.
20:25:36 <jle`> hm
20:25:39 <jle`> might be an issue with (.)
20:25:46 <koz_> Let me try removing it.
20:25:55 <jle`> try BV i (runST theNeedful)
20:26:00 <koz_> Yep, that works.
20:26:10 <koz_> So basically (.) is the issue?
20:26:13 <jle`> yeah
20:26:17 <koz_> Argh.
20:26:22 <jle`> (.) monomorphisizes its arguments
20:26:30 <geekosaur> right, that was what I was trying to explain
20:27:17 <koz_> geekosaur: So I assume the evil hack for ($) isn't there for (.)?
20:27:22 <geekosaur> it's not
20:27:32 <geekosaur> and combinations of (.) and ($) can also confuse it into not doing the hack
20:28:00 <geekosaur> (which basically permits an impredicative polymorphic type where it wouldn't otherwise be permitted)
20:28:02 <jle`> if you apply the type of (.) to runST i think it ruins it
20:28:13 <jle`> `runST $ ...` doesn't actually *apply* the ($) function
20:28:18 <jle`> it's literally just syntax
20:28:46 <jle`> which is kind of gross, now that i think about it
20:29:00 <geekosaur> right but it leaves a breadcrumb in tne typechecker which can be detected and used to force a polytype there that would otherwise be illegal
20:29:03 <jle`> `f $ ...` actually ignores the definition of ($)
20:29:08 <koz_> I was getting super confused about that earlier.
20:29:17 <geekosaur> it is confusing
20:29:26 <geekosaur> the real story is even more confusing, I suspect
20:29:46 <koz_> So basically, don't (.) in the presence of runST?
20:29:54 <geekosaur> right
20:30:21 <jle`> i wish there was a way to make a rankn-respecting (.)
20:30:24 <geekosaur> and be very careful in general with runST, about the only thing guaranteed to work is runST (foo ...) or *if it is simple enough*  runST $ foo ...
20:30:35 <jle`> then my RankN "lenses" would compose properly
20:30:42 <geekosaur> but not runST . foo, or possibly anything . runST $ ...
20:30:52 <geekosaur> it's ugly in there
20:31:22 <jle`> i use RankN equivalents of lenses/traversals very often but i just have to get used to the fact that they don't compose
20:31:27 <jle`> with (.)
20:31:52 <koz_> Alrighty, I have learned my lesson. Hopefully.
20:34:01 <koz_> Also, thanks for reminding me about modify, jle`.
20:34:05 <koz_> I keep forgetting it exists.
20:36:15 <jle`> no problem :)
20:36:23 <jle`> yeah i usually use modify and other higher order functions these days instead of runST
20:38:25 <koz_> jle`: But once you freeze a mutable vector, don't you have to runST it anyway?
20:38:53 <jle`> 'modify' is an abstraction over manually running runST
20:39:17 <koz_> jle`: Are we talking about the same modify? http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed-Mutable.html#v:modify
20:40:07 <jle`> koz_: ah yes we are not
20:40:09 <jle`> http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#v:modify
20:43:31 <koz_> jle`: Ah, I see.
20:44:17 <jle`> not that it also requires a polymorphic/impredicative ST s function
20:44:55 <jle`> *note
20:45:09 <koz_> jle`: That looks much easier to work with.
20:45:29 <jle`> yeah, higher order funcions are the best :)
20:52:06 <koz_> jle`: I assume modify will behave appropriately in the presence of (.) and ($)?
20:59:13 <jle`> yeah the order of arguments makes it harder to mess up $ with modify
20:59:38 <jle`> you can't `flip modify`, though, due to the same issues with (.)
21:00:12 <koz_> I'm not in a hurry to flip modify, so I think I'll be fine. :)
21:00:20 <jle`> it's tempting :)
21:00:42 <jle`> to do things like `flip modify v $ \mv -> ...`
21:01:16 <jle`> but yeah that has the same problems as using (.)
21:01:27 <jle`> (with runST)
21:35:50 * hackagebot extensible 0.4.4 – Extensible, efficient, optics-friendly data types and effects – https://hackage.haskell.org/package/extensible
21:38:09 <koz_> jle`: I'm reading your post here: https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html, and I was wondering - with the vector-based representation, how would you write the length function for Vec?
21:38:17 <koz_> (other than by defaulting to the one from the underlying vector)
21:43:17 <jle`> oh boy so much of that post i need to rewrite heh
21:43:48 <jle`> the way i wrote it there you can use 'natVal :: KnownNat n => p n -> Integer'
21:44:16 <koz_> So how woudl I write length :: Vec n a -> Int on that basis?
21:44:44 <jle`> you'd need length :: KnownNat n => Vec n a -> Int
21:45:45 <jle`> but really, that ignores the 'Vec n a', anyway
21:45:59 <jle`> it'd be natVal (Proxy @n), if you have scopedtypevariables on
21:47:01 <koz_> Huh, I'm gettng parse errors from that.
21:47:39 <jle`> you might need TypeApplications
21:48:13 <koz_> Now it complains about the type variable not being in scope.
21:48:37 <jle`> ah yeah, if you're writing this at home, length :: forall n. KnownNat n => Vec n a -> Int
21:48:47 <koz_> So I need RankNTypes also?
21:48:49 <jle`> length _ = fromIntegral $ natVal (Proxy @n)
21:49:27 <koz_> Apparently not.
21:49:40 <koz_> I'm not used to seeing explicit foralls except in when RankNTypes is on.
21:50:40 <jle`> explicit foralls is often used for scoped type variables
21:50:57 <jle`> you can think of it like a "lambda" for type variables
21:51:18 <jle`> it binds 'n' so that the function body can refer to it
21:51:25 <koz_> Ah, I see.
21:51:32 <koz_> Thanks - I actually think I get this.
21:51:33 <benzrf> jle`: no, that's scoped type variables
21:51:41 <benzrf> it binds n so that the _return type_ can refer to it
21:51:46 <benzrf> oh wait
21:51:50 <benzrf> im a moron, i didnt read lmao
21:51:53 <benzrf> sorry
21:52:05 <jle`> no worries haha
21:55:09 * hackagebot state-codes 0.1.0 – ISO 3166-2:US state codes and i18n names – https://hackage.haskell.org/package/state-codes
21:55:44 <dmj`> jle`: o/
21:56:15 <koz_> jle`: The index function for the vector rep - I tried writing it exactly as-is, but apparently, there is no type-level >
22:07:11 <jchia> lens-aeson question: How do I filter out keys what start with "a" ("a" `isPrefixOf`)? I want a function "f :: Text -> Text" that will change '{"top": {"a1": 1, "a2": 2, "b1": 3}}' into '{"top": {"b1": 3}}' and 'f = key "top" . _' What's the expression I should use to fill in the '_'? Right now, I'm using 'f = key "top" . _Object %~ HM.filterWithKey (\k _ -> not ("a" `isPrefixOf` k)' but I find it ugly to mix lens with non-lens parts.
22:11:56 <jle`> koz_: as-is?
22:13:22 <koz_> jle`: Never mind, figured it out.
22:13:44 <koz_> I had to do 'index :: forall n m . (KnownNat n, KnownNat m) => Vector (n + m) a -> Proxy n -> a
22:13:46 <koz_> '
22:13:56 <koz_> And turn on more extensions, as usual.
22:14:27 <jle`> `Proxy n` could be just 'p n'
22:14:30 <dsal> Is there anything wrong with infinite recursion on an IO func?
22:14:38 <jle`> and another way to write 'index' is also to use Finite, instead
22:14:59 <jle`> dsal: the general concept, no
22:15:07 <lyxia> jchia: key "top" . _Object . itraversed . ifiltered (\k _ -> not ("a" `isPrefixOf` k))
22:16:00 <dsal> jle`: Thanks.  I don't fully understand the execution model.  It's intuitive that this is a fine way to do an infinite loop
22:17:37 <jle`> koz_: the problem with taking Proxy as an argument is that indexing as an operation rarely happens in situations where you know the value of the index at compiletime
22:17:49 <jle`> except for things like head and last
22:18:06 <jle`> 'problem' in an API/usability sense, not in a fundamental sense
22:18:44 <jle`> er, sorry, 'Proxy' is not the issue, i meant taking the index as a type-level argument (n) there
22:18:52 <koz_> jle`: Fair enough.
22:19:39 <jle`> koz_: see http://hackage.haskell.org/package/finite-typelits
22:19:59 <jle`> safeIndex :: Vector n a -> Finite n -> a
22:22:19 <jchia> lyxia: Somehow that's not typechecking as Text -> Text.
22:23:08 <koz_> jchia: Oh, cool!
22:23:31 <koz_> Sorry, jle`, not jchia.
22:24:16 <lyxia> jchia: ah I forgot to turn the traversal into a function
22:25:53 <lyxia> I can't find a HashMap counterpart of toMapOf
22:27:23 <koz_> jle`: Could I use Finite to write something like replicate :: forall n . (KnownNat n) => Proxy n -> a -> Vector n a?
22:27:36 <koz_> Would it be something like replicate :: Finite n -> a -> Vector n a?
22:28:05 <lyxia> jchia: looks like it has yet to be added given how recent this is https://github.com/ekmett/lens/pull/676
22:28:25 <jle`> koz_: you don't need finite
22:28:42 <jle`> koz_: `replicate :: forall n. KnownNat n => a -> Vector n a` is enough :)
22:28:53 <lyxia> jchia: so you'll have to do with what you have, which doesn't look that bad in the end.
22:29:02 <koz_> jle`: ... penny just dropped.
22:29:24 <jle`> by the way, does the type signature for 'replicate' look familiar ...?
22:29:26 <jchia> lyxia: Thanks for the help.
22:29:28 <jle`> like a common haskellism?
22:30:10 <jle`> i'm fishing for a specific answer to a super open ended question, of course
22:30:16 <jle`> so don't worry if you don't see it
22:30:28 <koz_> jle`: My mind is like this right now: https://www.youtube.com/watch?v=WFNEgdwjEhs
22:30:38 <jle`> ha
22:30:52 <jle`> the answer i was fishing for was 'pure'
22:31:05 <jle`> replicate is 'pure' for the `KnownNat n => Vector n` applicative
22:31:13 <jle`> :t pure
22:31:15 <lambdabot> Applicative f => a -> f a
22:31:29 <koz_> jle`: https://www.youtube.com/watch?v=WFNEgdwjEhs
22:31:31 <jchia> lyxia: That commit only mentions Map but not HashMap. Is that why you think HashMap is not yet covered?
22:31:31 <koz_> again.
22:31:42 <jle`> ikr
22:31:53 <koz_> This is amazing.
22:32:39 <jle`> in fact i think it's the only such function with that type signature
22:33:29 <jle`> s/such//
22:34:04 <jle`> (the obvious follow up question is "so what is <*>")
22:34:30 <koz_> jle`: Wouldn't there be two possible answers?
22:34:32 <jle`> (and the much more conceptually tricky question is "is there a Monad instance")
22:35:52 <jle`> hm, i never thought of that
22:36:02 <jle`> there was always one obvious <*> to me
22:36:17 <koz_> It's the same as list and vector as an Applicative - there can be two.
22:36:25 <jle`> oh, if you mean 'pure'
22:36:30 <jle`> there is only one possible 'pure'
22:36:34 <koz_> I mean <*>.
22:36:48 <jle`> which ones are you thinking of?
22:37:10 <jle`> also remember that pure for ZipList and [] are different
22:37:16 <koz_> Really?
22:37:18 <jle`> mhm
22:37:20 <koz_> I though they were the same?
22:37:33 <koz_> s/?/./
22:37:59 <jle`> koz_: think of what pure has to be for `pure f <*> xs` to be `fmap f xs`
22:38:03 <jle`> for ZipList
22:38:17 <jle`> > zipWith ($) [succ] [1,2,3]
22:38:20 <lambdabot>  [2]
22:38:29 <jle`> pure x = [x] doesn't work for ZipList
22:38:45 <koz_> You'd need infinitely-many?
22:38:50 <jle`> because then `pure f <*> xs` would only keep one item
22:38:51 <koz_> Since you have no idea what lists you're getting fed?
22:38:54 <jle`> yeah, pure = repeat
22:38:58 <jle`> for ZipList
22:39:02 <koz_> jle`: https://www.youtube.com/watch?v=WFNEgdwjEhs
22:39:03 <jle`> > zipWith ($) (repeat succ) [1,2,3]
22:39:06 <lambdabot>  [2,3,4]
22:39:20 <koz_> OK, then in that case, there'll only be one.
22:39:24 <jle`> but to your original question, i'm not sure if 'pure' uniquly determines <*>
22:39:29 <jle`> in the general case
22:39:37 <jle`> I know that <*> uniquely determines 'pure', though
22:39:46 <jle`> the choice of <*> determines what 'pure' has to be, as we just saw
22:39:55 <koz_> Yeah, that does make sense.
22:40:00 <jle`> but i'm pretty sure that the choice of 'pure' does not uniquely determine <*>
22:40:04 <jle`> so your question was a valid one
22:40:52 <jle`> i have a counter-example in mind where two Applicative instances for the same type have the same 'pure' but different '<*>'s
22:41:08 <jle`> but it's too big to fit in a single irc message
22:41:12 <koz_> jle`: LOL.
22:41:50 <jle`> but it might be a fun exercise for anyone reading for a lazy weekend afternoon
22:42:10 <koz_> Which I'm not currently having, as you can probably tell.
22:42:19 <jle`> time zones are crazy :)
22:43:01 <koz_> jle`: It is an afternoon right now, but not a lazy or weekend one.
22:44:32 <koz_> Also, is there a better/neater/more natural way to write this function? http://lpaste.net/357904
22:44:44 <koz_> I wrote it using manual recursion, but I suspect that means I'm doing it wrong.
22:46:04 <nshepperd> Vector n a is equivalent to (Finite n -> a)
22:46:38 <nshepperd> so you can use the Reader instances ;)
22:46:52 <jle`> koz_: you can use traverse (some helper function) [0 .. MV.length mv - 1]
22:46:57 <jle`> nshepperd: ah yes, that's pretty convincing
22:47:14 <koz_> jle`: Oh yeah, that makes sense. Thanks!
22:47:28 <jle`> it's kind of weird that there is no 'traverse' function for mutable vectors
22:47:33 <koz_> There's even a Protolude 'apply N times' helper.
22:48:21 <jle`> yeah it's sort of the equivalent of ruby's 5.times do |n| ... idiom
22:49:11 <jle`> ...that felt so weird to write after four years of not using ruby
22:50:04 <jle`> i guess we could write 'times' in haskell
22:50:12 <jle`> and we can do 5 `times` \n -> do ...
22:50:23 <trigone> hi! i wondered what the typical usage case for span/break was? and if y'all use those prelude functions often, or not, or not at all....
22:50:26 <nshepperd> for_ [1..5] $ \i -> do ...
22:50:35 <nshepperd> the best imperative language
22:50:39 <jle`> :)
22:50:48 <jle`> trigone: i just used it earlier today actually
22:51:18 <jle`> i needed to split a list into its leading whitespace and all of its actual concent
22:51:23 <cocreature> trigone: I rarely use them directly but something like "splitAt :: (a -> Bool) -> [a] -> [[a]]" can easily be implemented on top of them and that’s quite useful
22:51:26 <jle`> > span isSpace "         hi"
22:51:29 <lambdabot>  ("         ","hi")
22:51:55 <trigone> :t break
22:51:56 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:51:58 <trigone> :t splitAt
22:51:59 <lambdabot> Int -> [a] -> ([a], [a])
22:52:17 <trigone> hm i see
22:52:20 <jle`> it's a pretty natural function for lists actually
22:52:26 <jle`> it's basically takeWhile with dropWhile
22:52:33 <trigone> i have trouble with "span" though, what is the name supposed to refer to?
22:52:39 <jle`> if you think of lists as a stream
22:53:04 <trigone> (break is vaguely clearer)
22:53:19 <trigone> > break (> 5) [1..10]
22:53:21 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
22:54:01 <cocreature> span gives you the longest span of elements satisfying the predicate or something like that
22:54:06 <jle`> the span of consecutive elements where p is true, and the span of elements afterwards?
22:54:18 <jle`> admittedly span sounds like a better name for takeWhile
22:54:29 <jle`> but takeWhile is arguably the best name for takeWhile
22:54:52 <cocreature> naming things is hard :)
22:55:29 <trigone> isn't it weird to use "span" like that? i'm not natively english-speaking though, just, span feels awkward unless it's about time... is it just me? 
22:55:44 <nshepperd> yeah, it's a weird name
22:55:53 <jle`> it's not uncommon to use span to refer to a spatial expanse
22:55:54 <trigone> cocreature: i agree, very hard
22:56:00 <speak> trigone: It's just you yeah
22:56:20 <trigone> jle`: could you give me an example? might help remembering the meaning of the function
22:56:27 <jle`> the span of a kingdom
22:56:34 <nshepperd> wingspan!
22:56:34 <trigone> jle`: really?
22:56:48 <jle`> it's also a synonym for 'length'
22:56:59 <jle`> and a bridge spans a river's width
22:57:03 <speak> Yup
22:57:09 <trigone> well that's weird. unless it means the span of time during which the kingdom existed? cuz kindgoms don't really have "lengths" to speak of, do they?
22:57:23 <trigone> hm ok
22:57:31 <jle`> maybe i'm conflating span with expanse in that specific example
22:57:35 <jle`> hehe
22:57:36 <speak> It's not just time, it's also spatial
22:57:41 <jle`> but i don't think it'd be weird to use it there
22:57:47 <nshepperd> the average wingspan of a golden eagle is 1.98 meters
22:57:51 <speak> No it's not weird at all
22:57:54 <nshepperd> that's taller than a person
22:58:12 <trigone> nshepperd: yeah i guess in that usage it feels smooth
22:58:32 <speak> But yes jle`'s examples were good
22:59:18 <jle`> but for some reason in many natural language, concepts of distance and time are often interchangeable
22:59:29 <speak> But of course, best to just read: http://www.thefreedictionary.com/span
22:59:32 <speak> If you're curious enough
22:59:42 <trigone> it feels like span means specifically, "length between specific boundaries", so here i guess it means the start of the list and whenever the predicate isn't true anymore... but i agree it'd fit better for the meaning of takeWhile
22:59:45 <jle`> i'm not sure if this is a fundamental property of natural language, or just a feature of the languages that exist
22:59:53 <speak> jle`: It's because they're both dimensions are a couple of dimensions, DUN DUN DUNNNNNN
22:59:57 <lyxia> jchia: The PR mentions adding HashMap in the future.
23:00:08 <jle`> but this is probably not an on-topic discussion so i'll leave it at that, heh
23:00:36 <trigone> well naming is part of programming, we can't do everything with x and \, can we? :P thanks everyone
23:00:37 <speak> jle`: It's because they're both dimensions, or a couple of dimensions, DUN DUN DUNNNNNN
23:00:41 <speak> There had to fix it
23:00:45 <jle`> :)
23:01:17 <nshepperd> at its height, the roman empire spanned 4 million km^2, or 1% of the earth's surface
23:02:03 <jle`> my new sheets don't spand the entire length of my bed, i should probably see if i can return them
23:02:09 <jle`> er, s/spand/span
23:03:06 <trigone> jle`: would you actually say that IRL? (as opposed to some equivalent expression)
23:03:17 <nshepperd> span facts
23:03:57 <jle`> i might say it if i felt like sounding pretentious
23:03:58 <nshepperd> still not a good name for takeWhile + dropWhile though, because 'span' by itself doesn't really indicate which span you're talking about
23:04:04 <trigone> jle`: lol
23:04:51 <jle`> isn't span in the report
23:04:56 <nshepperd> in CS we talk of spanning tress, which span ABSTRACT GRAPHS instead of space or time
23:05:11 <nshepperd> er, trees
23:05:12 <jle`> those report people might have had other naming things to worry about
23:05:21 <jle`> but, the term might predate haskell
23:05:26 <trigone> nshepperd: oh...
23:05:31 <trigone> jle`: tss nothing predates haskell
23:05:49 <trigone> its span is infinite
23:06:21 <jle`> yes span and its function are specified in the haskell report https://www.haskell.org/onlinereport/standard-prelude.html
23:06:42 <jle`> s/function/functionality
23:07:05 <trigone> span looks like a parser-like tool, parser libraries must re-implement its functionality, wouldn't they?
23:07:11 <jle`> i like to imagine that it was made up on the spot at the end of a late night of naming things
23:07:22 <jle`> "none of you are leaving this room until we name everything in haskell"
23:07:56 <nshepperd> jle`: well, if the biggest thing wrong with your new programming language is that one stdlib function is misnamed, you'd better convert to $religion because it's a miracle
23:08:54 <jle`> also i didn't realize that so many non-base libraries are specified in the Report
23:09:38 <jle`> but also maybe they say 'library' when they really meant what we call modules today
23:09:40 <mikeplus32> anybody from fpcomplete around? http://download.fpcomplete.com/ubuntu is down → the keter install script fails
23:09:59 <jle`> because Maybe is a library apparently
23:10:09 * jle` imagines importing an external library to use Maybe
23:10:36 <trigone> jle`: external to base?
23:10:43 <geekosaur> someone did that earlier today, come to think of it
23:10:52 <jle`> https://www.haskell.org/onlinereport/
23:10:59 <jchia> lens question: Is there a general way (operator?) to combine two Setter's into one Setter' ?
23:11:00 <jle`> maybe i'm just misreading the report
23:11:06 <geekosaur> (refer to a module as a "library" or "package", I don't recall which offhand)
23:11:34 <jle`> oh, maybe i'm thinking of 'packages'
23:11:52 <geekosaur> I think the Report was avoiding reference to specific organizational details
23:12:03 <jle`> i suppose the term library isn't really used in a specific technical sense these days
23:12:04 <geekosaur> also, back in the day at least some of those *were* external
23:12:37 <jle`> does library have a specific technical definition in the Report?
23:12:42 <geekosaur> I had cause to go digging around in ghc4 docs a few months ago and a number of things we consider "standard" were separate installs
23:12:45 <trigone> i think "library" here is an abstract way to differentiate the bare language from the tools which are implemented with it, even if said tool are so ubiquitous they feel like language feature (and i bet in a lesser language they'd have become language features)
23:13:03 <trigone> (but to be fair i didn't read the report at all)
23:13:22 <jle`> yeah the way they use it seems to mean just grouped chunks of functionality
23:14:03 <jle`> oh okay i found something that might be passable as a technical definition
23:14:06 <geekosaur> I don't see a definition of "library", but its usage seems to be ,,, tha
23:14:07 <geekosaur> t'
23:14:21 <jle`> "modules [..] which provide less frequently used functions and types"
23:14:26 <trigone> or perhaps it means, things which are decomposable into smaller bits, instead of atomic constructs only implemented via compiling
23:16:44 <geekosaur> basically talking about a level of organization above single modules, but without reference to packaging
23:16:45 <speak> trigone: Just to drive the point home, yes I actually use "span" in that way when I speak English, and yes it is actually used, and yes it is natural even though you haven't bumped into it much :D
23:16:45 <geekosaur> conceptual units vs. compilation units (modules) or implementation organizational units (packages etc.)
23:16:45 <jle`> the first section of the report only talks about libraries in the sense of "library modules"
23:16:45 <trigone> speak: ok thx :)
23:16:45 <jle`> "Many of the features of Haskell are defined in Haskell itself as a library of standard datatypes, classes, and functions, called the "Standard Prelude." In Haskell , the Prelude is contained in the module Prelude. There are also many predefined library modules, which provide less frequently used functions and types."
23:16:45 <trigone> do you'all use alternatives to prelude, or you don't? if you do use an alternative, what's the preferred method to avoid implicit prelude import and to import your own preferred alternative prelude?
23:16:46 <jle`> this reminds me of exegetical days
23:17:08 <jle`> i suppose i trade exegesis of one text for another
23:17:17 <geekosaur> trigone, as usual in the Haskell community, there's no single common answer there
23:17:32 <trigone> geekosaur: did i ask for one single common answer? ^^
23:17:50 <geekosaur> "you'all" suggests some kind of rough consensus, yes
23:18:02 <trigone> ok i should reformulate "what's your personal preferred method, for each one who will answer"
23:18:12 <halogenandtoast> trigone: you can use NoImplicitPrelude and then import an alternative, I often use Yesod which comes with ClassyPrelude
23:18:24 <halogenandtoast> If I'm writing my own code I usually juse use Prelude.
23:18:24 <tdammers> geekosaur: "y'all" is plural for "you", just like "youse"
23:18:58 <koz_> trigone: Protolude and NoImplicitPrelude in my case.
23:19:00 <geekosaur> it still presupposes that the plurality can be considered a group
23:19:39 <tdammers> best method to use a custom prelude is {-# LANGUAGE NoImplicitPrelude #-} and then explicitly import WhateverPrelude, in every source file
23:19:46 <trigone> so you always have to manually import whatever alternative in each file? not that it's that big of a hassle, i'm just checking. and do you use language pragma at the top of the file, or an option at compile time, or an option in whatever config file?
23:20:00 <jle`> i think language pragmas should preferably be at the top of a file
23:20:02 <koz_> trigone: You can set it to auto-do NoImplicitPrelude in the cabal file.
23:20:08 <cocreature> I enable NoImplicitPrelude in my cabal file
23:20:09 <tdammers> you can set NoImplicitPrelude externally (through cabal or stack config, or with manual GHC options), but that's a bit messy
23:20:23 <cocreature> but you’re stuck with an import at the top of every file
23:20:29 <tdammers> lesser evil IMO
23:20:32 <trigone> geekosaur: well more or less. if i say do y'all want some ice cream, do you interpret it as meaning "if one of you doesn't want any, none of you will get any, na-na-na!"
23:20:47 <tdammers> if Haskell had a better module system, this could probably be made more elegant
23:20:57 <geekosaur> ^
23:21:23 <jle`> trigone: i wouldn't normally read you'all as y'all, i'd read it as a typo of you all
23:21:25 <trigone> tdammers: ok i think i'll do that (pragma + import in each file).
23:21:27 <geekosaur> was just thinking that, as the module currently exists, multiple imports vs. one import to rule them all means tradeoffs in both directions
23:21:31 <halogenandtoast> I'm trying to decide if it's worth learning Scala, every time I try, I just want Haskell.
23:21:55 <jle`> it's worth learning scala if you are working somewhere that uses scala
23:22:04 <jle`> i don't think it's worth learning on its own
23:22:21 <trigone> jle`: actually it was a typo on y'all. i agree "you all" would look more like asking for consensus
23:22:45 <tdammers> between Haskell and {Java,C#}, I don't think there is an awful lot of novel features that you could learn from Scala
23:23:00 <jle`> 'how to take functional programming, and ruin it'
23:23:14 <jle`> which might not be obvious, from only knowing haskell
23:23:35 <trigone> what might not be obvious?
23:23:41 <jle`> how to ruin functional programming
23:23:41 <tdammers> jle`: that's easy though, just don't provide language features to control effects
23:23:43 <halogenandtoast> that it ruins functional programming
23:23:49 <trigone> geekosaur: what do you mean by one import to rule them all?
23:24:16 <trigone> jle`: oh you mean to obvious to do
23:24:18 <jle`> sorry, the joke was a response to the statement that there isn't anything you can learn from scala that you can't learn from haskell/java/c#
23:24:29 <tdammers> trigone: a custom prelude importing everything you need throughout the project and then re-exporting it (one import to rule them all) vs. importing everything you need directly where and when you need it
23:24:33 <trigone> ok got it ^^
23:25:10 <tdammers> jle`: well, seriously, what you *can* learn from it is how they tried to "combine" functional and shared-mutable-state-based imperative OO
23:25:14 <jle`> if you want to learn a good language to see how interop with an existing ecosystem can be done well, try purescript
23:25:29 <speak> Has purescript been nice?
23:25:38 <tdammers> purescript is very nice
23:25:49 <speak> As someone who has to deal with JS every day, it's looked like a nice sanity saver possibly
23:25:53 <trigone> tdammers: hm yeah. i guess it'd be logical to be able to choose your preferred implicit prelude for whole packages
23:26:14 <jle`> i think it's a good example for writing a haskelly language in a way to take advantage of the massive existing js ecosystem
23:26:18 <trigone> tdammers: isn't it the case with Ocaml too?
23:26:24 <jle`> which might have been what scala was originally trying to do
23:26:25 <tdammers> trigone: you can, by adding GHC options in your cabal file
23:26:27 <trigone> tdammers: that's a naive question btw
23:26:29 <jle`> (with java)
23:26:39 <trigone> tdammers: really? there's an option for implicit import?
23:26:52 <halogenandtoast> Everytime I try to use a JS alternative, I always get stuck trying to figure out drag and drop.
23:27:20 <halogenandtoast> I need a jQuery alternative out of the box.
23:27:26 <halogenandtoast> s/need/want/
23:27:30 <koz_> A little late to the party, but re:Scala - http://classicprogrammerpaintings.com/post/142321815809/hieronymus-bosch-a-visual-guide-to-the-scala
23:27:34 <speak> Hehe halogenandtoast 
23:27:51 <speak> Nothing stops you from using a jquery-blob to get the drag&drop if you so wish
23:27:55 <jle`> purescript has also sort of morphed into a playground for people who want a "haskell redesigned with the perspective of 20 years of using haskell"
23:28:18 <speak> And use purescript for everything else
23:28:21 <speak> Oh interesting jle` 
23:28:36 <sssilver> I'm reading this Haskell book and I feel like the author is trolling me or something
23:28:39 <speak> So some sort of "haskell without the historical baggage... in JS!"
23:28:39 <tdammers> trigone: there's an option to turn off the implicit import Prelude
23:28:45 <halogenandtoast> sssilver: which Haskell book.
23:28:46 <jle`> in a way it's like if people wanted to fix the haskell language without worrying about backwards compatibility
23:28:52 <jle`> the JS part is incidental, to people who use it like that
23:29:00 <speak> Hah yeah
23:29:02 <sssilver> I'm at like chapter 5 and I can do a ton of stuff except I still have no clue how to print "hello world"
23:29:16 <halogenandtoast> print "hello world" will do it
23:29:19 <speak> sssilver: Welcome to so much of the haskell learning ecosystem
23:29:31 <trigone> jle`: yeah some things look better in purescript, though constantly exposing forall is a bit verbose, even if more precise
23:29:35 <tdammers> actually I think some of the decisions purescript made are overly opinionated
23:29:38 <sssilver> halogenandtoast that is so hilarious
23:29:43 <halogenandtoast> I'm not kidding
23:30:01 <jle`> sssilver: well, this is one thing commonly said about haskell -- it's best to forget everything you've learned from other languages when learning haskell
23:30:03 <tdammers> e.g. how you can't write (Foo a, Bar a) => a -> Something anymore, you have to write Foo a => Bar a => a -> Something
23:30:08 <jle`> sssilver: it'll only set you up for confusion
23:30:19 <speak> I really loathe the way haskell is usually taught. "Here's how to solve a million of math problems in Haskell"    "I never do math in programming and I program every day, wtf is this going to do for meeeee?"
23:30:20 <trigone> > print "mellow world"
23:30:22 <lambdabot>  <IO ()>
23:30:36 <tdammers> speak: that is not how Haskell is usually taught AFAIK
23:30:38 <trigone> oh right it doesn't execute
23:30:38 <jle`> sssilver: the idea of "printing hello world" is something imprinted to you from your previous programming experience, presumably
23:30:47 <halogenandtoast> sssilver: http://imgur.com/a/TEgCc
23:30:51 <halogenandtoast> see now you can stop worrying
23:30:59 <jle`> sssilver: and it's clear that it's causing some disorientation while learning haskell
23:31:13 <speak> tdammers: That is my experience. Or alternatively: Hey, here's a million ways to manipulate lists!   "This doesn't seem like something I normally do..."
23:31:13 <sssilver> I mean the problem is I was like "hey I wanna learn Haskell, so let me make this simple guestbook web app as I learn it", and at this point I'm like "hell I feel like I know a lot about Haskell, yet zero clue how I would build a web guestbook app with it"
23:31:35 <halogenandtoast> "simple guestbook web app" yup good liuck
23:31:37 <halogenandtoast> *luck
23:31:43 <cocreature> speak: yeah, I think a bit of up-front learning is useful in Haskell but a lot of learning materials stay with that for way too long before they explain how you can read a file or something like that
23:31:45 <sssilver> perhaps Haskell just isn't meant to build simple web apps?
23:31:55 <speak> cocreature: Yeah indeed
23:32:02 <tdammers> speak: well, with any language you need to learn the basics before you can build anything real-world
23:32:02 <jle`> sssilver: it is good for simple web apps, but just probably not alongside most haskell introductions
23:32:06 <halogenandtoast> sssilver: It can very easily build simple web apps, but it requires a lot of up front knowledge
23:32:13 <Cale> sssilver: I don't know, reflex-dom is pretty great on the frontend
23:32:18 <halogenandtoast> sssilver: Here's a web app I built: https://github.com/halogenandtoast/nhk-reader-haskell
23:32:19 <jle`> i'd use haskell for all my simple web apps these days
23:32:19 <sssilver> I don't need to build anything sophisticated, just a toy project where user can post a message and view a list of posted messages, via HTTP formatted in HTMS
23:32:20 <tdammers> speak: in Haskell, an early hurdle is IO, which you need in order to build anything useful
23:32:21 <sssilver> HTML
23:32:23 <cocreature> I had a lecture at my university that contained a bit of Haskell. it never got over the “write your beautiful programs and run them in ghci” point
23:32:26 <halogenandtoast> and another: https://github.com/halogenandtoast/mirin
23:32:27 <tdammers> speak: there are two school of thought here
23:32:28 <Cale> and there are a lot of pretty decent backend libraries
23:32:37 <cocreature> so now most people think Haskell is completely useless
23:32:53 <cocreature> *most people who attended that lecture
23:33:10 <jle`> sssilver: in any language, too, the type of apps you can write after "X months" in that language is different
23:33:10 <speak> tdammers: Yes, but the problem is that the tutorials often omit context, hence confusing people just looking to get started
23:33:12 <halogenandtoast> sssilver: I'd suggest starting with something like Spock
23:33:14 <tdammers> speak: one, handwave how IO actually works, only give the student a few cookbook recipes and promise to get back to explaining them later, and then proceed to teach the actual entry-level stuff
23:33:38 <tdammers> speak: two, start with the entry-level stuff and do not build anything useful for the first few months
23:33:38 <trigone> can lambdabot execute some IO?
23:33:40 <jle`> sssilver: "type of apps you can write after X months" is a small set that spreads slowly, from different places, and this is different for every language
23:33:48 <halogenandtoast> but even still storing a message requires talking to an external entity (filesystem, database, api)
23:33:48 <speak> Yeah tdammers I'm of the first camp for sure
23:33:48 <trigone> (like launchMissiles :P)
23:33:50 <jle`> sssilver: and, also, for different ways of teaching language
23:34:13 <speak> tdammers: A few months is an awfully long time to wait to see something useful, if you're not sure you're making a good time investment, yet
23:34:21 <tdammers> speak: the problem is, one way or another you need to actually learn about IO's true nature before you can build practical stuff without getting utterly confused
23:34:22 <jle`> sssilver: it wouldn't be too hard to write a haskell introduction that is geared around writing web apps
23:34:25 <speak> Hence shortcuts are essential in the beginning, there's time to learn better later
23:34:25 <sssilver> I would say I know a fair number of programming languages reasonably well, and I've never had this situation really :)) not complaining, just quite confused
23:34:35 <jle`> sssilver: you've hit upon a major point
23:34:44 <halogenandtoast> jle`: I don't know about that, I still feel like the database stuff gets complicated fast.
23:34:55 <jle`> sssilver: knowing a fair number of programming languages, you actually don't realize that most of the languages you know are actually very similar
23:34:58 <tdammers> speak: the danger of that is that you may develop wrong mental models that take a lot of head-banging to unlearn later
23:35:03 <jle`> sssilver: haskell might be the first language you know that's actually *different*
23:35:08 <ski> @help run
23:35:09 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
23:35:11 <ski> trigone ^
23:35:17 <sssilver> like yeah learning C++ is challenging, learning Lisp can be weird, learning Rust has major hardships around lifetimes and such, but Haskell is like OK I know a lot of stuff, and I get it, but how do I build a guestbook app :D
23:35:24 <tdammers> speak: I think this is where the Monad Fallacy originates
23:35:51 <sssilver> I'm reading Learn You A Haskell For Great Good btw
23:35:52 <jle`> sssilver: learning C++, Rust, and Lisp are all sort of really the same thing.  but learning haskell you kind of have to temper your expectations as if you were starting from square 1, and all of your other language expectations or knowledge holds you back rather than helps you
23:35:54 <speak> tdammers: Yeah it is a balance for sure. The only issue I have is that so many tutorials just omit the context completely, and just are so excited to tell you about list manipulation in Haskell, without a single real world example
23:35:54 <trigone> ski thanks! btw, what is lambdabot prattling about? i didn't get the joke
23:36:00 <sssilver> perhaps the wrong book for me?
23:36:01 <halogenandtoast> sssilver: are you building it with or without a framework? That's probably the first step.
23:36:10 <jle`> sssilver: oh yes LYAH is a bit...notorious for being impractical
23:36:11 <tdammers> speak: well, lists are very prominent in Haskell
23:36:14 <speak> Like seriously tdammers, not even a single example of what the list manipulation could be used for
23:36:16 <ski> trigone : when ?
23:36:24 <tdammers> speak: depends on the book, I guess
23:36:24 <jle`> sssilver: you won't find much love for it these days
23:36:26 <halogenandtoast> Oh yeah LYAH is my least favorite Haskell book.
23:36:32 <speak> tdammers: See, _I_ know that, but that sure as heck didn't help me when I was starting
23:36:45 <speak> tdammers: And I'm talking more about various online resources
23:36:58 <Rotaerk> but it has pictures!
23:37:15 <speak> And also it doesn't help that in Haskell you've usually got single character variable names, which makes everything even more abstract
23:37:16 <tdammers> speak: have you looked at Real World Haskell? It's ridiculously outdated, but I enjoyed the approach a lot
23:37:19 <kvda> halogenandtoast what's a good one these days?
23:37:22 <trigone> ski when you did `@help run`, it said "you have haskell, 3 seconds and no io. go nuts!"
23:37:26 <trigone> @help run
23:37:26 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
23:37:26 <sssilver> alright guys sounds like you're the gods of Haskell -- what should I read? I know Python, Swift, Rust, C++, PHP, Lisp/Clojure, some Pascal, and some Javascript.
23:37:35 <sssilver> "know" as in, someone at some point paid me to write code in those languages
23:37:36 <sssilver> except Rust
23:37:39 <sssilver> nobody paid me for Rust
23:37:40 <jle`> sssilver: its reputation is that it is cute/shows you nice tricks but does not do very well with preparing you for the real haskell world
23:37:41 <halogenandtoast> kvda: I'm in love with this one: http://www.cs.nott.ac.uk/~pszgmh/pih.html
23:37:44 <Rotaerk> speak, short variable names are fine if something ELSE makes it clear what it means
23:37:45 <halogenandtoast> the examples are awesome
23:37:49 <ski> trigone : `> print "mellow world"' is short for `@run print "mellow world"'
23:38:01 <trigone> ski didn't work for me
23:38:05 <jle`> sssilver: one that has been getting some momentum these days is 'haskell from first principles'
23:38:05 <tdammers> single-character variable names don't make things any more abstract than they already are, usually - they are sometimes overused, but most of the time, there really isn't much more to them than "this is a variable, there are many like it, but this one is mine"
23:38:09 <speak> tdammers: I did check it out yeah, and it seemed pretty good!
23:38:10 <jle`> sssilver: although it is non-free
23:38:15 <sssilver> I don't mind paying
23:38:16 <trigone> > print "ha"
23:38:18 <lambdabot>  <IO ()>
23:38:23 <halogenandtoast> I think Haskell from First Principles is okay
23:38:24 <tdammers> speak: there's also Build Yourself A Scheme
23:38:27 <halogenandtoast> I meanders a bit
23:38:30 <halogenandtoast> s/I/it/
23:38:30 <sssilver> I bought the physical Learn you a haskell book actually coz I thought it was pretty entertaining
23:38:32 <speak> tdammers and Rotaerk yes, you're both right in the context of "someone who already knows haskell"
23:38:36 <kvda> thanks halogenandtoast i was unaware of this one
23:38:41 <trigone> ski: see? it doesn't execute it, it just evaluates it (as much as it can)
23:38:44 <jle`> sssilver: LYAH is definitely *entertaining*, heh
23:38:51 <jle`> i think that's really its main goal
23:38:56 <jle`> and accomplishment
23:39:04 <tdammers> speak: even if you don't know Haskell, there often simply isn't a meaningful name you could give your variables
23:39:04 <trigone> @run print "a"
23:39:05 <halogenandtoast> kvda: It does a good job of pointing out lazy evaluation and making really cool examples around it
23:39:07 <lambdabot>  <IO ()>
23:39:15 <tdammers> speak: take, for example: id :: a -> a
23:39:15 <halogenandtoast> It's the first book I've read where I didn't get mad at the contrived examples
23:39:19 <trigone> ski: oh well nevermind, they do actually do the same thing
23:39:23 <Rotaerk> let p = getPerson blah
23:39:25 <mauke> trigone: that's why it said "no IO"
23:39:28 <halogenandtoast> LYAH and HFFP both have really dumb examples
23:39:30 <jle`> @where haskellbook
23:39:31 <lambdabot> http://haskellbook.com
23:39:34 <tdammers> speak: what meaningful name would you want to give 'a' here, without making it seem less generic than it is?
23:39:43 <Rotaerk> no point in calling p "person" when it's clear what it stands for based on what's being assigned to it
23:39:44 <tdammers> speak: it literally means "a type"
23:39:49 <kvda> halogenandtoast i'm doing a bulk book purchase soon, will add to list, thanks
23:39:49 <speak> tdammers: That is a function type definition, not a variable name in the sense I meant
23:39:50 <trigone> mauke: so what do you do with @run? unless it's just identical to `>`?
23:39:51 <ski> trigone : yes, evaluation doesn't cause execution
23:39:56 <tdammers> speak: it's a type variable
23:40:01 <halogenandtoast> kvda: Ha no problem!
23:40:04 <speak> Yes, which is not what I meant, sorry
23:40:10 <tdammers> speak: you can use id's term-level definition instead if you want: id a = a
23:40:10 <jle`> sssilver: but also there are some great online lectures/notes too
23:40:13 <jle`> @where learnhaskell
23:40:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:40:14 <BernhardPosselt> hi, how does traverse use the applicative? something like: collect <$> a1 <*> a2 <*> …
23:40:15 <ski> trigone : .. and lambdabot doesn't do I/O execution
23:40:18 <tdammers> (or id x = x)
23:40:44 <mauke> trigone: "> " is an alias for the run command
23:40:57 <trigone> mauke: ok thx
23:41:24 <speak> tdammers: You're missing my point, _I know_ why single character variable names are used, especially in contexts like that
23:41:28 <ski> (.. as i already said :)
23:41:29 <trigone> ski: ok, well that was my original question. i guess it's logical
23:41:42 <tdammers> speak: so, seriously, what other name is there that would make it easier to learn?
23:41:46 <jle`> BernhardPosselt: `traverse f [x,y,z]` is like (\x' y' z' -> [x',y',z']) <$> x <*> y <*> z
23:41:52 <trigone> (that lambdabot doesn't execute IO)
23:42:05 <BernhardPosselt> jle`: aaah, ty
23:42:11 <speak> Rotaerk: Even having "let p = getPerson blah" is rare to see is my whole point, you don't have that in a lot of tutorials online
23:42:13 <jle`> BernhardPosselt: it sequences all of the items "inside" the Traversable using Applicative, and then re-assembles them back into the original structure
23:42:20 <halogenandtoast> sssilver: if you feel like you know haskell and want some help/guidance writing a guest book, you can feel free to ask me, I'm no expert yet, but I've enjoyed writing web apps in Haskell.
23:42:23 <jle`> BernhardPosselt: actually sorry, what i wrote was 'sequenceA'
23:42:28 <speak> It stays in the completely abstract level, no connection to real life programming problems
23:42:36 <jle`> BernhardPosselt: but traverse f = sequenceA . fmap f
23:42:36 <speak> Anyway, enough offtopic, sorry
23:42:48 <trigone> :t sequenceA
23:42:49 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
23:42:52 <BernhardPosselt> jle`: yeah, dont know sequenceA yet so the explanation was perfect
23:43:03 <tdammers> I think the real issue here is that Haskell code tends to be written to be as general as possible
23:43:04 <trigone> :t sequence
23:43:06 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:43:16 <tdammers> which is good, but makes for a mental hurdle when learning
23:43:16 <ski> @type sequenceA
23:43:18 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
23:43:29 <jle`> BernhardPosselt: but yeah, it uses the Applicative to 'sequence together' all of the resulting actions/`f a`s, and also to re-assemble them back into the original structure
23:43:33 <trigone> when should i use sequence vs sequenceA?
23:43:53 <BernhardPosselt> trigone: A means applicative
23:43:56 <speak> tdammers: I'm just saying that maybe for once, the tutorial could even in passing mention what all the list manipulation is actually used for in the end :D
23:44:02 <BernhardPosselt> so for applicatives
23:44:04 <jle`> trigone: 'sequence' only exists as a historical accident
23:44:09 <ski> you can always use `sequenceA' instead of `sequence', now that `Monad' is (finally) a subclass of `Applicative'
23:44:24 <jle`> trigone: so use `sequenceA` for everything, except sequenceA's name is significantly sillier than sequence's name
23:44:28 <tdammers> we have this instinct that when, for example, we have written a function [Int] -> Int, we go, wait, how about we rewrite that as (Foldable t, Num a) => t a -> a
23:44:32 <ski> if you want to emphasize that you're working with a monad, you could use `sequence' for that reason
23:44:32 <halogenandtoast> ski: "finally" as in a few years ago finally
23:44:36 * ski nods
23:44:39 <trigone> jle`: no kidding (for the name)
23:44:51 <tdammers> speak: I agree with that. Examples of real world use cases are tremendously helpful
23:44:57 <jle`> trigone: so most people use `sequence` because it's a nicer name, but really you should be using 'sequenceA' for everything.
23:45:05 <tdammers> speak: that's why I mentioned RWH and Write Yourself A Scheme
23:45:12 <trigone> jle`: but in terms of implementation, they're both identical or not?
23:45:19 <jle`> their functionality is the same
23:45:23 <halogenandtoast> tdammers: Write yourself a scheme is amazing, but I feel like it's out of date.
23:45:25 <speak> tdammers: Yeah indeed, thankfully there are some resources like the ones you mentioned
23:45:27 <jle`> trigone: but sequenceA works on more things than sequence does
23:45:29 * ski sometimes uses `liftM' instead of `fmap', to emphasize that it applies to the monad in question, rather than any old functor
23:45:34 <trigone> jle`: like, i heard ap was different to `<*>` in some cases though i still don't know why
23:45:40 <speak> tdammers: I suppose we're pretty much on the same page, then
23:45:42 <halogenandtoast> That might have been fixed, but I remember having trouble with the parsec library
23:45:45 <jle`> trigone: they should be functionally identical
23:45:47 <ski> (can make it easier to read the code, if you *also* have some `fmap' in there)
23:45:53 <jle`> trigone: just with different internal implementations
23:45:57 <tdammers> halogenandtoast: that's very possible, IIRC it was written before parsec 2
23:45:58 <pacak> :t ap
23:46:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:46:06 <jle`> trigone: they might be implemented differently, but their results must be identical
23:46:19 <pacak> If instances agree - they are identical, but if they are not...
23:46:21 <trigone> jle`: yeah but beyond functional there's efficiency. it sure is probably not that big of a deal, but still if i have a choice, might as well use the best implementation, right?
23:46:41 <jle`> if there is a difference in efficiency, sequenceA would be the more efficient one
23:46:43 <halogenandtoast> tdammers: What I really want is a good write yourself a haskell in haskell
23:46:54 <trigone> jle`: same for <*>?
23:46:58 <tdammers> halogenandtoast: diehl has a WIP on that
23:47:00 <jle`> yes
23:47:07 <trigone> pacak what do you mean instances agree?
23:47:12 <halogenandtoast> tdammers: Yeah I've stumbled on it a few times
23:47:15 <halogenandtoast> diehl might be my hero
23:47:19 <tdammers> http://dev.stephendiehl.com/fun/
23:47:24 <tdammers> (for those unfamiliar)
23:47:51 <ski> if one's making a type an instance of both `Monad' and `Applicative', giving "real" implementations of `return' and `(>>=)', then one can implement `(<*>)' just as `ap' (defined in terms of the former two), in order to avoid spelling the particular definition of `(<*>)' out
23:48:00 <trigone> tdammers: is this a serious thing or a joke? cuz it sounds great
23:48:06 <BernhardPosselt> :t (>>=)
23:48:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:48:19 <ski> similarly, `liftM' (or `liftA') can be used as a default implementation of `fmap' (or `liftA')
23:48:41 <jle`> indeed ap is used by those too lazy to write <*> for their types by hand
23:48:56 <jle`> instance Applicative Foo where pure = return; (<*>) = ap
23:48:59 <trigone> ski: i know that, but i still heard ap and <*> had differences of behavior in some fringe cases (though i still don't know when or how)
23:49:09 <jle`> (assuming you already have an instance of Monad for Foo)
23:49:19 <jle`> ap and <*> are required by law to be the same
23:49:24 <jle`> but there are unlawful instances out there
23:49:28 <jle`> i'm looking at you, simon marlow
23:49:36 <halogenandtoast> lol
23:49:42 <trigone> jle`: who's that?
23:49:46 <jle`> ... as an inspiration :)
23:49:49 <tdammers> trigone: it's serious. and it is great. problem is it's a "rough cut" version, unfinished, and there doesn't seem to be a lot of activity, so I don't think it'll be anywhere near complete in the foreseeable future
23:49:55 <jle`> trigone: one of the two holy Simons of Haskell
23:50:04 <halogenandtoast> lol
23:50:05 <trigone> tdammers: still what's there is probably very enlightening
23:50:07 <halogenandtoast> the holy simons
23:50:10 <halogenandtoast> that's a first for me.
23:50:13 <tdammers> trigone: do read it, yes
23:50:21 <tdammers> trigone: also check out http://dev.stephendiehl.com/hask/
23:50:35 <trigone> tdammers: when i have time :P
23:50:52 <koz_> I second checking out Stephen's excellent piece.
23:50:57 <trigone> tdammers: yeah i know of what i wish i knew, really great reference. sad it's not complete though
23:51:02 <koz_> It ranks along the same level as the Typeclassopedia for me.
23:51:53 <tdammers> What I Wish is like the Pragmatic Haskeller's Handbook
23:52:07 <tdammers> a great practical companion to the more theoretical materials found elsewhere
23:52:21 <BernhardPosselt> yep, even learn you a haskell is too theoretic
23:52:53 <tdammers> learn you a haskell is also wrong in many places, or uses questionable wording for the sake of giving the reader an intuition, any intuition at all
23:53:16 <BernhardPosselt> OO analogies would have helped a lot
23:53:24 <trigone> what?
23:53:38 <trigone> how do you make OO analogies of haskell?
23:53:49 <BernhardPosselt> concepts in OO taken to haskell
23:53:57 <tdammers> no, they wouldn't
23:54:12 <BernhardPosselt> like "this is how you build an app with haskell"
23:54:15 <tdammers> in order to understand how to implement OO concepts in Haskell, you first have to understand most of the rest of Haskell
23:54:36 <tdammers> "how you build an app" has nothing to do with OO techniques
23:54:49 <BernhardPosselt> well kinda
23:54:51 <trigone> hm... like encapsulation and polymorphism? they risk trying to apply OO *techniques*, trying to find the OO way in haskell, and they won't find it
23:55:03 <BernhardPosselt> stuff like DI containers
23:55:25 <tdammers> none of that has anything to do with "how you build an app"
23:55:45 <trigone> (is it me or OO terminology reads like "how to build a car engine from scratch?")
23:55:50 <BernhardPosselt> well, it does for everyone working in the java space for instance
23:56:15 <BernhardPosselt> you create your services using containers like Spring
23:56:20 <tdammers> encapsulation just means "I have a program, I split it up into modules, and I define narrow interfaces for them, using language features to make sure nothing gets accessed from the outside except for the interface"
23:56:58 <tdammers> that's not "how to build an app", it's "how to build an app with Java and Spring"
23:57:03 <BernhardPosselt> first thing i thought when looking at haskell was "where is the DI container"
23:57:16 <jle`> ^ that's probably an example of previous programming experience making it harder to learn haskell
23:57:17 <speak> It's even simple examples like this that I wish were employed more in Haskell tutorials: http://try.purescript.org/?gist=b80be527ada3eab47dc5&session=16dd0811-5010-aed8-63de-2902c6b8c42e
23:57:26 <BernhardPosselt> jle`: it totally is
23:57:43 <trigone> tdammers: well tha's the haskell way. in OO i think the main purpose is encapsulating mutability: giving the responsibility of mutability to the state itself. but since each state bubble can call another state's method and mutate said other state, the advantages remain limite
23:57:50 <ski> (solution : forget previous programming experience)
23:57:52 <jle`> but admittedly most people come into haskell with ruined minds
23:58:04 <halogenandtoast> jle`: like me
23:58:04 <BernhardPosselt> forgetting the stuff takes years
23:58:09 <jle`> same
23:58:27 <tdammers> trigone: shared mutable state is the main reason, but modularity and narrow interfaces are good even if you never mutate anything
23:58:37 <BernhardPosselt> or rather learning everything from scratch
23:58:38 <halogenandtoast> I came from C, Java, PHP, Ruby
23:58:43 <trigone> tdammers: yes ofc
23:59:05 <tdammers> and actually we have that in Haskell, and it works just fine
23:59:07 <BernhardPosselt> because you are used to certain patterns/structures that dont exist in haskell
23:59:10 <halogenandtoast> Well and QBasic
23:59:10 <tdammers> better even than in Java, I would say
23:59:14 <halogenandtoast> but we don't really talk about that anymore
23:59:22 <trigone> tdammers: (except the module system itself is kinda horrible)
23:59:24 <BernhardPosselt> and there are patterns/structures that dont exist in Java
23:59:35 <tdammers> trigone: nah, just not very powerful
23:59:45 <BernhardPosselt> or at least not explicitely
23:59:47 <trigone> tdammers: which is kinda why it's horrible :P
23:59:51 <tdammers> BernhardPosselt: yes. lots.
