00:37:42 <dminuoso> Im trying to understand what a type constructor exactly is. Is it just a way of expressing a type?
00:38:10 <dminuoso> I mean the term "constructor" seems quite abstract when looking at something like Bool. Or is it possibile to have parameterized type constructors?
00:39:10 <ventonegro> dminuoso: Bool is a type constant, Maybe is a type constructor
00:39:27 <ventonegro> :k Maybe
00:39:29 <lambdabot> * -> *
00:39:36 <ventonegro> :k Bool
00:39:37 <lambdabot> *
00:40:47 <dminuoso> ventonegro: Okay that is surprising, because the purple haskell book that was recommended to me, calls the Bool part in `data Bool = False | True` to be a type constructor
00:41:20 <ventonegro> dminuoso: Yes, they are usually called like that, which can be confusing some times
00:41:57 <verement> Bool is a type constructor in the same way that False and True are data constructors
00:42:03 <[exa]> dminuoso: technically both are type constructors, but one is parametrized and second is already constant and immutable. Maybe "type literal" would be better.
00:42:22 <dminuoso> [exa]: I see, so this is kind of the equivalent of normal and templated types in C++?
00:42:32 <[exa]> dminuoso: very roughly yes
00:44:40 <ventonegro> dminuoso: If I can plug a blog of my own: http://unendli.ch/posts/2017-07-20-algebraic_data_types.html
00:44:54 <[exa]> but well, expressed totally differently. if you look at the kind * as a "type" of the type, eg. the type of Bool, then * -> * is a function that takes one type and produces another (which is exactly what Maybe identifier represents)
00:47:51 * hackagebot hslua 0.8.0 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
00:49:29 <dminuoso> [exa]: Aha, so this is why I cant declare a type like `foo :: Maybe -> Bool` because the type constructor Maybe acts like a function which produces a final type.
00:49:42 <[exa]> yes
00:50:14 <[exa]> in fact, types of every declared thing must be of kind *
00:50:18 <[exa]> btw
00:50:21 <[exa]> :k (->)
00:50:25 <lambdabot> * -> * -> *
00:51:10 <[exa]> function-type-constructor takes input/output types and produces the resulting function type
00:51:59 <dminuoso> [exa]: Interesting, so it seems like a far more generich approach to what template classes in C++ describe
00:52:16 <dminuoso> *generic
00:52:44 <dminuoso> Well, I cant quite describe it, but it feels like a very intuitive and trivial concept.
00:53:11 <[exa]> dminuoso: AFAIK both systems can be simulated in another, except for C++ integer template parameters
00:53:55 <[exa]> (which requires some extra processing)
00:54:10 <dminuoso> The similarities between the template system in C++ and Haskell are really surprising (especially with concepts in the mix as an equivalent to typeclasses)
00:54:49 <[exa]> you might want to try this https://github.com/vituscze/norri
00:55:19 <[exa]> (and compare with https://aphyr.com/posts/342-typing-the-technical-interview )
00:58:28 <[exa]> dminuoso: anyways the comparison basically reduces to the fact that C++ forces the programmer to uniquely specify the return type of each identifier, which makes the type checking mostly unidirectional; haskell inference goes "both ways" without the programmers' annotations. The most interesting part imho is that almost all other differences are a direct outcome of this.
01:00:40 <merijn> ok, suppose I want to display dynamically generated images on the web, what are the best languages/libraries I can use if I prefer sticking with haskell? I could use diagrams to generate static images and serve those, but the generation doesn't seem all that fast...I could draw directly in the canvas, but then I have to decide what the easiest language is to deploy/compile to JS
01:00:59 <merijn> ghcjs? PureScript? TypeScript? Elm? Did I miss any fancy contenders?
01:01:22 <ventonegro> merijn: Isn't there a binding for Cairo?
01:01:24 <merijn> Bonus for easy to compile/deploy and decent support for drawing (vector) graphics
01:01:50 <halogenandtoast> TIL I could write fmap using Monad and without using methods directly from Applicative or Functor
01:01:50 <merijn> ventonegro: I fail to see how that solves the slow to render issue? Since the Cairo backend is slow
01:02:49 <ventonegro> Backend for what? I meant Haskell bindings to the Cairo lib
01:04:00 <merijn> ventonegro: The cairo backend for diagrams. Cairo itself is WAY to low level for me
01:04:21 <ventonegro> merijn: I see
01:07:05 <angerman> Hmm Is there some function I should know of, with type: (a -> b -> m c) -> m a -> m b -> m c? (e.g. fn f x y = do x' <- x; y' <- y; f x' y')
01:07:57 <angerman> guess `join . liftM2` would work
01:08:21 <merijn> angerman: Sadly, no. I've thought about writing a generalised version of that a bunch of times before
01:09:03 <angerman> maybe this just tells me I really want an applicative interface ;-) but that would be too much of a refactoring right now.
01:10:20 <[exa]> hm, what would be a good name for that?
01:11:00 <angerman> =2<<? :)
01:12:03 <angerman> or =<<2 or maybe just bind2? 
01:14:31 <angerman> guess bind2 is better, as you can't have an infix with three argument i believe.
01:18:25 <[exa]> bind2 seems cool
01:20:39 <ab9rf> angerman: well, yes, you can really
01:22:27 <angerman> ab9rf: might have screwed something up then. f `bind2` x y, seemed to err out, whereas bind2 f x y did not.
01:23:12 <[exa]> it applies x to y first
01:23:36 <ab9rf> ^
01:24:03 <[exa]> anyways, what about some renamed nice $ ?
01:24:05 <ab9rf> what's the default fixity of a `` infix op? 0?
01:24:32 <[exa]> ab9rf: afaik it's handled separately
01:24:50 <ab9rf> [exa]: i knew this once but it's been ages since i read that chapter of the report
01:25:28 <ab9rf> [exa]: the report suggests that you canset the fixity of operators specified uysing ``
01:25:50 <ab9rf> actually, it doesn't just suggest it, it outright demonstrates it
01:25:57 <[exa]> wow
01:26:02 <ab9rf> 4.4.2
01:26:34 <ab9rf> default fixity is left-9
01:26:58 <merijn> Prelude has a bunch of examples too
01:27:04 <merijn> `elem` has infixl 4
01:27:16 <merijn> or maybe it's infix 4, since it's not associative anyway
01:27:55 <merijn> [exa]: This kinda nifty details is why I recommend people read the report, it's very readable and filled with details like this that many people don't know :)
01:27:56 <ab9rf> merijn: infix 4
01:28:08 <ab9rf> merijn: heh
01:28:20 <[exa]> where do you see the thing about `` ? (maybe I'm just blind)
01:28:22 <ab9rf> merijn: to be fair, i did go straight for the report to answer the question :)
01:28:36 <ab9rf> [exa]: read section 4.4.2 of the report
01:29:05 <ab9rf> to be fair, that's the 98 report, but i don't imagine it changed in 2010
01:29:48 <ab9rf> section numbers mya hae changed
01:30:11 <ab9rf> no, it's 4.4.2 of the 2010 report as well
01:30:13 <[exa]> "Any operator lacking a fixity declaration is assumed to be infixl 9" ... this?
01:30:29 <ongy> 10:28 ab9rf: to be fair, that's the 98 report, but i don't imagine it changed in 2010        
01:30:36 <ongy> argh, I hate my touchpad =.= sorry
01:30:40 <ab9rf> [exa]: also the example below, where they explicit demonstrate setting fixities of `op` and `Bar.op` and `Foo.op`
01:31:42 <ab9rf> the little table in 4.4.2 of "standard" operators also shows a number of ``-defined operators
01:31:56 <ab9rf> `elem`, `notElem`, `div`
01:32:03 <[exa]> yup but still no idea how that connects to f `bind2` x y  where the x_y takes precedence :]
01:33:11 <ab9rf> function application is higher than all operators
01:33:16 <[exa]> oh so, a misunderstanding. I read `` as "empty function application operator" :D
01:33:24 <ab9rf> so f `bind2` x y is parsed as f `bind2` (x y)
01:33:41 <[exa]> so I was trying to derermine where tf would haskell get that
01:33:51 <[exa]> ok explained. :D
01:34:18 <ab9rf> while (f `bind2` x) y might be more useful, that's not how haskell parses it
01:34:26 <ab9rf> and it's not possible to force it to, either
01:34:39 <[exa]> what's the best way to hide a $ there?
01:35:23 <[exa]> like, it stands out a bit too much in:  f `bind2` x $ y
01:35:46 <merijn> [exa]: You can't, for good reason, because that'd make people guess what you mean
01:36:23 <ab9rf> it's probably best not to do such things :)
01:36:45 <[exa]> best solution on the wiki also looks as a hack
01:36:47 <merijn> [exa]: You have 3 options, all of which make the grouping obvious: 1) 'bind2 f x y', 2) '(f `bind2` x) y', or 3) 'f `bind2` x $ y'
01:37:10 <ab9rf> merijn: oh there are more options!
01:37:19 <[exa]> I go with 1
01:37:27 <ab9rf> evil thing syou can do with sections
01:37:47 <merijn> [exa]: "hiding the $" is just code for "I want to group like this, but make it look like I didn't", which in turn is code for "I want to make this more confusing to read", which you probably shouldn't
01:40:39 <ab9rf> yup
01:42:38 <ab9rf> "Fixity is a property of a particular entity (constructor or variable), just like its type; fixity is not a property of that entity’s name." i take it that that means if i say "plus = (+)" then `plus` is infixl 6?
01:43:49 <ongy> > let plus = (+) in 4 `plus` 5 * 3
01:43:51 <lambdabot>  27
01:44:36 <ab9rf> that's curious
01:45:07 <[exa]> fixity is a property of an operator-like token, no idea how does it connect to a variable
01:46:11 <ab9rf> that is not the result i expected.
01:48:17 <[exa]> ab9rf: tokenization and parsing can't be mixed up with variable binding in compiler chain (it would create a good deal of chaos). That's btw the reason why fixity declarations only work globally
01:48:19 <merijn> ab9rf: I did :)
01:48:32 <merijn> ab9rf: infixl 9 default
01:49:01 <ab9rf> merijn: yes, i figured that. obviously i misunderstood what the report was saying.
01:51:48 <merijn> ab9rf: I admit it's confusingly worded
01:52:14 <merijn> I was confused initially to, but I think what it's saying is that compound expressions can't have a fixity
01:52:30 <merijn> Which is irrelevant, as you can't put compound expressions inside ` atm anyway
01:53:12 <ab9rf> merijn: i think it might also be referring to the fact that package-qualified names have fixity based on the package qualification
01:54:13 <ab9rf> if `op` is, say infixl 5, but in module Foo `op` is infixr 6, , then `Foo.op` is infixr 6
01:54:40 <ab9rf> that seems to be what the illustration below that statement seems to be illustrating
01:54:54 <halogenandtoast> Is there a good way to remove an element from a list. Something with the type: Int -> [a] -> (a, [a])
01:55:19 <halogenandtoast> or I guess Int -> t a -> (a, t a)
01:55:27 <ab9rf> why a tuple?
01:55:39 <MarcelineVQ> halogenandtoast: what if the list is empty?
01:55:52 <halogenandtoast> I'm fine with Int -> t a -> (Maybe a, t a) as well
01:56:06 <ab9rf> What's the Int? an index?
01:56:09 <halogenandtoast> Yes
01:56:27 <halogenandtoast> (removed element at index, remainder after removing the element at index)
01:57:25 <ab9rf> halogenandtoast: Data.Set defines deleteAt
01:57:28 <halogenandtoast> could probably use splitAt, take the head and combine the first part and the tail of the second, but I was wondering if there is something better/cleaner
01:57:38 <merijn> I was about to say, this sounds suspiciously like "not a list"
01:57:45 <ab9rf> but this really isn't a "list"
01:57:50 <ab9rf> it's just an indexed collection
01:58:08 <halogenandtoast> merijn, ab9rf: I'm modelling a hand of cards
01:58:14 <merijn> halogenandtoast: What are you storing/doing? And are you sure you're not better off without a list? :)
01:58:27 <halogenandtoast> I'm probably better off without a list
01:58:30 <halogenandtoast> isn't that usually the case?
01:58:39 <ab9rf> note that Data.Set uses a tree representation
01:58:50 <merijn> halogenandtoast: I'd use either a Set (if you can't have multiple identical cards) or Sequence
01:59:53 <halogenandtoast> Okay, technically there are no duplicated cards.
02:00:18 <ab9rf> halogenandtoast: i'd suggest Data.Set from the containers package
02:00:26 <EvanR> if you have a set of cards, you cant permute them
02:00:36 <EvanR> like swap card at i and j
02:00:59 <ab9rf> EvanR: in most card games, your hand is not ordered
02:01:14 <ab9rf> your play might be, but the cards in your hand are unordered
02:01:18 <halogenandtoast> So the order kind of matters here
02:01:23 <halogenandtoast> because the user types the index of the card
02:01:27 <halogenandtoast> to play it
02:01:45 <EvanR> if i look at a video poker screen, it may show 10 J Q K A or 10 J Q A K
02:02:05 <EvanR> same set though
02:02:05 <halogenandtoast> The order matters in that it should stay the same, don't care about the actual ordering.
02:02:06 <ab9rf> halogenandtoast: if you need to preserve order, Seq
02:02:38 <EvanR> and if this is a hand of cards
02:02:52 <EvanR> of up to 5 or 10 or 20 cards
02:03:05 <EvanR> Data.Set is OVERKILL :)
02:03:09 <MarcelineVQ> Set seems like a pretty good idea. Seq does too. though if you want to use list then your splitAt idea might look like  (\n xs -> case splitAt n xs of (_,[]) -> Nothing; (xs,y:ys) -> Just (y, xs ++ ys))   but xs ++ ys is extra work written like that
02:03:09 <ab9rf> EvanR: yes
02:03:27 <ab9rf> one of Set or Seq (possibly bot) will both Do What You Want with a minimum of fuss
02:03:33 <halogenandtoast> Thanks everyone I'll check out Seq
02:03:40 <halogenandtoast> is Seq different than Sequence?
02:03:41 <EvanR> > splitAt 3 [0,1,2,3,4,5,6]
02:03:43 <ab9rf> they're probably overkillish, but they are there and have fairly obvious APIs
02:03:44 <lambdabot>  ([0,1,2],[3,4,5,6])
02:04:08 <EvanR> > splitAt 3 [0,1,2,99,4,5,6]
02:04:10 <lambdabot>  ([0,1,2],[99,4,5,6])
02:04:20 <ab9rf> note that splitAt is in the Seq API
02:04:58 <ab9rf> halogenandtoast: Data.Sequence defines the type Seq
02:05:02 <ab9rf> halogenandtoast: this is, perhaps, unfortunate
02:05:10 <ab9rf> actuallt the type constructor Seq
02:05:15 <ab9rf> it's not a type until you apply it :)
02:05:45 <ab9rf> don't try to use Seq for hands with more than maxBound::Int cards
02:06:35 <EvanR> what do you use for that
02:06:41 <geekosaur> god doesn't play dice withthe universe, e plays texas hold 'em?
02:07:28 <ab9rf> the 100,244,102,091 of Spades
02:07:41 <EvanR> bust
02:08:03 <ab9rf> imagine bridge with a maxBound::Int deck
02:08:27 <saurabhnanda> is there any way to use forM on a Data.Strict.Map such that the traversal function has access to they key AND the value?
02:08:47 <merijn> saurabhnanda: No, Foldable/Traversable can only look at the last type parameter
02:09:00 <saurabhnanda> aargh
02:09:15 <merijn> saurabhnanda: Use M.mapWithKey or M.traverseWithKey
02:09:16 <saurabhnanda> merijn: the Data.Map.Strict docs also don't seem to have any special function
02:09:34 <saurabhnanda> merijn: and build a list of IO actions and then use `sequence` on it?
02:09:37 <cocreature> traverseWithKey is exactly that special function
02:09:40 <merijn> saurabhnanda: That's because Map.Strict reexports everything but a handful of functions from Lazy
02:09:54 <cocreature> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html#v:traverseWithKey
02:09:58 <saurabhnanda> cocreature: but that doesn't allow monadic actions, does it?
02:10:03 <merijn> saurabhnanda: Map.Strict and Map.Lazy are the exact same data structure, just different insert operations
02:10:13 <ab9rf> the hackages pages are confusing for Data.Map.Strict, it looks like it's empty but it actually reuses most of Lazy 
02:10:23 <cocreature> saurabhnanda: every monad is also an applicative so it definitely does allow for monadic actions
02:10:23 <merijn> saurabhnanda: traverse works with any Applicative
02:10:50 <merijn> ab9rf: Yeah, I don't like how haddock does partial module reexports
02:11:01 <cocreature> ab9rf: are you looking at different haddocks than I am? https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html lists a lot of stuff
02:11:27 <merijn> cocreature: Data.Map haddocks, probably
02:12:01 <cocreature> ah yeah that mostly links to Data.Map.Lazy
02:12:10 <saurabhnanda> I'm at https://www.stackage.org/haddock/lts-9.0/containers-0.5.7.1/Data-Map-Strict.html#g:13
02:12:36 <ab9rf> merijn: it took me quite a while to understand what was going on there.
02:12:58 <ab9rf> merijn: i still sometimes forget about that behavior when looking at some module i've not used before
02:13:05 <saurabhnanda> merijn: cocreature: If I use traverseWithKey, the behaviour is not like forM_. I'm getting a type error: Expected type: IO () // Actual type: IO (Map RecordName ())
02:13:38 <merijn> ab9rf: I've tried to figure out how to fix that when writing my own haddocks, but the only way is to explicitly at all reexports to your export list
02:13:42 <merijn> saurabhnanda: So, use "void"
02:13:42 <cocreature> saurabhnanda: use "void"
02:13:44 <saurabhnanda> I'm not sure if the IO is actually going to get excuted!
02:13:56 <saurabhnanda> okay, let me try
02:14:02 <ab9rf> merijn: well, that's probably best for other reasons as well, but it's... bleah
02:14:07 <cocreature> it’s like the difference between mapM and mapM_
02:14:12 <merijn> ab9rf: Why is that best?
02:14:36 <ab9rf> merijn: i don't like wildcard exports
02:14:39 <merijn> ab9rf: I mean that "module Foo (module Foo.MyReExport) where" generates the obscure small link
02:15:02 <ab9rf> merijn: from a standpoint of principle of least surprise, it's better to explicitly list all your exports
02:15:06 <merijn> ab9rf: Whereas "module Foo (Foo.MyReExport.foo, Foo.MyReExport.bar) where" does generate individual entries for foo and bar
02:15:39 <merijn> ab9rf: That kinda defeats the entire point of reexports. Listing "module Foo" in your export list already explicitly lists what you're reexporting
02:15:40 <ab9rf> that way, if the parent module changes what it exports, your code doesn't start exporting something you didn't know about
02:15:48 <merijn> ab9rf: Writing 10-20 explicit exports is a pain in the ass
02:15:55 <saurabhnanda> merijn: cocreature: works! thanks!
02:15:59 <ab9rf> merijn: yeah, that's the downside of that approach.
02:16:24 <ab9rf> merijn: if one approach or the other were clearly better in every case, it wouldn't be an optional behavior :)
02:16:51 <merijn> ab9rf: The best approach would be to have a haddock config flag that tells it what it should generate
02:17:18 <ab9rf> merijn: won't argue with that
02:17:39 <ab9rf> merijn: the tool should never become the master
02:18:39 * hackagebot transient-universe 0.4.6.1 – Remote execution and map-reduce: distributed computing for Transient – https://hackage.haskell.org/package/transient-universe
02:24:00 <merijn> So, to repeat my earlier question: ghcjs, PureScript, TypeScript, or elm, which would you recommend?
02:24:09 <merijn> (You, being anyone here)
02:24:30 <Athas> TypeScript or Elm.  But for which purposes?
02:24:47 <[exa]> merijn: you want to draw the bitmap to html5 canvas?
02:24:48 <ab9rf> that's a field i need to learn more about
02:25:27 <merijn> Athas: Rendering (vector) graphics specifically, but just more complex web programming in general
02:25:35 <ab9rf> maybe i should reimplement that colorspace thing i wrote 15 years ago in haskell and try to make it work as a browser app
02:25:50 <ab9rf> (i wrote it 15 years in javascript, obviouslyt)
02:26:09 <ab9rf> very ugly javascript
02:26:11 <[exa]> merijn: try reflex.dom?
02:26:20 <ab9rf> might be a candidate for reflex
02:26:55 <[exa]> merijn: anyways, what kind of vector graphics? diagrams?
02:27:40 <merijn> [exa]: I don't have a really specific goal beyond vague ideas and inspiration, tbh
02:28:20 <Aruro> what is best way to parse html in haskell?
02:28:25 <ab9rf> so, dancing kittens?
02:28:33 <merijn> Reflex seems like an absolute no go
02:28:37 <merijn> "GHCJS uses a lot of memory during compilation. 16GB of memory is recommended, with 8GB being pretty close to bare minimum." <- lolwut
02:28:51 <ab9rf> merijn: yeah, that's a bit of a turnoff
02:28:55 <merijn> I guess that means I can preemptively cross-off ghcjs too
02:29:20 <ab9rf> i think i might havew 16GB on my minecraft server box, i can't remember how much ram we stuffed into that thing
02:29:45 <ab9rf> Aruro: what do yuou want to do with the html you parse?
02:29:56 <merijn> ab9rf: I want something I can develop on my laptop and deploy to a cheap VPS, not something that requires a dedicated buildbox >.>
02:30:02 <merijn> Athas: So why TypeScript and Elm?
02:30:07 <ab9rf> merijn: that rules out ghcjs :)
02:30:13 <Aruro> ab9rf: i want to extract text
02:30:33 <merijn> ab9rf: also, I heard ghcjs generates pretty obscenely big source
02:30:40 <merijn> Aruro: Just webscraping?
02:30:44 <Aruro> merijn: yeah
02:30:48 <merijn> Aruro: Have a look at html-conduit
02:30:59 <merijn> Aruro: Which also ties easily into http-conduit for fetching webpages
02:31:01 <ab9rf> merijn: the js it produces is somewhere between "hideous" and "oh my dear fucking lord"
02:31:13 <[exa]> merijn: looked at d3js ?
02:31:39 <merijn> [exa]: That would involve writing JS, which I'd like to avoid at all cost :)
02:31:46 <ab9rf> i'd second html-conduit. i've only used it once, but it's really easy to work with for most scraping purtposes
02:31:48 <[exa]> merijn: btw I ran ghcjs on my 4gb laptop with no serious trouble
02:32:09 <merijn> html-conduit is super easy if you don't have any schemas or whatever
02:32:11 <Unode> If an haskell program suffering from a space leak ends. What happens to all the leaked objects? Do they get evaluated, garbage collected or simply thrown out in incomplete state?
02:32:25 <ab9rf> merijn: i used to like javascript, too. but that was 15 years ago.
02:32:33 <ab9rf> merijn: i knew more then :)
02:32:45 <merijn> Aruro: I actually have a really simple webscraper I wrote using html-conduit, although it doesn't quite work anymore due to changes: https://gist.github.com/merijn/d8188ddd129718ffcfb0
02:33:15 <ab9rf> i should try to find that old hard drive and recover my ham radio repeater database
02:33:16 <Aruro> merijn: ty
02:33:28 <merijn> Unode: "space leak" is code for "this isn't GCed as quickly as I want it" or "this is producing a ridiculously large intermediate structure I don't care about"
02:33:30 <ab9rf> it did a bunch of scraping and other stuff, written mostly in perl
02:33:33 <[exa]> Unode: they get simply discarded (afaik it's not necessary to garbagecollect in that situation)
02:33:40 <Aruro> i used hxt but then got discouraged by its complexity
02:33:43 <merijn> Unode: Unless you're using the FFI you never "permanently" leak memory
02:33:48 <merijn> Aruro: oh, yeah, hxt is confusing as fuck
02:33:55 <merijn> Aruro: html-conduit is much simpler
02:34:01 <ab9rf> that site, when it was up, netted me like $50 a month in ad revenue, and i ndidn't even try to promote it
02:34:44 <ab9rf> and reimplenenting it in haskell would be a useful exercise
02:34:46 <merijn> ab9rf: I just wanna do some procedural generation/visualisation (like: https://watabou.itch.io/medieval-fantasy-city-generator)
02:34:55 <Aruro> did archlinux fixed haskell package mess?
02:35:02 <ab9rf> merijn: ooh, sounds like fun
02:35:12 <merijn> ab9rf: Except I want something I can easily package/distribute
02:35:21 <merijn> ab9rf: So JS+vector graphics seems easiest
02:35:59 <Unode> so technically an object is only "space leaked" if it's not used? So in other words, if I have some structures piling up in memory I can either have a space leak bug or an actual bug because I'm not using some structure I created?
02:36:25 <merijn> Unode: Space leaks like that exist in any GCed languag (java, python, ruby, etc.)
02:37:05 <merijn> Unode: Haskell has an additional type of space leak where laziness might result in building a huge structure of computation that (eventually) just evaluates to, like, an integer. So you'd rather be slightly less lazy and only store the integer
02:37:06 <Unode> yeah it's just the lazyness that makes it worse/more noticeable.
02:37:22 <merijn> Unode: "foldl" is a typical example of this
02:37:31 <Unode> how so?
02:38:18 <Unode> oh, I see what you mean, intermediate structure is kept until evaluated
02:38:30 <Unode> therefore foldl' ?
02:38:39 <merijn> Unode: Yeah
02:39:12 <merijn> Unode: If you'd evaluated immediately you could immediately GCed that whole structure. And if you have a list of, like, 10 million elements that sorta intermediate structure hurts
02:39:13 <ab9rf> foldl (+) 0 [1..20] builds this fairly large structure of unevaluated additions
02:39:55 <merijn> Unode: But, as I said, space leaks are never *truly* lost so that they can't be GCed (unless you're using the FFI to manually allocate memory, then all bets are off :))
02:40:56 * hackagebot axiom 0.4.6, hsdev 0.2.5.1, wrecker 1.0.0.2
02:40:56 * hackagebot  → https://hackage.haskell.org/packages/recent
02:48:36 <Unode> thanks for the clarification
02:52:04 <Aruro> why hoogle goes on stackage when asked: hoogle generate ?
02:53:28 <Aruro> downloading ..stackage.org/lts/cabal.config
03:02:44 <geekosaur> presumably so it can download prebuilt hoogle indexes for your resolver and include them in your local hoogle database, rather than leave anything you got from the resolver unindexed
03:06:16 * hackagebot orgstat 0.0.4 – Statistics visualizer for org-mode – https://hackage.haskell.org/package/orgstat
03:15:01 <kahlil29> Hey I'm getting my API response from theMovieDb API and I wanted to know the best way to extract out the "id" of the first result from the list of results returned by this 
03:15:03 <kahlil29> https://api.themoviedb.org/3/search/movie?api_key=443faaae5d25a64487005863edc6c726&query=Jack+Reacher
03:15:11 <kahlil29> this is an example url
03:15:49 <kahlil29> I've tried using Lens but I end up with an array of Value which I can't parse 
03:16:00 <geekosaur> you know, giving out your api key like that might not be the wisest idea
03:16:12 <kahlil29> yeah i know but I'm desperate for some help 
03:16:51 <geekosaur> you probably want aeson-lens package
03:17:01 <kahlil29> yeah using it already. Tried ^? 
03:17:06 <[exa]> help for the price of apikey, yay
03:18:25 * geekosaur is *not* following that url btw, since if that site has any clue at all they'd notice multiple IPs accessing a keyed resource and suspedn the api key
03:18:41 <ventonegro> Too late
03:19:09 <kahlil29> resp ^?  responseBody  . key "results" 
03:19:13 <kahlil29> is what i tried
03:19:39 <kahlil29> it gives me something closer to what i want. but after that I don't know how to access just the "id" of the first result
03:20:02 <dysfun> can i suggest pastebinning the data (rather than pasting the link with the api key in it) ?
03:20:18 <kahlil29> yeah will do that next time. sorry
03:21:30 <kahlil29> once I get the id , I can fire my next GET request 
03:22:48 <dysfun> 'first result' is iat 0 ?
03:23:28 <dysfun> probably even ix
03:24:40 <kahlil29> didn't get you @dysfun
03:25:05 <dysfun> i assume `key "results"` gives you a list or seq or somesuch
03:25:19 <dysfun> so you can just use `ix 0` to get the first result?
03:25:37 <geekosaur> actually nth
03:25:37 <geekosaur> http://hackage.haskell.org/package/lens-aeson-1.0.2/docs/Data-Aeson-Lens.html#v:nth
03:25:50 <dysfun> oh, aeson specific
03:26:12 <dysfun> and then it's just `key "id"` ?
03:26:24 <geekosaur> hopefully yes
03:27:00 <geekosaur> ix would probably work but might need type annotations; nth knows it's using aeson types
03:27:14 <kahlil29> i tried key "id" but i think it doesn't work since it's nested inside. key probably only checks top level 
03:27:30 <geekosaur> right you need the nth 0 to drill don
03:27:34 <dysfun> yeah there are a million ways to express anything in lens, if you know the incantations
03:27:43 <geekosaur> *down
03:27:45 <f-a> I made a little package with I invoke via cabal new-repl. It has all sort of useful/testing stuff. Is there a way to cabal new-package $directory somehow? It would be lovely to use it without cd'ing
03:27:52 <kahlil29> nth sounds like what i need. thanks @geekosaur and you too @dysfun
03:32:21 <kritzcreek> I'm getting this failure when building Win32-notify on the latest stackage nightly. The hackage page lists no repository, where should I report this?
03:32:28 <kritzcreek> http://lpaste.net/357737
03:34:26 <ertes-w> lo
03:36:57 <srhb> ._.
03:37:13 <srhb> kritzcreek: Refer to one of the full names, or hide one of them.
03:37:35 <kritzcreek> srhb: I don't even know where to get the source from
03:37:38 <srhb> oh
03:37:45 <srhb> Sorry, I misunderstood.
03:38:09 <srhb> kritzcreek: I'd email the maintainer in lieu of a issue tracker.
03:38:18 <AWizzArd> The Linter suggested me to do    do let y = (x+10)    instead of    do y <- return (x+10)   – why is it „better” to use let?
03:38:37 <srhb> AWizzArd: Because y <- return x is the same as let y = x
03:38:49 <srhb> AWizzArd: The whole return-bind juggling is superfluous
03:38:52 <AWizzArd> So, why not suggest to do   y <- return x    instead of let?
03:39:06 <srhb> Because it's a bit weird to wrap some constructor over x just to remove it immediately again
03:39:12 <srhb> AWizzArd: consider Maybe, where return = Just
03:39:22 <srhb> AWizzArd: y <- Just x
03:39:29 <AWizzArd> Okay good, understood.
03:40:58 <mniip> AWizzArd, also let is more generic
03:41:08 <mniip> it lets you set an explicit type signature
03:41:15 <mniip> and define an identifier by case analysis
03:41:20 <mniip> or define a function at all
03:44:44 * hackagebot dejafu 0.7.1.1 – Systematic testing for Haskell concurrency. – https://hackage.haskell.org/package/dejafu
03:47:21 <AWizzArd> mniip: also good points, thx!
03:55:56 <ertes-w> hlint should probably warn about 'return' in general: "use pure"
04:01:05 <bvad> ertes-w: Why? 
04:02:37 <ertes-w> bvad: because 'return' is 'pure' with an unnecessarily strict type
04:02:46 <ertes-w> :t (pure, return)
04:02:48 <lambdabot> (Applicative f, Monad m) => (a1 -> f a1, a -> m a)
04:03:25 <bvad> ertes-w: I just wanted you to elaborate :p
04:04:18 <bvad> ertes-w: should 'return' be removed from 'Monad'?
04:04:37 <merijn> bvad: Long term, yes
04:04:43 <srhb> I don't know about that. When you're writing a library, it usually makes sense to be very general. When you're writing the client code, it usually makes sense to be very restrictive.
04:04:55 <srhb> (Though in the case of return/pure, return shoudl probably just disappear)
04:05:13 <ertes-w> srhb: but 'return''s type is the kind of restriction that is rather pointless
04:05:18 * srhb nods
04:05:20 <bvad> But when you get generality for free, then why not?
04:05:42 <srhb> bvad: I agree in this case. But unnecessarily general code can give unnecessarily general errors.
04:06:05 <cocreature> isn’t there something silly about ApplicativeDo where it only works with "return" but not "pure"?
04:06:07 <ertes-w> srhb: in the best case nothing happens, in the worst case you find yourself refactoring your code to change every 'return' to 'pure'
04:06:15 <srhb> ertes-w: Indeed.
04:06:15 <halogenandtoast> ab9rf, EvanR, merijn thanks for the advice earlier
04:06:34 <halogenandtoast> I had to attend my Haskell Book club so I didn't get a chance to thank you before
04:06:43 <srhb> bvad: That's why I mentioned the library/executable division. At least I often find that useful.
04:07:36 <bvad> srhb: I agree
04:07:46 <bvad> .. I think
04:07:48 <ertes-w> cocreature: it should work with 'pure'
04:08:17 <bvad> ApplicativeDo looks at dependencies on labels, right?
04:08:26 <cocreature> ertes-w: in theory sure, but I vaguely remember that pure is not supported but maybe I’m missremembering or it has been fixed since
04:09:00 <ertes-w> cocreature: the more common mistake is to do something like "pure $ …" and then wonder why 'pure' is not supported =)
04:09:17 <ertes-w> cocreature: but the truth is that ($) is your top-level function there, and ($) is not supported
04:10:32 <cocreature> ertes-w: looking at the docs "$" is supported, and pure is too
04:10:45 <cocreature> “Note: the final statement must match one of these patterns exactly: return E, return $ E, pure E, pure $ E"
04:10:57 <ertes-w> cocreature: ah, that's new
04:12:17 <cocreature> I still would have liked an "ado" or something like that to guarantee that things only use Applicative operators
04:14:02 <jle`> indeed
04:17:23 <ertes-w> cocreature: (Applicative f) => (Monad f => Void) -> f …
04:17:24 <ertes-w> =)
04:17:41 <ertes-w> with an explicit Dict argument and EmptyCase it might actually work
04:18:05 <cocreature> ertes-w: how does that help if "f" is some fixed type?
04:18:14 <cocreature> and "f" is an instance of Monad
04:18:27 <ertes-w> ah, well…  in the latter case it doesn't
04:18:38 <cocreature> that’s why I want "ado" :)
04:18:44 <ertes-w> (and if it's not a Monad, you'd get a type error anyway)
04:18:49 <ertes-w> yeah, i'm just playing around =)
04:32:17 <brynedwards> :r
04:32:24 <f-a> :P
04:32:33 <brynedwards> Tmux bind...
04:32:37 <f-a> haha
04:32:44 <f-a> may your recompile bring no type errors
04:32:52 <brynedwards> :D
05:04:11 <adsc_> Hey everyone. I have a quick question to anyone with experience implementing bidirectional type inference...
05:05:05 <adsc_> I'm implementing a simple lambda calculus with bidirectional inference, and I've split my AST up into two mutually recursive types of inferrable and checkable expressions
05:05:34 <adsc_> Now I'm adding tuples, and I cannot seem to understand if I should add tuples to inferrable or checkable expressions.
05:06:09 <adsc_> Clearly, if all the elements of the tuple are inferrable, the tuple's type is also inferrable, but if any element is not, then inference fails
05:08:55 <adsc_> So, I'm not really sure how to handle that situation... Anyone who've got any inputs on this?
05:30:58 * hackagebot yarn-lock 0.3.1 – Represent and parse yarn.lock files – https://hackage.haskell.org/package/yarn-lock
05:41:35 <dramforever> Why are constraints unlifted?
05:42:17 <dramforever> i.e. why can't we have: castList :: Eq a b -> a -> [b]; castList ~Refl x = [x]
05:42:53 <dramforever> Then castList _|_ x = [ _|_ ]
05:53:04 <mniip> @tell dramforever you could lift the constraint with Dict
05:53:04 <lambdabot> Consider it noted.
06:05:55 <ryba> does anyone know if haskell threads get any exception manin thread exits?
06:13:38 <c_wraith> ryba: that's not the standard behavior.
06:13:43 <jchia_1> Does anyone know how to reliably clear the ~/.stack and ~/.stack-work directories of unwanted things, where "unwanted things" could be defined as files needed only by old resolvers that I don't want to use anymore, or all locally-generated files (as opposed to downloaded files like hackage packages or ghc binary)?
06:14:04 <c_wraith> ryba: the standard behavior is for an exception to only impact the thread that received it
06:14:28 <jchia_1> I meant PROJECT/.stack-work, not ~/.stack-work.
06:14:52 <ryba> c_wraith: ok, is there any standard way for thread to know that program exits, so it can do cleanup?
06:15:59 <c_wraith> ryba: no.  If you need to clean up, it needs to be done before the main thread exits
06:17:21 <ryba> c_wraith: which makes things painfull, when main thread is c code
06:24:28 <schoppenhauer> hi. is there any real example where being able to catch exceptions outside IO would *really* break referential transparency?
06:24:51 <schoppenhauer> I just found examples that do not feel like genuine problems.
06:27:55 <Athas> schoppenhauer: define "*really*".
06:28:15 <ryba> schoppenhauer: how would you catch exceptions outside IO anyway?
06:28:47 <Athas> ryba: try/catch expressions?
06:28:51 <Athas> SML has those.  They work great.
06:29:05 <Athas> But it means everything is effectful.
06:29:53 <ryba> Athas: but those are IO alredy
06:30:02 <[exa]> there should be some syntactic sugar for Either that does the try/catch
06:30:50 <ryba> Athas: SML?
06:30:59 <Athas> ryba: STandard ML.
06:31:13 <Athas> The most formally correct language!
06:31:31 <c_wraith> schoppenhauer: being able to do so would introduce values that depend on their evaluation order
06:32:00 <c_wraith> schoppenhauer: you can do that already with unsafeInterleaveST, which is hideously unsafe.  That's why it's got "unsafe" in its name.
06:32:20 <int-e> schoppenhauer: http://lpaste.net/9161049329790615552 is a toy example demonstrating that allowing pure code to catch async exceptions is problematic
06:32:53 <c_wraith> schoppenhauer: but the same would happen with any code with bottoms in its values, if you could catch exceptions in pure code
06:34:40 <c_wraith> amusingly, int-e's objection and mine deal with totally different classes of exception, each of which is bad to catch purely in its own way.
06:35:19 <schoppenhauer> c_wraith: ok, so it is only the evaluation order?
06:35:45 <int-e> my example doesn't care about evaluation order
06:35:55 <c_wraith> schoppenhauer: "only"?  Being able to observe evaluation order of pure code is exactly the same as it not being pure code.
06:36:39 <schoppenhauer> c_wraith: I'd hope that there is an example where x != x
06:36:51 <schoppenhauer> *hoped
06:36:59 <c_wraith> yes, that's exactly what you get
06:37:08 <schoppenhauer> c_wraith: how?
06:39:53 <c_wraith> Just create something whose value depends on evaluation order.  I can build an example in a few minutes, I guess.
06:52:16 <trigone> hi! anyone got good reference to haskell-customize vim the best way? thanks! :)e
06:54:23 <ertes-w> schoppenhauer: the question doesn't make sense…  you can't observe exceptions in pure code, and you can't run IO actions in haskell
06:55:43 <ertes-w> catch :: a -> (SomeException -> a) -> a  -- will always return the first argument or the result of the second argument…  you couldn't branch on whether an exception occurred in the first argument
06:56:07 <ertes-w> catch :: IO a -> (SomeException -> IO a) -> a  -- and this is just complete non-sense
06:58:37 <ertes-w> you can't use int-e's approach either, because that one breaks semantics…  haskell's semantics does not allow observing infinite loops without IO
06:59:00 <ertes-w> (pure exceptions are equivalent to infinite loops)
07:00:01 * hackagebot serokell-util 0.4.0 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
07:00:56 <Cale> ertes-w: You can run IO actions in Haskell... from other IO actions :)
07:01:01 <trigone> nobody uses vim? :/
07:01:27 <ertes-w> Cale: that's not really "running", just composing
07:01:29 <phadej> trigone: sec
07:01:34 <Cale> trigone: I used vim for a long time. The main customisation I would recommend is :set expandtab
07:01:50 <Athas> Cale: Or with unsafePerformIO.
07:01:51 <trigone> Cale: yeah but i rather meant specialized for haskell
07:01:55 <phadej> trigone: http://www.stephendiehl.com/posts/vim_2016.html 
07:02:01 <trigone> phadej: what does sec mean?
07:02:13 <phadej> one second :)
07:02:13 <trigone> phadej: thx for the link!
07:02:19 <trigone> oh ^^
07:02:44 <kahlil29> I have a value 'Number 24428.0' of type  Number :: scientific-0.3.5.1:Data.Scientific.Scientific -> Value   .... how can i convert it to either Int or String in order to use it? 
07:02:49 <trigone> phadej: is this what you use? or used?
07:02:56 <phadej> I use some parts from there
07:03:06 <phadej> (and IIRC nothing that's not there)
07:03:30 <trigone> what's iirc already? i keep forgetting
07:03:40 <Cale> If I recall correctly
07:03:41 <phadej> if i remember correctly
07:03:50 <trigone> ok thx
07:03:50 <Cale> I tried the ghc-mod stuff on a couple occasions, but never really found it to be worth the trouble somehow.
07:04:09 <phadej> Cale: ghc-mod is exactly what I don't use
07:04:25 <Cale> You can use hasktags to generate tags for your Haskell code, and get jump to definition and such.
07:04:26 <trigone> Cale: how do you code in haskell, wrt tooling?
07:04:34 <ertes-w> kahlil29: Scientific is already a numeric type…  if you still need to convert it to another numeric type you can use 'realToFrac' or e.g. 'round'
07:04:58 <trigone> Cale: sounds good
07:05:00 <mizu_no_oto> I typically just have 2 terminals.  One with vim, one with ghci
07:05:11 <Cale> trigone: So when I used vim, I basically used plain vim with syntax colouring and tags. Lately I've been using Sublime Text, and I basically use plain Sublime Text.
07:05:27 <c_wraith> kahlil29: but first you need to pattern-match to remove the Number constructor Aeson uses to distinguish from all the other things that make up JSON
07:05:31 <trigone> hm ok
07:05:32 <Cale> There's a Haskell plugin, but I tried it and it was mostly more annoying than helpful.
07:06:14 <trigone> do you think there's a way to make ghci reload automatically when the file(s) change?
07:06:17 <kahlil29> how do i do that? @c_wraith? normal case 'something' of? 
07:06:23 <c_wraith> kahlil29: yes
07:06:25 <Cale> I dunno, I just hit :r
07:06:43 <kahlil29> thanks @ertes-w and c_wraith . will try it out
07:07:27 <trigone> Cale: yeah i guess... there's still an advantage in calling vim from within ghci: it jumps immediately to the location of the first error. ironically it's not smart bc on average it's the last error which is actually meaningful
07:08:38 <Cale> In my experience, all the errors tend to be distinct and meaningul on average
07:08:40 <ertes-w> kahlil29: Scientific is not really suitable for arithmetic though, because it uses a representation that makes it expensive…  if you need to do heavy computation you should probably convert to something like Double first
07:08:43 <trigone> how's sublime text, does it allow keyboard control? is it free?
07:08:57 <Cale> It's not free, but it's got some nice features
07:09:12 <trigone> Cale: really? so far with me, very often the last error was the one "triggering" the others. but maybe that was random
07:09:14 <Cale> The multiple cursor thing is actually pretty cool
07:09:45 <trigone> Cale: hm ok
07:11:00 <tsahyt> I've already asked this yesterday but got no reply. Is there anything I can read on the duality of parsing and serialization? After all I've got Parser a = String -> a on the one hand, being a functor and applicative, and Serializer a = a -> String on the other, being contravariant and divisible
07:11:08 <tsahyt> everywhere I look I just see the same things with the arrows reversed
07:11:38 <Cale> trigone: Basically I only switched because I just wanted an editor where the things which annoyed me were different from the things which were annoying me about vim
07:11:40 <tsahyt> but I don't know nearly enough category theory to explore this further, so I was wondering whether someone else did
07:11:44 <dminuoso> `a = if 1 then 1 else 1` I've been staring at this for so long now, I'm confused. Why exactly is trying to deduce (Num Bool) ?
07:11:50 <Cale> trigone: If you're generally happy with vim, then use it :)
07:12:07 <dminuoso> For a while Ive been thinking that this should try to look for (Bool Num) rather, for no real reason other than intuition
07:12:14 <Cale> I just got really tired of hitting 'u' when I meant to hit 'i' and little things like that :)
07:12:24 <phadej> dminuoso: if fromIntegral (1 :: Integer) then 1 else 1
07:12:45 <c_wraith> phadej: isn't it fromInteger, rather than fromIntegral?
07:12:48 <ongy> so you stopped using vim because you suck at touch typing? :P
07:12:52 <trigone> Cale: yeah, i'm mostly happy, i'll probably not change for now
07:12:58 <kahlil29> @ertes-w won't be using it for arithmetic. API response is returning it that way. Just wanna use the number as a string and append it to my next GET request. What do you suggest I use for converting to String or Int? 
07:12:58 <lambdabot> Unknown command, try @list
07:13:00 <dminuoso> phadej: You misunderstand my problem. It's not about "making this work", but rather trying to understand that detail about the error message.
07:13:03 <phadej> c_wraith: true, fromInteger
07:13:15 <phadej> dminuoso: fromInteger is a member of Num class
07:13:18 <c_wraith> dminuoso: phadej was explaining the error message
07:13:32 <dminuoso> Ohh!
07:13:49 <trigone> Cale: true, i plan on hiding commands as such to not hit them by mistake for nothing. esp `u`, you can write `:u` for the same effect
07:13:50 <ertes-w> kahlil29: see if the Show instance fits your needs
07:14:05 <ertes-w> @let import Data.Scientific
07:14:06 <lambdabot>  .L.hs:117:1: error:
07:14:06 <lambdabot>      Data.Scientific: Can't be safely imported!
07:14:07 <lambdabot>      The module itself isn't safe.
07:14:14 <ertes-w> seriously?
07:14:25 <c_wraith> unsafeScientific.
07:14:42 <kahlil29> @ertes-w : realToFrac does not get rid of the trailing decimal point and 0 . It comes as 24428.0
07:14:42 <lambdabot> Unknown command, try @list
07:14:50 <c_wraith> schoppenhauer: I can't manage to construct a problem case, though I'm sure one exists.  I'll think about it more.
07:15:14 <schoppenhauer> c_wraith: ok. just highlight me when you have one. I couldn't think of one either.
07:15:28 <ertes-w> kahlil29: realToFrac does not render at all
07:15:48 <c_wraith> kahlil29: trailing decimals are a property of how the data is printed, not how it is represented
07:15:58 <ertes-w> kahlil29: if you need a very specific format one option is the Numeric module, another is Text.Printf
07:15:59 <dminuoso> phadej: Well... the haskell book says "[the issue is that Bool does not implement the Num typeclass]"
07:16:21 <kahlil29> sorry. haskell noob here. so I need to convert the number to an Int first and then show it? 
07:16:48 <ertes-w> kahlil29: use Integer instead of Int, but only if you're fine with losing the fractional part
07:16:53 <c_wraith> kahlil29: you should convert it to whatever type is correct. :P
07:17:01 <kahlil29> yes i WANT to lose the fractional part :P 
07:17:08 <dminuoso> Which by itself makes sense, but I just cant maek sense of this error message still, even with what you just said.
07:17:22 <ertes-w> kahlil29: in that case you need to use one of the rounding functions:  ceiling, floor, round, truncate
07:17:43 <phadej> dminuoso: instances are open, so we don't have a non-hacky way to say "this type will not ever have that instance"
07:18:12 <phadej> dminuoso: so type-checker looks for Num Bool instance and as it fails to find it, it says "cannot find it"
07:18:15 <kahlil29> truncate did the job. awesome. thanks you guys 
07:18:20 <dminuoso> phadej: is (Num Bool) a bizarre way of expressing that it's trying to turn a Numb into a Bool?
07:18:25 <kahlil29> just btw, how do you guys tag other users? 
07:18:32 <phadej> dminuoso: in that case yes
07:18:38 <phadej> > True + False
07:18:40 <lambdabot>  error:
07:18:41 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘+’
07:18:41 <lambdabot>      • In the expression: True + False
07:18:52 <phadej> > 1 :: Bool
07:18:55 <lambdabot>  error:
07:18:55 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘1’
07:18:55 <lambdabot>      • In the expression: 1 :: Bool
07:19:24 <ertes-w> > liftA2 (\(fn, f) x -> (fn, x, f x)) (zip "cfrt" [ceiling, floor, round, truncate]) [-2.25, -1.75 ..]
07:19:27 <lambdabot>  [('c',-2.25,-2),('c',-1.75,-1),('c',-1.25,-1),('c',-0.75,0),('c',-0.25,0),('...
07:19:36 <ertes-w> err
07:19:44 <c_wraith> dminuoso: the syntax for declaring an instance looks (in part) like "instance CLASSNAME TYPENAME where ...".  So if you were to declare an instance, it would look something like "instance Num Bool where ..."
07:20:28 <c_wraith> dminuoso: the compiler is telling you that it can't find "instance Num Bool", which is why uses that ordering.
07:20:44 <ertes-w> > liftA2 (\x (fn, f) -> (fn, x, f x)) [-2.25, -1.75 ..] (zip "cfrt" [ceiling, floor, round, truncate])
07:20:46 <lambdabot>  [('c',-2.25,-2),('f',-2.25,-3),('r',-2.25,-2),('t',-2.25,-2),('c',-1.75,-1),...
07:21:07 <dminuoso> c_wraith: Ahh. I kept thinking that this was a kind-of type constructor expression.
07:21:15 <dminuoso> c_wraith: Now this makes perfect sense. Thank you.
07:22:11 <ertes-w> kahlil29: "tag"?  you mean the "kahlil29:" part?
07:22:40 <kahlil29> yes that @ertes-w
07:22:46 <ertes-w> kahlil29: just write it
07:22:54 <ertes-w> kahlil29: in most clients you can tab-complete it
07:23:06 <kahlil29> ertes-w:
07:23:53 <kahlil29> ertes-w: got it thanks
07:25:39 <jmnoz> what'd be the stack equivalent for "cabal install -fdevelopment"?
07:25:58 <dminuoso> c_wraith: Is it relevant that Bool is not a typeclass to begin with?
07:26:13 <kadoban> jmnoz: What's -f ? package flags?
07:26:21 <ab9rf> dminuoso: well, yes, because you can't make one typeclass an instance of another typeclass
07:26:26 <c_wraith> dminuoso: yes.  Types and classes are very different things
07:26:28 <ab9rf> you caonly make types instances of typeclasses
07:26:34 <ab9rf> Num is a class, not a type
07:26:38 <ab9rf> Bool is a type
07:26:44 <mniip> dminuoso, it kind-of is, still
07:27:02 <c_wraith> dminuoso: a type is (roughly) a list of possible values.  A class is a set of operations a type can opt in to
07:27:24 <mniip> Num Bool is a constraint. Constraints are things that can appear left to =>
07:27:25 <AWizzArd> When reading a blog post I found something similar to   (\() -> const 10 20) ()      – what is \()  ?  A function that pattern matches on ()?
07:27:26 <ab9rf> it's fairly common for haskell newbies to think that Num is a "superclass" or "supertype" of the various numeric types, but that's not how it works
07:27:40 <jmnoz> kadoban: I'm not sure It's just how snap framework suggests to install in development mode but I use stack
07:27:51 <mniip> AWizzArd, a lambda and a pattern match on ()
07:27:55 <jmnoz> it's "-f development"
07:28:30 <AWizzArd> mniip: oki
07:28:47 <kadoban> It's probably --flag "*":development or something, you should probably look up in cabal-install's docs that that's what that means though.
07:29:18 <jmnoz> kadoban: okay, thank you very much :)
07:30:42 <c_wraith> dminuoso: the Bool type represents the two values True and False.  The Num class represents operations like (+), (-), (*), and the one you ran into implicitly, fromInteger, which is used to convert numeric literals in source to values of a type that implements Num
07:31:32 <c_wraith> dminuoso: this is how Haskell allows numeric literals to be Integer, Int, Float, Double, or any other type that has a Num instance
07:32:22 <dminuoso> c_wraith: Ah, and since fromInteger has the type `fromInteger :: Num a => Integer -> a` it cant construct `a` because Bool is not an instance of Num (which it would have to be for that to work)
07:32:31 <c_wraith> dminuoso: exactly
07:33:04 <c_wraith> dminuoso: and of course, it determined that it needed to be a Bool because you must provide a Bool value as the conditional expression in an if/then/else expression
07:33:25 <dminuoso> c_wraith: is if/then/else a function? or is that a syntactical construct?
07:33:31 <c_wraith> dminuoso: it's syntax
07:33:53 <c_wraith> dminuoso: but you can still kind of pretend it has the type Bool -> a -> a -> a :)
07:33:56 <ab9rf> syntax over which there is often significant dedate
07:33:59 <ab9rf> debate
07:35:05 <c_wraith> dminuoso: it's sort of redundant syntax, as it does nothing that can't be done with pattern matching or a helper function that uses pattern matching.  But people wanted it, so we've got it. :)
07:35:37 <ertes-w> dminuoso: it could very well be a function…  the reason it's syntax mostly comes down to history, and perhaps a lack of self-confidence =)
07:36:06 <ab9rf> you will also find people who don't like the use of boolean types :)
07:36:35 <ertes-w> yeah, lots of those crazy people that think that programming is not about ones and zeroes…  i'm one of them =)
07:37:00 <jmnoz> kadoban: can "*" be used in stack.yaml for flags? I can't find it documented
07:37:38 <kadoban> jmnoz: There's some syntax for setting flags on packages in stack.yaml, but I don't know what it is, I never use that. Sorry
07:37:43 <ab9rf> you will find haskellers who will insist that "if x == ... then ... else ... " is bad code that should be instead written as a pattern match
07:37:46 <ertes-w> a certain mr. harper would call me a logician (as opposed to a combinatorialist)
07:38:26 <ab9rf> at first i thought they were silly, but as i've spent more time writing code in haskell i've concluded that they're more right than wrong
07:39:18 <ertes-w> Bool is always a red flag…  whenever you use bool, there is something wrong with your code, even when (or perhaps *especially* when) you don't have another choice
07:39:46 <ertes-w> for example (doesFileExist :: FilePath -> IO Bool)…  this function is highly problematic
07:40:22 <ertes-w> not only does it lead to boolean-blindness, but the kind of blindness that is actually prone to race conditions
07:40:55 <ab9rf> ertes-w: "do-operation-or-fail" is a better model for such situations
07:41:23 <ab9rf> for many different reasons, not just "does the file exist"
07:41:28 <ertes-w> ab9rf: you don't always have that option unfortunately…  the filesystem is not transactional
07:41:30 <ab9rf> the file might exist but the operaiton might be prohibited for some other reason
07:41:48 <ab9rf> ertes-w: well, the file system might not be transactional. some filesystems are :)
07:47:21 <geppettodivacin> I've never heard the argument against Bool (except for the case for type blindness). Is there a good article to go read? (Or would you like to rant about it here?)
07:48:31 <ongy> it's not like people agree on that view in general. There's also people (which I belong to) that say you should test for things first and only run into exceptions when things go wrong after checking (and this depends on your language, python devs disagree strongly)
07:49:37 <kadoban> For usual file-y things, that's a waste of time. Anyone can create/delete the file you just checked on anyway, or it can fail for other reasons, so you have to deal with the exception anyway. But it depends, things get complicated and annoying.
07:50:22 <phadej> ongy: that's why openFile could be openFile :: FilePath -> IO (Except CommonErrors a)
07:50:24 <ongy> things like files already existing, or the directory you want not existing shouldn't default into exceptions. though you should be aware any checks are insufficient in the real world
07:50:38 <Unode> if I have two consecutive (1st and 2nd line) liftIO calls inside the same 'do', what would be the syntax to only have to use liftIO once?
07:50:53 <phadej> Unode: liftIO $ do ...
07:50:55 <ertes-w> geppettodivacin: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
07:51:00 <ertes-w> geppettodivacin: the section is self-contained
07:51:00 <Unode> phadej: thanks
07:51:05 <kadoban> But as to Bool, I think many people would agree on *some* uses of it being better as pattern matches, like if isNothing blah ...  I think everyone has a different tipping point. I find them bad for APIs a lot of the time as well, when it's unclear which means what between True and False
07:51:23 <ertes-w> geppettodivacin: here is a more theoretical perspective: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
07:51:33 <geppettodivacin> ertes-w: Thanks, I'll take a look. And thanks to all the others, too!
07:51:37 <ab9rf> kadoban: if isNothing can just be a patther match on Nothing
07:51:49 <kadoban> ab9rf: Yes, that was my point
07:51:53 <dolio> Saying that boolean is always a red flag is also silly.
07:52:38 <ab9rf> i'd not elevate it to red-flag status
07:52:41 <ab9rf> yellow-flag perhaps
07:52:51 <ertes-w> geppettodivacin: short version: in general boolean blindness means that you reduce the information to a bit, then you branch on that bit, and then in at least one branch you use more information than that bit conveys, which is in essence an unsafe thing to do, but may be safe, because you were careful as a programmer
07:53:26 <ertes-w> geppettodivacin: in other words: it's not safe by construction, but safe by careful programming
07:53:44 <geppettodivacin> Is it always possible to be safe by construction?
07:53:52 <trigone> ertes-w: in which case C is very safe if you're very careful... but that's not very useful
07:53:56 <ertes-w> geppettodivacin: computationally yes
07:53:59 <geppettodivacin> Especially since a lot of libraries don't expose constructors
07:54:15 <geppettodivacin> Unless that's not at all what you mean by "by construction"
07:54:27 <ertes-w> geppettodivacin: basically if you can represent your information algebraically, then you can use pattern-matching, folds, etc.
07:54:38 <ongy> ertes-w: then what should the result of doesFileExist be? (provided we don't have race conditions or other things that make the entire idea questionable)
07:54:40 <trigone> geppettodivacin: here construction means it doesn't depend on you screwing up or not
07:54:43 <dolio> Haskell doesn't have a nice-enough type system (yet) to make booleans completely obselete.
07:55:11 <dolio> And even in languages with fancy systems, you might still want booleans sometimes.
07:55:36 <phadej> ongy: it could be FilePath -> IO (Maybe Inode) 
07:55:43 <ertes-w> ongy: doesFileExist is an unfortunate case, because our filesystems aren't powerful enough to get rid of that blindness completely
07:56:07 <phadej> or something like that, so you don't need to traverse filesystem metadata anymore
07:56:16 <trigone> ongy: maybe you should have that function take two jobs, one if the file exists, the other if the file doesn't...
07:56:16 <ongy> phadej: that carries more information, but unless we move to inode based apis, that's going to be thrown out most of the time
07:56:27 <ertes-w> ongy: although in many cases you can use transactional operations: just open the file and handle the exception
07:56:36 <phadej> ongy: indeed, it needs inode based api then to be useful
07:56:44 <phadej> but it might be good thing
07:56:49 <trigone> http://degoes.net/articles/destroy-all-ifs
07:56:57 <ertes-w> phadej: i believe inodes can be reused
07:57:02 <ab9rf> a larger issue is that "does the file exist" is itself a potential coding error
07:57:18 <ongy> trigone: for file that mostly works, for directory my most common case to check whether it exists is to create it if it doesn't and then run the same thing (luckily createIfDoesntExist or similar exists these days)
07:57:20 <phadej> ertes-w: well, say not inode but something less error-prone then "filepath"
07:57:33 <ertes-w> phadej: i don't think there is anything like that in general
07:57:48 <phadej> ertes-w: but there *could* be
07:58:07 <trigone> ongy: well sure you could have a function which defaults the "false" case's job
07:58:15 <ab9rf> you're most likely either trying to simulate the filesystem in your own code in an effort to pretest whether some future operation is likely to succeed, which leads to code creep if the filesystem changes and to race conditions
07:59:30 <ongy> file system access will always be racy
07:59:30 <merijn> Did I hear the magic words of TOCTOU race? :p
07:59:36 <ab9rf> IO is always messy anyway, but there are ways to make it less messy
07:59:46 <ertes-w> phadej: good luck convincing the linux devs of that =)
07:59:58 <merijn> Anyone know if there's GHC binaries for WLS on windows?
08:00:02 <ongy> good luck convincing them of anything they didn't come up with :)
08:00:08 <merijn> Or do I have to build them myself?
08:00:23 <ongy> merijn: last I checked (a few months now I think) the subsystem didn't support some syscall yet GHC uses. probably best to ask in #ghc if that changed
08:00:49 <merijn> ongy: There was a blog post (on microsoft.com) just last week that pointed out GHC has been working on it for several months
08:01:34 <merijn> ongy: https://blogs.msdn.microsoft.com/commandline/2017/02/09/haskell-on-bashwsl/
08:01:54 <ertes-w> phadej: the most sensible option to deal with the non-transactional nature of the filesystem is to avoid it entirely: use sqlite or perhaps acid-state
08:02:13 <merijn> Although rereading that post indicates that simply "apt install ghc" should work
08:02:15 <ongy> why do you hate plaintext human readable files?
08:02:36 <merijn> ongy: The real question is: Why don't you love SQLite?
08:02:43 <merijn> SQLite is amazing!
08:02:45 <ertes-w> ongy: i don't hate them, but they are not well suited for *state*, more for configuration
08:03:14 <ongy> sure, but I don't tend to write out my state. but maybe I'm living in a small  happy world :)
08:03:24 <ongy> merijn: it's ok, but I hate working with databases in general
08:03:26 <ertes-w> ongy: also in the case of sqlite there is little reason to insist on plaintext…  there are enough tools from CLI to fully fledged graphical editors to deal with databases =)
08:03:43 <merijn> I can only wish that all software in the world was as well-tested, reliable, elegant, and efficient as SQLite
08:03:51 <hexagoxel> "reduce the information to a bit" ? there can't be reduction when both have the same number of values, and i'd say a pretty standardized mapping. boolean blindness as i understand it is about the semantics of the 1/True or the 0/False which may have a non-trivial mapping to the two values the things aims to represent.
08:04:01 <merijn> Only a tiny, tiny, tiny fraction of a percent is that well engineered
08:04:19 <phadej> ertes-w: I agree about non-transactionality
08:04:25 <ertes-w> ongy: sqlite is fine…  IMO most of the complexity of databases comes from them being complex pieces of server/client software…  something like sqlite typically ends up being *simpler* than dealing with text files
08:04:34 <ab9rf> i really do like sqlite 
08:04:46 <ertes-w> ongy: and i would usually pick sqlite over anything else
08:04:57 <merijn> I just wish we had slightly nicer sqlite bindings in haskell, although Selda is looking good
08:04:59 <ertes-w> ongy: for example i *hate* that my shell uses a text file for its command history
08:05:06 <ab9rf> ertes-w: especially since sqlite's CLI is fairly easy to use, and so getting data out of a .sqlite file is fairly easy
08:05:22 <ongy> depending on what it is. sqlite is nice for computer - computer stuff, but intended to be edited at all I wouldn't want it
08:05:41 <merijn> ongy: Querying it by hand using the sqlite3 binary is also pretty good
08:05:49 <ab9rf> ongy: i'm perfectly happy "editing" files with "update" statements
08:06:07 <ab9rf> ongy: but i've been a DBA for 29 years
08:06:08 <merijn> ongy: I dumped all my benchmarking data into SQLite and manually query during exploration
08:06:29 <phadej> does sqlite have validation of foreign keys nowadays, I remember it didn't validated them, so you could have inconsistent db
08:06:42 <ertes-w> phadej: yes, but you need to enable it
08:06:43 <ongy> merijn: but why?
08:06:51 <merijn> phadej: Yes, but it's optional
08:06:57 <ongy> ab9rf: argh, that sounds like you like pain to me
08:06:59 <ertes-w> phadej: it's off by default
08:07:08 <merijn> ongy: because storing them in SQLite makes loading way faster, takes less space and more amenable to filtering
08:07:24 <ongy> how much benchmark data do you have?
08:07:26 <merijn> ongy: I had it in plain text files before and loading data was a bitch, as was filtering/regrouping/etc.
08:07:28 <ab9rf> merijn: and is harder to corrupt by dropping a cat on your text editor.
08:07:40 <merijn> ongy: about 3 million measurements, give or take?
08:07:52 <merijn> ongy: Probably more soon
08:08:09 <merijn> ongy: You have no idea how much of a pain a directory with 24k text files is to deal with...
08:08:22 <ab9rf> pretty much any context where i need a persistent datastore that isn't going to be heavily shared i'm going to consider using sqlite
08:08:27 <merijn> (I mean 24,000 individual text files, not a directory of text files of size 24kb)
08:08:47 <ongy> merijn: on which file system? I'd just load that into tmpfs to work on it
08:09:00 <merijn> ongy: I dunno, ext3 or so?
08:09:03 <ertes-w> ab9rf: sharing is fine, especially if you enable the WAL, as long as you don't have too many concurrent writers
08:09:07 <ab9rf> ertes-w: o
08:09:13 <ab9rf> ertes-w: i've used it that way, too, and it's not bad
08:09:16 <merijn> ongy: How would tmpfs help at all?
08:09:35 <merijn> ongy: Your machine should already be caching files in memory anyway...somehow everyone always forgets that
08:09:41 <ab9rf> ertes-w: but at some point you really do need the more flexible arbitration that the larger DB engines provide.
08:09:49 <phadej> ertes-w, merijn: great news, thanks. I then might consider using sqlite now :)
08:10:46 <ertes-w> phadej: it pays off to at least skim this page: https://sqlite.org/pragma.html#syntax
08:11:04 <ertes-w> err…  without the anchor
08:11:19 <infandum> How do you run a haskell file from stdin using stack? Like, instead os "stack file.hs", how do I do "cat file.hs | stack"?
08:11:20 <ab9rf> ertes-w: i've even used sqlite databases shared using WAL over network devices with fairly good success, although lock arbitration can be quite slow
08:11:23 <ongy> merijn: ls -lh on a directory with 24k entries takes .182 seconds total in tmpfs (on my not very up to date machine)
08:11:41 <ertes-w> phadej: pay special attention to journal_mode and locking_mode
08:11:53 <phadej> ertes-w: thanks
08:12:05 <ertes-w> phadej: in general if you don't have a reason to restrict yourself to a single file, you should always use WAL
08:12:15 <merijn> ongy: Only if it's caches already
08:12:24 <ongy> merijn: in tmpfs it's always "cached"
08:12:31 <merijn> ongy: Did you create it right before running that?
08:12:37 <ab9rf> merijn: my wife ran into a single directory with over 1 million files in it. i think it might have been as many as 10 million
08:12:39 <ongy> unless you swap it out, but then you failed to use tmpfs
08:12:57 <merijn> ongy: The 2nd ls runs in similar time
08:13:09 <merijn> ongy: Actually, how did you time that?
08:13:16 <ongy> time ls -lh
08:13:22 <ab9rf> merijn: someone had the "brilliant" idea to collapse a bunch of folders into a single folder. 
08:13:40 <merijn> ongy: I run into issues where my SSH connection can't keep up :p
08:14:26 <merijn> anyway, SQLite can compute average on all datapoints in the same time ls managed to only list the files, let alone read and parse them :)
08:14:34 <ab9rf> i remember that she had to talk to the SAN administrator who determined that "well, the OS on the SAN doesn't support directories with more than 1 million files."
08:14:38 <ertes-w> just use a modern filesystem, then the number of files in a directory only matters to some tools (like ls)
08:14:51 <ertes-w> but anyway…  just use sqlite =)
08:14:57 <merijn> ertes-w: That assumes I have any control over the FS
08:15:40 <ongy> keep up with what? the output?
08:15:43 <merijn> ongy: after the initial ls it takes about 1.1s here to run "time ls -lh", but I think that's timing terminal output more than ls speed :)
08:15:46 <merijn> ongy: Yes
08:16:07 <ongy> piping to /dev/null it goes down to 0.074 total
08:16:51 <merijn> ongy: Which isn't really an argument in favour of having 24k files :)
08:17:09 <merijn> ongy: Especially since things like "tab complete to open a file" become rather painful :p
08:17:31 <ertes-w> to deal with a directory of files you need special tools
08:17:54 <ertes-w> to deal with a database, to high levels of complexity, all you need is the sqlite command-line tool
08:18:18 <ongy> merijn: it does? About as hard as too keep them apart. instant on my end. I think you should really try to use your tmpfs some time
08:18:55 <merijn> ongy: It's not speed, but "Display all 400 possibilities? (y or n)" when you type a prefix :)
08:19:08 <ertes-w> when i had the "just use text files" mentality i tried to replicate what sqlite does by using tools like 'sort', 'comm', 'cut', etc.
08:19:11 <ertes-w> it was not very practical
08:19:26 <ertes-w> i really see no value in the directory-of-files proposal, as opposed to sqlite
08:19:39 <sphinxo> anyway to search through #haskell logs, now that http://ircbrowse.net/browse/haskell has no search
08:19:47 <ongy> merijn: how would any other tool fix that issue? If you want to tab complete on some identifier
08:20:23 <ertes-w> ongy: you have a text file with a bunch of measurements…  how do you calculate the average?
08:20:35 <ertes-w> just 1-dimensional numbers written in any format you like
08:20:43 <merijn> sphinxo: ircbrowse is, sadly, dead
08:21:43 * hackagebot hedis 0.9.9 – Client library for the Redis datastore: supports full command set, pipelining. – https://hackage.haskell.org/package/hedis
08:22:09 <merijn> sphinxo: Or rather, Chris Done who ran/run it is no longer maintaining it due to cutting back on his open source work because of RSI
08:22:50 <merijn> It would be amazing if someone contacted him and adopted ircbrowse
08:22:59 <ongy> ertes-w: with the shell! (actually possible), but probably bc wc and some shell magic
08:23:17 <sphinxo> merijn: I might just do that, thanks!
08:23:30 <merijn> ongy: Doesn't sound nicer than "SELECT AVG(time) FROM measurements;"
08:23:50 <ongy> sounds nicer to me than having to use sql
08:24:00 <merijn> What's wrong with SQL?
08:24:05 <ertes-w> ongy: how about finding the top 10 maximum values?
08:24:10 <merijn> It's a perfectly sane DSL for querying data...
08:24:21 <ongy> probably that they tried to teach it in school and like so many things did a terrible job at doing so
08:24:40 <platz> is there a newtype for tuples that avoids the `mappend` that happens in 
08:24:42 <platz> instance Monoid a => Applicative ((,) a)
08:24:45 <ongy> ertes-w: sort (-h) | head -n 10
08:24:48 <ongy> do you even shell?
08:24:57 <merijn> Hell, it's downright impressive how well SQLite managed to optimise my, frankly, god awful queries
08:25:42 <merijn> platz: Eh, the Applicative wouldn't be lawful without that mappend, so...I hope not
08:25:45 <ongy> is sqlite the thing I'm thinking of? that 3.5k C file?
08:26:26 <ertes-w> ongy: well, that situation can be improved; watch these: <https://www.youtube.com/watch?v=tii7xcFilOA>, <https://www.youtube.com/watch?v=GkBf2dZAES0>
08:26:37 <ertes-w> ongy: total of roughly 40 minutes, and you will fall in love with SQL =)
08:26:52 <ertes-w> at least if algebra resonates well with you, but since you're a haskeller…
08:27:45 <ongy> ertes-w: I had course, basics of database systems. though I don't think I ever was in the lecture... collided with something else
08:28:03 <merijn> I wish we had a nicer library for dynamically generated queries, though...
08:28:06 <platz> hrmm.. well if the Monoid is Const I think it does what i want
08:28:18 <ongy> if I could state everything in the calculus systems we learned there... those are actually interesting
08:28:26 <merijn> Right now I've resorted to Text concatenation to construct queries :\
08:28:41 <ab9rf> merijn: that's a pervasive problem with systems based on sql
08:28:49 <platz> but I'm not sure if mapping over the left element of a tuple is in base
08:29:17 <merijn> platz: What are you actually trying to accomplish?
08:30:34 <cement> I mean, I'd usually think of mapping over the right element
08:31:18 <ertes-w> ongy: relational algebra is actually a nice way to use set theory for dealing with data
08:31:51 <ertes-w> ongy: and it's really easy to understand, too…  once you have that, the translation to SQL is almost literal, except that you replace the symbols by keywords
08:32:27 <ongy> maybe I'm too used to fucked up SQL which requires subqueries and other things
08:32:37 <ongy> where SQL was taught for the sake of SQL
08:32:49 <platz> sorry brb
08:33:06 <merijn> ongy: Sounds more like a messed up data model, tbh
08:33:21 <ertes-w> ongy: subqueries aren't inherently evil…  they are really just the SQL equivalent to first-class sets (as in Data.Set)
08:33:26 <ongy> merijn: I doubt there was any real data model in any course that had SQL I've seen thus far
08:34:24 <merijn> I have a 1-to-many relation in my tables where I want to effectively get rows of N columns for every element on the 1 side, so I've had to resort to repeated JOINs on the same relationship, and this somehow manages to get turned into a linear traversal
08:35:02 <ab9rf> merijn: that's a fairly common pattern
08:35:27 <merijn> ab9rf: Not documented or written down by anyone, apparently, though :p
08:35:28 <ab9rf> merijn: shows up all the time in snowflake schemas
08:35:32 <ertes-w> merijn: not that surprising really…  all your joins are flattened into a simple iteration pattern
08:36:01 <ab9rf> most query planners will deal fairly well with queries like that
08:36:44 <ab9rf> if you are filtering by one of the joined values, the planner may end up inverting the index spool order, though
08:36:45 <merijn> ab9rf: I was mostly pleasantly surprised by the fact that even SQLite's simple query planner accomplishes this :)
08:37:06 <ab9rf> merijn: sqlite's query planner is remarkably adept for as small as sqlite is
08:37:22 <dolio> It sounds like it's better than MySQL.
08:37:25 <ab9rf> dolio: it is
08:37:25 <dolio> Which is sad.
08:37:34 <ab9rf> dolio: mysql's query planner is moronic.
08:37:36 <ventonegro> MySQL is sad
08:37:40 <dolio> Yeah, I've noticed. :)
08:37:57 <ab9rf> dolio: mysql is about two decades behind the curve in this area
08:38:11 <ab9rf> dolio: which is an improvement: a decade ago they were THREE decades behind the curve
08:38:29 <ertes-w> mysql's query planner is probably tailored to the kinds of queries mysql typically has to deal with
08:38:47 <ertes-w> which is what the average PHP ORM vomits
08:38:47 <merijn> My database selection decision tree is: 1) Do I need SQL? If no, use some key-value store (berkely DB or something). If yes, do I need massive scale or large amounts of concurrency? If yes, use postgres, else us SQLite.
08:38:55 <dolio> I don't think I've used the newest version.
08:38:56 <ab9rf> ertes-w: i think it's more that mysql is used for the sort of queries that its query planner can handle :)
08:39:06 <ertes-w> probably =)
08:39:08 <dolio> My experience is with 5 or so.
08:39:19 <ertes-w> i wonder if maria is better in that regard
08:39:22 <ab9rf> dolio: the more recent versions are at least into the 1990s
08:39:36 <dolio> But, e.g. any subquery was instant performance killer.
08:39:47 <ab9rf> ertes-w: not significantly. most of the advanced techniques are patented, and maria cannot get licenses.
08:39:58 <ertes-w> that's just sad
08:40:14 <ertes-w> anyway, i rarely use anything other than sqlite these days
08:40:31 <ab9rf> the "commercial" version of mysql has more advanced query planners, because they can use licensed tech from their oricular masters
08:40:36 <merijn> dolio: I have an a query that performs N joins of table X and M joins on table Y, combined with a JOIN on a subquery with a complex group by and it all comes tumbling out as 1 sequential table scan :)
08:41:57 <dolio> Isn't postgres pretty good, though? So it's not all patents.
08:42:08 <ab9rf> dolio: yes, it's not all patents
08:42:24 <ab9rf> dolio: there's plent yof advances that are in the nonpatented technical literature 
08:42:25 <merijn> dolio: Postgres is pretty good, but I'm usually to lazy to setup/maintain a server :)
08:42:30 <ertes-w> postgres is pretty good, yes
08:42:37 <ab9rf> and if you bother to read those journal articles, you can fairly readily implement them
08:42:45 <ertes-w> but postgres has a lot of maintenance overhead
08:42:52 <ertes-w> and the default configuration is just stuuuuuupid
08:42:55 <ab9rf> the problem is that mysql is the php of database engines: it was developed initially by people who really had no idea what they were doing
08:43:30 <ab9rf> ertes-w: postgres is great for the database engineer, and a holy hell for the DBA
08:43:41 <ab9rf> it's a very maintenance-intensive engine
08:43:51 <merijn> ab9rf: What's the SQLite of visualisation/rendering? >.>
08:43:58 <merijn> Because I could use that...
08:44:04 <ab9rf> merijn: hehe, i wish i knew
08:44:27 <ab9rf> merijn: of all the things about which i know basically nothing, visualization is right near the top
08:44:52 <ertes-w> ab9rf: i have to wonder if postgres has any features other than concurrent writes and ACLs that sqlite lacks
08:45:04 <ertes-w> sqlite even has expression indices these days
08:45:28 <ab9rf> ertes-w: at the engine level? possibly not many. postgres has some really fancy extension functionality though
08:45:43 <ab9rf> i've done GIS in postgres, and that's really quite pleasant
08:45:44 <merijn> ertes-w: It does, I remember looking up something I needed, that was missing in SQLite, but I forgot what :p
08:47:59 <ertes-w> ab9rf: i believe sqlite can handle GIS
08:50:08 <dminuoso> ertes-w: there is an extension yes
08:50:16 <dminuoso> spatialite I think its calle
08:54:16 <ab9rf> ertes-w: could be, i haven't tried to do that stuff for several years now
08:54:31 <ertes-w> dminuoso: yeah, that's the one
08:58:11 <trigone> re, i just tried following http://www.stephendiehl.com/posts/vim_2016.html to make vim comfortable for haskell. i tried using ghc-mod's functions, but vim tells me they don't exist, there's apparently only GhcModDiagnostic... anybody can help me?
09:02:25 * hackagebot sdl2 2.3.0 – Both high- and low-level bindings to the SDL library (version 2.0.4+). – https://hackage.haskell.org/package/sdl2
09:03:28 <Unode> trigone: there's a vim plugin for ghc-mod. It's a bit slow if the codebase is reasonably large and is quirky to setup but kind-of works.
09:04:23 <Unode> The only thing I find myself fighting with every now and then is indentation. Sometimes vim tries to be smart and does the wrong thing.
09:05:07 <Unode> https://github.com/eagletmt/ghcmod-vim.git is what I'm using.
09:06:03 <Psybur|Work> Anyone use intellij?
09:06:54 <trigone> Unode: that's what i was talking about. i managed to make it work but it doesn't seem to be smart enough at all, at least not for type signature guesses...
09:07:00 <Unode> Read about it, didn't look good enough once you weigh the bloat effect.
09:07:27 <Psybur|Work> What about Leksah?
09:07:52 <Unode> trigone: yeah I don't use that feature. I mostly use it for code inspection. I.e. know what kind of variable I have in hands.
09:08:49 <Unode> and this works as long as the file qualifies as a module and/or has a proper main function.
09:09:13 <Unode> :GhcModInfoPreview is what I use the most
09:09:57 <Unode> but then again, I'm new to haskell so... an advanced user might miss other features.
09:10:42 <trigone> Unode: well i'm trying to make it work but it never finds any type, and GhcModInfoPreview just says "cannot show info"... 
09:11:04 <Unode> yeah I've been there. Are you using stack?
09:11:44 <trigone> Unode: wait, you can't inspect code except in Main?
09:11:46 <Unode> there's an issue on it but my problem was something else. The way ghcmod is launched it silences the error. Once you have access to it you can diagnose further.
09:11:59 <Unode> try this: https://gist.github.com/9f47569ff81ed16c415ccc2fdf12eb14
09:12:40 <Unode> no, you can. But you need to have a .hs file with a correct structure.
09:13:24 <Unode> meaning, if you have "loose" functions on a file it won't work. You need a module declaration and the whole thing needs to compile :)
09:13:58 <trigone> pff so far it's more work than it seems useful... yes i do have module decl. but how can i tell if it compiles without using ghci, in which case i can introspect from there?
09:14:42 <Unode> trigone: try using ghcmod externally. If it works there it's one step closer to getting it to work in vim.
09:15:06 <trigone> Unode: it DOES work now. it just keeps telling me "i don't know, don't ask me"
09:15:26 <trigone> it doesn't even recognize the type of True!
09:15:41 <Unode> ok then it's some other issue. 
09:15:51 <akfp> > [1,2] <> [3,4]
09:15:53 <lambdabot>  [1,2,3,4]
09:16:04 <Unode> I remember I did something to get that working. Let me see if I can get something from my breadcrumbs
09:16:46 <trigone> Unode: ok. thanks for trying!
09:16:57 <Unode> how did you install ghc-mod ?
09:18:16 <Psybur|Work> > [1,2] >> [3,4]
09:18:19 <lambdabot>  [3,4,3,4]
09:18:48 <trigone> Unode: stack install ghc-mod
09:19:55 <crobbins> trigone: for what it's worth, i prefer to do `stack build ghc-mod` and then point to the executable returned from `stach exec which ghc-mod`
09:19:59 <Unode> right, then I think you might be hitting the same problem I hit before. I fixed it somehow ... don't remember. But I know there's a github issue on it.
09:20:14 <crobbins> since `stack install` will install a global binary in ~/.local/bin
09:20:45 <crobbins> which is generally not what you want since ghc-mod can only be used with a project which uses the same ghc version that ghc-mod itself was compiled with
09:20:58 <Unode> I have mine setup to install to a custom bin location that is in PATH
09:21:40 <crobbins> you are probably better off creating an alias or script pointing to `stack exec which ghc-mod`
09:21:46 <mud> https://github.com/commercialhaskell/stack/pull/2812 if this gets accepted sometime, it'll have that built in, then you can just build it once for each compiler version
09:22:10 <trigone> crobbins: i'm not sure to follow... how can you choose whatever ghc-mod according to the version of ghc that the file you edit is meant to use?
09:22:28 <trigone> crobbins: is there no retrocompatibility?
09:22:41 <Unode> https://github.com/eagletmt/ghcmod-vim/issues/88
09:22:46 <Unode> trigone: ^
09:23:00 <crobbins> ghc-mod must be compiled with the same version of ghc that you are using for your project
09:23:19 <crobbins> if you use stack, it'll work by using `stack exec -- ghc-mod [flags..]`
09:24:19 * hackagebot mbox 0.3.4 – Read and write standard mailbox files. – https://hackage.haskell.org/package/mbox
09:24:19 * hackagebot asn1-codec 0.1.0 – Encode and decode ASN.1 – https://hackage.haskell.org/package/asn1-codec
09:24:30 <trigone> ok, well i'll try that. an alias could do the trick?
09:25:55 <crobbins> trigone: maybe, a script might be better though
09:26:10 <crobbins> e.g.
09:26:14 <crobbins> !#/bin/bash
09:26:24 <crobbins> stack exec ghc-mod -- "$@"
09:26:35 <crobbins> yikes my shebang is backwards
09:26:56 <crobbins> you get the drill though
09:27:13 <mud> stack exec -- ghc-mod  isn't really enough though, is it? How do you get it to have the compiler-specific version on the PATH?
09:28:01 <crobbins> mud stack exec does that for you
09:28:16 <crobbins> i believe it updates the PATH accordingly
09:28:40 <crobbins> so long as your project uses stack, of course
09:28:44 <mud> Oh you're saying you do 'stack build ghc-mod' first? Does that work? hm
09:29:03 <crobbins> yup
09:29:27 <crobbins> whether or not all of this works with vim, i'm not sure
09:29:47 <crobbins> but that's essentially the workflow needed for haskforce
09:29:47 <mud> It should if the plugin can accept a different executable to run
09:30:17 <crobbins> or you can just create a `ghc-mod` script on your PATH that runs `stack exec ghc-mod -- "$@"`
09:30:25 <mud> Ya
09:31:49 <trigone> crobbins: somehow, your method killed my vim (it hangs indefinitely when trying to load a .hs file)... :/
09:32:57 <trigone> is there a way to call ghci just for one command given as a string
09:32:59 <trigone> ?
09:34:56 <crobbins> ghci?
09:35:10 <crobbins> maybe `ghc -e` ?
09:36:03 <trigone> crobbins: no i mean sth like ghci Foo -e ":t myfun"
09:37:14 <crobbins> trigone: `ghci Foo <<< ':t myfun'`
09:38:02 <cheater> hi
09:38:20 <trigone> srenatus[m]: thx! it worked. it's terribly verbose but it worked. is there a way to make it silent?
09:38:26 <trigone> (on loading)
09:38:32 <trigone> i meant crobbins 
09:38:36 <cheater> i need to hand out fresh identifiers to my function in some way, i don't know how many i'll need. is there a monad like this? something like a reader monad but it'll generate the data that is read
09:38:58 <crobbins> trigone: add `> /dev/null 2>&1`
09:39:14 <crobbins> to redirect stdout and stderr
09:39:25 <crobbins> `> /dev/null` for just stdout
09:40:23 <trigone> crobbins: thanks!
09:40:35 <crobbins> np trigone
09:43:01 <cheater> hm i guess i could use the reader monad directly maybe
09:44:23 <penteract> cheater, wouldn't that be a state monad if it needs to generate fresh identifiers each time one is requested?
09:47:06 <werner291> Hi, I just read https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/, but it appears to (haskell-newbie) me that one cannot easily reason about the operators.For example, detecting a sum of sums, so that those may be transformed into some kind of list-based sum. The only way I see to do that is to maintain some variable in those operation objects, 
09:47:12 <werner291> which kinda defeats the purpose of this approach since it allows completely static extensible checking. Do I see this wrong?
09:48:09 <werner291> Would such a thing be possible at all without some kind of dynamic type check?
09:53:01 <ab9rf> ah, this old chestnut
09:53:27 <ab9rf> this is, i think, the fifth or sixth "solution" to this problem
09:53:29 <ab9rf> that i've seen
09:56:32 <werner291> Aha... could you explain why you don't like it? (I'm new to Haskell, so not sure if it's obvious or not.)
09:56:44 <ab9rf> i didn't say i don't like it
09:56:56 <ab9rf> it's just that people put a lot of energy into trying to solve this "problem"
09:59:36 <werner291> I'm trying to implement some way to implement symbolic computation in Haskell, and I was looking for an elegant solution. That approach seemed to work fine until I tried to implement a "simplify" operation, and I found I couldn't easily detect a sum-of-sums (or double negation, etc...) without running into some of the same extensibility problems that this approach aims to solve.
10:00:19 <werner291> So I basically have to use runtime type checks?
10:02:53 <ertes-w> werner291: i'd probably just use a *type* ExpAlg instead of a class
10:03:23 <ertes-w> data Exp = Lit Int | Add Exp Exp
10:03:44 <ertes-w> data MulExp = Exp Exp | Mul MulExp MulExp
10:03:56 <ab9rf> ertes-w: i think the whole point is to be able to add new instances without having to change the algebraic type
10:04:12 <ertes-w> ab9rf: that's what i just did, is it not?
10:04:32 <ab9rf> ertes-w: except now you have two different types :)
10:04:45 <ertes-w> ab9rf: as opposed to …?  two classes?
10:04:50 <ab9rf> ertes-w: shrug, i know
10:05:07 <ab9rf> ertes-w: i run across these discussions all the time and generally fail to get the point of them
10:05:31 <ertes-w> the first-class representation has one advantage: you can write 'simplify' without going crazy =)
10:06:15 <ertes-w> well, i've made a mistake in my types
10:06:15 <ab9rf> ertes-w: i suppose it might be more comprehensible if presented with a more practical example than an expression tree
10:06:37 <werner291> So, you just have a different type for each language module?
10:06:47 <ertes-w> and expression tree is kind of a good example, because it easily displays the essence of the expression problem
10:07:15 <ab9rf> ertes-w: the larger issue for me is i'm not cnvinced that the exprssion problem is, well, that big of a problem
10:07:24 <ertes-w> werner291: my view is this:  types represent languages, in this case an add and a add+mul language
10:08:03 <ertes-w> werner291: whether a language is more expressive than another is decided by what kind of morphisms exist between them
10:08:15 <ertes-w> think of morphisms (functions) as "translators"
10:09:24 <ertes-w> a monomorphism retains all knowledge, so it's the basis for translating into an *at least* as expressive language, and an epimorphism covers the whole target language, so it's the basis for translating into an *at most* as expressive language
10:09:41 <ertes-w> if you find an isomorphism, the languages are equally expressive
10:10:05 <bvad> Anyone here who's located in copenhagen, denmark? I'm looking to start a study group of sorts :)
10:10:49 <ab9rf> i am enjoying the first quiet day i've had in months
10:10:56 <ab9rf> it's weirdly blissful
10:11:17 <ertes-w> ab9rf: the expression problem comes up in some cases, for example imagine a compiler for two versions of a language
10:11:45 <ab9rf> ertes-w: i've bumped into that one
10:12:31 <ab9rf> you'd like to reuse the common portions 
10:12:41 <ertes-w> in my approach it's all a matter of translating…  you can translate not only expressions, but also functions on them
10:13:04 <ab9rf> ertes-w: yeah, i'm finding your comments here useful
10:13:08 <werner291> What I'm running into, for example, is that I define some language that does (+/-/*/:), and then later I want to add trignonmetry operations. In that case, how can I add the result of two trigonometry operations together?
10:13:29 <johnw> werner291: there are several good papers addressing this problem
10:13:55 <ab9rf> i don't think the one you linked is all that good of one :)
10:14:00 <johnw> see https://en.wikipedia.org/wiki/Expression_problem, and the paper by Wouter Swierstra
10:14:24 <johnw> however, if you only ever need to add one new set of operators, ever, then just doing it by hand and updating all of your evaluators, is cheaper
10:14:48 <johnw> it's a good problem to know about, though, since it comes up often enough
10:15:18 <ab9rf> the reality is that _most_ projects will have one or the other dimensions fairly well-fixed
10:15:36 <ab9rf> this become a sledgehammer that you should use sparingly
10:15:47 <ab9rf> don't overengineer your solution
10:16:00 <ertes-w> the a-la-carte method is actually equivalent to mine, except that instead of building everything from primitives i start with larger units
10:18:05 <ertes-w> a "translator" from (a, b) to (a) would be a function:  (a, b) -> a
10:18:48 <ertes-w> there is an epic, but not a monic, so (a) is less expressive than (a, b)
10:20:55 <werner291> Well, I'm going to check out that paper by Swierstra. I am looking for something extensible, if anything as an exercise in working with Haskell.
10:21:07 <werner291> Thanks for the suggestions.
10:23:16 <johnw> werner291: Wouter's paper is the best for understanding the problem, in my opinion; however, his solution is quite inefficient (lots of additional constructors).  There are also *many* modern solutions which alleviate many of these runtime costs.  My favorite right now is freer-effects.
10:28:25 <ertes-w> johnw: i'm not overly fond of freer to be honest…  if we even accept that there should be something like an "application monad" (which i disagree about), then freer does not solve the problem of local extensions in a satisfactory way
10:30:03 <ertes-w> my own approach to this particular problem is old and works much better than most people seem to acknowledge: use transformers…  but don't *start* with a transformer stack, but use individual transformers as you need them, and keep their use sites small
10:31:03 <ertes-w> oh, and haskell also features a little known and very powerful abstraction mechanism that i think everybody should use
10:31:06 <ertes-w> functions =)
10:31:34 <k0ral> Hello
10:31:54 <dsal> Hmm...  What am I trying to do here?    bounds t = (minBound t, maxBound t)
10:32:05 <dsal> I'd expect that to work, but compiler disagrees.
10:32:11 <ertes-w> dsal: minBound and maxBound aren't functions
10:32:24 <werner291> With transformers, you mean these? https://hackage.haskell.org/package/transformers
10:32:57 <ClaudiusMaximus> > let bounds t = (minBound `asTypeOf` t, maxBound `asTypeOf` t) in bounds '!'
10:32:59 <dsal> Oh.  Crazy voodoo.   Is there a way to express something like that?
10:32:59 <ertes-w> @let bounds = let x = minBound in (x, maxBound `asTypeOf` x)
10:33:00 <lambdabot>  ('\NUL','\1114111')
10:33:00 <k0ral> what's the state of the art on open unions in Haskell ? is there any decent, usable, future-proof library implementing them ?
10:33:01 <lambdabot>  Defined.
10:33:04 <ertes-w> :t bounds
10:33:05 <lambdabot> error:
10:33:05 <lambdabot>     Ambiguous occurrence ‘bounds’
10:33:05 <lambdabot>     It could refer to either ‘Data.Array.bounds’,
10:33:10 <ertes-w> d'oh
10:33:13 <ertes-w> @let bounds' = let x = minBound in (x, maxBound `asTypeOf` x)
10:33:14 <lambdabot>  Defined.
10:33:16 <ertes-w> :t bounds'
10:33:18 <lambdabot> (Bounded t1, Bounded t) => (t1, t)
10:33:21 <ertes-w> huh?
10:33:40 <werner291> Gonna check those out as well, thanks. Have to go, bye
10:33:41 <ClaudiusMaximus> polymorphic let binds
10:34:32 <ertes-w> werner291: monad transformers in general, but yeah, the transformers library and often mtl
10:35:51 <ertes-w> @let bounds'' :: (Bounded a) => (a, a); bounds'' = (minBound, maxBound)
10:35:52 <lambdabot>  Defined.
10:36:15 <ClaudiusMaximus> maybe the MonomorphismRestriction or MonoLocalBinds extensions would help (if i got the names right)
10:36:37 <ertes-w> dsal: ^ that's how i would write it, but more likely just use minBound and maxBound directly and let context and inference take care of making them equal
10:36:55 <ertes-w> ClaudiusMaximus: i was sure they are enabled
10:37:29 <ertes-w> hmm, doesn't work in GHCi either
10:37:38 <penteract> > bounds'' :: (Int,Int)
10:37:40 <lambdabot>  (-9223372036854775808,9223372036854775807)
10:38:12 <int-e> well, lambdabot is using NoMonomorphismRestriction ... I'm sure this was requested at some point.
10:38:22 <dsal> Thanks.  I've got a few ideas what's going on now.
10:40:13 <int-e> :t (\x -> (x, maxBound `asTypeOf` x)) minBound
10:40:14 <lambdabot> Bounded t => (t, t)
10:41:34 <dsal> What is minBounds, btw?
10:41:40 <dsal> er, minBound
10:41:54 <ertes-w> dsal: the minimum value of a type w.r.t. Ord
10:41:59 <int-e> :t (minBound, maxBound) `asTypeOf` join (,) undefined -- ;-)
10:42:00 <lambdabot> Bounded t => (t, t)
10:42:08 <dsal> No, I know what it does, just not what it is.  :)
10:42:17 <ertes-w> dsal: a value =)
10:42:50 <dsal> Oh weird.  I think I'm approaching single digit percentage understanding of the haskell type system.
10:43:15 <ertes-w> @src Bounded
10:43:15 <lambdabot> class Bounded a where
10:43:15 <lambdabot>     minBound, maxBound :: a
10:43:30 <ertes-w> @src Bounded Int
10:43:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:43:43 <ertes-w> you got it, tsunderebot
10:43:55 <ertes-w> @src Int Bounded
10:43:55 <lambdabot> Source not found. I am sorry.
10:44:24 <ab9rf> dsal: well, you're ahead of me then :)
10:44:39 <ertes-w> it's kinda weird when lambdabot is friendly
10:44:55 <dsal> Is minBound justa shortcut to x from (x, _) in a types bounds?
10:45:23 <ertes-w> dsal: Bounded is a type class with two members: minBound and maxBound
10:45:37 <ertes-w> dsal: any type with a Bounded instance has those two values defined
10:45:40 <ab9rf> each instance is required to provide instance-specific values
10:46:27 <ertes-w> class Bounded a where { minBound :: a; maxBound :: a };  instance Bounded Word8 where minBound = 0; maxBound = 255
10:46:41 <ertes-w> now if you use maxBound for Word8 the value will be 255
10:46:49 <ertes-w> > maxBound :: Word8
10:46:50 <ab9rf> there are no defaults. each instance must provide a specific implementation for both minBound and maxBound
10:46:51 <lambdabot>  255
10:47:02 <dsal> Oh interesting.  I've pretty much not made a type yet, so the mechanisms around this are a bit odd to em.
10:47:37 <ab9rf> the compiler can derive minBound and maxBound in some cases
10:47:53 <ertes-w> @let data MyBool = MyFalse | MyTrue  deriving (Eq, Ord, Show)
10:47:55 <lambdabot>  Defined.
10:48:02 <ertes-w> dsal: what would be minBound for MyBool?
10:48:06 <ab9rf> dsal: you mean an instance, i assume. making types is hard to avoid in Haskell :)
10:48:10 <ertes-w> hint:
10:48:15 <ertes-w> > MyTrue < MyFalse
10:48:17 <lambdabot>  False
10:48:38 <dsal> Yeah, I could read that part.  But does it automatically have a Bounded instance?  (or however that language works)
10:49:01 <ertes-w> you can use automatic deriving, but no, in principle *all* instances are manual
10:49:04 <dsal> ab9rf: Definitely not an instance.  But I've mostly interacted with Other People's Types
10:49:43 <dsal> ertes-w: Yay, it worked the way I expected.
10:50:07 <dsal> (tried it in ghci)
10:50:35 <ertes-w> dsal: one key thing to keep in mind is that Bounded is not a special class…  as far as haskell/GHC are concerned it's just another type class that happens to have two members
10:50:53 <dsal> Yeah, I understand.  I just don't know how classes work at all.  heh
10:51:16 <dsal> But it was intuitive that there was no minBound in your type above.
10:51:19 <ertes-w> maybe it's time to start writing your own types and then learn the class system =)
10:51:35 <ertes-w> hmm?  MyBool has a suitable minBound
10:51:40 <ab9rf> the compiler will automatically derive a Bounded instance for any algebraic type, all of whose constructors have arguments that are all instances of Bounded
10:51:40 <dsal> Yeah, I'm working my way through projects.  My first project is "done"  I'm pretty happy with it.  Trying to do the next one.
10:51:49 <dsal> ertes-w:     • No instance for (Bounded MyBool) arising from a use of ‘minBound’
10:52:04 <dsal> I added 'Bounded' to deriving and it was happy.
10:52:05 <ertes-w> dsal: sure, the instance is not defined yet, but you could define it
10:52:16 <ertes-w> dsal: well, i kinda hoped that you wouldn
10:52:20 <ertes-w> 't do that
10:52:29 <ertes-w> instead you should think and figure out what minBound would have to be
10:52:30 <dsal> Oh, you mean do it manually?
10:52:39 <ab9rf> dsal: yes
10:52:57 <ertes-w> dsal: ok, by now you should know that MyFalse is the minBound…  can you at least explain why?
10:52:59 <dsal> Well, sure.  it made sense intuitively.  I can try to express the instance manually, though.
10:53:03 <ab9rf> see Chapter 10 of the Report for more on derivable types
10:53:06 <dsal> Yeah, because of Ord
10:53:13 <ertes-w> dsal: be more precise
10:53:19 <ab9rf> dsal: Ord isn't required
10:53:42 <ertes-w> Bounded only makes sense with respect to an order, and the canonical order is Ord =)
10:53:53 <penteract> but you can have a partial order
10:54:05 <dsal> I don't know how to express it correctly.  The type had all values defined with the min bound on the left and the max bound on the right.
10:54:31 <ertes-w> dsal: what can you tell me about (minBound <= x) for some unknown x?
10:55:03 <dsal> ertes-w: Uh.  True?  :)
10:55:12 <ertes-w> dsal: why?
10:55:29 <dsal> Because no value can be less than the minBound
10:55:33 <dsal> That seems a bit tautological, though.
10:55:36 <ertes-w> exactly =)
10:55:39 <ertes-w> it isn't
10:56:05 <Saidahmad> hi
10:56:10 <ertes-w> just because you named a value "minBound" doesn't mean that laws manifest by themselves =)
10:56:20 <ab9rf> ertes-w: bounded may only "make sense" with an order, but the compiler can derive a Bounded instance whethre or not you have an Ord instance
10:56:40 <ertes-w> ab9rf: sure, because it's using a particular order
10:57:08 <Saidahmad> helo
10:57:18 <ertes-w> @let instance Bounded MyBool where minBound = MyFalse; maxBound = MyTrue
10:57:20 <lambdabot>  Defined.
10:57:34 <ertes-w> hi Saidahmad
10:57:49 <mud> Is that actually a law? I thought it was, but I'm not even seeing it in the docs. The relationship between Enum and Bounded seems pretty well documented though ...
10:58:23 <dminuoso> Hey. Im looking for a decent resource to start learning Haskell in. haskellbook seemed shallow without the level of detail I crave for.
10:58:32 <dsal> Nice
10:58:33 <dsal> Prelude> (minBound ::MyBool) < (maxBound ::MyBool)
10:58:33 <dsal> False
10:58:50 <ab9rf> > succ (maxBound :: Int)
10:58:52 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
10:59:58 <Saidahmad> im sorry to interrupt, and i know almost nothing about programming, about to start learning and this is a community full of programmers, so can any one of you tell where i should start
11:00:03 <ab9rf> mud: you don't have to have an order to have bounds, even though that doesn't make a whit of sense.
11:00:27 <dsal> ab9rf: I have an order and my bounds disagrees with it.  :)
11:00:44 <mud> It just seems weird that nothing seems to require that minBound < maxBound if both instances exist. Or I'm just missing it.
11:00:45 <ab9rf> dsal: yes, you _can_ do that. the compiler doe snot enforce the Bounded laws
11:01:24 <dsal> Saidahmad: There are tons of intro materials.  http://learnyouahaskell.com/chapters is a good read.  Depending on what you want to do and what kind of timeline you're expecting, it may not be the best intro to how to program.
11:01:42 <dsal> mud: Yeah, it totally let me do something stupid.
11:02:25 <mud> dsal: Well, GHC can't enforce quite a few typeclass laws, but usually they're documented anyway and the programmer must verify them when they write the instance.
11:02:56 <Saidahmad> dsal: thank you
11:05:59 <hc> hi, i'm wondering whether I should upload my apple push notification api to hackage or not. It uses the new HTTP2 protocol, and afaict the available apn libraries all use the legacy api. What do you think?
11:06:23 <hc> OTOH, it's still at an early stage and I don't want to add yet another apn api to hackage...
11:06:49 <cocreature> hc: if you think it’s useful for others and you intend to develop it further and maintain it at least for some time, sure why not
11:10:44 <dsal> Saidahmad: what do you want out of programming?  Do you want to be a super elite hacker, or just don solve specific problems.
11:11:29 * dsal should part attention to meeting and not writing confusing stuff into phone
11:15:05 <Psybur|Work> Why cant I understand arrow notation ;_;
11:15:19 <Psybur|Work> Is there a fun tutorial like learnyouahaskell that covers it
11:15:34 <dsal> Which arrow notation?
11:15:49 <Psybur|Work> The one that's like an abstraction for monads
11:15:52 <Psybur|Work> ->
11:16:11 <cocreature> Psybur|Work: tbh the perhaps disappointing truth about arrow notations is that it’s _very_ rarely used
11:16:34 <Psybur|Work> cocreature, tell that to all the game engine code I'm groking through ;_;
11:16:52 <cocreature> Psybur|Work: ah frp?
11:17:14 <Psybur|Work> Maybe grok is not what I thought it meant
11:17:19 <Psybur|Work> slogging through D;
11:17:44 <Psybur|Work> I started out with FRP but then the code scared me away, then just looking through anything I'm just floored haha
11:17:51 <Saidahmad> dsal: oh man just basic stuff for now, like if im able to make a really good website or an app for a phone and all these things, im okay 
11:18:22 <Psybur|Work> https://github.com/LambdaHack/LambdaHack/blob/master/Game/LambdaHack/SampleImplementation/SampleMonadClient.hs
11:18:26 <cocreature> the only thing I use "Arrow" for is "&&&" and "***" and I only use that on the most boring arrow instance (->)
11:18:36 <hc> cocreature: okay, thanks!
11:18:54 <dsal> Saidahmad: Phone apps are typically built with specific toolkits for phone apps.  I'm not sure how practical haskell is for writing an app for android, for example.  But Java is super painful, so who knows.
11:19:00 <cocreature> Psybur|Work: that code doesn’t use arrow notation?
11:19:41 <Psybur|Work> oh whoops are those just lambdas
11:19:53 <cocreature> which line are you referring to?
11:20:00 <Psybur|Work> I think they are just lambdas xD
11:20:05 <cocreature> I might have missed something
11:20:08 <dsal> Saidahmad: There are languages that dominate specific domains.  iPhone and Android apps are rarely written in the same language.  iPhone apps and web apps aren't written using the same language.  The ways you think about solving problems varies a lot by language as well.
11:20:36 <dsal> What is this 'go' thing I've seen in a few places?  Is there anything special in haskell that's called 'go' ?
11:20:44 * dsal programs in go, where 'go' is a keyword
11:21:03 <dmj`> dsal: what makes you ask
11:21:04 <MarcelineVQ> usually it's just a helper function to make loops
11:21:08 <cocreature> dsal: there is nothing special about it in haskell
11:21:28 <Saidahmad> dsal: i see 
11:21:34 <mud> "go" is a somewhat popular name for yeah, little internal helper functions that are in the scope of some other function.
11:21:34 <Tuplanolla> It's a name for a function for making the pun `let go`, dsal.
11:21:35 <dsal> I've just seen the word 'go' in a few times and wasn't sure if it meant something, or was just a local identifier name.
11:21:46 <Psybur|Work> https://stackoverflow.com/questions/5844653/haskell-why-the-convention-to-name-a-helper-function-go
11:21:52 <ab9rf> i used "go" in a parser once as a convenience function to emit a token and change state, iirc
11:21:53 <Psybur|Work> dsal, ^
11:22:23 <dsal> I've not written a parser in a long time.  I'm going to need to do that for some of the projects I've got coming up.  I hope it's not going to make me sad.  :)
11:23:13 <dsal> Psybur|Work: I may have seen that in a groggy stupor.  So go ~= loop (trying to remember where loop was a thing...)
11:23:41 <Saidahmad> dsal: haha what if i want to be a super elite hacker then like you asked earlier
11:24:28 <dsal> Saidahmad: haskell will teach you a lot of really nice fundamentals about problem solving that you can apply when working in other paradigms.  Though you won't really understand programming until you've touched on quite a few.
11:24:52 <Tuplanolla> Other favorites are `f`, `g`, `rec`, `loop`, `again` and `more`, dsal.
11:25:19 <Psybur|Work> One that really tickled my fancy was s t a b as arguments
11:25:28 <ab9rf> i've used 'whatever'
11:25:32 <Tuplanolla> The goal is to make your program read like a poem.
11:25:41 <Psybur|Work> Or a cry for help
11:25:56 <dsal> Saidahmad: i.e., the majority of programmers I've encountered in the wild know one language, and they suffer greatly from this (but don't know any better).  It's painful because it really limits the ways you can solve problems to what you've seen before in a really small world view.  :)
11:25:57 <ab9rf> once i thin ki used 'dat'
11:26:02 <ab9rf> as in "where dat"
11:26:06 <Tuplanolla> I've seen `gr a b` for graphs too.
11:26:20 <dsal> gr a b is pretty logical.
11:26:32 <ab9rf> dsal: i can't imagine knowing only one language
11:27:03 <Saidahmad> dsal: i see, one more question, what level of math is required to be a good programmer?
11:27:07 <dsal> I used to interview java programmers (that's a thing).  They know java only.  I kind of halfass did java at work and had no trouble stumping these people in interviews in their primary/only language.  That made me really sad.  :(
11:27:16 <dsal> Saidahmad: Nah, I'm terrible at math.
11:27:17 <Psybur|Work> learning about haskell has improved my scala but it has also removed my sanity
11:27:30 <Tuplanolla> None, but more is always better, Saidahmad.
11:27:31 <ab9rf> Psybur|Work: sanity is overrated
11:28:13 <Tuplanolla> (This answer is universal.)
11:28:36 <Saidahmad> thank you all
11:28:55 <Psybur|Work> Tuplanolla, I'm pretty sure that php breaks your rule
11:29:01 <Saidahmad> so how much time do i need to learn one language?
11:29:09 <dsal> Saidahmad: some programming requires a lot of math. Some needs none. Depends on the problem you're trying to solve.
11:29:12 <ab9rf> Saidahmad: depends on what you mean by "learn"
11:29:22 <dsal> Saidahmad: depends on how many you know. :)
11:29:28 <ab9rf> that too
11:29:35 <Tuplanolla> I meant that regardless of your goal, knowing more math is always beneficial, Psybur.
11:29:38 <Saidahmad> so many variables
11:29:45 <ab9rf> most languages have variables
11:29:53 <ab9rf> some have more than others
11:30:17 <infandum> I'm hesitant to alter ob-core.el, but I need to do something. I just want to have variables at the end, rather than the beginning of the block. It seems easy to do, edit "org-babel-expand-body:generic" to have var-lines after the body, but how can I ensure this continues throughout upgrades etc.?
11:31:54 <ab9rf> more meth, on the other hand, is generally not helpful
11:31:56 <infandum> woops, wrong subreddit.
11:32:08 <infandum> whoops, wrong chat type
11:32:16 <ab9rf> infandum: are you lost?
11:32:23 <infandum> ab9rf: It seems so
11:33:18 <Saidahmad> ab9rf: meth is never helpful lol
11:35:56 <Saidahmad> thank you dsal tulpanolla and ab9rf , i will go make some digging around about programming
11:36:04 <Ankhers> If I have 2 `Maybe Double`, how could I get the greater of the two without using nested case expressions?
11:36:28 <cocreature> > (>) <$> Just 1 <*> Just 2
11:36:30 <lambdabot>  Just False
11:36:32 <cocreature> eh
11:36:36 <cocreature> > max <$> Just 1 <*> Just 2
11:36:38 <lambdabot>  Just 2
11:36:38 <dminuoso> So this might seem like a silly question, but I suddenly got interested in figuring out why Complex is a Functor, and was wondering what exactly fmap does in it
11:36:43 <Ankhers> cocreature: Thanks!
11:36:49 <glguy> > max <$> Just 1 <*> Nothing
11:36:52 <lambdabot>  Nothing
11:37:06 <Psybur|Work> The plot thickens
11:37:11 <Ankhers> That doesn't work how I would have expected.
11:37:22 <jared-w> <*> short circuits on Nothing
11:37:58 <Ankhers> Right.
11:37:58 <glguy> > maximumOf (each.each) [Just 1, Nothing, Just 10]
11:37:59 <jared-w> Just because we want max to magically treat Nothing like 'lowest possible number' doesn't mean it is :)
11:38:01 <lambdabot>  Just 10
11:38:05 <glguy> > maximumOf (each.each) (Just 1, Nothing)
11:38:08 <lambdabot>  Just 1
11:38:09 <cocreature> > let x = Just 1; y = Nothing in max <$> (x <|> y) <*> (y <|> x)
11:38:11 <lambdabot>  Just 1
11:38:26 <jared-w> :t maximumOf
11:38:28 <lambdabot> Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
11:38:30 <Saidahmad> dsal: one last question, which language do you recommend i start with? python? java? haskell? or any other?
11:38:43 <cocreature> jared-w: who doesn’t love those beautiful lens type signatures :)
11:38:49 <t7> :hoogle [a] -> [b] -> (a -> b -> c) ->  [c]
11:38:51 <Tuplanolla> It's just a strict, uniform pair, dminuoso.
11:38:52 <Psybur|Work> Saidahmad, c
11:38:53 <Psybur|Work> :D
11:38:58 <t7> zipWith i think
11:39:03 <jared-w> Saidahmad: it really depends on what you want to do. I personally think Haskell or another FP language is my favorite to start with because it doesn't corrupt you the same way other languages do
11:39:04 <Tuplanolla> There's only one choice for the `Functor` instance.
11:39:09 <Ankhers> I think I will just stick with nested case expressions for now. Thanks for the help everyone!
11:39:15 <jared-w> So you can learn more of the programming rather than learning the language
11:39:24 <ab9rf> :t zipWith
11:39:26 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:39:45 <[exa]> Saidahmad: after you learn some language, remember that it's always useful to know assembly to see what the CPU actually has to do
11:39:46 <Saidahmad> jared-w: what do you mean by corrupt?
11:39:57 <jared-w> Then I'd learn a language like C to understand low level memory and imperative programming. Once you know C you can pick up Java or any other imperative language instantly
11:40:08 <dminuoso> Tuplanolla, okay that didn't have the result I was hoping for! :-)
11:40:27 <jared-w> Saidahmad: People always mention how learning Haskell makes them better programmers. It's because it forces you to think more about correctness, getting things done the proper way, thinking about your programs in a purer manner, and instilling discipline into your writing
11:40:34 <[exa]> also, C-assembly connection is a pretty good start for understanding compilers
11:40:47 <jcbell> Saidahmed: Scheme is also an excellent choice https://mitpress.mit.edu/sicp/full-text/book/book.html
11:41:04 <jared-w> C, on the other hand, lets you be very loose and lazy with your code. Java is even worse and Python is the worst of all 3 for letting you just "fuky around" until it compiles and sorta works
11:41:04 <dminuoso> jared-w, uh from my experience the bridge from C to Java is hard. Going from no abstractions to a language full of bizarre and strange abstractions is hard.
11:41:14 <Psybur|Work> I remember using the PEP/8 system for learning assembly in college. I'd recommend it
11:41:28 <ab9rf> t7: you want flip . flip zipWith :)
11:41:45 <dminuoso> Are there interesting functors to look at? I'm trying to look for one that embeds structure that does _not_ have some list/tuple kind of notion.
11:41:53 <jared-w> dminuoso: Going from C to Java is pretty easy, going from C to Enterprise Java is pretty difficult. But learning the core language is very easily done since it's so similar. All that remains after that is to grok Java's absurd bastardization of OOP and "design patterns"
11:42:28 <mud> dminuoso: ((->) e)  and Proxy I guess?
11:42:29 <jared-w> (which is why Java programmers know Java and can't really program in anything else. They never learned how to really program, they just learned the cookie cutter design patterns and blind OOP nonsense)
11:42:42 <Psybur|Work> jared-w, do you happen to have an article on these bastardizations? I'm curious
11:42:44 <ab9rf> i'd avoid java entirely unless you want to be a code monkey
11:42:57 <ab9rf> you won't learn anything from it
11:43:10 <[exa]> dminuoso: not quite "hard" but "repulsive" I guess :]
11:43:12 <Saidahmad> [exa] ok, thanks
11:43:30 <dminuoso> [exa], well my point is just that very little knowledge or understanding is transferrable.
11:43:46 <dminuoso> C to C++ seems far more natural
11:43:52 <[exa]> dminuoso: yeah, java is about something completely else :]
11:43:57 <ab9rf> the java language is really easy if you know C and at elast one OO language, but the java _environment_ is a cluster
11:44:10 <Tuplanolla> The value of C is teaching you to read technical standards, because your program working today has nothing to do with it still working tomorrow.
11:44:20 <dminuoso> Tuplanolla, if only.
11:44:31 <Tuplanolla> In my experience most students struggle with the idea of programming for an abstract computer that doesn't even exist.
11:44:33 <jared-w> The value of C is teaching you to fear the words "Undefined behavior" ;)
11:44:36 <ab9rf> java is saturated in boilerplate code and has a VERY complicated ecosystem 
11:44:38 <mud> Tuplanolla: Except you have no idea if you did it wrong, which is horrible for learning.
11:44:45 <dminuoso> The sheer amount of folks coming into ##c for years, still not understanding what UB means or being incapable of reading the standard, which is simple enough to be considered the best learning resource..
11:44:49 <shapr> Saidahmad: you could also spend one day on each of a bunch of languages and see which one clicks best for you?
11:45:06 <ab9rf> dminuoso: UB?
11:45:09 <shapr> Yeah, java wasn't terrible until J2EE
11:45:11 <shapr> undefined behavior
11:45:14 <ongy> uncefined behavior
11:45:15 <ab9rf> ah
11:45:20 <ongy> the one thing that allows a lot of optimization
11:45:34 <dminuoso> ongy, partially. a lot of UB is also about not putting too much burden on the implementation
11:45:34 <ab9rf> yeah, i know the concept, just didn't recotgnize the initialism
11:45:35 <ongy> but also some rather odd things. And most people don't know they are violating one rule or the other
11:45:59 <Tuplanolla> Strict aliasing for breakfast.
11:46:05 <dminuoso> Indeed. That is a wonderful example.
11:46:14 <dminuoso> Its almost impossible to diagnose in any non-trivial case
11:46:17 <ab9rf> i've written articles about how C's sequence point rule allows for broader optimization
11:46:29 <shapr> My favorite broad overview of undefined behavior is the PoC||GTFO series: https://www.alchemistowl.org/pocorgtfo/
11:47:00 <dminuoso> shapr, I didn't appreciate the complexity of what UB really entails until I implemented C myself and started writing a kernel.
11:47:12 <dminuoso> Until then you are happy as long as it compiles and you get "kind of the right output"
11:47:38 <shapr> I'm not smart enough to write C and C++, that's why I stick with Haskell
11:47:47 <jared-w> Then it's like "oh god, how did anything ever get done in C with UB?" and you just kinda walk around with a ಠ_ಠ face on for the rest of your life
11:47:51 <Psybur|Work> ab9rf, what you think Spring is complicated? ;D
11:48:00 <shapr> or, with more detail.. I don't think I have enough short term memory / stack space to write C and get it right.
11:48:10 <dminuoso> jared-w, the sad thing is, Rust shows that it's easy to maintain the same amount of abstraction that C++ has, without any of the pitfalls.
11:48:16 <shapr> dminuoso: right!
11:48:16 <[exa]> dminuoso: writing two layers correctly in one person is a good skill. :D
11:48:40 <shapr> so I think I may pick up Rust next and use that whenever I need to write C or C++
11:48:47 <jared-w> dminuoso: Well, to be fair, Rust is taking advantage of like 25 years of PLT and PL research...
11:48:58 <dminuoso> jared-w, oh yeah. I dont blame C, considering where it comes from.
11:49:03 <ab9rf> Psybur|Work: rube goldberg ain't got nothing on a Java-based framekwork :)
11:49:06 <shapr> yeah, but when can we get rid of C?
11:49:09 <Saidahmad> @shapr hmm, one day is kind of short i think, and plus since i know nothing about these languages i wont be in a position to judge or determine whether a language has "clicked" with me
11:49:09 * lambdabot slaps hmm, one day is kind of short i think, and plus since i know nothing about these languages i wont be in a position to judge or determine whether a language has "clicked" with me
11:49:13 <Tuplanolla> Rust still gets integer overflow wrong, doesn't it?
11:49:17 <dminuoso> shapr, you can just start writing new projects simply.. not in C?
11:49:19 <jared-w> If anything, Rust shows that "compile time memory safety" is not the golden bullet for languages to be safe; it only gets you part of the way there.
11:49:26 <jared-w> Tuplanolla: what do you mean?
11:49:31 <dminuoso> jared-w, though modern C++ is extremely safe already.
11:49:33 <EvanR> that command is... wait what
11:49:37 <shapr> Saidahmad: that's a good point
11:49:43 <dminuoso> When I write modern idiomatic C++ its almost impossible to get memory errors.
11:49:58 <Tuplanolla> It should be trapping unless explicitly disabled, jared-w.
11:49:58 <Xal> modern ""idiomatic"" C++ is disgusting
11:49:59 <Saidahmad> soo C it is then?
11:50:16 <dminuoso> Xal, heh, in a way its true. It's not as widely spread as I would hope.
11:50:17 <jared-w> True, you just have to memorize 10 books worth of information and then write stuff so unreadable it makes Perl look beautiful :p
11:50:18 <shapr> dminuoso: for me, it feels like Haskell is a huge pile of crutches where everything gets checked for me, so I can skip the mental work required to write good C / C++
11:50:28 <Xal> trying to make C++ safe feels so warty and unwiledy
11:50:45 <dminuoso> shapr, Im only beginning to learn Haskell. Everything Im learning right now shows that if I was to write another Kernel, it would be in C++ or Rust again.
11:50:46 <shapr> 'discipline is freedom' or something like that
11:50:54 <dminuoso> shapr, so I think it still depends on the domain
11:50:58 <shapr> dminuoso: have you seen HaLVM, the Haskell unikernel?
11:51:11 <jared-w> HaLVM is... interesting
11:51:15 <ab9rf> dminuoso: i've run into people who insist that you can write memory-safe C++ if you just "follow RAII correctly"
11:51:16 <Psybur|Work> According to slant.co, haskell is or was recently the #1 language to build a 2d video game. Do you guys agree?
11:51:20 <shapr> I like HaLVM
11:51:36 <dminuoso> shapr, I just started with Haskell a week ago. I know what a Functor is, but a Monad is still shrouded to me.
11:51:36 <EvanR> Psybur|Work: agree
11:51:39 <jared-w> dminuoso: check out the language "Habit" -- it's a Haskell-based language designed for low level programming like kernels
11:51:40 <Xal> ab9rf: any "memory-safety" that relies on humans checking the code isn't safe at all
11:51:41 <dminuoso> shapr, so I wont bother to look at it.
11:51:42 <ongy> jared-w: looking at the repo, they are trying to make HalVM implement a basic posix layer, to run cbits
11:51:51 <ab9rf> dminuoso: i suspect that they're mainly using some sort of library that is effectively a garbage collector
11:51:57 <shapr> dminuoso: that's a sensible choice, are you using haskellbook.com for learning?
11:52:04 <Psybur|Work> EvanR, can you show me the source for a 2D game written in haskell that you'd use to back that up?
11:52:11 <dminuoso> shapr, went through the entire free sample, absolutely hated it.
11:52:20 <EvanR> i could
11:52:20 <shapr> dminuoso: ah, what are you using to learn then?
11:52:21 <dminuoso> Doesn't have the level of detail, and it seems far too much targeted at beginners
11:52:28 <jared-w> Weird, I liked haskellbook a lot
11:52:29 <EvanR> but i dont have to to back up "i agree with that" :)
11:52:35 <shapr> yeah, haskellbook works well for me
11:52:41 <jared-w> It does have a ton of detail in it and it quickly ramps up to be not so targeted at beginners
11:52:43 <dminuoso> shapr, the resources from https://github.com/bitemyapp/learnhaskell is what Im currently inspecting
11:52:47 <ab9rf> i think i used haskellbook at some point
11:52:48 <Psybur|Work> EvanR, curses, I'm looking for a good example of a 2D game since I too think haskell would be good for it
11:52:52 <dminuoso> and they feel far more to my taste, I want concise but accurate information.
11:52:58 <Psybur|Work> But it's not proving easy
11:53:02 <jared-w> Chapter 17ish gets you to Monads and it goes all the way through to chapter 31
11:53:03 <shapr> dminuoso: what about the Gentle Introduction? have you seen that?
11:53:13 <jared-w> shapr: the famously un gentle introduction? :p
11:53:13 <EvanR> Psybur|Work: https://github.com/nikki-and-the-robots/nikki
11:53:19 <shapr> dminuoso: https://www.haskell.org/tutorial/
11:53:20 <MarcelineVQ> EvanR, Psybur|Work: https://www.youtube.com/watch?v=GaorHAlUkVs may interest either of you, it's not a link to a game though
11:53:23 <ab9rf> dminuoso: don't shortcut the learning process. unless you've used other functional or declarative languages, haskell is a major cheese move.
11:53:24 <EvanR> that just proves you could sell a game written in haskell
11:53:24 <shapr> @quote brick
11:53:25 <lambdabot> Cale says: Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
11:53:27 <shapr> @quote brickbat
11:53:27 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
11:53:36 <dminuoso> shapr, I was scared away by the date stamp.
11:53:46 <shapr> dminuoso: if you want detail, that might be worth trying
11:53:56 <shapr> dminuoso: alternatively, ask lots of questions here?
11:54:00 <dminuoso> ab9rf, I have decent experience in C++ with templating and modern pure functional JavaScript, so a lot of basic concepts are already there.
11:54:16 <dminuoso> at least I hope so
11:54:17 <shapr> I'm really glad the monoid -> functor -> applicative -> monad approach is around for learning
11:54:18 <ab9rf> dminuoso: no, they're not
11:54:25 <crobbins> dminuoso: just look at the definition of Monad, it basically defines two methods, `return` and `>>=` (bind). write code that uses monads, don't worry about fully understanding it just yet, it'll make sense as you use them. you won't need to define your own Monads for a while probably
11:54:44 <dminuoso> crobbins, yeah probably. I mean I understand what it does conceptually perfectly fine. :-P
11:54:45 <shapr> I started learning Haskell about the same time this irc channel was created, there weren't many resources
11:55:00 <Psybur|Work> My brain just melts reading this ;_; Is there hope for me? https://github.com/nikki-and-the-robots/nikki/blob/master/src/Top/Main.hs
11:55:02 <EvanR> the definition of Monad defines 2 methods, and assumes 3 other methods
11:55:05 <ab9rf> dminuoso: don't assume you know anything yet.
11:55:14 <EvanR> so 5 methods, and like 10 laws
11:55:30 <shapr> EvanR: yeah, monad is an algebraic abstraction, that's mind breaking after using objects for a pile of years
11:55:55 <ab9rf> your first three or four attempts to understand monads will be wrong
11:55:58 <MarcelineVQ> Psybur|Work: yes
11:56:05 <EvanR> for me it wasnt so bad because my mind had been breaking for years trying to use objects for everything
11:56:09 <dminuoso> ab9rf, I have a feeling that it's an abstraction that has a similar "oh well, this is a useful abstraction" similar to Functors.
11:56:12 <shapr> once I got monads, it was "oh, that's all?"
11:56:14 <dminuoso> *similar feeling
11:56:17 <EvanR> its like a releif
11:56:20 <EvanR> relief?
11:56:21 <shapr> dminuoso: yes exactly!
11:56:24 <jared-w> Psybur|Work: that code is fairly complex stuff
11:56:47 <jared-w> I wouldn't worry about it breaking your brain, it's definitely more complex than a lot of "real world code" out there
11:57:06 <Psybur|Work> But this is supposed to be an example of Haskell being the best language for 2d games! xD
11:57:08 <jared-w> (and also suffers from a lot of semi poor design choices, in my opinion...)
11:57:13 <EvanR> the only reason Monad isnt called a design pattern is... you dont have to copy and paste all the code that does monads. its a library
11:57:31 <jared-w> Also people get scared calling stuff design patterns because of Java connotations :p
11:57:51 <EvanR> Psybur|Work: that i cant guarantee by lookign at nikki's code
11:57:57 <shapr> all abstractions are just useful conventions
11:58:21 <Xal> lisp has taught me that 90% of the time the only three abstractions I need are lists, symbols, and functions
11:58:22 <EvanR> Psybur|Work: a lot of times, game code in haskell appears to cut a lot of corners, and doesnt attempt to be "pure functional" or declarative as such
11:58:24 <ab9rf> design splattern
11:58:37 <jared-w> EvanR: I was the same way. OOP never meshed for me at all and FP is so much more comfortable for my brain
11:58:55 <jared-w> Xal: and homoiconic macros? :p
11:59:01 <Psybur|Work> EvanR, have you encountered any haskell game code that you read and thought "Damn son, I'd hit it"?
11:59:10 <dminuoso> ab9rf, what I said about knowing was just in CT sense. Bizarrely that doesn't help me at all.
11:59:11 <EvanR> play the game?
11:59:14 <EvanR> lol
11:59:20 <shapr> yeah, I do think I lack the large mental stack space good OOP devs have, and that's why OOP frustrates me, and C and C++ are so hard for me to write.
11:59:21 <EvanR> who reads the code to decide to play a game
11:59:28 <Psybur|Work> Im not looking for a fun game
11:59:32 <ab9rf> dminuoso: category theory may help understand haskell, but it might not either :)
11:59:36 <Psybur|Work> Im looking for an example so I can learn to make my own game
11:59:45 <EvanR> did you see the link i posted
11:59:47 <jared-w> dminuoso: CT helps with learning some stuff in Haskell, but it's important to remember that Haskell is inside a category 'Hask' and there's a lot of stuff you can't properly translate from CT to Haskell
11:59:56 <dminuoso> ab9rf, it helped me instantly grasp functors. :)
12:00:07 <shapr> Is raincat open source?
12:00:08 <jared-w> shapr: it's not the mental stack space, it's just trying to shoehorn stuff into stupid abstractions
12:00:12 <shapr> http://bysusanlin.com/raincat/
12:00:17 <Psybur|Work> EvanR, yes, and I posted a source file from your link stating that it melted my brain xD
12:00:17 <ab9rf> dminuoso: i learned haskell before i knew any CT so i can't comment
12:00:27 <dsal> Saidahmad: sorry, was at lunch. Doesn't matter really what you start with. Just start.  
12:00:29 <ab9rf> i still don;t raelly undrtand any category theory
12:00:38 <jared-w> "Oh this is a builder pattern, that is a super class of this and this other thing is a class of that other thing and like don't think too hard about it..."
12:00:38 <dminuoso> ab9rf, but mostly because languages like Ruby, JavaScript and C++ have the map concept already, and a functor is just the general abstraction of the same idea. :)-
12:00:51 <EvanR> Psybur|Work: so youre looking at some IO code
12:01:00 <EvanR> without knowing much haskell?
12:01:09 <EvanR> probably not the best intro to haskell
12:01:15 <ab9rf> EvanR: hahah
12:01:20 <Psybur|Work> I learned me a haskell, but I guess thats not good enough
12:01:33 <geekosaur> it's generally not
12:01:43 <EvanR> that file contains a bunch of thread stuff and exception stuff. not that bad and i dont agree with all the style choices here, but 
12:01:44 <Saidahmad> dsal: thank you, i will just go with c
12:01:52 <jared-w> It's why I dislike that book strongly and rant about how we need to remove it from the r/haskell sidebar every now and then
12:01:57 <EvanR> really not what haskell is about
12:02:03 <dminuoso> ab9rf, regarding your "shortcuts" comment. I have been programming a React application for 6 months now, the concept of declarative and pure functional parts has been sipping in for so long, that I understand the values.
12:02:25 <dsal> Saidahmad: Regarding corruption -- it's a good point.  It's why I asked about your timeline.  If you learn haskell, you can learn a lot of really great things, but you won't be able to put them together into a phone app really quickly (and not necessarily directly into a web app)
12:03:25 * hackagebot newtype-generics 0.5.0.1 – A typeclass and set of functions for working with newtypes, with generics… – https://hackage.haskell.org/package/newtype-generics
12:03:25 * hackagebot pandoc-citeproc 0.11 – Supports using pandoc with citeproc – https://hackage.haskell.org/package/pandoc-citeproc
12:04:43 <dminuoso> shapr, how applicable is the gentle introduction nowadays?
12:04:55 <dminuoso> Will I have to revisit some or a lot of topics when Im done?
12:05:07 <shapr> dminuoso: depends on how deep you want to go
12:05:21 <shapr> but there are other resources if you get into implementing your own spineless tagless g-machine and all that
12:05:44 <dminuoso> A what?
12:06:32 <Saidahmad> dasl: i see
12:06:40 <Saidahmad> dsal*
12:07:39 <dsal> Saidahmad: How did you end up here, btw?  Haskell is a pretty great language, but has managed to remain somewhat underground for a long time now.
12:07:58 <EvanR> dminuoso: a gentle introduce really helped me when i was learning, but what helped more was, afterward, trying to write code
12:08:09 <EvanR> when something didnt make sense, i asked IRC :)
12:09:16 <Saidahmad> dsal: ycombinator.com
12:09:34 <Saidahmad> i saw someone recommend it there
12:11:16 <dsal> Saidahmad: Well, you can start your way through http://learnyouahaskell.com/ -- haskell doesn't really give you a lot you have to "unlearn" when you go elsewhere.  For the most part, you just end up with things you miss.  Some languages teach you really awful habits.  It's way harder to unlearn those than to learn new ways.
12:13:21 <Saidahmad> dsal: i see, thank you very much
12:15:11 <jared-w> @where learnhaskell
12:15:11 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:15:18 <jared-w> (I prefer this link for starting out over LYAH)
12:15:56 <dsal> "DO NOT INSTALL HASKELL PLATFORM"
12:15:59 <dsal> I'm doing it all wrong!
12:16:22 <johnw> note that that book is not without its opinions
12:16:27 <johnw> not everyone "believes in stack"
12:17:02 <dsal> It wasn't obvious to me how to get stack running on all my machines at home.  haskell-platform was universally available, but in different versions.
12:17:44 <bollu> mpickering ping
12:18:02 <penteract> I think the hardest hing about learing to program is installing (and running) the compiler
12:18:57 <machinedgod> Hi all... would someone care to help me with a prorotype code that has some indexed types in 
12:19:00 <machinedgod>                      it? Its maybe one page long and I am stuck on recursion/pattern matching. This is the code: 
12:19:03 <dsal> This is why old Sun machines were the best.  They gave you a forth compiler/repl before even booting the OS.
12:19:09 <machinedgod> Hi all... would someone care to help me with a prorotype code that has some indexed types in 
12:19:12 <machinedgod>                      it? Its maybe one page long and I am stuck on recursion/pattern matching. This is the code: 
12:19:26 <machinedgod> I'm really sorry for retarded posting... my c/p skills are 0
12:19:29 <johnw> dsal: Sun machines running SunOS 4 were strangely good
12:19:52 <dsal> Yeah.  My mail servers was 4.1.4.  Had working ocaml back when java was "run everywhere"
12:20:12 <machinedgod> Anyway - this is the code, if someone is willing: http://lpaste.net/357750
12:22:44 <eschnett> machinedgod: i think this is called “polymorphic recursion”, and it works fine in haskell
12:23:01 <eschnett> machinedgod: you write a recursive routine that calls itself explicitly
12:23:36 <eschnett> machinedgod: do you have a sketch of such a recursive routine that maybe leads to a type error?
12:24:03 <dsal> How is there a two hour video tutorial for stack?
12:24:21 <MarcelineVQ> dsal: because no one reads the goddamn manual eheh
12:24:39 <dsal> Is there enough to know that would require a feature length film?  That's like, a lot.
12:24:52 <machinedgod> Hi eschnett! I am using Justin Le's tutorial on statically typed neural networks as a guide - he uses type level naturals to merge layers together. However, I am not sure how would polymorphic recursion look like so I don't know if he's using it?
12:25:13 <eschnett> machinedgod: do you need to give an explicit type signature for “attachShaders”? what if you change the “pu” there — that’s currently the same as the “pu” of the enclosing function; renaming this to “pu1” might do the trick.
12:25:25 <MarcelineVQ> Not if you can read :> it's a comprehensive vid though
12:25:28 <eschnett> machinedgod: that’s because you are using scoped type variables.
12:26:08 <machinedgod> eschnett: If I remove the signature, I get 'type variable (skolem, rigid) would escape its scope'
12:26:46 <MarcelineVQ> dsal: https://docs.haskellstack.org/en/stable/GUIDE/
12:26:49 <machinedgod> eschnett: I was trying to use scoped type variables to bring pu pi po into scope in the recursive function and make it work somehow, but I failed
12:27:45 <eschnett> machinedgod: if the type of “pu” changes during recursion, you can’t keep it fixed
12:28:01 <dsal> MarcelineVQ: I'm still trying to get a bit of an idea what stack is.  I'll see if it gives me better results on this machine that didn't have great results.
12:28:33 <MarcelineVQ> stack is a tool for reproducable builds of a particular project, if your project builds now it should build a year from now
12:28:42 <machinedgod> eschnett: That's actually enlightening! I could probably make a type become an inverse of what it was upon construction!
12:29:04 <MarcelineVQ> that's what it's for, though people tend to use it for a lot more than that anyway
12:29:18 <dsal> All I really want is ghc, ghci, cabal.  I guess reproducing builds isn't a terrible idea.  I don't know how awful compatibility is with haskell, though.
12:30:59 <penteract> To understand stack, don't use it until you need it. (That was my route anyway)
12:31:12 <wayne> dsal: i told people to use stack in a recent workshop
12:31:17 <wayne> it worked wonders to get people up and running
12:31:30 <wayne> able to download + install libraries in one fell swoop
12:31:36 <dsal> It might be good on these machines that don't agree on the version.
12:31:43 <dsal> Assuming stuff can build.
12:32:48 <Psybur|Work> dir
12:32:50 <Psybur|Work> ops
12:33:06 <Psybur|Work> Wrong window ^_^;
12:33:18 <cheater> is there a common function that does this?   foo = case bar of { Nothing -> []; Just baz -> [quux] }
12:33:20 <penteract> stack is good, but if you're first learning to program, you probably don't need to install packages and you may well be confused by the command line
12:34:09 <dsal> My first useful haskell program used a few packages.
12:34:31 <dsal> My less useful programs made it hard for me to remain interested.
12:35:01 <sm> anybody starting out with haskell will need to install packages pretty quick
12:35:04 <EvanR> soon you be sucked into the world of useless programming
12:35:29 <EvanR> see also SPJ "haskell is useless" haha
12:36:13 <srhb> cheater: It's completely unclear what you want that to do since you left out any arguments. For instance, how does quux suddenly arise?
12:36:24 <MarcelineVQ> cheater: possibly    maybe [] (const [quxx]) bar   or     const quxx <$>  maybeToList bar
12:37:06 <srhb> I suspect they may simply mean maybe [] (:[])
12:37:29 <MarcelineVQ> that'd be nice and easy,  maybeToList
12:37:35 <dsal> const is odd...  is there anything in ghci that will tell me what something is for vs. what it does?
12:37:47 <srhb> dsal: :t !
12:37:58 <geekosaur> that's what it does, thet want actual docs
12:37:58 <dsal> Yeah, I mean, :t tells me that, but not why it exists.
12:38:01 <geekosaur> and the answer is no
12:38:17 <geekosaur> hayoo/hoogle if your friend here
12:38:20 <geekosaur> *is your
12:38:24 <MarcelineVQ> :t  :info  docs http://hoogle.haskell.org/?hoogle=const
12:38:26 <lambdabot> error: parse error on input ‘:’
12:38:32 <MarcelineVQ> shush dear
12:38:42 <dsal> Docs are slightly better.     const x is a unary function which evaluates to x for all inputs.
12:38:43 <cheater> srhb: quux is defined elsewhere.
12:38:47 <dsal> I got that from :t  heh
12:38:58 <srhb> cheater: Then what MarcelineVQ said.
12:39:02 <Saidahmad> dsal: is there anyhwhere else i could contact you if i have some questions about programming, if you don't mind
12:39:23 <cheater> :t maybeToList
12:39:24 <dsal> Saidahmad: I'm always on irc.  You can pm me or whatever.
12:39:25 <lambdabot> Maybe a -> [a]
12:39:50 <dsal> :info is nice
12:39:54 <Saidahmad> ok thank you dsal, good night
12:40:15 <dsal> Saidahmad: Sleep well.  When you become a programmer, you may stop doing that altogether.
12:40:47 <Saidahmad> hahaha 
12:40:57 <Saidahmad> bye :D
12:45:13 <dsal> What's a good thing to look at for playing around with directory contents?  I'd ideally like   FilePath -> [(FilePath, FileStatus)] or something.  I found a thing that'll get me [FilePath], but then I have to go back and stat all the things.
12:47:20 <dsal> Wow, I just realized this program I want to write is basically a thing I did in ocaml in 2004.  Apparently I just aged.
12:48:26 <srhb> dsal: Sounds like an excellent time to learn functors! ;-)
12:49:05 <dsal> Yeah, I was reading about functors this morning.  Makes a lot more sense now that I have a bit of context.  heh
12:49:17 <dsal> Just wondering if there's a good package for dealing with the directory/file parts.
12:49:30 <dsal> (or if I have it)
12:49:43 <srhb> dsal: I don't know exactly what you want "done for you"
12:50:30 <dsal> Well, I have System.Posix.Files and System.Posix.Directory -- is that the right start?
12:50:42 <srhb> dsal: Sounds like the right modules, yeah.
12:50:49 <dsal> OK.  That's good, then.
12:51:49 * hackagebot choice 0.2.2, geoip2 0.3.0.0, sparkle 0.6
12:51:49 * hackagebot  → https://hackage.haskell.org/packages/recent
12:51:53 <sm> that's posix specific, you've also got the more general http://hackage.haskell.org/package/directory 
12:52:11 <sm> and http://hackage.haskell.org/package/filepath
12:52:22 <dsal> I think I looked at System.Directory first and got confused.  heh
12:52:56 <Psybur|Work> What do? I am trying to run something using stack and it's giving me a runtime exception about a dll missing but I can see that dll exists in .stack-work, but adding the path to the dll in my PATH doesnt make the error go away.
12:54:09 <dsal> sm: Is there a platform-agnostic stat?
12:56:01 <dsal> Oh weird.  System.Directory has some of what I need.
12:56:16 <jared-w> System stuff in general is always a bit weird
12:56:38 <dsal> Yeah, I think this will do it.
12:58:27 <dsal> Any good high level packages for doing TCP servers/clients?
12:59:52 <dsal> It'd be neat to bring up an APRS-IS server in haskell.  I wrote one in go I use at home.  It basically just broadcasts anything it receives on its client port to all of its connected clients.
13:00:11 <sm> a search on hackage will find them
13:00:43 <cocreature> dsal: what do hope that such a package will do for you?
13:01:02 <cocreature> I’m honestly not sure what a “high-level package for a tcp server” would look like
13:01:24 <dsal> I'd expect it to introduce me to some design concepts that are different from what I'm used to.  :)
13:02:02 <dsal> go ships with a package for doing old school text proto clients and servers that's decent.  You still do have to manage the accept loop, but how to spin off a concurrent client is pretty obvious.
13:02:40 <dsal> http://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html might be a good start.
13:05:30 <dsal> Yeah, searching from the top of hackage is more useful than what I was otherwise doing.  Thanks.
13:08:54 <jcbell> \quit
13:13:50 <johnw> dsal: by TCP server, I assume you don't want to use REST?
13:14:05 <dsal> Right.
13:14:16 <dsal> I'll want to do some of that stuff, too, but APRS-IS is a line protocol.
13:14:17 <johnw> so a protocol server, akin to SMTP or something?
13:15:01 <dsal> Yeah.  go has a package that makes SMTP, NNTP, etc... really easy to implement.   I wrote a quite useful NNTP server in it years ago.  But I'd like to do some APRS-IS stuff.
13:15:22 <johnw> I don't know about Haskell; Idris has some excellent examples of this sort of thing
13:15:59 <jackhill> dsal: I would be interested in APRS-IS stuff!
13:16:39 <dsal> My hopes aren't that high...  My go server's been running for years, but it doesn't do much.  It basically serves stuff around the house and lets me know if someone messages me.
13:16:54 <dsal> Parsing the messages might be fun. (it's probably not, APRS is horrible)
13:16:56 <t7> @pf \x -> [a]
13:16:56 <lambdabot> Maybe you meant: pl bf
13:17:02 <t7> @pl \x -> [a]
13:17:02 <lambdabot> const [a]
13:17:30 <t7> @pl maybe [] (\x -> [x]) (unify a b)
13:17:30 <lambdabot> maybe [] return (unify a b)
13:17:38 <t7> omg
13:17:43 <t7> i suck
13:20:11 <johnw> maybe empty return (unify a b) :)
13:20:36 <johnw> one of the cases where empty can be taken quite literally
13:21:36 * hackagebot eventsource-geteventstore-store 1.0.4, eventsource-store-specs 1.0.1, eventsource-stub-store 1.0.2
13:21:36 * hackagebot  → https://hackage.haskell.org/packages/recent
13:25:29 <MarcelineVQ> "<johnw> I don't know about Haskell; Idris has some excellent examples of this sort of thing" could you point me in that direction johnw?
13:26:35 <johnw> MarcelineVQ: https://github.com/edwinb/Protocols
13:27:21 <johnw> also, http://simonjf.com/2014/01/14/networking-in-idris.html
13:27:30 <johnw> which have an example specifically about a TCP protocol server
13:27:41 <MarcelineVQ> johnw: thank you
13:32:00 <t7> is there a function for   f [a, b] [1, 2] = [a, 1, b, 2] ?
13:32:19 <cocreature> :t zipWith ($)
13:32:20 <lambdabot> [a -> c] -> [a] -> [c]
13:32:23 <cocreature> ^ t7 
13:33:06 <t7> cocreature: wait you missed a comma
13:33:08 <MarcelineVQ> cocreature: missed a comma I think
13:33:18 <cocreature> oh
13:33:28 <iqubic> Can anyone see this?
13:33:31 <MarcelineVQ> same idea though, can you think of what would replace $ t7?
13:33:41 <t7> : ?
13:33:50 <iqubic> Testing testing testing. Am I connected to Freenode?
13:33:53 <MarcelineVQ> *what function would replace $
13:34:13 <geekosaur> > concat . transpose $ [[a,b], [1,2]]
13:34:15 <geekosaur> iqubic, yes
13:34:16 <lambdabot>  [a,1,b,2]
13:34:17 <t7> i can think of something but i would need a concat
13:35:59 <cocreature> there’s nothing wrong with using concat :)
13:59:18 <jared-w> > zipWith (++) ['a','b'] [1,2]
13:59:20 <lambdabot>  error:
13:59:20 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Char’
13:59:20 <lambdabot>      • In the expression: 'a'
13:59:27 <jared-w> hmm, whoops
13:59:40 * jared-w has been using too much python lately
14:02:03 <hpc> i had a thought today about database "create table" statements
14:02:33 <hpc> with a bit of adjustment, you could redesign the query syntax so things like foreign key relationships appear in the type position
14:02:41 <hpc> and then it reads a lot like a struct or data definition
14:02:59 <mizu_no_oto> jared-w: what are you trying to do?
14:03:39 <jared-w> mizu_no_oto: I was trying to zipWith [a,b] [1,2] and get [a,1,b,2] and had a brain fart with types for a second :p
14:04:06 <penteract> \quit
14:04:35 <jared-w> What's with the \quit?
14:04:59 <mizu_no_oto> Looks like they were leaving
14:05:31 <jared-w> Well yeah, I'm just curious what client is silly enough to use \quit and then send that message to the IRC server rather than catching it and just quitting...
14:05:55 <johnw> I think he mistyped it, and then retyped it with /
14:05:59 <geekosaur> more likely it's a user getting \ vs / backwards
14:06:15 <jared-w> could be. I just saw the same typo twice in like 5 minutes and thought it was odd 
14:06:43 <geekosaur> it's a common typo, because windows teaches users \ is the "normal" slash
14:07:13 <geekosaur> instead of weirdness IBM came up with ages ago
14:08:48 <jared-w> what was the weirdness IBM came up with?
14:09:43 <geekosaur> \ as a common slash character. was imported from EBCDIC
14:10:00 <geekosaur> ASCII actually had arrows for that and a few other characters originally
14:10:00 <jared-w> ahh right, fun times
14:10:00 <johnw> c:\Windows\System32
14:10:48 <jared-w> geekosaur: arrows are far too complicated, though /s
14:10:54 <geekosaur> (if anyone remembers trs-80 model 1, that's why it had arrows instead of characters like \; it conformed to an older ASCII spec)
14:11:17 <johnw> never noticed that on the TRS-80
14:11:44 <johnw> but then my neighbor owned it, and all I did was play games he had alreadey started
14:20:47 <trigone> hi! when writing a function which only expects integers superior to 0, is it better to use Int for easier compatibility (but that requires repetitive testing that its value is > 0) or to use the unsigned version (is it word32?), which will force whoever wants to use the function to cast their ints into unsigned ints?
14:21:07 <trigone> *integers superior or equal to 0, aka natural numbers
14:22:06 <jared-w> word32 is a machine word, not an integer
14:22:10 <hpc> you probably want Word
14:22:18 <hpc> which is unsigned Int
14:22:23 <trigone> hm ok
14:22:25 <hpc> or Natural, which is unsigned Integer
14:22:29 <johnw> I would go with Word, so the function can be total
14:22:40 <johnw> and errors are reported at use sites
14:22:42 <hpc> Natural isn't a peano nat type, it uses the same gmp functionality as Integer
14:23:03 <jared-w> why Word? Natural would be much better imo
14:23:13 <hpc> Word is faster most of the time
14:23:22 <hpc> well, all the time
14:23:29 <trigone> johnw: the functions need Maybe to be total anyway (cuz of other restrictions)
14:23:41 <johnw> well in that case
14:23:44 <hpc> if you need numbers greater than 2**(arch size) which would overflow otherwise, use Natural
14:23:46 <trigone> but it restricts the meaning of Nothing which is always better
14:23:48 <hpc> but that's a pretty rare case
14:23:52 <johnw> maybe use an Either to indicates the failure modes
14:25:27 <jared-w> The solution I'd normally think of would be just either using a wrapper function (which makes sure you always use a value greater than 0) or just checking for valid input.
14:25:42 <jared-w> https://hackage.haskell.org/package/base-4.10.0.0/docs/Numeric-Natural.html but since we have this...
14:26:25 <trigone> jared-w: a wrapper inside the function, or when using it?
14:27:40 <trigone> can we expect dependent types to one day be fully integrated in haskell? (including a smooth syntax)
14:28:25 <johnw> trigone: I think we'll get full pi types; but I don't think the goal is ever to have a fully consistent logic
14:28:39 <trigone> what's pi types?
14:28:46 <johnw> forall n : nat, P n
14:29:01 <johnw> where the result depends on universally quantified terms (i.e., values)
14:29:08 <jared-w> How I'd probably do it is fn num = (check then if valid call 'real function')  where (real function here).  Or fn num | num >= 0 = (call real function) | num < 0 = (error stuff here)  where (real function here)
14:29:23 <johnw> I think the intended syntax is: pi n : nat, P n
14:29:37 <jared-w> johnw: haskell already has an inconsistent logic, so that's certainly not the goal :p
14:30:25 <trigone> to get a Word out of an int, must one use fromInteger?
14:30:34 <johnw> the reason I mention that is that a lot of excitement about dependent types revolves around a rich enough type language to prove interesting properties; whereas in Haskell, it will be more for programming, since the proofs will never be completely sound (we'll always have the "assume totality, termination, and no use of unsafe/error/undefined/etc)
14:30:50 <trigone> > (3 :: Word) > (fromInteger (3 :: Int))
14:30:52 <lambdabot>  error:
14:30:53 <lambdabot>      • Couldn't match expected type ‘Integer’ with actual type ‘Int’
14:30:53 <lambdabot>      • In the first argument of ‘fromInteger’, namely ‘(3 :: Int)’
14:31:18 <trigone> > (3 :: Word) > (fromIntegral (3 :: Int))
14:31:20 <lambdabot>  False
14:32:02 <trigone> johnw: it's still very useful for programming isn't it
14:32:08 <johnw> oh yes, indeed
14:32:18 <johnw> makes it a lot easier to stop bad programs from being writeable
14:32:45 <johnw> just won't *necessarily* mean that every program you can write is a good one
14:33:11 <trigone> and for now, can we use (some) dependent typing in haskell without too much clunkiness or not?
14:33:19 <johnw> depends on what you want to say
14:33:21 <EvanR> in some cases, itll turn writing bad programs into a puzzle
14:33:31 <johnw> some dependent things are easy enough to write (heterogenous lists), some are not so easy
14:34:09 <tdammers> automatically deciding conclusively whether an arbitrary program is "good" or "not good" amounts to the halting problem
14:34:51 <trigone> hm
14:34:57 <johnw> if there's a scale of goodness, sure; but you can have "possible" vs. "not possible" according to a chosen meta-theory
14:35:21 <johnw> though maybe the automation angle is your point
14:35:59 <trigone> > mzero :: IO a
14:36:01 <lambdabot>  error:
14:36:01 <lambdabot>      • No instance for (Typeable a0)
14:36:01 <lambdabot>          arising from a use of ‘show_M82712379641290677427372’
14:36:17 <EvanR> how relevant is the halting problem practically. when faced with a typical undecidable problem, joe shmo programmer usually solves it anyway. 
14:36:22 <trigone> > mzero :: IO ()
14:36:23 <EvanR> manually
14:36:25 <lambdabot>  <IO ()>
14:36:30 <johnw> trigone: if you say "/query lambdabot", you can talk to lambdabot privately, until you find a result you want to share with the whole channel
14:36:39 <trigone> johnw: ok sorry
14:36:52 <EvanR> and when AI writes the code, somebody demands their money back for buying into the halting problem
14:37:16 <johnw> trigone: no problem; actually, if you find your solution privately and then post it here, no one knows all the failing iterations you tried, so it makes it look like you "got it in one" :)
14:37:33 <trigone> lol
14:37:44 <MarcelineVQ> 60% ​of the time it works every time
14:38:04 <trigone> MarcelineVQ: well that's a weird statistic
14:38:47 <trigone> mzero in IO, does it raise an exception or not?
14:39:13 <MarcelineVQ> ask ghci
14:39:33 <trigone> yeah but i trust y'all more than ghci :P
14:39:53 <MarcelineVQ> You should trust ghci more :>
14:40:00 <MarcelineVQ> you'll need to  import Control.Monad
14:40:08 <johnw> we trust ghci more, so trust us, and then... transitivity
14:40:52 <trigone> where's MonadPlus?
14:41:44 <trigone> oh it doesn't have an isolated module
14:42:26 <trigone> ghci tells me "no instance for MonadPlus IO".
14:43:09 <trigone> i was sure yesterday somebody told me mzero raised an error in IO... :s
14:43:23 <MarcelineVQ> you can ask hoogle where to import it from  http://hoogle.haskell.org/?hoogle=MonadPlus
14:43:44 <trigone> :) thx
14:43:45 <johnw> there's a MonadPlus instance for IO
14:44:04 <trigone> johnw: well... i don't get it then
14:44:22 <johnw> I get: *** Exception: user error (mzero)
14:44:41 <trigone> if i do "mzero >> print "a"" it tells me "no MonadPlus IO", and "no Alternative IO" if i use guard
14:45:13 <dsal> Heh, I started running 'stack setup' at 13:03 (it's 14:44 here):  ghc-8.0.2:   52.38 MiB / 136.70 MiB ( 38.32%) downloaded...
14:47:14 <MarcelineVQ> stack is a little hard on data, the indices folder for hackage is something like 900mb for me
14:47:43 <trigone> johnw: why don't i got my MonadPlus IO instance??
14:47:45 <dsal> This is a raspberry pi in my attic.  I'm sure that's not helping things.
14:48:07 <MarcelineVQ> trigone: what did you actually try? your quoted example didn't have guard in it
14:48:07 <johnw> trigone: are you importing Control.Monad?
14:48:25 <mud> MarcelineVQ: Well, this is just it downloading ghc AFAIK
14:48:30 <trigone> johnw: if i didn't it wouldn't recognize mzero or guard anyway
14:48:37 <johnw> good point
14:48:43 <johnw> I'm a bit symied then
14:48:46 <trigone> MarcelineVQ: guard False >> print "a"
14:49:12 <trigone> No instance for (GHC.Base.Alternative IO)       arising from a use of ‘guard’
14:49:53 <trigone> oh wait, stack ghci recognizes it
14:51:52 <dsal> Why does stack give me ghc 8.0.2 if there's a newer one?
14:51:53 <trigone> well that's weirdish... Alternative/MonadPlus IO is supposed to exist since 4.9.0.0 (though i dunno if it's ghc/i or the package base)q
14:52:17 <dsal> I should always have the latest things.
14:52:36 <MarcelineVQ> stack isn't about the latest things
14:52:38 <trigone> oh well apparently, my non-stack ghci runs with base 4.8... great
14:52:43 <MarcelineVQ> it's about reproducable builds
14:52:48 <trigone> is it that recent?
14:52:53 <MarcelineVQ> sometimes that's clost to the latest thing, sometimes it's not
14:53:08 <trigone> i think it's reproducible
14:53:59 <MarcelineVQ> until there's a stack resolver that includes ghc 8.2 you're out of luck. a resolver is a set of curated packages known to build together that are frozen at specific versions
14:54:10 <dsal> Oh.  Fancy.
14:54:13 <trigone> may 21 2016, it says. how can i have such an old version of ghc/i walking around?
14:54:29 <dsal> I'm going to be trapped knowing that I have an ancient version of things.
14:55:08 <mud> dsal: For 8.2.1 you have to use nightly resolvers, you can pick one manually
14:55:10 <MarcelineVQ> changes in 8.2 aren't impactful to learning haskell
14:55:29 <dsal> I'm just figuring out what stack does. heh
14:55:38 <johnw> dsal: if you're very brave, there's always Nix
14:55:51 <hpc> stack is better than nix imo
14:55:55 <johnw> which can also use Stackage, and allows multiple environments, one of which could be seriously-up-to-date, and another totally stable
14:55:55 <dsal> I'm looking at release notes for 8.2.  Adds color to errors.  I like colorful errors.
14:56:07 <johnw> hpc: why is that?
14:56:17 <johnw> if the aim is reproducibility, Nix includes system dependencies as well as Haskell ones
14:56:18 <hpc> nix needs a type system
14:56:18 <MarcelineVQ> is there a nightly for 8.2 now? that's good. but even better is reading this first  https://docs.haskellstack.org/en/stable/GUIDE/
14:56:37 <johnw> hpc: that issue doesn't affect most users of Nix, who won't be writing expressions
14:56:41 <hpc> when i tried to use nix, i couldn't figure out what parts of an expression denoted things that actually happen
14:56:45 <hpc> ah, fair
14:56:47 <mud> dsal: stack passing through GHC's colors I don't think is in a released version yet. If you really want that you'll need to 'stack upgrade --git' I believe.
14:56:52 <hpc> stack can manage some system dependencies as well
14:56:53 <johnw> although I agree that it does need one
14:57:03 <johnw> <-- as a writer of expressions who runs into lots of stupid errors
14:57:07 <hpc> when i used it on windows, it was able to keep track of sdl for me
14:57:14 <johnw> oh, interesting
14:57:25 <hpc> it doesn't do everything, but the ability is there sometimes
14:57:26 <MarcelineVQ> isn't there a haskell dsl for writing typed nix? :>
14:57:37 <johnw> as an example, my current project depend on the z3 library, and I like that I never needed to know how to build it to build my Haskell project
14:57:47 <johnw> MarcelineVQ: yes, Gabriel is working on one
14:58:47 * hackagebot HSvm 0.1.0.2.90, ghcjs-dom 0.9.2.0, jsaddle-dom 0.9.2.0, ghcjs-dom-jsaddle 0.9.2.0, … and 1 more
14:58:47 * hackagebot  → https://hackage.haskell.org/packages/recent
14:59:03 <MarcelineVQ> all configuration languages confuse me :( this is a barrier to things like nix and propeller. propeller looks really cool but the example code is terrfying, to my untrained eye
14:59:20 <hpc> nix does more than one thing
14:59:28 <hpc> it's both a build language and a configuration language
14:59:41 <hpc> or if you like, it's a configuration language that sees build configuration as part of system configuration
14:59:48 <hpc> (which sometimes it is)
14:59:49 <thoughtpolice> hpc: Nix has some downsides but its benefits far outweigh them in general. Some of the downsides are really annoying.
15:00:01 <dsal> What is <- ?    :t won't tell me.  Something about taking the value out of a monad in the right context or something?
15:00:06 <hpc> would it help if i learned nix independently of nixos?
15:00:09 <johnw> it's syntactic sugar
15:00:13 <hpc> dsal: it's part of do-notation syntax
15:00:14 <johnw> it's not from a library
15:00:19 <thoughtpolice> I basically describe Nix as: it makes some impossible things easy, some easy things annoyingly hard, and essentially everything else is mostly smooth sailing.
15:00:22 <hpc> it's not a value, just a lexical token
15:00:43 <hpc> dsal: it's at the same level of abstraction as parens or the "where" keyword ;)
15:00:59 <MarcelineVQ> thoughtpolice: that's high praise in the computing world
15:01:01 <dsal> I see.  I just don't quite understand what to think of it as doing.
15:01:02 <thoughtpolice> hpc: That's how I used it at first, yes. I just wrote package expressions and got used to the tools.
15:01:27 <hpc> MarcelineVQ: the first configuration language to really click with me was puppet
15:01:34 <hpc> you may have luck with that
15:01:35 <thoughtpolice> (I use Nix on Fedora/Ubuntu right now in fact, and only have one NixOS server atm)
15:01:49 <hpc> since version 4, it has a type system that i don't feel horrible for using
15:01:54 <MarcelineVQ> hpc: I'll have a look thank you, puppet came up in #haskell-offtopic recently iirc
15:01:55 <boj> dsal: i typically describe it as "unwrapping a monad value", or "executing an action"
15:02:08 <dsal> Yeah, "unwrapping a monad value" is kind of how I was looking at it.
15:02:11 <dsal> Thanks.
15:03:11 <MarcelineVQ> <- lets you name the result of a monadic action so you can refer to it elsewhere, though that's not the clearest way to explain to someone
15:03:40 <MarcelineVQ> I'm not sure how to explain it actually, beyond that, much better to explain >>= and what <- means to >>=
15:04:05 <thoughtpolice> hpc: The thing is, there's already enough 'surface area' in the package-level language (using nixpkgs and the tools) to keep you occupied for a while. For example, each programming language tends to have its own set of tools and APIs for Nix-powered management you need to get used to.
15:04:09 <dsal> Yeah, I don't get >>=
15:04:28 <dsal> I just read this STM example:  https://wiki.haskell.org/Simple_STM_example  --  it doesn't look like it has anything to do with STM.  Kind of reads like normal atomic operations.
15:04:37 <thoughtpolice> That's good because it means multi-language projects are very robust and possible to reproduce easily, but it's a bit to learn. NixOS is a logical extension of all this but for a newcomer it may be pretty overwhelming.
15:04:48 <hpc> thoughtpolice: the specific thing that i got hung up on was making the system nix expression manage files in a home directory
15:06:39 <thoughtpolice> It's tricky to do that (Nix wants to really only manage the store, and a few other things) and in general it doesn't work portably, is the thing.
15:07:06 <thoughtpolice> (On NixOS, nix-build for example is done by a daemon in a container environment and likely can't mount your homedir, if you try to do things like write to it during a build step)
15:07:06 <hpc> so the store only maps to specific "userland" locations?
15:07:22 <johnw> thoughtpolice is the original reason I tried Nix
15:07:28 <boj> dsal: do you understand how to use >>=?
15:07:33 <hpc> because you can make a nix expression manage /etc files
15:07:34 <johnw> watching what he could do on his laptop with his GHC development
15:07:47 <thoughtpolice> :)
15:08:00 <dsal> boj: I do not.  I've written like, one useful program in haskell so far, and it only had IO in main.
15:08:26 <boj> dsal: ok, makes sense
15:08:30 <MarcelineVQ> GHC dev is a place I could see nix really shine, given all the versioning issues I have run into playing with that
15:08:39 <dsal> (it had a little bit of monadic stuff in another function someone else wrote using <$> and <*> which I didn't quite understand until this morning)
15:08:46 <thoughtpolice> hpc: So on NixOS you can, but in general doing that is probably ill-advised on Nix-on-Ubuntu or whatever.
15:09:16 <dsal> boj: What's a good way to quickly understand >>= ?
15:09:17 <thoughtpolice> I mean you can probably make it work, but, you're a bit "on your own". Declarative management of system files is a very long game to play and you'll end up recreating half of NixOS's machinery anyway
15:09:19 <boj> dsal: do-notation is syntax sugar for >>=, { do x <- foo; bar x } = foo >>= \x -> bar x
15:09:30 <hpc> can we continue this in -offtopic?
15:09:41 <dsal> Oh.  I see.
15:09:44 <hpc> i feel like an examination of what goes into making a file appear in /etc will help a lot
15:09:45 <johnw> good idea hpc
15:09:48 <dsal> Does >>= get used much in real code?
15:09:53 <MarcelineVQ> dsal: consatantly
15:10:39 <thoughtpolice> MarcelineVQ: I think Nix is good for many downstream consumers, but I probably wouldn't advise ever making it mandatory for GHC or anything. GHC is already incredibly complex and has to work in a wide variety of places, so Nix doesn't really help *that* much.
15:10:40 <MarcelineVQ> though outside of do notation you might be more inclined to see   =<<   (flipped >>=)  depends on the person writing the code
15:11:07 <dsal> OK, good.  Thanks.  I think I can at least understand what it means now.
15:11:14 <thoughtpolice> (I mean, it does help, but stuff like that is always a huge, broad topic.)
15:11:19 <dsal> Also good to know that it means the same thing in both directions.  heh
15:11:38 <boj> dsal: i think once you start visualizing your code more like pipelines you naturally start writing >>= in some cases where it feels more readable
15:12:12 <MarcelineVQ> thoughtpolice: yes that's reasonable, even just getting extra tools like arcanist set up felt like a barrier when I was first playing with ghc
15:12:33 <MarcelineVQ> multiple logins bewteen git, phab, trac, etc
15:12:43 <dsal> The one useful program I wrote takes a csv and adds a couple columns to it.  It ends up with three or four copies of all the data at once, but I suspect that'd be non-trivial (especially since I traverse the file at sort of two different "speeds")
15:13:07 <dsal> So I'd need two independent streams of rows that are from the same source.
15:13:15 <MarcelineVQ> that's not a complaint, just that I can understand why not wanting more outside tools would be preferred
15:13:19 <dsal> None of my files are going to be too big to fit in memory, though.
15:13:27 <thoughtpolice> MarcelineVQ: In that particular case we didn't really have anything at all for code review and GH wasn't up to our liking, so it was more of a necessity. I unfortunately never really had time to do any kind of login unification. :P
15:13:40 <thoughtpolice> (LDAP could do it but being an LDAP admin was the absolute last thing I wanted)
15:14:08 <MarcelineVQ> LDAP sounds like something you use to fire artillery
15:15:08 * hackagebot HSvm 0.1.0.3.22 – Haskell Bindings for libsvm – https://hackage.haskell.org/package/HSvm
15:15:24 <dsal> Hmm...   How is haskell FFI?
15:15:31 <dsal> You know what, I don't think I even want to know.
15:15:37 <boj> dsal: it's great
15:16:08 <dsal> Even when languages have good FFIs, you still have to deal with the crap you're bringing in.  I'd rather just not.
15:16:15 <dsal> So many projects.
15:16:22 <boj> yeah
15:45:09 <jared-w> MarcelineVQ: nah, LDAP is just something you use to shoot yourself in the balls with, like most Microsoft products, it seems...
15:46:39 <Lordcirth> Samba4 LDAP servers aren't bad
15:48:08 <boj> we use one of the two ldap libraries out there to auth off MS AD. we had a question with one of the authors, they immediately wanted to pawn it off to us to support :D
15:48:36 <hpc> ipa?
15:50:00 <boj> the haskell "LDAP" library
15:52:26 <koz_> I'm having some trouble following what the Base type family is all about here: https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#t:Base
15:52:38 <koz_> Could someone help me make some sense of what it's meant to represent?
15:53:57 <johnw> it lets you pick out our base functor
15:53:59 <johnw> your*
15:54:16 <johnw> for example, if you define ExprF r as your F-algebra, and then type Expr = Fix ExprF, then the Base type of Expr is ExprF
15:54:30 <koz_> Ah, I see.
15:54:35 <koz_> That makes a whole lot more sense.
15:56:26 <koz_> johnw: If you could, can you give me a general description of what a zygomorphism iis meant to do?
15:56:38 <koz_> Like, I get cata, ana, para, apo and hylo.
15:56:51 <koz_> But zygo doesn't make any sense, and reading its type sig is providing no insights.
15:57:45 <johnw> maybe here: https://stackoverflow.com/questions/36851766/histomorphisms-zygomorphisms-and-futumorphisms-specialised-to-lists
15:57:48 <boxscape> how come << doesn't exist?
15:57:57 <koz_> boxscape: Try writing its type sig.
15:58:13 <boxscape> sec
15:58:15 <johnw> boxscape: good question, but nowadays you can always use <* where you would want <<
15:58:28 <koz_> johnw beat me to it. :P
15:58:38 <boxscape> I see, that makes sense
15:58:43 <boxscape> thanks guys
16:00:02 <koz_> johnw: That link is pure gold - thank you!
16:01:19 <koz_> :t (<*)
16:01:20 <lambdabot> Applicative f => f a -> f b -> f a
16:11:09 <search> hello
16:40:01 * hackagebot SciFlow 0.6.0 – Scientific workflow management system – https://hackage.haskell.org/package/SciFlow
16:53:20 <platz> > liftA2 ((<>)) ("first","xx") ("second", "yy")
16:53:22 <lambdabot>  ("firstsecond","xxyy")
16:53:59 <platz> how would I generate ("first", "xxyy")
16:54:33 <platz> essentially it's using `mappend` in the applicative instance for (,)
16:55:08 <platz> but I just want it to keep the value from the first tuple
16:56:30 <implementation_> > ("first","xx") >> ("second","yy")
16:56:32 <lambdabot>  ("firstsecond","yy")
16:56:43 <implementation_> hmm, that's at least the exact opposite
16:58:03 <pacak> > (fst *** fst) $ curry (fst &&& snd) ("first","xx") ("second", "yy")
16:58:05 <lambdabot>  ("first","second")
16:58:15 <platz> implementation_: that's the co-answer :)
16:58:22 <dmwit> > (S.First "first", "xx") S.<> (S.First "second", "yy")
16:58:24 <lambdabot>  (First {getFirst = "first"},"xxyy")
16:58:32 <dmwit> (S = Data.Semigroup)
16:58:34 <MarcelineVQ> :(
16:58:38 <platz> ah, yes..
16:58:41 <pacak> > const ("first", "second") undefined
16:58:43 <lambdabot>  ("first","second")
16:58:50 <dmwit> :t bimap
16:58:51 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
16:59:49 <platz> bimap + First would seem to do it
16:59:59 <platz> bimap is is bifunctors ?
17:00:09 <platz> is in
17:00:30 <dmwit> > (const, (<>)) <<*>> ("first", "xx") <<*>> ("second", "yy")
17:00:33 <lambdabot>  ("first","xxyy")
17:00:33 <pacak> > getFirst $ foldMap First [1,2,3]
17:00:35 <lambdabot>  error:
17:00:36 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M215944286038...
17:00:36 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:00:41 <dmwit> (<<*>>) is from Data.Biapplicative
17:00:41 <platz> ahh it's in base 
17:00:54 <dmwit> platz: You like my new one? =)
17:00:56 <platz> excellent, thanks dmwit 
17:01:31 <platz> ooh, expert mode :)
17:01:35 <platz> i like it
17:02:25 <platz> i was thinking Data.Functor.Const but it was wrong, so biapplicative, interesting!
17:03:52 <dmwit> However, I think I also like this one just fine:
17:04:08 <dmwit> > let f (a, b) (c, d) = (a, b <> d) in f ("first", "xx") ("second", "yy")
17:04:10 <lambdabot>  ("first","xxyy")
17:04:34 <dmwit> very readable by comparison =P
17:05:46 <Tuplanolla> :t over (join iso swap) -- I was considering using this, but I can't think how right now.
17:05:48 <lambdabot> ((b, a) -> (a, b)) -> (a, b) -> (b, a)
17:06:57 <dmwit> :t iso swap swap
17:06:58 <lambdabot> (Functor f, Profunctor p) => p (b1, a1) (f (a, b)) -> p (a1, b1) (f (b, a))
17:07:10 <Tuplanolla> The idea was that you ought to be able to operate with the pair under the swap isomorphism.
17:07:27 <dmwit> :t swap
17:07:28 <lambdabot> (a, b) -> (b, a)
17:08:11 <dmwit> > (swap . ((>>) `on` swap)) ("first", "xx") ("second", "yy")
17:08:13 <lambdabot>  error:
17:08:13 <lambdabot>      • Couldn't match expected type ‘([Char], [Char]) -> t’
17:08:13 <lambdabot>                    with actual type ‘(b0, a0)’
17:08:21 <dmwit> > swap $ ((>>) `on` swap) ("first", "xx") ("second", "yy")
17:08:24 <lambdabot>  ("second","xxyy")
17:08:31 <dmwit> oh, so close =)
17:09:01 <dmwit> ...
17:09:02 <dmwit> :t (<<)
17:09:04 <lambdabot> error:
17:09:04 <lambdabot>     • Variable not in scope: <<
17:09:04 <lambdabot>     • Perhaps you meant one of these:
17:09:53 <dmwit> ?let m1 << m2 = m1 >>= (<$ m2)
17:09:55 <lambdabot>  Defined.
17:10:02 <dmwit> > swap $ ((<<) `on` swap) ("first", "xx") ("second", "yy")
17:10:04 <lambdabot>  ("first","xxyy")
17:10:10 <dmwit> yaaaay
17:12:21 <Tuplanolla> :t swap .: on (liftA2 const) swap -- This is what I had in mind, but the isomorphism is lost in the noise.
17:12:23 <lambdabot> Monoid a => (b, a) -> (b, a) -> (b, a)
17:12:46 <boxscape> @pl > let f (a, b) (c, d) = (a, b <> d) in f ("first", "xx") ("second", "yy")
17:12:46 <lambdabot> (line 1, column 1):
17:12:46 <lambdabot> unexpected ">"
17:12:46 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:12:49 <boxscape> aww
17:12:58 <boxscape> ah wait
17:13:03 <dmwit> ?pl \(a, b) (c, d) -> (a, b <> d)
17:13:03 <boxscape> @pl \let f (a, b) (c, d) = (a, b <> d) in f ("first", "xx") ("second", "yy")
17:13:03 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (<>)) . (.) . (,))
17:13:03 <lambdabot> (line 1, column 5):
17:13:03 <lambdabot> unexpected reserved word "let"
17:13:03 <lambdabot> expecting pattern
17:13:13 <boxscape> christ
17:13:18 <boxscape> @pl let f (a, b) (c, d) = (a, b <> d) in f ("first", "xx") ("second", "yy")
17:13:18 <lambdabot> ("first", "xx" <> "yy")
17:13:20 <boxscape> there we go
17:13:28 <boxscape> I thought it was confused by the let at first
17:13:40 <boxscape> although the answer is a bit disappointing, in a way
17:13:52 <dmwit> boxscape: See the answer to my ?pl query. Much more satisfying.
17:14:00 <boxscape> ah, yeah
17:15:14 <boxscape> is ? just something you can use instead of @ with lambdabot?
17:15:19 <dmwit> yes
17:15:22 <boxscape> good to know
17:16:29 * hackagebot master-plan 0.2.0.0 – The project management tool for hackers – https://hackage.haskell.org/package/master-plan
17:23:04 <cheater> is show the best way to turn Double into String or is there a nicer more prefered way?
17:25:10 <johnw> there are better ways
17:25:14 <johnw> like the `numbers` library
17:25:39 <cheater> hm what if i don't care enough to pull in an extra lib?
17:25:43 <johnw> the "best" representation is the least one that parses back to the same bits
17:25:57 <johnw> then you can use show, except you might sometimes see 0.000000000003
17:26:06 <cheater> ok
17:26:26 <johnw> MPFR can give a good rendering, but I guess base isn't using it
17:26:34 <cheater> oh nice, numbers is up to version 3000. that must be mature
17:26:49 <cheater> :)
17:28:06 <cheater> i'm having an issue figuring out how i would use numbers to print a Double
17:28:31 <boxscape> that almost looks like they started using the release year for the version number and then just gave up at some point
17:28:53 <cheater> there doesn't seem to be anything that jumps out at me
17:29:13 <cheater> boxscape: kinda, yea.
17:29:41 <boj> cheater: there's always good ol' printf
17:29:50 <cheater> johnw: how does one use numbers to print a Double?
17:29:54 <cheater> boj: yeah
17:36:16 <johnw> cheater: one sec
17:37:10 <johnw> showCReal <precision>
17:41:20 <cheater> johnw: ok but that's for CReal numbers
17:41:37 <cheater> johnw: i guess i would have to convert from Double first using something like from*
17:43:05 <cheater> actually i don't even see a way to make a CReal from a Double
17:43:21 <cheater> none of the classes mentioned here seem to make it possible: http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html
17:45:32 <cheater> btw, does anyone see a reason why i would be having this issue with hvx? (hvx is a convex programming library). it's really difficult for me to come up with a way to fix this. https://github.com/chrisnc/hvx/issues/10
17:50:27 <ludat> hi guys, is someone here maintaining stack? I'm not sure but I may have found a bug
17:50:44 <cheater> i think snoyberg is
17:50:48 * pacak is not surprised
17:51:11 <cheater> you can probably best write him on twitter or use the bug tracker
17:52:54 <ludat> never mind I'm just an idiot :P
18:05:20 <koz_> Could someone please explain (or point me to some reading which will) the difference between wfix, cfix and kfix here? http://hackage.haskell.org/package/comonad-5.0.2/docs/Control-Comonad.html#v:wfix
18:05:40 <edwardk> kenny foner's talks on the subject are pretty good
18:06:10 <edwardk> https://www.youtube.com/watch?v=F7F-BzOB670
18:06:16 <koz_> edwardk: Is there something in written form? I prefer written stuff, but I will check that out.
18:06:28 <koz_> Also - hi!
18:06:34 <pacak> more cosmic wisdom.
18:06:48 <koz_> pacak: Good - I'm not the only one who thinks so. :P
18:06:52 <edwardk> https://pdfs.semanticscholar.org/89d3/57437a7b0d069fa81037b79fd96c819985c7.pdf
18:07:25 <pacak> koz_: I mean you'll get it once you watch/read it a few times. And it will be useful in a long run.
18:07:39 <koz_> edwardk: Thank you - shall watch/read/understand.
18:07:55 <edwardk> the short version is that kfix uses exactly the same structure of argument as the classic loeb's theorem proof.
18:08:48 <edwardk> dan piponi's loeb function on the other hand just kinda squints at the type and replaces the 'is provable' modality with a functor and tries to write it using fmap and fixed points
18:09:47 <edwardk> so kfix is closer to loeb than either of the two 'comonadic fixed points' that always exist for all comonads and can actually be much faster due to it having nice structure
18:10:41 <epoitras> Can someone explain to me why this simple monad transformer example seems to violate haskell's type system?
18:10:42 <epoitras> http://lpaste.net/357755
18:10:49 <edwardk> If you look at the definition kfix is sort of like the bastard child of wfix and cfix, it shoves the 'w' in all the places that either of the other two do, but its able to exploit 'ComonadApply' to compute efficiently
18:11:10 <epoitras> 'ask' seems to return a Reader instead of State
18:11:43 <koz_> epoitras: Yeah, because ask is the Reader monad's shindig.
18:11:53 <koz_> For pulling out the state, there's a different function.
18:12:05 <koz_> (get I think)
18:12:07 <koz_> :t get
18:12:07 <edwardk> epoitras: 'ask' is for accessing the reader. 'get' is for accessing the state
18:12:08 <lambdabot> MonadState s m => m s
18:12:12 <epoitras> oh god...
18:12:16 <epoitras> Thanks friends
18:12:23 <koz_> epoitras: No worries - happens to all of us.
18:17:16 <koz_> edwardk: I'm watching the talk, just got to Loeb's Theorem in Haskell, and my reaction to it was: https://vignette2.wikia.nocookie.net/glee/images/e/eb/What-kind-of-sorcery-is-this.jpg/revision/latest?cb=20130422032527
18:22:27 <edwardk> koz_: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html <- is the original intro to loeb's theorem that piponi write a decade ago
18:22:53 <koz_> edwardk: I'll add it to my reading queue. Thanks!
18:23:19 <pacak> koz_: How long is your reading queue and what's in there?
18:23:25 <edwardk> also note that kfix requires just a bit too much of 'w' it requires ComonadApply but never exploits extract. it really should be for some "SemicomonadApply' class that we don't have, or 'ExtendApply' whatever you want to call it
18:23:45 <koz_> pacak: For this topic, or in general?
18:23:47 <edwardk> that would permit it to handle piponi's [] based examples
18:23:56 <pacak> In general
18:23:58 <pacak> just curious
18:24:04 <koz_> edwardk: What would ExtendApply's operations be?
18:24:08 <edwardk> as [] can be extended and has a zipping operation, but can't be extracted
18:24:26 <edwardk> koz_: ComonadApply minus extract
18:24:55 <koz_> edwardk: So that would be something like (Functor w) => ExtractApply w where ... ?
18:24:57 <edwardk> fmap, (<*>), and duplicate
18:25:13 <koz_> edwardk: <*> being applicative splat?
18:25:20 <edwardk> class Extend f => ExtendApply f where (<@>) :: f (a -> b) -> f a -> f b
18:25:24 <edwardk> yeah
18:25:38 <edwardk> (<@>) has (<*>) like associativity
18:27:02 <edwardk> a strong lax symmetric semi-monoidal semi-comonad -- say that three times real quick
18:27:17 <koz_> edwardk: Describing something as 'strong lax' always threw me.
18:27:25 <edwardk> likewise
18:27:39 <koz_> I know that they refer to very different things, but it still sounds weird.
18:27:45 <edwardk> i've just taken to dropping both words and letting the people who actually know category theory shake out what i mean =)
18:27:56 <koz_> edwardk: Which basically means 'people who aren't me'. :P
18:28:11 <koz_> (since I don't actually know category theory)
18:28:32 <koz_> edwardk: So would it make sense to have 'Applicative w => ExtractApply w' then?
18:30:08 <edwardk> koz_: no requirement of pure
18:30:14 <koz_> edwardk: Ah, I see.
18:30:24 <koz_> (hence the 'semi-monoidal' part?)
18:30:31 <edwardk> its the same operations as Extend and Apply but with an extra requirement of symmetry
18:36:12 <edwardk> koz_: for reference, the 'comonadapply' class that is referenced there is based on the ComonadZip class from Uustalu and Vene's "Essence of Dataflow Programming" https://pdfs.semanticscholar.org/ad77/ebcb739925559b48adc441d86ea45e7b9900.pdf -- that paper is quite good up until it starts mucking about with Bikleisli
18:36:33 <koz_> edwardk: Ah, I see. Yeah, I didn't get the whole Bikleisli thing either.
18:36:55 <koz_> (otherwise, that's a really cool paper)
18:37:09 <edwardk> its a bad idea that got a lot of traction at the time
18:37:44 <koz_> Also, as a side note - could you please remind me of the different tradeoffs for the various free(er) monads? You mentioned reflection without remorse, machines, and one other one.
18:38:02 <koz_> And I think the machines one has a large overhead in general, but I can't recall the other two.
18:40:33 <edwardk> there are 4 approaches to free to get from functor up to monad. there is the naive adt encoding that has problems with left associated binds, Codensity (Free f) that has the problem of being too big, but having an embedding and a retraction of that embedding from Free f. There is the "Church free" monad "F" i have in the free package that has the correct size (same size as "Free f") unlike Codensity (Free f), while maintaining the
18:40:33 <edwardk> benefits for left associated binds, but both of these latter two solutions have problems when it comes to inspecting and continuing on to do more binding. Reflection without remorse handles both left associated binds and continued binding in exchange for terrible constants.
18:41:08 <koz_> edwardk: And Oleg's latest paper on extensible effects uses which of these?
18:41:14 <edwardk> you can choose to optionally compose this with Coyoneda to get from a type constructor of kind * -> * to monad instead. and then people start throwing around names like operational or 'freer'
18:41:15 <koz_> (reflection without remorse?)
18:41:16 <edwardk> thats it
18:41:34 <edwardk> freer = reflection without remorse based free on top of coyoneda of f
18:41:58 <koz_> edwardk: Ah, OK. So basically, it's OK asymptotically, but in practice those constants bite?
18:42:13 <koz_> (and I assume it's the FTCQueue they're using that gives those constants?)
18:42:41 <edwardk> now, for effect systems there comes a hurdle that every effect system gets caught up on the horns of a dilemma. (trilemma? quadlemma?) they have to give up something and they all basically fall into one of 4 bins in my experience.
18:43:18 <edwardk> well once you bake in the assumption that you're using the free monad to talk about an effect system you get some other problems
18:44:26 <edwardk> oleg's first stab at doing effect system stuff was based on more or less a codensity of free of a data types a la carte set of base effect functors.
18:45:03 <edwardk> later he replaced the codensity of free part with reflection without remorse and hit everything with coyoneda. (not that he tends to talk about codensity/coyoneda)
18:45:25 <koz_> Yeah - he never mentions either of those anywhere I've seen.
18:45:38 <edwardk> but the thing with codensity (free f) is that its bigger than free f. so its capable of handling "effects" such as Cont.
18:45:54 <edwardk> unfortunately once you're big enough to handle Cont you are big enough that you can't compose your "handlers" and preserve laws.
18:46:00 <Welkin> oh hi edwardk 
18:46:14 <Welkin> I was just learning about Free and Cont
18:46:22 <edwardk> combining the handlers for Cont and the laws for monad writer doesn't work in one direction. "handling" Cont silently breaks your use of Writer!
18:46:38 <Welkin> and wanted something about Cofree and Comonad (and Yoneda/Coyoneda). Any suggested papers/essays/talks?
18:46:54 <edwardk> this is a sign that there is something rotten in the state of denmark
18:47:52 <Welkin> I started reading gabriel's blog post on comonads which looks good
18:48:29 <edwardk> if you start with the Codensity (Free f) approach you have a problem. Codensity (Reader e) a is isomorphic to State e a! It is too big an effect. if you replace the codensity bits with a right kan extension of some response type along some request type you can 'shrink' the effect system down enough that it can handle reader, but now binding it becomes a chore
18:49:11 <edwardk> welkin: the old sorta nonsensical comonads are objects post?
18:49:19 <orion> edwardk: What's the takeaway?
18:49:40 <Welkin> edwardk: yes
18:49:40 <koz_> The takeaway is that while extensible effects look nice, they're hiding some sins that they aren't escapign from/.
18:50:32 <koz_> I believe Edward did a talk about lenses + monad transformers which elaborated on the very same topic Edward is expounding on now.
18:50:42 <koz_> (that was some time last year I think?)
18:50:53 <orion> https://www.youtube.com/watch?v=Bxcz23GOJqc -- this?
18:51:07 <koz_> orion: Yeah, that one.
18:51:29 <orion> Thanks for the tip. I'm watching now.
18:51:37 <koz_> orion: I might be wholly off-base here.
18:51:54 <koz_> That's just me trying to relate various bits of Edward wisdom to each other while heavily caffeinated.
18:52:07 <edwardk> orion: you have pick your poison if you want an effect system: either you can't have Cont, or your "handlers" don't compose, almost everybody who does share a request/response type is too big to handle 'reader' properly, every 'free' based solution is based on a request/response model that fundamentally can't handle lazy state or lazy writer, or you're basically using the mtl and have to write the n^2 instances. oh, and then you get
18:52:08 <edwardk> languages that build their entire effect system on the naive encoding (*cough* idris) because it can be given types in their type system so that left associated binds mean that performing long chains of IO can incur a quadratic cost.
18:52:54 <edwardk> for idris the loss of Cont as an effect isn't a problem as it has positive position issues anyways
18:53:31 <koz_> edwardk: Do you think that extensible effects is a dead end?
18:54:18 <edwardk> Sadly, I do. That doesn't stop there being an entire conference dedicated to it, and a whole bunch of people touting it as a replacement for the mtl for all circumstances, etc.
18:54:42 <koz_> edwardk: There's a conference for extensible effects?
18:54:45 <koz_> Really?
18:55:03 <Welkin> edwardk: is purescript's effect system considered "extensible effects"?
18:55:15 <Welkin> or is it different because of row polymorphism?
18:55:24 <edwardk> Welkin: purescript's effect system can handle all your effects so long as they all look like IO
18:55:59 <edwardk> koz_: http://icfp17.sigplan.org/track/hope-2017-talks it is a workshop, not a conference per se
18:56:10 <edwardk> welkin: its basically just a tagged io
18:56:17 <Welkin> I see
18:56:28 <koz_> edwardk: I see. I guess I can understand that - it does seem really good, almost too good to be true on first inspection.
18:56:41 <koz_> Thank you for pointing out the issues with it - it's very enlightening.
18:56:47 <paf31> purescript-run is a more interesting take on extensible effects using rows in purescript
18:56:51 <Welkin> I noticed that when I was looking at howto create your own Effect types
18:57:14 <edwardk> koz_: when the major offerings in the space can't handle writer, reader, state or cont in the same generality as the mtl there is a bad sign. ;)
18:57:17 <paf31> as edwardk says, the one you're thinking of is just a phantom row on top of IO to help chop up the set of stuff you want to allow
18:57:20 <edwardk> you've kinda lost before you begun
18:57:32 <orion> edwardk: Have your concerns been heard by Oleg and friends? If so, what is their response?
18:57:38 <koz_> edwardk: Fair enough.
18:58:55 <edwardk> orion: well, oleg did manage to respond to the concern about state by coming up with a sort of dedicated combinator you could hack in to get head-recursion in an effect based state. its not the "one-point compactification" style thing I want though, you need to handle it specially and prove that its correct, and always change the style of your code whenever head recursion might occur.
18:59:08 <edwardk> that was an unexpected win from my initial complaints
18:59:44 <edwardk> another unexpected win was atze showing the world that reflection without remorse exists in the first place. my initial round of complaints occured before he found it. so i had one fewer point in the design space to criticize. ;)
19:00:57 <edwardk> so between them those two things helped out a fair bit from a pragmatics perspective, but effect systems are still very bad at handling things like the lazy writer/lazy state monad examples that don't exist in strict languages. i think they work pretty well for handling the kinds of effects that you tend to run into in a strict language, but are ill suited to the extra cases that become possible with laziness
19:01:50 <edwardk> another example of something where an 'effect systems will replace the mtl and all its ilk' style arguments fall apart is a library like 'bound' that fundamentally makes use of adding a new 'effect' to introduce fresh names in local scopes that i put on and peel off in sequence.
19:02:01 <edwardk> if you use a request/response model you get the wrong asymptotics
19:03:23 <edwardk> anyways, when folks tend to talk about effect systems its always a game of whackamole, because like i said there are those 4 major bins i find i can classify them in, so you need to pin down which bin someone is arguing about, lest you level criticisms that aren't fair to their variant
19:03:26 <Cale> The one example of "yet another way to defer the decisions about how we're going to implement stuff" which I've found not tedious recently is Conal's CCC thing.
19:03:45 <koz_> Cale: Link?
19:03:58 <Cale> https://github.com/conal/concat
19:04:05 <Cale> He gave a talk about it...
19:04:09 <koz_> One more thing for the reading queue!
19:04:17 <Cale> https://www.youtube.com/watch?v=vzLK_xE9Zy8
19:05:16 <Cale> It's actually more interesting than all the other stuff because it compiles Haskell into Category-related classes, so you get new domain-specific meanings for ordinary Haskell programs
19:06:03 <Cale> Lambdas and all :)
19:06:23 <Welkin> does anyone have another suggestion instead of gabriel's comonad essay?
19:06:38 <koz_> Welkin: Essence of Dataflow Programming.
19:06:38 <edwardk> Welkin: sorry got distracted
19:06:47 <koz_> It's literally the best thing I've seen on motivating me to care about them.
19:06:50 <edwardk> essence of dataflow programming is a good starting point.
19:07:03 <koz_> (modulo the Bikleisli thing, as per edwardk's comment)
19:07:16 <Welkin> thanks, I think I found it
19:07:18 <edwardk> another fun starting point is just asking yourself. how do i define the instances for (,) e    or for data Store s a = Store (s -> a) s
19:07:25 <Cale> Did everyone see my printf thing? :)
19:07:27 <edwardk> writing the instances is fun
19:07:35 <Welkin> Cale: nope
19:07:50 <koz_> edwardk: I need a motivation for Store - I'm still a bit unclear what to use it for or with.
19:07:52 <Cale> https://hackage.haskell.org/package/category-printf
19:07:54 <edwardk> instance Monoid e => Comonad ((->) e) -- is also fun
19:08:13 <edwardk> koz_: kenny's talk is all about spreadsheets and stuff, right?
19:08:42 <koz_> edwardk: It mentions them, yes; right now I'm on the 'function swapper thing' and he's laying out why Traversable and infinite streams don't mix.
19:08:44 <edwardk> Store (Int, Int) a -- is a 2d sheet of 'a's with a cursor on it
19:08:52 <koz_> OOOOOOOOOOH.
19:09:02 <koz_> The penny just dropped hard.
19:10:13 <edwardk> Store Integer a  -- is a 1 dimensional array stretching out to infinity in either direction with a cursor that lets you know where you are on it.
19:10:22 <koz_> edwardk: So a Turing tape?
19:10:39 <edwardk> Now you can define a function like blur :: Store Integer a -> a; blur (Store f s) = (f (s - 1) + f (s + 1)) / 2
19:11:21 <edwardk> then extend blur will 'blur' the contents of the whole 'sheet' by averaging your neighbors and give you a new 'sheet' by applying that function virtually to all of the positions.
19:11:28 <Cale> I was watching a talk by Dan Patterson at the NY Haskell Meetup at one point, and he was talking about a sort of continuation-passing-style sort of way to handle printf (and it was really unfortunate that his slides were broken, and I think most of the room was tuned out)
19:12:23 <edwardk> data Stream a = a :- Stream a; data Tape a = Tape (Stream a) a (Stream a) acts similarly. you can make a comonad for Tape, it is tricky
19:12:50 <koz_> edwardk: Kenny showed that, and it seemed quite straightforward.
19:13:23 <Welkin> oh haha, I watched Kenny's talk a few days ago
19:13:26 <edwardk> data Pointer i a = Pointer (Array i a) i -- acts the same sort of way as data Zipper a = Zipper [a] a [a] when i is Int or something
19:13:35 <edwardk> all of these are 'store-like'
19:13:39 <Welkin> I didn't understand it all
19:13:41 <Cale> But I noticed that he was defining this composition operator of type (String -> b -> c) -> (String -> a -> b) -> (String -> a -> c) for composing these "CPS format specifier things", and I thought "I bet that's just the composition for an already-existing category", and thought about it a bit.
19:13:43 <koz_> edwardk: I assume 'Store' is more general?
19:13:58 <koz_> Welkin: I'm pleased to say the talk is making sense, aside from Edward's categorical interjections. :P
19:14:05 <edwardk> data Fold a b where Fold :: (r -> b) -> (r -> a -> r) -> r -> Fold a b -- is also a comonad
19:14:46 <edwardk> extract (Fold k _ z) = k z; duplicate (Fold k f z) = Fold (Fold k f) f z; 
19:15:21 <edwardk> store is also related to lenses. lenses are 'store comonad coalgebras'
19:15:38 <koz_> edwardk: I *kinda* see that intuitively.
19:15:45 <edwardk> f :: s -> Store a s -- such that f is a store comonad coalgebra is a lens.
19:15:46 <Cale> So turns out it's the composition for the co-Kleisli category for the comonad of functions out of a fixed monoid (in our case, String)
19:15:54 <edwardk> why? lets look at store a bit
19:15:58 <edwardk> (s -> a, s)
19:16:27 <edwardk> so lets go back tot he common sense definition of a lens  data Lens s a = Lens { get :: s -> a, set :: s -> a -> s } 
19:16:46 <edwardk> then factor those two functions (s -> a,  s -> a -> s) because they have a common prefix
19:16:51 <edwardk> s -> (a, a -> s)
19:16:58 <edwardk> and alpha rename to get the store above.
19:17:07 <koz_> Damn, that's slick.
19:17:26 <edwardk> in the van laarhoven representation, we usually pick two comonads, Identity and Const to read off the parts
19:17:39 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t 
19:18:16 <edwardk> pick f = Const a, then  Const :: a -> Const a b can be passed as an argument
19:18:22 <edwardk> to get s -> Const a t
19:18:34 <edwardk> then remove the Const wrapper and you get 'get :: s -> a'
19:18:49 <edwardk> pick f = Identity and you can 'map' over a lens.
19:19:07 <edwardk> (a -> Identity b) -> s -> Identity t -- squint and you can remove the Identity newtypes and see it as (a -> b) -> s -> t
19:19:37 <edwardk> then just pass it a constant function to get the   s -> b -> t   function that is 'set' in its full generality
19:19:54 <crucify_me> hi re: the typeclass def 'class (Real a , Enum a) => Integral a where     a textbook says this " In a very real sense the tuple syntax here denotes the conjunction of typeclass constraints on your type variables. the idea of constraints has been covered for a while, but I feel I'm missing something from the way that is written.
19:20:03 <edwardk> alternately you can do both of these in one pass by fixing f = Store a
19:20:20 <koz_> edwardk: Consider myself sufficiently motivated with regard to Store. Thank you! :)
19:20:44 <crucify_me> sorry if I may repost that ...
19:20:55 <edwardk> koz_: as a fun exercise you can convert the definition of van laarhoven lenses into a viable definition for a 'store' comonad as well
19:21:01 <edwardk> flip the definition of your lens
19:21:10 <Cale> crucify_me: The wording of that sense is a bit strange, but it's not wrong. There's not much to miss.
19:21:14 <Cale> oops
19:21:18 <Cale> sentence*
19:21:19 <edwardk> forall f. Functor f => (a -> f a) -> s -> f s -- i'll fix a = b, s = t while i'm at it
19:21:21 <Welkin> crucify_me: it looks like it may be referring to the fact that the constraints are a product (AND) instead of a sum (OR)
19:21:29 <edwardk> to get s -> (a -> f a) -> f s
19:21:41 <edwardk> then pull the forall f. Functor f =>    across tot he right hand side
19:21:55 <edwardk> s -> forall f. Functor f => (a -> f a) -> f s
19:22:01 <edwardk> ball up the right hand side with a newtype
19:22:55 <Cale> crucify_me: If you're implementation-minded, you can regard the type class constraints as referring to records of methods of the type class operations which are going to arrive as a secret additional parameter to your function.
19:23:09 <Cale> crucify_me: and then the tupling is really just tupling those records together (perhaps)
19:23:09 <edwardk> newtype Context a s = Context { runContext :: forall f. Functor f => (a -> f a) -> f s }        and a Lens' s a is a 'Context comonad coalgebra' -- and you can show it is a comonad, etc. and can do the same things as store!
19:23:25 <dsal> What does '\FS' mean?  (character literal)
19:23:29 <koz_> edwardk: I can see why you're so excited by comonads.
19:23:38 <edwardk> its worth converting back and forth from Context <-> Store to get used to the two encodings
19:23:40 <Cale> > fromEnum '\FS'
19:23:42 <lambdabot>  28
19:23:44 <koz_> Hearing (reading?) you talk about them now, I'm excited about them too.
19:23:50 <edwardk> replace Functor with Applicative in the above definition and you get the notion of 'Bazaar' from lens.
19:24:05 <crucify_me> Cale Welkin thanks, please let me digest that...
19:24:10 <glguy> dsal: FS means "file separator"
19:24:12 <edwardk> which is used to characterize a traversal without introducing extra _|_'s unlike the "FunList" encoding will
19:24:17 <glguy> http://www.theasciicode.com.ar/ascii-control-characters/file-separator-ascii-code-28.html
19:24:21 <dsal> Oh, yeah.  I just looked it up in man ascii
19:24:51 <edwardk> (infinite) moore machines are comonads, data Moore a b = Moore b (a -> Moore a b) -- but that is actually the same as the Fold definition I gave! (just less efficient)
19:25:37 <edwardk> koz_: https://www.schoolofhaskell.com/user/edwardk/cellular-automata <- did you see this series?
19:26:03 <edwardk> i seem to keep referencing it on here lately
19:26:45 <koz_> edwardk: No, I haven't. Time to append to my reading list again!
19:27:08 <Welkin> didn't jle` write a series on Auto?
19:27:20 <Welkin> is that the same thing? (I think this was based on Arrow)
19:27:33 <edwardk> https://www.schoolofhaskell.com/user/edwardk/parallel-crc builds on the second part. https://www.schoolofhaskell.com/user/edwardk/conquering-folds builds further on the approach talked about there to tackle the third homomorphism theorem
19:27:48 <crucify_me> going to arrive as a secret additional parameter to your function ? so you mean that, in this case a product is calculated from the two tuple values, which adds functionality ?
19:28:09 <Cale> crucify_me: Or it could just be multiple arguments
19:28:37 <Welkin> crucify_me: from your example, it means that `a` must be an instance of both Real AND Enum, not just one or the other
19:29:51 <Cale> and the way the compiler's going to deal with that is by passing along a couple of records: one containing the operations for the Real type class (for a), and the other containing the operations for Enum (for a)
19:29:51 <Welkin> erisco: did anyone use your package yet?
19:30:35 <Cale> Welkin: which package?
19:30:41 <Welkin> Cale: lol :D
19:30:50 <erisco> 14 downloads, so maybe
19:30:53 <Welkin> http://hackage.haskell.org/package/control-dotdotdot
19:31:18 <Cale> oh no...
19:31:19 <Cale> hahaha
19:31:31 <Cale> This should be Acme.DotDotDot
19:32:11 <erisco> yeah but I can actually see myself using it in the right situation :P
19:33:17 <crucify_me> Cale so do both Real and Enum have numeric / algebraic values there, that are multiplied and / or used on arguments 
19:33:29 <crucify_me> ?
19:33:41 <Cale> crucify_me: Multiplied?
19:33:58 <Cale> crucify_me: The sense of the word "product" is that of "Cartesian product" 
19:34:22 <Cale> i.e. if A and B are sets, then A × B is the set of all pairs (a,b) with a in A and b in B.
19:35:02 <Cale> Note that if A and B happen to be finite sets, then if A has n elements and B has m elements, A × B will have n*m elements, hence the name "product"
19:35:12 <jchia> Question about containers package. Since 1. there is Enum instance for Int, 2. there is toEnum & fromEnum to freely convert between Int & Enum, 3. Enum is more general than Int, why don't they define EnumMap instead of IntMap to serve more use cases? Functions that depend on the numeric properties (like the Ordered instance) like lookupLT & lookupGT can have an Ordered constraint.
19:35:31 <koz_> jchia: Implementation-specific stuff for Ints.
19:35:42 <koz_> Basically, IntMap is done in a way that only makes sense on Ints.
19:36:13 <Cale> koz_: jchia is asking why not use the Enum operations to automatically convert back and forth from Int
19:36:24 <jchia> koz_: For example? It seems that under the hood, an Enum can be treated as an Int.
19:36:42 <koz_> jchia: I guess you're right.
19:36:53 <koz_> Spoke too soon, it would appear. :P
19:37:06 <Cale> This would work, but unfortunately, failure to specialise might result in everything being a whole lot slower even in cases where the type of index actually is Int
19:37:23 <Cale> But EnumMap could easily be provided anyway
19:37:44 <koz_> Cale: Someone should.
19:37:53 <Cale> I bet it's on Hackage already
19:38:07 <Cale> http://hackage.haskell.org/package/EnumMap yep
19:38:08 <jchia> I suppose if the Enum's toEnum & fromEnum are expensive, then an EnumMap implementation that effectively wraps around the IntMap implementation using toEnum & fromEnum would have poor performance, but it doesn't hurt the Int case.
19:39:07 <crucify_me> Cale thank you, so we are dealing with a finite set since enumerable is finite..
19:39:07 <Cale> jchia: You could have polymorphic code which defers the decision about which instance gets used, and that might result in failure to inline and then unbox the eventual Int arguments...
19:39:46 <jchia> Cale: Yeah, but I wonder why it's not in container, which is more commonly used.
19:40:16 <jchia> Cale: Do you mean that that EnumMap may suffer from failure-to-optimize problems that IntMap wouldn't?
19:40:25 <Cale> jchia: Actually, we've been struggling with that kind of thing a whole lot in one of our projects where I work, and we've got some benchmarks where if Monad instances fail to be specialised, code runs 60x slower.
19:40:46 <crucify_me> sorry no reals are infinite
19:41:12 <Cale> crucify_me: Well, you're talking about the type of all implementations of the Real typeclass operations
19:41:32 <Cale> (Real is poorly named, it's really for types which can be converted to Rational numbers)
19:41:54 <Cale> (i.e. most approximate numeric types which aren't complex)
19:42:14 <Cale> (but ironically, not actual computable real types)
19:43:00 <Cale> :t toRational
19:43:02 <lambdabot> Real a => a -> Rational
19:44:40 <Cale> class (Num a, Ord a) => Real a where toRational :: a -> Rational
19:44:58 <Cale> So you can imagine that the compiler is going to implement this type class with a record type like:
19:45:02 <xa0> @pl \x -> a (b $ c x)
19:45:02 <lambdabot> a . b . c
19:45:39 <Cale> data RealD a = RealD { toRational :: a -> Rational, numDict :: NumD a, ordDict :: OrdD a }
19:46:08 <Cale> and then whenever your definition has a constraint like  Real a => ...
19:46:08 <crucify_me> Cale can't really follow but really appreciate your efforts..
19:46:17 <Cale> that gets compiled into a function parameter like
19:46:22 <Cale> RealD a -> ...
19:47:01 <Cale> and wherever you might use toRational, it extracts the corresponding field of the record that was passed in to obtain the operation
19:47:29 <Cale> (and if you use Ord or Num operations, it can unpack those as well)
19:49:23 <crucify_me> so in layman's terms, when you have a product type (indicated by the tuple construction) you generate values through multiplication that are used by haskell to calculate / evaluate more efficiently, for example?
19:49:26 <crucify_me> Cale
19:49:39 <xa0> @pl \x -> map (a . map $ flip c x) d
19:49:39 <lambdabot> flip map d . a . map . flip c
19:49:40 <Cale> It's not numerical multiplication
19:49:53 <Cale> It's only an abstract sort of "multiplication" of types
19:50:11 <crucify_me> Cale, dang ,can't wait to understand it. thanks!!
19:50:19 <Cale> Where the product of two types A and B is the type of pairs (a,b) where a has type A, and b has type B
19:50:33 <Cale> That's all it means
19:50:36 <erisco> count the inhabitants
19:53:05 <crucify_me> so its a third type that is generated, that has a sort of signature that is used by the interpreter/ compiler 
19:54:07 <Cale> Yeah, maybe we're talking about too many things at once here. I was talking about the implementation of type classes, but you can also just talk about product or tuple types of ordinary types separately.
19:54:26 <Cale> So if we have data Colour = White | Black and data Piece = Pawn | Knight | Bishop | Rook | Queen | King
19:54:41 <Cale> Then the type which in Haskell we'd write as (Colour, Piece)
19:54:55 <Cale> Or more generally, might be written Colour × Piece
19:55:15 <Cale> will consist of the pairs (c,p) where c :: Colour and p :: Piece
19:55:22 <Cale> e.g. (Black, Knight)
19:55:46 <Cale> Colour has two (defined) elements, and Piece has 6
19:55:49 <crucify_me> Cale thanks so much . getting kicked out of cafe. more drama later. pax
19:55:54 <Cale> Notice that (Colour, Piece) has 12
19:55:58 <Cale> = 2 * 6
19:56:15 <Cale> see you!
19:56:22 <crucify_me> got that 6 pieces. thanks again
20:03:15 <platz> the default ByteString exported by Data.ByteString is Data.ByteString.Char8 ?
20:03:38 <Cale> uh
20:03:48 <Cale> Data.ByteString.Char8 and Data.ByteString export the same type
20:04:02 <Cale> But the operations in .Char8 are different, and regard the bytes as characters
20:05:10 <Cale> (It just truncates to 8 bits and regards the result as a unicode character in the 0-255 range, which is weird, so usually best not to use that)
20:05:37 <Cale> Well, "truncates" -- it only looks at one byte at a time, regardless of what you might be reading :)
20:05:59 <dsal> How do I apply a mask to an Int16?
20:06:15 <platz> ah interesting.  just playing bytestring tetris and thought the Char8 was opt-in, but as you say it's the default type
20:06:20 <Cale> (.&.) from Data.Bits?
20:06:26 <platz> compared to Data.ByteString.Lazy 
20:06:34 <c_wraith> I mean, .Char8 works well-enough if you're only dealing with ASCII characters.  But any case where user input is involved and it gets hairy
20:06:42 <erisco> where are our quotient types
20:07:30 <dsal> Cale: Ah, thanks.  I figured out why that wasn't working for me.
20:07:50 <geekosaur> CHar8 is opt-in, you have to import that module and use its versions of functions
20:07:50 <platz> right, but for example a  librarie on hackage that use import Data.ByteString (ByteString) are uses the Word8/Char representation
20:08:04 <geekosaur> but the underlying type is the same
20:08:18 <geekosaur> that said, ByteString is always limited to 0..255; it is a byte string, after all
20:08:46 <geekosaur> the underlying representation acts like Word8 always. the Char8 module is basically a hack that exposes the Word8-s as truncated Char-s
20:08:56 <c_wraith> geekosaur: 8-bit chauvinism! 
20:08:58 <platz> ok well good to know, i getting confused by what i was seeing in GHCI but it makes sense now
20:09:09 <c_wraith> geekosaur: some perfectly fine obsolete architectures used 9-bit bytes!
20:09:21 <platz> thanks
20:09:28 <geekosaur> I'm quite aware...
20:09:48 <c_wraith> I expect you have first-hand experience with some of them. :)
20:09:58 <geekosaur> (actually worse than that, they used 6 or 9 depending on which op mask you specified in assembly code)
20:10:35 <c_wraith> which is that?  PDP-11?
20:10:42 <geekosaur> pdp10
20:10:53 <c_wraith> ah
20:10:58 <geekosaur> pdp11 used 8-bit bytes
20:11:23 <c_wraith> that must have been a real shock to the people updating software for the new system
20:11:28 <geekosaur> pdp10 was a mainframe and you could use a mask parameter on registers to specify contiguous 3-bit subranges
20:11:30 <geekosaur> on a 36-bit word
20:11:56 <erisco> it's like people were just making stuff up
20:12:13 <geekosaur> actually it was intended for compatibility
20:12:14 <c_wraith> like we're making stuff up any less nowadays...
20:12:29 <geekosaur> various DEC minis used 6, 12, 18 bit words
20:13:01 <geekosaur> and at least one was 9-bit. (DEC liked 3s)
20:13:25 <c_wraith> what did the alpha use?
20:13:28 <geekosaur> so you could use register masks on pdp10 to slice its 36-bit words compatibly for their other platforms
20:13:36 <geekosaur> alpha was standard 8-bit byte.
20:13:45 <c_wraith> I still remember altavista existing as an advertisement for the existence of the alpha
20:14:07 <geekosaur> could mask 64-bit machine words at various 8-bit chunks iirc
20:15:28 <geekosaur> IBM 360's 8-bit bytes won. DEC gave up and newer hardware (pdp11, vax-11, mips-based stuff, alpha) used that
20:20:46 <wilornel> I'm confused about how `traverse (Constant . (+1)) ([1,2,3,4,5] :: [Sum Integer])  results in Constant (Sum {getSum = 20})
20:24:29 <c_wraith> wilornel: Constant is usually called Const..  Did you define your own?
20:24:45 <wilornel> I am reading "Haskell Programming from First Principles"
20:25:03 <wilornel> can one run a haskell command in this  irc channel?
20:25:15 <c_wraith> yes
20:25:17 <wilornel> > x = 1
20:25:19 <lambdabot>  <hint>:1:3: error:
20:25:19 <lambdabot>      parse error on input ‘=’
20:25:19 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
20:25:23 <wilornel> > let x = 1
20:25:26 <lambdabot>  <no location info>: error: not an expression: ‘let x = 1’
20:25:34 <wilornel> > putStrLn "a"
20:25:35 <Hafydd> What is a "Haskell command"?
20:25:36 <lambdabot>  <IO ()>
20:25:38 <c_wraith> > traverse (Const . (+1)) ([1,2,3,4,5] :: [Sum Integer])
20:25:40 <lambdabot>  Const (Sum {getSum = 20})
20:25:45 <wilornel> alright, there
20:26:04 <wilornel> there is a library that shows the Expr that becomes this final value
20:26:18 <c_wraith> simple-reflect, I believe
20:26:21 <wilornel> ah! yes
20:26:39 <wilornel> Is it possible to have this expression be shown with simple-reflect?
20:26:57 <c_wraith> with a bit of modification, sure..
20:27:23 <c_wraith> > traverse (Const . (+1)) ([a,b,c,d,e] :: [Sum Expr])
20:27:26 <lambdabot>  error:
20:27:26 <lambdabot>      • Couldn't match expected type ‘Sum Expr’ with actual type ‘Expr’
20:27:26 <lambdabot>      • In the expression: a
20:27:34 <c_wraith> Oh, right.
20:27:51 <c_wraith> > traverse (Const . (+1) . Sum) ([a,b,c,d,e] :: [Expr])
20:27:53 <wilornel> > traverse (Const . (+1)) ([a,b,c,d,e])
20:27:53 <lambdabot>  Const (Sum {getSum = a + 1 + (b + 1 + (c + 1 + (d + 1 + (e + 1 + 0))))})
20:27:55 <lambdabot>  Const ((a + 1) <> (b + 1) <> (c + 1) <> (d + 1) <> (e + 1) <> mempty)
20:28:23 <wilornel> traverse (Identity . (+1) . Sum) ([a,b,c,d,e] :: [Expr])
20:28:26 <wilornel> > traverse (Identity . (+1) . Sum) ([a,b,c,d,e] :: [Expr])
20:28:29 <lambdabot>  Identity [Sum {getSum = a + 1},Sum {getSum = b + 1},Sum {getSum = c + 1},Sum...
20:28:40 <wilornel> that's confusing! Identity vs Const
20:29:05 <c_wraith> wilornel: so most of the magic is in traverse
20:29:40 <wilornel> in the case of traverse, do we end up with `sequence [Const 2, Const 3, Const 4, Const 5, Const 6]` at some point?
20:30:00 <wilornel> (where these integers are Sum Integers)
20:30:47 <c_wraith> I don't know that it actually goes through that representation, but that is certainly equivalent
20:31:28 <wilornel> I see, so it is equivalent. Now, I don't understand how to go from that representation to Const (Sum {getSum = 20}). I think that I do not understand `sequence`
20:32:09 <wilornel> is it like doing `foldr mempty [Const 2, Const 3, Const 4, Const 5, Const 6]` ?
20:32:36 <wilornel> (and then flipping the foldable with the functor somehow)
20:32:53 <c_wraith> more like foldr (liftA2 (:)) (pure []) ...
20:33:18 <c_wraith> The important thing is that sequence works on the Applicative effects
20:33:28 <wilornel> flipping the foldable with the monad* somehow
20:33:37 <wilornel> hmmm
20:34:11 <wilornel> so the difference in the applicative effects between Identity and Const is what's making one sum everything up and the other keeping the elements apart
20:34:34 <c_wraith> Identity's Applicative effects are "no effect". 
20:35:25 <wilornel> the applicative effect is the <*> , right?
20:36:03 <c_wraith> basically yes.  I'd word it a bit differently - I'd say that <*> is what applies the Applicative effect.  But I think you mean the same thing I do.
20:36:34 <c_wraith> So, Const is more complicated than Identity in an important way.
20:36:45 <c_wraith> Const has two type parameters, Identity only has one.
20:36:48 <wilornel> (found this (<*>) :: Const * m (a -> b) -> Const * m a -> Const * m b)
20:37:21 <c_wraith> Man, those polykinded kind markers are really confusing.
20:38:02 <c_wraith> Just pretend those *s after Const aren't there. :)
20:38:18 <erisco> isn't that just Haddock's weird way of printing it?
20:38:18 <wilornel> yes, I don't understand them hahah
20:38:29 <wilornel> found here: https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor-Const.html
20:38:32 <c_wraith> erisco: yes, it's just what haddock does when a type is polykinded
20:39:09 <c_wraith> wilornel: it's a documentation thing for a more advanced type system feature that the module has enabled but is totally irrelevant for this. So.. ignore them. :)
20:39:31 <wilornel> cool!
20:39:49 <wilornel> I've been thinking about it and I guess it does something like: Const Sum (0 +) <*> Const Sum 2 <*> Const Sum 3 ... ?
20:40:01 <wilornel> Where Sum 2 are two individual arguments to Const?
20:40:28 <dsal> I'm trying to use stack to do a thing.  How do you name files?  I created a package APRS.Types.  Trying to test it.  
20:40:31 <c_wraith> I'm afraid not.  This is why I said Const is  more complicated than Identity.
20:41:12 <c_wraith> wilornel: the key thing is that the Const *type* constructor takes 2 types as arguments, but the Const *value* constructor only takes 1 value as an argument
20:41:44 <wilornel> This is VERY confusing hahah
20:41:50 <wilornel> Oh wait
20:42:43 <wilornel> So if I have Const 5, then one type is Integer, and what's the other type? We declare it with `::` ?
20:43:09 <c_wraith> wilornel: it's whatever type is required for the expression to type check.
20:43:12 <erisco> is Const a first principle? interesting
20:43:14 <wilornel> I see
20:43:32 <c_wraith> wilornel: the second type parameter of Const is called a "phantom type"
20:43:43 <c_wraith> wilornel: that's because it doesn't appear in the value anywhere.
20:43:48 <wilornel> yes! I was going to say this term but was not sure
20:44:00 <wilornel> I never read much about phantom types and why they are useful
20:44:56 <c_wraith> They have at least two independent use cases.  Sometimes they're used to signal extra information about a type.  In this case, they're used to make type signatures fit together when they otherwise wouldn't
20:45:00 * hackagebot Yampa 0.10.6.1 – Library for programming hybrid systems. – https://hackage.haskell.org/package/Yampa
20:45:38 <wilornel> Still thinking about how to see it: Const (Sum 2 +) <*> Const 3 <*> Const 4 ... ?
20:45:42 <erisco> they can also be dependent on other types, which is useful
20:45:55 <wilornel> Interesting, the "make type signatures fit together when they otherwise wouldn't"
20:46:10 <c_wraith> wilornel: if you throw out that +, yes. :)
20:46:45 <wilornel> But how is `Sum 2` a :: `m (a -> b)` ?
20:46:51 <c_wraith> It's not!
20:47:08 <wilornel> *confused*
20:47:10 <c_wraith> Well, ok, yes it is. :)
20:47:29 <wilornel> *desufnoc*
20:47:29 <c_wraith> m = Const (Sum Int)
20:47:51 <c_wraith> You know how I said the last type variable can be *whatever* it takes to make the types work out?
20:47:56 <wilornel> yes
20:48:41 <c_wraith> well, if m = Const (Sum Int), that means it can unify just fine with m (a -> b)
20:48:42 <wilornel> (a -> b) is the second type
20:48:50 <wilornel> aha!
20:49:11 <c_wraith> However, that isn't actually what traverse builds. :)
20:49:27 <wilornel> but then as per the type definition of <*>, we need Const (Const (Sum Int)) (a -> b)
20:49:29 <c_wraith> I was a bit mistaken there.
20:49:44 <wilornel> oh wait
20:50:41 <wilornel> Const a b is the type, and `instance Applicative (Const a) where`, and so (a -> b) is " wrapped" by (Const a) and if we build `Const (Sum Integer)`, that is our `Const a`
20:50:42 <c_wraith> traverse actually constructs pure (:) <*> Const (Sum 2) <*> (pure (:) <*> Const (Sum 3) <*> ...
20:50:44 <wilornel> ok I think I see it
20:51:18 <wilornel> pure (:) would become `Const (Sum 0)` in order to typecheck properly
20:51:33 <c_wraith> wilornel: that is exactly what it becomes, yes
20:52:30 <wilornel> and what is the function? What declares it?
20:52:51 <wilornel> this looks like foldr a little bit btw
20:53:02 <c_wraith> It can be written with a foldr
20:53:23 <c_wraith> sequence for [] is foldr (liftA2 (:)) (pure [])
20:53:37 <wilornel> I see
20:54:17 <wilornel> but still the function for Const is not clear. Is it Sum's Applicative's function? How does it figure that out? Oh, it needs to typecheck
20:55:10 <c_wraith> wilornel: the secret of <*> for Const is that the function never actually exists. :)
20:55:27 <c_wraith> wilornel: as long as the types line up, there's no function to apply, and no value to apply it to.
20:56:29 <c_wraith> wilornel: you actually demonstrated that when you evaluated pure (:) to Const (Sum 0)
20:56:49 <c_wraith> wilornel: (:) was the function.  It completely vanishes!
20:56:51 <wilornel> hmmm and then there's no need for a function then? It's a sort of placeholder to make Const a an Applicative? Why have a function for the second type? Why not a normal type?
20:56:57 <wilornel> hmmmm
20:57:59 <wilornel> I see I see! And then Const (Sum 0) <*> Const (Sum 2) will become Const (Sum 0 + Sum 2) because we are using (:) and that becomes Sum's monoidal function, (+)
20:58:12 <c_wraith> wilornel: that's correct
20:58:33 <wilornel> but then is Identity 2 <*> Identity 3 just becoming [Identity 2, Identity 3]?
20:58:54 <wilornel> I looked at https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Functor-Identity.html and am not sure what coerce means
20:58:59 <c_wraith> wilornel: well, Identity 2 <*> Identity 3 won't usually type check.  It only will if it can make 2 a function
20:59:55 <c_wraith> wilornel: remember with Const, the values inserted by pure never actually exist, because it's working on a phantom type
21:00:08 <c_wraith> wilornel: in contrast, Identity doesn't have a phantom type.
21:00:09 <dsal> Super confused.  'stack ghci' loads my module (APRS.Types), but I can't access any of the things from inside it.  regular ghci + :l does the right thing.  What am I missing?
21:00:58 <wilornel> hmmmm so how does it mappend them together? We end up with Identity [2] <*> Identity [3] ?
21:01:17 <pacak> dsal: "stack" part is wrong then.
21:01:34 <c_wraith> wilornel: the mappend only came from the Applicative instance for Const
21:01:39 <dsal> pacak: I'm certain I'm doing all kinds of things wrong...
21:01:57 <c_wraith> wilornel: With Identity, mappend never shows up.  It's not part of its Applicative instance
21:01:58 <dsal> Trying to get stack test to work.  Says it can't find constructor for my type.  'stack ghci' also can't, so that's good, I guess.
21:02:25 <penteract> dsal: is it exported?
21:02:33 <dsal> I... think so?
21:02:44 <MarcelineVQ> is the module exposed in your cabal file?
21:02:55 <wilornel> I'm not sure how do they become a list in that case
21:02:59 <dsal> AFAICT.  My prompt comes up like this:  *Main APRS APRS.Types> 
21:03:15 <dsal> It claims to have loaded the file.  I just can't see that it got any symbols from it.
21:04:07 <c_wraith> wilornel: I don't know how it became a list either. :)  I think you applied something incorrectly. :)
21:04:20 <MarcelineVQ> dsal: then the next step is to lpaste your project's .cabal file and the module you're having issues with, and the exact things you type to get the issue
21:04:21 <erisco> you know, I hadn't looked at Const's Applicative instance and I am surprised it satisfies the laws
21:04:54 <c_wraith> erisco: Applicative's effects are a monoidal structure.  Const happens to match that perfectly. :)
21:04:58 <wilornel> > traverse (Identity . (+1)) [1,2]
21:04:58 <dsal> cabal: http://lpaste.net/1354826465492860928
21:05:00 <lambdabot>  Identity [2,3]
21:05:27 <c_wraith> wilornel: Yes, a list does show up in the final value, but it doesn't happen via the intermediate representation you provided
21:05:37 <dsal> types.hs:  http://lpaste.net/357756
21:06:02 <c_wraith> wilornel: the list in the final value comes from the pure (:) <*> Identity 1 <*> (pure (:) <*> Identity 2 <*> ...
21:06:20 <erisco> c_wraith, what is the structure?
21:06:39 <wilornel> > traverse (Const . (+1)) [1,2]
21:06:41 <c_wraith> wilornel: with Identity, those (:) constructors actually get used
21:06:42 <lambdabot>  error:
21:06:42 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M548357030252...
21:06:42 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
21:06:51 <MarcelineVQ> dsal: Frame, PacketType, Address, only exports the type, PacketType(..) exports the dataconstructors too
21:06:56 <wilornel> > traverse (Const . (+1)) ([1,2] :: Sum Integer)
21:06:59 <lambdabot>  error:
21:06:59 <lambdabot>      • Couldn't match expected type ‘Sum Integer’
21:06:59 <lambdabot>                    with actual type ‘[Integer]’
21:07:04 <wilornel> > traverse (Const . (+1)) ([1,2] :: [Sum Integer])
21:07:06 <lambdabot>  Const (Sum {getSum = 5})
21:07:11 <wilornel> > traverse (Identity . (+1)) ([1,2] :: [Sum Integer])
21:07:13 <lambdabot>  Identity [Sum {getSum = 2},Sum {getSum = 3}]
21:07:16 <dsal> MarcelineVQ: ah.  Interesting.
21:07:32 <wilornel> hmmmm how is the (:) used in the Identity case vs the Const case
21:07:37 <wilornel> in the Const case they are just not used
21:07:43 <wilornel> and in the Identity case they are used
21:07:51 <c_wraith> yes, that's exactly the difference
21:07:57 <wilornel> Identity (:) <*> Identity 2 <*> Identity 3
21:08:12 <wilornel> Ah!
21:08:25 <wilornel> woah, Const is a bit confusing
21:08:27 <c_wraith> wilornel: well, that won't type check, but it's the right idea. :)
21:09:02 <wilornel> Identity (:) <$> Identity 2 <*> Identity 3 ?
21:09:19 <wilornel> > (:) <$> Identity 2 <*> Identity 3
21:09:22 <lambdabot>  error:
21:09:22 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M119048174790...
21:09:22 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
21:09:28 <c_wraith> wilornel: 	Identity (:) <$> Identity 2 <*> Identity [3]  would type check
21:09:34 <wilornel> huh
21:09:38 <c_wraith> wilornel: remember that the second argument to (:) needs to be a list
21:09:49 <wilornel> so how does it know it make it a list?
21:10:00 <c_wraith> It's the base case for sequence.
21:10:00 <koz_> wilornel: Try :t (:)
21:10:05 <wilornel> :t (:)
21:10:07 <lambdabot> a -> [a] -> [a]
21:10:13 <wilornel> > 1 : 2 : 3
21:10:16 <lambdabot>  error:
21:10:16 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M682632133254...
21:10:16 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
21:10:24 <wilornel> > 1 : 2 : 3 :: Integer
21:10:24 <c_wraith> The base case for sequence is sequence _ [] = pure []
21:10:25 <koz_> Same issue as you had previously.
21:10:27 <lambdabot>  error:
21:10:27 <lambdabot>      • Couldn't match expected type ‘Integer’ with actual type ‘[a0]’
21:10:27 <lambdabot>      • In the expression: 1 : 2 : 3 :: Integer
21:10:32 <wilornel> > 1 : 2 : 3 :: [Integer]
21:10:34 <lambdabot>  error:
21:10:35 <lambdabot>      • No instance for (Num [Integer]) arising from the literal ‘3’
21:10:35 <lambdabot>      • In the second argument of ‘(:)’, namely ‘3’
21:10:38 <koz_> > 1 : 2 : [3]
21:10:41 <lambdabot>  [1,2,3]
21:10:45 <wilornel> ah! right, sorry
21:10:48 <wilornel> I'm not fully there
21:10:52 <wilornel> like cons
21:11:00 <koz_> : is cons, quite literally.
21:11:48 <wilornel> Ah! So we had 3:[] a the very deepest level of foldr in there
21:11:52 <wilornel> at the*
21:11:57 <c_wraith> wilornel: exactly
21:11:59 <wilornel> c_wraith is that what you mean
21:12:02 <wilornel> ok good!
21:12:12 <dsal> Well, ghci works now, but not tests.  I guess that's closer.
21:12:19 <wilornel> Awesome~!
21:13:13 <dsal> Anyone have a good example of a small project with tests using stack I can look at?
21:14:08 <c_wraith> erisco: newtype FromApp f = FA (f ()) ; instance Applicative f => Monoid (FromApp f) where mempty = FA (pure ()) ; mappend (FA x) (FA y) = FA (x *> y)
21:14:16 <koz_> dsal: run 'stack new foo-bar simple'
21:14:21 <koz_> That'll give you a good starting point.
21:14:54 <c_wraith> erisco: You can use the Applicative laws to prove that Monoid instance is valid.  That's what I mean by "Applicative's effects have a monoidal structure"
21:15:27 <dsal> koz_: That gives me less than what I had.  :)  Right now, I'm just trying to figure out how to run tests.
21:15:28 <wilornel> thank you c_wraith and koz_
21:15:46 <koz_> dsal: Ah,you need tests specifically.
21:15:55 <dsal> Yeah, I think that's the last piece I don't quite have.
21:16:06 <dsal> My tests can't get to my types.
21:16:52 <koz_> dsal: Sorry then - I've not had to deal with this (yet).
21:17:43 <dsal> It creates Spec.hs -- not sure if it wants me to use hspec or something.  I don't really want to do that.
21:27:46 <kadoban> dsal: Almost positive it's not opinionated, you can use whatever you want.
21:28:04 <dsal> I'm trying just hunit.  It's just not finding my code.
21:28:12 <kadoban> dsal: As to getting to your types, usually you put everything in a library, then use that library in the executable and in the tests.
21:28:35 <kadoban> The test-suite doesn't have any magic access, you have to depend on the library and make sure it exports the stuff you're using.
21:28:51 <dsal> kadoban: It gave me Lib.hs at first, but I wanted to import as APRS.Types.
21:28:53 <dsal> Oh, I thought there was magic.
21:29:41 <kadoban> Doesn't matter how you structure your modules, that's up to you. As long as they're in the library part, you can import them in your tests (after you depend on the library in the test-suite's build depends in the .cabal file.
21:30:23 <dsal> output was redirected with -o, but no output will be generated because there is no Main module
21:31:44 <kadoban> dsal: Your Spec.hs or whatever should be the main module. Make sure it says module Main    at the top, or also should work with no module declaration. If it's not that' need more context, feel free to gist.github.com the .cabal file and some relevant files.
21:32:10 <dsal> Oh hey!  Seems to be it.
21:41:58 <dsal> What's the opposite of intercalate?
21:43:40 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
21:43:40 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:12 2017]
21:51:17 <erisco> c_wraith, I need  pure (\_ b -> b) <*> x <*> pure () = x
21:51:52 <erisco> which is probably relevant to why the f is stuffed with unit
21:53:17 <glguy> Was there just a large network split?
21:53:22 <xa0> no
21:53:30 <xa0> some dumb netop banned half of freenode
21:53:56 <glguy> xa0: That would explain my kline message. Does this mean that the ban has been resolved?
21:54:02 <xa0> yep
21:54:07 <Zowlyfon> xa0: or a netbot went crazy
21:54:13 <glguy> OK, thanks.
21:55:11 <erisco> dsal, it is not reversible
22:18:32 * hackagebot SSTG 0.1.1.7 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
22:19:45 <glguy> The k-line made #haskell temporarily the most populated channel on Freenode ^_^
22:24:37 <ab9rf> there was a k-line?
22:24:45 <ab9rf> wow, wtf
22:25:18 <ab9rf> i have joins/parts/quits muted in here, i had to go to another channel to see the chaos
22:38:26 <Axman6> dsal: you want something that splits based on a a given element?
22:38:38 <dsal> Yeah.  I got something working reasonably.
22:40:46 <ab9rf> fairly easy with parsec :)
22:41:25 <dsal> Does anyone know Read class?  I don't quite understand how to satisfy it properly.
22:41:31 <dsal> (I'm satisfying it improperly in the meantime)
22:43:31 <pavonia> Probably everyone here knows the Read class. You should ask more specific questions
22:46:57 <dsal> How do you typically write something for it?  readsPrec wants an int (which I just ignore).
22:50:17 <dsal> Oh, I found a thing that at least describes what it is.
22:50:56 <norc_> If I have a polymorphic function such as foo :: Num a => [Integer] -> [a], is there a compact way to select a specific type, or do I just have to explicitly do `q :: [Integer] -> [Double]; q = foo` ?
22:52:08 <kadoban> norc_: You want to define a new, less general name, or you're just trying to use the thing?
22:53:26 <norc_> kadoban: Well the function is defined as foo = fromInteger, so I was hoping I could do something along C++ lines of foo<Double> [1,2,3]
22:54:26 <kadoban> Not really, just giving a type annotation like you showed is best. Or just ... don't create that function and just use fromInteger directly.
22:54:34 <erisco> c_wraith, do you know how to finish the proof?
22:54:57 <norc_> kadoban: Oh and my bad, its actually defined as `foo = fmap fromInteger` :-)
22:55:09 <kadoban> Ya I wondered a bit :)
22:55:31 <norc_> kadoban: Is there a way to do the type annotation inline? 
22:56:08 <norc_> Ohh
22:56:10 <norc_> (foo :: [Integer] -> [Double]) [1,2]
22:56:11 <kadoban> You can do  q = foo :: [Integer] -> [Double]   , but it's not quite the same thing in all cases, and tools might still give you a warning.
22:56:18 <kadoban> Oh that, yeah you can do that.
22:56:38 <norc_> I mean.. where/let and defining this thing seems more sensible
22:56:39 <Enigmagic> norc_: with newer ghc (8.0 iirc) you can do `foo @Int [x, y, z]` by enabling TypeApplications
22:57:24 <norc_> Enigmagic: Oh yes! That's exactly what I was looking for. :-)
22:57:28 <MarcelineVQ> reaching for @ shouldn't be your first reaction
22:57:57 <norc_> MarcelineVQ: Oh I'm just laying out the puzzle pieces, just care to know they exist.
23:00:05 <norc_> Enigmagic: ghc: panic! (the 'impossible' happened)
23:00:06 <norc_> Heh!
23:00:15 <nshepperd> foo [1, 2, 3] :: [Double]
23:00:17 <norc_> That was fast!
23:00:41 <norc_> nshepperd: Oh that is interesting, so that is haskell inferring the type backwads?
23:00:56 <halogenandtoast> I wrote a small blog post realated to Haskell and I was wondering if anyone would be willing to read/fact check it before I publish it: http://www.halogenandtoast.com/p/387b636b-3e07-410a-aabe-75e226cb1e6e/
23:01:03 <nshepperd> once you actually use foo somewhere where the result is used, the type will be inferred from its context
23:01:37 <nshepperd> norc_: haskell can infer types in all directions! forwards, backwards, sideways
23:03:34 <Enigmagic> norc_: dunno, i haven't used it much... but on 8.2.1 this works:
23:03:46 <Enigmagic> > foo :: Num a => [Integer] -> [a]; foo = fmap fromInteger
23:03:53 <Enigmagic> > foo @Double [1,2,3,4]
23:04:01 <norc_> Enigmagic: Hooray! Not even a week into haskell and I found the first reproducible bug.
23:04:04 <norc_> I have a talent for this.
23:04:17 <erisco> darn newcomers coming in and using it all wrong...
23:04:19 <norc_> Enigmagic: It requires a series of things to do in GHCi first.
23:04:27 <MarcelineVQ> 8.0.2 has a few foibles with @ which are likely fixed in 8.2
23:04:43 <norc_> stack gave me 8.0.2 :S
23:05:10 <EvanR> is 8.2 out yet
23:05:22 <Enigmagic> yes
23:05:26 <kadoban> 8.2.1 is released, yeah.
23:05:29 <halogenandtoast> https://mail.haskell.org/pipermail/ghc-devs/2017-July/014422.html
23:05:31 <EvanR> nice
23:05:59 <norc_> Is there a way to tell stack to install a specific version of ghc?
23:06:08 <MarcelineVQ> just as well, there's no rush to jump to 8.2 and @ really shouldn't be your first reaction to supplying types
23:06:19 <kadoban> norc_: Use one of the recent nightlies instead of an lts, it has GHC 8.2.1 already.
23:06:35 <halogenandtoast> norc_: see https://www.reddit.com/r/haskell/comments/6oz5q3/announce_ghc_821_available/dklr7kl/
23:06:43 <halogenandtoast> or use a nightly I guess
23:12:49 <erisco> halogenandtoast, looks good, especially since I am a sucker for pointfree. I have not heard "Applicative context" used to refer to the f of f (a -> b)
23:13:08 <halogenandtoast> erisco: how would you describe it?
23:13:11 <norc_> Okay the bug is fixed. :(
23:13:18 <halogenandtoast> I was at a loss for words on that one.
23:14:26 <norc_> One thing I've really been curious though. How does my linter know that lengthList [] = 0; lengthList (x:xs) = 1 + lengthList xs is the same as lengthList xs = foldr (\ x -> (+) 1) 0 xs ?
23:15:15 <halogenandtoast> norc_: the better question is why doesn't it use section to make that look nicer.
23:15:24 <erisco> halogenandtoast, f is an Applicative, and (a -> b) is applied to f or mapped by f
23:15:39 <erisco> maybe someone else has some phraseology for you
23:15:52 <norc_> halogenandtoast: Well, it does look nicer. But turns out that IRC does not allow line breaks in messages. ;-)
23:16:08 <norc_> Or do you mean that it should auto fix it?
23:16:18 <halogenandtoast> norc_: Oh I mean foldr (1+) 0 xs or foldr (+1) 0 xs
23:16:38 <halogenandtoast> oh nevermind
23:16:49 <halogenandtoast> you're ignoring the x
23:16:51 <halogenandtoast> I can't read
23:16:52 <norc_> You just made me stare at the type with confusion
23:17:03 <norc_> Heh
23:17:32 <dsal> I don't understand the function argument of maybe.  When do you use something other than id?
23:17:35 <halogenandtoast> still could do foldr (const (+1)) 0 xs
23:17:48 <erisco> halogenandtoast, you could probably also say the function type is lifted
23:18:02 <halogenandtoast> erisco: I'll go with that
23:18:16 <lipkab> Hi everyone, https://www.haskell.org/news has been down for a day or two.
23:18:26 <lipkab> Is this the right place to report that?
23:18:42 <EvanR> dsal: it lets you do anything thats possible to do with the Maybe
23:18:44 <\u> WHy is https://github.com/malcolmwallace/cpphs empty
23:18:50 <Axman6> possibly #haskell-infrastructure
23:18:55 <erisco> I understood what you meant but contexts are what go to the left of =>, so it sounds like you're saying Applicative (a -> b) =>
23:18:58 <EvanR> if it assumed id, you could not
23:19:11 <EvanR> without pattern matching of course, which maybe is letting you avoid
23:19:19 <halogenandtoast> erisco: I always called those constraints
23:19:26 <dsal> I guess I figured I'd put the function on the outside, but I guess I'll imagine for now.  :)  It just confused me momentarily.
23:19:35 <erisco> halogenandtoast, constraints are what you find in a context :)
23:19:37 <EvanR> how would you
23:19:58 <halogenandtoast> erisco: fair enough!
23:20:08 <EvanR> it wouldnt be able distinguish between Just and Nothing
23:20:44 <EvanR> unless you do, maybe Nothing Just :)
23:20:51 <halogenandtoast> erisco: thanks so much for reading it and giving feedback!
23:21:00 <dsal> Yeah, it makes sense.
23:21:01 <lipkab> Axman6: Ok, thanks!
23:21:12 <EvanR> (which is pointless)
23:22:04 <erisco> halogenandtoast, year and a half since the last post... tsk tsk ;)
23:22:20 <erisco> oh, two and a half
23:24:09 <erisco> dsal, there is a deeper reason why it is defined that way
23:25:33 <erisco> dsal, the way you create a Maybe A is either Nothing :: Maybe A or Just x :: Maybe A where x :: A
23:26:16 <erisco> dsal, and so there must be a dual way to deconstruct it, which is why it is maybe :: (a -> b) -> b -> Maybe a -> b
23:26:17 <halogenandtoast> erisco: Yeah, well, I was trying to write a programming language in C as a series of blog posts
23:26:20 <halogenandtoast> you know how that goes.
23:27:24 <erisco> :t \j n m -> case m of Just x -> j x; Nothing -> n; -- dsal it is so it corresponds exactly to how you do case analysis
23:27:26 <lambdabot> (t1 -> t) -> t -> Maybe t1 -> t
23:28:51 <erisco> halogenandtoast, I know how having a blog goes, yes ... made about 10 posts myself and forgot about it
23:29:00 <dsal> Yeah, it does make sense.  Just not exactly how I'm using it here. heh
23:30:05 <Axman6> maybe id = fromMaybe
23:30:13 <erisco> dsal, if it was not defined that way then it would not be what is called "complete"
23:30:37 <dsal> Yeah, I can understand that.
23:30:53 <erisco> you understand completeness? well, darn, because that is fun to explain :P
23:30:58 <dsal> OK, so my Read…   If I return (t, " stuff") I get "no parse"  Is that normal?
23:31:17 <dsal> I understand why it's useful to have it there.  :)  I'm a bit overdue for bedtime.
23:32:13 <erisco> well for anyone listening in... to be complete to have to be able to reconstruct the same data
23:32:22 <erisco> :t maybe Just Nothing
23:32:24 <lambdabot> error:
23:32:24 <lambdabot>     • Couldn't match expected type ‘a1 -> a -> Maybe a’
23:32:24 <lambdabot>                   with actual type ‘Maybe a0’
23:32:28 <MarcelineVQ> why are you guys flipping the args to maybe :o
23:32:34 <dsal> erisco: Oh, that makes a lot of sense, yeah.
23:32:56 <erisco> :t maybe Nothing Just
23:32:57 <lambdabot> Maybe a -> Maybe a
23:33:06 <erisco> apparently it is the other way around =\ but there you go, a proof
23:33:52 <erisco> MarcelineVQ, because foldr has it the other way
23:34:23 <EvanR> @src Maybe
23:34:23 <lambdabot> data Maybe a = Nothing | Just a
23:34:27 <EvanR> @src []
23:34:28 <lambdabot> data [] a = [] | a : [a]
23:34:35 <EvanR> inconsistent!
23:36:15 <MarcelineVQ> looks more like foldr is the inconsistent one compared to maybe and bool and Maybe and Bool and []'s constuctor orders, oh well
23:37:33 * hackagebot shakespeare 2.0.14 – A toolkit for making compile-time interpolated templates – https://hackage.haskell.org/package/shakespeare
23:38:59 <erisco> [] does not actually have source ;)
23:41:24 <erisco> and one of the largest channels has not seen said spam? interesting
23:42:25 <MarcelineVQ> erisco: it does, but it's not exposed, and in addition to that it's build-in syntax, so it's a bit of a vague subject :(
23:43:17 <MarcelineVQ> what I​ mean by it does is:  ghc/libraries/ghc-prim/GHC/Types.hs:106   data [] a = [] | a : [a]
23:54:46 * hackagebot recursion-schemes-ext 0.1.1.0 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
23:59:04 <boj> is there anything like an abitrary IO transaction monad? i have a case where i need to run 3 IO actions, but if any of them fails i need to rewind the other 2. just curious if something existed before i dug in
23:59:40 <erisco> sounds like transactional memory
23:59:42 <Hafydd> I would also be interested in a method for undoing arbitrary IO actions.
23:59:54 <cocreature> boj: I’m not sure how that’s supposed to work. how do you rewind an arbitrary io action
