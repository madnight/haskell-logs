00:00:29 <erisco> I thought it'd have to be  [re|;[a-z]+\.(mp3|flac|aac)|]
00:01:32 <erisco> I can't remember if I allowed the semicolon to be implicit...
00:01:42 <erisco> but anyways, you need to anchor to the beginning and end of the string
00:01:49 <erisco> that matches ers.mp3
00:01:50 <ab9rf> thre's a quasiquoter for regexps?
00:02:05 <erisco> yes :) it is for tdfa
00:02:08 <ab9rf> ah, that's not a fixed match? then it'll match on "atters.mp3"
00:02:18 <ab9rf>  .;/'
00:02:25 <foojs> hi there
00:02:28 <erisco> right, t is not a capital... must be getting late :P
00:02:32 <ab9rf> sorry, my keyboard fell
00:02:47 <ab9rf> erisco: some letters are very hard to classify as upper case :)
00:02:56 <foojs> i like erlang its funny better than haskell
00:03:02 <erisco> start anchor is probably ^ and end anchor is probably $
00:03:18 <koz_> Mutable vectors in combination with monad stacks are causing my brain to melt.
00:03:20 <ab9rf> probably :)
00:03:23 <norc_> jle`: Aha! So it essentially ends up with some constraint violation when it tries to match that given constraint Num ((a -> a -> a) -> t -> t1) against 25.
00:03:30 <koz_> Like, at this point, I genuinely have no idea wtf I'm doing.
00:03:53 <ab9rf> koz_: tine for some cerebral liquid nitrogen injections?
00:04:02 <erisco> according to http://hackage.haskell.org/package/regex-tdfa-1.2.0/docs/Text-Regex-TDFA.html you can use \` and \'
00:04:13 <koz_> ab9rf: If it'll help me figure out how to use mutable vectors with monad stacks? Sure!
00:04:16 <norc_> For the last part though, what exactly does `Non type-variable argument` mean?
00:05:06 <norc_> Oh oh! I found some articles to see where this is heading.
00:05:13 <jle`> norc_: yes, well, it's not quite a violation
00:05:19 <nykros> its working now, [re|^[a-zA-Z]+\.(mp3|flac|aac)|]. Thank you very much
00:05:22 <jle`> the violation is actually for something different
00:05:37 <ab9rf> nykros: you should likely add $ to the end too
00:05:38 <jle`> norc_: the error is that you can't have typeclass constraints for things with constructors in vanilla Haskell
00:05:42 <erisco> nykros, you should also put $ at the end
00:05:49 <foojs> tadatadatada.
00:05:51 <jle`> nykros: you can only have Num a, Num b, but not Num (Maybe a), or Num (a -> b)
00:05:52 <ab9rf> nykros: otherwise it'll match on "Garblefar.mp3-notreally"
00:05:55 <jle`> sorry, norc_ ^^
00:06:05 <jle`> norc_: if you turn on the FLexibleContexts extension, then the error should go away
00:06:14 <jle`> well, at least, the error will happen at a different point
00:06:28 <ab9rf> or even on "Bitemycat.aackleberry"
00:06:32 <jle`> but let x = 25 mod 24 in ghci should be valid, assuming no monomorphism restriction
00:06:46 <jle`> the error will then happen when you try to pick a specific Num instance you want 25 to be
00:06:57 <ab9rf> this is also not really a great use for regexps
00:07:00 <jle`> the specific numeric types for 'a' and 'b'
00:07:22 <jle`> but right nwo your error is just that vanilla haskell can only have constraints on type variables, not things made wih constructors like (->)
00:07:49 <jle`> you need FlexbileInstances for that
00:08:00 <erisco> nykros, but really, how are you getting away without the semicolon? :s
00:09:13 <erisco> the format is supposed to be [re|flags;regexp|]
00:09:16 <nykros>  [re|^[a-zA-Z]+\.(mp3|flac|aac)$|] is working with my few examples. It should fail?
00:09:57 <erisco> well, that was the intent, but I guess it is messed up
00:10:21 <nykros> I´m using import Text.RE.TDFA.String. Is it ok?
00:10:42 <erisco> yeah, none of that should matter, it is just the quasiquoter that checks for that format
00:11:05 <erisco> it separates the flags and the pattern using break (==';')
00:11:15 <erisco> > break (==';') "flags;pattern"
00:11:18 <lambdabot>  ("flags",";pattern")
00:11:25 <erisco> > break (==';') "pattern"
00:11:27 <lambdabot>  ("pattern","")
00:11:43 <erisco> without the semicolon it should be treating the pattern as flags instead
00:11:56 <erisco> no, actually it should just fail to compile
00:12:10 <norc_> jle`: Interesting, so in the end the error is that the necessary constraint for type deduction for that polymorphic 25 is not allowed
00:12:25 <erisco> because it is matched on  case break (==';') txt of (flagString, ';':pat) -> ...
00:12:30 <nykros> does´t have default flags for these cases?
00:12:33 <foojs> hi
00:12:55 <erisco> nykros, well the problem generally is if a semicolon exists in the pattern
00:12:58 <norc_> Sounds like a kind of constraint violation on the constraint itself. :-)
00:13:17 <erisco> nykros, I could have had an escape sequence for semicolons but that didn't seem good
00:13:46 <jle`> norc_: yes, at the moment, the error is that vanilla haskell cannot support constraints of that form
00:13:47 <erisco> often with regexps you have delimiters, often /, which the flags go after
00:13:48 <foojs> when to choose direct recursion over tail recursion , only to be simple and less headaches on accumulator ?
00:14:02 <erisco> well, TDFA doesn't have delimiters
00:14:11 <jle`> norc_: but if you turn on FlexibleContexts (which most haskell code already has on, it's a failry standard extension) then you will have a different error
00:14:23 <koz_> Could someone please help me write this? I've written, in detail, what I'm trying to do: http://lpaste.net/357672
00:14:48 <ab9rf> regular expressions are a curse
00:15:14 <erisco> hrm, I can't even install it on my GHC
00:15:47 <erisco> base went to 4.9 but I have it restricted to 4.7, mkay
00:15:59 <erisco> I'll get that fixed
00:16:51 <erisco> what's the feeling on base versions? apparently I thought a max was wise
00:18:00 <jle`> i usually don't restrict upper bounds on base
00:18:14 <cocreature> if you care about upper bounds, I don’t think base is any different from any other package
00:18:24 <cocreature> it changes and breaks with pretty much every ghc release
00:18:26 <jle`> i'm usually the person submitting PR's to packages bumping up base when a new ghc comes out
00:18:34 <foojs> helloooooo world!
00:18:35 <nykros> I´m very glad to be able to be here. It is a nice forum, full of people smarter than me :)
00:18:40 <erisco> cocreature, base does? what about outside of GHC.Ext?
00:18:48 <norc_> jle`: Fair enough, I just tried that and that looks a bit different. But it made me think and realize that something like (1 1) would be enough to produce the same diagnostic.
00:19:09 <foojs> hi haskell i dont like u at all!
00:19:11 <norc_> And from that I tried doing the same thing with ('a' 'a') which gave me a trivially readable diagnostic.
00:19:16 <jle`> norc_: yes, that'd be (Num (a -> b), Num a) => b
00:19:19 <cocreature> erisco: ftp, the monad applicative stuff, typeable in ghc 8.2, …
00:19:24 <jle`> and "a -> b" is not a valid constraint in vanilla haskell
00:19:32 <jle`> only things like Num a, Show a, Read b, etc. are
00:19:45 <jle`> *Num (a -> b)
00:20:16 <norc_> Made that substitution in my head. :)
00:20:30 <jle`> norc_: the thing about 1 1 is that numeric litearls are polymorphic, so ghc has to do type inference to figure out what you want
00:20:41 <jle`> but char literals like 'a' are monomorphic, no type inference required
00:21:05 <jle`> no constraints required
00:21:29 <erisco> -XOverloadedChar
00:21:48 <jle`> heh, if you turn on OverloadedStrings then you will get a similar error with "a" "a"
00:22:23 <jle`> but really, FlexibleContexts is fairly standard and i'm usually surprised when i find out that i haven't turned it on yet
00:23:37 <norc_> jle`: Perhaps, even with flexible contexts I get a new surprising error again. Kind of harsh to a newcomer.
00:23:51 <jle`> yes the error will be that there is no Num instance for the thing you want, i believe
00:24:09 <jle`> yeah, numeric overloadeding can give some bad errors for newcomers
00:24:16 <erisco> nykros, do you have another idea for the format?
00:24:32 <jle`> i mean it's a bad thing in that it presents a learning barrier, but it's a good thing in that once you learn it, it's very helpful
00:25:01 <jle`> but!
00:25:06 <jle`> there could be better errors
00:25:10 <norc_> jle`: When I started with C I remember a phase when all I did was add * and & to the left and right of expressions until the compiler stopped complaining, and my program crashing still.
00:25:15 <jle`> there are only a few people working on good readable errors for GHC
00:25:24 <norc_> So Im trying to not repeat that phase by focusing on understanding what GHC tells me. :-)
00:25:35 <jle`> they are working hard, but, it's no easy task
00:25:52 <erisco> you still can't use TH in ghci can you
00:25:53 <norc_> jle`: This whole experience reminds me a lot of C++ templates.
00:26:09 <norc_> Also a pure functional language, type deduction, unreadable errors..
00:26:12 <norc_> :-)
00:26:19 <jle`> heh, i can see where the similarities might be :p
00:26:19 <mud> The problem with this error message is that I'm not sure how GHC can really do a lot better. To do it "right" you kind of need a "beginner mode" and an "advanced mode"
00:26:29 <foojs> erlang is FP too 
00:27:01 <norc_> mud: Well from my perspective I'd naturally ask "why are numeric literals polymorphic to begin with"
00:27:11 <ab9rf> norc_: because people expect them to be :)
00:27:38 <jle`> it's nice to be able to do things like 5 / 4 and infer that 5 and 4 are meant to be dividable things
00:27:45 <mud> norc_: Because otherwise you have to throw a bunch of fromInteger everywhere in your code, and it's not terribly fun.
00:27:54 <jle`> there's also a lot of possible types you might want to use / with
00:27:54 <ab9rf> there are a LOT of numeric types in haskell
00:28:13 <ongy> we even have extensions to make some literals more polymorphic
00:28:14 <ab9rf> mud: or lots of explicit typetagging
00:28:25 <jle`> numerical literals being polymorphic open a lot of doors in expressiveness
00:28:29 <jle`> like the 'ad' library
00:28:48 <mud> ab9rf: Or that. And some way to be able to express them :-/
00:28:59 <ab9rf> mud: it would definitely clutter the syntax
00:29:11 <mud> Yeah, it wouldn't look so good probably.
00:29:21 <nykros> I really miss an environment like Eclipse for haskell. That could have a huge impact on usability
00:29:54 <ab9rf> mmm, i've never really felt that way
00:30:21 <ongy> there's a few things that could be nice, like type aware autocomplete, but a lot of that doesn't work well in haskell
00:31:17 <jle`> i think a a lot of people feel like the IDE interop with haskell is lacking
00:31:37 <ab9rf> i suppose an IDE that could turn a type hole into a tooltip or something might be nice
00:31:45 <jle`> see https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#ide-support
00:32:47 <ongy> haskell-vim-now....
00:33:45 <mud> https://github.com/haskell/haskell-ide-engine this looks a decent amount further along than last time I looked, huh.
00:36:51 <nykros> I think that Windows users are viewed as outsiders. I'm using Stack+Atom+haskell-ide, but it doesn`t feel like a real IDE
00:37:08 <erisco> okay... what have I done wrong... to use a custom quasi quoter I thought it was [q| ... ]  where q is the name of your quoter
00:37:18 <ongy> nykros: what are you missing for a "real" IDE?
00:37:33 <erisco> I mean [q| ... |]
00:37:39 <erisco> now I am being told there is a parse error at |]
00:37:54 <ab9rf> haskell on windows is definitely a bastard stepchild
00:37:58 <cocreature> erisco: have you enabled -XQuasiQuotes?
00:38:20 <erisco> cocreature, thanks! 
00:38:30 <erisco> was thinking TemplateHaskellQuotes
00:39:15 <ab9rf> it's annoying that ghc has to carry along with it the entire msys compilation toolchain, which (while not completely hideous) means any interaction with native windows compilers will require major code-fu
00:40:03 <cocreature> erisco: I’ve never used TemplateHaskellQuotes explicitely. I just use TemplateHaskell directly if I need that :)
00:40:06 <erisco> nykros, [re|^[a-zA-Z]+\.(mp3|flac|aac)$|]  does not compile for me... errors saying it needs to be in the flags;regexp format
00:40:35 <erisco> nykros, maybe you're using a different library than what I am thinking?
00:41:04 <nykros> refactoring, automatic import management, 
00:41:27 <nykros> let me see
00:42:04 <erisco> maybe you are using version 0.1.0 ?
00:42:50 <erisco> in 0.2.0 I changed what re is... the 0.1.0 re became pat
00:43:12 <nykros> I imported Text.RE.TDFA.String and regex in build-depends.
00:43:25 <erisco> the new re is more useful in that it actually gives you a Regex value
00:43:32 <erisco> rather than a Pattern
00:44:06 <erisco> yeah but you should be getting the quasi quoter from Text.Regex.TDFA.QuasiQuoter from regex-tdfa-quasiquoter
00:44:32 <jle`> i know i'm really late into this and you probably already know this, but don't use regexps in haskell
00:45:43 <erisco> I think they're a good idea though ideally I'd have more back ends than TDFA
00:45:56 <erisco> would be nice to compile to attoparsec or parsec
00:46:33 <erisco> the regexp notation is much more concise than parser combinators... does a specific job better
00:46:44 <nykros> how do consult stack which version of the libraries is using?
00:47:10 <jle`> nykros: you can stack exec ghc-pkg list | grep mypackage
00:49:24 <erisco> I am betting  you have 0.1
00:50:44 <nykros> http://lpaste.net/357675
00:51:35 <erisco> I don't know how stack works... no idea why the quasiquoter package is not in there if you are in fact using it
00:52:25 <MarcelineVQ> if you're in a project, which you should be with stack, you type  stack list-dependencies  to get the real and true list of things you're using for your project.
00:53:29 <ab9rf> jle`: yeah, i really think adding a regexp quasiquoter is a bad idea all together
00:53:35 <ab9rf> regexps are the Wrong Way to solve most problems,
00:53:46 <ab9rf> a chainsaw that has been grossly overused.
00:53:49 <erisco> I have fought for regexp rights since 2005
00:54:08 <ab9rf> regexps are not particularly useful as a programming tool
00:54:18 <Axman6> is stack list-dependencies not the right way to find out deps of a stack package?
00:54:28 <erisco> they are concise and elegant, two qualities that make them excellent as programming tools
00:54:38 <ab9rf> i'd argue that they are neither
00:54:41 <mud> Axman6: It is the right way, yes.
00:54:51 * Axman6 agrees with ab9rf
00:55:07 <erisco> the problem only is that there is this "regexps are awful" bandwagon everyone has jumped on
00:55:15 <erisco> probably as an excuse for not understanding regular expressions
00:55:17 <mud> They can sometimes be concise. They also can be great examples of why concision isn't necessarily that important.
00:55:24 <ab9rf> they tend to force a problem into a domain that the problem is not actually in, and lead to inelegant, confusing solutions to problems that can be solved more directly in other ways
00:55:38 <Axman6> regexes are great for text editors, and occasionally on the command line, but parsers are so useful and easy to use that we should advocate them where possible
00:55:48 <ab9rf> Axman6: i concur entirely with that
00:55:53 <Axman6> if you need a user to provide a pattern to find something, that's a good use of them, but that's about it
00:56:02 <ab9rf> they're a nice languge for specifying throwaway one-time pattern matches
00:56:06 <erisco> most regexps translate into parser combinators become horrendously verbose
00:56:06 <Axman6> (which is why text editors and the command line are good examples)
00:56:26 <erisco> the other problem is that programmers use regexp for the wrong thing and then blame regexp for being awful
00:56:30 <MarcelineVQ> I like regex's, but I have to google every single time I try to use one :<
00:56:32 <mud> Axman6: And even then that user *must* be essentially a coder otherwise it's just a recipe for pain and hate.
00:56:36 <Axman6> comparatively verbose sure, but maintainable
00:56:45 <erisco> there is nothing not maintainable about a regexp
00:56:53 <Axman6> I disagree
00:56:54 <erisco> these are all bandwagon fallacies
00:56:57 <ventonegro> if it's going to be frozen in code, parsers >>> regexps
00:57:03 <Axman6> try and use a regex to find email addresses
00:57:08 <erisco> done that
00:57:26 <Axman6> one which meets the actual spec is horrendous and fragile. writing a parser is quite trivial
00:57:33 <ab9rf> i'd rather have a straightforward parser instead of a fancy ginsu knife that cuts text up inot inexplicable chunks, then juggles those chunks around to get the same end result
00:57:38 <erisco> fragile? how is meeting the spec fragile?
00:57:40 <mud> Axman6: Most of the problem there is that the email address format is so vague to be essentially undefined.
00:57:48 <Axman6> the number of places which do not allow the use of + is so painful
00:57:53 <nykros> stack is very magic. Dendendencies: http://lpaste.net/357676
00:57:53 <ab9rf> mud: no, it's very precisely defined.
00:57:55 <erisco> it is easy
00:57:56 <mud> Or not really vague, just expansive.
00:58:01 <ab9rf> mud: and is fairly easy to write a parser for
00:58:13 <ab9rf> mud: writing a REGEXP for it is rather harder.
00:58:16 <jle`> i don't know about other people but i've been using regexps for for over a decade now and i still have problems reading them immediately and making changes to complex regexps
00:58:22 <erisco> however, yes, for email addresses the regular expression is very long, and that makes it an inappropriate use of regular expressions
00:58:40 <ab9rf> i use regexps in editors fairly frequently
00:58:48 <ab9rf> i never use them when writing code
00:59:05 <erisco> if you understand what a regular language is then a regular expression is nothing unsettling
00:59:08 <Axman6> This does not look understandable or maintainable to me: (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
00:59:09 <Axman6> |\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
00:59:15 <erisco> in fact you welcome how directly it lets you express regular languages!
00:59:15 <Axman6> if the spec changes, you're stuffed
00:59:23 <ab9rf> Axman6: gesundheit
00:59:29 <erisco> Axman6, that is wrong
00:59:31 * Axman6 sniffle
00:59:36 <ab9rf> erisco: how can you tell?
00:59:46 <erisco> easy...
01:00:07 <Axman6> I could have pasted the PHP one... http://emailregex.com
01:00:17 <erisco> https://gist.github.com/erisco/29082201244b053285cfd48814f3859c
01:00:38 <Axman6> that's pretty horrific...
01:00:45 <erisco> the correct answer is this http://lpaste.net/357677
01:01:10 <Axman6> ah yes, clearly
01:01:20 <merijn> The correct answer is "don't freaking validate emails with regular expressions"
01:01:39 <erisco> that is not a good use of them, but I did that to demonstrate that what is in the spec is in fact a regular language
01:01:49 <merijn> Pop quiz: Which of the following characters is not allowed in an email address? 1) quotes, 2) space, 3) tab, 4) newline?
01:01:57 <erisco> granted that when you look at the broader spec for addresses in headers this changes (apparently, but I don't really care)
01:02:01 <MarcelineVQ> trickquestion
01:02:08 <merijn> MarcelineVQ: Ssshhh!
01:02:15 <mud> Aren't they all allowed?
01:02:19 <Axman6> merijn: iirc, because 1 is allowed, most of the others are too?
01:02:33 <merijn> mud: Yeah, it was a trick question, they're all allowed
01:02:37 <mud> Oh okay
01:02:57 <merijn> Once again indicating how stupid any attempt at email validation other than "mailing a link" is
01:03:15 <erisco> just because you can find something which is not suited to regular expressions does not mean there is nothing suitable for regular expressions
01:03:17 <merijn> mailing a link not only confirms it's valid, but also that the person can actually receive said email
01:03:33 <mud> Ya, I long ago gave up strictly validating email addresses. The few times I've been tempted to, the most I did is "Is this really your email address? It doesn't look very likely?" warning. Yeah, sending an email seems to be the right way to validate an email address.
01:04:19 <tdammers> a more pressing concern than making sure the address the user entered is something that they can receive mail on, is whether the thing the user entered could possibly break your server
01:04:34 <dibblego> Our aviation authority told me on Saturday that the email address that I have had registered with them for years, is not valid, and so I cannot complete a medical.
01:04:50 <jle`> clearly it means that you don't exist
01:04:54 <merijn> Hell, there's people that are "well, just validate that there's an @ and a . behind it" which fails two ways. 1) if someone buys a custom TLD like you can now, they could be hosting email on the TLD and 2) @ is not required, at least theoretically, if someone is using a bang path (does anyone still use those?)
01:05:10 <Axman6> dibblego: you sent them the spec right?
01:05:10 <nykros> this is really awesome: https://regexper.com/#%5E%5Ba-zA-Z%5D%2B%5C.(mp3%7Cflac%7Caac)%24
01:05:28 <ab9rf> merijn: i used to have an email domain that was only reachable by UUCP
01:05:34 <dibblego> Axman6: I sent them an angry email, because the Doctor of Aviation that I am seeing in 29 minutes requires me to have filled that out first, or I forfeit a deposit.
01:05:53 <Axman6> :(
01:06:06 <dibblego> the "new medical system" won't accept my very valid email address, even though it's the same one I have had with them for years
01:06:12 <mud> tdammers: Yes, but that's a matter of just usual code correctness.
01:06:21 <erisco> https://regexper.com/#%2F%5E(((%5B!%23%24%26'*%2B%5C-%2F0123456789%3D%3FABCDEFGHIJKLMNOPQRSTUVQXYZ%5E_%60abcedfghijklmnopqrstuvwxyz%7B%7C%7D~%5D%2B)%7C(%22(%5B%5Cx0%5Cx1%5Cx2%5Cx3%5Cx4%5Cx5%5Cx6%5Cx7%5Cx8%5Cx9%5CxA%5CxB%5CxC%5CxE%5CxF%5Cx10%5Cx11%5Cx12%5Cx13%5Cx14%5Cx15%5Cx16%5Cx17%5Cx18%5Cx19%5Cx1A%5Cx1B%5Cx1C%5Cx1D%5Cx1E%5Cx1F%20!%23%24%25%26'()*%2B%2C%5C-%5C.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWXYZ%5C%5B%5C%5D%5E_%60
01:06:21 <erisco> abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%5Cx7F%5D%7C%5C%5C.)%2B%22))(%5C.((%5B!%23%24%26'*%2B%5C-%2F0123456789%3D%3FABCDEFGHIJKLMNOPQRSTUVQXYZ%5E_%60abcedfghijklmnopqrstuvwxyz%7B%7C%7D~%5D%2B)%7C(%22(%5B%5Cx0%5Cx1%5Cx2%5Cx3%5Cx4%5Cx5%5Cx6%5Cx7%5Cx8%5Cx9%5CxA%5CxB%5CxC%5CxE%5CxF%5Cx10%5Cx11%5Cx12%5Cx13%5Cx14%5Cx15%5Cx16%5Cx17%5Cx18%5Cx19%5Cx1A%5Cx1B%5Cx1C%5Cx1D%5Cx1E%5Cx1F%20!%23%24%25%26'()*%2B%2C%5C-%5C.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDE
01:06:22 <erisco> FGHIJKLMNOPQRSTUVWXYZ%5C%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%5Cx7F%5D%7C%5C%5C.)%2B%22)))*)%40(((%5B!%23%24%26'*%2B%5C-%2F0123456789%3D%3FABCDEFGHIJKLMNOPQRSTUVQXYZ%5E_%60abcedfghijklmnopqrstuvwxyz%7B%7C%7D~%5D%2B)%7C(%5C%5B((%5B%5Cx0%5Cx1%5Cx2%5Cx3%5Cx4%5Cx5%5Cx6%5Cx7%5Cx8%5Cx9%5CxA%5CxB%5CxC%5CxE%5CxF%5Cx10%5Cx11%5Cx12%5Cx13%5Cx14%5Cx15%5Cx16%5Cx17%5Cx18%5Cx19%5Cx1A%5Cx1B%5Cx1C%5Cx1D%5Cx1E%5Cx1F%20!%22%23%24%25%26'()*%2B%
01:06:22 <ab9rf> merijn: i haven't seen a bang path in about 15 years, but anyone still using sendmail can in theory process them
01:06:27 <erisco> 2C%5C-%5C.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWXYZ%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%5Cx7F%5D)%7C(%5C%5C.))*%5C%5D))(%5C.((%5B!%23%24%26'*%2B%5C-%2F0123456789%3D%3FABCDEFGHIJKLMNOPQRSTUVQXYZ%5E_%60abcedfghijklmnopqrstuvwxyz%7B%7C%7D~%5D%2B)%7C(%5C%5B((%5B%5Cx0%5Cx1%5Cx2%5Cx3%5Cx4%5Cx5%5Cx6%5Cx7%5Cx8%5Cx9%5CxA%5CxB%5CxC%5CxE%5CxF%5Cx10%5Cx11%5Cx12%5Cx13%5Cx14%5Cx15%5Cx16%5Cx17%5Cx18%5Cx19%5Cx1A%5Cx1B%5Cx1C%5Cx1D
01:06:32 <erisco> %5Cx1E%5Cx1F%20!%22%23%24%25%26'()*%2B%2C%5C-%5C.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWXYZ%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%5Cx7F%5D)%7C(%5C%5C.))*%5C%5D)))*)%24%2Fm
01:06:33 <dibblego> erisco: excuse me please
01:06:36 <Axman6> ...
01:06:39 * erisco facepalms
01:06:39 <ab9rf> merijn: i seem to recall that postfix refuses to even try to process bang paths
01:06:47 <dibblego> erisco: please fart outside the elevator
01:06:52 <ab9rf> erisco: "this is your brain on regular expressions"
01:06:59 <tdammers> mud: which, unfortunately, isn't very usual out in the wild
01:07:19 <erisco> it turns out it puts the whole expression in the URL...
01:07:22 <ab9rf> merijn: i have no idea what exchange does to them. yhou probably have to install a custom address parsing module
01:07:50 <ab9rf> merijn: exchange lets you email X.400 addresses directly, though, so it can probably handle them
01:08:00 <mud> tdammers: True
01:08:10 <MarcelineVQ> luckily that's more of an argument for saner web-sites or better irc client automation, rather than against your point
01:08:16 <merijn> ab9rf: Don't forget MS has a reputation for backwards compatible support bordering on the downright silly :p
01:08:25 <MarcelineVQ> all though it's a little bit of that last one
01:08:47 <ab9rf> merijn: i was an exchange admin for about eight  years, and i don't recall seeing anything that would set up bang path routing, but it could be buried somewhere deep in the raw guts of IIS
01:09:09 <erisco> well anyways, if you copy http://lpaste.net/raw/357677 into this regexper thing you can see the expression is not all that crazy
01:09:27 <erisco> most of the length comes from the character classes... they can be shortened with ranges but I just wrote them all out for clarity
01:09:53 <ab9rf> merijn: exchange's actual mail exchanger is this ancient lizard brain that traces its roots to somewhere around the cretaceous era, and so it might well have that logic in it
01:10:58 <ab9rf> i remember there was a switch somewhere to disable % addressing
01:11:16 <ab9rf> awhich also disabled @host:user@host addressing support, as i recall
01:11:33 <ertes-w> erisco: IMO that's the wrong kind of clarity =)
01:11:44 <ab9rf> both of those are really stupid to have enabled today, as they make your machine really suitable for spam forwarding
01:11:46 <ertes-w> elo
01:11:54 <ab9rf> EHLO
01:12:28 <jchia> Question about (\\) from ClassyPrelude. It's an alias for 'difference' from Data.Containers of mono-traversable, where 'difference' takes a SetContainer, and there is an instance "Eq key => SetContainer [(key, value)]". There is no "Eq key => SetContainer [key]". The result is that I can't use ClassyPrelude.(\\) on [Int] even though I can with Data.List.(\\) from base. Why would the mono-traversable author not define "Eq key => SetContainer [key]" so that (\\
01:13:04 <ertes-w> erisco: it's the same kind of "clarity" you get from windows API identifiers like MsgWaitForMultipleObjectsEx, or from visual basic syntax
01:15:00 <erisco> ertes-w, I can't argue with that, it was just that when I was defining it I was just in a mode of writing out all the characters
01:15:12 <erisco> because there are a bunch of escape codes to write in there too
01:15:21 <jle`> jchia: i'd submit an issue or pr
01:15:47 <erisco> so it was the clarity of "everything is a character" rather than both characters and ranges
01:16:00 <nykros> I go to sleep. It´s late here. See you later
01:16:40 <erisco> I'll have to start a blog to continue the crusade for regular expressions
01:16:53 <jle`> fight the good fight
01:17:48 <ab9rf> or something like that
01:17:56 <ab9rf> bite the wax tadpole
01:19:00 <erisco> what would be good to extend their capability is to have expression references
01:19:18 <erisco> that is really when people start complaining
01:20:03 <erisco> but the point is to not use them where you'd need that ... anyways ... it is probably easy to add that functionality with quasi quoters
01:21:31 <erisco> basename = [a-z]+; ext = mp3|ogg; filename = basename\.ext
01:21:40 <ertes-w> erisco: *for* regular expressions?
01:21:53 <erisco> that is much more scalable
01:22:30 <ab9rf> that's not really any more readable than what you get using parser combinators, though
01:22:30 <ertes-w> also people often fail to realise that they are writing regex in a host programming language that has abstraction capabilities
01:22:53 <ertes-w> let name = "[A-Za-z0-9]+" in name ++ "@" ++ …
01:23:25 <ertes-w> there is no need to extend regex itself…  if it can't do what you want, don't use regex, and if it can, use your programming language!
01:24:19 <erisco> ab9rf, interspersing with <*> and <|> adds considerable noise
01:24:24 <jchia> jle`: Just did.
01:24:58 <ab9rf> erisco: so does all the regexp crap
01:25:08 <erisco> no, it is objectively shorter
01:25:16 <ab9rf> shorter is not necessarily better
01:25:17 <merijn> Shorter /= less noisy
01:25:24 <ab9rf> sendmail.cf files are VERY short
01:25:33 <erisco> when I used the word "noise" I meant it is making it longer without adding any more meaning
01:25:46 <merijn> Anyway, I think this regex discussion has gone on long enough to the point where it's getting boring and not very on topic for #haskell
01:25:48 <ab9rf> but they look like they were written by a chicken that walked in spilled ink
01:26:49 <ab9rf> the gods have spoken!
01:26:58 <erisco> you're right merijn
01:27:08 <ab9rf> nothing to see here, move along home
01:31:17 <merijn> Actually, speaking of on-topic things. Anyone here have experience with writing cabal packages that rely on non-haskell executables at runtime? I know cabal has a libexecdir, but I dunno how I can get cabal to put my C/python executables there. And I don't know if that will work when running things without doing "cabal install" (i.e., when I only build/new-build for testing)
01:31:24 <merijn> Any recommendations/advice?
01:31:37 <ab9rf> merijn: i attempted to do that once
01:31:43 <ab9rf> merijn: i failed. miserably.
01:31:57 <ab9rf> merijn: as a result, i have no useful advice :)
01:32:13 <merijn> ab9rf: Right now I hardcode the build-path for the executables, but that's...not ideal :)
01:32:22 <ab9rf> i don't even remember what i tried, it was such a traumatic experience, i think i blocked out all memories of it
01:33:05 <ab9rf> that, or i was drunk 
01:33:53 <merijn> ab9rf: Usually the best response to these issues ;)
01:34:24 <ab9rf> i've had very little luck getting cabal to do what i want
01:34:50 <ab9rf> it does what IT wants, and sometimes that works ot being useful for me. when it doesn't, i usually just hit it with a stick until one of us capitulates (usually, me)
01:34:50 <nshepperd_> Isn't there a thing for handling data files? Maybe you can treat your c executable as data?
01:35:10 <ab9rf> i remember something like that somewhere
01:35:21 <merijn> nshepperd_: There's a thing for data files, and a separate ones for executables. I just don't quite know how it works, so I was hoping someone else had figured that out already
01:36:50 <merijn> Ah, looks like this issue: "Cabal already supports a libexec directory, there is just no easy way to get an executable copied there. So I had to write my own custom hooks."
01:38:19 <merijn> I wish I actually had time to fix all these little warts myself :\
01:39:16 <erisco> derp I forgot to update the source-repository tag... that doesn't matter right?
01:39:28 <ertes-w> merijn: in my defence i came into the discussion late =)
01:39:36 <ab9rf> nah, just put eggplant emojis there, you'll be fine
01:39:45 <erisco> yeah, thought so
01:40:27 <ab9rf> erisco: it would probably be best that you put real stuff in there if you plan to publish the package
01:40:29 <ertes-w> merijn: i do use some command line programs from haskell packages, but generally i don't specify it in the cabal file, but just expect that they are installed
01:40:40 <ab9rf> if you're just building locally, you can stuff it full of eggplants and nobody will care
01:40:46 <erisco> it is published... I just forgot to bump the tag
01:40:56 <erisco> though I think it was wrong to begin with
01:41:07 <merijn> ertes-w: The programs are in my own code and my build system takes cares of building both them AND the cabal package
01:41:15 <erisco> I don't know what it is actually used for other than linking to the github page
01:41:25 <ab9rf> erisco: that's what it's used for
01:41:35 <merijn> ertes-w: So "expecting them to be installed" doesn't really work. As I don't have a reasonable way of installing them anyway. I was hoping to piggy back on cabal for that :p
01:41:39 <ab9rf> erisco: having it be wrong may tend to annoy your user base, if any.
01:41:42 <ertes-w> merijn: ah, i see…  i would most likely make those separate
01:41:54 <ertes-w> merijn: nix takes care of the rest for me
01:41:58 <erisco> well, it is not a popular package... email complains to the posted address :P
01:42:07 <merijn> ertes-w: I don't see the point of separating them?
01:42:22 <ertes-w> merijn: and i don't see the point of combining them =)
01:42:31 <erisco> did not get one notice that it does not work on the new GHC so clearly no one cares
01:42:47 <merijn> ertes-w: The programs only reason for existing is to be called from my haskell code
01:42:50 <ertes-w> merijn: you could combine them in the same source tree for, say, revision control, but i wouldn't make them part of the haskell package
01:42:52 <ab9rf> erisco: half the stuff in hackage doesn't work with recent compilers
01:43:09 <merijn> ertes-w: There is no "haskell package" beyond "cabal file to build things"
01:43:14 <ertes-w> merijn: sure, and my approach would be to use my higher-level deployment tool, in my case nix
01:43:48 <ertes-w> merijn: nix-build would then build both and put them alongside each other, so the haskell program can find the other one
01:44:32 <ertes-w> merijn: the main reason is that cabal doesn't really handle building foreign things very well
01:45:32 * hackagebot tasty 0.11.2.5 – Modern and extensible testing framework – https://hackage.haskell.org/package/tasty
01:45:33 * hackagebot regex-tdfa-quasiquoter 0.2.1.0 – Quasi-quoter for TDFA (extended POSIX) regular expressions. – https://hackage.haskell.org/package/regex-tdfa-quasiquoter
01:46:21 <ongy> merijn: we can only hope for the cabal new-build/cabal.project stuff to be able to handle that. and afaik it's supposed to (at least from external packages)
01:48:24 <David-> Hi, quick type signatures question
01:48:48 <David-> I'm reading through http://members.chello.nl/hjgtuyl/tourdemonad.html right now and see the following
01:48:56 <David-> > foldM takes a function of type:
01:48:56 <David->   (Monad m) => (a -> b -> m a) 
01:48:56 <David-> In different words, it takes a function with two non-monadic parameters, resulting in a monadic value and folds a list with it. The expression:
01:48:56 <David->   foldM f a [x1, x2, ..., xn]
01:48:59 <lambdabot>  <hint>:1:24: error: parse error on input ‘of’
01:49:07 <David-> is equal to:
01:49:07 <David->   f (... f (f (f a x1) x2 ...) xn
01:49:47 <David-> But wouldn't f a x1 have type m a?
01:50:08 <David-> so then f (f a x1) x2 wouldn't work
01:50:30 <erisco> :t foldM
01:50:33 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
01:51:08 <David-> Ok, using that type signature, (f a x1) would have type m b
01:51:43 <erisco> so why do you think it is equal to that?
01:52:01 <David-> Because typeclassopedia linked to this webpage as supposedly authoritative 
01:52:07 <David-> and I'm a beginner
01:52:29 <David-> so my prior is that it's more likely that I'm missing something than there's an error
01:53:40 <erisco> to me it just looks wrong
01:53:55 <erisco> if we were talking about foldl then sure
01:54:02 <erisco> > foldl f z [a,b,c]
01:54:05 <lambdabot>  f (f (f z a) b) c
01:54:10 <erisco> but we're not
01:55:02 <David-> Alright - thanks for your help
01:55:24 <erisco> > foldM f z [a, b, c]
01:55:27 <lambdabot>  error:
01:55:27 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M438825978142...
01:55:27 <lambdabot>        prevents the constraint ‘(Show (m0 Expr))’ from being solved.
01:56:31 <erisco> well anyways, there is going to be a bind between each use of f to get the b out
01:56:52 <ertes-w> :t \f s0 xs -> foldr (\x go s -> f s x >>= go) pure xs s0
01:56:55 <lambdabot> (Monad m, Foldable t) => (b -> t1 -> m b) -> b -> t t1 -> m b
01:57:32 <merijn> Ok, next question: With the bracket pattern there's no real way to prevent someone from leaking resources outside the bracket, no?
01:58:02 <erisco> you allocate the resources going into the bracket and deallocate when leaving
01:58:20 <erisco> so, there are no resources outside the bracket
01:58:26 <merijn> I mean, withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r is nice and all, but if I do "withFile "foo" ReadMode return" you'll leak the Handle
01:58:39 <merijn> erisco: There are, you'll just crash when you use them
01:59:07 <ertes-w> merijn: monadic regions can do it, if you do the work of wrapping your API
01:59:09 <erisco> is that how it works? well, I didn't design it :P
01:59:12 <merijn> bracket guarantees freeing resources, it doesn't prevent people from attempting to use them
01:59:23 <merijn> erisco: Well, how would you stop someone from returning the Handle?
01:59:42 <merijn> ertes-w: I was thinking I could limit/prevent this with an ST like approach
01:59:45 <erisco> you can't, but you can return unit ... this is likely too restrictive
01:59:55 <ertes-w> merijn: yeah, that's exactly what monadic regions are
02:00:10 <erisco> the way it works with the equivalent in other languages is you have  using (x = allocate_a_resource) { ... }
02:00:16 <erisco> so the x is only in scope in the block
02:00:17 <merijn> ertes-w: That's what I guessed
02:00:34 <erisco> though, I suppose you can return x; and jump out with the deallocated resource, heh
02:00:39 <ertes-w> merijn: there are two approaches
02:01:00 <erisco> something something linear types
02:01:07 <mibaz_1> Can I catch no parse exceptions thrown by read?
02:01:08 <merijn> ertes-w: I was thinking "someone could still returns a ST style handle", but I just realised that doesn't matter, since it can't actually ever be used, so there's no issue if the resource is freed already
02:01:13 <mibaz_1> 'try' wants an IO
02:01:21 <merijn> mibaz_1: Yes, by not using "read"
02:01:23 <ertes-w> merijn: if the resources are lexically scoped and there isn't too much nesting, you can do this:  withFile :: … -> (forall s. Handle s -> Region s IO a) -> IO a
02:01:28 <merijn> :t Text.Read.readMaybe -- mibaz_1 
02:01:30 <lambdabot> Read a => String -> Maybe a
02:01:33 <ertes-w> merijn: alternatively you can do something like ResourceT
02:01:54 <ertes-w> merijn: newBlah :: (MonadIO m) => Region s m (Blah s)
02:02:09 <ertes-w> runRegion :: (MonadIO m) => (forall s. Region s m a) -> m a
02:02:09 <merijn> ertes-w: What's the added value of ResourceT?
02:02:18 <mibaz_1> merijn: ah, sorry I missed readMaybe. Thanks
02:02:28 <ertes-w> merijn: you don't *have to* use the 'with'/brachet pattern
02:02:30 <ertes-w> *bracket
02:02:40 <merijn> mibaz_1: It's a bit hidden away since it wasn't part of the Prelude. There's also "reads", but readMaybe is easier to use
02:02:52 <ertes-w> merijn: which means you can have dynamic resource pools
02:03:36 <merijn> ertes-w: Basically, my issue is that my resource is "large" (and I mean huge) files, so I would like them GCed ASAP. I could wrap them with ForeignPtr, but that makes it easy to accidentally keep the around
02:03:39 <ertes-w> merijn: also you don't get error messages that look like this:  Region s (Region s (Region s (Region s (Region s …
02:04:09 <AWizzArd> aws: https://github.com/brendanhay/amazonka  vs  https://github.com/aristidb/aws   – do we have users of one/both? What is the difference? Is one preferrable?
02:04:37 <ertes-w> merijn: you can still use with/bracket with something like ResourceT, but it becomes optional…  if with/bracket is all you need, go with the first approach, because it's much simpler and has no extra run-time cost
02:05:04 <ertes-w> (ResourceT is not free)
02:05:41 <merijn> ertes-w: Well, bracket makes it trickier to use when your operation isn't directly IO
02:05:50 <merijn> ertes-w: So I think ResourceT would have some value
02:06:05 <ertes-w> merijn: but why are you worrying about leaks?  the bracket should close/free everything at the end, so even if the handle remains around, the resources should have been GCed when you return from the bracket
02:06:38 <merijn> ertes-w: Yes, but then you get crashes trying to access the handle/perform operations later
02:06:48 <ertes-w> merijn: perhaps something like monad-control to lift 'bracket'?
02:07:10 <erisco> be careful... you start worrying about modeling one thing with types and soon you have to have all the things
02:07:12 <merijn> ertes-w: I think I have to dive into how ResourceT, SafeT, and Managed differ from each other
02:07:14 <erisco> then you end up crippled like me
02:07:59 <ertes-w> merijn: ResourceT and SafeT are pretty much the same thing – i recommend the former, because it's more established and has more features
02:08:14 <ertes-w> merijn: and (Managed ≃ Codensity IO)
02:08:19 <merijn> ertes-w: Yeah, but I don't think ResourceT works well with pipes?
02:08:40 <merijn> ertes-w: OTOH, a lot of code I have us currently using conduit...I wish there was a way to be streaming library agnostic...
02:08:40 <ertes-w> merijn: it does
02:09:24 <ertes-w> conduit has some built-in stuff for ResourceT IIRC, and pipes-safe has some built-in stuff for pipes…  other than that they are all compatible
02:09:48 <merijn> ertes-w: I was about to say, you can't use pipes-safe in that case, no?
02:09:52 <ertes-w> you can use ResourceT with Proxy and SafeT with ConduitM
02:09:58 <ertes-w> correct
02:10:25 <merijn> ertes-w: Reimplementing the stuff from pipes-safe myself would be annyoing, though :\
02:10:32 <ertes-w> if your usage is strictly with-like you may want to go with Codensity/Managed
02:10:32 <merijn> Anyway, that's a hypothetical issue atm
02:11:10 <ertes-w> fileContents :: FilePath -> Producer ByteString (Codensity IO) ()
02:11:15 <ertes-w> like that
02:11:50 <merijn> ertes-w: But ResourceT/SafeT/Managed all still suffer the issue that you can't prevent, leaking things like Handles/pointers like you can with regions
02:11:59 <ertes-w> unlike ResourceT/SafeT there is no dynamic resource pool in this case…  it's really just CPSed IO
02:12:13 <ertes-w> merijn: well, you mentioned pipes…  this makes things very complicated
02:12:36 <merijn> ertes-w: Well, yes, if it was simple I would've probably come up with something myself ;)
02:12:37 <ertes-w> it's very difficult to prevent resource leakage on the type level when CPS is involved
02:12:55 <ertes-w> i think you might have to wait for -XLinearTypes =)
02:13:01 <merijn> ertes-w: Bugger :\
02:13:20 <technochine> that seems to be the answer for a lot of things in haskell
02:13:59 <ertes-w> technochine: what do you mean?
02:14:44 <merijn> ertes-w: Maybe I just have to suck it up...I think my C++ version can't really prevent this kinda resource leakage either
02:16:18 <merijn> ertes-w: I think I can managed the region thing since I probably want my stream to run with a single resource, so just move the entire stream into the region
02:16:51 <merijn> technochine: Well, at least GHC/Haskell are implementing new things to wait for. More than can be said about many other languages ;)
02:17:08 <ertes-w> merijn: C++ doesn't even have RankNTypes…  i can't even imagine how you could prevent it there
02:17:09 <ertes-w> merijn: for now just make sure that the bracket properly releases all resources…  that makes referring to the handle a run-time error…  not pretty, but better than actual resource leaking =)
02:17:51 <merijn> ertes-w: RAII all the things and prevent returning values with references
02:18:33 <merijn> ertes-w: Deleting copy/move constructors for all your values prevents them from being returned out of the code using your data structure
02:18:44 <ertes-w> merijn: yeah, that works…  and you could still combine this with Codensity to get something like ResourceT, but without the run-time cost =)
02:18:53 <ertes-w> ah
02:21:53 <ertes-w> Producer A (Region s (Codensity IO))
02:21:54 <ertes-w> or embed Codensity into Region right away
02:22:28 <merijn> ertes-w: I'm not familiar enough with Codensity to quite get that one
02:22:43 <ertes-w> merijn: i'm thinking of an API like this:  cbracket :: IO (f s) -> (f s -> IO b) -> Region s m (f s)
02:23:00 <ertes-w> where:  newtype Region s m a = Region { runRegion :: forall r. (a -> m r) -> m r }
02:23:44 <merijn> Anyway, before I worry to much about this I should probably first implement this file format before worrying how to access it from Haskell ;)
02:24:18 <erisco> maybe, depends where you will fail fastest
02:24:20 <ertes-w> merijn: it's just ContT with a result type that is run-time-parametric
02:24:21 <ertes-w> :t \open close -> ContT (open close)
02:24:21 <ertes-w> err
02:24:23 <lambdabot> forall k a (m :: k -> *) (r :: k) t. (t -> (a -> m r) -> m r) -> t -> ContT r m a
02:24:25 <ertes-w> :t \open close -> ContT (bracket open close)
02:24:27 <lambdabot> IO a -> (a -> IO b) -> ContT r IO a
02:24:34 <ertes-w> merijn: ^
02:25:04 <ertes-w> with Codensity the 'r' disappears, and you *have to* use the continuation
02:25:50 <erisco> there is always bottom, so don't feel too safe
02:30:42 <YuzeG> hi there, anyone knows how to install packages via stack ? e.g. install juicypixel by stack
02:30:51 <YuzeG> thanks in advance
02:35:53 * hackagebot ixset-typed 0.3.1.1 – Efficient relational queries on Haskell sets. – https://hackage.haskell.org/package/ixset-typed
02:46:01 * hackagebot jsaddle 0.9.4.0, jsaddle-warp 0.9.4.0, jsaddle-webkit2gtk 0.9.4.0, jsaddle-wkwebview 0.9.4.0
02:46:01 * hackagebot  → https://hackage.haskell.org/packages/recent
02:48:58 <dminuoso> Mmmm, been playing around a bit. It seems like `stack` is kind of similar to `npm` in the JavaScript world, is that assessment correct?
02:51:06 * hackagebot digit 0.3.0 – A data-type representing digits 0-9 and other combinations – https://hackage.haskell.org/package/digit
02:51:10 <pacak> sort of
03:24:40 <AWizzArd> Is there some kind of UI tool that visualizes the types in a Haskell project, and their relations?
03:26:42 <jchia> For constraints, is there something that's the opposite of ~? The context is how to avoid overlapping instances when defining instances 'Eq key => SetContainer [(key, value)]' & Eq key => SetContainer [key]. If I can make the constraint match exclusive to one instance, then I can avoid overlapping instances.
03:27:14 <tdammers> jchia: no. that would violate the open universe principle
03:27:16 <jchia> Is that like asking for the halting problem to be solved?
03:27:29 <tdammers> no, it's unrelated to the halting problem
03:27:34 <tdammers> it's way more worldly than that
03:27:59 <merijn> jchia: Sadly, no, there's no opposite of ~
03:28:34 <tdammers> if you define these two instances, then such a feature would allow you could disambiguate between these two instances, but not between any of them and instances yet to be passed in from outside
03:30:21 <tdammers> in your particular case, what I would do (and in fact, what I have done in the past) is define a newtype for association lists, and then hook up all the desirable dictionary-like instances with that
03:30:34 <tdammers> newtype AList k v = AList { unAList [(k, v)] }
03:31:22 <tdammers> then you can have instance Eq key => SetContainer (AList key value); and also instance Eq key => SetContainer [key]
03:31:29 <tdammers> the newtype makes it such that they can never clash
03:32:32 <jchia> tdammers: OK. I'm working with an [Int] and just looking for a way to make a SetContainer instance for 'Eq a => SetContainer [a]'.
03:33:01 <tdammers> oh wait, so SetContainer isn't your own typeclass, check
03:33:24 <tdammers> then you'd newtype [k] instead
03:33:34 <tdammers> assuming that the instance for [(key, value)] already exists
03:34:03 <jchia> tdammers: Yeah, that would work.
03:34:54 <jchia> merijn, tdammers: thanks
03:35:01 <tdammers> or maybe use Set instead of [] in the first place, if set functionality is what you need
03:37:42 * hackagebot lens-toml-parser 0.1.0.0 – Lenses for toml-parser – https://hackage.haskell.org/package/lens-toml-parser
03:51:59 <sphinxo> is it possible to have a list of Show b => Either String b
03:52:23 <tdammers> sphinxo: yes, but not the way you think
03:52:51 <tdammers> actually, you can get it the way you think, too, with existential types
03:53:08 <tdammers> but that really boils down to a very elaborate way of writing [Either String String]
03:55:28 <sphinxo> tdammers: so how do I do it not the way I think
03:56:28 <tdammers> Show a => [Either String a]
03:56:44 <tdammers> that's fairly uncontroversial, but it means that all the a in your list have to be the same a
03:57:07 <tdammers> meaning that you can't have Either String Int in the first element and Either String Char in the second, for example
03:58:16 <tdammers> if you want that, you should probably just go with [Either String String], and do the show call when adding things to the list
03:58:26 <sphinxo> ah ok, thanks
03:58:27 <tdammers> because there really isn't anything else you can do with them anyway
04:20:11 * hackagebot megaparsec 6.1.1 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
04:24:58 <halogenandtoast> Probably a silly question. If I want to use StdGen for setup in a library, but I don't want to have random as a dependency is that possible.
04:25:21 <merijn> halogenandtoast: No
04:25:44 <halogenandtoast> Right
04:25:49 <halogenandtoast> thanks merijn
04:25:55 <merijn> halogenandtoast: Why do you not want to depend on it?
04:27:10 <l30nch0l0> hi
04:28:22 <erisco> l30nch0l0, hello
04:41:10 <[exa]> explicit caches are comonads?  (just an idea thrown into place)
04:45:08 <MichaelBurge> What's a good example of the ST monad being used in a case that can't be efficiently reduced to tail recursion?
04:45:24 <opqdonut> any array manipulation
04:46:47 <foldr> mutating FFI API
04:47:05 <merijn> MichaelBurge: I'm not quite sure what ST and tail recursion have to do with eachother?
04:47:34 <foldr> instead of doing a traverse in ST to update a mutable structure, you can build a new mutable structure using recursion
04:47:43 <MichaelBurge> Are you sure about array manipulation? foldr ($) arr [ (i, 1) | i <- [1..10] ] should be as efficient as replacing the array with ST right?
04:47:44 <foldr> s/new mut/new immut/
04:47:58 <l30nch0l0> hi
04:48:03 <opqdonut> MichaelBurge: I meant mutating array manipulation, something like quicksort for instance
04:48:22 <opqdonut> merijn: I guess he means having a couple of STRefs and updating them vs. having a couple of arguments to your tail-recursive function
04:48:23 <foldr> MichaelBurge: that creates a linked list, not an array. If you only want to update one element of an immutable array, you have to copy the entire array
04:48:40 <foldr> arrays are contiguous in memory
04:49:02 <l30nch0l0> hi
04:49:02 <foldr> updating a mutable array is O(1). updating an immutable array is O(n)
04:51:48 <MichaelBurge> you're right, that syntax was wrong. 
04:52:04 <halogenandtoast> merijn: because I wasn't thinking clearly
04:55:13 <bbear> immutable array are accessed through a specific monad, isn't it ?
04:56:22 <jle`> MichaelBurge: tail recursion isn't really a thing in haskell
04:56:34 <merijn> bbear: immutable arrays can be accessed anywhere, since they're immutable anyway
04:56:35 <jle`> it actually really isn't a thing in other languages either; the thing is tail-call optimization
04:56:56 <jle`> bbear: immutable arrays in haskell are better known as "arrays"
04:57:07 <jle`> :)
04:57:30 <jle`>  
05:01:41 * hackagebot ekg-wai 0.1.0.2 – Remote monitoring of processes – https://hackage.haskell.org/package/ekg-wai
05:13:57 <MichaelBurge> Here's an example of what I mean by tail calls vs ST: http://lpaste.net/357681
05:14:04 <dminuoso> So considering that all functors are endofunctors in haskell, isn't CT-wise every function in Haskell an endofunctor?
05:14:22 <MichaelBurge> I think in those examples I did something silly, because the ST version is too slow to be useful. But some variant of it should be as efficient, it seems like
05:15:17 <merijn> dminuoso: functions are morphisms in the category of Hask
05:15:46 <jle`> dminuoso: when we say that all functors are endofunctors, we mean that the Functor typeclass represents endofunctors in Hask
05:16:05 <merijn> MichaelBurge: Timing performance using runghc isn't sensible anyway
05:16:06 <jle`> we don't literally mean that all ways you can represent functors are only as endofunctors
05:16:16 <merijn> MichaelBurge: If you're doing measurements you should always compile
05:16:20 <jle`> it's a statement specifically about instances of the Functor typeclass
05:22:06 <MichaelBurge> Anyways, I'm writing an article about porting over imperative code that uses mutable variables and loops to Haskell. I never use the ST monad, but I thought I should include something about it.
05:22:21 <MichaelBurge> Can anyone recommend a specific package or other code that uses it in an effective or creative way?
05:22:30 <saurabhnanda> is it possible to generate haskell source as a string and splice it in using Template Haskell?
05:23:09 <MichaelBurge> saurabhnanda: I think you'd have to run the GHC parser for that, but in principle I think so. The Q monad expects a syntax tree
05:24:47 <ertes-w> MichaelBurge: lazy ST can be used to create something like an infinite stream of random numbers
05:24:57 <ertes-w> from an imperative algorithm
05:25:16 <ertes-w> for example you could use the mwc-random library with lazy ST
05:25:17 <merijn> MichaelBurge: ST is useful in combination with, for example, vector
05:25:40 <merijn> MichaelBurge: It allows you to perform in-place operations on a vector inside a pure function
05:25:57 <ertes-w> other than that i can only think of rather boring examples like doing everybody's favourite wrong example (a prime sieve) properly using ST
05:26:04 <merijn> MichaelBurge: So any case where you want to use a mutable array would be beneficial
05:28:27 <ertes-w> in fact you could use lazy ST here again, because then you could return the individual primes immediately, and the sieve would only be computed on demand
05:29:45 <bbear> sorry I meant mutable arrays.
05:30:25 <merijn> bbear: Mutable arrays are usually access via IO or ST, yes
05:30:43 <merijn> bbear: ST having the advantage that it can be used within pure code
05:41:09 * hackagebot hslogger-reader 1.0.3 – Parsing hslogger-produced logs. – https://hackage.haskell.org/package/hslogger-reader
05:41:40 <Xion_> Is there a package which has a TextRead class that's an analogue to Read, kinda like TextShow is to Show?
05:45:01 <merijn> Xion_: Honestly, if you care about performance you should just use one of the parsing libraries to parse Text, rather than Read. And if you don't care you can just do "read . T.unpack"
05:45:16 <merijn> Xion_: Read has absolutely abysmal performance
05:45:44 <Athas> I'm curious what the original justification was for Read.  Debugging convenience?
05:45:50 <merijn> Athas: Pretty much
05:46:16 <MichaelBurge> I sometimes use it when copy-pasting Show'd values into a unit test or something
05:46:27 <Xion_> Nah, it's not about performance, just common interface.
05:46:35 <Xion_> But if no one uses Read then it doesn't make sense I guess :)
05:46:47 <Xion_> (Haskell's legacy cruft strikes again...)
05:46:51 <merijn> Xion_: Common interface to what? :)
05:47:03 <Athas> MichaelBurge: but if you put the value in the source code you don't need the Read instance anyway.
05:47:11 <merijn> Xion_: Well, as said the ability to derive a slow (but working) Read instance is helpful when debugging
05:47:45 <Xion_> Right; I keep forgetting that Read/Show aren't really intended for end-user consumption
05:48:00 * Xion_ wants the Debug/Display distinction from Rust :(
05:48:33 <merijn> Xion_: We have prettyprinter for displaying things :)
05:48:53 <MichaelBurge> Athas: Sometimes the output is large enough that it belongs in a separate file.
05:49:53 <Athas> MichaelBurge: use a separate .hs file!
05:50:02 <Athas> Haskell has a pretty crap module system, but it works for that.
05:51:28 <ertes-w> Athas: you can't (or shouldn't) use the module system for dynamic loading
05:51:41 <Athas> Why would a test suite require that?
05:51:51 <ertes-w> who knows
05:53:17 * hackagebot ltk 0.16.1.0, vcsgui 0.2.2.0, vcswrapper 0.1.6
05:53:17 * hackagebot  → https://hackage.haskell.org/packages/recent
05:56:45 <szwetsloot> Hey
05:56:57 <szwetsloot> Is this the correct place to ask about android apps?
05:57:37 <icassina> in general or the haskell coding of them?
05:57:43 <icassina> the former: probably not?
05:57:53 <szwetsloot> I'm coding in android studio
05:58:10 <szwetsloot> What do you mean with the haskell coding? I found this IRC through a forum where it was recommended
05:59:12 <barrucadu> This is the IRC channel for the Haskell programming language
05:59:16 <petercommand> szwetsloot: you should join #android-dev
05:59:36 <szwetsloot> petercommand: I tried, but no-one is responding there
05:59:48 <szwetsloot> But okay, guess I'm wrong here
05:59:50 <szwetsloot> Have a nice day!
06:01:57 <knmae> excited, got my first haskell script working :--D
06:03:23 <ongy> knmae: cool :) what did you do?
06:04:12 <knmae> Well, nothing mindblowing, i'm just learning the syntax :)
06:04:48 <knmae> just trimming stirngs/arrays 
06:11:03 <bbear> what is ST '
06:12:08 <saurabhnanda> why can't TH just work with literal strings? why is a third party parser required? https://stackoverflow.com/questions/31412444/template-haskell-is-there-a-function-or-special-syntax-that-parses-a-string-a
06:13:05 <srhb> bbear: The strict state transformer monad. It's often used to model mutable algorithms where you can afterwards extract the result without an IO context in a pure fashion.
06:13:33 <merijn> srhb: Why do you say "strict state transformer"? It's not strict, nor a transformer
06:13:34 <bbear> can you get outside ?
06:13:41 <merijn> bbear: ST stands for State Thread
06:13:45 <srhb> merijn: That is its name, is it not?
06:14:01 <merijn> srhb: No, ST is State Thread, not a transformer
06:14:09 <srhb> state-transformer, rather.
06:14:31 <merijn> srhb: The name of the paper is "Lazy functional state threads"
06:14:38 <Xion_> State thread is a dumb name though
06:14:39 <merijn> srhb: It also has the wrong kind to be a transformer
06:14:43 <srhb> From the docs: "The strict state-transformer monad. A computation of type ST s a transforms an internal state indexed by s, and returns a value of type a."
06:14:44 <Xion_> It has nothing to do with threads
06:14:50 <srhb> merijn: state-transformer, something that transforms states.
06:14:51 <merijn> Xion_: Agreed
06:15:01 <barrucadu> It threads state through a computation
06:17:39 <srhb> From 2.1 in the paper: The “ST” stands for “a state transformer”
06:17:54 <srhb> So I assume the docs, and the paper, and the name, are all correct and in agreement.
06:18:21 <jle`> i concurr that it is an unfortunate naming choice
06:18:29 * srhb snickers
06:18:55 <srhb> I think the only problem is the overloading of the word transformer in this community. :-P
06:19:13 <merijn> srhb: How about the overloading of the word overloading?
06:19:37 <srhb> I get around that by prepending ad-hoc and pretending that somehow clears things up. :-)
06:20:54 <capn_freako> What happened to the setL function from lens?
06:22:17 <srhb> capn_freako: I don't know, what do you think happened?
06:23:30 <Gurkenglas> You mean https://hackage.haskell.org/package/data-lens-2.11.1/docs/Data-Lens-Common.html#v:setL ? The equivalent from the lens library's just called set
06:35:03 * hackagebot eventsource-geteventstore-store 1.0.2 – GetEventStore store implementation. – https://hackage.haskell.org/package/eventsource-geteventstore-store
06:35:03 * hackagebot eventsource-api 1.1.1 – Provides an eventsourcing high level API. – https://hackage.haskell.org/package/eventsource-api
06:40:52 * hackagebot eventsource-geteventstore-store 1.0.3 – GetEventStore store implementation. – https://hackage.haskell.org/package/eventsource-geteventstore-store
06:44:09 <dminuoso> merijn: But isn't fmap :: (a -> b) -> Maybe a -> Maybe b   in itself a morphism too?
06:45:34 <jle`> it can be considered a morphism yes
06:45:38 <merijn> dminuoso: The question to ask is whether it's a morphism in the same category (I'm lazy to think about it)
06:45:59 <jle`> dminuoso: but anything can be a morphism
06:46:04 <merijn> dminuoso: Functor is morphisms from one category to another
06:46:05 <jle`> in some category
06:47:07 <merijn> dminuoso: functions are morphisms in the category Hask, (endo)functors are morphisms between the morphisms of Hask
06:47:31 <merijn> dminuoso: Which is a different category (one where the objects are morphisms in Hask)
06:47:43 <dminuoso> merijn: Well, morphisms between objects and morphisms of hask
06:49:54 <jle`> dminuoso: if you are talking about Functors, (Maybe, fmap) can be considered an endofunctor in Hask
06:50:12 <dminuoso> jle`: Well, that would be an endofunctor in a subset of hask.
06:50:28 <dminuoso> Because an endofunctor would map the entire category (i.e. _all_ types and morphisms)
06:50:35 <dminuoso> but (Maybe, fmap) is a clear limitation
06:50:39 <jle`> what is the limitation
06:50:45 <jle`> Maybe can be applied to any object in Haskl
06:50:47 <jle`> *Hask
06:50:53 <dminuoso> OH!
06:50:56 <jle`> Maybe's domain is the entirety of Hask
06:51:16 <jle`> its image does not cover Hask, of course, but that's the same for most functors
06:51:54 <jle`> it's also injective, which is kind of neat
06:51:57 <jle`> but it's not surjective
06:52:17 <dminuoso> jle`: so Maybe itself is the mapping between the types, and fmap a mapping between the morphisms?
06:52:29 <jle`> yes, and the two together form a functor
06:53:34 <jle`> these functors happen to be useful to work with as an abstraction, so that's why we have the Functor typeclass
06:53:44 <jle`> we didn't realize that it was useful until fairly late in Haskell, admittedly
06:54:14 <merijn> jle`: Functors where fairly early, iirc. Applicative was rather late
06:54:21 <jle`> they were after Monad
06:54:24 <jle`> which i consider late
06:54:32 <jle`> fsvo late
06:54:43 <jle`> :)
06:54:56 <merijn> jle`: AFAIK monad and functor were added at the same time
06:54:57 <Myrl-saki> I'm a bit curious. What do Haskellers think about IPC through files?
06:55:04 <merijn> jle`: Which is during/before Haskell98
06:55:13 <merijn> Myrl-saki: I prefer unix sockets/pipes, tbh
06:55:37 <jle`> merijn: if that's the case, why isn't Functor a superclass of Monad?
06:55:38 <Myrl-saki> merijn: I mean unix files in general, so that counts. :P
06:56:17 <Myrl-saki> How about modularity through IPC?
06:56:25 <merijn> jle`: Because that would force all people that implement monad to also implement functor and at the time they decided there was no point in forcing people to do extra work if they wanted to use Monad
06:56:42 <Myrl-saki> I guess modularity through IPC isn't generally liked by Haskellers, because impurity?
06:57:05 <jle`> merijn: ah
06:57:07 <merijn> Myrl-saki: Where'd you get that idea? That wasn't my impression, tbh
06:57:09 <jle`> different values at that time, i suppose
06:57:18 <merijn> jle`: A completely stupid rationale in hindsight, but there you go
06:57:19 <Myrl-saki> merijn: Just a thought. :P
06:57:51 <Myrl-saki> merijn: I was thinking of making a WM configured P9-like.
06:57:53 <merijn> Myrl-saki: I actually do it quite a bit. Together with haskell's streaming libraries (conduit/pipes) it's actually fairly easy
06:58:04 <jle`> interesting to see how the values/priorities of the community shift
06:58:34 <merijn> Myrl-saki: Normally I try to keep it within a single program (i.e. Chan, etc.) but if I need to do something in C++/python I usually pipe stuff into those and back out to haskell
06:59:29 <Myrl-saki> merijn: I've been experimenting with Hs + Bash. :D
06:59:42 <Myrl-saki> It's kind of, I don't know. Interesting?
07:00:42 * hackagebot DeepDarkFantasy 0.2017.8.14 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
07:00:57 <jle`> kind of a dramatic name for a package
07:01:06 <Myrl-saki> Requires a wink. :D
07:01:45 <Myrl-saki> merijn: How do iteratees compare to pipes/conduit? (I've only read a bit about iteratees)
07:04:15 <merijn> Myrl-saki: pipes/conduit are the more practical/simpler/nicer libraries inspired by iteratees
07:05:10 <merijn> Myrl-saki: Iteratees was the first streaming library, invented by Oleg. But like a lot of things invented by Oleg it was thoroughly confusing :p
07:12:41 <tesan> I tried to make a list comprehension that takes the square root from numbers in an inner list and only keeps those numbers that aren't fractions...
07:12:48 <tesan> But I am getting some error
07:13:01 <jle`> what does it mean for a number to not be a fraction
07:13:30 <jle`> do you mean irrational?
07:13:39 <tesan> x `mod` 1 == 0
07:14:05 <jle`> ah
07:14:09 <tesan> idk how to say it in english but I think that is accurate
07:14:45 <AndreasK> Where the result is a integer
07:14:59 <sphinxo> How can I make aeson parse 1.0 as a float, rather then an int?
07:15:27 <jle`> decode "1.0" :: Maybe Int
07:15:30 <jle`> er
07:15:35 <tesan> I tried this: [x | x <- [x^(1/2) | x <- [1..]], x `mod` 1 == 0]
07:15:36 <jle`> decode "1.0" :: Maybe Float
07:15:42 <tesan> Is this incorrect?
07:15:52 <jle`> ^ in haskell is used for integer exponents
07:15:57 <jle`> you probably want sqrt x
07:16:01 <jle`> or x**(0.5)
07:16:12 <jle`> but, one issue you have is that 'mod' only works on integer/integral things
07:16:12 <sphinxo> jle`: well if it's an int then I want to parse it as in int
07:16:20 <tesan> Ouch
07:16:42 <sphinxo> I'm parsing a { "a": 0.0 } into Map.Map String Value
07:17:04 <jle`> tesan: you might want mod' from the Data.Fixed module
07:17:18 <jle`> sphinxo: if that's what you mean, then, it doesn't make too much sense in aeson
07:17:23 <jle`> because json doesn't have int/float distinction
07:17:24 <sphinxo> ah ok
07:17:41 <jle`> Value represents a json value, but json values do not distinguish betweehn floats and ints
07:17:53 <jle`> it has a generic Number spec
07:18:08 <jle`> tesan: and x `mod'` 1 == 0 might not actually be exactly what you want, because of floating point stuff
07:18:50 <jle`> maybe abs (x `mod'` 1) < 0.0001, to use the same logic
07:19:25 <jle`> sphinxo: but i think the numeric type in aeson distinguishes between the two, actually
07:19:42 <jle`> maybe try playing around with it
07:19:58 <jle`> sphinxo: see the 'Number' constructor for Value? http://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson-Types.html#t:Value
07:20:13 <tesan> jle: Thank you, I may try that
07:20:33 <sphinxo> jle`: thanks!
07:20:36 <jle`> no problem
07:20:52 <tesan> Ohh, I forgot the `
07:32:54 <sphinxo> jle`: isFloating (0.0 :: Scientific)
07:33:05 <sphinxo> ( yields false )
07:33:39 <jle`> oh, you mean based on the string in the aeson?
07:33:41 <jle`> *json
07:34:10 <sphinxo> what do you mean? jle` 
07:34:24 <jle`> how do you want to determine whether something is a float or an int
07:34:34 <Myrl-saki> Is there actually merit to keeping the broken ListT?
07:34:49 <jle`> backwards compatibility maybe?
07:34:59 <jle`> i mean, it's deprecated
07:35:08 <jle`> so you get that compiler warning
07:35:32 <sphinxo> jle`: by it's type?
07:35:37 <sphinxo> ahh
07:35:41 <jle`> what type?
07:36:06 <Myrl-saki> jle`: When was ListT found to be wrong?
07:36:07 <jle`> like, if you see a json string, how do you know if you want the number you see to be interpreted as a Float or an int by haskell
07:36:47 <jle`> not sure exactly
07:36:52 <sphinxo> if it has any digits after the decimal place
07:37:24 <sphinxo> I'd rather not be checking by hand
07:37:57 <Myrl-saki> sphinxo: `:: Either Float Int`?
07:38:05 <Myrl-saki> Rather
07:38:07 <jle`> oh, yeah.  that's not really something that Value or json is meant to handle
07:38:12 <jle`> maybe Either Int Float
07:38:13 <sphinxo> I suppose so
07:38:58 <Myrl-saki> Bad advice, but why not just handle everything as Double? That's what JS does.
07:39:38 <mizu_no_oto> Because you don't always want doubles?
07:39:59 <Myrl-saki> mizu_no_oto: Tru
07:40:14 <Myrl-saki> And I'm assuming that he's using this with a JS program.
07:40:19 <Myrl-saki> Which might not be true
07:40:40 <mud> Though having "Either Float Int" isn't really better than just having a Float, is it? *ponders*
07:41:06 <Myrl-saki> mud: Either Double Int. :P
07:41:15 <liste> and sometimes you actually need bignums
07:41:19 <Myrl-saki> But yeah. That should have been Either Float Integer
07:41:34 <liste> even bigdecimals
07:41:56 <liste> json can encode them just fine
07:41:57 <sphinxo> how I'm trying to use this: find mismatches { "a": 1 } and Map.Map Name Type
07:42:44 <sphinxo> where Type is like TInt, TFloat, TBool for some language
07:43:44 * hackagebot lzma-conduit 1.1.3.3 – Conduit interface for lzma/xz compression. – https://hackage.haskell.org/package/lzma-conduit
07:43:57 <Myrl-saki> Imagine if you can make a singleton of (*)
07:44:01 <Myrl-saki> Can you?
07:44:18 <Myrl-saki> Oh wait, that sounds like a stupid question lol
08:05:32 <AndreasK> mud: There will be values that are not representable accuratly by Float but which is a good reason to use int. Less of an issue with double though
08:07:33 <ertes-w> oh, ListT is still around
08:07:47 <ertes-w> kinda weird…  i don't think anyone uses it
08:10:13 <ertes-w> Myrl-saki: i like the 'logict' package as a ListT replacement
08:10:33 <ertes-w> that one is a proper ListT
08:11:32 <ertes-w> there is also 'pipes', which provides its own ListT, but i prefer LogicT, because it has a more efficient encoding
08:26:05 * hackagebot slack-web 0.2.0.1 – Bindings for the Slack web API – https://hackage.haskell.org/package/slack-web
08:36:59 <Xandaros> Is there a way to get the length of a Data.ByteString.Builder.Builder or do I need to convert it to an actual ByteString?
08:41:09 <cocreature> Xandaros: a builder is just a function and concatenation is function composition and there is nothing that keeps track of of the length so you can’t get the length out of it.
08:41:31 <Xandaros> Yeah, I figured
08:44:33 <ertes-w> Xandaros: a Builder can take arbitrary lazy ByteStrings and have infinite length itself…  keeping track of length would at best reduce its efficiency
08:45:21 <cocreature> you can always wrap it in some "data Builder = Builder !Int ByteString.Builder" and define the monoid instance appropriately
08:47:12 <Xandaros> I'll just convert to ByteString and get the length from that. It won't be much of problem, I just wanted to know if there was a simpler solution
08:50:42 <Garreett> hi all am I okay to ask questions in this IRC? I am pretty new to Haskell and am struggling to implement something from a book I have been following
08:51:04 <barrucadu> Don't ask to ask, just ask
08:51:31 <Garreett> okay sorry just didn't want to upset people if there is somewhere else for questions
08:51:43 <shapr> this is a good place
08:52:30 <shapr> Garreett: which book?
08:52:45 <Garreett> I have been trying to implement an environment for procedures in a simple language. I have defined a type: Env_p = Procedure -> Statement
08:53:06 <Garreett> Semantics with applications nielsen is the book
08:53:10 <ertes-w> Xandaros: well, by converting to ByteString you're giving up the nice properties of Builder =)
08:53:51 <Xandaros> ertes-w: I am indeed, but I need the length right before sending it to a handle, anyway, so it shouldn't matter much
08:54:21 <ertes-w> Xandaros: in that case you should use cocreature's approach
08:55:04 <Garreett> this has allowed me to store procedures in the global scope however to do this for static scope rules I need to extend the procedure environment to: Env_p = procedure -> (statement, Env_p)
08:55:57 <Garreett> i tried doing: type Env_p = procedure -> (statement, Env_p) but I've found out that types can't be defined by themselves and I haven't really had any luck with anything else so far
08:58:49 <mnoonan> Garreett, what about doing "newtype Env_p = Env_p (procedure -> (statement, Env_p)"?
09:02:38 <Garreett> mnoonan, thanks for the response! Would that essentially allow the same functionality as "Env_p = procedure -> statement" but instead maps to (statement, Env_p) ?
09:02:38 <Xandaros> ertes-w: Maybe later. Right now, that is premature optimisation :P
09:03:41 <mnoonan> Garreett: yes, you'll just need to wrap/unwrap the Env_p constructor to get at the function inside of it
09:04:27 <Garreett> when previously working with Env_p = procedure -> statement, I created a global Env_p to use and declared all procedure names to map to Skip which acted as an empty statement
09:05:01 <Garreett> I am not too sure how I would declare an empty environment for this extended case
09:05:29 <Garreett> is it possible to make types/ newtypes empty in some way
09:05:44 <mnoonan> I should say that I missed the earlier part of this conversation, so I don't know if the idea I gave actually solves your real problem.. 
09:06:16 <mnoonan> it sounds like you might want some more complicated kind of environment, like "data Env_p = EmptyEnv | Env (proc -> (stmt, Env_p) | ..."
09:07:10 <ertes-w> Xandaros: if you're really too lazy for that, at least convert to a *lazy* ByteString to compute the length and then convert it from the Builder *again* for output…  that way you don't have to create a full in-memory ByteString
09:07:29 <dminuoso> Okay so in an abstract sense the purpose of an Endofunctor is to embed structure into both data/types and morphisms.
09:07:32 <ertes-w> Xandaros: but honestly skipping this kind of easy optimisation is exactly the reason why software gets slower much faster than hardware gets faster
09:07:44 <Garreett> mnoonan, I'll take a look at that thanks!
09:07:54 <ertes-w> Xandaros: just to appeal to your conscience a bit =)
09:08:35 <Xandaros> ertes-w: That is actually exactly what I did. I want to get things to work first before worrying about things like this
09:08:55 <Xandaros> Otherwise there is a very real chance it will never get done :P
09:08:58 <cocreature> ertes-w: pff, the haskell spirit is to write slow code and then claim that it’s so beautiful that it doesn’t matter that it’s slow!
09:09:07 <ertes-w> hehe
09:09:34 <cocreature> “look at my quicksort, isn’t it beautiful?” “that’s not quicksort” “BEAUTIFUL!”
09:09:40 <Xandaros> That only applies if the code is actually beautiful, though :(
09:09:47 <ertes-w> "your quicksort just drained my battery…"
09:10:01 <ertes-w> in 2017 power matters =)
09:11:01 * hackagebot xmlhtml 0.2.5 – XML parser and renderer with HTML 5 quirks mode – https://hackage.haskell.org/package/xmlhtml
09:12:29 <[exa]> ertes-w: +1 for efficiency :D
09:22:53 <sqooq> when haskell pattern matches on a single value, it uses equality under the hood?
09:23:48 <cocreature> sqooq: depends on what you mean by “equality”.
09:23:55 <sqooq> ==
09:24:01 <mud> sqooq: Probably depends what you mean. It can't use Eq, since Eq doesn't have to exist (and can contradict pattern matching)
09:24:01 <cocreature> it doesn’t use the Eq instance (there might not even be one)
09:24:02 <[exa]> sqooq: pattern matching is not "overloaded =="
09:24:15 <cocreature> pattern matching compares constructors
09:24:16 <[exa]> sqooq: it's actually much more restricted
09:24:20 <sqooq> crap
09:24:24 <sqooq> then why do I get "No instance for (Eq D) arising from a use of `time'"
09:24:29 <dminuoso> So I've been studying ad-hoc polymorphism for a bit now, and it seems classes in haskell are more like concepts in C++ or something like Enumerable in Ruby. Am I on the right track here?
09:24:38 <cocreature> sqooq: you’ll have to show us some code
09:24:49 <[exa]> sqooq: the fun part is that comparing the integer constructors looks kinda like equality check (and is implemented so)
09:24:52 <dminuoso> i.e. if it satisfies a certain interface, it conforms to that class
09:24:53 <sqooq> it uses the csound-expression library
09:25:11 <mud> sqooq: Can you show code?
09:25:21 <sqooq> yes
09:25:22 <sqooq> lpaste is slow
09:25:27 <sqooq> http://lpaste.net/357688
09:25:29 <cocreature> dminuoso: yeah, they’re often also compared to interfaces in languages like java which while not being completely true is a reasonable analogy
09:26:01 <sqooq> it type checks fine if I don't give it a signature (idk what that signature would be)
09:26:15 <dminuoso> cocreature, essentially static duck typing?
09:26:21 <sqooq> then I have maketups = fmap tuplforcs . parserToNotes
09:26:23 <cocreature> dminuoso: one thing that might be different from concepts and enumerable (I’m not too familiar with those) is that types are not implicitely instances of a class but you need to explicitely make them an instance
09:26:36 <sqooq> but when I try to do fmap time . maketups
09:26:40 <sqooq> I get that instance error
09:26:41 <cocreature> dminuoso: no you need to explicitely instances.
09:27:24 <mnoonan> dminuoso, you might be interested in this: https://pdfs.semanticscholar.org/f381/b69b665dc7f13bb26c4e10fedd2b87fcc0de.pdf ("A comparison of C++ concepts and Haskell type classes")
09:27:29 <sqooq> Hmm y'all are right, time works perfectly on it's own
09:27:34 <sqooq> it just doesn't work when I try to map it
09:27:53 <dminuoso> mnoonan, that looks like my kind of paper. Already started reading thank you. :-)
09:27:54 <sqooq> despite working before when it was slightly different (but less powerfull)
09:29:05 <cocreature> sqooq: pattern matching on numeric literals is an exception. in that case it actually uses ==
09:29:18 <sqooq> hmm
09:29:29 <mud> Ya for that it does actually have to use (==), heh.
09:29:38 <mud> Just for that one part though
09:29:43 <sqooq> then when I try to use it in ghci all alone, (outside the csound context) I'm guessing it uses Double not D
09:29:50 <sqooq> D is an instance of OrdB
09:29:55 <sqooq> sorry
09:29:56 <sqooq> EqB
09:29:58 <sqooq> but not Eq
09:30:14 <sqooq> but I tried using the special function ==*
09:30:17 <sqooq> and still getting errors
09:30:25 <cocreature> what is OrdB?
09:30:34 <sqooq> I guess Ord but for Csound
09:30:43 <sqooq> this csound library created a bunch of new types
09:30:46 <sqooq> Str for String
09:30:47 <sqooq> D for Double
09:30:55 <sqooq> idk if that's good practice but that's what they did
09:31:19 <cocreature> which library exactly? there seem to be multiple csound libs
09:31:39 <cocreature> also please add the full error you’re getting to the lpaste
09:31:41 <sqooq> csound-expression
09:31:45 <sqooq> here are the types
09:31:46 <sqooq> https://hackage.haskell.org/package/csound-expression-typed
09:32:07 <sqooq> specifically Csound.Typed.Types.Prim
09:32:12 <sqooq> is where the main stuff is
09:35:22 <sqooq> when trying to use their equality instead
09:35:24 <sqooq> I get
09:35:24 <sqooq> http://lpaste.net/357689
09:35:59 <cocreature> have you tried doing what it tells you, i.e., have you tried turning on GADTs?
09:40:09 <sqooq> that stopped the error
09:40:12 <sqooq>  but now :  * Couldn't match type `BoolD' with `Bool'     Expected type: Bool       Actual type: BooleanOf D   * In the first argument of `fmap', namely `time'     In the expression: fmap time (maketups "[0 2 3 x]")     In an equation for `it': it = fmap time (maketups "[0 2 3 x]")
09:40:45 <sqooq> that was in ghci though
09:40:52 <sqooq> maybe doing it in the file changes things, hold up
09:41:45 <mbw> If I have a data type promoted to a kind like data S = A | B, and another type T defined as data T :: S -> * where C1 :: T 'A; C2 :: T 'B, this requires either XGADTs, or (XGADTSyntax + XExistentialQuantification). Is there a way to define this type T without using GADTSyntax?
09:42:13 <mbw> (Of course we also need XDataKind and XKindSignatures...)
09:42:28 <eitanChatav> yo
09:42:42 <sqooq> doing it in the file didn't help, same error
09:46:08 <cocreature> mbw: `data T' s = (s ~ 'A) => C1' | (s ~ 'B) => C2'` should work. but GADTSyntax is really the sane solution here :)
09:46:36 <eitanChatav> mbw: you can try desugaring the GADT - http://www.haskellforall.com/2012/06/gadts.html
09:47:59 <eitanChatav> when is it a good idea to use default signatures vs just defining the instance?
09:48:33 <mbw> eitanChatav: Thanks for the link.
09:48:34 <dmwit> When the instance would overlap with instances you don't want.
09:48:46 <dmwit> Or instances you do want, but which would be defined differently.
09:48:59 <mbw> cocreature: what does (s ~'A) really say? Is there a "least" language extension the notation is associated with?
09:49:10 <dmwit> Generally, the default signature is for a fully-polymorphic (even if type-class constrained) instance, and so just writing the instance would overlap with all possible instances.
09:49:53 <dmwit> mbw: `a ~ b` means the types `a` and `b` are equal. I do not think there is a least extension for it, but many extensions turn it on by association, including `TypeFamilies` and `GADTs`.
09:50:20 <mbw> I actually had the intuition I needed to fumble around with '~', but couldn't get the syntax right
09:50:29 <mbw> Nor did I know what I was doing
09:52:06 <eitanChatav> dmwit: here's an example; I have a mtl style class such that any transformer over it is also an instance; I read a blog post recently about using default sigs for that; why not just make an instance `instance MonadTrans t, MonadThing m => MonadThing (t m)`?
09:52:13 <dmwit> mbw: Sounds like the beginning of a horror film. =)
09:52:18 <mbw> I thought it would be way more complicated than that, if only for using a funny symbol instead of something like '=' :)
09:52:30 <dmwit> (in a deep voice) "But... they didn't know what powers they were fumbling with..."
09:52:39 <mbw> haha
09:52:46 <eitanChatav> lol
09:52:57 <mbw> Well if the internet goes dark you know I messed up
09:53:41 <eitanChatav> mbw, are you michael brandon williams?
09:54:23 <mbw> I would have to google myself if I were :/
09:55:00 <dmwit> eitanChatav: Might be okay. But it would also overlap monad formers that were not monad transformers that happened to accept things of kind `* -> *` as an argument.
09:55:01 <eitanChatav> ok, just checking :-) I have a buddy who uses the same username and has an interest in haskell
09:55:11 <dmwit> e.g. possibly would overlap with a potential instance for `Free` or so.
09:55:17 <mbw> ah ok
09:55:30 <mbw> I thought you were talking about someone famous.
09:56:00 <eitanChatav> well, he's a little famous among swift programmers I guess
09:56:17 <dmwit> eitanChatav: It also prevents you entirely from defining a new transformer that does something fancier than just `lift` your operation, which may or may not be desirable.
09:56:37 <mbw> So he's not a former football player I guess :)
09:56:42 <dmwit> eitanChatav: (In particular it would probably overlap with an instance for ThingT.)
09:57:08 <sqooq> alright I did a cheap work around. Made my tuple have 3 slots, the first is a bool value which is only true for the one case I wanted to test against anyways.
09:57:15 <sqooq> It works now
09:57:18 <eitanChatav> dmwit: so it seems like the safe route is to use default signatures
09:57:45 <dmwit> I think so.
09:58:08 <srhb> Do people tend to use the gl library directly, or is there a higher level candidate somewhere?
09:58:46 <eitanChatav> dmwit: my other example is I have a `FromValue` and `FromRow` class; the `FromRow` can be gotten if the type already has an `SOP.Generic` constraint and is a record and all its fields have `FromValue` constraints; default sig?
09:59:46 * hackagebot HsOpenSSL 0.11.4.11 – Partial OpenSSL binding for Haskell – https://hackage.haskell.org/package/HsOpenSSL
09:59:46 * hackagebot simple-log 0.9.3 – Simple log for Haskell – https://hackage.haskell.org/package/simple-log
10:00:07 <mnoonan> what's the deal with the "Variable not in scope: etc etc .. before the splice on line .." errors? why can't a (use, definition) pair span a splice?
10:00:25 <dmwit> eitanChatav: I don't even know how you would write the constraint that "all its fields have `FromValue` constraints", so I suspect both options are out, no?
10:01:18 <dmwit> mnoonan: At the moment, TH splices are evaluated in order from top to bottom in the file. This ordering constraint is just one of the prices you pay for using TH.
10:01:35 <dmwit> There's a reason this makes the implementation significantly easier, but I don't know it off the top of my head.
10:01:41 <eitanChatav> dmwit: `(IsProductType y ys, AllZip FromColumnValue columns ys)`
10:02:01 <texasmynsted> Is monoidal mappend pronounced like append with map?  Like map-end?
10:02:04 <eitanChatav> using generics-sop
10:02:20 <texasmynsted> This?  <>
10:02:27 <dmwit> eitanChatav: If I understand what you're saying, I would expect this instance to overlap literally every other instance, making the existence of a class at all somewhat questionable.
10:02:27 <mnoonan> dmwit: I don't know if that explains the error I was seeing though.. my case looks like "use of X; splice not involving X; definition of X"
10:02:42 <dmwit> texasmynsted: I usually pronounce it "em append".
10:03:00 <eitanChatav> dmwit: hmm, i'm using it in an example program so I'm not sure what you mean
10:03:11 <dmwit> mnoonan: The whole file is processed top-to-bottom in chunks of "TH" and "not TH".
10:03:22 <mnoonan> dmwit, ah, I understand now. thanks!
10:03:34 <cocreature> texasmynsted: I pronounce it map-end but I’ve never thought about pronouncing it differently tbh :)
10:04:06 <srhb> I also pronounce it em-append (monoidal append)
10:04:33 <dmwit> eitanChatav: If you write `class Class a; instance Ctxt a => Class a`, you might as well just delete `Class` and write `Ctxt` everywhere instead.
10:04:56 <paolino> is ti possible to promote (!!2) to a Getter ?
10:04:58 <texasmynsted> Ok, I kind of like that.  It highlights the Monoid-ness of it.
10:05:01 <eitanChatav> dmwit: fair enough...maybe I should do that
10:05:03 <dmwit> eitanChatav: Or `type Class a = Ctxt a` if `Ctxt` happens to be a lot of (finger-) typing.
10:05:18 <johnw> paolino: to (!!2)
10:05:38 <eitanChatav> dmwit, constraint synonyms have the downside of not being able to partially apply
10:06:01 <dmwit> If `Ctxt` can be partially applied, `type Class = Ctxt` will allow partial application with the `Class` name.
10:06:17 <dmwit> But I was assuming `Ctxt` could not be partially applied (as it is not capable of being in your example).
10:06:20 <paolino> johnw, thanks. Just spent half an hour with ix and traverse :-/
10:06:26 <eitanChatav> yes
10:06:58 <eitanChatav> I can do `class Class a where; instance Ctxt a => Class a` though
10:07:21 <eitanChatav> but now I'm thinking I'll try a default sig again
10:07:29 <dmwit> Okay, that's true.
10:07:42 <eitanChatav> in case user wants to define their `FromRow` by hand
10:07:58 <johnw> paolino: x ^. to (!!2) is very similar to x ^?! ix 2
10:08:39 <dmwit> Quick! Name a three-character operator which is not defined in lens.
10:09:30 <ERR_208> Hello
10:09:32 <Garreett> mnoonan, hi again, would you be able to give me an example on how I can use the data you defined earlier? "data EnvP = EmptyEnv | Env (Pname -> (Int, EnvP))" I think I am not understanding how it works
10:10:03 <mnoonan> Garreet: I'm not totally clear on what you are trying to do, can you spell it out in a bit more detail?
10:10:10 * dmwit waves vaguely in ERR_208's general direction
10:10:11 <ERR_208> How are you?
10:10:18 <dmwit> Do you have a Haskell question?
10:11:04 <ERR_208> Do you know Liveoverflow?
10:14:16 <Garreett> mnoonan, so for the simplier example "type EnvP = proc -> stmt" I would pass the environment envP into a function and specified where envP _ = Skip. (Where the Skip statement does nothing essentially). I am a bit unsure on how I do something similiar with your suggestion. I think I am not understanding the "Env" in "| Env (proc -> (stmt, EnvP))"
10:15:56 <Garreett> mnoonan, I have tried "eP :: Pname -> (Int, EnvP) eP _ = (0,EmptyEnv)" which seems to give what I desire but in this case eP is of type "Pname -> (Int, EnvP)" and not EnvP right?
10:16:14 <mnoonan> Garreett, you can think of it like a wrapper around the function. your example would just become "envP = Env (\_ -> Skip)". To apply the function to x, you'd just have a pattern match like "case env of ... Env f -> f x"
10:17:09 <trigone> hi! aside from a cluttered namespace, what negative consequences can come from importing too much (not using most of it)
10:17:54 <parsnip> slow builds?
10:18:32 <parsnip> oh, internal code? or third party libraries?
10:18:42 <mizu_no_oto> ERR_208: https://zenhack.net/2017/01/08/public-service-announcement-irc-is-not-a-syncronous-medium.html
10:19:04 <Garreett> mnoonan, would you be able to write a simple example I can try to disect?
10:19:05 <mizu_no_oto> Ah, looks like he left a couple min ago
10:19:06 <texasmynsted> Thanks
10:19:45 <trigone> parsnip: yes, external libraries, like writing an alternative prelude and importing a lot
10:22:49 <mnoonan> Garreett, http://lpaste.net/357690
10:23:02 <Garreett> thank you very much
10:28:28 <eitan> hmmm...in the end I think I'll go with defining the instances and force the user's hand
10:31:31 <dsal> Easy question:  How do I BL.readFile a file specified on the commandline?
10:31:53 <dsal>     • Couldn't match expected type ‘[FilePath]` with actual type ‘IO [String]’
10:32:06 <dsal> (using head System.Environment.getArgs)
10:33:40 <eitan> dsal: do file <- fmap head getArgs; content <- BL.readFile file; BL.putStrLn content
10:35:20 <eitan> or `head getArgs >>= BL.readFile >>= BL.putStrLn`
10:35:49 <dsal> Ah, thanks.  I still don't fully get IO
10:35:51 <eitan> aack...ignore that last one
10:36:30 <eitan> IO is like a wrapper...you have to grab values out of an IO context...do notation gives you a cute syntax to do that
10:36:44 <eitan> x <- someIOContextContainingx
10:37:11 <Chobbes> Has anybody done much exact / arbitrary precision real arithmetic in Haskell? I'm using the exact-real package, but it seems to be really slow (which might just be the reality of the situation).
10:37:47 <dsal> I don't quite like how this program works in general. Reads entire file, parses csv, maps rows, encodes new file, spits it back out.  Too many copies
10:39:41 <dsal> I think it works. I need to figure out how to do useful testing, though. I don't 100% trust the math.  I tested one case, but ideally I'd test all against another implementation.
10:40:28 <dsal> (or use an existing, tested thing, but the one I found doesn't build, do I went with my own)
10:40:42 <eitan> dsal: for such a program, people often recommend using a stream library
10:41:10 <eitan> like streaming, conduit, or pipes
10:41:20 <dsal> eitan: yeah, I'm using cassava, which I think can do it, but I'm barely hanging on here. :)
10:41:36 <eitan> fair enough...i think these are more advanced topics
10:41:58 <eitan> all of them have cassava compatibility
10:42:01 <dsal> My data isn't more than a couple MB. I'm just not using the tools I'm used to.
10:42:54 <dsal> My native language as this point is go.  I've not been very diverse the last few years.
10:44:38 <kgadek> hey all, what's the solution to record problem du jour? has `record` package got any popular?
10:44:49 <verement> Chobbes: I'm working on https://hackage.haskell.org/package/decimal-arithmetic -- not sure how it compares with exact-real for speed
10:44:58 <jpstone> so, can someone explain monads to me? lol...jk :)
10:45:02 <Tuplanolla> Probably `lens`, kgadek.
10:48:23 <kgadek> Tuplanolla: thx. Was wondering what are the options in use. "Everyone uses lens" is a valid answer
10:49:20 <Tuplanolla> There's also `microlens`, which is a smaller selection of the same stuff, kgadek.
10:49:47 <Chobbes> verement: know anything about MPFR? It seems like it promises speed of a sort.
10:50:01 <kgadek> Tuplanolla: there is indeed. I use microlens whenever I can
10:51:04 <Chobbes> verement: I'm checking out decimal-arithmetic now too! Hopefully you just solved my problems :)
10:51:16 <verement> Chobbes: I have not used MPFR, but it sounds like it should indeed be performant
10:53:16 <Chobbes> verement: sounds good. I'll try them both out. I'm hoping your fancy Haskell library is just fast enough :).
10:53:48 <verement> Chobbes: I'd be happy to get your feedback.
10:55:49 <Chobbes> verement: certainly! Frankly, I'm just happy I have options at this point :).
10:58:14 <Ojd> hello, to practice Haskell (and functional programming) I have been working on several exercises like translating current python code,  99 questions (https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems) etc.  Also, I was thinking of translating the games from this book (http://landoflisp.com/) into Haskell
10:58:29 <Chobbes> verement: oh shoot, do you have tan implemented?
10:58:52 <Ojd> however, the very first exercise requires setting a state
10:59:00 <Ojd> so it would change after user response
10:59:11 <Ojd> the game is to guess a number between 1-100
10:59:25 <verement> Chobbes: not yet -- trig functions are about the last things missing
10:59:36 <Ojd> the pc would  provide guesses and the user would reply by saying "bigger"or "smaller"
11:00:19 <Chobbes> verement: ah, darn! Doesn't quite work for me yet, then!
11:00:44 <Ojd> the strategy presented is simply binary search
11:01:06 <Ojd> but the key part is that they have the side effects of modifying the limits
11:01:20 <Ojd> I have been thinking about the best approach using functional programming
11:01:47 <verement> Chobbes: OK, good to know. Maybe I can get them implemented soon.
11:08:45 <Ojd> I have a very limited knowledge in Haskell, so I am wondering if there is any way to group several instructions
11:09:08 <Ojd> (I would like to ask for  feedback and print a message with current guess to screen)
11:10:54 <srhb> Ojd: Start simple. Something like: loop = do { input <- getLine; putStrLn input; loop}
11:11:20 <srhb> Ojd: Oh, by the way, usually you wouldn't write it like that (but it's handy for onelines in IRC)
11:12:01 <Ojd> thanks srhb
11:12:02 <srhb> Ojd: http://lpaste.net/7204424716935757824 -- this is how it would usually be formatted
11:13:08 <srhb> Ojd: The {}s and ; are just a different way of writing the same thing. :)
11:22:54 <texasmynsted> why is <$ found but $> is not?
11:23:24 <texasmynsted> I can do something like 'a' <$ "zzzzz", but I can not do "zzzzz" $> 'a'
11:23:30 <texasmynsted> the $> is not found
11:23:59 <Ojd> srhb, would it be possible to use guards with do? or I should use the if then else nested?
11:24:05 <texasmynsted> I get Variable not in scope: ($>) :: [Char] -> Char -> t
11:24:08 <Tuplanolla> @hoogle ($>)
11:24:09 <lambdabot> Data.Functor ($>) :: Functor f => f a -> b -> f b
11:24:09 <lambdabot> Data.Functor.Compat ($>) :: Functor f => f a -> b -> f b
11:24:09 <lambdabot> Data.Functor.Apply ($>) :: Functor f => f a -> b -> f b
11:24:34 <texasmynsted> I guess I need to import that?
11:24:36 <texasmynsted> hm
11:24:38 <texasmynsted> lets see
11:25:05 <Tuplanolla> It's in a `Compat` module, which suggests that at some point it was moved, texasmynsted.
11:25:52 <texasmynsted> So the safe thing to do is to always import Data.Functor?
11:25:58 <srhb> Ojd: As in loop g | g > 42 = do { ... } ?
11:26:20 <texasmynsted> Or maybe I should not be using the default Prelude?
11:29:09 * hackagebot hdocs 0.5.2.1 – Haskell docs tool – https://hackage.haskell.org/package/hdocs
11:29:52 <Guest58861> Hi guys, I am new to haskell and cant figure out, whats wrong with this expression: drawStars xs =                                                                                                                                                                                          
11:29:52 <Guest58861>      let drawStars' :: Integer -> [String] -> String                                                                                                                                                     
11:29:52 <Guest58861>          drawStars' n (y:ys) = if (n == (length (y:ys))                                                                                                                                                  
11:29:52 <Ojd> I was thinking https://thepasteb.in/p/NxhVmVVgKJ4tN
11:29:53 <Guest58861>                                  then ""                                                                                                                                                                 
11:29:56 <Guest58861>                                  else (print n) ++ "=" ++ y ++ (drawStars' (n+1) ys)
11:30:03 <srhb> Guest58861: Use lpaste.net
11:31:14 <srhb> Ojd: Yes, so, loop min max number | number == guess = ...; | number < guess = ...; etc
11:31:27 <Guest58861> http://lpaste.net/357691
11:31:45 <srhb> Ojd: Er, you probably need another argument if you're doing it like that :)
11:31:51 <Guest58861> I get a paste error on "then"
11:31:55 <Guest58861> parse* error
11:32:24 <srhb> Guest58861: I count three left parens and two right in the line before "then"
11:34:25 <Guest58861> srhb how could i miss that, thank you
11:34:55 <Ojd> srhb right now I can do the search. My next step would be to print the guess and do the search
11:35:07 <Ojd> and my last step wuld be prinet the guess, ask for feedback and keep looping
11:35:35 <Ojd> when I try to add the do, I mess with the guards
11:35:53 <Ojd> (ghci complains)
11:37:04 <srhb> Ojd: Paste the broken version :)
11:37:28 <Ojd> "error: parse error on input '|' "
11:38:06 <srhb> Ojd: I can't guess exactly what you did wrong without seeing it.
11:40:55 <Ojd> https://thepasteb.in/p/2RhKzKEZz55H4
11:41:37 <srhb> Ojd: That's not how guards work, I'm afraid. You attach them to the definition of the function itself.
11:43:48 <srhb> Ojd: http://lpaste.net/1833230026347118592
11:44:24 <Ojd> I had that part, but I was trying to sneak the putStrLn
11:44:36 <srhb> Ojd: You can always make more helper functions.
11:45:32 <srhb> Ojd: do { putStrLn "foo"; helper arg1 arg2 } and then attach the guards to helper, etc.
11:48:55 <Ojd> srhb, working on that
11:49:34 <srhb> Ojd: Or, you know, if-then-else as you suggested, to get something working without too many complexities at once :)
11:50:35 * hackagebot haddocset 0.4.3 – Generate docset of Dash by Haddock haskell documentation tool – https://hackage.haskell.org/package/haddocset
11:53:03 <Ojd> srhb, yep, probably I should start with that
11:57:55 <Guest58861> Ok next Problem, I get non-exhaustive pattern on this one: http://lpaste.net/357691
11:58:13 <Guest58861> I cant see why the break condition doesn't work
12:02:16 <Guest58861> Oh dude
12:02:20 <Guest58861> thats so dumb
12:02:24 <Guest58861> i see it
12:03:01 <srhb> procude? :)
12:03:14 <srhb> Yeah, that's mean to debug. :-P
12:05:02 <srhb> Guest58861: You might want to run ghci with -Wall
12:05:11 <srhb> Guest58861: That should give you a better warning if that happens again
12:05:59 <srhb> Guest58861: (Top-level binding with no type signature: procudeStarts [...])
12:06:06 <srhb> Er, Stars.
12:06:10 <srhb> Clearly that's a hard word.
12:12:18 <l30nch0l0> hi
12:13:04 <l30nch0l0> yo anyone here ?
12:13:15 <srhb> Plenty of people. Ask your haskell question :)
12:13:42 <l30nch0l0> aight
12:16:12 <Guest58861> srhb thank you :)
12:16:39 <Guest58861> Is there a way to make that '-Wall' flag permanent or do i have to type it each time i start ghci?
12:18:08 <Tuplanolla> Put `:seti -Wall` in your config, Guest58861.
12:19:53 <Ojd> having issues when trying to print an integer
12:19:58 <Ojd> https://thepasteb.in/p/r0hwlwDY47XHK
12:21:28 <Cale> Ojd: Num isn't enough to ensure you can Show
12:21:45 <Cale> Ojd: You might want (Num a, Show a) => a -> IO ()
12:21:49 <Cale> Or just  Integer -> IO ()
12:22:00 <Ojd> Thanks Cale
12:22:14 <Cale> also, you're not passing an argument to loop
12:22:33 <Cale> Presumably you meant to pass along (x + 1) or something
12:23:20 <Cale> Ojd: Also, print x = putStrLn (show x)
12:24:16 <Cale> So you could write something like  loop x = do print x; loop (x+1)
12:27:54 <dsal> I don't quite understand what fmap does.   How do I think about this?
12:28:20 <dsal> (I've got a lot of wrapping my head around types to go).
12:29:23 <srhb> dsal: Different fmaps do different things. Your best bet is to stare really hard at the type, the laws, and remember that as long these are upheld, it could do anything.
12:29:45 <dsal> I guess I don't quite understand 'Functor'
12:29:56 <srhb> dsal: Which part?
12:30:02 <dsal> This is specifically as to why "fmap head getArgs" gives me a string.
12:30:03 <srhb> dsal: There are very few components to a Functor
12:30:12 <Tuplanolla> Time for a container analogy!
12:30:15 <srhb> noooo
12:30:40 <srhb> dsal: Have you tried unifying the types by hand?
12:30:43 <dsal> I used to program in ocaml a decade or so ago.  I almost understood them then.  heh
12:31:05 <srhb> I don't think OCaml functors and Haskell functors are related.
12:31:06 <dsal> I'm basically a noob here.   I'm at the "Why does this IO thing keep getting in my way" level.
12:31:08 <srhb> Well, not very clearly though
12:31:17 <Xandaros> I like the container analogy. That's how I finally understood functors :P
12:31:25 <srhb> dsal: You should try unifying the types by hand.
12:31:41 <dsal> Yeah, I didn't mean to imply ocaml functors would help me here.  I just assume they won't.  :)
12:31:51 <srhb> Right :)
12:32:31 <dsal> Not sure what you mean by "unifying the types"    getArgs :: IO [String]   whereas head wants [String]
12:32:53 <srhb> dsal: I mean figuring out the type of fmap when it is applied to some function and then getArgs
12:32:57 <srhb> :t fmap
12:32:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:33:05 <srhb> So, identifying f, a and b
12:33:06 <Tuplanolla> :t fmap @IO
12:33:08 <lambdabot> error:
12:33:08 <lambdabot>     Pattern syntax in expression context: fmap@IO
12:33:08 <lambdabot>     Did you mean to enable TypeApplications?
12:33:11 <Tuplanolla> Good one, lambdabot.
12:33:54 <dsal> Well, a and b are [String] and String, right?
12:34:00 <srhb> dsal: Yeah
12:34:36 <Xandaros> Here's an example: for `fmap show (Just 5)`, a could be Int, b is String and f is Maybe
12:35:01 <srhb> Let's stick with one example at a time :-)
12:35:24 <Xandaros> I was just slow at typing :(
12:35:34 <srhb> I know that feeling. q_q
12:35:41 <dsal> Heh.  I have a case I assume is really simple, and it works.  I just don't quite know *why* it works.
12:35:51 <srhb> dsal: Well, did you find f yet?
12:36:08 <dsal> No, I don't get what f is in this case. :(
12:36:24 <srhb> getArgs :: IO [String]
12:36:27 <srhb> So f ~ IO
12:36:27 <mniip> perhaps you should practice on simpler types then?
12:36:31 <mniip> such as 'flip id'
12:36:41 <dsal> I think it's IO I'm specifically confused by.
12:36:48 <srhb> dsal: If we write out the type of fmap now
12:36:49 <mniip> IO is nothing special
12:37:11 <mniip> in the case of type inference/checking, it is absolutely perfectly normal *->* kinded type constructor
12:37:23 <srhb> dsal: fmap :: ([String] -> String) -> IO [String] -> IO String
12:37:34 <srhb> dsal: Now, we can add a (redundant) paranthesis to make clear what is going on
12:37:42 <srhb> dsal: fmap :: ([String] -> String) -> (IO [String] -> IO String)
12:38:11 <srhb> dsal: In other words, this particular invocation of fmap takes a function from [String] to String and converts it into a function from IO [String] to IO String
12:38:36 <dsal> Oh.  ooooh.
12:38:43 <dsal> I misunderstood what was ghci was telling me.
12:38:47 <dsal> (fmap head getArgs) :: IO String
12:38:53 <dsal> I thought it was like, prying away the IOness
12:38:58 <srhb> It is not. :)
12:39:05 <mnoonan> just the opposite!
12:39:36 <dsal> Yeah.  I assumed when it showed me the string, that's all it was.  I've still got a bit to go to understand all the things, but this is good progress. Thanks.  :)
12:39:47 <srhb> dsal: ghci auto prints IO Strings
12:39:50 <Xandaros> You can never pry away the IOness :P (You can pretend like you did for a while, by using do-notation, but you have to go back to reality at some point)
12:39:50 <srhb> dsal: It is a little confusing.
12:39:55 <ltielen> that was very strange. my function didnt want to update in ghci.. kept getting prelude.undefined with an error on line with whitespace
12:40:12 <stites> hey all! I'm in a bit of a weird predicament where I need to make calls to a (stateful) python library -- would anyone have any tips?
12:40:12 <srhb> dsal: (Because normally you cannot do that, wrong type)
12:40:52 <mniip> ltielen, did you :reload the file
12:40:57 <Tuplanolla> If not, you probably shadowed a previous definition, ltielen.
12:41:04 <dsal> Makes sense.  I'm just hacking my way through a small program I want to write.  Thanks everyone.
12:41:11 <srhb> dsal: Welcome, have fun :-)
12:41:17 <Xandaros> That's the best way to learn :)
12:41:31 <dsal> I've got more questions, but I'm going to at least stick with the ones that apply to what I'm doing for now.  :)
12:41:40 <Tuplanolla> If you `let g = f` and `let f = h` later, then `g` still refers to the old `f` that no longer has a name, ltielen.
12:41:48 <ltielen> I did try reloading, but didnt go away. then closed my editor (was already saved), cleaned everything with rm -rf and then it worked again
12:42:36 <mniip> did your clock go backwards by any chance?
12:42:40 <dsal> I'm surely writing awfully unstylish code at this point.  No clue when to use fmap vs. <$> or whatever.  Is there a decent guide to a typical coding style?
12:42:54 <Xandaros> fmap and <$> are the same thing :P
12:43:05 <ltielen> maybe due to a .o not being recompiled? first time I had this happen :p
12:43:12 <johnw> dsal: whatever style you choose, if you ever work for a Haskell company, you'll have to learn something else
12:43:30 <dsal> Well,    fmap head getArgs   vs.   head <$> getArgs
12:43:34 <Tuplanolla> My mental style guide says to not use operators unless you have to, dsal.
12:43:45 <johnw>  I prefer <$> to fmap where possible
12:43:47 <dsal> Ha.  Yeah.  My company has like, slightly more than 0 haskell.
12:43:51 <dsal> haha
12:43:53 <johnw> I mainly use fmap if I want to compose fmap foo . bar
12:43:59 <Xandaros> ^
12:44:01 <Eduard_Munteanu> I generally go with (<$>) for applicatives and monads, and leave fmap to container strucctures.
12:44:06 <Xandaros> Exactly what hohnw said :D
12:44:11 <Xandaros> *johnw
12:44:18 <dsal> Is $ considered good form?
12:44:33 <johnw> I like both $ and parens
12:44:39 <dsal> Bottom of my code looks like this:                BL.putStr $ encode $ process (V.head v) $ V.toList $ V.tail v
12:44:39 <Xandaros> Makes things easier to read IMO
12:44:45 <mniip> I prefer `id` :^)
12:45:10 <Xandaros> I typically use . for most things only use $ at the end, since the . is less noisy
12:45:25 <Xandaros> It's really personal preference, though
12:45:28 <dsal> Hmm...  I'm not sure my brain can effectively use . yet
12:45:49 <Tuplanolla> I still pretend Haskell is really Scheme, dsal.
12:46:06 <Xandaros> Tuplanolla: I hope I never have to read your code :P
12:46:45 <mniip> BL.putStr <<< encode <<< uncurry process <<< (V.head &&& V.toList <<< V.tail)
12:46:51 <dsal> Heh.  Yeah.  Mine was really looking like scheme for a bit.
12:47:20 <Tuplanolla> Xandaros: http://lpaste.net/352328
12:47:38 <Xandaros> Them arrows. I should really get used to those at some point
12:48:00 <dsal> I don't know what they mean.  Some kind of left shift.
12:48:04 * shapr fires arrows at Xandaros, aiming for immersion learning
12:48:23 <Xandaros> dsal: Not a left shift. Ignore that for now :P
12:48:37 <Xandaros> More function combinators akin to (.)
12:48:41 <dsal> Left shifting my encoding into the str.
12:48:44 <srhb> dsal: Don't worry about it. If you had to learn every kind of functiony applicationy thing in Haskell, you wouldn't get very far :-)
12:49:05 <dsal> I'm having trouble even finding catalogs of operators people use.  Took me a while to find <$> and <*> (which were in an example from last night)
12:49:08 <srhb> Haskellers saw functions and went: BUT WE CAN DO MORE.
12:49:26 <srhb> dsal: Usually those turn up when you learn about applicative functors.
12:49:41 <Xandaros> ($) and (<$>) are probably the operators I use the most. Together with (<>)
12:49:51 <mnoonan> Xandaros, (.)?
12:49:52 <Xandaros> and (.) of course
12:49:53 <ltielen> dsal: you can use hoogle to find functions
12:49:56 <mnoonan> :)
12:50:57 <dsal> The docs can be a little sparse.  The complete documentation for <> is "beside"
12:51:23 <mniip> umm
12:51:36 <mniip> (<>) :: Monoid m => m -> m -> m; infixr 6
12:51:36 <mniip> An infix synonym for mappend. Since: 4.5.0.0
12:51:37 <bodisiw> what's the best way to learn the 'name' (pronouncable hopefully?) of common operators?
12:51:49 <srhb> bodisiw: Based on experience: Asking in here.
12:51:50 <dsal> mniip: Huh.  Well hoogle mislead me.  :(
12:52:07 <srhb> bodisiw: You'll soon discover that people don't pronounce them the same way though.
12:52:11 <dsal> bodisiw: I found this:  https://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators -- it doesn't list most of the operators discussed here recently. :)
12:52:13 <shapr> sometimes I don't realize I don't know the name of an operator until I try to speak the problem to someone else
12:52:16 <srhb> ICFP should put down a committee.
12:53:02 <bodisiw> oh cool that stackoverflow has a good response
12:53:02 <mniip> heh
12:53:19 <bodisiw> but yeah it would useful to some people like me if there were a glossary somewhere for that
12:53:30 <Xandaros> I like calling (>>=) "shove"
12:53:33 <mniip> I don't think I ever questioned the pronunciation of the operators mainly because I've never had to communicate complex haskell to anyone over voice
12:53:51 <srhb> Xandaros: I call it fish...
12:53:57 <bodisiw> (.) is "pipe to" and not "compose"? wha?
12:54:01 <Xandaros> (>=>) is fish for me
12:54:07 <srhb> I rarely use >=>
12:54:08 <dsal> I used to have a guy on my team here who was pretty hardcore into haskell.  That was a couple years ago.  He moved away from civilization to live on a secluded island off of Canada.
12:54:09 <mniip> but I guess <$> fmap, <*> ap and >>+ bind
12:54:10 <srhb> It remains nameless.
12:54:11 <mniip> >>=
12:54:17 <shapr> I think of (>=>) as reverse bind
12:54:33 <Xandaros> I have used (>=>) exactly once. I was like "omg, I actually used this thing"
12:54:36 <shapr> dsal: lots of Haskell on secluded islands?
12:54:38 <mniip> >=> is just compose
12:54:46 <shapr> :t (>=>)
12:54:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:54:54 <bodisiw> dsal, is that a parable of some sort? :-)
12:54:57 <shapr> :t (flip >>=)
12:54:58 <lambdabot> ((b -> a -> c) -> (a -> b -> c) -> b1) -> (a -> b -> c) -> b1
12:55:03 <mniip> :t (>>>) `asTypeOf` (>=>)
12:55:03 <jfischoff> I’m using wreq (which uses http-client) and I have a response that has a “Set-Cookie” header, but the Response’s cookie jar is empty? Anyone know why that might happen?
12:55:04 <lambdabot> error:
12:55:04 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ m b
12:55:04 <lambdabot>       Expected type: (a -> m b) -> (m b -> m c) -> a -> m c
12:55:06 <thimoteus> i usually use <=<
12:55:07 <dsal> shapr: I suspect if I start getting more into haskell, I'll move to a secluded island and not have to worry about pronunciation.
12:55:47 <shapr> dsal: so why'd you get into Haskell, and not when you had a hardcore Haskell coworker?
12:56:00 <srhb> dsal: Joey Hess is also a good example of where this can lead...
12:56:24 <shapr> haha
12:56:41 <shapr> Wait, maybe joey hess was the hardcore Haskell coworker who moved to an island?
12:56:45 <dsal> shapr: I used to do ocaml and liked it, but haven't had any fp stuff going on in a while.  I've tried learning haskell off and on, but never wrote anything remotely useful.  I've been programming almost entirely in go lately.  It's super easy to do anything and my brain is getting soft.
12:56:53 <shapr> I do like using joeyh's code
12:57:01 <dsal> My coworker's name was Jason.
12:57:13 <shapr> I get extremely frustrated when I try to write Go code
12:57:16 <dsal> Also, that was pretty much right after I took a new job, so my brain had plenty to do at the time.
12:57:17 <Xandaros> I still need to try Go. It seems to be popular
12:57:39 <shapr> yeah, I need to suck it up and learn enough Go to get by, it's very popular.
12:57:42 <dsal> I like go.  It's super boring.  Does all the things I want with minimal effort.  It's not "satisfying" but jobs get done.
12:58:08 <Xandaros> Sounds ideal
12:58:11 <srhb> I loathe it. It's like it pretends there were no developments in computer science in the last fifty years.
12:58:12 <shapr> Go feels like it's missing out on a bunch of useful tools
12:58:22 <dsal> At the same time, it's got a lot of other useful tools.
12:58:24 <srhb> I can't shut out the annoyance of not being able to reach for the right tool for the job.
12:58:52 <shapr> yeah, I have that problem
12:58:52 <dsal> On the other hand, it's the only language the company in which I can look at code and immediately know what's happening (almost all the time, anyway).
12:59:26 <dsal> i.e., I don't mind writing whatever for my own code, but I don't want to look at other people's stuff.
13:02:41 <shapr> dsal: observationally, many useful things are being written in go, so it has something worthwhile
13:04:23 <dsal> yeah.  it's easy to do the right thing.  There are some parts that are annoying (nothing remotely fp-like, no const values, people complain about generics and stuff).   The interface model is kind of neat, but people still try to write java in it.  Then they get angry when they figure out it's not an OO language.
13:04:58 <dsal> How do I do super basic testing of my code in haskell?  My program is one file and has a function that computes great circle.  How do I go about writing a test for that function?
13:05:47 <Xandaros> dsal: Take a look at quickcheck and hunit
13:06:00 <mnoonan> hspec, too
13:06:14 <shapr> dsal: yeah, one of those. HUnit is the familiar unit testing, and quickcheck is property based testing
13:06:44 <dsal> I'm not sure how quickcheck would be beneficial here.  I've often wished it would do something nice for me.  go has a quickcheck built in that's almost entirely useless.
13:06:58 <dsal> What I want to know is given a pair of coordinates, does it spit out the distance I expect.
13:08:39 <Tuplanolla> QuickCheck tends to not find weird corner cases, especially if your types are lenient.
13:08:58 <shapr> Tuplanolla: did you see DRMacIver's recent post on that?
13:09:08 <mnoonan> dsal, see https://hspec.github.io/
13:09:15 <Tuplanolla> Probably not, shapr. Let's see it.
13:09:35 <MarcelineVQ> super basic? myDistance x y  == expectednumber
13:10:01 <dsal> Oh, cabal -- is there a way to like, record my dependencies based on my code?
13:11:06 <Xandaros> Since a module could theoretically be provided by different packages, no. Just stick them in your .cabal file manually :P
13:11:37 <shapr> huh, I can't find it now
13:12:04 <Xandaros> That said, it does give suggestions if you try to use a hidden module (installed, but package is not in the .cabal file)
13:12:18 <Tuplanolla> Is it this one, shapr: http://hypothesis.works/articles/types-and-properties/
13:12:25 <shapr> oh right!
13:12:53 <Xandaros> Looking at hspec, I think the haddock documentation mentions ways to declare properties for functions which could be checked. Is there something that does this?
13:13:34 <shapr> Tuplanolla: what do you think about that article?
13:13:41 <mnoonan> Xandaros, "prop>", maybe?
13:14:04 <Xandaros> Yes, exactly. Something that checks those
13:14:52 <joeyh> shapr: nah, it's the other way around. I was stuck in the steep part of the haskell learning curve until I had some good uninterupted space in which to study
13:14:57 <Ojd> I am stuck , couldn't make that function works https://thepasteb.in/p/LghNnNQKxAzHZ
13:15:28 <mnoonan> Xandaros, doctest, I think, though I haven't used it
13:15:37 <shapr> joeyh: oh that makes sense!
13:15:43 <Tuplanolla> It's a good review, shapr.
13:17:00 <shapr> I wonder if that's why go's quick is considered not helpful by dsal?
13:17:39 <dsal> Yeah, the generators are not all that useful.  You can sort of make them a bit more useful with enough work to make it not practical to use it in the first place.
13:17:54 <mnoonan> shapr: this seems like a prime example of a place where generics make life much better
13:18:26 <Tuplanolla> The situations I find myself reaching out for testing in are such that property-based testing rarely helps, shapr. Say, finding a bad point in a specialization of `Integral a => a -> a -> a -> a`.
13:19:02 <shapr> Tuplanolla: do you think better data generators would help? or something else?
13:19:28 <Tuplanolla> In that case it's much more useful to pick a small type like `Int8` and a large type like `Int64`, go through the whole domain and compare results, shapr.
13:19:41 <dsal> It's not obvious to me how I get code from my main program into hunit -- do I need to make a module that contains the code I need to test and also want to use in main?
13:20:07 <dolio> But there are property-based tests for that, too.
13:20:26 <mnoonan> dsal: if you use hspec, you can take advantage of auto-discovery.. you basically have a test/ directory parallel to src/, with an analogous module structure, and it discovers and runs the tests
13:20:48 <dsal> I don't have a src or test directory.  I'm clearly doing this poorly.
13:20:55 <Tuplanolla> Well, I have not been exposed to them yet, dolio.
13:20:57 <dsal> But how do I reference the code I want to test?
13:21:36 <mnoonan> hspec-discover does magic, so that "MyModuleSpec.hs" sees the guts of "MyModule.hs"
13:22:17 <dsal> Sure.  I just don't have a module at all.  I'm trying to figure out how to lay out really simple programs.
13:22:50 <dsal> My code currently reads a csv file that contains gps coordinates in it, finds the first one, and then adds a column with the distance from the first coordinate to all the rows.  I want to test the distance function.
13:23:21 <dsal> (originally, I was going to try the 'geodetic' module, but it doesn't compile or something, besides -- this is a good exercise)
13:23:46 <mnoonan> I think the normal approach is to split your code into a library with essentially all of the functionality, a tiny Main module, and then tests for the library.
13:24:55 <dsal> Ah, OK.  I've never liked that approach all that much, but it's common in a lot of languages and makes the answer more obvious.
13:25:18 <mnoonan> there's probably something you can do in a single file, but I don't ever work that way so I can't tell you :)
13:26:11 <dsal> There's a 'geodetics' module.  Let's see if that one builds.  I'd rather not use my own code for this anyway.
13:26:52 <sm> mnoonan: yes, there's doctest
13:27:13 <dsal> doctest sounds neat.  Probably suffers the same problem, though.
13:28:09 <NickHu> Quick question, when you use a large chunk of someone else's code in a module, assuming under BSD3 license, are you supposed to include them in the module copyright header?
13:28:37 <sm> or, you can keep unit tests in your main source file
13:29:01 <sm> s/unit/hunit/
13:30:18 <codeshot> NickHu, You should check with a lawyer. Or maybe the author of the module.
13:31:34 <codeshot> Sorry for the avoidance, but it is a legal opinion you're asking about so a lawyer will know when an engineer can only talk balls - but the author can absolve you of having to care by telling you explicitly what they think
13:31:37 <NickHu> codeshot: I've spoken with the author, and he's happy for me to use it - I don't know if I ought to, or if it's common practice, to include him in the copyright header though
13:32:15 <NickHu> I will give him attribution somewhere, but I don't know if the copyright header is appropriate
13:32:27 <Tuplanolla> Does it cost you to put them there, NickHu?
13:32:41 <codeshot> At the risk of incorrectly sounding like lawyer, I think they have copyright so you have to list them as such
13:32:54 <sm> NickHu: it's common to see "portions of this code are copyright ..." 
13:32:56 <codeshot> anything else would be false
13:32:57 <mud> I add multiple copyright statements when a file includes work copyrighted by different groups/people. "parts copyright: blah blah"\n"parts copyright: foo bar"
13:33:25 <mud> Well, you just have to do whatever the license requires. It's a fairly short license. It doesn't say anything about module headers per se.
13:33:43 <cocreature> “Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.” makes it pretty clear that you need the copyright somewhere. I don’t think you need it in the header
13:33:58 <cocreature> eh binary form, I can’t read
13:34:10 <cocreature> that’s the one “Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.”
13:34:16 <NickHu> Tuplanolla: No, but to be perfectly honest I don't think he'd like to be bothered about further developments - this is a very academic piece of code
13:34:21 <mud> "The above copyright notice" is the one in the LICENSE usually. I certainly don't touch that one, though usually I'll rename the file to specify what the hell that license is for.
13:34:35 <codeshot> The easiest thing is to talk about what terms you can license the integrated chunk under and do whatever fits as a result if there is then a clear path.
13:34:50 <codeshot> so you come together mutually as co-authors of the module
13:34:55 <codeshot> if you can do that
13:35:02 <NickHu> Yes, I am basically packaging it up on Hackage for him, also under BSD3 license
13:35:34 <codeshot> So I think you just list him as a copyright holder, along with yourself
13:35:47 <codeshot> have a google for advice on joint authorship and joint copyright
13:35:48 <NickHu> I just wanted to know what the etiquette was, I know the license doesn't explicitly require me to put him down as a copyright holder in the module header
13:35:59 <mud> I would
13:36:16 <koz_> Likewise.
13:36:21 <koz_> I mean, what's the harm in it?
13:36:48 <NickHu> It's more that I didn't think it was the done-thing
13:37:01 <codeshot> It's not a community etiquette thing, it's a legal requirements thing
13:37:19 <NickHu> E.g. I'm sure many people have contributed to bits of pandoc, but the module headers don't have a giant list of copyright holders
13:37:33 <codeshot> Sometimes people assign copyright
13:37:35 <mud> codeshot: There are license requirements, but people usually go beyond what's technically required. The BSD and MIT licenses are ridiculously easy to comply with, the require so little.
13:37:48 <codeshot> eg, the FSF will not accept a patch unless you assign copyright to them
13:37:56 <codeshot> to avoid this kind of issue
13:38:24 <mud> Yeah, bigger projects have contributor agreements spelling out if you're assigning copyright or giving a license or whatever happens.
13:38:41 <mud> Otherwise things are a mess. Not really sure what the hell happens without that.
13:39:05 <Tuplanolla> You collect a lot of names.
13:39:11 <NickHu> I think I'll just email him and see what he wants me to do - I know not a lot of people are happy having their emails in plaintext github files
13:39:57 <codeshot> This is such a big topic that we could go on for many days talking about the nuances and things which is why I'm suggesting just talking to the other author to see if you can agree what to do
13:40:27 <codeshot> In NickHu's case it's probably easiest to be joint-copyright holders and to be listed as such if you have a google to see how to indicate such
13:41:07 <codeshot> It's easy to agree to do that and then you both know where you stand and there's unlikely to be a major dispute in the future
13:41:46 <codeshot> as always, get a good source of advice for any solution you think you're going to go for 'cos we're just engineers here and thus bullsh**ers :D
13:42:40 <mud> Tuplanolla: Well, I mean you're obviously submitting code, usually with some understanding that it's going to be used for something, but if you don't explicitly give any kind of license ... I don't know what happens there at all.
13:42:58 <codeshot> Of course, best flexibility is to get the other author to assign the copyright to you like fsf do but many people don't like to do it
13:43:12 <bartavelle> clear
13:43:13 <mud> codeshot: Heh ... ew.
13:44:23 <NickHu> Yeah thinking about it I wonder if GPL preambles in the linux kernel or something collect thousands of lines...
13:44:26 <shapr> codeshot: and Germany disallows copyright transfer
13:45:19 <mud> Ah ya that too, I think a few places do, even berne members. copyright transfer and "I give this to the public domain" are on my list of things not to trust.
13:46:03 <NickHu> My professor's approach to all of this is "yeah it's public domain I don't want to deal with it"
13:46:28 <mud> That's a pretty bad approach though. Some places don't have that concept, don't allow it, or it's unclear if that's possible. Giving a permissive license is better.
13:47:29 <NickHu> Why do you think it's better?
13:48:51 <mud> NickHu: From what I've read in the USA and other places it's at best ambiguous if it's even possible to explicitly put things you wrote in the public domain. So ... it might do nothing, as far as I can tell. It has problems other places too.
13:50:09 <NickHu> Interesting
13:52:34 <mud> At least one place I've worked didn't allow it as an acceptable "license" thing for code reuse, you needed something more.
13:53:27 <NickHu> That's very peculiar
13:53:34 <NickHu> At least it sounds strange to me
13:53:43 <NickHu> Is it maybe more of a US thing?
14:00:09 <mud> NickHu: It doesn't seem to be US only. But the US is enough for me.
14:06:06 <dminuoso> [(2*)] <$> (.)(3*)
14:06:10 <dminuoso> Am I naive in expecting this to work?
14:09:09 <johnw> wrong argument order
14:09:16 <johnw> > ((.) (3*)) <$> [(2*)]
14:09:19 <lambdabot>  [<Integer -> Integer>]
14:10:23 <eacameron> I'm getting Couldn't match representation of type 'm a' with that of 'm a1' arising from a use of 'coerce'
14:10:32 <eacameron> I have no idea how to look into this and figure out where the problem is
14:10:53 <dsal> Anyone know how to use this https://hackage.haskell.org/package/dimensional-1.0.1.3/docs/Numeric-Units-Dimensional.html thing?
14:11:08 <dsal> I've got a "Length Double" (value in meters) and just want the number.
14:11:13 <dsal> (in meters)
14:11:38 <dminuoso> johnw, ah well. I'm happy that the idea was right! :-)
14:11:48 <dsal> show prints out "5853100.990908321 m"
14:11:59 <dsal> Which, I'm also fairly sure is incorrect.
14:12:44 <dsal> Maybe this code is also wrong.  Man.  Cant other people's code work?
14:12:49 <srhb> dsal: extractValue, I believe.
14:15:51 <dsal> I don't see what exactValue wants -- but I'm pretty sure it's not five million meters between these two points on earth.
14:16:28 <dsal> Prelude Geodetics.Geodetic Numeric.Units.Dimensional> a
14:16:28 <dsal> 40° 41' 21.12" N, 74° 2' 39.84" W, 0.0 m WGS84
14:16:28 <dsal> Prelude Geodetics.Geodetic Numeric.Units.Dimensional> b
14:16:28 <dsal> 48° 51' 29.88" N, 2° 17' 40.20" E, 0.0 m WGS84
14:16:28 <dsal> Prelude Geodetics.Geodetic Numeric.Units.Dimensional> groundDistance a b
14:16:29 <dsal> Just (5853100.990908321 m,0.9374771792466613,1.95110476194196)
14:18:51 <srhb> dsal: almost 6000km
14:18:54 <srhb> dsal: Sounds right to me.
14:19:12 <dsal> Oh.  Yeah.  OK.  I'm just dumb, then.  :)
14:19:28 <dsal> Yeah, I was doing it in km before.  Now I just need to figure out how to get the value extracted.
14:20:15 <dsal> (I was doing my stuff in km before, which broke my brain)
14:20:57 <srhb> dsal: Are you sure what you want is to get it out?
14:21:04 <srhb> dsal: You lose safety by doing that.
14:21:11 <dsal> This is the point where I'm putting it back into the csv.
14:21:12 <srhb> dsal: What are you actually trying to do?
14:21:15 <srhb> Ah.
14:21:23 <dsal> Just make a string of a sensible value to put in the csv.
14:21:36 <dsal> The units are good -- clearly what I was doing before was more confusing.
14:24:40 <srhb> dsal: coerce (thing :: Quantity DLength Double) :: Double
14:24:50 <srhb> dsal: From Numeric.Units.Dimensional.Coercion
14:25:30 <srhb> A better solution is probably to have a pretty printer that specifically gives you a string of the absolute value in the wanted unit
14:25:31 <dsal> yay.  That works.  Thanks!
14:25:40 <dsal> Heh, I also don't understanding printing.
14:25:42 <srhb> (but coerce might be used to implement that)
14:26:22 <srhb> showIn meter thing gets close
14:26:58 <dsal> Yeah, that just sticks the ' m' at the end.
14:27:07 <dsal> Also, the distance from a point to itself is apparently NaN *sigh*
14:28:29 <srhb> dsal: By the way
14:28:42 <srhb> meter /~ meter ought to be unitless, right?
14:29:02 <dsal> Ah, yes
14:29:10 <dsal> That also looks useful.  :)
14:29:20 <srhb> Very. And keeps invariants better :)
14:29:32 <dsal> Trying to figure out how to unNaN myself now.
14:29:52 <srhb> Maybe not use Double
14:30:05 <dsal> I'm in other people's code land now.
14:30:26 <dsal> Giving me a NaN from two points that represent the same location seems like bad behavior.
14:30:49 <srhb> Ugh, why is that not parameterized...
14:32:07 <dsal> It's geodetic stuff.  So whatever the appropriate representation of a lon/lat/altitude point is would change based on the ellipsoid, I guess.  So from that perspective, I guess it's parameterized, but it's pretty abstract to me.
14:33:03 <erisco> we should have a floating point type that also carries the error bars
14:33:38 <dsal> heh.  That'd be helpful for testing.
14:33:48 <dsal> I ended up with this:
14:33:49 <dsal> distance a b = case groundDistance a b of
14:33:49 <dsal>                  Nothing -> _0
14:33:49 <dsal>                  Just (d, _, _) -> if (isNaN (d /~ meter)) then _0 else d
14:34:15 <dsal> feels dumb, but does what I want.
14:35:51 <jared-w> dsal: looks fine to me. What's the "_0"?
14:35:57 <dsal> _0 == 0 meters
14:36:01 <dsal> I guess.  I saw it in the docs.
14:36:29 <jared-w> ahh you're using a library, okay
14:36:41 <erisco> isn't there a postfix op extension? or is that upcoming?
14:36:53 <eitanChatav> What is your favorite Haskell database library? What don't you like about it? What do you wish it could do that it cannot?
14:37:25 <erisco> eitanChatav, at least 500 words and due by Friday?
14:37:40 <Tuplanolla> > (yes!!!) -- erisco
14:37:43 <lambdabot>  There is!
14:37:46 <eitanChatav> erisco: yes please :-)
14:38:06 <NickHu> I go to the hackage.haskell.org/package/mypackage url and it tells me that it doesn't exist
14:38:07 <eitanChatav> or just spitball
14:39:00 <erisco> there is a library that lets you persist ADTs and that seems popular
14:39:25 <eitanChatav> erisco: you mean acid-state?
14:39:33 <erisco> that could be it
14:39:57 <User_01> Sup?
14:40:06 <dsal> I got yelled at by some bot.  Did I exceed line rate limits?
14:40:22 <User_01> ayy lmao
14:40:52 <erisco> you can have some abstract store like that or talk more explicitly in SQL
14:41:25 <User_01> what you sayin' foo'?
14:41:31 <eitanChatav> so, you like not using a traditional database backend (postgres, mysql, etc)?
14:41:52 <geekosaur> -XPostfixOperators which is a section hack
14:41:56 <erisco> at a time I was thinking about how to have an eDSL for SQL which can be extended for various combinations of dbms
14:41:58 <eitanChatav> ah, I missed the "or"
14:42:15 <eitanChatav> erisco: yes, let's focus on SQL eDSLs
14:42:21 <eitanChatav> what would you like to see in one?
14:42:30 <erisco> so you would have at basic the SQL standard and then you can add features to it
14:42:40 <erisco> but features you add restrict which rdbms it will work with
14:43:00 <erisco> so you can add pg's geospatial extensions but now you are pg specific
14:43:22 <User_01> How does one become a hacker?
14:43:23 <eitanChatav> what about separate libs for each rdmbs? is there a reason you'd like to be able to have 1 lib target multiple?
14:44:08 <eitanChatav> for example the "*-simple" suite of libs is a different lib for each backend
14:44:16 <eitanChatav> is that a bad design?
14:44:34 <erisco> there are various solutions of embedding SQL that leave you agnostic to which rdbms is being used
14:44:48 <erisco> and by doing so you have no leverage of specific features when you want them
14:45:28 <eitanChatav> but with 1 lib per backend, you don't have an issue with leveraging specific features; instead you may have an issue if you want to switch out backends
14:46:31 <erisco> yes, you do
14:47:12 <eitanChatav> i'm working on a database lib, just targeting postgres for now
14:48:44 <dsal> I've not used postgres in a long time.  That'd be a great output for the thing I'm working on.
14:49:22 <eitanChatav> dsal: what is the thing you're working on?
14:49:30 <dsal> Just various logs.
14:49:38 <dsal> I fly RC stuff.  Got lots of RC logs.
14:49:44 <eitanChatav> aha, and what would you like in a haskell postgres lib?
14:49:54 <dsal> Convert my logs to databases.  :)
14:50:05 <dsal> I've not done much with traditional databases in a while.
14:50:16 <erisco> getting appropriate error information out of pg is a challenge
14:50:31 <eitanChatav> erisco: can you elaborate?
14:50:43 <erisco> not really... been a couple years since I last used it
14:50:48 <eitanChatav> fair enuff!
14:50:55 <erisco> but there are various errors where it is more vague than you'd like
14:51:26 <eitanChatav> what if your SQL was statically checked against your schema, eliminating swaths of bugs
14:51:32 <eitanChatav> good thing?
14:51:38 <dsal> Man, it's hard to work today.  I've got barely working haskell code.
14:51:42 <boj> eitanChatav: you may want to look at tisch
14:51:56 <boj> or opaleye
14:52:01 <erisco> it is probably weak because people are checking data integrity before it enters the database
14:52:23 <eitanChatav> boj: tisch is cool. opaleye is cool. there are lots of cool libs. Personally, I think they're all missing things
14:52:27 <erisco> but I wanted to check integrity at the database, not before it, and getting the correct error information out is difficult
14:52:50 <boj> eitanChatav: cool. just making sure you were aware of them before reinventing the wheel :)
14:53:51 <eitanChatav> for instance, most opaleye based libs like tisch don't support DDL statements I think (could be wrong)
14:54:36 <boj> would it make more sense to contribute such a feature, than write a new lib?
14:54:39 <erisco> personally I don't care about the application being checked against the database statically
14:54:53 <erisco> they are not statically tied, so to me it is irrelevant
14:55:09 <eitanChatav> boj: maybe, but too late now :-)
14:55:14 <erisco> in fact if you rely on that then you're just going to allow yourself more bugs
14:55:22 <exio4> can't some libraries give you the DDL?
14:55:42 <eitanChatav> well, thanks for the responses! gotta go pick up my folks at the airport
14:55:45 <eitanChatav> bye
14:55:52 <erisco> see you later
15:07:08 <erisco> boj, sometimes the cost of understanding someone else's program is just as much or outweighs writing it yourself
15:07:46 <boj> erisco: no disgreements there. on the other hand, the cost to the community is yet another library
15:08:08 <Xandaros> http://tcpst.net/0v58 Sometimes I feel like I should really make like a list of extensions I use a lot and just declare them all in every project, necessary or not...
15:08:32 <Xandaros> On that note, FlexibleInstances really needs to go.
15:09:08 <erisco> that is why we proposed {-# LANGUAGE EKMETT #-}
15:09:28 <Xandaros> lol
15:10:00 <Xandaros> {-# LANGUAGES EverythingThatDoesntBreakStuff #-}
15:10:11 <Xandaros> s/S//
15:15:40 <NickHu> Is this a good place to contact the hackage maintainers?
15:16:10 <Eduard_Munteanu> There's also #hackage.
15:21:03 <NickHu> If I go to hackage.haskell.org/package/mypackage and it gives me a package not found, yet there is a listed maintainer for said package, what does that mean?
15:34:30 <dsal> Is there a convention for keeping up with the list of package requirements I need for a project?
15:36:37 <hodapp> isn't that sort of what Cask is for?
15:36:54 <dsal> Maybe?  I don't know things.
15:41:06 <sm> dsal: how are you getting tripped up ?
15:41:17 <dsal> Just don't know what to put where.
15:41:30 <dsal> I made a program.  I needed to install dependencies for it.  I don't know where to put that list.
15:42:11 <dsal> e.g., I'm using Data.Csv from the 'cassava' library and Geodetics.Geodetic from the 'geodetics' library.  I'm going to forget that shortly.
15:43:03 <om_foxy> Hi, I can `stack build` a project from the command line but when I try `C-c C-l` in emacs (with `(custom-set-variables '(haskell-process-type 'stack-ghci))`) I get an error that all the package modules I import can't be found.
15:43:11 <sm> the usual place is in a MYPROJECT.cabal file. Or (more recently) a package.yaml file.
15:43:36 <sm> dsal: for small programs, you can also just list them at the top of the file using a "stack script" shebang line
15:44:09 <dsal> Woah.  neat.
15:45:23 <sm> actually, recent enough stack and maybe recent enough cabal can figure them out just from your imports
15:46:19 <dsal> Does one tend to make source executable for this thing?
15:46:45 <sm> the stack script way assumes an executable source file with a shebang line, yes
15:47:10 <dsal> I just ran 'stack thing.hs'
15:47:11 <sm> it's a good way to go for one-file programs that don't need to be on hackage
15:47:16 <dsal> It's downloading the internet now.
15:47:34 <sm> good good
15:47:45 <dsal> Thanks for the pointer.  This is appropriate for my program.
15:47:50 <sm> np
15:47:53 <dsal> It's terribly unlikely anyone will ever care about it.  :)
15:49:11 <dsal> man.  It's installing ghc.  I don't think I need that.
15:50:02 <sm> it's usually considered a good idea to let it do that, for reproducability
15:50:28 <sm> otherwise your script probably will break when some other ghc version happens to be in path
15:50:41 <dsal> Heh.  I'm OK with that for now.
15:50:48 <dsal> I'll add that to the commit, though.
15:51:24 <sm> ghc ? that wouldn't be recommended
15:52:40 <jared-w> yeah, ghc is for your own computer. It's also huge and doesn't do well with git.
15:52:53 <hodapp> dsal: uhhhh, I'm sorry, I thought we were in #emacs, not #haskell. Ignore everything I said about Cask.
15:53:05 <jared-w> hodapp: lol I was wondering about that :)
15:53:30 <dsal> hodapp: ha.  I'm not in #emacs, but it's an OS I spend a lot of time in.
15:53:33 * sm didn't like to say
15:54:20 <dsal> I guess I don't get the ghc confusion.  I've got ghc.  Is the idea to use stack to do all of the work?
15:54:42 <dsal> The only thing I was considering changing was tracking my dependencies a bit.
15:55:01 <sm> you can add --installed-ghc or something to the stack command to skip the ghc installation
15:55:17 <dsal> Yeah, I'm using that now.
15:55:40 <sm> just if you want the script to work for others (or for you in a year or two), you probably shouldn't
15:55:59 <dsal> Yeah.  I don't care about others or my future self.
15:56:04 <sm> cool
15:56:40 <sm> hopefully someone will point your future self back to this chat log :)
15:56:44 <Psybur> Anybody have any thoughts on the state of frp and game engines in haskell? Is frp the way to go or is it missing the mark?
15:57:52 <sm> considered probably the way to go, but still a bit bleeding edge Psybur 
15:59:52 <dsal> sm: I assume just about everything I'm doing is wrong at this point.   I don't quite get what this stack thing does now, though...  It actually runs the program as a script.  Does it use any of the common cabal stuff?
16:00:06 <jared-w> I think the biggest thing about frp is that it gives a coherent "story" about how to treat dynamic "wait and respond to events as they happen" situations
16:01:34 <sm> dsal: stack uses cabal under the hood. Usually you create a full blown stack&cabal project with "stack new". You can also use just cabal, "cabal new" or something. This "stack script"/shebang style is a special case stack also supports, which is more lightweight
16:02:23 <sm> for more understanding, you should probably skim cabal's user guide and then stack's
16:03:17 <dmwit> I like monochrom's (?) SICP.
16:03:18 <dmwit> ?where SICP
16:03:18 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
16:03:19 <lambdabot> Packages"
16:03:25 <dmwit> The last one there.
16:03:44 <dmwit> It probably does assume some familiarity with Cabal, though.
16:05:14 <dmwit> On reviewing it: it starts from very basic assumptions indeed. Yay for thoroughness!
16:25:56 <erisco> see we have postfix operators... http://lpaste.net/357700
16:27:26 <erisco> I bet you can set something up for unit analysis too
16:29:03 <erisco> with a different num class you might instead have 100*m + 50*m
16:31:21 <jared-w> erisco: That's pretty neat. However, at some point, it feels like you're just wrangling the compiler far too much into integrating an EDSL into the "language" itself. It'd probably be easier to just make an EDSL or DSL rather than worry too much about screwing around with ghc extensions to make units look more 'traditional'
16:31:58 <erisco> the notation matters
16:33:06 <ggVGc> write your own haskell!
16:33:13 <ggVGc> and implement the edsl in it
16:56:14 --- mode: tolkien.freenode.net set +o shapr
16:56:26 --- mode: tolkien.freenode.net set +o ChanServ
17:00:39 --- mode: tolkien.freenode.net set +o shapr
17:00:51 --- mode: tolkien.freenode.net set +o ChanServ
17:06:41 <koz_> I'm trying to get to grips with ST and mutable vectors - could someone give me a helping hand? http://lpaste.net/357701
17:08:12 <pacak> koz_: Try putting () in there, ghc will complain and suggest something better.
17:08:59 <pacak> koz_: ghcid/hdevtools/whatever works nicely here.
17:09:14 <koz_> pacak: Already using those tools, and it's not helping any.
17:09:38 <pacak> What kind of type error are you getting?
17:09:53 <koz_> pacak: Do you mean 'if I replace the hole with ()'?
17:09:57 <pacak> yep
17:10:05 <koz_> pacak: I'll modify the paste and add the error.
17:10:53 <Guest83660> need a pastebin that runs ghcid
17:11:33 <koz_> pacak: Amended: http://lpaste.net/357701
17:12:09 <MarcelineVQ> there is one, to a small degree :>
17:12:12 <MarcelineVQ> @letpaste 357701
17:12:14 <lambdabot>  .L.hs:242:8: error:
17:12:14 <lambdabot>      • Couldn't match expected type ‘()’ with actual type ‘m0 ()’
17:12:14 <lambdabot>      • In a stmt of a 'do' block: tmp <- MV.read v i
17:12:36 <pacak> So it says it wants answer in form of m0 ()
17:12:51 <pacak> Let's give him IO () and see how it complains now
17:13:34 <koz_> pacak: Says that it can't match s with RealWorld, which I actually get.
17:13:43 <koz_> I wanna work in ST, which has a state parameter usually called s.
17:13:50 <koz_> I just have no idea what I should be returning.
17:13:57 <sm> MarcelineVQ: what does the @letpaste command do ?
17:14:09 <koz_> Wait, I got it. ST s ()!
17:14:22 <MarcelineVQ> loads an lpaste into lambdabot
17:14:37 <sm> neat
17:14:59 <koz_> MarcelineVQ: I'll have to make use of that in the future, thank you!
17:15:04 <sm> more channel spam :)
17:15:05 <koz_> Is there anything lambdabot can't do?
17:15:15 <koz_> @maketea
17:15:15 <lambdabot> Unknown command, try @list
17:15:18 <koz_> :(
17:15:26 <sm> it can't provide a nice UX
17:15:34 <pacak> koz_: solving p - np problem
17:15:34 <koz_> It also can't make hot beverages.
17:16:13 <jared-w> no hot beverages?
17:16:17 <jared-w> huge deal breaker right there
17:16:55 <koz_> Can ST be used in monad transformer stacks?
17:17:02 <koz_> And if so, does it have to be the innermost, like IO?
17:19:57 * hodapp mutters something about the matrix
17:20:00 <jared-w> koz_: monad transformer stacks are usually done with certain libraries (such as mtl or some other library). It'll depend on the transformer stack but I don't know of any that don't support ST and IO
17:21:12 <koz_> jared-w: Let's assume mtl then. Does mtl require ST to be the innermost member of the stack, like it does with IO?
17:22:32 <monochrom> Actually it is the other way round. ST and IO require to be at the bottom.
17:23:33 <koz_> monochrom: Sorry, I must be confused with my terminology. What I meant was 'there is no IO transformer, becuase that's the thing that gets transformers applied to it'.
17:23:39 <koz_> And I assume ST is the same?
17:24:18 <monochrom> I am skeptic about your "because" part.
17:24:41 <jared-w> koz_: there is a StateT monad transformer
17:24:43 <jared-w> :t StateT
17:24:44 <lambdabot> (s -> m (a, s)) -> StateT s m a
17:24:55 <koz_> jared-w: State is different to ST though.
17:25:00 <koz_> (is it?)
17:25:15 <monochrom> There is no IO transformer. This is an axiom. This is the first cause. There is no "there is no IO transformer because ...".
17:25:38 <koz_> monochrom: OK, then allow me to rephrase my earlier question. Is it an axiom that there is no ST transformer?
17:25:45 <monochrom> Yes.
17:25:53 <koz_> OK, that's what I wanted to know. Thanks!
17:25:58 <koz_> Sorry about my lack of clarity.
17:26:15 <jared-w> np. It's not like anyone clearly writes that out in documentation anywhere... 
17:26:30 <koz_> jared-w: It doesn't excuse me from asking questions badly.
17:27:36 <jared-w> There's a difference between asking a question badly and asking a question from inexperience :) There are very few bad questions but there are many ways to ask a question in a non-precise way (mostly due to inexperience)
17:29:37 <dsal> If I let bind a partially applied function, is the compiler sufficiently smart to avoid repeating the work that's unique for the first half of the input?
17:31:26 <srhb> dsal: You can test this sort of thing by using Debug.Trace which has functions that will (completely unsafely) print something when they are *evaluated*
17:32:14 <dsal> Oh neat. Yeah. It's o(n) to find an offset in the header and then o(n) to apply it.
17:32:59 <dsal> Actually, no, o(1) for the row. Could actually matter
17:38:47 <Welkin> MATRIX!!!!
17:38:53 <Welkin> wtf
17:38:54 <halil> MATRIXX
17:39:03 <Welkin> holy shit
17:39:11 <Welkin> ban matrix already
17:39:49 <geekosaur> the matrix has you
17:40:55 * jared-w is confused
17:41:06 <MarcelineVQ> just filter join/parts with matrix.org, banning a service like that isn't beneficial to the longevity of an irc community
17:44:07 <dsal> trace says this does the O(n) thing a lot
17:44:48 <dsal> This compiler is not sufficiently smart.
17:45:38 <monochrom> I actually saw an instance in which trace was unreliable.
17:46:27 <monochrom> In general, while I usually give trace a shot, for 100% certainty I read the core code.
17:46:32 <pacak> dsal: In general it's not possible to avoid repeating work with partial applications.
17:46:43 <dsal> Yeah, I'm not surprised.
17:46:48 <pacak> > f = (+) 4 in f 10
17:46:51 <lambdabot>  <hint>:1:3: error:
17:46:51 <lambdabot>      parse error on input ‘=’
17:46:51 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:46:55 <pacak> > let f = (+) 4 in f 10
17:46:58 <lambdabot>  14
17:46:59 <pacak> take this as an example.
17:48:11 <dsal> My case is more like    let f = (+) 4 in  map f [1..10000]
17:48:22 <dsal> Except f is O(n)
17:48:43 <dsal> (well, for a different dimension -- n is like, ~34)
17:51:02 <erisco> huh... phantom types seem to be lazy
17:51:41 <dsal> I  just made my function not take the last argument and return a lambda.  Same signature, O(1)
17:52:04 <dsal> Sufficiently Smart Compiler *could* do this.  :)
17:52:18 <dsal> (or trace lies)
17:53:21 <dsal> My code is slightly uglier, but faster in a way I don't care about.  I should not be optimizing.
17:53:35 <jared-w> MarcelineVQ: ahh, gotcha. I have all join and leaves filtered out automatically in my irc client :p
17:54:19 <erisco> yeah I should turn them off too... rarely helps
17:54:44 <erisco> the usually useful one is a leave in the middle of a conversation
17:58:07 <EvanR> dsal: the answer lies in core
18:00:09 <kgadek> hi. anyone uses newest nightly stackage?
18:00:15 <monochrom> The truth lies somewhere. XD
18:00:17 <kgadek> I have some strange issue
18:00:30 <kgadek> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
18:00:32 <dsal> the truth lies
18:00:41 <kgadek> not sure if that's my problem or stack/-age
18:02:35 <kgadek> nvm. stackage problem, nightly-2017-08-12 works but newer are broken
18:04:20 <kgadek> emmm, anyone knows where to submit bugreports for stackage nightly?
18:13:27 <mnoonan_> so I believe that it is true even in constructive logic that ∃X.F(X) is equivalent to ∀T. ((∀X.(F(X) => T)) => T). The forward direction is easy, (just evaluate the polymorphic function at your particular F(X)), but how the heck is the reverse direction supposed to work?
18:23:13 <erisco> I dunno, but isn't it equivalent to  (∀X. F(X) => ⊥) => ⊥  ?
18:29:28 <mnoonan_> erisco: maybe.. can you prove ∀T. (⊥ => T) constructively?
18:29:55 <erisco> why do I have to do that?
18:31:59 <mnoonan_> hm, maybe I’m off track there
18:33:55 <erisco> in predicate logic, ∃x.P(x) ⇔ ¬∀x.¬P(x)
18:34:40 <erisco> constructively, the negation of A is A → ⊥  or  A → Void  i.e. A sent to the empty type
18:35:36 <erisco> whether you can get from one to the other in a constructive logic will depend exactly on the logic being used...
18:35:47 <erisco> one direction may be doable and the other not
18:35:56 <erisco> or neither may be... I don't know
18:36:26 <jmcarthur> Can't you just say T = ∃X.F(X) ?
18:37:34 <mnoonan_> hm, https://en.wikipedia.org/wiki/Intuitionistic_logic suggests only ∃x.P(x) => ¬∀x.¬P(x) in general
18:38:02 <mnoonan_> jmcarthur: I think T has to be a monotype, but I’m not sure
18:38:18 <jmcarthur> "has to be" according to what?
18:39:04 <mnoonan_> first order logic
18:41:02 <erisco> mnoonan_, the problem with your meaning is that if ∃X.F(X) is true then we do not expect ∀X. F(X) ⇒ T to be generally implementable
18:41:39 <jmcarthur> data Packed f = forall x. Packed (f x); let thing (f :: forall t. (forall x. f x -> t) -> t) = f Packed
18:44:01 <f-uckboi> yo
18:44:20 <f-uckboi> anyone here ?
18:44:43 <mnoonan_> jmcarthur: isn’t that just the forward direction?
18:44:54 <erisco> mnoonan_, well I fail to see the problem of that, per se, but that is the idea of the other equivalence
18:45:41 <f-uckboi> hi
18:45:56 <f-uckboi> i need help
18:46:21 <Cale> mnoonan_: False implies everything even in intuitionistic and constructive logics - that's practically a characterisation of what "False" is.
18:46:29 <Welkin> f-uckboi: what a name...
18:46:51 <f-uckboi> thanks brah
18:47:19 <f-uckboi> you too
18:48:45 <Axman6> what do you need help with f-uckboi?
18:49:00 <Welkin> oh lol Axman6 
18:49:03 <Welkin> you are being trolled
18:49:18 <Axman6> probably, but I'm waiting to see how
18:49:26 <mnoonan_> Cale: it makes sense with my classical goggles on, but then.. ⊥ -> A is inhabited for any A? what would a term look like?
18:49:51 <Axman6> there are no good trolls any more :( there used to be great trolls who could keep a conversation going for ages, but they lack patience these days
18:50:04 <f-uckboi> yeah true 
18:50:08 <erisco> :t \case {}
18:50:10 <lambdabot> t1 -> t
18:50:10 <f-uckboi> rip trolls 
18:50:25 <erisco> :t \case {} :: Void -> a
18:50:27 <lambdabot> Void -> a
18:51:15 <Welkin> :t absurd
18:51:17 <lambdabot> Void -> a
18:51:18 <Welkin> :D
18:51:26 <Welkin> has anyone veer used that function?
18:51:37 <f-uckboi> yea me
18:51:38 <Welkin> the only place I have ever seen it was in the halogen purescript library
18:51:45 <mnoonan_> erisco: nice, thanks
18:52:15 <c_wraith> Welkin: it shows up when you have a function with Void in the return type and you need to unify it with another expression.
18:53:19 <f-uckboi> bruh
18:53:33 <c_wraith> Welkin: like, say you had something like forever, except with a slightly different type:  Applicative f => f a -> f Void
18:53:51 <Welkin> :t vacuous
18:53:53 <lambdabot> Functor f => f Void -> f a
18:53:59 <Welkin> hm
18:54:02 <c_wraith> Welkin: and you wanted to use it in one branch of a case, but not the other
18:54:28 <Welkin> I don't get it
18:54:31 <c_wraith> Welkin: So you need something like the above vacuous function to get the types to work.  vacuous = fmap absurd
18:54:36 <Welkin> how would you get an `a` from Void?
18:55:00 <c_wraith> You can't.  The thing is, you can't get a Void, either.
18:55:24 <c_wraith> So it's just as useful to say you have a function of type Void -> a  as it is to say you have a value of type Void
18:55:53 <f-uckboi> puggy was here ?
18:56:55 <u0_a153> yo
18:57:10 <f-uckboi> ay man what up
18:57:12 <erisco> I dunno, I don't know how to derive it but I can't fault the idea of your equivalence mnoonan_
18:57:26 <u0_a153> i need help
18:57:40 <crucify_me> hi quick question. here, we can test for equality between the two type constructors: ThisOne and ThatOne. ie. ThisOne 5 == ThatOne 5 -> False. Does this go to the ignore case to return False ? https://ptpb.pw/IPJG  
18:58:11 <u0_a153> i need help
18:58:33 <mnoonan_> crucify_me: yes
18:59:23 <u0_a153> i need helo
18:59:27 <u0_a153> help
19:00:02 <c_wraith> :t let { forever' :: Applicative f => f a -> f Void ; forever' f = let { x = f *> x} in x } in forever' -- Welkin, you can't have a value of type Void, so the Void in the signature indicates a value that can never be produced.  In this case, that means forever' never returns
19:00:03 <lambdabot> Applicative f => f a -> f Void
19:00:05 <u0_a153> ill pay
19:00:05 <peglong> !help
19:00:18 <crucify_me> mnoonan_, thanks, where in the code do we get behavior that allows us to test ThisOne and ThatOne for equality? is it in the first line?
19:00:44 <crucify_me> I would have thought they were separate
19:00:57 <mnoonan_> crucify_me: no, the first like is when both sides are ThisOnes, the second is when both are ThatOnes, and the last catches the rest of the cases
19:01:15 <mnoonan_> *line
19:02:01 <f-uckboi> im back
19:02:01 <crucify_me> so really, they are not "allowed" to be tested, that statement gets passed to the last case. mnoonan_ 
19:02:23 <mnoonan_> crucify_me: right, (==) on the inner a/b will never get called in that case
19:02:34 <crucify_me> technically, it doesn't even test them for equality
19:02:48 <crucify_me> the inner a/b ?
19:03:35 <crucify_me> I thought my moniker was out there...
19:03:54 <crucify_me> oh boi
19:04:00 <mnoonan_> you can write “ThisOne (error “Barf”) == ThatOne (error “argh”)” and your program won’t throw an error, because the stuff inside the ThisOne and ThatOne don’t need to be inspected
19:04:54 <nshepperd> getting an 'a' for Void is easy. let's enumerate the cases:
19:05:05 <nshepperd> *from Void
19:05:27 <mnoonan_> nshepperd: :)
19:05:44 <Welkin> nshepperd: how come you always remind me of mass effect?
19:06:09 <nshepperd> because i'm jane shepard, saviour of the galaxy
19:07:18 <crucify_me> right, its not inspected at all . thanks mnoonan_ .. but the "or" operator here '|' is not what prohibits the prog. from inspecting one against the other
19:07:35 <nshepperd> a slightly more advanced way of enumerating the cases would be: ⊥ -> ⊥
19:08:09 <erisco> you only get to do that if you're the semantics
19:08:17 <crucify_me> nshepperd, bottoms ? not there yet, you referring to my inquiries?
19:08:56 <nshepperd> crucify_me: no, i'm talking about the meaning of the 'vacuous' and 'absurd' functions
19:09:18 <crucify_me> I know a vacuous girl
19:10:44 <nshepperd> erisco: i can map bottoms to things if I want! you can't tell me what to do!
19:10:55 <pacak> :t absurd
19:10:57 <lambdabot> Void -> a
19:11:24 <pacak> -- give me nothing and I'll return anything
19:11:28 <pacak> :t vacuous
19:11:30 <lambdabot> Functor f => f Void -> f a
19:11:45 <pacak> -- give me object containing nothing - I'll fill it with anything
19:12:19 <dsal> Hmm...  I've got two of these things:  t :: Monad f => f LocalTime    -- how do I subtract them?  :(
19:12:28 <erisco> > vacuous myWallet
19:12:31 <lambdabot>  error: Variable not in scope: myWallet :: f Void
19:12:45 <erisco> hang on while I mail it...
19:12:58 <nshepperd> 'give me an object containing the impossible' would maybe be more to my taste
19:13:26 <pacak> nshepperd: Or that.
19:13:40 <pacak> Words are hard.
19:14:22 <pacak> Ex falso quodlibet .
19:15:05 <pacak> For me is something ghc tells when it can figure out my code.
19:15:15 <pacak> impossible is
19:15:59 <nshepperd> or perhaps what you are doing is replacing nothing with the absence of something specific :)
19:16:17 <nshepperd> absurd :: Void -> Int -- if you don't have anything, you don't have an Int
19:17:12 <pacak> Prove me wrong. It will give you int if you pass it Void. You just can't pass it Void since it's not a thing. Assuming bottom-less category.
19:17:37 <crucify_me> may I ask again to be certain: the "|" symbol .. call it "OR" in this use? .. disallow the ThisOne and ThatOne. nip it in the bud so to speak..by passing ThisOne 5 == ThatOne 5 , directly to the ignore case, or does it happen elsewhere? do you see my point? https://ptpb.pw/IPJG
19:18:49 <crucify_me> disallow .... *from being compared*
19:18:59 * pacak fails to parse the question
19:19:08 <crucify_me> sorry. pacak
19:19:16 <crucify_me> I wish I could phrase it better
19:19:20 <jared-w> crucify_me: you wrote that instance correctly
19:19:32 <pacak> You create a datatype that contains something of type a
19:19:33 <nshepperd> crucify_me: the meaning of | in a data declaration is simply to enumerate the possible cases
19:19:39 <pacak> container can be either of those two things.
19:20:00 <pacak> Code and instance seems correct.
19:20:08 <pacak> ghc can derive the same instance though.
19:20:14 <jared-w> crucify_me: also, the pattern matching of the function is what brings it to the ignore case
19:20:22 <crucify_me> but those are two separate cases, yet ThisOne and ThatOne are "allowed" to be compared, because there is no error
19:21:00 <nshepperd> crucify_me: a value of type 'Which a' is either ThisOne x for some x :: a OR ThatOne y for some y :: a
19:21:26 <jared-w> If the eq instance is "passed"   ThisOne 5 == ThatOne 5, what will happen is that first: You have the line (==) (ThisOne a) (ThisOne b); you have a ThatOne in the second parameter so it doesn't match and it tries the second line
19:22:19 <jared-w> The second line has a ThatOne as the first parameter and so it doesn't match the comparison you "passed in", so it goes to the third line. The third line says "return False for anything you give me" so it returns false
19:22:38 <crucify_me> jared-w, excellent got it. thanks ALL !
19:23:28 <dsal> I don't understand this thing I'm getting for time.   t :: Monad f => f LocalTime
19:23:37 <dsal> repl prints it, but "show t" blows up
19:24:44 <pacak> dsal: repl is more magical.
19:25:26 <jared-w> repl is very magic
19:26:05 <pacak> dsal: blows up in what way?
19:26:09 <dsal> I guess I don't understand why it returns a function.
19:26:37 <dsal> I kind of understand it now.   show doesn't know how to deal with the function thing.
19:26:54 <pacak> f LocalTime looks like a value in a monad to me.
19:27:26 <pacak> You can't get current LocalTime from a pure function.
19:27:43 <pacak> At least not unless you pass it in.
19:27:45 <dsal> It's not current time.
19:28:13 <dsal> parseTime is deprecated and suggests calling parseTimeM True
19:28:19 <dsal> Which returns a monad instead of Maybe
19:29:34 <mnoonan_> dsal: ghci is specializing “f” to “IO”, and it knows how to show anything of type “IO t”, as long as it also knows how to show “t” 
19:30:10 <mnoonan_> it’s kind of cheating, because it knows how to show “IO t” only by running the action, and then showing the result
19:30:11 <pacak> dsal: Maybe is Monad.
19:30:29 <pacak> :t parseTimeM
19:30:31 <lambdabot> error: Variable not in scope: parseTimeM
19:30:34 <pacak> Meh.
19:30:45 <mnoonan_> (I think)
19:30:47 <dsal> It's just weird to me that parsing returns a function I need to call.
19:31:15 <pacak> it returns a wrapped value
19:31:53 <dsal> But why is it wrapped?
19:32:11 <dsal> It's also slightly confusing to me how to call a nullary function vs. accidentally passing its value.
19:32:16 <dsal> (er, it *as* a value)
19:33:12 <pacak> Result might not be there for example.
19:33:18 <mnoonan_> dsal: for warty reasons, the Monad interface includes the ability to fail
19:33:34 <koz_> mnoonan_: Did they not break it out into MonadFail yet?
19:33:37 <geekosaur> for most functions there is no difference. if it's a monad, you use >>= (or <- in do)
19:33:37 <geekosaur> *a monadic value
19:33:55 <mnoonan_> dsal:  parseTimeM can fail, but since they leave the Monad instance polymorphic, the *caller* gets to pick what failing should mean
19:34:05 <geekosaur> I think people have snarked about parseTimeM before... it's a bit of a throwback
19:34:54 <mnoonan_> so if you use parseTimeM in a way where it results in a “Maybe time”, you’ll get Nothing in the failure case, or Just theTime in the successful case
19:35:14 <pacak> :t fail
19:35:16 <lambdabot> Monad m => String -> m a
19:35:19 <pacak> fail is bad.
19:35:29 <geekosaur> back in the day. Data.Map.lookup used the same trick. (think it changed in 6.6)
19:35:32 <dsal> fail fores the monad?
19:35:38 <dsal> er, forces
19:35:51 <geekosaur> using fail requires a Monad context, yes
19:36:13 <geekosaur> note that Maybe is a Monad, so supplies the correct context already
19:36:41 <geekosaur> and you get back Nothing on error or Just theParseResult
19:37:11 <geekosaur> but you could force a monad that lets it tell you *what* failed
19:37:13 <pacak>  fail defaults to this
19:37:21 <pacak> fail        :: String -> m a     
19:37:21 <pacak> fail s      = errorWithoutStackTrace s
19:38:55 <dsal> Just sticking at () after parseTimeM result gets me a value.
19:39:37 <mnoonan_> dsal: you’re picking the “(() ->)” monad :)  
19:39:51 <dsal> heh
19:39:55 <mnoonan_> I don’t know how that fails, runtime exception probably
19:40:20 <mnoonan_> @let parseBit c = case c of { '0' -> return False; '1' -> return True; _ -> fail "bad parse" }
19:40:23 <lambdabot>  Defined.
19:40:32 <mnoonan_> >parseBit ‘1’ :: Maybe Bool
19:40:54 <dsal> Well, I can get to LocalTime, but I can't figure out how to convert to something I can subtract.
19:41:21 <mnoonan_> > parseBit ‘1’ :: Maybe Bool
19:41:21 <dsal> mnoonan_: That's a Maybe, though.  I get that.  The older interface returned Maybe
19:41:24 <lambdabot>  <hint>:1:10: error: lexical error at character '\8216'
19:41:54 <mnoonan_> > parseBit ‘1' :: Maybe Bool 
19:41:57 <lambdabot>  <hint>:1:10: error: lexical error at character '\8216'
19:42:08 <mnoonan_> argh, stupid smart irc client
19:42:12 <geekosaur> heh
19:42:21 <geekosaur> thught I recognized that char
19:42:34 <geekosaur> > text "\8216"
19:42:36 <lambdabot>  ‘
19:42:57 <koz_> > parseBit '1' :: Maybe Bool
19:43:00 <lambdabot>  Just True
19:43:08 <koz_> > parseBit '1' :: Either String Bool
19:43:09 <erisco> editors that replace my characters rot in the recycle bin
19:43:11 <lambdabot>  Right True
19:43:24 <mnoonan_> now do parseBit ‘2’ :)
19:43:40 <koz_> > parseBit '2' :: Either String Bool
19:43:43 <lambdabot>  *Exception: bad parse
19:43:48 <pacak> > parseBit '☭´ :: Either String Bool
19:43:51 <lambdabot>  <hint>:1:11: error: parse error on input ‘☭´’
19:43:58 <pacak> > parseBit '☭' :: Either String Bool
19:44:00 <lambdabot>  *Exception: bad parse
19:44:05 <pacak> O_o
19:44:08 <koz_> pacak: In Soviet Russia, bit parses you?
19:44:16 <mnoonan_> yeah, interesting fail instance! what is going on there?
19:44:27 <pacak> > parseBit '☭' :: Maybe Bool
19:44:29 <lambdabot>  Nothing
19:44:30 <pacak> > parseBit '☭' :: [Bool]
19:44:32 <lambdabot>  []
19:44:35 <pacak> fail is bad.
19:44:38 <koz_> Yeah, shouldn't it be Left "" or something?
19:44:39 <pacak> fails is very bad.
19:44:51 <pacak> It defaults to exception throwing.
19:45:02 <geekosaur> I think you need to use Except these days?
19:46:01 <pacak> geekosaur: Either supposed to be a value or an error message. Is the most logical choice, but it's fail is broken.
19:46:31 <mnoonan_> > parseBit (head “1”) ()
19:46:32 <geekosaur> there was a decision made that Either should not treat Left as special
19:46:34 <lambdabot>  <hint>:1:16: error: lexical error at character '\8220'
19:46:40 <mnoonan_> oh my god
19:46:41 <geekosaur> which is why we went through Either -> Error -> Except
19:47:07 <mnoonan_> > parseBit (head (show 1)) ()
19:47:09 <lambdabot>  True
19:47:14 <mnoonan_> this is what I’m reduced to
19:47:22 <mnoonan_> :t parseBit (head (show 1)) ()
19:47:25 <lambdabot> Bool
19:47:53 <koz_> geekosaur: Where does Except live?
19:47:54 <mnoonan_> :t \() -> parseBit (head (show 1)) ()
19:47:57 <lambdabot> () -> Bool
19:48:05 <mnoonan_> > parseBit (head (show 2)) ()
19:48:09 <lambdabot>  *Exception: bad parse
19:48:46 <koz_> @src Except
19:48:46 <lambdabot> Source not found. :(
19:49:50 <geekosaur> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
19:49:50 <geekosaur> and it looks like this just overrides fail, or something
19:49:51 <dsal> OMG.  I subtracted time.  heh
19:50:47 <dsal> Can't call variable Δ.  I guess that makes sense.
19:51:06 <geekosaur> it's an uppercase...
19:51:41 <dsal> Yeah.
19:59:33 <Welkin> > let δ = 2 in δ
19:59:36 <lambdabot>  2
19:59:38 <Welkin> :D
19:59:48 <Welkin> > let Δ = 3 in Δ
19:59:51 <lambdabot>  error: Not in scope: data constructor ‘Δ’
19:59:54 <Welkin> lol
20:02:40 <pacak> > let ᐃ = 4 in let (☭) = (+) in ᐃ ☭ ᐃ
20:02:43 <lambdabot>  8
20:02:47 <pacak> Challenge accepted.
20:04:43 <mnoonan_> data Δ ᐃ = ᐃ Δ
20:04:53 <mnoonan_> — no wait!
20:05:16 <dsal> Well, I can't figure out how to use this NominalDiffTime.  It's incompatible with everything.
20:05:49 <Welkin> the time libraries are weird
20:06:07 <Welkin> NominalDiffTime is a difference
20:06:27 <Welkin> what do you want to do with it?
20:06:27 <dsal> Yeah, but I can't use it with anything.
20:06:43 <dsal> I've got two log records that have positions and timestamps.  I want to know what the speed was between them.
20:07:10 <mnoonan_> dsal: diffUTCTime?
20:07:17 <Welkin> you can do lots with it
20:07:46 <Welkin> http://hackage.haskell.org/package/time-1.8.0.3/docs/Data-Time-Clock.html#t:NominalDiffTime
20:07:51 <dsal> Yeah, that gives me t Δ :: NominalDiffTime
20:07:54 <Welkin> it has tons of instances
20:08:08 <Welkin> you can show it, do arithmetic with it
20:08:10 <Welkin> whatever
20:08:52 <mnoonan_> it isn’t clear how to scale it, which I guess is what you want to do next
20:09:01 <Welkin> scale it?
20:09:06 <Welkin> it has a Num instance
20:09:14 <Welkin> which means you can treat it like any other number
20:09:25 <mnoonan_> er, divide by it. he wants to do (some position calculation) / time delta
20:09:46 <Welkin> convert it into a float/double
20:09:46 <dsal> I can't use it with the Numeric.Units stuff that this geodetics library uses.
20:09:52 <dsal> How do I convert it?
20:09:53 <Welkin> it has a fractional instance too
20:10:05 <Welkin> :t round
20:10:07 <Welkin> er
20:10:07 <lambdabot> (Integral b, RealFrac a) => a -> b
20:10:53 <Welkin> I always forget the functions
20:11:09 <dsal> round gives me 0
20:11:40 <Welkin> either way, you can use (/)
20:12:12 <Welkin> > (0.3 :: Time.Clock.NominalDiffTime) / 3.0
20:12:14 <lambdabot>  error:
20:12:14 <lambdabot>      Not in scope:
20:12:14 <lambdabot>        type constructor or class ‘Time.Clock.NominalDiffTime’
20:12:27 <Welkin> > (0.3 :: Data.Time.Clock.NominalDiffTime) / 3.0
20:12:31 <lambdabot>  error:
20:12:31 <lambdabot>      Not in scope:
20:12:31 <lambdabot>        type constructor or class ‘Data.Time.Clock.NominalDiffTime’
20:13:05 <pacak> @hackage thyme
20:13:05 <lambdabot> http://hackage.haskell.org/package/thyme
20:13:21 <Welkin> > Data.Time.Clock.nominalDay / 3.0
20:13:23 <pacak> A slightly less derpy replacement for time. Also faster.
20:13:24 <lambdabot>  error:
20:13:24 <lambdabot>      Not in scope: ‘Data.Time.Clock.nominalDay’
20:13:24 <lambdabot>      No module named ‘Data.Time.Clock’ is imported.
20:13:30 <Welkin> lol damn it
20:13:49 <pacak> Internally most of the things are number of microseconds since some point so enum instance is your friend.
20:17:23 <dsal> Hmm...  * gives me errors.
20:18:11 <dsal> I'd like to have this as a floating point number of seconds.  Or perhaps something Numeric.Units is happy with so I could just divide.
20:31:25 <dsal> Yeah, I can't figure out anything useful I can do with this value.
20:31:44 <dsal> Heh.  I can't even add it to itself.
20:32:45 <pacak> Prelude Data.Time.Clock> realToFrac nominalDay  :: Double
20:32:46 <pacak> 86400.0
20:33:31 <pacak> dsal: ^
20:33:57 <dsal> Hey.  That did something.
20:34:09 <dsal> How do I get good at knowing things without bothering people?
20:34:37 <pacak> dsal: Look at provided instances
20:34:40 <mnoonan_> hoogle helps a lot (but was admittedly not great for this one because of all the number-like typeclasses)
20:34:47 <dsal> What is "instance" btw?
20:35:00 <pacak> so....
20:35:06 <pacak> > 1 :: Int
20:35:08 <lambdabot>  1
20:35:35 <pacak> There's not much you can do with it if you don't use any instances
20:35:46 <pacak> We know that Int have Show instance so we can
20:35:51 <pacak> > show (1 :: Int)
20:35:53 <lambdabot>  "1"
20:35:54 <pacak> :t show
20:35:56 <lambdabot> Show a => a -> String
20:36:02 <geekosaur> oh dear, yes, if you're not familiar with typeclasses then all of this will be fairly opaque
20:36:06 <dsal> realToFrac doesn't show up there...  I'm super ignorant.  :)
20:36:06 <geekosaur> :t 1
20:36:08 <lambdabot> Num t => t
20:36:14 <pacak> There's Num instance
20:36:24 <pacak> > negate (1 :: Int)
20:36:26 <pacak> and so on.
20:36:27 <lambdabot>  -1
20:36:32 <geekosaur> :t realToFrac
20:36:34 <lambdabot> (Fractional b, Real a) => a -> b
20:37:05 <pacak> It says it can convert any Real to any Fractional.
20:37:15 <pacak> Look at those typeclasses and their instances.
20:37:26 <pacak> NominalDiffTime is Fractional, Double is Real\
20:38:04 <suzu_> is the haskell book final yet
20:38:05 <pacak> dsal: Read on typeclasses.
20:38:16 <dsal> Yeah, I've got reading to do.  Thanks.
20:38:29 <dsal> Unfortunately, even after converting this to the Numeric.Units type, I still can't divide them.
20:38:32 <suzu_> read the haskell book
20:38:35 <suzu_> and the haskell wikibook
20:38:57 <pacak> Convert to Double.
20:39:25 <dsal> Oh, I have to do this:  d Numeric.Units.Dimensional./ us
20:40:14 <dsal> heh,   65.0 m s^-1
20:40:19 <dsal> I guess you can write it that way.
20:41:37 <dsal> (d Numeric.Units.Dimensional./ us) /~ (kilo meter Numeric.Units.Dimensional./ hour)
20:41:40 <dsal> Gross/yeah
20:52:37 <dsal> How do I get the current timezone?  getCurrentTimeZone is   IO TimeZone  -- I assume I can grab that from within my main's do and then use it in functions that don't have side effects.
20:52:57 <pacak> dsal: Yes.
20:53:07 <dsal> How does that work?  I can't seem to make anything sensible happen.
20:53:36 <dsal> oooh, it only works *in* the do
20:53:37 <dsal> that makes sense
20:53:42 <pacak> main = do
20:53:42 <pacak> zone <- getCurrentTimeZone
20:53:42 <pacak> mydata <- getmydata
20:53:42 <pacak> print $ doStuff zone mydata
20:54:19 <pacak> It only works in a monad. Do is just a syntactic sugar
20:54:23 <dsal> I have     parseTS :: String -> String -> TimeZone -> UTCTime
20:54:41 <dsal> do { tz <- getCurrentTimeZone ; parseTS "2017-08-14" "20:48:39.245" tz }    fails me   is that incorrect?
20:55:24 <dsal> oh  *sigh*
20:55:30 <dsal> It's the repl that's erroring.  The code's fine
20:55:32 <pacak> sure it will
20:55:35 <pacak> fail
20:55:48 <dsal> this works:  do { tz <- getCurrentTimeZone ; putStr $ show $ parseTS "2017-08-14" "20:48:39.245" tz }
20:55:59 <pacak> parseTS returns UTCTime, do expects monadic action.
20:56:01 <dsal> The magic is a little confusing to me.
20:56:01 <pacak> Yes, this works.
20:56:11 <pacak> putStr (show foo) is the same as print foo
20:56:21 <dsal> Oh, thanks
20:56:21 <pacak> @src print
20:56:21 <lambdabot> print x = putStrLn (show x)
20:56:29 <pacak> Hmm... Close anyway.
20:56:49 <dsal> yeah, even better
20:57:12 <dsal> OK.  If I ever internalize "expects monadic action" I'll stop making similar mistakes.  :)
20:58:57 <pacak> Monads are kind of burritos....
20:59:04 <pacak> Hmmm....
20:59:16 <pacak> It's a way of composing computations.
20:59:29 <pacak> There's a ton of different computations so there's a bunch of different  monads.
20:59:36 <pacak> Maybe, [], Either a, etc.
20:59:39 <pacak> IO is a monad.
20:59:50 <pacak> Common part - you can compose then using bind
20:59:53 <pacak> :t (>>=)
20:59:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:00:02 <pacak> you can put a pure value in a monad
21:00:03 <pacak> :t return
21:00:05 <lambdabot> Monad m => a -> m a
21:00:12 <pacak> and squash monadic layers
21:00:14 <pacak> :t join
21:00:15 <lambdabot> Monad m => m (m a) -> m a
21:00:46 <pacak> In that do you need something that looks like m a
21:00:57 <pacak> in this case you are in IO monad
21:01:02 <pacak> :t print
21:01:04 <lambdabot> Show a => a -> IO ()
21:01:16 <pacak> print takes showable thing and puts it in IO monad
21:10:43 <ab9rf> of course, print = putStrLn . show
21:11:10 <ab9rf> (well, not exactly, because of DMR)
21:12:49 <suzu_> dmr?
21:13:07 <ab9rf> monomorphism restriction
21:13:12 <Cale> The dreaded monomorphism restriction :)
21:13:28 <ab9rf> "dreaded" is the polite word used for the D :)
21:13:42 <suzu> oh thats what the d is
21:13:45 <suzu> hehe
21:13:50 <ab9rf> it's actually defined as "print x = putStrLn (show x)"
21:14:16 <Cale> It's okay to say that print = putStrLn . show as an equation, but if you try to write that without giving an explicit type signature, you'll find that it gets specialised to whatever type you first use it at (if the MR is on)
21:14:36 <Cale> Presumably the actual definition has an explicit type signature so it doesn't matter.
21:15:01 <ab9rf> it does: print           :: Show a => a -> IO ()
21:15:31 <pacak> DMR was designed to make things less confusing for novices...
21:16:40 <Cale> Well, not exactly... it's designed to make performance more obvious when stuff looks like constants but is type class polymorphic
21:17:24 <ab9rf> DMR is the subject of endless heated debates, like every other design decision in haskell :)
21:17:33 <koz_> DMR?
21:17:36 <Cale> If you casually write n = <some expensive calculation> then regardless of whether n's type is polymorphic, you probably expected to be defining a constant
21:18:11 <Cale> and in many cases you might expect that n would be computed once and then its result shared between occurrences, because that's how lazy evaluation normally is
21:18:34 <Cale> But if n is type class polymorphic, it gets compiled to a function of the type class dictionary, and the result is *not* shared
21:18:43 <Cale> So it will be recomputed everywhere that it's used
21:18:56 <Cale> So the MR tries to prevent you from accidentally doing that
21:19:27 <Cale> I think making it an outright error rather than a warning is a bit heavy handed.
21:19:48 <ab9rf> Cale: i know you can turn it off but i take it there's no option for making it a warning
21:19:52 <Cale> But sometimes it interacts with defaulting to mean that stuff will just get specialised to Integer
21:20:09 <Cale> (or whatever)
21:20:40 <Cale> and in those cases, it can actually also provide a little bit of convenience -- maybe
21:21:02 <Cale> But overall, I think it probably wasn't the best idea.
21:25:14 <pacak> That's why -Wall to develop and -Werror to compile for prod.
21:26:52 <Cale> We do that and I'm sort of getting used to it, but one thing that I still find really ugly is that it forces you to write stuff like _ <- foo
21:32:57 <monochrom> Except http://lpaste.net/142600
21:34:41 <Cale> I find it ugly all the time, not just when it forces you to explicitly discard a result from a trivial type. But at least in other cases it sort of makes sense as a warning.
21:35:11 <pacak> :t void
21:35:11 <lambdabot> Functor f => f a -> f ()
21:36:18 <greywolf_> hey there haskell channel :)
21:36:34 <pacak> monochrom: Yea, could be a bit less derpy.
21:37:30 <MarcelineVQ> Cale: if you feel forced is there a reason not to write  -Wall -fno-warn-unused-do-bind
21:43:48 <jared-w> monochrom: I fail to see why the warning is politically-correctly thought out :p
21:45:59 <jared-w> Also, the warning doesn't warn on ()? What does that mean? It doesn't warn on an implicit return?
21:46:20 <monochrom> That's right, what does it mean?
21:46:29 <monochrom> But no warning if the type is ().
21:47:26 <monochrom> For example it doesn't warn on putStrLn"xxx"
21:48:11 <piyush-kurur>  here is a question regarding Storables and Generalised new type deriving
21:48:23 <mud> monochrom: I wonder if it warns if you discard a Void
21:48:38 <piyush-kurur> Suppose I have a phantom type like newtype Phantom a = Phantom Int deriving Storable
21:48:49 <monochrom> I bet it does.
21:49:26 <piyush-kurur> Is it true that Phantom Int is storable or Phantom Foo is storable
21:49:49 <piyush-kurur> I am having trouble when I try to pass this to a FFI function when I hide the constructor
21:49:52 <remexre> Is there a way to get a variable set at compile-time as a string?
21:50:27 <piyush-kurur> The compiler seems to be saying that it needs the constructor to make the type an instance of Storable
21:50:32 <pacak> remexre: CPP? O_o
21:50:59 <pacak> remexre: or TH
21:51:02 <remexre> pacak: Oh, ew. Can I get stack to pass the -D?
21:51:16 <pacak> stack? No ideas.
21:51:28 <remexre> Hm, I'll go with TH then
21:51:30 <remexre> thanks
22:03:34 <mnoonan_> piyush-kurur: I had a similar issue recently.. I ended up making a typeclass like this: http://lpaste.net/357707
22:05:14 <piyush-kurur> mnoonan thanks but why does this not work with a ffi call.
22:05:32 <piyush-kurur> If I define a Haskell function with say peek it is all fine
22:07:14 <piyush-kurur> this is a bit irritating because I want the phantom type to guard against unwanted conversion (so hide constructor) but I want to directly supply to FFI function as no amount of Phantoms  can prevent one from being safe with C ;-)
22:09:14 <piyush-kurur> s/safe/unsafe/
22:09:18 <HallaSurvivor> Is there a better way to solve minimization problems than the list monad?
22:09:53 <HallaSurvivor> I currently have a bunch of functions, and I want to know what composition of up to 10 functions minimizes the output under some metric
22:10:31 <HallaSurvivor> I'm currently just doing do {f1 <- funs, f2 <- funs, ... f10 <- funs; return f1 >=> ... >=> f10}
22:10:42 <HallaSurvivor> and trying all of them
22:10:48 <HallaSurvivor> but I feel like there's a more efficient way
22:10:55 <mnoonan_> piyush-kurur: I ended up having some internal modules and types that interfaced with the C code via the FFI/Marshallable typeclass (e.g. a InternalPoint type that wrapped a CInt), then a user-facing layer that used phantom types (e.g. newtype Point t = InternalPoint) 
22:11:47 <mnoonan_> that way, I could make the phantom type parameter encode other invariants about the C interface, like “this input has to be a point with property X” or whatever
22:17:38 <jared-w> monochrom: sorry, I tabbed out for a moment and forgot. Yeah that seems like a particularly ugly special case because of how common it is to have a very simple main function that just does a few things and prints some stuff (for beginners or simple programs, at least)
22:23:11 <halogenandtoast> So I want to do something like: [1,2,3,4] ^? element 2, but instead of 2 I have (Just 2), is the best way to handle this: join $ ([1,2,3,4] ^?) . element <$> Just 2
22:23:18 <halogenandtoast> Or is there a better way of handling this?
22:23:49 <halogenandtoast> Basically my negative feeling is coming from having to use `join`
22:24:37 <pacak> :t (^?)
22:24:39 <lambdabot> s -> Getting (First a) s a -> Maybe a
22:24:43 <pacak> Ugh
22:25:11 <jared-w> is ^? a lens?
22:25:17 <halogenandtoast> Is that a typical response to lenses?
22:25:17 <glguy> no
22:25:18 <halogenandtoast> Yes
22:25:23 <halogenandtoast> Well it applies a lens
22:25:32 <jared-w> ah, gotcha
22:25:52 <dibblego> nah, it implies a (Getting (First a)) as an argument
22:25:54 <pacak> I don't mind lens, I don't like this perl-style encryption.
22:25:55 <jared-w> halogenandtoast: can you not just lift out the 2?
22:26:21 <jared-w> pacak: it's apparently surprisingly mnemonic once you get the hang of it, I've heard :p
22:26:33 <dibblego> a lens satisfies this, among many things (including those which are not lenses)
22:26:57 <halogenandtoast> pacak, jared-w I think one big argument for the "encryption" is that if everyone can agree on the meaning you have something quite powerful (kind of like Kanji)
22:27:33 <jared-w> halogenandtoast: I'm personally just fine with 'encryption'; I just haven't gotten around to learning lenses yet
22:27:45 <lordcirth_> More like compression than encryption, then
22:28:08 <dibblego> TIL (^?) is encrypted
22:28:18 <halogenandtoast> jared-w: I can't see how to lift the 2
22:28:20 <jared-w> I'd even say it's not so much compression as it is a symbolic notation :p
22:28:26 <halogenandtoast> dibblego: no encrypted, "encrypted"
22:28:32 <halogenandtoast> the quoting was deliberate on my part.
22:28:57 <dibblego> who are you quoting?
22:29:17 <remexre> Does this look reasonable/make sense? The docs warn the qRunIO is "dangerous"... https://github.com/oftlisp/oftb/blob/rewrite-haskell/src/Language/OftLisp/Modules/Templates.hs#L15
22:29:18 <halogenandtoast> The quotes are "encrypted" air quotes.
22:29:28 <MarcelineVQ> ~encrypted~
22:29:41 <jared-w> halogenandtoast: well if you /know/ you have a Just you can use fromJust. You can also pattern match on the maybe. Perhaps the Applicative instance of maybe might also be useful?
22:30:09 <halogenandtoast> jared-w: Ah yeah I don't have known Just, I just have a Maybe Int (coming from readMaybe)
22:31:16 <halogenandtoast> I'll try to think about the applicative instance, I couldn't see how it would work
22:31:32 <halogenandtoast> Maybe (a -> b) -> Maybe a -> Maybe b
22:31:50 <pacak> remexre: Hmm... Why not [| var |] on line 18?
22:32:05 <remexre> pacak: what would that change?
22:32:15 <pacak> readability.
22:32:25 <pacak> And it won't break when TH changes.
22:32:52 <remexre> pacak: What does that notation mean, rather?
22:33:09 <remexre> wait, or would that replace the whole line, or just the "var" part?
22:33:41 <pacak> Whole line assuming var is String
22:34:38 <remexre> Okay, thanks!
22:34:45 <remexre> Looks good other than that, though?
22:34:51 <jared-w> halogenandtoast: the easiest thing I can think of is that if you're using readMaybe to get the Int, you wouldn't even want to do anything if you had a Nothing value, so why not pattern match on the Maybe and do Nothing in the case of Nothing?
22:35:09 <pacak> var <- fromMaybe def <$> lookupEnv s
22:35:09 <pacak> [| var |]
22:35:12 <pacak> something like this
22:35:17 <pacak> with runIO
22:35:39 <remexre> var <- qRunIO (fromMaybe def <$> lookupEnv s) then?
22:36:27 <pacak> yea
22:37:24 <remexre> Okay, so all the rest looks "idiomatic"?
22:38:18 <pacak> You might need to add some pragmas
22:38:23 <pacak> but looks sane otherwise.
22:38:42 <halogenandtoast> jared-w: Yeah, I just start to dislike nested cases
22:39:00 <remexre> Yeah, looks like just TemplateHaskell
22:39:01 <remexre> thanks!
22:39:17 <halogenandtoast> I feel like it should be a "smell" but perhaps I don't know the practices to eliminate it.
22:42:06 <jared-w> halogenandtoast: the practices to eliminate nested cases are generally implicit "combining" using things that act "intelligently". A trivial example is combining a bunch of functions that return maybe inside do notation. So mkPerson (name) (age) (weight) would have do  {n <- validateName; a <- validateAge; w <- validateWeight; return mkValidPerson n a w }
22:43:00 <halogenandtoast> jared-w: https://gist.github.com/halogenandtoast/0b4383fa48156dc66028474b9e956a25
22:43:06 <halogenandtoast> that was the extent of my vision
22:56:08 <cocreature> halogenandtoast: using the fact that Maybe is an instance of Monad, you can slightly simply the nested cases in chooseFromArray
22:56:42 <cocreature> oh you already did that in the upper solution, nvm
22:56:46 <cocreature> I should read the backlog
22:57:54 <halogenandtoast> cocreature: I don't think my upper solution utilized the monad aspects of Maybe
22:58:03 <halogenandtoast> I use fmap, that's about it.
22:58:13 <cocreature> "join" looks very monady :)
22:58:15 <halogenandtoast> the bind is the Monad instance of IO, not Maybe
22:58:19 <halogenandtoast> oh yeah
22:58:46 <cocreature> "(choices ^?) . element =<< mchoice" would be a more natural way to write this
22:59:44 <halogenandtoast> huh
22:59:51 <halogenandtoast> :t (=<<)
22:59:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:00:00 <cocreature> it’s just flip >>=
23:00:03 <halogenandtoast> yeah
23:00:11 <halogenandtoast> just wanted to see it and think about how it works here.
23:00:20 <halogenandtoast> but yeah makes sense.
23:00:49 <cocreature> :t \f x -> join (f <$> x)
23:00:51 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
23:01:20 <halogenandtoast> looks familiar
23:01:31 <cocreature> yep, that’s =<< expressed in terms of join and fmap
23:01:43 <cocreature> which is what you used
23:01:58 <halogenandtoast> Thanks, my toolbox is now slightly bigger
23:02:24 <halogenandtoast> I prefer the =<< over the join fmap
23:09:50 * hackagebot DeepDarkFantasy 0.2017.8.15 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
23:10:43 <halogenandtoast> Thanks cocreature and jared-w for the information.
23:15:39 <cocreature> that DeepDarkFantasy lib is seeing a lot of updates, maybe I should check it out at some point :)
23:19:43 <jared-w> Every time I see it I want to fork it and make a DSL for writing convolutional neural networks and call it "BeautifulDarkTwistedFantasy"
23:25:37 <bvad> cocreature: I was just thinking the same. It's written by a first year student.. Makes me feel very insufficient :o
23:29:11 <jared-w> bvad: hah, don't feel bad about that. There was a 15(ish) year old who's one of the higher ranked experts on one of those competition AI websites. That about wrecked me when I found out so I try not to think about that too much :p
23:29:50 <bvad> jared-w: You made me feel worse :(
23:30:01 <jared-w> Just remember the eternal truth of the internet: There's always someone way better than you ;)
23:30:05 <bvad> Or maybe you motivated me, who knows..
23:30:35 <jared-w> He got there in like 3 years! You can do it; I believe in you
23:30:54 <bvad> awww thank you :)
23:31:44 <erisco> we've several billion years on now... no race ;)
23:35:05 <jared-w> https://www.reddit.com/r/MachineLearning/comments/5z8110/d_a_super_harsh_guide_to_machine_learning/
23:37:00 <bvad> "If you have life questions, I have no idea."
23:38:12 <pacak> If you want to make progress - it helps to read and do stuff right outside of your comfort zone. You need to both read and do.
23:38:14 <cocreature> just write an AI that answers life questions
23:38:34 <pacak> 42
23:38:49 <cocreature> pacak: now you’re an AI researcher
23:43:37 <erisco> though there is enough to read to never do and enough to do to never read
23:44:49 <bvad> erisco: and that's why I never do anything
23:44:52 <jared-w> Ain't that the truth
23:47:46 <EvanR> never say never
23:48:21 <EvanR> twice in the same sentence
23:49:33 <u0_a107> hi
23:49:49 <pussyslayer> yo
23:59:47 <pussyslayer> hi
