00:41:48 <KeyJoo> Salute! Whet is a problem on: http://projects.haskell.org/gtk2hs/ ? - Error establishing a database connection
00:42:16 <cocreature> KeyJoo: projects.haskell.org doesn’t exist anymore
00:42:36 <cocreature> hm maybe it does and I’m confusing things
00:42:41 <KeyJoo> Is it replaced?
00:43:06 <cocreature> KeyJoo: gtk2hs is on github https://github.com/gtk2hs/gtk2hs
00:43:57 <KeyJoo> cocreture thank you
01:30:37 * hackagebot phoityne-vscode 0.0.15.0 – ghci debug viewer on Visual Studio Code – https://hackage.haskell.org/package/phoityne-vscode
01:39:31 <xormor> I have succeeded in running Haskell: https://pastebin.com/G0SjBVFv
01:40:00 <xormor> I made up the equation and someone helped me on IRC to formulate it into a Haskell expression.
01:40:15 <jared-w> nice!
01:40:21 <mud> xormor: Nice. You might want to try "runhaskell laurin.hs" as well
01:40:47 <xormor> mud, thanks :)
01:55:53 * hackagebot http2-client 0.2.0.0 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
02:55:50 <dbousamra> Hi. I have a datatype: data Memory s = Memory [Word8] s. How do I actually instantiate a literal value? The free s is causing me issues
02:56:12 <opqdonut> well for instance: Memory [12,13] True
02:56:17 <opqdonut> would have type Memory Bool
02:56:30 <opqdonut> or Memory [] Nothing
02:56:37 <opqdonut> would have type Memory (Maybe a)
02:56:52 <dbousamra> That makes total sense. I'm trying to fill the implementation for this:
02:57:04 <dbousamra> newMem :: ST s (Memory s)
02:57:47 <jle`> dbousamra: you can't quite do that
02:58:01 <jle`> at least, that's probably not what you want to do
02:58:13 <jle`> ST isn't relaly meant to let you get values of type s
02:58:36 <jle`> do you *really* want Memory to have an 's' field?
02:58:43 <jle`> why not data Memory s = Memoty [Word8] ?
02:58:47 <dbousamra> right. Full context, I'm trying to play about with this code: https://github.com/jaspervdj/dcpu16-hs/blob/master/src/Memory.hs#L54
02:59:18 <dbousamra> trying to understand how the new function is working
02:59:51 <jle`> yes it looks like the definition you gave is different from theirs
02:59:56 <jle`> theirs doesn't have an 's' field either
03:00:05 <jle`> are you familiar with the concept of phantom types?
03:00:55 <dbousamra> Loosely, and only from Scala. The notion of a type having a type param that is not used anywhere, but constrains
03:01:26 <jle`> yes, s is a phantom type there
03:01:30 <jle`> it's not meant to represent any values of type s
03:01:35 <jle`> it's just there to parameterize the type
03:01:47 <dbousamra> data Memory s = Memory (MutableByteArray# s)
03:01:48 <dbousamra> that one?
03:02:58 <jle`> yes
03:03:09 <jle`> Memory has no values of type s
03:03:15 <jle`> s is a phantom type parameter
03:04:08 <dbousamra> hmm
03:04:31 <pacak> s is designed to cause issues if you are doing something strange.
03:05:01 <pacak> :t runST
03:05:02 <dbousamra> pacak yeah I read about that. Not letting the s escape
03:05:03 <lambdabot> (forall s. ST s a) -> a
03:05:29 <pacak> :t newSTRef
03:05:31 <lambdabot> a -> ST s (STRef s a)
03:06:08 <pacak> dbousamra: Do you understand it now?
03:06:49 <dbousamra> sort of. I think I have enough to get going. Thanks guys
03:09:40 <xormor> how should I go on learning more Haskell? I have done equations with it. I think it is useful for mathematics.
03:10:16 <pacak> xormor: By writing programs
03:10:23 <pacak> there is no easy way to haskell.
03:10:29 <jle`> xormor: there are some nice books to help :)
03:17:55 <cheater> hi
03:18:08 <cheater> can someone suggest a mixed-integer quadratic programming library for haskell?
03:19:52 <ventonegro> xormor: http://haskellbook.com/
03:29:09 <dminuoso> Oha! So the the point of Monads is the composability of endofunctors?
03:29:47 <jle`> not sure what you mean by "the point"
03:29:55 <jle`> ..or by the composability of endofunctors
03:30:11 <mniip> do you mean monoidal structure of the endofunctor category
03:30:13 <jle`> or by endofunctors
03:30:22 <jle`> what endofunctors are yout alking about?
03:30:25 <jle`> and what kind of composition?
03:30:49 <dminuoso> jle`: Well, all a monad is, is an endofunctor with join and return right?
03:30:50 <koz_> jle`: I figured out my issues with mutable arrays and MonadRandom.
03:30:57 <jle`> congrats :)
03:31:08 <koz_> jle`: It's actually kinda obvious in retrospect. :P
03:31:20 <koz_> I guess this is why I shouldn't code when sleepy.
03:31:26 <jle`> koz_: i don't exactly remember what the issue was
03:31:32 <jle`> but i'm sure it was not too obvious :)
03:31:55 <koz_> jle`: I needed a stack of ST and MonadRandom, but wanted to return the answer in a stack of ExceptT and MonadRandom.
03:32:10 <koz_> The solution is a bit convoluted, but it works.
03:32:23 <jle`> heh. sometimes sleep does help :)
03:32:27 <jle`> dminuoso: sure
03:32:36 <koz_> Being away from Haskell for a while and then coming back also helps.
03:32:50 <koz_> I find I can read a lot of (for example) Oleg Kiselyov's stuff now and it doesn't read like Greek.
03:32:57 <jle`> hah
03:33:03 <dminuoso> jle`: Alright, so join just composes two endofunctors (or I suppose CT might call this a natural transformation)
03:33:03 <jle`> sometimes the mental break is important
03:33:25 <jle`> in what way does join compose two endofunctors?
03:34:15 <koz_> Also, is there a library implementing Oleg's latest-and-greatest, all-singing, all-dancing, all-Free version of extensible effects?
03:34:39 <koz_> (or should I just use the code from his site?)
03:35:39 * hackagebot creatur 5.9.20 – Framework for artificial life experiments. – https://hackage.haskell.org/package/creatur
03:36:25 <dminuoso> jle`: Well a monad is just a monoid in the category of endofunctors (S) and a monoid is closed over its monoidal operation S x S -> S
03:36:51 <jle`> there are many monoids in the category of endofunctors
03:36:59 <jle`> so if you want to talk about the monoidal operation, you have to specify which one you mean
03:37:44 <jle`> this might be like saying "so addition will multiply two numbers together?   addition is a monoid on numbers, right?  and multiplication is a monoidal operationa?"
03:38:46 <jle`> join takes the composition of the *same* endofunctor and turns it into just one application of that endofunctor
03:38:52 <jle`> it doesn't compose two different endofunctors together
03:39:25 <jle`> so join for Maybe is a natural transformation from (Maybe :.: Maybe) to Maybe
03:39:47 <jle`> in general, for Monad f, it's (f :.: f) ~> f
03:40:04 <jle`> note that it's for the *same* endofunctor, composed with itself
03:40:09 <jle`> not two different endofunctors
03:44:44 <dminuoso> jle`: wait a second, but join is just m a -> m b -> m b
03:44:47 <dminuoso> How is that not a composition?
03:44:57 <koz_> dminuoso: join isn't that.
03:44:59 <koz_> :t join
03:45:00 <jle`> :t join
03:45:01 <lambdabot> Monad m => m (m a) -> m a
03:45:02 <lambdabot> Monad m => m (m a) -> m a
03:45:10 <koz_> jle`: Jinx!
03:45:16 <jle`> i owe you a soda 
03:45:48 <koz_> jle`: I don't get the reference.
03:45:57 <jle`> dminuoso: m a -> m b -> m b can be considered a composition in a loose sense of the word, but it's not the one that corresponds to monad
03:46:14 <jle`> koz_: oh that's the typical prize of calling jinx first
03:46:22 <jle`> as per tradition
03:46:26 <koz_> jle`: Ah, OK. TIL I guess.
03:46:48 <koz_> Black cherry would be awesome, in case I'm ever in your neighbourhood.
03:46:53 <koz_> (or you're in mine I guess)
03:46:58 <jle`> deal :)
03:47:15 <dminuoso> jle`: Oh I was thining of >>
03:47:18 <dminuoso> Yeah.
03:47:21 <koz_> :t (>>)
03:47:24 <lambdabot> Monad m => m a -> m b -> m b
03:47:31 <koz_> Oh yeah, so it is.
03:47:38 <jle`> (>>) is not an endofunctor in the sense that we call monads endofunctors, though
03:48:20 <jle`> we also don't necessarily even need Monad to have (>>)
03:48:37 <koz_> jle`: Applicative could do that, right?
03:48:40 <tdammers> (>>) is a bit of a historical accident
03:48:50 <jle`> yeah
03:48:52 <tdammers> (*>) does the same but doesn't require Monad
03:48:57 <jle`> Applicative is actually another monoid in the category of endofunctors
03:49:02 <koz_> :t (*>)
03:49:04 <lambdabot> Applicative f => f a -> f b -> f b
03:49:28 <koz_> jle`: Applicative == lax monoidal functor, right?
03:49:58 <tdammers> I really like the "stars pointing to interesting stuff" pattern in applicative parser code: somethingWeDiscard *> theThingWeWant <* somethingDiscardableThatMustFollow
03:50:21 <koz_> tdammers: I'm more fond of the f <$> x <*> y thing.
03:50:54 <tdammers> koz_: that one is nice too
03:51:02 <jle`> for monad, the monoidal operation is (:.:), and for applicative, the monoidal operation is `Day`
03:51:14 <koz_> jle`: What are those in Haskell-speak?
03:51:27 <jle`> data (f :.: g) a = Comp (f (g a))
03:55:07 <koz_> jle`: What's `Day` in Haskell-speak then?
03:57:26 <mniip> Day :: f x -> g y -> (x -> y -> a) -> Day f g a
03:58:02 <koz_> mniip: f and g are Applicatives I guess?
03:58:13 <mniip> no just functors
03:58:47 <mniip> though a monoid under Day,Identity monoidal category will necessarily be applicative
03:59:28 <mniip> and I even have proofs of the monoidal cat laws stashed somewhere (Day is quantified and  not particularly nice to work with)
03:59:49 <koz_> mniip: It's OK - I don't think I know enough category theory to appreciate said proofs.
03:59:54 <mniip> nah
03:59:59 <mniip> it's a pure mechanical thing
04:00:16 <koz_> Mechanical proofs can still be difficult to follow if you don't understand said mechanics.
04:00:18 <mniip> write a function Day f (Day g h) a -> Day (Day f g) h a
04:00:48 <mniip> (Functor f, Functor g, Functor h) =>
04:01:54 <mniip> it's like 150 chars long with no apparent structure to it but it typechecks
04:08:12 <mniip> jle`, where'd you get that :.: stuff
04:08:16 <mniip> I'm used to Compose
04:08:24 <mniip> Data.Functor.Compose iirc?
04:15:01 <phadej> generics
04:15:05 <cocreature> mniip: (:.:) is the GHC.Generics variant of Data.Functor.Compose
04:15:27 <cocreature> it’s a bit silly that we have the same thing twice in base
04:16:27 * hackagebot grid 7.8.9 – Tools for working with regular grids (graphs, lattices). – https://hackage.haskell.org/package/grid
04:23:39 * hackagebot som 9.0.4 – Self-Organising Maps. – https://hackage.haskell.org/package/som
04:34:56 <mniip> base?
04:35:32 <cocreature> mniip: the base package
04:36:09 <mniip> yes but Compose isn't
04:36:30 <cocreature> it is since base 4.9, https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor-Compose.html#t:Compose
04:38:06 <mniip> huh
04:48:19 <kgadek> hi all. Q: what's your opinion of DuplicateRecordFields? Yes) super-useful, with lenses basically solves records "problem". No) it causes problems later and better not use it.
04:49:28 <erisco> doesn't support inference, not yet useful
04:49:47 <erisco> but when that is working it will be very useful
04:53:56 <tdammers> kgadek: No) Clarity and unambiguousness are more important than convenience
04:54:27 <tdammers> I prefer splitting things up into separate modules and importing those qualified
04:55:02 <jle`> yeah it's silly that COmpose exists
04:55:06 <jle`> also Product and Sum
04:55:20 <kgadek> tdammers: for you, does the same argument applies to Has-pattern? (class Has a b)
04:55:25 <jle`> they're already (:*:) and (:+:)
04:55:34 <jle`> but like, why
04:55:45 <jle`> did we add Product and Sum
04:55:51 <tdammers> kgadek: no. Has is mostly fine
04:55:52 <jle`> i guess they were originally named that way in 'transformers'
04:55:58 <tdammers> kgadek: just don't overuse
04:56:28 <tdammers> one problem with Has is that it focuses on the field name alone, but not on the meaning or the type
04:56:57 <tdammers> you can't have both class HasName a where name :: a -> String and class HasName a where name :: a -> Text
04:57:28 <kgadek> class HasName a b | a -> b
04:57:29 <tdammers> although with MPTC you can have class HasName a s where name :: a -> s
04:57:29 <kgadek> ?
04:57:34 <tdammers> so, yeah
04:57:36 <tdammers> that works
04:57:55 <tdammers> MPTC + fundeps
04:58:17 <kgadek> thanks. And back for records: I guess the name prefixing is the way to go? _fooText is su superugly but solves the problem. Qualified imports do not help much
04:58:40 <tdammers> qualified imports to help
04:58:40 <kgadek> I'm making types for some REST API and (for example) "text" value is so common
04:58:44 <tdammers> s/to/do/
04:58:58 <tdammers> yes, so call it "text" everywhere, but import qualified?
04:59:03 <kgadek> ok, let me give you example of my problem:
04:59:31 <kgadek> data Response = Type1 Resp1 | Type2 Resp2 | …
04:59:49 <kgadek> data Resp1 = Resp1 { _text :: Text, … }
04:59:58 <kgadek> data Resp2 = Resp2 { _text :: Text, …}
05:00:39 <kgadek> and the problem is:
05:00:52 <kgadek> *actual problem is: I can't export qualified modules 
05:01:09 <kgadek> that would force lib user to import bazillion modules with distinct prefixes
05:01:24 <kgadek> therefore, I've fallen back to two solutions
05:01:33 <kgadek> a) data Resp1 = Resp1 { _resp1Text :: Text, … }
05:01:56 <kgadek> b) DuplicateRecordFields + makeFieldsNoPrefix
05:03:09 <kgadek> I /could/ also recover by having: data Response = Type1 { _text :: Text, …} | Type2 { _text :: Text, …} | …
05:03:49 <kgadek> but that would mean that I have to get a lot of `case x of Type2 -> error "this can't happen, must be Type1"`
05:03:53 <kgadek> which I could solve with GADTs
05:04:42 <kgadek> data Response (a :: RespType) where Type1 :: {…} -> Response RType1 \n Type2 :: {…} -> Response RType2
05:05:35 <kgadek> but I don't feel putting GADTs everywhere is right when you can use much simpler constructs (data composition)
05:06:21 <kgadek> so… here I am, wondering what's best in long run
05:07:07 <tdammers> right
05:08:40 <tdammers> possible solutions: a) don't re-export, make users import qualified as needed; b) provide HasXXX typeclasses and export those
05:08:59 <tdammers> I would definitely not do Type1 { _text :: ... } | Type2 { _text :: ... }
05:09:09 <tdammers> never mix sum types with records
05:09:31 <tdammers> because then record fields used as accessors become partial
05:14:40 <pacak> "Never" feels a bit too extreme.
05:14:49 <aphorisme> I'm looking for a possibility to read out the currently open sockets (like netstat) via Haskell, has anyone an idea? At the moment I just run "netstat" and parse the table, but it is so messy... 
05:16:01 <pacak> aphorisme: cat /proc/net/tcp
05:16:08 <pacak> Those are droids you are looking for.
05:16:24 <tdammers> pacak: yeah, ok... it's the same kind of "never" that also governs when you should write partial functions in general
05:17:11 <aphorisme> pacak: so this is linux only, or?
05:17:19 <hpc> perhaps a good general rule is
05:17:31 <hpc> only do things you should "never" do, to handle cases that should "never" happen
05:17:32 <pacak> aphorisme: Are there any other OSes? :)
05:17:41 <hpc> pacak: bsd :P
05:17:50 <aphorisme> pacak: I wish there weren't. ; )
05:18:03 <opqdonut> aphorisme: if you want a portable solution, calling netstat is it I'm afraid
05:18:28 <aphorisme> opqdonut: I see. Well, then I have to stick to parsing a text table. Ey. Thanks to all.  : )
05:18:32 <opqdonut> as long as you have gnu netstat everywhere
05:18:39 <opqdonut> and well, /proc/net/tcp is a text table too
05:18:55 <hpc> yeah, windows' netstat output is subtly different
05:19:29 <aphorisme> I've already managed to parse os-specific, but it depends even on the OS' language. 
05:19:56 <aphorisme> It's a mess, I can tell. Hopefully it doesn't launch missiles based on its results.
05:23:20 * hackagebot mixed-types-num 0.3.1 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
05:29:24 * hackagebot http2-client 0.2.0.1 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
05:34:16 <`Guest00000> are there some instances defined in standard libs like instance (Num a, Applicative f) => Num (Appl (f a)) where Appl x + Appl y = Appl (liftA2 (+) x y) and so on, and how is Appl called?
05:37:06 <kgadek> tdammers: thanks for opinion :)
05:38:06 * hackagebot mixed-types-num 0.3.1.1 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
05:43:33 * hackagebot gf 3.9 – Grammatical Framework – https://hackage.haskell.org/package/gf
05:48:07 <pavonia> `Guest00000: applicative-numbers seems to provide such instances
06:30:05 * hackagebot mixed-types-num 0.3.1.2 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
06:33:13 <nicknight> hi
06:33:36 <nicknight> any newbie programmer who started haskel as his first language?
06:34:03 <nicknight> I heard haskel make you better programmer true?
06:34:13 <trigone> hi! this question is probably more hardware than coding, but i'm wondering if you can write to more than one hard disk at once if you use concurrent programming?
06:34:53 <duncan^> nicknight: haskell will make you think differently, but whether that makes you a better programmer is unknown
06:35:15 <nicknight> duncan^: think different how ??
06:35:26 <duncan^> nicknight: functionally
06:35:39 <duncan^> but you should try learning some haskell
06:35:46 <duncan^> then you will understand
06:36:02 <vktec> Learning Haskell as your first language will most likely make you a better *functional* programmer, but might make it harder to pick up OOP languages
06:36:42 <nicknight> OK 
06:36:59 <nicknight> oop arejob oriented if I am correct
06:37:16 <vktec> OOP = Object Oriented Programming
06:37:24 <vktec> Java, C++, etc.
06:37:31 <nicknight> I know I am saying oop will solve realworld problems
06:37:43 <nicknight> vktec:  even python oop right
06:37:46 <vktec> Well, you can solve real world problems with any language
06:37:52 <vktec> Yes, Python can do OOP
06:38:27 <nicknight> vktec: Ok but I guess haskel not famous
06:38:32 <nicknight> even thought its very old
06:38:37 <nicknight> java is famous
06:38:39 <Watercooler_Dale> Is cursing allowed.
06:38:44 <ventonegro> Try Smalltalk for the pure(tm) OO experience
06:39:06 <HellBaron> Hello
06:39:27 <vktec> As far as I can tall, OOP is used in industry because it's used in industry. There's no real reason for it, it's just what happened
06:39:49 <nicknight> ok 
06:39:54 <HellBaron> Of course
06:39:59 <vktec> More and more companies are starting to shift to FP, but if you're working on older codebases, it's likely to be C++ or Java
06:40:33 <HellBaron> You are a programmer?
06:40:49 <nicknight> HellBaron:  me ?
06:40:50 <trigone> re for my question -> can concurrent programming allow writing to several hard drives at once, or is it impossible at the hardware level?
06:40:56 <Watercooler_Dale> Oh, so basically geeks.
06:40:58 <trigone> also, what's the difference bwn concurrent and async?
06:41:11 <Watercooler_Dale> I wanted 4Chan levels of kek.
06:41:35 <HellBaron> No vktec
06:41:41 <vktec> I'm a programmer, yes
06:42:16 <HellBaron> Good. Sound like a good job
06:42:25 <HellBaron> Maybe stressful
06:42:51 <HellBaron> As many others..
06:43:19 <hexagoxel> http://lpaste.net/357716 - is there any way to prevent "stack ghc" from putting two aeson package versions in scope?
06:44:19 * hackagebot list-transformer 1.0.3 – List monad transformer – https://hackage.haskell.org/package/list-transformer
06:44:20 <tdammers> trigone: concurrent means that you have multiple lines of execution, and at least for part of your codebase, you do not care in which order they are run. asynchronous means not synchronous; synchronous means that the current line of program execution pauses ("blocks") while waiting for some process to finish. asynchronous means that rather than block and return the result, the call that triggers the other
06:44:22 <tdammers> process will return immediately, which also means that the result must be obtained in some other way.
06:44:58 <tdammers> trigone: and finally, parellel means that multiple things are actually happening at the same time
06:46:05 <vktec> trigone: Which means that *concurrent* programming cannot write to multiple drives simultaneously, but *parallel* might be able to (I don't know if there are hardware limitations)
06:46:51 <tdammers> more like, writing to multiple harddrives is a concurrent concern, but to actually make it happen simultaneously, you need to do it in parallel
06:46:53 <ventonegro> Isn't parallel always concurrent?
06:47:33 <trigone> tdammers: sorry, i still don't get the difference bwn async and concurrent...
06:47:46 <barrucadu> ventonegro: It depends.  In some fields, "parallel" and "concurrent" mean different things, in others they don't.
06:48:37 <barrucadu> Where there is a difference, it's usually something like "parallelism is doing things truly simultaneously and concurrency is programming with threads"
06:48:39 <tdammers> ventonegro: no, not always. you can, for example, perform bitwise OR in parallel, but that doesn't make it concurrent
06:49:05 <tdammers> ventonegro: likewise, vector addition can be done in parallel, but it's not concurrent
06:49:14 <ventonegro> I see
06:49:30 <Watercooler_Dale> Quick question: What does this channel do?
06:49:35 <hexagoxel> <rant> cabal new-exec does not exist; cabal sandbox management is buggy as hell, and trying to fall back on stack you don't only run into issues, you also have no idea anymore how to fix the process. i'll go back to cabal sandboxes, at least there i can work around the issues manually </rant>
06:49:42 <ongy> talk about Haskell and related thing
06:49:43 <barrucadu> Watercooler_Dale: We talk about Haskell!
06:49:46 <trigone> Watercooler_Dale: crepe, french fries, smoothies
06:49:48 <tdammers> trigone: the difference is that async refers to the semantics of an individual thread of execution, while concurrent refers to the fact that multiple threads exist
06:49:49 <ventonegro> Watercooler_Dale: https://www.haskell.org/
06:50:46 <trigone> tdammers: hm ok... so async is the fake version of concurrency, a bit like concurrency is the "fake" version of parallel (it's a metaphor, i know they have different usages). do we use async only when we don't have access to concurrency?
06:51:00 <tdammers> no, it's not fake
06:51:01 <trigone> or is there a special usage for async
06:51:16 <tdammers> async is one way to model concurrency
06:51:28 <tdammers> but you can also have async code that isn't concurrent
06:51:28 <trigone> tdammers: ah ok, it's an implementation of the concept?
06:51:38 <trigone> ok... i'm lost
06:51:40 <ongy> tdammers: what's the definition of concurrent?
06:51:55 <tdammers> ongy: multiple lines of program execution ("threads")
06:52:15 <Watercooler_Dale> I was wishing for more trolling and less coding.
06:52:35 <tdammers> if all your program ever does is kick off one async call and handle its result, then that's hardly concurrent
06:53:16 <trigone> tdammers: hm... so you mean async doesn't need to be everywhere, but concurrency more typically is?
06:53:26 <trigone> (everywhere/all the time)
06:53:28 <vktec> Watercooler_Dale: Sounds like you shouldn't have joined a channel dedicated to a programming language then :P
06:53:41 <tdammers> trigone: no, I don't mean that.
06:54:08 <trigone> tdammers: could you give me a more practical example which is async and not concurrent, or viceversa?
06:54:47 <tdammers> trigone: async, but not concurrent: readFileAsync "hello.txt" (\text -> putStrLn ("Hello, " ++ text))
06:55:24 <tdammers> trigone: concurrent, but not async: forkIO (putStrLn "Hello") >> forkIO (putStrLn "World")
06:55:28 <ongy> tdammers: then how does parallelised bitwise not fit that?
06:56:14 <trigone> tdammers: hm... maybe we could say that you give everything to do to async, and you don't expect to get a result?
06:56:34 <vktec> ongy: A bitwise operation is one atomic operation.
06:57:07 <vktec> Concurrency is when you have multiple streams of operations interleaved (though when programming you'd imagine them running at the same time)
06:57:35 <tdammers> trigone: yes, that's closer. async means that you don't get the result from the call directly; instead, you either receive a handle that will contain the result once it is available (called a "Promise" or a "Future"), or you have to pass in a function that says what to do with the result once it becomes available (called a "Continuation")
06:58:40 <trigone> tdammers: ok :) but under the hood, how can async be implemented without concurrency? i don't get the idea of having a subprogram run in the background but in the same thread...
06:59:38 <trigone> like, at some point your runtime will have to interleave the async job and the rest right?
07:00:05 <tdammers> trigone: of course, async code is inherently capable of being concurrent
07:00:26 <tdammers> trigone: it's just that if you don't build anything concurrent with it, it's still asynchronous
07:00:34 <ongy> vktec: So you are saying the difference only exists, when you don't want to think about electronics?
07:01:14 <vktec> ongy: Or when you're concerned about efficiency
07:01:27 <vktec> Otherwise, I'd say they're pretty similar concepts
07:02:11 <barrucadu> trigone: The difference is levels of abstraction
07:02:12 <barrucadu> trigone: Your question is sort of like someone saying "trees are better than byte arrays for this use-case" and you responding "but under the hood, how can trees be implemented without byte arrays?"
07:02:24 <tdammers> the bitwise operation is conceptually just one operation; it is done in parallel, but there are no concurrent concerns
07:02:24 <vktec> But you'd probably only want to write a parallel program when concerned about efficiency, whereas concurrency is a good way of doing things that don't need to happen in sequence
07:02:35 <trigone> barrucadu: so, async is more abstract than concurrency?
07:02:54 <barrucadu> trigone: Not necessarily *more* abstract, but a different abstraction
07:03:02 <tdammers> async is a calling convention
07:03:09 <tdammers> concurrency is a program flow pattern
07:03:12 <barrucadu> nodejs, for instance, implemented asynchronous programming without multiple threads
07:03:30 <barrucadu> node has an event loop, and calls the appropriate async callback function when the event it's waiting for finishes
07:03:48 <ertes-w> lo
07:03:54 <trigone> hm ok, i think i get it
07:04:39 <trigone> so async doesn't define *how* it's done, only how it must behave, whereas concurrency does define how it's supposed to be done
07:05:02 <trigone> but can you implement async without multithreads?
07:05:09 <Myrl-saki> trigone: Yes.
07:05:15 <Myrl-saki> trigone: By nonblocking I/O.
07:05:38 <trigone> Myrl-saki: what's that?
07:05:51 <Myrl-saki> trigone: You know how getLine pauses your program, right?
07:06:17 <Myrl-saki> trigone: Now make getLine not pause, and have another function that sees if there's an available line.
07:07:30 <ertes-w> honestly i don't think that 'async' has such a strict definition…  it's a highly overloaded term
07:07:33 <trigone> do you have to make a sort of loop that keeps checking if a line has been entered? and otherwise does some other job?
07:07:43 <ertes-w> the calling convention i would perhaps call "callbacks"
07:08:00 <Myrl-saki> riadvargas[m]: Exactly.
07:08:04 <Myrl-saki> trigone: *
07:08:05 <vktec> async doesn't have to mean callbacks
07:08:17 <Myrl-saki> ertes-w: In fact, IIRC, nonblocking I/O is also considered async.
07:08:29 <Myrl-saki> I may be wrong.
07:08:30 <trigone> Myrl-saki: *?
07:08:44 <vktec> * means a correction
07:08:44 <Myrl-saki> trigone: I pinged riadvargas[m] instead of you.
07:08:54 <Myrl-saki> trigone: And I corrected that by *
07:08:57 <trigone> Myrl-saki: oh ok ^^
07:09:06 <vktec> ertes-w: As an example, JS has promises
07:09:20 <Myrl-saki> vktec: It failed all of them though.
07:09:23 <Myrl-saki> vktec: jk jk
07:09:28 <vktec> Which do technically still use callbacks, but they work differently
07:09:31 <vktec> Myrl-saki: Hahaha
07:09:39 <trigone> so, async without concurreny amounts to manually interleaving work instead of whatever's handling the threads in an OS
07:10:08 <vktec> Well, that's pretty much what concurrency is...
07:10:18 <vktec> Concurrency doesn't have to be OS threads
07:10:53 <tdammers> async just means that when you call a procedure, the call returns before the procedure finishes
07:11:02 <Myrl-saki> trigone: interleaving *is* concurrency.
07:11:09 <trigone> vktec: oh i thought concurrency meant threads. though i guess at this point the issues are terminological ^^
07:11:33 <tdammers> this can be done by forking a thread, or by pushing the computation onto an execution queue
07:11:48 <Myrl-saki> trigone: Don't worry. :P In fact, in a single-core computer(do they even still exist??), user-space concurrency and kernel-space concurrency are pretty much the same.
07:11:49 <vktec> Well, you can have "green threads", which are handled by the language runtime rather than the OS
07:12:03 <ongy> Myrl-saki: I still have one of those (as router)
07:12:59 <Myrl-saki> ongy: I have a Thinkpad that has a modem. I should consider using it as a router.
07:13:01 <trigone> tdammers: ok... so async vs non async concurrency is more a difference of expression: async being more callback-oriented?
07:13:15 <ongy> Myrl-saki: what modem? isdn?
07:13:48 <Myrl-saki> ongy: Not familiar with the terminologies. It connects to a telephone wire.
07:13:52 <tdammers> trigone: you could say that, more or less. Async is one way to express concurrency.
07:13:52 <infandum> I'm trying to allow the user to input any function of type ([a] -> a) from the command line. I'm using hint to do this. I'm testing out hint and I get to the point where I have (f :: Either InterpreterError Fun), where (newtype Fun = Fun { getFun :: forall a. ([a] -> a) }). However, when I do (either show (\x -> show $ (getFun x) [1,2,3]) f) I end up with During interactive linking, GHCi couldn't find the following symbol:
07:13:52 <infandum> interactive_Ghci1_getTest_closure This may be due to you not asking GHCi to load extra object files, archives or DLLs needed by your current session., etc. What am I doing wrong?
07:14:14 <ertes-w> you might consider async exceptions a form of async, but not a form of concurrency
07:14:18 <ertes-w> for example signal handling
07:14:22 <ertes-w> or event callbacks
07:14:33 <ertes-w> (that you don't have to trigger explicitly)
07:14:36 <ongy> Myrl-saki: i have one of those aswell. But I doubt it will do any halfway modern DSL :(
07:15:10 <trigone> ertes-w: hm i see
07:15:14 <ertes-w> async is basically anything that "just happens" in the background, or is triggered by something in the background at arbitrary points in your code
07:15:42 <Myrl-saki> ongy: It was released in 2008.
07:15:51 <ertes-w> concurrency is when you have multiple threads of execution…  these are code paths you have explicitly written
07:15:55 <Myrl-saki> ongy: Tbf, I'm not exactly sure if it's a Modem.
07:16:01 <trigone> ertes-w: to me it still feels like it probably entails concurreny, by virtue of having a background and a foreground at least potentially working in an interleaved fashion...
07:16:04 <Myrl-saki> ongy: It just has 2 network jacks, and one is shaped differently.
07:16:11 <ertes-w> and they don't have to be simultaneous…  for example coroutines are a form of concurrency
07:16:48 <Myrl-saki> This topic reminds me of the joys of "concurrency vs parallelism" :D
07:17:11 <ertes-w> trigone: well, as i said, "async" is not a very well-defined term
07:17:19 <ongy> Myrl-saki: VDSL2 is from 2006, ADSL even newer. So I doubt it
07:17:31 <ongy> (doubt it's anything decent for these days standards)
07:17:35 <trigone> ertes-w: yeah ^^ but i have a clearer picture, thanks :)
07:17:37 <Myrl-saki> ongy: Aww. :(
07:17:56 <ertes-w> trigone: it only becomes well-defined, if you attach an explicit asynchronous model to it…  and then in most cases it will be equivalent to concurrency
07:18:04 <trigone> Myrl-saki: concurrent and parallelism have rather clear-cut differences in purpose and implementation, have they not
07:18:17 <Myrl-saki> ongy: Well, our internet speed is 5Mbps
07:18:28 <ongy> that's sad
07:18:29 <Myrl-saki> ongy: Are they backwards compatible?
07:18:33 <Myrl-saki> ongy: And yep, it's sad. :P
07:18:53 <ongy> to be honest, I haven't put too much research into DSL/modem standards in general
07:19:07 <ertes-w> Myrl-saki: ours isn't much faster…  we have only 150 mbps
07:19:10 <ongy> you could probably look up what specific chip you have, and which standards it supports
07:19:16 <Myrl-saki> ertes-w: millibits!?
07:19:26 <ertes-w> megabits
07:19:27 <ongy> ertes-w: symmetric and full duplex?
07:19:29 <trigone> lol millibit
07:19:39 <ertes-w> ongy: symmetric, half duplex
07:20:00 <Myrl-saki> Symmetric means up = down?
07:20:04 <ongy> yes
07:20:19 <Myrl-saki> Oh boy
07:20:24 <Myrl-saki> don't get me started with our upload speeds
07:20:29 <Myrl-saki> I think our upload speeds are 1 Mbps at most.
07:20:30 <trigone> one bit every six second ^^
07:20:31 <ongy> I have 100Mbit/s symmetric full duplex :D
07:21:19 <ongy> trigone: probably close to what https://en.wikipedia.org/wiki/Semaphore_Flag_Signaling_System would achieve
07:22:06 <Myrl-saki> ongy: Which would have better ping times, SFSS or IPoA?
07:22:19 <trigone> ongy: lol
07:22:34 <orion> Hey, does anyone have any example opaleye code for the specific case of when the "Read" and "Write" tables differ?
07:22:45 <ongy> probably SFSS, but IPoA could have a pretty good MTU
07:23:24 <ertes-w> Myrl-saki: honestly though, i'm sorry…  a fast internet connection is so much better, so much more enjoyable…  i'm not trying to rub it in, i just feel sorry…  your internet is so awfully slow…
07:23:42 <orion> In particular, I don't think I can use makeAdaptorAndInstance.
07:23:49 <Myrl-saki> ongy: The interesting thing is that "oA" is actually down by photographers. [citation needede]
07:24:23 <ongy> ertes-w: the best thing, I can just and use a workplace at the uni when my connection is too slow
07:24:26 <Myrl-saki> ongy: Wikipedia: Rafting photographers already use pigeons as a sneakernet to transport digital photos on flash media from the camera to the tour operator.
07:24:33 <Myrl-saki> ongy: "too slow"
07:24:36 <Myrl-saki> ongy: gahhhh
07:24:56 <ongy> Myrl-saki: they don't run IP over it, but the general idea applies :)
07:24:57 <Myrl-saki> ertes-w: I don't even know if I'll ever have 20ms ping times.
07:25:06 <ongy> Myrl-saki: did you never have to do download 300GB+?
07:25:50 <Myrl-saki> ongy: I watch anime, so I spread that out in 6 months or so?
07:25:57 <trigone> ongy: what could you need to dwd which would be 300gb sized?
07:26:06 <Myrl-saki> trigone: Data sets come to mind.
07:26:30 <ertes-w> ongy: my connection at home is actually faster than the connection at work =)
07:26:37 <trigone> Myrl-saki: oh... i guess. it's a very specific usage though
07:26:52 <ongy> that specific one was the entire debian jessie (and this year debian stretch) repository
07:27:08 <ertes-w> Myrl-saki: you probably preload an episode a day before you watch it =)
07:27:24 <Myrl-saki> trigone: I think other people have it worse, actually w/ movies.
07:27:30 <ertes-w> Myrl-saki: youtube-dl is your friend (it supports many sites)…  trust me, i know =)
07:27:36 <infandum> Oh, it's a problem of the newtype, not hint
07:27:50 <Unode> how do I visualize the result of: maybe maxBound fromIntegral $ Just 2
07:27:55 <ongy> infandum: ? what is?
07:28:07 <ongy> > maybe maxBound fromIntegral $ Just 2
07:28:09 <lambdabot>  error:
07:28:10 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M276138734879...
07:28:10 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:28:13 <ertes-w> Unode: "visualise" in what sense?
07:28:13 <infandum> ongy: During interactive linking, GHCi couldn't find the following symbol:
07:28:13 <infandum>   interactive_Ghci6_getTest_closure
07:28:22 <Myrl-saki> ertes-w: :P Jokes aside. I'm actually happy because our ISP (transparently) updated our speeds from 3Mbps to 5Mbps, and I can stream 720p all the time and 1080p on good days.
07:28:33 <Myrl-saki> ertes-w: And nowadays, good days are like, 80-90% of the days.
07:28:38 <infandum> For newtype Test = Test { getTest :: forall a. forall t. (Ord a, Eq a, Foldable t) => t a -> a }
07:28:39 <trigone> (maybe maxBound fromIntegral $ Just 2 ) :: Int
07:28:40 <Unode> ertes-w: I want to know what it evaluates to. i.e. what value it holds.
07:28:41 <ongy> Myrl-saki: where are you from?
07:28:45 <trigone> > (maybe maxBound fromIntegral $ Just 2 ) :: Int
07:28:49 <lambdabot>  2
07:28:50 <Myrl-saki> ongy: Philippines! :D
07:29:00 <ertes-w> Unode: use GHCi
07:29:09 <ertes-w> Unode: GHC comes with a fully fledged interpreter
07:29:11 <trigone> Unode: you need type signature
07:29:25 <Unode> ertes-w: I did, doesn't work either unless I specify an explicit type like trigone did
07:29:28 <Unode> and I don't understand why
07:29:33 <ertes-w> Unode: because of this:
07:29:36 <ertes-w> :t fromIntegral
07:29:39 <lambdabot> (Num b, Integral a) => a -> b
07:29:51 <ertes-w> Unode: GHC doesn't know what result type you want
07:30:05 <ertes-w> Unode: there are defaulting rules, but they did not apply here
07:30:19 <Myrl-saki> I wonder if there's a term for this.
07:30:53 <Myrl-saki> Correct me if I'm wrong, but you can have a polymorphic result type, but an input type "must" not be polymorphic.
07:31:07 <Unode> ertes-w: not sure I get the why yet
07:31:30 <ertes-w> Unode: look at the type of fromIntegral above…  the result type is polymorphic, right?
07:31:54 <trigone> Myrl-saki: to print the maxBound you need it to be monomorphic though, and you can't be sure to be able to show any Num a
07:32:00 <Unode> ertes-w: due to Num correct?
07:32:12 <ertes-w> Unode: no, due to fromIntegral being polymorphic
07:32:25 <ertes-w> (and it happens to use Num, but that's not the reason)
07:32:26 <trigone> ertes-w: and maxBound
07:32:32 <ertes-w> yes, and maxBound
07:32:40 <Unode> :) kind-of redundant there. I guess I'm not reading the why is it polymorphic.
07:32:40 <ertes-w> actually fromIntegral should default just fine
07:32:51 <ertes-w> > fromIntegral 15
07:32:54 <lambdabot>  15
07:33:02 <ertes-w> > maxBound 15  -- but maxBound definitely needs a type signature
07:33:05 <lambdabot>  error:
07:33:05 <lambdabot>      • Could not deduce (Num t0)
07:33:05 <lambdabot>        from the context: (Num t, Bounded (t -> t1))
07:33:09 <ertes-w> err
07:33:12 <ertes-w> > maxBound  -- but maxBound definitely needs a type signature
07:33:15 <lambdabot>  ()
07:33:24 <trigone> ertes-w: lol monomorphism restriction
07:33:26 <ertes-w> seems like lambdabot has extended defaulting rules
07:33:34 <trigone> at least i think that's that
07:33:41 <ertes-w> trigone: i don't think MMR is responsible for this
07:33:44 <Myrl-saki> How does `> maxBound` evaluate though...
07:33:58 <ertes-w> huh?
07:34:02 <ertes-w> it works in GHCi
07:34:06 <Myrl-saki> lambdabot |  ()
07:34:15 <ertes-w> > maxBound `asTypeOf` fromIntegral 15
07:34:17 <trigone> ertes-w: you don't think? why did it choose () then? it's clearly monomorphic
07:34:18 <lambdabot>  error:
07:34:18 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M373743296413...
07:34:18 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:34:26 <Myrl-saki> Oh wait. I just realized that `maxBound :: Bounded a => a`
07:34:32 <ertes-w> trigone: it seems to default to ()
07:34:37 <Myrl-saki> > minBound
07:34:40 <lambdabot>  ()
07:34:43 <ertes-w> that's a really weird default for Bounded
07:35:00 <ertes-w> 10 years of haskell, and i still suck at defaulting =)
07:35:10 <trigone> ertes-w: lol i agree, but maybe they defined () as default whenever the instance existed regardless of the class
07:35:19 <ertes-w> > mempty
07:35:22 <lambdabot>  ()
07:35:27 <ertes-w> hmm
07:35:35 <Myrl-saki> > mempty <> mempty
07:35:39 <lambdabot>  ()
07:35:39 <trigone> ertes-w: why would it not be the monomorphic restriction though?
07:35:48 <ertes-w> @let class Blah a where blah :: a; instance Blah () where blah = ()
07:35:48 <lambdabot>  Parse failed: Parse error: instance
07:35:49 <trigone> i just recently heard of it and it seems to fit
07:35:55 <ertes-w> @let class Blah a where { blah :: a }; instance Blah () where blah = ()
07:35:57 <lambdabot>  Defined.
07:35:59 <ertes-w> > blah
07:36:02 <lambdabot>  ()
07:36:11 <ertes-w> trigone: looks like it
07:36:13 <trigone> ertes-w: well here there's no other instance so...
07:36:26 <ertes-w> @let instance Blah Bool where blah = False
07:36:29 <lambdabot>  Defined.
07:36:31 <ertes-w> > blah
07:36:34 <lambdabot>  ()
07:36:40 <ertes-w> i highly doubt the existence of another instance makes a difference
07:37:07 <trigone> @let class Waa a where { waa :: a }; instance Waa Int where waa = 0; instance Waa () where waa = ()
07:37:07 <lambdabot>  Parse failed: Parse error: instance
07:37:13 <ertes-w> in any case this is defaulting, not MMR
07:37:19 <trigone> @let class Waa a where { waa :: a }; instance Waa Int where {waa = 0}; instance Waa () where{ waa = ()}
07:37:22 <lambdabot>  Defined.
07:37:23 <ongy> > fromInteger 1 -- The extended defaulting does a lot, but not everything
07:37:26 <trigone> > waa
07:37:27 <lambdabot>  1
07:37:29 <lambdabot>  ()
07:37:37 <trigone> >waa
07:37:44 <trigone> > waa
07:37:47 <lambdabot>  ()
07:38:07 <ertes-w> this isn't extended defaulting, it's regular defaulting…  i just tested it in GHCi
07:38:22 <Myrl-saki> > let u = id in u waa
07:38:22 <trigone> ertes-w: i thought monomorphic restriction was about defaulting...
07:38:25 <lambdabot>  ()
07:38:37 <ertes-w> trigone: MMR is about picking special vs. general types for *definitions*
07:38:48 <Unode> So again can you explain what is the reason why I need to explicitly type the output of that maybe? Is it due to the behavior introduced by Bounded ? I don't get it.
07:39:04 <nshepperd_> :t show maxBound
07:39:05 <ertes-w> trigone: i.e. whether to reuse type variables in lexical scope, or go with the most general type
07:39:05 <barrucadu> ertes-w: I thought ghci used the extended defaulting rules by (heh) default
07:39:06 <lambdabot> String
07:39:06 <trigone> ertes-w: well here it's not really a definition but still it had to pick a specific type sig...
07:39:20 <ertes-w> barrucadu: oh, you may be right
07:39:40 <trigone> wait, show maxBound = "String"??
07:39:48 <trigone> oh no the type neverminD
07:39:52 <ertes-w> trigone: MMR is about whether to choose types from the local scope…  it's not about defaulting
07:39:59 <trigone> ertes-w: ok...
07:40:07 <ertes-w> trigone: f x = y + y where y = x + x
07:40:27 <ertes-w> is y Num-polymorphic, or is it monomorphic, reusing the type from 'f' itself?
07:40:30 <ertes-w> that's what MMR is about
07:41:04 <trigone> ok... i don't get it but nevermind, i'll look into it later :)
07:41:16 * Unode doesn't get it either
07:41:42 <nshepperd_> When you print maxBound the result is just a String, without any type variables. It means the type of maxBound is an undetermined type variable. It could be anything without affecting the rest of the program's types
07:41:43 <ertes-w> trigone: imagine ScopedTypeVariables were enabled
07:41:57 <ertes-w> trigone: f :: forall a. (Num a) => a -> a; f x = y + y where y :: a; y = x + x
07:42:00 <ertes-w> that's with MMR
07:42:18 <ertes-w> wait…  i'm talking non-sense
07:42:26 <nshepperd_> But you have to choose some type, so that you have some specific Show instance and Bounded instance
07:42:44 <ertes-w> trigone: with MMR: f :: forall a. (Num a) => a -> a; f x = y x + y x where y :: a -> a; y x' = x' + x'
07:42:56 <ertes-w> trigone: without MMR: f :: (Num a) => a -> a; f x = y x + y x where y :: (Num a) => a -> a; y x' = x' + x'
07:43:13 <ertes-w> without MMR y's type is self-contained
07:43:31 <ertes-w> you could move it to the top-level, and it would have the same type
07:43:59 <Unode> nshepperd_: I don't see why the result of maxBound is a String. Isn't that because you used :t show  and show produces a String ?
07:44:20 <Unode> isn't this unrelated the the Bounded behavior?
07:44:31 <Unode> *to the
07:44:40 <nshepperd_> Unode: the result of 'show maxBound' is a string
07:44:57 <ertes-w> Unode: sorry, i went on a tangent there…  it's only indirectly related to your problem =)
07:45:01 <cheater> can someone suggest a mixed-integer quadratic programming library for haskell?
07:45:28 <Unode> ertes-w: I noticed :) I was trying to follow and see if I could get it but it's beyond me. I'm not there yet.
07:46:29 * hackagebot hascar 0.2.1.2 – Decompress SAPCAR archives – https://hackage.haskell.org/package/hascar
07:46:29 * hackagebot hslua 0.7.1 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
07:46:40 <ertes-w> Unode: let's look at the type of your expression
07:46:52 <trigone> ertes-w: ok thx :)
07:46:56 <Unode> (Bounded b, Num b) => b
07:47:00 <ertes-w> :t maybe maxBound fromIntegral (Just 2)
07:47:02 <lambdabot> (Num b, Bounded b) => b
07:47:35 <trigone> > show $ maybe maxBound fromIntegral (Just 2)
07:47:36 <ertes-w> Unode: you ask for the value of that, and values only exist for concrete types…  so you're challenging GHC to come up with such a concrete type
07:47:37 <lambdabot>  error:
07:47:37 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show’
07:47:37 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:47:45 <trigone> :t show $ maybe maxBound fromIntegral (Just 2)
07:47:47 <lambdabot> error:
07:47:47 <lambdabot>     • Ambiguous type variable ‘a0’ arising from a use of ‘show’
07:47:47 <lambdabot>       prevents the constraint ‘(Show a0)’ from being solved.
07:47:57 <ertes-w> Unode: now GHC has defaulting rules for many type classes, but it doesn't have defaulting rules for *combinations* of type classes
07:48:11 <ertes-w> > mempty :: (Monoid a) => a
07:48:13 <trigone> ertes-w: ah that explains it
07:48:15 <lambdabot>  ()
07:48:18 <ertes-w> > mempty :: (Monoid a, Bounded a) => a
07:48:21 <lambdabot>  ()
07:48:25 <ertes-w> oh, come on
07:48:26 <Unode> erm..
07:48:26 <trigone> ertes-w: maybe it works when the types are all the same
07:48:36 <trigone> ertes-w: i mean when the defaults of all classes are all the same
07:48:38 <ertes-w> > mempty :: (Num a, Bounded a) => a
07:48:38 <nshepperd_> The point is, without defaulting, 'show maxBound' would have type "(Bounded a, Show a) => String". Useless. Because you have no way to indicate what is a
07:48:41 <lambdabot>  error:
07:48:41 <lambdabot>      • Could not deduce (Monoid a1) arising from a use of ‘mempty’
07:48:41 <lambdabot>        from the context: (Bounded a, Num a)
07:48:51 <Unode> So it's something specific to Num and Bounded?
07:49:03 <ertes-w> Unode: GHC doesn't have defaulting rules for *most* combinations =)
07:49:10 <trigone> > mempty :: (Num a) => a
07:49:13 <lambdabot>  error:
07:49:13 <lambdabot>      • Could not deduce (Monoid a1) arising from a use of ‘mempty’
07:49:13 <lambdabot>        from the context: Num a
07:49:26 <trigone> > mempty :: (Num a, Monoid a) => a
07:49:30 <lambdabot>  error:
07:49:30 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M131653442510...
07:49:30 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:49:56 <trigone> show maxBound
07:49:58 <trigone> > yshow maxBound
07:49:58 <ertes-w> "you want a Num?  sure, Integer…  you want a Bounded?  sure, ()…  you want both at the same time?!  sorry, no idea how to deal with that"
07:50:02 <lambdabot>  error:
07:50:02 <lambdabot>      • Variable not in scope: yshow :: t0 -> t
07:50:02 <lambdabot>      • Perhaps you meant ‘show’ (imported from Prelude)
07:50:04 <trigone> > show maxBound
07:50:07 <lambdabot>  "()"
07:50:37 <trigone> ertes-w: yeah, that seems to be the deal. it doesn't pick any default, and from there cannot assure there's a Show instance
07:50:45 <nshepperd_> I sort of assumed ghc would just choose the first type from a list that happens to satisfy all the constraints
07:51:38 <nshepperd_> I guess that's not how it's implemented though?
07:51:59 <trigone> nshepperd_: in the first place, you should never rely on default values (i dont even get the purpose of it), so really that'd make ghc's behavior just even more baffling...
07:52:01 <nshepperd_> > maxBound + 1
07:52:03 <lambdabot>  error:
07:52:04 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M393744999801...
07:52:04 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:52:34 <Unode> > (maxBound :: Int) + 1
07:52:37 <lambdabot>  -9223372036854775808
07:52:51 <trigone> seriously, why default types? nobody wants to use "any type for that class" (esp if the default is () ^^)
07:53:15 <Unode> So... I'm still confused
07:53:20 <trigone> it should just refuse to typecheck, just like for intersection of constraints
07:53:20 <ertes-w> trigone: have fun writing haskell without defaulting =)
07:53:38 <ertes-w> 1 + 1 -- type error
07:53:52 <Unode> So 'Bounded' is polymorphic in the sense that it needs a type to define its boundaries. Correct?
07:54:14 <Unode> I sort of understand the logic behind it but don't understand how this happens. But moving on...
07:54:23 <trigone> ertes-w: hm... ok, but not all classes should have defaults
07:54:34 <ertes-w> Unode: Bounded is a type class…  for a full understanding wait for your learning material to teach them
07:54:36 <trigone> ertes-w: it really makes no sense to default maxbound to ()
07:54:53 <Unode> Then there's 'Num' which is also polyumorphic in the sense that it can 'hold' different numeric types. Is this somewhat correct?
07:55:52 <ertes-w> Unode: things like Bounded, Fractional, Integral, Monoid and Num are all type classes…  don't worry about them, until you properly learn them…  for now just think of them as "constraints for types that require certain operations to be defined"
07:56:47 <ertes-w> trigone: probably, but then it doesn't seem to be dangerous…  i've started haskell ten years ago, and until today i didn't even know about this particular defaulting rule
07:57:26 <dolio> Not all type classes do have defaults.
07:57:34 <dolio> Or, cause defaulting.
07:57:43 <Unode> ertes-w: I've sort of been there but didn't fully grasp it while reading Learning Haskell from first .... Now trying the Learn You a Haskell... book.
07:57:58 <dolio> GHCi allows more, which is also enabled by ExtendedDefaultRules.
07:58:06 <trigone> ertes-w: bc you never actually end up using it. it's not dangerous, but it's a bit confusing for no apparent gain in functionality
07:59:01 <Unode> The first book went into a lot of detail on why things work the way they work but it didn't give me the "why should I care" and "how do I use this" parts in a clear way.
07:59:05 <nshepperd> trigone: the main use case is using ghci as a calculator
07:59:13 <trigone> dolio: not sure, we tested it earlier with a new class, and it defaulted to the type () as soon as the instance existed
07:59:21 <nshepperd> having to add type signatures every time you write a number would be annoying
07:59:39 <trigone> nshepperd: yes, i say it's confusing for Bounded, not for Num
07:59:42 <nshepperd> but it's also relevant when you use things like (^) or OverloadedStrings in code
07:59:56 <nshepperd> :t (^)
07:59:58 <lambdabot> (Num a, Integral b) => a -> b -> a
08:00:03 <ertes-w> Unode: perhaps try this one: https://www.cis.upenn.edu/~cis194/
08:00:09 <dolio> trigone: Tested where?
08:00:16 <trigone> dolio: here, with lambdabot
08:00:18 <dolio> lambdabot has the extended default rules on.
08:00:19 <ertes-w> Unode: in my personal opinion LYAH is not very good
08:00:23 <trigone> dolio: oh ok then
08:00:23 <nshepperd> people write (^2) a lot in code, which would be an error without defaulting
08:00:51 <dolio> It's also possible to make `show (maxBound + 1)` default to something.
08:01:05 <dolio> But by default, there's nothing with the right instances in the defaulting list.
08:01:06 <ertes-w> trigone: we were talking about haskell's inconsistencies yesterday in another channel…  lots of language features are confusing…  you kinda just get used to them =)
08:01:15 <ertes-w> trigone: but we have far fewer WATs than other languages
08:01:31 <trigone> nshepperd: i get that, you don't need to convince me. i just say, the default for Bounded is weird, and if you don't know of it first, you get weird ()-based results which have no use at all
08:01:32 <Unode> lets not talk about javascript
08:01:38 <ongy> like [] + {} tier WATs?
08:02:10 <trigone> ertes-w: i agree, i don't rant, i just am a bit of a pathological perfectionist. it doesn't bother me, i just say, without really caring "it'd be less absurd if ..."
08:02:12 <Unode> trigone: I sort of get why maxBound works like that. Not that it's at an intuitive level.
08:02:13 <tdammers> [] + {} isn't very interesting in the wild - if you encounter it, then that means there is a lot more wrong with that codebase than being written in javascript
08:02:51 <Unode> trigone: Bounded is supposed to represent Boundaries of types. If no type is specified, unit is the 'end' of both boundaries.
08:02:57 <trigone> tdammers: pretty sure you can do that operation by error in JS if each operand is the result of a function all all that
08:02:57 <ertes-w> trigone: then please vote for making haskell great in the next iteration…  help me not to have to ever write FlexibleContexts or TupleSections again =)
08:03:03 <dolio> You can also disable defaulting completely if you want.
08:03:07 <Unode> but that's where my intuition ends :)
08:03:08 <dolio> By putting `default ()` in your files.
08:03:15 <tdammers> trigone: yes, and when that happens, it means your code is bad
08:03:27 <tdammers> trigone: or at least insufficiently tested
08:03:40 <trigone> t
08:04:10 <Unode> ertes-w: thanks for the link. I'll give that a read. Bookmarked.
08:04:27 <trigone> tdammers: sure, but JS is still at fault partially, bc you gotta actively fight with it to write good code. for the most part, haskell fights with you if you want to write bad code :P
08:04:29 <c_wraith> tdammers: or exploiting javascript filters that try to remove "dangerous" sigils, but aren't aware that javascript is so dynamic that you can call just about anything with only a couple operators, none of which are .
08:04:31 <nshepperd> > read "1"
08:04:34 <lambdabot>  *Exception: Prelude.read: no parse
08:04:44 <nshepperd> ^^ a case of defaulting rules being bad
08:04:45 <ongy> > read "()"
08:04:48 <lambdabot>  ()
08:05:34 <nshepperd> 'read' should really always be a compiler error when the type is undetermined
08:05:45 <trigone> nshepperd: so should maxBound actually
08:06:22 <dolio> Read isn't normally defaulted on its own.
08:06:22 <ongy> or Num types, since 250 + 6 can be different depending on type
08:06:58 <nshepperd> > read "1" + 1
08:07:01 <lambdabot>  2
08:07:05 <trigone> dolio: well i guess it's more like the default for Read a
08:07:15 <tdammers> trigone: that's an orthogonal concern though. you have to fight it because it lacks crucial expressivity features like a type system
08:08:08 <trigone> tdammers: well yeah... that's what i meant, among others
08:08:29 <dolio> Defaults are not per-class.
08:09:35 <trigone> dolio: you sure?
08:09:39 <dolio> Yes.
08:09:41 <trigone> :t read "1"
08:09:43 <lambdabot> Read a => a
08:09:44 <dolio> Go read the Haskell report.
08:09:50 <trigone> :t 1+1
08:09:52 <lambdabot> Num a => a
08:10:11 <trigone> dolio: if it's not a question of class, why is read "1" defaulting to type () and not 1+1?
08:10:35 <trigone> dolio: oh right nevermind
08:10:52 <trigone> :t maxBound + maxBound
08:10:55 <lambdabot> (Bounded a, Num a) => a
08:10:59 <trigone> > maxBound + maxBound
08:11:01 <lambdabot>  error:
08:11:02 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M763967646451...
08:11:02 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:11:02 <dolio> Because `read "1"` has constraint `Read a` and `read "1" + 1` has constraints `(Read a, Num a)`, and () is not a Num.
08:11:32 <nshepperd> Read seems worse to me since it's a partial function that takes stringly typed input
08:12:07 <nshepperd> but then, it's almost never an issue in real code, because normally you do things with values other than immediately printing them
08:12:24 <trigone> nshepperd: i think read is more like useful at university to try to demonstrate input output... but maybe it has other practical (reasonable) usaeg
08:14:52 <trigone> is there a function which would take a value as input, and a string, and if the value is bottom, it outputs "error string" (aka a way to replace the error message from partial functions, since most of the time they're hardly useful)
08:15:22 <monochrom> No.
08:15:35 <c_wraith> depends on your definition of "function"....
08:16:23 <monochrom> Heh I decided to use my definition.
08:16:45 <nshepperd> if the value is an _exception_, you can do that
08:16:50 <c_wraith> There are hacks that work sometimes.  But they are hacks.  They don't always work.  When they fail arbitrarily, it's very hard to debug what went wrong because you're using them.
08:16:53 <trigone> c_wraith: well, even if it's built-in, at least if we could that'd be pretty useful... i mean what do you do when your program halts bc of head and tells you "*** Exception: Prelude.head: empty list". you don't know where, you don't konw which list...
08:16:58 <nshepperd> (you can't catch a nonterminating value)
08:17:18 <trigone> nshepperd: even in the IO monad? i know it'd be a stretch and probably hard to handle anyway
08:17:32 <nshepperd> trigone: halting problem
08:18:05 <monochrom> At this point we also diverge what "bottom" refers to!
08:18:10 <dolio> Why not not use head in the first place?
08:18:15 <trigone> ok... it's still a shame you can't rewrite the error string of any partial function at will
08:18:15 <ertes-w> trigone: just don't use the partial functions in the first place
08:18:30 <trigone> dolio: obviously, yes
08:18:31 <nshepperd> anyway you can catch an exception, and re-throw it with extra information, if you're really careful
08:18:48 <nshepperd> talking about pure exceptions
08:19:27 <nshepperd> but it will work with (error "exception") and not [1, error "exception"] which will be unaffected
08:19:44 <ertes-w> any attempt to do that starts with "unsafePerformIO"
08:19:57 <nshepperd> and not (\x -> error "exception")
08:20:58 * hackagebot smiles 0.2.0.0 – <i>Added by fonturacetamum, Tue Aug 15 15:18:53 UTC 2017.</i> – https://hackage.haskell.org/package/smiles
08:20:58 * hackagebot jukebox 0.2.19 – A first-order reasoning toolbox – https://hackage.haskell.org/package/jukebox
08:21:17 <nshepperd> but anyway the actual solution to "*** Exception: Prelude.head: empty list" is either "don't use head in the first place" or compile with -prof and run with +RTS -xc and get a stack trace
08:22:49 <trigone> you know i wasn't asking that in the idea of using read/head, etc. i don't use them in general. but i was thinking "on top of being partial, it outputs a useless error message, so if one would really want to use them, it'd be cool to be able to personalize the error message". that's all, i don't plan on going all partla
08:22:57 <trigone> *partial
08:23:43 <trigone> but i guess it encourages people to not use them so it's good too in a way
08:24:23 <orion> What exactly is the difference between f :: (a -> b) -> f a -> f b, g :: (b -> a) -> f a -> f b, and h :: (a -> b) -> f b -> f a?
08:24:24 <dolio> I imagine having to provide an error message would take away the appeal of using them.
08:24:30 <dolio> Since they'd no longer be short.
08:24:48 <c_wraith> orion: g and h are the same type.
08:24:50 <orion> I understand f to be covariant.
08:24:53 <c_wraith> orion: f is different
08:25:18 <dolio> I think GHC can now fix them without that, too. If they take a HasCallStack, then you'd get a source location when you use them.
08:25:19 <monochrom> Too many f's.
08:25:31 <c_wraith> orion: and yes, f is the type of a covariant functor, and g/h are the type of a contravariant functor
08:25:42 <dolio> Just, none of the partial functions in the prelude do that yet.
08:25:47 <nshepperd> also, fun fact! the 'error' function appends a call stack to its exception by default now
08:26:13 <trigone> nshepperd: what does that entail?
08:26:23 <c_wraith> orion: so first, do you see why g/h are the same type?
08:26:49 <nshepperd> trigone: by default, it prints out the source location where 'error' is called
08:26:52 <dolio> I think there was some murmuring about performance somewhere, but that seems like a bad argument.
08:26:56 <tabaqui> oh, that's strange
08:27:11 <dramforever> > error "Please!"
08:27:14 <lambdabot>  *Exception: Please!
08:27:20 <trigone> nshepperd: it doesn't do it on ghci
08:27:25 <orion> c_wraith: Yes, now I do. 
08:27:26 <tabaqui> I was sure that I haven't to use identation with unless inside a monad
08:27:28 <trigone> nshepperd: but then there's no source
08:27:33 <tabaqui> like
08:27:33 <nshepperd> if you add HasCallStack as a constraint to the function that calls error, it shows where that function is called
08:27:34 <trigone> *file
08:27:39 <orion> c_wraith: They're variables, the letter doesn't matter.
08:27:44 <tabaqui> ....unless error $ do
08:27:46 <tabaqui> ....smth
08:27:49 <nshepperd> and if you add HasCallStack to *that* function, and so on
08:28:05 <c_wraith> orion: exactly. They are called "alpha equivalent" because you can rename type variables to make them the same.
08:28:07 <orion> c_wraith: I understand that a bifunctor is a type of kind * -> * -> *, covariant in both variables. A profunctor is contravariant on the left and covariant on the right.
08:28:07 <tabaqui> and I have code, that was compiled a month ago with such construction
08:28:17 <tabaqui> but no it doesn't
08:28:17 <trigone> tabaqui: error do? the list monad to write the error message?
08:28:32 <tabaqui> trigone: not a list monad, arbitrary monad
08:28:37 <tabaqui> I use it inside IO actually
08:28:41 <nshepperd> trigone: a source location is pretty useless in ghci in my experience ;)
08:28:47 <trigone> tabaqui: i thought error was String -> a
08:28:54 <tabaqui> it doesn't matter
08:28:56 <tabaqui> oh, ok
08:29:02 <orion> c_wraith: I'm reading the docs for product profunctor now. It's slightly confusing.
08:29:05 <tabaqui> unless (some check) $ do
08:29:17 <c_wraith> orion: that's correct, but it only really has a meaning to someone if you already have internalized what covariant and contravariant mean in this case
08:29:19 <trigone> nshepperd: depends, if you have a file loaded?
08:29:20 <infandum> How do I define a newtype in hint? Like, interpret "newtype blah blah" >> interpret "other stuff"
08:29:24 <tabaqui> it was a good way to skip many identations
08:29:29 <trigone> :t unless
08:29:32 <lambdabot> Applicative f => Bool -> f () -> f ()
08:29:33 <geekosaur> tabaqui, re indentation, NondecreasingIndentation became default at some point and it does change behavior in unexpected ways soemtimes
08:29:40 <geekosaur> you can try compiling with -XNoNondecreasingIndentation to see if it changes things
08:30:01 <nshepperd> trigone: this only works if you call 'error' yourself, also. the Prelude functions like 'head' don't use this technology yet
08:30:07 <trigone> tabaqui: it just looks like the negative of guard
08:30:13 <orion> c_wraith: My understanding is that in CT, you can have "co-" structures where arrows are flipped.
08:30:15 <tabaqui> geekosaur: can stack developers change default behavior?
08:30:16 <trigone> nshepperd: hm ok
08:30:26 <tabaqui> trigone: guard raise an error in IO
08:30:28 <trigone> > let f = error "Hiya" in f
08:30:29 <orion> c_wraith: So a contravariant functor would be a cofunctor.
08:30:30 <c_wraith> orion: true, but that's not quite what's going on here. :)
08:30:33 <geekosaur> tabaqui, no. ghc devs can and do
08:30:34 <lambdabot>  *Exception: Hiya
08:30:37 <dramforever> Is there a godbolt.org -like website for Haskell *core*?
08:30:42 <trigone> tabaqui: oh really? didn't know
08:30:50 <c_wraith> orion: that's not actually true.  In CT, a cofunctor is the same thing as a functor
08:30:50 <geekosaur> if you changed resolver then you may have a different ghc now
08:30:58 <orion> c_wraith: Ah, hmm
08:31:10 <tabaqui> geekosaur: yes, I did
08:31:16 <c_wraith> orion: covariant/contravariant are both just considered functors in CT
08:31:20 <dramforever> opposite category to opposite category
08:31:23 <tabaqui> ok, I'll try the extension
08:31:26 <tabaqui> thanks
08:31:26 <orion> c_wraith: I see.
08:31:46 <cocreature> dramforever: afaik there isn’t such a website. I was planning to make one at some point but I got busy with other stuff :/
08:32:06 <c_wraith> orion: Are you comfortable with regular covariant functors, like the Functor class?
08:32:39 <geekosaur> orion: functor is (a -> b) -> (f a -> f b), cofunctor is (b -> a) -> (f b -> f a), note they are alpha equivalent (since co- means swap the stuff around the arrows)
08:32:42 <orion> c_wraith: Yes. You have a "container" of type a and you want to transform the element from (a -> b)
08:32:56 <orion> geekosaur: Indeed.
08:33:25 <dramforever> oh okay
08:33:42 <orion> c_wraith: I *think* a covariant manipulates the results of computations (the "output").
08:33:55 <orion> But a contravariant manipulates the inputs.
08:33:58 <orion> IS that correct?
08:34:03 <trigone> geekosaur: is it normal your cofunctor is the same as functor just with a as b and b as a?
08:34:33 <geekosaur> trigone, that's what "swap the stuff around the arrows" means
08:34:48 <c_wraith> orion: pretty much.  For a nice concrete example, look at this:  newtype Predicate a = Predicate (a -> Bool)
08:35:03 <geekosaur> in this particular case, you get no result
08:35:05 <geekosaur> it's not generally true though
08:35:13 <geekosaur> comonad is different from monad, for instance
08:35:20 <trigone> geekosaur: hm ok get it
08:35:47 <c_wraith> orion: If you experiment with it for a while, you'll see that you can't make it an instance of Functor.  If you have a Predicate a and a function of type (a -> b), there's no way to use that function to get a Predicate b
08:36:04 <geekosaur> and iirc comonoid does something which in Haskell is pointless, but in CT which is more general does have uses (iirc the only type that can be a comonoid *in Haskell* is unit)
08:36:09 <trigone> coapplicative is also same as applicative? though copure wouldn't be like pure
08:36:09 <c_wraith> orion: I encourage you to actually give it a try.
08:37:24 <dolio> geekosaur: Every type/set is a comonoid in a unique and trivial way.
08:37:49 <orion> c_wraith: Intuitively, it doesn't compose in my head.
08:37:52 <trigone> geekosaur: is there a cojoin :: m a -> m (m a)?
08:38:03 <cocreature> trigone: it’s called "duplicate"
08:38:13 <cocreature> https://hackage.haskell.org/package/comonad-5.0.2/docs/Control-Comonad.html#v:duplicate
08:38:22 <orion> c_wraith: I am unable to conceive of a way to make (a -> b) compose with (a -> Bool).
08:39:11 <trigone> cocreature: ok :) 
08:40:21 <ertes-w> trigone: there is ComonadApply, which is a subclass of Comonad
08:40:40 <ertes-w> (i.e. the superclass relationship is inverted)
08:40:43 <dolio> geekosaur: At least, with the unit-pair monoidal structure.
08:40:43 <trigone> ertes-w: hm... Apply is like applictative withou pure?
08:40:52 <c_wraith> orion: Now consider the type of contramap from Contravariant, as specialized to Predicate:  (a -> b) -> Predicate b -> Predicate a
08:40:57 <ertes-w> trigone: it's a Comonad with (<*>)
08:40:58 <orion> c_wraith: So, that makes sense. The only way I'd be able to compose them is to have (a -> Bool) . (b -> a) -- contravariant.
08:40:59 <c_wraith> orion: can you make that type work out?
08:41:29 <trigone> ertes-w: wait are you saying that the hierarchy is reversed?
08:41:36 <trigone> for cothings
08:41:39 <phadej> ertes-w: different Apply? (apply is Applicative without pure)
08:41:41 <ertes-w> trigone: no, not fully
08:41:57 <ertes-w> phadej: yes, it's not Apply from semigroupoids, it's ComonadApply from comonad
08:42:21 <c_wraith> orion: well, there you go.  That's a a contravariant functor for you.
08:42:34 <trigone> ertes-w: so it's a bit different, it's not a clean mirroring?
08:42:42 <c_wraith> orion: in some sense, it maps in the opposite direction as a covariant functor.
08:42:51 <ertes-w> trigone: yeah…  the key observation is that you can't write (<*>) in terms of Comonad
08:42:58 <dolio> ComonadApply is just a Comonad that is also Apply.
08:43:16 <c_wraith> orion: and you can see that as happening because it's mapping "input" rather than "output", for super-imprecise definitions of "input" and "output"
08:43:17 <ertes-w> trigone: so ComonadApply is richer
08:43:31 <trigone> ertes-w: oh, wait, (<*>) as in the traditional applicative? ok, so it's a bit of both co and not-co
08:43:33 <dolio> I don't think the class even has its own methods, it's just an empty class with two constraints on it.
08:44:03 <ertes-w> dolio: it's its own class
08:44:07 <trigone> ertes-w: i guess that means it's also a functor?
08:44:32 <ertes-w> dolio: ComonadApply has stronger laws than Comonad+Apply though
08:44:33 <cocreature> it doesn’t have Apply as a superclass for some reason so it needs its own methods
08:44:50 <ertes-w> but yeah, it should be Comonad + Apply + extra laws
08:45:17 <ertes-w> trigone: since almost everything we're talking about is Functor, yeah, that is also Functor =)
08:45:38 <dolio> I guess I was looking at some other package.
08:46:10 <trigone> ertes-w: oh right, and functor and cofunctor are the same
08:46:48 <ertes-w> i don't know what a cofunctor is
08:47:19 <cocreature> the exact same thing as a functor
08:48:07 <trigone> are creatures and cocreatures different? :P
08:48:49 <cocreature> I think if I reverse all of my arrows some things change
08:48:59 <Myrl-saki> Lol
08:49:32 <Myrl-saki> Are cofunctors == functors only for endofunctors or nah?
08:50:32 * hackagebot ghc-tcplugins-extra 0.2.1 – Utilities for writing GHC type-checker plugins – https://hackage.haskell.org/package/ghc-tcplugins-extra
08:50:32 * hackagebot inline-c-cpp 0.2.1.0 – Lets you embed C++ code into Haskell. – https://hackage.haskell.org/package/inline-c-cpp
08:50:39 <cocreature> Myrl-saki: no that holds in general
08:51:26 <trigone> apparently there's a bit of terminological issue: cofunctor seems to mean very often contravariant functor, which is apparently different from "cofunctor" in the same meaning as "comonad" (but then i know nothing of contravariant or comonad)
08:51:55 <cocreature> I’ve never heard anybody refer to contravariant functors as cofunctors
08:52:48 <trigone> well google says so, not me
08:52:56 <cocreature> stupid google
08:53:03 <trigone> https://en.wiktionary.org/wiki/cofunctor
08:53:11 <Myrl-saki> cocreature: The only time I've heard anyone use cofunctors as contravariant functors is when people say it's sometimes used to refer to contravariant functors. :D
08:53:16 <trigone> actually it's wiki
08:53:38 <cocreature> I’m not sure I trust wiktionary when it comes to category theory terminology
08:53:43 <mnoonan> MacLane says no, so.. https://math.stackexchange.com/questions/394472/is-cofunctor-an-accepted-term-for-contravariant-functors
08:53:52 <trigone> cocreature: lool why not? you surprise me
08:54:24 <cocreature> funnily enough, the wikipedia reference on wiktionary redirects to the page for functors :)
08:54:44 <trigone> still i wonder who bothers to write CT definitions when they're not specialists enough to not make mistakes...
08:55:05 <orion> c_wraith: Ok, are these statements correct?: A mapping function f is of type (a -> b). If you "unwrap" a Functor you have a "a", and if you "unwrap" a Contravariant you have a "b". In a covariant, you do (mapping function) . (unwraped data structure). In a contravariant you do (unwrapped data structure) . (mapping function).
08:55:21 <Myrl-saki> mnoonan: But the fact that it exists means that some people (wrongly) do use it as such. :P
08:55:35 <mnoonan> it's actually not so uncommon to see "cofunctor" to mean contravariant functor, but I think it should be read as an abbreviation rather than a \idea -> co-idea application
08:56:08 <mnoonan> here's a random example from an algebraic topology conference, for example: https://books.google.com/books?id=UK17CwAAQBAJ&pg=PA113&lpg=PA113&dq=cofunctor+mac-lane&source=bl&ots=A94ER5pEu-&sig=rkgfRq3AzIatprYiGcPGmJzRfvY&hl=en&sa=X&ved=0ahUKEwiryenSzNnVAhXCVyYKHVweDwkQ6AEIOjAD#v=onepage&q=cofunctor%20mac-lane&f=false
08:58:54 <orion> Does anyone else agree with the statements I directed at c_wraith?
09:00:03 <cocreature> orion: I’m not sure what unwrapping is supposed to mean here
09:00:13 <eschnett> orion: isn’t it the other way around with a and b? (a -> b) is a functor in b.
09:00:38 <orion> "unwrapping" means pattern matching on the datastructure to reveal what's inside.
09:00:50 <wolfcub> so when im trying to do 'stack build' and it complains theres a missing c library, where should i install this c library?
09:00:52 <cocreature> how do you pattern match on a Proxy to reveal what’s inside?
09:01:01 <cocreature> how do you pattern match on a Cont to reveal what’s inside?
09:01:10 <wolfcub> on windows btw, tried copying the dlls to a folder in path but still complains
09:01:18 <Myrl-saki> What does co* mean again?
09:01:58 <mnoonan> wolfcub, you can put extra-libraries and extra-lib-dirs in your .cabal file
09:02:25 <wolfcub> i put the path to the dlls there?
09:03:14 <mnoonan> I've never tried on windows, but I assume you'd do something like put the path in extra-lib-dirs and put the dll name in extra-libraries.
09:03:46 <ertes-w> orion: your wording makes assumptions on the nature of the functors in question, but in general goes in the right direction
09:03:51 <orion> cocreature: When I say "unwrap" I mean fmap f (Just a) = Just (f a). "Unwrapping" the Just.
09:04:03 <wolfcub> i see, thanks
09:04:16 <orion> "Peeking" inside the Just.
09:04:20 <cocreature> orion: so how do you “unwrap” Nothing?
09:04:29 <orion> err
09:04:32 <orion> Sorry, unwrapping the Maybe
09:04:36 <Myrl-saki> Is co* just literally reversing all arrows?
09:04:44 <orion> Peeking inside the Maybe to reveal a Just a or Nothing.
09:04:55 <orion> The terminology is poor.
09:04:58 <cocreature> orion: I think I get what you mean but the wrapping/unwrapping analogy just falls down very quickly for more complex functors
09:05:00 <ertes-w> orion: very poor
09:05:21 <ongy> Maybe isn't that complex, and I'd say it even fails fro maybe (unwrapping Nothing)
09:05:33 <geekosaur> Myrl-saki, yes
09:05:34 <ertes-w> orion: i would say: "covariant functor is to post-application what contravariant functor is to preapplication"
09:05:58 <cocreature> Myrl-saki: iirc cfwm has a pretty good rigorous definition of duality that’s quite understandable even if you don’t know a lot of category theory
09:06:13 <Myrl-saki> cfwm?
09:06:24 <cocreature> categories for the working mathematician
09:06:27 <tsahyt> Is there some prior art on how serialization is dual to parsing, i.e. functors in parsing types become contravariants in serialization, applicative becomes divisible, etc?
09:06:33 <Myrl-saki> And I'd say I understand a lot of Category Theory(for Haskell)
09:06:42 <tsahyt> I doubt that I'm the first person to discover this
09:06:47 <ertes-w> orion: in other words: Functor is a generalisation of (\f -> (f .)), whereas Contravariant is a generalisation of (\f -> (. f))
09:06:51 <Myrl-saki> Except duality. Lmao
09:07:10 <cocreature> there is a difference between understanding the category theory you see in Haskell and fully grasping it on a mathematical level :)
09:07:22 <Myrl-saki> cocreature: Exactly why I added a (for Haskell) :P
09:07:25 <orion> ertes-w: Makes sense. What do you think of this intuition? (something for which I don't have a good word) . (mapping function) == contravariant, and the reverse is covariant.
09:07:46 <Myrl-saki> cocreature: I read nLab from time to time, but a lot of things just doesn't fit. Yet.
09:07:57 <Myrl-saki> cocreature: I'm trying and I'm sure I'll get there!
09:08:13 <mnoonan> is there an intuitive explanation that is better than "covariant :: (a -> b) -> (f a -> f b)", "contravariant :: (a -> b) -> (f b -> f a)"?
09:08:14 <ertes-w> orion: sounds like just a much more awkwardly worded version of what i said =)
09:08:17 <CuriousErnestBro> hi!
09:08:22 <orion> ertes-w: Indeed. :)
09:08:35 <cocreature> Myrl-saki: nlab is very good at confusing the shit out of me and I like to believe that I actually know a reasonable amount of ct even on a mathematical level :)
09:08:41 <ertes-w> orion: try not to use symbols, if you're not going to define them rigorously
09:08:52 <CuriousErnestBro> should one follow this course (instead of reading a book, I don't like books unless I'm somewhat versed in the topic)? https://www.futurelearn.com/courses/functional-programming-haskell
09:08:59 <orion> ertes-w: I appreciate the suggestion.
09:08:59 <CuriousErnestBro> don't mind the cheeky instructors 
09:09:50 <Myrl-saki> cocreature: Should I check out cfwm? I'm not looking for intuition but for rigurous definitions, most preferrably symbolic.
09:10:29 <cocreature> Myrl-saki: if you really want to get into category theory then go for it. although don’t be discouraged if things seem very confusing at first.
09:10:47 <cocreature> Myrl-saki: personally I prefered awodey’s book on category theory
09:11:12 <ertes-w> CuriousErnestBro: looks like a course i might like
09:11:38 <ertes-w> CuriousErnestBro: but hard to tell without actually watching/visiting a lecture, and i can't do that right now =)
09:12:05 <Myrl-saki> cocreature: This reminds me that it took me 3 tries to get into Haskell, now I exclusively use it for like 2-3 years.
09:12:20 <cocreature> Myrl-saki: I think I only made it through awodey’s book on my third attempt :)
09:13:20 * hackagebot servant-websockets 1.0.0 – Small library providing WebSocket endpoints for servant. – https://hackage.haskell.org/package/servant-websockets
09:13:31 <ertes-w> CuriousErnestBro: if in doubt try the following, but this is in no way a comparison to the UoG course: https://www.cis.upenn.edu/~cis194/fall16/
09:13:46 <ertes-w> CuriousErnestBro: if you're still uncertain, just try it…  or flip a coin
09:14:49 <platz> is there an "aeson" for xml?
09:15:19 <platz> that uses e.g. applicative style encoder/decoder instances
09:15:37 <CuriousErnestBro> ertes-w, hmm the choice between the uni that made the REPL thingy vs an ivy league uni
09:21:28 <dsal> OK.  I have something that's really breaking my brain.
09:22:11 <dsal> This code:  http://lpaste.net/357722
09:22:37 <dsal> At minDur = 200, it does what I expect.  If I set minDur to something more useful (like 2), it seems to never be trailing ehind.
09:22:52 <dsal> e.g.,   At 200, I get trace entries like this:  head diff = 180.84s first was 180.84s
09:23:12 <dsal> At 20, they all look like this:  head diff = 0.7s first was 0.7s
09:25:18 <dsal> What kind of confusion have I caused for myself?  Fundamentally, I'd expect the accumulator in the mapAccumL to be the same as the input, trailing behind the original log by minDur seconds, regardless of the value of minDur.  I get fine results at 200, but that's a uselessly large value.
09:26:15 <dsal> I also tried minimizing the problem to see if I could even compare times that small.  Doesn't seem to be an issue: http://lpaste.net/357723
09:36:50 <c_wraith> orion, oh. I responded, but apparently my response was eaten by flaky internet. 
09:38:00 <c_wraith> orion, I disagree with your characterization. it's more complex than just function composition. 
09:38:51 <c_wraith> orion, newtype F r a = F ((a -> r) -> r) 
09:39:14 <c_wraith> orion, is that covariant or contravariant? 
09:40:38 <c_wraith> orion, what about newtype G r a = G (((a -> r) -> r) ->) 
09:46:21 <orion> ertes-w: /redraw
09:46:30 <orion> oops
09:46:42 <orion> c_wraith: ertes-w and I worked it out.
09:47:01 <orion> c_wraith: 12:06:27 < ertes-w> orion: in other words: Functor is a generalisation of (\f -> (f .)), whereas Contravariant is a generalisation of (\f -> (. f))
09:47:09 <orion> That was the light-blub moment for me.
09:49:15 * byorgey . o O ( "How many Lisp programmers does it take to change a light-blub?" )
09:50:08 <kuribas> how many?
09:51:54 <Aruro> how to solve expected T.Text vs Data.Text.Internal.Lazy compiler error?
09:52:22 <byorgey> It's a trick question, Lisp programmers will never change their light-blub
09:53:14 <byorgey> http://www.paulgraham.com/avg.html
09:53:26 <Aruro> im using Text.HTML.Parse, everything works untill i try to use replace from Data.Text
09:53:49 <Aruro> thats when scary Text error pops up
09:54:40 <Aruro> can not match T.Text with Data.Text.Internal.Lazy.Text
09:55:37 <byorgey> Aruro: the Text package exports two types named 'Text', one lazy and one strict
09:55:53 <byorgey> the one you get by default from Data.Text is the strict one.
09:56:05 <byorgey> the other one is what you get if you import Data.Text.Lazy instead.
09:56:53 <byorgey> Aruro: apparently you have some library that is using one of them, and you are using the other.
09:57:10 <Aruro> yeah, thank u. i imported both modules now and changed replace function to lazy
09:57:15 <dsal> Clearly something is broken in the time conversion.
09:57:20 <byorgey> yeah, something like that should do it.
09:57:36 <Aruro> byorgey: btw package is html-parse from Ben
09:58:10 <Aruro> he hase two functions parseTokens and parseTokens lazy i use first ,but seems there is something behind curtains
09:58:23 <Aruro> parseTokensLazy*
09:58:48 <Aruro> working with Text in prelude is pain :D
10:01:24 <dsal> OK.  WOO.  Bad time format.
10:01:43 <Aruro> i tried to work with html using hxt but that got too complicated too fast
10:01:50 <Aruro> :(
10:03:51 <ertes-w> Aruro: are you trying to read, write or transform HTML?
10:04:06 <Aruro> i try to extract parts of haddock htmls
10:04:14 <Aruro> to have console docs (or emacs)
10:04:23 <Psybur> Anybody know of a good frp framework that works with haskell 8?
10:04:36 <ertes-w> Aruro: i believe that haddock has output formats other than HTML
10:04:57 <ertes-w> Psybur: reactive-banana, reflex
10:05:12 <Aruro> ertes-w: yes but haddock html is not computer friendly enough :) they do have anchors which is nice and class annotations
10:05:59 <Psybur> Hmm stack install reflex complains that all my versions of things are too far ahead. Guess thats a stack config issue then if you say it works with 8
10:07:46 <ertes-w> Psybur: the most common way to work with reflex is to use nix instead of stack, optionally using ryan trinkle's modified haskell package set that is tailored to reflex
10:09:29 <ertes-w> Psybur: here is one possible entry point, but it's very specific to reflex-dom and GHCJS usage: https://github.com/reflex-frp/reflex-platform
10:10:54 <dsal> How would one go about removing items from a list based on nearby items?  (e.g., duplicates)  Would that makes sense as a foldl?
10:11:41 <dsal> foldl + dropWhile seems sort of natural.
10:13:39 <Psybur> nub or nubBy?
10:15:57 <dsal> It's not a set thing, so order matters.  My logs have GPS positions, but when those positions are duplicated, they're often incorrect -- at the very least, not useful for computing speed.
10:16:04 <dsal> (pretty sure I didn't hit 400kph in this plane)
10:16:11 <cocreature> dsal: manual recursion is probably the easiest solution. foldl would probably work but foldl doesn’t work on infinite lists. foldr works on infinite lists but it doesn’t quite fit the foldr pattern
10:16:17 <cocreature> easiest + most efficient
10:18:29 <cocreature> Psybur: if you give us the exact error message stack is showing you and show us your stack.yaml, we might be able to help you
10:19:21 <Psybur> cocreature, https://pastebin.com/DnTnyMdM
10:20:18 <dsal> cocreature: thanks.  makes sense.  I hope my logs aren't infinite, but actually, for this app, I've already got a "prune" function that's trimming entries.  It might be a natural place to add a dropWhile.
10:20:34 <dsal> hmm... except that might take me into the future.  That'd be inconvenient.
10:21:21 <cocreature> Psybur: looks like you are going to need to use reflex from the master branch. there is no hackage release supporting base 4.9. see https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location to learn how you can tell stack to fetch packages from git repos
10:22:19 <Psybur> cocreature, thanks will check
10:23:09 <Psybur> dsal, so you dont want to remove duplicates completely, but want to keep 1 and remove the rest in a set?
10:23:12 <Psybur> And maintain order?
10:23:43 <dsal> Yeah.  If a particular field isn't changing, it's either because I'm not moving, or because the GPS is broken, so I just want to ignore those records.
10:24:31 <Psybur> So you maybe want to also build up a set of unique entries as you go, and then try to add the current element to the set. if it gets added, its unique and keep it. if it doesnt get added then discard it?
10:25:21 <dsal> I don't care about unique entries, just don't want to add a value if a particular field has the same value as the previous entry.
10:25:33 <Psybur> Just the previous ok gotcha
10:26:35 <Psybur> And if there is three in a row, only keep first?
10:26:38 <dsal> Right.
10:26:49 <Aruro> ertes-w: seems that haddock supports only html , and experimental latex
10:28:36 <Aruro> a bit strange choice considering all the folks are in emacs vim
10:31:37 <Psybur> dsal, what about something like this https://pastebin.com/6WyZL11e
10:32:08 <dsal> Huh.  That's kind of neat.
10:34:08 <Psybur> Dont know which is better that or map head . L.group $ [1,1,2,1,2,2,2,3,4]
10:34:34 <Psybur> Anybody know if that or if this is "better"? map head $ L.group [1,1,2,1,2,2,2,3,4]
10:34:46 <dsal> head . L.group seems like it'd produce less waste.
10:35:35 <Psybur> Yeah I think it would make less traversals?
10:35:46 <ertes-w> :t flip (foldr (\x go xs -> if S.member x xs then go xs else x : go (S.insert x xs)) (const [])) mempty
10:35:48 <lambdabot> (Ord a, Foldable t) => t a -> [a]
10:36:02 <ertes-w> @let nub' = flip (foldr (\x go xs -> if S.member x xs then go xs else x : go (S.insert x xs)) (const [])) mempty
10:36:04 <lambdabot>  Defined.
10:36:05 <dsal> sufficiently smart compiler™
10:36:35 <ertes-w> > nub' ([1,2,3,3,2,1,4,1,5] ++ [6..])
10:36:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:37:12 <ertes-w> any manual list recursion should be encodable as a fold
10:37:31 <Psybur> ertes-w, I dont think he wanted to remove duplicates in general, just duplicates grouped together
10:37:41 <ertes-w> you can do that with foldr
10:37:48 <dsal> Yeah, I was originally thinking fold + dropWhile
10:37:53 <dsal> I don't think I understand foldr
10:39:00 <dsal> I should try that just because of all the things discussed so far, I understand it the least.  :)
10:39:28 <dmwit> `map head . group` seems the cleanest and simplest to me, given the requirements.
10:39:53 <ertes-w> :t let squeeze [] = []; squeeze (x0:xs0) = x0 : foldr (\x go x' -> if x == x' then go x' else x : go x) (const []) xs0 x0 in squeeze
10:39:55 <lambdabot> Eq t => [t] -> [t]
10:39:57 <dsal> I'm passing too much junk around, though and/or duplicating code to avoid passing more junk around.
10:40:00 <ertes-w> @let squeeze [] = []; squeeze (x0:xs0) = x0 : foldr (\x go x' -> if x == x' then go x' else x : go x) (const []) xs0 x0
10:40:03 <lambdabot>  Defined.
10:40:12 <ertes-w> > squeeze "abbbcdeeeeeeeffgh"
10:40:14 <lambdabot>  "abcdefgh"
10:40:18 <ertes-w> > squeeze [1..]
10:40:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:41:09 <ertes-w> dsal: i have a massive foldr tutorial, if you want to learn it =)
10:41:22 <ertes-w> dsal: http://ertes.eu/tutorial/foldr.html
10:41:35 <dsal> Thanks.  This is helpful.
10:42:09 <Aruro> i dont think foldr code is good for interhuman communication
10:42:19 <Aruro> too complex
10:42:44 <Psybur> Does the lambdabot do speed tests? :D
10:43:33 <geekosaur> speed tests on a low-cost virtual instance seems like bad pan
10:43:35 <geekosaur> *bad plan
10:43:44 <dsal> I need to learn some quickcheck, too.  The one useful bit of quickcheck in go was if you write two functions that you think do the same thing, it'll tell you if it spots a case where they give different results.
10:43:50 <ertes-w> Aruro: foldr is a pattern, and you just need to train yourself to recognise it
10:44:13 <dsal> foldl makes plenty of sense to me.  I can't imagine foldr is a huge leap from there.
10:44:35 <ertes-w> dsal: it's a huge leap…  in particular foldl is a special case of foldr
10:45:10 <nshepperd_> When i understood how the implementation of foldl' in terms of foldr worked, i felt like a whole new world opened to me :)
10:45:14 <ertes-w> dsal: but it's not just a leap in expressivity, but a conceptual leap, too…  foldr is an example of what is known as a catamorphism, so you can generalise it
10:45:59 <ertes-w> dsal: going from foldl to foldr is like going from (ℤ, +, 0) to groupoids =)
10:46:23 <dsal> haha . I'm not a mathematician, so I'd be lost long before I got to the starting point.
10:46:59 <Aruro> ertes-w: why foldl and foldr mathematically different? seems unplausible
10:47:18 <ertes-w> dsal: while the term "catamorphism" is from mathematics, the concept is a very practical one…  it all boils down to recursive algorithms on data structures, and how to tie the recursive knot
10:47:26 <Unode> I'm trying to use `stack script` or `stack runghc` to run a file of haskell as a script. It tries to import code that lives in a subdirectory (./MYApp) and a stack.yaml file exists at ./ . Does anyone know how I can tell stack to include this directory in the list of locations to look for packages/modules?
10:47:32 <ertes-w> Aruro: foldl is a special case of foldr, and foldr is strictly more expressive
10:48:02 <cocreature> protip: manual recursion is also very expressive
10:48:36 <Aruro> ertes-w: i dont see why? isnt foldr a special case of foldl too? :)
10:48:56 <ertes-w> Aruro: here is a fold that you can't express in terms of foldl:
10:49:00 <ertes-w> :t foldr (:) []
10:49:01 <lambdabot> Foldable t => t a -> [a]
10:49:40 <Aruro> ertes-w: its haskell problem, mathematically they should be same
10:49:53 <Aruro> hence my question, why the preference
10:49:53 <ertes-w> cocreature: manual recursion has a few drawbacks: it's ad-hoc, so it's harder to see the pattern (it's the difficulty of reading for-loops translated to reading recursion), and also it doesn't fuse =)
10:49:54 <Psybur> Does foldr start at the end of a list, which means the list has to be traversed first to get that element?
10:50:10 <ertes-w> Aruro: they aren't the same mathematically
10:50:18 <cocreature> ertes-w: sry, you’re not going to convince me that rewriting everything in terms of foldr is a good idea :)
10:50:19 <ertes-w> Aruro: why do you think they are the same?
10:50:39 <Aruro> because definition seems symmetrical
10:50:40 <nshepperd_> Aruro: it's not quite the same, because foldl has to iterate to the end of the list always. This means that foldl has no result on any infinite list
10:50:50 <ertes-w> Psybur: no, all folds go from left to right
10:51:10 <ertes-w> Psybur: the "r" in foldr is related to the associativity
10:51:36 <ertes-w> Aruro: really?  the types are isomorphic, but the definitions are very different =)
10:51:58 <Aruro> so its all about semantics, i dont think cathegory theory cares about that
10:52:13 <Aruro> does it?
10:52:17 <nshepperd_> foldr can also handle lists like 1:2:undefined which foldl can't
10:52:28 <ertes-w> it can care about it, but CT represents semantics in terms of relations (morphisms)
10:52:32 <dsal> What is 1:2:undefined ?
10:52:55 <ertes-w> dsal: it's the list [1, 2, BOOM
10:53:03 <ertes-w> > 1 : 2 : undefined
10:53:06 <lambdabot>  [1,2*Exception: Prelude.undefined
10:53:18 <dsal> ah
10:53:19 <ongy> :t 1 : 2 : undefined
10:53:21 <lambdabot> Num a => [a]
10:53:29 <Aruro> btw all folds in prelude writted using foldr
10:53:37 <geekosaur> dsal, the point there is foldr can stop before hitting the undefined, foldr can't
10:53:37 <geekosaur> er, foldl can't
10:53:53 <geekosaur> it depends on the predicate you give it, in the case of foldr
10:53:54 <dsal> Yeah.  I inferred that.  :)
10:54:20 <dsal> Definitely going to foldr for this just so I have some idea what this means.
10:54:39 <nshepperd_> If to talk about how foldr and foldl are "mathematically" the same or different I would use denotational semantics. And there they are different because of bottoms and infinite lists
10:54:51 <Aruro> dsal: btw group does not use folds :) its manual
10:55:21 <dsal> Sure.  I don't think it's hard to use group, or do this completely manually or whatever.  I'm just learning stuff right now.
10:55:22 <ertes-w> they are different for the same reason (+) and (-) on Integer are different =)
10:55:51 <ertes-w> well, perhaps a better example would be how (^) and (^^) are different
10:55:57 <Aruro> lists can be infinte in both directions
10:56:09 <dsal> Can I write  [..6]  ?
10:56:10 <ertes-w> they look similar, but (^) is strictly less expressive
10:56:16 <ertes-w> dsal: what would that mean?
10:56:21 <dsal> I want a list of all numbers up to 6.
10:56:33 <ertes-w> dsal: a list can be in exactly two forms
10:56:47 <ertes-w> dsal: either it's [], or it's (x : xs), where x is the head element, and xs is the remaining list
10:57:00 <dsal> Oh.  Lame.
10:57:08 <dsal> I want left infinity.
10:57:13 <dsal> I guess I can just reverse [6..]
10:57:32 <ertes-w> dsal: what would you expect as the result?  (x : xs), where x = ?
10:57:52 <nshepperd_> Aruro: right. I assumed we are talking about the definition on haskell lists
10:57:57 <ertes-w> dsal: *all* lists are of one of those two forms, including the result of 'reverse' =)
10:57:59 <dsal> I'm not asking for anything reasonable.
10:58:31 <nshepperd_> Aruro: if it's snoc lists, well, they are still different but it's the other way around because you have renamed left and right
10:58:54 <Aruro> would be interesting to see situation where foldr is same as foldr
10:58:56 <ertes-w> dsal: since you can't start from infinity, what you really want is [6, 5, ..]
10:59:12 <orion> What is the difference between a profunctor and a product profunctor?
10:59:23 <ertes-w> dsal: remember that lists are sequences, not sets…  they need a starting point and an iteration rule
10:59:46 <dsal> ertes-w: I was mostly trolling (re: lists infinite in both ways).  I was thinking about that yesterday, though.  The (x:xs) thing really clears it up, though.  It's just cons
11:00:02 <Aruro> i dont like lists.
11:00:03 <Psybur> > take 10 [6,5,..]
11:00:07 <lambdabot>  <hint>:1:14: error: parse error on input ‘..’
11:00:17 <ertes-w> oh yeah, lose the second comma =)
11:00:23 <nshepperd_> Aruro: for the strict structures like arrays foldl and foldr are basically equivalent. They just associate different ways in the array elements
11:00:28 <Psybur> > take 10 [6,5..]
11:00:32 <lambdabot>  [6,5,4,3,2,1,0,-1,-2,-3]
11:00:46 <nshepperd_> Or data. sequence
11:01:10 <ertes-w> dsal: another useful perspective is: all computable lists can be represented in terms of unfoldr
11:01:39 <ertes-w> (lists might come from "outside" and be non-computable, but all lists that the program itself computes can be represented in terms of unfoldr)
11:01:51 <dsal> I'm unfamiliar with unfold* as well.  Neat.
11:02:03 <Aruro> it generates list
11:02:12 <Aruro> from seed
11:02:35 <ertes-w> unfoldr is the epitome of stateful sequences =)
11:09:13 <nshepperd_> dsal: you *can* define a list type where the recursion goes the "other way". They're called snoc lists https://mail.haskell.org/pipermail/haskell-cafe/2007-July/029485.html
11:09:54 <nshepperd_> snoc = backwards cons
11:10:58 <nshepperd_> Anyway, it's just the same as a normal list, but you imagine the list growing to the left instead of the right :p
11:12:39 <nshepperd_> Nil :> 1 :> 2 :> 3
11:23:23 <prietoj> Hello! I was wondering what's the idiomatic way of using lenses conditionally (i.e. modifying a value in a given path only if the value in another path satisfies certain condition)
11:27:50 <Aruro> btw probably there are also bidirectional lists where (:) adds elements from both sides :)
11:28:12 <Akii> anyone has an idea how to add a request header to servant client?
11:30:02 <cocreature> Akii: afaik you should just use https://hackage.haskell.org/package/servant-0.11/docs/Servant-API-Header.html#t:Header in your api endpoint and then you have to pass an additional argument representing the header
11:30:05 <phadej> Akii: http://haskell-servant.readthedocs.io/en/stable/tutorial/ApiType.html#request-headers
11:30:13 <phadej> cocreature: +1
11:31:00 <Akii> thanks!
11:37:43 <ertes-w> prietoj: lenses can be multi-"path", but the paths are isolated from each other…  however, you can use something like 'filtered'
11:38:13 <ertes-w> > (traverse . filtered even *~ 10) [1..]
11:38:17 <lambdabot>  [1,20,3,40,5,60,7,80,9,100,11,120,13,140,15,160,17,180,19,200,21,220,23,240,...
11:39:10 <ertes-w> prietoj: well, i messed up terminology…  traversals focus on arbitrarily many points…  lenses are traversals that focus exactly one point
11:39:58 <ertes-w> prietoj: now within the predicate of 'filtered' you could use another lens/traversal
11:41:11 <prietoj> Ah, makes sense. I'll give it a try, thanks!
11:41:28 <ertes-w> > (traverse . filtered (even . view _1) . _2 . traverse %~ toUpper) (zip [1..] ["abc", "def", "ghi", "jkl", "mno"])
11:41:31 <lambdabot>  [(1,"abc"),(2,"DEF"),(3,"ghi"),(4,"JKL"),(5,"mno")]
11:41:39 <ertes-w> prietoj: example ^
11:42:19 <prietoj> Great!
11:46:59 <Akii> cocreature, phadej: that was exactly it xD Was away too long from Haskell again
11:47:19 <ahihi> is there some tool for monitoring thread creation/destruction in a haskell program?
11:47:19 <Akii> love how servant forces you to encode request headers into your apis
11:47:47 <geekosaur> ahihi, ThreadScope? btu building it can be painful on some platforms I gather
11:48:59 <ahihi> geekosaur: I will have a look, thanks :)
11:55:00 <kgadek> hi all. I'm using lens' makeFields, but that forces me into single module (otherwise I get name lash of classes). Any clever way around it?
12:17:19 <jmnoz> has anyone managed to use snap with stackage lts-9.0 or latest nightly?
12:19:58 <dsal> Is it possible to give a function type a name?  This is getting a little unwieldy:  prune :: TimeZone -> (String -> (V.Vector String) -> String) -> [V.Vector String] -> (V.Vector String) -> UTCTime -> [V.Vector String]
12:20:22 <dsal> eg. (String -> (V.Vector String) -> String) could be named "FieldLookup" or something.
12:20:24 <byorgey> dsal: sure
12:20:36 <byorgey> type FieldLookup = String -> V.Vector String -> String
12:20:59 <dsal> Well that seems obvious.
12:21:01 <Tuplanolla> A question, especially for Logio: is there a mechanism for choosing a normal for a vector, which deliberately and, in some sense, canonically breaks the symmetry of the perpendicular subspace? I feel geometric algebra could help me out here.
12:21:01 <byorgey> dsal: though that is probably only worthwhile if you use that function type a lot
12:21:20 <dsal> It's in a couple places.  I'll see if it clarifies things.
12:21:55 <byorgey> dsal: you can give any type a name.  Function types are just types.
12:22:06 <dsal> Yeah, makes sense.
12:24:27 <supercynic> dsal: keep in mind that type aliases can make code harder to read, depending on the situation…  instead of seeing the actual type, now you need to look up aliases
12:24:45 <supercynic> map :: MappingFunction a b -> ListMappingFunction a b
12:26:29 <dsal> Yeah, I would assume so.
12:39:31 * hackagebot mikrokosmos 0.6.0 – Lambda calculus interpreter – https://hackage.haskell.org/package/mikrokosmos
12:47:09 <Tuplanolla> Ping for edwardk, our other geometric algebra wizard, as well.
12:49:14 <mnoonan> Tuplanolla, what do you mean exactly re: breaking the symmetry?
12:51:07 <Tuplanolla> Take our three-dimensional space for example, mnoonan. If you want to find a normal for a vector, you have an infinite number of options to choose from, each one as good as the next.
12:52:03 <mnoonan> it sounds like you might be after an almost-complex structure
12:53:04 <mnoonan> take your 2n-dimensional space, identify a mutually orthogonal set of n 2-planes, and do a 90-degree rotation in each 2-plane
12:54:04 * hackagebot wrecker 1.0.0.1 – An HTTP Performance Benchmarker – https://hackage.haskell.org/package/wrecker
12:54:04 * hackagebot wrecker 1.0.0 – An HTTP Performance Benchmarker – https://hackage.haskell.org/package/wrecker
12:54:20 <Tuplanolla> One practical solution is to calculate the inner product of the vector and all of the basis vectors, reject the smallest result, use the rest to form a perpendicular vector and normalize it.
12:54:20 <dolio> Heh.
12:55:45 <sm> heh, great package name
12:56:06 <supercynic> Tuplanolla: would *any* normal be good enough?
12:56:41 <mnoonan> Tuplanolla, do you want this to (1) work in odd dimensional spaces too, or (2) be continuous?
12:56:59 <Tuplanolla> Can I have both, mnoonan?
12:57:06 <mnoonan> sorry, no :)
12:57:26 <mnoonan> "hairy ball theorem"
12:57:41 <Tuplanolla> Oh, huh.
12:58:15 <mnoonan> take the outer normal field on the unit sphere, and use your process.. you'll get a nonvanishing tangent field, which is impossible on even-dimensional spheres
12:59:34 <Logio> Tuplanolla: well, if you deal in geometric algebra, you can just define the "normal" as the hodge dual of the vector
13:00:03 <Tuplanolla> Is this the star of the wedges thing, Logio?
13:00:34 <Logio> yeah, but it's basically just the basis of the orthogonal subspace wedged together
13:02:00 <minn> Is there a standard library for conversion between ByteString and numeric types (in different bases). In particular, an implementation of Numeric.readInt for ByteString?
13:04:05 <Logio> Tuplanolla: what are you trying to achieve that requires a normal for a vector?
13:04:58 <Tuplanolla> Choosing a local coordinate system for a colliding pair of particles, Logio.
13:05:17 <mnoonan> wait, in physical space or in phase space?
13:05:38 <Tuplanolla> Real space, mnoonan.
13:06:15 <Logio> Tuplanolla: I would think the particle physicists have a book listing each sensible coordinate system for any combination of particles by now
13:06:36 <mnoonan> too bad, phase space gets an almost-complex structure for free
13:06:40 * supercynic is imagining a page full of equations for doing it in phase space
13:08:00 <Tuplanolla> That's a good idea, except for the having to do a literature review part, Logio.
13:09:51 <mnoonan> Tuplanolla, if you have colliding particles, why not use the normal to the plane they are traveling in?
13:10:33 <Tuplanolla> If they happen to stop while in contact, the plane vanishes, mnoonan.
13:11:33 * hackagebot parsers 0.12.7 – Parsing combinators – https://hackage.haskell.org/package/parsers
13:16:47 <hc> hi everyone!
13:17:17 <hc> I was looking for an API to send apple push notifications using the new HTTP2 API, but to no avail, so I started to work on my own. https://github.com/hce/apn still very early stage. testers and contributions welcome :-)
13:25:57 <sm> sounds cool hc. What does it do ?
13:27:07 <Tuplanolla> I guess the next best thing is finding definitions that are easy to compute or only have a single lick, mnoonan. Someone else must have done the hard work by now.
13:28:56 <u0_a153> hi
13:29:36 <l30nch0l0> yo?
13:29:49 <hc> sm: so far, it can send push notifications using text or badge infos, using a resource pool to share a connection
13:31:48 <sm> hc: does it mean I can use your apn lib/tool to push an IOS-style notification to my iphone ?
13:32:06 <sm> as you can tell I have not idea what's going on :)
13:38:14 <trigone> hi, i'm reading parallelism and concurrency in haskell, and i got trouble understanding something, wrt rpar/rseq/rparWith. is there someone that could help me with that?
13:38:31 <cocreature> trigone: asking your actual question usually works better
13:42:01 <trigone> cocreature: well, first, why the need for rparWith? what's the difference bwn `startegyFoo` and `rparWith strategyFoo`?
13:43:01 <kgadek> hi all. I'm using lens' makeFields, but that forces me into single module (otherwise I get name lash of classes). Any clever way around it?
13:43:44 <trigone> hackage describes it as meaning rparWith foo = rpar `dot` foo = rpar . withStrategy foo (withStrategy being flip using
13:44:07 <trigone> but i don't get the point of using rpar after having used foo already
13:45:23 <trigone> apparently rparWith foo x = rpar (x `using` foo) --even if the actual source is much more complicated, and i didn't get it
13:45:56 <trigone> oh wait maybe i get it
13:47:33 <trigone> ok no i don't... rparWith foo x = rpar (runEval (foo x)). why the need to call rpar over the result of runEval?
13:48:39 <jared-w> kgadek: using template haskell across modules is bad juju, generally speaking
13:49:25 <kgadek> jared-w: though I appreciate that I don't have to write all those `HasX`, `HasY` instances by hand
13:49:42 <trigone> why not just write (foo x)?
13:49:54 <jared-w> oh for sure. It's probably just better to use the lens' makeFields in a single module :)
13:50:12 <jared-w> I think several projects tend to have a lens module that they use specifically for that reason? Not quite sure
13:52:05 <rntz> in haskell, can you define the fixity of a constructor?
13:52:11 <rntz> (if that constructor is an infix operator)
13:52:39 <hc> sm: yes it does, but you need to write your own app and a developer acconut
13:52:41 <trigone> cocreature: so, can you help me understand this?
13:53:48 <hc> sm: see also https://developer.apple.com/notifications/
13:56:09 <jared-w> rntz: yes. See "infixr" and "infixl"
13:56:21 <jared-w> also "infix" for non-associativity
13:56:41 <rntz> I ask because when I try to use "infix" haskell says "The fixity signature for # lacks an accompanying binding"
13:56:54 <rntz> I have:
13:56:55 <rntz> infixr 4 #
13:56:55 <rntz> data Seq a = (#) a (Seq a)
13:57:08 <jared-w> Hmm... # is not allowed as a symbol, I believe. That could be your issue
13:57:21 <trigone> rntz: i think infix constructors must start with `:`
13:57:50 <rntz> ah, I see.
14:00:45 <jared-w> There are infix data constructors which must start with :
14:01:05 <jared-w> you can also write infix type constructors with the TypeOperators extension
14:01:13 <sm> hc: I see. Thanks
14:01:22 <jared-w> infix operators are a different thing altogether
14:02:12 <jared-w> An infix operator is just a normal function whose name consists entirely of symbols: (++) is an example (the entire lens library is another example :p)
14:04:37 <boj> "the entire lens library" lol
14:07:32 <jared-w> I mean, I'm being slightly hyperbolic...
14:11:52 <boj> i wonder what the total ratio of haskell infix operators to edwardk libraries is
14:12:13 <jared-w> ?hoogle "perl gibberish"
14:12:14 <lambdabot> No results found
14:12:22 * jared-w tried :(
14:17:43 <akfp> how can I use `over` from lens to execute things in parallel?
14:18:10 <akfp> or.. how can I execute actions `over` something in parallel?
14:18:30 <jared-w> https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Parallel-Strategies-Lens.html  <-- is this helpful?
14:22:18 <sphinxo> is it possible to have a list of a phantom type, allowing anything for the type variable?
14:22:28 <c_wraith> akfp, so you mean execute IO actions concurrently? 
14:22:33 <c_wraith> *do? 
14:23:00 <jared-w> sphinxo: is there anything you're imagining that [a] cannot do?
14:23:37 <c_wraith> akfp, like, do you want to run IO actions concurrently on each target of a Traversal? 
14:23:38 <sphinxo> Well actully, now that I think about it, i'd want a map
14:23:45 <sphinxo> Data.Map
14:24:39 <sphinxo> data Id a = Int; Data.Map String (Id a)
14:25:44 <Cale> sphinxo: By writing a function  Id a -> Id b  and applying it to all the elements, yes.
14:26:47 <Cale> If it's important which type they are, then you might want to consider using a GADT along with an existential wrapper
14:47:38 <codeshot> I just discovered that a program without branches is a left zero-ing semigroup (if the language allows the programmer to choose between terminating or infinitely looping) and that execution is folding the fixedpoint of (prog <>) into entropy itself !
14:48:15 <jared-w> nice!
14:48:59 <MP2E> neat!!
14:49:32 <jared-w> I'm wondering if this ties nicely into lambda calculus at all or not :)
14:50:13 <codeshot> My next trick will be to add data (I'm going to use a ringbuffer) so STM is modelled on all scales but the nature of the program shouldn't change. reading and writing data to and from the ringbuffer (and therefore computation) will be treated as I/O because of course it causes physical changes
14:50:17 <codeshot> I think so
14:50:59 <Tuplanolla> I lost you on entropy, codeshot. What exactly did you do?
14:51:12 <codeshot> because at that point I will have described a turing complete assembler language for a machine with tape loops
14:51:37 <codeshot> "entropy" is the progression of the arrow of time and the development of the current state of the universe
14:52:22 <codeshot> execution is a type of fold on the cons-structure built by semi-group append
14:52:59 <codeshot> I'm actually about to make a program that writes chunks of data that describe linux x64 syscalls directly
14:53:59 * hackagebot rollbar 1.0.0 – error tracking through rollbar.com – https://hackage.haskell.org/package/rollbar
14:54:37 <codeshot> My goal is to write an interpreter in assembler directly, where a program can be embedded via text-based macros (c pre-processor, for example), but that all primitives are instances of the basic blocks of category theory
14:55:36 <codeshot> so there's a simple interpreter in assembler and a higher-level functional language is a direct one-to-one mapping, so that a basic parser can be written as data in assembler and both an assembler or functional programmer can easily understand it
14:55:57 <codeshot> and all these parts can be exposed in the higher-level language that they implement!
14:56:33 <codeshot> Then I plan to write the interpreter also in that higher-level language, to interpret a compiler for that language that compiles the interpreter into the original assembler!!!!!!!
14:56:35 <codeshot> ahahaha
14:56:38 <codeshot> ahahahahahaha
14:56:40 <codeshot> ahahaha
14:56:41 <codeshot> !!!
14:56:42 <codeshot> !!!!!!
14:57:14 <codeshot> :(
14:57:27 <Tuplanolla> I don't get it, but it sounds like you're having a good time, codeshot.
14:57:31 <boj> codeshot: sounds exciting :)
14:57:33 <codeshot> yes, yes I am
14:59:14 <jared-w> Tuplanolla: the tl;dr is that assembly is built on the idea of Von Neumann architecture. Rather than using that outdated and silly archaic model (along with problematic "turing machine" evaluation models) one can directly deal with linguistic computational models such as lambda calculus (or in this case, a variant based on folding entropy into a non-branching semi-group)
14:59:57 <jared-w> This allows for being able to write and express category theory "primitives" directly in an assembly that executed by a functional machine
15:00:17 <Tuplanolla> Yes.
15:00:36 <jared-w> (the rest was just about constructing a boot-strapping process to self-host for his high level language, indirectly creating a self-hosting assembler in the process)
15:00:56 <codeshot> lol
15:01:12 <codeshot> that old chestnut
15:26:47 <priewienv> So what is the difference?
15:30:47 <codeshot> between a regular von neumann program and the thing I just went insane over ? or something else ?
15:32:05 <codeshot> If the former, then I'm convincing myself that there's no difference except, I think, in the order of factoring primitives allows more scalable analysis. That's an important thing, though.
15:35:24 <jared-w> Theoretically speaking, both are equivalent in their ability to compute something.
15:36:40 <jared-w> That being said, if a program is evaluated based on graph reduction on hardware that can natively handle graph reduction, you're going to get more performance than translating graph reduction into linear execution of "machine instructions" in a VN architecture
15:45:21 <Xandaros> So, I'm trying to decrypt some data. The description of how things work is here: http://wiki.vg/Protocol_Encryption#Symmetric_Encryption. I got to the point where encryption is enabled, but if I try to decrypt the packets I receive, it still is gibberish. I'm using cryptonite to do the actual decryption, I generate the AES128 value and the IV here:
15:45:23 <Xandaros> https://github.com/Xandaros/MinecraftCLI/blob/master/src/Network/Protocol/Minecraft/Network/Encoding.hs#L33-L37 and my decrypt function is in the same file. Any ideas what I'm doing wrong?
15:46:37 <Xandaros> Also, the note about it being updated continuously is worrying me, since I don't get a new AES128...
15:56:53 <Xandaros> Actually, I might be an idiot, hold on
16:04:00 <Xandaros> Nope, still no clue. It looks like I can decrypt the first byte, but since it's a block cipher, that wouldn't make much sense, would it?
16:16:21 <akfp> jared-w: yes I think it helps, but an example would be good.  
16:17:06 <akfp> over traverse (+ 2) [1,2,3,4]
16:17:26 <akfp> how would that look in parallel?
16:18:08 <Welkin> parMap (+2) [1,2,3,4]
16:18:08 <Welkin> :D
16:18:56 <akfp> over (traverse . _2) (+2) [(1,1), (2,2), (3,3)]
16:21:19 <Welkin> :t Free
16:21:20 <lambdabot> error: Data constructor not in scope: Free
16:21:28 <Welkin> @src Free
16:21:28 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:22:15 <MarcelineVQ> you shouldn't have called yourself a rocket surgeon that noe time
16:22:25 <Welkin> hm
16:22:33 <Welkin> I recently watched a talk on Free
16:22:54 <Welkin> the free package doesn't look like the Free I learned about
16:23:25 <Welkin> data Free f a = Pure a | Roll f (Free f a)
16:23:27 <Welkin> something like that
16:23:41 <erisco> there be more than one Free
16:24:10 <nshepperd_> free package calls the second constructor Free instead of Roll
16:24:14 <nshepperd_> For whatever reason
16:24:44 <Eduard_Munteanu> Roll (f (Free f a))
16:24:56 <Eduard_Munteanu> @src Mu
16:24:56 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:25:38 <Welkin> does this definition exist anywhere?
16:25:46 <Welkin> oh I see
16:26:09 <Welkin> http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html#v:Free
16:38:36 <Welkin> so I learned a little about Free, and played around with fix a bit
16:39:04 <Welkin> I think it's time to learn Comonads, Cofree, and Yoneda/Coyoneda
16:39:10 <Welkin> any good resources for those?
16:39:53 <erisco> a good bottle of whiskey and a high tolerance for pain
16:41:16 <Welkin> erisco: I meant papers or talks
16:41:33 <Welkin> or even co-algebras in general
16:42:13 <cheater> if aeson has the ability to derive instances via template haskell at compile time, why does it have the ability to also derive using generics with run time overhead?
16:42:21 <erisco> why not bite the bullet and learn CT
16:42:21 <Welkin> I found this https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/ but I find his blog to be too difficult to understand (too much category theory)
16:42:57 <Welkin> erisco: I am learning CT, but I haven't gotten very far yet. I'd rather learn from multiple perspectives than just an academic one. I like learning about these concepts through haskell
16:43:06 <MarcelineVQ> he has videos on categroy theory for coders as well, I think anyway, if you find videos digestable
16:43:43 <Welkin> this purescript talk on Free was very good https://www.youtube.com/watch?v=eKkxmVFcd74
16:43:49 <Welkin> something like that would be great
16:46:13 <akfp> does f :: [a -> b] -> [a] -> [b] exist?
16:46:19 <Welkin> I just found these essays from kmett on comonad.reader http://comonad.com/reader/2008/monads-for-free/
16:47:10 <Welkin> akfp: yes, it's called ap or <*>
16:47:15 <Welkin> :t (<*>)
16:47:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:47:38 <akfp> Welkin: thanks!
16:47:49 <Welkin> it is very close to fmap
16:47:50 <Welkin> :t fmap
16:47:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:48:18 <Welkin> > pure (+1) <*> Just 2
16:48:20 <lambdabot>  Just 3
16:49:47 <MarcelineVQ> :t zipWith ($) -- <*> might not have the desired result, so this is another option
16:49:48 <lambdabot> [a -> c] -> [a] -> [c]
16:50:31 <akfp> > (,) <$> [1,2,3] <*> [4,5,6]
16:50:33 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
16:50:47 <akfp> yes, that's not what I want..
16:50:58 <Welkin> ah, yes
16:51:06 <Welkin> the applicative instance for lists is different
16:51:26 <erisco> :t ZipList
16:51:27 <lambdabot> [a] -> ZipList a
16:51:43 <erisco> > (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
16:51:45 <lambdabot>  ZipList {getZipList = [(1,4),(2,5),(3,6)]}
16:51:59 <akfp> erisco: ah, nice!
16:53:47 <Welkin> > extract ((,) <$> ZipList [1,2,3] <*> ZipList [4,5,6])
16:53:49 <lambdabot>  error:
16:53:49 <lambdabot>      Variable not in scope: extract :: ZipList (Integer, Integer) -> t
16:54:10 <Welkin> > Control.Comonad.extract ((,) <$> ZipList [1,2,3] <*> ZipList [4,5,6])
16:54:12 <lambdabot>  error:
16:54:12 <lambdabot>      Not in scope: ‘Control.Comonad.extract’
16:54:12 <lambdabot>      No module named ‘Control.Comonad’ is imported.
16:54:56 <erisco> ZipList shouldn't be a Comonad
16:55:16 <Welkin> oh well
16:55:30 <Welkin> is there a good resource for learning how to use comonads?
16:55:34 <Welkin> and why they exist
16:55:51 <erisco> no one is sure why things exist, yet
16:55:54 <pacak> Welkin: They exist because of co-part
16:56:13 <pacak> And they are useful... For cellular automatas for example
16:56:15 <Welkin> is there an introduction to coalgebras?
16:56:36 <pacak> Or anywhere when you construct a big picture out of small pieces
16:57:27 <pacak> :t extract
16:57:29 <lambdabot> error: Variable not in scope: extract
16:57:35 <pacak> lambdabot: :-P
16:57:46 <erisco> Comonad w => w a -> a
16:57:48 <pacak> extract :: w a -> a
16:58:02 <Welkin> I know the type
16:58:10 <pacak> extend :: (w a -> b) -> w a -> w b
16:58:15 <Welkin> I'm looking for some kind of essay or talk though
16:58:54 <Welkin> or if someone feels like explaining it right here
16:58:58 <pacak> signature says "let's look at whole big picture and create a small bit of it", and the magic of comonads does this transformation for whole picture, one bit at a time
16:59:08 <MP2E> I liked this post about comonads http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
16:59:13 <MP2E> doesn't go into coalgebras i don't think
16:59:59 <Welkin> MP2E: thanks
17:00:07 <cheater> are there common functions like fst and snd but for triples?
17:00:18 <pacak> :t view _1
17:00:19 <lambdabot> (Field1 s s b b, MonadReader s m) => m b
17:00:29 <pacak> view _2, view _3
17:00:36 <pacak> > view _1 (1,2,3)
17:00:39 <lambdabot>  1
17:00:40 <Welkin> cheater: I would not use those
17:00:56 <pacak> > over _3 (+1000) (1,2,3)
17:00:59 <Welkin> almost always when you are using `fst` or `snd`, you should realy be using pattern matching instead
17:00:59 <cheater> i would not either
17:01:00 <lambdabot>  (1,2,1003)
17:01:33 <cheater> Welkin: yeah, but this time i really do want to use fst or snd, but for triples
17:01:47 <pacak> Also works for pairs or bigger stuff
17:01:56 <cheater> :t over
17:01:58 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
17:02:05 <pacak> > (view _1 (1,2), view _1 (1,2,3,4,5,6,7,8))
17:02:07 <lambdabot>  (1,1)
17:02:14 <cheater> i'm so not pulling in lens for that
17:03:02 <Gurkenglas_> cheater, have you considered using pattern matching instead of fstlikes?
17:03:18 <Gurkenglas_> oops, ninja'd
17:04:03 <akfp> > sum $ ZipList [1,2,3] <*> ZipList [3,2,1]
17:04:05 <lambdabot>  error:
17:04:05 <lambdabot>      • Could not deduce (Num a0)
17:04:05 <lambdabot>        from the context: (Num (a -> a1), Num a, Num a1)
17:04:14 <cheater> Gurkenglas_: i have done that already
17:04:26 <cheater> but i thought, maybe somewhere those functions exist, and i could use them
17:04:54 <akfp> > sum $ getZipList $ ZipList [1,2,3] <*> ZipList [3,2,1]
17:04:56 <lambdabot>  error:
17:04:56 <lambdabot>      • Could not deduce (Num a0)
17:04:56 <lambdabot>        from the context: (Num (a -> a1), Num a, Num a1)
17:05:10 <Welkin> akfp: the types are wrong
17:05:11 <erisco> akfp, you probably don't mean that... remember the type of (<*>)
17:05:23 <akfp> I want a dot product
17:06:02 <akfp> ah, so
17:06:22 <pacak> > sum . getZipList $ (*) <$> ZipList [1,2,3] <*> ZipList [3,2,1]
17:06:25 <lambdabot>  10
17:06:25 <akfp> > sum $ getZipList $ (*) <$> ZipList [1,2,3] <*> ZipList [3,2,1]
17:06:28 <lambdabot>  10
17:06:43 <Psybur> > sum $ (+) <$> ZipList [1,2,3] <$> ZipList[3,2,1]
17:06:45 <lambdabot>  error:
17:06:45 <lambdabot>      • Couldn't match expected type ‘Integer -> a’
17:06:45 <lambdabot>                    with actual type ‘ZipList (Integer -> Integer)’
17:06:47 <Psybur> Ops :D
17:06:48 <erisco> > ((sum .) . zipWith (*)) [1,2,3] [3,2,1]
17:06:51 <lambdabot>  10
17:07:23 <Welkin> erisco: alright, enough showing off
17:07:42 <erisco> showing off? well we don't need ZipList if we are just zipping two lists
17:07:45 <pacak> > sum $ zipWith (*) [1,2,3] [3,2,1]
17:07:46 <akfp> > sum $ zipWith (*) [1,2,3] [3,2,1]
17:07:47 <lambdabot>  10
17:07:48 <lambdabot>  10
17:07:54 <pacak> a bit more readable.
17:07:55 <akfp> great!
17:08:33 <Welkin> :t (sum .) . zipWith (*)
17:08:34 <lambdabot> Num c => [c] -> [c] -> c
17:08:47 <Welkin> :t sum (.).(.) zipWith (*)
17:08:48 <lambdabot> (Num (([b -> c1] -> [b] -> [c1]) -> [b -> c1] -> c), Num (b -> c1), Foldable ((->) (([b] -> [c1]) -> c))) => (b -> c1) -> [b -> c1] -> c
17:08:50 <Welkin> lol
17:08:58 <erisco> your type asplode
17:09:01 <Psybur> > sum $ (+) <$> ZipList [1,2,3] <*> ZipList[3,2,1]
17:09:01 <pacak> oh noes, my eyes...
17:09:03 <Welkin> :t sum ((.).(.)) zipWith (*)
17:09:03 <lambdabot>  12
17:09:04 <lambdabot> (Num (((a -> a -> a) -> [a] -> [a] -> [a]) -> (a -> a -> a) -> [a] -> c), Num a, Foldable ((->) (([a] -> [a]) -> c))) => [a] -> c
17:09:57 <erisco> if I publish that dot dot dot package you could write  sum ... zipWith (*)   :D
17:10:20 <Welkin> oh wait
17:10:24 <MarcelineVQ> .: is in a few places already
17:10:26 <Welkin> :t (.).(.)
17:10:27 <pacak> plz don't.
17:10:27 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
17:10:29 <Welkin> :t ((.).(.))
17:10:29 <erisco> this is different
17:10:30 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
17:10:37 <Welkin> what
17:10:39 <erisco> dot dot dot applies all arguments
17:10:42 <MarcelineVQ> Welkin: ((.).(.)) is prefix
17:10:47 <Welkin> :t sum `(.).(.)` zipWith (*)
17:10:48 <lambdabot> error: parse error on input ‘(’
17:10:50 <Welkin> lol
17:11:03 <Welkin> yeah
17:11:07 <Welkin> (.).(.) sucks!
17:11:09 <Welkin> I need ...
17:11:26 <Welkin> what is the usual way of writing it? .: ?
17:11:49 <erisco> no, it requires some type level programming
17:12:39 <erisco> sum ... zipWith3 ((*) ... (*))   would be the same but for three lists
17:13:00 <Welkin> looks like an emoticon
17:13:16 <Welkin> actually...
17:13:35 <erisco> my life's dream is to turn all of Haskell into operators
17:13:37 <Welkin> http://hackage.haskell.org/package/data-emoticons-0.1.0/docs/Data-PopCulture-Emoticons.html
17:14:08 <erisco> RuneBlaze is a paragon
17:15:08 * hackagebot tcod-haskell 0.2.0.0 – Bindings to libtcod roguelike engine – https://hackage.haskell.org/package/tcod-haskell
17:15:25 <erisco> guess I'll whip it into a package... give me an hour...
17:16:53 <erisco> and I'll have to remember to also alias it as …  heh
17:17:07 <erisco> will Haskell see that as an operator? no idea
17:17:30 <erisco> answer is affirmative
17:21:39 <erisco> glguy, were you the one who showed me how to use a type family to characterise the base cases for recursing on types with classes?
17:22:16 <erisco> my brain has stopped recording people's names beyond the first character
17:22:40 <erisco> if not then it was geekosaur
17:27:58 <cheater> in haddock markup, when I want to say something like "This depends on Foo's Bar", how would i make Foo a hyperlink? Doing "This depends on 'Foo''s Bar" will make it a hyperlink to Foo'.
17:28:15 <Psybur> What courses do you have to take to be able to understand https://wiki.haskell.org/Catamorphisms >.>
17:29:10 <erisco> Psybur, the theory is from Category Theory, but you can practise with catamorphisms in Haskell
17:30:35 <erisco> Psybur, you're doing this just by using foldr
17:31:31 <erisco> whoa I had my github repo starred... efamous now
17:34:00 <penteract> Why is the arrow (=>) for contexts when defining a typeclass in the wrong direction?
17:34:21 <koz_> penteract: I'm not sure I get what you mean by that.
17:36:25 <penteract> Functor m => Monad m is not a true logical statement, whereas Functor m <= Monad m would be
17:36:48 <Welkin> it just is
17:37:52 <Welkin> haskell is not a logic language
17:38:00 <Welkin> you could also complain that :: and : are swapped
17:39:01 <erisco> penteract, you read it as "m is a Monad given m is a Functor"
17:39:25 <penteract> other uses of => can be nicely interpreted as implications
17:39:28 <erisco> and similar for reading any context
17:40:23 <erisco> you can read it like an implication
17:41:09 <penteract> eg Ord a => a -> a -> Bool  can be seen as "for all a, if Ord a then there is a function (a->a->Bool)
17:41:34 <erisco> yeah, same thing
17:41:55 <erisco> I see the other interpretation you are thinking of but you can use the one you just gave instead
17:42:39 <penteract> whereas "class Applicative m => Monad m" does not mean that "for all m, if Applicative m  then Monad m"
17:43:12 <zwild> That's constraint
17:43:33 <zwild> means "Monad m must also be an Applicative"
17:43:45 <penteract> instead it means "for all m, if Monad m  then Applicative m", so the implies symbol is being read backwards
17:43:47 <erisco> instance Show a => Show (Maybe a)   "a is Showable implies Maybe a is showable"
17:43:58 <penteract> exactly
17:45:08 <Welkin> I have never read or thought of `=>` as "implies"
17:45:14 <Welkin> but rather, "has constraint"
17:45:25 <Welkin> which is still "backward" I suppose
17:45:36 <Greyskull> Yo
17:47:21 <erisco> penteract, well, it does mean that, but it is actualised only by an instance
17:48:03 <erisco> imagine it was  Applicative m -> Monad m
17:48:10 <erisco> you give me applicative I give you monad
17:48:40 <Welkin> the => are converted to -> when you desugar the type classes, right?
17:48:47 <Welkin> they are just dictionaries that get passed around
17:51:18 <erisco> penteract, then because it took an Applicative to make a Monad, if you have a Monad then you have an Applicative
17:51:24 <Greyskull> Sup folks?
17:52:45 <penteract> but "class Applicative m => Monad m" really means that if you have a monad you can get an applicative
17:53:29 <penteract> so its more like a function Applicative -> Monad
17:54:46 <erisco> implemented by an instance, yeah
17:55:52 <mud> It's definining a class you can instantiate for some type m, in the context that m is an instance of Applicative. Seems really similar to the use of => elsewhere
17:56:10 <erisco> your way of thinking is not wrong, I am just offering a possible defense of the direction of the arrow
17:56:18 <Greyskull> Is this a unique language?
17:56:40 <mud> Greyskull: Hello. What do you mean by unique?
17:56:52 <erisco> Greyskull, there are many functional programming languages, so in that sense Haskell is not unique
17:57:19 <Greyskull> I understand, thanks
17:58:00 <erisco> the underlying research has spawned many languages
17:58:08 <Welkin> but there are very few lazy purely functional languages
17:58:13 <Welkin> or even purely functional
17:58:26 <Welkin> the only othr lazy purely functional language I can think of it Clean
17:58:32 <Welkin> is*
18:00:46 <penteract> mud, In the other uses eg "(==)::Eq a => a->a->Bool", it says that for all types a, you can get an instance, so that's why I'm claiming it is different.
18:02:48 <minn> iirc curry is lazy
18:05:00 <cheater> in my module's documentation, how can i make headings that separate multiple definitions? e.g. i would like to have a heading that says "Input", then all the data types related to input, then "Output", and all the data types related to output.
18:05:43 <cheater> I tried "-- | = Output" but that just gets put under the first data type following it.
18:09:01 <cheater> ah it's -- *
18:21:58 <cobreadmonster> anyone here at Texas A&M or UIUC? It's kinda of an emergency, so forgive the OT >.<
18:23:33 <Axman6> "kinda an emergency"?
18:23:44 <cobreadmonster> Axman6: Need a book for my thesis proposal.
18:24:00 <erisco> oh, *that* kind of emergency
18:24:10 <cobreadmonster> As opposed to? :P
18:26:24 <cobreadmonster> Wait, didn't Welkin go to UIUC?
18:41:46 <Welkin> cobreadmonster: nope
18:41:55 <cobreadmonster> Ah fuck.
18:48:05 <inhortte> uck.
18:49:26 <ab9rf> uiuc is about two hours south of me, but i don't have a car 
19:02:35 <erisco> well I have the library ready but now I figure I need to generalise to Category
19:03:38 <erisco> though I am not sure that is possible, hm
19:04:15 <penteract> What library are you working on?
19:05:06 <erisco> :t (.).(.)
19:05:08 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
19:05:20 <erisco> the question is if you can generalise that to category, but I don't think so
19:08:22 <nykros> hi
19:08:36 <cheater> hi, does anyone know why i would be having this issue with the DCP solver? https://github.com/chrisnc/hvx/issues/10
19:09:57 <nykros> no idea, sorry
19:11:42 <nykros> do u know how to enumerate an infinite matrix? My solution gave me only half a matrix
19:11:58 <nykros> [(x, y) | x<- [0..], y<- [0..x]]
19:12:04 <erisco> :t fmap . (.)
19:12:05 <lambdabot> Functor f => (b -> c) -> f (a -> b) -> f (a -> c)
19:12:28 <erisco> well, for generalised (.) that will work for  cat a b  if  cat a  is a Functor
19:13:24 <erisco> I am not sure how niche that becomes, though
19:14:41 <penteract> :t fmap `fmap` fmap
19:14:43 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
19:15:56 <erisco> :t fmap . (Control.Category..)
19:15:58 <lambdabot> forall k (a :: k) (f :: * -> *) (b :: k) (cat :: k -> k -> *) (c :: k). (Category cat, Functor f) => cat b c -> f (cat a b) -> f (cat a c)
19:17:47 <Welkin> :t (Control.Category..) (Control.Category..) (Control.Category..)
19:17:49 <lambdabot> forall k (a :: k) a1 (b :: k) (cat :: k -> k -> *) (c :: k). Category cat => cat b c -> (a1 -> cat a b) -> a1 -> cat a c
19:19:45 <erisco> obviously it works for (->) ... seems to work for Kleisli as well, so maybe it is worth it
19:24:44 <pikajude> would it be possible to make `cabal run` do something useful for ghcjs?
19:24:46 <pikajude> like, for example, open the generated index.html in the browser
19:24:48 <pikajude> or something of that nature
19:26:51 <Profpatsch> What’s the cleanest way to assemble Lefts in a Semigoup?
19:27:37 <Profpatsch> Something like assemble :: NonEmpty (Either e a) -> Either (NonEmpty e) a
19:29:24 <Profpatsch> assemble :: (Foldable f, Semigroup s) => (e -> s) -> f (Either e a) -> Either s a
19:30:24 <Profpatsch> I’m missing some standard combinator, right?
19:31:19 <pacak> :t distribute
19:31:21 <lambdabot> error:
19:31:21 <lambdabot>     • Variable not in scope: distribute
19:31:21 <lambdabot>     • Perhaps you meant ‘distrib’ (imported from Control.Lens)
19:32:21 * hackagebot github-release 1.0.5 – Upload files to GitHub releases. – https://hackage.haskell.org/package/github-release
19:33:20 <wilornel> Hey #haskell! How could I install a package's fork that I have cloned locally?
19:33:28 <penteract> erisco: what do you mean by works?
19:33:50 <erisco> penteract, that (->) is a category and (->)a is a Functor
19:34:00 <Profpatsch> pacak: That’s not what I am looking for, is it?
19:34:41 <pacak> Profpatsch: It kind of can distribute functor over different stuff, but you'll need something else in addition.
19:37:17 <Profpatsch> I can do something like (validationToEither . sequence . first pure . eitherToValidation)
19:37:20 <wilornel> add-source is not working
19:38:06 <Profpatsch> Hm, not exactly; but that’s a bit dirty.
19:43:13 <penteract> If C is a category, then C a should be the Hom functor.
19:43:16 <HallaSurvivor> How does one sort vectors?
19:43:27 <HallaSurvivor> I'm getting Data.Vector does not export sortBY
19:43:39 <HallaSurvivor> but I feel like sorting a vector of Ord objects should be built in
19:43:53 <penteract> whether that makes it a Functor in Haskell, I'm not sure
19:46:57 <Welkin> Covariant Functor
19:52:45 <dsal> haskell noob -- is there a magic operator to apply D./~ without having to do the parens-around-if thing here:       (if (tΔ <= ε) then D._0 else (pΔ D./ tΔ)) D./~ (kilo meter D./ hour)
19:56:33 <monochrom> No, but you can save parentheses elsewhere.
19:56:47 <dsal> Oh good.  I'm a bit low on parenthesis.  heh
19:56:53 <monochrom> (if tΔ <= ε then D._0 else pΔ D./ tΔ) D./~ (kilo meter D./ hour)
19:57:15 <dsal> I tend to apply them a bit too liberally.
19:57:51 <MarcelineVQ> better too many than too little if it's not hurting readability
19:58:37 <penteract> seconded (and very guilty of avoiding them)
19:58:41 <erisco> hm, it doesn't really work... the characterisation of base cases isn't strong enough
19:59:19 <erisco> was a kind of nice idea though... you just go to the bottom of the functors and then compose the category
19:59:23 <penteract> erisco, does Control.categorical.Functor help?
19:59:34 <erisco> :t fmap . fmap . fmap . (Control.Category..)
19:59:36 <lambdabot> forall k (a :: k) (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (b :: k) (cat :: k -> k -> *) (c :: k). (Category cat, Functor f, Functor f1, Functor f2) => cat b c -> f2 (f1 (f (cat a b))) -> f2 (f1 (
19:59:36 <lambdabot> f (cat a c)))
20:00:07 <erisco> no, the problem has to do with identifying base cases when recursing on types
20:00:13 <dramforever> If you are having trouble deciding which parens to use and which not, your expression is too complex
20:08:35 <penteract> Category C => C a is an instance of Control.Categorical.Functor.Functor
20:09:57 <erisco> penteract, what package is that?
20:10:13 <penteract> categories
20:10:33 <penteract> the instance isn't there, but I think I can write it
20:11:14 <erisco> it is unrelated to my issue, I just thought I'd take a look
20:13:22 * hackagebot control-dotdotdot 0.1.0.0 – Haskell operator `g ... f = \x1 .. xn -> g (f x1 .. xn)`. – https://hackage.haskell.org/package/control-dotdotdot
20:14:47 <dramforever> so, it has come to this
20:14:55 <erisco> mhm
20:15:26 <erisco> I am just going to where the people are... they're fed up with (.)
20:15:59 <boj> is this the haskell equiv of nodejs leftpad?
20:16:30 <erisco> that sounds like string padding
20:16:52 <dramforever> no because there aren't as many reverse deps (I hope!)
20:18:13 <dramforever> oh, it's new...
20:22:24 <Welkin> (＾∇＾)
20:22:33 <erisco> now how do I get it on lambdabot
20:22:51 <Welkin> @let (＾∇＾) = (.).(.)
20:22:53 <lambdabot>  Defined.
20:23:53 <Welkin> > fmap (+1) (＾∇＾) zip [1..3] [4..6]
20:23:54 <lambdabot>  error:
20:23:55 <lambdabot>      • Couldn't match type ‘[t0] -> a1 -> [a]’ with ‘[Integer]’
20:23:55 <lambdabot>        Expected type: ([a] -> [b] -> [(a, b)])
20:24:04 <Welkin> > (fmap (+1) (＾∇＾) zip) [1..3] [4..6]
20:24:05 <erisco> seriously we probably get this question every couple weeks, so it'd be fun to have a "well, you could do this" on lambdabot
20:24:06 <lambdabot>  error:
20:24:06 <lambdabot>      • Couldn't match type ‘[t0] -> a1 -> [a]’ with ‘[Integer]’
20:24:06 <lambdabot>        Expected type: ([a] -> [b] -> [(a, b)])
20:24:08 <Welkin> :D
20:24:22 <Welkin> it's the parens
20:24:34 <Welkin> :t (＾∇＾)
20:24:36 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
20:39:36 <cobreadmonster> erisco: Get what questions?
20:40:41 <erisco> wondering why  sum . zipWith (*)  doesn't work, for example
20:45:24 <Big_G> How can I modify a function without changing the input? For example, I want to do a pointfree of (+) that has the result negated.
20:45:45 <erisco> negate ... (+)   :P
20:45:47 <cobreadmonster> :t zipWith (*)
20:45:48 <lambdabot> Num c => [c] -> [c] -> [c]
20:46:04 <cobreadmonster> Wait, I forget why that won't work.
20:46:07 <cobreadmonster> Hold up.
20:46:18 <cobreadmonster> Man, I haven't practiced Haskell in a while.
20:46:20 <Eduard_Munteanu> :t sum .: zipWith (*)
20:46:21 <lambdabot> error:
20:46:21 <lambdabot>     • Variable not in scope:
20:46:21 <lambdabot>         (.:)
20:46:31 <cobreadmonster> :t sum . zipWith (*)
20:46:33 <lambdabot> (Num [c], Num c, Foldable ((->) [c])) => [c] -> [c]
20:46:48 <cobreadmonster> Yeah, thought so it does compile.
20:47:04 <cobreadmonster> > sum . zipWith (*) [1,2,3]
20:47:06 <lambdabot>  <[Integer] -> Integer>
20:47:06 <Eduard_Munteanu> :t (sum .) . zipWith (*)
20:47:08 <lambdabot> Num c => [c] -> [c] -> c
20:47:24 <erisco> Big_G, there is ... which I just published, or  (id ~> id ~> negate) (+)  using ~> from TypeCompose
20:47:55 <Eduard_Munteanu> > ((sum .) . zipWith (*)) [1,2,3] [2,2,2]
20:47:56 <erisco> Big_G, or  (negate .) . (+)  or  ((.).(.)) negate (+)
20:47:56 <lambdabot>  12
20:50:19 <erisco> Big_G, also if you want to do some reading then there is http://conal.net/blog/posts/semantic-editor-combinators
20:50:41 <erisco> and maybe there is a lensy thing, I dunno
20:50:49 <glguy> Big_G: the actual solution is: (\x y -> -(x+y))
20:51:16 <erisco> haters gunna hate
20:56:43 <EvanR> semantic editor combinators = pure awesome
20:57:58 <penteract> > ((negate.).(+)) 4 5
20:58:00 <lambdabot>  -9
20:58:01 <glguy> Doing it via lens would be: over (mapped . mapped) negate (+), which is a more complicated version of  fmap (fmap negate) (+) 
20:58:34 <Big_G> Oh, for some reason I forgot about composition. Thanks penteract 
20:58:58 <penteract> sorry for the abscence of Functors :)
21:02:41 <penteract> :t flip (Control.Category..)
21:02:43 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
21:04:05 * hackagebot octane 0.20.2 – Parse Rocket League replays. – https://hackage.haskell.org/package/octane
21:04:06 * hackagebot DeepDarkFantasy 0.2017.8.16 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
21:07:21 <erisco> @pl \(x,y,z) -> ()
21:07:21 <lambdabot> (line 1, column 7):
21:07:21 <lambdabot> unexpected "z"
21:07:21 <lambdabot> ambiguous use of a non associative operator
21:07:43 <erisco> @pl \x,y -> x
21:07:43 <lambdabot> fst
21:07:49 <Axman6> o.O
21:07:54 <Axman6> wut
21:09:11 <penteract> could someone explain why "flip (Control.Category..)" can be interpreted but not compiled?
21:09:25 <Axman6> eh?
21:09:34 <Axman6> why wouldn;t that be able to compile?
21:10:37 <mud> penteract: What's the error?
21:12:08 <penteract> {-# LANGUAGE FlexibleInstances,MultiParamTypeClasses,IncoherentInstances,UndecidableInstances,PolyKinds,RankNTypes,TypeInType #-} seems to do it
21:12:55 <Axman6> uh...
21:13:04 <penteract> )At some point I introduced a different error, so I'm not sure if they're all needed
21:13:09 <Axman6> you several of those are things you don't want
21:13:45 <erisco> {-# LANGUAGE SledgeHammer #-}
21:14:12 <penteract> I included everything ghc suggested until it compiled
21:14:25 <pacak> Ugh.
21:14:29 <penteract> It also needed import Data.Kind
21:14:38 <Axman6> don't just add things you don''t understand
21:14:58 <pacak> Axman6: one might end up looking at a blank file...
21:15:01 <c_wraith> when GHC starts suggesting things with "Incoherent" in the name, you've gone off the rails
21:15:23 <penteract> That ones not actually needed
21:15:55 <Axman6> UndecidableInstances can also lead to your compile never terminating IIRC
21:16:05 <penteract> I managed to import it earlier while somehow still having clashing instances
21:16:06 <c_wraith> Well, GHC will terminate it anyway
21:16:10 <erisco> I thought they had a recursion depth
21:16:28 <Axman6> possibly, I've never used it, because afaik it's a bad idea
21:16:29 <c_wraith> UndecidableInstances is harmless.  The only two particularly bad ones are OverlappingInstances and IncoherentInstances
21:16:38 <c_wraith> Axman6: no, it's super-useful.
21:16:42 <Axman6> ah that could be it
21:17:00 <penteract> {-# LANGUAGE PolyKinds,RankNTypes,TypeInType #-} is enough
21:17:04 <erisco> there are many things you want to do at the type level that GHC can't be sure terminates
21:17:20 <pacak> By undecideable instances you are telling ghc - "i know it might look as it won't terminate, but trust me - it will".
21:17:42 <erisco> more like: trust me, it might
21:17:57 <c_wraith> "trust me, and yell at me later if I was wrong"
21:17:59 <Axman6> "Trust me, I think I know what I'm doing"
21:18:22 <pacak> Axman6's looks closest I think :)
21:19:22 * hackagebot servant-static-th 0.1.0.5 – Embed a directory of static files in your Servant server – https://hackage.haskell.org/package/servant-static-th
21:20:05 <pacak> can any off-shelf http server stream arbitrary file as it's being written by a different process?
21:20:30 <pacak> arbitrary - as in non video/audio
21:21:12 <penteract> so the challenge is now: instance C.Category c => F.Functor (c a) (->) c where fmap = flip (C..)
21:21:17 <monochrom> No, GHC doesn't trust you. It just gives your code a spin for a preset number of iterations.
21:21:46 <c_wraith> penteract: that one is a bad idea
21:21:51 <geekosaur> pacak, if it doesn't know about it, when it hits current eof it will consider the file done
21:21:57 <monochrom> It doesn't yells at you if you're wrong either. It just yells at you after that number of iterations. You may still be right.
21:22:08 <geekosaur> becuase that's how files normally work
21:22:41 <pacak> geekosaur: Are there any standard ways of asking it to retry after some time?
21:22:43 <geekosaur> as long as the writer is at least one buffer ahead of the server at all times, it will "just work"
21:22:55 <geekosaur> pacak no
21:22:57 <penteract> this does need all the extensions I gave and still says functional dependencies conflict
21:23:16 <c_wraith> penteract: yes, because it's a bad idea. :P
21:23:40 <Axman6> penteract: it wouldn't be too hard to do with lower level APIs, though the question becomes when should it stopwaiting?
21:23:41 <penteract> why is it a bad idea? I just want to implement the Hom functor
21:23:53 <geekosaur> I mean, the client can try a byte range transfer starting at the last length it got, but the client has to know about that
21:23:53 <Axman6> uh, pacak
21:23:58 <pacak> geekosaur: Hmm... Makes sense. I guess nothing that can't be solved by a custom plugin :)
21:24:14 <c_wraith> penteract: because it overlaps with all sorts of things.  that's why you need IncoherentInstances.
21:24:40 <c_wraith> penteract: and if you don't know *exactly* how IncoherentInstances works and design so that its pitfalls can't bite you - they will
21:24:49 <pacak> client knows that there will be data written into file at some point within next few hours  and simply wants all the data as soon as possible
21:25:38 <geekosaur> so if the client knows that, it can periodically look at the current / saved size of what it has and try a byte range transfer starting from that point
21:25:41 <geekosaur> various remote log followers work that way, for example
21:26:24 <geekosaur> (if you're one of the scarily large overlap between here and ##crawl, that's how the milestone reporting bots find out about new milestones)
21:28:25 <pacak> Trying to design a new API which is mostly HTTPish and a choice between using off shelf server, implementing something in Haskell or making up some abomination from telnet/ssh and tail.
21:28:55 <pacak> Largely offtopic here though...
21:29:09 <monochrom> Use netcat instead of telnet there.
21:29:41 <pacak> monochrom: both server and clients are needed with desire to run some commands remotely
21:30:02 <monochrom> Oh, that.
21:30:31 <pacak> As I said - abomination :)
21:31:18 <monochrom> Ah I'm sure you can still use netcat. Just do the telnet or ssh protocol by hand.
21:32:11 * monochrom used to netcat to http servers, irc servers, and nntp servers.
21:34:39 <geekosaur> ssh protocol by hand will make you very unhappy unless you're good at sha512 or ec25519 key generation in your head :p
21:36:18 <monochrom> Euler did RSA in his head.
21:36:32 <monochrom> This is why RSA uses the Euler totient function.
21:42:54 * pacak refactors haskell code he wrote 4-5 years ago
21:43:01 <Axman6> pacak: another approach that could work is doing something like using tee to write the file and read from its stdout
21:43:02 <pacak> not as bad as I  though
21:43:17 <Axman6> you could even have the app write to a named pipe which tee is reading from
21:44:43 <geekosaur> tail -f
21:44:53 <geekosaur> into a pipe
21:45:51 <penteract> So I've now copied the definition of Control.Categorical.Functor.Functor to get rid of other pesky instances; and the compiler is still complaining
21:47:36 <pacak> So task looks like - two data producers, a bunch of consumers in a different network and links between producers and consumers are limited. Producers create several streams each, consumers want all the things. Consumers  might want to seek to arbitrary position on the stream. Things should be reliable and simple. Currently kafka is used but it's not working well.
21:47:48 <Axman6> are you still trying to define the class instance penteract?
21:47:55 <penteract> yes
21:48:30 <eklavya_> pacak: why is kafka not working?
21:48:31 <Axman6> like c_wraith said, that instance is a bad idea
21:50:33 <penteract> I'd still like to understand why
21:51:07 <erisco> what is this instance?
21:51:34 <penteract> instance C.Category c => F.Functor (c a) (->) c where fmap = flip (C..)
21:52:12 <pacak> eklavya_: Several reasons. It's a huge project and using it implies a bunch of specialized knowledge and some special care of how api is used.
21:53:13 <eklavya_> pacak: but the alternatives being talked about here are uhm ... :P
21:53:23 <penteract> erisco, when you were looking for categories C where C a is a functor, this is what I wound up with
21:53:43 <pacak> eklavya_: I know.
21:55:12 <pacak> Main problem is that we want just a bit more strange things what kafka can't provide.
21:56:05 <erisco> penteract, it is going to overlap with other instances
21:57:21 <erisco> you usually want instances where each parameter begins with a type constructor
21:57:43 <penteract> I used overlappingInstances + a lot of other extensions, that still failed; then I copied the definition of Control....Functor and it still failed
21:58:44 * hackagebot mime-mail-ses 0.4.0.0 – Send mime-mail messages via Amazon SES – https://hackage.haskell.org/package/mime-mail-ses
21:58:44 * hackagebot mime-mail 0.4.14 – Compose MIME email messages. – https://hackage.haskell.org/package/mime-mail
22:00:24 <penteract> Obviously I have to learn how to write ghc extensions :)
22:01:34 <erisco> penteract, I don't know what error you have, but when I tried your code has a type error
22:01:43 <erisco> I stuck a hole in for the instance... this is the type  (a1 -> b) -> c (c a a1) (c a b)
22:04:33 <penteract> :t flip (Control.Category..)
22:04:35 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
22:05:06 <pacak> penteract: What exactly  are you trying to invent here?
22:05:22 <penteract> The Hom Functor
22:05:38 <erisco> so clearly flip (.) is incorrect
22:05:49 <pacak> I know some of those words...
22:05:50 <penteract> why?
22:06:33 <erisco> because it needs to have the type  Category c => (a1 -> b) -> c (c a a1) (c a b)
22:07:19 <penteract> no, the categories ca be different
22:07:30 <erisco> I took your flip (.) out and I put in a hole
22:07:36 <erisco> I am telling you what the type of the hole is
22:08:33 <penteract> the type of F.fmap :: r a b -> t (f a) (f b)
22:09:29 <erisco> and in your case  f = c z, r = (->), t = c
22:09:47 <erisco> so  (a -> b) -> c (c z a) (c z b)
22:10:24 <penteract> should be t = (->), r=c
22:10:40 <erisco> okay, I just copied your code
22:11:34 <erisco> so now it is c a1 b -> c a a1 -> c a b
22:12:06 <erisco> so maybe trying (.) instead of flip (.)
22:12:11 <pacak> :t (>>>)
22:12:12 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
22:12:13 <pacak> :t (<<<)
22:12:15 <lambdabot> forall k (a :: k) (b :: k) (cat :: k -> k -> *) (c :: k). Category cat => cat b c -> cat a b -> cat a c
22:12:50 <erisco> and in that case it compiles for me
22:14:56 <erisco> penteract, http://lpaste.net/357735
22:15:06 <penteract> yeah, I got the order of arguments for the composition operator mixed up
22:15:19 <penteract> thanks
22:16:01 <penteract> now I just need to find out how many extensions I can disable
22:16:49 <penteract> Remember to pronounce it "after"
22:17:16 <HallaSurvivor> hey, when I run stack ghc on my project (I'm compiling a script, not the main project file, so I'm not using stack build) I can't find the executable
22:17:30 <HallaSurvivor> I see the .hi and .o files, but no executable like I'd expect from a regular ghc call
22:17:39 <HallaSurvivor> Also, stack exec isn't able to find it either...
22:18:08 <pacak> penteract: try hlint
22:18:10 <mud> HallaSurvivor: You probably need --make to GHC, so stack ghc -- --make
22:18:22 <HallaSurvivor> mud, Thanks! let me check
22:18:33 <mud> HallaSurvivor: Also, consider stack's script interpreter thing? It has an auto-compilation option now.
22:19:04 <monochrom> I don't know stack, but having been trained (machine-learning sense) by previous Q&A, I think it's always safe to say "are you sure the stack commands you used mean what you think". :)
22:19:08 <HallaSurvivor> mud, is that stack runghc?
22:19:32 <HallaSurvivor> that's how I'm currently running it, but it's NP-hard, so I feel like it would run faster if I compiled it
22:20:04 <penteract> pacak: why are you suggesting hlint?
22:20:07 <mud> monochrom: This is more "running GHC manually isn't fun"
22:20:19 <pacak> It can tell you what language pragmas you can disable
22:21:02 <mud> HallaSurvivor: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter this. It has an --optimize flag in newer stack
22:21:23 <mud> Or just --compile if optimization is overkill
22:25:54 <penteract> thanks pacak, it's down to FlexibleInstances,MultiParamTypeClasses and FunctionalDependencies
22:33:10 * hackagebot Villefort 0.1.1.2 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
22:39:15 * hackagebot Villefort 0.1.1.4 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
22:39:15 * hackagebot Villefort 0.1.1.3 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
22:51:00 <pacak> That is some fast software development...
22:51:44 <erisco> when the AIs take over that is what it will be like
22:52:22 <Axman6> software development will become like high frequency trading, we won't be able to keep up
22:53:31 <halogenandtoast> On my display, they released 0.1.1.4 before 0.1.1.3
22:53:46 <halogenandtoast> So I think some time travelling was involved.
22:53:47 <Axman6> yeah, just like HFT
22:54:02 <halogenandtoast> hft = high frequency trading?
22:58:33 <dsal> ghc: panic! (the 'impossible' happened)
22:58:39 <dsal> Damn.  My haskelling is advancing rapidly.
22:58:55 <pacak> dsal: nice. what version?
22:58:58 <pacak> of ghc
22:59:04 <dsal> Looks like 8.0.1
22:59:12 <pacak> try 8.2.1?
22:59:19 <dsal> I just pulled whatever this distro had.
22:59:59 <dsal> I'm just installing a package I'm unlikely to use on this machine anyway.
23:00:20 <halogenandtoast> dsal: btw, I usually have that happen when I try to compile something the same time something else is autocompiling
23:00:36 <halogenandtoast> for example if I'm running `yesod devel` and then I try to compile at the same time.
23:01:05 <halogenandtoast> Not sure if it helps you in this situation, just commenting on instances where I've seen it.
23:01:09 <dsal> I'm just doing a bit of cabal on fresh installs around the machines.  The armbian machines seems newer.
23:01:23 <halogenandtoast> For example, maybe you're trying to install multiple packages at the same time.
23:01:27 <pacak> If new ghc still panics - it's your chance to make a bugreport
23:02:00 <dsal> I'm installing multiple packages at the same time, but I'm not demanding concurrency.  :)
23:02:42 <halogenandtoast> pacak: Ah for some reason I've always considered it Yesod's fault. Next time it happens to me I'll file a bugreport, but I don't think I've tried it outside of 8.0.2
23:03:07 <pacak> halogenandtoast: whatever yesod does - ghc shouldn't panic.
23:04:14 <MarcelineVQ> a panic is always a ghc bug, 8.0.2 had a few of them as I recall as well, at least I ran into a few
23:06:09 <dsal> Man.  These things don't even get ghci.
