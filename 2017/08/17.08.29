00:07:32 <tabemann> I have a random question
00:07:57 <tabemann> why would, in Haskell, a thread hang without generating an exception but at the same time using no CPU, and no locking is involved either?
00:12:58 <cocreature> tabemann: threadDelay, waiting for IO, …
00:14:04 <tabemann> there is one threadDelay in the thread, which is absurdly small in length that all it does is force a context switch
00:14:16 <tabemann> and there is IO in the form of putStr
00:14:22 <cocreature> if you have some specific code, show us the code :)
00:14:33 <cocreature> it’s hard to guess why you’re specific thread is blocking without seeing the code
00:15:08 <tabemann> it's not exactly a small code sample type of thing; I might as well direct you to my github
00:15:31 <cocreature> then the first step is to isolate it to a small code sample :)
00:16:02 <tabemann> it's virtual machine for genetically engineered robot combat
00:16:07 <cocreature> ffi calls can also be a problem, in particular if you are using the non-threaded runtime.
00:16:13 <cocreature> IO on windows is also sometimes weird
00:16:24 <tabemann> I'm using -threaded
00:16:35 <tabemann> *genetically programmed
00:17:14 <dminuoso> How is Arrow to be understood? Do they just represent morphisms in Hask?
00:18:49 <nshepperd> if you're writing to stdout and the consumer is not reading then you can be blocked on filling up that buffer
00:21:00 <tabemann> I'm writing to stdout, where stdout is a terminal
00:22:46 <tabemann> commenting out all the terminal IO did not fix it (and I know it didn't because there was still no CPU usage, where normally the code uses a decent amount of CPU, as in without threadDelay it maxes out a single core)
00:24:09 <tabemann> I should go to bed, will figure this out tomorrow
00:30:05 <BernhardPosselt> hm, so you can use partial types? https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Either.html#line-130
00:30:10 <BernhardPosselt> instance https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#Functor (https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Either.html#Either https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Either.html#local-6989586621679154465) where
00:30:14 <BernhardPosselt> oops
00:30:20 <BernhardPosselt> instance Functor (Either a) where
00:33:33 <BernhardPosselt> so as long as you dont need the b it's fine?
00:34:19 <BernhardPosselt> and why is it a if the implementations use x and y?
00:34:51 <lavalike> dminuoso: these might help https://www.haskell.org/arrows/biblio.html
00:36:04 <halogena1dtoast> Is there a short hand for this "double" fmap? (fromList <$>) <$> sequence [draw 7, draw 7]
00:36:07 <lavalike> BernhardPosselt: 'b' is the type parameter of the functor, the type of Right :: b -> Either a b
00:36:48 <BernhardPosselt> right, but don't you need Right to map over stuff?
00:37:15 <BernhardPosselt> i mean it just looks like an abitrary definition to make the typeclass fit
00:37:22 <lavalike> BernhardPosselt: if I understand your question correcly you're surprised 'b' does not appear in the line “instance Functor (Either a) where”
00:37:28 <BernhardPosselt> exactly
00:37:39 <BernhardPosselt> i mean I know its    m a 
00:37:52 <BernhardPosselt> so the compiler would infer m to take only one parameter
00:37:56 <BernhardPosselt> correct
00:37:57 <BernhardPosselt> ?
00:38:19 <lavalike> yeah, the compiler doesn't infer it, it knows it: “class Functor (f :: * -> *) where fmap :: (a -> b) -> f a -> f b ...”
00:38:22 <lavalike> is the the definition
00:38:26 <nshepperd> it's the same reason 'a' does not appear in "instance Functor Maybe"
00:38:37 <BernhardPosselt> ah
00:38:46 <BernhardPosselt> so the first parameter is already "applied"
00:39:31 <BernhardPosselt> so if my Functor instance would require 3 type parameters I'd do something like: instance Functor (TheType a b) where
00:39:38 <lavalike> exactly
00:39:44 <BernhardPosselt> thank you
00:39:51 <lavalike> no problem!
00:40:22 <nshepperd> yes. then you fmap would have type (x -> y) -> TheType a b x -> TheType a b y
00:45:47 * hackagebot data-fix 0.0.6, language-puppet 1.3.10, relational-query-HDBC 0.6.3.1
00:45:47 * hackagebot  → https://hackage.haskell.org/packages/recent
01:06:39 <trigone> does haskell has implicit memoization for every function? like if i say read the length of some bytestring, do i have to keep the result around for later use or can i just call the function length again and it will just remember the previously calculated value?
01:07:13 <trigone> (it's just an example btw)
01:07:59 <tdammers> there is no implicit memoization
01:08:21 <tdammers> let-bound and where-bound thunks may get reused though
01:09:01 <tdammers> print (length "Hello") >> print (length "Hello") -- will count the string length twice
01:09:17 <merijn> trigone: No, but the rule of thumb is that, in principle, GHC will not evaluate named expressions multiple times
01:09:31 <tdammers> let l = length "Hello" in (print l >> print l) -- will probably only evaluate l once
01:10:28 <tdammers> however, common subexpression elimination (CSE) may kick in for the first example if you compile with optimizations; I don't know how aggressively GHC performs CSE though
01:11:16 <merijn> tdammers: The answer is "not aggressive at all"
01:11:33 <trigone> even for name expressions it's not a certainty? you say probably/in principle
01:11:52 <tdammers> merijn: yeah, thought so... after all, deciding whether it's worth it is kind of a hard problem
01:12:14 <trigone> CSE=?
01:12:18 <tdammers> trigone: the language standard allows either
01:12:24 <tdammers> trigone: Common Subexpression Elimination
01:12:30 <trigone> tdammers: yeah but what does GHC do?
01:13:05 <merijn> trigone: It's not a certainty because GHC sometimes tries to predict if computing something is expensive or not. Guaranteeing something is evaluated only once is somewhat expensive, so for really cheap computation performing them multiple times might be more efficient than the overhead of doing it once
01:13:19 <[exa]> trigone: for single binding in let it's almost sure that it will only get evaluated once, as it generates only a single thunk
01:13:53 <[exa]> trigone: it may get broken by inlining, this is quite related: https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf
01:13:58 <trigone> merijn: oh ok... well as long as the general result is the best solution in terms of performances :)
01:14:01 <merijn> [exa]: GHC does multiple evaluation of the same thunk occasionally
01:14:50 <[exa]> merijn: just curious- is there any other reason than inlining (and explicit programmer's wish) why it would get evaluated twice?
01:15:14 <trigone> thx for the link :)
01:15:35 <merijn> [exa]: What I just said above. In the parallel runtime guaranteeing it only gets evaluated once requires mutual exclusion, etc. which introduces overhead
01:15:36 <[exa]> trigone: esp. section 2.3 work duplication
01:15:58 <[exa]> merijn: oh so, that's true. I'm still living singlethreaded :D
01:16:05 <merijn> [exa]: It's cheaper to have separate threads evaluate it twice, rather than doing mutual exclusion for small computations
01:17:37 <trigone> that's really interesting. i'm beyond tired right now but i'll read it later :)
01:21:05 <tsahyt> Is reflex still alive? The latest versions I can find on hackage don't work with GHC 8 due to upper bounds on the base version used, and by now GHC 8 isn't exactly new anymore
01:21:46 <trigone> btw, with GADTs, i was randomly wondering if you can enforce the specific type of a phantom type for each constructor separately? something like data Foo p a where FInt :: a -> Foo Int a; FBool :: a -> Foo Bool a
01:22:04 <tsahyt> trigone: yes
01:22:28 <tsahyt> trigone: and pattern matching on the constructor will bring that type information back into scope too
01:26:01 <trigone> tsahyt: that's pretty cool. in some way it feels like some sort of ad-hoc polymorphism: foo :: Foo t a -> t for example can only be called with the specific t values which are defined in the GADT, a bit like constraints which only allow the types instantiating the underlying class... (it's just an impression)
01:28:53 <tsahyt> hm, that actually works too
01:28:55 <tsahyt> nice
01:29:25 <trigone> what works?
01:29:32 <tsahyt> your foo function, you can implement that
01:29:39 <tsahyt> and it typechecks and works
01:30:12 <drets> Hi guys, I want to have type level list in ascending order. I was able to implement such check for first and second element from the type level list using `instance (x <= z) => Asc (Cons x (Cons z m))  where`. So this compiles `test (Proxy :: Proxy (Cons 1 (Cons 2 (Cons 3 Nil))))` and this not: `test (Proxy :: Proxy (Cons 2 (Cons 1 Nil)))` as expected. Now I am looking for a way how to make a recursion on instances in order to check all elements from 
01:30:12 <drets> the list, any hints? Warning: I am a noob and may not understand what I am talking about.
01:30:53 <tsahyt> trigone: as long as the phantom parameter is always determined by the constructor. if you add an FAny :: a -> Foo p a constructor, you won't be able to define a case in the foo function for it
01:31:29 <tsahyt> since you'd have to return a value that inhabits *all* types. there is no non-bottom value that fulfils that criterion
01:31:40 <tsahyt> so in effect, the function becomes partial with that
01:31:48 <trigone> tsahyt: yeah, i read a similar function in https://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf , but since it used an apparently non-implemented syntax, i didn't know if you could actually write it (but it works with GADT apparently)
01:32:57 <trigone> tsahyt: oh good remark
01:33:18 <tsahyt> well the fundamental usefulness of GADTs is due to the fact that it lets the exact type depend on the values, and that you can regain the type information by pattern matching. if that sounds a bit like dependent types, that's because it is. GADTs are the fundamental building block to "faking" dependent types in haskell
01:33:56 <trigone> that makes sense
01:35:38 <merijn> GADTs are not dependent types
01:35:45 <iqubic> dependent types mess me up big time.
01:35:46 <merijn> It's still just types depending on values
01:36:05 <merijn> It's just types are allowed to have more complex dependencies on values than in classic ADTs
01:36:12 <tsahyt> merijn: I'm not saying they are, I'm saying it's the key extension that allows faking it
01:36:13 <trigone> you can avoid the partiality, sort of, with a Maybe or Either though...
01:36:23 <tsahyt> merijn: you obviously need a lot more
01:36:26 <tsahyt> TypeInType, TypeFamilies, etc
01:36:27 <merijn> tsahyt: I'd say the key extension is DataKinds
01:36:48 <tsahyt> merijn: richard eisenberg disagrees. as usually when I say something, I'm just parroting what I've heard
01:37:00 <tsahyt> I just listened to the Haskell Cast episode with him the other day
01:37:02 <tsahyt> that's why I remember that
01:37:16 <tsahyt> but yeah, DataKinds are also very very useful
01:37:47 <trigone> how is the project of seamlessly adding dependent types in haskell going btw? can we hope that one day (no matter when), it'll stop being a hack at all, or is it probably never going to be?
01:38:07 <merijn> I don't think it's going to be all that seemless :p
01:38:08 <tsahyt> trigone: last I checked it's still going. but it won't be ready for another few years I think
01:38:25 <merijn> But I think Richard and Stephanie are working hard on it
01:38:25 <tsahyt> but the next big thing I'm looking forward to isn't even dependent types, it's linear types
01:38:31 <merijn> tsahyt: hell yeah
01:38:31 <trigone> tsahyt: cool. i'm not in any hurry anyway
01:38:51 <tsahyt> and it seems like linear types is coming sooner than dependent haskell too
01:38:57 <iqubic> What the heck are linear types?
01:39:09 <trigone> btw, why is idris non-lazy by default? any relation to the choice of being very dependently typed?
01:39:10 <[exa]> cakes are linear
01:39:35 <tsahyt> iqubic: the way I understand it, they're essentially types that encode that a value is used exactly once
01:39:40 <[exa]> trigone: laziness is terribly complicated with linearity (it consumes your resources in surprisingly weird places)
01:39:44 <tsahyt> this allows very efficient streaming for example
01:39:48 <trigone> tsahyt: wait you mean like uniqueness?
01:40:37 <tsahyt> it's quite similar afaik. but linear types allow a non-linear value to be cast to a linear one for further processing
01:41:14 <`Guest00000> which are some most complex, enlightening or bizarre uses of Template Haskell that you know?
01:41:19 <tsahyt> trigone: relevant paper https://github.com/tweag/linear-types/releases/download/v1.0/hlt.pdf
01:41:23 <[exa]> tsahyt: anyway, did you see the Hask-LL thing?
01:41:30 <tsahyt> [exa]: nope, what is it?
01:41:44 * [exa] digs the link
01:42:01 <[exa]> oh it's exactly the paper you posted :]
01:42:10 <tsahyt> oh, I forgot that it was called that
01:42:25 <tsahyt> I've somehow got it mentally sorted under -XLinearTypes or something
01:43:16 <[exa]> another cool approach is the "best of both worlds" paper https://arxiv.org/pdf/1612.06633.pdf
01:44:01 <trigone> (it's weird but haskell corrupted me so well that i can't imagine how strictness works (in practice when coding), esp in a pure language...)
01:45:01 <[exa]> the other paper comes with a handy glue to put restricted/unrestricted types to a haskell-like class-based type system
01:45:44 <trigone> [exa]: but it's not implemented, it's just theory for now, isn't it?
01:45:53 <merijn> iqubic: Linear types are types that can guarantee that a value is used before some point X and is never used after
01:46:15 <trigone> does rust have uniqueness or linear types? (unless i mix up with another language...)
01:46:40 <[exa]> trigone: there's mostly nothing to implement, it's a straightforward patch for existing HS type system
01:46:40 <merijn> trigone: Rust uses some amount of linearity to track ownership, yes
01:47:25 <merijn> iqubic: A classic C example would be, you have an array defined in a function, how do you prevent the pointer accidentally leaving the function? (Since it's invalied after the function returns)
01:47:27 <[exa]> trigone: also I guess that 'deriving Un' can be quite simple
01:47:33 <trigone> [exa]: really? and wrt dependent types, is it complementary or overlapping in terms of domains of relevance?
01:47:48 <merijn> iqubic: linear types let you have an array value where accessing it outside the function is a type error
01:47:57 <trigone> (linear types and dependent types i mean
01:48:22 <tsahyt> merijn: afaik rust's type system is affine, i.e. values are used at most once
01:48:22 <merijn> trigone: linear types and dependent types are pretty much completely unrelated :)
01:48:25 <tsahyt> but you can also just not use them
01:48:38 <[exa]> trigone: unrelated, but dependent types are super helpful for session-like usage of linear types
01:48:52 <trigone> what's "session-like"?
01:49:03 <[exa]> like, the main reason for linear types are arrays   (crowd shouting: of what size?)
01:49:26 <trigone> and by straightforward patch, do you mean there's already an actual way to have linear types in haskell?
01:49:28 <[exa]> trigone: there's a demo&discussion of the connection in the paper :]
01:50:12 <trigone> ok :) so you mean they're sort of complementary?
01:50:12 <tsahyt> [exa]: aren't arrays just one example of a bigger class though? i.e. memory safety that can get by without GC?
01:50:18 <[exa]> trigone: i see no reason not to have it other than lack of purpose&manpower :D
01:50:57 <trigone> [exa]: so that's a no?
01:51:13 <trigone> (for now, practically speaking)
01:51:21 <[exa]> tsahyt: linearity provides a proof that no one's going to need original version of your array if you modify it in place, which enables one super-cool kind of optimization :D
01:51:49 <tsahyt> yes, but that doesn't just apply to arrays, but any kind of mutation that you can now do without any copying
01:52:05 <trigone> [exa]: does that mean you basically stop separating pure code from effectful code?
01:52:06 <[exa]> trigone: author of the paper said he's working on something, maybe he's got it ready
01:52:15 <merijn> trigone: linear types are in GHC HEAD, yes
01:52:30 <trigone> what's HEAD? a wish list for the future?
01:52:52 <[exa]> merijn: wow really? (that was faster than I thought)
01:53:02 <dminuoso> lavalike: Okay I think the concept of Arrow is not as complicated, but at this point I should probably stop and continue on with the gentle introduction.
01:53:37 <dminuoso> I steered off way too far on lazy evaluation (I ended up implementing various lambda calculus combinations) to understand why that client/server example required ~ :P
01:53:58 <dminuoso> Read into all those resources, and it seemed a bit too abstract.
01:54:02 <merijn> [exa]: They only just missed 8.2, I think the first implementation is currently planned for 8.4
01:54:14 <[exa]> merijn: links? (wiki seems outdated)
01:54:28 <merijn> [exa]: Some remark I saw on reddit :)
01:54:39 <merijn> [exa]: Try asking around on ghc-devs@ ?
01:54:43 <merijn> and/or #ghc
01:54:50 <tsahyt> are there any prediction for when 8.4 will arrive?
01:54:58 <tsahyt> I'm guessing some time next summer or so
01:55:01 <merijn> tsahyt: 8.2 is only just out, so...
01:55:03 <trigone> would using linear types replace the IO monad for controlling effectful code? (though i'm not exactly sure how you could do effectful code in haskell without IO, short of unsafePerformIO, which i suppose isn't unsafe with linear types?)
01:55:09 <tsahyt> going by how long 8.2 took from 8.0
01:55:13 <merijn> trigone: No
01:55:44 <merijn> trigone: But, you could use linear types to do purely functional without monadic IO, yes
01:56:16 <merijn> trigone: For example, Clean uses uniqueness types (a more restricted/simpler subset of linear types) to implement IO in a purely functional manner
01:56:36 <merijn> trigone: But I think most/all haskell people realise that first class IO is amazing, so I don't see that changing anytime soon
01:56:44 <[exa]> merijn: doesn't have the Un class (*sadface*)
01:56:49 <BernhardPosselt> hi, is there a good example where the Functor and Monad interface gives you functionality out of the box?
01:56:50 <tsahyt> merijn: how does that specify order of effects then?
01:56:56 <[exa]> but yeah, goot do see that :]
01:56:58 <BernhardPosselt> e.g. for Applicative Functor there's traverse
01:57:06 <tsahyt> I mean part of what makes monadic IO useful is because it clearly specifies order of execution
01:57:15 <tsahyt> (barring unsafeInterleaveIO)
01:57:31 <trigone> merijn: hm... but it wouldn't be anymore the same notion of pure function, would it? i mean it'd be purity in another meaning than without linear types, right?
01:57:35 <merijn> tsahyt: Well, Clean isn't lazy so you can just rely on order of evaluation
01:57:41 <merijn> tsahyt: like in all strict languages
01:57:44 <BernhardPosselt> for monads there's do notation but that doesnt exist in other languages, there's monad transformers but I'd classify that more as a shortcoming
01:57:49 <tsahyt> right, not my cup of tea :P
01:58:20 <trigone> what's first class IO? you mean effects as values?
01:58:31 <tsahyt> BernhardPosselt: shortcoming how? extensible effects type of systems also have drawbacks, just a different set of them
01:58:54 <tsahyt> I'd say both have their place, and it's good to have both
01:58:59 <merijn> trigone: Yes
01:59:14 <merijn> trigone: The fact that you can just pass "IO String" as value to a function
02:00:14 * hackagebot jsonschema-gen 0.4.1.0 – JSON Schema generator from Algebraic data type – https://hackage.haskell.org/package/jsonschema-gen
02:01:27 <Ferdirand> what's a linear arrow (-o) ?
02:01:46 <trigone> so maybe haskell's laziness prevents using linear types for handling IO (short of having unpredictable execution ordering)?.... well ofc unless it's possible to actually contain the effects allowed via linear types in a monad-like structure which would direct the flow... but then i'm not sure there'd be any gain...
02:02:10 <trigone> merijn: yes, you mean "the caller has control" design, vs the callee
02:02:26 <tsahyt> Ferdirand: it's a function that guarantees that it will consume its input exactly once
02:02:41 <tsahyt> so some function A -o B will use that A exactly once and return a B
02:03:00 <Ferdirand> so, to be clear, it only has impact on the A, not on the B ?
02:03:05 <tsahyt> yes
02:03:35 <tsahyt> and actually it doesn't restrict what that A can be either. A doesn't have to be a "linear value" as such, it can be anything. the guarantee is made by the arrow.
02:04:12 <Ferdirand> so, for instance
02:04:22 <halogenandtoast> If I want to make a desktop application that emulates a boardgame (need to draw sprites, drag and drop, etc.) is there a suggested library to use
02:04:27 <halogenandtoast> SDL, Cairo, other?
02:04:28 <Ferdirand> there would be no valid implementation of "A -o (A,A)"
02:04:30 <Ferdirand> ?
02:04:54 <Ferdirand> i mean forall A. ...
02:05:00 <tsahyt> Ferdirand: there shouldn't be, no.
02:06:21 <Ferdirand> so, the wiki page says you can also add weights for bindings ?
02:06:42 <tsahyt> Ferdirand: foo :: forall a b. (a,b) -o a; foo (a,b) = a is also illegal, since the b is never used
02:06:44 <Ferdirand> so presumably, such a binding can only be consumed by a -o, but not a -> ?
02:06:46 <trigone> tsahyt: maybe i'm wrong but, technically, with laziness you could put bottom on the left or the right, and as long as it's not being used i guess it's valid? obviously it's useless (i think) though
02:07:40 <trigone> tsahyt: what's the problem with not using b?
02:07:44 <tsahyt> trigone: I suppose you're right, but that's not *really* because of laziness, but because bottom inhabits every type.
02:07:50 <Ferdirand> sorry if this is a naive question but this is the first time i see such a thing, and the "semantics" section of the wiki page is completely opaque to me
02:07:53 <tsahyt> well you've promised that the b gets used in the type signature and then you're not using it
02:08:30 <trigone> tsahyt: well with strictness it'd raise an error wouldn't it? and therefore would act as partial function... i'm not sure as i said i don't have the intuition of strictness in a pure environment
02:08:55 <tsahyt> Ferdirand: yes, the binding for the a inside an a -o b can only be consumed by another linear function I think. otherwise the guarantee goes out the window.
02:09:31 <tsahyt> but I'm also not 100% sure about all those things, I've read the paper a few months ago, except for the section on the actual typing rules, which got a bit opaque for me
02:09:46 <tsahyt> this blog post is rather useful for understanding though https://www.tweag.io/posts/2017-03-13-linear-types.html
02:09:49 <BernhardPosselt> tsahyt: yep extensible effects is the alternatives. What I'm trying to say is: what are real benefits and not just "baggage" that you need to deal with when using the typeclasses
02:09:57 <BernhardPosselt> alternative*
02:09:58 <tsahyt> trigone: it'd raise a runtime error, it'd still type check
02:10:04 <trigone> tsahyt: wrt unused b: yes i understand that, but why the need to be certain that b is being used? what's the kind of problem that it tries to solve?
02:10:23 <trigone> tsahyt: oh true
02:10:36 <ventonegro> trigone: https://www.tweag.io/posts/2017-08-03-linear-typestates.html
02:11:23 <tsahyt> BernhardPosselt: I'm not sure I understand your question
02:12:00 <BernhardPosselt> tsahyt: rephrased: why would i want to have a Functor interface
02:12:08 <trigone> tsahyt: thanks for the links!
02:12:13 <Ferdirand> mhh
02:12:31 <Ferdirand> "a simple, unintrusive design that can be grafted to your favourite functional language at no cost for the programmer"
02:12:44 <BernhardPosselt> what does Functor give me that makes me want to pull out an interface/typeclass
02:13:02 <BernhardPosselt> i mean i could just implement map methods without Functor interfaces
02:13:05 <tsahyt> BernhardPosselt: several reasons. for starters it's quite nice to have one function that lifts functions over the (conceptual) functor, i.e. fmap. you also get <$ for free, which is also nice. but then there's more. you can now write functions that work over *all* functors. the entire lens library vitally depends on this for example.
02:13:18 <tsahyt> you couldn't do that if you were to write a special map function for every type
02:13:19 <trigone> BernhardPosselt: ad-hoc polymorphism, aka you can write functions which will take any functor and do stuff to it
02:13:31 <dminuoso> BernhardPosselt: If it's a Functor, then it's accepted in any place that requires a Functor.
02:13:31 <[exa]> BernhardPosselt: typeclasses are required for overloading, ad-hoc overloading resolution is NP-complete
02:13:49 <BernhardPosselt> well, thats all arguments for why you want interfaces/typeclasses in general
02:14:04 <[exa]> BernhardPosselt: the other possibility is to have uni-directional type "inference", like in C++
02:14:19 <Ferdirand> i shudder at the thought of one day wanting to read code, and find a bunch of "-o" where the "->" used to stand, and get completely confused by an entirely new set of type errors i won't understand :|
02:14:27 <dminuoso> [exa]: If C++ only had concepts :(
02:14:36 <BernhardPosselt> tsahyt: lens library is a good example, but i dont think you need that in other languages
02:14:46 <[exa]> dminuoso: weren't they scheduled for c++19 ?
02:14:53 <BernhardPosselt> lenses are result of immutability, right?
02:14:55 <trigone> you don't choose the functor, the functor chooses you... it's about composability and reusing code. the functor is just an observation of pre-existing pattern, it's not an invention.
02:15:16 <dminuoso> [exa]: By C++19 you mean C++11, removed for complexity, then ignored, then reduced, and then delayed until C++2x possibly
02:15:16 <BernhardPosselt> so what really useful function is there that requires a Functor?
02:15:22 <tsahyt> BernhardPosselt: why? lens isn't just record accessors, the abstraction is extremely powerful.
02:16:15 <BernhardPosselt> tsahyt: oh, what else is there to it?
02:16:20 <[exa]> dminuoso: well, main thing about concepts is that their syntax is totally incompatible with the rest of C++, and the only improvement is that error messages are more readable (which is actually not an appreciated goal for C++ crowd)
02:16:24 <tsahyt> and why the Functor class is a thing is like wondering why gravity is a thing. it's not newton that made gravity. gravity was there first, newton named it. Same with functors.
02:17:02 <BernhardPosselt> tsahyt: sure, but that approach is not something that makes me want to learn Functors
02:17:40 <BernhardPosselt> i want to know a specific usecase that would otherwise be hard to solve without Functors
02:17:51 <BernhardPosselt> or very repetitive
02:18:52 <[exa]> BernhardPosselt: rename "Functor" to "WrappedThing" for a moment, it gets much more intuitive if you forget about CatT naming
02:19:26 <Ferdirand> yes you could have a bunch of map functions instead
02:19:47 <Ferdirand> but would you really like to have to write mapList, mapMaybe, mapIO, ... ?
02:19:50 <halogenandtoast> > 1 + 1
02:19:52 <lambdabot>  2
02:20:00 <mekeor> *applause*
02:20:04 <[exa]> IT WOERKS
02:20:08 <ventonegro> BernhardPosselt: But Functor is an abstraction of a *repetitive* pattern, namely transforming things wrapped in some structure
02:20:13 <halogenandtoast> I was just making sure "others" could see what I typed
02:20:41 <trigone> what's the deal with 1+1?
02:20:56 <ventonegro> BernhardPosselt: Once you see it, you cannot unsee Functors
02:21:03 <halogenandtoast> trigone: it's 2
02:21:07 <dminuoso> [exa]: https://gist.github.com/dminuoso/c0d1fea461d2f4798d6d6b793247a50a
02:21:16 <BernhardPosselt> background: I want to present Functor to a bunch of java devs and I want to tell them why this interface is worth pulling map out into an interface (yeah, i know, no HKT in java :D)
02:21:18 <dminuoso> [exa]: It's not just hard to read. The diagnostics are basically worthless.
02:21:20 <tsahyt> Ferdirand: even if you did that, you'd now get to write specialized versions of many other things, e.g. set and over
02:21:32 <BernhardPosselt> for Applicative Functor there's traverse which is really nice
02:21:56 <ventonegro> BernhardPosselt: That's not how teaching Haskell works. You cannot go there and say "Haskell is cool because Functors".
02:22:11 <BernhardPosselt> ventonegro: right, I'm not teaching haskell :D
02:22:34 <trigone> halogenandtoast: no kidding ^^
02:22:35 <tsahyt> BernhardPosselt: well that's probably not suitable for the java presentation, but functors compose. so say you have a list of maybes or something, both are functors. then you have a functor for the composition. so you can map over the elements in the maybes in the list, without writing extra stuff
02:22:41 <tsahyt> all you need to do is to specify the composition
02:22:49 <tsahyt> and this can of course go arbitrarily deep
02:22:53 <BernhardPosselt> I'm basically trying to present Haskell patterns in Java, then once all the basic stuff is understood use a new syntax
02:23:02 <tsahyt> and it's not like all functors are containers either. see the Const functor for example
02:23:09 <dminuoso> [exa]: With this it might be obvious if you just look at the code, but when you start having non-trivial types you can blow this to extreme proportions (though 260 lines of just internal obscure errors is already extreme)
02:23:36 <BernhardPosselt> tsahyt: oh, thats neat, how would i write that?
02:24:10 <BernhardPosselt> basically: the transition from OOP to functional is hard enough, no need to throw a new syntax and type system at them as well :D
02:24:27 <tsahyt> BernhardPosselt: Data.Functor.Compose provides the machinery there
02:24:33 <BernhardPosselt> ty :)
02:24:49 <cocreature> BernhardPosselt: the problem is that Haskell patterns are not always useful in Java
02:24:52 <tsahyt> BernhardPosselt: this also still works for applicatives
02:25:04 <tsahyt> it does no longer work for monads, because they don't compose
02:25:46 <BernhardPosselt> cocreature: right, but a lot of them are. Also I'm thinking of examples like "wouldn't it be cool if i could just do X? "
02:25:54 <dminuoso> tsahyt: monads compose
02:26:01 <[exa]> dminuoso: the most basic problem is that you don't see the first error first in the terminal :] it screams "oh I cant minus the iterators"
02:26:06 <dminuoso> its just not closed under composition
02:26:18 <tsahyt> dminuoso: so the composition of a monad with a monad isn't always a monad
02:26:24 <cocreature> BernhardPosselt: I have my doubts that this is a good approach :)
02:26:33 <ventonegro> cocreature: +1
02:26:34 <[exa]> dminuoso: but I get it, I'm just unix-ish in this way
02:26:38 <tsahyt> dminuoso: I mean that's what the docs say anyhow
02:27:20 <BernhardPosselt> well, I tried to show them Monoids once and listed the laws from math with explanations. Everyone tuned out :D
02:27:34 <BernhardPosselt> "oh, it's math *brain shuts off"
02:27:44 <[exa]> unlearn Java for great good
02:27:58 <dminuoso> [exa]: Some deeply internal "I cant minus the iterators" does not tell you what's wrong though.
02:28:18 <dminuoso> Especially if you dont know what substitutions occured
02:28:30 <cocreature> BernhardPosselt: just ignore the fact that it comes from math and use examples to demonstrate why it’s useful. http://ozark.hendrix.edu/~yorgey/pub/monoid-pearl.pdf has some great examples
02:28:36 <[exa]> dminuoso: the types are right under the error message
02:28:57 <dminuoso> [exa]: So in general C++ terms, what's wrong with the code? 
02:28:58 <tsahyt> BernhardPosselt: you can also use this composition stuff to build up rather complex types of simpler ones. As some contrived example, newtype ListIntMap a = ListMap { getListMap :: Compose IntMap [] a }, and you can then use generalized newtype deriving to get functor and applicative for free, etc.
02:29:06 <tsahyt> that's also a result of having Functor as a class
02:29:22 <dminuoso> [exa]: I mean just based on the error message.
02:29:28 <[exa]> dminuoso: but don't get me wrong, I'm not saying it's right, I'm just saying that it's hardcore and there are people who like it that way.
02:29:28 <tsahyt> and since the composition is again a functor and an applicative you can nest this arbitrarily 
02:29:45 <dminuoso> [exa]: Heh. https://tgceec.tumblr.com/ :-)
02:29:45 <[exa]> dminuoso: sort expects better iterators
02:30:11 <kurolox> Hello!
02:30:17 <dminuoso> [exa]: Perhaps, in reality you can't tell because it's possible with the wrong types it picked up the wrong specializations and ended up doing something silly.
02:30:20 <[exa]> I saw someone implementing fixpoint for that contest :D
02:30:29 <kurolox> Quick question, is there any way to make ghc completely silent unless there are any errors?
02:30:45 <[exa]> dminuoso: yeah, "hardcore"
02:30:50 <dminuoso> Heh.
02:32:09 <[exa]> kurolox: you can wrap it in some unix commandline magic, I'm not sure if there's an option for that
02:32:21 <[exa]> kurolox: what'd be the usecase?
02:33:14 <[exa]> dminuoso: the other point is that c++ programmers like to break stuff in weird ways. Iterators with side effects are unthinkable for OOP people, but perfectly OK for assembly crowd
02:33:44 <kurolox> I'm making a bot that runs code, but if the compiler says anything it's considered an error. The other languages I've tried are silent if everything goes well, so haskell not being completely silent means that it will always throw an error.
02:33:50 <[exa]> dminuoso: (the example is terrible, but I saw someone doing runtime IR optimizations with that)
02:34:05 <kurolox> I could try to do some unix stuff, but that only will work if stdout and stderr are implemented properly
02:34:20 <[exa]> kurolox: what about catching ghc's exit code?
02:34:30 <tabaqui> oh, Yampa 10.6.2 doesn't depend on hcwii
02:34:52 <tabaqui> someone has send him a message?
02:35:02 <kurolox> That would be a good idea, but I'll try to make it silent for now and if I'm unable I'll go back to it
02:35:24 <dminuoso> [exa]: Well I've worked with boost. In one particular example I managed to produce around 8,000 lines of diagnostics, just because my container didn't satisfy some condition. Boost is hardcore squared for diagnostics. ;-)
02:35:59 <[exa]> boost, "stuff so brutal they didn't let it even in C++ std"
02:36:17 <[exa]> ok let's stop hating c++ :D
02:36:26 <tsahyt> BernhardPosselt: I just thought of something else. Free monads depend on Functor being a class.
02:36:29 <dminuoso> Im just hating lack of concepts :P
02:36:37 <dminuoso> But fair enough.
02:36:55 <cocreature> tabaqui: https://github.com/fpco/stackage/issues/2772
02:37:04 <tsahyt> The whole machinery just wouldn't work without it. you'd have to implement your free monad manually without the ad hoc polymorphism provided by the class, so they'd be significantly less free in practice.
02:37:18 <BernhardPosselt> tsahyt: thanks for the input! will take a look :)
02:37:21 <[exa]> kurolox: the wrap could be something like :   ( ghc $@ 2>/tmp/errors-$$.txt || echo /tmp/errors-$$.txt ; rm /tmp/errors-$$.txt )
02:37:29 <BernhardPosselt> the compose package is already very useful
02:37:41 <kurolox> Yeah, I've been testing. Dumping stdout should be enough, since the errors go through stderr
02:37:44 <kurolox> thanks for the help exa!
02:37:57 <[exa]> dminuoso: anyway, did you see the syntax for the concepts? :D
02:38:28 <tabaqui> cocreature: nice
02:38:36 <dminuoso> [exa]: Yes. Its actually not too shabby.
02:39:08 <dminuoso> [exa]: We C++ developers have been abused by really strange notation, dots and brackets flying around everywhere. 
02:39:43 <[exa]> I'll start considering it hardcore as well       *fixed*
02:40:01 <Rembane> mnoonan: That's really nifty! Nice!
02:40:23 <[exa]> but still I always wonder why they just don't include full prolog as an extra compiler pass
02:40:57 <dminuoso> [exa]: Haskell is really refreshing. I mean there's actually a lot of similarities in templates and Haskell, but Haskell has this really concise and elegant syntax to it.
02:41:17 <dminuoso> Was amazed about type declarations from day one.
02:46:07 * hackagebot structured-cli 0.9.1.0 – Application library for building interactive console CLIs – https://hackage.haskell.org/package/structured-cli
02:46:07 * hackagebot labels 0.3.3 – Anonymous records via named tuples – https://hackage.haskell.org/package/labels
03:47:47 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
03:47:47 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
04:21:59 <defstryker> Anybody try the codewars website?
04:23:53 <ph88_> ya
04:23:56 <ph88_> only first exercise though
04:23:59 <ph88_> was fun
04:24:06 <merijn> hmmm, on unix is there a way to write stuff to a file, but not have the file be visible in the FS until after some final "flush"?
04:24:37 <merijn> I could make a temp file and move it after being done, but that's not ideal, since I'd be leaking tempfiles if my process dies before the final move
04:26:55 <ph88_> why would the process die ? :p
04:27:15 <merijn> ph88_: Because stuff on the cluster gets killed after I run out of processing time
04:27:33 <cocreature> solution: get more processing time
04:27:43 <merijn> ph88_: So I need something that work gracefully in the process of SIGKILLs occuring at random point during processing
04:28:26 <merijn> cocreature: The rule is "no processes longer than 15 minutes during working hours" (so that people can interactively test stuff with reasonable turn around), so that's a no go
04:28:55 <merijn> cocreature: I'm writing some code that stuffs as many tasks as I can within the timeslice I have, but I need to handle stuff getting killed before finishing somehow
04:28:57 <ph88_> you can write temp files to /tmp and they get cleaned automatically i think
04:29:40 <merijn> ph88_: /tmp only gets cleaned on reboot (which happens infrequently) and my files are large
04:29:52 <merijn> ph88_: So I might run myself out of diskquota that way
04:30:04 <ph88_> you can check for leftover tmp files when you restart
04:30:08 <cocreature> can’t you just check on startup for stale files?
04:30:08 <merijn> ph88_: I guess I could allocate a tmp folder per batch and nuke it after each one
04:30:32 <cocreature> i.e. don’t try to exit cleanly, instead move the cleanup process to the beginning of the next run
04:30:47 <ph88_> maybe your program gets some time to do cleanup when it gets a signal from OS
04:30:57 <merijn> cocreature: Well, I wanna launch a new job as soon as it ends, but processing of results may still be running. But I guess I can tackle that by having a folder per batch
04:31:02 <merijn> ph88_: no, it's SIGKILL
04:31:08 <merijn> ph88_: Already tried that
04:40:14 <defstryker> ph88_: Have you per chance attempted this one: https://www.codewars.com/kata/sort-the-odd/haskell ?
04:40:55 <defstryker> Imperatively, in python I could find a solution but being a noob in haskell its maddening
04:40:56 <ph88_> defstryker, no but i can try it if you want
04:41:00 <ertes-w> lo
04:41:21 <defstryker> ph88_, thanks that's be awesome
04:42:40 <ertes-w> > (partsOf (traverse . filtered odd) %~ sort) [5, 3, 2, 8, 1, 4]
04:42:42 <lambdabot>  [1,3,2,8,5,4]
04:43:15 <dddddd> merijn, maybe https://stackoverflow.com/questions/4171713/relinking-an-anonymous-unlinked-but-open-file
04:43:40 <defstryker> wow... haven't yet come across '%~' in LYAH. Back to studying
04:43:58 <ertes-w> defstryker: i doubt that LYAH explains lenses to this extent, if at all
04:44:02 <tsahyt> defstryker: that's likely because lens is not part of LYAH
04:44:11 <ertes-w> in fact i think LYAH is older than van laarhoven lenses
04:44:51 <defstryker> The haskell docs then?
04:44:59 <ertes-w> @package lens
04:44:59 <lambdabot> http://hackage.haskell.org/package/lens
04:45:01 <ertes-w> defstryker: ^
04:45:14 <tsahyt> :t partsOf
04:45:16 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
04:45:55 <ertes-w> tsahyt: turns a traversal into a lens for all points collectively
04:46:12 <ertes-w> in particular: partsOf traverse = traverse
04:46:29 <tsahyt> :t partsOf (traverse . filtered odd)
04:46:30 <lambdabot> (Functor f, Integral a, Traversable t) => LensLike f (t a) (t a) [a] [a]
04:46:38 <ertes-w> err
04:46:39 <ph88_> defstryker, the easiest way i can think of is keeping track of the positions of the numbers
04:46:43 <tsahyt> hm, so that's a lens on only the odd numbers?
04:46:48 <ertes-w> ignore the equation…  that was non-sense
04:46:51 <ertes-w> yeah
04:46:58 <merijn> dddddd: That's linux only, though :)
04:47:16 <tsahyt> that's quite cool
04:47:20 <tsahyt> it also looks deeply magical
04:47:29 <tsahyt> but that's just because I still don't understand lens properly
04:47:33 <tsahyt> not in depth anyhow
04:48:33 * hackagebot relational-query-HDBC 0.6.4.1 – HDBC instance of relational-query and typed query interface for HDBC – https://hackage.haskell.org/package/relational-query-HDBC
04:49:22 <ertes-w> @let alphaCase f c | isUpper c = bool (toLower c) c <$> f True | isLower c = bool c (toUpper c) <$> f False | otherwise = pure c
04:49:23 <lambdabot>  Defined.
04:50:22 <ertes-w> > (partsOf (traverse . alphaCase . filtered id) %~ reverse) "Hello World!"
04:50:25 <lambdabot>  "Hello World!"
04:51:21 <ertes-w> > toListOf (traverse . alphaCase . filtered id) "Hello World!"
04:51:23 <lambdabot>  [True,True]
04:51:41 <ertes-w> oh, i see
04:52:48 <ertes-w> > (partsOf (traverse . filtered toUpper) %~ reverse) "Hello World!"
04:52:50 <lambdabot>  error:
04:52:50 <lambdabot>      • Couldn't match type ‘Char’ with ‘Bool’
04:52:50 <lambdabot>        Expected type: Char -> Bool
04:53:01 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Hello World!"
04:53:03 <lambdabot>  "Wello Horld!"
04:53:25 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Sony Playstation"
04:53:27 <lambdabot>  "Pony Slaystation"
04:54:26 <srk> lol
04:57:20 <defstryker> any other way other than lenses? Lenses, to my current understanding is sorcery
04:58:40 <ertes-w> defstryker: write a function that maps a function over the sublist of odd numbers
04:59:20 <ertes-w> partialMap :: (a -> Bool) -> ([a] -> [a]) -> [a] -> [a]
04:59:32 <defstryker> seems easier. will give it a go asap thanks
05:01:27 <ph88_> defstryker, i'm finished
05:08:47 <ph88_> what's the "as" keyword about ?
05:10:20 <ertes-w> ph88_: 'as' is only a keyword in the context of an import statement
05:10:36 <ertes-w> import qualified Data.Map.Strict as M
05:11:14 <ph88_> oh right
05:11:26 <ph88_> it was just bad syntax highlighting on a website that i thought it was a keyword ^^
05:11:51 <ertes-w> you should use lpaste or gist =)
05:12:00 <ertes-w> or your editor
05:12:07 <ph88_> https://www.codewars.com
05:12:30 <merijn> ertes-w: Github's syntax highlighting is pretty bad too
05:13:59 <ertes-w> merijn: yeah, but it's better than most others', particularly than what seems to be the most popular pastebin these days, pastebin.com
05:16:25 <vektorweg1> so, there is still no haskell/sml-like lightweight scripting language that can be built into applications? like lua, but awesome?
05:17:19 <ventonegro> vektorweg1: funny, I thought myself that today
05:18:17 <ertes-w> vektorweg1: you could do what many haskell projects do: instead of embedding the language into your application, do it the other way around: write your application as a *library* and let the user "configure" it by writing a program in haskell
05:18:48 <ertes-w> vektorweg1: popular projects using this idea are: hakyll, shake, xmonad
05:21:16 <[exa]> ertes-w: that might require restarting for switching the scripts though
05:21:19 <vektorweg1> ertes-w: you still need to supply ghc tho. if i want to make a small game, shipping ghc feels like overkill. 
05:22:35 <[exa]> vektorweg1: how much of the haskell featureset would you want? (interpretting haskell is basically equal to shipping ghc btw)
05:23:52 <vektorweg1> [exa]: i guess the stuff in base would be enough, when i think about games were players can code a bit. 
05:24:37 <vektorweg1> oh
05:24:41 <[exa]> https://hackage.haskell.org/package/baskell ?
05:25:12 <merijn> vektorweg1: Well, write your own? :)
05:26:08 <vektorweg1> [exa]: sounds like a nice package. but its not working anymore. 
05:26:17 <[exa]> bah. :]
05:26:44 <vektorweg1> merijn: probably should. :|
05:27:05 <merijn> vektorweg1: Honestly, if you don't care about amazing performance, just a simple compiler it shouldn't be that hard
05:28:41 <ertes-w> [exa]: yeah, although restarts don't have to give up all state…  for example xmonad restarts without losing anything…  typically you only notice the restart, because the focus flashes, and even that could be avoided
05:28:50 <ertes-w> for a game it would be difficult to reproduce that though
05:29:21 <[exa]> vektorweg1: you might want to fork off this https://github.com/vituscze/norri (friend's work). Just remove the output and write a simple interpreter (which is 6-cases function or so, in this case)
05:29:49 <ertes-w> vektorweg1: well, you could embed a scheme, but consider that your will probably write most of the game logic in that scripting language, you potentially it would be best to actually require GHC and provide the full haskell language
05:30:15 <ertes-w> wow, that was terrible
05:30:36 <ertes-w> vektorweg1: well, you could embed a scheme, but considering that you will probably write most of the game logic in that scripting language it might be best to actually require GHC and provide the full haskell language
05:32:19 <ertes-w> note that there are two ways to embed haskell: either your game needs to be a library, and the main application is written in haskell, or you can use something like the 'hint' library to embed GHC's interpreter
05:32:40 <ertes-w> the latter is probably a better option for a game, because it allows you to switch scripts dynamically without restarting the game
05:33:41 <vektorweg1> i give it a thought. its still a lot of things i have to learn. 
05:34:26 <cocreature> you can also just shell out to ghc (or use the api) to compile things to object code and load those dynamically
05:41:54 <ertes-w> there is even a middle ground: you can use -fobject-code to let the interpreter compile to native code
05:42:18 <ertes-w> it's not quite as fast as regularly compiled code, but faster than the default bytecode
05:44:54 <vektorweg1> i guess digging deeper in lambda calculus and building a interpreter some day is still most fun from all the options. :p
05:45:28 <ertes-w> vektorweg1: definitely…  go ahead and do it, and then use haskell for your game anyway ;)
05:45:55 <cocreature> if you like programs that crash with terrible error messages, hot-loading code compiled via ghc is also a lot of fun :)
05:46:10 <vektorweg1> :D
05:46:22 <ertes-w> haha
05:47:15 <cocreature> almost as fun as looking at backtraces of your jit compiler and realizing that you tried to execute a null pointer
05:47:47 <ertes-w> i never had the pleasure, because i just go unix and write separate processes =)
05:48:02 <ertes-w> has the advantage that i can easily do "hot reloading" (just restart a component)
05:48:11 <cocreature> pff, that’s boring
05:48:56 <ertes-w> cocreature: oh, not at all…  writing your code to be fault-tolerant is not as easy as it sounds =)
05:49:11 <ertes-w> if a process goes away, the others need to deal with it
05:49:31 <cocreature> does crashing count as “dealing with it”? :)
05:49:52 <ertes-w> nope
05:49:57 <[exa]> vektorweg1: kindof reminds me of colobot, did you play colobot?
05:50:05 <ertes-w> you must not crash, and you must not lose information
05:50:47 <ertes-w> i'm not 100% confident that i have the latter issue fully under control yet, which is why i've been considering for a long time to switch to ZeroMQ
05:51:05 <ertes-w> but never actually done it
05:51:27 <vektorweg1> [exa]: i tried colobot, but coding c++ in a weak editor makes it awful. 
05:51:33 <ertes-w> (the other option is to use the filesystem, postfix/Maildir-style)
05:52:02 <ertes-w> ((and yet another option would be to use sqlite, but it doesn't support event-based concurrency))
05:52:13 <vektorweg1> to be fair, a graphical programming language would probably the best option for a game. one that can type check the components directly and only optional writing. 
05:53:14 * hackagebot strict-concurrency 0.2.4.2 – Strict concurrency abstractions – https://hackage.haskell.org/package/strict-concurrency
05:53:57 <merijn> ertes-w: How does ZeroMQ solve your "don't lose information" issue?
05:54:11 <merijn> ertes-w: What kinda consistency are you assuming? :p
05:54:36 <merijn> Because ZeroMQ uses sequential consistency and a lot of people on the idiot don't seem to understand that
05:54:57 <merijn> I meant to type internet when I wrote idiot
05:55:02 <merijn> But it seems appropriate...
05:55:06 <cocreature> that’s a nice typo :)
05:56:22 <ertes-w> merijn: i need eventual consistency, i.e. "what serf does"
05:56:51 <merijn> ertes-w: That doesn't help me decide whether ZeroMQ makes sense :)
05:57:08 <merijn> ertes-w: ZeroMQ *can* lose messages
05:58:46 <ertes-w> merijn: A needs to send a query to B…  if B goes down before receiving the query, A should just keep trying…  if B goes down after receiving the query, A should backtrack from the "wait for answer" phase to the "ask question" phase
05:59:02 <merijn> ertes-w: You'll have to implement that yourself
05:59:24 <ertes-w> merijn: ZMQ can't do that?  i thought it has that particular scheme built-in
05:59:35 <merijn> ertes-w: If A goes down with a message in-transit to B the message can be lost
06:00:02 <ertes-w> merijn: that's fine…  the more important scenario is when B goes down
06:00:08 <merijn> ertes-w: It will retry if B goes down before the message is sent
06:00:12 <[exa]> is there some (.) that would work on types? eg. for removing `a' from `IO(M1(M2 a))' that would write as `IO.M1.M2'
06:00:35 <ertes-w> [exa]: Data.Functor.Compose
06:00:44 <merijn> ertes-w: Possible scenario: send a message to ZMQ socket on A, flushed from ZMQ to network, B goes down, message lost
06:01:05 <merijn> ertes-w: Which is perfectly fine from a sequential consistency standpoint
06:01:46 <merijn> ertes-w: Because "message lost due to B going down with message in flight" is indistuingishable from "B went down *right* after the message was received from the network"
06:01:48 <[exa]> ertes-w: I'll rename it to :. for this case :] thanks
06:01:50 <ertes-w> merijn: wait…  doesn't ZMQ have multiple…  err…  "subprotocols"?  like one for pub/sub, and another for this particular kind of query/answer scheme
06:02:30 <merijn> ertes-w: If you need to guarantee message not getting lost you need to build that on top
06:02:37 <ertes-w> i see
06:02:46 <merijn> ertes-w: Since this requires the receiver to persist a message to disk before A can consider it delivered
06:03:26 <merijn> ertes-w: So that means you need some form of acknowledgement that a message has been persisted on the receiver
06:03:33 <merijn> ertes-w: Which opens up a whole can of worms
06:03:42 <merijn> ertes-w: Because what if you lose the acknowledgement
06:04:03 <ertes-w> merijn: actually i don't necessarily need persistence…  all i need is A not to get confused by B going away…  a simple loop that just does the whole query/answer process until it succeeds would be good enough most of the time
06:04:06 <merijn> ertes-w: Hence why ZeroMQ does sequential consistency. Anything else is way to expensive for general messaging
06:04:22 <ertes-w> the whole point is that A can keep running (e.g. processing requests from others) while i'm upgrading B
06:04:53 <merijn> ertes-w: Well, you'd still need to implement some form of retry then if A always has to get a reply
06:06:01 <ertes-w> well, i could probably use something like redis or even a full MQ framework like RabbitMQ
06:06:02 <ertes-w> just to make coding this easier
06:06:34 <ertes-w> but that's a lot of extra engineering compared to just looping until success =)
06:08:58 * JuanDaugherty likes 0mq
06:14:42 <merijn> hmm, if I have multiple executables that need to call each other, is there any sane way I can ensure they can find each other at runtime, or do I just hardcode the path to my repository?
06:17:54 <mlehmk> merijn, generally speaking, if the executables are in the search path, they should be found. But it is dependent on the operating system used
06:18:15 <merijn> mlehmk: I know that, but they are not in the search path because I'm not installing anything
06:18:33 <merijn> I just have a project repo where I build things and run them
06:28:52 <ertes-w> merijn: personally i'd just use PATH
06:28:57 <merijn> I wish I could just embed executables and fork...
06:29:28 <ertes-w> merijn: just extend PATH locally
06:30:01 <ertes-w> merijn: alternatively…  do you use nix?
06:30:12 <merijn> ertes-w: No
06:30:31 <merijn> ertes-w: I don't want my path cluttered up with them, tbh
06:30:35 <ertes-w> merijn: well, if you use a deployment system, it probably has a facility to do that
06:31:01 <ertes-w> merijn: nix would make that particularly easy
06:31:05 <merijn> ertes-w: There is no deployment system
06:31:19 <merijn> There's no deploying either
06:31:52 <ertes-w> then consider using one =)
06:32:33 <merijn> ertes-w: With what goal? Seems I could save a whole bunch of time by just hard-coding the repo path at build time instead
06:33:36 <ertes-w> merijn: the goal would be to handle cases like this dynamically and flexibly…  if you don't need that, sure, just hard-code the path
06:33:48 <ertes-w> alternatively use an environment variable other than PATH to communicate the repo path
06:34:23 <merijn> ertes-w: The only thing it really needs to handle is "I might clone this repo and work with the clone for a bit"
06:34:54 <ertes-w> but there is no real reason to do that…  i would just use PATH (note that you can use relative paths there)
06:35:13 <ertes-w> PATH="./bin:$PATH" bin/prog1
06:35:41 <merijn> ertes-w: deciding on a deployment system, figuring out how it works, and making it do what I want doesn't sound like the time/improvement ratio is worth it :)
06:36:25 <ertes-w> merijn: sure, although you might benefit from it in the long run, especially if you learn something like nix, which is much more than just a deployment system
06:37:04 <merijn> ertes-w: In the long run, anyone who wants to run this on some other system can go sort it out themselves :p
06:40:04 <cocreature> merijn: but … reproducible research! :(
06:40:17 <ongy> reproducible builds!
06:41:05 <merijn> cocreature: I already made it as portable as I can. Anyone who thinks it's not portable enough can either sod-off, define a universal target for software artifacts that I could work against, or pay me to fix it :)
06:41:21 <nshepperd_> merijn: you should be able to get the path of the current executable. From whatever the equivalent of argv[0] is. Then derive your repo path from that
06:41:24 <ertes-w> merijn: you could use the paul graham approach to do the work: let someone else get pissed off enough by your lack of conscientiousness that they do it for you =)
06:42:58 <ertes-w> nshepperd_: argv[0] does not necessarily have the full path
06:43:27 <ertes-w> in fact it only does when you actually invoke the program with its full path
06:43:36 <nshepperd_> That's ok, in that case it is relative to the current dir
06:43:50 <merijn> nshepperd_: Not really
06:44:35 <nshepperd_> getExecutablePath in System. Environment
06:44:43 <ertes-w> well, you could extract the dirname from argv[0]
06:44:48 <ertes-w> but that's a really really ugly solution =)
06:45:23 <ertes-w> also, if relevant, it doesn't take the current working directory into account
06:46:48 * hackagebot ble 0.4.1 – Bluetooth Low Energy (BLE) peripherals – https://hackage.haskell.org/package/ble
06:47:48 <nshepperd_> I don't see how you think the current working directory needs to "taken into account"
06:48:08 <merijn> ertes-w: Well, I think it'd at least work to find the other executables, since as nshepperd_ points out it's either a valid relative path, or it must be on PATH itself, in which case relative paths wrt to the repo should work, since those would be relative to path then too
06:48:33 <ertes-w> nshepperd_: "if relevant": when your program changes the CWD, as some programs do, you need to take it into account, because then the dirname is relative to the wrong directory
06:48:37 <nshepperd_> Just do this at the start of your program, before you chdir
06:49:02 <nshepperd_> Calculate the absolute path, that is
06:49:20 * JuanDaugherty also misses a hs universal application/software abstraction/target
06:49:21 <ertes-w> merijn: but how is that less work than just extending PATH?
06:49:58 <ertes-w> if you go with PATH, you would actually account for cleaner solutions for people, who want to use them
06:49:59 <merijn> ertes-w: because I don't have to update PATH when using a different clone of the code
06:50:23 <ertes-w> if you hardcode your own executable finding logic instead, those people will have trouble
06:50:37 <JuanDaugherty> as soon as anybody thinks "app server" bip boom bang they land pronto in a web server
06:51:24 <merijn> ertes-w: Fortunately, I don't get paid to worry about other people :)
06:51:53 <ertes-w> merijn: well, hypothetically speaking, does your program A even need to execute program B by itself?  or is it just a coprocess that it needs to communicate with?
06:51:55 <Iceland_jack> I worry about other people in my free time
06:52:20 <merijn> ertes-w: It's being exec'd, yes
06:54:22 <JuanDaugherty> not even a generalized net protocol server, weird for a community where generalization is supposed to such a thing
06:54:53 <ertes-w> merijn: i would pick one of three options (potentially a combination): 1. use PATH, 2. if applicable use a process supervisor like s6, 3. use a deployment solution
06:55:01 <ski> merijn : hm, could one say you wanted static scoping for executables ?
06:55:34 <ertes-w> most of the time i combine 2 and 3
06:55:35 <merijn> ski: Yes, similar to what's being worked on for cabal-install 2.x, yes. Although not all my executables are Haskell ones
06:56:41 <ertes-w> merijn: honestly i think PATH is the easiest and still most flexible option…  again: remember that you can use relative paths
07:03:58 <merijn> ertes-w: I don't see how relative paths help?
07:05:03 <ertes-w> merijn: if you have "./blah" in PATH, then when you cd into your fork and invoke it there, it will use 'blah' from the fork
07:10:08 <mlehmk> "./blah" is a relative path, it shouldn't be searched in PATH
07:10:56 <tdammers> relative paths in $PATH are evil
07:11:23 <ertes-w> only if you add them to your shell profile
07:11:24 <mlehmk> I mean, if you tell to execute binary "./blah" then it should be looked up in the CWD only, not searched in PATH
07:12:24 <ertes-w> PATH=./blah blah/myprogram
07:12:47 <ertes-w> now 'myprogram' can find other programs in ./blah
07:20:27 <tabaqui> what is faster: IntMap or Map with bounded integer type (like Word32)?
07:21:51 <cocreature> tabaqui: that’s a question you can only really answer with benchmarks :)
07:22:00 <mud> tabaqui: IntMap for almost everything
07:22:05 <cocreature> tabaqui: note that the key in IntMaps is Int not Integer so it is also bounded
07:22:48 <tabaqui> I mean, Word32 can be optimized on x86 arch
07:23:03 <tabaqui> while Int has about 60 bits length
07:23:17 <tabaqui> *30
07:23:19 <tabaqui> hmm
07:23:35 <tabaqui> okay, "Map Word16 a" or "IntMap a"
07:24:13 <cocreature> the answer is still “benchmark if you care about the difference”
07:24:25 <Cale> tabaqui: Int will typically be whatever integer type is fastest for the given architecture
07:24:27 <cocreature> but mud is right that IntMap is probably going to win
07:24:31 <mud> It's not going to change the answer. It's generally not even close. You really should benchmark though if it matters, yeah.
07:24:50 <Cale> I would expect Word32 to be worse than Int usually.
07:25:02 <tabaqui> it matters :(
07:25:13 <tabaqui> ah, I hate to write benchmarks
07:25:30 <mud> The one trouble I ever run into with IntMap is IIRC it's size test is Θ(n), so if you're using that much you have more to think about.
07:25:33 <cocreature> the apis are basically the same so swapping out one for the other is almost trivial
07:25:43 <ertes-w> tabaqui: IntMap is a safe preference when it comes to performance
07:26:54 <tabaqui> ertes-w: dunno, I thought that it is true only when other keys are non-numerical
07:27:16 <tabaqui> but almost all Maps have the same speed with Ints
07:27:45 <mud> That doesn't sound right.
07:28:13 <cocreature> if "Map Int v" and "IntMap v" had the same performance characteristics, IntMap wouldn’t need to exist
07:28:16 <Cale> tabaqui: Map has a totally different internal structure from IntMap
07:28:37 <tabaqui> cocreature: sounds logical :)
07:28:41 <cocreature> https://github.com/haskell-perf/dictionaries has some benchmarks
07:28:42 <Cale> It does order comparisons, whereas IntMap is based on binary prefixes
07:29:41 <nshepperd_> Isn't word32 secretly 64 bits anyway (on x86-64)
07:30:13 <tabaqui> > sizeOf
07:30:15 <lambdabot>  error:
07:30:15 <lambdabot>      • Variable not in scope: sizeOf
07:30:15 <lambdabot>      • Perhaps you meant one of these:
07:30:18 <nshepperd_> Just with different instances
07:31:05 <mud> nshepperd_: Is it? That sounds like it'd make its overflow behavior annoying to implement for no gain. Just guessing though.
07:31:45 <alexbiehl> yes, internally Word8, Word32, Word64 are all represented the same on x64
07:33:53 <alexbiehl> (there is an ongoing effort to make them distinct)
07:46:58 * hackagebot grouped-list 0.2.1.3 – Grouped lists. Equal consecutive elements are grouped. – https://hackage.haskell.org/package/grouped-list
08:04:03 <iomotoko> do I understand it correctly that there are not yet physical copies of http://haskellbook.com/ ? cause I am not willing to pay 59 USD for a .pdf file... :/
08:04:40 <srhb> iomotoko: As far as I know, yes 
08:05:09 <iomotoko> srhb: k ty
08:05:15 <iomotoko> just wanted to double check by asking here
08:06:04 <merijn> afaik there isn't one planned either
08:06:08 <merijn> Due to the size of the book
08:06:25 <merijn> It's like 1100 pages iirc
08:10:19 <jared-w> my version of the book is a whopping 1233 pages. It'd be a bit ridiculous to print that :p
08:13:19 <ertes-w> that's massive
08:13:37 <ertes-w> why is it so huge?
08:13:47 <MarcelineVQ> idk why you'd want a print version, the whole book is exercises, you're not gonna learn how parts work by reading it in bed or something. That's the lesson that Learn You A Haskell will teach you, reading a text doesn't teach you a text.
08:13:51 <merijn> ertes-w: Because it's rather slow and in-depth?
08:14:19 <ertes-w> merijn: LYAH levels of slow?
08:14:25 <merijn> MarcelineVQ: Paper can be easier to skim
08:14:57 <merijn> ertes-w: Possibly slower
08:15:08 <merijn> ertes-w: Certainly more thorough than LYAH
08:15:41 <ertes-w> seems to be a popular approach to teaching haskell: just go veeeeeeery slooooooooooow
08:16:04 <merijn> ertes-w: I think you might be underestimating how hard things are when you're still clueless :)
08:16:10 <MarcelineVQ> If you get it it's not slow.
08:16:22 <MarcelineVQ> Getting it is slow :D
08:16:29 <jared-w> Right, and it's really not an issue to me honestly
08:16:43 <merijn> I only have 2nd hand experience with Haskell Book, though, so take my opinion with a grain of salt
08:17:07 <jared-w> I already was very familiar with LC and with some of the basics and all that so I just breezed through the first 5 chapters really fast, worked through the next 5 fairly quickly as well and was ~400ish pages in after a couple days
08:17:46 <jared-w> One of the benefits of it being slow is that it explains things in quite a bit of detail, but it's still laid out well enough that you can skim through without being afraid of skipping a gem hidden inside of the "stuff you already know/are familiar with" parts
08:17:48 <ertes-w> i have none at all, and prior to just now i would have been open to reviewing it (given a free copy)
08:17:49 <MarcelineVQ> imo it's big because it's 50% exercises and examples, so that you get it, if you complete them instantly it's a much smaller book
08:18:01 <ertes-w> but i'm not gonna review a tree's worth of book =)
08:18:28 <merijn> I'm not entirely happy with the focus of the earliest set of chapters, tbh
08:18:31 <ertes-w> although lots of examples and exercises sounds good
08:18:36 <merijn> too many strings and lists
08:19:08 <erisco> what is a string but a list
08:19:30 <ertes-w> merijn: it's a common haskell teacher's disease
08:20:09 <jared-w> The string and list is to get you familiar with explicit recursion, which most people suck at
08:20:24 <ertes-w> but lists are a gentle way to introduce people to the idea of parametric recursive types, because parametric lists are a concept that most people either already understand or can be easily explained to them
08:20:33 <merijn> jared-w: It causes it to be overly focussed on existing programmers, imo
08:20:38 <jared-w> Then you get into folds and it's like "oh mah gawd"; plus, strings and lists are trivial data structures to build up and create for small exercises
08:20:39 <erisco> seriously, how many times do people come around, helpless and wandering, saying "what shall I do with Haskell?"
08:20:42 <ertes-w> at least in my experience (in in-person workshops)
08:20:51 <merijn> ertes-w: "parametric lists are easy to explain" <- hah, not really
08:21:06 <merijn> ertes-w: If they can already program, maybe
08:21:10 <jared-w> merijn: I do agree somewhat on that. I've seen a /lot/ of needless fumbling around because the book somehow manages to be incredibly friendly to "people without programming experience" yet somehow only reads well if you have programming experience :p
08:21:20 <erisco> we should behoove ourselves to compile a list of Haskell problems
08:21:33 <ertes-w> merijn: even if not, once they have understood the basic concepts of functions and pattern-matching, it's easy enough to explain
08:21:40 <merijn> jared-w: Yeah, I'm not sold on the "friendly to people without programming" experience
08:21:53 <merijn> ertes-w: You underestimate how hard those two things are :)
08:21:59 <erisco> step one is to categorise, so we may grip our minds onto the macroscopic of this collection
08:22:24 <erisco> lists surely, fib and fac surely, and what other items should we procure?
08:23:35 <merijn> ertes-w: I've been helping my girlfriend work through the book when she gets stuck. I think you're thoroughly overestimating how easy things like that are to explain :)
08:23:53 <ertes-w> merijn: no, i don't: i run a haskell workshop every year with 15-20 participants on average…  it's not trivial, but i rarely need more than one evening to get people comfortable with lists (meaning that they can write list functions with explicit recursion)
08:24:05 <merijn> ertes-w: Programmers?
08:24:17 <mnoonan> are there any libraries out there to help with some light web scraping?
08:24:28 <merijn> http-conduit + html-conduit
08:24:46 <MarcelineVQ> mnoonan: type scrape into hackage and see if anything pops up
08:25:01 <merijn> mnoonan: I had a nice, simple example of a parallel scraper using those two, but it bitrotted due to changes in async
08:25:12 <ertes-w> merijn: depends on whether i invite non-programmers, which i do about half the time, and then usually about 3/4 of them are programmers
08:25:20 <merijn> mnoonan: But it should give you some ideas: https://gist.github.com/merijn/d8188ddd129718ffcfb0
08:25:21 <mnoonan> merijn, thanks, I've been wanting to tinker with conduits before anyway
08:25:37 <ertes-w> merijn: so about 3/8 of them are non-programmers on average
08:25:39 <merijn> mnoonan: It doesn't end up very conduit-y, though
08:26:05 <mnoonan> ah, i see. well, it does look straightforward enough. thanks!
08:26:20 <ertes-w> merijn: of course programmers have a much easier time, but when i reach the point where i start to explain lists, they are usually comfortable enough with haskell that they can write very simple toy programs
08:26:34 <merijn> mnoonan: The monad stack there doesn't work anymore, but you can probably easily steal bits of it for inspiration
08:26:38 <ertes-w> and they do understand the idea of type abstraction, because i cover the basics of that *before* going into lists
08:27:01 <ertes-w> (i do "strings" before that, but i don't explain right away what strings actually are)
08:27:34 <ertes-w> fun fact: IO is usually the first and last topic i cover =)
08:28:33 <erisco> good, IO sucks
08:28:35 <MarcelineVQ> actually sounds like you'd like the book
08:30:35 <ertes-w> MarcelineVQ: from what i know about it so far i like the "lots of examples and exercises" aspect, but i might disagree with its general pace
08:31:02 <erisco> earliest chapters of what, by the way?
08:33:12 <ertes-w> (but who am i to talk…  i have written a massive tutorial on a single haskell function) =)
08:33:39 <erisco> what do you teach before lists? lists require pattern matching and recursion
08:34:04 <ertes-w> erisco: exactly that
08:34:42 <jared-w> ertes-w: what was your massive tutorial on a single haskell function? 
08:34:46 <erisco> how early do you talk about types?
08:35:24 <ertes-w> erisco: immediately
08:35:33 <MarcelineVQ> jared-w: http://ertes.eu/tutorial/foldr.html
08:35:40 <ertes-w> jared-w: ^
08:36:07 <jared-w> I'm not sure if I should bring up types immediately to people with no programming experience... On one hand, they're fundamental, on the other hand if someone has zero programming experience, it's a lot to grasp all at once.
08:36:12 <erisco> ertes-w, how do you cope? to talk about the type of a number is to talk about constraints and type classes, already advanced
08:36:58 <jared-w> erisco: you can get pretty far by ignoring constraints and typeclasses if you stick with concrete types, I think.
08:37:02 <ertes-w> erisco: you don't have to explain what type classes are right away…  people understand intuitively the idea of a "constraint"
08:37:23 <ertes-w> ("if there is a (Num a) constraint, it means that you can use (+)")
08:38:17 <c_wraith> jared-w: my experience is that simple types make a lot of sense to people with no experience.
08:38:29 <lavalike> ("if there is a (… =>) constraint, it means you can use :info … in ghci")
08:38:32 <ertes-w> interestingly people *without* programming experience seem to have an easier time understanding polymorphic types
08:38:48 <c_wraith> jared-w: people have no trouble with Bool or Integer.  They have really obvious meanings.
08:38:59 <jared-w> interesting. I wouldn't have guessed that, but I suppose it makes sense :)
08:39:29 <jared-w> c_wraith: also a good point. Types can be thought of as just another style of 'constraint' after all, and people understand those pretty readily
08:39:31 <dminuoso> ertes-w: I think it depends on the language they might have experienced. Some people have a tendency to quickly conceptualize the world in the language they learned.
08:39:44 <c_wraith> ertes-w: experience with a subclassing-based language really seems to interfere with people understanding constraints.
08:40:27 <ertes-w> c_wraith: my observation is that it's more a question of whether they have used languages with parametric polymorphism like java and C++
08:41:50 <ertes-w> c_wraith: i have had a lot of people who have used subclassing before, and it hasn't really interfered, as long as i keep telling them: "no, there is no subclassing in haskell"
08:42:15 <ertes-w> and reinforce the notion that constraints are *not* supertypes
08:42:59 <c_wraith> My point was that some people jump to the conclusion that constraints are supertypes because supertypes are all they know, and then require being untaught everything.
08:46:55 <erisco> does that go to everyone who thinks Num is a type?
08:47:56 * hackagebot Plot-ho-matic 0.12.0.0 – Real-time line plotter for generic data – https://hackage.haskell.org/package/Plot-ho-matic
08:48:06 <c_wraith> erisco: pretty much.
08:48:22 <c_wraith> Though, once you enable ConstraintKinds, Num is a higher-kinded type! >_>
08:49:06 <c_wraith> (that tidbit does not help anyone learn the basics)
08:49:18 <erisco> are higher-kinded types types?
08:49:56 <ertes-w> well, i used to think that prior programming experience is a stumbling block for haskell, but honestly it's not as bad as a lot of people seem to think
08:49:57 <c_wraith> are <foo> types types? :P
08:50:13 <erisco> I don't want to get into another nomenclature discussion, because that has happened many times and it never got less confusing, but I do want to know if * -> * is a type
08:50:34 <dolio> No, it's a kind.
08:50:46 <ertes-w> usually when you tell beginners that there is no subtyping in haskell, they will adapt to that very quickly
08:50:52 <dolio> Do you mean you want to know of F is a type given that F : * -> *?
08:50:56 <erisco> I want to know if things with kind * -> * are types
08:51:27 <erisco> the reason I said it that way accidentally because usually we say * is Type
08:51:27 <c_wraith> ertes-w: I think what it comes down to is that if there is direct instruction involved, it doesn't hurt at all.  It can cause problems when someone is trying to learn entirely by themselves and their primary method is by analogy to other languages.
08:51:28 <lavalike> they are, and they are not higher-kinded, (* -> *) -> * is, i.e. it involves a non-* kind
08:51:36 <erisco> so, is * -> * Type
08:52:09 <dolio> Not if you want Type to be like the universe of types.
08:52:15 <dolio> Because * -> * would be Type -> Type.
08:52:16 <ertes-w> erisco: you could say that…  it's useful to call types of kind * "concrete types"
08:52:55 <ertes-w> c_wraith: that's true
08:53:50 <erisco> I always panic when I am thinking of what Maybe is
08:54:04 <MarcelineVQ> "<ertes-w> well, i used to think that prior programming experience is a stumbling block for haskell, but honestly it's not as bad as a lot of people seem to think" absolutely, especially the poor people that come from 5 monad tutorials that all start with "this it complicated so I'm gonan use analogy to explain it" instead of just explaining classes and being done
08:54:10 <erisco> is that a type? is it a higher kinded type? can I say it is either? then I might say it is a type constructor instead
08:54:37 <ertes-w> erisco: with TypeInType in mind you could still call Maybe a type…  from logic we have a name for things that may have inhabitants: "universe"
08:54:44 <ertes-w> * is a universe, but * -> * is not
08:55:39 <ertes-w> MarcelineVQ: well, i doubt that any non-programmer would understand those tutorials =)
08:55:43 <MarcelineVQ> * :: * is the face I make when TypeInType is needed in some code
08:55:54 <ertes-w> haha
08:56:14 <erisco> ertes-w, why is * -> * not a universe if Maybe has that kind?
08:56:29 <ertes-w> @remember MarcelineVQ * :: * is the face I make when TypeInType is needed in some code
08:56:29 <lambdabot> Okay.
08:56:38 <MarcelineVQ> omy
08:56:55 <erisco> you're famous now, right there beside Einstein quotes
08:56:59 <ertes-w> erisco: a type of kind * -> * can't have inhabitants
08:57:15 <ertes-w> neither Maybe nor any other type
08:57:44 <erisco> I thought you were suggesting that * is a universe because it has inhabitants
08:57:54 <ertes-w> (i think "universe" is mostly used for types that contain *types* though)
08:57:57 <erisco> but you're talking about... the grandchildren
08:58:53 <ertes-w> erisco: no, the immediate children…  in haskell + TypeInType Type is really the only universe
08:59:03 <erisco> then I do not follow
08:59:18 <ertes-w> err…  wait
08:59:18 <erisco> Int :: * so * must be a universe because Int is an inhabitant
08:59:27 <ertes-w> yes, * = Type
08:59:32 <erisco> Maybe :: * -> * so * -> * must be a universe because Maybe is an inhabitant
09:00:10 <ertes-w> yeah, wait…  my notion just broke down =)
09:01:52 <ertes-w> of course * -> * is a universe =)
09:01:57 <ertes-w> Maybe is not one
09:02:19 <erisco> if we were talking about values we'd just say "hello world" is a String and id is a function
09:02:32 <ertes-w> and Maybe is a * -> *
09:02:36 <erisco> so why can't I just say Int is a type and Maybe is a function
09:02:54 <ertes-w> you can say that
09:02:54 <dolio> You can.
09:03:09 <dolio> Maybe is a more special function than others, though.
09:03:16 <erisco> good, then you're my references when someone complains to me
09:04:11 <erisco> it doesn't have that beta reduction stuff
09:04:19 <erisco> but neither do data constructors, so that's nothing new is it?
09:04:31 <dolio> It's like a constructor. Like (:).
09:04:46 <dolio> Or Just.
09:05:05 <erisco> I had a reason for giving constructors a different type and now I forget
09:05:25 <erisco> one other than just that they're unlike function
09:05:41 <glguy> You can say Int and Maybe are types and Maybe is a function , just like you can say 0 and Just are values and Just is a function
09:06:36 <erisco> but see that is what is awkward glguy, because we don't have some type called Value, or is pronounced that way
09:06:45 <erisco> and if we did we'd probably be a bit more confused on what a value was
09:06:59 <glguy> It's useful to distinguish constructors and variables from each other, constructors are matched in patterns and variables are bound
09:08:06 <glguy> I don't know what your comment about type called Value means
09:11:18 <erisco> Haskell Wiki, quoting Wikipedia, says "… a primitive type, denoted * and called 'type', which is the kind of any (monomorphic) data type."
09:11:23 <erisco> https://wiki.haskell.org/Kind
09:12:20 <glguy> The wikipedia article deviates from the terminology used in the Haskell Report
09:13:02 <dolio> I don't usually call it 'type'.
09:13:05 <dolio> I say 'star'.
09:13:15 <glguy> but your linked wiki page doesn't seem to disagree that Maybe and Either Int are types
09:13:37 <glguy> It describes * as the kind of "ordinary" types
09:14:22 <erisco> I don't see the Haskell Report 2010 giving any name to ∗
09:14:50 <glguy> The report is clear about constructor being a syntactic distinction, not related to kinds
09:15:02 <glguy> and gives examples of things with kinds other than * being types
09:15:04 <dolio> That wiki page seems pretty bad.
09:15:49 <dolio> I don't use probably 50+% of the terminology it uses in the same way.
09:17:18 <glguy> beyond adhering to the report, it's just not useful to try and restrict types to only having kind *, we have type variables that can have varying kinds, and we need the syntactic distinction of constructor vs variable when defining typeclass instances, and for establishing which things are scoped by a specific type signature and which are not
09:18:22 <erisco> asterisk, the kind of inhabited types
09:18:38 <erisco> "ordinary" is just a bad qualifier
09:20:39 <dolio> But, this stuff doesn't really matter that much, as long as people can figure out what you're talking about.
09:21:20 <erisco> including myself
09:23:35 <erisco> https://ghc.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
09:23:37 * erisco *sighs*
09:24:10 <erisco> mkay, so you see, Haskell doesn't have subtyping but it does have subkinding
09:24:24 <dolio> No, Haskell doesn't have that.
09:24:34 <glguy> GHC *used to* have that
09:24:37 <dolio> Also GHC no longer has that.
09:24:59 <erisco> 2006 is that long ago is it
09:25:45 <erisco> I am uninterested in distinguishing "Haskell" from "GHC"
09:25:52 <glguy> > 2017 - 2006
09:25:54 <lambdabot>  11
09:25:56 <erisco> unless we're specifically in a talk about the report
09:26:09 <dolio> Why? Seems like a big mistake.
09:26:19 <Clint> because of all the other haskell compilers which are about to appear?
09:28:07 <dolio> Like, the stuff there isn't even particularly relevant to the sort of 'what is a type' discussion, because it deals with unboxed weirdness that you don't have to get into for a long time.
09:28:47 <erisco> are you saying I haven't used unboxed types?
09:29:09 <glguy> There's an important distinction between the implementation details that are prone to change dramatically between releases of GHC and the higher level Haskell abstraction that those implementation details exist to support
09:29:09 <erisco> anyways if that isn't the state of the art what is?
09:29:10 <ertes-w> erisco: sorry for the confusion: Type is the type of universes…  so things like Maybe or (Type ->) aren't universes, but Maybe Int is a universe
09:29:59 <glguy> Not to say that the particulars of the implementation aren't interesting or useful to know along the way
09:30:36 <erisco> ertes-w, iow an inhabited type is a universe?
09:31:15 * ggVGc waits for llvm to support haskell
09:31:47 <ertes-w> erisco: i'm not sure whether you may call value types "universes"…  so far i have seen the word "universe" used only for types of types
09:32:16 <ertes-w> for value types you can say "value type" or "concrete type" or something
09:32:41 <ertes-w> note that it's not quite a question of whether a type *is* inhabitated, but whether the question of inhabitants makes sense at all
09:32:43 <dolio> For another example, if you're trying to understand IO, and you just jump into the way GHC _implements_ IO in practice, you're going to have a bad time, because it doesn't implement it in a way that achieves the goals of having IO in the first place.
09:33:03 <ertes-w> so if you allow the word "universe" for value types as well, Void would still be a universe
09:33:28 <erisco> ertes-w, you said "Type is the type of universes", so if you weren't saying "inhabited types are universes" then were you saying "* is a universe"?
09:34:50 <ertes-w> erisco: for the sake of simplicity let's say that all inhabitants of Type are universes, then Type :: Type, so yes, Type is a universe, and so is Type -> Type, Int -> Int, but not e.g. (Type ->) or (Int ->) or Maybe
09:34:50 <erisco> Void is inhabited but it does make me wonder about this "kind of inhabited type" description in languages where it isn't
09:35:02 <cocreature> ggVGc: it already does in some sense. llvm has a specific calling convention for ghc :)
09:35:50 <dolio> ertes-w: No. Type is the universe, not its values.
09:36:12 <ertes-w> dolio: but Type -> Type is a universe, right?
09:37:22 <erisco> maybe I'll have to learn about the universe another day
09:39:13 <ertes-w> well, i have to go anyway…  see you tomorrow =)
09:39:42 <erisco> bye
09:40:53 <nshepperd_> It's universes all the way up
09:42:03 <erisco> what a shame we don't have Pratchett to write about it
09:47:18 * hackagebot sbv 7.2 – SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. – https://hackage.haskell.org/package/sbv
09:52:27 <reactormonk> Your favourite way to derive Monoids?
09:53:16 <erisco> with a closed, associative, binary operation, and a left/right identity
09:53:29 <reactormonk> Derive, not write.
09:53:33 <cocreature> reactormonk: https://hackage.haskell.org/package/generic-deriving-1.11.2/docs/Generics-Deriving-Monoid.html
09:54:34 <erisco> you may have many monoids for one type. not sure how you'd pick
09:55:04 <reactormonk> erisco, with one constructor only, it's a bit easier
09:55:25 <cocreature> you can also have multiple Ord instances for one type. that doesn’t mean you can’t choose a default one and derive that automatically
09:56:10 <erisco> you're right, but we're not usually caring about it
09:56:18 <erisco> we just want to throw our values into a Set or something
09:56:32 <erisco> what is the analog for monoid?
09:58:42 <jared-w> "pick an arbitrary mempty that works, pick an arbitrary operation that's associative" :p
09:58:54 <nshepperd_> Normally i write my monoid instances by hand
09:59:05 <nshepperd_> Because they contain application specific logic
09:59:15 <reactormonk> Can I derive a monoid for something like `data Foo f a = Foo { foo :: f (Maybe a) }` ?
09:59:29 <jared-w> https://hackage.haskell.org/package/generic-deriving-1.11.2/docs/src/Generics-Deriving-Monoid.html#line-122
10:00:48 <jared-w> If you have a data = Thing constructor, the monoid is trivial. If you can assume that all the data constructors of a type are also monoids, you can just kick the implementation down mechanically
10:02:54 <jared-w> Not quite sure how the generic stuff really works under the hood but it looks cool. However, I'd probably do my monoid instance by hand as well
10:03:33 <reactormonk> Is there something like a Monoid for * -> * ?
10:04:42 <erisco> is it a unique instance for single constructor data types?
10:12:19 <erisco> reactormonk, Alternative
10:12:23 <erisco> reactormonk, MonadPlus
10:13:50 <erisco> there may be a Monoid1 lurking somewhere
10:15:14 <zachk> Monoid1?
10:16:05 <erisco> that would be conventional naming for a Monoid for types of kind * -> *
10:25:31 <reactormonk> Is it possible at all to declare a monoid instance for https://gist.github.com/reactormonk/6a6a6f6d3a31666fa726ea483d5113cf ?
10:26:31 <erisco> yes
10:27:17 <reactormonk> I've tried a few things with auto-deriving, but I'm usually stuck at Monoid (f (SJObject a))
10:27:26 <reactormonk> Or manual writing, for that matter.
10:27:34 <Ferdirand> maybe you need a constraint on f for it to be useful ?
10:27:48 <reactormonk> Ferdirand, yeah, add constraint for the Monoid instance as required.
10:27:58 <Ferdirand> i was thinking Applicative
10:29:41 <reactormonk> That's what I'd need for MonadPlus too in the end, but I kinda got stuck defining an Applicative instance for the type... if there's a shorter way, I'd love to see it.
10:30:26 <erisco> what about like this http://lpaste.net/358060
10:31:26 <erisco> really one would like to say  forall a. Monoid (f a)  but  alas one cannot
10:33:15 <cocreature> let’s hope somebody steps up and implements the “quantified class constraints” paper in ghc
10:33:48 <reactormonk> erisco, tells me something about UndecidableInstances
10:33:53 <Cale> You can sort of do stuff like that using the constraints package
10:34:04 <erisco> reactormonk, have a really close look at the lpaste again
10:34:06 <cocreature> Cale: yeah but it’s kind of annoying
10:34:14 <Cale> https://hackage.haskell.org/package/constraints-0.9.1/docs/Data-Constraint-Forall.html
10:34:46 <cocreature> you have to manually unpack these constraints if you actually want to use them
10:34:57 <Cale> Right
10:35:10 <Cale> But if you're really stuck, that's an option
10:35:16 <reactormonk> erisco, "The constraint 'Monoid (f (SJObject a))' is no smaller than the instance head
10:35:30 <reactormonk> ah fuck
10:35:32 <erisco> reactormonk, look reeeeallly carefully
10:35:33 <reactormonk> sorry
10:35:35 <erisco> lol
10:42:50 <vascolleitao> l
10:43:34 <erisco> o
10:46:36 <reactormonk> How would I write a function to change the `f` in that data structure?
10:47:21 <erisco> (forall a. f a -> g a) -> MyType f -> MyType g
10:47:53 <reactormonk> Presumably I can't access a Monoid a there?
10:48:18 <erisco> where?
10:48:28 <reactormonk> In the first argument.
10:48:36 <johnw> not unless you put such a constraint there
10:48:49 <johnw> (forall a. Monoid a => f a -> g a)
10:48:53 <reactormonk> That works?
10:48:56 <reactormonk> Nice.
10:48:56 <johnw> sure
10:49:11 <johnw> it's a much more limited form of natural transformation, but it's legit
10:51:12 <tabaqui> oh yeah, they put "maybe" and "either" into Prelude
10:51:25 <tabaqui> maybe one day they'll do "bool" too
10:52:00 <tabaqui> and <>
10:52:16 <reactormonk> tabaqui, just make your own with blackjack and hookers
10:52:20 <johnw> why is that better than just importing them?
10:52:24 <MarcelineVQ> you can import bool if you want it, Data.Bool, it's as useful really
10:52:29 <MarcelineVQ> *not as useful
10:52:43 <tabaqui> I have full page of imports for 300 lines of code
10:52:54 <erisco> yeah, and?
10:52:59 <[exa]> tabaqui: "code reuse" is good, isn't it
10:53:04 <MarcelineVQ> import them into another module and import that module BAM, one import line
10:53:07 <cocreature> excuse me sir, do you have a moment to talk about the benefits of custom preludes
10:53:10 <tabaqui> I'm tired to import Monoid in all my projects
10:53:21 <erisco> cocreature, lmso
10:54:20 <johnw> tabaqui: make an editor macro
10:54:27 <tabaqui> cocreature: dunno, 10-strings file with Monoid, Bool, Maybe and others inputs?
10:54:28 <johnw> waiting for it to become part of Prelude is going to take years and years
10:54:41 <johnw> if it happens at all
10:55:17 <MarcelineVQ> in other news fromLeft and fromRight are a thing now
10:55:34 <erisco> in the Prelude? oh dear
10:55:35 <tabaqui> johnw: it can't reduce source code size, actually I never write new file from blank page
10:55:42 <tabaqui> it is always copy of some old project
10:55:46 <MarcelineVQ> no no in Data.Either
10:55:56 <erisco> oh, well I think those have been there for a long time
10:55:59 <MarcelineVQ> at least I don't think they're in lude
10:56:02 <MarcelineVQ> erisco: they have not
10:57:15 <reactormonk> Is there a fold for semigroups somewhere?
10:57:28 <johnw> foldl1, foldr1
10:57:37 <johnw> I think there's a fold1 equivalent somewhere
10:57:41 <erisco> MarcelineVQ, so they haven't
10:57:58 <cocreature> tabaqui: I use protolude which is basically just a bunch of reimports + a typeclass for converting between strict/lazy Text/String/ByteString and it solves 95% of the pain I have with imports
10:58:35 <cocreature> tabaqui: I also don’t import protolude directly but have a project specific prelude which reexports protolude but I can also add other stuff to it without having to change the imports in all files
10:58:40 <reactormonk> johnw, I'd prefer a version with Maybe, not the non-total one in the Prelude :-/
10:58:46 <nshepperd_> Make your own prelude, with blackjack and Data.Monoid
10:58:53 <erisco> what I want to know is where is both :: Either a a -> a
10:59:04 <johnw> reactormonk: ?
10:59:36 <reactormonk> johnw, (Foldable t, Semigroup a) -> t a -> a
10:59:37 <cocreature> erisco: do you really use that so often that "either id id" doesn’t cut it?
10:59:39 <reactormonk> johnw, (Foldable t, Semigroup a) -> t a -> Maybe a
10:59:40 <erisco> imagine a world where you didn't care about import lines
10:59:46 <erisco> isn't it a nice world? come live with me there
10:59:51 <johnw> why would the first one be partial?
10:59:52 <nshepperd_> It can be literally just a module that reexports a bunch of stuff, so basically a macro for all of your normal imports
11:00:03 <tabaqui> cocreature: but there is only one non-obvious conversion - between ByteStrings and Text
11:00:10 <reactormonk> johnw, in case t a is an empty list
11:00:13 <tabaqui> there are already function to convert the rest
11:00:17 <tabaqui> *functions
11:00:22 <MarcelineVQ> :t sconcat
11:00:25 <lambdabot> error:
11:00:25 <lambdabot>     • Variable not in scope: sconcat
11:00:25 <lambdabot>     • Perhaps you meant one of these:
11:00:28 <MarcelineVQ> orly..
11:00:28 <johnw> reactormonk: oh, I was thinking of a semigroup on non-empty lists, n/m
11:00:38 <erisco> cocreature, there is just an elegance to it that I enjoy
11:00:53 <MarcelineVQ> :t Data.Semigroup.sconcat
11:00:54 <lambdabot> Data.Semigroup.Semigroup a => Data.List.NonEmpty.NonEmpty a -> a
11:01:02 <cocreature> tabaqui: sure the conversions are there. but having to do qualified imports to 10 different modules to get the right "pack" and "unpack" is really annoying
11:01:04 <tabaqui> tabaqui1: test1
11:01:10 <tabaqui> tabaqui: test1
11:09:21 <jle`> erisco: `id ||| id`
11:12:53 <erisco> :t (|||)
11:12:55 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
11:25:24 <cheater> hi
11:25:47 <cheater> what are good linux distributions to program haskell on as a dev workstation that aren't ubuntu?
11:26:19 <wedify> how do I convert a CULong to a Word8? I just want the last 8 bits
11:27:23 <mud> cheater: Shouldn't matter, any that 'stack' will work on would be identical to me. Even if you don't use stack, any you can get GHC working on and whatever other tools should be fine.
11:33:22 <iqubic> cheater: yeah, literally just pick a distro and install it. If you need help getting a Haskell workflow set-up, we can help.
11:34:13 <iqubic> wedify: Data.Bit + a bit mask?
11:34:35 <iqubic> *Data.Bits
11:38:12 <lyxia> wedify: fromIntegral?
11:41:01 <wedify> lyxia: that works. thank you
11:41:03 <Habib> Hey, guys. Any crypto people in the room?
11:43:33 <erisco> so, for ADTs, there is the intuition of "count the inhabitants" yes?
11:44:02 <vektorweg1> aSdtIG5vdCBhIGNyeXB0byBndXksIG9idmlvdXNseQ==
11:44:08 <erisco> how does that apply to -> and Void
11:44:26 <erisco> a -> Void particularly
11:45:19 <rcat> cheater: I use Arch Linux and I'm quite happy with it
11:45:34 <rcat> rolling release distro, everything is bleding edge
11:46:07 <tdammers> the downside is of course that you now run a rolling release distro, and everyting is bleeding edge
11:46:45 <geekosaur> how do you manage to be happy with how arch has broken ghc?
11:47:01 <geekosaur> or did they finally get a clue and back off the shared libs nonsense
11:48:01 * hackagebot canteven-listen-http 1.0.0.3 – data types to describe HTTP services – https://hackage.haskell.org/package/canteven-listen-http
11:48:07 <rcat> geekosaur: https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
11:48:21 <rcat> I just added that section there yesterday with some help from the folks in here
11:48:48 <rcat> pure happiness, I just use ghc and ghc-static, cabal-install is built on my own with stack, all back to normal now \o/
11:48:58 <rcat> no more issues with the dynamic linking story
11:49:13 <rcat> I can't really trust any more Haskell Arch maintainers, but now it's ok
11:49:44 <rcat> tdammers: well, to be honest with languages that offer good version pinning, like now Haskell (sandboxes, new-build, stack) that isn't an issue anymore
11:49:54 <rcat> the gist as usual is to have reproducible builds
11:50:05 <rcat> whenever somebody mentions cabal hell, I have no clue what they are talking about
11:50:09 <cocreature> geekosaur: as long as you don’t insist on installing anything but ghc via the package manager arch behaves just like any other distro :)
11:50:22 <rcat> cocreature: exactly :)
11:50:29 <geekosaur> well, and ghc-static
11:50:34 <cocreature> rcat: “cabal hell” mostly comes from a time before sandboxes
11:50:38 <geekosaur> but absolutely nothing else, yes
11:50:59 <rcat> cocreature: I know I know, but that issue is completely gone!
11:51:46 <ggVGc> well
11:51:51 <ggVGc> I just emialed joe armstrong
11:53:11 <geekosaur> I really need to write up a page about dynamic linking, why ghc doesn't use it for haskell libs by default, and why it really should only be used under the supervision of a nix-like library/package manager
11:53:29 <ggVGc> just build everything from source always
11:53:48 <geekosaur> (andf why this is essentially ghc-specific)
11:54:02 <ggVGc> in the future every software release will be virtual machine image
11:54:08 <cocreature> geekosaur: I would definitely appreciate that. I know embarrasingly little about linking
11:54:08 <ggVGc> and we'll be all good
11:54:51 <geekosaur> it's a fairly long and hairy story as to all the parts that fit together, or rather don't in ghc's case >.>
11:54:55 <geekosaur> (by design)
12:03:35 <larrybotha> hey everyone - total Haskell noob here - I'm doing Haskell Book and in chapter I can't understand why a question's throwing an error (the point is to make the code evaluate). Does anyone have a minute?
12:04:18 <adam5> I'm looking for some marketing assistance with this material: try http://loch.reallyhim.com for some jedi mind trick #proof, http://bereshit.reallyhim.com to end world hunger with the magic of virtual reality, and http://jerusalem.reallyhim.com to see pre-crime here and now.  also last of not least of importance, technocracy, here http://gate.reallyhim.com and then, something about a sign: http://threetag.reallyhim.com
12:04:21 <larrybotha> chapter 10*
12:04:26 <adam5> really ... him ... by the way.
12:06:09 <wedify> larrybotha: just ask the question
12:06:34 <larrybotha> well, this is the code that doesn't evaluate:
12:06:35 <larrybotha>     foldl ((++) . show) "" [1..5]
12:06:53 <larrybotha> which to me seems as though it would evaluate to
12:07:11 <larrybotha> ...
12:07:18 <larrybotha> gimme a sec as to what I believe...
12:08:25 <larrybotha> ((++) . show $ 1 ((++) . show $ 2 ((++) . show $ 3 ((++) . show $ ""))))
12:08:32 <wedify> larrybotha: use foldr instead
12:09:04 <larrybotha> agh god I'm looking at the wrong question... my bad.. gimme a sec - it's what looks like a simple const
12:09:09 <larrybotha>     foldr const 'a' [1..5]
12:09:17 <larrybotha> why is that not just 1?
12:09:34 <larrybotha> (const 1 (const 2 ( const 3 (....)))))
12:10:15 <larrybotha> I've seen one solution as follows:
12:10:18 <larrybotha>     foldr (flip const) 'a' [1..5]
12:10:45 <larrybotha> omg...
12:10:59 <larrybotha> no... it's gone... still don't understand
12:12:01 <tdammers> :t foldr
12:12:03 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:12:08 <larrybotha> I realise now I thought I was working with foldl the whole time, but still... why does it not just return 'a'
12:12:22 <tdammers> :t const
12:12:24 <lambdabot> a -> b -> a
12:12:54 <tdammers> :t flip const
12:12:56 <lambdabot> b -> c -> c
12:13:01 <larrybotha> so surely that's evaluating to (const 'a' (const 1 (...)))
12:13:11 --- mode: ChanServ set +o shapr
12:13:15 --- kick: adam5 was kicked by shapr (Kicked by shapr)
12:13:19 * shapr sighs
12:14:00 --- mode: shapr set +b *!*@aftertheome.ga
12:14:04 --- kick: adam5 was kicked by shapr (Kicked by shapr)
12:19:04 <wedify> larrybotha: compare 'foldl (\acc v -> ...) acc list' with 'foldr (\v acc -> ...) acc list'
12:19:17 <wedify> notice how the arguments are switched?
12:19:44 <larrybotha> ye
12:24:54 <larrybotha> what I keep expecting is for the first 'step' of `foldr const 'a' [1..5]` to be `(const 1 (...further traversals))`, where am I going wrong with that expectation?
12:26:29 <geekosaur> > foldr const 'a' [a,b,c,d,e] :: Expr
12:26:31 <lambdabot>  error:
12:26:31 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘Char’
12:26:31 <lambdabot>      • In the expression: foldr const 'a' [a, b, c, ....] :: Exprerror:
12:26:38 <geekosaur> oh right
12:26:38 <mud> > foldr const 42 [1..5]
12:26:40 <lambdabot>  1
12:26:43 <geekosaur> > foldr const z [a,b,c,d,e] :: Expr
12:26:44 <lambdabot>  a
12:26:49 <geekosaur> heh, too smart
12:27:19 <mud> lambdabot: So, you're not going wrong with that, it seems? Just 'a' isn't a Num instance usually.
12:27:29 <mud> larrybotha: ^
12:27:31 <mud> Heh
12:28:13 <larrybotha> but how is the first evaluation different from `const 1 'a'`? why does it throw when evaluated inside foldr?
12:28:46 <mud> :t foldr
12:28:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:29:26 <mud> The type of foldr doesn't change just because it never uses the 'a'. It still has to make sense on the type level. ie the 'b' type variable there has to match the 'b' from (a -> b -> b)
12:30:04 <mauke> larrybotha: it doesn't throw, and it's not evaluated
12:30:28 <mud> Yeah, this is all way before it even tries to run any code, it's a compilation error.
12:31:00 <larrybotha> ah ok, so, compilation vs ... runtime?
12:31:31 <larrybotha> my god... so it's because I'm working with [Integral], and acc is Char?
12:32:26 <mud> larrybotha: That's the right idea anyway. Some of the details are a tad wrong, pedantically.
12:33:59 <larrybotha> haha, ye, the terminology is still pretty alien, but I'm at least a bit more aware of the effect of types within folds now
12:34:33 <larrybotha> ok awesome, thanks folks
12:36:29 <larrybotha> O.o... epiphany coming... I feel it happening! Thanks again :) have an awesome day / evening
12:36:48 <mud> Anytime :)
12:38:50 <reactormonk> What's the `x` here? https://gist.github.com/reactormonk/8ecdbcdc7c7d819b64beacc5a432d670
12:41:58 <lyxia> reactormonk: https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html#v:hoistCofree <- forall x. ...
12:42:51 <sibelius> can someone explain why this "works": (\x -> x 5)(\x -> x)  more specifically the first part 
12:43:06 <sibelius> my brain tells me that \x->x 5 should give an error
12:43:31 <erisco> what does "works" mean?
12:43:46 <sibelius> isn't an error
12:43:48 <lyxia> sibelius: (\x -> x 5) is a function, which maps a function "x" to the application of x to 5, "x 5".
12:44:30 <mud> sibelius: x 5  is just function application, yeah. Why would it error?
12:47:07 <reactormonk> lyxia, thanks
12:47:35 <sibelius> dont know how to say exactly, but cant get my brain around it
12:47:44 <sibelius> how would you write \x->x 5 as a "let .. in"
12:48:01 <geekosaur> and we're set for a repeat of last night;s existential angst over first class functions >.>
12:48:01 <mud> let f x = x 5 in f id
12:48:13 <mud> > let f x = x 5 in f id
12:48:15 <lambdabot>  5
12:48:17 <geekosaur> :t \x -> x 5
12:48:18 <lambdabot> Num t => (t -> t1) -> t1
12:48:44 <geekosaur> hm, that's clearer without the typeclass
12:48:45 <mud> > let f x = x 5 in f (\x -> x)
12:48:46 <lambdabot>  5
12:48:52 <geekosaur> :t \x -> x (5 :: Int)
12:48:53 <lambdabot> (Int -> t) -> t
12:49:38 <mud> sibelius: This is all kind of a consequence of first-class functions, functions being able to take functions as arguments and etc. And then just lambda syntax.
12:50:03 <mud> It does take a while to get used to though
12:50:34 <sibelius> so is the second x a function as well?
12:50:57 <sibelius> i know what it does from changing the values around but still dont understand how exactly
12:51:03 <mud>  (\x -> x) is just another name for 'id', the function that just gives back whatever you pass in.
12:52:03 * hackagebot wkt 0.3.2 – Parsec parsers and types for geographic data in well-known text (WKT) format. – https://hackage.haskell.org/package/wkt
12:52:03 * hackagebot http2-client 0.3.0.1 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
12:53:00 <geekosaur> the \... -> is a lambda, a function defined "on the fly"
12:53:18 <mud> So (\x -> x 5) is "give me a function and I'll apply it to the value 5"   and then (\x -> x) is "the function that just gives back its input"
12:53:33 <geekosaur> > map (\a -> a + 1) [4,5,6]
12:53:35 <lambdabot>  [5,6,7]
12:53:56 <sibelius> but \x->x 5 doesn't do anything alone
12:54:23 <sibelius> but if you put for example (\x-> x+x) after it
12:55:06 <sibelius> so which of those is taking the other as an argument?
12:55:57 <rcat> I replied to a recent mail thread in the Arch ML where it was mentioned again the dynamic linking issue
12:56:05 <mud> Function call syntax in haskell says that the first thing is the function being applied, and then come the argument(s). One of the arguments just happens to be a function itself.
12:56:14 <rcat> it would be good if more people jump in into the discussion to try to fix the situation: https://lists.archlinux.org/pipermail/arch-general/2017-August/044188.html
12:56:15 <mud> :t (\x -> x 5)
12:56:16 <lambdabot> Num t => (t -> t1) -> t1
12:57:36 <sibelius> so \x -> x 5 takes a function and replaces x with it?
12:57:37 <geekosaur> (\x -> x 5) (\x -> x + 1)      is     (\x -> x + 1) 5     (substituting the second one for "x" in the first)     is     5 + 1     (substituting the 5 for x)
12:58:03 <geekosaur> function application (not operators, but functions) is left to right
12:58:11 <mud> sibelius: Yes
12:59:14 <sibelius> oh damn, thanks a lot
12:59:49 <sibelius> for some reason because of the brackets around (\x -> x 5) i thought x and 5 are "inseparable", so i thought it's weird its not an error since if you replace x with another number, it should be an error
13:00:05 <sibelius> like "1 5", for some reason placing a function there never occured to me
13:00:27 <sibelius> even though it should be obvious as the (\x -> x+x) is right after it...
13:00:44 <geekosaur> if you have the right instance in scope, even a number can be a function :)
13:01:12 <sibelius> lets not get ahead of ourselves, even this one was a little tricky for me :)
13:03:43 <v0d1ch> does anyone use ghc 8.2 and cabal 2.0 and have problems installing alex and some other packages on macOS
13:03:46 <v0d1ch> http://lpaste.net/7248397756048343040
13:04:55 <v0d1ch> this is what the log file says
13:04:56 <v0d1ch> http://lpaste.net/358064
13:14:25 <dan2_> hey -- new to Haskell and trying to figure out how Parsec works.  I'm trying to parse a simple WKT string into a data structure.  Can anyone help?
13:14:52 <cocreature> dan2_: what problems are you running into?
13:16:09 <dan2_> heh.. getting started.  The string is formatted like this: "TYPE(((123 456, 234 345, 456 567)))" where the digits are x and y coordinates separated by comma
13:16:47 <nisstyre> dan2_: I'd start by breaking it up into "productions", i.e. try and parse a list of comma separated values
13:17:06 <nisstyre> then figure out how to parse something like F(whatever)
13:17:07 <nisstyre> etc
13:17:13 <nisstyre> and then put it all together
13:17:29 <nisstyre> combinators like many1 will be helpful
13:17:49 <nisstyre> sepBy would be the best here probably
13:19:46 <dan2_> ok .  would I use 'between' for the parentheses?
13:20:00 <nisstyre> you could yeah
13:20:33 <nisstyre> do you understand how parsec works as a monad instance?
13:20:54 <dan2_> ish... I've read through a tutorial that shows how to build a CSV parser, but that's about it
13:21:11 <nisstyre> I'd start with just building a parser that does a subset of what you want
13:21:25 <nisstyre> like start by being able to parse a list of comma separated values
13:22:17 <nisstyre> you do recursion basically by recursively calling your functions that parse things
13:22:21 <nisstyre> if necessary
13:22:21 <dan2_> I'm trying to figure how to get between to work.  How do I get it to return "(foo)" -> "foo".     inside = do between (char '(') (char ')') ??
13:22:29 <nisstyre> it'll depend on the type of language you're parsing
13:23:12 <cocreature> dan2_: you are going to need to write a parser that parses the stuff in between :)
13:23:23 <nisstyre> yeah look at the type of between
13:23:35 <nisstyre> between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a 
13:23:47 <nisstyre> that takes three instances of ParsecT and returns a new one
13:23:49 <dan2_> well yeah... trying to start with that then get to sepBy
13:24:11 <cocreature> starting from the inside out can often work pretty well
13:24:31 <cocreature> start by writing a parser that given "123 456" gives you back (123, 456) or whatever data structure you want to parse that in
13:24:32 <nisstyre> that's what I'm saying
13:24:33 <nisstyre> start small
13:24:34 <dan2_> oh yeah i guess starting with between is starting from outside in :)
13:24:39 <nisstyre> then build your way out to the full language
13:25:00 <cocreature> then build upon that to create a parser that parser lists of these things separated by commas
13:25:08 <cocreature> then add the surrounding parentheses using between
13:25:16 <cocreature> and so on
13:26:12 <dan2_> ok cool.  I'll give that a shot.  I'm determined to get comfortable in Haskell. I've been meaning to learn it for years, but it's hard feeling like a total novice after writing in other languages for years :)
13:26:33 <shapr> dan2_: hard but awesome!
13:26:39 <nisstyre> dan2_: it took me a while to get comfortable with it too, just gotta keep trying new things
13:26:46 <cocreature> there is an initial cliff that you need to get over. once you’re past that point, things go more smoothly :)
13:27:14 <dan2_> yeah ... just a bigger cliff than most languages.  but I can already see how powerful it'll be after hacking on it for a few days
13:27:28 <nisstyre> there's a point where you stop trying to fight the language and instead let it sort of decide things for you
13:27:37 <shapr> Haskell is my exocortex.
13:28:45 <nisstyre> this is a great lecture to check out once you're a little more comfortable with it dan2_ https://www.youtube.com/watch?v=6COvD8oynmI
13:28:55 <nisstyre> if you can stand the font choice
13:29:52 <Tuplanolla> That position reverses eventually, dan2_.
13:30:09 <dan2_> cool -- I'll check it out
13:30:53 <dan2_> ahh..comic sans
13:31:12 <nisstyre> dan2_: he works for Microsoft, gotta represent the company :p
13:31:38 <nisstyre> but seriously it's a really good explanation
13:32:25 <mud> Holy crap, he actually uses comic sans. :-/ *goes off to learn PHP instead*
13:32:46 <dan2_> haha  .. but then you'd have to learn PHP
13:41:51 <c_wraith> mud, https://www.reddit.com/r/haskell/comments/1bd1ia/spj_and_comic_sans/
13:47:45 <dolio> ertes: No, * -> * is not a universe. At least not obviously.
13:48:46 * hackagebot safecopy-store 0.9.5, servant-auth-token-rocksdb 0.4.3.0, squeal-postgresql 0.1.0.0
13:48:46 * hackagebot  → https://hackage.haskell.org/packages/recent
13:51:00 <epta> @hoogle Maybe a -> b -> Either b a
13:51:01 <lambdabot> Control.Error.Safe justErr :: e -> Maybe a -> Either e a
13:51:01 <lambdabot> Control.Error.Util note :: a -> Maybe b -> Either a b
13:51:01 <lambdabot> Data.Either.Extra maybeToEither :: a -> Maybe b -> Either a b
13:51:56 <jle`> epta: people call it note sometimes, but it's not in base
13:51:58 <epta> why it differs from https://www.haskell.org/hoogle/?hoogle=Maybe+a+-%3E+b+-%3E+Either+b+a ?
13:52:28 <jle`> different index
13:53:06 --- mode: ChanServ set +o glguy
13:53:07 --- mode: glguy set -qqbb *!*@*/ip.84.211.229.153 *!*@gateway/web/freenode/ip.109.193.163.36 *!*@76-14-164-44.wsac.wavecable.com *!*@*/ip.88.97.47.162
13:53:07 --- mode: glguy set -bo *!*@*/ip.92.220.69.55 glguy
13:58:43 <Nickske> hallo?
13:58:55 <shapr> gutentag Nickske, how's code?
13:59:29 <Nickske> Crashing...
13:59:49 <shapr> Are you using unsafeCoerce?
14:00:11 <Nickske> haha I wish
14:03:44 <dan2_> nisstyre: holy crap I got it to work.  thanks for the help
14:04:44 <nisstyre> dan2_: no problem, you did it all
14:04:51 <shapr> Nickske: do you have exciting questions about Haskell?
14:07:48 <Nickske> I'll be asking some specific questions later, I need to figure some things out first
14:07:51 <Nickske> thanks for asking though!
14:14:35 <cheater> mud iqubic rcat i'm pretty good with haskell tools, i've just been using ubuntu forever, and i'm thinking of switching the distro to something else that's less.... ubuntu
14:14:40 <cheater> thanks
14:15:02 <erisco> such as Windows
14:15:45 <syd> I would try to convince you to use Arch, but it's probably best not to do that in #haskell, and if you're in the right channel anyway, you won't need _me_ to do the convincing ;p
14:43:51 <trigone> hi! it's sort of off-topic, or rather it's about programming but not specifically haskell. i'm looking for a better font which would remain extremely visible even when very small. indeed i have trouble coding when i have to constantly scroll around and so on... does anyone know of great fonts?
14:45:07 <rcat> trigone: I like terminus font, maybe it's useful for that...?
14:45:46 <rcat> not sure how good it will be with tiny sizes
14:46:20 <boj> trigone: check out http://sourcefoundry.org/hack/ - there's a playground in the browser
14:46:26 <nisstyre> trigone: I use Hack
14:46:33 <nisstyre> http://sourcefoundry.org/hack/
14:46:48 <nisstyre> boj: great minds think alike
14:46:53 <nakal> fantasque sans mono is still my favorite
14:46:59 <boj> :)
14:47:28 <nisstyre> a lot of it will depend on your syntax highlighting and your screen resolution
14:48:29 * hackagebot alerts 0.1.0.0, servant-auth-token 0.5.0.0, servant-auth-token-acid 0.5.0.0, servant-auth-token-leveldb 0.5.0.0, … and 2 more
14:48:29 * hackagebot  → https://hackage.haskell.org/packages/recent
14:49:44 <nakal> hack looks nice, too
14:50:04 <trigone> rcat: wow dunno, g a o e look very similar, along with l and 1... :/
14:50:54 <nisstyre> if you can easily tell l and 1 apart then it's a decent font
14:51:09 <nisstyre> same with O and 0
14:51:58 <trigone> fantasque sounds nice
14:52:20 <erisco> fanta squee
14:52:24 <rudol> I have "data Tree a = Node a [Tree a]". In the case I'm looking at "a" is ([Int], Bool). My function is passed a Node. If that Node has children, I want to choose its first child Node with the Bool set to True, and if there is no such child, the head of the children list. 
14:53:27 <erisco> rudol, paste your code to lpaste along with any errors or what inputs you tried, the corresponding outputs, and how those outputs do not match what you want
14:53:52 <trigone> i don't really find hack particularly exciting. it sure seems to avoid having characters too similar but otherwise... it feels like the characters are just a tiny bit to close to one another...
14:53:58 <trigone> erisco: what?
14:54:47 <[exa]> the i without the proper serif looks greek
14:55:05 <rudol> <erisco> - I am getting lost in increasing deeper nested case statements
14:55:11 <geekosaur> I feel like more effort went into the website than the font >.>
14:55:21 <[exa]> :]
14:56:02 <erisco> geekosaur, more important to sell it
14:56:42 <erisco> rudol, just paste whatever you have
14:57:15 <rudol> is it the right approach that I need to use "case" to pattern match the Node to get its children and then pattern match again to get its "a" (ie ([Int],Bool) in this case)
14:57:45 <jle`> usually you can directly pattern match
14:57:52 <jle`> on Node (xs, b) ts
14:58:03 <rudol> aand then somehow filter on the Bool whilst keeping a handle on the [Int] which is what I am returning? 
15:00:08 <[exa]> rudol: if I got it correctly, the function should not recurse down the tree structure?
15:00:47 <rudol> [exa] that's right in this case. It just need to pick one of the first gen children
15:00:57 <[exa]> what if there's no children at all?
15:01:42 <rudol> that's where the recursion terminates in the calling function
15:01:53 <rudol> think of a gametree with minimax
15:02:06 <rudol> if there are no children, it's all over!
15:03:42 <rudol> but the code is in such a mess trying to get the children of the passed in node and then choose one based on some predicate on come constituent part of what's in "a" (from Tree a)
15:03:44 <[exa]> so that won't happen, ok. What about this skeleton: f (Tree _ (c:cs)) = foldr (...) c cs
15:04:56 <[exa]> oh sorry, s/Tree/Node
15:05:49 <rudol> [exa] I think foldr may be better than what I am working with, but what is seemingly making it messy is that I need to dig into the structures at various levels yet keep a higher level structure intact for returning
15:05:52 <trigone> hm in the end i think i still prefer ubuntu mono, i don't manage reading fantasque very well, it's cluttered a bit too much too...
15:07:22 <trigone> does anyone know of a vim plugin to split the screen in half, and have each half automatically display two parts of the code which follow each other? as if you doubled the height of the screen then cut the lower half and put it at the right of the upper half... it could solve my problem...
15:07:43 <[exa]> rudol: foldr just needs to decide if it should continue or not, based on receiving 2x Node ([Int],Bool) _
15:08:34 <[exa]> rudol: also I have a bit overdone the fallback: foldr (...) c (c:cs)
15:09:26 <rudol> I was using map and then filter, and then some cases with more maps and a maybeFromList and ... but the "case"s got really ugly
15:09:45 <rudol> (not to mention, they it never worked ;)
15:09:54 <jle`> if you get ugly working code, show it to us
15:10:02 <jle`> it'll help us know what exactly it is you want
15:10:38 <rudol> it's so ugly (and probably wrong) I am not sure it will help
15:10:50 <[exa]> we've seen C++ today, don't worry
15:11:04 <rudol> tbh, this looks worse!
15:11:09 <jle`> it'll at least help us know what it is you really mean, heh
15:11:19 <jle`> it's difficult to really understand from vague descriptions
15:14:12 <rudol> if you imagine "data Tree a = Node a [Tree a]" then a gametree that creates Tree Board and minimax that creates Tree (Board, Int) ie embelishes the labels with evaluations of leaves which perculate back up to the root of th etree section in hand. That all works, 
15:14:49 <[exa]> rudol: I'll insist on foldr:
15:14:55 <[exa]> > let (c:cs) = [(1,False),(2,True)] in foldr (\(i,b) nxt -> if b then (i,b) else nxt) c (c:cs)
15:14:57 <lambdabot>  (2,True)
15:15:12 <[exa]> > let (c:cs) = [(1,False),(2,False)] in foldr (\(i,b) nxt -> if b then (i,b) else nxt) c (c:cs)
15:15:15 <lambdabot>  (1,False)
15:15:53 <[exa]> you'll need to decorate it a bit with Node constructors
15:16:15 <rudol> but ... I want to choose the best move for any certain board, and that involve applying a predicate to the snd of a (ie ([Int], Int) and returning the int
15:16:55 <rudol> [exa] - thank you. I think it's deconstructing the Node which is making it so messy.
15:17:38 <erisco> first figure out how to get the necessary data to make the decision at every node
15:18:01 <erisco> then, your problem reduces to traversing the tree and selecting the appropriate child using only the local information
15:18:47 <[exa]> rudol: this is for a=(Int,Bool), getting it to ([Int],Bool) should be no problem, ([Int],Int) will probably require some sorting or so.
15:18:49 <erisco> problems become too difficult when you try to do too much at once
15:19:24 <[exa]> rudol: and well, try not to use fst/snd, patternmatching is a better way to deconstruct stuff (like with as-patterns:   (left,right)@both  )
15:19:32 <rudol> http://lpaste.net/358068
15:19:34 <[exa]> (maybe @ goes the other way)
15:20:33 <rudol> ericso, I think that is what I am suffering from, and I am usually comfortable to break things up, but this seems to intertwine everything
15:21:19 <rudol> the reason I didn't paste it in is that I have mangled it beyond usefulness probably
15:22:07 <[exa]> rudol: the maybe is there just for determining that the player ran out of possibilities to survive?
15:22:15 <erisco> so, you find yourself at a node, what information do you need to decide which child to choose? (or is that not the problem at all?)
15:23:30 <rudol> previously I got it to compile with http://lpaste.net/358069 but the list can be empty so head fails (hence the attempt at Maybe'ing it)
15:25:05 <rudol> so, based on whose turn it is, the logic chooses the highest or lowest valued child (ie the predicate (or ordering) is against the snd value in the label tuple is )
15:26:31 <rudol> I say predicate, because I tried to use a smarta.se scheme here where the Player value is enough to determine the valuation/score of a position (since either player 1 or player 2 wins, and the game is simple enough to follow the gametree to conclusion)
15:26:50 <[exa]> rudol: what should bestnext return if there's no possible move?
15:27:22 <rudol> [0,0,0,0,0]
15:27:27 <rudol> for example
15:27:57 <rudol> so, a board is a list of ints
15:28:08 <rudol> type Board = [Int]
15:28:32 <[exa]> like, it should return an empty board of 0's, or the original board?
15:29:36 <rudol> the idea is from the new edition of the Hutton book - the game is Nim (game starts with [5,4,3,2,1], ends with [0,0,0,0,0]). I was trying to automate it
15:30:27 <rudol> I was curious to see if the gametree was small enough to make it possible for the machine to always make "best" possible moves 
15:31:02 <rudol> (a bit like in tic-tac-toe, where it is possible since the game possibilities are limited)
15:31:29 <erisco> you do not have to write a tic tac toe solver to figure that out, though
15:31:55 <rudol> well, you can make the gametree and see that there are some 1/2 million possibilities
15:32:12 <erisco> then it is trivial
15:32:32 <rudol> so minimax (even without ab pruning) will work on most modern hardwarew
15:32:34 <rudol> so minimax (even without ab pruning) will work on most modern hardware
15:32:46 <erisco> you can brute force that easily
15:32:50 <rudol> but that is not my issue
15:34:05 <rudol> I am trying to work out how my logic got so messy and why I have not been able to break it up into simple parts, as is usually so nice in Haskell (in the right hands ;)
15:35:31 <[exa]> rudol: possible good reading https://cseweb.ucsd.edu/~ccalabro/essays/nim.pdf
15:36:17 <rudol> "For some games, every winning strategy takes an exponential amount of time if the losing player wishes to use a delaying strategy. "
15:36:33 <erisco> rudol, okay, as an exercise in breaking it up, explain to me what bestnext does
15:36:36 <[exa]> (exponential in bit lengths of the numbers actually) :]
15:36:37 <rudol> sounds like my experience writing that function!!
15:38:16 <rudol> bestnest takes a board and a player (1 or 2), calculates the gametree, embelishes each node with a  valuation (by minimax) and then chooses the best board position that cna be reached directly (ie 1 move away) from the current one
15:39:59 <rudol> this is quite simple logic, but I am hitting a block with the destructuring of the nodes and then filtering based on some part buried inside, whilst returning the composite thing it belongs to
15:40:47 <rudol> http://lpaste.net/358069 actualy compiles, and can be made to work (in some edge cases, with the right board config ;)
15:40:54 <erisco> okay, lets say we just have the minimax tree, forget the rest
15:41:06 <erisco> with the minimax tree what do we need to do?
15:41:20 <deech> I've read that ghc can compile C++ sources. Can anyone point me to docs on how to do that?
15:42:22 <rudol> from the root, we need to go down 1 level and find which child has snd ([Int], Int) equal to player (1 or 2) and return the [Int] (fst ...)
15:42:44 <rudol> as in http://lpaste.net/358069
15:43:14 <erisco> okay, seems weird
15:43:22 <erisco> what does the root of this tree represent?
15:43:49 <rudol> BUT, if there is no such child, weshould return a board (which is the [Int]) labelled with the other player
15:44:17 <rudol> it's the position from which you want to make a move (so the current position)
15:44:43 <erisco> okay, so the node label is a board state?
15:45:09 <erisco> is that all? where does this tuple come from?
15:45:13 <rudol> sort of, but embelished with its evaluation (1 or 2)
15:45:32 <erisco> okay, so is the label a 2-tuple of a board state and the number 1 or 2?
15:45:36 <rudol> think of it as (Board, Evaluation)
15:45:53 <rudol> type Board = [Int]
15:46:01 <rudol> type Evaluation = Int
15:46:19 <rudol> and yes, 1 and 2 is the smarta.sedness I was trying out
15:46:30 <erisco> what is a smarta.sedness
15:47:29 <rudol> well, usually in minimax, you run down to the leaves (if you can get that far) evaluate the position with some meaningful number (eg MAX_INT might mean checkmate in chess)
15:48:22 <rudol> and then you walk back up the tree to your current root (current position) flipping between minimising and maximising the evaluation from the next generastion
15:48:42 <koz_> rudol: This smells like a catamorphism to me.
15:48:50 <rudol> foldr?
15:49:17 <erisco> okay, so I have the 2-tuple (b, 1) where b is a board state, and this is the label of the root
15:49:19 <erisco> what does that tell me
15:49:22 <rudol> might well be, but I have not made any instances of any classes yet
15:49:25 <koz_> rudol: A catamophism is like a super-fold.
15:50:21 <erisco> it seems like you're just skipping over this node completely so I am interested to know why we're making it at all
15:51:21 * hackagebot b-tree 0.1.3 – Immutable disk-based B* trees – https://hackage.haskell.org/package/b-tree
15:51:31 <rudol> the trick I "discovered" was that since there is no draw in this game, and since I reckon I can easily calsulate the gametree right to the end for every line of play, then I only need to check at each level whether the evaluation is equal to the player value (1 or 2), rather than have to check the palyer at each level and the use min or max appropriately/respectively, as in the usual minimax algo.
15:52:31 <rudol> if you look at http://lpaste.net/358069 you'll notice that what is passed in is not a Tree (data constr Node) but a Board 
15:52:44 <erisco> so it the number an evaluation or the player name?
15:52:57 <erisco> so is the*
15:54:17 <rudol> yes, I reckon I can make it work (if I knew enough Haskell :) by just allocating an evaluation of Player (1 or ) at the leaves, and then perculating that back up by checking only if the eval matches the player whose tuen it is at each level
15:55:00 <erisco> the way to make a sensible Haskell program is to begin by thinking slowly, clearly, and deliberately
15:55:16 <erisco> there is no rush to jump to optimisations and clever tricks and so forth
15:56:08 <rudol> I have written game trees before, and with ab pruning too, and it was not too difficult and much more elegant than the monstrosity I created this time
15:56:13 <koz_> Yeah, definitely what erisco said. In Haskell, thinking is the hard part; figuring out what of the million amazing tools you need is a very tricky thing.
15:56:35 <koz_> rudol: Why are you not using alpha-beta pruning in this case, out of interest?
15:57:05 <rudol> I am going stepby step - minimax is fine for now, and may even be sufficeint
15:57:43 <erisco> I am just trying to disassemble what this tree is, and am still not hearing clear answers
15:58:01 <rudol> I was just curious if my idea about using just the Player id (1 or 2) instead of a fullblown evaluateion startegy would work, but that was a couple of hours ago ;)
15:58:02 <erisco> the labels are 2-tuples, okay. The first element is a board state, okay. The second element is what?
15:58:28 <rudol> did you look at http://lpaste.net/358069
15:58:42 <erisco> yes
15:58:44 <rudol> data Tree a = Node a [Tree a]
15:59:29 <erisco> first you said the second element was an evaluation, then you said it was a player name but it is somehow equivalent, now I don't know what to think
15:59:37 <rudol> so a Tree cold be Node ([0,0,1,0,2],1) [Node ([0,0,0,0,2],2) [Node ([0,0,0,0,1],1) [Node ([0,0,0,0,0],1) []],Node ([0,0,0,0,0],2) []],Node ([0,0,1,0,1],1) [Node ([0,0,0,0,1],1) [Node ([0,0,0,0,0],1) []],Node ([0,0,1,0,0],1) [Node ([0,0,0,0,0],1) []]],Node ([0,0,1,0,0],2) [Node ([0,0,0,0,0],2) []]]
15:59:53 <erisco> meaning, I am looking for meaning
16:00:11 <erisco> [0,0,1,0,2] is a board state, that is the meaning of that list
16:00:21 <rudol> In this case, a represents a (,) [Int] Int 
16:00:47 <rudol> yes, type Board = [Int]
16:01:03 <rudol> so it can be seen as (Board, Evaluation)
16:01:20 <rudol> s/it/a
16:01:27 <erisco> okay, I am just going to assume the second element of the 2-tuple is an evaluation and ignore the bit about it being a player
16:01:41 <rudol> it is an Int,
16:01:49 <rudol> type Player = Int
16:01:53 <erisco> do you know what semantics are?
16:02:05 <rudol> type Evaluation = Int
16:02:26 <rudol> is that a rhetorical question?
16:02:57 <rudol> it is just a question about Haskell syntax (I think) or maybe how to do it nicely in Haskell
16:03:01 <erisco> well the answer is either "no" or you're suggesting it isn't relevant
16:03:40 <rudol> It is relevant, the whole point is that semantically, I see the evaluation and player id as beibg intechangable (that's the purpose of trying this)
16:03:57 <erisco> how are those things possibly interchangeable
16:04:23 <rudol> it is a thought experiement, but I got stuck in the haskell syntax, because I believe there must be a neater way to program this
16:04:24 <erisco> if those things are interchangeable in your semantics then maybe try a different semantics
16:04:43 <koz_> Is there some connection between Data.Functor.Divisible and divide-and-conquer algorithms? I assume the terminology being the same is not a coincidence, but I'm not seeing it.
16:04:44 <rudol> think of evaluation as a noun
16:05:00 <rudol> and its domain as 1 and 2
16:05:04 <rudol> same as Player
16:09:13 <erisco> if they're the same then I am just going to keep calling it an Evaluation then
16:09:42 <rudol> that makes sense in the context of choosing a "best" move
16:10:08 <erisco> so, what does the root label tell us? in other words, what state of the board are we looking at and what does the associated evaluation say about this board?
16:11:07 <rudol> the root is not so important, it is where we are currently at. The idea is to choose the best child Node (ie best move)
16:11:22 <erisco> cool. I'm asking about the root though.
16:12:26 <rudol> here's a bit more code (that seems to work and look like resanable Haskell)
16:12:29 <rudol> http://lpaste.net/358070
16:13:49 <rudol> the root is not really too relevant for the bestnext function (a Board is passed in, and the gametree is derived from it, minmax puts the extra labels on the nodes of the gametree)
16:14:17 <erisco> okay, so you don't know what it is
16:14:43 <erisco> that's fine, then why bother having a root? just have the list of trees (called a forest)
16:14:54 <rudol> it is the root that's the gametree is calculated from
16:15:08 <Welkin> game your game tree a finger tree :D
16:15:27 <rudol> you need a root for creating a gametree from - root represents the current postion
16:15:53 <erisco> maybe you need to be more flexible in whether you want a gametree
16:16:34 <Welkin> could you call a 2-3 finger tree a chameleon tree, since a chameleon has its big toe and fore toe on the same side opposite the other three?
16:17:04 <erisco> if the point of us having a gametree is to find the best move, and we have information we cannot even identify in this tree, maybe it is the wrong thing to have
16:17:27 <rudol> the gametree works, as does the minimax (http://lpaste.net/358070). The question relates to making the bestnext (ie best next board position) function work and smell less bad
16:17:46 <rudol> what is it we cannot identify?
16:18:00 <erisco> what does the label of the root node mean?
16:18:05 <Welkin> what is this about smells?
16:18:36 <rudol> the gametree represents the future potential states of the games and is the basis for the minimax application over it
16:18:40 <Welkin> it's always disgusting to hear someone mention "smell" as they want to relate it to code
16:18:54 <rudol> the root is the currrent position, from which the rest of the gametree eveolves
16:18:58 <Welkin> one of those cliches that makes people sound dumb
16:19:25 <erisco> rudol, the root label is a 2-tuple, so what does each element tell us? I get that the board is the present board state
16:19:41 <rudol> I am quite happy to admit the initial code I pasted is dumb - I am looking for advice on how to improve it
16:20:15 <rudol> (Board, Evaluation)
16:20:33 <rudol> Board is [Int] - the game-board state
16:20:36 <erisco> I will reword the question then
16:20:47 <erisco> what does the evaluation, found in the 2-tuple of the root node, tell us
16:20:54 <rudol> Evaluation is Int (the value given to a position)
16:22:07 <rudol> in the root node, it is not relevant (unless you want to know what the odds of winning are rather than finding the best move - we are dealing with the latter)
16:23:00 <rudol> we will use the valuation of future nodes to establish what move is best in the current board position
16:23:32 <erisco> okay. since we do not need this root node, why don't we rethink that
16:23:32 <rudol> and the current board postion forms the basis (aka label) for the root node in the gametree
16:24:30 <rudol> are you suggesting it would be easier to write bestnext if the gametree had no root? 
16:24:36 <erisco> this will be easier for me if you let me be stupid and meander through my questions
16:25:08 <erisco> well, I'd think so, because the first thing we're doing is discarding the root, so why do we have it in the first place
16:25:15 <rudol> sure ... I am fascinated by this - it is clearly very different from how I was looking at the gametree
16:25:50 <erisco> there are two types to rose trees. there is the tree and the forest.
16:25:56 <rudol> because without a root, how do we get children? The root _is_ the tree
16:26:18 <erisco> data Tree a = Tree a (Forest a);  guess what Forest is
16:27:02 <rudol> looks like [Tree a]
16:27:46 <erisco> indeed, so what if instead of  gametree :: Board -> Tree Board  we had  gameforest :: Board -> Forest Board
16:28:26 <erisco> there is a principle I call "don't tell me what I already know"
16:29:21 <erisco> it doesn't have to be used everywhere, but if we find we're being handed back information we don't care about, especially information we already have, maybe we should change something
16:29:59 <erisco> that is, if I call gametree then I already have the initial Board. I have to because that is what gametree wants
16:30:12 <erisco> then gametree hands it back to me as a tree node
16:30:43 <erisco> maybe that's sometimes helpful, but it doesn't seem to be here
16:30:44 <rudol> the gametree takes the current position as the label for its root node 
16:30:56 <rudol> and derives the "future" from there
16:31:07 <erisco> instead, lets define gameforest and gametree b = Node b (gameforest b)
16:32:21 <rudol> do you feel that will make it easier for me to make http://lpaste.net/358069 better behaved and better looking? 
16:32:57 <erisco> do you think it makes sense to construct a root and then not even use it?
16:34:09 <rudol> I am sure there will be lots of potential improvements, but this is a fairly standard way to create gametrees (although of course I am open and grateful for all advice)
16:34:26 <erisco> and semantically we just care about what happens next in the game, not how it currently is
16:35:16 <rudol> I don't follow - we pass in the current board and create a gametree from there to the end of the game
16:36:11 <erisco> gameforest b = map gametree (applymoves b (moves b))
16:36:19 <erisco> gametree b = Node b (gameforest b)
16:36:26 <erisco> and you need to get your base cases in there
16:36:48 <rudol> gametree :: Board -> Tree Board gametree z@[0,0,0,0,0] = Node z [] gametree b = Node b (map gametree (applymoves b (moves b)))
16:36:59 <erisco> now when we are trying to determine the next move we just need the gameforest from the current board, not the gametree
16:37:23 <erisco> and thus we won't bother ourselves with making a root node for the current state just to toss it away
16:37:30 <rudol> OK, but that might make the tree less like a tree (ie no single root)
16:38:00 <erisco> it might be like a forest
16:39:54 <rudol> I thought a "Forest a" was a "Tree a". Are you saying it does not need a root? or will you create a root for each child (ie each next-position-one-move forward-from-current-position)
16:40:30 <koz_> Is there any link between Data.Functor.Contravariant.Divisible and divide-and-conquer algorithms? I assume the coincident terminology is not an accident,but I'm not seeing the connection.
16:40:32 <erisco> you didn't think that. Go back to when I asked you to guess what 'Forest a' was
16:41:17 <rudol> I thought I told you it looks like a "Tree a" and you did not object ;)
16:41:34 <erisco> reread your log
16:42:23 <rudol> [02:26] <rudol> looks like [Tree a] [02:27] <erisco> indeed
16:43:04 <erisco> so what do square brackets mean to you?
16:43:06 <rudol> data Tree a = Node a [Tree a]
16:44:38 <erisco> go to the definition of Tree I gave you that uses Forest (it is right before you gave that answer)
16:47:23 <rudol>  <erisco> data Tree a = Tree a (Forest a)
16:47:41 <erisco> so, what is 'Forest a'
16:48:17 <rudol> I still don't see why this is different from the original  data Tree a = Node a [Tree a]
16:48:45 <erisco> it isn't... that is how you're supposed to figure out what 'Forest a' is, which you did
16:49:04 <rudol> we did that 25 minutes ago
16:49:22 <erisco> then 25 minutes later you said you thought 'Forest a' was 'Tree a', so I had us go back
16:49:36 <rudol> but my question is, how does this help us improve/fix http://lpaste.net/358069
16:50:32 <erisco> gametree makes a root node, it makes a Tree, and the first and only thing we do with the the root label is throw it away (ignore it)
16:50:59 <erisco> all we keep (and care about, and use) are the branches, i.e. the list of trees, i.e. the *forest*
16:51:52 <rudol> I appreciate the patient build-up and the more general advice. I am trying to first get that bit of bestnext code working and looking a bit more idiomatic. After that, I am sure we can tell Mr Hutton on the book's page that we wasted a node at the top there ;) 
16:52:46 <erisco> I didn't anticipate this taking so long, but no matter
16:52:55 <rudol> iiuuc, you are saying that the datastructure used fro the gametree is making life more complicated writing bestnext
16:53:15 <erisco> a simple step towards simplifying bestnext is to remove the redundancy of the root node
16:53:28 <erisco> we already know about forests, that's idiomatic
16:54:17 <rudol> OK, it would mean 1 less pattern match, I suppose, and that is indeed where I feel it must be  improvable
16:55:16 * hackagebot yesod-alerts 0.1.0.0 – Alert messages for the Yesod framework – https://hackage.haskell.org/package/yesod-alerts
16:55:17 * hackagebot aeson-injector 1.0.9.0 – Injecting fields into aeson values – https://hackage.haskell.org/package/aeson-injector
16:58:49 <erisco> once you have that we can look at toBoardPlayer, because I am curious as to what that is
17:01:49 <rudol> toBoardPlayer is just a way to get at the values in the tuple inside the Node ie the tuple, which holds a Board (eg [3,4,2,0,1]) and a Player (1 or 2) 
17:02:49 <erisco> it is a projector. If we use Data.Tree we already have this function as rootLabel
17:03:55 <rudol> that sounds promising, but I suppose I then need to use fst and snd 
17:04:15 <erisco> where?
17:04:27 <erisco> toBoardPlayer is equal to rootLabel
17:05:10 <rudol> OK, so I would still pattern match in the same way, so at least it would be idiomatic then
17:08:27 <schoppenhauer> hi. question: when I use mmapFilePtr, why is there ptr and offset? why do I have to get an offset parameter, why isn't there just a pointer to the memory region returned directly?
17:08:32 <rudol> In the book, I think he is shying away from using too many Haskell libs whenever he can build simple structures himself. But, TBH, I still don't see why the forest (rather than the original [Tree A]) would make things any better wrt bestnext. Is it correct that they are equivalent? Are you nudging me that way because of all the class instances that exist for Forest?   
17:09:07 <erisco> is it correct that what are equivalent?
17:10:08 <rudol> data Tree a = Tree a (Forest a)     vs       data Tree a = Node a [Tree a]
17:10:41 <erisco> there are no class instances for Forest, it is just an alias
17:10:51 <rudol> why are you strongly advocating the former over Hutton's original code (the latter)
17:10:59 <erisco> I am saying to use a forest because all we need is a forest
17:13:02 <erisco> you can see how tidily forests and trees play together
17:13:30 <erisco> a forest is a list of trees and a tree is a labeled forest
17:15:02 <rudol> that is a clear description, and it explains how you want to get rid of the root of the gametree. 
17:17:34 <erisco> if you want to use your own Tree definition then you can add the projectors using record notation
17:17:57 <erisco> data Tree a = Tree { label :: a, forest :: Forest a }
17:23:27 <rudol> I am also open to all suggestions re how to make http://lpaste.net/358069 more idiomatic based on data Tree a = Node a [Tree a]  
17:26:44 <erisco> we then have to look at what is going on with filter then head
17:27:01 <erisco> is the list guaranteed non-empty?
17:27:17 <rudol> no, that is the problem I was describinbg above
17:27:56 <rudol> so that is why I came up with the monstrosity I previously pasted with maybeFromList etc 
17:28:16 <erisco> so, is it possible there is no best move next?
17:28:46 <rudol> yes, if the game is over (ie Board = [0,0,0,0,0]
17:30:12 <erisco> okay, so the easiest way to solve this dilemma is to use Maybe Board rather than Board
17:30:30 <erisco> maybe there is a next board, chosen by the best move, or maybe there isn't
17:31:05 <rudol> if I understand you, you don't like     let (Node (b',p') ts') = minimax p (gametree b) 
17:31:17 <erisco> no, I do not
17:31:40 <rudol> which is only useful, as a root node, to get at its children, from which one will win
17:31:40 <erisco> it isn't a crime against humanity but it seemed simple to remove this redundancy
17:32:25 <erisco> and it seemed simple because I identified how it relates to trees and forests
17:32:42 <rudol> that's fine by me, and I want to improve it as much as I can, but for now, I am focusing on just this function, with the hand-rolled datastructures in the book
17:33:28 <erisco> okay, fine, if we are not going to change minimax or gametree then at least we can add projectors to our Tree definition
17:33:32 <rudol> I think I have committed far worse crimes in that few lines of code than the one we have been discussing so far
17:33:43 <erisco> then instead of pattern matching it is  label (minimax p (gametree b))
17:33:53 <erisco> er, not label, but forest
17:34:35 <erisco> and we want a projector for the label later anyways, so lets get those defined
17:35:03 <rudol> OK, I totally agree with you, but what if I have to use data Tree a = Node a [Tree a]; say I have no choice. I was really looking for ideas on how to improve that function (and get it to work more consistently!)
17:35:47 <erisco> then I would separately define  label :: Tree a -> a; label (Node l _) = l;  forest :: Tree a -> [Tree a]; forest (Node _ ts) = ts
17:36:38 <rudol> I think that will already make things cleaner, thank you
17:37:17 <erisco> then for the searching there are several ways to massage it, but a quick Hayoo search pulled up firstJust :: (a -> Maybe b) -> [a] -> Maybe b
17:38:31 <rudol> OK, again, looks  better than my attempt with fromMaybe
17:39:18 <rudol> PS never heard of hayoo either - looksk useful, thanks
17:46:00 <erisco> fmap fst . mfilter ((= p) . snd)  seems depressing
17:46:24 <erisco> this fst/snd pattern comes up often enough that I am now annoyed by it
17:47:30 <MarcelineVQ> what is that there?
17:47:43 <platz> I'm trying to format a UTCTime as a string that only has 3 second decimals but the %Q format character always gives 12 second decimals
17:48:10 <platz> e.g.getCurrentTime >>= return . formatTime defaultTimeLocale "%Y-%m-%dT%H:%M:%S%Q%z"
17:48:13 <platz> "2017-08-30T00:45:06.479156734+0000" == "2017-08-30T00:45:06.479156734+0000"
17:48:35 <erisco> it often comes up that you annotate elements and then filter or sort or find a maximum or *something* by the annotations
17:48:41 <erisco> and in the end you just want the elements
17:49:14 <platz> well it appears it it actually gives 9 second decimals, but still want only 3
17:49:20 <MarcelineVQ> ah thank you, I know about decorate foo undecorate, rather I was wondering what the filter line was in regards too. what the context of bringing it up was
17:49:43 <eschnett> platz: can you round the number of seconds to 3 decimals before handing it to %Q?
17:49:56 <erisco> rudol would need that for applying to firstJust
17:50:29 <platz> eschnett: perhaps, but it means i can't take the format string as a config paramaeter
17:51:02 <MarcelineVQ> erisco: oh I see they're working with tuples in their problem, thank you
17:51:20 <mnoonan_> what’s the consensus on “extra” stuff that should/should not go in a git repo? Specifically, .gitignore? stack.yaml?
17:51:30 <erisco> rudol, a macroscopic problem, potentially, with the program is that you will reconstruct the whole game tree for each move
17:51:48 <MarcelineVQ> mnoonan_: yes to both imo
17:51:57 <MarcelineVQ> oops, yes to include both
17:52:24 <erisco> rudol, is it refined or changed in any way after a move is made?
17:53:24 * hackagebot flow 1.0.9 – Write more understandable Haskell. – https://hackage.haskell.org/package/flow
17:53:42 <mnoonan_> MarcelineVQ: that suits my bias. thanks!
17:55:12 <rudol> ericso, this is true. This is a very limited little game, so it still performs OK, I expect(!), on an average laptop. There are quite interesting optimisations for more challenging games.
17:55:50 <erisco> if we wanted an interactive game, so one player is the human (or whoever the program is reading by standard input) and the other is the AI
17:56:22 <erisco> and we have all possible games before us in a tree, then all making a move is is selecting a child in the current tree, then this child becomes the new current tree
17:56:59 <erisco> since the AI requires moves to be annotated with evaluations, the tree we keep around will be the annotated one
17:57:36 <rudol> yes, especially in this example game, where we can calculate _all_ combinations of moves (every time, as you say)
17:58:08 <erisco> you calculate them all ahead of time
17:58:25 <erisco> you're doing that anyways, you're just discarding all the work each move
17:58:34 <rudol> exactly
18:03:13 <rudol> with tictactoe as well, you can calculate the whole gametree and identify best moves, all upfront, once and for all. Google have also done something interesting to beat 2 top Go players by introducing some Monte Carl Simulation (looking ahead to evaluate what the chances are of various moves leading to advantageous/won positions) which seems to be a big advance in this area.
18:03:47 <mnoonan_> the monte carlo search was already a known technique for ~10 years
18:03:56 <mnoonan_> in go, that is
18:04:46 <erisco> all I know about AlphaGo is from Michael Redmond
18:04:49 <mnoonan_> it helped get to strong amateur level, but no more than that. still, it was a huge leap compared to computer go before monte carlo search
18:05:16 <erisco> Monte Carlo is part of it, iirc, but there is a lot more going on in the its brain
18:05:17 <rudol> I too read that it is not a totally new approach, but Google have made it work
18:05:44 <erisco> going on in its brain
18:06:42 <mnoonan_> the novelty of alphago is in the policy networks for move suggestions. iirc, in the original paper they showed it already was the best computer go system even if monte carlo and everything *but* the policy networks were disabled
18:07:16 <erisco> I did hear that from the engineers, that it was already really strong just with that one piece of it
18:09:03 <erisco> Lee Sedol was the last hope for humans in game 4, finding that one improbable move
18:14:17 <erisco> I just hope at the end of things we have a clear understanding of intelligence rather than an algorithm gumbo
18:18:07 <mud> erisco: At the end of alphago? We won't.
18:18:51 <JuanDaugherty> something may be learned about "monetization"
18:19:01 <erisco> what I am referring to is the increasing use of AI in industries
18:19:17 <JuanDaugherty> as over against what IBM learns from Watson
18:20:02 <erisco> are we going to withhold our exuberance in wait for knowledge and wisdom? no
18:20:22 <JuanDaugherty> i am
18:20:41 <mnoonan_> erisco: DARPA has a new program for explainable AI methods.. I don’t know who ended up proposing on it, but it could be interesting
18:20:44 <JuanDaugherty> till i fucking die if i have to submit to the slaver creeps
18:20:47 <erisco> in other words, I fear AI will become useful faster than we understand it
18:21:14 <mnoonan_> “program” in the organizational sense, not the computer-science sense
18:27:32 <erisco> just for fun I sometimes think about the nature of intelligence... I don't do much reading on it because it is the thinking that is the fun part
18:27:48 <erisco> but I identified one aspect that I might want to read in detail on...
18:28:46 <erisco> it seems to me that a basic feature of intelligence is to identify patterns in data
18:29:04 <erisco> data that, absent of any perception of patterns, is just whatever it may be, who knows
18:29:19 <erisco> and these seemed to be called "feature extraction" when I did some reading
18:29:52 <erisco> but, the methods of feature extraction seemed to be predicated on knowing the kinds of patterns we want to see
18:30:14 <erisco> so how is it then we could know the kinds of patterns we want to see before we even know what the nature of the data is
18:30:31 <erisco> seeing as we have ourselves as successful examples of this
18:30:58 <erisco> and then I realised an explanation could be evolution, i.e. there is no necessity that we know these pattern kinds beforehand
18:31:09 <JuanDaugherty> because thats the way the human mind/brain develops, as a composite of predictive networks
18:31:23 <erisco> there is merely iterative guesswork and the brains that happened upon the relevant patterns survived
18:31:48 <JuanDaugherty> mere pattern recognition occurs in simple organisms
18:31:52 <erisco> this seems an obvious conclusion but I don't know what in particular to read on this specifically
18:32:23 * JuanDaugherty is currently reading "How Emotions are Made", it's relevant
18:33:12 <erisco> yes, prediction is another thing I reasoned was primary to intelligence
18:33:43 <nshepperd_> Which patterns appear in what context is a kind of pattern that occurs in life
18:34:00 <nshepperd_> And is learnable
18:34:54 <erisco> nshepperd_, but it doesn't seem to me possible to have machinery capable of identifying arbitrary patterns
18:35:23 <erisco> rather you'd have machinery that sees certain patterns, and the machinery we ended up with was that which was useful to survival and procreation
18:35:50 <nshepperd_> That's what kolmogorov complexity is about
18:36:10 <erisco> well I happen to know a little about that, but I am not sure exactly how it ties in here
18:36:18 <nshepperd_> Solomonoff induction is the general pattern identifier
18:36:54 <nshepperd_> But it's uncomputable of course, so anything real is an approximation
18:37:16 <erisco> "Solomonoff's theory of inductive inference" ?
18:37:59 <nshepperd_> Yes
18:38:00 <erisco> that seems right on the money, so I will read about that
18:38:33 <erisco> I encountered Kolmogorov complexity during my attempt to learn information theory (but the notation drove me so mad that I quit)
18:38:56 <erisco> the part I was after was the algorithms which found optimal codes for streams with unknown distributions
18:39:26 <erisco> that sounded highly relevant to this problem of finding patterns where when we don't know anything up front
18:39:53 <erisco> but when I skipped ahead I discovered they were predicated on some fairly specific assumptions about what kind of distributions these could be
18:40:22 <erisco> now I am seeing Solomonoff inductive inference merely requires a computable distribution, and so that is plenty general for me ;)
18:40:34 <JuanDaugherty> post natal at least
18:40:37 <nshepperd_> I think that people have evolved a mixture of general purpose (whatever that means) and task specific pattern recognition. That's the efficient way to do it
18:40:44 <JuanDaugherty> you always know something upfront
18:41:11 <erisco> well, the explanation of evolution suggests no one has to know anything up front, that's the nice thing about evolution
18:42:02 <erisco> so then we'd think about genetic algorithms to reproduce this phenomenon, I'd suspect
18:42:16 <nshepperd_> On priors we expect the universe to make sense in some general ways. Such priors are evolutionarily successful *because* the universe makes sense
18:42:51 <JuanDaugherty> off-topic or blah i think
18:50:18 <rudol> ericso - http://lpaste.net/358072 . Still the annoying (p == ).snd lives  but  eliminating calls when there's "no best move" (ie gameover) simplified things, and I benefited from some of your other suggestions too. It runs quite fast (only moves 1 & 2 take over a second). Thanks again. Surely that if block can be better, especially the any followed by filter filter?
18:51:56 <erisco> you can use a function such as firstJust, or find
18:53:33 <erisco> and then it is idiomatic to use g . f rather than let x' = f x in g x'
18:55:21 <rudol> is that in reference to selcrit?
18:55:48 <rudol> I refactored that into the let to avoid replication 
18:56:15 <erisco> I don't know what you're doing with if/then/else
18:57:27 <erisco> that advice is in reference to every place that pattern fits
18:58:06 <rudol> if there's a label whose 2nd element is equal to the player id at that level, then use the associated next board, otherwise, (there is no winning path) take any (head) board.
18:59:08 <erisco> it wasn't needed before, I don't see why it is needed now
18:59:34 <wedify> does anyone have example of using javascript with threepenny-gui? None of the examples use javascript. It's not clear to me from the api docs how to emit javascript
18:59:46 <erisco> all we want to do is find an element in the list which satisfies a predicate
19:00:00 <erisco> this element may or may not be found, which we addressed by using Maybe
19:00:25 <erisco> there are several functions which do just this, such as firstJust, or find, to name two
19:00:52 <rudol> that was actually one of the first reasons I stated for having to refactor. Now it is easier to write and understand the code than before (and it works!). I will look some more tomorrow.
19:02:22 <rudol> no, it's a bit more involved than that. If there is an element for active player take it, if there is none, take any (because it will belong to the only other player anyway - this is the smarta.rsed shortcut :0
19:03:06 <rudol> we talked about maybe more in the context of "if there is no best move" (which is no longer possible). 
19:03:43 <rudol> best move does not, unfortunately always mean "a move that improves your position"!
19:06:32 <rudol> anyway, I will definitely look more thoroughly at find and friends, but it seems I will still need some "if" messiness.
19:06:41 <erisco> you won't
19:08:48 <mnoonan_> is WrappedArrow used in practice?
19:08:59 <mnoonan_> I don’t recall ever running into it before
19:10:56 <rudol> if find returns Just ([1,2,2,2,2],1), I can return [1,2,2,2,2], but if find returns nothing, I still need to send something from that list back (as it stands, I return its head).
19:11:23 <rudol> s/nothing/None
19:11:48 <erisco> well, if the prominence of Arrow is transitive to other things with Arrow in the name, then no, it is not used much
19:12:38 <mnoonan_> P(uses WrappedArrow | uses Arrow), then :)
19:15:21 <erisco> I'd have to check but you might have pointed out a way for me to make use of WrappedArrow
19:18:07 <monochrom> Oh wait, so cabal-install 2.0 calls curl to download the packag list now?!
19:20:27 <erisco> hm, nope, sorry mnoonan_, doesn't help me
19:20:38 <Eduard_Munteanu> That kinda makes it reasonable to just use the https endpoint. Not sure if the latest cabal has the verification in place.
19:23:54 <monochrom> Along with a lot of proxy, firewall, socks issues that people have got curl to work and cabal-install may as well use that instead of yet another custom solution, yeah.
19:31:13 <gp5st> maybe I've been mistaken, but it seems like there is a habit/culture in the haskell of just looking for functions by type/signature as that gets you pretty far towards an answer.  Is there a name for that?
19:31:55 <EvanR> "taking types seriously"
19:31:56 <c_wraith> gp5st: I don't think so.  It's just what happens when you have an expressive type system.
19:32:17 <EvanR> there is type-directed development, but thats something else
19:32:18 <gp5st> EvanR, c_wraith ^_^
19:32:48 <gp5st> having glimpsed better things makes me hate my job in PHP and Ruby
19:33:27 <EvanR> thats one of the first stages
19:34:01 <gp5st> stages of?
19:34:18 <EvanR> post-haskell syndrome
19:34:34 <gp5st> :)
19:34:50 <gp5st> not even just that, but Rust and C++
19:35:14 <gp5st> I used to do Java work and it's painful because the system goes pretty far, but just not far enough to be really expressive 
19:35:58 <tabemann> I missed something
19:36:04 <tabemann> what is post-haskell syndrome
19:36:22 <c_wraith> What you get when you realize your day job is not using Haskell
19:36:29 <tabemann> is it the whole "all languages other than haskell, agda, and coq irredemably suck" thing
19:36:34 <gp5st> tabemann, hating languages w/o expressive types
19:36:34 <EvanR> no
19:36:54 <EvanR> haskell is visible from the standpoint of everyday jobs and their programming languages
19:37:16 <EvanR> when you look into it, you are like wtf, why doesnt everything already have these features (actually, they are acquiring them slowly)
19:37:35 <EvanR> then from the haskell standpoint, you see other languages with features haskell doesnt have
19:37:41 <EvanR> then you get more symptoms
19:38:06 <EvanR> but those languages arent on the radar until you do haskell, in my experience
19:38:32 <tabemann> my day job is, as I would call it, software archaeology, so I'm kinda used to using suboptimal tools
19:39:08 <EvanR> well, there are many ways haskell is suboptimal
19:39:40 <gp5st> mine's interesting. They've tried to do "the right thing" but it ends up becoming very complex, and doesn't actualy solve the real problem because it wasn't fully known at the time
19:39:44 <EvanR> we havent begun to really tap into the potential of programming languages
19:40:40 <tabemann> I work on a codebase that is at least 25 years old that is a rat's nest of C, C++, pre-Apple Objective C, and Java
19:40:52 * gp5st backs away
19:41:03 <erisco> mind you, there is a time shift between industry and current research
19:41:44 <erisco> we haven't really tapped what we already know
19:41:47 <EvanR> whats the scale of that shift?
19:43:08 <jared-w> Like 20-30ish years, maybe as much as 50-70 depending on the industry?
19:43:25 <EvanR> haskell is almost 30
19:43:44 <EvanR> but 30 seems like an under estimate
19:43:55 <tabemann> scheme is how many years old?
19:44:05 <jared-w> yeah and the PL research that went into Haskell was from the ~60-80s and has yet to reach 90% of mainstream languages :p
19:44:10 <c_wraith> scheme is a lot newer than lisp in general, which is like... almost 70
19:44:11 <EvanR> you can blame "unfortunately immortal" programming languages!
19:44:37 <c_wraith> lisp slightly predated computers that could run it. :)
19:44:48 <tabemann> key innovations from scheme are just starting to enter mainstream languages
19:44:49 <EvanR> after a critical mass of code has been written in it, it cant be allowed to die, however terrible they are
19:45:07 <gp5st> idk, maybe i'm cynical, it's like everything that's "mainstream" hasn't learned from _anything_ that's happened in the past 30 years :-\
19:45:13 <tabemann> (well, javascript has had lexical closures for a while)
19:45:40 <EvanR> in the future, mainstream languages will have laziness and will think its cool :)
19:46:00 <EvanR> but it will probably be klunky and annoying to use
19:46:15 <c_wraith> EvanR: doesn't that already describe scala?
19:46:27 <EvanR> yes, but do they think its cool
19:46:36 <tabemann> the problem with laziness is most other languages' attempts at it are useless, because they are strict first and lazy second, but laziness has to be primary to be useful
19:46:59 <EvanR> i have heard varying opinions on that
19:47:30 <EvanR> whether defaulting one way or another is better
19:47:46 <EvanR> in any case, you want to be able to do both
19:47:53 <tabemann> does anyone ever actually use support for laziness in MLs or Lisps?
19:48:15 <EvanR> clojure has an amount of lip service to laziness
19:48:15 <monochrom> Chris Okassaki did. For his thesis/book :)
19:48:35 <tabemann> I have his book; now I have to find it
19:48:37 <gp5st> I would be overjoyed if strong, expressive type systems became normal over the laxness of python, ruby, php, javascript and the ridgid, unhelpful ones of C and java
19:49:19 * EvanR sips some koolaid
19:50:04 <EvanR> i fully believe that and agree with you, despite not having the slightest idea what that would need to look like to really compete in the wacky worlds they dominate
19:50:10 <gp5st> c++ isn't all too bad, but all that unsafe memory operations is a but scary
19:50:46 <EvanR> haskell itself is missing some good support for poorly thought out record hierarchies
19:51:08 <gp5st> I'm really really excited about Rust, but just don't have the time to play with it, or haskell, or adga :-\
19:51:11 <EvanR> extensible records or something, which many haskell inpsired languages have in some capacity
19:52:01 <EvanR> extensible variants may or may not make exception shenanigans convenient
19:52:11 <EvanR> i dont know of any language that has that
19:52:20 <Cale> Ermine
19:52:28 <EvanR> really?
19:53:04 <Cale> Oh, variants? I'm not sure
19:53:21 <EvanR> yeah, add a case on the fly
19:53:46 <EvanR> is ermine available for use by the general public?
19:53:50 <Cale> It is
19:54:01 <EvanR> i might need to check that out
19:54:17 <Cale> I don't know how many users it has outside of the people who built it though :)
19:54:33 <EvanR> safety in numbers ... 
19:54:39 <tabemann> the thing about traditional objects is I don't see how they are a good thing
19:54:41 <monochrom> ocaml has open variants
19:54:56 <EvanR> oh nice
19:54:57 <monochrom> but ocaml also has open records (because it has to do OOP anyway)
19:55:04 <tabemann> e.g. traditional objects easily break modularity if you're not very, very careful with how you do them
19:55:07 <S11001001> EvanR: https://bitbucket.org/ermine-language/ermine-scala
19:55:24 <EvanR> is a traditional object the same thing as a record
19:55:40 <tabemann> EvanR: I mean like a C++ or Java object
19:55:55 <Cale> dolio: Does ermine have extensible variants?
19:56:27 <EvanR> tabemann: gross
19:56:33 <S11001001> Cale: no
19:57:01 <EvanR> so the main implementation is written in scala
19:57:11 <EvanR> that seems odd
19:58:11 * hackagebot yesod-auth 1.4.18 – Authentication for Yesod. – https://hackage.haskell.org/package/yesod-auth
19:58:26 <monochrom> ezyang: I see that new haddock (comes with GHC 8.2.1) has a new top-level section title "Signatures" in addition to the traditional one "Modules". Is that your doing?
19:58:29 <EvanR> i guess it answers the java compatibility question
19:58:36 <tabemann> to me the ideal object sytsem is one in which there is implementation inheritance
19:58:46 <tabemann> *system
19:58:50 <EvanR> implementation inhertiance :(
19:58:55 <tabemann> *no implementation inheritance
19:59:14 <tabemann> i.e. interfaces, to use Java terminology, only
19:59:15 <Cale> tabemann: Just use Haskell, hah.
19:59:26 <EvanR> well then youre really just asking for records, or extensible records
19:59:37 <Cale> Inextensible records of methods :)
19:59:42 <monochrom> Yeah, go row polymorphism. :)
19:59:57 <Cale> Well, row polymorphism might make that a little nicer anyway
20:00:18 <monochrom> I think tabemann means interface inheritance is still desirable
20:00:25 <tabemann> yes
20:00:42 <Cale> But I'm actually not sure how much that's really needed. A lot of the draw to inheritance came out of the fact that method implementations were tied to the types.
20:01:32 <Cale> Once you can easily implement objects of the same type in many different ways, subtyping really doesn't seem all that important.
20:01:35 <erisco> I thought the draw was virtual methods
20:01:39 <EvanR> im all for expressive programming at the type level
20:01:56 <EvanR> compute a record type as a concatenation of 3 others
20:02:45 <EvanR> as long as theres a debugger to get a print out of the final answer for documentation, easy understanding
20:03:14 <EvanR> then you dont need a separate restricted concept of inheritance
20:03:23 <Cale> The one thing which I don't like about row polymorphism is the weird way that it makes names more important than they ought to be.
20:03:31 <Eduard_Munteanu> Some of the Javascript-interoperable Haskell dialects have that.
20:03:34 <Cale> The names of the fields, that is.
20:04:33 <EvanR> for an anonymous record type... isnt the fields exactly 50% of the importance
20:04:42 <Cale> It seems like it might be a coincidence that something happens to have a field of the right name and type
20:04:58 <Eduard_Munteanu> Inheritance seems to be a single-axis thing, while traits/mixins/typeclasses seem to allow multiple axes of classification to exist.
20:05:42 <EvanR> it fails to work so much, they invented multiple inheritance :)
20:06:53 <monochrom> Cale: The extreme of self-important field names are a revolt to the other extreme that is mathematicians' "a Turing machine is a 7-tuple (Sigma, Gamma, delta, iota, eta, zeta, Xi)"
20:07:18 <monochrom> And oh add a :) at the end of that. :)
20:07:37 <Cale> hah
20:07:51 <ezyang> monochrom: Yes, and it's a bug! 
20:08:05 <EvanR> "names are hard"
20:08:44 <Eduard_Munteanu> That's why I tackle naming before implementation. :P
20:08:46 <EvanR> we should just use balanced parenthetical expressions for every thing
20:08:55 <monochrom> More seriously, at our current state of technology and people's attitude, the only two practical choices are really named fields (with oh-so-meaningful names) and tuples. Named fields are really the lesser evil here.
20:09:16 <EvanR> monochrom: is every such tuple a turing machine?
20:09:16 <monochrom> In my ideal, we use formal specifications, not petty names.
20:09:32 <Cale> monochrom: Yeah, the funny thing about it is that people will give definitions like that and then never actually use the 7-tuple-ness directly again.
20:09:49 <Eduard_Munteanu> Sure, names are just unique ids which are supposed to have some underlying semantics.
20:09:54 <monochrom> EvanR: Probably not. But if I may finish that sentence with "such that <10 conditions here>" then it is.
20:10:16 <EvanR> ok, then we moved the evil names into the name "turing machine"
20:10:43 <EvanR> speaking of which, i demand the ability to use spaces in names
20:11:03 <Eduard_Munteanu> That would be nice, yes.
20:11:26 <Cale> EvanR: Yeah, there's a single name for the complete concept, it doesn't matter as much after that what the parts are called, or the specifics of how the structure is built (what order the tuple components come in, etc.)
20:11:55 <Eduard_Munteanu> In fact, names should be IDs with a description metadata serving as documentation.
20:12:11 * EvanR looks at the pile of XML-based standards
20:12:19 <monochrom> Oh God please don't go RDF >:)
20:12:32 <EvanR> bureaucrats dream
20:12:57 <Eduard_Munteanu> I was thinking a binary AST representation of source code, not jumbling up more textual formats into the mix.
20:13:08 <EvanR> before that stuff takes over, artificial intelligence will both make it obsolete and illegal for being so bad
20:14:29 <EvanR> itll be able to identify whats important about e.g. the puny human explication of what a turing machine is, and understand it, and explain it back to us in a context appropriate way :)
20:14:53 * monochrom begins to write a book called "The Road To Hell: How Record Systems Became Ontology Systems: A PLT Researcher's Digress"
20:15:36 <Baltazaar> Hola folks -- I was using mirc 20 years ago. First time since. Getting back into the IT realm. I don't quite remember what to type in order to see the list of automatic commands (for autojoin, register a username w/ pw, create bot .. )
20:16:34 <monochrom> I thought you just had to click on menus. It's mirc on Windows.
20:16:45 <monochrom> But maybe /help helps.
20:16:49 <Eduard_Munteanu> Baltazaar, "/msg nickserv help" for network-related stuff like usernames or "/help" for IRC client commands help
20:17:11 <Baltazaar> Nickserv! Yes. Thank you :D 
20:17:21 <JuanDaugherty> Baltazaar, normally just /help at the freenode window/promt
20:17:26 <JuanDaugherty> *prompt
20:17:36 * Baltazaar is thankful
20:17:39 <JuanDaugherty> (or any irc server)
20:17:59 <Baltazaar> It's like riding a bike :D 
20:19:01 <Eduard_Munteanu> Also see https://freenode.net/kb/answer/registration
20:21:27 <EvanR> "the IT realm" conjures situations from "the IT crowd"
20:23:39 <Baltazar> It does. Really. 
20:23:49 <Baltazar> I worked in forestry in the mean time.
20:23:56 <Baltazar> really, another UNIVERSE
20:24:47 <EvanR> in the future trees will be genetically engineers to be solar powered and run haskell
20:25:14 <Baltazar> Ah! 
20:25:35 <Baltazar> Genetically engeneered, likely if we remain on the same  track
20:26:12 <freeman42x> is there an equivalent github that does this for Haskell? https://areweideyet.com/#visualstudio except: https://wiki.haskell.org/IDEs and https://wiki.haskell.org/Editors
20:27:11 <Baltazar> Is haskell being used to code dna? 
20:27:49 <EvanR> https://wiki.haskell.org/Applications_and_libraries/Bioinformatics
20:27:55 <halogenandtoast> \q
20:42:51 <orzo> so i'm running "ghci -fdefer-typed-holes"
20:43:05 <orzo> and then I say ":t bs" without ever having defined bs
20:43:11 <orzo> and it says it's a typed hole
20:43:36 <orzo> but the doc, https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#typed-holes makes it seem like only underscore-prefixed symbols can be holes
20:44:26 <orzo> I've been using this typed-hole thing and now I accidentally have code making use of undefined symbols
20:44:28 <mud> orzo: "All unbound identifiers are treated as typed holes, whether or not they start with an underscore. The only difference is in the error message:"
20:44:51 <orzo> oh
20:45:04 <orzo> well is there a way to error for the non-underscore symbols?
20:45:14 <mud> It is an error, isn't it?
20:45:23 <mud> Oh with defer ... uhm, I dunno.
20:46:37 <orzo> the thing is, i have a lot of todo stubs
20:46:42 <orzo> so i shut off the warning
20:46:52 <orzo> but then there's inadvertant typed-holes that I never saw
20:47:43 <orzo> maybe when you combine -fdefer-typed-holes and -Wno-typed-holes it should implement the behavior I want
20:47:59 <orzo> as the behavior it is implementing seems like something you'd never want
20:49:06 <orzo> actually, if there's a way to shut-off only the underscore wanrings (rather than -Wno-typed-holes), then that would be acceptable
20:49:13 <orzo> it's not that i need an error
20:49:29 <orzo> it's that i want to silence only the underscore-prefixed version
20:51:12 <orzo> how do other people use this feature?
20:51:13 <orzo> heh
20:53:57 <orzo> hm, manual mentions -fno-warn-typed-holes
20:54:09 <orzo> maybe i want that instead of -Wno-typed-holes
20:54:15 <orzo> or are those equivelent?
21:37:10 <jle`> hi
21:37:48 <jle`> is there any TH library available that can splice in data from some json config during compile time
21:38:06 <jle`> i guess i could use one of those include-text-from-file libraries and then decode it using aeson
21:40:38 <Lokathor> if i want to do randomIO 5 times in a row and have a list of the results
21:40:50 <Lokathor> is there a thing that does that all fancy like?
21:41:05 <jle`> replicateM ?
21:41:06 <Lokathor> i mean it takes no inputs so it seems like mapM and co wouldn't apply
21:41:27 <jle`> replicateM 5 :: IO a -> IO [a]
21:41:40 <Lokathor> oh i tried "repeat"
21:41:42 <Lokathor> silly names
21:41:52 <Lokathor> ghci said there was no repeatM
21:42:08 <jle`> `replicateM 5 x` is like mapM (\_ -> x) [(),(),(),(),()]
21:42:14 <jle`> so that was some good intution
21:42:22 <jle`> ah yeah you might have been thinking of replicate, not repeat
21:47:06 <koz_> @src replicateM
21:47:06 <lambdabot> replicateM n x = sequence (replicate n x)
21:58:41 <pacak> :t random
21:58:43 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
21:58:44 <pacak> :t randoms
21:58:46 <lambdabot> (RandomGen g, Random a) => g -> [a]
22:13:42 <monochrom> Oh haha, so it is configurable how cabal-install downloads from hackage: "http-transport: curl, wget, powershell, or plain-http"
22:13:54 <monochrom> (default is curl)
22:14:06 <monochrom> But powershell? wth :)
22:15:08 <c_wraith> when on windows, do as windows does
22:16:30 <jle`> and this whole time i thought wget was just a wrapper over curl
22:16:33 <monochrom> I'm just amused that powershell is growing into a kitchen sink. It was supposed to be a shell, a really cool and modern one but still a shell. Now it's all an http client. Soon it will be a web browser too. Soon it will also do email.
22:17:01 <monochrom> s/all an http client/also an http client/
22:17:20 <mac10688> I was cool with it the other day. I opened powershell and was able to do all my linux commands to navigate. You say it has curl now too?
22:17:36 <c_wraith> I mean, it's a scripting engine for windows core services.  I'm sure it's asking some window core service to do the downloading, rather than being powershell itself.
22:17:52 <monochrom> Oh, true.
22:20:26 <monochrom> . o O ( http-transport: sh, bash, zsh, csh, tcsh, powershell, or emacs )
22:28:38 <pacak> powershell never was a proper shell, rather than something that you would use for scripting windows services.
22:29:09 <pacak> command names are way too insane to be just shell commands.
22:49:35 * hackagebot bizzlelude 1.0.3 – A lousy Prelude replacement by a lousy dude – https://hackage.haskell.org/package/bizzlelude
23:00:56 <yushyin> monochrom: bash can do tcp, so no problem doing HTTP requests with bash
23:01:44 <monochrom> Yikes.
23:01:58 <monochrom> Haha isn't it great, I'm a prophet!
23:26:16 <tdammers> in a way, you could say that even modern zsh/bash/ksh/... aren't really just shells anymore either
23:27:01 <tdammers> lots of built-in commands, and they mess with the terminal quite a bit
23:29:26 <yushyin> zsh is huge with all its modules (man zshmodules)
23:31:30 <tdammers> it is
23:32:19 <tdammers> bit of a common trend though, moving things away from a pure Unix model towards a bit more monolithic and more opinionated solutions
23:35:50 <[exa]> tdammers: also interesting to watch the percent of such solutions that persist, most of them are basically tiny unices (emacs/tex)
23:37:58 <tdammers> indeed
23:38:09 <tdammers> although I was thinking more of things like systemd
23:39:36 <[exa]> tdammers: did you see sun's SMF?
23:39:57 <dsal> I've not heard bad things about smf, but systemd makes me pretty sad.
23:40:32 <[exa]> tdammers: systemd haters should try to manage a SMF system for a while, to see why SysV init&other linux inits sucked that hard
23:40:40 <dsal> I just want to make a program that starts when my system boots and restarts when it crashes.  That's complicated and error prone.
23:41:11 <[exa]> but yeah, systemd get that good idea and bloated it like hell
23:41:28 <tdammers> I just think systemd gave up on the unix idea a bit too much
23:41:38 <tdammers> and I think that's where most of the hate comes from
23:41:45 <dsal> I've had good enough results with launchd.
23:41:51 <dsal> It's just... not very cross platform.
23:42:04 <tdammers> because systemd basically said, "fuck this whole unix nonsense", and people got emotional over it
23:42:12 <[exa]> tdammers: the main problem is actually caring about 'common desktop user'
23:42:28 <dsal> It's not the "this isn't UNIX" that I hate.  It's the thing where deploying an app as a non-root user actually requires root access.
23:42:40 <[exa]> tdammers: yeah which includes screwing unix :D
23:43:15 <boomshroom> Hello
23:43:24 * [exa] . o O ( someone should rewrite that in haskell )
23:43:31 <[exa]> mornin'
23:43:33 * pacak finds most of Poettering‎'s creations stupid
23:43:47 <[exa]> oh lennart, the C programmer
23:43:55 <boomshroom> This is my first time in this channel. I've been playing around in haskell recently and have run into something that probably isn't supported.
23:44:02 <boomshroom> What I'
23:44:07 <dsal> Hopefully it's not systemd
23:44:09 <speak> A lot of people also think someone like Poettering should not have such a huge influence on the whole linux ecosystem
23:44:17 <[exa]> boomshroom: ask away, we're just in a middle of systemd hate :D
23:44:25 * speak hates
23:44:40 <boomshroom> What I'd like to do is have an anonymous enum as a field inside another enum.
23:44:40 <Axman6> this hate should probably move elsewhere (-blah for instance)
23:44:44 <sbrg> ^
23:44:51 <pacak> also journald and a bunch more crap ending with d...
23:45:05 <[exa]> speak: linux culture is ruled by do-oism (just as debian), well he nailed it
23:45:19 <speak> [exa]: I'll move it into -blah
23:45:25 <Lokathor> boomshroom, no anon enums really. you can do Either Foo Bar, if there's just two options 
23:45:33 <Axman6> boomshroom: what do you mean by annonymous enums?
23:45:47 <[exa]> boomshroom: any reason why two definitions of data are too much?
23:45:55 <boomshroom> On the topic of systemd, does anyone know of a recent tutorial to test a custom pid 0? :P
23:45:55 <Lokathor> Axman6, the "enum version" of tuple, i assume
23:46:11 <[exa]> boomshroom: lol
23:46:42 <boomshroom> Either is probably the write answer. I currently have `| SE Reg (Const Word8 | Reg Reg)` as a part of my enum of CHIP-8 opcodes.
23:47:52 <boomshroom> I remember http://www.mustafaak.in/2016/02/08/writing-my-own-init-with-go.html, but I've had trouble getting it to work recently.
23:47:53 <Lokathor> https://github.com/Lokathor/weeklygamejam7/blob/master/app/Main.hs#L22 look at those delicious list literals
23:48:15 <cocreature> boomshroom: often you are better off making new types and giving the constructors more descriptive names than "Left" and "Right".
23:49:19 <boomshroom> cocreature: It's mostly because I'm not entirely sure how much it will be used. It will probably be used enough to warrant its own type.
23:49:52 <cocreature> boomshroom: depending on how you’re using it the costs of introducing new types are pretty small
23:50:59 <boomshroom> cocreature: When compiled, 2 enums with the same number of variants and each variant has the same number of arguments should be identical.
23:51:43 <cocreature> boomshroom: I was referring to costs in terms of changes you need to make and maintenance not runtime cost
23:52:21 <boomshroom> `data Arg = Const Word8 | Reg Reg` = `type Arg = Either Word8 Reg` But one is better in the short term, and the other in the long term.
23:52:57 <Lokathor> choose the one that will give you smarter results if you accidentally mismatch things
23:53:44 <wogi> What are people using haskell mainly for?
23:53:51 <cocreature> "data Arg = Const {-# UNPACK #-} !Word8 | Reg {-# UNPACK #-} !Reg" :)
23:54:29 <cocreature> boomshroom: tbh I assume you are saying "Either Word8 Reg" is better in the shortterm but I’m not sure I’d agree with that
23:55:07 <cocreature> you are probably not going to use large parts of the API provided by Either so the only difference is that the constructors are named differently
23:55:21 <boomshroom> cocreature: "Short term" as in "only used once in the entire program." Also, enum variants can have the same name as types right?
23:55:55 <boomshroom> leading to things like `| Reg Reg Reg` :P A register to register operation.
23:56:09 <cocreature> boomshroom: even if you only use it once in your program, declaring the type synonym is barely shorter than declaring a new type
23:56:26 <cocreature> and "Const 5" tells me a lot more about what this is supposed to represent than "Left 1"
23:57:04 <boomshroom> true. I did use it the exact next operation.
23:57:34 <wogi> Can anyone explain to me why haskell is so popular right now? (not sure if it has always been but i am noticing it a lot more) what are people usually using haskell for?
23:57:52 <cocreature> boomshroom: you might also be interested in https://github.com/quchen/articles/blob/master/algebraic-blindness.md 
23:57:57 <cocreature> wogi: writing software :)
23:58:19 <wogi> cocreature But in what area is it popular? 
23:59:02 <wogi> cocreature Like python is popular for django/fask and scientific stuff
23:59:50 <cocreature> apart from a few areas like embedded development and other low-level stuff, people use Haskell for all kinds of things
