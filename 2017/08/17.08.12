00:04:05 * hackagebot svg-tree 0.6.2 – SVG file loader and serializer – https://hackage.haskell.org/package/svg-tree
00:18:55 <mibaz_1> Why didn't datakinds add a new keyword for making kinds? Why did they use data?
00:19:20 <erisco> mibaz_1, the syntax is exactly the same
00:20:50 <erisco> maybe I misunderstood the intent of your question... ultimately you want to have the same capabilities on the type level as you do on the value level
00:21:24 <dmwit> mibaz_1: GHC HQ has historically been very nervous about adding new keywords.
00:21:46 <cocreature> mibaz_1: it’s also really convenient that it’s not a different syntax. that way you can use it both as a kind and as a type without having to define it twice
00:21:54 <dmwit> mibaz_1: They don't like the possibility of making existing code suddenly have a keyword in it.
00:23:53 <mibaz_1> I get the keyword thing, and I understand it is more of an attempt to merge type and value than to allow explicit manipulation of either
00:24:02 <mibaz_1> That answers my question
00:25:22 * hackagebot rasterific-svg 0.3.3 – SVG renderer based on Rasterific. – https://hackage.haskell.org/package/rasterific-svg
01:16:56 <Franciman> Hello
01:17:09 <Franciman> Do you know how I can set macosx minimum version for an haskell program?
01:17:43 <dysfun> that's only a linker flag isn't it?
01:17:49 <Franciman> guess so
01:18:08 <Franciman> because when I create a bundle for my executable, os x says it targets 10.12 and I just have 10.11
01:18:13 <dysfun> cabal has linker settings
01:18:16 <Franciman> (but I'm using the right libs)
01:18:58 <Franciman> dysfun, I used to use -mmacosx-version-min with clang
01:19:00 <dysfun> that's quite impressive actually, defaulting to an osx version you don't have
01:19:06 <ab9rf> heh
01:19:09 <ab9rf> was thinking the same
01:19:16 <Franciman> is it the right name for the linker?
01:19:26 <ab9rf> Franciman: did you tell it to use llvm-clang?
01:19:42 <Franciman> I installed ghc & cabal from homebrew
01:19:46 <Franciman> default install
01:20:55 <ab9rf> i thin ghc uses its internal compiler by default, instead of clang, even on macos
01:21:06 <ab9rf> you might need to use -fllvm if you want to use clang-specific flags
01:21:11 <Franciman> I hope it supports this flag
01:29:09 <dysfun> i remember seeing a graph somewhere of how adjusting the branch factor affects performance of hash array mapped tries. anyone happen to know where it is?
01:57:04 <_sras_> Is anyone using Beam database library in production?
03:17:33 * hackagebot DeepDarkFantasy 0.2017.8.12 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
04:03:40 <rjg_> j
04:34:46 <gehinnn> Trick question: Why doesn't this code (http://lpaste.net/357625) compile?
04:34:57 <Franciman> I created a sandbox with cabal, then did cabal install --dependencies-only. Now when I run cabal build i get this error: Resolving dependencies...
04:34:57 <Franciman> ./dist/setup/setup.version: openFile: resource busy (file is locked)
04:34:59 <Franciman> why?
04:38:28 <cocreature> gehinnn: because C.let parses as a qualified identifier
04:39:58 <gehinnn> cocreature: But `C.let` does not match qvarid - `let` does not match `varid`, because `let` matches `reservedid`
04:40:01 <lyxia> Now I want to find a way to somehow export a "let"
04:40:20 <pacak> gehinnn: ghc probably provides some explanation.
04:41:02 <pacak> lyxia: O_o
04:41:05 <lyxia> gehinnn: is that from a Haskell report
04:41:29 <gehinnn> no, I looked that up using the syntax reference
04:41:48 <lyxia> which is from the Haskell report
04:42:17 <lyxia> Basically GHC does not exactly implement the language as described by the report.
04:42:56 <cocreature> it’s great having a standard when it is not implemented by the only relevant compiler
04:43:39 <gehinnn> Hmm, ok... I am trying to implement a lexer by myself and noticed that it is a little bit easier to treat `C.let` as qvarid
04:44:38 <mniip> wait
04:45:08 <mniip> are full functors just epimorphisms and faithful functors just monomorphisms?
04:45:36 <pacak> mniip:  I know some of those words.
04:45:58 <cocreature> at some point I even knew all of them
04:45:59 <pacak> "are", "just" and "and"...
04:46:14 <trigone> hi, i've come across RankNTypes, and i like that extension very much. what i'd like to know is, are there performance issues to expect? i know there may be trouble with type inference but i hardly care since i like writing down types as much as possible :)
04:46:32 <mniip> by the definition they are a surjection and an injection respectively
04:46:47 <mniip> and I'm sure that's enough to conclude that they're epis and monos in Cat
04:46:48 <cocreature> mniip: full functors don’t need to hit every object
04:47:14 <cocreature> they’re only surjections on the homsets
04:47:18 <mniip> cocreature, yes they do
04:47:34 <cocreature> mniip: huh? ncatlab says they don’t
04:47:46 <cocreature> and wikipedia too
04:48:15 <mniip> oh
04:48:16 <mniip> indeed
04:49:04 <the_2nd> I have a type holding a string which will be encoded via Aeson later on. I don't care about the concrete string type. Which one should I use so Aeson won't have to do expensive conversions?
04:49:07 <mniip> then yes, indeed, they aren't monos and epis
04:49:11 <cocreature> faithful should imply injectivity even on objects since you always have the identity arrows
04:49:23 <cocreature> hm no
04:49:25 <cocreature> nvm
04:49:27 <cocreature> I’m stupid
04:50:20 <mniip> if however a functor is full and its object map is surjective
04:50:25 <mniip> then it's an epimorphism
04:51:05 <mniip> a faithful functor still looks monomorphic however
04:51:36 <mniip> if it mapped X and Y to Z then id_X and id_Y would be mapped to id_Z in contradiction with definition of faitfulness
04:51:46 <mniip> oh
04:51:49 <mniip> parallel
04:51:51 <mniip> dammit
04:52:02 <mniip> yeah it doesn't work either
04:52:47 <mniip> what a misleading pair of definitions
04:53:14 <mniip> aha
04:54:32 <mniip> a functor f is full (resp faithful) is forall X Y,  f : hom(X, Y) -> hom(FX, FY)  is surjective (resp injective)
04:55:41 <mniip> aha, and embedding is just a synonym for faithful functor?
04:55:55 <cocreature> hm I’m forgetting the things I knew about category theory at an alarming rate.
04:56:44 <mniip> heh
04:56:57 <mniip> I'm rereading maclane and realizing I didn't learn anything the previous time
04:58:18 <cocreature> I think I only made it through awodey on my third attempt
04:58:39 <cocreature> I’ve only used maclane as a reference. I never read it front-to-back
04:58:42 <mniip> haha
04:59:02 <mniip> I was just thinking of doing all the excercises this time
04:59:13 <mniip> and then there comes excercise 1 and I don't know any of those words
05:01:15 <cocreature> I’m way too lazy to do that ;)
05:02:12 <mniip> ok
05:02:20 <mniip> I think now I know some of those words
05:24:42 <slack1256> how can I compare which libraries are more popular?
05:29:24 <trigone> slack1256: good question. is there a system to rate the value of packages? maybe that'd be really useful: stars for perfs, stats for expressivity, stats for functionalities... (with comments and all). but then maybe github or whatever already does that
05:29:52 <trigone> btw, regarding my previous question, nobody to know if RankNTypes can crash performances?
05:31:35 <slack1256> there is a "vote" mechanism in hackge... which nobody uses
05:31:57 <slack1256> currently I am using reverse deps, but that only works for OSS works
05:36:09 <Geekingfrog> So I was reading https://github.com/haskell-servant/servant-swagger/blob/master/src/Servant/Swagger/Internal/TypeLevel/Every.hs and realised that I understand ~nothing of the typelevel trickery going on.
05:36:23 <Geekingfrog> Does anyone has any recommendation to get up to speed there?
05:48:30 <sm> slack1256: how do you mean, only works for OSS works ?
05:50:30 <sm> in addition to reverse deps, you can check the number and dates of releases, changelog/readme/other docs, commit activity, PR and issue activity etc.
06:02:05 <fgaz> there's the download count too
06:02:26 <fgaz> even though that is influenced by cdns
06:03:08 <cocreature> and mirrors
06:03:16 <lyxia> Geekingfrog: Read a lot about type families
06:03:17 <cocreature> I don’t think it’s particularly useful at this point
06:07:29 <lyxia> trigone: RankNTypes has no impact on performance
06:32:40 <Gehinnn> Haha, why is this not valid: http://lpaste.net/357626 ? :D
06:42:25 <boj> Gehinnn: it seems to work?
06:43:02 <lyxia> what is that even supposed to do
06:43:07 <marvin2> .-- is a valid operator name perhaps?
06:43:25 <boj> ah
06:44:23 <boj> Gehinnn: you need a space between comments and code, otherwise you end up potentially making actual haskell operators :o
06:45:00 <Gehinnn> again, ghc differs from the "haskell report"
06:45:35 <boj> Gehinnn: the code works without the comment?
06:46:20 <Gehinnn> syntax highlighting is obviously broken in most editors - they all interpret "-- print something" as comment
06:46:40 <Gehinnn> yes, it compiles fine without the comment
06:46:41 <marvin2> emacs doesn't
06:47:10 <Gehinnn> it also compiles fine when adding a whitespace between "." and "--"
06:47:38 <marvin2> so where exactly does ghc differ from the report?
06:48:10 <Gehinnn> the report disallows dashes in varsym
06:49:12 <Gehinnn> according to the report, "--" always starts a comment, except in strings
06:49:41 <boj> which makes sense
06:50:00 <Gehinnn> Thus, according to the report, my snippet above should compile
06:50:08 <boj> except when you have no space between "--" and ".", which ends up with something like ".-", potentially an infix function
06:50:33 <glguy> glguy.net/haskell.vim fixes the comment highlighting and lots more
06:52:05 <glguy> haskell report allows -- to start an operator symbol
06:52:22 <glguy> so --> is not a comment
06:52:46 <boj> nor is .--
06:52:59 <lyxia> it's not like GHC diverging from the report on these points is going to actually bother anyone.
06:53:02 <glguy> An ordinary comment begins with a sequence of two or more consecutive dashes (e.g. --) and extends to the following newline. The sequence of dashes must not form part of a legal lexeme. For example, “-->” or “|--” do not begin a comment, because both of these are legal lexemes; however “--foo” does start a comment.
06:53:39 <Gehinnn> where does the haskell report allow "--" to start an operator symbol?
06:54:03 <glguy> Gehinnn: i just quoted it
06:54:58 <glguy> haskell report 2010: Comments
06:56:14 <Gehinnn> But the same haskell report says `varsym→( symbol⟨:⟩ {symbol} )⟨reservedop | dashes⟩`
06:56:50 <Gehinnn> thus, "-->" is a valid varsym, but not "--", "---" or "----"
06:57:06 <boj> nor ".--"
06:57:09 <Gehinnn> (https://www.haskell.org/onlinereport/haskell2010/haskellch10.html)
06:57:19 <boj> look at your code again
06:58:33 <Gehinnn> the "." is not part of the operator, it belongs to qvarsym: [ modid . ] varsym
06:58:54 <boj> but ".--" is the only way to logically parse that
06:59:16 <glguy> Gehinnn: you misunderstood the lexical rule
07:00:06 <Gehinnn> so you mean that "B.--" is not a qvarsym but rather a varid ("B") followed by varsym (".--")?
07:00:24 <glguy> the trailing subscript removes symbols consisting of only --
07:00:40 <glguy> and also only a reserved symbol
07:01:06 <glguy> not any match containing one as a substring
07:01:20 <Gehinnn> But why is the error message then "Not in scope: ‘B.-->’"?
07:01:28 <boj> >.<
07:01:30 <Gehinnn> But why is the error message then "Not in scope: ‘B.--’"?
07:01:37 <glguy> that's a qualified name
07:03:17 <glguy> qvarsym
07:03:48 <Gehinnn> yeah, but isn't the dot part of qvarsym?
07:04:00 <Gehinnn> thus not part of varsym
07:04:20 <Gehinnn> so the varsym part of qvarsym is only "--"
07:05:25 <glguy> it's all one lexeme said that -- could be contained in a lexeme, so it seems contradictory
07:05:36 <glguy> that much could be a bug
07:05:37 <boj> varid ("B.--")
07:06:06 <trigone> lyxia: ok thx! (a bit late, sorry i was distracted by sth) you really sure? (and could you tell me why?)
07:06:19 <trigone> (regarding RankNTypes)
07:07:00 <Gehinnn> boj: "B.--" cannot be a varid, since "." is neither small, large, digit or '
07:08:24 <lyxia> trigone: it only makes more programs typecheck. As far as I can tell it has no effect on how the program gets compiled afterwards.
07:09:54 <marvin2> Gehinnn error message with your original code: Not in scope: `B.--'; Not in scope: `something'
07:10:39 <marvin2> nm, i thought you wondered why that wasn't the error message
07:12:03 <glguy> You can get GHC to produce this error, 3:3: error:    Qualified name in binding position: Demo.--
07:13:03 * hackagebot transient 0.5.9.2 – composing programs with multithreading, events and distributed computing – https://hackage.haskell.org/package/transient
07:18:37 <trigone> lyxia: ok then great, thx :)
07:19:59 <kgadek> hi. I want to write a Slack bot. I see two libs: slack-api and linklater. Anyone have experience / could compare those?
07:24:30 <glguy> Gehinnn: There you go: https://ghc.haskell.org/trac/ghc/ticket/14109#ticket
07:29:41 <Gehinnn> glguy: thanks :D
07:31:14 <glguy> Gehinnn: I'm not sure what the result should have been, though. If B.-- isn't a valid lexeme then it probably should have lexed as: "B.-" and "-"
07:32:04 <glguy> but that'd also be pretty silly
07:33:11 <Gehinnn> it should be lexed as [ varid("B"), varsym("."), comment("--") ]
07:33:47 <glguy> why?
07:34:04 <glguy> There's a perfectly good, longer qvarsym that the lexer could have grabbed first
07:34:21 <Gehinnn> oh, I thought somehow, that "-" is dashes as well
08:23:45 <SrPx> Hey guys, I found a real-world application made with interaction combinators!
08:24:02 <SrPx> You. http://i.imgur.com/QNfuy8N.png
08:25:06 <Tuplanolla> Is this relativistic?
08:29:11 <Welkin> are there any good sources for syntax highlighting css for what pandoc outputs?
08:30:08 <Welkin> something like this https://github.com/mbadolato/iTerm2-Color-Schemes
08:30:16 <Welkin> but for pandoc (or hakyll) output
08:48:40 * hackagebot nmis-parser 0.1.0.0 – NMIS file parser – https://hackage.haskell.org/package/nmis-parser
08:52:14 <lyxia> I just look at the HTML. There's like 5 classes.
08:52:31 <Welkin> that's not what I meant
08:52:36 <Welkin> I am looking for ready-made themes
08:52:52 <Welkin> in the style of those I posted above
08:52:59 <Welkin> similar to editor/terminal themes
08:54:00 <lyxia> ah ok. no idea.
08:58:28 <hkei> hey, have any of you had any luck with using stack nightly-2017-08-12? I've been getting "This package requires at least Cabal version 2.0" parse errors upon stack setup
09:00:18 <cocreature> hkei: please show us the full error message
09:01:02 <cocreature> hkei: also make sure that you are using the latest version of stack (try `stack upgrade`)
09:01:35 <hkei> that's pretty much the entire thing; The full line is 'Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing'
09:03:07 <hkei> the upgrade thing might've been the problem, didn't realise there was a new major version
09:03:44 <cocreature> you need 1.5.1 
09:05:38 <hkei> yeah, that was the problem. Sorry about that
09:06:31 <mbw> If I have a function (f :: MonadThrow m => m MyResult), it does not seem possible to unify types as (f :: Either MyConcreteErrorType MyResult), only (Either SomeException MyResult). Is this intended to be used with try/tryJust, or should I implement a function with a MonadCatch constraint? Is MonadThrow only intended to be used for functions that may yield different errors *in addition* to 
09:06:37 <mbw> MyConcreteErrorType, and I should return (Either/EitherT/MonadError ... => ...) instead? If there is a definitive resource on how to actually use MonadThrow/Catch/Mask, I haven't found it yet.
09:10:15 <cocreature> mbw: MonadThrow is for actual exceptions (technically it does have an instance for Either SomeException). if you want to parametrize over things like Either, MonadError is the typeclass you want to use here
09:10:24 <mbw> Maybe someone could point me in the right direction? I've read the documents on fpcomplete.com and while they're helpful, they didn't clarify everything, though.
09:10:44 <cocreature> but if you’re stuck with MonadThrow but want an Either, then "try" is the right thing to use here
09:11:13 <mbw> cocreature: Is it okay to discuss an example?
09:11:13 <monochrom> throwM's type pretty much dictates that you will not have your own exception type. Because it's "throwM :: (Exception e, Monad m) => e -> m a", meaning I, the user, chooses the exception type, not you.
09:11:42 <cocreature> mbw: sure
09:12:26 <monochrom> And yeah Control.Monad.Catch isn't even in mtl or transformers. It's in exception.
09:13:03 <cocreature> whether you should be using exceptions or ExceptT is a subject that people love to argue about without any chance of convincing the other side :)
09:14:03 * hackagebot cassava 0.5.1.0 – A CSV parsing and encoding library – https://hackage.haskell.org/package/cassava
09:14:25 <mbw> Say I have a function that parses a Url, and returns some XML Document or something. I know I would like to return some concrete error type like data URLError = URLNotAbsolute | URLNotRelative or whatever, instead of a Maybe. But when implementing the function, it is not clear to me yet if I want to deal with those errors locally, or just catch in main and save some state to disk and crash gracefully. What 
09:14:32 <mbw> should be my "first approximation" of the type signature?
09:15:19 <monochrom> Oh neat "Add FromField/ToField instance for" Natural and Scientific.
09:16:20 <monochrom> And oh the previous one, 0.5.0.0, has "Don't unecessarily quote spaces with QuoteMinimal" which will make a lot of non-conformant people happy. :)
09:16:35 <mbw> cocreature: Actually it should probably just return a parsed URL type, for simplicity. No network I/O.
09:16:37 <glguy> mbw: Url -> IO Xml , or Url -> IO (Either XmlError Xml)
09:16:59 <cocreature> mbw: if there is no IO, then Either or MonadError are what you’re looking for
09:17:03 <mbw> glguy: I thought the last one was an acknowledged anti-pattern?
09:17:26 <glguy> there's no blanket rule for that, no
09:17:37 <cocreature> while there is an open debate on whether exception in IO are a good idea, most people would agree that exceptions in pure code are bad
09:18:27 <monochrom> Both are acknowledged anti-patterns. :)
09:20:14 <monochrom> This is what you get for reading opinionated blogs purported as technical blogs.
09:20:54 <mbw> But if I chose MonadError, and decided to deal with the error in main after all, would this imply an "ExceptT ThisParticularError m a" in the global transformer stack? Then I would have to either collect errors in a sum type, or manually lift, if I had a function returning MonadError SomeOtherError as well, right?
09:22:55 <mbw> monochrom: The blog actually states it is opinionated, and that's perfectly fine. I just feel I am not really able to make a "informed" decision on what error handling framework for this or the other particular case, since there's so many options.
09:24:12 <monochrom> Does your code have to be perfect?
09:24:34 <monochrom> Because all options work, and which one is perfect is subjective and/or context-dependent.
09:25:19 <mbw> To be frank, if some piece of code would have to be perfect, I wouldn't be the one writing it.
09:25:31 <monochrom> By which point rolling a die is more efficient than agonizing over it.
09:25:44 <glguy> mbw: You should stick with the simplest solution until you have a reason to make it more complicated. typeclasses aren't the simplest solution
09:26:28 <mbw> glguy: Good point.
09:27:17 <mbw> It's just that I thought that MonadThrow abstracted over the different ways to "throw" errors. But apparently this isn't what this library is about after all?
09:28:10 <mbw> If only it were possible to include code examples in the API docs ...
09:29:10 <cocreature> MonadThrow abstracts over transformer stacks in which you can throw exceptions
09:29:28 <cocreature> where exceptions refers to haskell runtime exceptions not some abstraction notion of failure
09:30:18 <mbw> So MonadThrow ~ SomeTransformStackWithIOAsBaseMonad ?
09:30:58 <mbw> But then I could just use MonadIO...
09:31:12 <mbw> I don't really see the point yet :(
09:31:37 <c_wraith> the point is mostly that it's a counterpart to MonadCatch, but it has fewer requirements
09:32:06 <cocreature> and it’s a bit easier to write "throwM" than "liftIO . throwIO"
09:38:01 <slack1256> netsplit :-(
09:40:48 <mbw> Ok thank you all for your input.
09:41:43 <Alovenom> Hey all
09:42:30 <Alovenom> I'm wondering if it would be feasible to invoke ghci from python
09:43:37 <slack1256> you can launch it as a process and interact with it maybe
09:43:56 <Alovenom> i've written a short something with csound-expression and I want to write a GUI for it... I'm pretty much done with gloss and honestly doing FFI is an hassle for this, considering I don't care about performance I was thinking about doing that slack yeah
09:44:34 <Alovenom> just writing the GUI in python and launching it as a process and passing commands when needed...
09:48:26 <Alovenom> this however sounds very lazy
09:49:12 <Alovenom> and it would also mean I would have to do a type structure in python that matches the haskell one underneath. 
09:50:52 <slack1256> hey, if it works
09:50:53 <monochrom> Consider threepenny-gui
09:51:17 <slack1256> althought I would do minimal processing on the python side and only use it for the GUI
09:51:41 <slack1256> question , how good are the qt bindings on python?
09:53:47 <Alovenom> monochrom, I actually started to write an UI in threepenny gui.
09:53:50 <fendor> hey, is there a reason why repa is not in lts-9.0?
09:54:38 <Alovenom> But it wasn't successful at all - I have 0 DOM knowledge and it was frustrating to me .. maybe I should give it a go again.
09:55:38 * hackagebot HsHTSLib 1.3.2.2 – High level bindings to htslib. – https://hackage.haskell.org/package/HsHTSLib
09:56:13 <Alovenom> slack, I don't know. Been ages since I've used Kivy. I plan on using Kivy
09:56:20 <Alovenom> since I've used python*
09:59:09 <Alovenom> Oh.
09:59:19 <Alovenom> I didn't see the new GUI library on the GUI page
09:59:33 <Alovenom> how good is CEF3 ?
10:01:40 <Alovenom> oh.. webthing too
10:02:06 <Alovenom> I think I'll just go ahead with the ghci thing... 
10:02:23 <Alovenom> another reason I'm considering ghci is that I have a lot of custom operators.
10:03:05 <Alovenom> and that all FFI I've seen don't support them, whereas I'm imagining it's way easier to just send them as simple strings to the ghci process
10:03:13 <Alovenom> anyways, I'm off. thanks for the help.
10:07:18 <mclark1129> Does anyone have any tips for tab autocomplete for haskell in vim?
10:07:38 <mclark1129> I've got the necoghc plugin going, but seems like for most things it cannot autocomplete basic syntax
10:08:05 <mclark1129> I'm looking for something where I can type "mod" and see "module" as a potential choice, or autocomplete variables that I've defined earlier in the file.
10:28:14 <Tuplanolla> I use the default completion, which is not good, but does accomplish that, mclark1129.
10:29:39 <Welkin> why is the tryhaskell "terminal" on haskell.org broken?
10:29:53 <Welkin> it can only do arithmetic on numbers
10:30:24 <Welkin> everything else gives a mueval-core time limit exceeded
10:30:26 <Welkin> for everything
10:32:02 <petercommand> Welkin: indeed! putStrLn "123" gives time limit exceeded 
10:36:55 * hackagebot intero 0.1.21 – Complete interactive development program for Haskell – https://hackage.haskell.org/package/intero
10:39:54 <minn> It seems that neither Options.Applicative nor System.Console.GetOpt permit arguments lists (e.g., '-o a b c'). Is there an alternative? Ideally I would like to parse the arguments directly to a record of functions.
10:42:24 <slack1256> minn: can you get the string "a b c" from the arguments and parse it yourself?
10:43:14 <slack1256> mmm nvm, this is not your question :-)
10:43:38 <johnw> I usually just go with -o a,b,c
10:45:02 <minn> I suppose the more general question is whether one of the available packages implements these conventions: https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
10:45:25 <minn> Yeah, "a,b,c" is a fine alternative.
10:49:29 <plakband> Hello, I'm getting an UndecidableInstances error for (what seems to be a pretty vanilla) newtype deriving with an associated type. Am I missing something, or is this to be expected? I'm one GHC 8.2.1, the code can be found here: http://lpaste.net/357627
10:50:29 * hackagebot selections 0.1.0.4 – Combinators for operating with selections over an underlying functor – https://hackage.haskell.org/package/selections
10:59:50 <Welkin> ...
10:59:52 <Welkin> MATRIX!
11:01:18 <parsnip> where?!
11:03:54 <lyxia> plakband: I think an error is to be expected, but not that one.
11:04:41 <lyxia> plakband: 8.0 says that you can't derive for a class with associated types
11:05:25 <plakband> lyxia: it's new in 8.2 I think
11:06:03 <lyxia> It is.
11:06:22 <lyxia> I think it's a bug (wrong error).
11:06:34 <bbear> hello quick question: I have a list of [t a -> Bool] and a type t a; how do I get a list of Bool ?
11:07:00 <c_wraith> :t \x -> map ($ x)
11:07:02 <lambdabot> a -> [a -> b] -> [b]
11:07:02 <johnw> map ($ myValue) listOfFunctions
11:07:03 <bbear> thats map but the otherway around
11:07:37 <bbear> ok
11:08:37 * hackagebot selections 0.2.0.0 – Combinators for operating with selections over an underlying functor – https://hackage.haskell.org/package/selections
11:09:20 <plakband> lyxia: what error should it give?
11:10:25 <lyxia> plakband: the one that it gives in 8.0, that GeneralizedNewtypeDeriving doesn't work with associated types
11:11:13 <lyxia> "even with cunning GND" http://lpaste.net/357628
11:24:03 <plakband> lyxia: Adding UndecidableInstances does produce that error
11:24:33 <plakband> But I'm still confused when and when you can't derive associated types
11:24:40 <plakband> I'll have a look at the trac tickets
11:25:47 <sqooq> http://lpaste.net/357631
11:26:00 <sqooq> why am I getting "Multiple declarations of `Note'"
11:26:23 <lyxia> sqooq: you declare two constructors named Note
11:26:43 <sqooq> But one is Type and the other Data
11:26:50 <sqooq> this never caused problems in the past
11:26:51 <lyxia> There are 3 notes
11:27:06 <lyxia> one Note is a type, the two others are constructors.
11:27:28 <sqooq> So I can't embed a type constructor into another type constructor?
11:27:59 <lyxia> What does that mean
11:28:17 <sqooq> like I can't define a type somewhere else to be put into another type, like what I tried to do?
11:28:38 <lyxia> No you can't.
11:29:11 <sqooq> hmm, but I can do Chord [Note a]
11:29:17 <lyxia> Maybe you want data Sound a = ... | OneNote (Note a) | ...
11:29:30 <sqooq> yeah I figured
11:29:33 <sqooq> that's so gross though
11:29:40 <lyxia> It is.
11:29:49 <sqooq> Is there a better way to clean this up?
11:30:08 <mniip> unify OneNote and Chord?
11:30:23 <mniip> why can't OneNote be a single-note chord
11:30:33 <sqooq> :thinking:
11:30:40 <sqooq> Hmm I guess it could
11:30:51 <mniip> also, in a chord all your notes can have different durations, is that intended
11:31:00 <sqooq> O shoot\
11:31:10 <mniip> also not sure what pch and oct mean
11:31:17 <sqooq> pitch and octave
11:31:21 <mniip> but are you sure you want them to have the same type as the duration
11:31:28 <sqooq> yes
11:31:30 <mniip> why is it polymorphic anyway
11:31:43 <sqooq> because I can't constrain in type definitions
11:31:48 <mniip> and why are pitch and octave not the same thing
11:31:52 <mniip> ?
11:32:00 <sqooq> they could be if I made another type probably
11:32:03 <mniip> sure you can
11:32:12 <mniip> just write a goddamn Int
11:32:13 <sqooq> I can do Num a => a ?
11:32:17 <mniip> or whatever
11:32:27 <mniip> no I didn't mean lack of context
11:32:34 <mniip> I asked why are they polymorphic at all
11:32:56 <sqooq> because I need to division and stuff with them
11:33:06 <mniip> so>
11:33:08 <mniip> ?
11:35:37 <sqooq> what's a better word than Sound
11:35:40 <sqooq> that includes rests
11:35:45 <sqooq> like "Musical Element"
11:35:47 <sqooq> or somethign
11:36:47 <mniip> if you're describing musical notation it could be Symbol
11:37:43 <Welkin> pitch is a frequency
11:37:54 <Welkin> octave is a grouping of frequencies
11:38:25 <mniip> Welkin, nowadays pitch might as well be a logarithmic integer mapping of the frequency space
11:38:25 <sqooq> alright
11:38:27 <sqooq> better
11:38:27 <sqooq> http://lpaste.net/357633
11:38:38 <sqooq> mniip is right
11:38:47 <sqooq> and since I'm using logarithmic pitch values, I call it pitch
11:38:50 <sqooq> rather than frequency
11:39:09 <sqooq> better mniip?
11:39:10 <mniip> representing A as 0 and 12 is much better than 440.0 and 880.0
11:39:33 <sqooq> I like C as 0
11:39:35 <sqooq> but yeah
11:39:39 <mniip> middle C?
11:39:50 <sqooq> O well I separate octave information
11:40:02 <sqooq> tbh it's arbitrary so it doesn't really matter
11:40:20 <Welkin> there are already many programming languages to represent musical notation
11:40:25 <Welkin> look at lilypond, for example
11:40:29 <mniip> sqooq, not sure that's a good idea
11:40:43 <mniip> I mean how many songs you know that are explicitly octaved apart by C
11:40:51 <sqooq> Welkin: Lilypond has many flaws and represents musical notation, I'm actually using this to make sound
11:41:21 <mniip> sqooq, consider sticking with the ideas behind midi then?
11:41:32 <sqooq> midi is terrible
11:41:36 <sqooq> midi can't do microtonal either
11:41:43 <mniip> sure can
11:41:46 <mniip> with pitch bending
11:41:48 <sqooq> by pitch bends
11:42:05 <Welkin> sqooq: so then look at haskore/euterpea
11:42:06 <sqooq> yeah which is ugly and terrible
11:42:13 <Welkin> it is in already in haskell
11:42:19 <mniip> well if you wanna support microtonal then good luck
11:43:03 <mniip> might as well try a pair of the tuning frequency and a rational exponential offset
11:43:13 <sqooq> Pretty sure haskore can't do microtones
11:43:19 <sqooq> and either way both of their notations are difficult
11:43:28 <mniip> so that you can use twelfths as well as nineteenths
11:43:29 <sqooq> otherwise I would just use straight Csound
11:45:08 <sqooq> mniip: I'm doing pitch class and octave because this translates well into csound
11:45:09 <sqooq> http://www.csounds.com/manualOLPC/cps2pch.html
11:45:34 <sqooq> My code will be a notation parser that plugs into csound 
11:46:01 <sqooq> I'm almost done with the parser side of things, just forgot about rests and blanks, so now have to update my functions
11:46:12 <sqooq> but figured I should get my type much cleaner first
11:48:58 <sqooq> do you think it's good now?
11:57:58 * hackagebot dwergaz 0.2.0.1 – A minimal testing library – https://hackage.haskell.org/package/dwergaz
12:30:50 <orion> In CT, my understanding is that an identity arrow goes from an object a back to itself: idA : a -> a. If I write a function foo :: Int -> Int where foo x = x + 1, have I constructed an identity morphism?
12:31:15 <Franciman> orion, no
12:31:15 <johnw> no, that's just an endomorphism
12:31:24 <johnw> id has the specific requirement that id . f = f, and f . id = f
12:31:28 <Franciman> the identity morphim is not necessarily the only one with that signature
12:31:47 <Franciman> yeah, as johnw 
12:31:58 <Franciman> if you write a function with that signature and also, this function has those 2 properties
12:32:01 <Franciman> then it MUST be id
12:32:10 <Franciman> the 2 properties being: id . f = f && f . id = f
12:32:20 <orion> So it's accurate to say that all identity morphisms are endomorphisms, but noy all endomorphisms are identity morphisms.
12:32:33 <Franciman> in this case yes
12:33:20 <Franciman> I guess you can have some categories where the only element of Hom(A, A) is id
12:35:51 <orion> Hm. So it seems that in CT I am unable to "zoom in" on objects. In Hask, all I know is that objects are Sets/Types (ignoring bottom), but I can't "peek" inside.
12:36:28 <dmwit> The arrows are how you peek. =)
12:36:39 <orion> My mind is about toi be blown.
12:37:00 <johnw> I would amend that to say: universal properties are how you peek
12:37:38 <johnw> morphisms alone still don't give you information, they only map from unknown objects to unknown objects (in the general case); but the universal mapping properties narrow down what the object can be to a family of isomorphic objects you *do* know something about
12:39:05 <orion> In the case of foo :: Int -> Int where foo x = x + 1, it's not clear to me how I would test if foo . f = f, because all I can see is an endomorphism.
12:39:10 <augur>  what's people's preferred editor for doing typed-hole-based development but also in a way that's Stack compatible?
12:40:10 <dmwit> Alternate perspective: the definition of a category is so general that it's tough to introduce a way to "peek" that works for every category. But particular categories may offer richer ways to peek. To draw an analogy to something you might already be familiar with, there is no `runMonad :: Monad m => m a -> a` -- the definition of monads is too general to give you a general-purpose way to peek. But most particular monads have a function with so
12:41:10 <johnw> dmwit: I would certainly agree with that.  You need some kind of categorical structure to say anything about what's happening inside a category beyond equalities between specific patterns of composition.
12:41:10 <dmwit> e.g. `runState :: State s a -> s -> (a, s)` gives you a way to "peek" at stateful things, but it only works for stateful things and not for other monads. Likewise Hask gives you lots of operations for peeking at things that work great in Hask but don't necessarily generalize to all other categories.
12:42:51 <codeshot> orion, you only look at things while you're turning them into objects (defining the arrows into and out of the object)
12:42:53 <dmwit> So, for example, in Hask, each object (type) comes along with a collection of values of that type and an equality (that exists *outside* of Haskell!) on those values.
12:43:14 <codeshot> then it's all arrows and their relationships as far as I can see
12:43:37 <codeshot> I've just been reading about it so I bought a ton of books. It's fascinating me
12:43:47 <dmwit> When we want to check whether `f = g` in Hask, we can't necessarily do that by writing Haskell code to check the equality. The reasoning has to be done outside the category.
12:44:00 <orion> dmwit: Is there an implicity forall f in id . f == f . id?
12:44:06 <dmwit> So, if we want to check `(\x -> x + 1) . f = f`, we first have to say what our equality is.
12:44:24 <codeshot> yes
12:44:27 <dmwit> Probably some kind of alpha-beta or alpha-beta-eta equality would be a natural choice.
12:44:39 <dmwit> orion: There is, yes.
12:45:18 <codeshot> f = id . f, f = f . id  and  a = b, b = c -> a = c
12:48:19 <dmwit> orion: That is to say, you complain that "all I can see is that `foo . f` and `f` are endomorphisms with the same type", but this isn't true; the category comes equipped with an equality on arrows that let's you "see" whether they are equal or not.
12:49:11 <orion> So Hask is a category with extra restrictions (namely, a notion of equality) imposed upion it.
12:49:12 <dmwit> (Mathematicians differ on their opinion about whether there is an equality on objects. =P)
12:49:30 <codeshot> It also has a terminal object and you know all about it (it's "()" )
12:49:32 <dmwit> orion: Hm. I'm pretty sure all categories have an equality on arrows.
12:49:48 <codeshot> I think so too
12:50:13 <codeshot> But I bought a couple of books about it to make sure I could check
12:50:13 <monochrom> Yes. Else how do you mean "f . g = id" what is "=" there? :)
12:50:18 <johnw> dmwit: isn't that just equality between identity morphisms?
12:50:22 <codeshot> tutorials recorded on youtube aren't enough
12:50:33 <johnw> although I guess that isn't defined by a category
12:50:48 <monochrom> However, mathematicians tend to take = for granted, so they never say it out loud.
12:51:12 <orion> codeshot: I guess you're referring to Bartosz?
12:51:17 <codeshot> yeah
12:51:29 <orion> What books did you purchase?
12:51:31 <codeshot> but there are some other interesting ones too
12:52:36 <codeshot> An introduction to the language of category theory
12:52:38 <dmwit> johnw: It is sort of a funny question. I usually think of equality as being typed -- defined only when the two arrows in question have the same "type" -- but that ends up being a bit circular since saying when they have the same type amounts to talking about an equality on objects. =P
12:53:00 <monochrom> which annoys philosophers, linguists and logicians alike because  <mathematician> 1+1=2  <linguist> What do you mean they are equal? Clearly "1+1" is three tokens and "2" is just one token. Maybe you mean "[| 1+1 |] = [|2|]" but that's a whole can of worms.
12:53:04 <codeshot> - so far seems to be *very* thoughtfully written but I found really important typographic errors in the preface (missing symbols o.O!)
12:53:49 <codeshot> That's my starter
12:53:54 <codeshot> Conceptual Mathematics (A first introduction to categories)
12:53:55 <dmwit> You can say "equality is only defined when they can be composed with the same other arrows" but then to say what the same other arrows are you need a heterogeneous equality.
12:54:01 <orion> No definition of category that I've ever seen includes a notion of equality. :/
12:54:06 <orion> For arrows.
12:54:07 <codeshot> - this is highly recommended online, I bought it for main course
12:54:12 <dmwit> All that to say I probably don't yet understand what CT folks mean when they say "=".
12:55:06 <johnw> orion: yes, to formalize categories in Coq, I have to use quotient categories: where each category can define what it means for two morphisms to be equivalent
12:55:30 <monochrom> But so far every time you bring up a concrete example of a category, people have incredible consensus on what = means for that particular category.
12:55:33 <codeshot> dmwit - it means that the things inside the objects at both ends of the two arrows are the same in every meaningful way (start of f = start of b, end of f = end of b) - not just which objects they go it
12:55:41 <codeshot> Type Theory and Formal Proof (an introduction)
12:55:50 <dmwit> johnw: Also: if you haven't already seen it, the ncatlab page titled "evil" is a fun read. =)
12:55:59 <codeshot> - this is dessert
12:56:15 <codeshot> apparently very difficult but enlightening in a satisfying way
12:56:30 <codeshot> and Type-Driven Development with Idris
12:56:59 <codeshot> for a practical way to apply and consider the limitations of current tech for applying category theory
12:57:18 <dmwit> codeshot: The "things inside the objects"? And who decides what ways are meaningful? This definition doesn't sound very good to me.
12:57:58 <codeshot> meaningful - as in - it makes sense to think about it
12:58:08 <codeshot> really actually "has meaning"
12:58:28 <monochrom> tee hee hee
12:58:38 <codeshot> the "id" arrows defined when constructing the category tell you about value equality on mass - I think
12:58:49 <monochrom> You are really better off delegating this to individual categories.
12:59:02 <codeshot> because not only are the start and end points the same object, the values at each end are also the same by definition
12:59:26 <dmwit> codeshot: Okay. If I write down some text which identifies an object, and you write down the exact same text, are the objects so named equal? It is "meaningful" to distinguish between who wrote down the identifying text. But I would outright reject any category that included the identity of the mathematician writing proofs about it in its definition.
13:00:08 <codeshot> I don't think there is object equality in category theory unless you category defines an object of all it's objects
13:00:16 <codeshot> so it would depend which category we're talking about
13:00:29 <dmwit> Okay, replace "object" with "arrow" everywhere in my previous question.
13:00:46 <codeshot> I think so
13:01:06 <codeshot> bear in mind, I'm new at this
13:01:57 <codeshot> I don't think the identity of the author is meaningful within that category
13:02:07 <nshepperd> isn't the notion of = in the definition a category the same as the notion of = in the definition of a group or any other algebraic structure?
13:02:22 <monochrom> Yeah.
13:02:25 <dmwit> Who appointed you decider of what is meaningful? This is my point: "the same in every meaningful way" is not a good definition (yet).
13:02:27 <nshepperd> if this is a problem, it's not a problem specific to category theory
13:02:48 <codeshot> but if you take a larger category containing it - one that includes (definitions of arrows x authors) - then the author is meaningful
13:02:58 <codeshot> I think
13:02:59 <nshepperd> normally they just use the equality that comes with first order logic or whatever?
13:03:34 <codeshot> so if you were looking whether two papers defined the same category, you might look at the legibility of the handwriting and the effect of misreading on the meaning
13:03:35 <monochrom> That's one good way to think of it.
13:03:46 <monochrom> But my good way to think of it is it's an implicit parameter.
13:03:53 <codeshot> in this category both readings are present
13:04:11 <codeshot> and the extent to which the readings can cause different conclusions can be analysed
13:04:20 <monochrom> If you and I talk about a specific group, we have very good agreement on what is a good = for that group.
13:04:45 <dmwit> orion: Anyway, my top-level claim is that even though folks generally don't write down what they mean by equality when they're defining a category, it is in fact an integral part of the category. It's just not written down because usually it's so obvious what it should be that it's a waste of author and reader time.
13:04:51 <monochrom> And this happens to all specific groups. So it's an implicit parameter.
13:05:42 <monochrom> Rather than arguing the meaning of "meaningful" it is more defensible to use parametrization.
13:05:55 <monochrom> @quote monochrom pointless.debate
13:05:55 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
13:05:56 <dmwit> That is to say, it seems "obvious" that we should not make `\x -> x + 1 :: Int -> Int` and `\x -> x :: Int -> Int` equal in Hask.
13:05:59 <orion> dmwit: It's surprising to me that people magically seem to agree on the definition of equality without it being written down.
13:06:09 <codeshot> implicitness is captured by Functors
13:06:17 <codeshot> mappings between categories
13:07:39 <dmwit> orion: Okay. I wonder if, after seeing the definition of a hundred categories or so, you will still be surprised by this. =)
13:07:50 <codeshot> so as new factors become apparent you can apply a functor to all the knowledge about a category and get a larger category that allows to analyse the consequences of variation of the parameter that had heretofore been ignored because it's variations had so far caused the codomain of the functor to be the same category every time
13:07:51 <orion> ha
13:08:13 <codeshot> sorry, the "codomain of the inverse functor"
13:08:59 <orion> The only categories I've ever seen are Hask, Grp, Set, Topo, and maybe a few more.
13:09:06 <nshepperd> set theory comes with a (=) that works on everything
13:09:14 <codeshot> sorry again, the "image of the inverse functor"
13:09:25 <codeshot> except for some sets of sets
13:09:41 <codeshot> set theory's equal doesn't always work there
13:10:41 <orion> dmwit: Have you seen the definition of 100 categories? How many of them are useful?
13:10:42 <dmwit> orion: Of those, which did you find had the least obvious equality?
13:10:46 * dmwit places a bet on Hask
13:11:08 <codeshot> orion, BTW category theory has "isomorphic with" for many uses of = done in other fields
13:11:28 <dmwit> I have probably not yet seen the definition of 100 categories. Many of the categories I have used were useful, and phrasing statements about them in terms of CT short-circuited a bunch of boring legwork in most cases.
13:11:44 <codeshot> this is defined as the shape formed by arrows and their compositions (and the shapes that are not formed by them)
13:11:54 <codeshot> I think
13:12:27 <codeshot> probably a fuller definition is needed than my inexperienced brain
13:13:45 <dmwit> orion: I wonder: are you familiar/comfortable with monoids? (Or any other abstract algebraic object?)
13:14:24 <codeshot> orion you've seen more than me
13:15:24 <dmwit> If so, does it surprise you as much that people don't define "=" when talking about monoids? Why (not)? There are certainly laws that talk about "=", as in `(x <> y) <> z = x <> (y <> z)`.
13:15:43 <orion> dmwit: I am comfortable with reasoning about Monoids in the context of writing Haskell for fun and profit.
13:16:31 <orion> If you asked me, "Show that foo is bar when baz is a Monoid" I'd probably struggle since I am not great at mathematical reasoning/communication.
13:16:52 <orion> (I have a distinct lack of formal math training, which really hold me back)
13:17:25 <codeshot> of course, because it's a category and we have no data constructors!
13:18:25 <codeshot> we do now have "views" and other things but I haven't used them yet - I guess those will model isomorphism checks
13:19:20 <codeshot> aka, "peer review"
13:20:59 <dmwit> orion: In most cases, the "when baz is a Monoid" bit would be more like "when baz is this particular Monoid", say, "when baz is a String".
13:21:41 <dmwit> orion: e.g. I would bet you could show that `"hello, " <> "world!"` was `"hello, world!"`, and might even be confused why that was a thing that needed showing -- the equality is just so obvious!
13:22:42 <orion> I see.
13:23:30 <iqubic> For Strings <> = ++
13:25:22 <codeshot> the equality is by definition for lists
13:26:41 <codeshot> orion, on the topic of categories, I think I noticed that while the notation defines parts of a category in terms of objects being members of it
13:27:08 <codeshot> really, I think the "arrows" are members of it and the objects are dragged along by their collars where the arrows are attached
13:27:32 <codeshot> because hom_c(A,B) is a set, but Obj(C) is much larger than a set
13:28:01 <codeshot> which I don't understand but one is easy to talk about intuitively and the other is weird and scary
13:29:33 <johnw> codeshot: you don't even technically need objects to define what a category is, Mac Lane gives a definitions for "arrows only" categories
13:29:49 <codeshot> how?
13:29:55 <johnw> and since categories themselves are the objects of Cat, you don't need categories at all, just functors
13:29:58 <codeshot> an arrow has an object at each end
13:30:05 <johnw> codeshot: I recommend reading that section
13:30:06 <codeshot> or does it?
13:30:58 <johnw> the minimum you need to describe a category is not "arrows with endpoints", but a differentiation between arrows, and a mapping of all composible pairs of arrows to their composition
13:31:31 <codeshot> johnw, Categories for the working mathematician?
13:31:34 <johnw> so, if you take arrows to be identified by natural numbers, it's quite a simple thing to define the structure of a category.  You can then create a functor from this structure to your category of interest.
13:31:35 <johnw> codeshot: yes
13:31:55 <monochrom> Oh great, this is pointful and pointfree all over again.
13:32:12 <codeshot> if arrows are defined to meet then a point is identified - why isn't that an object ?
13:32:42 <codeshot> monochrom, I missed that, should I stop now?
13:33:25 <codeshot> natss with zero or without ?
13:33:34 <johnw> doesn't matter
13:33:41 <johnw> any set of symbols that can be distinguished from each other
13:33:41 <codeshot> cool
13:33:49 <johnw> it doesn't have to be ordered
13:34:04 <monochrom> I have always been fond of arrows without objects. Until you point out "so now you don't need categories, you only need functors". At that point I realize I am not all that abstract after all, I need the objects back.
13:34:24 <johnw> haha
13:34:49 <johnw> monochrom: https://arxiv.org/abs/1602.01759
13:34:55 <codeshot> I'm going to leave the CT discussion now
13:35:09 <codeshot> I just thought of something that will take me to Homotopy theory
13:35:17 <codeshot> and that scares me
13:35:29 <monochrom> ooohhhh Leibniz.
13:37:07 <ryba> hi, could anyone help me with cabal
13:37:30 <ryba> i cant't find out how to install local pkg
13:37:57 <ryba> i did something with sandboxes, but when i rung ghci and try to import it, it doesn't work
13:42:01 <dmwit> cabal exec ghci
13:42:04 <dmwit> or cabal repl
13:42:21 <dmwit> (...from within the directory that has the sandbox)
13:43:37 <ryba> hmm, but ghc normally sees packages installed by cabal using cabal install, i want it to work the same
13:43:50 <dmwit> ...then don't use a sandbox?
13:43:58 <Welkin> just use stack
13:44:16 <Welkin> then you can use `stack repl`
13:45:38 <ryba> dmwit: ok, how do i unsandbox
13:46:24 <ryba> Welkin: i want to use ghc directly
13:46:52 <dmwit> ryba: --ignore-sandbox if you already have one. Or delete the existing sandbox if you never want to use it again.
13:47:23 <Welkin> you are always using ghc directly
13:47:36 <Welkin> you can set up whatever commands/flags you want to run ghc with in your .cabal
13:49:31 <ryba> dmwit: ok, i missed the part where cabal install without package name installs local one, my bad
13:52:31 <geekosaur> installing locally is what it does by default unless you are in a snadbox
13:52:52 <geekosaur> use cabal repl instead of ghci
13:52:52 <geekosaur> neither ghc nor ghci has special support for either cabal or stack wired in
13:53:13 <geekosaur> so they see neither one's sandbox
13:53:34 <geekosaur> you must use the appropriate sandbox command (cabal repl, or stack ghci) to get a ghci with the sandbox
13:53:55 <geekosaur> ...or use the sandbox's exec command to run them (cabal exec -- ..., stack exec -- ...)
13:56:47 <codeshot> johnw, the link you gave for monochrome. Is that the concept of type deduction ?
13:57:03 <mibaz_1> If I have 'data MyType (a :: Nat) = ...' how can I get that nat in a function 'f :: (KnownNat a) => MyType a -> Integer' ? I tried 'f = natVal (Proxy :: Proxy a)' but "...couldn't match '*' with 'Nat'.
13:57:15 <johnw> codeshot: I don't feel that I understanding your meaning well enough to answer
13:57:21 <codeshot> me neither :(
13:57:25 <codeshot> lol
14:00:22 <mibaz_1> lol understandable
14:00:31 <mibaz_1> Weird DataKinds stuff I'm trying to grasp
14:01:31 * hackagebot rss-conduit 0.3.1.2 – Streaming parser/renderer for the RSS standard. – https://hackage.haskell.org/package/rss-conduit
14:03:12 <codeshot> johnw, Do you know how to look for citations of that paper?
14:03:47 <dmwit> mibaz_1: Have you turned on ScopedTypeVariables and included a `forall` in the type signature for `f`?
14:03:51 <codeshot> The intro is a bit philosophical and I want to see what other mathematicians think of it's correctness
14:04:28 <dmwit> mibaz_1: Also: why have you not written `f = natVal`?
14:07:33 <mibaz_1> dmwit: That did it! Thanks so much
14:07:46 <mibaz_1> dmwit: That's not the actual function just a distillation of my question
14:08:05 <dmwit> mibaz_1: Seriously, though, you don't need STV and a special signature. Just pass your `MyType a` to `natVal` and skip this `Proxy` nonsense.
14:08:25 <mibaz_1> dmwit: Wait natVal will take any type like that? Hold on...
14:09:30 <mibaz_1> Well shoot, that's much better. Thanks again, the newbie tutorials on this stuff are sparse
14:10:30 * hackagebot nmis-parser 0.1.0.1 – NMIS file parser – https://hackage.haskell.org/package/nmis-parser
14:22:11 <orzo> If you have a Data.Data instance with embeded NoRep fields, will the generic folds avoid attempting to gunfold or toConstr them?
14:23:08 <orzo> I notice that Data.ByteString.ByteString sets gunfold and toConstr to error calls. That doesn't make it unsafe to use gunfold on a type with BytStrings in it, does it?
14:31:15 <ryba> if i have source file and compiled .o file, can ghci use .o file to get better performance?
14:32:51 * hackagebot recursion-schemes-ext 0.1.0.2 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
14:32:52 * hackagebot tweet-hs 1.0.1.2 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
14:35:52 <MarcelineVQ> ryba: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#loading-compiled-code
14:37:55 * hackagebot recursion-schemes-ext 0.1.0.3 – Amateur addenda to recursion-schemes – https://hackage.haskell.org/package/recursion-schemes-ext
14:37:55 * hackagebot composition-prelude 0.1.0.2 – Higher-order function combinators – https://hackage.haskell.org/package/composition-prelude
14:43:00 * hackagebot tibetan-utils 0.1.1.4 – Parse and display tibetan numerals – https://hackage.haskell.org/package/tibetan-utils
14:43:00 * hackagebot wordchoice 0.1.1.1 – Get word counts and distributions – https://hackage.haskell.org/package/wordchoice
14:48:03 * hackagebot xmonad-vanessa 0.1.1.4 – Custom xmonad, which builds with stack or cabal. – https://hackage.haskell.org/package/xmonad-vanessa
15:00:58 <yorick> where's the Data.Functor.Compose documentation at?
15:08:18 <yorick> can I auto-derive Eq1?
15:29:34 * hackagebot eventstore 0.15.0.2 – EventStore TCP Client – https://hackage.haskell.org/package/eventstore
16:44:32 * hackagebot lzma-conduit 1.1.3.2 – Conduit interface for lzma/xz compression. – https://hackage.haskell.org/package/lzma-conduit
17:05:31 <dysfigured> thoughts on purescript?
17:12:55 <systemfault> Great stuff.
17:31:14 <mibaz_1> I was using Finite to hold type level literals as arguments to functions, however, 'natToFinite :: (KnownNat n, KnownNat m, (n + 1) <= m) => proxy n -> Finite m' suggests that Finite is indexed differently than Nat
17:31:54 <mibaz_1> That would make sense if 0 "inhabits" 
17:32:38 <mibaz_1> To avoid this issue, I was just going to use Proxy to pass Nats around. If anyone has any better suggestions please let me know.
17:34:19 <mibaz_1> (I think I meant, instead of "type level literals", "literals of kind Nat as types")
18:20:49 <dmwit> mibaz_1: I don't think they're indexed differently. I just think `Finite 0` is not inhabited, and so they wrote a type that witnesses that fact.
18:22:12 <dmwit> Kind of like you would write `safeHead :: NonEmpty a -> a` to witness the fact that `[a]` doesn't necessarily have a head, but `NonEmpty` does -- this is witnessing that we can convert a nat to a `Finite` only when that nat is bigger than 0.
18:26:38 <dolio> Nat isn't indexed at all.
18:27:30 <dolio> Is it?
18:28:30 <mibaz_1> dmwit: Yeah I see, but I thought using proxy would simplify the types so I didn't have to keep track of that shift. Is this reasonable or mistaken?
18:28:32 <dmwit> Well. Seems like not such a terrible abuse of language to say KnownNat is "indexed".
18:28:44 <dmwit> What shift?
18:28:46 <mibaz_1> dolio: Yeah you're probably formally right
18:29:41 <mibaz_1> dmwit: if KnownNat is "indexed" then KnownNat 0 is "inhabited" while Finite 0 is not inhabited
18:29:45 <dolio> Is "Nat" meant to be "KnownNat"? Or some kind of natural numbers?
18:30:31 <mibaz_1> dolio: Nat is the kind of type level literals provided by DataKinds and TypeLits, I think.
18:30:34 <dmwit> KnownNat 0 is not inhabited.
18:30:39 <dmwit> It has the wrong kind to be inhabited.
18:31:04 <mibaz_1> dolio: Every type of kind "Nat" has an instance of "KnownNat", If I understand correctly.
18:31:04 <dmwit> (KnownNat 1 is also not inhabited.)
18:31:25 <dolio> `KnownNat n` represents that n is a natural number with a value-level witness. `Finite n` is the type with n elements.
18:31:33 <dolio> Or, a type.
18:31:39 <dmwit> I think you do not understand correctly. I think it is pretty easy to construct a term of kind Nat which is not obviously an instance of KnownNat.
18:32:43 <dmwit> Certainly all type-level literals of kind Nat will be instances of KnownNat.
18:33:37 <mibaz_1> dmwit: Hm, so I'm obviously making an error here. From the type of natToFinite, I read "the Nat in the proxy can be one greater than the type in the KnownNat". Why this shift?
18:33:56 <mibaz_1> "than the type in the Finite" rather
18:33:58 <dmwit> Because 0 is a KnownNat, but Finite 0 is not inhabited.
18:34:22 <dmwit> (But Finite (n+1) is inhabited for all n.)
18:34:55 <mibaz_1> Yeah so that's what I mean. I don't want to have to deal with that asymetry so I thought I could just use mostly Proxys instead
18:35:32 <dmwit> I don't really understand what problem you are solving.
18:38:12 <dolio> The point of the `n` in `Finite n` is to tell you how many (well defined) values there are. And the idea is that `Finite n` consists of the natural numbers less than n, because there are n of those.
18:38:20 <mibaz_1> dmwit: I'm practicing DataKinds etc. with a small program. I'm using vector-sized. vector-sized takes everything as Finite. I made a custom type with a tagged size which is handled easily by functions that work with Proxy. So I have both but want harmony
18:38:29 <dolio> The point is not that `n` is a member of `Finite n`.
18:39:03 <mibaz_1> dolio: yeah that explanation shows me I'm not grasping this yet.
18:39:03 <dmwit> mibaz_1: What are you expecting to happen when you index into a vector of length 0?
18:39:21 <mibaz_1> dmwit: I'd like it not to typecheck.
18:39:30 <dmwit> Okay. That is what `Finite 0` gets you.
18:39:43 <dmwit> There is no term of type `Finite 0`, so you can't index into vectors of length 0.
18:40:19 <dmwit> (I'm assuming the operation for indexing is something like `Vector n a -> Finite n -> a` or so.)
18:40:35 <mibaz_1> dmwit: You're correct yeah
18:40:49 <dmwit> The flip side of this is that you, as the programmer, then have to prove that `n > 0` every time you want to do indexing.
18:41:07 <dmwit> Which... seems reasonable to me.
18:42:25 <mibaz_1> dmwit: Ok, so Finite n is a type inhabited by n types, correct?
18:42:46 <dmwit> ...that is to say, hoping there will be "harmony" by swapping out `Finite n` for `Proxy n` seems like a hopeless dream: there isn't any value *in* there to get, no matter what type you use to inspect it.
18:42:58 <dmwit> mibaz_1: No, Finite n is a type inhabited by n values.
18:43:05 <mibaz_1> the Nat 4 is recursively defined at the type level and so is inhabited by 4 types?
18:43:17 <mibaz_1> dmwit: My bad thats what I meant
18:43:24 <mibaz_1> 4 values*
18:43:36 <dmwit> No, The Nat 4 is a compiler primitive and is not inhabited at all, by types or values.
18:44:09 <mibaz_1> Let me look up and understand "inhabited" then, since that seems an early hangup for me here
18:57:47 <dmwit> (Okay, the Nat 4 doesn't need to be primitive. But even so it isn't recursively defined.)
19:08:19 <EvanR> im surprised there havent been more matrix.org floods in here, in other channels its kind of extreme
19:23:31 <JuanDaugherty> Lofti Zadeh died
20:04:10 * ski supposes <matrix.org> mass joins/quits can be considered to be similar to netsplits (though no special detection/handling of them as such)
20:04:59 <ski> (perhaps there ought to be a way to request something like that)
20:09:21 <albeit> If I'm using stack, how do I re-compile my files with the -O GCC option enabled?
20:17:15 <monochrom> Perhaps stack already uses -O ?
20:17:49 <monochrom> Because cabal certainly does.
20:19:27 * hackagebot SSTG 0.1.1.6 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
20:19:34 <monochrom> Ah, cabal uses -O2, and you want -O1.
20:21:03 <albeit> Oh did not know that - how can you tell what stack/cabal already uses?
20:21:24 <monochrom> cabal build -v3
20:31:40 <geekosaur> hm, I expected -O (which is -O1) default; -O2 is not recommended except with code specifically designed to optimize with it, iirc
20:32:10 <geekosaur> so not normally used outside of base or certain external packages designed for it (e.g. text)
20:33:10 <geekosaur> also, you said gcc, and while that is doable it would only apply to ffi stubs or associated C code
20:35:26 <albeit> Oops, meant to say ghc not gcc
20:42:50 <monochrom> cabal calls ghc with -O.
20:43:03 <monochrom> and when ghc is called with -O, it calls gcc with -O2.
20:44:11 <albeit> Got it, thanks!
20:44:52 <geekosaur> ah. but as I said, gcc doesn't do much aside from FFI stubs
20:45:13 <geekosaur> ghc hasn't compiled via C in close to a decade, I think they even finally removed the option instead of having it warn you it was unsupported
20:46:19 <trigone> hi, i wonder if there's any tutorial, or even book about an advanced part of haskell which would lengthy and extensive, and not only focused on theory/math... i do like the more abstract stuff but i also like to know how and when to use what i learned, and with short tutorials sometimes there are just too many unanswered questions
20:47:10 <geekosaur> I think the closest thing to an advanced Haskell book currently is parallel & concurrent
20:47:13 <geekosaur> @where parallel
20:47:13 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
20:47:17 <geekosaur> meh
20:47:40 <geekosaur> @where concurrent
20:47:40 <lambdabot> I know nothing about concurrent.
20:47:44 <geekosaur> @google parallel and concurrent haskell
20:47:46 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
20:47:46 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
20:48:17 <monochrom>  @where is like a safe with its keys thrown away
20:49:33 <trigone> geekosaur: cool, thanks a lot! is it a really good book?
20:49:46 <geekosaur> normally I'd grep my logs but they're on a different machine
20:50:10 <geekosaur> it's considered very good, tes
20:50:20 <geekosaur> however it's specifically about parallelism and concurrency, not about e.g. type level stuff
20:50:36 <trigone> geekosaur: yeah, but that's useful too right?
20:50:40 <geekosaur> and I suspect the big problem with a book about that is it's still changing
20:51:01 <trigone> is it already becoming obsolete?
20:51:13 <geekosaur> the p&c book is still good
20:52:09 <trigone> k thx again :) any other by any chance? not to be greedy, but while i'm here
20:52:10 <geekosaur> type level stuff hasn't been changed in a way that makes older code obsolete, but newer and better ways of doing things are added pretty much with every major version (which for ghc means 7.10, 8.0, 8.2, the upcoming 8.4, etc. --- think  linux kernel versioning)
20:53:04 <trigone> hm and type-level wise, is there any solid book/tutorial on at least a (big) part of it?
20:54:40 <geekosaur> mostly there's blog stuff, not so much books
20:55:20 <geekosaur> I think most potential book authors are still wary of what happened to _Real World Haskell_ which was already partly obsolete when it hit the shelves (exception handling had been completely rewritten)
20:55:49 <monochrom> No, I think it's simpler than that.
20:55:57 <monochrom> Most potential authors have real lives.
20:56:00 <trigone> hm... btw, wrt p&c, do you need to know about parallelism and concurrency in general? cuz i know squat about it, in haskell as much as in anything else
20:56:41 <geekosaur> I don't think so; practically speaking, most people dont know much about it, they just follow recipes :)
20:57:12 <geekosaur> (and then people like me get to file bug reports :p )
20:57:18 <monochrom> For example Richard Eisenberg's time is better spent on publishing new research as a postdoc or new prof than to write a book that earns little money, career-wise.
20:58:00 <trigone> lol sigh... but the book does more than giving out recipes right? i want to learn in depth, not just sh*t out some code without caring about its quality or what i'm doing...
20:58:19 <monochrom> For example Simon Marlow actually had to create a 4-month unemployed gap to finish P&C. But that was when he was an established big shot so he could afford it.
20:58:33 <trigone> geekosaur: you mean bug reports on programs made (partially) in a recipish way?
20:58:46 <geekosaur> this book is not recipes. I'm talking more the kind of stuff I often see in other languages. Haskell, as usual, rewards you for actually understanding what's going on instead of just muddling through with a muddled program
20:59:10 <geekosaur> os the book is designed to teach you that
20:59:22 <trigone> os?
20:59:40 <geekosaur> bug reports mostly on libraries that claim to support reetrancy and/or concurrency and/or parallelism, and get it wrong
21:00:12 <trigone> that's good then :) regarding structuring whole programs, any lengthy sources to recommend?
21:00:29 <trigone> what's reetrancy?
21:01:11 <geekosaur> calling a function simultaneously from multiple threads, or calling the function again from a callback passed to the first invocation
21:01:45 <monochrom> And 50 years ago, simply supporting recursion.
21:02:13 <trigone> not sure to get it but that's not important for now
21:02:44 <monochrom> Reentrancy simply means a previous call hasn't returned and here you are calling it again.
21:03:11 <geekosaur> reentrancy is usually more of a problem with functions written in C; if you have any static variables, your function likely is not reentrant
21:03:20 <geekosaur> and ibc has a lot of legacy interfaces that do that
21:03:40 <geekosaur> *libc
21:04:38 <trigone> hm ok
21:04:40 <geekosaur> (plus newer ones with _r suffixes that are supposed to be reentrant versions... but in at least one case, it's not, quite: strtok_r. but then strtok / strtok_r is kinda "y u do this?" anyway)
21:06:10 <geekosaur> (strtok() is close to the perfect advertisement for "why you shouldn't program in C")
21:06:14 <c_wraith> I learned to program at a very young age.  Many ideas I encountered were far over my head.  I figured strtok was one of those things when it made no sense to me.
21:06:35 <c_wraith> As I grew older, I learned no...  strtok was too dumb for me to understand, not the other way around.
21:07:35 <c_wraith> it never occurred to me that it could work via both hidden internal state *and* repeated mangling of its parameters
21:07:51 <c_wraith> No one would ever do something like that, right?
21:08:15 <monochrom> strtok was a product of an unhealthy hatred towards dynamic allocation and an unhealthy ignorance of algebraic data types.
21:08:40 <geekosaur> this is how C programmers thought in the late 70s/early 80s
21:09:10 <geekosaur> granted, it's also something of a product of the low memory systems of the time... why would you waste your 64K on a copy of a string you're going to throw away anyway?
21:10:01 <erisco> so... if I read this right... it replaces the delimiters with \0
21:10:07 <c_wraith> It's also the result of the C string format.
21:10:12 <c_wraith> Which is a problem in and of itself
21:10:16 <monochrom> But a better way wouldn't have to copy the string either.
21:10:46 <erisco> and it gives you all the new substrings
21:10:47 <c_wraith> Of course, in the 80s C programmers argued against other string formats on memory use grounds, too.
21:10:53 <trigone> i didn know c functions could keep state
21:11:04 <c_wraith> trigone: yeah, static local variables persist between calls.
21:11:16 <erisco> but because they do not want to allocate a list of pointers for these new sub strings they instead have an unrefined version of a generator
21:11:25 <erisco> where you call it and it yields values to you
21:11:29 <erisco> is that about right?
21:11:36 <c_wraith> erisco: pretty much
21:11:52 <geekosaur> yeh
21:11:55 <erisco> that doesn't sound crazy but I still don't want to use it
21:12:37 <c_wraith> erisco: except iirc, you can pass a different delimiter each time you call it with the same string, so it only finds the next chunk each time you call it.
21:12:40 <geekosaur> and a lot of code actually did that manually, so a library version wasn't all that insane by the standards of the time
21:13:00 <monochrom> What you should do is to cut it up into two functions, strtok_create and strtok_next. strtok_create takes your string and returns a fresh handle to a record of tokenizer state. (The record can keep just a pointer to your string, no need to copy.) strtok_next takes a handle and returns the next token and mutates the tokenizer state as necessary.
21:13:21 <c_wraith> monochrom: yes, that would be sane. :)
21:13:35 <erisco> well, maybe that is too verbose
21:13:52 <monochrom> This is not rocket science. Not even in 1960. People already did this to open_file and read_handle
21:14:22 <erisco> I see that theme in modern code, especially JavaScript, where merely being shorter justifies the code
21:14:34 <c_wraith> monochrom: somehow people thought you would never make interleaved calls to strtok on different strings
21:15:00 <c_wraith> whereas they knew you could interleave operations on different files
21:15:12 <c_wraith> So, might as well make a "more convenient" interface!
21:16:49 <geekosaur> again, 64K address spaces
21:17:10 <geekosaur> in general you parsed one language, you ran a separate program with a different parser to parse a different language, it wouldn't all fit in one address space
21:17:31 <geekosaur> VAXes only appeared later and weren't generally available for the most part
21:17:52 <geekosaur> or 680x0 etc.
21:18:40 <geekosaur> of course, by the time strtok() made it into a commonly available unix, 32 bit computing was starting to be more commonly available....
21:19:10 <geekosaur> (but getting programmers to change their ways of course took longer anyway, so without strtok() they still would have done it that way)
21:19:42 <trigone> regarding whole (haskell) program structuring (architecture? i'm not certain of the proper term), does anyone know of any lengthy source on the subject?
21:21:10 <geekosaur> RWH might be helpful
21:21:13 <geekosaur> @where rwh
21:21:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:21:14 <erisco> trigone, are you asking how to organise code into modules for a package?
21:21:46 <sqooq> quick question: In a parser, I thought <* and *> would help simplify the initial function needed by excluding the need for a certain case, which is only used as a check for whether to continue or not
21:21:59 <sqooq> but it's not working the way I expected
21:22:20 <erisco> sqooq, add parentheses because the precedence may not be as you expect
21:22:24 <erisco> otherwise, paste code and error :)
21:22:36 <sqooq> treeMaker' = branchMaker <$> token (char '[') *> treeMaker' <*> treeMaker' <*> many treeMaker' <* token (char ']')              <|> token leafMaker
21:22:57 <sqooq> branchMaker b c d = Branch (b : c : d)
21:23:03 <trigone> erisco: nah, more how to organize things inside the code. it's not so much i find that difficult, it's that i want to explore what's been found/invented on that topic, bc it's a very interesting one to me
21:23:28 <sqooq> I can use the same branchMaker but with _ b c d _ and regular <*> to have it work fine
21:23:52 <erisco> trigone, so, how you might linearise the definitions in a single file?
21:24:48 <sqooq> erisco: this is error http://lpaste.net/357639
21:24:59 <erisco> sqooq, stick a hole where branchMaker is and ask ghci what the type is
21:25:24 <sqooq> Char -> a0
21:26:27 <sqooq> ha
21:26:29 <sqooq> aha
21:26:49 <sqooq> you were right, had to put () around just that *> part
21:26:50 <trigone> geekosaur: hm yeah i know of it... i've read several parts several times. it's very useful, but it doesn't feel like there is much specifically on the topic of the different ways one can write the architecture of a program (studied in an abstract way)
21:26:55 <sqooq> thanks erisco
21:27:07 <trigone> erisco: what?
21:27:31 <erisco> trigone, well, you have to decide the order in which definitions will come after the other
21:27:53 <trigone> erisco: no, i don't mean organize the code as in organize the text, it's about organizing the structure of the program (not of the source code)
21:28:30 <erisco> are you asking how you go from an abstract problem all the way to an implementation?
21:30:26 <erisco> or from a technical specification to a program?
21:33:27 <trigone> erisco: well it's tricky for me to describe something i barely know anything about yet, but , for example, one strategy that seems to be studied around is to write the program with a limited DSL, and then use several interpreters, in parallel and sequence, to write the program but in a way that isolates the code for each various type of functionality, instead of, for example, mixing together the "main code" and the logging part, for 
21:35:04 <erisco> you are cut off at "logging part, for"
21:35:53 <trigone> erisco: oh, well it ends pretty much there, there's just one last word "example" (keyboard echo of course)
21:38:25 <erisco> so, in mission to solve a problem, what are the methods by which we identify and separate concerns
21:39:24 <erisco> or it is once we have identified and separated the concerns, what methods do we have to encode this as a program?
21:39:38 <trigone> well that's one objective that one can aim at, there are several others, like safety, composability, reusability, whatever...
21:40:59 <erisco> okay, well you can ask what programs have those qualities and why (i.e. a predictive model of them)
21:41:20 <erisco> after first tamping down what those mean
21:41:44 <trigone> studying isolated tools is very interesting too, but i find particularly interesting the idea of trying to study whole programs regardless of the isolated tools employed, trying to find patterns perhaps, or ways to articulate the program which make things better regardless of most of what your program could use as library or whatever else
21:42:24 <erisco> we know that polymorphism improves reusability, for example
21:43:28 <erisco> we know type systems can improve safety (if we're talking about "don't crash!")
21:44:46 <erisco> there are various tricks of the trade that suggest there is some greater wisdom about how to make good programs
21:45:02 <trigone> erisco: well making a model of the perfect program is not easy for me... at my level it's more the other way around, learning what kind of things makes things better on the short or long run. i can't find that by myself (well i can but it won't be fast and at best i'll just rediscover the wheel, at worst i'll stay in bad patterns not thinking things could be better...)
21:45:16 <erisco> such as removing magic numbers, and conventions for memory allocation, and naming conventions
21:45:29 <trigone> greater wisdom? what do you mean?
21:45:53 <trigone> what's a magic number?
21:46:21 <erisco> the greater wisdom is something which predicts these advices, and others
21:46:49 <erisco> but it is hugely related to how humans operate
21:47:48 <trigone> i think you hit it: i want to learn how to make good programs. programs which work, even programs which are relatively easy to maintain, sure it's doable. but i don't want to just make programs that work, i want to make the best programs i could make
21:47:59 <erisco> trigone, sometimes in a program you will see a number literal and there will be no indication of what this number means
21:48:08 <erisco> trigone, these are called "magic numbers"
21:48:22 <trigone> you mean like an enumeration? or a constant?
21:48:33 <erisco> like, a number literal...
21:48:44 <trigone> you mean in the source code or compiled code?
21:48:50 <erisco> in the source code
21:49:43 <trigone> including in haskell?
21:49:46 <erisco> there are two weaknesses to this. First, you have to understand the surrounding program to understand what the number is, and that is more work
21:49:52 <erisco> trigone, sure
21:50:30 <erisco> second, should the value change (one might imagine this is some number tweaked for business reasons) it is then tricky to replace it everywhere in the program correctly
21:51:51 <erisco> the first seems difficult to quantify because it is dependent on our way of understanding
21:51:59 <trigone> so, basically you mean when people put literals instead of creating variables
21:52:10 <erisco> we gain a lot of insight by giving this number a name, but this name has no meaning for the program's semantics
21:52:25 <erisco> and one name can be better or worse than another, but that might be difficult to quantify too
21:52:32 <trigone> (esp, named variables)
21:53:18 <erisco> the second is more easily quantifiable because it is measurable how many occurrences there are of that substring in the whole program
21:53:48 <trigone> hence putting semantics in the type sys right? to define the value indirectly by all the functions which recognize it as valid input/output
21:54:22 <erisco> however it is not easily measured how many occurrences need to be replaced to correctly update the value, because we don't know the meaning
21:54:50 <erisco> i.e. the number 8 in one place may be the price of eggs and the same number 8 elsewhere may be a timeout in seconds, but we only want to update the price of eggs
21:55:09 <erisco> well, just looking at the text of the program won't tell us which is which and neither will looking at the semantics of the program
21:57:10 <trigone> i agree yes, but that's more on the side of good general practice at any scale (writing a function or a whole app), rather than specifically focused on the type of issues visible (mostly/only) at the scale of a program
21:57:43 <erisco> there are other maintenance aspects you can look at like this where you measure how many other locations need updating relative to a particular change
21:58:03 <erisco> for example, in Haskell, adding a field to a data type may require you to update every place that data type is constructed and deconstructed
21:58:19 <erisco> but if you use record notation you may be able to add the field without any other changes
21:59:19 <erisco> well it becomes program-scale when you consider all the things you could change
21:59:46 <erisco> what does it cost to add a method to a class, or remove this type definition, or change this string, or change the type of this argument, etc
22:00:21 <erisco> this relevant to development and maintenance. obviously in maintenance, but also in development because we don't usually get it right the first time ;)
22:00:40 <trigone> erisco: indeed, that's one useful starting point for thinking
22:01:15 <erisco> outside the language itself people experiment with ways to do less compiling
22:01:22 <erisco> i.e. sharing more compiled code
22:01:31 <erisco> compile a library once, use it anywhere
22:02:44 <erisco> another thing you can measure is the detectability of errors
22:03:01 <erisco> there are simple solutions to mitigate error such as naming conventions
22:03:20 <erisco> when working with different coordinate systems it is common to use prefixes or suffixes to indicate what space you are in
22:04:17 <erisco> in games development, is this in world space or screen space? you might note that as w_pos for a position in the world and s_pos for a position on the screen, for example
22:04:40 <erisco> that way when you have some expression involving many of these names it becomes much more obvious if you misuse one
22:05:16 <erisco> of course we also have type systems which can assist in checking these sorts of problems
22:05:54 <erisco> so the measure is to say that what level of indication do we get for an induced error? the measure of course depends on the error induced, so we can consider a wide variety of them
22:06:41 <erisco> the weakest level is a change in program behaviour at runtime which is not an abort
22:07:03 <erisco> so now the calculator does addition instead of multiplication when you press the multiplication button, say
22:07:29 <erisco> we might get a runtime exception or crash instead, and that is stronger
22:08:03 <erisco> we might statically have a problem such as a syntax error or type error, and lets say those are the strongest
22:09:03 * hackagebot miso 0.7.1.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
22:09:08 <erisco> so you are measuring how resistant the program is to modifications which induce some error, i.e. some deviation from the way the program is supposed to work
22:09:09 <trigone> on that respect, btw, i've found myself recently become kinda obsessed with safety of that kind, and i wonder how much trouble i should really go through to make errors systematically static instead of crash-dynamic (aka runtime errors which end in crashes, which as you said is better than the alternative)
22:09:31 <erisco> relevant to the strongest level is what sorts of properties we can have the compiler check for us
22:09:45 <erisco> a reason why dependent typing is compelling
22:10:46 <trigone> yeah, but in haskell it *feels* still a bit... clunky? to delve into dependent types and other type-related recent extensions... but maybe not i dunno...
22:11:28 <trigone> i can't really measure what is of the domain of "experimentation" and what is of the domain of "real world application"...
22:12:20 <erisco> there are languages where you can mistype a variable name and that will land you in either level 0 or level 1
22:12:25 <erisco> if level 0 is no error and level 1 is a runtime error
22:13:05 <manek> Hi! Is it possible in Haskell to transform such type class `class Foo2 t t' where foo2 :: forall s1 s2. t s1 s2 -> t' s1 s2` to one that begins with `class FooN (n :: Nat) t t' where ...` ? I'm asking because I did not find a way to express the `...` part
22:13:35 <erisco> trigone, what do you mean by experimentation vs real world application?
22:14:47 <lyxia> manek: foo2 :: proxy n -> t s1 s2 -> t' s1 s2
22:14:57 <monochrom> :)
22:15:28 <lyxia> manek: or turn on AllowAmbiguousTypes and TypeApplications
22:15:41 <erisco> manek, what is the foo2 equivalent for FooN supposed to do? especially in relation to n :: Nat
22:15:49 <manek> lyxia: err, for `n = 3` it should be `forall s1 s2 s3. t s1 s2 s3 -> t' s1 s2 s3` I think you are reffering to something else, am I right ?
22:16:01 <trigone> erisco: well, that's kinda self-descriptive... i don't really know how to reformulate that
22:16:26 <erisco> trigone, are you saying how do you tell between what the program is supposed to do and what the program is doing?
22:16:27 <lyxia> manek: AH you want to generalize the kind of t !
22:16:29 <manek> erisco: ^^
22:16:37 <manek> lyxia: yup
22:17:01 <monochrom> Time to lift "type class" to "kind class".
22:17:22 <trigone> experimentation with advanced type-level programming vs using those tools to make programs better (programs not specifically made to study type-level programming)
22:17:26 <manek> monochrom: heh, but is it somehow doeable now ?
22:17:27 <erisco> please, because we need that for DataKinds to work better
22:18:51 <trigone> but maybe there *is* no difference of turf and everything in haskell which is advanced type stuff is really useful in practical application
22:19:11 <erisco> it depends on how you qualify "useful"
22:19:40 <erisco> making a product out of the best materials is useful in that it improves the physical properties of the product
22:20:10 <erisco> but it may be not useful in the sense the product does not require it for the intended use, and now it is more expensive
22:20:27 <trigone> erisco: what? look, i just try to differentiate the usage of haskell for relatively academic purposes, and for more practical purposes, like a web app, a text editor, an OS, whatever...
22:21:04 <erisco> so there is the sense of "it has a use" and a different sense of "the use furthers the objective"
22:22:03 <trigone> i don't really get what you mean... mind you i'm so tired and got a headache so maybe it's me
22:22:17 <erisco> type level programming has a use but may not be useful for the objectives of your program
22:23:11 <erisco> given any program you can start incorporating more sophisticated types which encode and prove relevant properties of its intended behaviour
22:23:36 <erisco> like you can upgrade the materials of a physical product
22:24:11 <trigone> erisco: hm yes
22:24:14 <erisco> but if the cost of your program misbehaving is low it may not be worth the expense
22:24:58 <erisco> same concept of how you prioritise what bugs to fix first
22:25:37 <erisco> lots of software has a bugs list a novel deep but most of it will be considered frivolous or unimportant
22:26:43 <trigone> erisco: yeah, but esp the question is, is every type of very advanced type-level programming useful for relatively common problems, or is there a part of it which either solves only a few rare problems, or problmes which are indeed too complex to implement for the gain
22:27:57 <trigone> basically is all type-level programming (in haskell) very useful or is there not a part mostly academically interesting but not very much useful for meliorating any lambda problem "out there"
22:28:16 <erisco> you don't have to go to dependent types to learn that not all types have common use... just look through hackage and find unpopular packages
22:29:59 <trigone> not sure to get you. i didn't mean "all types have common use" i meant "all type-level programming techniques have common use"
22:31:01 <erisco> at what sort of resolution? GHC extensions?
22:31:57 <trigone> resolution?
22:32:29 <trigone> sorry i'm way too tired, i'm actually starting to head hurt pretty bad, so i gotta crash... thanks for the discussion, maybe we can continue it later :)
22:32:32 <erisco> I am not sure what qualifies as a technique. Are type families a technique?
22:32:50 <erisco> okay, have a good night :)
22:34:11 <erisco> the two metrics I gave you earlier are real considerations I go through when writing code that is intended to last
22:34:45 <erisco> I haven't studied it abstractly or independently of a particular task, but I am thinking about that
22:34:51 <trigone> which two metrics already? (brain's a bit fuzzy)
22:35:25 <trigone> i'll write em down to not forget em
22:36:28 <erisco> one is if I make a change at one place 1) how many changes do I have to make at other places 2) given the technique for finding the other locations, what is the ratio of correct to incorrect locations
22:37:11 <erisco> so for (2) you could imagine if I have to do a grep over all the files for a particular substring because that is the only way I can find the places to change, I can find many matches which actually should not be changed
22:37:33 <erisco> due to the fact the meaning of my change is not necessarily represented in the text alone
22:38:22 <erisco> ideally I make a change and nowhere else has to change, and second to that is when I make a change I get some static error for each other location I need to update
22:38:44 <trigone> got it, i see the logic :) i wrote it down. thanks again for everything :) see you later!
22:38:45 <erisco> if I have neither of those then I am really unhappy about the code I am writing :P
22:38:54 <trigone> yeah me too ^^
22:39:05 <erisco> the other metric is if I make a mistake, at what level am I informed of the mistake?
22:39:12 <erisco> is there no error, a runtime error, or a static error
22:39:29 <trigone> (oh that was one i thought it was the two ^^)
22:39:51 <trigone> yeah, that's a pretty paramount concernt too
22:40:37 <erisco> I prefer putting enough detail into my types such that mistakes I know I am liable to make (such as putting a term in the wrong place) blow up statically
22:41:03 <erisco> that can add a lot of development cost for certain things, though
22:41:49 <erisco> you can also take a different slant and remove the possibility of mistake by not putting the burden on yourself in the first place
22:42:01 <erisco> memory management is an example
22:42:47 <trigone> what does that entail?
22:43:02 <erisco> memory management? the automatic allocation and freeing of memory
22:43:34 <jared-w> Well, memory management can be solved in a few ways. a) do it yourself (error prone), b) have the compiler be super strict with you (this is what Rust does), c) use a garbage collector and never worry about it again
22:43:35 <trigone> oh right got it i misinterpreted some grammar
22:44:04 <erisco> good APIs are similar in that they hide complication behind a simpler interface
22:44:39 <erisco> so, in terms of structuring programs, you can consider how effectively an API unburdens the programmer
22:45:00 <erisco> I am not sure exactly how you would measure this, but the concept seems right
22:45:23 <erisco> then a good design is one that minimizes burden, say
22:45:34 <jared-w> A great example of that is conduit or pipes. You can either get streaming IO "right" or... have the library handle all that shit for you and you can focus on the actual content of what you're doing
22:46:18 <jared-w> Another one is lens. Super complicated yet somehow gets out of your way and lets you focus on expressing the data transformations rather than focusing on 'destructuring the data correctly'
22:47:59 <trigone> ok, yes i agree :) thx! this time really gotta go, sorry, bye
22:48:13 <erisco> there is possibly a connection to information theory if you can describe the domain the API is for well enough
22:49:22 <erisco> with maybe some way to calculate the entropy of the domain and thus compare it to what the particular API achieves
22:51:14 <iqubic> erisco, I finally understand what parser do, and a little bit of how to use them.
22:52:59 <jared-w> iqubic: nice!
22:53:45 <iqubic> I know what BNF notation is, and I understand grammar. 
22:54:04 <iqubic> I get what an AST is, and how to make on in Haskell using data types.
22:57:53 <erisco> iqubic, great :) did you have a question?
22:58:24 <iqubic> No. I just wanted to thank you for teaching me what parsers do.
22:59:53 <erisco> you're welcome
23:00:06 <erisco> I can tell you are experienced because you understood it quickly
23:00:13 <iqubic> Yep. 
23:09:17 <jared-w> iqubic is definitely a smart cookie
23:09:47 <iqubic> jared-w: I picked up most of C on a two hour plane ride earlier today.
23:10:05 <jared-w> ಠ_ಠ damn, and I thought I was sorta smart
23:10:17 <parsnip> whoa, favorite reference material for that?
23:10:23 <jared-w> Now to spend the next 45 years memorizing "undefined behavior" :p
23:10:41 <jared-w> parsnip: probably K&R? It's only like ~300 pages and for over a decade it /was/ the C-language documentation
23:10:42 <iqubic> I used a book called "learn C in 21 days" lol
23:11:18 <jared-w> lol that works, I guess. K&R is what I'll be using if I ever care to touch C again. Hopefully I can just learn rust and avoid C... I know how to use it to do what I want, I just hate touching it for most things
23:11:19 <c_wraith> iqubic: the problem with C is all the things you think are defined but the compiler is free to change.
23:11:23 <iqubic> jared-w: What do you mean by undefined behaviour?
23:11:30 <c_wraith> iqubic: like, for instance, adding 1 to a number.
23:11:44 <c_wraith> Well, a signed number.
23:12:17 <c_wraith> Signed overflow is undefined.  The compiler can do anything it wants if if it thinks an overflow might happen.
23:12:37 <int-e> c_wraith: "might"?
23:12:57 <c_wraith> int-e: I'm not aware of anywhere that allows undefined behavior on the expression 1+1
23:12:58 <parsnip> fuzzy c
23:13:44 <int-e> c_wraith: yeah but for the compiler to do anything naughty, it should better be certain that undefined behavior is being triggered.
23:14:11 <int-e> like ... optimizing x+1 > x to true, I think that's the most infamous example.
23:14:12 <c_wraith> int-e: well...  It can also assume that the undefined behavior can't happen, and optimize based on that.
23:15:05 <int-e> (well it was optimizing x+y > x to y > 0, since the former is a bit of an idiom for checking for overflows)
23:15:32 <int-e> c_wraith: anyway, I think the way you phrased it wasn't the best.
23:15:35 <int-e> that's all
23:16:17 <c_wraith> int-e: it's slightly hyperbolic, but at the same time it still severely understates the danger.  So I stick with it.
23:30:21 <crucify_me> test
23:34:02 <iqubic> hey crucify_me. Did the test work?
