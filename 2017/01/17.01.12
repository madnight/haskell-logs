00:03:23 <mkoenig> is there a shortcut for a forever + threadDelay loop?
00:38:42 <bronx75> !list
00:38:55 <bronx75> ciao
00:39:01 <bronx75> !list
00:39:08 <Axman6> man, people still do that?
01:17:42 <Carl`> if i want to use some foo, i do import data.foo but what do i put in my cabal file? Or rather, where do i find what to put there? 
01:19:20 <Carl`> will it always be just foo?
01:20:08 <quchen_> Carl`: Any package can contain any module. If you have a module, try using Hayoo/Hoogle to find out what package it’s from.
01:23:28 <Carl`> let's say i want to use wreq, so the dependcy is just wreq. But if i didnt know that and I went to hackage to find out, where would I look?
01:25:34 <markus3> Carl`: you just type the package's name into the search field
01:28:08 <Carl`> and then I just use the last part of the url? e.g, hackage.haskell.org/package/wreq ?
01:34:23 <athan> What are prisms useful for?
01:34:43 <matrium_> Carl`: Yes
01:37:22 <athan> wait, so if a prism works on sum types, then if you've already "gotten" the part out of it, that's why it's reviewable automatically? :s
01:37:54 <athan> oh wait! Is a reviewed prism just a... builder?
01:46:24 <athan> Monoid a => (a,) is an Applicative, but not a monad[Writer]?
02:08:26 <cencul> Hello. Please, can anybody help me, how to idiomatically lift (and :: [Bool] -> Bool) to get (and' :: [Maybe Bool] -> Maybe Bool)?
02:09:17 <Axman6> athan: yes, prisms may fail in one direction, but will always succeed when you use review
02:09:44 <Axman6> cencul: and <$> sequence xs?
02:10:01 <shiona> > fmap and . sequence $ [Just True, Just False]
02:10:04 <lambdabot>  Just False
02:10:08 <Axman6> :t sequence `asAppliedTo` [Just True]
02:10:10 <lambdabot> [Maybe Bool] -> Maybe [Bool]
02:10:13 <athan> Thanks Axman6!
02:10:13 <athan> cencul: Do you need every bool to exist?
02:10:28 <Axman6> :t review
02:10:30 <lambdabot> MonadReader b m => AReview t b -> m t
02:10:34 <Axman6> :t (#)
02:10:36 <lambdabot> error: parse error on input ‘)’
02:10:43 <Axman6> hmm
02:10:45 <athan> this might be a job for witherable, but I may be wrong
02:10:49 <athan> Maybe Wrong :v
02:10:50 <Axman6> > _Just # 1
02:10:53 <lambdabot>  Just 1
02:11:53 <athan> wow that's awesome, thank you Axman6
02:12:16 <Axman6> athan: yes it is :)
02:12:32 <Axman6> > _Left . _Just . _Right # 2
02:12:35 <lambdabot>  Left (Just (Right 2))
02:13:07 <athan> > _Left (Left 1) -- ?
02:13:09 <lambdabot>  error:
02:13:09 <lambdabot>      • Could not deduce (Choice Either) arising from a use of ‘_Left’
02:13:09 <lambdabot>        from the context: (Applicative f, Num a)
02:13:18 <Axman6> #
02:13:29 <athan> well, I'm not trying to review here
02:13:32 <athan> er re*
02:13:40 <Axman6> what do you want to do?
02:13:43 <athan> I still have no idea what the use for prisms actually are
02:14:12 <athan> _Left ^. Left 1
02:14:13 <Axman6> well, for dealing with sum types in a way which can fail
02:14:19 <athan> > _Left ^. Left 1
02:14:21 <Axman6> other way around
02:14:22 <lambdabot>  error:
02:14:22 <lambdabot>      • Couldn't match type ‘Either Integer b1’
02:14:22 <lambdabot>                       with ‘(a -> Const a a)
02:14:31 <athan> How is failure defined?
02:14:31 <athan> Ahh right, sorry
02:14:33 <Axman6> > Left 1 ^? _Left
02:14:36 <lambdabot>  Just 1
02:14:40 <Axman6> > Left 1 ^? _Right
02:14:42 <lambdabot>  Nothing
02:15:06 <athan> Oh! Okay, so it's "affine"?
02:15:31 <athan> awesome
02:15:45 <athan> Ahh, and that's the meaning of `?` - may fail
02:15:53 <Axman6> yep
02:16:09 <athan> > (Just 1 ^? _Nothing) ^? _Nothing -- ?
02:16:12 <lambdabot>  Just ()
02:16:13 <athan> just for grins
02:16:36 <athan> ahh! Does _Nothing always produce unit?
02:16:38 <athan> or really - prisms which lack a... return type?
02:16:40 <Axman6> yep
02:16:53 <athan> really crazy property that they're all reviewable o_o
02:17:04 <Axman6> and constructors with multiple arguments return a tuple of the arguments
02:17:30 <Axman6> data Foo a = Foo a a would have _Foo Foo (a,a)
02:17:37 <Axman6> uh
02:17:51 <Axman6> _Foo :: Prism' (Foo a) (a,a)
02:17:59 <athan> !! woah!
02:18:48 <athan> So optics are both prisms and lenses... somehow?
02:18:58 <athan> I can see how prisms are also traversals (I think)
02:19:04 <Axman6> prisms and lenses are both optics
02:19:43 <roxxik> and traversals are just lenses with multiple targets
02:19:45 <Axman6> they differ in what constraints are placed on the functor and the profunctor
02:19:52 <roxxik> prisms are traversals with one or no target
02:20:47 <athan> hmm, alright. Wait...
02:20:54 <athan> are prisms Contravariant? :s
02:21:02 <athan> I know traversals are Applicative
02:21:30 <Axman6> type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
02:21:37 <Axman6> so they have Choice
02:21:52 <athan> ahhh okay
02:22:10 <athan> shoot, I didn't realize lenses were generalized to arbitrary profunctors
02:22:14 <Axman6> which gives you... left' :: p a b -> p (Either a c) (Either b c) IIRC
02:22:20 <athan> as... kleisli arrows?
02:22:50 <Axman6> I can;t remember if/how kleisli comes into lens
02:22:51 <athan> Ahh!
02:22:54 <athan> wow that's awesome
02:23:14 <Axman6> yes it is :)
02:23:20 <athan> dang :) thank you regardless, my brain is full now
02:23:36 <Axman6> make sure you buy edwardk a beer next time you see him :P
02:24:05 <athan> only if it's pabst :v
02:27:24 <Kegsay> There will be a bunch of people parting this channel from a gateway in a moment. This is an automated process to remove idle users, sorry for the disruption.
02:28:06 <Axman6> is matrix.org failing again? =)
02:28:13 <Axman6> ha
02:28:30 <Kegsay> This is on purpose :) to reduce the number of people we have to maintain resources for
02:28:57 <magthe> ph88^: I still don't know what you mean by "commit"... the output tells you that you are running version 0.0.2, and you are most likely running the released version downloaded from Hackage (http://hackage.haskell.org/package/foundation)
02:29:55 <magthe> ph88^: you can tell stack to use version 0.0.3 from Hackage instead, or use a specific commit from the git repo on github if you'd rather want that
02:30:19 <ph88^> magthe, foundation is under git version control, but i don't know which git version 0.0.2 was based on
02:32:25 <magthe> ph88^: it's most likely based on the commit tagged with foundation-v0.0.2 (https://github.com/haskell-foundation/foundation/releases)
02:33:06 <ph88^> aaah ok i thought maybe it was handled in stack, but it's just a git release ^^
02:33:38 <Kegsay> Cleanup is done now. Sorry for the disruption.
02:33:42 <ph88^> how can i upgrade the package from 0.0.2 to 0.0.3 ? is there a command ? or do i have to change the stack.yaml file ?
02:34:00 <magthe> ph88^: well, Vincent tags a version in git and pushes that tag to github, he then builds a source package and uploads it to Hackage, stack then pulls that version from Hackage for you
02:34:25 <magthe> ph88^: you change the stack.yaml file, it's the easiest way I think
02:34:44 <jchia_> Is there a simple way to query some regular records in a style similar to SQL or LINQ? E.g. if I have some data Foo = Foo { a :: X, b :: Y, c :: Z }, I want to calculate something about a [Foo] using convenient syntax structured like a SQL or LINQ statement, which provides 'WHERE', 'GROUP BY', 'ORDER BY'. Being able to join two 'tables' would be even nicer.
02:35:56 <ph88^> magthe, so suppose the maintainer makes a mistake where he builds a source package from tag 0.15.0 and then upload it to hackage as 0.15.2 there is no way for me to verify this ?
02:36:36 <ph88^> magthe, after i have changed stack.yaml which command should i run for stack to get the new version ?
02:36:56 <magthe> ph88^: sure, just download the source package from Hackage and clone the git repo, then diff the two things :)
02:37:06 <Emanuele> Hi 
02:37:25 <magthe> ph88^: I think a simple `stack build` should do it
02:39:44 <ph88^> ah it works, thanks magthe 
02:40:51 <magthe> ph88^: ah, good :) just in case you haven't realised it yet, stack is the bee's knees! :)
02:42:28 <ph88^> lol
02:42:38 <liste> jchia_: there was https://downloads.haskell.org/~ghc/6.10.1/docs/html/users_guide/syntax-extns.html#id2687789, but to my knowledge it's discouraged
02:44:43 <liste> jchia_: ghc 8 link: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#generalised-sql-like-list-comprehensions
02:50:59 <reactormonk> How exactly do stack and cabal interact?
02:52:35 <maerwald> stack is just a wrapper around cabal (in a sense) with functionality on top
02:56:14 <jchia_> liste: Thanks
02:56:49 <jchia_> liste: Would be even nicer if it had projections and joins
03:22:30 <ocramz> hi all
03:23:01 <ocramz> is there a way to write Arbitrary instances for pairs of objects? I.e. I'd like a certain orthogonality property to hold
03:24:26 <osa1> ocramz: can you be more specific?
03:56:41 <quchen_> reactormonk: Stack uses the Cabal library the same way the Cabal executable (from the cabal-install package) is built using the Cabal library.
03:57:53 <quchen_> ocramz: Sure, Gen is a monad, so you could do »arbitrary >>= \n -> if even n then pure (n,n) else arbitrary«
03:58:20 <quchen_> That would generate tuples of even numbers only, in a way that almost surely terminates. ;-)
04:07:08 <pie__> does functional analysis in ath have anythin gto do with higher order functions in programming_
04:07:55 <pie__> *math
04:09:57 <absence> why does Traversable have a Foldable constraint? it doesn't seem to be used in the source code for Traversable
04:10:38 <absence> oh wait, maybe it doesn't have to be specified since it's in the class
04:11:51 <kuribas> absence: because any Traversable is a Foldable.
04:12:36 <kuribas> absence: so foldMap and friends work on any Traversable.
04:16:46 <absence> kuribas: i see, thanks
04:18:55 <quchen__> absence: the same way you don’t *need* a Functor instance to write an Applicative instance, but every Applicative gives rise to a Functor naturally, so it makes sense to have them in a hierarchy
04:19:11 <quchen__> absence: Exercise: write fmap and foldMap in terms of traverse :-)
04:20:50 <quchen__> absence: It’s a matter of picking the right Applicative for traverse
04:22:17 <quchen> pie__: Not really, no.
04:22:46 <pie__> bbiab
04:28:51 <kuribas> I wish haskell had inheritance.
04:29:07 <kuribas> So a Traversable implementation would automatically give a Foldable implementation.
04:29:57 <ongy> can't we do a instance {-# OVERLAPPABLE #-} Traversable a => Foldable a where  in theory?
04:37:13 <kuribas> ongy: that means every Foldable is a Traversable?
04:39:11 <ongy> It's an instance declaration that makes a Foldable instance from a Traversable instance (I have no idea if that's possible, I was going from your comment), but I think it needs undecidable instances, and overlapping instances (which afaik are both not that popular)
04:40:01 <ongy> so it's the other way around, every Traversable automagically is Foldable, but could define a better instance if possible
04:40:48 <ongy> provided a) it works, b) I got the right macro, and c) the macro is at the correct position
04:46:26 <cencul> Thanks and sorry for long pause. Proposed solution and <$> sequence xs works perfectly, but does not preserve laziness of and. Can we preserve it? So and <$> sequence ([Just False, Nothing, Just False, Just False, ...]) terminate and return Just False?
04:47:19 <opqdonut> cencul: sequence can't be lazy because an operation way down the list might fail
04:47:26 <kuribas> > and <$> sequence ([Just False, Nothing, Just False])
04:47:29 <lambdabot>  Nothing
04:47:44 <kuribas> cencul: ^^^
04:49:43 <cencul> OK, original question was how to lift and from [Bool] -> Bool to [Maybe Bool]->Maybe Bool. We can do and <$> sequence xs but sequence breaks laziness. Can we do something else without sequence?
04:50:07 <srhb> cencul: How does sequence break laziness?
04:51:16 <srhb> and <$> sequence [Just False, Just True, Nothing, undefined]
04:51:18 <srhb> > and <$> sequence [Just False, Just True, Nothing, undefined]
04:51:20 <lambdabot>  Nothing
04:51:45 <srhb> cencul: Are you confusing sequence with seq?
04:51:46 <cencul> But I need and <$> sequence [Just False, Just True, Nothing, undefined] to return Just False.
04:51:54 <srhb> Ah.
04:52:02 <cencul> Because and [False, ...] is False
04:52:28 <cencul> So we do not get to eval Nothing part of list
04:53:02 <srhb> cencul: I think you will have to define your needs a bit more. Are you just ignoring the Nothings completely?
04:53:02 <opqdonut> then you need a different function
04:53:15 <kuribas> > getAll <$> foldMap (All <$>) ([Just False, Nothing, Just False])
04:53:18 <lambdabot>  Just False
04:53:50 <cencul> > getAll <$> foldMap (All <$>) ([Just True, Nothing, Just False])
04:53:52 <lambdabot>  Just False
04:54:31 <cencul> That should be Nothing
04:55:08 <kuribas> > all $ catMaybes [Just True, Nothing, Just False] -- or this
04:55:10 <lambdabot>  error:
04:55:10 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
04:55:10 <lambdabot>                    with actual type ‘[Bool]’
04:55:14 <opqdonut> cencul: then you want a loop like this "andM [] = return True; andM (op:ops) = do val <- op; if val then andM ops else return False"
04:55:21 <kuribas> > all <$> catMaybes [Just True, Nothing, Just False] -- or this
04:55:25 <lambdabot>  error:
04:55:25 <lambdabot>      • Couldn't match type ‘Bool’ with ‘a -> Bool’
04:55:25 <lambdabot>        Expected type: [a -> Bool]
04:56:23 <hexagoxel> @src and
04:56:23 <lambdabot> and = foldr (&&) True
04:56:44 <kuribas> > Just $ and $ catMaybes [Just True, Nothing, Just False] -- this should work
04:56:47 <lambdabot>  Just False
04:57:12 <hexagoxel> cencul: maybe you want some other foldr that works on trinary values?
04:57:44 <opqdonut> kuribas: that was supposed to be Nothing
04:58:17 <kuribas> opqdonut: I don't get what he wants then...
04:58:39 <opqdonut> well I get what but not why :)
04:59:11 <cencul> > opqdonut: i thing that loop is OK, but i would like to reuse "and" instead of implementing it again
04:59:14 <lambdabot>  <hint>:1:34: error: parse error on input ‘,’
05:02:19 <hexagoxel> :t let f Nothing _ = Nothing; f _ Nothing = Nothing; f (Just False) _ = Just False; f _ (Just False) = Just False; f _ _ = Just True in foldr f (Just True)
05:02:21 <lambdabot> Foldable t => t (Maybe Bool) -> Maybe Bool
05:02:56 <kuribas> cencul: there are two ways of lifting and to maybe, as a monad, or as a monoid.  What you want is neither of those.
05:03:03 <cencul> I'm looking for general solution how to transform function f::[a]->a to f'::[Maybe a]->Maybe a and preserve f's laziness (i.e. if f does not eval some part of it's list then that part can contain Nothings but we still get Just)
05:03:36 <Boomerang> > let f (Just False) _ = Just False; f a b = (&&) <$> a <*> b in foldr f (Just True) [Just True, Just True, Nothing, undefined]
05:03:38 <lambdabot>  Nothing
05:03:44 <kuribas> cencul: both foldMap and sequence are lazy.
05:03:56 <cencul> I can write it as loop, but i would like to know if there is some standard function for it.
05:03:57 <Boomerang> > let f (Just False) _ = Just False; f a b = (&&) <$> a <*> b in foldr f (Just True) [Just True, Just False, Nothing, undefined]
05:03:59 <lambdabot>  Just False
05:04:58 <kuribas> cencul: why would you ever need that?
05:07:10 <mettekou> Is there a way to separate logging code in a monad transformer stack (using monad-logger) from the rest of the code if it logs values the rest of the code computes? 
05:10:23 <Geekingfrog> Does anyone knows why Data.Set cannot be an instance of Traversable ?
05:12:52 <cencul> Thanks all for help. I will implement it as loop, sice there seems to be no available standard function doing that.
05:13:04 <hexagoxel> cencul: the difference between what you seem to ask for and `sequence` is more than laziness. Because the semantics in the presence of Nothings are completely different.
05:13:51 <cencul> hexagoxel you are right, it need something else but I can not find what :-)
05:13:53 <mettekou> Geekingfrog: because Set is not a Functor, it does not obey the law of composition.
05:13:56 <Boomerang> Geekingfrog: Because Traversables need to also be Functors and a Set can't be a Functor otherwise you could fmap 2 distinct values into the same one breaking the property that sets have can only have their element one time. Some math expert might want to check that statement though :)
05:14:04 <sbrg> aaah yeah of course
05:14:39 <hexagoxel> cencul: my best guess is still you want `foldr`.
05:16:14 <hexagoxel> >> and3 [Just True, Just False, Nothing]
05:16:16 <hexagoxel> > and3 [Just True, Just False, Nothing]
05:16:19 <lambdabot>  Just False
05:16:27 <hexagoxel> > and3 [Just True, Nothing, Just False]
05:16:29 <lambdabot>  Nothing
05:16:48 <hexagoxel> > and3 [Just True, Just True]
05:16:50 <lambdabot>  Just True
05:17:27 <hexagoxel> cencul: like that?
05:18:16 <Geekingfrog> mettekou, Boomerang, thanks.
05:18:20 <mfukar> Geekingfrog , Data.Set is Ord-constrained, because of efficiency (see Hoogle), and that's incompatible with Functor, like Boomerang said
05:18:33 <opqdonut> even an Eq constraint would be incompatible
05:18:40 <opqdonut> and Eq is the least you need for actual sets
05:20:04 <mettekou> mfukar Geekingfrog: Although that is true, the Ord constraint is not the heart of the problem, the problem is that Set removes duplicates. HashSet from unordered-containers does not have the constraint and isn't a Functor either.
05:20:13 <cencul> hexagoxel: yes, like that (and3) 
05:20:33 <mfukar> HashSet uses Data.Set
05:20:43 <Geekingfrog> mettekou and "removing duplicates" violate the functor laws. Ok.
05:20:57 <kuribas`> how does removing duplicate violate the functor laws?
05:21:42 <hexagoxel> cencul: that is:  and3 = let f Nothing _ = Nothing; f (Just False) _ = Just False; f _ Nothing = Nothing; f _ (Just False) = Just False; f _ _ = Just True in foldr f (Just True)
05:21:43 <Boomerang> If Sets were functor what do you expect "fmap (`mod` 2)" to do to Set [0,1,2,3] ?
05:22:06 <mettekou> kuribas`: fmap (f . g) is no longer equivalent to fmap f . fmap g due to the removal of duplicates.
05:22:39 <kuribas`> mettekou: I don't see how
05:23:13 <Boomerang> kuribas`: look at my example it shows what mettekou is stating
05:23:23 <SlowBait> Hi
05:23:32 <sbrg> kuribas`: if 'f' adds an element and 'g' removes the same element, then it will be there if you apply g then f, but be removed if you apply f then g
05:23:33 <SlowBait> Do you know any good books on type theory?
05:24:06 <sbrg> or hmm
05:24:12 <buglebudabey> what is the fastest matrix package?
05:24:12 <mettekou> SlowBait: depends on whether you want a proof-theoretic or a model-theoretic perspective. Types and Programming Languages is fine for the first.
05:24:46 <cencul> hexagoxel: Thats it. But can we reuse definition of "and" and just lift it some way? But this way is probably not standard enough to have built in implementation. Because this solution is "hardcoded". If i need "or" i need to implement it again.
05:24:53 <mettekou> SlowBait: You can follow it up with Advanced Topics in Types and Programming languages for dependent typing and other stuff.
05:25:04 <kuribas`> sbrg: the laws say nothing about swapping f and g
05:25:40 <SlowBait> mettekou: What is the difference between the two perspectives?
05:26:17 <mettekou> SlowBait: The proof-theoretic perspective focuses on syntactic reasoning and is more useful when implementing type systems.
05:26:57 <kuribas`> Boomerang: return Set [0, 1]
05:27:01 <sbrg> kuribas`: yeah nvm
05:27:07 <kuribas`> Boomerang: that doesn't violate a law...
05:27:13 <hexagoxel> cencul: no. i think you don't realise how "strange" `f` is there; it is some kind of non-commutative `min` over three values, with `Just True` on top and both `Just False` and `Nothing` below.
05:27:50 <SlowBait> mettekou: So the model-theoretic is the one that draws from order theory (not sure it's the right name, I mean things like posets), for example?
05:29:21 <mettekou> SlowBait: The model-theoretic perspective is about semantic reasoning and grew from denotational semantics, rather than operational semantics (proof-theoretic)
05:29:39 <cencul> hexagoxel: thanks for your ideas. I will think more about it.
05:30:36 <mettekou> SlowBait: Both perspectives correspond to the proof theory and model theory of a logic, you know, natural deduction or sequent calculus versus interpretations and tableaux.
05:31:29 <SlowBait> Do you have any references for model-theoretic books on type theory?
05:35:13 <SlowBait> mettekou: ^
05:36:15 <mettekou> SlowBait: Haven't gotten around to reading those yet, but those are the books which propose categories as models for type systems (for example Cartesian-closed categories for simply-typed lambda calculus). I think Categorical Logic and Type Theory seems nice, albeit advanced.
05:36:32 <mettekou> There's of course Homotopy Type Theory as well.
05:36:48 <mettekou> But the model-theoretic perspective requires notions of category theory and topos theory.
05:37:19 <SlowBait> I thought there were books based on order theory models, which were not so advanced...
05:38:29 <mettekou> Not sure about that, sorry. Maybe just good old denotational semantics? But the moment you add a type system to a language, you move to categories, I think.
05:38:49 <SlowBait> Thanks, I'll take a look :)
05:39:32 <mettekou> SlowBait: Out of curiosity: why are you interested in the model-theoretic perspective of type theories?
05:42:51 <kuribas`> Doesn't there exist an extension so you can do: instance (Set :: Ord a => a -> *) => Functor Set ?
05:43:19 <cocreature> kuribas`: afaik there is no such extension
05:43:25 <kuribas`> right
05:44:36 <SlowBait> mettekou: Just curiosity. There's something in that branch of mathematics that I really enjoy, but I haven't to figure out exactly what it is.
05:54:19 <buglebudabey> :t iterate
05:54:21 <lambdabot> (a -> a) -> a -> [a]
05:56:07 <ertes> kuribas`: newtype Collection a = Collection { forall r. (Monoid r) => (a -> r) -> r }
05:56:36 <ertes> kuribas`: this is Alternative and Monad, and you can later instantiate it at r = Set
05:58:11 <kuribas`> what does that do?
05:58:41 <ertes> kuribas`: write:  toSet :: (Ord a) => Collection a -> Set a
05:59:08 <ertes> kuribas`: then you can use Monad/Alternative to build a Collection and then convert it to Set
05:59:23 <ertes> kuribas`: "convert" is the wrong word…  *instantiate* it as Set
05:59:31 <kuribas`> ah right
06:00:37 <ertes> the trick is to delay the Ord constraint to the very end and embed it indirectly in the Monoid constraint on r
06:01:08 <kuribas`> it will give a functor instance?
06:01:25 <ertes> yeah…  trivially even:  derive (Functor)
06:01:35 <ertes> *deriving
06:03:42 <kuribas`> ertes: toSet (Collection f) = f Set.singleton ? 
06:04:25 <kuribas`> ertes: I just followed the types...
06:04:34 <ertes> kuribas`: correct
06:05:10 <kuribas`> ertes: ah, and then (myCollection = Collection (\f -> f 1 <> f 2 <> f 3))
06:06:09 <kuribas`> or "flip foldMap elements"
06:06:47 <ertes> kuribas`: yeah…  you can also give it arbitrary set operations for optimisation
06:07:08 <ertes> kuribas`: newtype Collection = Collection { fromCollection :: forall r. ([a] -> r) -> (a -> r) -> r }
06:07:58 <ertes> 'singleton' is the bare minimum to make it work, but you might want to also give it fromList, for example, so it doesn't have to build all sets via singletons and unions
06:08:59 <ertes> 'union' is passed implicitly via Monoid…  you could also pass it explicitly:  forall r. (r -> r -> r) -> r -> (a -> r) -> r
06:12:57 <kuribas`> anyone seen the curry language?
06:13:18 <kuribas`> looks pretty cool
06:13:35 <kuribas`> like haskell, but with undeterministic functions.
06:14:49 <ertes> i've seen it and liked what i saw, but mercury does the non-determinism part better: it's encoded on the type level
06:15:05 <ertes> there is no way in curry to make sure that a function has at least one result
06:16:48 <kuribas`> mercury looks like prolog...
06:17:15 <ertes> it's a typed and properly functional prolog
06:17:23 <Hi-Angel> Why is "fmap" considered a functor from Category Theory viewpoint? It only maps functions, but not single types, e.g. it's undefined for "Int", thus it is not a valid functor, isn't it? I.e. because functor should be defined for all objects in the category.
06:17:45 <ertes> Hi-Angel: F together with its fmap is the functor
06:17:53 <ertes> F :: * -> *  -- maps objects to objects
06:18:12 <kuribas`> ertes: I suppose you can do the same in haskell by writing everything in the list monad.
06:18:18 <Hi-Angel> :t F
06:18:18 <ertes> fmap :: (->) a b -> (->) (F a) (F b)  -- maps morphisms to morphisms
06:18:20 <lambdabot> error: Data constructor not in scope: F
06:18:39 <ertes> Hi-Angel: F is your F…  e.g. F = Maybe
06:18:49 <Hi-Angel> Ah, so it is type constructor
06:18:51 <Hi-Angel> I see
06:19:22 <ertes> Hi-Angel: note that Functor is the class for endofunctors on Hask, not functors in general
06:19:39 <kuribas`> ertes: I am not sure about custom search strategies though.
06:19:42 <ertes> so all Functor functors go from Hask to Hask
06:20:22 <Hi-Angel> Okay, then the question ends up this: an endofunctor is a single arrow that maps objects to objects, and functions to functions. But in Hask we have one function to map objects (a type constructor), and another to map functions (fmap). Is it even valid?
06:21:24 <ertes> kuribas`: there is a caveat with Collection:  intermediate collections don't collapse into sets just yet, for example:  xs >>= f  -- you will search every value in xs
06:21:33 <ertes> including duplicates
06:21:52 <kuribas`> yeah
06:22:06 <ertes> if you need to prevent that, you can't use Monad at all
06:22:19 <Rodenbach> Why does a)   print length [1, 2, 3]     not work?  I know that I have to do it like b)   print $ length [1, 2, 3] 
06:22:48 <Hi-Angel> Rodenbach: because print thinks that you're passing to it two arguments
06:23:03 <ertes> Hi-Angel: "endofunctor" just means: goes from a category to itself
06:23:05 <quchen> Rodenbach: f x y = (f x) y, not f (x y)
06:23:10 <kuribas`> Rodenbach: or print (length [1, 2, 3])
06:23:21 <Rodenbach> Okay, makes sense. Thank you guys.
06:23:39 <quchen> Rodenbach: print length [] tries to print the length function, and then apply the result to []
06:23:39 <ertes> Hi-Angel: look at fmap, and you'll notice that it *always* takes a Hask morphism (a.k.a. a function) and *always* returns a Hask morphism
06:23:51 <ertes> Hi-Angel: fmap :: (->) a b -> (->) (F a) (F b)
06:24:06 <Hi-Angel> ertes: I understand what an endofunctor is
06:24:24 <ertes> Hi-Angel: then i may be misunderstanding your question
06:24:43 <ertes> Hi-Angel: you're asking about the top-level (->) in fmap?
06:24:46 <Hi-Angel> ertes: I'm just wondering, is it valid from CT to use two different functions (i.e. a type constructor and fmap) to implement a single functor
06:24:55 <ertes> Hi-Angel: yes, sure
06:25:16 <ertes> Hi-Angel: "two functions" is just an encoding of a functor
06:26:15 <Hi-Angel> Okay, thank you!
06:26:41 <ertes> Hi-Angel: category theory doesn't quite stand on its own:  it needs an underlying calculus to make sense of some of the concepts it uses, in particular "mappings" and "equality"
06:28:13 <ertes> in this case we use "haskell" as the underlying calculus to talk about "mappings" (functions) and equality
06:28:22 <Hi-Angel> I see
06:28:38 <Hi-Angel> Thank you!
06:29:30 <Hi-Angel> I'm curious, do anybody really thinks in terms category theory whilst programming? What's an experience it is?
06:31:00 <Hi-Angel> s/in terms/in terms of
06:31:23 <oherrala> Hi-Angel: everyone probably does, but maybe don't know it :)
06:31:54 <ertes> Hi-Angel: https://golem.ph.utexas.edu/category/2010/03/a_perspective_on_higher_catego.html
06:32:22 <ertes> Hi-Angel: it's an essay on categorical thinking, and i think i can identify with that
06:32:39 <Hi-Angel> Wow, cool, I'll definitely read it!
06:34:15 <oherrala> Hi-Angel: this is also good stuff if you want to delve deeper: https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
06:36:27 <Hi-Angel> Wow, Bartosz has a video channel? I didn't know it. I've read his blog posts though. I should say, I struggle with Category Theory for a year, and I'm finally at the point where it's easier to read formal definitions, and then look at examples ☺
06:37:55 <zipper> So liftA is just a less general fmap?
06:38:43 <opqdonut> zipper: yes
06:39:04 <opqdonut> zipper: and liftM2 is a less general liftA2
06:43:11 <pie__> Hi-Angel, i just started reading his blog :D
06:43:42 <romano> hi guys
06:46:07 <romano> do you have any ideas on identifying bottlenecks in programs using monad-par? at the moment my parallel program runs slower than its sequential version. i was not able to use threadscope since it crashes my system reading a 1.1gb eventlog :)
06:47:26 <romano> the cpu utilisation appears to be good (just looking at cpu graphs in my system monitor)
06:47:49 <ertes> @paste romano 
06:47:49 <lambdabot> Haskell pastebin: http://lpaste.net/
06:49:39 <ertes> romano: one of the most common sources for bad parallel performance with concurrency-based parallelism is to forget that haskell is lazy, so you might easily pass *work* to another thread rather than a *value*
06:51:55 <romano> ertes, interesting. would you suggest evaluating things with deepseq before passing them to parallel functions?
06:52:31 <ertes> romano: 'put' already does that, if you're using it
06:53:18 <romano> ertes, i'm using parMap and parMapChunk, i think they use put internally?
06:53:30 <ertes> romano: note that evaluating to NF is an actual algorithm that needs to traverse the data completely…  a better way is to *make sure* it's evaluated and then use 'put_'
06:53:52 <Hi-Angel> Rodenbach: btw, I'm not sure if you see this, but "$" is just a function. E.g. you can do in ghci
06:53:52 <Hi-Angel> :let (€) = ($)
06:53:52 <Hi-Angel> :print € length [1, 2, 3]
06:54:04 <ertes> romano: i thought this was about monad-par
06:54:23 <Rodenbach> I tried it in ghci, thx.
06:54:50 <Rodenbach> I come from a dyanmic language background and wondered if function objects have a representation.  I tried    print length    but this didn’t work.
06:55:04 <Rodenbach> Not that I need it…
06:55:15 <Tuplanolla> They don't, as is, but we have quasiquotation, Rodenbach.
06:55:19 <romano> ertes, it is. in my old version of monad-par parMap is a part of this package :)
06:55:35 <ertes> romano: ah =)
06:55:44 <ertes> romano: which version?
06:57:04 <ertes> romano: ah, 0.1.0.* i suppose
06:57:22 <ertes> (wow, that's old!  you should upgrade your code)
06:57:27 <romano> it's an old one
06:57:36 <ertes> romano: anyway, parMap does it
06:57:44 * shapr hugs ertes 
06:57:51 <romano> hm, that came with stack's lts-6.13
06:58:20 <ertes> romano: i don't know what your result domain is, so keep this in mind:  deepseq is an algorithm that needs to traverse all data
06:58:23 <ertes> aww
06:58:52 <ertes> shapr: thanks…  you do that even though i haven't found time to clean up my genetic code yet =)
07:00:43 <romano> ertes, i'll upgrade the library and give it another go. thanks
07:00:54 <ertes> romano: parMap from monad-par is rather unfortunate: there is no variant that doesn't insist on deepseq
07:02:24 <shapr> ertes: no worries, I enjoy your helpful everyday self
07:02:44 <ertes> romano: consider switching to data parallelism, if you can…  i find it easier to reason about its performance
07:02:50 <romano> ertes, do you know any debugging tools that could help with this? i looked at the report generated by the rts (-s) and also ekg
07:03:18 <ertes> romano: not really…  honestly i don't use any debugging tools myself
07:03:37 <ertes> (which forces me to really understand what's going on) =)
07:03:48 <romano> ertes, nice one!
07:05:00 <ertes> romano: if you aren't aware of it already, i recommend reading The Book: http://chimera.labs.oreilly.com/books/1230000000929/
07:06:00 <ertes> romano: it's written by the author of monad-par and perhaps the most knowledgable person on this planet about haskell performance =)
07:06:12 <romano> ertes, yes i did come across it. google suggests it with every query containing 'haskell' and 'parallel' :)
07:07:16 <blackdog> ertes: haha, i just followed the link, all excited - "oh, _Marlow's_ book. well obvs."
07:07:47 <ertes> of course…  it's The Book =)
07:17:00 <reactormonk> I've seen the Monad in Scala (cats) provides an Applicative, whereas the Monad in Haskell requires an Applicative - how come the difference?
07:17:10 <ertes> shapr: would you be disturbed by the fact that i'm actually using FRP for it? =)
07:17:28 <shapr> ertes: maybe?
07:18:25 <ertes> reactormonk: probably the same thing:  every monad gives rise to an applicative functor (so you get an Applicative out of Monad in scala), or put differently: every monad has to be an applicative functor (so Monad depends on Applicative interface-wise)
07:19:10 <reactormonk> ertes, but then why do you need to provide the applicative in haskell, when it's possible to derive it from the monad?
07:19:56 <ertes> shapr: background: evolution is a process with time-varying values (fitness of the best solution so far, the random distribution used for mutations, etc.) and events (when certain things happen, when the evolution should stop, etc.)
07:21:09 <ertes> reactormonk: we require that every Monad also defines a lifted application function (<*>), but you can derive it from Monad:  (<*>) = ap
07:21:19 <Cale> reactormonk: I suppose it just comes down to "that's how type classes work" -- there isn't really a way to put default method implementations for superclasses into the subclass definition.
07:21:34 <shapr> sounds like that fits into FRP nicely
07:21:41 <ertes> reactormonk: so in haskell there is an explicit requirement, but since every Monad is an Applicative you pretty much get (<*>) for free, if you want
07:22:07 <ertes> Cale: well, there is DefaultSignatures
07:22:08 <reactormonk> Cale, ah, ok, so it's an implementation detail after all.
07:22:11 <reactormonk> ertes, a, good to know.
07:22:41 <Cale> ertes: Yeah, fair enough, perhaps we could be taking advantage of that.
07:23:39 <Cale> reactormonk: In any case, it's not really a huge deal, since you can always just write (<*>) = ap and pure = return
07:23:54 <reactormonk> Cale, ah, good to know.
07:24:35 <ertes> reactormonk: since base >= 4.8 you would rather write:  instance Applicative F where { pure = …; (<*>) = ap }; instance Monad F where (>>=) = …
07:25:09 <ertes> reactormonk: so you only need to be redundant, if you want to implement a more efficient version of (<*>), for example
07:27:29 <Cale> It's actually really weird that we don't use DefaultSignatures in the definition of Applicative to provide a default for (<*>)
07:27:41 <Cale> Given that all this stuff was revised so recently
07:28:10 <ertes> i guess someone has to write it =)
07:28:20 <Cale> Also maybe just people wanting to reduce the number of extensions required to build the Prelude
07:29:01 <ertes> well, it shouldn't *require* any, right?  IIRC it makes heavy use of CPP to support other compilers
07:30:07 <ertes> i wonder if it would make sense to have a ghc-base library instead…  would certainly lower the maintenance burden, and supporting the current version of 'base' is probably already very difficult for new compiler authors
07:32:29 <Cale> Ah, right, Applicative/Monad are defined in GHC.Base already anyhow, and that module has e.g. UnboxedTuples, ExistentialQuantification and RankNTypes
07:32:44 <Cale> So adding in DefaultSignatures would probably not be a big deal :P
07:33:01 <ertes> yeah =)
07:33:23 <ertes> base is pretty much ghc-base already
07:33:39 <Darwin226> Hey guys. I have a class with an associated type `type Name t = n :: Symbol | n -> t`. Is there a way to write a type family `OfName :: Symbol -> *` that gets the `t` given the name?
07:33:41 <c_wraith> It stripped out all the hugs stuff a long time ago
07:33:58 <Cale> Perhaps the argument could be made that it screws over compilers that don't support DefaultSignatures because then all the *client* code just lacks definitions of (<*>) and that results in runtime failures
07:34:15 <c_wraith> what?  You can put a fundep on an associated type?
07:34:33 <ertes> Darwin226: for what?  whenever you use your type class, the type variable 't' is already in scope
07:34:42 <reactormonk> How does `data Car = Car { company :: String } deriving (Show)` work exactly? Specifically the `deriving (Show)` - compiler magic, or is that defined somewhere language-level?
07:34:54 <ertes> reactormonk: magic
07:35:08 <Cale> reactormonk: Pretty simple magic, but magic nonetheless.
07:35:20 <ertes> c_wraith: yeah, TypeFamilyDependencies makes associated types as expressive as fundeps
07:35:21 <reactormonk> ertes, ah, that explains why it's so fast in haskell compared to scala ^^
07:35:27 <c_wraith> Darwin226: you can do something weaker by saying (n~ Name t) in your constraint.  It may or may not suffice for your purposes.
07:35:35 <reactormonk> There it's language-level if you want it.
07:35:43 <Darwin226> ertes: Hmmm... That's true... I guess I could imagine something like (C (OfName "myname")) working
07:35:47 <Cale> There are some systems in place to do language level generics
07:35:51 <Darwin226> then I can only use the symbol
07:36:57 <shapr> oh hey, will the release of  ghc 8.0.2 also have containers 5.7.9.1 ? I want the new Data.Sequence features 
07:37:07 <ertes> reactormonk: the reason it's so fast is more likely that it uses the (.) encoding of lists
07:37:16 <ertes> @src ShowS
07:37:17 <lambdabot> type ShowS = String -> String
07:37:23 <byorgey> Darwin226: the answer to your question is no
07:37:37 <Darwin226> shapr: I think GHC doesn't ship with containers at all. You can use them right now
07:37:42 <ertes> reactormonk: it makes sure that 'show' result lists are properly lazy and right-associated
07:37:50 <shapr> Darwin226: I thought containers were part of base?
07:38:11 <shapr> Darwin226: bok! How's code? Written anything neat?
07:38:12 <ertes> reactormonk: in other words: it doesn't build the strings in-memory first…  it lazily produces them as you consume them
07:38:22 <Cale> shapr: not part of 'base' itself at least...
07:38:29 <ertes> reactormonk: even with nested stuff
07:39:03 <shapr> Darwin226: huh, I was confused, thanks for the tip
07:39:35 <byorgey> shapr: re: ghc 8.0.2 and containers, I highly doubt it, though I don't know for sure
07:39:50 <byorgey> shapr: you can just install the newer version of containers though.
07:40:08 <Cale> Though it's amusing to think of Show as being "fast" -- it uses String, which is a lazy linked list of 32 bit wide characters, and generally isn't very competitive with anything that works on a more compact memory representation.
07:40:39 <ertes> Cale: String *output* is not that slow, if GHC manages to optimise the linked list away
07:40:51 <Cale> It seems the version of containers that ships with GHC 8.0.2 is 0.5.7.1
07:41:02 <Cale> (I just downloaded it and checked)
07:41:22 <ertes> i'm pretty sure it's reduced to a loop that fills the Handle buffer directly
07:41:45 <Cale> ... maybe sometimes :)
07:42:06 <ertes> at least in many… show cases =)
07:42:28 <Cale> hshs
07:42:30 <Cale> haha*
07:42:32 <shapr> oh, it looks like ghc 8.0.2 also fixes the -no-pie problem
07:43:03 <ertes> i'm eager to get GHC 8.0.2…  if i understood correctly it makes -fdefer-typed-holes usable again =)
07:44:01 <ertes> 8.0 made *all* identifiers holes, which has annoyed me to no end…  so much that i disabled it completely
07:44:22 <Cale> GHC 8.0.2 will be the most life-changing release of GHC in a long while for me, and it's all because the build determinism will let my nix projects for work use parallel compilation.
07:44:47 <Cale> I have an 8 core water cooled machine that I can barely put to use :D
07:44:53 <ertes> yeah, indeed!
07:45:18 <srhb> Cale: Need to set up a Hydra server! :-P
07:45:35 <c_wraith> Cale: play DOOM on max graphics settings. :)  (seriously, though, it's a great throwback to when FPS games were fun)
07:46:14 <ertes> doom…
07:46:19 * ertes needs to get a better machine
07:46:38 <c_wraith> admittedly, it won't use all 8 cores.  yeah, you're gonna need parallel builds for that. :)
07:46:46 <Cale> haha
07:46:54 <Cale> Play DOOM while compiling
07:47:01 <shapr> :-)
07:47:17 <kuribas`> Cale: or witcher 3
07:47:24 <shapr> Cale: is your build process documented online somewhere?
07:47:54 <Cale> shapr: Not entirely... but it's based on the stuff in reflex-platform
07:47:56 <ertes> play DOOM while mining the next altcoin on the GPU and compiling reflex-platform on the other four cores
07:48:19 <Cale> shapr: Also, that doesn't yet use GHC 8.0.2 (but it will as soon as possible)
07:48:48 <shapr> neat!
07:49:56 <shapr> There are so many new libraries I don't know yet!
07:50:44 <Cale> shapr: Have you looked at reflex-dom at all? It's a lot of fun.
07:50:56 <shapr> No, I've just heard of it.
07:52:41 <Cale> It actually manages to make developing web frontends more fun than doing the backend stuff most of the time.
07:53:32 <ertes> shapr: i also appreciate reflex itself a lot
07:53:51 <Cale> Yeah, we need more reflex backends for other sorts of applications :)
07:54:10 <c_wraith> reflex-server?
07:54:17 <Cale> yeah, stuff like that
07:54:21 <c_wraith> Might as well make the backend use reflex too. :)
07:54:41 <ertes> Cale: i generally just write the host myself…  it's not too difficult if you understand the host part of reflex =)
07:54:48 <Cale> I would really really love to be able to have reflex interacting with the DB layer.
07:55:15 <Cale> ertes: Well, sure, but a lot of people don't want to do that :)
07:55:56 <Cale> If we had some basic support for OpenGL and SDL applications, I think more people could be encouraged to start, even if writing the hosts isn't going to be so bad.
07:56:31 <ertes> Cale: i'd probably enjoy implementing it, but i have no use for it myself…  also if you want that, then this should really be fixed first: https://github.com/reflex-frp/reflex/issues/63
07:58:07 <ertes> i've attempted to fix it myself, but getting into the Spider implementation is time-consuming
07:58:14 <ertes> so i gave up for now
07:58:18 <Cale> hmm
07:58:44 <ertes> due to that bug reflex is not suitable for long-running applications right now
07:59:04 <Cale> I'm not sure we've seen it come up in our reflex-dom stuff.
07:59:19 <ertes> maybe it only happens on bare metal for some reason
07:59:22 <Reisen> I have a really dumb question, is it possible to define an f, where curry (uncurry (curry f)) /= (curry f)?
07:59:46 <Cale> :t curry . uncurry . curry
07:59:47 <c_wraith> Reisen: use algebraic reasoning
07:59:47 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:59:51 <Cale> :t uncurry . curry
07:59:53 <lambdabot> ((a, b) -> c) -> (a, b) -> c
08:00:01 <Cale> ^^ this has to be the identity
08:00:13 <ertes> Reisen: i'd assume not, if curry and uncurry are implemented properly regarding strictness
08:00:14 <Cale> :t curry . uncurry
08:00:14 <c_wraith> Reisen: just substitute definitions of curry and uncurry together
08:00:16 <lambdabot> (a -> b -> c) -> a -> b -> c
08:00:19 <Cale> ^^ so does this
08:00:35 <Cale> @free f :: (a -> b -> c) -> a -> b -> c
08:00:35 <lambdabot> (forall x. k . p x = q (g x) . h) => k . f p y = f q (g y) . h
08:00:38 <Cale> hmm
08:00:46 <ertes> Reisen: oh, yeah…  you probably have a typo in that equation, too =)
08:00:46 <Reisen> I guess my question is more generally, is it possible to break isomorphisms somehow, I thought maybe it would be possible with something super sneaky
08:01:02 <Reisen> Like maybe you could make it unsound with some kind of type family trickery
08:01:03 <ertes> Reisen: unsafePerformIO can break isomorphisms
08:01:16 <c_wraith> ertes: can it?
08:01:47 <ertes> const (unsafePerformIO readSomeIORefAndIncrement)
08:01:55 <ertes> uhm
08:01:55 <c_wraith> ertes: at least in the simple case of inverses being applied to each other, I don't see how the definition of anything else can matter
08:02:43 <ertes> c_wraith: well, i guess it would be more sensible to say:  impurity breaks the concept of isomorphisms itself
08:03:08 <ertes> if f is impure, then "curry (uncurry f) = f" doesn't make much sense
08:03:12 <c_wraith> ertes: but you get the exact same impurity both ways! :)
08:04:18 <ertes> c_wraith: i think it would be easy enough to come up with a contrived example that uses unsafePerformIO to mess with some heap internals =)
08:05:07 <c_wraith> ertes: I guess the difference is that I'm treating = as meta-equality, rather than an artifact of program evaluation
08:05:09 <ertes> it could potentially distinguish between f and (uncurry f) and do different things
08:05:43 <ertes> c_wraith: i'd rather not use "=" at all when impurity is involved…  it doesn't really make much sense
08:06:52 <c_wraith> ertes: I mean, if you compile without optimizations so that no inlining/simplification happens, you could just inspect the heap objects using super-dirty internal stuff.
08:08:12 <ertes> let (c = modifyIORef v (+1) >> readIORef v), i would expect (unsafePerformIO c = unsafePerformIO c) to hold, but then you would need to define "=" in terms of state transitions on some abstract machine
08:08:48 <ertes> it would get very complicated and IMO almost useless
08:09:15 <c_wraith> Shoot, I totally forgot the name of that library again.  What's the one that generates graphs of heap objects?  It's not vacuum, it's the one that actually inspects thunks and graphs what they're holding references to.
08:09:28 <ertes> c_wraith: ghc-heap-view, i think
08:10:29 <c_wraith> Hmm.  I'm not sure if that was the same one or not, but it certainly does what I was asking about
08:10:38 <c_wraith> ...  Up until GHC 7.10
08:12:23 <c_wraith> Oh, I was actually thinking of ghc-vis
08:12:37 <c_wraith> Which depends on ghc-heap-view, but provides more front-ends for the data
08:13:23 <ertes> data-reify is a nice library on top of ghc-heap-view, but it does something unrelated to this =)
08:13:27 <ertes> (observable sharing)
08:14:03 <c_wraith> Now that GHC 8 finally has a stable release, it'd be nice if it was updated
08:14:53 <shapr> ok, so I need to add reflex to my list of Haskell things to learn
08:18:52 <ertes> shapr: vinyl is also a nice library to learn
08:19:00 <ertes> … to understand the things haskell sucks at
08:19:16 <c_wraith> I should learn dependent-map
08:19:38 <shapr> ertes: yeah, I like to learn those. Here at work people are learning Haskell to figure out where Python sucks.
08:21:45 <ertes> shapr: i frequently use the reflection library
08:22:05 <c_wraith> ertes: what for?  configuration?
08:22:26 <tabaqui1> hash maps in unordered containers have O(log n) asymptotics for search and insert operations
08:22:29 <ertes> c_wraith: yeah, for some value of "configuration"
08:22:36 <tabaqui1> what's the reason of using them?
08:22:39 <c_wraith> ertes: sure, it's a broad term
08:22:52 <ertes> tabaqui1: comparing hashes is much faster than comparing strings
08:23:03 <ertes> tabaqui1: or product types or …
08:23:04 <shapr> oh that's interesting
08:23:09 * shapr reflects on reflection
08:23:10 <c_wraith> tabaqui1: hash maps in all libraries have O(log n) asymptotics for search and insert.  People who claim otherwise are ignoring important things.
08:23:26 <c_wraith> tabaqui1: In all cases, the reason for using them is constant factors
08:23:31 <tabaqui1> c_wraith: python dicts have O(1) for lookup
08:23:45 <ertes> tabaqui1: python dicts are hash *tables*
08:23:55 <tabaqui1> ertes: ah, uhm
08:24:00 <ertes> tabaqui1: internally HashMap = IntMap
08:24:02 <davean> c_wraith: perfect hashing?
08:24:14 <c_wraith> tabaqui1: That's impossible.  The hash function has to take O(log n) time, or can't distribute the items in the table into O(n) buckets
08:24:22 <ertes> tabaqui1: it reduces keys to an Int first, then branches/compares that one
08:24:26 <c_wraith> tabaqui1: that's the important detail I was talking about
08:24:35 <tabaqui1> ertes: yeah, right
08:24:45 <tabaqui1> hmm
08:25:12 <c_wraith> davean: perfect hashing is O(1) by virtue of requiring that table size be fixed. :)
08:25:13 <tabaqui1> does haskell have hash tables then?
08:25:18 <davean> c_wraith: exactly
08:25:37 <titusg> Hi, I've got a problem with IO in a QuickCheck prop, can someone take a look?
08:25:50 <c_wraith> davean: by that criteria, unordered-containers has O(1) hashing whenever used with a finite key type. :P
08:25:52 <davean> c_wraith: and is therefor quite common in important performance areas
08:25:55 <lpaste> titusg pasted “QuickCheck prop with IO” at http://lpaste.net/351134
08:26:10 <tabaqui1> c_wraith: with bounded sets of elements, there are hashes with O(1) asymptotics for search
08:26:16 <ertes> tabaqui1: there is the hashtables library, but HashMap/IntMap were faster in all benchmarks i've done, so there is no reason to put up with the inherently stateful API of hash tables
08:26:32 <c_wraith> davean: I'm not arguing hashing doesn't give excellent constant factors.  I'm arguing that when they key set isn't bounded, O(1) is impossible.
08:26:41 <c_wraith> *the* key set
08:26:50 <davean> c_wraith: Ok, I saw no where you said "unbounced key set" before that
08:27:06 <davean> because most key sets are well bounded (and often constant)
08:27:17 <tabaqui1> by the way, which trees uses data.map?
08:27:22 <tabaqui1> red-black?
08:28:10 <ertes> tabaqui1: https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Map-Strict.html
08:28:18 <ertes> tabaqui1: see the explanation at the top
08:29:10 <c_wraith> davean: It's inherent in O notation.  It's defined in terms of "as n goes to infinity"
08:31:18 <tabaqui1> ertes: AVL actually
08:31:25 <tabaqui1> ok
08:31:31 <c_wraith> No.  It's not AVL or red-black
08:31:39 <c_wraith> It's something way more lax than either of those
08:31:45 <c_wraith> So that rebalancing is less frquent
08:31:47 <c_wraith> *frequent
08:35:55 <tabaqui1> c_wraith: ok, not AVL
08:36:31 <tabaqui1> but it's reasonable to use HashMap instead of Map only if there is fast implemebtation of "hash k"
08:36:49 <tabaqui1> faster then "compare k1 k2"
08:37:26 <ertes> tabaqui1: 'hash' is usually very straightforward
08:37:27 <tabaqui1> ah, no
08:37:46 <tabaqui1> it's reasonable when insetion is rare operation
08:38:03 <tabaqui1> *insertion
08:38:17 <ertes> @let import qualified Data.Hashable as H
08:38:19 <lambdabot>  Defined.
08:38:28 <ertes> > H.hash (5 :: Integer)
08:38:31 <lambdabot>  5
08:38:59 <ertes> > H.hash ((5, 7) :: (Integer, Word))
08:39:00 <tabaqui1> but "Map Int a" is faster than "HashMap Int a"
08:39:01 <lambdabot>  83888088
08:39:51 <ertes> tabaqui1: it is?  i guess you've found a rare edge case =)
08:40:03 <ertes> but you would use IntMap anyway in that case
08:40:56 <tabaqui1> ertes: oh, didn't know about this structure, thanks!
08:42:00 <tabaqui1> ertes: if we insert records in hashmap too often, then we should calculate hash each time and compare it as Int
08:42:36 <tabaqui1> if we insert simple keys (Int, Int) in map, we just compare two (or less) Int
08:43:17 <tabaqui1> hashmap has siginficant overhead with many insertions, right?
08:43:25 <tabaqui1> *significant
08:43:53 <ertes> tabaqui1: it needs to hash all keys
08:44:34 <tabaqui1> even worse
08:44:38 <ertes> but again: the hash function is very straightforward…  it doesn't use a traditional randomising hash function or a cryptographic hash
08:45:22 <kuribas`> ertes: doesn't that lead to unbalanced trees?
08:46:25 <dolio> HashMaps aren't balanced search trees.
08:46:32 <kuribas`> > H.has 20
08:46:34 <lambdabot>  error:
08:46:34 <lambdabot>      Not in scope: ‘H.has’
08:46:35 <lambdabot>      Perhaps you meant ‘H.hash’ (imported from Data.Hashable)
08:46:40 <kuribas`> > H.hash 20
08:46:42 <lambdabot>  20
08:48:03 <dram_phone> > H.hash 123451234512345123451234512345 -- It has to be something
08:48:06 <lambdabot>  -8993495017415724635
08:48:24 <tabaqui1> > H.hash -1
08:48:27 <lambdabot>  error:
08:48:27 <lambdabot>      • No instance for (Typeable a0)
08:48:27 <lambdabot>          arising from a use of ‘show_M22494089927855381124422’
08:48:37 <tabaqui1> > H.hash (-1)
08:48:40 <lambdabot>  -1
08:48:52 <tabaqui1> H.hash (-8993495017415724635)
08:49:00 <tabaqui1> > H.hash (-8993495017415724635)
08:49:03 <lambdabot>  -8993495017415724635
08:49:20 <pja> > 1 + 2
08:49:22 <lambdabot>  3
08:49:41 <dram_phone> That's, that's not how attack resistant hashing works is it?
08:50:03 <tabaqui1> @let a = H.insert (-8993495017415724635) 0 $ H.insert 123451234512345123451234512345 1 $ H.empty
08:50:04 <lambdabot>  .L.hs:165:5: error:
08:50:05 <lambdabot>      Not in scope: ‘H.insert’
08:50:05 <lambdabot>      Perhaps you meant one of these:
08:50:24 <tabaqui1> > H.insert (-8993495017415724635) 0 $ H.insert 123451234512345123451234512345 1 $ H.empty
08:50:27 <lambdabot>  error:
08:50:27 <lambdabot>      Not in scope: ‘H.insert’
08:50:27 <lambdabot>      Perhaps you meant one of these:
08:57:08 <ertes> dram_phone: correct, and indeed HashMap doesn't use such a hash function
08:57:32 <ertes> dram_phone: so an attacker can make HashMap drop to [(key, value)] speeds
08:57:47 <ertes> (but they can't make your memory usage blow up the way they could with hash tables)
08:58:08 <ertes> ideally HashMap would drop to a binary tree for colliding hashes, but it doesn't
08:59:37 <ertes> if you have attacker-controlled keys, it's best to define a wrapper type and use a fast cryptographic hash like BLAKE2 in HMAC mode with a secret key
08:59:37 <davean> if we're talking about unordered containers its not only at risk of such attacks, its unusably at risk
08:59:41 <davean> It doesn't even ahsh
08:59:53 <ertes> you can use reflection to define a Hashable instance for that key type
09:00:34 <davean> I view the hashable/unordered-containers packages as a dangerous lie
09:00:49 <davean> I have had to remove bugs from rather a large number of projects due to them
09:00:51 <dolio> Would degrading to a binary tree actually be better than just choosing a better hash?
09:01:26 <ertes> dolio: unlikely
09:01:40 <ertes> except perhaps on 32-bit platforms, where hashes start to collide very quickly
09:01:47 <pie_> if i want to understand (dependent) types, what math books should i read?
09:02:00 <pie_> i dont really have any experience with category/type theory yet
09:02:48 <wonder90> Can GHC HEAD or a nightly build of GHC be used as a solver for a stack project?
09:03:13 <dolio> Types and Programming Languages is probably a good start.
09:03:51 <Psychiatrist> Hey guys. I'm trying to make my custom Tree type an instance of Functor -- could someone point out what I'm doing wrong at the last line of: http://i.imgur.com/1wjeItT.png
09:04:31 <glguy> Psychiatrist: It's easier if you upload your code (in general) to a pastebin like http://lpaste.net
09:04:37 <davean> Psychiatrist: why would you ever screenshot text?
09:04:49 <glguy> Psychiatrist: also include the error messages
09:05:16 <davean> also the problem is your function "f" maps 'a's to 'b's but Leaf stores a Maybe a
09:05:28 <davean> but please never screenshot text again :(
09:05:34 <glguy> Psychiatrist: You should be able to write your instance with two cases rather than 4
09:05:36 <dolio> davean: When you're showing off a text rendering bug.
09:06:40 <davean> dolio: Then you're screenshooting the text rendering ;)
09:07:52 <dolio> I think I've had to take a photo of my screen before, too, because the graphical error was too far down the pipeline to show up in a screenshot.
09:09:10 <davean> dolio: Those are common in game programming :(
09:09:16 <Psychiatrist_> Sorry guys, I DCed if I missed any messages. I pasted the code into pastebin: http://pastebin.com/raw/KiS2xYyh
09:10:31 <glguy> Psychiatrist_: :    f :: (a -> b); subtree :: [Tree a];   fmap f :: [a] -> [a]
09:10:33 <glguy> erro
09:10:35 <glguy> Psychiatrist_: :    f :: (a -> b); subtree :: [Tree a];   fmap f :: [a] -> [b]
09:12:04 <glguy> so you're going to have a problem with   (fmap f) subtree   since subtree doesn't have the type [a]
09:12:20 <glguy> The type error is saying that for   [a] to equal [Tree a],  a would have to equal Tree a
09:12:53 <Psychiatrist_> in my mind I'd see fmap f subtree going through the same instance that I defined
09:13:27 <glguy> The instance you're defining gives you  fmap :: (a -> b) -> Tree a -> Tree b
09:13:30 <glguy> so that doesn't cut it, either
09:13:40 <glguy> This field is a [Tree a]
09:14:15 <Psychiatrist_> is this valid? (map (fmap f) subtree)
09:14:21 <glguy> yeah
09:14:23 <Psychiatrist_> NICE
09:14:24 <dram_phone> :t map -- hint
09:14:26 <lambdabot> (a -> b) -> [a] -> [b]
09:14:26 <Psychiatrist_> thanks
09:14:36 <glguy> Psychiatrist_: Now you can delete the two middle cases and fix the first one
09:14:43 <dram_phone> uh, hint was too late
09:15:03 <glguy> Psychiatrist_: you should have two cases: "fmap f (Leaf x) = ..." and "fmap f (Node a subtree) = ..."
09:15:18 <Psychiatrist_> hmm, alright
09:15:25 <Psychiatrist_> I fixed the first one
09:16:13 <glguy> Psychiatrist_: Also note that map is fmap for lists, so    map (fmap f) subtree   is   fmap (fmap f) subtree
09:16:44 <glguy> Using the Functor instance for [] helps implement the Node case; another Functor instance can help with the Leaf case
09:19:50 <wonder90> How do I remove the function arguments x and y from:  `myJoin x y = (Just) $ (-) x y`, so it's just myJoin = ..  ?
09:20:37 <glguy> ?pl \x y -> Just (x - y)
09:20:38 <lambdabot> (Just .) . (-)
09:20:51 <glguy> But it would be much better not to and write: myJoin x y = Just (x - y)
09:21:25 <Psychiatrist_> glguy: Thanks a lot, I got it down to two lines.
09:24:39 <wonder90> glguy: what does the ?pl lambdabot command do?
09:24:53 <glguy> ?help pl
09:24:53 <lambdabot> pointless <expr>. Play with pointfree code.
09:25:36 <wonder90> Cool!
09:25:51 * stobix loves that lambdabot has a pointless command that, well, isn't.
09:33:34 <Rodenbach> From all the free resources available online, is there some kind of defacto standard of being the „best” tutorial/intro into Haskell?
09:35:56 <maerwald> @where learnhaskell
09:35:56 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:58:56 <sm> I like https://leanpub.com/haskell-cookbook
09:59:07 <sm> (Rodenbach)
09:59:40 <ertes> Rodenbach: there is no de facto resource
10:02:24 <ertes> "Using Parenthesis or the Special $ Character and Operator Precedence"
10:02:25 <ertes> yikes
10:09:03 <Rodenbach> sm: also nice, thx!
10:12:29 <codygman_> > (\r -> r^._1 > subtract 30 (r^._1)) (0,0)
10:12:32 <lambdabot>  True
10:12:58 <codygman_> Is there a more concise way to write this? I feel like there should be a general form of this
10:13:21 <codygman_> > (>) <$> (^. _1) <*> (subtract 30 . (^. _1)) $ (0,0)
10:13:23 <lambdabot>  True
10:13:59 <ertes> Rodenbach: CIS194 and NICTA are widely regarded as good resources though…  just get GHC and start those
10:17:19 <ertes> Rodenbach: here is also a book recommendation just to have some diversity in the commercial options: http://www.cs.nott.ac.uk/~pszgmh/pih.html =)
10:17:29 <hexagoxel> > uncurry (>) . (id *** subtract 30) $ (0,0) -- codygman_
10:17:31 <lambdabot>  True
10:18:02 <ReinH> hexagoxel: The first element is used in both
10:18:38 <ertes> codygman: const False
10:18:44 <glguy> > views _1 (\x -> x > x-30) (0,0)
10:18:47 <lambdabot>  True
10:18:52 <ertes> uhm
10:18:57 <ertes> codygman: const True
10:19:02 <ReinH> heh
10:19:08 <glguy> ertes: on Integer, yes, not Word
10:19:15 <ertes> ah, i see
10:19:39 <ertes> :t (\(x, _) -> x > x - 30)
10:19:41 <lambdabot> (Ord a, Num a) => (a, t) -> Bool
10:19:58 <ertes> you don't have to shoehorn lenses into everything, you know =)
10:20:04 <glguy> Yeah, if the lens in question was actually _1 on a 2-tuple, I'm with ertes
10:20:07 <ReinH> Well, you can factor out the ^. _1 and call it fst
10:20:30 <ertes> ReinH: doesn't make it particularly nicer though
10:20:38 <ertes> :t (\x -> x > x - 30) . fst
10:20:40 <lambdabot> (Ord a, Num a) => (a, b) -> Bool
10:20:50 <ReinH> Yeah, that.
10:28:33 <seequ> Or, if you wish, \_ -> True
10:29:18 * seequ didn't notice const was mentioned
10:29:29 <glguy> If we can get away with not preserving the original meaning, maybe we can get away with not preserving the type. How about: ()
10:31:57 <codygman_> hexagoxel: thanks! Err i think :D because now I'll probably write code like that
10:34:12 <codygman_> ReinH, all: (0,0) is a stand in for a more complex type
10:35:11 <glguy> codygman_: When you don't ask the actual question but a simpler one, you're likely to get a simpler answer than you wanted
10:35:15 <ReinH> I would still factor out the view _1
10:35:48 <ReinH> then it's no longer a simpler type
10:35:53 <ReinH> er, a more complex type
10:40:12 <codygman_> In my real example it is more like
10:40:52 <codygman_> (glguy) > views signupDt (\x -> x > x-30) user
10:41:07 <codygman_> Minus the glguy ;)
10:41:29 <codygman_> I think what he posted is the ideal in my case
10:49:32 <nitrix> Does Haskell has a category for kinds?
10:50:14 <nitrix> Or for example, a category whose objects would be a functor of Hask ?
10:51:03 <nitrix> Is there such thing as a category of Haskell categories?
10:52:11 <nshepperd1> The category of natural transformations? type f ~> g = forall a. f a -> g a
10:52:57 <seequ> Btw, how does forall a. f a -> g a differ from f a -> g a ?
10:54:13 <glguy> Without more context, it doesn't differ
10:54:53 <glguy> Maybe we could consider the case where that's the type of a record field, or of a function argument
10:55:12 <glguy> Are you looking at a particular situation?
10:55:36 <seequ> Well, at what nshepperd1 said
10:56:49 <glguy> If you had a definition like: myfun :: (forall a. f a -> g a) -> ...; myfun fg = ...
10:57:01 <glguy> you'd be able to use fg at many different types
10:57:19 <glguy> fg :: f Int -> g Int;   fg :: f Char -> g Char
10:57:33 <glguy> where you get to make the decision inside the definition of myfun
10:57:48 <glguy> however with myfun :: (f a -> g a) -> ....;
10:58:04 <glguy> The choice of 'a' is made by the user of myfun
10:58:18 <glguy> inside myfun you don't get to assume anything about it
10:59:29 <glguy> When you're making a type synonym the type variables have to be quantified somewhere, so your choices in ~> are:  type f ~> g = forall a. ...
10:59:36 <glguy> or type (f ~> g) a = ...
11:03:03 <hackrilege> What is (~>) ?
11:03:34 <glguy> A type operator that is being defined
11:04:00 <hackrilege> Ah, no wonder I can't find it on hoogle!
11:04:15 <codygman_> :t const . fmap
11:04:17 <lambdabot> Functor f => (a -> b1) -> b -> f a -> f b1
11:04:42 <seequ_> Heh, I still don't see the difference
11:05:55 <codygman_> :t const . map
11:05:56 <nshepperd1> seequ: to put it shortly, the difference between f a -> g a and forall a. f a -> g a, is that in the second one a is universally quantified (so it's a polymorphic type) and in the first one it's a free variable, and takes the value of whatever a is in the context
11:05:57 <lambdabot> (a -> b1) -> b -> [a] -> [b1]
11:06:01 <ertes> nitrix: kinds can be objects with type constructors as morphisms
11:06:59 <codygman_> (const . map) id undefined [0..5]
11:06:59 <mizu_no_oto_work> seequ_ `foo :: f a -> g a` is the same as `foo :: forall a. f a -> g a`.
11:07:01 <seequ_> nshepperd1: ahh
11:07:15 <codygman_> > (const . map) id undefined [0..5]
11:07:18 <lambdabot>  [0,1,2,3,4,5]
11:07:48 <mizu_no_oto_work> `type Foo a =  f a -> g a` is different than `type Foo = forall a.  f a -> g a`
11:07:49 <glguy> ertes: The morphisms probably aren't restricted to type constructors
11:08:01 <glguy> just types with kind * -> * or similar, right?
11:10:02 <seequ_> On a related note: fourth day with Haskell, loving it. Understanding monad transformers took a while, but they're ingenious.
11:11:02 <hackrilege> Can you explain them to me seequ_?
11:11:25 <codygman_> :t fmap const
11:11:26 <lambdabot> Functor f => f a -> f (b -> a)
11:11:52 <hackrilege> Or, what you like about them...
11:12:14 <codygman_> > fmap const [0..3]
11:12:16 <lambdabot>  error:
11:12:16 <lambdabot>      • No instance for (Typeable b0)
11:12:16 <lambdabot>          arising from a use of ‘show_M74957432736449195027393’
11:13:30 <seequ_> hackrilege: They take a monad as a type, wrapping new functionality around them. So we can compose functionality infinitely! \o/
11:14:08 <hackrilege> :t lift
11:14:10 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
11:15:22 <nshepperd1> seequ: however, in type signatures (in let blocks, where blocks and inline signatures i think), Haskell automatically adds a forall quantifier for any left over fee variables just to save typing, which is why you will see function definitions in haskell code like 'id :: a -> a' 
11:15:58 <Jello_Raptor> I'm looking for some advice. I'm implementing some operations over the usual numeric types, but should be different depending on whether they have an Enum instance etc.. Basically something like "existsValueBetween (Num a,Ord a) => a -> a -> Bool" that is clearly different for for things like Integers and Rationals 
11:17:38 <Jello_Raptor> There's no typeclass that nicely corresponds to this, and the best prelude has is Enum (which would fail for Floats and Doubles, since those are discrete in practice but not in Haskell's type hierarchy)
11:19:52 <davean> Jello_Raptor: I think the issue for Floats and Doubles having an enum class is that there is no sensible order
11:19:52 <ertes> glguy: a "type constructor" being any type of kind (a -> b) for some kinds 'a' and 'b'
11:20:19 <davean> Jello_Raptor: I mean, an Enum instance could exist
11:20:19 <glguy> That not a type constructor in Haskell. Is that what a type constructor is in category theory?
11:20:37 <davean> Jello_Raptor: but which one would you want?
11:20:40 <ertes> glguy: that was supposed to be a definition =)
11:20:59 <ertes> add a "where" in front
11:21:15 <glguy> Oh, OK. I could have imagined that that's how the term is used in CT
11:21:16 <hackrilege> I guess you just want to check if it's fractional
11:21:32 <ertes> glguy: i wouldn't know
11:22:08 <Jello_Raptor> Alternately, does anyone recommend an alternate prelude that's total and has a nice hierarchy of numeric typeclasses? 
11:22:41 <hackrilege> What's wrong with the one in Prelude?
11:24:08 <ertes> Jello_Raptor: how about Ord?
11:24:27 <ertes> Jello_Raptor: ah, nevermind
11:24:51 <ertes> i guess it depends on whether your interval is closed
11:25:19 <hackrilege> :t fromIntegral
11:25:21 <lambdabot> (Num b, Integral a) => a -> b
11:25:36 <hackrilege> :t fromRational
11:25:38 <lambdabot> Fractional a => Rational -> a
11:26:04 <hackrilege> One is countable, the other isn't
11:26:20 <monochrom> Jello_Raptor: I suggest created your own class and hand-coding the common instances.
11:26:49 <monochrom> In fact because even knowledge of Enum doesn't help.
11:28:34 <shiona> is there such a thing as "enumerable in ascending order of value" in math?
11:28:53 <monochrom> Across the hall in the math department, this issue is under "denseness" and is a concept pretty much independent of enumerable ordered rings
11:30:08 <monochrom> s/created/creating/
11:30:53 <monochrom> shiona: That would be "order-isomorphic to the nats or ints"
11:32:00 <shiona> monochrom: ok. thanks.
11:55:51 <NextHendrix> having a bit of a typemare
11:56:49 <NextHendrix> trying to implement numeric e^x
11:57:26 <NextHendrix> https://ptpb.pw/defV.hs
11:58:44 <NextHendrix> can only get it to load in GHCI with no type annotations, and then it fails on every input because of ambiguous type
11:59:05 <dmwit> :t (^)
11:59:07 <lambdabot> (Num a, Integral b) => a -> b -> a
11:59:18 <NextHendrix> in my mind, factorial should be Int -> Int, and eFrac should be Int -> Int -> Double
11:59:25 <dmwit> Perhaps you would like `(x ^ i) / fromIntegral i`.
11:59:49 <NextHendrix> :t (/)
11:59:50 <lambdabot> Fractional a => a -> a -> a
11:59:51 <dmwit> NextHendrix: `(/)` definitely does not have type `Int -> Int -> Double`.
12:00:01 <NextHendrix> eFrac has two inputs
12:00:08 <NextHendrix> two integers
12:00:36 <dmwit> If you want the inputs to be `Int`, but the output to be `Double`, you will have to convert at some point.
12:00:53 <NextHendrix> well i tried whacking a :: Double on the end to no avail
12:01:04 <dmwit> > let factorial n = product [1..n]; eFrac x i = (x ^ i) / fromIntegral i in eFrac 3 4
12:01:07 <lambdabot>  20.25
12:01:21 <dmwit> NextHendrix: Type ascriptions do not convert between types.
12:01:29 <dmwit> They can only make a type more specific, not change the type entirely.
12:01:58 <dmwit> > let factorial n = product [1..n]; eFrac x i = (x ^ i) / fromIntegral (factorial i) in eFrac 3 4 -- forgot to call factorial, lol
12:02:00 <lambdabot>  3.375
12:03:03 <NextHendrix> you're right, conversion does the trick
12:03:33 <Jello_Raptor> what's the extention that allows me to propote datatypes into types, and the corresponding types into kinds? 
12:03:42 <dmwit> -XDataKinds
12:03:43 <NextHendrix> i was incorrectly expecting (:: Double) to magically convert it :S
12:03:47 <Jello_Raptor> thanks :) 
12:03:52 <NextHendrix> thanks a lot
12:05:49 <saml> is wand a good algorithm?
12:11:11 * shapr waves his wand at saml 
12:19:04 <dmwit> niteria: Math.OEIS.extendSequence appears to concatenate search results instead of returning just the first result as the documentation claims. When I try `extendSequence [0,2,4]` the answer starts like `[0,2..120]` but then continues as `[1,6,1,8,0,3,3]` and so on.
12:27:55 <romano> does any know of any problems with async/parmap combination? i'm running parmap inside an async and i can't get it to use all cores
12:38:26 <byorgey> ertes: things of arrow kinds is not the definition of 'type constructor' in Haskell, though the term often gets misused that way.
12:39:17 <byorgey> if you read the Haskell report it clearly defines 'type constructor' to mean the parallel thing to 'data constructor' --- a name starting with a capital letter that constructs a type.
12:39:37 <byorgey> Int, Maybe, Either are all type constructors.  Either Int  is not.
12:41:38 <ertes> byorgey: yes, again: i was *defining* the term type constructor for my particular usage
12:42:36 <ertes> byorgey: i guess you haven't seen it though, because it was further below =)
12:43:25 <byorgey> ertes: OK, in that case I object to using a standard term and redefining it to mean something different for your particular usage. =)
12:44:31 <ertes> byorgey: yeah, sorry…  i shouldn't be so hesitant to use the word "type function"
12:44:47 <byorgey> yeah, "type function" is good
12:45:01 <EvanR_> Either Int isnt a type constructor?
12:45:16 <glguy> No, type constructor describes a single name
12:45:24 <byorgey> EvanR_: nope, it's the application of the type constructor Either to the type constructor Int.
12:45:24 <ertes> EvanR_: the same way (,) 5 isn't a data constructor
12:45:36 <byorgey> EvanR_: it has kind  * -> *  though.
12:45:39 <glguy> type constructor: Either, Bool, (->)
12:45:42 <glguy> type variable: a b c
12:45:46 <EvanR_> in the same sense that (+1) isnt a function?
12:45:55 <glguy> No (+1) is a function
12:46:02 <ertes> EvanR_: it's report terminology
12:46:05 <EvanR_> or are we trying to strictly interpret a standard
12:46:13 <byorgey> EvanR_: Either Int  is a type function.  it is not a type constructor.
12:46:17 <glguy> Either Int isn't a name, it's an expression
12:46:35 <EvanR_> +1 isnt a name
12:46:46 <byorgey> right, so it isn't a data constructor
12:46:46 <glguy> the type formed by the type constructor Either is being applied to the type Int formed by the type constructor Int
12:47:04 <EvanR_> if a smart ctor had some name, it would be a data constructor?
12:47:10 <glguy> (+1) is an expression and it has a type of the form  _ -> _
12:47:12 <glguy> so it's a function
12:47:32 <glguy> No, smart constructors are always defined as variables, lowercased things
12:47:35 <EvanR_> * -> * are literally called type functions?
12:47:37 <glguy> so they are variables, not consturctors
12:47:48 <glguy> constructors*
12:47:49 <EvanR_> havent heard that before
12:48:04 <glguy> There are two sorts of value names, variables and constructors
12:48:23 <byorgey> EvanR_: that terminology is not as standard/widespread, but sure.  Or you could just call them 'types of kind * -> *'
12:48:42 <monochrom> EvanR_, "False || True" is not a value constructor, but "False" alone is.
12:49:21 <monochrom> You are trying to draw a parallel between the value world and the type world, and yet the parallel reinforces glguy's point.
12:50:13 <EvanR_> i dont know what good type level terminology is anyway, so i usually dont call it anything and jus use haskell ;)
12:51:00 <glguy> The tricky part is that when we write something like   True, it's impossible without context to know if we're talking about the name True, or the value expression True
12:51:19 <EvanR_> you could use quotation for the name
12:52:46 <monochrom> type-constructorness might not be as important as data-constructorness. You need to know data constructors for what's legal in pattern matching. The type world doesn't have a similar restriction.
12:52:57 <glguy> It does: typeclasses
12:54:06 <glguy> typeclass instances are matched by pattern on type constructors
12:54:16 <glguy> similarly type/data family instances
12:54:27 <monochrom> ah
12:55:04 <glguy> This leads to my wishing that type synonyms introduced new type variables instead of new type constructors
12:55:41 <monochrom> yikes
12:55:46 <glguy> Because of type synonyms, the distinction is in fact blurred
12:56:24 <monochrom> OK I see, the problem is with "you need not say 'forall'"
12:57:05 <monochrom> So if I write so much as "mine :: whee -> whee", you don't know whether "whee" is a type synonym defined elsewhere or I'm saying "forall whee. whee -> whee".
12:57:22 <glguy> exactly
12:57:41 <monochrom> Many years ago I already wrote in haskell-cafe how much harm is implicit forall. Now we know one more :)
12:57:49 <ertes> "how come you don't talk about it?  all haskell programmers i know are crazy about it" – "i love it, too, but you know, programming in it is much easier than talking about it"
13:00:18 <EvanR_> wait, lowercase type synonyms?
13:00:33 <monochrom> tee hee hee!
13:00:48 <monochrom> See my comment again. It will help.
13:02:24 <dolio> Lowercase value synonyms?
13:03:46 <EvanR_> unrelated i just noticed you can do intersection of sorted lists... is this faster or slower than Set intersection
13:03:52 <monochrom> glguy! We need pattern synonyms for types!
13:04:48 <glguy> monochrom: I think after you enable TypeSynonymInstances, that that's what type synonyms are
13:06:25 <ryba> hi
13:06:39 <lambdabot> Hello.
13:06:40 <ryba> does anyone here has experience with accelerate library?
13:09:14 <byorgey> EvanR_: it is faster when the lists are about the same length.  Slower when one is much shorter than the other.
13:09:26 <glguy> Unless you're taking a survey of #haskell and the libraries that have been used, you're more likely to get help just asking your question
13:10:18 <EvanR_> byorgey: huh... intersection [] reallyLong = []
13:10:30 <ryba> im just starting with accelerate and im trying to do some simple iteration over vector, but whathever i do i get Data/Array/Accelerate/Language.hs:650:10-44: No instance nor default method for class operation fromEnum error
13:10:37 <byorgey> EvanR_: ok, other than that special case.
13:10:58 <ertes> intersection [0] [1..]
13:11:00 <byorgey> EvanR_: if the first list is not empty, you have to look at every element in the second list.
13:11:15 <EvanR_> right
13:11:25 <EvanR_> infinite would be the point
13:11:29 <byorgey> EvanR_: if they are Sets then it turns out you can do a bit better, you don't have to look at every single element
13:11:30 <ertes> you don't really have to
13:12:02 <ertes> intersection (0 : xs) (1 : ys) = 0 : intersection xs (1 : ys)
13:12:15 <EvanR_> no, it doesnt have a 0 in that case
13:12:23 <EvanR_> 0 != 1
13:12:53 <EvanR_> = intersection xs (1:ys)
13:13:40 <EvanR_> but i see that you could get bottom eventually
13:13:55 <ertes> @let intersectL (x : xs) (y : ys) = if x < y then x : intersectL xs (y : ys) else y : intersectL (x : xs) ys; intersectL [] ys = ys; intersectL xs [] = xs
13:13:57 <lambdabot>  Defined.
13:14:03 <ertes> > intersectL [0] [1..]
13:14:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:14:09 <EvanR_> why are you prepending x
13:14:22 <ertes> however…
13:14:26 <EvanR_> intersection is everything thats in both sets
13:14:28 <ertes> > intersectL [1..] [0]
13:14:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:14:30 <EvanR_> not either
13:14:37 <ertes> oh, d'oh
13:14:40 <ertes> @undef
13:14:40 <lambdabot> Undefined.
13:14:54 <ertes> i was thinking of union
13:16:11 <EvanR_> intersect [0] [1..] = []
13:16:22 <ertes> intersect [0] [1..] = undefined
13:16:27 <EvanR_> no
13:16:30 <Athas> ryba: you might have more luck on /r/haskell, or ask the Accelerate devs directly.  Not many users yet.
13:16:36 <EvanR_> since the first list is finite, itll end
13:16:53 <glguy> ryba: You could paste your code to http://lpaste.net
13:17:35 * byorgey agrees with EvanR_, if we are assuming the lists are sorted
13:17:36 <EvanR_> you only have to search the shorter of the two
13:17:40 <ertes> ah, you have the sortedness invariant
13:17:42 <glguy> ryba: The Exp type from accelerate has a fake Enum instance
13:18:39 <byorgey> EvanR_: you only have to search until the end of whichever list's last item is smaller
13:18:43 <EvanR_> and if you use a pair of lists sorted in opposite directions, you could have infinite subsets of integers
13:19:16 <glguy> ryba: So if your code is using [_ .. _] syntax for types from accelerate you'll have to stop
13:19:16 <EvanR_> oh
13:19:33 <ryba> glguy: you got me here
13:20:41 <glguy> I'm not sure how to interpret that
13:20:51 <ryba> glguy: i tried that
13:20:57 <BartAdv> hm, DuplicatedRecordFields allow me to declare duplicated accessor, but don't allow me to use them (at once). what's the point? Or am I missing something obvious
13:21:07 <ph88^> anyone here using darcs ?
13:21:28 <dolio> I use darcs.
13:21:30 <ryba> glguy: but i tried to use it with foldl, which should translate to series of sums
13:21:46 <ph88^> dolio, do you mind if i ask you a few questions in pm or in #darcs ?
13:21:59 <ryba> glguy: sums of Exp, which should be fine
13:22:12 <dolio> Sure. Probably better in #darcs, since other people can answer if I don't know answers.
13:22:42 <glguy> ryba: OK. When you paste the code you can indicate that it's for #haskell and the URL will appear here automatically
13:23:45 <ryba> glguy: after some changes it doesnt compile so let me first try to make it compile again
13:24:25 <monochrom> EvanR_: Data.Set's intersection is linear-time too. The hedge algorithm <3
13:24:57 <EvanR_> is the set of all possible infinite subsets of natural numbers definable in haskell the same as any other (turing complete) language
13:25:00 <monochrom> (Roughly speaking it is divide-and-conquer on steroid)
13:25:38 <monochrom> I think you need to restrict to the computable ones, but yes
13:25:41 <EvanR_> sorted lists of nats with no duplicates
13:27:01 <monochrom> I might teach the hedge algorithms to the poor kids when I teach binary search trees next time!
13:27:25 <EvanR_> poor kids, is that what you call students after they get charged tuition
13:27:54 <monochrom> No, I haven't been thinking of their money.
13:28:29 <monochrom> And it's OK for me to not think of their money, because our CS school charges them a per-year flat rate, independent of how many courses they take and then drop.
13:28:56 <EvanR_> in what sense do infinite subsets NOT definable in haskell exist?
13:29:04 <monochrom> However, I was thinking of how hard my course is to them
13:29:26 <monochrom> In the classical math-and-logic sense.
13:29:46 <monochrom> Classical math exists, no? Just look at all those mathematicians. They think therefore they exist.
13:29:51 <EvanR_> i must be regressing, i dont really understand that sense
13:30:51 <lpaste> ryba pasted “this doesnt work” at http://lpaste.net/351150
13:31:20 <glguy> ryba: Does it work if you replace [0..2] with [0,1,2] ?
13:31:43 <ertes> EvanR_: the codomain of the busy beaver function
13:31:51 <ryba> glguy: lol yes
13:31:57 <ryba> glguy: but why?
13:32:13 <glguy> ryba: OK, like I said, accelerate's Exp type doesn't have a valid Enum instance
13:32:20 <EvanR_> ertes: the image?
13:32:23 <glguy> the [_.._] syntax uses an Enum instance
13:32:37 <EvanR_> good call
13:32:46 <glguy> ryba: I don't know why that is, I've never looked at accelerate before
13:32:56 <rgrinberg> Anyone else find intero/flycheck unbearably slow in spacemacs?
13:32:56 <ryba> glguy: ok, what are alternatives?
13:32:58 <ertes> EvanR_: yeah, the image
13:33:14 <EvanR_> ertes: in what sense does that (whole) sequence exist?
13:33:24 <monochrom> haha
13:33:30 <ertes> EvanR_: it "exists" in "classical mathematics" =)
13:33:34 <glguy> ryba: Look at this section http://hackage.haskell.org/package/accelerate-0.15.1.0/docs/Data-Array-Accelerate.html#g:12
13:33:41 <glguy> "Enumeration"
13:33:53 <ryba> glguy: because im not fan of typing [ (x,y) | x<-[0..7] y<-[0..7] ] manually :)
13:34:03 <EvanR_> each element of that list requires someone come up with a proof that a particular turing machine halts or not
13:34:04 <monochrom> We are the classical logicians. You exist. Resistance is futile.
13:34:07 <EvanR_> doesnt it
13:35:03 <EvanR_> but i guess once someone does, the answer cant be anything else
13:35:15 <EvanR_> interesting
13:35:37 <EvanR_> the only question left is whether we can logically continue that process as far as we want
13:35:57 <gameer> Hey Guys. I'M reading Learn you a Haskell and acutally I learn Input/Output. There are some examples with GNU cat. I never used something like this(I use windows). I found now "GnuWin". Is this something right to get this?
13:36:07 <monochrom> Well the problem is that you don't know one succint tactic that works for the whole sequence, you have to do each element ad-hoc.
13:37:30 <monochrom> The most hurting news to you is that most researchers in computability use classical logic.
13:37:52 <monochrom> If you asked them about existence, they would think you're kidding.
13:38:11 <EvanR_> what if you get to element 31 in the sequence, and someone proves that the answer is not provable or disprovable
13:38:45 <Kaidelong> if you're proving that one problem is reducible to a computable one there isn't really much of a problem with indirect proofs, is there?
13:38:58 <ryba> gameer: cat is simply read file and output to termina
13:39:09 <monochrom> They will just say "neato one more undecidable/independent problem". They survived the continuum hypothesis, you know.
13:39:39 <Kaidelong> uncomputable*
13:39:49 <EvanR_> that would seem to make the idea of this sequence in the first place much more subjective than the original "we just dont know what the elements are yet"
13:39:55 <ertes> EvanR_: i think each result requires a proof for a whole class of turing machines
13:40:17 <ryba> gameer: if you want to try this on windows install cygwin, or if you have windows 10 you can try with windows bash (unix subsystem or whathever it was called, type in google windows 10 bash and you will find)
13:40:43 <EvanR_> as i understand it continuum hypothesis is just taken for granted in a lot of set theory
13:41:25 <Tuplanolla> I think the Windows equivalent to `cat` is `type`, gameer.
13:41:25 <gameer> I dont have win10, but thanks. I will try Cygwin :)
13:41:40 <ertes> EvanR_: you would rather specify under which assumption you're working:  CH right or CH wrong
13:41:40 <gameer> Tuplanolla: So I can use type in the console?
13:41:48 <EvanR_> and is not provable or disprovable in the one true set of axioms
13:41:53 <ertes> EvanR_: because both are consistent with ZFC
13:42:05 <EvanR_> so its like another axiom
13:42:05 <monochrom> Let me tell you the most horror story in computability. Define the set S, a subset of the naturals, to be { n : Nat | the Riemann hypothesis }.
13:42:42 <ryba> glguy: the problem with those enumerations is that i am within generate function, and if i tried for example to map over this enum range i would get nested parallellism i guess, which isnt supported
13:42:49 <monochrom> If you open most computability textbooks, this set is classified as decidable. Proof: There are only two cases...
13:42:53 <EvanR_> the riemann hypothesis parameterized by an n ?
13:43:07 <monochrom> No, S is either Nat or empty.
13:43:16 <EvanR_> ok, no n
13:43:29 <gameer> Tuplanolla: Nice, thanks, it works :)
13:43:31 <EvanR_> yes ive seen that justification
13:43:41 <EvanR_> in a book. i was kind of flabbergasted
13:43:59 <ertes> > let riemannHypothesis = True in [ x | x <- [0..], riemannHypothesis ]
13:44:01 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:44:09 <ertes> > let riemannHypothesis = False in [ x | x <- [0..], riemannHypothesis ]
13:44:09 <ertes> =)
13:44:14 <lambdabot>  mueval-core: Time limit exceeded
13:44:15 <EvanR_> []
13:44:21 <EvanR_> lol
13:45:06 <EvanR_> let riemannHypothesis = False in [ x | x <- [0..]++[], riemannHypothesis ]
13:45:10 <EvanR_> [] ;)
13:46:38 <EvanR_> { n : N | continuumHypothesis }
13:46:41 <EvanR_> decidable
13:46:57 <EvanR_> >_<
13:47:21 <monochrom> I think you should surrender. Resistance is futile.
13:47:31 <monochrom> Come join the dark side!
13:47:33 <EvanR_> is something wrong with computer science?
13:47:53 <EvanR_> that subset existing sounds like equivalent to platonism
13:47:55 <monochrom> No. Classical logic is more powerful!
13:48:01 <ertes> computer science: the science of the middle
13:48:16 <EvanR_> its either empty or its full, we just dont know which
13:48:32 <EvanR_> we dont know if we have the right set theory axioms installed
13:49:01 <Kaidelong> logicians use "more powerful" in a way that's exactly the opposite of what it sounds like
13:49:16 <EvanR_> the beginning of this set theory book says "future mathematicians may come up with new axioms of set theory and add them to the list"
13:49:39 <EvanR_> not exactly quoted... i should probably get the exact quote
13:49:40 <dolio> Continuum hypothesis is not the same (probably) as the Riemann hypothesis.
13:49:45 <monochrom> No no, classical logic is not more powerful. Quantum logic is. |CH>/sqrt2 + |not CH|/sqrt2 FTW.
13:49:53 <Kaidelong> you can generally still embed "more powerful" logics in "less powerful" ones.
13:49:57 <ertes> it's also not really a hypothesis anymore
13:49:59 <monochrom> err, |not CH>
13:50:03 <ertes> it's more like a property
13:50:20 <EvanR_> well, you can take it as a hypothesis, like anything
13:50:31 <dolio> No.
13:50:43 <Kaidelong> the reason for that is because they're using power to mean the proportion of things that have a proof, and if you add a bunch of equivalences in a logic, it becomes "more powerful", even though really there are less distinct things you can talk about than if you didn't
13:51:04 <kazagistar> EvanR_: silly mutability. Why not "future mathematicians may come up with new axioms of set theory and create a new list containing those too"
13:51:06 <dolio> The continuum hypothesis has been proved independent of the logic you'd probably say you're working in.
13:51:43 <EvanR_> right, like ertes was saying, you take it as given a lot of the time, like an argument to a function
13:51:44 <monochrom> Kaidelong: "powerful" is my own word, not logicians'. I am aware of the dialectal class struggle between "more powerful demonically" vs "more powerful angelically". I was joking.
13:51:56 <dolio> The Riemann hypothesis probably isn't, if I had to guess.
13:51:59 <Kaidelong> not just yours
13:52:06 <monochrom> OK
13:52:11 <ertes> most of the time, unless you're doing foundational work, you'll probably not need to care about it anyway
13:52:14 <Kaidelong> probably the person who I've seen use it most obnoxiously is Priest
13:52:16 <Kaidelong> he's a good writer though
13:52:30 <EvanR_> yes we still have the hope that riemann hypothesis can be solved, and award EvanR with the million dollar prize
13:55:49 <monochrom> kazagistar: Mathematicians say "add 1 to 4" all the time, and yet they don't mean "afterwards, 4=5 becomes true".
13:56:10 <kazagistar> monochrom: touche
13:56:32 <monochrom> And of course they don't literally say that, but they do say "add a new vertex to the given graph G"
14:00:21 <nitrix> IS STT on IO safe?
14:01:27 <smoge> is there a irc channel for haskell and music/art?
14:01:35 <nitrix> I'm thinking to use STT on a game's monad transformer stack, but once you runST you lose the references created so you aren't able to runST again for the next frame, unless you tie or not or recursively call runST.
14:01:53 <Kaidelong> nitrix: should be safe, but why not just use IO?
14:02:03 <nitrix> Is this (1) a good idea, (2) am I going to have performance issues (3) what happens with rendering? Do I do my IO rendering inside ST now?
14:02:37 <Kaidelong> on (1), what do you get from STT IO that you won't get from IO?
14:02:49 <nitrix> Kaidelong: I'd interested in giving the user the ability to create arbitrary references, but not to run arbitrary IO computations.
14:02:52 <Kaidelong> STT s IO*
14:02:59 <Kaidelong> okay well
14:03:26 <geekosaur> how do you plan to extricate the IO from the STT?
14:03:40 <nitrix> I'm in exploratory phase atm picking up an older project of mine.
14:03:46 <Kaidelong> I think there was a class for monads with references
14:04:03 <Kaidelong> let me see if I can find it
14:04:29 <monochrom> there is one (or more) on hackage. try words like "monadref"
14:04:47 <nitrix> The stack is a newtype and you're not able to run IO things useful. Instead, the framework provided you monadic computations that used IO behind the scenes but you had no access to it.
14:04:50 <augur> is this pattern familiar to anyone?    f = fmap g . sequence f . h
14:04:56 <nitrix> Like the newtype didn't derive MonadIO.
14:05:29 <augur> i think this somehow relates to folds over unfolds??
14:05:37 <EvanR_> in type theory like MLTT, are the logical rules involving natural numbers (introduction, elimination / induction principle) considered just rules? axioms? definitions?
14:06:39 <EvanR_> at what point do you have to call something an axiom
14:06:54 <hexagoxel> augur: same f?
14:07:10 <Kaidelong> nitrix: is this interface good enough?
14:07:11 <Kaidelong> http://hackage.haskell.org/package/ref-mtl-0.3/docs/Control-Monad-Ref.html
14:07:34 <monochrom> EvanR_: Both rules and axioms mean "built-in". But rules are stated at the meta level, axioms are stated inside the logic.
14:07:48 <Kaidelong> you could simply hide IO behind a newtype, and re-export this instance
14:08:04 <Kaidelong> MonadRef IORef IO
14:08:25 <Kaidelong> you might want to wrap the ref too if you want to hide any IORef specific functions
14:09:49 <atz__> EvanR_: it seems to me that they're like the universal properties in category theory.
14:10:08 <dmwit> smoge: I don't think so, but there is a workshop on it. FARM
14:10:21 <dmwit> http://functional-art.org/
14:10:33 <dolio> EvanR_: MLTT is based on natural deduction, which doesn't have 'axioms' per se.
14:11:08 <ertes> nitrix: if you want to disallow non-ST effects for part of an IO action, just give it an ST type instead of an IO type
14:11:08 <dolio> Axioms are more for Hilbert systems, where the only inference rule is modus ponens.
14:11:12 <dmwit> :t \g f -> fmap g . sequence f
14:11:14 <lambdabot> Traversable f => (a1 -> b) -> f (a -> a1) -> a -> f b
14:11:15 <ertes> nitrix: IO is a special case of ST
14:11:50 <dmwit> lol
14:11:51 <dolio> And then you have a bunch of axioms (which are propositions) that fill out the logic so that you only need that one inference rule.
14:12:00 <dmwit> :t \g f -> fmap g . traverse f
14:12:02 <lambdabot> (Traversable t, Applicative f) => (t b1 -> b) -> (a -> f b1) -> t a -> f b
14:12:09 <monochrom> EvanR_: Take for example Hilbert's logic. It says "there is only one rule, modus ponen". This means this is the main activity you, the prover, has to do all the time. It then says "Here are a lot of axioms". These are sentences inside the logic; apart from being "they're given, they're pervasive, they're your Prelude", they are just like any other sentence you can write inside the logic.
14:12:22 <augur> hexagoxel: yeah, same f, but it's an equation not a definition, probably
14:12:24 <augur> dmwit: hmmm
14:12:36 <EvanR_> is principle of excluded middle then an axiom?
14:12:37 <ertes> nitrix: ah, i realised that this won't work…
14:12:42 <EvanR_> in a hilbert system
14:12:48 <ertes> nitrix: you couldn't access STRefs that way
14:12:57 <augur> so the concrete context that this pattern arises is something like this:
14:13:01 <dolio> EvanR_: Yes.
14:13:03 <nitrix> Kaidelong: This definitely seems promising, but not quite.
14:13:13 <EvanR_> so many axioms
14:13:27 <monochrom> No, Hilbert's system uses just implication. But it has Pierce's law as an axiom, which causes you to have a classical logic.
14:13:35 <EvanR_> so the traditional axioms of set theory are underpinned by even more axioms of classical logic
14:13:36 <dolio> EvanR_: In natural deduction, there would be an excluded middle inference rule with zero premises above the bar.
14:13:48 <dolio> Which is a lot like an axiom, really.
14:13:51 <augur> if you're building a proof tree, or some other kind of tree, in a monad where the production of each node is done top down, but that production might have effects, this is (roughly) the way you can build it
14:14:31 <dmwit> :t \f -> fmap f . sequence
14:14:32 <lambdabot> (Traversable t, Monad f) => (t a -> b) -> t (f a) -> f b
14:14:46 <nitrix> Kaidelong: What if we simplify this and I say that the monad for my game is some form of ReaderT + StateT + STT + ErrorT on Identity or something.
14:14:52 <EvanR_> ((P -> Q) -> P) -> P
14:14:59 <EvanR_> will have to think about that one
14:15:04 <monochrom> Natural deduction is kind of an opposite style to Hilbert's. Natural deduction has a ton of rules but just one axiom: "P |- P". To obtain classical logic, there are several ways, but the way I'm most familiar with is adding this rule (double-negation elimination): "from not(not P), deduce P"
14:15:14 <Kaidelong> nitrix: I tried making a game engine like this once in the past and my own experience with it was "I should just have used IO"
14:15:30 <Kaidelong> you could probably figure out some clever stack
14:15:35 <augur> you have some coalgebra h that decomposes a node into subnodes, possibly with effects, then you build up the tree, sequencing the effects to get an effectful tree
14:15:41 <Kaidelong> but when working with mtl you should focus on the classes, not the structures
14:15:41 <nitrix> Kaidelong: Very little effects possible as far as updating the game goes. Normally you'd runStateT . runReaderT and so on in your main loop and obtain the final state that you can render in some IO context outside of your game monad.
14:15:47 <Kaidelong> use MonadReader, not ReaderT
14:16:05 <Kaidelong> use MonadThrow and MonadCatch rather than ExceptT
14:16:05 <nitrix> Kaidelong: But because STT is brought to the picture, I'd lose these references between invokations of runSTT
14:16:07 <Kaidelong> etc etc
14:16:17 <nitrix> Kaidelong: It's figuratively, please.
14:16:19 <Kaidelong> then just use IO as the actual data structure
14:16:31 <nitrix> I'm not interested in having IO as a data structure.
14:17:16 <nitrix> It's way too permissive for my goals.
14:18:01 <EvanR_> encode the idea of "this is a video game, and whats more, its actually fun to play" into the types somehow, *dreams on*
14:18:05 <dmwit> If you don't need `IO`, why do you need `STT`?
14:18:08 <Kaidelong> it's not worth it putting too much effort into preventing a user of a library from doing stuff later
14:18:15 <dmwit> Just place `ST` as the bottom of your monad stack.
14:18:28 <nitrix> dmwit: Well fine, ST is at the bottom then.
14:18:33 <nitrix> I still have to runST.
14:18:53 <nitrix> And since every frame runST, and you can't unify the `s`, you're still screwed.
14:18:55 <dmwit> Okay. What's the question, then? I thought the question was "can I use STT and IO together?".
14:19:16 <Kaidelong> that was the original question but he also asked if it is a good idea to do that
14:19:19 <nitrix> dmwit: The issues is that you'd loose your references between invocations of runST.
14:19:25 <nitrix> dmwit: Between the frames.
14:19:26 <geekosaur> nitrix, tbh if you think you need to runST every frame, you are using ST incorrectly
14:19:29 <Kaidelong> and at least personally I see no reason you'd ever prefer STT s IO over IO
14:19:44 <geekosaur> you are specifically *not supposed to* do that.
14:19:47 <Kaidelong> IO can do everything ST can, and more
14:19:49 <nitrix> Since the monad for the game doesn't do rendering and I don't want it to do rendering, this has to happen in IO externally.
14:20:01 <nitrix> Yet, having something "external" doesn't play nice with ST semantics.
14:20:08 <EvanR_> introduce and elmination as purely a rule of logic is pretty interesting...
14:20:18 <EvanR_> of numbers i mean
14:20:50 <EvanR_> so all inductive types end up being just logic
14:20:53 <dmwit> nitrix: Yes, that's sort of true. I think something might be possible with lazy ST, but it doesn't seem particularly pretty.
14:20:58 <Kaidelong> nitrix: you could just make your game functions monomorphic in your Game monad and then give a "runGame" when things actually have to be passed to the renderer
14:21:06 <nitrix> geekosaur: I want to keep the game update/logic/monad completely separated from the rendering of the new state after a frame.
14:21:19 <geekosaur> sounds like a free monad to me?
14:21:22 <Kaidelong> you could internally use ST to have references
14:21:49 <dmwit> nitrix: e.g. the top-level ST thing would be something like `[Event] -> ST s [Frame]`.
14:22:20 <nitrix> dmwit: That's more or less where I'm headed using FRP, but I can't connect the dots.
14:22:43 <nitrix> That is, infinite lists as inputs and infinite lists as outputs.
14:22:48 <EvanR_> would "vsync" be an Event there
14:22:56 <nitrix> The game would remain completely pure and the renderer is external.
14:23:02 <dmwit> EvanR_: Yes, sure, or "1/30s passed".
14:23:26 <dolio> Only 30 fps?
14:23:30 <EvanR_> penchant for 30 fps ... why
14:23:43 <EvanR_> 24 for that movie look
14:23:46 <atz__> EvanR_: isn't the elimination rule for natural numbers essentially the same as the definition of a natural numbers object (e.g. in a topos) in the sense of categorical logic?
14:24:25 <EvanR_> i dont see any induction anything in natural number objects
14:24:32 <dolio> The definition of a natural numbers object would include all the rules about natural numbers.
14:24:55 <EvanR_> its defined by the interface Z and S and a universal property
14:25:17 <augur> edwardk: do you know of anything like an effectful coalgebra?
14:25:23 <dolio> Introduction, elimination and proof equivalence, I think.
14:25:28 <AWizzArd> In this expression I repeat x^2  several times:  [ x^2 | x <- [1..90], mod (x^2) 100 == 0, (x^2) < 7000, (x^2) > 1500 ]    is there a way to give it a name, say „n” and use that instead? I am basically trying to access the current value(s) of the LC.
14:25:36 <anonus> hi
14:25:50 <anonus> i have a question about auto library
14:25:56 <EvanR_> proof equivalence?
14:26:06 <dolio> EvanR_: induction is the existence part of the universal property.
14:26:08 <asivitz> nitrix: why do you need a monad at all? if you want your game state update to be pure, it's just a pure function right?
14:26:39 <dmwit> AWizzArd: [ n | x <- [1..90], let n = x^2, mod n 100 == 0, n < 7000, n > 1500 ]
14:26:42 <anonus> is there more elegant way of doing Auto m (a, b) (c, Blip d) -> Auto m (a, b) (Blip (c, d)) ? http://ix.io/1PTs
14:26:47 <atz__> the universal property of a natural numbers object is essentially the induction rule...
14:27:03 <AWizzArd> dmwit: oh good, thanks!
14:27:15 <EvanR_> i feel like this should be enlightening, could you elaborate on that
14:27:52 <dmwit> > filter (\n -> n `mod` 100 == 0 && inRange n (1500,7000)) . map (^2) $ [1..90]
14:27:55 <lambdabot>  error:
14:27:55 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M893024543363...
14:27:55 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
14:28:48 <Tuplanolla> That looks like `traverse` for `(,) s` and `Blip`, anonus.
14:29:16 <atz__> well... the universal property of the natural numbers object tells you that in order to extend a morphism from the terminal object 1 to an object X to a morphism N -> X (where N is the natural numbers object) it suffices to give a morphism X -> X.
14:29:17 <dmwit> > filter (\n -> n `mod` 100 == 0 && inRange (1500,7000) n) . map (^2) $ [1..90]
14:29:20 <lambdabot>  [1600,2500,3600,4900,6400]
14:29:25 <dmwit> AWizzArd: Another spelling you might like.
14:30:15 <atz__> And this gives a unique morphism N -> X where the successor function and the given morphism X -> X commute.
14:30:17 <AWizzArd> dmwit: looks also good, was just wondering about where to put that let in the LC.
14:30:18 <EvanR_> eureka!
14:30:44 <anonus> Tuplanolla: as far as I remember Blip is not Applicative =/
14:31:00 <Tuplanolla> That's a shame, anonus.
14:31:42 <EvanR_> atz__: wait... do all universal properties correspond to induction-like principles o_O
14:31:50 <atz__> yes :)
14:32:16 <EvanR_> my brain just exploded
14:32:33 <atz__> if you look at the induction-like principle for 2-tuples it's just the universal property of categorical products
14:32:48 <atz__> similarly sum types corresponds to the universal property for coproducts.
14:32:49 <atz__> etc.
14:34:31 <EvanR_> all this time i thought category theory was abstract nonsense, but under this identification with induction, its just another programming language
14:34:33 <dolio> That is the entire theory behind "initial algebra semantics".
14:35:08 <dolio> Data types are initial algebras, and the fold is the universal property of the algebra.
14:35:58 <EvanR_> everything is now trivially obvious
14:36:28 <atz__> have you heard of homotopy type theory yet?
14:36:36 <EvanR_> yes i read the book
14:37:00 <f-a> I am getting this error from cabal new-build http://paste.debian.net/908529/
14:37:09 <atz__> it's a similar idea... except replace "category" with "infinity-category"
14:37:23 <atz__> (at least that's how I see it...)
14:37:40 <EvanR_> yes, or -groupoid?
14:37:48 <atz__> right infinity groupoid
14:38:00 <f-a> this happened after cabal getting hakyll and then new-building it. Is there anything I can do?
14:38:16 <EvanR_> that makes sense since equality is symmetric
14:38:25 <EvanR_> but other than that i dont see the parallel
14:38:40 <EvanR_> with the initial algebras thing
14:38:49 <dmwit> f-a: Well, you could look at Distribution.Client.Dependency:658
14:38:57 <dmwit> f-a: (sorry)
14:39:24 <geekosaur> f-a, you upgraded to ghc 8.0.2?
14:39:33 <f-a> geekosaur: a few minutes ago, yeah
14:39:40 <geekosaur> iirc directory got bumped at the last minute, the ecosystem has to catch up
14:39:50 <f-a> km
14:39:56 <f-a> *ok, I can wait
14:40:01 <geekosaur> you might to better to downgrade back to 8.0.1 and wait a few weekjs
14:40:36 <geekosaur> (there was a warning about that in the announcement and the release notes)
14:41:36 <ertes> hmm…  IO is no longer a special case of ST as it seems
14:42:47 <atz__> EvanR_: It's more complicated in the infinity-groupoid context, but you might try to think about how to define a topological space from finite data.
14:43:26 <atz__> There are standard ways of doing this in the category of simplicial sets via some adjoint functors.
14:43:49 <atz__> and these essentially encode these "higher" universal properties.
14:44:56 <EvanR_> what is the significance of these two adjoint functors
14:45:27 <EvanR_> endofunctors on category of simplicial sets?
14:45:28 <ertes> nitrix: anyway, it works, if you use stToIO (which is safe)
14:45:32 <atz__> For example there's an adjoint functor to the restriction of a simplicial set to its k-skeleton.
14:45:42 <ertes> nitrix: and that way you can also leak STRefs out of ST
14:46:06 <atz__> so if a topological space is naturally defined by its k-skeleton, this adjoint functor will encode all the corresponding universal propertie.s
14:46:09 <ertes> nitrix: (you can no longer use those in runST, of course, because that would be a problem)
14:46:17 <atz__> the circle, for example, is defined by its 1-skeleton.
14:46:41 <dmwit> Whoa, cool, I never knew about http://hackage.haskell.org/package/hackage-db-1.22/docs/Distribution-Hackage-DB.html.
14:46:49 <rgrinberg> How can i do a define  a cons on a church encoded list?
14:47:36 <atz__> Is there a category theory channel?
14:47:59 <rgrinberg> ##categorytheory i believe
14:48:17 <dmwit> rgrinberg: \new_elem list cons nil -> cons new_elem (list cons nil)
14:48:21 <rgrinberg> dmwit: thanks
14:50:12 <EvanR_> if the classical world of math is a dream, then we can be the engineers to construct the bridge to get there... and maybe find nothing
15:03:32 <rgrinberg> Are haskell's type holes the same as agda's metavariables?
15:04:06 <c_wraith> no, the compiler doesn't use context to fill them in partially, the way again can. 
15:04:24 <c_wraith> but the general idea is similar - just less magical. 
15:04:42 <c_wraith> err, the way agda can. 
15:05:12 <monochrom> Did you use "ag<tab>" to obtain "again"? :)
15:05:41 <c_wraith> that would be thematically appropriate. but it was just my phone's autoincorrect
15:06:22 <rgrinberg> I see. So would it ever be possible to have something like agda's emacs mode?
15:06:43 <rgrinberg> Where the type holes become goals and you can see the context
15:06:48 <rgrinberg> but less magical as you said
15:06:58 <ertes> rgrinberg: you can see the context with typed holes
15:07:14 <rgrinberg> Yeah, but it's not really usable like in agda's emacs mode :/
15:07:15 <monochrom> you just have to read the error message completely
15:07:16 <ertes> it tells you what's in the local scope along with the types (and where those types came from)
15:07:36 <ertes> rgrinberg: that's right…  it's possible in principle, but the current haskell-mode doesn't do it
15:07:38 <monochrom> Unfortunately, studies show that programmers have mental blocks whenever error messages happen.
15:08:11 <rgrinberg> The programmer is absolved from blame in this case. The error messages are huge and redundant
15:09:40 <monochrom> No, the two are in a vicious cycle.
15:10:26 <hodapp> As a general rule, when the error message is a factor of 2 or 3 times as large as all of the source code (once it's past some basic 10-20 lines), I start to lose interest pretty quickly.
15:10:32 <c_wraith> error messages really need to be interactive. start super small, allow the programmer to request more info if they desire it. 
15:10:42 <hodapp> I'm looking at you, C++.
15:11:05 <monochrom> Programmers have mental blocks in front of error messages (even irredundant ones). But they don't know it's a mental block. They think the error message is too short. So compiler writers add more stuff to error messages. Repeat.
15:11:38 <c_wraith> but not like rustc, which just kicks you to a longer generic description of the error. I mean things like source location and context should be hidden initially. 
15:12:24 <dmwit> I think you have it backwards. Source location should be the only thing shown by default. =P
15:13:02 <monochrom> The case of C++ is worsened by the lack of Haskell type classes. So it has to tell you implementation details of some methods just so as to tell you "you lack a + operator" (the equivalent of Haskell's "you lack a Num instance")
15:13:26 <dmwit> I honestly don't know where the compiler's inevitably incorrect suggested fixes should show up in the chain, though.
15:13:28 <hodapp> that and the fact that the language is a holy clusterfuck to parse.
15:14:05 <rgrinberg> not everybody gets this wrong. agda is maintained by like ~3 people and it's a joy
15:14:06 <hodapp> so something slightly amiss in a template in a header file might mean that it's telling you that OH MY GOD EVERYTHING IN THIS ENTIRE PROJECT IS COMPLETELY BROKEN HOLY SHIT NOTHING WORKS RIGHT
15:14:51 <EvanR_> at least it does that at compile time not runtime... oh...
15:16:17 <monochrom> Perhaps that's what we need. Dictatorship on error messages.
15:16:25 <hodapp> bah?
15:16:44 <monochrom> Because you know what happens when more stakeholders have a say on error message (or pretty much anything).
15:18:34 <EvanR_> agda and error messages... you get 1 line of text which says some words, but the location of the error is highlighted in the window and you dont even need to read it
15:19:00 <EvanR_> instead of a tower of errors which you need to scroll up to start reading, just to get the line number
15:20:09 <ongy> I had some fun with c++ template error messages today
15:21:13 <hodapp> hm, I haven't used Agda at all. I have been trying to learn Lean lately.
15:21:51 <Axman6> monochrom: I think they should be puce, it'll help the cyclysis^wdevelopers relax when they arrive at work
15:23:42 <monochrom> Oh haha great because http://english.stackexchange.com/questions/68872/why-does-puce-mean-two-different-colors-depending-on-where-you-live
15:25:27 <hodapp> still haven't found an IRC channel, Slack, gitter, or anything like that for Lean, but mailing list is good
15:27:44 <Axman6> monochrom: ha, I guess that was unintentionally more funny than that I meant it to be =)
15:36:24 <quack_> Hello?
15:36:40 * dmwit waves in quack_'s general direction
15:37:29 <quack_> Hi!  I am new here.  I programmed in C++ before, and I need to learn Haskell for school.
15:37:40 <quack_> Well uni actually
15:37:58 <dmwit> Welcome! There are many, many resources out there for learning, and this channel is certainly one of them.
15:38:00 <Axman6> This is good news for you!
15:38:03 <dmwit> ?wiki tutorials
15:38:03 <lambdabot> https://wiki.haskell.org/tutorials
15:38:07 <EvanR_> consider a planet X with the following rule "if it rains one day, it rains the next day". you arrive on planet X and its not raining. you conclude it was not raining the day before. can you conclude it has never rained?
15:38:11 <EvanR_> on planet X
15:38:36 <Axman6> yes?
15:38:44 <quack_> Well, if you look at predicate logic, p -> q.   Neg p does not mean neg q.  
15:38:45 <Axman6> I can't see any trick there...
15:38:58 <EvanR_> its like induction but backwards
15:39:18 <dmwit> quack_: No, but neg q does imply neg p.
15:39:31 <dmwit> quack_: In particular, "it is not raining today" does imply "it did not rain yesterday".
15:39:40 <dmwit> EvanR_: Now just apply induction.
15:39:46 <quack_> Hmm, ok.  
15:40:09 <dmwit> Like, normal forwards induction, with today numbered 0, yesterday numbered 1, the day before yesterday numbered 2, etc.
15:40:13 <EvanR_> neg q implies neg p ?
15:40:37 <dmwit> Yes, `p -> q` and `!q -> !p` are equivalent.
15:40:56 <quack_> dmwit is correct
15:40:58 <EvanR_> how that...
15:40:58 <dmwit> In classical logic, at least.
15:41:02 <EvanR_> oh
15:41:04 <quack_> I remember learning that 
15:41:06 <c_wraith> that's the contrapositive relationship. 
15:41:13 <dmwit> EvanR_: They're both `p \/ !q`.
15:41:41 <Axman6> if the premise implies the conclusion, and you know the conclusion is false, then the premise must also be false
15:42:01 <dmwit> Seems like we can probably do it in intuitionistic logic, too.
15:42:10 <EvanR_> im checking
15:42:12 <dmwit> ?djinn (p -> q) -> ((q -> Void) -> (p -> Void))
15:42:13 <lambdabot> f a b c = b (a c)
15:42:31 <dmwit> ?djinn (p -> q) -> Not q -> Not p
15:42:31 <lambdabot> f a b c = b (a c)
15:42:33 <dmwit> yay
15:42:41 <Axman6> heh, nice!
15:42:53 <EvanR_> yep
15:43:12 <EvanR_> ?djinn (p -> q) -> (q -> Void) -> p -> Void
15:43:12 <lambdabot> f a b c = b (a c)
15:43:25 <dmwit> Just plain old function composition. =)
15:43:26 <EvanR_> hooray
15:43:39 <EvanR_> thus, it really wasnt raining yesterday ;)
15:44:03 <EvanR_> no spooky malfunctions of logic leaving us with not nots
15:44:34 <ur_> How would I create an instance of Random for a sum types with non-empty constructors?
15:45:20 <dmwit> Do you definitely need to?
15:45:23 <c_wraith> use Random to create a value of each constructor argument's type. 
15:45:38 <EvanR_> does Random have laws?
15:46:28 <ur_> I don't definitely need to, but I might as well learn how to. Or an equivalent. 
15:46:33 <dmwit> EvanR_: I think you would surprise somebody if your results weren't roughly uniformly distributed, or if `randomR (x,y)` gave a value `z` which was not between `x` and `y`.
15:46:49 <Axman6> assuming it's something like Arbitrary, something like oneOf [Foo <$> randoms, Bar <$> randoms <*> randoms] might work?
15:47:01 <dmwit> EvanR_: Dunno that I've seen those stated as laws, but that's the kind of contract I'd keep in mind when instantiating `Random`.
15:47:01 <EvanR_> :t randomR
15:47:02 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:47:08 <c_wraith> Axman6, have to be much more manual 
15:47:10 <EvanR_> wow that... doesnt involve Ord
15:47:37 <dmwit> EvanR_: The guy writing the instance is of course allowed to use `Ord`, since for him the `a` has been monomorphed.
15:47:42 <EvanR_> "roughly uniformly distributed" sounds a little flaky
15:48:11 <EvanR_> monomorphin time!
15:48:21 <dmwit> That's why I didn't try to write the law for it. =P
15:48:34 <ur_> the problem with a random value for each of the values of the constructor is that a different function needs the type itself to be Random
15:49:01 <ur_> so that it can generate an infinite list of random values of that type
15:49:31 <EvanR_> well you can do instance Random a => MyFoo a where
15:49:34 <EvanR_> er
15:49:41 <EvanR_> well you can do instance Random a => Random (MyFoo a) where
15:50:27 <dmwit> ur_: I think you can probably write an instance like `instance (Ix a, Bounded a, Random a, Ix b, Bounded b, Random b) => Random (Either a b)`.
15:51:10 <dmwit> ur_: Use `Ix` and `Bounded` to compute how much weight to give to choosing `Left` or `Right`, then use `Random` to get the actual value under that constructor.
15:51:26 <EvanR_> No instance for (Random (Either Bool Bool))
15:51:28 <EvanR_> ;_;
15:52:47 <Axman6> that's just (Bool, Bool)
15:53:09 <ur_> dmwit: hm, that's interesting. A bit more then I bargained for, but I'll give it a try
15:53:39 <ur_> I wonder why randomR :: RandomGen g => (a, a) -> g -> (a, g) isn't 
15:54:33 <EvanR_> No instance for (Random (Bool, Bool)) ... Either
15:55:01 <ur_> hm.. don't know what exactly
15:55:18 <Ferdinanvw> cause it has a type constraint Random a
15:55:24 <dmwit> EvanR_: P.S. the documentation for randomR agrees with my proposed contract =)
15:55:36 <EvanR_> the uniform part?
15:55:37 <ur_> but something where it was (a, a) -> g -> (b, g)
15:55:51 <dmwit> EvanR_: Both the uniform part and the in-range part.
15:56:09 <EvanR_> right the range part makes sense
15:56:27 <EvanR_> its funny that this notion of range is possibly independent of Ord
15:56:29 <EvanR_> or Enum
15:57:07 <ur_> I suppose the type itself must provide the range, but why can't a different type provide the range?
15:57:39 <dmwit> If you agree "the type itself must provide the range", how can you ask the question you asked?
15:57:56 <c_wraith> ur_, what Int values are between True and False? 
15:58:17 <Axman6> Qbit values
15:58:39 <ur_> dmwit: yes, clumsy. In the first statement I was asserting that that is how Random typeclass is defined
15:58:40 <c_wraith> those are complex reals, not ints. :P
15:59:03 <ur_> c_wraith: Do Int values have to be between True and False for them to define a range?
15:59:07 <EvanR_> No instance for (Random (Complex Double))
15:59:34 <c_wraith> ur_, yes. that's what defining a range means. 
15:59:55 <codedmart> Any ede users here?
16:00:04 <ur_> c_wraith: Well yes, if you take that definition. But some function could take an int and provide a range for Bool
16:00:06 <EvanR_> using Int would be like relying on Enum
16:00:36 <EvanR_> though i think c_wraith's thing is using Bool as the range and Int is the random type
16:01:06 <ur_> oh right.
16:01:18 <ur_> still, you could define it as 0,1
16:01:29 <EvanR_> > fromEnum True
16:01:31 <lambdabot>  1
16:02:22 <ur_> so why not (RandomGen g, Enum a) => (a, a) -> g -> (b, g)
16:03:07 <dmwit> ur_: Is `a` or `b` the type variable mentioned in the `Random` class header? My objection to your proposal depends dearly on your answer.
16:03:20 <Ferdinanvw> it will have to...
16:03:50 <Ferdinanvw> fuck read it wrong, nvm
16:04:01 <ur_> dmwit: uh... well I guess 'b' would be the one in the class header
16:04:50 <dmwit> ur_: Okay. Then my objection is that I want to declare `Random` instances for types that don't have any reasonable correspondence with `Int`s, and you've just forced me to have one for that function to be implemented.
16:06:58 <ur_> dmwit: Hm. Right. So how about RandomGen g => (a, a) -> g -> (b, g)
16:07:31 <ur_> where an arbitrary function could be interpreted into a range
16:07:45 <ur_> type* not function
16:07:57 <dmwit> ur_: Oh, great, now you've even taken away my ability to inspect the `a`s to get an `Int` out of them and I have literally *nothing* I can do with them!
16:08:17 <dmwit> (Remember: the *caller* gets to choose what type `a` is here, not the instance writer!)
16:09:11 <EvanR_> not literally nothing, you can pass it to polymorphic functions
16:09:21 <ur_> dmwit: Hm... I guess I'm missing something
16:09:26 <Axman6> that came off a little passive aggressive dmwit (I don't think it was meant to)
16:09:27 <EvanR_> such as (:[])
16:09:49 <ur_> Axman6: Nah, I understood it as a joke :) don't worry
16:09:52 <EvanR_> which doesnt help
16:09:59 <ur_> RandomGen g => (a, a) -> g -> (a, g) is fine
16:10:00 <ur_> but 
16:10:00 <Axman6> =)
16:10:13 <ur_> but RandomGen g => (a, a) -> g -> (b, g) is not
16:10:24 <dmwit> ur_: Phew, thanks for interpreting my comment charitably. It was indeed meant as a joke. =)
16:10:58 <Ferdinanvw> remember that a is an instance of Random in your second type
16:11:06 <dmwit> ur_: Well, to be more fair, since `b` is in the class header, you should be comparing `RandomGen g => (b, b) -> g -> (b, g)` (OK) to `RandomGen g => (a, a) -> g -> (b, g)` (not OK).
16:11:35 <ur_> dmwit: yeah, should have gone with the a. now I just confused myself
16:11:41 <ur_> yes that's what I meant
16:13:58 <ur_> so let's just switch to a being in the header. that's more intuitive
16:15:13 <ur_> so RandomGen g => (a, a) -> g -> (a, g) vs (b, b) -> g -> (a, g) vs (b, c) -> g -> (a, g) 
16:15:26 <augur> unfurl :: (Traversable f, Monad m) => (a -> m (f a)) -> a -> m (Fix f)
16:15:26 <augur> unfurl f = return.In <=< mapM (unfurl f) <=< f
16:15:49 <augur> effectful coalgebras???
16:16:19 <ur_> doesn't (b, c) -> g -> (a, g) cover everything that (a, a) -> g -> (a, g) covers
16:16:41 <dmwit> ur_: Absolutely, and much much more (which is the problem).
16:17:18 <ur_> dmwit: Is it though??
16:17:21 <augur> Control.Functor.Algebra mentions F-M-Monadic Coalgebras which are defined as   type GCoalgebra f m a = a -> f (m a)
16:17:24 <augur> which seems relevant
16:17:28 <augur> time to read this package! :D
16:17:34 <dmwit> ur_: Okay, let me pose a simpler question.
16:17:41 <dmwit> ur_: Can you implement the type signature `a -> a`?
16:18:14 <ur_> dmwit: Jup, only in one way
16:18:32 <ur_> dmwit: Right, you're saying that it gives too many possibilites
16:18:37 <dmwit> ur_: Okay. So then you should have no problem implementing the type signature `a -> b`, right? Since it covers everything that `a -> a` covers for sure.
16:19:10 <ur_> I see
16:19:12 <dmwit> Or, if not, let's try to articulate clearly why it's hard to implement `a -> b`. Then let's see if we can apply that logic to your proposed type for `randomR`.
16:20:40 <ur_> well, a -> b can describe any possible unary function I suppose
16:21:09 <dmwit> Hm. That doesn't sound quite right to me. It's places a lot of constraints on the implementor.
16:21:10 <augur> edwardk: so it seems like what i'm looking for is GCoalgebra; is there a monadic equivalent of anamorphisms that produces monadic results? i saw you have g_ana but i that produces a pure result??
16:21:30 <dmwit> For example, `not :: Bool -> Bool` is a unary function, but it definitely can't be given type `a -> b`.
16:21:40 <ij> Can tdfa do captures/groups?
16:21:50 <dmwit> > (not :: a -> b) True
16:21:52 <lambdabot>  error:
16:21:52 <lambdabot>      • Couldn't match type ‘a’ with ‘Bool’
16:21:52 <lambdabot>        ‘a’ is a rigid type variable bound by
16:22:00 <ur_> dmwit: Oh right... I probably shouldn't think of it in the context of `fmap`
16:22:27 <ij> regex-tdfa, that is, of course
16:22:29 <dmwit> ur_: A function of type `a -> b` has to be able to produce any `b` the caller dreams up, given just a value of type `a` (again of the caller's choosing).
16:22:34 <luminos1ty> hello
16:23:26 <luminos1ty> so i am forcing myself to use ubuntu to learn the linux environment.  I am a microsoft baby i feel so lost
16:23:50 <luminos1ty> I don't know where to start, some people said VIM but it is so alien to me
16:24:08 <lpaste> dmwit pasted “Random (Either a b)” at http://lpaste.net/351157
16:24:23 <dmwit> ur_: ^^ (going back to your original question)
16:24:34 <johnw> luminos1ty: are you also trying to learn Haskell?
16:25:01 <dmwit> ur_: A better class than `Ix` would let this make only one call to `randomR` instead of sometimes requiring two, and would eliminate the overflow problem.
16:25:05 <dmwit> ur_: But I am lazy. =P
16:25:25 <luminos1ty> Well it is a language I am interested in learning more of.  Have learned some basics.  Basically unsure what I want to do on my free time to be familiar enough with linux to put it on my resume
16:25:58 <ur_> dmwit: Oh I see. Interesting. Thanks for going through the trouble! :)
16:26:03 <luminos1ty> I know the age old thing where people swear up and down about linux, but i don't see it yet
16:26:10 <johnw> luminos1ty: learning Linux and learning Haskell are pretty well unrelated; since Linux might well be better to put on your resume, you may want to visit #linux
16:26:10 <luminos1ty> besides vim fanboys
16:26:29 <johnw> we really just discuss Haskell here
16:26:39 <luminos1ty> aye but i program in C# on windows, dont want want to do that on linux lol
16:26:46 <luminos1ty> haskell seems good
16:27:05 <johnw> after you've gotten some Linux under your belt, come on back when it's time to write some Haskell code!
16:27:19 <luminos1ty> yeah I should probably learn bash first and stuff
16:27:25 <luminos1ty> for sure thanks good day
16:27:41 <zomg> luminos1ty: as someone who was writing code for like 12 years before haskell, it's one of those things which was actually still interesting and challenging looking at it purely from the view of writing code
16:28:01 <zomg> there's hardly anything that interesting in "just" writing code after doing it for that long =)
16:28:03 <ij> Ok, regex-tdfa does grouping with (pattern =~ text :: [[String]])
16:28:15 <luminos1ty> yeah
16:28:18 <luminos1ty> lol
16:28:53 <luminos1ty> well Im pretty new to it but besides the syntax and being functional, i really really like the idea of late binding
16:29:30 <dmwit> I... don't think Haskell has late binding.
16:29:41 <luminos1ty> lazy evaluation
16:29:42 <luminos1ty> i mean
16:29:45 <luminos1ty> my bad
16:30:20 <Philippa> dmwit: not the easy way, anyway. The strongest argument for first-class modules in haskell is that you can't hide the effects that might be needed to generate one!
16:30:42 <ur_> dmwit: I'll have to digest that code. Very new to haskell. Never heard of {-# LANGUAGE ConstraintKinds #-}
16:31:03 <dmwit> ur_: Oh, it's not actually that fancy. It can be completely removed by just expanding the `C` type synonym.
16:31:11 <dmwit> ur_: I was just lazy and didn't want to type all those classes twice. =P
16:31:34 <dmwit> ur_: (And have an editor macro for inserting extensions with very few keystrokes, so it didn't cost me much to turn that on.)
16:32:17 <ur_> dmwit: Oh I see. So that's what it does
16:35:59 <ertes> i should write some PHP once in a while, just to remind myself how horrible programming can get…  you're mad that String is the default string type?  write some PHP!  it annoys you that Semigroup is not a superclass of Monoid?  write some PHP!
16:39:55 <monochrom> You're mad that you can't just embed Haskell code in HTML files? Write some PHP! :)
16:40:36 <ertes> haha
16:41:42 <Fr4n> I remember a website that you would put some inputs and expected outputs and it would return a function, does anyone know the URL of it?
16:44:51 <edwardk> augur: one side works (ana) with monads and distributive laws the other works with comonads and distributive laws. ultimately the last step is 'removing' the monad or comonad by extracting from it... otherwise literally all you have is a regular cata or ana with the carrier being (m a) or (w a)
16:46:00 <augur> edwardk: im not sure what you mean by the last part
16:47:36 <edwardk> i mean this gana and gcata aren't 'special' they are just ana or cata with a choice of carrier that happens to include a (co)monad. and some games played to make that work by using distributive laws.  then at the end they finally to a return or extract thing to make it work
16:48:05 <edwardk> if you remove that return or extract you just have the ana or cata with carrier (m a) or (w a) instead of 'a'
16:48:20 <edwardk> gana and gcata aren't very interesting as they give you no new extra power
16:48:30 <edwardk> they are just a stylized application of distributive laws
16:52:56 <johnw> edwardk!
17:00:31 <sm> it's true, writing some PHP once in a while is refreshing 
17:01:24 <ertes> Fr4n: there is RIES, but it doesn't quite do what you described
17:02:17 <ertes> Fr4n: are we talking about numeric functions?  or at least functions in some field?  because then you can just use polynomial interpolation
17:03:00 <Fr4n> I remember some examples that used [Int]
17:04:50 <dmwit> I vaguely remember something similar. But I don't remember where it was or what a good search term would be.
17:05:01 <dmwit> I remember thinking it was quite magical.
17:06:13 <dmwit> I think it used some sort of heuristic-driven proof search and was accompanied by a paper that was too dense for me.
17:06:56 <ertes> hmm…  i'm thinking of a class-based approach that seems pretty straightforward
17:21:30 <mankyKitty> quick yesod question, if anyone knows, is there a way to change the response codes, or return JSON instead of HTML when using yesod-auth ?
17:23:29 <Welkin> I had to write my own yesod-auth modules to get it to do what I wanted
17:23:31 <Welkin> it's easy enough
17:23:44 <Welkin> just copy the relevant module and modify it
17:24:50 <mankyKitty> I have a plugin in that does what I want, auths via LDAP, my beef is that with yesod-auth itself, it will return a 200 on failed auth attempts.. did you make your own yesod-auth, or just the authplugin ?
17:25:44 <Guest51804> Hi
17:28:25 <Welkin> my own plugin
17:28:32 <Welkin> I just copied the Email module and modified it
17:29:42 <mankyKitty> so you still return HTML on a failed auth ?
17:29:48 <alexknvl> Can someone point me to a paper about type-aligned sequences?
17:30:39 <alexknvl> Or free categories in Haskell.
17:30:57 <johnw> look for the paper on reflection without remorse
17:30:59 <johnw> it talks about them
17:31:13 <johnw> although that's not entirely what the paper is about
17:32:17 <c_wraith> I mean, they're really any sequence structure that keeps track of the types at its ends, and allows concatenation to change types.
17:32:28 <c_wraith> At the deepest level, they're kind of boring. :)
17:32:31 <alexknvl> Thanks, I'll take a look.
17:34:22 <autopawn> Hello people... Someone there?
17:34:28 <johnw> lots
17:34:39 <autopawn> :D it's my first time here
17:34:48 <c_wraith> only about 1500 people present right now..  Why's the number down?
17:34:49 <johnw> can we help you with learning Haskell?
17:35:06 <alexknvl> c_wraith: Yeah, I just don't understand how to fold them in a type-safe manner without too much pain.
17:35:36 <autopawn> ... the question was for me?
17:35:59 <johnw> autopawn: yes!
17:36:08 <c_wraith> autopawn: the question asking if we could help you with learning haskell was for you.
17:36:20 <autopawn> johnw: oh, thank you
17:36:51 <autopawn> i have learned haskell alone for more than 6 months now
17:37:00 <alexknvl> In a different language than Haskell, so existentials are a pain, type-inference is crap, and escape hatches are sooo easy :P
17:37:26 <autopawn> johnw: but I still finding surprices
17:37:28 <c_wraith> alexknvl: existentials are a pain in haskell, too. :)
17:37:30 <monochrom> existentials are a pain in haskell too
17:37:49 <monochrom> the binary method problem and whatnot
17:37:50 <johnw> autopawn: that part never ends
17:38:47 <autopawn> johnw: hehe, I am here now because I finished a package that I think could be useful for other people
17:38:57 <johnw> autopawn: ooh, I'd like to see it
17:39:28 <autopawn> johnw: :D i this is the repo https://github.com/Autopawn/haskell-secureUDP
17:39:54 <johnw> how do you guarantee receipt?
17:40:16 <autopawn> johnw: it uses ACKs under the hood
17:41:04 <autopawn> johnw: the thing is that i don't know how to "publish" it, if that's how its said
17:41:25 <Koterpillar> autopawn: http://hackage.haskell.org/
17:41:28 <johnw> create an account on hackage.haskell.org, and then "cabal sdist" to make a tarball, and then "cabal upload" it
17:41:35 <johnw> you'll need to put your user/pass into ~/.cabal/config too
17:41:41 <johnw> there should be a document on how to do this somewhere
17:41:47 <johnw> gotta run now though
17:41:53 <Koterpillar> johnw: did cabal fix upload over plain HTTP?
17:42:00 <autopawn> johnw: Oh, okay thank you very much!
17:44:11 <autopawn> also... somebody knows how to document packages, I know that there's haddock and cabal, how both work together?
17:45:04 <c_wraith> autopawn: cabal has a haddock command.  Make your docs look right when you run it that way.
17:45:49 <autopawn> c_wraith: how "look right" ?
17:46:18 <Zefria> So what are the odds that stackage nightly will get on to ghc 802 by the weekend?
17:46:26 <c_wraith> autopawn: if you run "cabal haddock", it will produce output somewhere in the build directory.  Open it up in your favorite browser and make sure everything is rendering the way you want
17:47:13 <autopawn> c_wraith: I see, I will try it, thank you very much.
17:47:45 <qmm> i have this written in a js like language: users = []; while users.length is < desired_length: create more users and add them to the users table... i am only now realizing i don't know what the translation would be into haskell
17:48:09 <Welkin> fold
17:48:13 <c_wraith> qmm: probably something like replicateM
17:48:35 <Zefria> ReplicateM is my vote
17:48:39 <qmm> thanks
17:49:32 <qmm> i don't think it's a good idea to fill the users table up with faux data initially and i can't say let users = [] and then append to it
17:49:43 <qmm> i'm thinking recursion comes in handy
17:50:00 <qmm> user : addMoreUsers
17:50:21 <Welkin> you mean laziness
17:50:22 <Welkin> yes
17:50:26 <Welkin> you can build the list in place
17:50:36 <Welkin> that is what I meant when I said use a fold
17:50:38 <Welkin> right fold
17:50:58 <c_wraith> qmm: you really should look at what replicateM does
17:51:57 <autopawn> c_wraith++
17:51:59 <ertes> OT question: if i generalise an algorithm from some numeric field like ℚ or ℝ to arbitrary fields, would that algorithm still be called "numeric"?  my instinct says: "yes"
17:52:38 <hodapp> I'd say yes too
17:53:02 <c_wraith> qmm: the only way replicateM might not match your description is if your create user action depends on the current list of users.  Then you need something a bit more complex.
17:53:47 <NextHendrix> say i have a list [a, b, c, d, ...]
17:53:58 <NextHendrix> and i need [[a, b], [b, c], [c, d], ...]
17:54:15 <NextHendrix> what black magic can do this transformation
17:54:25 <NextHendrix> been thinking about it for about an hour
17:54:33 <ertes> NextHendrix: tails, then map (take 2)
17:55:15 <ertes> > map (take 2) (tails "abc")
17:55:18 <NextHendrix> gotcha
17:55:18 <lambdabot>  ["ab","bc","c",""]
17:55:23 <NextHendrix> how did you think of that so fast
17:55:49 <c_wraith> You eventually get used to thinking in terms of composing small pieces instead of doing everything in one big piece.
17:55:50 <NextHendrix> or dyou just know the stdlib really well
17:55:54 <ertes> NextHendrix: whenever something involves progressively constructing sublists, i immediately think of either 'tails' or 'iterate (drop n)'
17:57:19 <ertes> > map (take 3) . takeWhile (not . null) . iterate (drop 2) $ [0..]
17:57:21 <lambdabot>  [[0,1,2],[2,3,4],[4,5,6],[6,7,8],[8,9,10],[10,11,12],[12,13,14],[14,15,16],[...
18:11:00 <ertes> instance MonadError IOException IO  -- oh, come on!
18:11:34 <ertes> can't mtl get it right on the first try for a change?
18:12:07 <ertes> why does mtl insist on sucking for error handling?
18:13:10 <nshepperd> you'd prefer if that was SomeException?
18:13:17 <nshepperd> or what
18:13:20 <ertes> of course…
18:15:28 <fragamus> Filesystem.Path.CurrentOS seems to lack constructor
18:15:38 <fragamus> what am I missing
18:15:42 <ertes> if there weren't that equally pointless fundep (m -> e), at least it wouldn't be a problem to add a second instance
18:16:04 <fragamus> I have a String with a path and I want to use this 
18:16:31 <fragamus> I got it nvm
18:19:53 * ertes goes to write some PHP now
18:23:25 <Welkin> ...why
18:36:24 <alexknvl> Is there a name for (forall a . f a -> b)?
18:37:07 <alexknvl> e.g. data F b = F (forall a . f a -> b)
18:37:19 <alexknvl> * data F f b
18:55:55 <orzo> Hey, i was looking at the 8.0.2 release notes, and i noticed there's a change with respect to "defaulting rules" where the example "module Foo where\ndefault (Bool)" is given
18:56:01 <orzo> i'm not familiar with that syntax
18:56:07 <orzo> what's default (Bool) mean there?
18:57:20 <orzo> http://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/8.0.2-notes.html#language
18:57:36 <orzo> the bit about -XExtendedDefaultRules
18:57:51 <glguy> orzo: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
18:59:27 <orzo> thanks
19:05:34 <Profpatsch> If I have DB data types and normal data types, where both are very similar but the DB types are a bit more serialized. 
19:05:35 <Profpatsch> How can I define isomorphisms for these in a clever way?                                                               
19:05:37 <Profpatsch> Right now there’s functions like                                                                                       
19:05:39 <Profpatsch> dbToTask (DBTask tit desc how url recur start) =                                                                       
19:05:41 <Profpatsch>   Task tit desc how (importURL . toS <$> url) recur start                                                              
19:08:46 <orzo> how about a record that is parameterised on the type of url
19:08:59 <orzo> then you could fmap between them
19:09:10 <Axman6> can you a lens Iso?
19:18:59 <codygman> I just cloned the ghc source and did a make/make install
19:19:07 <codygman> I see where ghc is installed, but where is cabal installed by default?
19:19:37 <nitrix> More likely at ~/.cabal/bin/cabal
19:19:41 <athan> codygman: cabal-install is not installed by default, iirc
19:20:08 <codygman> athan: Oh, thanks
19:20:21 <codygman> that makes me wonder how to install it, I'll keep reading wiki Iguess
19:21:26 <excelsiora> hi haskell!
19:21:32 <glguy> codygman: Normally you'd get it when installing the minimal Haskell Platform
19:21:43 <geekosaur> codygman, cabal-install is not part of ghc, only the Cabal library is
19:21:47 <glguy> Otherwise you can download it here http://hackage.haskell.org/package/cabal-install
19:21:56 <glguy> It comes with a "bootstrap" script to get started
19:22:15 <glguy> and I think they have binaries here https://www.haskell.org/cabal/download.html
19:22:54 <excelsiora> Anyone using haskell with emacs orgmode? I'm trying to demonstrate the main (as in `main = putStrLn "hello world") as the entry point to the program, but it's not executing. 
19:23:12 <codygman> glguy: I already have a couple different cabals installed from stack and hvr's ubuntu repo. I'll just use the newest one (1.25).
19:23:31 <codygman> excelsiora: There is a bug in haskell-org
19:24:27 <excelsiora> what's the recommendation?
19:25:31 <codygman> excelsiora: there was last time I tried at least, did you actually add Haskell to the babel list and try executing a code block?
19:26:24 <codygman> excelsiora: Ah, here is the bug with org-mode/haskell-mode (inf-haskell specifically)/babel: https://github.com/haskell/haskell-mode/issues/1429
19:26:28 <excelsiora> codygman: yes
19:26:44 <codygman> excelsiora: Did you get an error? Same or different than the one in the above bug?
19:26:45 <excelsiora> codygman: that's the bug report I've got up 
19:27:01 <codygman> excelsiora: Ah, yeah. I tried debugging it but I'm not so great at elisp
19:28:23 <codygman> excelsiora: Actually I never tried my own final recommendation, the solution they used for ob-go: https://github.com/pope/ob-go/issues/10
19:28:31 <codygman> I also updated my comment on the github issue with that link
19:36:07 <excelsiora> why doesn't prelude like main = putStrLn "hello world"
19:38:27 <Koterpillar> excelsiora: it's a module, it has no feelings. What actually happens?
19:46:33 <c_wraith> excelsiora: that excerpt, out of context, looks correct.  More context is therefore required to answer the question.  Maybe an error message, or the rest of the file, or both on lpaste.net
19:47:43 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
19:48:23 <Rotaerk> is there a name for <*>?  I'd like to make, in nix, something equivalent to Map String (a -> b) -> Map String a -> Map String b
19:48:40 <monochrom> It was called "ap" in Control.Monad
19:48:47 <Rotaerk> ah
19:49:38 <glguy> :t M.intersectionWith
19:49:39 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
19:50:18 <Philippa> yeah, <*> is commonly pronounced "ap" because it's literally why the Applicative in Applicative Functor
19:50:28 <Philippa> it's said Applicative Functor's notion of function application
19:55:37 <Rotaerk> k, thanks; I was thinking something a bit more immature
19:56:27 <monochrom> Darth Vader's Special TIE-Fighter? :)
19:57:00 <Rotaerk> no, if <$> is fmap, then <*> is fap
19:57:19 <monochrom> haha yeah
19:57:19 <Rotaerk> but now that you mention it...
19:57:32 <monochrom> maybe "fapp" looks less worse
19:57:40 <Rotaerk> yea
19:58:24 <monochrom> <$> is Darth Vader's Treasure Ship, obviously :)
20:00:48 <Profpatsch> orzo: Hm, interesting.
20:18:07 <mrbackend> @pl m (a -> b -> c) -> m a -> m b -> m c
20:18:07 <lambdabot> (line 1, column 8):
20:18:07 <lambdabot> unexpected '>'
20:18:07 <lambdabot> expecting operator
20:21:15 <mrbackend> While Monad m => m (a -> b) -> m a -> m b is called ap, does m (a -> b -> c) -> m a -> m b -> m c have a name?
20:21:56 <Xnuk> :t liftM2
20:21:57 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:22:06 <geekosaur> what were you trying to do there?
20:22:24 <geekosaur> @hoogle m (a -> b -> c) -> m a -> m b -> m c
20:22:25 <mrbackend> Xnuk: Not the same
20:22:27 <lambdabot> Data.Function.Pointless ($::) :: (a -> b) -> ((a -> b) -> (c -> d)) -> (c -> d)
20:22:27 <lambdabot> Control.Lens.Iso dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
20:22:27 <lambdabot> Control.Lens.Review bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
20:22:40 <geekosaur> ... that
20:22:50 <geekosaur> s unusually off even for hoogle...
20:23:16 <Xnuk> :t \f a b c -> f <*> a <*> b <*> c
20:23:18 <lambdabot> Applicative f => f (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
20:23:36 <mrbackend> Xnuk better!
20:23:41 <geekosaur> one to omany
20:23:47 <mrbackend> oh
20:25:02 <Xnuk> :t (\f a b -> f <*> a <*> b) :: Monad m => m (a -> b -> c) -> m a -> m b -> m c
20:25:03 <lambdabot> Monad m => m (a -> b -> c) -> m a -> m b -> m c
20:26:44 <mrbackend> Learnt a lot there 
20:27:44 <Xnuk> :t (\f a b -> f `ap` a `ap` b)
20:27:46 <lambdabot> Monad m => m (a1 -> a -> b) -> m a1 -> m a -> m b
20:27:48 <mrbackend> :t liftM3 ($)
20:27:50 <lambdabot> Monad m => m (a -> a3 -> r) -> m a -> m a3 -> m r
20:28:10 <mrbackend> Still doesn't have a name
20:33:58 <geekosaur> so you want it for unspecified m?
20:34:09 <geekosaur> do you have an implementation for this?
20:39:10 <geekosaur> or just a single name for that specific operation? (we don't generally do that unless there's historical precedent for its naming; simple combinators like that are rarely worth naming specifically)
21:02:03 <nitrix> Writing my first GUI application as well as isolating the graphical stuff in its own module.
21:02:11 <nitrix> Does this looks like on I'm the right track:
21:03:33 <nitrix> main = runApp $ App { appTitle = "Foo Bar", appMode = Windowed 800 600, appScenes = [mainMenu], appUpdate = undefined, appRender = undefined }
21:04:18 <EvanR> no events!
21:05:31 <nitrix> EvanR: appUpdate :: Event -> Engine Result
21:05:53 <nitrix> data Result = Continue | Skip | Switch Scene | Bring Scene | Terminate
21:06:19 <EvanR> can scenes be nested
21:06:24 <nitrix> Layered.
21:06:28 <EvanR> ok
21:07:43 <nitrix> Essentially a scene receives a event, process it, and decides weither or not we continue normally, skip and pass the event to the next scene, replace the current scene with a new scene, bring a new scene on top, or terminate the application.
21:08:12 <nitrix> I suppose there should be another result for destroying itself but not terminating the app.
21:08:15 <EvanR> can you have two layers in parallel
21:08:46 <EvanR> think a vertical separation of the screen into two "apps"
21:09:03 <EvanR> each with its own layers
21:10:47 <fragamus> Failed to load interface for ‘Data.HashMap’
21:10:51 <fragamus> WTF
21:11:40 <nitrix> They must receive their events in turn, but I think it's not too limitating. The left side would receive the click event but could ignore it because its out of its boundary then the right side would process the event and make better sense of it.
21:11:41 <fragamus> I have an import for Data.Hashmap in my Turtle script here and it gives me this error
21:12:27 <EvanR> i think that wouldnt work for more complex sides, each with the same complexity as a whole app
21:12:27 <glguy> What package were you hoping had Data.HashMap?
21:12:29 <nitrix> EvanR: Good question though. I'll have to keep this in mind. But back to the original problem statement, I'm just wondering if I'm headed towards more pain by using this form of declarative approach with callbacks.
21:12:45 <glguy> fragamus: unordered-containers don't have such a module, for example
21:12:47 <glguy> doesn't*
21:13:07 <glguy> It has Data.HashMap.Lazy and Data.HashMap.Strict, however
21:13:16 <fragamus> oh
21:24:30 <EvanR> if every finite set has a listing without repetitions, then you have law of excluded middle
21:28:26 <codygman> I have a pretty odd problem I think. I have an inner join function using Vinyl records where the results type is Record (leftRows ++ rightRows). I need to dispatch on the left or right size in order to build an index of the smaller one. The problem is the type variable gets pinned as either "leftRows" or "rightRows". Here is the code/error: https://github.com/codygman/frames-diff/blob/inner-join-fix/Frames/Diff.hs#L113
21:31:17 <codygman> The only way I know to say "this can be two types" is GADTs. I think they'll let me say the type of this function can be  (Record leftRows) || (Record rightRows)
21:34:05 <EvanR> a value can never have two types at the same time
21:35:21 <nshepperd> EvanR: don't finite sets have that by definition? finite ~ "has a bijection to [0..n] for some nat n"
21:35:39 <nshepperd> or something
21:36:02 <codygman> EvanR: So I can't write that then?
21:36:44 <EvanR> the particular definition this case is a surjection from [0..n] to the set
21:37:12 <EvanR> also called a listing
21:37:16 <EvanR> http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/
21:37:55 <EvanR> by making certain finite sets of truth values, you can construct LEM
21:38:31 <EvanR> if they have a listing without reptitions for any finite set
21:41:11 <EvanR> codygman: i have never really used vinyl so not sure
21:41:55 <codygman> EvanR: I have a join working but it doesn't work because it blindly selects the left column... hmm I just thought of a workaround I think.
21:42:06 <nshepperd1> Oh. Well, i think i can construct a bijection from such a surjection, but only if equality on the elements is decidable
21:42:24 <EvanR> yes it gets to that
21:56:24 <codygman> Can anyone explain exactly what this means: (as ++ bs) ~ (bs ++ as)
21:57:07 <c_wraith> codygman: as a constraint?
21:57:48 <codygman> c_wraith: Yeah I was struggling with a problem above where I could return a type level list that was in either order, but I coaxed ghc into giving me that definition. I just don't really understand what it means.
21:58:19 <c_wraith> First, ~ is the type equality constraint.
21:58:37 <c_wraith> (a ~ b) is satisfied when GHC can prove a and b are the same type
22:00:09 <c_wraith> I'm assuming ++ is a type family defined on type-level lists?
22:00:16 <codygman> c_wraith: Yes
22:01:07 <c_wraith> Well, that constraint is satisfied when ghc can prove that it produces the same result when its arguments are flipped.
22:01:18 <codygman> oh, so a and b are the same type because in my case they are both "Records". Before GHC cared about their contents differing but that equality constraint told ghc it's okay because they are both of the "Record" type?
22:01:19 <c_wraith> It's one of those super-painful constraints.
22:01:41 <c_wraith> It's really hard to prove something like that to GHC's satisfaction
22:01:56 <c_wraith> a and b aren't even types in that constraint...
22:02:45 <codygman> c_wraith: Sorry :/ I know I have a kind of inconsistent grasp of these things, I probably shouldn't have been able to trudge my way this far ;)
22:03:16 <c_wraith> I mean, that's not an assertion that's universally true.  It'll only be true of specific types as and bs
22:03:48 <c_wraith> And then, even when it's true, you need to convince GHC that it's true.  That's another level of pain in itself.
22:04:20 <codygman> c_wraith: Ah yes, you are right. My workaround didn't work and I can only do self inner joins
22:04:21 <c_wraith> GHC doesn't do anything smart.  It just tries to expand the type function and sees if they end up in the same place.
22:09:45 <codygman> c_wraith: Yeah I think I need something like multiple return types. I need a function that can do (lefts and rights are type variables): Record lefts -> Record Rights -> Record (lefts | rights)
22:10:29 <c_wraith> codygman: are you trying to get a type-level set?
22:16:29 <saurabhnanda> broadcasting this here: https://www.reddit.com/r/haskell/comments/5noz7g/how_to_deal_with_protected_fields_in_records/
22:17:58 <qmm> all i do is ask questions in here :)
22:18:13 <qmm> when are those with answers going to ask questions? ;)
22:18:18 <qmm> let (ys,zs) = splitAt n xs   in   ys ++ [new_element] ++ zs
22:18:29 <qmm> i'm not really sure how to use that
22:18:32 <qmm> it comes from https://wiki.haskell.org/How_to_work_on_lists
22:18:48 <qmm> > let (ys,zs) = splitAt 3 [1,2,3,4,5,6] in ys ++ [0] ++ zs
22:18:50 <lambdabot>  [1,2,3,0,4,5,6]
22:19:22 <qmm> not really sure how to save the final list returned
22:19:29 <orzo> that's code to insert a new_element a tthe nth position in xs
22:19:41 <c_wraith> qmm: what does "save" mean?
22:19:49 <qmm> c_wraith: good question :)
22:19:52 <orzo> insert new_element xs = let (ys,zs) ...
22:20:02 <qmm> c_wraith:  give it a name
22:20:09 <qmm> orzo: ah
22:20:26 <orzo> hm, probably should pass n too
22:21:58 <qmm> hm, still not seeing how to use this
22:22:14 <c_wraith> qmm: just assign the result to a name.
22:22:27 <qmm> > insert el n xs = splitat n xs in ys ++ el ++ zs   -- go on then, lambdabot, let me know what's wrong
22:22:29 <lambdabot>  <hint>:1:16: error:
22:22:30 <lambdabot>      parse error on input ‘=’
22:22:30 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:22:56 <c_wraith> qmm: lambdabot only handles expressions.  I think you needed a let expression.
22:23:04 <c_wraith> Well, it only handles expressions with >
22:24:01 <c_wraith> qmm: (let [decls] in expr) is an expression in haskell.  It has a value.  that value can be bound to an identifier
22:24:03 <qmm> > let name = let (ys,zs) = splitAt 3 [1,2,3,4,5,6] in ys ++ [0] ++ zs
22:24:05 <lambdabot>  <no location info>: error:
22:24:05 <lambdabot>      not an expression: ‘let name = let (ys,zs) = splitAt 3 [1,2,3,4,5,6] in ...
22:24:14 <geekosaur> heh
22:24:16 <c_wraith> qmm: not enough "in"s
22:24:57 <qmm> name = let (ys,zs) = splitAt 3 [1,2,3,4,5,6] in ys ++ [0] ++ zs -- actually works in ghci
22:25:13 <c_wraith> qmm: because ghci does more than just expressions
22:25:19 <c_wraith> ghci treats that as a decl
22:25:28 <geekosaur> in 8.0.1 and later at least
22:25:39 <geekosaur> in earlier ones you needed let
22:29:12 <codygman> c_wraith: I made it work, but with the caveat that the arguments left and right may not correspond to left and right in the resulting table. I just flip the way I append depending on which type of table was larger
22:30:12 <c_wraith> codygman: a policy like that can work.  Sometimes it gets unwieldy, but if it's functioning, nice work. :)
22:33:25 <codygman> c_wraith: Yeah.... my calling functions will be more complex because of it though. Luckily Frames/Vinyl are good at structural typing and I can just put "contains this column" constraints on calling functions instead of full "types"
22:42:07 <codygman> c_wraith: Yeah, pretty proud of this one :)  ->>>> https://github.com/codygman/frames-diff/blob/master/test/Test.hs#L97
23:39:35 <hololeap> i think i need some helping understanding Traversable
23:40:06 <jle`> hololeap: feel free to ask your question :)
23:41:55 <hololeap> sequence on lists seems to handle permutations and can emulate "counting" if you repeat a list of digits
23:42:30 <hololeap> > sequence $ replicate 2 "0123456789abcdef"
23:42:31 <jle`> that behavior actually comes from the Applicative instance for lists
23:42:32 <lambdabot>  ["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e",...
23:42:37 <jle`> not from the Traversable instance
23:42:47 <jle`> :t sequence
23:42:48 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
23:43:12 <hololeap> from the source code it looks like sequence = traverse id
23:43:13 <jle`> the permutation aspect comes from the Monad/Applicative behavior, actually
23:43:19 <chocopuff> you guys think it's a good idea to map the shift keys to brackets? 
23:43:22 <hololeap> > traverse id $ replicate 2 "0123456789abcdef"
23:43:24 <lambdabot>  ["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e",...
23:44:32 <hololeap> so my question is kind of broad, but i want to know what the traverse function is for, how this instance for lists fits into it, and maybe an example of another instance besides lists (?)
23:49:52 <jle`> hololeap: the 'permutation' behavior you're seeing is actually not from the fact that list is a traversable
23:50:07 <jle`> but from the fact that it's Applicative
23:50:19 <jle`> notice that you used a list in two distinct places there
23:50:39 <jle`> sequence [['0','1'], ['0','1']]
23:51:07 <jle`> hololeap: my favorite motivating example of traversable is Map, from the containers package
23:51:34 <jle`>  let's say you had a Map whose values were IO actions
23:51:43 <jle`> Map String (IO Int)
23:53:04 <hololeap> ok
23:54:29 <jle`> with sequence, you have the ability to execute all of those IO actions (one after the other), and re-assmble them back into the 'same' Map
23:54:40 <jle`> with each key having a result corresponding to the IO action it used to have
23:54:48 <jle`> sequence :: Map String (IO Int) -> IO (Map String Int)
23:55:26 <jle`> that's what the Traversable instance of 'Map k' gets you -- you can sequence all of the actions it "contains", and then collect the results and *preserve the original structure*
23:56:02 <jle`> if you only had Foldable, for instance, you could only do sequence_ :: Map String (IO Int) -> IO ().  you can execute all of the IO actions, but the original structure of the Map is lost forever
23:56:29 <johnw> well, since you know the keys, couldn't you rebuild the map
23:56:36 <jle`> Traversable lets you "sequence together" all of the items contained, and give you the results preserving the structure
23:56:39 <johnw> I guess Foldable doesn't give you the keys
23:56:55 <Xnuk> @hoogle Seq a -> [a]
23:56:56 <lambdabot> Data.Sequence fromList :: [a] -> Seq a
23:56:56 <lambdabot> Data.Edison.Seq.BankersQueue fromList :: [a] -> Seq a
23:56:56 <lambdabot> Data.Edison.Seq.BinaryRandList fromList :: [a] -> Seq a
23:57:11 <hololeap> how does this relate to Applicative? (i also don't have a good grasp of what it and <*> are used for)
23:57:37 <jle`> > sequence (M.fromList [(1,"012"), (2,"012"), (3,"012")])
23:57:40 <lambdabot>  [fromList [(1,'0'),(2,'0'),(3,'0')],fromList [(1,'0'),(2,'0'),(3,'1')],fromL...
23:58:25 <jle`> hololeap: it sequences the actions using the "sequencing" behavior that the Monad/Applicative instance provides
23:58:36 <jle`> for IO, the Applicative/Monad instances say "do this, then that"
23:58:44 <jle`> for lists, the applicative/monad instances say "collect all possible results"
23:59:11 <jle`> for Maybe, it's 'short-circuit when you get Nothing', etc.
23:59:39 <jle`> > sequence (M.fromList [(1,"01"), (2,"01"), (3,"01")])
23:59:42 <lambdabot>  [fromList [(1,'0'),(2,'0'),(3,'0')],fromList [(1,'0'),(2,'0'),(3,'1')],fromL...
