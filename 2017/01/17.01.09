00:00:10 <Lokathor> jle`, "what does imperative state give you in terms of power", the answer is usually "closer to the metal", sadly reasoning doesn't play into it
00:00:56 <jle`> :'(
00:01:21 <Lokathor> i know one person who has specifically said that they want to be able to tell the program each instruction in order
00:01:42 <jle`> like sure i guess?
00:02:00 <jle`> but, there are reasons in haskell why we switch over to imperative program
00:02:02 <jle`> -ming
00:02:13 <jle`> especially for a lot of IO/networked code/scripts
00:02:37 <Lokathor> I recently wanted a function that, given a RandomGenerator, would give back a list of 10 million values
00:02:55 <Lokathor> and I thought, "maybe I should go ahead and write the ST version now and not write the non ST version"
00:03:26 <Lokathor> but that's still stateless... in a sense
00:05:14 <Lokathor> I've been doing Handmade Hero in Rust lately, and I feel like it's closer enough to Haskell than most other languages that it might be a good starting point to take people to
00:06:31 <wespiser> what about using a statistical generator function?
00:06:42 <Lokathor> wespiser, what?
00:07:08 <wespiser> a function that, given a RandomGenerator, gives back a list of N vals
00:07:25 <Lokathor> oh
00:07:30 <wespiser> sorry If I'm off
00:07:33 <wespiser> lol
00:07:53 <wespiser> hold on, I'll find the reference. This seems similar to the statistics stuff I've looked at 
00:08:23 <Lokathor> yeah what I wanted was something like... makePlanetStubs :: RandomGen g => Int -> g -> (Vector.Unboxed (PlanetStub),g)
00:09:08 <Lokathor> where, data PlanetStub = PlanetStub !Float !Float !Word
00:09:55 <Lokathor> and, like, however you fiddle vectors to get a whole thing of compact, strict things. I guess maybe it'd be "type PlanetStub = (Float,Float,Word)"
00:11:05 <wespiser> https://jtobin.io/simple-probabilistic-programming
00:11:19 <wespiser> "> replicateM 1000 (simulate posterior)"
00:11:27 <wespiser> you're entering the world of probabilistic programming
00:12:10 <Lokathor> hmm
00:12:20 <Lokathor> I think not what I want
00:12:40 <Lokathor> i mean, the planets will have random locations, but i don't have a random chance of a planet
00:13:10 <Lokathor> i don't know, i've never heard of a probabilistic program before though
00:13:18 <wespiser> the planets has a probabilistic chance of being at location X
00:13:34 <Lokathor> oh, hmm
00:13:35 <wespiser> it doesn't follow the orbital equations exactly
00:13:47 <wespiser> are you doing this for Kerbal Space Program?
00:14:04 <Lokathor> I'm not doing it for KSP, but it would be for a space game
00:14:26 <wespiser> nice! I did some Haskell w/ Phantom Types for a KSP orbit planner
00:14:49 <Lokathor> This is more like an intersteller adventure type game... i hope
00:15:07 <wespiser> awesome!
00:15:19 <Lokathor> so i'll need to have a galaxy, and then the player is at some place, and they can FTL to other places, so they need to at least know where the other places are
00:15:30 <Lokathor> even if the other places have their real data made later on 
00:15:37 <wespiser> yea, maybe probabilistic isn't the best approach
00:15:52 <wespiser> if you want to do orbital mechanics, a patched conic approach is the way to go
00:16:07 <Lokathor> I don't think the stars will move
00:16:24 <Lokathor> that's just... not a thing i will worry about, even though the game will have some time mechanics
00:16:25 <wespiser> yea, that would be a major waste of time
00:16:39 <wespiser> the time mechanic would be interesting!
00:16:49 <Lokathor> ever read the Hyperion books?
00:16:52 <wespiser> no
00:17:04 <wespiser> do you have a game mechanic in mind that deals with relativity?
00:17:27 <Lokathor> yeah it's like that, basically, at FTL speeds your ship interior goes time X, and the exterior universe goes X+Y, the Y is "time debt"
00:17:42 <Lokathor> but also the trips themselves are long enough to be bothersome, so there's cryo sleep too
00:18:19 <Lokathor> so your "age" can become some totally nonsense thing based on your birthday, time existed, and actual time spent without beigng frozen and stuff
00:18:45 <Lokathor> I'm not sure if it'll make for a fun game, but I wanna give it a try
00:20:03 <Lokathor> lately has been almost 100% handmade hero and rust though
00:20:16 <wespiser> cool
00:20:24 <wespiser> seems like you need a demo to see if its a playable mechanic
00:20:29 <wespiser> I say go for it
00:21:02 <wespiser> don't bet the farm, though
00:21:40 <Lokathor> well, the time debt element and other game elements would all be somewhat orthogonal
01:09:34 <tsahyt> Hello. I've been trying to do a length indexed list for something and I'm in the process of giving it a IsList instance, but the following won't compile: http://lpaste.net/2759787594605658112 Is there some way to write an instance here or do I need to resort to an existential for the length parameter?
01:30:33 <lyxia> tsahyt: either an existential, or overlapping+undecidable instances for "History n a" (n > 0) and "History 0 a".
01:31:06 <tsahyt> hmm, I'll try the second way first. GHC should still be able to compile that I think
01:31:18 <lyxia> but in any case you'll need to annotate every use site with the length you want...
01:31:35 <tsahyt> lyxia: that's okay in my case, the length is statically known
01:31:53 <tsahyt> the use case here is that I have lists of a statically known size, but that is determined by the caller
01:59:25 <jle`> tsahyt: in your case, fromLIst is necessarily partial
01:59:38 <jle`> just because of the type signature
01:59:51 <jle`> fromList :: [a] -> History n a
02:00:09 <jle`> there isn't any way you could implement a function of that type that *isn't* partial, for all a and n
02:00:34 <jle`> what's the error you'r currently getting?
02:10:56 <sphalerite> given f :: (a -> m b), g :: (b -> c), is there a neater way to compose them than (liftM g) . f ?
02:12:45 <merijn> sphalerite: the parentheses are redundant and I'd use fmap instead of liftM, but no, not really
02:13:36 <Insanity_> If any of you are using a "mac"
02:13:39 <Insanity_> What does System.Info output?
02:13:41 <Insanity_> os*
02:13:45 <Insanity_> os in System.Info
02:13:56 <Insanity_> I believe the information there comes from https://github.com/ghc/ghc/blob/master/compiler/utils/Platform.hs
02:14:01 <merijn> Insanity_: "darwin"
02:14:09 <Insanity_> Thanks!
02:14:18 <sphalerite> merijn: oh yeah, makes sense. Thanks!
02:14:37 <merijn> Insanity_: i.e., it just mimics uname :)
02:15:08 <merijn> sphalerite: If you're directly applying 'f' to some 'a' you could do "g <$> f a" (<$> being infix fmap)
02:15:27 <Insanity_> uname? 
02:15:59 <sphalerite> Yeah, I know that. Not helpful in this case though (I think?) because I'm composing the function so I can fmap it over another monad
02:15:59 <merijn> Insanity_: The standard commandline tool for querying kernel/os version on *nix :)
02:16:15 <sphalerite> Or is there a better way to do that? (specifically here, an IO Maybe t)
02:16:18 <Insanity_> Oh okay thanks, did not know that :-)
02:16:29 <merijn> Insanity_: Actually, looks like it's a posix syscall too :)
02:17:13 <merijn> sphalerite: Not really in general, there might be a slightly nicer way in some specific cases, but that's heavily dependent on exactly what you're writing
02:17:45 <sphalerite> ok, thanks!
02:18:16 <sphalerite> Are there any cases where it would make sense to use liftM rather than fmap?
02:18:34 <merijn> sphalerite: Not anymore, it's a historic artefact
02:18:51 <sphalerite> ah ok
02:18:59 <merijn> sphalerite: Up until a few years ago Functor wasn't a superclass of monad, so you couldn't always use fmap without adding a constraint
02:19:40 <merijn> "f :: (Functor m, Monad m) => ...." just to use fmap on your Monad and "liftM :: Monad m => (a -> b) -> m a -> m b" avoided that extra constraint
02:20:03 <merijn> Now that functor is a superclass of Monad liftM and fmap are identical and it's just kept to avoid needlessly breaking existing code
02:24:40 <ski> (well, `liftM' is still useful as a default implementation of `fmap')
02:24:55 <ski> (as is `liftA')
02:25:56 <merijn> ski: Yeah, but that doesn't hold for "users" of those classes :)
02:26:47 <ski> making an instance of a type class is not using it ? ;)
02:27:24 <bwe> Hi, I've installed Decimal. ghci> import Data.Decimal (roundTo)  # Could not find module ‘Data.Decimal’
02:27:49 <bwe> How can I import roundTo?
02:27:55 <ski> sphalerite : "I'm composing the function so I can fmap it over another monad" -- how, more specifically, are you using that composition ? ("there might be a slightly nicer way in some specific cases, but that's heavily dependent on exactly what you're writing")
02:28:54 <sphalerite> Actually it's 3 layers of functors x)
02:29:05 <sphalerite> fmap (fmap locationValue . veLocation)  <$> Map.filter isLecture  <$> vcEvents <$> cal
02:29:43 <ski> (in any case, writing `instance Functor Blah where fmap = liftA -- or `liftM', depending', certainly should be considered as using `liftA')
02:30:15 <sphalerite> lots of Maybes and IOs in there
02:30:40 <sphalerite> cal is an IO VCalendar (VCalendar from Text.ICalendar)
02:31:07 <bwe> okay, reinstalling it via cabal-install did the job.
02:31:19 <bwe> s/-/ /
02:37:42 <ski> sphalerite : and you want a `IO (Map (Text, Maybe (Either Date DateTime)) (Maybe Text))' as result ?
02:38:31 <ski> i suppose you could rewrite the given snippet as `(fmap (fmap locationValue . veLocation) . Map.filter isLecture . vcEvents) <$> cal', should you prefer that
02:39:38 <ski> sphalerite : or perhaps you want to supply some default value (perhaps a call to `error' ?) in the `Nothing' case ? or perhaps you want to get a `IO (Maybe (Map (...) Text))' back instead ?
02:39:47 <ski> these are just guesses
02:40:19 <sphalerite> I just want something to look at from ghci for now :D
02:40:24 <sphalerite> so anything goes really
02:41:04 <ski> this is a bit fun, didn't realize it before :
02:41:06 <ski> @type \f g x -> f <$> (g <$> x)
02:41:08 <lambdabot> Functor f => (a -> b) -> (a1 -> a) -> f a1 -> f b
02:41:13 <ski> @type \f g x -> (f <$> g) <$> x
02:41:15 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
02:42:20 <ski> (any particular reason why `<$>' was chosen to be left-associative ?)
02:43:03 <feuerbach> to work nicely with <*>
02:43:35 <feuerbach> f <$> a <*> b = (f <$> a) <*> b
02:43:45 <feuerbach> both are infixl 4
02:46:25 <ski> hm, right .. i think i noticed that detail of associativity rules, but haven't understood why it should be necessary
02:46:27 <sphalerite> I don't like the type of recurUntilCount here https://hackage.haskell.org/package/iCalendar-0.4.0.3/docs/Text-ICalendar-Types.html#t:Recur :(
02:47:28 <ski> iow, why is `<$>' required to be left-associative there (rather than also allowing non-associative) ?
02:47:53 <ski> (of course `<*>' has to be left-associative)
02:48:33 <feuerbach> it could be non-assoc, but then it should have higher priority than <*>
02:49:22 <ski> why should that be necessary ?
02:49:49 <ski> (i'm asking for a rationale of the rules, not asking for what the rules are)
02:50:21 <feuerbach> what would be the alternative?
02:50:23 <merijn> ski: because you need to turn the left side of the first <*> into "f (a -> b)" before <*> can be applied
02:50:40 <merijn> ski: Thus the initial <$> application has to bind tighter than <*>
02:50:47 <merijn> Else it's a type error
02:51:30 <feuerbach> you have a `op` b `op` c (where `op`s are potentially different ops of the same priority). Unless they are associative in the same way, you don't know how to put parentheses
02:51:41 <Gurkenglas> Then why don't we have <$> binding more strongly than <*>? Using <*> to the left of <$> makes sense sometimes
02:51:42 <merijn> "f <$> a <*> b <*> c" <- here "a <*> b" is nonsensical without first doing "f <$> a"
02:52:13 <ski> merijn : i'm asking for why `f <$> a <*> b' meaning `(f <$> a) <*> b' requires `<$>' (and not just `<*>') to be left-associative
02:52:18 <merijn> Gurkenglas: Having them at the same precedence makes it easier to read code (less precedence to remember)
02:52:56 <ski> (i just checked in Prolog, as i expected, this is not required with the operator parsing there)
02:53:55 <ski> (obviously `<$>' couldn't be *right*-associative here. but i don't see why it's not allowed to be *non*-associative (as indeed Prolog allows))
02:55:34 <feuerbach> ski: does my explanation above not make sense?
02:56:13 <ski> feuerbach : i don't see why the requirement has to be as strict as "they are associative in the same way"
02:56:31 <ski> why not just "they don't have conflicting associativities" ?
02:56:54 <feuerbach> let's say (+) and (-) are both infix 6 (non-assoc). How would you parse 10-6+5?
02:57:10 <ski> ("what would be the alternative?" -- i hope i clarified it above)
02:57:13 <Gurkenglas> ski, don't you need operators of the same precedence to have their fixity defined in the same fixity declaration to be able to combine them?
02:58:29 <Gurkenglas> Scratch that, "infixl 4 <*>, <*, *>, <**>" ( http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#%3C%2A%3E )
02:58:36 <ski> feuerbach : that case would be invalid. but pick `+' as left-associative, and i think it should be `(10 - 6) + 5'. or pick instead `-' as right-associative, and i think it should be `10 - (6 + 5)'
02:59:02 <ski> Gurkenglas : "don't you need operators ..." -- not afaik ?
03:00:25 <ski> (so one would also have to get a definite "association" to prefer, which is why `infix'/`infix' doesn't work)
03:03:42 <ski> (ftr, i think there may be some general parsing principle which may disallow / advice away from allowing the loosening of the parsing rules that i'm proposing here (and which Prolog apparently adopted). but i don't know what it is, would be interested to know)
03:07:37 <ski> (a parsing principle akin to e.g. "operator precedence must be transitive" as exemplified as if `a o b p c q d' is parsed as `a o (b p (c q d))', then `a o bc q d' must be parsed as `a o (bc q d)', where `o',`p',`q' are infix operators, and `a',`b',`bc',`c',`d' are atomic expressions)
03:08:34 <feuerbach> so why does left-assoc of (+) imply (10-6)+5? it is just as consistent with 10-(6+5)
03:09:35 <feuerbach> e.g. 10-1+2+3 would be 10-((1+2)+3). (+) is still left-assoc here
03:10:27 <feuerbach> I have a hard time "parsing" your parsing principle..
03:13:56 <mfukar> feuerbach , seems to me it follows from the definition of left-associativity. Your second example implies + and - have different precedence, otherwise 10-1+2+3 would be parsed as ((10-1)+2)+3, right?
03:15:20 <feuerbach> mfukar, well, your parse implies that - have higher precedence
03:15:37 <feuerbach> just as mine implies that it has lower precedence
03:15:42 <mfukar> No, it implies - and + have the same precedence and are left-associative
03:15:55 <feuerbach> but we're discussing the case where - is not left-associative
03:16:12 <feuerbach> in reality, yes, they are both infixl
03:16:38 <mfukar> must've missed that, ok
03:17:03 <mfukar> ignore my drivel :)
03:17:41 <ski> "so why does left-assoc of (+) imply (10-6)+5? it is just as consistent with 10-(6+5)" -- good point
03:20:00 <ski> (but i don't follow "e.g. 10-1+2+3 would be 10-((1+2)+3).". it would be just as consistent with `(10 - (1 + 2)) + 3' and with `((10 - 1) + 2) + 3', then, no ?)
03:21:22 <feuerbach> I suppose? It's a hypothetical parsing rule that I don't understand either
03:21:37 <feuerbach> Basically, there are two ways to treat associativity:
03:21:56 <feuerbach> In mathematics, it only applies to the same operator
03:22:17 <feuerbach> so if (+) is left-assoc, 1+2+3 means 1+(2+3)
03:22:29 <feuerbach> err, the other way around
03:22:43 <feuerbach> but it doesn't say anything about different ops
03:23:03 <feuerbach> in Haskell, all ops with the same precedence are treated as the same operator
03:23:07 <feuerbach> so they all can be associated
03:23:22 <feuerbach> but in order to know how to associate them, they all have to agree
03:23:34 <feuerbach> so that we can really treat them as the same kind of operator
03:23:48 <feuerbach> you're proposing some mixed model
03:23:58 <feuerbach> where some operators are associative, some are not
03:24:08 <ski> "they all have to agree", yes, but not in Prolog, which got me wondering about the whys
03:24:10 <feuerbach> but the parser can still associate them to some limited extent
03:24:48 <feuerbach> maybe it can work, idk
03:24:54 <ski> i'm using two different models, here. one operational, based on parsing levels (which is what Prolog also is using), but which is asymmetric, not necessarily good to use as a basis
03:25:30 <feuerbach> but the principle is, if something is declared infix (non-assoc), you shouldn't try to associate it with other stuff
03:25:39 <feuerbach> (you = the parser)
03:25:53 <ski> (iiuc, this is what you automatically get, if you don't make adjustments, when using the precedence level as used with `showsPrec' and `readsPrec')
03:26:12 <ski> well, what does "associate it with other stuff" even mean ?
03:26:24 <feuerbach> means figure out how to place parens
03:26:36 <ski> the other, more declarative, specifying for each pair of infix operators `p' and `q', given atomic expressions `a',`b',`c', whether `a p b q c' ought to be parsed as `(a p b) q c' (symbolized as `p L q') or as `a p (b q c)' (symbolized as `p R q'), or not allowed
03:27:48 <ski> (then the rule "operator precedence must be transitive" simply says that `p L q /\ q L r => p L r' and `p R q /\ q R r => p R r' -- that's not quite the whole story, but it'll serve as a first approximation of what i had in mind, i hope)
03:28:29 <ski> (so `L' and `R' must be disjoint binary relations)
03:30:30 <ski> (but not necessarily covering all possibilities together : there can be combinations of `p',`q', where `a p b q c' is simply not allowed -- this would correspond to the non-associative case)
03:34:42 <lpaste> bwe pasted “Type annotation issue” at http://lpaste.net/425800613889048576
03:34:59 <tabaqui1> https://hackage.haskell.org/package/network-2.6.3.1/docs/Network-Socket.html#t:SockAddr
03:35:11 <tabaqui1> SockAddr type is deriving from Ord
03:35:22 <tabaqui1> but how? where can I found rules for standard derivations?
03:35:33 <tabaqui1> and how can I write rules for my own classes?
03:35:34 <ski> (however, what i appear to be realizing is that the `not (p L q) /\ not (p R q)' case doesn't map bijectively to the non-associative `infix' specification (as in Haskell). one is about the relation between two operators; the other is about a single operator, and would have to be mapped to the former version by deciding how to map mixed cases like `infix'/`infixl' of `p' resp. `q', i think .. hmm)
03:36:33 <ski> feuerbach : clearly i'll need to think this over more, before (possibly) being able to say something useful. ty for the comments,feedback,opinion,skepticism
03:38:44 <bwe> Can someone give me a hint how to correctly annotate the type I want? I am not sure whether Rational is right. I don't want decimals, I want fractions for precision.
03:39:19 <bwe> Oh, I missed the most important part: The please (in particular for the British.)
03:42:19 <merijn> bwe: Rational is fractions
03:42:33 <merijn> > 1 % 3 + 2 % 3
03:42:36 <lambdabot>  1 % 1
03:42:46 <merijn> :t (%)
03:42:48 <lambdabot> Integral a => a -> a -> Ratio a
03:42:58 <merijn> Rational is just "Ratio Integer"
03:43:32 <merijn> > 1 % 3 / 3
03:43:35 <lambdabot>  1 % 9
03:46:18 <ski> bwe : why do you `fromIntegral' the elements of `causes' (note `count' is already the result of a `fromIntegral' call)
03:46:48 <ski> (also `total' and `sorted' are unused, presumably you haven't got around to using them yet)
03:47:27 <ski> bwe : do you have `NoMonomorphismRestriction' enabled ?
03:48:01 <bwe> ski: Afaik not.
03:48:27 <bwe> ski: The function is not complete yet, therefore sorted and total are not used yet.
03:49:07 <ski> btw, both `Rational' and `Double' is an instance of `Fractional'
03:49:51 <ski> i'm not sure, but perhaps the DMR is an issue in this case
03:50:19 <bwe> ski: So, how can I resolve the ambiguity? [Rational] shoulb de returned.
03:50:26 <merijn> ski: That should have a pretty unambiguous error message, though?
03:50:41 <merijn> I missed the code/error, though
03:52:10 <tabaqui1> I'm back
03:52:17 <tabaqui1> did I miss something?
03:54:08 <ski> bwe : "[Rational] shoulb de returned." -- then replace `[b]' in the type signature with `[Rational]' (and drop the constraints on `b') ?
04:03:11 <maerwald> it seems there is no complete sql parser written in haskell is there?
04:04:17 <merijn> Maybe? Also depends on the SQL dialect, I suppose?
04:20:25 <bwe> ski: Alright! That's a simple solution. Thanks.
04:36:33 <Athas> I am looking for a function that takes every N'th element of a list.  Any suggestions?
04:36:45 <Athas> (I can write it easily enough; I'm looking for a fun/clever version.)
04:50:13 <jeltsch> Athas: How about this:
04:50:18 <jeltsch> > let f n = map snd . filter ((==) 0 . flip mod n . fst) . zip [0 ..]
04:50:20 <lambdabot>  <no location info>: error:
04:50:20 <lambdabot>      not an expression: ‘let f n = map snd . filter ((==) 0 . flip mod n . fs...
04:50:59 <Athas> jeltsch: Ooh, nice.  I like that.  I had this myself:
04:50:59 <Athas> stride n s = concatMap (take 1) . take n . iterate (drop s)
04:50:59 <Athas> But your version is nicer.
04:52:17 <jeltsch> Athas: Actually, I was looking for something like your solution first, but unfortunately tried to use splitAt instead of drop.
04:52:37 <Athas> jeltsch: my solution behaves poorly on finite list, which yours does not.
04:53:18 <Athas> And filter is cheap in Haskell, which is nice (usually my intuition is that it's slow).
04:53:55 <solarus> > ((.) . (.)) (map head . takeWhile (not . null)) (iterate . drop) 5 [0..100]
04:53:56 <merijn> Filter isn't cheap, in most cases it's just trivially amortised with whatever final iteration you end up doing
04:53:58 <lambdabot>  [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
04:54:33 <Athas> merijn: it's cheap compared to the parallel settings I'm used to.
04:55:13 <jeltsch> Athas: I see. You probably should add something like takeWhile (not . null).
04:55:20 <solarus> ^ is cleaner with .: defined :)
04:55:54 <Athas> jeltsch: nah, I think your filter solution is cleaner anyway.
04:56:13 <Athas> No subtle tricks, and no partial functions.
04:56:16 <jeltsch> Athas: And I would use map head instead of concatMap (take 1).
04:56:51 <Athas> That was a trick to avoid diverging on unexpectedly short input lists.
04:57:25 <jeltsch> Athas: I think with concatMap (take 1) you still diverge.
04:57:31 <maerwald> I'd use zipWith and a second infinite list (e.g. with Maybe) to indicate which elements to pick
04:58:06 <jeltsch> Athas: You actually diverge more (the whole remaining list is undefined). Note that nontermination is also diverging.
04:58:30 <Athas> jeltsch: under which circumstances?
04:58:40 <ertes> Athas: mod is probably the slowest part of it
04:58:43 <jeltsch> Athas: Let’s try:
04:58:50 <ertes> Athas: i like your initial solution best
04:59:48 <jeltsch> Athas: Okay, you “diverge more” when using lists ending with infinitely many empty lists.
05:00:23 <jeltsch> In any case, you should stop if you encounter the first empty list; therefore my takeWile (not . null) recommendation.
05:01:22 <ertes> > (\n -> map head . unfoldr (\xs -> guard (not (null xs)) >> pure (splitAt n xs))) 3 [0..9]
05:01:25 <lambdabot>  [0,3,6,9]
05:03:25 <ertes> :t first
05:03:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
05:03:34 <ertes> :t Data.Bifunctor.first
05:03:35 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
05:03:54 <ertes> > (\n -> map head . unfoldr (\xs -> guard (not (null xs)) >> pure (Data.Bifunctor.first head (splitAt n xs)))) 3 [0..9]
05:03:57 <lambdabot>  error:
05:03:57 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
05:03:57 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
05:04:16 <ertes> @let import qualified Data.Bifunctor as Bi
05:04:18 <lambdabot>  Defined.
05:04:24 <ertes> > (\n -> unfoldr (\xs -> guard (not (null xs)) >> pure (Bi.first head (splitAt n xs)))) 3 [0..9]
05:04:26 <lambdabot>  [0,3,6,9]
05:04:31 <ertes> i like this one best
05:06:47 <Athas> It's a little too complicated for my uses.
05:06:57 <maerwald> Last time I heard someone say errno is not thread-safe... from a POSIX perspective, that is wrong. Does GHC do some hackery here that breaks it?
05:09:17 <ertes> maerwald: something sets errno, time goes by, you read errno…  now let multiple threads do that
05:09:37 <maerwald> errno is thread-specific
05:09:47 <maerwald> see https://stackoverflow.com/questions/1694164/is-errno-thread-safe
05:09:51 <implementation_> but OS threads != Haskell threads
05:09:53 <ertes> maerwald: OS-thread-specific
05:10:00 <ertes> not haskell-thread-specific
05:10:09 <maerwald> so GHC breaks errno
05:10:23 <ertes> haskell threads break errno
05:10:46 <maerwald> I'm still not sure if that's really true
05:11:00 <implementation_> you could use it in a "bound" thread
05:11:20 <ertes> a bound thread doesn't help here…  there is still the gap between writing and reading
05:11:49 <ertes> maerwald: i'd use errno in a critical section that includes the action that sets it and the action that reads it
05:12:24 <maerwald> another reason not to use haskell for system programming
05:12:54 <merijn> implementation_: bound threads don't rule out other haskell threads getting scheduled on the bound thread
05:13:28 <implementation_> merijn: thanks for clarification
05:14:20 <ertes> maerwald: errno is just a poor concept…  systems programming in any modern language will require workarounds for the braindamaged design of POSIX
05:14:32 <maerwald> errno is perfectly well defined
05:14:50 <ertes> it's still a poor concept introduced only to work around the limitations of C
05:15:08 <ertes> C doesn't have Either
05:16:15 <emc2> errno is an error reporting mechanism designed to communicate across the kernel-user boundary.  It will persist in any system because of this
05:16:28 <maerwald> I want well-defined behavior in system programming and not have to think about what weird stuff GHC or its RTS does and where it breaks POSIX
05:17:04 <maerwald> it's difficult enough to reason about things on that level, another layer of weirdness doesn't make it better
05:18:35 <Athas> If you're using a virtual machine (which any high level language really is), then you'll have trouble when you try to reach through and touch the layer beneath.
05:19:41 <maerwald> I don't think this is related to high-level language as much as it might seem. It's rather specific to GHC and the way it deals with threads
05:19:53 <maerwald> (or emulates them)
05:20:00 <ertes> maerwald: have fun with C then…  POSIX is mostly well defined for C =)
05:20:03 <Athas> Pretty sure you'd see the same in Go or Erlang or any other language that uses green threads.
05:20:30 <hpc> you know your abstraction is brittle when go is too high-level for it
05:20:30 <maerwald> that's is a smaller set than "high-level language"
05:20:53 <maerwald> unless you assume all high-level languages have green threads
05:21:21 <ertes> Q: what's a high-level language? A: a language is high-level if it's not C =)
05:21:36 <Athas> Not at all, but other high-level languages probably make other things confusing (although errno is unusually easy to clobber by runtime systems).
05:21:50 <Athas> I mean, it doesn't take more than a GC at an inopportune time.  Most likely the GC will call something that sets errno.
05:22:04 <ertes> Athas: that's actually rather unlikely
05:22:19 <maerwald> that would be funny though
05:22:21 <Athas> ertes: mmap() sets errno.
05:22:29 <ertes> Athas: you use mmap() for GC?
05:22:45 <Athas> It may be necessary.
05:22:49 <Athas> Maybe there are some locks, too.
05:22:59 <ertes> hmm…  finalizers might set errno
05:23:07 <Athas> Futexes set errno too, I think.
05:23:29 <ertes> ok…  errno is broken by languages that are…  uhm…  not C =)
05:23:34 <ertes> perhaps fortran might work =)
05:23:35 <maerwald> that's wrong
05:23:37 <merijn> ertes: Many gc's use mmap instead of sbrk nowadays
05:23:49 <ertes> merijn: ah
05:23:53 <merijn> ertes: More control
05:23:58 <ertes> yeah, i see
05:24:00 <Athas> Does _anyone_ use sbrk anymore?
05:24:08 <merijn> sbrk can only free at the top of the virtual stack, mmap can free anything
05:24:18 <Athas> Pretty sure sbrk() is implemented through mmap() anyway.
05:24:24 <merijn> Athas: Probably
05:24:48 <merijn> Although, to be fair, sbrk apparently also sets errno, so...
05:25:04 <ertes> so GC needs to restore errno
05:25:27 <merijn> Pretty sure you can clobber errno with a signal handler too?
05:25:44 <Athas> ertes: only if the language wants to permit you to punch through the abstraction barrier!
05:25:57 <ertes> merijn: as far as i know the signal handler in haskell doesn't do much…  it just throws an async exception at the main thread
05:26:09 <Athas> I probably wouldn't want to expose errno in a high level language.  It's way too fragile.
05:26:14 <ertes> at least the default
05:26:53 <maerwald> Athas: you mean in a language where the GC is not isolated and messes with random stuff :P
05:27:04 <merijn> ertes: Sure, I just meant that non haskell stuff breaks it too
05:27:19 <ertes> Athas: yeah, it's a C-ism…  it should have gone away in the 70s when real programming languages came along…  but C was there to stay
05:27:27 <Athas> maerwald: pretty much.  Any language where the runtime is complicated enough for errno to essentially be a random variable.
05:27:45 <Athas> Maybe you can use errno by sampling!
05:28:19 <Athas> if prob(errno == EPIE) > 0.95 then ...
05:28:34 <ertes> hahaha
05:28:40 <maerwald> even simpler: I'll switch to a language for the subset of the problem that doesn't randomly break POSIX guarantees (and doesn't even seem to document that fact)
05:29:01 <Athas> Good idea.  Haskell has a great FFI anyway.
05:29:19 <ertes> have fun finding such a language that isn't C =)
05:29:26 <maerwald> there are plenty
05:29:39 <merijn> maerwald: oh, name one other than C++?
05:29:52 <maerwald> D
05:29:55 <ertes> well, FORTRAN maybe =)
05:30:12 <merijn> ertes: tbh, I'd rather write FORTRAN than C...
05:30:15 <Athas> Rust!
05:30:18 <maerwald> that too
05:30:22 <Athas> Pascal.
05:30:27 <maerwald> go away :P
05:30:46 <Athas> I have a friend who is employed as a Delphi programmer.
05:30:50 <Athas> I wonder how long it takes him to commute to the 90s.
05:30:54 <maerwald> it was actually my first language
05:31:09 <maerwald> anyway... 
05:31:40 <ertes> beware…  if a delphi bites you, you might turn into a delphi, too
05:31:53 <ertes> watch out for cobols, too
05:32:52 <Ferdirand> I just had an epiphany regarding free monads
05:33:12 <ertes> Ferdirand: you loved them all along?
05:33:27 <merijn> Ferdirand: The free monad was inside you all along?
05:33:32 <maerwald> ertes: with cobol you get amazing payment at least, because not many people are up to that sort of pain
05:33:43 <Ferdirand> merijn: yes, exactly
05:33:56 <ertes> maerwald: i seriously considered learning it for that particular reason
05:34:10 <Ferdirand> actually i never found any explanation satisfactory
05:34:38 <Ferdirand> then I just looked at the datatype definition for Free, and tried to implement Applicative for it
05:34:41 <Ferdirand> that was baffling
05:34:50 <Ferdirand> then I went to implement Monad
05:34:58 <Ferdirand> and it dawned on me
05:35:35 <ertes> Ferdirand: now learn the church-encoded version =)
05:36:10 <Ferdirand> ertes: that sounds like some lovecraftian horror concept
05:37:02 <ertes> Ferdirand: it's fairly simple once you get the idea that the iteration/recursion is *embedded* in the encoding itself
05:37:18 <ertes> Ferdirand: type List a = forall r. (a -> r -> r) -> r -> r
05:37:30 <ertes> encode a list by its fold
05:37:44 <maerwald> ertes: I'm sure the first thing you'd do is to reinvent Monads in cobol :P
05:38:17 <maerwald> oh dear, what a scary though
05:38:22 <maerwald> *thought
05:38:27 <Ferdirand> ertes: oh. church-encoding of lists, I can grok
05:38:56 <Ferdirand> church-encoding of free monads, i sorta see the parallel but I cannot honestly say i have a good intuition of it
05:39:23 <ertes> maerwald: i'd more likely find a way to compile to cobol
05:41:01 <ertes> Ferdirand: freeFold :: (a -> r) -> (f r -> r) -> Free f a -> r
05:41:09 <ertes> Ferdirand: it's exactly the same idea
05:41:41 <ertes> Ferdirand: (note: the predefined foldFree function in the 'free' package is *not* the Free fold)
05:44:48 <merijn> I need some recommendation for a library for dealing with/scraping XML. I've used xml-conduit so far, which is kinda ok, but the API makes some things I want to do rather annoying. For example, trying to map the XML to a list of objects
05:45:26 <merijn> Any recommended libraries/personal favourites?
05:48:12 <ertes> Ferdirand: BTW, now you might also see why Free ((,) a) () ≃ [a]
05:48:36 <ertes> foldFree :: (() -> r) -> ((a, r) -> r) -> Free ((,) a) () -> r
05:48:39 <ertes> it's just foldr =)
05:54:30 <merijn> No one?
05:55:15 <ertes> merijn: would xml-lens help you?  it provides traversals into XML
05:56:21 <merijn> ertes: I don't know? ;)
05:58:52 <ertes> it would be nice for use cases like this to have an automatic way to go from A ≃ Fix F to F (Fix F)…  then we could map and fold F
05:58:57 <merijn> I basically have a structure that has some specific tags that should occur exactly ones and some that are basically lists of any length and I want to convert that into a record datatype, but xml-conduit only returns lists from it's axes, which means it's hard to enforce the presence of required tags and also hard to "map" another axis over a sub part
05:59:41 <ertes> ah
05:59:58 <Athas> So, when would you say it's OK to ditch support for GHC 7.8 (pre-AMP) in my code?
06:00:29 <ertes> Athas: i already ditched it
06:01:13 <lordcirth> Depends who's going to be compiling it
06:01:42 <Athas> It's not even a library, and I guess everyone except Travis is using the default stack.yaml, which uses GHC 8.0.1.
06:01:46 <merijn> Athas: For my research code I only support "whatever version I have installed", so it depend son your expected users?
06:01:57 <ertes> Athas: if you're working on a program, it's pretty much up to you…  i see no reason to be compatible even to < 8 at all
06:02:03 <merijn> Athas: Basically, do you care about other people running your code? :p
06:02:18 <Athas> Of course I do!  But they can just install a newer compiler, I guess.
06:02:21 <ertes> Athas: for libraries it's a different story…  i generally support the last major version of GHC as well as the current one, so:  7.10 and 8.0
06:02:50 <merijn> Athas: Ok, lemme rephrase: "Do you care about people in restricted environments who can't don't want to install newer compilers?"
06:03:09 <Athas> I see 53 commits where I fix accidental breakage of GHC 7.8.
06:03:11 <Insanity_> Athas: You are lucky enough to assume smart users then :p 
06:03:33 <Athas> Insanity_: I tell my users 'stack setup && stack install'.  Doesn't require smarts!
06:04:10 <Insanity_> We have some users that pretty much say "nope" as soon as they would encounter an operator like that :p
06:04:45 <Athas> I have prebuilt tarballs for people who can only manage a 'make'.  But all my "users" are graduate students for now, so they'll manage (they have no choice).
06:05:37 <merijn> Athas: Man, if your code actually builds you're already exceeding expectations for grad students :p
06:05:48 <ertes> maintaining one's local packages is a skill every programmer should master…  i would almost say: force them to use GHC 8 =)
06:06:02 <Insanity_> Different users than here. I work in a hospital and you need to learn to expect _nothing_ from the users here :P 
06:11:29 <maerwald> hence the nick...
06:36:31 <markus1199> i~.i
06:37:52 <markus1199> sorry that was an accident and not a new lens operator ;) 
06:44:42 <grazie> sm: does hledger support hledger-web for mac? on the download page, I only see `brew install hledger`
06:45:07 <grazie> whereas `sudo apt install hledger hledger-ui hledger-web`
07:02:41 <sm> hi grazie.. we just need someone to work on that package. For now, you'll have to build hledger-web with stack/cabal on mac
07:02:53 <sm> s/package/recipe/
07:04:50 <osa1> I'm looking for a library that allows me to define SQL tables (not from Haskell types, but directly) and run type-safe queries (including joins etc. the more complete the better). does such a library exist? I looked at persistent but I disliked the quoter syntax (not documented!) and I don't want to define Haskell types. I'll write any convertions from my types to table types manually.
07:05:00 <grazie> sm: thank you, I thought it might have been left out because not compatible with mac for some reason
07:06:59 <EvanR> osa1: theres *sql-simple
07:07:58 <osa1> EvanR: I'm already using sqlite-simple, it doesn't do what I described
07:08:28 <osa1> EvanR: I want to define tables and get type-safe queries
07:08:40 <EvanR> i dont really understand your two requirements 
07:08:59 <EvanR> define tables, type-safe, without types
07:09:24 <Ferdirand> you want the schema to be statically baked into your application ?
07:09:50 <osa1> Ferdirand: yes
07:09:55 <EvanR> but without haskell types
07:10:23 <EvanR> what sort of data is returned to you without it being haskell types
07:10:33 <osa1> EvanR: I mean something like persistent except I don't want to use Haskell types, I want SQL types (I'm using SQLite) and corresponding Haskell types
07:11:17 <EvanR> the rows returned to you with mysql-simple and similar is a vector of "FromSQL" values
07:11:33 <EvanR> which can be converted to haskell in different ways
07:11:53 <EvanR> thats as far away from haskell types i can think of
07:12:35 <EvanR> i wouldnt call that type safe. but i still am not sure what your thing would look like
07:12:41 <Cale> osa1: Yeah, for that, I would use sqlite-simple -- I've used postgresql-simple, and it's good at the stuff that it does.
07:12:51 <osa1> ohh I think opaleye-sqlite is what I need
07:13:33 <maerwald> I really wish we had a complete set of SQL parser combinators. I started to write a sublanguage of SQL, but it's still awfully complex, especially to get character sets etc right.
07:13:39 <Cale> opaleye has the annoying property of requiring all your record fields to be abstracted as type variables, though maybe that's not a problem for you
07:16:20 <osa1> "All the magic that typeclasses do is
07:16:22 <osa1> also available by explicitly passing in the "typeclass dictionary"" FINALLY
07:16:30 <osa1> I hate it when libraries don't do this
07:16:32 <Cale> hm?
07:16:44 <osa1> that's from the opaleye tutorial
07:16:47 <Cale> ah
07:17:01 <Cale> There are so many DB libraries and none of them I've found so far has really made me happy.
07:17:16 <osa1> so far I feel the same
07:17:22 <Cale> Currently we're using a combination of Groundhog and postgresql-simple
07:17:29 <Cale> and it works, but it's not really ideal in any way
07:18:18 <Cale> Groundhog for its ability to do the most trivial migrations automatically, and be somewhat type safe regarding generating the queries.
07:18:20 <osa1> I started implementing our storage layer in sqlite-simple today and the boilerplate I had to write is ridiculous and I haven't even finished half of the queries we need
07:18:51 <Cale> But Groundhog can't do JOINs and its support for raw queries isn't so nice, so you end up wanting something a bit different.
07:19:39 <Cale> The main problem whenever we use postgresql-simple is that syntax errors in the SQL are runtime errors.
07:19:52 <Cale> (also, many other things you'd hope would be type errors)
07:20:00 <osa1> also, I have to test even the simplest queries because they're basically formed of strings so there's a lot of room for runtime errors
07:20:04 <Cale> yeah
07:20:05 <osa1> yeah
07:20:08 <osa1> heh
07:20:08 <Cale> exactly
07:20:24 <Cale> So, when we *can* use Groundhog, we tend to do so.
07:20:28 <EvanR> haskelldb ?
07:20:58 <osa1> and I have no idea how to maintain this mess -- a simple change in a table means changes in dozens of strings...
07:22:00 <EvanR> when you be explicit about fields in the query, they are more resistant to changes in the table
07:22:11 <EvanR> basic sql tips
07:23:32 <osa1> I'll try groundhog and opaleye tomorrow and see how it goes. hopefully in the long run the time I'll waste will pay off :-)
07:23:52 <Cale> Groundhog has most of the same problems as persistent
07:24:17 <osa1> any ideas on opaleye?
07:24:27 <ct_j> Hoping someone here could help me with this query. My CS lecturer mentioned it but didn't explain how it works
07:24:34 <ct_j> If I define a function sum3 which sums 3 integers, so that "sum3 1 2 3" = 6, why am I able to do "(sum3 1) 2 3" or "(sum3 1 2) 3"?
07:25:24 <Cale> I didn't look very carefully at Opaleye, but Ryan pointed out to me that it seems to require you to define all your record types in an annoying style where you never actually say what the type of any of the fields are, you leave that up to type parameters, which you later fill in with the concrete types.
07:25:55 <ct_j> Seems like the function would only have 1 or 2 arguments respectively in those 2 examples when it expects 3 arguments, but clearly it's getting all 3 even though they're outside the brackets
07:25:56 <mettekou> ct_j: Because functions are curried in Haskell: they take a single argument and return a function.
07:26:12 <mettekou> > :t (+ 1)
07:26:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:26:21 <mettekou> :t (+ 1)
07:26:22 <lambdabot> Num a => a -> a
07:26:31 <osa1> OK, I guess I'll see how bad it is. thanks Cale
07:26:48 <mettekou> ct_j: As you can see, I can apply (+) to a single argument and get back a function which takes the second argument.
07:27:46 <Cale> Well, what you wrote there is a section which desugars to (\x -> x + 1), so it's not really the best example of currying :)
07:27:54 <Cale> :t (+) 1
07:27:56 <lambdabot> Num a => a -> a
07:27:59 <Cale> ^^ but this works too
07:28:14 <ct_j> oh that makes sense I think, thank you
07:28:25 <Cale> ct_j: Whenever you see a type like A -> B -> C -> D
07:28:32 <Cale> it really means A -> (B -> (C -> D))
07:28:36 <Cale> and whenever you write
07:28:39 <Cale> f x y z
07:28:47 <Cale> it really means ((f x) y) z
07:29:27 <ct_j> So A -> B -> C -> D is more for convenience, it's not what really happens?
07:29:41 <Cale> Well, it's just that -> associates to the right
07:29:59 <Cale> Each -> takes two type arguments, the domain and codomain of the function
07:30:17 <Cale> So, a function of type A -> B -> C -> D is a function which accepts an argument of type A
07:30:23 <Cale> and produces a function of type B -> C -> D
07:31:03 <jameseb> ct_j: that is A -> (B -> (C -> D)), but the brackets are normally omitted for readability
07:31:31 <Cale> Every function in Haskell has exactly one argument, and the illusion of multiple arguments just comes from having functions which produce other functions, and some syntactical conventions regarding the way that expressions associate
07:31:36 <mettekou> Cale: I don't see how exactly GHC desugars a section is relevant to a beginner's question on Haskell? The difference between applying \x -> x + 1 to an argument and applying (+) 1 to it irrelevant to the result type or indeed value.
07:31:52 <EvanR> which is ironic because new comers are perplexed by A -> B -> C -> D and lisp people prefer an unreasonable nest of brackets also for readability
07:31:55 <mettekou> is irrelevant **
07:31:59 <Cale> mettekou: Well, because (+ 1) doesn't make use of the fact that (+) is curried
07:32:33 <ct_j> Cale: So then the function B -> C -> D which is produced accepts an argument of type B, and returns a function C -> D?
07:32:40 <Cale> yep
07:32:56 <Cale> So, if we have f :: A -> B -> C -> D, and x :: A, y :: B, z :: C
07:32:58 <Cale> we have
07:33:02 <Cale> f x :: B -> C -> D
07:33:05 <Cale> f x y :: C -> D
07:33:08 <Cale> f x y z :: D
07:33:26 <mettekou> Cale: If you strip the syntactic sugar away, sure. But I'm talking about what's visible to a beginner in the interpreter.
07:33:30 <Cale> noting that f x y means (f x) y
07:33:38 <Cale> and f x y z means ((f x) y) z
07:34:19 <hexagoxel> the language decides reality, not how you decide to parse a -> b -> c :p
07:34:22 <Cale> mettekou: Sure, the sectioning sugar is meant to be reminiscent of what happens with currying.
07:34:39 <EvanR> yes f x y z = ((f x) y ) z i think was the answer to the original question
07:35:19 <EvanR> speaking of which
07:35:53 <Fuco> sectioning is nice until you get to code like (.f).(g.) 
07:36:04 <Fuco> then it takes a bit of mental ping-pong
07:36:13 <Cale> heh
07:36:27 <EvanR> i have been perplexed on numerous occasion by various people describing certain languages as "left to right" and "right to left", and being confused by not knowing wtf that means wrt parsing, precedence, and evaluation strategy
07:36:50 <Fuco> EvanR: I had the hardest time explaining J to a friend... where you basically never write parens and it just associates somehow :D
07:36:51 <ct_j> Makes a lot more sense now, thank you all. I see why mathematicians like functional languages
07:36:54 <Cale> I'm fairly okay with (f .) . g by now, but it's not something that I'd usually put in code for others to read
07:36:56 <Fuco> I'm not even sure what to call it
07:37:02 <EvanR> yes J is involved in this
07:37:04 <ct_j> If I want to read more into this, if "function currying" what I need to search for?
07:37:08 <ct_j> is*
07:37:31 <Cale> ct_j: Yeah, currying is the process of turning a function which takes a tuple as its argument into a function which produces another function as its result
07:37:34 <EvanR> and when they said "$ in haskell makes it right to left" i knew it was wrong, but i have no idea whats going on
07:38:05 <EvanR> Fuco: you think "right to left" is talking about association?
07:38:08 <ct_j> cheers :)
07:38:14 <Cale> ct_j: We say that functions in Haskell are "curried" though, really, they start out life as functions which produce other functions by default.
07:38:16 <Fuco> probably people interpret $ as | in bash and get confused? :D
07:38:17 <Cale> :t curry
07:38:19 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:38:22 <Cale> :t uncurry
07:38:24 <ralu> even monad-s does not define evaluation order
07:38:25 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:38:40 <Cale> ^^ though these functions exist to help with functions that take pairs
07:38:41 <EvanR> Fuco: in elixir, yes
07:39:31 <Fuco> I'm not sure what "right to left" might mean but I would understand it in terms of association yes... or in case of some "stack notation" I would read the stack from that direction
07:39:50 <Fuco> e.g. some paren-less lisp with syntax like * 1 + 2 3
07:39:54 <Cale> Evaluation in Haskell is *mostly* going to be left to right, though the language is designed in such a way that it mostly doesn't matter which order you evaluate expressions in, so long as you pick an order which terminates whenever such an order exists.
07:39:55 <hexagoxel> EvanR: did you know that ($) has a precedence of (-3.44) in the official cross-language precedence scale? :)
07:39:57 <EvanR> read the stack from right to left, what in the world?
07:40:13 <Cale> e.g. when you have
07:40:18 <Cale> f (g (h x))
07:40:24 <Cale> this results in f being unfolded first
07:40:38 <Cale> and (g (h x)) being passed unevaluated as a parameter to it
07:40:42 <Tuplanolla> Is there a single programming language that is parsed from top to bottom?
07:40:50 <EvanR> Cale: what does "left to right"  mean >_<
07:40:56 <Cale> EvanR: I mean outermost-first
07:40:57 <Fuco> Tuplanolla: funge
07:41:21 <hexagoxel> Tuplanolla: are you restricting yourself to those boring 2-dimensional source-code languages?
07:41:24 <EvanR> really?
07:41:24 <Cale> Let's give the double example :D
07:41:30 <Cale> Consider the function
07:41:32 <Tuplanolla> We must have this, Fuco. May I propose `TransposedSyntax`?
07:41:33 <Cale> double x = x + x
07:41:43 <Cale> and suppose we want to evaluate  double (double 5)
07:41:44 <EvanR> to you think outermost first is what left to right means in J or something?
07:41:57 <Cale> Under strict evaluation, we'd have something like the following:
07:41:58 <EvanR> or list
07:42:00 <EvanR> lisp
07:42:01 <Cale> double (double 5)
07:42:05 <Cale> -> double (5 + 5)
07:42:07 <Cale> -> double 10
07:42:09 <Cale> -> 10 + 10
07:42:10 <Cale> -> 20
07:42:30 <Cale> That is, we always reduce the innermost reducible subexpressions first
07:42:48 <Cale> We could also naively evaluate it outermost-first:
07:42:53 <Cale> double (double 5)
07:42:58 <Cale> -> (double 5) + (double 5)
07:43:05 <Cale> -> (5 + 5) + (double 5)
07:43:11 * hexagoxel wonders if there is any IDE that highlights precedence by offsetting stuff in the 3rd dimension. That'd be fancy as hell.
07:43:12 <Cale> -> 10 + (double 5)
07:43:16 <Cale> -> 10 + (5 + 5)
07:43:18 <Cale> -> 10 + 10
07:43:19 <Cale> -> 20
07:43:31 <Fuco> hexagoxel: I bet there's an emacs package for that
07:43:38 <Fuco> and if not I will write it (for elisp at least :D)
07:43:39 <EvanR> 10 + (5 + 5) -> 10 + 10 isnt outermost first
07:43:45 <Cale> But note that this resulted in duplication of work: we ended up evaluating double 5 twice because the parameter to double occured twice in its body.
07:44:01 <EvanR> or side to side afaict
07:44:06 <Cale> EvanR: Well, there I'm regarding the outermost (+) as not being reducible yet.
07:44:19 <Cale> Because (+) is strict in both its arguments
07:44:30 <tenniscp25> How to convert Text to ByteString using ascii charset? Is B8.pack . T.unpack the right solution?
07:44:31 <Cale> (and I don't want to unfold its definition)
07:44:54 <EvanR> Fuco: so... a string of symbols could be considered a stack operation language
07:45:16 <EvanR> and is this what APL/J is thinking and what left to right/right to left comes from
07:45:17 <Fuco> EvanR: if you fix  arity you can do it consistently
07:45:34 <Cale> So we might check the first occurrence of (+) in 10 + (5 + 5) there first, but discover that it's still applied to something which isn't explicitly a number, and so demand that its second argument be evaluated.
07:45:57 <Fuco> I understand it that way, practically
07:46:11 <Cale> Strict evaluation always evaluates arguments to functions exactly once
07:46:28 <Cale> Plain outermost-first evaluation will evaluate an argument to a function zero or more times
07:46:30 <EvanR> Fuco: in that case is association always leaning left, or is association just making it more complex to think about
07:46:58 <Fuco> well, you don't need association, it is given by the way you write it
07:47:02 <Fuco> thre is only one way to parse
07:47:09 <EvanR> now its starting to make sense, association just isnt a thing because its not an expression language
07:47:11 <Cale> Lazy evaluation is like outermost-first evaluation, but we add an additional rule to prevent the duplication of work which took place above when we copied the (double 5) to both x's in x + x
07:47:17 <EvanR> its a stack imperative language
07:47:35 <Cale> Specifically: any bound variable should only be evaluated at most once, and the result shared between its occurrences.
07:47:47 <Cale> So, under lazy evaluation:
07:47:49 <Fuco> think about "+ * 1 2 3" vs "+ 1 * 2 3", there is only one way yo evaluate it popping from the stack
07:47:51 <EvanR> and applying these "principles" to haskell code is just whack
07:48:11 <Fuco> (assuming arity 2 for both + and *)
07:48:12 <Cale> Well, if you'll allow me to use a 'let' expression to represent the sharing, it would look like this:
07:48:17 <Cale> double (double 5)
07:48:30 <Cale> -> let x = double 5 in x + x -- note that we've reduced the outermost double here
07:48:44 <Cale> -> let x = 5 + 5 in x + x
07:48:50 <Cale> -> let x = 10 in x + x
07:48:52 <Cale> -> 10 + 10
07:48:53 <Cale> -> 20
07:49:37 <Cale> So that's all that lazy evaluation is: outermost-first evaluation, plus this proviso that bound variables are evaluated at most once (sharing).
07:50:05 <EvanR> and that expressions become bound variables
07:50:41 <Cale> Well, bound variables could always have been bound to as-yet-unevaluated expressions in the outermost-first case.
07:50:49 <EvanR> anyway, now its becoming clear that some people think about expression languages as some kind of imperative language to operate on a stack or something vague
07:51:25 <Cale> Yeah, the thing about outermost-first evaluation in general is that it completely changes the meaning of your stack
07:51:38 <Cale> You no longer really need or want something like a call stack.
07:52:05 <nshepperd> it's implemented using a stack, but it sure isn't "about" a stack
07:52:09 <Fuco> it's just a rewrite system then really
07:52:10 <Cale> But in GHC and many other implementations, there is still a stack -- it's just not very appropriate to think of it as a call stack.
07:52:36 <EvanR> i wasnt thinking about call stacks
07:52:41 <EvanR> but good point
07:52:43 <Cale> ah
07:52:44 <EvanR> i was thinking about forth
07:52:47 <Cale> ah, right
07:53:00 <Cale> That's more at the level of just parsing the expression in the first place
07:53:29 <EvanR> yes! man theres enough totally separate things going on that theres many ways to smush them together and get hella confused
07:53:37 <Cale> GHC's stack is a stack usually consisting primarily of pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
07:53:47 <mettekou> Is there a library out there which combines the functionality from annotated-wl-pprint and ANSI control characters for colours?
07:53:58 <EvanR> the fact that stacks can be introduced in various ways doesnt help
07:54:04 <Cale> It may also have some applications on it, you can't evaluate f x without first evaluating f.
07:54:38 <Cale> (but those entries don't tend to pile up unless you're doing something pathological)
07:54:57 <EvanR> the pattern matches pile up
07:55:02 <Cale> yeah, they may
07:55:20 <Cale> If you have a stack overflow, it's almost guaranteed that it's pattern matches waiting on the stack
07:55:48 <Cale> rather than function applications waiting for the function to be evaluated
07:55:52 <Fuco> hm, now that I think about the sharing, it messes my simple view a bit :D Naively you would just parse the expression into a tree and then DFS eval it /shrug
07:56:18 <Cale> Yeah, you can still sort of do that, but the expression becomes a graph
07:56:23 <Fuco> right
07:56:42 <EvanR> you dont have to think about sharing
07:56:49 <EvanR> you still get the same answer
07:56:55 <Cale> Well, you only have to think about the sharing if you care about performance.
07:57:09 <EvanR> yes so its an optimization
07:57:09 <Cale> In fact, you only have to care about the evaluation order at all if you care about performance
07:57:12 <Cale> which is really nice
07:57:26 <EvanR> not a critical component of the correctness
07:57:43 <Cale> Any order of evaluating expressions in Haskell will tend to produce the same result (save for interactions involving unsafePerformIO and unsafeInterleaveIO)
07:57:48 <EvanR> unless evaluating a certain way changes non termination?
07:57:53 <Cale> Yeah
07:58:00 <Fuco> can that even happen in a typed system?
07:58:03 <Cale> You can't do innermost-first evaluation
07:58:16 <Fuco> well with infinite structures, sure it can :p
07:58:18 <EvanR> yes! thats the worst way!
07:58:24 <Cale> But you could, say, swap between doing an innermost reduction and outermost one repeatedly.
07:58:50 <EvanR> so "depth first search" evaluation is bad mmkay
07:58:53 <Cale> GHC makes use of this freedom of changing the evaluation order extensively
07:59:19 <EvanR> idris looking at you
07:59:25 <Tuplanolla> I wonder how horrible a stochastic evaluation strategy would be.
07:59:40 <EvanR> evaluate all the things in parallel!!!!
07:59:47 <Tuplanolla> Pick an expression at random at each step.
07:59:51 <Cale> There's a strictness analyser which reorders the evaluation to be more strict whenever it can be proven that the result of that evaluation will surely be needed later.
08:00:25 <Cale> Tuplanolla: Then your conditionally terminating programs will almost surely terminate ;)
08:01:18 <EvanR> actually the parallel interpretation explains why you can implement certain expressions computation as a circuit
08:01:20 <Tuplanolla> Now I want to drop all the useful work I have lined up and try it.
08:02:39 <EvanR> and how an expanded view of how addition works lets you make an adder which is faster than this step-by-step algorithm
08:03:26 <Tuplanolla> Twenty seconds until someone brings up braided monoidal categories...
08:03:47 <EvanR> agreed
08:03:57 <nshepperd> Tuplanolla: train a deep learning system to pick the most efficient expression to evaluate first...
08:04:25 <Tuplanolla> That sounds actually useful, which is something I don't do, nshepperd.
08:04:50 <nshepperd> heh. no useful work allowed!
08:07:53 <EvanR> so uh, now i want to learn how J code looks as a traditional expression
08:08:03 <EvanR> so i can actually understand it
08:13:15 <ij> Is writeFile strict?
08:13:48 <Adeon> pretty sure it has to be
08:14:07 <Adeon> can't write a file if you don't evaluate all the contents of the string
08:18:25 <zq> how to tell cabal to use clang, not gcc
08:19:32 <niklasb_> cya
08:23:54 <meditans> is it possible to disable the error produced by a type wildcard using PartialTypeSignatures?
08:23:56 <Tuplanolla> Does setting the environment variable `CC` help, zq?
08:25:38 <glguy> meditans: When you get a message like this: Desktop/Demo.hs:5:6: warning: [-Wpartial-type-signatures]
08:25:46 <glguy> You can disable that warning like this: {-# OPTIONS_GHC -Wno-partial-type-signatures #-}
08:26:07 <meditans> perfect glguy, thanks!
08:27:20 <ij> I'm using strict's System.IO.Strict to read a file, the default writeFile to write, so it should be all right, but somewhy I'm getting resource busy on openFile.
08:27:48 <zq> Tuplanolla: no, of course not
08:27:53 <zq> cabal ignores CC intentionally
08:27:57 <zq> doesn't matter, i symlinked
08:29:04 <glguy> ij: You can paste the problem code to http://lpaste.net
08:30:13 <ij> Well this is all the code that touches the problematic file, but it seems to be unproblematic to my eye. :D http://vpaste.net/5VR5o
08:30:16 <Profpatsch> ,exf IO (Maybe a) -> MaybeT IO a
08:31:05 <Profpatsch> I can never remember what the exference bot syntax is.
08:31:06 <glguy> ij: You could make your code a lot clearer using do-notation and cases instead of things like >>= and either, incidentally
08:31:30 <geekosaur> ":exf"
08:32:06 <ij> glguy, Are you talking about the reloadConf specifically?
08:32:22 <glguy> ij: most of the file
08:32:45 <glguy> Also, there's no standard "System.IO.Strict"; which package are you using?
08:32:54 <ij> There's not a lot of code there. // Package strict, I think.
08:33:19 <ij> Is there any other function other than load/reloadConf that seem bad?
08:33:52 <Profpatsch> :exf IO (Maybe a) -> MaybeT IO a
08:34:00 <glguy> I think the last 4 defintions would benefit from a do
08:34:14 <Profpatsch> geekosaur: you sure?
08:34:20 <exferenceBot> could not find expression
08:34:20 <glguy> if you're going to mix >>= and ., you should mix =<< and .
08:34:33 <Profpatsch> Ah, ok.
08:34:36 <NextHendrix> when i run cabal install --only-dependencies with this cabal file https://ptpb.pw/BfFN.cabal
08:34:52 <ij> Do you really consider "get >>= liftIO . load >>= put" unclean?
08:34:52 <geekosaur> be patient, it's slow :)
08:34:54 <NextHendrix> i get Plain fields are not allowed in between stanzas: F 22 "license" "GLP-3"
08:34:55 <glguy> ij: System.IO.Strict as a "readFile" definition, I don't think it fixes your problem, but you don't need to define 'readFileStrict'
08:35:00 <glguy> ij: yeah
08:35:08 <ij> WHAT!?
08:35:30 <NextHendrix> cabal generated that file by itself, which is why im confused
08:35:33 <glguy> If you're going to do that, at least write:   put =<< liftIO . load =<< get
08:35:40 <glguy> get things in the same direction
08:35:46 <geekosaur> NextHendrix, are you sure?
08:36:11 <geekosaur> because the "synopsis" and "description" headers are commented while their contents are not, which I doubt is what cabal generated
08:36:21 <geekosaur> (and will indeed cause that error)
08:36:45 <ij> Oh, you're talking about that. Well, I suppose someone might be bothered by that, but not me.
08:37:11 <glguy> That's fine, no one else generally will need to see this code
08:37:14 <ij> I general I agree, but this case is a mild offense.
08:37:17 <NextHendrix> geekosaur: aha
08:37:32 <NextHendrix> geekosaur: yes the desc and synopsis are the bits i added myself, forgot to uncomment
08:37:33 <ij> glguy, even if they did, I'd consider it a mild offense.
08:37:41 * NextHendrix leaves to bang his head on a wall somewhere
08:37:59 <glguy> ij: Yeah, reloadConf is more of a problem
08:38:08 <ij> My brain can well imagine the data flow without much overhead.
08:38:39 <glguy> Sure, it just shouldn't have to
08:39:26 <glguy> ij: read = liftIO $ readIniFile confStore, is that readIniFile another strict read?
08:40:12 <Profpatsch> What’s the best way to get an IO (Maybe a) to a MaybeT IO a?
08:40:18 <glguy> MaybeT
08:40:25 <Profpatsch> Oh, lol.
08:40:41 <Profpatsch> Yeah, where’s my brain.
08:40:50 <ij> glguy, That's probably the issue.
08:40:58 <ij> waiiit, no
08:41:08 <ij> The json file is the problematic one.
08:41:39 <ij> Ok, I've urgent money-work to do.
08:41:42 <glguy> ij: Another operator pattern that you might like: load defaults = maybe defaults id . decode . BCL.pack <$> readFileStrict botStore
08:41:59 <buglebudabey> is there something i should be careful of when downloading haskell on windows 7?
08:42:42 <ij> glguy, I knew the pattern, just didn't think of it.
08:42:48 <ij> Yeah, that should totally be there.
08:43:32 <Profpatsch> buglebudabey: Don’t feed the grue
08:43:46 <buglebudabey> Profpatsch, grue?
08:43:49 <tabaqui1> I need some functions from internal modules of library
08:43:53 <Profpatsch> kidding
08:44:09 <tabaqui1> but stack doesn't want to give them
08:44:22 <tabaqui1> how can I "force import" 'em?
08:44:37 <glguy> tabaqui1: You can fork the library if the modules aren't exposed
08:45:03 <tabaqui1> glguy: it's the obvious solution, but there is no nicier one?
08:45:15 <nitrix> The nicer would be to ask the maintainer to expose these modules.
08:45:18 <glguy> send the maintainer an email
08:45:52 <geekosaur> tabaqui1, no, there is no "force expose" switch. if they were not exposed, the information to expose them *does not exist*
08:46:18 <nitrix> I'm glad such thing doesn't exist, else people would be taking weird shortcuts all the time.
08:46:20 <buglebudabey> what shell should i use when running haskell programs from the command line on windows 7, powershell? or cygwin or other
08:47:22 <tabaqui1> that's a shame, because developer didn't make any commit for a year
08:47:33 <tabaqui1> I have to fork it then
08:47:37 <tabaqui1> thanks all
08:47:43 <tabaqui1> *to all
08:54:47 <buglebudabey> i downloaded stack using the installer but the 'stack' command still isn't recognized as a cmdlet, the installer was supposed to add it to my path, any thoughts?
08:55:08 <Profpatsch> buglebudabey: should work from cmd.exe … 
08:55:21 <Profpatsch> Hm, maybe I misremembered.
08:55:28 <Profpatsch> buglebudabey: Did it install cygwin?
08:55:51 <buglebudabey> Profpatsch, no
08:56:18 <buglebudabey> Profpatsch, doesn't work on powershell or cmd
08:58:55 <deank> did you restart your shell
08:59:43 <deank> to load fresh environment variables
09:00:06 <buglebudabey> i closed them and reopened them and same result
09:02:13 <Profpatsch> buglebudabey: Err, don’t you have to log out on Windows to get a new path?
09:02:31 <buglebudabey> not sure, i'm used to using mac osx, this is my work computer
09:03:01 <buglebudabey> rather than just installing stack im going to use the minimal package from the haskell.org page and see how that goes
09:05:52 <Profpatsch> buglebudabey: If you’re used to Mac, I suggest wiping your drive and installing a linux distribution.
09:06:05 <Profpatsch> Maybe elementary OS.
09:06:12 <buglebudabey> it's a work computer, no dice
09:06:58 <Profpatsch> whoa, I’d lose 80% of my productivity if I had to work on a system that isn’t my config.
09:07:16 <Profpatsch> sad state of business.
09:08:21 <nshepperd> yeah you should try logging in again
09:10:00 <buglebudabey> cabal works just fine
09:10:03 <buglebudabey> just not stack
09:13:38 <Younder> Both cabal and stack have their issues.
09:14:13 <glguy> Younder: No, this isn't a time to defend a tool, buglebudabey is actually just having trouble with an installation
09:14:36 <Younder> I have chosen to stick with cabal for now. But some say stack offers better stability.
09:14:52 <Younder> -
09:14:54 <buglebudabey> Younder, they have different purposes
09:14:57 <glguy> Unless you think you can pep talk buglebudabey's stack installation into working
09:15:12 <Younder> nop, I'll keep out of it.
09:15:48 <glguy> OK, I'll try for you. "Hang in there buddy, you're just as good as cabal and if you believe in yourself you'll start working for buglebudabey!"
09:16:07 <buglebudabey> buttons have been pressed
09:16:17 <Younder> glguy, now you are just being silly
09:16:36 <glguy> Oh, definitely!
09:17:18 <nshepperd> gabatte stack-tan! you can do it!
09:17:32 <Younder> What a temper on that guy. Let's cut the noise ratio.
09:19:45 <hexagoxel> i for one are also in favor of cutting the noise ratio.
09:20:58 <buglebudabey> so i hand-added stack.exe to my path, and still am not getting it to work...
09:22:11 <hexagoxel> buglebudabey: you mean the path of stack.exe?
09:22:36 <buglebudabey> yes hexagoxel i do mean that
09:23:02 <glguy> I'm opposed to the noise, too, which I why I stopped buglebudabey needing help configuring his installation from turning into yet another stack/cabal discussion
09:23:16 <buglebudabey> i even when to the folder it's in on my command line and tried to run 'stack ...' and nothing still
09:23:40 <glguy> buglebudabey: What's the actual error message you're getting?
09:24:23 <buglebudabey> the term 'stack' is not recognized as a cmdlet, .., .... Check the spelling... verify the path...
09:24:40 <geekosaur> o.O
09:24:48 <geekosaur> that's not a cmd.exe error
09:24:56 <geekosaur> "cmdlet"?
09:24:57 <buglebudabey> im in powershell
09:24:59 <ertes> does anyone know whether the scrypt library is unmaintained or just "still good"?
09:26:05 <buglebudabey> geekosaur, when i run it on cmd.exe i get the usual 'stack' is not recognized as an internal or external command..
09:33:01 <zamanf> time to mode +R
09:33:29 <glguy> zamanf: This isn't an attack, it's the matrix.org people coming back
09:34:24 <zamanf> glguy, from where?
09:34:48 <glguy> from when they split off about 16 minutes ago
09:35:43 <ongy> why do they all have [m]?
09:36:04 <glguy> I presume that matrix.org mandates that you have a [m] suffix when they proxy you through to IRC
09:36:11 <glguy> It's some other chat protocol
09:37:13 <glguy> Maybe it's a marketing strategy, their regular netsplits and [m] suffix ensure that people learn about them through floods of joins and parts
09:37:43 <glguy> Anyway, we can talk more about it in #haskell-ops if you want (and it's fine if you do)
09:40:04 <infandum> If my package depends on another package which has a very restrictive upper bound, what can I do about it?
09:40:57 <glguy> You can email the maintainer. You can ask the trustees to update it if the maintainer is unavailable and it's compatible with newer versions
09:43:40 <infandum> glguy: Okay. That seems like the proper thing to do but it also seems time consuming.
09:44:08 <glguy> OK
09:44:17 <glguy> https://github.com/haskell-infra/hackage-trustees if you need the link
09:46:32 <nitrix> Given some category, can I simultanously have monomorphisms/epimorphisms/isomorphisms within that same category?
09:46:46 <nitrix> My current understanding is that these are properties of the morphisms when the objects are some form of container-like idea, like the category of Set.
09:47:18 <nitrix> Is this right? Also, what if instead we look at functors between two categories; can I describe these via mono/epi/iso as well?
09:47:51 <nitrix> I'm probably making very little sense :(
09:48:36 <lyxia> you can talk about these in any category
09:48:38 <hexagoxel> infandum: the least time-consuming pseudo-solution is to --allow-newer.
09:51:09 <ertes> nitrix: the definitions of those do not rely on anything more than the basic definition of a category
09:51:15 <nitrix> lyxia: So, if I understand this right, lets say the Hask category where objects are types and morphisms are functions, obviously not every functions maps types the same way, so I could, indeed, have morphisms with different properties (mono/epi/iso) within a category.
09:51:42 <nitrix> So that's great. Now what about functors?
09:51:49 <nitrix> Don't they form a mapping too?
09:51:54 <ertes> nitrix: there are categories of categories, where functors can be monic, epic and iso, too
09:52:02 <nitrix> ertes: Oh.
09:52:25 <ertes> nitrix: in a category of categories the morphisms are typically functors
09:52:33 <nitrix> ertes: That makes sense too, but what if I have just two categories and a single functor?
09:52:47 <nitrix> ertes: Does it makes sense to say that functor is monic/epic, etc?
09:53:03 <ertes> nitrix: find a category that includes those two as objects and the functor as a morphism
09:53:10 <nitrix> Or it has to be within the frame of a category?
09:53:17 <nitrix> ertes: I see. That answers a lot then.
09:53:29 <ertes> nitrix: monomorphism, epimorphism and isomorphism really only make sense in terms of a category
09:54:23 <nitrix> ertes: Mhm. My understanding seems less fragile now :)
09:54:32 <Younder> Those terms predate category theory, they come from topology,
09:55:08 <nitrix> lyxia: ertes Appreciated, both of you. I'll see where I can go from there :P
09:55:32 <Younder> Although studies in c homology let to category theory.
09:56:11 <Younder> Still confused but trying to learn.
09:56:13 <ertes> yeah, the terms are overloaded…  i mean the categorical versions
09:58:12 <ski> ner0x652 : "what if I have just two categories and a single functor?","Does it makes sense to say that functor is monic/epic, etc?","Or it has to be within the frame of a category?". the concepts "mono" and "epi" are "global" in the sense that they refer to any object in the category, and any morphism from/to that object. so you need the surrounding category
09:58:17 <ski> hrm
09:58:21 <ski> nitrix ^
09:59:31 <ertes> nitrix: note that the terms have different semantics depending on the category in question, but they always describe a form of partial order that denotes "size" of some sort
10:00:28 <ertes> nitrix: in fact i don't like the notion of "subcategory" in terms of objects and morphisms…  i much prefer a notion of it in terms of functors
10:01:09 <ski> (generalize to subobjects)
10:05:06 <Younder> I recommend 'lattices and order' by Davey and Priestly before takling category theory. In my case this is in hindsight, but I felt it helped.
10:06:48 <Younder> For beginning Haskellers like myself who are not yet experts.
10:11:25 <StarsC> which haskell package has biggest number of dependecies?
10:12:01 <maerwald> @hackage acme-everything
10:12:01 <lambdabot> http://hackage.haskell.org/package/acme-everything
10:12:16 <Tuplanolla> Unfortunately it's not everything anymore.
10:12:18 <Younder> lol
10:12:34 <StarsC> excluding deliberate dependecies :)
10:13:34 <Younder> acme is the company that provides Willy coyote with all his tools?
10:14:15 <kadoban> Yep
10:14:19 <Younder> who new haskellers had a sense of humor
10:16:08 <sm> OT: ward cunningham speaking live at https://www.youtube.com/watch?v=DnZJHw8NmEQ
10:18:25 <ertes> StarsC: yesod
10:20:17 <StarsC> stack also has many
10:20:40 <StarsC> ertes: ty, will check yesod
10:21:14 <sm> darcsden has a good few
10:22:16 <Younder> darcs still lives even in this git-hub world.
10:39:03 <shapr> darcs is wonderful
10:41:56 <ertes> StarsC: hakyll is also very heavy
10:42:24 <andromeda-galaxy> shapr: any opinions on pijul?
10:42:25 <davean> darcs views source code in a way very opposed to how I think about it
10:42:41 <davean> I do not consider patches to be a thing other then a transfer mechanism
10:42:58 <ertes> i like the idea of darcs, but i switched to git a few months ago
10:43:17 <shapr> andromeda-galaxy: first I've heard of it, but the webpage is persuasive
10:44:03 <ertes> so far i was able to map all my workflows (which are highly darcs-/patch-theory-specific)
10:44:33 <andromeda-galaxy> ertes: is that about pijul or something else? shapr: yeah, it definitely sounds good...
10:45:26 <ertes> andromeda-galaxy: i haven't tried pijul, so can't really say anything about it
10:46:12 <andromeda-galaxy> ertes: ah okay, sorry - read something backwards
10:47:08 <bwe> How can I retrieve the third element of a triple like (3 % 10,9 % 10,22 % 1085)  ?
10:47:33 <ertes> bwe: \(a, b, c) -> c
10:47:38 <bwe> I know `fst` and `snd` do only work on tuples. 
10:47:45 <bwe> ertes: Oh, that's straightforward.
11:08:37 <ReinH> Or even \(_, _, x) -> x if you want to be more explicit about not using the other elements.
11:15:03 <Benzi-Junior> question is the size of the Int type dependent on the machine architecture or is it fixed to 64 bits ?
11:15:34 <dolio> It is not fixed.
11:16:40 <Benzi-Junior> dolio: TY
11:18:30 <kadoban> According to the report it's ... at least 30 bits of magnitude I believe? Something like that.
11:18:39 <geekosaur> 29 bits
11:19:21 <geekosaur> but ghc gives you the full native width. that said, there are types Int8, ... Int64 (at least)
11:19:35 <geekosaur> so if you require a 64-bit integer, use Int64
11:20:06 <kadoban> Ah, thanks.
11:21:00 <Benzi-Junior> geekosaur: why a minimum of 29 bits ?
11:21:15 <Benzi-Junior> geekosaur: purely out of interest
11:21:31 <geekosaur> I presume they were setting a limit on the number of bits that could be "stolen" for constructor tagging or etc.
11:22:06 <geekosaur> you'd have to ask the language committee to be certain... if you can find the members from back then
11:22:23 <dolio> I think it's 30 bits. -2^29 to 2^29-1.
11:25:35 <suppi> what's the recommended way to store a password in a db in haskell?
11:25:47 <suppi> i guess i need to hash the password, which lib should i use?
11:27:07 <pakettiale>  i think argon2
11:31:24 <suppi> pakettiale: thanks :)
12:29:35 <ertes> suppi: i was informed earlier today that cryptographers are hesitant to adopt argon2 right now, because it's so new
12:29:53 <ertes> suppi: to be safe you may want to go with scrypt, but implement the facilities to upgrade to argon2 later
12:30:17 <ertes> suppi: however, any kind of KDF is really better than simply hashed passwords
12:30:22 <ertes> so argon2 is probably just fine
12:30:42 <EvanR> is something wrong with existing hash algorithms?
12:30:46 <EvanR> why do we need to upgrade them?
12:32:33 <ertes> EvanR: well, we don't necessarily need to…  scrypt is fine, too
12:36:29 <pakettiale> just dont use md5 or sha-1 :P
12:40:54 <pakettiale> btw does anybody have experience of using stack on rasperry pi? Currently rasbpian ships with llvm-3.2 so stack can't build a recent version of ghc :(
12:42:28 <ertes> according to ##crypto there are some issues with argon2, so i'd go with scrypt for now
12:43:23 <RoboLettuce> I never really appreciated how awesome Stack is until I had to build something on a wierd deployment server running a super old linux distro
12:43:42 <RoboLettuce> The fact that it allows you to use a later version of GHC than the system GHC is awesome
12:43:49 <RoboLettuce> and it installs everything for you automatically
12:54:00 <Gloomy> Hi :) 
12:54:12 <Gloomy> What is wrong with this? I get "several instances of show": 
12:54:19 <Gloomy> http://lpaste.net/351051
12:54:55 <Gloomy> Here is the error I get: 
12:54:57 <Gloomy> http://lpaste.net/351051
12:55:17 <Gloomy> I don't really understand the error message :/ 
12:55:23 <tdammers> Gloomy: you have two instances of Show for [ParseError]
12:55:51 <tdammers> the explicit one you wrote, and another one that is the result of your derived Show instance for ParseError and the existing instance Show a => Show [a] from Prelude
12:56:01 <Gloomy> Yeah that far I got :-) But it says one is defined in prelude, shouldn't the one I wrote override the default one? 
12:56:06 <tdammers> no
12:56:06 <kuribas> /join #haskell-offtopic
12:56:06 <kuribas>  
12:56:11 <kuribas> sorry
12:56:20 <tdammers> instances never override one another
12:56:54 <tdammers> at any point, for each combination of a type and a class, there can be either zero or one instances
12:57:07 <tdammers> if you try to define another one when one already exists, then that is an error
12:57:36 <tdammers> also, you can never rely on the absence of an instance, because outside code could add one
12:58:20 <Gloomy> Mmh, but I added the pragmas {-# LANGUAGE TypeSynonymInstances #-}, {-# LANGUAGE FlexibleInstances #-} to allow to give instances to type synonyms (should have mentioned it in my paste, sorry)
12:58:41 <tdammers> yes, but they still won't allow you to write conflicting instances
12:59:04 <tdammers> with these extensions, you could write the Show [ParseError] instance, but then you cannot have Show ParseError
12:59:54 <Gloomy> Oh so I just need to remove "deriving (Show)" from the ParseError type? 
12:59:56 <tdammers> this restriction is necessary because the order in which instances are defined is not always deterministic
13:00:28 <tdammers> if that's what you want, then yes, but it seems more reasonable to me to leave the derived instance and delete the manual one for [ParseError]
13:00:53 <tdammers> after all, the existing instance based on the derived ParseError Show and the list Show does exactly what should be expected
13:01:22 <Gloomy> I just want to add some nice formatting instead of the  default haskell list format.
13:01:38 <geekosaur> then you want to do it to the ParseError, not the alias
13:01:55 <tdammers> also, don't use Show for pretty printing
13:02:08 <tdammers> Show is for debugging, basically
13:02:38 <Gloomy> geekosaur : But how do I format several errors if ParseError is a datatype for only one error? 
13:02:56 <geekosaur> what's going on here is actually a little subtle: there is a canned instance for lists which defers to showList for the type of list elements, which is how [Char] == String gets displayed as a string without requiring extensions. this will conflict with any other instance for a list
13:03:16 <geekosaur> but also tells you how to handle your own lists: define your own showList as part of the instance for ParseError
13:03:33 <geekosaur> that said, see what tdammers said; using Show for this kind of thing is usually a bad idea
13:03:42 <Gloomy> tdammers Ah, then probably that's where I should be looking :)
13:04:02 <geekosaur> a better way is to provide your own mechanism for error messages, or possibly reuse an existing pretty-printing library/class
13:04:11 <geekosaur> (ghc does the latter)
13:04:24 <Gloomy> Ok, good to know. I'll look into that :-) 
13:04:30 <Gloomy> Thanks a lot!
13:20:05 <sphinxo> I'm wondering how best to annotate my ast with types, and being able to have a function that only take the annotated varient?
13:21:03 <sphinxo> actually I have three variants, a expr with an annotation, an expr with a verified annotation, and an expr with no annotation
13:26:17 <jmnoz> who uses docker builds with stack? do you cache ~/.stack? seems wasteful not to
13:31:01 <ski> sphinxo : one variant is to make it a parameter of the AST
13:36:54 <sphinxo> oh - ski then I can use Free and automatically derive functor
13:37:15 <sphinxo> or cofree
13:38:54 <Sonolin> jmnoz I don't use haskell in production, but if I did I'd imagine you can bundle the .stack directory with the deployment image
13:39:21 <Sonolin> assuming the architecture(s) line up of course
13:39:34 <jmnoz> Sonolin: it's for the build container for faster builds
13:39:51 <Sonolin> ah, gotcha
13:40:11 <Sonolin> yea that'd probably make sense then, would just mean a larger container image 
13:40:31 <Liskni_si> jmnoz: doesn't stack do that itself when building using docker?
13:42:00 <jmnoz> Liskni_si: maybe - thanks have to look into that, I was just looking at https://raw.githubusercontent.com/fpco/stack-docker-image-build/master/build-static.sh and it does not cache
13:42:27 <byorgey> sphinxo: if you just have a single recursive data type, then yes, that approach can work well
13:42:36 <byorgey> sphinxo: if you have mutually recursive types it gets more complicated
13:43:22 <Liskni_si> jmnoz: oh, that's a different beast, I meant https://docs.haskellstack.org/en/stable/docker_integration/
13:48:07 <Gloomy> How do you avoid circular import errors, if you have two functions in two separate modules that depend on each other? 
13:48:47 <Gloomy> Do I necessarily have to put them both in the same module?
13:50:19 <Welkin> factor them ou into a common module
13:50:22 <Welkin> out*
13:51:23 <Gloomy> Mmmh but then all functions that depend on these two have to be placed in that module as well? 
13:51:30 <glguy> Gloomy: If you can't factor it into a common module you can read about https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html?highlight=recursive%20modules#how-to-compile-mutually-recursive-modules
13:52:11 <Gloomy> glguy Thanks, will read that
14:08:51 <Arguggi> #/toggle awl_viewer
15:27:20 <MarcelineVQ> is there a defacto library for file compression into archives like tars?
15:27:37 <MarcelineVQ> if not, what's your favorite :>
15:27:48 <hpc> zlib
15:28:10 <hpc> also tar
15:29:40 <MarcelineVQ> thank you, would one use tar to create an archive that respects paths and use zlib to compress that? is that the idea behind  .tar.gz ?
15:30:27 <hpc> foo.gz means that the file named "foo" has been compressed
15:30:35 <hpc> if you want to compress multiple files, tar combines them
15:31:31 <MarcelineVQ> thanks hpc, I'll play around with these
15:32:13 <EvanR> ah HA
15:32:24 <EvanR> Hugs is actually an acronym
15:32:37 <EvanR> for "Haskell User's Gofer System"
15:33:46 <hpc> it's actually a recursive acronym for "hugs understands ghc superiority" ;)
15:34:14 <kadoban> EvanR: I can't tell if that's a real fact or a joke, heh.
15:34:26 <hpc> kadoban: he's right
15:34:37 <kadoban> Huh, interesting
15:36:29 <ReinH> ®https://en.wikipedia.org/wiki/Gofer_(programming_language)
15:36:50 <monochrom> "Haskell User's Gofer System" is a real fact
15:37:27 <monochrom> It began as a Gofer interpreter and then converted to Haskell. ("convert" as in adopting a new religion)
15:37:43 <maerwald> isn't that unholy?
15:37:46 <monochrom> (Oh, not to say that Gofer and Haskell are religions... :))
15:38:50 <hpc> the major language families get pretty close to being religions
15:38:57 <hpc> (C-like, lisp, ML-like)
15:39:13 <monochrom> It's probably better to use the "join the federation" analogy.
15:39:37 <hpc> especially the untyped interpreted subset of C-like languages
15:51:14 <shapr> yay Haskell?
15:51:32 <davean> sorry, I haven't said my daily prayers
15:52:29 <EvanR> i got that info from this somewhat ancient (2011) review of haskell's history and "present" http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
15:52:50 <EvanR> shapr is mentioned as inventing this IRC channel
15:54:01 <EvanR> despite its age, this PDF is the best overview of haskells language, tools, debugging strategies, and "gripes" ive seen
15:54:26 <pi____> Hey guys, I'm looking for some constructive critisim on some code (http://lpaste.net/351058), it takes some letters and finds perfect single word anigrams
15:55:01 <pi____> Don't think I can alter it much but hoping for a Haskell coders eye for suggestions
15:55:45 <Tuplanolla> I'd sprinkle in some toplevel type signatures, pi____.
15:56:08 <pi____> Alright, just for readability?
15:56:48 * ski . o O ( TkGofer )
15:56:49 <hpc> "hash" is an odd verb for what those operations are doing
15:57:07 <hpc> though i can't think of a better one
15:57:18 <Tuplanolla> The use of `mapM_` is a bit strange too, pi____. Perhaps `ShowS` would fit in better.
15:57:44 <Tuplanolla> How about `wrangle`, hpc?
15:57:51 <hpc> i wouldn't use Show for logic like that
15:58:05 <hpc> maybe write it with forM_ instead?
15:58:21 <hpc> no need to be afraid of making imperative code look imperative ;)
15:58:26 <Tuplanolla> I meant concatenating the strings and then passing it to the system call, hpc.
15:58:30 <hpc> ah
15:58:51 * ski thinks `mapM_' looks better than `forM_', in this case
15:58:53 <pi____> hpc: yeah, guess so, it's not really a hash
15:59:08 <hpc> "munge" maybe?
15:59:43 * pi____ googles it
15:59:54 <EvanR> urbandictionary it
15:59:58 <Tuplanolla> When in doubt, swear like a sailor.
15:59:59 <pi____> That looks spot on actually,
16:00:06 <hpc> you could maybe do (arg:args) <- getArgs, too
16:00:11 <ski> pi____ : perhaps you could `arg:_ <- getArgs'
16:00:22 <hpc> heh
16:00:30 <sphinxo> Hey I'm trying to parse strings like A -> A -> A to data Type = TArrow Type Type | TVar ( some stuff )
16:01:10 <sphinxo> and I'm struggling to be able to parse both "A" and "A -> A"
16:01:11 <pi____> ski: ah, true, how did I *not* do that?
16:01:31 <ski> sphinxo : left-factor
16:02:15 <sphinxo> what do you mean ski?
16:02:37 <sphinxo> ( what I've managed so far: http://lpaste.net/2060845705144041472 )
16:03:18 <pi____> Thanks guys
16:04:02 <ski>   ty = do
16:04:07 <ski>     t <- tvar
16:04:27 <ski>     tyRest t
16:05:06 <ski>   tyRest t1 = do reservedOp "->"
16:05:15 <ski>                  t2 <- ty
16:05:24 <ski>                  return (TArr t1 t2)
16:05:41 <ski>           <|> do return t1
16:05:57 <ski> sphinxo : something like that
16:06:38 <ski> sphinxo : .. or, in case you're using something like Parsec, try wrapping the first branch in your paste with `try'
16:07:24 <kuribas> I just installed haskell-platform on my mac mini (os X 10.6).  cabal gives a segfault.
16:08:07 <hpc> cool
16:08:18 <kuribas> ghc seems to run fine
16:08:19 <shayan_> kuribas: what IDE are you using on your Mac?
16:08:27 <sphinxo> oh thanks, ski initially I typed out the left factor stuff, which is cool- but try seems to work so I'm going to go with that
16:08:30 <kuribas> shayan_: command line for now.
16:08:52 <kuribas> shayan_: I actually develop in linux, but I have emacs also on my mac.
16:08:54 <ski> sphinxo : note that uses of `try' may be inefficient (which is why it's not the default in Parsec)
16:09:09 <sphinxo> yeah, it doesn't work for X -> X
16:09:32 <ski> sphinxo : sorry ?
16:10:09 <kuribas> I tried brew first, then reinstalled using the generic installer, but I get the same problem.
16:10:10 <sphinxo> hmm with try "X -> X" returns TVar X
16:10:12 <shayan_> kuribas: cool — i’ve been looking for what to use, will be starting to learn haskell when my book arrives in the mail :)
16:11:09 <sphinxo> ski: so it would be try tarrow  <|> tvar ?
16:11:13 <ski> sphinxo : which which ordering of the branches ? and making sure all input is consumed by the top parser ?
16:11:42 <kuribas> shayan_: TBH, I hardly ever use mac.
16:11:50 <ski> sphinxo : alternatively `try tvar <|> tarrow'
16:11:52 <kuribas> shayan_: But I think emacs should work just fine.
16:12:29 <sphinxo> ski: seems to behave the same
16:13:28 <shayan_> kuribas: is that because you have a preference of programming in the linux environment?
16:13:56 <sphinxo> chainl1 might do what I want
16:15:37 <kuribas> shayan_: yeah
16:15:46 <kuribas> shayan_: I know linux much better than mac
16:16:32 <shayan_> kuribas: fair enough. i’ve been considering learning in the linux environment
16:17:12 <kuribas> shayan_: Os X feels quite linuxy though :)
16:17:19 <kuribas> or unixy...
16:17:37 <kuribas> hm, I guess I am running 32 bit...
16:18:12 <shayan_> kuribas: :D
16:18:30 <sphinxo> ski: thanks for all your help
16:19:05 <shayan_> kuribas: thanks for the emacs suggestion though, i didn’t know beforehand. i think i will definitely be downloading that now
16:19:33 <kuribas> shayan_: it does have a large learning curve
16:19:47 <kuribas> and requires some tinkering
16:25:48 <ski> @where emacs
16:25:49 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
16:25:51 <ski> shayan_ ^
16:26:17 <shayan_> ski:  thanks so much
16:30:00 <ski> shayan_ : also see #emacs and <https://www.emacswiki.org/>
16:30:54 <shayan_> ski: thank you amigo 
16:33:01 <dmwit> Can I ask GHC about whether a specific package has a profiling version?
16:33:26 <kuribas> does ghc not work with 32 bit mac?
16:34:01 <kuribas> well cabal and stack actually?  I get "segmentation fault" and "illegal instruction" respectively.
16:39:35 <Axman6> kuribas: well, it's basically an unsupported platform, even for Apple, so it wouldn't surprise me (even though macOS runs 32 nd 64 bit binaries side by side just fine)
16:41:53 <kuribas> Axman6: then why wouldn't it run cabal/stack?
16:42:07 <kuribas> Axman6: could be a different issue?
16:43:28 <kuribas> apparently apple has blocked 64 bit support for the mac mini.
16:48:21 <kuribas> previous versions did work on this system...
16:52:57 <kuribas> maybe I can bootstrap from an older version
16:54:13 <Axman6> it more depends on whether GHC supports 32 bit macOS compilation than what macOS is doing, and I could understand if the GHC devs didn't want to continue to support 32 bit on macOS
16:57:08 <kuribas> hm, I did upgrade the CPU, perhaps that's why I doesn't support 64 bit.
16:57:28 <kuribas> I need to find a hack for the firmware.
16:59:44 <Axman6> well, you're way outside territory anyone could sanely support, so good luck! No intel mac has ever supported upgrading the CPU
17:00:40 <kuribas> Axman6: I did, and also added memory.
17:01:08 <sm> go kuribas!
17:01:58 <kuribas> but it's and older system, where the cpu wasn't soldered in.
17:03:32 <kuribas> The additional memory made a huge difference!
17:13:16 <zennist_> hooray
17:26:19 <niklasb> does anybody have a quick example read to sort a (Data.Vector.Vector a) ? the vector-algorithms provide a signature for sory like (PrimMonad m, MVector v e, Ord e) => v (PrimState m) e -> m (), but I just want a pure version :/
17:28:16 <dmwit> Can you thaw, sort (in ST), then freeze to get a pure sort?
17:30:24 <jchia> that's what i usually do
17:30:41 <jle`> you don't even need to work with st/io
17:30:45 <jle`> niklasb: just use 'modify'
17:30:56 <jle`> niklasb: modify takes a function in the form of that function
17:30:56 <niklasb> ok nice, thaw + freeze worked
17:31:06 <niklasb> jle`: haven't gotten modify to work, I tried briefly
17:31:20 <jle`> niklasb: http://hackage.haskell.org/package/vector-0.12.0.0/docs/Data-Vector.html#v:modify
17:31:29 <jle`> 'modify sort xs' should work
17:31:47 <niklasb> oh jle` I was using the wrong sort :/
17:31:54 <dmwit> Oh, `modify` is nice.
17:32:08 <niklasb> I used Prelude.sort and the error message didn't involve any [] characters :/
17:32:11 <niklasb> thanks dmwit jle` 
17:32:14 <jle`> no problem!
17:32:16 <jle`> yeah that happens :)
18:44:38 <Zemyla> Who was it who originally codified Traversable for Haskell?
18:57:21 <barrucadu> There's a functional pearl "The Essence of the Iterator Pattern" by Jeremy Gibbons and Bruno Oliviera, I don't know if there's an earlier source.
18:57:37 <barrucadu> *Oliveira
19:17:17 <ski> edwardk : SYN
19:18:36 <Axman6> No route to host
19:22:22 <mikeplus32> is there a generic zipper function like "zipWith :: (Zippy f, Alternative f) => (a -> b -> c) -> f a -> f b -> f c" that 'zips' so far as the structure of the two arguments are the same? maybe an ekmett package has it ... :-)
19:23:11 <EvanR> a variadic zipWith
19:23:28 <EvanR> could try the printf trick
19:23:39 <EvanR> and be damned!
19:24:33 <Axman6> if you want generic data type zipping, the closest I can think of is MonadZip, but that's constrained to monadic actions
19:24:48 <mikeplus32> i mean a zipwith that would work on e.g. Data.Tree.Tree (for my case a typical expression type like data Expr a = Plus (Expr a) (Expr a) | Pure a etc)
19:24:52 <Axman6> I'm assuming you're not after a variadic zip
19:24:55 <mikeplus32> Axman6: yeah, basically
19:25:17 <Axman6> I can't think of any type class which gives you that
19:25:29 <Axman6> ... it could be implemented for anything which is Generic pretty easily though
19:25:48 <mikeplus32> MonadZip might work actually
19:25:56 * Axman6 says "easily" without actually knowing enough of the details to actually do it himself
19:25:58 <EvanR> does the structure need to be exactly the same
19:26:04 <EvanR> like list of equal lengths
19:26:35 <Axman6> I'd assume you'd expect the same behaviour as zipWith, where the smaller side is taked to be the end of the spine
19:26:38 <mikeplus32> for me yes -- so just ordinary recursion might be the easiest way but least fun
19:26:44 <mikeplus32> yeah
19:26:50 <EvanR> smaller works for lists
19:26:59 <EvanR> but in general they might look totally different
19:27:04 <Axman6> works for anything with a nullary constructor
19:27:04 <EvanR> like expressions
19:27:25 <mikeplus32> that's why i chucked in the 'Alternative f' on the message above :)
19:28:09 <EvanR> how do you zip (1 + 2) with f(a,b,c)
19:28:46 <mikeplus32> you don't, you return some null equivalent
19:29:03 <EvanR> so you really are expecting the structures to match
19:29:35 <EvanR> i think you could come up with some laws for that
19:31:21 <mikeplus32> (... this feels like the kind of thing that would be hidden away in 'lens')
19:31:49 <Axman6> you could probably use the scrap your boilerplate stuff to do it actually
19:32:29 <Axman6> https://hackage.haskell.org/package/lens-4.15.1/docs/Data-Data-Lens.html
19:32:53 <Axman6> afaict, template, when used with the right type, points to _all_ a's in a type s
19:34:38 <mikeplus32> i'm not sure how i'd use that
19:34:59 <Axman6> yeah me either now I think about it
19:35:00 <mikeplus32> a class with a default impl using GHC.Generics.Generic1 might work
19:35:04 <Axman6> but this is pretty amazing:
19:35:06 <Axman6> > [1,2,3,4] & upon head .~ 0
19:35:08 <lambdabot>  [0,2,3,4]
19:35:13 <mikeplus32> yes lol
19:35:20 <Axman6> where head is Data.List.head, nothing fancy
19:35:55 <mikeplus32> i have no idea what's going on in the source for upon
19:36:33 <Axman6> yeah me either. the SYB stuff is pretty magic
19:36:51 <Axman6> (where magic = I don't understand it)
19:36:53 <EvanR> at some point lens will run out prepositions and well need to switch to slovakian
19:37:29 <EvanR> or hawaiian
19:38:02 <mikeplus32> at least we'll never run out of plausible looking operators
19:38:09 <EvanR> ._.
19:38:21 <EvanR> famous last words
19:41:05 <mikeplus32> https://hackage.haskell.org/package/these-0.7.3/docs/Data-Align.html
19:41:08 <mikeplus32> aha
20:04:22 <Axman6> EvanR: Hawaiian has some great words - the names fortwo types of lava are hawaiian, a'a (ah-ah), and pahoehoe (pah-hoe-ee-hoe-ee)
20:04:28 <Axman6> for ywo*
20:05:45 * Axman6 is bad at typing, probably should be a Haskeller
20:05:46 <manyone> i have a string s, how do i get "floor (sqrt (length s)) " without any error messages?
20:05:53 <Axman6> shouldn't. omg -_-
20:06:17 <Axman6> manyone: you can use floor . sqrt . fromIntegral . length
20:06:32 <manyone> oh wow - thank you!
20:06:48 <EvanR> the trick is to read then understand the error message
20:07:18 <EvanR> then know that fromIntegral is one of few ways to convert numbers, the others being realToFrac and floor
20:07:46 <monochrom> don't forget ceiling, truncate, round :)
20:08:00 <EvanR> i already forgot
20:08:02 <manyone> i already knew about fromIntegral but i was putting it in the wrong place.  thank you again
20:08:26 <Eduard_Munteanu> :t genericLength
20:08:28 <lambdabot> Num i => [a] -> i
20:08:59 <EvanR> @src genericLength
20:08:59 <lambdabot> genericLength []    = 0
20:08:59 <lambdabot> genericLength (_:l) = 1 + genericLength l
20:09:08 <EvanR> i dareday use fromIntegral . length instead
20:09:12 <EvanR> say*
20:09:43 <monochrom> yes, I think fromIntegral.length is more efficient
20:09:45 <Axman6> yeah genericLength will have a habit of blowing up your stack
20:10:11 <EvanR> foldl
20:10:29 <EvanR> foldl' succ 0
20:10:53 <EvanR> still
20:11:04 <nshepperd> > [1,2,3,1] & upon head .~ 0
20:11:06 <lambdabot>  [0,2,3,1]
20:11:07 <Eduard_Munteanu> :t foldl' (+) 0 . map (const 1)
20:11:09 <lambdabot> Num c => [b] -> c
20:11:28 <Axman6> Eduard_Munteanu++
20:11:40 <EvanR> Enum would be even more generic! maybe
20:12:00 <EvanR> Enum as counter for fun and profit
20:12:29 <monochrom> Enum probably doesn't mix well with Complex Double
20:12:51 <EvanR> > [0..] :: [Complex Double]
20:12:53 <lambdabot>  error:
20:12:53 <lambdabot>      • No instance for (Enum (Complex Double))
20:12:53 <lambdabot>          arising from the arithmetic sequence ‘0 .. ’
20:12:58 <EvanR> WHAT
20:13:16 <Eduard_Munteanu> Would be useful if genericLength could somehow get the strictness of the type into consideration.
20:13:23 <Axman6> what should [1 :+ 0 .. 0 :+ 1] be?
20:13:43 <Eduard_Munteanu> For non-strict types, I'd much rather have a foldr.
20:13:47 <Axman6> Eduard_Munteanu: genericLength basically only exists so you can do length with Nat
20:13:51 <EvanR> by analogy to Double Enum, [1:+0, 0:+1]
20:14:11 <monochrom> genericLength (or any parametric polymorphism) is not going to be able to see the strictness of your type.
20:14:54 <Eduard_Munteanu> Well, Num would be a good place to expose that.
20:15:13 <monochrom> But it chose a kind of foldr because "maybe your type is the Peano numbers so foldr is less restrictive"
20:16:13 <nshepperd> . o O (class Strictness a where { isStrictMonoid :: Proxy a -> Bool })
20:16:25 <EvanR> i just read about the Eval class
20:16:32 <EvanR> the old way seq worked
20:16:41 <EvanR> and the case study which found it horrible
20:16:51 <glguy> nshepperd: might be nice as a type family
20:17:54 <Eduard_Munteanu> The decision should be taken at compile-time though.
20:18:31 <glguy> yeah, that's why type family would be good
20:18:52 <dfeuer> EvanR: I'd love to see more work on making that work better somehow.
20:19:42 <ski> EvanR : ooi, where did you read about that ?
20:20:12 <EvanR> http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
20:21:03 <EvanR> there are no page numbers....
20:21:10 <EvanR> page 32
20:21:24 <Eduard_Munteanu> And perhaps let Foldable's fold turn into foldl' or foldr depending on strictness.
20:21:30 <ski> section 10.3, i presume
20:21:35 <EvanR> yes
20:21:36 <Eduard_Munteanu> (and genericLength = fold)
20:27:51 <elrikdante> so I was able to solve the problem. =) https://github.com/elrikdante/hacker-rank-hs/blob/master/errata/SUCCESS6.gif
20:28:07 <elrikdante> I doubt I would've passed if QuickCheck was generating the test cases!
20:28:17 <EvanR> ski: an odd thing there is that the solution, at the time, was to eliminate Eval class and make seq have a normal polymorphic type. and then it says the optimization that it would break was left in but "is unsound"
20:28:35 <elrikdante> thanks EvanR et al!
20:30:01 <ski> EvanR : odd, why ?
20:30:22 <EvanR> does it mean the optimization is done anyway even if it would break code
20:31:31 <ski> afaiui, yes
20:32:55 <EvanR> so that seems odd
20:33:21 <ski> `foldr undefined 0 (build seq)' is `0', but `seq undefined 0' is `undefined'
20:34:40 <ski> (EvanR : unrelatedly, in section 10.4.1, "algorithmic debugging" is also known as "declarative debugging")
20:37:44 <ski> (see Buddha <https://web.archive.org/web/20091122221642/http://ww2.cs.mu.oz.au/~bjpop/buddha/>. also see the papers on the declarative debugger in Mercury, at <https://www.mercurylang.org/documentation/papers.html>)
20:38:41 <qmm> why is this invalid?  length' x | null x = 0 | otherwise = 1 + length' $ tail x -- while this is valid:  length' x | null x = 0 | otherwise = 1 + length' (tail x)
20:39:16 <Axman6> because that gets parsed as (1 + length) $ tail x
20:39:38 <EvanR> (1 + length) (tail x)
20:39:46 <ski> `+' binds more tightly than `$'
20:40:16 <qmm> infixl 6 + vs infixr 0 $
20:40:18 <qmm> thanks
20:41:31 <qmm> i guess this is a good time to understand how infixl and infixr operate at a high level
20:44:49 <nshepperd> Eduard_Munteanu: it would be, if the declaration is inlined...
21:18:05 <jchia> How do I easily express the infinite list ["a", "b", ..., "z", "aa", "ab", .., "az", "ba", "bb", .., "bz", "ca", ...]. Basically, I just want an endless supply of text names that are easy for a human to read.
21:21:31 <Axman6> :t filterM (const [True,False])
21:21:32 <lambdabot> [b] -> [[b]]
21:22:10 <Axman6> > filterM (const [True,False]) ['a'..'z'] -- not what you want, but I think something similar can be used...
21:22:12 <lambdabot>  ["abcdefghijklmnopqrstuvwxyz","abcdefghijklmnopqrstuvwxy","abcdefghijklmnopq...
21:22:30 <Axman6> > filterM (const [False,True]) ['a'..'z']
21:22:32 <lambdabot>  ["","z","y","yz","x","xz","xy","xyz","w","wz","wy","wyz","wx","wxz","wxy","w...
21:23:08 <Philippa> jchia: so you want ['a'..'z'], then you want to add each of those in front of all of those, then you want to do the same to /that/ list ad nauseam?
21:26:29 <Xnuk> > iterate (\x -> [b:a | b <- ['a'..'z'], a <- x ]) [""]
21:26:32 <lambdabot>  [[""],["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","...
21:26:55 <Xnuk> > iterate (\x -> [b:a | b <- ['a'..'z'], a <- x ]) [""] ! 2
21:26:57 <lambdabot>  error:
21:26:57 <lambdabot>      • Couldn't match expected type ‘Array Integer e’
21:26:57 <lambdabot>                    with actual type ‘[[[Char]]]’
21:27:01 <Xnuk> > iterate (\x -> [b:a | b <- ['a'..'z'], a <- x ]) [""] !! 2
21:27:03 <lambdabot>  ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao",...
21:27:04 <Xnuk> > iterate (\x -> [b:a | b <- ['a'..'z'], a <- x ]) [""] !! 3
21:27:07 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
21:29:22 <Axman6> > let names :: [a] -> [[a]]; names xs = go (fmap (:[]) xs)  where go ys = ys ++ go ((:) <$> xs <*> ys) in names "abcd"
21:29:25 <lambdabot>  ["a","b","c","d","aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","cd"...
21:29:59 <Axman6> > let names :: [a] -> [[a]]; names xs = go (fmap (:[]) xs)  where go ys = ys ++ go ((:) <$> xs <*> ys) in names "0123456789"
21:30:01 <lambdabot>  ["0","1","2","3","4","5","6","7","8","9","00","01","02","03","04","05","06",...
21:31:14 <Axman6> may be slightly shorter with liftA2 (:) xs ys
21:31:32 <Axman6> @pl go ys = ys ++ go ((:) <$> xs <*> ys)
21:31:32 <lambdabot> go = fix (ap (++) . (. (((:) <$>) . (xs <*>))))
21:31:50 <Axman6> @pl go ys = ys ++ go (liftA2 (:) xs ys)
21:31:50 <lambdabot> go = fix (ap (++) . (. liftA2 (:) xs))
21:37:51 <nshepper1> > fix (\xs -> [""] ++ liftA2 (flip (:)) xs "abc")
21:37:54 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","ca...
21:38:27 <nshepper1> i suppose that should be "" :
21:50:44 <fragamus> howdy
21:50:54 <Axman6> o/
22:22:28 <ski> exercise : extend to enumerating binary trees
22:23:04 <athan> How is `view` implemented? view l = runConst . l . Const ?
22:23:41 <Axman6> I believe so
22:23:58 <athan> that's awesome :)
22:24:08 <athan> is that why it's a "profunctor optic"?
22:24:23 <athan> 'it' meaning 'lens'
22:24:41 <Axman6> that might be why it's a van Laarhoven lens... but I'm not sure.
22:25:33 <Axman6> seeing how both set and over are implemented is pretty educational
22:25:38 <ski> > filterM (const [False,True]) "abc"
22:25:41 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
22:25:50 <ski> > foldr (\c ss -> [id,(c:)] <*> ss) [[]] "abc"
22:25:52 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
22:25:55 <ski> > foldr (\c ss -> ss <**> [id,(c:)]) [[]] "abc"
22:25:57 <lambdabot>  ["","a","b","ab","c","ac","bc","abc"]
22:26:12 <Axman6> <**>?
22:26:19 <Axman6> :t (<**>)
22:26:21 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
22:26:28 <ski>   liftA2 (flip ($))
22:26:55 <Axman6> or flip (<*>)
22:27:01 <ski> nope
22:27:04 <Axman6> no?
22:27:08 <ski> (except for commutative idioms)
22:27:11 <athan> Thank you Axman6!
22:27:13 <Axman6> oh, ordering might be different
22:27:32 <ski> (as was the case here, for lists)
22:27:44 <Axman6> yeah
22:27:46 <ski> (iow, ordering mattering)
22:28:36 <Axman6> :t (_Just . _Left) (\x -> (x,x))
22:28:38 <lambdabot> Monoid a => Maybe (Either a c) -> (a, Maybe (Either a c))
22:31:42 <ski> > fix (\xs -> [""] ++ (xs <**> ((:) <$> "abc")))  -- slight rewording of nshepper1's version
22:31:45 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","ca...
22:36:59 <ski> > fix (\ss -> [""] ++ [c:s | s <- ss,c <- "abc"])
22:37:00 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","ca...
22:37:19 <ski> > (concat . take 3 . fix) (\sss -> [[""]] ++ [[c:s | s <- ss,c <- "abc"] | ss <- sss])  -- upto a given length
22:37:22 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc"]
22:37:23 <ski> > (concat . take 3 . fix) (\sss -> [[""]] ++ map (<**> ((:) <$> "abc")) sss)
22:37:26 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc"]
22:38:28 <athan> ugh man, I still don't get how traverse is a lens... maybe... wait...
22:38:45 <athan> Lens ~ Functor f => (b -> f b) -> a -> f a
22:39:06 <athan> Traversalamente ~ Applicative f => (b -> f b) -> a -> f a
22:39:10 <athan> holy crap
22:40:33 <athan> and view won't work for a traversal beacuse Const isn't an applicative?
22:41:03 <athan> er... because.. monoids or something
22:45:13 <Axman6> Const should be an Applicative afaict, possibly with a constraint on the first type param being a Monoid, yes
22:51:15 <nshepper1> athan: all Lenses are Traversals. or can be used as Traversals
22:51:44 <nshepper1> 'traverse' (from the Traversable type class) is a Traversal
22:51:49 <nshepper1> :t view _1
22:51:51 <lambdabot> (Field1 s s b b, MonadReader s m) => m b
22:51:57 <nshepper1> :t view traverse
22:51:59 <lambdabot> (MonadReader (t a) m, Monoid a, Traversable t) => m a
22:53:00 <athan> ahh wow oay
22:53:01 <athan> okay*
22:53:19 <nshepper1> view for a traversal has the monoid constraint because of the Monoid a => Applicative (Const a)
22:53:29 <nshepper1> which has the effect of smushing together all the viewed items
22:53:37 <athan> can a Traversable be turned into a list in general?
22:53:48 <nshepper1> yeah
22:54:05 <athan> ahh! wow okay, that's perfect. Thank you nshepper1 :)
22:56:41 <athan> oh woah! Do traversals allude to prisms?
22:56:51 <athan> because a prism ~ Maybe a, where traversal ~ [a]?
22:58:09 <nshepper1> sort of, yeah
23:00:17 <nshepper1> I haven't really studied prisms.. but what I read from kmett was that they are for like the different branches of a variant
23:00:23 <nshepper1> x or y or a
23:01:13 <nshepper1> when you combine a lens and prism you get back a Traversal. because Traversal is like the lowest common denominator i guess
23:02:07 <athan> oh wow! okay that makes a lot of sense
23:04:46 <nshepper1> apparently the main benefit is that prisms are reversible
23:05:10 <EvanR> where did all these names come from, lens, prism
23:05:21 <nshepper1> a thesaurus, probably
23:09:35 <athan> space lasers
