00:08:31 <BalterNotz> hello
00:08:35 <BalterNotz> ?
00:09:48 <BalterNotz> Hello?
00:12:19 <pavonia> Yes, we can read you
00:20:26 <BalterNotz> nice to meet you, pavonia, this is my first time comunication with foreign people use irc 
00:20:41 <BalterNotz> it's very magical
00:21:20 <uiop> BalterNotz: have you put on your cloak and wizard hat yet?
00:28:47 <BalterNotz> uiop: I have to spend some time to understand your message. My English is not good.
00:29:37 <uiop> BalterNotz: oh, nevermind then. it was a joke :)
00:32:15 <ongy> uiop: you aren't wearing your cloak either
00:32:42 * uiop puts on his cloak and wizard hatr
00:38:06 <BalterNotz> uiop: I will read some irc tutorial, to find, what is the cloak and wizard hat
00:41:06 <uiop> BalterNotz: heh
00:42:02 <uiop> BalterNotz: i will save you some time http://www.bash.org/?104383
00:43:44 <BalterNotz> uiop: thx very much
00:44:29 <uiop> BalterNotz: de nada
01:00:39 <BalterNotz> #game
01:25:16 <jchia1> Is there a Data.Binary.Put counterpart for Data.Binary.Get.isolate? I.e. I want to make sure that my `put` puts a certain number of bytes, no more and no less?
01:25:48 <jchia1> I suppose such things can be tested in a unit test, so it's not really necessary.
01:32:20 <ongy> I don't think put is supposed to fail, so I doubt that it makes sense to put it in either way
01:54:20 <_sg> Hi
01:56:25 <thatguy> (all) am I doing something wrong when all my function calls basically look like fun 1 (fun 2 (fun 3 x))
01:56:31 <thatguy> I mean if I am using that many brackets
01:59:43 <roxxik> tahatguy: not generally, but don't you think `fun 1 . fun 2 . fun 3 $ x` looks better?
02:01:57 <roxxik> i don't think there's anything wrong with some brackets, but it starts to look confusing if you use too many, depends on your structuring....
02:11:00 <haskell687> last2 :: [Int] -> Int
02:11:04 <haskell687> last2 xs = xs!!((length xs)-1)
02:11:09 <haskell687> can anyone tell me how this works?  
02:11:15 <haskell687> I'm not sure what the -1 is doing
02:11:20 <haskell687> I know !! is take basically
02:11:23 <haskell687> so take some stuff from cs
02:11:25 <haskell687> xs*
02:11:38 <haskell687> but ((length xs)-1) is a little confusing
02:11:46 <haskell687> thanks
02:13:00 <roxxik> because the last element has index length - 1
02:13:09 <haskell687> what's the -1?
02:14:27 <roxxik> basically if you got some opaque elements (a..d) you index them like: 0: a,  1: b, 2: c, 3: d (having a length of 4) so the last index is calculated by (length list) - 1
02:15:11 <haskell687> is there a null pointer?
02:15:14 <roxxik> nope
02:15:34 <roxxik> (better answer: not in safe haskell)
02:17:20 <haskell687> wait so there's an extra element added on the end that contains the entire length of the list?
02:17:23 <haskell687> d (having a length of 4)
02:17:55 <haskell687> if I enter [1,2,3]
02:18:02 <haskell687> I'm seeing it as [1,2,3] but something else added to the end
02:18:04 <haskell687> to go back to 3
02:18:08 <haskell687> that's what I'm seeing
02:20:42 <roxxik> no there is no extra element
02:21:01 <roxxik> > [1,2,3]
02:21:04 <lambdabot>  [1,2,3]
02:21:10 <roxxik> > length [1,2,3]
02:21:13 <lambdabot>  3
02:21:24 <roxxik> > [1,2,3] !! 0
02:21:26 <lambdabot>  1
02:21:32 <roxxik> > [1,2,3] !! 2
02:21:34 <lambdabot>  3
02:21:48 <roxxik> no show me what you see
02:22:09 <haskell687> I see
02:22:09 <haskell687> :P
02:22:16 <haskell687> because the length is 3
02:22:20 <haskell687> but then you take that, -1
02:22:25 <haskell687> so then you get [1,2,3] !! 2
02:22:29 <haskell687> right?
02:22:30 <roxxik> exactly
02:22:39 <haskell687> thanks very much for the clarification :)
02:22:53 <roxxik> > let f xs = xs !! (length xs - 1) in f [1,2,3]
02:22:55 <lambdabot>  3
02:23:19 <haskell687> yes, ty
02:23:31 <roxxik> no prblem :)
02:24:00 <thatguy> roxxik, ok thanks
02:30:21 <haskell687> [tail, init, reverse] :: [[a] -> [a]]
02:30:37 <haskell687> how come the input is a list of a polymorphic type and an output of a polymorphic type?
02:32:00 <uiop> haskell687: they are the *same* type, whatever it may be
02:32:38 <roxxik> :t [tail, init, reverse]
02:32:40 <lambdabot> [[a] -> [a]]
02:33:02 <haskell687> so the functions tail, init and reverse can take a variety of types?
02:33:23 <roxxik> kind of... yes
02:33:28 <roxxik> :t \x -> x
02:33:31 <lambdabot> t -> t
02:33:46 <roxxik> this is called id and can be applied to any type
02:34:06 <roxxik> reverse can only be applied to lists of every element type
02:34:22 <haskell687> id?
02:34:25 <roxxik> :t id
02:34:27 <lambdabot> a -> a
02:34:31 <roxxik> > id 5
02:34:33 <lambdabot>  5
02:34:59 <haskell687> if reverse can only be applied to lists of every element type
02:35:02 <haskell687> surely tail and init can too?
02:35:29 <roxxik> there type says it all
02:35:30 <roxxik> :t tail
02:35:32 <lambdabot> [a] -> [a]
02:35:44 <haskell687> :t init
02:35:46 <lambdabot> [a] -> [a]
02:35:51 <haskell687> :t reverse
02:35:53 <lambdabot> [a] -> [a]
02:35:56 <haskell687> ah ok
02:35:59 <haskell687> so
02:36:20 <haskell687> why the extra square brackets around the whole [a] -> [a]?
02:36:26 <roxxik> if you know some more haskell you'll learn that this is equivalent to forall a. [a] -> [a] which says that you can apply to any list of a's (the forall is just implictly added for ease of typing)
02:36:41 <roxxik> because you provided a list of functions
02:36:44 <roxxik> :t tail
02:36:46 <lambdabot> [a] -> [a]
02:36:47 <roxxik> :t [tail]
02:36:49 <lambdabot> [[a] -> [a]]
02:37:12 <haskell687> ahhhhh
02:37:16 <haskell687> ok I get it now, thank you again
02:37:30 <qcrvszvz> I'm trying to use dbus from hackage to build a… thing, that interface with the logind inhibitor api. Logind tries to send me a file descriptor, which the dbus lib seems to support. Yet dbus-monitor says DBus itself is sending logind an error saying that my client does not support receiving a fd. Any ideas what I could try to fix that?
02:39:30 <qcrvszvz> (the idea that the lib should support it is because there is code to marshal/unmarshal filedescriptors for sending over the wire)
02:40:15 <malinoff> hi, can I override .stack-work location?
02:41:47 <roxxik> malinoff: [0] seems related 0: https://github.com/commercialhaskell/stack/issues/1178
02:42:25 <malinoff> roxxik: thanks
02:51:30 <Faizan> o hello
02:51:34 <Faizan> koei zinda hia yahan k nahi 
02:52:06 <haskell687> sameListIndex (x:xs) (y:ys) n = sameListIndex xs ys (n - 1)
02:52:37 <haskell687> basically this function takes 2 lists and then checks the index with n
02:52:45 <haskell687> but I don't know how the sameListIndex xs ys stuff works
02:52:55 <haskell687> it's recursion so it's a bit tricky, can someone explain the stuff after the = for me?
02:53:40 <roxxik> that is not the whole function, isn't it?
02:53:55 <haskell687> no
02:54:03 <haskell687> http://pastebin.com/xswLaD4F
02:54:38 <roxxik> ah ok you want to know whether two elements (at the same index) are equal
02:54:41 <haskell687> I understand all the stuff except last line
02:54:42 <haskell687> yeah
02:55:24 <roxxik> if you have two non empty lists and an index, that is non zero <- that is the stuff before the =
02:56:22 <erisco> is groups-0.4.0.0 defacto for groups?
02:56:23 <haskell687> oh I think I get this now
02:56:36 <haskell687> xs and ys are kept being inputted because the list keeps getting chopped up right?
02:56:45 <haskell687> and those are inputted until you have nothing left
02:56:53 <roxxik> kind of...
02:57:05 <haskell687> ?
02:57:45 <roxxik> you recurse on a smaller data structure (that's the most common kind of recursion)
02:57:54 <roxxik> so you destructure your lists as you go
02:58:08 <roxxik> up until one is empty or the index is zero
02:58:32 <roxxik> so if none of this conditions hold, you just chop up the lists and recurse
02:58:57 <haskell687> the smaller data is just simply the list right
02:58:58 <haskell687> ?
02:59:09 <roxxik> yah
02:59:16 <haskell687> ok, I get it, thanks
02:59:47 <roxxik> that's an really easy way to make any computation over recursive data types
03:06:39 <tabaqui1> what's the point of using Data.Vector?
03:06:49 <erisco> tabaqui1, speed
03:06:51 <tabaqui1> it still has O(n) complexity of append and insert
03:07:05 <tabaqui1> s/append/prepend
03:07:09 <erisco> it is an array. What else would you expect?
03:07:23 <tabaqui1> O(1) of append || O(1) of prepend
03:07:27 <tabaqui1> not O(n) for both
03:07:37 <erisco> are you thinking like C++ vectors?
03:07:45 <tabaqui1> yep, why not?
03:07:50 <erisco> they are not dynamic arrays, no
03:07:57 <roxxik> speed is maybe not best here. data locality would be better
03:08:22 <tabaqui1> but I can't do inplace operations in Haskell
03:08:29 <geekosaur> qcrvszvz, poking at the code to dbus, it's not marshaling fds correctly and it can't because the network package doesn't expose sendmsg or the SCM_RIGHTS flag
03:08:34 <erisco> you can with MVector, which is mutable
03:08:41 <roxxik> data locality gives you an increase in speed but not asymptotically
03:09:24 <roxxik> and Landau notation talks about asymptotic behaviour
03:09:27 <geekosaur> that is, it tries to send/receive fds as normal data, but they have to be sent as a special message type
03:10:04 <erisco> you may want to consider sequences
03:10:15 <tabaqui1> ok, O(n) - it's a worst case?
03:10:26 <erisco> that is what that means, yes
03:11:05 <tabaqui1> eh, actually we should use Omega and Theta symbols for it
03:11:46 <erisco> Θ(n)
03:12:13 <tabaqui1> maybe, not sure
03:12:28 <tabaqui1> anyway
03:12:50 <tabaqui1> vector in C++ allocs some memory
03:13:08 <tabaqui1> and while I append not much values, it takes constant time for it
03:13:24 <tabaqui1> Data.Vectors behaves similarly?
03:13:44 <erisco> no
03:14:05 <erisco> vectors in C++ are dynamic arrays meaning that they resize themselves to accommodate more elements
03:14:09 <erisco> Data.Vector does not do this
03:14:13 <tabaqui1> reallocations after each operation?
03:14:28 <qcrvszvz> geekosaur: schucks :$
03:14:33 <erisco> to add an element you must copy the array each time
03:15:08 <tabaqui1> MVectors too?
03:15:11 <erisco> yes
03:15:21 <tabaqui1> that sucks! I don't get any performance here
03:15:51 <erisco> well, you can pull off the gloves and use unsafe operations
03:16:01 <roxxik> can't you collect all your elements and then do a one time append to your array?
03:16:03 <erisco> maybe there is a library out there that already does this. I don't know
03:16:20 <Adeon> you can implement the C++ vector resizing with MVector although I think the vector package itself doesn't provide anything ready
03:16:30 <tabaqui1> hmm
03:16:48 <erisco> that's right, you can use unsafe operations if you wish, so it is implementable
03:16:51 <tabaqui1> well, Data.Array is just like Paskal array, right?
03:17:21 <Adeon> also even with immutable vectors when you make updates, what you can do is get a copy of original vector as mutable vector
03:17:25 <Adeon> then do bunch of mutable operations
03:17:29 <Adeon> and then freeze the vector back to immutable
03:17:44 <erisco> afaik Data.Array is essentially no different than Data.Vector. It is just that Data.Vector has an improved API
03:18:58 <tabaqui1> Data.Array cannot be extend
03:19:04 <tabaqui1> as I understand it correctly
03:19:07 <nbtiwires> Hello friends, I'm a bit lost in Vector vs MVector. How to thaw `MVector s Int` to `MVector PrimState (ST s)) Int`? Here is code http://ix.io/1QyP , toppleOnce function.
03:19:30 <Adeon> I think the main difference is that vectors are always indexed by a single Int whereas Data.Array arrays can have more complicated indexes (indices?)
03:19:52 <Adeon> you can extend anything if you think of making a bigger copy as extend
03:20:17 <erisco> ah yes, they simplified the indexing scheme in Data.Vector
03:20:19 <qcrvszvz> geekosaur: https://hackage.haskell.org/package/network-2.6.3.1/docs/Network-Socket.html#g:10 ?
03:20:22 <Adeon> there is a `grow` function on mutable vectors but I'm not sure if it tries to reallocate the existing vector or if it makes a totally new vector
03:20:32 <Adeon> but even the C++ vector can make a totally new copy on append
03:20:37 <Adeon> it just usually doesn't
03:20:58 <Adeon> as far as I understand behind the scenes it has a vector of N elements, which is the capacity and M elements which is the actual size reported
03:21:17 <Adeon> and then the actual size would grow beyond capacity you allocate a new C++ vector of (N*2) elements and copy the old stuff to the new vector
03:21:18 <geekosaur> hm, missed that. dbus package still isn't using it...
03:21:21 <Adeon> or something liek this
03:21:45 <geekosaur> it just marshals as normal data in-line, no provision to send the control message
03:21:53 <Adeon> all of which is doable in haskell it's just that afaik the vector library doesn't implement it for you
03:23:26 <erisco> nbtiwires, thaw converts Vector to MVector
03:23:30 <Axman6> nbtiwires: I think you'll find that PrimState (ST s) == s
03:23:52 <Axman6> so MVector (PrimState (ST s)) Int == MVector s Int
03:23:58 <qcrvszvz> geekosaur: looks to me like dbus' protocol has type-flags preceding the values sent; shouldn't it be possible then to call {send,receive}Fd when we would expect there to be a fd?
03:24:10 <Axman6> try running :kind! PrimState (ST s) in GHCi
03:25:03 <geekosaur> the current Haskell implementation assumes everything can be marshaled to/from a ByteString and sent/received in one message; it has no provision to send a separate message with the SCM_RIGHTS control data
03:25:10 <erisco> mutable vectors in Haskell are already an unpleasant spot to be in
03:25:18 <geekosaur> much less to include that in a normal message
03:25:31 <nbtiwires> Thanks disco, Axman6! Yeah, I though that, but ghc complains he cannot convert one to another http://ix.io/1QyS Maybe it need more type signatures?
03:25:45 <qcrvszvz> geekosaur: yeah; that would break all the pretty abstractions :-(
03:25:53 <nbtiwires> erisco! sorry, autocorrect
03:26:16 <erisco> at a glance, you might be conflating unboxed and boxed vectors
03:26:30 <absence> is it somehow possible (language extension or otherwise) to pass parameters to infix operators? say i have f x y z = undefined, something like a `f n` b
03:27:12 <tabaqui1> absence: f x y z
03:27:18 <tabaqui1> x `f` y z
03:27:37 <tabaqui1> remember about the currying
03:27:41 <erisco> let g = f n in a `g` b
03:27:56 <tabaqui1> :t flip
03:27:58 <lambdabot> (a -> b -> c) -> b -> a -> c
03:28:04 <ongy> @unpl x `f` y z
03:28:04 <lambdabot> (f x (y z))
03:28:19 <erisco> precedence woes
03:28:19 <tabaqui1> ongy: oh, right)
03:28:45 <Boomerang> > let f x y z = x + y * z in (2 `f` 3) 4
03:28:47 <lambdabot>  14
03:29:11 <absence> tabaqui1: the arguments would be in the wrong order even if it worked, but thanks :)
03:29:13 <erisco> what you want to do is define a family of functions indexed by n
03:30:09 <absence> erisco: sounds right
03:30:41 <nbtiwires> erisco: thanks, right import fixed it
03:30:53 <qcrvszvz> Time to learn the FFI then, I guess
03:31:01 <erisco> well that's how a lot of maths texts go :P I don't know of any extension for this
03:31:35 <erisco> don't be allergic to ternary operators
03:32:28 <absence> erisco: ternary operators?
03:32:36 <erisco> that is what you have
03:32:43 <erisco> it takes three arguments does it not?
03:33:01 <ongy> qcrvszvz: do you want to improve the dbus package, or make your own bindings?
03:33:27 <erisco> in a theoretical setting you may not want to actually have this as a function, hence a family of functions, but that's not the setting we're in
03:33:52 <absence> yes. since i'm trying to use one, i didn't feel allergic to it, and was confused by your advice to not be allergic to it :)
03:34:35 <erisco> okay, well, it just seemed suspiciously like the phenomenon I see in maths notations
03:34:53 <erisco> where instead of just accepting more arguments they instead adorn symbols with a plethora of subscripts and superscripts
03:35:07 <qcrvszvz> ongy: I was planning to build a small module that does all the logind inhibitor stuff (specifically) in C with a (hopefully) simple haskell binding
03:35:22 <qcrvszvz> ongy: Improving dbus would, of course, be the way to go; but that seems… a hassle
03:35:37 <erisco> possibly influenced by the lack of typing
03:35:49 <absence> erisco: but in haskell i basically have to define a bunch of aliases like the let g = f n in ... example?
03:36:25 <erisco> possibly, yes
03:36:40 <erisco> if there are finite n you can merely give them all names
03:37:38 <erisco> it depends on what we're doing as to what is practical here
03:39:21 <absence> erisco: unfortunately not. i'll get by with local aliases for now though, and if it becomes too tedious down the road i'll consider making a "real" language instead of an edsl
03:41:31 <erisco> does your pattern look like  a `f n` b `f n` c `f n` … ?
03:43:32 <erisco> if that were the case then you can define g such that (a `g` b `g` c `g` …) n  is equivalent
03:44:22 <erisco> possibly Reader is an option
03:52:17 <_sg1>  Hi
03:52:46 <quchen_> Hi!
03:53:34 <erisco> why are groups, rings, semirings, etc not more prevalent
03:53:41 <erisco> I feel like I am in the Hackage boonies trying to find them
03:54:35 <ski> ertesx : hard to present in a lawless fashion, possibly
03:55:11 <erisco> what do you mean?
03:55:28 <ski> lists can be presented/normalized to right (or left) associated, so you don't have to impose extra laws (equivalences/relations) on the data type
03:55:56 <ski> (and functions can't be inspected directly, so that's how you get associativity there)
03:56:20 <ski> (finite) lists are the free monoid over the element type
03:56:43 <erisco> but so what? we use lawful classes all the time
03:57:12 <ski> if you'd present it as that, you'd have `data List a = Nil | Sing a | Append (List a) (List a)', with the associativity law and left&right neutral element (`Nil') law on `Append'
03:58:01 <ski> (and typically one'd then make it an abstract data type, in order to not allow users to distinguish between equivalent representations)
03:59:02 <ski> by associating to one side, like `Append (Sing a0) (Append (Sing a1) (..(Append (Sing an_1) Empty)..))', you can represent this as `Cons a0 (Cons a1 (..(Cons an_1 Empty)..))'
03:59:16 <ski> avoiding the need for laws on the data type
03:59:17 <erisco> I don't really know where you're going with this
04:00:22 <ski> i'm just trying to say that it's simpler to represent anarchic data in Haskell, so it's possibly what people first think of using
04:05:43 <erisco> I would say it is because you need interesting functions defined on those classes for them to have merit
04:06:24 <erisco> what interesting thing you do have with a group? pow? what else?
04:10:22 <erisco> null :: (Eq a, Monoid a) => a -> Bool; null = (==) mempty
04:11:17 <erisco> why not be more creative
04:13:35 * ertes peeks and vanishes again
04:17:19 <kuribas> is it possible to inline assembly in haskell?  For example to leverage SIMD?
04:19:17 <tabaqui1> queue package marked as deprecated
04:19:31 <tabaqui1> but I cannot find information about actual queue structure
04:19:42 <erisco> are you new to Haskell tabaqui1?
04:19:59 <tabaqui1> erisco: dunno, few months
04:20:04 <tabaqui1> is it new?
04:21:30 <erisco> you can't use Haskell effectively by trying to mimic how you use other languages
04:22:01 <erisco> when you know Python and want to use JavaScript you go down the list of usuals
04:22:17 <erisco> where are my lists, my maps, my tuples, how do I define a class, and so on
04:22:24 <erisco> what do I import to write a regex
04:23:05 <erisco> I see many people incorrectly assume the same for Haskell. Just making sure it isn't you too
04:23:35 <erisco> after having many languages be different shades of gray it isn't any fault for making the assumption
04:23:49 <NextHendrix> haskell is purple with yellow polka dots
04:24:25 <NextHendrix> adjust accordingly
04:25:39 <Axman6> kuribas: there used be a package for writing x86 assembly, I don't think it ever got ported for x86_64. you can use LLVM for that though, and take advantage of the JIT to generate code at runtime
04:27:03 <kuribas> Axman6: ah cool.
04:28:02 <Axman6> kuribas: see llvm-general
04:31:24 <tdammers> erisco: yes you can, but you have to implement DSLs that mimic the other language first
04:31:40 <erisco> there are some ACME packages for that
04:33:14 <tdammers> I forgot for a second what your other language is ;)
04:33:50 <tdammers> anyway, all joking aside
04:34:02 <tdammers> a lot of general programming principles apply to haskell all the same
04:34:14 <tdammers> separation of concerns, DRY, etc.
04:34:51 <ggVGc> I'm starting to feel Elixir is actually pretty great, althrough I miss some of the big brother watch from haskell
04:35:35 <kuribas> I cannot compile primitive-simd, it says: You are using an unsupported version of LLVM! Currently only 3.7 is supported.
04:35:35 <ggVGc> I'm starting to think immutability is maybe a lot more important than static type safety
04:35:59 <erisco> don't make me choose you monster
04:36:02 <kuribas> 3.7 being the only version that isn't in linux-mint.
04:36:46 <ggVGc> I thought elixir was gonna be frustrating after doing a fair bit of haskell, but it's turning out fine, because it's immutable even if it's dynamic
04:36:58 <ggVGc> and it's a lot more rapid to develop things
04:37:00 <suppi> i'm currently using Turtle.Prelude.err to send an error to stdout but noticed this is problematic with multiple threads. what can i use to guarantee the output won't be mix?
04:37:02 <hpc> ggVGc: just wait for SafeHaskell to grow up, it'll be extremely hard to decide which core language feature is most important ;)
04:37:08 <ggVGc> but, I guess I'll see how it works in a year when I revisit this code
04:37:33 <erisco> yes, all the software engineering principles still apply, that doesn't change
04:37:36 <suppi> ggVGc: i think it great another language is working out for you :)
04:37:53 <erisco> though I'd like to one day see unit tests expunged from the Earth
04:38:03 <ggVGc> hm, never knew about safehaskell before
04:38:14 <hpc> unit tests as a concept are alright
04:38:25 <hpc> in practice they end up being an ad-hoc type checker :/
04:38:41 <sbrg> for a lot of dynamic languages like JS and such, unit tests are only barely replacing a typechecker yeah
04:38:47 <mfukar> unit tests aren't supposed to test type safety, they're supposed to test behaviour
04:38:51 <suppi> i meant stdout -> stderr in my previous comment
04:39:07 <hpc> they're good for regression testing and shoring up shortcomings in your type system
04:39:09 <mfukar> using them to test language-level concepts can indeed be frustrating
04:39:14 <hpc> which... is absent in most languages
04:39:14 <ggVGc> hpc: funnily, I never really got into unit testing until I started using haskell, because haskell for once was so easy to write tests for. But I only do it reactively. E.g I write tests when I get unexpected behaviour, not test driven development
04:39:15 <erisco> with good enough types there is no difference between type checking and testing behaviour
04:39:23 <ggVGc> I was super interested in TDD years ago, but it never worked for me in practice
04:39:33 <hpc> yeah, i am not really a fan of TDD either
04:39:36 <sbrg> same
04:39:36 <erisco> which is what I mean when I say I'd like unit tests to be rid of eventually
04:39:39 <ggVGc> it sounds great in theory
04:39:57 <ggVGc> erisco: I think a pure language combined with unit tests for bug fixes is great
04:39:59 <hpc> my approach to coding is that if i can't understand it just by looking at the code itself, it's automatically defective
04:40:03 <ggVGc> because it makes sure you don't get regressions of fixes
04:40:05 <hpc> even if the behavior is correct
04:40:16 <erisco> ++hpc
04:40:19 <sbrg> I had this period where I really wanted to do TDD, and tried to do it in Haskell. It worked fine, I guess, but most of the time I felt like a lot of the tests I wrote were kind of .. trivial. maybe i'm just bad at writing tests
04:40:26 <hpc> maybe it gets fixed with comments or generated documentation
04:40:30 <hpc> but it has to be obviously correct
04:40:42 <ggVGc> sbrg: yep, which is why I started doing it reactively instead. E.g only testing when something behaves wrong
04:40:55 <sbrg> keeping functions small and clear(-ish) went a long way towards reasoning about their correctness, and tests just felt like I was writing them to be able to say that I had tests or something.
04:40:58 <erisco> my biggest change in programming practice is I won't even bother with complicated messes
04:41:04 <erisco> either it is straight-forward or it is wrong
04:41:10 <ggVGc> doEverything = undefined
04:41:12 <ggVGc> ^ simple
04:41:15 <hpc> ggVGc: anyhoo, the "safe" in SafeHaskell refers to type safety
04:41:28 <ertes> "TDD" sounds like a mental disease
04:41:37 <ertes> time-dissipating delusions or something
04:41:45 <ggVGc> "Hey boss, I think my team might be suffering from TDD"
04:41:52 <ertes> time dissipation disorder
04:42:09 <sbrg> time dilation disorder!
04:42:18 <sbrg> i think i'll use that as an excuse for being late sometimes
04:42:28 <ggVGc> sorry, my TDD kicked in
04:42:34 <ongy> we do a lot of DDD here
04:42:45 <absence> erisco: unfortunately not, it's more like a `f n` b `f m` c ...
04:43:11 <ggVGc> uhm, I just got a completely unmarked and unaddressed beige envelope in the mail
04:43:21 <sbrg> it's anthrax!
04:43:34 <ertes> back when CD burning was a thing i found myself buring /dev/urandom onto a disk…  "what do you mean, your drive can't read it?"
04:43:35 <ggVGc> pretty weird
04:44:01 <ongy> ertes: those were expensive, bakc when they were a thing
04:44:50 <kuribas> Do all intel processors have SIMD instructions?
04:45:00 <hpc> define "all"
04:45:10 <hpc> https://en.wikipedia.org/wiki/Intel_8086
04:45:16 <sbrg> I think you have to go back a good number of years before you find one that doesnt' support at least some of it I think
04:45:25 <ongy> define SIMD instructions, there's different sets of extensions that provide differently powerful SIMD
04:45:29 <ocharles_> Is there a way to concatenate to GHC.TypeLits.Symbols ?
04:45:39 <kuribas> hpc: all that aren't in a museum
04:45:41 <ggVGc> SIMD has been commonplace for at least a decade afaik
04:45:52 <kuribas> ongy: the ones ghc compiles to
04:46:09 <ongy> all x86_64 have at least SSE2 iirc
04:48:20 <ggVGc> has anyone here used haskell for writing workers for web services? I mean, hosting the service and handling connections woth something else, but doing the actual work with haskell programs
04:49:36 <ggVGc> I did some web service stuff in haskell a while back, and it didn't feel completely right, and currently elixir feels much better. But for the actual service implementation, elixir isn't feeling great, and I feel haskell would be more suitable
04:49:41 <ggVGc> but not sure that complexity is worth it
04:51:06 <erisco> there are oodles of things you could write with a magma in Haskell
04:51:21 <erisco> the problem is that your T -> T -> T is usually not a singleton
04:51:28 <erisco> and newtype wrappers are a PITA
04:53:54 <erisco> we're obviously missing out because of this though
04:55:19 <erisco> maybe I just have to learn lens, since I know a small part of it copes with newtype wrappers
04:55:58 <tabaqui> oh veh
04:56:03 <hpc> lens really needs a symbol language dictionary of some kind for it
04:56:09 <tabaqui> well, again
04:56:23 <tabaqui> queue package is deprecated
04:56:40 <tabaqui> where is actual queue now?
04:57:15 <erisco> are you looking for a mutable queue?
04:57:36 <ggVGc> erisco: newtype wrappers really are way too much of a PITA
04:57:37 <ertes> tabaqui: how about Data.Sequence?
04:57:39 <tabaqui> nope, persistent would fine
04:57:57 <tabaqui> ertes: a moment...
04:58:02 <ertes> tabaqui: O(1) manipulation at both ends
04:58:17 <ertes> tabaqui: https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Sequence.html
04:58:46 <ggVGc> one of my conclusions after my first major haskell project was that almost everything should be Maps, IntMaps or Data.Seqs
04:59:10 <erisco> you forgot Text
04:59:14 <hpc> ViewR and ViewL are some pretty handy data types
04:59:16 <ertes> tabaqui: in general keep the 'containers' and 'unordered-containers' packages in short-term memory…  they solve most of your casual data structure problems
04:59:24 <ggVGc> erisco: fair
04:59:30 <hpc> ggVGc: might i interest you in pugs? ;)
04:59:50 <ggVGc> perl_
04:59:51 <ggVGc> ?
05:00:01 * aggressive vomits a bit
05:00:18 * maerwald chokes
05:00:33 <hpc> lol
05:01:25 <tabaqui> ertes: yeah, sequence fits fine
05:02:12 <tabaqui> btw, treap doesn't belong to containers or unordered containers
05:02:37 <tabaqui> last time I have to implement it by myseld
05:02:57 <ertes> tabaqui: to be honest i found whenever i needed a queue what i really needed was one of: MVar, TBQueue, TMVar, TQueue
05:05:16 <niklasb> tabaqui: well treap is kind of tricky in a pure setting because it needs randomness, right?
05:05:34 <niklasb> Data.Map uses a red-black tree though
05:06:32 <ertes> niklasb: nope…  see the remarks at the top of Data.Map
05:07:00 <ertes> treaps aren't really that tricky in a pure setting, as long as the randomness is not exposed
05:07:33 <niklasb> nevermind
05:07:53 <niklasb> lol the documentation reference my friend's paper
05:08:03 <niklasb> I should probably know better
05:08:19 <ertes> i won't tell them =)
05:08:21 <erisco> rekt :3
05:08:56 <kuribas> how do I enable unboxed syntax?  Like (I# x)?
05:09:07 <ertes> kuribas: -XMagicHash
05:09:07 <erisco> MagicHash
05:09:09 <Axman6> MagicHash
05:09:15 <kuribas> right, thanks!
05:09:17 <Axman6> @quote stereo
05:09:17 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
05:09:26 <Axman6> close enough
05:09:48 <hpc> that was almost in stereophonic quadravision
05:09:51 <ertes> let's try this again…
05:10:01 <ertes> is there a function like 'map' that works for arbitrary data structures?
05:10:12 <hpc> (https://www.youtube.com/watch?v=96Y24a0cyCE)
05:10:26 <erisco> nope
05:10:35 <hpc> cinemaphonic quadravision, rather
05:10:52 <Axman6> sounds like fmap to me... (for a specific definition of 'arbitrary')
05:11:04 <Axman6> also, Data.Data IIRC gices you something which can do that
05:11:43 <ertes> monthly social experiment check…  massive failure though
05:11:51 <hpc> kuribas: side note since it's not immediately obvious, all MagicHash does is change the parsing rule for the '#' character - it doesn't have any meaning at all except by convention of how ghc names things
05:11:55 <hpc> in case you didn't already know
05:11:57 <ertes> although you might take this as a brilliant example of reverse psychology
05:12:01 <hpc> so it's not quite "unboxed syntax"
05:12:25 <kuribas> hpc right thanks
05:12:28 <hpc> ertes: have you tried turning it off and on again?
05:13:24 <kuribas> I get an error: http://lpaste.net/351455
05:13:35 <kuribas> Do I need to recompile ghc with llvm-3.7?
05:13:45 <kuribas> And why doesn't linux-mint have llvm-3.7?
05:14:02 <erisco> "We will try though..." well that's nice of them
05:14:42 <hpc> mint pulls its packages from ubuntu doesn't it?
05:15:05 <hpc> yeah, they're going to be perpetually out of date
05:15:40 <kuribas> (but it has llvm-3.4, llvm-3.5 ... and lvm-3.8)
05:18:11 <kuribas> I suppose ghc uses llvm as external process?
05:18:17 <Axman6> 5yes
05:18:32 <Axman6> it outputs LLVM IR text files and calls opt on them IIRC
05:19:11 <Axman6> I believe there are plans to ship LLVM with GHC so things don't get broken when a new LLVM is released and it's not compatible with GHC anymore
05:21:08 <erisco> absence, I am always happy writing ugly, verbose syntax so long as the concept is clear
05:21:25 <erisco> unfortunately the source itself is no longer suitable to convey that concept
05:21:28 <kuribas> Axman6: or llvm should introduce breaking changes every release..
05:21:54 <Axman6> they're already quite good at that =)
05:22:06 <Axman6> (I assume you meant shouldn't)
05:22:31 <kuribas> yeah shouldn't
05:39:10 <romano> hi guys
05:39:54 <romano> in your experience, is it worth trying to do parallel computations (using strategies) on a 2-core machine?
05:40:32 <Axman6> probably depends on the actual problem
05:40:52 <romano> i have not been able to get any speedups on 2 cores and i'm wondering whether they are even possible on such a small number of cores
05:41:12 <Unode> there's always advantages to parallelizing if the task is parallelizable
05:41:48 <romano> it is expresses as a map so i think it is parallelisable
05:42:13 <romano> but so far my parallel versions are slower than sequential ones :)
05:42:49 <romano> i have played with different granularities and strategies (rseq, rdeepseq, rpar) but so far no luck
05:43:42 <romano> just wondering if it's my implementation or maybe on 2 cores the overheads of threaded runtime and gc are just too big
05:44:53 <romano> unfortunately can't test with ThreadScope because my eventlog is 1.1g and basically TS kills my machine trying to load it :)
05:45:35 <romano> btw. do you guys know if it is possible to make the eventlog smaller somehow so it's manageable?
05:45:52 <ertes> romano: paste your code
05:46:01 <ertes> (parallelisation)
05:55:13 <romano> ertes, this is one of the versions i tried http://lpaste.net/351456
05:55:43 <romano> ertes, compiled with -threaded and run with +RTS -N2 of course
05:56:06 <romano> ertes, it is slower than non-threaded :)
05:59:36 <ertes> romano: hmm…  nothing obviously wrong with it…  does an individual 'mostSimilar' computation take a non-trivial amount of time?  you shouldn't create too small sparks
05:59:56 <ertes> also is your CPU actually dual-core?  or is it a single core with hyperthreading?
06:00:32 <romano> ertes, my cpu is dual core
06:01:39 <romano> ertes, single mostsimilar computation is non-trivial, it depends but it's 500ms-1s on my machine
06:02:31 <x1n4u> hello everyone, i'm training to communicate with chrome via it's native message client interface, for that i need to read the first 4 bytes of the message to get the lengt, anyone an idea how i can do that.
06:03:13 <ertes> romano: so things that can go wrong include:  too finely grained sparks, inadvertent sharing, bad parallel GC performance (see +RTS -S)
06:03:53 <ertes> x1n4u: what's your level of haskell?
06:05:01 <romano> ertes, thanks. what do you mean by inadvertent sharing? 
06:05:43 <ertes> romano: i can't think of a simple example, but basically threads competing to update the same thunks
06:06:03 <ertes> romano: it's unlikely in a parList* scenario
06:06:18 <x1n4u> ertes, more lie beginner why ?? is this the wrong channel, if so i'm sorry
06:06:24 <romano> ertes, is it about 'passing work' rather than a value?
06:06:28 <x1n4u> s/lie/like
06:06:36 <ertes> x1n4u: the solution depends on it =)
06:06:55 <romano> ertes, and then threads trying to evaluate the same thing separately?
06:07:51 <ertes> x1n4u: a beginner solution would be to create a thread and loop explicitly, reading block by block, then send each finished datagram to an MVar for another thread to pick up
06:08:23 <ertes> x1n4u: if you're comfortable with parser combinators, attoparsec can help you a lot
06:08:47 <Gurkenglas> Could we have do notation automatically lift all lines of a do block to their least upper common monad transformer stack?
06:08:52 <ertes> x1n4u: a non-beginner solution would be to use stream processing, particularly pipes-group
06:09:20 <x1n4u> ertes: ok, thanks. i'm going to take a look at those options. 
06:09:39 <owoce> hey everyone, i have a quick question
06:09:46 <owoce> what happened to the At typeclass?
06:09:51 <owoce>  i've seen it mentioned in a few places but it's not on hoogle, and the name makes googling pretty hard.
06:09:56 <ertes> x1n4u: pipes-group can split a stream into chunks to process individually without giving up the streaming nature, but it requires understanding of free monads and being comfortable with all kinds of lifting between monads
06:10:55 <ertes> romano: yeah, as far as i know threads take an optimistic approach:  take the pointer, put a "black hole", evaluate, put result back
06:11:07 <ertes> romano: if they compete, one of them has to wait
06:11:22 <ertes> although in that case the RTS will most likely jus schedule another thread
06:11:45 <ertes> owoce: lens package
06:11:51 <ertes> @package lens
06:11:51 <lambdabot> http://hackage.haskell.org/package/lens
06:12:17 <mettekou> Is there a way to align data in several columns using annotated-wl-pprint/ansi-wl-pprint aside from manually computing the length of the data and then adding spaces?
06:12:41 <ertes> mettekou: not in ansi-wl-pprint at least
06:12:57 <romano> ertes, i just though of another potential problem, maybe it's because the computations do not take the same amount of time and time is wasted waiting for the longer lasting computation?
06:13:03 <mettekou> ertes: Drats.
06:14:04 <quchen_> Even calculating the width won’t help you, since this breaks if your document contains line breaks inside cells
06:14:09 <quchen_> mettekou: ^
06:14:25 <mettekou> quchen_: It doesn't, so that's not an issue.
06:14:48 <ertes> mettekou: do you mean newspaper-style columns?  or more like a table?
06:14:55 <romano> ertes, the worst thing is i have no visibility on what the rts is doing. i believe you don't use any debugging tools but perhaps you know how to shrink the size of an eventlog so that threadscope doesn't crash trying to load a 1g file?
06:15:20 <ertes> romano: yes, parList* work under the assumption that each spark takes about the same amount of time
06:15:54 <ertes> romano: well, not quite…  but in any case you will benefit from homogenous sparks
06:16:08 <ertes> romano: however, i would expect it to at least *somewhat* work
06:16:19 <bennofs> Is there a git repo that contains stackage snapshot meta data, like there is all-cabal-hashes and all-cabal-files?
06:16:21 <mettekou> ertes: Well, I would like to show the context of a type checker as a few lines of the shape "<name> : <type>" where there is space before the colon for names which are shorter than the longest name.
06:16:39 <ertes> so like a table
06:16:56 <mettekou> ertes: I guess so, two cells separated by the colon.
06:16:59 <romano> ertes, yeah it does work in the sense that I get 100% utilisation on both cpus but the whole thing is still slower than the sequential version :)
06:17:17 <ertes> mettekou: well, in both cases you may find this library useful: https://hackage.haskell.org/package/boxes
06:17:34 <bennofs> woops, found the repos: https://github.com/fpco/stackage-nightly and https://github.com/fpco/lts-haskell
06:17:55 <ertes> mettekou: making it work with *-wl-pprint could be a bit challenging though, because the text flow models are inherently incompatible
06:19:35 <mettekou> ertes: Yeah, that's too much of a pain for me to currently investigate.
06:19:51 <ertes> romano: actually i'm talking non-sense…  parList* should be fine with heterogenous sparks, as long as they're not too small, and your buffer is large enough
06:19:52 <mettekou> Manually adding spaces works fine for my use case.
06:20:40 <quchen_> mettekou: Sounds like a case for fill/fillBreak. https://quchen.github.io/ansi-wl-pprint-docdump/haddock/Data-Text-PrettyPrint-Doc.html#v:fill
06:21:08 <quchen_> mettekou: That’s the Haddock of my fork, but it applies to ansi-wl-pprint just as well.
06:21:10 <mettekou> quchen_: Wow, the example is literally what I need modulo the let, thanks.
06:22:17 <quchen_> mettekou: :-)
06:54:22 <Ferdirand> ģ/win 5
06:54:26 <Ferdirand> oops
06:58:28 <_sras_> Hey guys. is there a function/package that can take two timestamp values (utctime or localtime) and return their difference as a human friendly string, like "2 weeks and 3 days", "1 month and 2 weeks" etc...?
07:07:07 <bartavelle> _sras_ something like that perhaps ? https://hackage.haskell.org/package/friendly-time
07:08:15 <bartavelle> ah not really
07:08:19 <bartavelle> it gives you like "2 days ago"
07:11:46 <bartavelle> (it seems possible to customize the HumanTimeLocale though)
07:12:04 <quchen_> Woah, GHC-Mod 5.7 is out!
07:12:12 <quchen_> Hopefully it fixes the HLint issues
07:12:19 <quchen_> Thanks DanielG :-)
07:12:50 <quchen_> @tell DanielG There’s no Github release for ghc-mod 5.7 yet, only a Hackage one
07:12:50 <lambdabot> Consider it noted.
07:12:57 <hololeap> can someone please take a look at some code of mine and give some code of mine and give me some advise on how to clean it up/make it more concise? https://git.io/vM94h
07:18:17 <ur_> Does haskell have a library for an in-memory relational database like https://github.com/tonsky/datascript?
07:19:36 <sdx23> ur_: what's the point / usecase?
07:20:33 <ur_> sdx23: using it with ghcjs for UI with a very dynamic state
07:22:41 <sdx23> ur_: urgs. perhaps ixSet
07:23:02 <romano> ertes, does this look normal to you on a dual-core machine? SPARKS: 973 (971 converted, 0 overflowed, 0 dud, 1 GC'd, 1 fizzled)
07:23:12 <dramforever> Is there a good persistent int32 array-ish thing? I need one with 2^23 slota (that's 8388608) and Data.IntMap takes a few seconds to construct one
07:23:33 <dramforever> Hmm, maybe there's a faster way of creating a zeroed array?
07:23:35 <ur_> sdx23: Thanks, I'll check it out
07:23:45 <dramforever> s/slota/slots
07:27:08 <dramforever> Oh wait, I can make it by treating missing slots as zero :P
07:27:32 <hololeap> dramforever: what are you doing with it
07:28:35 <dramforever> It's the memory space of a bytecode virtual machine
07:28:55 <dramforever> The architecture is pre-defined as having such an address space of int32's
07:30:12 <ertes> romano: i don't really know how to interpret the latter 1s, but if the number of sparks roughly matches your list length (perhaps off by a constant factor), then it seems fine
07:30:16 <cocreature> dramforever: how about mmapping a sparse file?
07:31:00 <dramforever> That's not persistent (functional) enough...
07:31:29 <cocreature> dramforever: what do you need persistence in a vm for?
07:31:36 <dramforever> debugging
07:32:19 <cocreature> fair enough
07:32:39 <hololeap> specifically, can someone look at lines 99-103 in the code i posted? i feel like there has to be a more generic form for that pattern
07:32:40 <romano> ertes, thanks. yes, it matches my list
07:32:53 <ertes> dramforever: data Chunk a = Chunk !(Vector a) | Zeroes !Int;  type Array a = FingerTree Length (Chunk a)
07:33:14 <ertes> @package fingertree
07:33:15 <lambdabot> http://hackage.haskell.org/package/fingertree
07:34:14 <dramforever> sounds great
07:34:42 <dramforever> I'm thinking of: data Mem = Val Int32 | Fork Mem Mem
07:35:05 <dramforever> Then the zeroed tree would have a really nicely shared structure
07:35:34 <ertes> dramforever: the underlying idea is that of a rope, but with run-length-compressed blocks of zeroes, except with a finger tree instead of a binary tree
07:35:37 <ertes> dramforever: https://en.wikipedia.org/wiki/Rope_(data_structure)
07:36:02 <dramforever> Yeah
07:36:23 <dramforever> Thanks for that, will look into such a structure
07:39:29 <kuribas> dramforever: a strict bytestring?
07:41:01 <dramforever> kuribas: persistent ;)
07:41:41 <kuribas> dramforever: what do you mean?  On a file system?
07:41:54 <dramforever> I need to fork state for debugging (like 'what if I did this there') and it would not be very good if I had to copy 2^23 * 4 bytes every time
07:42:26 <dramforever> oh yeah, persistent as in forkable or something :(
07:43:10 <kuribas> dramforever: and random acces?
07:43:14 <dramforever> yep
07:44:49 <kuribas> dramforever: A strict bytestring, and copy it of debugging?
07:44:56 <kuribas> copying is fast...
07:45:55 <kuribas> I'd say IntMap, but you already tried that...
07:45:58 <dramforever> Hmm, maybe you're right
07:46:40 <kuribas> it's only 32Mb
07:47:16 <dramforever> I think I can also hack IntMap's internal structure to get the sharing I want
07:49:29 <kuribas> ByteString.replicate uses memset
07:52:16 <dramforever> yeah that's a way too
07:54:37 <codedmart> I am playing with lenses to try and get a better understanding. I am curious if this is possible how I am trying to do it. https://gist.github.com/codedmart/fc7eb33298b2e526df9430f61db0681a#file-lenstry-hs
08:06:32 <kuribas> :t over
08:06:34 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
08:06:49 <kuribas> codedmart: over doesn't return IO
08:07:05 <kuribas> :t traverseOf
08:07:07 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
08:07:25 <codedmart> kuribas: I get that was just wondering if there was some magic you could use to sequence IO out or something.
08:07:25 <kuribas> codedmart: I think you want traverseOf or the lens directly.
08:07:46 <kuribas> codedmart: yes, that's in fact what a lens does.
08:08:54 <kuribas> codedmart: try removing "over" :)
08:09:09 <kuribas> codedmart: traverseOf is just a specialized id
08:09:31 <dvmacias> hello everyone. was trying to convert a submap keybinding to something similart to how the WS switching works in xmonad
08:09:33 <dvmacias> http://pastebin.com/PUnzkCiy
08:10:28 <codedmart> kuribas: Nice thanks!
08:10:46 <free_beard1> ok
08:11:48 <ptek> Hi guys. Why does Data.Set have a `map` function but no Functor instance? Must `fmap` preserve the structure?
08:13:40 <hololeap> ptek: i would think it could be an applicative and a monad as well. maybe it's just not implemented by default?
08:13:54 <kuribas> ptek: because of the Ord constraint.
08:14:07 <hololeap> oh yeah
08:14:08 <kuribas> :t Data.Set.map
08:14:10 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
08:14:41 <ptek> kuribas, oh, I understand
08:15:02 <ptek> makes sense now
08:15:36 <ptek> so, obviously, Traversable would also be not possible...
08:17:06 <kuribas> no
08:17:58 <byorgey> ptek: Data.Set is a monad in a mathematical sense, but because of the Ord constraint it doesn't fit in the Haskell Monad class
08:19:11 <kuribas> byorgey: if it had an existential type, would it work?
08:19:15 <tmciver> Is the Ord constraint on Data.Set functions a kind of "absraction leak" since a mathematical set has no such constraint?
08:19:31 <byorgey> tmciver: yes, that's a good way of putting it.
08:20:00 <Tuplanolla> Mathematical sets still require equality, but that's usually assumed to be universal, tmciver.
08:20:07 <tmciver> byorgey: I imagine it's *possible* to create an implementation that did not have that problem.
08:20:20 <kuribas> tmciver: you could implement a set as a list, but that would be very inefficient.
08:20:36 <byorgey> tmciver: not really, because you have to assume *something* about the elements, decidable equality at least.
08:20:38 <tmciver> Tuplanolla: That's true, so really it should have an Eq constraint?
08:20:50 <Tuplanolla> That can be done in Haskell, but it'll be super slow, tmciver.
08:21:08 <Tuplanolla> Suddenly everything logarithmic becomes linear.
08:21:36 <byorgey> kuribas: if what had an existential type?
08:21:48 <kuribas> byorgey: Set
08:22:03 <byorgey> ah.  Well, then it would have the wrong kind
08:22:32 <byorgey> assuming you mean something like  data Set = forall a. ...
08:22:36 <kuribas> yeah
08:23:08 <kuribas> can data parameters be constrained?
08:23:35 <cocreature> there is a package that has a Functor typeclass that allows for constraints
08:23:39 <cocreature> but I forgot what it’s called
08:23:45 <byorgey> kuribas: not any more.  It used to be possible but it didn't do what anyone thought it would do
08:23:58 <byorgey> it was actually called 'stupidTheta' in the GHC source code
08:24:05 <kuribas> lol
08:25:37 <byorgey> cocreature: there is RMonad, but it hasn't been updated since 2013.  I'm also unsure what package you would find this in
08:27:34 <cocreature> byorgey: hm maybe I’m missremembering
08:31:04 <cocreature> there is https://hackage.haskell.org/package/ConstraintKinds-1.3.0/docs/Control-ConstraintKinds-Functor.html but I thought there was a more recent ones, but I can’t find it
08:31:47 <old1101> hello people, can anybody tell me if this is correct? http://bit.ly/2jgj37M So, every new thunk references the "last computation"
08:33:00 <kuribas> old1101: there is only one 3.
08:33:55 <kuribas> old1101: I guess all 3's should refer to the same one.
08:34:01 <byorgey> old1101: that doesn't look right.  take 2 x  would evaluate to  3 : 3 : []  with no backward references.
08:34:51 <byorgey> and I don't think evaluating take 2 x  would cause x to turn into the thing you draw at the bottom.  It would still look like the thing at the top, but with no thunks anywhere, just a reference back to itself
08:36:09 <old1101> I'm trying to understand a simple case
08:36:29 <old1101> but the real thing is this: http://stackoverflow.com/a/10972826
08:36:38 <old1101> the graphs
08:40:44 <bbaren> old1101: What about the graphs?
08:41:16 <old1101> bbaren: my simple case is correct?
08:41:34 <drninjabatman> hello
08:42:06 <bbaren> old1101: Not quite. Did you read the comments from kuribas and byorgey?
08:42:07 <drninjabatman> I updated the system ghc on mac os x and now stack ghci complains it can't load some dylibs
08:42:36 <drninjabatman> because it is looking for an 8.0.1 directory while the correct one would be 8.0.2
08:42:48 <drninjabatman> any ideas?
08:44:04 <amx> drninjabatman: what does ghci --version show?
08:44:08 <old1101> bbaren: if a right it as x = 3 : 3 : x, it would be my second graph no?
08:44:23 <old1101> bbaren: I think I'm just breaking the parts
08:44:50 <bbaren> old1101: Almost. For `x = 3 : 3 : x`, the thunk would point back to the head of the list, not to the second cons.
08:45:06 <wamaral> Any good online CS courses using Haskell? I'm majoring in Mathematics and looking for some formal CS basis to go along
08:45:29 <drninjabatman> amx: ghci --version => 8.0.2,  stack ghci --ghci-options --version => 8.0.1
08:45:42 <old1101> wamaral: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html perhaps
08:46:52 <old1101> bbaren: true
08:47:26 <old1101> bbaren: but how the second graph (on SO) references a new fibs?
08:47:46 <wamaral> old1101 looks interesting, thanks!
08:48:53 <old1101> bbaren: being more specific, why it "slides" to the new item of the list
08:49:02 <old1101> bbaren: next*
08:49:15 <bbaren> old1101: Well, the glib answer is that secretly, Haskell has mutation after all :)
08:50:13 <bbaren> old1101: But really, what’s going on is that when you more fully evaluate `fibs`, the runtime runs a thunk which generates a new cons.
08:50:28 <bbaren> It then garbage-collects the old thunk (and its pointers).
08:51:11 <bbaren> So the arrows don’t actually slide; they’re recreated in a new place.
08:51:13 <bbaren> Does that make sense?
08:51:36 <erisco> how is a free magma of X joining binary trees labeled by elements of X "at the root"?
08:51:38 <old1101> wait, I need to digest this
08:52:10 <erisco> https://en.wikipedia.org/wiki/Magma_(algebra)#Free_magma
08:52:59 <erisco> I mean, okay, you can do this, but it isn't unique
08:53:11 <erisco> why not just, say, take the first or second argument
08:53:46 * shapr starts too many arguments
08:54:50 <amx> I often find myself in need of chaining non-monadic operations on a value, e.g. Map.adjust (+1) 12 m `op` Map.adjust (+4) 18 `op` …, does such a op :: a -> (a -> b) -> b exist in base?
08:55:29 <erisco> amx, function composition i.e. (.) maybe?
08:55:57 <old1101> bbaren: but then, how in the second graph, the new thunk doesn't point to the first item?
08:55:57 <amx> that would work, but then I write the initial value at the end instead of the beginning
08:56:02 <MarcelineVQ> :t (&)
08:56:04 <lambdabot> a -> (a -> b) -> b
08:56:36 <stobix> sounds kinda like >>> to me
08:56:39 <amx> thank you!
08:57:05 <erisco> (learn . to . love) it
08:57:49 <stobix> (love . to . learn) it -- (.) composition is backwards
08:57:57 <bbaren> old1101: Because in the second graph, `zipWith` has already run once, so it’s applying (+) to `tail fibs` and `tail (tail fibs)`.
08:58:16 <erisco> stobix, what makes you think I got it backwards? :)
08:58:33 <stobix> heh, touché. :)
09:06:37 <tabaqui1> when I run "stack build" it compiles dependencies in random order
09:06:52 <tabaqui1> how can I fix order for compilation?
09:07:38 <tabaqui1> I maked many changes that affects a bit of deps and want to fix 'em one by one
09:07:57 <old1101> bbaren: this makes a lot of sense, but from where comes the notion of `tail fibs` `tail (tail fibs)`? It's because haskell knows that you already evaluated 1 number from the list? But in 0 : 1 : thunk, 0 and 1 doesn't count?
09:08:40 <tabaqui1> s/fix\ order/set\ order
09:12:49 <bbaren> old1101: Hang on, let me write something a bit lengthier.
09:19:45 <rgrinberg> What's the relationship between arrows and profunctors?
09:25:07 <stobix> I seem to have cabal documentation in two places. Can I merge them somehow?
09:25:22 <walrus_> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
09:25:22 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
09:26:35 * stobix still smirks at the undo command
09:27:14 <bbaren> old1101: Well, I’m having some trouble putting this into words. I did draw https://imgur.com/kB8Nas5, but I’m not actually convinced that conveys information beyond Dons’ SO post.
09:28:48 <bbaren> old1101: The basic idea is that `zipWith` cdrs down the lists it’s working on, so after applying `(+)` to produce the first elements in `fibs`, it’ll move on to generate the rest the same way.
09:29:01 <davean> bbaren: it seems you left off the "why" those arrows point back like that which I'd theorize is somewhat important for understanding
09:29:17 <jerin> hello, I'm trying to setup xmonad hardware keys
09:29:47 <walrus_> does the opposite of "@undo" also exist? as in convert from explicit binds to do notation?
09:29:47 <jerin> import qualified Graphics.X11.ExtraTypes.XF86 as extraKey
09:29:47 <jerin> is causing errors
09:29:58 <jerin> Is this how I'm supposed to qualified import?
09:30:13 <jerin> Or is there some error
09:30:20 <bbaren> davean: I guess I’d say the arrows point back because `fibs` points to its referent, and pattern matching `fibs` against `(a:as)` and `(b:bs)` causes it to get destructured in the expected way.
09:30:36 <bbaren> jerin: You need a capital letter on your module name. `import qualified Graphics.X11.ExtraTypes.XF86 as ExtraKey`
09:30:51 <jerin> bbaren: oh, that silly. Thanks!
09:31:02 <bbaren> jerin: No problem.
09:34:14 <tabaqui1> *haskell hasn't coprofunctors still
09:34:38 <tabaqui1> I gonna fix this
09:35:34 <johnw> a coprofunctor is from DxCᵒ
09:35:36 <johnw> ?
09:35:59 <johnw> (got a bit truncated there, but if you understand what I meant...)
09:38:08 <tabaqui1> nope, I'm just joking
09:39:09 <johnw> I think I took it as a cojoke then
09:41:53 <jerin> how do I launch stalonetray in my xmonad.hs?
09:42:03 <jerin> will spawnPipe "stalonetray" do?
09:42:19 <johnw> wow, I haven't seen an xmonad question here in a couple of years
09:44:46 <old1101> bbaren: packing all the information and help you gave me, I finally  fuc**** understood haha :)) (being aobut 10h reading google) the image with the notion that haskell has mutation made the trick. thank you for the effort with me :))
09:56:14 <stobix> What is a profunctor? Is it related to https://en.wikipedia.org/wiki/Profunctor?
10:00:05 <johnw> yes
10:02:29 <stobix> heh. well. thanks. 
10:02:48 * stobix found, and is reading http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html 
10:05:23 * stobix just broke his head again. Oh, well.
10:19:58 <dmwit> stobix: Are you comfortable with bifunctors?
10:27:02 <Unode> two very basic questions. Does any function that realizes IO need to include IO in its signature?
10:28:36 <Unode> and what does ghci do to IO that always works but when compiling I get errors and wrong type inferences.
10:29:07 <Unode> (yet another newbie with IO related questions... the more I read the more confused I get)
10:30:45 <phadej> realizes IO?
10:31:10 <_sg> Hi! Why does't work 
10:31:10 <_sg> data Bool = False | True deriving (Ord)
10:31:10 <_sg> on page http://learnyouahaskell.com/making-our-own-types-and-typeclasses
10:31:17 <phadej> ghci is a bit magical, to make it "convenient", but the cost is that it's a bit confusing
10:31:47 <phadej> _sg: have you tried deriving (Eq, Ord) ?
10:31:56 <Xe> _sg: LYAH is largely considered outdated, you might wanna look into http://haskellbook.com/
10:32:08 <_sg> ok, I'll do it
10:33:44 <_sg> Ok, (Eq, Ord) is correct. Thanks
10:34:26 <stobix> dmwit: I've never heard of them  until today.
10:34:58 <amx> Unode: Yes, and ghci essentially runs your prompt in an IO loop that prints whatever you are doing, for your benefit.
10:36:15 <dmwit> stobix: Okay. Then my route to enlightenment probably won't help you. Sorry. =P
10:37:01 <stobix> dmwit: Heh. Well, thanks for trying. :) Learning about bifunctors will probably be a good thing too. Some day.
10:37:10 * stobix is clocking out for today.
10:38:28 <Unode> amx, phadej, I'm still wrapping my head around IO. I started with something simple: http://lpaste.net/351464 but I'm stuck around the IO and getting the Integer out
10:39:17 <amx> Unode: try "print offset"
10:43:23 <erisco> nothing comes out… at least most things don't
10:45:22 <Unode> amx: ok that helped... I was doing "let size = show offset; putStrLn "Message" ++ size" but I wasn't understanding what's wrong.
10:45:42 <Unode> Was missing "$" after putStrLn or () around the ++ operation
10:46:45 <erisco> remember to weigh your bed
10:47:39 <Unode> phadej: by "realizes IO" I meant, that actually performes IO by use of other functions that have IO in their signature.
10:48:07 <Unode> my next question is how do I avoid IO proliferating throughout my program but I guess I'll take my time to get there.
10:48:40 <erisco> do you need IO for ++?
10:49:05 <Unode> no
10:49:21 <Unode> but something else needs to get the filesize
10:49:42 <erisco> well it is like that. Not all your program needs IO
10:50:29 <boojinks> Unode, if you write most of your program ignoring IO then you'll be off to a reasonable start
10:51:19 <ph88> when i want quickcheck to choose randomly of a bunch of generators i use the construct   oneof [a,b,c]  is it possible to replace this with an infix function similar to <|>  ?
10:51:22 <boojinks> i.e. instead of thinking "how do I get out of IO", think about individal problems and then later worry about the realisation of IO to glue it all together
10:55:46 <Unode> boojinks: ok lets see how that fares.
10:57:10 <erisco> Haskell isn't a language where you can just drop some database or network operations anywhere
10:57:40 <erisco> which is a seemingly common thing otherwise
10:58:39 <boojinks> Unode: do you come from an imperative background or is this just your first tango with pure functional code?
10:58:48 <Unode> boojinks: pretty much
10:59:04 <boojinks> first or second? :p
10:59:56 <Unode> I've been reading Haskell programming from first principles and so far things are going ok but once it gets to actually write code it's like I haven't been reading the book at all
11:00:07 <Unode> boojinks: both :)
11:00:39 <boojinks> I understand the feeling...
11:00:44 <Unode> I'm trying to add a little bit of functionality to an haskell project. I thought it would be easy but ... hehe
11:01:49 <Unode> I also had some ideas about creating a small networked program but that's probably too much sand for my haskell minivan right now.
11:02:39 <erisco> in my opinion that isn't where the fun is
11:02:43 <boojinks> may or may not be helpful but I found the best way to work with Haskell was to take things back to basics. I found if I really drilled down into the core pieces of what I was doing, wrote a function for each (even if just to give a name to a very simple part of a process) and compose it that way, it's much easier to actually *accomplish* something.
11:02:48 <erisco> unless we're exercising, say, pipes, but that is advanced
11:03:18 <Unode> erisco: well the program is something I need and since I was learning Haskell, why not ...
11:03:21 <erisco> learning pure functional languages should avoid any IO for a long time
11:04:10 <boojinks> once the basics of a solution are in place, that's when you can start experimenting with all the weird and wonderful tools Haskell gives you under the guarantee that if you break something, 9 times out of 10 GHC will 'politely' let you know
11:04:15 <Unode> I'm more of a python programmer and there I know exactly what I'd have to do to get the program working. But I wouldn't learn any Haskell with that exercise :)
11:05:04 <Unode> boojinks: yeah that's also something I'm still learning. GHC tells me a lot of stuff. Most is quite dense. Even reading the errors is hard right now.
11:05:30 <Unode> I mean, there's 5 errors on screen. But often 1 line changing fixes them all.
11:05:41 <Unode> or brings other 5 into the screen :)
11:05:50 <Unode> (my current feeling)
11:06:41 <boojinks> yeah but don't you find it more useful than the alternative in Python of receiving nothing but a "what have you just given me?" error at runtime? :p
11:06:43 <Unode> erisco: well I'm not learning it for the sake of learning functional... I want to be able to produce something with it.
11:07:00 <dmwit> Usually if the line number doesn't immediately tell me what's wrong, I find GHC's error messages quite enlightening. Though they do take some time to read; as with most machine-generated things they are sometimes more precise than the human mind is designed to handle.
11:07:55 <Unode> boojinks: well... that's life I guess :) Haskell also complained at runtime when I mistyped the filename in the source. No way to figure that one out at compile time.
11:07:57 <erisco> yes but… it isn't like IO is required to produce things
11:09:44 <Unode> erisco: I am currently under the impression that anything that requires interaction with anything outside of realm of the language needs IO. I mean I don't want the program to only play with itself.
11:10:08 <ph88> is it possible to have some fold-like operation with lookahead (of at least 1) where the intermediate result is a different type than the end result ?
11:10:52 <boojinks> Unode: yes but you can actually write the majority of an application completely avoiding IO.
11:11:58 <erisco> yes, sure, you will need it at some point, and if you really want to then go for it
11:12:12 <Unode> oh yeah, sure I get that. But need more hands on to wrap my brain around the implications and how this is handled in practice.
11:12:15 <erisco> I am just saying that it is unnecessary and not really the interesting part
11:13:01 <boojinks> that's why I'd suggest not worrying about IO at all when you start coding.
11:13:51 <dmwit> ph88: For lookahead, try the fancy `ap zip tail` trick. For intermediate vs. final, tack a postprocessor on the end of the fold.
11:14:05 <boojinks> IO belongs at the boundaries and will end up taking very little of your time in reality
11:14:19 <erisco> I don't know, maybe I am too far gone
11:15:00 <Unode> For instance the code I'm trying to change already has a certain structure. I now want to obtain the size of a file and this value will be passed as an argument to a "system" command. The command call is already there. So I shouldn't have to worry about IO because IO is already going to happen anyway (well somewhere).
11:15:06 <erisco> I think of the problem with IO as an afterthought
11:15:23 <dmwit> > let secondToLast = fst . foldl (flip const) (error "lol") . ap zip tail in secondToLast "abcde" -- ph88
11:15:29 <lambdabot>  'd'
11:15:42 <erisco> the problem looks like this, I'll solve that, and then I'll use whatever OS API to plug it in
11:16:01 <Unode> erisco: This particular problem is sort of IO centered or as you say, I probably have the wrong mindset.
11:16:14 <dmwit> Unode: Nothing wrong with doing IO when you need to do IO.
11:16:18 <dmwit> That's not a wrong mindset.
11:17:33 <boojinks> Unode: well yes you'll need IO to get the file size but I'd suggest almost everything you do with that size afterwards will probably not involve IO at all.
11:20:09 <boojinks> so what I'd look at doing is writing the rest of that code in isolation, without caring whether my "size" comes from the filesystem or a hard-coded value or whatever, and then only involve IO when I'm gluing things up? hope that makes sense.
11:20:27 <ph88> hhmm intersting dmwit 
11:22:28 <Unode> boojinks: ok so on a practical note. If I have a function :: String -> Int . This function is actually the one that reads the filesize. So I actually need :: String -> IO Int (or do I?) and then in the caller, is the result of the function handled just like any other integer? For instance (fun...) + 1 fails. How is this usually addressed?
11:23:01 <dmwit> You do actually need `String -> IO Int`. The result is not handled just like any other `Int` because it is not an `Int`.
11:23:16 <dmwit> There are functions that teach `Int`-based operations how to handle `IO Int`s; e.g.
11:23:25 <dmwit> fmap :: (Int -> a) -> (IO Int -> IO a)
11:23:43 <dmwit> liftM2 :: (Int -> Int -> a) -> (IO Int -> IO Int -> IO a)
11:23:49 <ph88> instead of   a <|> b <|> c   is it possible to have a list [a,b,c]  and have some function which does the same thing to that list as chaining with <|>  does ?
11:24:00 <dmwit> (=<<) :: (Int -> IO a) -> (IO Int -> IO a)
11:24:04 <erisco> ph88, asum
11:24:11 <glguy> Unode: I you define   myaction = getFileSize "filename.txt",   myaction will have the type   IO Int
11:24:25 <glguy> That doesn't mean that myaction knows the file size, it's the name of the action that could get the filesize
11:24:29 <ph88> erisco, that's it? o_O
11:24:35 <erisco> :t asum
11:24:37 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
11:24:43 <erisco> looks like it to me
11:24:51 <ph88> okay
11:24:53 <glguy> do when you work with it in your main action you could write something like:  do theFileSize <- myaction; ...
11:25:02 <glguy> now you can use theFileSize, which is an Int in that ...
11:25:10 <erisco> :t foldr (<|>) empty
11:25:12 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
11:25:59 <monochrom> time to read my http://www.vex.net/~trebla/haskell/IO.xhtml
11:26:57 <Unode> dmwit: still trying to parse what you wrote... need more time
11:27:18 <dmwit> glguy's introduction may be a gentler direction to learn from.
11:27:50 <dmwit> I've never been very good at gentle.
11:27:56 <erisco> IO isn't a gentle topic in Haskell
11:28:18 <erisco> need more fac and fib
11:28:21 <boojinks> >.<
11:28:55 <dmwit> ?google IO for people who just don't care
11:28:56 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
11:28:57 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
11:29:31 <monochrom> fac and fib aren't gentle either. https://mail.haskell.org/pipermail/haskell-cafe/2017-January/125976.html
11:30:00 <erisco> I know what you are linking without even opening it
11:30:42 <erisco> okay I was wrong :P thought it was the undergrad to prof one
11:31:35 <dmwit> Unode: (In case you liked glguy's direction better, I think sigfpe's blog post there is a nice expansion on that line of teaching.)
11:32:10 <erisco> if FP had institutions they'd be secluded in mountains and you wouldn't return for a year
11:32:12 <sm> Unode: it's true that types and errors can be a little different in ghci vs your compiled program. I recommend leaving 'ghcid myprogram.hs' running in a side window to get quick feedback as you make changes in your program
11:32:59 <Unode> sm: ghcid ? don't have that command.
11:33:11 <sm> stack install ghcid will get it, if you have stack
11:33:52 <monochrom> my http://www.vex.net/~trebla/haskell/IO.xhtml is better
11:34:33 <Unode> sm: fetching. Thanks
11:34:53 <sm> and from what you're saying, I bet you might enjoy https://leanpub.com/haskell-cookbook/read#leanpub-auto-tutorial-on-impure-haskell-programming
11:36:36 <Unode> ok I have something like 5 pages to read now :) thanks to everyone. I'll be back when I manage to understand enough to have more questions.
11:45:02 <plakband> Hello, I am trying to rewrite parts of my library using singletons, but I found the singletons paper to be outdated (nothing on TypeLits/KnownNat), and the haddocks aren't very beginner-friendly. Does anyone know of a practical introduction to using singletons, or have any tips on where to start?
11:46:19 <Unode> sm: I take it from the error messages that to use it with stack I need to have a formal project structure?
11:46:54 <Unode> i.e. can't simply have a ghcid working globally on the system?
11:57:59 <mmachenry> I think my explicit recursion here is better expressed as an msum but I can't figure out how to work in the additional argument I'm using. http://lpaste.net/351469
11:58:11 <mmachenry> Does anyone have any suggestions?
11:59:41 <erisco> why not  ((==)count) . length . filter ((==)n)  ?
12:02:00 <erisco> okay, so FD is a MonadPlus and #== and #/= are presumably like guard
12:03:43 <erisco> I do not understand why comparing FDExpr requires this
12:04:45 <jle`> plakband: i wrote a small one as a part of a larger blog series, if you want
12:06:01 <plakband> jle`: definitiely!
12:06:21 <plakband> definitely*
12:06:38 <jle`> plakband: https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html
12:06:59 <jle`> singletons is kind of sprinkled through both posts atm
12:07:05 <erisco> okay so lets say we do  fmap (($>) 1 . (#==) n)  then we have  [FD Int]
12:07:57 <erisco> then  fmap sum . sequence  ?  seems a bit gross
12:09:26 <erisco> but if we're shorting like with guard then I don't see how this makes sense
12:09:31 * erisco shrugs
12:18:50 <plakband> jle`: Oh you're Justin Le! I came across your articles earlier, and they've been the most useful information on singletons so far, thanks a lot!
12:20:06 <jle`> oh, no problem!
12:20:23 <jle`> hope you can find them helpful; let me know if you have any other questions
12:27:30 <mojjo> hi! I'm, looking for a simple example for reading the stdout of an external process from within haskell. could somebody give me a hint? 
12:29:30 <dyreshark> mojjo: if you're fine with waiting until the process exits to start processing its output, you should just be able to do `readProcess "/path/to/bin" ["arg1", "arg2..."] ""`
12:29:38 <dyreshark> see https://hackage.haskell.org/package/process-1.4.3.0/docs/System-Process.html
12:30:40 <mojjo> oh, I did not mention that the process emits data infinitely.. The one you suggest I already checked out..
12:33:24 <mojjo> dyreshark: i think I have something helpful now, http://lpaste.net/351471 .. So no need for further answers I think..
12:49:28 <ladyfriday> is this the right place to ask about stack, or is there another channel for that?
12:51:07 <wespiser> ReaderT EnvCtx IO a
12:51:19 <wespiser> how does that monad transformer function unwrapper work?
12:53:36 <glguy> wespiser: what aspect are you struggling with?
12:53:42 <lpaste> ladyfriday pasted “Stack install issue” at http://lpaste.net/1556872305601150976
12:54:14 <wespiser> the chatbot command to unwrap the mtl type
12:54:25 <ladyfriday> ^ when I try `stack install helm`, it complains about missing C library cairo, but it's definitely installed (see the commands at the bottom)
12:54:45 <ladyfriday> is there something I need to do to get stack to pick it up correctly? Do I need a different version of cairo installed?
12:55:35 <wespiser> ReaderT EnvCtx IO a => EnvCtx -> IO a
12:56:30 <wespiser> its a function of this interface, i've used it here before, but can't recall
12:57:58 <geekosaur> @unmtl ReaderT EnvCtx IO a
12:57:58 <lambdabot> EnvCtx -> IO a
13:00:26 <afldcr> lastfriday-- is libcairo on your $LIBRARY_PATH
13:00:42 <glguy> wespiser: Are you just asking what the name of 'runReaderT' is?
13:00:43 <glguy> http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT
13:00:54 <wespiser> no
13:01:02 <wespiser> its an interface command for irc
13:01:10 <geekosaur> afldcr, it's in /usr/lib, it had better be in the default path
13:01:24 <geekosaur> wespiser, check scrollback
13:01:48 <wespiser> it would work for StateT m t a 
13:01:50 <wespiser> like
13:02:01 <wespiser> :t StateT m t a
13:02:03 <lambdabot> error:
13:02:03 <lambdabot>     • Couldn't match expected type ‘Expr -> Expr -> t’
13:02:03 <lambdabot>                   with actual type ‘StateT s0 m0 a0’
13:02:20 <wespiser> a function of lambdabot
13:02:28 <wespiser> for mtl types 
13:02:35 <ladyfriday> afldcr: $LIBRARY_PATH is empty - I guess I set that to /usr/lib?
13:02:49 <geekosaur> sigh
13:02:53 <geekosaur> @unmtl ReaderT EnvCtx IO a
13:02:53 <lambdabot> EnvCtx -> IO a
13:03:03 <geekosaur> for the second time, do you see it this time wespiser?
13:03:17 <wespiser> no
13:03:20 <wespiser> that's not it
13:04:54 <jle`> @unmtl StateT s m a
13:04:54 <lambdabot> s -> m (a, s)
13:05:44 <afldcr> ladyfriday-- if that's where libcairo is, I guess-- iirc it's normally empty, but you can add to it for additional libraries
13:05:47 <wespiser> jle` thanks!
13:06:03 <jle`> geekosaur: just used it twice before i came along
13:06:06 <afldcr> ladyfriday-- /usr/lib should really be on the load path already though
13:06:13 <geekosaur> jle`, they said that's not it
13:06:17 <jle`> er, that was for geekosaur 
13:06:19 <geekosaur> so I have no idea what they want
13:06:20 <jle`> *for wespiser 
13:06:26 <jle`> yeah, but i just used it, and they said thanks?
13:06:30 <jle`> so i'm a little puzzled
13:06:35 <geekosaur> ...
13:07:22 <wespiser> haha
13:08:57 <cale2> why might I use httpoison instead of hackney?
13:09:08 <cale2> oops, pls ignore lol
13:09:14 <ladyfriday> afldcr: that's what I figured - solving this kind of issue before has been easy, but I don't know why it's not finding it :(
13:09:32 <ladyfriday> afldcr: (for the record, setting LIBRARY_PATH didn't help)
13:10:22 <monochrom> Do you know of "ldconfig"?
13:11:07 <ladyfriday> I'm aware of it
13:11:39 <monochrom> If you put some *.so files in /usr/lib or /usr/local/lib recently, they are not immediately recognized, because the system is not going to look. The system only looks at /etc/ld.so.cache, which is only updated by ldconfig
13:12:31 <ladyfriday> it's libcairo, so I'm fairly sure its been there for a very long time now
13:12:53 <ladyfriday> May 3rd, 2016 by the looks of things
13:13:53 <monochrom> Yeah, and "apt-get put it there, and apt-get knows to call ldconfig" is also true
13:14:31 <ladyfriday> I'm on arch linux, fwiw
13:15:56 <ladyfriday> gonna try an older resolver for stack, see if it magically starts working
13:16:27 <monochrom> if resolver doesn't help, try revolver!
13:16:34 <geekosaur> stack resolver shoudln't affect finding C libs
13:17:38 <monochrom> trigger-happy monochrom doesn't resolve problems; he revolves problems. :)
13:17:59 <geekosaur> next time, convolve them
13:18:42 <monochrom> convolution is too hard. let's fourier-transform, multiply, inverse-fourier-transform.
13:18:58 <monochrom> and revolve.
13:19:10 <glguy> Isn't there a log file that can be  checked to see what exactly the failure was that lead the configure script to declare that cairo wasn't available?
13:24:06 <ladyfriday> glguy: the log file mentioned when building is just a log of the output you see anyway it seems :(
13:24:44 <ladyfriday> the only information I see is a bunch of pkg-config commands, all of which are successful
13:25:31 <geekosaur> glguy, cabal lib doesn't log what it's doing in that check :(
13:25:54 <geekosaur> only way I know to figure it out is strace (with +RTS -V0 otherwise you drown in itimer noise)
13:30:55 <sm> Unode: one of these may work better: stack exec -- ghcid myprog.hs or ghcid -c 'stack ghci myprog'
13:32:02 <Unode> sm: stack always complains if I'm not in a project directory: "Cannot determine project root directory for Docker sandbox."
13:32:28 <sm> alright, I don't know what you have set up there. ghcid needs to see the same installed packages as when your program is being built
13:32:55 <sm> when you can do ghci prog.hs, ghcid should work too
13:33:07 <glguy> ladyfriday: You get more information with : -v3 to Cabal
13:33:37 <lpaste> glguy pasted “stuff I see with v3 for ladyfriday” at http://lpaste.net/351477
13:33:55 <glguy> ladyfriday: Perhaps seeing the gcc command that it's attempting to run will help us to pin down what's failing
13:34:02 <Unode> sm: stack --version    
13:34:04 <Unode> Version 1.2.0 x86_64y
13:34:13 <Unode> (ignore the y at the end)
13:34:42 <codedmart> Is there a better way to read a string "2017-01-17T22:21:44.09400Z" to UTCTime rather then striping the T and Z? I am using readMaybe but it only succeds when the string is "2017-01-17 22:21:44.09400"?
13:35:07 <sm> Unode: are you working in a cabal project, stack project, or just a regular directory ?
13:35:10 <glguy> codedmart: the time package has a parseTimeM where you can specify the format you want to support
13:35:17 <Unode> sm: regular directory
13:35:26 <glguy> Unode: Your stack is out of date, you should have 1.3.2
13:35:32 <sm> does ghci yourprog.hs work ?
13:35:45 <koala_man> that date format is ISO8601. surely something can parse it
13:36:05 <glguy> koala_man: Yeah, parseTimeM will be able to
13:36:17 <codedmart> glguy: Ah skipped right over that. Thanks!
13:36:47 <Unode> sm: yes but I think it uses ghc from elsewhere
13:36:49 <koala_man> I mean out of the box without having to specify the format
13:36:51 <Unode> glguy: ok
13:36:55 <glguy> codedmart: https://github.com/glguy/irc-core/blob/93f77ef2f6dc2ff529786cfb89057428baa5eeb0/src/Client/EventLoop.hs#L370
13:37:30 <sm> Unode: ok, not sure what you mean but what error do you get from ghcid yourprog.hs 
13:37:42 <Unode> I don't have ghcid
13:37:47 <glguy> koala_man: http://hackage.haskell.org/package/time-1.7.0.1/docs/Data-Time-Format.html#v:iso8601DateFormat
13:38:09 <codedmart> glguy: Even better, thanks again
13:38:14 <Unode> sm: that's the thing I have ghci but not ghcid. if I use stack to try to install it, it complains with the error I pasted.
13:38:44 <sm> Unode: oh. I thought you had installed ghcid. Can you repaste ? I don't see it
13:39:26 <Unode> sm: when in a regular directory stack reports: "Cannot determine project root directory for Docker sandbox."
13:39:33 <Unode> with stack exec -- ghcid
13:39:48 <sm> you need to install it first - "stack install ghcid"
13:40:31 <sm> and please ignore what I said about stack exec, I wrongly guessed you were in a stack project
13:42:22 <Unode> sm: install also gives me "Cannot determine project root directory for Docker sandbox."
13:42:39 <Unode> and just updated to stack 1.3.2
13:42:51 <Unode> seems like it doesn't want to run from anywhere but a stack project
13:43:06 <sm> it should.. are you in eg $HOME ?
13:44:17 <Unode> yup
13:44:45 <sm> are you running inside a docker container or something ?
13:44:48 <Unode> I do have "docker enable true" on my stack config
13:45:10 <sm> I would view that with great suspicion right about now :)
13:45:28 <Unode> I don't remember exactly why but it was the recommendation somewhere
13:45:45 <Unode> something to do with getting a static binary out of it
13:46:41 <Unode> which was part of my requirements for one project
13:46:47 <sm> so when you comment it out.. any change ?
13:49:31 <Unode> downloading a bunch of stuff :)
13:50:04 <Unode> ok seems like I need to bootstrap stack
13:50:41 <Unode> that may be another reason for going docker. less painful for being prepackaged.
13:51:49 <sm> I read "<Unode> sm: fetching. Thanks" as "yes I have stack, fetching ghcid"
13:52:16 <Unode> yes I have stack but aparently setup for docker and not with a global setup (non docker)
13:52:23 <sm> ok
13:53:17 <Unode> will take a moment
13:59:08 <Unode> sm: "All good 1 module" after ghcid
14:06:00 <sm> Unode: great
14:07:11 <sm> keep an eye on it as you try changes
14:07:14 <Unode> I don't undersand ... I could swear the same code was failing before
14:07:28 <Unode> understand* I think I'm getting tired :S
14:08:22 <sm> I understand.. did you figure out what you needed about IO ?
14:08:36 <hackrilege> If I define 'edit i f a = set i $ fmap f $ get i a' for "forgetful" types (such as list where get = !!) but use set 0 for types such as zipper which retain their configuration, what class describes such types?
14:09:45 <Unode> sm: at this point I'm not sure but I think I'll revisit tomorrow
14:09:52 <Unode> my confusion is something else now
14:10:45 <sm> how many days in are you ?
14:10:51 <Unode> I'm using a function from System.Posix that returns IO FileOffset. If I call it inside a do block and + 5 the result it works.
14:11:05 <Unode> sm: reading the book quite a few. getting my hands dirty less than a week
14:11:16 <sm> cool
14:11:30 <sm> a fun time of madness and ecstasy :)
14:11:57 <jle`> hackrilege: what is the type you're expecting edit to have
14:13:26 <hackrilege> I have a paste, should I put it up? I thought the question might be clear, I guess it should be (flip (!!)) for list, is that what you were picking up on?
14:13:32 <Unode> sm: Just madness
14:13:38 <Unode> well Maybe
14:13:54 <sm> a useful tip is to add type annotations (:: IThinkItsThisType) to any line you're uncertain of
14:14:00 <johnw> sm++
14:14:31 <Unode> sm: yeah I've already learned how hard numbers are in ghci
14:14:49 <Unode> I'm still not sure I've learned the difference... Num, Int, Integer, Int*
14:15:03 <jle`> hackrilege: jut not exactly sure what edit is supposed to do
14:15:03 <Unode> or was it Integral..
14:15:13 <jle`> *just
14:15:24 <sm> and I add {-# LANGUAGE ScopedTypeVariables #-} at the top so I can place type annotations more precisely, eg (x :: IThinkItsThis) <- something
14:15:29 <hackrilege> Edit the i'th element
14:15:50 <Unode> sm: don't know what you mean on that last line
14:15:52 <jle`> i ... don't think that that does that
14:16:26 <hackrilege> Ok I'll put up the paste, hang on
14:16:31 <jle`> unless you're talking about a set/get that i'm not familiar with
14:17:51 <hackrilege> lpaste.net/351478
14:19:46 <sm> Unode: eg, you might have a line in a do block like "x <- some monadic action". To get a more precise error message you might annotate it like so:  "x <- some monadic action :: ExpectedType". But ExpectedType includes the monad you're in, and might be hard to write at first, so this is easier: "(x :: ExpectedReturnedType) <- some monadic action"
14:20:49 <johnw> the more I use servant, the more I like it
14:20:51 <Unode> sm I see
14:25:22 <ocharles_> Does GHCI no longer default monads to IO now?
14:25:43 <ocharles_> I keep getting errors like this: https://gist.github.com/ocharles/3284fb341e203639ae32560ecf518718
14:26:12 <ocharles_> adding a type to "formattedComments" (even just IO _) is enough
14:26:20 <hackrilege> jle' does that help?
14:29:18 <sm> people sometimes recommend reading two books at once to learn something. If you've only used HPFFP you might find another source fills in gaps, such as the HTAC I mentioned
14:29:50 <sm> not that HPFFP is known for leaving gaps of any kind :)
14:34:53 <Unode> sm: still pretty much scratching the surface. It's taking me a long time to go through the book and by the time I get past a chapter the first chapters are kind of lost in the details.
14:35:15 <Unode> also failed (at this point) to see all the relevance of some of the details mentioned
14:35:41 <sm> that's what I was thinking. A lighter/faster intro can sometimes be better
14:37:16 <hackrilege> Is a zipper the only thing that retains its context? I thought maybe there would be something from lenses...
14:38:28 <glguy> ocharles_: It'll default to IO if the outermost type is IO, but it's not like the normal defaulting mechanism that works on number types
14:38:28 <johnw> hackrilege: the zippers library uses lenses to build a context
14:38:38 <glguy> ocharles_: so: Prelude> liftIO getLine  will use IO
14:38:46 <glguy> but: Prelude> const () $ liftIO getLine   is ambiguous
14:38:55 <ocharles_> bleh
14:39:15 <ocharles_> in this case i'm using streaming, and `m` is somewhere in the middle of that type
14:39:20 <ocharles_> toList_ brings it to the front
14:39:40 <johnw> so instead of taking the derivative of a type, and building a list of one-hole contexts, you navigate to sub-elements using lenses, and this provides the context
14:40:08 <Unode> sm: yeah, I've been waiting for the Monads chapter to understand the fuss about them. Still a few chapters to go before that.
14:40:12 <hackrilege> johnw, did you see my paste?
14:40:35 <johnw> hackrilege: it's not in my scrollback
14:40:43 <hackrilege> Ok one sec
14:40:46 <sjpet> is it possible to define a type synonym something like: type MyType = (a, [a])
14:40:48 <sjpet> ?
14:40:55 <sm> try the one I linked, you don't really need to go so slowly
14:40:59 <hackrilege> (hackrilege) lpaste.net/351478
14:41:00 <glguy> sjpet: Yes, you just did it!
14:41:04 <glguy> oops
14:41:09 <glguy> what're those 'a' variables up to?
14:41:31 <glguy> Maybe you meant: type MyType a = (a, [a])
14:41:58 <sjpet> yeah, maybe that's what I want to do
14:43:18 <sjpet> indeed, that must be it. thanks
14:46:45 <hackrilege> johnw, see how edit uses push instead of put, I'm trying to describe the rule where after navigating through a type, the type maintains this orientation
14:47:12 <johnw> hackrilege: it's a bit too much code for a quick glance while working, I'm afraid
14:47:33 <hackrilege> Ah ok
14:47:50 <hackrilege> Not to worry
14:52:41 <nitrix> Which language again didn't offer pattern matching but would create a bunch of `isFooBar :: Foo -> Bool` instead?
14:52:48 <nitrix> Agda, Idris, Coq?
14:53:22 <glguy> none of the above
14:53:33 <nitrix> Oh interesting.
14:53:57 <Sornaensis> what kind of pleb tier language doesn't have pattern matching
14:54:06 <nitrix> So curiously then, is this a reasonable alternative to not having pattern matching? What are the other approaches in other languages for ADTs ?
14:54:19 <nitrix> Sornaensis: What?
15:01:48 <cale2> nitrix: some languages can mimmick Haskell for ADTs, but obviously it's not baked in.
15:01:58 <cale2> I guess it depends on what you are wondering about
15:02:07 <cale2> How do they implement pattern matching?
15:02:34 <nitrix> I'm toying with the idea of a very simple parser/lexer.
15:02:48 <cale2> nitrix: https://rosettacode.org/wiki/Pattern_matching#Perl_6
15:02:49 <nitrix> Almost forth-like / RPN.
15:03:04 <cale2> perl6 grammars are pretty insane too: https://github.com/timo/ADT
15:03:55 <nitrix> Oh. That's an interesting way to do it.
15:04:48 <nitrix> Brb. I'll have a more serious look. Cheers Cale :)
15:12:42 <filthyCausual> Okay, I am getting the "all instances must ... Use FlexibleInstances to disable this." error, even though the .hs fire has {-# LANGUAGE FlexibleInstances -#} at the top. What is going on? 
15:13:10 <Cale> nitrix: btw, cale2 isn't me
15:14:36 <ij> What's Data.Text.Text's elem?
15:15:38 <MarcelineVQ> filthyCausual: best to include your code with a question about code :> http://lpaste.net/
15:16:34 <ij> […continuing about elem] It doesn't have one and I must build it?
15:18:28 <patientpl> hi
15:18:55 <suppi> how do i write a a script tag with src attribute in lucid?
15:18:57 <patientpl> is there a good book for haskell? im looking at http://haskellbook.com/assets/img/sample.pdf and im having trouble as its overly simplistic
15:19:32 <suppi> patientpl: what do you mean by overly simplistic?
15:19:41 <glguy> ij: isInfixOf
15:20:08 <glguy> isInfixOf (singleton n)
15:20:39 <filthyCausual> Okay, I am getting the "all instances must ... Use FlexibleInstances to disable this." error, even though the .hs fire has {-# LANGUAGE FlexibleInstances -#} at the top. What is going on? ( http://lpaste.net/351479 )
15:21:17 <ij> I'm doing a String -> Text over my project — should I do it for Megaparsec as well or does it only do strings?
15:21:21 <MarcelineVQ> filthyCausual: {-# LANUAGE FlexibleInstances #-} language
15:21:37 <filthyCausual> Ah thank you!
15:21:53 <patientpl> suppi im at page 40 and we're still talking about 2+2
15:21:56 <patientpl> getting bored
15:21:59 <glguy> patientpl: Programming in Haskell 2nd ed. by Graham Hutton is another recent option
15:22:35 <MarcelineVQ> it takes you though every concept you need to know, so it'll start simple sure
15:22:38 <suppi> patientpl: haskellbook is a bit slow paced but is thorough
15:23:14 <sm> https://leanpub.com/haskell-cookbook/read is probably more "simplistic", but faster
15:23:35 * sm feels like we need a book recommendation bot
15:27:44 <codedmart> If I have an array of 2 just items `[Nothing, Just 1]` how can I apply `<|>` to that?
15:28:13 <codedmart> To just end up with `Maybe Integer` rather then `[Maybe Integer]`
15:28:29 <glguy> :t asum
15:28:31 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
15:28:37 <MarcelineVQ> asum, aka foldr (<|>) empty
15:30:03 <codedmart> Thanks that is handy.
15:30:11 <codedmart> Didn't know about asum. 
15:31:17 <MarcelineVQ> patientpl: by page 40 you've learned how to make declarations, functions, operators, play with ghci, and the entirely of untyped lambda calculus including the ideas of combinators and divergence which will come up constantly in haskell. Don't feel discouraged! you've already covered a lot even if it doesn't feel that way
15:35:07 <nitrix> Cale: I wouldn't have made the assumption in a sensible situation, but I figured it wouldn't be harmful here. Good to know the two of you aren't related.
15:35:48 <MarcelineVQ> no nitrix, you are the cales
15:36:19 <nitrix> Actually I am. I have multiple accounts for all my personalities, this way I can rubber duck my own problems.
15:36:40 <nitrix> I expose my problems to myself, find the solution myself and then teach to myself :D
15:37:37 <nitrix> More seriously, this is close to "feynman technique" which is worth mentioning for being really awesome.
16:35:41 <Layl> okay, I followed advice and installed linux, now what
16:37:33 <glguy> Now do whatever it was you were trying to do that lead you to install Linux.
16:37:34 <yushyin> now you install stack and start writing some great haskell code?
16:38:14 <SexHendrix> no, now you endlessly rice the system and do no work at all
16:40:13 <monochrom> I think that's a matter of the person more than a matter of the OS. Some people simply never stop tweaking configurations.
16:40:51 <monochrom> I for one use Ubuntu and seldom change settings.
16:41:25 <Layl> SexHendrix: I spent 2 days getting sound working
16:41:30 <monochrom> In contrast I know people here who are still changing fonts in search for the ideal font.
16:41:40 <Layl> which involved visiting 3 different IRC channels
16:41:43 <Layl> and a bug tracker
16:41:45 <SexHendrix> Layl: did you finally make it work?
16:41:58 <Layl> Technically I disabled a feature
16:42:01 <Layl> so no, I did not
16:42:06 <SexHendrix> what was the problem
16:42:10 <SexHendrix> is 1% still 99%
16:42:12 <Layl> I just gave up on getting the specific thing I didn't even want working
16:42:18 <Layl> that's what I fixed
16:42:26 <SexHendrix> what did you disable
16:42:46 <Layl> I disabled a new feature introduced in a certain update of pulseaudio
16:43:06 <Layl> the update, 7.1, had as changelog "Better support Xonar DGX"
16:43:13 <Layl> my soundcard is the Xonar DGX
16:43:18 <Layl> so obviously it broke everything
16:43:31 <Layl> I should note, PulseAudio is now at version 10, 3 whole major versions further
16:43:46 <Layl> and everything using the Xonar DGX will run into this issue
16:45:06 <SexHendrix> hue
16:45:09 <SexHendrix> well good job
16:48:08 <Layl> gosh GHCJS did not kid when it said "this will take a long time"
16:48:24 <Layl> and this is an overpowered machine how long does this take on an old laptop
16:48:36 <SexHendrix> have you ever tried compiling chromium
16:49:14 <SexHendrix> also i blame js
16:53:29 <Layl> SexHendrix: I have tried compiling LLVM once
16:54:09 <SexHendrix> llvm is nothing on chromium
16:54:49 <SexHendrix> Layl:  * www-client/chromium
16:54:49 <SexHendrix>    Total builds: 1
16:54:49 <SexHendrix>    Global build time: 5 hours, 44 minutes and 43 seconds.
16:55:05 <Layl> you're right, that's just about 40 minutes longer than LLVM
16:55:28 <SexHendrix> ive ordered a pi zero, should be here next couple of days
16:55:31 <monochrom> . o O ( Are you two even using the same computer? )
16:59:15 <fresheyeball> hello out there
16:59:27 <fresheyeball> I'm looking for advice on the right data structure for something
17:00:05 <fresheyeball> right now I have essentially this (Maybe a, [a])
17:00:29 <fresheyeball> but I need to guarentee that if `Maybe a` is a Just, that the contained term is also in the list
17:01:23 <glguy> You can't guarantee that
17:01:40 <fresheyeball> well I thought of one way I could do it already
17:01:45 <fresheyeball> but I don't like it
17:01:51 <glguy> You could do something like: data T a = NoSelection [a] | Selection [a] a [a]
17:02:12 <fresheyeball> { before :: [a], current :: Maybe a, after :: [a] }
17:02:34 <Cale> yeah, and usually store the "before" part in reverse order
17:02:50 <Cale> Well, it depends, but that's often a good idea
17:03:15 <fresheyeball> I like the NoSelection, Selection thing
17:03:44 <monochrom> If you use { before :: [a], current :: Maybe a, after :: [a] }, now you have the ambiguity of {before=[1,2,3], current=Nothing, after=[]} and {before:[1,2], current=Nothing, after=[3]}.
17:04:02 <Cale> right
17:04:10 <Cale> You'd want the separate constructor
17:04:15 <fresheyeball> do we have that same problem wit the other version as well?
17:04:22 <Cale> nah
17:04:22 <fresheyeball> oh no, actually we just don't
17:04:24 <fresheyeball> ok
17:04:30 <fresheyeball> alright I'm sold
17:04:33 <monochrom> The design of a data model is a road of hair pulling.
17:04:55 <fresheyeball> going 0th times, going 1th times sold
17:08:10 <Welkin> fresheyeball: done any elm lately?
17:13:54 <fresheyeball> Welkin: not much lately
17:14:10 <fresheyeball> I need to get back to it on my own time though
17:17:03 <fresheyeball> Cale: what if I also want to restrict such that I know that each `a` in my model is unique
17:17:06 <fresheyeball> ?
17:17:27 <glguy> nope
17:18:15 <fresheyeball> you said that last time too
17:20:25 <glguy> You can't can't make restrictions like that
17:20:36 <glguy> still can't*
17:20:39 <Welkin> so that means you can?
17:20:43 <Welkin> is that a double negation?
17:20:50 <glguy> No, it's a correction.
17:21:20 <glguy> You can't confuse me into getting the language to support this :)
17:21:23 <fresheyeball> Well I no I could in the noSelection case
17:21:28 <fresheyeball> I could just use `Set`
17:22:27 <glguy> You could make a type with a set of limited operations and refuses to add an element if it has been see
17:22:38 <glguy> What you can't do is make a data type that enforces that
17:25:34 <c_wraith> Seems like you should be able to create a type family that as only inhabited of every inhabitant of a type-level list is unique.
17:25:40 <c_wraith> *if every
17:26:08 <c_wraith> Of course... I wouldn't want to *use* any type based on that.
17:26:42 <fresheyeball> c_wraith: that seems like overkill
17:26:56 <glguy> Yeah, you could enforce that the types are unique, just not that the values of the same type are unique
17:27:15 <c_wraith> Type-level lists feel almost like an anti-pattern.  In most cases they make things harder by a much larger amount than they make things safer.
17:27:19 <c_wraith> At least in Haskell
17:30:08 <glguy> fresheyeball: You can have the operations on your type with NoSelection and Selection constructors enforce uniqueness, which is how Set works
17:30:21 <cale2> sm: is https://leanpub.com/haskell-cookbook/read a new book?
17:30:50 <fresheyeball> glguy: gotcha, that makes sense!
17:30:57 <cale2> I guess 2016. It looks fantastic
17:32:04 <eschnett> @djinn (a -> a) -> a
17:32:05 <lambdabot> -- f cannot be realized.
17:32:26 <geekosaur> djinn fails at recursion
17:32:30 <c_wraith> eschnett: djinn only provides total functions
17:32:38 <c_wraith> eschnett: and fix is decidedly non-total
17:32:44 <c_wraith> And yes, also recursive
17:32:45 <geekosaur> (both are true)
17:32:55 <eschnett> c_wraith: thanks for the pointer to fix!
17:33:03 <c_wraith> :t fix
17:33:04 <lambdabot> (a -> a) -> a
17:33:33 <c_wraith> For extra fun, figure out why fix is implemented the way it is. :)
17:33:47 <cale2> I enjoyed reading Haskell Book, but unfortunately, I grew weary of toy programs :/
17:34:35 <cale2> and then when it got to Hangman, it was so much stuff that wasn't covered
17:34:44 <cale2> IO, etc
17:53:50 <monochrom> I write toy compositions for 6 years when learning Chinese.
17:54:02 <glguy> Did you hang anyone?
17:54:23 <monochrom> I was hung.
17:54:38 <c_wraith> It was a frequent occurrence in my early schooling.  But that wasn't in China.
17:55:11 <monochrom> I was on the airplane, and played hangman on the airplane's personal entertainment computer. I chose a hard level, and lost all games.
17:56:21 <monochrom> The notion of "I have been learning this new language for 3 months, when are we going to watch a movie in this language and write a movie review in this language?!" baffles me.
17:56:54 <cale2> monochrom: learning haskell is considerably different from learning a natural language
17:57:03 <cale2> programming for most people is a means to make money
17:57:21 <cale2> Chinese is a door to a new culture, new experience, etc. 
17:57:32 <monochrom> Is that the most important difference? Because a lot of Western people learn Chinese to make money.
17:57:32 <cale2> I guess you could say the same for Haskell if you're a mega nerd ;)
17:57:57 <Welkin> lol what
17:58:08 <cale2> monochrom: nobody gets a job *just* because they learn chinese. Most already have a big job and they learn chinese because they get re-assigned there
17:58:21 <Welkin> that's not true
17:58:22 <Welkin> lol
17:58:29 <cale2> Welkin, really?
17:58:34 <c_wraith> Adults also learn natural languages a lot faster than children.
17:58:37 <Welkin> I have a friend who got an engineering qa job because he is chinese and speaks chinese
17:58:52 <cale2> Welkin: So he didn't know anything about engineering?
17:58:59 <monochrom> No, I think children are faster.
17:59:01 <Welkin> he did, but he had no experience
17:59:04 <Welkin> fresh out of school
17:59:12 <cale2> Welkin: you get my point though
17:59:14 <Welkin> children take YEARS to learn a language
17:59:33 <Welkin> and they still suck for many more years
17:59:44 <monochrom> No, you can amortize it. Children can take the same years to learn 4 languages.
17:59:57 <c_wraith> monochrom: adults are faster if they actually dedicate themselves full time.  That's a rare thing, but it's what children do automatically.
18:00:26 <mekeor> why does cabal-install not work together with $GHC_PACKAGE_PATH ?
18:01:05 <geekosaur> and adults are missing some language learning machinery that children have (in adults it gets reassigned to executive function)
18:02:55 <Welkin> that isn't true
18:02:55 <Welkin> o.o
18:03:13 <Welkin> based on all the research I have read, children suck hard at language learning
18:03:20 <Welkin> adults can pick it up no problem
18:03:31 <cale2> Welkin: Isn't there a difference in the way they learn though?
18:03:42 <cale2> Children can absorb a lot subconciously
18:03:42 <geekosaur> yes
18:03:51 <cale2> Adults do not absorb things well. We learn them
18:04:10 <monochrom> We need an empirical experiment for this. We need to teach Haskell to Tarzan!
18:04:17 <geekosaur> also children do most of that absorbing before age 7; languages taught in school don;t get learned by the same method
18:04:42 <dolio> You mean, by moving to a location where only that language is spoken?
18:04:46 <Welkin> that is false
18:05:02 <Welkin> it is unfortunate that people still spread that myth around
18:05:24 <geekosaur> I am actively monitoring that research, please explain your sources
18:05:58 <cale2> Too many booleans in this convo
18:06:03 <cale2> very offputting 
18:06:18 <cale2> Only a sith deals in booleans
18:06:24 <monochrom> The solution is: moar booleans. Because numbers are a lot of bits.
18:07:03 <athan> What are the uses for Prisms? So far, all I can see their use is `review`ing :s
18:07:19 <monochrom> (And I have the next card ready when you next say "but the situation is more complex than a number")
18:07:37 <Welkin> here is one http://www.sk.com.br/sk-krash-english.html
18:10:23 <monochrom> hmm low anxiety context for learning Haskell
18:10:48 <monochrom> Well too bad the computer's type-checking is pretty unforgiving
18:16:02 <cale2> Happy Learn Haskell Tutorial is pretty low anxiety
18:16:29 <monochrom> Yeah I think that one is good.
18:21:07 <cale2> They've not made an update to the tutorial since summer 2016 sadly
18:21:16 <cale2> Don't know if they're continuing volume 2 or not
18:23:23 <isd> So, I'm playing with the syb library for the first time; I read one of the papers a while back. I'm hitting a case where I've got a series of types T1 a, T2 a, T3 a... that contain one another in a non-trivial way. I want to write something that will traverse the data structure and convert all of the 'a's to some other datatype, so at the end I get T1 b, T2 b, T3 b...
18:23:46 <isd> I'm not seeing an obvioius way to do that -- all of the apis seem to expect the same input and output type.
18:24:05 <isd> Is this something that's possible?
18:25:07 <isd> (It's not obvious to me how you'd pull that off with just Typeable, so maybe not).
18:25:40 <isd> Hrm, maybe mkR?
18:30:31 <isd> no...
18:37:12 <Gurkenglas> Does some library provideo (a -> IO b) -> a -> IO b for memoizable as and serializable bs which uses the disk?
18:41:37 <isd> Hrm, the thing is, what I really want is *almost* a functor, but in actuallity these all have multiple type parameters and I don't always want to map over the same ones.
18:42:08 <glguy> Gurkenglas: Closest thing that comes to mind: https://ghc.haskell.org/trac/ghc/wiki/StaticPointers
18:43:52 <Gurkenglas> (Actually it should probably be (a -> b) -> a -> IO b so you can properly formulate the "no functional effect" law)
19:07:34 <Layl> where does `stack build` drop the build artifacts?
19:26:26 <julianleviston> Layl: .stack-work ?
19:26:32 <julianleviston> (just a guess)
19:33:50 <Layl> It was a bit more complex but I've found it
19:34:19 <Layl> 244kB output by GHCJS after minifying
19:34:39 <Layl> expected but still kinda big
19:35:10 <hpc> in 2017, 244k of javascript is eentsy-weentsy
19:35:52 <hpc> (mostly because of how wasteful web development is but still)
19:36:48 <Layl> hpc: not for my purposes
19:37:12 <Layl> I'm trying to run this on a multiplayer JS programming game, I'm charged for CPU time
19:37:22 <hpc> ah
19:37:40 <Layl> as in, I've got a budget for CPU time every tick and script reloads cost
19:37:51 <Layl> as long as it doesn't grow to 800MB I'm fine though
19:39:09 <YellowOnion_> Layl, why would you reload the script every tick?
19:39:34 <Layl> YellowOnion_: It doesn't but it eats into a cpu time bucket
19:41:22 <Layl> And yes this game is in fact the only reason I've spent 2 days installing and setting up archlinux
19:41:27 <jerin> looking for xmonad users for opinions on available notification systems? wrong IRC?
19:41:35 <YellowOnion_> Layl, sorry the file size does? How? runtime initialization should only happen once.
19:42:10 <Layl> YellowOnion_: loading in the script form the DB by itself takes CPU time in this game, runtime initialization even more
19:42:26 <Layl> (I also sure hope that the runtime initialization is less than Emscripten's or I'm screwed)
19:45:12 <YellowOnion_> Layl, what game is this?
19:45:18 <geekosaur> jerin, #xmonad is probably a better choice
19:47:26 <Layl> YellowOnion_: Screeps
19:53:58 <YellowOnion_> Layl, ohh this looks interesting. GHCJS is going to have a lot of runtime overhead. You could try purescript to reduce the burden.
19:58:29 <Layl> YellowOnion_: I just really want to use haskell
19:58:39 <Layl> egh it's not working though, it's not printing the message
20:01:43 <Layl> it's getting through running main without errors though
20:01:46 <Layl> it's just... not printing
20:03:15 <Layl> it's working in-browser but not in screeps
20:03:39 <Layl> it's also working in node, hm
20:04:33 <YellowOnion_> Layl, "I want to use haskell" story of my life :D
20:07:20 <Layl> huh, h$running is never set to true
20:08:05 <Layl> I doubt it's even a related problem though
20:08:10 <Layl> I have no idea what's causing this to fail
20:20:48 <Layl> Ah. I think I found the problem
20:20:56 <Layl> Can I force GHCJS output to run immediate and non-threaded
20:24:08 <Cale> What do you mean non-threaded?
20:25:00 <Cale> GHCJS implements GHC's concurrency stuff, but so far as I know, the underlying Javascript doesn't involve threads.
20:25:18 <Layl> It seems to be trying to use MessageChannel though
20:25:24 <Layl> even to run a simple hello world
20:25:51 <Cale> Probably part of the way it's implementing the runtime system
20:26:01 <Cale> But you'd have to ask luite
20:26:22 <Layl> problem is the environment this is runnning in doesn't quite like message passing or anything threaded
20:27:24 <Layl> so it's simply never executing
20:28:17 <Layl> With a bit of hackery I got it to just run immediately, but it's an ugly hack
20:34:01 <Layl> so the problem appears to be that it's trying to set a timeout for the script?
20:34:09 <Layl> I don't even want a timeout
20:35:38 <Cale> https://github.com/ghcjs/shims/blob/master/src/thread.js contains the basic implementation of the thread scheduler
20:35:57 <Cale> and the main loop and whatnot
20:36:37 <Layl> Cale: the problem doesn't seem to be with threading actually, but that it's trying to use various methods of deferring execution just to get a timeout
20:37:06 <Layl> and I don't want any of that, making it run code directly seems to work but it requires me to manually edit the output
20:39:54 <excelsio1a> hi
20:41:58 <Cale> hi
20:42:21 <YellowOnion_> Layl, are you able to link us the code?
20:42:33 <Layl> YellowOnion_: what code do you want?
20:43:23 <Cale> Layl: Is setTimeout defined but disallowed or something?
20:43:37 <Layl> Cale: setTimeout is defined and enabled
20:43:37 <YellowOnion_> Layl, if it's just a hello world, probably the ffi stuff?
20:44:01 <Layl> YellowOnion_: do you want the output script? It's the haskell code is the unedited helloworld from stack
20:44:01 <Cale> Layl: er, okay
20:44:12 <Cale> What's going wrong with the timeout then?
20:44:19 <Layl> Cale: let me clarify: it's correctly detecting the timeout and setting it
20:44:36 <Layl> the problem is that it's in an environment where it can't run anything through any of the timeout methods
20:44:42 <YellowOnion_> Layl, I mean you need to call the haskell code from JS for it to execute?
20:44:50 <Layl> Screeps simply terminates the code before anything happens
20:45:02 <Layl> YellowOnion_: no it creates an executable JS file
20:45:05 <Cale> So the environment includes setTimeout treacherously for no reason, rather than simply removing it?
20:45:09 <Layl> you can `node all.js` to run it even
20:45:36 <Layl> Cale: it's always running it through the timeout methods regardless on if I tell it to set a timeout or not
20:46:20 <Layl> it's calling `setImmediate` when trying to run the code
20:46:34 <Layl> which is exported by the module that sets up the timeout code
20:50:18 <YellowOnion_> Layl, That's probably not whbat is required to get it to work with screep, here's some code I wrote to get ghcjs to work with clashjs: https://gist.github.com/YellowOnion/edd4edd641e3028f8f77
20:51:14 <Cale> It seems kinda broken to me if they have a setImmediate/setTimeout function, but it doesn't work correctly :P
20:51:53 <Layl> YellowOnion_: I'm not seeing anything here that would fix this problem though
20:52:26 <Layl> Cale: it's a valid assumption that if an environment has MessageChannel that you can use it
20:52:40 <Layl> Though it's not nice that it's always using it regardless on if I'm actually doing anything with it
20:52:59 <Cale> Well, it's using it because that's how it schedules Haskell threads to run.
20:53:40 <Cale> It's nice also because if there's other JS doing stuff, it lets the Haskell program yield a bit.
20:53:53 <Cale> I suppose in your case, that's not terribly useful
20:54:39 <Cale> You'll notice though...
20:54:43 <Layl> I added `sed -i 's/channel\.port2\.postMessage/runIfPresent/g' ./.stack-work/install/x86_64-linux/lts-7.15/ghcjs-0.2.1.9007015_ghc-8.0.1/bin/screeps-bot-exe.jsexe/all.js` to my script that builds a file ready for Screeps, which seems to hotfix the problem for now
20:55:10 <Layl> I do not plan to be using any threads given that this environment can't make use of it anyways
20:55:53 <YellowOnion_> Layl, The haskell code is being called from JS, which I assume is required to get it to work with screep, looking at the tutorial, you would need to attach an entry point to module.exports.loop?
20:57:00 <sergio85> whats going on in here
20:57:07 <Layl> YellowOnion_: the GHCJS output runs the main anyways, which in screeps is called "the code that runs at script caching/loading"
20:57:25 <Axman6> sergio85: what it says on the tin, Haskell
20:57:32 <Layl> I do have to export a function eventually, the problem is that currently it's not able to run main
20:57:41 <Layl> I plan to export a function inside the haskell main
20:58:32 <Cale> oh hmm...
20:58:37 <Cale> have a look here:
20:58:42 <Cale> https://github.com/ghcjs/shims/blob/0a6234261b4b13103ad8be898b93705bcf5dc3ae/lib/setImmediate/setImmediate.js#L141
20:59:11 <Layl> Cale: yea that's where I've been looking in the all.js output
20:59:14 <Cale> ah
21:05:42 <YellowOnion_> Layl, You need to call haskell manually when it's in a module: http://edsko.net/2015/02/14/atom-haskell/
21:07:06 <Layl> YellowOnion_: Calling haskell isn't the problem, haskell is being called, the problem is that the way calling into haskell works is with a timeout
21:07:19 <Layl> here it still runs "h$run(h$mainZCMainzimain);"
21:07:22 <Layl> which is being run fine
21:07:40 <Layl> the problem is that h$run uses the timeout method to run h$mainZCMainzimain
21:12:50 <spear2> is there a `show` function that returns Text instead of String ?
21:13:38 <jle`> there are a couple of odd packages that offer one, but usually people just do (pack . show)
21:14:13 <glguy> If you're building a bigger Text you can look at the Builder modules in the text package
21:14:30 <glguy> but for debugging with show if you need it as a Text you can just pack
21:14:38 <spear2> found it in the prelude i'm using BasicPrelude, tshow :)
21:14:52 <spear2> i think it was a change from 0.5->0.6 i just updated
21:15:37 <glguy> tshow = Text.pack . Prelude.show
21:16:12 <YellowOnion_> Layl, maybe I've been poorly explaining it, but even the wiki says you need to wrap the code if you want to call it from a module: https://github.com/ghcjs/ghcjs/wiki/Deployment#globals-and-modules
21:18:29 <Layl> YellowOnion_: calling it from a module isn't the problem
21:18:38 <Layl> there is no problem with calling it from a module, it's working fine
21:19:02 <Layl> I do in fact want main to run while evalulating the module file, this is my intended behavior
21:19:11 <Layl> I don't want to export main
21:20:07 <Layl> the problem isn't caused by modules, it's caused by screeps terminating my code's node VM before anything can finish running, because the use of timeout methods causes the code to finish too late
21:21:04 <Layl> I know this for sure because my monkeypatch works
21:21:21 <Layl> if my assumption were wrong there it would not
21:25:19 <YellowOnion_> Layl, what was your monkey patch?
21:25:36 <Layl> `sed -i 's/channel\.port2\.postMessage/runIfPresent/g' ./<path to your output>/all.js`
21:44:16 <fred-fri> apparently the signature foo :: a -> a -> a can only be implemented two ways, but im too stupid to figure them out
21:44:29 <dreaswar> why dosent this work :: length [1,2,3,4]  + 4.3
21:45:02 <YellowOnion_> Layl, so what is happen when set timeout is called? the VM gets destroyed? and then the setTimeout trys calling code that doesn't exist?
21:45:11 <fred-fri> dreaswar, doesn't length return an integer?
21:45:28 <fred-fri> dreaswar, i don't think you can + integers and non integers
21:45:34 <EvanR> indeed
21:45:36 <dreaswar> my point is since :t (+) is Num => a -> a , and Int, Integer, Float , Double are all instances shouldnt it work
21:45:36 <EvanR> :t (+)
21:45:39 <lambdabot> Num a => a -> a -> a
21:45:56 <EvanR> dreaswar: a = Int, and a = Double at the same time?
21:46:05 <EvanR> i.e. Int = Double
21:46:19 <EvanR> contradiction
21:46:22 <fred-fri> dreaswar, try casting the integer from length to a double and + 4.3
21:46:33 <fred-fri> that should work
21:46:34 <EvanR> dont try casting, try conversion
21:46:47 <EvanR> > fromIntegral (length [1,2,3,4]) + 4.3
21:46:50 <lambdabot>  8.3
21:46:52 <dreaswar> so it has to be length [1,2,3,4] :: Double + 4.3 ? 
21:47:06 <EvanR> that would be a type error
21:47:06 <fred-fri> i defer to the superior intellect of EvanR 
21:47:28 <EvanR> dreaswar: in haskell, you dont rely on implicit type conversions, you have to use functions made for that purpose
21:47:34 <EvanR> like fromIntegral, or floor
21:48:06 <EvanR> 4.3 :: Int would simply be "wrong" instead of a command to convert
21:48:27 <dreaswar> yes, thats my point, coming from OOP, i felt that since it 'interfaces' Num all of them (int, integer, Float, Double) would work and implicit type conversion would be done
21:48:40 <fred-fri> EvanR, maybe you can answer my noob question as well: the signature foo :: a -> a -> a can apparently only have two definitions, of which one is undefined. what is the other one?
21:48:41 <EvanR> yes Num has nothing to do with conversions
21:49:03 <EvanR> (except for fromInteger which is how 123 can be polymorphic)
21:49:37 <EvanR> fred-fri: theres 2 *non-undefined* ways
21:49:43 <athan> it's a way to share names for different implementations, nothing about how to turn one implementation into another
21:50:21 <EvanR> fred-fri: so try coming up with the answer again, since you now have 2 chances to win instead of 1 ;)
21:50:42 <athan> Num includes the names for the (+) and (-) operations for instance
21:50:48 <EvanR> dreaswar: in Num a => a -> a -> a, you choose what a is at the time of use, and that substitutes everywhere you see a
21:50:53 <athan> vs. the instances which actually define them
21:51:03 <fred-fri> dreaswar, unless im mistaken, in eg java you can't + an integer and a double either. while technically you could make the compiler figure out it could still do it by casting or converting the integer to a double, that would be arguably be very undesirable, so its better to leave it to the coder to do it explicitly
21:51:50 <athan> same argument in Haskell
21:52:14 <EvanR> fred-fri: answer :: a -> a -> a. answer x y = ?
21:54:12 <fred-fri> foo :: a -> a -> a
21:54:12 <fred-fri> foo x y = x
21:54:25 <EvanR> ding ding ding
21:54:30 <EvanR> and the other is
21:54:42 <fred-fri> y
21:54:48 <Layl> within a do block, how could I change `foo <- bar \n baz foo` to have `bar` be called in-line
21:54:52 <fred-fri> so it just drops one of the arguments
21:55:17 <YellowOnion_> Layl, bar >>= baz?
21:55:22 <fred-fri> i dont see how this is a useful function but ive been known to fail to see how useful things are useful in the past
21:55:35 <dreaswar> ok, @EvanR, what then would be the use of TypeClass since anyway we can use functions to convert explicitly. 
21:55:48 <Layl> YellowOnion_: thanks that works
21:55:55 <EvanR> fred-fri: the standard name for the first one is const
21:56:17 <EvanR> dreaswar: so you can use the same name with different types
21:56:36 <monochrom> dreaswar: type classes are orthogonal to conversions.
21:56:38 <EvanR> instead of + and +. in ocaml
21:57:06 <monochrom> When I want to add Doubles, I don't want to "convert to int first" anyway.
21:57:09 <fred-fri> dreaswar, from haskellbook: "A typeclass is a means of expressing faculties or interfaces that
21:57:10 <fred-fri> multiple datatypes may have in common. This enables us to
21:57:10 <fred-fri> write code exclusively in terms of those commonalities without
21:57:10 <fred-fri> repeating yourself for each instance. Just as one may sum values
21:57:10 <fred-fri> of type Int, Integer, Float, Double, and Rational, we can avoid
21:57:10 <fred-fri> having different (+), (*), (-), negate, etc. functions for each by
21:57:12 <fred-fri> unifying them into a single typeclass. Importantly, these can
21:57:14 <fred-fri> then be used with all types that have a Num instance. Thus, a
21:57:18 <fred-fri> typeclass provides us a means to write code in terms of those
21:57:20 <fred-fri> operators and have our functions be compatible with all types
21:57:22 <fred-fri> that have instances of that typeclass, whether they already exist
21:57:24 <fred-fri> or are yet to be invented (by you, perhaps)."
21:57:49 <monochrom> And when I want to add Word8's, I don't want to "convert to Double first" either.
21:58:21 <monochrom> If you think in terms of conversion, you are not thinking operator overloading.
21:58:29 <dreaswar> exactly, thats what i meant. If indeed thats the advantage (using +,*,-,/ operators across typeclass) then shouldnt it handle conversion as well ? 
21:58:44 <EvanR> there is a Convertible class
21:58:45 <Layl> Sweet, I've got haskell callbacks working and exporting!
21:59:06 <EvanR> or the idea of one
21:59:13 <Cale> dreaswar: Shouldn't what handle conversion? Num? It handles conversion from Integer to any numeric type
21:59:17 <EvanR> e.g. instance Convertible Word8 Int8
21:59:24 <Cale> :t fromInteger
21:59:26 <lambdabot> Num a => Integer -> a
21:59:45 <Cale> :t toInteger -- instances of Integral can be converted to Integer
21:59:47 <lambdabot> Integral a => a -> Integer
21:59:48 <EvanR> Cale: shouldnt the type class mechanism handle conversions, they asked
22:00:03 <Cale> ah, well, our actual type classes handle conversions
22:00:08 <Cale> :t fromIntegral
22:00:10 <lambdabot> (Num b, Integral a) => a -> b
22:00:17 <Cale> ^^ from any integral type, to any type of number at all
22:00:26 <Cale> :t realToFrac
22:00:28 <EvanR> and even with the Convertible class you still have to write the conversion
22:00:28 <lambdabot> (Real a, Fractional b) => a -> b
22:00:40 <EvanR> so i repeat, in haskell you dont do implicit conversions, period
22:01:02 <dreaswar> so Cale, that brings me to the first question :- :t( length [1,2,3,4])  is Int , which is an instance of Num. :t(+) :: Num a => a -> a, so why dosent length [1,2,3,4] + 8.3 works with both are instances of Num ? 
22:01:16 <EvanR> i answered that one in several ways
22:01:19 <Cale> dreaswar: because of the type of (+)
22:01:21 <Cale> :t (+)
22:01:23 <lambdabot> Num a => a -> a -> a
22:01:25 <EvanR> :(
22:01:34 <Cale> ^^ it says that both the arguments and the result have the same type
22:01:43 <Cale> and that this type must be an instance of Num
22:01:47 <monochrom> Yeah, learning requires hearing the same message 3 times.
22:02:13 <dreaswar> :(
22:02:43 <Cale> > fromIntegral (length [1,2,3,4]) + 8.3
22:02:45 <lambdabot>  12.3
22:02:49 <Cale> :t fromIntegral (length [1,2,3,4]) + 8.3
22:02:51 <lambdabot> Fractional a => a
22:03:02 <Cale> > fromIntegral (length [1,2,3,4]) + 8.3 :: Complex Double
22:03:05 <dreaswar> so + has to satisfy two conditions, one same Type and second same TypeClass .. 
22:03:05 <lambdabot>  12.3 :+ 0.0
22:03:19 <EvanR> no
22:03:28 <EvanR> one same type, two Num
22:03:32 <monochrom> Huh? The type class is already known to be Num. What same type class?
22:03:52 <dreaswar> so same Type and Num class.. 
22:03:52 <dreaswar> ok 
22:03:52 <dreaswar> ? 
22:03:59 <Cale> Both the arguments *and* the result need to have the same type
22:04:08 <Cale> *and* that type must itself be an instance of Num
22:04:18 <EvanR> which makes sense because an algorithm for addition is not written against every other possible implemenations of numbers
22:04:23 <dreaswar> Cale. Thanks, 
22:04:35 <EvanR> its written with x and y being of the same type
22:04:37 <monochrom> In fact, why do we even need to talk of "the same type" as if there could be two? There is only one type. You choose one type and you stick to it. Make up your mind.
22:04:50 <Cale> Examples of instances of Num include most types which you'd regard as some kind of number
22:05:06 <YellowOnion_> Layl, have you tried using h$runSync?
22:05:13 <Cale> Int, Integer, Word32, Float, Double, Complex Double, Rational, etc, etc.
22:05:17 <EvanR> and the machine instructions for addition take 2 of the same sort of things as arguments
22:05:23 <shanemik_> ping
22:05:38 <Cale> So you can pick any one of those to plug in for 'a' in the type, and it will work
22:05:52 <Cale> So you can have (+) :: Complex Double -> Complex Double -> Complex Double
22:06:05 <Cale> and (+) :: Int64 -> Int64 -> Int64
22:06:36 <Cale> But no matter which type you choose the 'a' to be equal to, you can't change your mind halfway through the type signature :)
22:06:40 <monochrom> This is why I wrote http://www.vex.net/~trebla/haskell/prerequisite.xhtml#substitution . You see "a -> a -> a" and you get to say "today I want to plug in a=Int". But that means Int -> Int -> Int. You plug in coherently.
22:06:49 <Cale> yes :)
22:07:14 <EvanR> a review of substitution... yet another prereq for the monad tutorial ...
22:09:53 <Cale> dreaswar: This ability to say "I not only want these things to be of some type which satisfies the given interface, but also they should have the same type" is something that often OOP languages struggle to express, and it's really nice to have in a lot of cases.
22:10:30 <EvanR> parametric interfaces
22:10:31 <Layl> YellowOnion_: replacing runmain with that seems to run the main function, but break all callbacks
22:10:50 <Layl> it's setting *something* as a callback, but it's not actually doing anything on callback
22:10:57 <Layl> I would assume there's some initialization code missing now
22:11:03 <monochrom> Java surrendered by adopting Phil Wadler's "generic" system.
22:12:31 <monochrom> In fact Java generics got a bit better than Haskell because Java generics has a syntax equivalent for "forall a".
22:13:41 <monochrom> So to put it mildly Haskell is missing out on ScopedTypeVariables where Java generics already has it (and more --- rank-n types).
22:16:40 <Lokathor> stack seems to have gotten confused, and it had to reinstall ghc
22:16:58 <glguy> Java's type system is powerful enough to typecheck a general coersion function, http://io.livecode.ch/learn/namin/unsound
22:16:59 <Lokathor> now it doesn't read my .ghci file, it makes a temp config script and loads that every time
22:17:28 <monochrom> This is why I still refrain from stack. The line between "abstraction" and "unpredictable black box" is very thin.
22:17:38 <Lokathor> damn
22:17:44 <Layl> wait so if cabal is a build tool
22:17:50 <Layl> does that make stack a build build tool tool
22:17:54 <monochrom> You never know the exact precondition upon which stack decides to install one more local copy of GHC.
22:18:04 <Lokathor> cabal-the-binary is not invoked by stack most of the time, so no
22:18:20 <monochrom> Well, I guess I should stick to speaking for myself. I never know. Maybe you or someone does.
22:19:01 <monochrom> cabal has its limitations but it is dumb enough to be predictable.
22:19:12 <Lokathor> i'll just have an ugly ghci for a bit
22:19:21 <c_wraith> are you worried new-build might be attempting to make cabal too smart?
22:19:28 <c_wraith> Or is it just a better dumb?
22:20:16 <monochrom> I don't know. But I can circumvent the version resolver if I want to. (To be sure, true for stack too.)
22:20:41 <monochrom> The benefit of cabal is that it won't suddenly decide that your copy of GHC is invisible.
22:20:53 <Lokathor> in fairness, stack is operating mostly correctly
22:21:04 <Lokathor> i'm just not understanding where it's trying to read for a .ghci file
22:21:37 <monochrom> The drawback of stack is that it wants to control your GHC too, and you don't know how it thinks, and it always downloads GHC one more time and kill your internet data limit this month.
22:21:48 <monochrom> s/limit/quota/
22:22:50 <Layl> monochrom: haven't you heard? Disk space is cheap! That's why tools will now randomly without instruction download multiple gigabytes of data localized to just your local project at random
22:24:17 <monochrom> xkcd needs to make a comic on "<A> Hey get back to work  <B> Stack's downloading GHC  <A> OK carry on"
22:24:42 <Lokathor> Layl, Cargo downloads and compiles all the crates it needs per project :P
22:25:05 <Layl> Lokathor: I do like that behavior actually
22:25:18 <Layl> nothing can go wrong because some other project decides to use an old version of a lib
22:25:37 <monochrom> Did you know that the experimental laser data link between Earth and Moon is like 100x faster than your home internet?
22:26:26 <c_wraith> I don't know if it has very good ping, though.
22:26:47 <Layl> It's likely going to have better ping than comcast
22:26:52 <c_wraith> We need to pull a futurama, and increase the speed of light.  What could go wrong?
22:29:17 <Layl> I have made a huge mistake
22:29:33 <Layl> I just realized I've spent about an hour fiddling with i3 window layouts with no way to persist that window layout
22:31:46 <monochrom> No no, you should think like Edison. You should think "this is a great success, I have now learned one more thing!"
22:35:40 <Lokathor> so
22:35:52 <Lokathor> GHC ate up so much memory that it crashed firefox in the process
22:36:22 <monochrom> Yikes. Next time have GHC compete with Chrome, see who dies first :)
22:36:44 <monochrom> (Open a lot of tabs in Chrome to consume more memory)
22:37:18 <Lokathor> the facebook tab of firefox crashed out
22:37:19 <geekosaur> that's easy, just try to tell chrome to open a new window/tab from outside with xdg-open or etc.
22:37:26 <Lokathor> galaxy.EXE: getMBlocks: VirtualAlloc MEM_COMMIT failed: The paging file is too s
22:37:27 <Lokathor> mall for this operation to complete.
22:40:11 <Lokathor> and stricting and unpacking all the fields is not quite good enough here it seems
22:42:05 <c_wraith> Lokathor: if that's on linux...  yeah, the OOM killer just sort of picks something at random to kill.  It doesn't know who the guilty party was
22:42:24 <Lokathor> windows 7
22:44:02 <Lokathor> cutting the generated list size from 10 million down to 10 thousand, now the program seems to do nothing
22:44:09 <Lokathor> tricky
22:45:00 <EvanR> who kills the OOM killer
22:46:42 <pikajude> the kernel
22:47:23 <mniip> EvanR, kexec() or shutdown()
22:56:17 <Lokathor> http://lpaste.net/351505 so, if i use mkGalaxy (line 62) with a 10 bigger input, the memory used shoots waaaaaaaay over 10x in response
22:57:58 <Lokathor> ~80mb max used to about ~1.4gb max used
22:58:30 <Lokathor> where is that difference boiling away into
23:05:12 <Guest86770> can any one help me how to avoid mitm isp attacks.  I attacker is mimicking my isp gateway which reroutes all my traffic directly from my modem to attacker
23:06:19 <monochrom> glguy: Oh I see! Suppose I have two unrelated Java types Int and String, so unrelated that they aren't even in any subtyping relation. But I can use wildcards to trick Java into believing that now a witness Z exists for Int <: Z <: String, so suddenly I have one more subtyping relation.
23:06:58 <monochrom> I always knew that wildcards were up to no good.
23:10:47 <Guest86770> i always get a wildcard from wildcard.twimg.com
23:11:05 <Guest86770> ti seen i was no good when it carried a cert a few weeks ago
23:19:06 <Guest86770> any one know malware that i can use as a sort of honey pot for the guy who is monitoring me
23:19:22 <monochrom> you're in the wrong channel
23:19:57 <monochrom> also you are not making sense. are you human?
23:20:19 <Guest86770> no i am reptile sorry wrong room
23:20:33 <Lokathor> good reply tho
23:20:44 <Lokathor> also i figured my memory issue
23:20:46 <Lokathor> ...mostly
23:20:49 <tomus> my company works in go
23:21:00 <tomus> I am not a great fan of go :(
23:21:30 <Lokathor> now it takes about 80mb to print 100k star stubs most of the way though, but partway through the memory use jumps up suddenly to 113mb,
23:21:44 <Lokathor> not sure why it jumps like that
23:22:28 <monochrom> You have a [StarStub]. How long is that?
23:23:12 <monochrom> But it's going to take 24n bytes, if n is the length.
23:24:01 <Lokathor> the task manager reports that the space used is 80mb almost instantly, then most of the way through evaluating the list it goes up to 112mb for a moment, then up to 113mb, then down to 5mb once the list gets dropped
23:24:21 <Lokathor> in this case, the list is 100,000 elements long
23:24:51 <Lokathor> updated the lpaste, http://lpaste.net/351505
23:25:04 <monochrom> I spoke too soon. 24n is just the list skeleton.
23:25:42 <monochrom> Hmm how much does an unpacked Float take? That's a new one.
23:25:48 <Lokathor> 32 i thought
23:26:37 <monochrom> You may be surprised by alignment issues and GHC generosity in consuming your memory
23:26:44 <Lokathor> oh no!
23:26:57 <monochrom> For example Int8 sill takes 8 bytes. Even after unpacking IIUC
23:28:27 <Lokathor> int8 is... 8 bytes?
23:28:30 <Lokathor> not 8 bits?
23:28:58 <Lokathor> GHC thy name is MAMMON
23:29:44 <dmwit_> what?
23:29:45 <dmwit_> no
23:29:50 <dmwit> > maxBound :: Int8
23:29:53 <lambdabot>  127
23:30:19 <dmwit> Oh, I understand what monochrom means.
23:30:20 <Lokathor> dmwit, well, the memory space isn't defined by the maxbound
23:30:23 <monochrom> You are in luck because "data Float = Ctor Float#" so it maybe be just 4 bytes after unpacking (the Float# part).
23:30:29 <dmwit> It's probably worse than 8 bytes.
23:30:31 <dmwit> It's probably 16.
23:30:37 <Lokathor> oh shiiiiiit
23:30:53 <monochrom> But Int8 is screwed. "data Int8 = Ctor Int#".
23:31:09 <Lokathor> welp, in this case it's just Word and Float we're worried about
23:31:19 <Lokathor> I guess those Word values could be Word32 values
23:31:20 <monochrom> Because alignment requirements would still waste the other 7 bytes anyway.
23:31:42 <monochrom> (And GHC insists on alignment because it enables pointer tagging)
23:32:32 <monochrom> OK so each StarStub record is 8+4+4 bytes if we're optimistic.
23:32:48 <Lokathor> recompiling with Word32 instead of Word
23:32:57 <monochrom> So for a [StarStub] of length n, you're looking at (24 + 8 + 4 + 4)n
23:33:02 <Lokathor> perfectly stable 82,380k memory use during the entire evaluation
23:34:12 <Lokathor> and 4,620k after the list gets dropped
23:34:22 <dmwit> You can probably get an n-long UArray Int8 to fit in n bytes + a small (independent of n) amount of overhead.
23:34:31 <monochrom> That's strange because Word32 suffers the same problem. "data Word32 = Ctor Word#"
23:35:12 <Lokathor> word32 is the same space as word
23:35:15 <Lokathor> oh boy
23:35:41 <monochrom> I am only uncertain about Float#
23:36:02 <nshepperd> Lokathor: maybe you want https://www.fpcomplete.com/blog/2016/05/weigh-package (thanks MarcelineVQ for mentioning this ^_^)
23:36:28 <nshepperd> to narrow down the memory usage
23:36:40 <Lokathor> Well, this is just test code
23:36:50 <Lokathor> it will vary widely in time, i'm sure
23:37:09 <Lokathor> the primary goal I had when writing this was seeing how much startup time would be to generated all the star positions
23:37:28 <Lokathor> turns out, 100k stars is "blink and you'll miss it" fast
23:38:26 <monochrom> the problem with wishing upon 100k stars :)
23:38:49 <Lokathor> no that's good. It means that the game can probably use 100k as the average star count
23:39:21 <nshepperd> monochrom: aw, there isn't a Int8#?
23:39:22 <Lokathor> yeah, if i don't have it print the stars, it can print the final generator before the counter thread gets to print even once
23:40:32 <monochrom> No, it's whole machine words all the way down
23:41:04 <Lokathor> but my cache lines!
23:41:10 <nshepperd> I would have thought Int8# would be allowed to be misaligned since you don't need to take a pointer to it
23:42:00 <Lokathor> perhaps GHC will never be max speed
23:42:14 <Lokathor> but at least we have green threads
23:45:44 <monochrom> I spoke too soon again. I forgot to count the fact that the StarStub constructor takes 8 more bytes.
23:46:27 <monochrom> But now it's final. I have read the Cmm code to find out how many bytes it allocates on the heap. "Hp = Hp + 32;"
23:47:15 <monochrom> 8 bytes for the constructor (aka tag), 8 bytes for unpacked !Word, 8 for unpacked !Float, 8 for unpacked !Float the second time.
23:47:35 <Lokathor> hmm
23:47:49 <monochrom> [StarStub] of length n is going to be (24+32)n bytes
23:48:04 <monochrom> That's for 64-bit GHC. If 32-bit, half.
23:48:17 <Lokathor> in rust it'd be... just 8 less I think. u32, f32, f32 = 12bytes each
23:49:33 <jmnoz[m]> :t (<~~>)
23:49:35 <lambdabot> error: Variable not in scope: <~~>
23:49:40 <monochrom> You may like to use Vector.Storable to cut that 24 at the very least.
23:49:58 <monochrom> I mean unless you have a lazy list.
23:50:25 <Lokathor> well sure, the format of the storage will probably be vector later
23:50:32 <jmnoz[m]> This gist from 2012 contains "<~~>", any idea what it is? https://gist.github.com/paul-r-ml/738025
23:50:42 <Lokathor> but that's like, at least 2x as hard to figure
23:50:42 <jmnoz[m]> hoogle, hayoo, google comes up short
23:51:21 <monochrom> In fact if you go Vector.Storable this is where you get to write your own peek and poke, therefore you could really use only 4 bytes for a Float.
23:51:44 <Lokathor> jmnoz[m], p1 <~~> p2 = ignore $ forkIO (p1 `proxyTo` p2) >> forkIO (p2 `proxyTo` p1)
23:51:53 <Lokathor> it's in the "where" clause listings
23:52:04 <jmnoz[m]> oh doh, thanks
23:52:44 <Lokathor> monochrom, but that sounds like it'd be slower
23:53:06 <monochrom> yeah I can't eliminate that possibility
23:53:12 <Lokathor> anyway, once a player visits a star system then it'll get expanded out
23:53:24 <Lokathor> and all the memory in the world will be eaten up by lambdas
23:53:32 <Lokathor> so it's okay
23:53:37 <monochrom> :)
23:54:01 <monochrom> "space, the final frontier" literally
