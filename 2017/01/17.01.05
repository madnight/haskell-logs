00:10:14 <lyxia> this is a traversal
00:10:42 <lyxia> hm, a fold
00:11:31 <tsahyt> Hello! foldr on lists still traverses left to right as far as I know. What would I do when I need to traverse right to left though? I suppose reversing the list first is an option, but I was wondering whether there was a more elegant way
00:14:46 <spocot> foldl and foldr traverse from opposite directions
00:16:07 <spocot> foldr should traverse from the right, no?
00:16:39 <tsahyt> I remember reading that it doesn't. let me check
00:17:57 <tsahyt> I don't see why it would
00:18:32 <tsahyt> foldr k z = go where go [] = z ; go (y:ys) = y `k` go ys  
00:18:48 <tsahyt> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#foldr
00:19:38 <lyxia> it does start accumulating from the right
00:19:47 <tsahyt> ah that was it
00:19:52 <tsahyt> I think that might actually be enough for me
00:20:15 <lyxia> foldr (%) z (a : b : []) = a % (b % z)
00:20:16 <tsahyt> so from what I can tell it builds up (y1 `k` (y2 `k` (... `k` yn)..), right?
00:20:56 <tsahyt> I'm not sure whether that's the right way to say it but it makes k associate to the right
00:21:03 <srhb> tsahyt: You can think of l/r as parens associativity yeah
00:21:10 <tsahyt> I think that's enough for my usecase anyhow
00:22:28 <srhb> > (foldr f a [x,y,z], foldl f a [x,y,z])
00:22:31 <lambdabot>  (f x (f y (f z a)),f (f (f a x) y) z)
00:23:12 <tsahyt> lambdabot is just tremendously useful
00:23:21 <tsahyt> thanks for the help!
00:31:01 <lyxia> dylanj_: http://lpaste.net/350898
00:33:40 <dylanj_> lyxia: That's awesome, thank you.
01:01:58 <spocot> Anybody have any suggestions for some great resources for advanced haskell techniques?
01:16:01 <orzo> I want to use things like Read and IsString to make an attoparsec parser
01:16:16 <orzo> is there a way to catch those exceptions and turn them into parse fails?
01:18:13 <pavonia> orzo: You can use readMaybe instead, so you don't have to deal with exceptions
01:21:39 <mounty> belated thanks @liste
01:28:36 <nevere> What is `Pure` and `Text` in this line of code https://github.com/jaspervdj/digestive-functors/blob/8b61bc72d20f79add4496e2dab358d37dfb6fefb/digestive-functors/src/Text/Digestive/Form.hs#L103
01:34:16 <lyxia> https://github.com/jaspervdj/digestive-functors/blob/8b61bc72d20f79add4496e2dab358d37dfb6fefb/digestive-functors/src/Text/Digestive/Form/Internal.hs#L81 nevere 
01:34:53 <lyxia> https://github.com/jaspervdj/digestive-functors/blob/8b61bc72d20f79add4496e2dab358d37dfb6fefb/digestive-functors/src/Text/Digestive/Form/Internal/Field.hs#L29
01:41:47 <nevere> How can I parse Int values while using Text.Digestive.Aeson libraries without wrapping the integer value                                                                                                                                                                                                                                                                                                                                            
01:41:56 <nevere> In ""?
01:42:44 <nevere> How can I parse Int values while using Text.Digestive.Aeson libraries without wrapping the integer value in "" (in the json)?
01:47:24 <Squarism> :djinn (a ->b) -> (c -> d) -> (b -> d -> e) -> e
01:55:15 <samvher> Does anyone here have a lot of experience with the FFI? I'm having some trouble. I'm using stack + nix maybe that's making it a bit harder for me. The problem is right at the beginning: I'm not sure how to get my libraries included
01:56:35 <samvher> (I get a Missing C library error)
02:02:03 <Squarism> theres no : Bool -> a -> Maybe a ?
02:02:18 <Squarism> in base?
02:08:31 <osa1> samvher: there's a cabal field for native library dependencies
02:09:40 <osa1> samvher: "extra-libraries"
02:10:45 <osa1> samvher: see this cabal file as an example https://github.com/osa1/hslua/blob/master/hslua.cabal it has native dependencies, C files included in the package, extra include dirs etc. probably everything you need
02:11:26 <osa1> :t bool
02:11:27 <lambdabot> a -> a -> Bool -> a
02:11:55 <osa1> :t \b a -> bool Nothing (Just a) b
02:11:57 <lambdabot> Bool -> a -> Maybe a
02:12:01 <osa1> Squarism: ^
02:12:53 <mrbackend> @pl \b a -> bool Nothing (Just a) b
02:12:53 <lambdabot> flip (bool Nothing . Just)
02:13:24 <Squarism> i thought there could have been one
02:13:30 <Squarism> but sure
03:05:05 <Philonous> Is there a package for easy sampling from various distributions (e.g. normal, exponential, poisson etc.) ?
03:08:40 <oish> Anyone able to help with this persistent db question? http://lpaste.net/350901
03:09:18 <oish> is it possible to hide a field when showing an object as JSON from Persistent?
03:09:46 <oish> (Or do I have to write my own Show, To/FromJSON instances)
03:15:06 <amx> I don't see a way around a custom ToJSON instance
04:04:02 <henr_k>  /ignore joins parts quits
04:04:05 <henr_k> bah, sorry
04:14:40 <zomg> henr_k: smartfilter.pl if you use irssi :)
04:18:39 <maerwald> how to check reverse deps on hackage/cabal?
04:18:45 <henr_k> zomg: thanks!
04:19:22 <amx> maerwald: using something like http://packdeps.haskellers.com/reverse
04:19:52 <maerwald> the library is not there
04:20:25 <amx> which one?
04:20:58 <maerwald> MAC
04:22:04 <amx> a package with zero reverse dependencies will not be listed, maybe no one is using it?
04:42:46 <athan> I think it uses stackage snapshots for the reverseness maerwald 
05:09:02 <ongy> hm, I was under the impression that I can always write a pattern as (Constructor var var {}) if I don't want to type out all (_), is that an extension?
05:09:08 <maerwald> Alejandro[m]: are you Alejandro Russo?
05:17:49 <ertes> Philonous: mwc-random, random-fu
05:18:02 <ertes> fast vs. pure respectively
05:20:47 <Philonous> ertes, Thanks
05:22:34 <sbll> Hello. Do you have a striking short example demonstrating the advantages of functional programming.
05:23:28 <ertes> sbll: there are fancy one-liners in pretty much every language and paradigm…  consider those marketing
05:24:42 <ertes> > sequence ["Hh", "3e", "l", "lL", "o0"]  -- if you still want to see one, here you go:
05:24:44 <lambdabot>  ["H3llo","H3ll0","H3lLo","H3lL0","Hello","Hell0","HelLo","HelL0","h3llo","h3...
05:25:11 <Carl`>  sbll: how about total functions (aka functions) vs partial functions?
05:27:06 <ertes> sbll: one advantage of haskell's FP is that 1. functions are actual functions, not procedures, 2. we have a type for effects (IO), so "programs" are actual values in haskell that we can transform and pass around
05:27:39 <ertes> sbll: therefore what you know as built-in control constructs (for, while, if, …) is actually just regular functions in haskell, and you can write your own
05:27:49 <ertes> you can and you will, if you use haskell
05:31:14 <athan> What's the best way to learn lenses?
05:31:42 <ertes> athan: would you care to do two short exercises?
05:32:15 <ertes> you will understand lenses after those and a short explanation =)
05:32:59 <athan> definitely! Okay, I mean I've been leering at them for a... few years honestly
05:33:17 <sbll> ertes: Thanks. It looks interesting. I probably need to try some coding to understand the idea, and I will do. It just seems to me that it takes time to learn it, since it is so different.
05:33:33 <ertes> athan: 1. write a function that maps over the fst of a tuple:  mapFst :: (a' -> a) -> (a', b) -> (a, b)
05:34:02 <ertes> sbll: yes, if you're used to other paradigms, it does take time to *unlearn* =)
05:34:25 <maerwald> if you don't write compilers or something else with overly complicated nested data structures the gain of lenses is not that big and I'd argue maybe even counter-productive for the project (since you increase the threshold for contributors)
05:34:47 <athan> ertes: mapFst = fmap -- :p
05:34:51 <athan> er
05:34:54 <athan> duy
05:34:56 <athan> sorry haha
05:35:04 <ertes> athan: not quite…  oh, and you're not allowed to use Data.Bifunctor either =)
05:35:07 <athan> mapFst f (x,y) = (f x, y)
05:35:12 <athan> D:
05:35:51 <ertes> athan: alright, 2. write an effectful version of that function:  traverseFst :: (Functor f) => (a' -> f a) -> (a', b) -> f (a, b)
05:36:03 <athan> This is a lens because the act of going in and coming back out is lossless, right? Vs. a prism which might hit a sum or something?
05:36:42 <ertes> athan: if this were a lens, yes, but there is actually an even simpler reason why it's a lens that you will shortly see
05:36:49 <athan> traverseFst f (x,y) = (,y) <$> f x
05:37:02 <athan> hmm okay :x
05:37:04 <ertes> athan: good…  traverseFst is an actual lens
05:37:11 <ertes> you can use it with the lens library
05:37:17 <athan> ahh! woah okay
05:37:28 <ertes> athan: reason:  when f = Identity, this is just mapFst, so you can use it as a setter
05:37:46 <ertes> you can write a convenience function (call it (%~)) to use in that way
05:38:15 <ertes> athan: when f = Const a', then you can use it as a getter
05:38:37 <ertes> again: you can write a convenience function (call it (^.)) to use it in that way
05:38:42 <athan> Okay, so a lens is just a "different" traverse, for subcomponents of a type which isn't in the natural functor position (like traverseSnd)?
05:38:55 <athan> !!!
05:38:57 <athan> Woah!
05:39:09 <athan> hold fast, that one hurt haha
05:39:12 <ertes> they are actually a bit stricter:  you *must* have (Functor f)
05:39:27 <kuribas> athan: http://www.seas.upenn.edu/~cis194/fall16/lectures/14-lenses.html
05:39:31 <ertes> if you relax that to (Applicative f), then you have what is known as a "traversal"
05:39:33 <athan> well, I meant functor in the sense of the structure you're looking into, (,) in this case
05:39:48 <athan> thanks kuribas :)
05:40:01 <ertes> sure, but 'traverse' is stronger, because it requires Applicative in general =)
05:40:01 <athan> :O!
05:40:11 <kuribas> athan: also I suggest the documentation of microlens over lens.
05:40:24 <athan> thank you kuribas!!
05:41:02 <kuribas> athan: unless you want to know all the laws ;-)
05:42:17 <athan> :x every time I've tried to explore lens, I just get lost, then use ^. a few times haha
05:42:42 <athan> is there a cheat sheet of the vocabulary for ^. and %~ operators?
05:42:55 <athan> I just saw a ^#, I'm not sure what it has reference to
05:42:58 <Tuplanolla> Microlens is pretty nice, athan.
05:43:08 <ertes> athan: no, but they are quite intuitive…  they follow conventions that you get used to
05:43:09 <athan> something like `ALens' s t` or a "Context"
05:43:18 <athan> hm okay
05:43:37 <kuribas> athan: I simply don't use them.
05:44:09 <athan> kuribas: you prefer the `traverseX` variants?
05:44:13 <athan> _1 etc?
05:44:21 <ertes> athan: well, here is another exercise:  implement (%~) :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
05:44:36 <kuribas> athan: I use the named alternatives (assign, modify, over, set, etc...)
05:45:10 <Tuplanolla> My theoretical understanding of lenses is almost disjoint from my practical knowledge. Maybe they'll unify eventually.
05:45:24 <athan> ertes: Ahh, and that first part is the profunctor?
05:45:31 <ertes> athan: once you've done that, you can make the type signature of (%~) prettier:  type ALens s t a b = (a -> Identity b) -> s -> Identity t
05:45:48 <ertes> that's where all those ATypes come from
05:46:12 <ertes> in other words: when a function is asking for an ALens, it's asking for a Lens =)
05:46:37 <ertes> uh
05:46:49 <ertes> that was an unfortunate example
05:47:03 <ertes> type ASetter s t a b = (a -> Identity b) -> s -> Identity t
05:47:04 <athan> doodad %~ f = \s -> runIdentity $ doodad (Identity . f) s -- :O
05:47:07 <athan> woah okay
05:47:21 <ertes> type AGetter s t a b = (a -> Const a b) -> s -> Const a t
05:47:30 <athan> and if Identity is a... monad and a comonad, it can be arbitrarilly effectful?
05:47:47 <ertes> Identity doesn't have any effects
05:48:17 <athan> That's what I mean
05:48:22 <athan> nor does Const... kinda
05:48:31 <athan> but they are "unwrappable" I mean
05:48:38 <athan> I think this has to deal with an Iso..?
05:49:04 <athan> maybe a... CoApplicative? :s
05:49:07 <ertes> not really…  they are just different choices for f in 'traverseFst' (and other lenses)
05:49:15 <athan> with `dirty :: f a -> a` :D
05:50:06 <athan> doodad %~ f = \s -> dirty $ doodad (pure . f) s
05:50:18 <Tuplanolla> ...and `Comonad` should've come with `borrow`, athan.
05:50:22 <ertes> you're not using any generic interface to them
05:50:47 <athan> where (%~) :: (Applicative f, CoApplicative f) => ((a -> f b) -> s -> f t) -> (a -> b) -> s -> t
05:51:05 <athan> @type borrow
05:51:08 <lambdabot> error: Variable not in scope: borrow
05:51:31 <kuribas> athan: I believe '^' means get, '%' modify, '~' over a value '=' over a state, '?' over a maybe value, '.' accessor, '..', access multiple values, etc....
05:51:34 <athan> Tuplanolla: I can't see the pun sorry :)
05:51:46 <athan> ertes: Hmm, okay :)
05:51:57 <Tuplanolla> You can `return` the value later, athan.
05:52:04 <athan> ahh wow okay
05:52:14 <athan> ahaha
05:52:17 <athan> thanks Tuplanolla 
05:52:25 <ertes> > ["abc", "def", "ghi"] ^. traverse
05:52:27 <lambdabot>  "abcdefghi"
05:52:38 <athan> hold on one sec
05:53:24 <maerwald> has anyone played with MAC?
05:53:49 <athan> so that's saying, because list is LensLike (correct?), you are... getting them with traverse?
05:54:19 <maerwald> I'm reading the paper and I cannot see (or agree) how the method of labels gives any guarantee about secure operations, since I can just unwrap high-security labels via (unId . unRes) and feed them to my own malicious IO functions
05:54:23 <Xnuk> esoteric lens
05:54:27 <athan> that just feels like an awkward sequence for some reason :s
05:54:35 <kuribas> > view traverse ["abc", "def", "ghi"]
05:54:38 <lambdabot>  "abcdefghi"
05:55:02 <kuribas> > listOfview traverse ["abc", "def", "ghi"]
05:55:05 <lambdabot>  error:
05:55:05 <lambdabot>      Variable not in scope:
05:55:05 <lambdabot>        listOfview :: ((a0 -> f0 b0) -> [a0] -> f0 [b0]) -> [[Char]] -> t
05:55:08 <kuribas> > listOf traverse ["abc", "def", "ghi"]
05:55:12 <lambdabot>  error:
05:55:12 <lambdabot>      • Couldn't match expected type ‘[[Char]] -> t’
05:55:12 <lambdabot>                    with actual type ‘Gen [a0]’
05:55:23 <kuribas> > toListOf traverse ["abc", "def", "ghi"]
05:55:27 <lambdabot>  ["abc","def","ghi"]
05:55:29 <maerwald> and those functions are exported unconditinally in the package
05:55:47 <kuribas> ertes: does view combine with a monoid?
05:56:14 <ertes> kuribas: not 'view', but the Applicative instance of Const =)
05:56:28 <athan> Is Getting just an open type family?
05:56:46 <kuribas> ertes: I see, thanks.
05:56:52 <Tuplanolla> @info Getting
05:56:52 <lambdabot> Getting
05:56:57 <Tuplanolla> Thanks, lambdabot.
05:57:31 <Xnuk> @info @info
05:57:32 <lambdabot> <unknown>.hs: 1: 1:Parse error: @
05:58:07 <ertes> > [1,2,3,4] ^. traverse . iso Sum getSum
05:58:09 <lambdabot>  Sum {getSum = 10}
05:58:43 <athan> ertes: what is the function you're supplying to `traverse` in `[..] ^. traverse`?
05:58:54 <athan> because traverse is like fmap with effects, right?
05:59:08 <athan> Ahh! hmm
05:59:48 <kuribas> athan: https://hackage.haskell.org/package/microlens-0.4.7.0/docs/src/Lens.Micro.html#%5E.
05:59:50 <athan> does iso inherit a monoid as an effect!? whaaa
06:00:11 <kuribas> "s ^. l = getConst (l Const s)"
06:00:21 <athan> ehrmagherd
06:00:25 <athan> @type iso
06:00:29 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
06:00:31 <athan> that is beautiful
06:00:40 <kuribas> athan: the function is "Const"
06:00:42 <kuribas> :t Const
06:00:45 <lambdabot> forall k a (b :: k). a -> Const a b
06:01:11 <athan> Would `p s (f t)` be applicative in that case...?
06:01:24 <ertes> athan: the behaviour you're seeing comes from the Applicative semantics of Const
06:01:37 <athan> Ahh wow
06:01:43 <athan> that is so strange
06:01:46 <ertes> > Const "abc" <*> Const "def" :: Const String ()
06:01:49 <lambdabot>  Const "abcdef"
06:01:58 <kuribas> athan: it will become clear if you read the link to the course I send...
06:02:00 <athan> so there's an implicit Const effect every time you use ^. ?
06:02:05 <athan> that you need to account for
06:02:34 <ertes> athan: you don't need to account for it…  consider it as a feature you get for free
06:02:45 <ertes> in particular you will never observe it with lenses
06:02:49 <ertes> it's a traversal feature
06:03:05 <ertes> because lenses don't use Applicative…  all they need is Functor
06:03:10 <jstolarek> how can I has a String?
06:03:11 <shapr> jophish: that dbrecord-opaleye is really neat, are there other useful libs that extend opaleye?
06:03:24 <jstolarek> there used tobe hashString :: String -> Int32 in Data.HashTable
06:03:31 <jstolarek> but this was removed
06:03:33 <shapr> oh "hash a string"
06:03:45 <shapr> I read that as "I can haz String?"
06:03:49 <athan> jstolarek: Hashable exposes a hash function :)
06:03:52 <athan> same haha
06:04:06 <Tuplanolla> :t canHasString
06:04:08 <lambdabot> Bool
06:04:09 <ertes> the hash function of hashable is very simplistic though, so beware
06:04:34 <jstolarek> ah, got it
06:05:24 <shapr> Tuplanolla: how'd you do that magic?
06:05:30 <shapr> > canHasString
06:05:35 <lambdabot>  True
06:05:38 <shapr> ok then
06:05:51 <shapr> god morgon athan! 
06:06:30 <athan> x.x wait, why is Monoid used in Const's Applicative?
06:06:32 <maerwald> ah, MAC depends on the Unsafe Language pragma to enforce that trustworthy code doesn't unwrap security labels
06:06:52 <ertes> athan: pure x = ?
06:07:06 <athan> shapr: I can't wait to blair my ghetto blaster in this neighborhood ;-;
06:07:34 <shapr> athan: I thought you were in .dk or something?
06:07:44 <athan> ertes: Oh! It's where the unused data comes from?
06:07:49 <shapr> athan: do they even sell ghetto blasters in kopenhamn?
06:08:11 <athan> pure x = Const x undefined :v
06:08:41 <athan> oh no, I'm in Seattle USA :)
06:08:47 <ertes> athan: well, you need to return *something*, so one option is to return mempty, at which point you've locked yourself into Monoid, not because you used mempty, but because the Applicative laws coerce you into using (<>) for (<*>)
06:08:47 <shapr> oh, ok
06:08:48 <athan> It's about 6am here
06:09:05 <ertes> athan: pure = Const
06:09:08 <ertes> no undefined
06:09:17 <maerwald> oh dear, I guess lambdabot would be a perfect fit for applying MAC
06:09:30 <athan> Oh wait yes I'm being silly
06:09:36 <shapr> I'm in Atlanta, I got to meet a #haskell member from 2007 last night! Does anyone remember DrSyzygy?
06:09:45 <athan> the "unused data" is at the type level
06:09:56 <ertes> shapr: i remember that name, but it's long ago
06:10:12 <shapr> ertes: now is @michiexile on twitter
06:10:18 <ertes> can't connect it to anything other than: "seen somewhere on IRC" =)
06:10:51 <shapr> He's in town for the Joint Mathematics Meeting. I'm going to the JMM knitting circle tonight!
06:11:02 <kuribas> > [1, 2, 3] ^. traverse
06:11:05 <lambdabot>  error:
06:11:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M770448700100...
06:11:05 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:11:10 <shapr> I still haven't figured out how to apply Haskell to knitting.
06:11:12 <kuribas> > [1 :: Int, 2, 3] ^. traverse
06:11:16 <lambdabot>  error:
06:11:16 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘traverse’
06:11:16 <lambdabot>      • In the second argument of ‘(^.)’, namely ‘traverse’
06:11:28 <kuribas> > [1 :: Sum Int, 2, 3] ^. traverse
06:11:30 <lambdabot>  Sum {getSum = 6}
06:11:40 <maerwald> kuribas: you can pm lambdabot for experiments and then post the working example here
06:11:46 <maerwald> less noise
06:11:48 <kuribas> maerwald: right, sorry
06:11:49 <athan> shapr: knot algebra!
06:11:55 <Philippa> shapr: ah! Good to put those two names together
06:11:57 <ertes> maerwald: what's this MAC you speak of?
06:12:03 <maerwald> @hackage mac
06:12:04 <lambdabot> http://hackage.haskell.org/package/mac
06:12:23 <maerwald> see the linked paper
06:12:27 <ertes> ah!  nice
06:12:29 <ertes> thank you
06:12:34 <maerwald> pretty interesting, similar to information flow control
06:12:42 <athan> knot compilers! :v
06:12:59 <ertes> i was trying to do MAC via type families, but failed due to the non-dependentness of haskell's type system
06:13:11 <ertes> (failed in the sense: it worked, but it was super-awkward to use)
06:13:12 <shapr> athan: great idea, but I'm not even sure where to start with that
06:13:29 <shapr> athan: was that a joke about "tying the knot" ?
06:13:39 <athan> oh jeez, well now it is haha
06:13:43 <shapr> :-)
06:14:20 <athan> prove that this knot can be fused into a smaller knot by just tugging at it strictly
06:15:24 <maerwald> ertes: there's also https://hackage.haskell.org/package/lio for IFC, which is a bit more complex
06:15:48 <maerwald> there are 2 papers about IFC in haskell, one using arrows, one using monads
06:16:04 <ertes> the interface is puzzling…  why is MAC not a MonadIO?  instead it exports this awkwardly named ioTCB with exactly the same type and semantics of liftIO
06:16:12 <shapr> wow, there's already Haskell code for knot theory: https://hackage.haskell.org/package/HaskellForMaths-0.4.8/docs/Math-Projects-KnotTheory-Braid.html
06:16:32 <maerwald> ertes: because it needs to mark it as unsafe!
06:16:34 <athan> wait, holy potatoes, pure for Const is completely useless isn't it?
06:16:39 <maerwald> otherwise the whole architecture falls apart
06:16:53 <maerwald> as in: library authors must not use MAC.Core
06:17:00 <maerwald> only the end user
06:17:13 <ertes> maerwald: but it's exactly the same semantics…  there is nothing going on behind the scenes
06:17:21 <athan> shapr: *bookmark*
06:17:47 <ertes> maerwald: ah, i see
06:18:03 <shapr> athan: I also found https://hackage.haskell.org/package/knots but I don't know what those words mean.
06:18:04 <ertes> i'm not supposed to use ioTCB/liftIO as a user
06:18:30 <maerwald> ertes: it's not described explicitly in the paper, but for example... unwrapping a security label via (unId . unRes) in a library would allow you to well... ignore the security label and do arbitrary things with the input
06:18:33 <shapr> khovanov homology anyone?
06:18:47 <maerwald> so the module that allows unwrapping is marked unsafe and not to be used by library authors
06:18:53 <maerwald> that way you can establish safe contracts
06:19:00 <ertes> fix :: l -> MAC l ()  -- "to help the type system"
06:19:02 <ertes> oh, come on!
06:19:02 <EvilMachine> hi. is there any recursion that can’t be translated to tail recursion?
06:19:16 <shapr> newsham: howdy! long time no see
06:19:22 <ertes> ok, sorry, that library doesn't seem practical
06:19:24 <athan> shapr: *bookmarks that too*
06:20:24 <ertes> also it's not quite doing what i was looking for…  it establishes security regions by labelling monads, but what i need is access tokens for data
06:20:38 <athan> EvilMachine: Look into supercombinators :)
06:20:44 <shapr> EvilMachine: mutual recursion is more difficult, but not impossible https://en.wikipedia.org/wiki/Mutual_recursion#Computer_functions
06:20:45 <ertes> which is inherently dependent =/
06:20:54 <maerwald> ertes: the mac library is really more about establishing security contracts between a random library author and the library user
06:21:07 <maerwald> and verifying those via the Unsafe language pragma and the type system
06:21:35 <ertes> yeah
06:21:38 <maerwald> which also means: the library author has to play along
06:21:46 <maerwald> if he doesn't want to provide a MAC version of his function
06:21:48 <maerwald> then you are done
06:22:18 <athan> even though the newtype for Const is (b :: k) polykinded, does the instance for Applicative just assume * due to <*>?
06:22:28 <ertes> yeah, that's something entirely different…  i thought it would control access to data
06:22:36 <EvilMachine> athan, shapr: I’m just wondering: If anything could be translated to tail recursion, why would the compiler not make it so?
06:23:03 <athan> EvilMachine: There's no stack in the GHC runtime iirc
06:23:08 <athan> it's a heap allocated G machine
06:23:18 <athan> where edges are pointers
06:23:21 <maerwald> ertes: maybe lio can do what you want, I haven't had a close look at it though
06:24:02 <niklasb> EvilMachine: e.g. to transform a standard depth-first traversal into tail recursive form, you would need to pass what is basically a stack around as the argument
06:24:06 <niklasb> so you don't really gain anythin
06:24:07 <EvilMachine> athan: So it’s the laziness/strictness that’s the thing here…
06:24:32 <EvilMachine> niklasb: Sounds like continuation passing.
06:24:35 <athan> Well, in strict languages you can do just what niklasb spoke of very easily
06:24:48 <athan> and get a precise tail rec thing
06:24:58 <athan> but in lazy semantics I'm honestly not sure
06:25:10 <athan> but iirc it's still easy to do, because you can factor-away Y
06:25:11 <EvilMachine> athan: Yes, I just realized a purely “tail-recursive” language would be a strict one and hence lose the advantages of laziness.
06:25:31 <athan> and leave the rest of the expressions as supercombinators
06:26:30 <athan> yeah like, what's the intent of tail rec? To be super fast? Or forget about accomplished progress?
06:26:32 <EvilMachine> athan: btw, i think “laziness” is a very bad misnomer. laziness is when one is saving so much effort, that it is *less* efficient again. Haskell should be efficient. Not lazy. Which is exactly the case when the “stack” is flooded due to non-tail recursion.
06:26:42 <ertes> maerwald: yeah, lio is much closer, but also not quite, because it does security checks at run-time
06:27:09 <athan> because in the latter, the GC reference systems and a few other kit help alleiviate that, but it's still a jungle
06:27:24 <athan> I just hope LinearTypes makes this a more cool experience
06:27:38 <EvilMachine> athan: what at LinearTypes?
06:27:49 <EvilMachine> athan: s/at/are/
06:28:09 <athan> You can leverage lazyness to be efficient
06:28:11 <maerwald> ertes: yeah, F* would probably be interesting for that kind of thing with it's dependent types and SMT solver
06:28:39 <maerwald> or you abuse liquidhaskell :o
06:28:51 <athan> EvilMachine: basically a way to count used expressions, but I don't know how far you can optimize it
06:29:04 <athan> check out the GHC trac wiki about it, it's really interesting
06:29:26 <ertes> maerwald: i should just try again in haskell, because the last time i tried there was no TypeInType
06:29:31 <athan> s/used expressions/arguments used in an expression
06:30:33 <EvilMachine> athan: i guess i want haskell to automatically detect when it is lazy instead of efficient, and not do that. and I suspect that I can define what the difference is in a way that’s clean enough, to write a compile-time detection algorithm.
06:30:38 * shapr send coffee to ertes to encourage cool experiements
06:31:49 <shapr> ertes: Why do you have two github profiles?
06:31:51 <jonascj> Hi everyone, haskell beginner here. I'm trying to get the current systemtime to create a string like: "yyyy-mm-dd hh:mm:ss: some message". At first something like 'fmap show getZonedTime ++ ": some message"' looked promesing, but type of 'fmap show getZonedTime' is "IO String" which is not compatible with "[char]". I understand that IO means impure because it does io operations, but surely it must be 
06:31:55 <EvilMachine> shapr: sleep > coffee
06:31:55 <athan> EvilMachine: Check out the trac article on it!
06:31:57 <jonascj> possible to create a string containing a timestamp.
06:32:15 <EvilMachine> athan: if i find the time, i will…
06:32:18 <shapr> EvilMachine: I keep hearing that, but I keep drinking death wish coffee until I don't believe it. CODE FASTER!
06:32:22 <EvilMachine> athan: (probably the next time i’m here)
06:32:23 <athan> rofl
06:32:51 <shapr> EvilMachine: have you seen how tail call optimization works? Is that what got you started on these questions?
06:33:53 <EvilMachine> shapr: After a while, like any drug, coffee stops having any benefit. you’ll just be even more tired without it. So you need more to not just go back to the normal state that you would have had without coffee, had you not started using it. Sleep doesn’t have that problem.
06:33:55 <Tuplanolla> Are you familiar with `do`-notation, jonascj?
06:34:14 <EvilMachine> shapr: (this is waay OT though :)
06:34:15 <jonascj> Tuplanolla: yes, 
06:34:45 <shapr> EvilMachine: shapr :: Coffee -> Maybe Sleep -> Code
06:34:54 <jonascj> also the goal is to get a function "trace :: MonadIO m => String -> m ()" to accept this string "yyyy-mm-dd hh:mm:ss: some message" and the problem is getting the the timestap to play along
06:35:16 <Tuplanolla> You must first bind the time computation with `<-`, jonascj. Only then can you pass on the actual value.
06:35:21 <shapr> ertes: do any of your experiments end up on github? I'd like to dig into your experiments
06:35:23 <ij> Why doesn't the third test case parse? http://vpaste.net/QWhZK
06:35:33 <athan> Coffee is the gas to my totality checker
06:35:37 <EvilMachine> shapr: No, actually, a discussion in #e, about automating memory management, since what’s the point of having a computer, if I don’t automate stuff away?
06:36:11 <shapr> EvilMachine: in that case, does this help any? https://wiki.haskell.org/Performance/Accumulating_parameter
06:36:11 <Cale> jonascj: Well, you're apparently already using IO, so just execute the action
06:36:19 <EvilMachine> shapr: Coffee makes one less efficient.
06:36:52 <Cale> jonascj: Or at least some instance of MonadIO, you should be able to use  liftIO :: (MonadIO m) => IO a -> m a  to transform the IO action getZonedTime into an action in whatever monad it is that you're using
06:37:09 <jonascj> Cale: the trace function is not mine, just using it from some other library. But yes, it is IO it seems. That's why I posted the type of it, maye there was a better way when trace was already IO.
06:37:40 <Cale> jonascj: and then just execute it like  do t <- liftIO getZonedTime; trace (show t ++ ...)
06:37:43 <EvilMachine> shapr: I wish I had a way to tell ghc, that things should be tail-recursive, and throw a compilation error if it isn’t. (or ideally just automatically transform it into one)
06:38:00 <shapr> EvilMachine: ah, but that wiki page I linked to you is what you need!
06:38:02 <athan> EvilMachine: read up on LinearTypes lol
06:38:24 <ertes> shapr: i have only one…  the other is my old account, which is no longer accessible…  and a lot of stuff i play with never makes it to the internet…  i know, i should change that =)
06:38:59 <shapr> ertes: you write code that could teach me much, for selfish reasons I wish you would publish more code :-)
06:39:22 <ertes> i'll try =)
06:39:45 <athan> EvilMachine: Do you know how foldl and foldr differ operationally?
06:39:53 <athan> It's very related to your goal I think
06:40:01 <shapr> ertes: thanks!
06:41:35 <EvilMachine> athan: yes, but I have trouble describing it without drawing it as a tree.
06:41:38 <jonascj> Cale: yes that worked, don't know if it was what Tuplanolla had in mind
06:42:10 <ertes> shapr: i have my ~/src/var/test.hs, which i open up whenever i have a…  don't know what it's called in english…  "blitzidee"…  like a flash of an idea that is just about to fade as quickly as it manifested…  then i start hacking…  i hack and hack, until i've coded myself into a corner (basically exploring the limits of that idea)…  then i delete the code
06:42:12 <shapr> I had lots of fun yesterday evening talking Haskell, Swedish, German, French, and persistent homology with michiexile.
06:42:14 <athan> EvilMachine: Then you understand how an accumulator is evaluated before it's applied to the next "loop" for foldr?
06:42:24 <shapr> ertes: that last step makes me sad
06:42:45 <EvilMachine> athan: Well, it isn’t evaluated at all, uness it is needed. Which is why you use foldl' to make it strict. ^^
06:42:50 <jonascj> liftIO seems like cheating to me at this stage of my haskell understanding
06:43:02 <shapr> ertes: but I think that's a great name for the next Haskell IDE
06:43:13 <ertes> shapr: at that point the code is in a completely useless state, because i've long left the realm of usefulness behind me
06:43:17 <athan> jonascj: It's glorious though >:D
06:43:30 <athan> i mean, not in a "okay gimme what I want" way
06:43:48 <athan> it's more like a "I know this thing will be done" kind of way
06:44:00 <ertes> shapr: so i've basically turned blitzidee into blitzcode…  it faded away just as quickly as the idea =)
06:44:09 <shapr> heh, too bad
06:44:36 <ertes> jonascj: try to explain why it's cheating
06:44:36 <EvilMachine> ertes: In Enlish they just say ”… and then it struck me”, where ”is” is meant to be a lightning bolt. ”… it hit me” is an alternative.
06:44:49 <EvilMachine> ertes: s/“is”/“it”/
06:44:50 <ertes> EvilMachine: thanks!
06:45:32 <ertes> jonascj: consider liftIO for IO itself:  liftIO :: IO a -> IO a;  liftIO = id  -- is that "cheating"?
06:45:57 <shapr> I think blitzidee is a great name, I'm stealing it.
06:46:23 <athan> ertes: So, in `[...] ^. traverse`, traverse references the Const applicative effect, right?
06:46:30 <jonascj> ertes: I suppose not, there is bound to be a way to get a "pure constant value" from an IO function and use it as pure even though it originated from some IO. 
06:46:31 <athan> @type traverse
06:46:33 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:46:36 <ertes> athan: no, (^.) does
06:46:43 <athan> er...
06:46:43 <shapr> Anyway, my listening comprehension for German is meh, but I can get by. I'm much better in Swedish or French.
06:47:00 <athan> > ["a","b"] ^. traverse
06:47:02 <lambdabot>  "ab"
06:47:05 <ertes> jonascj: i think you're misunderstanding what exactly liftIO does =)
06:47:29 <athan> @type (^.)
06:47:31 <lambdabot> s -> Getting a s a -> a
06:47:32 <Tuplanolla> It might be helpful to put away the `mtl` classes and use `IO` directly for a while, jonascj.
06:47:57 <Tuplanolla> That is, `IO a` instead of `MonadIO m => m a`.
06:48:37 <ertes> jonascj: do you understand monad transformers?
06:48:57 <athan> mtl takes a broader perspective of monads jonascj, so if you don't understand the actual monads being used, it will be really difficult to follow along :.
06:49:00 <athan> :/*
06:49:14 <jonascj> ertes: most likely, like I said I'm a beginner, and no I do not understand monads yet, I'm in haskell at the moment because of xmonad configuration :) 
06:50:11 <jonascj> and had some classes many years ago in a functional programming course, but we mostly just did list comprehension in ghci. So don't waste your breath on explaining it to me. I'll get through a haskell tutorial/book one of these days.
06:50:25 <ertes> jonascj: ok…  in that case:  X is a monad that has IO at its base, so it denotes arbitrary effects, but at each point you have access to the current state of xmonad (like the current StackSet of windows)
06:50:26 <jonascj> thanks though
06:50:41 <ertes> jonascj: since X supports arbitrary effects, liftIO is the function that lets you embed them
06:50:46 <ertes> liftIO :: IO a -> X a
06:51:03 <EvilMachine> I’ve written a great generator for t-shirt captions and band names: http://lpaste.net/350910 (Nevermind the bad code. I won’t waste any more time on it. :)
06:51:14 <shapr> jonascj: In my opinion, the best learning option at the moment (other than this wonderful channel) is the book "Haskell from First Principles"
06:51:36 <jonascj> shapr: not "learn you a haskell for the greater good" or some such?
06:51:44 <ertes> jonascj: or ignore the word "monad" for now
06:52:22 <shapr> jonascj: LYAH and RWH aren't as good because Haskell has changed some since they were written. Much of the content is still applicable, but when learning I prefer for *all* the content to be applicable to prevent confusion.
06:53:11 <mekeor> shapr: it's 60 USD...
06:53:16 <shapr> mekeor: and worth it!
06:53:19 <samvher> shapr: what were big changes? I learned with LYAH and never really noticed any problems (although RWH seems to be a bit outdated)
06:53:44 <mekeor> shapr: but not affordable
06:53:44 <samvher> but I haven't been deep in Haskell for a while (let's say around a year)
06:54:03 <shapr> mekeor: are you a poor student who wishes you owned a copy of haskell book so you could learn?
06:54:08 * EvilMachine goes AFK, doing some “serif uproot windsurfing” through the “Narragansett jamming simplex” on his ”amiable Margarita switchboard”.
06:54:23 <shapr> EvilMachine: what does that MEAN?
06:54:28 <jonascj> ertes: Your explanation makes somewhat sense, right now I'm thinking of liftIO as a way to "inspect" the current state/value of something IO
06:54:29 <mekeor> shapr: yes
06:54:33 <EvilMachine> shapr:  http://lpaste.net/350910
06:55:20 <shapr> mekeor: I've purchased one copy for a poor student friend, ask me again next week when I'm not so busy?
06:55:35 <shapr> EvilMachine: oh wow
06:55:48 <athan> jonascj: I see it more as "embed this IO action in some action that has other features"
06:56:22 <EvilMachine> shapr: The results are quite hilarious. Especially since I own China-made shirts that have very similar hilarious random strings of Enlish words on them.
06:56:37 <ertes> jonascj: a value of type (IO A) is an "action" or "program" that may have arbitrary effects and at the end produces a value of type A
06:57:00 <jonascj> yes, that makes perfect sense, I knew that :)
06:57:23 <ertes> jonascj: do-notation, which you probably already used, allows you to compose a large action from smaller ones, and you may give each individual result a name along the way
06:57:27 <jonascj> like "IO String" procudes a string by some IO (which might have other effects than producing a string)
06:57:39 <ertes> jonascj: yeah
06:57:52 <Cale> jonascj: liftIO takes an IO action and does whatever is necessary (depending on which monad it is) to turn it into an action of some other monad (which in turn will have been constructed in terms of IO somehow)
06:58:16 <ertes> jonascj: a value of type (X A) is very similar to an (IO A), except that, among all effects that IO supports, it also has effects to access the current xmonad state
06:58:43 <ertes> jonascj: now you can't use (putStrLn :: String -> IO ()) in an X action, because that's a type error:  X ≠ IO
06:58:46 <Cale> jonascj: Not all monads support that of course, typically only those which somehow are wrappers around IO will -- but those which can are members of the type class MonadIO
06:58:56 <ertes> jonascj: that's where liftIO comes in:  liftIO :: IO a -> X a
06:59:19 <ertes> it's the bridge from X to IO…  a way to "lift" IO actions to X actions
07:00:04 <jonascj> ertes: it makes good sense, probably even better when I understand monads better. Thank you for the explanation
07:00:10 <jonascj> Cale: you as well
07:00:35 <jonascj> Now I can get on with debugging my xmonad config with timestamps on my log messages
07:02:27 <ertes> jonascj: now you know why xmonad is called "xmonad"…  it literally defines the X monad as a framework for window managers =)
07:02:53 <ertes> "configuring xmonad" amounts to "writing a window manager using the X monad" =)
07:03:13 <jonascj> yes
07:03:26 <jonascj> and is the X from XORG or X as in "some arbitrary effect" ?
07:03:35 <Cale> From Xorg
07:03:38 <ertes> jonascj: more likely the former
07:03:42 <jonascj> that is what I thought
07:03:50 <Cale> (or earlier X Window System)
07:03:59 <ertes> IO is the monad for arbitrary effects
07:04:15 <Carl`> it's X as in 1980's 
07:07:27 <wespiser> I'm building a prog lang with a standard library, is there anyway to include that in the executable created by stack?
07:10:48 <osa1> wespiser: not sure about stack, but you can use extra-source-files field of cabal for including those in the .tar
07:11:00 <wespiser> thanks!
07:14:40 <ertes> wespiser, osa1: you probably want to use data-files instead of extra-source-files for those
07:15:06 <wespiser> yea, extra-* looks like its for source code, this would technically be a data file
07:15:11 <ertes> wespiser, osa1: https://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties
07:15:36 <ertes> difference:  data files are installed
07:15:57 <ertes> and there is a way to find their path: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
07:21:23 <H4CKRYPT> Yo
07:37:36 <athan> Are all (haskell) profunctors (haskell) categories?
07:37:57 <c_wraith> athan: no
07:38:10 <athan> aw shoot okay, thanks c_wraith
07:39:19 <athan> it's just the case that (a -> s, s -> a -> a) happens to be both? Wait... sorry let me think before I speak :x
07:39:39 <c_wraith> athan: newtype Foo a b = Foo { unFoo :: a -> (b, Int) }
07:39:56 <qmm> does haskell have a single model of computation or allow for several types of computation?
07:40:08 <qmm> types of computational models
07:40:12 <benzrf> qhat do you mean by that
07:41:10 <c_wraith> athan: I suppose that *could* be made an instance of Category, but there are a lot (probably infinite) valid category instances.  There's only one Profunctor instance
07:42:00 <c_wraith> Well.  I guess it can be a Category in as many different ways as Int can be a monoid.
07:42:02 <qmm> benzrf: i guess i'm referencing models of concurrent computation such as the actor model
07:42:15 <c_wraith> So not *quite* infinite, due to the fact that Int is bounded. :)
07:42:19 <iphy> I've been trying to solve this dependency resolution problem for several days now: https://travis-ci.org/TokTok/hs-msgpack-rpc#L305
07:42:24 <nshepperd1> newtype P r a b = P (a -> r) b -- not a category
07:42:28 <iphy> I don't understand what it wants
07:42:38 <benzrf> qmm: it's not totally clear to me what you mean... do you mean like evaluation strategies?
07:42:39 <qmm> clojure has the process calculus CSP and erlang has the actor model
07:42:45 <c_wraith> nshepperd1: ah, yes.  That example is better. :)
07:42:59 <iphy> it can't find a version of 'vector' it likes
07:43:12 <benzrf> qmm: in that case i'd say that haskell is based on the lambda calculus
07:43:40 <iphy> but I have nothing that depends on a specific version of vector, myself
07:43:41 <qmm> looking at wikipedia, that answers the original question :) https://en.wikipedia.org/wiki/Model_of_computation
07:43:49 <iphy> and I can build it locally with this ghc and cabal version
07:43:57 <qmm> through cloud haskell, i suppose haskell gives you the ability to use the actor model as well
07:44:03 <iphy> (7.8.4, 1.18)
07:44:09 <c_wraith> qmm: Haskell doesn't bless any particular concurrency model innately, unlike some other languages
07:47:59 <athan> Thanks c_wraith :)
07:48:22 <osa1> iphy: it says which vector versions it tried and rejected, with reasons. in the end it runs out of options.
07:48:31 <c_wraith> athan: if you missed it, nshepperd1 had an even better example
07:49:52 <athan> Hmm, yeah I was just thinking for lenses
07:49:52 <athan> like how Lens s t = (s -> t, t -> s -> s)
07:49:52 <athan> (so far as my shallow knowledge goes :x)
07:50:57 <athan> qmm: Even with cloud haskell, you're still just thinking in terms of lambdas, with incoming messages just as you would incoming http requests for a web server :)
07:51:07 <c_wraith> Well.  the lens library uses a different representation.  It is interconvertible with that representation, but the exact details of the difference have some nice properties
07:51:20 <athan> where each actor is just a process on a [different] machine
07:51:37 <osa1> iphy: cabal is trying to find a set of packages that are supposed to work together (according to dependency bounds) but it's failing. note that this space is huge because you have no bounds at all. try giving some dependency bounds. alternatively, find a stackage repo and use stack.
07:51:50 <athan> er wait... I think cloud haskell lets you push code actually :x
07:52:38 <athan> c_wraith: Hmm! Okay I'll have to dig into it. Thank you for your help c_wraith!!
07:52:39 <c_wraith> It doesn't allow pushing closures yet.  That's still not something GHC supports
07:53:09 <qmm> what is the mkClosure syntax then?
07:53:40 <c_wraith> qmm: it lets you assemble a reified closure.  That's not the same as automatic reification of any arbitrary closure
07:54:05 <qmm> useful to know, ty
07:54:38 <iphy> osa1: I thought not giving bounds would be good until I find out which versions actually don't work, in order to give fewer constraints and thus making the solver's life easier
07:54:44 <qmm> c_wraith: if you have time, i am interested in a small expansion on your lens comment. what is the representation it uses?
07:54:44 <iphy> apparently that thought is wrong
07:55:03 <qmm> iphy: sorry to break up your comment :)
07:55:32 <c_wraith> qmm: to be specific, I'm talking about the library lens, not many of the other libraries.  I like to point that out, because there are multiple ways to do this. :)
07:55:34 <iphy> qmm: my fault
07:55:48 <osa1> iphy: finding which versions are not going to work is a hard problem, I don't think we have a solution for that. usually you try with versions that you know are going to work and then relax when needed
07:56:05 <c_wraith> qmm: type Lens s t a b = Functor f => (a -> f b) -> s -> f t
07:56:25 <c_wraith> qmm: which..  has a lot of type variables.  More than you'd expect
07:56:58 <c_wraith> qmm: the type variables are there to allow lenses which can change the types of values they're working on.
07:57:41 <c_wraith> qmm: if you disallow type changes, you get another type synonym from the library:  type Lens' s a = Functor f => (a -> f a) -> s -> f s
07:58:59 <c_wraith> qmm: it's an interesting representation.  The big win is that lens composition is just function composition.
07:59:40 <c_wraith> qmm: also, the standard id function is the identity lens.
08:01:13 <qmm> c_wraith: underneath, though, it's all represented by lambda terms, right?
08:01:37 <c_wraith> well, I guess the big win is that the type is fully compatible with small tweaks that allow more functionality, like Traversals, and so on.
08:01:50 <c_wraith> qmm: In some sense.  I mean, it *is* a function.
08:02:19 <qmm> i may have misunderstood your original comment, thankfully 
08:02:34 <qmm> otherwise, none of that would have appeared on the screen :)
08:03:01 <qmm> c_wraith: thanks for explaining
08:03:06 <c_wraith> haha.  my original comment was meant to say that lenses don't use a representation as a getter/setter pair.
08:03:30 <c_wraith> Rather, they use a slightly funky accessor function that you can derive setters and getters from.
08:07:53 <warbo> hi, I'm trying to suppress a spurious warning from HLint using an annotation: {-# ANN getVal "HLint: ignore Redundant case" #-}
08:09:10 <warbo> but I'm getting an error with GHC 8.0.1, which seems to be type-checking the annotation as if it's Haskell code: "Ambiguous type variable ‘t0’ arising from an annotation prevents the constraint ‘(Data.Data.Data t0)’ from being solved... In the annotation: {-# ANN getVal "HLint: ignore Redundant case" #-}"
08:10:34 <c_wraith> warbo: technically, it is haskell code
08:10:39 <warbo> it's treating `getVal "HLint..."` as a call of `getVal` with argument `"HLint: ..."` and getting confused when inferring the type of `"HLint: ..."` due to OverloadedStrings
08:10:51 <warbo> c_wraith: technically, it's a *comment*
08:11:10 <c_wraith> warbo: it's not.  It's a haskell expression with a Data instance.
08:11:26 <warbo> ??
08:11:33 <c_wraith> https://ghc.haskell.org/trac/ghc/wiki/Annotations
08:11:49 <c_wraith> According to that, everything after the identifier is treated as a haskell expression
08:12:07 <c_wraith> And it uses the Data instance to reify it into the .hi file
08:12:45 <c_wraith> And so the error is because with OverloadedStrings, the expression has the type (Data a, IsString a) => a
08:12:50 <c_wraith> Which is ambiguous
08:13:32 <warbo> ah
08:14:05 <warbo> I was getting confused, since `getVal` does some crazy Typeable magic, so I thought that's where the constraint was coming from
08:14:23 <warbo> are such annotations incompatible with OverloadedStrings then?
08:14:50 <c_wraith> Take advantage of it being a full expression
08:15:12 <warbo> ah, so I can `("Hlint: ..." :: String)`...
08:15:23 <c_wraith> should work, according to that page
08:15:54 <warbo> :)
08:15:57 <warbo> works, thanks!
08:16:56 <c_wraith> fwiw, I *just* searched for that page - I was surprised to see that arbitrary expressions are allowed in annotations.
08:17:07 <c_wraith> So I totally understand where your confusion came from. :)
08:27:16 <spoon> Is there a way of specifying a nested polymorphic function type signature as the same type as the enclosing polymorphic function
08:30:01 <warbo> spoon: is https://wiki.haskell.org/Scoped_type_variables what you want?
08:30:10 <osa1> spoon: define a type synonym, use it in both type signatures. you can't say "type of the enclosing function"
08:31:49 <warbo> with that extension, when you use the same type variable name (e.g. `a`) in your outer function's type and inner function's type, they'll both refer to the same type
08:33:26 <dfeuer> (if you use foralls)
08:33:37 <warbo> yes
08:33:52 <dfeuer> (or if they're variables in the head or context of an instance declaration)
08:34:14 <hexagoxel> (but without shadowing the `a` variable with another forall)
08:39:10 <mettekou> How can I make Haddock render the documentation for the exports from some modules in a module which imports them under the same alias and reexports the alias?
08:44:57 <spoon> Thanks!
08:50:14 <hexagoxel> mettekou: https://github.com/haskell/haddock/issues/225
08:52:12 <mettekou> hexagoxel: Guess I'll have to skip the smaller export list trick for now. Thanks!
08:52:17 <ph88> hi guys
08:52:32 <ph88> can anyone tell me what these function arguments on render suppose to mean?  https://hackage.haskell.org/package/tabular-0.2.2.7/docs/Text-Tabular-AsciiArt.html
08:54:16 <nitrix> row header, coloumn header
08:54:19 <liste> ph88: they're functions to render row header, column header and element
08:54:52 <nitrix> data Table rh ch a = Table (Header rh) (Header ch) [[a]]
08:55:15 <ph88> so if my input is already of type String i just put id there ?
08:55:28 <nitrix> Seems valid.
08:56:02 <newsham> shapr: :)
08:56:17 <nitrix> ph88: You might need the `Header` or `Group` wrapper.
08:56:33 <shapr> newsham: you writing more Haskell lately?
08:56:48 <nitrix> ph88: Nevermind, withdraw that.
08:56:48 <newsham> no not really.  :(
08:57:05 <shapr> newsham: aw, sad to hear that
08:57:39 <nitrix> ph88: render ~ (String -> String) -> (String -> String) -> (Int -> String) -> Table String String Int -> String
08:57:51 <nitrix> ph88: It seems the specialize easily :)
08:57:53 <nitrix> *to
08:58:14 <ph88> nice :)
08:59:04 <nitrix> ph88: Are you using that library just for the cute infix (^..^) ?
08:59:24 <ph88> no, for the tabular formatting
08:59:32 <ph88> looks like a pig
08:59:33 <nitrix> Oh, of course.
08:59:44 <ph88> piggy
08:59:54 <ph88> do you know what is the replacement for filter in foundation ?
09:00:25 <ph88> or should i import implicit  Data.List.filter
09:01:34 <nitrix> ph88: class (IsList c, Item c ~ Element c, Monoid c, Collection c) => Sequential c where filter :: (Element c -> Bool) -> c -> c
09:01:50 <nitrix> They have `Sequential` things that lets you `filter` them.
09:02:00 <nitrix> instance Sequential [a]
09:02:35 <ph88> but i was just using [] in my source code
09:02:48 <nitrix> [] has type :: [a]
09:03:13 <ph88> i have a list of   [State]
09:03:25 <ph88> should i make a Sequential instance for State then ?
09:03:52 <nitrix> No, instance Sequential [a] is already general enough for every `a`.
09:04:13 <ph88> but filter was not defined ..
09:04:43 <ph88> <interactive>:1:1: error: Variable not in scope: filter
09:04:50 <nitrix> Are you importing Foundation.Collection ?
09:04:50 <ph88> i did   import Foundation at the top of the file
09:04:53 <ph88> no
09:05:12 <ph88> doesn't mention i have to do that in the readme
09:05:26 <nitrix> ph88: The Collection in the Foundation module is more limited.
09:05:39 <ph88> limited compared to ?
09:05:47 <nitrix> To the Collection in Foundation.Collection
09:06:20 <ph88> ooh
09:06:38 <nitrix> They're re-exporting only some parts.
09:07:45 <ph88> what about (all)  ?
09:08:00 <nitrix>     , Collection(..)
09:08:02 <nitrix> Oh what the...
09:08:04 <ph88> Data.List.all
09:08:04 <ph88>  :: Data.Foldable.Foldable t => (a -> Bool) -> t a -> Bool
09:08:36 <ph88> they re-export everything from Collection ??
09:08:41 <nitrix> Maybe I don't understand the haddock documentation. Can you at least try?
09:09:00 <ph88> it works when i import Foundation.Collection if that's what you're asking
09:09:20 <nitrix> Oh ahah, they're re-exporting Collection not Sequential :P
09:09:41 <ph88> :D
09:09:58 <nitrix> class (IsList c, Item c ~ Element c, Monoid c, Collection c) => Sequential c where
09:10:06 <nitrix> Collection c => Sequential c
09:10:36 <ph88> what does that mean ?
09:11:13 <ph88> i search on hoogle and hayoo for  (a -> Bool) -> t a -> Bool   (part of type signature of all) but it didn't find anything in Foundation ^^
09:11:17 <nitrix> That every sequential types most be collection types.
09:11:31 <nitrix> So they have some form of hierarchy I presume.
09:11:36 <ph88> oh ok
09:15:33 <nitrix> ph88: https://github.com/haskell-foundation/foundation/issues/177
09:15:44 <nitrix> ph88: Someone seems to also think Sequential needs to be re-exported.
09:15:54 <ph88> yes it's me .. posting 8 minutes ago
09:16:03 <nitrix> Heh.
09:16:05 <ph88> if you check 178 the next issue is about   all
09:18:37 <MarcelineVQ> what an iteresting lib
09:19:17 <nitrix> ph88: all p = null . filter (not . p)
09:19:55 <ph88> what's up with this ?  http://pastebin.com/0fp3nZna
09:19:57 <nitrix> ph88: I think you could implement it yourself with the tools available. If you want `all`, you probably want `or` and `and` too.
09:19:57 <ph88> oh thanks nitrix 
09:20:39 <nitrix> Oh and `any` :P
09:21:21 <ph88> nitrix, when i use your implementation (i called it all2) why does it not have  t a   but only  a  as second argument?   all p = null . filter (not . p)
09:23:11 <jophish> Dows this exist somewhere on Hackage? https://gist.github.com/expipiplus1/2895aeb7c0ef4a207409eb1b1f95b1eb
09:23:14 <jophish> consuming a type level list
09:23:37 <ph88> i have to run be back soon and i will read up
09:23:46 <nitrix> :t null . filter (not . p)
09:23:48 <lambdabot> error:
09:23:48 <lambdabot>     • Couldn't match expected type ‘a -> Bool’ with actual type ‘Expr’
09:23:48 <lambdabot>     • In the second argument of ‘(.)’, namely ‘p’
09:24:14 <nitrix> :t \p -> null . filter (not . p)
09:24:16 <lambdabot> (a -> Bool) -> [a] -> Bool
09:24:20 <nitrix> ph88: What do you mean?
09:24:32 <MarcelineVQ> he's wondering about the c of filter :: (Element c -> Bool) -> c -> c
09:25:15 <nitrix> ph88: I think it is because you filter a collection and obtain a smaller collection.
09:27:10 <nitrix> IsList c => Sequential c
09:27:24 <nitrix> instance IsList [a]
09:27:46 <nitrix> Same thing with the Collection constraint, `c` ~ `[a]`.
09:28:25 <nitrix> It's the list type that has an instance for collection, so the `c` you're seeing is a collection all along.
09:29:56 <nitrix> Which is why they need this `Item c ~ Element c` and the type families and all.
09:30:03 <how> If I want to do some processing each step may output an a, If I want to collect them to [a] I can use a writer monad. What if I want to output an [[a]] instead (where each step may produce an a or ask to start a new list) ?
09:30:12 <nshepperd1> Ew, implementing all in terms of filter. Does foundation not have foldr?
09:30:21 <nitrix> nshepperd1: It does.
09:33:00 <how> Realized that my wording is very awkward but should be understandable. Anyway my current method is to use RWS r [[a]] (s, [a]) and only transfer the result from the state to writer when encountered a breakline
09:33:26 <how> Is there a better way to do it?
09:34:31 <nitrix> "some processing each step may output an a", like mapM ?
09:35:27 <how> yes but I want to output [[a]] instead of [a]
09:36:31 <nitrix> But you said each result would have the type `a`, so all you need is `[a]` to collect multiple results. If you want to put that in another list later you can, but it seems pointless.
09:36:42 <nitrix> :T return [1,2,3,4,5]
09:36:48 <nitrix> :t return [1,2,3,4,5]
09:36:50 <lambdabot> (Num t, Monad m) => m [t]
09:38:41 <how> more like data Z = Break | A a | None, and (Monad m) => [m z] -> m [[a]]
09:38:50 <nitrix> how: Is it multiple tasks, each tasks has multiple steps?
09:45:14 <javor> Hi
09:45:38 <javor> Someone used HaLVM for web applications?
09:48:11 <ertes> TIL: Codensity ((->) s) a ≃ State s a  -- just more efficient and with dynamic strictness control that is not hard-coded by the Monad instance =)
09:48:45 <nshepperd1> how: produce [Z] then convert into [[a]] with some post processing
09:48:46 <ertes> modify :: (s -> s) -> Codensity ((->) s) ()
09:48:47 <ertes> modify f = Codensity (\k -> k () . f)
09:49:48 <nshepperd1> eg groupBy, then gather all the lists of As
09:50:01 <how> nshpperd1: Is there a more elegant way
09:52:35 <nshepperd1> Well, there's data L a = None | Single [a] | Many [a] [[a]] [a]
09:54:08 <nshepperd1> With the right monoid instance, the thing you want is just a foldMap
09:55:56 <nshepperd1> Those should probably be dlists instead of normal lists for efficiency
09:57:26 <how> nshepperd1: That's an interesting idea, have to think about it. Thanks!
10:36:51 <dmwit> how: Are you writing a parser? Perhaps you would like to use one of the monads designed for parsing if so.
10:42:04 <darthdeus_> hey guys, I've been meaning to get into haskell again after about a 2-3 year break, and I'm wondering which version should I get for windows? do I want 32 or 64bit? do I want the platform or stack?
10:42:08 <jophish> shapr: I'm playing with tisch (formerly opaleye-sot) at the moment
10:42:15 <tdammers> dmwit: that would make for a freakishly scary compiler warning if done right
10:42:53 <jophish> dbrecord looks fancy, but perhaps a little unloved
10:44:09 <dmwit> tdammers: Now I'm imagining clippy in my GHC. *shudder*
10:44:38 <tdammers> :)
10:45:17 <dmwit> darthdeus_: If you have a computer made in the last ten years and don't have special needs, you probably want 64-bit.
10:45:21 <tdammers> on a more serious note, I could use some sparring on a syntax design question
10:45:31 <dmwit> As for platform vs. stack, well... I usually just install GHC and cabal-install the rest of what I need.
10:45:58 <tdammers> the library in question is yeshql (http://hackage.haskell.org/package/yeshql)
10:46:15 <tdammers> I currently have query parameters using the popular :name syntax
10:46:43 <tdammers> but now I want to extend it such that the generated query functions can take record types, and decompose them inside the query
10:47:03 <tdammers> e.g., you pass a User object as :user, and then inside the query, you can access its fields
10:47:15 <tdammers> which technically really just boils down to generating a function call
10:47:29 <tdammers> so I'm wondering what a good syntax for that would be
10:47:35 <tdammers> :user.username is high on the list
10:47:41 <tdammers> :user:username is another option
10:47:53 <sm> darthdeus_: the stack 64 bit installer is a good option
10:47:54 <tdammers> :(username user) could work too, since it's just a function call
10:48:05 <darthdeus_> good, thanks guys
10:48:34 <darthdeus_> I'm only asking since it seems these days that most languages have a very different "experience" in their 32 and 64 bit versions, sometimes even advertisting not to use one over the other
10:50:29 <sm> darthdeus_: here, they'll seem very similar, except the 64 bit may be better tested these days and it will allow your programs to use more than 4G on windows
10:50:31 <dmwit> tdammers: I don't have advice for you, but I do like the cut of your jib.
10:50:52 <dmwit> "Just use SQL, it was designed carefully" <- yes please
10:51:10 <tdammers> I actually carefully stole that idea from yesql, a pretty decent clojure lib
10:53:02 <tdammers> after years of dealing with clusterfucks like hibernate and the likes, yesql was a relief
10:53:11 <tdammers> figured the idea could work even better in haskell
10:53:12 <dmwit> :user.username is closest to existing SQL syntax
10:53:33 <tdammers> yeah, also :user:username gives me heebie-jeebies for some reason
10:53:41 <tdammers> my brain parses that as :user :username
10:54:37 <darthdeus_> for a second there I thought yesql was something for yesod lol
10:55:05 <how> Is there an UnCons Typeclass such that instance UnCons f where uncons :: f a -> Empty | a :< f a
10:55:53 <dmwit> There are several in various libraries.
10:56:28 <dmwit> `Stream` from parsec springs to mind.
10:56:34 <infandum> Is there a version of groupBy which compares the next element in the list to all of the elements in the sublist? Like, group
10:56:55 <tdammers> :user[username], hmm
10:57:04 <tdammers> nah, probably not
10:57:42 <infandum> groupBy (\x y -> abs (x - y) <= 2) [2,1,2,3,4,5,6,7] which would return [[2,1,2,3],[4,5,6],[7]]?
10:57:50 <infandum> very quickly?
10:58:03 <infandum> it doesn't need to be a list, just so I can convert it back to a list of lists
10:58:23 <infandum> (because I'm sure there are faster data structures out there for this)
10:58:46 <dmwit> how: There also seems to be a `ListLike` package that has something similar. I think `encoding` has something like this. Probably `edison` has something similar, too.
10:59:58 <Thaufeki> Anyone know how to return the transpose of a list of lists?
11:00:07 <dmwit> :t transpose
11:00:09 <lambdabot> [[a]] -> [[a]]
11:00:54 <how> dwit: Thanks, it's annoying that there isn't such things in base though
11:01:10 <Thaufeki> i'll give it a go (very new) thanks!
11:01:35 <dmwit> how: It turns out everybody wants something slightly different from such a class, which makes it hard to choose one standard implementation to share.
11:02:16 <dmwit> If you've ever looked at all the different container libraries and noticed that they all have functions with the same names, this is the result of that sad lesson: as tempting as it is, their types just don't unify in the way you want them to.
11:02:28 <how> dwit : What are the different things people want?
11:02:53 <how> dwit: I can only think of two, the one I mentioned and one with multi parameters which restrict a
11:02:59 <warrshrke> for someone who knows ocaml
11:03:16 <warrshrke> does haskell have learning value?
11:03:57 <dmwit> Perhaps it should be monadic. Or perhaps there should be some options about which kind of thing you want to strip off -- from the front, or the back, or the smallest one, or the biggest one. Perhaps being able to strip off several at once is more efficient for your data structure; or being able to split off some other kind of collection than just singleton elements.
11:04:36 <dmwit> warrshrke: I think the way you structure code in a lazy language is sufficiently different from the way you structure code in a strict one that you would be able to learn something valuable.
11:05:03 <warrshrke> dmwit: makes sense
11:05:17 <ralu> warrshrke: most programming languages have leraning value.  Even if you dont like/use language and even if languageis bad.
11:05:18 <dmwit> warrshrke: The abstraction capabilities offered by typeclasses is also quite fun to experience.
11:05:32 <warrshrke> you think it would better than learning clojure?
11:05:37 <dmwit> I can't recall whether OCaml has higher-kinded polymorphism. Probably yes?
11:05:41 <joehillen> ralu: keyboard issues?
11:06:09 <ralu> joehillen: yes
11:06:19 <warrshrke> dmwit: yes it does
11:06:30 <dmwit> Nothing to learn there, then. =)
11:07:39 <warrshrke> by there you mean clojure?
11:07:41 <how> warrshrke: I think the fact that Hakelll is the only widely used pure functional programming language is enough reason to learn it
11:08:50 <dolio> When did it get higher-kinded types?
11:09:12 <raichoo> I don't think it has HKTs…
11:09:29 <Xnuk> @hoogle (x -> Either a b) -> [x] -> ([a], [b])
11:09:32 <lambdabot> Agda.Utils.List mapEither :: (a -> Either b c) -> [a] -> ([b], [c])
11:09:32 <lambdabot> Util partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])
11:09:32 <lambdabot> Music.Theory.Duration.Sequence.Notate coalesce_accum :: (b -> a -> a -> Either a b) -> b -> [a] -> [(b, a)]
11:10:46 <rdococ> @tell hppavilion[1] you still working on that peano language?
11:10:46 <lambdabot> Consider it noted.
11:11:34 <warrshrke> how: well ocaml is funcktional too
11:12:48 <suppi> warrshrke: I heard Haskell has a bigger ecosystem than OCaml
11:14:33 <tdammers> IMO the learning value in Haskell is that it makes some very important and useful concepts clearer, because it doesn't compromise on them and leverages them fully
11:15:18 <tdammers> non-strict evaluation, purity, fully curried functions, a non-optional type system, effectful actions as first-class values...
11:16:46 <tdammers> it's a bit like how Lisp tends to make you really grok the "code, data, who cares" thing, or how Java or C# make class-based OOP "click" better than C++ does
11:16:53 <tdammers> only better
11:17:59 <warrshrke> hmm all good points
11:18:04 <warrshrke> one last thing
11:18:14 <warrshrke> is it suitable for competitive programming?
11:18:22 <ralu> python
11:18:56 <ralu> at lest for me
11:18:57 <suppi> what is competative programming?
11:20:03 <Lokathor> warrshrke, Haskell it suitable for top tier programming
11:20:04 <suppi> like this? https://en.wikipedia.org/wiki/ICFP_Programming_Contest
11:20:20 <zomg> competitive programming: when you go on freelancer/elance and compete for projects with people who accept 5 bucks an hour as a rate
11:20:23 <zomg> :P
11:20:27 <warrshrke> suppi: yeah
11:20:53 <warrshrke> zomg: no lol. algorithm competitions. think job interview type questions
11:21:06 <zomg> yeah just making a dumb joke :)
11:21:30 <suppi> looks like a few people already won a few competitions with it then :)
11:21:48 <warrshrke> aha awesome.
11:21:52 <warrshrke> so
11:21:52 <warrshrke> right
11:21:52 <warrshrke> okay then
11:21:58 <suppi> says so at the link i linked
11:22:15 <warrshrke> Whats the best way to learn? learnyouahaskell? online course from uni pages?
11:22:21 <warrshrke> something else?
11:22:28 <suppi> i think haskellbook.com
11:22:40 <warrshrke> suppi: yea i see it
11:22:53 <Lokathor> what's the big difference between Vecror.Storable and Vector.Unboxed?
11:23:13 <Lokathor> is unboxed just faster if you don't need the extra conversions?
11:23:47 <warrshrke> suppi: is it better than learnuahaskell?
11:24:01 <Lokathor> warrshrke, miles and miles better
11:24:17 <suppi> warrshrke: by far
11:24:46 <glguy> warrshrke: I've got a copy of http://www.cs.nott.ac.uk/~pszgmh/pih.html that I like
11:24:58 <wonko7> and compared to realworldhaskell.org? 
11:25:12 <suppi> wonko7: yes
11:25:15 <wonko7> I'm asking because I'm currently going through that one 
11:25:24 <dolio> Lokathor: Storable is array of structures, Unboxed is structure of arrays, basically.
11:25:41 <Lokathor> the latter sounds faster
11:25:44 <dmwit> warrshrke: Since you already know OCaml, I would suggest the Gentle Intro even harder than I usually do.
11:25:57 <suppi> wonko7: is it working for you?
11:25:57 <dolio> Well, that isn't necessarily true, I think. But it might be for what you're doing.
11:26:21 <Tuplanolla> Did you read the documentation, Lokathor?
11:26:29 <wonko7> suppi: mostly, yes 
11:26:46 <suppi> wonko7: how far are you into it?
11:26:53 <suppi> wonko7: well if it works it works i guess :)
11:26:54 <Lokathor> Tuplanolla, Data.Vector.Unboxed.Mutable just says "Mutable adaptive unboxed vectors" and that's it
11:26:55 <how> warshrke: which competitions are u aiming to participate in?
11:27:01 <suppi> it didn't really work for me
11:27:16 <Tuplanolla> Things that are `Storable` are intended for ffi, Lokathor. See `Data.Vector.Storable.Storable`.
11:27:25 <wonko7> suppi: chapter 8 out of 28 
11:27:34 <Lokathor> yes I know that but, unboxed values are all also storable, right?
11:27:40 <suppi> that's more than i've read
11:28:00 <Tuplanolla> No, Lokathor.
11:28:06 <Lokathor> oh
11:28:18 <Tuplanolla> It's usually the other way around.
11:28:47 <Xnuk> Why `partitionWith` is not in "base", while it's in "ghc"? https://www.stackage.org/haddock/nightly-2016-12-31/ghc-8.0.1/Util.html#v:partitionWith
11:28:49 <Lokathor> huh
11:31:08 <Psychiatrist> Hey guys. I'm trying to generate all prime numbers, could someone point out why I'm getting an endless loop here while trying to take 1 from my result? primeStream = [ x | x <- [1..], any (\y -> (x `mod` y) == 0) (delete x [2..])] 
11:31:26 <wonko7> suppi: why didn't it work for you? compared to haskell book?
11:33:01 <dolio> Psychiatrist: You're checking if any of an infinite number of things divide another number.
11:33:42 <Psychiatrist> dolio: Wouldn't any stop when it finds the first result of the predicate being True?
11:33:50 <dolio> It's never true for 1.
11:34:26 <Psychiatrist> dammit!
11:34:30 <pja> You’re trying to write the Sieve of Erasthothenes (sp?) ?
11:34:55 <Psychiatrist> pretty much 
11:35:03 <Psychiatrist> well I want my own logic
11:35:13 <Psychiatrist> dolio: Even if I start the initial list from 2 it does this, though.
11:35:50 <how> PsyChiatrist: Sieve of Erasthothense only works for finite list so that's not it
11:36:04 <dolio> Psychiatrist: In that case, you remove 2 from the list, and 2 `mod` n = 2 for n > 2.
11:36:39 <suppi> wonko7: i didn't learn from haskell book as it didn't exist at the time, but from lyah
11:37:34 <how> Psychiatrist: also, you are still checking for infinite predicates since delete x [2..] is infinite
11:37:50 <suppi> wonko7: i didn't really understand rwh at the time and all the comments just made everything even more confusing so i gave up reading on it
11:37:56 <dolio> Psychiatrist: Anyhow, you're actually selecting all composite numbers, and looping on primes.
11:38:22 <dolio> Because for primes, you're removing the only thing out of the list that will divide the number.
11:38:26 <Psychiatrist> how: Wouldn't delete x list stop after one deletion?
11:38:40 <how> Psychiatrist: check out the primes package if u want to implement an efficient lazy prime list
11:38:45 <suppi> wonko7: but the parts i did read from haskellbook i understood pretty well
11:39:24 <wonko7> now I don't know which one to read anymore 
11:39:31 <how> Psychiatrist: no
11:39:35 <Boomerang> Psychiatrist: you probably want something like takeWhile (<x) instead of delete x if I understand this correctly
11:40:47 <Boomerang> Psychiatrist: and then negate the filter with not
11:40:52 <Psychiatrist> That's a great idea
11:40:54 <Psychiatrist> dammit
11:41:42 <Psychiatrist> Thanks guys! dolio, how, Boomerang
11:41:52 <Boomerang> or you can do all instead of any and then use /= instead of ==
11:42:14 <Boomerang> (that might be a confusing sentence ^^)
11:42:22 <Psychiatrist> Nope, got it!
11:42:28 <sgronblo> Are there any tools for automatically updating your cabal file?
11:43:44 <Boomerang> Also takeWhile (<x) [2..] is the same as [2..x-1]
11:44:02 <Boomerang> (for x > 2)
11:47:24 <lyxia> for x <= 2 too
11:47:45 <monochrom> > [2 .. 1]
11:47:48 <lambdabot>  []
11:48:06 <ertes> how: sieve of eratosthenes does very well work for infinite streams as well…  it's just not very efficient
11:48:24 <ertes> how: although if you use a stream of delimited sieves, it can be efficient, too
11:48:44 <ertes> also what Psychiatrist is doing is not the sieve of eratosthenes…  it's just trial division
11:49:08 <mnoonan> > takeWhile (< 5.5) [2..] == [2..5.5]
11:49:10 <lambdabot>  False
11:49:13 <mnoonan> :)
11:49:15 <monochrom> Yeah there are several wrong legacies in the Haskell community.
11:50:37 <ertes> also if you want an efficient prime stream, you should use the arithmoi package, which implements the idea i just mentioned
11:50:47 <monochrom> Conflating stream of trial divisions with sieving, and conflating laziness with nonstrictness.
11:50:50 <mnoonan> whoops, I misread
11:52:04 <monochrom> The worst part is that when you point it out, they actually invent rationalizations.
11:53:33 <ertes> so far most people didn't argue about whether trial division is really sieving, once i told them what sieving actually is…  here is a nice criterium: if it uses division or modulo, it's not a sieve =)
11:54:24 <ertes> criterion
11:57:06 <dolio> monochrom: I'm not sure it's Haskell legacy. I think people just have trouble knowing the difference.
11:58:57 <dolio> Also I'm not sure most examples of sieving are actually sieving, regardless of language.
12:03:50 <ertes> there is a legacy of super-short prime streams in haskell that are marketed as sieves…  in fact we had that unfortunate legacy on the main page of haskell.org for a while
12:04:33 <ertes> see the prime filter on the top right?  "primeFilter" used to be called "sieve"
12:04:46 <ertes> s/primeFilter/filterPrime/
12:06:04 <monochrom> Oh neato. I just thought up a pun. Q: "Is Haskell ready for prime time?" "A: Sure! Just look at the sample code on the front page."
12:08:28 <dolio> > let subtract (p:ps) (q:qs) | p < q = subtract ps (q:qs) | p == q = subtract ps qs | otherwise = q : subtract (p:ps) qs ; emit (x:xs) = x : emit (subtract (map (x*) [2..]) xs) in emit [2..]
12:08:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:09:05 <Xnuk> > let f (x:xs) = x : filter (\y -> y `mod` x /= 0) (f xs) in f [2..]
12:09:08 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:09:28 <tdammers> woop, :user.username now supported
12:19:34 <monochrom> onoes, a GHC steering committee
12:20:09 <buttons840> we need a way to limit the number of committees; perhaps just one more committee?
12:20:18 <monochrom> :)
12:24:16 <buttons840> i want to make a concurrent web crawler, and want to limit the number of crawls in progress -- i'm looking at using async or parallel-io right now (or maybe monad-par?) -- any thoughts on these?
12:29:46 <nshepperd1> So, would the thing on the haskell front page be a sieve if it used a difference of sorted lists instead of filter/mod?
12:30:42 <how> Is there a way to cast Reader a c to Reader (a, b) c without all the packing and unpacking?
12:31:46 <ralu> how: wha about withReader ?
12:32:44 <ertes> buttons840: monad-par is for parallelism, not concurrency…  you can't use it here
12:33:03 <how> thanks, how about State a c to State (a, b) c
12:34:19 <ertes> buttons840: i'd use async to create a certain number of threads, each reading from a TQueue
12:34:32 <ertes> if you have lots of writers, a TBQueue may also be useful
12:36:27 <ertes> how: 'zoom' with lenses
12:37:03 <ertes> > execState (zoom _1 $ modify (+ 1)) (5, 5)
12:37:06 <lambdabot>  (6,5)
12:37:11 <ertes> > execState (zoom _2 $ modify (+ 1)) (5, 5)
12:37:14 <lambdabot>  (5,6)
12:38:09 <how> ertes: Oh right, thanks
12:40:12 <ezyang> Anyone know what a Heyting algebra without implication is called? 
12:40:38 <monochrom> eek, that takes away all the fun of Heyting algebras :)
12:41:34 <monochrom> Simply some kind of lattice? Because you have conjunction and disjunction and pretty much nothing else.
12:41:51 <dolio> Lattice.
12:41:57 <monochrom> \∩/
12:42:16 <monochrom> What do you call a smart phone without any antenna? :)
12:42:24 <dolio> MP3 player?
12:42:38 <monochrom> That will do, I did have one :)(
12:42:56 <monochrom> oops spurrious (
12:45:07 <buttons840> ertes: monad-par does have runParIO -- it doesn't handle exceptions thoough, according to S. Marlows book, so it's probably a bad choice for web crawling
12:47:17 <ertes> buttons840: even then its purpose is parallelism, not concurrency…  you use it when you want to compute faster and can't use any of the functional parallelism abstractions
12:49:34 <dolio> Oh, I guess it's a bounded lattice. Just lattice doesn't require identities.
12:53:01 <how> ertes: How to do RWS a () c k -> RWS (a, b) () (c, d) k then
13:00:32 <ertes> how: that's a two-step process: 1. change it to (ReaderT (a, b) (State (c, d)) k), 2. use the techniques you know
13:03:48 <how> ertes: thanks
13:06:28 <how> ertes: But now my code that works with general doesn't work
13:06:48 <how> wait
13:08:32 <ezyang> Hey, straw poll for Haskell channel, what do you think should happen here: http://lpaste.net/350917 
13:10:46 <Tuplanolla> Pick either `f` or `g`, depending on which one is more powerful for implementing the other, ezyang. If it is not known in general, think about the most common use cases. If there is still not enough information, pick the one that comes first alphabetically.
13:12:18 <shapr> ezyang: all else being equal, just add the default from the 'other' class?
13:12:37 <ezyang> Let me rephrase 
13:12:42 <int-e> ezyang: shouldn't that "default" come with an implementation?
13:13:02 <ezyang> The question is, should the MINIMAL complete definition be f OR g, or empty? 
13:13:18 <ezyang> int-e: This is a signature, we're describing a type class but not providing impl 
13:13:26 <Tuplanolla> I thought I answered that.
13:13:47 <ezyang> Tuplanolla: Yeah, I counted you as in the f OR G camp 
13:14:17 <ezyang> shapr's suggesting of combining both defaults will give you the minimal complete defn is empoty 
13:14:22 <ezyang> *suggestion 
13:14:25 <int-e> ezyang: so it's not proper ghc Haskell then, fine. I can see that neither solution will always be correct, but f OR g seems more conservative.
13:14:48 <implementation> there is no perfect answer as long as we don't know the semantics
13:14:56 <int-e> (motivating example: f = g; g = f)
13:16:29 <int-e> ezyang: why do you need a general rule though rather than a case by case decision?
13:16:49 <dmwit> ezyang: MINIMAL pragmas are hand-written, and therefore not restricted by concerns of computability. So I think it is unfair to ask this question without also showing the implementations of the defaults.
13:16:57 <dolio> ezyang: How can you get these two things to 'combine' them?
13:17:00 <mtjmullen> ezyang: my gut reaction is empty
13:17:03 <ezyang> int-e: Because in Backpack, signatures can get combined together 
13:17:16 <ezyang> that happens automatically and GHC needs to decide what to do if things don't line up 
13:17:42 <dmwit> ezyang: Also: what does "combine" mean?
13:18:29 <ezyang> dmwit: Formally, when you combine decl D1 and D2, you find the least specific D3 which is a subtype of D1 and D2 
13:18:31 <Cale> ezyang: What do you mean "combining these two type classes"?
13:18:36 <Cale> Ah, dmwit already asked
13:18:56 <Cale> What's a subtype?
13:19:07 <ezyang> Cale: As defined by the substitutability principle 
13:19:15 <ezyang> anywhere D1 was used, we can use D3 instead 
13:19:39 <Cale> But there's nothing which could be substituted for either of these, is there?
13:19:49 <dmwit> ezyang: Surely classes must be invariant in this subtyping, right?
13:19:53 <dmwit> Since they can both be used and implemented.
13:19:56 <ezyang> Cale: Well, let's say I have 'class K a where f :: a -> a' 
13:20:06 <ezyang> and later I add a default method to f. That's not a BC-breaking change 
13:20:33 <ezyang> So a subtyping relationship exists between the class with and without the default 
13:20:45 <Cale> BC-breaking?
13:21:04 <ezyang> Cale: as in, everyone's code will keep compiling 
13:21:08 <amx> please explain what this default keyword achieves here, I thought it is for disambiguating Num instances in modules
13:21:08 <dmwit> Is it really allowed? Certainly not with current Haskell semantics; unimplemented methods get implemented by the compiler. If you add an implementation, that changes the meaning of the unimplemented methods.
13:21:23 <Insanity_> Quick Question
13:21:25 <Cale> Okay, yeah, everyone's code will continue compiling -- though it might behave differently.
13:21:33 <Insanity_> I am trying to putStrLn an IO Text
13:21:45 <Insanity_> How can I go from IO String -> IO Text
13:21:46 <ezyang> amx: using -XDefaultSignatures you can say 'default f :: Num a => a -> a' to provide a default with an extra type class constraint 
13:22:06 <ezyang> Insanity_: Given String -> Text, you can use fmap 
13:22:12 <amx> thank you
13:22:13 <ezyang> fmap Text.fromString 
13:22:24 <mtjmullen> Insanity_: have you also looked at Data.Text.IO?
13:22:30 <mtjmullen> might be something useful in there
13:22:33 <Insanity_> works with IO String / IO text?
13:22:34 <ezyang> Cale: Yeah, the metric is does it keep compiling 
13:22:37 <dmwit> Insanity_: If `x :: IO Text`, then `x >>= Data.Text.putStrLn :: IO ()`.
13:22:43 <Insanity_> I found one "showText" in https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Internal.html
13:22:46 <Insanity_> but that is not for the IO
13:22:57 <Insanity_> >>= is a monad thing, right?
13:23:00 <dmwit> yes
13:23:05 <Insanity_> (I have not gotten that far in LYAH yet)
13:23:20 <Insanity_> I'll give those a shot, thanks guys
13:24:10 <mtjmullen> ezyang: after thinking about it a bit, in the case of cyclic default dependencies, I would find it most useful for the minimal pragma to be (f | g)
13:24:11 <dmwit> ezyang: Given that "keeps compiling" is the metric, it seems like you are forced to make the combined class be `class K a where f :: a; g :: a; default f :: a; default g :: a`.
13:24:28 <ezyang> dmwit: Yes, but you ALSO must specify f | g as MINIMAL 
13:24:38 <ezyang> because if you write that syntax, you'll actually get an empty MINIMAL by default. Confusing! 
13:24:46 <ezyang> as mtjmullen says above 
13:24:53 <Cale> dmwit: Well, he could leave out the defaults, it will still compile, it'll just be broken.
13:25:00 <dmwit> ezyang: Nonsense. empty MINIMAL is clearly the correct default.
13:25:20 <ezyang> dmwit: Yes, not arguing there. 
13:25:38 <dmwit> ezyang: There's no reason to believe the two default implementations mention each other at all.
13:25:40 <ezyang> but I got confused because I first did the case without MINIMAL pragmas and I ended up with an impl that didn't OR 
13:26:24 <dmwit> But I am saying you *shouldn't* OR.
13:26:31 <ezyang> even in this merging case?! 
13:26:43 <Cale> What is the actual merged class?
13:27:01 <Cale> Does it contain default declarations?
13:27:40 <ezyang> Well, if you have a minimal pragma that doesn't require a declaration for a method in some circumstances, it had better have a default impl 
13:27:52 <ezyang> Cale: In any case, we're trying to decide what the merged class should look like 
13:28:17 <dmwit> I don't see why we should believe that MINIMAL pragmas can automatically be combined at all.
13:28:37 <dmwit> Or else they wouldn't be a human-written annotation in the first place.
13:28:51 <Cale> Even if K a and K a (from separate modules or whatever) are identical, maybe they actually have different meaning. Are we sure we even want to combine them?
13:28:52 <ezyang> dmwit: Remember, we're not talking about the implementation of a class, just a specification of what a type class is 
13:29:12 <dmwit> I don't see how that helps.
13:29:15 <ezyang> you're saying, "I don't know how you're planning to put this type class together, but here are the properties I need" 
13:29:26 <Cale> I think it would help to know more about the code in question
13:29:40 <ezyang> OK, let me frame it this way 
13:29:56 <ezyang> you're trying to write down a specification of how you depend on some library p, which defines a type class 
13:29:59 <Cale> Like, K,f,g aren't very helpful names to figure out what these classes express and how we ought to combine them
13:30:06 <Cale> hm
13:30:30 <ezyang> In an old vrsion, there's no default methods so you say that {-# MINIMAL f, g #-} in the spec 
13:30:52 <ezyang> In a newer version, they add some fancy generic default method. Your old code is still going to work. 
13:32:45 <dmwit> Okay, so now: in your first K class, the person who writes this as their dependency is announcing that they promise to implement `g` anytime they instantiate `K`. Am I right so far?
13:32:49 <ezyang> but if you are going to have this notion of "compatibility", you also need to be able to combine requirements, in case one library demands K implements the default, while another doesn't 
13:32:57 <ezyang> dmwit: Yep 
13:33:00 <dmwit> And the person who writes the second one as their dependency is announcing that they promise to implement `f`.
13:33:03 <ezyang> yep 
13:33:51 <dmwit> And now we ask: can we summarize this by announcing anything about what we promise to implement?
13:34:02 <dmwit> And you claim we promise to implement either `f` or `g`.
13:34:05 <dmwit> Okay, I understand.
13:34:33 <pikajude> hey, i'm trying to use halive with nix
13:34:34 <dmwit> But I am not sure I agree that this should necessarily be shoehorned into `MINIMAL`...
13:34:51 <pikajude> and halive can't find any of my dependent libraries
13:34:56 <pikajude> which is weird, because they show up in ghc-pkg list
13:35:16 <dmwit> I dunno. I guess why not.
13:35:20 <ezyang> dmwit: Well, you're always making a claim about what the minimal set of methods client need to implement are 
13:35:57 <Cale> ezyang: Let's consider a silly case:
13:36:03 <teurastaja> hey id like to make an iterator for the following (mutable) data type that can select another node right left up or down:
13:36:04 <teurastaja> data Node = Node {left :: Node, up :: Node, val :: Int, right :: Node, down :: Node}
13:36:30 <Cale> well, let me put it in a paste
13:37:18 <ezyang> teurastaja: Have you looked into making a Zipper/ 
13:37:34 <dmwit> AFAIK zippers for 2D structures are an open research question
13:37:41 <teurastaja> ezyang: having trouble understanding them and lenses
13:37:44 <dmwit> But if it's mutable, you may not need a zipper.
13:37:51 <lpaste> Cale pasted “No title” at http://lpaste.net/350918
13:38:11 <teurastaja> its mutable so i dont know what to use
13:38:38 <Cale> ezyang: What class do we get when we combine these? Does it have both x = y and y = x?
13:38:39 <dmwit> Why do you say it's mutable, though? I don't see any mutable bits in the declaration you gave.
13:38:40 <ezyang> Cale: those aren't valid signatures, but OK :) 
13:38:54 <ezyang> Cale: You're not allowed to write default implementations in a signature 
13:38:59 <Cale> hm?
13:39:05 <Cale> This is valid Haskell...
13:39:07 <teurastaja> dmwit: its for dancing links algorithm
13:39:12 <ezyang> Cale: Not in an hs-boot file 
13:39:13 <Cale> But okay
13:39:15 <Cale> ah
13:39:17 <ezyang> nor is it in hsig file 
13:39:28 <ezyang> (well, it's accepted, but the default method doesn't actually do anything) 
13:39:33 <teurastaja> i need to use the state monad i guess
13:39:41 <ezyang> (that's a bug) 
13:40:09 <dmwit> teurastaja: You might like http://hackage.haskell.org/package/set-cover
13:40:10 <teurastaja> i did it in scheme but im having trouble translating to haskell
13:40:10 <Cale> So, anyway, I was just giving examples of classes for which we'd have MINIMAL y and MINIMAL x respectively
13:40:18 <ezyang> yep 
13:40:34 <Cale> If we put them together, do we keep both of the default methods?
13:40:42 <teurastaja> dmwit: how do i make sure it uses bitvectors?
13:41:06 <dmwit> teurastaja: See Math.SetCover.BitSet
13:41:43 <ezyang> Cale: as I've said, you can't merge implementations. But let me rephrase what you asked a little differently 
13:41:48 <teurastaja> dmwit: having troubles understanding the example file can you help demystify the usage?
13:41:58 <teurastaja> for the sudoku example
13:42:02 <ezyang> Say there were two competing libraries providing C, each providing one of the two examples you gave 
13:42:13 <Cale> ezyang: Well, sure, but presumably the signatures tell us something about actual classes, I want to think about actual classes, not signatures.
13:42:15 <ezyang> Finally, we've decided to merge them together, and have on C class to rule everyone 
13:42:18 <dmwit> teurastaja: Only by giving more examples, I'm afraid. I remember being a bit mystified myself, but I don't recall what I learned now.
13:42:27 <dmwit> It's been a while since I used it.
13:42:33 <teurastaja> oh and i need to modify the algorithm a bit so i get a difficulty rater for free
13:42:36 <ezyang> How should we design the class C? The only reasonable thing to do is have f = g; g = f, and MINIMAL f | g 
13:43:08 <teurastaja> so im afraid i cant use it
13:43:16 <dmwit> ezyang: Wait, no. Combining providers is different than combining dependencies.
13:43:53 <ezyang> dmwit: Yes, you're right 
13:44:30 <ezyang> but in this case, thinking about how the providers combine tells you that requiring MINIMAL (empty) is too stringent a combined dep 
13:45:14 <teurastaja> so how can one define a mapper and iterator for abstract types like this?:
13:45:15 <teurastaja> data Node = Node {left :: Node, up :: Node, val :: Int, right :: Node, down :: Node}
13:45:43 <teurastaja> it must specify which direction
13:45:44 <Cale> ezyang: In this case, if you don't provide anything, you get an infinite loop
13:45:51 <Cale> (once we combine the implementations)
13:46:02 <Cale> I don't know if that's relevant
13:46:16 <dolio> ezyang: It seems that any choice you make is backward incompatible with someone.
13:46:38 <rribeiro> Hi all! Does anyone knows how to fix the can't load .so/.DLL error on loading ghci, on using stack? I've tried stack clean, build project, before calling stack ghci
13:46:45 <dolio> So if that's what you care about, there is no good choice.
13:46:46 <ezyang> dolio: Really? How is f = g; g = f; MINIMAL f | g incompatible with any code that worked with one of the two prev libs? 
13:46:51 <rribeiro> I'm using stack on Mac OS X
13:47:13 <dmwit> teurastaja: As far as I know, the only thing you can do is make the graph structure explicit.
13:47:27 <teurastaja> dmwit: how?
13:47:34 <Cale> ezyang: If the goal is to specify the interface of these libraries which are different in terms of what default implementations they provide, the only way that some instance is going to work with both of the libraries will be if it provides all the methods.
13:47:35 <dolio> ezyang: Any module that defined a MINIMAL f class does not satisfy that specification.
13:47:51 <Cale> ezyang: It can't just provide one or the other, because it wouldn't work with one of the libraries then.
13:47:57 <dmwit> teurastaja: Use mutable references, or have indirection through a "node identity" (e.g. using `fgl` or similar).
13:48:38 <Cale> ezyang: Is that what we're trying to do?
13:48:42 <dmwit> teurastaja: As in `data Node = Node { left :: NodeID, up :: NodeID, val :: Int, right :: NodeID, down :: NodeID }; type Nodes = Map NodeID Node`.
13:48:43 <ezyang> dolio: Oh, I'm talking about people who wrote instances against the class 
13:48:49 <Cale> ezyang: If so, that might explain why you ended up with no minimal set.
13:49:02 <ezyang> Obviously the old library 1 won't work with clients of library 2! 
13:49:17 <Cale> Any instance which only provides one of the methods won't work with the library that doesn't have a default for the other.
13:49:24 <teurastaja> dmwit: what does that type declaration do?
13:49:50 <ezyang> Let me rephrase this again in a different situation 
13:50:17 <ezyang> You have transformers and monads-tf battling it out for monad supremacy, and transformers provides a function foo that monads-tf doesn't, and vice versa 
13:50:29 <ezyang> obviously transformers isn't going to work for people using monads-tf, and vice versa 
13:50:50 <ezyang> but you can still write a new library which provides foo (and others), and it will work with all clients 
13:51:21 <dmwit> teurastaja: Your `Node` type represents a collection of values (by traversing the up/down/left/right pointers). My `Node` type represents a single value; `Nodes` recovers the representation of the whole collection by telling what values lie under the `up`/`down`/`left`/`right` pointers.
13:52:33 <dmwit> teurastaja: Your representation sucks because it's very hard to update the value at a single node, because you have to update all pointer paths that arrive there as well. My representation fixes that by making the indirection explicit and letting you change the value at a given pointer without changing all the pointers to it.
13:52:38 <dolio> ezyang: If you don't care about other libraries being able to implement the signature, why not just give the MINIMAL declaration for the class you actually wrote?
13:52:49 <dolio> Since it's the only one you care about?
13:53:15 <ezyang> dolio: Sure. But you wanted to write a library that was a drop in replacement for the other two. In that case, you MUST write MINIMAL f | g or better 
13:55:28 <teurastaja> map with a capital M?
13:55:54 <dmwit> ?hoogle Map
13:55:57 <lambdabot> module Data.Map
13:55:57 <lambdabot> Data.Map.Lazy data Map k a
13:55:57 <lambdabot> Data.Map.Strict data Map k a
13:56:04 <dolio> Yeah, the thing you write must behave like that.
13:56:40 <dolio> Either MINIMAL f | g or nothing.
13:57:06 <ezyang> yep 
13:58:42 <teurastaja> wtf is this black magic??
13:59:07 <teurastaja> :O
14:00:13 <byorgey> teurastaja: not magic, just sufficiently adanced technology ;-)
14:00:18 <byorgey> *advanced
14:01:09 <teurastaja> so record fields are used as an associative list to retrieve the intended field by key?! huh?
14:02:08 <nitrix> Nah they aren't lists.
14:02:56 <nitrix> They are just product types and there's pattern matching happening behind the scenes.
14:03:37 <nitrix> @let data Demo = DemoA { demoA :: String } | DemoB
14:03:39 <lambdabot>  Defined.
14:03:49 <nitrix> :t demoA DemoB
14:03:50 <lambdabot> String
14:03:54 <nitrix> > demoA DemoB
14:03:56 <lambdabot>  "*Exception: No match in record selector demoA
14:05:32 <EvanR> that example confuses
14:05:49 <EvanR> records are not assoc lists, they are products with projections
14:05:53 <teurastaja> dmwit: so how do you use your definition after that?
14:07:03 <Xnuk> > let both f = f *** f in both succ (1, 'c') -- What is the type of `f`?
14:07:05 <lambdabot>  error:
14:07:05 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
14:07:05 <lambdabot>      • In the expression: 1
14:08:06 <Xnuk> *`f` -> `both`
14:08:17 <Xnuk> I mean `both`
14:08:31 <Koterpillar> :t (***)
14:08:33 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:08:39 <Koterpillar> :t \f -> f *** f
14:08:41 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
14:08:46 <Koterpillar> Xnuk: ^ ?
14:10:48 <Xnuk> Koterpillar: Cannot apply to my example, because (Char -> Char) isn't (Num a => a -> a)
14:13:02 <geekosaur> isn't f (forall a. a -> a)? (parens *required*)
14:13:39 <nitrix> @let bothRank2 :: Arrow a => forall b' c'. a b' c' -> a (b', b') (c', c'); bothRank2 f = f *** f
14:13:40 <lambdabot>  Defined.
14:13:57 <nitrix> > bothRank2 succ (1, 'c')
14:13:59 <lambdabot>  error:
14:13:59 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
14:13:59 <lambdabot>      • In the expression: 1
14:16:16 <nitrix> Interesting.
14:16:22 <nitrix> I was expecting that to work.
14:17:46 <Xnuk> nitrix: Is it just Arrow a => a b' c' -> a (b', b') (c', c')?
14:17:59 <c_wraith> nitrix, I don't see anything rank 2 about that. 
14:20:22 <Xnuk> > let both f = f *** f in both Just (1, 'c')
14:20:26 <lambdabot>  error:
14:20:26 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
14:20:26 <lambdabot>      • In the expression: 1
14:21:50 <ertes> hmm…  microlens doesn't support indexed traversals
14:22:28 <c_wraith> nitrix, I don't see how you could make that potentially work, either.. at least not without specializing the type a lot in weird ways. 
14:22:45 <ertes> i have to say:  i can't praise microlens as much as some people do…  it really just feels like a version of lens with missing joints everywhere
14:22:47 <geekosaur> that's what I'm seeing too
14:23:01 <geekosaur> a itself has to be instantiated at multiple types, if I understand it correctly
14:23:05 <glguy> ertes: Not being as useful as lens is the whole point
14:23:21 <nitrix> It seems my type annotation needs to be on *** ?
14:24:16 <ertes> glguy: i guess…
14:24:19 * ertes goes back to lens
14:24:33 <nitrix> I was trying to allow `f` to remain polymorphic.
14:25:53 <c_wraith> nitrix, like maybe.. (Arrow a, Enum b, Enum c) => (forall e. (Enum e) => a e e) -> a (b, c) (b, c) 
14:26:10 <nitrix> e.g. both :: (forall a. a -> a) -> ...
14:26:27 <nitrix> But I can't seem to do it because arrow isn't a function o.o
14:26:30 <c_wraith> but then it's weirdly specific to Enum
14:28:26 <geekosaur> nitrix, f has to be rank 2. and yes, far as I can tell you can't make an Arrow that is rank 2 like that --- not that I am at all expert in Arrows
14:30:25 <ertes> nitrix: that can't work, because the *user* of the function needs to make assumptions, which is bothRank2 in this case…  you wouldn't want to inform bothRank2 of what the function does
14:33:06 <ertes> nitrix: you would have to encode in some way that the function works for the two types given, which you can't express as a constraint directly…  perhaps there is a way using some type-level hacks, but i would expect it to get very ugly
14:33:31 <c_wraith> I keep wishing there was a way to specify that a function is polymorphic over constraints. 
14:33:35 <nitrix> Yeah I'm realising it now.
14:33:40 <nitrix> (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:34:27 <nitrix> I'd have to be able to merge `a b c` and `a b' c'` into a single arrow that has some form of polymorphism of either b | b'  or c | c'
14:34:36 <ertes> bothRank2 :: (Arrow cat) => (forall x. (CanBeEqualTo a x, CanBeEqualTo b x) => cat x x) -> cat (a, b) (a, b)
14:34:51 <nitrix> Can I use type equality for this?
14:35:53 <ertes> no, type equality is a specification of equality, not potential for instantiation
14:35:57 <c_wraith> not in any direct way. 
14:36:10 <ertes> read "CanBeEqualTo" as "CanBeInstantiatedAs"
14:36:12 <nitrix> Some ugly forall x y. x ~ b, x ~ b', y ~ c, y ~ c' ...
14:36:17 <nitrix> :(
14:36:47 <nitrix> That's fascinating though. Is this a limitation of Haskell, Hindley-milner, or universal quantification?
14:36:54 <dolio> Why do you need the constraints?
14:37:16 <dolio> You're just calling (***).
14:37:28 <c_wraith> dolio, because of the rank 2 type. 
14:37:51 <c_wraith> dolio, the goal is to instantiate one argument at two different types. 
14:37:57 <dolio> So?
14:38:12 <nitrix> dolio: let both f = f *** f in both succ (1, 'c')
14:38:20 <ertes> dolio: (f *** f) works, but there is no g such that (g f = f *** f) with the generality of (***) to allow different objects for each component
14:38:40 <dolio> :t arr id
14:38:41 <lambdabot> Arrow a => a c c
14:38:58 <nitrix> :t arr succ
14:39:00 <lambdabot> (Arrow a, Enum c) => a c c
14:41:12 <c_wraith> nitrix, I guess you could call it a weakness of hindley-milner, as h-m is what specifies that lambda arguments must be monotyped. 
14:41:47 <dolio> :t let both :: Arrow a => (forall x y. a x y) -> a (x, x') (y, y') ; both f = f *** f in both
14:41:48 <lambdabot> Arrow a => (forall x1 y1. a x1 y1) -> a (x, x') (y, y')
14:42:13 <ertes> dolio: try (both id)
14:42:42 <dolio> Right, that won't work because it's not general enough.
14:42:49 <dolio> There are arrows that will work with both, though.
14:43:08 <c_wraith> this has nothing to do with arrows. 
14:43:31 <ertes> dolio: sure, but i don't think that's very useful =)
14:44:08 <c_wraith> if you replace them with (->) it stays just as broken. 
14:44:16 <nitrix> dolio: I was trying to make it more general for Xnuk and failing miserably.
14:44:23 <dolio> :t let both :: Arrow a => (forall x. a x x) -> a (x, y) (x, y) ; both f = f *** f in both
14:44:24 <lambdabot> Arrow a => (forall x1. a x1 x1) -> a (x, y) (x, y)
14:44:40 <ertes> dolio: try (both (arr succ))
14:45:39 <nitrix> Cannot deduce Enum x1
14:45:44 <ertes> since 'both' is the user of the morphism, *it* needs to make the assumptions, which amounts to extra constraints on the rank-2-bound types…  but there is no way in haskell to express potential for instantiation, so it can only make what c_wraith called "weirdly specific" constraints
14:46:13 <nitrix> Yeah now we're back to ertes's oberservation. You have an issue with instantiation.
14:46:17 <ertes> s/constraints$/assumptions/
14:47:00 <ertes> not to say that it *couldn't* work, just that haskell has no mechanism to make it work =)
14:47:28 <nitrix> *cough* SPJ *cough* help
14:47:43 <nitrix> :P
14:47:50 <ertes> you could hack something together using Typeable, but i'd expect that to be super-ugly =)
14:48:42 <dolio> :t let both :: (Arrow a, c x, c y) => p c -> (forall x. c x => a x x) -> a (x, y) (x, y) ; both _ f = f *** f in both
14:48:44 <lambdabot> (Arrow a, c y, c x) => p c -> (forall x1. c x1 => a x1 x1) -> a (x, y) (x, y)
14:49:25 <ertes> that could work
14:49:33 <dolio> :t let both :: (Arrow a, c x, c y) => p c -> (forall x. c x => a x x) -> a (x, y) (x, y) ; both _ f = f *** f in both (Proxy :: Proxy Enum) succ
14:49:33 <c_wraith> that works until you need two constraints. 
14:49:34 <lambdabot> (Enum y, Enum x) => (x, y) -> (x, y)
14:49:52 <ertes> indeed, you can't have two constraints
14:50:08 <c_wraith> or until you need a higher-kinded constraint
14:50:30 <ertes> more generally any constraint that would require partially applied type synonyms
14:50:41 <ertes> although again: that could be fixed
14:51:19 <ertes> there is no reason to disallow partial application in general…  only special cases like instances need to be disallowed
14:55:09 <c_wraith> the reason I had those objections immediately on hand is that I was already thinking about that approach, and where it breaks down. :) 
15:02:14 <ij> Why doesn't the third test case of this simple Megaparsec parser parse? http://vpaste.net/QWhZK
15:02:58 <ij> Oh, I know — because it takes the left one first, so it never tries to parse it as a backslash?
15:03:37 <ij> Does this have something to do with it being LR parser?
15:05:57 <ij> No, changing the order still doesn't happ.
15:05:59 <ij> help*
15:06:54 <ij> Oh, and of course "te"st" doesn't parse — it was meant to be "te\"st", but that doesn't work either.
15:09:26 <ij> Okay, I solved the mystery.
15:10:24 <mtjmullen> https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#v:ala woah, this is cool
15:10:40 <mtjmullen> I should actually sit down and learn more stuff from lenses at some point
15:10:45 <Insanity_> mhm, somehow now when I import my .hs script in GHCi I can not run any functions inside
15:10:51 <Insanity_> always "not in scope {function}"
15:10:57 <Insanity_> even though it said modules loaded
15:11:31 <ij> mtjmullen, pretty cool
15:11:50 <ertes> Insanity_: how did you load it?
15:12:14 <Insanity_> :l script.hs
15:12:41 <ertes> @paste your script.hs, Insanity_
15:12:41 <lambdabot> Haskell pastebin: http://lpaste.net/
15:12:42 <Insanity_> it does say " modules loaded : Main :
15:12:51 <Insanity_> hehe, prepare for the ugliness :D
15:13:21 <Insanity_> http://lpaste.net/9213030073433587712
15:14:13 <ertes> Insanity_: is there a Main.hi/Main.o lurking around?
15:14:19 <Insanity_> yeah there is
15:14:32 <Insanity_> it stopped working after I created them 
15:14:43 <ertes> delete/move those (ideally just compile with -outputdir, so they are written somewhere where GHCi doesn't see them)
15:14:45 <Insanity_> But I never had this happen before
15:14:56 <Insanity_> As in, even though I generated them I did not notice ghci to stop working
15:15:04 <Insanity_> Thanks erts
15:15:05 <ertes> background: if there is a compiled version, GHCi will prefer it, which has the effect of only giving you *exported* definitions
15:15:10 <Insanity_> ertes*
15:15:22 <Insanity_> Ah right, so if I had exported those functions, it would have been fine
15:15:24 <ertes> you have no module header, which is equivalent to:  module Main (main) where …
15:15:30 <ertes> so the only definition you can access is 'main'
15:15:42 <Insanity_> Right, that explains it
15:15:46 <Insanity_> Thanks for the background info
15:16:12 <ertes> that's only for compiled modules…  interpreted modules are fully accessible (because the hidden stuff has not been compiled away yet)
15:16:46 <ij> How could I make ghci load some imports only THIS time?
15:20:14 <Insanity_> what do you mean ij?
15:20:30 <ij> There's ~/.ghci, but that would load 'em every time.
15:20:49 <Insanity_> I never put imports there 
15:20:53 <Insanity_> but to import in a running sessions
15:21:03 <Insanity_> :m + module works
15:21:07 <Insanity_> for example
15:21:13 <Insanity_> :m + Data.List
15:21:20 <Insanity_> Will load Data.List
15:21:24 <ij> never is a strong word
15:21:31 <Insanity_> No I mean it
15:21:34 <Insanity_> I have _never_ done that yet :P
15:21:44 <Insanity_> but I have not done a lot with Haskell yet ;-)
15:21:44 <ij> Sorry, I didn't see "I" there. My bad.
15:21:55 <Insanity_> No worries, I figured as much :-)
15:22:30 <ij> Oh, I can oneline them then.
15:22:39 <ij> That solves some of my issues with pasting import lists.
15:22:44 <Insanity_> I think this works as well
15:23:02 <Insanity_> :m + Data.List Data.Text ....
15:23:06 <Insanity_> as many as you want afaik
15:23:43 <ij> The «onelining» part was speaking precisely about that.
15:24:20 <MarcelineVQ> if you have trouble with pasting imports on multiple lines you can use :{   :}
15:24:42 <ij> What's that?
15:24:46 <MarcelineVQ> :{ <enter> <as many lines of anything you like> :} <enter>
15:24:59 <hexagoxel> or simply don't restart ghci and :reload
15:25:01 <MarcelineVQ> type :help in ghci for lots of neat things
15:25:25 <ij> No, importing works, it's just that it moves away the history.
15:25:45 <ij> I want to be able to ^P^P^P^J.
15:25:49 <hexagoxel> i guess that does not work if you modify the .cabal.. but otherwise? can't think of much
15:26:05 <ij> I do that, but … I sometimes stop using ghci. :D
15:26:27 <ij> So :m + One Two Three is what I'm lookin' for.
15:26:44 <hexagoxel> put it inside a tmux session.
15:26:55 <hexagoxel> throw more tooling at the problem! the solution to everything :D
15:27:06 <MarcelineVQ> I don't understand the problem, glad you found a solution though. note also there's an :add
15:27:55 <ij> hexagoxel, I run everything in tmux.
15:29:17 <Maxdamantus[W]> C-b, [
15:29:38 <Maxdamantus[W]> or change C-b to whatever your tmux command key is.
15:30:59 <Maxdamantus[W]> s/command/prefix/
15:31:30 <jmorris> is there a function that does this? Monad f => f (a -> b) -> (a -> f b)
15:32:20 <hexagoxel> :exf "Monad f => f (a -> b) -> (a -> f b)"
15:32:21 <exferenceBot> \ a b -> fmap (\ f6 -> f6 b) a
15:32:38 <hexagoxel> fmap ($ b) a
15:34:20 <hexagoxel> :exf "Monad f => a -> f (a -> b) -> f b" -p
15:34:21 <exferenceBot> Data.Functor.fmap . flip id
15:34:27 <jmorris> http://lpaste.net/350922
15:34:37 <jmorris> this is the problem I'm trying to solve
15:36:27 <jverse> I'm having a bit of trouble understanding an exercise I'm trying to do.
15:36:42 <jverse> oops, meant to include it
15:37:12 <jverse> "Write a generator listOf :: Integer -> Gen a -> Gen [a]  such that listOf n g generates a list of n elements, where each element is generated by g."
15:37:54 <jverse> so the second parameter, Gen a is a generator. But the final Gen [a] sounds like it should be a list of generated values, not a generator itself?
15:38:56 <hpc> it's a generator that makes lists
15:39:43 <ertes> :t \c x -> c >>= ($ x)
15:39:45 <lambdabot> Monad m => m (a -> m b) -> a -> m b
15:39:57 <ertes> :t \c x -> ($ x) <$> c
15:39:58 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:40:08 <ertes> jmorris: ^ like this?
15:40:21 <ertes> ah, hexagoxel already wrote it
15:40:25 <hexagoxel> :exf "Monad f => f (a -> b) -> f a -> f b" --hiding "(Control.Applicative.<*>)" --hiding "fmap" --hiding "liftA2"
15:40:26 <exferenceBot> \ a b ->
15:40:26 <exferenceBot>   b Control.Monad.>>=
15:40:26 <exferenceBot>     (\ f -> a Control.Monad.>>= (\ f10 -> pure (f10 f)))
15:40:26 <exferenceBot> \ a b ->
15:40:26 <exferenceBot>   a Control.Monad.>>= (\ f6 -> b Control.Monad.>>= (pure . f6))
15:40:40 <hexagoxel> jmorris: in terms of (>>=): ^
15:40:42 <jmorris> ertes: This is the problem http://lpaste.net/350922
15:41:11 <ertes> jmorris: that requires a different function though
15:41:28 <jmorris> which function?
15:41:30 <ertes> jmorris: try to express it in do-notation, then desugar it
15:41:35 <jverse> hpc, so this listOf function would return a new generator, which would then have to be used by another function to actually return the list that the exercise asks for?
15:41:46 <jmorris> it's from http://github.com/NICTA/course
15:41:48 <ertes> jmorris: ah, you don't have do-notation =)
15:42:03 <jmorris> I might have already made the function
15:42:11 <jmorris> In applicative or functor
15:43:07 <ij> Ghc whined about error at 44 and when I fixed it, about error at 41. Isn't that odd?
15:43:25 <hexagoxel> jmorris: you realize that your (=<<) is just flip (>>=), right? so what exferenceBot provided should be close to what you want.
15:44:06 <hexagoxel> :t (>>=)
15:44:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:44:10 <hexagoxel> :t (=<<)
15:44:11 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:44:12 <Koterpillar> ij: not if 44 was a syntax error that prevented, e.g. types from being solved
15:44:19 <ertes> ij: not really…  the order you see errors in has more to do with dependencies than source code location
15:44:56 <ertes> ij: the previous error may have caused GHC not to have enough information to even see the error in line 41 yet, until you fixed it, at which point GHC was informed enough to see the error in line 41
15:45:56 <ij> Ah, types may be inferred slowly.
15:46:03 <hpc> jverse: yes-ish
15:46:13 <hpc> jverse: it doesn't say outright but it asks for one generator which makes the list
15:47:22 <jmorris> I'm still not really sure
15:47:42 <jmorris> I think I need to have ,~ something ~ =<< a
15:47:51 <jmorris> because the type of a is f a
15:48:12 <jmorris> and =<< takes (a -> f b) -> f a -> f b
15:48:13 <ij> Is parsing without parser combinators pain?
15:48:27 <jmorris> but f :: f (a -
15:48:48 <jmorris> f :: f (a -> b) and =<< take (a -> f b)
15:50:27 <dibblego> jmorris: also use (<$>)
15:52:35 <jmorris> dibblego: f <*> a, fits the type
15:52:47 <jmorris> which means  f <*> a =  f <*> a 
15:52:55 <dibblego> jmorris: (<*>) is the function you are writing
15:53:15 <jmorris> and I can write it with (<$>) and (=<<)
15:53:22 <dibblego> that's the answer
15:54:09 <jmorris> what is?
15:54:20 <dibblego> write (<*>) with (<$>) and (=<<)
16:01:40 <whiteline> does anyone here know what "Invalid package ID" means in the context of Stack?
16:02:40 <whiteline> i've tried googling it and some people seem to have had the exact same error - invalid package id and then a string of packages - but i can't seem to find any helpful information on it
16:02:44 <MarcelineVQ> it usually means you need to upgrade it, or your .cabal file isn't quite right
16:02:44 <glguy> whiteline: It often means that your stack.yaml is malformed. It can also mean that your stack executable is out of date relative to your GHC version
16:02:56 <MarcelineVQ> ah is it stack.ymal not cabal?
16:03:23 <glguy> whiteline: You can paste your stack.yaml to http://lpaste.net
16:03:25 <whiteline> glguy: i did do stack setup and stack upgrade though
16:03:41 <whiteline> so it should use the correct GHC, 8.0.1, for the current LTS
16:05:04 <MarcelineVQ> stack upgrade puts the upgraded stack into .local/bin so you'll want to make sure that's on your path. you can be sure with stack --version  the latest should be 1.3.2
16:05:05 <whiteline> glguy: which one? i get the error regardless of if i'm building the example project or not
16:05:30 <whiteline> MarcelineVQ: ah. it is using an earlier version
16:06:24 <whiteline> thank you, now it works :3
16:15:27 <rribeiro> Hi! Does anyone knows how to solve the error  can't load .so/.DLL on ghci? I'm using stack 1.3.2, on Mac OS Sierra, and ghc 8.0.1
16:15:44 <rribeiro> I've googled for solutions, but none worked
16:19:17 <glguy> rribeiro: There's not a generic solution for that. Paste the command you're running and the output you're getting to the pastebin to help people see what's going on
16:21:14 <rribeiro> glguy: I've pasted the output here: http://pastebin.com/hqqBmfT9
16:21:30 <rribeiro> I'm just trying to call stack ghci on a stack project
16:22:05 <rribeiro> and ghci doesn't start because he can't load can't load .so/.DLL 
16:23:57 <glguy> rribeiro: It's having trouble finding a library that comes with GHC 8.0.1, specifically transformers-0.5.2.0
16:24:18 <rribeiro> is there a way that I can fix this?
16:24:23 <glguy> Does: "ghc-pkg check" report any problems? Have you manually unregistered packages? used the --force flags?
16:24:59 <rribeiro> let me do ghc-pkg check
16:25:18 <rribeiro> it doesn't return any message
16:25:50 <rribeiro> and no I didn't use any force flag
16:28:14 <MarcelineVQ> how about  stack exec -- ghc-pkg check  from the same place you did stack ghci
16:28:44 <glguy> Well, if the command MarcelineVQ gave you comes back the same either you still have transformers-0.5.2.0 installed and I'd recommend removing your stack snapshot so that it rebuilds, or you don't and I'd recommend reinstalling GHC so you do
16:29:02 <glguy> You can see where GHC things that the transformers package should be installed with: ghc-pkg describe transformers-0.5.2.0
16:30:00 <rribeiro> it returned messages complaining about haddock files on the libraries that I'm using
16:31:23 <MarcelineVQ> it'll sumarize issues at the end if there are important ones. e.g. "The following packages are ..."
16:32:06 <rribeiro> MarcelineVQ: it returned only warnings about haddock
16:52:11 <xkapastel> probably not the correct place to ask, but anyone here familiar with illative combinatory logic?
17:10:20 <dibblego> jmorris: got it?
17:15:31 <jmorris> dibblego: no
17:16:54 <dibblego> @type (=<<)
17:16:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:17:16 <dibblego> jmorris: the (a) in that type signature could be anything, including a function, agree?
17:17:23 <jmorris> yes
17:17:34 <dibblego> Monad m => ((x -> y) -> m b) -> m (x -> y) -> m b
17:17:51 <glguy> jmorris: Are you working on "Monad f => f (a -> b) -> (a -> f b)" still or is this a different one?
17:17:59 <dibblego> I think that was misstated
17:18:13 <dibblego> it is f (a -> b) -> f a -> f b in terms of (=<<) and (<$>)
17:18:24 <jmorris> glguy: still that one
17:18:32 <dibblego> jmorris: which of the two signatures above is correct?
17:18:48 <jmorris>  f (a -> b) -> f a -> f b
17:19:04 <dibblego> ok, be aware that this is different to what you stated originally, f (a -> b) -> (a -> f b)
17:19:29 <jmorris> I was wondering if there was a function that did that
17:19:43 <dibblego> there is, it is in NICTA/course somewhere
17:19:49 <dibblego> you can write it using just (<$>)
17:20:04 <jmorris> because (=<<) :: (a -> f b) -> f a -> f b 
17:20:16 <dibblego> it won't help you with (<*>) 
17:20:21 <jmorris> and <*> :: f (a -> b) -> f a -> f b
17:20:36 <dibblego> to get to (<*>) you will need (=<<) and (<$>)
17:21:08 <jmorris> I know
17:21:12 <jmorris> but I don't know how
17:21:22 <glguy> There are two distinct ways to get something with (<*>)'s type
17:21:47 <glguy> Does the exercise give you any constraints that might help narrow that down?
17:21:51 <dibblego> (=<<) can be used as if it has the type ((x -> y) -> m b) -> m (x -> y) -> m b
17:21:57 <dibblego> glguy: yes they do
17:24:04 <jmorris> what are the ways?
17:24:50 <dibblego> you can focus on the argument (f (a -> b)) first or the other argument (f a) first
17:25:05 <dibblego> you want to focus on the first one
17:25:10 <dibblego> (=<<) can be used as if it has the type ((x -> y) -> m b) -> m (x -> y) -> m b
17:25:29 <jmorris> ok
17:35:34 <jmorris> i dont understand ((x -> y) -> m b)
17:36:11 <glguy> Which part?  Do you understand:   (Int -> Int) -> Char   ?
17:36:12 <Philippa> I'm not sure I understand how there can be anything useful of that type
17:36:52 <jmorris> glguy: No, I don
17:36:59 <jmorris> 't understand the parentheses
17:37:03 <glguy> Philippa: It's a portion of a larger type mentioned above: ((x -> y) -> m b) -> m (x -> y) -> m b
17:37:11 <Philippa> glguy: ah, fair enough
17:37:42 <glguy> jmorris: (Int -> Int) -> Char   is the type of a function whose result type is Char, but whose argument type is *also* a function
17:37:43 <Philippa> though even in that context I'm side-eyeing it somewhat
17:38:07 <jmorris> ok
17:38:08 <dibblego> it's how you get (<*>) from (=<<) and (<$>)
17:38:35 <jmorris> I have no ideas about how to get there
17:38:57 <glguy> :t (\f -> chr (f 97)) :: (Int -> Int) -> Char
17:38:59 <lambdabot> (Int -> Int) -> Char
17:41:05 <Squarism> when running stack, say i want a package of a certain version but it cant be found in the LTS im using. How can i find the earliest (or any) LTS its contained in?
17:54:39 <geekosaur> generally I search the package on stackage.org. it's far from perfect, but good solutions are kinda difficult
17:55:25 <glguy> Squarism: The older LTS resolvers aren't maintained, new ones are released. I think the standard practice is to pick the latest resolver and then add extra-deps on whatever else you need
17:55:42 <Squarism> oh ok
17:55:54 <Squarism> i resolved to that
18:16:00 <haskell855> Is a real time system realistic in haskell? 
18:16:14 <dolio> No.
18:16:24 <dolio> Just like almost every other language.
18:17:28 <dolio> Unless you mean creating a domain specific language that emits real time code, or something.
18:17:35 <haskell855> is there a functional programming language that could be used to make a real time system?
18:17:48 <haskell855> No, I mean coding directly in Haskell
18:23:12 <dolio> Real time is rather at odds with lots of general purpose programming.
18:23:38 <dolio> Like, you'd use a language without dynamic memory allocation.
18:24:00 <dolio> And you probably wouldn't use modern x86 type CPUs which reorder instructions and whatnot.
18:25:43 <dolio> Fitting 'functional programming' into constraints like that would be pretty difficult.
18:26:16 <c_wraith> especially if your conception of functional programming means using immutable data
18:27:44 <exio4> I'd guess something like Rust which an imperative language with some features which aren't normally found in imperative languages but functional languages (like sum types, ...) might be a good fit comparatively 
18:28:08 <dolio> I'm not sure C is a good language for it.
18:28:25 <dolio> And most of Rust's features probably go the wrong way.
18:28:59 <dolio> Features beyond C, that is.
18:30:00 <c_wraith> Rust at least gives you defined semantics a lot more often than C
18:30:15 <dolio> I think most programmer assume that you do real time programming in C, but I think it might be that you use some custom tooling that the people that made your real time hardware wrote.
18:31:48 <dolio> Yeah, it's better in that respect. :)
18:32:12 <dolio> I mean, I way prefer Rust to C for anything that I'd probably want to do.
18:39:40 <Axman6> haskell855: what hasn;'t been mentioned is that Haskell is a fantastic for designing languages which produce code for embedded systems which enforce strong guarantees about various properties. for example the Copilot language allows you to write very functional looking stream processing code, which turns out is extremely common in monitoring systems, and it guarantees constant time execution of looks, constant time memory usage etc. you write
18:39:40 <Axman6>  your programs in an EDSL in Haskell and use that to produce C, or other outputs which can be used for formal verification etc.
18:41:24 <davean> He might mean a very soft realtime
18:41:25 <Axman6> Galois has some work with NASA using some other similar system (or Copilot, I can't remember) for monitoring hard real time flight control systems
18:41:29 <davean> hard realtime is ... hard
18:41:42 <Axman6> davean: it's not that hard if you can constrain the language
18:42:01 <davean> Axman6: uh? We don't even know how long instructions take on almost any CPU
18:42:07 <davean> Axman6: they're not even documented these days!
18:42:16 <Axman6> yes we do, on embedded sytems
18:42:26 <Axman6> most embedded CPUs are very predictable
18:42:31 <davean> Axman6: On a VERY few specificly designed CPUs for realtime systems
18:42:50 <Axman6> which are usually the ones chosen for hard real time applications...
18:42:52 <davean> Arm has a special series JUST for realtime, the rest of their embeded ones aren't for example
18:43:03 <davean> and even those have issues with some cache effects
18:43:05 <davean> etc
18:43:12 <davean> and then theres unmaskable interupts
18:43:18 <davean> so you'll still miss your deadlines
18:43:33 <Axman6> generally the worst time execution of things are known
18:44:03 <Axman6> most em,bedded sytems provide means for handling interrupts in a way that allow for hard real time guarantees to be maintained, using interrupt priorities
18:44:05 <davean> which is how you get *soft* realtime
18:44:06 <davean> not hard
18:44:35 <Axman6> you get hard real time if you know that in the worst case you won't miss deadlines
18:46:09 <davean> depending on how you specify your deadlines,, sure
18:46:15 <Axman6> and systems like copilot allow you to write hard real time systems too, with "concurrent" threads (the scheduling is static)
18:46:24 <mitchty> is there a way for Setup.hs build to work in parallel? the old makefile approach doesn't seem to exist anymore
18:47:29 <nshepperd> atmel mcus come with a manual listing the entire instruction set and cycles taken for every instruction
18:47:30 <Axman6> mitchty: I thought cabal has support for parallel builds now
18:47:41 <davean> Axman6: between packages, not inside?
18:47:46 <mitchty> Axman6: for dependencies sure, for inside a package no
18:47:54 <davean> whichyou lose if you sue a custom setup.hs
18:48:02 <Axman6> huh, I thought it had that, shame if it doesn;t L(
18:48:05 <Axman6> :(*
18:48:55 <mitchty> i ask mostly due to having to use setup.hs on an arm board, single cpu perf is.... glacial
18:49:23 <geekosaur> the real problem is cabal isn't what needs to parallelize better, ghc does
18:49:31 <Axman6> yeah
18:49:35 <davean> ghc has --make at least
18:49:35 <geekosaur> and that turns out to be a bit tricky
18:51:00 <slack1256> the problems with parallel ghc had to do with FastString or it was something else?
18:51:01 <mitchty> i suppose i could buy one of these new arm soc's https://www.solid-run.com/product/armada-8040-networking-community-board/
18:51:20 <mitchty> but it'll still have single core as a funnel
18:51:43 <geekosaur> a big issue iirc had to do with cached iface files (.hi files)
18:57:16 <mitchty> specs on that thing if anyone is curious https://www.solid-run.com/marvell-armada-family/armada-8040-community-board/ it'll support ecc ddr4 and even 10gig via sfp
18:58:44 <mitchty> guess i'll just get used to 14 hour compiles :)
19:07:57 <nitrix> ? :: Engine () -> IO ()
19:08:07 <nitrix> Should I name it runEngine or withEngine?
19:08:39 <nitrix> It's meant to be used as main = someEngine $ do ...
19:09:50 <slack1256> runEngine
19:10:01 <Koterpillar> nitrix: typically runX :: m a -> a, and withX :: m a -> m a
19:10:07 <Koterpillar> with some variations
19:10:10 <slack1256> withEngine sound like you want to pass a continuation with it
19:10:21 <codygman> I'm using unix timestamps, anyone know a reason I shouldn't use the unix-time library or have a better suggestion? unix-time: https://github.com/kazu-yamamoto/unix-time
19:10:41 <slack1256> https://hackage.haskell.org/package/async-2.1.1/docs/Control-Concurrent-Async.html#v:withAsync example
19:11:15 <slack1256> codygman: I would use unix-time only because kazu maintains it
19:11:56 <nitrix> Koterpillar: What about m a -> n a ?
19:13:02 <nitrix> coerceEngine, embedEngine o:
19:13:29 <Koterpillar> nitrix: tricky! I would not worry about it too much though
19:13:38 <codygman> slack1256: haha :) It seems to fit the bill of being almost exactly what I want: Text -> Int64 representation timestamp I can put in an unboxed vector. Text because that's the format I'm already in.
19:14:04 <codygman> Anyone know how much overhead there is converting from bytestring to text and vice versa? I'm sure someones made a blog post along those lines, I just can't recall.
19:15:49 <slack1256> I wouldn't care unless profiling revealed it was really the bottleneck
19:16:29 <codygman> slack1256: Yeah, good point. I should just use this as is and then reprofile.
19:16:42 <codygman> I have such a pathological perf bug right now that I surely won't notice
19:16:54 <codygman> self-made bug ;)
19:27:47 <mitchty> doh, i had split objs in my configure call and didn't notice it, 14 more hours to go again :)
19:45:58 <codygman> I have template Haskell in a module X that uses module Y's Y.Type, Module Z imports module X but I get an error about type Y.Type not being in scope. Can I re-export Y.Type from module such that module Z need only import module X?
19:46:33 <Koterpillar> codygman: are you _generating_ code that needs Y.Type?
19:47:51 <Koterpillar> codygman: keep in mind that someone might import X (th_function), omitting the re-export
19:48:28 <Koterpillar> codygman: https://ghc.haskell.org/trac/ghc/ticket/1475
19:50:30 <nitrix> Is there similar to `over _1 foo` but that'd give a result similar to the result of foo instead of the original tuple?
19:50:56 <nitrix> foo  . view _1   I  suppose?
19:52:13 * nitrix hides
19:57:21 <Axman6> :t over
19:57:22 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
19:57:43 <Axman6> oh, that's %~, ok. what result do you want?
19:57:48 <codygman> Koterpillar: I'm generating code that needs Y.type yes
19:58:01 <codygman> Koterpillar: I'm the only user so I don't yet care about someone omimtting the re-export
19:58:37 <Koterpillar> codygman: so... have you already tried it?
19:58:42 <codygman> I'm using the UnixTime library now, but I want to use my own show instance... what's the easiest and best way to do this
19:59:01 <Axman6> codygman: newtype?
19:59:03 <codygman> Koterpillar: No not yet, my focus is on my newest question. I can still use my library even if I have to import an extra thing
20:00:36 <codygman> Axman6: for some reason I thought a newtype would cause me inconvenience but now I see not
20:00:42 <codygman> thanks
20:00:54 <codygman> Koterpillar: I'll try the suggestion in the trac you linked in a moment
20:11:58 <codygman> Any convenient way to go from a unix timestamp in seconds to a Time.Day?
20:12:22 <glguy> > (_1 <%~ succ) (10,20)
20:12:25 <lambdabot>  (11,(11,20))
20:12:34 <glguy> nitrix: like that?
20:35:31 <erisco> when you get the code right you know it
20:35:57 <erisco> suddenly it becomes so simple you can hardly believe you didn't think of it
20:37:28 <erisco> trust that if it is still murky and confusing that it isn't right yet
20:40:20 <nitrix> Is it a limitation of Template Haskell that you can't have mutually recursive types such that their definition order is relevant?
20:40:45 <nitrix> I can write my own lenses, it just feels very arbitrary.
20:42:53 <meglomaniac> Hi, for a power function defined for integer exponents, if I defined it as power x n =( power x (n 'div' 2))* ( power x (n 'div' 2)) for n even and power x n = x* ( power x (n 'div' 2))* ( power x (n 'div' 2)) for n odd
20:43:20 <meglomaniac> Then when haskell is evaluating this, would it evaluate ( power x (n 'div' 2)) twice?
20:43:34 <Koterpillar> meglomaniac: without optimizations, yes
20:43:51 <erisco> might with optimisations too
20:44:23 <erisco> how hard is it going to look for common sub-expressions?
20:45:02 <meglomaniac> Koterpillar so if I set power x 0 = 1 as a base case, power x 1 should require the * operator to be used twice?
20:46:11 <Koterpillar> meglomaniac: why not let y = power x (n `div` 2) in y * y?
20:46:20 <erisco> if I am thinking it is really important the compiler makes an optimisation, and I can just make it myself, I'm not trusting the compiler
20:46:25 <meglomaniac> Im confused because this implementation should be better than O(n) in terms of the nunber of * used, but it doesnt seem to be
20:46:47 <meglomaniac> Koterpillar oh, yeah I could do that
20:48:14 <meglomaniac> Koterpillar or could I alternatively use a where clause
20:48:24 <Koterpillar> yes
20:49:18 <meglomaniac> Okay so in terms of the complexity of this , I now have u(2m+1) = 2 + u(m) and u(2m) = 1 + u(m)
20:49:27 <meglomaniac> With u(0)=0
20:49:45 <meglomaniac> But Im not sure how to translate that into a closed form
20:50:13 <meglomaniac> The measure of complexity im using is the number of times * is used
20:50:24 <Koterpillar> I'm pretty sure the worst case is if you use the first form all the time
20:51:31 <Koterpillar> with m >> 1, u(2m) ~= 2 + u(m), therefore u(m) = log2(m)
20:51:32 <meglomaniac> You mean without the let y= ... in ...
20:51:53 <Koterpillar> no, with the let
20:52:39 <erisco> if divide and conquer didn't end up like this we'd be concerned
20:54:51 <meglomaniac> Wait but how do we go from u(2m) ~= 2 + u(m) to u(m) = O(log2(m))
20:56:47 * Koterpillar waves hands roughly in the direction of an epsilon delta
20:59:42 <erisco> meglomaniac, rigorously I don't know. aint my type of math. However, there is a simple way to think about it
21:00:14 <erisco> u(2m+x) = y + u(m)  we've got something of this shape, right, and x and y are constants
21:00:32 <erisco> so first we chuck out x because it isn't important
21:00:46 <erisco> tossing out small constants in comparison to dividing by 2 is irrelevant for big m
21:01:09 <erisco> then we just look at how many times we add y to itself, and we know y > 0
21:01:14 <Koterpillar> well, formally, you can define u(1) = 1 and go by induction
21:01:16 <erisco> well, how many times can you divide a number by 2
21:01:23 <erisco> this log2(m)
21:02:00 <erisco> so we add y to itself log2(m) times
21:02:13 <erisco> so we have ylog2(m) and we toss out the coefficient
21:03:15 <erisco> I forget the exact formulation but in big-O we're looking for a function which is always greater or equal to the exact cost after some arbitrary point
21:03:27 <erisco> which roughly means you toss out small stuff
21:03:37 <erisco> and that's the back of the envelope version that I use :P
21:09:37 <erisco> my math prof would scorn me for using my intuition
21:10:24 <erisco> I just figure what being correct is worth
21:15:11 <Cale> https://en.wikipedia.org/wiki/Master_theorem
21:16:28 <erisco> am I really better for plugging my numbers into equations I still do not understand
21:16:29 <Rotaerk> where's the Doctor theorem?
21:17:15 <dolio> According to the recurrence, u is turning an n-fold product of 2s into an n-fold sum of 2s.
21:17:25 <dolio> So u(2^n) = 2*n
21:17:57 <Cale> erisco: Well, not necessarily, but if you want a proof, you can look one up :)
21:18:16 <Koterpillar> right, since we're in big O, we can round the argument to the nearest power of 2
21:18:51 <dolio> And log_2 (2^n) = n, so u must be approximately log_2.
21:19:34 <erisco> would you like your bank balance rounded to the nearest power of 2?
21:19:44 <Koterpillar> > zipWith (/) (iterate (\n -> 2*n + 1) 1) (iterate (* 2) 1)
21:19:47 <lambdabot>  [1.0,1.5,1.75,1.875,1.9375,1.96875,1.984375,1.9921875,1.99609375,1.998046875...
21:20:20 <Koterpillar> erisco: that would make an interesting currency system
21:21:43 <Cale> erisco: Yes!
21:21:51 <Cale> (right now)
21:22:04 <erisco> for me the answer is no :P
21:22:45 <dolio> Then you should withdraw some money.
21:24:02 <Cale> I would make about 2 and a half months' pay.
21:24:14 * erisco converts to USD… never mind, double me up!
21:31:24 <erisco> I am finding an interesting pattern… see if I can summarise without a blog post
21:32:36 <erisco> lets do boolean logic at the type level.  data True = True; data False = False; class And a b c | a b -> c where and :: a -> b -> c
21:32:53 <erisco> so  instance And True True True where and True True = True   for example
21:33:41 <erisco> then if we want indeterminism we add data ToF = XTrue True | XFalse False
21:33:56 <erisco> I am elaborating the definitions a bit because we might be carrying more data if we were doing something more complicated than boolean logic
21:34:24 <erisco> then for example   instance And False ToF False
21:34:43 <erisco> and also   instance And ToF ToF ToF   is interesting because it completely writes itself
21:34:57 <erisco> it is just a dispatch table to our other instances
21:35:37 <erisco> the point of this is that you can retain some type level information in the return value
21:35:49 <erisco> so you know that and False x is always False, for example
21:36:06 <erisco> this can be relevant when, for example in my scenario, reusing code
21:36:18 <codygman> Can you get a quickcheck property to print out the result that failed like hspec-expectations does for regular hspec stuff?
21:36:47 <erisco> if you always dump things into ToF, or Bool, then you might find you're then having to use partial cases to get the data back out
21:36:55 <erisco> makes more sense if we're using Left/Right or something like that
21:36:57 <Cale> codygman: uhh... doesn't quickCheck already do that?
21:37:28 <kadoban> codygman: What runner are you doing? Ya I think mine already does that
21:38:00 <erisco> this came out of using classes for adhoc polymorphism
21:38:22 <codygman> kadoban: just hspec
21:39:15 <codygman> You guys see anything wrong with this epochTime :: UTCTime -> EpochTime function? http://lpaste.net/350924 Quickcheck says: 1858-11-17 00:00:00.000000000001 UTC
21:39:17 <codygman> oh wait...
21:39:19 <codygman> LOL
21:39:44 <codygman> I need to modify the UTCTime arbitrary instance :)
21:39:44 <erisco> I just really like the pattern of it
21:39:57 <erisco> ToF is just a boolean variable
21:40:06 <erisco> the relationship between types and values here is… interesting
21:40:11 <EvanR> 1858 was over 100 years before UTC
21:40:13 <kadoban> codygman: Hmm, I don't think I've ever used hspec. But mine definitely shows exactly what failed, I use tasty. I know I've used other ways to run quickcheck too and they all did.
21:40:51 <erisco> EvanR, and 3000 BC was 3000 years before Christ
21:41:17 <qmm> are there examples of creating a language which is actually a dsl on top of haskell 
21:41:41 <erisco> qmm, called eDSLs and yes. Atom for example
21:42:04 <erisco> unless you're talking about using Haskell to write compilers or interpreters or something
21:42:08 <qmm> i want to create a file named test.mylang and have haskell somehow compile output code for another language
21:42:16 <qmm> i don't know what this type of process is called
21:42:17 * erisco facepalms
21:42:46 <qmm> erisco: why the face palm?
21:44:54 <qmm> the .mylang file extension?
21:45:08 <erisco> no, I just assumed you meant an eDSL and I was wrong
21:45:51 <Axman6> eDSL is the term you want to look for. if you can write the necessary language features in Haskell, you can get GHC to be your compiler (this is basically how Facebook is using Haxl - they provide a simple interface which non-programmers can write
21:45:52 <erisco> there was a time when I always paid close attention to the questions and didn't begin an answer until I knew I understood
21:46:28 <Axman6> if you are sure you want to invent your own syntax, then that's possible too - you may even find you can compile your language into Haskell and still get a lot for free
21:46:34 <erisco> well if he has his own source file I presume he isn't looking for eDSLs
21:47:14 <qmm> i think it needs to be an edsl
21:47:16 <erisco> if you are making your own syntax and want to translate this to another language this is called transpiling
21:47:32 <qmm> but then i want to convert that haskell code to another language
21:47:34 <erisco> but if you're pedantic then all compilers are transpilers so you may as well call it a compiler
21:47:39 <qmm> not really what to do that about that part
21:48:17 <erisco> with an eDSL you are just writing Haskell code
21:48:25 <qmm> i understand
21:48:44 <erisco> okay, well, then test.mylang would be filled with Haskell code
21:48:49 <qmm> yep
21:48:58 <erisco> and you'd probably call it test.hs instead
21:49:17 <qmm> maybe
21:50:03 <qmm> i suppose i just need a way to convert haskell code into lambda terms
21:50:35 <qmm> or somehow model haskell in the destination language
21:50:46 <erisco> I am not sure you've quite got eDSLs right
21:51:08 <qmm> the destination language has a typed lambda calculus iirc
21:51:19 <erisco> an eDSL is just a Haskell library. You import it, write Haskell code, compile the Haskell code, and run the Haskell program
21:51:45 <erisco> you aren't reading source files and parsing them
21:52:09 <erisco> if you're doing that then you are compiling
21:53:38 <erisco> the point of eDSLs is you can piggyback on GHC and Haskell. i.e. you do not have to write your own compiler and type system and so on
21:53:56 <erisco> "a language in a language"
21:54:21 <qmm> i'm pretty sure i understand this, and i don't want to write a compiler
21:54:27 <qmm> i guess that is code generation i'm describing though
21:54:40 <erisco> I don't know why you'd want to convert Haskell code to lambda terms then
21:55:20 <qmm> the ultimate target language isn't haskell, but i want to use haskell facilities to do things before generating the final code
21:55:36 <qmm> i suppose this really is getting into parsing/compiling
21:55:50 <EvanR> qmm: heres one mad science thing they tried https://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
21:55:54 <erisco> I don't know, from my perspective this is all over the board
21:56:03 <EvanR> involving hacking of ghc
21:56:50 <erisco> when you say "convert Haskell code" it sounds to me to be "parse Haskell source" and then some code gen
21:57:05 <erisco> if you are parsing Haskell source code then we're not talking about an eDSL
21:57:43 <erisco> or maybe we're talking about TH but I wager not
21:58:28 <erisco> !hackage Atom
21:58:46 <erisco> http://hackage.haskell.org/package/atom take a look here at an eDSL
21:58:53 <Cale> "i want to create a file named test.mylang and have haskell somehow compile output code for another language i don't know what this type of process is called"
21:58:59 <Cale> That's called compiling :)
21:59:19 <qmm> Cale: haha, yeah
21:59:22 <qmm> ok
21:59:32 <erisco> you write a Haskell program and when you run this program it spits out the C program
21:59:33 <EvanR> compiling haskell code is highly non trivial ;)
21:59:37 <erisco> at least it is C last I recall
21:59:48 <EvanR> ghc doesnt output C
22:00:01 <erisco> no but I am talking about Atom
22:00:07 <EvanR> oh yeah
22:00:17 <EvanR> thats specifically for outputting C
22:00:58 <erisco> so we're piggybacked on Haskell/GHC for the front end and we generate C
22:01:47 <EvanR> lambda-CCC piggybacks on haskell language, front end, middle end, optimizations etc, and generate something besides machine code
22:03:26 <erisco> I don't recommend using programs that write programs though due to the machine uprising potential
22:03:40 <kadoban> Haha
22:03:54 <slack1256> if SIGINT is caught on the main thread, does it kill all the other green threads before quitting?
22:03:58 <EvanR> machine hater
22:05:02 <sm> slack1256: normally, yes
22:05:17 <sm> but not in GHCI
22:05:30 <EvanR> note finalizers might not run
22:06:01 <slack1256> no? event if I have a supervisor thread with the bracket (and thus masked) pattern?
22:06:05 <slack1256> *even
22:06:39 <EvanR> in some random thread
22:06:50 <EvanR> correct, the system is going down *now*
22:07:04 <sm> use the async package
22:07:27 <EvanR> to properly cleanup on SIGINT you need to install your own handler
22:07:43 <slack1256> already using withAsync ;-)
22:08:41 <sm> +1
22:08:48 <lpaste> slack1256 pasted “SIGINT deal” at http://lpaste.net/350925
22:09:19 <slack1256> I am asking because networkLoop on that paste
23:18:24 <mounty> The Ids defined in Persistent are 64-bit integers, right?
23:18:29 <mounty> I
23:19:15 <mounty> I want to use Text.Show.showt on them to get a printable representation.  This is to put the value into a HTTP session value.
23:19:34 <mounty>     No instance for (text-show-2.1.2:TextShow.Classes.TextShow ViewId)
23:19:35 <mounty>       arising from a use of ‘showt’
23:19:59 <mounty> What's the fix?  I can't find any official function that for example converts an Id to a Word64.
23:20:15 <Cale> What's this ViewId type?
23:21:04 <mounty> It's an opaque integer identifier, a unique key of a persistent table.  http://www.yesodweb.com/book/persistent
23:21:27 <mounty> ViewId, ThingId, MyStuffId, WhateverId.
23:25:43 <athan> Are type variables normally polykinded if they're unused?
23:25:54 <athan> phantom ><
23:26:15 <Cale> athan: Only if certain extensions are turned on
23:26:32 <Cale> In Haskell98/2010, they're defaulted to kind *
23:26:42 <athan> ahh okay, thanks Cale
23:29:47 <Cale> mounty: Is it the Key type for some instance of PersistEntity perhaps?
23:30:17 <Cale> Well, it doesn't quite look like one, Key is a data family...
23:30:40 <Cale> mounty: Really hard to figure out without being able to look at the definition of the type and its instances.
