00:18:30 <systadmin> Is there any Haskell module/libraries similar to Python's `math` module?
00:18:41 <Lokathor> probably
00:18:47 <Lokathor> what does math do?
00:20:49 <systadmin> Lokathor: it adds more math operators such as factorial
00:21:11 <Lokathor> well some operations are in base, some operations you might have to look elsewhere for
00:21:15 <Lokathor> depending on what operation you want
00:21:34 <systadmin> I'm looking for one with factorial
00:22:01 <pikajude> @let factorial n = product [1..n]
00:22:04 <lambdabot>  Defined.
00:22:07 <pikajude> > factorial 5
00:22:11 <lambdabot>  120
00:22:35 <systadmin> How does that expression work?
00:22:39 <Lokathor> systadmin, there's no built in factorial that's commonly used, because factorial is pretty easy to define yourself in Haskell, as you can see
00:22:45 <pikajude> > [1..5]
00:22:48 <lambdabot>  [1,2,3,4,5]
00:23:04 <Lokathor> :t product
00:23:06 <pikajude> `product` does what you'd expect and that's what the .. operator does
00:23:07 <lambdabot> (Foldable t, Num a) => t a -> a
00:23:08 <systadmin> And the `product` does?
00:23:18 <pikajude> > product [2,3,4]
00:23:20 <lambdabot>  24
00:23:31 <Lokathor> product multiplies together all the values in the Foldable you pass it
00:23:32 <systadmin> The `product` expression or whatever you call it, multiplies all integers in a list?
00:23:37 <systadmin> Or Foldable
00:23:40 <Lokathor> yes
00:23:42 <pikajude> it multiplies all Nums in a Foldable
00:23:51 <Lokathor> List, Set, Vector, etc are all usable with product
00:23:52 <pikajude> integers in a list is a specific case
00:24:16 <systadmin> Sounds fun
00:24:25 <pikajude> also, ((,) a)
00:24:29 <pikajude> for some reason
00:24:45 <systadmin> How do foldables work?
00:25:25 <pikajude> see http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Foldable.html
00:26:01 <ongy> you want to look at foldl/foldr, the entire class can be a bit confusing
00:27:03 <Lokathor> a Foldable is kinda like... uhm, any structure that lets you pull out a part at a time and work it into a total at the end
00:27:20 <Lokathor> it's hard to avoid saying "any structure that you can fold", but that's a pretty useless definition
00:32:03 <ongy> I alwasy want to say that a Foldable is a structure that can be traversed, than I think about Traversable and get confused
00:35:43 <kirillow> how do i just repeat a function indefinitely?
00:36:01 <orzo> kirillow: iterate
00:36:07 <orzo> :t iterate
00:36:09 <lambdabot> (a -> a) -> a -> [a]
00:36:40 <orzo> :t forever
00:36:42 <lambdabot> Applicative f => f a -> f b
00:36:44 <glguy> :t fix
00:36:49 <lambdabot> (a -> a) -> a
00:37:00 <kirillow> Mh.. this is in the context of an IO Monad
00:37:02 <kirillow> forever!
00:37:14 <orzo> kirillow: i'd prefer fix to forever
00:37:19 <kirillow> why?
00:37:33 <orzo> i don't trust forever not to give memory leaks in strange situations
00:37:49 <Lokathor> forever has special let expression magic to avoid that, if you look at the source
00:37:54 <orzo> meaning i suspect forever tickles a compiler bug
00:37:57 <Lokathor> ...but the let expression magic might not always work >_>
00:40:52 <systadmin> :t =>
00:40:55 <lambdabot> error: parse error on input ‘=>’
00:42:38 <Lokathor> systadmin, => is special type signature syntax that seperates the type class limitations on a type from the rest of the type signature
00:42:42 <Lokathor> :t fromIntegral
00:42:45 <lambdabot> (Num b, Integral a) => a -> b
00:43:11 <Lokathor> so here, Num b and Integral a are limits put on the type signature that follows the =>
00:44:55 <orzo> they're usually called constraints
00:45:10 <Lokathor> ah yes, that's the word I was thinking of
00:45:23 <systadmin> So Num b and Integral a aren't part of the type signature?
00:45:53 <orzo> they are part of the signature
00:46:54 <Lokathor> they are part of the signature, but they don't reprisent input and output types of a function, they reprisent limits on how a generic function can be turned into a concrete function
00:47:17 <Lokathor> you can't use fromIntegral on a String, because a String isn't in the "Integral" typeclass, so it doesn't satisfy "Integral a", for example
00:48:13 <Lokathor> compare with the "id" function
00:48:14 <Lokathor> :t id
00:48:17 <lambdabot> a -> a
00:48:39 <Lokathor> there's no constraint on the 'a', so you can pass in literally any type of value at all to the id function, and it will work
00:49:03 <systadmin> So if I do =>
00:49:17 <systadmin> There are certain types of values that can't be used?
00:49:54 <Lokathor> yes, the part before the => specifies the type classes that work for the generic types after the =>
00:50:24 <Lokathor> ghc will generally infer the most generic type possible for things that you write, but you can specity a more specific type if you want and it will use that instead
00:50:36 <orzo> this is a good way to think of it in the beginning, but it's not technically right.  For example, Typable t => doesn't put any constraint on t
00:51:24 <orzo> your actually declaring that you are using some propery of the type
00:52:01 <systadmin> So (Num b,Integral a) can only use the type of value given to it? Which is Num and Integral
00:53:03 <Lokathor> systadmin, Num and Integral are type classes, so they're groups that a type can have an instance of or not. If a type has an instance of Num, then it can be used in a situation that calls for a "Num a" value
00:53:03 <orzo> no, Num is a collection of types, you can use any one of those to instantiate the type variable b
00:53:54 <kadoban> Examples of Num instances would be Int, Integer, Float, Double, etc.
00:57:47 <systadmin> So b and a can only use the type classes given to them?
00:57:53 <mrkgnao> why does this kind of thing not work?
00:58:02 <mrkgnao> > go :: ((b -> c), [(a, b)]) -> [(a, c)]
00:58:06 <lambdabot>  error:
00:58:06 <lambdabot>      • Variable not in scope: go :: (b1 -> c1, [(a1, b1)]) -> [(a1, c1)]
00:58:06 <lambdabot>      • Perhaps you meant one of these:
00:58:17 <mrkgnao> > go (func,pairs) = map (second func) pairs
00:58:19 <lambdabot>  <hint>:1:17: error:
00:58:20 <lambdabot>      parse error on input ‘=’
00:58:20 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:58:26 <mrkgnao> > go (func,pairs) = map (second func) pairs
00:58:28 <lambdabot>  <hint>:1:17: error:
00:58:28 <lambdabot>      parse error on input ‘=’
00:58:28 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:58:30 <mrkgnao> > let go (func,pairs) = map (second func) pairs
00:58:33 <lambdabot>  <no location info>: error:
00:58:34 <lambdabot>      not an expression: ‘let go (func,pairs) = map (second func) pairs’
00:58:44 <mrkgnao> I am so ham-fingered
00:58:45 <kadoban> mrkgnao: lpaste.net please
00:59:15 <Lokathor> systadmin, the a and b values must be values of a type that has an instance of the typeclass specified
00:59:16 <mrkgnao> how do I define a function here? it's just that thing I need, lpaste would probably be overkill
00:59:35 <Lokathor> note that, for example, all Integral values are also Num values
00:59:45 <Lokathor> mrkgnao, nope, lpaste is just right for this :3
00:59:56 <mrkgnao> Lokathor: okay, sure
01:01:49 <kadoban> mrkgnao: For the record you can do @let with lambdabot
01:01:53 <MarcelineVQ> @let go :: ((b -> c), [(a, b)]) -> [(a, c)]; go (func,pairs) = map (second func) pairs
01:01:54 <lambdabot>  Defined.
01:01:56 <kadoban> It's a bit tricky to get right though
01:01:59 <systadmin> So Num a must have an instance of the Num typeclass?
01:02:42 <Lokathor> systadmin, yes, whatever type becomes the "a" has to have an instance of the Num typeclass, or GHC will reject it
01:02:59 <systadmin> Oh, okay. TIL
01:05:23 <mrkgnao> kadoban: http://lpaste.net/5692610178797535232
01:05:42 <systadmin> So in (Num b, Integral a) => a -> b
01:05:55 <mrkgnao> now obviously that list can't be constructed because it doesn't have a proper type (unless you use Either for the second element of the pairs)
01:06:02 <Wojciech_K> Why `type fn = Int -> Int` gives error 'Malformed head of type or class declaration'?
01:06:16 <systadmin> a and b in `a -> b' should use the type class it is given?
01:06:21 <mrkgnao> Wojciech_K: type names must be capitalized
01:06:27 <Wojciech_K> ahh, right
01:06:29 <Wojciech_K> thx
01:06:35 <mrkgnao> @let type Fn = Int -> Int;
01:06:37 <lambdabot>  Defined.
01:07:02 <Lokathor> systadmin, yes, exactly
01:07:16 <systadmin> Which is what `=>` does?
01:07:58 <mrkgnao> but shouldn't there be ... some ... way to do it? with something like [forall a. a] (although this looks like a spectacularly bad idea because, well, this gives you heterogenous lists)
01:08:12 <orzo> ghc could probably do better than "malformed head" for a lowercased type name
01:08:51 <mrkgnao> I am ending up with a homogeneous list in the end, though. Can this be done without impredicative polymorphism, whatever that is?
01:08:58 <Wizek_> @pl @pl (\x -> x & _1 .~ x^._2)
01:08:58 <lambdabot> (line 1, column 1):
01:08:58 <lambdabot> unexpected "@"
01:08:58 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
01:09:16 <Lokathor> systadmin, yes, the => is just a different kind of arrow because the normal -> arrow means something else
01:09:27 <Wizek_> @pl (\x -> x & _1 .~ x^._2)
01:09:27 <lambdabot> (line 1, column 12):
01:09:27 <lambdabot> unexpected "_"
01:09:27 <lambdabot> expecting space or simple term
01:10:27 <mrkgnao> kadoban: Lokathor: I fixed an error in the lpaste. Mind looking at it?
01:10:35 <mrkgnao> okay, that came off wrong
01:11:13 <kadoban> I don't personally know a way to do that
01:11:54 <Lokathor> mrkgnao, if you don't know what signature you want, you can usually try leaving a signature off of xs entirely, getting a thing that loads into ghci, and then just using :t on it
01:12:20 <kadoban> Except that's not exactly going to help here, is it?
01:12:26 <mrkgnao> Lokathor: I *know* that xs can't be constructed in the obvious way.
01:13:11 <Lokathor> yes, it's quite an odd value for sure
01:13:32 <mrkgnao> I was just trying to refactor a bunch of a = map a1 a2; b = map b1 b2; bindings when I ran into this problem. 
01:13:43 <mrkgnao> (Although one entirely of my construction, for sure.)
01:14:08 <mrkgnao> can impredicative polymorphism allow you to construct something like [2,"a"] :: [forall a. a]?
01:14:20 <mrkgnao> @let xs :: [forall a. a];
01:14:20 <lambdabot>  Parse failed: Parse error: ]
01:14:31 <mrkgnao> @let xs :: [a];
01:14:33 <lambdabot>  .L.hs:162:1: error:
01:14:33 <lambdabot>      The type signature for ‘xs’ lacks an accompanying binding
01:15:46 <mrkgnao> I like how trying stupid things in Haskell is a ticket down $TYPE_THEORY_RABBIT_HOLE. :)
01:22:11 <orzo> mrkgnao: i think i have what you're looking for
01:23:10 <systadmin> I wanna code a combinations calculator
01:23:16 <orzo> mrkgnao: http://lpaste.net/5692610178797535232
01:23:35 <Lokathor> systadmin, what do you mean "combinations"?
01:23:52 <systadmin> Lokathor: it's a math thing
01:24:28 <systadmin> n! / ((n - r)! * r!)
01:29:32 <Omnic> whenever i hear the term "ADTs" that security company comes to mind
01:29:36 <Omnic> ok tahts all
01:29:56 <orzo> what would you prefer i call them
01:30:10 <orzo> never liked the name either
01:30:13 <MarcelineVQ> Aflacs
01:30:17 <orzo> heh
01:30:41 <Omnic> i don't really mind the name, just every time that's the first thing i think haha
01:30:52 <Omnic> probably b/c my grandparents had an adt alarm system
01:30:53 <Omnic> anyways
01:31:04 <orzo> i usually say "data structures" if i'm speaking outloud
01:31:32 <orzo> abstract seems a silly modifier
01:32:06 <systadmin> What's everyone up to?
01:32:25 <MarcelineVQ> the a is for algebraic
01:32:43 <orzo> oh, well okay
01:33:08 <MarcelineVQ> in our case because they define sums and products of types
01:33:53 <systadmin> How can I write a function that repeats a given string exactly n times?
01:34:03 <orzo> replicate n "given string"
01:34:30 <cocreature> systadmin: do you want to implement the function itself or are you ok just using a library function?
01:34:34 <MarcelineVQ> usually recursion with a value that ticks down each recurse that tracks what step you're on
01:34:36 <cocreature> in the latter case orzo has given you the solution
01:34:49 <systadmin> cocreature: whicher is easier 
01:35:00 <cocreature> systadmin: then just use replicate :)
01:35:07 <orzo> we have such a tiny prelude
01:35:19 <systadmin> How can I set replicate to keep repeating the string for a given number of times?
01:35:27 <cocreature> :t replicate
01:35:28 <orzo> if people aren't memorizing it anyway, i vote we expand
01:35:29 <lambdabot> Int -> a -> [a]
01:35:36 <cocreature> the first argument is the number of repetitions
01:35:42 <cocreature> > replicate 3 "meh"
01:35:45 <lambdabot>  ["meh","meh","meh"]
01:36:00 <cocreature> if you want a single string you can combine that with concat
01:36:01 <systadmin> I'm just trying to solve this Kata https://www.codewars.com/kata/57a0e5c372292dd76d000d7e/train/haskell
01:36:06 <cocreature> > concat (replicate 3 "meh")
01:36:09 <lambdabot>  "mehmehmeh"
01:37:01 <MarcelineVQ> that looks an awwwful lot like an exercise designed to make you think of and write a solution yourself instead of just inserting a library function :>
01:37:27 <orzo> naw
01:37:35 <orzo> he just has to adapt the library functions
01:37:44 <orzo> theres none of exactly the right type
01:37:47 <cocreature> if in doubt, just do it both ways :)
01:37:53 <orzo> :t replicate
01:37:56 <lambdabot> Int -> a -> [a]
01:38:10 <orzo> he needs (Int,String) -> String
01:38:44 <orzo> concat might prove useful
01:39:18 <systadmin> Should I remove the "" in: repeatStr n str = ""?
01:41:13 <orzo> well, your first case is repeat n "" = "". After that, you just need to write a case to match all possible strings
01:41:28 <orzo> i mean, one case for each string
01:41:31 <orzo> :D
01:41:41 <orzo> it's a long program
01:41:44 <cocreature> orzo: I don’t think it really wants you to have that type. it looks like the question is just the same for all languages
01:43:42 <orzo> repeatStr n s = [1..n] >> s
01:43:46 <orzo> heh
01:46:05 <systadmin> orzo should I change anything in the lines of codes above it?
01:46:29 <orzo> i dont really know what you're asking me
01:46:56 <systadmin> Nevermind
01:47:04 <systadmin> How did repeatStr n s = [1..n] >> s work?
01:47:24 <orzo> it works because list is a Monad
01:47:42 <systadmin> A Monad...
01:48:03 <orzo> the (>>) operator for a list means to repeat every instance of the second list for each member of the first
01:48:05 <systadmin> I'm still far from the chapter with Monads in the book I'm reading
01:48:10 <reactormonk> uri-bytestring must match >=0.2 && <0.3, but the stack configuration has no specified version (latest applicable is 0.2.2.1) -- should work, what am I misunderstanding?
01:48:49 <cocreature> systadmin: it might make sense for you to try to solve the exercises yourself or read some introduction to haskell if you are not yet able to write it yourself.
01:48:54 <orzo> yeah, [1..n] >> s wasn't even what i came up with initially
01:49:08 <Lokathor> systadmin, unfortunately for the beginner, many parts of Haskell that make it easy to use once you know all the basics are also what make it hard to use before you know all the basics
01:49:11 <orzo> it's what i came up with after being bored with my first idea
01:49:54 <cocreature> systadmin: think about how you would solve this problem on an abstract level and then try to translate that into haskell
01:49:55 <reactormonk> ahh, oops. stack config, not cabal. Gotta read the error messages.
01:50:12 <cocreature> reactormonk: you need to add it to extra-deps
01:50:22 <reactormonk> cocreature, yeah, gotta read the error messages.
01:50:24 <cocreature> reactormonk: that message means that the package is on hackage but not in the stackage snapshot
01:50:26 <orzo> systadmin: i recommend you ignore the >> solution and find something that makes sense with what you know and have covered so far.
01:50:36 <cocreature> reactormonk: tbh the error message is pretty confusing
01:50:48 <MarcelineVQ> odd, what lts are you using? uri-bytestring has been on stackage for awhile
01:51:01 <reactormonk> cocreature, no. "Recommended action: try adding the following to your extra-deps in stack.yaml: uri-bytestring-0.2.2.1"
01:51:14 <reactormonk> MarcelineVQ, some old nightly
01:51:19 <reactormonk> nightly-2016-09-24
01:51:36 <cocreature> reactormonk: I still think it’s confusing because “latest applicable” makes it seem like it should work
01:54:10 <reactormonk> Huh. lts-7.18 still uses aeson 0.x instead of 1.x
01:56:06 <reactormonk> How do you request an upgrade?
02:00:26 <systadmin> Is LYAH a good book?
02:00:45 <cocreature> systadmin: the opinions vary but I liked it
02:02:37 <maredebianum> How can I upgrade package pandoc to latest version? here is what I tried: http://lpaste.net/3280977104266592256
02:03:11 <seequ_> Learn You A Haskell is great if you have no functional programming background
02:03:33 <Lokathor> seequ_, i would dispute that
02:03:35 <t0by> seequ_: I sorta disagree.
02:03:44 <t0by> I find that's precisely the case where you don't want LYAH
02:03:51 <Lokathor> LYAH lets you kinda read haskell, but you'll probably not be equipped to write haskell at all by the end
02:04:36 <Lokathor> systadmin, http://www.seas.upenn.edu/~cis194/spring13/lectures.html try here for some good companion practice to go along with LYAH
02:04:45 <Axman6> maredebianum: it's probably because you have versions of dependencies which conflict with the versions needed by 1.19 already installed
02:04:54 <seequ_> Huh. I precisely found it useful because it taught me the basic concepts
02:05:09 <systadmin> I'm reading Haskell Programming but I was wondering if people liked LYAH
02:05:40 <systadmin> Lokathor: CIS194 is also written by the author of Haskell Programming
02:06:16 <Lokathor> systadmin, no, they just suggest CIS194. the book and the course are different people
02:06:18 <Axman6> is it?
02:06:24 <Axman6> thought so
02:06:26 <systadmin> Oh
02:06:42 <Lokathor> systadmin, Haskell Programming is an A++ book
02:06:42 <systadmin> Maybe I do CIS194 alongside HB
02:07:23 <Lokathor> Haskell Programming + Parallel and Concurrent Programming in Haskell will have you set to begin any number of Haskell projects
02:07:51 <Lokathor> (http://chimera.labs.oreilly.com/books/1230000000929/index.html for the latter book, but it's only suitable once you've finished Haskell Programming)
02:08:47 <systadmin> I've mostly been learning Haskell expressions by relating them to Python expressions
02:09:20 <Lokathor> I would try to consider Haskell expressions in their own right when possible, as you go along
02:09:22 <systadmin> This is the book I'm reading http://haskellbook.com/
02:09:29 <Lokathor> eventually it will all jel togtether
02:09:46 <Lokathor> yep, it's a top tier book
02:09:58 <maredebianum> Axman6: how can I resolve these, is there no upgrade concept? I remember this was difficult before, too. Do I need to wipe ~/.cabal and hope for a recompile? I updated the paste, it seems the base package is the problem here. Do I need to sove all dependencies by hand?
02:10:10 <systadmin> tbh, I torrented that book
02:10:23 <Lokathor> !
02:10:32 <systadmin> Because a lot of people recommend it above all the others
02:10:39 <Lokathor> go pay them, it's worth the price
02:10:57 <systadmin> Yeah,the version of the eBook I got is slightly out of date
02:11:11 <systadmin> I'm missing the last 2 chapters
02:14:15 <samvher> Hi, quick question: if I see a type declaration under class ... where, this is enabled by some language extension right? Which extension would that be?
02:14:55 <samvher> I'm looking at Web.Spock.Internal.Types - it has "class HasSpock m where\n type SpockConn m :: *", I don't entirely understand what's going on there
02:16:18 <cocreature> samvher: it’s part of TypeFamilies
02:16:18 <MarcelineVQ> it's related to type families samvher: https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html
02:16:40 <cocreature> it’s called “associated type”
02:16:44 <samvher> thanks! I'll check that out
02:19:37 <maredebianum> How can I force a cabal install? It may break any packages but the one I need and its dependencies ;)
02:20:05 <maredebianum> cabal list 
02:23:38 <systadmin> You're using cabal?
02:23:52 <systadmin> maerwald ^^^
02:23:57 <systadmin> maredebianum: 
02:25:00 <cocreature> maredebianum: "base" is tied to GHC so the only way to upgrade base is to upgrade GHC
02:25:19 <cocreature> maredebianum: it looks like pandoc requires baes >= 4.7 which is equivalent to GHC >= 7.10
02:25:23 <cocreature> eh 7.8
02:25:35 <systadmin> I recommend Stack over Cabal
02:26:26 <Lokathor> as do i, but that still wouldn't solve the version issue with base :P
02:28:05 <systadmin> https://docs.haskellstack.org/en/stable/install_and_upgrade/#installupgrade
02:28:11 <maredebianum> systadmin: I typed this cabal command in wrong window ;) I just moved ~/.cabal away, my system package provides ghc 7.6.3 only, can I compile it with cabal? I see Default available version: [ Not available from any configured repository ]
02:28:48 <maredebianum> systadmin: ah, thanks, will try that now
02:29:00 <systadmin> Stack is just easier
02:29:06 <systadmin> Takes care of GHC updates
02:29:39 <cocreature> maredebianum: what system are you on that provides ghc 7.6? that’s quite old so it might be worth upgrading or at least adding some repository that provides newer versions
02:29:58 <systadmin> The current version is 8.0.1 right?
02:30:06 <cocreature> 8.0.2
02:30:10 <systadmin> wat
02:30:25 <maredebianum> systadmin: thanks, unfortunately system packages are quite old, Ubuntu 14.04 LTS here
02:30:29 <Lokathor> 8.0.2 isn't in an LTS yet though
02:30:42 <cocreature> maredebianum: https://launchpad.net/~hvr/+archive/ubuntu/ghc
02:30:43 <systadmin> My version is 8.0.1
02:31:02 <Lokathor> maredebianum, you can just install stack without using the package manager and it can get GHC itself without using the package manager.
02:31:17 <Lokathor> unless you're picky about the package manager always being in charge of all things
02:34:51 <maredebianum> ppa is usually fine, if you find a maintained one (automated upgrades: yes please ;) I go with that first, then with newest ghc/base everything missing should compile. 
02:40:50 <systadmin> What does Haskell have in place of Python's input()?
02:41:07 <mrkgnao> systadmin: readLine and read
02:41:14 <mrkgnao> > :t readLine
02:41:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:41:21 <mrkgnao> :t readLine
02:41:23 <lambdabot> error:
02:41:23 <lambdabot>     • Variable not in scope: readLine
02:41:23 <lambdabot>     • Perhaps you meant one of these:
02:41:30 <mrkgnao> oh, sorry
02:41:35 <mrkgnao> :t getLine
02:41:36 <systadmin> :t (readLine)
02:41:37 <lambdabot> IO String
02:41:38 <lambdabot> error:
02:41:38 <lambdabot>     • Variable not in scope: readLine
02:41:38 <lambdabot>     • Perhaps you meant one of these:
02:41:47 <mrkgnao> getLine is what you want
02:41:51 <systadmin> So it's getLine?
02:42:16 <mrkgnao> yes. and you can use read to parse ints and such out of strings
02:42:18 <systadmin> let something = getLine
02:42:23 <systadmin> Something like that?
02:42:52 <mrkgnao> no, it's an IO action, so you want to use do-notation or similar things.
02:43:11 <systadmin> :t do
02:43:12 <lambdabot> error: Empty 'do' block
02:43:26 <mrkgnao> main = do s <- getLine; putStrLn ("You entered " ++ s)
02:44:29 <systadmin> What does `do` do?
02:45:21 <mrkgnao> it's a nice notation for monads, that's all. you can just use (>>=) (the "bind" operator) if you like.
02:45:37 <mrkgnao> I recommend reading a tutorial on doing IO in Haskell, though.
02:45:56 <mrkgnao> anyway, with the string in hand, you can use `read`.
02:46:08 <mrkgnao> > (read "70") :: Int
02:46:11 <lambdabot>  70
03:07:05 <miladz89_> I have a probelm with haskell automated testing, full question here on stackoverflow : http://stackoverflow.com/questions/41920181/haskell-automated-test-configuration
03:07:47 <miladz89_> basically the problem is that I want to automatically changed some configuration when I am testing.
03:08:47 <miladz89_> for example I want the string ' mongoHostAdress = "192.168.0.1" ' to change to mongoHostAdress = "127.0.0.1" when I am testing
03:46:53 <reactormonk> I've got a bunch of executables here in my .cabal file - any way to dedup build-depends?
04:01:30 <ph88> if i use list in a type i can just use  [ ]   but what about a non-empty list ?
04:02:08 <ph88> by the way, is the non-empty list a form of dependent type ?
04:02:55 <reactormonk> quick hackage search reveals https://hackage.haskell.org/package/semigroups
04:03:09 <reactormonk> There's probably a few more
04:04:21 <reactormonk> From what I understand, I can't have a type that's one constructor only? aka https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html#t:URIRef but I'd only allow RelativeRef?
04:04:39 <cocreature> ph88: you should use '[element0, element1]. ' is not always required (that’s why you can write [] instead of '[]) but modern GHCs warn if you don’t use it
04:06:04 <skeuomorf> Is there a haskell cheat sheet? Kinda like https://www.conj.io for Clojure
04:06:25 <ph88> cocreature, eh i don't really understand the syntax you are describing here. So i use a single quote before [ and after ] a dot and a space and a single quote ?    but then later you say after ] parenthesis close ?
04:07:55 <cocreature> ph88: [], is kind of special. if you have a data constructor called "Constructor" "'Constructor" is the promoted version at the type level. [] is builtin syntax , in that case you put ' before the first opening bracket, i.e., "'[]", "'[elements]"
04:08:35 <reactormonk> cocreature, isn't that a typelevel list?
04:08:43 <cocreature> sometimes you can get away without putting ' before promoted names but that only gets confusing
04:08:45 <cocreature> reactormonk: yes
04:09:06 <cocreature> maybe I missunderstood ph88 
04:10:03 <cocreature> ph88: are you talking about nonempty lists of values or nonempty typelevel lists?
04:10:18 <ph88> i don't know what you mean by promoted version of constructor, i was refering to https://hackage.haskell.org/package/semigroups-0.16/docs/Data-List-NonEmpty.html
04:10:26 <cocreature> ph88: oh sorry
04:10:33 <cocreature> ph88: in that case you just use "NonEmpty"
04:10:34 <ph88> i want to put values, but i still have to put it in my type
04:10:51 <ph88> oh ok, so no nice [] syntax anymore :(
04:10:57 <cocreature> yep
04:11:00 <ph88> is NonEmpty a form of dependent type ?
04:11:06 <cocreature> no
04:11:18 <cocreature> it’s just a regular data constructor
04:11:25 <ph88> but it depends on the value no ?
04:11:30 <cocreature> data NonEmpty a = a :| [a]
04:11:57 <cocreature> ph88: the type does not depend on the in the list
04:12:26 <cocreature> *the values
04:12:33 <cocreature> or the number of values in the list
04:13:01 <ph88> i thought it does bcz it has to have at least 1 value of that type ..
04:13:25 <Gurkenglas> Which of these IntelliJ haskell plugins would you recommend? https://gyazo.com/3b7be505552de2bf98c38ecc2600ea60
04:13:39 <ph88> anyway i thought of using this instead of lists in case i want to save things which use combinator "some"
04:13:42 <cocreature> ph88: a dependent type would be one where the type would change depending on the number of elements. NonEmpty just doesn’t have a constructor that takes no elements
04:13:52 <ph88> oh ok
04:14:48 <cocreature> ph88: it’s not different from "data X = X Int" in that regard: you can only put a single Int in there but it’s definitely not a dependent type
04:16:39 <ph88> does anyone know of a tool that visualize all the haskell types of a file, and how one type depends on another type ?
04:22:37 <MarcelineVQ> no but there probably is one, some sort of UML library perhaps
04:33:16 <shiona> Is there a way to insert a cookie into wreq session?
04:34:42 <cocreature> shiona: it looks like there is a "cookies" lens
04:34:58 <shiona> cocreature: Where? I can see such a thing only for the options
04:35:09 <cocreature> shiona: oh right sorry
04:35:23 <shiona> no problem, I was cautiosly optimistic
04:36:08 <shiona> I have no idea who designed this web UI, but it uses javascript to create the session id on the login page
04:36:39 <shiona> so now I need to emulate it somehow, since the server itself will just not give me the seid
04:37:15 <cocreature> shiona: put wreq session should manage cookies automatically, why do you want to put one manually into a session?
04:37:59 <shiona> I have a http server that requires a seid-cookie to be sent on login request.
04:38:12 <cocreature> where does your browser get the seid-cookie from?
04:38:27 <shiona> using a browser, this seid-cookie is created in javascript on the landing page
04:39:40 <cocreature> ah ok, now I understood the problem
04:39:54 <cocreature> shiona: looks like you are just going to have to put the cookies in "Options" for each request
04:40:11 <shiona> :/
04:40:16 <shiona> ok. Thanks 
04:40:28 <cocreature> or use a different library depending on how much code you have written that depends on wreq
04:40:45 <shiona> I could go with some other library
04:41:00 <shiona> I haven't been able to get far, as I can't really log in
04:41:05 <systadmin> Does Haskell use operators like: !=, ==. <==, >==, etc?
04:41:33 <shiona> systadmin: I assume you are looking for /=, ==, <=, >= in order
04:41:45 <systadmin> yeah
04:42:12 <systadmin> Also what does Haskell have in place of if, elif, else statements 
04:42:24 <cocreature> systadmin: we do have "if" and "else" :)
04:42:40 <systadmin> I'm coming from Python so I'm looking for the Haskell counterparts of Python expressions/statements/etc
04:42:50 <systadmin> cocreature: so no elif?:(
04:43:12 <cocreature> systadmin: there is a MultiWayIf extension that is pretty much that
04:43:21 <cocreature> or you can use guards
04:43:22 <MarcelineVQ> guards tend to subsume elif
04:43:43 <systadmin> Are if and else statements used the same way
04:43:49 <systadmin> Like 
04:43:58 <shiona> It's a bit counterproductive to try to force haskell to work in your python mindset 
04:43:59 <systadmin> if: followed by another block of code, or column
04:44:01 <MarcelineVQ> else is a neccesary part of if,  if pred then one else two
04:44:39 <cocreature> yeah trying to find counterparts for python expressions is not a particularly good idea
04:44:44 <ph88> is there a version of Text that requires that there is at least one character ?  Kind of like  NonEmpty Char
04:44:48 <cocreature> there is not really a one-to-one correspondence
04:45:05 <cocreature> ph88: afaik no
04:45:09 <systadmin> So I shouldn't really try to learn the counterparts
04:45:13 <ph88> oki
04:45:17 <systadmin> I should learn Haskell normally like I should do?
04:46:03 <cocreature> systadmin: the problem is trying to translate individual expressions/statements. it’s better to find a problem, solve it in python and then find a solution in haskell and compare these two
04:46:26 <cocreature> the syntax & semantics of python & haskell are two different for translations based on individual statements
04:47:01 <systadmin> Okay, just one more Python to Haskell translation (I couldn't help it.). What does Haskell have in place of Python's input()?
04:47:25 <srhb> systadmin: It doesn't.
04:47:34 <systadmin> oh way
04:47:44 <srhb> There are various plugins approaches, but they're extremely dissimilar.
04:47:56 <srhb> (lambdabot uses hint, which is one of them, iirc)
04:48:16 <cocreature> srhb: input() is not eval(), right?
04:48:29 <srhb> cocreature: It's getLine >>= execute, iirc
04:48:35 <srhb> Or something like that :-P
04:48:45 <cocreature> srhb: I think it’s just getLine
04:48:48 <cocreature> without the execute part
04:48:49 <srhb> Oh, is it.
04:49:05 <cocreature> systadmin: so the answer is “getLine”
04:49:33 <systadmin> :t getLine
04:49:35 <lambdabot> IO String
04:49:46 <srhb> cocreature: >>> input(); 1+1; 2
04:49:53 <ahihi> python 3 input() scrapped the evaluation part
04:50:00 <srhb> Aha, hence the confusion.
04:50:27 <cocreature> sure just change the semantics of a function completely but keep the name …
04:50:31 <srhb> :-)
04:50:38 <srhb> It's backwards compatible!
04:52:02 <cocreature> systadmin: so "getLine" is python 3’s input(), emulating python 2’s input() is more complex
04:52:23 <systadmin> In Python2 it's raw_input()
04:53:31 <chattered> There's an idiom in SML where, as you map over a data-structure, you check at each level whether what you got back is pointer identical to what you started with, and if so, you just return the original. In this way, map id doesn't have to do any allocation. Does Haskell have any story on this?
04:58:13 <systadmin> I need to add `do` to my getLine function?
05:01:21 <srhb> systadmin: That's not how `do` works.
05:01:53 <systadmin> ?
05:01:59 <srhb> `do foo` is equivalent to `foo`. always.
05:08:01 <srhb> systadmin: Perhaps if you rephrase the question in a more general manner: What are you trying to achieve?
05:16:18 <Malleus> I'm a C# dev looking into functional programming. Can i build Websites using Haskell as well as Text based games such as MUDs? What I'm really asking is what is it good for
05:21:06 <megaTherion> Malleus: you know LINQ?
05:22:48 <malleus99> yeah linq is awesome
05:23:01 <megaTherion> then this is basically functional programming
05:23:24 <megaTherion> however since you're a C# dev already, I might suggest looking into F# first - because then you'll work with an familiar eco system at hand
05:25:13 <malleus99> ah yeah i forgot about F# sharp. I'll have a look at that too
05:25:24 <epta> megaTherion: how come that LINQ is a functional programming?
05:25:51 <epta> isn't it just a bunch of Data.List routines over lazy lists?
05:26:47 <hpc> higher-order functions over lazy lists, is how i would put it
05:27:10 <hpc> or some other type of stream, like an sql query (where stepping through the result set is an IO effect)
05:27:17 <megaTherion> epta: ok one part of it ^^
05:27:35 <hpc> it's a bit like a special form of do-notation
05:29:09 <hpc> malleus99: the way i would break it down is learn F# if you want to carry over as much of your existing knowledge as possible, learn haskell if you want to literally never stop learning new things :D
05:30:42 <epta> LINQ example is horrible because of it's implementation. They did a separate instance of IEnumerable/IEnumerator for each and every function. It doesn't have anything in common with abstract implementation of correspondent methods in Data.List
05:30:55 <epta> So it's not really high order as you said
05:31:52 <malleus99> I love learning new things and the different syntax and the complexity at 1st sight is drawing me to it. just wondering what i can do it with that might benefit me career wise. I guess could be a fun hobby language maybe
05:32:18 <epta> > Can i build Websites using Haskell as well as Text based games such as MUDs < yes, but it will take 10x more time because of a different paradigm 
05:32:20 <lambdabot>  <hint>:1:82: error: parse error on input ‘,’
05:33:15 <epta> malleus99: perfect choise as a hobby language indeed 
05:34:46 <malleus99> some of the jobs pay well too but seem quite scientific or involve a lot of math knowledge from what I've seen
05:35:46 <hpc> the way i would put it is you will learn about new concepts well before they become mainstream (which most of them inevitably do)
05:36:16 <hpc> a couple of weeks ago i had that with parser combinators
05:37:21 <hpc> at work i found a domain-specific library that we could use for some specific stuff, and it happened to expose an API that worked a lot like trifecta
05:37:38 <hpc> it's pretty flawed in a lot of ways, but it uses the same parser for parsing and pretty-printing
05:40:11 <hpc> (or you learn them more generally, like transactions via STM)
05:45:14 <ph88> hhmm 4K loc causing some serious compilation times :P
05:46:52 <ph88> since NonEmpty implement Functor does that mean i can use the  some  and  many  combinators on it ?
05:47:30 <epta> what does 'stack install' do? Does it install a package user-wise or does it make it available for a specific project environment only?
05:48:35 <ph88> epta, it downloads and installs the package to a cache, and then if your project needs this package it will use that exact one form the cache
05:48:58 <ph88> so that you don't have to download the exact same package for different projects
05:50:57 <epta> ph88: I mean, if some excutable is installed via 'stack install', is it presented in $PATH for every shell session?
05:51:40 <MarcelineVQ> only if .local/bin is on your path since that's where stack install places installed binaries
05:52:02 <ph88> and only when you are not a project directory (so you use the global project)
05:53:10 <MarcelineVQ> stack install will place executables in ~/.local/bin if you're in a project directory too
05:53:30 <ph88> oh ok ^^
05:53:55 <ph88> wow ghc is mega slow now
05:54:16 <ph88> 15minutes for 4K loc is that normal ?
05:55:54 <ertes> ph88: that's a bit much, but of course it depends on what you have in those 4K
05:56:04 <MarcelineVQ> dunno, never had 4k loc, but given that ghc itself only takes me at most 20 minutes to build, probably not. are you building with -O2 ?
05:56:20 <ph88> no, i'm just doing reload in ghci
05:56:32 <ertes> ph88: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/sooner.html
05:56:45 <ph88> hi ertes 
05:56:55 <MarcelineVQ> I see, is this 4k in one file? consider splitting it up so that it can choose not to rebuild things that don't change
05:56:57 <ertes> helo =)
05:58:44 <ertes> in the case of GHCi splitting by itself shouldn't even help (it always reloads all modules that aren't compiled), but it does help, because GHC can generally cope better with smaller modules
05:58:54 <Tuplanolla> If you have several modules, try `-fobject-code`, which is not mentioned there in the user guide, ph88.
05:59:14 <ertes> also beware of the many caveats of -fobject-code =)
06:00:27 <ph88> well htop shows ghci is taking only 28% of my memory .. so it would be ok to use some more
06:02:56 <systadmin> hi
06:03:44 <ph88> hi systadmin 
06:05:13 <ertes> ph88: you can use 'some' and 'many' on any Alternative functor, not on any Functor
06:06:01 <ertes> > many (pure 'a') :: NonEmpty Char
06:06:04 <lambdabot>  error:
06:06:04 <lambdabot>      • Expected a type, but ‘'NonEmpty Char’ has kind ‘NonEmptyList a0’
06:06:04 <lambdabot>      • In an expression type signature: NonEmpty Char
06:06:38 <ertes> @let import qualified Data.List.NonEmpty as Ln
06:06:40 <lambdabot>  Defined.
06:06:44 <ertes> > many (pure 'a') :: Ln.NonEmpty Char
06:06:46 <lambdabot>  error:
06:06:47 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
06:06:47 <lambdabot>        Expected type: Ln.NonEmpty Char
06:07:00 <ertes> > many (pure 'a') :: Ln.NonEmpty [Char]
06:07:02 <lambdabot>  error:
06:07:02 <lambdabot>      • No instance for (Alternative Ln.NonEmpty)
06:07:02 <lambdabot>          arising from a use of ‘many’
06:07:08 <ertes> oh, of course
06:07:11 <ph88> many on NonEmpty doesn't make sense actually :/
06:07:21 <ph88> i see NonEmpty has a function some1 that will be good enough
06:07:40 <ertes> i would expect it to cycle anyway
06:07:48 <ertes> > many "a"
06:07:54 <lambdabot>  mueval-core: Time limit exceeded
06:07:57 <ph88> :P
06:07:57 <ertes> or loop, i guess
06:08:16 <ertes> > head (some "a")
06:08:20 <ph88> i think i will move the source code from my laptop to my pc
06:08:22 <lambdabot>  mueval-core: Time limit exceeded
06:08:42 <ph88> this makes me want to buy one of those new intel processors :/
06:08:51 <ph88> i7 7700k or w/e
06:09:17 <ertes> ph88: splitting your module will be more effective
06:09:28 <ph88> i like to contain the grammar into one file
06:16:15 <excelsiora> so how do you print the compiler info?
06:17:44 <excelsiora> import qualified Distribution.Compiler as DC
06:18:26 <excelsiora> print DC.CompilerInfo
06:19:04 <excelsiora> no instance - so this is the type I want, but I want to get the instance for the GHCI session or program.
06:19:11 <int-e> excelsiora: is any of that missing from ghc --info?
06:20:04 <excelsiora> I don't know. I just want to print it from ghci.
06:22:16 <ph88> if i want to make a project with several parts (modules i guess) is it useful to put them in separate git repo's as well ?
06:22:33 <ph88> basically i want to make a command line utility that is an front-end for several functionality
06:26:20 <excelsiora> I presume ghci and any given compiler knows its own name and version, correct?
06:26:32 <excelsiora> How do I print this?
06:27:04 <excelsiora> in Python, it's import sys; print(sys.version)
06:27:35 <Theophane> excelsiora: wait a sec
06:29:08 <Tuplanolla> Is there `:show version`?
06:29:28 <Theophane> Tuplanolla: System.Info.compilerVersion
06:29:36 <Theophane> (import System.Info first)
06:37:41 <excelsiora> Theophane: thanks that gets me closer
06:38:06 <Theophane> you've also got System.Info.compilerName
06:38:18 <Theophane> and you're welcome :)
06:43:03 <excelsiora> Theophane: how do I get the compilerVersion into a nice human readable string
06:43:20 <excelsiora> I'm trying to do: print(arch ++ os ++ compilerName ++ compilerVersion)
06:43:37 <excelsiora> (is this style ok?)
06:43:41 <Theophane> excelsiora: :doc showVersion
06:43:43 <Theophane> ;)
06:44:19 <excelsiora> unknown command :doc
06:46:10 <excelsiora> got it
06:47:06 <excelsiora> ok, now I need to learn string formatting. printf the way to do it?
06:47:14 <epta> are there any resharper analogues for haskell besides stylish-haskell?
06:47:44 <Theophane> epta: I use stylish-haskell, but perhaps you could try hlint
06:48:11 <epta> Theophane: anything else?
06:48:37 <Theophane> epta: idk \o/
06:50:33 <excelsiora> Theophane: thanks again, by the way
06:50:43 <Theophane> you're welcome :)
06:59:54 <excelsiora> so... printf?
07:01:14 <ertes> excelsiora: it's certainly the most accessible in terms of availability (it's in base)
07:01:53 <ertes> excelsiora: but i think it's safe to say that it's also the least favourite solution simply because haskell doesn't have the type system to support it properly
07:02:18 <ertes> excelsiora: printf "%s" (0 :: Integer)  -- not a type error…  will throw a run-time exception instead
07:03:02 <ertes> (at least it won't be a memory violation the way it would be in C)
07:03:58 <ertes> for number formatting see the Numeric module, which is also in base
07:04:53 <ertes> for general formatting you can very often use ShowS, but not a lot is predefined
07:05:28 <ertes> > (showString "A number: " . showHex 254 . showChar '!') ""
07:05:31 <lambdabot>  "A number: fe!"
07:05:51 <ertes> the functions from Numeric are all compatible with ShowS
07:07:51 <ertes> it doesn't quite replace printf, because stuff like padding is missing
07:20:32 <Tuplanolla> Is there a way to generalize or express this better? I have `view _1 xs /= view _2 xs` in a guard.
07:21:24 <kirillow> I want to load the contents of a file as a ByteString before compilation. How do I do that? 
07:21:37 <Tuplanolla> I feel like there ought to be some way to say `equal xs`.
07:28:12 <excelsiora> why are there so few examples in the haskell documentation?
07:30:58 <excelsiora> this entire page - not a single example: http://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Printf.html
07:31:26 <excelsiora> What's the thought process on that?
07:32:07 <kirillow> nvm
07:32:14 <excelsiora> "If we make examples, we'll attract programmers that learn by example instead of by reading the specifications, and that would be bad."
07:32:32 <ertes> excelsiora: probably: "i don't like to come up with examples right now", thought by every documentation writer so far…  care to become the first exception? =)
07:33:14 <kirillow> b-but there's an example on that page
07:33:31 <excelsiora> show me!
07:33:40 <kirillow> it's introduced with the words "for example:"
07:33:55 <ertes> hehe
07:34:19 <ertes> i don't know…  as haskell programmers we're often comfortable just looking at types
07:34:52 <excelsiora> > printf "%d\n" (23::Int)
07:34:55 <lambdabot>  error:
07:34:55 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M561607525422...
07:34:55 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:35:10 <ertes> > printf "%d\n" (23::Int) :: String
07:35:12 <lambdabot>  "23\n"
07:35:49 <excelsiora> I found actual examples in a collapsed text box.
07:36:26 <excelsiora> halfway through the doc page. Where it saves 6 lines. Not sure how users benefit from that.
07:37:37 <excelsiora> And as I just demonstrated, there's apparently an issue with the examples...
07:38:35 <excelsiora> > printf "%s %s\n" "Hello" "World"
07:38:38 <lambdabot>  error:
07:38:38 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M572878973673...
07:38:38 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:38:46 <excelsiora> > printf "%s %s\n" "Hello" "World" :: String
07:38:49 <lambdabot>  "Hello World\n"
07:38:52 <Tuplanolla> It's waiting for more arguments, excelsiora.
07:39:12 <ertes> the issue is: you must understand the basics of haskell's type system
07:39:22 <Tuplanolla> The type checker doesn't know what's inside the string.
07:39:41 <ertes> it's more like: the type checker doesn't know whether you want a String or an IO () in the end
07:39:51 <excelsiora> printf "%.2f\n" pi :: String
07:40:16 <Tuplanolla> :t printf "%s %s\n" "Hello" "World" :: String -> String
07:40:18 <lambdabot> String -> String
07:40:24 <excelsiora> Tuplanolla: these are examples directly from the documentation
07:40:33 <ertes> (printf "%d\n" 23)  -- this can be one of three things
07:40:55 <excelsiora> afk
07:41:01 <ertes> 1. a function that takes another argument to format (haskell's type system is not powerful enough to figure out that the format string does not specify any more)
07:41:06 <ertes> 2. a String
07:41:08 <ertes> 3. an IO ()
07:41:27 <roxxik> this is where looking at types stops being useful
07:41:35 <roxxik> so examples are needed
07:45:10 <ertes> there are more constructive ways to complain, especially in a community driven mostly by volunteers
07:45:51 <ertes> nobody here will disagree about the benefits of examples, but somebody has to do it
07:45:56 <Ferdirand> isn't printf evil anyway ?
07:46:20 <ertes> not really…  it doesn't have the same problems that printf in C has
07:46:40 <ertes> but it is dynamically typed, so i'd say it's ugly, not necessarily evil
07:46:51 <Ferdirand> fair enough
07:49:17 <lyxia> Write a statically typed printf with a quasiquote for the format string.
07:50:16 <ertes> printf (Proxy :: Proxy "%d\n") 23
07:50:22 <Ferdirand> that actually sounds like a nice exercise
07:51:55 <ertes> for this kind of application it would be nice to have a singleton type family for strings with automatic type inference from literals
07:52:05 <ertes> "abc" :: "abc"
07:52:09 <ertes> like this
07:53:52 <hpc> really though, it's printf
07:54:43 <hpc> pretty much all it needs to say is "works the same as in C" and you instantly know what it does
07:55:26 <ertes> i guess we can no longer assume that people are familiar with C, which…  is a good thing, i guess
07:55:27 <hpc> and as it turns out, the first sentence on the page is "A C printf(3)-like formatter."
07:56:02 <hpc> so i guess the examples you are looking for can be found at man 3 printf
08:00:14 <ertes> if we add padding and alignment stuff to ShowS and write better documentation for it, that might be a better option
08:01:56 <lpaste> kirillow pasted “WebSocket Warp Wai Problem” at http://lpaste.net/351767
08:02:05 <kirillow> Please help?
08:02:59 <ph88> why is stack package index so big ? it's like 200 mb o_O
08:03:53 <ertes> kirillow: sounds like something is timing out…  wrap your forever-action in an exception handler to see if any are thrown
08:04:49 <ertes> kirillow: forever c `onException` \(SomeException ex) -> print ex >> throw ex
08:04:59 <ertes> whoops
08:05:03 <ertes> kirillow: forever c `catch` \(SomeException ex) -> print ex >> throw ex
08:05:05 <ertes> like that
08:05:37 <kirillow> o_O
08:05:42 <kirillow> thanks!
08:05:44 <kirillow> will try
08:07:10 <dfeuer> Anyone here have some interesting lazy ST code?
08:07:28 <dfeuer> I want to test a substantial overhaul of the lazy ST implementation.
08:07:36 <dfeuer> Make sure I didn't break everything.
08:07:46 <ertes> dfeuer: make a lazy list of random numbers using mwc-random
08:08:43 <dfeuer> ertes: it's hard to work with proper *packages* in this context; too much stuff doesn't work with 8.1....
08:08:48 <dfeuer> I can attempt it.
08:08:55 <ertes> i see
08:09:01 <dfeuer> Thanks for the idea.
08:09:17 <dfeuer> I will steal it anyway.
08:09:18 <ertes> dfeuer: well, write an RC4 implementation to produce the stream
08:09:28 <ertes> naive RC4 is like 10 lines of code
08:09:40 <ertes> it uses a mutable array
08:09:50 <dfeuer> Betterer and betterer!
08:10:26 <dfeuer> ertes: how about uses of mfix with lazy ST?
08:10:58 <ertes> hmm…  i can't think of a proper example
08:11:06 <dfeuer> Yeah....
08:11:25 <ertes> you could shoehorn it in, i guess
08:12:27 <ertes> an STRef only starts existing when the action is actually run, right?
08:12:54 <ertes> ah, wait
08:14:58 <ertes> dfeuer: STRef is boxed, so you could probably force mfix in somehow to keep track of the two RC4 indices
08:15:33 <Tuplanolla> How about using a vector with the head reserved for indices?
08:15:59 <ertes> vector requires a package though
08:16:06 <Tuplanolla> Right...
08:16:34 <ertes> (the indices could just as easily be recursive arguments, but this is for testing)
08:16:44 <dfeuer> ertes: the trouble is really that I don't know all the ways these thing might interact, so coming up with small artificial test cases is better than nothing, but I'd *much* rather play with code that does lots of fancy shit already :/
08:17:17 <ph88> i noticed when i type   stack ghci  and it starts to build packages that it just launches 2 ghc processes, how can i launch 4 so that it uses all my cores ?
08:17:24 <ertes> dfeuer: i think, i can implement a very small Event-only FRP system that works exclusively in ST
08:17:29 <dfeuer> ertes: array doesn't require anything.
08:17:35 <ertes> dfeuer: then you can make heavy non-trivial use of mfix
08:17:41 <dfeuer> Lazy ST?
08:17:57 <hpc> ph88: the -j parameter
08:18:00 <ertes> you can use it in lazy ST in order to produce a stream
08:18:11 <dfeuer> I mostly want to make sure I haven't broken any laziness.
08:18:12 <hpc> (same as make and other stuff)
08:18:31 <ertes> yeah, that should be testable
08:18:35 <dfeuer> Wooooo.
08:18:55 <Athas> Hov does Haskell manage to avoid making 'as' a reserved word?
08:19:08 <hpc> Athas: it only occurs in import syntax
08:19:12 <Tuplanolla> Context-sensitive tokenization, Athas.
08:19:19 <Athas> Ugh.
08:19:34 <ertes> dfeuer: shall i?
08:19:52 <kirillow> "Thread killed by Warp's timeout reaper" well that sucks
08:19:53 <Athas> I actually thought you couldn't do that with Alex.  I'll have to check that out.
08:19:58 <dfeuer> BTW, ertes, the differential is at https://phabricator.haskell.org/D3038. If you want to compile that with 8.0, you'll have to change the definition of runST to unsafeCoerce# runRW#.
08:20:16 <dfeuer> ertes: well, if you think you can do that *easily*, then yes, I'd very much appreciate it!
08:20:37 <glguy> Athas: It doesn't have to modify Alex to support that
08:20:45 <glguy> It would be handled in the parser
08:20:49 <ertes> dfeuer: i'll implement it and leave integration to you =)
08:21:18 <dfeuer> ertes: wheeeeee. Do you think you could maybe also review that differential? Make sure none of my changes look insane?
08:22:02 <dfeuer> (and maybe even see if you think it likely actually fixes the bug?)
08:22:36 <glguy> Athas: https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y#L3256-L3274
08:23:25 <glguy> Athas: The grammar simply has cases in the production for identifiers that allows certain keywords to be used as identifiers
08:23:43 <Athas> glguy: I see.  I guess that's not too bad.  It's not really context-sensitive lexing.
08:23:56 <ertes> dfeuer: i'm not competent enough to see errors there that go beyond type errors =/
08:24:31 <ph88> hpc, do you know how i can set -j4 globally for whenever i use stack ?
08:25:00 <hpc> i don't
08:31:21 <dfeuer> ertes: if you do that trick with FRP or whatever, please just lambdabot message me or email. I have to run now. Thanks again!
08:35:51 <ertes> dfeuer: if you're still there: is STRef enough, or do i need to use arrays, too?
08:37:29 <ertes> so much for that =)
08:40:52 <g256> hi
08:42:42 <lambdabot> Hello.
08:44:20 <g256> @help
08:44:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:44:31 <g256> @list
08:44:31 <lambdabot> What module?  Try @listmodules for some ideas.
08:44:45 <g256> @listmodules
08:44:45 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
08:44:45 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
08:44:59 <g256> @activity
08:45:00 <lambdabot> 4*total 4*#haskell
08:45:33 <ph88_> ertes, i started ghc with -Rghc-timing to see how much GC is being done, now i get messages such as:   <<ghc: 17329232 bytes, 29 GCs, 782638/1564936 avg/max bytes residency (4 samples), 4M in use, 0.000 INIT (0.001 elapsed), 0.000 MUT (0.116 elapsed), 0.047 GC (0.036 elapsed) :ghc>>   do you know what the first few things tell me ?
08:46:41 <g256> @system
08:46:41 <lambdabot> Unknown command, try @list
08:47:00 <g256> @version
08:47:00 <lambdabot> lambdabot 5.1
08:47:01 <lambdabot> git clone https://github.com/lambdabot/lambdabot
08:47:10 <hpc> iirc, the first number is the sum of all allocations, and the next number/number is how much you ever ended up actually using at once
08:47:24 <ertes> ph88_: residency is heap usage (the amount of memory actually used at a point in time)
08:47:40 <ertes> the rest i could only guess, so better read the GHC manual on that
08:48:10 <g256> @dice
08:48:10 <lambdabot> unexpected end of input: expecting number, "d" or "("
08:48:18 <ertes> g256: you can use lambdabot in private
08:48:22 <ertes>  /query lambdabot 
08:48:29 <g256> oh sorry :)
08:48:35 <g256> will do :)
08:48:38 <ertes> no worries =)
08:49:52 <MarcelineVQ> ph88_, ertes: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
08:50:11 <g256> didn’t think that it’s visible for everybody :)) 
08:51:02 <ertes> g256: if you type the command i just gave you, then a new window/tab/whatever will pop up, and everything there is between you and lambdabot =)
08:51:22 <ertes> (and int-e and a few server operators, too)
08:52:04 <g256> ertes: cheers :)
08:55:01 <ph88_> ertes, thx :)
08:55:06 <ph88_> MarcelineVQ, ah excellent good find 
09:00:22 <soniaa> www.icq-net.eu chat for all people !!!
09:04:58 <ph88> when i have a top-level function that never gets called through main, will it be optimized away when i do a regular build (outside of ghci) ?
09:07:42 <kirillow> how do i ignore an exception and keep the programm running
09:10:18 <ertes> ph88: likely, unless you're building a library, although i'm not sure if the linker is very aggressive at eliminating dead code
09:10:23 <ertes> kirillow: catch it
09:10:49 <ertes> kirillow: but in that case you should only ignore certain exceptions
09:11:11 <ertes> kirillow: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:catchJust
09:12:19 <kirillow> ertes: but isnt that what your function did?
09:12:34 <kirillow> ertes: it still timed out?
09:13:24 <kirillow> i mean catching exceptions, not ignoring only specific ones
09:13:29 <ertes> kirillow: mine rethrows the exception…  it's only for seeing the exception…  my guess is that your websockets library has a catch-all handler that does nothing, but did you actually verify that something like a timeout is happening?
09:13:59 <ertes> kirillow: ignoring exceptions is highly risky
09:15:07 <kirillow> Uhm, sorry, I can't follow you. It said "Thread killed by Warp's timeout reaper" and I was inable to send more messages. Isn't that verified then?
09:17:08 <ertes> i don't know
09:17:27 <ertes> that sounds more like warp is killing your handler, because it didn't return for a long time
09:17:41 <ertes> not because there was a network timeout
09:20:22 <ertes> the way this seems to work is:  warp receives the request, the websockets middleware recognises it as a websockets request and calls your websockets handler…  while that one is running, warp waits for it to finish and kills it after a certain amount of time
09:21:11 <ertes> if that's the case, warp has no way of knowing whether the handler is just doing its work or is actually hanging…  i imagine that you're supposed to disable timeouts for websockets handlers
09:21:39 <kirillow> hm yes
09:21:58 <ertes> that timeout kill might actually be the reason why you get the behaviour you observed
09:25:42 <grdvnl`> :help
09:25:49 <grdvnl`> exit
09:48:26 <ph88_> ok i'm a bit surprised, i have a file about 4K lines with some comments in between, i run   time stack build --ghc-options '-O0 -j4 -Rghc-timing'   and my core i7 920  runs already an hour on this !!
09:49:16 <ph88_> using 8GB of memory, but i have 24GB so depending on the statistics i will set it to use more on next run
09:49:23 <ph88_> but this is the slowest compiler i ever saw o_O
09:52:47 <Tuplanolla> Sounds like a GHC bug, ph88.
09:53:18 <monochrom> 4k is on the unusually big side for a Haskell module. Not to say that I know how fast GHC is for this.
09:53:28 <MarcelineVQ> with that kind of memory use I'd also be suspect of extensions you may have enabled, some of the type-fu-checking can get exponential
09:54:18 <monochrom> Actually Haskell 2010 type inference is already exponential.
09:54:25 <MarcelineVQ> :>
09:54:56 <monochrom> In fact going all the way back to plain Milner-Robin, it is still exponential.
09:55:08 <ph88_> https://paste.fedoraproject.org/539939/85712480/  i use these extensions
09:55:30 <monochrom> Err, Hindley-Milner!
09:56:14 <Lokathor> ph88_, you name shadower!
09:56:41 <ph88_> oh oh
09:57:59 <MarcelineVQ> I'd be looking at that UndecidableInstances first of all
09:58:13 <ph88_> ye actually i think i left that in without reasons
10:00:35 <MarcelineVQ> type families can also blow up in some cases, idk which though: https://ghc.haskell.org/trac/ghc/ticket/8095
10:00:40 <ph88> oh it's there for a reason alright .. but perhaps there is another way to solve it
10:02:18 <xcmw> > (+) <$> [1,2,3] <*> [4,5,6]
10:02:19 <ph88> MarcelineVQ, if i dont' use UndecidableInstances i get a lot of these errors:  https://paste.fedoraproject.org/539950/14857128/
10:02:19 <MarcelineVQ> Before chasing too many rabbits though I'd suggest just breaking up your code into at least 3 or 4 modules instead of one 4k file
10:02:21 <lambdabot>  [5,6,7,6,7,8,7,8,9]
10:02:51 <xcmw> Why is it not [5,7,9]?
10:03:36 <hpc> xcmw: what you're looking for is ZipList
10:04:22 <monochrom> []'s <*> has to be consistent with >>= in doing cartesian product.
10:04:43 <xcmw> hpc: Thank you
10:06:57 <cocreature> ph88: doing some sort of binary search by removing half of your definitions/replacing them with undefined, can often help finding the problematic definition
10:07:07 <xcmw> Why doesn't ZipList work with do notation?
10:07:11 <ertes> xcmw: use zipWith
10:07:18 <hpc> because it can't satisfy the Monad laws
10:07:37 <ertes> even if it could, it would be horribly inefficient
10:07:49 <monochrom> ZipList fails to be a monad.
10:07:54 <ertes> xcmw: you can use do-notation with ZipList, if you enable -XApplicativeDo
10:09:38 <monochrom> Mathematics conspires to put you between a rock and a hard place.
10:09:40 <xcmw> Stupid question: Can't you just make (ZipList as) >>= f = ZipList $ as & map f & LI.imap (\index (ZipList element) -> element !! index)
10:10:05 <ertes> xcmw: that violates the monad laws and also explains why "it would be horribly inefficient" =)
10:10:31 <xcmw> ertes: Ok, Thanks
10:10:33 <hpc> xcmw: it's actually a good exercise to work out for yourself how it breaks the laws
10:11:05 <ertes> xcmw: there is a family of fixed-length zip-lists, each an individual monad (including the infinite one), and each with the same terrible (>>=) performance
10:11:54 <ertes> for example this one is a monad:  data V3 a = V3 a a a
10:12:09 <ertes> also V4, V5, V1000 and in the limit ZipStream
10:13:35 <xcmw> ertes: Ok
10:17:15 <Zemyla> I wish I could remember what my mind was like before and while I was getting good at Haskell.
10:18:43 <Zemyla> Like, how I went from "What's a monad?" to "I can build a monad, in a cave, with a box of scraps!"
10:19:54 <ph88_> cocreature, i commented like 99% of the code and i left this little snippet of code in  https://paste.fedoraproject.org/539980/13891148/  which causes the undecidable instance. Why is this happening ?
10:20:39 <ph88_> by the way, if i newtype ContextItem it also happens    newtype ContextItem = Foo String
10:23:19 <cocreature> ph88_: I was more thinking about commenting to find out which part causes GHC’s compile times to blow up. UndecidableInstances can cause problems but there are also valid usecases
10:24:04 <ph88_> ok i will try to comment with UndecidableInstances .. but actually i still like to get rid of UndecidableInstances !
10:24:07 <cocreature> ph88_: the problem is that to check if something satisfies Rule f DesignUnit, ghc has to check whether it satisfies Rule f ContextClause.
10:24:12 <cocreature> ph88_: but none of these terms is smaller
10:24:18 <cocreature> so there could be an infinite recursion
10:24:59 <ph88_> what something ?
10:25:22 <cocreature> ph88_: so let’s say you use "get" somewhere
10:25:45 <cocreature> GHC then has to satisfy some constraint because "get" is a class method
10:26:05 <cocreature> so to check whether the constraint is satisfied it has to check all instances
10:26:26 <ph88_> which constraint are you talking about ?
10:26:34 <cocreature> ph88_: basically the problem that you could write "instance Rule f ContextItem => Rule f ContextClause where" and "instance Rule f ContextClause => Rule f ContextItem where"
10:26:40 <cocreature> so then GHC would keep looping
10:26:55 <ph88_> o_O
10:27:02 <ertes> Zemyla: i miss the kind of epiphanies i used to have in the first year =)
10:27:22 <ertes> it was like exploring a parallel universe completely unknown to most people
10:27:37 <ph88_> i was just reading that as for there to be "Rule f ContextItem" there must exist "Rule f ContextClause"  which is really easy to check
10:28:30 <cocreature> ph88_: it’s more like: Rule f ContextClause _implies_ Rule f ContextItem
10:28:47 <cocreature> ph88_: but how do you know if Rule f ContextItem is true? you have to check again
10:29:02 <cocreature> ph88_: and if you construct a cycle of these dependencies, GHC loops forever
10:29:15 <ph88_> i don't see how this is cyclic ..
10:29:42 <cocreature> codedmart: consider "instance Rule f ContextItem => Rule f ContextClause" and "instance Rule f ContextClause => Rule f ContextItem"
10:29:47 <cocreature> eh ^ ph88_ 
10:29:59 <ph88_> line 14 this code    Rule f ContextItem =>    is not in the source file, so it should give an error and abort
10:30:43 <ph88_> ok if you use "instance Rule f ContextClause => Rule f ContextItem" i totally see how that is cyclic .. but that is not in the code
10:31:04 <cocreature> ph88_: instances can come from other files. so GHC has to conservatively reject instances assuming there _could_ be one that created a cycle. this does not mean that there actually is one
10:31:19 <cocreature> which is why enabling UndecidableInstances is completely fine in a lot of cases
10:31:31 <ph88_> how can i protect my classes in my module so that it doesn't go search for instances in other modules ?
10:31:38 <cocreature> you can’t
10:31:45 <cocreature> well you can not export the class
10:31:49 <cocreature> then people can’t make instances
10:32:09 <ph88_> the module i use is just the main module .. it's for an executable not a package
10:32:34 <cocreature> ph88_: all that UndecidableInstances does is that it’s now your job to make sure that there are no cycles. GHC doesn’t try to check it
10:33:09 <ph88_> i feel like i should write them in a dedicable way so i can keep the ghc check in
10:33:22 <ph88_> i just don't get how that code is undecidable :/
10:38:02 <ph88> cocreature, i'm gonna explore that different path and just add code until compile times blow up
10:38:29 <monochrom> No, use the subtraction method.
10:39:40 <ertes> why are so many modules not linked in <https://hackage.haskell.org/package/base>?
10:39:46 <ertes> i need the documentation for GHC.STRef
10:40:58 <ph88> monochrom, you think it's not better to start small with something that works ?
10:41:01 <monochrom> Perhaps the module isn't exposed to begin with?
10:41:13 <ertes> monochrom: i can import it
10:41:24 <monochrom> Ah, strange, I don't know.
10:41:26 <ertes> anyway, the proper way to add a finaliser to an STRef is to add it using 'addFinalizer' on the underlying MutVar#, right?
10:41:40 <ertes> not on the STRef itself
10:41:58 <ertes> data STRef s a = STRef (MutVar# s a)  -- here is how STRef is defined
10:42:00 <monochrom> ph88, you currently don't have a small working thing to add to. You currently have a big questionable thing.
10:43:03 <monochrom> Recall the story of Ptolemy's epicycles.
10:43:53 <vimalloc_> I'm new to haskell, and am working my way through some excersises and exaples. I've got this code, which I cannot get to compile, but I'm having a hard time figuring out what is wrong with it. Would anyone mind taking a look? https://gist.github.com/vimalloc/b17a6ac578328a714280d9c5ad00d0f8
10:45:35 <ertes> vimalloc_: write Int instead of i
10:45:55 <monochrom> oh heh
10:46:12 <monochrom> "Couldn't match expected type ‘Int’ with actual type ‘i’" is actually meaningful.
10:46:26 <ertes> vimalloc_: your length type is Int, but your type signature in the first function claims that your function works for *any* length type, which is clearly not true
10:46:47 <kadoban> vimalloc_: In the second attempt there, Int isn't a typeclass, it's an actual type. So you'd write :: Int -> [a] -> a     there
10:47:05 <vimalloc_> I thought the (Int i) => i ... would do that. I didn't realize I could pass an exact time directly there
10:47:08 <vimalloc_> Thx guys <3
10:47:28 <monochrom> And there is no such thing as "Int i".
10:47:29 <ertes> vimalloc_: types and type classes aren't the same thing…  they aren't interchangable like that
10:48:16 <vimalloc_> Could I do the same code with typeclasses (Just out of curiosity)? Something like (Num i, Ord i, Eq i) => i -> ..
10:48:21 <kadoban> You could almost write   Num i => i -> [a] -> a      but it wouldn't quite work, because  'length' gives you exactly an Int as a result, not any Num you want.
10:48:30 <monochrom> Not for this one. length insists on Int.
10:48:32 <ertes> vimalloc_: the definition doesn't permit it
10:48:50 <vimalloc_> Great. Thanks! 
10:48:57 <monochrom> Unless you throw in a bunch of "fromIntegral"s to relax it.
10:52:21 <ertes> vimalloc_: it's useful to keep in mind that whenever you write a type variable (without class constraints like Num), it can stand for *any* type…  for example your function would have to be prepared to work with (i = Integer -> Rational) just as well as (i = Int)
10:53:33 <monochrom> No no, "any" alone is beside the point. But point is: from whose perspective.
10:53:41 <monochrom> Answer: From the user's perspective.
11:02:58 <vimalloc_> o
11:06:35 * PanosAsproulis[m sent a long message: PanosAsproulis[m_2017-01-29_19:06:12.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/bQMKepuVQDuEWlLuVBGkPpVl
11:06:42 <PanosAsproulis[m> Why does this fail?
11:07:09 <PanosAsproulis[m>  Couldn't match expected type ‘a’ with actual type ‘Triangle’
11:07:09 <PanosAsproulis[m>       ‘a’ is a rigid type variable bound by
11:07:30 <PanosAsproulis[m>  Couldn't match expected type ‘a’ with actual type ‘Triangle’
11:07:31 <PanosAsproulis[m>       ‘a’ is a rigid type variable bound by
11:08:06 <PanosAsproulis[m> the type signature for:
11:08:07 <PanosAsproulis[m>           formingFaces :: forall a. Face a => Duo -> [a]
11:08:40 <lyxia> PanosAsproulis[m: in the last line you return a list of Triangles
11:08:44 <pikajude> PanosAsproulis[m: [t1 d, t2 d] :: [Triangle]
11:08:53 <pikajude> you need a forall a. Face a => [a]
11:09:06 <PanosAsproulis[m> Because Triangle is an instance of Face
11:09:20 <pikajude> it's true
11:09:25 <PanosAsproulis[m> Can I not use a Triangle for Face?
11:09:28 <pikajude> but it's not any a for which an instance of Face exists. it's Triangle
11:10:17 <PanosAsproulis[m> I don't understand. 
11:10:59 <kjslag> I think you want: class Face a => Cell c a where formingFaces :: c -> [a]
11:11:10 <lyxia> Face a => c -> [a] means that the caller of formingFaces gets to pick the face type.
11:11:27 <lyxia> But then if you return a list of Triangle, it can't be any other face
11:13:21 <PanosAsproulis[m> But class Face a => Cell c a is like saying that Cell is a superclass of Face which is not meaningful
11:13:46 <PanosAsproulis[m> Sorry,  Face is a superclass for Cell.
11:13:58 <pikajude> well, what are you trying to use Face for
11:14:59 <PanosAsproulis[m> Face should be unrelated to Cell. I just want a function that returns any kind of cell face.
11:15:31 <pikajude> that's my question. how are you using that information
11:15:39 <ph88_> is it allowed to use  |  when manually giving the type with ::  ?
11:16:30 <PanosAsproulis[m> The way it is in the code. There is no dependence of one on the other.
11:16:52 <PanosAsproulis[m> Also, the "class Face a => Cell c a where
11:16:53 <PanosAsproulis[m>     formingFaces :: c -> [a]" gives me an error
11:17:07 <PanosAsproulis[m>  Too many parameters for class ‘Cell’
11:17:08 <PanosAsproulis[m>       (Use MultiParamTypeClasses to allow multi-parameter classes)
11:17:22 <kjslag> You need to enable MultiParamTypeClasses in order to use my suggestion
11:18:22 <kjslag> http://lpaste.net/351770
11:19:33 <PanosAsproulis[m> Yes, with this option it works
11:20:53 <PanosAsproulis[m> It feels strange to me. That I have to specify the kind of Face I use and make Cell have Face as a superclass.
11:21:58 <ph88_> cocreature, i saw that at one point where i was using get that the compiler infered the wrong type, after i manually put ::  the error went away. So now i'm adding manual types on everywhere where i use get, i hope it will speed up ghc too
11:22:58 <PanosAsproulis[m> What I am trying to do is this: Have a Face typeclass and a Cell typeclass. Then create instances of these typeclasses for various kinds of faces (Triangle, Quadrangle etc) and various kinds of Cells (Tetrahedron, Hexahedron etc).
11:23:31 <PanosAsproulis[m> So, I want to be able for any kind of cell to return the forming faces which could be of any type.
11:23:45 <cocreature> ph88_: compile times of > 1 hour really don’t call for “small” optimizations such as adding explicit type signatures. there must be some deeper problem and I would try to find that before you spend time on other compile time optimizations
11:24:11 <kjslag> Then I think you need pikajude's suggestion
11:24:34 <ertes> ph88_: there are no technical reasons to use giant modules…  you should split it up
11:24:43 <ph88_> cocreature, when i remove half of my code i get soooo many errors, it will take a very very long time to do some kind of binary search on leaving code out and running ghc
11:24:50 <PanosAsproulis[m> For certain cases the faces can be of different kinds. So, a Pyramid has one Quadrangle and 4 Triangles.
11:24:51 <kjslag> Maybe read this: https://wiki.haskell.org/Existential_type
11:25:35 <geekosaur> PanosAsproulis[m, I suspect your problem is you're thinking of typeclasses as OOP. class Face a => Cell a does not express that Cell is a subclass; it expresses that Cells are composed of Faces
11:25:39 <ertes> ph88_: if you want to do this in a principled way, try to come up with a small core language you can express the rest in, then write a separate module for that language
11:26:20 <ph88_> ertes, you mean building up the grammar bottom up ?
11:26:25 <PanosAsproulis[m> geekosaur: how can I then return a list of Face objects, each one of a different type e.g. Triangle, Quadrangle etc?
11:27:00 <ertes> ph88_: yes…  look for code patterns that you can factor out
11:27:25 <geekosaur> actually, as written, you can't because the precise relationship specified there is that you have some type a that has both Cell and Face instances. that does not sound like what you are describing
11:27:42 <ph88_> ertes, i've starting writing the parser top-down and been feeling it ever since :/
11:27:56 <ertes> ph88_: similar to how computing sums and products can be factored out as foldl'
11:28:18 <geekosaur> quite possibly you want Cell to be a record type, one of whose fields is a list of Face-s. but if the Face-s can have different types then you need to have Face be an ADT with data constructors representing the different face types
11:28:21 <kjslag> PanosAsproulis[m: this is probably a better reference: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
11:28:30 <geekosaur> (which will end up being much cleaner, but it's harder to extend in the future)
11:28:31 <ph88_> ertes, i have little inside of how certain grammar rules are clustered together
11:28:34 <ertes> ph88_: yeah, as you see GHC *really* wants you to write functional code =)
11:29:05 <geekosaur> typeclasses for this kind of thing is a bit of a code smell
11:29:25 <geekosaur> (although there are ways to do it that can use typeclasses --- not the way you are trying to do it, though)
11:29:47 <ertes> ph88_: my first step would be to look for code patterns that are similar
11:29:56 <PanosAsproulis[m> geekosaur: Thank you. I will read the link.
11:30:13 <ertes> ph88_: if you really can't find any (unlikely in 4K LoC), then try to *make them* look similar
11:30:40 <geekosaur> and heterogeneous lists are also a bit of a code smell, not to mention a massive PITA to work with; try to find a different way to represent it
11:30:43 <ph88_> ertes, well i suppose when i want to redo this bottom up i can take all the rules that only contain terminals and start building on top of them ^^
11:31:36 <ertes> ph88_: i don't know your use case, so i can't really give you a strategy, but the idea is very similar to things like foldr
11:31:52 <ertes> pretty much all single-list reductions are foldrs
11:32:12 <ertes> once you really understand foldr, you see them everywhere and start expressing them in terms of foldr
11:32:19 <ph88_> not sure how fold relates to this tbh .. i'm thinking about grammar rules and types
11:32:19 <kjslag> I have some questions about profiling with GHC using set cost centers (SCC).
11:32:20 <ertes> (or special cases of it)
11:32:26 <kjslag> For example, is it possible to manually attach an SCC to an entire function? For example, how do I attach an SCC to "f x = g x where g = ..."? If I write "f x = {-# SCC f #-} g x where g = ...", then the "where g = ..." part isn't included in the SCC. Somehow, -fprof-auto seems to be able to attach an SCC to all of "f" at once, which is what I want to do manually.
11:33:06 <ertes> ph88_: well, i can give you an exercise, if you want
11:33:08 <geekosaur> the big problem with what you were doing is that the most sensible use case for it is (Face f, Structure s) => class Cell s f where type CFace s = f; ... -- which limits you to one type of face
11:33:12 <ph88_> the amount of errors i find by just reading my own code is also staggering :|
11:33:18 <ph88_> ertes, sure :P
11:33:32 <ph88_> but it will take a few minutes before i have my hands free
11:33:46 <ph88_> i'm trying to get another run of ghc and see if it works better with a lot of things type annotated
11:34:29 <ertes> ph88_: three steps: 1. implement (++) naively (not using combinators), 2. implement a function that prints each element of its argument list (again without combinators like 'traverse'), 3. find a common pattern and factor it out
11:38:32 <geekosaur> PanosAsproulis[m, btw another way to do this is to break Face down, rather than have Triangle, Quadrangle, etc. have data Face = Face {vertices :: Int; conns :: [Double {- angles -} ]};
11:38:48 <geekosaur> or something like that
11:40:37 <geekosaur> or if the angles need to be in the Cell then Face would just have vertices and quadrangle = Face {vertices = 4}
11:41:10 <geekosaur> but I'd have to know more about what you are modeling and what you're trying to do with it to give a better description
11:41:44 <geekosaur> (for example you might do better with edges instead of vertices)
11:48:31 <ph88> ertes, can i use reverse ?
11:48:47 <Gurkenglas> :t \foo -> filter foo . sequence -- How do you correctly backtrack through an exponential space? Requesting a version of this that exploits that foo x implies foo for each prefix of x.
11:48:49 <lambdabot> Traversable t => (t a -> Bool) -> t [a] -> [t a]
11:50:57 <Gurkenglas> Huh, that nonspecialization of t to [] means that I might need to rephrase that "prefix" stuff
11:51:38 <pikajude> filter needs []
11:51:40 <pikajude> iirc
11:52:39 <Gurkenglas> pikajude, I mean t. filter, as lambdabot shows, already forces the applicative to []
11:52:49 <pikajude> oh
11:55:27 <lpaste> xcmw pasted “ZipList with ApplicativeDo” at http://lpaste.net/351771
11:57:24 <xcmw> Why do the code error? ZipList is an applicative and I enabled ApplicativeDo.
11:59:21 <kadoban> It probably isn't matching one of the cases that ApplicativeDo handles. I'm still not clear on what exact form(s) it can do.
11:59:57 <sergisiberia2003> how to tuples?
12:00:14 <kadoban> > (5, "stuff")
12:00:16 <lambdabot>  (5,"stuff")
12:00:28 <sergisiberia2003> can I have fraction?
12:00:48 <Gurkenglas> :t \foo -> foldlM (\accum factor -> [new | x <- factor, let new = accum ++ [x], foo new]) [] -- If t is set to [], this applies, but the ++ [_] makes me think its not the canonical way.
12:00:50 <lambdabot> Foldable t => ([a] -> Bool) -> t [a] -> [[a]]
12:01:13 <ertes> ph88: ideally don't use anything
12:01:16 <sergisiberia2003> thank you lambdabot, but how to substract fraction if fraction is negative?
12:01:29 <ertes> ph88: really just write the most straightforward implementation you can think of…  use recursion
12:01:45 <ph88> yeah i had to look at the implementation of foldr :/
12:01:48 <xcmw> sergisiberia2003: look into Rational
12:02:07 <sergisiberia2003> xcmw: ok, is substract negative possibility?
12:02:31 <xcmw> > (1 % 2) - (-1 % 3)
12:02:33 <lambdabot>  5 % 6
12:02:41 <sergisiberia2003> sorry for bad english, i'm from pakistan! I very much enjoy hashel
12:02:47 <sergisiberia2003> thank you for help.
12:03:08 <ph88> how can i hide function from the prelude individually 
12:03:22 <sergisiberia2003> i believe I have an error
12:03:26 <sergisiberia2003> goodbye
12:03:26 <ertes> ph88: import Prelude hiding (blah)
12:03:28 <geekosaur> import Prelude hiding (...)
12:03:40 <Gurkenglas> ph88, I don't think it counts if you just paste the foldr source in and refactor until we can't tell :D
12:04:00 <ertes> ph88: an explicit Prelude import overrides the implicit one
12:04:02 <geekosaur> if you import Prelude explicitly, it overrides the implicit full import
12:04:04 <geekosaur> heh
12:04:08 <ertes> =)
12:04:25 <MarcelineVQ> xcmw: ApplicativeDo is reeeeally picky, don't use $ on your return/pure
12:05:31 <ertes> ph88: i think you're overthinking this…  i *really* want you to write straightforward implementations…  just time-travel to the point when you just started with haskell and were learning about basic list functions and recursion
12:05:49 <ertes> that's the kind of implementation i'd like you to write
12:06:08 <ph88> well that part was always a bit unclear so i kinda moved on
12:06:36 <ph88> so far i have this   go [x1]     s2 = x1 : s2      go (x1:xs1) s2 = go x1 (go xs1 s2)
12:06:37 <ertes> i see…  then it's time to catch up =)
12:06:51 <ertes> ph88: what about the empty list?
12:06:57 <xcmw> MarcelineVQ: It works now. Thanks
12:07:42 <ph88> yeah i can add them but the error seems the same anyway
12:08:11 <ertes> ph88: what's the head of ((x : xs) ++ ys)?
12:08:19 <ph88> x
12:08:24 <ertes> ph88: and the tail?
12:08:31 <ph88> xs ++ ys
12:08:34 <ertes> there you go =)
12:08:45 <ertes> (x : xs) ++ ys = x : (xs ++ ys)
12:09:26 <ph88> i thought that's what i have now without infix notation
12:09:40 <ertes> nope
12:09:49 <ertes> you have a 'go' there that should really be (:)
12:09:58 <ph88> yeah i removed that go
12:10:25 <ph88> https://paste.fedoraproject.org/540197/48572059/ this is what i have now
12:10:35 <Gurkenglas> :t filter foo . sequence -- Is there a version of this that exploits that foo can say False as soon as no path to True remains?
12:10:38 <lambdabot> error:
12:10:39 <lambdabot>     • Variable not in scope: foo :: t a -> Bool
12:10:39 <lambdabot>     • Perhaps you meant ‘for’ (imported from Data.Traversable)
12:10:59 <ph88> no that go i had before should be there !
12:11:08 <Gurkenglas> :t \foo -> filter foo . sequence -- you forget querying to lambdabot first _one time_...
12:11:14 <lambdabot> Traversable t => (t a -> Bool) -> t [a] -> [t a]
12:11:17 <ertes> ph88: *something* should be there, but not 'go'
12:11:49 <ph88> ah ok i got it now
12:13:42 <ph88> ertes, what did you mean with a common pattern ?
12:13:56 <ph88> repetition in a list ?
12:13:56 <ertes> ph88: i can't explain until you have done the first two steps
12:14:13 <ph88> the 2nd step i knew right away so i moved on to the 3rd
12:14:20 <ertes> do it anyway
12:14:25 <ph88> do what ?
12:14:28 <ertes> step 2
12:14:33 <ph88> yes it's done
12:14:41 <ertes> ok, can you paste your code?
12:14:45 <ph88> ok
12:15:06 <ph88> https://paste.fedoraproject.org/540212/72087914/
12:15:40 <Gurkenglas> mapM_ is cheating too
12:15:56 <ph88> o_O
12:16:01 <ertes> ph88: question: go [] ys = ys; go (x : xs) ys = x : go xs ys
12:16:09 <ertes> ph88: are there any unhandled cases?
12:16:16 <ertes> with my two-clause version that is
12:16:28 <ph88> nope :P
12:16:32 <Gurkenglas> "without combinators like 'traverse'" <- mapM = traverse, mapM_ = traverse_
12:16:59 <ph88> didn't know mapM_ was traverse_
12:17:01 <ertes> ph88: that's right…  adjust your definition of 'go' and then do 'prt' without cheating =)
12:17:18 <ertes> again using recursion
12:20:39 <ph88> prt []     = putStrLn ""   prt (x:xs) = putStrLn x >> prt xs
12:21:06 <ertes> ph88: can you do it without the extra line at the end?
12:21:25 <ph88> no, ghc will throw an exception that i have non-exhaustive pattern match
12:21:42 <ph88> i tried that first
12:21:45 <ertes> ph88: for an empty list the resulting action should be an action that does nothing
12:21:58 <ertes> that's not the same as not defining what happens for the empty list
12:21:59 <ph88> i don't know of any action that doesn't do anything
12:22:14 <ertes> you do…  you've used it in the past =)
12:22:15 <c_wraith> return builds the action that doesn't do anything
12:22:37 <ph88> ah yes i got some inspiration :P
12:22:37 <c_wraith> that's true of every monad.  That's more or less what the monad laws say. :)
12:22:48 <ph88> prt []     = return ()
12:22:55 <ertes> great
12:23:14 <ertes> ph88: now look at the two functions you have defined…  we can talk about patterns now: *code* patterns
12:23:17 <ertes> do you see one?
12:23:33 <ph88> cons and recursion
12:23:52 <ertes> yeah…  both have some base case for recursion…  let's call it _z
12:24:05 <ertes> prt [] = _z  -- in this case _z = pure ()
12:24:17 <ertes> go [] ys = ys  -- in this case _z = ys
12:24:26 <ertes> whoops
12:24:29 <ertes> go [] ys = _z  -- in this case _z = ys
12:24:54 <ph88> don't see how   ys = pure ()   being the same base
12:25:08 <ertes> this is just a symbolic game
12:25:12 <ph88> ah ok
12:25:20 <ertes> i've renamed the result for the empty case to _z
12:25:24 <ertes> good so far?
12:25:32 <ph88> ok
12:25:47 <ertes> less obviously both do something with the head element and the recursive result
12:26:22 <ertes> go (x : xs) ys = x : (xs ++ ys)
12:27:08 <ertes> prt (x : xs) = putStrLn x >> prt xs
12:27:54 <ertes> it may be less obvious how these two are the same pattern, but here is the secret:  for both cases there is a function _f that takes the head element as well as the recursive result as its arguments
12:28:05 <ertes> go (x : xs) ys = _f x (xs ++ ys)
12:28:08 <ertes> what's _f in this case?
12:28:33 <ph88> :
12:28:47 <Zemyla> Okay, question. If something has a StablePtr made of it, it doesn't get GCed anymore until the StablePtr is released, right?
12:28:52 <ertes> yeah (nitpick: it's (:))
12:29:10 <ertes> ph88: prt (x : xs) = _f x (prt xs)  -- what about this one?
12:29:18 <ph88> >>
12:29:22 <ertes> ph88: nope
12:30:05 <ph88> \a b -> putStrln a >> b
12:30:08 <akfp> How do I write a function that calculates the average of two numbers and that operate on both Integral and Fractional?
12:30:15 <ertes> ph88: exactly
12:30:15 <akfp> returning Double
12:30:43 <ertes> ph88: everything else about these two functions is the same…  they only differ in _f and _z
12:30:55 <ph88> yup
12:31:22 <ertes> ph88: factoring out means: write a function that abstracts over _f and _z:  reduce f z (x : xs) = f x (reduce f z xs);  reduce f z [] = z
12:31:24 <ph88> nitpick: \a b -> putStrLn a >> b
12:31:43 <ertes> hehe yeah
12:32:12 <ertes> ph88: then you can write:  go xs ys = reduce (:) ys xs
12:32:19 <ph88> ah yes
12:32:41 <ertes> ph88: and: prt = reduce (\x go -> putStrLn x >> go) (pure ())
12:33:33 <ertes> ph88: this kind of pattern abstraction is at the heart of functional programming =)
12:33:41 <ph88> and now we implemented foldl with reduce or what
12:33:47 <ertes> ph88: foldr
12:34:38 <ph88> foldr ? isn't that suppose to start from the right side of the list ?
12:34:39 <ertes> akfp: Integral has toInteger
12:34:44 <ertes> ph88: nope
12:35:17 <ph88> oh i always thought foldr stood for fold right
12:35:24 <c_wraith> it does
12:35:27 <ertes> ph88: right-associative fold
12:35:30 <c_wraith> But that doesn't mean "start from the right"
12:35:45 <ph88> omg -___-
12:35:55 <ph88> okay
12:36:03 <c_wraith> starting from the right would be *terrible* for performance.
12:37:01 <ph88> yeah i always wondered why foldl was slower than foldr, the opposite seemed to make more sense
12:37:06 <ertes> ph88: the second step to mastering this abstraction technique is to "re-see" those patterns in new code and then use (in this case) foldr correctly
12:37:35 <ph88> ok but how is this gonna help finding groups in my grammar rules graph ?
12:38:12 <ertes> ph88: you need to find similar code patterns and figure out over what you need to abstract, similar to 'go' and 'prt'
12:39:24 <ph88> well i factored out some code already, but the problem is that i need to make the rules so that all dependencies are there otherwise i get a lot of errors by ghc
12:40:41 <ph88> for example  data HigherRule = HR LowerRule      data LowerRule = LR String
12:41:10 <ertes> those two aren't mutual…  they can easily live in separate modules
12:41:33 <ertes> however, it's more common to have a .Types module that has only types and instances
12:41:48 <ph88> yeah just that there are over 150 rules and i have little insight into the dependencies they have on each other .. this was just a simple example
12:44:17 <ph88> i will start with the rules that don't have any dependencies, check if it compiles and go from there i guess ^^
12:45:21 <ph88> actually i'm thinking about writing a script that parses my source file and figure out in which order i should introduce the rules in a bottom-up way
12:46:18 <ph88> ertes, you want to see my source file, i don't think there is much room to factor out stuff but perhaps you see some patterns which i don't
12:47:11 <ertes> ph88: i'd rather not look at 4K LoC this evening =)
12:47:17 <ph88> ok :P
12:48:06 <ertes> the two techniques that really help reducing code size are abstraction (like foldr) and composition (i.e. come up with a minimal domain-specific language and express everything in that one)
12:48:28 <ph88> yeah i'm not quite there yet though
12:48:36 <ph88> atm i'm focusing on reducing compilation time
12:49:03 <ertes> less code = shorter compile times ;)
12:49:11 <ph88> ok ok
12:56:06 <Tuplanolla> "If you need the database to be fast, we recommend not putting too much data in it."
12:58:28 <Jello_Raptor> so I'm contemplating using classy-prelude for a project of my, but the haddock page is painful 
12:58:33 <EvanR> optimally, make sure there is no data in there at all
12:58:50 <ertes> that's what i call reductio ad absurdum =)
12:58:53 <Jello_Raptor> is there a way to get a haddock page with the closure of all the exported elements and their haddocks? 
12:59:29 <EvanR> empty database has other benefits, like being able to prove any property for everything in it
13:00:01 <tdammers> Jello_Raptor: my personal experience with classy prelude confirms your fears. It's good, but the documentation is painful.
13:01:43 <Jello_Raptor> tdammers: yeah :/ this is project with some others who are going to be haskell newbs, and I want to restrict them to something total, with all the common functions and much less worrying about imports, but forcing them to gid through N layers of redirection in hackage to find what's in the base library is no-go. 
13:03:29 <tdammers> Jello_Raptor: if they're Haskell newbs, absolutely recommend against classy-prelude
13:03:37 <tdammers> it's definitely a power tool
13:04:20 <tdammers> you're probably better off making your own prelude, re-exporting just a bunch of uncontroversial modules
13:04:30 <tdammers> Data.List, Data.Char, Data.Maybe, Control.Monad, that kind of stuff
13:04:58 <Jello_Raptor> mmm
13:07:16 <Jello_Raptor> seems reasonable, though I'd still like to prevent them from having access to the non-total functions in prelude (barring undefined and error) 
13:07:36 <tdammers> eh
13:07:47 <tdammers> I'd solve that with code reviews and education
13:08:02 <tdammers> but if you have to, you can of course have your custom prelude import Prelude hiding (head, ...)
13:09:44 <Jello_Raptor> part of it is that even I end up making mistakes with that sort of thing that bite me in production.
13:10:00 <Cale> Tuplanolla: But yeah, compilation is super-linear -- it's often possible to chop a large module up into smaller ones, and the sum of compile times for the small modules will be smaller than the compile time for the large one.
13:10:23 <Jello_Raptor> but even then, it would be very nice to have some way to generate the haddock that's the closure of all the relevant imported and exported stuff. 
13:11:08 <tdammers> Jello_Raptor: for my own custom prelude, I resorted to dumping a ghci :browse into a file, and pasting that into the export list
13:21:37 <athan> What is a "zipper", not in ekmett terms? :) I've seen something similar to `([a], [a])` where the head of the first list is the "focus" (maybe)
13:21:59 <EvanR> theres that one and ([a], a, [a])
13:22:13 <EvanR> the second one is a comonad
13:22:28 <athan> ahh! Do you know where I can find more info about them?
13:22:45 * athan still doesn't even comonad ._.
13:23:28 <EvanR> thats the simplest zipper, you can get more elaborate
13:23:44 <EvanR> https://en.wikibooks.org/wiki/Haskell/Zippers
13:24:21 <athan> awesome, thanks EvanR
13:24:29 <AWizzArd> I want to call this from the shell via `cat file.txt | ./myProg` to list the contents of a file, prefixed by the line number. Works: main = interact $ unlines . map (\(i, s) -> show i ++ ". " ++ s) . zip [1..] . lines         I wonder now if using zip [1..]  is the best way to create an indexed sequence for map.
13:27:49 <byorgey> AWizzArd: zip [1..] is fairly idiomatic.
13:28:28 <byorgey> AWizzArd: if you want to get really crazy you could use an indexed traversal from the 'lens' library, but honestly a simple  zip [1..]  is best.
13:28:52 <AWizzArd> Okay thanks.
13:29:32 <Gurkenglas> AWizzArd, map (\(x, y) -> f x y) $ zip a b is zipWith f a b
13:29:56 <AWizzArd> byorgey: one more question: if I don’t want to read from standard input, but forward the results of a `readFile` into my expression above, is there a way to do this?
13:30:15 <mpickering> How do I tell stack to use the version of GHC on my command line?
13:30:47 <Gurkenglas> main = putStrLn . unlines . zipWith (\i s -> show i ++ ". " ++ s) . lines =<< readFile "file.txt" -- AWizzArd
13:31:05 <AWizzArd> Gurkenglas: ah yes, I haven’t seen this =<< yet. Good, danke!
13:32:59 <mpickering> I don't understand why when it looks for ghc-8.0.1 it refuses to use the binary called ghc-8.0.1 which is on my path
13:39:35 <lpaste> jadlr pasted “type class instance for servant” at http://lpaste.net/351774
13:40:35 <ph88_> geekosaur, you told me about enum, can i use that to replace pattern matching as well ? https://paste.fedoraproject.org/540395/57259731/ so that here i can do something with P.pretty and [SSimpleName .. SALL]   ??
13:40:36 <jadlr> Hi, I'm trying to create a type class instance for servant and I am stuck. How can I create the type class above without getting the orphan warning?
13:41:24 <jadlr> This is the code: http://lpaste.net/351774
13:41:26 <geekosaur> ph88_, sadly no
13:44:00 <geekosaur> ph88_, tht's one of the places where things tend to get ugly and require boilerplate
13:44:51 <ph88_> boilerplate like template haskell ?
13:47:00 <geekosaur> like repeating yourself the way you did in that paste
13:47:19 <geekosaur> TH could probably avoid it but TH has its own price, which is probably not worth it in this case
13:48:25 <ph88_> geekosaur, this is one of the most ugly things in my code :(  https://paste.fedoraproject.org/540413/85726466/
13:50:01 <reactormonk> Where does Lens' come from? https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html#g:7 => 
13:50:05 <reactormonk> https://www.haskell.org/hoogle/?hoogle=Lens%27
13:50:17 <reactormonk> ... or rather, how do I look for it.
13:50:29 <Tuplanolla> What does `:i Lens'` say, reactormonk?
13:50:54 <glguy> jadlr: instead of making an instance of a type synonym, you can create a newtype
13:50:55 <reactormonk> not in scope...
13:51:28 <Tuplanolla> I get `type Lens' s a = Lens s s a a -- Defined in 'Lens.Micro.Type'`, but this is probably not the `Lens'` you're looking for, reactormonk.
13:52:20 <reactormonk> > This module also provides analogs to Lens over the various types in this library. These are written in a generic way to avoid a dependency on any particular lens library. You should be able to use these with a number of packages including lens and lens-family-core.
13:52:22 <lambdabot>  <hint>:1:6: error: parse error on input ‘module’
13:53:08 <reactormonk> So they should be usable with either of these?
13:53:20 <geekosaur> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Lens.html#t:Lens-39- ?
13:53:42 <geekosaur> (which is the same type Tuplanolla showed)
13:58:15 <jadlr> glguy, how would that newtype look for a list of Integer?
14:00:20 <jadlr> glguy, thanks I think I got it!
14:02:25 <AWizzArd> Is there some kind of pipe/threading operator in Haskell? Like function composition `.`, but the other way around. Not  length . take 10 . reverse $ "abcdefghijklmnop"    but  "abcdefghijklmnop" -> reverse -> take 10 -> length    – “Take this string and reverse it. From the output of this take 10 chars, and from that output give me the length.
14:03:06 <Koterpillar> AWizzArd: some libraries define it, but there are disagreements on whether it's a good style to use it
14:03:10 <Koterpillar> :t (&)
14:03:11 <lambdabot> a -> (a -> b) -> b
14:03:26 <Koterpillar> > "abcdef" & reverse & take 3
14:03:29 <lambdabot>  "fed"
14:04:10 <AWizzArd> Oki thx. I don’t say that this is necessarily good style, was just curious if there is something like this.
14:04:19 <geekosaur> that's actually flipped ($) not flipped (.). reversed function application
14:05:13 <Tuplanolla> We have that too though.
14:05:13 <Tuplanolla> > 0 & (+ 1) >>> (* 2)
14:05:15 <lambdabot>  error:
14:05:15 <lambdabot>      Precedence parsing error
14:05:15 <lambdabot>          cannot mix ‘&’ [infixl 1] and ‘>>>’ [infixr 1] in the same infix exp...
14:05:26 <Tuplanolla> > 0 & ((+ 1) >>> (* 2))
14:05:29 <lambdabot>  2
14:14:23 <b4ff3r>  /who 
14:33:32 <eschnett> Julia uses “|>”: x |> y = y x
14:33:55 <Tuplanolla> Elm has something similar as well.
15:26:38 <joehillen> :t (&)
15:26:40 <lambdabot> a -> (a -> b) -> b
15:38:39 <recur22> dose anyone know good example on how stdin stdout is used to call haskell as backend
15:39:02 <SrPx> Is there any easy way to, given an int `n`, get a list of all strings of length `n^2` containing `n` occurrences of every `x < n`? E.g., for 2, that would be: 0011, 0101, 1001, 0101, 0110, 1100
15:39:36 <SrPx> For 3, that would be: 000111222, 001011222, 010011222, 100011222, 100101222... 
15:40:33 <Koterpillar> SrPx: it looks like you'd benefit from permutations :: [a] -> [[a]]
15:40:48 <Koterpillar> ...which is in Data.List
15:41:21 <Koterpillar> > permutations "0011"
15:41:24 <lambdabot>  ["0011","0011","1001","0101","1001","0101","1100","1100","1010","1010","0110...
15:42:52 <SrPx> > foldl (\s x -> if x `elem` s then s else s ++ [x]) [] [1,2,3,1,1,2]
15:42:55 <lambdabot>  [1,2,3]
15:43:07 <SrPx> > foldl (\s x -> if x `elem` s then s else s ++ [x]) [] [1,2,3,1,1,2] $ permutations "0011"
15:43:10 <lambdabot>  error:
15:43:10 <lambdabot>      • Couldn't match expected type ‘[[Char]] -> t’
15:43:10 <lambdabot>                    with actual type ‘[Integer]’
15:43:18 <SrPx> > foldl (\s x -> if x `elem` s then s else s ++ [x]) [] [1,2,3,1,1,2] $ permutations [0,0,1,1]
15:43:20 <lambdabot>  error:
15:43:20 <lambdabot>      • Couldn't match expected type ‘[[Integer]] -> t’
15:43:20 <lambdabot>                    with actual type ‘[Integer]’
15:43:40 <SrPx> > foldl (\s x -> if x `elem` s then s else s ++ [x]) [] $ permutations [0,0,1,1]
15:43:43 <lambdabot>  [[0,0,1,1],[1,0,0,1],[0,1,0,1],[1,1,0,0],[1,0,1,0],[0,1,1,0]]
15:43:47 <Koterpillar> nub "0011001"
15:43:49 <Koterpillar> > nub "0011001"
15:43:51 <lambdabot>  "01"
15:43:59 <SrPx> > nub $ permutations [0,0,0,1,1,1,2,2,2]
15:44:02 <lambdabot>  [[0,0,0,1,1,1,2,2,2],[1,0,0,0,1,1,2,2,2],[0,1,0,0,1,1,2,2,2],[0,0,1,0,1,1,2,...
15:44:07 <Tuplanolla> This question feels familiar.
15:44:11 <Koterpillar> (beware that nub is O(n^2))
15:44:11 <SrPx> Interesting...
15:44:18 <Koterpillar> :t nub
15:44:20 <lambdabot> Eq a => [a] -> [a]
15:44:31 <Koterpillar> you can do better with Ord a
15:44:36 <SrPx> Koterpillar: why if it can easily be done in O(log(N)*N)?
15:45:04 <SrPx> Tuplanolla: why?
15:45:22 <Koterpillar> SrPx: nope, you need to check every incoming element against every element you've seen
15:45:54 <Tuplanolla> It comes up when indexing lexicographic permutations, which I seem to find myself doing all the time, SrPx.
15:45:57 <SrPx> Koterpillar: with that type yes, but why isn't `nub` requiring Ord to begin with?
15:46:24 <Koterpillar> SrPx: oversight/legacy reasons
15:46:44 <Tuplanolla> Note that `permutations` doesn't return them in lexicographic order either.
15:46:55 <geekosaur> @index  nubOrd
15:46:55 <lambdabot> bzzt
15:47:09 <SrPx> Tuplanolla: hmm... interesting. I guess the permutations implementation is fine but probably sub par. I wonder what is the more direct recursive algorithm
15:47:20 <Koterpillar> SrPx: it's under ordNub everywhere: http://hayoo.fh-wedel.de/?query=Ord+a+%3D%3E+%5Ba%5D+-%3E+%5Ba%5D
15:47:40 <Tuplanolla> @let picks (x : xs) = (x, xs) : [(y, x : ys) | (y, ys) <- picks xs]; picks [] = []
15:47:42 <lambdabot>  Defined.
15:48:02 <Tuplanolla> @let perms xs = [y : zs | (y, ys) <- picks xs, zs <- perms ys]; perms [] = [[]]
15:48:04 <lambdabot>  .L.hs:160:1: warning: [-Woverlapping-patterns]
15:48:04 <lambdabot>      Pattern match is redundant
15:48:04 <lambdabot>      In an equation for ‘perms’: perms [] = ...
15:48:08 <Koterpillar> SrPx: you would be better off keeping counts of how many times did you emit each element
15:48:17 <Tuplanolla> Damn it.
15:48:21 <Tuplanolla> @undefine
15:48:22 <lambdabot> Undefined.
15:48:57 <Tuplanolla> @let perms [] = [[]]; perms xs = [y : zs | (y, ys) <- picks xs, zs <- perms ys]
15:48:59 <lambdabot>  Defined.
15:49:12 <Tuplanolla> > perms [0 .. 4]
15:49:14 <lambdabot>  [[0,1,2,3,4],[0,1,2,4,3],[0,1,3,2,4],[0,1,3,4,2],[0,1,4,2,3],[0,1,4,3,2],[0,...
15:49:32 <Tuplanolla> > permutations [0 .. 4]
15:49:34 <lambdabot>  [[0,1,2,3,4],[1,0,2,3,4],[2,1,0,3,4],[1,2,0,3,4],[2,0,1,3,4],[0,2,1,3,4],[3,...
15:51:10 <Zemyla> I just came up with a Stupid Haskell Trick.
15:51:18 <Zemyla> Set -XOverloadedStrings, then define:
15:51:23 <Zemyla> @let instance (a ~ [Char], IsString b) => IsString (a -> b) where fromString s = fromString . (++) s
15:51:24 <lambdabot>  Defined.
15:51:41 <Zemyla> Then something like "long" "literal" "string" becomes "longliteralstring".
15:51:44 <Tuplanolla> The point is that `perms = fmap reverse . permutations . reverse` does not hold, SrPx.
15:51:53 <Koterpillar> > "long" "literal" "string"
15:51:55 <lambdabot>  error:
15:51:56 <lambdabot>      • Couldn't match expected type ‘[Char] -> [Char] -> t’
15:51:56 <lambdabot>                    with actual type ‘[Char]’
15:52:08 <Zemyla> lambdabot doesn't have OverloadedStrings set.
15:52:47 <geekosaur> what is this, C? >.>
15:52:55 <Tuplanolla> That's neat, Zemyla.
15:53:16 <Tuplanolla> I wonder if the type checker likes it.
15:53:19 <Zemyla> It also makes showString unnecessary in Show instances.
15:55:02 <SrPx> Tuplanolla: makes sense
16:55:32 <orzo> What do you guys use for the parameter name when you invoke 'fix' on a lambda in order to make a loop?
16:55:53 <orzo> i used to use 'loop' but warnings of shaddowing a loop in Control.Arrow caused me to start using 'again'
16:56:11 <Axman6> f?
16:56:20 <orzo> hm
16:56:21 <Koterpillar> go?
16:56:35 <monochrom> self, go, rec,f, r
16:56:45 <Axman6> > fix (\f n -> if n < 1 then 1 else f (n-1) + f (n-2)) 7
16:56:48 <lambdabot>  34
16:57:42 <orzo> when i want more arguments, i use 'flip fix' so i can hang the lambda off the end
16:57:46 <orzo> heh
16:57:54 <orzo> gets akward if i want yet another argument
16:58:12 <glguy> I'd use loop and remove the arrow import!
16:58:35 <orzo> i mainly inmport arrow for things like 'second'
16:58:38 <monochrom> Don't do that. Use recurse instead.
16:59:04 <orzo> recurse didn't show up in my hoogle search
16:59:18 <monochrom> I mean for your own names.
17:00:06 <orzo> you mean use a let instead of a lambda?
17:00:29 <monochrom> fix (\recursive_placeholder n -> if n < 1 then 1 else recursive_placeholder (n-1) + recursive_placeholder (n-2))
17:01:16 <orzo> i don't see how you solved the flip fix problem
17:01:23 <orzo> you still have to pass an initial value for n
17:01:44 <monochrom> You know what? I was talking to glguy.
17:01:49 <orzo> oh
17:02:35 <glguy> monochrom: Oh, yeah. recursion > using fix, but I like using the name loop for my recursively defined things
17:02:43 <Tuplanolla> I was going to suggest `again`, but QuickCheck has that.
17:03:07 <orzo> conflicting with QuickCheck is less of an issue for  me though
17:12:59 <orzo> do you import 'fix' from Data.Function or Control.Monad.Fix ?
17:13:09 <monochrom> Data.Function.
17:13:20 <monochrom> Is there fix in Control.Monad.Fix?
17:13:34 <byorgey> yes, for hysterical raisins.
17:14:18 <davean> The one in Control.Monad.Fix is the only one I sue
17:14:24 <davean> er
17:14:24 <monochrom> If you're also using mfix, I guess you may like to just import Control.Monad.Fix and be done with it.
17:14:29 <davean> thats mfix, ignore me
17:14:35 <orzo> i never use mfix tho
17:14:42 <davean> mfix is amazingly useful
17:15:11 <byorgey> orzo: why do you use fix?
17:15:33 <orzo> for loops
17:15:41 <pikajude> for for loops?
17:15:59 <orzo> no heh
17:16:11 <orzo> i use 'fix' for making a loop
17:16:25 <orzo> often in IO monad
17:16:33 <orzo> is that a bad idea?
17:16:55 <monochrom> It's OK. "let" in a do-block gets old pretty quickly.
17:17:38 <orzo> what's your typical use of mfix?
17:18:04 <monochrom> To build a cyclic data structure (but its content comes from effects)
17:18:51 <monochrom> I rarely need it but that's what I would use when I needed one. And in a mathematical sense, that's its only use.
17:20:19 <monochrom> Because mfix carries out the effect only once. So, not the control-flow kind of recursion or loop. The only recursion/loop/self-reference left is on values and/or data and/or data dependency.
17:20:53 <monochrom> https://wiki.haskell.org/MonadFix
17:21:26 <fragamus> hey is any Haskell library decent for postgreSQL
17:24:41 <fragamus> I'm thinking this one http://hackage.haskell.org/package/HDBC-postgresql
17:30:23 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html
17:32:02 <byorgey> =D
17:37:21 <orzo> the mu and la references when over me
17:38:21 <monochrom> la is a poor one. Couldn't think up anything for it.
17:38:34 <monochrom> mu is the Greek letter people use for fix.
17:38:43 <geekosaur> Mu is a recursive type representing fixpoints
17:38:54 <geekosaur> la is just copying the original :)
17:39:39 <monochrom> It might have been slightly better if I wrote "lol, a state to follow SO"
17:39:53 <Axman6> fragamus: postgresql-simple is good, persistens can be useful if you need its features. hasql is quite fast. I don't think anyone uses the HDCB stuff any more
17:40:00 <geekosaur> > succ '\SO'
17:40:01 <Axman6> uh, HDBC
17:40:02 <lambdabot>  '\SI'
17:48:21 <ertes> fragamus: postgresql-simple is probably the highest-level API that is still just a postgresql binding
17:49:07 <Axman6> it's quite pleasant to use too. though I'm now leaning towards hasql whenever I need postgresql
17:49:56 <ertes> "The API is completely disinfected from exceptions. All error-reporting is explicit and is presented using the Either type."
17:50:04 <ertes> that sounds like it gets old…  fast…
17:50:27 <Axman6> hasql needs a bit more abstraction though, no monat transformers, all explicitly in IO
17:50:53 <Axman6> monad*
17:51:34 <orzo> why would you want transformers
17:52:04 <orzo> im wokring on a code base where somebody thought they should make type classes and transformers for everything
17:52:09 <ertes> oh god, no…  another one of those "arrows for the sake of arrows" libraries
17:52:11 <orzo> and i think they went overboard
17:52:13 * ertes closes hasql tab
17:52:31 <Axman6> ertes: you don't have to use arrows
17:52:45 <ertes> no?  Query is an arrow
17:52:47 <Axman6> it's also got profunctor and category instances, which are equivalent in power but less painful
17:53:01 <ertes> that's not the point…  it's just stupid not to make this a regular monad
17:53:15 <monochrom> orzo: Sometimes I appreciate ParsecT as a monad transformer, for example. But yeah some people go overboard.
17:53:33 <ertes> and it can't even excuse itself with "history" or "experiment" the way hxt could
17:54:26 <monochrom> :)
17:54:53 <Axman6> the queries aren't what need to be a Monad, Sessions are, and they are a monad
17:55:04 <ertes> Query is an ArrowApply
17:55:05 <Axman6> you appear to be complaining about a library you on't understand yet ;)
17:55:15 <ertes> in other words: it's a monad
17:55:35 <monochrom> I am with ertes when it comes to "it is already an ArrowApply".
17:55:48 <ertes> the fact that it provides an Arrow/Profunctor interface means that you have to use awkward combinators or awkward syntax *for no reason*
17:56:11 <monochrom> I chip in one more point: do-block usually gives you more efficient code than proc-block.
17:56:30 <ertes> exactly…  ArrowApply is worse than Monad in every way i can imagine
17:56:45 <Axman6> Query a b = Query (Kleisli (ReaderT Connection.Connection (EitherT Decoders.Results.Error IO)) a b) (so it appears it could be a monad?
17:57:44 <Axman6> my experience has been I haven't needed to compose Queries anyway, it's Sessions I usually compose which is the result of running a Query
17:58:42 <ertes> sure…  it's just that it immediately makes me question the whole thing
17:58:47 <Axman6> anyway, what I want to see if a MonadHasql m with run :: Session a -> m a (it would basically just be a specialised Reader over Connection and with MonadIO
17:59:56 <monochrom> If no one has ever composed Query's. then it need not be even Arrow.
18:00:02 <monochrom> nor Category.
18:00:33 <dfeuer> Hi ertes, monochrom.
18:00:36 <Axman6> _I_ haven't, I'm sure others probably have. clearly someone has as the example shows how to do it
18:00:40 <monochrom> But as soon as someone wants to compose Query's, it's a slippery slope, they will quickly crave for the full Monad power.
18:01:02 <ertes> the thing that really baffles me is how one does even come to the conclusion: "i need an arrow here"
18:01:12 <dfeuer> ertes: I found an implementation of `fix` using lazy ST by Oleg, which is *one thing*, but I think we should have a few more.
18:01:39 <monochrom> Oh dfeuer you're in luck today!
18:01:50 <Axman6> ertes: I agree, but again, you _do not need to use arrow in any way to use the library_
18:01:51 <ertes> dfeuer: i'm struggling to add arrays
18:01:54 <monochrom> marvel at my http://lpaste.net/5545157388815826944
18:02:03 <ertes> dfeuer: so far it's an STRef fest
18:02:40 <monochrom> Also Oleg already has 3 other fix'es. Using types or Dynamic.
18:03:09 <monochrom> URL is at the bottom of mine.
18:03:28 <ertes> dfeuer: do you think complicated networks of STRefs would be good enough?
18:03:57 <ertes> as a test case i mean
18:04:31 <dfeuer> ertes: I think that sounds awesome.
18:04:47 <ertes> alright
18:04:51 <buglebudabey> does anyone here have a hakyll site with a comment section for their posts?
18:05:20 <dfeuer> I don't think anything I've done could affect arrays but not STRefs, but I could be wrong.
18:05:24 <Axman6> buglebudabey: yes
18:05:34 <buglebudabey> Axman6 do you use disqus or something else
18:05:35 <Axman6> buglebudabey: I just use Disqus
18:05:39 <buglebudabey> ah ok
18:05:55 <Axman6> works quite well, for the one comment I've got so far =)
18:05:58 <buglebudabey> i was thinking about disqus, it seems easy enough, but part of me wants to own my comments
18:06:01 <dfeuer> monochrom: yes, he does; I'm only interested in the STRef one at the moment because I think the GHC test suite could use a few tests of lazy ST. Especially since I'm making non-trivial modifications to it.
18:06:19 <Axman6> means I can host everything on S3 behind CloudFront
18:06:20 <monochrom> Yes, now I remember ertes's message on haskell-cafe
18:06:24 <dfeuer> monochrom: if you have time for a code review, I'd certainly be appreciative. 
18:06:31 <buglebudabey> Axman6 i have no clue what those are
18:06:32 <dfeuer> That was my message, I believe?
18:06:36 <Axman6> buglebudabey: kinda defeats the whole static site idea no?
18:06:50 <buglebudabey> Axman6 i don't mind doing some work if it's worth it
18:07:06 <Axman6> well, you'll need a web service too then
18:07:09 <ertes> dfeuer: if necessary it shouldn't be too difficult to shoehorn an array in somewhere
18:07:15 <monochrom> Yikes, your message yes.
18:07:41 <dfeuer> ertes: if you like; I'd be more interested if you can find a (preferably non-trivial) way to shoehorn fixST in.
18:07:44 <buglebudabey> Axman6 yeah i guess if it ever becomes popular enough it may make sense to switch but until then i guess disqus is alright, what would i do with comments i own anyway other than look at them
18:07:51 <ertes> dfeuer: yes, definitely
18:07:55 <dfeuer> Woohoo.
18:08:06 <Axman6> (S3 is Amazon's simple storage service, it's amazon's file storage and static file hosting service, CloudFront is their content distribution network)
18:08:20 <dfeuer> ertes: do you have a guess as to how long this might take? Are we talking minutes/hours/days/weeks?
18:08:22 <buglebudabey> Axman6 ah i just host mine with github
18:09:11 <buglebudabey> ertes dfeuer i haven't heard this term shoehorn used this way, what do you mean by it
18:09:21 <ertes> dfeuer: if you stick around for a while, you might see a working test case =)
18:09:37 <dfeuer> buglebudabey: a shoe horn is a device for cramming a foot into a shoe when it doesn't seem to fit.
18:09:49 <buglebudabey> well i know what a shoe horn is
18:09:53 <buglebudabey> but in this context
18:10:00 <buglebudabey> you mean to fit it into your code?
18:10:00 <ertes> buglebudabey: arrays are useless here, but i can use them anyway, if i want to…  it's just not a proper use case for arrays
18:10:00 <dfeuer> Shoehorning is putting something in "by force" when it doesn't necessarily fit.
18:10:12 <buglebudabey> gotcha
18:10:31 <buglebudabey> i just don't wear dress shoes, never have to use a shoe horn now
18:10:50 <buglebudabey> weddings? sandals
18:10:54 <dfeuer> buglebudabey: I think this particular usage may be American slang.
18:12:39 <orzo> yeah, i know the slang shoehorn but never encountered or thought about it that there's an actual device called a shoe horn
18:16:28 <monochrom> Sometimes it is called bootstrap. And not the "boot up the OS" kind. Nor the "write the first Haskell compiler in history" kind.
18:23:34 <orzo> I have pattern (:->) defined in a module but when i try to import it with pattern (:->) syntax, it balks
18:23:44 <orzo> what's the right syntax for importing this?
18:24:10 <monochrom> Do you have enough number of parentheses?
18:24:37 <orzo> import Data.Wrapper.PSQ (PSQ, pattern (:->))
18:25:06 <orzo> is that high enough?
18:26:18 <monochrom> Let me read the user guide carefully. I am wonderng if they want PSQ((:->))
18:26:58 <orzo> but PSQ and :-> are not closely related
18:27:07 <monochrom> Ah OK.
18:27:59 <orzo> there is a type called Binding that :-> can produce, but when i defined it, i used "type Binding =" seperate than the "pattern (:->) :: k -> p -> Binding k p" line
18:28:55 <monochrom> They may want you to write Binding((:->))
18:29:10 <ertes> dfeuer: what's the proper way to add a finaliser to an STRef?  ideally one that runs in ST within the same thread, but not necessarily
18:29:11 <monochrom> I am not 100% certain, but worth a try
18:29:22 <ertes> (same state thread that is)
18:29:45 <ertes> dfeuer: i tried adding it to the underlying MutVar#, but GHC doesn't like that
18:29:52 <orzo> does not export ‘Binding(type (:->))
18:30:03 <ertes> dfeuer: and i'm not sure whether adding it to the STRef itself is safe
18:30:49 <orzo> oh wait sorry
18:30:57 <orzo> i think I failed to enable PatternSynonyms
18:31:09 <dfeuer> ertes: what do you mean by a finalizer?
18:31:18 <ertes> dfeuer: as in Weak
18:31:21 <orzo> my original syntax is fine
18:31:45 <monochrom> OK nice.
18:31:56 <dfeuer> ertes: GHC weak references smell kind of flaky. Why do you need that?
18:33:15 <dfeuer> ertes: it probably *should* be safe to add it to the underlying MutVar# using unsafeCoerce#, but that's only based on my memory of what edwardk told me about MutVar#. I dunno if we want something so weird in the test suite.
18:33:46 <ertes> dfeuer: yeah, i think i'm overengineering this at this point
18:34:15 <ertes> dfeuer: when a behaviour ceases to exist, the events it's based on should no longer notify it
18:34:47 <dfeuer> ertes: small test case better :P
18:34:54 <ertes> yeah =)
18:34:56 <dfeuer> Just as long as it's just weird enough.
18:35:04 <dfeuer> And relies maximally on the laziness of lazy ST.
18:42:03 <ertes> dfeuer: do you want to have unsafeIOToST in there?
18:42:11 <ertes> (with a proper use case)
18:42:41 <ertes> (adds 20 LoC)
18:43:46 <dfeuer> ertes: yeah. If it works with the current implementation, I'd like to know if I break it.
18:43:59 <dfeuer> I can't swear I won't, but it'd be good to know.
18:44:25 <dfeuer> If you can make sub-tests that test these different things that'd be even better, so I can track down a problem if I run into one.
19:11:37 <dfeuer> ertes: me must to going home now. Got meeting in morning. lambdabot knows where to find me.
19:15:23 <orzo> there should be a prelude name for (return ())
19:18:13 <orzo> since (return ()) is a common do-nothing default, it feels wrong to have all the awkward parenthesis
19:18:27 <dibblego> void
19:19:02 <orzo> void is the wrong type
19:19:26 <dibblego> I have never written return () in 12 years of writing production haskell
19:19:52 <dibblego> because void exists, and even then, that's rare
19:20:00 <dfeuer> <$
19:20:07 <ertes> dfeuer: just as i finished a working implementation =P
19:20:12 <dfeuer> ertes: oh, really?
19:20:13 <dfeuer> OK.
19:20:17 <dfeuer> Well, I got glued to my chair.
19:20:18 <Koterpillar> orzo: use void and remove the last line (which would be "return ()")
19:20:21 <dfeuer> So ... show me?
19:20:25 <orzo> i frequently use it for exception handlers or fail cases for things like 'maybe', 'either', and 'bool'
19:20:38 <dibblego> use void instead
19:21:03 <Koterpillar> unless it's the only thing that you have
19:21:11 <Koterpillar> > void undefined
19:21:13 <lambdabot>  error:
19:21:13 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M682050353230...
19:21:14 <lambdabot>        prevents the constraint ‘(Show (f0 ()))’ from being solved.
19:21:19 <dfeuer> ertes: link?
19:21:33 <dfeuer> void undefined? That's totally different.
19:21:47 <Koterpillar> void $ return undefined
19:21:55 <orzo> void undefined isn't going to save me much parens
19:22:01 <Koterpillar> parens, yes
19:22:03 <Koterpillar> typing, no
19:22:06 <dibblego> orzo: show the code, let's fix it
19:22:14 <ertes> dfeuer: here is the FRP implementation: https://gist.github.com/esoeylemez/02bd5e00fcccdbf284ba632eff4efe2a
19:22:27 <dfeuer> ertes: I'll have a look tomorrow. Thanks again!
19:22:28 <ertes> it's a bit messy, but it works (the cache stuff is commented out, because it's buggy)
19:22:34 <orzo> well, here's an awkward line of code: flip (withAsync g) (return ()) $ atomically $ do
19:22:43 <dfeuer> Oh boy. Long.
19:23:16 <ertes> dfeuer: yes…  there is a lot of stuff i ended up not using
19:23:27 <ertes> dfeuer: i'll make a minimal version
19:23:46 <dfeuer> ertes: so the unsafe stuff seems to actually not be used?
19:24:05 <ertes> dfeuer: yeah…  right now everything is safe, but it's just a minor bug that needs to be fixed
19:24:21 <ertes> dfeuer: here is a test case: app ev = do rec bx1 <- scan 1 (fmap (+) (tag (const <$> bx1) ev)); pure (tag (const <$> bx1) ev)
19:24:26 <ertes> that one can be used with 'react'
19:24:47 <ertes> this works: main = print . take 10 . react app $ [1..]
19:25:26 <dfeuer> ertes: gotta runnnnnnnn. I don't know what that means. Can't read it now.
19:25:31 <dfeuer> Gotta run for reals!
19:25:33 <dfeuer> BYE
19:25:37 <ertes> dfeuer: bye =)
19:25:50 <orzo> hm, i guess for this code i need (const $ return ())
19:32:38 <orzo> instead of (const $ return()) I can use (void . return)
19:33:19 <orzo> i do like the latter better
19:59:37 <begriffs> Is it possible to build a cabal file which has a test-suite but no library or executable?
19:59:56 <begriffs> I keep getting errors about it not finding the Main module, but my test has a one.
20:00:11 <orzo> try using Main-is
20:00:28 <begriffs> Tried that :(
20:00:31 <xpika> is there a version of getChar that will return 1 character and not just 1 grapheme ?
20:00:39 <begriffs> But earlier in the build it says "No executables and no library found. Nothing to do."
20:00:47 <orzo> do you mean 1 byte, xpika?
20:00:51 <begriffs> So maybe it is giving up before even building things from the test-suite.
20:01:11 <orzo> probably Data.ByteString.Char8 has it
20:01:22 <xpika> orzo: I mean a character, including its diacritics
20:01:33 <Koterpillar> xpika: what do you want to use it for?
20:01:58 <Koterpillar> (also, I think Unicode defines a "grapheme cluster")
20:03:03 <Koterpillar> xpika: and how many graphemes do 힌 and ジ have?
20:04:02 <begriffs> Ah my problem is an instance of https://github.com/commercialhaskell/stack/issues/2862
20:04:52 <xpika> Koterpillar: they both have 1
20:04:56 <xpika> °͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌͌ has 26
20:05:44 <Koterpillar> then I don't think you'll find that function anywhere
20:05:44 <xpika> getChar only returns the first one
20:06:04 <xpika> Koterpillar: you have searched all of hackage have you ?
20:07:01 <Koterpillar> nope, what I'm trying to say is, it's unlikely someone else had the same (guessing invalid) understanding of Unicode as you
20:08:01 <Koterpillar> xpika: note that ㅎㅏㄴ can be combined to look like what I posted earlier
20:08:19 <xpika> Koterpillar: you mean "valid"
20:08:39 <Koterpillar> I mean "likely not corresponding to the definitions in the Unicode standard"
20:08:49 <Koterpillar> and no, I haven't read all of the standard
20:09:23 <Koterpillar> OK, re-reading what you said, I _think_ you want a grapheme cluster
20:11:21 <Koterpillar> xpika: I'd start with Data.Text.ICU
20:11:25 <orzo> is a character the same as a grapheme
20:11:47 <orzo> google told me "The collection of characters to make up a glyph is a grapheme cluster."
20:12:02 <orzo> which doesn't really add a lot of clarity heh
20:12:16 <Koterpillar> orzo: you don't really want to deal with characters
20:13:02 <Koterpillar> ironically, as a concept they are less useful than grapheme clusters and code points
20:14:15 <orzo> does getChar mean grapheme or code point?
20:14:26 <orzo> probably codePoint
20:14:31 <Koterpillar> Char is a code point AFAIR
20:14:41 <orzo> i think Char is only a 32bit primitive
20:31:27 <Maxdamantus> Char theoretically has about as much to do with a character as Word8 does.
20:31:46 <Maxdamantus> One just happens to be able to represent more characters than the other in one unit.
20:56:50 <orzo> if i use 'length' and 'reverse' together, will the compiler figure out to do that in one loop?
21:13:08 <Axman6> no
21:13:35 <Axman6> there are implementations of reverse which may allow that but the standard foldl does not
21:15:07 <Axman6> it could be added as a RULE, but that might break other things
22:13:25 <qmm> how can i write: 2 + 2 \ -- some documentation
22:13:40 <qmm> + 3 + 3 \ -- some more documentation
22:13:50 <qmm> * 2 -- further documenation
22:13:53 <Axman6> things which alls documentation -- ^ Some docs
22:14:07 <Axman6> allows*
22:14:17 <Axman6> I don't think you can quite write it like that though
22:14:35 <Axman6> (assuming you want this in haddock)
22:16:00 <pavonia> And you can't have any documentation for expressions, can you?
22:16:08 <lpaste> qmm pasted “example.hs” at http://lpaste.net/351786
22:17:12 <pavonia> qmm: What's wrong with this?
22:18:16 <Axman6> qmm: what result do you want from what? afaict that works
22:18:35 <Axman6> you might need to align the * with the 2 though
22:18:49 <Axman6> hmm, probably not
22:20:51 <qmm> Axman6: forgot to paste the error, here it is http://lpaste.net/9161310433737441280
22:20:59 <qmm> pavonia even
22:21:37 <pavonia> Ah right, putStrLn is expecting a String but you're giving it a number
22:21:48 <pavonia> > show (2 + 2)
22:21:50 <lambdabot>  "4"
22:21:53 <Axman6> oh good catch
22:22:02 <Axman6> you want print qmm
22:22:07 <Axman6> :t putStrLn
22:22:09 <lambdabot> String -> IO ()
22:22:11 <Axman6> :t print
22:22:13 <lambdabot> Show a => a -> IO ()
22:23:21 <qmm> oh, right!
22:26:09 <Axman6> make sure you check the location of errors in error messages ;)
22:35:51 <qmm> is there an equivalent of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow for haskell? i need to move a decimal place two places to the right, but i'm told (without really understanding) that multiplying something by 100 isn't a generic enough solution 
22:36:45 <qmm> Math.pow(10,2) is how i could do it with that function from js
22:36:59 <wei2912> qmm: i don't see what's the point of using Math.pow(10, 2) when it's 100
22:36:59 <kadoban> qmm: Is this for output, or?
22:37:05 <qmm> 3.43343 * Math.pow(10,2) rather
22:37:09 <kadoban> And what type are you using? Double or something?
22:37:10 <wei2912> qmm: wait a moment, isn't this #haskell
22:37:16 <wei2912> oh, i see what you mean
22:37:23 <liste> > 5^3
22:37:25 <lambdabot>  125
22:37:38 <davean> qmm: oh, do you want to move it in a SPECIFIC base? whatever base that happens to be?
22:37:39 <liste> > 5**3
22:37:41 <lambdabot>  125.0
22:37:53 <qmm> kadoban: i don't actually know, a fractional of some sort
22:38:04 <liste> qmm: those 2 operators, ^ and **
22:38:14 <liste> :t ((^), (**))
22:38:15 <wei2912> probably stick with ^
22:38:16 <lambdabot> (Num a, Integral b, Floating a1) => (a -> b -> a, a1 -> a1 -> a1)
22:38:31 <wei2912> if you're using Fractional
22:39:06 <qmm> liste, wei2912: thought & and ** were for exponentiation. i didn't realize you could change bases 
22:39:20 <kadoban> "pow" is exponentiation
22:39:47 <qmm> ah 
22:40:32 <liste> "pow" is short for "power" or "to the power"
22:41:20 <qmm> > 2.3433 * (10 ^ (2))
22:41:23 <lambdabot>  234.33
22:41:35 <qmm> thanks!
22:42:22 <qmm> the extra parens were left over from me playing with negative numbers
22:49:40 <bobsterman> I'd like to use haskell with a C++ for a project, and trying to get C++ to call haskell functions.
22:50:02 <bobsterman> I have been following this (https://github.com/jarrett/cpphs) guide, but want to usee cmake instead of make
22:50:19 <bobsterman> just having troubule using cmake with haskell
22:57:44 <orzo> ghc user guide mentions a special function called 'oneShoot' and links to haddock for GHC.Exts which shows no exported 'oneShoot' function
22:59:28 <orzo> i guess i'ts in GHC.Magic
23:06:26 <qmm> > takeWhileL (<2) [1..5]
23:06:28 <lambdabot>  error:
23:06:29 <lambdabot>      • Variable not in scope:
23:06:29 <lambdabot>          takeWhileL :: (Integer -> Bool) -> [Integer] -> t
23:08:59 <opqdonut> bobsterman: without knowing cmake that well, it seems to me like you could just add a custom rule for the .hs -> .o ghc compilation, and then add all the necessary LDFLAGS for the linking phase
23:17:03 <bobsterman> opqdonut: Thanks, ill look at doing that. I having trouble finding the libraries in my filesystem anyway
23:47:00 <somewone> does anyone know a non GPL licensed mqtt library for haskell ?
23:47:14 <somewone> mqtt-client library*
