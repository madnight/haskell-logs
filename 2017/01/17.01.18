00:07:49 <delYsid> cocreature: Oh, haven't thought about that.  Is there any difference between ParserT (RWS ...) and RWST ... Parser ?
00:08:18 <delYsid> I mean, in behaviour, that I should be aware of?
00:08:40 <johnw> I think it will make a difference when using <|>
00:08:51 <cocreature> yep
00:09:11 <cocreature> delYsid: I have an example of StateT ParserT and ParserT StateT for megaparsec https://github.com/simonmichael/hledger/pull/366#issuecomment-232079895
00:09:46 <cocreature> there is no clear answer as to what is correct. it depends on your usecase.
00:18:06 <delYsid> johnw: I was exactly afraid of that.  Now I just need an intuition for *what* is different.
00:18:28 <johnw> if Parser is on the "outside", then state changes will carry across <|>
00:19:20 <cocreature> runParser (flip evalStateT 0 (((modify (+1) >> fail "") <|> modify (+1)) >> get)) "" "" will return 1, flip evalState 0 $ runParserT (((modify (+1) >> fail "") <|> modify (+1)) >> get) "" "" will return 2
00:20:32 <delYsid> johnw: And that is exactly not what I need :-(  So I need a typeclass for parsing then?
00:20:56 <johnw> or do what cocreature demonstrated, and put it on the inside
00:22:43 <cocreature> delYsid: you could just "lift" your parser. however that means that you don‚Äôt get access to the state in your parser
00:23:06 <delYsid> cocreature: I know, that is sort of my problem.
00:23:21 <cocreature> you can workaround this my manually passing the state to your parser or use something like monad-control to handle this for you
00:23:25 <delYsid> johnw: Yes, but that backs me into a corner regarding lifting.
00:23:41 <johnw> yes, it changes what you can express
00:24:22 <delYsid> OK, so it looks like using the parsers package in Haskell was really the best solution to the dillema, everything else looks quite hackish or even impossible.
00:27:09 <uiop> delYsid: what are you parsing?
00:28:18 <johnw> I think I had it reversed, if Parser is on the "inside", state carries over <|>, based on what cocreate wrote
00:31:43 <cocreature> johnw: the good part is that it‚Äôs not entirely clear what ‚Äúbeing on the inside‚Äù means so you can always claim you‚Äôre right :)
00:32:08 <johnw> :) except that where the 'runParser' goes kind of clinches it...
00:32:14 <johnw> as you have shown, code beats description
00:32:33 <pikajude> oh wow, did ghc 8.0.2 fix the determinism bug?
00:32:47 <johnw> pikajude: indeterminate so far
00:32:50 <johnw> j/k
00:47:55 <delYsid> uiop: Braille music notation.
00:58:11 <YellowOnion_> how does one check which version of a package is installed with stack?
01:06:23 <MarcelineVQ> usually  stack list-dependencies  in a project or  stack exec -- ghc-pkg list
01:12:36 <tsahyt> hello! I was wondering how I'd serve images through servant with regards to the content-type. When I just use OctetStream, the browser doesn't recognize it as an image of course. So I could define content types for various image formats that I want to support, but now the question is how to use multiple content types in a Get verb and how to serve the right one?
01:14:17 <tsahyt> my use case here is just a simple private image host with a CLI interface
01:17:17 <MarcelineVQ> I guess you'd need to make your own mime handler https://hackage.haskell.org/package/servant-0.9.1.1/docs/Servant-API-ContentTypes.html between examples there and https://www.sitepoint.com/web-foundations/mime-types-complete-list/ you might be able to make something work, I've not used servant really though so idk
01:18:23 <MarcelineVQ> I realize that doesn't address your actual question :(
01:18:24 <tsahyt> MarcelineVQ: that's what I've been doing, but the mimeRender function cannot fail, so I don't know how I would chose the correct content type
01:18:55 <tsahyt> on getting the image that'd be easier, because unrendering returns an Either and so I suppose servant just tries until one succeeds or all failed.
01:19:20 <tsahyt> or well, actually the content type must be set to one anyhow, so either that fails or not
01:19:38 <tsahyt> but when sending it back I don't know how to choose the right type
01:20:25 <tsahyt> or maybe I'm just barking up the wrong tree entirely and there's a better way to do it
01:50:29 <lonokhov> argh, I wish there was a -XExplicitLetRec extension. Spent a day looking for a bug in wrong place. Well, I also need a better testsuite and logging.
01:50:31 <tsahyt> @hoogle String -> Data.ByteString.Lazy.ByteString
01:50:34 <lambdabot> Data.ByteString.Lazy.UTF8 fromString :: String -> ByteString
01:50:34 <lambdabot> Data.ByteString.Lazy.UTF8 toString :: ByteString -> String
01:50:34 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
01:50:43 <tsahyt> ah there it is
01:51:22 <tsahyt> oh that's not in bytestring
01:57:55 <MarcelineVQ> usually you're dealing with somethng called encoding when taking written text to bytestring so searching for that might have better options
02:01:01 <Cale> Yeah Data.Text.Encoding.encodeUtf8 is probably what you're looking for
02:01:28 <Cale> (combined with Data.Text.pack, if you're starting from String)
02:02:17 <tsahyt> MarcelineVQ: I ended up using that because I already had it imported, but it was really just about prepending a timestamp to some binary data before hashing it
02:02:40 <MarcelineVQ> neato, what are you using to hash?
02:03:13 <tsahyt> MarcelineVQ: Data.Digest.Pure.SHA, because it has the simplest interface of the sha1 implementations I could find. I really just need some unique identifier for a paste/upload.
02:03:45 <tsahyt> and because file uploads have a limited number of clicks that get stored and updated accordingly in the database I need to make a difference between them even if they contain the same data
02:03:56 <MarcelineVQ> ah cool, I was looking at similar recently but crc ended up being good enough for me
02:04:25 <tsahyt> yeah, sha1 is really massive overkill here, but it was just the first thing I found
02:05:48 <tsahyt> I might end up rolling this all into a blog post about writing a simple pastebin with servant and persistent. There's not yet enough material on servant out there, so somebody might find it useful to see how to use the two together. I just found a github repository with an example project, and that was about it.
02:06:10 <MarcelineVQ> I'm sure someone would find it useful
02:07:07 <tsahyt> before I do that, I want a working implementation with some more features though, like file uploads and an image host. It's not that there aren't any existing solutions out there but it's fun to work with servant a bit and see how it works.
02:27:32 <MrMonad> hi guyz
02:28:06 <MrMonad> does anyone know how to use bind (>>=) but evaluating on Left for the Either type? or any equivalent functions that can achieve that
02:28:47 <cocreature> MrMonad: what do you mean by ‚Äúevaluating on Left‚Äù? could you give an example of what you are trying to achieve?
02:29:29 <jchia> :i swapEither
02:29:34 <jchia> :t swapEither
02:29:37 <lambdabot> error:
02:29:37 <lambdabot>     ‚Ä¢ Variable not in scope: swapEither
02:29:37 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
02:29:46 <seequ_> I guess they're looking for `either`
02:30:15 <MrMonad> like if im not mistaken doing >>= works only for Right. but right now my value of interest is in Left
02:30:16 <jchia> :m +Data.Either.Combinators
02:30:23 <jchia> :t swapEither
02:30:31 <lambdabot> error:
02:30:31 <lambdabot>     ‚Ä¢ Variable not in scope: swapEither
02:30:31 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
02:30:56 <cocreature> MrMonad: so you are just trying to swap the roles of Left and Right?
02:31:09 <jchia> MrMonad: Well, there's swapEither if you want to map a Either a b to an Either b a. Then the >>= will be working on what used to be the left side
02:31:30 <Cale> MrMonad: Well, if possible, arrange so that the successful values you're interested in are always marked with Right. Otherwise, either Right Left will swap them for you.
02:31:37 <Cale> :t either Right Left
02:31:39 <lambdabot> Either b a -> Either a b
02:32:16 <Cale> MrMonad: There's no choice about what the Monad instance does:
02:32:19 <Cale> :t (>>=)
02:32:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:32:26 <Cale> If you have m = Either e
02:32:40 <Cale> Then that specialises to  Either e a -> (a -> Either e b) -> Either e b
02:34:53 <Cale> Of course, you could perversely redefine Either such that it was  data Either e a = Left a | Right e, but that's just needlessly confusing.
02:35:50 * ggVGc bans monads
02:36:01 <Cale> ?
02:36:07 <ggVGc> sorry
02:41:04 <seequ_> ggVGc: Removing everything seems rude
02:41:28 <haskell395> guys, i got disconnected somehow
02:41:31 <haskell395> im MrMonad btw
02:41:59 <haskell395> thanks for the help i looked through some of the options and i think whenLeft might work for me
02:44:06 <haskell395> and to clarify things, i wasn't trying to swap Left and Right from its use. Right is the valid computation. and Left contains values that determines how the computation has failed. what i was attempting was to use those values and retry the computation
02:44:47 <cocreature> haskell395: it seems like you just want to pattern match in that case instead of using >>=
02:44:58 <haskell395> preferably without pattern matching or using case of.. which is why i wanted to figure out if i could use bind on left, but from what it seems: whenLeft might do it
02:45:05 <haskell395> yeahhh, its already working with pattern matching
02:45:11 <haskell395> was trying to cut down liness of code
02:48:46 <tsahyt> how can I add a header to the response using servant? I'd like to have a Content-Disposition header
02:49:52 <seequ_> haskell395: Right, sounds like you want just either
02:50:02 <seequ_> :t either
02:50:04 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:53:04 <merijn> haskell395: Do you have many Either's and want to collect all the errors in one place for easy retrying?
02:55:08 <merijn> I was thinking he wanted Validation, but now I'm think he most likely wants something different than I've personally wanted too. Which is, I suppose, more like tuple that collects all failures AND all successes
02:59:31 <Arban> I just started out with Haskell, playing around a bit to see what's possible. Is there any way of making something like this work:
02:59:34 <Arban> [ (a,b) | a <- [1..], b <- [1..], a*b == 7]
03:00:08 <Arban> Or do you have to use finite lists for these kind of problems?
03:00:33 <jaspervdj> Arban: it depends... do you only want one solution, or all possible solutions?
03:01:13 <Arban> All possible. Or just a few.
03:01:33 <jaspervdj> Yeah then you need some sort of upper limit
03:01:36 <MarcelineVQ> what output are you expecting?
03:02:19 <cocreature> Arban: you can produce an infinite list of all results but you need to think of a way to walk through the two lists such that you reach every combination of numbers in finite time
03:08:46 <Arban> Ok. I'm a little bit confused. I thought the point of languages like this was to think in terms of what you want, and not how the result is actually produced. But I guess you can't get away from that?
03:09:54 <seequ_> Arban: You still have to define what you want.
03:10:07 <seequ_> And infinity is hard to define.
03:11:29 <tsahyt> Arban: what you're looking for here is a constraint solver. yeah there are ways to make this work but it won't be a list comprehension.
03:12:01 <tsahyt> I'm not aware of any decent CSP libraries for haskell though, but in principle you can make it work
03:12:17 <tsahyt> you can possibly even make it work with a more general monad comprehension and reuse the same syntax, but I'm not entirely sure about that
03:13:18 <tsahyt> Arban: in your specific case, there are only two (non-negative) integer solutions anyhow
03:13:45 <Arban> Oh wait, that's a typo. It's supposed to be a+b
03:14:14 <tsahyt> now there are more, yes.
03:14:19 <seequ_> Well, 5 then
03:15:10 <tsahyt> Arban: but even most constraint programming languages either don't work over infinite domains at all or they have very limited support for it
03:15:11 <Cale> Arban: You have described a particular list, it's just that the list has elements in a particular order.
03:15:35 <EvanR> "i want an enumeration of some infinite set"
03:15:54 <EvanR> and then defined it wrong... doesnt reach everything
03:16:08 <EvanR> so its still "what i want"-based
03:16:13 <Cale> Arban: and so no element of that list has a value of a which is greater than 1, simply because there are infinitely many values of b which have to come before any pair whose first component would be 2
03:19:45 <Arban> Yeah, I realize what's happening. I'm just confused by the fact that I actually have to think that way. This is the second course I've taken where we deal with a functional language, and we have zero focus on how the stuff is actually being done, even though you run into problems like this all the time of you don't think about what's going on in the background.
03:20:58 <EvanR> Arban: this isnt a background thing, its just the idea of a listing of infinite things
03:21:04 <Cale> Well, the background still matters when it comes to performance, but this isn't a background distinction
03:21:15 <Cale> This is a matter of *which list you're describing*
03:21:33 <EvanR> if you think about it, it has to be. an infinite set doesnt just have some ordering of its own
03:21:35 <tsahyt> Arban: I think what you expect is the language being smarter than it can really be. the compiler (or ghci for that matter) has no way to prove that for a given a, there can be no more bs such that the constraint is still satisfied
03:21:41 <tsahyt> so it can't just move on.
03:22:05 <Cale> You can make this same mistake in pure mathematics
03:23:58 <EvanR> there are other kinds of searchable spaces, a simple listing isnt the only way. but "all pairs of numbers" isnt one of them as is
03:24:16 <Cale> Well, no, you *can* have a list of all pairs of numbers
03:24:25 <Cale> All pairs of natural numbers or integers
03:24:30 <Cale> But not in *this* order
03:24:35 <EvanR> right, now what i was saying at all
03:24:35 <tsahyt> Arban: but just to illustrate that when you do have that reasoning power, you can do something like this. here's a solution using the sbv package, which uses an SMT solver underneath
03:24:37 <EvanR> not*
03:24:50 <EvanR> "all pairs of number" as a vague concept
03:24:52 <tsahyt> allSat $ \(a :: SInteger) (b :: SInteger) >- a + b .== 7
03:24:52 <EvanR> not a listing
03:24:58 <tsahyt> this will start enumerating all possible integer solutions
03:25:03 <tsahyt> of which there are of course infinitely many
03:25:18 <tsahyt> ->, not >-
03:25:21 <tsahyt> sorry for the typo
03:25:57 <tsahyt> you can get all non-negative solutions using allSat $ \(a :: SInteger) (b :: SInteger) -> a .>= 0 &&& b .>= 0 &&& a + b .== 7
03:26:26 <tsahyt> now there are finitely many. for me it gives 8 solutions which is correct unless I've forgotten a lot about maths
03:26:29 <Cale> If you want to define a bijection f: N -> N x N, it doesn't suffice to say f(0) = (0,0), and whenever f(n) = (a,b), pick f(n+1) = (a,b+1)
03:26:43 <EvanR> you can also have a tree of layers where each layer is a collection of pairs with a certain max component
03:26:46 <Cale> That will inductively define a function, but it won't be a surjection
03:27:58 <tsahyt> you can also extract the results from the SMT model that you get of course. but overall, this is somewhat involved compared to thinking about upper bounds.
03:28:49 <EvanR> and infinite isnt the only issue!
03:29:08 <EvanR> "all finite sets have a listing without duplicates" implies excluded middle
03:29:44 <Cale> > let (x:xs) /\/ ys = x : (ys /\/ xs) in foldr (/\/) [] [[(x,y) | y <- [0..]] | x <- [0..]]
03:29:46 <lambdabot>  [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0,...
03:30:09 <Cale> ^^ that ordering is extremely biased, but will eventually hit everything
03:30:41 <EvanR> anything, maybe not everything ;)
03:30:45 <Cale> Every other element has 0 in the first component, and then every other element of what remains has 1, and so on
03:32:35 <Arban> Ok, thanks everyone! Now I have a lot to think about.
03:32:58 <Cale> > [(x,s-x) | s <- [0..], x <- [0..s]]
03:33:00 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
03:33:11 <Cale> ^^ a fairer ordering
03:33:37 <Cale> (it enumerates all the elements having a given sum before moving on to the next)
03:34:15 <EvanR> best strategy is to order them with the solution at the beginning !
03:34:31 <tsahyt> Cale: isn't that either the same or really similar as diagonalization?
03:34:34 <Cale> Just reverse the list, you'll find it faster ;)
03:34:42 <Cale> That's the same as diagonalisation
03:34:58 <tsahyt> right, each pair on a given diagonal has the same sum
03:35:03 <Cale> yeah
03:35:54 <EvanR> i see it as a pyramid
03:35:59 <Cale> Bonus exercise: work out how to do the snakey version of the diagonals, where you go down one diagonal and up the next.
03:36:11 <EvanR> each level is not diagonal but horizontal
03:36:53 <Cale> Or better exercise: do the diagonals as I gave them without involving arithmetic
03:37:15 <Cale> (as a function [a] -> [a] -> [(a,a)] perhaps)
03:40:07 <EvanR> alternatively, what i want could be a sequential traversal of two copies of N, which might place the location of my solution at an infinite ordinal number of steps
03:40:32 <EvanR> which the computer takes literally
03:43:36 <fizbin> Cale: or the really advanced, annoying version: order the pairs in order of non-decreasing distance from the origin.
03:48:54 <YellowOnion_> I've put strictness annotations everywhere used 'force' all over the place, and my structure is still leaking far too much, what could I possibly be doing wrong?
03:49:43 <fizbin> > concatMap (\x -> ap zip reverse [0..x]) [0..]
03:49:46 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
03:50:43 <fizbin> (That's Cale's diagonals without arithmetic)
03:55:48 <EvanR> YellowOnion_: putting annotations on the wrong thing
03:56:14 <EvanR> or using an algorithm which has to use lots of memory
03:56:47 <cocreature> YellowOnion_: maybe you are explicitely holding on to something and thereby preventing it from being garbage collected?
03:58:06 <YellowOnion_> The thing is, if I use /print/ it fixes a major space leak.
03:59:10 <YellowOnion_> If I use force on the exact some structure nothing happens.
04:00:05 <jaspervdj> YellowOnion_: Are you using something like deepSeq?
04:00:13 <merijn> YellowOnion_: I think that basically means you're not doing what you think you're doing by adding "force", but it's hard to say what's going on without some example
04:01:43 <cocreature> YellowOnion_: note that "force" alone does not magically start evaluation. all it does is that _if_ the expression is evaluated to whnf it will instead be evaluated to nf
04:01:52 <cocreature> YellowOnion_: if you want to force evaluation there is "evaluate"
04:02:00 <cocreature> e.g. try replacing print by evaluate . force
04:02:45 <Cale> fizbin: B... but how does that work if there's no Num instance for the list of elements you're picking pairs of?
04:06:04 <YellowOnion_> cocreature, putting in evaluate seems ugly, do I have to remplment Vector.fromList to get this to not go mental?
04:06:44 <cocreature> YellowOnion_: it‚Äôs really hart to tell you what the proper solution is without seeing at least parts of your code. I don‚Äôt see how reimplementing Vector.fromList would help
04:06:49 <fizbin> Cale: Can I assume an Enum instance?
04:06:50 <seequ_> That's one more word
04:08:13 <YellowOnion_> cocreature, I'm trying to clean up my code a bit before I post it.
04:09:31 <fizbin> Cale: Though I guess that's not, strictly speaking, necessary. Hold on...
04:11:13 <fizbin> > concatMap (zip <*> reverse) . inits¬†$ [0..]
04:11:15 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
04:12:48 <fizbin> That's only diagonals of one infinite list with itself, no arithmetic. Diagonals combining two lists might be a bit trickier.
04:12:56 <NextHendrix> > mapM (\_ -> "hello") (Just 5)
04:12:59 <lambdabot>  [Just 'h',Just 'e',Just 'l',Just 'l',Just 'o']
04:14:00 <YellowOnion_> cocreature, OK, I think I figured it out, I need to put force before an IO action but after the causer of the space leak.
04:16:20 <kuribas> what program transformations are valid under call by name, but not under call by value?
04:17:21 <merijn> kuribas: Well, if we assume mutable (but not global) data then reordering function calls is valid in call by value, but not call by name
04:17:38 <merijn> Assuming those calls don't rely on each other's results
04:17:54 <YellowOnion_> cocreature, having it after I put it in to the Vector was probably my issue.
04:18:04 <kuribas> merijn: and assuming pure functions?
04:18:39 <merijn> kuribas: Or we just considering denotational semantics or also operational?
04:18:43 <merijn> s/Or/Are
04:19:05 <merijn> kuribas: Because I would say that, denotationally, those are not distinguishable
04:19:40 <kuribas> merijn: I am just wondering how well ghc's tranformations would work on a strict, pure language.
04:20:53 <merijn> kuribas: Right, so operationally then :)
04:21:07 <kuribas> yeah
04:21:46 <merijn> kuribas: And also, specifically, FROM call by name TO call by value
04:22:05 <merijn> kuribas: I would actually, say "most things except CSE"?
04:22:07 <kuribas> merijn: no, transformation from call by name to call by name.
04:22:20 <kuribas> merijn: I mean value, sorry.
04:23:09 <merijn> kuribas: eh, which one should be value? :p
04:23:55 <fizbin> > concatMap (second reverse >>> uncurry zip)¬†$ (zip `on` inits) [0..] ['A'..]
04:23:58 <lambdabot>  error:
04:23:59 <lambdabot>      ‚Ä¢ No instance for (Num Char) arising from the literal ‚Äò0‚Äô
04:23:59 <lambdabot>      ‚Ä¢ In the expression: 0
04:24:35 <kuribas> merijn: so I have a transformation from call by name to call by name, and I want to know if it holds for call by value to call by value.
04:25:41 <merijn> kuribas: Right, that's what I meant
04:25:54 <kuribas> merijn: oh I see.
04:26:00 <merijn> kuribas: I think the majority should work, except CSE
04:27:45 <kuribas> merijn: what about removing unused arguments?  For example "const x _|_ = x"
04:27:45 <antystenes> Hey. What are the best resources to learn dependent types in haskell?
04:28:02 <kuribas> haskell has dependent types?
04:28:05 <hpc> not yet
04:28:17 <fizbin> > concatMap (second reverse >>> uncurry zip)¬†$ (zip `on` inits) ['0'..] ['A'..]
04:28:18 <antystenes> I should have put this in quotes.
04:28:20 <lambdabot>  [('0','A'),('0','B'),('1','A'),('0','C'),('1','B'),('2','A'),('0','D'),('1',...
04:28:29 <hpc> you should look at the docs for ghc's language extensions
04:28:34 <ertes> antystenes: the singletons paper, if that's not too dense
04:28:39 <kuribas> merijn: but in call by value const x _|_ = _|_
04:28:44 <fizbin> Cale: ^^^ The diagonals without arithmetic, though both lists need to be the same type.
04:29:02 <hpc> and information from proper DT languages should carry over too, for the most part
04:29:28 <ertes> antystenes: as a far more gentle start you could also read the functional pearls paper called "implicit configurations"
04:30:10 <ertes> antystenes: the latter gives you the basic idea of how to move between value and type level, while the former does type-level computation
04:30:36 <kuribas> merijn: makes me wonder if inlining is even valid...
04:30:58 <ertes> antystenes: also make sure that you understand at least one dependently typed language (agda, coq, idris, ‚Ä¶)
04:32:22 <kuribas> merijn: but I suppose ghc has to handle those as well...
04:32:42 <merijn> kuribas: Are you familiar with "Fast and Loose Reasoning is Morally Correct"?
04:32:54 <kuribas> merijn: no
04:33:17 <merijn> kuribas: https://pdfs.semanticscholar.org/a316/3d9097a87a713f0dd3f154f139e19dcb2a82.pdf
04:33:29 <ertes> antystenes: or wait for -XDependentTypes (anywhere between 2 and 10 years) and then just use your existing knowledge‚Ä¶  working with singletons is awkward at best =)
04:33:45 <kuribas> merijn: right thanks
04:33:51 <merijn> kuribas: Basically, it is a formal argument that it's "ok" to ignore bottoms :p
04:34:18 <kuribas> merijn: what if bottom is a meaningful error message?
04:34:32 <kuribas> merijn: not a runaway computation
04:34:37 <ertes> antystenes: if you want to get a taste of what singletons feel like in practice (try to) use the vinyl library for something serious =)
04:34:40 <merijn> kuribas: You are right that lazy programs do not always remain correct when making them strict, but note that that's not actually a problem
04:35:00 <merijn> kuribas: Because if we inline a non-terminating computation in a strict program we already weren't terminating to begin with
04:35:10 <merijn> kuribas: In the underlying theory those are not distinguished
04:35:17 <antystenes> ertes: Singletons are where i'm stuck at when using dependent types in haskell, however they would be really handy to have at my diposition at the moment.
04:35:46 <merijn> kuribas: Note, especially that "case True of True -> throw Foo; False -> throw Bar" is explicitly allowed to throw either Foo *or* Bar
04:36:05 <ertes> antystenes: do some exercises with them‚Ä¶  eventually it clicks
04:36:37 <kuribas> merijn: right
04:37:08 <merijn> kuribas: So that's useful for end-user purposes, but not required by the semantics of Haskell, at least
04:37:13 <antystenes> ertes: thanks for all the advice.
04:37:30 <cocreature> antystenes: iirc stephanie weirich gave a talk at some conference on how to implement a red-black tree that is guaranteed to be correct by enforcing invariants using singletons. that might be useful
04:37:41 <ertes> antystenes: singletons are type families (not in the -XTypeFamilies sense, but in the "parameterised types" sense) that get around haskell's lack of dependent types by just ignoring the value level for the most part, but making sure that each type of the family has exactly one inhabitant, and that inhabitant structurally determines the type-level value uniquely
04:37:44 <merijn> Yes, but it's painful and messy
04:37:49 <ertes> antystenes: hence "singletons"
04:38:11 <merijn> antystenes: As you have probably discovered dependent types are rather painful to fake in Haskell (hence one of the original papers was called "Hasochism")
04:38:25 <fizbin> @pl \a b -> concatMap (second reverse >>> uncurry zip)¬†((zip `on` inits)¬†a b)
04:38:25 <lambdabot> (((second reverse >>> uncurry zip) =<< ¬) .) . (zip `on` inits) ¬
04:38:26 <kuribas> merijn: so if I were to port ghc (or parts) to a strict pure language, this wouldn't normally be a problem?
04:38:28 <cocreature> antystenes: this is it https://www.youtube.com/watch?v=n-b1PYbRUOY
04:38:30 <haskell674> If an Endofunctor is an (a -> a) in category theory, what is a (a -> a) -> a -> a ?
04:38:31 <merijn> antystenes: tbh, if you really want dependent stuff than using a "true" dependent languages is orders of magnitude simpler
04:38:51 <fizbin> Does anyone know what it means when @pl returns something with question marks (?) in it?
04:38:58 <hpc> :t (?)
04:38:59 <lambdabot> error: Variable not in scope: ?
04:39:06 <merijn> kuribas: I would say that it would cause "problems", but more of the "minor annoyance" than "fundamental issue" kind
04:39:13 <hpc> fizbin: can you give an example?
04:39:15 <merijn> kuribas: i.e. it should be reasonably easy to fix them as they occur
04:39:23 <kuribas> merijn: in particular porting the optimizer of ghc to purescript.
04:39:25 <fizbin> @pl \a b -> concatMap (second reverse >>> uncurry zip)¬†((zip `on` inits)¬†a b)
04:39:25 <lambdabot> (((second reverse >>> uncurry zip) =<< ¬) .) . (zip `on` inits) ¬
04:39:26 <kuribas> merijn: right
04:39:57 <hpc> ah, those are unicode capital A with two dots above it
04:40:15 <hpc> which... i still have no idea where that came from
04:40:16 <merijn> kuribas: Actually, the one thing to worry about, I think is that inlining expensive computations by value causes them to run twice
04:40:18 <ertes> antystenes: i agree with merijn‚Ä¶  as i said: working with singletons is awkward at best
04:40:27 <fizbin> hpc: wait, what?
04:40:32 <antystenes> cocreature: Thanks for the video. I think it is one of the most recommended resoruces.
04:40:38 <quchen> :t √Ç
04:40:41 <lambdabot> error: Data constructor not in scope: √Ç
04:40:55 <fizbin> :t √Ñ
04:40:57 <lambdabot> error: Data constructor not in scope: √Ñ
04:41:00 <kuribas> merijn: yeah
04:41:06 <fizbin> :t √§
04:41:08 <lambdabot> error: Variable not in scope: √§
04:41:26 <hpc> fizbin: https://dl.dropboxusercontent.com/u/37707/Untitled.png
04:41:33 <Darwin226> edwardk: Hey ed, you there?
04:42:04 <fizbin> @hpc Are you using ISO-latin-1 ?
04:42:05 <lambdabot> Maybe you meant: src rc pl ghc
04:42:31 <kuribas> merijn: they may run twice also in call by value...
04:43:08 <merijn> Actually, I guess my description makes no sense 
04:43:20 <merijn> Because you can inline the values just fine...
04:43:45 <merijn> hpc: I see A with ^ on top
04:44:11 <merijn> And I know my terminal is doing utf-8 correct, because it handles weird stuff like hebrew just fine
04:44:12 <hpc> hmm, maybe putty is just cutting it off then
04:44:26 <hpc> it has that problem with arrows and stuff too
04:44:35 <hpc> but i haven't seen it cut off vertically before
04:44:44 <MarcelineVQ> why is it printing something it wouldn't accept as input :>
04:45:18 <fizbin> Okay, this is odd. When I switch to ISO-latin-1, I see something different from @pl
04:45:26 <MarcelineVQ> actually I guess it does, nvm, it just doesn't have that symbol defined as something
04:47:00 <merijn> hpc: What I see: http://files.inconsistent.nl/screenshot.png
04:47:40 <fizbin> merijn: What encoding do you view this server with?
04:47:50 <merijn> fizbin: utf-8
04:47:57 <hpc> what font is that? it has some weird strokes that make it look like comic sans
04:48:06 <merijn> hpc: Monaco
04:48:28 <shiona> √Ñ√Ç√§√¢
04:48:31 <merijn> hpc: That's mostly due to being incredibly blown up in that screenshot :p
04:48:37 <hpc> heh
04:48:57 <hpc> :t \a b -> concatMap (second reverse >>> uncurry zip)¬†((zip `on` inits)¬†a b)
04:48:59 <lambdabot> [a] -> [a] -> [(a, a)]
04:49:11 <merijn> hpc: But yes, it's a very "round" font compared to say, Courier New
04:49:30 <hpc> okay, at least it's a valid expression
04:49:46 <merijn> I have to say that it's my favourite fixed-width font by far :)
04:49:46 <hpc> i know pl has issues with things that don't typecheck, and it doesn't actually tell you
04:49:59 <hpc> ah, neat
04:50:23 <hpc> i have been using the droid family and it's great for readability at tiny sizes
04:50:29 <hpc> so my laptop screen feels much more spacious
04:50:31 <merijn> Also, I tend to have a far bigger than font size than many people
04:50:41 <merijn> hpc: See, I don't actually use "tiny" sizes anymore
04:51:09 <merijn> 14pt atm, always gets weird looks from the 10pt Courier New crowd
04:51:22 <merijn> I prefer the "get a bigger screen" approach to having more space ;)
04:51:43 <merijn> hpc: You should invest in a UHD/high-DPI screen laptop :)
04:51:49 <ertes> i use 16pt dejavu sans mono =)
04:51:50 <hpc> yeah, i will probably go that way when i stop laptoping
04:52:04 <hpc> i have had this since before retina was a thing, and i don't plan on replacing it soon
04:52:10 <fizbin> hpc, merijn: here's the weirdness I see when playing with encodings: http://pasteboard.co/2m2nVx3Ga.png
04:52:16 <hpc> i keep windows around for games and i can't stand post-7 windows
04:52:24 <hpc> so instead, 8pt droid sans mono
04:52:30 <merijn> hpc: Since I'm using my private laptop for work I got by boss to pony up for a UHD display instead from my budget
04:53:15 <hpc> when i get a linux desktop i will go looking for the prettiest font in all the realm
04:53:21 <merijn> hpc: I switched to Windows 10 from 7 (because 7 can't handle displays at different DPIs and I didn't wanna throw away my non-UHD display), don't really have problems with it and the new linux subsystem looks interest
04:54:13 <fizbin> So it's as though @pl is sending some byte sequence that my client in UTF-8 mode interprets as "bad/unknown character", and that it interprets in ISO-8859-1 mode as "back up one character".
04:54:14 <merijn> hpc: I don't think you can get Monaco free, but Adobe Source Code Pro is a somewhat similar free (as in beer and as in speech) font
04:54:54 <ertes> hpc: most pretty coding fonts look pretty much like dejavu sans mono, but it doesn't have those super-round almost-half-circle parentheses that most of them seem to use‚Ä¶  i find it a lot more aesthetically pleasing
04:55:08 <ertes> and it's free (as in beer and speech)
04:55:45 <ertes> it also comes with a very pretty serif font for variable width
04:56:05 <ertes> the variable sans font is ugly, because all variable sans fonts are ugly
04:57:43 <merijn> https://www.fontsquirrel.com/fonts/source-code-pro
04:58:21 <merijn> I think some of the special characters like @ look kinda wonky in Dejavu Sans Mono
04:59:28 <fizbin> I suspect it's at the point I'll need to break out wireshark to watch what's really being sent.
04:59:55 <ertes> well, in source code pro % and even 'i' look wonky =)
05:00:03 <ertes> i guess it's mostly a personal thing
05:00:35 <merijn> ertes: Which is why I use Monacro and not Source Code Pro ;)
05:01:08 <ertes> merijn: the one in the screenshot?
05:01:27 <merijn> But unless you use Monaco people don't generally have access to that, unless I suppose you buy it, but I don't know many non-graphics designers who buy fonts :p
05:01:30 <merijn> ertes: Yeah
05:01:47 <merijn> eh s/Monaco/OSX
05:01:57 <hpc> graphic designers could do to buy a few less fonts imo
05:02:02 <hpc> at least when they're doing web development
05:02:04 <ertes> well, i wouldn't buy that one at least, because i don't like half-circle parentheses =)
05:02:46 <hpc> you get a psd and every font is different, the heading is in snoofle-gringot sans medium with a very specific font hinting, and you have to figure out which of arial and helvetica is closest to it
05:05:55 <edwardk> Darwin226: yeah
05:06:58 <dramforever> https://be5invis.github.io/Iosevka/
05:09:45 <dramforever> It's got quite a few opentype features so you get to say, for example, whether you want 'i' to have a hook, a flat bottom stroke or no bottom stroke
05:09:48 <fizbin> Okay, WTF. Connecting with a new client from elsewhere and capturing all the data with tcpdump shows that @pl isn't saying weird characters.
05:10:00 <fizbin> But it isn't just me seeing this.
05:10:15 <ongy> when did it do it? I have missed the conversation so far
05:10:52 <dramforever> Aaand it's got nice ligatures for arrows, <!--, :+, etc.
05:11:22 <dramforever> I know you can configure them in Atom but I don't think most editors allow them
05:13:21 <fizbin> Maybe the server somehow knows whether a client is ISO-8859-1 and sends subtly different data?
05:14:35 <Ferdirand> afaik irc does not specify encoding at the server level
05:14:44 <Ferdirand> you could be on different channels using different encodings
05:14:45 <merijn> IRC doesn't specify an encoding, period
05:14:51 <ongy> is your local broken, and the client just can't display it properly?
05:17:02 <t0by> hpc, graphic designers would do well to leave the web alone entirely.
05:17:53 <fizbin> ongy, Ferdirand: Do you see strangeness after the =<< in this response?
05:18:02 <fizbin> @pl \a b -> concatMap (second reverse >>> uncurry zip)¬†((zip `on` inits)¬†a b)
05:18:02 <lambdabot> (((second reverse >>> uncurry zip) =<< ¬) .) . (zip `on` inits) ¬
05:18:05 <merijn> I disagree, the web desperately needs some more graphic designers
05:18:19 <merijn> Most websites are atrocities
05:18:49 <ongy> I feel like they need more functionality designers than graphic designers... they can be super pretty, If they are horrible to use, it's useless
05:19:03 <fizbin> ongy, Ferdirand: some people see a √Ñ (captial A umlaut), some people see a √Ç (captial A circumflex), I see a ? after the =<<
05:19:35 <fizbin> But from another machine where I can run tcpdump, I see nothing:
05:19:37 <ongy> I see the circumflex
05:20:03 <fizbin> 000005a0  3d 3c 3c 29 20 2e 29 20  2e 20 28 7a 69 70 20 60  |=<<) .) . (zip `|
05:21:16 <fizbin_test> @pl \a b -> concatMap (second reverse >>> uncurry zip) ((zip `on` inits) a b)
05:21:16 <lambdabot> (((second reverse >>> uncurry zip) =<<) .) . (zip `on` inits)
05:21:36 <fizbin> @pl \a b -> concatMap (second reverse >>> uncurry zip) ((zip `on` inits) a b)
05:21:36 <lambdabot> (((second reverse >>> uncurry zip) =<<) .) . (zip `on` inits)
05:21:41 <ongy> this one doesn't have it (btw. how could we test lambdabot weirdness with multiple clients not spamming a channel?)
05:22:22 <fizbin> Well, I had been testing using PRIVMSG to lambdabot, but that wasn't showing anything so I tried this here.
05:22:38 <fizbin> @pl \a b -> concatMap (second reverse >>> uncurry zip)¬†((zip `on` inits)¬†a b)
05:22:38 <lambdabot> (((second reverse >>> uncurry zip) =<< ¬) .) . (zip `on` inits) ¬
05:23:26 <Ferdirand> i don't even understand what the circumflex A is supposed to stand for in this code
05:23:37 <Ferdirand> is it a bug in pl ?
05:24:21 <fizbin> Ha! Okay, I think I found it.
05:25:02 <ongy> Ferdirand: either that, or fizbin is posting in things we don't see
05:25:27 <Ferdirand> ongy: aha, interesting point
05:26:05 <fizbin> Right, so what's happening is that my copy/paste has some character 0xA0 (character 160, aka nonbreaking space, aka &nbsp;) in it.
05:26:21 <fizbin> That, in UTF-8, is the byte sequence c2 a0
05:27:26 <fizbin> @pl is interpreting this (I think) as the two character sequence '√Ç', '\xA0'  and is treating the 0xA0 it sees as a space. 
05:27:26 <lambdabot> (line 1, column 64):
05:27:26 <lambdabot> unexpected "\130"
05:27:27 <lambdabot> expecting variable
05:28:39 <ongy> @pl \x -> ‚Äãx
05:28:39 <lambdabot> (line 1, column 8):
05:28:39 <lambdabot> unexpected '\128'
05:28:39 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
05:28:44 <fizbin> It is then replying with an answer that includes (isolated) 0xC2 bytes.
05:28:55 <ongy> @pl (\x -> ‚Äãx)
05:28:55 <lambdabot> (line 1, column 9):
05:28:55 <lambdabot> unexpected "\128"
05:28:55 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
05:28:55 <fizbin> That's invalid UTF-8
05:29:39 <fizbin> But most people's clients are set up so that invalid UTF-8 is interpreted as ISO-8859-1 or IS-8859-15, so the isolated C2 bytes become √Ç
05:33:10 <fizbin> So, okay, my client somehow changed both spaces that happened after right parens into non-breaking spaces when I first typed them, which @pl (not UTF-8 aware) was interpreting as captial-A-circumflex followed by a space, which made it respond in kind.
05:33:56 <fizbin> It was as though I had been sending @pl the expression   \a b -> concatMap (second reverse >>> uncurry zip)X ((zip `on` inits)X a b)  but with capital-circumflex-A instead of X
05:35:35 <ongy> int-e: what encoding does lambdabot use for irc input/output?
05:35:58 <fizbin> It's inconsistent across commands! Oddly enough, :t seems to be UTF-8 aware.
05:36:39 <fizbin> Which is why my expression that I was feeding to @pl could be copied into :t and come out just fine.
05:37:13 <merijn> ongy: It seems to handle UTF-8 fine, so I would expect that
05:37:36 <ongy> we have just seen an example where things broke
05:37:54 <fizbin> merijn: Well, the ">" and ":t" commands handle UTF-8. @pl however seems different.
05:40:30 <fizbin> > 3¬†+¬†5
05:40:31 <int-e> ongy: it's supposed to use UTF-8 but this is a) brittle and b) there's a known (meaning I'm aware of it...) problem with 0xA0 being treated as a space when it's part of an UTF-8 encoding.
05:40:32 <lambdabot>  8
05:40:42 <ongy> > ord '‚Äã'
05:40:45 <lambdabot>  <hint>:1:6: error:
05:40:45 <lambdabot>      lexical error in string/character literal at character '\8203'
05:40:50 <int-e> ongy: a) meaning that it's easy to mess up on the plugin side.
05:40:51 <fizbin> @pl 3¬†+¬†5
05:40:51 <lambdabot> 3 ¬ + ¬ 5
05:41:26 <fizbin> (The spaces around the + sign there were nbsp characters - character 160)
05:42:30 <kuribas> what are these red underscores?
05:42:45 <ongy> red underscore?
05:43:13 <kuribas> is that what emacs shows for nbsp?
05:44:14 <ongy> int-e: would that be on the side of base library? I'd expect it to use isSpace
05:46:10 <fizbin> int-e: Is this also an issue when byte 0x85 shows up in a UTF-8 sequence?
05:46:56 <fizbin> (I ask because 0x85 is whitespace in some systems, because $REASONS)
05:47:25 <merijn> > generalCategory '\x85'
05:47:28 <lambdabot>  Control
05:48:49 <briansteffens> what does it mean when the console output for running a program is "filename: <<loop>>" ?
05:49:38 <merijn> briansteffens: You have an infinite recursion in your code
05:50:02 <briansteffens> ok thanks
05:52:53 <c_wraith> specifically, infinite *value* recursion.
05:54:11 <c_wraith> It means calculating a specific constructor being demanded requires knowing the result of the calculation.
05:54:56 <c_wraith> (Or primitive value like Int# if you want to be super-precise)
06:00:24 <malinoff> hi everyone, can I ask stack-related questions here?
06:00:41 <merijn> malinoff: Yes, with varying degrees of succes :)
06:01:10 <c_wraith> Is there a more stack-specific channel?  I think I've heard of one, but I don't know what it is if it exists.
06:01:17 <malinoff> merijn: well, the issue I'm having is... extremely weird
06:01:22 <merijn> I think #stackage ? or something
06:01:27 <osa1> #haskell-stack
06:01:28 <malinoff> so I'm not expecting any degree of success :)
06:03:15 <malinoff> I'm trying to execute `stack setup` from within a jenkins pipeline script which spawns a docker container (based on fpco/stack-build) and executes `stack setup` within that container
06:03:27 <malinoff> and it fails, without stdout/stderr
06:04:46 <cocreature> malinoff: have you tried passing --verbose?
06:04:54 <malinoff> cocreature: https://bpaste.net/show/9cb0a3a01484
06:05:25 <malinoff> no stuff like "Downloaded lts-6.10 build plan"
06:06:38 <cocreature> hm weird
06:06:44 <malinoff> the most interesting thing is if I spawn a similar container and execute `stack setup` manually, everything works
06:07:03 <seequ_> What's the general consensus on point-free style vs explicit arguments? And by extension on abusing combinators?
06:07:04 <seequ_> Example case: getAction = fmap hotkeyAction .$$ find . (==) .$ hotkeyChar
06:07:04 <malinoff> i even tried to replicate `env` that Jenkins sets, without success
06:07:04 <seequ_> vs getAction c a = fmap hotkeyAction $ find (\x -> hotkeyChar x == c)
06:08:00 <merijn> seequ_: Use whatever is most readable
06:08:30 <merijn> seequ_: I would probably write "hotkeyAction <$> find ((c==) . hotkeyChar)"
06:08:55 <seequ> merijn: That's pretty subjective, though. To me the first one is very redable because I know the combinators.
06:09:02 <seequ> merijn: That's not quite right
06:09:28 <merijn> seequ: In what way is it not right?
06:09:45 <seequ> (fmap f .) !== (f <$>)
06:10:04 <ertes> seequ_: i avoid it for the most part, except in cases of eta reduction (f x y = g (h x x) y ‚Üí f x = g (h x x)) and function composition (f x = g (h (i x)) ‚Üí f = g . h . i)
06:10:05 <merijn> seequ: Your last version doesn't have "fmap f ."
06:10:19 <merijn> seequ: .$$ is an operator I've never seen before, so
06:10:22 <seequ> merijn: Your version doesn't have a :)
06:10:35 <seequ> Ugh, I missed it there
06:10:37 <seequ> Sorry.
06:10:59 <ertes> seequ: turned out for me that point-free style is not worth doing in most other cases
06:11:24 <cocreature> seequ: it is definitely subjective, but it‚Äôs not possible to objectively say that some code is more readable than other code. (ignoring extremes where this might be possible)
06:12:17 <ertes> example: i have no idea what your code does, and i would have to look up (.$$) and (.$) to learn it, which is a waste of time, when the pointy version is more readable
06:12:23 <jophish> ARe there any haskell compilers which run on DOS?
06:12:23 <fizbin> seequ: Are (.$) and (.$$) abstractions that you've defined in your code?
06:12:30 <merijn> jophish: ...
06:12:45 <merijn> jophish: You're scaring me
06:13:12 <seequ> fizbin: Yeah, (f .$ g) x = f x . g and (f .$$ g) x = f . g x
06:13:47 <merijn> seequ: I would say that relying on obscure (i.e. not in base or a major library) by definition reduces the readability :)
06:13:51 <fizbin> seequ: So, there's a difference between "pointfree using standard combinators" and "pointfree using combinators I invented for this file"
06:14:31 <ertes> i tolerate reader monads to some extent when writing point-free code =)
06:14:37 <Ferdirand> how is (f .$$ g) more readable than (f .) . g ?
06:14:58 <ertes> Ferdirand: neither of those really deserve the attribute "readable" =)
06:15:04 <merijn> Ferdirand: "(f .) . g" is also not readable :)
06:15:07 <jophish> ((.).(.)) f g
06:15:11 <seequ> Right. This is pretty much what I assumed, but a friend of mine insisted on defining combinators for everything.
06:15:20 <fizbin> Ferdirand: The same way a 10-letter word you've seen many times before is more readable than a made-up 10-letter word.
06:15:21 <jophish> there's a "common" operator for that
06:15:32 <ertes> seequ: even haskell has anti-patterns, and this is one of them =)
06:15:42 <Ferdirand> fizbin: well, my point exactly
06:15:49 <merijn> ertes: co-patterns? :)
06:15:50 <cocreature> jophish: or alternatively fmap fmap fmap f g
06:15:54 <Ferdirand> (f.).g is certainly more common than .$$
06:16:01 <jophish> or f .: g
06:16:02 <ertes> merijn: no, copatterns would be nice =)
06:16:11 <jophish> cocreature: nice
06:16:58 <fizbin> ertes: Would they? Or are co-patterns the things haskell programmers would be nice *to*, whereas using common patterns is being nice to haskell programmers.
06:17:31 <seequ> Right, so, all in all I'd settle with getAction c = fmap hotkeyAction . find ((== c) . hotkeyChar)
06:18:03 <ertes> fizbin: copatterns are something specific:  data A = A { field1 :: Integer, field2 :: Text };  blah :: A; field1 blah = 15; field2 blah = "blubb"
06:18:22 <ertes> instead of:  blah = A { field1 = 15, field2 = "blubb" }
06:18:42 <ertes> would be particularly nice with function fields
06:18:51 <fizbin> Ah, specifying record parts with what looks vaguely like prolog logic programming.
06:19:41 <int-e> ongy: fundamentally the issue is that IRC is a byte based protocol and it's not really clear where exactly encoding should be handled when writing an IRC bot... it's not really the base library's fault, except perhaps when it comes to running lambdabot on terminals.
06:19:48 <int-e> > isSpace '\x85'
06:19:50 <lambdabot>  False
06:20:06 <int-e> fizbin: ^^ 0x85 should be fine.
06:20:21 <bennofs> ertes: isn't that nearly achieved with RecordWildCards and blah = A{..} where field1 = 15; field2 = "blub" ?
06:20:33 <ertes> data Iso a b = Iso { forward :: a -> b, back :: b -> a };  forward (power x) y = x^y;  back (power x) y = logBase x y
06:20:40 <ertes> that would be really nice to have in haskell
06:20:49 <bennofs> oh nesting
06:20:49 <malinoff> cocreature: okay, `Downloaded lts-6.10 build plan` is actually showed when I cleanup .stack
06:20:57 <malinoff> cocreature: but nothing more
06:21:03 <ertes> bennofs: that's for defining, not pattern-matching
06:21:10 <ertes> *co*-patterns =)
06:21:17 <bennofs> ertes: RecordWildCards can be used for defining
06:21:27 <ertes> oh, i see
06:21:30 <fizbin> int-e: I would have thought that encoding should be handled by whatever library handles wrapping messages in low-level IRC details, like PRIVMSG etc.
06:21:33 <ertes> nice, that's actually useful
06:29:01 <niilohlin> I am using QuickCheck to test one of my programs. When I tried to write a shrink funktion for a more complex record (10+ fields, with some of which are records with multiple fields). I find that the shrinking takes a _very_ long time.
06:29:23 <niilohlin> Are there any examples online of some more complex shrinking functions?
06:30:27 <ertes> niilohlin: how are you shrinking?
06:31:10 <niilohlin> ertes: what do you mean?
06:31:51 <ertes> niilohlin: you should shrink the way tuples are shrunk: only one field at a time, and additively, not multiplicatively
06:32:05 <ertes> > shrink ("abc", "def") 
06:32:08 <lambdabot>  [("","def"),("bc","def"),("ac","def"),("ab","def"),("aac","def"),("aba","def...
06:32:16 <niilohlin> I have tried a couple of different ways. Generating shrinking lists for all values and ziping them together
06:33:21 <ertes> > (\(xs, ys) -> map (, ys) (shrink xs) ++ map (xs,) (shrink ys)) ("abc", "def")
06:33:24 <niilohlin> I tried doing that to. It still made super long lists of all possible shrinking values
06:33:25 <lambdabot>  [("","def"),("bc","def"),("ac","def"),("ab","def"),("aac","def"),("aba","def...
06:34:12 <ertes> niilohlin: well, then perhaps you can use your domain-specific knowledge to make only shrinks that are worthwhile
06:34:19 <niilohlin> Is this maybe just a property of shrinking?
06:34:41 <niilohlin> ah, ok. so I have to be a bit more clever than just shrinking every value
06:34:44 <ertes> niilohlin: well, nine fields are a lot‚Ä¶  you get nine times each individual shrink
06:35:21 <ertes> niilohlin: also note that shrinking is optional‚Ä¶  it only makes quickcheck try to reduce failing cases to simpler ones
06:35:43 <niilohlin> there are a lot more than 9 values. some tree structures too
06:35:50 <ertes> 'ok, it failed for ("abc", "def"), so how about ("", "def")?'
06:35:54 <Darwin226> edwardk: You know that trick where you want to put _some_ null value into a strict unpacked field, so you can use unsafeCoerce ()?
06:36:30 <Darwin226> Because it's not undefined so it survives the strictness check, and as long as you don't touch it it doesn't matter that it's a lie
06:37:28 <Darwin226> Is there something that works if the field in question has some type with multiple fields? I'm getting segfaults in those cases
06:37:30 <niilohlin> ertes: thank you. It seems that it's maybe not worth the effort then
06:37:37 <ggVGc> Purescript eschews tuples because of having extensible records. What are you guys opinions about this? I kind of often feel tuple usage is a trap for me in haskell and often comes back and bites me because it's quick initially but is always less clear and makes for worse readability long term
06:38:03 <ertes> niilohlin: is this actually causing trouble?
06:38:15 <ertes> niilohlin: if not, just go with the way tuples work
06:38:25 <ggVGc> I guess it's just mainly my own discipline problem
06:38:36 <ggVGc> how much do you guys use tuples in haskell?
06:39:09 <niilohlin> ertes: No I was having some test fail with huge inputs. I was thinking that it might save time in the long run.
06:39:21 <ertes> ggVGc: there are some good use cases for tuples (as generic products when it really doesn't make sense to define a separate type), and many bad ones
06:39:41 <ggVGc> ertes: I feel I've been doing a lot of bad usages of tuples in my haskell programming so far
06:39:45 <ggVGc> and I feel it's quite common
06:39:52 <ggVGc> It's almost one of haskell's main pitfalls imo
06:40:07 <ggVGc> it was one of the most interesting prespectives for me when doing some purescript recently
06:40:10 <ertes> niilohlin: don't optimise prematurely‚Ä¶  if it causes trouble in the future (a test fails, but quickcheck is taking very long to report it), just simplify the shrinker later
06:40:31 <NextHendrix> you can use tuples for uncurried functions
06:40:36 <ggVGc> but having extensible records makes it a lot easier to not abuse tuples, also
06:40:40 <ggVGc> (imo)
06:41:18 <ertes> ggVGc: i use tuples when i need a generic product constructor and when i need to return multiple values from a function
06:41:49 <ggVGc> yep, those are basically the valid use cases I can think of too
06:41:52 <ggVGc> but in practice I'm sloppy
06:41:59 <ggVGc> and use tuples too much for other things
06:42:13 <ggVGc> like collections of MVars etc.
06:42:28 <ertes> ggVGc: one useful measure is:  "how long does my tuple survive?"  if it lives longer than in a very narrow scope, that's an indication that you should define a type
06:43:09 <ggVGc> ertes: do you use OverloadedRecordFields?
06:43:17 <ertes> nope
06:43:37 <niilohlin> ertes: I don't think I am optimizing prematurely. I have never seen it work properly. I usually give up after a 10minutes of waiting. sometimes I run out of memory
06:43:53 <ertes> niilohlin: does the testing itself take that long?
06:43:59 <niilohlin> shrinking
06:44:18 <niilohlin> the testing itself does only take a couple of minutes
06:44:30 <ertes> niilohlin: well, if the failing case is good enough to find the bug, then sure, don't bother
06:44:33 <ggVGc> ertes: any particular reason? i feel record field name collisions are a major reason I have a hard time using records more than tuples
06:44:41 <ertes> niilohlin: you might also want to use smallcheck instead of quickcheck
06:45:00 <ertes> niilohlin: smallcheck comes up with examples structurally instead of randomly
06:45:03 <somewone> any way I can use a package from github, before a new version is released on hackage? 
06:45:04 <ertes> starting with small examples
06:45:23 <bennofs> somewone: do you use stack or cabal?
06:45:28 <ertes> ggVGc: i use DuplicateRecordFields
06:45:34 <somewone> stack
06:45:38 <ggVGc> ertes: ah, sorry, I mixed them up
06:45:41 <somewone> i can reference the commit
06:45:42 <ggVGc> that's what I meant
06:45:56 <ggVGc> actually, not sure what OverloadedRecordFields does
06:45:57 <ertes> ggVGc: yeah, that one i do use
06:46:04 <somewone> but the hackage version still seems to have priority
06:46:17 <bennofs> somewone: well then just add it to "packages" like here: https://github.com/bennofs/reflex-host/blob/master/stack.yaml
06:46:25 <ertes> ggVGc: it's one of the many IMO misguided attempts to fix record overloading =)
06:46:28 <ggVGc> somewone: you could just put it in your project folder and reference it?
06:46:31 <ggVGc> that's what I often do
06:46:51 <ertes> ggVGc: i'm not a big fan of DuplicateRecordFields either‚Ä¶  it's terrible
06:46:57 <ggVGc> I was just about to ask
06:47:02 <niilohlin> ertes: interesting, I have never heard of it
06:47:23 <ertes> niilohlin: yeah, it's unfortunately not as well known as it should be =)
06:47:35 <ggVGc> ertes: I've also had issues with it, but I can't remember what exactly now. But I remember random small things popping up that made it feel a bit hit n miss in usage
06:47:49 <somewone> bennofs I did, never the less it doesnt seem to pick the github/commit version but the version published on hackage
06:48:02 <ertes> ggVGc: the issue is: basically you still have to tell it which type the field belongs to, even when it's painfully obvious from the type
06:48:10 <ggVGc> yeah, right
06:48:12 <ggVGc> I remember that
06:48:14 <somewone> ggVGc I'll give that a try although I would prefer directly referencing the git repository
06:48:20 <ggVGc> inference breaks a lot
06:48:37 <ertes> ggVGc: all current approaches are bad, IMO, and i'm considering writing an article about that
06:48:47 <niilohlin> ertes: thank you. I should get back to work.
06:48:49 <bennofs> somewone: can you show your stack.yaml?
06:48:56 <ggVGc> somewone: I think that should work too, but personally I think its good to lock into a certain checkout, when tracking a git repo instead of releases
06:49:29 <ggVGc> ertes: have you tried this? https://nikita-volkov.github.io/record/
06:49:33 <fizbin> ggVGc: Or at least a specific tag
06:49:51 <ggVGc> yep, maybe you can do that with stack though
06:49:53 <ggVGc> I've never tried
06:50:00 <ggVGc> I usually just check out and keep a copy
06:50:02 <ggVGc> because
06:50:03 <ggVGc> <-- lazy
06:50:11 <bennofs> ggVGc: yes you can see https://github.com/bennofs/reflex-host/blob/master/stack.yaml for an example
06:50:52 <ertes> ggVGc: i don't like that one either
06:51:05 <ertes> ggVGc: IMO haskell should just get ad-hoc polymorphism
06:51:09 <somewone> bennofs http://lpaste.net/6751384518512345088
06:51:47 <bennofs> somewone: tried extra-dep: true, like in my example?
06:52:04 <somewone> yeah i think i've tried that as well
06:52:08 <somewone> Ill try again
06:52:42 <kuribas> Anyone ever used liquid haskell to prove low level haskell code correct?  Like that unsafeThaw, unsafeIndex etc aren't unsafe?
07:01:18 <quchen> hvr: ping
07:01:43 <somewone> bennofs got it... i referenced another package via stack but basically had only one "location:" parent
07:40:30 <Layl> what's the general standard for unit testing in Haskell?
07:41:03 <somewone> does anyone know if there are any plans to publish precompiled packages for arm, a clean cross compile build takes me ages, since I have to compile all dependencies first for arm.
07:41:07 <unsymbol> Layl: have a look at this thread https://www.reddit.com/r/haskell/comments/5mrk20/haskell_testing_frameworks_what_do_you_use/
07:41:20 <unsymbol> it's fairly recent.
07:41:42 <Layl> unsymbol: thanks
07:41:54 <comerijn> somewone: I think precompiled packages are only provided for tier1 platforms and I don't think arm is tier1?
07:42:41 <kuribas> Layl: hunit and tasty
07:42:55 <Layl> is there some kind of guide for setting up hunit and tasty?
07:43:35 <kuribas> Layl: I just use the haddock docs.
07:43:47 <kuribas> Layl: http://hackage.haskell.org/package/HUnit-1.5.0.0/docs/Test-HUnit.html
07:43:58 <Layl> alright thanks
07:44:17 <somewone> Layl maybe this will help as well http://documentup.com/feuerbach/tasty#tests-for-a-library
07:44:36 <Layl> somewone: ah that one's what I'm looking for exactly
07:47:13 <somewone> comerijn, thanks, no apparently it is tier2
07:47:58 <comerijn> I think the main problem is that none of the regular contributors really have an arm thing to test on and neither is there a convenient buildbot, which makes testing and investigating issues hard
07:51:43 <somewone> ok I can understand that, although I guess regarding the hardware part, if one had dedicated arm servers (which I think are still hard to come by) that could cover that issue.
07:52:32 <PanosAsproulis[m> General question: how fast are the Haskell executables particularly for number crunching applications compared to other native languages like C/C++?
07:53:56 <davean> PanosAsproulis[m: the closest you might get to a real answer on that is sometihng like http://benchmarksgame.alioth.debian.org/ but its really hard to messure and might quickly stop meaning what you think it means as you try to quantify it
07:54:50 <comerijn> PanosAsproulis[m: It Depends(TM)
07:55:25 <comerijn> PanosAsproulis[m: Also, why do you say "native languages like C/C++"? What's your criterium for "native language", because by all sensible definitions haskell *is* a native language
07:55:50 <sm> folks often report reaching speeds within an order of magnitude of C
07:55:55 <davean> actually no it isn't comerijn - the only native language is the one the CPU speaks and thats microcode, and Haskell isn't microcode
07:56:08 <comerijn> davean: By that definition C is not native either
07:56:12 <davean> Correct!
07:56:24 <comerijn> davean: And I would say that *no one* would consider that a useful definition of native
07:56:24 <davean> The CPU only speaks one language, how could any other language be native?
07:56:44 <davean> well, actually, some CPUs speak a few languages
07:56:45 <sm> and occasionally, with expert tuning, 2x slower, or faster than C
07:56:59 <Layl> hm, `haste-cabal configure --enable-tests` seems to be failing with "haste-cabal.exe: At least the following dependencies are missing: tasty ==0.11.*" and I'm not sure why
07:57:15 <maerwald> sm: add expert vulnerabilities to that :P
07:57:17 <comerijn> Layl: Well, because those aren't installed, presumably? :)
07:57:30 <Guest46242> T
07:57:40 <Layl> comerijn: cabal doesn't pull them in automatically?
07:57:48 <sm> expert tuning of haskel code causes vulnerabilities ?
07:57:48 <davean> Layl: maybe those can't be built for haste?
07:58:12 <davean> sm: clearly, almost expert tunings include adding risk
07:58:41 <PanosAsproulis[m> By "native" I meant a language with a compiler that creates native executables.
07:58:48 <davean> PanosAsproulis[m: haskell does that ...
07:58:59 <davean> PanosAsproulis[m: Thats the only way GHC works really
07:59:19 <davean> (ghci being seperate)
07:59:52 <sm> well sure, I wouldn't trust an almost expert :)
08:00:08 <davean> sm: It isn't even really about trust
08:00:39 <maerwald> people thought OpenSSL devs are experts too :P (and they probably are)
08:00:39 <davidj_> hello, can someone please clarify a lambda calculus substitution rule for me:
08:00:54 <fizbin> Layl: Usually, with cabal, I first run a command to add all the dependencies:
08:00:57 <davean> maerwald: Actually thats more complicated
08:01:13 <fizbin> Layl: cabal install --dependencies-only --enable-tests
08:01:19 <davean> maerwald: they were mostly crypto experts, not programming experts or people commited to the openssl project
08:01:37 <maerwald> davean: that's what I said
08:01:51 <Layl> fizbin: seems to fail at trying to resolve "process"
08:01:58 <davean> maerwald: well, they weren't experts at what they were doing
08:01:59 <fizbin> Layl: If I forget --enable-tests on the "install --dependencies-only" line, I get an error later when trying to run/build tests about missing test-only dependencies.
08:02:42 <davean> You could just use new-configure and new-build and stop with all that?
08:02:46 <davidj_> According to SPJ's book, (\y. E)[M/x] (when y != x) reduces to (\y. E) when *either* 1. x does not occur free in E, or 2. y does not occur free in M
08:02:55 <davidj_> and I'm wondering why it's not just condition 2
08:03:10 <davidj_> sorry... typo... reduces to (\y. E[M/x])
08:03:39 <maerwald> fine-tuning performance doesn't generally imply thinking about security... 
08:03:58 <Layl> I think "process" doesn't work on Haste? Would make sense
08:04:05 <Layl> but it's an indirect dependency of tasty
08:04:21 <fizbin> Layl: I usually have to install dependencies before configuring.
08:04:49 <davean> fizbin: why not just use new-?
08:07:05 <fizbin> davean: Because I hadn't heard about this thing, and set up my build environment and Makefiles back in 2014.
08:07:22 <davean> fizbin: just use "cabal new-configure" and "cabal new-build"
08:07:38 <davean> you're well out of date
08:08:22 <fizbin> davean: Sort of. I still need to build stuff on Ubuntu 14.04 LTS machines though, so I can't generally use new tricks.
08:08:35 <sm> PanosAsproulis[m: also, for serious number crunching I believe people use GPUs, there are some haskell packages for that
08:08:41 <davean> fizbin: I mean, cabal will install on that fine?
08:08:55 <davean> fizbin: that has access the cabal-head even
08:09:01 <PanosAsproulis[m> Another question: Would you consider Haskell a sensible choice for a scientific application with heavy mathematical computations which mainly involve large vectors of reals and two dimensional sparse matrices? How is immutability going to affect memory requirements? The modification of a large vector based on computations means that a new vector must be created and then the old deleted? 
08:09:09 <comerijn> sm: Although as someone doing number crunching on the GPU I wouldn't recommend those packages :p
08:09:32 <sm> comerijn: noted!
08:09:48 <comerijn> PanosAsproulis[m: Note Haskell is just immutable by default, it's fairly easy to make mutable stuff in haskell
08:10:04 <comerijn> PanosAsproulis[m: And you can frequently fuse the entire thing away
08:10:24 <maerwald> I wonder if it's better to say "variables are immutable" as opposed to "values"
08:10:27 <PanosAsproulis[m> Interesting. I need to do some serious reading.
08:10:46 <ertes> PanosAsproulis[m: at the very least i would use it on the higher levels
08:11:00 <maerwald> IORef is technically stell immutable
08:11:07 <davean> PanosAsproulis[m: theres things like hblas, otherwise haskell has good mutable dense vector support but sparse support is weaker and not as well developed, otherwise its good
08:11:16 <ertes> PanosAsproulis[m: but GHC matching or even beating GCC/clang is not even that uncommon anymore
08:11:36 <comerijn> PanosAsproulis[m: Haskell has a fairly easy C FFI, so you could easily use it as glue code for handwritten kernels
08:11:38 <davean> C has never had the numerical performance crown
08:11:41 <ertes> PanosAsproulis[m: and in the cases when it doesn't, it has a reasonably straightforward FFI to C
08:12:12 <PanosAsproulis[m> What about parallelism? Is there some high-level approach one can follow in Haskell for that e.g. Actors?
08:12:21 <comerijn> sm: The biggest issue is that those things tend to try and "polish away" low level details, but those are often crucial for getting the performance you want. 
08:12:34 <ertes> PanosAsproulis[m: in haskell you would typically try to use data parallelism first
08:12:48 <comerijn> PanosAsproulis[m: GHC has a lightweight threading system, fairly similar to Go's goroutines and Erlang's processes
08:13:44 <ertes> PanosAsproulis[m: but if you really want to use a thread-based approach, you can have that, too, and you can even choose between quite a few approaches, ranging from completely pure (monad-par) to the state of the art in concurrency abstractions (e.g. STM)
08:14:37 <ertes> PanosAsproulis[m: data parallelism works like this: "i have a list‚Ä¶  i want to make a function‚Ä¶  make this parallel, please", done =)
08:14:45 <ertes> s/make/map/
08:15:18 <PanosAsproulis[m> yes, data parallelism could be very useful and easy to apply.
08:15:25 <Rodenbach> By putting the function name between `backticks`. For example:  5 `subtract` 100   instead of  subtract 5 100.      Is it possible to curry using the infix notation?   I tried      let min5 = 5 `subtract`       but this gave me an error.
08:15:50 <comerijn> Rodenbach: That's an error the same way "5 +" is :)
08:15:54 <Rodenbach> Uh, forgot to say we can make 2-ary functions infix
08:15:57 <ertes> PanosAsproulis[m: particularly important for scientific computations: we have a number of libraries for data parallelism on unboxed arrays, the most common one being repa
08:16:05 <comerijn> Rodenbach: You can use section syntax to do what you want, though
08:16:15 <davean> PanosAsproulis[m: how much of it is just composing existing matrix operations on large matrixes?
08:16:24 <Rodenbach> comerijn: I can say   let byTen = (/ 10)        and     let tenBy = (10 /)
08:16:26 <comerijn> Rodenbach: Also, you can make any function infix that way, including 3-ary or more, but that might not be very usable :)
08:16:45 <comerijn> Rodenbach: Right, and you can say "let min5 = (5 `subtract`)" too
08:16:51 <PanosAsproulis[m> davean: it is mainly vector operations
08:16:54 <Rodenbach> Ah okay, that‚Äôs it then, thx
08:16:56 <Rodenbach> Works.
08:17:05 <davean> PanosAsproulis[m: Lots of small ones, or a few large ones?
08:17:15 <davean> PanosAsproulis[m: on the same or different matrixes?
08:17:16 <ertes> PanosAsproulis[m: worth to know: there is a whole book on parallism and concurrency in haskell: http://chimera.labs.oreilly.com/books/1230000000929/
08:17:22 <PanosAsproulis[m> a few very large vectors
08:17:26 <davean> PanosAsproulis[m: are the operations the standard mathematical operations, or origional ones?
08:17:40 <PanosAsproulis[m> standard mathematical operations
08:17:44 <Layl> so tasty aint workin' on Haste, and I can't figure out how to get HUnit to run through `haste-cabal test`, off to a great start
08:18:01 <davean> wait, vector not matrix?
08:18:42 <PanosAsproulis[m> Mainly vector operations but some algorithms may involve the creation of a large sparse matrix which needs inversion.
08:19:13 <ertes> PanosAsproulis[m: most vector operations are pretty straightforward both to express and to parallelise using e.g. 'repa' (CPU) or 'accelerate' (GPU)
08:19:37 <ertes> with sparse matrices it depends on your representation, of course
08:19:43 <davean> PanosAsproulis[m: well I have no worries about the vector ecosystem in Haskell, my only question then would be if the sparse matrix options are sufficiently mature for you
08:19:55 <davean> PanosAsproulis[m: and sparse matrixes are their own entire discussion
08:24:16 <Layl> egggh I can't get tests working, guess I'll leave it at no tests for now
08:24:19 <Layl> this is taking too much time
08:24:41 <seequ> It's not like you need tests in Haskell. ;P
08:25:05 <Jinxit> "it compiles, ship it!"
08:25:34 <maerwald> seequ: haskell doesn't even have a proper proof assistant... which would be the only proper argument for omitting tests in some cases
08:26:02 <Layl> seequ: I like using red-green-refactor as a method of developing software
08:26:04 <seequ> maerwald: Right, I assumed ";P" would imply sarcasm.
08:26:10 <ertes> not even then‚Ä¶  proofs are much more expensive than tests
08:26:21 <maerwald> seequ: most autists don't understand sarcasm
08:26:25 <maerwald> (that was sarcasm)
08:27:11 <ertes> Layl: you could try not using tasty‚Ä¶  it's just convenience
08:27:22 <Layl> ertes: I also tried HUnit
08:27:51 <Layl> everything seemed to be a maze of different ways of setting up tests and conflicting information, broken documentation, and on top of that half of things didn't work on Haste
08:27:55 <SrPx> Is it possible to build a short proof that the result of a `foldr` over a huge (> 10GB) list is correct? I.e., I have a on my computer a huge list, some kind of fingerprint of it (a hash, merkle tree, whatever), and someone sends me "hey the result of `sum yourList` is `78035081`, proof: `...`
08:28:13 <SrPx> Where proof would take much less work to compute than actually running `foldr (+) 0` myself.
08:28:24 <ertes> Layl: that means you need either a different framework (quickcheck, smallcheck) or a different compiler (GHCJS) =)
08:28:37 <SrPx> merkle root*
08:28:54 <Layl> ertes: it took me enough time to set up Haste which I got the impression was the standard choice for Haskell to JS
08:29:10 <Layl> I am not about to waste another 2 days setting up a *different* compiler and then another 2 days setting up a different test framework
08:29:21 <Layl> I simply do not have the time
08:29:29 <ertes> SrPx: verify the proof?
08:30:43 <ertes> Layl: haste is probably not worth the effort‚Ä¶  i would have gone with GHCJS right away
08:30:53 <ertes> it's basically the same experience as with GHC
08:31:02 <Layl> Well it would be nice if this were documented anywhere
08:31:09 <Layl> Because it's nearly impossible to find out how to do anything
08:31:40 <Layl> Every question has 5 solutions that only people who already know the problem domain in detail know the best solution to
08:31:52 <ertes> Layl: well, someone needs to document it =)
08:32:23 <Layl> it's not going to be me when I am in extreme time limits and am doing this as a hobby next to uni
08:32:41 <merijn> Layl: That's because haste and co aren't haskell, they are subsets of haskell/haskell-like languages so not all existing code works with them
08:32:53 <ertes> Layl: i guess, every potential documenter before you had a similar problem =)
08:33:20 <ertes> hence the lack of documentation =)
08:33:24 <sm> Layl: try doctest, it's simple
08:33:26 <Layl> I don't want to be seen as a potential documenter, when someone makes a tool they should god damn document it properly
08:33:32 <merijn> Layl: Why?
08:33:46 <Layl> Because they're the most qualified person to do so, it's what I do when I make tools
08:34:17 <davean> Layl: why would they?
08:34:24 <davean> Layl: they don't need docs, why would they care?
08:34:27 <merijn> Layl: Good for you. But I don't see why there's any reason to expact *anyone* to do anything unless you're paying them
08:34:36 <ertes> Layl: it's all volunteer work, so people just do what they like to do or find interesting‚Ä¶  there is no obligation to document
08:34:48 <sm> actually, also try https://github.com/unisonweb/unison/tree/master/yaks/easytest . Not quite released, but apparently works well
08:34:52 <merijn> I wish programmers (in general) would stop being so entitled about open source
08:35:01 <Layl> It's all volunteer work yes, but if I can't figure out how to use a tool in a timely manner my solution is generally: pick something else
08:35:15 <seequ> I'd still say an undocumented tool is a terrible tool.
08:35:15 <davean> Layl: Great, that sounds entirely like your problem
08:35:24 <ertes> Layl: it's your freedom to pick something else just like it's their freedom not to do stuff they don't enjoy =)
08:35:36 <Layl> And just because something's open source and voulenteer work doesn't mean I'm not allowed to complain about shortcomings
08:35:44 <davean> Layl: you sound extreemly selfish ATM
08:35:54 <davean> Layl: which is your perogative
08:35:57 <SrPx> ertes: pardon?
08:35:57 <sm> you are allowed to complain, and we are allowed to complain about your complaining :)
08:36:07 <davean> but I really doubt people were thinking "what would Layl want?" when they wrote stuff
08:36:10 <Layl> Yea well this is coming from 2 weeks of built up frustration that are now coming out at a tool that I guess isn't deserving of all of it
08:36:37 <johnw> Layl: I fail to document packages regularly; I can tell you from experience that just because a thing "should" happen, doesn't mean that it does.  This is our free-time, we do with it as we please.
08:36:46 <ertes> Layl: it's just that your complaints are pointless at best‚Ä¶  at worst you're attacking people who did expensive work not to have done more
08:36:53 <Rodenbach> Is there an opposit to `filter`?
08:37:04 <merijn> Rodenbach: You mean that keeps the opposite thing?
08:37:11 <Rodenbach> Yes
08:37:11 <sm> Layl: your underlying point is very valid, it's not that helpful to castigate people
08:37:16 <davean> Rodenbach: ... not?
08:37:18 <merijn> Rodenbach: "filter (not . f)"? :)
08:37:31 <Rodenbach> Ok :-)
08:37:37 <Layl> It's not complaints out of hate for the tool, I *want* to use it, really, but I simply can't if there's a lack of documentation
08:37:52 <davean> Layl: And who cares about that? Mostly you
08:38:06 <davean> Layl: feel free to pay someone to care about you
08:38:16 <ertes> Layl: well, then either fix the situation or use something else‚Ä¶  this really isn't helpful at all
08:38:17 <merijn> davean: You are now moving in the exact same territory of being unhelpfully attacking someone
08:38:20 <sm> or maybe it is helpful to castigate people. If it improves the situation, I'm all for it
08:38:38 <sm> put up a hall of shame
08:38:41 <merijn> sm: Except it doesn't, I put undocumented stuff online because "it might be useful to someone"
08:38:54 <merijn> sm: Complaining about it just makes me go "fuck it, not worth the hate"
08:39:02 <Layl> It wasn't my intention to castigate someone, just to complain about the fact that I can't get anything done because I can't find any information related to what I'm doing
08:39:14 <sm> understood, we've all been there
08:39:15 <Layl> But it seems it was certainly the intention of everyone here to castigate me
08:39:29 <seequ> Huh. I find it ridiculous that documentation is deemed unnecessary.
08:39:30 <Rembane> Are you having a meta complaint discussion?
08:39:44 <merijn> seequ: Who says it's deemed unnecessary?
08:39:49 <Layl> Any discussion, given enough time, turns into a meta discussion
08:39:49 <johnw> seequ: not unnecessary at all; it just gets "saved for last", and by then another idea comes along...
08:40:10 <sm> it's highly dependent on the project, goals, maintainer's situation...
08:40:10 <ertes> Layl: here is what you should have done right from the start: talk to people‚Ä¶  at the very least it's clear that the situation is unclear‚Ä¶  a quick post to haskell-cafe or a question here would have saved you the trouble
08:40:11 <cocreature> seequ: nobody is saying that documentation is bad or unnecessary. but complaining that people who work on projects in their free time don‚Äôt write documentation for them is not helpful
08:40:26 <Layl> ertes: I did ask questions here
08:40:48 <ertes> Layl: and haste was recommended?
08:41:00 <merijn> seequ: My (our?) conjecture is that you are assuming an underlying motivation about code's authors that does not exist
08:41:15 <Layl> waste wasn't specifically recommended here, but that's the solution I found in other places, that Haste's in general the best solution
08:41:18 <Layl> *haste wasn't
08:41:18 <ertes> Layl: because that's rather unlikely‚Ä¶  GHCJS is the state of the art right now, even though it has some problems
08:41:29 <seequ> merijn: I apparently missed how this started. :)
08:41:40 <sm> the "god damn" raised the heat level, I think
08:41:43 <ertes> Layl: in fact GHCJS is even used commercially
08:42:39 <Layl> ertes: as a serious question: why isn't this mentioned on the #1 google result page for "haskell js"
08:42:40 <merijn> seequ: The start of the conversation started with "people have to document their code", which people then disagreed with, because complaining at authors for lack of documentation is only helpful if documentation was left out out of naivete (i.e. no one needs it)
08:43:04 <merijn> seequ: Whereas in reality documentation mostly gets left out because it doesn't contribute to whatever the author was trying to accomplish
08:43:32 <sm> Layl: because haste has a domain name and is older, I guess
08:43:34 <johnw> merijn++
08:43:42 <Layl> on the resulting page, which is "The JavaScript Problem" on the haskell wiki, GHCJS doesn't show up until 3.3
08:44:02 <davean> Layl: it is the #1 on duckduckgo
08:44:12 <seequ> merijn: Right, indeed. I found where this started. I think Layl made just an exaggerated point out of frustration.
08:44:35 <sm> davean: not for me :)
08:45:03 <titusgg> Trying to build xmonad-contrib from git and get error re getXmonadCacheDir not being in scope 
08:45:06 <johnw> as a targeted complaint, it could succeed if the haste author were here; as a generalized complaint, we take umbrage because... we might guilty for not writing docs :)
08:45:08 <seequ> It very much depends on what your motivation is for publishing a tool/library.
08:46:00 <Xyliton> how do you detect patterns in images, like QR, with Haskell?
08:47:04 <merijn> Xyliton: I'm not entirely sure how to interpret that question?
08:47:30 <Layl> Xyliton: do you have 12 months for the full explanation?
08:47:36 <seequ> If it's just something you wrote for yourself and decided someone might find it useful, I don't expect docs. But if someone releases a library that's designed especially for widespread use, I'd expect good docs.
08:47:37 <davean> yah, I mean "Exactly the same as any other language" is a valid answer - the algs don't change.
08:48:46 <Layl> seequ: I can see the point in things like... publishing just because it's easy and why not, not because you meant it to be used by others
08:48:55 <johnw> seequ: the addage "what the market will bear" applies in open source too; if everyone is willing to use an undocumented library, then it may never be document; if not, it puts pressure to create good docs. There is no moral absolute to dictate that docs must appear for something to be good or useful or successful; it just changes the audience.
08:48:59 <merijn> seequ: Right, but presumably authors of the latter are already aware of the latter. Because I find it hard to believe no one thinks that's worthwhile :)
08:49:15 <Xyliton> merijn: I want to detect a somewhat simple pattern (it encodes 16 bits). It isn't QR though. Is there anything I could use in Haskell in order to detect that stuff?
08:49:32 <seequ> merijn: It was just my personal conclusion of the matter. :)
08:49:56 <Layl> There's no obligation for docs, I agree, but when you publish a tool with the intent to have people use it, lack of docs is one of the easiest ways to kneecap that purpose
08:50:10 <johnw> Layl: that's a fair point, and quite correct
08:50:20 <merijn> Like half my day consists of using academic tools/software, if you think no tools/documentation is bad, try running software written by academics >.>
08:50:33 <johnw> I know that I've hobbled some of my own projects by not writing docs; problem is, getting motivated to do it when I don't need those docs myself.
08:50:52 <merijn> johnw: Or when you don't get paid to support/write docs and thus not have the time for it :)
08:51:10 <johnw> the only incentive would be... project popularity?  and that's just not enough apparently
08:51:12 <Layl> johnw: or when you're on a deadline of 3 more days and it's not your day job
08:51:21 <shapr> "I wrote this code for me, but you can use it too. Feel free to write docs"
08:51:30 <davean> Layl: often when I publish its to share my code with other people actively working in the field - they could have writen it themselves, but I wrote it and they wrote other things and we're just sharing in public
08:51:33 <sm> totally correct. But you don't need to swear at them.. just rate them, compete with them, build consensus to raise community standards..
08:51:46 <merijn> I get paid to write papers, making sure it runs on anything other than my machine and the university cluster is just "nice to have" :)
08:52:09 <shapr> I totally meant to write Haskell docs this year, but life has been in the way.
08:52:26 <davean> shapr: So yah ...
08:52:32 <johnw> shapr: my todo list has "Document XXX" repeated like 30 times over; and yet I just keep writing new code instead
08:52:58 <davean> johnw: thank you! I personally have appreciated your priorities ;)
08:53:19 <shapr> Yeah, everyday I'm using several things that johnw wrote.
08:53:34 <johnw> shapr: and I wonder how you figured out how to use them ;)
08:53:49 <shapr> honestly, reading the source code
08:53:59 <seequ> Documentation has a terrible catch: the longer you postpone it, the more work it is
08:54:00 <davean> shapr: so he did document it!
08:54:05 <shapr> that's how I found eshell-toggle-cd
08:54:16 <Layl> I find often that documentation, like tests, guide my API
08:54:24 <Layl> If it's not easy to document, perhaps my API should be better
08:54:30 <sm> I'm a big fan of this
08:54:50 <Benzi-Junior> is there a way to have ghci just execute the lines of a file without trying to check it as a module (or even well formed haskell)
08:56:40 <Benzi-Junior> so I can quickly repeat a bunch of different steps when I'm starting up ghci (like let statements and additional imports and things)
08:56:56 <Layl> honestly, I think the simplest solution right now for me to get my project working is actually to install archlinux from scratch
08:57:10 <Layl> that isn't often the simplest solution, but it's it here
08:57:33 <Benzi-Junior> Layl: what's broken ?
08:57:42 <johnw> Layl: I'm sure there's a world within the multiverse where I do that, because it's nicely user (rather than implementation) oriented
08:58:14 <Layl> Benzi-Junior: mainly it's that GHCJS is going to require me to set up mingw, which has given me more pain in the past than any other tool
08:58:15 <merijn> seequ: Not if you obsolete your old code :)
08:58:30 <Layl> I would rather set up archlinux from scratch than allow mingw on my HDD again
08:59:54 <Layl> That, or get ubuntu-on-windows updated to the version running in the insider previews
09:00:03 <cocreature> Layl: depending on how tied you are to Haskell, you could also try purescript which is a bit easier to set up and seems to have a bigger userbase
09:00:35 <Layl> cocreature: Tried it a bit, I would rather want to get haskell working
09:01:37 <ij> Does this thing have multiple sigs per a single name? https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-At.html#t:Ixed
09:02:33 <merijn> ij: What do you mean?
09:02:37 <cocreature> ij: the second is the signature of the default implementation
09:03:16 <merijn> oh...that's unfortunate haddock rendering
09:03:28 <cocreature> yep, I had to look at the source to figure that out
09:04:22 <ij> I see.
09:04:31 <davean> Layl: why not just use a VM?
09:04:52 <davean> Layl: you can just launch a VM instance with everything installed already
09:05:41 <Layl> davean: mostly the problem of transferring files and the slowness of the VM
09:06:11 <merijn> slowness of the VM? If you have any CPU less than a decade old that's really not true
09:06:14 <davean> VMs should be ~ native speed with a small deviation for TLB management and IO abstraction
09:06:34 <merijn> Everything has hardware virtualisation support nowadays
09:08:44 <davean> oh wait, what VM options are available on windows? Is it still VMWare style?
09:08:52 <Krispyeeee> hello
09:09:10 <Layl> merijn davean: In theory, yes, in practice that hasn't been my experience
09:09:20 <Layl> even with things like GPU passthrough
09:09:39 <Layl> davean: best option on windows is likely going to be VirtualBox
09:10:05 <merijn> davean: VirtualBox works fine for me on Windows
09:16:16 <shapr> today's popular Haskell app: https://github.com/koalaman/shellcheck/
09:16:18 <ertes> developing on windows sounds like a nightmare, if you're seriously considering a linux VM =)
09:16:25 <shapr> Several of my coworkers use shellcheck, thanks koala_man !
09:18:07 <ggVGc> shellcheck is a must
09:18:08 <ggVGc> imo
09:18:13 <ggVGc> it taught me a low of bash in a short time
09:18:56 * ertes went away from writing shell scripts instead
09:22:00 <shapr> davean: I think I talked to sm about a repo to collect example-based docs for the most popular Haskell libs
09:35:58 <mmachenry> I'm confused about stack global import. This is my global stack.yaml http://lpaste.net/9123348759701356544. But when I run stack ghci and try "import FD" it is not found.
09:36:31 <mmachenry> However, when I try this in a stack project, and add that to the yaml, and then add finite-domain to my cabal file, I can then import FD just fine in my project's src files.
09:36:59 <mmachenry> But there is no global cabal file, is there? How do I make a github repo globally importable by my ghci?
09:37:57 <koala_man> shapr: glad you find it useful!
09:38:04 <kadoban> mmachenry: stack ghci --package finite-domain
09:38:58 <johnw> is there a ByteString-based version of System.Process?
09:39:26 <johnw> ah, process-extras
09:40:03 <mmachenry> kadoban: Oh‚Ä¶ huh. Is there a way to configure this such that it's always available to import?
09:40:52 <mmachenry> kadoban Also when I do that I get "The following target packages were not found: finite-domain"
09:41:34 <kadoban> mmachenry: Try setting the extra-dep: true flag on that package maybe? I didn't think it'd be required for that, but ... maybe
09:42:07 <kadoban> mmachenry: Oh, the package name is 'fd' apparently, I just guessed from the github repo name.
09:42:32 <mmachenry> Doesn't seem to work.
09:42:57 <mmachenry> Oh shoot you're right!
09:43:38 <mmachenry> So that made ‚Äîpackage work
09:43:42 <kadoban> mmachenry: As to how to have it be automatically available ... not sure, I don't use stack ghci outside of package contexts much ... maybe a shell alias? Kind of funky though. I think in practice after the first time you don't actually have to specify --package, it'll still be available, but I'm not sure how reliable that is.
09:43:52 <mmachenry> But that actually opens every module immediately.
09:44:10 <mmachenry> I'm hoping to emulate the experience I have from stuff that is available with stack install.
09:44:16 <kadoban> Hmm, probably extra-dep: true will make that not happen ... maybe
09:44:28 <mmachenry> Basically, that it's never in my ghci until I say import, and if I do it imports it just fine
09:44:49 <jstolarek> I'm struggling to run HPC
09:44:56 <jstolarek> I managed to get *.tix file from GHC
09:45:04 <mmachenry> Extra-dep true caused it to always import.
09:45:08 <jstolarek> but can't figure out how to generate a report from it
09:45:23 <mmachenry> Which is somewhat useful, but still really annoying to import into every ghci session I'm using.
09:45:34 <jstolarek> hpc executable keeps complaining that it cannot find modules of my application
09:45:52 <kadoban> Sounds weird, I dunno sorry.
09:45:57 <jstolarek> and expects an .hpc directory, which does not exist
09:46:01 <jstolarek> any suggestions?
09:46:18 <mmachenry> No problem. Thanks for helping. I'm further along than I was at any rate. :)
09:46:32 <kadoban> :) anytime
10:06:58 <ertes> is there a way to reset some of the GC stats?  most notably heap residency
10:07:01 <ertes> uhm
10:07:07 <ertes> *maximum* heap residency
10:08:28 <ertes> that is the maxBytesUsed field in base/GHC.Stats/GCStats
10:13:21 <saurabhnanda> is it possible to build a stack project in a limited memory environment? Perhaps by limiting the memory available to RTS? How does one do it?
10:13:26 <Xyliton> how do I convert from DynamicImage to a gryscale one in JuicyPixels?
10:13:26 <ertes> alternatively: is there a way to hook into GC?  i.e. run an IO action just after every GC
10:14:21 <MarcelineVQ> saurabhnanda: possibly +RTS -H2G or similar
10:14:35 <MarcelineVQ> actually -M
10:15:06 <kadoban> saurabhnanda: I don't know much, but I'd personally be surprised if that worked at all. It should be GHC itself using the memory, mostly, not stack.
10:15:36 <kadoban> The best luck I've had in the past is by trying to make everything run as sequential as possible instead of parallel, I think -j1 might be it, I forget if there's more you can do.
10:16:32 <saurabhnanda> kadoban: right. how to pass it down to GHC?
10:17:34 <kadoban> Does GHC even take RTS options? There is --ghc-options in stack, though ... I dunno maybe. If GHC does accept RTS options, it's possible it'll work?
10:17:45 <ertes> Xyliton: you can use ColorConvertible, but you still have to pattern-match on the DynamicImage yourself
10:18:07 <ertes> Xyliton: there is also dynamicMap, but i see no way to branch on whether a pixel type is ColorConvertible
10:20:13 <ertes> Xyliton: ah, wait‚Ä¶  i read the docs wrong‚Ä¶  ColorConvertible only supports promotion, never loss of data
10:20:27 <MarcelineVQ> kadoban: it does. however rts memory limits kill the offender, so it's probbaly not a solution if they need a build to complete
10:20:43 <kadoban> Hmm, good point
10:21:23 <ertes> Xyliton: ah, there is LumaPlaneExtractable
10:26:21 <Xyliton> ertes: I tried to do this http://lpaste.net/351396 but it errors with "Non-exhaustive pattern in function dynToImg"
10:27:13 <Xyliton> how would I extract the luma plane?
10:27:17 <ertes> Xyliton: what does that function return when it's an ImageYF?
10:27:26 <ph88> if i import a class is there some way to modify the default implementation ?
10:27:47 <ertes> Xyliton: you would apply 'extractLumaPlane'
10:27:52 <ertes> Xyliton: https://hackage.haskell.org/package/JuicyPixels-3.2.8/docs/Codec-Picture-Types.html#t:LumaPlaneExtractable
10:28:17 <ertes> ph88: no
10:29:23 <Xyliton> ertes: here's my current code: http://lpaste.net/351398 I didn't try to give it an ImageYF yet
10:32:27 <ertes> Xyliton: dynToImg (ImageY8 img) = extractLumaPlane img
10:35:00 <joe9> Hello, I want to see the Core output, STG output and the cmm output for a haskell program. Any suggestions on how I can do that please?
10:36:13 <Xyliton> ertes: it's using extractLumaPlane now but it still throws the same error
10:36:35 <ertes> Xyliton: say you write a function of type Bool -> Bool
10:36:50 <ertes> Xyliton: myF True = True  -- this is the whole definition
10:37:01 <ertes> Xyliton: do you see a problem with this function?
10:37:18 <Xyliton> umm...
10:37:27 <Xyliton> not really, I guess it's just redundant
10:37:38 <ertes> @let myF True = True
10:37:41 <lambdabot>  .L.hs:199:5: error:
10:37:41 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòBool‚Äô with ‚ÄòInt‚Äô
10:37:41 <lambdabot>        Expected type: Foo Int
10:37:54 <ertes> @let myF :: Bool -> Bool; myF True = True
10:37:56 <lambdabot>  .L.hs:197:1: error:
10:37:56 <lambdabot>      Duplicate type signatures for ‚ÄòmyF‚Äô
10:37:56 <lambdabot>      at .L.hs:173:1-3
10:37:59 <ertes> @undef
10:38:00 <lambdabot> Undefined.
10:38:02 <ertes> @let myF :: Bool -> Bool; myF True = True
10:38:04 <lambdabot>  Defined.
10:38:08 <Xyliton> lol?
10:38:17 <ertes> > myF True
10:38:19 <lambdabot>  True
10:38:21 <ertes> > myF False
10:38:23 <lambdabot>  *Exception: /tmp/mueval14693480941956297539.hs:161:1-15: Non-exhaustive patt...
10:38:31 <ertes> Xyliton: now do you see a problem?
10:38:34 <Xyliton> yes
10:38:42 <ertes> Xyliton: your function suffers from the same problem =)
10:38:45 <Xyliton> oh
10:38:58 <ertes> Xyliton: https://hackage.haskell.org/package/JuicyPixels-3.2.8/docs/Codec-Picture-Types.html#t:DynamicImage
10:39:17 <ertes> there are many cases, but yours is only handling the ImageY8 case
10:39:25 <Xyliton> so I have to handle every case?
10:39:29 <Xyliton> ;-;
10:39:51 <Xyliton> why is there no simple DynamicImage -> GreyScaleImage function?
10:39:55 <ertes> Xyliton: of course‚Ä¶  what if the image is 24-bit RGB?  you have not written what would happen then =)
10:40:00 <MarcelineVQ> joe9: I'd reccomend the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#compiler-debugging-options
10:40:14 <Xyliton> ertes: because everything will become the same, kinda
10:40:32 <joe9> MarcelineVQ: Thanks a lot.
10:40:33 <MarcelineVQ> -ddump-simpl is generally used for core, along with -dsuppress-all   the others you should be able to find easily
10:40:35 <ertes> Xyliton: i'm pretty sure if you contributed such a function, it would be included‚Ä¶  although it would be more useful to write variants of dynamicMap that support more type classes than Pixel =)
10:43:52 <ertes> Xyliton: dynamicMapLuma :: (forall pixel. (LumaPlaneExtractable pixel => Image pixel -> a) -> DynamicImage -> Maybe a
10:43:56 <ertes> i would start by writing this function
10:44:19 <Xyliton> I have no idea what this means, though ;-;
10:44:40 <ertes> Xyliton: in that case just pattern-match for now =)
10:44:55 <Xyliton> should I pattern match EVERY possibility?
10:45:28 <ertes> Xyliton: yes, but catch-all patterns are possible
10:45:55 <Alxandr> Hi. I just got a build error from a stackage package O_o
10:46:04 <Alxandr> Doing stack.build
10:46:11 <Alxandr> (stack build I mean)
10:46:37 <ertes> Xyliton: something like this for all LumaPlaneExtractable cases: dynGreyscale (ImageY8 img) = Just (extractLumaPlane img)
10:46:44 <glguy> Alxandr: You'll have to tell us the error
10:46:49 <ertes> Xyliton: and then a catch-all case:  dynGreyscale _ = Nothing
10:46:52 <Alxandr> Yeah, making paste
10:47:12 <lpaste> Alxandr pasted ‚ÄúBuild error dns stackage‚Äù at http://lpaste.net/351400
10:47:49 <ertes> Xyliton: or, if you want to avoid the Maybe, come up with a way to greyscale the image types that aren't LumaPlaneExtractable
10:48:14 <ph88> i have this code which compiles (it's missing a few parts in the paste though) https://paste.fedoraproject.org/530005/14847651/ is it possible to abstract line 6-8 and line 16-18 somehow so that i don't have to repeat this for every type ?
10:48:20 <glguy> Alxandr: That's some windows-specific code that doesn't work any more
10:48:25 <glguy> https://github.com/kazu-yamamoto/dns/blob/master/Network/DNS/Resolver.hs#L442-L448
10:48:57 <Alxandr> So basically the package doesn't work on windows?
10:49:03 <glguy> Alxandr: The code probably changed and no one ever tried on it on Windows since the change
10:49:09 <Alxandr> :(
10:49:26 <glguy> Time to file an issue https://github.com/kazu-yamamoto/dns/issues
10:51:23 <glguy> ph88: You could use Template Haskell to generate the instances; I don't think there's a shorter way than that for what you have
10:52:09 <ptek> is there anyone from the haskell committee around?
10:52:32 <mmachenry1> ptek: You might want to just ask your real question. 
10:52:44 <ph88> so it's not possible to make my own class that defines an instance for another class or something ?
10:53:05 <old1101> hello, can anybody tell me why this code works? https://codepaste.net/1uidrs The expression executes the code, how? What am I missing? ): (it's from cis194 hw5 exercise 6)
10:53:21 <ph88> instance Foo DesignFile where  instance Arbitrary DesignFile where   
10:53:32 <ph88> probably not existent this syntax ^^
10:53:45 <ptek> mmachenry1: the donation via Stripe seems not to work on https://www.haskell.org/donate
10:54:09 <cocreature> ptek: iirc there is a comittee mailing list. you might have more luck there
10:54:14 <ph88> old1101, why the code works or how the code works ?
10:54:44 <old1101> ph88, sorry, the "how"
10:55:03 <ptek> cocreature, I have sent some emails today, but thought maybe I would catch someone around here...
10:55:17 <Alxandr> Well, that was annoying :-/
10:55:49 <Alxandr> Anyone know any other dns library avail for haskell?
10:55:52 <lpaste> glguy pasted ‚Äúfor ph88; th generated instances‚Äù at http://lpaste.net/351401
10:55:57 <cocreature> ptek: the easiest way to figure that out is to just substitute the definitions one by one
10:56:11 <ph88> oh thanks glguy i will look in a moment, i was looking at old1101 his problem
10:56:27 <ptek> cocreature, what do you mean? :)
10:56:31 <ph88> old1101, have you looked here?  https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Map-Strict.html#t:Map
10:56:35 <cocreature> ptek: i.e. start with "withVars [("x", 5)] (var "x"), then substitute the definition of var, then substitute the definition of withVars, then start evaluating and you‚Äôll end up with Just 5
10:56:41 <ertes> Alxandr: if you don't need any async stuff, you could just use the network library
10:57:01 <Alxandr> I need to do simple name lookup to a spesific name server
10:57:07 <ptek> cocreature, I think you mean to write to someone else
10:57:21 <cocreature> ptek: oh sry
10:57:21 <Alxandr> Like doing "ask 8.8.8.8 where google.com is"
10:57:32 <cocreature> old1101: the above was directed at you :)
10:57:35 <glguy> old1101: Do you have a more specific question about that code than "how"?
10:57:50 <ertes> Alxandr: in that case fixing 'dns' is your best bet
10:58:13 <ph88> i think old1101 went afk :(
10:58:21 <Alxandr> In this case it's probably a better bet to just go with node/pyhon
10:59:10 <Xyliton> ertes: I don't have to grayscale every single type of image so that's not too much of a problem (it's only for a school project with a limited amount of test data)
10:59:38 <Xyliton> it now calculates the edges using the canny algorithm flawlessly (although it's a bit slow IMO)
10:59:46 <ertes> Alxandr: well, choose between: more complexity due to having to fix a library, and more complexity due to language limitations‚Ä¶  i'd fix dns =)
11:00:53 <Alxandr> Yeah. Normally I'd agree. But this is a small application I need for my master thesis that are to do a simple thing, so the hole thing will probably end up with less than 100 LOC regardless. And considering I'm new to haskell, figuring out what's wrong with dns is probably a rather large task for me.
11:00:55 <old1101> my basic understanding is that (withVars vs expr = expr (M.fromList vs)) M.fromList creates a Map and somehow the expr executes it, but the expression is (var "x") :: HasVars a => a
11:01:08 <old1101> how it is linked to the MapExpr or something
11:01:13 <ertes> Xyliton: the API of JuicyPixels could use some improvement‚Ä¶  the few times i've used it i raced to get out of DynamicImage as soon as possible after i acquired it
11:02:09 <ertes> Xyliton: e.g. go to PixelRGB8 or PixelRGB16 immediately and just use true-colour functions for everything
11:02:20 <maerwald> ertes: I found the API to be a bit "naive", but that was some time ago
11:02:21 <Xyliton> ertes: I'm using friday for the actual manipulation so JP is only for loading/saving the files
11:02:34 <maerwald> as in: you're somewhat confused here and there as a power user
11:02:38 <ph88> glguy, that last line  how can i make an instance for a single data?  makeInstance [t|A|]  ?   then i will place this one-liner with each data , it's still better than 3 lines
11:03:06 <Xyliton> ertes: I'm a bit confused about how I should implement the Hough transformation now, though
11:04:30 <ertes> Alxandr: at least you should report the bug‚Ä¶  with a bit of luck you might find it fixed very quickly
11:04:48 <Alxandr> Already did
11:05:02 <glguy> ph88: You can do that, but you'll need to define 'makeInstance' in a separate module and import it then
11:05:46 <Alxandr> I also added an issue to add appveyor testing
11:07:37 <ph88> old1101, second argument of withVars should be of type MapExpr, then you put as second argument (var "x") then it's gonna look for a function var and it finds one available in class HasVars, then it's gonna look for a function var that gives the MapExpr that you need, then it finds one in instance HasVars MapExpr, then it's gonna replace var with M.lookup so you have (M.lookup "x)
11:08:11 <ph88> oh he left :/
11:08:38 <nitrix> Hi. Given `data Foo a = Bar`, is the type constructor `Foo` considered injective?
11:09:02 <ph88> is making a new module as simple as creating a new file with the same name ?
11:09:05 <glguy> nitrix: yes
11:09:19 <nitrix> I'm trying to apply what I know at the type & kind level.
11:09:32 <nitrix> glguy: Appreciated. Do you have a surjective example?
11:10:22 <eze> I can't see why the law: fmap f u = pure f <*> u, holds from the applicative laws
11:10:53 <eze> I mean, how can you derive the naturality of pure from the other laws°
11:10:57 <nitrix> glguy: Is it even possible?
11:11:01 <Alxandr> Anyways, thanks for the help :). I'll be back again whenever I'm stuck :P
11:11:57 <nitrix> glguy: Would `data Foo = forall a. Bar a` be surjective ?
11:12:34 <glguy> nitrix: When you're talking about types it doesn't matter what's to the right of the =
11:12:50 <nitrix> Ah I see.
11:13:01 <nitrix> Foo is the type constructor.
11:13:15 <nitrix> You can't have a surjective type constructor?
11:13:21 <ertes> nitrix: only type aliases can be surjective:  type Bar a = ()
11:13:33 <glguy> Perhaps  type A a = a
11:13:37 <glguy> or similar
11:13:42 <ertes> uh
11:13:52 <ertes> nevermind
11:14:53 <Xyliton> would something like this still be detectable? https://puu.sh/tqQt9.png
11:15:16 <Xyliton> s/detectable/readable
11:16:08 <MarcelineVQ> ertes: Possibly there's an option for your gc tracking, if you're polling often enough. It's not in current docs though :X Seems to be on head. https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Stats.hsc
11:16:40 <MarcelineVQ> with that you'd have access to gc info via gc :: GCDetails of RTSStats
11:16:53 <nitrix> glguy: Wouldn't that be injective?  `A Int  becomes Int`, `A Double becomes Double`, seems unique to me.
11:17:17 <nitrix> glguy: ertes's example with `Bar Int becoming ()` and `Bar Double becoming ()` makes mroe sense to me.
11:17:20 <glguy> Well, it's both injective and surjective
11:17:27 <ertes> nitrix: A is injective and surjective
11:17:42 <nitrix> Oh yeah you're right.
11:17:43 <MarcelineVQ> ertes: It's much more detailed info than was previously available
11:18:03 <nitrix> And Bar is only surjective?
11:18:05 <ertes> MarcelineVQ: i'm not entirely sure how to use it for profiling though
11:18:08 <nitrix> ertes: glguy ^ ?
11:18:10 <MarcelineVQ> At least in-sofar as resolution goes, since you can poll the most recent gc
11:18:27 <ertes> nitrix: Bar is not surjective
11:18:36 <nitrix> ertes: How come?
11:18:52 <ertes> surjective would mean: ‚àÄ b. ‚àÉ a. Bar a ‚âÉ b
11:19:00 <ertes> counter-example: b = Bool
11:19:12 <ph88> glguy, it works now with   makeArb [t|DesignFile|]   is that syntax with [t| ]  really needed ?
11:19:24 <nitrix> ertes: Having unicode problems. Can you rewrite?
11:19:50 <glguy> ph88: another option is the syntax: makeArb ''DesignFile
11:20:03 <glguy> you can pass the *name* of the DesignFile type instead of the type DesignFile
11:20:16 <glguy> this is more limited, because you only get to pass single names, not whole types
11:20:17 <ertes> nitrix: for all 'b' there exists 'a' such taht (Bar a) isomorphic to 'b'
11:20:27 <glguy> e.g. [t| Something a b c |]
11:21:03 <ph88> glguy, i think the function has to change now because it's giving some type errors
11:21:17 <glguy> Yup, you'll have to update it to support names instead of types
11:22:20 <old1101> glguy, ph88, I figured it out, instance X with a function was a little mindblowing for me thanks
11:22:24 <glguy>       [d| instance Arbitrary $(conT n) where
11:22:48 <ertes> nitrix: (^2) :: Integer -> Integer  -- its image does not cover all integers, so not surjective
11:22:49 <nitrix> ertes: But the only `b` possible is `()`. Shouldn't that mean that `forall a. Bar a` are all isomorphic to () ?
11:23:05 <glguy> old1101: That example is non-standard Haskell in two ways, it makes an instance of a type synonym, and it makes an instance of a type that isn't of the form: (T a b c...) type constructor applied to zero or more type variables
11:23:14 <ertes> nitrix: Bar :: * -> *  -- its image does not cover all types up to isomorphism, so not surjective
11:23:26 <nitrix> ertes: Oww...
11:23:49 <nitrix> ertes: YOu mean like Int# isn't covered?
11:24:07 <ertes> nitrix: or even just Bool
11:24:17 <nitrix> type Bar a = ()
11:24:18 <ertes> Bar will never return a type that is isomorphic to Bool
11:24:28 <nitrix> Bar Bool ~ ()
11:24:36 <nitrix> ertes: I'm not following, it should be isomorphic.
11:25:19 <ertes> nitrix: read again:  for all types 'b' there exists an 'a' such that (Bar a) is isomorphic to 'b'
11:25:29 <nitrix> ertes: Maybe I'm entangled in my understanding of surjective.
11:25:47 <nitrix> Oh crap it's reversed!
11:26:09 <nitrix> Bar a is isomorphic to `b`. `Bar a`, which will always be `()`, cannot be Bool, for sure.
11:26:11 <nitrix> :O
11:26:17 <Akii> :D
11:27:02 <nitrix> ertes: It clicked.
11:27:15 <ertes> nitrix: and the graphical way to think about it is:  the image of Bar (all types isomorphic to ()) would have to cover its entire codomain (all types), which is clearly not the case
11:27:15 <nitrix> That means I need more practice though until this becomes a reflex.
11:27:16 <old1101> glguy: I'm starting with haskell and this example was hard to follow, do you have any suggestion how it should have been done (haskell standard way;clean code)? https://codepaste.net/1uidrs
11:28:29 <nitrix> ertes: So to summarize cheaply, phantom types are bijective and type aliases are injective?
11:28:37 <nitrix> Is this always the case?
11:28:43 <glguy> nitrix: Being phantom wasn't relevant
11:29:06 <nitrix> glguy: So can I entend that claim to all type constructors?
11:29:08 <glguy> 'data' always declares an injective type 
11:29:18 <nitrix> Interesting.
11:29:25 <glguy> type constructor describes a name
11:29:42 <glguy> it doesn't tell us if we have a type family, data type, type synonym, newtype
11:30:14 <nitrix> I'm starting to realize the distinction is very important now.
11:30:45 <Akii> ++
11:31:01 <nitrix> glguy: ertes That was invaluable. Very appreciated from the two of you (:
11:32:47 <glguy> old1101: This code exists to show these aspects of the language. It's hard to say how I'd rewrite it in general because it is it's own specification
11:33:16 <glguy> old1101: a "standard" way to achieve the same thing would be to use a 'newtype' instead of a type synonym when defining MapExpr knowing that we wanted to make instances for it
11:34:13 <old1101> glguy: makes sense
11:54:19 <plugins> I have a question about multiparam type classes and fundeps.  The following gist has a snippet which fails the 'liberal coverage condition', but I'm not sure why as it looks to me like s and t do in fact uniquely determine t. https://gist.github.com/o1lo01ol1o/8319c986b27fcf0d06fbc89552e0760a
11:55:54 <ph88> maybe you need some more extensions :P
11:56:10 <plugins> there's more? I thought I got all of them
11:56:33 <ph88> hahaha :D
11:56:51 <plugins> i'm using singltons to get some depedant type magic so I need a lot 
11:57:03 <glguy> plugins: Why are you using functional dependencies at all there?
11:57:33 <Xyliton> Is it possible to run the GHC package (for windows) from a usb stick?
11:57:42 <glguy> plugins: class ValidBroadCast s t ~ True => BroadCastAlgebra s t where;    (+) :: (Tensor s fv a) -> (Tensor t fv a) -> (Tensor (EvalBroadcast s t) fv a)
11:58:46 <glguy> plugins: You can reply in channel
11:59:04 <plugins> sorry, never really did much IRC :)
11:59:18 <plugins> the shapes of the tensors are encoded in s t and u
11:59:24 <glguy> In your paste functional dependencies weren't giving you anything
11:59:25 <RandoCoder> What is the convention for how to manage different environments like dev or prod and how that affects dependencies such as which database to connect to?
11:59:35 <plugins> the binary operations will determin the shape of u from s and t
11:59:37 <glguy> plugins: You already encoded the information in the type family
11:59:47 <EvanR> RandoCoder: i like env vars
11:59:53 <glguy> so you don't need the 'u' typeclass parameter or fundeps at all
12:00:09 <knupfer> How can I delete duplicates from a  (Data.Tree a) ?
12:00:22 <plugins> but I do if I want ghc to infer what 'u' is 
12:00:30 <glguy> plugins: There is no u
12:00:40 <maerwald> cabal flags could also be an option
12:00:43 <plugins> how's that?
12:01:19 <glguy> plugins: I added the fix to your paste
12:01:49 <plugins> oi vey, yes, yes that would also work
12:02:01 <plugins> I got mired in the singltons paper and was overcomplicated
12:02:10 <plugins> overcomplecating
12:03:14 <plugins> thanks alot!
12:03:19 <glguy> you're welcome
12:17:23 <mstruebing> I have a stack.yaml, in which is ncurses-0.2.16 is defined as extra deps, but when I do a stack build it tells me that he cant find the ncurses header, what is wrong?
12:19:35 <glguy> ncurses is a C library, did you install it? On some systems you need to also install the associated "development" package for the C library
12:19:39 <Geekingfrog> mstruebing, my guess is that you need the dev version of ncurse lib installed
12:19:56 <Geekingfrog> What is your system ?
12:20:01 <mstruebing> ah so it isn't coming from stack, i need this on my system?
12:20:04 <mstruebing> I have arch-linux
12:29:46 <Geekingfrog> mstruebing, so apparently the haskell package is looking for the wrong ncurses headers (https://bugs.archlinux.org/task/17590)
12:30:08 <Zemyla> Okay, so lenses and prisms are profunctor transformers on Strong and Choice, like a lens is (Strong p, Functor f) => p a (f b) -> p s (f t), and a prism is the same with Choice...
12:30:09 <Geekingfrog> Do you absolutely need/want ncurses or anything to develop in a terminal would work ?
12:30:15 <mstruebing> yep
12:30:16 <Zemyla> Then what do we get for Costrong and Cochoice?
12:30:28 <mstruebing> i absolutly want, it is a meetup where we code together on a snake game 
12:30:34 <mstruebing> i just wanted to set  it up before
12:30:48 <mstruebing> is there any working out of the box docker image then or something what i can use?
12:31:06 <mstruebing> or do i have to do it myself
12:31:37 <Geekingfrog> I don't know, never used ncurses :/
12:32:35 <Tuplanolla> Use `pacman`'s search to look for `*ncurses*dev*`, mstruebing. Does anything come up?
12:34:11 <mstruebing> sadly not
12:34:41 <Tuplanolla> Well, check AUR then.
12:35:07 <mstruebing> i did :P
12:35:22 <mstruebing> https://aur.archlinux.org/packages/?O=0&SeB=nd&K=*ncurses*dev*&outdated=&SB=n&SO=a&PP=50&do_Search=Go
12:35:39 <Tuplanolla> How about `*ncurses*head*` or `*ncurses*compat*`?
12:35:59 <mstruebing> could it be that i need this? https://aur.archlinux.org/packages/haskell-hscurses/
12:36:07 <mstruebing> or is this something else
12:36:26 <Tuplanolla> @hackage hscurses
12:36:26 <lambdabot> http://hackage.haskell.org/package/hscurses
12:36:37 <Tuplanolla> It's that thing.
12:43:53 <geekosaur> but it's for whatever arch packages as ghc, not whatever you are using with stack (and not controlled by stack therefore can cause conflicts)
12:45:14 <mstruebing> argh
12:45:17 <mstruebing> now i get an other error
12:46:47 <mstruebing> http://sprunge.us/Pjga
12:47:08 <mstruebing> while `stack install`
12:47:21 <Tuplanolla> How did you get here?
12:48:08 <mstruebing> i typed /j #haskell
12:48:14 <Tuplanolla> Not literally.
12:48:34 <libscott> If I didn't specify dependency versions in my cabal file (since I am using stack), is there any way to auto generate the min and max version required for each dependency?
12:49:43 <kadoban> libscott: If there is, I'd be interested in hearing about it. Personally I seem to just ... try the oldest and newest resolvers manually and see if they work, if they do I put those major versions as requirements. No guarantees that's actually a good idea, but I've yet to be shown a better idea.
12:49:44 <glguy> It's not possible in general to guess what versions of packages you support
12:50:03 <glguy> You'll have to write down which versions of the packages you support
12:50:41 <libscott> Right
12:53:39 <libscott> so kadoban you try different stack resolvers and if they work dump out the results of `stack list-dependencies` and work with the min and max set?
12:54:15 <kadoban> libscott: Ya, essentially. I use the website to check the deps, but ... list-dependencies actually sounds easier/better
12:55:33 <libscott> seems like a good plan
12:59:27 <libscott> Seems that then each time there's a new Stack resolver you should check it manually, update the max dependency version and push a new version to hackage. Seems like there's nothing stopping this process from being automated, really, but I guess there may be edge cases in pratice 
13:00:24 <glguy> Note that if new versions of your dependencies come out and you're compatible with the new version without any code changes, you can update your bounds information without releasing a new version on hackage
13:03:38 <kadoban> libscott: I don't think you have to keep it at *exactly* the maximum bounds that are in stack resolvers, I usually round up and assume anything with the same major version is going to be fine, unless shown otherwise.
13:04:43 <ph88> this debug output is in the opposite order as i was expecting at first https://paste.fedoraproject.org/530105/14847733/ i think it's because of lazy evalution, does anyone have a suggestion on how i can reverse the order of the debug output ?
13:05:21 <glguy> ph88: If you don't want the output to follow evaluation order, don't use trace
13:05:41 <ph88> what can i use instead of trace ?
13:05:51 <joe9> these posts are awesome http://alpmestan.com/posts/2013-10-01-ghc-core-by-example-episode-2-evaluation.html
13:06:07 <EvanR> if you want to rearrange the order of evaluation, what exactly are you trying to debug
13:06:16 <joe9> any recommendations for similar posts on the internals, please? Core, STG, etc.
13:06:18 <EvanR> ideally debugging doesnt change whats going on
13:06:29 <ph88> hi joe9 
13:08:35 <sphinxo> is it possible to make an alias for instances
13:09:08 <joe9> ph88: hello
13:09:14 <sphinxo> eg instance JSON User is instance ToJSON User and instance FromJson User
13:09:54 <sphinxo> is this possible?
13:10:00 <ph88> EvanR, i don't want to change the order of evaluation of the parser, but i would like to change the order of the debug output, because when you are trying to follow the parser naturally you will start at the top-level rule and then search down the grammar tree
13:10:09 <glguy> sphinxo: You can use Template Haskell
13:10:11 <byorgey> sphinxo: if it were possible, you would do it by turning on ConstraintKinds and defining   type JSON = (ToJSON, FromJSON)
13:10:23 <byorgey> sphinxo: but I don't know what would happen if you say   instance JSON User
13:10:29 <byorgey> sphinxo: I'm guessing it doesn't work
13:11:14 <EvanR> the parser?
13:11:54 <sphinxo> byorgey:  the typedef doesn't even seem to work with ConstrainKinds
13:12:06 <EvanR> ph88 oh... well you could test each parser in isolation instead of all at once in one big parser
13:12:30 <EvanR> you can also manually add lots of strictness
13:12:36 <glguy> Yeha, it would have to be: type JSON a = (ToJSON a, FromJSON a)
13:12:43 <EvanR> which... i can see messing up the idea of debugging
13:13:10 <glguy> You can write: jsonInstances t = [d| instance FromJSON $(t); instance ToJSON $(t) |]
13:13:12 <ph88> EvanR, since the dbg function takes a parser and returns a parser, you think it might be possible to force the strictness there?
13:13:31 <glguy> later you can write: jsonInstances [t| User |]
13:13:48 <sphinxo> glguy: thanks
13:14:13 <glguy> sphinxo: Advanced warning, you need to define 'jsonInstances' in a different module than the one you use it in
13:14:27 <sphinxo> thanks
13:18:07 <EvanR> ph88: have you heard of debugM :: Monad m => String -> m ()
13:18:25 <ph88> no
13:19:02 <EvanR> you insert it between statements of do notation, it might come in an order you like more, but again, this will cause the monad actions to evaluate in a different order
13:19:22 <EvanR> because you need to implement it with a ! or seq
13:19:53 <EvanR> i would be frustrated if when i remove the debug lines, the thing stops working
13:20:01 <EvanR> because it works differently than when debugging
13:22:21 <ph88> not sure why it would stop working ... i think it should work both lazy and strictly
13:23:23 <ph88> eh actually would that mess up things like StateT ?
13:24:37 <m0rphism> Is there a simple technique for initializing a hint (the haskell interpreter) session the same way `stack repl` initializes ghci? Running `stack repl --with-ghc echo` prints the command line arguments passed to ghci, but hint seems to have no support for using them.
13:28:45 <johnw> EvanR: is that different from traceM?
13:28:57 <m0rphism> As hint uses the ghc-api and ghc has to parse and set command line arguments as well, I wonder how practical it would be to try to reuse the ghc functionality in a hint session.
13:28:58 <EvanR> :t traceM
13:29:00 <lambdabot> error:
13:29:00 <lambdabot>     ‚Ä¢ Variable not in scope: traceM
13:29:00 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòbraces‚Äô (imported from Text.PrettyPrint.HughesPJ)
13:29:47 <EvanR> johnw: traceM string = trace string (pure ())
13:29:58 <EvanR> so yeah, different from behavior i was thinking about
13:30:05 <johnw> k
13:30:26 <EvanR> it would be = trace string () `seq` pure ()
13:30:39 <EvanR> i think
13:30:50 <EvanR> no
13:31:00 <EvanR> do
13:31:13 <EvanR>   !_ <- return (trace string ())
13:31:19 <EvanR>   return ()
13:40:45 <t7> is there a name for sqrt 2 / 2?
13:41:04 <Tuplanolla> How about `1 / sqrt 2`, t7?
13:54:00 <m0rphism> Problem resolved; I've missed the `Unsafe` module from hint which provides `unsafeRunInterpreterWithArgs`.
13:59:21 * m0rphism feels unsafe now.
14:15:00 <chaseries> I'm having a weird problem with yesod devel. I'm running 1.5.1 and it just keeps spitting out the error "yesod: devel TLS port not available"
14:16:04 <chaseries> erp, nevermind. worked it out.
14:16:04 <Rembane> chaseries: What happens if you give it the argument -p 9999
14:16:12 <Rembane> chaseries: Sweet! :)
14:16:48 <chaseries> Rembane: it was still whining at me, but --tls-port worked.
14:16:59 <Rembane> chaseries: Ah, that's very nice.
14:22:01 <joe9> EvanR, just want to double check with you. It appears that GHC Core is pure. Am I wrong? I got that from this paper https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf
14:50:17 <t7> can i solve big multivariable equations quickly if they only use multiplication with a constant, addition and subtraction
14:52:07 <t7> and i know they have a solution
14:55:03 <SuprDewd> t7: sounds like you're looking for Gauss elimination?
14:56:23 <hpc> yeah, what you've described is exactly linear algebra ;)
14:56:59 <t7> oh crap my matrices are gonna be gigantic 
14:59:59 <t7> https://en.wikipedia.org/wiki/Homogeneous_differential_equation ?
15:03:39 <libscott> sure is fun watching cabal install a bunch of dependenies in parallel on a 32 core machine
15:08:21 <byorgey> t7: how gigantic?
15:08:30 <nshepperd> t7: a set of linear equations?
15:08:37 <byorgey> t7: wait, your equations use differentiation too?
15:08:46 <t7> yes thousands of simple equations 
15:08:55 <t7> where blah = 0
15:09:13 <t7> 6 variables max per equation 
15:10:01 <t7> but thousands of variables in total
15:10:03 <byorgey> t7: OK, should be no problem.  Just use any linear algebra library e.g. hmatrix
15:10:21 <byorgey> thousands of variables is not much for a computer.  Especially if only 6 variables per equation.
15:12:03 <t7> byorgey: do they need to be all in one matrix
15:12:09 <t7> ?
15:12:54 <t7> not sure how solving works....
15:13:54 <t7> lots of reading todo
15:23:50 <SuprDewd> t7: if it's one big system of equations (i.e. you want to solve the equations simultaneously), then yes, typically you put them in one big matrix
15:25:09 <biheho> ciao
15:25:16 <biheho> hi
15:25:21 <biheho> hello
15:25:22 <biheho> ciao
15:25:27 <lambdabot> Hello.
15:25:27 <biheho> !list
15:25:30 <SuprDewd> but if you have thousands of equations and variables, you may have to use a sparse solver
15:49:53 <glguy> Did anyone do the Advent of Code problems 12, 23, and 25. They were the ones based around a small assembly language with { inc dec jnz cpy out tgl } instructions. I've been playing with a "final" encoding of the instructions to make it easy merge the 3 days into a single implementation that is able to reuse the common parts between the 3 nicely as well as provide alternate implementations of the interpreter. For example on the problem that produces o
15:49:53 <glguy> utput it's easy to run it in a  way that checks the output or a way that provides a lazy list of the outputs, or to pretty print the instructions, etc
15:49:53 <glguy> https://github.com/glguy/advent2016/blob/master/asmprog-final/Main.hs
15:50:21 <glguy> Anyway, just wanted to share if anyone's interested
15:50:33 <Koterpillar> glguy: I've just made them all use the extended language
15:51:17 <glguy> You can run mine with an interpreter that supports all of them into one language, but you don't have to
15:52:08 <glguy> relevant reading http://okmij.org/ftp/tagless-final/course/lecture.pdf
15:52:57 <Benzi-Junior> hey I'm trying to write an Unbox instance (Data.Vector.Unbox)  for a data type that has two different constructors which take different kinds of parameters, is there a better way to do this than unboxing them as (Word64,Word64) ?
15:54:10 <sm> System.Process seems to always use /bin/sh, but I'm not seeing where that's hard-coded.. any ideas ?
15:54:47 <Benzi-Junior> and then using converter functions to fit them into the Word64 types
15:55:28 <glguy> sm: https://github.com/haskell/process/blob/18bb13c5a4e82dda51aa7bc8ebebebd750b69776/System/Process/Posix.hs#L74
15:57:53 <eikke> Is there any way to check for Cabal version (using CPP) in a Setup.hs?
15:58:37 <davean> eikke: why are you writing a custom Setup.hs?
15:59:02 <eikke> because I have a quite complicated build, including some non-trivial C bits
15:59:18 <davean> yes, what makes it complicated?
15:59:45 <eikke> I need to run autoconf, make, override GHC and ar so it can pick up some generated object files,...
16:00:40 <eikke> sorry, not run autoconf. configure.
16:01:07 <sm> glguy: thanks! I guess that module is not included in haddocks
16:02:47 <kadoban> eikke: You can require a certain version of cabal-install (and thus Cabal I guess?) in the .cabal file, or does that not make sense for what you're doing?
16:03:06 <ertes> eikke: as far as i see it's not possible, but who knows‚Ä¶  cabal has a tradition of undocumented features
16:04:11 <ertes> eikke: in any case conditionals are built-in (no need for CPP), so if all else fails you could just introduce a flag
16:04:31 <ertes> eikke: https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
16:05:33 <eikke> kadoban: the problem with that is by choosing e.g. Cabal 1.20, older setups which are tied to 1.18 no longer work (which is what I'm exxperiencing now, the testHook type changed)
16:05:59 <eikke> ertes: doesnt help caus my Setup.hs still wouldnt compile ;)
16:06:05 <kadoban> Ah, I see
16:09:03 <ertes> eikke: oh, you mean in Setup.hs itself?  even then i don't see a way to do it, as long as you're expecting runhaskell to keep working
16:09:26 <eikke> ertes: focus on 'cabal build' and 'stack build', that should do
16:10:12 <nshepperd> Benzi-Junior: ah, maybe. with something like 'data D = A X | B Y' I would possibly try both of unboxing to (X, Y, Bool) or (Word64, Bool) and see which is more efficient
16:10:30 <nshepperd> assuming you have functions that can convert X <-> Word64 and Y <-> Word64
16:10:56 <nshepperd> or generally replace Word64 with some other type 'big enough' to store either X or Y
16:11:12 <nshepperd> basically a C-like tagged union
16:11:48 <Benzi-Junior> nshepperd: the custom data is "data K = L A Float | L Int Int" where A is a custom data with finite number of instances (3 to be precise)
16:12:04 <ertes> eikke: that's not portable, so i don't expect there to be a way to do it, at least with cabal-install‚Ä¶  the standard way to install a haskell package is still Setup.hs-first
16:15:08 <eikke> ertes: huh? 'cabal' will just link and run Setup.hs when using Custom mode...
16:15:23 <eikke> Anyway. Think I can work around this using Typeable, actually
16:17:17 <ertes> eikke: yeah‚Ä¶  i mean: cabal-install probably won't let you use extra information during Setup's compilation, because that would mean that building the package would depend on special cabal-install semantics
16:18:12 <nshepperd> ah, so the easiest would be (Bool, A, Float, Int, Int) or even (Word8, Float, Int, Int)
16:18:43 <eikke> ertes: Cabal 1.24 at least has CPP support, and gets some macros defined, it seems ;)
16:18:54 <glguy> Modern Cabal has the custom-setup section in the .cabal file and provides CPP macros for the versions of packages being used when compiling Setup.hs
16:19:11 <glguy> But that doesn't help much with compatibility before Cabal 1.24
16:19:21 <eikke> indeed
16:19:25 <seagreen> What's the best way to download a git repository in haskell? Also, is there an advanced library that would allow doing more complicated things than that, like downloading a single file from a repo?
16:19:36 <nshepperd> basically storing the constructor tag + A in a Word8 (actually Word2 would be enough for this I guess), and then initializing the Float or the Ints to 0 when not needed
16:19:50 <glguy> eikke: For that you can hack around changing field types with type classes in some cases
16:19:54 <ertes> glguy: how does that work?  would Setup.hs then recompile and rerun itself or something?
16:20:08 <exio4> what could be causing uncaught exception in Haskell main thread: ReferenceError: h$open is not defined in generated GHCJS code? 
16:20:18 <ertes> glguy: or does that inherently depend on using cabal-install?
16:20:24 <glguy> ertes: I'd be guessing if I told you how it worked
16:20:36 <exio4> `uncaught exception in Haskell main thread: ReferenceError: h$open is not defined` 
16:21:55 <dmwit_> eikke: At one point gtk had to detect Cabal version in its Setup.hs. I don't recall how it was achieved; let me see if it still is doing that.
16:24:51 <glguy> eikke: Example of a sweet typeclass hack for Cabal compatibility https://github.com/hdbc/hdbc-postgresql/blob/master/Setup.hs#L34-L41
16:24:58 <athan_> It seems that GHC 8.0.2 on ARM is creating some assembly code my LLVM can't use on this arch
16:25:03 <athan_> what should I do?
16:25:17 <glguy> Create assembly code that LLVM can use on that arch!
16:25:31 <hpc> find a better arch
16:25:44 <athan_> D:
16:25:50 <glguy> On my Rpi3 I had to edit ~/ghc-8.0.1/lib/ghc-8.0.1/settings
16:26:05 <athan> that's my arch! hm
16:26:07 <hpc> or debug it somehow to figure out which stage of the pipeline is defective
16:26:54 <hpc> there exist standards-compliant ARM implementations that have totally mutually exclusive instruction sets
16:27:04 <hpc> not a single instruction in common
16:27:09 <glguy> athan: https://www.reddit.com/r/haskell/comments/5j0u36/getting_haskell_and_stack_on_a_rapsberry_pi_3/dbcfg3d/
16:27:15 <athan> was that folder in the source distribution glguy?
16:27:20 <athan> oh sweet, thank you
16:27:45 <athan> O_O that's crazy hpc
16:29:43 <eikke> glguy: hmh, interesting hack... could maybe apply here as well,, though slightly more elaborate
16:30:10 <hpc> i wonder what happens if you build ghc yourself now
16:30:22 <hpc> will it configure correctly?
16:30:51 <athan> did you get a lot of "movw" "movt" errors?
16:31:43 <glguy> athan: I don't remember; I set that up in June
16:31:55 <dmwit> eikke: Okay, here's how gtk seemed to work when it needed to support pre-1.18 and post-1.18 simultaneously: it had a separate package that had to be installed first (gtk2hs-buildtools) that included a tool for generating CPP macros that could be included in a surrogate SetupFoo.hs. Setup.hs ran the tool to build the macros, then compiled and ran SetupFoo.hs appropriately.
16:32:06 <dmwit> eikke: super nasty
16:32:17 <dmwit> eikke: I think the current approach (demand a newer Cabal) is saner in the long run.
16:32:38 <athan> do you happen to remember if you needed a specific LLVM version? I build this 3.7.1 version and it's still out of whack :\
16:32:44 <athan> thanks anyway
16:33:17 <dmwit> eikke: ...it *also* used typeclass hacks of the kind glguy posted, of course. =D
16:33:43 <glguy> weird, it's like some time travel just happened!
16:34:29 <glguy> athan: I appear to be using the llvm-3.7 package via the package manager
16:34:52 <athan> hrm :s
16:34:59 <athan> eh, here goes nothing
16:35:56 <eikke> glguy, dmwit: that typeclass trick seems to be working out. One to remember!
16:43:55 <eikke> glguy, dmwit: Thanks! -- https://github.com/NicolasT/reedsolomon/commit/1e13e3535c098fac157f8d57c4d06dac7f40fec3
16:45:31 <SexHendrix> trying to implement lowest common multiple of a list of integers in a naive way
16:46:06 <SexHendrix> here's the code
16:46:08 <SexHendrix> https://ptpb.pw/2PC5.hs
16:46:20 <SexHendrix> my problem is with the retLCM function
16:46:43 <SexHendrix> it takes an integer, which is the maximum number in the list, and a list
16:47:02 <SexHendrix> checks if its the lcm, and if not, increases the integer by itself
16:47:21 <SexHendrix> how can i get it to increment by the original integer each time without just doubling because of the recursion
16:47:29 <dmwit> Add an argument for the original integer.
16:48:01 <SexHendrix> well the first argument is the original integer
16:48:12 <dmwit> No, it's your current guess at the lcm.
16:48:13 <geekosaur> not on the recursive call
16:48:35 <dmwit> Alternately: okay, then add an argument for your current guess at the lcm. =P
16:48:55 <SexHendrix> well its both
16:49:09 <dmwit> Yes. But as you observe, it can't be both, because they are two different things.
16:49:16 <SexHendrix> well, sort of
16:49:28 <SexHendrix> the way it works is, it takes the maximum number of the list
16:49:34 <SexHendrix> checks if its the lcm
16:49:54 <SexHendrix> oh hang on, you're right
16:50:03 * SexHendrix implements
16:51:36 <SexHendrix> works now https://ptpb.pw/ZsfU.hs
16:51:38 <SexHendrix> thanks
16:51:45 <hackrilege> :t foldl return (>>=)
16:51:47 <lambdabot> (Foldable t, Monad m) => t a -> m a1 -> (a1 -> m b) -> m b
16:52:01 <dmwit> > foldr lcm 1 [2,3,4]
16:52:04 <lambdabot>  12
16:52:11 <SexHendrix> well thats cheating
16:52:49 <SexHendrix> plus i dont get to use my naughty operator
16:52:52 <hackrilege> (hackrilege) :t \ a -> foldl (return a) (>>=)
16:52:54 <dmwit> =)
16:53:04 <hackrilege> :t \ a -> foldl (return a) (>>=)
16:53:06 <lambdabot> (Foldable t, Monad m) => (a -> m a1 -> (a1 -> m b) -> m b) -> t a -> m a1 -> (a1 -> m b) -> m b
16:53:14 <glguy> hackrilege: You can play with lambdabot in /msg
16:53:26 <hackrilege> Thought I had it
16:53:28 <hackrilege> ...
16:53:31 <hackrilege> Twice
16:53:47 <dmwit> :t foldr (>=>) return -- what is "it"?
16:53:49 <lambdabot> (Foldable t, Monad m) => t (c -> m c) -> c -> m c
16:53:59 <hackrilege> I wrote it down somewhere one sec
16:54:36 <hackrilege> Oh I just got out the wrong way round
16:55:17 <hackrilege> (hackrilege) :t \ a -> foldl (>>=) (return a)
16:55:27 <hackrilege> :t \ a -> foldl (>>=) (return a)
16:55:28 <lambdabot> (Foldable t, Monad m) => a -> t (a -> m a) -> m a
16:55:35 <hackrilege> Sorry for the mess
16:55:43 <hackrilege> Anyway, what's that?
16:56:56 <hackrilege> :t foldl (>>=).return
16:56:58 <lambdabot> (Foldable t, Monad m) => a -> t (a -> m a) -> m a
16:58:05 <hackrilege> Does that have another name?
16:59:23 <hackrilege> Thought it could be something to do with monad transformers....
17:00:20 <hpc> it's a few newtypes away from being mconcat
17:01:15 <hackrilege> :t mconcat
17:01:17 <lambdabot> Monoid a => [a] -> a
17:01:35 <hackrilege> Nah
17:02:05 <hackrilege> I guess if I used the kliesli arrow instead
17:02:36 <hackrilege> :t join
17:02:38 <lambdabot> Monad m => m (m a) -> m a
17:03:13 <hackrilege> I mean, they are monad constructors really
17:03:41 <hackrilege> :t [Left,Right]
17:03:43 <lambdabot> [b -> Either b b]
17:04:07 <nshepperd> :t mconcat . fmap Endo
17:04:08 <lambdabot> [a -> a] -> Endo a
17:04:27 <nshepperd> it's that except the kliesli version
17:05:15 <hackrilege> Nice
17:08:44 <hackrilege> So which Monoid has (>=>) = mappend?
17:08:56 <athan> Is there a list of the LLVM versions for which GHC _is_ tested for?
17:09:04 <athan> I can't seem to get the magic pairs :\
17:10:04 <hpc> hackrilege: none that are defined for you
17:10:13 <hpc> but you can formulate the Monad laws as:
17:10:21 <hpc> return >=> x = x = x >=> return
17:10:32 <hackrilege> yar
17:10:39 <hpc> (x >=> y) >=> z = x >=> (y >=> z)
17:10:52 <hackrilege> Sure
17:11:01 <hpc> which if it weren't for kind errors would be exactly the laws of Monoid
17:11:38 <hpc> it'd probably end up like Alternative
17:11:45 <hpc> ... actually
17:11:48 <hackrilege> I just thought if Endo exists to wrap (a->a) that maybe there was one for Monad m => a -> m a
17:11:57 <hpc> newtype Fendo f a = Fendo {unFendo :: f a a}
17:12:12 <hpc> instance Alternative (Fendo Kleisli) where ...?
17:12:49 <hpc> actually i don't think that can work
17:13:12 <hpc> no legal Functor instance :(
17:13:24 <hpc> a is both covariant and contravariant there
17:15:37 <shapr> What's the preferred config file library for Haskell?
17:15:49 <shapr> I guess I could just stick with the ini file lib
17:16:01 <hpc> or json if you are feeling fancy
17:16:09 <shapr> nah, no comments
17:16:23 <hpc> i remember seeing one that was pretty damn good a while back, sec
17:16:27 <MarcelineVQ> you could use read and show on an adt :>
17:16:35 <eikke> I seem to remember some config pkg from bos as well, and one recent from gabriel
17:16:50 <shapr> yeah, I saw configurator from bos, but it's srs overkill for what I need
17:17:05 <hackrilege> I see ArrowZero
17:17:12 <shapr> eikke: any idea of the name of gabriel's lib?
17:17:29 <eikke> shapr: nope. Think I only saw it passing by on reddit or so
17:17:36 <shapr> eikke: ok, I'll check his github
17:17:53 <shapr> ohh right, dhall
17:18:03 <Zemyla> @let newtype Cendo c a = Cendo { getCendo :: c a a }
17:18:04 <lambdabot>  Defined.
17:18:14 <hpc> i think configurator is actually what i saw
17:18:21 <shapr> dhall is also overkill
17:18:26 <hpc> conf maybe?
17:18:43 <Zemyla> @let instance C.Category c => Monoid (Cendo c a) where { mempty = Cendo C.id; mappend (Cendo cf) (Cendo cg) = Cendo $ cf C.. cg }
17:18:45 <lambdabot>  Defined.
17:18:57 <Zemyla> hpc: I think that's the kind of instance you were looking for.
17:19:11 <hpc> shapr: yaml?
17:19:15 <shapr> meh, I'll just start with ini. At this point my config file only needs three values: api key and the two nearest marta stations.
17:19:23 <shapr> hpc: oh that's a good idea
17:22:23 <hpc> Zemyla: Category is a good call
17:24:33 <hackrilege> I'm having trouble using that
17:25:05 <hackrilege> How to mconcat [Just]
17:25:18 <hackrilege> For example
17:25:39 <hpc> :t mconcat [Cendo Just]
17:25:41 <lambdabot> error:
17:25:41 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type: a ~ Maybe a
17:25:41 <lambdabot>       Expected type: Maybe a -> Maybe a
17:25:47 <hpc> :t mconcat [Cendo (Kleisli Just)]
17:25:49 <lambdabot> Cendo (Kleisli Maybe) a
17:26:00 <hpc> :t Cendo . Kleisli
17:26:02 <lambdabot> (a -> m a) -> Cendo (Kleisli m) a
17:27:14 <exio4> does anyone have any tips on my ghcjs issue?
17:29:28 <hpc> dhall seems neat
17:30:05 <hackrilege> I can't see the instance Monad m => Category * (Kleisli m) definition at https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Control.Category.html#line-151
17:31:00 <hpc> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Arrow.html#t:Kleisli
17:31:12 <dmwit> https://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Endomorphism.html has the kind of Endo you're looking for
17:31:47 <hpc> ah, https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Control.Arrow.html#line-151
17:31:48 <dmwit> shapr: glguy has https://hackage.haskell.org/package/config-value which isn't terrible
17:31:59 <hackrilege> What about ArrowPlus?
17:32:03 <hpc> hackrilege: haddock bug, it seems
17:33:11 <glguy> aww, thanks, dmwit :)
17:33:20 <dmwit> hackrilege: http://stackoverflow.com/a/40983855/791604
17:36:03 <hackrilege> :t Data.Coerce.coerce
17:36:08 <lambdabot> Coercible a b => a -> b
17:36:14 <hackrilege> What's that?
17:36:32 <glguy> Check out the documentation
17:36:38 <dmwit> `Coercible` is a magic constraint. `Coercible a b` holds roughly when the only difference between `a` and `b` is newtypes.
17:37:11 <dmwit> https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Types.html#t:Coercible
17:37:33 <hackrilege> Nice!!!!
17:40:34 <hackrilege> Boom, got it
17:40:41 <hackrilege> :t Control.Monad.Loops.concatM
17:40:43 <lambdabot> Monad m => [a -> m a] -> a -> m a
17:40:56 <hackrilege> Thanks
18:01:55 <Zemyla> I think I've figured out a way to change a traversal that visits a finite number of elements into one that visits the elements in sorted order?
18:04:34 <glguy> Does it involve partsOf or something similar to it?
18:11:42 <Zemyla> glguy: No, it involves making a Bazaar-like pairing heap.
18:14:52 <exio4> how can I enable stack traces in GHCJS?
18:35:16 <_sg1> Thanks, this is my first book that I read in English
18:36:50 <shayan_> Where can I learn which framework will best suit my project requirements?
18:37:03 <shayan_> I‚Äôve already been on https://wiki.haskell.org/Web/Frameworks
18:37:25 <Axman6> I'd be surprised if that's up to date
18:37:39 <glguy> I'd be surprised if that question had an generic answer
18:37:40 <Axman6> here is as good a place as any to ask questions
18:38:28 <shayan_> I feel like I am being annoying with my newbie questions lately
18:39:14 <sm> also, the web framework discussions in the haskell reddit will be informative
18:39:31 <SexHendrix> the happstack book in insanely dense
18:40:12 <sm> ..but the answer is probably yesod
18:40:59 <glguy> Was the question "What was the name of that web framework that started with 'y'?"?
18:41:25 <Axman6> yesod?
18:41:41 <Axman6> uh, should read whole sentenses
18:41:52 <sm> lol
18:42:28 <Axman6> I'm not a fan of yesod, it's too big (though afaict it is possible to only use the bits you need)
19:10:40 <bollu> hey guys!
19:12:12 <mmachenry> Hi
19:38:01 <Zemyla_> Hell yes. I can now sort a finite traversal by its input.
19:55:14 <Henson> say you have some Haskell functions exported to C and compiled into a dynamic library.  You can call these functions from C, no problem.  Now say you want a C function that spawns a thread in Haskell, that's fine, too.  Now say you want a C function that's able to communicate with that thread.  How would you do that?  You'd need some context that the thread-spawning function passes back to C...
19:56:29 <Henson> which the communication functions would use to talk to the thread.  I'm thinking a TChan or something.  But a TChan isn't a marshallable type, and can't be passed to C.  Is there some way to pass opaque data to C which when passed back to Haskell can be used?:
19:57:25 <johnw> you can create a ForeignPtr to pass to C
19:58:02 <johnw> on the C side it would just a pointer, but back in Haskell you'd cast it to a Ptr TChan; you'd have to release it when done so that it could be collected.  Or I might be thinking of a StablePtr
19:58:29 <geekosaur> you likely need a StablePtr, since C can't know about GC moving Haskell stuff around
19:58:47 <Henson> johnw: and a ForeignPtr /StablePtr can refer to arbitrary Haskell types?
19:59:05 <johnw> yes, you can make a Ptr a for any a with StablePtr
19:59:05 <glguy> StablePtr's how are you can create a void* in the C world that refers to a value in the Haskell world
19:59:18 <johnw> this is sort of their exact use case :)
19:59:48 * Henson steeples his fingers...Excellent
19:59:58 <glguy> ForeignPtr is for referring to a C value from inside Haskell 
20:00:11 <Henson> johnw, glguy, geekosaur: thank you very much!!
20:11:04 <orzo> "If you‚Äôre getting agitated or highly emotional, you‚Äôre probably not thinking rationally or objectively, she says. That may be because you are emotionally invested in the subject or because you hold particular beliefs that aren‚Äôt letting you clearly see other viewpoints."  Anybody ever encounter this from a person when trying to understand their technical decisions?
20:12:17 <orzo> it wouldn't be so bad if they were self aware enough to say something like "I'm too heavily invested to even consider some other design"
20:13:19 <orzo> but instead they feed me lots of nonsensical technical justifications and get increasingly angry when none of them succede in persuading me
20:13:31 <johnw> orzo: I'm not really seeing the connection to Haskell....
20:16:12 <orzo> am i interrupting a haskell discussion?
20:16:35 <johnw> no, but it's also not a forum for general venting
20:18:46 <orzo> it's not general venting
20:19:08 <orzo> a non-tech vent room would not relate
20:19:38 <johnw> if it's related to Haskell, fine and well; if not, please find another tech room, thank you
20:31:08 <YellowOnion_> Are there any resources to better understand Haskell's Laziness/memorising? Are there any tricks to avoid memormising in places where the memory / cache penalty is worse than the CPU penalty?
20:31:26 <Koterpillar> there is no memoizing
20:32:00 <Koterpillar> (unless you build it)
20:33:02 <YellowOnion_> Koterpillar, what do you call it when you issue a command in GHCI and it runs instantly the 2nd time?
20:33:27 <Axman6> yeah GHC doesn't really do anything you don't tell it to, if you want to keep a result around, you need to keep it around (using say the memotrie package)
20:33:45 <Koterpillar> that would still be lazy evaluation
20:34:26 <Koterpillar> YellowOnion_: memoization would be if something like this ran fast the second time: [1..] !! 1000
20:34:43 <glguy> GHC will do transformations that increase sharing, actually
20:35:06 <glguy> You might have someFun = \x -> let xs = sort [5,1,10] in whatever
20:35:26 <glguy> GHC can lift that xs to the top-level and reuse it across uses of someFun
20:37:25 <glguy> see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html?highlight=full-laziness#ghc-flag--ffull-laziness for example
20:38:34 <YellowOnion_> so lets say I have a List, and some sort of Tree, both referencing some large data-bits, but when I add a 2nd structure, my memory usage balloons 5x
20:38:54 <YellowOnion_> Why would that happen?
20:39:13 <Koterpillar> is the tree itself taking space?
20:40:10 <YellowOnion_> Koterpillar, I hope not 5x the space of a List.
20:41:14 <Koterpillar> exactly how are you "adding" this structure?
20:45:08 <YellowOnion_> Koterpillar, This specific case is actually a building a List of Points to a KdTree, now that uses about 1.2GB of memory, but it's when I add a Hash Map to lookup by name to the Points. both structures are effectively created by a fromList
20:45:12 <Axman6> if you're holding onto old versios somehow, you'll have issues with space leaks
20:45:28 <Axman6> maybe try deepseq'ing the resulting structure
20:45:59 <johnw> deepseq'ing is fine for debugging, but should be avoided
20:48:19 <Axman6> YellowOnion_: which hashmap are you using?
20:48:29 <dmj`> YellowOnion_: is this what your profiles are telling you? 
20:49:00 <YellowOnion_> unordered-containers, Strict hashmap
20:51:19 <YellowOnion_> dmj`, I'm having a real hard time understanding the profiles, that is why I asked about understanding how this works properly, putting in force/strict and other things aren't helping if I don't know what I'm doing.
20:53:49 <wedify> how do i go about making sense of an expression like (((+) .) . (+))
20:54:12 <Koterpillar> :t (((+) .) . (+))
20:54:14 <lambdabot> Num a => a -> a -> a -> a
20:54:16 <glguy> start adding variables to it
20:56:03 <glguy> \x -> (((+) .) . (+)) x  --- \x -> ((+) .) (x+) --- \x -> (+) . (x+) --- \x y -> ((+) . (x+)) y --- \x y -> (+) (x+y) --- \x y z -> (+) (x+y) z --- \x y z -> x+y+z
20:56:06 <YellowOnion_> Currently I'm just putting force, and strict everywhere, and hoping for the best, I assume this is why the program is now awefully slow too.
20:56:20 <Axman6> @unpl  (((+) .) . (+))
20:56:21 <lambdabot> (\ x x0 -> (+) (x + x0))
20:56:44 <Axman6> huh, curiously not as pointful as I expected that to become...
20:57:07 <glguy> Axman6: It's probably not making assumptions about the type of (+) in that expression
20:57:54 <YellowOnion_> Axman6, Koterpillar, dmj`, My queries were running in the order of 2ms, and now that I have a hashmap, it took 11hrs for the build+query (I went to bed while it ran)
20:58:52 <Axman6> o.O
20:59:07 <kadoban> Woh
20:59:20 <Axman6> something is very very wrong then
20:59:30 <monochrom> I learned how to handle that from a recent xkcd.
20:59:48 <kadoban> force and such can definitely add some execution time, but ... that sounds extreme
20:59:51 <monochrom> Put the computer in Narnia. Bring it back later.
21:00:38 <dmj`> YellowOnion_: I‚Äôd strongly recommend you produce a heap profile (.hp), and also a time / memory allocation profile (.prof), and print RTS GC stats (-s) as well. It will be far easier to track down the root cause.
21:00:40 <Koterpillar> monochrom: HPMOR tried that, no luck.
21:00:42 <Axman6> plunge in liquid nitrogen and overclock to 10GHz
21:01:00 <monochrom> More seriously, from 2ms to 11 hours may just mean "going to swap".
21:01:05 <Axman6> yeah what dmj`said, without that information everything is just speculation
21:02:32 <YellowOnion_> monochrom, I've restricted the heap size to 4GB, and I got 8GB RAM, doesn't look like it's touching swap.
21:03:38 * sm goes looking for that xkcd
21:03:53 <monochrom> It's probably just this Monday
21:04:03 <wedify> how can i be as awesome as the author of xkcd?
21:04:32 <sm> https://xkcd.com/1786/ ?
21:05:06 <monochrom> That's similar to "how can I turn GHC 4.0 into GHC 8.0?"  Answer: Delete GHC 4.0, install GHC 8.0.
21:05:29 <monochrom> Yeah!
21:05:55 <Koterpillar> https://www.xkcd.com/821/
21:07:17 <Axman6> wedify: well, writing Haskell is a good start, IIRC a lot of the cool stuff on xkcd is written in haskell
21:07:28 <sm> ha! nice
21:07:39 <YellowOnion_> Koterpillar, I wonder how you transfer data over ether with a clear clock difference :P
21:08:38 <Axman6> https://www.reddit.com/r/haskell/comments/uved7/waldo_the_haskell_powered_codebase_behind_xkcds/
21:09:01 <sm> YellowOnion_: GHC profiles are hard to understand, I usually start by looking at the function entry counts. Between the 2ms and 11m cases there must be a big difference
21:09:35 <Koterpillar> YellowOnion_: http://www.hpmor.com/chapter/17
21:09:43 <sm> er, separate those two sentences. One does not imply the other
21:10:03 <Koterpillar> YellowOnion_: but given it's XKCD, just set up trebuchets hurtling CDs over each way
21:10:10 <YellowOnion_> sm, actually my previous issue, I found it pretty quickly, I couldn't for the life of me figure out how to stop it though.
21:11:11 <YellowOnion_> sm, http://imgur.com/a/bQpmu
21:11:27 <Axman6> davean: are you still involved with xkcd?
21:12:17 <wedify> glguy: i don't get this reduction step --- \x y -> ((+) . (x+)) y --- \x y -> (+) (x+y)
21:12:51 <glguy> wedify:  the intermediate step is expanding the definition of (.)
21:15:18 <YellowOnion_> Koterpillar, Axman6, sm, dmj` https://gist.github.com/YellowOnion/e0d0d7b31176b79c643096048444280d
21:15:37 <sm> YellowOnion_: have you tried http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html ?
21:16:30 <YellowOnion_> sm, yeah, As I said, My issue is understanding why something is leaking, not what is leaking.
21:17:01 <johnw> the article sm linked to is a good technique
21:17:10 <sm> ok, what part of your paste is leaking then ?
21:17:43 <sm> someone here (not I) will know what's leaking by looking at it
21:18:20 <johnw> there are a few reasons things leak, though: thunk buildup, stack exhaustion (which neil's article will detect early), too much residency
21:18:58 <YellowOnion_> sm, Trying to get a profile now but as I said its awefully slow :P, but It appeared after adding the Hash map to Galaxy.
21:19:05 <johnw> which also means there's no "one trick" to fix every case of over allocation
21:20:24 <YellowOnion_> line 142:StarMap.hs, is where I fixed the first space leak.
21:20:26 <monochrom> Neil's can detect some cases of thunk buildup. Specifically iff the thunk is later evaluated sufficiently, which requires much stack space.
21:21:13 <YellowOnion_> is using unpack on my structure a wise idea? something tells me that might be causing issues.
21:21:28 <YellowOnion_> on the System type
21:22:31 <dmj`> YellowOnion: are you using ghc8?
21:22:35 <dmj`> YellowOnion_: 
21:22:59 <YellowOnion_> dmj`, I think so, setup the project in stack 2 days ago.
21:23:35 <YellowOnion_> +RTS -s doesn't work unless the program quits cleanly, that needs to be fixed...
21:24:17 <Axman6> you could do that pretty easily by working a thread that does getLine >> exit 0
21:26:17 <YellowOnion_> Axman6, actually I just realised this could just be the way Windows kills apps.
21:26:41 <glguy> dfeuer: If you'd game for making the phabricator patch I'd appreciate it. That's a workflow I don't know
21:27:46 <davean> Axman6: why do you ask?
21:28:14 <YellowOnion_> here's the profile for running for a while until it hits the heap limit and stalls: http://imgur.com/a/ooeVh
21:28:49 <YellowOnion_> I don't know why Text isn't strict....
21:29:07 <dmj`> YellowOnion_: does it OOM ?
21:29:55 <YellowOnion_> dmj`, that's the strange thing, it doesn't, just gets slower. increasing the heap size just makes it faster.
21:31:03 <johnw> YellowOnion_: can we see some code?
21:31:23 <YellowOnion_> johnw, posted it earlier: https://gist.github.com/YellowOnion/e0d0d7b31176b79c643096048444280d
21:31:34 <johnw> thanks, I missed it
21:32:22 <dmj`> YellowOnion_: does any GC occur by the time you get to the repl? 
21:32:51 <YellowOnion_> johnw, all g, line 142, shouldn't that force the entire System be "realised"?
21:32:54 <johnw> YellowOnion_: how big is your input data?
21:33:15 <YellowOnion_> johnw, there's 6 million points.
21:33:22 <sm> YellowOnion_: do you really know what is leaking ? I think you implied that 
21:33:57 <johnw> YellowOnion_: do you have profiling output?
21:34:10 <YellowOnion_> http://imgur.com/a/ooeVh
21:34:15 <YellowOnion_> posted that earlier too :D
21:34:21 <dmj`> johnw: ~780M
21:34:30 <johnw> I mean, prof.out, with all the numbers and stuff, the textual version
21:35:18 <YellowOnion_> johnw, prof.out?
21:35:25 <johnw> the results from +RTS -p
21:35:34 <YellowOnion_> I got star-map.prof, and star-map.hp
21:35:41 <johnw> ok, star-map.prof
21:36:50 <YellowOnion_> johnw, added to gist
21:37:00 <dmj`> it might be partial (star-map.prof) if the program didn‚Äôt exit cleanly
21:37:02 <johnw> excellent, reading now
21:38:41 <johnw> YellowOnion_: just to try something, can you change to "QName !Text"?
21:39:57 <YellowOnion_> johnw done, should I strict REPL as well?
21:40:04 <johnw> no, just that one
21:40:28 <johnw> if you can make the data available someplace, I could debug this here
21:40:46 <YellowOnion_> johnw, the link is at the top of the gist
21:40:51 <johnw> oh, thanks!
21:41:15 <wedify> ok i think i get it; after taking the first arg we have ((+) .) (x+) which is the same as (+) . (x+). after taking the second arg we have (+) (x+y) leaving us to take a third arg.
21:41:23 * sm armchair-debugs: the parser seems inefficient
21:41:24 <YellowOnion_> johnw, part of me wants to figure this out myself. :-|
21:41:34 <johnw> YellowOnion_: I can keep it a secret if you like
21:41:48 <YellowOnion_> johnw, maybe you can give me some hints though :D
21:42:20 <wedify> so, intuitively, after the first arg the leftmost section "drops down"
21:42:52 <YellowOnion_> johnw, btw I used the QPoint query, so QName wasn't even touched in my first run through.
21:43:31 <johnw> then has does decodeUtf8 appear in your heap profile?
21:43:33 <johnw> how*
21:43:39 <johnw> internal to Aeson?
21:43:50 <wedify> does anyone have a list of similar point-free expressions?
21:44:35 <wedify> i want to learn to expand them in my head
21:44:36 <YellowOnion_> johnw, my System structure has a name :: Text
21:45:20 <YellowOnion_> johnw, Aeson isn't actually used, it's json-stream now, though I keep the Aeson instance around.
21:45:28 <glguy> wedify: You shouldn't need to expand something like this in your head: (((+) .) . (+))
21:45:40 <glguy> If you find it you can expand it on paper and then fix the bug of it existing
21:46:15 <wedify> glguy: but they're so much fun
21:46:43 <glguy> OK, then just use /msg lambdabot ?pl 
21:46:55 <glguy> and have it make all sorts of noise for you to enjoy :)
21:47:17 <johnw> YellowOnion_: what is safeString?
21:47:58 <johnw> ah, json-stream
21:48:10 <YellowOnion_> johnw, sets an upper limit on the string length so it doesn't leak space.
21:48:38 <johnw> so, your example here does extremely little then, doesn't it
21:49:22 <YellowOnion_> johnw, yeah, basically spent 99% of my time fighting laziness :D
21:49:28 <johnw> then let's simplify
21:49:38 <johnw> print out some detail of 'systems' after you parse it, and then exit
21:49:46 <johnw> narrow down how much code you need to cause the heap bloat
21:49:56 <sm> +1
21:50:00 <johnw> don't do the Galaxy computation, in other words
21:51:48 <YellowOnion_> john, it's definitely the galaxy, this is from earlier where I would print the [System] to console. http://imgur.com/a/bQpmu
21:53:31 <johnw> not sure how what I'm seeing relates
21:53:45 <johnw> so
21:54:23 <YellowOnion_> johnw, well if I print the results of [System] to console, it still builds up thunks for decodeUtf8.
21:54:54 <johnw> systemsToPoints rings a lot of alarm bells for me, but I don't have evidence yet
21:55:35 <johnw> where is Data.KdMap from?
21:56:07 <YellowOnion_> johnw, kdt package.
21:57:02 <dfeuer> glguy: see https://phabricator.haskell.org/D2988 and let me know if you have any changes to suggest.
21:58:07 <YellowOnion_> johnw, I did actually think about that as well.
22:00:05 <glguy> dfeuer: Thanks!
22:00:35 <dfeuer> glguy: no problem.
22:01:14 <glguy> dfeuer: Do you think we should actually remove the foldl and foldr implementations there?
22:01:36 <glguy> or fix them to have similar behavior?
22:01:58 <glguy> I guess there's not much room for improvement
22:01:59 <dfeuer> glguy: what's wrong with them?
22:02:00 <YellowOnion_> johnw, so I put force on the function and the heap got a lot smaller.
22:02:08 <dfeuer> Yeah, I think not.
22:02:22 <johnw> which function?
22:02:26 <johnw> systemsToPoints?
22:02:33 <johnw> how much smaller?
22:04:08 <YellowOnion_> johnw, systemToPoints went to the top of the list, I assume the kdt needs to be strict.
22:07:48 <johnw> Here is my guess: Every thunk created by systemToPoints holds the whole of 'systems' resident, which initially is smaller.  But as you process the data and cause some of the thunks within 'systems' to be evaluated, this replaces parts of 'systems' by real data, but that data now gets stuck in residency too.  So, if this guess is accurate, you should change systemsToPoints to perform all the computation work up front, so that as it
22:07:49 <johnw> processes the input data, things that are no longer needed can be GC'd.
22:08:33 <johnw> you want only the Galaxy data, not the data from the parsing step any longer
22:09:35 <YellowOnion_> johnw, strict KDT has platued at 640MB memory usage.
22:10:01 <johnw> is that sufficient for your problem?
22:10:53 <YellowOnion_> johnw, most definitely, the json file is 900MB, can't expect it to be much smaller with the added weight of a KdTree.
22:11:10 <johnw> if it works, I'd call it good enough
22:11:12 <johnw> next!
22:11:51 <YellowOnion_> johnw, really when I saw that hashmap had a strict variant, I should have been clued in on KDT needing it.
22:12:06 <johnw> except it doesn't tell you why it's needed
22:12:14 <johnw> "more strictness" is not always the answer to space problems
22:12:34 <johnw> usually the problem is an inappropriate balance of laziness and strictness
22:13:43 <johnw> Strictness forces some evaluation, but if it doesn't force enough, it leaves more thunks behind than if the more of the computation had been lazy.  The key is knowing how to be strict enough to reduce residency, but not so strict that you create too many thunks.
22:14:02 <_wintermute> Hey guys, googling and researching this (RTFM, I know) but thought I'd ask in here too: is there a book/resource that is considered the best by the communty for starting out with haskell?
22:14:20 <johnw> or, if you're 100% strict, you may do much more work than is necessary (or lose yourself in an infinite loop)
22:14:36 <johnw> _wintermute: nothing that's universally regarded as "best"
22:14:39 <glguy> _wintermute: No, there's isn't a commonly accepted best.
22:14:41 <kadoban> _wintermute: I quite like http://haskellbook.com/
22:14:50 <YellowOnion_> yeah my Galaxy type has the entire hashmap strict wich I think is also an issue for load times.
22:14:51 <kadoban> But yes, I don't think there's one answer.
22:15:16 <johnw> YellowOnion_: it's strictness is "one level down", which doesn't force the members of the tuples inside it
22:15:19 <_wintermute> johnw glguy kadoban Thanks for the responses, was just wondering if there was by any chance a 'go to' book. Not suprised there isn't and not discouraged at all either of course. 
22:15:24 <_wintermute> kadoban I'll check that out
22:15:24 <glguy> Programming in Haskell 2nd ed was recently released, kadoban's link comes up a lot, and then there are online resources
22:16:19 <kadoban> In particular I would recommend *against* LYAH, which gets recommended a lot. Most of the other resources I don't know enough about to say much.
22:16:41 <YellowOnion_> johnw, do you know if the build comannd is actually working in paralell? I can never figure out how to properly use par/pseq
22:17:11 <cwm> _wintermute: I've been using http://learnyouahaskell.com/chapters and it has been great so far
22:17:32 <johnw> YellowOnion_: I don't know, I've never used parallelism before
22:17:34 <_wintermute> glguy kadoban's link looks great. I'm not one to spend to much time farting around trying to figure out the best way to learn something when I could spend that time trying to learn, heh
22:17:43 <_wintermute> cwm is that the exact same as the NoStarch release?
22:17:51 <YellowOnion_> johnw, ahh all good, thanks for your help anyway.
22:18:28 <glguy> _wintermute: the lecture notes and assignment from this course have been popular, too http://cis.upenn.edu/~cis194/spring13/lectures.html
22:19:00 <cwm> _wintermute I believe so
22:19:15 <YellowOnion_> johnw, actually now that I removed the strict bit from Galaxy, I can use build to get 70% CPU load.
22:20:09 <_wintermute> glguy Nice one, looks like good information. I was told this channel was great and so far so good, thanks dudes. 
22:36:33 <lpsmith> hmm... I can't cabal install cabal-install
22:36:48 <YellowOnion_> johnw, looks like hashmap is too slow :(
22:36:55 <lpsmith> cabal version is 1.22.6.0
22:37:06 <lpsmith> kinda old, but that wouldn't be the problem?
22:37:24 <glguy> lpsmith: There are binaries you can start from. You need to be using Cabal 1.24 t build it with GHC 8, what version are you using?
22:38:01 <glguy> lpsmith: There's a bootstrap.sh script that comes in the source tarball
22:38:10 <glguy> You don't have to use cabal-install to install cabal-install
22:39:14 <lpsmith> yeah I know,  it's just what I've done for a long time
22:39:28 <lpsmith> I'm attempting to use GHC 8.0.2
22:39:33 <lpsmith> getting hung up on zlib?
22:39:41 <lpsmith> the error message isn't exactly clear
22:40:45 <glguy> I don't think you're able to use I don't think those versions of cabal-install and GHC will be compatible. something with the package id format changed
22:41:21 <lpsmith> yeah
22:41:23 <lpsmith> something like that
22:42:07 <shayan_> I am trying to install Snap. I‚Äôve already ran cabal install snap-templates‚Ä¶ Now I am in my project‚Äôs directory, and when I try to run ‚Äúsnap init‚Äù in the terminal, I get the folllowing message: -bash: snap: command not found
22:43:20 <glguy> The directory that the snap executable was installed into needs to be in your search path. How you configure your PATH depends on what OS you're using
22:58:57 <osa1> a minimum function on Ord, Eq, and Bounded elements can stop searching for a smaller element when it saw the minimum element in containers. does such a function exist in a library?
22:59:11 <glguy> shayan_: Are you using a cabal sandbox?
22:59:37 <shayan_> glguy: It is very possible, I was experimenting with a cabal sandbox a couple days ago :S
22:59:43 <glguy> osa1: I don't know of one in any "standard" library
22:59:56 <glguy> shayan_: OK, in that case check .cabal-sandbox/bin/
23:00:38 <osa1> actually, if implementation of `minimum` is implemented using `min` it can terminate early
23:00:39 <osa1> hmmm
23:00:52 <osa1> :t foldl min
23:00:55 <lambdabot> (Foldable t, Ord b) => b -> t b -> b
23:01:01 <osa1> :t foldr min
23:01:02 <glguy> osa1: Not if it's implemented with foldl
23:01:03 <osa1> sry
23:01:03 <shayan_> glguy: can I delete this sandbox crap?
23:01:03 <lambdabot> (Foldable t, Ord b) => b -> t b -> b
23:01:07 <osa1> glguy: right, I know
23:01:21 <glguy> osa1: I should have assumed as much
23:01:45 <glguy> shayan_: No, but you can delete the sandbox with 'cabal sandbox delete'
23:02:24 <shayan_> glguy: ‚ÄúWarning: Not in a sandbox."
23:02:46 <glguy> were you actually in the directory that you suspected had a sandbox in it?
23:02:53 <shayan_> No
23:03:03 <shayan_> I‚Äôm in .cabal now though
23:03:15 <glguy> Well, sandboxes directory specific
23:03:28 <shayan_> I don‚Äôt see it when I type ls in .cabal
23:03:31 <glguy> Before you go deleting sandboxes you should figure out if you installed snap in one
23:03:40 <glguy> it's not in .cabal
23:03:50 <glguy> the sandbox would be in the directory containing your project
23:04:12 <glguy> or the directory you were in when you typed : cabal sandbox init
23:04:15 <shayan_> okay, in that case then I must‚Äôve deleted it
23:04:27 <shayan_> it should be in the trash
23:04:32 <glguy> then you'll have to reinstall snap
23:04:48 <shayan_> I don‚Äôt get it
23:04:57 <shayan_> All I did was go to
23:05:01 <shayan_> snapframework.com
23:05:09 <shayan_> then ran the two commands
23:05:15 <shayan_> $ cabal update
23:05:17 <shayan_> $ cabal install snap snap-templates
23:05:19 <shayan_> $ mkdir foo; cd foo; snap init
23:08:34 <shayan_> when i do echo $PATH i do see /Users/shayanbozorgmanesh/.cabal/bin
23:11:39 <shayan_> glguy: when I said I must‚Äôve deleted it, I was referring to the directory that I had deleted a couple days ago where I had my sandbox in. I only was trying to install Snap a couple hours
23:11:48 <glguy> ok
23:15:33 <shayan_> when I try to reinstall, by typing in the command ‚Äúcabal install snap snap-templates‚Äù, i get the message: cabal: --root-cmd is no longer supported, see
23:15:34 <shayan_> https://github.com/haskell/cabal/issues/3353
23:49:07 <moet> anyone here use nixos with stack?
23:49:18 <lonokhov> o/
23:50:22 <lonokhov> Say I have a classy polymorphic lens class `class HasFoo a b | a -> b` and want to tidy up constraints on MonadState a bit.
23:50:36 <srhb> moet: NixOS in specific? Not just nix?
23:50:54 <moet> srhb: yes, unfortunately.
23:51:17 <lonokhov> So instead of `MonadState s m, HasFoo s b` I could write `HasFooState b m`
23:51:19 <moet> i've been bashing my head against NixOS trying to make it my dev environment for months. ready to give up.
23:51:36 <srhb> moet: Well, I'm using NixOS, you might want to just pose your question (either here or in #nixos)
23:51:43 <srhb> Oh, is see you already did
23:52:07 <moet> yes :P
23:52:19 <lonokhov> It seems that I can't have Constraint kind with `type HasFooState a m = forall st . (HasState st m, HasFoo st a)`
23:53:48 <lonokhov> hm, its rather obvious why I can't do it
