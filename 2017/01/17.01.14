00:00:07 <norms> oops, I was specifying the command syntax wrong (like `hindent --style=chris-done`), thanks for the help
00:01:08 <MarcelineVQ> you're right that this example doesn't show using --style despite it seeming to be neccesary though
00:23:30 <piyush-kurur> question regarding haddock of export list. Let us say that the module Foo has the entry module Bar in its exported list and that Bar is imported into Foo with hiding (biz). I would assume that no documentation for biz is generated in Foo but it does not seem to happen (Bar is a hidden module in the package)
00:32:47 <piyush-kurur> I would like to document biz in Bar but it should not appear in the docs of Foo. It seems Haddock is ignoring the hiding when generating docs
00:34:47 <zipper> What does closed mean in this context "Applicatives, it turns out, are also closed under composition."
00:36:26 <pavonia> That when you compose two Applicatives you will always get another Applicative
00:36:31 <geekosaur> http://stackoverflow.com/questions/23104490/meaning-of-closed-under-composition
00:38:28 <geekosaur> piyush-kurur, haddock has a lot of weird holes
00:39:02 <zipper> pavonia: So closed means getting the same typeclass instance out?
00:39:33 <zipper> Ok another different question, what does control mean for Control.Monad, Control.Applicative and so forth?
00:39:44 <geekosaur> nothing, essentially :)
00:40:03 <geekosaur> the division between Control and Data was a bad idea dating back to ghc 5
00:40:25 <pavonia> zipper: No, not the same instance but still an Applicative instance
00:40:35 <geekosaur> before they realized the division was so blurry as to be meaningless
00:51:28 <benmachine> what level of civic responsibility do I have to vet people before adding them as uploaders to a Hackage package? (the package in question is pointfree)
00:52:08 <benmachine> (I don't want to maintain it anymore, considering adding everyone who sends me a pull request in the hope that it makes them sto psending me pull requests)
00:54:58 <lyxia> everyone seems too much
00:56:47 <benmachine> lyxia: I agree, but I don't have much capacity for discrimination beyond that
00:58:00 <benmachine> I would need to find a volunteer that I trusted, but most people I trust are already doing stuff :P
01:08:03 <osa1> how do I express conduit's sourceToList in pipes?
01:12:04 <zipper> I have a type Compose here and I am trying to write its Applicative instance http://lpaste.net/351219#line8
01:12:14 <zipper> However I can't even write pure for it
01:13:02 <zipper> The error is that it says it's ending up with: f and g being (b-a) (a->b)
01:13:12 <zipper> Honestly to me this should be id . id 
01:13:30 <zipper> but then it'll complain that I've already applied f and g 
01:13:40 <zipper> WTF am I doing wrong here?
01:13:43 <lyxia> zipper: Compose doesn't necessarily contain functions
01:14:02 <zipper> lyxia: hmmmm
01:14:04 <lyxia> pure x = Compose (pure (pure x))
01:14:38 <zipper> and what is pure x ?
01:14:44 <zipper> I haven't defined that
01:14:56 <lyxia> it's pure using Applicative g
01:15:40 <zipper> I don't really get your reasoning. I see the answer but your reasoning not very :(
01:16:36 <cocreature> zipper: to implement the instances for Compose you use the instances for the two functors that you are composing
01:16:48 <kadoban> zipper: Look at the type of the thing you have to produce, what you have to start with, and the puzzle pieces you have (quite few, since you pretty much just have the Applicative instances of f and g and that's it)
01:17:30 <zipper> hmmmm I see
01:17:59 <zipper> So compose here in my understanding should be Compose (pure f) . (pure g)
01:18:06 <zipper> Let me see if that typechecks
01:18:52 <zipper> Nope it wont
01:20:23 <kadoban> zipper: f and g aren't values, right? They should be type level, or am I missing something?
01:21:15 <zipper> Yes they aren't values
01:21:21 <zipper> They are types
01:21:25 <zipper> hmmmm
01:21:49 <kadoban> Then they definitely don't go in an expression, certainly not without :: in front of them
01:22:17 <lyxia> zipper: The value wrapped by the compose constructor must have type f (g x), this is not a function.
01:22:20 <zipper>   `pure x = Compose $ \f g -> (pure f) ( (pure g) x)` 
01:22:46 <zipper> Also won't typecheck despite me "making" values of f and g 
01:23:53 <kadoban> Yes, seems like not correct in a couple of ways. What is the type of thing you're trying to build? What is the type of 'pure' here, specialized to your thing?
01:24:05 <zipper> lyxia: mmm I'm kinda getting what you mean. The value wrapped by the Compose value constructor must have a type `f (g x)`
01:25:01 <kadoban> For example pure for Applicative Maybe is  pure :: a -> Maybe a     what's yours?
01:25:05 <zipper> wait f (g a) is not even a type
01:25:55 <zipper> kadoban: The type of pure here is `a -> Compose f g a`
01:26:30 <kadoban> If a is a type, it is, no?  Good, and what's the definition of Compose ?
01:27:11 <parenthetically> A little off topic, but is there a read somewhere on how to idiomatically typeset types and type theoretic things in Latex?
01:28:12 <Ferdirand> data Compose f g x = Compose (f (g x)), right ?
01:28:22 <zipper> kadoban: Compose is Compose (f (g x))
01:28:33 <zipper> Just a wrapper around composition
01:28:38 <Ferdirand> and you want instance (Applicative f, Applicative g) => Applicative (Compose f g)
01:29:04 <zipper> Oh without bringing the a into this
01:29:47 <Ferdirand> so
01:29:56 <Ferdirand> Applicative f gives you pure :: a -> f a
01:30:05 <Ferdirand> Applicative g gives you pure :: b -> g b
01:30:33 <Ferdirand> you need a f (g x)
01:30:56 <zipper> go on
01:31:08 <Ferdirand> just pose a = g b
01:31:42 <Ferdirand> so you have pure :: g b -> f (g b)
01:32:29 <Ferdirand> (that's the pure coming from Applicative f)
01:32:47 <Ferdirand> so (pure . pure) :: b -> f (g b)
01:32:55 <Ferdirand> those are not the same pure
01:33:26 <zipper> Ferdirand: One sec let me follow this with pen and paper
01:33:57 <zipper> Would this be confusing for other people or do I need to go back and read on a certain topic?
01:34:37 <kadoban> I think it's fairly confusing at first for just about everybody.
01:35:13 <zipper> Wait I think I get it.
01:36:09 <Ferdirand> the types do work but maybe it's not the most intuitive way to explain it
01:36:32 <zipper> So (pure f (pure g)) this way g and f are still partially applied and waiting for a value
01:36:44 <Ferdirand> no no
01:36:50 <kadoban> What are f and g?
01:36:51 <zipper> So I have it up to `pure = Compose (pure f (pure g))`
01:36:58 <Ferdirand> f and g are of kind (* -> *)
01:37:05 <zipper> kadoban: They are not even in scope
01:37:17 <kadoban> Yes ...
01:37:18 <zipper> Yes they are of kind (* -> *)
01:37:25 <Ferdirand> okay I see where the confusion stems from
01:37:31 <Ferdirand> dictionary passing is implicit in haskell
01:37:33 <kadoban> So what are they doing in that expression? Kind of confused.
01:37:46 <Ferdirand> the compiler picks the appropriate instance by itself
01:38:02 <zipper> kadoban: I have to make it a lambda that takes f and g and then calls pure on each
01:38:03 <Ferdirand> what you mean is pure_f and pure_g
01:38:08 <zipper> but they still won't typecheck
01:38:20 <Ferdirand> no no 
01:38:44 <zipper> Ferdirand: Ok where does the confusion stem from? Scope?
01:38:46 <Ferdirand> there is no need to pass the f and g
01:39:02 <Ferdirand> they only exist at the type level
01:39:10 <zipper> Ferdirand: true
01:39:40 <zipper> and adding them in the lambda means it takes more args than just a
01:39:50 <Ferdirand> you want pure :: forall a -> f (g a)
01:39:55 <Ferdirand> sorry
01:40:03 <Ferdirand> pure :: forall a. a -> f (g a)
01:40:32 <zipper> Yes
01:40:39 <Ferdirand> that's the pure from Applicative (Compose f g) (minus the newtype wrapper)
01:40:54 <kadoban> zipper: Try this:   write a function    myPure :: a -> Maybe [a]     this is the   pure  for   Compose Maybe [], without the wrapper
01:40:58 <zipper> I can see the type so clearly
01:41:07 <Ferdirand> you also have pure :: a -> g a, from Applicative g
01:41:19 <Ferdirand> and you have pure :: b -> f b, from Applicative f
01:41:29 <Ferdirand> which you can specialize to g a -> f (g a)
01:41:32 <zipper> kadoban: i can't follow both of you guys :)
01:41:43 <kadoban> fair enough
01:42:02 <zipper> kadoban: I will def try yours after I get this or fail to get this
01:42:02 <Ferdirand> well i agree that maybe first doing it with concrete functors may help you understand
01:42:17 <zipper> Ferdirand: Ok let me try it with concrete functors
01:42:36 <Ferdirand> the point is that you can write (pure . pure), and in this expression, the two `pure` are not necessarily the same function
01:42:44 <Ferdirand> they might belong to different instances
01:42:56 <Ferdirand> it will be inferred from context
01:46:45 <zipper> Ha! kadoban I have it in types like so:
01:46:50 <zipper> `myPure = (pure :: [a] -> Maybe [a]) . (pure :: a -> [a])`
01:47:05 <zipper> `myPure :: a -> Maybe [a]; myPure = (pure :: [a] -> Maybe [a]) . (pure :: a -> [a])`
01:47:19 <kadoban> Looking very nice
01:47:20 <zipper> Ok I see the two pures are different
01:47:25 <zipper> and waiting for the a
01:48:26 <zipper> I see how it's (pure . pure) as per this example
01:48:42 <zipper> Ok let me test myself by writing the (<*>)
01:50:48 <zipper> kadoban: Maybe I'm not ready for monad transformers, but you said it's confusing to people at first so I think I am ready.
01:53:25 <kadoban> Ya, it was pretty mind-bending for me I know, and I think I was ready. At least I eventually got through it. Took me probably a couple weeks to get through NICTA maybe
01:53:47 <kadoban> (after already knowing haskell to a level where I could code reasonable-ish software)
01:53:54 <zipper> kadoban NICTA?
01:54:33 <kadoban> https://github.com/NICTA/course
01:54:44 <zipper> I am watching CT videos and reading the haskell book, I haven't written haskell in a while though
01:55:01 <zipper> Would you say that course is good if I want to apply for haskell jobs?
01:55:33 <zipper> I first have to finish this book
01:55:37 <kadoban> It's like a bunch of this stuff, guided with tests. Eh, I dunno, I liked it a lot. A lot of what's in it is also in haskell book, and the book guides you better (mostly there's just more text/explanation)
01:55:50 <zipper> kadoban: Was it a few weeks with you working on it at night after work and on weekends?
01:56:07 <kadoban> I didn't work on it all day or anything, but probably a couple of hours a day
01:56:21 <zipper> Sometimes I get so frustrated like last night I just got some vodka and closed the laptop :(
01:56:39 <zipper> kadoban: Yes I also do work during the day so I only work on it after I cook
01:56:42 <zipper> and  stuff
01:57:07 <kadoban> Breaks are an important part, I don't think it's really possible to just power through this stuff and force yourself, you have to take time for it to absorb and come back to it.
01:57:19 <zipper> What is frustrating is me wondering whether I don't get it because of something wrong with me. Not being in a class means I blame myself a lot
01:57:28 <zipper> kadoban: I see
01:57:39 <zipper> This is great avise 
01:57:50 <kadoban> I highly doubt there's something wrong with you, you'll get it
01:58:05 <zipper> kadoban: Yeah :D just patience.
01:58:15 <zipper> and lotsa practice
01:58:19 <zipper> Thanks
02:00:52 <dibblego> if you can get through the course, I will employ you
02:01:56 <zipper> dibblego: For real?
02:02:12 <zipper> dibblego: Don't make me do it lol
02:02:14 <dibblego> that has how I have employed people for about 8 years now
02:02:32 <zipper> Ok uh will come back to this chan when the time is right
02:02:56 <zipper> dibblego: You'll be hearing from me
02:03:33 <dibblego> ok
02:09:46 <zipper> kadoban: So one question how come for the `myPure` point free style worked but for the more general `Compose` it did not. As in `pure x = Compose (pure (pure x))` typechecks but `pure = Compose $ pure . pure` doesn't
02:10:02 <zipper> kadoban: per my reasoning in the more verbose one
02:10:19 <zipper> We call pure on the value before we apply f and g's pure
02:10:29 <zipper> Oh wait
02:10:38 <zipper> hahaa we are just calling fmap twice
02:10:47 <zipper> So we wrap the a in pure then f and g
02:11:09 <zipper> Uh like pure = (fmap . fmap) pure 
02:11:43 <kadoban> zipper: Should just be    Compose . pure . pure   I think, not $
02:12:10 <kadoban> You wrap it up after you   pure . pure the value, you don't wrap up the function that would create the right value
02:13:45 <kadoban> Compose $ pure . pure      would be more like, uhm ...      pure = Compose $ \x -> (pure (pure x))     something like that, something non-working
02:14:34 <zipper> I see but if it was . not $
02:14:37 <zipper> It would be
02:15:37 <zipper> fmap Compose \x -> (pure (pure x))
02:15:51 <zipper> lol works but I have confused self
02:16:02 <zipper> I am lifting Compose over something unknown
02:16:08 <Ferdirand> (pure . pure) :: a -> f (g a)
02:16:21 <Ferdirand> Compose :: f (g a) -> Compose f g a
02:17:15 <Ferdirand> (Compose f g a) is equivalent to (Compose f g) a, because application is left-associative
02:17:38 <Ferdirand> so (Compose . pure . pure) :: a -> (Compose f g) a
02:18:32 <Ferdirand> Compose is mostly an implementation artefact here, I believe
03:05:10 <jchia_> When I run "stack build", some "build-depends" in one of my project .cabal files gets modified to have a lower upper bound. Is this expected? If so, what exactly is stack trying to do and how do I prevent it?
03:06:42 <zipper> kadoban: You still here?
03:07:04 <zipper> So I am writing the apply instance for the compose type
03:07:53 <zipper> and I have `(<*>) :: Compose f g (a -> b) -> Compose f g a -> Compose f g b` with f and g having Applicative instances, right?
03:08:09 <jchia_> I think "stack build" was just building the .cabal file from the package.yaml
03:08:15 <jchia_> i didn't know "package.yaml" was a thing
03:08:43 <zipper> and I have `(Compose f) <*> (Compose a) = Compose $ f . a` as the implementation which wont typecheck
03:09:24 <zipper> To me I see the f and g can be abstracted to the f in fmap such that my implementation should work
03:09:51 <zipper> Such that  Compose $ fmap f a should work
03:10:01 <zipper> which is the same as  Compose $ f . a
03:10:11 <zipper> but seems I'm missing something.
03:11:16 <zipper> and the error I get seems to be what I want
03:11:30 <zipper> f g (a -> b)
03:13:06 <zipper> It makes so much sense in my view but ghc won't let me
03:14:15 <Ferdirand> if the solution could be written with fmap only
03:14:32 <zipper> Ferdirand: Hello
03:14:34 <Ferdirand> then it would mean you would only need (Functor f, Functor g) 
03:15:23 <Ferdirand> remember that for pure you needed to call out to the pure of the two underlying applicatives
03:16:24 <Ferdirand> does this help ?
03:16:35 <zipper> Ferdirand: Even if I used f <*> a it's like the same result :)
03:16:48 <zipper> hmmm I do
03:17:03 <zipper> So it's uh (<*> (<*> x)
03:17:05 <zipper> LOL
03:17:07 <zipper> Wait 
03:17:15 <zipper> let me try things before I post them
03:20:55 <zipper> Ferdirand: When it's `Compose $ f <*> a` It's of type f (g (a -> b)) while it wants f g (a -> b) So I can see I am not applying the a -> b far enough
03:22:04 <Ferdirand> this is tricky
03:22:12 <Ferdirand> a bit more than the pure case probably
03:22:42 <Ferdirand> i'm not sure how to give hints without spoiling it
03:23:28 <Ferdirand> do you know how to derive fmap from pure and <*> ?
03:24:29 <Ferdirand> the solution cannot involve only <*>, you also have to call pure or fmap
03:25:54 <zipper> Ferdirand: Ok I see I have a `g (a -> b)` and I want to make it a `(ga -> gb)`
03:26:07 <zipper> So I need to lift/fmap g over (a -> b)
03:26:10 <zipper> I see that
03:28:02 <zipper> this  is (<$>)
03:28:12 <Ferdirand> <$> is fmap
03:29:47 <Ferdirand> and fmap is (<*>) . pure
03:30:20 <Ferdirand> alternatively, f <$> x = pure f <*> x
03:30:54 <Ferdirand> so in this case, ignoring the Compose wrapping, you want to write
03:31:07 <Ferdirand> f (g (a ->b)) -> f (g a) -> f (g b)
03:31:09 <zipper> Yeah but pure f <*> x should work
03:31:11 <zipper> It's not
03:31:13 <zipper> lol
03:31:17 <zipper> I tried it
03:31:18 <mbw> Hello everyone. Is it possible to define binary operators of the form (<.,.>), to be used like <x,y> ?
03:31:27 <zipper> Well maybe it failed because of the Compose
03:31:29 <Ferdirand> (Applicative g) provides g (a -> b) -> g a -> g b
03:31:46 <zipper> Ferdirand: Yes
03:31:48 <Ferdirand> that is <*>
03:31:52 <zipper> I just need to get into the g
03:31:55 <Ferdirand> if you lift that into f with fmap
03:31:56 <Ferdirand> you get
03:31:57 <zipper> Like it's in the f
03:32:02 <zipper> I need to lift over the f
03:32:10 <Ferdirand> f (g (a -> b)) -> f (g a -> g b)
03:32:36 <zipper> I see it in the types I see I have a `g (a -> b)` which can be applied to a using <*>
03:32:46 <Ferdirand> and then the <*> from (Applicative f) provides
03:32:55 <Ferdirand> f (t -> u) -> f t -> f u
03:33:02 <Ferdirand> that you can specialize into
03:33:13 <Ferdirand> f (g a -> g b) -> f (g a) -> f (g b)
03:33:29 <zipper> Yes Ferdirand 
03:33:50 <zipper> but I can't see how to make the second (<*>) work
03:35:36 <Ferdirand> just follow the types
03:36:00 <Ferdirand> starting from (Compose ff) <*> Compose x
03:36:08 <Ferdirand> ff :: f (g (a -> b))
03:36:15 <Ferdirand> x :: f (g a)
03:36:40 <Ferdirand> <*> :: g (a -> b) -> g a -> g b
03:37:12 <zipper> Ferdirand: and ff <*> x gives f (g (a -> b)
03:37:14 <Ferdirand> fmap :: g (a -> b) -> f (g (a -> b)) -> f (g a -> g b)
03:37:48 <Ferdirand> <*> :: f (g a -> g b) -> f (g a) -> f (g b)
03:38:29 <zipper> Yes the fmap makes sense
03:38:49 <Ferdirand> i've just specialized these things to their relevant types
03:38:50 <zipper> hmmmm I see the <*> :: f (g a -> g b) -> f (g a) -> f (g b) is what I need
03:38:53 <zipper> So
03:39:04 <Ferdirand> now you just need to connect them
03:39:42 <zipper> Ferdirand: One sec
03:40:24 <Ferdirand> oh sorry i fucked up
03:40:29 <Ferdirand> my fmap is missing a term
03:40:49 <zipper> Seems to me partially applying another <*> should work
03:40:55 <zipper> but where to do it
03:41:08 <Ferdirand> fmap :: (g (a -> b) -> g a -> g b) -> f (g (a -> b)) -> f (g a -> g b)
03:41:23 <zipper> wait
03:41:58 <Ferdirand> fmap :: (t -> u) -> f t -> f u
03:42:03 <Ferdirand> t = g (a -> b)
03:42:11 <Ferdirand> u = g a -> g b
03:42:22 <zipper> :t ((<*>) . (<*>))
03:42:23 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
03:42:24 <zipper> > :t ((<*>) . (<*>))
03:42:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:44:41 <haskell-herbert> hello everybody i am facing a problem regarding testing my modules with hspec
03:44:49 <mbw> Is it possible to implement an operator that behaves like the tuple constructor, i.e. (,) a b = (a,b)?
03:45:07 <haskell-herbert> is there anybody familiar with hspec
03:45:11 <haskell-herbert> ?
03:47:36 <zipper> Ferdirand: I can see that I need to do (fmap g) somehow I have seen that for a while.
03:47:48 <zipper> How to write that has been the issue
03:55:31 <xpika> is there a command line tool for extracting data from a .cabal file?
03:57:02 <zipper> Ferdirand: LOL this function. I figured it out. I got to `f g (a -> b)` to be `f (g a -> g b)` using `fmap (<*>)`
03:57:51 <zipper> I don't know if I actually know what I did or tried all possible combinations that made some sense
03:58:17 <zipper> Ferdirand: I got it to tyoecheck
03:58:29 <bengt_> was banging my head against that one yesterday, also not sure if I actually understand what I did haha
04:07:10 <zipper> bengt_: What I am doing today?
04:07:19 <zipper> I guess it's all about practice, right?
04:07:33 <jdnd> Hello
04:07:42 <bengt_> I guess so, still trying to learn this stuff myself
04:08:35 <jdnd> So I installed GLUT, got that stuff all installed
04:09:10 <jdnd> but when I try to run an example GLUT program, it gives me "gears.hs: user error (unknown GLUT entry glutInit)"
04:09:22 <jdnd> Tried googling around a bit, didn't come up with anything 
04:10:10 <zipper> bengt_: Good to know that I am not brain damaged
04:10:15 <bengt_> zipper: are you also working through the "haskell programming" book?
04:10:19 <zipper> bengt_: or that we are both brain damaged
04:10:25 <zipper> bengt_: Yes
04:13:04 <bengt_> it does feel that way, but its really fun once you finally get something that typechecks, thats what keeps me going, even I feel retarded most of the time
04:13:12 <bengt_> even if I*
04:13:24 <bengt_> :D
04:15:11 <zipper> bengt_: :)
04:15:38 <zipper> are we programming or are we applying type theory :)
04:15:54 <bengt_> feels more like doing algebra golf sometimes
04:16:20 <bengt_> haven't really written anything useful yet
04:19:13 <Ferdirand> have you tried implementing join in terms of (>>=) ?
04:19:32 <Ferdirand> :t join
04:19:34 <lambdabot> Monad m => m (m a) -> m a
04:19:34 <zipper> Ummm I don't quite see *why* we can't compose monads
04:19:55 <zipper> Ferdirand: you mean ummm `fmap . join`?
04:19:59 <zipper> Wait what was it
04:20:13 <zipper> I remember doing bind in terms of fmap and join
04:20:36 <Ferdirand> that would be join in terms of (>>=)
04:20:40 <Ferdirand> sorry
04:20:47 <Ferdirand> (>>=) in terms of join
04:20:51 <Ferdirand> but the other way around
04:21:01 <Ferdirand> (it doesn't require fmap)
04:21:29 <zipper> Oh wait I kinda do
04:21:40 <zipper> the composing monads
04:21:54 <zipper> Ferdirand: I did but I can't remember very well
04:22:29 <Ferdirand> well the point is that it is very easy to derive from the types
04:22:36 <Ferdirand> provided you see the trick
04:23:07 <Ferdirand> but your mind can easily be blind to it
04:24:12 <zipper> Ferdirand: I have watched some CT videos and they sure make it easier to understand why we care so much about composition and identity
04:24:29 <zipper> Because knowing why I am doing something really helps with motivation
04:30:26 <ij> I've a "f :: a -> b -> m ()" and I want to give it "use h :: m a" and get "b -> m ()". Would that be (f <$> use h <*>) . return?
04:30:34 <ij> Does anything better exist?
04:30:49 <ij> Actually, it doesn't seem that bad.
04:32:24 <Ferdirand> (use h >>=) . flip f ?
04:37:01 <ij> Those parens bother me a little. Though not trying to criticize the solution.
04:37:39 <ij> In general the requirement of parens for symbol-functions, because they don't have normal-named equivalents.
04:40:09 <xpika> is it possible to specify imports when using ghc -e ?
04:52:31 <geekosaur> xpika, yes but it's a bit screwy
04:52:58 <xpika> geekosaur: do tell
04:53:01 <geekosaur> pyanfar Z$ ghc -e 'import Control.Monad' -e 'print 5'     
04:53:01 <geekosaur> 5
04:53:37 <geekosaur> at least I ththink that did the right thing... might have overwritten, but semicolons don't seem to work
04:54:11 <xpika> geekosaur: WOW thanks!
04:54:19 <geekosaur> works
04:55:36 <xpika> geekosaur: I thought pyanfar was some weird monad until I realised it was your shell prompt
05:00:04 <zipper> pyanfar?
05:01:00 <zipper> Ah 
05:03:09 <zipper> stack exec runs what is in .stack-work and not what is in ~/.bin even if there's something there, right?
05:05:12 <MarcelineVQ> afaik if the thing it's looking for is in .stack-work it'll find it there first, if it doesn't find it it'll search other places, such as .bin if it's on your path
05:05:31 <MarcelineVQ> use stack exec -- which <command> to see where it finds things if you're unsure
05:10:57 <ij> How do I Maybe (IO ()) -> IO ()?
05:11:17 <dramforever> :t fromMaybe (pure ())
05:11:19 <lambdabot> Applicative f => Maybe (f ()) -> f ()
05:11:56 <dramforever> :t sequence
05:11:58 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
05:12:02 <dramforever> :t sequence_
05:12:04 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
05:12:20 <dramforever> ij: Just sequence_
05:12:27 <dramforever> (no pun intended)
05:13:22 <ij> Nice!
05:17:04 <MarcelineVQ> zipper: it seems to search your local project, then your snapshot, and then elsewhere, if you use stack exec -- which <something>  and something doesn't exist, it'll tell you where it searched for it
05:19:35 <YellowOnion> Could someone help me with this csv parser I'm trying to write, it gives me a useless error "string" http://lpaste.net/351222
05:20:53 <dramforever> ij: Python: There's a library for that. Haskell: There's a function for that. Yes you already knew that function but you didn't know it could be used like that
05:21:15 <ij> I love haskell.
05:21:22 <ij> I've been matching types for three hours straight.
05:21:40 <ij> And should be preparing for leaving the house…
05:21:42 <ij> :D
05:21:58 <dramforever> :)
05:24:13 <dramforever> YellowOnion: Your code is missing 'sepParser'
05:24:58 <YellowOnion> dramforever, err I don't know what I was thinking, sepParser = char ','
05:26:23 <YellowOnion> dramforever, adding that function back in, I get the output "Error while parsing Systems: string"
05:27:22 <dramforever> What's the input like?
05:28:45 <dramforever> YellowOnion: ^
05:29:08 <YellowOnion> dramforever, http://lpaste.net/351225
05:29:28 <YellowOnion> dramforever, should have pasted that earlier, got the flu, so I bit slow today.
05:31:24 <dramforever> YellowOnion: did you forget to consume the terminating ' of a string?
05:31:28 <dramforever> in 'csvString'
05:32:06 <YellowOnion> dramforever, ahh I was wondering if I need to consume it. let me see.
05:32:37 <dramforever> doesn't really fix the problem though
05:32:45 <YellowOnion> no it doesn't.
05:35:34 <pavonia> YellowOnion: You don't parse the line ends from the second line on
05:36:14 <dramforever> attoparsec gets particularly unhelpful here
05:37:35 <YellowOnion> pavonia, let me try that.
05:38:50 <xpika> is there a lens operator for the right side of an Either data type ?
05:39:01 <codedmart> If I am using `readProcessWitExitCode` with an external program and I need to pass a filepath relative to the root of my project. How is that handled in haskell?
05:44:05 <YellowOnion> pavonia, dramforever I updated the paste with more info.
05:46:48 <delYsid> I am a big fan of the Python requests, lxml and jinja2 packages.  What would be the counterparts of these in Haskell?
05:47:06 <L00PeR> Somebody knows the best way for doing a wifi scan and detect unknown devices connected to your wifi?
05:48:12 <dramforever> I think I got it
05:48:53 <dramforever> between line 32 and 33 you are missing a sepParser
05:49:27 <YellowOnion> dramforever, oh good spotting!
05:49:29 <dramforever> *and* on line 40 you got the parens wrong. Should have been many (eDSystemParser <* endOfLine)
05:49:31 <delYsid> I've found myself using python lately to do scraping jobs, and it was very very efficient and pleasant to whip something up very very quickly.  I wonder if I could do something like that in Haskell and have a similar feeling of getting things done quickly.
05:50:05 <dramforever> I know requests -> wreq
05:51:04 <dramforever> YellowOnion: Try 'proper' parser combinator libraries if you want to have better error messages. megaparsec comes to mind
05:51:26 <dramforever> You can probably port code between them without much trouble, but I haven't really done that...
05:51:33 <zipper> OMG these GHC lang extensions can really reduce the amount of code one writes hahaha
05:51:34 <zipper> WOW
05:51:35 <dramforever> I haven't really done that before
05:51:38 <zipper> Mind blown
05:52:16 <YellowOnion> dramforever, you have a good point, any of these fast? I need to parse a 400MB file.
05:52:16 <zipper> PatternGuards, ViewPatterns
05:52:27 <dramforever> YellowOnion: They are not
05:52:31 <dramforever> but you switch between them
05:52:48 <YellowOnion> ohh drop in replacement?
05:52:52 <dramforever> not quite
05:52:54 <zipper> This is a good book "What I Wish I Knew When Learning Haskell"
05:53:05 <dramforever> attoparsec does backtracking by default
05:54:12 <MarcelineVQ> zipper: there's lots of good stuff on that site beyond that list as well, be sure to look around
05:54:16 <dramforever> With, say, megaparsec you need to insert a few 'try's into your code to get controlled backtracking behaviour
05:54:42 <dramforever> *But* in attoparsec there's a no-op 'try' so you don't really need to delete them
05:54:58 <dramforever> http://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec.html#v:try
05:55:03 <zipper> I'm overwhelemed with all the good haskell resources I don't know how I missed them when I was writing and learning haskell like 3 years ago
05:55:12 <zipper> MarcelineVQ: I shall
05:56:14 <zipper> OMG http://dev.stephendiehl.com/fun/
05:56:20 <dramforever> YellowOnion: On the other hand, any reason you are not using a 'proper' csv library?
05:57:13 <dramforever> Like cassava, which claims to be high-performance
05:57:59 <xpika> ok I found it all _Right
05:58:16 <dramforever> Oops, looks like it doesn't have nice error messages. But you can't make such mistakes you've made, right?
05:58:18 <YellowOnion> dramforever, to be clear, I need to parse a custom format for something else soon, so this is more practice than anything.
05:58:24 <dramforever> Ah okay
05:58:52 <dramforever> YellowOnion: Dropping 'from' parsec or (the newer) megaparsec 'to' attoparsec is quite easy
05:59:38 <zipper> WOW Stephen Diehl must be very smart
05:59:57 <YellowOnion> dramforever, that might work, if I hit any major road blocks I'll switch over.
06:01:32 <YellowOnion> though I think I should learn to do unit testing, If I had tested csvString, and eDSystemParser separately it might have been easier.
06:02:06 <dramforever> YellowOnion: TBH I just did 'manual testing' on your code :P
06:02:50 <dramforever> YellowOnion: Oh and there's a thing called <?>
06:03:40 <dramforever> You slap it after your parser definition like in: something <* something <* something <?> 'unicorns!'
06:03:53 <YellowOnion> dramforever, ahh
06:04:07 <dramforever> And when something doesn't parse you see 'unicorns!' in the error message
06:04:12 <dramforever> like a stack trace
06:05:04 <dramforever> Generally you put it onto nameable things like 'csv string', 'EDSystem'
06:06:02 <dramforever> Gotta go, wish you good luck with parsing and Haskell in general :)
06:15:56 <sabastiaan> I'm trying to output a string without \n before reading from stdin, but I can't get it to work
06:16:01 <sabastiaan> is there a way to manually flush stdout?
06:16:59 <IPXSam> Hello, in ghci I'm doing "some_value = [1, 2, 3, 4]" and I see you can also do "let some_other = False" what is the difference? are both functions?
06:19:29 <hpc> neither are functions
06:19:46 <kadoban> IPXSam: There's no difference. The former is a bit more sugary than the latter.
06:20:06 <kadoban> They're both just values. You can check their types with :t some_value   and etc.
06:20:13 <Boomerang> sabastiaan: Does "putStr" not work for you? You could either do "hSetBuffering stdout NoBuffering" or manually calling "hFlush stdout". These functions are available in System.IO
06:21:03 <sabastiaan> Boomerang, I tried putStr, but it does print the output untill a full line is printed 
06:21:10 <IPXSam> kadoban, yeah I did that to make sure and got for some_value = "some string" 'some_value :: [Char]' I'm not entirely sure what the '::' token is, is it an operator?
06:21:28 <sabastiaan> Boomerang, My guess would be because the default buffering would be on line buffering, which then would make sense
06:21:45 <Boomerang> Yes sabastiaan line buffering is the default
06:21:55 <kadoban> It's syntax for type annotations. It means something like    some_value is of type [Char]
06:22:25 <kadoban> [Char] is a list of characters, also known as String
06:22:42 <sabastiaan> Boomerang, calling hFlush stdout did the trick. Thanks! 
06:22:45 <IPXSam> kadoban, when I do some_value = [1, 2, 3, 4, 5] and later check its type, it says some_value :: Num t => [t] does that qualify as a function?
06:23:09 <Boomerang> sabastiaan: Setting the buffering is probably a better solution if you have to do it several times :)
06:23:12 <sabastiaan> IPXSam, no the => is a type restriction
06:23:34 <sabastiaan> In this case Num t states that t can only be type of Num
06:23:35 <kadoban> No, it's a polymorphic value. Num t => [t]   means that for any type that's an instance of Num, some_value is a list of elements of that type
06:24:01 <kadoban> Some example instances of Num would be Integer, Float, Rational, etc.
06:24:20 <kadoban> Note that Num is not itself a type, it's a typeclass.
06:24:21 <sabastiaan> Boomerang, Will do, but to set default buffering you have to give it as compile argument no?
06:24:55 <IPXSam> Okay and I assume that when you have something like double_num :: Num a => a -> a that does qualify as a function
06:25:06 <Boomerang> sabastiaan: No, just call "hSetBuffering stdout NoBuffering" once before outputting anything and you're good to go
06:25:07 <IPXSam> Because of the '->' operator>
06:25:08 <kadoban> Yes
06:31:30 <zipper> Is it normal to have a TypesSpec.hs to check types?
06:31:49 <zipper> Like to check that a parseJSON returns the correct thing?
06:35:35 <zipper> Also if reading a json file fails parseJSON doesn't let you have a Maybe or an Either
06:35:42 <zipper> What do you guys do?
06:37:03 <amx> parseJSON doesn't, but decode does
06:38:24 <amx> there's also parseEither and parseMaybe
06:38:52 <IPXSam> Is Haskell code supposed to have lots of parentheses? it complains if I don't type them when chaining function calls
06:39:26 <IPXSam> e.g. here http://pastebin.com/gkdvhVtS
06:40:01 <Boomerang> IPXSam: when chaining function calls you can use the compose function (.)
06:40:11 <Boomerang> :t (.)
06:40:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:43:02 <Boomerang> > let strcps x = unwords . replicate x in strcps 5 "abc" -- IPXSam 
06:43:05 <lambdabot>  "abc abc abc abc abc"
06:43:36 <kadoban> IPXSam: A couple of those are avoidable in various ways, but I wouldn't worry about it too much early on.
07:12:55 <IPXSam> kadoban, how would you?
07:13:08 <IPXSam> in the example I gave before in pastebin how would you minimize parenthesis usage?
07:13:23 <Rembane> IPXSam: More $ and .
07:13:48 <IPXSam> I tried using those but I can't grasp how they work.. an example would help
07:13:52 <Rembane> Aha. 
07:14:24 <Rembane> Lets see if I can rework your example.
07:15:52 <Rembane> IPXSam: http://lpaste.net/351229
07:18:07 <IPXSam> Rembane, I'm getting two errors with that
07:18:33 <Rembane> IPXSam: I see
07:19:47 <Rembane> IPXSam: Code that actually works needed more brackets. :/
07:19:59 <IPXSam> It's fine
07:20:14 <Rembane> http://lpaste.net/351229
07:21:22 <Rembane> IPXSam: BTW, have you seen this function? https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html#v:intercalate
07:21:42 <Rembane> > intercalate " " ["Hello", "cruel", "world!"]
07:21:44 <lambdabot>  "Hello cruel world!"
07:22:27 <IPXSam> Thanks for that, I'm just learning the language so I'm not prioritizing knowing every function that does XYZ
07:23:26 <Rembane> IPXSam: No worries.
07:24:01 <Rembane> IPXSam: Another technique is to give names to subexpressions. Are you familiar with where-expressoins?
07:24:58 <IPXSam> I kind of know what they do, I assume my example would be a cascade of nested wheres right?
07:25:00 <ggVGc>  worst part of Elm is no where clauses!
07:25:11 <ggVGc> where clauses are great
07:25:15 <Rembane> ggVGc: Does it have let-expressions?
07:25:17 <ggVGc> yes
07:25:19 <Boomerang> Rembane: intercalate " " is the same as unwords in the example I gave :)
07:25:25 <ggVGc> Rembane: but I very often prefer where
07:25:33 <Rembane> IPXSam: You don't have to nest them.
07:25:44 <Rembane> Boomerang: I failed my read-backlog-roll. :)
07:26:09 <Rembane> ggVGc: Same here, it makes the lines shorter.
07:26:22 <Boomerang> No worries, I was just wondering if my example was maybe not understood by IPXSam, I could explain it
07:27:03 <ggVGc> Rembane: it's also much easier cognitively for me. foo = x*processSomething(y) is clear, and then if I need to know what processSomething actually does I can look at the where clause
07:27:11 <ggVGc> rather than scanning to the bottom
07:27:28 <roundhouse> hi there, is there a way to map the exception type of MonadError?
07:27:35 <Rembane> ggVGc: Indeed, I've started to jump to in by now, but you don't get the nice overview.
07:30:59 <roundhouse> I guess one way to do it would be to use catchError, map to whatever I want and rethrow; but that seems a little verbose
07:31:09 <roundhouse> I'm using mtl's MonadError btw
07:32:33 <Rembane> roundhouse: You could also turn it into a value, an Either for instance.
07:33:17 <roundhouse> Rembane: how do I do that? Or do you mean change the type signature?
07:40:08 <Rembane> roundhouse: Use runExcept, dfeined here: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
07:51:15 <sabastiaan> Can somebody help me with a little piece of code? 
07:51:15 <sabastiaan> http://pastebin.com/fb81uKXH
07:52:48 <sabastiaan> I want to return the result of an IO String function, as an argument to an String -> Maybe IO Function
07:54:10 <sshine> what?
07:54:26 <sshine> by IO String function, do you mean IO (String -> String), or String -> IO String?
07:54:34 <Welkin> break it down using do-notation
07:55:12 <sshine> and are you sure you don't want a String -> IO (Maybe (a -> b)) for some a, b?
07:57:44 <sshine> sorry, sabastiaan, I didn't see your pastebin. I must be blind.
07:57:48 <sabastiaan> With IO String function I meant IO (String)
07:57:49 <sabastiaan> my bad
07:58:46 <Welkin> that is the same thing
07:58:55 <sshine> well, IO String is an action.
07:59:46 <sshine> or an effect? I don't think you'd normally refer to 'IO a' as a function..
08:00:02 <jchia_> How can I directly tell (e.g. by running ghci) for a given version of ghc/ghci whether a certain extension is already the default behavior (e.g. ApplicativeDo for 8.0)?
08:00:52 <Welkin> jchia_: read the docs I suppose
08:00:57 <sabastiaan> Ow that makes a lot of sense actually
08:01:14 <sabastiaan> I always thought of getLine of a function instead of an action
08:05:18 <sshine> sabastiaan, so the error you get seems to relate to the function for which the source code is omitted?
08:05:43 <sshine> @pl getLine >>= \a -> findCommand a
08:05:43 <lambdabot> findCommand =<< getLine
08:06:01 <sshine> or getLine >>= findCommand
08:06:23 <sabastiaan> sshine, the other function works fine, no errors there. Its just when calling itr
08:06:48 <sshine> sabastiaan, ah. you want 'then fromJust command'
08:07:01 <sshine> sabastiaan, command is a Maybe (IO ()) but is being used as if it were an IO ().
08:07:11 <sshine> sabastiaan, but better yet, you don't really want to use isJust and fromJust.
08:08:21 <Welkin> even better, avoid those two and instead use `maybe`
08:08:28 <Welkin> :t maybe
08:08:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:12:48 <Boomerang> :t fromMaybe (return ())
08:12:49 <lambdabot> Monad m => Maybe (m ()) -> m ()
08:14:23 <sshine> fromMaybe (putStrLn "Command not found") (getLine >>= findCommand)
08:19:10 <c_wraith> what's the current status of the interaction between Typeable and dynamic loading?
08:26:12 <sabastiaan> sshine, http://pastebin.com/hidw7f8v
08:26:45 <sabastiaan> sshine, I tried to run your code, but I don't know why it would fail
08:26:51 <epta> https://hackage.haskell.org/package/http-client-0.5.4/docs/Network-HTTP-Client.html#t:HttpExceptionContent what does it mean 'may including the beginning of response body?' in the comment for StatusCodeException? `responseBody' of such response is :: ().  
08:29:59 <mbw> Is there any documentation on how to actually use the https://hackage.haskell.org/package/algebra package by ekmett? Is it intended for use with NoImplicitPrelude or hiding the usual operators explicitly?
08:30:53 <sshine> sabastiaan, oh. right.
08:30:59 <sshine> :t (>>=) getLine
08:30:59 <Boomerang> sabastiaan: try with "fromMaybe (putStrLn "Command not found") (getLine >>= fmap sequence findCommand)"
08:31:01 <lambdabot> (String -> IO b) -> IO b
08:31:29 <Boomerang> Wait no
08:31:38 <Boomerang> that would be IO (Maybe ())
08:35:39 <sshine> sabastiaan, 
08:35:39 <sshine> import Data.Maybe (fromMaybe)
08:35:39 <sshine> getCommand :: IO ()
08:35:39 <sshine> getCommand = do
08:35:39 <sshine>   line <- getLine
08:35:41 <sshine>   fromMaybe notFound $ findCommand line
08:35:44 <sshine>   where
08:35:46 <sshine>     notFound :: IO ()
08:35:49 <sshine>     notFound = putStrLn "Command not found"
08:35:51 <sshine> findCommand :: String -> Maybe (IO ())
08:35:54 <sshine> findCommand "ls" = Just $ putStrLn "Lots of files!"
08:35:56 <sshine> findCommand "pwd" = Just $ putStrLn "You're here!"
08:35:59 <sshine> findCommand _ = Nothing
08:36:01 <sshine> oops.
08:36:04 <sshine> wrong paste buffer.
08:36:06 <sshine> sorry.
08:36:59 <sshine> sabastiaan, then you could rewrite that: 'fromMaybe notFound . findCommand $ line' or yet 'fromMaybe notFound . findCommand <$> getLine'
08:39:04 <glguy> I think the second one should be: =<< instead of <$>
08:39:31 <sshine> or maybe 'do { cmd <- findCommand <$> getLine; fromMaybe notFound cmd }' is probably nicer.
08:40:01 <sshine> whoops. I'm mixing Monad types now.
08:41:25 <sshine> glguy, yeah.
08:47:08 <kareeeeem> Hi people of #haskell, is cis194 by B. Yorgey still a relevant resource for learning the language? 
08:47:11 <kareeeeem> http://www.seas.upenn.edu/~cis194/spring13/
08:48:22 <glguy> yes
08:50:04 <kareeeeem> Thank you. One followup: has the language progressed in ways that make certain details incompatible? I heard that this was the case with some other books.
08:54:02 <glguy> kareeeeem: there are always minor changes but it's still a useful resource
08:55:04 <kareeeeem> Alright. Thanks.
08:56:08 <sabastiaan> sshine, that worked, thanks!
09:09:15 <ph88> hey guys, i'm making a parser and now i'm thinking over the pros and cons of putting comments and terminals together in the same node, now i have to decide whether i would add the comments before a terminal or the comments after the terminal to the node of that terminal .. anyone a suggestion ?
09:25:37 <dogbitsman> I would suggest comments before the terminal. So people get a description of the terminal before they see it
09:27:41 <ph88> well for pretty printing it doesn't really matter, it's just how to store it in the syntax tree
09:32:15 <nitrix> Is there such thing as an MVar that you can write to multiple times overwriting the older value (instead of blocking when there's a value), and still, only read once as usual (reading the latest value) ?
09:33:30 <glguy> There used to be this https://hackage.haskell.org/package/base-4.4.1.0/docs/Control-Concurrent-SampleVar.html
09:34:07 <glguy> and then it was deprecated with Deprecated: Control.Concurrent.SampleVar will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.
09:34:15 <nitrix> I'm essentially having a logic loop of a game signal the renderering when there has been changes and it needs to redraw, but I'd like that, if it's in the middle of drawing, instead of blocking, I'm able to keep going and process more events. Every new events processed, I just tell the renderer it has to redraw and it clears that flag.
09:34:33 <glguy> http://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/Control-Concurrent-MSampleVar.html
09:34:33 <nitrix> I basically want a concurrent boolean, with the semanic that "True" wakes up the listening thread.
09:35:07 <glguy> You can also easily build that with a TVar
09:37:09 <nitrix> glguy: Checking but TVar doesn't seem to cut it.
09:37:29 <glguy> look up "retry" along the way
09:37:50 <glguy> You read the TVar, and if you want to block until it changes you can retry
09:38:10 <nitrix> glguy: I'd be able to write multiple times to signal the renderer thread to redraw, but then, is the render thread guaranteed to wake up when a write is done?
09:38:24 <glguy> yep
09:38:42 <nitrix> readTVar is blocking?!
09:39:25 <glguy> look up "retry" along the way
09:39:52 <glguy> retry will block
09:41:26 <glguy> With STM you write a transaction on STM reference. If things aren't in the state you're looking for you can execute retry which will wait to rerun the transaction until something you read has been updated
09:41:47 <osa1> nitrix: IIRC pipes-concurrency has a pipe that works that way
09:42:06 <glguy> It makes it great for conditionally reading from variables, channels, queues, reading from one of many queues, etc
09:43:26 <osa1> nitrix: see `latest` here http://hackage.haskell.org/package/pipes-concurrency-2.0.7/docs/Pipes-Concurrent.html
09:43:59 <osa1> it uses STM under the hood so you can just copy the implementation if STM is OK
09:44:34 <nitrix> glguy: I'm going to use MSampleVar from SafeSemaphore because the documentation is very clear about the semantics.
09:44:43 <glguy> cool
09:44:53 <nitrix> glguy: I'll dedicate more time to STM later. Great find, appreciated (:
09:49:51 <nitrix> osa1: Appreciated. Bookmarked and I'll let you know how it turns out :)
09:51:49 <alakvx> wooohooo finally found an active chatroom
09:52:10 <alakvx> all the other misc fp chatrooms were just filled with crickets 
09:55:15 * int-e watches a tumbleweed blowing over the channel.
09:55:25 <alakvx> awkard
09:55:46 <glguy> FP writing crickets also sounds pretty impressive
09:57:35 <ph88> i get parse error on input "do" on line 4  https://paste.fedoraproject.org/527153/16593148/   how can i make do blocks in do blocks ?
10:02:30 <lyxia> ph88: lines 5 and 6 are not aligned
10:02:48 <geekosaur> they are, the pastebin munged tjem. look at the raw paste
10:03:19 <geekosaur> guessing it's related to the botched highlighting
10:04:22 <ph88> lyxia, eh i'm not sure what went wrong with the paste but they show up aligned in my editor ^^
10:04:37 <mbw> Does anybody know how to build the examples of the numeric prelude https://hackage.haskell.org/package/numeric-prelude ? I tried to stack new a simple project and pass the "buildexamples" flag via the stack.yaml. 'stack build' will suggest to 'stack solve', since gnuplot and HTam. However, this results in cabal errors.
10:05:11 <mbw> Any help would be appreciated.
10:07:47 <ph88> is do-block in do-block even possible or should i use bind ?
10:08:38 <geekosaur> ph88, I am wondering if it's actually related to using $, try parens instead
10:09:19 <lyxia> ph88: you're missing the last statement of your outer do block
10:09:52 <lyxia> ph88: the last statement can't be  foo <- bar
10:10:10 <ph88> ups my bad, the error started to point to another do-block which looks almost similar
10:10:13 <ph88> sorry for the fuzz
10:16:02 <mbw> The HTam package listed as dependency for the numeric prelude https://hackage.haskell.org/package/numeric-prelude does not even exist on Hackage https://hackage.haskell.org/package/HTam . I am starting to suspect that the numeric prelude is something that keeps getting mentioned, but isn't actually used...
10:25:29 <hackrilege> How do I write [[]] with kind * -> * ?
10:25:44 <hackrilege> :kind [[]]
10:26:17 <monochrom> would it be [] []?
10:26:43 <monochrom> > [[1,2,3], [4,5,6]] :: [] [] Int
10:26:46 <lambdabot>  error:
10:26:46 <lambdabot>      • Expecting one fewer argument to ‘[[]]’
10:26:46 <lambdabot>        Expected kind ‘* -> *’, but ‘[[]]’ has kind ‘*’
10:26:48 <glguy> Compose [] [] :: * -> *
10:26:54 <monochrom> too bad
10:27:19 <monochrom> Oh, right, [] ([] Int), so you need Compose
10:28:13 <hackrilege> @where Compose
10:28:13 <lambdabot> http://mainisusuallyafunction.blogspot.de/2010/10/typing-mathematical-characters-in-x.html
10:28:58 <monochrom> eh?!
10:29:18 <monochrom> oh haha that kind of Compose
10:29:36 <hackrilege> Oh it's in Data.Functor.Compose
10:29:42 <hackrilege> Thanks
10:30:13 <hackrilege> I thought there might be some built in sugar like type level (.) Or something
10:31:16 <glguy> Nope, general type-level programming isn't supported
10:31:45 <hackrilege> No hope of promoting (.)?
10:33:16 <geekosaur> functions can't be promoted
10:35:28 <mbw> Is there actually a haskell algebra package that comes with a modicum of documentation on how to actually use it?
10:35:33 <hackrilege> Also, I can't seem to define a type synonym instance e.g. type A a= (A a,a); instance Functor A where....
10:36:12 <glguy> type makes a synonym for an existing type, it doesn't define a "new" distinct type that can have instances
10:36:56 <glguy> newtype and data create the distinct types that can have their own instances
10:37:05 <Zemyla> mbw: Yeah. You'd need to go data A a = A a a; instance Functor A where { fmap f (A a b) = A (f a) (f b); a <$ _ = A a a }
10:37:23 <mbw> For my purposes (read: not a phd in maths), numerical prelude, the packages by edward kmett etc. are undocumented in that regard.
10:37:31 <hackrilege> And the solution with Compose throws errors can't match Compose [] [] a with [[a]]
10:37:59 <glguy> hackrilege: Yes, it's a distinct type, you can use Compose :: [[a]] -> Compose [] [] a
10:38:04 <mbw> There is HaskellForMaths, which the author wrote a lot about on his blog. But most if it is concerned with the library design.
10:38:10 <hackrilege> I was using a tuple and refactoring is going to be nasty
10:39:25 <hackrilege> I don't really want to add a wrapper to [[a]] it's used all over my code...
10:40:05 <hackrilege> But I guess without it it would use the Functor instance of [], super annoying
10:40:39 <mbw> Zemyla: Was your message actually directed at me?
10:40:45 <hackrilege> I guess I'll just stick to using (map.map)
10:40:53 <Zemyla> Yeah, it was.
10:41:31 <mbw> How does going data A a = A a a etc. help in my situation?
10:41:45 <hackrilege> mbw, which functions are you after? Something like matlab linear algebra?
10:41:49 <Zemyla> mbw: What was the type you originally wanted?
10:42:07 <hackrilege> mbw, that comment was directed at me
10:42:36 <hackrilege> I was asking about type synonym instances
10:43:58 <mbw> I was looking for an abstract algebra for educational purposes. So that for instance if I wrote "fun x y = x + y" GHC could infer a type signature with a semiring or something like that.
10:44:24 <YellowOnion> Anyone know of any libraries or techniques for making repls in haskell?
10:44:26 <mbw> Well it's probably not a semiring, but hopefully I got the point across.
10:45:09 <hackrilege> :t \ a b -> a + b
10:45:11 <lambdabot> Num a => a -> a -> a
10:45:27 <hackrilege> Num defines a ring
10:46:23 <hackrilege> :t \ a b -> mappend a b
10:46:24 <lambdabot> Monoid a => a -> a -> a
10:47:22 <Zemyla> YellowOnion: There's not really a special technique.
10:47:24 <hackrilege> Monoid defines the thing you are incorrectly calling a semiring
10:48:13 <osa1> I was hoping to write a typeclass for some database functions to be able to mock DB operations. the DB implementation uses persistent and we use primary key functions (`replace` etc.) but `BackendKey SqlBackend` is not exposed in `persistent`, so I'm not sure what kind of typeclass method to use here. did anyone do something like this before?
10:48:46 <hackrilege> Monoid is like a semigroup
10:49:00 <hackrilege> Does that help mbr?
10:49:12 <Zemyla> It'd be something along the lines of "let go currState = do { inp <- readInput; (res, nextState) <- eval inp currState; case res of { Exit -> return (); _ -> print res >> go nextState } }"
10:52:02 <monochrom> I wonder if instead of (Result, State) you should have Maybe State.
10:52:10 <hackrilege> Oh I don't think semigroups necessarily have identities...
10:52:19 <ph88> when i use overloadedstrings to work with Text  how can i still make the difference between a string literal and a char literal in my source code? 
10:52:30 <mbw> hackrilege: I was looking for something similar to the numeric prelude, i.e. a little more rigorous than the numeric typeclass hierarchy that comes with the prelude. I would also be interested in vector spaces.
10:52:54 <monochrom> 'x' is always a char literal
10:53:14 <mbw> And while a lot of (probably pretty good) packages like that exist, only the API seems to be documented, i.e. I am missing an "entry point" on how to actually start exploring.
10:53:33 <hackrilege> mbw, why do you think prelude isn't rigourous?
10:53:39 <YellowOnion> Zemyla, I noticed there's a library called repline, and perhaps using some sort of monad like, prompt, or free
10:56:12 <mbw> Well, for one there's the usual critique, for instance found here https://prime.haskell.org/wiki/NumericClasses
10:56:15 <hackrilege> Ok I found a discussion of that in numeric prelude, but what I mean is, what problem are you having?
10:56:31 <hackrilege> Why isn't the standard prelude good enough for you use?
10:57:18 <mbw> It is perfectly fine for application development. I was merely hoping for something more fine grained algebraic structures for educational purposes.
10:58:17 <hackrilege> What's wrong with numeric prelude?
10:59:14 <hackrilege> I guess it's a bit big and clumsy...
11:00:15 <hackrilege> Hmm, kind of interesting. I guess in absence of one you like you could write it out the way you like it
11:00:47 <hackrilege> I dont know any to suggest sorry
11:01:03 <mbw> Numeric Prelude seems good. But I am overwhelmed with how much it has to offer.
11:01:03 <geekosaur> https://wiki.haskell.org/Mathematical_prelude_discussion
11:01:40 <mbw> Also, ghc infers weird types involfing GHC.Prim.Any etc. and I don't know how to work with it, i.e. which modules to include.
11:01:57 <mbw> I can't build the examples, because a dependency (HTam) is missing on hackage.
11:02:22 <zipper> Is there a specific reason decode from Aeson wants a lazy bytestring?
11:02:51 <mbw> Or at least that's what I presume the problem is, maybe I'm just doing something wrong.
11:04:17 <hackrilege> I really like the classes of Prelude, I guess my argument would be that I can use the existing types in teaching at a low level, and at the point where the failings presented become apparent, the student has essentially completed the course
11:06:02 <hackrilege> I guess if your designing an axiomatic algebra course deriving it from a Haskell library it's kind of backwards
11:06:58 <hackrilege> But if you find out develop one id be happy to teach from it!
11:08:40 <pikajude> what datastructure should I use for a fixed-size queue where when I push an item onto it the last item is automatically dropped?
11:11:18 <geekosaur> mbw, http://code.haskell.org/~thielema/htam/ no promises
11:11:22 <HKei> pikajude: Sounds like a job for http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Sequence.html to me, though I guess there could be something more specifically useful for queues
11:12:04 <HKei> pikajude: Ohps, outdated docs, I meant http://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Sequence.html
11:13:27 <ph88> anyone have an idea how to abstract this? https://paste.fedoraproject.org/527194/14844211/  i have to do this for many lines and it's really repetitive. One is an Arbitrary generator for quickcheck and the other is a Parser for megaparsec
11:14:43 <HKei> ph88: what are the variable parts?
11:15:10 <c_wraith> ph88: you could do it, but, uh...  it would be basically just as verbose
11:15:36 <ph88> HKei, what do you mean variable parts ?
11:15:42 <ph88> c_wraith, what do you have in mind ?
11:17:45 <c_wraith> ph88: generate t c g = do { g <- t "generic" ; ... }
11:18:11 <c_wraith> ph88: then you need to make the type checker happy, which might require rank-2 types or constraint kinds and a type proxy argument...
11:18:27 <domenkozar> tomjagua1paw: hey
11:18:36 <domenkozar> tomjagua1paw: do you know what's the status of https://github.com/tomjaguarpaw/product-profunctors/tree/fieldnames
11:19:09 <ph88> c_wraith, eh sounds like that would be a bit over my head right now ^^
11:20:05 <c_wraith> ph88: well, if you write the implementation and then ask about any type errors you get, we could help further.  I'm not set up to actually do it myself, but I'm good at deciphering the compiler's complaint.
11:21:05 <glguy> ph88: You can make a typeclass with the operations that are common to the two
11:21:13 <glguy> and then write your operation in terms of that class
11:21:27 <ph88> c_wraith, alright alright .. i will look at it later though because i'm making good progress at the moment
11:21:52 <ph88> glguy, line 5 and line 15 are different though ^^
11:22:21 <glguy> ph88: that's ok
11:22:37 <mbw> geekosaur: Thanks, I shall have a look at it.
11:23:06 <s4ke> hi guys. does anyone have some experience with using Frege?
11:23:50 <mbw> hackrilege: I am not a teacher, I am currently studying the topic my self on an autodidactic basis and was hoping to make use of existing libraries, since some claim to have been written for that purpose.
11:24:13 <lpaste> glguy pasted “for ph88 - something like this” at http://lpaste.net/351238
11:24:39 <glguy> ph88^: I didn't typecheck that because I don't have the imports handy or a GenericClause, but you can do something like that
11:27:08 <ph88> glguy, ah yes i was actually considering making all my parser functions as a part of type class .. but i haven't so far ^^
11:27:14 <ph88> thanks though i will keep it
11:27:21 <ph88> look at it later
12:05:38 <ph88> anyone know how i can generate a Maybe with quickcheck ?  so randomly Nothing or Just a   ?
12:07:55 <bengt_> ph88: use uh, frequency [(1, Maybe <$> arbitrary), (1, Nothing) -ish
12:08:20 <bengt_> if there isn't an arbitrary instance for maybe already
12:10:36 <ph88> uf that's ugly ^^
12:10:41 <bengt_> derp, Just not Maybe
12:10:52 <kadoban> bengt_: I do that far too often myself xD
12:13:05 <warmblue> What kind of a mathematical object is a typeclass?
12:13:19 <ph88> pure Nothing <-- this is just hilarious
12:14:00 <bengt_> :P
12:14:34 <geekosaur> it isn't. it's syntactic sugar for a record of functions
12:18:55 <bengt_> ph88: there probably is a better way to do it :p
12:18:55 <geekosaur> and an ad hoc solution to the problem of integral and floating point math operations being different (e.g. SML had separate + and .+ operations for integral and floating addition back when Haskell was defined, and typeclasses were intended to make that go away). there was no mathematical justification for it
12:20:42 <nshepperd> good thing they turned out to be so useful
12:23:09 <warmblue> geekosaur: anywhere I can read about how exactly they're desugared?
12:25:21 <nshepperd> warmblue: I tend to think of a typeclass instance as a 'canonical' set of functions for a type, and the typeclass constraint as being a predicate that asserts that such canonical functions exist for that type
12:26:12 <c_wraith> geekosaur: you wouldn't call a type class constraint a proof requirement, and the class itself the proof?  Hmm, come to think of it, that's just Curry-Howard again.  I suppose it's not so interesting.
12:26:23 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellli3.html#x51-34700042.3 has two relevant references ([8] and [13]; Gofer's constructor classes became Haskell's typeclasses)
12:26:24 <nshepperd> but yeah basically underneath the syntax I think a typeclass is pretty much just an ordinary record type, and an instance is just a value of that type
12:26:53 <warmblue> honestly, I was hoping for some precise cateogry theoretic analogue I could read up on.
12:27:08 <nshepperd> 'foo :: Num a => a -> a'  ~=  'foo :: Dict (Num a) -> a -> a'
12:27:17 <c_wraith> Or maybe instead of "not so interesting", it's more like "another proof that Curry-Howard isn't just incidental"
12:28:37 <shayan_> Are monads a core concept in the Haskell programming language?
12:29:02 <c_wraith> Only in the same way Iterators are a core concept in Java
12:29:05 <kadoban> They're more of a pattern that comes up everywhere (and can be/has been encoded using the language)
12:29:18 <kadoban> Ya, that sounds like a nice analogy.
12:29:21 <Zekka> you should probably know how they work because a lot of your code will use them
12:29:22 <c_wraith> They are useful and have some syntactic sugar.  Same as Iterator in Java.
12:29:54 <nshepperd> c_wraith: it's somewhat interesting, because a good reason to require type class coherency, is so that you really can just treat a constraint like 'Monoid a => ' as a predicate, or a proof requirement
12:30:05 <Zekka> you probably don't have to understand them that well if you're new, because the only monad type you're likely to need right now is IO
12:30:08 <nshepperd> and not have to care what proof you get given
12:30:21 <geekosaur> warmblue, in fact there's no guarantee the dictionaries exist: whole-program compilers may be able to resolve all typeclass instances at compile time. and implementation is left up to compiler writers; records of functions are just the most obvious way (and more or less directly supported by the standard's typeclass / instance declarations, although they don't require it)
12:30:34 <Zekka> so if you just memorize how to get a few things done with IO then you probably don't need to get too involved
12:30:40 <Zekka> (above at shayan_)
12:30:54 <geekosaur> shayan_, I would say they are not core because Haskell existed before it had Monad
12:31:08 <c_wraith> geekosaur: even whole-program compilers sometimes need some runtime...  residue, I suppose...  of type classes in the case of polymorphic recursion.
12:31:14 <geekosaur> (which led to the klunky main :: [Response] -> [Request])
12:31:37 <geekosaur> c_wraith, yes, "may be able"
12:31:53 <glguy> we could have the current IO implementation without a Monad class
12:32:06 <c_wraith> we could have do-notation for IO without a Monad class.
12:32:19 <c_wraith> It just wouldn't exist for anything else.
12:32:23 <Zekka> shayan_: imho, if you are new, write a bunch of programs using very simple types and then figure out if there are any repeating patterns that annoy you. 
12:32:34 <nshepperd> we could, but that would be lame
12:32:38 <Zekka> then see if you can think of a way to abstract around them. (if not, ask a question about them here)
12:33:38 <shayan_> Zekka: sounds good. i’m following Programming in Haskell right now, which will soon cover the subject. i was quite curious and wanted to get a little tease of its importance, as it seems a topic where a lot of people find confusion around
12:33:55 <geekosaur> a lot of people overthink monads
12:34:04 <Zekka> yeah. maybe I should be a little clearer. capital-M "Monad" is a pattern that a lot of types can fall into
12:34:06 <c_wraith> shayan_: it's fantastically hard to grasp at first, because it's a different level of abstraction than most people have experience with.
12:34:20 <Zekka> IO is an example of a type that falls into that pattern, but you don't necessarily need to know the whole pattern just to use IO
12:34:29 <geekosaur> yes, their inspiration was from category theory. no, you do not need to know any category theory to use them, or even to make your own
12:34:49 <c_wraith> shayan_: but once you get used to Haskell's abstraction capacity, you discover Monad is actually pretty simple of a concept - it's just *really foreign* at first.
12:35:03 <Zekka> there are a lot of patterns that have weird words like Monad and Functor assigned to them, but Monad is special because Haskell has some syntax just for dealing with it
12:35:05 <geekosaur> it's just a pattern defined by two operations "pure" and "bind", with some simple laws relating them
12:35:54 <Zekka> Java example: you don't need to know Iterable to use List, even though a List is Iterable
12:37:59 <shayan_> I was thinking to myself the otherday that mathematics is responsible for everything. From the creation of humans, dna structure, and anything that can be thought of. Searching for books on monads, I just came across this review: “Ontological Mathematicians, on the other hand, know mathematics to be the quintessence of life, mind, and everything, in other words, Ontological Mathematicians know that mathematics invented humans. To an 
12:38:00 <shayan_> Ontological Mathematician, mathematics is, quite literally, all that there is.”
12:38:02 <shayan_> this is truly fascinating
12:38:18 <Zekka> how do they know that?
12:38:54 <c_wraith> I think it's almost tautological.
12:39:14 <Zekka> usually when I use math words about something, the thing already exists
12:39:14 <geekosaur> shayan_, that's one approach. the other is that mathematics is a set of flexible tools, and while many of those tools can be applied to the real world, none of them define it
12:39:20 <Zekka> and it would probably exist whether I did math about it or not
12:39:33 <geekosaur> (physicists tend to prefer that one, especially after getting burned by overly trusting the math :p )
12:39:34 <c_wraith> Math is our study of abstraction - our innate pattern-matching refined and made (sometimes) rigorous.  It's hardly surprising that our study of patterns is good at describing patterns.
12:40:13 <Zekka> (disclaimer: I am not a mathematician, I usually only use math words to talk about things computers do)
12:42:18 <shayan_> Zekka: they might know that through extrapolation? using locally-tested law and applying them over some larger scale on which we cannot directly test it — thus we extend it? if that makes any sense
12:42:48 <Zekka> what tells them they can extrapolate it, though?
12:43:40 <shayan_> an example would be Newton understanding gravity after observing the behavior of an apple falling from a tree. He then used that observation and extrapolated the law to define universal gravity
12:44:34 <shayan_> Zekka: local tests that provide true test results, which further increases the chances of probability and assumption that something similar in concept (?) can also be true?
12:44:58 <Zekka> yeah, I think humans are good at that
12:45:03 <c_wraith> shayan_: You can make an argument that it's fascinating that nature happens to be so amenable to abstraction.  In fact, there's a rather famous paper that did.  https://www.dartmouth.edu/~matc/MathDrama/reading/Wigner.html
12:45:33 <Zekka> there's probably not a pure math justification. the creatures who did that didn't die. there are a lot of other knowledge-getting strategies that would probably make you die if you did them
12:45:37 <c_wraith> shayan_: But there's a big difference between going "that's amazing when you think about it" and "this must have fundamental meaning"
12:45:52 <Zekka> if my knowledge getting strategy was "i believe any statement with an even number of words" I would probably die
12:46:48 <shayan_> all of this only should mean we are getting closer to the truth, but doesn’t garuantee that we have arrived at the truth. 
12:46:55 <glguy> Zekka: but if it was "I believe any statement with even numbers of words", you'd be OK
12:47:03 <hexagoxel> Zekka: but you would not believe that you would :)
12:47:28 <shayan_> c_wraith: but can something truly be amazing without real underlying substance?
12:47:30 <Zekka> glguy: i think my head would blow up!
12:47:58 <glguy> Zekka: yikes, that'd surely kill you, and you'd die anyway
12:48:03 <shayan_> xD
12:48:28 <DirtyAxe> hey
12:48:35 <Zekka> shayan_: well, if I believed the moon was made of green cheese, i might think that was an amazing coincidence, but it wouldn't be true
12:48:43 <c_wraith> shayan_: Sure.  One is phenomenological, the other is metaphysical.  My approach to life is to leave metaphysics out if they're not needed.
12:49:14 <DirtyAxe> So how good of a language is haskell ?
12:49:18 <warmblue> wow, I did not think of typeclasses that way, Wadler's 'less ad-hoc polymorhism' paper is amazing, even with all the hindsight.
12:49:24 <Zekka> DirtyAxe: i think it's pretty good!
12:49:24 <DirtyAxe> I have been thinking of learning it
12:49:32 <Zekka> what are you planning on doing with it?
12:49:58 <DirtyAxe> Don't know
12:50:02 <DirtyAxe> What can i do with it ?
12:50:02 <shayan_> Zekka: well you could not truly believe that to begin with, so that cannot be a valid case example
12:50:13 <Zekka> fwiw @shayan_: i think the feeling that something is amazing comes from things a brain does, and i'm not sure what a brain would know about true and false
12:50:46 <Zekka> i think brains do things because when they did those things, the creatures that had those brains didn't die, but that doesn't mean those things have to do with true and false
12:50:46 <c_wraith> DirtyAxe: I think it's the least-bad language I've ever used for making real software. :)
12:51:11 <Zekka> Haskell is pretty useful for general purpose programming
12:51:23 <DirtyAxe> @c_wraith i heard it was used mainly in math and such , is it ?
12:51:23 <lambdabot> Unknown command, try @list
12:51:30 * geekosaur reminded of an illustration in GEB of a brain filled with tiny valid equations forming a large "2 + 2 = 5" :p
12:51:52 <Zekka> I think it's particularly good for really small programs and really big programs -- I burned myself out on it because if your program does anything complicated with state management, you have to think about that in advance
12:51:54 <glguy> (The @ is for bot commands, not addressing people)
12:51:55 <c_wraith> DirtyAxe: it's actually pretty bad for doing pure math, since it's an inconsistent logic.
12:51:59 <hexagoxel> haskell is also okish for describing cooking recipes! but sure, you can do programming too.
12:52:12 <shayan_> c_wraith: but isn’t metaphysics the basis of phenomenology 
12:52:22 <c_wraith> DirtyAxe: It turns out to be fantastic for developing software, though.
12:52:36 <Zekka> in the ~400loc range I often found myself doing extra math that I only ended up using once,
12:52:57 <hexagoxel> but you need a garbage-collecting kitchen runtime.
12:52:58 <c_wraith> DirtyAxe: software is unconcerned with the capacity for the occasional infinite loop.  Math fails entirely if you can get into an infinite loop.  Something about being a paradox.
12:53:43 <Zekka> example: one of the ways to map haskell to logic says that a type is a logic proposition
12:53:48 <Zekka> :t let a = a in a
12:53:49 <lambdabot> t
12:54:18 <Zekka> if you use that rule to turn haskell into logic, then you can prove anything by using a nonterminating program like the above
12:54:32 <DirtyAxe> Can you give an example of some big software made using haskell ?
12:55:19 <dls> DirtyAxe: GHC? :p
12:55:21 <Zekka> (i used to know some examples but I'm not qualified to throw any out right now)
12:55:25 <c_wraith> DirtyAxe: Haskell gets the reputation of being mathematical because Haskell supports enough abstraction to pull in more mathematical concepts than most language, and a core agenda that's happy to sift through math theory to look for practically useful bits, even if it's surprising that they're useful.
12:55:44 <DirtyAxe> hehe
12:55:56 <Zekka> haskell's standard library doesn't pull in that many math things unless they're useful for programming too
12:56:39 <Zekka> although for some programs I think it would be a little more straightforward (and involve less math) if you started with different builtins from what haskell has
12:56:47 <c_wraith> DirtyAxe: for instance, mathematicians have called Category Theory "generalized abstract nonsense" because it often looked too non-practical for even math.  Then some people discovered that a few concepts from it turned out to be really practical for programming.
12:57:01 <DirtyAxe> Know it's a noob question but how do you address a specific user ? :P
12:57:13 <Zekka> DirtyAxe: on IRC you typically just type the user's name
12:57:21 <DirtyAxe> Zekka thanks :P
12:57:23 <Zekka> that will cause an ordinary IRC client to flash or beep
12:57:54 <Zekka> (for instance, your last message looks like this for me: http://i.imgur.com/aWPfPo0.png )
12:57:56 <kadoban> DirtyAxe: In most clients you can type a couple of characters of the user's name and hit <tab>
12:58:03 <shayan_> DirtyAxe: You can write the first few letters of that user’s name, then hit the TAB key on your keyboard to fill the remainder of their name — much easier.
12:58:43 <c_wraith> DirtyAxe: It doesn't mean you need to know the math to use the concepts, though.  It's just their origin.  You don't need to know number theory to use public-key cryptography, either. :)
12:59:18 <geekosaur> DirtyAxe, the canonical examples are pandoc, git-annex, and xmonad; some throw in yesod
12:59:34 <wennefer0> DirtyAxe pandoc might be an example of a relatively big system in Haskell (file conversion software)
12:59:38 <Zekka> (^good picks! although I think dirtyaxe has vanished for right now)
13:01:41 <shayan_> Computation derives primarily from mathematics. Programming is all computing algorithms, no matter the language in discussion i.e. Java, Haskell, etc. To build great software, you’re going to need a good understanding of algorithms and data structures; they are the tools that ultimately solve the problems you are after. 
13:01:46 <shayan_> he left the channel!
13:02:30 <pikajude> fare thee well
13:03:36 <Zekka> shayan_: deffo imho, but I think a lot of the things programmers want to do are easier than the things pure mathematicians want
13:03:57 <Zekka> (i don't have a rigorous argument for this, I'm just much better at understanding programmers whne they say "here is what I want" than I am at understanding mathematicians when they say that)
13:05:57 <Boomerang> Random question: What is more correct "combinational logic" or "combinatorial logic"?
13:06:16 <shayan_> Zekka: definitely — i think it all depends on what you are trying to solve. but at the basis of anything that is being solved, relies upon an algorithm. that is a fundamental truth that cannot be abbandoned. 
13:07:53 <Zekka> i think it depends on what you mean algorithm -- usually a program comes down to "I want these entities to do this list of things," even if you use different words or abstractions, because for the user to see effects, entities need to do things
13:08:11 <Zekka> i would say "this entity needs to do this list of things" is pretty close to what people mean when they talk about an algorithm
13:08:21 <Zekka> i think mathematicians don't hold themselves to that, because math doesn't need to be implemented on something
13:12:43 <Boomerang> Any recommendations where I should ask about "combinational" vs "combinatorial"? It's for a paper.
13:12:59 <Alxandr> Hi. I have some questions about stack and building + deploying. Is this the right place to ask?
13:13:07 <Zekka> Boomerang: I am not a mathematician but i think "combinatorial" is correct
13:13:22 <Zekka> because I think it comes from the word "combinator," which is the word used for items like "S" and "K"
13:15:47 <Boomerang> That makes sense, thanks. I think "combination" also makes sense as a combination of logic gates (and, or, xor). I think I've seen both around but since I'm writing in the context of Haskell programming I thought I'd ask here if there's a preferred name.
13:16:22 <mfukar> Boomerang, combinatorial refers to the discrete mathematics concept of combinations, combinational refers to a subset of digital logic (time-independent logic))
13:17:55 <Boomerang> Ah thank you mfukar! In this case combinational is better for me since I'm using Haskell to describe digital circuits :)
13:18:19 <mfukar> Yup, sounds reasonable
13:18:36 <Zekka> thank goodness a right answer sprung out of the woodwork after my wrong answer!
13:18:44 <Zekka> i will have to be more flagrantly incorrect in the future
13:19:00 <geekosaur> isn't there some kind of internet law about that?
13:19:20 <geekosaur> (the fastest way to get the correct answer to a question is to give an incorrect answer?)
13:19:30 <Zekka> I think perlmonks advised me of that!
13:19:32 <Boomerang> To be fair they're both pretty close and I wouldn't feel to bad about picking the wrong one
13:19:46 <Boomerang> *too
13:22:29 <alakvx> i know this isnt a js lobby but god damn
13:22:31 <alakvx> https://jsbin.com/zokigawago/edit?js
13:22:50 <alakvx> can anyone tell me why im stupid
13:24:44 <bengt_> its a blank page?
13:25:32 <glguy> you're right, it's not a js channel
13:25:46 <alakvx> woops
13:25:47 <alakvx> http://lpaste.net/351243
13:26:10 <alakvx> sorry the js fp community is rather small
13:27:57 <glguy> alakvx: sorry about the small js community, but it's off topic here
13:28:51 <alakvx> im attempting to compose a json parser with maybe for safe xhr
13:29:02 <alakvx> is it really that off topic?
13:29:20 <glguy> Is it Haskell?
13:29:30 <c_wraith> If the reason it's failing is because javascript is different from haskell, then yes.
13:30:40 <lpaste> shayan_ pasted “factorial 10” at http://lpaste.net/351245
13:30:42 <shayan_> after loading that script into ghci, when i try to run “factorial 10” in ghci, i get an error: http://imgur.com/a/yzzmO
13:31:15 <glguy> shayan_: Looks like you need to load your source fiel
13:31:17 <glguy> file*
13:31:33 <glguy> You can use :l TheModule.hs
13:32:13 <alakvx> forgive me i had word this was lobby filled with helpful kind fp friends
13:33:01 <shayan_> glguy: but i have already loaded the source file
13:33:43 <glguy> shayan_: OK, you'll need to reload it
13:33:53 <shayan_> :reload is not working
13:34:13 <glguy> Yeah, it's not loaded yet
13:34:14 <shayan_> well, it is, but 
13:34:22 <glguy> :reload will reload after you've loaded it
13:34:53 <glguy> It's possible that you used another command like :m to change which modules are in scope
13:34:57 <shayan_> okay it seems that there is a syntax error on ‘div’
13:35:05 <glguy> or that there was an error in your module, so it never loaded
13:35:11 <shayan_> glguy: the latter, for sure
13:35:11 <c_wraith> shayan_: you want `, not '
13:35:18 <shayan_> c_wraith: ah!
13:35:44 <shayan_> thanks, works!
13:36:23 <c_wraith> shayan_: converting a prefix function to infix uses backticks.  single quotes have several different uses, but in that case is was trying to parse it as an illegal character literal. :)
13:39:31 <shayan_> c_wraith: rereading the section, the author mentions the backticks. i was not paying attention.. thanks again
13:40:46 <c_wraith> shayan_: no worries.  I actually find that to be an especially awkward part of haskell's syntax.  It'll never surprise me when it trips someone up. :)
14:29:22 <grimr> hey, I'm getting a very strange error in my tests: https://ptpb.pw/02dX, here's Spec.hs: https://ptpb.pw/9JAW/haskell and getVx has type Registers -> Int -> Word8. ANy ideas ?
14:31:11 <glguy> grimr: Try indenting your $ to the right
14:31:54 <glguy> and then you'll probably need mapM_ instead of mapM
14:33:29 <grimr> thanks glguy, mapM_ did the trick !
14:34:35 <grimr> from what I understand, it's because mapM returns m [b] whereas mapM_ returns m () which is something that only has side-effects, right ?
14:36:00 <atomictom> Hi! I have a question on stack that I've been having some trouble figuring out...
14:36:04 <atomictom> (or maybe cabal)
14:36:16 <Boomerang> @src mapM_
14:36:16 <lambdabot> mapM_ f as = sequence_ (map f as)
14:36:24 <atomictom> With stack/cabal, can you only define 1 library per cabal file / stack directory?
14:36:35 <Boomerang> I think it just throws away the result
14:37:53 <Boomerang> atomictom: Yes only one library but as many executables, tests and benchmarks as you want
14:38:53 <atomictom> Boomerang: Thanks! So each library would need its own stack directory / cabal file, correct?
14:39:58 <atomictom> And, I see that cabal has a feature to allow a test / binary to depend on the library being defined in the same file. But, if you do not have a library (e.g. just an executable), can you have tests for that?
14:41:36 <glguy> atomictom: No, but you can have the bulk of the executable be a library
14:41:50 <glguy> and then generate an executable from that library and also import it for the tests
14:42:39 <Boomerang> There are two ways your tests can use your library: the first one where you depend on the library lets you test the public API, the other where you import the files of you library which lets you test internal functions that aren't exposed to the public API
14:43:30 <glguy> Here's an example executable that's mostly a library https://github.com/glguy/irc-core/blob/v2/glirc.cabal
14:44:06 <atomictom> glguy, Boomerang: That makes sense. Is it common to combine both methods and have tests for both the public and private functions in one test file?
14:44:31 <atomictom> glguy: are you using glirc right now? :)
14:44:52 <atomictom> And thanks for the reference
14:45:43 <glguy> Yeah, I've been using it full time for over a year
14:46:20 <Boomerang> To test both public and private you just need access to the files, like this I think: hs-source-dirs: test, src
14:48:33 <zipper> I have a function that reads a file and parses it. I have two types of exceptions to catch.
14:48:41 <zipper> and IOError and a ParseError
14:48:53 <zipper> The IOError would occur before the parseError
14:49:56 <zipper> Issue is that when I catch the IOError and print a message I can't think of a way to stop the program from halting and then trying to parse and showing yet more text
14:50:27 <zipper> I mean an IOError always leads to a parseError
14:50:37 <zipper> Maybe I should show the code, one sec.
14:50:58 <grimr> erm, what's the name of the exception array indexing can throw ? i need it for hspec and Ix.index (what ghci says when I try triggering that exception) isn't recognized
14:51:35 <zipper> http://lpaste.net/602295173862391808
14:53:13 <atomictom> glguy: that's cool! :D
14:54:01 <glguy> grimr: It just throws a generic "ErrorCall" exception
14:55:06 <atomictom> So, something I didn't think about before is...you can export as many modules as you want per "library". So, I guess a "library" is more of a package than a single interface, right?
14:55:31 <glguy> try (evaluate (listArray (0,0) [()] ! 10)) :: IO (Either ErrorCall ())
14:55:32 <glguy> Left Ix{Integer}.index: Index (10) out of range ((0,0))
14:56:43 <grimr> ok, so I should use anyException ?
14:57:39 <lpaste> glguy pasted “how to figure out the exception type for grimr” at http://lpaste.net/351250
14:58:27 <glguy> grimr: I don't know, I don't use hspec, but http://hackage.haskell.org/package/hspec-2.3.2/docs/doc-index-A.html shows that there is a definition "anyErrorCall"
14:58:30 <glguy> so that's probably better
15:01:54 <zipper> Do you guys use fail in your code where you want to just halt and exit because something was not provided?
15:02:19 <davean> zipper: nah
15:02:34 <davean> its really easy to throw a proper error
15:02:48 <zipper> With error?
15:02:54 <zipper> `error`?
15:02:55 <davean> even that is better, yes
15:02:59 <zipper> System.Exit?
15:03:01 <zipper> Which?
15:03:07 <zipper> So torn
15:03:11 <davean> none of those
15:03:23 <davean> er a proper exception
15:03:43 <davean> Control.Exception
15:05:22 <davean> I mean, fail and error aren't that different
15:05:36 <davean> If you're in a monad though you might as well ahve some structure
15:05:49 <grimr> thanks glguy :)
15:06:11 <davean> Also, I don't assume Monad will keeping having fail - it would be nice to move that to MonadFail 
15:06:11 <glguy> The biggest difference is that seq on (fail str) won't throw the error
15:31:54 <Conjecture> Haskell variables are basically immutable with the exception of indexes, correct?
15:32:42 <Rembane> Conjecture: All are immutable.
15:33:00 <jmorris> is there a better way to write this function? http://lpaste.net/351251
15:33:06 <Rembane> Conjecture: Except for when they explicitly tell you that they are not.
15:33:17 <Conjecture> Thanks
15:33:29 <Rembane> jmorris: Have you seen all in Data.List?
15:33:43 <jmorris> no
15:33:46 <Rembane> :t all
15:33:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
15:33:52 <Rembane> Hm...
15:33:54 <Rembane> :t and
15:33:56 <lambdabot> Foldable t => t Bool -> Bool
15:35:08 <Rembane> jmorris: isDivisible n = all (\x -> n `rem` x == 0) [20,19..11]
15:35:36 <jmorris> oh, thanks Rembane 
15:35:41 <Rembane> jmorris: No worries.
15:35:47 <Rembane> > [20,19..11]
15:35:50 <lambdabot>  [20,19,18,17,16,15,14,13,12,11]
15:38:39 <davean> Rembane: do you mean MutVar#?
15:39:03 <Rembane> davean: I was thinking of the mutable versions of Vector.
15:39:05 <davean> I can't think of anything non-primative that is mutable and primative isn't really Haskell
15:39:38 <davean> Rembane: ah, thats a tricky case depending on how you define "value" and "mutable" ;)
15:40:23 <Rembane> davean: Well, by waving my hands so much that I almost leave the ground. :)
15:41:21 * davean quitely exits hugging their MutVar#
15:43:00 <maerwald> variables are always immutable, there is only "shadowing"
15:43:07 <maerwald> everything else is value-level stuff
15:43:56 <Rembane> maerwald: Is shadowing happening in ghci too when you do: x = ...; x = ... ?
15:45:23 <Cale> Rembane: yes
15:45:33 <Rembane> Cale: Thank you.
15:46:04 <Cale> The old x still has its old value, you just can't refer to it by name anymore -- but if you had used x in building some other data structure, the new declaration won't affect that previous one.
15:46:32 <Rembane> That's nice.
15:46:58 <zipper> Looks like `fail` is ok for IO https://hackage.haskell.org/package/base-4.9.1.0/docs/System-IO-Error.html#v:userError
15:47:19 <zipper> " The fail method of the IO instance of the Monad class raises a userError, thus: fail s = ioError (userError s)"
15:48:00 <Cale> e.g. you can write something like let x = product [1..10000]  let p = x * x  let x = 0  and then check the value of p, and the product [1..10000] will be evaluated at that point.
15:48:50 <Cale> zipper: It's "ok"
15:49:17 <Cale> zipper: Though the inclusion of fail itself was kind of a mistake.
15:49:45 <zipper> Cale: What do you mean it was a mistake?
15:49:47 <zipper> How?
15:50:22 <Cale> Well, it's not really part of the mathematical description of what a monad is, obviously, and many of the monads we actually use don't really support it in a meaningful or useful way
15:50:51 <monochrom> Even in IO you should use something more specific than fail.
15:50:55 <Cale> So, it's just this awkward ugly addition to the Monad type class. For the most part, I try to pretend that it doesn't exist.
15:51:34 <geekosaur> the whole reason fail exists is to deal with pattern match failures in do syntax
15:51:46 <Cale> It's getting moved out into its own type class
15:51:50 <hpc> there's a MonadFail proposal in progress that moves it to a new class
15:51:54 <Cale> yeah
15:52:08 <dolio> It's not even that.
15:52:21 <dolio> It exists to deal with pattern matches that can't fail in do syntax.
15:52:45 <Cale> Er...
15:53:10 <dolio> In Haskell 1.4, patterns like (x,y) were known not to fail, so they could be given a Monad constraint.
15:53:29 <dolio> But they wanted to get rid of the specification of those patterns, but not lose the ability to say just Monad.
15:53:46 <Cale> Well, the Haskell 98 and 2010 reports use fail for all pattern matches on the left of a <- in do-syntax. GHC's translation isn't quite faithful to that though, and only invokes fail in cases where the pattern involves matching a constructor from a type that has more than one.
15:54:17 <Cale> Yeah, in Haskell 1.4, these were known as "failable" patterns
15:54:38 <jle`> zipper: fail for IO is ok, but fail for monad-polymorphic functions isn't; that's the difference
15:54:53 <Cale> which are a separate concept from "refutable" ones: (x,y) is not failable, but it's also not irrefutable.
15:55:05 <Eduard_Munteanu> I suppose irrefutable patterns changed that?
15:55:19 <Cale> In 1.4 they had both concepts
15:55:55 <Cale> Irrefutable patterns consist of matches against single variables, or patterns with ~ applied to them.
15:56:14 <Cale> (Operationally, these matches don't involve doing any evaluation)
15:56:45 <Cale> Whereas while (x,y) is not a failable pattern, matching against it involves ensuring that the scrutinee isn't _|_
15:57:01 <Cale> So it's not "irrefutable"
15:57:31 <Cale> You can write ~(x,y) instead, if you want it to be irrefutable, in which case the evaluation will happen when the value of x or y is demanded.
16:14:25 <mmachenry> Does anyone know why parseTest (ktoken "x" `sepBy` eol) "x\nx\n" returns a list of just one "x" in Megaparsec?
16:14:41 <mmachenry> I would expect that this expression would evaluate to ["x","x"]
16:16:33 <glguy> ktoken is probably eating the trailing white space
16:27:43 <glguy> mmachenry: also mega parsec doesn't appear to have a ktoken. did you define that?
16:30:24 <sm> I always find it inconvenient that newline is considered whitespace
16:31:33 * geekosaur generally expects it of programming languages. that said, it should probably be parameterizable somehow...
16:36:09 <monochrom> Consider a new surface syntax in which Unicode space characters have meanings and all other characters are whitespaces :)
16:36:38 <Cale> New version of whitespace
16:37:10 <Cale> https://en.wikipedia.org/wiki/Whitespace_(programming_language)
16:37:28 <Cale> Maybe the next version of Whitespace will have dependent types ;)
16:37:28 <monochrom> A base-5 number system in which the digits are tab, newline, latin space, nonbreak space, double-width CJK space
16:37:53 <xpika> is there a lens that set the first element of a list even if it
16:37:56 <monochrom> Oh haha "from the makers of Idris"
16:38:11 <xpika> ... is empty
16:38:21 <Welkin> "this summer, from the makers of idris, enter of world of categorical objects"
16:38:35 <monochrom> "space, the final frontier"
16:38:38 <Welkin> "on a journey through the monads"
16:40:41 <Cale> A nice thing about the original Whitespace is that it had unbounded Integer arithmetic (this was natural given that the interpreter was written in Haskell)
16:42:58 <dls> hey guys, kind of a newbie question. How can I tell which Applicative instance lift2 is using? I'm messing around with `(lift2 (,)) (*) (+)` and `lift2 (lift2 (,)) (*) (+)` at the moment
16:43:22 <monochrom> lift2? liftA2?
16:43:37 <dls> oh, sorry. it's from the NICTA course. maybe liftA2?
16:43:49 <monochrom> First ask lambdabot or ghci for types.
16:43:56 <monochrom> @type liftA2 (,) (*) (+)
16:43:58 <lambdabot> Num a => a -> (a -> a, a -> a)
16:44:02 <dls> lift2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:44:10 <monochrom> Then ask lambdabot or ghci for types, again.
16:44:21 <monochrom> @type liftA2 (,)
16:44:23 <lambdabot> Applicative f => f a -> f b -> f (a, b)
16:44:37 <dls> yeah, I just am having a hard time figuring out which Applicative instance is bound when I actually instantiate it
16:44:44 <monochrom> actually
16:44:48 <monochrom> @type liftA2 (,) undefined undefined
16:44:50 <lambdabot> Applicative f => f (a, b)
16:44:51 <dls> no issue finding the types... more an issue finding out which Applicative is used
16:45:01 <monochrom> Then perform unification.
16:45:17 <monochrom> Actually, rename type variables to deconfuse yourself, then perform unification.
16:45:35 <monochrom> Rename "f (a,b)" to "f (x, y)".
16:45:49 <dls> okay, that sounds like what I want. is there a command for unification?
16:45:50 <monochrom> So a->(a->a, a->a) = f (x,y)
16:46:17 <monochrom> Therefore f = (->) a, x = a->a, y = a->a
16:46:52 <monochrom> Short answer is no.
16:47:03 <dls> lol, okay. I'll keep trying by hand
16:47:14 <xpika> @type (+)
16:47:16 <lambdabot> Num a => a -> a -> a
16:47:28 <xpika> then take the first constructor
16:47:29 <monochrom> Long answer is every compiler that can do type inference contains an algorithm for unification, but they aren't going to expose this ability to you so easily.
16:47:57 <Gurkenglas> Why not expose the ability?
16:48:12 <monochrom> Yeah, great question, eh?
16:48:16 <dls> makes sense. there's something I'm still confused about with respect to typeclasses being automatically chosen for me... makes it harder to reason with very abstract code
16:48:19 <monochrom> Answer: "Patches welcome"
16:48:41 <dls> but I'm sure I can figure out how to figure that out by hand, was just hoping there was a command like :t or :info
16:49:22 <Gurkenglas> The patch here would be to turn the unification parts into a library and make ghc depend on it?
16:49:50 <monochrom> Actually, there is this new "type wildcard" feature that may help you
16:50:33 <monochrom> You enter "liftA2 (,) (*) (+) :: _ (_, _)" into ghci and see what happens. Maybe prefix with "@type" too
16:51:01 <Cale> :t
16:51:11 <monochrom> replace by lift2 if you're using the course's code
16:51:14 <Cale> The @type would be lambdabot :)
16:51:19 <Welkin> or :type
16:51:20 <Welkin> :D
16:51:22 <monochrom> err yeah :type
16:51:37 <monochrom> lambdabot has this feature too, but the output gets truncated
16:51:50 <dls> interesting, that does produce something new/different. thank you!
16:52:09 <Cale> It should tell you the types which fit into those holes
16:52:19 <Cale> (the types which it inferred)
16:53:44 <dls> ahh, sadly looks like you can't do `:t lift2 (,) (*) (+) :: Appliciative _ => _ -> _ -> _` thanks for the help, I'll get it eventually
16:55:28 <monochrom> you can also name the blanks, e.g., _whee, so that you don't get 3 indistinguishable _'s
16:56:09 <dls> wait, sorry, one more question. `lift2 (,)` has type `Applicative f => f a -> f b -> f (a, b)`... but then `lift2 (,) (*)` has type `Num a => (a -> b) -> a -> (a -> a, b)`... and yet Num doesn't seem to be an instance of Applicative... I guess that's what's confusing me
16:56:46 <monochrom> It's "Num a" and "Applicative (->) a", not "Applicative a".
16:56:55 <monochrom> err, Applicative ((->) a)
16:57:04 <dls> oh, okay. function is Applicative. thank you
16:57:09 <dls> that does indeed answer my question
16:59:06 <s4ke> hi
17:01:17 <monochrom> No, _whee doesn't seem to be a type wildcard, the error message says something else
17:04:41 <geekosaur> need the NamedWildCards extension
17:04:59 <monochrom> yeah, just found in the user guide
17:10:46 <xpika> > let setHead x xs = (x:drop 1 xs) in setHead 99 []
17:10:49 <lambdabot>  [99]
17:10:56 <xpika> > let setHead x xs = (x:drop 1 xs) in setHead 99 [1,2,3]
17:10:58 <lambdabot>  [99,2,3]
17:11:15 <xpika> has anyone seen a function like this before ? ^^ 
17:12:07 <Tuplanolla> > [1, 2, 3] & ix 0 .~ 99
17:12:08 <geekosaur> feels like trying to pretend to be imperative
17:12:10 <lambdabot>  [99,2,3]
17:12:15 <geekosaur> or maybe just reinventing lens on the cheap :p
17:12:30 <Tuplanolla> > [] & ix 0 .~ 99
17:12:33 <lambdabot>  []
17:12:35 <monochrom> lens pretends to be imperative, too
17:12:40 <Tuplanolla> Well, almost, xpika.
17:13:16 <ggVGc> monochrom: not sure I agree about that. It can be used to write code that pretends to be imperative though
17:13:26 <s4ke> did you guys try to use arrows for parallel processing before?
17:13:37 <ggVGc> but, a view of a lens over something isn't really imperative
17:13:41 <ggVGc> and a fairly common thing to do
17:13:53 <ggVGc> eh, mapping a view of a lens*
17:14:02 <s4ke> https://github.com/s4ke/Parrows (shameless plug, including a paper wip)
17:14:06 <monochrom> Although, first-class reference is a powerful idea.
17:14:13 <xpika> some algorithms can be inheritly more imperative than others
17:14:23 <Gurkenglas> A lens that can set the first element if it isnt there would also be expected to be able to remove it if it is there, but lists can't have holes in them
17:15:25 <monochrom> If you're doing AVL trees for example, you have a left-rotation and a right-rotation, the conventional coding has you write two mirror images of the same code, could you write just one version?
17:16:03 <monochrom> The answer is yes, write one version that takes a lens parameter. Pass in the "left lens" to get left-rotation, pass in the "right lens" to get right-rotation.
17:16:14 <Gurkenglas> And if removing would just shift the further-right elements to the left by one, then you'd expect setting to always displace the former list to the right
17:19:00 <Gurkenglas> And if removing would just shift the further-right elements to the left by one, then it turns out that you haven't made the first element go away, there's a first element left afterward right there
17:21:29 <BRS-Ryan> Hello this is Ryan from BulkReefSupply.com. If you look at a saltwater fish tank setup, you may notice there is no filter on the tank. That's because the filtration is primarily done by the live rock & sand, where the beneficial bacteria populate to break down the waste in the aquarium. Water Changes do the rest. Visit http://www.bulkreefsupply.com today for all your reefing needs, as at Bulk Reef Supply our mission is to make reefing fun & easy!
17:21:42 --- mode: ChanServ set +o monochrom
17:21:48 --- mode: monochrom set +b *!*@73.109.61.101
17:21:48 --- kick: BRS-Ryan was kicked by monochrom (BRS-Ryan)
17:22:18 <Rotaerk> do haskellers tend to like fish or something?
17:22:28 --- mode: monochrom set -b+b *!*@73.109.61.101 $a:BRS-Ryan
17:22:30 <Welkin> lol
17:22:40 <monochrom> Yes just look at the >=> operator
17:22:44 <Rotaerk> lol
17:22:49 <Welkin> I love fishing in Stardew Valley
17:23:19 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.98.225.64.228
17:23:26 --- mode: monochrom set -o monochrom
17:23:42 <MarcelineVQ> Hmm, I had figured there was no filter because saltwater annihilates them.
17:23:53 <Gurkenglas> You can't even make it a "Setter [a] a", because that'd look like "(a -> a) -> [a] -> [a]" and there need not be an initial a to pass to the "(a -> a)" part
17:24:07 <Gurkenglas> *Setter'
17:24:22 <monochrom> I don't understand prism, but supposedly prism addresses that.
17:25:44 <Gurkenglas> "Setter [a] (Maybe a)" falls prey to the same "put-hole-in-list-or-dont-actually-remove" problem
17:25:47 <Gurkenglas> *'
17:28:47 <Gurkenglas> Prism' s a allows us to express that the type s is the union of the the type a and something else, like Lens' does for product instead of union
17:29:04 <Gurkenglas> *disjoint union
17:33:27 <Gurkenglas> The Prism' that [] gives us arise from []'s data definition: "prism' (uncurry (:)) uncons :: Prism' [a] (a, [a])" and "nearly [] null :: Prism' [a] ()".
17:34:54 <xpika> is there a generic way to turn a lazy io stream into a strict one ?
17:35:11 <s4ke1> rnf :D?
17:35:19 <s4ke1> unqualified answer sry :D
17:37:14 <Gurkenglas> :t prism' (uncurry (:)) uncons . _1 -- These two compose into ix 0 because it does not know which [a] to combine with the given a
17:37:16 <lambdabot> Applicative f => (a -> f a) -> [a] -> f [a]
17:48:05 <Lokathor> so when might Stackage get to 8.0.2?
17:52:03 <MarcelineVQ> likely within 4 months, and sooner on nightly
18:03:47 <dls> hey anyone, newbie question: how do I read the type `((->) t (a -> b))` or more specifically, is there a site somewhere that might walk me through reading it correctly?
18:04:19 <jle`> dls: do you know how to read (*) 1 2 ?
18:04:28 <jle`> > (*) 3 4
18:04:31 <lambdabot>  12
18:04:36 <dls> yeah, trying to really get the details of the Applicative instance for functions
18:04:40 <jle`> (*) 3 4 is just '3 * 4'
18:04:46 <jle`> same for your case
18:04:47 <dls> and the wonky syntax of ((->) t) is throwing me
18:04:52 <dls> oh. huh
18:05:01 <jle`> (->) t (a -> b)   is just    t -> (a -> b)
18:05:02 <dls> what's the t there? I think it might be the return type
18:05:03 <dls> OH
18:05:04 <jle`> or t -> a -> b
18:05:09 <dls> god, it's just prefix'd then?
18:05:11 <jle`> yeah
18:05:23 <dls> man, thank you. I feel silly now :)
18:05:28 <jle`> no worries :)
18:05:39 <jle`> to be fair, most people don't encounter prefixed/infixed operators for types up until this point
18:05:51 <jle`> the only one you might plausibly see is (,)
18:05:58 <jle`> *only other one
18:06:22 <jle`> for, say, the Functor/Applicative/Monad instance for '(,) w'
18:06:41 <geekosaur> ((->) t) is partially applied (->), or t -> (not specified yet)
18:08:08 <jle`> btw, you can do the `` stuff at the type level, too -- you can write 'Either Int Bool' as 'Int `Either` Bool'
18:08:23 <jle`> (it might require a ghc extension)
18:08:29 <jle`> (but a relatively harmless one)
18:08:30 <geekosaur> prefix syntax works for -> but section syntax doesn't, so (t ->) isn't a legal section and we have to write it the other way
18:08:49 <geekosaur> no extension needed for that
18:08:59 <jle`> i tried it on ghci and it yelled at me :(
18:09:12 <geekosaur> huh
18:09:15 <jle`> it asked me to turn on TypeOperators
18:09:28 * geekosaur adds that to list of possibly insufficiently doc'd things
18:20:24 <MarcelineVQ> huh. I guess using them infix requires the extension    data Bleh = Int `Bleh` Char  is valid but   Bleh 3 :: Int `Bleh` Bool   isn't. however, it's not suggested this should be the case:  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#infix-tycons
18:20:58 <mounty> Is there anything like Database.Persist.Sql.toSqlKey that generalises the parameter type;  i.e., does not require the parameter to be an Int64?
18:21:08 <mounty> My table declaration has "Id Text NOT NULL" and I can't make a Key for it.
18:21:28 <mounty> I can't make the solution at http://stackoverflow.com/questions/41215452/yesod-querying-persist-database-with-a-custom-primary-key work in my case.
18:22:01 <MarcelineVQ> * Bleh 3 'c' :: Int `Bleh` Char isn't
18:27:37 <Gurkenglas> I'm thinking how to reduce the code duplication in main.hs -> routes (its two halves are practically the same) http://codereview.stackexchange.com/questions/152627/haskell-rest-api-postgresql-more-generic . One could define a function for routes to call twice that takes getUsersQuery, insertUsersQuery etc. as parameters. This is a function whose type you do not want to infer manually, letting ghci do it instead. 
18:27:37 <Gurkenglas> But he has places on the inside where he has to annotate with User/Team. If I had the type of the function to be extracted, I would have a scoped type variable I could annotate with. But until I have the type, I can't have that type be the only thing that's missing for compilation, so ghci can add it. What do?
18:31:38 <Gurkenglas> *refactors question* How do I fill in the "???"s? http://lpaste.net/351259
18:33:11 <autopawn> hello, haskell people, i have a question
18:33:42 <autopawn> I often have to use record syntax to apply a function over a data member, like this:
18:34:10 <autopawn> data {member = function (member data)}
18:34:13 <Gurkenglas> You want shinier syntax? Say hello to lens.
18:34:22 <autopawn> lens.?
18:34:37 <kadoban> autopawn: It's a package, very popular
18:34:39 <Gurkenglas> (\data -> data {member = function (member data)}) === member %~ function
18:35:10 <Gurkenglas> (You'll have to make the record definition lens-friendly for that to work)
18:35:28 <autopawn> it seems just what i was searching for
18:35:49 <autopawn> ok, I will take a look at it, thank you :D
18:36:18 <Gurkenglas> Ah, sending people to crash straight into the documentation brick wall x)
18:36:32 <autopawn> Gurkenglas++
18:36:40 <autopawn> xd
18:38:26 <Gurkenglas> You're not by any chance trying to code up a simple game that threads around some state, autopawn?
18:38:36 <autopawn> *sees the documentation* *understands what Gurkenglas meant with crashing with the wall*
18:39:09 <autopawn> ...
18:39:13 <autopawn> yes I am
18:39:23 <autopawn> how in the universe did you know it? ._.
18:40:10 <Gurkenglas> You'll also want state monads for more of the shiny. Here's an example by the edward himself https://github.com/ekmett/lens/blob/master/examples/Pong.hs
18:42:06 <autopawn> okay, it would be a better way to learn
18:42:14 <autopawn> :D thanks again
18:42:36 <Gurkenglas> Could you rephrase that? "<autopawn> okay, it would be a better way to learn"
18:43:29 <autopawn> oh, sorry, I am not a native english speaker, what a I mean is that learning from examples seems to be less difficult than reading the documentation, for this case.
18:44:16 <autopawn> I will soon know.
18:46:12 <autopawn> Gurkenglas: thank you very much for your advice.
19:21:41 <excelsiora> hi
19:21:43 <excelsiora> hi
19:21:54 <excelsiora> hi!!
19:22:16 <excelsiora> I'm still trying to get haskell to work with orgmode...
19:28:08 <Cale> excelsiora: hello!
19:28:14 <Cale> What's orgmode?
19:30:22 <excelsiora> Cale: hello!!!
19:38:36 <excelsiora> Cale: it's a magical mode for emacs that does everything. google it!
19:41:28 * markasoftware shudders at hearing the word "emacs"
19:41:58 <markasoftware> the world's most advanced operating system
19:44:30 <excelsiora> It strike fear in the hearts of the unworthy.
19:46:01 <markasoftware> meek vim users like myself
20:16:47 <jfelice> Is shadowing names with `let` not kosher in Haskell?
20:16:53 <jfelice> I'm having a very weird problem.
20:17:42 <geekosaur> it's fine although warned about with -Wall
20:17:55 <geekosaur> @paste
20:17:55 <lambdabot> Haskell pastebin: http://lpaste.net/
20:20:28 <jfelice> http://lpaste.net/351262
20:20:55 <geekosaur> ah
20:21:05 <geekosaur> you have uf on both sides of the =
20:21:15 <geekosaur> they're the *same* uf
20:21:32 <kadoban> jfelice: It can lead to confusion, sometimes. But ya that ^
20:21:38 <jfelice> hahahaa
20:22:23 <geekosaur> so it's futilely trying to find a fixpoint
20:23:56 <Lokathor> i want monad-random 0.5, but stack is failing to get it
20:24:06 <Lokathor> if only i knew how stack actually works
20:24:37 <geekosaur> if that version's not in your current resolver, you need to specify it as an extra package in your stack.yaml
20:25:00 <Lokathor> i did that
20:25:04 <Lokathor> and then it downloaded an index of some sort
20:25:09 <Lokathor> and then it said that it wasn't there
20:25:12 <Lokathor> but it's on hackage
20:25:49 <kadoban> Is it? I'm not seeing it
20:26:00 <geekosaur> oh
20:26:03 <geekosaur> it's MonadRandom
20:26:03 <Lokathor> https://hackage.haskell.org/package/MonadRandom
20:26:18 <kadoban> monad-random isn't the same thing as MonadRandom
20:26:29 <Lokathor> uhh, what?
20:26:42 <Lokathor> but i was using monad-random as well until i heard about the newest version
20:26:47 <Lokathor> are there really two packages?
20:27:00 <kadoban> Well ... I don't even see one with that name
20:27:02 <geekosaur> hackage doesn't have a "monad-random"
20:27:24 <kadoban> Were you getting it from elsewhere, maybe a git repo or something?
20:27:39 <Lokathor> hmmmmmm
20:27:42 <Lokathor> perhaps i'm dumb
20:28:01 <Lokathor> you're all right, i'm dumb
20:28:26 <kadoban> shit happens, it's confusing dealing with the different package name formats
20:28:43 <geekosaur> not that surprising actually, I'm kinda conditioned to try that form first as well, because most linux package managers will do that rename to fit their naming conventions
20:28:44 <jle`> MonadRandom-0.5 not on stackage yet
20:28:45 <Lokathor> 0.5 has a cool new "interleave" thingy
20:28:52 <Lokathor> where you can lazily do the randomness
20:28:56 <jle`> but you can use it with extra-deps
20:39:25 <Lokathor> does cabal merge flag lists?
20:39:42 <Lokathor> can i do this http://lpaste.net/351264
20:41:57 <geekosaur> that will merge, yes
20:42:17 <Lokathor> perf
20:57:18 <nitrix> Are there easy way to debug segmentation faults?
20:57:28 <nitrix> Other than proceeding by elimination?
20:59:01 <geekosaur> gdb will usually have useful information for FFI related segfaults (and if it's not ffi-related, shame on you! :p )
20:59:15 <nitrix> It's FFI :P
20:59:21 <nitrix> (SDL2)
21:01:13 <geekosaur> also helps to have debug symbols, which you can usually install on linux as a separate package (libsdl2-dbg on debian/ubuntu for example)
21:13:43 <fresheyeball> hey folks
21:15:00 <fresheyeball> so I'm building a little project using the "dimensional" library
21:15:12 <fresheyeball> but I also need to do vector math
21:15:28 <fresheyeball> for example, I would like to have something like a `Vec2 (Velocity Float)`
21:16:10 <fresheyeball> any recommendations on how to do this? Am I going to have to write my own lib for this, so that the vector computation uses the dimensional functions?
21:16:41 <fresheyeball> athan: hey there
21:17:14 <jle`> fresheyeball: the 'linear' package has V2, which it looks like you want
21:18:20 <jle`> data V2 a = V2 a a
21:18:37 <fresheyeball> Ooo its kmetty 
21:18:37 <jle`> comes with the appropriate Functor/Applicative/Traversable instances to be used conveniently :)
21:18:55 <fresheyeball> jle`: awesome
21:18:59 <fresheyeball> thank you!
21:19:01 <jle`> yeah, but for the most part it's just a package that exports types like that
21:19:02 <athan> fresheyeball: ! whutuuup
21:19:04 <jle`> and appropriate instances
21:19:17 <jle`> it's probably the least kmetty kmett package heh
21:19:38 <fresheyeball> athan: I'm going to see if I can't get `linear` to work with `dimensional`
21:19:46 <athan> :O nice!
21:19:54 <jmorris> how would i break a list into all possible consecutive combinations of a specified length? eg. break 2 [1,2,3,4] = [[1,2,],[2,3,],[3,4]]
21:19:55 <fresheyeball> jle`: fair enough, I just get this inspired sense of trust when I see he is the maintainer 
21:20:15 <jle`> ah, i definitely thought you were referring to a different connoation :)
21:20:43 <jle`> jmorris: you can generalize the ol' zip xs (drop 1 xs) pattern
21:22:49 <jmorris> jle`: it need to be able to break into different lengths
21:23:18 <jmorris> for example; breakBy 3 [1,2,3,4,5] = [[1,2,3], [2,3,4],[4,5,6] ... ]
21:23:25 <jle`> hmmm
21:23:40 <jle`> > take 3 (iterate (drop 1) [1..10])
21:23:42 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10]]
21:23:51 <jle`> > transpose (take 3 (iterate (drop 1) [1..10]))
21:23:53 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[10]]
21:24:10 <jmorris> this is the problem btw, https://projecteuler.net/problem=8
21:24:29 <jle`> if it's statically known you can just use zipWithN
21:24:34 <jle`> but yeah transpose will give you a general mechanism
21:24:45 <jle`> > transpose (take 4 (iterate (drop 1) [1..]))
21:24:47 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
21:24:58 <jmorris> the length should actually be 13
21:25:08 <jmorris> but i thought being general would help
21:25:27 <jle`> not sure how performant transpose is though
21:28:46 <pikajude> i'm curious about hoogle server
21:28:51 <jle`> i'm actually...not even sure how transpose works
21:28:56 <pikajude> i'm not sure how it could possibly work
21:29:16 <pikajude> it tries to run XHR requests to fetch pages from the local filesystem
21:29:19 <pikajude> but i don't think any browser allows that
21:29:33 <pikajude> what am i doing wrong
21:34:04 <Lokathor> deepseq doesn't seem to be helping me :/
21:37:23 <Lokathor> oh, turns out it works if you read the docs on how to make it work :P
21:41:34 <Lokathor> http://lpaste.net/351265
21:51:25 <MarcelineVQ> I keep forgetting I can't run your programs :>
21:52:04 <Lokathor> get a windows PC :3
21:52:13 <Lokathor> or port the ConcurrentConsole to mac
21:52:24 <Lokathor> it's like 2 functions you need to write
21:52:42 <MarcelineVQ> hmm
21:53:28 <Lokathor> i don't have a unixy system that can run haskell so i've been slacking on that front
21:53:46 <Lokathor> oh, wait, i do, now that i think of it, so really i have no excuse
22:00:57 <pavonia> As some parser combinator packages like Parsec use an explicit "try" operator for backtracking, are there any advantanges these packages have over the ones like attoparsec that handle backtracking automatically? Lower memory consumption or so?
22:01:51 <Lokathor> as i recall, attoparsec is a little more performant but usually has harder to understand error messages when there's a problem
22:02:17 <Lokathor> i'm not sure what the difference in backtracking does though
22:04:42 <pavonia> But e.g. megaparsec also has explicit backtracking and is said to have good error message
22:11:43 <MarcelineVQ> megaparsec is pretty nice, especially when you use its Lexer module. if I​ had to give them roles, megaparsec is better for parsing languages and attoparsec is better at data. I've only just recently been using attoparsec though so that's anecdotal
22:22:36 <fragamus> im compiling a 45 MB source file and it is taking a while
22:23:33 <fragamus> i guess it's poorly factored a little bit
22:23:51 <fragamus> :P
22:23:58 <Lokathor> 45mb is kinda big no matter what
22:25:44 <NextHendrix> Lokathor: deep
22:27:49 <YellowOnion> huh, is there a map/fmap for ByteString?
22:28:45 <jle`> YellowOnion: yeah
22:28:48 <jle`> it's just called 'map'
22:28:49 <Lokathor> NextHendrix, only the best pronouncements from here
22:29:28 <ubsan> Lokathor: a 45 MB hard drive is not that big
22:29:38 <jmorris> YellowOnion: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html
22:29:52 <Lokathor> ubsan i've got some type safety for you
22:30:10 <Lokathor> randSum :: Int -> MVar [Char] -> IO () -- how meaningful!
22:30:23 <YellowOnion> jmorris, I must be blind, I can't see any map there.
22:30:28 <jle`> YellowOnion: https://www.stackage.org/haddock/nightly-2017-01-14/bytestring-0.10.8.1/Data-ByteString.html#v:map
22:30:30 <ubsan> Lokathor: wat
22:30:44 <ubsan> please remember that I am not a haskeller
22:30:49 <Lokathor> :P
22:30:54 <jmorris> YellowOnion: Ctrl+F
22:31:12 <NextHendrix> if the types are too complicated to use, then they're definitely safe
22:31:27 <YellowOnion> jmorris, I tried that and all it brought up with mapAccum, must not be my day today ha.
22:31:57 <jmorris> Ctrl +F : map :: (Word8 -> Word8) -> ByteString -> ByteString
22:32:01 <Lokathor> ubsan, right, let me translate... hmm... fn randSum(count: i32, lock: Mutex<Vec<Char>>) { ... }
22:32:10 <NextHendrix> YellowOnion: Data.ByteString.map
22:32:51 <ubsan> Lokathor: what's it mean
22:32:56 <ubsan> what's it do
22:32:57 <jle`> YellowOnion: that's interesitng. mapAccum isn't even a function in Data.ByteString
22:33:03 <jle`> something fishy is going on
22:33:14 <jmorris> yeah i just realised that
22:33:15 <jle`> are you sure you're looking at the right module/version?
22:33:19 <NextHendrix> jle`: haddock
22:33:23 <jle`> post the link?
22:33:31 <Lokathor> right now it's just a demo, it adds up 10 million random numbers, and in the demo it does it in the background
22:33:51 <YellowOnion> jle`, I mean it jumped to the section with mapAccumL, and mapAccumR
22:34:03 <jle`> oh
22:34:07 <jmorris> it's the second map on the page
22:34:14 <ubsan> Lokathor: why does it take a [Char] if they're random
22:34:16 <jle`> YellowOnion: maybe go up a few results?
22:34:27 <ubsan> and why does it take a [Char] if they're numbers
22:34:47 <jle`> the mapAccum's section is the 6th match on the page for me
22:34:51 <shayan_> is it correct to read “::” as “is a value in” ? i.e. V::T would read as “V is a value in the Type T. V has type T.”
22:34:52 <jle`> YellowOnion: if you post the link maybe it'll help
22:34:58 <jle`> you might have the wrong module or version
22:35:08 <ubsan> Lokathor: this doesn't seem like programming with types
22:35:13 <Lokathor> ubsan, that reprisents the buffer of partial input in the user's console. It needs to pass the mutex to the concurrent-safe version of printing
22:35:28 <YellowOnion> jle`, don't worry my code compiles now :P
22:35:47 <Lokathor> soon enough a minor detail like that will go away with proper newtype use
22:36:26 <ubsan> Lokathor: see, this makes zero sense
22:37:20 <Lokathor> ubsan, the characters that the user currently has in the console are kept in the mutex. When the concurrent-safe printing is used, it deletes the partial input, prints, and then restores the partial input, so that the user can keep track of what they've entered so far
22:37:40 <ubsan> Lokathor: ... weird
22:37:49 <ubsan> why are you using [Char] as opposed to String
22:38:32 <Lokathor> as it happens, the buffer is stored in reverse order, since it's easier to affect the head of a list in haskell than the tail
22:38:38 <ubsan> ah
22:38:40 <Lokathor> http://lpaste.net/351265 here's an example session
22:38:54 <ubsan> well why is randSum dealing with printing
22:39:05 <ubsan> seems like not good separation of concerns
22:39:28 <Lokathor> it's just a thing that can be done as a demo of a longer running background computation
22:39:45 <ubsan> in another thread, I imagine
22:39:46 <Lokathor> gotta build up slowly!
22:40:11 <Lokathor> yes, main, counter, and randSum are all their own thread (and remember that haskell threads are green threads, not like rust with OS threads)
22:40:34 <ubsan> it seems weird
22:40:35 <Sornaensis> Lokathor: green threads?
22:41:07 <Lokathor> Sornaensis, yes? It means they're cheap and you can have dozens of them and they get assigned to OS threads by the Haskell runtime's scheduler
22:41:20 <Sornaensis> unfamiliar with the term
22:41:22 <Sornaensis> cool
22:41:47 * ubsan goes back to idris
22:42:09 <Lokathor> in haskell, you can have one thread per user in a networked program easily. If you did that with OS threads you'd probably just crash your program quickly
22:42:23 <Sornaensis> ahh
22:42:51 <Lokathor> good luck ubsan 
22:43:51 <ubsan> dependent types are :+1:
22:45:26 <Lokathor> sounds dubious
22:51:58 <osa1> what is the reason for `(<*>) = ap` law for an Applicative f when f is also a Monad ?
22:53:51 <osa1> nvm, found https://www.reddit.com/r/haskell/comments/3v9qlf/why_must_ap/
22:57:03 <jle`> isn't simon marlow's fancy facebook concurrency library built around a type where (<*>) doesn't = ap?
22:57:17 <Philippa> for what value of =?
22:57:18 <jle`> could be considered unfortunate perhaps
22:57:44 <Philippa> I imagine it isn't in terms of concurrency effects generated, I don't know about result values
22:58:01 <jle`> Philippa: where "f <*> g" evaluate to the same thing as "f `ap` g"
22:58:36 <Philippa> sure. I ask because that's not the only legit value for a monad that's held abstract
22:59:09 <jle`> 'value' in what sense?
22:59:22 <Philippa> if your only proper eliminator is some flavour of runMonad function, "runMonad (f <*> g) = runMonad (f `ap` g)" is a reasonable notion of equality
23:00:23 <jle`> they could probably be considered equal under the right quotient, probably, yeah
23:02:03 <Philippa> yeah, though what I'm point at is more an extensional-only equality in which effects that don't ever alter return values aren't observable to that equality any more than the exact syntax of functions
23:02:10 <Philippa> *pointing at
23:02:29 <Philippa> "it's equal in the monad's internal language", if you like
23:02:44 <ssd> @pl \xs n -> take n xs
23:02:45 <lambdabot> flip take
23:03:07 <ssd> @pl \(_, a) -> (a <= n)
23:03:07 <lambdabot> (<= n) . snd
23:03:11 <jle`> Philippa: yeah, if the order of execution of f and g can't ever affect the result, then it wouldn't really be an issue
23:03:49 <jle`> but making assumptions like that from IO actions is a good way to have something bite you really quickly :)
23:04:03 <ssd> @pl fst . last $ takeWhile (\(_, a) -> (a <= n))
23:04:03 <lambdabot> fst (last (takeWhile ((<= n) . snd)))
23:04:23 <jle`> by quickly i mean almost immediately
23:04:33 <Philippa> sure! Then again, assuming your IO action doesn't cause a complete failure of existence of your notion of evaluation can bite you too
23:04:59 <Philippa> do {hcf; ...}
23:05:16 <polll> What's the best way to continue calling a function indefinitely? (similar to a "while (true) do {foo();}" in other languages
23:05:23 <jle`> polll: there's forever
23:05:28 <jle`> um
23:05:32 <jle`> if you mean 'execute an IO action forever'
23:05:39 <jle`> *repeatedly, forever
23:05:45 <jle`> forever x = do x; forever x
23:05:57 <jle`> @src forever
23:05:57 <lambdabot> forever a = let a' = a >> a' in a'
23:06:09 <jle`> aw man i was hoping that would be actually helpful
23:06:17 <Lokathor> http://lpaste.net/351266 i seem to have forgotten how to ReaderT
23:06:43 <Philippa> Lokathor: if it helps any, I have a hell of a story about ReaderT changing under my nose back in the day
23:07:03 <polll> Thank you so much, jle`! Really appreciate it. 
23:07:05 <Lokathor> it helps if you can explain my type error :P
23:07:19 <jle`> polll: btw, this wouldn't typically be called "calling a fucntion indefinitely" in haskell
23:07:36 <jle`> calling a function is something like
23:07:37 <Lokathor> jle`, actually that >> is apparently important to help prevent space leaks in some situations, so says the comments in the GHC source
23:07:39 <jle`> > succ x
23:07:41 <lambdabot>  succ x
23:07:49 <jle`> > succ 1
23:07:51 <lambdabot>  2
23:07:52 <polll> What's the typical way of describing this?
23:07:54 <jle`> so 'calling succ indefinitely' might be:
23:07:55 <Philippa> Lokathor: at a glance, looks like you got String/[Char] and [String] mixed up somewhere?
23:07:59 <jle`> > iterate succ 1
23:08:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:08:19 <jle`> polll: executing an action repeatedly, maybe
23:08:46 <jle`> 'foo' in haskell wouldn't really be called a function because it doesn't have any arguments
23:08:51 <Philippa> jle`: "fix succ" is an extremely good example of laziness introducing values you probably didn't want, too
23:09:18 <Philippa> (at least, on the datatype that looks like the Peano naturals and is actually the conaturals)
23:09:24 <jle`> Lokathor: yeah, i see why it'd be in the actual source, but i'm talking about being helpful pedagogically, heh
23:09:58 <jle`> polll: "forever x" is "do x, then do (forever x)".  which is "do x, then do x, then do (forever x)", etc. forever
23:10:08 <Philippa> eh, it's the "write a worker function, call it" pattern
23:10:27 <dmwit> Lokathor: Unrelated, but `take n . repeat` can also more simply be spelled `replicate n`.
23:10:29 <Philippa> it's just that the worker uses its outer name because it's not actually worker/wrapper
23:10:45 <Lokathor> dmwit, yes but the ReaderT is what i want to fix :P
23:10:55 <dmwit> Lokathor: `putStr (reverse buffer)` looks suspicious to me.
23:11:03 <dmwit> Lokathor: Isn't `buffer` a `[String]`?
23:11:12 <Lokathor> dmwit, the buffer is stored in reverse order of how the characters appear on screen
23:11:25 <Lokathor> oh!
23:11:32 <Lokathor> waiTttt~
23:11:37 <Lokathor> it's supposed to be [Char]
23:11:39 <Lokathor> good call
23:11:47 <jle`> polll: something like 'putStrLn "hello"' isn't a function, but an IO action, that you can sequence execution of.  'forever (putStrLn "hello")' would sequence 'putStrLn "hello"' after itself forever/indefinitely
23:13:08 <dmwit> > "\b \b" >> [1..10]
23:13:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10]
23:13:24 <dmwit> > [1..10] >> "\b \b"
23:13:27 <lambdabot>  "\b \b\b \b\b \b\b \b\b \b\b \b\b \b\b \b\b \b\b \b"
23:13:33 <dmwit> Hm, not quite. =P
23:13:43 <dmwit> > "\b \b" <* [1..10]
23:13:45 <Lokathor> don't think it works when \b doesn't work :p
23:13:45 <lambdabot>  "\b\b\b\b\b\b\b\b\b\b          \b\b\b\b\b\b\b\b\b\b"
23:13:54 <dmwit> There we go.
23:14:53 <dmwit> Lokathor: I dare you to use that in your code. =)
23:15:09 <Lokathor> dmwit, http://lpaste.net/351266 is what i think i'll go with for now
23:15:58 <Lokathor> mm, perhaps replicate instead
23:16:11 <Lokathor> hlint is so insistent
23:17:05 <dmwit> your loss =)
23:17:34 <Lokathor> well
23:17:35 <Lokathor> hmm
23:18:08 <Lokathor> > let bufferSize = length "fooBar" in "\b \b" <* [0..bufferSize]
23:18:10 <lambdabot>  "\b\b\b\b\b\b\b       \b\b\b\b\b\b\b"
23:18:40 <Lokathor> ah, gotta start at 1?
23:19:25 <dmwit> > "\b \b" <* [1..length "fooBar"]
23:19:27 <lambdabot>  "\b\b\b\b\b\b      \b\b\b\b\b\b"
23:19:33 <dmwit> No need for the let now, since the value appears only once.
23:19:44 <dmwit> And yeah, off-by-one errors are hard. =)
23:20:27 <Lokathor> -- clear the currently displayed buffer text,
23:20:27 <Lokathor>         -- this goofy way of doing it is thanks to dmwit of #haskell.
23:20:39 <dmwit> =D <3
23:20:39 <Lokathor> you're famous!
23:21:55 <dmwit> Lokathor: Oh man, it gets even better.
23:22:06 <dmwit> > "\b \b" <* "fooBar"
23:22:08 <lambdabot>  "\b\b\b\b\b\b      \b\b\b\b\b\b"
23:22:45 <Lokathor> now that is interesting
23:47:48 <nanoz> hi
23:48:01 <nanoz> can someone help me on this problem 
23:48:21 <nanoz> https://www.hackerearth.com/practice/basic-programming/implementation/basics-of-implementation/practice-problems/algorithm/jumping-tokens/
23:55:22 <ssd> :t sqrt
23:55:23 <lambdabot> Floating a => a -> a
