00:08:29 <lyxia> fresheyeball: what's up?
00:10:48 <fresheyeball> lyxia: I just want the modules in the haddock to be clickable
00:12:07 <fresheyeball> lyxia: I mean, also how long does it take for hackage to update such that `cabal update` works?
00:12:08 <qcrvszvz> Is there a `mapMaybe :: (a -> Maybe b) -> Set a -> Set b` somewhere in containers? I didn't find one; any good reason why there isn't one?
00:30:11 <saurabhnanda> broadcasting this here: https://www.reddit.com/r/haskell/comments/5pnd9i/bugfree_leakfree_battletested_library_for/
00:30:27 <saurabhnanda> wonder what's the audience overlap between IRC, Reddit, and Haskell-cafe mailing list?
00:31:19 <unknownln> Reddit and IRC, but not mailing list, reporting in
00:31:48 <saurabhnanda> unknownln: thanks :)
00:32:22 <saurabhnanda> the haskell committee should probably do a thorough survey of this and bless 1-2 channels.
00:33:08 <unknownln> Yeah I'd be interested in the results as well. Maybe it's just because I'm a bit younger, but I've never joined a mailing list of any sort
00:34:03 <unknownln> Also, figuring out how many people participate in IRC, but not reddit or the mailing list, may be a bit more difficult since no matter when you post in IRC a lot of people won't see it
00:36:27 <jle`> would those people really be considered participants in IRC, then? :p
00:37:00 <jle`> you might get a decent sample by leaving it in the topic maybe
00:37:30 <doomlord> anyone around? How is the 'record system' in haskell these days
00:37:46 <saurabhnanda> doomlord: still hideous.
00:37:53 <saurabhnanda> doomlord: use lenses and it's palatable.
00:38:04 <jle`> it hasn't changed much for the most part for the past few years, but there are some changes in progress
00:38:17 <jle`> for the most part what we've done is found ways to work around it
00:38:34 <jle`> but come back in a year and a half and we might have something better :)
00:38:38 <doomlord> haha
00:38:42 <jle`> real changes have been put into ghc
00:38:55 <jle`> there is a planned roll-out over the next couple of versions
00:40:05 <doomlord> ok. well basically I haven't touched haskell in 2 years, I was curious to try it again. I remember what stopped me enjoying it was friction with straightforward records e.g. couldn't use the same field member in 2 (because it's making uniquely named accessor functions)
00:40:50 <doomlord> the rest was awesome
00:41:22 <doomlord> i wouldn't say i ever really mastered it though
00:42:56 <srhb> doomlord: Current workarounds consist of autogenerating polymorphic versions of the "same" name, but having the actual record field names be unique, more or less.
00:43:12 <srhb> doomlord: So yeah, if that's a show stopper, you probably want to wait a bit longer. :-)
00:43:15 <doomlord> using 'template haskell' ?
00:43:32 <dibblego> I'd call that a superior solution, more than a workaround
00:43:38 <doomlord> srhb i feel a bit dumb saying it's a show stopper, since the language is clearly remarkable
00:43:47 <dibblego> It's one of the reasons to use haskell; everything else is catching up.
00:43:52 <doomlord> its just a mental block I had I guess
00:44:02 <srhb> dibblego: Well, the fact that that's what happens is okay, the machinery you need to use to get there is annoying.
00:44:17 <dibblego> makeClassy ''DataType ?
00:44:21 <srhb> Yeah.
00:44:34 <doomlord> quite a few of the ideas have gone across into rust and swift, but they're still more like OOP ?
00:44:42 <dibblego> I agree. Still, nothing better has caught up yet.
00:45:12 <srhb> I mean, even if that were the only thing, it would be okay. But now you want to autogenerate Aesony stuff and you need to manually chop away parts of the original field names etc. etc. etc.
00:45:15 <srhb> Argh! :-)
00:45:20 <srhb> But it's certainly not a show stopper for me.
00:45:30 <srhb> And I have faith that we're going to get a very nice solution.
00:45:40 <dibblego> I think that's just poor library design from aeson
00:46:02 <dibblego> argonaut.io solved this problem, except it is in scala, which cannot have useful lenses
00:46:23 <doomlord> are these 'lenses' mostly about composeable mutations, or what?
00:46:42 <doomlord> simulating mutation  / or what
00:46:54 <srhb> dibblego: Might be. :)
00:47:05 <jle`> doomlord: a lens basically packages up functions for viewing and modifying a field/aspect of the data
00:47:10 <jle`> doomlord: and yeah, they're composable
00:47:18 <srhb> doomlord: Getters and setters on steroids, and that's the very short version. :-P
00:47:39 <jle`> a Lens itself is basically just a packaged-up getter/setter, and they're composable with (.), which is convenient
00:49:38 <mlegrand> Hey everybody! Any advice for a not-too-easy tutorial project in Haskell for a former OCamler ?
00:52:47 <wz1000> mlegrand: Writing a lisp interpreter is always fun :) Also, it would require you to become familiar with parser combinators, ADTs, monad transformer stacks, the writer/state/IO/error monads and lots more
00:53:36 <doomlord> hmm. i'll probably stick with other languages I guess.. as you say 'others are catching up'.  my oop-y poisoned brain will be more at home in something hybrid from the ground up.
00:55:30 <mlegrand> wz1000: That's actually a nice idea. I used to love category theory in class and do love the few I've seen of Haskell until now, I'll make sure to explore your pointers
00:58:23 <wz1000> mlegrand: Here are a few resources for just this: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours and a new take on it https://wespiser.com/writings/wyas/home.html
01:01:32 <mlegrand> That seems to perfectly fit my needs, thank's a lot
01:09:56 <riaqn> Hi, any facility to tracking the transformation of AST?
01:11:15 <riaqn> I mean, I was transforming AST1 to AST2, while part of AST2 issues an error. Now, I hope some facility to trace back the error to corresponding part in AST1, which was transformed to the part in AST2.
01:24:19 <Kasceh> Anyone encountered a 'DecodeError "Error in $: string"' from Aeson before? Anyone know what the error actually means?
01:34:56 <lyxia> Kasceh: that looks like a custom error message
01:39:26 <Kasceh> lyxia: Where would such things be defined? :(
01:44:00 <lyxia> Kasceh: in a FromJSON instance
01:57:41 <Pennyw95> Hi... jsut a little question, are functions written with 'where' technicaly closures? I'm getting an out of scope error when using a value from a main function in the smaller one...of course I can just pass it to it but I'm curious
01:58:41 <Pennyw95> Simplified: mainfunc t = getLine >>= go, where go x = putStrLn (x ++ show t)
01:59:55 <wz1000> Pennyw95: That should work(without the comma after 'go')
02:00:24 <Pennyw95> I'm getting a "variable not in scope" error though
02:00:30 <malinoff> hi everyone, I have a haskell-based app running within docker stuck in infinite loop of https://bpaste.net/show/2335bb4bccc5
02:00:32 <Pennyw95> let me paste the whole thing
02:00:44 <malinoff> if I execute the same binary manually within the same container, it works just fine
02:00:59 <malinoff> can somebody give me a clue?
02:02:34 <Pennyw95> wz1000: http://pastebin.com/4YVRPWSG  line 14 has the 'vel' variable out of scope
02:04:39 <ertes> Pennyw95: vel's scope is narrower
02:04:54 <ertes> it's only in scope for the remainder of its do-block
02:05:28 <ertes> there are two ways to fix this:  either pass 'vel' as an extra argument to 'go', or define 'go' after 'vel'
02:05:51 <ertes> i.e. using 'let' instead of 'where'
02:05:54 <Pennyw95> yeah I already noticed that I could go getLine >>= \l -> go vel l
02:06:08 <Pennyw95> defining go inside let is good too
02:06:25 <Pennyw95> so basically the do block doesn't actually include the where one?
02:06:43 <ertes> to anything defined in 'where' the entire do-block is a black box
02:06:50 <ertes> it can't see its local variables
02:07:11 <ertes> because anything defined in the do-block is only in scope for the remainder of that block
02:08:01 <ertes> > let xs = do x <- [1..3]; pure x in x  -- scope error
02:08:05 <lambdabot>  x
02:08:21 <ertes> > let xs = do blah <- [1..3]; pure blah in blah  -- scope error
02:08:24 <lambdabot>  error: Variable not in scope: blah
02:08:47 <Pennyw95> Oh, I see... good to know then, thanks alot :)
02:37:31 <thatguy> are there any good-style solutions for this course: http://www.cis.upenn.edu/~cis194/spring13/lectures.html -- and by that I mean solutions that are done with the knowledge you have at the point where the HW is stated
02:37:55 <thatguy> and preferably by someone who knows haskell and not another beginner like myself who just uploaded his solutions
02:38:13 <thatguy> because I often get solutions to work but have the feeling that there could be way more elegant ways
02:40:07 <malinoff> hi everyone, I have a haskell-based app running within docker stuck in infinite loop of https://bpaste.net/show/2335bb4bccc5. if I execute the same binary manually within the same container, it works just fine. Can somebody give me a clue?
02:41:52 <Axman6> mbuf: what is that paste?
02:42:03 <Axman6> uh, malinoff
02:44:02 <Ferdirand> malinoff: it is kinda hard to tell what it is doing without context
02:44:20 <Axman6> malinoff: you're going to need to give more context for anyone to be able to help you
02:45:26 <Ferdirand> do you run your container with -i/-a ?
02:46:07 <letmelearnthis> can anybody help me to understand how type constructors in haskell correspond to the mapping of objects between categories? For example, if I want to map 2 objects from one category to another how would this look ?
02:48:41 <lyxia> letmelearnthis: there are plenty of ways to see categories in Haskell types. It's not clear what you're looking for.
02:49:15 <letmelearnthis> lyxia: i'm trying to figure out how to implement a functor in haskell
02:51:01 <letmelearnthis> lyxia: the functor should map two objects from one category to two objects of another category. I have looked at some tutorials on how to implment functor for container like types such as Maybe but it's not clear to me how I would map the objects in my case. I've read that the mapping of objects corresponds to type constructors so i'm not sure if that's how I should also implment my functor
02:52:21 <lyxia> A common way to see type constructors as mappings between types is: a type constructor F maps a type a to type (F a).
02:53:03 <letmelearnthis> lyxia: so if my category has two objects, would that mean that I need two type parameters?
02:53:49 <lyxia> No.
02:54:15 <letmelearnthis> lyxia: would I need a new type constructor for each object?
02:54:21 <malinoff> Axman6, Ferdirand: I'm willing to give you more context, I just have no idea what exactly do you need
02:54:39 <lyxia> letmelearnthis: I don't know. Could you give more concrete details about the functor you are trying to define
02:55:14 <lyxia> letmelearnthis: What are the categories you are working with
02:56:13 <letmelearnthis> lyxia: I have come up with the categories myself as a way to represent data schemas. The functor would function as a migration from one schema(category) to the other
02:56:29 <malinoff> Axman6, Ferdirand: what do you need?
02:57:17 <letmelearnthis> lyxia: the schema(category) would have self defined types as the objects and so the functor should essentially map the objects from one schema to the other
02:58:48 <letmelearnthis> lyxia: so the objects of the first category could be EmailFromCatA, FirstNameCatA, and the functor would map those types to EmailFromCatB FirstNameCatB
02:59:07 <lyxia> letmelearnthis: what are the morphisms of these categories
03:00:27 <letmelearnthis> the morphisms would be containment. So I could build more complex types from the simpler types. An object from catA could be AccountCatA which would have morhpisms to EmailFromCatA and FirstNAmeCatA. The morphisms specify reference to another type
03:04:59 <letmelearnthis> lyxia: i'm not sure how to best represent this in haskell
03:06:00 <lyxia> I am wondering whether you really should be looking at this categorically
03:07:11 <letmelearnthis> lyxia: I'm looking at it categorically because this is just a simplified example and represnting it categorically would allow me to migrate between schemas while having nice properties
03:07:20 <malinoff> anyone?
03:08:54 <letmelearnthis> lyxia: it should still be possible to model this in haskell right? I will want to make additional functors based on these categories later, but right now I don't have an idea how this simplest functor which I described above could be implemented
03:10:47 <lyxia> letmelearnthis: won't you need to specify the mappings EmailFromCatA -> EmailFromCatB ; FirstNameFromCatA -> FirstNameFromCatB ... separately anyway
03:11:09 <letmelearnthis> lyxia: yes I think so
03:12:29 <letmelearnthis> lyxia: but i'm not sure how to specify the mappings
03:12:52 <lyxia> these would just be functions
03:13:19 <letmelearnthis> okay I See
03:14:14 <letmelearnthis> so the mappings of the objects could just be simple functions
03:15:53 <letmelearnthis> lyxia: and what would be the best way to 'collect' the functions together to ensure that they are considered a single unit along with the morphism mappings?
03:16:26 <letmelearnthis> lyxia: and would the morphism mappings also best be represented as plain old higher order functions?
03:16:38 <lyxia> actually these mappings I mentionned don't correspond to anything from the point of view of a functor...
03:16:53 <lyxia> But since we're talking about migration, these seem to be the only ones that make sense.
03:16:55 <ertes> letmelearnthis: i'd just implement it without CT, then see if i can retrofit CT, or whether there is even a point in doing so
03:17:45 <letmelearnthis> ertes: actually it is already implemented in Java and I am trying to use CT because it may allow me to verify the migrations
03:18:16 <ertes> *if* you want your migrations to be functorial…  what if a certain migration would like to get rid of some reference?
03:19:30 <lyxia> letmelearnthis: How do you represent your morphisms ?
03:19:59 <letmelearnthis> ertes: yes I am actually referring to some ideas I got from this paper goo.gl/qqEeBp
03:20:57 <letmelearnthis> but instead of tables/columns I want to hold data in-memory inside haskell types
03:21:49 <letmelearnthis> I don't have a lot of experience with CT or haskell and just supposed that it should be possible to represent these 'schema categories' nicely in haskell but it seems that maybe it isn't the best fit
03:22:28 <ertes> letmelearnthis: it's just that data migrations aren't functorial in general…  they are not as natural as one might think
03:22:49 <ertes> at least not with the kind of category that you had in mind
03:23:36 <ertes> to answer your question:  if you represent each migration by a type, then a type family can represent the object map
03:23:53 <ertes> type family Migrate mig a
03:24:10 <letmelearnthis> I want to represnt the migration with a functor and the data types as objects between the two categories
03:25:11 <ertes> in order to be a functor you need to prove for every migration that:  ∀ x y. x ≤ y → Migrate M x ≤ Migrate M y
03:25:19 <ertes> where "≤" means "refers to"
03:26:25 <ertes> also make sure that you have a category to begin with, in particular references need to be transitive
03:28:04 <ertes> you can mark functorial migrations with a type class, if you need to
03:28:47 <ertes> class Monotone mig  -- empty class
03:29:35 <Axman6> safe-copy offers the tools for that IIRC
03:29:44 <Axman6> (part of acid-state)
03:38:26 <manek> Hello! :) What is the best way (if there is any simple) to check if a given character is a UTF-8 newline? The same problem is with discovering UTF8 space (without newlines)
03:39:08 <hpc> > isSpace ' '
03:39:11 <lambdabot>  True
03:40:00 <EvanR> you mean a unicode newline
03:40:31 <EvanR> test against the few possibilities listed here https://en.wikipedia.org/wiki/Newline
03:40:37 <hpc> look at the character classes in Data.Char
03:40:37 <manek> hpc: nope, it contains newlines too
03:40:46 <manek> EvanR: yes, I mean unicode newline
03:41:33 <manek> hpc: none of these classes does it. isSpace returns true for newline. General Category does not have anything about newline, it returns "control" for newline char which is broade
03:41:37 <EvanR> theres no class for newline
03:41:55 <Axman6> what is a "unicode newline"?
03:41:59 <EvanR> see my link
03:42:05 <Axman6> i mean, newline is a specific character
03:42:12 <EvanR> next line is
03:42:21 <Axman6> > ord '\n'
03:42:26 <lambdabot>  10
03:42:57 <EvanR> thats not "newline" thats LF
03:43:19 <EvanR> theres up to 8 different things you could accept as newlines in unicode
03:43:47 <hpc> on a typewriter LF doesn't even make a new line
03:43:48 <EvanR> NEL is a brand new one invented just to complicate everything
03:43:53 <hpc> it puts you back at the first column
03:43:58 <EvanR> no thats CR
03:44:09 <EvanR> carriage return
03:44:12 <hpc> ah, had them mixed up
03:45:02 <manek> EvanR: thanks for the link! Ok, it makes perfect sense to test these 8 possibilities. And how we can now discover any space? By space I mean anything that unicode thinks is space without line terminators?
03:45:08 * jophish wonders if [CR,CR] puts the paper back where it started
03:45:08 <Axman6> CR is the 'ping', LF is the 'chunk'
03:45:28 <janosp> Hi, I have a question:
03:45:30 <Axman6> hmm, or is reaching he end of the line the ping...
03:45:53 <janosp> Sometimes you see function definitions using a ' in front of a Type like : HVect '[]
03:45:57 <Axman6> janosp: I hope it's a goodun if you're keeping it to youself :P
03:45:58 <janosp> what does the ' mean?
03:46:08 <janosp> and where can I read more about it
03:46:13 <janosp> Axman6: hahahaha
03:46:14 <Axman6> that's lifting a value into the type level
03:46:31 <EvanR> manek: parser libs come with whitespace recognizing things that dont match newlines, maybe you should use one of those
03:46:37 <janosp> what does that mean :D
03:46:47 <Axman6> True is a value of type Bool, 'True is a _type_ (of kind Bool? can't remember)
03:46:48 <jophish> It't telling the compiler that the "[]" means the value "empty list" and not the type "list constructor"
03:47:21 <manek> EvanR: I'm using megaparsec I dont see any function which matches space but newline
03:48:14 <EvanR> https://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec-Char.html#v:spaceChar ?
03:48:26 <EvanR> hrm
03:48:29 <janosp> so I can tell define that I want to have an empty list?
03:48:53 <janosp> so I could write :   giveMeAEmptyList :: '[]
03:48:53 <Axman6> it's a _type level_ list
03:49:08 <janosp> OK, I have no idea what type level list means
03:50:07 <Axman6> so if you have data Vec (k :: [*]) where VNil :: '[]; VCons :: a -> Vec xs -> Vec (a ': xs) gives you an HList, which can store values of different types
03:50:48 <manek> EvanR: it parses newlines too
03:50:49 <malinoff> hi everyone, I have a haskell-based app running within docker stuck in infinite loop of https://bpaste.net/show/2335bb4bccc5. if I execute the same binary manually within the same container, it works just fine. Can somebody give me a clue?
03:51:02 <Axman6> so VCons 7 (VCons True (VCons Nothing VNil)) could have type Vec '[Int,Bool,Maybe String]
03:51:11 <EvanR> manek: you can make a parser based on that one which rejects newlines
03:51:13 <malinoff> I also figured that if I `kill -s SIGINT` the process, it gets unstuck, prints the logs and exits
03:51:21 <ertes> manek: you have defined isNewline now, right?
03:51:25 <ertes> manek: satisfy (\c -> isSpace c && not (isNewline c))
03:51:28 <Axman6> malinoff: we asked you several questions about your problem before and you ignored them, are you going to answer them now?
03:51:44 <manek> ertes, EvanR: yes I can, but it will be slower than it could be :/
03:51:54 <EvanR> well
03:52:12 <EvanR> you can write low level byte crunching tests
03:52:22 <malinoff> Axman6: you said you need more context. I asked what specifically do you need, you never answered (I have been logged out in between, so I could miss some messages for sure)
03:52:29 <EvanR> but since its all boxed chars that seems silly
03:52:37 <EvanR> for speed you want attoparsec
03:52:45 <malinoff> Axman6: could you please repeat your questions?
03:52:56 <janosp> Axman6: Does this type of defining functions has a name, as your examples are a bit hard to understand, so I could read more about it online?
03:53:06 <manek> EvanR: I need nicer errors + custom state, so attoparsec is not usable here :(
03:53:09 <Axman6> malinoff: you need more context than what you've said
03:53:17 <ertesx> manek: memoise the function, if you really need to
03:53:23 <malinoff> Axman6: okay, what context do you need specifically?
03:53:33 <Axman6> janosp: they're called GADTs, generalised algebraic data types
03:53:41 <Axman6> malinoff: well, what are you doing?
03:53:57 <janosp> Axman6: thank you
03:54:28 <manek> ertesx: hmm, that could be interesting idea.
03:54:48 <malinoff> Axman6: I'm running a binary built by stack/ghc within a docker container. Instead of, well, working properly, it gets stuck on what I showed you on bpaste
03:55:49 <Axman6> malinoff: how are you running it? what are you using for the docker image? are you using any libraries which need to link against other C libraries?
03:55:53 <manek> EvanR: If I use ByteString with Megaparsec, will it still be much slower than attoparsec? If Im not wrong, bytestring will allow me to operate on unboxed chars, am I right ?
03:56:05 <Axman6> I'm not sure I can help you, but if you do want help you need to give context
03:58:51 <malinoff> Axman6: uh, just like any other binary executable - `./data/binary`. I'm using FROM ubuntu:trusty, trusty was used to build the executable. All libs from ldd output are present
03:59:15 <EvanR> manek: Word8 you mean, and no i dont think so
03:59:39 <EvanR> maybe Word8 code is optimized by the compiler
03:59:50 <malinoff> Axman6: do you need more context?
04:00:05 <EvanR> if it knows the Word8s are not bottoms
04:00:31 <EvanR> but since youre interesting in unicode this all sounds like  apain in the ass
04:00:55 <EvanR> interested*
04:07:11 <turnip2> hello?
04:07:19 <turnip2> I have a quick question
04:07:58 <turnip2> I often see people mention that the standard quicksort that people use to demonstrate haskell
04:08:13 <turnip2> isn't actually Hoare's quicksort
04:08:37 <turnip2> could someone point me to a more accruate implementation of quicksort in haskell?
04:08:40 <turnip2> thank you :)
04:09:09 <ahihi> http://stackoverflow.com/questions/7717691/why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort
04:10:01 <ertes> turnip2: more practically this one is a quicksort with a lot of tweaks for special cases: https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/Data-Vector-Algorithms-Intro.html
04:11:14 <ahihi> is it? the source says introsort
04:11:21 <turnip2> ahihi: "Dan Burton"'s quicksort seems quite like a direct translation from C
04:11:21 <turnip2> :D
04:11:35 <Tuplanolla> "Introsort is at its core a quicksort" says the documentation, ahihi.
04:11:39 <turnip2> ertes: thank you
04:12:02 <turnip2> is there any "haskell"y way to  implement it?
04:12:09 <turnip2> sorry if this sounds confusing
04:12:17 <ahihi> Tuplanolla: ah I see
04:12:36 <ertes> turnip2: what do you mean?
04:13:08 <EvanR> turnip2: if you implement it like on that stackoverflow post in a C-like way, you might be shooting yourself in the foot
04:13:50 <turnip2> ertes: isn't the implementation provided in SO quite unsafe?
04:13:57 <EvanR> because GHC is built with immutability in mind. mutable arrays require extra book keeping for garbage collection, thus slowing down code that would not have to do that in C
04:14:14 <ertes> turnip2: i haven't read it
04:14:54 <EvanR> use mergesort instead
04:15:24 <ertes> better: don't sort lists
04:15:26 <turnip2> EvanR: ahh I see, so trying to optimize memory usage could actually backfire?
04:15:45 <turnip2> ertes: vectors?
04:15:51 <ertes> if you need sortedness, use Map or Set
04:16:29 <ertes> if you need to sort a lot of unsorted data without the constant factors of Map or Set, use a mutable array and the vector-algorithms library
04:16:36 <turnip2> ertes: but isn't that inherently more complex? both in terms of speed and management?
04:16:50 <EvanR> turnip2: thats the beauty of it, when you use a lot of short lived immutable structures, the newest generation can be efficiently dropped from the first cache
04:17:06 <EvanR> performance gains are counterintuitive in ghc
04:17:22 <ertes> turnip2: it depends, but in most cases Map/Set will be preferable
04:17:34 <turnip2> ertes: okay :)
04:17:46 <ertes> remember: most applications don't ever need to "sort"…  they just have to *maintain* sortedness, which is a completely different thing
04:18:18 <turnip2> Evanr: that's quite interesting, would you have a link to someplace where I could learn more about haskell's GC?
04:18:33 <turnip2> Evanr: is it generational?
04:18:45 <EvanR> im not sure
04:19:49 <turnip2> okay I guess I'll try to look into in
04:19:52 <turnip2> *it
04:20:00 <turnip2> thanks ertes and EvanR
04:20:08 <turnip2> the #haskell community is quite nice
04:20:10 <turnip2> :)
04:20:27 <EvanR> and yeah vector algorithms is good because it can use mutability internally while being pure
04:28:48 <malinoff> anyone?
04:37:16 <novakboskov> Hi everyone! I'm new to Haskell and I'm interested in some productivity tricks with your workflow. I'm using Emacs, haskell-mode and intero. What I'm curious to know is your action in following scenario: I'm reading site.hs of my Haykill blog and want to know what is copyFileCompiler function (OK, I can obtain types from ghci or haskell-mode directly but I would like to see some source code, comments...). It would be great to see
04:37:16 <novakboskov> hackage docs for it. What to do?
04:39:47 <dunx> productivity tricks?
04:45:42 <AndreasK> novakboskov: I tend to just use hoogle for these look ups, not sure if theres a better way
04:52:23 <cskksc_> Hi, I'm pretty new to Haskell. So I apologize if this is a stupid question.
04:52:25 <cskksc_> But can I use arbitrary expressions in pattern synonyms ?
04:52:28 <cskksc_> pattern A = Something (1 + 2)
04:52:48 <cskksc_> Right now, I have to do this
04:52:56 <cskksc_> three = (1 + 2)
04:52:58 <cskksc_> pattern A <- Something three
04:54:27 <quchen> cskksc_: I haven’t used pattern synonyms much, but I think the GHC user’s guide is a fairly good explanation of how to use pattern synonyms: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms
04:54:45 <quchen> Your question seems to be about the directionality, the explanation of that is probably better than what I can come up with here.
04:55:36 <lyxia> pattern A = Something ((== 1 + 2) -> True)
04:55:40 <lyxia> ?
04:55:52 <lyxia> oh no that's not bidirectional. *facepalms*
04:56:55 <cskksc_> quchen: Yep. I did go through that. But din't find any answers there
04:57:05 <wz1000> Does anyone know what the status of Summer of Code is this year?
04:57:42 <reactormonk> How do you create a docker image from an application built with stack? copy over the binary from .stack-work ?
04:58:55 <cskksc_> So the problem is, I have a newtype like this;
04:59:10 <cskksc_> newtype Something = Something String
04:59:29 <cskksc_> and I'd like to use the fn toSomething in the pattern synonym
05:06:34 <Axman6> wz1000: sclv of shachaf might know
05:12:53 <Phillemann> Wasn't there a shortcut for statements starting with "maybe mempty"?
05:14:13 <lyxia> :t foldM
05:14:15 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
05:14:26 <lyxia> not that one...
05:14:41 <Phillemann> Ah, foldMap
05:14:52 <lyxia> right!
05:14:59 <deepfire> :t (.) . (.)
05:15:01 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:15:32 <deepfire> can someone help me understand, how does inference proceed to this result here?
05:16:24 <deepfire> I have tried naive substitution followed by solving equation due to the equality of 'b'
05:16:46 <deepfire> but the resulting type is huge and doesn't seem reducible
05:17:05 <humanoyd> anyone using intero + archlinux? When I `stack install intero`, I get the following error: `/usr/bin/ld: cannot find -ltinfo`
05:17:22 <ptek> Having two different test suites in a project, how would one run a specific one with stack? `stack test <test-suite-name>` results in `Error parsing targets: Directory not found: <test-suite-name>`
05:17:41 <quchen> ptek: steack test :testsuite:NAME I think
05:17:45 <quchen> stack*
05:17:50 <kuba-orlik> Hi! I'm trying to reimplement `map`, for practice. My solution doesn't work... What am I doing wrong? Could you help me out? http://pastebin.com/Ku1WubN6
05:17:52 <tdammers> quchen: freudian? you hungry?
05:18:11 <quchen> Freud was mostly a fraud, and Freudians were falsified. :-/
05:18:34 <quchen> Data point: I just had lunch.
05:19:12 <quchen> That said, Freud appearing on existentialcomics.com is usually a good laugh. :-)
05:19:52 <quchen> kuba-orlik: »fun list« applies »fun« to the whole list, not just the first element
05:20:29 <quchen> And »map2 fun tail(list))« means »(map fun tail) list«, because function application associates to the left.
05:20:37 <ptek> quchen: ooh... Thanks a lot! Should have read up on target syntax. (https://docs.haskellstack.org/en/stable/build_command/?highlight=target#target-syntax)
05:20:40 <quchen> So you’re trying to map fun over the »tail« function.
05:20:51 <quchen> ptek: In your defense, it’s not very intuitive.
05:21:25 <quchen> Thanks for telling me that it’s called »target syntax«, I’ll have it easier next time hehe
05:22:21 <lyxia> deepfire: http://lpaste.net/351562
05:23:35 <novakboskov> AndreasK: It seems like I should spend some time with Hoolge and it's search options. Thanks.
05:23:43 <deepfire> lyxia: thank you a lot!
05:23:45 <quchen> deepfire: If you’re interested in Hindley-Milner in general this might be interesting for you: https://github.com/quchen/articles/tree/master/hindley-milner#readme
05:24:10 <quchen> deepfire: You can do type inference in an ad-hoc way on paper, or read about a handful of simple rules that always work. :-)
05:26:08 <ocharles_> Any idea why `cabal haddock` is generating documentation for modules that aren't in `exposed-modules`?
05:26:21 <ocharles_> It's confusing to see modules that people can't actually import in my documentation...
05:27:15 <deepfire> lyxia: on my own I have got to line 16, but then I have decided to analyse the whole type, not (a -> c) !
05:27:22 <deepfire> lyxia, thank you again!
05:27:48 <deepfire> quchen: will take a look, thanks!
05:31:40 <kuba-orlik> quchen: I've moved some brackets around, now the function compiles but it throws an error when run... http://pastebin.com/SRJpE4Yv What else should I improve? I feel like I'm missing something crucial
05:34:05 <quchen> kuba-orlik: [fun head(list)] ++ ((map2 fun) tail(list))   means  [fun head list] ++ (map fun tail) list. In the [...] for example, what you want to do is to apply »fun« to the head of the list, but what you do is to apply »fun« to the »head« function (and the result of that to »list«).
05:34:33 <quchen> In other words, the parentheses are off. Other than that it looks conceptually correct already. :-)
05:35:14 <quchen> In other words, you’re doing   (f g) x   but you want   f (g x).
05:35:51 <quchen> fun head(list)  ===  fun head (list) === fun head list === (fun head) list
05:36:19 <quchen> Remember that parentheses don’t act like in other languages that use them to apply functions to arguments. Space does that in Haskell.
05:37:15 <quchen> »f x« is exactly the same as »f (x)« to the compiler. :-
05:37:16 <quchen> )
05:37:21 <kuba-orlik> Whoah
05:37:26 <kuba-orlik> I see
05:37:41 <kuba-orlik> hmmm
05:38:00 <kuba-orlik> but wait
05:38:19 <kuba-orlik> why is `(+) 2 3` correct, but `(+) (2,3)` not, then?
05:38:50 <liste> kuba-orlik: (2,3) is a single value
05:38:54 <quchen> (+) (2,3) means "apply the plus function to a single argument, namely the tuple (containing 2 and 3)«.
05:39:17 <kuba-orlik> Oh, that's right
05:39:34 <Profpatsch> :exf Maybe a -> MaybeT IO a
05:40:02 <Profpatsch> ,exf Maybe a -> MaybeT IO a
05:40:26 <quchen> kuba-orlik: Let’s fix your map function now. You’ve got »list«, »head« which gives you the first element of a (non-empty) list, and »fun« which transforms some element.
05:40:42 <kuba-orlik> quchen: yep
05:40:45 <quchen> kuba-orlik: What’s left is comining those in the right way to get »fun applied to the head of the list«.
05:41:06 <Profpatsch> I always forget what the command for exference bot was.
05:41:08 <quchen> Once you have that the part after the ++ is probably going to fall into place as well. :-)
05:41:34 <kuba-orlik> is it `fun (head list)`?
05:41:54 <quchen> > even (head [1,2,3])
05:41:56 <lambdabot>  False
05:42:08 <quchen> > id (head [1,2,3])
05:42:10 <lambdabot>  1
05:42:13 <quchen> Looks good, hm?
05:42:18 <kuba-orlik> yea
05:42:27 <kuba-orlik> soo what to parentheses do, exactly?
05:42:41 <quchen> kuba-orlik: Group stuff together
05:42:55 <quchen> kuba-orlik: If I change my parentheses, what happens?
05:43:12 <quchen>  (even head) [1,2,3]
05:43:23 <quchen> That applies the even function to the head function. That won’t work.
05:43:26 <kuba-orlik> you apply [1,2,3] to function (even head)
05:43:29 <quchen> Functions aren’t even or odd.
05:43:35 <kuba-orlik> I think I got it! http://pastebin.com/BQxVa33i :D
05:43:57 <jchia_1> Is it possible to have strict tuples natively, i.e. without using any special package?
05:44:01 <quchen> kuba-orlik: Good job! That works. :-)
05:44:57 <quchen> kuba-orlik: If you remember that function application is left-associative, you can omit one pair of parentheses in that solution. »(f g) x = f g x«
05:45:36 <quchen> So then it reads   map2 fun list = [fun (head list)] ++ map2 fun (tail list)
05:45:48 <quchen> A bit easier on the eyes already.
05:46:37 <quchen> Let’s continue refactoring this, shall we? Concatenating a single element onto the front of a list is known as »cons«, written »:« in Haskell. So instead of »[x] ++ stuff« you can write »x : stuff«.
05:47:23 <quchen> jchia_1: Depends on what you mean with natively. You can always reimplement strict tuples yourself instead of using a package.
05:47:47 <kuba-orlik> quchen: so `++` is equivalent to `:`?
05:47:49 <quchen> jchia_1: Strict data constructors (banged fields, like data Tuple = Tuple !Int !Int) are standard Haskell 98
05:47:59 <jchia_1> i know i can do data MyPair = MyPair !Int !Int. I'm talking about something even more like a tuple, where i can use fst and snd
05:48:11 <eronizz> I am starter.
05:48:16 <quchen> kuba-orlik: No, ++ puts two lists together, : puts a single element onto the front
05:48:19 <quchen> :t (:)
05:48:19 <eronizz> what is the meaning of this? (||) :: Bool -> Bool -> Bool 
05:48:21 <lambdabot> a -> [a] -> [a]
05:48:21 <quchen> :t (++)
05:48:23 <lambdabot> [a] -> [a] -> [a]
05:48:48 <quchen> > 1 : [2,3,4]
05:48:51 <lambdabot>  [1,2,3,4]
05:48:58 <quchen> > [1,2,3] ++ [4,5,6]
05:49:01 <lambdabot>  [1,2,3,4,5,6]
05:49:18 <lyxia> eronizz: it means (||) is a function which takes two boolean arguments and the result is a boolean.
05:49:37 <kuba-orlik> quchen: that's really elegant!
05:49:40 <quchen> jchia_1: You can defined your own fst and snd functions on your new tuple type.
05:49:50 <quchen> kuba-orlik: We’re not done yet :-)
05:49:53 <jchia_1> quchen: then i get ambiguous fst and snd
05:50:01 <eronizz> lyxia: tnx. what is the -> in haskell?
05:50:05 <quchen> jchia_1: Sure, you’ll have to invent new names.
05:50:10 <eronizz> "->"
05:50:13 <kuba-orlik> quchen: So if I understood correctly: parentheses force their content to be "evaluated" first, right?
05:50:31 <kuba-orlik> and the result of the evaluation is kept in their place
05:51:02 <lyxia> eronizz: it's the function type
05:51:16 <quchen> kuba-orlik: Well, it’s like in other languages, pretty much. Only that function application does not need parentheses or commas. In Javascript, you would write fun(head(list)).
05:51:42 <quchen> kuba-orlik: add(2, add(4,5)) in Javascript would read »add 2 (add 4 5)« in Haskell.
05:53:05 <quchen> kuba-orlik: I don’t think it’s correct or helpful to think about parentheses forcing evaluation.
05:53:41 <kuba-orlik> ok, so they group things
05:53:48 <quchen> Yup, just like in math.
05:54:13 <kuba-orlik> ok, so we can make the map2 function even more elegant? :D
05:54:21 <nitrix> "Forcing evaluation" is also wrong to say in a lazy evaluated language.
05:54:23 <quchen> »fun (head list)« applies »fun« to a single value, namely »head list«.
05:54:44 <quchen> kuba-orlik: Are you familiar with pattern matching on lists?
05:55:01 <kuba-orlik> `map2 fun (h:t) = ...?`
05:55:05 <quchen> kuba-orlik: Exactly
05:55:15 <kuba-orlik> wait, don't tell me!
05:55:17 <quchen> You can use that to write map.
05:55:21 <quchen> Not telling you :-)
05:55:57 <kuba-orlik> http://pastebin.com/TDkwVpw0
05:56:10 <quchen> ?src map
05:56:10 <lambdabot> map _ []     = []
05:56:10 <lambdabot> map f (x:xs) = f x : map f xs
05:56:14 <quchen> :-)
05:56:44 <quchen> kuba-orlik: That’s the elegant end result I promised you. :-)
05:56:54 <quchen> Congrats :-)
05:57:06 <kuba-orlik> thank you! :D
05:57:19 <kuba-orlik> One more thing: Is there a way to see the source of a function inside, say, ghci?
05:57:31 <quchen> kuba-orlik: Not in GHCi, unfortunately.
05:57:49 <nitrix> It's not possible. Even lambdabot uses a hardcoded file.
05:57:51 <quchen> But you can as lambdabot in here (or a private session via /msg lambdabot), it has a lot of functions stored in readable notation.
05:58:24 <quchen> kuba-orlik: Or you can look the function up in the Hackage documentation and click on »source«, but sometimes that’ll yield you a performant but hard to read implementation.
05:58:36 <nitrix> quchen: kuba-orlik: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source
05:58:42 <quchen> kuba-orlik: Exercise, write the »filter« function!
05:58:55 <quchen> > filter (> 4) [1,5,7,3,5,5]
05:58:58 <lambdabot>  [5,7,5,5]
06:01:09 <nitrix> filter' p xs = [x | x <- xs, p x] -- Am I cheating :) ?
06:01:09 <kuba-orlik> quchen: http://pastebin.com/2xZSGJWZ
06:02:12 <nitrix> kuba-orlik: Have you seen guards yet?
06:02:43 <kuba-orlik> nitrix: nope! is it something relating to recursion?
06:02:47 <quchen> kuba-orlik: Yep, that works! With guards we could make it a tad prettier, but other than that it’s good
06:02:56 <nitrix> kuba-orlik: You're able to subdivide your function body base on a predicate.
06:03:10 <quchen> kuba-orlik: Guards are basically a nicer way to write »if« in patterns.
06:03:18 <quchen> ?src filter
06:03:19 <lambdabot> filter _ []     = []
06:03:19 <lambdabot> filter p (x:xs)
06:03:19 <lambdabot>     | p x       = x : filter p xs
06:03:19 <lambdabot>     | otherwise = filter p xs
06:03:30 <quchen> Those vertical pipes that check cases are called guards.
06:03:49 <quchen> I’m sure your resource is going to cover it soon, if you haven’t seen them yet don’t worry about them.
06:03:53 <nitrix> otherwise = True
06:04:22 <kuba-orlik> what are the benefits of using guards?
06:04:40 <roxxik> looks nicer
06:05:06 <kuba-orlik> could you explain their syntax?
06:05:32 <kuba-orlik> I'm lost on what '=' and 'otherwise' are doing there, syntactically speaking
06:05:40 <nitrix> kuba-orlik: You know how you already can have multiple body implementation for a function if you have pattern matching (for each pattern) ?
06:06:16 <mizu_no_oto_work> kuba-orlik: things after the  = are the function body.  Between the | and the = is some boolean expression
06:06:18 <kuba-orlik> yeah, just as I had two body implementations for map2, depending on whether or not the list was empty, right?
06:06:28 <nitrix> kuba-orlik: Similarly, you can subdivide such body based on an expression that must yield a Bool value, and you give each of those an implementation. It's the very same concept.
06:06:47 <nitrix> kuba-orlik: The only difference is that we're using guards for one of the pattern matching case.
06:06:58 <dramforever> Lightweight 'if'
06:07:10 <roxxik> you can rewrite the last case as: filter p (x:xs) = if p x then x : filter p xs else filter p xs
06:07:12 <mizu_no_oto_work> You could also write this as `filter p (x:xs) = if px then x : filter p xs else filter p xs`
06:07:52 <mizu_no_oto_work> Guards tend to look nicer than nested if-else if branches when you start dealing with a number of conditions
06:08:24 <Tuplanolla> Guards are even better than `if`, because they backtrack pattern matches on failure.
06:08:25 <quchen> kuba-orlik: You can read the »filter« with guards like this, http://lpaste.net/351563
06:09:15 <thatguy> how would I get a list of substrings of length n of a string, for example I want to get "He", "el", "ll", "lo" from "Hello" (substring length 2)
06:09:59 <Ferdirand> > let slice n = map (take n) . takeWhile (not.null) . iterate (drop n) in slice 2 "Hello"
06:10:07 <lambdabot>  mueval-core: Time limit exceeded
06:10:07 <lambdabot>  mueval: ExitFailure 1
06:10:10 <kuba-orlik> Tuplanolla "Guards are even better than `if`, because they backtrack pattern matches on failure." - what does it mean?
06:10:36 <quchen> thatguy: have a look at »tails«.
06:10:38 <dramforever> > let substrings str = zipWith (\x y -> [x, y]) str (tail str) in "Hello"
06:10:40 <quchen> > tails "hello"
06:10:41 <lambdabot>  "Hello"
06:10:43 <lambdabot>  ["hello","ello","llo","lo","o",""]
06:10:55 <Ferdirand> oh sorry misread what you wanted
06:10:55 <dramforever> Forget about
06:11:01 <dramforever> Forget about it
06:11:03 <roxxik> > iterate (drop 2) "Hello"
06:11:06 <lambdabot>  ["Hello","llo","o","","","","","","","","","","","","","","","","","","","",...
06:11:10 <dramforever> > let substrings str = zipWith (\x y -> [x, y]) str (tail str) in substrings "Hello"
06:11:11 <roxxik> meh
06:11:12 <lambdabot>  ["He","el","ll","lo"]
06:11:25 <quchen> ?socratic
06:11:25 <lambdabot> Unknown command, try @list
06:11:29 <dramforever> Uh
06:11:30 <quchen> ?quote socratic
06:11:30 <lambdabot> chrisdone says: It's actually impossible to employ the socratic method in here. Ask a newbie a question and it *will* be answered by someone else.
06:11:45 <dramforever> You can
06:11:59 <dramforever> the newbie won't understand any of the other solutions
06:12:02 <Tuplanolla> You can have a pattern that's only matched when a condition is met, kuba-orlik. Consider `case e of Left x | x /= 0 = ... | Left x = ... | Right y = ...`.
06:12:05 <nitrix> > filter ((==2) . length) $ map (take 2) $ tails "Hello"
06:12:08 <lambdabot>  ["He","el","ll","lo"]
06:12:09 <dramforever> And I failed :(
06:12:44 <nitrix> thatguy: substrings n str = filter ((==n) . length) $ map (take n) $ tails str
06:13:00 <systadmin> hi
06:13:02 <thatguy> wow thanks guys
06:13:09 <kuba-orlik> Ok, I'm going back to studying. quchen, nitrix, mizu_no_oto_work, Tuplanolla - Thank you all for your help! You're lovely people :)
06:13:11 <thatguy> nitrix, your solution is very nice
06:13:21 <quchen> Boooo unnecessary use of »length«
06:13:38 <nitrix> thatguy: Assuming GHC does fusion. Otherwise it's a little wasteful to check the length twice.
06:13:39 <dramforever> I think I can calculate a nice 'take' for that...
06:13:54 <quchen> Exercise: drop the last N elements from a (possibly infinite) list.
06:13:55 <dramforever> I don't think GHC can do this fusion
06:13:58 <nitrix> thatguy: I'd personally write my own foldr if I had to.
06:14:43 <thatguy> quchen, is that possible without the function eventually failing if applied to an infinite list
06:15:24 <thatguy> nitrix, from my very limited haskell experience I somehow often have the feeling that expressions are evaluated tons of times
06:15:34 <thatguy> or at least how I am solving stuff at the moment
06:16:17 <thatguy> if I for example have to words some sentence I will do that once in the guards statement to check if it fullfils some condition and then again in my return statement to extract something
06:16:41 <nitrix> thatguy: The function I gave will work on infinite lists.
06:16:47 <quchen> thatguy: Well, dropping the last N elements of an infinite list is going to give you the same list of course.
06:16:55 <nitrix> Try `substrings 2 (cycle "abc")`
06:17:10 <quchen> But it won’t crash if you only ask for the first 2 elements of the infinite list where you dropped the last 4 elements.
06:17:18 <Phillemann> Scotty has "param" to read parameters, but I see no way of specifying optional parameters.
06:17:29 <quchen> »take (length xs - 2) xs« will fail to give you anything if xs is infinite.
06:17:46 <thatguy> quchen, so you would have to look ahead n steps on every call to your edited list?
06:18:07 <Ferdirand> > transpose . take 2 . tails $ "hello"
06:18:10 <lambdabot>  ["he","el","ll","lo","o"]
06:18:59 <quchen> nitrix: I think thatguy was referring to my drop-N-elements-off-end-of-a-list exercise, not your substrings solution.
06:19:00 <Ferdirand> ah damn you transpose
06:19:17 <tdammers> quchen: the dropEnd implementation from base should do right? ;)
06:19:24 <nitrix> quchen: It's informative either way :)
06:19:29 <systadmin> How is everyone? :)
06:19:43 <quchen> tdammers: We have a dropEnd in base?
06:19:46 <quchen> That’s new
06:20:55 <quchen> thatguy: No, not on every call. It’s a perfectly defined, well-behaved ordinary list.
06:21:19 <quchen>  dropEnd 3 [1..10] = [1..7]
06:21:23 <quchen>  dropEnd 3 [1..] = [1..]
06:21:48 <Tuplanolla> @src dropEnd
06:21:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:22:33 <quchen> Verbose solution with lots of explanations here: https://github.com/quchen/articles/blob/master/useful_techniques.md#avoiding-length-in-list-functions
06:22:44 <Tuplanolla> That's a shame. The short implementation is delightful.
06:23:02 <Tuplanolla> :t ap (zipWith const) . drop
06:23:04 <lambdabot> Int -> [c] -> [c]
06:23:22 <tdammers> I thought we did, hmm
06:23:31 <quchen> Looks completely unreadable to me.
06:24:01 <quchen> I still haven’t seen an intuitive use of the (->) Reader.
06:24:53 <tdammers> quchen: you're right, we don't; it's in `extra`: http://hackage.haskell.org/package/extra-1.5.1/docs/src/Data.List.Extra.html#dropEnd
06:25:26 <nitrix> > map (take 2) . init . tails $ "Hello"
06:25:30 <lambdabot>  ["He","el","ll","lo","o"]
06:25:36 <nitrix> Grr.
06:26:03 <nitrix> > map (take 2) . init . init . tails $ "Hello"
06:26:06 <lambdabot>  ["He","el","ll","lo"]
06:26:12 <nitrix> That's clean, right?
06:26:28 <thatguy> quchen, thanks for the link
06:26:35 <thatguy> it is quite interesting
06:26:38 <quchen> For some value of »clean«, yes.
06:27:10 <nitrix> I think it's better than the former `filter ((==2) . length)`.
06:27:32 <Ferdirand> > [[a,b] | (a:b:_) <- "hello"]
06:27:35 <lambdabot>  error:
06:27:35 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[t]’
06:27:35 <lambdabot>      • In the pattern: a : b : _
06:27:48 <Ferdirand> > [[a,b] | (a:b:_) <- tails "hello"]
06:27:50 <lambdabot>  ["he","el","ll","lo"]
06:28:10 * quchen liked dramforever’s solution.
06:28:16 <nitrix> I was trying to do that with an external function similar to dropEnd, but that's a clever one!
06:28:21 <nitrix> Well done Ferdirand :)
06:28:37 <nitrix> I'm all for Ferdirand's one :P
06:29:12 <Ferdirand> nah, it doesn's scale to >2
06:29:18 <nitrix> The only problem is that yours and mine don't scale really well over different values of `n`.
06:29:41 <Ferdirand> maybe there is still something to be done with transpose
06:29:52 <nitrix> I guess I can do multiple application of init.
06:30:10 <nitrix> I wonder if GHC fusion that :o
06:35:14 <eschnett> i’m experimenting with repa <https://hackage.haskell.org/package/repa>. i want to define my own datatype and store it in a repa array.
06:35:24 <eschnett> it works, but the amount of boilerplate is surprising: <http://lpaste.net/351564>
06:35:33 <eschnett> am i doing something wrong?
06:36:37 <Tuplanolla> > fmap (toListOf each) . ap zip tail $ "hello"
06:36:40 <lambdabot>  ["he","el","ll","lo"]
06:36:43 <MarcelineVQ> > let initN n = iterate (init .) id !! n in (\x -> map (take x) . initN x . tails) 3 "Hello"  -- scalable init :>
06:36:46 <lambdabot>  ["Hel","ell","llo"]
06:37:14 <Tuplanolla> There's some more reader for you, quchen.
06:42:16 <Boomerang> > let f m = foldr (zipWith (:)) (repeat []) . take m . tails in f 3 "hello"
06:42:19 <lambdabot>  ["hel","ell","llo"]
06:43:12 <Tuplanolla> There's the fold and it's very nice indeed.
06:44:42 <Tuplanolla> What's next? A `hylo alg coalg` solution?
06:45:04 <nitrix> Zygohistomorphic Prepromorphisms!
06:45:17 <nitrix> Tuplanolla: What's hylo?
06:48:44 <Profpatsch> Hm, liftIO :: IO a -> MaybeT IO a   is easy
06:48:56 <Profpatsch> But what is Maybe a -> MaybeT IO a ?
06:49:39 <lyxia> hoist under disguise?
06:50:20 <wz1000> :t lift
06:50:22 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
06:51:11 <Profpatsch> maybeT.lift
06:51:18 <Profpatsch> :t maybeT.lift
06:51:20 <lambdabot> error:
06:51:20 <lambdabot>     • Variable not in scope: maybeT :: t0 m a -> c
06:51:21 <lambdabot>     • Perhaps you meant ‘maybe’ (imported from Data.Maybe)
06:51:21 <lyxia> http://hoogle.haskell.org/?hoogle=hoist&scope=set%3Astackage
06:51:27 <Profpatsch> :t MaybeT.lift
06:51:30 <lambdabot> error:
06:51:30 <lambdabot>     Not in scope: ‘MaybeT.lift’
06:51:30 <lambdabot>     No module named ‘MaybeT’ is imported.
06:51:35 <Profpatsch> :t MaybeT . lift
06:51:37 <Profpatsch> darn
06:51:37 <lambdabot> error:
06:51:37 <lambdabot>     • Data constructor not in scope: MaybeT :: t0 m a -> c
06:51:37 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
06:51:38 <wz1000> :t MaybeT . fmap return
06:51:41 <lambdabot> error:
06:51:41 <lambdabot>     • Data constructor not in scope: MaybeT :: f (m0 a) -> c
06:51:41 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
06:51:51 <Profpatsch> Something like that.
06:53:48 <Profpatsch> Ah, MaybeT . pure
06:57:39 <grazie> when, in ghci, I do `partition (<=3) [3,4,1,20]` I get ([3,1],[4,20]), however, when I do `tops 3  [3,4,1,20]`  in this program, it gives me [1],[4,20] when I inspect the intermediate result in ghci https://github.com/liuxinyu95/AlgoXY/blob/algoxy/search/nth_element/NthElem.hs#L32
06:58:05 <grazie> can anyone please tell me why? ^
06:59:52 <mniip> grazie, that program runs 'partition (<=3) [4,1,20]
06:59:53 <mniip> '
07:01:15 <grazie> mniip: oops, thank you, that's an important detail!
07:03:21 <reactormonk> stack image container adds the current directory to the docker image - but I don't want that. Any way to disable it?
07:07:16 <unclechu> hi there. how do I specify lts version for stack new command?
07:08:31 <reactormonk> Ah nope, it's just hardcoded in :-/
07:13:14 <reactormonk> ah, works as expected.
07:28:38 <laz> unclechu: stack --resolver=lts-7.15 new ...
07:30:29 <unclechu> laz: thanks!
07:45:56 <Profpatsch> I can’t use [] as a -> [a], right?
07:46:22 <kadoban> (:[]) you can
07:46:44 <Gurkenglas> Anyone know what caused this? https://www.reddit.com/r/haskell/comments/5p1y09/code_review_hobby_package_would_like_some_feedback/dcs1lhl/?context=3#dcs10n5
07:46:58 <Profpatsch> kadoban: heh
07:47:10 <byorgey> good old robot monkey operator
07:47:25 <jophish> I never knew it was a *robot* monkey
07:47:38 <byorgey> (:()) is a normal monkey
07:47:57 <jophish> (:{)) is a moustache monkey
07:48:29 <byorgey> right.  and both of those are ill-typed because you can't trust real monkeys.
07:48:48 <jophish> makes sense
07:50:03 <Darwin226> Hey guys. If I have code like `forever $ do { something; threadDelay (10 minutes) }`, how is it possible that I'm leaking memory? Every 10 minutes the memory usage increases.
07:50:38 <NextHendrix> >> is mr pointy arrow
07:51:02 <byorgey> Darwin226: what's in the 'something'? Any IORefs?
07:52:55 <Darwin226> Hmm, no. I'm creating a database connection, getting something from the db and doing some processing on the  result
07:53:17 <Darwin226> But even if I did make IORefs, wouldn't it be enough that those refs are created within the scope?
07:53:25 <byorgey> Darwin226: what kind of processing?  What happens to the result?
07:53:55 <byorgey> Darwin226: I meant any IORefs created outside the scope of the 'forever'
07:54:01 <Darwin226> No, no iorefs
07:54:07 <Darwin226> the processing doesn't make any results
07:54:11 <Darwin226> it's in a mapM_
07:54:24 <Darwin226> i've even done !_ <- mapM_ ...
07:54:33 <Darwin226> to be sure that the unit doesn't accidentaly hold on to anything
07:54:49 <byorgey> right.  hmm, I don't know.
07:55:10 <Darwin226> but even if the unit did hold on to anything... Each forever iteration should forget about the last one, right?
07:55:17 <Tuplanolla> Try making a heap plot with the profiler and see what type takes up all the space, Darwin226.
07:55:46 <Darwin226> Yeah, I'll do that next I guess, but I need to recompile a lot of stuff if I want to profile
07:55:55 <Darwin226> and it's on a relatively weak server
07:55:57 <byorgey> Darwin226: I would think so.  But I don't know for sure.
07:56:50 <hexagoxel> Darwin226: maybe you are running into https://ro-che.info/articles/2017-01-10-nested-loop-space-leak ?
07:57:59 <Darwin226> Hmm, maybe. I'll try no full lazyness to see if it does anything
07:58:10 <Tuplanolla> It could also be caf inflation.
07:58:42 <Tuplanolla> Do you have any lazy top-level values that could get cached?
08:00:43 <Darwin226> The whole module is just imports and a main function
08:00:44 <Darwin226> http://lpaste.net/7434516315529805824
08:01:39 <Darwin226> It connects to email addresses using IMAP and processes emails. The leak is pretty large. Accumulates to gigabytes withing an hour or two
08:01:59 <Darwin226> it sounds like the emails aren't getting cleared for some reason
08:02:28 <Tuplanolla> My expertise ends here.
08:04:34 <hexagoxel> "createPostgresqlPool :: [..] - Create a PostgreSQL connection pool. Note that it's your responsibility to properly close the connection pool when unneeded. Use withPostgresqlPool for an automatic resource control."
08:04:44 <hexagoxel> rtfm
08:04:50 <hexagoxel> seriously :p
08:05:04 <ph88> anyone know how to add a stack template ?
08:05:08 <Darwin226> On the other hand, one connection every 10 minutes doesn't ammount to gigabytes
08:05:46 <Tuplanolla> You'd think that, but it might hold on to all intermediate values, Darwin226.
08:06:09 <Darwin226> I hope you're right.
08:07:48 <ph88> i saw a folder ~/.stack/templates can i just put my own templates there ?
08:10:29 <Darwin226> For what it's worth: https://hackage.haskell.org/package/groundhog-postgresql-0.7.0.2/docs/Database-Groundhog-Postgresql.html
08:10:34 <Darwin226> My manual is lacking
08:17:47 <Profpatsch> There’s nothing like MaybeT :: m (Maybe a) -> MaybeT m a for a general n, right?
08:17:50 <hexagoxel> Darwin226: fair, although the existence of "with.." could warn you.
08:17:58 <Profpatsch> :: m (n a) -> n (m a)
08:18:35 <Profpatsch> Ah, mmorph
08:18:42 <Faucelme> Traversable?
08:18:45 <Profpatsch> For transformers where this works.
08:18:50 <hexagoxel> Profpatsch: those kinds don't match up though
08:19:09 <Profpatsch> hexagoxel: Course they ,o
08:19:16 <Profpatsch> m, n :: * -> * 
08:19:22 <hexagoxel> :k MaybeT
08:19:25 <lambdabot> error:
08:19:25 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
08:19:25 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
08:19:38 <cocreature> :t traverse id
08:19:40 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
08:19:44 <cocreature> ^ Profpatch
08:19:52 <Tuplanolla> :t sequenceA
08:19:54 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:20:41 <nshepperd1> Traversable and Distributive
08:22:06 <Faucelme> But they only work when m is some sort of container.
08:22:12 <byorgey> m (n a) -> n (m a)  is very different than   m (Maybe a) -> MaybeT m a
08:22:38 <Faucelme> Ah, you are right.
08:22:42 <Profpatsch> Oh, right.
08:22:52 <Profpatsch> hexagoxel: You were right of course.
08:24:02 <Profpatsch> I see why it’s hard, since e.g. for ExcepT: m (Either e a) -> ExceptT e m a
08:24:10 <Profpatsch> Where the kind is different again.
08:27:29 <byorgey> Profpatsch: well, that's not all that different, there  Either e / ExceptT e  are playing the same roles as  Maybe / MaybeT
08:28:11 <byorgey> but in any case, I don't know of anything to do this generically.
08:29:26 <ph88> does ghci depend on base? when i load ghci without base i get this error:  Not in scope System.IO.hSetBuffering
08:30:54 <byorgey> ph88: yes
08:31:06 <byorgey> you have just proved that it does.
08:31:45 <ph88> when i import System.IO in my .ghci file it doesn't pick up on that and i still get the error
08:32:32 <byorgey> ph88: also, what do you mean by "load ghci without base"?
08:32:46 <ph88> i use this command: stack ghic
08:32:49 <ph88> stack ghci
08:32:56 <ph88> but i didn't require base in the cabal file
08:33:57 <byorgey> interesting.  But if base is not required in the .cabal file, it will be hidden, and even if you try to import a module from it in your .ghci file it will still not be able to find it.
08:34:31 <byorgey> ph88: why did you not require base?  Are you trying to use an alternate prelude or something like that?
08:35:33 <ph88> yes i'm trying to make a stack template for an alternative prelude
08:36:18 <byorgey> hmm, I think you will still need to require base.  But you can just turn on NoImplicitPrelude or whatever and import the alternate prelude
08:36:26 <janosp> Hi, has anybody experience with building a haskell webservice with stack and then deploying it in a docker container?
08:36:50 <janosp> has maybe anybody a good blogpost about that?
08:37:09 <ludat_> doesn't stack have support for that? never used it though
08:37:14 <cocreature> janosp: there is not really much to write about. just write your web service and then use "stack image container" to build your image
08:37:31 <janosp> oh, really? OK thanks!
08:37:48 <janosp> cocreature: thanks, I'll look into the doc of this command
08:38:13 <cocreature> janosp: you can take a look at the end of my stack.yaml http://sprunge.us/MZhe
08:40:48 <janosp> I've read a blogpost from FP Complete where they reduced the docker image to 5/20MB. Is it feasible to use their base?
08:40:59 <janosp> or won't that work?
08:42:21 <ph88> when is Setup.hs run ?
08:42:26 <ph88> especially in relation to stack
08:43:34 <cocreature> janosp: dunno, I haven’t botherd to reduce image size
08:46:38 <wespiser> @unmtl ReaderT EnvCtx IO a 
08:46:38 <lambdabot> EnvCtx -> IO a
08:49:18 <romano> hi guys
08:49:21 <romano> does anyone have experience making sessions persistent between restarts in the Spock framework?
08:54:49 <quchen> ph88: Add a »putStrLn "foo"« to it and see for yourself :-)
08:56:38 <ph88> that are some fancy markings !
08:57:31 <quchen> Shift-4 and shift-5 for me ;-)
09:21:49 <ph88> which package should i use if i want to read a big file and then while keep reading the file swap some bytes around and write another file at the same time? i would like to prevent to load the entire file in memory first
09:31:34 <kadoban> ph88: pipes or conduit I think
09:32:53 <glguy> ph88: Depending on what you're doing it might be OK just to open a Handle and read chunks of the file, perform your operation, and write the resulting chunk to another Handle
09:37:30 <mmachenry> Hey glguy, not sure if you're interested, but I found a constraint predicate from a paper that does exactly what I need to make my code more performant. I think it's not implemented in Haskell or even in Prolog's CLP(FD). I am working on understanding the algorithm now so I can add it to Haskell's fd.
09:37:34 <mmachenry> Thanks for the help.
09:37:52 <glguy> Oh, neat. How'd you find that?
09:40:23 <mmachenry> A bunch of fruitless Google searching for phrases like "constraint programming exactly n elements" and then finally finding something promising in conference proceedings. 
09:41:00 <mmachenry> This is what I need and will potentially write up for the library: http://web.emn.fr/x-info/sdemasse/gccat/Camong.html
09:41:52 <mmachenry> Anyway thanks for the help.
10:10:05 <janosp> Hi, I want to build a docker container from my Stack project, but get the error Running /usr/local/bin/docker inspect fpco/stack-build:lts-7.16 exited with ExitFailure 1
10:10:46 <janosp> []  Error: No such object: fpco/stack-build:lts-7.16
10:10:56 <janosp> Anybody an idea, what is wrong?
10:12:25 <bengt_> its trying to inspect an image that you don't have I guess
10:13:25 <janosp> mhm
10:13:26 <bengt_> try stack docker pull
10:13:34 <janosp> ok
10:15:19 <danza__> hey #haskell, how would you call a data structure similar to a map, but where a value can be associated to multiple keys?
10:16:09 <Cale> Isn't that like a usual Map?
10:16:43 <Cale> Or did you mean a key can be associated to multiple values?
10:16:53 <Cale> Perhaps you want Map k (Set v)?
10:16:57 <danza__> hum ... many to many, actually
10:17:34 <danza__> i am thinking of an implementation for overlapping categories (labels, tags?)
10:18:01 <danza__> whew i realise that categories is a very bad word to use in this channel for this ...
10:18:46 <ertes> danza__: do you want to have an efficient way to get all keys a certain value is associated to?
10:19:08 <danza__> more all values a key is associated to
10:19:22 <ertes> danza__: then what Cale said:  Map k (Set a)
10:19:44 <danza__> this way you can't have an element belonging to two keys
10:19:52 <ertes> why not?
10:20:02 <danza__> i think that i'm trying to implement overlapping sets
10:20:11 <danza__> with efficient intersections
10:20:20 <nshepperd1> Sure you can. Just add the values to two sets
10:20:30 <janosp> stack docker pull seems to work thanks :)
10:21:26 <ertes> danza__: first you need to clarify what intersection means, but most likely this, which is efficient:
10:21:29 <ertes> :t M.intersectionWith S.intersection
10:21:31 <lambdabot> (Ord a, Ord k) => M.Map k (S.Set a) -> M.Map k (S.Set a) -> M.Map k (S.Set a)
10:22:39 <danza__> right but here i still need to make sure that elements belonging to different sets are updated consistently. In other words, maybe the data structure i'm thinking of is not commonly used or known
10:22:53 <ertes> danza__: what's the use case?
10:23:31 <danza__> for example: `Tagged Category Package`, where category is one of the categories of Hackage, and Package is a package
10:23:51 <ertes> and you want to implement removal of a package?
10:23:54 <danza__> it represents overlapping descriptors ... i was thinking to call it called
10:24:08 <danza__> more update of a package, querying etcetera
10:24:22 <danza__> sorry, to call it "Tagged"
10:24:28 <ertes> you can use ixset, which gives you relations
10:24:29 <cocreature> danza__: you can just add an additional layer of indirections: store ids in your map and have a separate map from ids to values. then the values will always be updated together
10:24:44 <nshepperd1> If you want the elements to be modifiable, use (Map Label Int, IntMap Value)
10:24:54 <ertes> ixset is basically what cocreature said, but more generic
10:25:07 <danza__> cool, maybe ixset is what i'm looking for, thanks!
10:25:08 <ertes> it's Set with arbitrary indices
10:25:34 <danza__> sounds promising
10:25:42 <danza__> thanks ertes !
10:26:05 <danza__> (and thanks all)
10:31:49 <danza__> Hum, i think that IxSet is overkill for me, because i don't need named indexes, but just overlapping keys. I think that i will write `Tagged a b`, after all :)
10:32:14 <infandum> Has anyone used https://hackage.haskell.org/package/plots ? How does it differ from the diagrams backend of Charts?
10:32:24 <infandum> it looks very promising
10:34:47 <ertes> danza__: the word "overkill" should be scratched from programmers' vocabularies
10:35:12 <danza__> suggestions about a synonym?
10:35:39 <cocreature> unnecessarily complex? :)
10:36:07 <ertes> danza__: i mean: people will often write custom special-cased solutions and get them wrong in subtle ways, because they thought the general solution is "overkill"
10:36:11 <ertes> you know: reinventing the square wheel
10:36:24 <ertes> keeping things in sync is error-prone, and ixset does it for you
10:36:33 <danza__> of course, it's a personal assessment and one can be wrong
10:36:52 <danza__> in this case though i'm starting small, so i can afford to experiment
10:37:12 <cocreature> claiming that the more general solution is always more appropriate is just as silly as calling more general solutions overkill
10:41:04 <Philippa> if you have to write the general solution yourself, it may well be overkill in terms of complexity
10:41:59 <Philippa> and for all you can write a good song using the line "there's no kill like overkill..."? There's a lot to be said for learning precision targeting too
10:42:30 <Philippa> (disclaimer: I'm an advocate of doing just about anything of any size in applicative or monadic style as appropriate for future refactoring purposes. But I know just what I'm buying myself there)
10:45:30 <ertes> cocreature: that's not my claim…  my claim is that more often than not it's irrational to reinvent a special case solution when the general solution is free, even when the special case appears very small in comparison intuitively
10:45:51 <ertes> see, i use 'free' and 'pipes' for laughably small things
10:46:24 <ertes> i've used acid-state to keep the state of a one-off quick-n-dirty program to crunch on some data
10:46:41 <ertes> why not?  it's there and does it better than anything i would have come up with
10:47:38 <cocreature> ertes: I don’t think that the claim “the general solution is free” is true. there is always a cost associated with choosing a more general solution even if it is just the cost of somebody not understanding your code that is not familiar with an abstraction
10:48:15 <ertes> cocreature: let me call it cheap then, not free
10:48:22 <cocreature> can the costs outweigh the benefits? absolutely! but is that always the case? definitely not
10:48:56 <cocreature> eh flip costs and benefits in the first sentence
10:49:28 <ertes> hehe
10:51:02 <cocreature> sorry, I’m probably just grumpy because I have several times chosen a more general solution (i.e. a package) instead of writing a custom solution for my problem and ended up having to rewrite it because the package was not maintained actively enough
10:52:23 <ertes> cocreature: i'd probably just have forked it
10:52:52 <ertes> if you need to work on it, it's often cheaper not to wait for upstream
10:53:40 <cocreature> well if I fork I now have one more package to maintain and that package can often contain significantly more code than I need for a custom solution tailored to my problem.
10:54:03 <cocreature> I have just hard-forked a package because I got annoyed but I’m really not keen on doing that again :)
10:54:32 <ertes> cocreature: no, i mean just a local fork with your own changes…  no need to actually maintain a hackage package
11:01:17 <Philippa> ertes: we call this technical debt, just sayin'
11:04:32 <ertes> Philippa: sure, i've moved away from hakyll because of that
11:04:42 <ertes> yes, to my own special case solution =)
11:28:58 <johnw> geppettodivacin: you still here?
11:33:14 <johnw> @tell geppettodivacin The easiest way is to parse in a string like "$1,000.00".  You can add balances together with ^+^, from the 'linear' package.  Use the Plain constructor to lift an integer to a Balance with no commodity. Scalar multiplication by an integer is done with ^*.
11:33:14 <lambdabot> Consider it noted.
11:36:36 <pikajude> where is Balance defined
11:47:57 <dmwit> While pondering http://stackoverflow.com/q/41812122/791604, I started to wonder: can I introduce type variables in a type application somehow?
11:48:25 <dmwit> For example, I might want to write `coerce @_ @((a -> Bool) -> [a] -> [a]) filterM`.
11:48:34 <dmwit> But I can't do that, because of course `a` is not in scope.
11:48:58 <dmwit> And you can't just replace all the `a`s with wildcards, because that doesn't say that they're all the same variable.
11:53:37 <afldcr> yeah, no idea :/ haven't had much luck with good usecases for type applications yet
11:54:43 <dmwit> So, it seems you can do it with ScopedTypeVariables and an explicit binding. That seems quite heavyweight, though.
11:56:49 <dmwit> ...you can *sort of* do it. hm
11:57:17 <glguy> dmwit: You could do something like:   (coerce @_ @(using a and m here) :: forall a m. _)
11:57:26 <glguy> with ScopedTypeVariables and PartialTypeSignatures
11:58:04 <glguy> (id @a :: forall a. _) :: a -> a
11:58:14 <glguy> that last type signature was derived by ghci
11:59:03 <dmwit> glguy: clever!
12:00:15 <dmwit> The final term looks quite nasty. =P
12:00:27 <dmwit> coerce @_ @((a -> Bool) -> [a] -> [a]) (filterM @Identity @a) :: forall a. _
12:00:44 <Tuplanolla> That's quite the contortion.
12:01:29 <dmwit> It doesn't seem that you can omit any part of that expression, either.
12:01:52 <dmwit> (Though there may be other expressions that take a different approach that are simpler, of course, which I'd be interested in hearing about.)
12:07:51 <hackrilege> If I convert a foldable type to a list and back again, does the compiler factor this out? How does build fusion and the INLINE pragma fit into this?
12:08:11 <dmwit> Probably not, since there's no guarantee in general that this transformation is the identity.
12:08:29 <dmwit> Particular instances are free to specify this as a rewrite rule, though.
12:08:32 <Ant__> hello everybody
12:08:57 <dmwit> It's not clear to me that INLINE is related at all to this.
12:09:48 <dmwit> Build fusion is probably unrelated, since it is for lists only as far as I know, for which `toList` is probably already `id`.
12:09:58 * dmwit waves at Ant__
12:10:50 <Ant__> May someone help me with this
12:11:07 <Ant__> interpreteMot :: Config -> Mot -> Picture interpreteMot cfg mot = Line (snd etatDessin) where etatDessin = last (map (interpreteSymbole cfg (etatInitial cfg, path)) mot)
12:11:55 <Ant__> sorry
12:12:08 <Ant__> here is the function
12:12:09 <Ant__> interpreteMot cfg mot = Line (snd etatDessin) where etatDessin = last (map (interpreteSymbole cfg (etatInitial cfg, path)) mot)
12:12:50 <Ant__> the "path" variable need to change through the iterations of map
12:12:51 <dmj`> Ant__: if possible, can you paste this code on lpaste.net, ideally with type errors too. Will help us diagnose the issue better
12:13:01 <Ant__> okay thank you
12:13:32 <dmwit> :t mapAccumR -- for map-like things that need access to some state that changes as you process each element
12:13:33 <ertes> Ant__: you mean something like mapAccumL or foldr?
12:13:34 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:13:49 <dmwit> :t mapM -- or the general version, which is mapAccumR if you choose State as the monad
12:13:51 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:14:28 <ertes> > foldr (\x xs dx -> (x + dx) : xs (dx + 1)) (const []) [0,0,0,0,0] 0
12:14:31 <lambdabot>  [0,1,2,3,4]
12:15:00 <Ant__> here is the full code
12:15:01 <Ant__> http://lpaste.net/351573
12:15:58 <ertes> Ant__: is the change of 'path' at all related to the individual elements during mapping?
12:16:13 <byorgey> Ant__: is this a homework assignment?  Or just for fun?
12:16:20 <Ant__> this is homework
12:16:20 <hackrilege> What is mapM with the Writer monad?
12:16:52 <ertes> hackrilege: 'map' with an extra result channel
12:17:08 <johnw> a monoid result channel
12:17:40 <johnw> map + foldMap
12:18:18 <Ant__> yes each element is built with the previous path
12:18:59 <Ant__> within the interpreteSymbole function
12:19:37 <ertes> Ant__: i mean: can you construct a list of paths such that each path is paired with a mot at the same list position?  if yes, you can just use zipWith
12:20:10 <ertes> > zipWith (+) [1,2,3] [30,20,10]
12:20:13 <lambdabot>  [31,22,13]
12:20:23 <hackrilege> So you need the read/write of state to use the accumulator in its update... Ok
12:21:44 <hackrilege> Are there any other nice Monads to use with mapM?
12:21:52 <ertes> hackrilege: IO
12:22:26 <Ant__> thank you ertes
12:22:36 <Ant__> I will try this
12:22:39 <hackrilege> I guess that's pretty generic...
12:23:24 <ertes> hackrilege: is it?  IO may be the most special monad after Identity =)
12:24:07 <ertes> hackrilege: there is Maybe: short-circuit out of the map
12:24:57 <hackrilege> Ah that's pretty neat, is that how you approach fixed points?
12:25:02 <ertes> hackrilege: there is ContT which lets you do pretty crazy things like reverting the map to an earlier element and then map differently
12:25:22 <ertes> or register actions to be run just after the map
12:26:22 <hackrilege> Hmm, that might be useful for updating a square grid with the shadow of tree...
12:27:20 <ertes> there is a monad of my own that allows you to register reentry points to restart the map at certain points…  it's isomorphic to CofreeT from 'free'
12:28:11 <ertes> there is any free monad that lets you step through the map breakpoint-style
12:29:25 <ertes> and of course there is [], which lets you play out different choices for each map
12:29:29 <hackrilege> I was using a 2d zipper for that and was worried about the expense, I couldn't really tell how it would be handled lazily, would operations like forwards . backwards . forwards get rewritten by the compiler, or is trying to locate them as expensive as evaluating them... If that's not clear don't worry about it
12:29:37 <nshepperd1> I think the real question is, what monads aren't nice to use with traverse/mapM
12:29:41 <ertes> > traverse (\x -> [toUpper x, toLower x]) "hello"
12:29:43 <lambdabot>  ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","He...
12:30:23 <nshepperd1> The Proxy monad isn't i guess
12:30:44 <nshepperd1> If you use Const, you get foldMap!
12:30:53 <ertes> well, Identity is not too interesting either
12:31:26 <hackrilege> Can I see your monad that's like CofreeT?
12:32:07 <ertes> hackrilege: it's pre-AMP, but might still compile: https://hackage.haskell.org/package/continue
12:32:15 <hackrilege> Thanks
12:32:42 <ertes> hackrilege: you will have to adjust the dependencies though…  they are outdated
12:33:48 <hackrilege> Hey you couldn't take a look at this paste could you? http://lpaste.net/351478
12:34:20 <hackrilege> It's a work in progress also...
12:35:51 <nshepperd1> Ofc you can calculate scans with state / backwards state
12:36:39 <hackrilege> What's backwards state?
12:37:16 <seequ_> etats
12:38:48 <ertes> hackrilege: http://ertes.eu/tutorial/foldr.html#reverse-state
12:38:59 <hackrilege> Thanks
12:43:33 <hackrilege> So I basically proceed by defining instances of Stack, I'm wondering if I should write functions eg length, or if I should cast to list and use the existing implementations? Stack defined as in http://lpaste.net/351478
12:44:55 <hackrilege> It seems simply symbolic, replacing (:::) with (:), does the compiler take care of that or is there runtime cost?
12:47:37 <hackrilege> Is that the kind of thing I could write a rewrite rule for?
12:50:58 <hackrilege> Any ideas ertes?
12:53:33 <athan> What would be a good way to "listen" for a device, like a specific partition (or UUID), or just the block device name or something?
12:58:20 <athan> I could just poll lsblk, and try to mount them or something... but where's the fun in that?
13:02:55 <janosp> Hi guys, I have again a question regarding docker and stack. Has anybody experience with fpco/haskell-scratch and actually deploying a web-service with stack and docker?
13:03:23 <janosp> because I can build the docker file, but cannot run the actual service
13:04:52 <athan> Ahh, I think I need to use udev or something :x
13:05:26 <jle`> > traverse (\_ -> Proxy) [1,2,3]
13:05:30 <lambdabot>  Proxy
13:05:33 <jle`> beautiful
13:08:57 <ongy> :t traverse (const Proxy) [1..3]
13:09:00 <lambdabot> Proxy [b]
13:09:43 <ongy> :t traverse
13:09:45 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:11:15 <Tuplanolla> I made a bunch of lenses for Repa using Microlens. Where should I put them? They're now orphans.
13:11:44 <knupfer> How can I optimize a program, which is fast with profiling enabled, but slow without?
13:14:33 <ertes> hackrilege: why don't you just use []?
13:15:17 <hackrilege> Because there is a stack instance for many data types eg (Free ([],[])) which I make use of
13:16:10 <ertes> athan: the correct way is platform-dependent, but one way that works across most unix-likes is filesystem notification
13:16:32 <hackrilege> See for example the Stack instance for StackZipper in the paste
13:16:54 <ertes> athan: if your device eventually appears in a directory like /dev/disk/by-id, you could wait for it using fsnotify
13:17:08 <cocreature> Tuplanolla: how can lenses be orphans? Lens is not a typeclass
13:17:38 <Tuplanolla> I worded it badly, cocreature. I meant this thing: `instance Field1 (Z :. a) (Z :. a') a a' where _1 f (Z :. x) = fmap (\ x' -> Z :. x') (f x)`
13:17:53 <ertes> hackrilege: i don't have much experience with zippers…  never used them for anything serious
13:18:07 <hackrilege> Ok
13:18:34 <hackrilege> But the point is that all foldable containers have a stack instance
13:19:23 <athan> I was just thinking that ertes, good idea
13:19:24 <ertes> hackrilege: data V2 a = V2 !a !a  -- what's 'pop' for this one?
13:19:47 <athan> thanks. I feel like I should learn dbus though
13:19:56 <ertes> hackrilege: or even more importantly: what's 'basecase'?
13:20:04 <hackrilege> What's foldMap for it?
13:20:16 <ertes> foldMap f (V2 x y) = f x <> f y
13:20:21 <cocreature> Tuplanolla: ah ok. there is no clever solution here. you can ofc try adding your lenses to repa itself but I have no idea how open the maintainers are to that idea. otherwise you either need to live with orphans or define your own typeclass
13:21:05 <ertes> hackrilege: (Map k) is also Foldable…  what's 'push' for that one?
13:21:15 <Tuplanolla> I could make my own `Data.Array.Repa.Lens` and put them there. How about that, cocreature?
13:21:35 <cocreature> Tuplanolla: that’s the “live with orphans” solutions :)
13:22:36 <ertes> hackrilege: a stack is inherently list-like…  not every Foldable is list-like
13:22:42 <hackrilege> Ok
13:23:21 <hackrilege> I hadn't really appreciated that, there is some extensible aspect like unfold or Arbitrary, that's required
13:24:58 <hackrilege> Is "list like" the best name for this? I guess it's Alternative...
13:25:58 <ertes> Maybe is Alternative
13:26:04 <hackrilege> I think so
13:27:00 <hackrilege> That's a Monoid on Applicative Functors, though I'm not sure the Applicative superclass constraint is required...
13:27:04 <ertes> if you were to make a lazy variant of Data.Vector, that one would count as list-like
13:27:39 <ertes> if you don't like that requirement, there is the 'semigroupoids' package
13:27:48 <hackrilege> Thanks
13:28:45 <ertes> Plus is Alternative sans Applicative
13:29:19 <ertes> and there are some interesting proper Pluses:  (Map k), Event in FRP, etc.
13:29:56 <hackrilege> Yes, the Applicative instance for Map was upsetting me
13:30:31 <ertes> there is also Applicative without 'pure' in that package:  Apply
13:30:35 <hackrilege> Even for Trees the natural implementation seems bizarre
13:30:37 <ertes> Map is an instance of that one
13:30:58 <hackrilege> Ah, nice
13:30:59 <ertes> Apply corresponds to intersection, Plus corresponds to union
13:31:11 <dmwit> Map is an instance of Applicative?
13:31:17 <ertes> dmwit: of Apply
13:31:32 <ertes> from semigroupoids
13:32:01 <hackrilege> No, that's why I was upset by the Applicative constraint on Alternative.
13:32:21 <dmwit> hackrilege: You might like
13:32:23 <dmwit> ?hackage total-map
13:32:23 <lambdabot> http://hackage.haskell.org/package/total-map
13:32:33 <dmwit> Which has a real Applicative instance.
13:32:45 <dmwit> Even a Monad instance!
13:33:59 <hackrilege> I was working with something more like fgl
13:35:15 <hackrilege> http://lpaste.net/350976
13:36:09 <hackrilege> I'll add stack in to that soon
13:36:36 <hackrilege> Perhaps we should pick the discussion back up then
13:39:04 <hackrilege> I was just wondering if it was slow to use e.g. lengthS :: Stack f => f a -> Int; lengthS = length . fromStack
13:39:11 <dmwit> I am lost. There are three threads in this conversation that I thought I roughly was following: using Map as an Applicative-like; using stacks; and tree zippers. But it's not clear to me how any given pair of those three are connected to each other.
13:39:43 <dmwit> Yes, that is slow.
13:40:16 <hackrilege> We are discussing element wise construction, and Apply was suggested instead of Alternative as an Applicative instance may not be available
13:40:23 <ertes> hackrilege: either require 'length' in Stack, or require Foldable
13:40:50 <ertes> in the latter case you need to have some faith in the Foldable instance that it uses a type-specific implementation of 'length'
13:42:14 <hackrilege> There is a Foldable instance for a newtype wrapper of Stack, but I defined stackFold instead...
13:42:41 <hackrilege> http://lpaste.net/351478
13:44:11 <hackrilege> Here is the Foldable newtype http://lpaste.net/183227
13:45:05 <davide> Hi all! I'm trying to write a geometry library. Having some major issues getting my type classes/instance setup correctly
13:45:09 <davide> https://gist.github.com/DavidEichmann/d31254cc60ce794dc4abe6312f8bbbae
13:45:41 <davide> if some one can get this thing to compile, I'll be forever greatful! 
13:45:52 <hackrilege> Oh sorry, stackFold isn't on that one, my machine is installing updates so I can't update the paste now, but it's defined in the usual way
13:46:04 <janosp> hackrilege: I just looked quickly over your code at lpaste and I saw something I have never seen before : pattern Basecase <- (pop -> Nothing)
13:46:07 <janosp> was is that?
13:46:20 <janosp> I mean the definition is weird :D
13:46:28 <glguy> davide: Why do you need a multiparameter type class for this. How about: class HasRange a where getRange :: a -> Range a
13:46:46 <hackrilege> Yeah, maybe I should use the bidirectional version, is that what you mean?
13:46:56 <glguy> davide: I guess for the case on lines 21?
13:47:14 <glguy> davide: If you're getting an error you can include that in your paste
13:47:15 <hackrilege> It was my first attempt at view patterns...
13:47:36 <glguy> davide: You can respond in channel
13:48:36 <davide> glguy: Added the error as a comment in the gist 
13:49:08 <AWizzArd> I noticed that many functions in Haskell that work on data structures take them as the last arg. Is there a reason why this is so typical?
13:49:47 <hackrilege> Yes, it's to allow partial application
13:49:57 <glguy> davide: Your type for union is wrong, you need to enable UndecidableInstances for line 27, and your implemention of getRangeMay on line 29 is wrong
13:50:18 <hackrilege> > :t map (+1)
13:50:21 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:50:32 <hackrilege> (hackrilege)  :t fmap (+1)
13:50:38 <hackrilege> :t fmap (+1)
13:50:40 <lambdabot> (Num b, Functor f) => f b -> f b
13:51:12 <hackrilege> Sorry my clipboard isn't great...
13:51:18 <hackrilege> I shouldn't rush
13:51:24 <davide> glguy: isn't UndecidableInstances a bad idea?
13:51:43 <glguy> davide: No. It means sometimes if you make a mistake that the program won't finish compiling
13:51:51 <glguy> but when it does finish it's all good
13:52:00 <glguy> either way you don't have a choice if you want to write that instance
13:53:04 <glguy> davide: I think if you switched to type families instead of functional dependencies , that you wouldn't need it
13:53:33 <dmwit> davide: Besides the problem given by your error, your signature for `union` needs an extra `Range p` argument, you need a `Just` around the value of `getRangeMay (x:xs)`, and you need to apply `getRange` to `x` and `xs` in same.
13:54:13 <dmwit> glguy: You still need it. Or I do, at least, in my naive translation to type families.
13:54:26 <glguy> dmwit: Because of the Ord constraint?
13:54:29 <dmwit> glguy: right
13:55:21 <davide> Ok, I'll update the gist. got it to compile, one sec
14:01:59 <davide> glguy: so I'm trying to get the next issue to happen now :-P
14:11:05 <Earthlinger> LUL
14:14:27 <systadmin> hi
14:14:43 <lambdabot> Hello.
14:29:22 <davide> glguy: Ok, I'm back
14:29:28 <davide> https://gist.github.com/DavidEichmann/d31254cc60ce794dc4abe6312f8bbbae
14:29:46 <davide> getting an issue with overlapping instances now :-(
14:30:01 <davide> any help would be appreciated
14:30:06 <glguy> davide: you'll need to delete lines 30/31
14:30:30 <glguy> that instance will overlap with all other instances of HasRangeMay
14:32:11 <davide> glguy: that fixes the build, but I dont understand. is the context not enough to stop the overlap?
14:32:27 <glguy> No, the context isn't part of instance resolution
14:32:29 <geekosaur> context isn'ty relevant during instance selection
14:33:32 <davide> to be clear the "context" is the "HasRange p a" in "instance HasRange p a => HasRangeMay p a where"
14:33:33 <davide> right?
14:33:56 <glguy> Right. That instance says that all types of the form:  p, a have an instance
14:34:13 <glguy> and then when you try to use that instance you'll need to satisfy the context left of the =>
14:34:29 <davide> THAT! clears up a lot of questions hahaha
14:34:45 <davide> this seems like a large limitation in the type system
14:37:32 <c_wraith> it's a necessary consequence of the open world assumption. 
14:38:47 <davide> So you can't have overlapping instances? Unless you annotate them with {-# OVERLAP--- #-}
14:38:48 <davide> ?
14:39:43 <glguy> If you were scared of UndecidableInstances, hang on tight :-p
14:40:22 <davide> :-D
14:41:37 <orzo> Is there anything like GHC.Stats for runtime statistics on haskell threads?
14:42:03 <orzo> mainly i want to know the current number of threads at a given time
14:45:36 <davide> glguy: where/what should I be reading to better understand this?
14:48:26 <orzo> profiling is always disapointing.  The top cost-center and module is SYSTEM.  What's that mean?
14:48:50 <orzo> i saw the app use a lot of cpu on occassion
14:49:12 <orzo> but i don't really see that reflected in the .prof file
14:55:43 <orzo> ghc docs allude to an old concurrency debugging tool called chd (concurrent haskell debugger).  But it's a link to something that worked with ghc 5.  Is there a modern version of that?
15:10:34 <sm> orzo: does ekg report that ? also have you seen threadscope ?
15:19:02 <orzo> i've not used threadscope but my understanding is that it is offline, analyzing the eventlog
15:22:53 <geekosaur> wasn't there a recent change to make the eventlog "live"?
15:23:20 <geekosaur> at least in part to enable tools like threadscope to be usable on running programs
15:23:22 <orzo> i thought that is in a ghc fork
15:23:45 <orzo> i've too many dependency libraries to switch ghc build
15:40:07 <bsamorim> Hey guys, is there a german-speaking haskell channel?
15:40:29 <roxxik_> don't think so, but i can help you
15:40:37 <roxxik_> (in german if need be)
15:41:36 <bsamorim> Danke schön, aber ich wollte nur Deutsch und Haskell gleichzeitig üben hehe
15:41:46 <bsamorim> but thanks anyway!
15:41:51 <hexagoxel> there is #haskell.de, with a total of 1-5 non-bot members :D
15:41:56 <roxxik_> Kein Problem
15:42:07 <bsamorim> hexagoxel haha k thx!
15:43:28 <bsamorim> Is there a haskell FAQ, bordering on the off-topic (Good haskell books, good haskell open source projects, etc.) ?
15:45:32 <tommd> haskell-blah
15:45:36 <tommd> if it is still around.
15:46:02 <tommd> But those sounded to me to be on topic.
15:46:12 <bsamorim> tommd thanks!
15:46:34 <Tuplanolla> I find the off-topic channels to be way too off-topic.
15:49:18 <codedmart> Is there a << version of >> for Monad?
15:49:40 <Rembane> codedmart: You can use <*
15:49:50 <Rembane> codedmart: Or build your own from =<<
15:50:18 <codedmart> Rembane: Great thanks! Didn't know about <*
15:50:35 <Rembane> codedmart: No worries, it's neat nowadays. 
15:54:35 <AWizzArd> I have:  data Tree a = Empty | Node { value :: a, left :: (Tree a), right :: (Tree a) } deriving (Show, Read, Eq, Ord)    and now want to do:  type Leerbaum a = Node a Empty Empty    – but the compiler complains „Not in scope: type constructor or class ‘Node’”. Why is that?
15:55:18 <roxxik_> short answer: because Node is a value constructor and not a type constructor
15:55:39 <AWizzArd> Oh okay.
15:56:32 <roxxik_> better use emptyTree :: a -> Tree a; emptyTree a = Node a Empty Empty
15:56:52 <roxxik_> Tree appears on the type level
15:56:56 <roxxik_> Node on the term level
15:57:14 <AWizzArd> roxxik_: you mean the argument order?
15:57:28 <c_wraith> roxxik_, that doesn't look especially empty. 
15:57:28 <roxxik_> not exactly
15:57:34 <johnw>  does HackageBot not annouce package updates here anymore?
15:57:44 <verement> no
15:57:48 <roxxik_> sorry i just translated Leerbaum to emptytree
15:58:14 <c_wraith> johnw, it was only ever sporadic at best anyway 
15:58:15 <AWizzArd> An acceptable translation :)
15:58:56 <verement> johnw: https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125828.html
15:59:08 <johnw> verement: ah, thanks
15:59:10 <roxxik_> what do you want to do? a type alias for a tree or a declaration for an empty tree?
15:59:51 <AWizzArd> I thought I could alias an empty tree, so I can reuse this in pattern matching.
16:00:28 <roxxik_> oh... for pattern matching you need something different entirely
16:00:45 <roxxik_> you can only match on constructors and fields
16:00:51 <AWizzArd> Instead of the function header  add (Node v Empty Empty) val   I thought I could do    add Leerbaum val = …
16:01:01 <roxxik_> yah that is possible
16:01:06 <roxxik_> but way more complicated
16:01:19 <roxxik_> lookup pattern synonyms, as i have no idea how to use them
16:01:25 <AWizzArd> Okay, then it’s not for me, yet :-)
16:03:09 <roxxik_> https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/syntax-extns.html and scroll down to pattern synonyms
16:03:38 <roxxik_> and that's not a function header you have given, but a pattern match
16:04:09 <roxxik_> function header would be along the lines of `add :: Tree a -> a -> ???` and is called a type signature
16:05:35 <AWizzArd> roxxik_: Ah good, thx for the terminology.
16:06:17 <jtojnar> Why isn't Data.Text listed as Monoid instance on Hackage? https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html
16:07:06 <roxxik_> reading up on it, you could define something along the lines of: `pattern SingletonTree v = Node v Empty Empty` and then use this in your pattern match as: `add (SingletonTree v) val = ...`
16:08:00 <nshepperd1> codedmart: uh, note that <* is different from =<< though, in that <* does the effects in left to right order still
16:08:29 <geekosaur> jtojnar, that's a bug in haddock
16:08:37 <nshepperd1> That's why << doesn't exist, iirc, because it would be confusing wrt effect order
16:10:45 <roxxik_> AWizzArd: and you'd need to switch on the extension PatternSynonyms
16:12:46 <AWizzArd> roxxik_: aah, that’s why it didn’t work.
16:13:07 <bsamorim> why can't 'where' bindings be shared across bodies of multiple patterns? It seems to my virgin Haskell mind a very unnecessary restriction
16:13:11 <roxxik_> {-# LANGUAGE PatternSynonyms #-} somewhere at the top of the file
16:13:29 <Koterpillar> bsamorim: the patterns might introduce different variables
16:13:39 <Koterpillar> bsamorim: or variables with same names but different types
16:13:49 <Axman6> bsamorim: you can always just use case
16:14:21 <bsamorim> Koterpillar: I'm sorry, I'm not sure I follow...how could this introduction be made?
16:14:41 <AWizzArd> roxxik_: Works. Good.
16:14:50 <Axman6> foo (Left x) = ... foo (Right x) = ...
16:15:07 <Koterpillar> bsamorim: ^
16:15:18 <Axman6> if you could refer to x in a common where clause its type would be ambiguous
16:15:39 <Axman6> if say foo ::: Either Int Bool, then x is either Int or Bool
16:16:04 <bsamorim> Axman6, Kotterpillar: I see now, thanks ! :)
16:17:42 <sm> c_wraith, johnw: Chris Wong has taken over hackagebot, and might or might not be working on it
16:18:23 <johnw> sm: thanks
16:19:16 <sm> by the way I think it was pretty darned reliable, until pesky ops started hobbling it :)
16:32:01 <Axman6> those darn ops!
16:32:20 <glguy> It'd be neat if instead of flooding the channel when a new amazonka release came around that it sent one message listing all the new updates: this-0.1, that-0.2, etc-0.3
16:32:42 <Axman6> heh
16:32:47 <hpc> or if it caught prefixed packages
16:32:56 <johnw> right, grouping by prefix would be quite useful
16:33:06 <Axman6> how long is a prefix?
16:33:19 <johnw> up to first -
16:33:19 <Koterpillar> this{,-that{,-subpackage},-etc}-0.3
16:33:42 <johnw> when I update gitlib, I always update all its dependent packages too, but it should really only be one announcement, not 7
16:33:59 <Koterpillar> there was an article about writing the shortest regexp matching a given set of strings...
16:34:36 <monochrom> Does it also require unmatching other strings?
16:35:07 <glguy> .*
16:35:09 <Koterpillar> yes
16:35:40 <Koterpillar> http://nbviewer.jupyter.org/url/norvig.com/ipython/xkcd1313.ipynb
16:36:10 <monochrom> How is the given set of strings given?
16:36:29 <Koterpillar> the updated packages
16:36:44 <saulzar> How does anyone get on compiling things with ghc-head, given that the base version is conflicting with a lot of the packages in hackage? Can you somehow ignore base version for everything?
16:36:46 <Koterpillar> and "unmatching" is the rest of Hackage, obviously
16:37:07 <glguy> saulzar: There's an --allow-newer flag
16:37:19 <saulzar> Ah..
16:37:22 <sm> hackagebot used rss2irc, a generic feed announcer. I agree something smarter and custom would be nice, maybe Chris can use help
16:38:12 <saulzar> glguy, Thanks!
16:39:51 <justatech> any here got any resources with free college project 
16:41:12 <Axman6> justatech: I don't understand what that means
16:42:13 <codedmart> nshepperd1: Wait so if I do `anotherOperation <* operation` anotherOperation is ran first? It typed checked ok.
16:42:18 <codedmart> Is that what you are saying?
16:42:20 <justatech> need a few repository with projects like github Axman6
16:42:52 <Axman6> well, github has millions of projects...
16:43:09 <justatech> any others u may know 
16:43:32 <Axman6> I don't understand what you're looking for
16:43:35 <Koterpillar> justatech: what kind of projects do you want?
16:44:04 <Axman6> "college projects
16:44:05 <justatech> web app vulnerability scanner college level project 
16:44:14 <Welkin> ...
16:44:15 <Axman6> " makes it sound like you're after other people's assignment answers
16:44:19 <glguy> justatech: did you have a Haskell question?
16:44:35 <Welkin> I'm sure you could just go to the homework store and buy a copy of that project
16:45:34 <Axman6> Welkin: sadly that's how many students treat university, they don't see the difference between doing something themselves and paying someone else to do it and claiming it as their own
16:45:36 <justatech> i am after web app vuleberability scanner Koterpillar 
16:45:48 <Axman6> justatech: what does this have to do with Haskell
16:46:11 <Koterpillar> justatech: this is the wrong channel
16:46:32 <justatech> where could i go 
16:46:40 <Axman6> google?
16:46:53 <Koterpillar> I don't know
16:46:56 <justatech> my logic waa haskell==helping peopke
16:47:11 <Axman6> with haskell problems, this has nothing to do with haskell
16:47:12 <Koterpillar> > "haskell" == "helping peopke"
16:47:15 <lambdabot>  False
16:47:16 <orzo> can i declare an "as" alias for the current module?
16:47:19 <Axman6> justatech: go look at OWASP's website
16:48:17 <dolio> orzo: Try importing the module into itself.
16:48:28 <Welkin> import qualified
16:49:51 <orzo> dolio: "Module imports form a cycle"
16:50:39 <orzo> Welkin: "qualified" didn't fix the cycle
16:54:25 <monochrom> No, don't try to alias your own module. Alias all other modules.
16:55:41 <orzo> my module is adding instrumentation and simulating other modules
16:55:53 <orzo> i'm aliasing the other moduels
16:56:01 <orzo> but it'd be nice to alias my current one too
16:57:04 <orzo> you say don't try, but i'm pretty sure it's impossible
16:58:57 <monochrom> @pl \x -> x >>= \r -> r 5
16:58:58 <lambdabot> (($ 5) =<<)
16:59:54 <hpc> :t (($ 5) =<<)
16:59:56 <lambdabot> (Num a, Monad m) => m (a -> m b) -> m b
17:00:13 <hpc> not as bad as i expected
17:29:40 <fresheyeball> so if I use makelenses for an ADT
17:29:46 <fresheyeball> what should I expect for lens names?
17:38:47 <nshepperd1> codedmart: yeah
17:41:06 <nshepperd1> > [1,2] <* [3,4]
17:41:09 <lambdabot>  [1,1,2,2]
17:41:45 <sshine> ó_ò
17:42:13 <wedify> why does that duplicate the elements? shouldn't it be '[1,2]'?
17:42:28 <nshepperd1> > let (<<) = flip (>>) in [1,2] << [3,4] -- vs this
17:42:30 <lambdabot>  [1,2,1,2]
17:43:09 <EvanR> wedify: theres 4 paths
17:43:27 <sshine> > [ x | x <- [1, 2], y <- [3, 4] ]
17:43:30 <lambdabot>  [1,1,2,2]
17:43:37 <EvanR> 1 3, 1 4, 2 3, 24
17:43:50 <EvanR> <* ignores the second number in each case
17:46:20 <sshine> > do { x <- [1, 2]; y <- [3, 4]; return x }
17:46:23 <lambdabot>  [1,1,2,2]
17:47:02 <sshine> > [1, 2] >>= \x -> [3, 4] >>= \_ -> [x]
17:47:05 <lambdabot>  [1,1,2,2]
17:52:42 <codedmart> nshepperd1: ok thanks. So should I write my own << from =<<?
17:53:07 <sshine> wedify, just because only x is in the result, the expression still contains a (concat)Map over [3,4].
17:53:49 <nshepperd1> codedmart: yeah, if you want the effects to occur right to left
17:54:01 <sshine> > concatMap (\y -> concatMap (\x -> [x]) [1,2]) [3,4] -- seems like EvanR knows why the order is different. still, you're looking at the x of (x,y) <- [1,2] `cartesianProduct` [3,4].
17:54:04 <lambdabot>  [1,2,1,2]
17:54:59 <nshepperd1> On second thoughts, using lists was a bad example there
17:55:17 <sshine> wedify, [1,2] `cartesianProduct` [3,4] has four pairs of which two begin with 1 and two begin with 2.
17:56:26 <sshine> where cartesianProduct = liftM2 (,) -- :)
17:56:29 <dmwit> codedmart: I missed the question, but `flip (<<)` may be more performant than using something based on `(=<<)`.
17:56:34 <dmwit> uh
17:56:39 <dmwit> `flip (>>)` of course
17:56:59 <nshepperd1> > let (<<) = flip (>>) in (Left 1 <* Left 2, Left 1 << Left 2)
17:57:03 <lambdabot>  (Left 1,Left 2)
19:03:14 <clmg> Anyone know how to get intero mode to run 'main' programatically?
19:03:51 <clmg> haskell-mode has a `inferior-haskell-run-command` I use to load and run `main` but I'm switching to intero.
19:08:21 <JuanDaugherty> this is about emacs innit?
19:08:28 <clmg> JuanDaugherty: ya
19:09:44 <JuanDaugherty> ty, i'd not heard of intero b4
19:09:52 <JuanDaugherty> looks new
19:10:10 <clmg> It's nicer than haskell-mode except for this one pitfall.
19:10:16 <JuanDaugherty> guess not if it goes back to 7.8
19:10:47 <JuanDaugherty> you evaluated eclipse-fp?
19:11:39 <clmg> nope I use emacs for everything
19:11:59 <clmg> JuanDaugherty: have you used this lib? https://github.com/jtdaugherty/vty
19:12:08 <clmg> wait you have the same name
19:12:28 <JuanDaugherty> not directly, hledger oder might use it
19:12:53 <JuanDaugherty> my middle initial i e
19:13:07 <JuanDaugherty> *is e; daugherty is a fairly common name in US
19:13:15 <clmg> ah
19:13:48 <glguy> vty's handy. I use it for my irc client
19:14:32 <clmg> glguy: I'm considering building a simple text editor in it
19:15:02 <clmg> glguy: I tried using ncurses and rust but I couldn't get rid of the flickering. Did you have any performance problems with vty and your irc client?
19:15:32 <glguy> Not in particular, but it's a text chat client so the performance requirements aren't high
19:16:13 <clmg> rust is really not great
19:16:37 <wgetch> clmg, I did a lua lib for tty games, did not run into serious problems with flickering
19:16:46 <wgetch> this was written in c+ncurses
19:17:25 <wgetch> do you blank the screen each frame?
19:17:27 <clmg> wgetch: I was using ncurses-rs and I think that lib has some overhead with newwin(). Could be wrong.
19:17:39 <wgetch> ahh
19:17:52 <clmg> wgetch: blank it? I blank each line one at a time each frame.
19:18:10 <wgetch> yeah I had poor results with the lua ncurses lib actually
19:18:12 <clmg> wgetch: but I was getting a flicker just be calling newwin() and then doudpate().
19:18:14 <wgetch> now that I think about it
19:18:43 <clmg> ncurses is great but I was really upset. I put a week into the editor and I have to start over. I hope vty is more performant.
19:19:25 <ludat_> is there some way to print a Config from configurator? It doesn't seem to implement show ._.
19:19:27 <wgetch> honestly it looks promising
19:19:42 <wgetch> ncurses can be quite a hassle
19:19:50 <clmg> it's rather archaic
19:19:53 <wgetch> nice to learn of this alternative
19:19:58 <geekosaur> curses has weird gotchas. clearing the screen each frame will flicker if you use wclear but not if you use werase (wclear forces a physical full screen clear, werase just wipes internal structures and lets doupdate deal)
19:20:21 <ludat_> ignore me I just found it
19:20:24 * geekosaur still thinks curses was well named
19:20:39 <wgetch> What a horrible night to have a curse...
19:20:43 <clmg> geekosaur: I figured that part out. I ran into a wall with creating new windows. Seems like there's no way to create a new window and doupdate() without a flicker but I couldn't reproducing it in C, only the rust lib.
19:21:00 * wgetch looks at own username, remembers it is a curses reference
19:21:10 <geekosaur> :)
19:21:43 <wgetch> that's frustrating
19:22:21 <wgetch> also why I ended up writing my library in C and keeping the main loop there
19:22:53 <wgetch> its sometimes just easier not to deal with the program boundaries
19:22:57 <wgetch> or move them forward
19:23:40 * monochrom prefers to recurse
19:24:01 <monochrom> http://lpaste.net/5545157388815826944
19:25:12 <wgetch> I wish I understood haskell better
19:25:25 <wgetch> I'm only a couple days into it right now
19:25:32 <monochrom> You will.
19:25:45 <wgetch> What is a good practice program to write
19:26:09 <monochrom> Follow a good textbook.
19:26:39 <monochrom> I wrote toy compositions for 6 years when I learned Chinese.
19:27:37 <wgetch> My ultimate goal is to implement a toy language in haskell
19:27:53 <wgetch> but Im having trouble thinking of intermediate steps to learn the language firts
19:28:40 <wgetch> first*
19:29:01 <Koterpillar> monochrom: did you try to implement Chinese in Haskell?
19:29:06 <clmg> I'm in a similar position. Language design is really the ultimate
19:29:10 <monochrom> If you know algebraic data types and recursion, you can already implement a toy language interpreter. But you will have to settle for entering examples as abstract syntax trees for the moment.
19:29:25 <monochrom> After you also learn parsing, you will be able to enter examples as text.
19:30:22 <wgetch> I recently implemented a parser for an IRC bot (this was in js)
19:30:50 <monochrom> There is "write Scheme in 48 hours" that does this in Haskell.
19:31:17 <wgetch> I will check that out
19:32:48 <wgetch> the bot I made is kind of like a lisp, except more like a shell
19:33:03 <wgetch> after writing it I really wanted to try a lisp
19:33:11 <wgetch> try to write a lisp, that is
19:45:00 <karroffel> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
19:45:04 <karroffel> this book is really good
19:53:26 <ertes> any experiences on how well gloss works under mac and windows?  i'm giving a haskell workshop in february, and i'd like to write a graphical mini-game as the introductory example, but i'd also like to avoid nasty surprises with people not being able to get gloss running
19:55:08 <ertes> if that turns out to be problematic, i'll go for a web app instead
20:01:20 <wedify> is there a more recent book on implementing functional languages?
20:02:03 <dfeuer> wedify: yes.
20:02:27 <monochrom> ertes: Create an XY problem by using linux inside virtualbox inside windows or mac :)
20:03:13 <dfeuer> wedify: there's http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/ for one.
20:05:55 <karroffel> the 1987 book is definitely more complete ^^
20:06:22 <psych0nokoi_808> never heard of haskell.. can anyone enlighten me on why I should learn this language?
20:06:35 <monochrom> the eval-apply paper assumes you read the 1987 book. I know because I tried.
20:06:52 <ertes> monochrom: sure…  and that will only take the first three hours of the nine hours i got =)
20:07:22 <monochrom> If you have never heard, then no reason you should learn.
20:07:26 <psych0nokoi_808> beter than python? modules>
20:07:45 <markasoftware> it's not "better" than python
20:07:46 <ertes> psych0nokoi_808: it's practical, it's programmer-friendly (as opposed to compiler-friendly), it provides new perspectives on how to solve engineering problems, etc.
20:07:49 <markasoftware> it's not "worse" either
20:07:52 <markasoftware> it's different
20:08:07 <monochrom> I never heard of the Uralic family of languages, so I never needed to learn them.
20:08:23 <monochrom> (Until I heard that Finnish and Hungarian are members.)
20:08:24 <glguy> I just heard about "Uralic" languages. Why should I learn them?
20:08:44 <johnw> psych0nokoi_808: I'm not sure there's any reason why you *should*, but you might find it both interesting and enjoyable
20:09:31 <psych0nokoi_808> I'll check it out.. I have no means to learn another language, just interested
20:10:47 <psych0nokoi_808> What's a good site to dive in?
20:11:12 <wedify> learn you a haskell is pretty popular
20:11:44 <psych0nokoi_808> Thanks!
20:12:16 <ertes> psych0nokoi_808: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
20:12:23 <ertes> psych0nokoi_808: i recommend this over LYAH
20:13:36 <dfeuer> That is popular too.
20:13:40 <psych0nokoi_808> gotcha ertes.. LYAH looks friendly :0
20:14:12 <jle`> friendly is probably one of the only positive qualities of LYAH
20:14:20 <ertes> psych0nokoi_808: CIS194 has good pacing (i.e. neither boring nor overwhelming), and it's hands-on with lots of examples and exercises
20:14:20 <jle`> also 'good illustrations'
20:15:19 <psych0nokoi_808> great guys.. appreciate the info. 
20:46:55 <wedify> i've decided to try for a bachelor's in mathematics. you have haskell to thank for that
20:47:14 <ubsan> wedify: you should try idris :3
20:47:36 <wedify> ubsan: been learning agda but eventually will give idris a try
20:47:44 <ubsan> wedify: idris is way better
20:47:51 <ubsan> wedify: they actually call their Type type Type
20:47:54 <ubsan> as opposed to Set
20:47:58 <ubsan> which is annoying af
20:49:25 <glguy> ubsan: "Set"? Are you thinking of Agda?
20:49:36 <ubsan> glguy: uh, yes
20:49:42 <glguy> Oh, I skipped right over that line
20:49:42 <ubsan> > been learning agda but eventually will give idris a try
20:49:44 <ubsan> lol
20:49:45 <lambdabot>  error:
20:49:45 <lambdabot>      Variable not in scope:
20:49:45 <lambdabot>        been
20:50:03 <Sornaensis> :t takeTMVar
20:50:06 <lambdabot> error: Variable not in scope: takeTMVar
20:50:16 <Sornaensis> I just did STM for the first time
20:50:28 <Sornaensis> ;  -;
20:50:36 <johnw> import Control.Concurrent.STM
20:50:39 <dyreshark> take™Var
20:50:45 <Sornaensis> so amazing
20:50:46 <monochrom> :)
20:51:22 <monochrom> But actually I don't think that TMVar is as useful as MVar
20:51:48 <Sornaensis> why not
20:52:16 <monochrom> Because you're already in STM which enables a completely different paradigm.
20:52:22 <Sornaensis> ah
20:52:25 <dmwit> Yes, TMVar is silly.
20:52:28 <glguy> monochrom: You've never wanted to read from either one of two mvars? never wanted to read an mvar with a timeout?
20:52:42 <glguy> read/take
20:52:44 <dmwit> glguy: TVar seems fine for those uses.
20:53:02 <glguy> Sure, you could reimplement TMVar yourself
20:53:06 <glguy> but why if it's already done
20:53:34 <dmwit> No, like: *just* use TVar. Don't reimplement MVar with it.
20:53:53 <glguy> OK, but a TMVar is jsut a TVar
20:53:53 <monochrom> No, I have never wanted to.
20:54:00 <glguy> but with some helpers supporting the mvar type use
20:54:26 <glguy> monochrom: Well, when you want to do that, TMVar is nice
20:54:36 <Sornaensis> I just used it to read from two MVars at once among a pool of consumer threads w/ two producer threads idk i m noob
20:56:18 <monochrom> I think that will be in the infinitely far future. Because I have already written a program that waits for an asynchronous, may-succeed-may-fail-may-take-too-long effect with timeout, and I used async, not MVar or TMVar.
20:56:44 <glguy> You can't use timeout to do it
20:56:58 <monochrom> I used async.
20:57:17 <glguy> You can't use async to wait on an mvar with a timeout without risking losing the taken element on timeout
20:57:36 <monochrom> But I was not waiting on an MVar. I did not need to.
20:58:30 <monochrom> I was waiting on either a spawned process to finish (and then I still have to ask whether it's exit-0 or not) or 5 seconds.
20:58:43 <monochrom> So I just used two async jobs and raced them.
20:59:01 <glguy> OK, that's something else, but sounds useful in any case
20:59:23 <monochrom> Why do people use MVars? Because they're solving a similar problem as mine, before async existed.
20:59:29 <monochrom> Why do people use TMVars? Because they're solving a similar problem as mine, before async existed.
20:59:42 <glguy> No, TMVar isn't competing with async
21:14:52 <ertes> why is TMVar silly?  i use it a lot
21:19:22 <monochrom> Do you use it because it exactly solves the problem? Or do you use it because it's already available so you shoehorn your problem into it? I.e., if no one wrote TMVar, would you go out of your way to reinvent it, or would you rather rethink the whole problem and solve it some other way?
21:20:10 <monochrom> Because that's what I am talking about. You can always change paradigm, and the new paradigm may have more than 50% chance to be nicer.
21:21:49 <monochrom> Because I am drawing this controversial analogy "head and tail : pattern matching :: TMVar : STM"
21:22:24 <monochrom> There was a time people thought that head and tail would be used 90% of the time.
21:34:45 <glguy> No, I don't see it as related to head/tail at all. I don't think it comes up as being needed very often, but it's a nice extension to mvar on its own
21:35:39 <monochrom> Did you see my opening sentence?
21:35:55 <monochrom> <monochrom> But actually I don't think that TMVar is as useful as MVar
21:35:56 <glguy> About being a shoehorn?
21:36:32 <monochrom> And I totally approve of "map head (group xxx)" so it is not like I completely eradicate head and tail either.
21:39:07 <glguy> You seem to be thinking of very particular uses of these types where async can help clear up the meaning of code
21:39:20 <glguy> In those particular cases I'm in favor of using a higher level tool ,like async
21:49:22 <qmmm> what is ((,) e) ?
21:49:30 <qmmm> that's a difficult term to search for on the web :)
21:49:50 <dyreshark> (,) is the tuple constructor
21:49:53 <qmmm> yep
21:49:55 <monochrom> You know (Int, Bool), right? There is another notation to write it: (,) Int Bool
21:49:57 <dyreshark> so `(,) e` is a half-constructed tuple
21:50:05 <dyreshark> give it another argument and you get a fully-constructed tuple
21:50:07 <malinoff> hi all, where should I look if I have a binary (built by stack/ghc) stuck on https://bpaste.net/show/2335bb4bccc5 which gets unstuck (and die) on SIGINT
21:50:29 <qmmm> a half constructed tuple, mind blown
21:51:03 <qmmm> what ((,) e)) typically used for and where can i read more on it?
21:51:04 <glguy> qmmm: Have you considered the type: Either Int
21:51:24 <dyreshark> that depends entirely on the context
21:51:33 <monochrom> When you write "instance Functor ((,) e)" and there is no other way to put it.
21:51:35 <qmmm> glguy: i guess i haven't
21:51:46 <dyreshark> i can do `map ((,) "hi") [1..5]` and get [("hi", 1), ("hi", 2), ...]
21:52:04 <glguy> qmmm: dyreshark that example is something different
21:52:07 <dyreshark> just start passing functions around a lot and you'll get the hang of it :)
21:52:09 <glguy> -qmmm
21:52:21 <ertes> monochrom: if TMVar weren't available, i would have to use TVar . Maybe
21:52:32 <ertes> and reinvent put/take
21:52:36 <glguy> (,) "hi"  is a value level thing
21:52:54 <glguy> (,) sometype    is a type level thing. those are different (,). One is the type constructor and the other the value constructor
21:53:04 <monochrom> (,) "hi" does not have type (,) String. That is the fatal flaw.
21:53:22 <glguy> :t (,) "hi"
21:53:23 <lambdabot> b -> ([Char], b)
21:54:03 <glguy> qmmm: Note that there are no values with the type:  (,) e
21:54:03 <monochrom> But you can say you're using value-level partial application to convince that type-level partial application is a thing.
21:54:07 <qmmm> oh (,) "hi" is (,) applied to "hi" and waiting for another value
21:54:07 <glguy> This type has the kind  * -> *
21:54:31 <glguy> (,) "hi" is something else altogether
21:54:41 <ertes> monochrom: i think this is a case of the "i've never found it useful, so it must be useless" fallacy
21:54:53 <qmmm> glguy: please continue, and thank you for answering
21:54:55 <monochrom> The problem is that you will next use value-level lambda to convince me that type-level lambda is available too.
21:55:36 <monochrom> ertes: Did you see my opening sentence?
21:55:44 <monochrom> <monochrom> But actually I don't think that TMVar is as useful as MVar
21:55:46 <glguy> (,) Int :: * -> *, and so we can use it in situations like: fmap :: (a -> b) -> f a -> f b
21:56:07 <monochrom> Where did I write a boolean, absolute, closed minded sentence? Show me.
21:56:19 <glguy> qmmm: in the type of fmap, f is a type variable with kind * -> *, so we could instantiate it as: (,) e 
21:56:56 <monochrom> Even when I said that I have never used it before and probably never will, it is still for statistical purpose not boolean purpose.
21:56:58 <glguy> and get:  fmap :: (a -> b) -> (,) e a -> (,) e b --aka-- fmap :: (a -> b) -> (e,a) -> (e,b)
21:57:29 <monochrom> Where you accuse me of one fallacy, I'll accuse you of another: Straw man.
21:57:58 <glguy> I want to be the Tinman
21:58:07 <dyreshark> i want to be the sippycupman
21:58:16 <glguy> I don't remember that character
21:58:28 <dyreshark> it was a deleted scene
21:59:32 <ertes> monochrom: now that we're even, let's bring it back to technical:  TMVar is very often a good STM variant of FRP's Event…  STM integrates simultaneity, which is not available with MVar
22:02:13 <qmmm> glguy: oh, it it a way to tag data as a certain type? (Monad, []) e.g. or (Semigroup, ([1..], (+)
22:02:21 <qmmm> )
22:02:30 <qmmm> )
22:02:40 <qmmm> i can't type tonight
22:03:09 <qmmm> is it a way to type tag data as a certain type? e.g. (Monad, []) or even (Semigroup, ([1..], (+)))
22:03:17 <qmmm> i guess not
22:03:32 <qmmm> maybe though
22:03:54 <qmmm> glguy: help me out please? :)
22:04:07 <glguy> You're asking what tuples are for?
22:04:19 <qmmm> i'm not quite following your example from above
22:04:39 <qmmm> "in the type of fmap, f is a type variable with kind * -> *, so we could instantiate it as: (,) e and get:  fmap :: (a -> b) -> (,) e a -> (,) e b --aka-- fmap :: (a -> b) -> (e,a) -> (e,b)"
22:05:02 <glguy> OK, did you know that f was a type variable in that type signature?
22:05:09 <qmmm> yeah
22:05:18 <qmmm> i suppose it represents a function and not necessarily a type
22:05:23 <glguy> Do you know the kind of 'f'?
22:05:31 <qmmm> functor
22:05:39 <qmmm> not a function, right, okay, a type it is
22:05:47 <glguy> No, kinds are things made of arrows (->) and *
22:05:57 <qmmm> (a -> b) representing a function, f representing a functor
22:06:15 <glguy> So the kind of   Int   is?
22:06:44 <qmmm> is this correct: a functionisn't necessarily * -> * unles it takes one type and transforms it into another type?
22:06:51 <glguy> Your answer can use: these characters: " *()->"
22:07:15 <glguy> Hold on, we can do functions next
22:07:16 <qmmm> the kind of Int is *
22:07:39 <qmmm> the kind of a String is confusing
22:07:39 <glguy> Do you know the kind of (,)?
22:07:45 <glguy> OK, what's the kind of String?
22:07:46 <qmmm> i would naturally say *
22:07:59 <qmmm> but.. it's a list of characters and a list is a functor, right?
22:08:04 <glguy> Forget about functor
22:08:07 <qmmm> okay
22:08:08 <glguy> that's something else
22:08:12 <glguy> we're just working on kinds
22:08:16 <qmmm> yep
22:08:23 <glguy> String has kind *, yes
22:08:37 <glguy> all these types that have values like Int and String? They have kind *
22:08:40 <qmmm> increment n = n + 1 should have type * right?
22:08:44 <glguy> that's the magic of *, its the kind of types that can have values
22:08:47 <qmmm> s/type/kind 
22:09:03 <glguy> increment n = n + 1 is a definition for 'increment'
22:09:08 <glguy> increment is a *VALUE*
22:09:11 <glguy> values have Types!
22:09:44 <glguy> so maybe increment :: Int -> Int, right?
22:10:01 <qmmm> that makes sense
22:10:11 <glguy> and then you can ask, what kind does 'Int -> Int' have?
22:10:16 <qmmm> * -> * ?
22:10:24 <qmmm> looks like it
22:10:33 <qmmm> Int = *
22:10:48 <qmmm> Int -> Int == * -> *  -- True?
22:11:03 <glguy> No, not quite
22:11:07 <glguy> let's step back one step
22:11:11 <qmmm> ok
22:11:12 <glguy> values
22:11:27 <glguy> When something has a *function type* (e.g.   Int -> Int), then we can apply it to another values
22:11:35 <glguy> so increment was such a function
22:11:53 <glguy> We can apply it to an Int (the left side of that arrow) and we get an Int (the right side)
22:11:57 <glguy> increment 10 :: Int
22:12:07 <glguy> increment (10 :: Int) :: Int, OK?
22:12:33 <glguy> values with function types can be applied to other values with matching type
22:12:44 <glguy> 'f x' is f applied to x
22:13:09 <glguy> (checkpoint)
22:13:28 <glguy> we need to understand all of this first and then we can apply it at the type level
22:14:31 <qmmm> i thin i understand all of this
22:14:38 <glguy> OK, so let's move up one level
22:14:45 <glguy> Maybe :: * -> *
22:14:56 <glguy> Maybe has one of these function *kinds*
22:14:58 <qmmm> wait wait
22:15:10 <qmmm> increment is type *?
22:15:12 <qmmm> or is it type * -> *
22:15:19 <glguy> it's type is Int -> Int
22:15:32 <glguy> 'increment :: Int -> Int'  and  'Int -> Int :: *'
22:15:49 <glguy> the first :: is 'has type', the second is 'has kind'
22:16:05 <glguy> we use the same :: for both and try to keep straight which level we're talking about in our heads
22:16:08 <qmmm> oh right, because the resulting type isn't "wrapped" so to say
22:16:32 <qmmm> so Int -> Int is going to be of type *
22:16:38 <glguy> yes
22:16:40 <qmmm> String -> String is going to be * 
22:16:43 <glguy> yes
22:16:57 <qmmm> pure not so much
22:16:59 <glguy> Because these two have kind *, you know you can't apply them to another type
22:16:59 <qmmm> * -> *
22:17:06 <glguy> pure is a value, it doesn't have a kind
22:17:24 <qmmm> oh, in my head i saw pure as a -> m a
22:17:27 <qmmm> :k pure
22:17:28 <lambdabot> error: Not in scope: type variable ‘pure’
22:17:42 <glguy> pure :: _ => a -> m a
22:17:54 <glguy> Hold on, let's wrap your head around Maybe first
22:18:02 <qmmm> thanks :)
22:18:18 <glguy> What kind does the type 'Maybe' have?
22:18:26 <qmmm> * -> *
22:18:47 <qmmm> and the reason i think it's that is becuase there's a context with the value
22:18:52 <glguy> Yes. Now because it has that kind we know that we can apply it to a type with kind * (left side of the ->)
22:19:05 <glguy> and that we'll get a type back with kind * (the right side of the ->)
22:19:17 <glguy> so now if we have the type:  Maybe Int, what kind does it have?
22:19:22 <qmmm> "context", not really sure what to say, "container", an object which can contain something else where that something else is some value 
22:19:45 <glguy> container and context are more value level concerns
22:19:46 <qmmm> ...else is some value which can't contain something else itself
22:20:14 <glguy> We're just mixing and matching types right now
22:20:44 <glguy> So   Maybe Int has the kind *. We know this because Maybe has the kind '* -> *' and Int had *
22:21:01 <glguy> if you apply a type with kind '* -> *' to a type with kind '*' you get one back with kind '*'
22:21:05 <glguy> it's like functions at the value level
22:21:25 <glguy> where if we have a function  with type 'Int -> Char' and applied that to a value with type 'Int'
22:21:30 <glguy> we got a 'Char' back, right?
22:21:50 <qmmm> Maybe has * -> *
22:22:13 <qmmm> Maybe Int is Maybe "applied?" to Int 
22:22:16 <glguy> Yup
22:22:17 <qmmm> Int is *
22:22:57 <qmmm> I guess its * -> *
22:23:08 <glguy> You guess what is * -> *?
22:23:20 <qmmm> well,...
22:23:28 <qmmm> Maybe Int is constructing a value?
22:23:38 <glguy> It's constructing a type
22:23:50 <qmmm> so maybe since Maybe is already applied Maybe Int is *
22:24:04 <glguy> yes
22:24:17 <qmmm> this is so intense ;)
22:24:29 <qmmm> thank you for taking the time to share knowledge
22:24:29 <glguy> OK, so any time you have 'f :: a -> b' and 'x :: a', and you put them together you get 'f x :: b'
22:24:36 <glguy> this is out the -> works
22:24:41 <glguy> and that works the same at the type and value level
22:25:21 <glguy> 'ord :: Char -> Int' ' 'A' :: Char '   'ord 'A' :: Int'   (sorry about the ' on that one)
22:25:22 <ertes> qmmm: it may be helpful to look at bad examples as well:  Maybe IO  -- kind error: Maybe :: * -> *, so it takes a * as its argument, but IO :: * -> *
22:25:35 <ertes> qmmm: we have a kind system for types for the same reason we have a type system for values
22:27:13 <qmmm> f partially applied is *
22:27:16 <qmmm> ?
22:28:23 <glguy> qmmm: can you elaborate on that?
22:28:46 <qmmm> `f x :: b` is f partially applied, correct?
22:29:04 <glguy> just applied
22:29:14 <qmmm> oh, right, okay
22:29:48 <qmmm> yeah, okay i follow
22:29:59 <glguy> OK, so we were talking about the kind of (,)
22:30:16 <glguy> There are two way to write tuple types, infix and prefix
22:30:27 <glguy> so:  (Int,Char)   and   (,) Int Char   are the same thing
22:30:39 <qmmm> ertes: interesting, thank you
22:30:44 <glguy> at the value level we can write:  (x+y)   and  (+) x y
22:30:52 <glguy> and that's two ways to write the same thing
22:31:10 <glguy> Have you seen that?
22:31:46 <qmmm> yeah, i've actually used (+) x y
22:32:21 <glguy> now in Haskell, function application is *left associative*. What this means is that these two mean the same thing:  f x y   and   (f x) y
22:32:28 <qmmm> this adds a new dimension to (+) x y though 
22:32:47 <qmmm> this is turning out to be a neat interface
22:33:07 <glguy> so let's look at (+) first and then apply what we see to (,)
22:33:21 <glguy> We'll specialize to Int
22:33:29 <glguy> so,  (+) :: Int -> Int -> Int
22:33:48 <glguy> so,  (+) :: Int -> (Int -> Int) -- same thing, the arrows are *right associative*
22:34:16 <glguy> If we apply (+) to a single Int, what type do we get?   (+) 10 :: ?
22:35:14 <qmmm> before i forget, there was some argument on the wide, wide web and this person mentioned something essentially equivalent to "haskell has a consistent interface [in monads] for handling three completely distinct areas of computer science: error handling, logging, and management of state
22:35:30 <qmmm> does anyone recall where this was? (sorry glguy, just wanted to ask before i forgot)
22:35:55 <qmmm> ^ note to self for asking later i suppose
22:36:21 <ertes> qmmm: you will find this note all over the place…  it's usually how people promote monads (unfortunately)
22:38:26 <monochrom> I don't do arguments on the web, but you will want to read Phil Wadler's paper "monads for functional programming".
22:39:09 <qmmm> glguy: Int
22:39:12 <monochrom> Moggi has a paper earlier than that saying the same thing (plus others) too, but Moggi's is harder to read and much faster paced.
22:39:16 <qmmm> glguy: of type * -- yay!
22:39:32 <glguy> qmmm: Yes, Int :: *, but (+) 10 :/: Int
22:39:42 <glguy> :/: is my clever "does not have type"
22:39:55 <qmmm> (+) 10 doesn't have the type Int?
22:40:06 <glguy> :t (+)
22:40:07 <qmmm> oh, because it isn't applied yet
22:40:08 <lambdabot> Num a => a -> a -> a
22:40:29 <qmmm> Int of kind * -- is what i mean, sorry 
22:40:40 <qmmm> i'm a bit sick and sleepy, but i want to learn this
22:40:53 <glguy> Well, we'll be here for days and days
22:40:57 <qmmm> oh :)
22:41:49 <glguy> If you're tired you should just get some sleep and let your brain work on it
22:42:07 <qmmm> monochrom: thank you for the suggestions. yeah, i think it was some person's comment, possbily on hackernews when complaining about go vs haskell
22:42:18 <qmmm> s/when//
22:42:28 <monochrom> God, people never stop complaining, no?
22:42:56 <lambdabot> No, they don't.
22:43:55 <qmmm> complaining about go and then talking about how haskell has a consistent interface for ..
22:44:10 <qmmm> i *think* he said said statement management, logging, and error handling
22:44:34 <qmmm> but i guess there's more than just those three things and the commentor probably was aware of this, but was trying to make a point
22:44:49 <qmmm> glguy: i'm going to take your advice
22:45:02 <qmmm> glguy: if you're open to it, i'll ask you more later
22:45:09 <glguy> sure
22:45:13 <qmmm> glguy: thanks again
22:46:01 <glguy> yw
23:06:06 <qmmm> glguy: befor nodding off... ((+) 2) is * -> *
23:06:13 <qmmm> ((,) e) is * -> *
23:06:19 <glguy> No, and yes
23:06:27 <glguy> ((+) 2) was :: Int -> Int
23:06:42 <qmmm> oh
23:06:46 <qmmm> it's not * -> *
23:07:03 <glguy> * -> * is a kind
23:07:11 <glguy> but (+) 2 has a type, not a kind
23:07:38 <qmmm> i thought a kind was a type of a type
23:08:11 <glguy> That's right
23:08:32 <glguy> The type of (+)2 is Int -> Int
23:08:37 <glguy> The kind of Int -> Int is *
23:09:09 <glguy> It wouldn't make sense to write the type:   (Int -> Int) Char
23:09:11 <qmmm> because it returns a value which isn't "wrapped"?
23:09:38 <qmmm> the kinf of Int -> Int is * because it returns a value which isn't wrapped? 
23:10:04 <glguy> I don't know what wrapped means
23:10:22 <glguy> But since we have values with type Int -> Int, we know that Int -> Int has kind *
23:10:23 <opqdonut> the kind of Int -> Int is * because there exist values of type Int -> Int
23:10:25 <qmmm> oh right, i guess that doesn't mean anything
23:10:28 <qmmm> Maybe Int was *
23:10:36 <qmmm> it's "wrapped" in a "context"
23:10:44 <qmmm> too many monad tutorials
23:10:46 <glguy> Yeah, we have values of Maybe Int like   Nothing and  Just 42
23:12:13 <qmmm> okay, so we have ((+) 2) having a kind of * and ((,) e) having * -> *
23:12:40 <glguy> except that (+
23:12:49 <glguy> except that (+)2 is a *value* and values don't have kinds
23:13:03 <glguy> but yes, the type of (+)2 has kind *
23:14:03 <qmmm> :k (+) 2
23:14:05 <lambdabot> error:
23:14:05 <lambdabot>     Not in scope: type constructor or class ‘+’
23:15:00 <glguy> You have to give :k a type
23:15:51 <glguy> The error is it's looking for the *type* (+), but can't find it
23:16:07 <glguy> the type and value namespaces are separate
23:17:21 <qmmm> not possible to do 
23:17:23 <qmmm> :k (a -> a)
23:17:26 <lambdabot> error: Not in scope: type variable ‘a’
23:17:26 <lambdabot> error: Not in scope: type variable ‘a’
23:17:37 <qmmm> that probably  makes sense
23:17:56 <qmmm> :k String
23:17:58 <lambdabot> *
23:18:01 <glguy> :k forall a. a -> a
23:18:04 <lambdabot> *
23:18:13 <glguy> If we want to use type variables, we have to declare them for :k to be happy
23:19:55 <qmmm> glguy: what is the pragma for universally quantified types?
23:20:05 <qmmm> :set -X???
23:20:42 <glguy> Usually you'd put the parachute on first, but are you asking for RankNTypes ?
23:21:03 <qmmm> -# LANGUAGE RankNTypes #-}.
23:21:09 <qmmm> just came across it
23:21:17 <glguy> In Haskell the type variables are universally quantified by default
23:21:34 <glguy> :t id
23:21:36 <lambdabot> a -> a
23:21:54 <glguy> that 'a' is "universally quantified"
23:23:32 <qmmm> i feel fairly familiar with this, but there are probably some misunderstandings to ask about another time 
23:24:21 <qmmm> glguy: where was all of this going?
23:24:29 <qmmm> it was a fun lesson
23:24:42 <glguy> making sense of (,)e
23:24:50 <qmmm> to the understanding of that functions aren't necessarily * -> *
23:24:58 <qmmm> to the understanding of ((,) e)
23:25:02 <glguy> that (,) e had kind * -> *
23:25:45 <qmmm> not sure if we quite made the jump to (,) e
23:25:59 <qmmm> in the understanding bit
23:26:02 <glguy> well, that's just where we were going
23:26:22 <glguy> but we needed to spend some kind on how these arrows and application interact
23:26:23 <qmmm> glguy: thanks again, i will try to ask you for the next part of the lesson latre
23:26:27 <glguy> ok
23:40:33 <fred-fri> amongst organisations that develop and run haskell in production, is classyprelude ubiquitous or do most stick with default?
23:40:51 <davean> I've never seen classyprelude in production personally
23:41:04 <dibblego> I have never used it in 12 years and if I saw it, I would remove it immediately.
23:41:47 <fred-fri> ok. what about pragmas (not sure that's the correct term)
23:42:47 <liste> fred-fri: {-# LANGUAGE FooBar #-} pragmas are used all the time
23:43:20 <fred-fri> liste, are there any particular ones which are used more or less all the time and it's frowned upon not to use?
23:43:28 <davean> fred-fri: it varies by the extension
23:44:07 <davean> fred-fri: multiparameter type classes are everywhere, scoped type variables are flat out required for some things, etc
23:44:50 <davean> fred-fri: there are extensions that are up for addition to the report, no one ever objects to people using those unless they're crazy
23:45:27 <davean> There is a set of solid extensions that aren't up for addition but you'd be hard pressed to find someone objecting to
23:46:08 <davean> fred-fri: why these questions?
23:46:14 <fred-fri> how do you determine which ones are required when? im looking at making my first simple rest app with db roundtrips
23:46:19 <davean> (and where ever did you come across classy-prelude?)
23:46:22 <liste> fred-fri: things like FlexibleContexts or FlexibleInstances are no-brainers
23:46:39 <davean> UndecidableInstances thoguh ...
23:46:45 <davean> well, what do you think that name implies?
23:47:03 <davean> Yah, people will object if you use that, and with good reason
23:47:39 <liste> fred-fri: and many libraries require one extension or another, like multiparam type classes or type families
23:48:06 <qmmm> glguy: i think a function that goes from Int -> String is * -> * and if that is the case, i guess i can see how (,) e is * -> * since since maybe (,Int) might end up having a type of  Int -> (,)
23:48:18 <fred-fri> i see, so to the degree any are required, it will say so in the library docs (one would hope)
23:48:32 <qmmm> though i think this logic might fall through with (,) applied to () 
23:48:46 <qmmm> k, going to bed now
23:49:15 <liste> fred-fri: well, indirectly - in http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html for example you see multi-param type class and functional dependencies syntax
23:50:14 <fred-fri> liste, you're saying it's not made explicit for n00bs like myself?
23:50:42 <liste> fred-fri: there's "Portabilitynon-portable (multi-param classes, functional dependencies)" in the right hand corner
23:50:55 <liste> fred-fri: so you can check the extensions required there
23:51:03 <fred-fri> i see
23:54:23 <fred-fri> i do apologize for asking too many dumb questions but its not immediately obvious to me what pragma lines id have to add in order to accommodate non-portable (multi-param classes, functional dependencies)
23:55:09 <davean> fred-fri: just program some
23:55:24 <davean> these aren't questions that will survive doing it
23:55:29 <fred-fri> right
