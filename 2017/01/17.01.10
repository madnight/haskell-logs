00:06:42 <MarcelineVQ> https://haskell-lang.org/tutorial/string-types super useful
00:14:39 <benzrf> 01:56:30       athan │ because a prism ~ Maybe a, where traversal ~ [a]?
00:14:48 <benzrf> actually that's an affine traversal, not a prism
00:14:56 <benzrf> prisms are also reviewable
00:15:05 <athan> s_s
00:15:10 <athan> yeah I have no idea yet
00:15:14 <benzrf> bbl
01:36:02 <anonus> hi
01:36:07 <anonus> little help with tagsoup
01:36:45 <anonus> i cannot get how i can extract stuff between opening and closing tags
02:03:46 <sdx23> anonus: TagText?
02:04:22 <anonus> TagText what?
02:04:36 <anonus> i mean there is possible that some tags are in between too
02:05:23 <sdx23> anonus: and where's the problem?
02:06:11 <anonus> anyway, seems that i figured it out: takeWhile (~/= "</tag>") . dropWhile (~/= "<tag>")
02:06:41 <anonus> i was for some reason thinking that ~/= cannot take closing tags
02:10:13 <anonus> what is the point of sections btw?
02:10:29 <BartAdv> hi, I've setup a build with CircleCI, and it uses Ubuntu 14.04. The server I'm about to rent has Ubuntu 16.04 avaliable. Now, I've fetched the build artifacts and run them on my arch-linux machine just fine so I assume it should be possible to deploy to 16.04 as well, but then question is - what should be considered when doing such 'cross' builds? If the
02:10:30 <BartAdv> architecture is the same then it's all fine and if anything, if dynamic dependency is not on target machine then just installing it would do? 
02:14:02 <lyxia> anonus: they're shorter to write than other alternatives
02:16:52 <purelazy> anonus: (+3) is short for \x -> x + 3
02:18:26 <anonus> purelazy: yes, i know that, my question was about Text.HTML.TagSoup.sections
02:18:44 <purelazy> hehe: sorry
02:24:39 <rmrfroot> i'm using an older classy-prelude (0.11.1.1) and i'm trying to find out where `FilePath` is defined, all i can find is `FilePath :: *`. is it some kind of GHC built-in type?
02:26:29 <rmrfroot> nvm, i found out it was defined in the library system-filepath (Filesystem.Path) by using `:info FilePath` in ghci
02:43:20 <barrucadu> rmrfroot: If you click on a "FilePath" in the classy-prelude documentation (https://hackage.haskell.org/package/classy-prelude-1.0.2/docs/ClassyPrelude.html) it'll take you to where it's defined
02:44:04 <barrucadu> Oh, it's not a link in 0.11.1.1
02:54:02 <Profpatsch> Typeclassopedia, but for GHC Extensions.
02:55:35 <MarcelineVQ> Profpatsch: you looking for one? http://dev.stephendiehl.com/hask/#language-extensions   https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html
02:59:48 <tdammers> fwiw, classy prelude's haddock is kind of lousy due to the way it re-exports entire modules
03:00:05 <Profpatsch> MarcelineVQ: Thanks, straight to the bookmarks.
03:00:22 <Profpatsch> tdammers: Same for Protolude.
03:00:45 <Profpatsch> tdammers: Everybody would be eternally grateful if you fixed Haddock.
03:01:00 <tdammers> haha
03:01:29 <tdammers> I actually changed my own custom prelude (praglude) to explicitly list all exported symbols in the module header
03:01:42 <tdammers> just so the haddock would contain them all
03:01:43 <Profpatsch> No kidding, it’s fame and fortune.
03:02:06 <tdammers> well, I am currently unemployed, ...
03:02:17 <tdammers> but then, ugh, so many projects already
03:02:57 <Profpatsch> We should start a firm that has no other goal than to improve Haskell infrastructure.
03:03:25 <Profpatsch> And is funded by companies that rely on that infrastructure.
03:04:08 <Profpatsch> That would be a blast actually.
03:04:23 <Profpatsch> Anybody in?
03:04:59 <tdammers> you mean, funded by all 4 of them?
03:05:19 <Profpatsch> Well, I could list you probably 10 companies that earn big money in finance.
03:05:30 <tdammers> wait, you were being serious
03:05:37 <Profpatsch> Yeah, sure.
03:06:00 <Profpatsch> Well, ideas are for free.
03:06:02 <tdammers> isn't "companies funding haskell infra" basically the business model for the haskell-lang gang?
03:06:36 <Profpatsch> Not sure. But it’s not a single-company gig.
03:07:39 <Profpatsch> There’s also Well-Typed but they are doing advanced type-level stuff.
03:08:13 <Profpatsch> I think there might be enough demand for a group of people doing “grunt work” that just needs to be done.
03:12:03 <tdammers> hmhm
03:12:15 <Profpatsch> tdammers: https://pads.ccc.de/haskell-infra
03:12:25 <tdammers> maybe one important problem is that the kind of person who knows Haskell well enough to do that can also get more interesting jobs
03:13:09 <Profpatsch> Well, for most of these things you don’t have to be a very good haskeller.
03:13:25 <Profpatsch> Just a medium to good programmer.
03:13:37 <Profpatsch> Who also knows intermediate Haskell.
03:13:55 <Profpatsch> And I think it would be a very interesting job.
03:14:09 <tdammers> the ssl cert on that URI seems broken
03:16:17 <Profpatsch> Yes, it’s a CaCert
03:16:35 <Profpatsch> I’d move to another pad host, but I don’t know of one.
03:18:01 <how> Is there a vector stream fusion tutorial?
03:19:51 <Profpatsch> Meh, my connection is too flaky.
03:20:14 <tdammers> on a radically different note, I'm in need of some rubber ducking
03:20:45 <tdammers> using HDBC, I want to write queries with an IN operator in a WHERE clause; but I want the list of items in the IN () to be passed as a parameter
03:21:03 <tdammers> that doesn't seem to be possible, since SqlValue has no suitable constructor for lists
03:27:49 <tabaqui1> STM transactions are always pure, right?
03:28:42 <tabaqui1> how could I return timestamp from STM (UTCTime, Result)?
03:28:45 <tdammers> colloquially, yes
03:29:01 <tabaqui1> I want something alike
03:29:05 <tabaqui1> atomically $ do
03:29:11 <tabaqui1> t <- getCurrentTime
03:29:28 <tdammers> you can't, AFAIK
03:29:29 <tabaqui1> if pred then return (t, result) else retry
03:29:48 <tdammers> need to do the getCurrentTime in IO, so it has to happen outside the `atomically`
03:30:17 <tabaqui1> hmm
03:30:29 <tdammers> what's the problem you're trying to solve?
03:30:37 <opqdonut> can't you grab the time right after `atomically` succeeds?
03:30:57 <tabaqui1> I need to store this time for further transactions
03:31:07 <tdammers> what does the time represent?
03:31:08 <tabaqui1> result depends on time of previous action
03:31:13 <opqdonut> then perhaps before the atomically?
03:31:49 <tabaqui1> I need to pass timedelta in signal function
03:32:15 <tabaqui1> so my threads should write timestamp OR deltatime in shared memory
03:32:42 <tabaqui1> *timedelta
03:34:50 <tabaqui1> hmm, okay
03:35:32 <tabaqui1> looks like this timestaps have no correlations with real time
03:35:44 <tabaqui1> so I can smooth 'em a little
04:09:31 <merijn> Yeah, I would take a timestamp after/before the atomically (as appropriate)
04:22:32 <eklavya> hput here http://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString.html doesn't specify which exceptions it will throw
04:22:50 <eklavya> I need to attempt reconnection on socket exceptions
04:23:00 <ph88^> hey guys, i'm using stack and the foundation package, how can i update foundation to the latest commit ?
04:23:00 <eklavya> which exception should I catch?
04:33:23 <tabaqui1> eklavya: there are a lot of possible cases
04:33:32 <tabaqui1> usually it's just IOException
04:33:46 <eklavya> tabaqui1: yeah I think I'll catch em all
04:34:03 <eklavya> tabaqui1: thanks :)
04:34:50 <ocramz> memory lapse: what's the extension for using a String as a ByteString ?
04:35:15 <ocramz> as Text, sorry
04:35:18 <BartAdv> overloadedstrings
04:35:27 <ocramz> ah, sure, thanks BartAdv
04:36:49 <eklavya> wow I have read so many safe-exceptions doc pages and there isn't a single example here :/
04:50:35 <purelazy> what does use for pretty-printing? I googled and found https://hackage.haskell.org/package/GenericPretty. Is that prety good?
04:51:02 <purelazy> what does one use ... 
04:55:34 <quchen> purelazy: I recommend wl-pprint-ansi, it’s what most people use, and an extended version of the prettyprinter used in GHC.
04:56:11 <purelazy> quchen: OK thank you, thank you
04:56:30 <quchen> purelazy: I’ve got a significant overhaul of the wl-pprint lib in the pipeline with lots of documentation, so if you’re looking for examples run »stack haddock --open wl-pprint« in this repo: https://github.com/quchen/prettyprinter/
04:58:10 <purelazy> quchen: OK.Thx
05:01:16 <purelazy> quchen: ansi-wl-pprint
05:01:28 <quchen> purelazy: Oh, sorry, yes.
05:01:45 <purelazy> no prob
05:19:57 <babygau> hi, i'm wondering how haskell translate the simple math expression using prefix, not infix: `1 + 2 * 3 : 4 - 5`?
05:20:22 <Xnuk> > (+) ㄷ ㅆ
05:20:25 <Xnuk> > (+) 1 2
05:20:27 <lambdabot>  error: Variable not in scope: ㄷerror: Variable not in scope: ㅆ
05:20:28 <lambdabot>  3
05:22:31 <Insanity_> babygau: what exactly are you trying to find out?
05:22:53 <Insanity_> How haskell goes from: (+) 1 2 to 1 + 2?
05:23:15 <babygau> i'm a little confuse between function type constructor and function application
05:23:39 <babygau> while function type constructor (->) is right associative, function application is left associative
05:24:01 <babygau> trying to figure out how to write the above expression in one-line
05:24:12 <babygau> to see how functions are applied 
05:24:19 <b_jonas> Which one is that famous article about non-uniform polymorphism in haskell?
05:25:48 <shiona> "(-) ((:) ((*) ((+) 1 2) 3) 4) 5", if all the operators would have same precedence, were left associative and types would match
05:25:58 <pavonia> Insanity_: It actually goes from "1 + 2" to "(+) 1 2". Infix operators are just syntactic sugar
05:26:25 <shiona> but (:) needs a list on the right side, so at least that much will fail.
05:26:55 <b_jonas> maybe it's not called "non-uniform"? there's no "uniform" on http://okmij.org/ftp/Haskell/
05:28:51 <lyxia> b_jonas: do you mean "ad-hoc polymorphism", in the sense of what type classes offers
05:28:53 <babygau> tks @shiona, give me a few min to think about it :)
05:29:29 <Xnuk> If you do `:i (+)` in ghci, you can see "infixl 6 +", which mean it is left associative and its infix operator precedence is 6.
05:30:10 <Xnuk> and "infixr" is right associative
05:30:17 <b_jonas> lyxia: no, I mean a recursive data type and recursion over it where the data can recursively contain nodes of a potentially unbounded number of different possible types, but the recursive function you write will still work find on all those types
05:31:12 <b_jonas> This can be used to define a recursive algebraic type for a matrix represented as sort of list of lists where the algebraic type definition itself encodes the invariant that each row has the same length,
05:31:30 <lyxia> Oh I see what you mean. I can't find the word either...
05:31:50 <lyxia> polymorphic recursion?
05:31:58 <b_jonas> and for B-trees and similar tree structures where the algebraic data type definition encodes the invariant that the tree has the same path length to each leaf.
05:32:28 <dysfigured> i know some of these words
05:34:34 <b_jonas> I thought it was called non-uniform recursion or non-uniform polymorphism, but now I'm not so sure, maybe it's not called that or has another name too.
05:37:11 <Insanity_> pavonia: my bad! 
05:41:33 <babygau> tks @Xnuk and @shiona, but how about `function type constructor`? what does it mean by saying it's right associative?
05:42:25 <b_jonas> maybe it's called polymorphic recursion? 
05:45:29 <b_jonas> yes, it seems like it's called that... still trying to find the particular paper I want
05:47:22 <b_jonas> I think it must be Okasaki's paper http://www.usma.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/icfp99square.pdf 
05:48:32 <b_jonas> and it seems it's not on oleg's site 
05:55:29 <shiona> babygau: it means that (+)'s type is (if we constrict ourselves to int) "Int -> Int -> Int" a.k.a. "Int -> (Int -> Int)".
05:56:02 <shiona> that means that (+) takes an Int, and returns a function of type (Int -> Int) 
05:56:54 <purelazy> >:t (+)
05:56:57 <shiona> if, on the other hand (+) was for some reason of type "(Int -> Int) -> Int", it would require you to pass it a function of type "Int -> Int" (for example negation, or id), and would return you an int
05:57:19 <shiona> Which makes absolutely no sense.
05:57:23 <purelazy> >1
05:57:41 <purelazy> how to use the repl?
05:57:51 <shiona> add a space after >
05:58:01 <babygau> > :t (+)
05:58:03 <purelazy> > :t (+)
05:58:03 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:58:06 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:58:09 <shiona> :t (+)
05:58:11 <lambdabot> Num a => a -> a -> a
05:58:21 <purelazy> :t (+)
05:58:23 <lambdabot> Num a => a -> a -> a
05:58:54 <purelazy> + takes anything (as long as they are numbers)
05:59:21 <shiona> :D
05:59:39 <babygau> let's say we have `a -> b -> c -> d -> e -> f`
06:00:12 <babygau> how would we represent it in right associative by parenthese?
06:00:56 <lyxia> a -> (b -> (c -> (d -> (e -> f))))
06:01:20 <wonder90> A question about function inlining. Rather than using {-# INLINE foo #-} at the definition of foo, am I able to use inside another function, in a let/where, that I absolutely want `foo` inlined here.
06:01:29 <babygau> @lyxia, i wanna see the direction 
06:01:29 <lambdabot> Unknown command, try @list
06:01:32 <babygau> sorry my bad english 
06:01:40 <wonder90> e.g. let x = {-# INLINE HERE #-} foo 10
06:01:59 <babygau> i mean haskell will translate (e -> f) first 
06:02:15 <lyxia> babygau: I did not understand.  Also don't use @ to address people.
06:02:17 <babygau> or a -> (b -> c -> d -> e -> f)?
06:02:29 <wonder90> I might not always want `foo` inlined everywhere, but I absolutely know that I want foo inlined into `bar`.
06:03:36 <purelazy> babygau: Sure - inside (b -> c -> d -> e -> f) its (b -> (c -> (d -> (e -> f))))
06:03:58 <babygau> tks purelazy 
06:04:16 <purelazy> but without the unecessary brackets
06:04:19 <babygau> but i mean the steps
06:04:31 <babygau> hmm, i will take example 
06:04:45 <babygau> a -> b -> c -> d
06:04:58 <babygau> because -> is right associative
06:05:07 <babygau> will haskell will do it as 
06:05:13 <babygau> (c -> d)
06:05:32 <babygau> b -> ( c -> d)
06:05:45 <babygau> a -> (b -> ( c -> d))
06:06:08 <babygau> or it will translate it in opposite way?
06:06:32 <babygau> a -> ( b -> ( c -> d ))
06:06:48 <babygau> b -> ( c -> d)
06:06:52 <babygau> (c -> d)
06:06:58 <babygau> u understand what i meant?
06:07:08 <purelazy> I do understand
06:07:52 <purelazy> Seems you are asking what the compiler does - I don't have a clue
06:08:08 <babygau> haha
06:08:20 <babygau> i'm just curious 
06:09:38 <purelazy> If you know what right (or left) -associativity means, you know enough to get all this a -> b -> c stuff
06:11:16 <babygau> yay 
06:11:20 <babygau> i'm reading haskell book 
06:11:31 <purelazy> which one
06:11:45 <babygau> and the author mentioned about haskell lambda in the right first chapter
06:12:09 <systemfault> So it's the "Haskellbook"?
06:12:10 <babygau> basically function or lambda just take 1 arg and return 1 value 
06:12:13 <babygau> yep 
06:12:27 <purelazy> yep
06:12:28 <systemfault> That book is great
06:12:55 <purelazy> and the function has no  name - dont forget that
06:13:26 <babygau> i'm reading on chapter 6 on ready, but when i recall sth about left or right associate, i'm wondering about the order of them, how haskell translate them in the correct order
06:13:36 <babygau> i know it's way out of my knowledge
06:14:37 <purelazy> no need to get too deep 
06:14:42 <purelazy> cos its not that deep
06:14:49 <babygau> ha ha 
06:14:55 <babygau> tks u
06:15:33 <purelazy> : (\x -> 2 * x) 7
06:15:48 <Xnuk> :t (\x -> 2*x) 7
06:15:50 <lambdabot> Num a => a
06:16:08 <purelazy> > (\x -> 2 * x) 7
06:16:11 <lambdabot>  14
06:17:17 <babygau> what r u doing?
06:17:42 <purelazy> that's a lambda followed by an argument
06:17:43 <Xnuk> > (2*) 7
06:17:45 <lambdabot>  14
06:18:07 <babygau> that's partial application right?
06:18:17 <babygau> i heard haskell function is curried by default
06:18:52 <Xnuk> yup
06:19:00 <purelazy> actually no - that's not partial
06:20:17 <Xnuk> :t (*)
06:20:18 <systemfault> It's curried and has "sections" which confused me a bit for a while
06:20:19 <lambdabot> Num a => a -> a -> a
06:20:27 <purelazy> the lambda required one argument, and it got it - the 7
06:21:19 <purelazy> babygau: You were right-ish when you said a lambda takes one argument
06:24:54 <babygau> haha :)
06:25:58 <merijn> purelazy: Not right-ish, just right :)
06:26:19 <ph88^> hey guys, i'm using stack and the foundation package, how can i update foundation to the latest commit ?
06:26:23 <babygau> goodbyes guys, many thanks for helping me out
06:26:49 <Guest84442> hi People,  <purelazy> could you help me ?  I'm looking for Haskell books about Deep Learning (AI)
06:28:34 <ph88^> Guest84442, i think you can better use python for machine learning and deep neural nets
06:28:53 <purelazy> Guest84442: I don't know any 
06:29:14 <Guest84442> Hi ph88 ,  yeah,  I have written a lot using Python
06:29:14 <purelazy> Guest84442: Yeah - Python seems to be ahead of the curve in NNs
06:29:37 <purelazy> Stick with Theano etc
06:29:48 <Guest84442> but I wish to start for using Haskell on CNN
06:29:56 <Maegner> hey i'm new to the community and i would like to get started in Open Source projects can someone give me some advice?
06:30:22 <Maegner> i know C, Java, Lua and Python (and a lil bit of prolog)
06:30:28 <dunx> Maegner: read lots of code
06:30:43 <merijn> ph88^: I would vehemently disagree with python for machine learning >.>
06:30:51 <dunx> Maegner: find a project you like, find a problem, send a patch
06:31:07 <purelazy> Guest84442: https://crypto.stanford.edu/~blynn/haskell/brain.html
06:31:21 <merijn> Maegner: Any particular reason you're asking in #haskell if it's not on your list of languages? :)
06:31:27 <purelazy> Guest84442: Maybe you can join a CNN project
06:31:41 <purelazy> Guest84442: Or start you're own
06:32:09 <purelazy> Guest84442: your
06:32:43 <Maegner> i was looking for good IRC channels for programmers and the haskeel came up as the best so i thought it would be a good place to start
06:33:14 <dunx> Maegner: learn Haskell then
06:33:47 <purelazy> Maegner: install a haskell for great good
06:33:51 <Guest84442> I want to start for using Haskell for my new CNN projects
06:33:51 <Guest84442> I'm gonna check it out
06:33:55 <sdx23> Maegner: do work on projects that you're using yourself. This gives some extra motivation.
06:35:15 <Maegner> i'm having a lil bit of a hard time finding a project atm and when i find one i don't know where to start, and how to start
06:40:45 <purelazy> Maegner: What are your interests?
06:42:29 <zomg> Maegner: this might be useful https://yourfirstpr.github.io/
06:42:55 <Maegner> network programming, Multi threading, building applications, i guess i like mostly everything 
06:44:17 <merijn> Whoo! Managed to dramatically simplify my code merely by remembering functions are instances of Monoid...
06:47:56 <purelazy> merijn: what did you do?
06:48:34 <merijn> purelazy: I'm using xml-conduit to scrape some XML, it has "attributeIs :: Name -> Text -> Axis" to select all node that have a certain attribute
06:48:56 <merijn> (type Axis = Cursor -> [Cursor])
06:49:27 <merijn> And I was, for a long time, annoyed by the inability to do something like "select all nodes that have attribute A *or* attribute B"
06:50:23 <merijn> purelazy: Then I realised that since "Cursor -> [Cursor]" is a Monoid I can just do: attributeIs "attrA" "value1" <> attributeIs "attrB" "value2"
06:50:34 <merijn> Which ends up doing exactly that
06:50:52 <purelazy> cool
06:51:23 <shayan_> Are there any books on Reflex?
06:53:05 <merijn> purelazy: I always forget about "instance Monoid m => Monoid (a -> m)" even though it's so useful
06:53:24 <merijn> (Note that that instance applies recursively!)
06:56:33 * deusXM_0
06:57:10 <purelazy> quchen: I ended up using Text.Groom for my simple (debug output) prettyprinting needs
06:58:21 <quchen> purelazy: Oh, you’re trying to prettyprint »Show« output? I also have something for that based on the WL prettyprinters ;-) https://hackage.haskell.org/package/show-prettyprint
06:58:24 <purelazy> one import, and instead of putStrLn (show structure), its putStrLn (groom structure)
06:59:13 <purelazy> I don't need the Roll-Royce of pretty-printers (at the moment)
07:04:54 <merijn> ok, so I have 3 functions, "bar :: Foo -> Maybe Bar", "baz :: Foo -> Maybe Baz". "quux :: Foo -> Maybe Quux" and a datatype "data Xyzzy = Xyzzy { x1 :: Bar, x2 :: Baz, x3 :: Quux }", any suggestions how to, conveniently turn those three functions into "Foo -> Maybe Xyzzy"?
07:05:02 <merijn> Or either, or whatever
07:05:26 <merijn> It feels somewhat monoidal, but don't ask me how exactly :\
07:05:58 <Akii> liftA3?
07:07:10 <merijn> hmm, maybe it's just a double lift...once for the maybe, once for the function
07:07:57 <shiona> bar >=> baz >=> quux or something like that?
07:08:13 <merijn> shiona: That doesn't typecheck
07:08:17 <shiona> ok
07:08:51 <merijn> I think liftA is right, but now I need to figure out how to avoid dealing with an annoying double lift
07:09:13 <shiona> agh, sorry, for some reason I read that "quux :: Foo -> Maybe Xyzzy"
07:10:06 <arjanb> liftA3 (liftA3 Zyzzy)
07:10:40 <Akii> I was one lift off :D
07:14:24 <ph88^> i'm using stack and the foundation package, how can i update foundation to the latest commit ?
07:16:46 <shiona> merijn: (liftA3 Xyzzy <$> bar <*> baz <*> quuz)
07:26:36 <quchen_> :t liftA3 . liftA3
07:26:38 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 a) -> f (f1 b) -> f (f1 c) -> f (f1 d)
07:27:15 <quchen_> ⇒ (liftA3 . liftA3) Xyzzy bar baz qux
07:27:17 <purelazy> :t 1
07:27:19 <lambdabot> Num t => t
07:27:57 <quchen_> merijn: ^^^
07:28:25 <merijn> quchen_: Yeah, I realised that a while up, I'm just trying to work this realisation into one or two helpers that don't suck :)
07:28:37 <purelazy> > 1+1
07:28:40 <lambdabot>  2
07:28:47 <quchen_>  > let liftAA3 = liftA3 . liftA3 -- there you go, merijn ;-)
07:29:10 <lyxia> liftA3^2 = liftA9
07:29:15 <merijn> quchen_: I need to fit it inside the xml-conduit API :p
07:29:42 <merijn> quchen_: Which doesn't seem to have a neat way to deal with tags/entries that should be unique/required
07:30:27 <quchen_> lyxia: The same kind of wrong is what makes people write sin²(x) for (sin(x))².
07:30:31 <quchen_> :-C
07:45:54 <tabaqui1> what means ~(a,b)?
07:46:08 <tabaqui1> ~ symbol precisely
07:48:01 <b_jonas> tabaqui1: in a pattern the tilde symbol means a lazy match, that is, matching ~(a,b) will succeed without evaluating the pair and even if the pair is undef
07:49:05 <tabaqui1> b_jonas: thanks
07:49:19 <Hermit> how should I go about implementing callbacks in a transformer stack so that I can define callbacks involving upper layers?
07:49:58 <b_jonas> > case undefined of { (a,b) -> 2; }
07:50:00 <lambdabot>  *Exception: Prelude.undefined
07:50:03 <b_jonas> > case undefined of { ~(a,b) -> 3; }
07:50:06 <lambdabot>  3
07:50:14 <b_jonas> tabaqui1: ^ examples
07:51:14 <kuribas> is that the only time case doesn't evaluate it's argument?
07:51:23 <merijn> No
07:51:31 <merijn> > case undefined of a -> 2
07:51:34 <lambdabot>  2
07:52:22 <kuribas> merijn: so it evaluates only when it's a constructor, without lazy match?
07:52:23 <tabaqui1> > case 2 of { ~(a, b) -> a + b; }
07:52:26 <lambdabot>  error:
07:52:26 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M838904008163...
07:52:26 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:52:38 <merijn> kuribas: Right
07:52:45 <kuribas> ok, thanks!
07:53:19 <tabaqui1> > :t case 2 of { ~(a, b) -> a + b; }
07:53:21 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:53:22 <merijn> tabaqui1: ~ doesn't magically allow type errors
07:53:23 <tabaqui1> :t case 2 of { ~(a, b) -> a + b; }
07:53:25 <lambdabot> (Num (a, a), Num a) => a
07:53:55 <merijn> Tuples aren't (normally) instances of Num
07:53:57 <tabaqui1> merijn: but it tries to eval "a + b"?
07:54:03 <kuribas> tabaqui1: it thinks (a,a) is a Num instance.
07:54:25 <b_jonas> > case (3, 1) of { (a, b) -> 4; } {- try with a pair ->
07:54:28 <lambdabot>  <hint>:1:33: error: unterminated `{-'
07:54:28 <b_jonas> > case (3, 1) of { (a, b) -> 4; } {- try with a pair -}
07:54:30 <lambdabot>  4
07:55:20 <tabaqui1> looks dangerous
07:55:27 <tabaqui1> I'll better avoid of this
07:55:52 <b_jonas> it's not really anything dangerous, it's the same thing as the let keyword does, only this lets you do it inside a pattern
07:56:14 <b_jonas> > let { (a,b) = (3,1); } in 4
07:56:17 <lambdabot>  4
07:56:24 <b_jonas> > let { (a,b) = undefined; } in 3
07:56:26 <lambdabot>  3
07:56:41 <b_jonas> works the same way, the tilde syntax is useful only to put it inside a larger pattern
07:57:10 <tabaqui1> let { (a,b) = 5; } in 4
07:57:13 <tabaqui1> > let { (a,b) = 5; } in 4
07:57:15 <lambdabot>  error:
07:57:15 <lambdabot>      • Could not deduce (Num (t, t0))
07:57:15 <lambdabot>        from the context: Num (t, t1)
07:57:41 <tabaqui1> not so lazy, eh?
07:58:09 <b_jonas> it does the runtime pattern match lazy, not the type inference
07:58:23 <merijn> tabaqui1: I don't understand what you're trying to say?
07:58:33 <b_jonas> if you want type inference lazy, there's some ghc option for that, but it's rarely useful, because it defeats some of the point of type inference.
07:59:28 <tabaqui1> FlexibleContexts?
07:59:48 <b_jonas> no, -fdefer-type-errors
08:00:10 <tabaqui1> merijn: not sure, just looking around
08:00:24 <b_jonas> it's an advanced option, not something you want usually
08:01:03 <tabaqui1> > 1 / 0
08:01:05 <lambdabot>  Infinity
08:01:18 <Zowlyfon> > 0 / 0
08:01:20 <lambdabot>  NaN
08:01:33 <Zowlyfon> that's better than wolfram alpha
08:02:49 <tabaqui1> b_jonas: in my example ghc checks that Int is a pair and throw an error
08:03:19 <tabaqui1> and in your - ghc thinks that "undefined" is alike universal type
08:03:30 <tabaqui1> that can pass all type checkers?
08:04:58 <b_jonas> @type undefined {- let's ask ghc about that -}
08:05:00 <lambdabot> a
08:05:49 <merijn> tabaqui1: undefined *is* a universal type
08:06:23 <tabaqui1> makes sense
08:06:28 <tabaqui1> thanks to all
08:06:29 <slx> Types, the solution for "undefined is not a function"
08:06:42 <merijn> undefined is a function, though :)
08:06:47 <slx> indeed ;)
08:07:04 <slx> I once renamed my username to 'undefined' and it broke an entire webapp
08:09:01 <pikajude> i love weak typing
08:11:12 <hodapp> slx: lol, that is horrible
08:11:52 <nshepper1> /nick 'unsafePerformIO installMalware'
08:12:39 <pikajude> pff, like they'd give it a name like that
08:12:52 <pikajude> /nick unsafeUnutterablePerformMalware'
08:12:59 <slx> I'm pretty sure that the client side JS was doing a double equal vs tripple on `username` is undefined
08:13:31 <pikajude> but undefined doesn't even == "undefined" in JS-land
08:14:22 <slx> true...
08:14:57 <pikajude> so who knows WHAT they were doing
08:16:01 <nshepper1> authenticate(eval(username)) // FIXME not sure if correct
08:16:31 <slx> hahahahahah
08:19:35 <b_jonas> no no. it wasn't written in javascript, but some other language. and they're programmers following good practices, not hiding info in comments, so it was (FIXME (authenticate (eval username))); where the global variable FIXME is defined as FIXME = id during most of development and will be changed to FIXME = undefined later
08:20:04 <pikajude> that looks like haskell
08:20:06 <b_jonas> (whoever writes //FIXME ? that's just calling for trouble)
08:20:11 <pikajude> i wonder what their eval implementation looks like
08:23:13 <elfeck> hi. does someone know a msum, that fails everything if one of the items fails?
08:23:51 <lyxia> sequence
08:24:20 <jeltsch> lyxia: sequence is not an msum analog, AFAICT.
08:24:40 <lyxia> msum that fails if one item fails sounds contradictory
08:25:35 <jeltsch> elfeck: It does not make sense to me to have such a function for arbitrary MonadPlus instances. After all, the mzero case is just a corner case. Think of lists, where [] is really only one out of infinitely many cases (where a case corresponds to the list length).
08:26:01 <jeltsch> elfeck: It does make sense to me to have such a function for Maybe only, since there, you have just failure (Nothing) vs. success (Just).
08:26:01 <elfeck> hm
08:28:16 <dolio> To do it in general, you need a way to detect 'failure' and do something based on it, which MonadPlus doesn't allow.
08:28:59 <dolio> MonadLogic in logict provides such a thing.
08:29:05 <elfeck> okay I think what Alternative <|> applied to a list
08:29:21 <elfeck> yes
08:29:35 <elfeck> is there a function of that?
08:29:50 <elfeck> so item1 <|> item2 <|> ... <|> itemN
08:30:48 <jeltsch> elfeck: This would be just msum.
08:31:06 <jeltsch> With <|>, “failure” cases do not lead to failure of the whole thing.
08:31:19 <jeltsch> mzero is the neutral element of <|>.
08:31:29 <how>  /quit
08:32:11 <elfeck> jeltsch: yes but with <|> I only get the first action that succeeded and nothing else right
08:32:22 <elfeck> jeltsch: but msum does more stuff and concats or something
08:33:25 <lyxia> that's not true in general for Alternative
08:33:34 <jeltsch> elfeck: No. msum repeatedly applies mplus repeatedly.
08:33:40 <lyxia> > [True] <|> [False]
08:33:43 <lambdabot>  [True,False]
08:33:47 <jeltsch> elfeck: It concats only if mplus concats.
08:33:57 <elfeck> ah I see
08:34:02 <jeltsch> elfeck: And mplus is the same as (<|>).
08:34:23 <elfeck> I will need to think about this. This monad stuff still is very confusing to me
08:34:30 <elfeck> thanks for your help so far
08:34:45 <b_jonas> @src (<|>)
08:34:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:34:46 <jeltsch> elfeck: You’re welcome. :-)
08:35:13 <jeltsch> What? lambdabot is humiliating people?
08:35:21 * jeltsch thinks that this is new.
08:35:31 <hexagoxel> it is not new
08:35:44 <jeltsch> You don’t know how old I am. :-D
08:35:59 <glguy> It's about as old as lambdabot
08:36:04 <b_jonas> it's called "insulting"
08:36:10 <b_jonas> not "humiliating"
08:36:14 <b_jonas> but it's not new
08:36:19 <dolio> Old as the @src plugin, anyway.
08:37:10 <dolio> Someone should take out every message except, "I'm using the scrambler."
08:43:43 <mmaruseacph2> @src (?!)
08:43:43 <lambdabot> Source not found. My pet ferret can type better than you!
08:47:41 <shapr> mmaruseacph2: (?!) is in Data.Sequence
08:50:07 <glguy> (!?) is in Data.Sequence, among other places
08:50:20 <glguy> but only as of containers-0.5.8, which is newer than comes with GHC
08:52:15 <shapr> and I am sad, I want the neat things in containers-0.5.9+
08:52:18 <hexagoxel> at least my pet ferret uses nighly ghc!
08:52:30 <shapr> hexagoxel: your pet ferret is braver than I am
08:52:48 <shapr> hexagoxel: now I want pictorial proof that your ferret uses a computer at all :-P
08:53:55 <hexagoxel> shapr: ask lambdabot first please :p
08:54:24 <shapr> hexagoxel: oh hey, do you use TidalCycles?
08:55:00 <bwe> Hi, is there some standard lib providing a function to determine the greatest common denominator? I can not find any on hackage. Or should I define it on my own?
08:55:08 <glguy> :t gcd
08:55:11 <lambdabot> Integral a => a -> a -> a
08:55:41 <bwe> I am impressed.
08:56:37 <Sornaensis> > [1..]
08:56:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:58:40 <shapr> @quote hexagoxel 
08:58:40 <lambdabot> No quotes match. Take a stress pill and think things over.
08:59:32 <hexagoxel> shapr: huh? what has tidal have to do with this?
08:59:46 <hexagoxel> the answer is no.
09:00:00 <shapr> hexagoxel: I just noticed you're on #supercollider as well, so I thought you might be using tidalcycles
09:00:18 <shapr> hexagoxel: this Haskell thing: https://tidalcycles.org/
09:02:36 <kuribas> :t (liftA3 . liftA3)
09:02:39 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 a) -> f (f1 b) -> f (f1 c) -> f (f1 d)
09:04:10 <hexagoxel> shapr: one of my long-term projects is a non-live synthesizer (in haskell, mostly); that's why i am in several related channels.
09:04:43 <hexagoxel> shapr: the "live" style does not appeal to me much
09:07:40 <Alxandr> Hi. I'm getting linker errors suddenly when building my haskell code (using stack) and need some debugging help
09:08:21 <Alxandr> It's saying undefined reference to `Phidoczm0zi1zi0zi0zm1IVsJzzckfXrBd2bAeKyN06_TextziPhidoc_relink_closure'
09:08:55 <Alxandr> And I don't even know how to start figuring out what's wrong here
09:09:03 <Alxandr> I've tried googling, but I couldn't find anything
09:18:27 <Liskni_si> Alxandr: it also says which object file causes this error, if you remove it and let it rebuild, is it still happenning?
09:19:29 <Alxandr> I tried to remove the `.stack-work` folder
09:20:30 <elfeck> is it possible that "a `mplus` b" and "msum [a, b]" have different results?
09:23:39 <mmaruseacph2> shapr, glguy: thanks, I was mostly testing the lambdabot's message
09:24:52 <Liskni_si> Alxandr: all of them? there's one where stack.yaml is and then one in each package dir with .cabal file
09:25:22 <Alxandr> I only have a single cabal file
09:25:37 <Liskni_si> Alxandr: but if a clean rebuild results in an undefined reference that isn't related to FFI, it's most likely a GHC bug
09:25:48 <Alxandr> :(
09:26:18 <Alxandr> I can try to downgrade the GHC
09:26:25 <Liskni_si> I found one a few months ago but didn't report it as it had been fixed in GHC 8 already
09:26:42 <Alxandr> I'm on 8.0.1
09:26:48 <Alxandr> Which seems to be the latest
09:28:03 <Liskni_si> oh :-(
09:29:13 <Liskni_si> Alxandr: the responsible thing to do would be to find a minimal example and file a bug
09:29:41 <Liskni_si> but I guess you need a workaround sooner :-/
09:29:44 <Alxandr> Well, my code is like 80 LOC in total
09:29:44 <elfeck> okay I am confused. msum uses <|> ... is there an equivalent that uses mplus?
09:29:54 <Alxandr> I'm totally new to haskell
09:29:59 <Alxandr> And just trying to get stuff up and running
09:30:03 <Alxandr> So this is kind of a bummer
09:30:04 <Liskni_si> oh
09:30:27 <Liskni_si> sounds quite unlikely you'd run into that sort of issue at this stage
09:30:37 <Liskni_si> perhaps you are doing something wrong after all :-)
09:31:30 <Alxandr> Would you mind taking a look? I uploaded the entire thing to https://github.com/Alxandr/Phidoc
09:31:40 <Alxandr> As said, it's very little code
09:32:10 <nshepperd> elfeck: mplus is supposed to be the same as <|>, i think
09:32:45 <eklavya> how to analyze if a haskell program is leaking memory (no space leaks just good old memory leak) ?
09:32:51 * nshepperd wonders why that law isn't written in the MonadPlus docs though
09:33:53 <Alxandr> At least if I've done something obviously wrong it'd be good to know :)
09:34:07 <Alxandr> Also, there is always the chance that it's just my PC that's borked
09:34:18 <Liskni_si> Alxandr: building it will take a while :-)
09:34:31 <Alxandr> Yeah, I know. The deps takes forever -.-
09:35:23 <Liskni_si> (and some disk space, oh how I long to be back in 2010 when I could just apt install haskell-platform and be done with it)
09:35:49 <Alxandr> Btw, I'm on Windows, so that might also be a factor
09:36:01 <Liskni_si> that might indeed :-)
09:44:00 <Liskni_si> Alxandr: it fails to link on linux, too :-)
09:44:22 <Alxandr> Is it weird that I don't know if that's good or bad news?
09:45:01 <Liskni_si> it's good news in the sense it's reproducible and you're not alone :-)
09:45:37 <Alxandr> Do you have any idea how to go about fixing it though?
09:48:47 <Liskni_si> Alxandr: seems that adding Text.Phidoc to other-modules or exposed-modules, like the warning says, fixes this
09:49:04 <Liskni_si> although I've never seen this result in an actual linker error
09:49:17 <Liskni_si> not sure if that's worth reporting :-/
09:50:00 <mbw> Hello everyone. When defining a function dot xs = sum . zipWith mul xs; where mul x y = x * conjugate y , GHC deduces a RealFloat constraint.
09:50:12 <Alxandr_> Sorry, could you say that again (webchat lost connection)
09:50:18 <mbw> However, conjugate should work for Num, as well as multiplication and sum.
09:50:30 <Liskni_si> Alxandr_: seems that adding Text.Phidoc to other-modules or exposed-modules, like the warning says, fixes this; although I've never seen this result in an actual linker error; not sure if that's worth reporting :-/
09:50:33 <mbw> So where does this come from?
09:51:01 <Alxandr_> Hmm, I don't see a warning anywhere though?
09:51:07 <Alxandr_> Where did you get a warning?
09:51:11 <Alxandr_> And what is exposed-modules?
09:51:18 <mbw> oh, I forgot to mention I am using Data.Complex.
09:51:27 <Alxandr_> Ah, in the cabal file
09:51:46 <Liskni_si> Alxandr_: stack build gave me a colorful warning that it isn't mentioned in the cabal file
09:52:31 <Alxandr_> Hmm, I get no warnings though
09:52:37 <Alxandr_> Maybe I have a old version of stack?
09:52:54 <Liskni_si> then again, it's a warning, and it usually just means you should fix your cabal file someday, not that the build is going to fail horribly :-)
09:52:59 <Liskni_si> I have 1.3.2
09:53:03 <Alxandr_> 1.1.2
09:53:10 <Liskni_si> this warning has been there for a while though
09:53:59 <adarqui> Hi. I already quit purescript. Now i'm officially quitting Haskell & GHCJS. It's an absolute nightmare. The biggest problem with purescript & ghcjs are the bugs/issues you experience after your code base grows very large, so most people will be fine writing small applications. I'm sure none of you will care, that's fine and expected. Just stating this for irc history. Finally, the haskell community - which was one of the most luring aspects of me learning haskell in
09:54:06 <adarqui> peace
09:55:36 <Liskni_si> mbw: instance RealFloat a => Num (Complex a)
09:57:00 <mbw> So I cannot technically define functions like the above dot product which works with say Integer?
09:57:01 <Liskni_si> mbw: presumably because Num has abs
09:57:14 <mbw> @t abs
09:57:14 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
09:57:26 <ongy> :t abs
09:57:28 <lambdabot> Num a => a -> a
09:57:35 <Alxandr_> Wait, stack manages ghcs?
09:57:40 <Liskni_si> > abs (5 :+ 5)
09:57:42 <lambdabot>  7.0710678118654755 :+ 0.0
09:57:56 <Liskni_si> ^^ you can't compute this in Complex Integer
09:58:21 <Alxandr_> Liskni_si: Anyways, thanks a lot :)
09:58:44 <kuribas> > (5 :+ (5::Int))
09:58:46 <lambdabot>  5 :+ 5
09:58:51 <kuribas> > abd (5 :+ (5::Int))
09:58:53 <lambdabot>  error:
09:58:53 <lambdabot>      • Variable not in scope: abd :: Complex Int -> t
09:58:53 <lambdabot>      • Perhaps you meant one of these:
09:58:55 <kuribas> > abs (5 :+ (5::Int))
09:58:58 <lambdabot>  error:
09:58:58 <lambdabot>      • No instance for (RealFloat Int) arising from a use of ‘abs’
09:58:58 <lambdabot>      • In the expression: abs (5 :+ (5 :: Int))
09:59:03 <monochrom> > signum (5 :+ 5)
09:59:05 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
09:59:19 <kuribas> interesting
09:59:21 <Liskni_si> Alxandr_: yeah, stack manages ghcs, if you tell it to, or by default since 1.2.0 or something
09:59:23 <mbw> Ok. I think I read somewhere that abs being in Num was criticized.
09:59:56 <ongy> > sqrt(5^2+5^2) -- Is it just the "length" (whatever it's called for complex numbers)
09:59:58 <lambdabot>  7.0710678118654755
10:00:13 <monochrom> yes. modulus. magnitue. norm...
10:00:17 <Boomerang> kuribas: the Num instance for Complex requires RealFloat on a
10:00:25 <kuribas> yeah
10:00:39 <Liskni_si> mbw: This is probably one of the arguments. :-)
10:00:51 <monochrom> And you get irrational magnitudes so you can't even have Complex Rational
10:01:31 <mbw> This makes it kind of annoying to test properties, since you're comparing floating-point values.
10:02:42 <mbw> Back to pairs I guess.
10:03:58 <mbw> Btw is there something more concise for the "accumulate . zipWith pattern"?
10:04:47 <mbw> I feel like there should be some kind of folding function to capture this.
10:13:18 <kuribas> what's accumulate?
10:18:06 <Younder> sound like sum to me
10:18:36 <ongy> :t accumulate
10:18:38 <lambdabot> error: Variable not in scope: accumulate
10:18:50 <Younder> :t sum
10:18:52 <lambdabot> (Foldable t, Num a) => t a -> a
10:20:12 <f-a> I am pretty happy with cabal new-build, but is there a way to simulate a `cabal new-install`? Or do I have to cabal fetch xyz cd xyz-0.0.1.0 cabal new-build? 
10:24:15 <hexagoxel> f-a: "install --dep" is part of "new-build" last i checked.
10:25:49 <f-a> hexagoxel: so what would I have to do, cabal install --dep mypackagename?
10:26:12 <hexagoxel> f-a: to achieve what?
10:27:43 <hexagoxel> f-a: building of non-local dependencies does not require nor support manual management with new-build.
10:28:15 <f-a> hexagoxel: as now when I get a repo (say, hledger) and cabal new-build it, I see a new folder (called `store`) in my ~/.cabal, and the exec is placed under ~/.cabal/bin
10:29:03 <f-a> that's quite handy (moreover, you can fire ghci and have packages already there, while now I susped I would have to create a project and modify the .cabal file to and then cabal repl to toy with something)
10:29:45 <cocreature> f-a: there is an issue about a global environment for cabal new-build but it does not yet exist
10:30:25 <cocreature> f-a: https://github.com/haskell/cabal/issues/3737
10:31:22 <polyrod> Hi, who can please shortly explain "|" in class MonadReader r m | m -> r where , thanks
10:31:40 <polyrod> is it or ??? realy ?
10:32:25 <geekosaur> it's a functional dependency: it specifies that if the compiler knows the type of m, it can be certain that there is exactly one matching type for r
10:32:53 <geekosaur> which means it can do type inference, which is otherwise nearly impossible with a multiparameter typeclass
10:33:09 <f-a> cocreature: thanks, happy to see the issue has been raised and there are people willing to implement it
10:33:35 <cocreature> f-a: now the people willing to implement it just need to find the time to implement it :)
10:34:03 <polyrod> geekosaur, ah ... ok .. thanks ...
10:35:40 <geekosaur> polyrod, you can read the "|" as "where", like with list comprehensions [ x | x <- ...]
10:35:54 <polyrod> geekosaur, yes , i read there are two ways to transformers , functional dependency , or type families
10:36:27 <polyrod> "where" like the mathematical |
10:37:01 <polyrod> put the actual dependency looks like a function m -> r
10:37:10 <polyrod> s/put/but/ :)
10:37:14 <geekosaur> here the -> can be read as "determines"
10:37:22 <polyrod> k,
10:37:40 <polyrod> the more i know , the more i know  i don't know  ...:)
10:37:58 <geekosaur> isn't that always true? :)
10:38:38 <maerwald> there is only one correct answer to that question: I don't know
10:38:39 <polyrod> so the new version of mtl , uses functional dpendencies instead of type families ...
10:41:20 <cocreature> not sure what you mean by “new” but it’s literally used functional dependencies for years. not sure if mtl used type families at some point before that
10:43:32 <geekosaur> polyrod, no. the original mtl was monolithic. there was briefly a split version where you could pick fundeps or type families (transformers + monads-fd or monads-tf), then mtl2 was written as more or less the monads-fd version based on transformers
10:43:46 <geekosaur> mostly because it meant minimal code changes
10:44:58 <polyrod> so when i ask my navi to go from "basic understanding of functors,applicative,monad,>>=,return,MonadPlus,xxxxT" to "knowledge of a monad-library to practically work with" mtl2 is the wy to go or should i dig deeper in FreeMondrasctically wo
10:45:00 <geekosaur> but mtl itself was always fundep based; it just had everything inside itself instead of being based on transformers (and the simple monads Reader, Writer, State were independent of the transformer versions instead o being the transformers over Identity)
10:45:45 <vektorweg1> has someone done some research on running pure floating point (ieee754) calculations on different processors and can say when it would stay pure?
10:46:21 <vektorweg1> *meaning same results on different machines. 
10:46:54 <geekosaur> you will want to understand mtl just because lots of code uses it
10:47:16 <polyrod> geekosaur, thank you very much ...
10:47:33 <polyrod> i will concentrate on mtl 
10:48:09 <geekosaur> vektorweg1, I vaguely recall someone doing FP stuff across CPUs (and specifically some differences between Intel and MIPS) but don't recall details
10:49:08 <geekosaur> I don't know of any involving current CPUs and I doubt you care about MIPS/SPARC/Alpha/PPC :)
10:50:28 <vektorweg1> geekosaur: would be nice to know though. at least for armhf too. 
10:59:25 <Squarism> sure i can roll my own. But theres no reverseIt : Ordering -> Ordering ?
11:02:05 <geekosaur> I think you want the Dual newtype?
11:03:23 <Squarism> oh ok.. ill look into it
11:08:44 <ClaudiusMaximus> > map (compare EQ) [LT..GT]
11:08:46 <lambdabot>  error:
11:08:46 <lambdabot>      Not in scope: ‘LT..’
11:08:46 <lambdabot>      No module named ‘LT’ is imported.error:
11:08:52 <ClaudiusMaximus> > map (compare EQ) [LT .. GT]
11:08:54 <lambdabot>  [GT,EQ,LT]
11:09:15 <ClaudiusMaximus> Squarism: ^
11:10:03 <Squarism> neat
11:14:42 <kadoban> :t comparing Down -- there's also this, in some contexts very helpful
11:14:44 <lambdabot> Ord a => a -> a -> Ordering
11:17:21 <geekosaur> muh. I think Downw as what I was trying to remember (and landed on Dual which works for chained stuff...)
11:17:27 * geekosaur still working on coffee
11:17:28 <glguy> :t flip compare
11:17:30 <lambdabot> Ord a => a -> a -> Ordering
11:17:41 <dmj`> :t \f xs -> mconcat <$> forM xs f
11:17:43 <lambdabot> (Monoid b, Monad f) => (a -> f b) -> [a] -> f b
11:17:50 <dmj`> is this defined somewhere
11:18:56 <nitrix> Looks very close to mapM
11:19:15 <glguy> dmj`: Not anywhere common
11:19:20 <dmj`> nitrix: will, it could be mconcat <$> (flip mapM) xs f
11:19:25 <dmj`> s/will/well
11:19:45 <dmj`> glguy: ah, hm
11:20:44 <nitrix> Oh I only noticed the type signature, not the lambda above.
11:21:50 <dmj`> foldM would probably be better for this
11:25:31 <kuribas> > :t \f -> foldr (mappend . f)
11:25:33 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:25:37 <kuribas> :t \f -> foldr (mappend . f)
11:25:39 <lambdabot> (Monoid b, Foldable t) => (a -> b) -> b -> t a -> b
11:25:54 <lpaste> glguy pasted “for dmj`” at http://lpaste.net/351081
11:26:04 <johnw> :t foldMap
11:26:05 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:26:13 <glguy> dmj`: If ConstT existed somewhere, your function would be alaf ConstT traverse, at least :)
11:26:33 <johnw> :t \f x xs -> x <> foldMap f xs
11:26:35 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> m -> t a -> m
11:26:42 <dmj`> glguy: oh man :) 
11:30:51 <dmj`> johnw: ah, nice.
11:30:59 <mjtmullen> @pl  \f -> foldr (mappend . f)
11:31:00 <lambdabot> foldr . (mappend .)
11:31:03 <SLi> I'm trying to figure out if there's something replacing iterate in classy-prelude. Maybe some monadic function?
11:31:45 <dmj`> johnw: am reading multiple files from disk, they’re monoids so would like to combine them as they’re read
11:31:48 <dmj`> :t \xs -> foldM (\o path -> mappend o . read <$> readFile path) mempty xs
11:31:50 <lambdabot> (Monoid b, Foldable t, Read b) => t FilePath -> IO b
11:34:57 <dmj`> :t readMaybe
11:34:59 <lambdabot> error: Variable not in scope: readMaybe
11:35:05 <johnw> :t fmap fold . mapM (fmap read . readFile)
11:35:07 <lambdabot> (Monoid b, Traversable t, Read b) => t FilePath -> IO b
11:35:08 <johnw> you just need foldMapM
11:35:25 <johnw> strangely, not in Foldable
11:35:50 <dmj`> johnw: ah! hmmm, sounds like a proposal to me.
11:35:56 <nitrix> I like the sound of it
11:35:58 <johnw> i leave it in your good hands :)
11:36:06 <dmj`> johnw: hah! :)
11:36:38 <dmj`> if we added readMaybe... (Monoid b, Traversable t, Read b) => t FilePath -> IO (Maybe b)
11:37:04 <johnw> I would think that readMaybe is: Read a => String -> Maybe a
11:37:09 <kuribas> :t \f -> foldl (liftA2 mappend . f) (pure mempty)
11:37:10 <lambdabot> (Monoid c, Foldable t, Applicative f) => (f c -> f c) -> t (f c) -> f c
11:39:08 <dmj`> https://www.irccloud.com/pastebin/yjCRP5JZ/
11:40:21 <kuribas> :t \f -> foldl (flip (liftA2 mappend . f)) (pure mempty)
11:40:24 <lambdabot> (Monoid c, Foldable t, Applicative f) => (a -> f c) -> t a -> f c
11:41:31 <johnw> dmj`: that link doesn't work for those who disable Javascript on the Web :)
11:42:03 <frontendloader> if you disable javascript on the web in 2017, you are a special type of luddite
11:42:26 <johnw> I only allow 1st party images and css
11:42:38 <johnw> surprisingly, 95% of the Web that I use still works just fine
11:42:42 <Hafydd> Someone with "frontend" in their nick probably would think that.
11:42:47 <Franciman> Hello
11:43:03 <Franciman> can I use catamorphisms to write binary search on a binary tree?
11:45:16 <Younder> catamorphism?
11:45:19 <dmwit> Seems like you ought to be able to. Did you try, and run into trouble?
11:45:41 <johnw> :t \f xs -> foldM (\acc -> fmap (mappend acc) . f) mempty xs
11:45:43 <lambdabot> (Monoid b, Foldable t, Monad m) => (a -> m b) -> t a -> m b
11:45:52 <dmwit> Or is this, like, a question about your abilities as a programmer? =P
11:46:10 <dmj`> johnw: https://gist.github.com/dmjio/435c4be859be9e4184705f69a6a8c7cb
11:46:26 <johnw> dmj`: too cute
11:46:33 <kuribas> dmj`: doesn't IO have a monoid instance?
11:46:37 <dmj`> :]
11:46:44 <Younder> Ive heard many bizarre terms in category theory, buy not catamorpishm.
11:47:07 <johnw> kuribas: oh, it does!
11:47:08 <kuribas> :t foldMap :: (Monoid b) => (a -> IO b) -> [a] -> IO b
11:47:10 <lambdabot> Monoid b => (a -> IO b) -> [a] -> IO b
11:47:15 <johnw> perfect, thanks
11:47:24 <johnw> that's probably why there's no foldMapM
11:47:28 <frontendloader> oddly my name doesn't have anything to do with what I do, I work on mobile junk :/
11:47:58 <dmwit> johnw: You might like `Alt`.
11:48:00 <Younder> Franciman, Perhaps you will enighten me?
11:48:46 <dmwit> :t \f -> foldMap (Alt . MaybeT . f)
11:48:48 <lambdabot> error:
11:48:49 <lambdabot>     • Data constructor not in scope: MaybeT :: b -> f a
11:48:49 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
11:49:08 <johnw> ooh, neat
11:49:27 <johnw> hadn't heard of that one before
11:50:20 <dmwit> Younder: e.g. `foldr` is the catamorphism for lists
11:50:34 <kuribas> johnw: sadly not for StateT and friends
11:50:43 <dmwit> Younder: Generally it is the function that pattern matches, and replaces recursive part of the data type with the results of recursive calls to the catamorphism.
11:50:54 <johnw> (StateT, friends)
11:50:56 <Franciman> Younder, sorry, here I am, yes it's like a fold
11:51:22 <Younder> Ok a fold
11:52:40 <Younder> Or i C terms a loop
11:52:46 <Younder> in
11:53:11 <dmwit> Younder: I don't think it's quite like a C loop.
11:53:45 <Franciman> Younder, it's a particular type of loop, though
11:53:49 <dmwit> Younder: e.g. for `data BinTree a = Leaf | Branch (BinTree a) a (BinTree a)` the catamorphism is `binTree :: z -> (z -> a -> z -> z) -> BinTree a -> z`, which is not very loop-like.
11:54:13 <Younder> I see
11:54:52 <Younder> What we would call an invairiant in Isabelle
11:56:16 <dmwit> Odd, there's an `instance MonadPlus IO` listed on Hackage, but ghci complains that it can't deduce `MonadPlus IO`.
11:56:57 <dmwit> Oh, that instance was added in base-4.9?? I thought that was around since forever...
11:57:23 <dolio> It was an orphan instance for a long time.
11:57:31 <dmwit> Ah! Where did it live?
11:57:57 <dolio> I forget. Control.Monad.Error or something, maybe.
11:58:14 <dmwit> nice
11:59:01 <dmwit> :t msum . fmap (readFile >=> readIO) -- johnw
11:59:03 <lambdabot> (Foldable t, Read a, Functor t) => t FilePath -> IO a
11:59:59 <dmwit> Oh, that doesn't combine the successful ones. I didn't understand the goal. Apologies.
12:00:27 * Younder is cofused again
12:00:29 <dolio> Yeah, that gives the first successful one.
12:00:35 <kuribas> :t foldMap (readFile >=> readIO)
12:00:38 <lambdabot> (Monoid c, Foldable t, Read c) => t FilePath -> IO c
12:01:08 <dmwit> kuribas: I think that will die if any read dies, which also isn't quite what we're shooting for, I think.
12:01:19 <kuribas> right
12:02:13 <Younder> Why does  Haskell seem like a contentious headache that only increases the more you understand?
12:02:35 <Zemyla> Younder: The head pain is your brain expanding.
12:02:52 <zomg> that sounds like a serious medical condition
12:03:24 <koala_man> lambdacephalus
12:03:32 <dmwit> There's gotta be a type somewhere with `instance (Applicative f, Monoid m) => Monoid (Foo f m)`, right?
12:03:36 <johnw> lambdamegaly
12:03:49 <Younder> I should say I am almost 50 years old. I might just be to old for this.
12:04:07 <johnw> Younder: anyone < 130 years is not too old
12:04:54 <kuribas> Younder: often a clever solution isn't necessary
12:05:24 <Younder> Ok I'll stater with that catamorphism
12:05:30 <Younder> start
12:05:48 <Younder> which is like a fold
12:06:29 <kuribas> dmwit: that would be pretty useful.
12:07:03 <dmwit> I have no idea how to search for it.
12:07:47 <Younder> I considered myself a genius in math (mostly differential geometry and number theory) before I came here. Now I feel like a idiot.
12:08:44 <fresheyeball> Younder: wonderful isn't it
12:09:00 <Younder> It is most frustrating, but I figure character building.
12:09:08 <Tuplanolla> I find it strange that you've worked in math and not gotten used to perpetual frustration and self-doubt, Younder.
12:09:37 <byorgey> dmwit: as in,  newtype Foo f m = Foo (f m),   Foo f <> Foo g = mappend <$> f <*> g  ?
12:09:39 <Younder> I guess my focus was too limited.
12:09:47 <byorgey> er, with another Foo in there
12:11:13 <kuribas> byorgey: yes
12:12:37 <teurastaja> besides the order of evaluation of free identifiers in beta-evaluation of lambda calculus, is there anything other specific to haskell in alpha/beta/eta conversions?
12:12:47 <dolio> I don't think that type exists anywhere widely used.
12:15:01 <Younder> Tuplanolla, Well I am getting used to it now aren't I. I hope I'll see the and of this. (Somehow doubt I will)
12:15:44 <Tuplanolla> Learn to embrace it, Younder. The alternative is mental stagnation.
12:16:50 <Rembane> Embrace the pain?
12:17:04 <purelazy> Younder: Feeling stupid is not the answer
12:17:36 <purelazy> Younder: Feeling up-for-it most definately is
12:18:39 <Younder> Humility never killed anyone, hubris did. Tuplanolla is right. I need to embrace my limitations and learn to work within them.
12:19:05 <purelazy> Younder: But its good to know there is someone with differential geometry experience around
12:19:37 <ertes> cool!  powermate got an update =)
12:19:47 <Younder> A bit more positivity wouldn't hurt.
12:19:48 <ertes> i can finally use that damn thing
12:20:01 <ertes> helo
12:23:26 <sm> Younder, you are a beautiful person learning a beautiful language
12:24:20 <ertes> dmwit: instead of using Foo you can likely just derive the Monoid instance for your own type…  (<*>) and 'pure' are already defined for generic products, so you don't even need the generic-deriving library for that
12:24:42 <ertes> the generic-deriving library has mappend and mempty for generic products
12:25:12 <Tuplanolla> Positivity? Everything is great (up to a quadratic error term), Younder.
12:28:19 <Younder> Tuplanolla, lol
12:28:54 <byorgey> dmwit, kuribas: I don't know of any such Foo defined anywhere.  I'd be happy to accept a patch adding it to monoid-extras.
12:30:45 <ertes> byorgey: i wouldn't add Foo, but i would add:  appAppend :: (Applicative f, Monoid a) => f a -> f a -> f a;  appEmpty :: (Applicative f, Monoid a) => f a
12:31:25 <ertes> perhaps rename appAppend to appMappend and also add an appSappend for semigroups (until we finally make Semigroup a superclass of Monoid)
12:32:17 <byorgey> ertes: why come up with new specialized names for the mappend and mempty operations for that monoid?
12:32:18 <ertes> but honestly it doesn't really pay off…  "appAppend" isn't that much shorter than "liftA2 (<>)"
12:33:12 <ertes> byorgey: i imagine that using Foo would be awkward, because of the un-/wrapping, so i would make it easier to just define a suitable Monoid instance for your type…  but it's already really easy
12:33:13 <byorgey> it might or it might not. At the very least it's a nice observation that monoids lift through Applicatives in this way.
12:33:43 <byorgey> using Foo would not be too awkward using some tools from lens, e.g. 'ala' and friends
12:34:18 <byorgey> ertes: if you're not going to make a newtype then I very much agree with you that it's pointless to define appAppend
12:34:19 <ertes> there is in fact a library (i forgot its name) that uses TH to write instances like that based on Applicative:  Fractional, Num, Monoid, …
12:34:55 <ertes> it just lifts all operations appropriately
12:37:17 <kuribas> Shouldn't there be a monoid instance for StateT, ReaderT, etc...?
12:38:14 <ertes> kuribas: and Fractional and Num…  and Codensity and Constant and Parser…
12:39:02 <kuribas> ertes: for Num there is Sum and Product
12:39:51 <kuribas> ertes: there's one for Maybe, a -> b, IO, ...
12:45:32 <Coffee8Maniac> hey guys
12:47:34 <lethargicwalrus> >
12:55:56 <pflanze> Hello. How do I tell cabal not to parallelize a build? I don't have enough memory for it.
12:57:30 <romano_> hi guys
12:57:34 <kadoban> -j1 I think? Or did I make that up?
12:57:55 <ongy> -j should tell it the number of cores to use
12:58:01 <ongy> pflanze: swap?
12:58:04 <romano_> does anyone have experience with making sessions persistent in the spock framework
12:58:24 <romano_> by default they are kept in stm, which resets on app restart
12:58:26 <koala_man> it's probably way faster to compile in serial than in parallel with swapping
12:59:16 <ongy> probably. though I went pretty well with 1GB ram and no swap (32bit linux though)
12:59:49 <pflanze>  ongy: my machine in the clound has 2 GB of RAM and another one I tried first with 1 GB has been swapping for ~3 hours now trying to compile idris. "No".
13:00:04 <pflanze> Also, cabal -j 1 didnt' work, trying -j1 now
13:00:17 <pflanze> ah that seems to work..
13:00:19 <pflanze> Thanks!
13:01:36 <ongy> 64bit kernel? I think it makes quite the difference with haskell (using register-sized values so often)
13:02:17 <pflanze> What could this be?: Warning: idris.cabal: Unknown fields: extra-doc-files (line 79)
13:02:38 <pflanze> then goes on to say:  idris-0.99 failed during the configure step. The exception was:
13:02:38 <pflanze> ExitFailure 11
13:02:52 <niklasb> romano_: maybe you want to use the database instead of the built-in sessions
13:04:02 <ongy> pflanze: maybe old cabal version
13:04:26 <niklasb> romano_: you can use getSessionId at least
13:04:34 <romano_> niklasb, i do indeed. 
13:04:59 <romano_> niklasb, in fact i'm using the funblog example, which uses persistent for mysql storage
13:05:26 <romano_> niklasb, and the sessions seem to be written there but still when i restart the app i get logged out
13:07:42 <niklasb> romano_: yeah the way I read that code is that it takes the userID out of the current session and uses that to look up stuff from the DB
13:07:54 <niklasb> but the association between session ID and user ID is lost if you restart the server
13:08:13 <niklasb> so probably you want to make it store the session ID in the database too 
13:08:30 <romano_> niklasb, :/
13:09:09 <niklasb> romano_: actually, no
13:09:23 <niklasb> it uses (Key Session) as the session ID
13:09:38 <niklasb> so that should be ok
13:11:27 <niklasb> oh romano_ so type SessionVal = Maybe SessionId, and that is a valid pointer into the DB, but it's not what's in the cookie. the latter is a unique token generated at runtime and only stored in STM I suspect. But you can get the token from spock via getSessionId and store it too I guess
13:12:43 <kyousanshugi> what's the point of the underscore versions of functions like `sequence` or `replicateM` (sequence_, replicateM_)? if one wants to discard the result, why not just use (>>) or just not bind it to a variable with (<-) in a `do` block? i don't see why there has to be special versions of the functions
13:14:34 <romano_> niklasb, cheers. i will give this a go
13:15:41 <geekosaur> kyousanshugi, generally the implementation is optimized so the result isn't even collected (it can be hard to optimize it away "after the fact")
13:16:42 <pflanze> Ok, so I ran "cabal install Cabal", then "apt-get remove cabal-install" but now I realize that there's no cabal binary anywhere. Huh?
13:16:57 <geekosaur> Cabal is a library
13:17:02 <geekosaur> cabal-install is the program
13:17:02 <kyousanshugi> geekosaur: okay, thanks
13:17:12 <pflanze> Hmm k
13:18:08 <byorgey> pflanze: i.e. you want 'cabal install cabal-install'
13:18:32 <byorgey> the naming is a bit silly but it's like that for historical reasons and probably too big of a hassle to change it now.
13:28:19 <nitrix> That moment when someone adds a space to your spam filter system and all your users gets banned on your website.
13:28:42 <nitrix> We caught it only because the process is slow slow and only processed 400k users.
13:29:36 <nitrix> I'm afraid me pushing for Haskell to improve the performance of our spam filtering wont work anymore :(
13:30:44 <nitrix> Imagine the carnage if it was written in Haskell ;-;
13:31:07 <ongy> someone puts in a space, the compiler complains. Whoo!!
13:31:26 <ongy> also sounds like our favorite bumblebee bug
13:31:37 <davean> Haha, slowness as a feature
13:32:05 <pflanze> Is it possible to install a newer cabal using ghc from Debian?
13:32:16 <davean> You know you can test the actions it would take...
13:32:35 <pflanze> I've installed cabal-install from Debian's cabal, removed the latter, run the newly installed one but it is giving me errors
13:32:40 <davean> pflanze: trivial, cabal install Cabal cabal-install
13:32:46 <pflanze> That's what I did
13:32:53 <davean> Which errors?
13:33:05 <pflanze> cabal install -j1 idris --program-prefix=/usr/local/bin/
13:33:32 <pflanze> /tmp/cabal-tmp-26875/idris-0.99/dist/setup/setup.hs:296:26:
13:33:32 <pflanze>     Couldn't match type `PackageDescription' with `[String]'
13:34:20 <davean> Hum, sounds almost like Idris is hard coded against an older Cabal or something
13:34:20 <pflanze> The odd part is that another VM with the same Debian version, but 64 bit, now actually finished installing idris using Debian's cabal, after ~4 hours of swapping.
13:34:32 <davean> Can you install other packages?
13:35:03 <davean> Say ... containers?
13:35:08 <davean> Or happy
13:35:58 <davean> Idris has a custom build type
13:36:22 <davean> Which is a terrible wart and I bet the source of that problem
13:36:34 <ongy> does cabal try to reuse old tmp files? Can you purge them in /tmp/
13:40:38 <pflanze> cabal install -j1 happy  #worked fine, yes
13:47:30 <davean> Then I'm pretty damn sure you have to look at the custom Idris file :/
13:47:44 <davean> Maybe they have it updated in got
13:56:30 <ertes> nitrix: you can argue that it's always possible to add artificial delays =)
13:57:08 <davean> ertes: haha
14:04:42 <nitrix> ertes: I didn't think of that! So I'll propose we rewrite it in Haskell for the added safety / ease of maintenance, but we'll put a 3 seconds delay for "change management".
14:04:57 <nitrix> And a transition period of a year.
14:10:28 <dmwit> byorgey: Thanks for the encouragement. I wonder whether monoid-extras is the right place for it. I guess you might reasonably also want a Num instance, maybe Fractional/Floating; possibly others?
14:12:31 <dmwit> byorgey: If those instances don't turn you off, I'll put together a patch.
14:16:17 <kuribas> what's the minimum mac hardware recommended for ghc?
14:17:11 <ertes> nitrix: alternatively you could just make it easy enough to go back to an earlier state
14:17:30 <ertes> nitrix: if the filter is fast, you notice false positives more quickly, so you can respond more quickly
14:17:44 <purelazy> kuribas: I would guess any not-too-old mac would do
14:17:49 <ertes> nitrix: of course a better idea is to detect outliers properly =)
14:18:09 <ertes> "this seems like an outlier…  i'll store this for human review first"
14:18:14 <kuribas> purelazy: a second-hand running 10.11?
14:18:48 <purelazy> I would've thought memory would be the limiting factor
14:19:24 <purelazy> I have no idea, I'm not a mac user
14:20:01 <kuribas> strange how my perfectly fine mac mini is already obsolete.
14:20:29 <purelazy> https://wiki.haskell.org/Mac_OS_X
14:20:44 <purelazy> https://ghcformacosx.github.io/
14:20:56 <purelazy> here are a couple of sites I just Googled
14:21:29 <purelazy> Obsolete for you perhaps - but there must be a good home for it
14:22:41 <kuribas> well, obsolete for ghc, obsolete for most of the apps on the apps store.
14:23:37 <purelazy> its called a mini for a reason I guess
14:24:29 <kuribas> purelazy: it runs only on 32bit, because it is blacklisted in the bios, not because it cannot run 64 bit.
14:24:42 <kuribas> sorry for the ranting...
14:24:55 <davean> kuribas: its old enough to have a BIOS? Damn, that is obsolete
14:25:05 <davean> I didn't realize they made mac minis that long ago
14:25:08 <kuribas> davean: or efi, what's it called.
14:25:18 <davean> oh, huge difference
14:27:08 <Koterpillar> AFAIK Apple's Intel PCs always implemented [their understanding of] UEFI
14:27:32 <davean> Koterpillar: thats whta I thought
14:27:36 <kuribas> davean: it's a mac mini 1,1 upgraded to 2,1
14:28:39 <kuribas> The graphical card isn't supported on the new OSes.  (latest is 10.7)
14:29:25 <ongy> didn't apple have 32bit mode efi for a while aswell?
14:29:36 <ongy> I guess it's a bit off topic in here though
14:30:09 <davean> kuribas: oh my, did you upgrade the RAM? Thats rather ... well, I regularly allocate datastructures larger then that
14:30:23 <kuribas> davean: yes 2 GB.
14:30:26 <davean> I remember those days, they were hard to program for
14:30:32 <davean> So much work to deal with the lack of RAM
14:30:44 <kuribas> ongy: ghc refuses to work on it.
14:30:55 <kuribas> ongy: actually cabal/stack.  ghc does work.
14:31:03 <davean> kuribas: what fails?
14:31:25 <kuribas> davean: I get segmentation fault (cabal), and illegal instruction (stack).
14:31:50 <ongy> illegal instruction is funny
14:31:54 <davean> No its not
14:31:59 <davean> thats MANY instruction sets ago
14:32:12 <davean> And a LOT of very important instructions came out around that time
14:32:18 <davean> thats an extreamly dated processor
14:32:25 <davean> to compiler for such an old instruction set would be cripling
14:32:31 <kuribas> davean: it's a core 2 duo
14:32:36 <davean> kuribas: exactly
14:32:46 <kuribas> davean: so what would you recommend?
14:32:55 <kuribas> davean: minimum?
14:32:59 <davean> kuribas: I mean, I'd run a debugger on cabal
14:33:25 <davean> kuribas: you should be able to compile stuff to run on it
14:33:25 <kuribas> davean: I'd rather it works out of the box...
14:33:39 <ongy> davean: compiling for anything but host architecture (unless instructed to) isn't good compiler design either
14:33:58 <kuribas> davean: but then it will generate wrong instructions?
14:34:33 <ongy> I think I ran into illegal-instruction on a mac-mini aswell, something something assembler bug
14:34:35 <kuribas> davean: does ghc change code based on the host?
14:34:47 <davean> kuribas: GHC has no crosscompile ability :(
14:34:55 <davean> well, it SORTA does, but it has to run stuff on the host
14:35:01 <davean> and LLVM certainly can
14:35:12 <davean> I don't know much about the stack build process, stack solves a problem I don't have
14:35:18 <davean> so I use cabal
14:35:32 <kuribas> davean: I assume the stack binary is build with ghc.
14:35:37 <davean> specificly it solves a problem I don't have at the expense of problems I do have
14:36:08 <kuribas> still, cabal isn't very usefull since it segfaults.
14:36:22 <davean> yah, but that should be an actual bug
14:36:27 <davean> probably a library missmatch
14:36:33 <davean> would be my guess
14:36:38 <davean> which recompiling it WOULD fix
14:36:46 <davean> so you can use your working GHC to get a working cabal
14:36:49 <davean> or should be able to
14:37:02 <davean> running cabal with a debugger would tell you
14:37:06 <kuribas> davean: well, I could try a previous release.
14:37:13 <davean> kuribas: why not just compile it?
14:37:16 <davean> its trivial to compile
14:37:17 <MarcelineVQ> are there relases for 32bt mac?
14:37:45 <davean> also, stack might be 64bit only, that might be the illegal instruction
14:38:04 <davean> I certainly don't build anything with 32bit suppt any more!
14:38:06 <davean> x32 maybe
14:38:11 <davean> but certainly not 32
14:38:14 <kuribas> davean: but isn't ghc output the same regardless?
14:38:20 <davean> kuribas: of course not
14:38:28 <davean> kuribas: thats litterly impossible
14:38:42 <kuribas> Anyway, I want to produce binaries that I can distribute.
14:38:43 <davean> Thats not how CPUs work
14:39:05 <davean> kuribas: can you run "file" on the stack binary?
14:39:21 <davean> it should tell you fi it has as 32bit instruction set of a 64bit
14:39:34 <kuribas> davean: well, it was a script.
14:39:46 <kuribas> I guess it redirects to a binary though....
14:40:32 <davean> They really took "mini" to heart with these mac minis, my laptop is more powerful
14:41:13 <ongy> ... I'd have to try, but I bet you can get 64bit linux running on them
14:41:35 <davean> ongy: not if 64bit is blacklisted in the BIOS
14:41:46 <davean> er, EFI
14:41:50 <davean> he said BIOS but meant EFI
14:42:21 <lordcirth__> davean, but it would be grub doing the kernel loading, and grub is 32bit. Wouldn't that work?
14:42:27 <ongy> "blacklisted", afaik it's just that the efi only boots 32bit efi-applications, which makes things awkward for 64bit kernels, but kexec helps (I have done it, but not on mac-mini)
14:42:31 <davean> lordcirth: grub would work
14:42:36 <davean> lordcirth: linux wouldn't
14:42:39 <kuribas> ongy: I messed with it, but now I cannot start it up...
14:42:48 <davean> lordcirth: if 64bit is black listed the CPU litterly stops having 64bit instructions
14:42:56 <kuribas> ongy: I'll need some boot disk/usb, or even disassemble it (again).
14:43:00 <lordcirth> davean, really? Why would anyone do that, btw?
14:43:08 <ongy> becaus hardware vendors
14:43:14 <davean> lordcirth: they did it to virtualization instructions on many laptops
14:43:15 <ongy> there's quite a few things that are "why would you even?"
14:43:17 <davean> because fuck users
14:43:25 <davean> buy our more expensive models
14:43:27 <tdammers> it's called "price shaping"
14:43:30 <davean> which we didn't actually end up making
14:44:32 <kuribas> davean: I could try putting lion on it, but I am not even sure it will run in 64 bit...
14:44:51 <davean> kuribas: Anyway, you can't expect modern software to be 32bit, if you want 32bit you need to get a 32bit build or build it. 32bit is *slow* for a lot of things, and I'd expect you to have old libraries, so even modern software might not be ABI compatable, so build locally and you should be fine
14:45:06 <davean> kuribas: and cabal is trivial to do a source install of if you have GHC
14:45:20 <davean> its like 2 commands
14:45:29 <kuribas> davean: yeah, the whole idea is to produce binaries that I can distribute.
14:45:50 <davean> kuribas: Oh, well, you *can* distribute 32bit binaries but I doubt anyone would want them
14:46:00 <davean> you can't build 64bit ones from that though
14:46:06 <davean> GHC needs access to the runtime env to build for it
14:46:10 <davean> due to TH
14:46:17 <davean> you can SORTA cross compile with it
14:46:25 <davean> but you might as well cross compile from any OS then?
14:47:04 <kuribas> yeah, and testing them would be nice as well.
14:47:14 <ongy> at least on linux, 64bit binary on 32bit system isn't illegal instruction, it's " cannot execute binary file: Exec format error"
14:47:30 <lordcirth> because of ELF metadata, I guess
14:47:42 <davean> ongy: Yah, I don't know OS X though
14:48:04 <davean> ongy: its a thing that COULD be wrong
14:48:18 <davean> he's really have to break out a debugger but that won't solve his actual problem
14:48:25 <ongy> I remember it being "command not found" on some system, because the interpreter was on a different path
14:48:34 <davean> because the system can't solve the problem
14:49:11 <davean> kuribas: you could run a 64bit VM
14:49:27 <kuribas> davean: on the mini?  Or on my PC?
14:49:31 <davean> anything
14:49:33 <ongy> without hardware virtualization support? have fun
14:49:41 <davean> ongy: It works fine?
14:49:47 <kuribas> davean: I heard that's illegal.
14:50:03 <davean> maybe it is, crazy things are illegal
14:50:07 <ongy> davean: it works, fine is a different thing
14:50:22 <ongy> It's against ToS of OSX afaik
14:51:06 <davean> kuribas: could you rent an OS X instance when you need it?
14:51:17 <kuribas> davean: yes.
14:51:37 <davean> that might make the most sense?
14:51:44 <kuribas> develop it on 32bit, then test it on 64 bit...
14:51:54 <davean> yah
14:51:56 <Welkin> mini?
14:52:01 <Welkin> oh
14:52:02 <Welkin> mac mini
14:52:09 <Welkin> use a hackintosh
14:52:23 <Welkin> or, yeah, buy a mini, or a used macbook (air)
14:52:53 <kuribas> davean: how is latency though?  Isn't it hard to find performance problems?
14:53:15 <davean> kuribas: UI latency or other latency? theres a lot of types of latency
14:53:19 <davean> I don't know what you're making
14:53:20 <kuribas> UI latency
14:53:25 <davean> graphical?
14:53:32 <kuribas> yes, for fonts.
14:53:46 <davean> Well, people can stream first person shooters, but they use special tech to do it
14:54:02 <davean> it depends on which graphical streamign tech is used
14:54:06 <kuribas> though if it runs fine on the mini, it probably is fine on newer models.
14:54:14 <kuribas> davean: right
14:54:22 <davean> kuribas: which I guess would depend n the provider?
14:54:36 <davean> kuribas: its definately reasonable to have acceptable streaming performance but you'd have to look into the practice
14:54:59 <davean> and yes, if it works fine on the mini ...
14:55:03 <davean> you've got a LOT of headroom
14:55:34 <Welkin> MAX HEADROOM?
14:55:43 <davean> No, not the max headroom you could have
14:55:51 <davean> though actually
14:56:01 <davean> that mini MAY be close to the slowest intel system Apple ever released
14:56:04 <davean> so ...
14:56:16 <Welkin> I jave no problem with my 2014 macbook air
14:56:16 <davean> Hum, you might be able to get MAX HEADROOM
14:56:17 <Welkin> o.o
14:56:19 <kuribas> davean: it's good to test on a low end system anyway.
14:56:24 <Welkin> it's the fastest computer I've owned
14:56:28 <davean> kuribas: Yes, this is true
14:56:37 <davean> Welkin: that would blow away the system we're talking about here
14:56:46 <davean> Welkin: by like a factor of 4
14:57:00 <kuribas> davean: I am not going the play the witcher on it :)
14:57:16 <Welkin> the witcher is not supported on intel gpus
14:57:50 <davean> Welkin: well played
14:58:02 <systemfault> Anyone using intero-mode for emacs? If so, let's say I want to get rid of the repl from inside emacs, do I simply kill the buffer containing it or there's a "cleaner" way?
14:58:19 <kuribas> Welkin: doesn't the witcher 2 run on mac?
14:58:31 <Welkin> yes
14:58:35 <Welkin> witcher 1 and 2 do
14:58:39 <Welkin> but not on intel hardware
14:58:47 <Welkin> you need nvidia/amd gpus
14:58:50 <kuribas> right, they are gpu heavy.
14:59:08 <davean> Welkin: sorry, I checked, its more like a factor of 6-8 that your system is faster
14:59:16 <davean> Welkin: more on many workloads
14:59:34 <davean> Welkin: A workload like crypto yours might be more then a factor of 100 faster
14:59:44 <Welkin> for most software development (at least what I do) you don't need a powerful machine
15:00:12 <davean> Welkin: no, but I just thought your "my machine is slow" was amusing in cntext :-p
15:00:17 <kuribas> Welkin: I remember coding on a 486, compiling was slow :)
15:00:33 <kuribas> Welkin: I think that was on 4mb ram.
15:01:53 <davean> kuribas: ironically those were sometimes fast to compile because they optimized compiling to just happen
15:03:08 <davean> kuribas: no one runs a superoptimizer on a 486 ;)
15:03:35 <Welkin> does ghc run on cell?
15:03:54 <kuribas> I think performance is mostly for image editing/video editing/games
15:03:54 <davean> Welkin: it  runs on POWER
15:04:16 <davean> kuribas: I certainly could use more performance for testing and verification ...
15:04:28 <kuribas> right
15:04:45 <davean> Mostly I don't do things because of limited performance
15:04:49 <Welkin> why POWER? and not Power?
15:05:11 <Welkin> is that an 80's phenomenon?
15:05:13 <kuribas> davean: you need a lot of testing, even in haskell?
15:05:20 <Welkin> where you capitalize the whole word for no reason?
15:05:26 <davean> Welkin: Because its an aconym
15:05:34 <davean> POWER stands for something
15:05:49 <davean> Power Optimization With Enhanced RISK
15:05:51 <davean> *RISC
15:06:15 <davean> Thats not no reason, thats litterly a standard thing to do in english?
15:07:19 <davean> anyway, GHC might run on the POWER component of Cell, but not the SPEs
15:08:05 <davean> You'd have to use them via something like accelerate
15:09:03 <davean> Welkin: I mean, its very 80s for what *those* words describe why you should give a damn about POWER
15:09:11 <davean> and the RISC vs. CISC wars
15:09:13 <davean> and what POWER solved
15:09:24 <davean> if thats what you mean
15:09:27 <kuribas> from what I looked at gpu programming with haskell, it seems that most performance gain is from not using haskell.
15:09:49 <davean> kuribas: hahaha, thats an amusing thing to say?
15:10:19 <fosskers> If I had a million files that I wanted to perform async IO actions on, would: `getFilesNames >>= mapConcurrently_ work` be a terrible idea?
15:11:12 <davean> fosskers: have you looked at 'async'?
15:11:14 <kuribas> davean: the state of the art may have advanced though.  But when I checked, it had a rather large overhead.  And the reason for programming the GPU is to get raw speed.
15:11:17 <Axman6> fosskers: you might need to up the open file limit, or alternatively you probably eant to limit the number of concurrent (haskell) threads
15:11:30 <fosskers> davean, yeah, aync's `mapConcurrently_` function
15:11:43 <davean> kuribas: GPUs *inerhantly* have high overhead
15:11:46 <davean> kuribas: thats part of the design
15:11:57 <fosskers> Axman6, how does one limit the thread count? I'd like to do web calls for each file
15:12:06 <kuribas> davean: yeah, I mean the extra overhead that haskell brings.
15:12:21 <fosskers> Hoping that GHC doesn't spawn a million green threads, all trying to make HTTP requests at once
15:12:40 <Axman6> fosskers: an easy way would be to use a semaphore (or emulate one with an MVar or something)
15:12:46 <fosskers> luckily I don't open files, I actually just want to perform an IO action based on the filename
15:12:50 <Axman6> that's essentially what GHC will do
15:13:08 <joehillen> fosskers: I've done something similar and ended up having to turn mapConcurrently into a batched version
15:14:07 <joehillen> oh, if you're not opening files or ports, then you should be fine
15:14:17 <Axman6> actually, if you're using http-client, its Manager type inherently limits the number of concurrent connections to the same server
15:14:24 <davean> fosskers: you might be interested in something like 
15:14:33 <fosskers> The real truth: I want to perform a `Shelly` IO action for each file
15:14:33 <davean> parallel-io
15:14:36 <davean> which has a threadpool
15:14:41 <Axman6> (default is 10 concurrent connections IIRC)
15:14:45 <davean> or any other pool library
15:14:47 <fosskers> the action is a call to an external program which does http calls
15:15:05 <fosskers> I'll checkout parallel io
15:15:20 <davean> I haven't used parallel-io in years
15:15:30 <fosskers> last updated Feb of 2015
15:15:57 <joehillen> fosskers: "If it compiles, it works" ;)
15:16:19 <fosskers> joehillen, amen ;)
15:16:35 <davean> I swear I saw just the right thing for this like a month ago too ...
15:16:42 <joehillen> I've use a library that wasn't updated since 2007. I wish I remembered which
15:17:07 <davean> joehillen: I mean, I've used base, I swear they hadn't updated it since the 90s
15:17:08 <Axman6> you might find this useful: http://stackoverflow.com/questions/18896103/can-haskells-control-concurrent-async-mapconcurrently-have-a-limit
15:17:46 <Axman6> davean: we'll take back Applicative, Traversable and Monoid then if you're not happy :P
15:18:06 <davean> Axman6: I mean, I guess giving a starving child a peanut is better then not?
15:18:26 <davean> Axman6: It was a nice start
15:18:35 <fosskers> damn parallel-io isn't written in terms of `MonadIO`
15:18:49 <davean> of course not
15:18:53 <davean> It basicly can't be?
15:19:01 <davean> well, to be clear
15:19:03 <davean> it can't be
15:19:18 <davean> it can be writen in terms of MonadIO and some other constraints that are risky
15:19:25 <Axman6> there's the lifted-async package for (some of) that
15:20:24 <davean> Yu'd need sometihng like monad-control also
15:20:37 <davean> MonadIO is far too weak
15:20:40 <davean> (as should be obvious!)
15:20:52 <fosskers> hm
15:21:29 <davean> and the behavior of things like monad-control can be quite supprising
15:21:38 <Axman6> the interraction of threading and monad transformers can get tricky - what's supposed to happen if you for StateT s IO?
15:21:47 <Axman6> fork*
15:22:17 <davean> Axman6: well, I expect the compiler to pick the result that makes me happy from all possible results
15:22:33 <Axman6> the compiler has nothing to do with it
15:22:35 <davean> Its the only heuristic that will work really
15:23:41 <davean> I mean, it does, its the compiler that will get it and have to sort out whats supposed to happen from the undefined thing and do something other then give a type error
15:24:20 <davean> who else would handle it not having a definition?
15:24:21 <fosskers> alright, follow up. Given `getFileNames :: IO [FilePath]`, is `getFileNames >>= foo` always a bad idea if I know there are a million files?
15:24:37 <davean> not always
15:24:49 <fosskers> re: lazy IO vs streaming, here.
15:24:57 <davean> or even not lazy
15:25:09 <davean> if you're not kuribas a million isn't a large number really
15:25:21 <davean> Its not even unreasonable to spawn a million Haskell threads
15:25:29 <fosskers> ^ that much I knew, yeah.
15:25:38 <davean> Haskell usally handles that just fine
15:25:52 <fosskers> okay, so then it's just a matter of limiting the amount of threading during the uploads
15:26:10 <davean> Yes, or limiting your resource usage if you decide you care about other resources
15:26:18 <kuribas> davean: on my mac mini?
15:26:27 <davean> kuribas: yes :)
15:26:36 <davean> kuribas: you'd probably not appreciate him writing a program like that
15:26:50 <kuribas> davean: you guessed my thoughts :)
15:27:02 <kuribas> davean: but I don't care if it's one off...
15:27:25 <fosskers> production code :D
15:27:39 <fosskers> (potentially)
15:27:59 <davean> fosskers: personally i'd use a streaming system or a queue just because
15:28:10 <davean> with the queue you can give nice output about progress
15:28:42 <fosskers> I could use `streaming` to stream in N filenames at a time, then just `mapConcurrently_` over those
15:28:47 <fosskers> kinda naive though
15:30:46 <davean> fosskers: or you could just use a STM queue structure and a worker pool and a progressbar
15:30:51 <davean> or .. so many options
15:31:07 <fosskers> haha yes I'm sure
15:31:16 <fosskers> for now I'd like something that works
15:31:36 <davean> I mean, thats REALLY simple
15:31:45 <davean> Thats actually a VERY simple way to do it
15:31:51 <davean> Put the list in an MVar
15:32:03 <davean> spawn threads that try to get the head of the list
15:32:07 <davean> if the list is empty, they terminate
15:32:09 <davean> done
15:33:14 <joehillen> fosskers: I think if you don't want to deal with the uncertainty then conduit would definitely do the right thing no matter what
15:33:47 <fosskers> attempting `parallel-io` to start
15:34:15 <fosskers> the api and use case are clear enough
15:38:06 <guyFromWeb> hey, so we use Chromebooks at school, and we like to play a game called Happy Wheels :) But since the Chromebooks have blocked websites, we have found one (URL: http://198.61.245.54/) that worked, but is now also on block list. How can someone make a site like this? I'm not sure how it's done
15:38:32 <monochrom> Is that a Haskell question?
15:39:18 <monochrom> If no answer, I will assume it's a sneaking way to trick us to visit a malicious website.
15:39:24 <guyFromWeb> no, i just can't find channel this would fit in
15:39:39 <guyFromWeb> it's a reference to totaljerkface.com
15:39:46 --- mode: ChanServ set +o monochrom
15:39:49 <guyFromWeb> not sure how it works, but it works as 'unblocked' website
15:39:51 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.98.225.64.228
15:39:51 --- kick: guyFromWeb was kicked by monochrom (guyFromWeb)
15:40:14 --- mode: monochrom set -o monochrom
16:17:37 <dmj`> banhammer !
16:26:51 <pharaun> oO
16:29:21 <MarcelineVQ> I prefer jerk city over jerk face
16:58:35 <ertes> any opinions on whether smallcheck is still useful considering quickcheck's shrinking support?
16:59:11 <ertes> i'm considering switching to quickcheck
17:00:45 <Welkin> shrinking support?
17:01:29 <ertes> :t shrink
17:01:31 <lambdabot> Arbitrary a => a -> [a]
17:01:40 <ertes> > shrink "abc"
17:01:42 <lambdabot>  ["","bc","ac","ab","aac","aba","abb"]
17:04:19 <jle`> Welkin: "support for shrink"
17:08:50 <lordcirth> What precisely is "shrink" named for?  Seems like a combinatorics function?
17:09:29 <jle`> lordcirth: if "abc" fails a test, it also tests "simpler" inputs than "abc"
17:09:57 <jle`> 'shrink "abc"' is a list of inputs that are strictly 'simpler' in some way than "abc"
17:10:02 <jle`> it...shrinks the complexity, i guess?
17:10:08 <lordcirth> Seems hard to generalize
17:10:27 <lordcirth> Could be handy, though.  Essentially narrowing down the bug?
17:10:54 <lordcirth> Automatically produce a simplest failing case.  Pretty cool idea.
17:10:56 <jle`> yeah, that's sort of the idea of it.  quickchick might find an error with "abc" as the input, and so it also checks all simpler inputs and outputs the "simplest" input that gives the error
17:10:58 <jle`> mhm
17:11:13 <jle`> i am not sure if it's a super formal concept, but ... it actually might be
17:11:16 <jle`> considering ... haskell
17:12:09 <lordcirth> Apparently every function I've ever written is a inefficient specific case of some perfect generalized function that's already in the standard libs, in my experience :P
17:12:42 <jle`> i get the feeling ><
17:13:02 <ertes> hmm…  i guess i misunderstood what shrinking is for
17:13:23 <divVerent> What does "full precision" mean for toRational?
17:13:36 <divVerent> Does it mean that (a==b) == (toRational(a)=
17:13:41 <divVerent> Does it mean that (a==b) == (toRational(a)==toRational(b))?
17:14:04 <divVerent> It's not true for NaN though :)
17:14:21 <ertes> divVerent: yeah…  it's injective except for float peculiarities
17:14:31 <divVerent> > toRational (1/0)
17:14:32 <ertes> > toRational (1/0)
17:14:34 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:14:34 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:14:35 <ertes> hehe
17:14:39 <divVerent> > toRational (0/0)
17:14:41 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
17:14:48 <ertes> hmm
17:14:49 <divVerent> I'd really have expected those to error/undefined :)
17:14:53 <ertes> technically that makes it work =)
17:15:02 <divVerent> especially the value for NaN is odd
17:15:07 <ertes> > toRational (0/0) == toRational (0/0)
17:15:09 <lambdabot>  True
17:15:15 <divVerent> the value for Infinity kinda makes sense (and I suppose converting back to float yields Infinity again)
17:15:42 <ertes> > fromRational (toRational (1/0)) :: Double
17:15:43 <jle`> > fromRational (toRational (1/0))
17:15:45 <lambdabot>  Infinity
17:15:45 <divVerent> > (fromRational.toRational)(0/0)
17:15:46 <lambdabot>  Infinity
17:15:47 <lambdabot>  -Infinity
17:15:52 <jle`> haha
17:16:02 <divVerent> so this turns NaN into -Inf
17:16:12 <divVerent> is this specified or GHC-specific?
17:16:17 <ertes> #hive-mind
17:16:21 <divVerent> or even just GHC-x86-specific
17:16:40 <divVerent> hm... technically I have GHC on ARM here somewhere but no ghci (why not... is there an alternate REPL maybe?)
17:17:24 <ertes> if you want to preserve infinities and NaN the safest way is to create a wrapper type for Rational
17:17:38 <ertes> Rational is, if you don't count bottom, just ℚ
17:17:39 <divVerent> Identical behavior on armv8l
17:18:10 <divVerent> well... I mainly wonder why this isn't spec'd
17:18:19 <divVerent> my expected result was error "NaN" or something like that
17:18:32 <divVerent> just like 
17:18:33 <divVerent> ==
17:18:47 <divVerent> == for float is broken and technically Float/Double shouldn't implement Eq
17:18:54 <ertes> with hugs (toRational (1/0)) is an arithmetic overflow, i.e. bottom
17:18:58 <divVerent> and like abs is broken for Int
17:19:27 <ertes> (toRational (0/0)) is an arithmetic overflow, too
17:19:38 <divVerent> (abs (-2147483648) :: Int) < 0
17:19:41 <divVerent> is what I mean by broken
17:20:17 <ertes> i think Eq for Float/Double is fine…  you just have to understand floating point arithmetic
17:20:28 <divVerent> Rust solved the NaN problem by a separate PartialEq typeclass - maybe Haskell should at some point do that too?
17:20:36 <ertes> > sum (replicate 8 0.125) == 1
17:20:39 <lambdabot>  True
17:20:43 <divVerent> ertes: it's not _me_ who has to understand it - this can break generic code :)
17:20:49 <divVerent> think of stuff like Map Double Int
17:20:58 <ertes> Map Double Int doesn't break
17:21:01 <divVerent> depending on implementation, this may e.g. allow inserting NaN many times
17:21:04 <divVerent> but never looking it up
17:21:08 <divVerent> a memory leak basically
17:21:10 <ertes> oh
17:21:16 <ertes> > (0/0) == (0/0)
17:21:18 <lambdabot>  False
17:21:24 <ertes> > compare (0/0) (0/0)
17:21:27 <lambdabot>  GT
17:21:32 <ertes> i see what you mean
17:22:00 <divVerent> Data.Map has the multiple-times issue BTW :)
17:22:03 <ertes> yeah, equality should really be reflexive by law
17:22:18 <divVerent> does hugs have a bottom here too BTW?
17:22:31 <divVerent> would kinda make sense, would be a different kind of breakage of course but a more obvious one at least
17:22:36 <ertes> > M.fromList [(0/0, "a"), (0/0, "b")]
17:22:39 <lambdabot>  fromList [(NaN,"a"),(NaN,"b")]
17:23:04 <ertes> not good
17:23:25 <divVerent> some other maps have a different kind of issue though :)
17:23:29 <ertes> i would expect it to work with HashMap though
17:23:39 <divVerent> they only ever test using < and let a NaN overwrite a random other element
17:23:41 <ertes> > Data.HashMap.Strict.fromList [(0/0, "a"), (0/0, "b")]
17:23:44 <lambdabot>  error:
17:23:44 <lambdabot>      Not in scope: ‘Data.HashMap.Strict.fromList’
17:23:44 <lambdabot>      No module named ‘Data.HashMap.Strict’ is imported.
17:23:46 <divVerent> IIRC C++'s map does that
17:23:53 <ertes> @let import qualified Data.HashMap.Strict as Mh
17:23:55 <lambdabot>  Defined.
17:24:00 <ertes> > Mh.fromList [(0/0, "a"), (0/0, "b")]
17:24:02 <lambdabot>  fromList [(NaN,"a"),(NaN,"b")]
17:24:05 <ertes> uhhh
17:24:13 <ertes> why does that happen?  that doesn't make sense
17:24:27 <divVerent> well, a naive hash map implementation only ever compares using ==
17:24:30 <divVerent> so that's to be expected
17:24:33 <ertes> @let import qualified Data.Hashable as H
17:24:34 <lambdabot>  Defined.
17:24:39 <ertes> > H.hash (0/0)
17:24:41 <divVerent> I am actually more surprised that Map actually uses == :)
17:24:42 <lambdabot>  -2251799813685248
17:25:05 <divVerent> Go's map[] is weirdest there... they made the hash function return a random value on NaN, so inserting NaNs doesn't make the hash table inefficient
17:25:08 <ertes> HashMap *should* work
17:25:09 <divVerent> it still "leaks" though
17:25:27 <ertes> because even though 0/0 /= 0/0, hash (0/0) == hash (0/0)
17:25:34 <divVerent> yes, so?
17:25:39 <divVerent> that's a typical hash collision
17:25:44 <divVerent> hash maps can't kick out an element for that
17:25:55 <ertes> oh, i see
17:25:59 <ertes> of course
17:26:30 <divVerent> what'd behave different on NaN could be a map that only uses < of Ord like std::map in C++
17:26:42 <divVerent> there, NaN would count as smallest or largest element, typically (and kick out preexisting values)
17:26:46 <divVerent> even more nasty to debug
17:27:06 <divVerent> at least Data.Map isn't THAT insane :)
17:27:11 <ertes> well, Eq and Ord are underspecified
17:27:29 <ertes> (==) should be an equivalence relation, and (<=) should probably be a total order
17:28:39 <divVerent> Indeed, I'm surprised the documentation of Eq nowhere mentions "total order"
17:28:48 <divVerent> technically modules using Eq should only assume a partial order then...
17:28:57 <ertes> you mean Ord?
17:28:57 <divVerent> for Ord, sorry
17:29:05 <divVerent> wait, no
17:29:09 <divVerent> Ord says "totally ordered"
17:29:13 <ertes> well…  unfortunately you really need a total order for stuff like Map to work properly
17:29:15 <divVerent> it's Eq that doesn't define that it means
17:29:52 <ertes> so at least the Ord instances for Float and Double are in violation
17:29:58 <divVerent> indeed
17:30:14 <divVerent> as for map implementations - I suppose the Eq issue is solvable
17:30:27 <divVerent> if x /= x, a map could just skip inserting the element, as lookup could never find it ;)
17:30:45 <divVerent> OTOH one can always iterate over elements, so maybe it should stay and Data.Map does the right thing
17:30:47 <ertes> but what to do about it?  i'd say: dispense with IEEE
17:31:00 <divVerent> probably makes sense to specify one way and stick with it
17:31:06 <divVerent> IEEE does have some issues, indeed
17:31:12 <divVerent> so does Int :)
17:31:21 <ertes> Int?  why?
17:31:27 <divVerent> I indeed would love a "variant" of Haskell that has mathematically correct types by default
17:31:34 <divVerent> abs x < 0 has a solution, nuff said
17:31:47 <divVerent> a > b does not imply a+c > b+c
17:32:23 <divVerent> Integer does the right thing, and if Haskell were to be designed from scratch, maybe Integer should be called Int and Int should be called Int32 or something similar
17:32:27 <ertes> yeah, true…  however in that case i see no way to fix it
17:32:38 <ertes> other than to deliberately disallow the current minBound
17:32:48 <divVerent> well, it's mainly a naming thing
17:32:56 <divVerent> the "correctly behaving" thing should be the one simplest to use
17:33:05 <divVerent> and if one needs performance, one can take the tradeoff
17:33:40 <divVerent> at least Haskell does come with bigints in the standard library without any imports - it's a lot better than most other languages there
17:33:42 <ertes> there are use cases for "machine integers" though…  personally i wouldn't mind the renaming though
17:34:01 <divVerent> sure, but in most use cases you either care for the size anyway and would like to have it explicit
17:34:09 <ertes> rename Int to SmallInt and Integer to Int
17:34:19 <divVerent> or you just care for "some fast integer type", which is probably the current rationale behind Int
17:34:25 <divVerent> FastInt ;)
17:34:36 <divVerent> if you actually care for the size, Int32, Int64 etc.
17:34:45 <ertes> anyway, none of that is going to change any time soon =)
17:34:49 <divVerent> right
17:35:01 <divVerent> Int is the smaller problem anyway, every current programmer knows about those and doesn't fall for them
17:35:07 <divVerent> NaN is the bigger issue in practice
17:35:27 <divVerent> Infinity floating point values - meh, wouldn't hate it if by default these were refused too
17:35:47 <divVerent> sometimes I need full IEEE support, but that could be the "less simple to use" type (e.g. requiring an extra import)
17:36:33 <divVerent> ertes: also:
17:36:42 <divVerent> a == b, but (show a) /= (show b)
17:36:45 <divVerent> guess a and b :)
17:37:07 <ertes> well, one advantage of non-finite values is that you can handle them in pure code…  the only alternative i see is to provide a variant of (/) and 'recip' with explicit error results:  fdiv :: (Fractional a) => a -> a -> Maybe a
17:37:26 <ertes> > (1/0) == (-1/0)
17:37:29 <lambdabot>  False
17:37:32 <divVerent> > (\a b -> (a == b, show a == show b)) 0 1/(-1/0)
17:37:35 <lambdabot>  error:
17:37:35 <lambdabot>      • No instance for (Fractional (Bool, Bool))
17:37:35 <lambdabot>          arising from a use of ‘/’
17:37:41 <divVerent> damn, so close ;)
17:37:43 <ertes> ah, of course
17:37:49 <divVerent> where did I screw up :P
17:37:50 <ertes> > 0 == (-0)
17:37:52 <lambdabot>  True
17:37:57 <divVerent> -0 is not negative zero yet
17:38:01 <divVerent> you have to... force it :P
17:38:10 <divVerent> > 1/((-1) / 0)
17:38:12 <lambdabot>  -0.0
17:38:21 <divVerent> > (-0)
17:38:23 <lambdabot>  0
17:38:44 <divVerent> negative zero REALLY grinds my gears, causes even more subtle issues at times
17:39:05 <divVerent> at least Inf/NaN values "infect" anything they come in contact with so you'll figure out quickly what's up
17:40:04 <ertes> SurrealDouble
17:40:05 <ertes> =)
17:40:08 <divVerent> :)
17:41:48 <ertes> i'm really struggling with the choice between quickcheck and smallcheck…  the latter is better in principle, but also not in active development as it seems =/
17:45:42 <divVerent> cool, have to try smallcheck then
17:48:59 <ertes> the problem is that it's one of those packages:  it's better, but nobody is using it
17:49:52 <ertes> so you get missing stuff all over the place…  the thing that made me consider quickcheck is that there is no package with Arbitrary instances for 'vector'
17:52:23 <athan> Is `cloneLens` just `id`?
18:08:23 <mekeor`> reflex == future -- ?
18:09:42 <glguy> athan: No
18:10:39 <athan> glguy: Sorry, I just saw the implementation. Thank you!
18:10:51 <MarcelineVQ> ertes: what points make it better for your use?
18:11:39 <MarcelineVQ> sidequestion, arbitrary of vector is just   fromList <$> arbitrary  yeah?
18:15:35 <ertes> MarcelineVQ: it doesn't test randomly in general, but tries to come up with "interesting" samples
18:17:44 <MarcelineVQ> these docs are filled with ertes jargon :O
18:18:13 <ertes> "ertes jargon" =)
18:42:09 <manek> Hello guys! I've got 5-lines long Hs code and cannot get it compiled. It uses rank-n-types and it should work. Would anybody be so nice and look at it please? :) http://lpaste.net/351095
18:44:44 <ertes> manek: at the point when you pattern-matched the Either you have already instantiated the higher-rank 'm'
18:45:16 <manek> ertes: I know it and undertan where it originates. Is there any way to write such function ?
18:46:30 <ertes> manek: hideResult (mx :: forall m. …) = case mx of …
18:46:42 <ertes> uhm, nope
18:47:22 <ertes> uh, actually i see no reason to write a type signature at all
18:47:38 <glguy> manek: I don't think you'll be able to. You don't know what type 'm' is going to be in HiddenCtx yet
18:47:59 <glguy> so you won't be able to case on the argument without knowingthe type you're casing
18:48:05 <ertes> yeah, you need to actually pick an 'm' for HiddenCtx
18:48:49 <ertes> ah, no, i misread…  HiddenCtx isn't existential
18:49:02 <manek> glguy: Do I have to? HiddenCtx is jsut a wrapper with a context. I can write something like: `foo :: Foo m => m Int; foo = undefined; bar :: HiddenCtx Int; bar = HiddenCtx foo` and it works fine
18:49:20 <manek> ertes: yep, its not existential
18:49:48 <glguy> Yeah, I know it wasn't existential
18:50:15 <manek> glguy: I'm not touching `m` . I just want to pattern match on Either that ocntains this m. I know we'd be able to do it when having impredicative polymorphism in ghc, but unless then are we able to ?
18:50:35 <glguy> manek: No, you have to know what type the argument has to case on it
18:50:54 <glguy> but you don't know what type it's going to have, you needed it to be polymorphic
18:51:14 <manek> glguy: but I'm not casing on it, am I ? Im asking because I was sure it is not needed to be known when casing on something that wraps it
18:51:47 <manek> glguy: so it has to be impredicatively polymorphic? Unless it is GHC instantiates it there?
18:51:59 <glguy> manek: You're casing using a lambdacase
18:55:35 <manek> glguy: not using lambdacase, just normal case or multiple function definitions with different args doesnt make any change here
18:55:56 <glguy> yeah, my point is that you're casing it
18:56:03 <glguy> not that lambdacase made it different
18:57:35 <monochrom> That's interesting. I wonder whether "(forall x. a or p(x)) -> (a or (forall x. p(x)))" is provable in intuitionistic logic.
18:58:07 <ertes> instance (Eq a, Measured l (v a), Vector v a) => Eq (GenRope l v a)  -- i shouldn't be able to write this instance without FlexibleContexts, right?
18:59:15 <glguy> manek: consider that you can't even do this: hideResult e = case e of Right{} -> undefined
18:59:29 <glguy> manek: What type does 'e' have?
18:59:32 <manek> glguy: yep, I've tested it moment ago :(
18:59:37 <EvanR> monochrom: if x is enumerable, otherwise we have limited principle of omniscience
18:59:46 <manek> `e :: forall m => Foo m a`
18:59:58 <glguy> That's not a valid choice
19:00:03 <glguy> You have to pick a monotype
19:00:28 <glguy> Whether it's a Left or Right can depend on your choice of 'm'
19:01:04 <EvanR> to output Left a youd need to investigate all x to find an x which outputs Left a
19:02:30 <EvanR> *if X is finite, then it works
19:02:59 <monochrom> that is a bit counterintuitive (to me the classical logician) because "a" is independent of x. but thanks.
19:03:15 <glguy> manek: Also I was going to say, when you're pasting stuff like this it's nice if you include the extensions you're using so that it's easy to copy/paste into a local file
19:03:47 <EvanR> a is some variable, so that hypothesis is all we got
19:04:09 <monochrom> Yeah "a" is a propositional variable
19:05:35 <manek> glguy: sure, sorry for not pasting it like this
19:05:54 <glguy> No apology needed, it just makes it easier
19:06:29 <manek> glguy: how in this type Left / Right can even depend on the choice of `m` ? 
19:06:56 <manek> glguy: of course, sorry for making it harder! :0
19:07:00 <manek> :)
19:07:18 <EvanR> stuff like LEM and limited principle of omniscience is sometimes rejected because "it implies solutions to many unsolved problems of mathematics" whether or not this is a justified assessment, what would be the problem with that ;)
19:07:20 <glguy> manek: Because you don't get to use the lack of class methods as part of your reasoning
19:08:14 <glguy> and in general typeclasses allow value implementations to vary by type
19:09:52 <glguy> A class like Foo could have a method: class Foo (m :: * -> *) where example :: Either Int (m Int)
19:11:01 <glguy> then I could have 'hideResult example'
19:11:33 <glguy> hideResult is offering to tell me if example was going to produce a Left or Right but without knowing what m was
19:18:51 <EvanR> actually the situation is like the intuitionistic drinkers paradox
19:19:43 <EvanR> in that some domains allow searching and some dont
19:20:04 <EvanR> any given bar allows searching, at least if you look like a cop
19:44:46 <kendricktan> I don't seem to get `first` from `Control.Arrow`, could anyone shine some light onto it?
19:47:53 <kendricktan> > first even (10, 5)
19:47:56 <lambdabot>  (True,5)
19:51:32 <MarcelineVQ> :t first
19:51:34 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:51:59 <MarcelineVQ> imagine a as (->) and it may be clearer for your example
19:54:01 <Cale> Arrow types used to be easier to read back when we could have type variables with symbols in their names:
19:54:22 <Cale> (Arrow (~>)) => (b ~> c) -> ((b,d) ~> (c,d))
19:55:27 <kadoban> Hmm, that is quite a bit more readable
19:55:27 <kendricktan> that makes so much more sense. thanks :) 
20:18:50 <codygman> How can I convert a fractional to an Int?
20:20:16 <kadoban> :t round
20:20:17 <lambdabot> (RealFrac a, Integral b) => a -> b
20:20:25 <kadoban> There's also ceiling and floor, IIRC
20:20:40 <codygman> kadoban: Yep, thats what I was looking for
20:20:40 <codygman> > [(1 :: Int)..(round (1e6))]
20:20:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:20:59 <kadoban> Cool
20:53:01 <athan> `conjoined` seems really funny - what's the use of it?
20:53:13 <athan> I can see why `distrib` would be useful, kinda
20:53:39 <athan> but the type signature alone is really unique to me
20:53:40 <athan> it's almost got a scoped context
20:54:09 <athan> @type conjoined
20:54:11 <lambdabot> Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
20:55:09 <athan> "given that `p` is -> and Conjoined in the context of some `q`, then..." 
20:55:12 <athan> ...return the identity?
20:55:22 <glguy> conjoined is a performance hack
20:55:41 <glguy> It's so you can provide indexed and non-indexed things under the same name without a performance penalty
20:55:42 <glguy>   itraversed = conjoined traverse (itraverse . indexed)
20:55:54 <glguy> e.g.
20:56:06 <athan> oh wow that's awesome, thank you glguy!
20:56:31 <EvanR> does anyone know why the truth-functional interpretation of implication in classical logic is called that
20:56:57 <EvanR> coming from functional programming i dont see a parallel with the terminology
21:37:51 <Cale> EvanR: Because all there is to implication in classical logic comes down to the truth table values
21:38:51 <Cale> EvanR: In intuitionist logic, A -> B is not the same thing as B or (not A)
21:59:56 <codygman> This memory profile means that memory usage is constant, right? https://cloud.githubusercontent.com/assets/225847/21837296/9b8588ba-d790-11e6-889f-f0e02bc22c0d.png
22:02:25 <EvanR> it looks like nothing is happening at all
22:09:59 <kadoban> codygman: Looks like a good memory profile, ya.
22:10:06 <kadoban> (in my extremely limited experience)
22:14:49 <anohigisavay> hello!! xD
22:15:52 <anohigisavay> i'm writing a module that reads from sqlite
22:16:29 <anohigisavay> so i need to call `close` after each `open`
22:16:43 <Axman6> anohigisavay: which sqlite library are you using?
22:16:51 <anohigisavay> Axman6, sqlite-simple
22:17:22 <Axman6> you generally only call open once
22:18:07 <Axman6> there's also withConnection, which will ensure close is called even if there's an exception
22:18:56 <EvanR> sort of related to the memory profile... any idea how to estimate cpu usage of the program during runtime
22:19:37 <Axman6> EvanR: if it's anything I've written, it's 100%, anything less is a waste of resources :P
22:20:17 <anohigisavay> Axman6, there's no lazy IO involved i suppose?
22:20:26 <EvanR> example, youre writing a game and you want sound and graphics. you write the sound code and it uses 100% cpu, assuming youre out of cpus, youre fucked
22:20:48 <anohigisavay> i can keep a non-strict reference to the data and can still evaluate the data correctly?
22:20:50 <EvanR> would be interesting to "how much spare" you have
22:20:57 <EvanR> to see
22:21:08 <Axman6> anohigisavay: not sure what you mean
22:22:09 <Axman6> anohigisavay: make sure you have a good read of the sqlite-simple docs, for example the advice about using fold instead of query if you can (the docs imply to me that it will read all results into RAM, so lazy IO shouldn't be an issue)
22:22:33 <EvanR> and yeah closer to 0% is better for me and my electricity bill
22:22:38 <Axman6> uh, also the line "All results are retrieved and converted before this function returns." seems to confirm that :P
22:23:49 <anohigisavay> Axman6, thanks :) sorry about not having a complete read of the doc
22:24:35 <Axman6> it's a pretty small library, so I'd suggest reading all of it, so you have a better idea of what's available to you
22:26:17 <anohigisavay> Axman6, thanks man, will do that :)
22:26:59 <eklavya> how to analyze if a haskell program is leaking memory (no space leaks just good old memory leak) ?
22:27:38 <Axman6> you mean in C code called from Haskell? 
22:27:51 <eklavya> no
22:27:55 <eklavya> it's all haskell
22:28:17 <Axman6> because everything's GC's, there shouldn't be any "leaks", but holding references to old things which are actually garbage can cause increasing memory usage
22:28:27 <eklavya> yes
22:28:39 <eklavya> so is there a way to analyze the heap?
22:28:42 <eklavya> or something?
22:29:11 <Axman6> there is heap profiling, yes (see EvanR's link above)
22:29:20 <Axman6> https://cloud.githubusercontent.com/assets/225847/21837296/9b8588ba-d790-11e6-889f-f0e02bc22c0d.png in case you missed it
22:29:34 <eklavya> yay!
22:29:45 <eklavya> and is it realtime?
22:29:58 <Axman6> not as far as I'm aware
22:29:58 <EvanR> ironically, this emulated game has a "free cpu time" gauge which is almost at "completely free" but the emulator is at 100% cpu
22:30:27 <eklavya> is it threadscope?
22:30:35 <eklavya> sorry, I should have tried threadscope
22:31:10 <EvanR> holding onto things which should be collected also plagues regular GCed languages
22:31:16 <EvanR> like java, ruby
22:31:43 <Axman6> it's easier to get wrong in Haskell though, because laziness can mean something is referenced in a thunk which shouldn't be
22:32:34 <EvanR> one thing is kind of unusual, if you keep unevaluated data around that accumulates, because you never look at it, and its there because you might want to look at it at some point, it builds up in memory
22:32:47 <eklavya> once heap has expanded, it doesn't ever decrease right?
22:33:09 <EvanR> i think it does
22:33:17 <EvanR> ghc can return memory to the OS
22:33:21 <eklavya> wow
22:33:31 <eklavya> then it's very likely that I have a leak
22:33:42 <eklavya> the memory graph is always upwards
22:33:49 <EvanR> you probably do
22:33:57 <EvanR> unless the problem logically requires hat
22:34:00 <EvanR> *THAT
22:34:02 <kadoban> Any advice/tools/reading on how to correctly set version bounds on dependencies? Wouldn't mind doing it correctly for once. Especially interested in how to figure out what bounds actually work without a bunch of work and what to do for upper limits
22:34:10 <eklavya> maybe I should leave it running for 6-8 hours
22:34:23 <EvanR> less than a minute should be enough
22:34:44 <eklavya> no I mean if it really is leaking
22:34:45 <joehillen> eklavya: https://github.com/ndmitchell/blogs/blob/master/published/detecting-space-leaks.md
22:34:52 <Axman6> hmm, I'm not sure GHC compiled programs will ever "return" memory to the OS, but that migth have changed
22:34:55 <eklavya> it will never achieve a steady state
22:35:17 <EvanR> you dont need to wait longer than a minute to see that
22:35:37 <eklavya> joehillen: yeah I know about that one, thanks :)
22:35:39 <EvanR> if you think it should take constant space, the graph should be more or less constant
22:35:46 <EvanR> if you fix it
22:36:02 <eklavya> EvanR: I am not sure about that
22:36:09 <EvanR> ?
22:36:26 <eklavya> I was using an infinite curl loop to request
22:36:35 <eklavya> let me do a wrk2 test
22:36:37 <EvanR> yes, because the collector runs very quickly for junk that should be collected soon
22:36:46 <eklavya> so I know the request rate has peaked to some value
22:36:53 <Axman6> infinite curl loop?
22:37:07 <eklavya> while true; do curl ;done :P
22:37:24 <Axman6> how is haskell involved?
22:37:46 <eklavya> I am testing my db driver (haskell)
22:37:52 <eklavya> I put this curl loop
22:38:04 <eklavya> then I randomly stop start pause db
22:38:54 <eklavya> the small web app is a servant app
22:39:05 <eklavya> and the memory usage keeps increasing
22:39:08 <eklavya> in small amounts
22:39:11 <eklavya> but upwards
22:39:38 <eklavya> I am guessing unless the request rate has some peak I can't really say if the steady state has been achieved
22:39:46 <EvanR> and is your program supposed to be saving accumulating state somewhere?
22:39:59 <eklavya> nope
22:40:33 <EvanR> if you werent using any framework or lib, i would say ime thats a space leak
22:40:34 <eklavya> yeah I think I have a leak :(
22:40:40 <EvanR> but i dont know how servant works
22:40:51 <EvanR> once when that happened to me, the bug was in gloss
22:40:59 <EvanR> which is now fixed
22:41:16 <eklavya> EvanR: even if there was, when the request has been served all thunks should have collapsed, right?
22:41:19 <EvanR> steady creep upward is gone
22:41:35 <EvanR> if theres a bug?
22:42:01 <eklavya> EvanR: I am pretty sure it's in my code, servant is widely used?
22:42:23 <EvanR> "in somebody elses code we trust" (tm)
22:42:33 <eklavya> :D
22:42:42 <EvanR> i figured gloss was widely used
22:43:40 <EvanR> i think i figured it out with retainer profiling
22:44:02 <eklavya> I am such a noob I couldn't possibly blame any code but mine :D
22:44:30 <EvanR> i certainly had a bunch of issues with my code
22:44:41 <EvanR> only one with gloss
22:48:10 <EvanR> all this talk about space leaks
22:48:50 <EvanR> it seems kind of ridiculous that haskell is so awesome in other areas and not this one
22:49:03 <johnw> I wonder if blackholes are the greatest space leaks of all
22:49:04 <EvanR> im sure theres a hand wavy theoretical justification 
22:49:35 <EvanR> oh thought you were talking about ghc blackholes
22:49:47 <johnw> lol
22:50:36 <Axman6> blackholes are extremely dense so their quite an efficient use of space :P
22:50:54 <johnw> but it's space that I can't use anymore
22:51:03 <EvanR> i just tried to look up into about blackholes on google, and apparently its two words
22:51:25 <johnw> I guess I don't talk about them in writing much
22:59:14 <qmm> what are some good tutorials that aren't outdated on monad transformers?
22:59:37 <benzrf> qmm: you mean specifically monad transformer tutorials?
23:00:47 <qmm> benzrf: i am looking to familiarize myself with monad transformers as well as using MTL since i believe that is the standard library everyone is using
23:00:49 <athan> This is probably a dumb question, but what are indexed traversals / lenses useful for?
23:01:03 <athan> Do they create or use indexes?
23:01:19 <johnw> athan: they give you access to the index used to access an element
23:01:27 <Axman6> they give you the index if the element you're focussing on
23:01:53 <benzrf> qmm: i'd recommend just looking at a couple of monad transformers individually
23:01:58 <benzrf> at least to begin with
23:02:00 <Axman6> it's like doing zipWith [0..] (or whatever index type) to all the results
23:02:19 <benzrf> qmm: how comfortable are you with, say, non-transformer Reader, State, and Either monads?
23:02:26 <benzrf> (and with the concept of monads in general)
23:03:18 <athan> ahh okay, thanks Axman6 & johnw!
23:03:19 <Axman6> athan: basically it lets you do things like multiply every third focussed element by something (that'd be really useful in some geospatial code I had actually...)
23:03:39 <athan> Oh wait okay, so you can't really have an indexed lens then, right?
23:03:47 <athan> strict* lens
23:03:57 <Axman6> yeah I don't think that makes sense
23:03:57 <qmm> benzrf: i'm confident in how they are used though i have little experience with them myself
23:04:08 <Axman6> but lenses should compose with indexed traversals
23:04:09 <athan> ahh wow okay, that's awesome
23:04:50 <benzrf> qmm: in my experience, those two usually don't coexist :P
23:04:50 <qmm> i was looking at Writer and WriterT today, but i didn't finish reading about them, but i was thinking i'd need something like that since the code i needed was needing some logging mechanism for each step of the process
23:05:29 <qmm> i started reading http://catamorph.de/publications/2004-10-01-monad-transformers.html i suppose i could continue reading that and make note of all the errors for the lhs file
23:06:17 <johnw> qmm: consider the difference between t (m a) and (t m) a.  A monad transformer is some 't' such that 't m' is also a monad.
23:16:40 <johnw> they're only "special" because not every composition of monads is also a monad; whereas StateT s m is always a monad, if 'm' is a monad, so transformers are really just recognized patterns of monadic composition
23:20:29 <glguy> qmm: writer isn't actually good for logging, that's more of a way to think about what that type does
23:21:04 <johnw> glguy: well, for pure calculations it's good for logging
23:21:29 <glguy> only in the most trivial cases
23:22:02 <glguy> it's not an efficient way to log anything
23:22:35 <johnw> i mean, if you aren't using IO at all, it's one of the best ways
23:22:57 <johnw> I just used it yesterday for that purpose
23:23:05 <glguy> no, i wouldn't agree that it's a best way at all
23:23:16 <johnw> unless you are just talking about WriterT over some 'm' that could also do logging
23:25:16 <glguy> it's better to think of it as a preexisting building block that one could use to build with, you might build something like logging with it if you don't mind accumulating thunks
23:27:07 <johnw> glguy: what is your non-thunk accumulating alternative?
23:27:53 <glguy> you could build a logging library with a state transformer and avoid it
23:28:15 <johnw> i'm not sure how that's different
23:28:33 <johnw> "s -> m (a, s)" vs. "m (a, w)"?
23:28:40 <mrkgnao> anyone here use NixOS?
23:28:43 <johnw> mrkgnao: yes
23:28:55 <mrkgnao> I can't get Gloss to work because of a missing GL dependency
23:29:01 <glguy> yeah, or dives you the opportunity to force evaluation of the"log" along the way
23:29:04 <mrkgnao> back on Arch I just installed freeglut
23:29:08 <benzrf> mrkgnao: so you only have oss?
23:29:10 <glguy> it gives*
23:29:15 <johnw> mrkgnao: #nixos might be able to help
23:29:20 <mrkgnao> benzrf: pls
23:29:24 <benzrf> :D
23:29:26 <johnw> glguy: ah, I see
23:29:50 <johnw> glguy: http://stackoverflow.com/questions/25749126/a-stricter-control-monad-trans-writer-strict
23:29:59 <johnw> basically just the solution you propose
23:30:00 <johnw> thanks
23:30:05 <mrkgnao> johnw: I tried yesterday and didn't get an answer :) I'll ask again, but I figure this was worth a shot.
23:30:18 <johnw> mrkgnao: are you trying to make some Haskell code work?
23:31:06 <mrkgnao> nah, just trying to get the simple stack project to build with gloss in the buildDepends
23:31:22 <mrkgnao> as in, I did "stack new" and edited the cabal file
23:31:26 <johnw> well, at least stack is involved
23:31:44 <glguy> my larger point is just that the primitive transformers don't exist because they are the best way to do something but because they are primitive components that make sense to exist and might be useful
23:31:44 <mrkgnao> I'm new enough to not have known cabal nontrivially
23:32:10 <johnw> glguy: point taken, thanks for that clarification, I appreciate it
23:53:11 <kadoban> Any advice/tools/reading on how to correctly set version bounds on dependencies? Wouldn't mind doing it correctly for once. Especially interested in how to figure out what bounds actually work without a bunch of work and what to do for upper limits
