00:37:29 <Insanity_> Can I ask questions about Cabal in this channel as well?
00:37:37 <hvr> Insanity_: sure
00:38:18 <Insanity_> I've pulled down cabal from the github repository to install it, but it keeps defaulting to an install location I don't really like. Any way to change the install location?
00:38:41 <hvr> Insanity_: `cabal` or `Cabal`?
00:38:59 <hvr> i.e. are you referring to the executable?
00:39:18 <Insanity_> Essentially I'd like to have the packages stored in a different location to the default
00:39:46 <hvr> Insanity_: well, once you have a `cabal` executable, you can configure the locations via the ${HOME}/.cabal/config file
00:40:02 <Insanity_> Oh okay, I'll take a look in the config file
00:40:19 <hvr> Insanity_: but that config file isn't yet used if you're bootstrapping cabal directly from GitHuB
00:40:25 <Insanity_> ah
00:40:32 <hvr> Insanity_: what OS are you on?
00:40:40 <Insanity_> Windows at work unfortunately
00:41:20 <Insanity_> I'm not as familiar with this so it takes some time figuring out how they do things :D But the packages are now being downloaded to a network drive, which syncs on all other work devices. A lot of packages == slow startup
00:41:41 <hvr> Insanity_: I'd suggest grabbing a recent cabal.exe
00:42:20 <hvr> Insanity_: is there are reason you seem to be bootstrapping directly from github?
00:42:59 <Insanity_> I was thinking that the default install location should be in there and that I could change it then :-)
00:43:15 <Insanity_> No other reason, I can grab the .exe
00:43:29 <hvr> Insanity_: ok, well... in that case I'd suggest to grab the .exe and tweak it via the config file :-)
00:43:48 <hvr> (which is stored somewhere in your %APPDATA% iirc)
00:44:13 <Insanity_> I'll do that, cheers!
00:44:14 <hvr> it's created automatically by `cabal`
00:44:16 <hvr> when you run it
00:44:33 <hvr> and it's commented, so it should be obvious which entry to edit
00:44:46 <Insanity_> Thanks :-)
00:57:21 <fizbin> Hey, anyone else using snap-core and snap-server without using the rest of snap?
00:59:27 <fizbin> If so, is it possible to wrap a "Snap ()" action so that you can run stuff both before and after that action, no matter how it terminates? (and access the state so that you record the HTTP return status)
01:04:01 <saurabhnanda> why is this foldl not typechecking? https://gist.github.com/saurabhnanda/d9daa86cd7b9871626611490c967accf
01:08:04 <cocreature> saurabhnanda: you forgot the initial value
01:08:10 <cocreature> oh no you didn’t sry
01:09:34 <saurabhnanda> i can transform b -> a in a foldl' right?
01:09:51 <cocreature> saurabhnanda: could you show the type of "tags"?
01:10:00 <cocreature> not quite sure what b and a are supposed to be in your question
01:10:17 <cocreature> the fold can evaluate to a different type than the items of the lits
01:10:19 <cocreature> *list
01:10:21 <saurabhnanda> cocreature: which type do you need?
01:10:30 <saurabhnanda> cocreature: yes, that's what I was wondering
01:10:45 <cocreature> saurabhnanda: you are calling ct ^. tags, what is the type of "tags"
01:11:44 <saurabhnanda> updated the gist at https://gist.github.com/saurabhnanda/d9daa86cd7b9871626611490c967accf
01:11:58 <saurabhnanda> according to me (ct ^. tags) is supposed to be [T.Text]
01:13:30 <cocreature> where is foldl' coming from in your code?
01:13:54 <cocreature> try calling Data.List.foldl' explicitely. it seems like you are using foldl' from Data.Text
01:33:26 <unclechu> what does mean `| m -> s` in this expression `class Monad m => MonadState s m | m -> s where`?
01:34:18 <srhb> unclechu: "Where the type m determines the type s"
01:34:18 <cocreature> unclechu: it means that "m" uniquely determines what "s" has to be. it is enabled by an extension called FunctionalDependencies
01:35:57 <unclechu> thanks, I'm going to read about 'functional dependencies' ext.
01:47:38 <saurabhnanda> cocreature: wow, never thought of that
01:48:16 <jmorris> is there a superior alternative to showIntAtBase in Numeric
01:48:21 <saurabhnanda> cocreature: yes, you were right. Thanks!
01:48:37 <cocreature> saurabhnanda: yw
01:49:39 <saurabhnanda> cocreature: is there a  uniq :: [a] -> [a] function?
01:50:57 <c_wraith> :t nub -- saurabhnanda: is this what you're looking for?
01:50:59 <lambdabot> Eq a => [a] -> [a]
01:51:18 <jmorris> don't worry about my question i got a solution
01:51:30 <saurabhnanda> c_wraith: yes. who came up with this name?
01:51:39 <c_wraith> saurabhnanda: no idea.  it's a bit odd.
01:51:45 <cocreature> if you care about performance you probably want to use https://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/Data-List-Ordered.html#v:nubSort
01:52:04 <cocreature> "nub" only uses == to find duplicates so it is quadratic in the worstcase
01:52:18 <srhb> saurabhnanda: It's so weird that the docs even need an explanation of the word: "(The name nub means `essence'.)"
01:52:23 <srhb> Go figure.
01:52:24 <c_wraith> and for what it's worth, the worst case is "no duplicates"
01:52:44 <c_wraith> best case is every element is the same
01:52:59 <saurabhnanda> c_wraith: need to filter out duplicates in Haskell for POC code. Will be replaced by the appropriate SQL statement later.
01:53:25 <saurabhnanda> c_wraith: does sorting make the performance better?
01:53:35 <c_wraith> no
01:53:44 <saurabhnanda> c_wraith: anyways this is POC code. Let it be
01:55:02 <pavonia> You can use group if you are sorting the list
01:55:51 <cocreature> > (map head . group . sort) [1,2,1,3,1,4]
01:55:53 <lambdabot>  [1,2,3,4]
01:55:54 <EvanR> google agrees nub means that... secondary meaning what youre left with after getting blown up by terrorists
01:56:12 <EvanR> i never knew before learning haskell, so im skeptical
01:56:22 <cocreature> EvanR: terrorists exploiting quadratic behavior in your code
02:16:33 <aloiscochard> hi all, does anyone know about some cool open positions for EU/remote work using haskell ? thanks1
02:32:21 <janosp> I think Well-Typed is hiring
02:32:38 <janosp> But I am not sure about it
02:32:53 <janosp> maybe drop them an E-Mail
02:33:08 <janosp> Furthermore you'll find some Haskell positions at functionalworks
02:47:28 <aloiscochard> janosp: I'll check, thanks a lot!
02:56:52 <jmorris> is there a library like this, https://hackage.haskell.org/package/base16-bytestring-0.1.1.6, for binary/base2 encoding and decoding?
03:07:29 <merijn> jmorris: What do you mean, you just want to inspect Bits?
03:08:38 <jmorris> merijn: I want to encode and decode from string to binary and back but the only thing I can find is showIntAtBase
03:10:36 <merijn> Well, there's also "readInt" which is the opposite of showIntAtBase
03:19:21 <ij> Does something I'd call «syntactic search» exist for haskell? So that instead of /class.*Traversable/ I could search "class { name = Traversable }" or equivalent. 
03:25:54 <c_wraith> ij: that specific case might be covered by hoogle/hayoo.  In general, I don't think any tool like that exists.
03:41:05 <merijn> Anyone know of a GLR parser generator for Haskell?
03:41:46 <mniip> doesn't happy do that?
03:42:24 <niklasb> when building my stack project, I get a weird linking error: http://lpaste.net/6852315932140765184 any tips on how to debug this?
03:42:46 <merijn> I dunno, does it? I was under the impression that Alex/Happy were LALR(1) like flex/yacc
03:43:50 <mniip> >This chapter explains how to use the GLR parsing extension, which
03:43:50 <mniip> allows Happy to parse ambiguous grammars and produce useful results. This extension is triggered with the --glr flag, which
03:43:51 <mniip> causes Happy to use a different driver for the LALR(1) parsing tables.
03:44:39 <merijn> oh, neat
03:45:09 <hvr> niklasb: iirc this is a Stack bug, and the recommendation was to wipe your ~/.stack folder; but I don't use Stack myself, so take this advice with caution
03:46:17 <cocreature> niklasb: I’ve solved this kind of problems with "stack excec ghc-pkg unregister …"
03:46:43 <niklasb> cocreature: cool, unregister what exactly?
03:46:51 <niklasb> the random package in this case or time?
03:47:02 <cocreature> random
03:47:30 <niklasb> thanks. I'll try wiping the whole ~/.stack just to be sure
03:48:33 <hvr> if I had to guess, it's about Stack not properly isolating cached artifacts shared between different snapshots, or some similiar multi-instance issue; we had that such errors in the early stages of cabal's nix-local-builds  impl as well
04:06:29 <lpaste> stdnt pasted “Maybe type  problem” at http://lpaste.net/350761
04:06:53 <lpaste> stdnt annotated “Maybe type  problem” with “Maybe type  problem (annotation)” at http://lpaste.net/350761#a350762
04:08:09 <stdnt> Hi, I'm having a problem with Maybe type, can someone help me?
04:08:31 <stdnt> I pasted the code and error message here: http://lpaste.net/350761
04:11:07 <lyxia> stdnt: line 12 you swapped the arguments tree and (qty - 1)
04:11:36 <lyxia> stdnt: line 13 you pattern match on a Maybe Int value with the pair constructor (_, 1)
04:11:59 <lyxia> Did you mean (Just 1)
04:13:02 <stdnt> lyxia : thank you very much, i should probably rubberducking much more :-|
04:14:08 <stdnt> i was passing along Maybe (Int, Int) previously, that's whu the pair constructor (_,1) is there. I'm not sure with (Just 1), im not familiar with it
04:16:43 <dcz__> hello everyone
04:19:10 <lpaste> stdnt revised “Maybe type  problem”: “Maybe type  problem” at http://lpaste.net/350761
04:19:33 <lpaste> stdnt annotated “Maybe type  problem” with “Maybe type  problem (annotation)” at http://lpaste.net/350761#a350764
04:20:04 <dcz__> http://ideone.com/1VnQpc, this doesnt work due to " No instance for (Data.String.IsString  (aeson-1.1.0.0:Data.Aeson.Types.Internal.Parser Person))
04:20:04 <dcz__>       arising from the literal ‘"haha"’" 
04:20:13 <dcz__> can enybody help whats wrong ?
04:20:47 <stdnt> lyxia : it now compiles, with Just, but it gave a warning of Pattern match(es) are overlapped
04:20:59 <dcz__> it doesnt compile
04:24:22 <stdnt> dcz__ : it doesnt?
04:24:39 <dcz__> yes sir
04:25:59 <stdnt> dcz__ : tha's strange, mine only shows warning as you can see here: http://lpaste.net/350761#a350764
04:27:05 <dcz__> stdnt: thats not the code i gave, look at this: http://ideone.com/1VnQpc
04:28:41 <stdnt> dcz__ : Ah i see, I'm not that experienced yet to give you a solution for that haskell problem unfortunately, I was asking a questiong my self as well
04:29:20 <dcz__> okey, ty
04:29:34 <iphy> is there a way to get packages with extra-libraries to build on hackage?
04:30:12 <iphy> e.g. https://hackage.haskell.org/package/saltine-0.0.0.4/reports/ always fails because it needs libsodium
04:30:39 <merijn> iphy: Manually install said libraries?
04:30:47 <merijn> iphy: Oh, you mean on hackage?
04:30:51 <iphy> merijn: on hackage?
04:31:36 <merijn> No, there's no way to get those to build on Hackage beyond "ask hackage admins if they're willing to install said library" which (in general) seems unlikely
04:31:57 <c_wraith> if your concern is documentation, you can upload that pre-rendered
04:32:01 <lyxia> stdnt: yes the third clause is unreachable
04:32:19 <lyxia> stdnt: because the second one catches everything
04:32:26 <merijn> c_wraith: I think newer cabal's (finally) have a builtin command for that too :)
04:32:30 <dcz__> http://ideone.com/1VnQpc, this doesnt work due to " No instance for (Data.String.IsString  (aeson-1.1.0.0:Data.Aeson.Types.Internal.Parser Person)) can anybody help ?
04:32:52 <merijn> dcz__: Well, what's the type of .: ?
04:32:59 <dcz__> Int
04:33:08 <cocreature> dcz__: you probably need "pure" in front of "haha"
04:33:09 <dcz__> ahh i see :D
04:33:31 <stdnt> lyxia: yes, thank you!
04:33:56 <dcz__> cocreature, it didnt work
04:33:59 <hvr> merijn: cabal haddock  --for-hackage && cabal upload -d <doc-tarball>
04:34:55 <merijn> hvr: Yeah, I've mostly been using Fuuzetsu's script from a while back and so far I couldn't be arsed to research how, especially since I'm not even sure my cabal-install is new enough :p
04:35:02 <cocreature> dcz__: “it didn’t work” is not a very accurate description of the error you’re seeing :)
04:35:10 <dcz__> :D
04:35:45 <dcz__> cocreature, http://ideone.com/JfmLKW error
04:36:17 <cocreature> dcz__: well you are trying to parse a Person but you are supplying a string
04:36:20 <cocreature> that won’t work
04:36:28 <cocreature> if you want the Parser to fail use "empty"
04:36:40 <dcz__> i used it but , let me show 
04:37:23 <dcz__> cocreature, http://ideone.com/rnrW1B
04:38:08 <merijn> Ooh, ooh!
04:38:20 <merijn> I'm betting $100 on unqualified import of Data.Text :)
04:38:34 <dcz__> :D
04:38:44 <merijn> dcz__: You're using the wrong empty
04:39:11 <cocreature> unqalified importing of Data.Text considered harmful
04:40:17 <dcz__> what that means ?
04:40:28 <dcz__> unqualified importing ?
04:41:51 <cocreature> writing "import Data.Text" instead of "import qualified Data.Text" or "import qualified Data.Text as Text"
04:42:45 <cocreature> the first one will import the symbols in Data.Text directly, the last two make them available under Data.Text.symbolname or Text.symbolname
04:43:33 <dcz__> yeah, changed liked that.
04:43:46 <dcz__> what is the correct empty then ? :D
04:46:30 <dcz__> http://ideone.com/6GMrCt
04:46:47 <pie_> random nutty idea: haskell machine like there was lisp machine
04:46:58 <pie_> i havent figured out how to find anything on google yet though
04:47:12 <pie_> kind of hard to google system Fc in fpga
04:47:27 <pie_> and i dont seem to have gotten any relevant results anyway
04:48:16 <merijn> pie_: Google HaLVM and House
04:48:27 <merijn> pie_: Actually, not quite what you want, but still
04:48:49 <merijn> Also, I know a guy at the University of Twente who's working on designing a CPU optimised for lazy functional languages
04:49:32 <pie_> neato :)
04:50:10 <merijn> Not sure how much he's published yet, he was just starting when I last heard about it
04:50:29 <pie_> aw :( id be curious
04:50:30 <merijn> pie_: Oh, and final pointer for Haskell + FPGA, have a look at Cλash
04:50:32 <maerwald> functional hardware or just "optimized"?
04:50:36 <rdococ> ʸᵃʸ
04:50:42 <pie_> merijn, yeah i familiar with clash ^_^
04:51:20 <merijn> maerwald: At the hardware/transistor level everything is purely functional to begin with (hence clash)
04:51:24 <maerwald> last I checked spj said functional hardware was kind of a failure (couldn't keep up performance-wise)
04:51:44 <merijn> maerwald: The problem is that Intel CPUs are designed for assumptions that don't hold true for, say, Haskell
04:51:50 <maerwald> but he was talking about stuff that happened a few decades ago I guess
04:52:26 <merijn> maerwald: For example, caches assume locality (accessing something implies it's likely closeby values are accessed soon), but in general with thunks and laziness that's not true
04:52:57 <merijn> So why waste CPU space on caches? What if instead you build hardware level nurseries for the GC.
04:53:10 <rdococ> idk what you are talking about but meh
04:53:11 <merijn> Haskell also does *a lot* of indirect jumps, what if you optimise for those
04:53:48 <merijn> maerwald: So, that sorta stuff
04:53:53 <maerwald> and then still my kernel is written in C :o
04:54:15 <merijn> maerwald: C would be a terrible language to write a kernel in for such hardware
04:54:36 <maerwald> I'm not sure haskell is a good language for that either
04:55:21 <merijn> People have written kernels in Haskell and the Oregon State University had a project for a Haskell-dialect for systems programming (although it seems dead)
04:55:35 <merijn> NetBSD succesfully had drivers running haskell for a bit
04:55:37 <maerwald> people have written kernels in javascript too
04:56:21 <merijn> Haskell as-is isn't really suitable for kernel stuff, but that's not really due to fundamental limitations, but more due to design decisions made when it was first conceived
04:56:38 <merijn> I think a language very similar to Haskell would work excellent for kernel/systems stuff
04:57:04 <pie_> rust is a thing i guess
04:57:13 <pie_> but rust isnt haskell
04:57:25 <merijn> I like rust, but I wouldn't consider it similar to Haskell, nor the kind of language I would imagine
04:58:15 <maerwald> for a "kernel language", you want full control and have as little difference between "expressed code" and "low-level output" (whatever format that may be). I don't see haskell anywhere near that
04:59:08 <merijn> maerwald: GHC has plenty of primitives for that, and if you look at the Habit Language Report you can see what a Haskell language with those things integrated would look like
04:59:34 <merijn> You really don't need "little difference between expressed code and output", because if you didn't you wouldn't use C either
04:59:42 <maerwald> GHC generates a whole lot of stuff you cannot reason about, including an RTS
04:59:49 <merijn> What you *really* need is primitives for accessing machine state directly
05:00:10 <merijn> maerwald: The RTS could easily be reworked to run bare-metal
05:00:19 <merijn> In fact, it has been on 2 separate occasions
05:00:27 <maerwald> and people *do* reason about the output, not just the language the kernel is expressed in
05:00:27 <merijn> (House and HaLVM)
05:00:41 <merijn> What you care about is memory layout
05:01:20 <merijn> And Report Haskell doesn't have the primitives for that, GHC has some (but not all you want), but there's no reason you couldn't trivially add in things for that, again, see Habit Language Report
05:02:40 <maerwald> pie_: rust would just get in the way of writing a kernel, since the borrow checker isn't remotely smart enough to understand "advanced" memory tricks (that are in fact safe)
05:02:59 <maerwald> and you want those tricks in a kernel
05:03:06 <merijn> Which "advanced" memory tricks?
05:03:23 <merijn> I can't really think of anything you need in the kernel that you couldn't do in Rust
05:03:31 <maerwald> that's not what I said
05:03:48 <maerwald> but it requires additional boilerplate
05:03:59 <merijn> Like what? Give me one example
05:04:01 <maerwald> try to use gtk+ in rust and you'll see a few of those problems
05:04:20 <maerwald> it doesn't understand the lifetime of gtk+
05:04:28 <merijn> That's a mismatch between the Rust and C++ FFI
05:04:33 <maerwald> C++?
05:04:43 <merijn> That doesn't apply to a system completely in Rust
05:04:56 <merijn> C? I don't know what the hell gtk+ is written in
05:04:57 <maerwald> yes, but it also shows there are less ways to express it
05:05:17 <maerwald> and again: require a lot of boilerplate sometimes
05:05:23 <maerwald> because the borrow checker is not smart
05:05:33 <maerwald> it's not a "memory safety prover"
05:05:39 <maerwald> it's just a few very simple rules, enforced
05:06:25 <merijn> You are making a lot of assertions without evidence or examples
05:06:59 <maerwald> I'm not writing a thesis
05:07:21 <maerwald> about the rules, see the rust documentation
05:07:26 <maerwald> about the boilerplate, look up some rust code
05:07:49 <jaspervdj> Is there a package which provides a binary/cereal interface but that allows you to use some sort of cache?
05:07:54 <merijn> You're trying to argue that thinks aren't "feasible" which I don't belief based on my experience with: 1) kernel programming, 2) systems programming and 3) programming language
05:08:10 <maerwald> then I have a different experience in rust than you do
05:08:21 <jaspervdj> Maybe in mtl-style so you can drop a custom transformer around Get/Put
05:08:26 <merijn> maerwald: Now, you can either 1) disagree with me or 2) try to convince me with evidence. If 1, why are we discussing this? If 2, please provide evidence/examples.
05:08:51 <maerwald> I'm not interested in convincing you by trying to make a scientific case, no
05:09:44 <merijn> maerwald: Well, you're definitely not going to convince me with blind assertions, which means there's no point to this discussion
05:09:52 <maerwald> and none of this is scientific anyway, I said "rust would get in the way" which is a fuzzy statement of experience with a programming language
05:09:58 <maerwald> not an assessment like "it's not possible"
05:10:28 <maerwald> you're simply misunderstanding my statement
05:59:21 * SnowFlake yawns
06:13:14 <Superhoop> Wassup
06:13:38 <JuanDaugherty> nuthin
06:13:51 <JuanDaugherty> and no hoops
06:14:03 <JuanDaugherty> *no damn hoops
06:15:18 <Superhoop> LOL
06:15:27 <JuanDaugherty> :)
06:19:40 <ertes> watchin' the flame, havin' a tea…  what 'bout you?
06:22:02 <Superhoop> Chilling..
06:23:52 <JuanDaugherty> rise Sir Chillax Superhoops
06:24:22 <ertes> (if you just joined, you'd probably find that chilling, yeah) =)
06:25:26 <nshepperd> I hope it's not the servers burning
06:35:01 <danpalmer> Hi all, I'm getting a compile error on my Persistent models when I add a foreign key, but I'm not sure what's wrong with the syntax, can someone have a quick look and let me know if I'm doing something stupid? https://gist.github.com/danpalmer/dc7029cfc43d6ad1807e2ac5ccc07249
06:36:38 <danpalmer> Have added the error message to the gist, but tldr; "Multiple declarations of ‘TagGroup’" when I reference the Id in a foreign key.
06:38:24 <amx> is it known why fromJust intentionally does not generate a stack trace, and why this was changed from base 4.8.2.0 to 4.9.0.0: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Maybe.html#fromJust
06:41:49 <kuribas> amx: maybe for performance?
06:41:49 <merijn> amx: Because it wasn't possible to generate stack traces before?
06:42:44 <merijn> Stack traces are fairly new, and in some cases adding HasCallstack constraints to functions has some overhead, afaik?
06:44:30 <amx> the way I see it error appends the call stack starting from 4.9.0.0, but did not before (which is why errorWithStackTrace existed)
06:44:57 <kuribas> amx: that's why you shouldn't use fromJust, better use "fromMaybe (error "myfunc: unexpected Nothing") myVal"
06:45:47 <merijn> amx: Right, but that adds overhead
06:45:49 <amx> yes I know, it's just frustrating when programs crash in fromJust and I don't know where to fix it
06:46:03 <amx> ok, so it's performance
06:46:27 <merijn> amx: Then the question is why those programs are using fromJust in the first place? :)
06:46:33 <nshepperd> I thought the reason for adding stack traces was to fix that sort of issues (with fromJust etc)
06:47:36 <merijn> nshepperd: Doing so in Prelude would regress the performance of every single existing program/library using fromJust
06:47:39 <nshepperd> also: I'm confused, I thought error only appends the stack trace *when available*?
06:47:59 <nshepperd> would 'error "fromJust"' have not compiled at all?
06:48:43 <merijn> I have a mailing list discussion on it, lemme see if I can find the link
06:49:05 <nshepperd> was this a breaking api change with 'error' or what
06:49:18 <merijn> Here is the explanation: https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125659.html
06:49:30 <merijn> nshepperd: Seems I was wrong about the why, but right about the result :)
06:53:41 <nshepperd> ah, I see
06:53:46 <amx> ok thx
06:54:47 <nshepperd> imo maybe adding the HasCallstack constraint to would be nice though (now that we have that alias). it sort of signals that the thing is partial
06:58:53 <ryantm____> How do I get an account for the hackage matrix builder or how do I request that it build something? I want to run it against http://matrix.hackage.haskell.org/package/HDBC-mysql
07:00:33 <lpaste> purelazy pasted “Some type convertion is required I guess” at http://lpaste.net/350765
07:02:17 <purelazy> Is there a way to convert GHC.Word.Word32 to Int?
07:02:25 <glguy> fromIntegral
07:02:31 <purelazy> I am guessing that will fix my problem
07:02:39 <purelazy> OK glguy
07:02:56 <merijn> ryantm____: pinging hvr here is probably the best way to find out
07:03:30 <purelazy> glguy: Thanks. 'Twas as simple as that :)
07:04:30 <danilo2> Hello! Guys is it a bug or it jsut have to work like that - I've got a function `foo:: Foo b => (forall t. A t b)` and I run it providing smth of type `A t (Maybe t)`. It doesnt work, cause `Foo` gets `Maybe t` and `t` is out of scope. Hovewer `Foo` is eclared for every `Maybe` regardless the param
07:04:54 <danilo2> and if I run `foo @(Maybe t) (... :: A t (Maybe t))` it works. 
07:05:16 <danilo2> so the behavior is - if I pass explicit type argument, it works, If I leave it to be inferred, it doesnt 
07:05:31 <danilo2> ugh, thisi s niot the best minimal decription we can imagine :/
07:06:27 <ryantm____> hvr: can you run the hackage matrix biulder for HDBC-mysql http://matrix.hackage.haskell.org/package/HDBC-mysql please?
07:06:53 <ryantm____> hvr: or tell me what I need to do to do it myself.
07:07:03 <merijn> danilo2: FYI, foo as described there is not a function
07:11:57 <danilo2> merijn: of course, foo should be something like `foo:: forall b. Foo b => (forall t. A t b) -> Bar b` . The bahavior I'm facing is that If I provide an arg `A t X` it doesnt work uness I specify `X` using explicte notion, like `foo @X (... :: A t X), which shouldb e infered
07:12:54 <merijn> danilo2: I don't see how it could possibly infer 'b' if it depends on 't'
07:13:33 <merijn> danilo2: The type you seem to want doesn't make any sense in general
07:14:13 <merijn> You seem to want something like "foo :: (forall t b . Foo b => A t b) -> Bar b", but that doesn't work for obvious reasons
07:14:28 <danilo2> merijn: the example is just to simplified and seems broken. I have to think how to make real minimal example here
07:15:03 <danilo2> merijn: the code I've got work perfeclty fine, I only need to provide this @X explicitly which could be infered.
07:16:03 <merijn> danilo2: In the example you've provided there's no way it could be inferred
07:16:11 <Gurkenglas> For purposes of Literate Haskell it would be nice if you could put imports where they're relevant, not at the start.
07:16:15 <merijn> So, I disagree :)
07:18:04 <merijn> danilo2: What you've described has a 'b' variable that depends on the type scoped in a Rank2 type and then you want to use that same type outside of the Rank2 scope, unless there's more specific knowledge about either Foo, or 'b', I don't see how that could work
07:18:31 <merijn> I understand why the explicitly annotated one works, but you can't turn that into something that can be inferred
07:18:45 <danilo2> merijn: hmm, if there is a function with signature `foo:: forall b. Foo b => (forall t. A t b) -> Bar b` and I provide an arg with type (A <something> X) will `b` not be inferred to be X ?
07:19:36 <merijn> danilo2: Well, if that 'b' involves 't' then you're effectively negating the Rank2 type
07:19:58 <merijn> danilo2: The rank2 type says "foo picks the type of 't'"
07:20:24 <glguy> danilo2: This will probably be a more interesting discussion when you paste some code to the pastebin that other people can load and see
07:20:44 <merijn> danilo2: But since 'b' is determined by the *caller* of 'foo', if 'b' depends on 't' that means that you're preventing 'foo' from selecting 't' as the rank2 type suggests it does
07:20:45 <danilo2> merijn: not exactly, cause if there is `instance Foo (Maybe a)` - forall a, then it could be resolved before rankntype will be and I think this is the behavior I see here
07:20:58 <merijn> danilo2: GHC can't prove that
07:21:17 <merijn> danilo2: GHC has no way to verify that holds
07:22:38 <merijn> danilo2: if you had a Foo1 class (like Show1, etc) which was basically "instance Foo1 Maybe" and wrote "foo :: forall f . Foo1 f => (forall t . A t (f t)) -> Bar (f b)" then it might work
07:23:15 <merijn> danilo2: You're relying on 'f a' being an instance of Foo for all types of 'a', but the type system can't infer that
07:24:28 <Gurkenglas> I wonder if we could just make a new library that uses some sort of type hackery to provide IO' which accepts everything IO does but also can be used as MonadIO m => m, so we don't need to put liftIO everywhere
07:25:25 <merijn> Gurkenglas: Eh, isn't that just "MonadIO m =>" ? :)
07:25:35 <merijn> IO is an instance of MonadIO
07:25:38 <danilo2> merijn: that's interesting , cause if I provide `@(Maybe t)` explicitly GHC sees that this is the only instance and allows for such code. I understand your points and I known why it cannot prove it for itself, this behavior is just strange that in one way it allows it and in other it doesnt
07:26:23 <Gurkenglas> merijn, I mean that the missing feature is to embed IO in it without manually passing it through liftIO, like you can use a Lens as a Traversal.
07:26:27 <merijn> danilo2: That's because explicit type application is more powerful and more general than the inferred system GHC uses
07:27:05 <merijn> danilo2: They are *not* "different ways of writing the same thing"
07:27:23 <merijn> Explicit type application is strictly more powerfal than just inferring
07:29:55 <danilo2> merijn: I was sure it should be the same. Its is very interestign that we can do something different with type applications thank just passing types in parametrized datatypes and using tpye inferencer
08:02:48 <harrisonpartch>  /msg NickServ identify chi^mera
08:05:29 <MarcelineVQ> should probably change that if you like your nick :>
08:06:18 <JuanDaugherty> and everyplace else you used it, this is a publicly logged and prominent channel
08:06:36 <danger3rdeye> yes yes i dk why that happened
08:06:45 <ertes> https://freenode.net/kb/answer/sasl
08:06:48 <danger3rdeye> i am looking to see how to reset the pword
08:07:23 <ertes> you shouldn't use nickserv if you can avoid it
08:07:41 <danger3rdeye> ?
08:07:50 <ertes> danger3rdeye: see the link
08:08:12 <danger3rdeye> yes, how do i reset that compromised pword?
08:08:30 <ertes> for that you probably need nickserv =)
08:09:29 <ertes> danger3rdeye: first identify for the account, then use: /msg nickserv set password <newPassword>
08:15:20 <shapr> raichoo: do you have a haskell hat?
08:15:46 <raichoo> shapr: Nope, are there any?
08:15:55 <shapr> er, back on topic.. does anyone have a link to a single-file self-contained example of using hspec-megaparsec?
08:16:06 <shapr> raichoo: no, I just figured if anyone would have one, it would be you.
08:16:16 <raichoo> shapr: :D
08:16:39 <shapr> I am wearing a Haskell hoodie I got from edwardk
08:17:01 <raichoo> shapr: Nice :)
08:19:00 <shapr> So, any single file examples of hspec testing for megaparsec?
08:19:24 <harrison_partch> john reppy and i were talking about the possible use of Manticore, the multicore ML he is working on, for my voxel world realtime raytracer
08:19:56 <shapr> harrison_partch: is it up on github?
08:20:04 <harrison_partch> which?
08:20:37 <harrison_partch> Manticore? There is a repo -- I tried to build from it last week
08:20:42 <harrison_partch> wait
08:20:50 <shapr> ah, I found it http://manticore.cs.uchicago.edu/
08:21:06 <harrison_partch> anyhow, i am making a point here
08:21:28 <shapr> harrison_partch: oh, what is your point? I must have missed it.
08:21:58 <harrison_partch> he said "manticore will NEVER use compilation of little fragments of code which are then used in the running system"
08:22:26 <harrison_partch> i realized: of course, because whole-program optimization!
08:22:42 <harrison_partch> prolly the same caveat applies to haskell
08:23:49 <OutlawStar> Hello all, would we expect the following result when subtracting these doubles: (117.000 :: Double) - (116.92 :: Double) = 7.99999999999983e-2
08:23:51 <harrison_partch> however, i have no doubt at all that i could make a sierpinski cube flythrough demo in haskell
08:23:54 <OutlawStar> i would think that should be 0.8
08:24:01 <OutlawStar> i would think that should be 0.08*
08:24:17 <hpc> OutlawStar: welcome to IEEE floating point
08:24:26 <kuribas> > (117.000 :: Double) - (116.92 :: Double)
08:24:31 <lambdabot>  7.99999999999983e-2
08:24:40 <OutlawStar> yeah, that weird..
08:24:45 <hpc> > (117 - 116.92) :: Float
08:24:48 <lambdabot>  8.000183e-2
08:25:01 <Myrl-saki> Sounds correct to me.
08:25:05 <kuribas> OutlawStar: not weird, that's nearly 0.08
08:25:09 <Myrl-saki> > (117 - 116.92 :: Double)
08:25:11 <lambdabot>  7.99999999999983e-2
08:25:16 <Myrl-saki> > (117 - 116.92) :: Double
08:25:17 <OutlawStar> thats a clean subtraction though
08:25:19 <lambdabot>  7.99999999999983e-2
08:25:25 <Myrl-saki> > 0.08
08:25:27 <hpc> IEEE floats can only exactly represent fractions where the bottom is entirely powers of two
08:25:28 <lambdabot>  8.0e-2
08:25:29 <kuribas> OutlawStar: Double's representation is in binary, not decimal.
08:25:33 <Myrl-saki> Hmmm. Interesting.
08:25:37 <Myrl-saki> > 0.08 :: Double
08:25:39 <hpc> er, is the sum of powers of two
08:25:40 <lambdabot>  8.0e-2
08:25:50 <Myrl-saki> I have no idea how FP printing works at all.
08:25:54 <shapr> IEEE 754 floating point numbers, better than what came before, but still not great.
08:26:17 <OutlawStar> ok, well thanks all. Just wanted to confirm that was expected behavoir
08:26:19 <kuribas> > 116.92 :: Double
08:26:21 <lambdabot>  116.92
08:26:26 <Myrl-saki> shapr: IMO, they're pretty good.
08:26:29 <Myrl-saki> But that's just me.
08:26:47 <OutlawStar> still, that could eventually throw off calculations..
08:27:03 <Myrl-saki> OutlawStar: Err.
08:27:11 <Myrl-saki> :t repeat
08:27:11 <shapr> Myrl-saki: In my opinion, too much accidental difficulty involved in handling floating point numbers.
08:27:12 <lambdabot> a -> [a]
08:27:17 <kuribas> OutlawStar: if you need exact calculations, use Integer.
08:27:19 <Myrl-saki> > sum . replicate 10 $ 0.1
08:27:22 <lambdabot>  0.9999999999999999
08:27:23 <Myrl-saki> Just saying.
08:28:00 <kuribas> > (11700 - 11692 ) / 100
08:28:03 <lambdabot>  8.0e-2
08:28:11 <OutlawStar> kuribas: I might, currently I am dealing with currency though, so I might be ok if the error is so small. I will be rounding
08:28:12 <Myrl-saki> (The infamous `for (float i = 0; i != 1; i += 0.1);`
08:28:20 <Myrl-saki> OutlawStar: NO
08:28:20 <kuribas> > (11700 - 11692 ) `quot` 100
08:28:23 <lambdabot>  0
08:28:30 <Myrl-saki> OutlawStar: Don't ever use floating point  for currency.
08:28:41 <kuribas> OutlawStar: define your own type, and overload Num
08:28:42 <zygentoma> OutlawStar: especially for currency, use integer! never round!
08:28:53 <OutlawStar> ok will do
08:28:55 <shapr> What about Ratio?
08:28:56 <Myrl-saki> That's like currency 101.
08:29:03 <Myrl-saki> Ratio is probably the best choice.
08:29:49 <shapr> Has anyone used Hspec with Megaparsec?
08:30:10 <kuribas> OutlawStar: yeah, better use Ratio
08:30:22 <shapr> Also, finger trees in Data.Sequence are marvelous!
08:30:27 <OutlawStar> kuribas: will do thanks!
08:31:40 <libscott> shapr: what are you using them for?
08:32:33 <shapr> libscott: I used Data.Sequence to solve http://adventofcode.com/2016/day/16
08:33:14 <shapr> libscott: here's my solution: https://github.com/shapr/adventofcode2016/blob/master/src/Sixteen/Main.hs
08:33:51 <shapr> Mind you, it took me an extra hour of debugging because I didn't have tests, so I want to fix that for the next puzzle.
08:35:59 <shapr> libscott: have you used Data.Sequence to good advantage?
08:38:18 <shapr> Some of my solutions to AoC have been pretty sketchy, I used Data.Maybe.maybe for control flow in day 23
08:45:52 <Guest59218> hey if any github user could help me out by starring the repo: https://github.com/bergmark/feed that would be appreciated. It currently needs two more stars to be indexed by Github search :-)
08:46:57 <fizbin> Is anyone else using snap-core and snap-server without the rest of snap (i.e., no snaplets or Handler monad)? If so, is it possible to wrap a "Snap ()" action so that you can run stuff both before and after that action, no matter how it terminates? (and access the state so that you record the HTTP return status)
08:46:57 <shapr> Guest59218: looks like you forked and updated feed?
08:47:33 <Guest59218> Guest59218: it's not me but yeah it has a new maintainer
08:47:52 <Guest59218> Guest59218: forks need more stars than the original repo to be indexed by Github search according to their docs
08:48:08 <Guest59218> shapr: ehm, that was meant to you
08:48:21 <shapr> ah, neato
08:48:34 <odds> Wow, #haskell is way more active than #scala. Why?
08:48:41 <fizbin> The only thing I could come up with involves reaching deep into the Snap.Internal.Core package, which feels dangerous.
08:48:56 <odds> -- someone learning FP for the first time from Odersky's Coursera MOOC.
08:49:52 <shapr> odds: I dunno, maybe because #haskell has been active for 15 years or so?
08:50:10 <odds> That's probably a good bet shapr. Wow, didn't know that!
08:51:00 <shapr> odds: also, if you're vaguely proficient with Haskell, try to solve Advent of Code puzzles and compare with many other solutions
08:51:33 <odds> I'll keep that in mind shapr, thx. Once I finish the Scala course I'll consider learning a bit of Haskell to do that.
08:52:03 <shapr> odds: sure, show up sometime :-)
08:53:34 <odds> shapr: Do many people use Haskell for writing APIs and web dev?
08:53:54 <shapr> odds: yes, many
08:54:12 <odds> Cool. That's what got me started on FP: wanting to write my first REST API.
08:54:29 <agent_sm1th> Using Ratio for currency, You have 1200 euros and 38 cents and 2839029/982451653th of a cent on your bank account.
08:54:35 <odds> I'm sure I could've done it in Python or Java, which I'm already comfortable with, but *meh*.
08:55:01 <shapr> odds: you can do REST APIs in any language, but the FP approach leads to some particularly nifty tricks
08:55:06 <shapr> odds: yeah, I agree
08:55:35 <odds> Great, I didn't make a completely idiotic choice then it seems.
08:55:41 <odds> Maybe I should've started with Haskell though. ;)
08:56:33 <shapr> odds: I'm obviously a fan of Haskell, but you should figure out what fits your head. Try several FP languages and see what you enjoy?
08:56:36 <fizbin> odds: In fact, I keep asking a question here about one of the most popular Haskell HTTP frameworks.
08:56:48 <fizbin> (and getting ignored)
08:57:06 <shapr> fizbin: I don't use snap :-(
08:57:11 <odds> Ah, too bad. I'm interested in that question as well.. And ultimately a larger comparison between Scala HTTP and Haskell HTTP.
08:57:25 <humanoyd> Is there a better way to do LIKE pattern matching in postgresql-simple than the following? "SELECT * FROM foo WHERE bar LIKE ?" (Only ("%" <> baz <> "%"))
08:57:34 <odds> shapr: Scala has been fairly easy considering I learned Java in university (which is where I still study).
08:57:36 <humanoyd> fizbin: for snap there is also #snapframework
08:57:36 <shapr> I've most recently used servant and before that scotty.
08:57:52 <fizbin> shapr: Yeah, I suspect those who do just go ahead and drink all the snap kool-aid and go for snaplets.
08:58:25 <Guest59218> fizbin: may I ask what is the benefit of using snap instead of say WAI for serving when not using snaplets (sorry don't know the answer to your question)
08:58:46 <shapr> odds: I jumped from Python to Haskell. That nearly broke my brain, but now I can think in new directions.
08:58:53 <lpaste> purelazy pasted “Issue with DuplicateRecordFields” at http://lpaste.net/350770
08:59:07 <purelazy> Help required with DuplicateRecordFields
08:59:17 <how> class Monad m => MonadFree f m | m -> f where
08:59:25 <how> What does the m -> f mean
08:59:56 <Tuplanolla> Say, does anyone know if the pie problem concerns Debian testing (stretch)?
09:00:19 <fizbin> Guest59218: Not sure. Mostly? I found snap when I was looking for a minimal http front-end to slap on my formerly command-line-only tool, and didn't find wai at the time.
09:00:31 <odds> shapr: +1, it's good to break the brain every once in awhile. :)
09:00:43 <Tuplanolla> It's a `FunctionalDependencies` thing, how: the type `m` determines `f`.
09:01:17 <Guest59218> fizbin: I did see chrisdone using snap like that in tryhaskell, you might find something from inspecting his code on github
09:01:23 <shapr> Tuplanolla: I think the latest stack has a nopie GHC
09:02:58 <Tuplanolla> Good. Let's see what happens, shapr.
09:02:59 <MarcelineVQ> Tuplanolla: no clue :> just in case you're using stack, these are the most up-to-date methods of dealing with pie issues and stack atm https://github.com/commercialhaskell/stack/issues/2712
09:03:19 <how> Tuplanolla: thanks, now i can google about it
09:07:43 <Tuplanolla> It says `nopie` in the filename, so I'm hopeful. Thanks.
09:13:35 <haskell393> hi, what's the best place to know about the differences between 2 Zipper libraries : the generic Zipper, and the lens Zipper ?
09:13:45 <MarcelineVQ> purelazy: it could be best to not use DuplicateRecordFields in the first place and just import qualified instead, since you're often going to have to annotate or qualify everything anyway. more info here https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields  be sure to give all your functions explicit type signatures to help DuplicateRecordFields as much as possible, if you decide to stick with it
09:14:30 <haskell393> they are both type driven, but I am not sure what are the saillant differences
09:16:23 <shapr> haskell393: try them both, write up a blog post?
09:16:43 <shapr> haskell393: because I don't know, but I'd like to know?
09:16:58 <shapr> Tuplanolla: works for you?
09:17:14 <Tuplanolla> Nope, shapr. I got an "Error encountered while unpacking GHC".
09:17:18 <shapr> :-(
09:17:18 <haskell393> sharp : hmm... my knowledge is limited though
09:17:24 <purelazy> MarcelineVQ: I am using a library written by someone else. I am not sure if they have correctly exported the fields - as it appears from that web page, duplicate fields need special attention
09:17:47 <Tuplanolla> I don't know what to do with this.
09:18:28 <shapr> Tuplanolla: I'm using lts-7.9 on ubuntu 16.04, but I'm not sure how to tell if it's nopie
09:18:43 <shapr> Tuplanolla: which resolver did you configure that failed to unpack?
09:18:57 <haskell393> I guess lens is 'church based' and pure, look for 'categorical' instances available, while the generic one is just for the one level of the top type
09:19:20 <shapr> haskell393: you clearly know more than I do
09:19:28 <Tuplanolla> This seems to be `lts-7.14`, shapr.
09:19:30 <haskell393> lens can go on as long as it finds the correct instances, and is not tied to a particular type
09:19:34 <Tuplanolla> It's the default.
09:19:43 <purelazy> MarcelineVQ: Also, you can see from the code "vkApiVersion (properties :: VkPhysicalDeviceProperties)", I thought I would have disambiguated vkApiVersion
09:20:34 <purelazy> MarcelineVQ: Oh well :)
09:21:45 <shapr> Tuplanolla: try an earlier version if that GHC fails to unpack? Maybe lts-7.10 or lts-7.11 ?
09:21:59 <Tuplanolla> Maybe I'm running out of disk space, shapr.
09:22:19 <Tuplanolla> Just how much do I need?
09:22:46 <shapr> I don't know, I recently spent too much money on SSDs for my laptop.
09:23:05 * shapr checks du in ~/.stack
09:24:31 <shapr> Tuplanolla: I have 562M used in ~/.stack/snapshots/x86_64-linux/lts-7.9
09:24:34 <Tuplanolla> Well, that explained it: "bash: cannot create temp file for here-document" and crashed.
09:24:57 <shapr> so, running out of disk space?
09:25:13 <Tuplanolla> This virtual machine only goes up to 4 GB.
09:25:46 <MarcelineVQ> purelazy: That's rough that it's from a library so you have to deal with it, I'm not sure what would help :(
09:26:56 <purelazy> MarcelineVQ: The library is in it's infancy - I guess I'm kinda testing it :)
09:29:08 <quchen> bollu: pong
09:30:05 <Zemyla> Am I the only one who thinks a variant of the [Response] -> [Request] model is better for describing IO than the "state of the world" model?
09:30:49 <quchen> There is no »state of the world« model, that’s an implementation detail GHC chooses behind the curtain to model the semantics of IO.
09:30:58 <shapr> Zemyla: wasn't the original continuation based IO model something like that?
09:31:05 <quchen> There is never a variable of type »state of the world«.
09:32:15 <Zemyla> quchen: Yes, but it's still often used to describe IO, even in non-Haskell monad tutorials.
09:33:12 <Zemyla> shapr: Well, there are a couple of big problems with the type [Response] -> [Request]. For one thing, it's easy to get desynced. For another, you can't really compose two IO actions of that type.
09:33:15 <bollu> quchen: hey
09:33:21 <maerwald> that's fine for a first intuition, but can be misleading when one gets to the details... because then you have to explain evaluation vs execution, RTS and whatnot
09:33:26 <bollu> quchen: so, I'm going through the book "implementing functional languages, a tutorial"
09:33:52 <bollu> and I'm implementing the graph reduction machine first:https://github.com/bollu/graph-reuduction
09:34:04 <maerwald> (the RealWorld metaphor I mean)
09:34:09 <bollu> quchen: I would like to explain how it works, since I think STGi is a little too much to handle at first brush
09:34:21 <bollu> quchen: you seem to have experience teaching this sort of things
09:34:30 <bollu> quchen: so do you have any guide as to, well, how to make this nice-to-learn-from?
09:34:56 <bollu> quchen: thanks for STGi BTW :) the codebase is very pleasant to read and learn from
09:35:08 <quchen> bollu: The original STG paper is an excellent introduction into the topic! »Impmenting purely functional languages on stock hardware« it’s called, I believe. It’s from 1992 by SPJ.
09:35:20 <quchen> bollu: Thanks! That’s what I was hoping to achieve :-)
09:35:24 <Zemyla> A better model would probably be one where you make a Request, and then ask for a Response directly, such as data Main = Done | Do Request (Response -> Main).
09:35:30 <bollu> quchen: yep, I was reading from that
09:35:33 <dmwit> quchen: Aren't those quotes usually used in the other order?
09:35:37 <quchen> bollu: You can read through the STGi Prelude to learn about how to implement many standard Haskell Prelude functions in STG
09:35:38 <bollu> quchen: But I felt that going this way made more sense og me
09:35:43 <bollu> quchen: right
09:35:54 <bollu> quchen: I was asking more about the implementation of the STGi playground that you have
09:36:17 <bollu> quchen: how many LoC roughly was the environment? and if you had to redesign it, would you do things differently?
09:36:27 <quchen> dmwit: Depends on the language. Some languages point them outward (« French » adds spacings), some inward (»German«), and others I don’t know about. :-)
09:36:40 <quchen> I don’t know how to type a half-space :-/
09:37:49 <quchen> foo bar <- does this work? Probably not in monospaced fonts.
09:37:58 <quchen> bollu: Anyway, back to the STG! :-)
09:38:27 <quchen> bollu: What specifically do you want to know about?
09:38:38 <quchen> I read the paper and wrote the STGi, that’s the short version of the story ;-)
09:38:41 <bollu> quchen: :)
09:38:44 <bollu> quchen: right
09:38:58 <bollu> quchen: I'm working through the book, as I said before. Where he gradually "builds up STG" so to speak
09:39:00 <bollu> so, well
09:39:07 <quchen> There’s also the follow-up paper »making a fast curry«, but that’s much more technical. The 1992 paper is also technical, but you can read it as prose as well
09:39:19 <quchen> bollu: Oh, you mean SPJ’s first book
09:39:24 <quchen> His only book, I guess
09:39:34 <quchen> I did not read that one, but I think it predates the STG by a couple of years
09:39:45 <bollu> quchen: yep, it does
09:39:56 <quchen> bollu: What do you mean by »LoC of environment«?
09:40:27 <Psychiatrist> Hey guys. Since my functions don't have state am I able to somehow give my function its output so it would generate me the input based on the given output ? 
09:41:36 <Taneb> Psychiatrist, no, that is not something you can do
09:41:48 <Tuplanolla> This GHC takes way over 1 GB for me, shapr.
09:41:50 <Taneb> For example, what input gives the function "f x = 1" the output 2
09:41:54 <bollu> quchen: the pretty printer, and the navigation through the state
09:42:05 <quchen> Psychiatrist: Functions can have state, it’s just explicit! For example, you can implement length as »length = length' 0; length' n [] = n; length' n (_:xs) = length (n+1) xs«, where the »n« is a form of state as you iterate over the list.
09:42:33 <quchen> bollu: Oh, you mean everything that’s not strictly part of the STG, as in »the scaffolding«? That took up most of the time, actually.
09:42:37 <bollu> quchen: yes
09:42:40 <bollu> quchen: yeah, I thought so
09:42:50 <bollu> quchen: so, like, if you had to redesign the scaffolding lets say
09:42:51 <shapr> Tuplanolla: sorry, I thought it would match :-(
09:42:56 <bollu> quchen: would you do it differently?
09:43:04 <bollu> quchen: I'm looking for a clean way to implementing the scaffolding
09:43:15 <quchen> bollu: Look at the testsuite for the parser: it compares parses to handwritten syntax trees. Now imagine you didn’t have the parser – as was the case for some time – it’s basically impossible to work with this kind of program
09:43:49 <MarcelineVQ> purelazy: man idk, this is whack stuff  even something like  (vkApiVersion :: Char -> Int) still says it's ambiguous, when nothing like that exists at all
09:43:52 <quchen> bollu: Writing out the identity function is so awful in ADT notation that I just took a detour and wrote a parser. The good part is that I learned about Trifecta in the process. :-)
09:44:00 <Psychiatrist> Taneb, quchen Thanks! Yeah, that makes sense a lot of sense actually.
09:44:14 <quchen> bollu: Prettyprinting is quite a lot of fun to be honest, I really like the wl-pprint libraries
09:44:38 <bollu> quchen: I'm doing it in rust, unfortunately :)
09:44:44 <quchen> (So much that I rewrote them, hoping to release the rewrite as a major version bump in the next couple of … well, whenever the maintainer responds)
09:44:50 <bollu> quchen: so I may have to rebuild a lot of the insfastructure
09:44:55 <bollu> quchen: but that's part of the fun, I think
09:45:06 <bollu> quchen: yeah, right now I'm enoding S and K by hand and it's quite terrible
09:45:12 <quchen> bollu: Oh. Well, you don’t need the prettyprinter as much as you need the parser.
09:45:31 <bollu> quchen: I'm thinking of hand rolling a pratt parser, and maybe publishing the library if it comes out nicely :)
09:45:36 <quchen> My first workable version was basically an execution engine and the parser.
09:45:41 <bollu> quchen: parser combinators in rust aren't as nice as Haskell :(
09:46:06 <quchen> Prettyprinter helps for testing (displaying counterexamples), and garbage collection can be added as an afterthought when your heaps start becoming too large to read in bigger programs.
09:46:12 <alviprofluvium> I'm stuck in a HPFFP exercise. I need to QuickCheck some property for a datatype that its essentially a function. But I don't know how to make an Arbitrary instance for it. I just can't understand coarbitrary.
09:46:15 <hackrilege> Graph reduction in Haskell bollu? I can't read Rust
09:46:34 <quchen> Psychiatrist: I forgot a »'« at the end of the last »length« in my code above, woops
09:46:51 <quchen> Psychiatrist: Should be »length' (n+1) xs« (type system would have caught this though)
09:46:55 <agocorona> join transient
09:47:30 <bollu> hackrilege: yes, I'm doing it in rust 
09:47:39 <quchen> bollu: If you want to step through the STG execution, then a prettyprinter is very useful
09:47:41 <bollu> hackrilege: right now it's dumb, it does template instantiation
09:47:41 <purelazy> MarcelineVQ: On that webpage, it states "When DuplicateRecordFields is enabled, an ambiguous field must be exported as part of its datatype,  ...". It appears that no such special export was done.
09:47:42 <bollu> quchen: yes
09:47:44 <Psychiatrist> quchen: No worries, I got the example. I just remembered from Prolog that I was able to do that on some occasions, thought that maybe it's a possibility here as well.
09:47:54 <quchen> bollu: But having a parser that’s inverse to the prettyprinter is pure luxury
09:47:56 <bollu> quchen: right now I'm writing out raw heap addresses, which is clearly not pretty :)
09:48:00 <bollu> quchen: heh, fair
09:48:06 <quchen> bollu: Very useful for testing the parser though!
09:48:07 <dmwit> alviprofluvium: needs more "?"s ;-)
09:48:19 <dmwit> alviprofluvium: probably also needs more code
09:48:21 <dmwit> ?lpaste
09:48:21 <lambdabot> Haskell pastebin: http://lpaste.net/
09:48:30 <quchen> bollu: I had a parser bug where I allowed »let« as a variable name, and QuickCheck caught that one after a couple of thousand tries
09:48:33 <OutlawStar> anyone have a recommendation on storing currency with ratio? I was just going to store for example $116.23 as: (round $ 116.23 * 10^9) % (10^9) since I want 9 digits of precision on the right
09:48:35 <alviprofluvium> ?lpaste
09:48:35 <lambdabot> Haskell pastebin: http://lpaste.net/
09:48:55 <quchen> OutlawStar: How about Fixed, a fixed-size number representation?
09:48:56 <dmwit> OutlawStar: Yes, use one of the fixed-point types available on Hackage.
09:49:05 <bollu> quchen: so, for the scaffolding design
09:49:09 <bollu> quchen: do you have any "new" ideas
09:49:10 <quchen> OutlawStar: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Fixed.html
09:49:12 <OutlawStar> dwit: is that a different package
09:49:14 <bollu> that you wanted to explore but couldn't?
09:49:21 <Tuplanolla> Wait, does Stack build GHC from source?
09:49:29 <OutlawStar> quchen: thx
09:49:34 <quchen> Tuplanolla: No, it downloads a binary
09:50:01 <quchen> bollu: Not really, no. I think the architecture works quite well
09:50:23 <lpaste> MarcelineVQ annotated “Issue with DuplicateRecordFields” with “purelazy best I can do” at http://lpaste.net/350770#a350773
09:50:35 <bollu> quchen: hm, OK :)
09:50:49 <kadoban> Tuplanolla: It uses something like these, I believe: https://www.haskell.org/ghc/download_ghc_7_10_3 which take a bit of building work on the target machine (for reasons I never looked into), but it's not from source, that's a more involved and long build.
09:50:57 <quchen> bollu: There is some stuff that I did not implement, such as static code analysis (reporting unused variables, for exampke), but that would fit nicely in the current model
09:50:58 <janosp> hey, a question
09:51:26 <Tuplanolla> It takes too much space to work on a tiny virtual machine, so I need to come up with something else now, kadoban.
09:51:37 <janosp> If I wrote a custom data type in a haskell project and write an instance of Arbitrary in order to use QuickCheck, where should I put the instance?
09:51:41 <janosp> Into the Test folder?
09:51:44 <janosp> In Stack?
09:51:56 <janosp> or rather in the file where I create the data type?
09:52:07 <bollu> quchen: cool, thanks for the chat
09:52:24 <quchen> bollu: The actual STG execution engine is fairly simple to implement, actually!
09:52:34 <bollu> quchen: I see
09:52:45 <quchen> bollu: Some rules are tricky in the sense that one can mix up variables easily, but there’s nothing crazily complicated in them
09:52:48 <bollu> quchen: I wish to work through the book first, though. To have more "grounding" I guess is the word
09:52:58 <Zemyla> Okay, I remember there being a thing on /r/Haskell which discussed, in addition to sum and product types, subtraction and division types, where subtraction type X - Y is "X, but it can't be Y", and division types X / Y were "X, but two Xs are the same if they're both Y" or something.
09:53:05 <quchen> bollu: Give the 1992 paper a try! I cannot recommend it enough
09:53:06 <bollu> quchen: but I do plan on implemtning STG at the end of a month / two
09:53:10 <bollu> quchen: will do :)
09:53:17 <kadoban> Tuplanolla: That's unfortunate. Maybe you can make a temporary VM with more RAM, but otherwise identical and do it there and copy over the files? Though without a decent amount of RAM you'll probably find GHC not very usable in my experience.
09:53:38 <Tuplanolla> Not memory, but storage, kadoban.
09:54:05 <kadoban> Oh, then I dunno. GHC itself takes quite a bit, I don't think it's something you'll be able to get around.
09:55:00 <quchen> bollu: I think the »let« rule was the trickiest, in case you need a warning. It’s #3 in the STGi paper. (»letrec«, to be specific, because one has error reporting and recursion interleaved)
09:55:14 <quchen> It’s also the ugliest part of the STGi codebase :-)
09:55:15 <lpaste> alviprofluvium pasted “Combine arbitrary instance” at http://lpaste.net/350774
09:55:54 <alviprofluvium> I dont know how to implement de Arbitrary instance of that datatype.
09:56:00 <alviprofluvium> how can i do it?
09:56:24 <purelazy> MarcelineVQ: That compiles now. I can see I need to learn more about importing stuff. Thank you very much. ;o)
09:56:48 <michalrus> Hey, what do you think of Design by Contract understood as runtime asserts in code, failing of which results in the exit() syscall? *.*
09:57:10 <Tuplanolla> I guess I need to redo this whole installation. How much space do I need for all the Haskell stuff?
09:57:11 <dmwit> alviprofluvium: `Combine <$> arbitrary`?
09:58:02 <alviprofluvium> i would look into that. (I don't know yet what <$> is)
09:58:03 <kadoban> Tuplanolla: I currently have 5 GB just in ~/.stack/
09:58:20 <dmwit> alviprofluvium: `fmap Combine arbitrary` might be a spelling more familiar to you
09:58:22 <Tuplanolla> We're going with 8 GB then.
09:58:42 <dmwit> alviprofluvium: or `do { f <- arbitrary; return f }`, perhaps
09:58:46 <dmwit> oops
09:58:58 <dmwit> `do { f <- arbitrary; return (Combine f) }`, I mean
09:59:06 <kadoban> Tuplanolla: In most VM software, isn't there a way to make the hard drive space unconstrained, but not have it use up your whole drive unless the VM needs it?
09:59:08 <dmwit> alviprofluvium: These are all different ways of saying the same thing.
09:59:22 <Tuplanolla> I don't know how to do that without starting over, kadoban.
09:59:39 <kadoban> Ya me either probably.
10:00:42 <alviprofluvium> Oh, thanks. It worked.
10:01:06 <dmwit> alviprofluvium: But why have the new type at all? Functions already implement the two classes you've implemented there.
10:01:18 <quchen> Tuplanolla: 8 GiB should be enough for a working Stack installation. If you’re planning to use multiple GHC versions alongside each other then maybe more. My Stack folder is around 10 GiB right now, and I think I have a snapshot of every major LTS release installed.
10:01:41 <quchen> Meh, 15 GiB.
10:01:47 <Gurkenglas> alviprofluvium, (a -> b) already has those Semigroup and Arbitrary instances, so you could just get rid of Combine
10:01:54 <dfeuer> http://lpaste.net/851434458492960768  This crashes GHC 8.0.1. Does anyone here have a copy of GHC HEAD readily available to test it?
10:01:57 <dmwit> Gurkenglas: too slow =)
10:02:03 <alviprofluvium> It's an exercise about implementing Semigroup, Monoid and Arbitrary instances. To practice using QuickCheck.
10:02:25 <dmwit> alviprofluvium: Oh, if it's an exercise, then `fmap Combine arbitrary` and friends are totally cheating.
10:02:38 <dfeuer> If not, I can boot up my other computer, or install the GHC source tree here (which I'll need to do shortly anyway)
10:03:11 <janosp> hey, since you are taking about Stack and Arbitrary
10:03:12 <dfeuer> dmwit: I don't think that's cheating at all!
10:03:16 <janosp> Where should I put the instance?
10:03:19 <Gurkenglas> When do you write custom inner-view Arbitrary instances while *using* QuickCheck?
10:03:24 <Tuplanolla> I'm building this virtual machine to allow students to use GHC, quchen, so I only need one version. If only the system administration department wasn't incompetent when it comes to installing software...
10:03:24 <janosp> into test/ or into src/
10:03:24 <janosp> ?
10:03:27 <alviprofluvium> I think. The exercices talks about using coarbitrary. But I have tried looking for information about using it for 2 days and can't get it to work.
10:03:27 <Eduard_Munteanu> Tuplanolla, you might find containers easier to manage and work with, because you can share the underlying filesystem.
10:03:35 <dfeuer> dmwit: I think using the Functor and Applicative instances of Arbitrary is *usually* the right way to write new instances.
10:03:44 <dfeuer> Er...
10:03:49 <dfeuer> Not of Arbitrary.
10:03:58 <dfeuer> Of whatever the type is called.
10:03:59 <dfeuer> Gen.
10:04:10 <dmwit> dfeuer: The answer I posted before was `fmap NewtypeConstructor arbitrary`. That is cheating if the exercise is to figure out how to write the `Arbitrary` instance yourself.
10:04:14 <Eduard_Munteanu> Tuplanolla, there's a docker thingy for GHC, if the machines run Linux.
10:04:29 <dfeuer> dmwit: I consider that the correct solution!
10:04:35 <dfeuer> The *best* solution!
10:04:42 <Gurkenglas> Then why doesn't the exercise say to implement an Arbitrary instance for functions?
10:04:52 <Tuplanolla> They most certainly don't, Eduard_Munteanu. They can't even get Docker working.
10:05:03 <quchen> o/ Eduard_Munteanu!
10:05:05 <dmwit> dfeuer: Then I don't think you understand pedagogy very well.
10:05:08 <quchen> Long time no see.
10:05:18 <Eduard_Munteanu> \o
10:06:14 <janosp> dfeuer, where would you suggest to put instances of Arbitrary in a Stack project? Into the test folder where all the quickCheck tests are, or into the src/ folder, where the data type is defined?
10:06:27 <hackrilege> janosp, I guess it depends if you use the instance anywhere except in your test folder...
10:06:37 <dfeuer> dmwit: I think I do! The job of the pedagogue is to construct exercises with great care. Write an Arbitrary instance for the following type: data Foo = Foo Int Bool | Bar String
10:06:49 <dmwit> Gurkenglas: Because there is already an instance for functions, and it would be annoying to have to write a copy of QuickCheck that didn't have that instance just so that people could do this exercise.
10:07:00 <hackrilege> If you use it in your main routine then it should go in /src
10:07:23 <janosp> is Arbitrary used for anything else than QuickCheck?
10:07:27 <dmwit> dfeuer: That exercise does not involve CoArbitrary, so it is not as "good" for understanding CoArbitrary.
10:07:40 <dmwit> The natural application of CoArbitrary is functions.
10:07:47 <dmwit> So it is natural to set functions as the exercise.
10:07:55 <hackrilege> janosp, it can be used like unfold
10:08:01 <dfeuer> janosp: if you include the instance in the library proper, then you incur a QuickCheck dependency. That's a bit expensive.
10:08:04 <dmwit> alviprofluvium: I'm not sure what hints I can give that wouldn't just give away the answer.
10:08:15 <Gurkenglas> The natural applications of CoArbitrary are Contravariant functors, no?
10:08:41 <janosp> hackrilege, I have to look up how to use unfold
10:08:41 <dfeuer> dmwit: okay, so I chose a bad example. Sorry. But my point is that the teacher should specify an exercise that *requires* a non-trivial solution, if they want a non-trivial solution.
10:08:49 <quchen> »Things that have arbitrary inputs« = CoArbitrary’s domain.
10:08:50 <janosp> dfeuer, that makes sense. Thanks
10:09:39 <dmwit> dfeuer: Functions require a non-trivial solution. It is easy to say "don't use the existing function instance" in the exercise text, and even easier to say at the beginning of the class "it is your job to do these exercises, not trivialize them".
10:09:41 <hackrilege> janosp, it's like repeat except you provide a way to choose between the constructors of the data type.
10:09:47 <dfeuer> janosp: orphan instances of Arbitary and Coarbitrary in test suites aren't the prettiest things in the world, but they're often used because alternatives are lousy.
10:10:23 <Gurkenglas> Hmm are there contralenslikes like (a -> f b) -> Map b c -> f (Map a c)?
10:10:24 <dmwit> dfeuer: And as a student it is even easier to say to myself, "I will not trivialize these exercises, even though the teacher didn't explicitly say not to.".
10:10:42 <dmwit> Because how will you learn anything interesting if you avoid the interesting thinking?
10:11:01 <dfeuer> dmwit: we may have to agree to disagree. I think a lot of functional programming is about figuring out what can be trivialized how.
10:11:08 <janosp> hackrilege, I see thanks!
10:11:17 <dmwit> dfeuer: Yes. But learning functional programming is a different story. =)
10:11:58 <humanoyd> Is there a better way to do LIKE pattern matching in postgresql-simple than the following? "SELECT * FROM foo WHERE bar LIKE ?" (Only ("%" <> baz <> "%"))
10:11:58 <Gurkenglas> Oh, Map isn't a profunctor because you'd have to apply the (a -> b) to the whole domain of a. But you get the idea
10:12:23 <dfeuer> dmwit: I see the fundamental Functor/Applicative/Monad/Traversable abstractions as ever-available. Make the students write their own instances; don't make them avoid the classes. But you disagree, and that's fine.
10:12:24 * quchen wonders why there are no predefined functions »arbitraryN (n-ary f) = f <$> arbitrary <*> arbitrary <*> …« in QuickCheck.
10:12:28 <monochrom> The two of you are arguing over what the teacher has said and has not said. Based on obviously incomplete, inaccurate, inconsistent information from the student rather than from the teacher.
10:12:59 <monochrom> (obvious to me anyway.)
10:13:14 <quchen> The three of you are arguing over what … ;-)
10:13:40 <dfeuer> quchen: another issue is that there doesn't seem to be a really pleasant way to deal with Fun when multiple arguments are involved.
10:13:45 <dmwit> dfeuer: But the exercise is exactly to write his own instance...
10:13:59 <quchen> dfeuer: And showable functions are awful to work with!
10:14:13 <MarcelineVQ> purelazy: np, allthough you should't be forced to do this :(
10:15:06 <dmwit> alviprofluvium: You may like to browse https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen-Unsafe.html
10:15:23 <dfeuer> dmwit: I think the best fix is probably to require a different probability distribution than the underlying type, if the goal is to make students do things approximately by hand.
10:15:34 <monochrom> But I'm interested in how best to phrase the exercise "implement []'s map, but don't just call map from Prelude, in fact don't even sneak peak Prelude's source code"
10:15:46 <dfeuer> quchen: Fun fixes that pretty well, no?
10:16:10 <dmwit> monochrom: My preferred way would indeed to say some variant of "and don't trivialize it", and trust my students to understand what I mean.
10:16:27 <dmwit> monochrom: On the off chance that if you treat people like adults, they will act like adults. =)
10:16:30 <monochrom> (and in fact there is also an implicit requirement of not calling foldr from Prelude either. and not scanr and scanl. etc etc. How do I say all that? what else should I say?)
10:16:33 <dfeuer> monochrom: you can't stop someone peeking at the source code (except in a proctored exam), but you can tell them to implement Functor for  data List a = Nil | Cons a
10:16:35 <dmwit> Deal with it afterwards if this turns out not to work.
10:16:41 <quchen> dfeuer: I only tried using it a couple of times a year or so ago, but I wasn’t very happy with it. I don’t remember the specific problems though. I just remember that I did not try to do anything fancy and eventually gave up.
10:17:13 <anoe> hello, there is a way to represent all new datatypes as a graph ; there is a library that would do such job already ?
10:17:23 <Tuplanolla> Going through the source code isn't even the easiest option there, monochrom.
10:17:24 <MarcelineVQ> monochrom: usually i see that described as explicit recursion, "implement map for [] using explicit recursion" allthough if you already know what map is I'm not sure how useful this line is
10:17:59 <dfeuer> quchen: I've used it a fair bit in containers, to get rid of the horrifying Show instance for functions. I've generally used Fun (a,b,c) d to represent a -> b -> c -> d. You could use Fun a (Fun b (Fun c d)) instead, but I haven't dug deeply enough to make that win yet.
10:18:17 <anoe> something like stack dot but for new datatypes ?
10:18:22 <quchen> dfeuer: I’m meeting Hughes in February, maybe I can sneak in some changes ;-)
10:18:56 <lpaste> lambdafan pasted “stack upgrade error” at http://lpaste.net/3614082441188212736
10:19:03 <dfeuer> quchen: I don't think he maintains it anymore, although I imagine the maintainer would be glad to hear him out. What do you get to meet Hughes about?
10:19:37 <Eduard_Munteanu> One study says worked examples are as effective as exercises, by the way. ;)
10:19:38 <quchen> dfeuer: General functional programming conference, http://bobkonf.de/2017/en/
10:19:41 <Zemyla> Oh, question. How do you use QuickCheck to create an Arbitrary ordering function?
10:20:04 <alviprofluvium> thanks dwit
10:20:35 <dmwit> Zemyla: A proposal: use the RNG to permute a list of all the elements of the type, and use that as the ordering.
10:20:58 <quchen> dfeuer: Gotta go though! Out in the cold Vienna Winter I go :-)
10:21:10 <dmwit> Zemyla: You can do the latter part relatively efficiently by converting to a `Map a Int` or so.
10:21:19 <dmwit> (giving the index of each element)
10:21:44 <Zemyla> But there's no real way to do CoArbitrary a => Arbitrary (Order a)?
10:21:56 <Gurkenglas> What's Order?
10:22:03 <dmwit> ?src Ordering
10:22:03 <lambdabot> data Ordering = LT | EQ | GT
10:22:20 <Gurkenglas> That wasn't my question :D
10:22:24 <dmwit> my guess was `type Order a = a -> a -> Ordering`
10:22:26 <dmwit> I know it wasn't.
10:22:56 <dmwit> With the invariant that `Order a` represented linear orderings, presumably.
10:23:18 <Gurkenglas> How about "comparing coarbitrary"?
10:23:37 * shapr swears at hspec-megaparsec
10:23:48 <shapr> Ok, I give up. I can't figure out how to use that package.
10:24:23 <Gurkenglas> (Which I just assumed to mean (Coarbitrary a, Arbitrary b) => Gen (a -> b), and it apparently isn't)
10:24:40 <Gurkenglas> Oh, that's arbitrary
10:24:50 <johnw> shapr: can you show me what you've tried so far?
10:24:56 <Gurkenglas> arbitrary = comparing <$> arbitrary, then :)
10:25:20 <dmwit> That's pretty good. =)
10:25:48 <qmm> "the Haskell community also uses the term \"generic\" for a related but somewhat different concept" from https://en.wikipedia.org/wiki/Generic_programming#Genericity_in_Haskell what is the other term this is referencing?
10:25:50 <shapr> johnw: I grabbed the first code sample from https://mrkkrp.github.io/posts/latest-additions-to-megaparsec.html#improved-support-for-testing and tried to get it to typecheck. I put the prs and prs' helpers in my Lib.hs that gets imported.
10:26:05 <johnw> shapr: can you show me one of the errors you get?
10:26:30 <Eduard_Munteanu> qmm, the Generic typeclass and associated stuff.
10:26:38 <Eduard_Munteanu> @google ghc generics
10:26:39 <lambdabot> https://hackage.haskell.org/package/base/docs/GHC-Generics.html
10:27:18 <shapr> johnw: http://lpaste.net/350775
10:27:22 <Eduard_Munteanu> @google ghc generics wiki
10:27:23 <lambdabot> https://wiki.haskell.org/GHC.Generics
10:28:06 <qmm> Eduard_Munteanu: how is datatype generic programming different from generic programming?
10:28:10 <qmm> i thought they were the same thing
10:28:18 <buttons840> any suggestions on how to debug "thread blocked indefinitely in an STM transaction"
10:28:22 <shapr> johnw: any ideas?
10:28:43 <johnw> shapr: context "foo" $ it "bar"$ property $ \s -> True
10:28:54 <johnw> it takes the tests as a second argument
10:29:12 <Eduard_Munteanu> qmm, generic programming is normally another word for polymorphism in other languages.
10:29:22 <Eduard_Munteanu> Constrained polymorphism.
10:29:29 <shapr> johnw: now I get a similar error
10:29:37 <alviprofluvium> dmwit: Thanks. I succeed =). Any commnets on my solution
10:29:49 <Eduard_Munteanu> qmm, on the other hand, Generic lets you inspect definitions of data types programatically.
10:29:49 <lpaste> alviprofluvium pasted “Arbitrary instance” at http://lpaste.net/350776
10:29:54 <johnw> shapr: where is the code that uses context?
10:30:11 <johnw> if you can paste me a complete example, I can get it working here
10:30:48 <qmm> Eduard_Munteanu: i have been thinking generic programming is simply referencing polymorphism
10:30:58 <shapr> johnw: if I can get it to typecheck, I can poke at it until I can get it to test the parseNode above, that's my actual goal. here's the existing error: http://lpaste.net/350775
10:30:58 <kadoban> Anyone else have problems with criterion where the HTML output is broken and a lot of the graphs don't display (including the summary one)? I can't tell if it's something I'm doing wrong or a bug or what.
10:31:38 <johnw> shapr: is 'context' from hspec-megaparsec?
10:31:47 <johnw> I'm using to using 'describe' there, instead of 'contet'
10:31:49 <Eduard_Munteanu> qmm, for example, it can be used to automatically generate serialization functions for arbitrary data types
10:31:56 <johnw> used to using* 
10:32:13 <shapr> johnw: the larger code that's commented out is what I really want, but that gives me the same errors
10:32:14 <johnw> also, in the body of a function, not at column 0 like this
10:32:28 <johnw> shapr: I need to see the larger code
10:32:48 <shapr> johnw: it's the chunk commented out above that line, I'll update the paste..
10:32:56 <johnw> ahh
10:33:09 <johnw> ok, one sec
10:33:52 <shapr> johnw: updated http://lpaste.net/350775
10:34:11 <shapr> the error is included in the block comment at the top
10:34:14 <Eduard_Munteanu> qmm, other languages may call Generic-like stuff reflection, e.g. Java.
10:34:24 <Gurkenglas> (arbitrary = comparing <$> arbitrary will need a type signature on the inside though, because what is compared on isn't specified)
10:34:34 <Eduard_Munteanu> Though that's also conflating it with dynamic stuff.
10:34:41 <johnw> shapr: btw, prop "foo" == it "foo" $ property $
10:34:52 <shapr> ah, that's good to know
10:35:32 <shapr> I'd rather start simpler, I've not done any kind of spec testing before, only read about it.
10:35:47 <johnw> I use hspec pretty heavily
10:35:52 <johnw> so I'm sure you're doing something very simple wrong here
10:36:12 <shapr> oh I agree
10:39:27 <shapr> johnw: I just can't figure out what's wrong :-(
10:39:44 <johnw> (still building dependencies here)
10:40:00 <johnw> hspec is just a little too polymorphic for its own good, is usually the problem
10:40:08 <shapr> For most of my advent of code solutions, problems came from lack of testing, so I thought hspec-megaparsec would save me time. Three hours later, I'm not convinced.
10:40:29 <johnw> nah, you just need to get the Zen of the types of errors using hspec induces
10:40:52 <johnw> it's especially bad if you get fancy with transformers
10:41:02 <shapr> johnw: I use enough code written by you on a daily basis that I have confidence. :-)
10:42:28 <johnw> i need to add megaparsec to my stock set of "packages to build"
10:42:55 <shapr> Megaparsec is part of the glguy multitool collection.
10:48:48 <johnw> shapr: is this on github or something?  I'm missing 'Lib'
10:49:01 <shapr> johnw: I'll push the code
10:49:59 <shapr> johnw: https://github.com/shapr/adventofcode2016/
10:52:42 <shapr> johnw: I forgot to push the changes to Lib, I just pushed them
10:52:54 <johnw> got 'em
10:52:55 <shapr> johnw: now the error I'm seeing shows up from "stack install"
10:56:22 <johnw> i'm at the error finally
10:57:34 <shapr> johnw: my approach is to take the hspec-megaparsec code sample in mark karpov's post, get that to typecheck, and then massage it into working for my own code.
11:06:29 <shapr> johnw: I'm off to the dentist, but if you figure out how to get it to typecheck, I strongly desire to know the solution!
11:06:36 <johnw> ok
11:13:38 <miko__> :pf (flip (<$>))
11:19:38 <qmm> "Note that you do not need -threaded in order to use concurrency; the single-threaded runtime supports concurrency between Haskell threads just fine." from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#options-linker
11:19:42 <qmm> haskell threads?
11:19:46 <qmm> are these like erlang processes?
11:20:32 <johnw> @tell shapr The problem was that hspec-smallcheck's "property" is rather different from hpesc's "property": https://gist.github.com/jwiegley/5bb744aa20bfd39784883a9764c962b6
11:20:32 <lambdabot> Consider it noted.
11:21:00 <yushyin> qmm: threads managed by the runtime, not the OS.
11:21:45 <yushyin> qmm: also called green threads https://en.wikipedia.org/wiki/Green_threads
11:22:18 <qmm> yushyin: with -threaded, you are able to utilize all the cores on a node?
11:23:51 <qmm> wikipedia seems to confirm 
11:25:33 <yushyin> somewhat like that, yes, but of course it is in detail a bit more complicated.
11:27:18 <tdammers> I just fat fingered a hackage upload
11:27:26 <tdammers> now I'm the maintainer for ghcjs-vdom
11:27:27 <johnw> uh oh
11:27:31 <tdammers> that was not the intention
11:27:36 <tdammers> is there a way to undo this?
11:27:45 <johnw> i'd ask in #hackage
11:27:48 <tdammers> right
11:30:51 <buttons840> johnw: can I ask you about your pipes-async package? (a >&> b) will run both a and b in parallel right? what if I just wanted to run one in parallel?
11:31:38 <johnw> correct
11:32:09 <johnw> you can get finer grained control by using pipes' own mailboxing primitive
11:32:28 <buttons840> is that part of pipes-concurrent?
11:32:31 <johnw> yes
11:34:34 <buttons840> if I have `a >-> b >-> c` can the "mailboxes" of pipe-concurrent be used to make b run in parallel without changing any code outside of `b`? I've been trying to do this for a few days and haven't found a way
11:34:51 <buttons840> johnw: can you confirm if that's possible or not? or maybe your not sure?
11:35:47 <lpaste> xcmw pasted “How can I tell ghc that r will be given in a visible type application” at http://lpaste.net/350783
11:36:14 <johnw> it's certainly possible
11:36:21 <johnw> a sequentially feeds into a mailbox, b asynchronously processes the contents of the mailbox, and asynchronously writes them to a mailbox that c synchronously feeds from
11:36:27 <johnw> this should work well if b is really slow to do each of its jobs
11:37:39 <xcmw> GHC is complaining that it can't figure out what r is. I enabled AllowAmbiguousTypes. r will be given in a visible type application.
11:37:44 <buttons840> johnw: i have managed to do that: 
11:37:52 <lpaste> Buttons840 pasted “async b” at http://lpaste.net/350784
11:38:34 <johnw> buttons840: that's not quite how I'd write it
11:38:35 <johnw> one sec
11:39:23 <buttons840> that required me to change how `a >-> b >-> c` are composed (or "wired up" i want to say), but I was wondering if there is a way to hide the details inside of `b :: Pipe Int Int IO ()` itself?
11:40:13 <buttons840> I've also made a SO question about this (no worries if you don't have time to look): http://stackoverflow.com/questions/41412823/how-can-i-make-a-pipe-concurrent-with-haskells-pipe-library?noredirect=1#comment70029610_41412823
11:44:01 <johnw> buttons840: https://gist.github.com/jwiegley/67964c2c90918e5940daf3e4a0212a46
11:44:19 <johnw> ah, missingone thing
11:44:51 <johnw> gist updated
11:44:52 <buttons840> johnw: thanks for the help
11:45:09 <johnw> no, still not quite right
11:45:59 <johnw> ah, there is no way to hide this inside of b
11:46:16 <johnw> you can't have inputs coming from 'a' at a different rate than outputs going ot 'c'
11:46:26 <johnw> that requires the sort of thing that pipes-async is doing
11:48:03 <buttons840> johnw: so I see your using TChans (which "mailboxes" are just a wrapper of), I didn't try TChans because I was hoping there would end up being some nice way to compose an arbitrary graph of mailboxes inside a single Pipe
11:48:18 <xcmw> xcmw: Anyone know to to fix it? Does it require TypeScopedVariables? http://lpaste.net/350783
11:48:28 <johnw> the problem is having 'b' write to 'c' asynchronously, while also accepting input from 'a'
11:48:56 <Psychiatrist> I'm having hard time understanding type classes in Haskell. Everyone says it's one of the best things in Haskell but I cannot grasp how it's any different from interfaces in OOP. Like how is Haskell's Num different from an interface where all number operations are defined?
11:49:25 <johnw> Psychiatrist: when you have a function foo :: Num a => a -> a -> a
11:49:39 <johnw> both arguments to 'foo' must use the same instance of Num
11:49:50 <buttons840> johnw: i had a solution which had multiple threads running inside of a single Pipe, one thread awaiting, one thread yeilding, other threads doing the work, but it deadlocked and got killed by GHC
11:49:55 <johnw> with interfaces in OOP, each argument could be its own implementation of Num, they'd only need to agree on the interface
11:50:14 <buttons840> (so I guess it wasn't a "solution" afterall)
11:50:23 <c_wraith> :t read
11:50:28 <lambdabot> Read a => String -> a
11:50:42 <c_wraith> Psychiatrist: type classes can dispatch on return types.
11:50:44 <buttons840> johnw: so you're saying this isn't possible within a single Pipe even with TChans?
11:51:06 <buttons840> i have to compose what I want at a higher level outside of the individual Pipe?
11:51:14 <johnw> buttons840: correct
11:51:16 <johnw> yes
11:51:34 <johnw> i could explain exactly why, but it would take a little bit and I'm not sure you'd be terribly interested
11:52:55 <buttons840> johnw: i probably couldn't understand a really technical explination at my level, I've been working on this long enough to see several approaches get close, but then types never quite line up
11:53:35 <johnw> it's mainly because pipes is implemented using continuations, and you're trying to inject something rather "discontinuous" into the middle of it
11:53:49 <c_wraith> Psychiatrist: in fact, type classes have a fundamental difference from interfaces.  Interfaces dispatch based on the value the method is being called on.  Type classes dispatch based on the *type* the function is being used as.
11:54:06 <buttons840> since you can do IO inside of a `Pipe a b IO ()` shouldn't it theoretically possible to do anything?
11:54:52 <johnw> buttons840: you can't do the inverse those: you can't lift IO (as you'd need to do to execute a thread), and then from within that IO, unlift in order to yield or await
11:55:02 <buttons840> not that I'm going to try, I'm more curious about Haskell in general, does IO allow you to adapt to pretty much any interface/type?
11:55:16 <agocorona> johnw:  you can do it with transient https://github.com/transient-haskell/transient/wiki/Transient-tutorial#event-variables-publishsubscribe
11:55:21 <johnw> this comes down to the same reason why ConduitM can't be an instance of MonadBaseControl, in case you ever come across that oddity in the future
11:55:30 <johnw> sorry, I mean Proxy
11:55:35 <Philippa> hi. I'm waaaaay out of practice and stuck my foot in it trying to implement an applicative functor with a GADT "front end" and a double-barrel CPS-based interpreter...
11:56:09 <Philippa> basically, for <*> I need to convince the typechecker that a continuation corresponding to an either that ignores its type parameter, well, doesn't care about its type parameter
11:56:22 <johnw> agocorona: how does that relate exactly?
11:56:42 <Philippa> I'm pretty sure I've missed a trick somewhere and it might be as simple as "the original continuation for that chain wants a different type from the rest", but yeah
11:56:52 <c_wraith> Philippa: example code would be helpful. :P
11:56:53 <johnw> Philippa: can you paste the code?
11:57:11 <Philippa> there's a fairly tedious quantity of it and it's mid-hack?
11:57:13 <monochrom> Philippa: Is it easier for you to get >>= done and then just use ap for <*>?
11:57:43 <Philippa> monochrom: no, I'd hit the same problem re failures. I'm effectively reimplementing the applicative fragment of a parsec relative in CPS
11:57:56 <Philippa> which I remember took a long time the first time round and I imagine this was the blocker
11:58:00 <johnw> Philippa: pastie :)
11:58:09 <Philippa> <*> and >>= have exactly the same problem, types-wise
11:58:12 <Psychiatrist> johnw, c_wraith Thanks for the quick answers! I think I need to read some more since I can't seem to grasp it still.
11:58:13 <michaelt> what does the type declaration look like, at least ...
11:58:32 <Philippa> okay, gimme a mo to condense the problem slightly?
11:58:38 <agocorona> async writeTVar var "hello" <|> async  readEVar >>= liftIO . print
11:59:00 <johnw> Psychiatrist: a paper you may be interested in is http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
11:59:03 <Philippa> go :: Whatever -> SuccessContinuation -> FailureContinuation -> Result...
11:59:06 <johnw> it clarification the difference quite well
11:59:10 <agocorona> this is the pseudocode ( add atomically) of two threads, one stream "hello", the other read it
11:59:15 <Philippa> SuccessContinuation and FailureContinuation both yield a result...
11:59:21 <Philippa> Result, even
11:59:31 <Philippa> except that's Result a, *Continuation a etc
11:59:34 <Psychiatrist> johnw: Thanks, I'll check it out.
11:59:54 <johnw> agocorona: well, we have the functionality in pipes-async; it's just not implemented in the way buttons840 was hoping it could be
11:59:57 <Philippa> Result a = Either Something (a, SomethingElse)
12:00:08 <Philippa> so FailureContinuation corresponds to the Left branch, the one where a doesn't appear?
12:00:40 <Philippa> which means I should /probably/ figure out how to stomp a out of FailureContinuation's type
12:01:00 <Philippa> I /think/ the answer is to worker/wrapper one more time and explicitly fill in the result type right up the top of the chain of failure continuations
12:01:17 <Philippa> "I never see an a, so whatever builds the final Result can ignore me"
12:01:23 <michaelt> this is like the attoparsec Parser type. 
12:01:36 <agocorona> (waitEvents $  atomically $ writeTVar var "hello") <|> (waitEvents $ readEVar var >>= liftIO . print)
12:01:43 <lpaste> Buttons840 pasted “Threads inside a Pipe - Type checks but doesn't work” at http://lpaste.net/350785
12:01:57 <Philippa> michaelt: yes, it will be
12:02:09 <Philippa> because I'm basically redoing that as the starting point of something for the hell of it
12:02:17 <johnw> agocorona: that's basically the pipes-concurrency mailbox approach, no?
12:02:19 <Philippa> (give-or-take the front end, perhaps?)
12:02:27 <Philippa> but yeah, I guess I should go read attoparsec
12:02:32 <buttons840> johnw: ^ these a paste that shows where a noob got when following the types :)
12:02:43 <buttons840> there's*
12:02:55 <agocorona> sorry: (async $ forever $  atomically $ writeTVar var "hello") <|> (waitEvents $ readTVar var >>= liftIO . print)
12:02:59 <Philippa> (the "problem" is that <|> needs a /typed/ failure continuation to say "try the other branch")
12:03:18 <johnw> buttons840: lift $ forkIO $ void . pure $ inLoop in2 is just creating a thread that produces an action (but does not execute it) and then exits
12:03:37 <johnw> i wonder if GHC will even just compile it away
12:03:42 <johnw> since you never use the resulting value
12:03:46 <agocorona> Philippa:  any async comp execute the alternative computation
12:03:46 <buttons840> johnw: it does compile
12:04:00 <johnw> yeah, it has a meaning
12:04:03 <johnw> just not the meaning you intended
12:04:31 <buttons840> johnw: it does compile, but does nothing at runtime -- and when I used async instead of forkIO it just gave a STM deadlock error
12:04:48 <johnw> "it does compile, but does nothing at runtime" <-- see my explanation above :)
12:06:12 <michaelt> buttons840: i don't see how 'b' could begin working on the second number it gets from a, until c has printed the first result. 
12:06:23 <johnw> agocorona: now write a Pipe segment that sits in between two synchronous segments (that do not use TVars to communicate), and yet is able to read and write results asynchronously
12:06:24 <Philippa> agocorona: I think we got lines crossed - different <|> in my case, I'm having "fun" implementing a parser
12:06:32 <Philippa> just ignore me :-)
12:06:44 <SnowFlake> Evening
12:07:04 <Philippa> ...there's a "Types.Internal.Fhthaghn" module, that isn't entirely promising
12:07:23 <buttons840> michaelt: yeah, I was pretty lost in that code, I just started putting in whatever it took to fill the type holes in the end
12:07:29 <geppettodivacin> SnowFlake: Afternoon
12:07:43 <athan> 9
12:07:46 <athan> :x
12:07:56 <SnowFlake> How are you all?
12:08:08 <agocorona> johnw:    waitEvents (return "hello") >>=  liftIO  . print
12:08:12 <michaelt> buttons840: the second number that a releases (namely 2) is only going to get released when () gets sent back from c. 
12:08:22 <michaelt> buttons840: to speak somewhat pictorially ...
12:08:24 <johnw> agocorona: in between, as in: a >-> b >-> c
12:08:24 <agocorona> this produce "hello" events and they are printed
12:08:30 <michaelt> hullo SnowFlake 
12:08:36 <buttons840> johnw: can pipes async do `a >-> (b >&> c) >-> d`; can it join again once you've forked?
12:09:04 <agocorona> johnw: I don't use pipes
12:09:07 <johnw> buttons840: sure, (b >&> c) is, as a whole, just a pipe segment
12:09:17 <agocorona> I use transient
12:09:21 <johnw> anything you feed to it will be fed to b's mailbox as it comes
12:09:42 <johnw> agocorona: I see, you were suggesting an alternative to pipes for accomplishing the task
12:09:50 <agocorona> yep
12:09:58 <johnw> kk, now I understand, thanks for the pointer :)
12:10:04 <buttons840> johnw: ah, so if it want just b to be parallel i could `a >-> (b >&> cat) >-> d`?  (`cat` is id for pipes isn't it?)
12:10:29 <johnw> may be!  give it a try
12:10:32 <Philippa> okay, yeah, attoparsec's answer is to keep the return type out of the failure type and now I just have to CPS that adequately
12:11:48 <Philippa> ...except <|> is /still/ gonna kick me in the teeth for that, because that does care
12:12:01 <Philippa> (I am not writing this in the same style as attoparsec)
12:12:03 <agocorona> pipes is also single threaded. transient is multithreaded: each event is sent in a different thread by default
12:12:35 <johnw> ah!
12:12:48 <Philippa> (I have a GADT describing grammars/languages, and am writing a parser for said things which is in CPS)
12:12:59 <johnw> Philippa: I still have seen no pastie :(
12:13:25 <Philippa> johnw: that's because it's a big heap of crap and I'm both tired and juggling rl stuff that's kinda stressful :-)
12:13:33 <Philippa> you're right it's the most helpful thing I can do, mind
12:13:35 <agocorona> Philippa the <|> operator is underused in haskell ;)
12:13:39 <johnw> sorry to hear 2017 is starting out rough :(
12:19:01 <Philippa> Haven't flung this through GHC for sillier errors while cutting bits out, but this should be close to the minimal bits I need aside from parameterising over tokens:
12:19:02 <Philippa> http://lpaste.net/5649453617262886912
12:19:35 <johnw> could I see the error you get too?
12:20:52 <michaelt> Philippa: those grammars will all be infinite no?
12:21:14 <Philippa> michaelt: I've deliberately cut out every case not relevant to the actual problem
12:21:17 <Philippa> including in the Grammar type
12:21:25 <Philippa> the full thing's more-or-less a bog-standard applicative
12:21:27 <michaelt> ah
12:21:52 <michaelt> you were freaking me out for a second there ...
12:22:24 <Philippa> johnw: that'd take some messing about. It amounts to not being able to unify localFail like I'd like it to (ie it calls the up-chain continuation at its return-value type and has the type the call site wants)
12:23:08 <Philippa> and then me getting a choice of either the Ap case to fail on (which is the default) or the Choice case if I go rank-2 on the FailCont
12:23:40 <codygman_> Is profiling my criterion benchmark a good idea? It seems like it would show hotspots for areas I cared about.
12:25:03 <johnw> Philippa: I'm seeing the errors here now
12:25:30 <kadoban> codygman_: Seems like a decent idea, if the benchmark is any good. If it's measuring something that in reality you don't care about, it's not going to be terribly helpful though.
12:25:39 <Philippa> either I screwed up or they're a long-winded match for what I'm saying plus cascade failure?
12:25:46 <codygman_> kadoban: thanks for the sanity check
12:26:09 <Philippa> (one on localfail, one when the continuation chain using it smacks into the annotation for go)
12:26:57 <Philippa> though it's possible I've actually screwed up something in there and am sufficiently not together to follow it with the longer error messages (they're lovely, but I'm on an 11.6" screen)
12:27:47 <tdammers> 11.6", what's that, a phone?
12:27:55 <Philippa> oh, I could tighten up one of the annotations now
12:28:21 <kadoban> 11.6" is probably a tablet or maybe a netbook or whatever those are.
12:28:32 <codygman_> building my benchmark takes 4m31.407s :/
12:28:42 <Philippa> tdammers: har har har. Some of us have accessibility reasons for using passively-cooled machines where we can, until I needed to handle the new error messages this machine's done just fine
12:28:52 <kadoban> Just building it takes that? That's pretty long.
12:28:54 <Philippa> kadoban: it's a netbook-successor, yeah. Quad core bay trail job
12:28:58 <michaelt> it compiles if you get rid of the forall a. 
12:29:19 <hackrilege> Yeah, can't run ghc on a phone so easily. Found a Windows enabled device for £80 around black Friday...
12:29:26 <Philippa> michaelt: huh. I should start seeing which case makes it fall over next then. Cheers!
12:29:32 <kadoban> Philippa: I'd go nuts, I like multiple decent-sized screens.
12:29:43 <Philippa> hackrilege: mostly for OS reasons, admittedly - it works fine on a raspi
12:30:02 <michaelt> Philippa: oh wait, that was the first case only let me see...
12:30:12 <michaelt> Philippa: I commented the other out
12:30:49 <NextHendrix> kadoban: three good screens: £1500. feeling like a hacker on tv: priceless
12:30:56 <Philippa> michaelt: right, the problem is Choice and Ap have conflicting expectations about how that continuation behaves - Choice locally cares about its type because it's going to turn it into a success if it can
12:31:28 <Philippa> let's just say that this machine wasn't half that even after swapping the storage for a large SSD and upping the RAM, and it's damn solid for music production on the go?
12:31:29 <johnw> Philippa: I can get it working for just Choice, but Ap introduces an existential that messes everything up
12:31:48 <michaelt> yeah, at first even the first case wasn't compiling but its the easy one
12:32:13 <Philippa> johnw: yup, that's my diagnosis thus far. My question is "surely there's a standard technique for this that I've missed because I haven't done heavy enough CPS?"
12:32:25 <hackrilege> :t (>->)
12:32:27 <lambdabot> error:
12:32:27 <lambdabot>     • Variable not in scope: >->
12:32:27 <lambdabot>     • Perhaps you meant one of these:
12:32:29 <johnw> what are you trying to achieve again?
12:33:12 <Philippa> johnw: so go is clearly in CPS, right? And the point of that's to optimise stuff on failure branches
12:33:59 <Philippa> otherwise, for now I "just" want an applicative parser. I could say fuck it and write the direct style version and get on with other aspects of the project, just having one of those days where the bloody-mindedness:practicality ratio is off
12:34:06 <kadoban> NextHendrix: Naw, nowhere near that expensive, unless VAT is way more than I thought. I think I spent about $90 on the one monitor I bought that I'm currently using, the other was an old TV a friend didn't want anymore.
12:34:13 <hackrilege> johnw, where can I find a good introduction to this asynchronous pipes stuff? Similarly for transient... I couldn't quite deduce the value of Proxy by reading the source
12:34:23 <Philippa> and the "problem" is effectively that Choice can call a failure initially and get a success later?
12:34:41 <Philippa> because actually, you can make Ap work by rewiring how failures work otherwise
12:34:43 <NextHendrix> kadoban: thats a surprisingly relatable situation
12:34:49 <johnw> Philippa: but go needs the final result type to be 'a' for Choice, and 'a -> b' for Ap
12:35:34 <NextHendrix> can you write type declarations for anonymous functions
12:35:39 <Philippa> it's simpler than that: sans choice, fails /don't care what they failed to parse/
12:35:51 <Philippa> NextHendrix: yup, use :: inside their body
12:35:59 <Philippa> or just around them
12:36:05 <Philippa> depending on what exactly you want to annotate
12:36:08 <NextHendrix> nice
12:36:14 <Philippa> (\x -> x) :: x -> x
12:36:16 <hackrilege> Also, I understand Haskell use OS threading, I don't get how forkIO our async could be implemented in pure Haskell...
12:36:50 <ContessaTP> you can always use C imported functions
12:37:14 <hackrilege> Uses*, or*
12:37:15 <johnw> hackrilege: cooperatively, using green threading and an implicit "yield" after every action in the evaluator (or for certain actions)
12:37:38 <hackrilege> :t yield
12:37:40 <lambdabot> error: Variable not in scope: yield
12:37:46 <c_wraith> GHC uses an implicit yield when you allocate.
12:37:56 <johnw> that is, compile multiple actions to terms in some Action DSL, and then execute them in tandem by going round-robin between them at each yield point
12:38:45 <Philippa> c_wraith: yup, with the problem that tail-recursive strict functions can bite you in the arse last I heard? Or is that fixed now?
12:39:10 <hackrilege> Can I see some literature that would help me understand the concept of yield?
12:39:11 <Philippa> (I'm starting to think of "tail recursion modulo cons" in Haskell as tail-corecursive)
12:39:12 <c_wraith> Philippa: You can still block GC that way, yeah.
12:39:30 <c_wraith> Philippa: which, when combined with a stop-the-world GC...  is very bad.
12:39:34 <johnw> hackrilege: yield says to the evaluator, "I'm willing for you to consider doing something else"; what it means is up to you
12:39:53 <johnw> hackrilege: have you ever written an evaluator for a DSL?
12:40:02 <Philippa> (ones = 1:ones as your trivial example, in that the last thing it does is still return a cons cell containing itself)
12:40:10 <hackrilege> Nope!
12:40:27 <hackrilege> I guess I should...
12:40:29 <johnw> hackrilege: I'd recommend doing that then, and come back to the issue of concurrent execution after that's familiar
12:40:41 <johnw> working with DSL is one of Haskell's killer apps
12:40:54 <hackrilege> Nice, thanks
12:42:16 <hackrilege> I made a new representation of a graph I quite like, would you be able to take a look? http://lpaste.net/350633
12:45:08 <miko__> With the Type in Type, can a typevariable be a type?
12:45:15 <hackrilege> Its different to that of sgl in that rather than labeling each node with an Int, a cyclic graph can be represented by referring to a modified zipper...
12:45:44 <miko__> e.g. is "(Metatype t) => t a -> a" possible?
12:46:20 <Philippa> ...okay, technically I'm doing something different from both Parsec and Attoparsec in implementation strategy and that's probably why I'm in quite so big a mess
12:46:26 <hackrilege> Metatype is a class?
12:46:59 <miko__> well, the question is, what could it be?
12:47:11 <hackrilege> A class
12:47:40 <miko__> Could t become "Num" ?
12:47:55 <hackrilege> Oh I see
12:47:58 <miko__> Sorry, Maybe, as Num has no parametres
12:48:29 <hackrilege> It would be a feature I'm not aware of, maybe the others know
12:48:54 <Philippa> *facepalms*
12:49:16 <Philippa> oh, right. I actually need to write a bunch of very local fail continuations going "oops, failed step 1/step 2", don't I?
12:50:10 <Philippa> ...nope, that alone isn't enough to combine into "I failed at parsing the whole thing"
12:51:09 <miko__> Ask differently: Could the Class "Maybe" be a instace of the Class "Metatype", aswell as the class "Maybe2000", so that "(Metatype t) => t a -> a" matches "Maybe a -> a" and "Maybe2000 a -> a"?
12:51:22 <miko__> Is that what Type In Type is about?
12:51:52 <Philippa> Type In Type is literally just * : *
12:51:55 <Philippa> sorry, * :: *
12:52:44 <buttons840> johnw: I've been trying to get pipes-async installed with stack and I'd have to go back to at least lts-4 I think? the version bounds for base and lifted-async don't fit with more recent LTS version from stackage
12:52:51 <miko__> I tought it would unify kinds and types, so that "kind variable" are possible.
12:53:04 <Philippa> it's an alternative to having a hierarchy of ever ascending universes of types, and it's there because it's easier and Haskell can't reap the correctness benefit that the hierarchy offers anyway
12:53:08 <johnw> buttons840: I don't know, I don't use stack or stackage, or pay attention to what works there
12:53:27 <Philippa> miko__: yes, because now the kind * is a type
12:54:07 <Philippa> literally, the type of * (the most basic kind) is *
12:54:09 <Philippa> that's what it means
12:54:48 <miko__> But it does not allow the typing of type variables?
12:54:57 <Rembane> Philippa: Is * any type at all?
12:55:14 <Philippa> Rembane: it's the type of that, ignoring boxing etc
12:55:38 <c_wraith> Rembane: * is not a wildcard, despite how it looks.  It's a concrete kind. :)
12:55:51 <Tuplanolla> The type of types, except the ugly ones.
12:56:28 <Rembane> Philippa, c_wraith: Ah. This is confusing. I have a quite good intuition about how kinds work, but the details ar beyond me.
12:56:34 <c_wraith> * is the kind of types that have values.
12:57:02 <Philippa> Rembane: Type In Type basically does away with the idea of kinds, it makes it like working in a full-spectrum dependently-typed language instead
12:57:24 <Philippa> instead of kinds, /everything/ has a type and the type of * is * so that a finite number suffices
12:57:35 <Rembane> Philippa: Ah, I see. Interesting.
12:57:35 <hackrilege> How would your metaclass work!? Instances of classes are types with implementations of functions on them. Instances of metaclasses are kinds with type level functions defined over them?
12:57:39 <Philippa> (but you get Girard's paradox instead)
12:58:08 <Philippa> (which is why hierarchies of universes happen elsewhere - * gets called Type, Type : Type1, Type1 : Type2 etc)
13:00:07 <miko__> hackrilege, excatly. 
13:01:12 <hackrilege> Sounds intense
13:01:17 <miko__> I mean, depended typing calles for type level function, as i understand it, and these should have a typesystem, right?
13:02:02 <Philippa> miko__: Type In Type literally says "reuse the one you've got, your new rule is that Type is the type of Type"
13:02:25 <Philippa> otherwise we've already /got/ such a thing in the kind system, it's just intentionally limited in the functions it supports
13:02:45 <miko__> And, I don't really understand what typeintype offers, but it was advertised as DT in Haskell.
13:03:04 <miko__> Philippa, please tell me more. What function does it support?
13:03:36 <Philippa> mostly type constructors :-)
13:04:01 <buttons840> johnw: do you know if pipes-async will work with GHC 8? it looks like the version bounds in the cabal would have to be adjusted, but if I do that do you know if it will work?
13:04:12 <JuanDaugherty> generally since smalltalk, CLOS, etc, the metaclass functions are just functions
13:04:15 <Philippa> but Type in Type goes further than that. I don't know the rest of what's in currently properly, but it's a major step in the dependently-typed direction because it means there's nearasdammit nothing you can't quantify over
13:04:36 <johnw> buttons840: yes
13:04:39 <Philippa> JuanDaugherty: whereas the equivalent is firmly not true in Type Theory since it was realised that creates a paradox
13:04:42 <johnw> buttons840: I'm building it for ghc8 here
13:04:54 <JuanDaugherty> any distinction being calling, combining, compiling, etc
13:05:05 <Philippa> but Haskell's already a naively partial language, so the only thing that costs you is the ability to waste a lot of heat deciding you don't wanna wait for the compiler
13:05:11 <hackrilege> I guess it would support eg generation of kinds from type level ints
13:05:23 <Philippa> hackrilege: bingo
13:05:38 <JuanDaugherty> Philippa, right diff between mathematics and practical computing
13:05:45 <Philippa> except there are no kinds any more, there are just types that do the job kinds did and contain *
13:05:50 <hackrilege> Still can't imagine what the values ends up doing!
13:06:03 <Philippa> JuanDaugherty: the Idris folks might get a little irritated by that summary :-)
13:06:42 <JuanDaugherty> in execution a function is a function is a function
13:06:42 <Philippa> *cough* evaluation *cough* :-)
13:06:50 <Philippa> we use "execution" to mean that thing where you get to do IO around here...
13:07:09 <Philippa> IO-in-main's-type would be an entirely different extension
13:07:24 <hackrilege> I think the point was it enables compile time computation...
13:07:46 <Philippa> "enables" isn't quite the right word, we've been doing that in different forms for a long tiem
13:07:46 <miko__> Well, I thought how I would be possible to generalize the concept of the language-level function. e.g. overload the blank operator, or the applicative operator. That's why i wanted it.
13:07:47 <Philippa> *time
13:07:51 <Philippa> it makes it much /neater to do/
13:08:07 <miko__> So  that (a->b) becomes the multiparamter typeclass "function a b"
13:08:10 <hackrilege> Ok
13:08:40 <Philippa> miko__: that'd be a cute thing to have, certainly. Although you absolutely have to have a basemost notion of function somewhere
13:08:43 <miko__> But i wanted my own functions, so i need a class that contains "function" and other things that can be apllied arguemnts.
13:09:01 <Philippa> eh. You've been able to do that for a long time
13:09:11 <Philippa> the trick is you put your functions in a functor
13:09:31 <Philippa> and end up with an applicative or a monad, then limit the range of values in that
13:09:44 <Philippa> (note lack of capitals: the typeclasses Applicative and Monad are not up to this)
13:09:55 <miko__> But $ and <$> are different
13:10:16 <miko__> I get it's not needed.
13:10:35 <Philippa> aside from Identity being an isomorphism rather than equality, $ is a specialisation of <$>
13:11:18 <miko__> It's more of a syntaic annoyance. f $ x can be writte as f x. But m <$> x can't be written m x.
13:11:43 <Philippa> right. That's what languages like Frank aim at
13:12:19 <Philippa> it /is/ an annoyance, yeah. But you have to go through a pretty major overhaul of a 26 year old language to do it here
13:12:30 <hackrilege> I think there was something like ApplicativeDo language extension...
13:12:35 <Philippa> (it's not the most annoying thing that's baked in, either)
13:12:55 <Philippa> sure, but that suffers from miko__'s complaint still: you have to /say/ you're using it
13:13:06 <Philippa> (I'm one of its earlier proposers: I get to say nasty things about it!)
13:13:20 <johnw> hackrilege: in ghc8, yes
13:13:31 <EvanR> what would you want to write m <$> x as m x, did i miss context
13:13:37 <hackrilege> https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
13:13:43 <EvanR> what else can write with whitespace
13:13:47 <Philippa> when it uses *> instead of >> I'll even be able to use my own proposal for my own current use case for it :-)
13:13:50 <Philippa> it's got issues at the moment
13:14:40 <Philippa> EvanR: we all write m <$> x as m x for /some/ applicative. Haskell bakes one in, the ML languages another
13:14:54 <miko__> But I agree, it requires so many abstractions it's probably not worth it.
13:15:08 <EvanR> you mean Functor
13:15:15 <Philippa> miko__: what it actually requires is rewriting the entire syntactic structure of the language
13:15:32 <EvanR> this seems dangerously closed to overloaded whitespace
13:15:36 <Philippa> I mean "sod it, <$> started out in Applicative so what the hell", plus "no, you probably want room for a second parm"
13:15:46 <johnw> i guess if you only ever use one value from a preceding bind, there could be FunctorDo too
13:15:47 <Philippa> well yes. We already overloaded semicolons
13:15:50 <gingitsune> I'm reading learn you a haskell. In the example the type declaration precedes the functino definition. But GHCI won't have that
13:16:12 <lpaste> Buttons840 pasted “pipes-async build error” at http://lpaste.net/350787
13:16:21 <EvanR> Philippa: you can see from the do structure that its there, and doesnt look like normal functional code
13:16:25 <Philippa> johnw: no need, I'd have thought? The normal form already uses <$>
13:16:39 <hackrilege> It's strange the way I can write something like (0.5,0.5) == 1/2 if I write a fractional instance for tuple. The fromRational seems to be sugared to whitespace
13:16:49 <Philippa> EvanR: except a lot of us pointedly write in monadic or applicative style by default in anticipation of future refactoring
13:16:49 <johnw> buttons840: i guess it's just an instance I forgot, one second
13:16:49 <miko__> Philippa, I got the impression syntax is the easy part. But typesystems needs to generalize build in functions and user defined one. That's what looks tricky to me.
13:17:04 <Philippa> miko__: that's actually the easy bit, we already do it
13:17:37 <Philippa> we've been doing it for a very long time
13:17:44 <johnw> buttons840: wait, try importing Pipes.Safe to get that instance
13:17:46 <Philippa> we just don't give it the nice syntax
13:17:47 <gingitsune> Is there there a way to define a type declartion prior to the function in GHCI though?
13:18:24 <Philippa> EvanR: an important thing to understand about all things Applicative or Monadic is that if you can parameterise across all Applicatives or Monads, you've got pure code
13:18:32 <buttons840> johnw: you should know i changed the upper bounds for base to 4.9 (which you must have too, if your using ghc8), and the upper version bound for lifted-async to <0.10
13:18:43 <Philippa> (proof: instantiate with Identity)
13:18:44 <geekosaur> gingitsune, use a semicolon
13:18:55 <geekosaur> let foo :: ...; foo ... = ...
13:19:05 <miko__> > (\x -> x + 1) <$> 2
13:19:08 <lambdabot>  error:
13:19:08 <lambdabot>      • Ambiguous type variables ‘f0’, ‘b0’ arising from a use of ‘show_M29149...
13:19:08 <lambdabot>        prevents the constraint ‘(Show (f0 b0))’ from being solved.
13:19:21 <geekosaur> (you can also enable multiline mode, either temporarily with :{ :} or with :set +m, but each has its own warts)
13:19:32 <hackrilege> How is eg fromIntegral performed implicitly?
13:19:51 <geekosaur> the compiler inserts it for you
13:20:40 <hackrilege> > 1 == 1.0
13:20:43 <lambdabot>  True
13:20:59 <Philippa> integer literals translate to "fromIntegral <literal as an Integer value>"
13:21:05 <hackrilege> How do I write my own?
13:21:13 <geekosaur> that's why the IsString stuff also needs a compiler extension (OverloadedStrings) so it knows it has to wrap string literals in fromString
13:21:21 <miko__> Be carefull. Just today I compared floats. Id did me cost a hour or so. in floats x + a -a -x is not always 0.
13:21:41 <kadoban> hackrilege: Write your own what? Num instance?
13:21:45 <Philippa> miko__: yeah, in that particular expansion of FP the F is overloaded...
13:22:14 <kadoban> hackrilege: fromInteger is a method of Num, which is what gets used.
13:22:25 <geekosaur> the whole abbreviation is: floating point = f***ing painful :p
13:23:05 <hackrilege> I guess it's something special about the way ghc parses numbers in the source file, perhaps I can't think of another use case, maybe that's what overloaded strings are...
13:23:46 <Philippa> hackrilege: it's not how they're parsed, it's how they're interpreted, but yes
13:23:56 <tdammers> there's also overloaded lists
13:24:16 <hackrilege> What class has fromList?
13:24:21 <tdammers> and one could argue that applicative-do and monad comprehensions are in a similar arena
13:24:38 <tdammers> hackrilege: vectors, arrays, sets, ...
13:24:42 <Philippa> and what you want is the same thing for " " (with a reserved syntax for built-in application) and it translating into an Applicative
13:24:54 <Philippa> do is overloaded let, yes
13:25:12 <Philippa> mdo is the "data"/value-recursive version
13:26:26 <hackrilege> Anyway the stuff about pipes and async was more interesting... Sorry for the distraction
13:28:57 <t7> why are instances not first class?
13:29:42 <t7> i guess you can kinda do it with implicit params
13:29:53 <t7> is anyone doing that?
13:30:08 <geekosaur> instances are special in all kinds of ways. in particular they are always global. (yes, this is necessary)
13:30:13 <johnw> buttons840: uploading pipes-async 0.1.2 with updated bounds; it builds for me with GHC8 and the latest pipes
13:31:01 <gamegoblin> t7: if you haven’t, you might find the article "Scrap your typeclasses" interesting
13:31:16 <gamegoblin> t7: it’s here http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:31:21 <t7> gamegoblin: i think i read it before
13:32:30 <jmcarthur> t7: Instances can be considered "sort of" first class in that you can pass a dictionary around as a value. https://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint.html#t:Dict
13:32:38 <buttons840> johnw: would the next version of base be 4.10 or 5.0 ?
13:32:47 <johnw> buttons840: I don't know!
13:33:45 <buttons840> johnw: might do <4.10 for the upper version for base, but it don't matter right now
13:34:17 <Philippa> t7: you can only make "instances" first class safely if you detach them from "instance dispatch", at which point they lose a lot of their value
13:34:21 <johnw> changes in base are fairly conservative anyway
13:34:56 <johnw> know that according to PvP I shouldn't do <5, but...
13:35:11 <Philippa> (personally: I'd like to make that disconnect but I don't necessarily want them first class for the use cases I have in mind first)
13:37:52 <gingitsune> geekosaur: thanks the semicolen worked
13:38:37 <lpaste> Buttons840 pasted “pipes-async build error 2” at http://lpaste.net/350788
13:39:05 <buttons840> guess thats the same error from before
13:43:42 <buttons840> johnw: thanks for updating the version bounds, it installs with the latest stackage now, which is useful to users like me -- i still get the compile time error i paste above about a missing MonadSafe instance
13:46:54 <Philippa> grr, my problem is doing my head in not least because I know in principle you can CPS anything and I've written the direct-style version of this before
13:50:28 <monochrom> :)
13:50:46 <Philippa> monochrom: did you catch what my problem is?
13:50:55 <Philippa> (I've got a one-liner tl;dr if you can cope with it...)
13:51:05 <monochrom> No, I've been away.
13:52:14 <miko__> Oh, I think I just found out how Idris deals with monads that make applications much easier. ! lifts variables. If i understood it correctly, ((+) 1) <$> Just 5 becomes  1 + !(Just 5).
13:52:22 <Philippa> okay. I've got a GADT giving the syntax for an Applicative DSL. I'm writing an interpreter. The language has error/exception behaviour, and I'm trying for a "double-barreled CPS" implementation - a fail continuation and a success continuation. I can't make the <$> case typecheck, and it's over a type parameter that's irrelevant in that situation
13:52:26 <Philippa> (I could just coerce it)
13:52:52 <miko__> is ! used for anything in besides patterns?
13:53:03 <miko__> * in haskell.
13:53:08 <geekosaur> (!) is an array operator
13:53:25 <Philippa> and it's strictness in datatype declarations too
13:53:35 <Philippa> monochrom: summary making any sense?
13:53:38 <monochrom> yes
13:54:27 <miko__> Ok, "|" seems to be unused.
13:54:30 <Philippa> monochrom: know how to fix it (without the coercion), or anyone who knows how?
13:54:31 <monochrom> But I fear making a GADT a Functor instance etc.
13:54:37 <Philippa> miko__: it's pattern guards
13:54:37 <miko__> I wonder what it takes to write a language extension.
13:54:41 <jle`> miko__: | is used a lot in haskell syntax
13:54:44 <Philippa> it's also an operator
13:55:01 <jle`> it's probably one of the more overloaded syntax tokens, heh
13:55:06 <jle`> almost as much as (->)
13:55:09 <Philippa> miko__: I gather there's more of a guide to that now than there used to be? Don't have a link handy though
13:55:10 <jle`> er, ->
13:55:46 <monochrom> Single | is reserved, but you can always try |||||||
13:56:00 <miko__> Ok, as a operator, that suprises me.Patteren guards should be easily disinguised.
13:56:23 <miko__> (Ok, maybe not, esp. if it's also a operator)
13:56:24 <jle`> pattern guards are one of the least common usages of |
13:56:39 <miko__> Other usage I know are in [] brackets
13:56:47 <jle`> they're used in normal guards
13:56:51 <jle`> and most commonly probably in ADT syntax
13:57:18 <jle`> and in fundep syntax, type family dependency syntax, minimal typeclass declaration syntax
13:57:19 <miko__> But that's actually easy to distinguish
13:57:37 <miko__> well, ADTs
13:57:42 <miko__> Ok, ok, horrible idea.
13:58:13 <jle`> i wonder what the most overloaded syntax token is in haskell
13:58:20 <jle`> i'm guessing it's ->
13:58:55 <Philippa> do, case, lambda, function arrow, what else?
13:58:56 <Philippa> (the first three are all pretty consistent)
13:59:00 <Philippa> oh, ; is a good shout
13:59:13 <Philippa> (just because you don't usually write it...)
13:59:14 <miko__> I the lecture -> as introduced to us as a function. (e.g. a type level function). I was dissapointed when (<-) = flip (->) didn't work.
13:59:23 <miko__> *In a
13:59:23 <Philippa> {;} are almost certainly it, come to think
13:59:24 <jle`> Philippa: fundep syntax, type family dependency syntax
13:59:52 <jle`> how is it used for 'do' syntax?
14:00:07 <Philippa> d'oh, yeah. Wrong direction :-)
14:00:09 <jle`> miko__: :p
14:00:28 <Philippa> {;} show up for /every/ block including top-level though
14:00:48 <jle`> isn't ; just a part of layouting?
14:00:50 <Philippa> let, case, where, do/mdo...
14:00:56 <Philippa> no, layouting produces ;
14:01:06 <jle`> oh
14:01:08 <Philippa> which is to say: you can write it explicitly yourself
14:01:14 <jle`> then, as a part of "block" syntax?
14:01:30 <jle`> if there is such a thing
14:01:46 <monochrom> It is best to interpret "Monad gives you programmble semicolon" as "Monad gives you programmable would-be-semicolon-in-Java" rather than "programmable Haskell-semicolon"
14:01:54 <Philippa> yeah, but you'd have a reasonable argument for unifying lambda and case's uses of ->, and possibly the fundep and type family dependency ones
14:02:08 <Philippa> monochrom: heh
14:02:09 <maerwald> monochrom: I've never seen anyone misunderstand that to that point
14:02:16 <pikajude> hey, which library functions from Cabal should I use to copy something into the dist/build/{package} directory after the build step?
14:02:17 <Philippa> yes, that wasn't what I meant here :-)
14:02:31 <monochrom> becasue Haskell-semicolon is just a generic delimiter.
14:02:34 <Philippa> otherwise that would be firmly cheating because there'd be an infinite number of uses
14:02:35 <pikajude> buildDir from LocalBuildInfo is just "dist/build" and doesn't have the package name
14:03:01 <Philippa> sure, but aside from function arrows, -> is a generic separator much like commas
14:03:19 <Philippa> I mean, it's consistently used in function-like situations...
14:03:34 <monochrom> true. \x -> x+x
14:04:01 <Philippa> even case is just an n-way function :-)
14:04:03 <Philippa> but yeah
14:04:19 <Philippa> (it's literally the dual of an n-ary function)
14:06:23 <miko__> But really, is -> used anywhere outside of types? -> for lifing seems apporpriate. (as it is related to do and <-). So inc ->(Just 5).
14:08:07 <EvanR> i have ->(x,y,z)
14:08:19 <EvanR> er, i hate that notation
14:08:38 <Philippa> miko__: honestly? This is smelling of Wadler's Law a lot here
14:08:58 <buttons840> does anyone use default-extensions in the cabal file? what are acceptable default extensions?
14:09:01 <Philippa> pick something awkward in unicode, make it work, then work out what the right token should be, maybe?
14:09:02 <EvanR> and having ->, ->, ->, and <- floating around in the code looks ridiculous
14:09:07 <EvanR> four different things
14:09:58 <miko__> Philippa, the sematic is obvious, no discusion nesscarry :P
14:10:02 <Tuplanolla> What do you mean by default, buttons840?
14:10:09 <Philippa> they're /all/ either "describe a function-like thing" or "binding"
14:10:24 <EvanR> i forgot -> in case
14:10:43 <Philippa> seriously, eating up the token space to differentiate is even worse
14:11:05 <buttons840> Tuplanolla: e.g., if I put PartialTypeSignatures in the default-extensions part of *.cabal i don't have to put the corresponding language pragmas in the source files
14:11:11 <Philippa> maybe the stuff from the language of types from the stuff from the language of terms? But otherwise, yeah
14:11:28 <Tuplanolla> Oh, I don't use those, buttons840.
14:11:28 <monochrom> use unicode catface for now. argue over it later :)
14:11:45 <Philippa> yeah. Other things to talk about
14:11:55 <Tuplanolla> I do have this harmless configuration though, buttons840: http://tuplanolla.no-ip.org/tmp/.ghci-for-babies
14:12:15 <Philippa> (also, to jump back to earlier: if I had an 11.6" phone I think I'd be obliged to wear it on a large gold chain)
14:12:27 <miko__> ThatUnicode Han Character 'raise, lift up; recommend' (U+8209)
14:12:42 <Philippa> (it's pretty damn common as the smallest common laptop screen size)
14:12:46 <monochrom> oh yikes there are like 10 catfaces to choose from. I guess there is still a lot of argue over. :)
14:13:01 <Philippa> monochrom: Unicode says nya!
14:14:21 <EvanR> miko__: ap_f(x)... which is really just fmap f x
14:14:33 <EvanR> why do we need more syntax for this
14:15:17 <jnape> hello all! I'm curious, is there a notion of a "quasi-functor" that is some type that sports morphisms from Hask -> something more constrained? I ask, because I've been thinking about bifunctors in this context where one (or both) parameters might only support, say, endomorphisms
14:15:47 <miko__> Ok, I see, I see. This is pretty much a non-issue. I just wanted a small inconvience to go away, but it's not worth it, i get it. 
14:15:47 <jnape> an example of this could be Try[T] in scala, a coproduct of a Throwable or a T -- imagine being able to dually map over the Throwable and the T as you would with a bifunctor, but constraining biMapL to produce something covariant to a Throwable
14:16:39 <miko__> It gets a bit more tidy if you do stuff like f(x) ->a ->b (->a+4) (In my ad hoc syntax).
14:16:49 <miko__> But, no, it doesn't help much, and yes, I stop.
14:17:14 <miko__> I mean f x ->a ->b (->a+4)
14:18:43 <miko__> Will write my quasi quote, just to learn writing quasi quoters, tho.
14:19:39 <miko__> I'll stop to annoy. bye.
14:21:15 <EvanR> i cannot stand stabby arrow
14:21:50 <deank> vim
14:21:55 <deank> woops
14:22:00 <EvanR> by extension i cant stand expressions of the form x ->
14:22:22 <monochrom> but can you stand "-> y"?
14:23:29 <EvanR> no
14:23:37 <monochrom> achilles = -> foot  :)
14:23:43 <Philippa> jnape: mathematically speaking, you're asking for a functor that isn't a Functor
14:23:46 <EvanR> -> knee
14:24:11 <Philippa> (ie one that goes to some subcategory rather than being treated as a limited endofunctor on Hask)
14:24:20 <NextHendrix> achilles :: Arrow -> Heel -> Demise
14:24:38 <Philippa> there've been some tricks tried, you can do a fair amount with type classes or families to define what's in the target category
14:24:59 <NextHendrix> heel <- getArrow
14:25:21 <jnape> philippa: thanks for the reply, I suspected as much; I was wondering what generalizations, if any, you or anyone else are aware of that capture this idea (if it is, in fact, worth capturing)
14:26:01 <jnape> it seems extremely useful, but I can't seem to find a useful general construction for it that isn't my own invention
14:26:14 <Philippa> jnape: a Functor-style typeclass trying out some of the more recent extensions (ConstraintKinds?) and adding some parms?
14:26:25 <Philippa> I don't know if anyone's built a solid lib yet
14:26:33 <Philippa> I suspect it's "too obvious for anyone to do it"
14:26:49 <Philippa> (I hacked up just the bits I needed for a very specific case in 2011/2 IIRC)
14:27:43 <ertes> jnape: what would be an example use case that isn't already covered by simpler constructions?
14:27:49 <jnape> philippa: I see, and I've found an exchange about this where someone is asking something similar on a scalaz group, where the suggested path forward is, effectively, "synethesize your own type class for this use case and move on". But i'd like to be in the business of not writing these one offs, if that makes sense :)
14:29:04 <Philippa> jnape: yup! Figure out a suitably generic Functor class, work with it for a while, build other machinery and/or generalise from there while releasing? Someone's gotta do it, basically
14:30:18 <ertes> here is a fairly general functor class: https://hackage.haskell.org/package/hask-0/docs/Hask-Category.html
14:30:31 <jnape> philippa: thanks for the encouragement; I guess I was looking for a CYA that what I was suggesting wasn't obviously foolish and unhelpful because x and y, or that it's trivially doable with more foundational principles
14:30:45 <dibblego> jnape: you're probably describing this https://hackage.haskell.org/package/hask-0/docs/Hask-Category.html#g:2
14:31:01 <kadoban> Heh, I wrote a counting sort in haskell and apparently it's just always slower than 'sort' ... unfortunate. Wonder if there's a better way to do it. Any comments? http://lpaste.net/6963386565259165696 up to 100k elements, there doesn't seem to be any case where it's faster than sort for my use-case :-/
14:31:03 <ertes> =)
14:31:57 <jnape> ertes / dibblego: thanks! I'll check it out; it seemed like *someone* would have done something around this if it is, in fact, a reasonable thing to want
14:32:14 <EvanR> it seems incredibly specific
14:32:34 <ertes> jnape: i'm still not sure *what* it is you're asking for, but what dibblego and i linked is pretty much the most generic functor class you can have in haskell, as long as the mapping is still an actual function
14:33:07 <ertes> well, i suppose you could add constraints as well
14:33:12 <jnape> ertes: sorry, i was caught up in the exchange with philippa.
14:33:51 <ertes> jnape: a non-trivial example use case would help (perhaps even a trivial one)
14:34:05 <Philippa> ertes: adding constraints seems a good idea for anything written pre-ConstraintKinds
14:34:15 <jnape> what lead me to this question was thinking about a general coproduct that only supports endomorphisms for one side, and then making that something that behaves similar to a bifunctor
14:34:49 <Philippa> ertes: targetting an embedded language that isn't pointed for Hask-in-general or at all and doesn't operate on all Haskell data
14:34:57 <jnape> so, more concretely, consider Either l r where l must be some instance of a typeclass T, and must *always* map to another T
14:35:01 <Philippa> (for example: a typeful embedding of another programming language)
14:35:22 <jnape> but r supports r -> Hask
14:35:50 <jnape> so then it's a functor from (T l) x r -> (T l') x Hask
14:35:54 <ertes> jnape: that's not quite "endo" the way type classes work, but i think i see what you mean
14:36:00 <jnape> which, as others have pointed out, makes it not a functor, naturally
14:36:08 <jnape> but the question is, is it *something* useful?
14:38:11 <ertes> you can create a Bifunctor class similar to the Functor class from the 'hask' package and give it an additional associated type for constraints
14:38:40 <ertes> although for the specific case of Either even a constrained version of the regular Bifunctor class would suffice
14:40:12 <jnape> ertes: yes, I was just wondering if someone else has paved the way for this, so I don't re-invent the wheel or attempt to use my own terms in the face of canonical semantics
14:41:30 <jnape> thanks all! I'll think more about this, and please feel free to chime in if anyone has any further criticism or feedback
14:43:22 <Philippa> oh, it may be worth grabbing Conor McBride's recently tweeted slides from an '09 talk?
14:43:34 <Philippa> Has some further abstractions that're v.powerful
14:44:10 <dfeuer> Conor McBride has very powerful things, but he tends to target a rather advanced audience. 
14:44:34 <Gurkenglas> Aren't regular old Functors functors into a subcategory of Hask? F maps into types with form F (...)
14:45:41 <dfeuer> Gurkenglas: yes, but a full subcategory, which isn't very interesting.
14:45:43 <jnape> philippa: thanks, I'll see if I can find what you're talking about
14:45:58 <Philippa> jnape: was linked from @pigworker in the last week IIRC
14:46:04 <dfeuer> Er..
14:46:08 <dfeuer> No, I lied.
14:46:42 <Gurkenglas> *looks up "full"* yep, more stuff in [a] -> [b] than a -> b.
14:46:56 <ertes> also conor really wants your language to have dependent types =)
14:47:14 <Philippa> well. There's as /much/ stuff in [a] -> [b], but that's because countable infinity is a tedious number
14:47:27 <dfeuer> Gurkenglas: still, they're functors *from Hask*, not from any subcategory of Hask.
14:47:37 <ertes> so his stuff is typically anywhere between awkward to work with and impossible in haskell
14:48:13 <monochrom> cunning plan: do it in javascript instead :)
14:48:18 <dfeuer> ertes: more troublesome for *me* is that he assumes the reader is thoroughly familiar with dependently typed programming, category theory, and so on.
14:48:25 <jnape> ertes: good looking out, I'll take from it what I can with the implicit limitations. I guess more than anything i'm looking for a proper way to talk about these pseudo functors
14:48:50 <ertes> jnape: they're not necessarily pseudo
14:48:57 <Gurkenglas> So you want MathematicalFunctor F G where fmap :: (f a -> f b) -> g a -> g b?
14:49:03 <Philippa> dfeuer: nature of academia for you
14:49:03 <Gurkenglas> *f g where
14:49:14 <Philippa> making that assumption is what makes paying his bills viable, basically
14:49:16 <dfeuer> monochrom: you certainly *could* implement a dependently typed programming language in Javascript, but the last Javascript implementation might be obsolete by the time you finish.
14:49:39 <Philippa> dfeuer: eh. Tedious porting of that tutorial of Lennart's :-)
14:49:43 <dfeuer> Philippa: sure, but it makes cool-looking stuff hard to get into.
14:50:06 <Philippa> dfeuer: yeah, I agree. The problem is, he can't popularise one wave of stuff /and/ agitate for the next at the same time
14:50:32 <Philippa> it's easier to get people in a position to popularise and let them do it than it is to get people in a position to agitate at the "gets grant money" level, so...
14:50:40 <dfeuer> Philippa: I'm not blaming him. Just saying his work only goes so far to bring stuff to regular people.
14:50:50 <Philippa> ...well, here I am taking a fractional step towards popularisation
14:50:58 <Philippa> yeah, no argument there
14:51:14 <Philippa> that said: the range of stuff he does that others wouldn't is... valuable
14:51:38 <dfeuer> Philippa: oh, did you announce some cool thing you did above, when I wasn't looking?
14:51:57 <monochrom> Will you donate money to him if he customizes a talk for you?
14:52:05 <Philippa> dfeuer: nope, I just pointed some of the work at someone who's in a mood to implement (and hopefully document) stuff :-)
14:52:10 <dfeuer> Oh, for sure. Lots of value in people with deep mathematical knowledge who can bring it to the applied realm.
14:52:20 <monochrom> IMO the disease of FOSS is that no one ever thinks "maybe I'll donate money to that cool author"
14:52:35 <JuanDaugherty> wat
14:52:36 <jnape> gurkenglas: that is a useful approximation of what I'm talking about, yes
14:53:02 <dfeuer> monochrom: I'm not in a position to donate money at the moment. If that changes, then sure, I'd be happy to support such efforts.
14:53:04 <Philippa> monochrom: yup, software-only communism can't work
14:53:33 <Philippa> (and that's the bulk of the argument I have with GPL-everywhere advocates)
14:54:43 * JuanDaugherty reads "software only communism" as "FOSS in the context of capitalist control of software production in general"
14:56:19 <JuanDaugherty> computing would look very different today if FOSS had the same penetration as it did 30 ya, 10 y b4 gates became a philanthro capitalist
14:56:23 <jnape> philippa: s/in the mood/willing to eat the sin :)
14:56:45 <JuanDaugherty> *20 y b4
14:57:01 <monochrom> There is also another thing you could do to help him survive. You can write to the profs who decide about public research grants, and say "I am writing as a taxpayer, I want to nudge you towards giving more grant money to Conor because I like his research". Similarly, you can also write to his university to nudge towards increasing his salary.
14:57:52 <Philippa> JuanDaugherty: the distribution of food, shelter healthcare etc matters too
14:58:03 <mettekou> JuanDaugherty: are you saying free and open-source software is incompatible with capitalism in your statement about software-only communism?
14:58:18 <JuanDaugherty> Philippa, thanks for confirming my inference
14:58:22 <Philippa> monochrom: I don't know what the effective means of doing that given how things are currently structured in Scotland is, FWIW. You might wanna look that up before attempting
14:58:31 <JuanDaugherty> mettekou, no I am not
14:59:01 <Philippa> FOSS's penetration on microcomputers looked /very/ different 30ya
14:59:01 <JuanDaugherty> (since that would be to deny an established fact)
14:59:22 <JuanDaugherty> i know this is the post truth era, but hopefully not uih
14:59:28 <Philippa> yup, not only is it co-optable as hell, but that was the point of "Open Source" as distinct from the GNU folks
14:59:42 <mettekou> JuanDaughtery: uhu, but the contrast seemed so stark I would've thought you were hinting at mutual exclusion.
14:59:52 <Philippa> the GNU folks are just collectively a "single interest" group in an intersectional era
14:59:54 <mettekou> JuanDaugherty **
15:00:20 <JuanDaugherty> mettekou, ah
15:00:23 <Philippa> mettekou: a truly competitive GNU-style ecosystem is not compatible with capitalism
15:01:02 <Philippa> (it's not truly competitive until things like the collection of virtual instruments I have are GPL too and so're games with AAA levels of production effort)
15:01:09 <JuanDaugherty> the old capitalism has been grabbed by the u no wat
15:01:28 <mettekou> Philippa: yes, but when I refer to free and open-source software, I'm talking about the reality, not some GNU fever dream. 😏
15:02:29 <mettekou> Aren't the permissive open-source licenses far more popular than the copyleft ones, anyway?
15:02:33 <JuanDaugherty> because utopia
15:02:52 <NextHendrix> well you can torrent them so thats a sort of virtual DWTFYW license ;)
15:03:02 <monochrom> :)
15:03:22 <monochrom> "torrent Hackage now!"
15:03:37 <Philippa> mettekou: I'm very deliberately drawing a distinction here. BSD-style licenses clearly result in large-scale co-option of entire projects - often to the point of the open project's neglect - by commercial interests
15:03:38 <ertes> mettekou: in a parallel universe i'd be using GPL exclusively, but in the haskell community BSD3 is the most popular one =)
15:03:51 <Philippa> OpenSSL wouldn't be half the mess it is otherwise, for example
15:04:08 <ertes> so the least permissive license i could use without locking out 99% of the haskell community would be LGPL
15:04:40 <mettekou> Philippa: yet LibreSSL is a fork to sort out those issues under the OpenBSD license.
15:05:22 <NextHendrix> beerware is bestware
15:05:34 <Philippa> mettekou: sure, but look at what it took to make that happen
15:06:04 <Philippa> put bluntly: credible threats to the safety at various levels of pretty much everybody on the internet
15:06:37 <Philippa> (I hope we can agree that both are at the "don't assume we know what safe even looks like from here, /keep working/" stage?
15:06:39 <Philippa> )
15:06:44 <ertes> mettekou: in any case, it's important that copyleft exists as a concept and is used in practice…  it's really the only defence we have against increasingly closed systems…  in this day and age you can't even trust your own hardware anymore, because everything is tightly locked up
15:07:39 <ertes> so i believe it's important not to undermine what the FSF does…  after all they do it for us
15:07:49 <Philippa> and next thing you know, you're being DDoSed by lightbulbs and you have good cause to wonder what percentage of people's routers are pwned
15:07:56 <mettekou> Philippa: I don't think a GPL license would've changed the direction OpenSSL took. Is there any evidence for developers working for corporations messing OpenSSL up?
15:08:13 <Philippa> mettekou: Those are the wrong questions IMO
15:08:54 <Philippa> the question is: might someting have been done to get more resources on improving it /before/ everyone realised the bed smelled like a bear shat in it?
15:09:51 <EvanR> apt analogy
15:11:40 <mettekou> Philippa: How would you stimulate the allocation of resources to a project in a GNU-style ecosystem?
15:11:48 <Philippa> BSD-style licenses mean you have no actual leverage, only the hope of alignment of interest. Which is great when IBM decide you're interesting /and/ don't end up co-opting the entire project
15:11:50 <ertes> to be fair i don't think the state of OpenSSL has something to do with its licence
15:12:25 <Philippa> mettekou: having to send patches required to meet various compliance things upstream would've helped
15:12:45 <Philippa> of course, so would any of those compliance schemes catching blatant malpractice, but hey :-)
15:12:53 <ertes> it's a badly managed project in general
15:15:46 <mettekou> Philippa: But that's not an answer to attracting resources (mainly developer time in this case). How do you get a lot of (for enough scrutiny) amateur (in the original sense of the word, people who like to do something, not newbies) developers to spend their spare time on a project in a GNU-style ecosystem? 
15:16:09 <Philippa> you start by giving them genuinely spare time
15:16:34 <mettekou> How do you give spare time to someone? And who does the giving here?
15:16:35 <Philippa> you also figure out knowledge transfer within the relevant communities
15:17:00 <Philippa> okay, calling time on that right here and now
15:17:19 <ertes> you can't "give spare time", can you?
15:17:28 <Philippa> sorry, this is not the place for from-scratch armchair economics, let alone for trying to place the onus on one person to answer
15:17:50 <Philippa> ertes: depends how you define "give". You can certainly take away things that forcibly occupy time
15:18:14 <ertes> Philippa: you can train developers not to sign bad contracts =)
15:18:22 <Philippa> every last programming ecosystem that requires piles of time doing sysadmin is taking time away from its users in that sense
15:18:28 <Philippa> ertes: ... can we please not?
15:19:02 <Philippa> it's 2016, economic/financial coercion is a fact of life for many developers
15:19:09 <Philippa> just as it is for many others
15:19:18 <ertes> (actually it's 2017) =)
15:19:25 <ertes> but yeah, this is getting off-topic anyway
15:19:27 <Philippa> and a leap shitload, but yeah
15:24:27 <JuanDaugherty> yeah should be in blah and/or offtopic
15:24:51 <JuanDaugherty> i tend to route biz stuff to offtopic
15:27:34 <Philippa> we should also have some basic respect in here for the fact not everybody's financial circumstances are, to put it mildly, wonderful
15:28:23 <Philippa> not saying it's the only problem by any means, but if your joke might make someone who's on the breadline contract-to-contract wince, or someone on welfare? Go easy on us, yeah?
15:32:33 <jnape> philippa: found what I suspect you were referencing (http://strictlypositive.org/winging-jpgs/), and IFunctor and friends is very much circling what I'm getting at. Thanks again for the reference. Cheers
15:33:20 <Philippa> It's a relative of the one I had in mind, which may also be nearby in Conor's feed
15:33:30 <Philippa> (there's a crack about Oxford in the one I had in mind...)
15:33:46 <jnape> The feed is dense :)
15:33:52 <Philippa> (also the line "1, 2, 4, 8, time to exponentiate!" or similar - I saw the version in Nottingham)
15:33:55 <jnape> it was not trivial to consume
15:34:19 <Philippa> it's in a response to someone else commenting on how if you generalise what they've done "you'll have ... a powerful abstraction")
15:34:40 <Philippa> load up a week or two and search for "powerful abstraction", that might help :-)
15:34:50 <jnape> hmm ok that was the google fu I needed, excellent
15:40:09 <Liskni_si> speaking of licenses, is there an effort to exclude copylefted things from stackage or do I need to check every single transitive dependency?
15:48:40 <geekosaur> there is license information in cabal files, ideally they'd compute the resulting license and note resulting restrictions in metadata
15:48:57 <geekosaur> (macports does this so it knows what the buildbots can build packages for, for example)
15:49:36 <Liskni_si> well I found https://github.com/jpvillaisaza/licensor and https://github.com/jaspervdj/cabal-dependency-licenses
15:49:53 <Liskni_si> but I'd rather just not worry about licenses at all
15:50:09 <Tuplanolla> Choose GPL and stop worrying, Liskni_si?
15:50:26 <geekosaur> GPL has its own problems
15:50:41 <geekosaur> most GPL-is-religion types choose to regard those problems as benefits
15:50:46 <Liskni_si> Tuplanolla: I happen to work with a (partially) closed source codebase :-/
15:50:52 <Tuplanolla> Too bad.
15:51:05 <geekosaur> they also don't have to work in the business world (ever notice how commercial types won't touch gpl3 with a ten foot pole?)
15:51:19 <Liskni_si> Tuplanolla: "00:18:38 < Philippa> it's 2016, economic/financial coercion is a fact of life for many developers" :-)
15:51:54 <Philippa> Liskni_si: including those of us too asleep to remember which year it isn't! But yeah
15:52:10 <Philippa> (long-term welfare claimant here, as many of the old guard in chan are aware)
15:52:59 <Philippa> geekosaur: or at least won't admit to it
15:53:19 <Philippa> trade secrets + not shipping the software outside your organisation is a powerful combination still
15:53:59 <Liskni_si> Philippa: tried to find out more about your welfare situation, googled your name, found "The Complete List Of SJWs" => maybe we should get technical again :-D
15:54:30 <geekosaur> far as I'm concerned, RMS's meltdown over gcc vs. clang was a symptom of RMS not realizing that GPL3 is an impressive footgun
15:54:47 <Philippa> Liskni_si: I'm disabled and have never been able to work, that's all anyone particularly needs to know
15:54:49 <Liskni_si> geekosaur: when you say "ideally they'd compute ..." you mean it isn't done now and stackage is completely license oblivious, right?
15:54:57 <Philippa> what the old guard know is the /rest/ of the story, if that makes sense
15:55:11 <geekosaur> I've not noticed any transitive license computations on stackage.org at least
15:55:14 <Philippa> I used to spend a lot more time in here
15:55:30 <geekosaur> ...and you'd think fpcomplete would actually have a stake in doing so
15:57:50 <Liskni_si> okay, thanks both for your answers :-)
16:00:11 <Philippa> Liskni_si: it's generally a good idea to either avoid bringing up that site around here or simply refer to it as "SJWlist" btw. It's at best a blacklist and it doesn't much care whether /we/ think we're SJWs
16:00:35 <Philippa> it was the sting in the tail of a major community incident, basically
16:01:27 <Liskni_si> I think I decided not to take these issues into consideration during technical discussion
16:01:32 <Liskni_si> and if I didn't, I just did
16:01:50 <Liskni_si> (I, too, need to deliberately do a few things here and there to stay sane)
16:02:47 <Philippa> *nods*. I gather walking into -blah is unlikely to be much fun for me re non-technical, so hey
16:04:22 <hansihe> I remember reading an article about how in a dynamically typed language all types are an enum of all possible types, and uses that to argue that strictly typed languages are strictly more powerful than dynamically typed ones. Does anyone know what article that might have been?
16:04:46 <Philippa> might've been one of Bob Harper's?
16:04:58 <Philippa> there's a few tellings of the story out there, it's likely to use the term "unityped"
16:05:40 <Philippa> tends to ignore what's involved in having a useful reflective system, but everybody "loves" a good pissing war about who gets to own the terminology, right?
16:05:41 <hansihe> i think that's it
16:06:04 <hansihe> heh
16:06:12 <geekosaur> pretty much
16:06:44 <geekosaur> while thinking about it, ponder that quite a few of the folks active in the Haskell community are also active in the Perl or Python communities :)
16:07:18 <geekosaur> everything has its uses
16:08:56 <Tuplanolla> I'd raise a counterpoint, but I did recently pass PHP through a C compiler...
16:09:50 <Philippa> I hope you had appropriate medication to aid its passage :-)
16:10:23 * geekosaur reminded of a recentish discussion elsewhere which led to a confused person trying to compile rust source with gcc
16:10:48 <Rembane> Just use the -rust flag.
16:10:54 <Schoolmeister> Hey, I've got a question. What determines whether a data declaration can be derived for Eq and Show?
16:11:22 <jle`> Schoolmeister: usually it's if all of it sfields are also Eq or Show
16:11:32 <geekosaur> Schoolmeister, https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011 might be of interest
16:11:39 <jle`> there is a detailed description in the language spec (the Report), but i think that's a good intuition
16:11:48 <jle`> oh hey
16:11:59 <Gurkenglas> (Well, the derivaton happens each time, it just adds the sub-Eqs/Shows as constraints)
16:12:06 <geekosaur> but yes, there are instances for various standard types, and ADTs built from those types can be derived
16:12:45 <geekosaur> and if you use a type variable, it inserts a constraint on the derived instance so that it will be valid only if the type variable was instantiated as a type with that instance
16:14:27 <Schoolmeister> Hm, that makes perfect sense. Thanks a lot guys. I was asking because one of my declarations threw an error. Turns out it was using another declaration, but I forgot to derive that one.
16:14:47 <Schoolmeister> so simply a bit forgetful on my part
16:24:14 <ij> This page show that one of the three Megaparsec's imports gives you a Parser type, but I have no Parser although I've imported it.
16:24:16 <ij> https://mrkkrp.github.io/megaparsec/tutorials/parsing-simple-imperative-language.html
16:25:35 <ertes> any suggestions as to which text rendering library i should use for truetype?
16:26:50 <ertes> Rasterific seems like a good choice
16:27:03 <EvanR> freetype?
16:27:23 <geekosaur> Parser is a type alias defined (differently!) by Text.Megaparsec.Char, Text.Megaparsec.ByteString{,.Lazy} and Text.Megaparsec.Text{,.Lazy}
16:27:28 <geekosaur> ij ^^
16:27:36 <ertes> EvanR: freetype2 last release: 2012 =/
16:28:00 <geekosaur> hm, or not. I know Parsec does it that way...
16:28:21 <EvanR> im surprised any work was done on it in the last ten years
16:28:24 <ij> Ah, I had ".Char" imported, not ".String", so didn't have all. :P Thanks.
16:28:26 <EvanR> its a finished product
16:28:39 <geekosaur> right, String not Char, sorrt
16:29:12 <EvanR> ertes: the only issue i would think it has is its not functional
16:29:14 <geekosaur> you made the same mistake I always tdo initially, .Char is character parsers not the parser specialized to [Char] >.>
16:29:59 <EvanR> ertes: for extensively layout shananigans, theres harfbuzz
16:30:37 <ertes> EvanR: well, i've waited for an excuse to try Rasterific for a while now, so i'll let this be my excuse =)
16:31:07 <ertes> also i'm actually more comfortable using a pure haskell solution, if possible, and as far as i see Rasterific is one
16:31:38 <ertes> FontyFruity doesn't seem to have any foreign dependencies
16:32:24 <EvanR> do these pure haskell solutions have support for proprietary hinting engines
16:33:22 <ertes> unlikely
16:33:39 <EvanR> doesnt matter, just use font size 72pt ;)
16:34:55 <ertes> yeah, who cares about blurry fonts on 50000x50000 displays anyway? ;)
16:35:24 <EvanR> more secure anyway
16:35:46 <EvanR> now this clevery crafted version of comic cans cant execute arbitrary code
16:37:01 <EvanR> but now it doesnt even run node.js
16:37:31 <Welkin> EvanR: what...
16:39:16 <ertes> EvanR: you're reading my mind =)
16:39:37 <Squarism> Would you recommend a haskell-user-since-8-months switch to ghc 8? What features of ghc 8 would you miss the most, if you went back to 7.10? 
16:40:30 <ertes> Squarism: i recommend it, but right now i wouldn't miss any particular feature
16:40:58 <Squarism> Ok, good to know
16:41:15 <ertes> Squarism: ApplicativeDo is nice sometimes
16:41:18 <Welkin> switching is so easy that you won't even know the difference
16:41:28 <Welkin> unless you use the new features
16:41:44 <ertes> Squarism: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.0.1-notes.html#highlights
16:42:21 <ertes> despite praising it so much i haven't used TypeInType in practice yet
16:42:40 <Squarism> nice 
16:42:45 <ertes> which is probably the most noteworthy new feature
16:43:09 <ertes> to some people the new code generators might be of interest
16:43:21 <Tuplanolla> I like `TypeApplications`.
16:43:55 <ertes> yeah, indeed, but it's awkward to use with stuff you haven't written yourself, because the order of the type variables are unpredictable
16:44:09 <MarcelineVQ> ​:t sum @[]
16:44:14 <ertes> so you end up writing type signatures anyway, just to be safe
16:45:25 <ertes> PartialTypeSignatures can be used for a similar purpose, and it has been there since 7.10
16:45:41 <ertes> :t sum :: [_] -> _
16:45:43 <lambdabot> error:
16:45:43 <lambdabot>     • No instance for (Num t1)
16:45:43 <lambdabot>       Possible fix:
16:45:51 <ertes> :t sum :: _ => [_] -> _
16:45:53 <lambdabot> error:
16:45:53 <lambdabot>     Extra-constraint wildcard ‘_’ not allowed
16:45:53 <lambdabot>       in an expression type signature
16:45:57 <ertes> hmm?
16:46:05 <ertes> ok, bad example =)
16:47:38 <ertes> :t map :: (Int -> Word) -> _
16:47:40 <lambdabot> error:
16:47:40 <lambdabot>     • Found type wildcard ‘_’ standing for ‘[Int] -> [Word]’
16:47:40 <lambdabot>       To use the inferred type, enable PartialTypeSignatures
16:48:25 <ertes> constraint wildcards work, too, according to the docs
16:48:32 <ij> Suppose I parse some context/wrapper and then I want to return everything that's inside. Do I just "*> return"?
16:48:58 <MarcelineVQ> it's neat for filling in parts of sigs, foldr @_ @Int :: Foldable t => (Int -> b -> b) -> b -> t Int -> b
16:49:12 <Gurkenglas> ij, what's the type signature you want?
16:49:28 <ij> I want to get a Parser String.
16:49:36 <ij> with megaparsec
16:49:49 <Gurkenglas> No, the one we need to provide. Like you can say "(a -> b) -> [a] -> [b]" and we'll say "map"
16:51:11 * ij wraps his head around it
16:51:19 <Axman6> :t foldr @[]
16:51:21 <lambdabot> error:
16:51:21 <lambdabot>     Pattern syntax in expression context: foldr@[]
16:51:21 <lambdabot>     Did you mean to enable TypeApplications?
16:51:30 <Axman6> :(
16:51:49 <Axman6> yes I did lambdabot
16:52:31 <MarcelineVQ> I'll admit it's a little vague about what fills in though. popquiz, what does the first @application fill in for this: foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:56:24 <ij> I guess it's just `many anyChar'
16:59:36 <MarcelineVQ> if you guessed @type would fill in for t you're a genius, if you wonder why it would fill in t first then you're a human
17:00:12 <Tuplanolla> It's all explained in the manual, MarcelineVQ.
17:01:22 <Gurkenglas> Huh, literally Parser String. Didn't expect that ^^
17:01:45 <MarcelineVQ> Tuplanolla: yeah, though that one wasn't especially obvious to me :>
17:02:16 <Tuplanolla> I guess it's supposed to imitate the constraint ordering convention.
17:02:34 <Tuplanolla> Higher kinds first, order of appearance second.
17:04:13 <MarcelineVQ> it's more obvious with -fprint-explicit-foralls on because the ordering is more reflective of how things turn out, in my limited tests anyway, even though the variables in braces aren't technically available to fill in
17:16:51 <danpalmer> Anyone know how to reference the uniqueness of the default "id" field in a Persistent model?
17:17:23 <danpalmer> "UniqueFooId" didn't work, and you have to give the constraint name, not the field name "FooId"
17:18:27 <danpalmer> I've also tried creating my own with "UniqueFooId Id", but that errors with "unknown column in unique constraint "Id""
17:18:38 <Gurkenglas> Is there bracket' :: MonadIO m => m a -> (a -> m b) -> (a -> m c) -> m c?
17:20:33 <danpalmer> Gurkenglas: https://hackage.haskell.org/package/lifted-base-0.2.3.8/docs/Control-Exception-Lifted.html#v:bracket
17:23:23 <Gurkenglas> So MonadIO is also litter and MonadBaseControl IO is correct? …
17:23:53 <danpalmer> Gurkenglas: I don't know
17:24:36 <Gurkenglas> Hmm, somhttps://www.reddit.com/r/haskell/comments/5lnfn8/im_writing_my_first_haskell_library_and_i_have/dbx6grf/
17:24:49 <Gurkenglas> *Mh, someone who knows what they're doing reply to that
17:26:52 <geekosaur> Gurkenglas, in general lifting bracket through other monads is a potential problem, yes. not if the other monads in the stack can be treated as manipulating pure data and can't fail or throw exceptions (aye, there's the rub!)
17:28:06 <geekosaur> but MonadBaseControl has its own problems http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/ (title there is somewhat incorrect, it's not so much unsound as tricky to get right and current content reflects this)
17:46:03 <slack1256> what happens when you have a MVar (Mvar a) and you modify the one?
17:47:39 <duairc> Without using TypeInType (I want this to work on GHC >= 7.8 ideally), is there a way to explicitly match on the implicit kind variable of a polykinded type parameter of a type family?
17:48:13 <Philippa> slack1256: I'd expect it to just work - inner one refers to an a, outer one holds an /MVar reference to an a/
17:50:29 <slack1256> maybe a better question would be like this: with data State = S { value :: Int , events :: TChan Int }. If I got a MVar State, but I have a network listener that sends new values to the TChan Int. Does that network listener need to acquire the MVar?
17:50:41 <duairc> This works with TypeInType: http://lpaste.net/350790
17:57:24 <ertes> slack1256: yes
17:58:38 <ertes> slack1256: depending on your needs you might want to use a TVar State…  advantages: 1. you can "just read" (readMVar takes and puts back), 2. you can read the State and then the TChan within a transaction
17:59:47 <slack1256> I see, indeed looks better to use a TVar
18:01:20 <ertes> slack1256: in any case: any of the mutable variable abstractions (IORef, MVar, TVar, …) can hold anything you want:  from numbers over other mutable variables to IO actions and functions
18:02:12 <ertes> slack1256: MVar (IO ())  -- a thread can take IO actions from this MVar and execute them
18:12:00 <begriffs> I'm learning about how quickcheck works, and wondering what this change is for. Pre version 2, quickcheck defined newtype Property = Prop (Gen Result) but nowadays it is newtype Prop = MkProp{ unProp :: Rose Result }
18:12:18 <begriffs> What's up with the rose tree as part of a property?
18:13:00 <begriffs> (Where type Property = Gen Prop)
18:14:43 <ezyang> Anyone running Appveyor CI for GHC 8.0.1 and seeing "ghc.exe: getMBlocks: VirtualAlloc MEM_COMMIT failed: The paging file is too small for this operation to complete." 
18:34:01 <Squarism> hmm.. im not very happy with the readability of my haskell code. I guess an IDE with type inspections would help - but right now that seems to be only emacs?
18:34:43 <dfeuer> Squarism: you can probably get it with vim and sublime, but I can't promise.
18:35:21 <Squarism> would not go near VIM =D
18:35:34 <Squarism> But thanks for trying to help
18:48:05 <dinamyc> Squarism: i haven't used emacs, but atom has nice plugins.including haskell-ide and haskell-ghc-mod which has a type checking system.
18:49:28 <Squarism> dinamyc, i tried atom with plugins. Cant say i knew what i was doing but got plenty of errors
18:51:14 <dinamyc> Squarism you probably didn't install the binary dependencies on the system.
18:51:27 <Squarism> oh ok.
18:51:55 <Squarism> i remember it was ghc-mod that was complaining
18:52:58 <Squarism> ill try again
18:54:17 <ertes> Squarism: well, you could try emacs =)
18:55:51 <dinamyc> Squarism: i can't compare it with anything else, because i haven't used anything else for haskell.but the features are more than reasonable.
18:56:08 <dinamyc> though i really want to try leksah
18:57:45 <Squarism> ertes i think chris done wrote a blog post about emacs and RSI
18:58:18 <Squarism> dinamyc, yep.. definently wanna try it too - but it requires me to upgrade ubuntu
19:00:08 <dinamyc> Squarism: i couldn't install it by cabal. because of a conflict in the dependency "base"( >=4.0.0.0 && <4.9)! :/
19:02:55 <Squarism> you can run it using stack also
19:03:40 <Squarism> afaik
19:36:58 <cedricshock> Is there any existing work on using types like `Node a = Node a a` for graph libraries, using constraints like `Traversable Node`?
19:39:21 <cedricshock> A graph with nodes identified by `k` would then be approximately `Map k (Node k)`
19:46:38 <default> JOIN
19:46:47 <default> fuck you
19:47:16 --- mode: ChanServ set +q *!*@*/ip.198.7.62.204
19:49:23 <suzu> rofl
20:16:55 <marcx> hi. i am having issue with cabal repl. cabal install works fine, but if I try cabal repl I am just getting  "Preprocessing library test" right before being returned to shell
20:17:13 <marcx> test is the name of the module
20:27:47 <glguy> marcx: test can't be the name, modules are uppercased
20:32:24 <marcx> glguy Test
20:34:16 <glguy> marcx: you could put you .cabal file, the module, and terminal output showing what happened on lpaste
20:36:56 <mantovani> glguy: http://hackage.haskell.org/package/hasql ?
20:37:00 <ddellacosta> is there an Haskell+OpenGL-specific channel?
20:37:10 <mantovani> not all
20:37:20 <Axman6> I don't believe so
20:37:43 <ddellacosta> wondering if anyone knows if there is an idiomatic equivalent to gluUnProject in Haskell when trying to convert cursor position -> world coords
20:41:48 <Axman6> ddellacosta: have you looked at the gl package? AFAIK it should basically implement everything you can possibly do in OpenGL
20:42:39 <ddellacosta> Axman6: yeah, I see that it exists in GLURaw (http://hackage.haskell.org/package/GLURaw), but was uninterested in including another lib just for that function
20:42:50 <ddellacosta> but I suppose the reasonable answer to my question is perhaps "yes, use GLURaw..."
20:43:12 <ddellacosta> I'm using GLFW too, and was hoping something is hiding out there that I'm unaware of
20:43:18 <ddellacosta> should have mentioned that, sorry
20:43:46 <lpaste> marcx pasted “cabal repl error” at http://lpaste.net/350793
20:43:50 <Axman6> I'm not familliar enough with OpenGL to be able to give good advice on the topic
20:44:31 <geekosaur> marcx, that cabal file doesn't tell it what modules to include in the library
20:44:49 <Axman6> mantovani: you're not exporting any modules from your library. not sure if that's the issue, but it may be an issue
20:44:51 <geekosaur> so it probably gets confused about what to do
20:44:54 <ddellacosta> Axman6: yeah, the kind of annoying thing about doing OpenGL in Haskell is that OpenGL dictates so much of how the coding is done, that questions tend to get pretty specific :-/. Thanks for trying though
20:45:02 <Axman6> uh, marcx, not mantovani
20:45:25 <marcx> geekosaur I removed everything while still getting that error
20:45:58 <marcx> geekosaur I could post 41 line cabal, but would that help?
20:46:11 <Axman6> marcx: you aslmost certainly need exposed-modules: under the Library definition
20:46:43 <marcx> hmm, how come?
20:47:09 <geekosaur> marcx, to be honest for something like this it can be helpful to throw the whole thing on github/gitlab/whatever. also, what cabal version?
20:47:09 <Axman6> because without it it doesn't know what to load in ghci for one, but also it's an unusable library if you don
20:47:16 <Axman6> don't expose any modules*
20:48:08 <marcx> it is a dummy library. I am just using it to install a bunch of modules in repl, and then use that in one-file programs and when playing around in repl
20:49:06 <marcx> so I am not exposing any modules. but I could try and see if that will fix it
20:50:12 <haasn> since I can implement both ‘callCC’ and ‘evalCont’ without using recursion, this means that I cannot use continuations to “jump backwards”, right? Because if I could jump backwards, I could generate an infinite loop without using recursion
20:50:48 <mrlist> hi guys..  _ : xs == xs .... what should i put into the underscore?
20:50:50 <haasn> Trying to figure out in which sense continuations in haskell are different from ‘goto’ in imperative programming, and in my intuition of continuations it's like a goto where you can only jump “forwards”
20:51:18 <Axman6> mrlist: I don't know what you're trying to do, but that can definitely never return True
20:51:26 <mrlist> aww
20:51:29 <mrlist> ok thx
20:51:41 <mrlist> no identity smth smth?
20:51:44 <mrlist> im kinda new to haskell
20:52:12 <Axman6> not sure what you mean? equality is about structural equality, and those definitely have different lengths
20:52:18 <geekosaur> marcx, you should add them to other-modules in that case
20:52:29 <Axman6> ie, one is one element longer than the other
20:52:32 <haasn> mrlist: x : xs is a list that consists of ‘x’ prepended to ‘xs’. No matter what element you're prepending, you're always adding a new element to the list by writing that
20:52:33 <geekosaur> if no modules are listed in either, cabal thinks there is nothing to do
20:52:45 <mrlist> yeah cuz im looking for some function that when constructs 'doesnt' append to xs
20:52:59 <geekosaur> mrlist, (:) is a constructor
20:52:59 <haasn> Axman6: they don't necessarily have different lengths, but in the case where they have the same length, the (==) function can of course never return
20:53:03 <mrlist> long story short i have some function that does  (if b then _ else x):xs
20:53:04 <Axman6> mrlist: what should it do instead?
20:53:04 <geekosaur> it will construct something. no matter what
20:53:28 <Axman6> mrlist: if b then xs else x:xs?
20:53:34 <mrlist> but its veryyy long so to shorten it i rather put the if statement in the constructor :
20:53:44 <haasn> mrlist: (if b then id else (:) x) xs
20:53:49 <geekosaur> if b then id else (x:)?
20:53:53 <geekosaur> heh
20:53:55 <mrlist> NICEE
20:53:58 <mrlist> thxthtxthx
20:53:59 <Axman6> also, you can do (if b then id else (x:)) xs
20:54:00 <mrlist> :D
20:54:23 <Axman6> hey guys I think he should use if b then id else (x:)
20:54:52 <Axman6> mrlist: in case you haven't seen it, id is the function which does nothing, it returns its argument unchanged
20:55:03 <haasn> mrlist: (if b then [] else [x]) ++ xs
20:55:05 <Axman6> and (x:) is the same as (\xs -> x:xs)
20:55:14 <mrlist> yes thanks ill be using 'if b then id else (x:)'
20:55:37 <mrlist> i totally forgot i could just bring in the (:) into my if
20:58:07 <Schoolmeister> Hey, does anyone know what's wrong with my whitespace here? https://puu.sh/t9paF/a5afe9cb57.png
20:58:40 <glguy> Schoolmeister: the matchR and t <- don't line up
20:58:42 <Schoolmeister> getting a "parse error on do" error
20:58:54 <glguy> and then what's going on with the do f <- above it?
20:59:10 <geekosaur> when your first line doesn't end with "do", the indent must be to where the "f <-" is
20:59:19 <geekosaur> also, what exactly is that second "do" doing?
20:59:46 <geekosaur> (it''s not strictly illegal, but it's a bit weird)
21:02:09 <lpaste> glguy pasted “for Schoolmeister” at http://lpaste.net/350794
21:04:05 <Schoolmeister> Thanks, that fixed it, yes. To be honest, it was brainlessy copied for a textbook where it was written as such https://puu.sh/t9prE/9a52c6817f.png
21:04:32 <Schoolmeister> Not sure what the convention is for writing do's though, is putting it on a newline better?
21:05:29 <Schoolmeister> geekosaur: I'm still learning Haskell, but I don't think that second do is unnecessary? Or is it?
21:05:41 <pyon> When talking about zippers, is there some common name for the operation of “unfocusing” the currently focused element? (Besides comonadic “extract”, of course.)
21:05:55 <glguy> Schoolmeister: No, it's not unnecessary in this situation
21:06:22 <glguy> Schoolmeister: But it is important that the second do lines up with the "f <- factor"
21:06:38 <Schoolmeister> If i'm not mistaken, it first attempts that inner do, and if it fails it proceeds to the <|> return f, is that correct?
21:06:41 <glguy> and that the "<|>" falls between the second do and "symbol "*"" exclusive
21:07:13 <geekosaur> with the whole expression it makes a little more sense, yes
21:08:05 <Schoolmeister> Thanks a lot :)
21:26:39 <acevxz> exit
21:30:53 <buttons840> I can use the (^.) operator from lense without trouble if I just `import Control.Lense` but when I do `import Control.Lense ((^.))` i get type errors?
21:31:26 <pavonia> What errors?
21:32:33 <MarcelineVQ> oh that's interesting, import Control.Lens ((^.))  (^.) :: s -> Control.Lens.Getter.Getting a s a -> a       import Control.Lens   (^.) :: s -> Getting a s a -> a
21:32:50 <Koterpillar> that's the same
21:33:03 <MarcelineVQ> yeah but it's interesting that it qualifies the namespace
21:33:30 <buttons840> Couldn't match expected type ‘IO
21:33:30 <buttons840>                                       Data.ByteString.Lazy.Internal.ByteString’
21:33:33 <buttons840>                   with actual type ‘Response body00 -> body00’
21:33:52 <Koterpillar> MarcelineVQ: that's where it's defined
21:33:59 <buttons840> i don't understand the error, but that's what I get when I do a qualified import of ^.
21:34:21 <Koterpillar> buttons840: perhaps your import of Control.Lens shadowed something else?
21:34:51 <Koterpillar> buttons840: paste the relevant code (on a paste site, please)
21:35:48 <lpaste> Buttons840 pasted “No title” at http://lpaste.net/350795
21:36:34 <lucca> while this may not be surprising to some of you, template haskell is kinda coooool
21:37:02 <MarcelineVQ> lucca: it's pretty cool
21:37:08 <Koterpillar> buttons840: I'm guessing something like 'get' from wreq conflicts from something exported from lens by the same name
21:37:26 <Koterpillar> buttons840: try making _all other_ imports explicit
21:37:50 <pavonia> Shouldn't it report conflicting identifiers?
21:38:18 <buttons840> pavonia: is that only if one of the identifiers is used?
21:38:39 <Koterpillar> good point
21:38:53 <Koterpillar> buttons840: paste the full error, too
21:39:00 <pavonia> buttons840: Yes, when it doesn't know how to resolve the identifier
21:39:38 <lpaste> Buttons840 pasted “No title” at http://lpaste.net/350796
21:41:14 <Koterpillar> I have several guesses (fixity? instances?) but I'd try reducing the example first
21:42:22 <geekosaur> my first guess is that the (^. responseBody) wants to be applied to the result of get, not passed as a parameter
21:42:39 <Rotaerk> (^:
21:44:49 <geekosaur> (although. if it's CPSed then passed as a parameter would be correct --- but the rest of the expr would also need to be part of what is passed...)
21:45:34 <buttons840> i made all the other imports explicit and still see the same behavior
21:46:42 <buttons840> i need a bytestring related instance imported?
21:51:17 <buttons840> what types of "things" are there in haskell? functions, data types, typeclasses, instances -- anything else?
21:52:17 <glguy> all the values other than functions
21:52:41 <Koterpillar> modules
21:52:44 <glguy> new types, type synonyms
21:52:55 <EvanR> special syntax
21:53:03 <buttons840> glguy: can you import a type synonym?
21:53:11 <glguy> sure
22:04:15 <dmj`> patterns
22:12:25 <buttons840> so if I have `import Something (a, b)` what could `b` be that would cause `import Something(a)` to fail? i am not using b explicitly in my code
22:13:09 <Koterpillar> buttons840: minimize your example
22:13:13 <buttons840> a typeclass instance or something?
22:19:40 <aarvar> does enabling type families weaken type inference? I have some code with a polymorphic function in a where block, and if I enable type families then a monomorphic type gets inferred instead, causing a type error
22:25:32 <kadoban> aarvar: Does it have a polymorphic type annotation? Because if not, I thought it always ends up monomorphic, unless you turn on (off?) that monomorphism restriction extension
22:25:54 <kadoban> (I have no idea about type families)
22:26:20 <aarvar> the monomorphism restriction is unrelated I think
22:26:54 <aarvar> that only applies to functions with no explicit arguments, and turning it on/off doesn't change anything
22:27:37 <kadoban> Oh is that true? Maybe *looks*
22:28:47 <geekosaur> aarvar, TypeFamilies implies MonoLocalBinds
22:28:58 <geekosaur> which is distinct from the monomorphism restriction
22:29:00 <aarvar> ah
22:30:05 <aarvar> why is that?
22:31:07 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMonoLocalBinds
22:32:03 <geekosaur> "The rationale for this more conservative strategy is given in the papers “Let should not be generalised” and “Modular type inference with local assumptions”, and a related blog post." (http://research.microsoft.com/~simonpj/papers/constraints/index.htm and http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7)
22:32:43 <geekosaur> "You can switch it off again with -XNoMonoLocalBinds but type inference becomes less predicatable if you do so. (Read the papers!)"
22:32:44 <student> I'm having some problem with the Int and Integer data type, can someone take a look and let me know what i did wrong. I have been looking at it for quite a while :-( http://lpaste.net/350797
22:33:20 <geekosaur> :t (!!)
22:33:21 <lambdabot> [a] -> Int -> a
22:33:38 <geekosaur> you may want some fromIntegral-s on list indices
22:35:21 <student> geekosaur : what does that do?
22:35:41 <geekosaur> :t fromIntegral
22:35:41 <wespiser> :t fromIntegral
22:35:45 <lambdabot> (Num b, Integral a) => a -> b
22:35:45 <lambdabot> (Num b, Integral a) => a -> b
22:36:01 <kadoban> :t fromIntegral :: Integer -> Int
22:36:04 <lambdabot> Integer -> Int
22:36:11 <geekosaur> so, converts any instance of Integral to any instance of Num (which, if used as ... !! (fromIntegral to) ..., means to Int)
22:36:18 <kadoban> So if you have an Integer and need an Int, it's a good plan
22:36:33 <kadoban> You probably need the same thing on the first arguments to 'slice' there as well
22:36:54 <EvanR> :t fromInteger
22:36:55 <lambdabot> Num a => Integer -> a
22:37:00 <geekosaur> and note
22:37:04 <geekosaur> :t (+)
22:37:05 <lambdabot> Num a => a -> a -> a
22:37:21 <geekosaur> won't let you mix Int and Integer, it has to be the same type "a" all the way through
22:39:47 <lpaste> Buttons840 pasted “Explicit import of (^.) breaks things” at http://lpaste.net/8243351587573989376
22:40:36 <student> my apologize, i'm not really familiar with haskell yet, and I couldnt understand exactly which part of the code that i should alter. I would really appreciate an example... or a pointer of where i could read the example of it
22:41:09 <buttons840> Koterpiller: i shorted my example, same thing, explict import of the lense function breaks things, but importing all of lense works
22:41:55 <glguy> buttons840: <&> comes from lens, so you'll need to import it, too
22:42:16 <buttons840> :t <&>
22:42:18 <lambdabot> error: parse error on input ‘<&>’
22:42:27 <glguy> You should include the error messages when you paste code that doesn't work
22:42:44 <kadoban> > let n :: Integer; n = 2 in take n [1..5]
22:42:44 <wespiser> student: for the function you would like to use, what are the expected types?
22:42:46 <lambdabot>  error:
22:42:46 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Integer’
22:42:46 <lambdabot>      • In the first argument of ‘take’, namely ‘n’
22:42:52 <kadoban> > let n :: Integer; n = 2 in take (fromIntegral n) [1..5]
22:42:54 <lambdabot>  [1,2]
22:43:29 <kadoban> That would be a simple example, student. You need to do something similar (wrap with fromIntegral) at least the argument to !! and I think to slice as well, though it's not completely clear what slice that is.
22:43:31 <lpaste> glguy annotated “Explicit import of (^.) breaks things” with “cleaned up with do-notation” at http://lpaste.net/8243351587573989376#a829152971320197120
22:44:05 <glguy> buttons840: Once you fix the code as annotated there, you won't need to import <&>, either
22:44:15 <student> wespiser : I expected the output type to be  a list of [Integer]s
22:44:27 <wespiser> student: is that what + expects?
22:44:32 <buttons840> glguy: you're right, it's <&> and GHC was just reporting the error in a confusing place
22:44:40 <wespiser> student: read the error message
22:45:01 <buttons840> i thought <&> was fmap and in prelude for some reason
22:45:23 <student> wespiser : is there a special operation for Integer addition?
22:46:00 <wespiser> student: unfortunately I'm not aware of one, the standard is to convert Integer to Int via 'fromIntegral'
22:46:07 <kadoban> student: No. The problem you're having with + is that its operands must be the same type, both Integer or both Int for example.
22:46:21 <wespiser> student: see kadoban
22:46:32 <buttons840> what is <&>? is it fmap?
22:46:52 <glguy> <$> is fmap, <&> is flip fmap
22:48:42 <student> wespiser, kadoban : aaahhh, ok, i've changed that line to lazy2 (toList (slice (fromIntegral (to + 1)) (fromIntegral from) (fromList inList))) [(inList !! (fromIntegral to))] does this looks ok?
22:48:53 <buttons840> so in retrospec i should have replace the lens with a typehole and then then GHC reports the real issue, all the <&>'s are unknown operators -- thanks for the help glguy 
22:49:24 <kadoban> student: Possibly, GHC can tell you better than I can :)
22:50:20 <buttons840> does hoogle not include lens?
22:50:25 <student> kadoban : it compiles :-)
22:50:40 <kadoban> Default hoogle doesn't include pretty much anything. I use stackage's hoogle or hayoo
22:50:52 <kadoban> Or I think there's a beta hoogle somewhere that's supposed to be okay too, I forget where.
22:50:54 <glguy> buttons840: http://hoogle.haskell.org/?hoogle=%5E.
22:51:55 <Rotaerk> hmm https://www.haskell.org/hoogle/ should probably be made equivalent to that
22:53:06 <buttons840> good to know
22:53:49 <student> hahaha, now it wont produce an output because of the infinite list as the input (which is the challenge) :-D thank you for the help figuring the Integer and Int thing kadoban and wespiser :-)
22:55:28 <kadoban> Hehe, anytime.
22:55:33 <wespiser> student: infinite lists won't terminate, try putting a "take n" in front of there
22:55:49 <wespiser> student: print $ take 10 $ lazy ...
22:56:13 <kadoban> Well, I'm not sure Vector will be happy about you converting an infinite list to a Vector either.
23:00:01 <student> wespiser : looks like adding take doesn't have an effect :-( http://lpaste.net/350797
23:02:26 <student> i think the problem is when i try to take a sublist fron an infinite list via the Vector.slice function
23:03:12 <wespiser> student: is Vector lazy
23:03:58 <kadoban> student: Were you told to use Vector for this? I suspect it's not a good idea if your inputs can be infinite lists.
23:04:20 <student> wespiser : i suspect it's not
23:05:11 <student> kadoban : no i dont, it's just that i found the slice function from Data.Vector to be convenient to take a sublist from and to a certain list indices
23:05:22 <kadoban> student: You should probably base your implementation on 'drop' and 'take' and etc. instead and skip the Vector, that's what I'd do at least.
23:06:35 <student> kadoban : so if i like to get the sublist from the 1st to the 4th element of that infinite list, how do i do that with drop and take?
23:06:54 <kadoban> Think about it for a bit :) Me giving you the answer wouldn't be too interesting
23:14:01 <student> kadoban : ah i see, chaining drop and take to the list, ok ok :-D
23:14:40 <kadoban> Yep yep :)
23:16:57 <tdammers> what about .
23:17:29 <tdammers> (re overloading)
23:17:56 <tdammers> nvm, that convo happened internet years ago
23:18:40 <student> kadoban : it works now, just need to tidy up this indexing mess, thanks sir :-)
23:18:53 <kadoban> student: Glad you figured it :)
23:21:13 <haasn> Re: my question earlier about ContT and infinite looping / “backwards goto”; my reasoning was invalid, because I can combine the recursion-free callCC with a parameter that recurses to generate an infinite loop
23:21:17 <haasn> e.g. callCC $ return . fix
23:24:42 <haasn> (this will give me a “label” that I can `goto` to, even backwards)
