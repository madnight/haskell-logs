00:01:46 <mounty> Thanks Cale;  I've asked in #yesod which is the best place I reckon.
00:04:45 <Cale> mounty: It might be useful if you put the source code which defines the type on lpaste.net or something...
00:10:12 <Guest70023> wow
00:12:23 <Cale> ?
00:21:25 <Guest70023> nobody speak a word
00:23:18 <Guest70023> exit
00:23:29 <Guest70023> let me leave here
00:23:37 <Guest70023> quit
00:30:45 <stobix> Are there man pages for the haskell modules?
00:32:14 <lu1> what happened
00:32:28 <lu1> why so many people has quit?
00:33:26 <stobix> lu1: have they? I just arrived, but if it happened suddenly, it's probably a netsplit going on.
00:35:18 <lu1> glowcoil (~glowcoil@ell.io) has quit (*.net *.split) <- something like this
00:36:02 <lu1> I'll google what is netsplit, I have not very much experience about IRC
00:36:22 <lu1> em, I'm not have much experience
00:37:16 <stobix> Yeah, if a lot of them happened at once, I'd guess that it's something like different IRC servers lost contact with each other temporarily. The ones on the other server probably got the message that the people here quit as well. It will sync itself back in a little while.
00:37:52 <stobix> (And with "server" I mean machines hosting freenode, I guess.)
00:38:02 --- mode: jackson.freenode.net set +o ChanServ
00:42:20 <stobix> Huh, yeah, there's a lot of quitting going on, with a lot of timeouts. I'd say netsplit, or some dark magic I don't know about.
00:42:56 * stobix has the quits/joins in another window, so he mostly doesn't notice stuff like that.
00:44:17 <lu1> dark magic hah hah hah
00:45:50 <EvanR> a few days ago a server message said theyd be working on the railroad
00:46:31 <stobix> Railroad?
00:46:36 <lu1> railroad , you mean what?
00:46:40 <lu1> a train?
00:46:42 <EvanR> all the live-long day
00:47:13 <stobix> heh, I thin you just pwnd 2 non-americans with your crazy references. ;)
00:47:21 <stobix> think
00:47:50 <lu1> em, I'm a chinese man
00:47:51 <xpika> does the ST monad use IORefs under the hood ?
00:47:54 <stobix> Why is there no cabal install_all_the_man_pages_plx
00:49:19 <stobix> lu1: Nice. And I'm Swedish. Nin2 hao3. :) So both of us are non-americans. 
00:49:38 <lu1> sure, you are right
00:53:08 <stobix> lu1: If I'm not mistaken, the railroad thing is a reference to an old song, so don't worry if you didn't get it. :)
00:55:12 <lu1> Thanks for your tips.
01:07:30 <lu1> q
01:39:28 <athan> Would a co-applicative have any use?
01:39:59 <athan> (>*<) :: (f a -> f b) -> f (a -> b) -- ?
01:40:29 <athan> I remember lax monoidal categories are isomorphic to the traditional applicative shape
01:41:15 <lyxia> (>*<) is sometimes used as f a -> f b -> f (a, b)
01:41:27 <lyxia> which is not equivalent to Applicative if f is contravariant
01:42:01 <sgronblo> whats the easiest way to download a file over https?
01:44:12 <athan> lyxia: Oh woah, thank you
01:44:37 <athan> ah wait, yeah that's right, that's the monoidal operation I think
01:44:58 <athan> and strength is (a, f b) -> f (a,b)
01:45:13 <athan> sgronblo: facebook :v
01:48:09 <lyxia> athan: yeah
01:48:22 <sgronblo> athan: ?
02:05:41 <ocramz> hullo all!
02:08:24 <polll> Hi!
02:15:02 <Insanity_> Hey :-)
02:17:13 <polll> How do you convert a random int created with randomRIO to Word8?
02:17:53 <lyxia> fromIntegral
02:19:48 <EvanR> dont you want to choose a random Word8 instead
02:22:19 <polll> I think so, is there already a function for accomplishing that? 
02:27:32 <stobix> Speaking of randomRIO, why won't this build me an infinite list that I can take the first elements from: http://pastebin.com/2TbLqT8F  Do I force evaluation somehow?
02:27:58 <EvanR> polll: randomIO works for anything with a Random instance
02:28:06 <wz1000> I wrote an applicative like MaybeT, but which executes all the side effects of its arguments, even if a few fail. How good/bad/evil is this?
02:30:04 <wz1000> For example, f <$> fail "" <*> liftIO $ putStrLn "something" will print something
02:30:44 <wz1000> Of course, this means that ap and (<*>) have different semantics
02:35:51 <cocreature> wz1000: (observably) different semantics for ap and (<*>) are generally confusing. I would make a newtype that has your custom applicative instance but does not have a Monad instance
02:36:07 <cocreature> whether that instance is lawful I don’t know, I haven’t thought about it :)
02:38:05 <polll> This is a very beginner question, but what's the best way to deal with: "Couldn't match expected type ‘Word8’ with actual type ‘IO Word8’"? 
02:39:00 <cocreature> polll: use do-notation, if you show us the code that is causing this error we can probably help you rewrite it
02:39:16 <cocreature> polll: note that Word8 and IO Word8 are very different things so you can’t just convert from one to the other
02:39:53 <stobix> polll: randomRIO returns different things depending on context, so just do something like randomRIO (65::Word8,97::Word8) and you'll get a Word8 out.
02:39:57 <cocreature> the former is a single byte, the latter is a computation that will return a single byte when it is executed, this could involve reading files
02:40:24 <stobix> (also listen to cocreature)
02:40:47 <wz1000> cocreature: The use case for this was to log all parse errors before failing, instead of simply failing after hitting the first parse error.
02:41:05 <wz1000> Is there a better way to do this?
02:42:17 <cocreature> wz1000: making a parser that can continue to parse after encountering an error and thereby report multiple errors, is more complex than that. in particular you need to figure out what your parser should expect after it encounters an error
02:43:16 <wz1000> cocreature: In the case of simple applicative parsing, wouldn't this work?
02:43:52 <wz1000> And wouldn't -XApplicativeDo ensure that the parser gets as far as (naively) possible, without failing
02:45:11 <wz1000> cocreature: In my case, if the parser encounters an error, the final result will be a failure no matter what
02:51:00 <cocreature> wz1000: Applicative parsers cannot depend on the result of the previous parser but they still depend on how much they consume from the input string
02:52:01 <cocreature> wz1000: I guess what I’m trying to say is that solving this by hacking the Applicative instance might seem like a nice idea but you’re probably better off just explicitely handling the failures in your parser and continuing to parse
02:55:01 <wz1000> cocreature: Ah. I wasn't clear, but I'm not doing general parsing here. I'm reading JSON(as an Aeson Value) into a record. As such, there are no effects of the kind you mentioned.
02:55:42 <cocreature> wz1000: do you have some sample code to illustrate what you’re trying to do? I think I still don’t really understand it
02:57:00 <wz1000> cocreature: I get JSON that is preparsed by aeson into a Value. Now I try to convert it into a record by looking up keys in the Value and checking if they are in the correct format.
02:57:06 <wz1000> So it isn't parsing at all
02:57:15 <wz1000> Unfortunately, I can't share code.
02:58:54 <cocreature> ah ok, in that case it could work
03:00:21 <polll> cocreature: Here's what I'm up to: (http://lpaste.net/1995038078795776000). I need to generate a list consisting of 802 Pixels (3 word8 values). I suspect there may be a more efficient way of achieving this using take & cycle. 
03:05:09 <cocreature> polll: alright so in line 87 you can put "redPixels <- replicateM 806 randomIO", then do the same for the green pixels and blue pixels in the following two lines. in the last statement you can then use "SetColors 0 (zipWith3 Pixel redPixels greenPixels bluePixels)"
03:05:40 <cocreature> randomRIO 0 255 should be equivalent to randomIO for Word8
03:11:51 <polll> Thank you so much, cocreature!!! 
03:12:18 <cocreature> np
03:31:05 <ocramz> do monomorphic container types result in faster execution? I.e. if I pin my content type to Double
03:31:21 <ocramz> or perhaps faster compilation?
03:38:36 <sbrg> ocramz: I think it's possible wrt. performance because of specialization. but I think ghc is really good at specializing, so it probably already has specialized the functions to the types you are using
03:39:10 <cocreature> unboxing of fields in a datatype works only for strict monomorphic fields iirc
03:50:24 <erisco> what is Either for three options?
03:52:40 <erisco> other than the verbose Either a (Either b c) or Either (Either a b) c
03:56:17 <jameseb> erisco: you could define your own Either3 a b c = Left a | Middle b | Right c
03:56:34 <rmrfroot> erisco: what kind of possibilities are you trying to express? 
03:56:38 <jameseb> not sure if there's a library with something like that already
03:57:13 <jameseb> it may be better to have a more specific type depending on your requirements
04:01:27 <rmrfroot> been looking at tasty for testing, currently using hspec. anyone with an opinion on pros/cons of the two frameworks?
04:04:19 <c_wraith> erisco: I'd argue the algebraic blindness argument applies even more strongly to a 3-possibility generic sum type
04:04:40 <c_wraith> erisco: https://github.com/quchen/articles/blob/master/algebraic-blindness.md
04:06:30 <ocramz> rmrfroot : Tasty seems to have more functionality.. why do you want to switch?
04:06:48 <ocramz> like, have you found limitations in Hspec? 
04:08:52 <sbrg> you can use hspec with tasty
04:09:23 <rmrfroot> ocramz: i don't have a specific issue, i'm very content with hspec. just wondering if tasty could improve my testing. 
04:10:02 <rmrfroot> sbrg: ah, interesting!
04:11:50 <hal_> How do people deal with QuickChecking functions working on floating-point numbers? Epsilon? Or skip it altogether?
04:19:44 <ertes> hal_: if your functions are sufficiently general you can test with Rational
04:20:18 <ertes> there are also various versions of computable reals (CReal), which might be useful for testing
04:21:13 <ertes> of none of those work for you either, either use epsilons or ensure that float inaccuracies aren't possible
04:22:18 <maerwald> quickcheck is poor mans SMT solver
04:23:28 <sgronblo> All I wanted was to DL a simple file in Haskell... https://github.com/bos/wreq/issues/88
04:24:27 <ertes> sgronblo: does http-client complain?  maybe it's a wreq issue
04:24:42 <ertes> sgronblo: try to use http-client or its higher-level cousin http-conduit
04:25:14 <ertes> (i'd recommend using one of those anyway, if you just want to download a file…  wreq is more useful when you need sessions)
04:25:38 <sgronblo> ertes: Ok, I'll give it a try.
04:26:08 <ertes> sgronblo: try http-conduit…  it has transparent TLS support
04:27:52 <sgronblo> https://github.com/commercialhaskell/jump/blob/master/doc/http-client.md 404
04:28:16 <sgronblo> haskell eco-system... :(
04:28:27 <sw1nn> MoveOnLad21
04:28:56 <ertes> sgronblo: https://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Simple.html
04:29:39 <ertes> sgronblo: https://hackage.haskell.org/package/<enter package name here> =)
04:29:45 <sgronblo> thanks
04:41:38 <sgronblo> ertes: seem to be getting the same error
04:41:53 <sgronblo> hashtag haskellproblems
04:43:32 <ertes> sgronblo: then you should report that as an http-conduit or http-client-tls bug
04:44:07 <ertes> in the meantime we have a curl binding, which should work
04:44:20 <ertes> @package curl
04:44:21 <lambdabot> http://hackage.haskell.org/package/curl
04:44:50 <hal_> Thanks ertes
04:46:19 <sgronblo> lol "The workaround is simple if the API you use gives control over TLS parameters supportedHashSignatures or supportedCiphers: you just need to enable ECDSA in one or disable it in the other."
04:46:23 <sgronblo> https://github.com/snoyberg/http-client/issues/236
04:57:38 <cocreature> sgronblo: the hs-tls issue for this has been fixed and the fix is apparently released in 1.3.9. have you tried using that?
05:00:02 <ertes> hal_: epsilon-testing can be a good idea though…  sometimes a better idea than the other alternatives, because it can reveal numerical instability
05:00:51 <sgronblo> cocreature: I'm not the maintainer of http-client. Wouldn't it be kinda tricky for me to upgrade the version for it?
05:01:50 <ertes> sgronblo: http-client-tls has the following dependency: tls >= 1.2
05:01:56 <sgronblo> at least the error I was having with Network.Wreq seems like it might have been caused by the same problem.
05:01:58 <ertes> so 1.3.9 will just work
05:01:59 <cocreature> sgronblo: not really, http-client-tls has no upper bound for tls, so you can just build it against a newer version
05:02:03 <ertes> (dependency-wise)
05:02:18 <sgronblo> ok so how do i check my exact versions in my project?
05:02:21 <ertes> sgronblo: wreq uses http-client
05:02:31 <sgronblo> i using stack
05:02:54 <cocreature> put tls-1.3.9 in your extra-deps
05:03:11 <cocreature> or bump your snapshot to one that includes tls-1.3.9 but I’m not sure if there is one
05:03:11 <ertes> sgronblo: i'm not familiar with stack, but this should work to see your version of tls:  stack exec ghc-pkg list tls
05:03:14 <cocreature> nightly maybe
05:03:24 <sgronblo> will that cause a rebuild of http-client with that version then?
05:03:28 <cocreature> yep
05:03:41 <cocreature> package versions have to be consistent in a project
05:04:02 <cocreature> so there can be only one version of tls meaning that http-client-tls will be rebuilt
05:05:04 <sgronblo> so where do i put extra-deps?
05:05:08 <cocreature> in stack.yaml
05:06:15 <sgronblo> ok any idea how to verify which version of hs-tls my project is currently built with?
05:06:30 <cocreature> use the command ertes showed you
05:06:43 <cocreature> iirc there is also "stack list-dependencies"
05:07:06 <sgronblo> thanks. i also ofund it now.
05:07:16 <sgronblo> 1.3.8
05:07:24 <ertes> almost there =)
05:08:02 <sgronblo> "Warning: Some extra-deps are neither installed nor in the index:"
05:08:18 <sgronblo> what next?
05:08:54 <cocreature> run "stack build"
05:09:47 <sgronblo> I added "- hs-tls-1.3.9
05:09:58 <sgronblo> " to the end of the extra-deps AND ran stack build
05:10:09 <ertes> sgronblo: the package name is "tls", not "hs-tls"
05:10:37 <sgronblo> ertes: oooh, yeah
05:10:42 <sgronblo> hs-tls is just the github repo name...
05:11:21 <sgronblo> ok now i have a version conflict
05:11:42 <sgronblo> cryptonite-0.19 must match >=0.21 (latest applicable is 0.21)
05:12:42 <cocreature> if you can bumping the snapshot is probably the easiest solution, otherwise add cryptonite-0.21 to your extra-deps and hope you don’t get a long chain of broken dependencies
05:12:58 <cocreature> nightly-2016-12-31 contains tls-1.3.9
05:13:06 <sgronblo> so how do i bump the snapshot?
05:13:22 <cocreature> there is a "resolver" field in stack.yaml
05:13:30 <cocreature> you can put "nightly-2016-12-31" there
05:13:41 <sgronblo> isnt there some safer way to do it?
05:13:51 <ertes> couldn't stack just use hackage?  i imagine this kind of version chasing to be rather tedious
05:13:52 <cocreature> safer how?
05:13:53 <sgronblo> like "find newest snapshot that still works" plz
05:14:31 <cocreature> well 1.3.9 is just a few days old, so you are going to need to use a pretty recent nightly snapshot
05:16:02 <sgronblo> ok, giving it a try
05:16:24 <xenon-> getting pretty horrible haskell auto indenting in emacs, how can I make it better? http://lpaste.net/350930
05:20:33 <sgronblo> omg! it finally works. thanks so much to everyone who helped me!
05:20:54 <NextHendrix> xenon-: keep hitting tab
05:21:10 <NextHendrix> xenon-: what modes are you using
05:22:16 <cocreature> sgronblo: glad you worked it out
05:23:02 <xenon-> NextHendrix I googled a bit before asking, and that was recommended.. but I have to hit tab after every line to get proper indentation, including after every line of a do block.
05:23:40 <NextHendrix> xenon-: have you got ghc-mod and haskell-interactive-mode installed
05:24:15 <xenon-> moment, let me check
05:24:22 <NextHendrix> sometimes the tab gets carried away to the right hand side a little, sometimes i put a fake deriving (Show) in to ping it back to the left then just delete it later :D
05:25:05 <xenon-> haskell-mode and haskell-indent are active in the source buffer
05:25:18 <xenon-> ghc-mod isn't, and I don't think it is installed. I can't find it in M-x
05:25:37 <cocreature> maybe try enabling haskell-indentation-mode instead of haskell-indent-mode
05:25:41 <xenon-> I have haskell-interactive-mode
05:25:44 <cocreature> one is very simplistic and dumb but I forgot which one it is
05:29:00 <xenon-> ok haskell-indentation is not completely braindead at least :)
05:29:33 <xenon-> considerable improvement
05:29:39 <xenon-> still failed on then do though:
05:29:53 <xenon-> http://lpaste.net/350931
05:29:59 <haskell3242> is it possible to have phantom types that still act like specialized types without having to "unpack" them? e.g. if I have newtype T A = Int, I'd still like to be able to call f :: Int -> Int on types T A without having to pattern-match away T
05:30:12 <xenon-> can we get it even better?
05:30:14 <haskell3242> sorry, newtype T A = T Int
05:30:44 <xenon-> to make it worse, tab does nothing when it failed to properly indent print 20 after else do
05:31:17 <ertes> xenon-: haskell-mode has a number of indenters with haskell-indent-mode being the default
05:31:43 <ertes> xenon-: that one is indeed very manual, but there is haskell-indentation-mode, which is a lot more "do what i mean"
05:31:54 <ertes> xenon-: see haskell-mode-hooks
05:32:26 <mniip> haskell3242, you can use a type synonym
05:32:40 <ertes> xenon-: *haskell-mode-hook
05:32:48 <xenon-> ertes I am trying haskell-indentation-mode now, it is still rather poor. http://lpaste.net/350932
05:32:57 <mniip> oh wait
05:32:58 <mniip> hmm
05:33:04 <mniip> a type synonym family thenn
05:34:02 <ertes> xenon-: i would expect that you only need to indent the first line with that one though
05:34:04 <xenon-> maybe I am asking for too much to get extra indenting after every do, and beginning of line when I declare a function? I don't know :|
05:34:18 <ertes> xenon-: but i'm not really familiar with it (i use haskell-indent-mode)
05:34:52 <xenon-> ertes I was getting this with haskell-indent-mode: http://lpaste.net/350930
05:35:02 <ertes> xenon-: also note that it has a number of options of its own
05:35:14 <ertes> customize-group haskell-indentation
05:35:36 <ertes> xenon-: yeah, as i said, you need to cycle a lot with haskell-indent-mode =)
05:35:46 <ertes> i just got used to it
05:35:52 <haskell3242> mniip: thanks, I'll look into it
05:36:05 <haskell3242> mniip: it seems like just using type instead of newtype fixed my current problem though
05:36:44 <haskell3242> mniip: oh wait i don't think it did
05:36:59 <ertes> i think i'm going to try haskell-indentation-mode again…  it's really awkward that it doesn't automatically fill in function names though =/
05:37:11 <ertes> indent-mode does that, which is really nice
05:37:22 <haskell3242> mniip: just using type doesn't allow the compiler to differentiate between two different types even though you used a phantom parameter, right
05:37:46 <mniip> well you are asking for the impossible then
05:38:16 <mniip> differentiating between types but not differentiating between them
05:39:41 <xenon-> ertes honestly I have not had this poor auto indentation in any language and editor combo.. i am starting to think whether just indenting manually would be the least of evils
05:40:12 <lordcirth> I indent manually - it's hardly a major task in a good editor
05:40:53 <lordcirth> vim with :set expandtab tabstop=4 shiftwidth=4 
05:41:34 <ertes> xenon-: it's more a problem with haskell than with the indenter though…  indentation-mode should *usually* do a good job of predicting where you want to go, and you need to cycle when it gets it wrong
05:41:46 <ertes> there are no syntactic clues like in most other languages (e.g. braces)
05:41:56 <ertes> or rather: you'd typically not use them
05:41:59 <xenon-> do should be clue enough to indent
05:42:25 <ertes> sure…  perhaps it's a sign that haskell-mode could use some extra hands =)
05:42:34 <xenon-> so should this:       foo :: String 
05:46:47 <xenon-> else print 20<newline>, stays on same indentation level as else
05:46:58 <xenon-> so plenty of syntactic clues, it is just that they are ignoring them
05:51:04 <ertes> xenon-: it doesn't know whether you want to continue the 'else'-branch or end the 'if'
05:52:21 <xenon-> ertes continue how? with >>? I can't see how that is a sensible default
05:53:47 <kuribas> I cannot decide how to implement optional arguments: "myFunc arg1 (optArg1 <> optArg2)" or "myFunc arg1 [optArg1, optArg1]"
05:54:11 <ertes> xenon-: even indentation-mode doesn't really "understand" haskell layout…  it's smarter in some respects, dumber than others compared to indent-mode…  if you really want a fully layout-aware mode, you can try structured-haskell-mode
05:54:15 <kuribas> where "optArg1, optArg2 :: Endo MyFuncArguments"
05:54:23 <ertes> xenon-: it tries to do for haskell what paredit does for lisp
05:54:50 <kuribas> ertes: I'd like to rewrite haskell-indentation.el
05:55:17 <kuribas> ertes: write an purescript -> emacs backend, then rewrite the whole thing, with a proper parser...
05:55:38 <ertes> kuribas: why purescript?
05:55:45 <kuribas> ertes: because emacs lisp sucks
05:56:09 <ertes> kuribas: yes, but why purescript?  you could just use haskell-src-exts, if you wrote the backend in haskell
05:56:12 <kuribas> syntax for HOF is so convoluted.
05:56:24 <kuribas> ertes: because purescript is strict
05:56:42 <ertes> … so?
05:56:49 <kuribas> elisp is also strict
05:57:06 <kuribas> enforcing lazyness has a large overhead.
05:57:47 <ertes> i don't understand why that's even relevant
05:58:06 <ertes> write backend in haskell, communicate with it via elisp
05:58:25 <kuribas> ertes: the goal for haskell-indentation.el is to be pure elisp.
05:58:40 <ertes> ah…  you want to compile to elisp
05:58:45 <kuribas> yeah
05:59:31 <kuribas> ertes: So the incremental parser would generate an AST efficiently, then that could be used for any operation on the sourcefile.
05:59:52 <ertes> i see…  not sure i like the idea of using purescript though…  the sole thought of using bower or pulp for…  anything…  makes my stomach turn
05:59:54 <kuribas> ertes: for example search/replace on types, automatic insertion of INLINE and SPECIALIZE pargams.
06:00:27 <kuribas> ertes: Yeah, those shouldn't be necessary.
06:00:43 <kuribas> ertes: only the haskell compiler part of purescript.
06:00:59 <kuribas> ertes: and the generated code should be stand-alone
06:01:48 <mettekou> ertes: What's wrong with Pulp in your opinion?
06:01:55 <ertes> i'd rather write a backend in haskell and use a minimal elisp script for communication than binding the whole elisp API, which is also completely incompatible with the way purescript works (remember: elisp uses dynamic scoping for virtually everything), and then also reinventing a haskell parser
06:02:40 <ertes> mettekou: the fact that i have to use it
06:02:52 <kuribas> ertes: binding the API would be done in libraries.
06:03:02 <kuribas> ertes: using the "foreign" keyword.
06:03:29 <mettekou> ertes: So, nothing at all, really. 😏
06:03:33 <kuribas> ertes: since emacs-24 it has lexical scope.
06:05:08 <ertes> mettekou: GHC never forced cabal-install down my throat, GCC never forced GNU build tools down my throat
06:06:07 <kuribas> ertes: I think purescript is surprisingly compatible with emacs lisp.
06:06:43 <ertes> kuribas: well, you would have to write a library for dynamic scoping which would look very similar to IORefs with a dynamic global namespace
06:06:44 <kuribas> ertes: objects => hashtable, lists => Data.List, algebraic types => symbolic lists.
06:07:02 <kuribas> ertes: why?
06:07:18 <ertes> kuribas: as i said elisp uses dynamic scoping for virtually everything
06:07:37 <kuribas> ertes: and I said it supported lexical scope since 24?
06:07:50 <ertes> kuribas: that's no use, if nobody uses it =)
06:08:02 <xenon-> you can use it in all your .el files. I do
06:08:30 <kuribas> ertes: what does that matter, as long as the compiler uses it?
06:08:55 <kuribas> ertes: it doesn't interfere with lexical scope...
06:09:05 <kuribas> well except for callbacks maybe
06:09:59 <ertes> because a lot of the built-in functions use it to find the current state of things like buffers or windows
06:10:14 <ertes> where does the 'insert' function write stuff?  it doesn't take a buffer argument
06:10:20 <ertes> it uses the "current buffer"
06:10:44 <kuribas> ertes: that's just global scope...
06:11:41 <kuribas> ertes: and yeah, it would be "insert :: Insertable a -> a -> IO ()", or something like that.
06:12:27 <ertes> sure, you could interpret dynamic scoping as "everything is global"
06:13:20 <ertes> that's why i said: you need to write a system for that:  a global dynamic namespace for dynamically typed IORefs =)
06:14:08 <kuribas> ertes: I don't see why that's necessary.
06:14:32 <kuribas> ertes: elisp functions that mutate would be simply in IO.
06:15:57 <kuribas> ertes: as the generated code uses lexical scoping, it wouldn't "see" dynamic variables.
06:16:59 <kuribas> ertes: emacs variables could be available as IORefs, but why is that a problem?
06:18:03 <ertes> kuribas: it's just a lot of work
06:18:20 <kuribas> ertes: no, an IORef would just compile to a variable.
06:19:22 <kuribas> ertes: the biggest problem with purescript is that it doesn't do inlining and specialization.
06:19:35 <kuribas> ertes: impemented that is a lot of work.
06:20:56 <ertes> kuribas: well, if you want to do it, by all means…  i'm still pretty sure this will be a lot more work than you imagine
06:21:10 <kuribas> ertes: probably :)
06:21:20 <kuribas> ertes: like any project I start...
06:23:39 <ertes> emacs has lots of concepts to map from its countless global variables and APIs over buffer-local variables and its customisation API all the way to its more peculiar language features like define-advice and the huge number of scripts that use it to modify the behaviour of your functions, etc.
06:24:35 <ertes> so you're in for quite a ride =)
06:24:38 <kuribas> ertes: so, if you use advice on purescript generated code, you're on your own.
06:24:46 <kuribas> ertes: then don't do that :)
06:25:36 <kuribas> ertes: the purescript code would compile to an obarray or hashtable containing all the functions.
06:25:43 <kuribas> so it will live in it's own namespace.
06:28:01 <ertes> kuribas: as i said: by all means =)
06:28:27 <ertes> i just wish you would write an idris instead of PS =)
06:28:32 <ertes> *idris backend
06:28:43 <kuribas> I don't know idris...
06:29:40 <ertes> it's the most advanced haskell-like language *for programming* that i know
06:29:58 <kuribas> https://github.com/edwinb/idris-php
06:30:03 <xenon-> general purpose programming?
06:30:12 <ertes> yeah
06:30:14 <xenon-> and how does it compare to agda? I meant to learn one or the other
06:30:36 <ertes> "Yes, really..."
06:30:38 <ertes> hahahaha
06:31:22 <xenon-> mmm
06:31:29 <ertes> xenon-: well, it's a programming language…  i don't know if it has a formal specification now, but at least they care about semantics
06:31:50 <mettekou> xenon-: Agda is focused on formal proof and enforces totality, while Idris is focused on programming and makes totality optional.
06:32:36 <ertes> it's not only that:  with agda you don't even know which evaluation strategy your program is going to use, should you be inclined to actually run it
06:33:23 <ertes> its binding to even the most basic system APIs is laughable for any binding…  idris has a programmer-oriented base library just like haskell
06:33:36 <ertes> don't get me wrong:  i like and use agda, but only for theorems =)
06:34:00 <ertes> s/for any binding/for any target/
06:34:05 <mettekou> ertes: For me the "focused on formal proof" part entails both of these: I don't care what the proof term I use as a witness behaves like and I don't care about bindings to external libraries in my proofs.
06:35:35 <kuribas> ertes: the biggest problem with purescript is it's lack of optimization.
06:36:05 <ertes> kuribas: i'd expect idris to be in a similar state right now, although it probably does some basic optimisation
06:37:47 <NextHendrix> does anyone here write braceful haskell
06:37:51 <kuribas> ertes: I'd like to port ghc's inliner and specializer to purescript, but its probably to much work.
06:37:52 <NextHendrix> if so, why
06:38:21 <kuribas> ertes: I wish someone payed me to do so.
06:38:45 <kuribas> ertes: but otherwise I couldn't afford the effort...
06:39:04 <kuribas> Is ghc hacking volunteer work?
06:39:15 <xenon-> just googled some idris examples.. you can have a Vector type that is guaranteed to have only 3 elements at compile time. if you try to access 4th element you'll get compile error. so I wonder how do you access Nth element, where N is known at runtime? it does something similar to what IO () does for doing effects in haskell?
06:39:54 <ertes> xenon-: you have to prove that it's going to be in range
06:40:13 <Tuplanolla> Practically you have to carry a witness of `N` being suitable, xenon-.
06:40:27 <stobix> Just out of curiosity, is there a random type somewhere where I can specify the range of "subtypes", like having a random Maybe Int with the Int being between two specified values?
06:40:42 <Tuplanolla> @google proof witness type
06:40:44 <lambdabot> https://en.wikipedia.org/wiki/Evidence_(law)
06:40:45 <ertes> xenon-: for example you can use a decision function…  it's like a boolean function, but returns a proof along with True and a refutation along with False
06:41:12 <Tuplanolla> That's... a terrible search result.
06:44:15 <sm> stobix: no, haskell package/module docs are not available as man pages. Interesting notion
06:46:05 <ertes> xenon-: remember the curry-howard correspondence stuff you heard a million times?  this is it =)
06:47:40 <stobix> sm: oh, well. Good to know, at least.
06:47:59 * stobix usually prefers not using the happyland of distraction (aka the internet) when doing in-depth coding if avoidable.
06:48:30 <srhb> NextHendrix: I have never seen braceful Haskell in the wild, short of for one-lining without layout on irc.
06:48:52 <ertes> stobix: if you use firefox you can create a bookmark to:  https://hackage.haskell.org/package/%s
06:49:07 <ertes> stobix: open the properties of the bookmark and assign it a keyword "p"
06:49:30 <ertes> then you can type "p mtl" in the address bar to get directly to the hackage page/documentation of the mtl package
06:50:48 <stobix> ertes: interesting idea
06:51:21 <amx> chrome can do it too
06:51:23 * stobix still has to load the bloatedness that is firefox, but at least it would provide a shortcut
06:52:17 * stobix is actually using opera 12 for coding right now
06:52:23 <amx> that gives me an idea, the hackage web if could provide a opensearchdescription
06:54:15 <stobix> When programming Erlang, I tend to have about 15 man pages open in a screen somewhere. Kinda messy to do the same in most browsers I feel.
06:54:23 <ertes> stobix: if you use that, here is an interesting side note:  if you just type "p", hackage will redirect you to the full list of packages, at which point you can use the apostrophe key to search for links only =)
06:54:46 <jophish> k0001: hi, are you free to talk about tisch for a bit?
06:55:07 <k0001> jophish: sure
06:55:21 <jophish> great, thanks for it, it looks like a super library :)
06:55:37 <jophish> k0001: have you seen dbrecord and dbrecord-opaleye?
06:56:01 <jophish> it would be great to get your thoughts on that, as both dbrecord and tisch seem to be doing very similar things
06:56:37 <k0001> yeah, I read about it when it was mentioned in Reddit some months ago, but not since then.
06:57:21 <jophish> I wonder if there's any possibility of collaboration between the two projects
06:57:27 <jophish> both have some very compelling features
06:57:42 <jophish> one awkwardness is that they've both got quite a bit of code written
06:57:58 <jophish> (I'm expipiplus1 on github btw)
06:58:36 <ertes> stobix: if your editorating system has a text browser built-in, you can probably use it somehow to speed up the workflow
06:59:12 <k0001> Oh hi! I can't answer off the top of my head, I should see where dbrecord is currently at, I haven't been following its development.
07:03:13 <ertes> holy shit…  there is an emacs extension for an embedded webkit browser
07:05:03 <k0001> jophish: I'm glad you enjoy the library, by the way. Let me know if you see something missing that you need. What's  in the master branch is expected to be working, but maybe there's something missing that you need.  
07:06:27 <stobix> ertes: Wouldn't surprise me. I guess I'll learn emacs one of these decades. :)
07:06:45 <stobix> s/Wouldn't/Doesn't
07:06:48 <jophish> k0001: One thing I was wondering about was utilities for converting between tisch Records and regular haskell record types, possibly using some kind of Generic machinery
07:07:03 * stobix has no such luck with vim, he guesses. 
07:07:28 <jophish> oh, I've also been working on a way of extracting CREATE statements from tisch 'Table's
07:07:40 <jophish> It's going pretty well, nearly working at a basic level
07:12:00 <k0001> jophish: yeah. I actually started working on that but then stopped because of that other thing I mentioned in GitHub about wanting to change the Record internals a bit so that its related instances don't take forever to compile :)
07:13:36 <jophish> I think this is where dbrecord does quite well. As I understand it (although I've not run more than the examples yet) everything always stays in haskell records, but when a column is missing it gets replaced with ()
07:14:47 <k0001> Yes, there are a lot of alternatives to explore in this space. Not so much time to explore them all, though!
07:15:02 <jophish> tell me about it!
07:17:41 <ertes> stobix: probably not =) but at least you could try a text browser, which you might be able to call from vim directly
07:18:00 <ertes> stobix: like elinks, lynx, w3m
07:18:44 <ertes> at least you won't be looking at cat pictures with those when you should be reading package documentation =)
07:22:39 <Insanity_> ertes: I've played around with w3m and I can tell you, cat pictures are possible! :P
07:22:44 <k0001> jophish: do you think that CREATE work can have a place in Tisch.Run?
07:22:58 <geekosaur> as long as you're not compositing, at least >.>
07:22:58 <ertes> hehe
07:24:00 * ertes just got the pun "tisch"
07:24:10 <k0001> :)
07:24:34 <ertes> ("why is it called ‹tisch›?  ‹table›?  oh!")
07:26:34 <jophish> k0001: It's alreyad in Tisch.Create :). I'll open a PR today I hope
07:26:34 <janosp> Hi guys, quick question: Can I use QuickCheck in order to test High Order Functions?
07:26:53 <janosp> eg. to test if my implementation of "map" is correct ?
07:26:58 <ertes> janosp: it can generate functions
07:26:59 <k0001> jophish: ah! Very nice!
07:27:50 <janosp> ertes: Oh cool, do I have to define something similar to "Arbitrary" or a Generator?
07:28:26 <ertes> @check \f x -> (apply f (x :: String) :: Int) == apply f x
07:28:28 <lambdabot>  error:
07:28:28 <lambdabot>  Variable not in scope: apply :: () -> String -> Interror: Variable not in sc...
07:28:44 <ertes> janosp: see Test.QuickCheck.Function
07:28:53 <sm> +1 on ertes' browser shortcut to hackage suggestion, it is a must. Also one for hoogle and for stackage
07:28:56 <janosp> ertes:  great thanks!
07:29:55 <sm> stobix: our alternative to man pages is the haddock docs you can see on hackage/stackage, and note you can install a load of these locally for offline browsing (stack haddock in your project eg)
07:30:13 <ertes> @check \(Fun _ f) x -> (f (x :: String) :: Int) == f x
07:30:15 <lambdabot>  error:
07:30:15 <lambdabot>  Not in scope: data constructor ‘Fun’ Perhaps you meant one of these: variabl...
07:30:48 <stobix> sm: I kinda wish there were something like cabal install everything --only-docs-plx
07:31:09 <geekosaur> no fun here, I guess >.>
07:31:31 <geekosaur> stobix, that'd be great if building docs didn
07:31:31 <ertes> oh, Fun isn't even needed according to the instances
07:31:38 <ertes> @check \f x -> (f (x :: String) :: Int) == f x
07:31:39 <stobix> sm: As it is now, I can browse the packages cabal thinks I have installed locally, but it doesn't help me with what my system or hgc installed elsewhere
07:31:40 <lambdabot>  +++ OK, passed 100 tests.
07:31:42 <ertes> nice!
07:31:45 <ertes> janosp: ^
07:31:57 <geekosaur> t mean building the package (because it relies on the typechecker to expand types)
07:33:03 <ertes> janosp: although you should probably use Fun anyway, because shrinking doesn't work for raw functions
07:33:29 <stobix> geekosaur: oh, so the docs are "derived" in a sense from type info? Well, I guess that saves some work (unless you want the documentation to know what you want to install in the first place)
07:33:37 <janosp> ertes: Yeah, I am currently using Fun
07:33:48 <geekosaur> they
07:33:49 <geekosaur> e
07:34:00 <janosp> ertes: Which is the first thing in QuickCheck.Function
07:34:16 <geekosaur> they're API docs, they want to do things like enumerate instances for classes, provide expansions for type aliases, etc.
07:35:00 <sm> stobix: stack haddock installs the docs for all deps of current project, cabal probably has some equivalent. There might be a tool on hackage to install even more. If you have a mac, you might also want to check out the Dash app
07:35:26 <geekosaur> ancient haddock was standalone, modern haddock uses ghc and inherits ghc's problems with overly strict dependencies due to cross-module inlining and such (meaning it can be confused about instances if multiple versions of a package are installed)
07:36:01 <sm> stobix: http://hackage.haskell.org/package/docidx, eg
07:36:16 <sm> um, from 2012. YMMV
07:37:07 <Lokathor> geekosaur, it seems to me like you could just inline the version that a particular module is using when you're inlining it all together
07:37:25 <geekosaur> er? that's what causes the problem
07:37:53 <geekosaur> the stuff it exposes for inlining includes otherwise private symbols, some of which are generated and change between compiles
07:38:05 <Lokathor> ohhhhh
07:38:06 <Lokathor> okay
07:38:37 <Lokathor> I thought you were saying that it made the compile harder, which it doesn't seem like it should be doing if you just mangle here and there a bit
07:43:36 <shapr> well this got my brain confused: https://slpopejoy.github.io/posts/Pleonid.html
07:43:58 <shapr> tldr: haskell library for doing music based on knot theory?
07:45:06 <Tuplanolla> I didn't know those are even related.
07:45:19 <shapr> nor did I
07:46:31 <Tuplanolla> I did end up in knot theory from quantum mechanics recently, so I can now generalize and say every subject leads to knot theory.
07:46:45 <shapr> that's a knotty subject
07:46:55 * shapr sings "knotty dread"
07:47:54 <janosp> ertes: Can I ask you a question regarding Fun ?
07:49:11 <shapr> I want to ask about Work, but I know the answer.
08:11:17 <SrPx_> Is there any Haskell-type inspired JSDoc-like spec?
08:11:44 <janosp> Hi, can me somebody help with QuickCheck.Function? http://lpaste.net/350934
08:11:52 <SrPx_> I.e., I'd like to have good means to annotate high order functions and generic type params (forall)
08:11:59 <janosp> I don't understand how the error message is helping me or how to use these instances
08:18:07 <exio4> SrPx_: er, I don't know JSDoc, but you mean something like Haddock?
08:18:35 <SrPx_> no, Haddock, trying to document JS code in a more haskellish style
08:18:41 <SrPx_> if that is even legal
08:20:36 <exio4> ohh, you mean for JS, no idea =)
08:24:41 <bollu> I want to use a theorem prover for my software foundations course. does LEAN support set theory, propositional, modal and temporal logic?
08:24:46 <bollu> is there any proof system that does?
08:34:15 <O1O1> how do i add new data to next row in excel everytime i submit data? it is currently set as intRow=2 so it writes data in row 2 everytime i submit
08:34:53 <Tuplanolla> @hackage excel
08:34:53 <lambdabot> http://hackage.haskell.org/package/excel
08:35:46 <Tuplanolla> @hackage xlsx
08:35:46 <lambdabot> http://hackage.haskell.org/package/xlsx
08:36:34 <shapr> O1O1: Are you doing homework?
08:38:10 <Tuplanolla> There's actually a solution in the documentation.
08:39:49 <MarcelineVQ> @tell janosp it's telling you there's too many possibilities for what a and b are, give it a hand by giving specific types to work on: 3 exampes here http://lpaste.net/350936
08:39:50 <lambdabot> Consider it noted.
08:55:15 <infandum> Is there a quick way to zip within a depth? Like, specialZip [1,2,3] [["a", "b"], ["c"]] == [[(1, "a"), (2, "
08:55:23 <infandum> oops
08:55:40 <infandum> == [[(1, "a"), (2, "b")], [(3, "c")]]?
08:55:57 <saurabhnanda> I'm sorry, but I need a place to vent. Haskell is JUST NOT living up to its promises for me -- https://github.com/tomjaguarpaw/haskell-opaleye/issues/263
08:56:21 <saurabhnanda> Everything I touch, is broken, incomplete, or downright buggy. So much for "if it compiles, it runs correctly"
08:57:19 <Rotaerk> if it compiles, it's much more likely to run correctly, if you utilize the type system sufficiently; "if it compiles, it runs correctly" is an oversimplification
08:58:04 <c_wraith> saurabhnanda, from what I've seen, you're using haskell in very unusual ways without much grounding in the usual things. yes, when you use only weird experimental projects, you have issues. so why are you using only weird experimental things? 
08:58:34 <saurabhnanda> c_wraith: experimental?! this is actual real-life code I'm writing. It's stuff that I intend to push into production. Is Opaleye experimental?
08:59:02 <c_wraith> I would consider anything that attempts to be as magical as opaleye experimental, yes. 
08:59:19 <saurabhnanda> c_wraith: expecting JSON validation + parsing to be a solved problem is experimental? DB & incoming data validation is basic stuff for any webapp.
08:59:50 <saurabhnanda> c_wraith: Opaleye is FAR from magical. It's got the maximum amount of boilerplate. Bloody pain to use.
08:59:57 <Freundlich> I'm processing a list in such a way that if an element satisfies a certain condition, it should be paired up with the following element (if there is any) and the following element should also be skipped.
09:00:18 <c_wraith> there are many db libraries that are much simpler than opaleye, but don't attempt to be magical the way it does. 
09:00:31 <Freundlich> To make this more concrete: Take a look at how argument parsing on the command line works: If a parameter starts with a -, it should be paired with the following parameter.
09:00:37 <c_wraith> they have the advantages of working without lots of boilerplate 
09:00:42 <Freundlich> I'm wondering how to express this elegantly in Haskell.
09:01:32 <Tuplanolla> Perhaps `zipWith f <*> tail`, where `f :: a -> Maybe b` and `catMaybes` the result, Freundlich.
09:01:37 <Freundlich> So, for example, ["a","-b","c","d"] should become ["a",("-b","c"),"d"] (suppose we are using Either for this).
09:01:52 <Tuplanolla> Correction: `f :: a -> a -> Maybe b`
09:02:38 <Freundlich> Tuplanolla: I have been thinking about zipping with the tail, but does this also "skip" an element if it has been paired with its predecessor?
09:02:40 <Tuplanolla> Then again a simple `foldr` might be all you need, Freundlich.
09:02:45 <saurabhnanda> c_wraith: "there are many db libraries" -- that's precisely where the problem starts. So many libraries, each one trying to do their own thing. No one sweating the details on a single library working out all edge cases and use-cases.
09:03:14 <Tuplanolla> With the zipping approach you'd do the skipping by returning `Nothing` from `f` early, Freundlich.
09:04:15 <Rotaerk> saurabhnanda, the existence of many libraries targeting the same domain doesn't imply that there are no mature ones that "work out all the edge cases"
09:04:29 <Tuplanolla> Another zipping option would be to cut the `zipWith` into `zip`, `filter (p . fst)` and `fmap`, Freundlich.
09:04:55 <saurabhnanda> Rotaerk: can you name one?
09:04:56 <Rotaerk> just means you need to sift through them to find the mature one(s)
09:05:55 <Rotaerk> haven't really used databases from haskell yet, so I can't; maybe c_wraith can though
09:06:47 <Freundlich> Tuplanolla: Sorry, I'm not sure I understand. With the zipping approach, I would process ("a","-b"), ("-b","c") and ("c","d"), right?
09:07:00 <Rotaerk> my guess is these: https://wiki.haskell.org/Web/Databases_and_Persistence
09:07:14 <Tuplanolla> Yes, and filter away the pairs that start with nonflags, Freundlich.
09:07:47 <Tuplanolla> Then again processing the `--` thing requires a fold at some point.
09:08:00 <saurabhnanda> Rotaerk: all of them have the same issue
09:08:32 <saurabhnanda> Rotaerk: Persitent doesn't solve for SQL JOINs. Leaves it to Esqueleto, which isn't maintained any longer.
09:08:32 <Freundlich> Tuplanolla: Right... I simplified the problem a bit.
09:09:18 <Freundlich> Tuplanolla: Thanks. I have to think about this some more.
09:10:41 <c_wraith> wanting joins to happen automatically is definitely looking for magic.  
09:12:18 <infandum> Woah, got the answer, but it's a bit longer than I would have liked: say xs = [["a", "b", "c"], ["d"], ["e", "f"]]
09:12:33 <infandum> then let ys = Split.splitPlaces (map length x) [1..]
09:12:48 <saurabhnanda> c_wraith: not wanting them to happen magically. Persistent doesn't even allow expressing explicit joins.
09:12:57 <infandum> then the answer is zipWith zip ys xs
09:12:57 <infandum>  
09:13:09 <infandum> although a one liner would be cooler than a two liner
09:14:46 <NextHendrix> code coolness is extremely important
09:15:24 <infandum> *extremely*
09:15:59 <NextHendrix> 3extremely
09:16:35 <Rotaerk> "please explain the business case of doing this?" "maximum code coolness"
09:17:56 <Fuco> people always say "write smaller methods" and classes and when you design your entire app as 50 one-liners coordinated with cron they go into a mad rage
09:18:05 <infandum> well you see, if it was "magicalTraverse [1..] xs" that would be awesome
09:18:10 <infandum> beyond cool, in fact
09:18:30 <infandum> it would probably make more sense than "zipWith zip"
09:19:05 <Rotaerk> saurabhnanda, persistent looks like it's designed for a constrained use-case for databases
09:19:12 <Rotaerk> rather than a generic interface to databases
09:19:28 <Rotaerk> particularly persisting and retrieving entities
09:19:39 <Rotaerk> don't really need joins for that
09:20:04 <saurabhnanda> this is my first hand experience after 3 months of struggling with all this -- everything **looks** like it's solved, till you start using it. then the skeletons start tumbling out of the closet.
09:20:10 <Sonolin> I haven't used Persistent (much) but from what I understand I think you need something like Esqueleto to do joins, right?
09:20:22 <saurabhnanda> my biggest pet peeve -- haskell type inference isn't as good as it's claimed to be.
09:20:30 <Rotaerk> yea he mentioned that earlier, Sonolin 
09:20:30 <geekosaur> saurabhnanda, re opaleye, it's experimenting with explicitly experimental type system features
09:20:43 <saurabhnanda> Sonolin: which is unmaintained.
09:20:43 <geekosaur> they will indeed have problems with type inference, and lots of other things
09:20:57 <Sonolin> ok I see, sorry just jumped in
09:21:26 <geekosaur> "but it's the latest it must be the greatest" is not the way to go with ghc/haskell, you're just jumping into the shark tank
09:21:29 <saurabhnanda> geekosaur: which experimental type system feature?
09:21:36 <Rotaerk> is there a general consensus on what's the most mature general-purpose database interface for haskell?
09:21:55 <saurabhnanda> Rotaerk: take it from my highly irritated self. There is NONE.
09:23:20 <Tuplanolla> How do you right-align a widget with `brick`?
09:23:30 <Tuplanolla> I can only find left and center.
09:24:05 <saurabhnanda> and DBs is not the only problem. what about Servant. How do you leniently validate an incoming JSON?
09:24:28 <Rotaerk> have you tried HDBC?
09:24:31 <saurabhnanda> say you want to tell the UI that 'x' is supposed to be an Int not a String.
09:25:08 <Rotaerk> https://en.wikibooks.org/wiki/Haskell/Database  claims it's the "most popular"
09:25:35 <c_wraith> don't use hdbc. it's slow by design. 
09:25:59 <Rotaerk> do you have an alternative recommendation?
09:26:28 <glguy> Unless you were intending to write a leisurely-paced application?
09:26:49 <glguy> everyone's always in such a rush
09:27:15 <Rotaerk> are you an ent? treebeard?
09:31:49 <Rotaerk> saurabhnanda, what database are you using?
09:33:03 <Rotaerk> wonder how good this is http://hackage.haskell.org/package/hsql
09:33:08 <Rotaerk> it's not an abstraction layer though
09:33:30 <Rotaerk> well, at least, not the same level of abstraction you might want
09:37:15 <Rotaerk> seems like one thing the haskell ecosystem could benefit from is a community-driven list of domains and the recommended general-purpose library(ies) for that domain
09:37:37 <Rotaerk> as opposed to a list of *all* the libraries for each domain, including the experimental ones
09:38:35 <Rotaerk> if you're using postgresql this might be good https://github.com/nikita-volkov/hasql
09:40:34 <saurabhnanda> Rotaerk: PG
09:40:50 <mekeor> yeah, i find it hard to find the right package, too
09:40:56 <mekeor> in general
09:40:57 <saurabhnanda> Rotaerk: it's incomplete
09:41:57 <saurabhnanda> no, the problem is not, given X, find the best package that solves for X. The problem is given X, how many people have really written production applications around X. Libraries and techniques will follow automatically. And that, is the bitter truth.
09:42:40 <saurabhnanda> as I said, everyone is ranting & raving about Servant. I couldn't find any way to do lenient parsing+validation of incoming JSON. And that's a given in any serious webapp.
09:42:40 <Psychiatrist> Hey guys. Is there a way to have a function that has 3 parameters to do X if it gets only 2 parameters as input and do Y if it gets all 3 ? 
09:43:12 <Rotaerk> what are X and Y, exactly, Psychiatrist ?
09:43:27 <saurabhnanda> and it's not about servant really. What is the recommended way o doing lenient parsing+validation of incoming JSON in any web-library out there?
09:43:31 <Psychiatrist> calls to other functions, Rotaerk 
09:43:38 <Tuplanolla> Take a look at `Text.Printf.printf`, Psychiatrist.
09:43:43 <glguy> Psychiatrist: If you want to vary a definition by its type, you can make a typeclass
09:43:46 <Tuplanolla> It requires some type class tricks.
09:44:02 <saurabhnanda> ah and that reminds me -- there is no library to print numeric values in currency formats.
09:44:12 <Psychiatrist> It can be done! That's all I need. Thanks guys.
09:46:30 <mekeor> i think there is, saurabhnanda
09:46:39 * mekeor tries to find it
09:47:11 <saurabhnanda> and you can't use lucid without putting T.Text type signatures all around the place.
09:47:50 <mekeor> @hackage safe-money -- maybe this?
09:47:50 <lambdabot> http://hackage.haskell.org/package/safe-money -- maybe this?
09:50:01 <saurabhnanda> mekeor: no function to pretty print? http://hackage.haskell.org/package/safe-money-0.2/docs/Data-Money.html
09:53:14 <sm> there's http://hackage.haskell.org/package/hledger-lib-1.1/docs/Hledger-Data-Amount.html#g:3
09:57:05 <saurabhnanda> sm: import a complete accounting system to pretty-print a currency? http://hackage.haskell.org/package/hledger-lib-1.1
09:57:19 <saurabhnanda> sm: why can't Printf simply have grouping by thousand separators? based on locale?
09:57:47 <Tuplanolla> Because locales are a horrible invention.
09:58:10 <sm> the app follows a spec set by Ledger, which is to use the digit grouping convention of the data
09:59:05 <sm> helpful when accessing files using different conventions, eg
09:59:10 <Tuplanolla> If you want to print currencies, use ISO 4217 with C formatting.
09:59:52 <saurabhnanda> based on locale = taking into account different conventions
09:59:52 <sm> safe-money looks pretty nifty, you could add your own custom renderer
10:00:37 <saurabhnanda> sm: yes, I could. I'm just surprised that it's not already there. Which is why my hypothesis that no one is really using this stuff in production is getting stronger day-by-day.
10:01:34 <saurabhnanda> sm: and this is not the only thing. There are a 100 other nagging unsolved problems that I've come across when writing a real-world webapp in Haskell.
10:01:48 <Zemyla> Does the newest GHC platform have primitive-0.6.2.0?
10:02:25 <sm> saurabhnanda: I know. Sounds like the usual real-world developer's experience in most ecosystems. There's no doubt that haskell doesn't have the same depth of real-world conveniences that more popular languages do
10:03:16 <sm> it's a tradeoff. You accept having to research and write more of it yourself in exchange for the benefits haskell brings
10:03:25 <sm> and it's getting better every year
10:04:19 <saurabhnanda> what benefits, exactly?
10:04:30 <saurabhnanda> because seriously, I'm beginning to question the core benefits as well
10:04:38 <sm> really, must I enumerate them ? You know haskell I think ? 
10:04:52 <sm> I would say lower cost of maintenance over time is the big one
10:05:04 <saurabhnanda> and please try stating the benefits over & above any other statically typed language out there.
10:05:39 <saurabhnanda> because anything that you try to do over & above the basic stuff (that most other statically typed languages will have), you enter a world of pain.
10:06:00 <saurabhnanda> the very first being that haskell type inference goes for a toss, because you end-up using myriad language extensions.
10:06:31 <saurabhnanda> the second being boilerplate
10:06:35 <saurabhnanda> tons. and tons of it.
10:06:54 <saurabhnanda> else you have to spend another 2 weeks learning TH and/or generic programming. Because Haskell doesn't have reflection.
10:07:08 <sm> saurabhnanda: for context, what are you comparing with ? what's your default familiar real-world language ?
10:07:28 <saurabhnanda> or you throw your hands up in the air, and give up type-safe solutions. In which case, you come back to the question I Was asking -- what's the point of using Haskell in the first place?
10:08:11 <saurabhnanda> sm: right now, it's Ruby + Rails, mostly. But have developed in Java & C as well.
10:09:12 <sm> I hear your dilemma. It's a trade-off, you have to make the best choice for your situation. I think in a while you'll find it becomes an easier call
10:10:32 <sm> I have a large client project in PHP. It's a pretty clear call not to use haskell for that at the moment. But there are many projects I find haskell a no brainer for
10:10:43 <saurabhnanda> sm: for example?
10:11:39 <sm> smaller projects where I have a lot of control, for one. hledger, darcs hub
10:11:54 <sm> what's your project ?
10:13:06 <saurabhnanda> sm: pretty large SaaS webapp
10:13:34 <sm> starting from scratch, or rewriting ?
10:14:43 <saurabhnanda> parts rewriting, parts new development
10:14:49 <saurabhnanda> large part is new dev.
10:15:10 <sm> is there an existing team ? are they haskell-adaptable ?
10:18:01 <sm> saurabhnanda: if it's just you, and you have control, you could hedge your bets - plan a dual rails & haskell setup, modular enough that you can move any piece between rails and haskell as seems most expedient
10:18:46 <saurabhnanda> sm: what does one do when you want a simple report on webpage in haskell and you can't get currencies to format properly?
10:19:12 <saurabhnanda> sm: or when you're using lucid to write HTML and the stop webapp + compile app + start webapp cycle is killing you
10:19:29 <saurabhnanda> sm: when you're writing a JSON API endpoint and cant get validation to work like any normal webapp!
10:19:34 <qbit> hihi
10:19:38 <qbit> is there a way to make stack us a http proxy/
10:19:38 <sm> that sounds like an easy enough problem that one would just write the myFormatCurrency function
10:19:50 <qbit> I cann't seem to find anything on the readthedocs page
10:20:05 <sm> ack, I must type faster to keep up with your rant :)
10:21:26 <sm> saurabhnanda: I think it does take time to learn which packages and workflows are not efficient, and find better alternatives
10:21:47 <sm> like maybe lucid and servant aren't your best option
10:22:02 <sm> sometimes doing it a more stupid way is better
10:24:09 <sm> using GHCI reload (+ rapid, perhaps) instead of recompiling the app, etc.
10:24:51 <DemiMarie> Is there ever a reason for a function to return ()?
10:25:06 <Akii> :side effects:
10:25:15 <eelster> DemiMarie: Yes. 
10:25:38 <saurabhnanda> sm: couldn't get rapid to work with scotty. I tried.
10:25:43 <DemiMarie> eelster: Can you explain?  The only examples I can think of involve misusing unsafePerformIO and friends
10:25:58 <sm> saurabhnanda: one off the wall idea, for quickly developing enterprise type apps I would not rule out something like sprinkles 
10:26:17 <saurabhnanda> whats that?
10:26:22 <eelster> DemiMarie: If you have a function that prints recursively and you want a basecase to end execution you can just do return() for the base case. 
10:26:28 <sm> flexible data sources, no recompilation.. check it out on hackage
10:26:57 <DemiMarie> eelster: I didn't mean `IO ()` or the like, I meant just `()`
10:26:59 <tmciver> eelster: but that would be IO (), no?
10:27:01 <eelster> DemiMarie: Oh. 
10:27:02 <NemesisD> is there a way to access cabal flags via cpp in your source files
10:27:13 <eelster> I thought you mean a function with `return ()` in it.
10:27:22 <sm> it's not battle-tested, but it's so shallow that I think it's usable even now
10:27:27 <DemiMarie> eelster: I meant a function of type `something -> ()`
10:27:43 <eelster> DemiMarie: I've never written a function that does that. I feel like it would be useless.
10:27:48 <DemiMarie> eelster: me too
10:28:11 <NemesisD> do i have to do in the cabal file if flag(myFlag)\nCPP-OPTIONS: -DMyFlag, then ifdef #MyFlag?
10:28:25 <eelster> I mean, a function to consume something but not do anything I guess, but that's impractical and stupid. 
10:28:39 <DemiMarie> eelster: The only use for such a function would be some unsafe code that needed to force a certain value at a certain time
10:29:18 <mtjmullen> eelster: I've done it anonymously before, something like (\_ -> () <*> ioAction)
10:29:39 <mtjmullen> there's much better ways to do that though
10:30:03 <DemiMarie> mtjmullen: What are they?
10:30:20 <eelster> eelster: I can see that
10:30:27 <mtjmullen> :t void
10:30:29 <lambdabot> Functor f => f a -> f ()
10:30:58 <mtjmullen> > void $ putChar 'c' 
10:30:59 <eelster> But that's not `()`, thats `f ()` where f is a functor.
10:31:00 <lambdabot>  <IO ()>
10:31:26 <mtjmullen> eelster: the whole function is IO (), but the lambda is (forall a . a -> ())
10:31:36 <mtjmullen> that's all I was getting at :)
10:31:38 <eelster> :t <IO ()>
10:31:39 <lambdabot> error: parse error on input ‘<’
10:31:48 <DemiMarie> :t ()
10:31:49 <mtjmullen> > putChar 'c' $> ()
10:31:50 <lambdabot> ()
10:31:51 <lambdabot>  error:
10:31:51 <lambdabot>      • Variable not in scope: ($>) :: IO () -> () -> t
10:31:51 <lambdabot>      • Perhaps you meant one of these:
10:32:08 <eelster> Wait what is the type of <IO ()>?
10:32:18 <eelster> :t void $ putChar 'c'
10:32:19 <lambdabot> IO ()
10:32:44 <mtjmullen> There a way to import modules w/ lambdabot?
10:32:57 <eelster> mtjmullen: Not sure? It's worth a try
10:32:58 <mtjmullen> This is the function I was trying to use: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html#v:-36--62-
10:32:58 <MarcelineVQ> some modules  @let import Blah
10:33:15 <mtjmullen> @let import Data.Functor
10:33:16 <lambdabot>  Defined.
10:33:20 <mtjmullen> > putChar 'c' $> ()
10:33:23 <lambdabot>  <IO ()>
10:33:26 <mtjmullen> ok, thanks
10:33:37 <eelster> :t putChar 'c' $> ()
10:33:38 <lambdabot> IO ()
10:34:23 <MarcelineVQ> you have access to <$ without imports though
10:34:46 <eelster> Isn't <$ just fmap . const ?
10:35:06 <rotcev> :t (<$)
10:35:06 <lambdabot> Functor f => a -> f b -> f a
10:35:33 <mtjmullen> That is the default impl of (<$) in functor, year
10:35:34 <mtjmullen> *yeah
10:35:35 <eelster> :t (>=>)
10:35:37 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:35:55 <eelster> Thanks lambdabot 
10:35:57 <mtjmullen> :t flip (.)
10:35:58 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:36:21 <eelster> :t flip
10:36:22 <lambdabot> (a -> b -> c) -> b -> a -> c
10:36:44 <eelster> flip is useful for point free
10:36:53 <Boomerang> :t flip id
10:36:55 <lambdabot> b -> (b -> c) -> c
10:37:17 <eelster> why is it b -> (b -> c) -> c instead of a -> (a -> b) -> b?
10:37:26 <eelster> I mean I know they're alpha equivalent, but still odd.
10:37:40 <eelster> :t id
10:37:41 <lambdabot> a -> a
10:38:00 <DemiMarie> :t null
10:38:01 <Boomerang> I think it's because a becomes (b -> c) and there's no renaming of the type variables
10:38:01 <lambdabot> Foldable t => t a -> Bool
10:38:08 <DemiMarie> :t Foldable
10:38:10 <lambdabot> error: Data constructor not in scope: Foldable
10:38:16 <eelster> :i Foldable
10:38:24 <eelster> Or not :( 
10:38:31 <mtjmullen> :info Foldable
10:38:36 <mtjmullen> @info Foldable
10:38:36 <lambdabot> Foldable
10:38:41 <mtjmullen> thanks lambdabot 
10:38:46 <bengt_> lol
10:38:55 <eelster> You can think of it like [t] => t a -> Bool (but not exactly the same)
10:39:58 <eelster> > null [1, 2, 3]
10:40:01 <lambdabot>  False
10:40:11 <eelster> > null []
10:40:14 <lambdabot>  True
10:40:23 <eelster> There's a demonstration
10:41:24 <sm> saurabhnanda, parting thoughts: I'm sure you know, the most well-trodden and rails-like path in haskell is yesod. And, there's no getting round the fact that it takes more time to feel productive in haskell. We are biased here but many of us feel the benefits become most apparent as time passes and your app ages, keeps evolving easily, and keeps running
10:42:35 <saurabhnanda> sm: i'm also planning to give yesod one last shot
10:43:39 <stobix> Foldable are stuff that can be folded over. In a perfect world, we would have Mappable stuff for things that could be mapped over (kinda what Functor does now). Generalizations of different properties of a list.
10:44:05 <eelster> stobix: Certainly, I was giving a narrowed example to demonstrate the functio.
10:44:42 <stobix> I mostly get confused by narrow examples, so I wanted to provide a general one as well. :)
10:47:47 <sm> saurabhnanda: I like your posts on this topic. See you o/
10:56:33 <Guest51008> hey, is there a way to customize the field names when automatically deriving JSON instances for Persistent models?
10:57:35 <baordog> Guest14661: I don't know but that list of jargon is kind of turning me on
10:57:39 <baordog> tell me me more
10:57:58 <ezyang> Guest51008: Which JSON library are you using? 
10:58:05 <mtjmullen> Guest14661: are you using aeson for this?
10:58:43 <Guest14661> sorry guys tried to get my nickname back. whatever. I'm using something like http://lpaste.net/8780535362171699200
10:59:07 <niklasb_> the database field is called created_at
10:59:12 <niklasb_> but the json field is called createdAt
10:59:22 <niklasb_> I find the latter unpleasant
11:01:24 <mtjmullen> what library are you using for JSON?
11:01:48 <niklasb_> mtjmullen: well persist will generate aeson ToJSON/FromJSON instances
11:01:54 <mtjmullen> oh does it?
11:02:11 <mtjmullen> I know that you can do it in just aeson
11:02:13 <mtjmullen> https://hackage.haskell.org/package/aeson-casing-0.1.0.5/docs/Data-Aeson-Casing.html
11:02:19 <mtjmullen> Can't help you with Persist, sorry
11:02:25 <niklasb_> yes I think it uses https://www.stackage.org/haddock/lts-7.14/persistent-2.6/Database-Persist-Class.html#v:keyValueEntityToJSON
11:02:34 <niklasb_> and keyValueEntityFromJSON
11:04:36 <niklasb_> baetheus: what do you mean by "list of jargon"
11:04:43 <niklasb_> sry baordog 
11:04:46 <amx> well unless you can somehow specify aeson options in persistent, you're out of luck
11:05:27 <amx> in aeson it's enough to say in the ToJSON instance: parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = camelTo2 '_' }
11:05:47 <mtjmullen> niklasb_: can you avoid using the built-in json utils, and just derive instances yourself?
11:05:57 <mtjmullen> looks like you have to derive instances anyways
11:06:26 <niklasb_> mtjmullen: well it's just a single word more per model in the persist definition, so I guess then I would rather live with the camel case...
11:06:44 <niklasb_> I was just wondering, because I couldn't really find the code that does the derivation
11:07:46 <mtjmullen> you could also do "toJson = entityIdToJSON . <some mapping functions>"
11:15:26 <niklasb_> ok thanks mtjmullen I will check it out
11:16:20 <nitrix> Does Template Haskell creates a limitation that requires mutually dependent records to be unable to create the necessary lenses?
11:16:30 <nitrix> s/requires/makes/
11:16:42 <niklasb_> btw just as a general remark, the Haskell community is insanely helpful compared to every other programming language I know. just to put that out there
11:17:26 <nitrix> Given the dependency graph A -> B -> C -> A, the order in which they are defined becomes relevant, and I'm obviously unable to satisfy an order that'd work.
11:17:32 <nitrix> But it only happens with TH and lens.
11:21:59 <nitrix> niklasb_: (:
11:22:21 <nitrix> niklasb_: "Pay it forward"
11:23:26 <c_wraith> nitrix, yeah.. TH enforces an ordering on a file that otherwise doesn't exist. 
11:24:11 <nitrix> c_wraith: I had to create my lenses manually, but I was wondering if I was going crazy or something.
11:24:25 <nitrix> That's inconvenient but I'll live with it :P
11:24:35 <c_wraith> nitrix, the "standard" solution is to replace the mutually recursive types with type variables and then provide type aliases at the expected types. 
11:25:02 <c_wraith> nitrix, on the other hand, I like manually defined lenses anyway, since they compile faster. :) 
11:27:10 <infandum> Which is your favorite Haskell library?
11:27:40 <nitrix> c_wraith: I'm tempted to create `record f = lens' f (\s x -> s { f = x })`
11:28:04 <nitrix> c_wraith: I wonder if you're able to have record update syntax where the record member is provided as an argument.
11:28:59 <nitrix> :t \f -> lens' f (\s x -> s { f = x })
11:29:02 <lambdabot> error:
11:29:02 <lambdabot>     • ‘f’ is not a record selector
11:29:02 <lambdabot>     • In the expression: s {f = x}
11:29:09 <nitrix> :(
11:31:22 <MarcelineVQ> is this what is meant by records aren't first class?
11:31:32 <geekosaur> mostly, yes
11:32:39 <geekosaur> also I don't think the {} syntax works by itself, it always has to syntactically have an expression to apply to
11:33:12 <geekosaur> that is, you always need \s -> s {...}, it doesn't eta reduce to {...}
11:34:42 <Gurkenglas> What's lens'?
11:44:57 <ongy> blackmagic
11:53:06 <bbaren> Gurkenglas: Wait, there’s a function called `lens'`?
11:53:15 <shapr> :t lens'
11:53:17 <lambdabot> error:
11:53:17 <lambdabot>     • Variable not in scope: lens'
11:53:17 <lambdabot>     • Perhaps you meant ‘lens’ (imported from Control.Lens)
11:53:23 * shapr shrugs
11:53:33 <bbaren> I know there’s a type `Lens'`
11:53:59 <bbaren> which is an alias to help readability in code that uses lens.
11:55:55 <bbaren> fgrep "lens'" -r lens/ doesn’t turn up anything interesting, so I’m guessing `lens'` is a typo.
12:03:05 <geekosaur> http://hackage.haskell.org/package/app-lens/docs/Control-LensFunction.html#v:lens-39- ?
12:03:47 <Profpatsch> When I want to read a whole line into a Text with parsec, how would I do it?
12:03:49 <whittle> I have a bunch of functions of the form `f :: a -> Foo -> Foo` or `g :: b -> c -> Foo -> Foo`. Is there a good way to turn that into a monad, so that I can use do notation to build up the final object (of type Foo) over several lines? 
12:04:30 <bbaren> whittle: Is `Foo` a parametrized type (`Foo Int` or something like that)?
12:04:37 <Profpatsch> manyTill and endBy only gives me [Char]
12:04:38 <whittle> bbaren: Nope. 
12:04:46 <aarvar> whittle: (Endo Foo, a) ?
12:06:32 <bbaren> Yeah, you probably want `Endo` and `mconcat`. It won’t look quite as nice as the do notation, but it’ll be simpler (and arguably more correct).
12:06:41 <aarvar> or you could just create a list of Foo -> Foo
12:07:00 <whittle> Got it. 
12:08:09 <geekosaur> or type FooS a = State Foo a and use modify?
12:08:20 <whittle> Thank you, bbaren, aarvar. 
12:14:17 <Gurkenglas> whittle, might some Foo transformations create information that might impact which future Foo transformations you want to do?
12:18:14 <whittle> Gurkenglas: Not the way I had pictured it. 
12:19:07 <whittle> Gurkenglas: I had imagined getting all the information before-hand, and then building up a Foo from parts. 
12:20:41 <whittle> The Foo is actually a monomorphic tree-like structure that is created so that it can be encoded and sent over the wire. 
12:22:06 <Gurkenglas> If each transformation only overwrites previous information without depending on it, something more direct might be simpler - do you have a current version of the code?
12:22:43 <pikajude> lukexi: btw, halive is super useful, kudos to you for that
12:28:45 <whittle> Gurkenglas: I do: https://github.com/whittle/hal/blob/master/src/Data/Hal.hs
12:28:58 <drdo> How do I do this: instance Foo f ⇒ Foo (A . f)
12:30:35 <eelster> drdo: What do you mean? 
12:31:18 <drdo> eelster: I meant what I wrote, with A ∷ ★ → ★ and . composition
12:33:32 <c_wraith> drdo, if you mean the value level (.) function, that doesn't even make sense.. 
12:34:07 <Gurkenglas> drdo, instance Foo f => Foo (Compose A f)
12:34:13 <drdo> c_wraith: Naturally, I want to know how to write type level composition
12:34:49 <c_wraith> drdo, on the other hand, if you mean type level composition, it needs to be a newtype to work, like Data.Functor.Compose
12:35:30 <drdo> Can't I just write a type family?
12:36:39 <c_wraith> no. instances must be on generative types. type families are not generative
12:36:54 <drdo> c_wraith: What's a generative type?
12:36:58 <Gurkenglas> whittle, why don't you fill up all the fields in one record update?
12:38:28 <drdo> Apropos, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
12:38:43 <drdo> I really don't understand where the ambiguity is in that example
12:39:40 <c_wraith> type constructors are generative if (f a ~ g b) implies both (a ~ b) and (f ~ g) 
12:40:14 <c_wraith> that's trivially not true of type families. 
12:40:34 <c_wraith> even injective ones. 
12:41:15 <c_wraith> but it is true with standard haskell type constructors. 
12:42:46 <Gurkenglas> whittle, why do you have SingletonEmbed?
12:43:15 <Gurkenglas> That optimization sounds like it's HashMap's job.
12:45:51 <c_wraith> drdo, anyway - haskell type class resolution for higher-kinded classes depends on generativity. so instances must be defined on generative type constructors. 
12:46:37 <whittle> Gurkenglas: There’s a semantic difference between a rel that points to a single embed and a rel that points to an array of embeds that happens to contain only one. 
12:49:28 <ph88> hi guys, i'm trying to implement a new combinator for megaparsec and for that i have to know whether any input was consumed by an argument parser. How can i find out if input has been consumed after a parser has been run ?
12:49:46 <drdo> c_wraith: How do you even define the Compose (type-level) function?
12:49:56 <drdo> Turns out there's this weird limitation about "saturation"
12:51:14 <c_wraith> drdo, hmm. I'm not sure it's actually possible. 
12:52:02 <drdo> So I can't actually define an instance on the composition of two type constructors?
12:52:23 <drdo> Other than wrapping stuff in something like that Compose newtype
12:52:55 <c_wraith> yeah, it needs to be a newtype. 
12:53:05 <drdo> How is this not an extension yet
12:53:17 <drdo> With all the weird extensions there are
12:53:35 <c_wraith> because it isn't compatible with haskell's type system. 
12:53:47 <drdo> How so?
12:54:19 <c_wraith> it breaks generativity. 
12:54:54 <c_wraith> that's why type functions are so limited. you can't use them anywhere that depends on generativity. 
12:57:04 <drdo> c_wraith: But why is generativity important?
12:59:00 <whittle> Gurkenglas: Sorry, missed your question about filling up fields all at the same time. Representations are just intermediate structures that know how to serialize themselves. If I make the user fill fields up all at once, I’m just forcing the user to create an intermediate structure for plugging into an intermediate structure, which feels like I’m just kicking the can down the road. 
12:59:50 <Gurkenglas> Why does he need to create an intermediate structure for plugging into yours, instead of creating yours himself?
13:01:01 <c_wraith> drdo, it's an essential part of unification of types that have type constructors being applied. if you've got the types (f Int) and (Maybe a) that need to unify, generativity is the property that tells you they unify to (Maybe Int) 
13:02:31 <drdo> c_wraith: Why can't you just *not* have generativity as an axiom?
13:03:08 <c_wraith> you could, but the resulting type system wouldn't be compatible with Haskell's. it's just too different. 
13:03:13 <drdo> All the defined types will get a generativity axiom, but why do you need a universal one?
13:04:04 <drdo> c_wraith: counterexample?
13:06:56 <drdo> (by defined I mean in the usual way, with data and friends)
13:07:21 <c_wraith> sometimes you unify (f a) with (g b), and they stay polymorphic in the whole definition. there's no concrete type to fall back on the axioms of, but you'd still like to be able to say that f ~ g and a ~ b
13:07:46 <drdo> c_wraith: why?
13:08:07 <drdo> I really don't see why you would want such a strong axiom
13:10:20 <c_wraith> I don't know the exact problem it prevents at the system F level. but I do know that it makes inference a lot easier to understand. like much of haskell's choices, it was made so that inference is tractable and avoids surprises. (most of the time)
13:11:26 <c_wraith> some extensions add surprises. but the most notorious of them is ImpredicativeTypes which is actually just broken (doesn't work) because the surprises it adds just don't play nicely with any type inference algorithm.. 
13:11:38 <Gurkenglas> whittle, also missed that last question? :P
13:12:47 <drdo> c_wraith: Obviously you may have to give up something in the area of type inference
13:15:09 <whittle> Gurkenglas: Yes, sorry. I may not have understood your previous question. It sounded like you were suggesting having the user create a HashMap or something equivalent and then passing that to represent all of the embeds, instead of specifying embeds one at a time. 
13:15:59 <c_wraith> drdo, right. but haskell, even with extensions, tries to maintain type inference. ImpredicativeTypes just plain breaks type inference everywhere, which is why it doesn't really work. what you are suggesting would break type inference similarly. 
13:16:34 <c_wraith> drdo, so it's not available as an extension at all. 
13:17:51 <drdo> c_wraith: Are you sure it would break inference so badly?
13:21:17 <c_wraith> I'm pretty sure it would break inference nearly every site a polymorphic type constructor is used. 
13:24:52 <Gurkenglas> whittle, you could have him pass you a HashMap, or if that's too low-level, any Foldable of (Key, Value), et cetera. And why is there a self field if you just plug everything else in it before converting into a JSON? The whole file looks like nothing but plumbing :D
13:27:37 <ph88> can anyone explain this function to me? also i can't find the definition of unParser https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L724-L728
13:30:01 <MarcelineVQ> ph88: it's the record accessor for newtype ParsecT
13:30:35 <MarcelineVQ> you can search unParser on that page or ParsecT to find the definition
13:31:11 <ph88> eh sorry i don't mean the definition i mean the implementation
13:31:22 <whittle> Gurkenglas: You are correct: this is nothing but plumbing. Specifically, it’s plumbing don’t want to see in every one of the dozens of places I use it across three different apps. 
13:31:25 <c_wraith> it's a record accessor. 
13:31:32 <c_wraith> there isn't an implementation. 
13:32:54 <ph88> i'm lost :/
13:33:24 <whittle> I have to build up these representations over and over again, and they’re going to be the single thing that changes most frequently in the apps where this content type is used. I want a self-documenting interface so that I can see at a glance what’s included and where. 
13:33:26 <geekosaur> data Foo a = Foo { unFoo :: a }
13:33:31 <ph88> newtype Foo a = Foo { unParser :: b -> c } 
13:33:56 <geekosaur> yes, similar. unParser is not a function, it's a *field* containing a function
13:34:28 <geekosaur> whatever constructs a Parser provides the function to be assigned to the unParser field
13:34:39 <geekosaur> er, the ParsecT
13:34:53 <EvanR> i wish we had a difference between unParser being a field and a function
13:35:17 <EvanR> theres a field called that and a function called that
13:35:43 <monochrom> That requires a record system. Rather than an emulation.
13:36:52 <monochrom> As it is, even the Haskell committees couldn't decide on a record system, even after several generations.
13:37:03 <ph88> so  p  is a record, applying  unParser on p  "exposes" a function that takes a bunch of arguments   is that right ?
13:37:13 <geekosaur> yes
13:38:15 <ph88> what about these functions, like this one  https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L344  does define what to do if  consuming input went OK ?
13:40:21 <geekosaur> take a look at pMap a few lines down
13:40:32 <ph88> so i see that function returns   m b   then here https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L725 you stick ParsecT to the front of it. And then you have a ParsecT m b ??  but the type signature says the tryP returns  ParsecT e s m a
13:41:28 <geekosaur> you do not have a ParsecT m b
13:41:30 <ph88> ok let's go with pMap it looks easier
13:42:34 <ph88> unParser yields  m b  ..
13:42:35 <geekosaur> you have a ParsecT e s m a, which contains a field whose value is a function from various other functions to an m a
13:42:42 <ph88> line 348
13:43:46 <geekosaur> no, unParser yields  State s -> (a -> State s  -> Hints (Token s) -> m b) -> (ParseError (Token s) e -> State s -> m b) -> (a -> State s -> Hints (Token s) -> m b) -> (ParseError (Token s) e -> State s -> m b) -> m b }
13:43:47 <ph88> yes but on line  355 you get that function by doing  unParser p   and then 5 arguments are given
13:44:01 <geekosaur> (and now you see why they hide that under a newtype)
13:44:25 <geekosaur> unParser applied to four functions yields m b
13:44:41 <geekosaur> er, a state and four functions
13:45:39 <ph88> yes
13:46:20 <ph88> so we in my mind i replace  unParser p s (cok . f) cerr (eok . f) eerr  by  m b
13:47:02 <ph88> so   ParsecT $ \s cok cerr eok eerr -> unParser p s (cok . f) cerr (eok . f) eerr   becomes  ParsecT $ m b
13:47:07 <geekosaur> no
13:47:14 <ph88> oh :/
13:47:29 <geekosaur> invoking unParser *removes* the ParsecT
13:47:44 <geekosaur> so it's just m b
13:48:12 <ph88> so you get    ParsecT $ \s cok cerr eok eerr -> m b   ??
13:48:19 <geekosaur> yes
13:48:37 <ph88> not sure how that is of type   ParsecT e s m b
13:48:54 <geekosaur> with the type signature for unParser, that's not surprising :)
13:49:05 <ph88> lol ok
13:49:08 <geekosaur> it's pretty scary
13:49:32 <Zemyla> How do you write, on a 32-bit system with MagicHash on, a value of type Word64#?
13:49:37 <ph88> i guess  $ \s cok cerr eok eerr ->   ends up being  e s
13:50:24 <geekosaur> don't confuse the type constructor, which takes 4 type parameters, with the data constructor that takes a single function whose signature is determined by the 4 type parameter
13:50:25 <geekosaur> s
13:51:03 <ph88> oh yes i'm confusing that for sure
13:51:04 <geekosaur> (and which here is specified as a lambda)
13:51:17 <c_wraith> Zemyla, does something like 1# :: Word64# not work? 
13:52:19 <ph88> ok geekosaur i made the loop, i see how the types fit now
13:54:35 <Gurkenglas> whittle, can I see an example of code using this? Because I suspect at least almost this entire module can be eliminated
13:55:22 <ph88> be back later
14:31:21 <teurastaja> how do i set a record type to itself and pass around the state to other functions?
14:32:07 <teurastaja> STRefs seem to destroy state but i want to pass it around
14:32:21 <teurastaja> inside a record type if possible
14:32:46 <Tuplanolla> How about an `IORef`?
14:32:53 <Rotaerk> teurastaja, what do you mean by "set a record type to itself"?
14:33:20 <glguy> teurastaja: That question doesn't seem to mean anything on its own. Do you have an example of what you're trying to do?
14:33:29 <teurastaja> something like (lambda (x) (set! x x)) in scheme
14:33:43 <geekosaur> I also don't get "destroy state" unless you were expecting an STRef to survive past the end of a runST, in which case you need to learn how ST works (don't do that)
14:34:09 <teurastaja> i need the state to survive across functions
14:34:45 <teurastaja> preferably my record type would carry its own state
14:34:49 <teurastaja> how?
14:35:21 <geekosaur> you still aren't making much sense
14:35:54 <geekosaur> could you explain the actual problem you are trying to solve?
14:36:16 <teurastaja> i have a data structure and i want an init function that sets its fields to the data structure itself and survive while i pass the structure to other functions
14:36:50 <Liskni_si> that looks a lot like imperative thinking :-/
14:37:14 <teurastaja> i have no choice
14:37:17 <geekosaur> more like scheme thinking
14:37:20 <teurastaja> its dancing links
14:37:27 <glguy> teurastaja: Yes, that's right. You have no choice, you can't do that.
14:37:37 <glguy> You can put IORefs in your data structure, however
14:38:06 <teurastaja> does it need to be IORefs or do STRefs work also?
14:38:15 <glguy> If you want to put STRef, that's fine too. You'll just need to parameterize your record type so you can share that type with the STRef
14:38:37 <glguy> data T s = MkT { someField :: STRef s SomeType }
14:39:34 <teurastaja> glguy: so the field is always an STRef and gets passed around normally with the structure?
14:39:48 <teurastaja> thats it?
14:41:00 <teurastaja> so the new type takes a state and returns a state to SomeType is that right?
14:41:06 <teurastaja> sorry im noob
14:43:20 <Liskni_si> STRef is essentially a mutable variable, there's no taking/returning of state
14:43:39 <Liskni_si> you access it via readSTRef/writeSTRef
14:44:47 <Tuplanolla> You don't usually need `ST` unless you're after better performance or some really wacky data manipulation, teurastaja.
14:45:27 <Tuplanolla> I don't know if that's the case here since I'm only vaguely familiar with dancing links.
14:49:21 <teurastaja> Tuplanolla: dancing links is a special case of needing state absolutely unless you tie the knot (good luck)
14:50:27 <teurastaja> its to make a sparse matrix of quad-linked (+ header link and 3 Ints) circular lists
14:51:46 <teurastaja> they need to be initialized to point to themselves
14:51:57 <int-e> teurastaja: knot tying will defeat the primary purpose of the data structure: quick updates (removal from and re-insertion into the various lists).
14:52:12 <teurastaja> int-e: exactly
14:52:27 <teurastaja> so no choice unless lenses can do that
14:52:42 <teurastaja> but im not familiar with them
14:56:27 <teurastaja> in this line how do you initialize T with the state?: data T s = MkT { someField :: STRef s SomeType }
14:57:14 <teurastaja> what do you fill that 's' with?
14:57:31 <teurastaja> sorry for being a complete haskell noob
14:58:27 <teurastaja> or does it get filled automatically with some state?
14:58:36 <implementation_> you don't fill the s. Just don't touch it. runST will fill it for you (it needs to be universally-quantified)
14:58:39 <Liskni_si> maybe here's some info about STRef's: http://stackoverflow.com/questions/12468622/how-does-the-st-monad-work
14:59:00 <Liskni_si> for a beginner, it might be better to just ignore STRef and start with IORefs instead
14:59:05 <teurastaja> can i runST multiple times?
14:59:29 <Liskni_si> if you want to use state from one in another, no
14:59:46 <teurastaja> Liskni_si: thanks
15:00:17 <Liskni_si> you use a single runST to run an entire effectful computation and get a single result out of it
15:01:02 <teurastaja> alright i think i can start translating my sudoku generator from scheme to haskell now thanks. ill come back for more questions later need to plug my laptop ;)
15:02:18 <teurastaja> by the way scheme R7RS is becoming bullshit thats why im learning haskell 
15:03:42 <Tuplanolla> What a coincidence. I'm a Scheme migrant as well.
15:04:26 <teurastaja> last update to the standard was about renaming comparator hashing and sorting libraries and introducing "pure" functional lists that arent in the base language and arent compatible with other types
15:04:52 <teurastaja> oh and im not sure if theyre efficient and they have rlists and ilists
15:04:57 <teurastaja> sucks
15:06:01 <Liskni_si> what makes you think that haskell won't evolve outside your comfort zone, too? ;-)
15:06:33 <Tuplanolla> Template Haskell is probably already there.
15:06:49 <monochrom> my comfort zone evolves outside Haskell
15:06:55 <teurastaja> i still cant program a scheme compiler for a 8051 arch without function pointers in xdata zone, which makes compilers think its a union of structures and crashes any program anyways...
15:08:56 <teurastaja> was thinking of using reentrant setjmp and longjmp to get free continuations but then maybe im better using assembly to make sure i get all the registers right
15:09:38 <teurastaja> on PIC16 forget lambdas the stack is 8 levels deep and that includes interrupts
15:10:17 <teurastaja> id like to see lambdas on microcontrollers...
15:10:27 <ij> What meaning does <*> have for parser combinators?
15:11:12 <Tuplanolla> Informally concatenation of productions, ij.
15:12:34 <Tuplanolla> > (,) <$> Just 2 <*> Just 3 -- You can use it to pass the results of multiple parsers into a single function like this.
15:12:37 <lambdabot>  Just (2,3)
15:13:40 <ij> ah, gotcha
15:24:19 <codedmart> Is there already a function to tell which week a UTCTime is in the month? I see one to tell the week of the year?
15:28:08 <kadoban> One of the formatting ones maybe
15:36:21 <codedmart> kadoban: Any idea where I should look?
15:43:43 <codedmart> What I want to do is check if a UTCTime is a holiday. I know that Thanksgiving for instance is the 4th day of the 4th week of the 11th month.
15:44:35 <codedmart> So I have certain holidays like that. So I see how I can get the month, and day of that week, but I am only seeing how to get the week in total week from that year. Not the month.
15:51:04 <amx> convert it all to OrdinalDate
15:51:57 <amx> oh, 4th week
15:56:24 <kuribas> :t fmap and . sequence
15:56:26 <lambdabot> (Traversable t, Monad f) => t (f Bool) -> f Bool
15:56:39 <kuribas> is there a better way to do this?
15:56:57 <mtjmullen> :t traverse and
15:56:59 <lambdabot> error:
15:56:59 <lambdabot>     • Couldn't match type ‘Bool’ with ‘f b’
15:56:59 <lambdabot>       Expected type: t1 Bool -> f b
15:57:07 <mtjmullen> yeah, that occured to me as soon as I typed that :P
15:57:19 <kuribas> :t andM
15:57:20 <lambdabot> error:
15:57:20 <lambdabot>     • Variable not in scope: andM
15:57:20 <lambdabot>     • Perhaps you meant ‘and’ (imported from Data.List)
16:00:20 <jejune> Hi everyone!
16:00:50 <kuribas> hello
16:01:22 <jejune> Is there a better way to convert a function f :: a -> b to a function a -> m b in do-notation than to just use (return . f) ?
16:01:37 <Welkin> jejune: pure
16:02:17 <dibblego> jejune: use fmap or (<$>)
16:02:44 <c_wraith> kuribas: I'm pretty sure that's as good as you'll get for that.
16:03:13 <kuribas> ok
16:03:47 <zgrgr> clear
16:03:53 <zgrgr> woops, means /clear
16:04:57 <kuribas> jejune: you know you can use let inside do notation?
16:05:26 <c_wraith> kuribas: I kept thinking about how if you had just the right newtype instances, it'd just be a foldmap.  But, uh, you'd need to write at least one of those instances. :)
16:05:42 <kuribas> jejune: "a <- return (f b) " => "let a = f b"
16:05:49 <kuribas> c_wraith: like All?
16:06:04 <jejune> kuribas: thanks!
16:06:16 <c_wraith> kuribas: and some monoid that lifts another monoidal operation into Applicatives
16:06:35 <c_wraith> The latter is the one that I'm unsure of the existence of.
16:06:38 <teurastaja> having trouble writing initNode. Since Node carries state, doesn't it have to be initialized with newSTRef ? 
16:06:39 <teurastaja> http://pastebin.com/F0AhRM9b
16:06:49 <c_wraith> It's certainly not in Data.Monoid, but it could be in another library
16:07:09 <jejune> Honestly do notation is really confusing
16:07:32 <teurastaja> all Nodes have to be initialized to themselves
16:07:32 <c_wraith> teurastaja: yeah, that type signature isn't going to work.
16:07:49 <dibblego> jejune: you might consider posting the code to best answer the question
16:07:57 <Forlorn> Hi, how may I group every two elements in list [1,2,3,4,5,6] like so [[1,2],[3,4],[5,6]]? 
16:07:57 <c_wraith> teurastaja: also, that Node type won't really work.
16:08:19 <Forlorn> (first list being input, the second the output)
16:08:30 <c_wraith> teurastaja: Well, ok, Node might work, but the s parameter is really important.  hiding it like that is awkward.
16:08:41 <kuribas> wouldn't it be useful to have a "parser" combinators library for lists?
16:08:45 <teurastaja> c_wraith: can you initialize the Node fields to the Node itself as an example please?
16:08:48 <jejune> dibblego: kuribas answered my question, I think
16:08:55 <jejune> thanks for your help
16:09:01 <c_wraith> teurastaja: in particular, because InitNodes needs the type [Int] -> ST s (NodeST s)
16:09:41 <teurastaja> c_wraith: you mean STRef ?
16:09:47 <c_wraith> teurastaja: nope.
16:10:02 <c_wraith> teurastaja: You can't have a NodeST value escape ST
16:10:03 <kuribas> Forlorn: you need to write it.
16:11:40 <Forlorn> something like this?
16:11:41 <Forlorn> let foo [] = []; foo (xs:x:y) = (x,y) : foo xs
16:11:47 <teurastaja> c_wraith: and how do you initialize all Node fields to point to themselves?
16:12:37 <kuribas> > let foo (xs:x:y) = (x,y) : foo xs; foo _ = [] in foo [1..6]
16:12:39 <lambdabot>  error:
16:12:39 <lambdabot>      • Occurs check: cannot construct the infinite type: t1 ~ [t1]
16:12:39 <lambdabot>        Expected type: t1 -> [(t1, [t1])]
16:12:52 <kuribas> > let foo (x:y:xs) = (x,y) : foo xs; foo _ = [] in foo [1..6]
16:12:54 <lambdabot>  [(1,2),(3,4),(5,6)]
16:13:43 <exio4> I think something withj splitAt could be hacked 
16:13:54 <Forlorn> kuribas, thanks!
16:14:50 <Liskni_si> teurastaja: you'll probably need this: https://wiki.haskell.org/MonadFix
16:15:37 <exio4> > unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitAt 2 xs); ) [1..6]
16:15:40 <lambdabot>  [[1,2],[3,4],[5,6]]
16:15:58 <teurastaja> Liskni_si: oh god... how/why?
16:17:49 <teurastaja> how will MonadFix solve my problem?
16:18:04 <exio4> > unfoldr (\xs -> guard (not $ null xs) >> Just (splitAt 2 xs)) 
16:18:06 <lambdabot>  error:
16:18:07 <lambdabot>      • No instance for (Typeable a0)
16:18:07 <lambdabot>          arising from a use of ‘show_M442201212317011292427761’
16:18:14 <glguy> teurastaja: You can initialize them to point to an "undefined" and then afterward set them to the value you've constructed. MonadFix is a convenient solution, too
16:18:16 <exio4> > unfoldr (\xs -> guard (not $ null xs) >> Just (splitAt 2 xs)) [1..7]
16:18:19 <lambdabot>  [[1,2],[3,4],[5,6],[7]]
16:18:28 <Liskni_si> teurastaja: http://lpaste.net/350948
16:18:58 <Liskni_si> but glguy is right that newIORef undefined works even without MonadFix/RecursiveDo, I hadn't thought of that
16:19:09 <exio4> Forlorn: :P ^ if you want an inline version
16:20:15 <teurastaja> Liskni_si: how?
16:20:40 <teurastaja> i feel like a baby trying to make its first steps on mount Everest
16:20:50 <Rotaerk> welcome to haskell !
16:21:23 <teurastaja> Liskni_si: example?
16:21:35 <Liskni_si> teurastaja: you haven't chosen the best task to learn haskell with, to be honest
16:22:05 <glguy> teurastaja: make an IORef initialized with the value 'undefined', set it to the desired value afterward
16:22:16 <hpc> you still have to make the type right
16:22:55 <Liskni_si> teurastaja: http://lpaste.net/350948#a350949
16:23:15 <c_wraith> I'd use do rec instead of explicit mfix
16:23:49 <glguy> explicit mfix hasn't even come up yet
16:23:56 <Liskni_si> today is the first time I've actually used RecursiveDo, so, c_wraith, pardon my french :-)
16:24:16 <c_wraith> I spoke before I read the snippet. :) 
16:24:27 <teurastaja> Liskni_si: pourquoi utiliser pure?
16:25:02 <Liskni_si> teurastaja: s/pure/return/, whatever, it's the same :-)
16:25:08 <teurastaja> oh true
16:25:29 <Liskni_si> it's just a habit
16:26:10 <teurastaja> and what does RecursiveDo eat in winter?
16:26:52 <Liskni_si> now I'm lost
16:27:18 <hpc> what's the name of data Foo f where Foo :: f (Foo f) -> Foo f?
16:27:20 <Liskni_si> and I should go to sleep or I'll be late for a group ride tomorrow
16:27:33 <c_wraith> hpc, Fix
16:27:39 <hpc> i thought it was Fix, but can't find it with hoogle
16:27:51 <hpc> c_wraith: :(
16:28:12 <glguy> I don't think it lives in any one notable place
16:28:17 <Liskni_si> https://hackage.haskell.org/package/data-fix-0.0.3/docs/Data-Fix.html
16:28:35 <hpc> glguy: ah
16:29:15 <nshepperd> hpc: I think it's also called Mu, in recursion-schemes
16:29:47 <Liskni_si> and also here: https://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Functor-Fix.html :-)
16:29:47 <kuribas> :t foldlM (fmap . (&&)) True
16:29:49 <lambdabot> (Foldable t, Monad m) => t (m Bool) -> m Bool
16:30:05 <kuribas> c_wraith: ^^^
16:30:55 <hpc> nshepperd: oh, it's actually Fix in recursion-schemes too
16:31:12 <hpc> a lot of this stuff just doesn't seem to get drilled down by hoogle
16:31:20 <hpc> it stops at finding the package name
16:31:24 <kuribas> c_wraith: that should be more efficient.
16:31:45 <hpc> anyhoo that's the other part of what you would need for mfix and making an IORef point to itself
16:32:10 <hpc> instead of constructing an (IORef something), it'd be (Fix IORef)
16:32:48 <glguy> The goal in this case wasn't to actually point the IORef to itself, luckily, but to the record containing the IORef, so the loop is already broken and we don't need to bring in Fix
16:33:14 <hpc> oh, boring ;)
16:34:53 <nshepperd> oh, it was Mu in ekmett's catamorphisms posts on school of haskell
16:35:17 <teurastaja> does manipulating state imply importing the entire haskell namespace?
16:35:35 <teurastaja> just wondering
16:35:40 <glguy> You'll be importing lots of stuff no matter what you're doing
16:35:49 <nshepperd> in recursion schemes it's some kind of wacky cps'd thing
16:35:50 <hpc> there's no "entire haskell namespace" ;)
16:36:41 <teurastaja> screw it... got any example of dancing links implementation other than the exact-cover package which i cant understand?
16:37:42 <teurastaja> i thought i was way above average but when i come here i feel like a door knob
16:38:46 <kuribas> :t foldl (liftA2 (&&)) (pure True) -- c_wraith: or this one
16:38:48 <lambdabot> (Foldable t, Applicative f) => t (f Bool) -> f Bool
16:38:49 <geekosaur> we've all been there :)
16:40:41 <hpc> yeah, the ML family as a whole pulls in enough new concepts that it ends up feeling like starting over
16:41:22 <teurastaja> cant believe the State of AI in Haskell is so underdeveloped. maybe its because Haskell has no State...
16:41:26 <sm> fresh start! like learning BASIC!
16:42:40 <hpc> my first substantial program was a game of pong in TI basic in middle school
16:42:49 <hpc> it took under an hour and i did it because i finished a test early and got bored
16:42:52 * sm high-fives hpc
16:43:01 <hpc> then my first substantial program in haskell was an irc bot
16:43:09 <hpc> it took me a month to get it to connect to a network
16:43:28 <sm> ouch
16:43:42 <hpc> it was worth the effort ;)
16:43:43 <sm> irc is a tricky first program though
16:44:12 <hpc> it was partly irc being a pretty weird protocol
16:44:18 <hpc> partly me coming to haskell straight from java
16:44:45 <hpc> and partly trying to split my attention between a legitimate learning resource and some pages on haskellwiki
16:46:08 <hpc> a couple of years later and i was slinging zygohistomorphic prepromorphisms with the best of them
16:46:25 <hpc> or at least with the averagest of them
16:50:27 <monochrom> haskell wiki is not quite a learning resource.
16:50:56 <monochrom> most authors there are authors for venting their enthusiasism.
16:52:16 <monochrom> Do not think that it is a positive thing (for readers like you). No, venting enthusiasm means stream of consciousness braindump going off multiple tangents just because they learned something "awesome" 5 minutes ago.
16:52:38 <monochrom> The very antitheses to teaching and explaining, really.
16:52:41 <kuribas> :t fmap getAll . foldMap (fmap All) -- c_wraith this what you where after?
16:52:43 <lambdabot> (Monoid (f All), Foldable t, Functor f) => t (f Bool) -> f Bool
16:54:23 <geekosaur> see also: monad tutorials >.>
16:55:01 <exio4> geekosaur: monad tutorials? I thought they taught how to make burritos!
16:55:41 <nshepperd> kuribas: the Monoid a => Monoid (f a) instance doesn't real :(
16:56:00 <nshepperd> (Monoid f, Applicative f) => Monoid (f a), I mean
16:56:40 <nshepperd> if it existed it would conflict with things, sadly
16:57:38 <kuribas> nshepperd: well it will work with concrete instances.
16:57:55 <sm> monochrom: haskell wiki*book* was better than that, IIRC
16:59:38 <kuribas> :t let f = fmap getAll . foldMap (fmap All) in f (undefined :: [Maybe Bool])
16:59:40 <lambdabot> Maybe Bool
17:00:13 <nshepperd> > let f = fmap getAll . foldMap (fmap All) in f [[True, False], [True, False]]
17:00:16 <lambdabot>  [True,False,True,False]
17:00:39 <monochrom> Somewhat better. I had hopes originally. Until I saw: (1) A redundant series of exercises progressing from "data Two a = Two a a" to "data Four a = Four a a a a"; (2) That wall-of-text interwined story about the guy phoning up the ex-girlfriend for programming help.
17:01:11 <nshepperd> > let g = foldl (liftA2 (&&)) (pure True) in g [[True, False], [True, False]]
17:01:13 <lambdabot>  [True,False,False,False]
17:01:47 <nshepperd> kuribas: the Monoid instance for [a] is the wrong one
17:02:09 <monochrom> Also in the denotational section, "the bottom type, bottom at the type level". (This is where I get to say: FIFY.)
17:04:22 <kuribas> nshepperd: strange
17:04:38 <nitrix> Is there such thing as a MVar where you don't need the value but simply need it for the sync/wait semantic?
17:04:57 <monochrom> usually we use MVar () for that.
17:05:04 <nitrix> monochrom: Ah okay, thanks.
17:05:16 <nshepperd> > let f = fmap getAll . foldMap (fmap All) in f [[True, False], [True, False], [True, False]]
17:05:18 <lambdabot>  [True,False,True,False,True,False]
17:05:23 <nshepperd> > let g = foldl (liftA2 (&&)) (pure True) in g [[True, False], [True, False], [True, False]]
17:05:27 <lambdabot>  [True,False,False,False,False,False,False,False]
17:05:39 <nshepperd> ^^ will show what is going on
17:06:27 <kuribas> nshepperd: well, depends on what you want I guess.
17:39:17 <kuribas> hm, StateT isn't a monoid
17:40:05 <jle`> i wonder if there's a monoid wrapper for applicatives
17:44:03 <jle`> i can't find one in the usual places
17:44:41 <kuribas> jle`: google gave me this: https://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Applicative.html
17:45:21 <EvanR> look in the edkskell packages
17:46:18 <EvanR> ? https://hackage.haskell.org/package/reducers-3.12.1/docs/Data-Semigroup-Applicative.html
17:49:37 <jle`> kuribas: nice :o
17:50:11 <jle`> reducers's wrappers are nice too
17:53:47 <_sras_> Why does a Servant route like "users/list" creates a 404 not found error, but a url "users_list" works fine?
17:56:46 <alx741> There is very little people in #yesod, so no help there. I'm trying to modify the function 'isAuthenticated' to evaluate to 'Authorized' only if the 'User' field 'isAdmin' is 'True', how can I achieve that? the monadic wrapping got me puzzled
18:01:24 <wespiser> did any one see Harper's "Correctness of Compiling Polymorphism to Dynamic Typing" in Func Prog langs last week?
18:03:29 <wespiser> alx741: can you pastebin source?
18:07:55 <alx741> wespiser: Here is what I tried: http://pastebin.com/AYvP83Uc
18:08:38 <wespiser> whats the error message?
18:09:46 <alx741> I got: http://pastebin.com/1bsz6ZMP
18:12:05 <wespiser> "get uid" => "uid"
18:14:22 <alx741> that produces: http://pastebin.com/fppJmCqu
18:20:07 <wespiser> one more idea, (id <- get uid\n     Unathuorized $ "should be an admin " ++ pack (show (userIsadmin (uid))) } } "
18:20:15 <wespiser> one more idea, (id <- get uid\n     Unathuorized $ "should be an admin " ++ pack (show (userIsadmin (id))) } } "
18:20:36 <wespiser> the monadic assignment should bind the value of the monadic transformer
18:23:19 <codygman> No optimizations are applied in ghci right? So the only way to make functions run faster in ghci is to allocate less/do less?
18:23:34 <geekosaur> yes
18:24:05 <alx741> wespiser: should that be placed inside the 'Just uid -> ' ?
18:24:17 <wespiser> yea, that should work
18:25:25 <wespiser> get uid >>= (\i -> Unathuorized $ "should be an admin " ++ pack (show (userIsadmin (i))) 
18:29:20 <alx741> wespiser: http://pastebin.com/x8mkM0JU
18:31:55 <alx741> that should be a very simple thing to do right? It starts to bother me how the tools for removing complexity always seems to drive to a mess of unmanageable complexity. Maybe I'm just doing everything wrong though ¯\_(ツ)_/¯
18:32:44 <wespiser> it took me a while to learn monad transformers
18:32:56 <wespiser> yea, its a little complex
18:33:22 <wespiser> if we start with what you have, you need to go from: ‘ReaderT SqlBackend m0 (Maybe User)’ -> 'User'
18:35:40 <wespiser> the (get uid) -> (\i -> fn i) is a desugared monadic bind where i :: Maybe User 
18:35:57 <wespiser> there's some other weird stuff going on, which I think has to do with applies
18:36:35 <alx741> the yesod book has an example of somethin like that, but dones't provide the models for that particular example, and it doesn't work: http://www.yesodweb.com/book/authentication-and-authorization 
18:37:17 <wespiser> I'm not familiar w/ yesod at all, but isn't the book pretty old?
18:38:43 <alx741> I've found most of it isn't. That example doesn't fit at all with my models, so i think it doesn't apply
18:41:44 <alx741> woooww!! doing: "Just userIsadmin -> Authorized" compiled!
18:42:34 <alx741> userIsadmin :: User -> Bool   (I think)
18:42:45 <alx741> yep, it is
18:43:17 <glguy> alx741: Did you fix your isAdmin definition?
18:44:08 <alx741> glguy: It now looks like: http://pastebin.com/PHjnrsch
18:44:24 <alx741> and it compiled but, of course, I have no idea way
18:44:35 <alx741> *wy
18:44:48 <alx741> **why
18:44:55 <lpaste> glguy pasted “for alx741 - more like this” at http://lpaste.net/350951
18:45:25 <glguy> alx741: In http://pastebin.com/x8mkM0JU you had a 'return' on the outside of the case expression
18:45:34 <alx741> my brain is already dying, I even forgot how to type
18:45:51 <glguy> return :: a -> Handler a
18:46:17 <wespiser> yea, I would read https://hackage.haskell.org/package/yesod-auth-1.4.15/docs/Yesod-Auth.html, get a handle on the types, then take a look athttps://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
18:46:22 <glguy> but then in your Just uid -> alternative you were using 'get'
18:47:25 <glguy> alx741: Also you had :    get uid >>= \ i -> Unauthorized ...
18:48:20 <glguy> I don't know what type your 'get' has, but AuthResult probably doesn't have the correct type to be the result of that function
18:53:01 <alx741> I'll need to have a deeper inspection on that so it doesn't take me 2 days again, thanks a lot guys!
18:57:04 <wespiser> alx741, you are pretty close to 'grokking' it, keep with it!
19:08:48 <jmorris> can someone help me with this http://lpaste.net/350952? I'm having trouble writing the dropJ function...
19:10:05 <glguy> jmorris: Do you have any ideas as how you should start?
19:10:44 <jmorris> glguy: not really
19:11:36 <jmorris> it takes a JoinList so should I write a matching pattern for each case?
19:14:32 <monochrom> yes
19:14:52 <glguy> Yes, you'll have to consider the three cases. I'm not sure how the exercise intends for you to proceed, but when you're considering dropping elements from an Append case, it might be nice to know how many elements are on the left side
19:15:13 <glguy> or to know how many you dropped
19:16:08 <dibblego> jmorris: what to do if n <= 0 ?
19:16:39 <jmorris> return Empty i spose
19:16:58 <dibblego> if you drop 0 elements from the list [1,2,3] what list do you have?
19:17:07 <jmorris> oh
19:17:11 <jmorris> same list
19:17:37 <dibblego> correct
19:18:00 <dibblego> now if n>0 you need to handle each case of JoinList. There are three.
19:19:08 <jmorris> i tried dropJ n Empty = Empty but I get an error
19:20:01 <jmorris> http://lpaste.net/350955
19:20:21 <jmorris> the error only occurs when I try to use dropJ
19:20:24 <jmorris> not when it compiles
19:20:58 <glguy> jmorris: YOu can give GHCi a type when you try to use it
19:21:08 <glguy> It's not sure what your empty join list is an empty list of
19:21:47 <glguy> Int? Char? IO Bool?
19:22:07 <dibblego> jmorris: what are you giving to ghci?
19:22:16 <jmorris> dropJ 10 Empty
19:23:31 <glguy> I don't know what types have instances of Sized, but if you can think of one (and I'll call it T for now) you could write:   dropJ 10 Empty :: JoinList T ()
19:24:43 <dibblego> :info Sized
19:25:09 <jmorris> this is sized http://lpaste.net/350956
19:25:31 <jmorris> dropJ 10 Empty :: JoinList Size ()
19:25:42 <jmorris> = Empty
19:25:44 <dibblego> instance Sized Int where size = Size
19:26:17 <dibblego> dropJ (10 :: Int) Empty
19:26:34 <dibblego> or
19:26:38 <dibblego> dropJ (Size 10) Empty
19:27:34 <jmorris> neither of those worked, but dropJ 10 Empty :: JoinList Size () did
19:28:12 <dibblego> ok yeah
19:28:32 <dibblego> dropJ 10 (Empty :: JoinList Size ())
19:28:47 <jmorris> so the empty case works?
19:29:02 <dibblego> it's because the type of Empty does not resolve what kind of JoinList
19:29:25 <jmorris> should it?
19:29:33 <dibblego> it can't
19:29:40 <jmorris> ok
19:29:52 <dibblego> giving the explicit type resolves it, so it knows how to show (at ghci)
19:30:00 <dibblego> otherwise, which Show to use?
19:30:14 <dibblego> hence, the ambiguous type error, it can't work out how to resolve it
19:31:02 <geekosaur> there's a very small list of typeclasses that allow defaulting to work in that case. ghci's ExtendedDefaultRules extend that a bit, but you can still end up too polymorphic for ghci to figure out which instance to use
19:31:40 <geekosaur> (notably, Num has to be involved somewhere iirc)
19:36:06 <jmorris> how can I test dropJ n list | n <= 0 = list
19:36:32 <dibblego> dropJ (-3) (Empty :: JoinList Size ())
19:37:05 <jmorris> ok
19:37:20 <jmorris> it returns Empty, I'm pretty sure it's supposed to
19:37:26 <dibblego> yes
19:39:17 <jmorris> Is a single just one list?
19:46:23 <glguy> Yes
19:49:00 <jmorris> I think I already have handled the single case
19:49:22 <jmorris> actually
19:49:41 <jmorris> it will either return empty or the list, i think
19:51:49 <jmorris> this is where the exercise comes from http://www.seas.upenn.edu/~cis194/spring13/hw/07-folds-monoids.pdf
19:53:29 <erisco> what is a strategy to name modules if another module already has taken the name? particularly the only sensible name, given convention, is Data.Set
19:54:14 <erisco> the community doesn't seem to be into including vendor names
19:54:23 <dibblego> I tend to use unicode characters if I need a unique module name that has no other purpose than "others are unlikely to choose this"
19:57:51 <erisco> the only option I see is doing Data.Set.X where X is some superfluous name
19:58:28 <wespiser> erisco: I know there's a google api like Data.Network.Google.X
19:58:50 <MarcelineVQ> erisco: are people likely to use containers Set and your Set at the same time?
20:07:53 <meglomaniac> why am I getting a ''splitAt' '' not in scope error here? http://imgur.com/a/1qlbT
20:08:36 <glguy> meglomaniac: Better to put the actual program and the error on a pastebin like lpaste.net
20:08:58 <glguy> meglomaniac: but in this case the where clause is only for the second splitat case
20:09:07 <glguy> it doesn't span both the first and second
20:09:23 <glguy> swap lines 2 and 3
20:10:18 <meglomaniac> swapping 2 and 3 worked
20:10:25 <meglomaniac> but im not sure why
20:10:39 <glguy> In general it wouldn't be appropriate for a where clause to be in scope in both lines 2 and 3
20:10:55 <glguy> the variables bound for those lines, like x and xs, would be in scope some times and not others
20:11:29 <Cale> meglomaniac: Because the where only scopes over the declaration it's attached to, and you need splitAt' in the splitat n (x:xs) case, not the other one
20:11:50 <meglomaniac> ah okay
20:11:52 <meglomaniac> that makes sense
20:20:17 <glguy> erisco: you can use the PackageImports extension of you find yourself with two conflicting modules
20:44:47 <ogkloo> is it still common to use Yesod's scaffolded site? Every tutorial I can find using that is out of date.
20:54:33 <dustmote> can you hide an io action inside of a monad if you provide an appropriately typed run* method?
20:55:18 <glguy> sure
20:55:39 <glguy> newtype DefinitelyNotIO a = DNI (IO a)
20:58:15 <dustmote> ok, yeah.. that is prettymuch what i have already done so far ..
20:59:42 <dustmote> i'd like to take it a step further though; i have a couple of different kinds of io actions that i'd like to handle, see i'm wrapping a c library which has strange constraints about when the library functions can be called that relate to thread-local state
21:00:46 <dustmote> i'd really like to capture the constraints in phantom types on  or data constructor arguments to  .. problem is, both of those solutions break monads
21:01:18 <dustmote> oops **i\d like to take it a step further though
21:01:27 <dustmote> ugh
21:02:33 <dustmote> i would really like to capture the constraints in phantom types on `DefinitelyNotIO` or data constructor arguments to `DNI` .. problem is, both of those solutions break monads
21:04:22 <dustmote> phantom types would make it so my lovely monad is a bunch of different monads that need to be glued together mtl style
21:04:59 <dustmote> sticking data constructor arguments in with the `IO ()` make it rather difficult to implement applicative..
21:13:59 <Gurkenglas> Why does each c library need its own wrapper haskell library? Sounds automatable
21:15:07 <ertes> dustmote: you're looking either for different monads or monadic regions or even an approach based on witnesses, but the latter is a bit awkward in haskell
21:15:34 <ongy> Gurkenglas: maybe the binding generation, but we do like to have higher levels of abstraction/some guarantees that things are executed in the right order
21:16:10 <ongy> also you could have a look at the pulseaudio package (I made) that was really a pain to do, because the design isn't straight forward "call this, then call that"
21:16:46 <dustmote> ongy: yeah that sounds similar what i am dealing with
21:16:51 <monochrom> Yes there is a mathematical proof that this is automatable in practice.
21:17:25 <ertes> dustmote: although it might just work in this case:  withPrivilege :: (forall s. Privilege s -> Region s M a) -> M a
21:17:44 <ertes> dustmote: that's a mixture of the latter two approaches
21:17:46 <dustmote> Gunkenglas: it is only one c library, the functions just have state-oriented rules around which they must dance
21:17:56 <monochrom> In practice, you only need to consider "all C libraries in existence in the year 2016 and/or before". There are only finitely many of them. Any mapping with a finite domain is computable.
21:18:07 <ertes> dustmote: oh, actually you don't need the region at all
21:19:32 <ertes> dustmote: make functions that can only be called under certain circumstances take a "witness" that those circumstances hold…  make sure that these witnesses only exist during that time (that's what the rank-2 type does)
21:19:33 <dustmote> monochrom: lol..
21:20:57 <dustmote> ertes: taking a look at monadic regions now.. seems you think witnesses are more applicable?
21:21:13 <ertes> dustmote: they solve the same problem in different ways
21:21:56 <ertes> dustmote: the witness approach is fine in haskell, as long as the privilege is not related to certain data
21:23:51 <ongy> monochrom: that sounds like making a bad model "works for all we have, can't predict things though, no idea"
21:24:24 <ertes> dustmote: example of when it doesn't work as well (pseudo-code):  delete :: (key :: k) -> DeleteAccess key -> Map k a -> Map k a
21:24:45 <monochrom> Yes ongy. I would think that an armchair question begets an armchair answer.
21:25:20 <ertes> dustmote: "delete the given key", but you need to pass a "delete access to this key" access token, a witness that the circumstance "this key can be deleted" holds
21:30:33 <dustmote> this seems to discuss regions and witnesses http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
21:34:34 <ertes> dustmote: newtype SafeHandle s = SafeHandle { fromSafeHandle :: Handle }
21:34:35 <ertes> safeWithFile :: FilePath -> IOMode -> (forall s. SafeHandle s -> IO r) -> IO r
21:34:55 <ertes> then write: safeGetLine :: SafeHandle s -> IO String
21:35:28 <ertes> now don't export the constructor of SafeHandle
21:35:37 <dustmote> that's it? that's the ST monad trick, right?
21:35:54 <ertes> pretty much, except that you only need the 's' for the handle
21:35:59 <ertes> not for the whole monad
21:37:49 <dustmote> that's an improvement i might be able to use.. i think this helps with the resource parts of wrapping the library, but i have some other questions
21:39:10 <dustmote> the library allows the setting of callback handlers, as well as some functions which it explicitly states cannot be called in the callback handlers because they aren't "reentrant" (i guess that means they're IO that's explicitly manipulating the thread local state)
21:40:40 <dustmote> i've been thinking if there's a way to allow the callbacks access to general IO, without allowing them to run the non-reentrant functions
21:41:30 <dustmote> the answer is no, since users could (runTheMonad nonReentrantAction :: IO ()) in any case
21:42:30 <dustmote> but i wonder if there's a gentle way of encouraging users against the use of non-reentrant functions in the reentrant+IO context?
21:43:33 <meghnath> hello
21:45:35 <dustmote> meghnath: hello! usually on IRC you just dive into your desired discussion without waiting for greetings
21:47:26 <jle`> they have left
21:48:28 <dustmote> oops i turned joinquits off.
21:53:31 <ongy> dustmote: non-reentrant is annoying, that's both not-threadsafe (i.e. you can't call it twice) and makes problems with signalhandlers (shouldn't be a problem from haskell bindings)
21:53:49 <ongy> do you have a reason to asume thread-local?
21:58:38 <dustmote> opengl is involved :P
21:59:43 <ongy> not that familiar with ogl, the thing I wanted to know is if you have a good reason to think it's thread-local and not global
22:02:03 <monochrom> opengl is also thread-local.
22:20:30 <IANIMATEDYOU> help me help you https://www.fiverr.com/nicodaunt/animate-any-picture-you-send-me
22:21:40 --- mode: ChanServ set +q *!*@*ip.73.190.88.83
22:57:13 <kadoban> Is there any special meaning to blah.whatever.something.\ in a profiling report?
22:57:35 <kadoban> (specifically the \ part)
22:58:12 <kadoban> As a "cost centre" name, if that wasn't clear.
23:05:36 <kadoban> Oh I wonder if that's for like a lambda or something maybe ...
23:07:59 <pavonia> It is, IIRC
23:09:11 <kadoban> Thanks :)
23:18:11 <jchia_> Question about Control.Concurrent.STM.TBQueue & Control.Concurrent.Chan: What's a good way to simulate blocking read from multiple channels without using a 100% CPU busy loop? In other words, I want to block until any of the channels has an available item and then read it, a la Unix select().
23:23:51 <rblaze> jchia_: with STM just read from all channels, in any order. Transaction will retry if any of them is empty.
23:29:16 <jchia_> rblaze: Thanks
23:39:24 <c_wraith> do be aware that reading in any order biases towards the first ones you try to read from
23:39:41 <c_wraith> It's possible that if there's input in the first one every time the loop gets there, input on the rest will never get read
23:40:33 <c_wraith> Oh.  that only matters if you're attempting to read from the first that unblocks, not all at once.  Misread the case.
23:54:41 <kadoban> I seriously suck at profiling/optimization. Every single thing I try just makes the runtime worse xD I refuse to believe that my first attempt at this thing was optimal ...
23:57:41 <stobix> Are there instances where cabal install foo doesn't intsall all dependencies of foo, or am I doing something wrong?
23:58:27 <zipper> I'm preparing for a haskell phone interview. Should I read on testing?
23:58:44 <zipper> What should I be reading? Standard lib functions?
23:59:03 <stobix> Refresh everything! ;0
23:59:45 <zipper> I'm preparing for a haskell phone interview. Should I read on testing?
23:59:47 <zipper> What should I be reading? Standard lib functions?
