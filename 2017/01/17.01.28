00:10:47 <athan> What would you call a function `foo :: Monoid w => Maybe w -> w`?
00:11:06 <athan> `affinely`? :v (athan get's his space people dictionary)
00:15:39 <Rotaerk> foo = fromMaybe mempty?
00:17:41 <Rotaerk> there's maybeToList :: Maybe a -> [a]
00:18:02 <Rotaerk> so perhaps maybeToMonoid ?
00:19:52 <athan> Rotaerk: Ahh yeah that makes sense, idk I'm trying to think abstractly about this
00:20:12 <athan> what is Nothing compared to Just? I wouldn't call it pointed
00:20:25 <athan> shoot, maybe it is
00:20:41 <shiona> > fold $ (Nothing :: Maybe (Sum Int))
00:20:44 <lambdabot>  Sum {getSum = 0}
00:22:23 <athan> well, I think that holds different meaning than fromMaybe or catMaybes shiona
00:22:50 <athan> er.. wait
00:23:03 <athan> s_s idk anymore
00:25:05 <shiona> I'm not sure myself. I just use hoogle to search for the type 
00:25:42 <athan> I at least tried that kinda :)
00:25:44 <athan> thank you
00:26:34 <shiona> and given 'fold :: Monoid m, Foldable f => f m -> m' I don't see any other sensible definition for the case f ~ Maybe (I'm not sure that's how you use ~)
00:27:00 <athan> It is actually!
00:27:26 <athan> > fold (mempty :: (f ~ Maybe) => f (Sum Int))
00:27:29 <lambdabot>  Sum {getSum = 0}
00:27:59 <shiona> nice
00:28:05 <athan> I think you're right, I don't know what I was getting at. Thank you again
00:28:44 <cocreature> oh, I didn’t know about "fold". I’ve always used "foldMap id"
00:29:40 <shiona> no problem. I like how questions of all levels are thrown around here. When I see one that might be my level I try to come up with a solution and maybe learn some haskell myself.
00:31:03 <athan> I owe this community a lot
00:31:12 <shiona> same
00:31:43 <cocreature> without this irc channel I probably would have given up learning haskell quite early
01:31:35 <reactormonk> How can I control which directories are built on stack build/test?
01:45:21 <Axman6> raichoo: see "Example: A package containing executable programs" on https://www.haskell.org/cabal/users-guide/developing-packages.html
01:45:28 <Axman6> uh, reactormonk
01:45:43 <reactormonk> Ah, cabal handles that. kk.
01:50:08 <Axman6> cabal defines what you package is and how it's built. stack looks after what it's built with (compilers and libraries)
01:50:18 <Axman6> (toughly)
01:50:23 <Axman6> roughly*
02:12:28 <raichoo> Axman6: No problem… that's actually a useful document. I should give it a read ^^.
02:13:31 <reactormonk> What do I need for deriving Generic to work? {-# LANGUAGE DeriveGeneric #-} does not seem to be enough
02:14:14 <athan> reactormonk: GHC.Generics :)
02:14:20 <athan> to include the scope
02:14:34 <athan> (honestly I shouldn't have told you, I stare at this screen too much already :|)
02:16:39 <reactormonk> athan, works, thanks
02:17:10 <athan> np, godspeed B|
02:19:13 <reactormonk> Hm. `No instance for FromJSON Data.ByteString.ByteString` - how do I hoogle for typeclass instances?
02:26:00 <reactormonk> ah, there's a reason they don't exist.
02:26:48 <reactormonk> Any RTFM on Text vs. ByteString?
02:28:28 <Dryvnt> Hey. Is this a proper place for a beginner to ask questions?
02:28:39 <Akii> Dryvnt: #haskell-beginners
02:28:55 <Dryvnt> Cheers
02:28:57 <reactormonk> found one.
02:29:54 <Theophane> Hi everyone!
02:38:16 <mannen> what's a good book on haskell if you're just starting out, but have lots of programming experience in almost every other language (except for lisp)
02:38:45 <mannen> also, should I do some complementary math studies to get a better understanding of haskell, and if so, in what direction?
02:42:21 <Cartesianfox> Hi there :)
02:42:32 <reactormonk> mannen, any of them with typeclasses?
02:42:54 <Axman6> Dryvnt: here is also a good place too though, if you're not having luck in there
02:42:58 <mannen> reactormonk: what's a typeclass?
02:43:07 <reactormonk> good place to start :-)
02:43:11 <mannen> thanks :-)
02:43:22 <reactormonk> learn you a haskell is great
02:43:33 <Axman6> mannen: step 1) forget everything you know from other languages, it just gets in the way
02:43:52 <Axman6> @where learnhaskell
02:43:52 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:43:58 <Axman6> mannen: ^^^
02:44:06 <mannen> thanks a ton
02:44:09 <Cartesianfox> I'm a newbie too :)
02:44:16 <Axman6> bitemyapp also has a book:
02:44:20 <Axman6> @where haskellbook
02:44:20 <lambdabot> http://haskellbook.com
02:45:17 <Dryvnt> Axman6: Mhm. haskell-beginners channel seems a bit dead. I figured it out myself, but thanks. Learning how haskell works is tuff. Been so long since that half semester where we learned about it :P
02:46:27 <Jinxit> ok so i've been away from haskell for too long
02:46:47 <Jinxit> what is it exactly that allows a monad to hide information when we don't have anything like "private" in haskell?
02:46:51 <reactormonk> So Text for textual data of any kind, and ByteString for binary data?
02:46:59 <Dryvnt> I have this app I've written in Rust. I used unstable libs, and they've since changed their syntax, so I have to basically rewrite the entire thing if I want to update the rust compiler on my server. Figured I might as well toy with a new language if I had to do a complete rewrite anyway. Remembered Haskell was pretty neat from my programming languages class like a year ago, so I'm here now. Woop woop
02:47:03 <reactormonk> Jinxit, why hide information?
02:47:15 <Jinxit> not intending to do it, just curious how it works
02:47:30 <Axman6> reactormonk: re Text vs ByteString, one represents text, the other represents strings of bytes. these are not the same thing (and shouldn't be confused). A ByteString can hold UTF-8 encoded text, but is not really appropriate for working with it as if it were text
02:47:40 <boojinks> Jinxit: it's not 'hiding' information
02:47:41 <Axman6> TExt is UTF-16 encoded text data
02:47:53 <reactormonk> Axman6, hmm. Is there something for UTF8?
02:48:05 <systadmin> hi
02:48:09 <reactormonk> o/
02:48:17 <Axman6> you convert Text into UTF-8 encoded ByteStrings
02:48:39 <Axman6> and can convert UTF-8 (or 16, or 32) encoded ByteStrings to Text
02:48:43 <Jinxit> boojinks: but i can't access the inner state of IO can i?
02:49:09 <reactormonk> Axman6, any way to tell the typesystem specifically it's a UTF-8 bytestring?
02:49:17 <Axman6> Jinxit: the "state" in IO is an implementation detail that doesn't really have anything to do with IO
02:49:32 <Axman6> reactormonk: ByteStrings are just a string of bytes, nothing more
02:49:54 <systadmin> I'm new to Haskell
02:50:02 <reactormonk> systadmin, everyone is at some point.
02:50:05 <Axman6> they're appropriate for writing and reading to/from files, sending over the network etc
02:50:17 <systadmin> I just have a quick question
02:50:25 <reactormonk> Axman6, not so much for JSON?
02:50:27 <systadmin> What are top level variables?
02:50:36 <reactormonk> systadmin, give it a good guess
02:50:38 <Axman6> reactormonk: can you send JSOK over the network?
02:50:43 <Axman6> JSON*
02:50:49 <Jinxit> Axman6: and my question is how that implementation detail is hidden
02:50:50 <systadmin> Um....
02:51:09 <Axman6> Jinxit: it's hidden in Haskell by not exporting the constructor for IO
02:51:16 <Axman6> systadmin: don't ask to ask, just ask ;)
02:51:29 <systadmin> Yeah, I'm confused with how TLV's work
02:51:37 <reactormonk> systadmin, example?
02:51:39 <Axman6> TLV's?
02:51:49 <systadmin> Axman6: top level variable
02:51:51 <reactormonk> Axman6, trying to make an case for switching https://github.com/freizl/hoauth2/blob/master/src/Network/OAuth/OAuth2/Internal.hs#L24 to Text
02:52:03 <reactormonk> systadmin, or aka, what's not clear?
02:52:38 <systadmin> Actually, I'll try looking around Stack Overflow first
02:53:16 <Axman6> reactormonk: I would guess those values make the most sense as ByteStrings, things like keys in crypto etc often are
02:53:19 <Jinxit> aha
02:53:22 <Jinxit> thanks
02:53:25 <Axman6> systadmin: what is your question
02:54:00 <boojinks> Jinxit: if you really want to see what's going on, then check out the source for IO
02:54:05 <systadmin> Nevermind, found the answer
02:54:07 <boojinks> not sure what you'd get out of it though :)
02:54:09 <reactormonk> Axman6, still encoded as utf8 if you skip down to the json instances.
02:54:12 <Axman6> ah, you asked in #haskell-beginners anyway
02:55:14 <systadmin> Yeah, I'm currently reading a Haskell book
02:55:37 <Axman6> reactormonk: if you believe it's textual data, then Text might be a better choice (but if you're just making it Text for the sake of it being Text, when it's always used as a ByteString you've not really won anything)
02:56:18 <reactormonk> "always used as a ByteString"?
02:56:30 <Axman6> what is the value used for?
02:56:45 <reactormonk> Packed back into JSON
02:56:54 <reactormonk> and/or Authorization HTTP headers
02:57:12 <Axman6> hmm, actually it'll be Text in the JSON Value already won't it... might as well make it Text =)
02:58:42 <Axman6> and any framework yo're doing HTTP with should be able to encode it as ByteStrings automatically for the headers
02:59:57 <reactormonk> Just sad Text is UTF-16, got more unicode planes to cover.
03:00:59 <Axman6> It's not a detailt you really ever have to worry about
03:01:06 <Axman6> detail*
03:03:01 <Dryvnt> I've made a project with stack. I want to use use a library, but I have to add the library's package as a dependency, which is fine. The problem is: how do I know what package each lib is in? In this case, I want to use Network.HTTP, but it seems that the 'http' package does not exist. Despite it being the package on hackage that has the Network.HTTP bits I want. Any help?
03:04:11 <Axman6> I believe the package is HTTP, it's case sensitive
03:04:20 <Axman6> @Hoogle Network.HTTP
03:04:20 <lambdabot> Maybe you meant: hoogle google
03:04:27 <Axman6> @hoogle Network.HTTP
03:04:33 <lambdabot> module Network.HTTP
03:04:33 <lambdabot> Network.URL HTTP :: Bool -> Protocol
03:04:33 <lambdabot> Network.Gravatar Http :: Scheme
03:04:42 <Axman6> hmm, shame that doesn't tell you
03:05:05 <Dryvnt> Seems HTTP is right.
03:05:18 <systadmin> I have another small question
03:05:19 <Dryvnt> Seems backwards to have things like this be case sensitive, but what can you do
03:05:21 <Dryvnt> Thanks.
03:05:34 <systadmin> What does `->` do?
03:05:48 <systadmin> Example: topLevenFunction :: Integer -> Integer
03:06:26 <srhb> systadmin: That symbol is a bit overloaded
03:06:27 <Axman6> it's the function arrow, thatv type says topLevenFunction is a function which when given an Integer, returns an Integer
03:06:32 <boojinks> systadmin: http://learnyouahaskell.com/types-and-typeclasses
03:06:34 <srhb> systadmin: In that example it's the function construction (type) operator
03:06:47 <srhb> systadmin: The left hand side is the argument (type) and the right hand side is the result (type)
03:07:21 <systadmin> So if I do "Integer -> String", it would return the output as a string?
03:07:38 <systadmin> From an integer to a string
03:07:39 <srhb> systadmin: That is the type of a function that takes an Integer as argument and gives you back a String, yes.
03:08:14 <Axman6> systadmin: no, a type is a promise of what it will do, changing it means the implementation must also change
03:08:28 <systadmin> I have no idea why would I want to do `Integer -> Integer` when I can make the type signature just plain Integer
03:08:54 <boojinks> systadmin: you're not defining any behaviour but simply a type.
03:08:57 <srhb> systadmin: (+2) is Integer -> Integer
03:08:59 <Axman6> systadmin: 1 is an integer, negate is a function which takes an Integer and returns an Integer
03:09:01 <Axman6> > 1 :: Integer
03:09:04 <lambdabot>  1
03:09:10 <Axman6> :t negate :: Integer -> Integer
03:09:12 <lambdabot> Integer -> Integer
03:09:19 <Axman6> > negate (1 :: Integer)
03:09:21 <lambdabot>  -1
03:09:44 <systadmin> Oh, so it returns a negative number?
03:09:56 <boojinks> systadmin: do you know any other programming languages?
03:10:01 <Axman6> in the case of negate, yes
03:10:12 <systadmin> boojinks: before Haskell, I've been doing some Python3
03:10:14 <srhb> systadmin: negate does. (Integer -> Integer) is the type of ALL functions that take an Integer as an argument and return a (possibly different) Integer as result.
03:11:12 <boojinks> ok well Python is dynamically typed so you won't be used to functions having 'types'. Which Haskell book are you reading?
03:11:46 <vapid> :t a
03:11:48 <lambdabot> Expr
03:13:18 <systadmin> Function Arrows is a bit hard to understand
03:13:36 <systadmin> boojinks: hold on, getting the link
03:14:01 <srhb> systadmin: They read as `Type of first argument -> Type of second argument -> Type of third argument -> Type of result`
03:14:06 <srhb> systadmin: Throw in as many arguments as you like.
03:14:29 <srhb> systadmin: They tell you nothing about the behaviour of the function aside from the type (which can be more than you initially imagine)
03:14:40 <jre2> can anyone suggest a decent library for haskell record<>json (de)serialization?
03:14:52 <srhb> jre2: Aside from aeson?
03:15:01 <systadmin> boojinks: http://haskellbook.com/
03:15:16 <Axman6> systadmin: have you ever written comments in Python code like "When given a String which has the server address in it, this method will return an Object representing the database connection"? in Haskell, you would write String -> DBConnection
03:15:48 <implementation> or even ServerAddr -> DBConnection
03:16:06 <Axman6> Python gives you no real way to talk about types, basically everything is some kind of Object
03:16:26 <Axman6> in Haskell we can describe these sorts of preconditions in a way the compiler can enforce
03:17:45 <Axman6> implementation: or ServerAddr -> IO DBConnection, or MonadIO => ServerAddr -> m DBConnection =)
03:17:46 <boojinks> systadmin: I have no experience with that book but I'd suggest you re-read the types section (or alternatively look at http://learnyouahaskell.com/types-and-typeclasses) - it can be difficult to get your head around especially if your only prior programming experience is with Python (which has a completely different take on types)
03:18:28 <jre2> srhb: is aeson the normally recommended option? I haven't kept up with haskell libraries that well the last few years
03:19:00 <Axman6> jre2: at the moment yes, it's the most widely used anyway
03:19:03 <reactormonk> jre2, also kinda new here, still looks good
03:19:20 <reactormonk> Why not use String btw? Because UTF-32?
03:20:12 <Axman6> String is bad for many reasons, except if you need to accurately work with all unicode text. it's extremely space inefficient
03:20:53 <systadmin> I gotta get some Haskell related plugins for my .vimrc
03:21:07 <reactormonk> Sounds like UTF-32
03:22:29 <Axman6> String is a linked list of Chars (which represent all unicode values), so there's an overhead of something like 2 words (32 or 64 bit) per character
03:22:48 <Axman6> it's not a packed representation like Text is
03:25:10 <reactormonk> So basically UTF-32
03:25:29 <reactormonk> And Text is UTF-16 from what I understand. And use ByteString if you want UTF-8
03:27:10 <Axman6> well, ByteString is capable of holding UTF-8 encoded data, as well as UTC-16 or 32, ascii, or anything else
03:28:16 <boojinks> reactormonk: the important difference is that String is a linked list and ByteString and Text are packed
03:28:23 <reactormonk> ohh
03:28:55 <reactormonk> Is there a data type for UTF-8 specifically?
03:29:02 <Axman6> no
03:29:13 <reactormonk> How come?
03:29:31 <Axman6> do you know you need it though? I feel you don't understand what the difference between these different things is and what that difference means
03:31:09 <reactormonk> Usually no, UTF-16 covers a large part of unicode. But from what I understand, you can run into trouble if someone tosses you a character that's not in the first code page.
03:31:52 <Axman6> have you read the Text docs? it specifically mentions that occurance in right at the top of the page
03:32:12 <Axman6> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html
03:33:10 <Axman6> see also https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
03:33:24 <reactormonk> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#g:2 this part?
03:33:33 <Axman6> but since you're work with Aeson Values, you have no choice but to use Text to begin with
03:33:39 <Axman6> yes
03:34:11 <reactormonk> Yeah, let's stop bikeshedding and get back to coding and hope to not hit that case.
03:38:39 <systadmin> So in function arrows
03:39:23 <systadmin> It sort of like, enforces what kind of output it should print?
03:40:07 <systadmin> Like if the parameter after -> is Integer
03:40:08 <systadmin> The output should be an integer?
03:40:47 <boojinks> Well, it won't 'print' anything, but yes, you're telling the compiler that the result of the function HAS to be an Integer.
03:41:54 <systadmin> Oh okay, I understand now
03:41:57 <boojinks> if you then actually wrote the function to return a String, the compiler would tell you that you've messed up.
03:44:55 <systadmin> But what if I have several ->'s for one function?
03:45:14 <systadmin> Like: something :: Int -> Int -> Int
03:47:22 <sjl__> thats currying
03:47:24 <sjl__> https://wiki.haskell.org/Currying
03:47:29 <boojinks> the arrow is what is called 'right associative'
03:47:46 <boojinks> so the compiler reads that as something :: Int -> (Int -> Int)
03:48:18 <boojinks> which actually means something is a function that takes an Int and returns another function that takes an Int and returns an Int.
03:49:02 <boojinks> which is a somewhat foreign idea if you're used to Python so for the moment you could just think about it as a function that takes two Ints and returns an Int.
03:50:34 <boojinks> for example, addMyInts :: Int -> Int -> Int
03:56:47 <Dryvnt> Is this the place to request code reviews (Not now, but some uncertain time in the future several days away)?
03:57:01 <systadmin> boojinks: so I have a function that has a type of X, then I want the compiler to return it as Y, then I want the compiler to return Y as Z?
03:57:27 <systadmin> Dryvnt: can I see your code? :)
03:58:07 <boojinks> systadmin: assuming you meant it takes an X and a Y and gives you back a Z then yes
03:58:13 <boojinks> func :: X -> Y -> Z
03:58:22 <ph88> guys one advice, put OPTION Wall in your code .. it allowed me to catch quite a few more bugs
04:00:52 <Dryvnt> systadmin: Not yet. It's barely 40 lines. Just planning for the future.
04:01:02 <systadmin> Dryvnt: ok
04:03:41 <ph88> i was giving some extra constraints on an instance but ghc somehow figured out they are not needed, why does ghc say this??  https://paste.fedoraproject.org/538085/48560495/
04:07:59 <Atlantic777> Hi! I'm learning about functional programming way of solving problems through solving some problems from codechef in haskell (a competitive programming site). Now and then there is a problem which is well suited for stream processing but with a state object.
04:09:14 <Atlantic777> For example, one such problem is: there is a very long array of integers. All elements but one have it's pair. Find the element without pair.
04:09:57 <systadmin> Codechef?
04:09:59 <Atlantic777> One way would be to collect all elements of the array, sort, group, find the group with only one element, but this is somehow ackward.
04:11:04 <Atlantic777> systadmin: I'm sorry, here is the exact link to the site and the problem I'm giving as an example: https://www.codechef.com/problems/MISSP
04:11:43 <systadmin> Brb, I gotta restart my wifi
04:14:11 <Atlantic777> So, I feel like the fold approach could be suitable here.
04:15:37 <Atlantic777> Each time when a new element of array is "consumed", I create new state object. The end state object is then my final solution. Is a state object like this an ackward solution? Am I doing something wrong here?
04:21:07 <qcrvszvz> :t foldr
04:21:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:23:23 <Atlantic777> thanks qcrvszvz, I'm familiar with foldr. I'm just asking for opinion what would be an elegant (and efficient) way for solving such problems. :)
04:28:55 <qcrvszvz> probably foldr ;)
04:29:12 <qcrvszvz> for efficiency: foldr'
04:29:38 <boojinks> I barely even understand that problem o.o
04:30:12 <Axman6> there is no foldr'
04:30:41 <boojinks> oh, I get it now. herpyderp.
04:32:17 <boojinks> Atlantic777: you certainly could implement it with a fold.
04:33:24 <Axman6> Atlantic777: what do you know about the values in the values in the input?
04:34:35 <Atlantic777> Axman6: well, I know that inputs are integers, that there is always odd number of elements in input and that exactly one element occurs only once, all other elements occur exactly twice.
04:35:25 <Axman6> hmm, looking at the problem, I'd be using a bit vector. complement the nth bit when you see it, then find the bit that's set at the end
04:36:10 <Atlantic777> Axman6: bit vectors can be indexed in constant time?
04:36:41 <Axman6> as constant as your hardware allows, sure
04:36:55 <Axman6> (constant time data structures are usually a lie)
04:37:05 <JSharp> I'm sure they mean O(1) ... which is theoretical.
04:37:57 <Atlantic777> Yup, I don't mean strictly O(1)
04:37:59 <Axman6> sure, but no hardware impements anything that would give you that for large enough n
04:38:23 <JSharp> *sigh* of course it does.
04:39:53 <JSharp> the measure is usually only good for relative performance judgements, when looking at abstract algorithms on *whatever* hardware -- which is its purpose.
04:40:25 <JSharp> you're technically correct, yes -- but that's also not the point of theoretical complexity measurements
04:40:34 <Axman6> I wasn't talking about abstract performance though, I was talking about the actual log n cost you pay for anything you use in memory
04:42:36 <piyush-kurur> does anyone know of automated randomness tests preferably with haskell interface. I would like to add tests of randomness to the prg in raaz
04:42:53 <systadmin> What do you call those `->` expressions again?
04:42:53 <systadmin> It's at the tip of my tongue
04:43:02 <Axman6> type signatures
04:46:29 <JSharp> piyush-kurur: hmm, you mean tests like those provided by `dieharder-ng`?
04:47:55 <piyush-kurur> JSharp: yes something like that
04:52:00 <JSharp> piyush-kurur: I'm not aware of a pure haskell implementation of the likes of `dieharder-ng`. Many of the projects that I've seen that have to test sources of randomness (encryption algorithms, CSPRNGs et al) implement a harness using `dieharder` or `dieharder-ng`.
04:53:21 <JSharp> It's a tricky thing and that tester and its algos have been field tested fairly well
04:53:30 <JSharp> afaik
04:53:31 <Axman6> wow, Code Chef only has GHC 7.6? o.O
04:56:23 <piyush-kurur> JSharp: dieharder looks good to me. I have been coding up a chacha20 based prg and surprise surprise it started giving the same number :-(
04:56:56 <piyush-kurur> JSharp: I found the bug (forgot to update the pointer) but one wants to make sure that such silly bugs do not re-occur
04:57:27 <JSharp> well, that tester will help you find out if it's subtly broken but, sadly, it won't help you fix it.
04:58:05 <piyush-kurur> JSharp: that is at least good. Together with unittests on the underlying chacha20 implementation should work fine
04:58:32 <JSharp> oh, good then -- it should help you find out if it's broken (well, to 0.0001% of a chance anyway)
04:58:55 <JSharp> it does take quite a while to do a full run
05:00:55 <piyush-kurur> JSharp: thanks for reminding me about dieharder. I had heard that name some where and forgotten it.
05:01:31 <piyush-kurur> will try it out
05:01:52 <JSharp> no worries
05:16:55 <johndcl> Hello. How is the expression "-25 `mod` 26" evalueated and how does it differ from "(-25) `mod` 26" ?
05:17:52 <johndcl> What does the '-' mean when it stands at the beginning?
05:18:53 <hpc> > -(25 `mod` 26)
05:18:56 <lambdabot>  -25
05:19:30 <hpc> (-) has awkward parsing rules because it can be a prefix operator negating a number, or an infix operator subtracting two numbers
05:20:52 <johndcl> ok, thank you
05:22:26 <systadmin> > ->
05:22:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘->’
05:23:16 <systadmin> How does one negate using `-`?
05:24:35 <gpampara> with parens
05:24:38 <gpampara> (-1)
05:28:46 <SrPx> Is there any library that allows me to connect my process to a p2p network and broadcast messages?
05:49:25 <shiona> any idea why Wreq get receives a completely different answer compared to a curl from the same machine?
05:50:50 <srhb> shiona: Different headers?
05:51:06 <srhb> shiona: Tried dumping the request with netcat or something similar?
05:51:25 <shiona> I tried setting user agent. I hope wreq does set Host automatically
05:51:42 <shiona> the last thing left seems Accept-Encoding. I guess it's worth a shot
05:52:13 <shiona> oh, wait. That was the wreq request that had the Host set.
05:54:59 <shiona> .. does wreq automatically follow 302's? that might be my problem
05:58:08 <srhb> shiona: You can try making culr do the same with -L
05:59:03 <shiona> I'm making a "isLoggedIn" function, that tries to load a page that for non-logged-in users will return a 302
05:59:28 <shiona> and it seems "redirectCount" in HTTP.Client is what i need
06:00:41 <srhb> shiona: there's a redirects lens in wreq too, if you just want to limit the maximum amount.
06:01:08 <shiona> ok, maybe that's a cleaner choice
06:13:52 <ph88> when i have   data Foo = F (Maybe (String))  is it possible to put  (Maybe (String))  into a function ?
06:15:22 <ertes> shiona: wreq has to set Host properly, because not doing so violates HTTP 1.1
06:15:37 <shiona> I know ^^
06:15:50 <shiona> I was just baffled on why it wasn't working
06:16:08 <shiona> turns out wreq just outsmarted me, so I had to make it dumber
06:16:21 <ertes> ph88: what do you mean?
06:16:46 <ph88> something like    bar = (Maybe (String))    data Foo = F bar   ?
06:17:05 <ertes> ph88: you can make it a type alias:  type Bar = Maybe String
06:17:08 <ertes> data Foo = F Bar
06:17:14 <ph88> oooh yes good idea !
06:17:20 <ph88> thank you ertes 
06:17:35 <ertes> ph88: of course in this particular case i wouldn't do that…  if you need documentation, give the field a name
06:17:49 <ertes> data Foo = F { fieldName :: Maybe String }
06:18:21 <ertes> also you likely want a newtype there:  newtype Foo = F { fieldName :: Maybe String }
06:18:30 <ph88> data ProcessStatement = MkProcessStatement (Maybe ((NT Label), T)) (Maybe T) T     i have types like this and the first field   (Maybe ((NT Label), T)) is shared between many data types
06:18:53 <ertes> ah
06:19:38 <ertes> ph88: style note: Maybe (NT Label, T)
06:20:06 <ph88> so maybe i can do something like   type P_Label = Maybe ((NT Label), T)    and then    data ProcessStatement = MkProcessStatement P_Label (Maybe T) T
06:21:25 <ph88> i didn't want to use records because initially i had lot's of functions with similar names as i would give to the field selector functions. But this actually changed because i'm using a typeclass now so i, you think it's better to use records ?
06:21:43 <ertes> ph88: another side note: one of the most awkward features of the sample-frame library is that it uses types named T =)
06:21:50 <ph88> i already wrote like 2000 lines of code though, so it would be a bit painful change ^^
06:22:34 <ertes> ph88: what's T?
06:22:41 <ph88> ertes, i'm not familiar with the sample-frame library, T is my type, it stands for Terminal, but i renamed it to T so that the lines length doesn't get too big
06:22:54 <ertes> ph88: there is a more powerful way to do that
06:23:18 <ertes> ph88: data ProcessStatement a = MkProcessStatement (Maybe (NT Label, a)) (Maybe a) a
06:23:29 <ertes> ph88: now you can write: deriving (Foldable, Functor, Traversable)
06:24:08 <ph88> ah yes this could be useful later one when i have alternative implementations of Terminal
06:24:39 <ertes> ph88: gives you lovely idioms like:  traverse createTerm (MkProcessStatement Nothing (Just "path1") "path2")
06:25:17 <ph88> what's that ?
06:26:12 <ertes> ph88: uses 'createTerm' on each of the 'a's and gives you a ProcessStatement populated respectively
06:27:48 <ertes> ph88: here is a different way to express this:  let actions = MkProcessStatement Nothing (Just (createTerm "path1")) (createTerm "path2")
06:27:55 <ertes> actions :: ProcessStatement (IO ())
06:28:17 <ertes> whoops
06:28:21 <ertes> actions :: ProcessStatement (IO Terminal)
06:28:33 <ertes> sequenceA :: ProcessStatement (IO Terminal) -> IO (ProcessStatement Terminal)
06:28:58 <ertes> sequenceA actions  -- gives you a (ProcessStatement Terminal) with two terminals
06:33:35 <ertes> ph88: if you happen to have lenses for Terminal, you can also exploit 'traverse' the following way:
06:33:51 <ertes> termFd :: Lens' Terminal Fd
06:34:14 <ertes> traverseOf (traverse . termFd) hClose :: ProcessStatement Terminal -> IO ()  -- close all file handles
06:34:14 <ph88> ertes, i understand what it does now, but why would i need this for my program ?
06:35:54 <ertes> ph88: well, i imagine that you create ProcessStatements similar to this currently:  do t1 <- createTerm cfg1; t2 <- createTerm cfg2; pure (MkProcessStatement Nothing (Just t1) t2)
06:36:33 <ertes> ph88: if ProcessStatement is Traversable, you can do this instead:  traverse createTerm (MkProcessStatement Nothing (Just cfg1) cfg2)
06:38:23 <ph88> ertes, here is an example of what i do, this one mixes non-terminals with terminals https://paste.fedoraproject.org/538120/85614238/ but there are also rules that have only terminals, or rules that have only non-terminals
06:39:53 <ertes> ph88: ok, let me explain this with a different example:
06:40:26 <ertes> you have a list of file paths 'fps' and an action that takes a file path and returns contents of the file
06:40:29 <ertes> fps :: [FilePath]
06:40:36 <ertes> readFile :: FilePath -> IO Text
06:41:03 <ertes> 'traverse' takes those two and returns a structurally equivalent list of file contents
06:41:11 <ertes> traverse readFile fps :: [Text]
06:41:20 <ertes> now generalise "list" to "F"
06:41:58 <ertes> ProcessStatement is your F
06:44:18 <ph88> ertes, i could that .. just saying i don't know how this technique would fit in with what i'm currently doing
06:45:03 <ph88> i got that *
06:45:40 <ph88> anyway i'll save it as note, maybe it will be useful later on
06:45:46 <ertes> ph88: lbl = sequenceA (BS_Index (n get) (o $ …))
06:47:14 <ph88> you want to put everything on one line ?
06:47:44 <ertes> ph88: no, not necessarily, but you can keep the actions to generate a certain field *within* that field…  it makes the code clearer (IMO)
06:47:52 <ertes> and shorter, too, because you can avoid stuff like 'rest'
06:48:37 <ertes> ah, wait
06:48:53 <ertes> it wouldn't work as easily in your case =/
06:49:28 <ph88> aaah ok, so where i normally do   BS_Index a b c   i can now do    sequenceA $ BS_Index (m a) (m b) (m c)   ??
06:49:49 <ertes> ph88: that's the idea, but it wouldn't work
06:49:53 <ph88> o_O
06:50:51 <ertes> ph88: for Traversable to work you need to abstract over a certain type, and i see no obvious good choice =/
06:50:54 <ph88> before when i want to put everything on one line and save some verbosity of the do-notation i would just use  applicative style   BS_Index <$> (m a) <*> (m b) <*> (m c)
06:51:27 <ertes> ph88: you don't need to put everything on one line…  i usually line up the (<$>) and (<*>) on separate lines
06:51:33 <ph88> ertes, what's the problem with the current types that they are not an obvious good choice ?
06:52:03 <ertes> BS_Index\n<$> action1\n<*>action2
06:52:47 <ertes> data BlockSpecification a = BS_Name a | BS_Index a a  -- not a good choice, because the types differ
06:53:20 <ertes> data BlockSpecification = BS_Name (NT Name) | BS_Index (NT Label) (Maybe (a, (NT IndexSpecification), a))  -- probably not a good choice either, because of the way you construct these
06:53:28 <ertes> + a
06:54:36 <ph88> alright thanks, at least i learned about sequenceA :)
06:54:55 <ph88> so it replaced a bunch of <*> right ?
06:59:04 <ertes> ph88: it's basically a replacement for applicative style that is structure-aware
06:59:58 <ertes> sequenceA (C action1 action2 (Just action3) (action4, action5))  -- this is awkward at best to code with applicative style
07:00:31 <ertes> C <$> action1 <*> action2 <*> (Just <$> action3) <*> (liftA2 (,) action4 action5)  -- ugly
07:00:49 <ph88> ah ok, that's how i would write it, ugly :P
07:01:23 <ertes> it gets worse when you have named fields, while with traverse/sequenceA you can just write:  sequenceA (C { field1 = action1, field2 = action2 })
07:02:09 <ertes> compare:  (\x y -> C { field1 = x, field2 = y }) <$> action1 <*> action2  -- not only is this a lot harder to read, but the actions are syntactically disconnected from the fields they correspond to
07:02:24 <ph88> yes i noticed this already with records :/
07:02:34 <ph88> ok good tip, i'll see where i can apply it in parts of my code
07:02:51 <reactormonk> Can I have a local typeclass instance, by not exporting it?
07:02:57 <ertes> (-XApplicativeDo makes this particular case a lot better, but still needs you to come up with temporary names, so sequenceA is still nicer)
07:03:06 <dgpratt> I just stumbled across https://github.com/sdiehl/protolude which I thought looked pretty nice; anyone here have feelings about it, positive or negative?
07:03:21 <ertes> reactormonk: you can't not export instances
07:03:37 <ph88> ertes, what's the difference here between traverse and sequenceA then? i see the type signatures .. but when would you use which one ?
07:03:38 <ertes> reactormonk: type classes follow an open world principle
07:03:56 <ph88> looking at it's type signature sequenceA doens't even do anything
07:04:03 <ph88> oh wait it does
07:04:06 <ph88> swap t and f
07:04:14 <ertes> ph88: very often you have this:  sequenceA (C (f x1) (f x2) (Just (f x3)) (f x4, f x5))
07:04:38 <ertes> ph88: you can write:  traverse f (C x1 x2 (Just x3) (x4, x5))
07:04:40 <ph88> ah ok and then when you want to do the same but with map it becomes traverse ?
07:04:45 <ph88> yes ok
07:04:49 <ph88> thanks
07:05:12 <reactormonk> ertes, what are the implications?
07:05:12 <ertes> ph88: if you have a Functor: traverse f = sequenceA . fmap f
07:05:21 <ertes> reactormonk: that you can't not export instances =)
07:05:28 <reactormonk> ertes, oke
07:05:42 <ertes> reactormonk: also you can't not import them, except by not importing the module (not even transitively)
07:06:04 <ertes> reactormonk: you should assume that as soon as you define an instance, that instance is world-wide
07:06:42 <ertes> reactormonk: (that's why orphan instances should be avoided)
07:45:56 <reactormonk> There is no type to represent a URI?
07:46:31 <hpc> there are in a few web frameworks, but it's largely easier to just treat them as strings
07:59:56 <pavonia> reactormonk: The network package has one
07:59:58 <codedmart> Is it possible to have multiple executables in your cabal file but have compiling them be optional?
08:01:20 <reactormonk> pavonia, https://hackage.haskell.org/package/network-uri presumably?
08:01:31 <sm> codedmart: yes, you can set buildable: false based on some condition
08:02:14 <pavonia> reactormonk: Ah, it was split off, so yes
08:02:24 <cocreature> you can also just tell cabal to only build a specific target. it depends on what you are trying to achieve by making them optional
08:17:46 <codedmart> sm How do I pass that flag when using `stack build`?
08:29:18 <sm> codedmart: see stack build --help
08:41:53 <codedmart> Is there a way to check if your cabal file has unused deps?
08:48:58 <reactormonk> "Failed to load interface for `Network.URI`, It is a member of the hidden package" - huh?
08:49:07 <reactormonk> What does "hidden package" mean?
08:49:18 <hpc> which hidden package?
08:49:27 <reactormonk> network-uri-2.6.1.0
08:49:37 <reactormonk> ah, it's in the cabal faq, oops
08:49:37 <kadoban> reactormonk: You haven't declared the dependency in your .cabal file (in the correct place)
08:50:15 <reactormonk> ah, terminology. kk.
08:50:31 <reactormonk> aka ghc knows about it, but you haven't told it to use the package.
08:51:04 <monochrom> cabal tells GHC to hide away all packages not listed. "hide" means pretend not to see.
08:51:56 <kadoban> It's pretty far from the best error wording ever, but the layers of indirection involved seem to make it hard to improve it.
08:52:09 <suppi> how can i show a NominalDiffTime in a HH:mm format?
08:52:52 <reactormonk> kadoban, still better than T_PAAMAYIM_NEKUDOTAYIM - although that's beating midgets :-)
08:53:02 <kadoban> Hehe, yes
08:53:28 <suppi> why does that type even exist. I don't see how i can use it for anything useful. why not just have DiffTime?
08:53:33 <reactormonk> What's the stack command to refresh dependencies?
08:54:21 <hpc> suppi: NominalDiffTime measures stopwatch seconds
08:54:22 <kadoban> reactormonk: stack build --only-dependencies or something you mean? Not needed basically ever though. Usually you just build again normally, or whatever your actual goal is.
08:54:33 <reactormonk> oke
08:54:34 <hpc> suppi: contrast with different types that measure clock time
08:55:17 <suppi> hpc: hpc any idea how i can show that in HH:mm format?
08:55:34 <suppi> I basically have two UTCTime values and i want to show their diff in HH:mm format
08:56:13 <hpc> you'll have to do math on it iirc
08:56:27 <hpc> it has numeric type class instances that you can work with, look just below it in the haddock for a list
08:57:10 <suppi> hpc: thanks
08:57:23 <hpc> also i had it backwards
08:57:33 <hpc> DiffTime is stopwatch seconds, NominalDiffTime is UTC seconds
08:59:33 <hpc> improving those names would involve deciding what they should be, and then doing the whole deprecation thing
08:59:38 <suppi> hpc: if you know how to convert it to Integer that'd be great :)
08:59:55 <hpc> :k NominalDiffTime
08:59:57 <lambdabot> error:
08:59:57 <lambdabot>     Not in scope: type constructor or class ‘NominalDiffTime’
08:59:57 <suppi> i don't care about precision much
08:59:59 <hpc> :(
09:00:14 <suppi> http://hackage.haskell.org/package/time-1.7.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime
09:00:24 <hpc> floor (0 :: NominalDiffTime) :: Integer
09:00:28 <hpc> 0
09:00:38 <hpc> #hashtag-num-instances
09:01:24 <suppi> hpc: bless you
09:02:22 <reactormonk> Is there something like ShowS -> ByteString ?
09:03:04 <hpc> (String -> String) -> ByteString?
09:03:13 <reactormonk> Yeah
09:03:23 <hpc> :t BSC.pack (fix show)
09:03:25 <lambdabot> BSC.ByteString
09:03:33 <hpc> :t \show -> BSC.pack (fix show)
09:03:35 <lambdabot> (String -> String) -> BSC.ByteString
09:03:37 <hpc> voila!
09:03:37 <glguy> You can apply the function to "", and then pack that into a ByteString either with the .Char8 module, or with utf8-string's encode function
09:03:58 <monochrom> :)
09:04:43 <hpc> conveniently, that applied to show isn't even bottom
09:04:55 <hpc> because lazy bytestrings are chunked
09:05:03 <miladz89> quick question? what is the best testing setup to use with haskell projects?
09:05:31 <glguy> hpc: Unless the ShowS was 'id'!
09:05:40 <hpc> glguy: applied to show ;)
09:06:25 <glguy> Oh, I didn't realize you were talking about a new ShowS
09:07:05 <hpc> it's parameterized by ShowS, so it can take whatever you give it
09:07:09 <hpc> and if you give it show it's defined
09:07:19 <hpc> (it is indeed bottom with id though)
09:07:38 <hpc> and i just named the parameter show because i don't know how to type new lines in irssi
09:07:43 <hpc> i press up and then change what i need
09:08:04 <glguy> Yeah, I see what you changed
09:12:57 <reactormonk> :t fix
09:12:59 <lambdabot> (a -> a) -> a
09:15:28 <hpc> > fix show
09:15:31 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:20:45 <reactormonk> So I have `Maybe URI`, `URI -> ShowS` and the above function, how should I combine them?
09:21:07 <reactormonk> fmap + . ?
09:24:00 <glguy> reactormonk: Just start by using case
09:25:28 <reactormonk> glguy, I don't really care about the Nothing case.
09:26:07 <hpc> you... kind of have to
09:26:30 <hpc> if the Nothing case truly doesn't matter, you have URI instead of Maybe URI
09:27:11 <hpc> unless you mean you want mysteryShow Nothing = "" or something
09:29:17 <reactormonk> Ah no, a Maybe ByteString is the desired result.
09:30:10 <hpc> at this point i recommend you write out the complete type signature of what you want to define
09:30:34 <hpc> and at that point the code usually writes itself
09:36:33 <monochrom> No no, do it the other way round. Write the code first, then the types will write themselves (aka type inference) XD
09:36:44 <dsfox> Hello all - I'm having difficulty understanding how GHC.Generics is a replacement for Data.Generics.  How do I get information about the type apart from a particular value?  E.g. the list of a type's constructors, or the list of a constructor's field types?
09:37:08 <monochrom> No, I don't think they're replacement of each other.
09:37:19 <glguy> dsfox: Why do you think you need a value of the type to get that information?
09:37:36 <reactormonk> :t ((uriToString id) .> (\shows -> BS.pack (fix shows)))
09:37:38 <lambdabot> error:
09:37:38 <lambdabot>     Variable not in scope:
09:37:38 <lambdabot>       uriToString :: (a0 -> a0) -> BSC.ByteString -> r
09:37:48 <dsfox> glguy: I just haven't found a way using GHC.Generics
09:38:06 <glguy> http://lpaste.net/167793 (one version with TypeApplications and one without)
09:38:42 <dsfox> monochrom: do you mean one should keep using Data.Data?
09:38:43 <reactormonk> ... how can I ask lambdabot to import something?
09:39:19 <monochrom> No.
09:39:24 <glguy> dsfox: GHC.Generics and Data.Data are good at different things
09:40:09 <kadoban> reactormonk: @let import Whatever
09:40:30 <reactormonk> @let import Network.URI
09:40:32 <lambdabot>  Defined.
09:40:37 <reactormonk> @let import Flow
09:40:38 <lambdabot>  .L.hs:135:1: error:
09:40:38 <lambdabot>      Failed to load interface for ‘Flow’
09:40:38 <lambdabot>      Use -v to see a list of the files searched for.
09:40:44 <kadoban> reactormonk: No idea how often it'll actually work though, it's not going to let you arbitrarily bring in packages it doesn't have whitelisted or however that works.
09:41:54 <reactormonk> @let import import Control.Category ((>>>))
09:41:54 <lambdabot>  Parse failed: Parse error: import
09:42:01 <reactormonk> @let import Control.Category ((>>>))
09:42:02 <lambdabot>  Defined.
09:42:11 <reactormonk> :t ((uriToString id) >>> (\shows -> BS.pack (fix shows)))
09:42:12 <lambdabot> error:
09:42:12 <lambdabot>     • Couldn't match type ‘Char’ with ‘Word8’
09:42:12 <lambdabot>       Expected type: ShowS -> BSC.ByteString
09:42:20 <reactormonk> ^ yeah.
09:42:35 <dsfox> glguy: that makes me sad
09:42:53 <glguy> weird, I like that they do different things. It means I can do more things
09:44:30 <reactormonk> How do I make that typecheck? I think I'm using the combinators incorrectly.
09:44:56 <dsfox> jk, but I keep hearing that Data.Data is much slower than GHC.Generics
09:45:41 <glguy> GHC.Generics is only potentially faster if you know what you're doing with it. If you don't you can make code that's just as slow
09:45:59 <glguy> You have to structure things so that the generic representation is able to optimize away
09:47:18 <monochrom> It is strange that you are comparing their speeds, implying that you still don't believe that they have different purposes to begin with.
09:47:55 <glguy> There's some overlap in what they can do, so the comparison isn't totally out of scope
09:48:55 <dsfox> glguy: I'm just a person trying to figure out a reasonable approach based on info I've been able to pick up from the internets.  I have no firm beliefs on any of these issues, just a desire to get a job done.
09:49:56 <glguy> Did you look at the paste I linked to above?
09:50:57 <dsfox> glguy: oh, thank you, I missed that the first time
09:56:11 <codedmart> I am trying to create packages with stack, and I don't want to build a package unless I pass the build flag. I get this error though when just running `stack build`: https://gist.github.com/codedmart/fb06caf06d2b62534e98060661868094
09:59:58 <codedmart> I got it
10:12:52 <dsfox> glguy: for ghc8 the first example needs a DataKind annotation: data SelProxy (s :: Meta) (f :: * -> *) a = SelProxy
10:13:14 <glguy> Yeah.
10:13:25 <glguy> The second version doesn't make a new proxy type , though
10:13:35 <dsfox> nice
10:17:11 <glguy> Also DataKinds isn't dangerous to enable
10:17:11 <reactormonk> Anything out there to construct URIs?
10:17:30 <reactormonk> Network.URI is mostly for parsing them.
10:19:22 <monochrom> If you fill out the URI record and then use show, do you get an url?
10:19:57 <monochrom> actually there is also uriToString
10:20:04 <tsahyt> Hello. I'm in the process of reading conal's paper on push-pull FRP and I checked haskell to see what libraries implementing it. I noticed that there doesn't seem to be any library implementing it that is also still maintained. Why is that?
10:20:47 <monochrom> Probably because conal is busy.
10:21:34 <tsahyt> but what about the other parts of the FRP zoo? there are a few AFRP libraries and monadic FRP things like reactive-banana, which all seem to be maintained.
10:21:53 <tsahyt> I guess my question is really whether push-pull just fell out of favor, and if yes, whether there's some technical reason for it
10:22:59 <monochrom> The other parts of the zoo are from other people.
10:24:11 <tsahyt> so it's basically just that everybody has their own take on it then?
10:28:52 <reactormonk> monochrom, ohh, right. oops.
10:29:02 <reactormonk> didn't see the contructor.
10:30:09 <monochrom> Yes tsahyt.
10:30:34 <monochrom> Now also look at pipes vs conduits vs machines vs iteratee vs enumeratee vs ...
10:36:54 <reactormonk> Is there a reverse dependency index on hackage?
10:37:22 <monochrom> Not on hackage. Someone else has one. But I forgot the url.
10:37:49 <glguy> Try typing "reverse dependency hackage" into Google
10:38:39 <reactormonk> ehh, sorry
10:38:49 <monochrom> No worries.
10:38:58 <reactormonk> https://github.com/haskell/hackage-server/issues/40 :-(
10:39:17 <monochrom> yikes
10:39:55 <reactormonk> There's http://packdeps.haskellers.com/reverse
10:40:12 <monochrom> We need a crowdfunding campaign to buy more computers for hackage to do reverse dependency.
10:40:33 <reactormonk> So I started using Network.URI, but then I realized it's String-based - apparently there's http-types which gives you a few things, but no URI type from what I see (?)
10:40:48 <monochrom> And we need to repeat a similar campaign every 5 years for replacement parts.
10:41:18 <monochrom> Let me take a look at http-types doc
10:42:14 <dunx> can the computer it's running on take any more memory?
10:43:26 <monochrom> Maybe. But adding memory requires crowdfunding too.
10:44:23 <monochrom> http-types seems to be moar bytestrings for urls
10:44:42 <dunx> could it not be more distributed?
10:45:02 <dunx> like, hsve people volunteer computing for it
10:45:08 <monochrom> More distributed requires buying more computers which is back to what I said first.
10:45:23 <monochrom> Ah OK yes, so someone needs to organize it. Who?
10:45:45 <monochrom> And I have a Aesop tale to tell for that, too :)
10:45:57 <dunx> well, depends if you control the computers. so for instance i could offer a vm (hypothetically)
10:48:06 <monochrom> OK, you know whom to email to say you want donate your computing time, right?
10:56:50 <reactormonk> monochrom, so you didn't find anything either? :-(
11:01:21 <monochrom> I think urls are fairly implicit in http-types and not easy to single out.
11:03:19 <reactormonk> Yeah, having something explicit to build URLs would help out.
11:04:01 <reactormonk> Any you would know of?
11:06:01 <monochrom> No.
11:20:59 <nitrix> If there is only one reader and one writer to an IORef, but each have their independent threads, can I use readIORef and writeIORef respectively?
11:21:27 <monochrom> I think yes.
11:21:42 <nitrix> Or am I supposed to use atomicModifyIORef? This one seems like an issue with my current design because effects needs to be carried out only once between writes.
11:24:01 <hpc> in ghc, just about everything about acting on an IORef happens to be implemented with the same safeties as atomicModifyIORef
11:24:41 <hpc> which really just goes as far as to say you're never going to observe a "corrupted" value
11:25:22 <glguy> I think the concern is more about reordering of effects than corruption, isn't it?
11:25:40 <nitrix> hpc: That was my concern. Thanks.
11:25:44 <hpc> i would look more at something like TVar or MVar, which communicates more of a "this is being used concurrently by several things and here is how i keep it consistent"
11:26:09 <nitrix> Yeah. This would be an issue, excepted single writer and reader for this use case.
11:26:41 <glguy> so the issue would be that effects in the one thread could be reordered around the write to the ioref
11:26:47 <glguy> and observed in a different order in the other thread
11:26:57 <ij> How do I build an unpublished package's haddock docs?
11:27:03 <nitrix> I just want an effective communication between two threads that wont block on reads, so the reads can keep happening on the previous value until new writes happen.
11:27:05 <ij> haddock **/*.hs?
11:27:12 <glguy> ij : cabal haddock
11:28:34 <ij> or `stack haddock'?
11:30:11 <monochrom> @quote monochrom IORef.Int
11:30:11 <lambdabot> monochrom says: new catchy thing to say: an IORef Int contains an Int in the same sense as an IO Int contains an Int
11:30:58 <ij> Hmm, so are haddocks dependent on other packages?
11:31:01 <nitrix> hpc: Curiously, if an atomicallyModifyIORef fails, does the whole computation restarts or only the writing part?
11:31:07 <ij> And where will they be placed afterwards?
11:32:06 <hpc> nitrix: it never fails
11:32:09 <nitrix> hpc: (Failing as in, the compare-and-swap detects something touched it)
11:32:20 <hpc> nitrix: it waits for another atomic operation to complete, and then performs itself atomically
11:32:23 <hpc> blocking other operations
11:32:28 <nitrix> Ah interesting.
11:32:42 <hpc> what you describe is a transaction, which TVar does
11:32:55 <hpc> MVar is a more explicit form of blocking, where it can be either empty or full
11:32:58 <nitrix> So TVar is the one that does compare-and-swap and retries?
11:33:03 <hpc> empty vars block taking
11:33:06 <hpc> full vars block putting
11:33:16 <hpc> yes
11:33:23 <nitrix> Does TVar recomputes everything on every try or just the writing part?
11:33:39 <hpc> in fact, if you have a single consumer and producer, MVar might be what you want anyway
11:33:52 <hpc> the producer blocks if it gets ahead, until the consumer takes another item
11:34:01 <hpc> and the two threads proceed concurrently, but in relative lockstep
11:34:18 <hpc> or maybe you want them to not block each other, and you use a Chan perhaps
11:34:52 <hpc> if you use an IORef with atomic modifications, you're likely doing it in a way that the producer is able to overwrite the consumer's next step
11:35:06 <hpc> or the consumer doesn't need to wait for the producer and can perform multiple loops on the same input
11:35:22 <nitrix> hpc: That's indeed the goal.
11:35:49 <nitrix> hpc: I want my game engine to keep processing events and generate the next game state which the renderer will be able to pick up and render on the next frame.
11:37:11 <nitrix> I was concerned with potentially corrupted game state with IORef; the renderer blocking on reads for MVar; and the whole heavy logic being recomputed with a TVar.
11:37:16 <nitrix> But you dispelled some of my concerns :)
11:37:20 <hpc> :)
11:43:47 <ij> What does the LANGUAGE CPP do?
11:44:08 <hpc> it turns on the same CPP that preprocesses C files
11:44:26 <ij> But it is otherwise haskell?
11:44:42 <ij> Okay, cool, but very weird.
11:44:59 <hpc> quite
11:45:09 <hpc> it's useful for writing compiler-specific stuff
11:45:15 <hpc> and maybe occasionally FFI?
11:46:03 <EvanR> in the future, the latest version of C will specify support for template haskell
11:46:31 <EvanR> this might not be a joke
11:48:13 <monochrom> CPP allows you to use #define and #if
11:48:53 <ij> I've got two irc-clients: 1.0.0.0 from «packages» and 0.4.x.x from stack itself. I tried to put "irc-client >= 1.0.0.0" in .cabal, but "stack ghci" still says it's a hidden package.
11:48:59 <ij> And I thus can't import it.
11:50:57 <Lokathor> fresh stack stakes waaaaaay too long to get going
11:51:28 <benneh> I've heard that using 'Writer String' is inefficient, but I don't understand why. Could anyone point me towards a good explanation of why this is a bad idea?
11:51:52 <EvanR> the monoid for String does ++
11:52:00 <reactormonk> benneh, it's String that sucks - a) linked list b) UTF-32
11:52:20 <EvanR> repeatedly ++ing to the end of an accumulator is really bad in haskell
11:52:21 <glguy> Writer String is inefficient when ++ is inefficient, which is when you have left-nested binds (>>= , >>)
11:53:03 <Lokathor> It seems like usually Writer is kinda a bad move >_>
11:53:03 <MarcelineVQ> Lokathor: at least you're first world internet, there's a fair number of people that can't even get the package list downloaded because it's a git pull and those are all-or-nothing
11:53:05 <geekosaur> ij, extra-deps to override the resolver https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps ?
11:53:27 <benneh> But if I have something like 'do {a <- foo; b <- bar a; c <- baz b; quux d}', doesn't that get desugared in a right-associative manner?
11:53:36 <boccato> Is there a standalone warp server?
11:53:44 <ij> geekosaur, Do have them.
11:53:51 <EvanR> Lokathor: well, you can use a monoid type which has efficient appending
11:54:15 <glguy> WriterT has another inefficency issue when you use it to transform a Monad having a strict >>=
11:55:03 <Lokathor> i'll just keep a running state whenever i'd use writer i think
11:55:14 <glguy> state and writer solve quite different problems
11:55:30 <Lokathor> how so?
11:55:39 <EvanR> @undo do {tell "a"; tell "b"; tell "c"; return "d"} 
11:55:40 <lambdabot> tell "a" >> tell "b" >> tell "c" >> return "d"
11:56:02 <EvanR> infixl >> 1
11:56:07 <EvanR> er
11:56:09 <EvanR> infixl 1 >>
11:56:26 <glguy> writer is for streaming an output, state is for carrying along/transforming a value
11:56:38 <monochrom> I have doubts about whether it is related to left-nesting binds.
11:57:02 <Lokathor> glguy, but as i understand it, the output thunk gets built up over time and the writer doesn't do it all until the end?
11:57:04 <EvanR> er, >> nestes to the left?
11:57:06 <Lokathor> or is that just some of the time?
11:57:15 <monochrom> OK, I think I see.
11:57:23 <benneh> 'do {a <- foo; b <- bar a; c <- baz b; quux c}' gets desugared to 'foo >>= (\ a -> bar a >>= (\ b -> baz b >>= (\ c -> quux c)))', so everything is right-associative, and the resuulting string concatenation should also be right-associative, right?
11:57:44 <monochrom> But you usually use the do-notation which ends up right-nested.
11:58:00 <glguy> Lokathor: The output thunk only gets built up over time if you're forcing the writer to be evaluated by looking at the result rather than the monoid value
11:59:07 <Lokathor> glguy, i think you lost me
11:59:25 <glguy> If the Writer String () value's evaluation is being driven by evaluating the resulting String, then there aren't necessarily any thunks that accumulate
11:59:26 <Lokathor> isn't the monoid value the result?
11:59:50 <Lokathor> hmm
11:59:52 <barrucadu> ij: Could you share the stack.yaml?
12:00:08 <glguy> Lokathor: Here's a program that uses WriterT to stream output https://github.com/glguy/advent2016/blob/master/asmprog-final/Main.hs#L59
12:00:13 <glguy> No thunks are accumulated
12:00:22 <ij> barrucadu, http://sprunge.us/fNWi Here it is.
12:01:56 <barrucadu> ij: I don't think you also need the entry in extra-deps given you have the path in packages.
12:01:58 <Lokathor> glguy, golly am i lost
12:02:52 <glguy> > take 10 $ execWriter $ forever $ tell [ () ]
12:02:54 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
12:03:03 <geekosaur> one or the other but not both, likely. I would expect the extra-deps one to be needed as people who put newer packages in packages instead of extra-deps find the newer one ignored in favor of the resolver (per past debuggings here)
12:03:19 <glguy> Lokathor: See how that 'forever $ tell [ () ]' didn't need to run forever?
12:03:26 <Lokathor> ah ha
12:03:41 <glguy> evaluation of that infinite loopy thing was driven only as far as needed to produce 10 outputs
12:03:53 <glguy> You can't do that with State
12:03:58 <Lokathor> so it's lazyness at work
12:04:27 <glguy> No thunks were accumulated because evaluation only proceeded when output was needed
12:04:37 <ij> barrucadu, https://asciinema.org/a/bc68kw1hwfk0zfy9drlkzz4kl
12:05:16 <Lokathor> so the one time i wanted to maybe use writer, it was for an FOV thing
12:05:30 <Lokathor> where you're building an output Set (Int, Int) of places that can be seen
12:05:54 <glguy> Now if we'd do:     runWriter $ forever $ tell [ () ]
12:05:55 <Lokathor> but, as i recall, it ran a lot slower than unrolling it all by hand, so i went with the fast version
12:06:13 <glguy> We wouldn't be evaluating that [()] to drive the computation
12:06:15 <Lokathor> :t runWriter
12:06:17 <lambdabot> Writer w a -> (a, w)
12:06:24 <Lokathor> :t execWriter
12:06:26 <lambdabot> Writer w a -> w
12:06:35 <glguy> If we tried to inspect the 'a' there things wouldn't terminate
12:06:48 <glguy> and we'd accumulate thunks of [()] trying
12:07:17 <glguy> even if it wasn't 'forever', but just replicateM 1000
12:07:27 <nitrix> How do I turn a `Storable a => a` into `Storable a => Ptr a` for a foreign C library?
12:07:47 <glguy> we'd accumulate thunks by allowing evaluation to be driven by evaluation of the 'a'
12:08:08 <nitrix> isWhatImAfter :: Storable a => a -> IO (Ptr a)
12:08:39 <Lokathor> hmm
12:08:56 <Lokathor> I don't recall that most Writer documentation has explained this detail a lot
12:09:12 <monochrom> But see my http://lpaste.net/41790/ for how to write infinite loops correctly in State
12:09:21 <nitrix> So I absolutelly need malloc + poke?
12:10:00 <Lokathor> modify (() :)
12:10:02 <Lokathor> such a happy line
12:10:19 <barrucadu> ij: Those ambiguous type variable errors in Network.IRC.Client.Lens are interesting. Have you modified the code at all? That module shouldn't be getting built with OverloadedStrings.
12:10:32 <glguy> Yeah, a lazy State with left-nested recursion can produce values
12:10:33 <barrucadu> ij: I suspect it's failing to find the module because it's failing to compile the package
12:13:08 <benneh> If I've understood correctly, 'Writer String' is fine as long as your binds are right-associative, and ordinary do notation desugars into right-associative binds. It's only if you do something like 'm >>= f >>= g >>= h' where they left-associate, and inefficiecies can arise. Is that correct?
12:13:34 <glguy> and if evaluation of the Writer e a value is driven by evaluation of the e, not the a
12:15:06 <benneh> Yes, assuming that the 'written' value is the thing that you actually care about.
12:15:15 <benneh> Lots of the time, a = () anyway.
12:17:49 <glguy> Or in the case where you can produce the output without accumulating any values along the way
12:17:51 <glguy> > fst $ runWriter $ forever (tell [()]) >> return "X"
12:17:53 <lambdabot>  "X"
12:19:30 <glguy> > let (a,xs) = runWriter $ forever (tell [()]) >> return "X" in (a, take 10 xs)
12:19:32 <lambdabot>  ("X",[(),(),(),(),(),(),(),(),(),()])
12:20:45 <ij> barrucadu, No, haven't done anything. It builds quickly, when I changed it to lts-7.17 to not have everything get rebuilt.
12:20:46 <glguy> and then how you can pull on the output is going to depend on the behavior of mappend on your particular Monoid
12:20:55 <glguy> some of them are strict in the second argument, some in the first
12:21:07 <glguy> so yeah, it depends :)
12:22:04 <benneh> Ok, thanks, that clears some things up for me :)
12:22:23 <buglebudabey> could someone help me figure out why Hakyll my page won't render LaTeX? here is the page in question: https://aneksteind.github.io/posts/2015-08-12-spqr.html and here is my configurations... http://lpaste.net/8724984057596739584 .... and my default.html....http://lpaste.net/3152207555166470144
12:22:29 <barrucadu> ij: Then I'm at a bit of a loss, I'm not sure why that module would be built with OverloadedStrings. You could just remove the HLint annotation and see if it works then.
12:22:49 <MarcelineVQ> ij: things in your pacakge section need an extra-dep: true flag if they're just a dependancy and not physically part of your project, or stack mixes stuff up wrt flags and such.
12:23:25 <MarcelineVQ> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
12:24:16 <ij> MarcelineVQ, BAM, solved!
12:24:18 <MarcelineVQ> also things listed in your packages section shouldn't also be listed in the extra-deps section
12:24:51 <MarcelineVQ> allthough I'm not sure if that's actually a problem, just good practice
12:26:50 <byorgey> buglebudabey: and what was the source from which that page was generated?
12:27:31 <buglebudabey> byorgey by guessing what you mean i'm going to say that it was generated using github pages using the html my build generated
12:27:46 <myname_> Hi all!
12:27:53 <buglebudabey> byorgey firefox returned this error in the log: Blocked loading mixed active content “http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML”
12:28:06 <byorgey> buglebudabey: sorry, I mean can you paste or link to the file with the page content (e.g. is it a .markdown file?)
12:28:31 <buglebudabey> byorgey it is a markdown file, sure i'll paste the content
12:28:34 <byorgey> buglebudabey: oh, interesting.  I have never seen that error before
12:28:53 <kadoban> buglebudabey: That sounds like your page is on HTTPS and you're trying to load a script from HTTP, which is generally disallowed
12:28:56 <byorgey> I get that same error
12:29:30 <buglebudabey> kadoban do you happen to know the way around that? i'd rather keep my site https obviously
12:29:38 <byorgey> aha, so maybe change the URL for MathJax to use https
12:29:47 <buglebudabey> byorgey it's just this: http://lpaste.net/351746
12:29:59 <kadoban> How are you including that link? Is it automatic? Yeah it just needs to be HTTPS most likely.
12:30:47 <byorgey> buglebudabey: did you see kadoban's comment above?  try changing the MathJax link to https://
12:30:58 <buglebudabey> byorgey about to try that
12:38:35 <buglebudabey> github isn't building the page for some reason so let me fix that then i'll report back
12:40:34 <buglebudabey> byorgey it works! https://aneksteind.github.io/posts/2015-08-12-spqr.html, the https change worked
12:40:37 <buglebudabey> thanks kadoban 
12:41:03 <kadoban> Yay, 'welcome
12:43:39 <bandershas> Hey all, a newcomer here! A question: do you have any 'good' resources on typeclasses, polymorphism and instances in haskell? I finally understood monads and can use them in practice. Thanks :)
12:44:07 <buglebudabey> bandershas https://wiki.haskell.org/Typeclassopedia
12:44:40 <monochrom> SPQR?!
12:45:22 <bandershas> That's a rich resource, thanks :)
12:45:42 <buglebudabey> monochrom it comes with the default hakyll layout, i've yet to change it. wanna fill me in?
12:46:24 <monochrom> No, just scared that the fearsome name of Rome reappears!
12:49:38 <buglebudabey> monochrom maybe i'll keep it :P
13:03:15 <reactormonk> Contextually, should URIs be built on ByteString or Text?
13:10:21 <kadoban> Neither one is restrictive enough, and both can encode the entire range of possible URI values I think, so ... it might not matter?
13:10:47 <kadoban> I believe URIs are built on ASCII, which is representable as ByteString or Text.
13:11:17 <kadoban> (not even full ASCII, not every ASCII string is a valid URI, by far)
13:11:37 <EvanR_> dont we have unicode in domain names
13:11:42 <opqdonut> the spec just says a URI can contains these letters, coding isn't specified
13:11:56 <opqdonut> EvanR_: well it's encoded into alphanumerics (punycode)
13:12:01 <EvanR_> ok
13:12:02 <kadoban> EvanR_: Aren't they encoded using ASCII though at an underlying level? I thought?
13:12:12 <EvanR_> sounds familiar
13:12:25 <reactormonk> HTTP.Client uses ByteString, so I guess I'll use that.
13:12:32 <EvanR_> oh right, and in the path part you have some standard that says percent encoding into utf8
13:12:51 <EvanR_> percent encoding of the utf8 encoding
13:13:03 <kadoban> They're fairly complicated little beasts.
13:13:19 <EvanR_> its encodings all the way down
13:13:29 <EvanR_> or up, or something
13:13:38 <monochrom> @quote monochrom russian.doll
13:13:38 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
13:13:49 <kadoban> Heh
13:18:49 <Atlantic777> Is there implementation of BitVector in the standard library? I can find only 3rd party packages for bit vectors. I'm still not used to hackage, sorry.
13:22:12 <monochrom> Data.Array.Unboxed may uses a bitvector internally for Bool arrays. But I am not sure.
13:29:20 <orzo> I've been using this style lately: import qualified Data.Set as Set -- and on the next line i indent and then write another import preceded by a semicolon:   ; import Data.Set (Set)  -- so that the "Data.Set" text lines up both lines.
13:29:30 <orzo> What do you think?
13:29:53 <orzo> that way the module has only one import statement flush with the start of the line
13:30:36 <geekosaur> it's fairly common
13:30:44 <geekosaur> oh, the semicolon
13:31:19 <orzo> it's common to leave spaces in place of the absent "qualified"
13:31:28 <orzo> but to leave import at the start of the line
13:32:13 <orzo> indending suggests this import is related to the other
13:35:48 <orzo> it's too bad the syntax didn't put "qualified" at the end of the import statmenet rather than the start.  That we could extend it to have two import lists, one preceding the qualified, and one after.
13:36:43 <geekosaur> there has been occasional (generally selfstalling) discussion of enhancements to import declarations
13:46:03 <miko__> `stack build` can't find a compiler (expects 8.0.1), form the shell ghc --version indicates a 8.0.1.
13:46:26 <miko__> stracing `stack build` shows that it even stats the correct binary.
13:49:23 <hpc> stack is a reproducible build system, so it has to use its own version of ghc to keep control of the build environment
13:51:03 <miko__> I prefer to control my environment with nix :) 
13:51:36 <miko__> Oh, yes I solved it. ouch. ouch. wrong architecture.
13:51:52 <Theophane> :D
14:18:02 <ph88> hitting 3K loc ^^
14:19:58 <Tuplanolla> GHC just hogged so much memory it swapped out IRC and I disconnected.
14:20:18 <Tuplanolla> It was entirely my fault too.
14:20:47 <Tuplanolla> I still wish I didn't have to go through this every couple of months.
14:26:12 <ph88> install more memory :P
14:28:05 <Tuplanolla> If a line wrapping algorithm is given zero width to work with, should it return an infinite stream of empty lines or no lines at all?
14:28:54 <ph88> no wonder you are running out of memory lol
14:29:09 <Tuplanolla> This is tangentially related.
14:29:19 <Theophane> :')
14:29:21 <pikajude> Tuplanolla: what's the difference?
14:30:02 <Tuplanolla> It's a philosophical question, much like defining the surface area of a zero-dimensional ball, pikajude.
14:30:25 <pikajude> that's an easy one. 3 square inches
14:30:29 <ph88> i would go for the practical answer: no lines at all
14:30:51 <pikajude> i'd say an infinite stream of empty lines
14:30:53 <ph88> i consider it an edge case  where you can divide a number by all numbers just not 0
14:31:00 <pikajude> because if you combine enough empty lines you eventually get your text back
14:31:08 <pikajude> the same way that 0.9 repeating == 1
14:31:11 <Tuplanolla> I feel like the infinite stream is morally correct, but I should really return an error here.
14:31:24 <pikajude> oh, you didn't mention that
14:31:27 <pikajude> it would be a better idea to return an error
14:31:57 <hpc> an infinite stream is certainly funnier
14:33:16 <ph88> infinite memory would be funny as well
14:34:41 <pavolzetor> I am working on improving performance of my ray tracer and I would like to add ray filtering, i.e. during traversal a bunch of rays is tested against primitive, ones intersecting it are traversed furher (depth first)
14:34:47 <monochrom> Line wrapping under zero width sounds like division by zero to me.
14:35:16 <pavolzetor> the problem is the sets returned from traversal can be smaller, or objects can be closer
14:35:44 <pavolzetor> in C++ it could be done using std::partition and modifying t_hit of the ray
14:35:53 <pavolzetor> (the bunch is traced serially)
14:36:05 <Tuplanolla> Technically `repeat ""` doesn't contain a single incorrectly wrapped zero-length line, monochrom.
14:36:39 <Tuplanolla> Then again it doesn't really contain the text either. We have arrived at the excluded middle.
14:37:01 <monochrom> Yeah, but you are also under the promise of "the input has to appear in the output somewhere"
14:37:08 <pavolzetor> I have no idea how to go about it
14:37:34 <pavolzetor> for example using Maybe would traverse whole bunch each time
14:38:24 <pavolzetor> and if the order is changed, the rays would need to store an id so they can be merged (i.e., pick the closest hit)
14:38:51 <monochrom> There is also an agreement on "the output should be the shortest possible".
14:39:39 <pavolzetor> this is the description of the algorithm http://psychopath.io/breadth-first-ray-tracing/
14:42:08 <monochrom> pavolzetor: I am too lazy to read carefully, but "partition" exists in Data.List
14:42:26 <monochrom> And if you prefer to use Data.Set, there is some kind of partition too.
14:43:59 <Tuplanolla> Did this guy just write three articles on ray tracing without a single figure?
14:44:55 <monochrom> I don't know. But I know a linear algebra book that proves a hundred theorems without a single matrix. :)
14:47:13 <fmapE> Anyone know how to temporarily disable or mask the RTS timer interrupt (SIGVTALRM) to a Haskell thread?
14:47:48 <monochrom> Something about -V0
14:47:51 <fmapE> I have a read() call which goes to a OneWire sensor (supported by the w1-therm Linux kernel module
14:48:15 <fmapE> monochrome yeah I did that but I want a way to just temporarily mask it around one call to hGetSome or hGetContents
14:48:31 <monochrom> err not -V0
14:48:46 <fmapE> monochrom: +RTS -V0 worked
14:49:02 <fmapE> monochrom: but I want to use the lib I'm writing in a webserver or something
14:49:05 <monochrom> OK good
14:49:17 <fmapE> monochrom: So I don't want the RTS ticks turned off 
14:49:28 <fmapE> monochrom: just want to mask them around one IO call
14:49:59 <monochrom> Ah OK. I don't know.
14:50:00 <fmapE> monochrom: issue is the read() call takes a while because the kernel module starts querying the OneWire sensor when the read() is issued
14:50:16 <fmapE> And then the SIGVTALRM repeatedly interrupts the read forcing a do-over
14:50:27 <fmapE> monochrom: ok well thanks
14:55:26 <monochrom> Does it help if the read() call happens in a non-main thread?
14:56:08 <fmapE> monochrom: I'll try that. Does the RTS timer only interrupt the main thread?
14:56:25 <monochrom> I don't know.
15:00:36 <fmapE> monochrom: I'm building something that runs the hGetSome call inside a forkOS thread, we'll see if it works
15:01:18 <fmapE> monochrom: That seems to have done it :)
15:01:31 <monochrom> I think some people surrender and write a loop over a system call until the reason it finishes or dies is not E_INTR
15:01:42 <monochrom> OK good.
15:01:47 <fmapE> monochrom: Yeah that won't work in this case, already tried
15:01:53 <monochrom> Ah
15:02:01 <fmapE> monochrom: it starts fresh trying to query the OneWire sensor every time read() is issued
15:02:16 <fmapE> And every time that takes too long and gets interrupted by SIGVTALRM
15:02:19 <monochrom> Yikes.
15:02:59 <fmapE> If I use a non-blocking read it just always returns immediately because there's no data ready, because no data is there until read() gets issued and it starts polling the sensor
15:03:01 <fmapE> It's a mess
15:16:23 <aries_liuxueyang> Hello. When I build hugs98. It stucks at here: https://goo.gl/CIVJGq for a long time maybe above 15 minutes. No error message output. Does it failed?
15:16:53 <aries_liuxueyang> I downloaded the source code from here: https://www.haskell.org/hugs/pages/downloading.htm I use Slackware Linux.
15:17:18 <aries_liuxueyang> Does anyone knows why? Thanks in advance!
15:17:50 <Tuplanolla> Why Hugs, aries_liuxueyang?
15:19:09 <aries_liuxueyang> Tuplanolla: Because I am learning a course. It requires Hugs instead of GHCi.
15:19:22 <Tuplanolla> That's silly.
15:20:17 <geekosaur> presumably something has changed incompatibly in docbook2html
15:20:42 <geekosaur> you probably won't find much help with it; hugs is pretty long dead
15:20:51 <Cale> Hugs is no longer maintained, and it's been well over a decade since it was really reasonable to use it.
15:21:01 <aries_liuxueyang> Tuplanolla: In fact, I am not quite understand the reason. But there is a post: https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2015/discussion/forum/i4x-DelftX-FP101x-course-3T2014/threads/56200291d2aca5b29c0007c9
15:21:24 <geekosaur> sends me to a login screen
15:21:43 <Cale> aries_liuxueyang: I say try getting GHCi and using that instead.
15:21:53 <aries_liuxueyang> geekosaur: sorry. I didn't know this page requires login. :(
15:22:13 <Cale> There will be some small differences, but it shouldn't ruin the course.
15:23:00 <aries_liuxueyang> geekosaur: https://paste.kde.org/phjhwp4he Here is the reason he said.
15:23:42 <monochrom> You may have better luck finding a pre-built hugs instead of compiling your own.
15:23:53 <Cale> Yeah, that's a silly reason. He could instead have just distributed his own Prelude to use for the course.
15:24:14 <geekosaur> or just tell you to use ghc 7.8.x
15:24:27 <monochrom> Ubuntu has one, maybe Slackware has it too.
15:24:38 <Cale> Right, GHC 7.8 still is a far more reasonable thing to run than hugs
15:25:20 <monochrom> I don't completely believe in type-driven development to begin with.
15:25:40 <aries_liuxueyang> monochrom: I will have a try. Cale, geekosaur, I have installed GHCi 7.10.3 and I will use it first.
15:25:51 <monochrom> Haskell types have limitations, even with Haskell 2010.
15:25:56 <aries_liuxueyang> Thanks all of you. :P
15:26:04 <geekosaur> that one runs yo into the problem the message describes; AMP and FTP will likely confuse things
15:26:25 <monochrom> I have a cunning plan. Run virtualbox; inside that, install Ubuntu and then you can just apt-get install hugs98.
15:26:45 <Cale> Well, they'll confuse things *slightly*, but you can just take 5 minutes to understand what's going on there.
15:26:47 <Tuplanolla> It hasn't been a problem on our course. Students are pretty good at ignoring type constraints before they understand them.
15:27:21 <aries_liuxueyang> monochrom: yeah, that's a solution.
15:27:37 <Cale> Once you know that whenever you have a Traversable t constraint, it's possible to plug in [] for t, so that t a becomes [a], then everything should be fine.
15:27:55 <monochrom> The type-driven development dogma can only be realized by the Curry-Howard dogma, as far as dogmas go.
15:29:25 * geekosaur generally becomes wary as soon as "dogma" comes up
15:29:36 <geekosaur> guidelines are much better than dogmas
15:30:01 <monochrom> A more tenable reason is "type classes are hard at the beginning".
15:30:17 <monochrom> But that one is readily destroyed by arithmetic already.
15:30:30 <monochrom> Or even merely equality tests.
15:31:16 <monochrom> @quote monochrom fibonacci
15:31:16 <lambdabot> monochrom says: the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
15:32:23 <kadoban> Haha
15:32:32 <pikajude> fibonacci numbers are quite common in nature; some examples include 1, 2, and 3
15:32:41 <monochrom> haha
15:32:59 <monochrom> @remember pikajude fibonacci numbers are quite common in nature; some examples include 1, 2, and 3
15:32:59 <lambdabot> Good to know.
15:33:25 <monochrom> 1 little, 2 little, 3 little rabbits
15:33:34 <monochrom> 5 little, 8 little, 13 little rabbits
15:35:42 <Tuplanolla> In fact indexing OEIS turns it into an Online Encyclopedia of Integer Synonyms.
15:36:18 <pikajude> Online Encyclopedia of Rabbit Metaphors
15:36:43 <Tuplanolla> For example 8 is the size of the geometric automorphism group of the three-dimensional hypercube.
15:36:55 <Tuplanolla> Thanks, A000165.
15:37:24 <pikajude> i was trying to remember the size of the geometric automorphism group of the three-dimensional hypercube just the other day
15:38:20 <pavolzetor> monochrom, I tried the partition, the problem is merging. I am going back to board, definitely interesting problem as you sort of want it to be inplace instead of allocating memory
15:39:57 <pavolzetor> also, on my test for trilinear ray tracing haskell was only 10-100 slower than C++ which is encouraging
15:40:14 <Tuplanolla> Have you met `ST`, pavolzetor?
15:41:01 <pavolzetor> no, I had to duckduckgo it
15:41:32 <Tuplanolla> If you really need local mutation of bulk data, that's the way to go.
15:42:04 <pavolzetor> interesting, is it safe to execute in parallel?
15:42:17 <pavolzetor> I mean top level, not inside
15:43:22 <Tuplanolla> The mutation is local, so that's not going to be easy. However doing the same mutation in `IO` is possible and requires locking, stm or other data coherency tricks.
15:44:18 <pavolzetor> that's actually perfect, locally it will run in single thread
15:44:37 <pavolzetor> I parallelize per tiles so this is sufficient
16:14:36 <excelsiora> looks like I can get the compiler with this? https://hackage.haskell.org/package/Cabal-1.24.2.0/docs/Distribution-Simple-Compiler.html How would you idiomatically print the compiler name and version?
16:15:54 <ph88> is it possible to make a shorter syntax here? https://paste.fedoraproject.org/539127/48564889/  something like [BDI1, BDI2, .. and so on ?
16:21:30 <geekosaur> if you are looking for the .. syntax, you could derive Enum and maybe Bounded for whatever type has those constructors
16:25:05 <ph88> i don't know the .. syntax
16:25:18 <ph88> i just put .. there for et cetera
16:26:09 <ph88> oh actually i know how to do this
16:27:36 <geekosaur> derive Enum; map (<$> n93) [BDI1 .. BDI16]
16:27:50 <ph88> cool
16:28:12 <geekosaur> (note the spaces are required because it would misparse as a module name otherwise)
16:28:16 <ph88> i think Enum would be a bit confusing here, but it's good to know it exist !!
16:56:40 <systadmin> Hi
17:08:37 <glguy> Hi, systadmin.
18:07:13 <vicfred> hi
18:07:39 <lambdabot> Hello.
18:42:12 <Wizek> So, I'm in the process of learning to use lenses. the `hashmap` package doesn't define lens instances for its Map datatype, so I thought I would write one. Here is my attempt so far: https://gist.github.com/Wizek/0b51ad8413bdcfe24c600e1907324ade Could anyone help me understand what this type error is trying to say? I tried different variations too and the types don't seem to fit together. Could it be that I'll need to define a 
18:42:12 <Wizek> Traversal/IxValue instance instead of a Lens?
18:45:10 <glguy> Wizek: Yes you'll be defining a Lens, but the type you've declared for your lens is wrong
18:45:31 <glguy> You can forget about the IxValue type family for this exercise
18:46:12 <glguy> Your definition for 's' is wrong, too. Once you have the type signature for hmAt correct you should figure out what type 's' should have had
18:46:52 <glguy> Remember that: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
18:47:07 <glguy> In this case you won't need such a general type
18:47:15 <glguy> type Lens' s a = Lens s s a a
18:47:26 <glguy> (that is that s=t and a=b)
18:54:39 <Wizek> Hmm. Maybe my confusion also stems from not yet taking the time to understand the type for Lens and Lens'. A part of me wants this to "just work", and take time to learn/appreciate the theoretical elegance later. But alright I'll try to come up with a different type and definition for 's'.
18:55:28 <Wizek> maybe I could also take something simpler as a stepping stone, e.g. redefining `_1`
18:57:52 <glguy> You don't be able to define a lens by guessing at what they do and what their types should be
19:06:53 <Wizek> > let { g = lens fst (\(a,b) c -> (c,b)) } in ((1,2) ^. g, (1,2) & g .~ 3) -- okay, this works, moving on
19:06:55 <lambdabot>  (1,(3,2))
20:08:21 <systadmin> hi
20:22:27 <Dryvnt> The odd thing about being a beginner is
20:22:40 <Dryvnt> I /know/ I fucked up somewhere along the way in writing this function
20:23:29 <Dryvnt> Now that it works, all I can think of when I look at is "why can't I make it not repulsive"
20:23:40 <Dryvnt> oh well, its 5:20 am so im done coding for now
20:23:47 <Dryvnt> check it out, have a chuckle: https://github.com/Dryvnt/proxygen-hs/blob/master/src/Proxygen/Card.hs#L12-L63
20:33:27 <fragamus> System.FilePath.Posix has a nifty splitPath function but I dont see it in Turtle or in Filesystem.Path.CurrentOS     must I convert to and from string to use the Posix one
20:34:02 <fragamus> or am I missing something
20:36:47 <MarcelineVQ> how about splitDirectories from Filesystem.Path ?
21:31:44 <xpika> using pipes how can I consume only 1 character of stdin 
21:34:00 <Rotaerk> xpika, are you reading lines, but you only want the first character from the line, or are you trying to read characters before enter is hit?
21:35:36 <xpika> Rotaerk: I don't want to read a line as potentially the first line could be larger than memory. On the safe side I want to read just a few characters instead
21:35:55 <Rotaerk> is this not a text file you're reading?
21:36:54 <Rotaerk> I mean if it's interactive, you generally can't read something until enter is pressed and then you get a whole line
21:37:16 <excelsiora> looks like I can get the compiler with this? https://hackage.haskell.org/package/Cabal-1.24.2.0/docs/Distribution-Simple-Compiler.html How would you idiomatically print the compiler name and version?
21:37:23 <Rotaerk> I think there's a way to change the mode so that you get each entered key or something; never tried that though...
21:38:59 <excelsiora> print?
21:39:26 <excelsiora> putStrLn?
21:41:04 <Rotaerk> excelsiora, you mean the CompilerFlavor and Version within the CompilerId?
21:41:59 <xpika> Rotaerk: the standard functions for reading work on lines stdinLn . i want stdinChar
21:42:07 <Rotaerk> CompilerId implements Show, so you should be able to just print it
21:44:40 <Rotaerk> xpika, what about https://hackage.haskell.org/package/pipes-text
21:44:52 <Rotaerk> it doesn't use stdinChar, but it has something that uses hGetChunk
21:45:04 <Rotaerk> i.e. I don't think you have to worry about reading too much at a time
21:45:15 <xpika> Rotaerk: what if i want to ready binary ?
21:45:34 <Rotaerk> look through this https://hackage.haskell.org/packages/search?terms=pipes
21:45:54 <Rotaerk> maybe pipes-bytestring or pipes-binary
21:47:47 <xpika> Rotaerk: thanks
21:48:26 <Wizek> glguy, I'm back and I figured it out! Thanks for the pointers. The type became `hmAt :: _ => k -> Lens' (HM.Map k v) (Maybe v)` and `s` became `s m v = HM.alter (const v) k m`
21:48:33 <dmwit_> xpika: pipes appears to just use System.IO under the hood.
21:48:53 <dmwit_> xpika: So I suspect you should be able to just call `hSetBuffering NoBuffering` and the one of the `take`-alikes.
21:49:21 <Rotaerk> ah, does hSetBuffering do what I was talking about?
21:49:44 <kadoban> I can't tell if this is actually a buffering question. Do you actually want to turn off buffering, or do you only need to make sure that an infinitely long line doesn't break things?
21:50:09 <Rotaerk> neat, it does
21:50:15 <dmwit> I mean, of course there's also BlockBuffering if you still want the benefits of buffering.
21:50:26 <EvanR> seems like they want to react to invidual bytes available on stdin
21:50:43 <dmwit> EvanR: That isn't clear to me, although that's the specific question they asked.
21:51:09 <EvanR> ... right... *presses the "what are you really trying to do" button*
21:51:16 <Rotaerk> given that they weren't sure whether it would fill memory, it seemed unlikely to be a user entering input as opposed to a file being piped into their program or something
21:51:20 <Wizek> glguy, also, for some reason I was very irked by `s` having to take a Maybe value. Seemed like a useless wrapper, since in my case I always wanted to set Just a value. Until I realized that Nothing encodes deletion. Which makes tremendous sense, even if I may not use in this usecase.
21:51:41 <Rotaerk> and said file may have huge lines
21:51:51 <Rotaerk> just guessing though...
21:53:37 <glguy> Wizek: Nice work!
21:53:54 <dmwit> xpika: Something like `charFromHandle h = liftIO (hSetBuffering h BlockBuffering) >> go where go = do { eof <- liftIO $ IO.hIsEOF h; unless eof (liftIO (hGetChar h) >>= yield >> go) }`.
21:54:08 <dmwit> xpika: (Cribbing from the implementation of `Pipes.Prelude.fromHandle`, which is line-based.)
21:56:05 <dmwit> oops
21:56:24 <pikajude> heh, ex-pika
21:56:35 <dmwit> should be `(BlockBuffering (Just 1024))` or whatever size buffer you're comfortable with. `Nothing` means you don't care
21:57:05 <dmwit> Never knew about `hShow`. That looks fun.
22:18:38 <user__> testing
23:01:00 <systadmin> Hi
