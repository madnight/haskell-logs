00:00:06 <ertes> YellowOnion: one way to do it would be to parse the outer list on your own, but that basically means that you have to write a streaming JSON parser, at which point you might as well not use aeson at all
00:02:24 <hvr> ertes: fyi, https://github.com/haskell/cabal/issues/2832
00:03:38 <ertes> Squarism: ^
00:05:53 <Squarism> hvr, ertes : great! Lets hope for 2.0 then
00:07:33 <YellowOnion> ertes, since json-stream does stay in constant space, when for example, using last on the list, I think there's maybe some tricks I can pull.
00:31:20 <ertes> YellowOnion: you could of course just convert the input file first…  for example CSV can be stream-parsed easily
00:31:58 <YellowOnion> ertes, that's kind of what I was thinking, but you could probably do it in memory.
00:35:17 <ertes> YellowOnion: if you trade tolerance for malformed input for incremental parsing, that's also possible, yeah…  i see no way to do it with aeson though…  it's not incremental, and it doesn't even return leftovers
00:35:35 <somewone> Hi, first time I'm uploading a Hackage package candidate. Is there anything I have to do, to upload the haddock documentation or is added to bundle when running `cabal sdist`?
00:36:19 <ertes> somewone: in a perfect world it would be generated by hackage itself by building your package…  that's what's supposed to happen anyway, but it doesn't work sometimes
00:36:31 <cocreature> somewone: you need to run cabal haddock --for-hackage and then cabal upload --doc dist/something
00:37:10 <cocreature> in a perfect world cabal and stack would just autoupload docs and we wouldn’t have to worry about hackage building docs
00:37:21 <ertes> uh, nice!  i didn't know about those =)
00:37:58 <somewone> ok thank you, I'll give that a try.
00:38:13 <glguy> the flags i use are in my script in the lens repo
00:38:52 <glguy> has the flag to enable nicer syntax highlighting
01:08:20 <martisj> Morning
01:10:20 <MarcelineVQ> What is the word for not parallel?
01:10:39 <martisj> MarcelineVQ synchronous?
01:11:10 <mfukar> sequential
01:11:11 <MarcelineVQ> aha,sequential
01:17:36 <Cale> MarcelineVQ: hehe, "intersecting"
01:32:27 <MarcelineVQ> add mapConcurrently, job takes 6x longer, uh oh :(
01:39:57 <maerwald> did 8.0.2 get faster? It's just a feeling
01:40:25 <maerwald> but then again, my feelings often trick me
01:40:49 <Rembane> Search your feelings, you know them to be true.
01:41:17 <maerwald> Yes master Obi-Wan.
01:41:22 <MarcelineVQ> medichlorians
01:42:55 <Rembane> maerwald: The release notes for 8.0.2 don't mention any work on speed. What versions are you comparing? 
01:43:27 <maerwald> 8.0.2 to 8.0.1
01:43:54 <maerwald> don't have both installed though, just 8.0.2 now
01:44:05 <Rembane> Then it's just the Force.
01:44:09 <maerwald> :D
01:47:39 <HugoDaniel> w00t 8.0.2 was released ? nicest
01:50:20 <reactormonk> I'm trying to play with TypeError, but ghc doesn't like the wildcard in the AllCTRender declaration - what's the correct way to write this? https://gist.github.com/cb1d7a8ccbb4633d87e42716aeb1a03f
01:50:36 <Squarism> If you focus hard and direct a tight palm towards your computer - software often runs faster, yes
02:00:40 <Geekingfrog> I'm making an IRC bot which process commands. A (simplified) command is a pair (parser, cmdType). Currently I have an ADT for all command types and a function to process them. How can I enforce that the parser (Text -> Either String cmdType) matches the command type in the pair ?
02:01:03 <Geekingfrog> That is (parserA, cmdTypeA) is valid, but (parserB, cmdTypeA) would error at compile time
02:07:30 <ertes> Geekingfrog: one way would be dependent-sum
02:07:35 <ertes> @package dependent-sum
02:07:35 <lambdabot> http://hackage.haskell.org/package/dependent-sum
02:08:36 <Geekingfrog> mmm, I've simplified a bit here, but in my case, a command is much more than a tuple.
02:08:54 <Geekingfrog> Ideally I'd like to have this working for a record.
02:09:02 <reactormonk> System.Process the correct approach for shelling out and read the stdout?
02:09:24 <ertes> reactormonk: yes
02:09:43 <Geekingfrog> ah, wait, apparently dependant-sum is more general than I thought.
02:09:44 <ertes> Geekingfrog: there is really no limit in what the second component is, as long as the first component specifies its type
02:10:19 <Geekingfrog> Ok thanks, I'll have a look and if I'm still disatisfied I'll come back here. Thanks ertes 
02:18:33 <tabaqui1> @let type Foo a = Int
02:18:35 <lambdabot>  Defined.
02:18:42 <tabaqui1> @let x = 2 :: Foo Char
02:18:44 <lambdabot>  .L.hs:171:1: error:
02:18:44 <lambdabot>      Multiple declarations of ‘x’
02:18:44 <lambdabot>      Declared at: .L.hs:166:24
02:18:53 <tabaqui1> @let myX = 2 :: Foo Char
02:18:55 <lambdabot>  Defined.
02:19:17 <tabaqui1> @let myF :: Foo Int -> Bool; myF x = x == 2
02:19:19 <lambdabot>  Defined.
02:19:22 <tabaqui1> > myF x
02:19:25 <lambdabot>  error:
02:19:25 <lambdabot>      Ambiguous occurrence ‘x’
02:19:25 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
02:19:27 <tabaqui1> > myF myX
02:19:30 <lambdabot>  True
02:20:03 <tabaqui1> "type" keyword with type constructor has no sense
02:25:08 <geekosaur> could be useful if a type constructor that had a parameter lost it, you could provide backward compatibility
02:28:57 <omongo> 
02:29:00 <tabaqui1> too specific case, imo
02:32:11 <Ferdirand> what about type families ?
03:00:16 <MarcelineVQ> ertes: https://github.com/MarcelineVQ/weigh/tree/residency
03:01:46 <jstolarek> I have:
03:02:05 <jstolarek> foo :: Eq a => Map Foo a
03:02:26 <jstolarek> and it turns out I can't write
03:02:38 <jstolarek> x `member` foo
03:02:59 <jstolarek> because there is no way to resolve what `a` type variable should be
03:03:25 <jstolarek> I can't figure out a way around this
03:03:27 <MarcelineVQ> you can make a map with just Eq, but most of the methods on map require Ord
03:04:31 <jstolarek> note that Eq is on values, not keys
03:05:16 <jstolarek> key type is Foo and it has both Eq and Ord
03:06:02 <jstolarek> the problem is that calling `member` requires resolving a concrete type for values, even though `member` is only concerned with keys and never looks at values
03:06:04 <Ferdirand> well
03:06:41 <Ferdirand> the only value of type (forall a. Eq a => a) is bottom, no ?
03:07:30 <jstolarek> Ferdinand: I simplified my example to convey the main point
03:07:36 <ertes> MarcelineVQ: nice, although personally i've just used performGC and getGCStats directly, most of the time in an interactive setting =)
03:07:54 <jstolarek> if you really want to know the type is
03:08:01 <jstolarek> Eq a => Map Primitive ((a, a) -> Value)\
03:08:06 <opqdonut> > let x = M.empty :: Eq a => M.Map Bool a in M.member True x -- worksforme
03:08:08 <lambdabot>  False
03:08:11 <ertes> jstolarek: haskell doesn't mind not instantiating a fully polymorphic type variable, but yours isn't
03:08:17 <ertes> jstolarek: you have an Eq constraint on it
03:08:25 <MarcelineVQ> this can be plugged into tests now so maybe it'll see some use, I'll use it at least :> before other tests would disrupt it and it didn't have residency info as part of the summary
03:08:30 <ertes> > const () (undefined :: a)
03:08:33 <lambdabot>  ()
03:08:39 <ertes> > const () (undefined :: (Eq a) => a)
03:08:41 <lambdabot>  ()
03:08:45 <ertes> ah, even that works
03:10:02 <ertes> MarcelineVQ: my idea was very different:  make something like criterion, but not as a benchmarking library, but as a test framework to test for complexity curves
03:11:09 <ertes> shouldn't be too difficult to do, so if a use case pops up, i might do it
03:12:28 <meditans> I have a question on the best way to accomplish something (the problem stemming from the fact that I can't partially apply type synonyms): let's say I have
03:12:40 <meditans> type family Foo a
03:12:40 <meditans> I have a question on the best way to accomplish something (the problem stemming from the fact that I can't partially apply type synonyms): let's say I have
03:12:41 <meditans> type family Foo a
03:12:50 <meditans> (sorry for the duplication)
03:13:14 <meditans> and I want to write:
03:13:35 <meditans> instance Foo A = SomethingDependingOn Foo
03:13:45 <safinaskar> please, say me some argument (or link) for (or against) separate sum and product types, as in ml
03:14:19 <meditans> this is not possible because Foo is not fully applied, but is there a way in which I could get the same effect?
03:14:50 <meditans> basically a type family which is recursively defined, with some basecase being
03:14:58 <meditans> instance Foo Text = Text?
03:15:09 <ertes> meditans: you need a 'data' family for that
03:15:42 <meditans> thanks ertes, but how do I go around needing multiple constructors for that? I mean
03:15:51 <meditans> data family Foo a
03:16:36 <meditans> data instance Foo Text = Text
03:16:56 <meditans> data instance Foo A = Constructor (SomethingDependingOn Foo)
03:17:06 <meditans> and I would like to have:
03:17:07 <ertes> meditans: i think you're looking for a GADT instead of a type family
03:17:22 <MarcelineVQ> jstolarek: what does your actual code look like?
03:17:43 <jstolarek> MarcelineVQ: I can show you once I'm done refactoring it
03:17:50 <jstolarek> I've managed to solve the problem
03:17:52 <meditans> data instance Foo B = CannotHaveSameConstructor (SomethingDependingOn Foo)
03:18:00 <jstolarek> explicit type applications for the win!
03:18:12 <ertes> meditans: data Foo :: * -> * where TextFoo :: Text -> Foo Text; CFoo :: SomethingDependingOn Foo -> Foo A
03:18:24 <jstolarek> that, and AllowAmbigousTypes
03:18:56 <MarcelineVQ> I'm not sure you need such a hammer
03:19:12 <meditans> ertes: right, but that is closed, right? I mean, the users cannot add more/different instances
03:19:34 <ertes> meditans: you can open it up by making it a data family
03:19:41 <meditans> (still, I will try to model the general case that way, maybe I can get away with a constructor for the base case and one for the recursive one)
03:19:45 <meditans> how so, ertes?
03:20:39 <ertes> meditans: data family Foo a; newtype instance Foo Text = TextFoo Text; newtype instance Foo A = AFoo (SomethingDependingOn Foo)
03:20:53 <ertes> (then of course you no longer need a GADT)
03:21:50 <ertes> meditans: a data family is just a regular type…  it doesn't need to obey type alias rules
03:22:08 <ertes> in particular partial application and recursion are allowed
03:23:05 <meditans> right, so this was the solution sketched above, which had the `problem` of requiring new constructors for every instance, but if this is the canonical way I'll do this (just wanted to make sure there are not smarter ways)
03:23:25 <jstolarek> MarcelineVQ: I will be happy to have a simpler solution.  Let me just get my code in shape and I'll show you what it looks like
03:23:45 <meditans> ertes: thanks for the answer, I have a clearer picture now!
03:24:27 <ertes> meditans: you can't get around that requirement, but you don't necessarily need a data family to achieve extensibility…  other extensibility methods include: 1. add a type variable for extensions, 2. construct a type-level algebra for your type
03:24:57 <ertes> meditans: example of the former: monad transformers (they abstract over the underlying monad and let the user choose that one)
03:25:12 <ertes> meditans: example of the latter:  if 'a' and 'b' are monoids, (a, b) is also a monoid
03:25:47 <meditans> ok, give me a minute to think how these solution would look in my setting
03:26:04 <tdammers> hrrngh... 'Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"'
03:26:13 <tdammers> I hope upgrading stack and cabal fixes this
03:26:31 <MarcelineVQ> that error is most common with older stack versions
03:26:47 <tdammers> upgrading stack as we speak
03:27:03 <tdammers> at first I suspected it had something to do with x64 vs. x86
03:27:16 <tdammers> but turns out the stack on x86 I have is pretty old
03:28:25 <sbrg> tdammers: which version of stack are you using?
03:28:53 <sbrg> IIRC I remember seeing errors like that with some of my students that got stack 0.1.x from their distro's repos
03:28:57 <sbrg> upgrading stack solved it
03:32:36 <tdammers> yeah, it's 0.1.something
03:32:59 <tdammers> upgrading as we speak, just takes a while because it's a somewhat underpowered VM and I'm compiling from source :x
03:33:22 <tdammers> but thanks for confirming
03:34:58 <meditans> ertes: I see the points of the solution you mentioned, however I think I'll stick to data families, because I'd really like to depend on Foo (partially applied)
03:35:52 <meditans> at least, I'm not seeing how I could satisfy that requisite in the methods above
03:36:04 <meditans> but the data family solution is not too bad, after all
03:37:50 <dramforever> newtype FooWrap a = FooWrap (Foo a) can be partially applied
03:41:30 <ertes> meditans: data Foo :: (* -> *) -> * -> * where AFoo :: SomethingDependingOn (Foo ext) -> Foo ext A; ExtFoo :: ext a -> Foo ext a; TextFoo :: Text -> Foo ext Text
03:41:31 <Athas> Does anyone have a precompiled stack binary for OpenBSD?
03:41:43 <Athas> I'm not sure how I'm supposed to bootstrap the installation here.
03:42:30 <ertes> meditans: this is a fairly flexible version, because it lets extensions select the second type argument of Foo, but that's optional…  you can simplify the extension variable's kind to * if you don't need that
03:42:40 <ertes> SimpleExtFoo :: ext -> Foo ext a
03:44:16 <ertes> meditans: BTW, this is an instance of the first method…  generally the second method is preferable if possible
03:44:34 <meditans> thanks dramforever, that's a ligthweitght suggestion I didn't consider!
03:44:52 <meditans> ertes: but how would I go to add IntFoo as a user?
03:45:19 <meditans> (I mean, the gadt approach still has the closeness property, right?)
03:45:29 <ertes> data IntFoo :: * -> * where IntFoo :: Int -> IntFoo Int
03:45:48 <ertes> ExtFoo (IntFoo 5) :: Foo IntFoo Int
03:46:58 <meditans> give me a minute to play around with this, it's dense :D
03:47:45 <ertes> IntFoo's type argument is only there to enforce the last type argument of Foo to be Int
03:47:53 <ertes> without that it would look like this:
03:48:02 <ertes> SimpleExtFoo 5 :: Foo Int a
03:49:37 <ertes> you can also make a more generic version:  data Ext :: * -> * -> * where Ext :: a -> Ext a a
03:49:46 <ertes> ExtFoo (Ext 5) :: Foo Int Int  -- ok
03:49:55 <ertes> whoops
03:50:00 <ertes> ExtFoo (Ext 5) :: Foo (Ext Int) Int  -- ok
03:50:05 <ertes> ExtFoo (Ext 5) :: Foo (Ext Int) String  -- type error
03:58:40 <jstolarek> MarcelineVQ: https://github.com/jstolarek/slicer/blob/master/src/Trace.hs#L606
03:58:51 <jstolarek> there. That's what it relly looks like
03:59:12 <jstolarek> if there's a way of doing this without explicit type applications I'd be happy to hear ot
04:02:22 <opqdonut> jstolarek: what's the error if you define it symmetrically with isIntBinOp?
04:05:09 <LSorceress> hello
04:05:24 <LSorceress> I'm looking at gloss's code and I wonder what this  "= {-# SCC "drawComponent" #-}" is
04:05:54 <opqdonut> LSorceress: that's a profiling annotation
04:06:06 <opqdonut> defines a cost centre called drawComponent
04:06:17 <opqdonut> {- blah blah -} is a comment
04:07:08 <jstolarek> opqdonut: sorry, I don't understand what you mean by "symmetrically with isIntBinOp"
04:07:29 <jstolarek> isIntBinOp is not polymorphic, isCommonOp is
04:07:41 <opqdonut> jstolarek: I mean "isCommonOp :: Primitive -> Bool; isCommonOp op = op `member` commonOps"
04:07:46 <opqdonut> jstolarek: isCommonOp isn't polymorphic
04:07:54 <LSorceress> Thanks, opqdonut
04:08:06 <jstolarek> opqdonut: type ambiguity
04:08:14 <opqdonut> jstolarek: it's basically just checking whether op is OpEq or OpNeq
04:08:22 <jstolarek> exactly
04:08:35 <jstolarek> but commonOps has a type class constraint that GHC cannot resolve
04:09:25 <opqdonut> jstolarek: ok I think I see. can't you just default a to say () then?
04:09:45 <jstolarek> hm...
04:09:51 <jstolarek> that might be an idea
04:11:15 <jstolarek> opqdonut: yeah, that works
04:11:17 <jstolarek> thanks
04:11:23 <jstolarek> I knew there must be a better solution
04:12:13 <jstolarek> I knew there must be a better solution
04:27:49 <Layl> Hey, why was the Haskell programmer fired?
04:27:53 <flxw> Hello all. Is there a infix operator for flip fmap, like <$>, just with reversed arguments?
04:27:54 <Layl> His supervisors discovered he only did work while they were evaluating him.
04:28:18 <magneticduck> hahaa
04:28:23 <NextHendrix> Layl: heh
04:29:51 <jophish_> flxw: check out <&>
04:29:54 <liste> @hoogle <&>
04:29:54 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
04:29:54 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
04:29:54 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
04:29:59 <b_jonas> lol
04:32:43 <dramforever> I think people won't kill you if you defined your own (<&>) to avoid depending on lens (or, 'a lens package')
04:33:53 <flxw> thanks alot.
04:34:37 <reactormonk> Is there a shorthand for (\x -> (foo, x)) ?
04:35:06 <opqdonut> > (True,) 1
04:35:09 <lambdabot>  (True,1)
04:35:20 <NextHendrix> doesn't that need a language extension
04:35:35 <reactormonk> Yeah, it does.
04:35:47 <tabaqui1> on downloads.haskell.com there is explanation of arrow notations
04:35:49 <tabaqui1> *are
04:35:56 <opqdonut> well (,) True works without extensions
04:36:03 <tabaqui1> and translation from arrow-do
04:36:10 <NextHendrix> > (,) True
04:36:12 <lambdabot>  error:
04:36:12 <lambdabot>      • No instance for (Typeable b0)
04:36:12 <lambdabot>          arising from a use of ‘show_M111495621020648351514468’
04:36:17 <tabaqui1> but no translation from arrow-do-rec notation
04:36:24 <opqdonut> > (,) True 1
04:36:28 <lambdabot>  (True,1)
04:36:46 <tabaqui1> which code equals code with "rec"?
04:36:58 <NextHendrix> > True (,1)
04:37:03 <lambdabot>  error:
04:37:05 <lambdabot>      • Couldn't match expected type ‘(t0 -> (t0, Integer)) -> t’
04:37:09 <lambdabot>                    with actual type ‘Bool’
04:37:50 <opqdonut> > (,1) True
04:37:52 <NextHendrix> nvm, checked it prefix
04:37:53 <lambdabot>  (True,1)
04:37:54 <Layl> Haskell programmer taking the trash out: He's done it but you just won't realize it yet until the garbage truck comes
04:38:23 <NextHendrix> Layl is all zingers all the time
04:39:04 <NextHendrix> Haskell programmer taking the trash out. Takes the first bag and then takes the trash out
04:40:03 <Layl> Haskell marriage proposal: "I think it's time to evaluate our relationship"
04:42:28 <HugoDaniel> ahah
04:42:34 <HugoDaniel> that marriage is very good :D
04:43:11 <Layl> Javascript breakup: "I think it's time to evalua*gets cut off*"
04:44:54 <reactormonk> Is there a nicer way to write https://gist.github.com/reactormonk/483be50e6b294737b429041ad2a322fa ?
04:45:46 <ertes> the 'recip' implementation for Double seems extremely unstable
04:45:46 <reactormonk> The type before >>= is ExceptT <ADT of InvalidJson> IO ByteString
04:45:48 <ertes> whoops
04:45:52 <ertes> the 'recip' implementation for Complex Double seems extremely unstable
04:46:01 <ertes> > recip (encodeFloat 1 (-538) :+ 0) :: Complex Double
04:46:03 <lambdabot>  Infinity :+ NaN
04:46:15 <ertes> > recip (encodeFloat 1 (-538)) :: Double
04:46:18 <lambdabot>  8.997827589086393e161
04:47:54 <ertes> in fact Double can handle twice that range
04:47:59 <ertes> > recip (encodeFloat 1 (-1023)) :: Double
04:48:02 <lambdabot>  8.98846567431158e307
04:48:50 <ertes> should that be considered a bug?
04:49:21 <dramforever> reactormonk: Right id -> return $ OAuth ...
04:49:28 <dramforever> Left err -> throwError $ InvalidJson...
04:49:39 <reactormonk> dramforever, trying to see if *** works
04:50:25 <opqdonut> reactormonk: also, you can destructure t, like >>= (\(foo,bar) -> ...)
04:50:56 <dramforever> and if you do >>= (\(foo, bar) -> ...) you can use foo instead of (fst t)
04:51:01 <dramforever> and bar instead of (snd t)
04:51:02 <opqdonut> yeah
04:51:11 <reactormonk> Looks good.
04:51:19 <ertes> reactormonk: don't call variables "id"…  i call them "k" ("key") instead
04:51:56 <reactormonk> ertes, I think in the domain of oauth things, id is appropriate.
04:52:07 <opqdonut> it's just that id is a function in the standard library too
04:52:09 <opqdonut> :t id
04:52:10 <dramforever> > recip (1 :+ 0) :: Complex Double
04:52:11 <lambdabot> a -> a
04:52:14 <lambdabot>  1.0 :+ 0.0
04:52:14 <ertes> reactormonk: yeah…  rename it anyway =)
04:52:15 <reactormonk> got it
04:52:44 <opqdonut> perhaps oid or oauthId or authId
04:52:48 <dramforever> reactormonk: There's already a function named id
04:52:49 <dramforever> :t id
04:52:51 <lambdabot> a -> a
04:53:06 <ertes> if you want to have the "id" in there, give it a prefix ("authId" perhaps)
04:55:22 <dramforever> Got Internet problems earlier, sorry if something I said didn't make sense
05:15:36 <orzo> i have a binding that is clearly not used but -Wunused-binds and -Wunused-top-binds are not reporting it
05:15:57 <orzo> is there some nuance to those?
05:16:14 <dramforever> Got Code?
05:20:30 <orzo> https://github.com/pxqr/bittorrent/blob/dev/src/Network/BitTorrent/Address.hs
05:23:26 <orzo> _resolvePeerAddr is not used
05:24:17 <LSorceress> does anyone have any idea as to how one might create a stroke font 
05:24:48 <LSorceress> I'm trying to change gloss to use something else than GLUT.Roman but I don't know of any other stroke fonts
05:25:13 <LSorceress> and GLUT only has MonoRoman as an alternative -_-
05:33:08 <orzo> dramforever: This single line haskell program does not warn of an unused binding:  module Unused () where _resolvePeerAddr = undefined
05:33:22 <orzo> do they exempt undefined?
05:33:39 <orzo> no, i set it to 3
05:33:42 <orzo> still no warning
05:33:51 <orzo> this is weird
05:33:54 <orzo> ghc 8.0.1
05:34:49 <orzo> it seems to be the leading underscore
05:34:55 <orzo> they exempt leading underscores
05:35:56 <dramforever> Yes, was going to say that :)
05:37:05 <orzo> don't suppose theirs a stricter version that includes underscores
05:37:09 <orzo> there's
05:37:23 <dramforever> It's kinda useful. I can say fooAcceptsCallback (\butOneParameter _isUnused -> ...) and name the second arg so I know exactly what's unused
05:40:40 <ertes> LSorceress: font rendering unfortunately isn't gloss' strength…  one thing you could do is to render into a texture via e.g. Rasterific
05:41:10 <LSorceress> @ertes i'll look into it
05:41:11 <lambdabot> Unknown command, try @list
05:46:04 <ertes> LSorceress: if you're into pain, you might even try to use FontyFruity directly and render the strokes to a Picture
05:46:13 <ertes> it's probably not even that difficult
05:50:49 <LSorceress> oh, that sounds lovely.
05:53:02 <bweston92> How does package management work in Haskell? Everything has a "git clone" statements on their docs but where do I clone it too? Is there no like "pkgmanagement install <packagename>" tool?
05:53:09 <bweston92> Sorry for newbish question
05:53:37 <somewone> Is there a way to enforce loading a package via stack/github? I had to fork a project, but after specifying the forked package location via the stack.yaml it still seems to pick the hackage version.
05:54:54 <LSorceress> I'm going to try to do that
05:57:16 <suppi> bweston92: have you seen this? https://haskell-lang.org/get-started
05:57:40 <bweston92> suppi: No sorry I've just come from watching Lambda school :/ I will take a look, thanks
05:58:29 <bweston92> I use stack for creating and building
05:59:30 <vens> haskell!
06:00:04 <LSorceress> ertes : I'm looking at fontyfruity on hackage and I am honestly completely bamboozled
06:00:42 <LSorceress> do you know of any projects using it
06:03:16 <LSorceress> I'm really in over my head here holy fug cx 
06:08:54 <bweston92> suppi: Where in that documentation does it say about getting third part deps? Sorry
06:09:12 <ertes> LSorceress: well, Rasterific uses it
06:13:07 <vens> a
06:24:07 <savask> Hello. I have a haskell program with two functions: foo and bar. foo traverses a structure and sometimes calls bar. I've noticed that I pass a superfluous argument to bar, as it can be computed from its other arguments. But after I moved that argument computation inside bar, the program started working ~3 times slower.
06:24:10 <savask> That argument is used only once per bar call, so no common subexpression saving should take place. The question is: how is that possible? Since then I've been able to reduce running time by making foo a tail recursive function + a few other tricks, but it still would be nice to know the answer.
06:24:18 <athan> Hey everyone, when I run `./sync-all get` in the GHC master repo, I don't think my libraries/ folder is populating. What do?
06:24:48 <athan> (I'm trying to upgrade GHC 7.6.3 (eventually) to 8.0.1, but right now I'm on 7.8
06:24:51 <athan> )
06:25:43 <athan> savask: I read a really nice paper on G machines for Miranda not long ago
06:26:20 <savask> athan: Nice
06:26:26 <athan> one sec :x
06:27:55 <athan> agh, I might message it to you this is going to take a bit of digging
06:28:35 <athan> but it went into the general idea of supercombinator translation techniques, and how that is used to make a pointer-based "graph machine"
06:28:57 <athan> but I don't think it had anything to do with -threaded or GHC's modern features
06:31:25 <savask> Well, if it's GHC's quirk, then it's a pretty weird one
06:33:52 * ski . o O ( "An Architecture for Combinator Graph Reduction (TIGRE)" (Ph. D. thesis) by Philip Koopman in 1990 at <https://users.ece.cmu.edu/~koopman/tigre/index.html>,<http://repository.cmu.edu/isr/710/> )
06:34:30 <ski> savask : computed locally ?
06:34:45 <ski> (is `bar' recursive ?)
06:35:29 <reactormonk> So what should I be using? String, Text, ByteString? Got ClassyPrelude here already.
06:35:42 <reactormonk> ... and how would I convert Text down to String if I need it?
06:36:01 <c_wraith> ski: did TIGRE predate STG?  Or are they just addressing different aspects of the problem?
06:36:19 <ski> i don't know
06:36:21 <savask> ski: bar itself isn't recursive, but it has a recursive subfunction "go" defined inside which uses that troublesome argument 
06:36:52 <ski> savask : and the difference was between `foo' computing it, and `bar' (not `go') computing it ?
06:37:00 <savask> ski: Yeah
06:37:15 <savask> So in both cases it should be computed only once per bar call
06:37:56 <ski> presumably it wasn't passed as an argument to `go' in either case
06:38:15 <savask> Yes, but go obviously could reference it
06:38:19 * ski nods
06:39:29 <ski> so, barring more advanced rewriting (lambda-lifting ? some kind of fusion ?), i suppose the difference couldn't be attributed to access via static link, vs. more direct access
06:48:12 <nevere> In Opaleye, is there a way to filter a (Column PGArray a)?
06:49:38 <Rodenbach> Did some of you guys worked/played with Frege?
06:50:15 <bweston92> If I use stack do I still need cabal?
06:50:46 <athan> shoot, who was it asking for syntactical optimization help?
06:50:56 <vektor> Anyone here familiar with hint (Language.Haskell.Interpreter)? I recently switched my build process to stack and now my hint code broke. It looks like it can't find the library I'm importing in the module I'm loading (loadModules).
06:51:02 <vektor> athen: savask maybe?
06:51:04 <athan> here's a nice read: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
06:51:26 <vektor> athan: Oops, typo'd your name. The foo and bar thign?
06:52:27 <vektor> regarding hint, Is anyone aware where hint gets it's libraries from? Or whether something changed with that process?
06:52:31 <athan> Ahh you're right though
06:52:42 <athan> savask: ^ check out that book
06:55:52 <nevere> In Opaleye, is there a way to filter a (Column PGArray a)?
07:03:48 <savask> athan: Thanks, that will definitely help in understand how GHC works but I'm afraid it's a bit unpractical to study my issue that way, lol
07:05:16 <athan> eh what you described seemed to fit the bill - you said different runtime behavior based on an accumulator type for TCO-stuff?
07:05:21 <athan> it's in there
07:05:44 <athan> but yeah it might be too internal, idk
07:08:34 <wonder91> I'm trying out Liquid Haskell and I've not quite figured it out. Here's my attempt, and the liquidhaskell error: http://lpaste.net/351343
07:09:23 <codedmart> I am writing an client to an api. There is `datetime` in the api docs which is eq to `UTCTime`, but there is also, `time` and `date` in the api docs? What would this eq in Haskell?
07:09:39 <wonder91> Why can't it see that my Image type is constrained by the Pixel type:  {-@ type Pixel = {p:Int | p <= 255} @-}
07:09:40 <wonder91> ?
07:10:17 <chpatrick> has anyone had a problem with an inline-c symbol not being found?
07:10:24 <chpatrick> specifically with nix
07:10:58 <Philonous> I have a package with a library an a test suite, the test suite depends on the library as a build-dependency. I can build it all fine with stack build --test, but when I try to stack ghci :testsuite  cannot satisfy -package <libraryname>, what am I doing wrong?
07:11:52 <chpatrick> codedmart: Day and TimeOfDay?
07:14:41 <Rodenbach> I thought that putting parens around   let (a, b, c) = (100, 200, 300) in [a, b, c]    would result in ([100, 200, 300]) – a tuple with one element, which is a list. But even    (((let (a, b, c) = (100, 200, 300) in [a, b, c])))   produces the same output: [100, 200, 300]. Why is that?
07:14:44 <nevere> In Opaleye, is there a way to filter a (Column PGArray a)?
07:15:07 <quchen> Rodenbach: We don’t have 1-tuples in Haskell. (x) is a parenthesized »x«.
07:15:07 <tdammers> Rodenbach: Haskell doesn't have one-tuples
07:15:20 <Rodenbach> Ah. Okay, makes sense then, thanks.
07:15:24 <quchen> (Identity can be seen as the canonical 1-tuple if you want.)
07:15:29 <ski> wonder91 : i don't know much about LiquidHaskell. there seems to be a #liquidhaskell channel, perhaps you can also try asking there (and then, as is IRC custom for .. less busy (often technical) channels, preferably wait at least a few hours, possibly coming back later days to check whether people have noticed your question, and have something to respond)
07:15:50 <ski> wonder91 : what is the (LiquidHaskell) type of `Data.Array.IArray.amap' ?
07:18:42 <ski> wonder91 : quite probably it doesn't help, but i would try having `type Image = Array (Int,Int) Pixel' as "main" definition of `Image', adding a `type Pixel = Int' as a non-liquid definition of `Pixel'
07:19:12 <wonder91> ski: hi. I've changed it slightly: http://lpaste.net/351343
07:19:29 <wonder91> The error's the same.
07:19:35 * ski is only guessing here how LiquidHaskell behaves with "normal" vs. "liquid" declarations of types, type signatures, &c.
07:21:34 * ski assumes wonder91 is a newbie with IRC
07:22:10 <wonder91> ski: why so?
07:23:03 <ski> well, simply because you were using the FreeNode web interface to the IRC network, and not a separate IRC client
07:23:25 <ski> (of course not all who use that are newbies, but i believe more newbies use such interfaces)
07:24:45 <ski> (and that's why i added the bit about "IRC custom", also partially since it's typically easier to forget about being connected to an IRC network in a tab in your web browser, (hours) later closing the browser without checking back on IRC whether someone has responded)
07:25:44 * ski has many times experienced being able to answer a question asked by someone on an IRC channel, but they left too soon for anyone (who could answer) got a chance to respond
07:27:37 <ski> (often they don't come back at all. if you're lucky, they'll come back some hours later, or a day or some days later. several times i've also experienced this happening, only they have managed to not be connected at the time i had time to check on IRC .. and with no registered IRC nick, there's often no easy way then to send a message which will be delivered when (if) they return)
07:28:22 <ski> (.. other times, i've participated in conversations where there have been hours inbetween the individual things said)
07:28:35 <ski> wonder91 : does that help ?
07:29:31 <wonder91> ski: thanks, yes. I'm asking on #liquidhaskell also.
07:29:36 * ski nods
07:33:40 * ski idly wonders why it's not written (or possible to write) as `brightenPixel :: {pIn : Int | x <= 255} -> {pOut : Int | pIn <= pOut && pOut <= 255 }' (anaphora, cf. "donkey sentence")
07:34:47 <ski> wonder91 : btw, you didn't answer about `amap'
07:35:40 <quchen> hvr: ping
07:37:14 <quchen> Oh, haskell.org donations can be made via PayPal!
07:38:03 * sm thinks haskell should set up on opencollective.com
07:42:20 <jchia_> conduit question: I have an input file from which I want to parse a Foo (using Binary Get), and then a variable number of Bar. (Foo comes first in the file, followed by the Bars.) I want to do this with conduit. It seems that for the Foo I'll have one ConduitM and for the Bars I'll have another ConduitM. How do I express that I want to connect the source to the first ConduitM, run it until I get one Foo, then connect the source to the second ConduitM and cont
07:44:34 <nevere> In Opaleye, is there a way to filter and update a postgres Array column (apply a filter to a value of type Column PGArray a)?
07:51:48 <asdf12345> @help
07:51:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:54:49 <Alxandr> Hi. I'm getting Not in scope: type constructor or class `Typeable' error. Do I need to import something to derive from Typeable?
07:56:03 <k0001> Alxandr: import Data.Typeable (Typeable)
07:56:10 <eschnett> @help
07:56:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:56:33 <eschnett> @pl fmap
07:56:33 <lambdabot> fmap
07:56:47 <eschnett> @lp \x -> f (g x)
07:56:47 <lambdabot> Maybe you meant: wn v slap rc pl let id help do bf @ ? .
07:57:05 <eschnett> @pl \x -> f (g x)
07:57:06 <lambdabot> f . g
07:57:15 <eschnett> @pl x+1
07:57:15 <lambdabot> x + 1
07:57:23 <eschnett> @pl \x -> x+1
07:57:24 <lambdabot> (1 +)
07:57:25 <maerwald> eschnett: please play with lambdabot in a query
07:57:33 <quchen> You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others). 
07:57:52 <eschnett> @maerwald: thanks for the pointer
07:57:52 <lambdabot> Unknown command, try @list
07:59:57 <Alxandr> k0001: Thanks, that seems to have worked :)
08:11:07 <nevere> In Opaleye, is there a way to filter and update a postgres Array column (apply a filter to a value of type Column PGArray a)?
08:13:10 <NatureShade> Just upgraded to ubuntu 16.10, having some crazy linker issues with GHC, any tricks?
08:15:30 <quchen> NatureShade: Paste the console output please
08:15:36 <quchen> ?paste
08:15:36 <lambdabot> Haskell pastebin: http://lpaste.net/
08:16:13 <pie_> https://wiki.haskell.org/Haskell_IO_for_Imperative_Programmers ". The way to resolve that tension is to think differently. Instead of thinking about IO as something you do, you need to shift gears and think about IO as a result that you achieve. The programming task then becomes one of describing the program’s interaction with the outside world. (That turns out to be a much more powerful idea, the full consequences of which are beyond th
08:16:13 <pie_> e scope of this post.)"
08:16:19 <pie_> where can i read more about this?
08:16:25 <NatureShade> took only some of it
08:16:35 <NatureShade> http://lpaste.net/351347
08:18:21 <ClaudiusMaximus> NatureShade: might be fixed by  cabal installl --ghc-options=-optl-no-pie  which is my standard recipe at the moment, i hear ghc 8.0.2 might fix this issue with hardened lower-level compilers shipped as standard by some distributions
08:18:40 <ClaudiusMaximus> or just -optl-no-pie if using ghc directly
08:19:08 <NatureShade> just downloaded newest version of haskell-platform, I will try and see if it fixes it
08:22:55 <Alxandr> How do I solve ambigous occurence with prelude?
08:23:14 <Alxandr> I've made a monad (MonadFS) that has `readFile` function
08:23:47 <glguy> you can: import Prelude hiding (readFile); or you can import your module qualified
08:23:58 <glguy> import qualified AlxandrMonadFS as FS
08:24:15 <Alxandr> I like the prelude one better :)
08:24:20 <Alxandr> Didn't know you could hide things
08:25:06 <Alxandr> Thanks, that worked brilliantly :)
08:25:23 <Alxandr> I'm used to F# where the last imported thing takes precedence
08:25:36 <Alxandr> But being able to hide is also good
08:26:22 <glguy> That wouldn't be so good for all the people who want to alphabetize their imports!
08:28:10 <Alxandr> That's true, but in F# this is the case for all things (functions and variables too). So instead of alphabetizing you are forced to order your file based on usage
08:28:20 <Alxandr> And it can be argued whether or not that's a good thing
08:28:40 <Alxandr> But it makes it impossible to do accidental circular references at least
08:28:45 <dgpratt> it's an extremely annoying thing, in my experience
08:31:04 <lpaste> Alxandr pasted “Read PHI file” at http://lpaste.net/351348
08:31:06 <dgpratt> also, I feel like if you have accidentally created a circular reference, you are really in the weeds as it is
08:31:19 <Alxandr> I need some help fixing my function (link above)
08:31:33 <Alxandr> I'm doing mapM wrong
08:32:20 <Alxandr> I have a list of files, and I want to call a function that returns "Monad [FileContent]" on each of them and concat the arrays into one
08:36:24 <glguy> Alxandr: Minor note, lists like [FileContent] aren't arrays. You can name the [[FileContent]] result of the mapM... on line 6 and then return the concat of that
08:36:57 <Alxandr> Ah, yes. I'm just used to calling things in brackets for arrays :P
08:37:07 <Alxandr> I realized from the error myself that I just had to concat it
08:37:09 <Alxandr> Just now
08:37:21 <Alxandr> I just read the error wrong. I thought it gave me a single FileContent for some reason
08:37:49 <glguy> What can happen is you have a [[FileContent]] while a [FileContent] was expected
08:37:57 <glguy> so it unifies the outer list type
08:38:07 <glguy> and then objects to [FileContent] unifying with FileContent
08:38:45 <Alxandr> ?
08:40:47 <Rodenbach> Do Type Classes have to appear left of the constraint operator `=>` in type hints?  I’ve done  1) foo :: Integral n => n -> a -> [a]    and this worked.  Then I thought why not    2) foo :: Integral -> a -> [a]   but this errored.      But then    3) foo :: Int -> a -> [a]    worked again nicely.
08:40:54 <Rodenbach> Does it have to do with Integral being a Type Class?
08:41:42 <glguy> Yes, Integral is a type class, but it's not the type of numbers, so you can't have a value with type Integral
08:44:27 <nitrix> Hi, small question here.
08:45:31 <nitrix> If I'm running multiple forkOS threads but bounded, how does that work? Will it get migrated to a single thread?
08:46:07 <nitrix> The two concepts seems mutually exclusive to me, where forkOS is supposed to be a dedicated thread, which runInBoundThread is supposed to put the computation in a common thread to keep the local variables.
08:46:42 <glguy> forkOS forks a new bound thread
08:46:54 <glguy> runInBoundThread either forks a new thread unless you're already in a bound thread
08:47:11 <nitrix> I see.
08:47:31 <nitrix> So that was a misconception on my part then.
08:47:53 <glguy> In the case that runInBoundThread needed to forkOS, it will then block waiting for that bound thread to finish 
08:47:55 <nitrix> glguy: So nothing guarantees the bound threads all have access (read, share) the same local variables?
08:48:14 <glguy> All bound threads will be bound to *their own* threads
08:48:18 <glguy> They don't compete with each other
08:48:35 <glguy> or share thread-local state
08:48:40 <nitrix> Interesting. That makes it even more fascinating.
08:49:25 <nitrix> That means apparently for SDL2, I need bound threads for both event polling and rendering, but from my tests, they don't mutually need one another.
08:49:44 <nitrix> The event thread and the renderer thread seems fine isolated on their own. I'm surprised.
08:50:20 <nitrix> glguy: https://github.com/nitrix/lspace/blob/develop/src/Engine.hs#L96
08:58:21 <osa1> I'm looking for a package in stackage 7.14 that defines lenses for time package, does anyone know any?
08:58:57 <glguy> osa1: "time-lens" seems promising from an initial ^F -lens search
08:59:03 <glguy> see https://www.stackage.org/lts-7.14
08:59:29 <osa1> glguy: but that package defines its own lens type
08:59:52 <glguy> aww, lame
09:00:47 <glguy> timelens is just a couple entries down from that
09:01:01 <dolio> time-lens and timelens?
09:01:19 <glguy> Oh, it's time minus lens
09:01:32 <dolio> That's another thing to put in the list.
09:04:33 <dolio> Although, I wonder. If 'time-lens' and 'timelens' were to be considered conflicting package names, would 'time-lens' and 'tim-elens' conflict?
09:10:19 <lpaste> shayan_ pasted “split” at http://lpaste.net/351354
09:10:46 <shayan_> I am unsure on how to make this function split a list
09:10:50 <glguy> shayan_: 'length' isn't a number, so you can't div it
09:11:07 <glguy> splitAt also expects an argument
09:12:06 <shayan_> glguy: isn’t splitAt ([1,2,3,4,5,6] `div` 2), an argument?
09:12:20 <glguy> :t splitAt
09:12:22 <lambdabot> Int -> [a] -> ([a], [a])
09:12:48 <glguy> and you can't   [1..6]`div`2
09:13:59 <NextHendrix> any reason why ghci uses 1 terabyte virtual memory
09:15:27 <glguy> NextHendrix: http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system
09:15:33 <lpaste> shayan_ pasted “split” at http://lpaste.net/351355
09:15:51 <shayan_> It seems to work now, thank you. Is there a better practice way to write this code?
09:16:48 <glguy> shayan_: That way's fine. There's a clever solution that would allow your halve function to work on "infinite" lists.
09:18:10 <lpaste> glguy annotated “split” with “split (annotation)” at http://lpaste.net/351355#a351356
09:18:40 <lpaste> shayan_ pasted “split infinite ” at http://lpaste.net/351357
09:18:45 <glguy> url 
09:18:47 <shayan_> wanted to post it before looking at yours
09:19:10 <glguy> Well, try yours on ([0..] :: [Integer]) and see
09:19:38 <glguy> there's no clever way to  get the ssecond half of an infinite list
09:20:01 <shayan_> Wow, your code looks very advanced
09:20:40 <glguy> Which part?
09:20:58 <NextHendrix> glguy: nice one
09:21:07 <shayan_> xD
09:21:10 <shayan_> all of it
09:21:22 <NextHendrix> glguy: was a little worried to see this https://ptpb.pw/BSNf.png
09:21:47 <shayan_> oh wow
09:21:52 <shayan_> one day NextHendrix 
09:21:56 <shayan_> what are you working on?
09:22:08 <glguy> NextHendrix: Yeah, that number isn't generally useful
09:22:11 <shayan_> glguy: I’m just wrapping up chapter 4 in Programming in Haskell
09:22:49 <Rodenbach> In my .hs file I type-hinted   foo :: (Integral n, Ord n) => n -> [a] -> [a]     Now in ghci I load that file and look at   :t foo   and get only   foo :: Integral n => n -> [a] -> [a]      — where is my (Ord n) constraint gone?
09:22:58 <NextHendrix> shayan_: the from first principles book?
09:23:11 <NextHendrix> that scrolling text is just chromium compiling lol
09:23:22 <shayan_> NextHendrix: Graham Hutton (2edition)
09:23:23 <glguy> NextHendrix: The book is "Programming in Haskell (2nd ed.) by Graham Hutton", I think
09:23:35 <shayan_> yep
09:23:48 <glguy> Chapter 4 is "defining functions"
09:23:50 <NextHendrix> oh yeah i have the first edition of that
09:23:55 <NextHendrix> is he still using hugs
09:24:50 <glguy> No, the first section in chapter 2 is GHC
09:25:01 <NextHendrix> ah good, yeah the first edition is pretty dated
09:25:18 <shayan_> 2e just came out, 2016
09:26:39 <shayan_> glguy:  how can I test your code? 
09:26:58 <NextHendrix> the 'from first principles' book is really excellent
09:27:23 <NextHendrix> http://haskellbook.com
09:27:48 <shayan_> NextHendrix: I have it bookmarked. Will plan to read it after this one
09:27:54 <glguy> shayan_: You could put it into a file and load that in GHCi, or you could paste the lines I typed into GHCi into yours
09:30:29 <shayan_> glguy: damnit… econ class starts in 30min. i have to leave unfortunately. i saved your code, will do it right when i get back 
09:30:53 <johnw> has anyone ever connected servant with fuse, so that I can browse my REST API as a filesystem, where each time I access a "file" it performs the request -- using the path for the request arguments -- and the answer is presented as the contents?
09:37:05 <jdnavarro> ls
09:51:39 <Rodenbach> Are Integrals implicitly also Ords? I type-hinted a function with the constraint (Integral n, Ord n), but after loading it I see it only has the constraint (Integral n). The Ord is gone.  If I use Num instead of Integral then after loading both are there.
09:54:15 <davean> Rodenbach: https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Integral
09:54:19 <davean> Rodenbach: class (Real a, Enum a) => Integral a where
09:54:26 <davean> Rodenbach: class (Num a, Ord a) => Real a where
09:59:22 <Sonolin> is there a function that does catMaybes but returning empty list if there's a Nothing?
10:00:46 <gamegoblin> Sonolin: so you want a function that returns [] if any are Nothing, and [a] if all are Just?
10:01:56 <kadoban> :t fromMaybe [] . sequence  -- that essentially?
10:01:58 <lambdabot> [Maybe t] -> [t]
10:02:12 <gamegoblin> kadoban: exacty what I was going to say
10:02:38 <gamegoblin> > fromMaybe [] (sequence [Just 1, Just 3, Just 2])
10:02:42 <lambdabot>  [1,3,2]
10:02:47 <libscott> is it possible to implement >>= in terms of <$>? or <*> in terms of fmap? for a monad do i really need to do all 3 separately?
10:02:51 <gamegoblin> fromMaybe [] (sequence [Just 1, Nothing, Just 2])
10:02:52 <libscott> is it possible to implement >>= in terms of <$>? or <*> in terms of fmap? for a monad instance do i really need to do all 3 separately?
10:03:01 <johnw> libscott: try it :)
10:03:03 <libscott> ^^ oops too much slack
10:03:33 <libscott> johnw: I am trying it! >>= in terms of fmap doesnt seem to work.
10:03:50 <kadoban> libscott: (<$>) isn't powerful enough to be used on its own to implement (>>=)   same with (<*>) and fmap. You can do it the other way around though, you can implement Monad and use that to implement Applicative and Functor
10:04:29 <libscott> kadoban: that makes sense, but if Applicative is a superclass of Monad, isn't that doing things backwards?
10:05:05 <libscott> I suppose if the compiler can see you have a Monad instance you can use it anywhere..
10:05:12 <kadoban> It depends what you consider backwards/forwards. But haskell/GHC won't care if that's what you're asking.
10:05:17 <gamegoblin> libscott: If you go to hackage and read the comments around the Monad, Applicative, and Functor typeclass, they say some things about how they can be implemented
10:05:31 <libscott> gamegoblin: excellent, should have thought of that
10:05:38 <gamegoblin> libscott: e.g. "Furthermore, the Monad and Applicative operations should relate as follows: pure = return; (<*>) = ap "
10:05:45 <gamegoblin> libscott: https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Monad
10:06:27 <libscott> thanks gamegoblin 
10:07:21 <geekosaur> libscott, it's not really a "superclass" so there is no real notion of backwards/forwards
10:08:22 <glguy> libscott: The minimum work is: fmap = liftM; (<*>) = ap; pure = <actual implementation>; (>>=) = <actual implementation>
10:08:24 <geekosaur> (documentation does call it that, but typeclasses are not OOP, they're sugar for records of functions --- so as long as everything hooks up, it's fine)
10:08:39 <Rembane> libscott: They can on the other hand be ordered in terms of power. Like this: Monad > Applicative > Functor.
10:09:51 <Sonolin> thanks kabodan
10:09:53 <Sonolin> perfect
10:11:07 <libscott> I see
10:14:52 <Gloomy> Hi :-) What http library would you suggest for making a parser that needs to support proxies and https? 
10:15:13 <Gloomy> The basic Network.HTTP module doesn't seem to support https
10:17:24 <Rembane> Gloomy: Client or Server?
10:17:44 <Gloomy> Client, and I meant scraper, not parser
10:18:19 <Rembane> Gloomy: I have used http-client and it has worked well for me: https://hackage.haskell.org/package/http-client
10:19:28 <Gloomy> Thanks, will check that out
10:19:44 <Rembane> No worries. Good luck!
10:46:08 <mmaruseacph2> is there a way to tell tasty-discover to ignore a test?
10:46:29 <mmaruseacph2> beside changing the name of the test so it doesn't start with the prefixes tasty-discover knows
10:59:28 <aravart> Is it sane to write monadic functions recursively like this... filterSuccessors :: (Random b, Ord b) => (a -> b) -> [a] -> State StdGen [a]
10:59:29 <aravart> filterSuccessors f (x:xs) = do
10:59:29 <aravart>   g <- get
10:59:29 <aravart>   let (c',g') = random g
10:59:32 <aravart>   let keep = c' < f x
10:59:35 <aravart>   put g'
10:59:38 <aravart>   tail <- filterSuccessors f xs
10:59:41 <aravart>   return (if keep then x : tail else tail)
10:59:45 <aravart>  
11:01:16 <pikajude> is that spam
11:01:40 <johnw> it's very topical spam, isn't it
11:01:47 <Xyliton> well, he could've uploaded his code to lpaste.net ...
11:01:54 <pikajude> but a k-line?
11:02:20 <kadoban> Apparently tripped some switch in Sigyn. Can't imagine that was the best outcome, but ... bots be bots.
11:02:51 <geekosaur> sigyn may be a bit hair-trigger again. could bring it up in #freenode
11:03:33 <geekosaur> also that is a kill not a k-line (which is autokill-on-connect)
11:04:07 <kadoban> Hmm, I didn't know there was a difference. Is there a different message for k-line?
11:04:30 <pikajude> probably not since they'd never get into a channel
11:04:43 <geekosaur> yes, "K-Lined"
11:04:51 <geekosaur> and you will see it when the line is applied
11:04:56 <kadoban> Ah :)
11:05:01 <geekosaur> "Killed" just means their current connection but they can reconnect
11:05:17 <haskell873> Hi, what would be a good begineer haskell project?
11:05:43 <maerwald> write a parser for the SQL standard
11:05:51 <SexHendrix> haskell873: brainfuck compiler
11:05:56 <SexHendrix> *interpreter
11:06:26 <SexHendrix> hangman
11:06:30 <SexHendrix> noughts and crosses
11:06:46 <SexHendrix> morse code translater
11:06:50 <SexHendrix> *translatoe
11:06:51 <codedmart> I am working with an api. What types would these be in Haskell? Api docs `date` sample data `"2017-01-17"`, and api docs `time` sample data `"18:16:41"`? 
11:06:52 <Sornaensis> haskell873: wiki books: write yourself a scheme in 48 hours
11:06:55 <SexHendrix> harumph
11:07:49 <haskell873> I think I'll go for the brainfuck interpreter thanks!
11:13:37 <codedmart> Nevermind I see what is happening.
11:20:18 <athan> how do I compile ghc if ./get-all sync won't get all the libs? :(
11:20:47 <geekosaur> athan, probably that's a #ghc question
11:21:53 <athan> good idea, thanks geekosaur 
11:27:53 * shapr hops cheerfully
11:27:59 <LSorceress> Yo
11:28:05 <shapr> oh hai LSorceress, how's code?
11:28:31 <LSorceress> pretty good, thanks ! 
11:31:52 <Hijiri> no
11:31:56 <Hijiri> wait
11:31:59 <Hijiri> I'm scrolled up
11:32:12 <kyle1320> New(ish) to Haskell, I need to split a list at the first instance of a particular constructor. I could write my own function to do so, but I was wondering if there is a way to do so using break or another similar function.
11:32:49 <Gurkenglas> break f where f (Constructor _) = True; f _ = False
11:33:08 <benjwadams> How to read XSDs without wanting to gnaw your arm off?
11:33:27 <kyle1320> Of course. Thank you.
11:33:37 <benjwadams> ack.  Wrong channel
11:33:49 <Gurkenglas> Or, using lambdacase, break (\case (Constructor _) -> True; _ -> False) for less naming
11:34:33 <johnw> or, using lens and generating record lenses, break (has Constructor)...
11:34:49 <johnw> (not record lenses, prisms)
11:34:56 <Gurkenglas> *_Constructor
11:35:09 <johnw> depends how you generate them, but sure
11:35:32 <johnw> I think the default is _Constructor
11:36:16 <ph88> how can i make this code https://paste.fedoraproject.org/529103/46816441/ so that i can at line 20 i can have two functions instead, one for the specific case of when it needs to yield an Arbitrary and one for the case of Parser  ?
11:37:01 <glguy> For pattern matching on the constructor itself without any of the fields, Constructor{} works (whether or not it's otherwise a record)
11:39:42 <Zemyla> Hmm, it occurs to me that showListWith could be made a good consumer.
11:41:29 <LSorceress> ertes : I managed to do what I wanted to do
11:42:05 <LSorceress> using Rasterific to draw text and then converting the image to the gloss picture format. But it was already written for me, I used gloss-juicy.
11:42:09 <glguy> Zemyla: What kind of consume is it now?
11:42:16 <glguy> consumer*
11:42:28 <Zemyla> :t \sh l s -> foldr (\a r c _ -> c $ sh a $ r (',':) (']':s)) (const id) l ('[':) ('[':']':s)
11:42:29 <lambdabot> Foldable t => (t1 -> [Char] -> [Char]) -> t t1 -> [Char] -> [Char]
11:42:33 <LSorceress> anyway now I can draw text in gloss using any ttf font. I'm happy !
11:42:57 <Zemyla> glguy: It uses explicit pattern matching instead of a fold, so it doesn't stream well.
11:43:32 <glguy> It streams, do you mean that it doesn't fuse?
11:43:42 <Zemyla> Yeah, that's what I meant.
11:44:02 <glguy> I see
11:44:24 <Zemyla> Of course, almost no showsPrec instance produces a good fusible String, either. :V
11:50:27 <Zemyla> @let showListW :: (a -> ShowS) -> [a] -> ShowS; showListW sh l = foldr (\a r c _ -> c $ sh a $ r (',':) (']':s)) (const id) l ('[':) ('[':']':s)
11:50:30 <lambdabot>  .L.hs:183:5: error:
11:50:30 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘String -> String’
11:50:30 <lambdabot>        Expected type: ShowS
11:50:42 <Zemyla> @let showListW :: (a -> ShowS) -> [a] -> ShowS; showListW sh l = \s -> foldr (\a r c _ -> c $ sh a $ r (',':) (']':s)) (const id) l ('[':) ('[':']':s)
11:50:45 <lambdabot>  Defined.
11:51:30 <Zemyla> > fmap (\l -> take 10 $ showListW shows l "") [[], [0], [0, 1], [0..]]
11:51:33 <lambdabot>  ["[]","[0]","[0,1]","[0,1,2,3,4"]
11:52:04 <Zemyla> See, it even does the right thing to infinite lists.
11:54:10 <machinedgod> hi everyone. I have a question regarding two extensions, DeriveAnyClass and DefaultSignatures
11:55:33 <machinedgod> I was under the impression that DeriveAnyClass would create just an empty 'instance' declaration, so that default signature (if exists) would be used. I have a data with a function member, and compiler complains not to be able to find a class instance for that member
11:56:09 <machinedgod> Does this mean that, in order to use DeriveAnyClass, every data member has to be deriveable with the same class as well?
11:56:31 <glguy> machinedgod: Perhaps paste the code and the error message to http://lpaste.net
11:56:54 <machinedgod> glguy: Okay, sorry, should've thought of it myself :-) one minute
11:57:44 <ertes> LSorceress: great =)
12:00:15 <machinedgod> glguy: Here it is: http://lpaste.net/351358
12:01:59 <machinedgod> glguy: if I remove DeriveAnyClass and instead of 'deriving (Named)' I simply write 'instance Named Interactible' it works just as I'd like
12:04:15 <glguy> machinedgod: I'd have expected that to work, too
12:04:31 <machinedgod> Me too, at least according to the GHC user guide :-\
12:04:40 <Zemyla>  Is there a library for an in-memory relational database that can be created and updated in ST, then queried in pure code?
12:04:41 <glguy> machinedgod: What's your instance of StatProvider look like for this type?
12:05:26 <machinedgod> glguy: http://lpaste.net/351359
12:05:49 <machinedgod> glguy: wait, I'll throw in resolve* function too:
12:05:52 <Layl> I've got different code that has to be executed for different strings, these strings are defined at runtime, is the best solution just a hashmap (running on haste-compiler)
12:06:06 <Layl> hashmap with functions-as-values I mean
12:07:31 <machinedgod> glguy: http://lpaste.net/351360
12:08:26 <lpaste> glguy annotated “No title” with “smaller case of machinedgod 's issue” at http://lpaste.net/351359#a351361
12:09:38 <ertes> Zemyla: i don't know of a mutable one, but ixset is that in pure form
12:10:40 <machinedgod> glguy: So, according to your annotation vs. GHC user guide - the problem is in using record syntax, then?
12:11:02 <glguy> machinedgod: removing the record syntax doesn't help
12:11:37 <ertes> Zemyla: it's basically like Seq (or Set if you choose so), but with multiple custom indices
12:11:58 <machinedgod> glguy: Huh. Did not expect that. Well, when can DeriveAnyClass be legally used then?
12:13:57 <ertes> Zemyla: (you could also use an in-memory sqlite database, of course)
12:14:44 <glguy> machinedgod: It's looks like it's known to be broken  https://ghc.haskell.org/trac/ghc/ticket/12594
12:15:17 <machinedgod> glguy: Oh. Damn, another thing I should've checked. Sorry on wasting your time mate... :-\
12:28:46 <wuschel> Hi! :^) Could anyone give me a rough idea how much "overhead" one has build small to medium sized programs in Haskell when compared to simpler languages like Python or Scheme? Also, how does Haskell compare to Rust with its manual memory management? I understand that Haskell is not suited for all problems / one needs to jump to a recursive circus in order to adopt Haskell to problems outside its field of strength, while Rust gives 
12:28:53 <wuschel> comes to managing memory manually.
12:29:59 <wuschel> Thanks for a random comment or two. Just looking at Rust/Haskell and wondering where I should put my time into, considering the fact that it seems to take ages to learn Haskell properly and change your way of thinking.
12:31:02 <Rembane> wuschel: What are you going to program? What kind of programs?
12:33:06 <maerwald> wuschel: I wrote a file manager in haskell (basic functionality only) and I regret it. I'd probably redo it in rust (if the standard lib didn't suck so hard) if I ever feel like making it a serious thing
12:33:10 <maerwald> so really depends
12:33:17 <wuschel> In general, I am trying to enlarge my spectrum of languages (currently Python and a bit of Scheme). I would like to be able to use a language that is statically typed, fast, and gives me the ability to do anything.
12:33:27 <shapr> wuschel: in my experience, being able to change your way of thinking gives you more tools for programming. I prefer learning languages that require me to change my way of thinking.
12:34:07 <wuschel> I see.
12:34:37 <wuschel> Which means that Haskell would be a conceptional enrichment of your capabilities as a programmer (& more perhaps)?
12:34:45 <shapr> wuschel: what about giving each of Haskell and Rust a week. Jump into their communities and see how it goes?
12:35:04 <shapr> wuschel: I do believe that Haskell is a conceptional enrichment, yes.
12:35:09 <maerwald> I don't think haskell improves your C skills a lot. I was very picky about documenting "side effects" in C long before I came to haskell.
12:35:27 <maerwald> so I usually disagree with people saying that it "makes you a better programmer" per se, because it depends
12:35:28 <shapr> conceptual?
12:35:35 <shapr> maerwald: What do you think it depends on?
12:36:03 <Hermit> wuschel: and a painful experience, specially if you have deadlines
12:36:09 <maerwald> haskell can improve your scala skillz, although scala sucks... but then you know how "it should have been"
12:36:11 <wuschel> maerwald: I don't even know C. That is why I am hesitating. 
12:36:13 <ph88> how can i make it so that an instance of a typeclass doesn't use the function defined in the class but uses it's own function?
12:37:07 <maerwald> I said that before... if you want to improve your "programming skills" in general: do algorithms, problem solving, study techniques about improve quality, safety, security, maintainability etc
12:37:24 <wuschel> And from the looks of some answers on Stackoverflow, it takes a long time to be knowledgeable in the constructs that are used in Haskell to tacke many a type of problem.
12:37:25 <Hermit> ph88: just define it in the instance
12:37:39 <ph88> i don't see how i can start using typeclasses and then start to specialize again .. everything stays generic :/
12:37:53 <shapr> wuschel: I'm a fan of http://haskellbook.com/ for learning Haskell
12:38:12 <maerwald> a programmer who can write 10 languages, but has little knowledge about the security field, isn't a very good programmer
12:38:54 <wuschel> shapr: I think I take your advice and try both :) And thanks for the hint re security, maintainability, etc. :)
12:39:06 <wuschel> > maerwald ^
12:39:08 <lambdabot>  <hint>:1:11: error:
12:39:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:39:11 <shapr> wuschel: I look forward to hearing how it goes!
12:39:17 <wuschel> Merci! +1
12:39:27 <wuschel> Will do.
12:39:32 <dolio> I suspect it takes a while to be knowledgable about all the stuff in Rust, too.
12:39:34 <sm> wuschel: what kind of overhead ? Do you mean how much ceremony & boilerplate etc. for a typical haskell developer to build something new ?
12:39:42 <wuschel> sm: yes!
12:39:51 <shapr> dolio: that has been my experience
12:40:01 <sm> I think it's not bad at all, and improving by the year
12:40:03 <wuschel> Knowing e.g. some Randomoid.
12:40:15 <maerwald> doing rust without knowing C sounds a bit odd though
12:40:36 <maerwald> because for the most part, you won't really "get" why they did things the way they do
12:41:09 <wuschel> I thought that already. Guess I will read a bit of C, then look into Rust/Haskell as an excursion. 
12:41:11 <wuschel> :)
12:41:14 <shapr> I'm not convinced you must know C in order to understand constraints of the hardware
12:41:16 <maerwald> for me, at least, that would be confusing... I refuse to learn things I can't really understand the motivation behind
12:41:34 <shapr> Hm, I'm the opposite. I learn things so I can understand the motivation.
12:41:45 <wuschel> lol
12:42:02 <wuschel> Guess we have the reason why there are so many different programming languages..
12:42:38 <maerwald> shapr: uhm, that's not really what I said, but you can take the sentence literally if you really must
12:42:46 <eschnett> learning C to understand hardware doesn’t really work any more; hardware now is very different from the 80s.
12:42:58 <eschnett> you could learn C and OpenMP instead; that might work.
12:42:59 <shapr> maerwald: oh, what did I misunderstand?
12:43:05 <shapr> and of course I have to go afk now...
12:44:18 <wuschel> eschnett: But at least learning a primitive set of tools before understanding the advantages of the more advanced tool. I guess for hardware one still should look at a primitive processor and its instruction set. 
12:45:06 <wuschel> Anyway, thanks for the Haskell book reference. I will check it out! :)
12:45:07 <maerwald> shapr: I was implying that I learn something that gives me the understanding of the motivation... which, in this case, is the failure and the problems that came before (as in: C)
12:45:14 <ertes> learning C to understand anything doesn't really work
12:45:17 <eschnett> wuschel: the argument about the “more primitive tool” is dangerous, since there is always a “more primitive tool”. for example, you could learn assembler language to understand the motivation for C
12:45:38 <wuschel> sschnett: I see. 
12:45:39 <ertes> except perhaps the linux kernel and half of the outdated mess that is POSIX
12:45:47 <maerwald> eschnett: exactly, and that's very straight forward and enlightening
12:45:56 <maerwald> start with machine code
12:46:00 <maerwald> and see why you can't do it
12:46:00 <wuschel> ertes: because c := "punk rock"
12:46:02 <wuschel> ;
12:46:15 <Xyliton> how do I use "IO String"s for the interpolation in shakespeare?
12:46:47 <ertes> i feel like python is more like punk rock…  it's terrible, yet everybody loves it
12:46:59 <maerwald> in maths, it's even worse... most courses don't teach anything about failed attempts/axioms etc. but just dump the result in front of your feet
12:47:05 <ph88> if i have a decorator typeclass and i want to specialize an instance of the underlying class with the decorator class should i use multi param type classes ?
12:47:11 * raichoo does not like punk rock…
12:47:26 * danza likes some punk rock
12:49:19 <maerwald> C is heavy metal: loud, painful and with a raw beauty... but still annoying
12:49:34 <geekosaur> "industrial"
12:49:37 <ertes> that's C++
12:49:40 <ertes> C is more like grindcore
12:49:44 <maerwald> C++ has no beauty :P
12:49:55 <wuschel> What is Haskell? 
12:50:00 <wuschel> Lisp would be Jazz, then?
12:50:04 <geekosaur> C++ is industrial rock as imagined by Rube Goldberg
12:50:15 <ertes> yeah, lisp as jazz fits well =)
12:50:21 <maerwald> haskell is prog metal... very technical, but can be utterly annoying too if people overdo it
12:50:22 <ertes> haskell is probably like classical music
12:50:28 <Rembane> Math metal!
12:50:32 <wuschel> omg.
12:50:39 <glguy> And #haskell is for questions about Haskell programming!
12:50:45 <wuschel> Ups. 
12:50:46 <geekosaur> and agda is baroque?
12:50:50 <johnw> glguy++
12:51:11 <wuschel> Again, thanks for the replies. 
12:51:14 <Nycatelos> C is punk rock tbh
12:51:30 <maerwald> there's probably -offtopic to continue the metaphor discussion
13:09:10 <DexterLB> is there something like until, but inside a monad? e.g. muntil :: Monad m => (a -> Bool) -> (a -> m a) -> m a
13:12:26 <geekosaur> maybe in monad-loops?
13:14:46 <ph88> glguy, could you take a look at this code please? i'm trying to use your decorator pattern but at some instances i want to specialize it on the type it's suppose to yield https://paste.fedoraproject.org/529145/14846876/
13:25:02 <glguy> ph88: If you need more operations that can vary based on types that implement your 'Decorator' class, you'll have to add more methods to that class
13:25:29 <glguy> you don't get to provide custom instances of 'get' for different types like 'Parser' or 'Arbitrary'
13:28:52 <glguy> perhaps you could add an extra   'aget :: Arbitrary a; aget = get' to your 'Rule' class
13:29:57 <glguy> You'll just need to make sure to use 'aget' when you want the arbitrary case so you get the custom behavior
13:31:41 <glguy> though that second version probably will make it easy for implementations to lose track of being the in special case...
13:31:55 <glguy> first option is better
13:38:27 <ph88> glguy, what are you calling the first and second option ?
13:38:58 <glguy> first option: add more methods to 'Decorator' that characterize how the implementations should vary
13:39:16 <glguy> You don't get to assume that Parser and Abitrary are the only two cases
13:40:19 <ph88> glguy, what did you mean for the second option ?
13:40:29 <glguy> It's not really an option
13:40:32 <ph88> oh ok :P
13:40:38 <ph88> glguy, how do i make my class so that i'm not obliged to implement get if i provide aget (arbitrary) and pget (parser)  ?
13:41:14 <ph88> or should i then write   get = undefined    in my instance ?
13:41:17 <glguy> that's a different design, it doesn't fit what you have here
13:41:40 <ph88> what do you mean different design ?
13:41:56 <glguy> You'll need different classes for that to work than these
13:42:15 <ph88> what kind of classes ?
13:42:20 <glguy> dunno
13:42:27 <ph88> oh
13:43:04 <glguy> Maybe something with a multi parameter type class for Rule
13:44:50 <ph88> ah ye i was also considering multi param type classes .. i saw them before but never implemented
13:50:12 <ph88> is it possible to have a partial instance with multi param type classes?  like  instance Foo Bar a where ..   but then for Baz have   instance Foo Baz Qux where ..    ?
13:50:26 <ph88> eh partial is not the right word here i guess ^^
13:52:18 <glguy> yeah, you could have: instance Rule Arbitrary Terminal,   and instance Rule f Library
13:52:48 <ph88> oh excellent !
13:52:54 <ph88> let me try that
13:58:00 <ph88> glguy, any idea what this is about? https://paste.fedoraproject.org/529159/69023814/ maybe i need some parenthesis ?
13:58:23 <glguy> ph88: Arbitrary is the wrong type for this, you need 'Get'
13:58:36 <glguy> Arbitrary is the constraint for things that support 'Get'
13:58:43 <ph88> Get or Gen ?
13:58:49 <glguy> Oh, perhaps Gen, then
14:08:10 <zipper> TIL: fns get a free mappend instance if the results have a mappned instance!
14:08:42 <ph88> glguy, something doesn't seem quite right yet  https://paste.fedoraproject.org/529165/48469087/  i think it broke type inference somehow
14:09:12 <glguy> ph88: instance Rule f LibraryUnit => Rule f DesignUnit
14:11:41 <ph88> glguy, seems i have to enable quite a few extensions for this https://paste.fedoraproject.org/529168/48469106/  but this last extensions is making me nervous
14:12:01 <glguy> Those are fine for this
14:13:03 <ph88> i was also reading upon this  https://wiki.haskell.org/Functional_dependencies  maybe i can tell it this way as well ?
14:13:26 <glguy> I don't think fundeps help you here
14:13:47 <ph88> ok
14:13:59 <ph88> what is this actually in english?   instance Rule f LibraryUnit => Rule f DesignUnit
14:15:03 <glguy> It defines an instance of Rule for all types 'f' and 'DesignUnit', and when you use this instance you'll also have to show that there's an instance of 'Rule f LibraryUnit'
14:16:54 <ph88> interesting ^^, i'll make note
14:17:57 <glguy> similarly there's an: instance Show a => Show [a]. You can turn a [a] into a String, but if you do that you'll also have to show that you can turn 'a' into String
14:18:00 <ph88> these are some very powerful abstractions i see :)
14:18:31 <ph88> why is it not infered that you have to show that you can turn a into a string ?
14:20:03 <geekosaur> because someone could write a vacuous instance like the Show instance for functions in Text.Show.Functions
14:20:37 <ph88> i mean why is the constraint itself not infered
14:21:01 <glguy> That syntax is how you declare what constraints should be considered
14:21:18 <glguy> it's similar to how when you write a type signature that it doesn't infer extra information
14:21:27 <glguy> It checks that what you wrote is sufficient
14:28:08 <patientpl> hi
14:29:04 <lambdabot> Hello.
14:29:17 * hodapp looks at lambdabot
14:29:31 * ChaiTRex glares at lambdabot.
14:30:04 <patientpl> hi
14:30:06 <patientpl> so 
14:30:13 <patientpl> what is the best use case for haskell generally
14:30:29 <patientpl> im looking at a meetup that will teach beginning haskell and want to see if it would be a good use of my time
14:30:37 <SegFaultAX> patientpl: Writing software. :)
14:30:42 <patientpl> gtfo
14:30:45 <patientpl> :D
14:30:49 <patientpl> no but really...
14:30:51 <patientpl> gtfo
14:31:12 <patientpl> big data, web based applications, micro controllers
14:31:25 <SegFaultAX> patientpl: Well that's not very nice. But Haskell is a general purpose programming language. It's useful in the same places you'd use other general purpose programming languages.
14:31:37 <SexHendrix> toy compilers
14:31:54 <epta> is there any shortcut for StateT . const?
14:31:58 <SegFaultAX> patientpl: But it's especially well suited to areas where correctness is of greater importance.
14:32:01 <patientpl> interesting
14:32:10 <patientpl> so robots and lower level stuff
14:32:22 <patientpl> like microcontrollers and such?
14:32:55 <SegFaultAX> patientpl: Actually I'd say embedded systems probably aren't a strong area for Haskell. But I'd love to hear why I'm wrong about that.
14:35:04 <jackhill> SegFaultAX, patientpl: but for those things there are EDSLs: http://hackage.haskell.org/package/atom “Atom is a Haskell EDSL for designing hard realtime embedded software”
14:35:07 <hodapp> SegFaultAX: go ask in #haskellembedded for a more thorough answer on that :P
14:35:17 <uiop> patientpl: the only real way you could use haskell for embedded systems is if you're using haskell to generate some other lower-level language
14:35:24 <exio4> http://dpaste.com/04TS9XW I don't really know how to solve this dependency issue, my stack.yaml is in the paste too BTW
14:35:58 <hodapp> uiop: Haskell is pretty much always used to generate some other lower-level language :P
14:35:59 <exio4> any ideas? using GHCJS even though I don't think that should matter much
14:36:03 <SegFaultAX> hodapp: Sure. My intuition (which is probably incorrect) is that Haskell's non-strict evaluation and general immutability makes working in a super resource-constrained environment really hard.
14:36:50 <uiop> your intuition is correct SegFaultAX
14:37:10 <uiop> SegFaultAX: that's why you cheat and use it to gen code for such an environment
14:37:36 <SegFaultAX> jackhill: That's really awesome, thanks for the link.
14:37:39 <hodapp> uiop: it's *always* generating code in some fashion. The question is just what's generating code, and for what.
14:37:40 <SegFaultAX> uiop: Indeed!
14:37:40 <uiop> hodapp: true, squinting hard enough you could almost call all haskell that
14:37:59 <hodapp> uiop: Call it what?
14:38:08 <ChaiTRex> patientpl: See also https://stackoverflow.com/questions/1604790/what-is-haskell-actually-useful-for
14:38:11 <jackhill> SegFaultAX: :) it's an example of what uiop describes
14:38:13 <uiop> "generating a lower-level language"
14:38:28 <uiop> @hodsapp
14:38:28 <lambdabot> Unknown command, try @list
14:38:29 <hodapp> uiop: the point is that compilation isn't magically something else
14:38:47 <exio4> is there any pgp implementation which can be used in ghcjs?
14:39:11 <exio4> I tried hOpenPGP but it didn't finish compiling, some "linker error" IIRC
14:39:32 <hodapp> uiop: it happens that in Haskell, you're already in the practice of writing things declaratively, and so all sorts of other forms of compilation - which don't necessarily involve a runtime that is coupled to what GHC produces - end up the same in most regards
14:39:54 <SegFaultAX> patientpl: Also, the Haskell Book (http://haskellbook.com/) is really good (whether you're a beginning programmer or well versed in many other languages)
14:39:57 <hodapp> with the only real difference being that (1) there might be a few extra steps in compilation and (2) you might be creating a value of some other type than IO ()
14:41:25 <patientpl> ok 
14:41:29 <patientpl> dumb question
14:41:41 <uiop> hodapp: yes, exactly. and in those cases where you're using haskell to ultimately achieve code that runs within a severely constrained environment or that must operate under constrained requirements, you are more often than not "compiling" some representation to a lower-level code which is handed of to that language's respective compiler
14:42:00 <patientpl> what is a good eli5 example of a difference in code between a functional and object oriented program
14:42:06 <uiop> and doing so you play to both haskell's strengths as well as the generated languages strengths
14:42:11 <uiop> and avoid the weaknesses of both
14:42:30 <patientpl> i think i understand the higher level explanations, but im having trouble picturing the code in my head
14:42:36 <SegFaultAX> patientpl: Ah, the age old question (and flame war fuel) :)
14:43:27 <hodapp> uiop: https://haskellembedded.github.io/posts/2015-10-09-compiler-compilers.html is what I wrote awhile back trying to explain how, in working with Ivory for around a year, there was almost no apparent difference in writing code for Ivory, and writing it for "normal" Haskell
14:43:40 <SegFaultAX> patientpl: An overly simplistic defintion is that functional programming favors functions and data as modeled by the lambda calculus, rather than encapsulation and message passing as modeled by many forms of OOP.
14:43:44 * uiop checks out Ivory
14:43:56 <Rembane> hodapp: Is Ivory an EDSL?
14:43:59 <hodapp> Rembane: yes
14:44:04 <Rembane> hodapp: Cool
14:44:48 <uiop> hodapp: ive been out of the haskell loop for a few years, so im not up to date with the newest libraries/projects
14:44:49 <hodapp> SegFaultAX: so, if you're actually trying to target main :: IO () to a microcontroller, yes, that brings with it all sorts of issues
14:44:53 <uiop> hodapp: looking forward to checking it out
14:45:42 <hodapp> SegFaultAX: and http://www.metasepi.org/doc/metasepi-icfp2014.pdf gives some actual examples of someone doing it in Ajhc
14:45:48 <SegFaultAX> patientpl: But it's hard to be much more specific in your comparison than that without picking 2 particular languages (eg Haskell vs. Java) and contrasting them directly. Many langauges today implement aspects of both styles.
14:46:01 <SegFaultAX> hodapp: Thank you!
14:46:47 <SegFaultAX> hodapp: Haskell for embedded systems is a fairly foreign concept to me, though I'm very interested to learn more. :)
14:47:12 <hodapp> SegFaultAX: yeah, there's always #haskellembedded; I don't want to derail you from answering less-embedded questions
14:47:50 <uiop> hodapp: is #haskellembedded the correct spelling?
14:48:01 <uiop> just joined and it's me and one other guy that just joined from here
14:48:01 <hodapp> crap. #haskell-embedded
14:48:05 <uiop> thx
14:49:18 <hodapp> patientpl: Code is just going to be tough to picture in your head unless you've worked with the language a bit. That's one thing I've found.
14:49:36 <hodapp> you can look at the syntax but you're often not going to have a good intuitive idea how it fits together
14:50:36 <SegFaultAX> patientpl: I'll add that Haskell in particular favors the things I mentioned, and goes quite a bit beyond that through its type system. Static types aren't necessarily required for functional programming as such (though many of the more popular functional languages are statically typed)
14:51:42 <patientpl> hmm
14:52:06 <patientpl> i found this link useful as well: http://www.codenewbie.org/blogs/object-oriented-programming-vs-functional-programming
14:57:00 <Cale> patientpl: One of the main things which I think characterises functional programming -- at least what we'd now call functional programming -- is the usage of so called algebraic data types, and pattern matching in defining functions on data.
14:57:29 <Cale> patientpl: Even though this doesn't really have anything to do with functions being first class values
14:57:37 <exio4> Nettle on GHCJS (which is a hOpenPGP dependency) fails to compile with http://dpaste.com/1QRD7FN
14:57:42 <exio4> running out of ideas :/
14:58:02 <Cale> patientpl: So, for example, in Haskell, we can define a type for binary trees like:
14:58:14 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
14:58:38 <Cale> which says that every Tree of values of type a is either the empty tree Tip
14:59:01 <Cale> or is something of the form Branch x l r, where x is a value of type a, and l, r are trees of values of type a
14:59:05 <Cale> (the left and right subtree)
14:59:26 <Cale> So, if we want to write a function on trees of this sort, we can pattern match:
14:59:30 <Cale> depth Tip = 0
14:59:43 <Cale> depth (Branch x l r) = 1 + max (depth l) (depth r)
15:00:43 <Cale> Here, depth is defined separately for the case where its argument is Tip and the case where its argument is a Branch node, and in the Branch node case, the variables x, l, and r are bound to the value on that node, and the left and right subtree, respectively
15:03:17 <Cale> patientpl: Does that help at all? :)
15:03:46 <Cale> patientpl: I don't know if you've seen such a program written in a non-functional style as well, but I'd be less happy to have to write that out for you in the channel ;)
15:09:39 <patientpl> Cale that looks strange to me, because the way that you're writing a is that it looks like you're defining the "object" of a - that is that it can take the form of left, right, or leaf. But i thought that this was functional programming and so a cannot be an object?
15:11:01 <geekosaur> there are significant differences
15:12:02 <patientpl> but is "data Tree a =" assigning a different properties which you then define later. Not to disagree, im just trying to understand what Cale wrote.
15:12:50 <patientpl> so you assign these properties, assign values to the properties afterwards, and the program knows through inheritence/recursion that those values modify the properties you previously assigned
15:12:52 <patientpl> ?
15:13:16 <geekosaur> the big difference is that, in an OO system, Tip and Branch would be valid "types"; here, they are just different constructors
15:14:29 <patientpl> sorry geekosaur eli5?
15:15:09 <geekosaur> mm, different implementations of new() with different parameters in c++/java parlance
15:15:59 <geekosaur> I'm trying to do too many things at once :(
15:16:02 <patientpl> hmm
15:16:21 <patientpl> its raining here and i have to bike to a thing soon and i dont have a raincoat
15:16:24 <patientpl> very sad panda
15:20:20 <geekosaur> if I knew what languages you are familiar with, I (or others since I've got too many pots on the stove atm) could do better
15:23:33 <patientpl> eh its ok - ive generated enough interest for myself that I'm going to go to this meetup just to learn the basics of haskell. it might be a useful thing to have in my toolbox one day
15:26:11 <mankyKitty> any stack users... is it possible to add another repo of templates for use with stack new? As opposed to specifying the file every time..
15:27:39 <kadoban> mankyKitty: You can specify a default template in your config, including as a local file somewhere, if that helps.
15:27:43 <Unode> mankyKitty: I think there's something you can put on stackrc for that
15:28:03 <kadoban> You can't yet specify a different repo I don't think.
15:28:21 <mankyKitty> hrmm okey dokey. thanks kadoban Unode 
15:32:56 <ij> Is moving from String to Text very hard? I don't have endless strings.
15:34:28 <Taneb> ij, shouldn't be
15:34:41 <RandoCoder> In general, no.
15:34:43 <ij> irc-client uses only Text and I'm tired of unpacking.
15:34:44 <Taneb> ij, unless you're using a lot of list-specific operations, like "map", say
15:34:54 <RandoCoder> There are functions to do that or you can use a pragma for it
15:35:17 <ij> OverloadedStrings won't cut it.
15:38:27 <jle`> what kind of answer are you asking for, a "yes" or "no"?
15:38:54 <jle`> it takes some work, but it's not a complicated endeavor for the most part
15:38:55 <ij> I'm looking for a yes and "just do it!"
15:39:05 <jle`> and, the best part is that the compiler is there to make sure you don't make any mistakes
15:39:13 <jle`> that's the best kind of refactoring :)
15:39:23 <jle`> imagine doing this in a non-compiled language without haskell's type system
15:39:51 <ij> Such a language might not have this problem. :P
15:39:52 <Cale> patientpl: Ah, don't get too hung up on the syntax... it's meant to look a little like BNF if you've ever seen that before. It might actually be a little less confusing (depending on your background) to use the other available syntax:
15:39:53 <jle`> the compiler is basically here to guaruntee that you do it correctly :)
15:39:58 <Cale> data Tree a where
15:40:03 <Cale>   Tip :: Tree a
15:40:04 <ij> Though you're right in general about refactoring.
15:40:10 <Cale>   Branch :: a -> Tree a -> Tree a -> Tree a
15:40:14 <jle`> i don't think it's a language issue as much as an ecosystem/library issue
15:41:08 <Cale> patientpl: So, we're defining this (parametric) type Tree, so you can have types like Tree Integer or Tree String or Tree (Tree (Int, Double))
15:41:24 <Cale> and at the same time, we're defining two basic ways to make Trees
15:41:51 <Cale> Tip, which takes no parameters, and is a tree of an arbitrary type
15:42:16 <Cale> and Branch, which takes some value of type a, and then two subtrees (of values of type a), and combines those together into a tree
15:42:40 <Cale> So, you can have things like  Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip (Branch 4 Tip Tip)) :: Tree Integer
15:43:30 <Cale> So, that's the tree whose root is labelled with 1, and then its left subtree is the tree (Branch 2 Tip Tip), which has 2 at its root, and empty subtrees
15:44:12 <Cale> and then the right subtree of the overall tree is (Branch 3 Tip (Branch 4 Tip Tip)), which has 3 at its root, empty left subtree, but the right subtree has 4 at its root and empty subtrees
15:45:01 <Cale> ij: Yes, just do it :)
15:45:55 <alphonse23_> would anybody be nice enough to help me with this piece of code?
15:46:25 <alphonse23_> https://www.irccloud.com/pastebin/4797gl4u/yesod_monad_test
15:46:33 <alphonse23_> and here's the compiler error:
15:46:52 <alphonse23_> https://www.irccloud.com/pastebin/AEGJDPtx/yesod_monad_test%20compiler%20error
15:47:05 <alphonse23_> $ ghc --version
15:47:05 <alphonse23_> The Glorious Glasgow Haskell Compilation System, version 7.10.
15:47:25 <Cale> import qualified Data.Text as T
15:47:31 <Cale> and then use T.readFile
15:47:36 <Cale> instead of readFile
15:47:58 <Cale> Oh, sorry, maybe that should be Data.Text.IO
15:48:15 <Cale> yes
15:48:53 <Cale> (just add that import to the one you already have)
15:49:37 <alphonse23_> Thanks Cale!
15:49:38 <alphonse23_> worked!
15:49:43 <Earthlinger> Greetings haskellians
15:49:43 <Cale> no problem
15:49:50 <Cale> Hello!
15:49:53 <alphonse23_> https://www.irccloud.com/pastebin/ofKvPrCT/successful%20compile
15:50:15 <Cale> alphonse23_: Weird linker errors
15:50:25 <alphonse23_> running it on openbsd 6.0
15:50:29 <Cale> ah
15:50:36 <alphonse23_> so I don't think it's a common os to be running haskell on
15:50:40 <alphonse23_> like yesod init doesn't work
15:50:45 <alphonse23_> and stack also has bugs
15:50:56 <alphonse23_> but it works as a standalone file
15:50:59 <alphonse23_> but it crashes alot
15:51:28 <Cale> Yeah, there was someone a long time ago who maintained a good chunk of Haskell OpenBSD stuff, but he's perhaps been way too busy lately.
15:51:30 <alphonse23_> I think, eventually I'll try comping ghc 8 on open bsd itself
15:53:58 <jle`> b 6
15:53:59 <shayan_> glguy: hey, I basically did a copy + paste of your code into a new file and I get "testy.hs:1:10: error: Parse error in pattern: everyOther”. Are there any adjustments that needed to be made? Also does it matter if Prelude> is in the code? 
15:54:17 <glguy> Prelude> shouldn't be in it, that was just from my GHCi session
15:55:05 <shayan_>     Parse error: naked expression at top level
15:55:25 <Cale> shayan_: That line, whatever it is, doesn't belong in the module
15:55:37 <Cale> shayan_: glguy was just showing something you could try in ghci
15:59:14 <shayan_> I’m not sure if I am following. My intial understanding was that I could take the annoted code here http://lpaste.net/351355#a351356, paste it into a file, and run in the ghci to see how an infinite split would work
15:59:53 <glguy> You can take "everyOther (x:_:xs) = x : everyOther xs; everyOther _ = []" and "halve xs = zipWith const xs (everyOther xs)" and put those in a file
16:00:01 <glguy> then you could run: ghci ThatFile.hs
16:00:12 <glguy> and try evaluating expressions that use everyOther or halve
16:00:22 <glguy> as seen on lines 3 and 5
16:00:51 <lpaste> Alxandr pasted “Fake IO bind” at http://lpaste.net/351370
16:01:02 <Alxandr> Hi. I need some help figuring out why my code isn't working
16:01:18 <glguy> Alxandr: Include the errors you're getting in your pastes
16:01:19 <Alxandr> It's only a few lines and seem straight forward
16:01:35 <Alxandr> Ok
16:02:43 <Alxandr> Do I just paste the error at the bottom?
16:02:55 <shayan_> glguy: thanks 8) 
16:03:01 <glguy> sure. the goal is just for other people to be able to see it
16:03:29 <lpaste> Alxandr revised “Fake IO bind”: “Fake IO bind” at http://lpaste.net/351370
16:04:00 <glguy> Alxandr: OK, you're having a problem with the fact that in standard Haskell, type variables aren't scoped
16:04:07 <Sonolin> not sure if its just me but... pathfinding in haskell is a PITA
16:04:15 <Alxandr> Ah
16:04:18 <glguy> so the 'b' on line 3 and 6 are unrelated
16:04:28 <Alxandr> I'm guessing I need a language directive?
16:04:32 <Cale> Sonolin: How so?
16:04:56 <Cale> Sonolin: I wrote an A* algorithm that you can pull off of Hackage if you like.
16:05:07 <lpaste> glguy annotated “Fake IO bind” with “Fake IO bind (annotation)” at http://lpaste.net/351370#a351372
16:05:23 <Cale> Sonolin: I never used it for anything nontrivial, but some other people have used it and it seemed to work out well for them.
16:06:10 <Cale> (But really I spent like 10-15 minutes translating some imperative code off of Wikipedia)
16:06:22 <Sonolin> eh I'm working on it from scratch and probably not using the best strategy
16:06:22 <Cale> https://hackage.haskell.org/package/astar
16:06:41 <Sonolin> kind of starting off working imperatively, then once working slimming things down into smaller bits
16:06:42 <Cale> eh, what the heck, it's using HashSet now...
16:06:53 <Cale> Johannes must have done something :P
16:07:29 <Sonolin> ooh nice API Cale
16:07:34 <Sonolin> gives me some ideas already :)
16:07:53 <Cale> https://hackage.haskell.org/package/astar-0.3.0.0/docs/src/Data-Graph-AStar.html#aStar -- code hasn't changed much from when I wrote it though, just Map and Set got replaced by HashMap and HashSet for some reason
16:10:51 <Cale> Well, my first version didn't have the arbitrary monad there
16:10:55 <Alxandr> Hmm. I tried simply commenting out the type definitions and I got a new (and much nicer) error, but still not sure what is wrong: http://lpaste.net/351373
16:11:02 <Alxandr> I think it's using the wrong >>= it seems
16:11:51 <Cale> Alxandr: There's no way you got that error from the same code as in the paste
16:12:04 <Alxandr> Ah, no, wait, I figured it out. It's caused by my instance Monad lower down
16:12:07 <Alxandr> You're right
16:12:11 <Cale> right
16:12:19 <Alxandr> >>= required the ards to be the other way around
16:12:23 <Cale> yeah
16:32:32 <shayan_> Anyone know of any summer school or camps for Haskell? :)
16:33:56 <dunx> shayan_: they teach haskell at edinburgh university as a first year course, if that's any use to you :-)
16:40:17 <shayan_> dunx: That would really be a treat. Maybe I should have specified something available in North America, or Canada specifically, haha
16:41:24 <dunx> well if you're not at university you could apply now! :-P
16:41:48 <Alxandr> I need some help with operator precedence
16:41:57 <Alxandr> I'm trying to get the following code to work:
16:42:19 <Alxandr> http://lpaste.net/351374
16:42:38 <Alxandr> Where (/+) is defined as FakeFileSystem -> (String, String) -> FakeFileSystem
16:42:59 <Alxandr> And (|=) is simply (,) (in other words, String -> String -> (String, String)
16:43:00 <Cale> Are you sure you wouldn't rather have those arguments in the other order?
16:43:11 <glguy> Alxandr: include your infix declarations in the paste
16:43:22 <Alxandr> Well, they are rather random
16:43:26 <Alxandr> Cause I don't know what I'm doing
16:43:34 <Alxandr> (which is why I didn't include them)
16:43:55 <Alxandr> Cause I figured somebody who knew how infix operators work could tell me "you need left or right or whatever"
16:44:06 <Alxandr> But sure, this is what I've attempted
16:44:07 <Cale> But in any case, you want |= to be higher precedence than /+ and you want /+ to associate to the left, apparently
16:44:38 <Cale> and you want </> to be higher precedence still than |=
16:44:40 <Alxandr> (paste updated with what I have)
16:44:52 <glguy> Youd need something like: infixl 1 /+; infix 2 |=; infixr 3 </>
16:45:02 <Alxandr> higher precedence = higher number right?
16:45:07 <Cale> yes
16:45:48 <Alxandr> Thanks :)
16:45:48 <Cale> |= should probably not have a specified association
16:46:00 <Alxandr> I got a error message longer then my terminal cause it was wrong :P
16:46:05 <Cale> because something is wrong if you're writing a |= b |= c
16:46:25 <Alxandr> How do you do noassoc?
16:46:29 <Cale> infix
16:46:32 <Alxandr> Ah
16:46:35 <glguy> Youd need something like: infixl 1 /+; infix 2 |=; infixr 3 </>
16:46:37 <glguy> included that
16:46:42 <Alxandr> Yeah, that's what you wrote :P
16:46:50 <Alxandr> Also, </> is defined in System.FilePath
16:46:50 <Cale> Also, I would strongly consider making /+ the other way around
16:47:00 <Alxandr> +/?
16:47:11 <Cale> (String -> String) -> FileSystem -> FileSystem
16:47:15 <Cale> oops
16:47:15 <Alxandr> Ah
16:47:19 <Cale> (String, String) -> FileSystem -> FileSystem
16:47:27 <Alxandr> No, that would look way worse though?
16:47:29 <Cale> and then it would associate to the right
16:47:33 <Cale> why?
16:47:41 <Cale> It would look basically the same
16:47:44 <Alxandr> I'm trying to imagine how the code would look
16:47:50 <Cale> The empty would go at the end
16:47:57 <Alxandr> Hmm
16:47:57 <Cale> otherwise, it would be the same
16:48:09 <Alxandr> Why would that be better btw?
16:48:11 <Cale> Think about lists and (:)
16:48:15 <Cale> :t (:)
16:48:17 <lambdabot> a -> [a] -> [a]
16:48:26 <Cale> It takes an element, and gives you a function which transforms lists
16:48:44 <Alxandr> Yeah, I know. But I need this as a tiny dsl to build up a fake filesystem for my tests
16:48:54 <Cale> Sure, it doesn't *really* matter
16:49:02 <Alxandr> Hmm
16:49:06 <Alxandr> Oh well. I'll try it
16:49:21 <Alxandr> It basically turns it into monadplus doesn't it?
16:49:31 <Cale> But the order of arguments you want is typically some combination of the (unfortunately sometimes competing) factors:
16:49:34 <Alxandr> No wait, that's wrong
16:49:46 <Cale> 1) Arguments which vary more often should come later.
16:50:05 <Cale> 2) Ending up with something of the form A -> A for some type A, when possible, is nice.
16:50:31 <Cale> The reason for 1 is that functions are curried, so if you satisfy that, partial applications of your function will be more useful
16:50:59 <Cale> The reason for 2 is that all functions whose type is A -> A can be composed with one another
16:51:24 <Alxandr> Yeah, I know :)
16:52:04 <Alxandr> Like such: http://lpaste.net/351376
16:52:16 <Alxandr> imho looks sligtly worse, but again, doesn't really matter :)
16:52:19 <Cale> Your monad from earlier is something like StateT FakeFileSystem (Either SomeException)
16:52:26 <Alxandr> Yes
16:52:31 <Alxandr> I tried using StateT though
16:52:35 <Alxandr> And I got way confused :P
16:52:37 <Cale> You can get rid of that first newline now :)
16:52:38 <Alxandr> So I wrote my own
16:52:49 <Alxandr> Yeah, I know, but I rather they line up like such
16:52:57 <Alxandr> Which they incidentally will
16:53:02 <Cale> I mean, they should stay lined up the same way...
16:53:08 <Alxandr> Cause fs is short :P
16:53:23 <Cale> http://lpaste.net/351376
16:53:31 <Cale> Regardless :P
16:54:47 <lpaste> Cale annotated “No title” with “See? They still line up :)” at http://lpaste.net/351376#a351378
16:55:21 <Cale> But sure, I get what you mean ;)
16:55:26 <Alxandr> Yeah, I know, but I rather like to stick to normal indentation :P
16:55:33 <Alxandr> "normal"
16:55:38 <glguy> so much licking
16:55:44 <Alxandr> ?
16:55:49 <Cale> "Normal" indentation in Haskell is "make things line up in any column you want"
16:55:53 <glguy> :P all over the place
16:56:06 <Rembane> Except for the part that should be more indented.
16:56:24 <Cale> Yeah, any *sufficiently deep* column you want :)
16:57:13 <Cale> It is nice when you don't have to edit it as much though.
16:58:46 <Alxandr> Yeah
16:59:22 <Alxandr> YES! It (almost) compiles :P
16:59:32 <Alxandr> Just need to implement show and eq for one of my types
16:59:39 <Alxandr> That's the only thing it now complains about
17:09:54 <codedmart> Can I use printf to turn 1 in 100 or 1000 or 10000
17:11:14 <excelsio1a> Haskell has printf?
17:11:48 <hpc> :t printf
17:11:50 <lambdabot> PrintfType r => String -> r
17:12:18 <glguy> > printf "%d00" 1 :: String
17:12:21 <lambdabot>  "100"
17:12:25 <glguy> tada?
17:21:19 <Skunk> #ufonet
17:22:03 <Skunk> buonasera
17:22:05 <Alxandr> Holy crap. It works!
17:22:08 <Alxandr> That's it
17:22:16 <Alxandr> I'm not touching this anymore
17:22:19 <Alxandr> I'm going to bed :P
17:23:57 <Alxandr> Thanks a bunch for the help :)
17:24:10 <Alxandr> I must say, the haskell channel is generally always so helpful :)
17:25:43 <excelsio1a> > let e_main = putStrLn "Hello, world!"
17:25:45 <lambdabot>  <no location info>: error:
17:25:45 <lambdabot>      not an expression: ‘let e_main = putStrLn "Hello, world!"’
17:25:53 <excelsio1a> > e_main
17:25:56 <lambdabot>  error: Variable not in scope: e_main
17:26:12 <excelsio1a> putStrLn "Hello, world!"
17:26:18 <excelsio1a> > putStrLn "Hello, world!"
17:26:20 <lambdabot>  <IO ()>
17:36:33 <Emma14288> hello
17:36:53 <lambdabot> Hello.
17:39:10 <dunx> hello
17:39:18 <dunx> ;p
18:55:24 <eze> I am using literate haskell and the <|> operator looks really bad in the pdf. Any advice?
19:09:55 <mmachenry> eze: Rename it to orElse and use infix backticks like the STM module does.
19:13:17 <joe9> I am trying out some ml and it appears that haskell is so much cleaner. I am not sure if it is because I am used to haskell. any experiences with ml?
19:13:29 <glguy> Oops, this is #haskell
19:13:57 <joe9> glguy: I understand and I am used to haskell. just want to check if any haskellers dabbled with ml?
19:14:05 <monochrom> "A->B allows effects" has its pros and cons.
19:16:00 <milesrout> Hi, if you consider turning indentation into { and } tokens, can you lex Haskell without writing a parser?
19:16:19 <milesrout> From what I understand, you need to determine if you would get a parser error or not to work out whether to insert '}'s
19:16:38 <glguy> lexing haskell doesn't rely on layout
19:17:24 <milesrout> well that depends what you mean by lexing, right?
19:17:48 <glguy> If we're using a new defintion of lexing then I guess I can't answer
19:17:57 <milesrout> Well I'm using the normal definition of lexing
19:18:10 <glguy> OK, then you can lex haskell without resolving layout
19:18:18 <milesrout> You seem to just mean 'whatever you can do without resolving layout'
19:18:25 <milesrout> right?
19:18:51 <glguy> No, I mean the process of turing the characters into a stream of lexeme/token pairs annotated with file position
19:18:55 <milesrout> I think resolving layout is part of lexing, I'll put it that way.
19:19:41 <glguy> There's a second pass that's done to insert layout tokens
19:20:01 <milesrout> You shouldn't have to think about the position of things in your parser, right? 
19:20:09 <glguy> for example see how http://hackage.haskell.org/package/haskell-lexer handles it
19:20:14 <milesrout> that's what the lexer is for, for an indentation-sensitive language
19:22:08 <monochrom> This is clearly the post-modern, post-truth age in which everyone re-defines lexing.
19:24:56 <monochrom> But I am one of those positivist dinosaur who say that as long as your compiler handles my source files correctly, you have done it right, it doesn't matter whether your compiler is well-organized into 3 stages or it's an irreducible neural network.
19:25:53 <eze> mmachenry: Thanks, but I have seen this operator used in other places and it looks fine. I was wondering if there is a common kind of mistake I could be making
19:26:04 <milesrout> It does matter to me, because I'm the one writing the compiler. For another language, not for Haskell.
19:26:39 <milesrout> Anyway, my main question was going to be: if you do need some level of parsing to do this, what part of the layout requires this? Is it possible to have something close to layout that doesn't require a full parser to work out?
19:26:52 <eze> mmachenry: But thank you for the reply
19:26:53 <milesrout> Because if so, that makes it much easier to do auto-indenting and such in editors
19:29:48 <monochrom> Why don't you take a look at Python? It represents another layout design.
19:30:47 <nshepper1> parsing haskell requires whitespace, so your lexer should not throw it away
19:31:16 <nshepper1> also I don't think the haskell-mode indentation for emacs does full parsing
19:31:32 <milesrout> monochrom: Python doesn't support blocks inside expressions. 
19:31:52 <milesrout> monochrom: which is partly because they consider it confusing, but also probably difficult to implement in a way that would feel consistent..?
19:32:04 <glguy> milesrout: if you don't optionally support either layout for explicit structure like { ; ; }, you can resolve it ahead of parsing
19:33:55 <nshepper1> oh, it does have a recursive descent parser of some kind inside it
19:34:37 <monochrom> that's amazing
19:34:51 <monochrom> hardcore
19:35:22 <nshepper1> parsers in elisp
19:35:25 <milesrout> nscott76: https://github.com/haskell/haskell-mode/wiki/Why-TAB-cycle-indentation-for-Haskell-is-a-hard-problem seems to indicate that you probably need one, too.
19:37:13 <glguy> milesrout: for example as implemented http://hackage.haskell.org/package/located-0.1.1.0/docs/Text-Location-Layout.html
19:38:11 <monochrom> Any sufficiently complicated Lisp program contains an ad-hoc, partial implementation of Haskell :)
19:38:49 <milesrout> Stealing Lisp jokes is one thing, stealing Lisp jokes and using them against Lisp.. that's even worse!
19:39:17 <monochrom> I am a genius.
19:40:51 <Layl> (steal (jokes lisp))
19:46:26 <milesrout> thanks for your input, btw
19:46:29 <milesrout> I appreciate the help.
19:47:00 <milesrout> I'll probably end up just using curly braces for now, and think about whether v2 of my language will support some sort of Haskell-style optional layout system.
19:47:59 <Big_G> If they kepy track of side effects, they'd know when their jokes are stolen
19:48:09 <Squarism> id expected Enum to be able to provide all "constructors" in some way. But i cannot be able to find any such function in Enum class
19:48:30 <glguy> Squarism: on its own, Enum doesn't offer that
19:48:48 <glguy> Enum is a hack to help with [_ .. _] syntax
19:49:01 <Squarism> glguy, ok, what else do i need to provide that?
19:49:15 <geekosaur> Bounded
19:49:20 <Squarism> ok
19:50:00 <Squarism> it only exposes min and max?
19:50:40 <Koterpillar> Squarism: do you want to somehow get, e.g. "Nothing" and "Just" out of Maybe?
19:50:48 <glguy> > [minBound .. ] :: [Ordering] -- for some types this works
19:50:50 <lambdabot>  [LT,EQ,GT]
19:50:59 <Koterpillar> Squarism: maybe you want Typeable?
19:51:06 <Koterpillar> or Generic...
19:51:30 <geekosaur> you did say "what else", given minBound and maxBound you can then use Enum methods. you cannot enumerate non-nullary constructors (they cannot be Enum) unless you use facilities in Data.Data or Data.Generic
19:51:55 <Squarism> Im assuming here that an Enum is a type with constructors that has no arguments - so i wanted all values of the type 
19:52:08 <Squarism> glguy, ok - ill try that
19:52:10 <glguy> Double is an instance of Enum
19:52:19 <Squarism> oh ok
19:54:28 <glguy> > dataTypeConstrs (dataTypeOf EQ)
19:54:30 <lambdabot>  [LT,EQ,GT]
19:55:00 <glguy> That's not a complete solution, the Show instance for the Constr type is making it looks more finished than it should
19:56:08 <glguy> > concatMap (gunfold (const []) (:[])) (dataTypeConstrs (dataTypeOf (undefined :: Ordering))) :: [Ordering]
19:56:10 <lambdabot>  [LT,EQ,GT]
19:57:28 <shayan_> Is Yesod a competitor to GHCJS? Meaning that, if I were to use GHCJS, then I would be giving up the opportunity of using Yesod? 
19:59:40 <markasoftware> shayan_: no, ghcjs is front end, yesod is backend
19:59:55 <markasoftware> ghcjs compiles haskell to javascript i think
20:00:27 <Squarism> yep
20:00:37 <GD_> isnt just using something like purescript better for front-end?
20:00:43 <ggVGc> depends
20:00:50 <ggVGc> purescript is quite different from haskell
20:00:57 <Squarism> but it looks parts of yesod is about producing markup 
20:01:24 <glguy> > let gen :: forall a. Data a => [a]; gen = gunfold (\x -> liftA2 ($) x gen) (:[]) =<< dataTypeConstrs (dataTypeOf (undefined :: a)) in gen :: [Maybe Ordering]
20:01:27 <lambdabot>  [Nothing,Just LT,Just EQ,Just GT]
20:01:59 <Koterpillar> Squarism: GHCJS isn't producing markup, it's producing JavaScript
20:02:52 <geekosaur> Squarism, do you understand the difference between a language and a framework?
20:02:54 <ggVGc> GD_: if you have a haskell code base that you just want to run on the frontend for some reason, ghcjs is what you'd want. If you want to write frontend code is a pure functional language that is similar to haskell syntactically, purescript is a good choice. Purescript maps closer to javascript because it's strict rather than lazy. But you can't really code share much with haskell code, because of that, and 
20:02:55 <markasoftware> Squarism: that's correct
20:03:00 <ggVGc> also because purescript has extensible 
20:03:03 <ggVGc>  records and an effects system, and that is completely different from haskell
20:03:04 <markasoftware> yesod can make html from a template
20:03:05 <ggVGc> sorry for the wall
20:04:39 <glguy> > let gen :: forall a. Data a => [a]; gen = gunfold (<*> gen) pure =<< dataTypeConstrs (dataTypeOf (undefined :: a)) in gen :: [Maybe Ordering] -- little better, last one
20:04:41 <lambdabot>  [Nothing,Just LT,Just EQ,Just GT]
20:04:48 <geekosaur> oh, I think I confused who was saying what
20:05:27 <Squarism> geekosaur, i cannot say i know yesod. But from the docs it looked like it was some sort of rails with helpers for producing "Widgets". In a GHCJS app i would delegate all markup manipulation to GHCJS and just use a rest able server. But that might just be me
20:06:14 <geekosaur> shayan_, yesod is not a competitor, it's a different thing entirely. in theory (perhaps not in practice yet) you could use ghcjs to build yesod, producing javascript instead of a native executable. (I'm not sure why you'd want to do that though... native vs. JS is like swapping Ferrari for Yugo)
20:11:01 <geekosaur> Squarism, yesod is a web framework
20:11:07 <geekosaur> is ruby a replacement for rails?
20:11:20 <kadoban> Is there some common reason why building with profiling with GHC would make the resulting program go *faster*, before I tear by hair out looking? It's like ... not even close, 40% faster with profiling
20:12:30 <geekosaur> profiling defeats inlining; maybe you've found a pessimal case for inlining
20:13:05 <kadoban> Hmm, that's interesting. I'll see if I can find that then
20:13:11 <geekosaur> (one of those situations where you get to fiddle with special pragmas to get inlining vs. specialisation etc. to happen right, maybe)
20:13:41 <Cale> kadoban: What is the program?
20:13:44 <kadoban> Ya, I never quite seem to be able to tell if I'm doing that correctly, heh. Maybe this will be a good opportunity to tell
20:13:57 <kadoban> Some algorithmic nonsense, mostly a suffix array implementation and using it for something.
20:14:12 <Squarism> geekosaur, i understand that. My point was that he might reach for something with a more limited scope he'd prolly not need the parts of yesod dealing with markup manipulation and abstractions
20:14:35 <Squarism> ...as he'd prolly..
20:14:53 <geekosaur> well, yesod has a lot of parts and plugins, certainly you don't need to use all of them
20:17:20 <markasoftware> ok time to try yesod first time
20:17:22 <markasoftware> wish me luck
20:17:25 <markasoftware> i don't even know how to use a monad yet
20:17:49 <ggVGc> that doesn't matter
20:17:58 <markasoftware> are monads important
20:17:59 <ggVGc> also, that's the wrong way of thinking about it
20:18:02 <ggVGc> but that also doesn't matter
20:18:31 <ggVGc> markasoftware: not nearly as important as you might think when you first start getting into haskell
20:18:42 <ggVGc> markasoftware: just write some code, ignore type theory words like monads
20:18:57 <Squarism> glguy, thanks for the explaination on enum/bounded. To bad it st wasnt easy =D
20:18:58 <markasoftware> better to install things through distrobution package manager if possible right?
20:19:01 <ggVGc> markasoftware: just do what you'd do in any other situation. Try to do something, google how to do it, try to understand what you did
20:19:04 <ggVGc> repeat
20:19:11 <markasoftware> yep, basically how I learned node, thanks
20:19:27 <markasoftware> i think all the template haskell stuff might get confusing though
20:19:35 <dmj`> markasoftware: I wouldn’t recommend web development with haskell until you understand at least monads, and probably monad transformers.
20:19:40 <ggVGc> markasoftware: you'll eventually get into knowing what "monad" actually means, and realise how boring and not really important to writing your code it is
20:20:25 <ggVGc> markasoftware: but also, yes, web development with haskell isn't the best entry point. It's a lot harder than in something like node as a first step
20:20:31 <Cale> It's kind of important to be able to use some *examples* of monads
20:20:39 <ggVGc> most haskell developers don't really know how to use it for web development
20:20:45 <markasoftware> well ive done some project euler with haskell
20:20:55 <markasoftware> and have a lot of experience with web dev in general/in js
20:21:19 <ggVGc> Cale: that's why I said just try to solve things and then think about what you did, rather than going into "I need to study what monads are"
20:21:31 <markasoftware> yep
20:21:34 <markasoftware> learn by necessity
20:21:36 <ggVGc> since just doing stuff will have you use monads, but that doesn't mean you need to understand why they are monads
20:21:36 <markasoftware> thanks
20:22:07 <GD1> The main problem of monads in haskell is that everyone tries expain it. Its just a typeclass. Look for its uses and you will perfectly understand
20:22:23 <ggVGc> markasoftware: basically, at first it's okay to just learn examples of monad usage, and not actually understand the abstraction, It'll get you far enough for building most programs you'd want to make now
20:22:36 <markasoftware> yeah, i plan to start small
20:22:43 <markasoftware> i want to make a basic multiplayer rock paper scissors game first
20:23:07 <ggVGc> GD1: yes, but even knowing what type classes are, isn't really necessary for writing a lot of code. It's just abstration, and abstraction isn't necessary for writing programs. It just makes it smoother once you know them
20:23:16 <ggVGc> but many people write programs in many languages without using much abstraction
20:23:19 <Squarism> markasoftware, i was also new to web dev in haskell and used "Spock" as webserver/framework. I can confirm its quite hard to do web dev if you dont understand monads. I now have a running site but i still struggle with the monad / monad transformer parts - to be in control you need to learn these for non trivial tasks
20:23:23 <ggVGc> even if the languages allow abstracion
20:23:37 <GD1> then they should use unlambda :D
20:24:02 <GD1> its like writing without interfaces in OOP langs
20:24:11 <GD1> nonsence
20:24:32 <markasoftware> this strong type stuff drives me crazy after using js
20:24:47 <dmj`> markasoftware: soon it will be the other way :) 
20:24:48 <ggVGc> markasoftware: the bottom line for me anyway is that haskell has a really high roof of abstractions you can do, but as with any language you can write anything you want without abstracting at all, and if you do that with haskell you'll have maybe more verbose code than what it could have been, but that's fine
20:25:25 <markasoftware> are desktop guis in haskell a thing?
20:25:50 <ggVGc> uhm, why is someone banging some door or wall at 5.25am
20:25:54 <ggVGc> or hammering something
20:25:59 <ggVGc> seems unreasonable
20:26:04 <ggVGc> wonder if someone is having a breakin
20:26:16 <zomg> ggVGc: my gf started vacuuming in the middle of the night, I had to tell her to stop... :P
20:26:19 <GD1> markasoftware: if you will continue with haskell js will drive you crazy with its stupid type interference
20:26:39 <markasoftware> i do like how the types remove run time errors mostly
20:28:25 <zomg> GD1: I work with JS all day!
20:28:39 <zomg> but then again, I was a PHP dev for 10 years so I'm one of those people who can make anything work (more or less) :D
20:28:47 * markasoftware shivers
20:30:36 <GD1> zomg: I feel sad for you. Every time i touch JS i get instantly frustrated
20:30:43 <GD1> :D
20:30:44 <zomg> heh
20:31:13 <zomg> yeah I'm currently refactoring some stuff a jr dev/intern of ours wrote like two years ago...
20:31:30 <zomg> frustration is probably the emotion I'd associate with this =)
20:31:58 <zomg> in hindsight I should've kept a closer eye on him but at least now I'll know to do that the next time such a thing occurs :p
20:32:00 <markasoftware> does templatehaskell basically allow people to arbitrarily add extra syntax
20:34:24 <markasoftware> to be fair, js is good for people who are new to programming
20:34:29 <markasoftware> easier to learn than hs
20:34:50 <qmm> of DeriveDataTypeable, DeriveGeneric, StandaloneDeriving, ExistentialQuantification, ScopedTypeVariables, PatternGuards, RecordWildCards, FlexibleInstances, UndecidableInstances, and MultiParamTypeClasses, which describes what the {..} is in findName :: forall k v. (Keyable k, Serializable v) => Key k, findName Key{..} state = undefined
20:35:23 <zomg> markasoftware: hard to say to be honest.. as a language, maybe, but if all you know is the language you won't be very productive
20:35:43 <markasoftware> recursion is hard for people who don't even know loops yet
20:36:08 <zomg> there was a discussion here at some point about those who learned haskell with no programming background vs those who learned it after some other exposure
20:36:15 <zomg> it actually wasn't that straightforward :)
20:36:33 <markasoftware> maybe if you never learned loops recursion is easier
20:36:51 <zomg> yeah
20:37:04 <nshepperd> qmm: RecordWildCards
20:37:50 <GD1> Are people that started haskell first even exist?
20:38:09 <markasoftware> GD1: that's what I'm wondering ;)
20:39:22 <GD1> The only ones i can imagine are old math-guys decided to do some cs :D 
20:39:39 <dyreshark> GD1: i worked with a guy who said he taught his CS 101 class in haskell
20:39:45 <dyreshark> (for the first part, at least)
20:39:57 <dyreshark> so there are apparently who started with Haskell out there
20:40:01 <dyreshark> apparently people*
20:40:09 <GD1> What a brave man!
20:40:11 <markasoftware> is CS 101 the first one?
20:40:16 <dyreshark> yup
20:40:19 <markasoftware> are they allowed to choose what language they use?
20:40:29 <dyreshark> i'd assume it depends on college
20:40:37 <markasoftware> because I've only heard of it in Java
20:40:38 <dyreshark> where i went to school, it had to be Java
20:40:38 <zomg> I showed my gf who has some math background haskell and it seemed to make a lot more sense to her than javascript :)
20:40:51 <zomg> the most exposure to "programming" she had was Excel formulas
20:41:04 <markasoftware> you'd be surprised waht some poeple can do with excel formula
20:41:08 <zomg> haha yeah
20:41:23 <dyreshark> obligatory https://xkcd.com/1667/
20:41:24 <markasoftware> my dad makes a couple thousand dollars a year selling a vba plugin for excel
20:41:28 <GD1> Havnt she used something like Mathematica or Maple?
20:41:29 <markasoftware> scares the shit out of me
20:41:52 <markasoftware> dyreshark: there's always a relevant xkcd
20:41:55 <markasoftware> ;)
20:42:02 <dyreshark> that's what's so great about it
20:42:20 <markasoftware> i think i need to see about 200 more before i can start bringing up relevant ones
20:42:50 <markasoftware> do you have to enable overloaded strings before you can use Text?
20:43:27 <Squarism> we did it in standarnd ML
20:43:30 <glguy> markasoftware: Template Haskell allows you to manipulate and generate Haskell code for your module at compile time
20:43:30 <kadoban> No. The only thing OverloadedStrings does is lets you use string literals as-if they were Text, or anything else.
20:43:47 <kadoban> (any instance of IsString anyway)
20:44:23 <glguy> If you don't enable OverloadedStrings, then you just use 'pack :: String -> Text'
20:45:14 <codygman> I've been stuck for a couple of hours trying to figure out why this RElem UserId constraint isn't satisfied, any ideas? https://github.com/codygman/understanding-vinyl-min-repro/blob/master/src/Main.hs#L227 (note that Main.hs has no dependencies and can be a standalone file) 
20:48:12 <codygman> oh I think I have the wrong RIndex function
20:48:30 <ertes> GD1: my zealousness has created two people who started with haskell as their first language
20:48:46 <glguy> codygman: You didn't implement any RElem instances?
20:49:21 <codygman> glguy: Yeah I think so. I'm feeling my way around Vinyl/Frames by doing this so a little lost by nature of it. Thanks.
20:49:28 <glguy> so there are no instance, so you can't find the one it needs :)
20:49:55 <xpika> is there a constructor like data Function a b = Function (a -> b -> a) ?
20:50:09 <ertes> xpika: yeah, you just created it
20:51:14 <Koterpillar> xpika: does this have anything to do with folds?
20:52:35 <xpika> Koterpillar: not in this case. I want to use it for storing numbers as functions.
20:53:13 <Koterpillar> what do a and b mean?
20:53:28 <ertes> xpika: you want to use church encoding?
20:54:07 <xpika> ertes: yes
20:54:32 <ertes> xpika: that requires RankNTypes though…  are you familiar with that extension?
20:54:46 <xpika> ertes: yes
20:55:22 <ertes> @let newtype NatC = NatC { fromNatC :: forall r. (r -> r) -> r -> r }
20:55:26 <lambdabot>  Defined.
20:55:48 <xpika> Koterpillar:  it may exist in the package "folds" but I havn't found it
20:56:46 <ertes> you're literally searching for a definition of that?  because i doubt that there is a package for it…  it's pretty trivial and doesn't have too many interesting instances except perhaps Contravariant
20:57:52 <qmm> nshepperd_: thank you
20:58:27 <codygman> glguy: haha yeah that was it, it's working fine now :)
20:58:42 <xpika> @hoogle fromNatC :: forall r. (r -> r) -> r -> r
20:58:45 <lambdabot> No results found
20:59:03 <glguy> ertes: To be fair there are less useful packages than that
21:00:02 <xpika> @hayoo  forall r. (r -> r) -> r -> r 
21:00:02 <lambdabot> Unknown command, try @list
21:00:12 <glguy> xpika: You can play with lambdabot in /msg
21:10:30 <ertes> @let instance Num NatC where { NatC f + NatC g = NatC (\s z -> f s (g s z)); NatC f * y = f (y +) 0; abs = id; negate (NatC f) = f (const (error "Negative natural")) 0; signum (NatC f) = f (const 1) 0; fromInteger n0 | n0 < 0 = error "Negative natural"; fromInteger n0 = NatC (\s z -> let go 0 = z; go n = s (go (n - 1)) in go n0) }
21:10:33 <lambdabot>  Defined.
21:11:30 <uiop> > 1::NatC
21:11:32 <lambdabot>  error:
21:11:32 <lambdabot>      • No instance for (Show NatC)
21:11:32 <lambdabot>          arising from a use of ‘show_M79274948578476486091210’
21:12:27 <ertes> @let instance Show NatC where { showsPrec d (NatC f) = showsPrec d (f (\y x -> y $! x + 1) id 0 :: Integer) }
21:12:29 <lambdabot>  Defined.
21:12:35 <ertes> > 5 + 7 :: NatC
21:12:38 <lambdabot>  12
21:13:22 <uiop> > 2 - 1 :: NatC
21:13:25 <lambdabot>  *Exception: Negative natural
21:15:40 <mniip> the default definition of - uses negate
21:15:49 <mniip> you could define your own without
21:16:30 <ertes> strictly speaking that *should* be bottom to be consistent with x - y = x + negate y =)
21:18:23 <ertes> @let natCFoldl' f x0 (NatC g) = g (\go x -> go $! f x) id x0
21:18:26 <lambdabot>  Defined.
21:18:54 <ertes> > natCFoldl' (+ 1) 0 5000
21:18:57 <lambdabot>  5000
22:36:49 <anonx> hello
22:44:06 <jchia> To convert from a Vector Int to an IntSet, is there a more direct way than to use foldMap singleton?
22:47:46 <monochrom> I would use foldl' IntSet.insert IntSet.empty
22:48:25 <jchia> monochrom: Why? Is it more efficient?
22:48:51 <johnw> what about IntSet.fromList . Vector.toList?
22:49:29 <jchia> johnw: I wonder whether that's going to actually make a list first, affecting efficiency.
22:49:32 <MarcelineVQ> the difference is between the big O of repeated union vs repeated insert
22:49:42 <johnw> jchia: I'd be quite surprised if it did
22:50:20 <MarcelineVQ> also foldl' is strict so that's another difference, idk if union is
22:50:32 <dyreshark> IntSet.fromList seems to be just that: https://hackage.haskell.org/package/containers-0.5.9.1/docs/src/Data.IntSet.Internal.html#fromList
22:50:45 <dyreshark> so do whatever's clearest :)
22:52:00 <monochrom> union is strict
22:52:45 <uiop> MarcelineVQ: IntSet datatype is strict in the recursive parts (and the Ints)
22:53:07 <uiop> so just forcing the result with cascade
22:53:13 <uiop> s/with/will/
22:53:20 <monochrom> Also, strictness is beside the point. foldl is strict too.
22:57:42 <MarcelineVQ> Ah, am I using that term wrong? Is it strict because, due to recursing right away, there isn't a moment for a constructor to allow lazyness? Should I have said, instead of strict, that foldl' forces its accumulator to be evaluated as it runs?
22:59:29 <uiop> MarcelineVQ: yes
22:59:44 <Cale> > foldl undefined 0 []
22:59:46 <lambdabot>  0
22:59:47 <Cale> > foldl' undefined 0 []
22:59:49 <lambdabot>  0
22:59:56 <Cale> Both wrong, neither function is strict ;)
23:00:23 <Cale> (formally a function is strict if f _|_ = _|_)
23:01:38 <uiop> > fold' undefined undefined []
23:01:40 <nshepperd> presumably monochrom is referring to 'foldl f ⊥ xs = ⊥'
23:01:41 <lambdabot>  error:
23:01:41 <lambdabot>      • Variable not in scope: fold' :: t0 -> t1 -> [t2] -> t
23:01:41 <lambdabot>      • Perhaps you meant one of these:
23:01:46 <uiop> > foldl' undefined undefined []
23:01:48 <lambdabot>  *Exception: Prelude.undefined
23:01:57 <uiop> only nonstrict in first arg ;)
23:01:59 <pikajude> we just have to define foldl'''
23:02:45 <nshepperd> anyway, you could sort your Vector and do IntSet.fromAscList
23:03:21 <nshepperd> that could... conceivably... have a better constant factor
23:03:48 <nshepperd> given a fancy in-place sort
23:03:57 <YellowOnion> ertes, wow, I think I've fixed it, just moved the structed out of scope so it can be GC'd.
23:04:27 <uiop> if it takes too long just to *build* the IntSet, you're probably screwed once you try to use it...
23:04:29 <uiop> or something
23:05:18 <uiop> in other words, just fromList it, you'll be fine. if you aren't, then you've got worse problems
23:05:19 <uiop> :)
23:05:31 <nshepperd> yeah, IntSet.fromList is probably the correct thing
23:05:57 <EvanR> shouldnt lookups be quite a bit faster than full building the set in the first place
23:06:03 <EvanR> fully
23:06:29 <uiop> yes
23:07:12 <ertes> YellowOnion: great…  is the memory usage more reasonable now?
23:07:47 <YellowOnion> ertes, climbing a lot slower ha.
23:08:31 <ertes> =)
23:11:48 <YellowOnion> ertes, amazing, it's using 700% CPU too, without me doing anything to parralise it.
23:12:23 <johnw> parallelization leads to system paralization
23:12:42 <EvanR> system parallelization?
23:13:12 * dyreshark thinks it was a pun on paralysis
23:13:26 <uiop> EvanR: yes, i was thinking more along the lines of doing a bunch of union's and intersect's with the IntSet you built when i said that.. if all you're doing is lookups then what i said doesn't apply
23:15:20 <EvanR> uiop: if you have a sorted list in the first place, then you can do "a bunch" of unions and intersects directly, without a tree
23:15:28 <EvanR> may or may not be better
23:16:09 <nshepperd> union and intersection are O(n) in IntSet too
23:19:09 <EvanR> yes big O is a wash here
23:19:10 <uiop> sure, i just meant if the IntSet is so massive as to exhaust your memory, then you've got worse problems.. like running out of memory
23:19:31 <EvanR> yes, and if you have lazy lists, you can avoid exhausting memory
23:19:39 <uiop> but if it *does* fit in memory, then fromList shouldnt kill you, unless maybe you're fully constructing the list in memory before hand
23:19:48 <uiop> EvanR: right exactly
23:20:00 <nshepperd> actually the docs say O(n+m) but surely that should be O(min(n,m)) there...
23:20:12 <nshepperd> or, uh
23:20:18 <EvanR> no its linear
23:21:20 <EvanR> uiop: good point... the fact that IntSet must rather strictly construct is already a downside as far as memory goes
23:22:03 <EvanR> more memory = slower
23:22:41 <EvanR> time and space are really part of the same underlying manifold with a weirdo metric
23:22:59 <EvanR> unless youre feynman who said fuck that
23:23:01 <pikajude> time and space are nearly the same, except that the matching group is "tim" as opposed to "spac"
23:23:16 <MarcelineVQ> :>
23:23:38 <ertes> YellowOnion: hmm?  parallelisation is explicit in haskell
23:24:37 <YellowOnion> ertes, unless it's just the GC going mental. idk how else its using like 4 of my cores.
23:24:46 <nshepperd> hmm, surely hedge union l ∪ r should not have to traverse the entire l, if |r| is very small like 2
23:25:03 <ertes> YellowOnion: you'd at least have to tell it to use multiple threads by an RTS option
23:25:18 <YellowOnion> stack does that by default
23:25:23 <nshepperd> O(min(l, rW) + min(r, lW))?
23:26:05 <ertes> YellowOnion: try: +RTS -s
23:26:15 <ertes> it gives you some statistics
23:26:47 <ertes> or -t…  one of those is very detailed
23:27:49 <MarcelineVQ> -S
23:32:48 <nshepperd> ah yeah, the bounds for Data.Set say 'O(m*log(nm + 1)), m <= n', so basically agrees that it is faster than union of sorted lists
23:33:53 <nshepperd> when the sets are not balanced anyway
23:34:28 <xetra11> hello guys
23:34:54 <xetra11> I hope everybody is up for my fst question ! :D
23:36:15 <xetra11> I'm struggling with understand what this pattern match actually does. Especially what "xs" is binding to. Code: length' (_:xs) = 1 + length' xs
23:36:38 <xetra11> function definition: length' :: (Num b) => [a] -> b
23:37:00 <uiop> > (\x:xs -> (x, xs)) [0,1,2,3]
23:37:02 <lambdabot>  <hint>:1:4: error: parse error on input ‘:’
23:37:19 <uiop> > (\(x:xs) -> (x, xs)) [0,1,2,3]
23:37:21 <lambdabot>  (0,[1,2,3])
23:37:49 <uiop> > let f a@(x:xs) = (x, xs, a) in f [0,1,2,3]
23:37:51 <lambdabot>  (0,[1,2,3],[0,1,2,3])
23:38:12 <uiop> xetra11: 
23:38:28 <xetra11> @uiop I'm listening
23:38:28 <lambdabot> Unknown command, try @list
23:38:34 <xetra11> @list
23:38:35 <lambdabot> What module?  Try @listmodules for some ideas.
23:38:57 <xetra11> @listmodules
23:38:57 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
23:38:57 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:39:11 <uiop> xetra11: those bot executions demonstrate what that pattern match does
23:39:45 <uiop> is the "_" confusing you?
23:40:44 <xetra11> Well not completly I know its some kind of wildcard
23:40:50 <xetra11> But what I try to understand is
23:40:57 <uiop> x:xs
23:41:06 <uiop> x binds to the first element of the list
23:41:30 <xetra11> so xs == fst [1,2,3] ?
23:41:44 <xetra11> sry fst only works on tuples (im new)
23:41:48 <kadoban> > tail [1,2,3]
23:41:49 <xetra11> meant to say head
23:41:51 <lambdabot>  [2,3]
23:41:56 <kadoban> > head [1,2,3]
23:41:59 <lambdabot>  1
23:42:07 <xetra11> thx kado
23:42:13 <uiop> xs binds to the tail of the list, which is to say the rest of the list beginning at the 2nd element
23:42:22 <xetra11> AH okay!
23:42:30 <kadoban> (if there is no second element, then it's the empty list, [])
23:43:03 <kadoban> If there is no *first* element, then that pattern match fails, because there is no (:) to match.
23:43:37 <xetra11> now I get the function - it deconstructs the list and adds +1 to every recursion and returns the 1 + 1 + 0 at the end
23:43:41 <gregorylion> Use can imagine lists defined as List a = a : List a | [] .So x(:)xs just matches head and tail
23:43:43 <gregorylion> You
23:43:57 <uiop> xetra11: right
23:44:23 <xetra11> I thought about _:xs is something like 1:[] (where [] is the x in the function)
23:44:41 <xetra11> like adding _ = which is the whole list parameter and adds it to the function var
23:45:14 <xetra11> did not know that it only binds the tail of a list to the "xs" var
23:47:26 <TamaMcGlinn> any haskell programmers about who can answer me a really basic type question?
23:48:00 <uiop> dont ask for permission, ask for forgiveness ;)
23:48:06 <TamaMcGlinn> lol
23:48:08 <cocreature> or just ask your question directly :)
23:48:23 <cocreature> it’s hard to know if you can answer a question that you don’t know
23:52:09 <delYsid> Hmm, I have a possibly quite stupid question.  Without the parsers package (Parsing typeclass), how do I deal with a monad stack and lifting?  Of course, I can lift parser functions inside of my transformer stack, but how do I call parser functions like lookAhead *on* one of my transformer based combinators?
23:52:34 <cocreature> delYsid: which parser library are you using?
23:53:09 <TamaMcGlinn> If I have this type declaration: " f :: Num a => a -> a -> a " and I call it as (f 2 4.1), it seems to me that the first parameter could be restricted to only Int, and it should still work - but the compiler complains about not being able to deduce a; why? In other words, why does this toy example fail to compile until you change Int back to a in the function type declaration? http://paste.debian.net/909271/
23:53:36 <delYsid> cocreature: actually, purescript-parsing :-)   But that shouldn't matter for this question, I think all parser libraries work similarily in this regard when it comes to stacking them in a transformer stack?
23:53:49 <geekosaur> TamaMcGlinn, there is no automatic conversion
23:53:57 <cocreature> TamaMcGlinn: the problem is that (*) requires that both of its argument are of the same type
23:54:05 <cocreature> TamaMcGlinn: you are trying to multiple an Int and an a
23:54:13 <geekosaur> :t (*)
23:54:15 <lambdabot> Num a => a -> a -> a
23:54:30 <geekosaur> must be the same a throughout; cant multiply Int and Double, or Int and unspecified a
23:54:51 <cocreature> delYsid: a lot of them already include a typeclass, e.g. https://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec-Prim.html#t:MonadParsec
23:55:08 <TamaMcGlinn> I see. Thank you. So, ghci and then ":t (*)" would tell me the answer
23:55:25 <EvanR> also :info Num can be handy
23:55:44 <EvanR> :info <anything>
23:56:14 <delYsid> cocreature: I know and used the parsers package, so I know about the typeclass approach.  My question is basically, without the typeclass, can I still work around this, or do I need to reinvent the Parsing typeclass in purescript to be able to do lookAhead on a stacked combinator of mine?
23:58:07 <cocreature> delYsid: looking at the source of purescript-parsing, it seems like lookAhead already allows a "ParserT s m a" so if you put ParserT at the top of your monad stack it should work.
