00:10:14 <xpika> is there a peek function in pipes like there is in conduit ?
01:03:08 <zipper> raichoo: Hello
01:04:20 <cocreature> xplat: afaik you need to use pipes-parse for that. then you can use https://hackage.haskell.org/package/pipes-parse-3.0.8/docs/Pipes-Parse.html#v:peek
01:04:37 <cocreature> oh xpika is already gone, that’s why autocomplete failed
01:12:10 <bollu> what is the relationship between JS promises and actors?
01:12:14 <bollu> and continuations as well
01:12:35 <bollu> I'm not sure where to ask this question, I thought #haskell has enough of "CS theory" to entertain this question
01:12:43 <bollu> wow
01:13:17 <athan> continuations are very generic, but I don't know enough about them to give the best answer :x
01:13:45 <athan> I think a promise is something like a continuation
01:14:34 <athan> you can imagine the continuation monad as "given that I have some method to fulfill the computation that sparked my thread, do something then call it", very similar to JS's `next()` concept
01:15:06 <athan> but, this can be pushed further to delimited continuations, which I know nothing about :)
01:16:18 <athan> :S
01:22:50 <reactormonk> Why is refraining from using typeclasses considered good practice in API design?
01:23:26 <t7> where did you read that?
01:25:35 <reactormonk> https://www.reddit.com/r/haskell/comments/5qxh1e/deni_bertovic_haskell_and_docker_down_the_rabbit/dd399dx/
01:25:47 <Rembane> There's more than one way to do it
01:26:51 <athan> @type show . read -- shouldn't this throw an ambiguity error?
01:26:53 <lambdabot> String -> String
01:28:17 <reactormonk> > (show . read) "foobar"
01:28:19 <lambdabot>  "*Exception: Prelude.read: no parse
01:28:53 <reactormonk> huh?
01:30:19 <athan> I would think it would throw an ambiguity error before being capable of running :s
01:30:29 <athan> due to deciding the `a` in between
01:31:19 <cocreature> athan: GHC defaults the constraint to (). if you enable -Wtype-defaults you’ll get a warning
01:31:42 <athan> oh! That makes perfect sense :)
01:31:45 <athan> thank you cocreature
01:32:14 <cocreature> athan: if you enable ExtendedDefaultRules you’ll also get an error
01:32:21 <cocreature> ExtendedDefaultRules is enabled by default in GHCi
01:33:37 <athan> What does that extension do, cocreature? I've seen it around a few times
01:34:18 <athan> or is that what facilitates the "default-ness"
01:34:55 <cocreature> athan: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
01:51:00 <orzo> does cabal pass -O by default?  The --help says n=1 is default for the --enable-optimization option, but it's ambiguous what happens when you don't pass that
01:51:31 <cocreature> orzo: afaik, it does pass -O by default
01:52:46 <orzo> well maybe it does usually, but i actually have "optimization: False" in my .cabal/cofnig
01:53:05 <orzo> probably was tired of slow compiles
01:53:17 <cocreature> if you disable optimizations, cabal will obviously disable them :)
01:54:48 <orzo> i had a memory leak earlier and i fixed it, but it was primarily just putting some strictness annotations. I wonder if an optimization pass would have eliminated it anyway
01:55:33 <cocreature> I’m not a big fan of relying on optimizations to infer strictness. it’s too easy to make a small change to your program and break them even if they did work before
01:56:32 <orzo> so its probably good practice to fix memory leaks in a -O0 build
02:12:40 <Arguggi> Hello, I'm trying to use ekg behind nginx ( mainly for https), proxy_pass usually works (I'm using it to serve my servant code), but now I'm getting "No handler accepted "/" ", some details here: http://lpaste.net/3083176968179417088 , any idea why?
02:21:15 <systadmin> What's a good Haskell book for reference?
02:29:09 <sdx23> systadmin: reference? I'd rather say docs on hackage.
02:31:38 <MarcelineVQ> systadmin: depends what you're referencing, the language report is great general reference https://www.haskell.org/onlinereport/haskell2010/
02:35:32 <reactormonk> Is there a specific type for ascii-only characters?
02:36:10 <opqdonut> Char8
02:36:30 <opqdonut> as used by Data.ByteString
02:37:10 <opqdonut> hmm no, it's not a type, it's just the name of the module http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Char8.html
02:37:51 <opqdonut> there's Data.Word.Word8 for bytes, but I'm not sure where to find Character interop for that
02:40:25 <merijn> opqdonut: You are hurting my very soul
02:40:34 <opqdonut> sorry
02:40:46 <merijn> What does "Character interop for Word8" even mean
02:41:34 <opqdonut> e.g. ascii :: Character -> Maybe Word8, unAscii :: Word8 -> Character
02:41:35 <merijn> Because it sounds like something that makes me sad >.>
02:42:20 <merijn> There's 'ord' and 'chr' but using those means you deserve all the misery you get :p
02:42:23 <merijn> :t ord
02:42:25 <lambdabot> Char -> Int
02:42:25 <merijn> :t chr
02:42:27 <lambdabot> Int -> Char
02:42:27 <opqdonut> yeah
02:43:27 <opqdonut> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html has utf8 utils for Bytestring<->Text, i.e. Word8<->Character conversions
02:43:56 <opqdonut> but I don't see ascii stuff
02:44:28 <merijn> What do you need/want ASCII for?
02:44:43 <opqdonut> I don't, I was just replying to reactormonk 
02:45:06 <merijn> I didn't necessarily mean you, I just missed the original question
02:45:22 <reactormonk> merijn, OAuth tokens via JSON
02:45:36 <merijn> Seems extremely rare you'd get ASCII JSON
02:45:42 <merijn> most JSON on the web is utf8
02:45:54 <reactormonk> Ok, Text it is
02:46:07 <merijn> Of course no one bothered to define what the proper encoding of JSON *should* be, because everyone involved with the web apparently likes pain
02:46:11 <opqdonut> right, for that sort of stuff I'd just use Text
02:46:26 <reactormonk> How do I pick a lens library?
02:46:41 <opqdonut> perhaps combined with some validation that checks that there aren't any nasty characters
02:46:46 <merijn> reactormonk: Additionally, utf8 has the nice property that if your text (through sheer luck) is only ascii the utf8 encoding is the same as ascii
02:46:59 <reactormonk> merijn, but Text isn't utf8?
02:47:49 <merijn> reactormonk: Text is unicode codepoints, and how they are stored internally isn't really relevant. You need to explicitly encode Text to whatever encoding you need when writing to a file/network
02:48:09 <merijn> reactormonk: Using, for example 'encodeUtf8 :: Text -> ByteString'
02:48:41 <merijn> Slightly related, just to clarify things, the name 'ByteString' is a ridiculous historical accident and you should pretend the type is really called 'Bytes'
03:00:17 <benneh> http://lpaste.net/351789 <- does this function exist anywhere already?
03:04:01 <opqdonut> benneh: isn't that just runState?
03:04:23 <opqdonut> hmm right but there might be a big transformer stack in the way
03:04:45 <orzo> there seems to be a pattern synonyms bug that causes the non-exhaustive pattern match warning
03:04:59 <merijn> orzo: Which version of GHC?
03:05:08 <orzo> 8.0.1
03:05:26 <orzo> i have pattern k :-> p <- (k,p,())
03:05:33 <benneh> opqdonut: they are similar, but not the same
03:05:34 <orzo> but when i match it, i get a warning
03:05:37 <merijn> orzo: As far as I know the exhaustive checking of pattern synonyms isn't completely finished yet
03:05:48 <cocreature> I think it will be in 8.2
03:06:15 <orzo> probably it should default to no-warning if it doesn't know
03:06:19 <merijn> orzo: So it's not a bug, as much as, this wasn't finished yet
03:06:27 <merijn> orzo: No, that'd be horrible
03:06:55 <merijn> orzo: You can easily silence the warning and the last you thing want is it silently not warning about a pattern that actually isn't exhaustive
03:07:40 <orzo> if i silence the warning by addin ganother match case, i'll get a new warning about it being redundant later when the exhaustiveness check is done
03:07:51 <orzo> heh
03:08:22 <orzo> plus it's code clutter
03:09:19 <merijn> orzo: Well yes, you get a redundant warning once it's finally fixed and then you can safely delete it. The other alternative is not giving a warning if the case could be non-exhaustive and you wind up getting paged at 4:30 AM because your code crashed on a missing pattern
03:34:15 <tarragon> hei
03:34:22 <tarragon> I recently installed pandoc
03:34:48 <tarragon> and I want to file a bug
03:36:31 <cocreature> tarragon: the pandoc bucktracker is on github https://github.com/jgm/pandoc/issues
03:37:01 <tarragon> is not really pandoc, because I realized pandoc is entirely coded with haskell
03:37:24 <tarragon> there's a particular dependency that irked me. At first I could'nt believe my eyes!
03:37:35 <tarragon> I thought it was a spelling error or something.
03:37:37 <ocharles> Does anyone know about the thread safety of IOVectors? Should I wrap them in an MVar if I'm going to operate on them concurrently?
03:39:38 <cocreature> ocharles: I just found this https://stackoverflow.com/questions/19967421/safe-parallel-use-of-mvector-iovector-from-haskell-vector-package suggesting that they are thread safe
03:40:05 <ocharles> cocreature: terrific. Thank you!
03:41:14 <cocreature> ocharles: it looks like it boils down to whether MutableArray# is thread safe
03:41:24 <ocharles> Yea, that seems to be the only mutable variable
03:42:06 <nickager> Hi, I'm parsing some CSV using http://hackage.haskell.org/package/cassava-0.4.5.1/docs/Data-Csv.html#v:decode It seems that only way to know that the `decode` API expects a lazy ByteString is by looking at the source (the Hackage documentation just shows `ByteString`). However IIUC https://wiki.haskell.org/Maintaining_laziness, indicates that as `decode` returns `Either String (Vector a)` then "This function cannot be lazy, because when you access the firs
03:42:06 <nickager> character of the result, it must already be computed, whether the result is Left or Right”. So ... is `decode` gaining anything by expecting a lazy ByteString rather than the non-lazy ByteString?
03:42:08 <MarcelineVQ> what do you mean by threadsafe for your use?
03:42:28 <cocreature> tarragon: if you have some specific question or problem, just ask :)
03:43:12 <lyxia> nickager: you can see that the ByteString type in the signature links to ByteString.Lazy
03:43:51 <nickager> @lyxia thanks I missed that
03:43:52 <lambdabot> Unknown command, try @list
03:44:59 <tarragon> why was haskell chosen for pandoc?
03:45:24 <lyxia> nickager: a lazy bytestring doesn't need to be in memory all at once to be consumed.
03:46:58 <cocreature> tarragon: I think “because the author likes it” is the best answer you are going to get for that question. he has written a bit about why he does so https://groups.google.com/forum/#!topic/pandoc-discuss/0rutNJAVKoc
03:47:08 <nickager> lyxia: so `decode` producing a non-lazy result, but does so efficiently using a lazy bytestring? 
03:47:20 <tarragon> cocreature: interesting i'll read
03:48:27 <tarragon> cocreature: I find interesting the election of this language for such a big and popular project. Haskell must restrict the contribution to it due to limited ppl knowing it.
03:49:27 <cocreature> tarragon: for most opensource projects the author choses the language he likes, not the one he expects most other people to know
03:50:16 <lyxia> nickager: efficiently meaning it doesn't hold the whole bytestring in memory at once
03:50:51 <tarragon> wow, can anybody explain  the difference of this statement? " If I were starting over, I'd use Text
03:50:54 <tarragon> everywhere instead of String."
03:50:58 <nickager> lyxia: thanks , that’s helped
03:51:07 <Insanity_> I have a problem that I _think_ I understand, but I would like to get some clarification: 
03:51:23 <Insanity_> I have made a small Haskell program that compares two sets, the data is in two separate CSV files
03:51:26 <tarragon> how does 'text' look different from 'string' in haskell or whatever his talking about?
03:51:47 <Insanity_> So I want to find the set-theoretic difference. I can read the files and then use the Data.List.\\ operator to compare the two sets (A \\ B) 
03:51:55 <zipper> tarragon: It's not about No. of contrib but quality of
03:52:05 <Insanity_> This seems to work well for files with just a few entries, but it does not work for quite large files (1000+ entries)
03:52:17 <Insanity_> Could Haskell's lazyness have anything to do with this, or should I be hunting for a bug?
03:52:18 <opqdonut> Insanity_: use Data.Set?
03:52:21 <roxxik> tarragon: String is a List of Char ([Char]) while Text is an opaque type backed by an array (i think)
03:52:39 <opqdonut> Insanity_: Data.List.\\ is quadratic (O(n^2))
03:53:06 <lpaste> Dylan pasted “No title” at http://lpaste.net/351791
03:53:10 <Insanity_> http://lpaste.net/351791
03:53:20 <Insanity_> Well, I should have given it a title, but that is the code
03:53:25 <Insanity_> opqdonut: thanks for that information
03:53:37 <Insanity_> I am not sure if that will solve the problem but I will try that now
03:53:48 <Insanity_> Though then I would have surely not understood the problem at hand :D
03:53:53 <roxxik> Insanity_: try with some hundred entries and time it
03:54:23 <Insanity_> oh wait I realise I might not have explained what the actual error is.. 
03:54:31 <Insanity_> The problem is that for large files, the output is incorrect
03:54:37 <tarragon> roxxik: so why is the pandoc author saying that 'text' is better than 'strins'?
03:54:46 <Insanity_> if I have a set of 1000+ lines, the result of A 
03:55:08 <Insanity_> A \\ B still contains the lines from B that it should not
03:55:26 <opqdonut> > [1,1,1] \\ [1]
03:55:31 <lambdabot>  [1,1]
03:55:33 <roxxik> tarragon: the whole discussion is all about performance. text won't do you anything if you don't care about performance. but if you do, you have to either pack and unpack alot, or rewrite to only use text
03:55:35 <opqdonut> Insanity_: see, \\ only removes one entry if there are multiple
03:56:29 <Insanity_> file A and B should be unique (I am getting data from Splunk, on which I am running 'distinct'), let me just verify that the data got through correctly
03:56:49 <roxxik> tarragon: first sentence from Data.Text doc: "A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed."
03:57:11 <Insanity_> opqdonut: yeah, the data is unique
03:57:26 <zipper> Insanity_: You're using readFile from Prelude, right?
03:57:34 <Insanity_> Yeah I am
03:59:53 <zipper> Insanity_: If you think it is laziness could you enable BangPatterns language extension and call it as so: `let difference = findSetTheoreticDifference (lineToList !aContent commaRegex) (lineToList !bContent commaRegex)`
04:00:02 <zipper> Insanity_: https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/bang-patterns.html
04:00:19 <zipper> That will force strictness and tell you whether laziness is the issue.
04:00:24 <merijn> Laziness won't result in wrong results
04:00:25 <opqdonut> zipper: err bang patterns don't work like that
04:00:38 <merijn> zipper: That's not a valid use of bang-patterns either
04:00:41 <opqdonut> zipper: and also forcing a list will only force the first cons-cell
04:00:43 <Insanity_> I thought it would maybe compare part of incomplete files merijn
04:00:56 <merijn> Insanity_: How big are your files?
04:01:24 <zipper> Oh well lucky I tried to help and got helped
04:01:30 <zipper> opqdonut: How do they work?
04:01:32 <zipper> hmmmm
04:01:40 <Insanity_> one is about 1.5k lines, the other is 709 entries (csv)
04:01:43 <zipper> Seems that's what I kind find 
04:01:54 <zipper> That's not too much for a modern computer
04:02:03 <zipper> 1.5 k lines aint much
04:02:22 <zipper> That's like 300KB file?
04:02:24 <Insanity_> No, I thought so as well. But I am not sure how the whole lazy deal works in Haskell :-)
04:02:24 <zipper> at most?
04:02:29 <opqdonut> zipper: you use them in a pattern, e.g. a function definition "f :: Int -> Int -> String; f !x !y = show (x+y)"
04:02:35 <merijn> Insanity_: Honestly, you should probably not be using readFile for Prelude for this to begin with
04:02:49 <zipper> merijn: Yeah lazy bytestring?
04:02:54 <merijn> No, Text
04:02:58 <opqdonut> Insanity_: merijn: but it should work using readFile
04:03:04 <merijn> opqdonut: Agreed
04:03:16 <Insanity_> opqdonut/merijn: Well, that puts me back in square one :-) 
04:03:19 <zipper> merijn: When should I use bytestring over text and vice versa?
04:03:33 <zipper> I see stuff that reads over the net uses bytestring
04:03:35 <opqdonut> zipper: bytestring for binary, text for text
04:03:36 <merijn> zipper: Simple answer: pretend 'ByteString' is called 'Bytes'
04:03:49 <zipper> I assume because you can have yeah binary data like pics over the wire
04:03:54 <merijn> zipper: The name is an unfortunate historical accident and it has nothing to do with strings
04:03:55 <zipper> I see
04:04:11 <zipper> For example:
04:04:24 <zipper> :t Network.Wreq.get
04:04:27 <lambdabot> error:
04:04:27 <lambdabot>     Not in scope: ‘Network.Wreq.get’
04:04:27 <lambdabot>     No module named ‘Network.Wreq’ is imported.
04:04:30 <merijn> Other than "unicode strings can be encoded as binary data"
04:05:17 <merijn> zipper: So normally when you talk on the network you get binary data and if you want to treat it as Text you need to know how it's encoded and then decode from binary to Text
04:05:20 <Insanity_> merijn: If lazyness is not the issue, do you have any idea where the issue might be regardless of that? 
04:05:46 <merijn> Insanity_: tbh, I just saw 4 lines of code out of context and I don't know what the types/implementations of anything are
04:05:51 <zipper> Insanity_: Do you have any idea where it breaks?
04:06:01 <zipper> Insanity_: print debugging?
04:06:11 <zipper> Do you actually read both files?
04:06:21 <Insanity_> Well there really is not much else to it apart from those lines. I can show you the missing lines (which is two of them) 
04:06:33 <Insanity_> And the odd thing is that it does work for all other files I tested that are smaller
04:07:38 <lpaste> Dylan revised “No title”: “compare-csv-files” at http://lpaste.net/351791
04:07:39 <zipper> Insanity_: You should find out Line x finishes execution but Line x+1 doesn't. Then try figure out what happens at the point of breakage.
04:08:16 <Insanity_> I'll see if I can find some more information about the point where it breaks exactly :-)
04:08:48 <merijn> Insanity_: So, why are you using lists and \\ rather than Set for set difference?
04:09:06 <Insanity_> Because I only found out about that about 5 minutes ago ^^ 
04:09:22 <merijn> Insanity_: I have no clue what lineToList does, btw
04:09:22 <Insanity_> I am still very much learning Haskell on the side :p
04:09:25 <Insanity_> ah
04:09:27 <merijn> Set will be faster and more efficient
04:09:28 <Insanity_> splitRegex regex input
04:09:47 <Insanity_> just splits the line of input with the regex mkRegex ","
04:10:06 <Insanity_> Yeah someone explained that to me a bit earlier, I will revise that
04:11:09 <zipper> Maybe your "parsing" is failing.
04:13:58 <Insanity_> zipper: Good point, perhaps the output of some of the entries has different line endings or something subtle. I'll check with smaller files with just the failing entries
04:15:11 <merijn> If you have quoted columns inside your CSV this fails horribly anyway
04:15:32 <zipper> Insanity_: How about a better debugging method than manually reading a CSV file you guys.
04:16:05 <merijn> tbh, I would start with just getting a CSV parser
04:16:17 <Insanity_> Well yeah.. We actually do have one.. We are writing in Java normally
04:16:18 <zipper> :)
04:16:28 <Insanity_> I just wanted to see if I could get something quick out of Haskell to do the same thing :p
04:16:52 <zipper> Insanity_: Call lineToList with each file in the repl
04:17:10 <zipper> In the repl readFile  then lineToList
04:17:15 <zipper>  then for the second file
04:17:48 <zipper> Ok this is offtopic Haskell and now into general debugging 
04:19:20 <Insanity_> Thanks, I'll play around with it and see ;-) 
04:24:51 <Insanity_> *facepalm* you put me on the right track zipper. The issue was actually one of the CSV files being spit out of some of our tools not generating pretty CSV files, but the viewer handled it correctly.. Anyway, after a small fix to the files it now works
04:30:22 <zipper> So a CSV file not being pretty printed breaks haskell's readFile?
04:30:28 <zipper> Insanity_: ^
04:31:29 <merijn> zipper: No, it breaks his "parser"
04:32:04 <Insanity_> merijn: Yeah well, the "parser" in Haskell was correct, but well, when one of the tools misses putting a "comma" in, it's a pretty CSV generater
04:32:09 <Insanity_> pretty shitty*
04:32:23 <merijn> Ah, I suppose that could also happen :p
04:32:44 <Insanity_> Yeah, it shouldn't, but it did :p
04:33:18 <be5invis> you know, sometimes i have strange imaginations, like: in the Cold War, Russians choose to use ternary computers with a purely functional language...
04:34:05 <be5invis> they are completely separated from the western world, and their mathematicians, like Kolmogorov, decided to build their own computer and the entire theory...
04:38:05 <_deafbeef> hello folks, windows 10 64-bit user here, using stack; I've tried following the official documentation on compiling DLLs for foreign languages, over at this page: https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/win32-dlls.html#making-dlls-to-be-called-from-other-languages
04:38:47 <_deafbeef> here is the result, all the files are the same as in the documentation, except for the changes that are explicitly stated in the following picture: https://i.snag.gy/zFv9wa.jpg
04:38:50 <_deafbeef> any help welcome!
04:43:50 <Profpatsch> Is there a module annotation to disable a certain kind of warning?
04:44:19 <Profpatsch> I’d like to disable -Wtype-defaults and -Wmissing-signatures for one module of mine
04:44:20 <Profpatsch> .
04:45:05 <lyxia> {-# GHC_OPTIONS -Wno-type-defaults #-} ?
04:45:06 <merijn> Profpatsch: I think you can use a pragma to indicate flags to use when compiling a module
04:45:16 <merijn> Profpatsch: But it's a bit...questionable
04:45:28 <merijn> I'd hate having to open every file to see which flags it uses
04:45:50 <merijn> Profpatsch: Why not just add type signatures to avoid both warnings?
04:50:58 <Profpatsch> merijn: It’s a Resource.hs, which basically contains all my applications user-facing texts as functions.
04:52:38 <Profpatsch> merijn: {-# GHC_OPTIONS -Wno-type-defaults -Wno-missing-signatures #-}
04:52:48 <Profpatsch> gives me “unrecognized pragma”
04:53:19 <merijn> Suppose I have an N-dimensional space of hypercubes and want to find the change hyperplanes (i.e., where there's a change in the hypercubes bisecting the plane in that dimension), any pointers in data structures/algorithms I wanna look at?
04:53:23 <lyxia> oh, it's OPTIONS_GHC https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#options-ghc-pragma
04:54:03 <Profpatsch> lyxia: Nice, thanks.
04:54:35 <Profpatsch> That way I can have -Wall and selectively disable warnings if I’m sure they are okay.
04:55:14 <merijn> Profpatsch: But if you're sure they're ok why not just add annotations to avoid them in the first place?
04:55:35 <Profpatsch> merijn: Because that’s a lot of typing for a lot of messages.
04:55:56 <Profpatsch> It’s just boilerplate in that case.
04:56:05 <Profpatsch> Especially since I added a
04:56:12 <Profpatsch> default (Text)
04:56:17 <Profpatsch> at the top of the module.
04:56:52 <Profpatsch> So that GHC doesn’t default the strings to [Char]
04:57:55 <merijn> *shrug*
04:58:42 <merijn> Bleh, I know there must be some research on what I want to do, but I'll be damned if I can come up with the right terms to find it...
04:59:54 <hpc> just search arxiv for "finding the thing i want on arxiv"
05:00:25 <merijn> hpc: >.>
05:10:35 <merijn> hpc: It's times like these that I wish this completely unrealistic semantic web thing took off :p
05:12:19 <merijn> Or that the math nerds were awake while I work >.>
05:13:05 <hpc> it's times like these i wish i understood your original problem ;)
05:13:25 <merijn> hpc: It's actually not even that complicated!
05:14:43 <Profpatsch> It’s everyday programmer’s stuff of course
05:14:50 <merijn> hpc: Suppose you have a 3D space you could partition it into a set of cubes of different sizes, yes? Now I can take the intersection of this 3D space in any of it's 3 dimensions and basically see a cross-section
05:14:53 <osa1> anyone knows a good way to generate NominalDiffTimes in a given range in QuickCheck?
05:15:11 <Profpatsch> ==> ?
05:15:16 <merijn> hpc: Now, I want to find the points (in all 3 dimensions) where the squares in this cross-section change
05:15:42 <merijn> hpc: Except, I wanna do all this for a number of dimensions N where N > 3 :p
05:15:42 <hpc> so collision detection?
05:15:47 <hpc> in higher dimensions
05:15:49 <merijn> hpc: Not quite
05:16:06 <merijn> hpc: Or maybe it is? I'm not sure :p
05:16:25 <hpc> you have one thing, the hypercube
05:16:29 <hpc> and another thing, the hyperplane
05:16:34 <hpc> and you want to see how they touch
05:16:39 <merijn> hpc: Not quite
05:17:12 <merijn> hpc: Suppose I take the cross section at X=1 and X=2 the cubes in the cross section might be different, yes?
05:17:29 <merijn> I want to find the exact X point at which the cubes in the cross-section change
05:17:56 <hpc> ah
05:18:10 <lyxia> osa1: generate an Integer within some range and use fromInteger?
05:18:20 <osa1> lyxia: I need sub-second precision
05:18:26 <osa1> forgot to mention
05:18:48 <merijn> hpc: Which, while rather specific, seems like the kind of problem someone somewhere already solved :p
05:21:23 <lyxia> osa1: then you can use fromRational
05:22:08 <lyxia> or do divisions
05:22:25 <_deafbeef> is there no one awake that has insights on my ghc + DLLs conundrum? :\ 
05:22:32 <osa1> lyxia: it's still annoying bauase `Ratio Int` is not an instance of Random so `choose` doesn't work
05:24:01 <merijn> _deafbeef: I suspect the majority of people are not working on Windows and thus feel unqualified to comment
05:24:02 <osa1> anyway, that's not too hard using ratios, just annoying
05:24:18 <merijn> _deafbeef: You might want to try the mailing lists to have a better chance at reaching people using Windows
05:29:34 <Profpatsch> Is it just me or should GHC handle error messages involving type aliases differently?
05:29:42 <Profpatsch> That is expand them less confusingly?
05:29:57 <Profpatsch>     • Couldn't match type ‘L.HtmlT Identity ()’ with ‘Text’
05:29:59 <Profpatsch>       Expected type: Text.Digestive.View.View Text -> Text
05:30:01 <Profpatsch>         Actual type: Text.Digestive.View.View (L.Html ()) -> Text
05:30:21 <Profpatsch> In this case it’s easy to see that Html () = HtmlT Identity ()
05:30:48 <Profpatsch> But when you have servant API type aliases, it gets very, very, very interesting
05:31:52 <lyxia> Things can definitely be improved.
05:32:19 <merijn> Profpatsch: GHC tries to use the tpe alias as used in the signatures it reads
05:32:33 <merijn> Profpatsch: Whether that's always desirable is debatable
05:48:12 <_deafbeef> oh okay merijn, thanks for the suggestions
05:48:53 <_deafbeef> the compilation process is pretty much equivalent in linux though, I tried the same steps in ubuntu gnome
05:49:04 <_deafbeef> the result of the process, I mean
05:50:11 <zipper> LOL why write haskell if you plan not to write type sigs? "merijn | Profpatsch: Why not just add type signatures to avoid both warnings?"
05:50:33 <zipper> :)
05:50:58 <grr12314> yo
05:51:30 <zipper> Profpatsch: Can't typeholes help you figure it out? Then you add whatever you get from GHC?
05:51:48 <zipper> grr12314: Hello
05:52:47 <grr12314> why it seems impossible to make a simple function that takes no args and returns an infinite list of strings read from stdin?
05:53:04 <grr12314> without any io traces in its return type
05:53:20 <jophish> grr12314: that's because reading from stdin requires IO
05:53:47 <zipper> "infinite list of strings read from stdin"?
05:53:49 <grr12314> but cant the function handle it internally and just return the list
05:53:58 <zipper> Like asking the user to press enter every time?
05:54:10 <jophish> It is possible to make this, something like: IO [String], however I'd stronly recommend to avoid this as lazy IO can be a huge headache
05:54:15 <grr12314> and the action happens only when you need a list item
05:54:19 <zipper> Like a loop for forever with getArgs?
05:54:24 <zipper> :t forever
05:54:27 <lambdabot> Applicative f => f a -> f b
05:55:00 <zipper> Sorry, not getArgs, getLine or whatever
05:55:29 <zipper> Ok idk what I'm talking about I'm going to just stfu and see what jophish says
05:56:49 <jophish> grr12314: the problem is that 'the action' has the type 'IO String'.
05:56:52 <Ferdirand> :t interact
05:56:57 <lambdabot> (String -> String) -> IO ()
05:57:13 <zipper> jophish: What did he mean by handle it internally?
05:57:34 <grr12314> yeah like you said zipper, like a infinite loop with getLine
05:58:24 <grr12314> ok im trying to wrap my head around it but i guess i'll need some actual programs before i can 
05:59:24 <zipper> grr12314: You can write that eaily as `forever getLine`
05:59:43 <zipper> With an if to check for a string like stop
05:59:47 <zipper> "stop"
05:59:58 <zipper> to stop the forever
06:00:09 <jophish> grr12314: what do you want to do with the string you get from the line on stdin?
06:00:29 <Ferdirand> is lazy IO really such a huge headache, when you are reading from a pipe ?
06:00:43 <Ferdirand> or any non-seekable fd
06:00:50 <grr12314> well its more generic and theoretical question
06:00:59 <merijn> Ferdirand: It depends
06:01:00 <grr12314> i might want to takeWhile or whassname
06:01:29 <jophish> Ferdirand: That's probably one of the better cases for it, but there could still be problems wrt resource ownership
06:01:35 <merijn> jophish: I'm not quite sure what lazy IO has to do with this entire issue?
06:02:09 <lyxia> " and the action happens only when you need a list item"  <- this is lazy IO
06:02:16 <jophish> merijn: grr12314 seemed to want a value with type 'IO [String]'. Where the list was an infinite list of lines from stdin
06:02:42 <grr12314> yeah except without the IO part, but i get its impossible
06:03:00 <lyxia> it's actually possible with unsafePerformIO
06:03:17 <merijn> lyxia: You're not helping
06:04:01 <merijn> Telling beginners about unsafePerformIO is about as helpful as handing handguns to toddlers, it's only going to get them hurt
06:04:13 <lyxia> But this is exactly what grr12314 asked.
06:04:26 <AWizzArd> In “Learn You A Haskell” the author said that when opening a text file in ReadMode then under the hood it is buffered line-wise. Is there a way to overwrite this default behaviour, i.e. I know that a file contains gigabyte-sized lines?
06:04:32 <grr12314> im just trying to understand how all that io action stuff and why it is so sticky and hard to get rid of. but i guess its just a quirk i have to get used to
06:04:42 <merijn> lyxia: And much like with the malevolent genie in a bottle people don't always want what they wish for
06:05:24 <AWizzArd> Oh okay sorry, nevermind. It’s explained just in the next paragraph.
06:05:27 <jophish> grr12314: It's impossible to get rid of because if one could get rid of it one could write functions which appear not to deal with the outside world on the surface, but underneath launch missiles or whatever
06:05:51 <grr12314> i have to do some hello-world types of puzzles in haskell instead of just trying to theorize about it i guess
06:05:55 <merijn> grr12314: It's not so much a quirk as a foundational principle. To keep the language pure (which roughly translates to "whenever you call a function with the exact same arguments, you should get the exact same results) you can't allow side-effects, so effects must be accounted for in the type system
06:06:06 <jophish> what most programs do is have some "shell" on the outside which handles all the IO, and do some interesting pure computation underneath
06:06:57 <grr12314> yeah and a way to generic-alize that shell
06:07:09 <merijn> grr12314: Take 'getLine :: IO String', suppose this would be, instead 'getLine :: () -> String' and read a line from stdin, then clearly 'getLine ()' and 'getLine ()' wouldn't necessarily be the same
06:07:14 <grr12314> is to maybe have a function that accepts all stdin as [String]
06:07:27 <jophish> there are some neat and safe ways to do what you want, only reading a line when it's required (pipes, conduits etc...) however these libraries can be a little complicated to use sometimes and it might be best to start with something simpler
06:07:49 <jophish> grr12314: is your stdin finite?
06:08:42 <grr12314> yes, but assume i read the number of items or something so i know not to step over the limit
06:08:43 <jophish> because there does exist the function "getContents" which returns the whole of stdin as a string. Beware though, this function will not terminate if the input is unbounded.
06:08:49 <grr12314> like in programming puzzles
06:09:18 <merijn> grr12314: So, instead of actually reading something from stdin, why don't we define a notion of 'program fragment' or 'action' that *describes* a behaviour, without actually *performing* it. Which is roughly what IO is, 'getLine :: IO String' is the description of 'reading a line from stdin', and that description is always the same (thus pure), but executing such descriptions may end up yielding different 
06:09:24 <merijn> results. But the actual execution is not observable *inside* haskell
06:09:26 <jophish> usually what I do for these things is define a data type for the pizzle input, and write a parser which goes from String to that type
06:09:30 <jophish> then use that with getContents
06:12:25 <Ferdirand> :t lines <$> getContents
06:12:27 <lambdabot> IO [String]
06:14:49 <grr12314> hm i guess im starting to see the light. or an incoming train, not sure
06:15:00 <Ferdirand> :t (\f -> interact (unlines . f . lines))
06:15:01 <lambdabot> ([String] -> [String]) -> IO ()
06:15:25 <grr12314> i just realized that even if i had an infinite [String] and wanted to use it with functions that take some elements from it and process it
06:15:38 <grr12314> i'll still have to pass around "resto of list" between them
06:15:54 <grr12314> so its pretty much like passing around IO
06:16:09 <Ferdirand> congratulations, you just grokked (part of) monads
06:16:50 <merijn> This really has nothing to do with monads, tbh
06:16:53 <piyush-kurur>  does anyone know how to put the contents of readme directly into the starting page of package
06:17:01 <Ferdirand> shhh, it's motivational
06:17:18 <piyush-kurur> I mean usually the staring page is generated from the .cabal file
06:18:01 <Ferdirand> but if you use getLine then do-notation is the sugar you need to have this IO passing behind the scenes, right ?
06:18:36 <merijn> You're not "passing" IO
06:18:59 <merijn> The point is, you can have IO in your language without monads and you could use monads in an impure language without IO
06:20:01 <merijn> It's just a happy coincidence that the interface for dealing with IO happens to nicely match the interface Monad provides.
06:52:27 <Ferdirand> merijn: well, my point is, you can model IO as State RealWorld, grr12314 seemed to have an intuition of that
06:52:45 <Ferdirand> okay maybe it would have been more correct to say they grokked the state monad
06:53:09 <c_wraith> I think that's a terrible way to think of IO.
06:53:15 <merijn> c_wraith++
06:53:23 <merijn> RealWorld is a filthy lie
06:53:41 <merijn> And breaks as soon as we talk about concurrency
06:53:49 <RyanGlScott> I have a singletons question
06:53:56 <RyanGlScott> I know how to use singletons to promote values to the type level
06:54:02 <RyanGlScott> But is it possible to do the reverse?
06:54:08 <RyanGlScott> e.g., in Idris you have this definition:
06:54:11 <RyanGlScott> the : (a : Type) -> (value : a) -> a; the _ = id
06:54:22 <c_wraith> It's much better to think of IO as a free monad with a primitive operation corresponding to "run this native code"
06:54:27 <RyanGlScott> Is it possible to write something morally equivalent to this today using singletons?
06:55:18 <c_wraith> That's not how it's actually implemented, but it gives you the correct mental model for IO.
06:55:51 <merijn> RyanGlScott: If you enjoy lots of pain, then you can approximate it
06:56:05 <RyanGlScott> Well, I didn't come for a haircut. How much pain are we talking? :)
06:56:16 <c_wraith> search for "Hasochism". :)
06:56:18 <merijn> RyanGlScott: The original paper is called 'Hasochism' ;)
06:56:50 <merijn> I believe Stephanie (Weirich) has a few papers on it too
07:01:09 <RyanGlScott> c_wraith, merijn: Thanks. It's not immediately obvious where in the paper they discuss this trick, though, so I'll have to read it more carefully.
07:01:46 <Tuplanolla> I take it you're familiar with how `Proxy` and `ScopedTypeVariables` allow something similar, RyanGlScott.
07:02:45 <RyanGlScott> Tuplanolla: Sure. I was just wondering if singletons provided some sugar for this sort pattern.
07:02:56 <RyanGlScott> Or perhaps the answer really is "just use Proxy/TypeApplications"
07:02:56 <merijn> RyanGlScott: I recall a paper on a "dependent" red-black tree for GHC by Stephanie, but I can't quickly find it
07:04:54 <merijn> RyanGlScott: I think that one included reifying the type-level depth at runtime
07:05:04 <RyanGlScott> Actually, I think that is the answer, according to slide 27 of https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf
07:05:23 <RyanGlScott> Weirich identifies (x : A) -> B with forall (x :: A). Sing x -> B
07:06:23 <RyanGlScott> She also talks about red-black trees in that presentation, too
07:06:45 <merijn> RyanGlScott: Yeah, that's the one I was thinking of, except there's also a full paper iirc
07:09:26 <roxxik> grr12314: i'm a little late to this discussion, but if you want to know the details: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
07:13:29 <roxxik> one mistake in there is using "IO Monad" too often, while it should read "IO Type", this way of doing IO is called monadic IO for the reason that monads were new at that time and there were already other aproaches to IO. it's true, that the IO Type supports monadic composition (there is an instance Monad IO), and thus allows us to programm imperatively
07:14:24 <roxxik> note: https://blog.jle.im/entry/io-monad-considered-harmful.html
07:33:38 <orion> What's the current consensus on postgres migration in Haskell?
07:35:01 <jophish> orion: I looked into this quite carefully recently. I settled on using postgresql-simple-migration
07:35:24 <jophish> dbrecord-opaleye looks very promising, but it's not in a usable state at the moment
07:36:12 <jophish> I started writing some fancy automatic conversion functionality myself, but determined that I'd never save time doing that compared to just writing the SQL by hand, and using p-s-m
07:37:59 <Profpatsch>     ifE f = if errs /= [] then f else id
07:38:03 <jophish> It's really easy to use, however it only handles a linear sequence of migrations, nothing fancy.
07:38:07 <Profpatsch> I’m missing a combinator, aren’t I?
07:39:04 <jophish> Profpatsch: you can use `null` instead of `== []`
07:39:22 <jophish> but I think you wanted to replace all of 'ifE'
07:40:04 <orion> jophish: I guess postgresql-simple-migration is intended to be used with postgresql-simple? How is that package?
07:40:28 <jophish> orion: I've not had anything to do with it. I use opaleye for everything
07:40:36 <jophish> (aside from one command when setting up the db)
07:42:12 <Profpatsch> jophish: Yes; do you know if null is more performant than /= []?
07:43:18 <jophish> well, both are going to be very cheap.
07:43:25 <roxxik> just lookup instance Eq a => Eq [a] and null
07:43:31 <jophish> null doesn't require passing a dictionary around though
07:43:37 <roxxik> should both break down to a pattern match
07:45:10 <Profpatsch> For Text the null function matches on the internal len field and checks len <= 0
07:45:40 <Profpatsch> For [] it just pattern matches
07:46:15 <orion> jophish: Are you happy with opaleye?
07:46:47 <jophish> orion: for the most part :)
07:48:57 <Profpatsch> :exf Bool -> (a -> b) -> a -> b
07:49:02 <exferenceBot> \ b1 f2 c -> f2 (bool c c b1)
07:50:48 <roxxik> ?src null
07:50:48 <lambdabot> null []    = True
07:50:48 <lambdabot> null (_:_) = False
07:50:56 <roxxik> ?src (==)
07:50:56 <lambdabot> x == y = not (x /= y)
07:51:02 <roxxik> ?src (==) @ []
07:51:02 <lambdabot> Source not found. Take a stress pill and think things over.
07:51:05 <roxxik> hmmm
07:51:23 <quchen> It’s a static database.
07:51:27 <roxxik> oh
07:51:29 <quchen> No fanciness involved.
07:51:31 <quchen> Lambdabot @src database: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source 
07:51:42 <Vtec234> wait, what
07:51:49 <Vtec234> ?src (/=)
07:51:49 <lambdabot> x /= y = not (x == y)
07:51:55 <Vtec234> ?src (==)
07:51:55 <lambdabot> x == y = not (x /= y)
07:51:57 * shapr hops randomly
07:51:57 <Vtec234> what
07:52:02 <shapr> Vq: GOOD MORNING!
07:52:21 <roxxik> ?src [] (==)
07:52:21 <lambdabot> []     == []     = True
07:52:21 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
07:52:21 <lambdabot> _      == _      = False
07:53:15 <Vtec234> why is equality defined in terms of inequality defined in terms of equality defined in terms of inequality defined in terms of equality defined in terms of inequality defined in <<STACK OVERFLOW>>
07:53:25 <lyxia> Vtec234: these are just the default implementations. you're supposed to provide at least one of (==) or (/=) when defining the instance
07:53:40 <lyxia> Vtec234: the default implementation then takes care of defining the other
07:54:29 <roxxik> in the docs it says `Minimal complete definition: (==) | (/=)` ;)
07:54:38 <jophish> Profpatsch: did you mean : Bool -> (a -> a) -> a -> a ?
07:55:07 <ph88> hi guys, i'm getting this error about Arbitrary https://paste.fedoraproject.org/541149/14857916/ i'm staring a bit blind here, anyone some pointers on what i could check to figure out why this error occurs ?
07:56:21 <roxxik> :exf (s -> (a,s)) -> (a -> s -> (b,s)) -> s -> (b,s)
07:56:22 <exferenceBot> \ f1 f2 c -> let ((,) g h) = f1 c in f2 g h
07:56:52 <ph88> i guess i will just try to reduce the type until the error goes away :/
07:57:35 <roxxik> :exf Maybe a -> (a -> Maybe b) -> Maybe b
07:57:35 <exferenceBot> (Control.Monad.>>=)
07:57:46 <roxxik> oh... that's a little disappointing
07:58:55 <Profpatsch> jophish: Well, I meant f b g = bool id g b
07:59:31 <roxxik> :exf ((a -> r) -> r) -> (a -> ((b -> r) -> r) -> ((b -> r) -> r)
07:59:32 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 60) "Parse error: EOF"
07:59:38 <roxxik> :exf ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
07:59:38 <exferenceBot> \ f1 f2 f3 -> f1 (\ f -> f2 f f3)
08:00:07 <roxxik> it's nice how the bind implementations (minus newtypes) can just be derived
08:01:02 <roxxik> :t \f1 f2 f3 -> f1 (\f -> f2 f f3)
08:01:04 <lambdabot> ((t1 -> t3) -> t) -> (t1 -> t2 -> t3) -> t2 -> t
08:03:54 <ph88> lyxia, do you have an idea perhaps? i just tested, if i put 5 things in that tuple it works, at the 6th it breaks
08:07:22 <lyxia> ph88: what version of quickcheck are you using
08:08:10 <ph88> QuickCheck-2.8.2
08:08:56 <Xnuk> ??ㄱ자
08:09:00 <Xnuk> sorry
08:10:01 <lep-delete> ㅅㅅ
08:10:19 <lyxia> ph88: Arbitrary for 6-tuples was added in 2.9
08:10:38 <lyxia> the blame is here https://github.com/nick8325/quickcheck/blame/master/Test/QuickCheck/Arbitrary.hs#L550
08:10:39 <ph88> :(
08:11:00 <ph88> perhaps i can say to stack to use this newer quickcheck version ?
08:11:15 <benneh> http://lpaste.net/351789 <- Does this function exist anywhere already? It looks a bit like runStateT, but it's not.
08:11:33 <ph88> why was the blame there ?  the highlighted line is a 7-tuple
08:11:53 <lyxia> ph88: oh you're right, I forgot to move the highlight up
08:12:18 <ph88> but the 6-tuple looks ok to me, don't see a mistake
08:12:38 <lyxia> there's no mistake
08:12:43 <lyxia> it's just not in your version
08:13:11 <lyxia> ph88: my point was that the commit where these instances were included happened after 2.8.2.
08:13:14 <ph88> i'm on lts-7.15 too bad it still had the old QC :/
08:13:21 <ph88> ah ok cool
08:13:23 <ph88> thanks for looking
08:14:04 <lyxia> I'd say go for it if you can upgrade quickcheck.
08:14:35 <ph88> i will try to add it as extra-deps in stack.yaml
08:14:46 <ph88> the latest lts is still on quickcheck-2.8.2  don't know why
08:16:32 <MarcelineVQ> the lts's goal isn't to be up to date, if you want more bleeding edge you might use the nightly resolver, or extra-deps
08:17:11 <ph88> oh well the new lts releases happen so quickly that i already felt like i was on bleeding edge :P
08:17:16 <MarcelineVQ> possibly in this case you could even just copy that arbitrary instance, I"m not sure how generics work and all that
08:17:21 <ph88> every time i start a new project it gets to a new lts release
08:20:51 <nogid> Can someone debunk this? C++ is pure: Consider that a C++ program actually runs at compile time (type system computations, constexpr evaluations). When the runtime loader (ld-linux.so) interprets the resulting binary, it is merely following the computation recipe returned by the C++ program at compile time. So all side-effects occur outside of the scope of the C++ program.
08:21:04 <nitrix> ph88: Maybe it's Haskell that cannot keep up with you!
08:21:32 <nitrix> ph88: Everyday, new project :P ?
08:21:39 <tdammers> nogid: it's a stab at how Haskell "cheats" itself into being pure by declaring its runtime to be outside the realm of the language itself
08:21:49 <MarcelineVQ> i don't really care what c++ does, not that I represent any significant opinion
08:21:59 <Cale> nogid: Well, those parts of a C++ program are pure, but that doesn't really constitute very much of the execution of a typical C++ program
08:22:04 <tdammers> nogid: the takeaway is that whether a language is pure or not is a matter of how you define its boundaries
08:22:24 <ph88> nitrix, no no, more like every day new lts and 1 new project a month :P
08:22:39 <nogid> tdammers: what has me stumped is that any argument that works can be applied just the same to Haskell's IO monad
08:22:40 <quchen> The universe is a closed system in the same way C++ is pure. If you make a circle big enough, everything’s on the inside.
08:22:48 <Cale> nogid: Haskell is interesting because you can actually write a significant fraction of your program in a setting where effects don't occur.
08:23:03 <Cale> nogid: Nobody's claiming that execution of IO actions is pure.
08:23:04 <tdammers> nogid: not really; IO itself is pure, the runtime that interprets it is not
08:23:43 <Cale> But *evaluation* in Haskell is pure (deterministic, referentially transparent, effect free).
08:23:59 <dfeuer> Except for lazy IO.
08:23:59 <nogid> tdammers: couldn't you say "C++ compilation is pure, the runtime that interprets it is not"?
08:24:10 <Cale> dfeuer: Yes, that's fair enough :)
08:24:28 <tdammers> nogid: that would be a bit confusing, considering how compilation is impure in the sense that it reads source files and writes object files
08:24:42 <nogid> So evaluation in Haskell is the equivalent of compilation in C++, and evaluation in C++ is the equivalent of interpretation in Haskell?
08:24:47 <nogid> Just a matter of terminology?
08:24:59 <nitrix> nogid: You're conflating compilation, execution and evaluation.
08:25:04 <dfeuer> Cale: also see https://ghc.haskell.org/trac/ghc/ticket/11760 for an interesting bug.
08:25:09 <Cale> nogid: Well, "equivalent" until you actually consider what those things accomplish.
08:25:28 <ph88> lyxia, i just compiled all the rules of my parser for the first time :D now i still have to implement all the pretty printers (which there was a generic pretty print) and after that i have to run it with quickcheck. And quickcheck will find bugs because i need a symbol table which i have not implemented yet
08:26:09 <nogid> Cale: C++ can do any arbitrary computation at compile time, and any pure computation at runtime.
08:26:29 <Cale> nogid: "Can do" and "It's reasonable to architect your software that way" are two very different things.
08:26:41 <Vtec234> nogid: i think you meant it the other way around
08:27:00 <nogid> Vtec234: I mean it can do both. Anything at compile-time is necessarily pure.
08:27:03 <Cale> and yeah, you meant the other way around
08:27:08 <nogid> Vtec234: But you can also do pure computations at runtime
08:27:11 <nitrix> nogid: I highly doubt you can query a remote server during compilation.
08:27:25 <Vtec234> nogid: pure at compile time, arbitrary at runtime. it cannot do arbitrary things at compile-time
08:27:30 <nitrix> nogid: You must've meant the reverse.
08:27:32 <nogid> nitrix: But haskell can't query a remote server during evaluation time! Only at *interpretation* time
08:27:53 <nogid> and interpretation is by no means pure
08:28:01 <tdammers> actually, haskell can query remote servers at compile time
08:28:05 <nogid> it's just shifting the definitions
08:28:10 <tdammers> with TemplateHaskell at least
08:28:14 <nogid> well so Haskell is even less pure than C++ ;)
08:28:20 <nogid> if it can do that during compilation time
08:28:30 <mmaruseacph2> only with certain extensions
08:28:40 <nogid> I know, I'm just joking now, but it's something to be considered
08:28:41 <Cale> nogid: But even so, practically nobody encodes very much of the work that their C++ program has to do as template expansion, because that is entirely unreasonable -- the language is very much not designed to make that easy.
08:28:42 <nitrix> nogid: These extensions aren't Haskell though.
08:28:43 <mmaruseacph2> and those extensions place the onus on the programmer to ensure correctnes
08:28:58 <ph88> anyone know of a generic pretty printer that doesn't print stuff like  show  prints it ?
08:29:22 <Cale> nogid: The template language, while Turing complete, is just not very expressive.
08:29:22 <tdammers> actually TH doesn't do that; it still maintains the pure evaluation / impure execution separation
08:29:31 <nogid> Cale: but C++ programs are very often structured in a way such that individual functions are side-effect free
08:29:52 <tdammers> it's just that it allows you to hook into a compile-time cycle of evaluation and execution as well
08:29:54 <Cale> nogid: Sure, but you can't take advantage of, or rely upon this in any way.,
08:29:55 <quchen> ph88: This one formats Show stuff nicely, https://hackage.haskell.org/package/show-prettyprint
08:29:57 <nogid> Cale: the implementation details of those functions may leverage side-effects and mutations as a performance optimization, but that's entirely invisible from the outside
08:30:25 <tdammers> so you write pure code that gets executed by an impure runtime to generate AST for pure code that gets executed by an impure runtime
08:30:41 <nogid> tdammers: pretty much
08:30:44 <ph88> quchen, that package outputs stuff like show!
08:30:47 <Cale> nogid: The C++ type system can't tell you that they're side effect free, the compiler may or may not be able to discover it and leverage it, but as a programmer, there's no way of knowing without carefully inspecting every line of source code.
08:30:57 <quchen> ph88: Except for readability, yes.
08:31:08 <nitrix> nogid: You're still confused. For the sake of simplicity, I'll bundle execution and evaluation together, but in reality, these also have important distinction in the context of a lazy-evaluated language like Haskell. Which leaves us with two parts to talk about: the language according to the specification and the runtime that runs it.
08:31:09 <ph88> yes but i don't want that :/
08:31:51 <ph88> quchen, when i have tuple ("hello ", "world")  i want "hello world"  and not  "(\"hello \", \"world\")"
08:31:51 <nitrix> nogid: With Haskell, your entire program is pure and its purpose is to build an ever increasingly complex IO "recipe", which is then given to the runtime system.
08:32:13 <quchen> ph88: If you’re looking for a prettyprinter, the wl-pprint universe is the de facto standard, with many choices available. wl-pprint-ansi is currently the most popular option. If you’re looking for documentation, I forked it and added truckloads of examples and explanations, a relatively recent Haddock rendering is online here: https://quchen.github.io/ansi-wl-pprint-docdump/wl-pprint-1/index.html
08:32:17 <nogid> nitrix: but that's just shifting definitions around
08:32:27 <lyxia> ph88: how is that generic
08:32:31 <nitrix> nogid: As far as working with Haskell, from its type system to everything else specified by the Haskell Report, you'll be working in a pure, referentially transparent, environment.
08:32:33 <nogid> nitrix: I agree that in Haskell you can see from the signature of a function that it is definitely pure
08:32:37 <nitrix> nogid: It's not.
08:32:46 <ph88> lyxia, you can inspect the structure of the tuple no ?
08:32:50 <nogid> nitrix: But any program doing reasonable work will have a lot of impure functions (interpretation-time, that is)
08:33:27 <nitrix> nogid: You have to understand that the effects you want the runtime to achieve are going to reflect in the types of your functions in a pure language.
08:33:31 <lyxia> ph88: but to do what you want you need to look at the types of each component of the tuple
08:33:48 <nitrix> nogid: The fact we have to accomodate effects at the type level is exactly what makes Haskell so safe.
08:33:49 <Cale> nogid: Evaluation is the process of reducing expressions to values (typically for the purposes of pattern matching / case analysis). In Haskell this has essentially no effects.
08:33:57 <dfeuer> Cale: you have PMs.
08:34:06 <nogid> Cale: Evaluation means something else in C++ though.
08:34:27 <Cale> nogid: Sure, evaluation can do a lot more stuff in C++
08:34:39 <nogid> Cale: the definition of evaluation in C++ encompasses what Haskell calls "interpretation"
08:34:43 <nitrix> nogid: It's pure in the denotational sense.
08:34:46 <nogid> So comparing the two is Apples-to-Oranges
08:34:53 <nitrix> nogid: Operationally, how Haskell is implemented is irrelevant.
08:35:03 <Cale> nogid: Right, there's no clean separation in C++ between what Haskell programmers call evaluation and execution
08:35:21 <ph88> lyxia, yes but for type String it's easy to define a default pretty printing function for it
08:35:43 <Cale> nogid: You can try to draw a line which is up at the level of template expansion, but that's not really a very reasonable analogy from a pragmatic standpoint.
08:36:16 <Cale> (because if you tried to translate any sizeable Haskell program into C++ while maintaining those lines, you'd lose all your hair and teeth in the process)
08:36:26 <ph88> lyxia, and for my own custom types i can define a function to pretty print it. I have type T (terminal) used everywhere, and it's the only type that needs to be printed. But now i have to write 150 pp functions over structures. So ye a package would come in handy ^^
08:36:32 <nogid> So to sum it up, the advantage Haskell gives you over a language like C++ is guaranteed type-system-enforced annotations for whether or not a function is pure at interpretation time.
08:36:42 <Cale> That's *one* advantage
08:36:50 <Cale> There are a large number of other ones
08:36:54 <Cale> But yes, that's a big one
08:37:03 <ph88> quchen, good work on the documentation :) at the moment i implemented a few functions with Text.PrettyPrint.Leijen.Text
08:37:09 <dfeuer> I'm a huge fan of some of Haskell's type system features.
08:37:19 <nogid> In the context of pure/impure, that seems to be the only advantage. Everything else is just bending the definitions.
08:37:23 <nitrix> nogid: There are many others; like equational reasoning.
08:37:29 <nogid> Not to say it doesn't have other advantages.
08:37:34 <Vq> shapr: GOOD EVENING!
08:37:45 <quchen> ph88: My fork is also Text-based in case that’s important to you. :-) https://github.com/quchen/prettyprinter/
08:37:45 <dfeuer> The fancy type system also relies on purity in some ways.
08:37:51 <nogid> nitrix: that sort of follows from the guaranteed purity annotations
08:37:53 <shapr> Vq: oh hai! how's code?
08:38:36 <Vq> shapr: Very dynamically typed unfortunately. :(
08:39:00 <lyxia> ph88: if your implementations all look the same, consider using Generics.
08:39:03 <shapr> Vq: yeah, I'm reading about project m36 while I wait for my dynamically typed code to build.
08:39:04 <nogid> Now for practical reasons, I've never written a function in C++ and wondered about whether it's pure or not. In my experience it's always obvious to the programmer (unless it was written by someone else and you're just reading the code).
08:39:27 <quchen> Most code I read is by someone else.
08:39:30 <Cale> nogid: (unless it was written by someone else and you're just reading the code) <-- this is important
08:39:34 <quchen> Me 6 months ago is an example of someone else.
08:39:39 <Vq> shapr: m36?  What dynamically typed language has long build times?
08:39:50 <nogid> So Haskell seems like it could provide advantages when multiple different programmers are working on a code-base and are not disciplined enough to document the side-effects of their functions.
08:40:02 <shapr> Vq: our build system is slow, not our language
08:40:13 <shapr> Vq: and I'm reading https://github.com/agentm/project-m36/blob/master/docs/15_minute_tutorial.markdown
08:40:16 <Cale> nogid: It's also important that the compiler holds you to task for your own work.
08:40:26 <Cale> nogid: I *constantly* make mistakes, and am aware of this fact
08:40:48 <Cale> The fact that the compiler is catching the vast majority of them is really really helpful.
08:40:49 <lyxia> ph88: Do you have more examples of outputs you want to have
08:41:01 <shapr> Yeah, give me all the crutches, because I am imperfect.
08:41:52 <shapr> nogid: also, you can code faster when the type system is checking for problems.
08:41:56 <nogid> Cale: in my experience with reasonable modern C++, the compiler also catches almost every mistake
08:42:01 <lyxia> ph88: if you're printing ("hello ", "world") as "hello world", aren't you throwing away the information that your data was in a tuple?
08:42:44 <quchen> lyxia: That’s the difference between a prettyprinter and a serialization library.
08:42:45 <ph88> lyxia, yes i throw away the structure i build. I go from source code to syntax tree, and when i go back to source code i loose of course the tree structure and everything becomes flat text again
08:42:49 <infandum> I'm getting "Failed to load interface for 'Gtk2HsSetup'" even AFTER installing gtk2hs-buildtools (trying to install cairo). Did something change?
08:43:07 <Vq> shapr: I work on a C# project as well and have to fight with msbuild, one of the worst build systems I've seen.
08:43:08 <nogid> for example it's a myth that in C++ you end up with memory leaks. You have all the tools to set up life-times of dynamically allocated memory in a declarative way (unique_ptr, shared_ptr, memory arenas)
08:43:15 <infandum> stack resolver is lts-7.18
08:43:16 <Cale> nogid: I'm just going to assume that you haven't done a large amount of programming in Haskell yet ;)
08:43:25 <nogid> Cale: nope I haven't
08:43:52 <Cale> nogid: The difference in terms of how many more of your bugs get caught at compile time is ridiculously large.
08:44:05 <nogid> Cale: but you have to consider that there are many different styles possible in C++. If someone is writing C-in-C++, of course the compiler is going to be much less helpful in catching mistakes
08:44:05 <ph88> lyxia, data Foo = F String String ---> String ++ String    data Foo = F String, String ---> String ++ String    data Foo = F [String] --> mapM_ putStrLn [String]
08:44:35 <Cale> To the extent that I regularly do refactors against a large codebase that touch hundreds of lines of code, and have everything work perfectly the moment it compiles again.
08:45:06 <ph88> quchen, you think i should use a serialization library? i thought a pretty printer could do the same and also would be very handy later in case i want to apply formatting (which is not a requirement right now, but will be later)
08:45:14 <Cale> Including refactoring other people's code that I don't even understand
08:45:27 <Cale> (because I don't have time to understand it)
08:45:51 <quchen> ph88: You can always use a prettyprinter to implement a serialization library. I don’t know your use case, so I don’t know whether you should serialize or prettyprint.
08:46:23 <quchen> ph88: In my STGi, I have a prettyprinter that outputs valid STGi programs, which fulfills both the role of a serialization library and a nice-to-humans prettyprinter.
08:46:36 <quchen> ph88: It’s much less performant than a pure serializer of course.
08:46:44 <nitrix> nogid: I can't blame you for the question though. It's a very valid question, and a thought one to answer as the nuance of its answer will just fly right above your head if you haven't been exposed to Haskell in any serious manner.
08:46:47 <Cale> I think a lot of what makes Haskell so great is also lost if you never use it in a team of people -- the ability of types to document what people's intentions are in a way that is machine-checked is remarkably useful on a moment-to-moment basis.
08:46:51 <nitrix> nogid: It's a relatively common question too.
08:47:01 <lyxia> ph88: basically you're collecting strings in your structure and concatenating them?
08:47:07 <shapr> nogid: Are you writing up your investigation results somewhere? I'm interested in what/why you're looking into this.
08:47:29 <Vq> shapr: Interesting project, I've never really understood how to best model historical data in a RDBMS
08:47:42 <lyxia> ph88: hmm, you're doing something different for lists.
08:48:40 <ph88> lyxia, yes i'm collection the strings and just print them, and "get rid of the structure"
08:49:00 <nogid> shapr: Not at this time. I'm just trying to get a better understanding.
08:49:50 <Cale> nogid: Types *say* a whole lot more in Haskell than in C++, partly as a knock-on effect of having the default of purity -- we have various types which express that computations can only have certain kinds of effects as well, and the types of pure functions, and especially polymorphic ones, can tell you a lot about what they must be doing.
08:50:14 <ph88> lyxia, eh i meant    data Foo = F (String, String) ---> putStrLn $ String ++ String    all structure need to be printed eventually. And with lists also in the order from left to right just as tuple or data-fields .. everything from left to right
08:50:36 <quchen> nogid: Well, this is #haskell, full of people that like Haskell. All the stories we could tell you about how we like it have been told countless times; none of them can show you what it is really like, much like reading about French does not teach you what it feels like to speak it. Some people like to learn and speak French once they try it out.
08:51:17 <lyxia> ph88: I mean, for lists you use putStrLn, which prints each element on one line, whereas for fixed length tuples you just concatenated them.
08:51:31 <quchen> nogid: We can tell you as a community of people that wrote a lot of C and C++ and Perl and ASM and what not that we did not regret learing Haskell. :-)
08:51:35 <nogid> quchen: Funny, I can speak French and I don't like it.
08:51:36 <lyxia> ph88: but overall this looks like something you can do with generics.
08:52:17 <quchen> nogid: You might not like Haskell either! That’s the point of the example, I guess.
08:52:30 <ph88> lyxia, yeah exactly i was just hoping there is a library that already provide some of this and i would just have to write the function to print my Strings (which are contained in another datatype)
08:52:51 <ph88> lyxia, yeah ok putStrLn was a mistake .. just putStr :P
08:53:02 <quchen> nogid: On the other hand, you might also learn a completely different view on things and like it. There are many other nice views to learn that would be worth your time.
08:53:08 <ph88> lyxia, the strings themselves will contain the newlines so i don't need to add them
08:53:22 <ph88> lyxia, you think i'm best of creating the generics printer myself ?
08:53:23 <Cale> nogid: Here's another anecdote -- the other week, one other member of my team and I pair programmed for 3-4 days and finished converting the web application our team of 7-ish programmers has been working on for over a year such that it is multi-tenant. This is the sort of thing which normally could easily take several weeks if you were working in a more traditional setting.
08:53:29 <lyxia> ph88: yes
08:53:42 <ph88> okay !
08:53:53 <ph88> challenge accepted :P
08:54:11 <nogid> quchen: My main gripe with Haskell so far is that it does add a lot of complexity to achieve its well-intended goals. And while many things may get easier, others get a lot more tedious.
08:54:11 * quchen learned quite a few things that he didn’t like before finding Haskell :-)
08:54:15 <Cale> nogid: The ability of the compiler to tell us exactly what needed to change in response to some initial changes to how the database was being accessed was just insane in terms of how much it improved our productivity.
08:54:21 <nogid> quchen: one example I can think of is the sieve of eratosthenes
08:54:27 <lyxia> ph88: I can't see what general purpose functionality you can find in a library that would be useful to you here.
08:54:57 <Cale> (Well, the database access stuff changed a bit, and then the authentication tokens also got a new type parameter)
08:55:06 <Cale> nogid: hm?
08:55:38 <quchen> nogid: I know complex code in Haskell, but no particularly complex principles in the language itself
08:55:39 <Cale> nogid: Are you talking about the one which isn't really the sieve of eratosthenes?
08:55:47 <Cale> But looks kind of like it?
08:56:00 <quchen> The one on haskell.org? ಠ_ಠ
08:56:03 <ph88> lyxia, i thought maybe there was a generics framework where you can just implement an instance for your type or something like that. Now i'm worried i will have to implement generics for lists, 1-tuple, 2-tuple, 3-tuple and so on
08:56:15 <nogid> Cale: yeah, and the lengths to which you have to go to get an actual sieve of eratosthenes (via the ST monat)
08:56:19 <Cale> https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
08:56:21 <nogid> monad*
08:56:28 <Cale> ^^ There are some easy real sieves there
08:56:31 <Cale> which don't use ST
08:56:38 <lyxia> ph88: What?
08:56:53 <Cale> If you have a priority queue datastructure handy, it's not hard to do a good job
08:57:02 <lyxia> ph88: You can derive Generic
08:57:27 <exio4> using []'s Monad instance is one of the many things I feel "missing" on other languages
08:57:53 <nitrix> nogid: One could argue that the complexity added are merely different, very powerful, re-usable abstractions.
08:57:57 <Cale> nogid: It's not a one-liner anymore, but it's still not particularly difficult.
08:58:10 <exio4> [unrelated to Haskell] but what is an idiomatic way to do stuff like that in a non-FP lang? 
08:58:35 <Cale> exio4: Usually using recursion to do a depth-first search of some kind
08:58:59 <nitrix> nogid: You can kind of think of it like design patterns, except it's not trying to patch recurring issues with the language, but to give you the tools to reason about the problem space. 
08:58:59 <dfeuer> The sieve of Eratosthenes is very difficult to implement well in any language.
08:59:02 <Cale> exio4: i.e. you would regard the collection of recursive calls made by a procedure as the "list"
08:59:11 <exio4> Cale: that sounds complicated compared to simply doing xs <- [a,b] :p 
08:59:18 <Cale> exio4: yes, it sucks
08:59:42 <ph88> lyxia, for example at the moment i'm using genericShrink and i derive Generic for that. But for pretty printing i would still have to implement the "genericPrint" equivalent function for that, and i don't know what this involves, i thought it might be very complicated
09:00:05 <Cale> dfeuer: This is also a good point
09:00:22 <nitrix> nogid: Most of these abstractions have a very minimal essence. Sometimes you can spend months learning what one of these are and once you have the eureka moment, you'll laugh at yourself for making such a big deal out of it.
09:01:31 <nogid> Cale: But the version with the priority queue is still way more complicated than the imperative version and has higher time complexity by a factor of O(log n) according to the paper
09:01:39 <nitrix> nogid: The thing is, it's a completely different way than you might be used to, to think and approach problems via abstractions.
09:01:42 <Cale> Than which imperative version?
09:01:54 <Cale> Are you sure that imperative version does the same thing?
09:02:05 <Cale> Does the imperative program emit an infinite sequence of primes?
09:03:02 <nogid> Cale: wait, that sieve from the paper doesn't emit an infinite sequence of primes either
09:03:08 <Cale> Yes it does.
09:03:11 <nogid> Cale: it takes a sequence and filters out the non-primes by sieving
09:03:14 <buglebudabey> i'm learning about qubit gates, and the CNOT gate is essentially |A,B> -> |A, B `xor` A>, is this analogous to a state monad almost? or something else maybe?
09:03:20 <Cale> Read it again :)
09:03:31 <Cale> sieve works on an infinite list
09:04:02 <lyxia> ph88: the GHC.Generics documentation describes a simple example http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html
09:04:14 <Cale> The "primes" defined at the bottom of page 8 for example is infinite
09:04:41 <nogid> Cale: oh the xs can be an infinite list
09:04:47 <Cale> yes :)
09:04:56 <Cale> That's mainly what makes it tricky
09:05:04 <ph88> lyxia, i looked at it before, since then i have become fearful :P but i will give it another go
09:05:35 <nogid> Cale: well, it's not the true sieve of eratosthenes algorithm then? As that one takes a fixed-size list and goes through crossing off all the multiples
09:05:36 <nitrix> nogid: Just functors for example. You can find an immediate practical use as containers, then you find out their level of abstraction reaches beyond containers to contexts, then you find out there's even more powerful, as abstractions of abstractions (once you get to category theory with categories of categories).
09:05:51 <nitrix> nogid: And it's the same concept from the begining, it just goes a very, very long way.
09:06:02 <Cale> nogid: Well, it's the same, it's just the size is being fixed at infinity ;)
09:06:29 <Cale> nogid: and the tricky bit is interleaving which multiple you're currently crossing off for
09:06:40 <Cale> so that you can go through in one pass
09:06:48 <nogid> Cale: the imperative algorithm would run forever on an infinite list trying to cross off all the multiples of 2 :)
09:06:51 <Cale> (because two obviously wouldn't do)
09:06:55 <Cale> right
09:07:00 <lyxia> ph88: the example is pretty close to your use case. instead of converting values to [Bool] you want to get a String.
09:08:07 <ph88> :)
09:08:22 <roxxik> buglebudabey: i can't see the similarity with state
09:09:52 <buglebudabey> roxxik, i guess i'm thinking it's some kind of monad because they can be composed like |A B> >>= (\|a b> -> return (A `xor` B))
09:10:27 <buglebudabey> return (a `xor` b) **
09:10:28 <nogid> Cale: In the simple map version, I don't get why x*x is inserted as opposed to x+x
09:11:16 <nogid> Cale: oh is that because it works for 2 and the factor of 2 will be found either way, hmm.. seems a bit unintuitive though
09:12:37 <roxxik> buglebudabey: then it would be monadic, State is often represented by s -> (a,s), or even better with arrow style by (b,s) -> (a,s) or kleisli style: b -> s -> (a,s) those are all pretty much interchangeable
09:12:45 <nogid> Cale: reconsidering it, I see how that's more efficient, but it still looks like it catches the special case of 4=2*2 by sheer luck
09:13:07 <buglebudabey> roxxik, if you replace |A B> with (A,B) is it still different from State then?
09:13:19 <nogid> Cale: certainly takes some trying it out to see that the algorithm is correct
09:13:20 <buglebudabey> i guess it is
09:14:39 <roxxik> hmmm you mean something along the lines of cnot b = do { a <- get; return (a `xor` b) } or if run through some State evaluator :: cnot a b = (a, a `xor` b)
09:15:24 <roxxik> im not sure how you represent qubits in haskell...
09:15:42 <buglebudabey> roxxik, i'm trying to figure that out myself right now
09:16:28 <NickHu>  
09:17:12 <roxxik> most circuit stuff can be looked at like arrows... maybe cnot would be of type `q (a,b) (a,???)` where ??? depends on the type of a `xor` b 
09:18:40 <nogid> Cale: this quote from the paper is what worries me a bit about Haskell: "But, despite fooling some of us for years, the algorithm we began with isn’t the real sieve, nor is it even the most efficient one liner that we can write."
09:18:59 <nogid> Cale: in the context of game development where performance is crucial
09:19:15 <buglebudabey> roxxik, i think it would always be :: Qubit -> Qubit -> Qubit
09:19:37 <roxxik> but isn't cnot taking in two qubits?
09:19:56 <buglebudabey> roxxik, yeah, my type takes in two quibits and outputs 1
09:20:13 <roxxik> hmmm
09:20:15 <bitemyapp> nogid: do you often write your own prime sieves in game development
09:21:19 <bitemyapp> nogid: you're focusing on the wrong things anyway. What'll bite you using GHC RTS for game dev is GC (this'll start to really hurt as heap gets >1gb) and the fact that you'll be fixing up bindings and libraries as you go in order to get things done.
09:21:47 <bitemyapp> you can use GHC Haskell to make indie-grade games just fine. That's all most people asking whether they should use a programming language for gamedev or not are likely to do anyway.
09:22:07 <bitemyapp> but if the point is learning game dev, Haskell will mostly add work to that unless you're specifically interested in FP + Game dev.
09:22:25 <nogid> bitemyapp: I often write performance-critical mutable data structures, like dynamic delaunay triangulations for collision detection navmeshes
09:22:40 <nogid> not sure how I would even approach that in Haskell
09:24:23 <dfeuer> nogid: we have mutable unboxed vectors and arrays, so you can make stuff happen if you like.
09:25:06 <bitemyapp> nogid: so, like I said, your main impassable problem is going to be GC
09:25:27 <bitemyapp> nogid: I know when/why people need mutable data structures, that's not a problem nor is it the main problem using GHC Haskell for game dev
09:25:45 <bitemyapp> nogid: you're spinning your wheels. If the point is game dev for its own sake, use standard tooling and languages.
09:25:48 <dfeuer> GHC is adding this "compact region" feature to alleviate the GHC issues.
09:25:59 <bitemyapp> nogid: if you specifically want to learn how to do game dev in Haskell, then do it in Haskell.
09:26:07 <nogid> bitemyapp: yeah, that's true. There's no way to disable GC with Haskell I assume?
09:26:25 <nogid> bitemyapp: I know D has GC by default, but it can be turned off.
09:26:49 <Rembane> nogid: You can give the runtime parameters such that the GC is hardly ever run.
09:26:50 <bitemyapp> not usefully, no, you cannot shut the GC off.
09:26:58 <bitemyapp> There is no quick fix for this.
09:27:52 <buglebudabey> roxxik, how is this: http://lpaste.net/351797, although idk how to incorporate the Qubit datatype
09:27:56 <Tuplanolla> How well would pushing the unpleasant parts to a foreign land work?
09:28:40 <bitemyapp> Tuplanolla: fine, but you still have semi-non-deterministic pauses and keeping GHC's heap tiny is hard even if you're tossing stuff over the fence.
09:29:07 <bitemyapp> Cowley had a trick for this with his robotics work where he'd invoke a GC pass when there was some breathing time
09:29:25 <bitemyapp> that's not as easy in games where you have at most 16ms and need most of that for the actual game
09:30:04 <roxxik> buglebudabey: it looks unfortunate, that an operation needs to be represented as a data type
09:30:18 <roxxik> buglebudabey: doesn't feel haskelly
09:30:23 <bitemyapp> It's just not a good use of time unless you specifically want to see how far you can take a game in Haskell, but you'll spend so much time just making the game engine, yeesh. farthest anyone got were the FRP folks that made a Quake 3 clone engine thingy.
09:30:57 <nogid> Yeah, it's probably best to write functional style in C++ directly for gamedev
09:31:19 <buglebudabey> roxxik, i see what you mean, what if the monad i want is essentially a control gate, where theres a bit that always determine whether the output changes? i'm just trying to find a way to generalize thiss
09:31:38 <bitemyapp> The Rust people have some pretty cool stuff coming down the pipe, but for now, the best choices are C++ or something like Unity.
09:31:41 <nogid> the Quake 3 engine is very interesting though, the way they represent the navigation space as a BSP tree
09:32:17 <nogid> unfortunately newer engines/games all seem to have converged toward a triangle soup representation with brute-force checking inside a uniform grid
09:32:18 <roxxik> buglebudabey: what do you want to do with those qubits?
09:32:54 <nogid> bitemyapp: I looked at Rust already but the lifetime annotations are painful and sometimes disallow things that would actually be perfectly safe
09:33:02 <buglebudabey> well, the user would define the k in ____ >>= k, and k would be the controll gate, in this case the cnot
09:33:07 <nogid> bitemyapp: maybe things have changed by now, I should look into it again
09:33:16 <bitemyapp> nogid: if that's too hard for you, gamedev is going to drive you fucking crazy.
09:33:21 <buglebudabey> roxxik, see above
09:33:54 <bitemyapp> statically enforced lifetimes are way easier than learning/doing gamedev, or for that matter, cleaning up mistakes made with lifetimes at runtime.
09:33:56 <nogid> bitemyapp: not too hard, just too much of a price to pay to fix something that isn't actually a problem for me (lifetime and memory managemend issues)
09:34:02 <bitemyapp> uh huh.
09:34:07 <bitemyapp> well, I'm out. Good luck!
09:34:12 <Tuplanolla> Game development would drive you crazy anyway.
09:35:40 <nogid> It's not that lifetime annotations are hard. It's just that I already have them in C++ in the form of unique_ptr, references, or plain value members.
09:36:07 <nogid> and those don't impose arbitrary restrictions
09:36:10 <Xeronate> Why do you need () are k+1 for:  dropK k l = (take (k) l) ++ (drop (k+1) l)
09:36:40 <cocreature> Xeronate: function application has higher precedence than +
09:36:57 <cocreature> Xeronate: so drop k + 1 would be parsed as (drop k) + 1
09:37:01 <jle`> Xeronate: without the parentheses, drop k + 1 l is (drop k) + (1 l)
09:37:09 <cocreature> oh yeah I forgot about the l
09:37:16 <Xeronate> ah thanks
09:37:24 <glguy> Xeronate: The only parentheses you need there are: dropK k l = take k l ++ drop (k+1) l
09:37:25 <jle`> but you also don't need the parentheses around k
09:37:26 <osa1> it seems like there's no way to detect that the stream is exhausted in a concurrent pipe once I get a Producer from an Input. am I missing anything?
09:37:29 <jle`> or around take k l
09:37:31 <Cale> Xeronate: The general rule is that function application (whitespace) binds more tightly than any infix operator
09:37:50 <Cale> Xeronate: (and it associates to the left)
09:38:48 <osa1> I was hoping to do things like spawning a concurrent pipe that receives from a Producer, logs it to a DB or file and releasing the resources (e.g. flush the file and close it) when the Producer is exhausted. it seems like I can't do that using concurrent pipes.
09:39:09 <cocreature> osa1: you can’t detect termination in plain pipes. what you can do is write a function that takes a producer and does something with it.
09:39:29 <cocreature> osa1: pipes-parse has a "isEndOfInput" parser that you could use
09:39:53 <osa1> cocreature: just to understand pipes better, am I asking for something unreasonable? e.g. maybe I'm doing this wrong
09:41:29 <cocreature> osa1: no that’s completely reasonable. if you use pipes you have to pay for the simple and consistent interface by restricting the operations you can conform. if this is not enough you need to write functions that take a Pipe as an input
09:42:04 <cocreature> osa1: pipes-parse deals with a lot of things like detecting termination so you probably want to take a look at this
09:42:11 <cocreature> even if you are not parsing anything
09:44:05 <osa1> I see it's using `next`
09:44:18 <osa1> btw thanks cocreature
09:44:19 <cocreature> yeah "next" is one of these functions that deconstructs a producer
09:48:41 <danza> anybody can help me building a sum type with a list?
09:49:20 <byorgey> danza: I don't understand what you mean.  What are you trying to do?
09:49:20 <osa1> so I need a state to collect values unintentionally read while checking if the Producer is exhausted
09:49:20 <danza> for example `MyType = Int | [Int]` ... not sure about the proper syntax
09:49:30 <byorgey> danza: ah, you need data constructors
09:49:48 <byorgey> data MyType = ConstructorName1 Int | ConstructorName2 [Int]   and so on
09:49:58 <byorgey> you can pick your own constructor names of course.
09:50:06 <danza> i see
09:50:11 <danza> thanks byorgey!
09:50:23 <byorgey> danza: the fact that there is a list in it is irrelevant, it's the same no matter what is contained in it
09:50:26 <byorgey> sure!
09:53:46 <danza> but then ... how can i accept either an Int or a [Int] as the argument of a function?
09:54:09 <infandum> danza: f :: MyType
09:54:49 <infandum> then you could pattern match (ConstructorName1 x) or (ConstructorName2 xs)
09:55:32 <danza> sure but, let's say that `f` could have either Int or [Int] as a parameter, without the Constructors ... is this even possible?
09:56:21 <cocreature> danza: no that’s not possible
09:56:25 <infandum> without constructors? No idea. I don't think it should
09:56:31 <lep-delete> i think it would be possible but not worth it
09:56:35 <infandum> that would destroy the point of static typing
09:56:37 <danza> i was trying to solve this test http://careers.citrusbyte.com/apply/5DcIgp/Experienced-Frontend-Engineer in Haskell: "Write some code that will flatten ..."
09:56:42 <jophish> s
09:57:56 <Cale> danza: That question doesn't quite make sense in the context of Haskell. All the elements of a Haskell list must have the same type
09:58:15 <danza> you are right
09:58:37 <danza> meh
09:58:45 <infandum> That list looks scary
09:58:48 <Cale> danza: So either there's a weird instance of Num for lists, or that's informal notation for some kind of tree data type.
09:58:52 <infandum> It shouldn't be a list, it should be a tree
09:59:10 <infandum> yeah, what Cale said
09:59:11 <danza> right, it's not Haskell ... one is just free to pick the language they want
10:00:08 <danza> i dove in without noticing the nonsense of doing so ^^;
10:00:11 <infandum> the input would either be a list of list of lists or a tree
10:00:33 <infandum> I vote tree
10:01:44 <nitrix> :t [] :: [forall a. Show a => a]
10:01:46 <lambdabot> error:
10:01:46 <lambdabot>     • Illegal polymorphic type: forall a. Show a => a
10:01:46 <lambdabot>       GHC doesn't yet support impredicative polymorphism
10:02:02 <Cale> "Write this function on lists which nobody in the real world ever actually wants, but which dynamically typed languages all seem to provide regardless."
10:02:39 <nitrix> @let data Foo = forall a. Show a => mkFoo a
10:02:40 <lambdabot>  Parse failed: Illegal data/newtype declaration
10:02:51 <infandum> pretty much. That list is prone to so many errors
10:03:14 <nitrix> Fixed the typo.
10:03:31 <infandum> I would never go more than 2 of the same type deep, otherwise there must be some better representation
10:03:38 <nitrix> :t [] :: [Foo] -- How come I'm allowed to use this datatype, but the other one is impredicative?
10:03:40 <lambdabot> [Foo]
10:04:10 <danza> "prote to so many errors" so are also dynamically typed languages, but a lot of people in the real world are available to pay real money for writing in those, unfortunately :)
10:05:28 <danza> i shouldn't be ranting here. Thanks for guiding me :)
10:05:29 <infandum> danza: Yes and no. They are paid to write *well* written programs (I assume). Just because the language lets you get away with stuff like that doesn't mean it's convention.
10:05:53 <Cale> nitrix: The thing you're not allowed to do is instantiate a type parameter (to anything other than a function type) with a polymorphic type.
10:06:34 <Cale> nitrix: For function types, the ability to do that is provided by the RankNTypes extension.
10:07:08 <Cale> nitrix: Even if you were allowed to have that type, there are not many values of type Show a => a
10:07:38 <Cale> (it's basically just bottom, since Show a gives you no way to create values of type a)
10:08:12 <implementation> and there is absolutely no reason why [forall a. Show a => a] should be preferred over [String]
10:20:16 <glguy> Except that Show provides more operations than show
10:36:52 <ph88> lyxia, are you still around ?
10:38:14 <ph88> the docs say stuff like "In the case for :+:, we produce False or True depending on whether the constructor of the value provided is located on the left or on the right" .. just that i don't want to have my value created by the position of the constructor .. but on the actual value
10:38:57 <mpickering> Hello, how can I pass options to GHC when running stack exec? I want to pass -ddump-simpl but it seems stack just ignores this option
10:40:02 <ph88> mpickering, --ghc-options 'option here'
10:43:20 <mpickering> ok, I tried that now and I look at the actual command run with -v and the options are not passed
10:47:48 <infandum> mpickering: What is your exact command
10:51:04 <mpickering> "stack build --ghc-options="-ddump-simpl" --force-dirty"
10:51:11 <mpickering> I am actually using stack build, sorry my confusion
10:52:44 <mpickering> and I see the Lib.dump-hi file but no Lib.dump-simp
10:54:05 <MarcelineVQ> try -ddump-to-file as well in case it's just eating your stdout, allthough I think stack makes it -ddump-to-file anyway
10:54:09 <infandum> Did you try -fforce-recomp
10:58:22 <MarcelineVQ> -fforce-recomp definetly made the difference testing it on one of my projects just now
10:58:22 <MrJazz>  
11:00:49 <infandum> Seems to be a bug with --force-dirty maybe: https://github.com/commercialhaskell/stack/issues/1666
11:01:00 <infandum> ghc that is
11:21:40 <ph88> what does it mean when a class has a type in it ?
11:21:58 <geekosaur> associated type
11:22:23 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-instances
11:23:04 <geekosaur> (actually that whole section)
11:24:13 <ph88> when to use it? when is it handy ?
11:27:03 <geekosaur> it's an alternative to functional dependencies. sometimes it ends up being easier than fundeps, sometimes harder; there's a certain amount of "what works for me" (i.e. the programmer) in it
11:27:24 <geekosaur> it *should* be equally as expressive as fundeps
11:30:07 <geekosaur> the "classic" example is a class for container types, where an associated type specifies the type of things stored in the container type (class Container c where {type Item; ...})
11:36:31 <ph88> ooh ok
11:36:38 <ph88> were there fundeps before class types ?
11:37:09 <dfeuer> Class types?
11:37:27 <lyxia> "associated types"
11:37:39 <dfeuer> Yes, fundeps predate associated types.
11:38:23 <dfeuer> Associated types are type families that are tied to a class. As far as I can tell, the main reason to use an associated type instead of an independent type family is to give it a default instance.
11:38:36 <dfeuer> (which is useful for generics)
11:39:57 <zipper> WHat is the function to round off to a certain decimal point in haskell?
11:43:10 <srhb> zipper: I don't think there's a "the function"
11:43:21 <srhb> zipper: You might want to check out Data.Decimal from the Decimal package.
11:43:32 <srhb> I've used that in the past at least.
11:44:24 <zipper> :(
11:45:54 <dolio> You can use mod' from Data.Fixed, too.
11:46:01 <srhb> zipper: libraries aren't ":(" :-P
11:46:14 <ongy> as a (probably pretty bad) hack you can multiply, use round, and then divide again
11:46:34 <ongy> :t (Data.Fixed.mod')
11:46:36 <lambdabot> Real a => a -> a -> a
11:47:02 <ongy> > 0.512 `mod'` 0.5
11:47:05 <lambdabot>  1.200000000000001e-2
11:47:14 <ongy> this looks the wrong way around to me
11:47:56 <monochrom> I deplore decimal-centric thinking. But you can multiply by 1000, then round, then divide by 1000. Or you can use showFFloat if your round-to-3-decimal-places is merely for show anyway.
11:48:06 <dolio> ongy: Subtract by the mod' value.
11:48:59 <geekosaur> right. the problem with this notion of "rounding" is that it is inherently inaccurate, because the value is stored in binary, not decimal. further operations using the "rounded" value will compound the inaccuracy
11:49:00 <monochrom> Where there is mod', there is also div', and divMod'
11:49:01 <dolio> Then hope that floating point approximation doesn't ruin things.
11:49:03 <ongy> > -0.512 `mod'` 0.5
11:49:07 <lambdabot>  -1.200000000000001e-2
11:49:22 --- mode: ChanServ set +o glguy
11:49:23 --- mode: glguy set +b *!*@85.255.13.137
11:49:29 <geekosaur> and binary floating point behaves differently from binary integers
11:49:46 <ongy> ieee754 is fun! not
11:50:47 <geekosaur> if you really need to work in terms of fractional decimals, Data.Decimal or similar is where you should be looking
11:50:51 <dolio> Converting to something from Data.Decimal is probably better, though, because it's a fixed-point decimal number.
11:50:57 <bodisiw> he never said he wanted to use floating point right?
11:51:27 <monochrom> If you write in x86 assembly, there is a BCD type, it does 18 decimal digits.
11:51:41 --- mode: glguy set -o glguy
11:52:00 <monochrom> True.
11:52:02 <dolio> monochrom: Can you write up a Haskell package that wraps x86 BCD?
11:52:11 <monochrom> I am too lazy to.
11:52:32 <dolio> I need my decimal numbers to be very fast.
11:52:41 <geekosaur> you'd first need to write a C package which used asm() to access the BCD instructions
11:52:56 <srhb> geekosaur: Can it be done with inline-c?
11:53:09 <monochrom> No I think I would skip C altogether.
11:53:15 <geekosaur> possibly? asm() is inherently nonportable
11:53:31 <geekosaur> and inline-c might have issues with it
11:53:48 <dolio> monochrom: Does 18 decimal digits mean 18 digits total, regardless of where the point is?
11:54:06 <monochrom> I forgot. Let me check again. God I used to know this too well.
11:57:00 <geekosaur> also I thought I'd heard that Intel killed the BCD operations in (some?) recent CPU families
11:58:02 <geekosaur> although I can imagine major banks lining up at their door to deliver swift kicks to the crotch... BCD kinda needed for compatibility with their mainframes
11:58:22 <geekosaur> and converting at the last step Doesn't Cut It
12:01:29 <dolio> I mean, you could emulate it in the microcode, probably.
12:01:45 <dolio> I wouldn't be surprised if they've been doing that for a while, though.
12:02:47 <geekosaur> they emulate everything in the microcode :)
12:03:03 <dolio> If it's 18 digits, though, that's at least 9 bytes, so you need some special support.
12:03:59 <dolio> Unless they change the representation to make it more packed, which I assume would break just as much stuff.
12:05:56 <geekosaur> ISTR they don't actually provide BCD ops as such, they provide a BCD adjustment op to follow the normal op. so you'd do the 18-digit operation as a series of operation-with-carry+adjust
12:06:10 <geekosaur> same way you do 64 bit ops on a 32 bit CPU
12:06:34 <dolio> Ah.
12:07:01 <geekosaur> (iirc "abcd" instr, "adjust for binary-coded decimal")
12:07:25 <monochrom> dolio: It seems to be 18 decimal digits fixed point.
12:07:40 <dolio> So, 18 digits after the decimal?
12:07:45 <dolio> Or 18 digits total?
12:08:37 <monochrom> 18 digits total and you imagine a decimal point in your head.
12:08:44 <dolio> Oh.
12:09:02 <dolio> So it's really BCI.
12:09:13 <dolio> Er.
12:09:20 <dolio> It's a decimal integer.
12:09:36 <geekosaur> BCD fixed-point. the encoding is still a packed decimal representation
12:10:59 <dolio> So it's really just an inefficiently represented integer.
12:11:08 <geekosaur> yes
12:11:10 <dolio> Whichi is compatible with software from decades ago.
12:11:47 <dolio> Never mind on wrapping it into Haskell, then. :P
12:12:21 <ongy> we should do it, with a fortran ffi
12:13:07 <geekosaur> and more to the point, compatible with specific operation-for-compatibility requirements, where the compatibility is not with a given machine architecture but with financial processing requirements that minimize loss of fractional values of money
12:14:17 <geekosaur> (whihc is why you do all the ops in BCD instead of doing it in a native format and converting later, unless you can *prove* you get the same result including in corner cases. such proof is difficult enough that it's usually easier to just use BCD)
12:17:06 <dolio> If you're doing fixed point arithmetic, it doesn't seem like it should matter whether the integer is stored in binary or BCD. But I wouldn't want to prove that the assembly does the same thing.
12:17:42 <ongy> first we got to trust the hardware
12:18:02 <monochrom> Converting to decimal at every step ensures decimal-centric rounding so you don't get binary-centric rounding.
12:18:13 <geekosaur> that, yes
12:18:25 <monochrom> And the financial sector insists on decimal-centric rounding.
12:18:27 <geekosaur> the problem is some ops produce more decimal places than the fixed-point can represent
12:18:30 <dolio> What rounding?
12:18:49 <monochrom> Apart from the New York Stock Exchange which dabbles in 1/8-centric rounding or something.
12:18:50 <geekosaur> (consider for example currency conversion)
12:19:18 <hodapp> unums ftw! \o/
12:20:02 <geekosaur> part of the complexity here is ensuring that rounding in these situations "cancels out" so you don't get fractions of a penny "disappearing" or "appearing" --- which, given the transaction volume in a modern financial exchange, adds up scarily quickly
12:20:16 <monochrom> I respect backward compatibility and the financial sector honouring a 500-year-old rule and "it is too late to change for the better". But Knuth proved that binary-centric rounding is less loss than decimal-centric rounding.
12:20:54 <hodapp> he proved it correct, but did he test it?
12:20:58 <geekosaur> and part is that for this canceling-out to work, everyone participating in the exchange must all switch at the same time
12:21:02 <monochrom> So decimal cannot possibly minimize loss. (Binary does.) Decimal can only be for "it was set in stone since the time of Venice".
12:21:32 <geekosaur> which is a political problem gthat is much, much less tractable than the technical one
12:21:44 <dolio> Haven't stock exchanges switch to decimal these days?
12:22:02 <dolio> Or do they still use 1/8 but show decimal in the reports?
12:22:14 <akfp> can anyone help me find a template-haskell mocking/testing framework that has been discussed on reddit or haskell-cafe in the last 6 months?  I can't find it, but it was some library that would do most of the boilerplate associated with creating mocks for a typeclass or something like that.
12:22:39 <monochrom> I don't know, but I know what Turing would say :)
12:35:13 <zipper> Anyone else have trouble with https://hackage.haskell.org/package/bytestring-0.9.1.3/docs/Data-ByteString-Internal.html ?
12:35:33 <dolio> geekosaur: Oh, I see what you mean. But you have to implement rounding correctly either way. How you store the integer has nothing to do with how you implement rounding.
12:35:51 <zipper> Anyone else have trouble with converting Data.ByteString.Internal.ByteString to say an Int?
12:38:06 <srhb> zipper: "Convertoing
12:38:09 <srhb> Yikes
12:38:14 <srhb> "Converting?"
12:38:48 <zipper> srhb: I don't know a better word.
12:39:01 <srhb> zipper: Are you asking how to parse anb
12:39:13 <srhb> Jeebs, this keyboard. "a bytestring into an Int?"
12:39:24 <srhb> zipper: Or are you experiencing difficulties with your specific parser?
12:39:40 <zipper> srhb: this https://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq-Lens.html#v:responseHeader
12:40:00 <zipper> I can get Content-Length as a Data.ByteString.Internal.ByteString
12:40:31 <zipper> I can show it as a String but I can't pull the Int out
12:40:50 <zipper> No pack and toStrict or fromStrict will work
12:41:16 <geekosaur> (read . Char8.unpack) will probably work
12:41:20 <geekosaur> (althouygh ugh)
12:45:51 <ongy> :t readInt
12:45:53 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
12:46:01 <ongy> @hoogle readInt
12:46:04 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
12:46:04 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:46:04 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:50:45 <plakband> The repa docs state to "Add bang patterns to all function arguments, and all fields of your data types". Is there a reason not to simply use the STRICT pragma, or were the docs simply not updated for GHC 8?
12:51:51 <Logio> akfp: are you thinking of tasty-th?
12:52:07 <Vlada> Всем привет! I am from Moscow. Does anyone want to chat?
12:52:51 <geekosaur> plakband, the latter I'd imagine
12:54:14 <Logio> plakband: I remember reading that a few years back, so most likely the latter
12:57:36 <plakband> geekosaur, Logio: Thanks. I figured as much, but I don't really have intuition for strictness yet
13:07:33 <teto> how can I print the type of a variable in my script ?
13:08:08 <geekosaur> Data.Typeable... but that's a strange thing to do as types are compile time and *not* dynamic
13:09:25 <geekosaur> if you think you need to verify a type at run time, you are likely thinking about the problem wrong
13:09:33 <geekosaur> (wrong for Haskell at least)
13:17:05 <teto> geekosaur: I am learning haskell and you can do :t in ghci but once you try to runcommands from a file, I don't know how to do it. This would help me check I am correct (the error messages are not yet - always -  clear to me)
13:17:11 <EvanR> question about the nature of backpack, is this like an answer to ML or ocaml "modules" ?
13:17:44 <Ed___> How to convert a float to an integer? Like 1.56 -> 1
13:17:53 <ongy> :t round
13:17:56 <lambdabot> (RealFrac a, Integral b) => a -> b
13:17:59 <geekosaur> round, ceil, or floor
13:18:03 <geekosaur> or truncate
13:18:09 <geekosaur> depending on the exact behavior you want
13:18:12 <EvanR> teto: unfortunately, ghci is kind of a different self contained language, you dont run commands like that in regular haskell code
13:18:25 <EvanR> Ed___: floor
13:18:29 <Ed___> Thanks guys!
13:18:32 <EvanR> > round 1.56
13:18:36 <lambdabot>  2
13:19:04 <geekosaur> rightm that one is either truncate or floor (the difference between them shows up with negative values: truncate is toward 0, floor is always down)
13:19:33 <geekosaur> (ceil is always up, round is 4/5 rounding)
13:20:14 <ongy> 4/5 rounding? I thought it's towards even?
13:21:36 <geekosaur> ah, yes, it is toward even, sorry
13:21:44 <ph88> is it possible to work with generics when you have a type like  data Foo = F (Maybe Int) [String]  ?  all the example use less complicated types
13:21:54 <glguy> > map round [-3.5 .. 3.5]
13:21:57 <ongy> what's 4/5 rounding?
13:21:57 <lambdabot>  [-4,-2,-2,0,0,2,2,4]
13:22:01 <geekosaur> (good example of the rounding issues discussed with decimal earlier :)
13:22:26 <geekosaur> 0.0 .. 0.4x round down. 0.5 .. 0.9x up
13:22:40 <ongy> ah, ok
13:22:42 <geekosaur> so the 4/5 expresses the location of the breakpoint for rounding
13:23:04 <ongy> I read that as \frac{4}{5} first, which confused me a bit
13:25:10 <EvanR> > round 1.5
13:25:14 <lambdabot>  2
13:25:16 <EvanR> > round 2.5
13:25:20 <lambdabot>  2
13:25:34 <EvanR> bankers rounding
13:25:52 <geekosaur> yeh
13:26:21 <geekosaur> which is why my comment referencing the decimal discussion
13:35:18 <Zemyla> ph88: If you derive Generic, then you get to use it with anything that can take a Generic.
13:37:32 <glguy> ph88: Your question isn't specific about what a simpler type is, or what aspect of your example makes it complicated
13:40:14 <ph88> well here they describe a type with "a"  https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html  Tree a   and then replace all a's. But i have Int and String
13:40:36 <ph88> then this example doesn't have  fields for the data constructor  http://www.stephendiehl.com/posts/generics.html
13:40:54 <ph88> and this example also just takes a's   https://jozefg.bitbucket.io/posts/2014-04-25-you-could-have.html
13:41:10 <ph88> which let's me think Generics only works with, what was it called, polymorphic type ?
13:41:52 <ph88> ok let's make it a bit easier, let's say i have a type   data Foo = F (Maybe String) [String]   so no mixed Int and String ..
13:43:13 <glguy> and what's your question about that type?
13:45:09 <ph88> as i understand it it should encode to something like    Either (Maybe String) [String]   .. still doable. But then i add another wrapped type     data Foo = F Wrapper [String]   data Wrapper = W (Maybe String) [String]    now if have Left of  Wrapper  and left of  (Maybe String)    those types don't match so how am i suppose to implement :*:  product ?
13:45:39 <glguy> Implement what?
13:46:11 <ph88> eh forget Either .. that was suppose to be (,)
13:46:19 <glguy> What is it you're implementing?
13:46:23 <ph88> https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html#t::-42-:
13:46:30 <ph88> i'm not implementing anything yet :/
13:46:48 <glguy> I know what :*: is, I don't know what aspect of :*: you're worried about
13:47:18 <ph88> that i have two types  Foo  and  Wrapped, where Foo uses Wrapped and i don't know how to implement :*: anymore
13:47:22 <glguy> Perhaps work through some of the links you shared above and get a handle on how things work before you worry about the complexities
13:47:45 <glguy> not knowing what it means to use GHC.Generics is going to make it pretty hard to have concerns about them that make sense
13:48:21 <ph88> what does it mean ?
13:49:19 <monochrom> GHC.Generics is not so easy to understand.
13:50:19 <monochrom> If you have had experience with the "data types a la Carte" paper, then GHC.Generics is more obvious in retrospect. However, "data types a la carte" is not so easy to understand either, I'm just shoving the problem elsewhere.
13:51:04 <monochrom> And yet, GHC.Generics is actually your best bet for "auto-writing code for pretty printing". Such is the fate of going down a rabbit hole.
13:51:29 <ph88> oh funny i just had dinner with that guy the other day
13:52:22 <ph88> and it wasn't a la carte lol
13:56:19 <ph88> ok this is something actually http://www.stephendiehl.com/posts/generics.html it shows type used by other type. Pie uses Filling and Topping so i will take a look at this
13:56:55 <ph88> i must say GHC.Generics makes me quite hungry
13:57:02 <ph88> maybe this was about food all along
14:02:02 <melissa_> Hey everyone WHYBW?
14:02:08 <ph88> "Since we’re passing around a proxy we’ll have to manually thread the dictionary around sometimes by passing an undefined cast to the type of the instance we need to resolve."  .. this sounds rather complicated
14:05:36 <ph88> menu (undefined :: Pie)  <-- srsly
14:05:56 <ph88> try ordering that at your favourite restaurant
14:11:40 <ph88> what kind of construct is that were you can give a type to undefined ..
14:11:58 <ph88> is that like a pointer cast in C ?
14:13:15 <ongy> afaik: undefined is bottom, and all types have bottom as inhabitant (with exception to unboxed stuff)
14:13:38 <geekosaur> it's just specialization to a type
14:16:18 <ph88> is bottom a theoretical thing or is it encoded in a certain way in memory ?
14:16:55 <geekosaur> it's theoretical (nontermination, by whatever means)
14:17:32 <geekosaur> in ghc, undefined = error "Undefined" and error throws an ErrorCall exception
14:18:11 <ph88> does that mean you redefine  undefined  in that place when you force it to a certain type ?
14:18:22 <geekosaur> but (let x = x in x) is also a form of bottom, one that does not reliably throw an exception
14:18:34 <glguy> ph88: It's no different than using 'map' at a particular type
14:18:39 <geekosaur> no, you are just specializing the type. types only exist at compile time
14:19:07 <ph88> why is that allowed to type check ?
14:19:19 <Koterpillar> :t undefined
14:19:21 <lambdabot> a
14:19:22 <geekosaur> it's a memo to the typechecker to treat an expression that has some more general type as if it had a compatible but more specific type
14:19:40 <geekosaur> why is `1` allowed to typecheck as Int or as Double?
14:19:45 <ph88> aaah i see
14:20:17 <geekosaur> (I should probably say `fromInteger (1 :: Integer)` there, sin ce Num is not part of this)
14:20:38 <ph88> i get the point ^^
14:20:46 <ph88> what's the head of a typeclass instance ?
14:21:40 <ph88> "All of which have a free parameter p which is bound to the head of typeclass instance when used in the associated datatype Rep a."
14:23:21 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-declarations
14:23:48 <ph88> oki
14:24:22 <ph88> ah i see, interesting terminology o___O
14:55:51 <ph88> what's this  (Proxy :: Proxy f)  ??
14:56:25 <ph88> looks like a type constructor with type signature
14:56:39 <Koterpillar> ph88: Nothing :: Maybe Int
14:56:44 <Koterpillar> ph88: same thing
14:57:02 <Koterpillar> ph88: the definition of Maybe is: data Maybe a = Nothing | Just a
14:57:10 <Koterpillar> ph88: the definition of Proxy is: data Proxy a = Proxy
14:57:43 <jle`> > (Nothing :: Maybe Int)
14:57:46 <lambdabot>  Nothing
14:57:50 <ph88> how you know the definition of Proxy ?
14:57:52 <jle`> ph88: it's a value constructor with a type signature
14:58:01 <jle`> ph88: you can find the consturctors in the documentation for Proxy
14:58:14 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Proxy.html
14:58:19 <ph88> oh i thought Proxy was a type made up for that blog post
14:58:23 <ph88> didn't know it was on hackage
14:58:31 <jle`> ah no, it's actually included in 'base'/ghc
14:58:38 <jle`> like Int, Maybe, list, Either, etc.
14:58:57 <ph88> what is it used for ?
14:59:05 <jle`> situations like this
14:59:08 <jle`> :)
14:59:12 <ph88> lol
14:59:32 <jle`> it's a nice way to *pass* a 'type' as an input to a function
14:59:42 <jle`> er, 'pass' a *type*
14:59:48 <ph88> i always wanted to do that !
14:59:58 <ph88> can you match on type with Proxy ?
15:00:24 <jle`> not quite, it's mostly for the type checker
15:00:36 <jle`> as in, you're telling the type checker what type you want
15:00:41 <jle`> it doesn't actually carry the type at runtime
15:00:50 <jle`> for that you need things like Data.Dynamic/Data.Typeable or Data.Singletons
15:01:16 <jle`> basically sometimes the type checker might not be able to figure out what type you want to instantiate your function with, just from the inputs/outputs
15:01:37 <jle`> for simple functions like map :: (a -> b) -> [a] -> [b], for instance, it's pretty easy for the type checker to see what 'a' or 'b' you want
15:01:49 <ph88> where would it be useful to tell the type checker which type i want? If you would ask me this question i would just say use :: and you can tell the type checker which type you want
15:01:52 <monochrom> Proxy is most useful for instantiating return-type polymorphism.
15:02:04 <jle`> but for some functions, it's not possible to guess what you want your type variables to be from just the arguments/outputs
15:02:04 <monochrom> Err, no.
15:02:46 <monochrom> Proxy is most useful for instantiating parameterless polymorphism.
15:02:48 <jle`> ph88: if you wanted to implement like a SizeOf typeclass that gives how many byes a value of that type takes up in memory
15:03:01 <jle`> ph88: class SizeOf a where sizeOf :: Int wouldn't work
15:03:03 <jle`> do you see why?
15:03:18 <jle`> sizeOf :: Int   ... how does the type checker know what type you want the size of?
15:03:30 <jle`> but imagine class SizeOf a where sizeOf :: Proxy a -> Int
15:03:39 <jle`> then you can do sizeOf (Proxy :: Proxy Bool)
15:03:46 <jle`> and that'll know that you want the Bool instance of sizeOf
15:05:54 <ph88> can't you just say   sizeOf :: a -> Int  ?
15:06:06 <jle`> sure, but that'll require you to actually pass a value of type 'a'
15:06:07 <davean> ph88: you'd need an 'a'
15:06:08 <Koterpillar> ph88: now we're back to passing undefined
15:06:12 <davean> where are you getting that 'a'?
15:06:17 <jle`> but what if you don't have a value of type 'a' available
15:06:20 <jle`> or you don't know how to make one?
15:06:55 <monochrom> "SizeOf a => a -> Int" causes people to believe that different values have different sizes.
15:07:07 <davean> which they sometimes do
15:07:17 <monochrom> "SizeOf a => Proxy a -> Int" says precisely to not expect that.
15:07:59 <monochrom> So between "a -> Int" and "Proxy a -> Int" you choose according to which message you want to convey. Or misconvey!
15:08:33 <ph88> oh you want to know the size of Bool and not a particular Bool .. right
15:08:54 <monochrom> So for a historical example, take a look at Storable in the FFI.
15:09:32 <jle`> there's also another common example Typeable, which is something close to a ShowType class
15:09:44 <jle`> class ShowType t where showType :: Proxy a -> String
15:09:52 <jle`> intance ShowType Bool where showType _ = "Bool"
15:09:58 <jle`> instance ShowType Int where showType _ = "Int"
15:10:04 <monochrom> It has "Storable a => a -> Int". But the intention is value independence, only type dependence. This was before we invented Proxy, so they had to say in the doc "it doesn't depend on the actual value!"
15:10:23 <jle`> then you can do showType (Proxy :: Proxy Int) and the type checker would know that you want 'Int'
15:10:29 <monochrom> And it becomes a source of misunderstanding to no end, because people don't read the doc.
15:11:17 <glguy> and then you generalize from: Proxy a -> String    to    proxy a -> String
15:11:42 <ph88> okay i'm mainly used to program on runtime, not on type-checker-time .. but i'll take it ShowType class is a good example
15:14:18 <jle`> yeah, it's basically a way of passing a type to the type checker at compiletime.  passing types around at runtime is a whole different ordeal, heh
15:14:26 <jle`> since types are erased at runtime in haskell
15:16:06 <monochrom> When you use type classes too much, you're bringing types to run time.
15:16:34 <ph88> dictionaries right ?
15:17:18 <monochrom> That is an awful-lot-of-operational way to explain it, but yes.
15:17:51 <ph88> i'm all about operational :P
15:18:02 <monochrom> It doesn't scale.
15:18:11 <ph88> the reasoning ?
15:18:22 <monochrom> Yes.
15:18:28 <ph88> hows that ?
15:19:51 <monochrom> Suppose I give you a 500-line program that takes 3 hours to run, and ask you to understand it.
15:20:32 <monochrom> If your only technique is to run it in your head, it is going to take more than 3 hours. Because my "3 hours" assumes a 2GHz computer. Your head is slower than that.
15:21:07 <ph88> well you don't perform all calculations when reading the source code
15:21:21 <exio4> then you're not following operational semantics :)
15:21:22 <monochrom> That proves my point.
15:21:48 <ph88> i never meant it that literally :|
15:22:34 <monochrom> But you don't need dictionaries to explain why type classes bring types to run time either.
15:23:00 <ph88> i was already surprised about myself i could muster up 1 piece of relevant information
15:23:19 <ph88> but i'm sure there are lot's of other ways to explain it ^^
15:23:34 <monochrom> A faster explanation is to point at Data.Typeable and Data.Dynamic. They are also more useful immediately.
15:24:45 <ph88> using typeclasses too much + Typeable or Dynamic  causes runtime overhead ?
15:24:59 <monochrom> What is overhead?
15:25:07 <ph88> anything on runtime really
15:25:22 <monochrom> Are you sure?
15:25:39 <monochrom> By now you know that I take your words very literally, you know. So, are you sure?
15:25:48 <ph88> in my book anything that is non essential to performing the algorithm as if it was implemented in assembly by the best of the best
15:26:05 <monochrom> OK, good, I agree with that.
15:26:18 <monochrom> Then the answer is "it depends".
15:27:11 <ph88> isn't it always ..
15:27:46 <Rembane> Will this give you analysis paralysis and anxiety and not letting you produce any code at all?
15:27:53 <monochrom> You're essentially asking: Is it true that every problem in the world can be solved without runtime type information.
15:28:19 <Rembane> monochrom: Is that a research area?
15:28:34 <monochrom> No. We already know that the answer is no.
15:28:41 <ph88> no ?
15:28:43 <Rembane> Oh. How disappointing.
15:28:44 <hpc> pick a language like idris and solve it at compile-time
15:28:51 <Rembane> monochrom: Why is it so?
15:28:52 * hpc ducks
15:29:01 <ph88> i thought things just had to be turing complete
15:29:04 <monochrom> I am too lazy to say why.
15:29:31 <Rembane> seq monochrom 
15:29:34 <ph88> ok np
15:29:39 <ph88> i have to go to sleep
15:29:41 <hodapp> Rembane :P
15:29:52 <monochrom> My bet is that, for some problems, even if you solve by writing a Turing machine directly, you have an encoding of runtime type information somewhere.
15:29:59 <hodapp> ph88: Turing completeness actually isn't even a requirement of most things.
15:31:03 <monochrom> Take for example, if you do so much as write your own sql or nosql database, you have runtime type information.
15:31:19 <AWizzArd> I have   foo n = let (Just f) = Just succ in f n   – can this be made point-free? I tried removing the two occurrences of n.
15:31:24 <ph88> i think that be more on the level of, suppose your system handling personal registration and your type Sex can be Male or Female .. i'd just call it data, but w/e
15:31:45 <jle`> AWizzArd: foo = succ ...?
15:32:05 <jle`> what you wrote seems like foo = succ
15:32:09 <AWizzArd> Sure, it can be simplified like this, but I wonder if it is possible with the let syntax.
15:32:11 <monochrom> But all the world's problems are not solved by a personal registration system.
15:32:22 <jle`> AWizzArd: how do you want to use the let syntax?
15:32:26 <ph88> good night
15:32:41 <AWizzArd> I just wondered if it was possible or not.
15:32:48 <jle`> i'm not sure what you are looking for
15:32:53 <jle`> what part do you want to make point free?
15:32:58 <glguy> If you want to 1) be point-free, 2) use let syntax you end up with something like:
15:33:00 <glguy> foo = let {} in succ
15:33:09 <monochrom> foo = succ.
15:33:11 <jle`> the '(Just f) = Just succ' part?
15:33:29 <jle`> you might be misunderstanding what point free means
15:34:32 <jle`> it's just not quite clear what you're asking
15:36:03 <monochrom> Are you under a teacher who insists that you use "let"?
15:36:18 <monochrom> And did the teacher say "use it for real, don't f**k with me"?
15:36:36 <glguy> foo = do let{}; succ
15:42:16 <AWizzArd> monochrom: no teacher, just new to Haskell
15:42:42 <monochrom> OK good.
15:42:50 <AWizzArd> I just saw that the function returns   f n,  so maybe it can just return f.
15:43:18 <AWizzArd> foo = let (Just f) = Just succ in f  -- looks okay to me, in principle.
15:43:30 <ertes> i wish there were Ord instances for things like IORef, MVar, etc.
15:43:31 <monochrom> Yes.
15:45:17 <monochrom> ertes: I think implementing Ord decreases efficiency.
15:45:53 <ertes> monochrom: does it?  shouldn't it just be pointer comparison?
15:45:56 <Cale> Yeah, currently IORefs and MVars and such can be moved around by the garbage collector.
15:45:57 <monochrom> Take for example IORef, which wraps a STRef, which wraps a MutVar#, which is probably a machine address.
15:46:01 <ertes> ah, i see
15:46:50 <ertes> ok, then i wish vault's Data.Unique.Really were in base =)
15:46:52 <monochrom> I wonder how Java pulls it off though. (They don't have Ord, but they have Hashable, same issue.)
15:47:12 <ertes> they probably couple it with a unique identifier
15:48:04 <monochrom> Somehow no one complains about Java efficiency. Everyone laughs and then complain about company funding for hardware.
15:49:31 <AWizzArd> Ooh, I just discovered that I can do   foo = let (Just f) = Just succ in f     I only had to declare the type explicitly, and then it worked.
15:51:01 <monochrom> I think I am seeing a conspiracy theory here. Programmers and lower managers conspire to tell upper managers "we use Java, Java is best practice, this is why we need better computers". In secret, they use Haskell, and use the spare cycles of the overpowered computers for their own games and bitcoin mining.
15:51:40 <lordcirth> monochrom, or they do actually use Java, and just blame the language for their ineptitude.  More believable :P
15:51:45 <hpc> dogecoin is a better investment nowadays
15:52:04 <monochrom> Yeah I'm out of touch in that area.
15:52:36 <ertes> hehe
15:52:42 <monochrom> lordcirth, but I want incredible conspiracy theories!
15:53:27 <ertes> AWizzArd: why are you matching (Just succ) against (Just f)?
15:53:46 <ertes> AWizzArd: foo = succ
15:54:14 <monochrom> foo = let f = succ in f
15:55:08 <monochrom> Is there a reason to bring in Just? Could you use list or Either or tuples?
15:55:29 <monochrom> foo = let [f, _] = [succ, succ] in f
15:56:38 <monochrom> . o O ( The perturbation method )
15:56:48 <hpc> watch your language ;)
15:58:50 <monochrom> OK!
15:59:24 <ertes> foo = let f : _ : _ : _ = [succ] in f
15:59:42 <monochrom> Hrm! I wonder if that bottoms out
15:59:46 <ertes> nope
15:59:55 <ertes> > let f : _ : _ : _ = [succ] in f 1
15:59:57 <lambdabot>  *Exception: <interactive>:3:5-26: Irrefutable pattern failed for pattern f :...
16:00:00 <ertes> huh?
16:00:03 <monochrom> See?
16:00:12 <jle`> f : ~(_ : _ : _) would be fine
16:00:17 <ertes> i thought let-patterns were irrefutable
16:00:30 <jle`> let patterns force evaluation
16:00:38 <monochrom> Yes but it is merely one outer ~
16:00:44 <ertes> ah, i see
16:00:52 <jle`> so f : _ : _ : _ forces ghc to evaluate [succ] to the extent that it knows it has three :'s
16:00:59 <monochrom> > case [succ] of ~(f:_:_) -> f 1
16:01:01 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
16:01:08 <ertes> jle`: i thought it were fully irrefutable
16:01:45 <ertes> i wish haskell were more consistent in that
16:01:45 <monochrom> I wrote a really long proof using merely Haskell 2010's equations for this kind of things.
16:02:05 <ertes> > (\(_, _) -> ()) undefined
16:02:08 <lambdabot>  *Exception: Prelude.undefined
16:02:14 <monochrom> But it's lost somewhere on lpaste
16:02:23 <ertes> > let (_, _) = undefined in ()
16:02:25 <dgpratt> what's the language extension that allows you to easily bring record fields in scope in a function with a record type parameter?
16:02:26 <lambdabot>  ()
16:02:39 <ertes> dgpratt: you mean RecordWildCards?
16:02:51 <dgpratt> I think so, thanks ertes 
16:04:37 <ertes> can a module import itself?  would be quite useful with RecordWildCards (and shadowing in general)
16:05:36 <ertes> hmm, nope
16:05:43 <hpc> record wildcards don't deal with imports
16:06:23 <ertes> hpc: i found myself not using them in one case, because i needed access to the record accessors
16:06:39 <ertes> and writing Data.Blah.Myself.blah is awkward
16:07:11 <ertes> import Data.Blah.Myself as Self
16:07:15 <ertes> Self.blah  -- less awkward
16:07:46 <MarcelineVQ> maybe have a module shortcut by default called This
16:08:01 <ertes> i'd vote for Me =)
16:08:12 <MarcelineVQ> there's already an disamiguity thing called this in another case, iirc
16:08:14 <Koterpillar> ertes: VB.Net?
16:09:30 <ertes> -XNarcissticModules
16:11:08 <ertes> -XNarcissisticModules
16:11:58 <MarcelineVQ> I​ guess I was wrong, 'this' isn't in the stolen syntax list for extentions
16:12:59 <MarcelineVQ> allthough neither is 'type' so maybe this is specific to code syntax
16:16:11 <MarcelineVQ> oh snap it's from -XPackageImports  "The special package name this can be used to refer to the current package being built."
16:32:26 <monochrom> dgpratt: RecordWildCard lets you write "f StateT{..} = ... runStateT ...". RecordPuns lets you write "f StateT{runStateT} = ... runStateT ..."
16:33:08 <dgpratt> ah, interesting, thanks monochrom 
16:33:24 <dgpratt> I wonder which one sees more use
16:33:33 <monochrom> Err, spelling error, NamedFieldPuns
16:33:49 <monochrom> And plural for RecordWildCards
16:33:59 <monochrom> English is so hard.
16:34:31 <dgpratt> for realz, thank goodness I learned it as a young child
16:34:33 <monochrom> I find that I use them together.
16:36:41 <monochrom> Wait, why do I use them together? That makes no sense.
16:37:37 <ertes> i've never used NamedFieldPuns
16:38:16 <monochrom> OK, I think I end up just using RecordWildCards more.
16:38:19 <glguy> monochrom: Maybe as your mood changes about how explicit you'd like to be:  Mk { field1, .. }
16:38:44 <monochrom> Yeah.
16:39:24 <Ptival> is there a local way of indicating intended orphan instance?
16:39:36 * ertes still believes that ad-hoc polymorphism would be better than any amount of record convenience extensions
16:39:42 <monochrom> But here is where NamedFieldPuns shines: You can use the pun on the RHS too. let runStateT = blahblah in StateT{runStateT}
16:40:10 <jle`> but ad-hoc polymorphism is super bad, right ...?
16:40:18 <ertes> Ptival: only module-local, as far as i know:  {-# GHC_OPTIONS -Wno-orphan-instances #-}
16:40:20 <glguy> Ptival: If you're asking for a way to turn off the warning for one instance rather than the whole module, no
16:40:22 <jle`> monochrom: you can RWC on the right hand side too
16:40:33 <Ptival> whole module is good
16:40:38 <jle`> let runStateT = blablah in StateT{..}
16:40:46 <ertes> jle`: why?
16:40:58 <monochrom> Oh haha yes. Oh God, where does this madness end?!
16:41:03 <jle`> ertes: not sure why, but preventing it was the entire reason typeclasses were invented, right
16:41:07 <jle`> > let getSum = 10 in Sum{..}
16:41:10 <lambdabot>  error:
16:41:10 <lambdabot>      Illegal `..' in record construction
16:41:10 <lambdabot>      Use RecordWildCards to permit this
16:41:12 <jle`> heh
16:41:14 <ertes> Ptival: sorry: OPTIONS_GHC, not GHC_OPTIONS
16:41:14 <glguy> Ptival: By default orphans don't generate a warning
16:41:19 <jle`> @let -XRecordWildCards
16:41:19 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
16:41:21 <jle`> oh
16:41:29 <jle`> @let {-# LANGUAGE RecordWildCards #-}
16:41:31 <lambdabot>  Defined.
16:41:32 <jle`> i forgot if this works or not
16:41:33 <monochrom> OK! The real reason I turn on both is because I am too lazy to make up my mind!
16:41:38 <jle`> > let getSum = 10 in Sum{..}
16:41:40 <lambdabot>  error:
16:41:40 <lambdabot>      Illegal `..' in record construction
16:41:40 <lambdabot>      Use RecordWildCards to permit this
16:41:49 <ertes> jle`: i don't know what the original intention was, but ad-hoc polymorphism and class polymorphism serve different purposes: convenience vs. abstraction
16:41:51 <ertes> respectively
16:42:19 <monochrom> ad-hoc is good or bad depending on details. The devil is in the details.
16:42:22 <glguy> ertes: -Wno-orphan-instances doesn't appear to be a valid flag, at least in 8.0.2
16:42:28 <glguy> ertes: perhaps -Wno-orphans
16:42:33 <ertes> ah, possibly
16:42:34 <monochrom> (Or is it "detail"? English is so hard.)
16:42:35 <Ptival> glguy: my .cabal has -Wall
16:42:38 <jle`> i admit that it is undeniable that the role that typeclasses play in haskell now are is very, very different than their intended purpose
16:42:46 <jle`> *original intended purpose
16:43:09 <jle`> same for newtypes
16:44:22 <ertes> ad-hoc polymorphism can cause trouble, but i'd say it's unlikely enough that the benefits outweigh the potential disadvantages
16:44:44 <jle`> there's also idris that just does  TDNR
16:45:02 <ertes> jle`: yeah, that's what i mean by ad-hoc
16:45:52 <ertes> if exactly one definition in scope is well-typed, just pick it and assume that it's the correct one
17:37:30 <haskelllord69> is this where haskell wizards hang out
17:38:15 <Cale> haskelllord69: Also many beginners
17:38:28 <Koterpillar> haskelllord69: we don't discriminate and welcome Haskell wizards, witches, lords and commoners alike
17:38:45 <haskelllord69> splendid
17:39:12 <haskelllord69> im going through haskell book atm hope to be finished soon
18:02:56 <jle`> haskelllord69: happy haskelling :)
18:03:54 <Welkin> I don't think I've written any haskell in almost 2 months o.o
18:09:04 <kadoban> Sounds terrible
18:09:31 <dgpratt> so I made a little program that runs a system command to generate the response to a web request
18:09:59 <Welkin> yeah... it's not great
18:10:11 <dgpratt> but I'd like to cache the command output for a small time interval
18:10:28 <dgpratt> on the order of seconds
18:10:47 <Welkin> all programming outside of haskell is... shitty
18:10:50 <Welkin> haha
18:10:58 <Welkin> it feels like I've been on a haskell diet
18:11:09 <dgpratt> I'm assuming some multithreading is in order, but beyond that I'm not sure the best direction to proceed, advice anyone?
18:11:19 <orzo> i need a bounded priority queue that will auto-delete the lowest priority element once it reaches a certain size but also give me fast access to the highest priority element and ability to delete it
18:12:09 <orzo> all i've come up with is pairing two priority search queues with opposite prioritization
18:13:44 <orzo> anybody got a better idea?
18:13:45 <monochrom> dgpratt: Consider http://hackage.haskell.org/package/psqueues (priority := timestamp, search key := query or path)
18:14:11 <dgpratt> consider it considered, thanks monochrom 
18:14:18 <Ptival> I am having trouble flattening code withing monadic code, see: http://paste.awesom.eu/k7DO
18:15:10 <monochrom> Ptival: Consider Control.Monad.ExceptT. Comes with GHC.
18:16:29 <monochrom> But if it's IO, you may be better off with exceptions, Control.Monad.Exception
18:16:43 <Ptival> monochrom: it is not IO, it's within a free monad
18:17:05 <Ptival> actually not even
18:17:11 <Ptival> I guess it's within an unspecified monad?
18:17:19 <monochrom> Then you should redesign your free monad so that user code does not need to do this case analysis all the time.
18:17:47 <Ptival> it's within an interpreter for a free monad, in an unspecified monad
18:17:53 <monochrom> In other words your free monad and your interpreter should include an exception mechanism.
18:18:27 <Ptival> so should I say that I only interpret within MonadError monads?
18:18:33 <monochrom> No.
18:19:46 <Ptival> ah, let me give you a little more context then
18:19:55 <monochrom> OK I don't know what is "interpreter for a free monad, in an unspecified monad".
18:23:40 <Ptival> monochrom: http://paste.awesom.eu/8iaC here's what it more or less looks like
18:24:04 <Ptival> maybe my separation of TypeCheckerF and Work is unfortunate
18:24:59 <Ptival> though this might be orthogonal to the current problem
18:25:56 <Ptival> so, no, this actually happens within a (FreeT TypeCheckerF m a) computation
18:30:03 <orzo> Ptival: you can use NondecreasingIndentation to nest monad operations without indenting
18:32:20 <ertes> @tell dfeuer i've abandoned the lazy ST FRP idea (too complex) and wrote an RC4 implementation using MonadFix instead: https://gist.github.com/esoeylemez/dd9c98506b25d197dd72e42edb914731
18:32:21 <lambdabot> Consider it noted.
18:33:46 <Welkin> how many of you have heard of the mythical "self-documenting code"?
18:34:08 <ertes> swapping array elements is actually quite convenient with MonadFix…  never noticed that
18:34:23 <Welkin> to me it's bullshit
18:34:24 <ertes> doesn't work with unboxed arrays though
18:36:26 <Ptival> orzo: interesting
18:41:37 <ertes> dfeuer: lambdabot has a message for you
18:46:12 <ertes> dfeuer: while working on your reimplementation you can check the result of 'rc4' against the test vectors here: https://tools.ietf.org/html/rfc6229
18:48:58 <dfeuer> ertes: oh,does that RFC have a table somewhere?
18:49:15 <dfeuer> Oh, lots.
18:49:36 <dfeuer> ertes: what lazy ST features do you rely on here?
18:49:58 <ertes> dfeuer: MonadFix, strictToLazyST
18:50:08 <ertes> and STRef
18:50:47 <ertes> and laziness of course…  this code will not work with strict ST
18:51:21 <dfeuer> Oh, good.
18:51:23 <dfeuer> :D
18:53:06 <ertes> it's a neat way to express RC4, too, but i needed the laziness of STArray, so it's not very efficient =)
18:53:19 <ertes> it doesn't work with STUArray
18:54:08 <ertes> if you replace all usages of 'updateArray2' by 'updateArray1', it will at least type-check, but will diverge at run-time with STUArray
18:57:01 * dfeuer is a bit sleepy.
18:57:11 <dfeuer> Thanks, ertes. I'll add that test to the list.
19:18:53 <lambdafan> I'm looking for a struct that has two operations, fromList and pop. Has such a thing been made?
19:19:08 <lambdafan> um stack, not struct
19:19:24 <pikajude> i forget. is pop the front or the back
19:19:29 <lambdafan> pop is front
19:19:40 <lambdafan> if it emtpy return Empty value
19:19:40 <Koterpillar> isn't that a newtype on []?
19:19:47 <pikajude> fromList = id; pop (x:xs) = (Just x, xs); pop [] = (Nothing, [])
19:19:52 <lambdafan> yeah it could be, I'm wondering if someone has done better
19:36:03 <Axman6> lambdafan: pikajude just did it for you =)
19:36:16 <Axman6> Haskell lists are essentially stacks
19:36:39 <Koterpillar> well, you _could_ try doing better by using a vector to reduce allocations
19:37:02 <Koterpillar> actualy, since your only operation is pop... I don't think so
19:37:46 <orzo> you could add rle compression
19:40:22 <nshepperd> unboxed vector could conceivably help if Vector.fromList fuses with whatever source you're using, /and/ you need the values to hang around for a while
19:40:33 <nshepperd> but nah
20:31:32 <qmm> is there something like takeLast in the standard library?
20:32:08 <qmm> i came across takeWhileL and takeWhileR, but i'm entirely sure what the intended purpose is there
20:32:17 <Welkin> > last [1,2,3]
20:32:19 <lambdabot>  3
20:32:22 <MarcelineVQ> you want to take from the end?
20:32:58 <qmm> MarcelineVQ: yeah
20:33:05 <qmm> not just the last item :)
20:33:17 <Koterpillar> \n x -> drop (len x - n) x will be just as inefficient as anything else
20:33:24 <Welkin> > takeWhile (> 3) . reverse $ [5,3,1,0,1]
20:33:27 <lambdabot>  []
20:33:36 <Welkin> > takeWhile (< 3) . reverse $ [5,3,1,0,1]
20:33:37 <Welkin> lol
20:33:38 <lambdabot>  [1,0,1]
20:33:53 <qmm> > take 2 (reverse [1,2,3]) -- probably isn't an efficient method of doing this
20:33:55 <Koterpillar> (\n x -> drop (len x - n) x) 3 [1,2,3,4,5]
20:33:56 <lambdabot>  [3,2]
20:34:08 <Koterpillar> > (\n x -> drop (len x - n) x) 3 [1,2,3,4,5]
20:34:10 <lambdabot>  error:
20:34:10 <lambdabot>      • Variable not in scope: len :: [a] -> Int
20:34:10 <lambdabot>      • Perhaps you meant one of these:
20:34:12 <Welkin> qmm: it's fine
20:34:14 <MarcelineVQ> wel, you have to get to the end of a list somehow
20:34:17 <Koterpillar> > (\n x -> drop (length x - n) x) 3 [1,2,3,4,5]
20:34:18 <Welkin> it's only linear time
20:34:19 <lambdabot>  [3,4,5]
20:34:20 <qmm> feels good to be able to break that out though (off the top of my head, woot woot!)
20:34:28 <Welkin> you don't rebuld the whole list anyway
20:34:29 <qmm> Welkin: really?
20:34:31 <qmm> oh
20:34:35 <Welkin> you traverse the list to the end
20:34:45 <Welkin> and only take the ones you need
20:34:47 <Koterpillar> you don't rebuild it, but you build it
20:40:23 <tommd> Why aren't the fd's from `socket` closed when `Socket` is GCed?  It seems like something most users would want.
20:40:52 <tommd> It occurs to me that, if one isn't careful, you'll end up closing a recycled FD... but my first impression is that care can be taken successfully.
20:42:03 <tommd> For example `main = socket AF_INET Stream defaultProtocol >> main` will quickly hit a resource limitation, even if you sprinkle in some `System.Mem.performGC` calls.
20:42:56 <Koterpillar> the action of closing a socket isn't pure
20:43:04 <Koterpillar> *is a side effect
20:43:22 <Koterpillar> closing a socket gracefully can produce an error, etc.
20:46:10 <tommd> Are you asserting that closing and ignoring the error (man says EBADF, EINTR and EIO) is worse than the current, alternative, behavior?
20:46:23 <tommd> Because I'd say it's a good bit better.
20:46:58 <geekosaur> I'm inclined to say that leaking a file descriptor like that is bad news.
20:47:35 <geekosaur> But... the gripping hand is Windows, where it is *not* a file descriptor and I don't know what if anything gc can do about it
20:47:50 <geekosaur> (I'd throw an exception if closing it in gc gets an error, fwiw)
20:49:05 <geekosaur> Because Winsock is weird, and potentially the leaked socket would be detected *outside* of an active Winsock session (although recent network may just create the session on first socket use and destroy it in global cleanup?)
20:50:19 <tommd> geekosaur: Always limited by the lowest common denominator here, hurm?  I'd have to learn about the windows case but it would be nice if we could get some smoother edges with Network in general and this certainly is one.
20:50:29 <geekosaur> I'm checking
20:50:38 <geekosaur> I don't see withSocketsDo any more, so.
20:50:45 <geekosaur> oh, there it is :/
20:51:20 <geekosaur> ok, looks like it is not needed any more (unless you use MkSocket directly, which is not recommended), so maybe it'd be safe
20:52:16 <geekosaur> *but* gc would need to reference the network package (they don't like adding bootlibs, they want bootlibs to go away!) *and* they'd have toi make sure a sufficiently recent version of network were used, at least on Windows
20:53:00 <geekosaur> that is, you will not be able to upgrade the network package any more if gc uses it; you would need to rebuild ghc
20:53:29 <tommd> geekosaur: We wouldn't need to go that far.  I think a finalizer would suffice.
20:54:20 <geekosaur> hm. maybe. suppose older versions of network wouldn't matter in that case because they wouldn't be setting the finalizer
20:54:40 <geekosaur> ask the network maintainer(s); they may have other reasons for it
20:54:59 <tommd> Will do.  I just wanted to smoke test it here - thanks.
20:55:01 <geekosaur> (again, windows is liable to be the sticking poibt because its socket implementation is Weird(tm)
20:57:59 <EvanR> does it make sense to convert free variables into de bruijn indices
20:58:21 <EvanR> or is that only for bound variables
21:02:19 <lpaste> qmm pasted “fails-to-compile-but-a-okay-in-ghci” at http://lpaste.net/351810
21:03:47 <tommd> qmm: `let 1 = 25000` should be `let t1 = 25000`.  So, typo.  Also, `tl` should probably be `t1`.
21:04:06 <clmg> How do I filter a list of bools by their values?
21:04:07 <qmm> tommd: thanks, i meant t1
21:04:19 <qmm> tommd: that's not the real problem though, fixed it gives the actual problem
21:04:30 <EvanR> > filter id [True, False, False, True, False]
21:04:31 <qmm> fixing the typo gives the actual probelm (sorry about the the typo)
21:04:33 <lambdabot>  [True,True]
21:04:40 <clmg> id was what I was looking for, thanks
21:04:41 <tommd> qmm: No, it actually compiles.
21:05:25 <tommd> Notice I called out two typos
21:05:48 <qmm> hm, i guess i don't understand the actual problem
21:06:02 <qmm> i'll continue looking at it
21:06:05 <qmm> tommd: thanks for taking a look
21:06:07 <tommd> It would help if you pasted the actual code you are trying to compile, the error, and the command used for compilation.
21:06:15 <qmm> always nice to have that confirmation regardless if i'm wrong
21:18:00 <ertes> tommd: i don't see a way to finalise an FD safely, as long as it's just a number
21:18:11 <ertes> the newtype wrapper doesn't help
21:18:24 <ertes> see the documentation of Weak in System.Mem.Weak for details
21:19:18 <halogenandtoast> Does anyone know how I might store (and read) a postgres json type with persistent?
21:20:01 <ertes> in other words: you *have to* use proper resource management here, be it a simple 'bracket' or something like ResourceT
21:21:01 <lpaste> qmm pasted “actual issue” at http://lpaste.net/351811
21:21:32 <monochrom> There are a lot of "let"s you can omit.
21:22:00 <qmm> monochrom: really?
21:22:03 <qmm> exciting
21:22:11 <qmm> where at?
21:22:47 <monochrom> You don't need consecutive let's.
21:23:01 <monochrom> For example lines 3 and 4.
21:23:04 <qmm> nice!
21:23:37 <monochrom> Although, as far as issues are concerned, this is non-essential. What happens when you run this program?
21:24:00 <monochrom> Hrm you have a whole ton of unused definitions.
21:24:52 <monochrom> u is going to be Integral or something. t is going to be Double or something. You can't do t*u.
21:25:02 <monochrom> s/Integral/Integer/
21:28:17 <halogenandtoast> I'm assuming I could do something with `PersistMap [(Text, PersistValue)]`
21:28:50 <Axman6> halogenandtoast: have you checked there isn't already an instance for Aeson's Value type?
21:29:37 <lpaste> qmm pasted “monochrom: this seems to work in ghci” at http://lpaste.net/351813
21:30:27 <halogenandtoast> Axman6: I might just be bad at googling, trying now
21:30:29 <monochrom> ghci exhibits modified behaviours for convenience.
21:30:55 <qmm> monochrom: okay, thank you
21:31:22 <monochrom> More specifically for this case, when entered into ghci, t retains its most polymorphic type, "Num a => a". (Enter ":type t" to see.)
21:31:49 <monochrom> But this doesn't happen in compiler mode, which is faithful to Haskell 2010.
21:32:22 <monochrom> Haskell 2010 requires the monomorphism restriction for t.
21:33:05 <monochrom> (And that's only half of the story. The other half is that Haskell 2010 also requires defaulting of types.)
21:33:25 <monochrom> (of certain types)
21:33:25 <halogenandtoast> Axman6: it doesn't seem like an instance already exists, but I might be able to reuse what was done here: https://github.com/periodic/LoLLogs/blob/master/parser/Data/GameLog/PersistTH.hs
21:36:32 <mrkgnao> could someone who knows about these things tell me what allowing types like [forall a. a] would do?
21:36:56 <mrkgnao> would that be the type of a heterogeneous list?
21:37:02 <monochrom> No.
21:37:24 <lpaste> qmm pasted “sorry to keep posting in this channel hacking around the problem, this is the error i'm receiving” at http://lpaste.net/351814
21:37:29 <monochrom> [forall a. Num a => a -> a -> a] would be a nice list of polymorphic arithmetic 2ary functions.
21:37:41 <nshepperd> [forall a. a] would be the type of a list of ⊥s
21:39:23 <monochrom> Maybe (forall r. (Int -> r) -> r) would be a nice way to say "I may have a continuation for you"
21:40:21 <geekosaur> qmm, there's nothing obvious wrong with the snippet the error message shows; would have to see the full code
21:42:36 <Axman6> halogenandtoast: have you seen https://hackage.haskell.org/package/persistent-2.6/docs/Database-Persist-Class.html#g:9 ?
21:43:03 <Axman6> hmm, might not be relevant actually
21:44:21 <monochrom> (forall a. a -> IO a, forall a b. IO a -> (a -> IO b) -> IO b) would be a nice dictionary for monad methods.
21:45:42 <monochrom> The possibilities are endless. Think of the future!
21:48:17 <qmm> > 0.34 * 34.343434333434344343433
21:48:19 <lambdabot>  11.676767673367678
21:48:46 <geekosaur> qmm, for what it's worth, the error indicates you used `ts` in a context requiring its type be [Char] (or String, equivalently)
21:59:56 <qmm> i'm in the IO monad stepping with the breakpoint, but i can't seem to inspect the types of the variables that were set with the let statements. is this normal?
22:00:42 <qmm> "stepping with the breakpoint" doesn't make sense, sorry. i'm stepping through the file with the debugger
22:02:14 <geekosaur> when it's showing you a line, iirc it is before it has evaluated it; you'd need to check the *next* time it stops
22:06:00 <RoboticFoot> Why is -fwarn-incomplete-uni-patterns not included in -Wall? That came as a very unpleasant surprise to me
22:09:55 <geekosaur> RoboticFoot, because whether it's a bad thing or not depends on the context
22:10:22 <geekosaur> for example, you *want* pattern failure to be silent in the list monad (or list comprehensions which are the same thing)
22:11:20 <geekosaur> (usually)
22:12:08 <RoboticFoot> geekosaur: Doesn't that desugar to "_ -> fail <msg>", so it's not actually a uni-pattern?
22:12:53 <RoboticFoot> I would expect uni-patterns to only cover things in the LHS of a lambda-expr
22:13:06 <RoboticFoot> (after desugarization)
22:15:31 <Lokathor> orchestrateGameInternals :: TChan InputEvent -> TChan OutputData -> TVar GameState -> IO GameState
23:53:41 <av_> hello everybody -- I'm reading up on IORef and found this in the docs: "Extending the atomicity to multiple IORefs is problematic" -- can anyone explain why that is, or point me to some literature?
23:55:07 <ongy> atomic stuff is interesting for multithreaded applications. It's roughly "how the world sees things"
23:56:33 <av_> ongy: OK, I know that, but why does it make a difference whether I have a single IORef or more than one?
23:56:53 <Lokathor> seems you can't build gtk at the moment on windows :/
23:56:55 <ongy> so if you had 2 bins of something represented as IORef Int (for how many are in there) and you want to move one piece from x to y you could do "do { modifyIORef x (+1); modifyIORef y (subtract 1) }. But any observer from the outside can see the state between the 2 operations
23:57:02 <Lokathor> cairo is all sorts of upset
23:58:28 <Lokathor> http://lpaste.net/351817
23:59:18 <Lokathor> ongy, can IORef have data races?
23:59:20 <av_> ongy: ah, ok!  So it's tricky to extend atomicity to operations involving multiple IORefs -- I think that would be a more appropriate statement, I find the docs slightly confusing
23:59:26 <geekosaur> av_, it doesn't lock, it just inserts a write barrier. if you need to modify more than one thing "atomically", you need locking or synchronization. this is not provided automatically because how would it know what to synchronize? so you use an MVar for synchronization/locking, or (better) a TVar
