00:00:01 <jle`> > sequence (M.fromList [(1,"01"), (2,"01")])
00:00:04 <lambdabot>  [fromList [(1,'0'),(2,'0')],fromList [(1,'0'),(2,'1')],fromList [(1,'1'),(2,...
00:00:10 <hololeap> i'm struggling to see the general pattern that all those examples fit into and how exactly it differs from the behavior of fmap
00:00:21 <jle`> hololeap: if it helps, 'traverse' is like an effectful fmap
00:00:29 <jle`> fmap lets you map (a -> b)'s
00:00:35 <jle`> traverse lets you map (a -> t b)'s
00:00:42 <jle`> er, (a -> f b)'s
00:00:57 <maerwald> ghc-boot-8.0.2, ghc-boot-th-8.0.2 and template-haskell-2.11.1.0 are not on hackage
00:01:06 <jle`> fmap :: (a -> b) -> t a -> t b
00:01:16 <jle`> traverse :: (a -> f b) -> t a -> f (t b)
00:01:35 <jle`> it "sequences" all of the resulting (f b)'s together using the Applicative instance for f
00:01:47 <jle`> for IO, that means it executes each (f b) one-after-the-other
00:01:50 <jle`> :t traverse
00:01:52 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:02:17 <jle`> for f ~ [], it means that it collects all of the possible results/branches
00:02:34 <jle`> your confusion might not be with traversable, but with List's Applicative instance
00:02:49 <jle`> (or its Monad instance)
00:03:03 <jle`> another way to look at it, if you are familiar with do notation:
00:03:26 <jle`> sequence [a,b,c] = do x <- a; y <- b;, z <- c; return [x,y,z]
00:03:49 <jle`> that's basically what sequence is for lists, generalized to as many list items as you want
00:04:15 <jle`> sequence [a,b,c,d,e] = do x <- a; y <- b; z <- c; i <- d; j <- e; return [x,y,z,i,j]
00:04:34 <jle`> for IO, that's just "do a, then b, then c, then d, then e, then collect all the results in a final list"
00:04:53 <jle`> for Maybe, it's "collect all the results in a final list if they're all Just"
00:05:08 <jle`> for List, it's "collect all potential permutations"
00:05:10 <chocopuff> length :: (Num b) => [a] -> b refers to b being a number right? not a? 
00:05:18 <chocopuff> so => can refer to the output as well?
00:05:27 <jle`> hololeap: it all depends on the Monad instance you're using with 'do'
00:05:42 <jle`> hololeap: for lists, their monad instance gives that permutation behavior
00:05:45 <jle`> chocopuff: yup
00:06:02 <hololeap> i think my confusion lies with Applicative. i don't understand what it is in the most general terms. if i was writing a Functor, when would i say to myself "this could be an Applicative" and what would i be looking to achieve by implementing it?
00:06:03 <jle`> it's called return-type polymorphism, and it's one of the more powerful features of haskell's type system/typeclasses
00:06:36 <jle`> hololeap: functor lets you map an (a -> b) over an 'f a' to get an 'f b'
00:06:50 <jle`> hololeap: applicative lets you do a 'multi-arity' map
00:07:04 <jle`> you can 'map' an (a -> b -> c) over an 'f a' and an 'f b' to get an 'f c'
00:07:28 <jle`> you can't do something :: (a -> b -> c) -> f a -> f b -> f c, with just Functor
00:07:36 <jle`> you need Applicatives to "combine" f a's
00:08:05 <jle`> every instance gets to define what "combining" actually does/means.  subject to some restrictions from the laws
00:08:37 <jle`> for IO, it implements it as sequencing IO actions.  liftA2 :: (a -> b -> c) -> f a -> f b -> f c will sequence 'f a' and 'f c' one after the other
00:08:54 <jle`> * the 'f a' and the 'f b'
00:09:14 <jle`> `liftA2 (++) getLine getLine` will be an IO action that does getLine twice, and returns their concatenated results
00:09:49 <jle`> > liftA2 (,) [1,2,3] "abc"
00:09:51 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
00:10:03 <jle`> ^ and, that above is how Applicative is instanced for lists
00:10:19 <jle`> "combining" [a] and [b] using Applicative returns their cartesian product (all possible pairs)
00:10:43 <jle`> and, what happens when you combine two of the same list?  -- you get all permutations
00:10:49 <jle`> > liftA2 (,) "abc" "abc"
00:10:51 <lambdabot>  [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c',...
00:11:09 <jle`> (permutations is not the technical word here of course)
00:11:18 <hololeap> so, if the function that you are applying is multi-arity, it still has to return a single value, and Applicative holds the logic of how to combine the results in a way that doesn't lose any information?
00:11:30 <chocopuff> jle` wait can you also have multiple typeclass decelarations? do you seperate them like (Num a) (Int b) => or (Num a) => (Num b)? how do you seperate
00:11:43 <jle`> hololeap: yeah
00:12:12 <jle`> hololeap: it provides a "monoidal" way to combine two 'f a''s
00:12:29 <jle`> chocopuff: typeclass constraints go on the left side of the =>
00:12:48 <jle`> `length :: Num b => [a] -> b` is a function `[a] -> b` where b can be any instance of Num
00:13:05 <jle`> or, do you mean multiple constraints?
00:13:05 <hololeap> i don't know why this is still so mind-bending to me. i guess i'm starting to see some of the elementary patterns that i never learned.
00:13:25 <jle`> it's still mind-bending to me today, so don't worry :)
00:14:08 <jle`> it's monoidal in the sense that it's associative and there's an "identity", but actually, you can write an Applicative instance that throws way information
00:14:17 <jle`> (so my previous "yeah" might have been premature)
00:14:45 <jle`> in fact, there is a way to write an Applicative instance for lists that does throw away information
00:15:01 <jle`> (that's not the one that is the default instance, though)
00:15:24 <jle`> 'preserving information' is not a law technically, only associativity and the existence of an identity
00:15:44 <hololeap> still, i think that i am understanding the general reason for its existance.
00:15:50 <Philippa> "multi-arity map" is also known as "[a notion of] n-ary function application"
00:16:35 <jle`> hololeap: yeah, it's a good intuition
00:17:05 <Philippa> hololeap: real learning of structure rather than facts often feels subtly mind-bending for a while, FWIW
00:18:56 <hololeap> the fractal structure is what interests me
00:19:11 <jle`> hololeap: one interesting result of the applicative laws though is that you can determine the structure of the result without applying the (a -> b -> c) function
00:19:38 <jle`> for example, for liftA2 :: (a -> b -> c) -> [a] -> [b] -> [c], if you know the length of 'a' and the length of 'b', you know the length of 'c'
00:19:44 <jle`> without ever even looking at the function
00:20:13 <jle`> this is the case for all Applicative instances, which is what makes them a powerful tool for reasoning
00:21:06 <jle`> for example, for liftA2 :: (a -> b -> c) -> IO a -> IO b -> IO c, if you know the effects of the IO a and the IO b, you konw the effects of the IO c
00:21:06 <hololeap> i have noticed that the length of the 
00:21:21 <jle`> the effects of the resulting 'IO c' are indenepdent of the (a -> b -> c) function
00:21:45 <jle`> same for liftA2 for Maybe (the nothing-or-justness), Either e, etc.
00:22:15 <jle`> this isn't the case for the Monad functions, like (>>=)
00:22:37 <jle`> for (>>=) :: (a -> IO b) -> IO a -> IO b, it's impossible to know what the effects of 'IO b' are without looking at the (a -> IO b) function
00:22:46 <hololeap> i have noticed some patterns with Applicative
00:23:10 <jle`> for (>>=) :: (a -> [b]) -> [a] -> [b], it's impossible to know the length of the final [b] without looking at the (a -> [b]) function
00:23:51 <jle`> one of the original omtivation for Applicative was for parsers. for liftA2 :: (a -> b -> c) -> Parser a -> Parser b -> Parser c, you can predict exactly with Parser c will consume by looking only at what Parser a/Parser b consume
00:23:59 <hololeap> > length $ sequence $ replicate 8 $ replicate 8 ()
00:24:07 <lambdabot>  mueval: ExitFailure 1
00:24:24 <hololeap> > length $ sequence $ replicate 4 $ replicate 4 ()
00:24:30 <lambdabot>  256
00:25:04 <hololeap> 4 ^ 4
00:25:21 <EvanR> > 4 `xor` 4
00:25:23 <lambdabot>  0
00:27:36 <qmm> in an earlier question, i was askin how to build a list of users. c_wraith: replicateM will work perfectly, however, i'm now curious about what Welkin mentioned. So, how can you build a list of X number of items using fold? the scenario is that you know that you need X number of items in a list, and you are going to construct the list using fold, how do you do this?
00:27:46 <hololeap> i meant 4 to the power of 4. i'm just pointing out that sequence seems to have an "expoonential" element to the way it combines things
00:28:28 <jle`> yeah, it's a combinatorics kind of thing
00:28:44 <jle`> you have four slots that you're filling with one of four elements, so that's 4 * 4 * 4 * 4
00:28:47 <jle`> possiblities
00:29:02 <jle`> > sequence ["01","ab","cd","ef"]
00:29:04 <lambdabot>  ["0ace","0acf","0ade","0adf","0bce","0bcf","0bde","0bdf","1ace","1acf","1ade...
00:29:12 <jle`> four slots that each can be one of two things
00:29:19 <jle`> so that's 2 * 2 * 2 * 2 possibilities
00:29:26 <jle`> > length (sequence ["01","ab","cd","ef"])
00:29:28 <lambdabot>  16
00:31:04 <hololeap> this was the function that i wrote that i realized could be replaced with sequence if i made it [[a]] -> [[a]] instead of [(a,a)] -> [[a]]. it's what got me thinking about all this: https://git.io/vM2GH
00:32:38 <Gloomy> Hey :) Asked this on haskell-beginners but maybe I'm getting outside of beginner territory here so: 
00:32:45 <Gloomy> I have a somewhat hairy stack of transformers that I use to evaluate a parsed language and send instructions to a robot with. I'm stuck with writing a "or" function for the evaluator, that takes two possibles evaluators as argument and tries both:
00:32:51 <Gloomy> http://lpaste.net/351169
00:33:35 <Gloomy> The ev <- runEval a d env part gives me a type error, I can't figure out how to solve it/write this function
00:33:39 <Gloomy> ideas? :) 
00:33:56 <Gloomy> (let me know if more information is needed on types or other stuff)
00:35:07 <hololeap> the fact that it is "double recursive" (it calls itself twice in the same expression) seems to make it follow the "exponential growth" pattern, whereas functions that are "single recursive" seem to follow a more linear pattern
00:36:48 <EvanR> thanks to laziness do two recursive "calls" doesnt have to be exponential
00:37:11 <EvanR> i.e., might never do both or even one of the calls
00:38:39 <Gloomy> I'm confused on why I can use get and ask as-is (no matter how deep in the stack the Reader and State monads are) but I can't bind runEval ? 
00:39:34 <MarcelineVQ> Gloomy: people need the errors along with the code, or code that can be compiled on their end, this is typically called a minimal example
00:41:35 <Gloomy> Right, here it is with the error: http://lpaste.net/351169
00:43:07 <MarcelineVQ> I'm pretty unversed in transformers but did you need a liftIO perhaps
00:43:38 <Gloomy> Where/why? 
00:46:07 <Gloomy> ev <- liftIO . runEval $ a env d   doesn't help 
00:46:23 <EvanR> er
00:46:30 <EvanR> :t (liftIO .)
00:46:32 <lambdabot> MonadIO m => (a -> IO a1) -> a -> m a1
00:46:38 <EvanR> seems wrong
00:46:49 <EvanR> oh $
00:47:10 <EvanR> (liftIO . runEval) a env d
00:47:22 <EvanR> u so silly... lift (runEval a env d)
00:47:46 <Gloomy>         ev <- liftIO . ( runEval a env ) $ d seems to work. not that I have any idea why.
00:48:04 <hololeap> qmm: i'm pretty sure the point of fold is to turn a list into a single value, not build a list based on parameters
00:48:40 <Gloomy> EvanR Why? Why is the lift needed?
00:49:08 <MarcelineVQ> because $ is really low precendence.  ev <- liftIO . runEval $ a env d    is like   ev <- (liftIO . runEval) (a env d)   it doens't make sense to apply a to env and d
00:49:10 <EvanR> the equivalent of get (MonadState), ask (MonadReader), for IO actions is MonadIO
00:49:21 <EvanR> :t liftIO
00:49:22 <lambdabot> MonadIO m => IO a -> m a
00:49:41 <Gloomy> ( lift (runEval a env d) doesn't seem to work, btw)
00:49:49 <EvanR> liftIO, i mistyped it
00:50:42 <EvanR> if your action is not generalized as a MonadIO action, then you have to use liftIO
00:50:54 <Gloomy> MarcelineVQ Ok, that explains that part :-) 
00:50:59 <EvanR> since none of the standard IO actions are like that, you usually have to do it
00:51:29 <ubsan> hey, so, I think I may have found a bug in haskell's indentation parsing?
00:51:56 <ubsan> https://gist.github.com/ubsan/f8d45340792a394b84809b6626ffdb20
00:52:11 <jle`> do you mean with the haskell spec, or with ghc's parsing?
00:52:11 <tsahyt> Hello. I've got a really strange compiler error here. it reports that the File name does not match the module name. Saw 'Main'. Expected 'Data.FreeLevelQueue', but the module name is clearly stated as the latter in this file. This already compiled just fine too earlier today and I can't think of a change that I made which might have prompted this. Has anyone run into this before who can give me some pointers
00:52:13 <tsahyt> where to even start looking?
00:52:28 <ubsan> jle`: ghc
00:52:28 <cocreature> ubsan: I think you need to indent more than the "let"
00:52:29 <Gloomy> EvanR Sorry, I'm quite new to this, having a hard time with some of what you say. What does it mean "generalized as a MonadIO action"? 
00:52:34 <jle`> ubsan: Left/Right should go past the 'd' in dirs
00:52:36 <MarcelineVQ> ubsan: you need to indent your cases farther than the d of 'dirs'
00:52:38 <cocreature> eh more than the dirs
00:53:11 <Gloomy> Is there a difference between IO and MonadIO ? 
00:53:15 <jle`> ubsan: if you want your case statement to be considered a part of 'dirs', you have to put it at least past the d
00:53:17 <jle`> otherwise like what even
00:53:25 <tsahyt> Gloomy: IO is a type, MonadIO is a typeclass
00:53:28 <ubsan> ah, okay
00:53:34 <ubsan> but... why
00:53:52 <tsahyt> Gloomy: IO is an instance of MonadIO, but so are many other monads, e.g. ReaderT Foo IO
00:54:00 <ubsan> what's the point of having to indent past the d
00:54:01 <jle`> ubsan: consider that 'Left e' is a valid binding/declaration
00:54:17 <jle`> it's to tell haskell unambiguously that 'Left err' is a part of 'dirs'
00:54:19 <jle`> and not its own thing
00:54:31 <jle`> > let Left k = Left "hi" in k
00:54:33 <lambdabot>  "hi"
00:54:57 <jle`> ubsan: it's a pretty consistent thing in Haskell
00:55:01 <ubsan> so it's so that something like "let x,\n    y = ..."
00:55:07 <tsahyt> Gloomy: basically MonadIO is a class for all monads in which IO actions can occur. those are generally monad transformer stacks with IO as their base.
00:55:08 <EvanR> Gloomy: so yeah... this is really kind of messy
00:55:15 <jle`> ubsan: usually, if you want something to be a part of 'dirs', it has to be indented at least past the d
00:55:24 <jle`> it's sort of a consistent thing with haskell layouting
00:55:40 <jle`> once you stop indenting things past the 'd', it's like the next block, unrelated to dirs
00:55:53 <Gloomy> tsahyt Ok, that part is clearer now, thank you :-) 
00:55:58 <EvanR> Gloomy: you see that get and ask are part of a typeclass right. but IO actions arent, they are concretely typed as IO
00:55:59 <jle`> "dirs stuff = .... (indented past 'd') ..."
00:55:59 <ubsan> yeah sure, that all makes sense
00:56:14 <ubsan> I still don't like it tho
00:56:39 <jle`> yeah, haskell committee had sort of a "don't think too much about the syntax, just design a good language" philosophy
00:56:47 <EvanR> Gloomy: some libraries expose their IO actions as MonadIO m => ... -> m a to make it so you dont have to use liftIO, but they dont always
00:56:55 <Gloomy> EvanR Ok, so that means that get and ask are more general? like, they work in any stack that has a State/reader monad by default?
00:57:10 <jle`> knowing that syntax is only ~5% of language design :)
00:57:23 <EvanR> any MonadState or MonadReader monad, which all your transformers implement
00:57:28 <jle`> there is no perfect syntax anyways, there's always going to be someone that doesn't like some aspect
00:57:56 <EvanR> IO actions obviously only work in IO
00:57:59 * cocreature waits for a lisper that explains jle` that sexprs are the perfect syntax
00:58:17 <jle`> heh
00:58:22 <tsahyt> nvm my question above, I encrypted my source code on accident. well that's a new one.
00:58:24 <ubsan> idris lets me do that :(
00:58:33 <jle`> this is why those haskell pitches that revolve around syntax always sound silly to me
00:58:40 <EvanR> tsahyt: good thing you didnt accidentally use md5 encryption
00:58:59 <tsahyt> good thing I have git, because not only did I encrypt it (didn't know that vim even did that), I also don't know the key
00:59:00 <Gloomy> Ok, think I get it . Thanks a lot :)
00:59:06 <EvanR> lol
00:59:16 <jle`> ubsan: ruby has some syntax things that i like too that aren't in haskell, so ... yeah, not every potentially good feature in every language is probably going to make it ;_;
00:59:21 <ubsan> jle`: I feel like I'd enjoy haskell more if it was more like idris
00:59:26 <ubsan> :P
00:59:34 <cocreature> ubsan: maybe you should just write idris :)
00:59:40 <ubsan> cocreature: but like... speed
00:59:40 <jle`> why don't you use a language more like idris
00:59:43 <jle`> for example, idris
00:59:50 <jle`> :p
00:59:52 <cocreature> I heard idris is pretty good at being like idris
01:00:00 <ubsan> quite
01:00:17 <ubsan> but it also has none of the maturity
01:00:22 <EvanR> idris is the limit point of some sequence of languages tending to be like idris
01:00:27 <ubsan> which is unfortunate
01:00:33 <jle`> that's fair
01:00:51 <jle`> does idris have any major contributors other than edwin?
01:00:52 <EvanR> in some cases it has more maturity, for example the repl
01:01:01 <EvanR> jle`: yeah, a few
01:01:02 <ubsan> jle`: I believe there are two or three
01:01:10 <jle`> oh, nice
01:01:16 <ubsan> also, I have to learn haskell if I want to hack on idris
01:01:27 <ubsan> they're still not self-compiling
01:01:29 <jle`> idris isn't bootstrapped yet?
01:01:35 <ubsan> no
01:01:37 <jle`> ah
01:01:38 <EvanR> no its not even a remote priority
01:02:12 <EvanR> if you try to use idris right now, youll see even writing a compiler in it is just not a thing
01:06:28 <xpika> is there a writer monad for monadplus ?
01:07:21 <jle`> er, do you mean to ask if there is a MonadPlus instance for Writer w?
01:14:14 <gfixler> I'm curious about the difference(s) between 2 and 4 parameter lenses
01:14:21 <gfixler> I'm reading this: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
01:15:03 <gfixler> it recommends going with the simpler ones for now, but doesn't explain why, or what's missing with only 2 params
01:21:07 <aib> what's that "forall" doing in the code examples? https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial I mean, I can see that it's asserting something is true for all types, but is it actual code? How can I execute it myself with ghci? Hoogle turned up nothing
01:21:34 <aib> oh man, I just saw the sidenote...
01:21:46 <aib> thanks for putting it after the 3rd example..
01:22:03 <aib> ><
01:24:27 <EvanR> whoa... http://wiki.c2.com/?WikiWikiSystemNotice
01:25:22 <merijn> aib: Normally the forall is implicit in all haskell signatures, but some extensions require it be explicit
01:26:28 <merijn> aib: i.e. in the underlying type theory "id :: a -> a" is really "id :: forall a . a -> a", which indeed indicates that it is "for all types", but Haskell (being more restricted than the theory) automatically adds a forall for all type variables used
01:27:11 <tsahyt> :pointfree \x -> foldr bar (foldr foo x xs) ys
01:27:19 <tsahyt> what was the pointfree command again?
01:27:23 <tsahyt> @pl \x -> foldr bar (foldr foo x xs) ys
01:27:24 <lambdabot> flip (foldr bar . flip (foldr foo) xs) ys
01:27:30 <tsahyt> hmm, that doesn't turn out very nicely either
01:27:33 <quchen> Visible type application is a really nice way of showing what that forall does I think. I didn’t envision that!
01:28:03 <quchen> tsahyt: Corollary. Point-free style is either obvious or useless.
01:28:29 <merijn> quchen: Sometimes you can't come up with the obvious one, though ;)
01:28:49 <tsahyt> I'm not really after pointfree style, I was thinking about whether there is a nice way to sequence folds that feed their accumulator into each other over different input lists
01:28:49 <quchen> No, that contradicts my corollary.
01:28:58 <tsahyt> pointfree is just my starting point usually
01:29:17 <quchen> tsahyt: foldr does not have an accumulator, it has a current element and a rest.
01:29:38 <Tuplanolla> That sounds like `mapAccumR`, tsahyt.
01:29:43 <tsahyt> :t mapAccumR
01:29:44 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
01:29:45 <aib> merijn: I think the author was using it to make a statement about an assertion rather than using it as part of a type declaration. but thanks for that info, I was just about to refresh on "forall" :)
01:31:10 <merijn> oh, apparently it was a different forall >.>
01:31:31 <tsahyt> Tuplanolla: what would that look like for two functions foo :: a -> b -> b, bar :: c -> b -> b and lists [a] and [c]?
01:36:08 <aib> merijn: yeah, that's what initially confused me as well :) Now I'm reading up on the actual "forall".
01:41:46 <ertes> quchen: foldr does have an accumulator, if you choose to give it one
01:42:34 <ertes> > foldr (\x xs b -> if b then x : xs (not b) else xs (not b)) mempty [1..] True
01:42:37 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
01:42:40 <quchen> ertes: No, your folding function has the accumulator in that case, foldr will just ignore it, because it does not consume it as an argument.
01:42:54 <ertes> sure
01:42:56 <quchen> But one could argue either way.
01:52:16 <quchen> That reminds me, I wanted to add an autoreplacement for posting foldl-in-terms-of-foldr on IRC. :-)
01:53:48 <quchen> :t \f z xs -> foldr (\x rest acc -> rest (f acc x)) id xs z
01:53:49 <lambdabot> Foldable t => (t1 -> t2 -> t1) -> t1 -> t t2 -> t1
01:53:51 <quchen> Does that look right?
01:56:05 <EvanR> true or false, the usage "n-skeleta" for plural of n-skeleton is purely an attempt to sound fancy with plurals
01:58:04 <merijn> EvanR: True
01:58:29 <EvanR> confirmed
02:04:18 <Geekingfrog> While reading this post: http://chrisdone.com/posts/fast-haskell-c-parsing-xml I encountered this line: (case ... of ...) Just ((+ index) -> spaceOrCloseTag) ->  which makes no sense to me. Any idea what's going on in the pattern matching ?
02:05:16 <merijn> Geekingfrog: ViewPattern
02:06:06 <merijn> "Con (f -> x)" matches constructor Con, applies 'f' to the field and binds the result of applying 'f' to 'x'
02:07:27 <merijn> https://downloads.haskell.org/~ghc/7.4-latest/docs/html/users_guide/syntax-extns.html#view-patterns
02:07:29 <Geekingfrog> Thanks
02:09:19 <EvanR> anyone know the origin of the jargon "material set theory" i can only find nlab or nlab people posting comments about it elsewhere
02:09:33 <EvanR> making me think its made up
02:10:53 <ubsan> in Haskell, is there a good way to create a Vect type?
02:11:28 <merijn> ubsan: Can you be more specific? Do you just need a vector type?
02:12:00 <ubsan> merijn: Vect :: Type -> Nat -> Type
02:12:22 <ubsan> i.e., a list with length information in the type
02:12:59 <merijn> ubsan: right, so a dependent vector. The answer to "is there a good way to create it?" is, unfortunately "not really"
02:13:10 <ubsan> merijn: alright, thanks
02:13:26 <merijn> ubsan: You really want dependent types to make it not suck
02:13:47 <ubsan> is there any way to do something similar to C++? not runtime dependent, but compile-time dependent?
02:13:53 <merijn> ubsan: If you really want it you can do that sort of thing with a bunch of extension abuse, see DataKinds, the singletons library and the hasochism paper
02:14:28 <merijn> ubsan: If you care about only statically known things it becomes less messy and painful, but it's still not ideal
02:14:38 <ubsan> alright, thanks!
02:14:44 <merijn> ubsan: Although, to be fair, it's not really messier than C++ templates, so :)
02:15:00 <ubsan> C++ templates are fairly unmessy, if you're doing it right
02:15:20 <merijn> ubsan: I beg to differ :p Although I don't dare say I'm doing it right :p
02:16:10 <merijn> ubsan: Here's a blog post looking at one way to do things like this: https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html
02:17:01 <merijn> Although this is all evolving rapidly, so you'll have to dig into a bunch of extensions and figure out a lot of stuff yourself
02:19:27 <ubsan> merijn: why do they use (:#) instead of (:) for the Vec type in that blogpost?
02:19:39 <merijn> ubsan: : is the constructor for lists
02:19:41 <merijn> :t (:)
02:19:43 <lambdabot> a -> [a] -> [a]
02:20:05 <ubsan> ... ah
02:20:08 <ubsan> Haskell isn't idris
02:20:10 <ubsan> right
02:20:59 <merijn> ubsan: Data constructors (as you probably know) are required to start with capital letters, since operator constructors are allowed it was (arbitrarily) decided that ':' is the "capital" operator character, so :# is a constructor operator
02:21:20 <merijn> (For the Vect type defined there)
02:21:28 <ubsan> lol, fun
02:23:32 <purelazy> How to convert a 4 byte ByteString to a Word32?
02:24:01 <purelazy> (I'm using the Lazy ByteString)
02:24:13 <merijn> purelazy: I know binary and cereal have parsers for that, but that may or may not be overkill?
02:24:45 <EvanR> purelazy: with Bits arithmetic
02:24:49 <merijn> getWord32le and co
02:24:56 <EvanR> (using your desired endianness)
02:25:41 <merijn> purelazy: What exactly are you doing? :)
02:25:41 <purelazy> Ultimately, I need to read a binary file into a [Word32]
02:25:51 <purelazy> merijn: That :o)
02:25:53 <merijn> purelazy: Right, reading binary files -> use binary
02:26:03 <merijn> purelazy: That has lots of stuff for parsing binary formats
02:26:43 <purelazy> merijn: I came across Data.ByteString.Conversion
02:27:11 <purelazy> which has a FromByteString type class
02:27:29 <merijn> Which library is that?
02:27:52 <purelazy> bytestring-conversion
02:28:57 <purelazy> I was hoping for something as simple as let x = (fromByteString bytestream) :: [Word32]
02:29:10 <merijn> tbh you should just use binary when I look at that. Less dependencies and probably simpler
02:29:49 <merijn> purelazy: binary is just "runGet (many getWord32host) bs"
02:30:12 <merijn> And then you can get error checking, incremental parsing, etc. later
02:33:30 <purelazy> merijn: Thanks for that.
02:34:23 <merijn> purelazy: you might want to use a different getWord32, depending on the byte order of your file
02:35:13 <purelazy> the file is bigend, my machine is little end
02:35:49 <EvanR> what the machine is doesnt matter
02:35:50 <merijn> purelazy: Right, binary has different combinators to do said conversion for you
02:36:08 <merijn> purelazy: getWord32be <- reads a big endian one and converts to whatever your machine is
02:36:09 <EvanR> what the file is matters, the computation to get a number from the bytes is the same regardless of the machine
02:36:26 <merijn> EvanR: Well it matters if you're directly grabbing bytes :p
02:36:33 <merijn> EvanR: You need to swap the order
02:37:02 <EvanR> directly grabbing bytes with unsafeCoerce ... no idea what that is
02:37:15 <merijn> EvanR: Using Bits to build Word32 for a large number of words in a file is a ludicrous idea
02:37:21 <EvanR> i agree
02:37:27 <EvanR> use the parser lib
02:37:36 <merijn> EvanR: What does unsafeCoerce have to do with it?
02:37:52 <EvanR> conceptually the computation with shifts and ors is the same regardless of the machine
02:38:32 <EvanR> swapping the 4 bytes and using unsafeCoerce would be more efficient but irrelevant
02:38:42 <merijn> I wouldn't use shifts to grab bytes from a buffer, tbh
02:38:45 <purelazy> merijn: So its pretty much runGet (many getWord32host) bs 
02:39:01 <EvanR> to convert a single thing to a single thing in isolation and understanding.....
02:39:03 <merijn> purelazy: If your file is big endian then you should use getWord32be, but yes
02:39:11 <EvanR> this is like "unicode doesnt matter, its all just bytes"
02:39:43 <merijn> purelazy: There's also incremental parsing and one that does error checking, but the types of most things are pretty self explanatory
02:40:05 <lpaste> purelazy pasted “ByteString to [Word32]” at http://lpaste.net/351172
02:40:09 <EvanR> 4 bytes is a different datatype / domain from 1 Word32 (N mod 2^32)
02:41:07 <purelazy> I did write my own ByteString to [Word32]
02:41:11 <EvanR> even if everything is utf8 and conversion functions are the identity, we still have that conversion
02:41:32 <purelazy> But I've been looking for a one-liner
02:42:07 <EvanR> like a lot of stuff that youd think is a oneliner in haskell its a lib
02:42:13 <merijn> EvanR: Depends on what you're writing, I mmap all the things :p
02:43:34 <merijn> Conversions are expensive :)
02:45:03 <purelazy> FYI: The binary file is SPRIV bytecode (or rather Word32 code)
02:45:11 <purelazy> SPIR-V
02:48:03 <EvanR> when its the identity, ideally that gets optimized away entirely
02:49:46 <Rodenbach> Is there a way in ghci to get a list of types in a certain typeclass? For example, I would like to see what types „Num” has.
02:50:40 <EvanR> :info
02:50:46 <EvanR> :info Num
02:51:09 <Rodenbach> Good, works, thanks!
02:51:49 <merijn> Rodenbach: Note, that only reports whatever you happen to have imported
02:52:08 <merijn> Rodenbach: It (obviously) can't print out types which you don't have imported, since it can't know they're instances
02:52:20 <Rodenbach> Ok, makes sense.
02:53:22 <Rodenbach> At https://tryhaskell.org/ I can type    maxBound  and get  ()  as a reply. In ghci I see something that more looks like an error message. Why is that?
02:53:38 <merijn> Rodenbach: Defaulting :)
02:54:27 <merijn> Rodenbach: Basically, suppose I write "show maxBound" we end up with "maxBound :: (Show a, Bounded a) => a"
02:54:53 <merijn> Rodenbach: How could GHC possibly *which* of the (presumably many) types that match that you want?
02:55:14 <dramforever> GHC says, well it
02:55:17 <merijn> Rodenbach: There are some defaulting rules for how to pick a "default" type, but only for a small set of things
02:55:18 <dramforever> it's probably ()
02:55:46 <merijn> Rodenbach: tryhaskell has extended the defaulting rules to cover this specifice case (you can create your own defaulting rules if you want)
02:56:13 <merijn> Rodenbach: ghci is presumably giving you an "ambiguous type" error, which is because it is, well, ambiguous which type you want :p
02:56:24 <merijn> (Since it can be anything that is Bounded and Show)
02:56:25 <Rodenbach> Oki, I see.
02:56:29 <dramforever> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
02:56:32 <merijn> Rodenbach: The solution is to annotate what you want
02:56:36 <merijn> > show maxBound
02:56:38 <lambdabot>  "()"
02:56:47 <merijn> looks like lambdabot also has defaulting
02:56:52 <merijn> > show (maxBound :: Int)
02:56:54 <lambdabot>  "9223372036854775807"
02:57:12 <dramforever> Rodenbach: wait a sec, which version do you have?
02:57:33 <dramforever> Because it's *also* () in GHCi here
02:57:49 <merijn> Doesn't ghci also do extended defaulting?
02:57:53 <merijn> Just GHC doesn't
02:58:05 <Rodenbach> Version 7.6.3
02:59:30 <EvanR> > maxBound + 1
02:59:32 <lambdabot>  error:
02:59:32 <lambdabot>      Ambiguous occurrence ‘maxBound’
02:59:32 <lambdabot>      It could refer to either ‘Prelude.maxBound’,
02:59:37 <EvanR> doh
03:00:13 <EvanR> was supposed to say 9223372036854775808
03:01:34 <merijn> EvanR: no, that'd be negative
03:01:40 <merijn> > (maxBound :: Int) + 1
03:01:43 <lambdabot>  error:
03:01:43 <lambdabot>      Ambiguous occurrence ‘maxBound’
03:01:43 <lambdabot>      It could refer to either ‘Prelude.maxBound’,
03:01:55 <merijn> @undefine
03:01:56 <lambdabot> Undefined.
03:01:57 <merijn> > (maxBound :: Int) + 1
03:01:59 <lambdabot>  -9223372036854775808
03:02:03 <EvanR> i know
03:02:09 <EvanR> it was going to be a hilarious joke
03:02:27 <EvanR> MAX PLUS
03:03:26 <purelazy> merijn: where is "many" in runGet (many getWord32host) bs
03:20:32 <eklavya> is there any reason to use =<< other than you want to write it b =<< a instead of a >>= b ?
03:22:12 <norfair> eklavya: not really. Maybe when you use it as a higher-order argument it may be more useful
03:22:26 <norfair> because then you don't have to write (flip (>>=))
03:22:36 <eklavya> ok
03:22:41 <eklavya> thanks norfair :)
03:26:11 <tsahyt> eklavya: I'd say stylistically it can be nicer when you compose pointfree stuff with it. e.g. foo . bar =<< quux. you can read this entirely right to left, while with quux >>= foo . bar you have to parse left to right for >>= but right to left for .
03:26:39 <tsahyt> this occurs when you have some pure transformation before feeding it into the next monadic function
03:31:04 <qz> i'm trying to "run" nicta course locally and have this problem https://github.com/NICTA/course/issues/177 , in the same time "stack build" compiles everything just fine. what could be the problem?
03:31:43 <dibblego> Axman6: ^^
03:35:11 <Axman6> qz: does stack repl work?
03:35:27 <Axman6> or, stack exec ghci? (this are not synonyms)
03:36:28 <qz> Axman6: wow, stack exec ghci works (stack repl does not)
03:37:19 <Axman6> yeah I found that when trying to get the course wokring with stack.
03:37:42 <Axman6> dibblego: it's broken in cabal too, so can't blame stack for this one =)
03:37:54 <qz> Axman6: although it shows some errors like "Variable not in scope: concatMap" but at least it stays in ghci
03:37:58 <dibblego> Axman6: I don't blame stack for it.
03:38:02 <Axman6> and it the same error from stack
03:38:05 <dibblego> stack is useless for other reasons
03:38:20 <qz> useless?
03:38:29 <Axman6> dibblego: yeah I know, just hoping whatever fix there is for cabal will also sort out stack repl
03:38:53 <dibblego> Axman6: I fought cabal all day.
03:40:04 <Gloomy> Hi :) 
03:40:21 <qz> is there any way to make it now show correct locations in files with errors ? <interactive>:1:39: error: ...  is useless :(
03:40:34 <Gloomy> What can cause ghc to compile smoothly but ghci to fail on a function execution? 
03:40:39 <Gloomy> This is the error I get: 
03:41:10 <Gloomy> http://lpaste.net/351173
03:41:18 <Axman6> qz: agreed, it makes debugging really painful. I hit my head against that for about a day before giving up
03:41:50 <Gloomy> If I compile the module and run that same function from main it runs perfectly
03:42:58 <Gloomy> Someone yesterday suggested that it could be because an imported library uses compiled haskell code and ghci can't use that, but I couldn't find a way to make it work even with -fobject-code ? 
03:43:30 <Axman6> qz: anyway, seems cabal repl is doing something funky, which I think has something to do with NoImplicitPrelude but I didn't look into it enough
03:43:54 * Axman6 -> bed
03:45:48 <tabaqui1> what happens if I put in IORef (Int -> IO Int) function from child thread
03:45:59 <tabaqui1> for example function that returns currentThreadID?
03:46:21 <tabaqui1> *myThreadID
03:47:02 <tabaqui1> if I call it from main thread, I'll get main thread id or child thread id?
03:47:08 <Phillemann> I probably just don't see it, but: isn't there a "indexOfSubstring" function in Data.Text?
03:47:27 <suppi> is there a haskell lib that converts markdown to lucid?
03:47:56 <norfair> suppi, sounds like something that pandoc would do
03:48:01 <norfair> but I don't know what lucid is tbh
03:48:13 <tabaqui1> well, ok, I check it, but actually I want to send closured function and use it like in child thread
03:48:29 <suppi> norfair: pandoc can convert markdown to html
03:48:56 <suppi> lucid is a haskell combinators library for writing html :)
03:49:03 <qz> Axman6: so its cabal itself who gives those errors and its not because of source code i'm compiling?
03:49:24 <norfair> suppi: Thanks for explaining, then I don't have an answer for you :)
03:49:27 <qz> because i moved all files containing "return" to other place and still error is there
03:49:38 <suppi> i know the 'markdown' can convert md to blaze-html, but i'm using lucid :(
03:49:48 <suppi> norfair: yw and thanks anyway
03:57:47 <lynnard> when you write classes on monad transformers - how do you make a transformer of a transformer an instance?
03:58:28 <lynnard> e.g., MyClass t where....;    MyClass t => MyClass (MyTrans (t...)) -- obviously not working
03:59:05 <norfair> lynnard: what do you mean 'not working'
03:59:43 <norfair> You might want to have a look at some examples: https://github.com/ekmett/mtl/blob/master/Control/Monad/Reader/Class.hs
03:59:59 <lynnard> given a type: MyTrans (t m) a; impossible to write an instance for (MyTrans . t)
04:00:07 <lynnard> unless making a new type
04:00:32 <lynnard> the only thing I can think about is to have a newtype wrapping like: newtype MyTransWrapper t1 m a = MyTrans (t1 m) a;  instance MyClass (MyTransWrapper t1) where
04:01:56 <purelazy> merijn: there?
04:02:13 <merijn> purelazy: Control.Applicative
04:02:21 <merijn> :t Control.Applicative.many
04:02:23 <lambdabot> Alternative f => f a -> f [a]
04:02:46 <purelazy> merijn: wha...? :)
04:04:08 <merijn> purelazy: I just got back from lunch/meeting and saw your "where is many?" question, unless you had another one now :p
04:04:47 <purelazy> I didn't know about many
04:04:58 <purelazy> I guess I ended up writing my own many
04:05:03 <qz> oh, debugging by trial and error shows that ghci fails with any project that has NoImplicitPrelude and RebindableSyntax turned on in .cabal file 
04:05:10 <qz> anyone knows if that's known problem?
04:05:12 <kuribas> is it possible to make self-modifying code?  I mean a program that modifies it's own source?
04:05:22 <lpaste> purelazy pasted “Using binary” at http://lpaste.net/351174
04:06:07 <purelazy> merijn: Of course, now you mention about "many", my version is still far from a one-liner
04:06:56 <merijn> kuribas: You mean in Haskell?
04:06:59 <kuribas> merijn: yeah
04:07:12 <kuribas> merijn: I need to know the location of a numeric constant
04:07:14 <merijn> kuribas: Yes, if you're willing to invest a non-trivial amount of engineering time
04:07:35 <kuribas> merijn: I suppose Num doesn't support HasCallStack.
04:08:05 <merijn> purelazy: Pretty sure you can replace like all of that code with simply Control.Applicative.many
04:08:24 <merijn> Since "many getWord32be :: Get [Word32]"
04:08:51 <purelazy> ok
04:08:55 <merijn> kuribas: I think you can add HasCallStack to anywhere?
04:09:02 <merijn> :t Control.Applicative.many
04:09:05 <kuribas> merijn: ah, I can?
04:09:05 <lambdabot> Alternative f => f a -> f [a]
04:09:20 <merijn> purelazy: Note that Get is an Alternative :) so "many :: Get a -> Get [a]"
04:09:58 <merijn> purelazy: Also, you're using getWord32le, but you said your data was big endian?
04:10:19 <kuribas> merijn: but I cannot give fromInteger another type than from Num?
04:10:57 <merijn> kuribas: I'm not entirely sure on the details of using HasCallStack, tbh
04:11:02 <purelazy> merijn: I think I was wrong about the file's endianness
04:11:25 <kuribas> merijn: perhaps I can hack something with unsafePerformIO.
04:11:45 <purelazy> merijn: I check the first 4-byte magic number
04:12:00 <purelazy> But well remembered!!! :)
04:13:15 <lpaste> merijn annotated “Using binary” with “Using binary (annotation)” at http://lpaste.net/351174#a351175
04:13:22 <merijn> purelazy: afaik that should be all you need
04:13:22 <kuribas> merijn: or template haskell.
04:13:42 <merijn> kuribas: Have you looked at what the GHC manual says about HasCallStack?
04:14:44 <kuribas> merijn: it wouldn't work anyway, since I cannot provide a type for an instance method.
04:15:05 <merijn> You can with some extension I forgot
04:15:38 <kuribas> merijn: I think template haskell will be a cleaner solution.
04:16:25 <purelazy> merijn: I get No instance for (Control.Applicative.Alternative Get) arising from a use of `many' Possible fix: add an instance declaration for  (Control.Applicative.Alternative Get)
04:16:43 <merijn> hmmm
04:17:11 <merijn> I think your binary is old
04:17:13 <merijn> "Alternative GetSource#	"
04:17:14 <merijn> Since: 0.7.0.0
04:17:23 <merijn> So it only has that since 0.7.0.0
04:19:26 <purelazy> My build-depends has binary without any less-thans, greater-thans
04:20:05 <merijn> Right, so apparently it picked an older one
04:25:55 <purelazy> merijn: OK. Its all sorted
04:26:25 <purelazy> I hadn't made BinaryTest part of the project
04:27:36 <purelazy> merijn: Anyway, another successful round of code golf thanks to you.
04:37:21 <ph88^> code golf ?
04:38:08 <merijn> ph88^: trying to solve a problem in the smallest amount of characters (i.e. keystrokes)
04:38:18 <merijn> ph88^: Like golf is about minimising strokes :)
04:38:39 <kuribas> how is "foo :: (a ~ ()) => a" different from foo ()?
04:38:45 <ph88^> ah
04:39:23 <merijn> kuribas: I think it affects inference
04:39:37 <merijn> But don't ask me the details :p
04:51:39 <quchen> kuribas: constraints are checked at a later stage than ordinary types
04:52:01 <kuribas> quchen: for typeclasses, or in general?
04:52:07 <quchen> For classes
04:52:18 <quchen> For example, you could write   instance (a ~ ()) => Show (IO a)  I think
04:52:31 <quchen> show = print
04:52:58 <quchen> I think there was a post about this some time ago. Probably by Chris Done.
04:53:39 <quchen> Let me see whether I can find it.
04:54:08 <quchen> Correction: my example above was complete nonsense and the typechecker hates me for it
04:54:58 <quchen> kuribas: Ha, it even mentions your very question. http://chrisdone.com/posts/haskell-constraint-trick
04:55:32 <kuribas> quchen: yeah, I read it...
04:57:14 <kuribas> quchen: so that works because constraint checking is done after instance resolution?
04:58:42 <quchen> Yes, basically the instances are resolved right away, and the constraints to satisfy are checked one step later.
05:05:50 <kuribas> ok thanks
05:06:21 <quchen> How do I convert Float to Double? :-x
05:07:03 <merijn> realToFrac?
05:07:10 <merijn> :t realToFrac :: Float -> Double
05:07:12 <lambdabot> Float -> Double
05:07:32 <merijn> quchen: If it's numeric conversion and it's not fromIntegral it's always realToFrac :p
05:07:44 <quchen> Thanks :-)
05:07:49 <cocreature> realToFrac is a pretty weird name for converting from Float to Double
05:07:55 <cocreature> (yes I know it’s more general)
05:07:56 <hpc> :t realToFrac
05:07:58 <lambdabot> (Real a, Fractional b) => a -> b
05:08:06 <hpc> i don't even remember what Real is
05:08:16 <hpc> the numeric hierarchy is pretty weird at times
05:08:28 <quchen> You forgot an »all« there
05:08:31 <merijn> hpc: Well, a Real is a Real? :p
05:08:44 <cocreature> merijn: so why does it have a toRational method? :)
05:08:56 <merijn> cocreature: Because the universe hates you
05:09:17 <merijn> cocreature: And because you can't write infinite literals in a source file
05:09:35 <merijn> oh, wait, that'd be for fromRational, I suppose
05:09:38 <hpc> :t pi
05:09:40 <lambdabot> Floating a => a
05:09:42 <cocreature> defining Reals as the things that can be converted to Rationals is a pretty weird definition
05:11:03 <hpc> fun fact, CDouble has both Real and Floating instances
05:11:09 <hpc> which means it's valid to write toRational pi
05:11:37 <kuribas> cocreature: youh, why didn't they call it fromFractional?
05:12:03 <kuribas> :t fromFractional
05:12:05 <lambdabot> error:
05:12:05 <lambdabot>     • Variable not in scope: fromFractional
05:12:05 <lambdabot>     • Perhaps you meant one of these:
05:17:26 <merijn> Man, I wish Kleisli didn't require explicit wrapping
05:32:24 <merijn> And Kleisli is not an Applicative
05:32:26 * merijn sighs
05:37:34 <merijn> Am I somehow the only person on the planet who wants to deserialise XML to Haskell datatypes? I can't seem to find any documentation on how to conveniently do that for any of the XML libraries, every documentation/tutorial is just walking paths down the tree
05:38:52 <M2tias> merijn: sorry if this is stupid but here? https://wiki.haskell.org/HXT/Conversion_of_Haskell_data_from/to_XML#Deserializing_from_Xml
05:40:03 <merijn> What I see there is a lot of generics that seems to generate a (de)serialiser for an existing ADT and then using that
05:40:13 <merijn> Not how I can deserialise an already existing format
05:40:33 <merijn> Especially since I don't want to keep all of the data in the original format
05:40:54 <Adeon> do you mean the pattern that aeson/yaml/cassava/some of the sql libraries use?
05:40:56 <Adeon> FromJSON/ToJSON etc
05:41:11 <quchen> Write an XML to JSON converter and use Aeson ;-)
05:41:36 <Adeon> I guess I should consider myself lucky I haven't had to parse XML in haskell yet...
05:41:52 <merijn> Adeon: I have no idea, I've never used aeson
05:42:30 <M2tias> what does "an already existing format" mean?
05:42:33 <merijn> All the documentation for xml-conduit, HXT, etc. focuses on "here's how you traverse the XML tree" which is all fine and good, but nothing on "how do I ensure there's exactly 1 copy of tag X and grab that"
05:42:49 <Adeon> oh I see
05:42:52 <merijn> M2tias: I have a bunch of existing XML, well I'm not even sure it's technically XML, and I need to parse that
05:43:23 <M2tias> why can't you form ADT based on it and use that? or am I missing something
05:43:34 <merijn> Like, this format at some point contains a list of "foo" elements which should all have, for example, an id, name, etc. and I want to decode that
05:44:12 <merijn> M2tias: Because then I have to write HXT code that maps my ADT to the right XML, but since the XML is messy and contains lots of useless stuff I don't want to actually match the XML exactly
05:44:29 <merijn> I just wanna grab the fields I care about and ensure there's no obvious mistakes like duplicate names/ids
05:44:58 <Adeon> yesh this would be like perfect aeson-solvable problem except it's XML so you can't have that
05:45:00 <merijn> i.e. if a foo has two names I wanna detect that and log it somewhere so I can manually sort that out later
05:45:12 <M2tias> why don't you just make a similarly nested ADT and then traverse the XML and the ADT side by side or something?
05:45:30 <M2tias> it's weird that I can't find anything on google though
05:46:04 <merijn> M2tias: Because that'd be even more painful than the current messy hacks I have
05:46:45 <merijn> Currently I'm just grabbing a Cursor to each element and repeatedly parse down from their to find the singleton fields I need/want and then at the end check that none of them failed
05:47:03 <merijn> but that's rather sucky and messy
05:47:25 <merijn> And I find it hard to believe that no one else has ever done this before
05:47:37 <merijn> But I can't really find any examples of people doing this either
05:48:01 <Adeon> the aeson approch is
05:48:12 <Adeon> you define typeclass FromJSON to each haskell type you want to parse out
05:48:30 <Adeon> you write a function that gets JSON-type value which is already parsed out by aeson
05:48:39 <Adeon> and you return a Parser which is a monad, also alternative
05:48:59 <Adeon> and you get utility functions to pick out whatever elements you want and it'll do failure if the fields don't exist
05:49:11 <Adeon> and you can recursively parse other haskell types out if they also implement that typeclass
05:49:29 <Adeon> can use `guard` to check that elements make sense etc. if you don't want to get invalid data
05:49:44 <Adeon> I think this same idea should be usable for xml as well? I think several libraries actually use something very similar to this
05:50:13 <merijn> Adeon: Sure, so do I, but I can't seem to find a library that works like that
05:50:29 <merijn> HXT seems to want a complete DTD and both a serialiser AND deserialiser
05:50:30 <Adeon> yeah...maybe nobody just bothered for xml
05:58:36 <f-a> I use cabal new-repl and then :load a specific module, but how to load a test module?
05:59:04 <f-a> cabal new-repl --enable-tests doesn't seem to work (i.e. when I type :l <tab> I don't see any test modules)
06:06:28 <reactormonk> The emacs haskell package complains about haskell-stack-ghc "cannot satisfy -package QuickCheck"
06:09:29 <reactormonk> ah, just gotta make sure the packages are installed.
06:25:28 <reactormonk> How do I make stack reparse the stack.yaml file and fetch additional dependencies?
06:30:16 <kadoban> reactormonk: It typically does it automatically when it needs to. Maybe you want something like 'stack build --only-dependencies' ? Not something you usually have to do though.
06:32:08 <reactormonk> kadoban, trying to fix it not finding QuickCheck (via emacs flycheck)
06:33:04 <kadoban> I don't use flycheck, or emacs, sorry.
06:33:11 <reactormonk> stack exec ghc -- -package QuickCheck gives me "cannot satisfy -package QuickCheck", so I'm trying to fix that by adding QuickCheck-2.9.2 to extra-deps, but is somehow doesn't pick that up.
06:33:44 <reactormonk> kadoban, the above should be unrelated to emacs.
06:33:52 <kadoban> Try what I suggested then, 'stack exec' does no building or downloading or anything whatsoever, as far as I know.
06:34:32 <reactormonk> Tried the stack build --only-dependencies, didn't help... hm
06:35:42 <kadoban> Is there more to any error messages you're getting?
06:39:31 <sm> reactormonk: stack will fetch QuickCheck only if your stack.yaml or cabal file(s) tell it to
06:40:05 <sm> or you can force it once, with stack install QuickCheck
06:41:07 <sm> rephrased: stack build will only install deps specificed by your stack.yaml/cabal files. Use stack install PKG if you want to manually install something extra
06:54:46 <romano> does anyone have experience running a parallel strategy inside an async? i've been struggling for the past couple of days and i can't get it to use 2 cores (i'm using -threaded -N2)
06:57:10 <mmachenry> romano: You're not using -threaded and -N2 as ghc arguments, are you?
06:57:23 <mmachenry> If I recall, -N2 is an RTS argument.
06:57:52 <Tuplanolla> There's a way to compile default RTS flags in though, isn't there, mmachenry?
06:57:56 <mmachenry> So you'd compile with -threaded and then run your code with ./mybinary —regular-arg +RTS -N2
06:58:21 <mmachenry> Tuplanolla: Not that I've heard of but that's totally possible. 
06:58:28 <merijn> mmachenry: You can
06:58:40 <merijn> -ghc-rts-opts or whatever it's called
06:58:50 <kadoban> There is a way to have default RTS flags, but it's not just providing the flags directly to GHC as-is.
06:58:54 <merijn> Tuplanolla: Although you can also just control multithreading in the binary :)
06:59:01 <mmachenry> Maybe romano should try my way just as a test though, even if you can build it in, to see if it works for him that way.
06:59:08 <reactormonk> sm, thanks, that's what I've been looking for.
06:59:17 <Tuplanolla> Certainly, merijn and mmachenry.
06:59:25 <merijn> Secret l33t trix: "getNumProcessors >>= setNumCapabilities"
07:00:36 <romano> merijn, mmachenry, i've set flags correctly. -threaded for compilation and -N2 at runtime. i'm checking this in my program too
07:00:59 <romano> and it shows threaded and 2 capabilities
07:01:29 <merijn> romano: You'll have to paste a minimal example of what doesn't work because this isn't enough info to go from :)
07:01:59 <romano> merijn, understood. i will factor something out
07:02:01 <mmachenry> romano and all: do you need to compile the binary with rts-opts enabled? 
07:02:28 <Tuplanolla> Yes, mmachenry.
07:02:28 <reactormonk> What's the proper way to check if file exists, then read?
07:02:53 <Tuplanolla> Try to read and catch the error, reactormonk.
07:03:03 <mmachenry> merijn: Yeah at this point I guess the most likely scenario is that his code possibly doesn't have the ability to use more than one core in a non-obvious way.
07:03:12 <reactormonk> Tuplanolla, I considered doing a doesFileExist first
07:03:21 <Tuplanolla> Not atomic, reactormonk.
07:03:34 <Rodenbach> Do function applications have precedence over infix operations?    When I define    bar x y = foo x + foo y      then I don’t get a complaint that + can’t work on x and foo. No parens needed.
07:03:49 <mmachenry> romano:  So you did also compile with the flag that enables rts-opts to be used on your binary, right?
07:03:55 <reactormonk> Tuplanolla, I assume that's catchError?
07:04:19 <Tuplanolla> Any such thing will work, reactormonk.
07:04:28 <mmachenry> Rodenbach: function application is one of the most high precedence operations. 
07:04:45 <romano> mmachenry, yes -rtsopts
07:04:51 <Rodenbach> Ok, thanks for confirming mmachenry.
07:04:55 <merijn> Rodenbach: Function application has higher precedence than infix operators, yes
07:04:56 <mmachenry> Rodenbach: So yeah f x + g x should work fine.
07:05:17 <merijn> Rodenbach: Operators have precedence 0 through 9, function application has precedence 10 and record syntax has precedence 11
07:05:47 <mmachenry> Rodenbach: Run hlint on your code to see where you've added extra parenthesis. 
07:07:31 <Rodenbach> Ah interesting, didn’t know about this tool. Good hint, thx!
07:08:21 <merijn> Is there a law that "fail == mzero" for MonadPlus?
07:11:04 <Gloomy> Someone knows what could be causing this error? http://lpaste.net/351173
07:11:42 <Gloomy> the module compiles and run perfectly with GHC, but fails with that error in ghci when executing a function
07:12:42 <Tuplanolla> I have a feeling you have two conflicting versions of a single package installed, Gloomy.
07:13:14 <Gloomy> Tuplanolla Really? Why? and how can I fix it?
07:13:53 <Tuplanolla> It's just a hunch, Gloomy. Linker errors don't usually pop up unless something is corrupted.
07:14:55 <Gloomy> Tuplanolla  Alright, I'll investigate. But how come with ghc it works then?
07:35:44 <jchia_> I got some structured JSON file that I want to navigate to a certain part of and extract all the keys of that part. How do I do this without ceremony, e.g. from GHCI, without defining any special data types describing the structure, like how I could do it in Python where everything is just presented as maps and lists?
07:35:58 <jchia_> I just want to get the keys of some object inside
07:37:14 <jchia_> afaik, the only thing i can do with a Value is to parse it into something else. I can't 'cast' it into a HashMap even if I know it's an Object.
07:37:32 <jchia_> i'm talking about interactive examination of some json
07:37:34 <byorgey> jchia_: are you familiar with lens?
07:37:46 <jchia_> byorgey: only the very basics
07:37:55 <jchia_> getters and settors
07:37:58 <jchia_> setters
07:38:13 <jchia_> byorgey: would aeson-lens help?
07:38:28 <byorgey> jchia_: well, you might try http://hackage.haskell.org/package/lens%2Daeson
07:38:31 <byorgey> not aeson-lens
07:38:59 <jchia_> byorgey: Thanks, I'm taking a look
07:39:27 <byorgey> if you look at the Haddock documentation it has a bunch of examples
07:39:31 <jchia_> OK
07:50:23 <glguy> jchia_: you can just use it like maps and lists like in Python
07:51:44 <jchia_> glguy: I suppose you mean with things like withObject and withArray?
07:52:02 <jchia_> do you have an example
07:56:25 <Rodenbach> I ask ghci for   :t (10,20,30,"x")   and it tells me:  (10,20,30,"x") :: (Num t, Num t1, Num t2) => (t, t1, t2, [Char]).   Why doesn’t it directly say (Num, Num, Num, [Char]), but names the different Nums first?
07:57:28 <geekosaur> because Num is not a type, it is a constraint on a type
07:58:41 <yhhko> Rodenbach: in other words: because 10 is both an Int and a Float, and ghci doesn't want to force you to make a choice
07:58:54 <yhhko> (and also other things)
07:59:31 <geekosaur> well, I suspect the real problem here is they're imagining an OO type system where Num would be a superclass type
07:59:44 <geekosaur> but that's not how Haskell types work
07:59:45 <Boomerang> Rodenbach: Also it shows several Nums instead of (10,20,30,"x") :: Num t => (t, t, t, [Char]) because they could be different Nums for example (Int, Integer, Double, [Char])
08:01:33 <Rodenbach> Boomerang: ah okay, that makes sense.
08:01:50 <nitrix> Rodenbach: Type inference works by starting with the most general type and constraining it down based on the information it has.
08:03:19 <nitrix> Rodenbach: Then the type checker validates the well knowns and inferred types fit together.
08:03:56 <glguy> jchia_: or just with pattern matching, the Value type is just a sum of a hashmap, number, text, array, and nil
08:05:59 <jchia_> glguy: pattern matching seems quite hard to do interactively from ghci. actually i don't even know how to use 'case' within ghci
08:06:55 <lyxia> > case Nothing of Just () -> True ; Nothing -> False
08:06:58 <lambdabot>  False
08:07:12 <glguy> case in ghci is the same as normal, you can match with a let, too, or you can use the with functions you mentioned
08:07:18 <jchia_> lyxia: OK, I see, you put everything on one line with semicolon
08:09:19 <jchia_> i wasn't used to using semicolons and i think ghci can't do multi-line input
08:09:40 <geekosaur> it can, several ways
08:09:54 <geekosaur> :{ :} bracketing, or :set +m
08:10:06 <geekosaur> (each has warts though)
08:10:11 <dranzer> part
08:14:16 <glguy> jchia_: for just exploring in GHCi you can write:   let Object m = v
08:14:26 <glguy> and now m will be available in future GHCi inputs
08:14:49 <jchia_> glguy: yeah, and if it's not an Object, ghci just complains, no big deal
08:15:04 <glguy> Right
08:17:35 <eklavya> I can't seem to find something for paper printing, only pretty printing on terminals :(
08:17:54 <eklavya> does anybody know of a printing (to a printer) lib for haskell?
08:18:44 <ongy> photocopy the pretty terminal
08:21:08 <eklavya> ongy: I can't tell if you are joking :P
08:21:33 <ongy> if you need to do it programatically you can screenshot
08:21:38 <nitrix> hackage.haskell.org/package/acme-photocopy-the-pretty-terminal
08:22:34 <eklavya> printing that way would not look good
08:23:21 <eklavya> I guess this suggestion only means printing is not yet supported :D
08:23:29 <Boomerang> you could use pandoc to generate tex of pdf
08:23:58 <eklavya> Boomerang: I still need to print that pdf though
08:24:10 <eklavya> programatically 
08:24:29 <eklavya> preferably through haskell
08:24:57 <Boomerang> That's more an os thing, you could use Turtle shell and use something like lpr (on linux) to print a pdf you generated earlier
08:26:26 <eklavya> needs to be cross platform
08:26:30 <eklavya> :(
08:27:01 <josevalim> hi everyone. I have been experimenting with rank 3 types to learn more about them and it is unclear why this example does not type check once the argument is abstracted to its own function: http://lpaste.net/7860706843729854464
08:27:39 <eklavya> although, is it possible to generate excel files? ala poi (Java/Scala)?
08:28:18 <glguy> josevalim: You have to provide type signatures for rank-n to kick in
08:28:39 <glguy> josevalim: and parentheses aren't involved in function application like you might be used to in C
08:29:08 <josevalim> glguy: so in this case I would have to provide the type signature once I abstract it away but if i don't abstract it the type system can figure it out by itself?
08:29:31 <glguy> josevalim: and the compiler probably didn't report "does not work" as the error message
08:29:37 <glguy> that'd be good to include in your pastes
08:29:54 <Boomerang> eklavya: I think the package xlsx does that, I don't know how good it is though
08:30:06 <eklavya> I think generating xls files maybe good enough 
08:30:21 <eklavya> thanks Boomerang ongy :)
08:30:30 <josevalim> glguy: good call, i will include it in the gist
08:30:52 <geekosaur> josevalim, if you specify a type signature, you must specify the whole thing, it won't infer things you left out.
08:31:20 <geekosaur> (modulo PartialTypeSignatures extension which requires you to use wildcards where you want inference to happen)
08:33:22 <glguy> josevalim: You'll need to provide a type signature for callsWithIdentity
08:33:37 <glguy> otherwise it won't have the correct type for you to use it with rank3
08:34:30 <joe9> Is something wrong with stack repos on github? http://codepad.org/nh3VDzpm
08:34:57 <lpaste> glguy annotated “Rank 3 experimentation” with “fixed with type signature for josevalim” at http://lpaste.net/7860706843729854464#a351181
08:35:50 <josevalim> glguy: beautiful, thank you
08:39:52 <geekosaur> joe9, github itself is broken 
08:40:01 <glguy> stack broke github?
08:40:01 <geekosaur> https://twitter.com/githubstatus/status/819940738452615168
08:41:32 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org' by ChanServ
08:41:46 <joe9> geekosaur: Thanks.
08:43:56 <geekosaur> and, https://twitter.com/githubstatus/status/819947685503442945 (but that was suspiciously fast...)
08:47:27 <josevalim> glguy: one last question: do you know why it works with anonymous functions and it doesn't for named ones? If the call site of "callsWithIdentity" would simply be replaced by its contents, then it was supposed to work equally, but that's clearly not the case
08:48:00 <josevalim> glguy: or it could be the opposite: none of them is supposed to work but the type system is using some information from anonymous functions to make it work
08:48:08 <josevalim> maybe it is local type inference?
08:48:11 <zipper> Hey can anyone figure what the parse error on L29 is here http://lpaste.net/8817337661325836288#line29
08:48:27 <merijn> zipper: You're indentation is wrong
08:48:28 <glguy> josevalim: callsWithIdentity has a known, rank-1 type. So it isn't compatible with your use in applyRank3
08:48:56 <glguy> josevalim: But when the definition is inlined and the types of the components are being inferred they can be inferred to their needed rank-2 types
08:49:00 <zipper> merijn: Oh man I think I see it
08:49:26 <zipper> merijn: I thought thr author's indenting was wrong
08:49:34 <merijn> zipper: 29 through 31 need to be indented to match the let
08:49:39 <glguy> josevalim: named values will always infer a rank-1 type on their own
08:50:20 <zipper> merijn: Why are we putting it in a `do` block?
08:50:34 <zipper> merijn: I don't see where the monad is :)
08:50:35 <merijn> zipper: It's a bit redundant, you could use let-in instead of do
08:51:09 <merijn> zipper: If you replace do with "let" and put an in before the last tuple it should work. Not sure why it was written that way
08:51:15 <zipper> merijn: As cool
08:51:22 <zipper> merijn: Yes it did
08:51:56 <Storn> Hi all
08:52:01 <josevalim> glguy: excellent, thanks
08:52:16 <nitrix> Storn: Welcome.
08:52:38 <Storn> Quick question: is there a way to indent multiple lines at the same time in haskell-mode for emacs?
08:53:30 <Storn> I mean, suppose I have a code block and I want to add 4 spaces to at the beginning of every line
08:54:00 <nitrix> `V` and `>>` on vim.
08:54:42 <geekosaur> select the lines to be indented, C-M-\
08:55:21 <geekosaur> (C-u TAB may also work depending on transient-mark-mode)
08:56:44 <nitrix> (Gave vim instructions because of the latest fade of using vim keybindings on emacs lately :P)
09:00:30 <reactormonk> So catchE instead of catchError?
09:06:11 <glguy> reactormonk: You can use 'try :: IO a -> IO (Either IOError a)'
09:06:27 <glguy> and also 'isDoesNotExistError :: IOError -> Bool'
09:06:28 <josevalim> glguy: sorry, one last example. in the rank1 and rank2 functions, can you think of a function that I could pass to rank2 that would not be accepted in rank1 or some code that I would be able to type with the rank2 function but not the rank1 one?
09:07:22 <josevalim> glguy: the reason I am asking is because I am implementing the polar type system and it infers the rank 2 function for \f -> f(\x -> x) out of the box and I would like to have an example that would only pass if I am correctly inferring it to be rank 2
09:07:45 <josevalim> (the polar type system reference: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8718&rep=rep1&type=pdf)
09:08:20 <glguy> josevalim: Do you mean something like  example f = (f (), f True) 
09:12:01 <josevalim> glguy: doh, thank you. rank1(\x -> (x True, x 1)) fails, but it works for rank2. obvious in retrospect :)
09:13:08 <glguy> josevalim: What type would you want to infer for example?
09:13:57 <josevalim> glguy: for which function? \f -> \f(\x -> x) or \f -> (f (), f True)?
09:14:15 <glguy> that latter (the one I confusingly named "example")
09:15:48 <markasoftware> can anybody tell me approximately how long it takse to compile ghc from source?
09:17:09 <davean> On my system about 45 minutes for a full build
09:17:15 <davean> There are faster builds
09:17:40 <markasoftware> hmm, so just as long as gcc then
09:17:48 <davean> Build time is of course system dependant
09:17:57 <davean> So your question is a bit underspecified
09:18:45 <josevalim_> glguy: an intersection type system such as the polar type system (System P) will give it the type example :: ((() -> a) ^ (Bool -> b)) -> (a, b)
09:38:00 <cocreature> hm, I don’t think moving from -O0 to -O2 is supposed to make my criterion benchmark run in 15.31us instead of 3.7us
09:38:50 <glguy> cocreature: where does -O1 fit into the picture?
09:39:33 <cocreature> glguy: 14.5us
09:39:45 <glguy> I'd pick -O0 then ;-)
09:39:56 <cocreature> well my other benchmark gets faster :)
09:40:04 <cocreature> I’m probably just benchmarking the wrong thing
09:40:21 <pikajude> is there a library function somewhere that can perform this task? http://lpaste.net/8255412628835270656
09:40:24 <cocreature> at least I hope so
09:42:14 <davean> cocreature: Or you're getting something like larger code which is falling out of cache
09:42:42 <cocreature> davean: good point, I hadn’t thought about that
09:43:05 <davean> I think actually its a somewhat common issue with GHC and how its tuned against microbenchmarks
09:43:34 <josevalim> glguy: sorry, chaotic internet
09:44:06 <glguy> josevalim: That sounds like an interesting type system. I'll have to read more about it later
09:45:03 <davean> cocreature: I think IIRC binary shows this problem rather clearly?
09:45:13 <cocreature> davean: I have no idea :)
09:45:24 <eklavya> https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple.html     doesn't mention a connection pool, is there one?
09:45:36 <davean> (I think it inlines type class code a *lot* leading to huge code sizes)
09:47:29 <Rodenbach> Could the compiler, in principle prevent an „Empty List” exception, by checking that a call of  `head` can only be reached when previously a `null` check showed that there is at least one element in the list?
09:47:47 <cocreature> davean: is there an easy way to figure out if that’s the problem? just looking at the complete executable sizes I get 48mb vs 51mb which doesn’t seem like a huge difference.
09:47:57 <cocreature> it’s sadly not at all a minimal example
09:48:07 <glguy> Rodenbach: No, in general it has no way to know if the list is empty at compile time or not
09:48:24 <glguy> Rodenbach: You could make a new type of lists that were never empty, however
09:49:40 <davean> cocreature: I don't know an easy way
09:49:54 <Rodenbach> In a branch of `if not (null myList)` we know that `head` can’t throw an exception, I would think.
09:50:27 <mmachenry> Rodenbach: There's also a safeHead I think that has what many people think is the appropriate type for head
09:50:31 <mmachenry> :t safeHead
09:50:33 <lambdabot> error: Variable not in scope: safeHead
09:50:37 <glguy> :t Data.List.listToMaybe
09:50:39 <mmachenry> Something like that :)
09:50:39 <lambdabot> error:
09:50:40 <lambdabot>     Not in scope: ‘Data.List.listToMaybe’
09:50:40 <lambdabot>     Perhaps you meant ‘Data.Maybe.listToMaybe’ (imported from Data.Maybe)
09:50:50 <glguy> :t Data.Maybe.listToMaybe -- yeah that
09:50:52 <lambdabot> [a] -> Maybe a
09:51:12 <mmachenry> :t headMay
09:51:14 <lambdabot> error: Variable not in scope: headMay
09:51:22 <glguy> Rodenbach: If you were locally checking if the list was empty, you wouldn't need head at all. This is where pattern matching comes in
09:51:25 <mmachenry> Alright sorry I suck at LambdaBot
09:51:30 <davean> cocreature: but the -O2 was larger
09:52:23 <Rodenbach> glguy: yes, PM would be a semantic variation of what I was thinking.
09:56:18 <glguy> pattern matching is a principled solution to that problem and doesn't require a set of arbitrary cases like checking that a particular code path is guarded by the  not (null xs), which might break if the expression didn't exactly match some predetermined setof cases
09:59:46 <Rodenbach> I was looking at http://learnyouahaskell.com/starting-out#texas-ranges and the author wanted to know what comes after "John", lexicographically. Is there a better way to do it than this?    [ y | a <- x, b <- x, c <- x, d <- x, let y = [a]++[b]++[c]++[d], y >= "john" ] !! 1
10:01:03 <glguy> Rodenbach: It wasn't that the author doesn't know the answer, but that one exists
10:01:10 <glguy> The point is that it's a nonsense question
10:01:38 <dmwit> Rodenbach: http://community.haskell.org/~ndm/catch/
10:01:47 <dmwit> oh dear
10:01:50 <dmwit> That seems to be a stale link.
10:02:02 <glguy> "John\0" comes after "John"
10:02:13 <dmwit> https://www.cs.york.ac.uk/fp/darcs/catch/catch.htm perhaps
10:02:14 <glguy> treating it as strings istead of "names"
10:02:23 <Rodenbach> Ah, and I defined:   let x = ['h'..'o']
10:02:28 <AndreasK> wouldn't it be joho?
10:02:56 <Rodenbach> I would say it’s joho
10:03:03 <AndreasK> Oh no hes right my mistake
10:03:06 <glguy> > "John\0" < "Joho"
10:03:09 <geekosaur> AndreasK, only by one possible definition. glguy's is another. "John0" is a third
10:03:10 <lambdabot>  True
10:03:17 <glguy> No, Joho comes after John\0
10:03:20 <geekosaur> none of them is fundamental
10:03:38 <AndreasK> Lexiographically the length is a smaller difference if the prefix is the same
10:03:40 <AndreasK> iirc
10:03:49 <glguy> No, that's not lexicographic
10:03:58 <glguy> The dictionary would look funny if all the short words came first
10:04:10 <AndreasK> "if the prefix is the same"
10:05:15 <glguy> Rodenbach: instead of [a]++[b]++[c]..., you can write [a,b,c,d]
10:39:32 <nitrix> How do I check if stdout isn't closed?
10:39:58 <glguy> nitrix: I tab-completed  hIs  in System.IO and saw hIsOpen
10:40:02 <nitrix> I have this thread in a GUI application that doesn't have access to stdout, dying because of an MVar that can't be emptied.
10:40:31 <nitrix> glguy: Mhh, I wasn't using a handle but I'll do that then.
10:40:40 <nitrix> Shouldn't putStrLn do this check internally?
10:41:13 <nitrix> if hIsOpen h then hPutStrLn s else return () -- or something?
10:41:56 <glguy> putStrLn throws an exception if you write to a closed handle
10:54:34 <vektor> Any idea why Stack would unregister and rebuild a lot of dependencies every time I run stack build?
10:58:50 <romano> can someone point me to an example of how to catch an exception in async that has been thrownTo it?
10:59:43 <romano> vektor, switching branches in git? :)
11:00:22 <glguy> romano: The same way you catch any exception, using catch or try
11:01:25 <romano> glguy, yes, but at which level? i have something like this: workers <- mapM (\_ -> async (processQueue q pool acfg)) [1..numWorkers]
11:01:51 <romano> glguy, if it 'try' in processQueue it does not pick up an exception being thrown
11:02:09 <shapr> I've often wondered how uniqueness typing and linear types are related: http://edsko.net/2017/01/08/linearity-in-haskell/
11:02:31 <glguy> romano: Are you using try at the same type as you're using throwTo?
11:02:44 <vektor> romano: No, It's every time I rebuild. and it's kinda annoying.
11:02:58 <glguy> If the try isn't executing when the exception is thrown, then it won't be able to catch it
11:03:05 <romano> glguy, i'm using SomeException
11:04:04 <romano> glguy, i mean i'm using try to catch SomeException and throwing my own exception which is an instance of Exception
11:04:46 <glguy> romano: OK, then if the try is active when the exception is thrown it will catch it. If the try hasn't started yet or is finished, it won't
11:07:04 <romano> glguy, would you mind having a look the the processQueue? http://lpaste.net/351186
11:08:52 <glguy> romano: If the exception arrives while the thread is blocked in line 3, it won't be caught on line 4
11:11:45 <romano> glguy, does it mean i should move 'try' above line 3 or basically i cannot handle exceptions while the thread is blocked?
11:12:31 <romano> glguy, apologies for being annoying. i should give it a try first. never mind. :)
11:12:32 <glguy> It's just a question of what you expect the code to do. You need to wrap try around all of the code that you want it to cover
11:13:38 <glguy> If you always want the thread to continue processing the queue after receiving any exception, you'll need to be even more clever
11:13:49 <glguy> because you could get an exception while recovering from the first one
11:14:02 <romano> glguy, that's exactly what i want to do
11:14:32 <glguy> You'll need to use this or something very similar 'asyncWithUnmask :: ((forall b. IO b -> IO b) -> IO a) -> IO (Async a)'
11:14:38 <romano> glguy, i want to cancel the job already being done without cancelling the worker thread
11:14:54 <romano> glguy, not already - currently
11:14:56 <glguy> so that the outermost body of the thread will be protected from exceptions
11:15:23 <glguy> and then selectively enable exceptions when processing jobs
11:15:56 <romano> cheers
11:16:36 <glguy> Check out the documentation here, too http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:forkIOWithUnmask
11:22:00 <urnanslug> I'm having a hard time understanding reader, state and now parsers completely without understanding monad transformers
11:22:06 <urnanslug> bitemyap1: ^
11:22:14 <urnanslug> I guess I will jump to those
11:22:45 <monochrom> Reader, State, and Parser, each alone does not require monad transformers.
11:22:53 <monochrom> It's ReaderT, StateT etc that do.
11:24:01 <dmwit_> "I am having a hard time understanding X without understanding Y" does not imply "understanding Y will help me understand X".
11:24:27 <dmwit> For example, I am having a hard time understanding ContT without understanding dark matter.
11:24:36 <dmwit> This statement is 100% true.
11:28:19 <sshine> hi. toying around with stack and xmonad. there's something I don't understand. it works, but... I tried 'import XMonad.Util.Run' but couldn't, apparently because my project.cabal only had xmonad and not xmonad-contrib. so I added 'xmonad-contrib >= 0.12' just like I had 'xmonad >= 0.12', and it said it wouldn't work (even though 0.12 was available). running 'stack solver' said I needed to add the extra-dep
11:28:25 <sshine> s 'X11-xft-0.3.1' and 'xmonad-contrib-0.12' to my stack.yaml.
11:28:52 <sshine> why exactly?
11:29:16 <dmwit> Presumably X11-xft is not on stackage.
11:29:20 <sshine> is 'xmonad >= 0.12' in my lts-7.15, but not 'xmonad-contrib >= 0.12'?
11:29:21 <sshine> ah, ok.
11:29:41 <Dupli> Hey guys! I have a problem where I get duplicated prints, and I can't figure out why. I'm trying to lookup values in a Data.Map, and print the solutions when/if they are found. This part works, but it seems like some values gets found multiple times, even though they shouldn't even be in the lookup table that is currently processed, as I use chunksOf (which would make each chunk contain a unique set of key/value-pairs). I'm not sure if
11:29:56 <Dupli> code at the moment: http://lpaste.net/2332806036508901376 Maybe you can spot an error?
11:29:57 <dmwit> sshine: By the way, there's an #xmonad. And also you're probably going to have some trouble using xmonad and stack.
11:30:03 <glguy> sshine: project.cabal build-depends list the range of versions your package supports. Your stack.yaml lists the specific versions you're using in this particular directory right now
11:30:15 <sshine> dmwit, what problem would I have?
11:30:23 <dmwit> sshine: The "xmonad is in charge of recompiling when you make a change" thing makes it hard because it just calls GHC directly.
11:30:30 <geekosaur> chopped off at "not sure if"; IRC has a shortish message length linit (512 bytes minus overhead)
11:30:41 <sshine> dmwit, ah, that part.
11:30:49 <geekosaur> dmwit, see the build script support committed last week
11:31:06 <dmwit> geekosaur: Oh, exciting! I didn't know there was progress on that front.
11:31:09 <sshine> dmwit, I do have a GHC on the system that is equivalent to the stack project's, but yeah, that's not necessarily true.
11:31:27 <dmwit> sshine: Even if you have the same GHC, stack manages its own package database.
11:31:46 <sshine> geekosaur, irssi cuts it into multiple messages. it continues at "s 'X11-xft-0.3.1' ..."
11:31:56 <geekosaur> if ~/.xmonad/build exists and is executable, it will be run instead of the builtin. you can use this to hook cabal or stack into builds
11:31:57 <sshine> dmwit, oh, right.
11:32:11 <sshine> geekosaur, thanks.
11:32:43 <geekosaur> (latest git only. beware arch, they keep breaking their 0.12 which tries to track git)
11:32:51 <Dupli> My initial lookup table [(key1,value1),(key2,value2)] etc is quite big, and takes a long time to convert to a Data.Map using fromList. Therefore I thought I'd use chunksOf on my list, and convert each chunk into a separate Data.Map.
11:32:54 * sshine liked the thought of having a github repo with his xmonad.hs in it and a one-liner to install it anew. :)
11:34:16 <sshine> geekosaur, should ~/.xmonad/build be a shellscript that runs 'stack build && stack install' and that's it?
11:34:36 <Dupli> But even though I split it up in chunks and solve each chunk on its own, it somehow prints "found key 1" multiple times. It's just as if each chunk contain the same key/value-pairs or something...
11:34:47 <geekosaur> sshine, that would work if you have an appropriate stack.yaml in ~/.xmonad, yes
11:34:52 <geekosaur> and cabal file
11:35:21 <Sonolin> so am I correct in assuming you don't need a pre-installed GHC to run stack?
11:35:22 <Sonolin> https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md
11:35:23 <sshine> geekosaur, I'd probably cd ~/Projects/myxmonad then :)
11:35:24 <geekosaur> sshine, also the message split was aimed at Dupli who did get cut off; their client did split, from the looks of it, but too late
11:35:31 <dmwit> Dupli: There's not really enough code here to say much. Perhaps you can try to build a minimal but complete example that demonstrates the problem.
11:35:34 <sshine> geekosaur, ok.
11:35:40 <theelous3> what's the name of the beginners haskell channel again?
11:35:47 <Welkin> #haskell-beginners
11:35:49 <Welkin> lol
11:35:53 <theelous3> ah, left out the -
11:35:54 <theelous3> ty!
11:36:07 <geekosaur> Dupli, that code by itself looks fine. I'd worry about data dependencies forcing all threads to compute dependencies first though
11:36:07 <Sonolin> excited to try this on my ARM netbook when I get home (no GHC installed yet, was trying cross compilation but PITA)
11:36:13 <glguy> theelous3: That's just a different channel; this one is fine for beginner questions.
11:36:39 <monochrom> You are encouraged to ask in both.
11:36:41 <sshine> we're all converging towards greater Haskell insight. :)
11:37:00 <monochrom> You are also encouraged to answer in both, but with conflicting answers :)
11:37:13 <sshine> monochrom, that's a great idea.
11:37:33 <Apocalisp> are names starting with _ not exported from modules by default?
11:38:38 <Apocalisp> _Foo :: Prism' (Wee Value) Poo
11:39:03 <Apocalisp> importing the module this is defined in doesn't put _Foo in scope. Any idea why?
11:39:16 <Boomerang> Apocalisp: I don't think that's the case. Are you refering to record fields? You might have to export the record constructor
11:39:36 <Apocalisp> I have an actual top-level definition
11:39:41 <jameseb> Apocalisp: what is the export list for the module where _Foo is defined?
11:39:52 <Apocalisp> jameseb: it doesn't have one
11:40:09 <Apocalisp> module M where ...
11:40:32 <urbanslug> monochrom: dmwit Well the way the book is structured there is a lot of reference to transformers
11:42:16 <Boomerang> Apocalisp: what you describe works for me _Foo is exported
11:42:29 <geekosaur> Apocalisp, I just defined that in a test module (but with type Int) and it shows as expoted in the iface
11:42:30 <Apocalisp> hrm
11:43:23 <dmwit> zipper: If your goal is to learn transformers, that's no problem. But if your goal is to learn a parser monad, you should find a resource that talks about learning parser monads.
11:43:50 <Apocalisp> I get Module ‘M’ does not export ‘_Foo‘
11:44:02 <glguy> Apocalisp: Maybe you're loading a different file than you're diting
11:44:06 <glguy> editing*
11:44:19 <Apocalisp> ah! maybe
11:44:41 <Dupli> dmwit, an example would be something like: lookupAndPrint ["key1","key2","key3"] [("key1","value1"),("key2","value2"),("key3","value3")], but with a much bigger lookup table (millions of elements), and like 20 keys. Then I will get "value 2 found!" printed multiple times, but I only want them printed once. I don't understand why it finds the values multiple times, as the key/value-pairs are unique, and I'm using chunksOf
11:47:16 <Dupli> My prints will be something like: key1 : value1 (0.1836544s), key2 : value2 (0.2117355s), ... , key1 : value1 (0.4965411s)
11:47:52 <sshine> Dupli, and key1 doesn't occur twice in the first argument?
11:48:17 <Dupli> The keys are unique, as well are the key/value-pairs 
11:48:29 <dmwit> Dupli: Could not reproduce.
11:49:20 <dmwit> Dupli: Seriously, please try to both *minimize* -- cut out code that doesn't contribute to the bug -- and *complete* -- include everything we need to reproduce your problem, including imports and data -- your problem.
11:49:58 <Dupli> Alright, I'll try!
11:54:50 <Apocalisp> yeah, cabal clean ftw
11:57:05 <Guest38698> Hey!
12:00:41 <ubsan> Guest38698: ho, let's go!
12:41:13 <deech> Hi all, had a question about using C2HS to represent int64 on Windows in a Haskell FFI. With the header files that ship with GHC 8.0.1 the C type `unsigned __int64` is mapped to CULLong (unsigned long long). They're both 64 bit so I guess it doesn't matter but I wanted to run it by people who know C better than me.
12:42:04 <ubsan> deech: I believe that __int64 is equivalent to long long
12:42:48 <merijn> deech: I'm not sure what the question is? :)
12:43:04 <ubsan> deech: or mapped to long long, at least
12:43:44 <ubsan> although it's weird that there are no CIntN types, to me
12:44:39 <deech> merijn: I was a little weirded out by the mismatch in types, like ubsan said I would have expected CUInt64 or something like that.
12:44:52 <deech> Just wanted to make sure the tool was telling me the right thing.
12:45:07 <merijn> deech: I'm not sure if the C standard covers how int64_t, etc. should be defined
12:45:30 <deech> merijn: Ah, k. I'm not a C expert. :)
12:45:43 <ubsan> merijn: it also doesn't really cover the normal int type
12:45:44 <ubsan> s
12:45:44 <merijn> deech: CULLong looks right, because a quick Google tells me "unsigned long long = unsigned __int64 = 64bit unsigned" in the Windows ABI
12:45:56 <ubsan> merijn: that's up to the ABI
12:45:59 <merijn> ubsan: No, but the relevant ABI does
12:46:04 <ubsan> i.e., something that haskell should deal with for you
12:46:13 <merijn> ubsan: I'm not sure if the ABI has an opinion on uint64_t?
12:46:20 <ubsan> yes, of course it does :P
12:46:42 <ubsan> the normal int types are defined in terms of the fixed size types, usually
12:47:00 <merijn> ubsan: tbh, I think if you're willing to write it out than the addition of those Foreign.C.Types would probably be welcomed?
12:47:04 <ubsan> b/c CPUs care about bit width
12:49:00 <merijn> Generally this is "nobody bothered to write it stuff"
12:49:30 <ubsan> hmm
12:49:39 <dolio> Most of the stuff I'm seeing says that uint64_t and the like are defined as aliases.
12:49:54 <dolio> Not vice versa.
12:50:00 <ubsan> dolio: in the C language
12:50:05 <ubsan> i.e., in the standard library
12:50:08 <ubsan> not in the ABI
12:50:33 <merijn> dolio: It would still be useful to have synonyms for those :)
12:50:45 <merijn> For portability's sake
12:50:58 <merijn> ubsan: Time to get your first GHC contribution ;)
12:51:04 <dolio> Why would they be in the ABI at all if they're language-level aliases for the more primitively defined things?
12:51:16 <ubsan> dolio: because ABIs care about bit widths
12:51:26 <ubsan> dolio: not C terms like 'int' or 'long'
12:51:37 <merijn> ubsan: Warning: int64_t is not guaranteed to actually be 64bits
12:51:44 <ubsan> merijn: uh, yes it is
12:51:44 <merijn> (nor uint8_t, etc.)
12:52:02 <merijn> ubsan: No, it implements 64bit arithmetic, but storing it in more than 8 bytes is allowed
12:52:03 <ubsan> they're only defined when you have an 8, 16, 32, 64 bit type
12:52:18 <merijn> ubsan: int8_t could be 4 bytes for all you know
12:52:27 <ubsan> merijn: I don't think it can be
12:52:40 <merijn> Lemme look it up in the bible...
12:52:59 <merijn> ubsan: I have seen implementations with 32bit chars, I've learned not to assume :)
12:53:08 <ubsan> chars are a byte big
12:53:11 <ubsan> whatever a byte is
12:53:20 <mfukar> merijn, uintN_t designate unsigned integers of width N exactly
12:53:26 <EvanR_> on my computer chars are 64bits
12:53:26 <ubsan> the {u,}intN_ts are ^
12:53:28 <mfukar> and no padding bits
12:53:51 <mfukar> You may be thinking of int_leastN_t
12:53:59 <ubsan> > signed integer type with width of exactly 8, 16, 32 and 64 bits respectively with no padding bits and using 2's complement for negative values (provided only if the implementation directly supports the type)
12:54:00 <merijn> Ok, first off. (u)int_t are apparently not standard defined at all, so presumably it's posix
12:54:01 <EvanR_> must have walked into the C channel accidentally
12:54:01 <lambdabot>  <hint>:1:16: error: parse error on input ‘type’
12:54:09 <ubsan> merijn: yes they are
12:54:15 <ubsan> they've been standard since C99
12:54:21 <ubsan> merijn: http://en.cppreference.com/w/c/types/integer
12:54:31 <EvanR_> i just got leinster "basic category theory" in the mail. huzzah!
12:54:31 <merijn> ubsan: I have the C11 standard open, they are not in there
12:54:37 <merijn> ubsan: C++ != C
12:54:41 <mfukar> merijn, 7.21.1.1
12:54:44 <ubsan> merijn: look for the stdint header
12:54:48 <mfukar> 7.20.1.1 , sorry
12:54:56 <ubsan> merijn: I know, that's why I linked to the C docs in cppreference
12:54:58 <merijn> oh, wait
12:55:01 <ubsan> cppreference is just way easier to read
12:55:13 <EvanR_> the w3schools of C
12:55:22 <merijn> hmm, ok, looks like you're right
12:55:37 <ubsan> I know the C standard pretty damned well, tbh
12:55:46 <merijn> Anyway, I'm too lazy to implement this stuff, but I wholly welcome someone else to do it for me :p
12:55:51 <ubsan> I've read it for fun before ;)
12:56:01 <merijn> I'll even give pointers!
12:58:31 <ubsan> merijn: alright, fine
12:58:35 * ubsan dls the source
13:01:45 <ubsan> merijn: deech: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Word.html
13:02:01 <ubsan> merijn: deech: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int8
13:02:08 <ubsan> see, this is why one checks docs first
13:02:18 <merijn> ubsan: I know about those, those don't match
13:02:29 <merijn> ubsan: Int8 is in fact 4/8 bytes, depending on architecture
13:02:52 <ubsan> merijn: why?
13:02:54 <dolio> Those aren't C types.
13:02:55 <merijn> "data {-# CTYPE "HsInt8" #-} Int8 = I8# Int#"
13:03:05 <merijn> ubsan: Because it's faster
13:03:09 <dolio> The C types are in Foreign.C.Types.
13:03:30 <ubsan> ah, okay
13:04:05 <merijn> ubsan: Loading full words is generally faster than partial words, so it's cheaper to use Int# for Int8 too then having a specialised type of exactly 8bits
13:04:21 <ubsan> merijn: I guess that makes sense
13:04:42 <ubsan> still gross tho
13:05:20 <EvanR_> if you dare to delve into the guts youll probably find Bools represented with whole ints, not bits, chars as whole ints, not even 32bit ints or 23 bits which i think is the minimum
13:05:33 <EvanR_> thats why we dont want to delve into the guts!
13:06:16 <ubsan> I mean, bools as u8 is fine
13:06:21 <ubsan> as opposed to bits
13:06:22 <EvanR_> a similar issue came up yesterday with SD cards...
13:06:27 <ubsan> that actually does screw stuff up
13:06:38 <EvanR_> you can only ever read or write entire blocks of 512 bytes, not single bytes or bits
13:06:38 <dolio> There's been talk of adding Int8# and such, but I'd be somewhat surprised if that were guaranteed to always be represented as 8 bits.
13:06:57 <ubsan> how does one check if a type exists?
13:07:00 <dolio> Only some places would make use of that information.
13:07:05 <EvanR_> its the reality of how the sausage is made. relax and live in an abstract world of math instead
13:07:11 <merijn> ubsan: You mean, in general anywhere?
13:07:16 <ubsan> merijn: yes
13:07:30 <merijn> ubsan: Hoogle and Google? :p
13:07:32 <merijn> Maybe Hayoo
13:07:33 <dolio> Just like I'd be surprised if int8_t really behaved that way.
13:07:46 <merijn> dolio: Apparently it does, C11 requires it
13:07:51 <merijn> dolio: 8 bit, no padding
13:07:59 <EvanR_> int8_t behaves as if it were a single byte, but probably isnt all the time
13:08:04 <dolio> Is it only allowed to be used in 8-bit CPU registers?
13:08:08 <ubsan> it can be put into a register
13:08:17 <ubsan> but while in memory, it is always 8 bits
13:08:25 <merijn> dolio: If a specific size cannot be supported (i.e. int24_t) you're required not to implement it
13:08:36 <ubsan> and even in a register, it's still 8 bits, there's just 56/24 bits of padding
13:09:07 <EvanR_> ubsan: if you make a struct with just one int8_t field, loose, not in a vector, i have a hard time believing other stuff will occupy the bytes around it
13:09:17 <ubsan> EvanR_: uh... yeah it will
13:09:24 <ubsan> as long as the alignment isn't off
13:09:28 <merijn> in a struct you don't know
13:09:36 <ubsan> in a struct you know exactly
13:09:49 <EvanR_> within the struct yes, im talking about outside of it
13:09:58 <merijn> ubsan: "struct { uint8_t x; }" is allowed to take up 64bits
13:10:00 <ubsan> struct Foo { int8_t x; int8_t y; int16_t bar; } // sizeof(Foo) == 4
13:10:04 <ubsan> merijn: no it isn't
13:10:26 <ubsan> unless it's on the stack, in which case... it's probably in a register
13:10:34 <geekosaur> ...um
13:10:37 <EvanR_> if you have a vector of them, it makes sense to pack 8 of them into a word
13:10:45 <EvanR_> but otherwise who knows
13:11:09 <EvanR_> it would be a pain in the ass for other heap objects to start off word boundary
13:11:10 <ubsan> they probably do get packed
13:11:49 <ubsan> heap objects are at semi-random places in memory
13:11:58 <ubsan> it's likely that the smallest allocation is 8 bits
13:12:04 <merijn> ubsan: "probably" is not a guarantee
13:12:06 <EvanR_> likewise, if the vector isnt multiple of 8 long, placing other objects exactly afterward is weird
13:12:07 <ubsan> but you still should only have access to 1 byte
13:12:10 <merijn> ubsan: C specifies nothing about padding
13:12:10 <ubsan> s/bits/bytes
13:13:00 <ubsan> merijn: "any reasonable implementation"
13:13:22 <merijn> ubsan: C11 doesn't require implementations be reasonable
13:13:26 <ubsan> and besides, stack isn't the important part of the intN_ts
13:13:38 <ubsan> passing is the important parts
13:13:39 <geekosaur> ubsan is one of those "the whole world runs linux intel" types
13:13:39 <ubsan> *part
13:14:22 <ubsan> geekosaur: no, I'm one of those people who understands that most of the world runs on Linux/Mac/Windows/BSD/zOS, on SPARC, x86, ARM, or POWER
13:14:56 <dolio> It sounds like there are a ton of caveats about C's behavior that make it not very different in practice than GHC's "gross" behavior.
13:15:22 <ubsan> not really
13:15:35 <merijn> dolio: Who says GHC is gross?
13:15:45 <ubsan> structs and arrays are quite useful
13:15:48 <ubsan> merijn: *cough*
13:16:01 <merijn> dolio: GHC is behaving perfectly reasonable and the lack of Foreign.C.Types for uint8_t is an easily remedied thing
13:16:03 <EvanR_> ubsan are you looking into implementing a haskell compiler?
13:16:18 <ubsan> EvanR_: no, I'd like haskell to have the intN types
13:16:24 <ubsan> at least for FFI
13:16:26 <merijn> EvanR_: No, we got started by the lack of GHC synonym for (u)intN_t
13:16:37 <EvanR_> Word8 is a marshable type
13:16:48 <EvanR_> use it for uint8_t
13:16:49 <ubsan> it's also the size of an Int
13:16:53 <merijn> EvanR_: Wrong
13:17:04 <dolio> Word8 is not uint8_t, it's HsWord8 or something.
13:17:13 <merijn> EvanR_: The correct type corresponding to Word8 is HsWord8
13:17:16 <dolio> If the latter even exists.
13:17:21 * EvanR_ photographically recalls the documentation
13:17:24 <merijn> dolio: It does for Int8
13:17:31 <monochrom> Eh? uint8_t is Word8, no?
13:17:40 <merijn> monochrom: No, why would it be?
13:17:44 <merijn> monochrom: Word8 is 4 byte
13:17:49 <merijn> uint8_t is 1 byte
13:17:50 <ubsan> (or 8 bytes)
13:18:22 <EvanR_> Word8 is usable in the FFI
13:18:24 <Boomerang> > 256 :: Word8
13:18:26 <lambdabot>  0
13:18:27 <merijn> EvanR_: Marshallable == GHC knows how to auto convert to relevant C types
13:18:45 <EvanR_> i daresay Word8's relevant C type uint8_t
13:18:46 <monochrom> OK whatever.
13:18:58 <merijn> EvanR_: Yes, but it is NOT equivalent to uint8_t and passing Ptr Word8 to something expecting uint8_t* is a bug
13:19:07 <EvanR_> no definitely dont do that
13:19:08 <merijn> Because those things are not the same
13:19:26 <merijn> Boomerang: It takes op 4/8 bytes, it still behaves as an 8bit number
13:19:41 <merijn> Else it'd be useless :)
13:19:44 <Boomerang> Oh I see :)
13:19:49 <EvanR_> it takes up a lot more than that due to boxing
13:20:02 <EvanR_> but Ptr is a Ptr, doesnt really matter to what
13:20:07 <monochrom> The semantics of Ptr Word8 is up to the Storable instance of Word8, you know that?
13:20:11 <dolio> I'm not sure Ptr Word8 uses 8 bytes per word. But it's not specified as being equivalent to a pointer to C char.
13:20:24 <ubsan> it shouldn't be equivalent to char*
13:20:29 <merijn> monochrom: hmm, I suppose the Storable instance could disagree with the GHC representation
13:20:39 <merijn> dolio: Yeah, you're right
13:20:53 <merijn> It probably *does* the right thing, but it's not *guaranteed* to
13:21:07 <dolio> The point is there are types you use on the Haskell side that are guaranteed to match the C types, and types on the C side that are guaranteed to match the Haskell types.
13:21:58 <EvanR_> the algebra of it all works out, you just cant exactly control the heap layout
13:22:24 <merijn> EvanR_: That's certainly a lacking feature in GHC :)
13:22:30 <EvanR_> maybe
13:22:38 <monochrom> Also, Word8 is not 4/8 bytes. It's 8/16 bytes.
13:22:43 <EvanR_> the same thing is true of unboxed vectors
13:23:09 <monochrom> Or rather, s/is/occupies/
13:23:21 <EvanR_> you get packing guarantees of the vector data, but you still need to use boxing to operate on the elements
13:23:30 <EvanR_> haskell isnt C
13:23:35 <monochrom> The liberal use of "is" is the main cause of illusions.
13:27:57 <EvanR_> screw the implementation of Int or Bool... just optimize functions as much as possible and we should be good
13:28:33 <EvanR_> something other languages dont really
13:29:30 <lpaste> bwe pasted “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:30:50 <monochrom> Actually I wonder why it defaults to Rational rather than Double
13:31:52 <monochrom> Oh you commented out the type so it's a pipe dream.
13:32:12 <monochrom> You have "fromRational" somewhere so you are forcing some things to be Rational.
13:32:26 <monochrom> Or rather s/forcing/pinning/
13:32:28 <bwe> monochrom: That has been an attempt to make it better.
13:32:34 <bwe> to the worse, of course.
13:33:24 <geekosaur> you didn't want fromRational, that goes the wrong way
13:33:56 <geekosaur> :t realToFrac
13:33:57 <lambdabot> (Real a, Fractional b) => a -> b
13:34:18 <monochrom> realToFrac doesn't seem necessary either.
13:34:39 <lpaste> bwe revised “How can I return `a` instead of `Rational` type?”: “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:35:20 <bwe> I wonder why sortEffects does return Rational.
13:35:46 <EvanR_> older programming languages used the term real to refer to essentially special rational types, properly reals werent a thing, maybe they didnt want to use "rational" because its too long, and "rat"s are generally to be avoided, if i were there i might have suggested "rash" ;)... hmm maybe also to be avoided
13:36:37 <glguy> bwe: You left "makeRelations" out of the paste
13:36:39 <monochrom> No EvanR_, those older programming languages had sqrt and cos, so they could not be thinking "rational" conceptually.
13:36:46 <EvanR_> haskell continues the idiosyncratic tradition by naming the rational conversion class "Real"
13:37:16 <EvanR_> ok, so they are talking about approximations of reals
13:37:22 <monochrom> YES!
13:37:26 <EvanR_> which are... rationals ;)
13:38:02 <monochrom> OK I guess you are just looking for a revisionist history that comforts you.
13:38:18 <dolio> Rationals are dense in the reals.
13:38:21 <lpaste> bwe revised “How can I return `a` instead of `Rational` type?”: “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:38:22 <EvanR_> yes because the Real class has a stupid name
13:38:30 <EvanR_> thats all i can do about it
13:38:38 <monochrom> Sure, most meaningful names are stupid.
13:38:44 <EvanR_> o_O
13:39:07 <monochrom> You disagree? Just look around for meaningful names like "Real"
13:40:23 <monochrom> bwe, clearly if you subject "values" to makeRelations :: [Rational] -> etc etc, you are again pinning "values" down to [Rational].
13:40:51 <monochrom> And yes even though "relations" ends up not being used.
13:40:53 <c_wraith> most "real" numbers seem fake to me. they're the output of infinite random processes, not a result of anything that happens in reality. 
13:40:56 <lpaste> bwe revised “How can I return `a` instead of `Rational` type?”: “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:41:23 <merijn> Yay! It's "my code can't run until my patch gets accepted upstream"- o'clock!
13:41:55 <kadoban> :(
13:42:04 <monochrom> Is there any reason makeRelations must be hardcoded to Rational?
13:42:09 <c_wraith> merijn, I think that's like "compiling". you're now free to wander the office and cause problems for others. 
13:42:13 <kadoban> Can't you fork whatever until upstream accepts your patch?
13:42:13 <glguy> bwe: If you want sepCauses to work for all Floating type, you'll want to updated makeRelations able to do the same
13:42:27 <merijn> c_wraith: This is a hobby project and I'm not in the office >.<
13:42:44 <merijn> kadoban: Sure, I've cloned the repo, patched it and used sandbox to use that
13:42:47 <c_wraith> merijn, just go pick a random office. 
13:42:51 <kadoban> merijn: Even better, then you can wander around at home and cause problems for others :)
13:42:56 <merijn> kadoban: But it means my code is useless to everyone else :p
13:43:16 <monochrom> Wander around #haskell and cause problems for others.
13:43:30 <merijn> monochrom: That's a background task that I always run :p
13:43:39 <lpaste> bwe revised “How can I return `a` instead of `Rational` type?”: “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:44:15 <monochrom> Why are there more and more pinning down your types?!
13:44:27 <merijn> Actually, now that everyone is actually here and talking...libraries for XML deserialisation...am I crazy or is there no convenient aeson like library for it?
13:44:55 <c_wraith> no one cares about putting that much time I to xml
13:44:57 <monochrom> I respect "random mutation of your code until it fits your desire". But this is not random mutation. This is deliberate mutation away from what you desire.
13:45:01 <EvanR_> c_wraith: they are fake in the sense of pro wrestling
13:45:07 <merijn> Needs more types in the where clause
13:45:26 <monochrom> It is as though your brain actually has a part that knows the right thing to do, but its output is then fed to a not-gate.
13:45:30 <c_wraith> especially since it's way more complicated. attributes and entities muck things up grandly. 
13:45:43 <merijn> c_wraith: But all the existing XML libraries are all pain and woe and I can't be the only one having to deal with XML
13:46:17 <bwe> monochrom: Okay. I stop my  deliberate mutation here. — May I tell you? `makeRelations` is also used by `makeSummary`. I want `makeSummary` to output a fraction. `sepCauses` should re-use `makeRelations`. Do you see what I want?
13:46:54 <monochrom> makeRelation can be the general any-type one, and makeSummary can be the one that specializes the any-type to Rational.
13:54:22 <lpaste> bwe revised “How can I return `a` instead of `Rational` type?”: “How can I return `a` instead of `Rational` type?” at http://lpaste.net/4185707433978494976
13:54:30 <k0001> Is `-split-sections` supposed to work in OSX?
13:55:36 <bwe> monochrom: Thanks for stopping me doing more stupid stuff.
13:56:17 <glguy> k0001: Doesn't look like it. When you use that flag GHC reports: ghc: on the commandline: -split-sections is not useful on this platform since it always uses subsections via symbols.
13:56:23 <bwe> monochrom: But I want to understand why did the `Rational` pinning of `makeRelations` affected the output of `sortEffects` in the function `sepCauses`?
13:56:54 <k0001> glguy: thanks!
13:57:21 <glguy> bwe: Because you had 'relations = makeRelations values'
13:57:37 <glguy> so since makeRelations requires that it's argument is a [Rational], we know that values has that type
13:58:48 <glguy> and since values :: [Rational], and sorted = sortEffects value, then sorted :: [Rational]
13:59:08 <glguy> and so on
14:01:17 <bwe> glguy: But where is the connection between sorted and makeRelations then?
14:02:22 <glguy> sorted is defined to be the result of applying makeRelations to values
14:02:27 <glguy> err
14:02:47 <glguy> sorry, it's the result of applying sortEffects to values.
14:02:48 <glguy> sortEffects :: (Num a, Ord a) => [a] -> [a]
14:03:01 <glguy> so since values [Rational], then certainly sorted will also be [Rational]
14:04:07 <EvanR_> Newman was alluding to something that would eventually be called an algorithm, a set of precise (but basically "mindless") instructions for solving a problem
14:04:20 <EvanR_> hmmm
14:04:55 <bwe> Ah! I am getting it. the type definition of `makeRelations` is inherited upwards to the `sepCauses`'s type definition. So values is of type [Rational]. Now, when `sortEffects` sees values as [Rational] and does not accept [Rational], that's the conflict, isn't it?
14:06:40 <EvanR_> By "mechanical process" Newman didn't mean a machine, of course. Machines may be able to perform simple arithmetic, but they can hardly do actual mathematics.
14:07:07 <EvanR_> i wonder as time goes on with "AI" how we will need to make a distinction between simple arithmetic and actual mathematics
14:07:22 <EvanR_> is automatic theorem proving actual mathematics
14:08:11 <merijn> EvanR_: What does "actual mathematics" mean?
14:08:20 <EvanR_> ask Newman
14:09:44 <EvanR_> supposedly turing considered the mind a machine
14:10:16 <EvanR_> which does actual mathematics, whatever it is
14:11:50 <merijn> Who is Newman?
14:12:20 <merijn> And why would I care what he thinks?
14:13:04 <ralu> EvanR_: by this reasoning , Is doing 1+1=2  math?
14:13:47 <EvanR_> Max Newman, he taught a graduate course on mathematical logic at cambridge in 1935, whose students included alan turing, before he proved the undecidability of the halting problem
14:14:00 <EvanR_> you might care if he was the guy deciding your grade in the course
14:18:49 <ralu> I am just wondering how long will it take for computers to write paper worth of Fields Medal but won't be granted for obvious reasons.
14:19:11 <EvanR_> haha
14:19:30 <EvanR_> and the you have the star trek episode "measure of a man"
14:21:51 <sssilver> Hey guys, does Agda transpile to Haskell?
14:21:54 <sssilver> or is it its own thing?
14:21:59 <sssilver> does anyone know?
14:22:05 <sssilver> yes? no? maybe?
14:22:08 <geekosaur> it generates Haskell code, yes
14:22:17 <EvanR_> yes
14:22:26 <glguy> sssilver: You can just ask the question and then wait. You don't have to fill in the empty space
14:22:26 <sssilver> interesting, the wikipedia article doesn't make that very clear
14:22:41 <sssilver> glguy but.... but....
14:22:43 <sssilver> let me think
14:22:51 <sssilver> OK well
14:22:54 <sssilver> I guess you're right
14:22:57 <glguy> you're doing it again
14:23:18 <EvanR_> agda info is a scare resource
14:23:23 <EvanR_> scarce
14:23:34 <Tuplanolla> It's also scary.
14:25:33 <sssilver> glguy see if I don't fill in the space, it's just uncomfortable, awkward silence
14:25:43 <sssilver> we're observing it right now
14:26:03 <geekosaur> or just silence, with you imaginingt he awkwardness
14:26:17 <sssilver> geekosaur all silence is awkward, no?
14:26:23 <geekosaur> no?>
14:26:30 <EvanR_> Newman wrote a letter to alonzo church when he solved the entscheidungs problem before turing: "His treatment - which consists in describing a machine which will ground out any computable sequence - is rather different from yours" its amazing that all this "computer" science was going on before computers even existed
14:26:37 <geekosaur> silence may be awkward in certain social circumstances
14:26:50 <EvanR_> s/ground out/grind out/
14:26:56 <geekosaur> sometimes it just means nobody has naything to say and is leaving the space open for those who might need it
14:27:09 <sssilver> geekosaur well this is social, this is a circumstance, and this is definitely certain
14:27:24 <nitrix> I think it's everyone's best interest to reduce the noise when we're in a channel this large. I think it's a form of respect.
14:27:35 <sssilver> fine I'll leave
14:28:18 <sssilver> OMG this channel has 1511 users (!!!). The world is a better place than I imagined!
14:28:25 <NickHu> lol
14:29:28 <Tuplanolla> :t awkward
14:29:30 <lambdabot> (Conjoined p, Plated s, Applicative f) => Traversing p f s s a b -> Over p f s s a b
14:29:47 <nitrix> :t absurd
14:29:48 <lambdabot> Void -> a
14:29:52 <geekosaur> ... shoulda known it'd be a lens combinator >.>
14:31:17 <SpinTensor> hi. New to haskell and still trying.
14:31:28 <Gurkenglas> :t confusing
14:31:30 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
14:31:37 <glguy> ?undefine
14:31:38 <lambdabot> Undefined.
14:31:40 <SpinTensor> I get a compile error for the following code and can't find the error: http://pastebin.com/z314XmmM
14:31:41 <glguy> :t awkward
14:31:43 <lambdabot> error: Variable not in scope: awkward
14:32:11 <glguy> lens has enough defintions to complain about, you don't have to make them up
14:33:50 <SpinTensor> "let number = 123" should of course not be part of the comment
14:34:15 <nitrix> SpinTensor: let number is your issue.
14:34:29 <nitrix> You cannot have an expression at the top-level.
14:34:45 <SpinTensor> nitrix: thx. where should i put it then?
14:34:58 <SpinTensor> in the "where" section?
14:35:00 <merijn> Does anyone know if there exists a maximum URL length/maximum number of GET parameters?
14:35:06 <nitrix> SpinTensor: Simply remove the `let` and now you'll have a proper definition.
14:35:30 <nitrix> SpinTensor: Ideally it'd be in the function that it is used, possibly a where clause, to avoid polluting the top-level.
14:35:35 <EvanR_> its interesting that for all the mathematics going on in the 1920s based in germany, and all in german or dutch, these computability papers all coming out at the same time were from church (american) and turing in english
14:35:41 <Tuplanolla> I think not, but servers have their limits, merijn.
14:35:42 <EvanR_> in the 30
14:35:49 <EvanR_> s
14:36:23 <ski> EvanR_ : ooc, reading some history ?
14:36:56 <EvanR_> merijn: its also based on the browser, firefox specifically on mac used to refuse to accept longer than about 1000 characters
14:37:01 <glguy> SpinTensor: It can be a top-level definition just like main
14:37:13 <glguy> SpinTensor: Also like main, you just don't include a "let"
14:37:49 <merijn> EvanR_: I'm not sure how the browser is relevant when I'm querying from Haskell :)
14:37:54 <EvanR_> ah
14:38:02 <SpinTensor> glguy: thanks. nitrix already helped.
14:38:11 <merijn> EvanR_: I just wanna know how many queries I can cram into a single request :)
14:38:21 <EvanR_> funny the freedom of context you get just by asking about "*the* maximum length of a url"
14:38:22 <glguy> SpinTensor: You're using 'number' at two incompatible types, so when you make it a top-level definition yoiu'll need to add a type signature
14:38:45 <merijn> EvanR_: Since there's a rate limit on request I'd better squeeze the most into each request I can :)
14:38:55 <EvanR_> ski: this is The Annotated Turing introduction
14:40:09 <SpinTensor> glguy: like "number :: Int" ?
14:40:14 <merijn> So if I'm lucky I should get 8k of URL, according to the RFC recommendations, now I just gotta hope most major servers support that :)
14:40:29 <ski> EvanR_ : any handy link ?
14:40:46 <glguy> SpinTensor: No, that won't work
14:41:00 <glguy> SpinTensor: You've got 'sqrt number', and you can't take the square root of an Int
14:41:23 <SpinTensor> glguy: so I need to cast before i take the sqrt?
14:41:32 <glguy> You can either use "fromIntegral" to convert number from an Int to a fractional type at this point, or you can define number :: Num a => a
14:41:58 <EvanR_> ski: maybe this http://it-ebooks.directory/book-0470229055.html but i am borrowing the dead tree from someone who goes to the local haskell reading group
14:42:01 <glguy> number can't just be a Double, because next you have ' number `mod` x == 0', and `mod` expect some Integral type
14:43:23 <EvanR_> isnt there something like fmod for Doubles
14:43:44 <geekosaur> yes, in an unexpected place (Data.Fixed)
14:43:52 <EvanR_> brilliant
14:43:57 <glguy> :t Data.Fixed.mod'
14:43:59 <lambdabot> Real a => a -> a -> a
14:44:14 <EvanR_> > Data.Fixed.mod' pi 3
14:44:16 <glguy> But in this case it's probably not the right answer
14:44:16 <lambdabot>  0.14159265358979312
14:44:25 <EvanR_> > Data.Fixed.mod' 6.0 3
14:44:27 <lambdabot>  0.0
14:44:31 <ski> EvanR_ : oh, it's a book. ty
14:45:28 <SpinTensor> glguy: sorry. still not sure what to do. now it spams the error " Ambiguous type variable ‘t0’ arising from a use of" which is probably caused by this type thing
14:46:04 <glguy> SpinTensor: You can change: sqrt number --to-- sqrt (fromIntegral number)
14:48:09 <SpinTensor> glguy: ok. now i got it. (at least it compiles)
14:49:08 <mpickering> Is sortBy compare the same as sort?
14:49:44 <SpinTensor> glguy: works now. Thanks a lot.
14:49:45 <glguy> mpickering: That's the actual definition of sort
14:50:12 <mpickering> I thought so, thanks
14:52:53 <ski> @src sort
14:52:53 <lambdabot> sort = sortBy compare
15:01:57 <geekosaur> not that @src is trustworthy...
15:06:17 <Zemyla> Stream-based vector implementations with rewriting rules give Haskell the speed of C in some cases.
15:06:42 <Zemyla> Could a similar improvement be done with stream-based Integers?
15:07:09 <hodapp> what do you mean by stream-based integers?
15:07:34 <EvanR_> i think in most cases Integers are really using machine ints, until they get enormous enough to go beyond the max int
15:07:53 <EvanR_> we never get to the point of huge streams of limbs
15:09:29 <EvanR_> also isnt GMP identically "the speed of C"
15:10:05 <Zemyla> Yes. But we really should have a pure-Haskell implementation with the same license as GHC.
15:10:21 <EvanR_> oh
15:11:56 <Zemyla> Also, for instance, (x + y) + z, if any intermediate is too big for a normal Int, creates a giant array and then immediately destroys it, I think?
15:12:37 <EvanR_> gmp integers can never be giant arrays, thats way too big for numbers
15:12:46 <EvanR_> its log scale
15:13:11 <EvanR_> giant in the sense of "large object area"
15:16:36 <nevere> How can I make an entier subform optional using digestive-functor library? Something like optionalString, but for a custom data type. 
15:18:09 <EvanR_> 1 googol = 10^100 has log_2 of 332 point something, bits. 42 bytes, and if each limb is like 8 bytes thats 5 limbs
15:18:28 <EvanR_> i dont actually know how big each limb is though
15:18:51 <EvanR_> 5 words on a 64bit computer
15:20:01 <EvanR_> which makes me think a haskell solution to this would be pretty cool
15:20:03 <Zemyla> Hmm. Well, we still do need a pure-Haskell implementation of Integer, and GHC.Integer.Simple doesn't cut it.
15:20:58 <EvanR_> GMP is thinking about memory managment from a C perspective, and objects can be mutated or resized
15:21:29 <nick99> does that matter when we can only access it through haskell interface?
15:21:32 <EvanR_> since we want immutable and realistic numbers are about as big as records, seems like a no brainer... in theory
15:22:58 <kadoban> Does it actually matter if it's pure-haskell? It seems like the license is more important to me. Though haskell would be a bonus I suppose.
15:23:09 <qmm> i want to create a user and set the id to be an increment from the last user in the list that is being built up
15:23:21 <qmm> is there a way to get an index of the iteration in replicateM?
15:23:30 <qmm> a count of some fort
15:23:34 <qmm> sort*
15:23:38 <augur> is there a standard technique for doing multi-sorted Map-like things in Haskell?
15:23:38 <EvanR_> if its implemented with haskell in mind (in whatever language), that seems cool, regardless of license
15:24:02 <glguy> qmm: you can do: mapM f [0..n-1]
15:24:25 <EvanR_> augur: theres something called a "dependent map"
15:24:44 <EvanR_> which is like an HList of key value pairs, aiui
15:24:55 <nick99> > replicateM 5 $ print 10
15:24:58 <lambdabot>  <IO [()]>
15:25:04 <augur> EvanR_: in haskell tho?
15:25:28 <augur> hm!
15:26:22 <EvanR_> yeah
15:26:53 <EvanR_> try this... havent tried it myself https://hackage.haskell.org/package/dependent-map-0.2.4.0
15:27:21 <nevere> How can I make an entier subform optional using digestive-functor library? Something like optionalString, but for a custom data type. 
15:27:27 <qmm> glguy: that's helpul, thank you
15:29:21 <qmm> i'm creating a list of my own adts which represent a user, but i don't think it makes sense to create a user with default fields that will be changed later
15:29:40 <qmm> that's not normal, is it, or does everyone use a Maybe
15:30:44 <qmm> if it's suppose to be a Bool field on the user, and it may change over time, maybe the ADT for the user looks like User { id :: Int, online :: Maybe a}
15:31:10 <qmm> Maybe a should be Maybe Bool
15:31:53 <augur> EvanR: thanks :)
15:32:02 <qmm> also, should this kind of question be in #haskell-beginners ? my questions have went from the abstract to the very beginner type questions
15:32:13 <qmm> i never know what to put in the beginners channel
15:32:28 <ski> beginner questions are welcome here
15:32:37 <qmm> thanks
15:32:54 <glguy> #haskell-beginners isn't the beginners channel for #haskell, it's just another channel someone created
15:36:53 <mjtmullen> try both channels!
15:37:49 <qmm> if nobody responds here, i might just try that :)
15:39:22 <qmm> ...maybe, the people here have been amazing to me
15:41:39 <qmm> maybe there's an example where someone creates a list of records and updates the records as needed?
15:43:11 <Gurkenglas> qmm, what happens if someone asks for the users online status before one is assigned? Can that even happen?
15:43:39 <qmm> Gurkenglas: that was just an example
15:44:03 <qmm> it's really just something with a bool field that will be updates 2 or three times
15:44:46 <Gurkenglas> Same question: Could that field be read before the first write?
15:46:22 <Gurkenglas> If no, because the record is only available for reading once all the values for it are assembled, try only constructing the record once you have all the values - no need for Maybes or default stuff then
15:47:14 <Boomerang> qmm: instead of a Bool you could use your own type: data Status = Online | Offline | NotRegistered or something along those lines to model your data
15:49:43 <Gurkenglas> If the online status is only used in one place, "handleOnline :: User -> IO ()", you could replace make the online field "online :: IO ()", to entirely skip the Maybes and boolean blindness
15:49:55 <Gurkenglas> -replace
15:51:10 <Boomerang> For the indexed users you can just apply "zip [0..]" to your list
15:54:56 <qmm> Gurkenglas: the field isn't read at all. the end result is that the users will be output to a csv and eventually imported into a spreadsheet, and that will be the first time the field is read, computer or otherwise :)
15:55:26 <qmm> try only creating the record once you have all the values... hm, ok
15:56:53 <qmm> maybe it would be easier if i used a database
15:58:51 <qmm> for each user i create, there are about 5 actions which take place and change fields (incrementing numbers, and changing flags), then (at least in the js like language), i move onto creating the next user and simulating 5 or so actions which change that new user's fields
16:03:15 <Earthlinger> Greetings Haskellers
16:03:45 <Boomerang> o/
16:03:54 <Zemyla> Okay, question.
16:04:15 <Earthlinger> Do you know if it's possible to do something like this:  class Summable a where plus :: a -> a -> a     instance Summable (a -> Summable b) where   (f `plus` g) x = (f x) `plus` (g x)?
16:04:38 <Zemyla> > readMaybe "1 % 0"
16:04:40 <lambdabot>  error:
16:04:40 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> t
16:04:46 <Rembane> Earthlinger: It looks like a monoid.
16:04:47 <glguy> Earthlinger: instance Summable b => Summable (a -> b)
16:04:47 <Earthlinger> When I try to compile it, GHC complains that "a" should be an OpenKind...
16:04:48 <Zemyla> @let import Text.Read (readMaybe)
16:04:50 <lambdabot>  Defined.
16:04:51 <Zemyla> > readMaybe "1 % 0"
16:04:54 <lambdabot>  Nothing
16:05:00 <Earthlinger> glguy thanks!
16:05:08 <Zemyla> > readMaybe "1 % 0" :: Rational
16:05:10 <lambdabot>  error:
16:05:10 <lambdabot>      • Couldn't match type ‘Maybe a0’ with ‘Ratio Integer’
16:05:10 <lambdabot>        Expected type: Rational
16:05:15 <Zemyla> > readMaybe "1 % 0" :: Maybe Rational
16:05:17 <lambdabot>  Just *Exception: Ratio has zero denominator
16:05:39 <Zemyla> Shouldn't it reject a ratio with zero denominator, instead of returning an exception?
16:05:46 <Earthlinger> Doh, I was being stupid
16:06:22 <ubsan> Zemyla: well, I believe `1 % 0` is a valid rational
16:06:41 <ubsan> Zemyla: it'd be an error in the constructor of Rational
16:06:46 <ubsan> as opposed to an error with parsing
16:07:12 <Earthlinger> Rembane: semigroup actually
16:07:32 <Boomerang> > readMaybe "1 :: 0" :: Maybe (Ratio Int)
16:07:35 <lambdabot>  Nothing
16:07:39 <Boomerang> > readMaybe "1 % 0" :: Maybe (Ratio Int)
16:07:41 <lambdabot>  Just *Exception: Ratio has zero denominator
16:08:04 <Boomerang> Sorry just testing out
16:08:45 <ski> (there's also `/msg lambdabot > ...')
16:08:56 <Boomerang> yes and ghci ^^
16:12:34 <ij> Does fix-imports on hackage work well?
16:12:38 <qmm> where is the documentation for hasql?
16:12:58 <glguy> ?hackage hasql
16:12:59 <lambdabot> http://hackage.haskell.org/package/hasql
16:13:15 <NextHendrix> good name
16:15:26 <Earthlinger> Is there any way (other than a comment) to indicate that you shouldn't use a certain constructor in a type? ...
16:15:52 <glguy> You could remove it from the type
16:16:30 <Boomerang> You could not export it
16:16:46 <Earthlinger> For example, say I have a type Thing = <stuff> | Flip Thing.  
16:17:08 <Earthlinger> And I want (Flip Flip Thing) = Thing
16:17:49 <Earthlinger> So I can put that in a separate constructor flipThing , but I don't want people to use Flip for anything but pattern matching
16:18:01 <Earthlinger> always use the flipThing constructor
16:18:12 <Earthlinger> I guess Boomerang 's suggestion is the best
16:18:27 <Rotaerk> if you don't export the constructor, don't think you can pattern match with it
16:18:35 <Earthlinger> Hmm
16:19:04 <Rotaerk> what kind of behavior is it you're trying to prevent?
16:19:25 <Earthlinger> I'm trying to prevent "let x = Flip y"
16:19:44 <jle`> smart constructor is probably the easiest way
16:19:55 <Earthlinger> instead it should be x = flipThing y
16:19:56 <jle`> you can use pattern synonyms too to make the abstraction cleaner
16:20:04 <Earthlinger> Yeah, that's what I've been doing
16:25:34 <geppettodivacin> Earthlinger: You could possibly use view patterns.
16:26:43 <qmm> glguy: thanks, i was looking at that page, but i don't quite understand how to use it by just looking at the typtes. i really just want a short english description
16:26:57 <qmm> think i'll look at opaleye, persistent, or something else
16:36:04 <Earthlinger> geppettodivacin: Thanks, I'll look into it later.  I'd rather not get into the language extension swamp atm :)
16:43:14 <Earthlinger> Oh one other quick question, is there anyway to implicitly coerce types?  Say I have a type Table and type Furniture and a simple function Table -> Furniture...
16:43:44 <Zemyla> There is no implicit type coercion.
16:43:52 <Earthlinger> Ok, thanks
16:48:56 <monochrom> pattern synonym is the best thing since pattern matching :)
16:49:03 <shayan_> Is Reflex the best for creating web applications? what is Reflex anyways? is it a client-side tool? how do you describe it?
16:52:05 <shayan_> it’s a web framework?
16:52:23 <johnw> the #reflex-frp channel might have a better answer, if we're quiet
16:53:30 <shayan_> Thank you johnw 
16:53:32 <ij> Does regex-tdfa do replacing?
16:55:41 <sm> I think not
16:56:10 <sm> you can find it in Hledger.Utils.Regex
16:58:39 <lpaste> dmwit pasted “oh, flip” at http://lpaste.net/351203
16:58:48 <ij> sm, nice
16:58:51 <dmwit> Earthlinger: ^^
16:59:19 <monochrom> haha "oh flip"
17:00:22 <monochrom> too many knots
17:00:51 <dmwit> I strive to go above and beyond. I don't just supply the rope...
17:01:42 <ij> sm, more dependencies… yay
17:02:39 <sm> well, I was thinking you could just copy the code. Depends on your situation I guess
17:03:10 <ij> Not a bad idea, really.
17:03:14 <sm> maybe submit it to one of the regex libs ? (but I don't even know which one)
17:03:35 <ij> It looks like there's not even an issue on regex-tdfa's page.
17:03:45 <ij> on github
17:03:59 <glguy> replacement wouldn't go into regex-tdfa
17:04:11 <ij> How come?
17:04:22 <glguy> It'd go into something like regex-base, just a separate package that depends on regex-base
17:04:28 <sm> https://hackage.haskell.org/package/gi-glib-2.0.11/docs/GI-GLib-Structs-Regex.html seems another source
17:04:46 <dmwit> regex-applicative makes replacement fun and easy.
17:05:22 <glguy> ij: Because it's not related to a particular algorithm for executing regular expressions
17:05:41 <ij> Ah.
17:07:40 <dmwit> Oh, neat, you can define `Not` by inlining `not_` and the not have `not_`. Much prettier.
17:08:20 <glguy> I'm still not sold on these patterns that match different values than they construct
17:09:16 <dmwit> I'm not sure I've ever used pattern synonyms in a serious project at all.
17:09:37 <dmwit> It does seem like an easy way to get confused, I agree.
17:12:14 <qmm> i was about to resort to using a database and then i happened to read something about the State monad which is exactly what i'm looking for
17:12:32 <qmm> and then i found out that i could use lenses
17:12:51 <qmm> might use the state monad before trying the lens solution
17:13:17 <ij> sm, Wouldn't it be easy to write a replacer given matches and groups? 
17:14:37 <Gurkenglas> qmm, why not both?
17:15:21 <nick99> everything you can do with a state monad you can do by threading the state manually as a function argument. so it doesn't give you any new functionality really, only existing functionality wrapped in a nicer package
17:15:24 <qmm> Gurkenglas: because i'm not really sure how to do that :)
17:15:40 <Gurkenglas> Give me the code, I'm bored :D
17:16:29 <qmm> in an fp language like erlang where you have immutable data, but you can't easily use a state monad, what do you do?
17:16:44 <qmm> do you have to resort to a database?
17:17:21 <qmm> i guess that is dependent on the language
17:17:53 <ubsan> hmm, was coarbitrary removed from quickcheck?
17:18:14 <Gurkenglas> qmm, google says https://github.com/jlouis/erl-lenses
17:19:18 <qmm> Gurkenglas: :P
17:19:27 <glguy> ubsan: http://hackage.haskell.org/package/QuickCheck-2.9.2/docs/doc-index-C.html
17:20:08 <ubsan> ah, okay
17:20:34 <nick99> qmm what are you doing? the big picture
17:23:13 <qmm> nick99: i am simulating what financials would look like 1 year from now. i did this in an imperative style language, where i defined a users lists to be users = [] and then proceeded to add a user, simulate some interactions, update fields for the user dictionary stored in teh list, and the continue on creating more users until i had a desired number of users in the list
17:23:39 <qmm> that's what i'm doing
17:23:49 <qmm> there isn't a state monad in erlang that i'm aware of
17:23:59 <qmm> but lenses have the equivalent functionality
17:24:21 <qmm> i'm assuming people did this sort of thing before either of these two concepts were known though
17:24:26 <qmm> and without requiring a database
17:24:39 <qmm> i'm curious how people did it then :)
17:24:48 <glguy> lenses aren't comparable to the State type
17:24:59 <glguy> and the State type doesn't let you do anything you can't do without it
17:25:12 <qmm> oops, wrong channel :)
17:26:25 <qmm> glguy: i'm spewing regurgitating what i read from https://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/
17:26:51 <qmm> "almost interchangeable with a lens" is the phrase on that phage with a link
17:27:49 <glguy> That's not saying the State type and lenses are interchangable
17:28:16 <qmm> glguy: why aren't lenses similar to State?
17:29:03 <nick99> qmm how are you consuming that user list? as it is being created or at the end?
17:29:26 <glguy> qmm: They just do different things
17:30:00 <qmm> nick99: users.append({id: 1, ...}) perform updates, repeat until desired number of elements in the list 
17:30:10 <johnw> dmwit: I think they can be very handy when working with Free constructions: https://github.com/jwiegley/notes/blob/master/Synonyms.hs
17:30:33 <JocoseJan> Hi !!!
17:30:33 <johnw> it's common to create smart constructors in such cases, but we were also missing the smart deconstructors until PatternSynonyms
17:30:34 <qmm> glguy: okay, i'm not expecting the a detailed response anyway. i'll be reading about State and lenses over the weekend i'm sure :)
17:30:45 <ubsan> JocoseJan: hello!
17:30:54 <EHS> hi ¡
17:30:57 <EHS> :D
17:31:10 <glguy> qmm: they're basically unrelated, so it's hard to provide much of an interesting response
17:31:15 <JocoseJan> How can use "Vector data constructor" from Cartesian module? Please?
17:31:28 <nick99> qmm and then you are inspecting the resulting list after you finished creating it?
17:32:01 <qmm> nick99: i guess there is one final call at the end which updates all the entries
17:32:02 <JocoseJan> ghc compiler says "Data constructor not in scope: Vector :: Integer -> Integer -> t"
17:32:23 <JocoseJan> I see the same error in ghci
17:32:50 <qmm> JocoseJan: i'm guessing you'll need to provide a snippet of code on lpaste to help others see how you are trying to use it
17:32:51 <geekosaur> what Cartesian is this? the first one I find is for Cartesian closed categories and somehow I suspect that's not the one you mean
17:32:52 <JocoseJan> can you tell me about examples using cartesian package? please? thanks
17:32:55 <qmm> lpaste.net
17:33:29 <JocoseJan> I had installed "cabal install cartesian" , but then I can't use as x = Vector 1 1
17:33:47 <geekosaur> and hackage tells me there is no package cartesian
17:34:14 <glguy> http://hackage.haskell.org/package/Cartesian
17:34:23 <JocoseJan> https://hackage.haskell.org/package/Cartesian
17:35:15 <geekosaur> right, case matters...
17:35:39 <geekosaur> then again I see other people in here blithely talking about e.g. data.map so maybe someone should fix hackage
17:36:03 <ubsan> how do I check the type of functions in a where block?
17:36:27 <JocoseJan> https://hackage.haskell.org/package/Cartesian-0.2.0.0/docs/Cartesian-Plane.html tells about a "Vector" constructor, but I can't do x = Vector 1 1
17:37:01 <glguy> ... where example :: _; example = ....
17:37:03 <JocoseJan> Please, help me. I want to to some algrebra cartesian vectoring
17:37:56 <glguy> JocoseJan: What version of Cartesian are you trying to use?
17:38:25 <ubsan> glguy: from ghci tho
17:38:41 <glguy> ubsan: no
17:39:03 <JocoseJan> I had installed "Cartesian-0.6.0.0" with "cabal install cartesian"
17:39:17 <ubsan> glguy: oh, it errors and tells me the type
17:39:18 <ubsan> weird
17:39:28 <ubsan> feels very rusty
17:40:01 <glguy> ubsan: Oh, I thought you meant "From ghci" meaning that you wanted to ask for types from ghci without modifying the source file
17:40:13 <ubsan> glguy: I would like to do that
17:40:18 <glguy> JocoseJan: OK, if you're using version 0.6.0.0 you can't use the 0.2.0.0 documentation
17:40:19 <JocoseJan> In ghci I write "import Cartesian.Core", then I write "Vector 1 1" but it says "Data constructor not in scope: Vector :: Integer -> Integer -> t"
17:40:23 <ubsan> if it's not possible that's fine
17:40:26 <glguy> ubsan: That's what you can't do
17:40:29 <nick99> i didn't know you could use type holes in types
17:40:43 <ubsan> glguy: aww :[
17:40:58 <glguy> nick99: Where else would you use type holes but types??
17:41:07 <nick99> glguy in place of values
17:41:15 <glguy> those would be value holes :)
17:41:33 <JocoseJan> I'm sorry. I'm a newbie in Haskell. What is the url for the cartesian -0.6.0.0 ?
17:41:35 <nick99> hmm, are you sure?
17:41:38 <glguy> JocoseJan: I uploaded the documentation for the Cartesian library you're using http://hackage.haskell.org/package/Cartesian-0.6.0.0
17:42:03 <geekosaur> isn;t that a type wildcard, not a type hole?
17:42:58 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-wildcards
17:43:24 <glguy> The guide talks about "typed" holes
17:43:32 <geekosaur> admittedly the message is identical to type holes, but last I checked tyoe holes /as such/ were value space
17:43:51 <JocoseJan> glguy: from that url I went to http://hackage.haskell.org/package/Cartesian-0.6.0.0 has just a "Package description" it's a text only no detail descriptions
17:43:54 <geekosaur> *typed holes
17:44:38 <geekosaur> and the type wildcards example includes things like maybools :: _
17:44:43 <JocoseJan> http://hackage.haskell.org/package/Cartesian-0.6.0.0/Cartesian.cabal show just a text. No detail descrioption about types, constructors
17:45:07 <glguy> JocoseJan: OK, but that's not the link I wrote
17:45:34 <glguy> JocoseJan: You'll need to click on the modules like "Cartesian.Core"
17:45:48 <glguy> This package probably isn't worth using
17:47:02 <JocoseJan> click on the modules?
17:48:07 <ubsan> > [1, 2,]
17:48:09 <lambdabot>  <hint>:1:7: error: parse error on input ‘]’
17:48:13 <ubsan> merp
17:49:12 <JocoseJan> Yeah glguy: ... but ... where are the Cartesian.Plane functions? to intersect a line with another line, polygons, and so on?
17:49:27 <glguy> dunno
17:49:54 <glguy> might not be in the package any more
17:49:55 <JocoseJan> How can create a Vector, then another vector,  and get the intersect point ?
17:50:22 <JocoseJan> I wanted Cartesian to to use functions to do algebra cartesian vectorial
17:50:41 <JocoseJan> I wanted Cartesian to to use functions to do algebra cartesian vectorial, distancie between a point and a line, etc, etc
17:50:42 <geekosaur> no match for Cartesian.Plane on hayoo
17:50:59 <glguy> JocoseJan: If the older version of the package does what you wanted you'll have to install the older version
17:51:09 <geekosaur> are you certain this package provides the functionality you are looking for, or just assuming that any package named Cartesian must necessarily do so?
17:51:49 <geekosaur> ah, I see , versions < 0.5 had it
17:52:14 <JocoseJan> That functions i had told you were those in the cartesian-0.2.0.0 ... i thought Vector, an algregra cartesion, lines, loygons were in 0.6.0.0 version too
17:52:58 <JocoseJan> sorry for my english. I'm spanish language native, from Lima, Perú, South America
17:53:59 <JocoseJan> Will those functions in < 0.5 return to the next lastest cartesian 0.6 ? Why those functions was deleted?
17:54:40 <glguy> JocoseJan: You'll have to ask the author of the package, we wouldn't know
17:56:56 <Earthlinger> dmwit: I just saw your NewBool module.  It's helpful. Thanks!
17:57:32 <JocoseJan> Ok. Thanks glguy, geekosaur. You had give a great help. Thanks a lot !!! the lastest 0.6 have no plane functions. and I was banging my head against the wall ... 
17:57:47 <JocoseJan> thanks a lot !!!
17:57:53 <glguy> You're welcome
18:48:50 <fragamus> im looking for a fromRight function 
18:49:09 <fragamus> Right "foo"     ->     "foo"
18:49:27 <fragamus> fromRight (Right "foo")
18:49:31 <fragamus> like that
18:50:45 <johnw> i'm pretty sure it's in the @hackage either pcakage
18:56:59 <athan> If recursive equations "tie the knot", do differential equations "tie the meta knot"? :)
18:57:25 <fragamus> rights :: [Either a b] -> [b]
18:57:47 <fragamus> it has it for an array of Eithers but not a single Either
18:58:11 <johnw> well, it's pretty easy to define it for yourself in your project
18:58:18 <johnw> it's in MissingH
18:58:58 <shayan_> I’m trying to use basic functions in the terminal: “sum [1..n]” “sum [1,2,3]” etc… getting this error message “*** Exception: <interactive>:63:1-23: Non-exhaustive patterns in function sum” what did I do this time? :S
19:00:33 <geekosaur> what was your definition of sum? (since the error indicates you defined it in ghci --- and I would suspect you didn't realize the whole definition needs to be on one line, with a semicolon instead of multiple lines)
19:00:34 <shayan_> it was working fine before hand
19:01:30 <shayan_> geekosaur: I can’t remember. I always clear the ghci. Anyway to recall my last defintion of sum? that would be very helpful indeed
19:01:48 <geekosaur> if you still have it open, you can uparrow
19:02:34 <shayan_> sum (n:ns) = n + sum ns
19:02:47 <shayan_> xD
19:03:11 <geekosaur> ok, that's the problem, you;re missing the empty list case. probably defined it on a separate line, but that doesn't work in ghci
19:03:25 <geekosaur> (unless you use multiline mode with :{ :}
19:03:42 <shayan_> before that i used sum []  = 0
19:03:51 <shayan_> anyways, i just terminated ghci and started a fresh new one :)
19:05:43 <dogbitsman> is there something equilivent to liftIO for [IO a] ?
19:05:55 <c_wraith> anyone have experience with the dependent-map, or the dependent-sum package it's based on? I have a question about their design.
19:06:02 <c_wraith> dogbitsman: you probably want sequence
19:06:26 <c_wraith> :t sequence
19:06:28 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
19:07:05 <dogbitsman> thanks c_wraith
19:07:28 <geekosaur> shayan_, so you need to do them on one line:     sum [] = 0; sum (n:ns) = n + sum ns
19:08:01 <shayan_> geekosaur: it didn’t specify doing it on one line in the book i’m following
19:08:12 <geekosaur> or equivalently by entering :{ on a line by itself, then the lines of your definition, then :} on a line by itself
19:08:21 <geekosaur> they likely intended you to put that in a file, not in ghci
19:08:36 <geekosaur> until ghc 8.0.1 you couldn;t even define it that way in ghci (needed to use "let")
19:09:53 <glguy> c_wraith: what's the question?
19:10:31 <c_wraith> glguy: I don't understand why f is there.  Seems like you can do what it does without throwing an arbitrary functor into the mix
19:13:03 <c_wraith> glguy: by the way, don't trust any of the examples in dependent-map.  It all looks copied&pasted from Data.Map, and they don't type check.
19:13:28 <glguy> were you thinking something like lookup :: k v -> DMap k -> v ?
19:14:16 <c_wraith> glguy: yeah, that's the transform I was wondering about.  Seems like all the necessary typing information for its type tagging and recover is still present
19:14:25 <c_wraith> *recovery
19:14:51 <glguy> The separate f allows the kind that k and f are indexed by to be something other than *
19:15:05 <c_wraith> ah.  ok, that makes sense
19:15:13 <c_wraith> now I see why it's there. :)
19:16:00 <c_wraith> I should have seen that, given that it documents the kinds of k and f as (k1 -> *) explicitly
19:18:42 <shayan_> geekosaur: I’m running the ghci on my default terminal, on the max osx. Are there any better options that work out on my osx?
19:18:57 <shayan_> should i perhaps start using emacs?
19:19:47 <geekosaur> the pooint is you put definitions in a file and load that file into ghci
19:20:22 <c_wraith> shayan_: any text editor will work.  emacs is good if you know it already.  If not, it has a pretty steep learning curve.
19:20:24 <geekosaur> you can use :e to edit the file and :r to reload it, or use a fancier setup (there are such things for both emacs and vim, and also atom)
19:21:04 <c_wraith> shayan_: and I am an emacs user.  I don't really recommend it to anyone, but my muscle memory is strong. :)
19:22:37 <shayan_> c_wraith: are you doubting me :(
19:23:07 <shayan_> http://33.media.tumblr.com/f08b43144d6bfeda5d2555cb46c37348/tumblr_n00dll6m801s2wio8o6_r1_500.gif
19:23:25 <shayan_> http://24.media.tumblr.com/4d2b0efa59d5811e16c18e947caec836/tumblr_mm9421Ft0z1s9wdxuo1_500.gif
19:23:34 <geekosaur> there's a certain tendency for people to hear that emacs haskell-mode is powerful and ask if they should switch to emacs
19:23:37 <c_wraith> shayan_: I'm just recommending one new thing at a time.  Haskell's pretty different.
19:23:49 <c_wraith> If emacs would also be new...  maybe hold off for a bit. :)
19:24:02 <geekosaur> which, well, emacs takes quite a lot of getting used to; it's 1970s and it shows
19:24:13 <shayan_> understood
19:31:55 <shayan_> what does it mean when the author uses many spaces before the = sign? http://imgur.com/a/Da9D1
19:32:08 <shayan_> example in the picture “qsort []         = []”
19:32:16 <glguy> It means they are lining things up
19:32:26 <shayan_> oh!
19:34:20 <shayan_> *moves into the text editor* xD
19:49:31 <shayan_> are scripts in the editor saved as .hs?
19:49:42 <shayan_> and what is the command to run it in the terminal?
19:50:28 <geekosaur> somename.hs, yes
19:50:34 <geekosaur> and then: ghci somename.hs
19:52:02 <shayan_> thank you
19:52:13 <shayan_> how can i change my directory? cd doesn’t work 
19:53:33 <geekosaur> :cd
20:00:12 <markasoftware> just out of curiousity, how does ghc build itself without an existing ghc install to bootstrap from?
20:07:47 <glguy> markasoftware: check out https://ghc.haskell.org/trac/ghc/wiki/Building/Porting
20:07:50 <shayan_> i’m trying to run a script i saved as “qsort.hs”, but i am getting the following error message http://imgur.com/a/B8Jxl
20:08:25 <glguy> shayan_: ghci isn't a replacement for bash, you can't run commands like "cd" and "ghci" in it like you would with bash
20:08:40 <geekosaur> you're already in ghci, use :load
20:08:47 <geekosaur> (can be shortened to :l)
20:08:50 <markasoftware> shayan_: looks like you forcgot to import
20:09:32 <shayan_> is load and import two seperate actions that i must perform?
20:09:51 <geekosaur> the import one is incorrect, they didn't look closely at what you did :)
20:10:39 <geekosaur> ":l qsort.hs" (but if you did :cd and are now not in the directory with that file, you will instead need to use the full path to the file)
20:11:08 <shayan_> i did :cd to the folder that i saved qsort.hs in
20:17:10 <lpaste> shayan_ revised “qsort ”: “qsort ” at http://lpaste.net/351206
20:17:33 <shayan_> does this not work?
20:17:53 <geekosaur> ... what is that on line 1?
20:18:05 <glguy> line 5
20:18:15 <glguy> an a should be a b
20:18:17 <markasoftware> pattern matching at its finest
20:18:32 <markasoftware> geekosaur: lol
20:19:08 <glguy> geekosaur: you didn't know the base case for pretend quick sort?
20:19:21 <shayan_> i fixed line 5, that was really bad.
20:19:55 <markasoftware> glguy: what?
20:19:57 <shayan_> the author writes line 1 as: qsort [] = []  …. i assume that i can fill it with any integer list to perform the quick sort
20:20:32 <shayan_> or should i leave it as qsort [] = []  and then at the end of this script run my own list to get the desired result?
20:20:39 <glguy> bad assumption, that's not where your input goes
20:20:51 <glguy> that's the base case, sorting an empty list
20:21:33 <shayan_> so it should be on line 2, replacing x:xs?
20:21:57 <glguy> no, line 2 was copied correctly
20:22:06 <geekosaur> shayan_, this is defining it,you don't fill it in anywhere
20:22:15 <geekosaur> you provide the list when you invoke it, not when you define it
20:22:31 <glguy> markasoftware: it's a joke
20:23:13 <glguy> unless you're asking about the link
20:23:20 <glguy> that's the answer to your question
20:23:32 <markasoftware> glguy: ok lol
20:23:52 <shayan_> glguy: okay, that makes sense. so after i define it, i can type a new line, say line 10, typing “qsort [12,3,4,1,1.2,99999]
20:24:29 <glguy> you can't put that on its own line
20:24:51 <glguy> but you could write mylist = qsort....
20:25:02 <glguy> .hs files are scripts
20:25:17 <shayan_> okay, so my definition goes into a script
20:25:19 <shayan_> after i run the script
20:25:24 <glguy> the aren't executed line by line like something like Python would
20:25:25 <shayan_> in the terminal, i can write in the terminal
20:25:31 <shayan_> qsort [x,x,x,x,x]?
20:25:41 <glguy> in ghci you can do that
20:25:56 <glguy> .hs files are not scripts***
20:26:03 <glguy> typo earlier
20:26:18 <Cale> Well, "hs" was originally supposed to stand for "Haskell Script"
20:26:35 <Cale> But yeah, nobody usually calls them that :P
20:26:36 <glguy> thanks, that'll help clear things up
20:26:52 <shayan_> ah, got it to work, thanks!
20:27:00 <Cale> It would perhaps be better to regard it as "Haskell source file" or something
20:27:52 <shayan_> so basically in the source file you define the algorithm, load it into the ghci, and then invoke your objectives
20:27:54 <shayan_> xD
20:29:39 <glguy> eventually you'll define a main action and compile your Haskell module to create a stand alone executable
20:34:47 <markasoftware> ghc --make your-file.hs to generate executable
20:35:35 <monochrom> You can omit "--make" since several years ago.
20:35:35 <geekosaur> --make hasn't been needed since the late 6 series...
20:36:47 <markasoftware> lol that's what learnyouahaskell said so ok
20:36:52 <markasoftware> guess it's aging
20:37:15 <monochrom> Every computer book is outdated before it's finished.
20:37:18 <geekosaur> yeh, it's pretty old at this point
20:37:26 <shayan_> haha
20:37:47 <geekosaur> and haskell moves pretty rapidly. _Real World Haskell_ was obsolete before it hit the shelves, the exception hierarchy got replaced
20:39:08 <ertes> i never had any doubts that "hs" stands for "HaSkell"
20:39:15 <monochrom> @type foldr
20:39:17 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:39:37 <monochrom> That also obsoletes most books.
20:40:12 <markasoftware> haskell moves fast? i thought last major change was in 2008
20:40:39 <geekosaur> last change to the standard
20:41:09 <glguy> Haskell 2010 came out in Nov 2009
20:41:17 <geekosaur> but nobody sticks to the standard. ghc pretty much defines where haskell is, and 8.0.2 was released yesterday and 8.2.1 is getting code freeze next month
20:41:18 <glguy> but the language and libraries move faster than the standard
20:41:54 <markasoftware> yesod or snap?
20:41:56 <ertes> markasoftware: you should read the release notes highlights with every major GHC version (when the first two numbers change)
20:42:09 <monochrom> You need to look at what most people speak rather than what the most recent Oxford English Dictionary says.
20:42:27 <geekosaur> OED's actually pretty good at tracking actual usage :p
20:42:40 <shayan_> would you all consider Programming in Haskell (Graham Hutton) to be outdated? 
20:42:45 <monochrom> (Even then, OED updates more often than The Haskell Report.)
20:42:45 <geekosaur> provided you use the online one, since print copies don't reprint themselves :)
20:43:11 <ertes> shayan_: that one should be pretty fresh…  its second edition came out recently
20:43:15 <monochrom> Programming in Haskell is one of the least outdated.
20:43:25 <geekosaur> iirc Hutton grumbled a bit when Applicative-Monad and Foldable/Traversable happened
20:43:25 <hodapp> geekosaur: give it another 10-20 years and I'll be getting junk mail that reprints itself to say something new when I ignore it.
20:43:35 <shayan_> ertes: 2007
20:43:51 <ertes> shayan_: if something is out of date, it means that you might find that the type of a function no longer agress with the book, but most likely because it was generalised (so it still works)
20:43:54 <shayan_> ertes: about a decade old now! xD 
20:44:00 <ertes> shayan_: second edition
20:44:09 <ertes> shayan_: http://www.cs.nott.ac.uk/~pszgmh/pih.html
20:44:17 <monochrom> Your bookstore could also be lagging behind.
20:44:24 <monochrom> TRUST NO ONE
20:44:26 <shayan_> i have the second edition physical copy in front of me. my first programming language book :)
20:44:37 <shayan_> monochrom: hahaha
20:44:42 <ertes> shayan_: that one is from 2016 =)
20:45:16 <shayan_> ertes: oh damn you’re right. i had just googled the title and thought it was showind the 2e
20:45:33 <ertes> your search engine could also be lagging behind.
20:45:35 <ertes> TRUST NO ONE
20:45:40 <shayan_> hahahaa
20:46:05 <monochrom> Google does not guarantee the latest hits. It only guarantees the most connected hits. Which also means lagging behind.
20:46:39 <monochrom> As another example if you Google for GHC user guide, you're bound to be pointed to 10 versions older than today.
20:47:05 <monochrom> (clarification: pointed to a version older than today by 10 versions)
20:47:23 <geekosaur> not just for haskell, either. the perl and python communities will tell you right off not to trust google searches but use their official language/module search portals
20:48:14 <shayan_> is there an active haskell forum, other than reddit?
20:48:39 <monochrom> the haskell-cafe mailing list
20:49:35 <ertes> if you like games, there is also an MMORPG with an active haskell user base:  stackoverflow.com
20:50:15 <jle`> lol
20:50:27 <hodapp> o_O
20:50:28 <geekosaur> heh
20:50:59 <monochrom> "achievement unlocked: higher score than edwardk's"
20:51:30 <markasoftware> what real-world stuff have you guys built with haskell?
20:52:08 <hodapp> markasoftware: firmware (and a build system for it)
20:52:12 <shayan_> monochrom: thnx, subscribed! anything useful for me other than beginners-mailing list?
20:52:28 <hodapp> for ARM Cortex-M0 and some Bluetooth Low Energy nonsense
20:52:36 <monochrom> a program to update a master CSV file by a patch CSV file
20:52:37 <markasoftware> hodapp: that's one thing I've noticed, about 50% of open-source haskell projects are just dev tools
20:53:13 <ertes> markasoftware: i wouldn't consider pandoc a dev tool, and there is also xmonad and gitit (a wiki engine)
20:53:16 <hodapp> markasoftware: this wasn't a dev tool; it was firmware that happened to be built with Shake
20:53:26 <monochrom> clearly xmonad is a dev tool
20:53:41 <geekosaur> and the other 50% are web platforms :p
20:53:47 <ertes> hehe
20:53:58 <Cale> markasoftware: The commercial project I've worked on most recently is intended to be a competitor to Slack -- a web application with chat that has integrated email, task management, surveys and a bunch of other organisational things.
20:54:00 <geekosaur> but yes, there's a few: git-annex, pandoc, xmonad
20:54:02 <hodapp> markasoftware: I was on a team building an end-user product, and firmware and electronics were my side of things
20:54:04 <ertes> well, it's 2017…  either it's a build tool, or it's a web app
20:54:18 <markasoftware> ertes: lol
20:54:24 <shayan_> Is Donald Knuth’s volume series "The Art of Computer Programming” relevant to Haskell? 
20:54:31 <geekosaur> pandoc is probably the best known since it's pretty much the go-to tool for translating documents between different formats
20:54:34 <ertes> shayan_: partly
20:54:36 <monochrom> no
20:55:04 <shayan_> ertes monochrom , should i invest the time in reading volume 1, at least?
20:55:10 <ertes> shayan_: but i'd rather not recommend it, because it's heavily biased toward imperative programming
20:55:16 <hodapp> does anyone really *read* TAOCP?
20:55:23 <hodapp> I considered them more just references
20:55:31 <monochrom> yes
20:55:36 <Cale> markasoftware: Another one was a face recognition task for a researcher to use on Amazon's Mechanical Turk -- where it presents the user with a series of images and they have to pick out the face and mark various features, and we record the results.
20:56:36 <Cale> markasoftware: Yet another one is a sort of marketplace for shippers and carriers (truckers) to get matched up.
20:57:01 <markasoftware> interesting, none of this stuff is on the 'what haskell is used for' page
20:57:04 <Cale> We do both the frontend and backend of our web applications in Haskell.
20:57:33 <monochrom> no one wants to update that page, too
20:57:52 <shayan_> Cale: are these projects done with GHJS?
20:57:55 <markasoftware> Cale: which framework?
20:57:57 <Cale> GHCJS, yeah
20:58:04 <Cale> We're using reflex-dom on the frontend
20:58:12 <shayan_> is GHCJS a framework?
20:58:16 <Cale> It's a compiler
20:58:22 <shayan_> reflex-dom is the framework?
20:58:28 <Cale> (Which compiles Haskell to Javascript)
20:58:28 <shayan_> i thought it was a “programming interface"
20:58:43 <shayan_> okay
20:58:45 <ertes> shayan_: what's the difference?
20:59:19 <shayan_> ertes: i was trying to find out earlier, i guess i just found out that there isn’t one!
20:59:25 <ertes> =)
20:59:30 <shayan_> xD
20:59:45 <ertes> it's vague terminology…  reflex-dom is a "framework" for web frontends
21:00:00 <Cale> Reflex-dom is a library for controlling the DOM in Haskell -- when you compile a reflex-dom project with GHC, you get a desktop application using an embedded browser widget, and if you compile with GHCJS, you get a web page.
21:00:32 <markasoftware> does GHCJS support all the html5 stuff and single page applications
21:00:45 <Cale> On the backend, we mostly use Snap, though it's usually overkill, since all our apps are single page applications and don't use any of the templating stuff.
21:01:10 <ertes> markasoftware: i think ghcjs-dom is pretty comprehensive, and if it isn't, it also has an FFI to haskell, so you can get access to missing stuff reasonably easily
21:01:26 <ertes> s/to haskell/to javascript/
21:01:43 <Cale> For the most part, the backend serves up this static page with a bunch of javascript, and then connects via a websocket and communicates with the frontend live via that.
21:01:44 <shayan_> are there any books on ghcjs-dom?
21:01:54 <Cale> Nope, it's too new
21:02:04 <Cale> There's documentation, most of which is autogenerated
21:02:24 <shayan_> https://media.giphy.com/media/PqVBpJna7r8Gs/giphy.gif
21:02:25 <markasoftware> and there's source code!
21:02:47 <Cale> yep
21:02:49 <shayan_> i’m watching some youtube videos right now on reflex-dom, it’s fascinating
21:02:50 <ertes> shayan_: you can learn the API mostly by guessing the right module name (just search the hackage page) and then reading the types
21:03:12 <ertes> it's pretty straightforward and works in haskell in general…  i can't remember how many libraries i've learned that way
21:03:30 <Cale> markasoftware, shayan_ : http://web.mit.edu/greghale/Public/ghcjs-dom-ghcjs/html/ghcjs-dom/index.html
21:03:36 <shayan_> this is probably a great way of learning how to program, is it not?!
21:03:37 <markasoftware> yeh, strong type system makes auto generated stuff more useful than most langs
21:04:22 <ertes> shayan_: difficult experiences are perhaps the most valuable =)
21:04:23 <shayan_> so reflex-dom is not restrictive to haskell, right?
21:04:28 <shayan_> ertes: +1
21:04:33 <Cale> hm?
21:04:39 <ertes> reflex-dom is a haskell library
21:04:47 <Cale> No, it's written in Haskell, you can't use it with any other language.
21:04:58 <Cale> It also wouldn't translate so easily to most other languages.
21:05:14 <shayan_> A video on youtube where someone is using reflex-dom with CSS
21:05:20 <ertes> yeah, it's indeed a *haskell* library =)
21:05:43 <Cale> shayan_: Well, yeah, you still write CSS to style your DOM elements.
21:05:52 <Cale> (in one way or another...)
21:06:09 <Cale> There's a Haskell library called Clay for generating CSS we sometimes use.
21:06:23 <Cale> It's a really thin wrapper though.
21:06:45 <markasoftware> eh, css is complex, better just to use css for css
21:06:47 <monochrom> CSS also has a presence in DOM.
21:07:27 <ertes> shayan_: reflex is a library for functional reactive programming…  it's a pattern for expressing interactive systems (be it user interfaces, networked stuff, etc.) using a completely pure domain-specific language
21:07:38 <Cale> markasoftware: Yeah, for the most part, I agree. It's tempting to try to abstract over various common patterns, but there's not a whole lot you can really do.
21:07:53 <ertes> shayan_: reflex-dom builds on top of reflex to build interactive web interfaces
21:07:58 <markasoftware> haskell is for doing stuff, css is more of a config file
21:08:07 <shayan_> ertes: wow, this is amazingly interesting
21:08:12 <Cale> It is nice to know that the CSS we're generated will be syntactically correct given that it typechecks.
21:08:49 <Cale> and that's the main advantage that we get out of Clay, I'd say.
21:09:56 <shayan_> I bookmarked the Clay library page
21:10:04 <ertes> Cale: it also handles some boilerplate: vendor prefixes for example
21:10:14 <Cale> Yes, that's true
21:10:26 <ertes> and simply being able to use haskell is reason to use clay over CSS:  onMobile $ do …
21:11:09 <Cale> Similarly we still use Groundhog (which is really similar to Persistent) for the DB queries that it manages to be able to express, rather than just using postgresql-simple for everything, since runtime query syntax errors are annoying.
21:11:25 <Cale> (and on top of that, it gives us some extra type safety)
21:11:30 <ertes> in fact i had wanted something like clay so badly that i wrote a library myself…  then i found out that i had just reinvented clay =)
21:12:23 <Cale> The last 3 days at work, we just transformed the chat/productivity/email application we'd been building for one client so that it's now multitenant. That was a lot of fun.
21:13:27 <shayan_> sarcasm Cale ?
21:13:39 <Cale> Maybe 10% sarcasm
21:13:54 <shayan_> :P
21:14:14 <ertes> "why are you not using SCRUM?" – "we use haskell…  we would have to do 2-hour sprints"
21:14:26 <Cale> It actually was pretty enjoyable, all things considered, though Wednesday was 14 hours long.
21:14:53 <shayan_> Cale: I hope one day I can get there!
21:14:59 <Cale> It would have been more like a year instead of 3 days if our stuff had been written in python or something.
21:15:07 <ertes> you realise that something like that would have taken a traditional web team weeks
21:15:14 <Cale> The refactor touched basically everything.
21:15:33 <Cale> Yeah, weeks is maybe more generous :)
21:16:07 <codygman> Did I find a ghci bug or is this invalid code? http://lpaste.net/351210
21:16:50 <ertes> codygman: i would have expected that to work…  maybe try without the 'let'
21:17:18 <codygman> ertes: No that didn't work
21:17:19 <dolio> Let 'statements' might be special cased in a weird way in ghci.
21:17:25 <dolio> Since they're not normal Haskell.
21:17:55 <codygman> dolio: Ah. It only seems to happen with lenses
21:18:00 <ertes> codygman: hack:  (a, b) <- pure c
21:18:27 <codygman> ertes: Still gives an error, but good thinking for a workaround
21:18:44 <monochrom> restart
21:19:05 <dolio> Actually, I'm wrong. It's not special cased.
21:19:08 <ertes> pattern binding works here
21:19:13 <dolio> I don't know what's going on in your example.
21:19:16 <monochrom> "have you tried turning it off and on?"
21:19:18 <ertes> let (x, y) = (3, 4)  -- works
21:20:32 <Cale> It's just so great having the typechecker there tying the frontend and backend together and making sure everything is coherent.
21:23:19 <Cale> Our authentication tokens have a type parameter now that indicate whether information about the schema that the user's data lives in was included in the signed token. On the frontend, that type variable remains polymorphic, because the frontend shouldn't ever have a chance to know or care about that. On the backend, it's filled in with a functor which is more or less (,) SchemaName in our case -- or which will be Identity in our 
21:23:19 <Cale> non-multi-tenant applications.
21:24:31 <Cale> But regardless, the introduction of that additional data, along with some changes to the types of functions that run database transactions helped us to track down everything which needed changing in response to the refactor and work through all the decisions that needed to be made.
21:25:40 <jle`> codygman: does it owrk if you don't deconstruct?
21:25:47 <jle`> let lls = recUncons recLenses
21:25:51 <jle`> let (l, ls) = lls
21:27:37 <Cale> Without a typechecker constantly directing us to the next thing, it would have been pretty insanely hard to get through everything.
21:32:14 <ertes> another interesting property about haskell is that you can refactor in a team
21:32:30 <codygman> jle`: Trying
21:33:49 <codygman> jle`: I still get <no location info>: error: not an expression: ‘let (l,ls) = lls’ so you either can't deconstruct that type by design or it is a bug I think
21:34:17 <ertes> codygman: yeah, that looks like a bug…  are you using 8.0.1?
21:34:53 <ertes> codygman: if not: 8.0.2 was released just a few days ago…  maybe try that one
21:35:00 <ertes> s/not/yes/
21:35:11 <glguy> codygman: Can you make a standalone file that we can use to reproduce that?
21:35:17 <glguy> the types in your paste don't seem to make sense
21:35:18 <ertes> apparently they fixed lots of small bugs in that release
21:36:07 <codygman> glguy: Yes I'll try it and I'll try it in 8.0.2
21:36:18 <glguy> Oh, nevermind the comment about the types, I found the comma in the tuple type just now
21:39:14 <codygman> glguy: It looks like it's fixed in HEAD +/-10 commits
21:39:27 <codygman> it gives me an ambiguous type error
21:43:08 <lpaste> shayan_ pasted “Sequencing Actions” at http://lpaste.net/351211
21:44:02 <shayan_> i’m wondering how i can invoke some sort of result from this example?
21:44:46 <shayan_> i want to see visually what this seqn function can do
21:46:05 <shayan_> for example, i have already tried seqn [getChar,getChar,getChar], but with no success, as it runs into an error in ghci
21:46:19 <Cale> shayan_: Your indentation is a bit off
21:46:33 <Cale> The subsequent lines in the do-block have to start on the same line as the x in x <- act
21:46:37 <Cale> on the same column
21:47:06 <Cale> also, there are tab characters in this
21:47:14 <eklavya> can someone please tell me how to use a connection pool with postgresql-simple   https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple.html  ?
21:47:18 <Cale> Make sure your text editor is configured to insert spaces when you press tab
21:48:47 <shayan_> Cale: thanks so much. would you say that TextWrangler is a bad text editor? Which one are you using
21:49:49 <Cale> eklavya: We use https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html
21:50:31 <eklavya> Cale: I was confident that I would get an answer when I saw you were online :P
21:50:36 <eklavya> thanks Cale :)
21:50:40 <Cale> eklavya: Which is a sort of generic connection pool thing. You give it an action which does the 'connectPostgreSQL', and an action which does 'close' and tell it a few numerical parameters and it'll make you a pool
21:51:00 <eklavya> Cale: also which postgresql lib do you use ?
21:51:48 <Cale> shayan_: Go to "Preferences" -> "Editor Defaults" -> "Auto-expand tabs"
21:52:07 <Cale> shayan_: I've been using Sublime Text lately
21:52:33 <Cale> I used vim for years before that, but I wanted a different collection of annoyances
21:52:57 <Cale> eklavya: We use a combination of groundhog and postgresql-simple
21:53:23 <Cale> We really need to do something about the situation, but it works
21:53:38 <eklavya> Cale: thanks, I was wondering if postgresql-simple was the best choice
21:54:00 <Cale> We use groundhog to make easy migrations trivial and to be able to do very simple queries in a type-safe way
21:54:27 <Cale> and then more complicated queries, we write using postgresql-simple, since its support for raw queries is much better
21:54:38 <eklavya> ok
21:54:41 <Cale> (basically anything involving a JOIN)
21:54:57 <eklavya> I confused groundhog with bloodhound
21:55:11 <eklavya> groundhog seems to also be a db lib
21:55:20 <Cale> Groundhog is a fork of persistent
21:55:31 <Cale> from several years back
21:58:25 <eklavya> now I think I should use groundhog
21:59:05 <eklavya> I won't be making any complex queries anyway, I have been conditioned too much by cassandra
22:00:05 <Cale> It depends on the application, but it's eventually really tricky to get good performance if you try to simulate joins outside the DB in my experience.
22:00:41 <eklavya> ok
22:00:45 <Cale> But yeah -- if your schema is pretty simple, maybe it just doesn't come up.
22:01:27 <eklavya> in Scala in some libs the sql is checked at compile time and you still get to use raw sql
22:01:31 <shayan_> Cale: Downloaaadin Sublime!  8) 
22:02:16 <eklavya> Cale: what plugin do you use for sublime?
22:02:23 <Cale> shayan_: The multiple cursors thing seemed gimmicky to me at first, but it turns out to actually be pretty nice
22:03:00 <jle`> codygman: hm, what about giving it a specific type?
22:03:04 <jle`> with a type annotation
22:03:06 <Cale> I'm using something called SublimeHaskell -- It's just barely set up
22:03:29 <Cale> I basically only use it because it gets jump-to-definition working
22:03:49 <eklavya> I can't imagine my life without multiple cursors now, it's been such a time saver since sublime introduced it
22:04:06 <eklavya> I tried SublimeHaskell once, couldn't make it working
22:04:19 <eklavya> I wish something like intero was available for sublime
22:04:32 <shayan_> Cale: what color scheme you rocking?  8) 
22:04:47 <Cale> Yeah, I just turned off all the ghc-mod etc. support since those things don't know about my nix environment.
22:05:21 <Cale> I modified the "Twilight" scheme to have a darker background
22:05:33 <Cale> (black)
22:07:08 <shayan_> awesome
22:08:00 <dmwit> Are multiple cursors like vim's marks?
22:09:02 <dmwit> eklavya: Possibly related to "use raw sql, get type-checked at compile-time": http://hackage.haskell.org/package/yeshql
22:11:19 <eklavya> dmwit: yes, something like that, it doesn't mention anything about sql injection mitigation though and the query and inputs are interpolated
22:12:00 <dmwit> codygman: Even if there was never an explicit bug for it, it might be worth submitting a test case to the GHC folks so whatever got fixed doesn't regress.
22:12:23 <eklavya> dmwit: in multiple cursors you select some text (any common pattern) and you keep on selecting it as far as you want and you get cursors in all the locations
22:12:42 <eklavya> then you can multi edit 
22:12:56 <dmwit> Oh, that does sound nice, and not at all like vim's marks.
22:13:02 <eklavya> it's available in sublime, emacs, vscode, atom
22:13:46 <eklavya> it's unbelievably useful
22:15:16 <shayan_> Are there tab adjustments that need to be made on Sublime after installation? I’m currently on the default settings 
22:15:46 <shayan_> O WTF U NEED TO BUY SUBLIME
22:17:11 <shayan_> https://az616578.vo.msecnd.net/files/2016/02/28/6359223430979430381456412245_giphy%20(11).gif
22:18:10 <Axman6> you don't actually _need_ to buy sublime, it'll just remind you like once a day. there are no restrictions for the unpaid version
22:19:48 <shayan_> Axman6: :)
22:20:00 <eklavya> it used to ask that at every 3rd-4th save
22:20:19 <Axman6> but also, that how the developer can afford to live and make updates to it
22:21:13 <shayan_> if i end up using it for a while, i will buy it
22:21:22 <shayan_> it also supports the haskell language, unlike textwrangler
22:24:49 <lpaste> shayan_ pasted “Seqn” at http://lpaste.net/351212
22:25:08 <shayan_> are there any actions I can run in this exercise to get a feel of what the Sequencing function is capable of doing?
22:28:49 <shayan_> i have tried seqn [getChar,getChar,getChar] , not sure why it’s not working
22:30:23 <jle`> what do you mean by "not working"?
22:30:36 <jle`> is it doing something different than what you expect?
22:34:19 <c_wraith> may be a buffering issue
22:34:34 <shayan_> jle`: I want to test what the seqn function can do. I’m not sure how I can invoke it. I tried seqn [getChar,getChar,getChar], but I am getting a message: http://imgur.com/a/cnJdt
22:35:47 <geekosaur> check your indentation. best is to tell the editor to indent only with spaces, because tabs don't always mean the same thing
22:36:18 <geekosaur> (ghc uses tabstops evey 8 characters, some editors use 4, others 5, others may do any number of things(
22:37:25 <MarcelineVQ> how very odd, it compiles for me as written in that paste, despite the 7 tabs :X
22:37:46 <geekosaur> yeh, that's been seen before
22:38:00 <geekosaur> browsers sometimes alter indentation
22:38:16 <MarcelineVQ> I'm using raw
22:38:27 <MarcelineVQ> or do you mean from their paste end?
22:38:36 <geekosaur> their end, yes
22:38:40 <MarcelineVQ> interesting
22:38:43 <geekosaur> this kind of thing has happened before
22:39:06 <geekosaur> it's one of the reasons people tend to just insist on "use spaces only", because things get *weird* with tabs sometimes
22:40:51 <shayan_> i have a feeling the problem is not with indentation: http://imgur.com/a/mUq1p
22:41:34 <shayan_> {i fixed line 1 btw lol dont h8}
22:41:41 <geekosaur> but what you show there is correct and so is the paste, but it thinks you escaped the do which means line 3 is not indented as far as it needs to be
22:43:02 <jle`> did you save the file after you make the edits, maybe?
22:43:08 <geekosaur> hm, or maybe overindented; if I look cloisely I see 4-space tabs in the editor
22:43:46 <shayan_> geekosaur: yes atm the tab size is: 4
22:44:02 <geekosaur> use 8, if you must use tabs
22:44:13 <geekosaur> better is to tell it to always expand tabs to spaces
22:46:03 <srhb> The lpaste also has mixed tabs and spaces. I thought that was basically the devil.
22:47:20 <norms> When I run hindent, all I get is the help text. Is this a known issue? http://lpaste.net/351213
22:52:38 <srhb> norms: I don't think so.
22:54:02 <shayan_> srhb: that’s correct. but i’m still having problems running it in my ghci
22:55:09 <srhb> shayan_: What's the error now?
22:55:59 <shayan_> srhb: it’s the same, one sec i’ll paste it
22:57:08 <shayan_> srhb: ABORT! works fine now :D
22:57:13 <srhb> shayan_: Goodie.
23:07:11 <MarcelineVQ> norms: what version of hindent are you using? I suspect that piping syntax is for the newer versions, note that the --version above the cat example is 5.1.1, probably you're using 4.6.4
23:08:09 <MarcelineVQ> I think you need to specify a style in <5.* versions, like uhm... cat file.hs | hindent --style chris-done
23:28:27 <shayan_> how do you exit from *Main in ghci?
23:29:46 <pavonia> ":quit"?
23:32:46 <shayan_> pavonia: thanks m8
23:33:06 <shayan_> pavonia: ah that exits ghci
23:33:08 <shayan_> xD
23:33:17 <shayan_> didn’t want to leave ghci entirely
23:33:35 <pavonia> What do you want to exit from then?
23:33:50 <shayan_> the *Main
23:33:56 <shayan_> basically after loading a file
23:34:06 <shayan_> and then going into the function call
23:34:12 <shayan_> if that makes any sense
23:34:18 <pavonia> Such that no module is loaded anymore?
23:36:51 <srhb> shayan_: :module -Main
23:36:53 <shayan_> pavonia: yes
23:38:08 <shayan_> srhb: perfect, thank you!
23:55:39 <norms> MarcelineVQ: I'm using 4.5.5
23:56:33 <norms> Which looks like it has the same syntax: https://hackage.haskell.org/package/hindent-4.5.5
