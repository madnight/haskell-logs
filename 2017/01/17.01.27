00:00:15 <zipper> OK I have bytes yes but they're not being processed on how?
00:00:43 <zipper> Is there a way I could just make a request and get *only* the response header in memory
00:01:36 <zipper> Because the Lazy ByteString is still in memory as far as I can understand, what would happen if I converted it to a String? Would it somehow use way more memory?
00:02:29 <zipper> "A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory."
00:02:41 <zipper> but since I read it over the network it is in memory, right?
00:02:53 <zipper> Since it's not like I'm reading from disk
00:03:04 <zipper> or does memory here means the stack?
00:04:06 <qcrvszvz> Lazy IO might enable you to already start processing the initial part of the returned bytestring before the rest is even transmitted over the wire
00:04:28 <zipper> qcrvszvz: Oh nice this is what I want
00:04:31 <shayan_> Any of you have experience practicing Haskell on codewars? 
00:04:38 <zipper> but I only want the first few bytes
00:04:44 <zipper> Since I want the content type
00:05:03 <zipper> and if I get it is a certain type I then read the <head></head>
00:05:10 <zipper> the rest I don't care about
00:05:43 <zipper> :t Data.ByteString.Lazy.take
00:05:45 <lambdabot> Int64 -> BSLC.ByteString -> BSLC.ByteString
00:05:49 <zipper> that looks great ^
00:06:14 <zipper> Is there a chance the head would be greater than 64 bytes, so hard to know
00:06:16 <qcrvszvz> a) Lazy ByteStrings are chunked, i.e.: there is some minimum amount of data you always read to even start constructing your bytestring (which might be large, say 4096 bytes)
00:06:52 <zipper> qcrvszvz: I'm ok with that
00:07:10 <qcrvszvz> b) Check if your network library actually does lazy io and isn't lying to you about the bytestring really being lazy
00:07:52 <zipper> qcrvszvz: I returns a lazy bytestring so it does
00:08:03 <zipper> *it
00:08:12 <zipper> My issue is that I have a small VM on Digital Ocean that always runs out of memory because it sometimes tries to download videos 
00:08:30 <qcrvszvz> but if it doesn't the idiomatic way is to just start parsing and don't look at the part you don't need; _usually_ what you don't look at doesn't get read
00:08:40 <zipper> qcrvszvz: Thanks I think I get what you mean
00:08:49 <zipper> Gonna come back if something breaks
00:14:48 <osa1> does anyone know a package like this on stackage lts 7.14: https://hackage.haskell.org/package/privileged-concurrency ? I need read-only MVars, Chans etc.
00:38:36 <Bish> can you guys bring the charm of functional programming closer to me? i've never (really) tried to code haskell, since starting is giving me a hard time. what's the point of having a language with functions without sideeffects, if you THEN define that some functions have
00:39:25 <Ferdirand> you don't really define that some have
00:39:42 <Bish> that's the point i am not getting
00:41:24 <Bish> i feel like the biggest benefit in this kind of programming is that you're really hard forced to have good structured data, and the same could be achieved with discipline
00:41:52 <bshelden> Certainly, but would you rather spend those mental cycles being disciplined or working on the solution?
00:42:20 <liste> Bish: you can do "math" with functions without side-effects, eg. if you have "f = a b c" and "g = a f", then g can be simplified to "g = a (a b c)"
00:42:22 <Bish> no, but none ever talks about this fact, that is what i feel like
00:42:32 <Ferdirand> discipline does not work in practice, we see countless examples every day
00:42:46 <liste> Bish: and so on, to reason with your code easily without running it
00:42:54 <Ferdirand> anyway, values in IO are not functions, they are "actions" if you like
00:43:02 <Ferdirand> things with side effects
00:43:07 <Ferdirand> and you cannot call them from haskell
00:43:23 <liste> Bish: and note that very few functions have side-effects, mostly debugging functions (Debug.trace) and functions that are misused (unsafePerformIO)
00:43:29 <Bish> so they're evaluated alongside with haskell rather than in the function?
00:43:45 <Ferdirand> what you do with actions is that you combine them to form a program
00:43:58 <liste> Bish: IO actions don't have side-effects, they *are* effects. (not "side")
00:44:09 <Ferdirand> they are not actually run when you combine them
00:44:36 <Ferdirand> but eventually, you build a single action, that you call main, and that gets executed by the runtime
00:44:49 <Bish> i am confused, still, maybe i just need to write something, i learned a lot of languages but starting haskell is one different thing enitrely
00:45:04 <Bish> Ferdirand: thanks that helps
00:46:28 <Ferdirand> also, be aware that when you are using ghci, what you enter is (roughly) in the context of a IO do-block, where actions can get executed immediately
00:46:40 <Ferdirand> this might be misleading
00:46:42 <Bish> i figured something like that
00:49:04 <Bish> so if i was about to write an echo server, i would write an action, which accepts connections, another one that multiplexes
00:49:18 <Bish> and would have purely function functions which use it's state to calculate an answer?
00:51:16 <Bish> is that correct?
00:52:12 <uiop> that's kind of vague Bish, it's hard to tell whether you've said something profound or said something confused :)
00:52:32 <Ferdirand> well there is a simpler example with no network involved
00:52:33 <Ferdirand> cat
00:52:55 <Bish> i always start with echo servers when learning a new language ;; how would io be different
00:53:19 <Ferdirand> fair enough
00:53:38 <uiop> Bish: exactly, it's *not* different. once you can code C in haskell, you've reached enlightenment
00:53:42 <uiop> .....or something
00:53:50 <Ferdirand> :t hGetLine
00:53:52 <lambdabot> error:
00:53:52 <lambdabot>     • Variable not in scope: hGetLine
00:53:52 <lambdabot>     • Perhaps you meant one of these:
00:54:01 <Bish> we can make it simplre though: if i have a "action" that just accepts socket, sends "hello" and closes.. what kind of function is that "action" then
00:54:47 <Ferdirand> it would not be a function, it would be a value
00:55:01 <Bish> i mean, it has sideeffects and probably "decides" what to do, maybe with exception handling, i don't know
00:55:06 <Ferdirand> unless you want to make it a function that accepts a port number to listen to
00:55:13 <uiop> Bish: there are so many abstraction levels stacked upon each other in haskell, it's impossible to answer that question without knowing at what level you desire an answer
00:55:53 <Bish> uiop: the most basic one
00:55:59 <Ferdirand> Bish: do you know the (>>), (>>=) operators yet ?
00:56:19 <Bish> i saw them in talks, they were described like pipes(abstract)
00:56:35 <Bish> but those are syntactical sugar, right? they get translated into something else
00:56:41 <Ferdirand> no, it's the opposite
00:56:47 <uiop> Bish: at the topmost level.... it's not a function unless the type is "...... -> IO (...)"
00:56:50 <Ferdirand> do-notation is sugar that translates into (>>=)
00:57:08 <Bish> oh, okay, i google the >>= operator
00:57:15 <Ferdirand> :t (>>=)
00:57:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:58:12 <Ferdirand> in the context of m being IO, it allows you to sequence two actions such that the definition of the second action depends on the result of the first
00:58:47 <Ferdirand> to be clear, (IO a) is the type of an action that, when run, yields a value of type a
00:59:46 <Ferdirand> there is no function (IO a -> a) in haskell, because knowing the definition of an action is not enough to know its result
00:59:49 <Ferdirand> for this you have to run it
01:00:12 <Ferdirand> and have effects on the world, etc
01:00:15 <Ferdirand> but what you can do
01:00:37 <Ferdirand> is use (>>=) :: (IO a) -> (a -> IO b) -> IO b
01:01:38 <uiop> :t unsafePerformIO
01:01:41 <lambdabot> error: Variable not in scope: unsafePerformIO
01:01:52 <uiop> liar
01:01:54 <Ferdirand> shhhh
01:02:00 <Ferdirand> that's a white lie
01:02:19 <Ferdirand> that means, if the second step of the computation (the function a -> IO b) needs to know the result a, before deciding what the next action will be
01:03:00 <Ferdirand> even though from haskell you cannot extract the a, you can use >>= to combine the actions so that the first part is run, then the second part is evaluated with the result and run
01:03:26 <Ferdirand> but this is still only combining actions; the actual running happens when this combined action itself is run
01:04:36 <Bish> i think i will just need to try it.. but syntax is haskell is very ugly too (imho)
01:04:44 <Bish> that's why i am hesitating
01:06:05 <uiop> Bish: it's like coffee, swedish fish, or crack cocaine. once you're hooked, it's too late
01:06:26 <Ferdirand> (>>=) is not very pretty indeed
01:06:26 <uiop> Bish: but srsly thogh, why do you say ugly?
01:06:30 <Ferdirand> that's why we have do-notation
01:06:42 <Bish> i tend not to glorify, especially fish, i wouldn't like fish
01:06:47 <uiop> heh
01:06:53 <merijn> I dunno, I kinda like >>=
01:07:01 <Bish> i always thought i've found the holy grail in programming
01:07:10 <Ferdirand> it's an acquired taste, maybe
01:07:10 <Bish> but i am pretty sure there is none
01:07:11 * uiop too, although he prefers flip mode wild style (=<<)
01:07:24 <Bish> Ferdirand: don't start this flamewar :D you can simply not like things
01:07:32 <Bish> there is no better taste, there is just taste
01:07:43 <merijn> Bish: That's why you learn haskell and start making your own programming languages!
01:07:51 <Bish> im a german, i went to japan, i tried, i tried really hard and got depressed, and that is nothing you learn
01:07:58 <Bish> (im talking about fish)
01:08:09 <Ferdirand> (i'm not saying it's better, i'm just saying taste evolves in time)
01:08:21 <Bish> that can also mean i hate fish more and more.
01:09:57 <Bish> when talking about ugly syntax i meant $ and .
01:10:10 <Bish> they're really making it worse (imho), why not just have prefix all the way
01:10:17 <Bish> but that is probably only opinion, too
01:10:20 <Ferdirand> then you get lisp
01:10:23 <merijn> That's not syntax, though
01:10:39 <merijn> THose are just functions, you could easily define your own prefix version
01:10:40 <Bish> merijn: i am not scientifical enough to understand that, but you get my point
01:10:51 <Bish> Ferdirand: so prefix haskell == lsip?
01:11:16 <Bish> merijn: if i always like to tell the compiler to use prefix yes.
01:12:11 <Ferdirand> no, but if you just dislike $ and ., you can entirely replace them with appropriate use of ()s
01:12:17 <Ferdirand> and lambdas
01:12:56 <Ferdirand> i kinda agree that $ looks very heavy for an application operator
01:12:57 <Bish> but what about things that are infix by defautl, say +
01:13:10 <Profpatsch> I want to write a DomT which is a ReaderT DomEnv m a
01:13:10 <Bish> i would have to do (+)(a,b)
01:13:16 <Bish> right?
01:13:21 <Ferdirand> (+) a b
01:13:33 <Bish> yeah that bugs me :/
01:13:38 <Ferdirand> or you could do plus = (+)
01:13:40 <Bish> always having to wrap it in ()
01:13:44 <Ferdirand> and then "plus a b"
01:13:45 <Profpatsch> Is there a nice way to inherit the instance from ReaderT?
01:13:58 <merijn> Profpatsch: Is DomT a newtype?
01:14:02 <Profpatsch> *instances
01:14:08 <Profpatsch> merijn: Yes, of course.
01:14:23 <merijn> Profpatsch: GeneralizedNewtypeDeriving
01:14:36 <Profpatsch> ReaderT has quite a few instances, I need to list them all, right?
01:15:10 <Profpatsch> And if ReaderT gets a new one, I’d have to update my library as well?
01:15:40 <electrocat> does anybody know how to specify that you want a man page when compiling ghc?
01:15:40 <merijn> Profpatsch: Yes
01:15:50 <thatguy> can anyone tell me why I get this error msg http://lpaste.net/351689 with this code http://lpaste.net/351688
01:15:57 <merijn> Profpatsch: If you care about that, why not directly expose the ReaderT?
01:15:59 <thatguy> for me I defined depth as Tree a -> Integer
01:16:04 <thatguy> I don't get why he is complaining
01:16:33 <Profpatsch> merijn: You mean just have a type instead of a newtype?
01:17:02 <merijn> Profpatsch: Or not even a type alias
01:17:13 <merijn> Profpatsch: Just have "ReaderT DomEnv m a" in your types
01:17:32 <merijn> I hate having to click through 5 type aliases to figure out something is just a ReaderT or whatever
01:18:19 <electrocat> thatguy: your are pattern matching on depthTree, it'l shadow the 'depthTree' function you created
01:18:33 <shayan_> is there any channel to discuss databases?
01:18:44 <thatguy> electrocat, ah damn it! I used the same name twice
01:18:54 <thatguy> I should have seen that
01:18:57 <thatguy> electrocat, thanks a lot
01:19:26 <electrocat> thatguy: your are also doing 'depthTree newLeft + 1', this will probably produce an error aswel
01:20:00 <thatguy> electrocat, yes I had the same error over and over again
01:20:07 <electrocat> it should be 'depthTree (newLeft + 1)'
01:20:07 <merijn> thatguy: You'll probably wanna use -Wall when compiling
01:20:17 <merijn> thatguy: That will warn you if you shadow names
01:20:28 <thatguy> merijn, I only use ghci and :load
01:20:35 <thatguy> is there a -Wall flag there?
01:20:53 <merijn> thatguy: Pretty sure "ghci -Wall" works, not sure if it reports errors when using ":l" though
01:20:54 <thatguy> electrocat, no I actually want the depth of the newLeft tree and add one to it
01:21:01 <electrocat> i think you can do ':set -Wall' in ghci
01:21:06 <Profpatsch> merijn: or have a function that exposes the ReaderT Dom m a to the user if hir wants to use it?
01:21:28 <merijn> Profpatsch: Yes, but if you're going to expose the ReaderT what's the point of newtyping?
01:21:29 <electrocat> thatguy: my bad, 
01:21:35 <electrocat> thatguy: nvm then :p
01:21:46 <merijn> Profpatsch: I mean, the entire reason people use newtypes is to *not* expose the underlying monad
01:21:53 <Profpatsch> Hm
01:21:54 <merijn> If that's not what you want, why bother?
01:21:59 <Profpatsch> Yeah, rigth.
01:22:10 <merijn> That's just giving other people busy work for no reason
01:22:41 <uiop> shayan_: what does that mean to discuss databases?
01:22:49 <uiop> shayan_: what aspect of them?
01:23:33 <oeoeoeoe> how I can make stack to use many cores?
01:23:49 <Profpatsch> merijn: On the other hand of course the interface breaks if I e.g. change the amount of fields in DomEnv
01:24:16 <uiop> what is this stack everyopne speaks of? forgive me, i'm a total newschool noob....
01:24:29 <uiop> ignore the fact i could google this
01:24:36 <uiop> ive had too many scotches...
01:24:46 <shayan_> uiop: I’m seeking a real-time database that covers news and events
01:25:19 <uiop> shayan_: ok. do you want to consume a product that has already solved this problem, or do you seek to implement such a beast?
01:26:14 <uiop> shayan_: second level question being.... what does "realtime" mean, and what does "news and events" mean?
01:26:15 <Profpatsch> Why arest thou speaking in ancient tongues?
01:26:28 <uiop> Profpatsch: lol
01:26:38 <merijn> Profpatsch: If you expose the ReaderT in anyway your interface breaks *anyway*
01:26:50 <Profpatsch> merijn: You are right.
01:26:51 <merijn> Profpatsch: Since part of the API breaks if you change it
01:27:00 <shayan_> uiop: I’m seeking to implement such a beast!
01:27:09 <oeoeoeoe> uiop:  stack is like cabal, a kind of "make" for haskell
01:27:11 <shayan_> uiop: As well as to consume, both really.
01:27:15 <Profpatsch> I probably don’t need a transformer, I’ll just do a simple stack.
01:27:31 <quchen> Profpatsch: The guy who asked about the good use of Cont in practice, do you know his name? I meant to tell him about chaining bracket/async and using Managed, but didn’t have the time
01:27:33 <Profpatsch> And if the user wants to he’d have to run it and use that.
01:27:37 <thatguy> I am following the CIS 194 course for haskell (spring 2013) and there is a task to create a balanced binary tree (i.e. the depth of the left and right subtree only differ by one). If anyone would be so kind to look at my solution and give tips what I could have done better I would be very happy http://lpaste.net/351688
01:27:54 <Profpatsch> quchen: Markarius
01:28:00 <uiop> oeoeoeoe: i thanketh thouth for pitying those that the suneth doth hast noteth shine upon in the recent
01:28:18 <quchen> Profpatsch: markarius@ihatesmlnj.com? ;-)
01:28:30 <Profpatsch> hahah
01:28:40 <Profpatsch> quchen: Just put it on the curry-club ml
01:28:50 <Profpatsch> This way everyone can read it.
01:29:14 <Profpatsch> curry-talk@lists.openlab-augsburg.de
01:29:27 <Profpatsch> If you don’t want to sub I can leave it through.
01:29:32 <uiop> shayan_: ok, sik! so what does realtime mean? (rhetorical)
01:30:37 <uiop> shayan_: well, that's an "actual" question really.... the real relevant question is: what are your goals, and what are your constraints
01:31:13 <quchen> Profpatsch: »Sie dürfen nicht abonnieren weil die von Ihnen angegebene E-Mail-Adresse als unsicher betrachtet wird.«
01:31:17 <quchen> Guess not.
01:31:53 <uiop> shayan_: ok, all bullshit aside (remember i'm, drinking scotch..): what is the application?
01:33:13 <Profpatsch> quchen: The guy is the maintainer of Isabelle btw, and longer in the business than any of us combined. >.
01:33:46 <shayan_> uiop: my goal is to find out more on the GDELT Project. Do you know anything about it?
01:34:41 <quchen> Oh! Then I guess I can find his mail elsewhere ;-)
01:35:11 <uiop> shayan_: i do not know about that project, but now i'm curious. do you have a link?
01:35:54 <shayan_> http://www.gdeltproject.org/
01:36:55 <uiop> shayan_: thx
01:37:30 <uiop> nice animated gif
01:37:42 <Omnic> question, with foldl (+) 0 [1..10], how does (b -> a -> b) translate to the (+) portion
01:37:51 <Omnic> (in the type of foldl, when you do :t foldl)
01:38:02 <oeoeoeoe> i'm looking at the docs about how to compile in parallel with stack but I see nothing, unlike cabal
01:39:09 <merijn> Omnic: Well, remember that 'b -> a -> b' means that 'a' and 'b' *can* be different, they don't *have* to be
01:39:38 <merijn> Omnic: So if we simplify '(+) :: Int -> Int -> Int' and compare that with 'b -> a -> b' we just get 'a = Int' and 'b = Int'
01:40:07 <merijn> :t Data.List.foldl
01:40:08 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
01:40:18 <Omnic> alright that makes sense
01:41:04 <merijn> and then we simply replace all the other 'a' and 'b' with Int
01:41:11 <Omnic> so (b -> a -> b) is a function in the type declaration?
01:41:30 <merijn> Omnic: Yes
01:41:36 <Omnic> alright thanks
01:42:09 <merijn> Omnic: Specifically a function that takes an 'b' and 'a' and returns a 'b', for whatever types of 'a' and 'b' we want :)
01:42:36 <Omnic> mucking about in haskell doing projecteuler
01:42:51 <Omnic> i came from scala, i do that purely functional, figure i might as well give haskell a shotr
01:42:59 <uiop> :t [unsafeCoerce, id]
01:43:01 <lambdabot> error:
01:43:01 <lambdabot>     Variable not in scope: unsafeCoerce :: a -> a
01:43:18 <merijn> Word of warning, I think Project Euler is...not great, in terms of programming excersises, especially not for Haskell
01:43:33 * uiop loves meta-violent hyperbole
01:43:48 <Ferdirand> merijn: why that ?
01:43:50 <Omnic> question 2 was good to teach me infinite lists w/ the fibonacci sequence
01:44:04 <merijn> It's fun if you like number theory, but the exercises focus on things that are not common programming tasks
01:44:16 <Kristof_HT> i enjoy project Euler, but didn't try it in haskell yet
01:44:30 <Ferdirand> thanks FSM there is Math.NumberTheory
01:44:36 <Omnic> merijn: true
01:44:47 <merijn> Additionally, the numeric hierarchy is one of the less nice portions of Haskell in my (and many other people's opinion) and PE really grinds your face into it
01:44:48 <uiop> wow there is so much i need to catch up on
01:45:33 <merijn> Which means that instead of learning to use Haskell for things it shines in and real programming, you end up rubbing your face in historical unpleasantness and wondering why things feel awkward
01:45:58 <merijn> Kristof_HT: Like I said, I think PE is fun. But I don't think it's good exercise
01:46:02 <merijn> @where exercises
01:46:03 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
01:46:13 <Omnic> oh i did H-99
01:46:14 <Omnic> well
01:46:16 <Omnic> in scala
01:46:17 <Omnic> S-99
01:46:36 <merijn> Those are focussed on providing more programming oriented tasks
01:46:45 <Omnic> yeah i enjoyed S99
01:49:04 <Omnic> ah yeah, s-99 is an adaptation of h-99 for scala
01:51:46 <uiop> does dons still hang around here?
01:52:21 <merijn> uiop: He mostly tweets pics of skylines nowadays ;)
01:52:57 <uiop> sounds like 1st world problems merijn...? ... :)
01:54:13 <merijn> uiop: He's rather busy with work, I gather and thus not as active as he used to be.
01:54:14 <uiop> merijn: thx, that was perfect info amount to locate
02:02:12 <thatguy> can anyone explain me the error here: http://lpaste.net/351694 (very short code). I am trying to use point-free style
02:02:26 <thatguy> ah found it
02:02:29 <thatguy> nvm
02:05:33 <ph88> hi guys, i have a question about a syntax i should use in return https://paste.fedoraproject.org/537440/51145614/ with applicative style i would use more <*> but now with do notation i don't know how to express this
02:12:27 <clmg> Does anyone know how to get the window size in vty?
02:12:43 <vapid> > x = x
02:12:46 <lambdabot>  <hint>:1:3: error:
02:12:46 <lambdabot>      parse error on input ‘=’
02:12:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:13:37 <quchen> clmg: Yes. @fmthoma is answering (author of vgrep, sitting next to me), I’m his IRC puppet. One moment. :-)
02:14:07 <quchen> clmg: https://github.com/fmthoma/vgrep/blob/master/src/Vgrep/App/Internal.hs#L27
02:14:59 <clmg> Great :-)
02:15:02 <zipper> Is there a function that means the same as (fmap . fmap) or (fmap . fmap .fmap ...) continued?
02:15:18 <zipper> Like is there a function that is like compose fmaps
02:15:27 <zipper> :t sequence
02:15:29 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
02:15:54 <ph88> zipper, maybe i could use such a function too but then with <*>
02:16:01 <merijn> zipper: No, because that's asking the compiler to guess how many fmaps you want
02:16:47 <zipper> :t (.) <$> fmap <*> fmap
02:16:49 <lambdabot> Functor f => (b -> b) -> f b -> f b
02:17:00 <zipper> goddamn
02:17:09 <zipper> merijn: I see
02:17:36 <quchen> Profpatsch: Please approve of my mailing list subscription »alsbald«. :-þ
02:19:43 <ph88> merijn, could you take a look at my paste please? i think it's not a difficult question
02:20:32 <merijn> ph88: Well, what's 'sp' supposed to return? What's it's type?
02:21:36 <ph88> sp is supposed to be like    chr '(' <*> n get <*> chr '(' <*>
02:21:49 <ph88> uh without that last <*>
02:22:22 <merijn> I'm not sure what you mean by that?
02:24:43 <ph88> eh wait let me try it with <*> first and see if it compiles and then see if it's possible to do the same with a do notation
02:30:14 <ph88> merijn, i think i will come back to this later, i'm a bit swamped in compiler errors :|
02:30:16 <shiona> Random thought of the day: Is it sensible (or even favourable) to think as the time passing as a side effect of a function?
02:32:13 <shiona> or is it a philosophical question and the running program is more likely the side effect of the time
02:35:31 <Logio> I don't think it's a philosophical question, but the latter still holds 
02:37:50 <danza> shiona, i think i've actually seen time encoded as a side effect, but i can't remember where :(
02:38:56 <tabaqui1> stack build i386 compiler without m32 flags
02:39:18 <tabaqui1> so I cannot use it to create x86 binaries
02:39:24 <tabaqui1> s/build/setup
02:39:48 <tabaqui1> maybe someone has solved this problem already>
02:39:51 <tabaqui1> *?
02:40:12 <uiop> shiona: what Logio said, it is not a philosopphical question, even though you may be smoking the good stuff.... if time if a river that everything floats down, then sure programs float down it as well.. but them being a *side effect* of time is a stretch. what, are the anthropahaskellizing time as a haskell program ans saying time has side-effects wqhich include the running of compuiter programs
02:40:16 <uiop> or something
02:40:17 <uiop> ?
02:40:44 <uiop> *"what, are _we_ antropa...."
02:41:17 <merijn> shiona: You are on the brink of reinventing...*drumroll* Functional Reactive Programming ;)
02:41:23 <shiona> :D
02:41:35 <uiop> lol yes exactly, ":D"
02:42:03 <merijn> Recommended reading: "Functional Reactive Animation" and "Push-Pull FRP" by Conal Elliott
02:42:52 <shiona> Unfortunately I don't have time to study haskell at this time.
02:43:21 <shiona> I did dabble on FRP a tiny bit at some point, maybe I'll continue after I get my shit together at work
02:43:24 <uiop> u must be too busy swimming in rivers
02:43:30 <unclechu> hey guys, can I deduce type for monad by existing typeclass instsance? here is my small example: http://pastebin.com/QgSXCPpU , it's not something real, I just want `continueIf` to deduce its `Left` type as `()`, could I somehow make ghc to do it?
02:44:13 * uiop passes out
02:44:20 <uiop> good bye sweet prince
02:52:31 <maerwald> merijn: we talked about formal methods yesterday. Is there something like PROMELA, but functional-ish?
02:52:52 <merijn> I have no clue what PROMELA is?
02:53:07 <maerwald> the language used to model-check with SPIN
02:53:19 <maerwald> concurrent, distributed systems and whatnot
02:54:15 <merijn> muCRL, based on Mu calculus is used for model-checking distributed/concurrent things and the basic language uses term rewriting which you can see as a very inefficient functional language
02:56:06 <maerwald> seems there is mCRL2 now
03:01:32 <maerwald> merijn: interestingly, in the report you referenced yesterday they don't think "program verification" would add a lot to the quality stack (especially compared to the cost). I wonder if that will change some day with Idris, F* etc
03:02:37 <maerwald> they were on C++ anyway, so the conclusion might be based on that
03:06:10 <thatguy> what is the best way if I have a list of integers up to n and want all integers up to n which are not in that list?
03:09:24 <dramforever> Like a scrolling window?
03:09:28 <dramforever> Uh sorry wrong window
03:09:36 <dramforever> Hmm, 'window'...
03:14:09 <ph88> why do i get this error "Could not decude (Alternative f) arising from a use of '<|>'" ??  https://paste.fedoraproject.org/537534/55155851/
03:14:50 <dramforever> What's a 'Rule'?
03:15:02 <ph88> maerwald, do you know about cake ml ?
03:15:13 <dramforever> ph88:  What's a 'Rule'?
03:15:19 <maerwald> ph88: no, tell me... off to lunch btw
03:15:38 <ph88> dramforever, class Rule f a where   get :: Decorator f => f a
03:16:04 <ph88> maerwald, i didn't try it, just read the website https://cakeml.org/ but since you where talking about formal verification it came to mind
03:16:06 <dramforever> What's a decorator then? Where did you get these typeclasses?
03:16:49 <ph88> dramforever, i made decorator myself with idea from glguy https://paste.fedoraproject.org/537538/51576914/
03:17:23 <dramforever> So 'f' is a parser type right?
03:17:37 <ph88> f is Parser and also Gen for generating arbitrary values
03:17:47 <dramforever> But it doesn't necessarily support alternatives
03:17:50 <ph88> basically this allows me to write the functionality for Parsing and Generating in one go
03:18:19 <ph88> ooooooh
03:18:20 <dramforever> Do you ensure that *all* decorators allow <|>?
03:18:24 <ph88> sorry i see it now
03:18:32 <ph88> i made a special function for that -____-
03:18:45 <dramforever> Hmm, 'c'
03:18:56 <dramforever> You have super concise names
03:18:58 <ph88> i didn't really get that from the error message i was getting
03:19:09 <ph88> you think i should rename some stuff ?
03:19:10 <dramforever> :t (<|>)
03:19:12 <lambdabot> Alternative f => f a -> f a -> f a
03:19:29 <dramforever> ph88: I mean, you literally said 'e stands for element'
03:19:38 <dramforever> just... call that 'element'?
03:19:46 <ph88> yeah the problem is that with Arbitrary i didn't know how to implement <|>
03:19:49 <danza> quick question, hopefully: can anybody point me to some learning material about how `build-depends` works in Cabal? I am trying to reduce redundant dependency declarations in my Cabal files
03:21:10 <danza> i have the cabal user guide in front of me but it does not seem to go very deep about the topic
03:21:24 <dramforever> ph88: This sucks, but you can probably just get an arbitrary Bool and choose between the two
03:21:24 <ph88> dramforever, oneof from this page https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html is what i used instead of <|> so this requires me to use a list
03:21:58 <dramforever> You probably should wrap Gen
03:22:08 <ph88> i mean now i have to input things like  oneof [a,b]  for Arbitrary  and then for parser i get  mplus [a,b]  instead of  a <|> b
03:22:19 <dramforever> :t msum
03:22:22 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
03:22:36 <dramforever> :t (\x y -> msum [x, y])
03:22:38 <lambdabot> MonadPlus m => m a -> m a -> m a
03:22:44 <ph88> eh sorry not mplus   i mean   asum
03:22:48 <ph88> :t asum
03:22:49 <dramforever> :t asum
03:22:50 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
03:22:51 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
03:22:59 <ph88> c = Data.Foldable.asum   <-- taken from my source code
03:23:20 <ph88> dramforever, what do you mean with wrap Gen  ?
03:23:45 <dramforever> Then you can write instance Alternative WrapGen without introducing an orphan instance
03:24:12 <dramforever> An 'orphan' instance is basically 'instance A B' where neither A nor B is in your module
03:24:21 <ph88> dramforever, here you see the implementation of both  https://paste.fedoraproject.org/537556/51622114/  it works pretty well so far
03:24:30 <dramforever> It's bad because you might get horrible collisions
03:24:50 <dramforever> I see
03:24:56 <ph88> what i have now is bad ?
03:25:00 <dramforever> Nothing
03:25:11 <ph88> ???
03:25:14 <zipper> When I'm processing a lazy stream what assurance do I have that what is processed is being garbage collected?
03:25:18 <dramforever> Uhh sorry I think I've gone too far
03:25:22 <zipper> hmmmm maybe I should code it firsy
03:25:25 <zipper> *first
03:25:29 <ph88> ok np ^^
03:25:32 <ph88> thanks for help
03:25:46 <dramforever> ph88: c [Exp <$> emin, Exp <$> eplus]
03:25:58 <dramforever> If you want 'c', how's that?
03:25:58 <Profpatsch> merijn: I’ve now arrived at this http://lpaste.net/351697
03:26:17 <dramforever> Better yet, Exp <$> c [emin, eplus]
03:26:21 <ph88> dramforever, yes i already fixed it :P
03:26:27 <dramforever> :P
03:26:31 <ph88> oh nice one like that
03:26:32 <Profpatsch> Took me a while to get the Maybe’s right in withDom
03:27:04 <dramforever> Hmm
03:27:33 <ph88> dramforever, the thing was that from the error message from ghc it didn't ring a bell that i already implemented a function for this you see
03:28:05 <dramforever> Yeah, I see that after I read the 'Decorator' thing more throughly
03:29:54 <ph88> oh he left :/
03:42:24 <kuribas> Will haskell have dependend types someday?
03:42:49 <Profpatsch> merijn: Hm, when I have a function from the original DOM api that has a callback like foo :: (a -> IO b) -> IO b
03:43:16 <Profpatsch> How would I lift that to fooD :: (a -> Dom b) -> Dom b
03:43:35 <Profpatsch> liftIO of course only gives me (a -> IO b) -> Dom b
03:44:26 <Profpatsch> My idea would be to manually grab the reader Env and put it back together in the callback
03:45:05 <merijn> Profpatsch: You can't really do that, unless you use something like MonadBaseControl, or whatever it's called
03:55:13 <Profpatsch> meh
04:06:13 <ph88> kuribas, i heard they are working towards it
04:06:57 <kuribas> ph88: I've been learning idris.  It'd be nice if they bring it to haskell :)
04:07:03 <ongy> can I give ghc a flag to print all files read during compilation?
04:07:10 <kuribas> ph88: like safe vector acces without bounds checking.
04:07:11 <ph88> kuribas, there is also liquid haskell
04:07:41 <kuribas> ph88: does it work with ghc extensions?
04:08:37 <ph88> don't think so
04:09:12 <ph88> i think you should view it more as a separate compiler which shares like 99% of code with ghc
04:11:07 <ph88> ah no the stuff they added seem to be implemented as comments so i think it's backwards compatible with haskell ^^
04:11:29 <ph88> i type annotated nearly this entire function to get some help from the typechecker, but i'm still getting errors i can't make sense of https://paste.fedoraproject.org/537597/51880114/
04:20:41 <maerwald> kuribas: it's pretty early in development state, although there's a lot of stuff that works already
04:21:01 <maerwald> you can also performance-kill it pretty easily with a few unexpected constructs
04:21:47 <kuribas> maerwald: well, for me the most interesting is using unsafe vector acces, and prove it correct.
04:22:15 <kuribas> And unsafeThaw etc...
04:27:34 <tfc> hi there. i would like to send ICMP ping packets to machines in my network from haskell. i found the Net.ICMP package to construct such packets, but it seems like this needs to be combined with other libraries. i did not find any nice tutorial for that. can someone give me a pointer/
04:29:43 <kvazau> me too
04:32:32 <Bish> ongy maybe try strace :o
04:32:56 <Bish> strace -e open ghc ...
04:33:12 <Bish> will give you all files opened by the process, but not only sourcefiles
04:35:19 <laz> tfc: you'll need Network.Socket 
04:35:39 <ertes> tfc: and you'll need root
04:36:04 <tfc> root? you mean root privileges on the system in order to send icmp packets?
04:36:22 <ertes> tfc: yes (or the capability that lets you send raw packets)
04:36:24 <laz> tfc: or CAP_NET_RAW
04:36:34 <ertes> yeah, that one
04:37:11 <ertes> in portable terms you need to be root
04:37:43 <tfc> i really hoped that i could get around root privileges. so it seems to be more feasible to write code which uses the system's ping application, in order to not need to be root.
04:37:59 <ertes> tfc: yep
04:38:19 <tfc> ok, at least that's not a hard thing to do.
04:38:35 <merijn> Well, you still need root for ping, it's just that the ping command is setuid root :)
04:38:36 <tfc> thank you both for the help!
04:38:45 <ertes> tfc: or split your application into a client and server, such that the server can initialise itself as root
04:38:51 <tfc> yeah, it has setuid and it's reasonably stable.
04:39:03 <tfc> but none of my haskell application code shall run as root or get the S bit
04:39:08 <merijn> :)
04:39:16 <ertes> unlike the ping command the server will only need to be root for a very short amount of time
04:39:52 <tfc> that sounds reasonable, but try to convince my coworkers that my haskell app needs root rights for pinging machines, lol
04:40:08 <merijn> If you just need to ping machines, then no, don't do that :p
04:40:11 <ertes> tfc: that shouldn't be difficult
04:40:35 <tfc> they are not even convinced of haskell, lol 
04:40:38 <ertes> tfc: alternatively: does it have to be ICMP ping?
04:40:59 <tfc> ertes: not really. i need to ping a machine and check its mac address
04:41:19 <Ferdirand> writing hnagios ?
04:41:40 <tfc> my use case is basically: a config file says "machine FOO; IP 123.123.123.123; MAC ab:cd:..." and i need to check if it exists like this.
04:42:15 <Ferdirand> sounds like a job for arping
04:42:47 <ertes> tfc: then any communication will do:  send some arbitrary UDP packet, check the ARP table every second
04:43:01 <LazyUncleBob> Hello, I'm new to Haskell and learning about recursion.
04:43:05 <tfc> ok, sounds like a nice workaround
04:43:07 <liste> hello LazyUncleBob 
04:43:20 <LazyUncleBob> This code example runs forever and never stops, while I specify an edge-condition. Could someone explain me what's going on here?
04:43:21 <LazyUncleBob> https://hasteb.in/zudutohamo.coffee
04:43:34 <ertes> tfc: or even use something like arping
04:43:44 <asthasr_> LazyUncleBob: you're already lazy, so...
04:43:49 <LazyUncleBob> I am! haha
04:43:56 <LazyUncleBob> Exactly why I chose to learn Haskell :)
04:44:14 <asthasr_> are you "the" Uncle Bob?
04:44:18 <liste> LazyUncleBob: that piece of code has no recursion
04:44:23 <LazyUncleBob> Depends if you're talking about me.
04:44:29 <tfc> ertes is this there is a library for or do i need to assemble stuff for that myself?
04:44:29 <LazyUncleBob> Oh wait, dangit, I left out a bit.
04:44:33 <LazyUncleBob> Excuse me, I'll fix it.
04:44:41 <LazyUncleBob> What a way to make a first impression.
04:44:49 <ertes> tfc: you use the command line program 'arping'
04:45:07 <LazyUncleBob> Hereby my corrected version: https://hasteb.in/janayopoye.coffee
04:45:07 <maerwald> ertes: did you see my question from yesterday or something?
04:45:14 <tfc> ertes: ok, but then i would prefer ping because it's preinstalled for sure, while arping is not.
04:45:29 <ertes> maerwald: yeah, i've answered it
04:45:57 <maerwald> meh, then my log replay is broken
04:46:11 <ertes> [17:04:51] <ertes> maerwald: i have barely touched memory safety with haskell…  all i can say right now is that it's difficult, even if limit yourself to Storable operations…  i believe that GHC-side support is necessary to fix this
04:46:12 <ertes> [17:05:08] <ertes> maerwald: alternatively make sure that GHC never gets to see the data by FFIing into C
04:46:18 <ertes> [17:07:20] <ertes> but even then, say in a crypto setting, GHC gets a hold of plaintext first, before it passes it on to C, so there is potential for data leakage, too
04:46:18 <ertes>  
04:46:36 <LazyUncleBob> The piece of code I linked effectively freezes my system, since it never stops running.
04:46:41 <maerwald> ertes: thanks
04:46:43 <LazyUncleBob> Which sucks.
04:46:59 <maerwald> well, I'd say we should call this "memory security" in fact
04:47:25 <ertes> tfc: in that case don't use ping…  send a UDP packet
04:47:48 <tfc> ertes yeah looks like that will do. thank you for the input.
04:47:52 <asthasr_> it works fine on mine, LazyUncleBob 
04:47:57 <asthasr_> what number are you using for input
04:48:02 <LazyUncleBob> 1.
04:48:17 <liste> LazyUncleBob: works for me at least, what are you testing it with? https://ideone.com/LjI5jv
04:48:20 <asthasr_> yep, it works fine
04:48:34 <LazyUncleBob> Okay.. I'm using ghci, really.
04:48:47 <LazyUncleBob> With the "prelude>" thingy.
04:49:12 <asthasr_> a minor style point, LazyUncleBob -- instead of calling your type variable 'bigInt,' it's idiomatic to say "a." so your signature could look like (Integral a) => a -> a
04:49:34 <asthasr_> then, of course, use something different for your argument, like n.
04:49:39 <LazyUncleBob> Right, okay, thank you.
04:49:50 <asthasr_> can you copy and paste your GHCI session?
04:49:52 <ertes> LazyUncleBob: did you load a source file or type the function by hand?
04:50:03 <LazyUncleBob> I mean, I've re-ran it now
04:50:06 <LazyUncleBob> and it does infact work.
04:50:17 <LazyUncleBob> Previously this literally froze my system.
04:50:38 <Profpatsch> merijn: I’ve solved my callback problem with this function:
04:50:42 <LazyUncleBob> I'm flabbergasted.
04:50:57 <Profpatsch> withDomEnv :: DomEnv -> Dom a -> IO a
04:50:59 <Profpatsch> withDomEnv e d = (runReaderT $ runDom d) e
04:51:26 <asthasr_> LazyUncleBob: We are magic
04:51:45 <asthasr_> Most likely, you had a typo when you entered it before. If your terminal condition is not right, then recursion will fail to end
04:52:01 <ertes> @bot feature request: copy pastes from JS-only pastebins to lpaste.net
04:52:01 <lambdabot> :)
04:52:19 <asthasr_> for example, leaving out the "0 = 1" case in a recursive definition of a factorial
04:52:47 <asthasr_> and yeah, hastebin (although it has a nice interface) is kind of buggy and unreliable, so I'd recommend using lpaste.net
04:53:42 <merijn> Nice interface == usually doesn't load for me? :p
04:54:42 <ertes> even a nice-interface pastebin can work without JS
04:54:49 <ertes> it's just less nice without it
04:55:10 <hpc> lpaste has a nicer interface
04:55:12 <hpc> imo
04:55:20 <hpc> nicest of any pastebin i have used
04:56:00 <ertes> lpaste feature request: make hlint optional AND DISABLED BY DEFAULT
04:56:05 <maerwald> ertes++
04:57:07 <maerwald> but guess what... chrisdone has disabled the issue tracker, no surprise
04:57:57 <ertes> really?  that's odd
04:58:29 <maerwald> I once opened a similar bug complaining about hlint stuff that was outright wrong
05:00:31 <thatguy> I have a list of some integers up to n L, and I want to have all integers up to n excluding the ones in L (so the complement in some sense)
05:00:34 <thatguy> how do I do that
05:01:19 <Ferdirand> > [1..10] \\ [2,7]
05:01:19 <ertes> thatguy: is the list sorted?
05:01:21 <lambdabot>  [1,3,4,5,6,8,9,10]
05:01:30 <thatguy> ertes, yes
05:01:37 <thatguy> Ferdirand, isn't that very ineffective
05:01:42 <thatguy> if the list is sorted
05:01:45 <thatguy> which I forgot to say
05:01:48 <Ferdirand> yes, but you didn't say it was
05:01:57 <ertes> thatguy: wait, do you need complement or difference?
05:02:01 <ertes> (\\) is difference
05:02:35 <thatguy> I need exactly the result Ferdirand got but I hoped there is a more effective way
05:02:40 <thatguy> Ferdirand, yes sorry I forgot
05:02:48 <merijn> argh...
05:02:54 <ertes> thatguy: then use Set
05:03:05 <merijn> It's "I minorly changed my code and now Conduit is all upset at my types" o clock :\
05:03:17 <hpc> merijn: try turning it off and on again
05:03:28 <ertes> merijn: switch to pipes already ;)
05:03:45 <merijn> ertes: That'd mean I'd have to port all libraries
05:04:19 <hpc> thatguy: you can write it in O(n) time if you do it yourself
05:04:34 <ertes> yeah, that's exactly what you should do, because then i could get closer to getting rid of conduit, too ;)
05:04:59 <hpc> thatguy: traverse both the complete list and the list you're subtracting
05:05:04 <merijn> ertes: tbh, pipes give me the same shit
05:05:27 <merijn> ertes: Where I end up having to chase type errors for hours when I change something small
05:05:33 <hpc> thatguy: and only step further into one of the lists if its head element is less than the other's head element
05:05:58 <thatguy> hpc, yeah thanks
05:06:21 <merijn> Like...wtf?
05:06:23 <merijn>     Couldn't match type ‘ConduitM Event o0 SqlM (Maybe ())’
05:06:23 <merijn>                    with ‘forall o. ConduitM Event o SqlM (Maybe a0)’
05:06:23 <merijn>     Expected type: Consumer Event SqlM (Maybe a0)
05:06:23 <merijn>       Actual type: ConduitM Event o0 SqlM (Maybe ())
05:06:31 <merijn> How do those not match?!?
05:06:35 <merijn> WTF is wrong with you?!
05:06:47 <hpc> merijn: it's not a higher-ranked type, is it?
05:07:04 <merijn> Consumer is rank 2
05:07:22 <merijn> hpc: I've tried adding an explicit free type variable too, but that doesn't work either
05:07:29 <hpc> hmm
05:07:39 <ertes> merijn: i'm assuming that o0 comes from the context, whereas you need to supply a polymorphic function?
05:07:59 <merijn> ertes: The point is that I'm never emitting any output
05:08:12 <merijn> I want my thing to be a Sink, but I can't figure out how to make that typecheck
05:09:24 <ertes> well, pipes uses Void there, which avoids errors like this, especially with MR
05:09:39 <mniip> merijn, it looks like o0 is skolem
05:09:56 <mniip> and you expect it to be universally quantified
05:10:03 <merijn> ertes: No, because when I put in Void it doesn't work either!
05:10:07 <mniip> however I can't tell for sure from the types involved
05:11:21 <merijn> ertes: Then I just "can't match 'ConduitM Event Void SqlM (Maybe ())' instead of the free type variable
05:11:50 <ertes> ah, conduit does that, too…  nevermind
05:13:17 <ertes> merijn: so you're using a function that expects a Consumer, but you (want to) have a Sink?
05:14:31 <merijn> I have a function "skipMany :: MonadThrow m => Consumer Event m (Maybe a) -> Consumer Event m ()" that I'm passing something too but it can't seem to live with that...
05:14:48 <ertes> merijn: in that case you need to use toConsumer
05:15:03 <ertes> if you have a Sink
05:15:20 <merijn> I don't have a Sink, I think?
05:15:25 <merijn> I'm not sure what I have
05:15:28 <jophish> Is there a table somewhere of all the GHC language extensions with the version they were introduced?
05:15:29 <ertes> you want to have one
05:15:36 <jophish> yes
05:15:51 <ertes> merijn: so have one and use toConsumer =)
05:16:11 <ertes> jophish: the GHC manual includes version numbers
05:19:46 <merijn> ertes: Nope...stuffed a toConsumer in there, still no cigar
05:21:05 <merijn> I can't easily paste this code either as it depends on an unreleased version of xml-conduit >.>
05:23:28 <chpatrick> what's the easiest way to make a derivation that's just a collection of packages?
05:23:29 <merijn> ertes: Ok, so if I replace the offending bit with a hole, I get a hole for "Consumer Event SqlM (Maybe a)", and what I need to fit in there is 'Sink Event SqlM (Maybe ())', which seems like it *should* be trivial
05:23:38 <chpatrick> oops meant #nix :)
05:24:12 <merijn> Logically you'd expect 'toConsumer' to work, but if I replace the hole with 'toConsumer _' I get a type error too
05:25:08 <jophish> ah, didn't spot it in there. Thanks ertes!
05:25:21 <merijn> I'm just at a complete loss WTF is going on here...
05:26:52 <kuribas> is there a kind for constrained type variables?
05:27:20 <kuribas> for example Ord a => a -> * 
05:27:41 <merijn> No, only a kind for constraints themselves
05:27:50 <merijn> ertes, mniip: Any idea/suggestions?
05:28:39 <mniip> sorry I have no idea about the context
05:30:33 <merijn> mniip: https://gist.github.com/merijn/90aaee65aa09079314f8634d9412351d on line 207 it claims 'item' doesn't typecheck
05:30:55 <merijn> But I have no clue why the hell it wouldn't...
05:31:01 <thatguy> this code takes two lists, one of which is a subset of the other and both are sorted and makes the difference: http://lpaste.net/351699 can anyone tell me if I programmed it good or if there are things to do better?
05:31:11 <thatguy> hpc, it is the algorithm you described to me
05:31:47 <mniip> merijn, oh my that's huge
05:32:32 <merijn> mniip: Yeah, but I have no idea how to minimize this issue
05:33:09 <merijn> It was all working before I decided to "simplify" things and I can't figure out which change broke it
05:33:30 <tabaqui1> does anybody know - is Data.Map persistent object?
05:33:38 <tabaqui1> I mean, if insert new value in it
05:33:48 <tabaqui1> it takes new O(n) memory in heap?
05:33:59 <merijn> tabaqui1: No, because it reuses parts of the old map
05:34:25 <tabaqui1> merijn: Is it true for any pure object in haskell?
05:35:01 <tabaqui1> if I fondly create my own tree, it will be perisitent?
05:35:16 <merijn> Define "persistent"
05:35:32 <dramforever> shared?
05:35:34 <dramforever> Of course yes
05:35:58 <tdammers> if you create your own tree, all the parent-child relationships will be implemented by reference, so if you add things to an existing tree, the new tree will share most of the data with the old one
05:36:00 <dramforever> tabaqui: You want to have the two trees to share a 'leg' right?
05:36:31 <tabaqui1> merijn: I'll try, but sorry for my english
05:36:54 <dramforever> tabaqui: Do you do competitive programming?
05:36:55 <tabaqui1> tdammers and dramforever: yeas, right
05:37:00 <tabaqui1> wait a sec
05:37:18 <dramforever> There's no need to copy, *because* we can't change them
05:37:36 <dramforever> makes sense to you?
05:39:27 <merijn> *head desk*
05:39:35 <merijn> Jesus Christ, why is this so impossible
05:39:36 <tabaqui1> merijn: persistent means that in any time, I can recover previous versions of object and any datum is keeped in one copy
05:40:14 <dramforever> Ah, that's classic
05:40:29 <tabaqui1> dramforever: yeah, but if I have "a = [1,2,3], b = 4:a, c = 5:a"
05:40:35 <dramforever> tabaqui: Yes, if you make your own trees and store them it will work
05:40:38 <tabaqui1> I want to allocate only 5 integers in memory
05:40:47 <dramforever> tabaqui: Yes!
05:41:00 <dramforever> It would be like, uh I can't draw in IRC, wait a sec
05:41:18 <tabaqui1> I know how to write peristent deck
05:41:22 <dramforever> I'll do a text version
05:41:45 <cfoch> Hi, carter 
05:41:46 <tabaqui1> but I don't know how haskell could do it for arbitrary data
05:41:53 <cfoch> are you still using NixOS?
05:42:02 <dramforever> tabaqui: by not copying
05:42:20 <carter> Who dat?  I was never using nix
05:43:30 <cfoch> I don't remember who was using it
05:43:44 <cfoch> But someone here was using NixOS
05:43:58 <dramforever> tabaqui: http://imgur.com/OwEDZXJ
05:43:59 <cfoch> 2 years ago I think
05:44:20 <tabaqui1> dramforever: yeah, persistent stack
05:44:40 <buglebud_> i'm trying to configure my hakyll site by saying if a certain word is in the metadata then add a script tag, but i'm getting a type error saying that type Metadata is not a Map, but is it in the documentation http://lpaste.net/351700.... documentation: https://jaspervdj.be/hakyll/reference/Hakyll-Core-Metadata.html
05:45:10 <buglebud_> but it is*
05:45:11 <tabaqui1> it's not so easy with persistent fifo, and I'm not sure that possible with any algebraic structres
05:45:12 <dramforever> tabaqui: Hmm... Does 'Constructors really just take pointers' make sense to you?
05:45:45 <dramforever> I keep saying if you make your own *tree* it would work
05:46:08 <dramforever> but it's going to take forever to draw tree
05:46:19 <tabaqui1> dramforever: well, my ghost wisphers that it's really possible
05:46:42 <tabaqui1> so I trust ghc for now
05:46:44 <tabaqui1> thank you
05:46:57 <dramforever> tabaqui1: How would you 'normally' make a persistent structure?
05:47:00 <tabaqui1> *whispers
05:47:39 <tabaqui1> dramforever: after each change put some "tag" in each node
05:48:11 <dramforever> Hmm looks like Haskell isn't that normal
05:48:15 <merijn> mniip: I literally can't even get a hole with a type signature to typecheck :\
05:48:26 <tabaqui1> so new versions could recover whole structure starting from the end
05:48:43 <tabaqui1> and read tags placed for it and it's parents
05:50:35 <dramforever> I don't think that's what Haskell does
05:50:53 <dramforever> Does that image make sense to you?
05:51:14 <ertes> merijn: sorry, i have no idea
05:51:16 <dramforever> a b c are the three variables
05:51:29 <dramforever> and we've got a linked list from each variable down
05:51:32 <ertes> merijn: the only thing that made sense to me was the toConsumer thing
05:51:37 <dramforever> but they really share a nice part of it
05:52:10 <merijn> ertes: Well, looks like GHC is fucking up in a spectacular fashion
05:52:33 <jophish> merijn: what's up?
05:52:46 <merijn> I moved part into a where clause with explicit signature and now it compiles just fine...
05:52:57 <dramforever> Oh wait, someone's already drawn a tree here: https://en.wikipedia.org/wiki/Persistent_data_structure#Trees
05:53:18 <merijn> I knew that code was trivially correct...
05:53:20 <dramforever> tabaqui1: *This* is how sharing in Haskell works, basically
05:53:45 <dramforever> https://en.wikipedia.org/wiki/Persistent_data_structure#Trees
05:54:40 <merijn> ertes, jophish: Looks like I've fallen victim to annoying RankN type aliases in conduit
05:55:08 <merijn> If I change "foo . skipMany $ item" to "foo $ skipMany item" it compiles just fine
05:55:19 <athan> What are the "key field" and "id field" in ghc-pkg? Are those something to do with semvars?
05:56:01 <dramforever> merijn: GHC can't instantiate a type variable with a 'forall' type
05:56:18 <dramforever> So... I suppose that's what happening with (.) there
05:56:25 <tabaqui1> dramforever: O(log n) additional memory
05:56:56 <dramforever> Yeah
05:57:22 <merijn> Welp...
05:57:29 <merijn> That's 2 hours of my life I will never get back
05:58:08 <tabaqui1> btw
05:58:38 <tabaqui1> if I have "infixl 5 @" and "infixr 5 $"
05:58:50 <tabaqui1> in which order will evaluated
05:58:52 <dramforever> btw, were you talking about this fat node thing? https://en.wikipedia.org/wiki/Persistent_data_structure#Fat_node
05:58:56 <tabaqui1> 1 @ 2 $ 3
05:58:59 <tabaqui1> ?
05:58:59 <merijn> tabaqui1: You can't mix those
05:59:03 <merijn> tabaqui1: Parse error
05:59:09 <dramforever> tabaqui: that's a parse error
05:59:15 <dramforever> How about we try that?
05:59:50 <tabaqui1> dramforever: I hope, that someone knows exactly :)
06:00:02 <dramforever> How exactly?
06:00:18 <quchen> ?let infixA = undefined
06:00:20 <lambdabot>  Defined.
06:00:23 <quchen> ?let infixB = undefined
06:00:28 <lambdabot>  Defined.
06:00:29 <tabaqui1> without starting ghci
06:00:34 <quchen> ?let infixl 5 infixA
06:00:34 <lambdabot>  Parse failed: Parse error: infixA
06:00:37 <dramforever> Yes, I know it's a parse error
06:00:38 <quchen> Aww. :-(
06:00:45 <tabaqui1> that's it
06:00:51 <tabaqui1> thx)
06:00:53 <quchen> ?undef
06:00:53 <lambdabot> Undefined.
06:00:59 <dramforever> quchen's wasn't it
06:01:21 <quchen> Lambdabot can’t define fixities it seems
06:01:24 <dramforever> It would be (literally) 'can't mix' infixl 5 @ and infixr 5 $
06:01:41 <jophish> merijn: what was the warning GHC gave. It's often pretty good at saying "Ahhh! ImpredictiveTypes"
06:02:56 <merijn> jophish: This one: Couldn't match type ‘ConduitM Event o0 SqlM (Maybe ())’
06:02:56 <merijn>                with ‘forall o. ConduitM Event o SqlM (Maybe a0)’
06:02:56 <merijn> Expected type: Consumer Event SqlM (Maybe a0)
06:02:56 <merijn>   Actual type: ConduitM Event o0 SqlM (Maybe ())
06:02:56 <dramforever> tabaqui1: ^ That's an example
06:03:23 <dramforever> GHC usually gives pretty long error messages
06:03:44 <dramforever> I don't really remember them exactly...
06:04:01 <dramforever> But I'm not sure you'll be happy with 
06:04:07 <merijn> dramforever: "pretty long errors" <- wut?
06:04:18 <merijn> dramforever: Clearly you've not programmed C++ if you consider GHC errors long
06:04:28 <dramforever> with 'it's a parse error' or 'Ahhh! ImpredicativeTypes'
06:04:41 <dramforever> merijn: Uh, that's a whole different thing
06:04:53 <dramforever> C++ template error messages are not for mortals to read
06:05:01 <merijn> I've had errors longer than my terminal scroll history >.<
06:06:10 <dramforever> I set up my gnome-terminal so that it has infinite history
06:06:16 <dramforever> (FSVO infinite)
06:06:18 <jophish> Ooh, that's annoying merijn. Is it worth filing a ghc bug?
06:06:45 <ertes> merijn: consider it an exchange: you paid two hours to save hundreds of hours in the future =)
06:06:46 <quchen_> Hah, got it. Forgot the backticks for infix fixities.
06:06:50 <quchen_> ?let infixA = undefined
06:06:50 <quchen_> ?let infixl 5 `infixA`
06:06:51 <lambdabot>  Defined.
06:06:52 <quchen_> ?let infixB = undefined
06:06:53 <lambdabot>  Defined.
06:06:54 <quchen_> ?let infixr 5 `infixB`
06:06:54 <lambdabot>  Defined.
06:06:56 <quchen_> :t \x y z -> x `infixA` y `infixB` z
06:06:56 <lambdabot>  Defined.
06:06:58 <lambdabot> t -> t2 -> t3 -> t1
06:07:05 <dramforever> huh?
06:07:06 <quchen_> Wat.
06:07:09 <dramforever> Wat
06:07:12 <quchen_> That gave me an error in the private session.
06:07:28 <quchen_> 15 seconds ago.
06:07:32 <quchen_> !??!
06:07:37 <dramforever> Let's do it again
06:07:58 <quchen_> :t \x y z -> x `infixA` y `infixB` z
06:08:00 <lambdabot> error:
06:08:01 <lambdabot>     Precedence parsing error
06:08:01 <lambdabot>         cannot mix ‘infixA’ [infixl 5] and ‘infixB’ [infixr 5] in the same infix expression
06:08:05 <quchen_> Uhmmmm
06:08:15 <quchen_> :t \x y z -> x `infixA` y `infixB` z
06:08:18 <lambdabot> error:
06:08:18 <lambdabot>     Precedence parsing error
06:08:18 <lambdabot>         cannot mix ‘infixA’ [infixl 5] and ‘infixB’ [infixr 5] in the same infix expression
06:08:22 <dramforever> Could be a race condition or something
06:08:22 <quchen_> OOkkaaay.
06:08:26 <quchen_> Yeah maybe.
06:08:33 <quchen_> Anyway, that’s the error I wanted.
06:08:44 <dramforever> tabaqui1: I can't really recite *that*, you see...
06:09:01 <tabaqui1> yep
06:09:05 <dramforever> But GHCi *always* knows the exact error message
06:12:54 <merijn> And now on to simpler Haskell issues, like: How do you guys deal with linewrapping of long pipelines of function composition
06:13:21 <jophish> merijn: break before the operators, line up the .'s and $'s vertically
06:13:39 * dramforever puts the dots on the left edge and lines them up
06:14:28 <dramforever> Basically like how you write multi-line {;;;;;;;} lists
06:15:07 <dramforever> Arguments for that: lining operators on the left side allows one to scan through the left edge and see the outmost structure
06:16:55 <merijn> jophish: That wastes so many lines, though :\
06:19:03 <jophish> merijn: break your pipeline up into two or three smaller pipelines in a let or where?
06:19:13 <jophish> that's sometimes easier said than done
06:19:52 <merijn> Basically this is what I have: http://lpaste.net/5818896029914759168
06:21:25 <Profpatsch> :exf a -> b -> c -> a
06:21:25 <exferenceBot> parse error: more than one input
06:21:36 <Profpatsch> :exf test :: a -> b -> c -> a
06:21:37 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 6) "Parse error: ::"
06:21:54 <Profpatsch> :exf a -> b -> a
06:21:54 <exferenceBot> parse error: more than one input
06:21:59 <Profpatsch> :exf  a
06:22:10 <Profpatsch> hm
06:22:46 <exferenceBot> could not find expression
06:23:05 <bwe> > fromIntegral $ 3/1 :: Rational  -- how can I make a Rational into an Integer?
06:23:08 <lambdabot>  error:
06:23:08 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘fromIntegral’
06:23:08 <lambdabot>        prevents the constraint ‘(Integral a0)’ from being solved.
06:23:31 <merijn> :t round -- ?
06:23:33 <dramforever> round floor ceil
06:23:33 <lambdabot> (RealFrac a, Integral b) => a -> b
06:23:34 <dramforever> chose one
06:23:36 <dramforever> *choose
06:24:02 <dramforever> > floor $ (3/1 :: Rational) -- Let's hope for the best
06:24:05 <lambdabot>  3
06:24:15 <merijn> dramforever: FYI
06:24:17 <merijn> :t (%)
06:24:19 <lambdabot> Integral a => a -> a -> Ratio a
06:24:30 <merijn> > floor $ (3%1)
06:24:33 <lambdabot>  3
06:24:36 <dramforever> I 'like' (/)
06:24:46 <dramforever> And it's not like it's inexact or anything...
06:25:10 <merijn> dramforever: Naah, but I hate having to type Rational as annotation :p
06:25:27 <dramforever> Uh, you know, I was just trying to imitate the original coee
06:25:29 <dramforever> *code
06:25:37 <dramforever> where original =def= bwe's
06:26:24 <bwe> dramforever: Thanks, have it working now.
06:31:36 <saurabhnanda> anyone know how to use PackageImports properly? http://stackoverflow.com/questions/41896211/how-to-use-packageimports-extension-to-shadow-a-module
06:32:24 <merijn> saurabhnanda: Why do you need it?
06:33:08 <merijn> Doing that will force every user of your library to use packageimports
06:35:55 <saurabhnanda> is it?
06:36:35 <saurabhnanda> merijn: if my library's user simply puts "instrumentedscotty" in the cabal file, and imports the same old `Web.Scotty.Trans` it'll work, right?
06:36:59 <saurabhnanda> that's the idea -- minimal amount of code change to use instrumented versions of certain libraries
06:37:38 <merijn> saurabhnanda: No
06:37:58 <merijn> saurabhnanda: They will have to change their imports to use packageimports to use your package if the module name clashes
06:38:02 <dramforever> Snoyman said no: http://www.snoyman.com/blog/2017/01/conflicting-module-names
06:38:55 <saurabhnanda> merijn: but they'll change `scotty` to `instrumentedscotty` -- not depend on BOTH in the cabal file.
06:39:48 <saurabhnanda> dramforever: Snoyman has not thought of my sexy use-case
06:40:06 <dramforever> More like 'he has other concerns'
06:40:23 <saurabhnanda> Use case: For someone using a library X make instrumentedX available. So, simply by changing X to instrumentedX in their cabal file, they can use the instrumented version of the library -- without any other change in code.
06:41:15 <saurabhnanda> merijn: if only instrumentedX is present in cabal file, even then will library users need to depend on PackageImports?
06:41:26 <merijn> I don't know for sure
06:42:53 <saurabhnanda> is there a way to find out who authored the PackageImports extension?
06:44:40 <saurabhnanda> a-ha : https://ghc.haskell.org/trac/ghc/ticket/13168
06:47:27 <ertes> merijn: i just view (.) as punctuation:  "f .\ng .\nh . \ni $ x"
06:48:25 <bennofs1> let a = [ ps !! 0, ps !! 1, ps !! 2, ps !! 3, ps !! 4 ]  and 'let a = take 5 ps' should be exactly equal, right???? (if length a >= 5)
06:48:46 <bennofs1> eh length ps >= 5
06:49:44 <pavonia> bennofs1: The fisrt one fails if the list is too short
06:50:00 <lpaste> bennofs pasted “Am I overlooking some typo” at http://lpaste.net/351704
06:50:13 <bennofs1> pavonia: yeah, that's why I said length ps >= 5
06:50:16 <ertes> and yes, i view lines starting with punctuation as a plague that needs to be wiped off this planet…  every line that starts with a comma is a declaration of war to the land of aesthetics
06:50:44 <bennofs1> Please, can anyone tell me that I'm missing something really dumb in http://lpaste.net/351704?
06:51:07 <bennofs1> Both a and take 5 ps :: [Node]
06:51:23 <MarcelineVQ> ertes: isn't it a compromise to create more readable diffs
06:51:47 <bennofs1> If I'm not making some mistake, then this means that somehow, parseValue observes the difference between two equal values...
06:52:03 <merijn> bennofs1: Print both values after show
06:52:09 <merijn> bennofs1: Are they rendering the same?
06:52:16 <ertes> MarcelineVQ: it would be, if it were true…  you're just moving the singularity from the bottom to the top
06:52:52 <bennofs1> merijn: λ: show (Project (take 5 ps)) == show (Project a)
06:52:57 <bennofs1> merijn: prints True...
06:53:09 <MarcelineVQ> ertes: I'm not sure what you mean
06:53:42 <merijn> bennofs1: odd...
06:53:51 <bennofs1> MarcelineVQ: and if I assign both shown values to a variable, then parseValue returns Nothing in both cases...
06:53:55 <ertes> MarcelineVQ: example with list syntax:  a,\nb,\nc  -- last line is a singularity (missing comma)
06:54:15 <bennofs1> merijn: so either ghc has a bug, or this library that parseValue comes from is doing something shady
06:54:24 <ertes> MarcelineVQ: \ \ a\n, b\n, c  -- first line is a singularity
06:54:38 <merijn> Start a new session and try again?
06:54:44 <bennofs1> merijn: btw, the bug appears to only be triggered if building dynamically linked executables or from GHCi
06:54:51 <MarcelineVQ> ertes: if the the first line is [ and the last line is ] that isn't an issue right?
06:55:40 <ertes> MarcelineVQ: you mean like:  [ a\n, b\n, c\n]  -- ?
06:55:44 <MarcelineVQ> my issue I mean a factor in a messy diff
06:55:58 <ertes> or [] on separate lines?
06:57:02 <MarcelineVQ> [ and ] on their own lines, allthough now that I've said it that's not super relevant since it allows both comma styles
06:57:07 <bennofs1> merijn: look at http://lpaste.net/351705. I'm not blind and missing some silly typo, am I?
06:57:46 <merijn> bennofs1: Not that I can see?
06:58:05 <ertes> MarcelineVQ: correct…  in fact i generally use a compact style with two singularities:  [ a\n … \n  z ]  -- because i believe source code should always be optimised for humans, not for tools
06:58:31 <bennofs1> merijn: ok so this is indeed as strange as it seems to be. Thanks, just wanted to make really sure that this isn't some typo bug before I start investigating in that direction :)
06:58:46 <ertes> (add a missing comma there)
06:59:04 <pavonia> bennofs1: That show is the standard show?
06:59:17 <dramforever> What if you do 'parseValue (show p1)' twice?
06:59:51 <MarcelineVQ> bennofs1: Do you have a complete example people could try?
07:01:38 <bennofs1> MarcelineVQ: working on it
07:01:41 <bennofs1> pavonia: yes, should be
07:01:58 <MarcelineVQ> also what exactly is the issue? two lists both 'show'n don't parse the same?
07:02:25 <dramforever> but the 'show'n strings compare equal
07:02:26 <bennofs1> MarcelineVQ: two Strings which are equal don't parse the same
07:02:40 <bennofs1> also, the list should be equal
07:07:23 <infandum> Do you know what's silly? If I pass a (large) json string from haskell to R using haskellR and process it using jsonlite I get a sigsegv. If I first write it to a file, then use jsonlite on the file then it works. :(
07:08:43 <bennofs1> MarcelineVQ: not quite standalone, but checkout https://github.com/bennofs/docvim/tree/weird. Run `stack build`, followed by `stack exec runhaskell Test.hs`
07:20:06 <MarcelineVQ> well then... if you want to see somehting really interesting try parsing ps as well and reandomising the order you do the parses in
07:21:54 <bennofs1> MarcelineVQ: yeah I found that this is nondeterministic
07:21:55 <MarcelineVQ> just parsing p1 8 times in a row gives you different results, something is wicked off
07:59:50 <nitrix> What is the best material one would recommend to learn about the free monad, data Fix and related contraptions?
08:02:05 <reactormonk> nitrix, if you're fine with some scala, I learned a lot from https://www.youtube.com/watch?v=rBmx9NsNSXM
08:04:42 <jophish> nitrix: Trying to use them might be a good way of learning, if you have a good usecase
08:11:55 <nitrix> Are haskell functors all endofunctors; or are there functors across different categories as well?
08:14:27 <nitrix> For one, I'm only aware of the Hask category and, as of lately, heard about the End(Hask) category, but I'd really like an overview of all it all connects.
08:14:41 <nitrix> s/of all/of how/
08:14:55 <lpaste> simli pasted “cereal-conduit confusion” at http://lpaste.net/351711
08:15:22 <unclechu> hey guys, where I can read about how to parse output from subprocess line by line?
08:16:13 <simli> my pasted uncommented version hangs forever (seemingly...), while the commented version utilizing my knowledge of the message length works as expected. What could I be missing?
08:16:16 <unclechu> is there any tutorials or something like that? i waste a lot of time for 'process' package but can't do what I want
08:18:15 <qmm> anyone have a coding challenge that should only take about 10 mins?
08:18:56 <simli> let me know if my paste is lacking detail, I suspect it's some misunderstanding on my part, so I didn't spend the time to make it a complete example
08:19:21 <simli> a *simple* misunderstanding, that is :)
08:20:52 <simli> qmm, perhaps https://adventofcode.com/2016/day/1 (I haven't looked super closely myself so not 100% on time req :P)
08:25:58 <sena_kun> hi, folks! Anyone who has experience with liquidhaskell? I have a little issue and don't know is it should be bug-reported or I'm just stupid.
08:31:41 <ph88> i type annotated nearly this entire function to get some help from the typechecker, but i'm still getting errors i can't make sense of https://paste.fedoraproject.org/537597/51880114/
08:33:50 <byorgey> ph88: what monad is the inner do-block supposed to use?
08:34:41 <ph88> the same as the outer monad
08:34:55 <sena_kun> I've submited a bug already, so nevermind me.
08:35:00 <byorgey> OK, but you're applying 'fromMaybe ""' to it, which means it has to be Maybe.
08:35:08 <byorgey> did you mean  fromMaybe "" <$>  ?
08:35:16 <ph88> ooh .. maybe
08:35:16 <ph88> lol
08:35:23 <ph88> jusjt a mometn
08:36:51 <ph88> byorgey, oh thank you, looks like that cleared up 2 of the 3 errors !
08:36:57 <ph88> i just .. couldn't see it
08:37:02 <byorgey> great =)  glad to help
08:37:04 <ph88> how did you notice that was it ?
08:37:30 <byorgey> I dunno, I just started looking at the code and trying to figure out what types different things were
08:37:38 <byorgey> it probably helped that I have no idea what the code is doing
08:37:59 <byorgey> so I don't know what the types are *supposed 
08:38:07 <byorgey> *supposed* to be, I just have to figure out what they *are*
08:47:09 <Rodenbach> In the Input/Output chapter of Learn You A Haskell a function   reverseWords = unwords . map reverse . words   is shown.  Why is the author not simply calling the  reverse  function?
08:49:06 <MarcelineVQ> they're a little different, reverse would reverse the entire line, what the above does is reverse each seperate word in a line
08:49:27 <MarcelineVQ> > (unwords . map reverse . words) "oh my goodness"
08:49:29 <lambdabot>  "ho ym ssendoog"
08:49:34 <MarcelineVQ> > reverse "oh my goodness"
08:49:37 <lambdabot>  "ssendoog ym ho"
08:51:38 <Rodenbach> MarcelineVQ: true, makes sense, thx
08:56:06 <ph88> byorgey, i have another question about nearly the same code, is that ok ?
09:19:32 <pavel> Hello everyone
09:20:15 <pavel> I've got a problem with understanding function composition 
09:21:36 <ph88> sup pavel 
09:22:00 <dfeuer> edwardk: yes, Data.Set is missing
09:23:19 <dfeuer> edwardk: yes, Data.Set is missing alterF. And I would like to add it. With apologies to lens, it will be Bool rather than Maybe ().
09:32:04 <bennofs1> Ok, I've simplified my problem from before. Run https://gist.github.com/bennofs/b97dbd484f8598b3347304ee9c4c2a79 (requires pretty-show haskell package) with runhaskell, and you'll be surprised: it outputs "Nothing" and "Just" mixed
09:34:26 <ph88> bennofs1, Just should have a value
09:35:29 <bennofs1> ph88: I'm not interested in the value in this case
09:35:39 <bennofs1> ph88: this program should print only 'Nothing' or only 'Just'
09:35:45 <bennofs1> ph88: the problem is, it prints *both*
09:37:43 <bennofs1> can happy generate parsers that have non-deterministic behavior?
09:40:21 <bennofs1> I'm quite convinced that this is a ghc bug now
09:40:28 <ph88> ill test it
09:40:43 <bennofs1> there's no unsafe function in any of the involved functions i believe
09:43:36 <ph88> bennofs1, i also get Just and Nothing
09:44:06 <pavonia> bennofs1: It indeed seems to be a GHC bug: https://github.com/yav/pretty-show/issues/21
09:45:14 <bennofs1> pavonia: oh, thanks for digging that one up! that saves me quite some time
09:49:19 <ph88> looks like it will land in 8.0.2 i was testing with 8.0.1
09:50:01 <Kristof_HT> what was the name of haskell channwl for beginners?
09:50:12 <ph88> #haskell-beginners
09:50:13 <EvanR> #haskell
09:50:21 <Kristof_HT> thank you
09:50:22 <EvanR> or that
09:51:13 <ph88> so i have this piece of code  https://paste.fedoraproject.org/537782/48553613/  and i intended f on line 30 to be the same f as on line 10, but ghc is not having it. What am i doing wrong ?
09:52:24 <srhb> Kristof_HT: Plainly, the topics are often advanced in #haskell-beginners and not in #haskell -- and vice versa. You're free to ask any Haskell question in either location. Having more channels is great if there's a lot of traffic in one or the other, though. :-)
09:53:04 <EvanR> this channel seems very beginner friendly
09:58:42 <Kristof_HT> yes I did notice this channel to be friendly, and haskell people in general are very helpful
09:59:12 <fragamus> is there a good way to escape a file path for bash
10:00:03 <fragamus> i am forced to generate a bash command and send it to the interpeter
10:07:06 <Liskni_si> fragamus: not sure if there's a library for that but I'd consider using something like this: readProcess "/bin/bash" ["-c", "builtin printf %q \"$1\"", "--", "test$"] ""
10:07:17 <Liskni_si> (that's System.Process.readProcess)
10:07:29 <fragamus> I have filenames with special characters in them
10:07:50 <fragamus> I need to escape them
10:08:50 <Liskni_si> yeah, I know
10:08:55 <Liskni_si> let escape x = readProcess "/bin/bash" ["-c", "builtin printf %q \"$1\"", "--", x] ""
10:08:58 <Liskni_si> Prelude System.Process> escape "blah`rm -rf /` $(FOO)"
10:08:59 <Liskni_si> "blah\\`rm\\ -rf\\ /\\`\\ \\$\\(FOO\\)"
10:09:38 <Liskni_si> but there _may_ be better options than this :-)
10:10:38 <fragamus> oh wow
10:11:03 <dgpratt> is the Default typeclass among those that can be automatically derived?
10:11:59 <cocreature> dgpratt: no, it is also not clear what it should derive. if you have something like "data X = A | B" A and B are both valid choices for a default value
10:12:14 <dgpratt> makes sense, thanks cocreature 
10:13:26 <Liskni_si> fragamus: this works too: let escape x = readProcess "/usr/bin/printf" ["%q", x] "", but it uses a different escaping algorithm apparently, so if you know you'll be feeding it into bash, the builtin printf may be better
10:15:08 <fragamus> escape "proj #3"    fails to escape that pesky pound sign
10:17:08 <Liskni_si> does it?
10:17:19 <fragamus> yes
10:17:26 <Liskni_si> $ echo proj\ #3
10:17:26 <Liskni_si> proj #3
10:18:04 <fragamus> the space is escaped but the pound sign is not
10:18:17 <Liskni_si> yes but it doesn't need to be as you can see
10:18:34 <Liskni_si> it does escape it if it's at the beginning of the string
10:18:42 <Liskni_si> it's more clever than I thought :-)
10:20:33 <fragamus> this worked:   touch 'proj\\ #3'
10:20:48 <fragamus> it didnt work until i placed the single quotes
10:21:23 <Liskni_si> do note that if you just type escape "" something in ghci, it prints it via the Show String instance
10:21:32 <Liskni_si> that is, escaped again for Haskell
10:21:47 <Liskni_si> if you want to copypaste into bash, escape "something" >>= putStrLn
10:22:00 <sam__> hey does anybody know if I can use the FFI without depending on base? I really want to use C and make my own "base"
10:22:15 <Kristof_HT> ok... anybody cares to explain or point me to a resource to read, about why [0, 0.3 .. 1.5]  does NOT result in [0, 0.3, 0.6, 0.9, 1.2, 1.5]
10:22:57 <Liskni_si> Kristof_HT: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
10:23:33 <Liskni_si> Kristof_HT: short answer, 0.3 isn't representable in base-2
10:28:01 <Kristof_HT> yes, this a good answer, I should have asked more precise question:  why in haskell 0.3 * 4 will provide 1.2 while [0, 0.3 .. 0.9] will result in [0.0,0.3,0.6,0.8999999999999999]
10:28:52 <Kristof_HT> aka how patter matching will give different result than simple multiplication operator on same numbers
10:29:14 <Tuplanolla> @hoogle enumFromTo
10:29:17 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
10:29:18 <lambdabot> Data.Vector enumFromTo :: Enum a => a -> a -> Vector a
10:29:18 <lambdabot> Data.Vector.Fusion.Bundle enumFromTo :: Enum a => a -> a -> Bundle v a
10:29:24 <Tuplanolla> It uses that function, Kristof_HT.
10:29:54 <Kristof_HT> thank you !  
10:30:54 <Cale> Kristof_HT: wait, what?
10:31:16 <Cale> > [0, 0.3 .. 1.3]
10:31:18 <lambdabot>  [0.0,0.3,0.6,0.8999999999999999,1.1999999999999997]
10:31:30 <Tuplanolla> Business as usual.
10:31:34 <pavonia> > 0.3*4
10:31:34 <Cale> Are you asking why that's 1.1999999999999997 and not 1.2?
10:31:36 <lambdabot>  1.2
10:31:46 <dmwit> Kristof_HT: I'm confused. Why would `0.3 * 4 = 1.2` and `[0, 0.3 .. 0.9] = [0.0,0.3,0.6,0.8999999999]` be in conflict?
10:32:10 <pavonia> > 0.3+0.3+0.3+0.3
10:32:13 <lambdabot>  1.2
10:33:42 <Liskni_si> now I'm confused too, last [0, 0.3 .. 1.2] is 1.1999999999999997, but 0.3+0.3+0.3+0.3 is 1.2 :-D
10:34:00 <Tuplanolla> > printf "%.32f" (0.0 + 0.3 + 0.3 + 0.3 + 0.3 :: Double) :: String
10:34:03 <lambdabot>  "1.20000000000000000000000000000000"
10:34:12 <Tuplanolla> Well, then...
10:34:53 <Kristof_HT> dmwit - i wouldn't say they are in conflict, was just surprised to see different result, and was wondering how pattern matching is handling floats under the hood
10:36:09 <eschnett> I think Julia uses a special mechanism for float ranges that ensures that the last value is obtained exactly, but very slightly modifying the step sizes
10:36:35 <dmwit> Kristof_HT: But what is different about the two results? They don't appear to overlap at all.
10:36:46 <dmwit> Kristof_HT: (Also, a minor terminology note: there's no pattern matching happening here.)
10:37:34 <dmwit> Liskni_si: FWIW, I too find that odd.
10:38:58 <Cale> > let myEnumFromThen n m = n `seq` m `seq` (n : myEnumFromThen m (m+m-n)) in myEnumFromThen 0 0.3
10:39:00 <lambdabot>  [0.0,0.3,0.6,0.8999999999999999,1.1999999999999997,1.4999999999999996,1.7999...
10:39:25 <Cale> > let myEnumFromThen n m = n `seq` m `seq` (n : myEnumFromThen m (m+m-n)) in myEnumFromThen x y
10:39:29 <lambdabot>  [x,y,y + y - x,y + y - x + (y + y - x) - y,y + y - x + (y + y - x) - y + (y ...
10:39:39 <Cale> > let myEnumFromThen n m = n `seq` m `seq` (n : myEnumFromThen m (m+m-n)) in myEnumFromThen x y !! 4
10:39:42 <lambdabot>  y + y - x + (y + y - x) - y + (y + y - x + (y + y - x) - y) - (y + y - x)
10:39:46 <fragamus> Liskni_si thanks
10:40:06 <Cale> > let { x = 0; y = 0.3 } in y + y - x + (y + y - x) - y + (y + y - x + (y + y - x) - y) - (y + y - x)
10:40:08 <lambdabot>  1.1999999999999997
10:40:13 <Cale> ^^ that's why
10:40:21 <Kristof_HT> dmwit i really don't know what do you mean when you say they don't overlap 
10:41:30 <Cale> Kristof_HT: One of the results was a list which didn't contain anything near 1.2 (and ought not to), and the other was 1.2
10:42:19 <Cale> Kristof_HT: You set the upper bound on the list too low if you wanted to see something like 1.2 in there
10:43:38 <Cale> The specified upper bound will always be less than or equal to half a step distance from the element that the list stops on (which is itself kind of a strange specification, but that's what it is)
10:45:17 <dmwit> Cale: Thanks for the explanation of why we don't get 1.2, that's very interesting. But isn't that in conflict with the Report? "The sequence enumFromThenTo e1 e2 e3 is the list [e1,e1 + i,e1 + 2i,…e3], where the increment, i, is e2 − e1." appears to require you to compute the interval just once, not re-compute it on every step, and then use multiplication.
10:46:08 <dmwit> > let reportEnumFromThen e1 e2 = [e1 + i*(e2-e1) | i <- [0..]] in reportEnumFromThen 0 0.3
10:46:11 <lambdabot>  [0.0,0.3,0.6,0.8999999999999999,1.2,1.5,1.7999999999999998,2.1,2.4,2.6999999...
10:46:44 <Kristof_HT> thanks for everyobdy, you guys don't realize how great it is to see meaningful discussion even on such simple example (as opposed to what i would expect on channels for most other programming languages)
10:47:54 <dmwit> > let reportEnumFromThen e1 e2 = let i = e2 - e1; go n = e1 + n*i : go (n+1) in go 0 in reportEnumFromThen 0 0.3 -- even stricter reading, and don't recurse on enumFromThen at another type
10:47:57 <lambdabot>  [0.0,0.3,0.6,0.8999999999999999,1.2,1.5,1.7999999999999998,2.1,2.4,2.6999999...
10:52:36 <Liskni_si> I wonder why it's defined in such a way
10:53:11 <Liskni_si> sum (replicate n 0.3) is consistently closer to the right answer than head (drop n [0, 0.3 ..]) :-)
10:54:24 <bennofs1> Is there a stack command to execute and executable from the project, recompiling before if needed?
10:56:44 <Liskni_si> bennofs1: stack exec --package "the package you're in" -- foo seems to work
10:56:57 <Liskni_si> whether it's the intended usage, I'm not at all sure
10:58:04 <bennofs1> Liskni_si: does that first recompile the package if any files changed?
10:58:21 <bennofs1> ah ok, --package seems to do that, thx
10:58:24 <Liskni_si> bennofs1: stack 1.3.2 does in the one case I tried
10:58:38 <Liskni_si> but I really do think it's a hack :-)
11:05:38 <Tuplanolla> The first mistake would be to consider floating-point numbers simple, Kristof_HT.
11:07:23 <monochrom> "simple" is relative, too.
11:07:54 <monochrom> actually make it s/relative/subjective/
11:10:22 <Kristof_HT> dmwit and Cale - oh so the question was why I provided examples of which one's upper bound wasn't set to go as high as 1.2, that's why dmwit said they don't overlap, - i got it now - well you are right I might have chosen better examples nut the point was that multiplication of 0.3 * n will give you rounded number (0.9, 1.2, 1.5) and [0,0,3..n] gives you 0.8999999999999999 and so on
11:10:33 <Kristof_HT> but through all the replies now I do understand it better
11:12:11 <monochrom> > 0.3 * 3
11:12:13 <lambdabot>  0.8999999999999999
11:12:17 <monochrom> eh?!
11:13:44 <glguy> > 0.3 * 3 :: CReal -- there we go
11:13:47 <lambdabot>  0.9
11:20:17 <Liskni_si> I need to remember to never use floating point arithmetic ever again in my life :-)
11:20:38 <Liskni_si> (still don't understand why enumFromThen is defined as it is)
11:20:50 <Kristof_HT> I'm glad I'm catching those things early
11:21:05 <dmwit> Liskni_si: I'm tempted to say the current implementation of `enumFromThen` is buggy.
11:21:50 <dmwit> Since the way it's implemented, you get compounding rounding errors not just from repeated additions but also from repeatedly recalculating the interval.
11:22:56 <dmwit> > let enumFromThenSingleInterval e1 e2 = iterate ((e2-e1)+) e1 in enumFromThenSingleInterval 0 0.3
11:22:58 <lambdabot>  [0.0,0.3,0.6,0.8999999999999999,1.2,1.5,1.8,2.1,2.4,2.6999999999999997,2.999...
11:23:13 <Liskni_si> https://github.com/ghc/packages-base/commit/e007a7cad7f402caaedacf1933e38b55d744ac4b
11:23:14 <dmwit> Probably still worse than what the Report says to do, but at least you get 1.2...
11:23:17 <Liskni_si> this seems to be the offending commit
11:24:06 <monochrom> I think "never use floating point" is too extreme. May as well never use computers.
11:24:31 <monochrom> However, "never be ignorant, never assume" is exactly right.
11:24:46 <Tuplanolla> My rule of thumb is to use floating-point whenever an analog signal would do.
11:24:51 <dmwit> "never be ignorant" is not actionable advice.
11:25:03 <dmwit> Human brains aren't big enough.
11:25:09 <glguy> dmwit: You don't even know
11:25:24 <monochrom> Oh "never" is never actionable. May the odds be never in your favour!
11:25:41 <Liskni_si> yeah, never again was a hyperbole :-)
11:26:38 <monochrom> But I guess I just needed "never assume".
11:26:46 <nitrix> Hi.
11:27:07 <nitrix> I have a stack.yaml for my executable requiring a local library which also has its own stack.yaml.
11:27:35 <nitrix> For some reason, the extra-deps of that local library doesn't seem to carry over to my executable and I'd have to duplicate them.
11:28:05 <nitrix> That seems a little dubious to me that these nested dependencies aren't figured out automagically, so I'm asking.
11:29:37 <dgpratt> where can I see a list of the predefined lenses in the ubiquitous lens library?
11:30:02 <glguy> ?hackage lens
11:30:02 <lambdabot> http://hackage.haskell.org/package/lens
11:30:13 <monochrom> The docs, yeah. :)
11:30:22 <arbitraria> hello all, I am trying to [x++(chr y) | x <- ['P','B','C'], y <- [1..10]]  and it doesn't work (also tried replacing chr with show), could someone maybe point me in the right direction?
11:30:35 <Liskni_si> nitrix: stack files aren't meant to nest, it's just your stack.yaml and a bunch of cabal packages
11:30:39 <monochrom> Unless you say "no no no I want them all in one single ebook"
11:30:50 <glguy> arbitraria: chr y isn't a list, so you can't ++ it
11:30:54 <nitrix> Liskni_si: Here's an example...
11:30:56 <nitrix> Liskni_si: https://github.com/z0w0/helm/blob/master/stack.yaml
11:31:09 <nitrix> Liskni_si: Someone using helm would have to list these three external dependencies themselves?
11:31:10 <glguy> arbitraria: 'P' isn't a list, either
11:31:19 <glguy> > ['P',chr 97]
11:31:22 <lambdabot>  "Pa"
11:31:36 <Cale> Kristof_HT: btw, this isn't just a Haskell thing, this is just how floating point arithmetic works (and almost all languages provide floating point numbers because CPUs support them). You generally have to be wary about treating any floating point number as an exact quantity, there's always going to be some tolerance for error.
11:31:51 <Liskni_si> nitrix: yes
11:32:02 <ph88> i have this piece of code  https://paste.fedoraproject.org/537782/48553613/  and i intended f on line 30 to be the same f as on line 10, but ghc is not having it. What am i doing wrong ?
11:32:15 <Cale> Kristof_HT: Of course, you can format the numbers to display in a prettier way, by rounding them even more :)
11:32:28 <Cale> > showFFloat (Just 2) pi ""
11:32:30 <Liskni_si> nitrix: normally you'd hope that helm and all its dependencies would be in stackage lts, but if they're not, you're expected to specify all that yourself as extra-deps
11:32:31 <lambdabot>  "3.14"
11:32:35 <arbitraria> thank you! glguy
11:32:48 <Cale> > showFFloat (Just 2) 0.8999999999999999 ""
11:32:48 <nitrix> lambdabot: That isn't my question.
11:32:51 <lambdabot>  "0.90"
11:32:58 <nitrix> Liskni_si: That isn't my question.
11:33:33 <monochrom> ph88: I see no "f" on line 10
11:33:55 <nitrix> Liskni_si: Again, my executable has a local dependency, which is listed in the stack.yaml file. That dependency, has dependencies of its own.
11:34:13 <nitrix> Liskni_si: Someone, my executable has to list the dependencies of that dependency, for it to work. And that doesn't feel right.
11:35:39 <Liskni_si> nitrix: Doesn't feel right, but it is indeed as designed. stack works with "curated" sets of packages, the stackage lts. If some dependency is in the lts, you don't need to list it. If it's just on hackage, you do. And that's it.
11:36:13 <Liskni_si> nitrix: And the dependency's stack.yaml file isn't considered at all.
11:36:33 <Liskni_si> Arguably it shouldn't even be there. :-)
11:36:49 <monochrom> In fact I see no reason to give "get" the type annotation "get :: f Exponent". The do-block already determines f, and the pattern "Exp ex" already determines Exponent. The only meta-explanation is that the author has an XY problem.
11:36:59 <nitrix> Liskni_si: You're answering something completely different to what I'm asking, but fear not, I found my issue.
11:37:48 <monochrom> I have a tale to tell about this, too! :)
11:38:42 <monochrom> I was in #math waiting for homework questions, and someone asked one: "x+1/y-2 ..." something. So I said, "add more parentheses".
11:39:08 <monochrom> The asker went on to clarify it as "(x)+1/(y)-2"
11:39:28 <Cale> monochrom: lol
11:39:41 <Cale> such helpful clarifications
11:39:58 <Liskni_si> nitrix: I really don't think I'm answering something different. You don't have to list your dependency's dependencies in the cabal/hpack file. You _might_ have to list your dependency's dependencies in stack.yaml and here I am telling you why.
11:40:30 <monochrom> I do not remember the exact expression, so I am paraphrasing now, to be fair. The real instance might be something less extreme, like "(2x)+1/y-2"
11:41:12 <monochrom> Still, people always clarify the part that needs the least clarification.
11:41:59 <ph88> monochrom, eh sorry i meant line 20 :/
11:42:25 <monochrom> Then you need ScopedTypeVariables and a few forall's.
11:43:04 <ph88> monochrom, the forall needs to be explicit ?
11:43:06 <monochrom> Or maybe no need for forall's. Read the GHC User Guide on how to use ScopedTypeVariables together with instance code.
11:43:10 <nitrix> Liskni_si: That makes no sense to me. Why would my executable need to explicitly list the dependencies of all my dependencies?
11:43:27 <nitrix> Liskni_si: I'm pushing code.
11:43:36 <ph88> monochrom, ok, i already have ScopedTypeVariables enabled though ^^
11:43:51 <monochrom> Call the GHC User's Guide. Call now.
11:44:08 <monochrom> Also like I said, I suspect XY problems.
11:44:44 <nitrix> Liskni_si: https://github.com/nitrix/lspace/blob/develop/stack.yaml
11:44:46 <nitrix> Liskni_si: https://github.com/nitrix/lspace/blob/develop/kawaii/stack.yaml
11:44:55 <monochrom> "(Exp ex) <- get :: f Exponent" cannot possibly be a type-clarifying annotation, let alone type-correcting.
11:45:09 <nitrix> Liskni_si: As you can see, the executable ends up listing very specific versions of the dependencies of that `kawaii` dependency.
11:45:29 <Kristof_HT> thank you all, back to work now, o7
11:45:42 <nitrix> Liskni_si: Which is completely crazy. What `kawaii` depends on shouldn't be none of the executable's business.
11:46:02 <nitrix> Liskni_si: In fact, what happens as soon as the library depends on a different version? Whoops, builds breaking.
11:46:22 <Liskni_si> nitrix: maybe you want to use cabal-install instead of stack, then
11:46:50 <nitrix> Liskni_si: It should be that the executable depends on `kawaii` and that's it. And kawaii should have the dependencies commented out and that would make a lot more sense.
11:46:50 <Liskni_si> nitrix: stack is about reproducible builds, and it won't go all around the internet looking for random packages you might need, it just won't, wasn't designed to
11:47:13 <nitrix> Liskni_si: It isn't going around the internet lookinf for random packages. These are local dependencies.
11:47:41 <nitrix> Liskni_si: `kawaii` is a local dependency of that executable.
11:48:29 <Liskni_si> nitrix: stack doesn't care where those dependencies are. If it doesn't know about the package, it won't see it. And it only knows about what's in the resolver (lts-7.9 in your case) and extra-deps.
11:49:03 <nitrix> Liskni_si: But it ISN'T, an extra dep.
11:49:11 <Liskni_si> nitrix: Again, stack.yaml aren't meant to nest. It isn't looking at stack.yaml in kawaii! It's looking at kawaii.cabal, maybe, but not kawaii/stack.yaml.
11:49:13 <nitrix> It's a package listed as a local dependency.
11:49:20 <nitrix> packages:
11:49:22 <nitrix> - '.'
11:49:24 <nitrix> - kawaii
11:49:26 <nitrix> How do I have to work this.
11:49:28 <nitrix> *word.
11:49:40 <nitrix> It'll, literally, look up that folder.
11:49:53 <Liskni_si> It doesn't matter what kind of dependency it is, local or remote or nonexistent.
11:50:10 <nitrix> Well, that is bogus.
11:50:17 <nitrix> Dependencies should be self-contained.
11:50:42 <Liskni_si> If you come from rebar3, you might well expect them to be, yeah. :-)
11:51:15 <Liskni_si> If you come from anything else, say, cpan, maven, whatever, not so much.
11:51:56 <nitrix> I can understand for packages that are external (on hackage) or internal (on stackage), but here we clearly state that kawaii can checkout this repository and build the library using these files.
11:52:21 <nitrix> Then the executable should just be able to use the library that was just built as, that library, is a local dependency.
11:52:38 <nitrix> It can just use it. It doesn't make sense for the executable to re-list all the stuff that that library needs.
11:53:30 <Liskni_si> I'm not sure if you want an explanation of why things are the way they are or a way to solve this without sacrificing your beliefs. :-/
11:53:43 <Liskni_si> Either way, I'm hungry, so I can't give you either. :-(
11:54:11 <nitrix> Alright. I'll see with the FPComplete dev team.
12:11:23 <ph88> monochrom, i've checked the docs it says i don't need an explicit forall in ghc and i already have ScopedTypeVariables extension enabled
12:11:50 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
12:13:38 <ph88> ya that's right, i don't know the cause -___-
12:14:33 <geekosaur> something like this was discussed in #ghc recently, iirc currently there is no way to synchronize those type variables
12:16:39 <ph88> is there a workaround ?
12:18:18 * geekosaur trying to find discussion
12:19:50 <geekosaur> http://ircbrowse.net/browse/ghc?id=44779&timestamp=1484535315#t1484535315 ff. was discussion I was remembering
12:20:58 <ph88> thanks, ill take a look
12:20:59 <geekosaur> ph88, what ghc version?
12:21:03 <ph88> 8.0.1
12:21:13 <geekosaur> http://ircbrowse.net/browse/ghc?id=44866&timestamp=1484536793#t1484536793
12:21:32 <geekosaur> is the relevant part, I *think* this is something that changed in 8.0.2
12:22:05 <geekosaur> but not directly related to your issue, just doing something you might benefit from as a side effect
12:24:36 <byorgey> dgpratt: um.  There are probably, like, thousands.
12:24:43 <ph88> i keep being surprised that there is still heavy development activity in ghc ^^
12:24:51 <byorgey> oops, I was scrolled up =P
12:25:12 <ph88> by the way, is there also a forum for questions ?
12:27:08 <geekosaur> glasgow-haskell-users mailing list, possibly
12:29:59 <AWizzArd> Control.Monad.forM  vs mapM – what’s the difference?
12:30:14 <monochrom> parameter order
12:30:21 <monochrom> is that right/
12:30:25 <monochrom> @type forM
12:30:27 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
12:30:38 <monochrom> yeah, parameter order
12:30:50 <AWizzArd> So it’s just interesting for style? If I have a big body I use forM, otherwise if it’s just a function name mapM?
12:31:03 <monochrom> yes
12:31:10 <zennist> For composition and product between functors / applicatives - what are the conventional constructors to use?
12:31:23 <AWizzArd> monochrom: oki thx
12:32:07 <zennist> I found: for composition: Data.Functor.Compose or :.:; for Product, only found :*: ?
12:32:09 <ph88> geekosaur, what i see there in the chat and also what i read in the documentation are examples whereby the type defined in the class is matched with the type of the function in the instance. But in my case i just want to specify the type of a function that resides in another instance (of the same class nevertheless). That's why i can't really relate those things back to my situation
12:32:57 <zennist> I suppose (:.:) and (:*:) are more consistent?
12:33:04 <geekosaur> the most relevant part was discussing just scoping every type variable automatically over the whole thing, instead of the hack added to 8.0.2 that scoped certain type variables
12:33:09 <monochrom> You found Data.Functor.Compose but not Data.Functor.Product?
12:33:47 <geekosaur> (that is not something that is currently implemented)
12:34:37 <tibbe> How do I get the Emacs haskell-mode to use stack instead of cabal?
12:37:24 <zennist> actually - I found Data.Functor.Product; maybe this is better
12:39:52 <monochrom> The X product :>*<: and its duel, the TIE product :<*>:
12:42:36 <clmg> How do cursors/outputs work in vty? When I setCursorPos via `outputIfFace vty` I don't see a cursor.
12:43:21 <Tuplanolla> I was about the ask the same thing today, clmg.
12:45:02 <clmg> Vty is great so far. I just wish vty-examples was more complete.
12:45:21 <Tuplanolla> I'm using it with Brick here. It's quasipleasant.
12:45:44 <Tuplanolla> I wish it could calculate the width of multiline strings correctly.
12:46:03 <zennist> monochrom: what is the X product?
12:46:06 <zennist> link?
12:46:20 <clmg> Tuplanolla: you're using vty and brick? Don't they occupy a similar space functionality-wise?
12:46:39 <Tuplanolla> Brick is a Gloss-like layer on top of Vty, clmg.
12:46:56 <Tuplanolla> It has event handlers and layout managers and stuff.
12:47:14 <clmg> Tuplanolla: wow thanks I've been missing out.
12:47:48 <Tuplanolla> Still can't position that cursor.
12:48:08 <zennist> btw I found :.: :*: looks nicer..? say you have three things you want to compose together; then infix looks better isn't it?
12:48:24 <zennist> but i don't think i ever see people using these constructors
12:48:55 <ph88> this code has quite a few nested do-blocks .. how could i rewrite it to make it less verbose?  https://paste.fedoraproject.org/537866/85550073/
12:59:31 <ph88> @pl data Foo = F String ;  do  (F x) <- F "foo"; return x
12:59:31 <lambdabot> (line 1, column 21):
12:59:31 <lambdabot> unexpected ';'
12:59:31 <lambdabot> expecting variable, "(", operator or end of input
13:00:12 <ph88> can i define some  data  with lamdabot ?
13:03:25 <mniip> ph88, yes, but not for @pl
13:03:46 <ph88> i'm using a do-block for this everytime
13:18:07 <ph88> is there a do-block equivalent of <*>  ?
13:18:46 * Clint squints.
13:18:48 <Rembane> ph88: (x,y) <- ... ; f x y
13:19:04 <Rembane> ph88: Well, sometimes at least.
13:25:23 <eschnett> ph88: you are writing “return …” in your do statements. you don’t need to end with a “return”; you can just write the respective expression instead, as in “do result <- calc; return result” becomes “do calc”
13:25:48 <ph88> ooh
13:28:31 <ph88> i have a whole bunch of ugly looking code like this  https://paste.fedoraproject.org/537874/55247614/
13:29:10 <ph88> so in case of line 27 i can ommit the return ?
13:29:42 <davean> ph88: of course
13:29:53 <davean> ph88: what do you tihnk the return is doing there?
13:30:05 <davean> Its taking a thing, and making it back into exactly the thing it was
13:30:15 <ph88> i always use return
13:30:26 <davean> If you like to, do it, it doesn't actually do anything
13:30:50 <davean> I mean, what it does is puts some value into the monad
13:30:57 <davean> but you just got that value *out* of the monad
13:31:02 <davean> isj
13:31:04 <davean> *ish
13:32:34 <davean> ph88: maybe I can make it more clear
13:32:41 <davean> ph88: do you know how to desugar do notation?
13:32:44 <ph88> ya most of the time it's useful i think, for example on line 21 i need to make a tuple
13:33:09 <ph88> yes i can use >>= but i seldomly use >>=
13:33:23 <davean> Sure, but conceptually lets look at what we have in the actual function calls
13:33:39 <davean> we have some "m a" (the right side of the <- on ike 23)
13:33:45 <davean> and we're passing it to return
13:33:48 <davean> ma >>= return
13:34:00 <davean> so consider the types
13:34:14 <davean> (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:34:26 <davean> and return :: Monad m => a -> m a
13:34:58 <davean> so (>>= return) becomes "m a -> m a"
13:35:08 <ph88> ye
13:35:10 <davean> That looks a lot like 'id' doesn't it?
13:35:16 <ph88> ye
13:35:26 <davean> we've given (>>= return) absolutely no ability to DO anything with m a
13:35:31 <davean> it just knows its a monad, thats not enough
13:36:12 <ph88> in case you want to combine a few things it becomes something like   \x y -> return (x, y)  ?
13:36:20 <davean> yep, basicly
13:36:26 <davean> YOu've got the idea
13:36:38 <ph88> yes i get the very basics of it
13:36:54 <ph88> i just know just enough syntax to make it compile (most of the time)
13:37:29 <ph88> there are still plenty of things i don't know ... for example i tried to move  (n get) <*>  into  etwo  and  emore  but that didn't work out
13:37:32 <davean> m a >>= (\a -> m b >>= (\b -> return (a, b))
13:37:36 <davean> to be explicite
13:37:46 <davean> but you don't need to think about it like that conceptually to understand how it works
13:38:39 <davean> Ah, I see why that wouldn't have worked - the point of <*> is you're filling in values to the function "And" or "Or" or whatnot
13:38:53 <davean> you'd need curry/uncurry
13:38:57 <davean> which isn't really what you want at all
13:39:07 <ph88> eh ok
13:39:10 <davean> what you COULD do is pass "And" and "Or" into etwo
13:39:26 <ph88> aaah right
13:39:47 <ph88> yeah i got stuck there everytime that i need to return a bunch of values, but of course i can only return 1 value with return
13:40:00 <davean> while you can do it the other way like you tried to initially, it doesn't make the code any prettier
13:40:11 <ph88> so there is no way i can  use do-notation and return  to give a few values to a data constructor ?
13:40:20 <ph88> ok ok
13:41:01 <ph88> i thought since there were so many parallels between applicative and monad that <*> must have a monad equivalent and also a do-notation
13:41:17 <davean> I mean, thats not your problem here
13:41:21 <davean> <*> works in monads
13:41:27 <davean> *must* work in monads
13:41:44 <ph88> only on the right side of the  <-  though ?
13:41:53 <davean> no
13:42:17 <davean> I don't think you understand how <$> ... <*> is working
13:42:39 <davean> You can't take the right side of that, the right side isn't really a thing
13:42:41 <ph88> not really .. but i still use them all the time succesfully
13:42:51 <ph88> tbh i'm not sure how i'm even writing haskell but it works o_O
13:42:58 <davean> Yah, they're not hard, but you can't section the expression like you're trying to
13:43:07 <davean> haskell isn't really that hard :)
13:43:41 <ph88> i just know that when i'm using <$>  and then i want a few more things i should put a few <*> after that :P
13:44:07 <davean> I could explain it, but I'm not sure how useful explaining it would be ATM for you
13:44:30 <ph88> it's ok
13:44:47 <ph88> at least i have one suggestion: put the data constructor as argument to the function
13:44:53 <ph88> i don't do that a lot actually
13:45:12 <ph88> what would be the type of a  data constructor though ?
13:45:20 <davean> Its just a function
13:45:27 <davean> data constructors are just functions
13:45:36 <glguy> sometimes
13:45:43 <davean> a -> list -> of -> values -> it -> takes -> theTypeItMakes
13:45:52 <geekosaur> :t Just
13:45:54 <lambdabot> a -> Maybe a
13:45:55 <glguy> :t True
13:45:57 <lambdabot> Bool
13:46:27 <geekosaur> in some ways, GADT syntax may be a better way to get to understand this
13:46:41 <davean> geekosaur: in probably all ways :)
13:47:40 <ph88> i think  <-  is like unpack  lol
13:48:12 <davean> ph88: that will probably do you fine
13:48:28 <mohsen_> Hi
13:48:41 <mohsen_> Why does this happen: https://ptpb.pw/5u6m ?
13:49:01 <davean> ph88: just be willing to revisit your intuitions when you come upon something deeply novel
13:49:12 <glguy> mohsen_: Because you provided a type signature but no implementation of sum'
13:49:36 <mohsen_> glguy: Do I have to provide the implementation first?
13:49:45 <glguy> mohsen_: No, you'll have to provide it at the same time
13:49:57 <glguy> mohsen_: A GHCi session isn't like typing in a .hs file one line at a time
13:50:02 <davean> (this is something that probably doesn't help ghci's usability)
13:50:04 <geekosaur> you need to provide them together, separated by a semicolon. in ghc versions before 8.0.1 you must also prefix with "let"
13:50:10 <ph88> davean, is my thinking ok when i start doing something like this https://paste.fedoraproject.org/537877/53764148/ so i leave out the return as you suggest ?
13:50:12 <glguy> sum' :: Num a => a -> a; sum' = sum
13:50:50 <geekosaur> (I am thinking that error looks like a version that needs "let" and is therefore parsing that as a type ascription on an undefined name)
13:50:52 <glguy> mohsen_: GHCi is better used where you put all your definitions in a file, load that with GHCi, and then experiment with one-off expressions in GHCi using those definitions
13:51:05 <davean> ph88: I expect you want to fmap that fromMaybe, whcih you can do nicely with <$>
13:51:27 <ph88> mohsen_, there is an option to set multiline in ghci (i can recommend it, it's useful)  and for implementation you can do   sum' = undefined   if you don't want to think about the implementation yet
13:52:18 <ph88> davean,  like this ?   fromMaybe "" <$> o $ do
13:52:37 <davean> yes, with the appropriate parentheses to make order of operation happy
13:53:07 <mohsen_> Thanks guys
13:55:26 <ph88> davean, i think fmap is nicer here, what you think ?  https://paste.fedoraproject.org/537881/14855540/
13:55:51 <davean> ph88: entirely personal style
13:56:03 <ph88> ok i really have to get use to this that i don't have to use return in the do-block
13:56:26 <davean> I mean, you can use it if you like it :)
13:56:32 <orzo> seems my memory leaks are all gone
13:56:50 <ph88> do i even need the do on line 24 anymore ?
13:56:59 <davean> ph88: of course not :)
13:57:03 <ph88> o_O
13:57:31 <davean> ph88: You have training wheels you didn't even know you had :)
13:58:59 <ph88> i think i should make a function like this   \x -> fmap (fromMaybe "") x     because i notice i use this pattern quite a lot
13:59:05 <orzo> when did you need the do
13:59:23 <ph88> orzo, when you want to work with  <-
13:59:42 <orzo> i mean on line 24
13:59:53 <orzo> you have a do on 25 to work with <-
14:00:35 <orzo> i guess maybe at some point you didn't have the fmap (fromMaybe ..) bit
14:00:47 <ph88> orzo, before the code was like at line 2 .. that's where the do come from .. this is all different versions of the same code
14:01:10 <zennist> why is State not a Monoid?
14:01:29 <zennist> (->) a b is a Monoid if b is a monoid
14:01:37 <orzo> does using "return" force "Monad" over "Applicative" ?
14:01:57 <zennist> I suppose we can make State a monoid simply by running the two State funcs and mappending the resultant valus
14:02:05 <ph88> orzo, yes i think so, for applicative you can use  pure   .. but stick around maybe someone can give you a better answer because i'm just a beginner myself
14:02:21 <orzo> that's a shame
14:02:28 <Tuplanolla> That's all, ph88.
14:02:32 <ph88> @src return
14:02:32 <lambdabot> Source not found. Just try something else.
14:02:36 <ph88> @src pure
14:02:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:02:52 <ph88> Tuplanolla, ?
14:03:11 <zennist> anyone who can answer my Monoid question?
14:03:33 <glguy> zennist: It doesn't have an instance because the author decided not to provide one
14:03:45 <orzo> i know return is technically a memeber of Monad, but they could have a rewrite rule to make it pure and deprecate it
14:03:56 <zennist> is that deliberate - or simply not thought out?
14:04:58 <zennist> i can see this being quite useful though - now, as soon as you want a state, you have to run it as Applicative for accumulation; with Monoid instance you just need a foldMap
14:05:55 <geekosaur> zennist, Monoid is kind *, MonadState and instances thereof are kind * -> *
14:06:08 <glguy> It wouldn't involve MonadState
14:06:17 <glguy> instance (Monad m, Monoid a) => Monoid (StateT s m a) where mempty = return mempty; mappend = liftA2 mappend
14:06:59 <orzo> zennist: couldn't you just fold over (*>) instead of (<>) ?
14:18:31 <orzo> if you use Data.Map.Lazy in a TVar for a mutable key-value table, is it pretty much impossible to not leak?
14:20:06 <orzo> I wasn't patient/careful enough to verify each individual change in isolation was a leak fix, but one thing i did is switched from PSQueue to psqueues inside of a TVar
14:20:50 <orzo> because PSQueue doesn't have !s on it's constructor arguments, I figured it was being too lazy
14:24:30 <monochrom> Data.Map.Strict leaks less.
14:25:00 <monochrom> There is a way you can stay with Data.Map.Lazy and not leak, but what you do will be what Data.Map.Strict does.
14:26:19 <orzo> would you have to add a lookup immediately following any insert?
14:27:23 <monochrom> No. But seq the insert.
14:28:27 <orzo> that's specific to Data.Map ?
14:28:54 <orzo> seems to me if all i know is that it's a lookup table, i need to use a lookup to force all the wobly bits after an insert
14:30:39 <monochrom> I don't know how to answer that question.
14:32:00 <orzo>  well seq can only force the values you are putting in, i don't see why it would force the spine
14:32:49 <monochrom> But if it's Data.Map, you do know that seq triggers forcing the spine.
14:33:34 <monochrom> It is "not specific" to Data.Map because Data.Set and Data.HashSet and Data.HashedMap and a million other things do this too.
14:34:10 <monochrom> But it is "specific" to Data.Map because you have to know it's Data.Map (or Data.Set, or Data.HashedMap, or...)
14:34:44 <orzo> what about PSQueue ?
14:34:54 <monochrom> See what's the problem? You have an assumption that says "I am encountering an abstract data type, so abstract that I absolutely, honestly, truly know nothing whatsoever"
14:35:16 <orzo> well i actually don't know
14:35:27 <orzo> i've not read how Data.Map works
14:35:29 <monochrom> But that is an unrealistic assumption. You always know enough. Sometimes from the doc, sometimes from the source code, sometimes from hearsay from #haskell.
14:41:21 <orzo> Data.Map puts !s in it's constructors, but { data PSQ k p = Void | Winner k p (LTree k p) k } does not.  Am I write to suspect and avoid using PSQueue in a TVar?
14:41:34 <orzo> s/write/right/
14:41:57 <monochrom> Is there any reason this is specific to TVar?
14:42:11 <orzo> hmm. LTree uses !s
14:42:38 <monochrom> I can simply answer "yes". But then the logical conclusion is that you won't even put a list in a TVar.
14:42:38 <orzo> TVar, IORef, ...
14:42:56 <monochrom> And yet TChan did just that. In fact probably worse than that.
14:43:44 <orzo> LTree uses ! on everything except recursive instances of LTree
14:44:08 <monochrom> TChan is a "lazy" tuple of two "lazy" lists in a TVar. It is so going to leak.
14:44:27 <orzo> are you being sarcastic
14:44:43 <monochrom> First sentence? Second sentence?
14:45:06 <orzo> i don't have a problem with lists
14:45:26 <orzo> but i want to be able to try out different lookup tables without having to read all their code and figure out exactly how they work
14:45:29 <monochrom> Why? They're as lazy as any other un!ed ADT.
14:46:45 <Squarism> List has function "all" but not Set. I think Set could have had it too - but im just a noob. 
14:46:45 <monochrom> There are ways to set up empirical experiments so you don't have to read source code.
14:46:47 <orzo> i'm not trying to argue for some logical proof of a theorem here, just looking for a rule of thumb for pratcial coding
14:47:29 <monochrom> For example if you wonder whether Data.Map is eager or lazy in its skeleton structure, you can try building an infinitely large map and see what happens.
14:47:29 <orzo> :t all
14:47:31 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:47:37 <orzo> Set is not Foldable?
14:48:14 <monochrom> I support practical programming too.
14:48:14 <Naughtmare[m]> orzo: set is not a functor.
14:48:17 <Squarism> ph it is
14:48:28 <Squarism> oh
14:48:42 <monochrom> The rule of thumb in this case is "you have to find out"
14:49:02 <Zemyla> Oh, edwardk, I realized why Cokleisli can't be a conforming Choice profunctor.
14:49:07 <jle`> Set should be foldable
14:49:16 <geekosaur> it is according to ghci
14:49:27 <Squarism> theres no docs that show what inherited methods a type has?
14:49:37 <edwardk> Zemyla: i need an isleftadjoint class
14:50:25 <Zemyla> Well, Cokleisli is closed, and it's apparently Strong, too. So if it were Choice as well, then I'm pretty sure that it would be able to be made an instance of Mapping.
14:50:55 <monochrom> You know what, it's all the more ironic because all the practical programmers I run into, they say "dig into the source code" more often than they say "you don't have to dig into the source code".
14:51:13 <monochrom> I am against that, but you brought up practical programming.
14:51:13 <geekosaur> Squarism, haddock shows instances (although recent versions have bugs that drop some instances)
14:51:21 <edwardk> the real constraint you want is something like f a is isomorphic to (x, a)  for some 'x'
14:51:25 <geekosaur> there is no such thing as "inherited instances"
14:51:27 <orzo> monochrome, you're being an ass, spare me.
14:51:35 <monochrom> Whereas it is instead the theorists who say "that's immoral".
14:51:38 <binary> I'm curious about the density of *derived* Binary instance vs a hand-written instance
14:51:40 <edwardk> that lets you write a real costrength
14:52:02 <binary> Looking at the old Binary deriving implementation: https://hackage.haskell.org/package/binary-derive-0.1.0/docs/src/Data-Binary-Derive.html#derivePut
14:52:09 <Zemyla> And I'm like 90% sure that any Arrow that is Mapping has to be isomorphic to Indexed i for some i.
14:52:15 <binary> It doesn't look like it'd be too great, but maybe I don't get it
14:52:19 <edwardk> my recollection is that is what is needed to fix cokleisli/costar's choice instance
14:53:30 <Squarism> geekosaur, Yeah i see that. But some types have like 30 instances so its a bit offputting to glance through all of them. =D
14:53:33 <Zemyla> Ahh, okay. So it is isomorphic to Indexed i.
14:53:52 <edwardk> once you know you have (f a -> b)   and that f a ~ (x, a)    then you can play currying games, because f a -> b ~ (x, a) -> b ~ (x -> a -> b) ~ a -> (x -> b)
14:53:59 <binary> Does anyone have experience with making Binary instances as compact as possible?
14:54:12 <edwardk> yeah
14:54:35 <edwardk> once you have that you can do things like traverse with it
14:54:45 <Squarism> geekosaur, but good to know inherited mehtods arent listed anyway
14:54:51 <geekosaur> ...
14:55:04 <geekosaur> could you explain what you think an inherited method is?
14:55:13 <geekosaur> they're "not listed" because there is no such thing. this is not OOP
14:55:23 <edwardk> anyways i need to come up with a good name for the existential form of that where you don't get to know 'x' and the form where you do, which are analogous to distributive and representable
14:55:52 <geekosaur> class Foo a => Bar a does not mean "Bar a inherits from Foo a", it means "Bar a must have an instance of Foo a"
14:55:55 <edwardk> then profunctors can get correct choice instances for cokleisli/costar
14:56:02 <geekosaur> you still have to provide that instance, it is not inherited
14:56:28 <orzo> that's called interface inheritence, geekosaur
14:56:33 <geekosaur> * an instance of Bar a must have ...
14:56:38 <binary> Okay, sounds like no one has much experience with derived vs hand-written Binary. If anyone has the knowledge, it'd be great to have some info on this in the https://hackage.haskell.org/package/binary docs.
14:57:46 <Zemyla> edwardk: Wouldn't the relevant method be something along the lines of Functor m => (a -> m b) -> f a -> m (f b)?
14:57:50 <Zemyla> Basically a lens?
14:58:01 <glguy> binary: You're unlikely to get much help with questions like "Does anyone have experience with..." questions
14:58:13 <edwardk> exactly
14:58:16 <Zemyla> And probably derive from Traversable1.
14:58:21 <edwardk> its a fancy subclass of Traversable
14:58:46 <edwardk> that is the existential version
14:59:14 <edwardk> the distributive analogue looks like that anyways
14:59:28 <edwardk> the representable one needs a type family to talk about 'x'
15:04:07 <Zemyla> edwardk: Is there a way to describe a Traversable f as f a ~ exists n. (x n, Vect n a)?
15:04:39 <edwardk> thats not quite right sadly, because traversable allows infinite containers
15:05:07 <edwardk> and the infinite descent isn't on one side like [a] all the time
15:05:36 <Zemyla> Well, n wouldn't be a number. It'd be a potentially-infinite countable ordinal.
15:05:40 <edwardk> its a good intuition for the finite cases
15:06:17 <edwardk> the problem is that you don't have the ability to necessariy re-associate things to put elements in place
15:09:35 <edwardk> even just an infinite tree gets you in trouble with that intuition. data Tree a = Bin (Tree a) a (Tree a) | Tip deriving (Functor,Foldable,Traversable); tree = Bin tree 1 tree has infinite recursions all over the place all over the place, but is still traversable (with or without Tip being a member)
15:10:04 <edwardk> you can come up with applicatives that can produce meaningful answers traversing that silliness
15:11:40 <Zemyla> Is there a way to turn a Magma into a breadth-first traversal?
15:14:25 <Squarism> what would be a short way of checking duplicates in a list?
15:14:35 <Squarism> i suspect such function exist
15:15:02 <Cale> (\xs -> xs == nub xs) is short
15:15:37 <Zemyla> That'd be something along the lines of zipping both halves of a fork when it happens...
15:16:51 <jle`> (\xs -> length xs == length (S.fromList xs)) might be more efficient but hwo knows
15:17:01 <jle`> (it requires an Ord instance tho)
15:17:31 <Cale> If I was worried about performance, I'd replace nub with something like
15:18:52 <Cale> @let ordNub xs = foldr (\x xs s -> if S.member x s then xs s else xs (S.insert x s)) (const []) xs S.empty
15:18:56 <lambdabot>  Defined.
15:19:29 <Zemyla> This is faster and more general.
15:20:04 <Zemyla> @let checkUnique l = foldr (\a r s -> S.notMember a s && r (S.insert a s)) (const True) l S.empty
15:20:06 <lambdabot>  Defined.
15:20:15 <Cale> oops, missed the element :)
15:20:26 <Zemyla> That way, you aren't accumulating stuff you don't need.
15:20:29 <Cale> @let ordNub xs = foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) xs S.empty
15:20:31 <lambdabot>  .L.hs:179:1: warning: [-Woverlapping-patterns]
15:20:31 <lambdabot>      Pattern match is redundant
15:20:31 <lambdabot>      In an equation for ‘ordNub’: ordNub xs = ...
15:20:35 <Cale> right...
15:20:40 <Cale> @undefine
15:20:41 <jle`> wait, isn't there an ordNub in base now?  or was i dreaming when i raed that there was
15:20:41 <lambdabot> Undefined.
15:20:46 <Cale> ordNub xs = foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) xs S.empty
15:20:48 <Cale> @let ordNub xs = foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) xs S.empty
15:20:50 <lambdabot>  Defined.
15:20:53 <Cale> @let checkUnique l = foldr (\a r s -> S.notMember a s && r (S.insert a s)) (const True) l S.empty
15:20:55 <lambdabot>  Defined.
15:21:08 <Zemyla> > checkUnique [1, 2, 3, 1, 4]
15:21:12 <lambdabot>  False
15:22:25 <Cale> It should amount to *approximately* the same thing using ordNub and (==), due to laziness
15:22:47 <Cale> But you'll end up doing more equality tests
15:22:49 <Zemyla> :t checkUnique
15:22:51 <lambdabot> (Foldable t, Ord a) => t a -> Bool
15:22:59 <Zemyla> My function is more general.
15:23:34 <Cale> Ah, I suppose this ordNub simultaneously converts to a list
15:23:53 <Cale> So you'd have to write  ordNub xs == toList xs
15:24:08 <Zemyla> And then you're folding over the list twice.
15:25:01 <Cale> Yeah, but it's not terrible, since the traversal happens in parallel
15:25:19 <Zemyla> Yes, but you should avoid doing more than you need to.
15:25:19 <Cale> (so early elements in the list can become garbage)
15:26:27 <Zemyla> Also, your solution prevents things like stream fusion if used with vectors.
15:26:44 <RandoCoder> Is there a function that has type Monad m => m a -> (a -> b) -> m b?
15:27:10 <RandoCoder> The closest I can find is flip fmap
15:28:24 <Zemyla> :t (<&>) -- RandoCoder
15:28:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:28:31 <seequ_> RandoCoder: fmap is probably what you want
15:29:27 <RandoCoder> Thanks
15:37:12 <biglambda> When does stack build execute Setup.hs?
15:47:13 <hpc> biglambda: when cabal does
15:47:38 <hpc> (and likely that will be multiple times)
15:56:35 <biglambda> I see, when would that be. I added a putStrLn to the main function  Setup.hs but it doesn’t seem to execute.
15:57:20 <hpc> dunno
15:57:31 <hpc> i would question what you need Setup.hs for, honestly
15:57:53 <hpc> it's rare that you need to do anything special in it
15:58:50 <biglambda> Yeah I’m trying to make this package cabal-macosx work
15:58:56 <Cale> poor Setup.hs, nobody loves you :(
15:59:07 <biglambda> Building a mac app 
15:59:18 <kadoban> I've never been quite clear what Setup.hs does or why or when you need it, heh.
15:59:18 <biglambda> It’s a bit bit-rot.
15:59:54 <hpc> it feels a lot like cabal was at some point modeling itself after autoconf
16:00:21 <biglambda> I’m not a big fan of our current system :(
16:00:50 <Cale> Setup.hs basically lets you program how Cabal performs the various tasks involved in building your package.
16:01:28 <Cale> Setup.hs is actually older than the cabal-install program
16:01:44 <hpc> ooooooh
16:01:49 <kadoban> Was it what people used before cabal-install existed or something, or is that not really accurate?
16:01:54 <Cale> yes
16:02:03 <Cale> For a while anyway, as I recall
16:02:18 <kadoban> Interesting
16:02:35 <biglambda> I would expect that cabal would run it several times everytime I build.
16:08:40 <Squarism> You know the feeling of "This could be done more effective / better, but i lack the knowledge and where to look it up". I get that all the time with haskell. I use Intellij IDEA because i havent heard of a "better" alternaitve. Ive made do wo State, Reader, Writer etc monads - cus i manage. I use the rather primitive HUnit. I sprinkle trace statements allover my code - cause its alteast some logging. Etc. 
16:10:13 <Squarism> I really want to learn how to work effectively with haskell - as in produce apps effectively
16:10:18 <edwardk> Zemyla: sorta
16:10:20 <edwardk> :t Control.Lens.Level.levels
16:10:21 <lambdabot> (Indexable Int p, Applicative f) => ATraversal s t a b -> p (Level () a) (f (Level () b)) -> s -> f t
16:10:49 <edwardk> that takes a traversal then evilly turns it into a breadth first traversal of 'levels'
16:10:55 <edwardk> :t Control.Lens.Level.ilevels
16:10:57 <lambdabot> (Indexable Int p, Applicative f) => AnIndexedTraversal i s t a b -> p (Level i a) (f (Level j b)) -> s -> f t
16:11:08 <edwardk> that version works with indexed traversals
16:11:36 <Squarism> ..that is: more application programming than going deep into abstractions i dont need (yet).
16:11:49 <Squarism> Where do one read/look?
16:21:14 <dgpratt> seems like most flavors of Haskell regex use bytestrings; I'm not sure if I should be surprised by that or not
16:21:33 <hpc> i am surprised at caring about regexes in haskell
16:21:53 <dgpratt> hpc: you'd use a parser?
16:22:04 <hpc> pretty much always, i think
16:22:28 <dgpratt> what if you want to allow specifying a pattern via a command line argument?
16:24:20 <hpc> haven't ever had to do that
16:24:30 <hpc> but then i might use regexes, admittedlly
16:28:33 <geekosaur> most flavors of haskekll regex defer to C functions which take what Haskell calls bytestrings
16:28:34 <Zemyla> hpc: A DFA-based parser has some desirable characteristics, like linear parsing times.
16:33:04 <Zemyla> Also, a regex is what you get when you have an applicative parser with no fixpoints, so it resembles a tree.
16:41:33 <NemesisD> does GADTs and TypeFamilies imply some other extensions? I have a module that fails to typecheck when gadts or typefamilies is enabled
16:42:42 <hpc> can you paste it?
16:44:32 <monochrom> Amusingly, yes, GADTs implies GADTSyntax XD
16:45:11 <monochrom> I think that was all, no other implications.
16:46:22 <NemesisD> weird...
16:46:35 <monochrom> The type error disappeared? :)
16:46:38 <NemesisD> i can't paste it, this is deep in a large proprietary project. i guess ill keep poking at it
16:47:29 <monochrom> You can apply the subtraction method. Delete code and still keep the type error.
16:49:50 <NemesisD> always this sort of maddening thing happens late on a friday
16:50:38 <monochrom> This is why theoretical physicists avoid work on Fridays altogether.
16:52:28 <NemesisD> genius
16:54:12 <orzo> GADTs seems to enable RankNTypes syntax-wise anyway
16:56:15 <monochrom> Not directly.
16:56:47 <monochrom> It won't accept "f :: (forall a. a -> a) -> ...". You will have to hide that in a GADT.
16:58:15 <orzo> Why do you need an explicit forall to use ScopedTypeVariables on functions?
16:58:35 <monochrom> To increase compatibility with Haskell 2010.
16:58:42 <hpc> how else are you going to quantify them?
16:58:50 <orzo> implicitly of course
16:58:51 <hpc> :t show
16:58:53 <lambdabot> Show a => a -> String
16:59:27 <hpc> hmm, bad example
17:00:41 <hinthint> I'm trying to get the type of a function in Haskell code using hint, but apparently I'm not using the typeOf function right: http://lpaste.net/351724
17:01:02 <hinthint> err, more specifically: http://lpaste.net/351724#line42
17:01:36 <orzo> :t typeOf
17:01:38 <lambdabot> Typeable a => a -> TypeRep
17:01:46 <monochrom> haha your nick hinthint
17:01:47 <geekosaur> typeOf (and Data.Typeable in general) does not currently work with polymorphic types
17:02:12 <monochrom> Unrelated typeOf
17:02:32 <geekosaur> ah
17:02:42 <orzo> isn't his error that he is treating typeOf as if it returns (Interpreter TypeRep)
17:02:55 <monochrom> I don't know the answer, but I sure want to know the current output.
17:03:34 <geekosaur> orzo, as monochrom said, wrong typeRep
17:03:36 <geekosaur> er, typeOf
17:03:45 <geekosaur> http://hackage.haskell.org/package/hint-0.6.0/docs/Language-Haskell-Interpreter.html#v:typeOf
17:03:45 <orzo> o
17:04:15 <geekosaur> it'd producing MonadInterpreter m => m String
17:05:04 <hinthint> geekosaur is correct
17:05:25 <hinthint> monochrom: ; )
17:06:56 <monochrom> @type let {f = head; g = f [f]} in g
17:06:58 <lambdabot> [a] -> a
17:07:21 <monochrom> What output did you get?
17:07:45 <schoppenhauer> hi. is there a codewalker for template haskell? that is, a thingy which I can pass a haskell source code and it will give me the AST such that I can manipulate it?
17:09:24 <orzo> haskell-src-exts ?
17:09:49 <schoppenhauer> orzo: thank you!
17:10:12 <orzo> actually, you said template haskell
17:10:39 <orzo> template haskell has it's own syntax tree type and you can make it using [| |] quotes
17:11:13 <schoppenhauer> yes, but I want to parse some given code, and return a manipulated version of it (for fun and profit)
17:11:48 <schoppenhauer> not sure whether I can pattern match on quotes
17:11:49 <orzo> well i don't think the src-exts parse is type-compatible with template haskell
17:12:23 <schoppenhauer> if I have some expression in quotes inside template haskell, will I get its AST?
17:12:50 <orzo> the [| |] quotes evaluate to an AST
17:12:53 <geekosaur> http://hackage.haskell.org/package/haskell-src-meta
17:13:10 <geekosaur> generates TH AST instead of h-s-e's own AST
17:16:40 <schoppenhauer> orzo: ok, so [| … |] basically parses the haskell code … and gives me the TH AST, right?
17:16:58 <orzo> yes
17:17:14 <schoppenhauer> orzo: thank you.
18:32:50 <athan> could mapMaybe be generalized to prisms or something?
18:35:47 <glguy> if anything it would generalize with a traversal
18:35:54 <athan> or like... traverseKinda lol
18:35:56 <monochrom> @type mapMaybe
18:35:57 <athan> hmm
18:35:57 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:36:00 <glguy> but toListOf already works
18:36:11 <athan> ahh awesome, thank you glguy
18:36:20 <glguy> err not traversal
18:36:23 <glguy> fold
18:36:44 <athan> ?~? I still have some learning to do then
18:36:44 <lambdabot>  I still have some learning to do then
18:36:52 <athan> lol
18:37:03 <monochrom> EH?! What is that command?!
18:37:16 <athan> well, that's the expression I was making I think
18:37:25 <athan> lambdabot loves confusion I guess :P
18:37:34 <athan> er, echos confusion*
18:38:00 <lucasem> ?-? confusion
18:38:00 <lambdabot>  confusion
18:38:06 <lucasem> literally
18:38:28 <athan> ?*? test
18:38:28 <lambdabot>  test
18:38:31 <athan> hrm
18:44:16 <newbie36> Hi, I am trying to understand recursion scheme
18:45:20 <newbie36> In particular, chronomorphism. I am reading https://github.com/ekmett/ekmett.github.com/blob/master/haskell/Chronomorphism.hs, but on 285 f m w are all Functor instead of Monad/Comonad, is that a typo?
18:58:37 <pplorins> hello everyone
18:58:50 <lambdabot> Hello.
19:01:47 <geekosaur> fwiw that earlier thing was likely @@ / ?? (echo text expanding @/? commands embedded in it)
19:02:23 <lolisa> Hello.
19:10:38 <saltz> I'm trying to install hsdev via stack for sublime haskell.  I get " haskell-src-exts-1.17.1 must match >=1.18.0 && <1.19.0 (latest applicable is 1.18.2)" and a similar error for simple-log.  I've tried requiring higher versions in global stack.yaml but I guess other packages require that version.  what am I missing?
19:12:08 <geekosaur> check what resolver you're using?
19:13:10 <saltz> lts-7.16
19:15:15 <geekosaur> yep. probably need a nightly, or a local stack.yaml with the newer versions as extra-deps
19:15:40 <saltz> got it, thanks
19:15:43 <geekosaur> nightly indeed has haskell-src-exts-1.18.2
19:16:00 <saltz> I see -- now I know what to look for next time.  thank you.
19:21:40 <MarcelineVQ> is this a good way to create an arbitrary number of IO actions with a limited number working at a time? http://lpaste.net/351728 Can you think of a better one?
19:22:01 <MarcelineVQ> *concurrent IO actions
19:22:52 <monochrom> Does writeTBQueue block when the queue is full, waiting for an empty slot?
19:23:25 <MarcelineVQ> yes
19:25:21 <monochrom> Yes this is a good way.
19:26:13 <monochrom> There are two other good ways, one is dual to yours, and one is dual to both. But no significant advantage.
19:26:22 <edwardk> lolisa: (Cofree f) is the comonad in question, (Free f) is the monad
19:26:38 <MarcelineVQ> That's good news, it was a bumpy road to this solution but worthwhile
19:27:08 <edwardk> er Cofree w and Free m
19:27:18 <edwardk> Cofree w is a comonad whenever w is a functor
19:27:24 <edwardk> Free m is a monad whenever m is a functor
19:27:40 <monochrom> The dual to yours is initially put 5 ()'s into a queue. Then withPool dequeues, runs job, enqueues. Think of each () as a license to run. In this case you don't need a bounded queue, any queue will do.
19:28:33 <glguy> QSem bundles that behavior up
19:28:53 <monochrom> The dual to both is you don't queue ()'s. You queue jobs. Then have 5 threads, each thread snatches a job from the queue, do it, repeat. (aka processor farm, aka thread pool.)
19:29:03 <edwardk> fwiw the chronomorphism thing turns out to be fairly boring
19:29:39 <edwardk> g_hylo and knowing about how to build distributive laws or the more interesting style of adjoint folds is where its at.
19:30:13 <edwardk> all the other whatevermorphisms are variants on cata/ana/hylo just mangled by using a distributive law in a stylized manner.
19:32:01 <edwardk> g_chrono uses the ability to promote a distributive law of f over w into one of f over (Cofree w) and one of m over f into one of (Free m) over f, then its just a generalized hylomorphism
19:32:40 * monochrom is invariant under chromomorphisms :)
19:33:28 <MarcelineVQ> monochrom, glguy: thank you, concurrency is new stuff for me. I was going to look at semaphores next since they were mentioned in simon's book and relate to the problem I want to solve but had no idea base already had them
19:47:30 <markasoftware> generally speaking should i use my distrobution's haskell packages or stack/cabal?
19:48:09 <glguy> markasoftware: You should pick one of the two and stick with it
19:48:16 <kadoban> markasoftware: stack/cabal
19:48:17 <geekosaur> unless you are building something for your distribution, avoid using its packages; they will usually be out of date, and upgrading any libraries installed as part of it will cause major pain
19:48:57 <kadoban> The GHC that comes in OS package managers tends to be horribly out of date as well, though some aren't so bad.
19:49:16 <markasoftware> is ghc 8.0.1 outdated?
19:49:23 <markasoftware> that's what arch has right now (and what im running)
19:49:27 <geekosaur> yes, actually :) 8.0.2 is out
19:49:55 <markasoftware> why do distrobutions recommend to use their packages?
19:50:37 <glguy> Do they? Maybe it says way underneath
19:50:38 <geekosaur> arch is better than most but that has its own sting in the tail: you build something with arch's library packages, then they upgrade them to a newer version and suddenly your stuff is breaking for no obvious reason
19:51:20 <markasoftware> from gentoo docs:
19:51:26 <markasoftware> " Warning
19:51:28 <markasoftware> The Gentoo Haskell team does not recommend the use of dev-haskell/cabal-install to install Haskell packages. Instead, emerge should be used. If you need a package that isn't in the main Gentoo tree, it may be present in the Haskell overlay. If not, please file a bug/issue, or ask us in #gentoo-haskell on IRC!"
19:51:37 <geekosaur> (this actually happened to xmonad, they decided to rev the X11 bindings to 1.7 --> KABOOM arch xmonad users started crashing all over the place. granted they did override xmonad's dependency spec which was there specifically to avoid this outcome...)
19:51:54 <glguy> markasoftware: Sounds like you could ask them why they recommend that in #gentoo-haskell
19:52:48 <isd> Hey. Are there monad transformer variants of the Get/Put types in Data.Binary somewhere?
19:52:51 <glguy> But if you're using Arch, then the answer might not apply
19:52:53 <kadoban> That sounds quite limiting, as soon as you want to use something that's not in their package manager, which is going to be not very long ... I don't know how you'd even proceed without just switching to using cabal/stack.
19:53:04 <geekosaur> markasoftware, the general rule is if you use the distro's compiler package then use its libraries and not externally installed ones
19:53:27 <markasoftware> geekosaur: why is that?
19:53:30 <geekosaur> but this will limit you to what versions your distro offers, and trying to upgrade those will be painful
19:53:55 <Axman6> isd: i dont believe so
19:54:16 <isd> (came into the conversation in the middle, so maybe I'm missing important context, but: I'm on Arch and basically use the distro packages for ghc and cabal, and cabal for everything else).
19:54:40 <geekosaur> (this isn't even specific to Haskell; Perl, Python, Ruby, etc. will also tell you this. because the distro  package manager only understands *its* packages, and mising and matching versions installed from different places always causes confusion at best and bizarre errors or crashes at worst)
19:54:43 <isd> Axman6: that's what I was afraid of. Do you know if there's a specific reason for that, or just "it wasn't written that way"
19:55:03 <markasoftware> i don't understand, why do the distros even provide these packages then?
19:55:24 <isd> markasoftware: they're useful if some application they want to package depends on them
19:55:29 <geekosaur> because they have packages that may require them, at least for building. (pandoc is widely packaged, for example)
19:57:17 <Axman6> isd: what need do you have for Get/Put as a transformer?
19:57:20 <geekosaur> you dont need ghc to use pandoc, but if they want to build a pandoc package they need ghc --- and it's far easier for the distribution maintainer if the build dependencies are already packaged
19:58:43 <geekosaur> another issue, relevant for gentoo (and other "ports" style distributions): if you install their ghc and then install libraries using cabal, then emerge-ing something else that uses ghc may potentially build with your library instead of gentoo's (*) and then they have a support nightmare on their hands if that breaks it
19:58:47 <markasoftware> well i guess ill take your advices and install with stack
19:58:52 <markasoftware> that's preferred over cabal now right?
19:59:02 <geekosaur> (*) granted, we strongly discourage global library installs so this shouldn't normally happen
19:59:07 <geekosaur> somtimes
19:59:23 <isd> Axman6: I went and wrote something with a type like (MonadGet m, MonadThrow m, ...) => m ..., then went looking for something I had expected to exist... so I can't figure out how to actually instantiate that type (if it's even possible).
19:59:29 <kadoban> markasoftware: By some, myself included. Others disagree.
19:59:29 <geekosaur> cabal new-install is even better than stack but still has some weak spots
19:59:49 <isd> (there is a third constraint there that's another MTL-style class of my own construction)
19:59:58 <Axman6> isd: can you use something like ttoparsec?
20:00:07 <Axman6> attoparsec*
20:01:14 <isd> I'm not wedded to the Get/Put monads; open to changing my strategy. I need to look at attoparsec a bit closer to see if it meets my needs.
20:01:32 <isd> Also, having a symmetric problem with Put.
20:01:59 <Axman6> get/put have quite specific uses, they're not designed as generalised encoding and decoding monads (though are sometimes used as such)
20:02:22 <isd> Oh?
20:02:26 <Axman6> basically it's used for serialising and deserialising haskell values
20:02:38 <Cale> markasoftware: They're both pretty good. Stack does a bit more in the form of managing project-specific GHC installs for example, but there are reasons to still prefer using the cabal-install tool. It's worth pointing out that both of them use Cabal (as a library).
20:03:24 <markasoftware> does it work to have system ghc and also per-project ghc?
20:03:37 <Axman6> markasoftware: if you're just starting out with haskell, you may find stack easier to get started with (it optimises for the common cases being easy), later when you need it, using Cabal alone will give you more power
20:03:45 <geekosaur> it works but may be confusing to you
20:03:46 <Cale> You can have as many ghcs as you'd like to spend the disk space on
20:03:51 <markasoftware> yeah i will start with stack for now
20:04:04 <geekosaur> especially if you try to run ghc or ghci yourself instead of using the appropriate wrapped stack/cabal command
20:04:20 <geekosaur> because you will get the wrong version with the wrong libraries visible
20:04:35 <markasoftware> well ill just use the stack command then
20:05:31 <Cale> For me, stack ends up kind of in an awkward place where it's a bit better suited to larger projects, but then we're using nix to manage our larger projects. :)
20:05:56 <Fylwind> what exactly is *cunning* newtype deriving?
20:06:28 <Fylwind> like, what is the adjective "cunning" supposed to mean? o.o
20:07:02 <markasoftware> "Marked by or given to artful subtlety and deceptiveness"
20:07:42 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-derived-instances-for-newtypes
20:08:38 <Cale> I'm not sure the word "cunning" means anything technical on its own, it's just sometimes GHC's error messages can be a bit colourful :)
20:10:16 <Fylwind> Cale: Reminds me of the “My brain just exploded” message
20:10:45 <buglebudabey> would anyone be able to tell me why my hakyll site isn't properly showing LaTeX based on my configurations? site:https://aneksteind.github.io/posts/2015-08-12-spqr.html  setup: http://lpaste.net/3272286813468753920
20:10:52 <geekosaur> it's not clearly stated in the documentation but there is a hint that the current deriving mechanism is smarter than the original one ("not through this new mechanism")
20:11:41 <geekosaur> I therefore presume "cunning" refers to the fact that the current mechanism is smarter than the original (which iirc was a simple-minded wrap/unwrap)
20:13:06 <Cale> I think the original original didn't consider very well the structure of anything, and simply allowed you to use the instance dictionaries without checking that you could actually write an instance.
20:13:14 <geekosaur> ...another hint is at the end where it talks about Read/Show/Typeable/Data; original newtype deriving was just a generalization of the standard-specified derivation used for those 4, iirc)
20:14:02 <geekosaur> also I think that because we have type roles, it more or less knows when it can cheat and unsafeCoerce >.>
20:14:19 <glguy> the current implementation doesn't attempt to write the instance either, but relies on the theory around type roles being sound, afaik
20:17:19 <Cale> glguy: yeah
20:38:03 <athan> What is the abstract difference between `Prism` and `APrism`?
20:38:32 <athan> I see `Market` and `Choice` thrown in there, but I don't quite have the chops to understand their respective utilities
20:38:59 <glguy> Prism requires the RankNTypes extension to take one as an argument to a function
20:39:32 <glguy> APrism is a rank-1 type (no quantifiers hidden away inside like Prism)
20:40:12 <athan> ahh! that's right, sorry glguy, thank you
20:40:40 <glguy> apology accepted
20:52:51 <dmwit> I'm pretty sure they referred to newtype deriving as "cunning" ever since the beginning, sometimes even in error messages.
20:53:10 <dmwit> (something like "couldn't derive that class, even with cunning newtype deriving")
20:53:58 <dmwit> Oh. That's what started this whole conversation.
20:54:09 <mrkgnao1> I'm at the end of my wits here. I built the Write You A Scheme executable from the repo, but stack simply says "file does not exist" when I try to run the (successfully built) executable
20:54:32 <mrkgnao> pretty sure this has something to do with my running NixOS
20:59:50 <dmwit> I don't know much about stack. But I suspect that somebody who does would want more details.
21:00:11 <dmwit> What's the exact error? Does stack have a verbosity flag that you could turn on to get more information? What's in your configuration files?
21:00:27 <dmwit> What are the exact commands you run?
21:00:29 <dmwit> etc.
21:00:39 <mrkgnao> Stack builds everything fine, although I'll try --verbosity debug.
21:01:04 <mrkgnao> I think there's something like a linker error going on because of the general funkiness associated with Nix.
21:01:45 <mrkgnao> I encounter the problem when I try to run, say, the .stack-work/whateverpath/scheme executable that stack builds.
21:03:16 <dmwit> I suspect you should use stack to run it.
21:03:30 <dmwit> e.g. `stack run foo` or similar. I don't know exactly what `stack` calls the command.
21:03:57 <glguy> exec
21:11:16 <mrkgnao> dmwit: glguy: tried that
21:11:23 <mrkgnao> same error.
21:11:56 <mrkgnao> strace says it can't find the glibc, so I'm rebuilding it with --nix-packages "glibc"
21:13:02 <mrkgnao> whoops, didn't help
21:27:02 <mrkgnao> I'm sorry for wasting y'all's time. The error was from the program itself. :/
21:27:15 <mrkgnao> thanks for helping, glguy and dmwit 
21:33:20 <mrkgnao> why don't interpreters use the State monad instead of Reader with local everywhere?
21:51:24 <Ptival> interpreters for?
23:11:49 <geekosaur> lots of programs use Reader/ReaderT without using local. the main point is that ReaderT is faster if you aren't changing the state, since it doesn't have to arrange for new state to be propagated
23:18:23 <pplorins> hi all , a very newbie question:  what’s the difference between + and ++ ?   I know + is used for mathmatic operation like +-*/ and ++ can be used for list operations , but is there something more important difference ?
23:19:07 <geekosaur> (+) is a typeclass method of Num, so any type with a Num instance can use it. (++) is specific to lists
23:20:25 <pplorins> great !  thanks a lot .
23:30:49 <mniip> pplorins, more generally the two are different functions
23:30:55 <mniip> like 'negate' and 'reverse'
23:40:01 <pplorins> @mniip thanks
23:40:01 <lambdabot> Unknown command, try @list
23:44:03 <_sras_> Can I call a template haskell call from code generated using template haskell?
