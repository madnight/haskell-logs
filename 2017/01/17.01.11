00:19:55 <purelazy> What's the way to check for file not found exception?
00:25:27 <tA> New to Haskell, trying to figure out how to nicely store arbitary cells in a grid (Connected adjacently, just don't want to store the entire grid in an array) can someone give me some pointers? Thanks
00:26:15 <purelazy> like an array of arrays
00:27:15 <pavonia> purelazy: I guess System.IO.Error.isDoesNotExistError is the way to go
00:27:28 <tA> I don't want to use a 2D array for it because 90% of the cells in a square grid I don't need
00:28:04 <tA> Pretty much just a bunch of linked types but I'm not sure how to go about that in Haskell
00:28:56 <EvanR> tA: common task, solve with IntMaps
00:29:11 <kadoban> tA: I'm not 100% following the goal, but a Set (Int, Int)  could make sense, or any of a few other related things
00:29:22 <EvanR> or Map from tuple of Ints to X
00:29:59 <EvanR> worse case scenario pull out a functional graph!
00:30:00 <kadoban> Ya, Map (Int, Int) Whatever, or IntMap are usually more efficent, but slightly less flexible, ways to go. The key is to use a dictionary type that allows sparseness.
00:30:18 <purelazy> tA: I googled dimensional sparse arrays haskell - it came up with some stuff
00:30:46 <purelazy> e.g. Map (Int, Int)
00:31:18 <purelazy> Judy bindings (a C library that implements fast sparse dynamic arrays) for Haskell presenting APIs conforming as much as possible to the existent Haskell library interfaces, like Data.Map and Data.Array.MArray.
00:52:42 <purelazy> pavonia: Thanks for that.
00:54:48 <purelazy> The problem I had was using the old "Control.Exception.try" instead of the new and improved "System.IO.Error.tryIOError"
01:00:22 <BernhardPosselt> im trying to make some connections in my mind for functor, monad and comonad: in java 8 there's there's an Optional type which gives you map (Functor?), flatMap ofNullable (Monad?) and get (Comonad?)
01:01:07 <BernhardPosselt> get throws a null pointer exception if its empty so I'm kinda wondering how haskell solved this for maybe
01:01:19 <BernhardPosselt> regarding comonads
01:01:21 <Philippa> we don't define it on Maybe
01:01:28 <lol-icon> BernhardPosselt: Maybe doesn't have a lawful Comonad instance.
01:01:48 <lol-icon> BernhardPosselt: The main example of comonads I can think of is zippers.
01:01:53 <BernhardPosselt> lol-icon: i see :)
01:01:57 <EvanR> "get" isnt the key operation anyway
01:02:10 <EvanR> but you still need it to be a comonad
01:02:38 <EvanR> regular list also isnt a comonad
01:02:55 <lol-icon> Infinite streams are comonads, though. :-p
01:03:12 <BernhardPosselt> because they are kinda like basic types which you cant extract any further?
01:03:15 <EvanR> java "get" on Optional sounds like "fromJust" which is know to explode in your face- dont use it 
01:04:20 <EvanR> youre supposed to deconstruct Options using a case or switch, which ensures code that assumes its not empty doesnt run when it is
01:04:44 <BernhardPosselt> right
01:06:05 <BernhardPosselt> as for extract: its defined for a type and you just directly access the data type and return it?
01:06:37 <EvanR> extract method of Comonad returns the currently selected element, every comonad has a notion of "currently selected element"
01:07:27 <BernhardPosselt> so basically you could define it for a list? :D
01:07:34 <EvanR> you cant
01:07:36 <BernhardPosselt> if you know what the currently selected element is
01:07:46 <BernhardPosselt> empty list would be interesting however
01:07:47 <EvanR> list can be empty, theres nothing to return
01:08:11 <EvanR> a common oversight which causes the program to crash
01:08:16 <EvanR> either right now or later
01:08:19 <BernhardPosselt> how does it work for infinite streams then?
01:08:25 <BernhardPosselt> cant they be empty too?
01:08:29 <EvanR> no
01:08:37 <BernhardPosselt> or does infinite mean there's always a value
01:08:41 <EvanR> data Stream a = Cons a (Stream a)
01:09:03 <EvanR> theres always a next element
01:09:40 <BernhardPosselt> i see, infinite stream != java stream
01:09:58 <EvanR> right, this is a pure data structure
01:10:05 <BernhardPosselt> is it more closely related to observables?
01:10:18 <EvanR> is what
01:10:27 <BernhardPosselt> forget it, probably isnt :D
01:10:45 <EvanR> if you want the stream to possibly end, you can use lists
01:10:55 <EvanR> which is potentially infinite too
01:11:06 <BernhardPosselt> i was wondering if it matches a stream of events which is modelled using Observables in some languages
01:11:22 <BernhardPosselt> e.g. stream of mouse click events
01:11:26 <EvanR> no, the assumption here is usually theres no IO involved
01:11:43 <EvanR> a Stream would be like the output of a random number generator
01:11:56 <EvanR> or a unique name generator
01:12:06 <EvanR> or an enumeration of an infinite space
01:12:51 <BernhardPosselt> ok, i think i got the concepts :D thanks for your help
01:13:13 <EvanR> the deconstruction thing i mentioned earlier expands to a really elegant and powerful way to operate on data
01:13:42 <EvanR> by doing a case or switch on a "view" of abstract data, you know youre dealing with an interpretation that is solid
01:13:57 <EvanR> and you dont have to keep reimplementing the view
01:22:27 <bwe> Hi, I want to get the greatest common divisor of two fractions, in other words: the greatest common denominator. What's the base case? I think it's any denominator with the numerator 1: 1/6 and 1/3 for instance would have the fracGcd 1/6. For that I would just inverse the fraction and apply gcd: invFrac frac = 1/((frac)) -- invFrac (1/6) returns 6.0 but not invFrac 1/6   <--- How can I make invFrac 1/6 work 
01:22:33 <bwe> (which seems more intuitive)?
01:23:06 <eklavya> is threadscope the only way to analyze .hp files?
01:23:32 <EvanR> bwe: you want... the least common multiple?
01:23:40 <EvanR> > lcm 3 6
01:23:42 <lambdabot>  6
01:23:54 <EvanR> > 6 `rem` 3
01:23:57 <lambdabot>  0
01:23:57 <EvanR> > 6 `div` 3
01:24:01 <lambdabot>  2
01:24:05 <EvanR> 1/3 = 2/6
01:24:16 <EvanR> so lcm, not gcd
01:24:30 <eklavya> stack install threadscope failed with syntax error
01:24:36 <eklavya> /usr/include/signal.h:79: (column 19) [FATAL]
01:24:36 <eklavya>       >>> Syntax error!
01:24:36 <eklavya>       The symbol `bsd_signal' does not fit here.
01:25:41 <mfukar> bwe, you are describing the max of two values, or am I understanding you wrong?
01:27:19 <EvanR> mfukar: lowest common denominator is the smallest denominator two fractions can have at the same time
01:27:45 <EvanR> 1/3 and 1/5, the answer would be
01:27:48 <EvanR> > lcm 3 5
01:27:51 <lambdabot>  15
01:28:02 <EvanR> so lcm, not max
01:28:33 <EvanR> i.e. 5/15 and 3/15
01:29:40 <mrkgnao1> > lcm 0 1
01:29:42 <lambdabot>  0
01:30:01 <EvanR> you wouldnt have denom 0 so lcm 0 1 would never come up
01:30:42 <mrkgnao> yeah
01:31:51 <EvanR> you actually dont need to use lcm to get the denoms the same, you could just multiply
01:34:57 <bwe> EvanR: Right. 
01:34:58 <bwe> > 2 / 60 :: Rational
01:35:00 <lambdabot>  1 % 30
01:41:15 <eklavya> how to install ghc utils with stack?
01:42:42 <cocreature> eklavya: what is ghc utils supposed to be?
01:42:59 <eklavya> cocreature: I need hp2ps
01:43:06 <eklavya> docs say it's part of ghc/utils/
01:43:22 <EvanR> supposed to come with ghc
01:43:33 <cocreature> it’s in ~/.stack-work/programs/$arch/ghc-$version/bin/hp2ps
01:43:47 <eklavya> oh
01:43:53 <eklavya> thanks cocreature :)
01:45:27 <eklavya> cocreature: there is no programs dir :(
01:47:19 <cocreature> eh ~/.stack/programs
01:47:21 <cocreature> not stack-work
01:47:46 <cocreature> and you need to replace $arch and $version with the corresponding values
01:47:55 <eklavya> got it
01:47:57 <eklavya> thanks :)
01:53:58 <bwe> What is the real problem I try to solve? I have a list of pairs of fracs. Give me that with the least denominator. 
01:54:01 <bwe> > map (\(x, y) -> x / y :: Rational) [(8/94, 2/41), (6/71, 2/41)]
01:54:03 <lambdabot>  [82 % 47,123 % 71]
01:54:57 <bwe> Here, the first pair, namely (8/94, 2/41) should be returned only, as 47 (of the first pair) is a smaller denominator than 71 (of the second pair). Do you see, what I want?
01:56:56 <bwe> So, next I think, I should retrieve the denominators only and pick the least. Then, filter for values with that denominator only. Eventually choose that with the highest total value, that would be 82 % 47 in the given example.
01:57:22 <quchen_> > maximumBy (comparing (\(x,y) -> denominator (x/y))) [(8/94, 2/41), (6/71, 2/41)]
01:57:25 <lambdabot>  (6 % 71,2 % 41)
01:58:06 <quchen_> bwe: ^
01:58:42 <quchen_> > id @Int
01:58:44 <lambdabot>  error:
01:58:44 <lambdabot>      Pattern syntax in expression context: id@Int
01:58:44 <lambdabot>      Did you mean to enable TypeApplications?
01:58:50 <quchen_> Cale: Any chance we can enable that extension? :-)
01:59:40 <lol-icon> Is there a typed distinction between functions that take explicit vs. implicit type arguments?
01:59:48 <lol-icon> Or are type arguments always optional?
02:00:18 <MarcelineVQ> quchen_: there's unresolved parsing issues with @ and patterns causing some aprehension about having lambdabot use TypeApplications appearantly, related to https://github.com/ghc/ghc/blob/574abb7173d85ee527161cbe36fc0f9535372f0f/compiler/parser/Lexer.x#L533 specifically
02:00:44 <quchen_> Pity! But thanks for the info.
02:00:53 <MarcelineVQ> I'd like to see TypeApplications available in lambdabot as well though, they're pretty amazing
02:02:09 <MarcelineVQ> for example an earlier question about first's weird signature had a nice place to use them:  :t first @(->)    first @(->) :: (b -> c) -> (b, d) -> (c, d)
02:03:56 <lyxia> lol-icon: types are inferred and then the compiler always works with explicit type applications.
02:04:57 <merijn> lol-icon: Before GHC8 it wasn't possible to explicitly provide type arguments at all
02:05:47 <merijn> tbh I think explicit type applications have a harmful effect in that a lot of people seem to be using them without really understanding what they're doing beyond "made my error go away"
02:06:29 <merijn> MarcelineVQ: You could accomplish something similar with asAppliedTo
02:06:46 <merijn> > first `asAppliedTo` (const undefined)
02:06:48 <lambdabot>  error:
02:06:49 <lambdabot>      • No instance for (Typeable b0)
02:06:49 <lambdabot>          arising from a use of ‘show_M487462005895920010520003’
02:06:52 <merijn> hmm
02:06:58 <merijn> > first `asAppliedTo` id
02:07:01 <lambdabot>  error:
02:07:01 <lambdabot>      • No instance for (Typeable b0)
02:07:01 <lambdabot>          arising from a use of ‘show_M401665546551318294620014’
02:09:44 <lyxia> merijn: oh? I'm surprised this is something you can abuse without understanding it
02:10:36 <MarcelineVQ> so far I've used it mostly to examine type signature substitutions in ghci, in code I've used it to avoid putting in undefined, because it's shorter :>
02:11:26 <MarcelineVQ> You can apply the types of arbitrary type variables which is pretty neato:  fmap @_ @Int :: Functor t => (Int -> b) -> t Int -> t b
02:11:44 <EvanR> oldie but goodie blog post on type systems... http://blog.steveklabnik.com/posts/2010-07-17-what-to-know-before-debating-type-systems
02:12:40 <bwe> quchen_: Thanks. That seems to do the job. I want to understand. Currently, I don't.
02:12:45 <bwe> > denominator (8/94)
02:12:48 <lambdabot>  47
02:13:24 <bwe> My ghci gives me for that a   Variable not in scope: denominator :: Double -> t  error.
02:14:09 <EvanR> denominator (8/94) :: Integer
02:14:17 <EvanR> hmm
02:14:29 <EvanR> :t denominator
02:14:30 <lambdabot> Ratio a -> a
02:14:32 <MarcelineVQ> bwe: Data.Ratio  http://hayoo.fh-wedel.de/?query=denominator
02:14:56 <EvanR> where is Double -> t coming from
02:15:02 <EvanR> oh defaulting to Double
02:17:49 <MarcelineVQ> merijn: I'm interested in knowing more about how it could be harmful, and if there's things I should be avoiding. I've not had a case of using them to assuage errors that I'm aware of, is it possible to elaborate on that?
02:18:29 <eklavya> thanks Axman6 EvanR, I am able to get the memory profile and event log now :)
02:20:46 <mrkgnao> could any  users here help me get gloss working?
02:20:54 <mrkgnao> NixOS*
02:21:30 <EvanR> i figured you were dealing with nix or stack so didnt say anything
02:22:02 <EvanR> hopefully we dont end up solving nix / stack questions more than haskell questions
02:22:58 <merijn> MarcelineVQ: They can let you do things you can't with just type inference, but it comes at a cost, such as making your function API more brittle. Your type is now not only dependent on the order of argument application, but also on the order of type variables
02:24:02 <merijn> EvanR: I think that link skips one of the more heinous ones
02:24:23 <EvanR> "ones" ?
02:24:24 <merijn> EvanR: Often you get people who know a bit about type systems and then start talking about "type safety", without understanding what it means
02:24:45 <MarcelineVQ> Oh I see that does make sense, thanks merijn
02:24:51 <merijn> EvanR: type theory terms abused/misunderstood by people
02:24:59 <EvanR> well, what is type safety?
02:26:23 <merijn> EvanR: Type safety is a relation between a type theory (system) and an semantic model which asserts that any well-typed term has it's semantics defined in said semantic model. That is, well-typed terms cannot exhibit behaviour outside of the semantic model
02:26:34 <quchen_> bwe: denominator gives you the denominator of a Ratio.
02:26:43 <merijn> Note, in particular, that there is no restriction at all on what the semantic model actually *is*
02:27:03 <merijn> C is perfectly type safe in the semantic model of "memory is sequential mutable bytes that I can access"
02:27:53 <merijn> People calling languages type safe often don't specify the model their type safety claim refers too, often having some vague imprecise notion of "stuff I don't want to happen" as model
02:27:57 <EvanR> that model doesnt seem to correspond much to how C works
02:28:32 <merijn> EvanR: Well, sure, it's not the operational model that the C standard uses and C is *not* type safe with regards to that model
02:28:57 <merijn> EvanR: But that's entirely my point, to say anything about type safety you need both a language AND a model, just a language is not enough
02:29:29 <EvanR> stuff i dont want to happen... HMMM
02:29:41 <EvanR> that comes up a lot
02:30:05 <EvanR> i think close to 100% we dont have a clear understand of what we do want to happen
02:30:16 <EvanR> hence agile, extreme programming
02:30:33 <merijn> EvanR: No, most programmers, on principle, refuse to have any clue what their code will do before they execute it
02:30:39 <EvanR> identifying what we dont want to happen is like the bumper lanes at the bowling alley
02:30:58 <merijn> It's why I think compiler class is one of the most useful CS classes that a lot of people miss
02:31:25 <merijn> Because to write a compiler you HAVE to think about that stuff
02:31:32 <merijn> (Or get a failing grade :p)
02:32:33 <EvanR> aimless programming
02:34:53 <EvanR> haskell is like a universe where you kind of have to know what you want before you can start
02:38:34 <merijn> I'm confused, 65 packages using xml-conduit and not a single one appears to have an example of the simple kind of stuff I wanna do?
02:45:45 <mrkgnao> EvanR: I got it to work!
02:46:10 <mrkgnao> the packages: [...] bit in stack.yaml's nix section did the trick
02:51:02 <lpaste> bwe pasted “Get least common denominator.” at http://lpaste.net/4234544991705235456
02:51:42 <ur_> I'm following this tutorial: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html - creating a JSON library. And it occurred to me (perhaps wrongly), that it would be useful to have JValue be a functor
02:51:50 <bwe> quchen_: Okay, I understand what denominator does. I must be careful to put a ratio in parentheses. 
02:52:06 <EvanR> > lcm 94 41
02:52:07 <ur_> however, JValue isn't the right kind
02:52:08 <lambdabot>  3854
02:52:54 <EvanR> guess i dont know what leasts common denominator is referring to after all
02:53:31 <bwe> quchen_: (\(x, y) -> denominator (x/y)) -- This is a lambda function that loads fst value of the pair into x and snd into y (to apply denominator to the ratio of both).
02:53:54 <pavonia> ur_: How would you define an fmap for this type?
02:54:42 <EvanR> youd need acme-monofunctor
02:54:42 <Phillemann> In aeson, is there a way to map missing record fields of type "Maybe a" to Nothing in FromJSON?
02:54:55 <bwe> quchen_: What I don't get is `maximumBy (comparing ...)`. What does the comparing expect as argument?
02:55:34 <ur_> pavonia: fmap f (JString x) = JString $ f x        fmap f (JArray xs) = JArray $ fmap f xs 
02:55:36 <ur_> and so on
02:55:44 <ur_> I suppose it doesn't match the type
02:56:02 <EvanR> Phillemann: (.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)
02:56:24 <merijn> :t comparing
02:56:27 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:56:32 <ur_> EvanR: acme-monofunctor. interesting
02:56:34 <EvanR> when the field is there, youll have Maybe (Maybe a)
02:56:43 <EvanR> so then you join
02:56:52 <merijn> EvanR: acme-monofunctor? Is that a serious package?
02:57:02 <EvanR> i wouldnt be surprised
02:57:17 <merijn> oh, it was a joke :)
02:57:30 <Phillemann> EvanR: Of course, thanks!
02:57:30 <bwe> merijn: it expects b and a where `a` must be orderable.
02:57:30 <merijn> Pretty sure monofunctor exists, though
02:57:39 <pavonia> ur_: Right, that wouldn't work with this type
02:57:48 <merijn> bwe: No, it expects a function 'b -> a' and two 'b'
02:58:07 <merijn> bwe: Basically "if you give me a way to turn 'b' into something comparable, I'll compare two 'b'"
02:58:27 <ur_> EvanR: well there's this https://hackage.haskell.org/package/mono-traversable-1.0.1/docs/Data-MonoTraversable.html
02:58:41 <EvanR> i knew that
02:59:00 <ur_> I assumed as much
02:59:01 <EvanR> still, what would "fmap" do for JValue
02:59:25 <EvanR> what would its type be
02:59:49 <bwe> merijn: So the parentheses in `(b -> a)` tell me that it's a function?
03:00:51 <ur_> EvanR: Well yes, there's no way to define (a -> b) -> f a -> f b for JValue
03:01:02 <Phillemann> So "maybeExist v name = join <$> (v .:? name)"
03:01:13 <Phillemann> Should be another operator. .:?? or something :D
03:01:25 <EvanR> so many operators
03:01:46 <EvanR> join <$> (v .:? name) is about a long
03:01:52 <EvanR> as maybeExist
03:02:35 <EvanR> and that name is misleading because... its specifically for supporting a Maybe field
03:02:47 <Phillemann> See, an operator would be better. Needs no name :D
03:03:05 <EvanR> i have gotten complaints that haskell code cant be pronounced
03:03:11 <ur_> EvanR: I suppose the question was, how would I apply a function to the value contained in JValue. Is the answer simply pattern matching?
03:03:21 <spatial>  newtype Grid a = Grid { unGrid :: [[a]] }
03:03:22 <EvanR> "the value" ?
03:04:11 <EvanR> what kind of function
03:04:16 <spatial> Assume I have a Grid type. line and below are lists. What does this mean ? let (line : below')     = unGrid below
03:05:03 <ur_> EvanR: I suppose I want to define this. http://pastebin.com/gAerXmPG   
03:05:42 <EvanR> what is the type of f
03:07:27 <ur_> EvanR: Right. It can't be expressed I suppose
03:07:46 <EvanR> the operation as written doesnt make sense
03:08:00 <EvanR> you need to explore more what you want out of it
03:09:11 <ur_> EvanR: Because f can't be constraint as any one type?
03:09:11 <EvanR> at the same time, this is a good time to see what about JValue isnt functorial besides the kind
03:09:46 <EvanR> er no... youre applying f to a String, a Bool, and a number
03:10:39 <osa1> does this error message look familiar to anyone: `SQLite3 returned ErrorBusy while attempting to perform close: unable to close due to unfinalized statements or unfinished backups` I'm getting this while using persistent with sqlite backend
03:11:28 <bwe> > :t maximumBy
03:11:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:11:38 <bwe> >:t maximumBy
03:11:42 <osa1> :t maximumBy
03:11:44 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
03:12:07 <lyxia> spatial: below can't be a list here.
03:12:16 <bwe> if you give me a way to turn two `a` into some order, I will fold a foldable `a` into `a`. -- So, what's really going on here?
03:12:19 <ur_> EvanR: That's what I meant. Perhaps I didn't express it properly. There isn't a typeclass to which I could constrain the value inside JValue. Or maybe I'm just talking nonsense 
03:13:00 <bwe> I presume (a -> a -> Ordering) to be the `(comparing (\(x, y) -> denominator (x/y)))` function. Is that correct?
03:13:24 <lyxia> bwe: (a -> a -> Ordering) is a way to compare two a.
03:13:41 <EvanR> ur_: whats an example operation you want to actually do
03:14:33 <EvanR> e.x. apply a string manipulation to all strings in the JValue tree, ignoring everything else
03:14:54 <ur_> EvanR: yeah, that's a good example
03:15:13 <EvanR> e.x. apply a string operation if this is a string, otherwise do nothing (totally different but similar)
03:16:41 <ur_> EvanR: so basically, apply a function to JValue if it can be applied, otherwise return JValue?
03:16:51 <ur_> EvanR: so basically, apply a function to JValue if it can be applied, otherwise return the input?
03:17:03 <EvanR> in my second example, it could be applied but wasnt
03:18:02 <EvanR> one thing you could narrow it down to is, if you have a function that operates on one of the 5 json primitives, apply that to everything in the tre
03:18:26 <EvanR> that function would have type (JPrim -> JPrim) -> JValue -> JValue
03:19:16 <EvanR> that seems to have limited utility because you dont know where you are in the tree
03:20:33 <EvanR> clojure has a few operations like this which traverse trees and let you arbitrarily rewrite it, but that doesnt tell you where you are either
03:20:41 <bwe> lyxia: and `comparing someFunction` is a way to compare...
03:21:11 <bwe> :t comparing
03:21:13 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:22:03 <ur_> EvanR: I it a pertinent question what JPrim is supposed to be? How would I factor it out from the JValue type? 
03:22:07 <bwe> ...two b. So, that should add up.
03:22:14 <ur_> EvanR: is it*
03:22:35 <lyxia> bwe: it does, right?
03:22:50 <EvanR> the function wraps the current leaf node in a JPrim, which is a type i made up, which tells you what kind of data it is
03:23:26 <EvanR> you return another primitive. but expanding the output to JValue might be more flexible
03:23:56 <EvanR> the visiting function will never be passed an array or object, for the sake of argument, so accepting JValue would introduce annoying non-totality
03:24:06 <spatial> lyxia : list of lists. Maybe
03:25:30 <lyxia> spatial: unGrid has type Grid a -> [[a]]. below should be of type Grid a.
03:26:23 <EvanR> ur_: actually... a function like clojures `walk' might make sense for JValue, since they are in spirit the same dynamically typed datastructure
03:27:29 <EvanR> walk :: (Value -> Value) -> (Value -> Value) -> Value -> Value
03:27:41 <lyxia> spatial: then to answer your question,    let line : below' = unGrid below    pattern-matches on the list (of lists) "unGrid below", which should be non-empty, and introduces two bindings, line for the head, and below' for the tail.
03:31:08 <ur_> EvanR: Hm.. yes it would be. Don't know how I'd implement it to be honest
03:31:22 <EvanR> it would be pretty easy
03:32:11 <ur_> EvanR: more to the point, I don't know how I'd type it
03:32:22 <EvanR> http://lpaste.net/351101
03:32:36 <EvanR> lisp highlighting is ... not working here
03:33:14 <ur_> EvanR: Yeah, I can read it. No problem
03:33:21 <EvanR> this code looks like alphabet soup, but if you can see the case analysis of it, its pretty much how youd write it in haskell
03:35:07 <ur_> EvanR: Yes, seems quite clear. Right. So I would have to implement functions isJString :: JValue -> Bool etc
03:35:13 <ur_> and than dispatch on that?
03:35:19 <ur_> then*
03:35:40 <EvanR> no
03:35:51 <EvanR> instead of isWhatever use pattern matching
03:37:01 <EvanR> even though the inner and outer will also have to do pattern matching again, thats just how it goes. gotta love dynamic types!
03:37:35 <osa1> I need FromJSON/ToJSON instances for types in `time` library, anyone know a library that provides those?
03:37:55 <ur_> EvanR: Right, I suppose I'll try to implement it, and see if I get stuck. Thanks for the tutoring!
03:38:38 <EvanR> aeson already comes with time instances
03:38:49 <EvanR> but you probably wont like what they do
03:39:22 <EvanR> so make your own newtypes
03:40:05 <osa1> EvanR: sorry, I mean DiffTime, not UTCTime
03:41:03 <EvanR> DiffTime, really?
03:41:43 <osa1> EvanR: ?
03:42:44 <EvanR> aeson comes with an instance for NominalDiffTime
03:43:36 <EvanR> but not DiffTime
03:43:50 <EvanR> might be an oversight, but anyway, almost no one wants DiffTime!
03:44:19 <osa1> what's wrong with it?
03:45:15 <EvanR> you cant add DiffTime to UTCTime to get a UTCTime
03:45:23 <EvanR> theyre incompatible
03:46:47 <EvanR> DiffTime works with AbsoluteTime, NominalDiffTime works with UTCTime
03:47:03 <EvanR> AbsoluteTime lives in its own world separated from us by leap second tables
03:47:13 <ur_> EvanR: By the way, you said "what about JValue isnt functorial besides the kind". What would that be? 
03:47:49 <EvanR> that you cant uniformly apply a function to its elements
03:49:18 <EvanR> also, it doesnt map types to types, or functions to functions on JValue
03:50:35 <EvanR> a functor is an image of one category in another, or in haskell, in itself
03:51:21 <EvanR> JSON doesnt have any of that structure
03:53:32 <ski> ur_ : a functor must be a parameterized type, where the parameter is allowed to be any type (of appropriate kind. typically it must be a concrete type, like `Int',`String',`[(String,Either Err (Int -> IO Bool))]',&c.)
03:54:33 <ski> ur_ : you can't say `JValue [Tree (Integer,String)]', it's just plain `JValue', it expects no parameter
03:54:56 <ur_> EvanR: an IMAGE of one category in another... afraid I don't understand. I suppose reading up on category theory would help? 
03:55:15 <EvanR> maybe not, thats just me babbling
03:55:35 <merijn> ur_: No, imo it wouldn't
03:55:45 <merijn> It's also not a particularly helpful description, imo
03:56:02 <ski> with a parameter imagined for `JValue', it being a functor then means it must allow you to go from `JValue A' to `JValue B', given than you can translate from `A' to `B', for *any* types `A' and `B'
03:56:31 <ur_> ski: Right, right
03:57:14 <EvanR> you can add that, but it ought to be clear how that wouldnt help
03:57:15 <ski> @type \f xs -> fmap (snd . fmap . f) xs
03:57:17 <lambdabot> error:
03:57:17 <lambdabot>     • Couldn't match type ‘f0 a1 -> f0 b1’ with ‘(a0, b)’
03:57:17 <lambdabot>       Expected type: a -> (a0, b)
03:58:35 <Myrl-saki> Sooo... I don't know type-level voodoo.
03:58:43 <Myrl-saki> https://github.com/ChrisPenner/rasa/blob/dc13652d41c4c941aa6bca8dcdb55d8d63d74a76/rasa/src/Rasa/Internal/Editor.hs
03:59:01 <Myrl-saki> https://github.com/ChrisPenner/rasa/blob/dc13652d41c4c941aa6bca8dcdb55d8d63d74a76/rasa/src/Rasa/Internal/Editor.hs#L72-L104
03:59:08 <hexagoxel> :t \i1 i2 -> join $ curry randomRIO <$> i1 <*> i2
03:59:08 <Myrl-saki> Basically maps types to values, I think?
03:59:10 <lambdabot> Random a => IO a -> IO a -> IO a
03:59:14 <Myrl-saki> How does that work?
03:59:15 <hexagoxel> :t \i1 i2 -> randomRIO =<< (,) <$> i1 <*> i2
03:59:17 <lambdabot> Random b => IO b -> IO b -> IO b
03:59:28 <hexagoxel> hmm which is nicer?
03:59:34 <ski> ur_ : i haven't followed from the start, .. however, there's <https://hackage.haskell.org/package/mono-traversable-1.0.1/docs/Data-MonoTraversable.html#t:MonoFunctor>, which doesn't require a parameterized type, it allows a single specific "element" type. i'm not sure whether it'd help in your case, though
04:00:08 <Myrl-saki> hexagoxel: Hmmm
04:01:31 <Myrl-saki> hexagoxel: I'd have to go with the second.
04:02:11 <Myrl-saki> :t curry randomRIO
04:02:12 <ur_> ski: Yeah, no idea if it would or if I should use it if it does. Regardless, it's interesting. I'll take a look 
04:02:13 <lambdabot> Random a => a -> a -> IO a
04:02:50 <bwe> lyxia: Yes.
04:02:58 <EvanR> json Value doesnt have a specific element type, unless you want to define a new JPrim for the 5 (?) primitive dynamic types
04:03:08 <EvanR> and treat it like a tree
04:03:27 <EvanR> the clojure walk operation seems more spiffy
04:11:19 <ij> If I'd like to parse format that's contained within another format, then I containerFormatParser >>= embeddedFormatParser?
04:12:12 <EvanR> use embeddedparser within the containerparser
04:14:54 <ij> But wouldn't this work as well?
04:15:35 <EvanR> what are the types
04:15:46 <merijn> Attempt #2: Anyone got experience with deserialising XML to haskell and would like to recommend a library?
04:17:01 <ij> EvanR, Right, a "Parser Foo" isn't a function.
04:17:51 <EvanR> maybe you were thinking the container parser returned a string, then you would run a sub-parser, but i think thats not as efficient
04:18:02 <ij> Yeah, I was thinking that, sorta.
04:18:52 <ij> Suppose, I've base64decode :: Parser String. Would it really make sense to make a base64 embeddedFormat :: Parser x -> Parser x?
04:19:02 <ij> base64decode*
04:19:27 <ij> How would subparsing look in code?
04:20:46 <EvanR> yes if you want to run a subparser
04:21:37 <EvanR> you get the string, you run the parser (as a pure function) to get the result, if it fails, fail the parser you originally were in
04:22:14 <ij> I think it shouldn't be neccessary to make the parser accept another parser in this case.
04:22:51 <EvanR> i figured you were trying to make a wrapper function which base64 decoded then ran the subparser on the result
04:23:43 <ij> right, but if I had base64d, I could get a string from it. So I should be able to, without changing base64d, pipe it into the next parser.
04:24:14 <EvanR> you mean, without subparsing
04:24:28 <ij> If by subparsing you mean "Parser x -> Parser x", then yeah.
04:24:34 * ij writes some test code.
04:24:39 <EvanR> i mean using "runParser" inside the parser
04:25:07 <EvanR> since base64 is involved, you cant just "pipe it to the next parser"
04:25:24 <ij> Really? Why?
04:25:46 <EvanR> a given parser parses the ambient input stream, not any string you want
04:27:17 * ski idly wonders how to do this sort of thing more nicely/naturally ..
04:28:55 <EvanR> we usually have fmap postProcess someParser
04:28:59 <merijn> ski: subparsers? attoparsec has a delimited parser now, i think?
04:29:16 <EvanR> but in this case we want to preprocess the base64 (segment of some length) before parsing
04:29:30 <ski> EvanR : i was thinking of something `local'-like, if that makes any sense
04:29:37 <merijn> hmmm, ok, so apparently not attoparsec, but one parser did?
04:29:51 <merijn> ski: I have seen it somewhere
04:30:24 * ski idly wonders whether parser intersection would be useful in this particular instance
04:30:35 <ij> doubleChar parser is so simple! many (anyChar >>= char)
04:30:41 <ij> amazing
04:32:57 <merijn> ski: Oh, I was thinking of binary
04:32:58 <ph88^> i'm using stack and the foundation package, how can i update foundation to the latest commit ?
04:33:30 <merijn> binary has "isolate :: Int -> Get a -> Get a"
04:34:00 <merijn> Which fails if Get a doesn't consume exactly N bytes
04:34:24 <merijn> Which is very nice for parsing delimited fields in protocols
04:34:56 <merijn> I think I opened a ticket for attoparsec to add that at some point
04:37:37 <merijn> Ah, closed as WONTFIX since no one else ever requested it
04:45:25 <magthe> ph88^: by "commit", do you mean that you want to pull foundation from github?
04:57:22 <Myrl-saki> How does one provide a mapping from type to values?
04:58:43 <Tehnix`> Myrl-saki: like a case statement, or what are you thinking?
05:00:03 <Myrl-saki> Tehnix`: https://www.reddit.com/r/haskell/comments/5l0a2i/rasa_modular_texteditor/
05:00:12 <merijn> Myrl-saki: Typeclasses are the only real way that doesn't involve type level voodoo
05:00:32 <Myrl-saki> merijn: I think this guy uses type level voodoo with typereps.
05:02:50 <ph88^> magthe, i'm not even sure where it's coming from at the moment .. i didn't find it on stackage. I want the latest commit, but not neccesarily from github
05:06:22 <tabaqui1> what is a precedence of quoted functions?
05:06:32 <Ferdirand> you can define it with infixl/r
05:06:46 <Ferdirand> like for operators
05:06:54 <magthe> ph88^: it's downloaded from hackage then, what version are you getting, and which do you want?
05:07:01 <Myrl-saki> merijn: I see `Map TypeRep [Hook]`
05:07:03 <tabaqui1> yeah, but what is the default value for functions like `foobar`
05:07:05 <tabaqui1> ?
05:07:09 <Myrl-saki> merijn: I think that is pretty relevant?
05:07:17 <tabaqui1> :i (+)
05:07:23 <tabaqui1> :t (+)
05:07:25 <lambdabot> Num a => a -> a -> a
05:09:03 <tabaqui1> If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity (see Section 4.4.2).
05:09:08 <tabaqui1> haskell 98
05:09:23 <merijn> tabaqui1: infixl 9 for default
05:09:33 <merijn> tabaqui1: You can specifiy custom fixity for quoted funs too
05:09:42 <merijn> tabaqui1: Same as operators
05:10:22 <tabaqui1> merijn: and infixl means left associativity, while infixr - right?
05:10:48 <merijn> yes
05:10:54 <tabaqui1> fine, thanks
05:13:15 <ski> merijn : ok, so perhaps my "parser intersection" notion might be useful here, then ..
05:33:19 <merijn> Sometimes I'm sad I can't use 'id' as variable name :\
05:34:11 <ski> you can't ?
05:34:34 <merijn> Well I can, but I warn for shadowing
05:35:00 <mettekou> You can always import it qualified.
05:35:17 <merijn> mettekou: id is in Prelude, so unless you qualify all of Prelude...
05:36:19 <mettekou> merijn: Not an issue: import Prelude hiding (id); import qualified Prelude as P.
05:36:27 <mettekou> Then you can use all of Prelude unqualified, except for id.
05:37:23 <Eduard_Munteanu> I'm trying to use Servant with polymorphic monads, but I get ambiguous types errors.
05:37:37 <Eduard_Munteanu> e.g. test = ask :: MonadReader () m => ServerT () m
05:37:39 * ski twitches
05:38:18 <Eduard_Munteanu> Might be because ServerT is a type family. Any idea how to fix it?
06:08:28 <manek> Hello! I need to implement intervalmap in Haskell. Is the fingertree the best path I can approach? I'm a little worried, cause the "best" library implementing fingertree I've found was created in 2006 with minor updates until today with a lot of "excercise"-labeled code inside
06:08:39 <manek> https://hackage.haskell.org/package/fingertree-0.1.1.0
06:09:29 <ertes> merijn: i switched to "k" from "id" when i came to haskell
06:09:52 <opqdonut> manek: the exercises are references to the fingertree paper, see e.g. page 8 of http://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf
06:10:25 <cocreature> manek: there is another package implementing intervalmaps https://hackage.haskell.org/package/IntervalMap which has been update recently. but I haven’t used it myself
06:10:29 <Eduard_Munteanu> Mm, nevermind, I figured it out, I should use 'm ()' directly instead of ServerT for handlers.
06:10:48 <ertes> manek: fingertree is a practical library, but potentially not the best data structure for interval maps…  check out the IntervalMap library as well
06:10:53 <manek> opqdonut: I know, still it sounds unprofessional
06:11:02 <ertes> manek: if in doubt, benchmark
06:11:48 <opqdonut> manek: I guess most people use Data.Sequence from the containers package instead of a raw fingertree, but then again Data.Sequence might not be generic enough for you
06:12:06 <ertes> manek: i can confirm from personal experience that fingertree is a good library…  some of the design decisions i don't agree with (most notably the non-strictness), but overall it's fine
06:12:10 <manek> ertes: In fact I need something fancy. I need intervals that doesnt overlap and I can scalee them as fast as possbile, so I can take some interval and tell that its now 2 times bigger, and all other intervals will be offseted. In fact uisng fingerprint I can implement that pretty easy. Do you know other libs I should look for ?
06:13:16 <ertes> manek: hmm…  you may want to use fingertree in that case, but the ready-made implementation is rather poor…  you should probably write your own implementation in terms of FingerTree
06:14:03 <manek> ertes: thats interesting. Why nobody made a genral , good implementation of it? It is usefull as hell if im not wrong
06:14:26 <ski> ertes : "k" ?
06:43:27 <ertes> ski: "key"
06:43:38 <ski> oh
06:44:10 * ski was thinking `k' was the new fashion shorthand for "identifier"
06:44:54 <merijn> ski: Or 'k' as in SKI? :p
06:45:15 <ski> didn't cross my mind
06:49:35 <contiver> I have been working on a Haskell project that I'd like open source, but I was wondering if it would be better to do some things before doing so, say write a style guideline, a good readme, opt for a license, stuff like that.
06:49:51 <Nolter> Stupid beginner question:  why does   map (/ 2.0) [1, 2, 3, 4, 5]  work but      map (/ 2.0) [1 .. 5]   doesn’t?
06:49:56 <contiver> Anybody got any recommendations? Or do people usually just make a repository public and work from there?
06:52:29 <merijn> contiver: Well a license is mandatory if you want others to actually use it
06:52:40 <merijn> contiver: The rest is "nice to have"
06:52:56 <merijn> Noldorin: Define "doesn't work"
06:53:03 <merijn> s/Noldorin/Nolter
06:54:44 <contiver> merijn: any recommendations? Right now its under MIT, would BSD3 be better? I'm not too well versed in licenses as you can see. Basically, I just want to let anybody do whatever with it.
06:55:16 <merijn> MIT/BSD2 or BSD3 should be fine
06:55:18 <kadoban> contiver: To me, BSD variants and MIT are very very similar, pretty much a coin flip.
06:56:56 <kadoban> contiver: I don't remember the last project I looked at that had an explicit style guide. Not that one is a bad idea, but ... probably not super necessary unless you want to.
06:57:56 <bwe> pickBest :: [(Rational, Rational, Rational)] -> Maybe (Rational, Rational, Rational) -- How can I transform a Just (Rational, Rational, Rational) value into (Rational, Rational, Rational) type?
06:58:05 <bwe> So, I want to get rid of the Maybe.
06:58:24 <merijn> bwe: Well, what should it do if you have Nothing?
06:58:59 <bwe> merijn: | best == Nothing = fallback
06:59:06 <merijn> :t fromMaybe
06:59:07 <srk> bwe: fromJust if you're sure there isn't Nothing, case otherwise
06:59:07 <lambdabot> a -> Maybe a -> a
06:59:25 <merijn> fromJust is a terrible recommendation >.<
06:59:27 <bwe> merijn: | otherwise       = fromMaybe best -- hope that works
06:59:50 <contiver> merijn,kadoban: thanks :)
06:59:50 <srk> merijn: well, sometimes there can't be nothing :)
06:59:52 <merijn> bwe: FYI, you should prefer pattern matching over "best == Nothing", the latter only works for things that are Eq
07:00:03 <merijn> :t (Nothing ==)
07:00:05 <lambdabot> Eq a => Maybe a -> Bool
07:00:44 <bwe> manek: Oh, I thought it to be pattern matching, actually. Hrmpf.
07:01:10 <merijn> bwe: Can you lpaste your entire function? :)
07:02:26 <seequ> Hi there. I'm playing a bit with monads to try to understand their use. I thought about writing a little parser as an exercise. Say, does this definition (and use) make any sense? http://lpaste.net/6748715746093694976
07:05:16 <bwe> merijn: https://bpaste.net/show/e8ba3c8b7c65 -- I've looked up what pattern matching actually is. However, I need to match against `best` which isn't `values`.
07:09:12 <lpaste> merijn pasted “No title” at http://lpaste.net/351104
07:09:19 <merijn> bwe: The idea is to do it like that
07:11:32 <bwe> merijn: This is art!
07:12:21 <srk> art of programming! :]
07:12:58 <srk> that's how it should be
07:13:55 <merijn> ugh, I hate XML...
07:14:43 <max___> Hey, just a quick question on the kleisli operator and the bind operator. I'm reading that the (>>=) operator can be written by, ma >>= k = const ma >=> k, but I'm wondering if this should be ma >>= k = const ma >=> k $ ()?
07:15:58 <opqdonut> :t (>=>)
07:16:00 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:16:03 <opqdonut> :t (>>=)
07:16:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:16:13 <byorgey> max___: yes, it should
07:16:17 <opqdonut> you're right
07:16:19 <ski> max___ : yes, or `(\() -> ma) >=> k) ()', if you prefer (i do)
07:16:19 <max___> ok, cool
07:16:36 <max___> thanks guys :^)
07:17:21 <bwe> How can I easily extend a tuple (1, 2) by one value, say 6? Desired: (1, 2, 6) 
07:17:43 <byorgey> bwe: \(x,y) -> (x,y,6)
07:18:19 <byorgey> bwe: there is nothing better than that.  Are you sure you don't want a list instead of a tuple?
07:19:55 <Cale> bwe: Despite the syntactic similarity, tuple types are all distinct from one another, and basically unrelated.
07:20:41 <Cale> You might prefer to use nested pairs, rather than ever touching the larger tuple types -- or indeed lists as byorgey already mentioned.
07:21:27 * ski idly wonders why bwe wants this, what they're trying to do
07:22:43 <mrkgnao> well, they might be used to python, where this is possible iirc (since tuples are "basically lists" to some extent there)
07:24:15 <mrkgnao> so I'm getting back into Haskell, and was looking to do a little bit of easy graphics programming with gloss
07:24:25 <mrkgnao> and I managed to get GL working on nixos
07:24:47 <mrkgnao> anyway, so I saw this <http://rosettacode.org/wiki/Snake#Haskell> really cool demo, and I wonder if there's a name for the kind of DSL it uses?
07:30:32 <byorgey> mrkgnao: every DSL is different.  That is like asking "I wonder if there's a name for the kind of person so-and-so is?"  It depends on which attributes you want to generalize over.
07:31:15 <byorgey> what are the particular attributes of the DSL you are wondering about?
07:31:54 <c_wraith> I'd describe it as "poorly documented"
07:32:12 <c_wraith> Just adding top-level type signatures would improve it about 100-fold
07:33:48 <c_wraith> It's got a bit of lensy stuff, and some reimplementations of ideas from lens that microlens doesn't have..
07:35:13 <byorgey> It's a shallow embedding.  It's monadic, based on Kleisli composition, although there is no explicit Monad instance
07:49:27 * ski . o O ( "The Importance of Being Ernest",Henry Ford,Essentialism )
07:53:41 <bartavelle> is there a library that solves simple equations for *integer arithmetic* (ie, x / 3 = 3 returns [9,10,11]) ?
07:54:48 <mrkgnao> byorgey: I've just really seen very few DSLs in the wild and couldn't really believe my eyes at first when I saw the code
07:55:08 <mrkgnao> to be fair, I'm not exactly experienced with Haskell
07:55:55 <mrkgnao> bartavelle: something that could solve arbitrary Diophantine equations would be ... exciting
07:56:27 <mrkgnao> see <https://en.wikipedia.org/wiki/Diophantine_equation#Hilbert.27s_tenth_problem>
07:57:39 <bartavelle> I need an algorithm that can fail, but as my requirement is equations with at most one variable, of the forme ax + b = 0 or a/x + b = 0, I think this is manageable :)
07:57:44 <mrkgnao> but I think you could do only, say, linear equations easily by rewriting a syntax tree.
07:58:08 <bartavelle> yes they are easy to solve if I need a single solution
07:58:14 <mrkgnao> ah. may I ask what this is for?
07:58:16 <bartavelle> but x / 3 = 3 has 3 solutions :)
07:58:32 <bartavelle> toy abstract domain interpreter
07:58:32 <mrkgnao> oh, you mean in the Java sense?
07:58:36 <bartavelle> non
07:58:47 <bartavelle> 9, 10 and 11 all work in *integer arithmetic*
07:58:52 <bartavelle> that would be
07:58:56 <mrkgnao> as in, truncating division
07:58:58 <bartavelle> x `div` 3 = 3 in haskell
07:58:59 <bartavelle> yes
07:59:09 <bartavelle> or x `quot` 3
08:01:05 <buglebudabey_> > compare 1 2
08:01:07 <lambdabot>  LT
08:01:56 <mrkgnao> bartavelle: I suppose ax + b = 0 always has an unique solution in \Z, if at all
08:02:17 <bartavelle> yeah, it's more a problem with x / a = b
08:02:28 <bartavelle> and then propagating all the bounds properly
08:02:31 <bartavelle> humm
08:02:42 <bartavelle> I'll just bite the bullet and try to solve it
08:03:05 <ski> bartavelle : perhaps there's a constraint solver that can do that, somewhere ..
08:03:28 <bartavelle> ski, yes, that's an idea but I had hoped for a lightweight solution
08:03:49 <bartavelle> you mean something like a SAT solver ?
08:03:56 <bartavelle> or something simpler ?
08:03:59 <mrkgnao> x / a = b is solved by [a * b .. (a + 1) * b - 1], no?
08:04:23 <mrkgnao> are you looking for more vars?
08:04:28 <bartavelle> for more operations
08:04:28 <mrkgnao> s/for/to do/
08:04:44 <bartavelle> where some parts could be intervals too
08:04:46 <mrkgnao> what else? 
08:04:49 <mrkgnao> oh, interesting
08:05:05 <bartavelle> x `div` [1,2,3,4] <= [5:78]
08:05:36 <zipper> Is the Range of a codomain the same thing as the Range?
08:05:53 <bartavelle> idk what that means :)
08:10:20 <ski> bartavelle : no, i was thinking of something like CLP(FD)
08:10:37 <ski> bartavelle : constraint programming, specifically constraint logic programming (CLP)
08:11:01 <ski> often implemented as an extension/library for Prolog
08:11:40 <ski> (there may be constraint solvers in Haskell libs as well, of course)
08:12:33 <bartavelle> alright, will try to look that up
08:12:35 <bartavelle> thanks!
08:12:59 <bartavelle> (that might be useful for a later stage where relations between variables are kept)
08:13:01 <ski> zipper : sometimes it means codomain when "range" is written. othertimes, it means image. sometimes it simply means the type of a variable
08:14:12 <ski> bartavelle : "FD" stands for "finite domain", typically it handles integers (implicity subsets of them), with equality, inequality, disequality, some arithmetic (but usually not solving higher than first-order (in)equations)
08:14:29 <bartavelle> that would fit my use case
08:14:42 <ski> bartavelle : there's also CLP(Q) (rationals), CLP(R) (reals), CLP(B) (booleans). CLP(BN) (Bayesian Networks), &c.
08:14:45 <zipper> ski: There has to be a yes or no strict math definition e.g image is in the codomain
08:15:01 <ski> (of course, in practice "reals" here means "floating-point numbers")
08:15:27 <ski> zipper : i don't understand "image is in the codomain"
08:15:59 <ski> zipper : what makes you believe there can't be several (mutually incompatible) math definitions ?
08:16:07 <ski> (you can also try asking ##math)
08:16:09 <zipper> The image is the possible values that can be returned by a morphism in the codomain
08:16:32 <zipper> Uh I am just reading CT and watching videos 
08:16:37 <ski> yes, that's what image usually measn
08:16:38 <zipper> I don't really know
08:16:43 <zipper> usually means?
08:16:45 <zipper> Ok
08:17:06 <ski> i would probably avoid using the term "range", unless it's clear in the context what it's taken to mean
08:36:40 <reactormonk> Need the 8.0.2 for the mac os fix, what do I set in the stack.yaml?
08:45:36 <markus3> hi! Are there any downsides in enabling RankNTypes for a cabal package by default? E.g if it's necessary for a couple of modules only.
08:47:42 <glguy> markus3: As opposed to listing the extensions you're using in the module?
08:47:50 <glguy> Or are you asking if it's OK to use RankNTypes at all?
08:48:17 <davean> I think he's asking if RankNTypes has effects where you're not directly using them?
08:57:20 <okok> hello everyone
08:58:09 <okok> I'm studying Haskell and googling around I learned I could have some questions answered here...
08:58:27 <davean> That is possibly true
08:58:59 <okok> I'm following this tutorial: https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/4-higher-order-programming-and-type-inference
08:59:11 <johnw> okok: indeed, this is the place to be
08:59:28 <okok> There is a part where its said: "Note, for example, that we can rewrite our composition function from above by moving the \x -> ... from the right-hand side of the = to the left-hand side:"
09:00:11 <okok> I understand that it meant f = \x -> (\y -> (\z -> ...))
09:00:38 <okok> But I don't see how "f = \x -> (\y -> (\z -> ...))" can be changed to comp :: (b -> c) -> (a -> b) -> a -> c comp f g x = f (g x)
09:00:53 <okok> comp :: (b -> c) -> (a -> b) -> a -> c
09:00:58 <okok> comp f g x = f (g x)
09:01:16 <glguy> okok: It looks like the author deleted something, or moved that paragraph, or something
09:01:29 <lambdaman> I'm trying to get a C-array, from the return of an inline-c call, wrapped by a Storable Vector - I believe this should be possible.  However, I see that I have a Ptr in hand and the only Vector function I see is unsafeFromForeignPtr, which takes a ForeignPtr.  My FFI-fu is weak.  Is it OK to just wrap the Ptr with 'newForeignPtr_'?  Does that then need 'finalizing'?
09:01:31 <glguy> There doesn't appear to be a composition function above that it could be referring to
09:01:53 <okok> Oh.
09:01:56 <glguy> okok: The function would have looked like this: comp f g = \x -> f (g x)
09:03:19 <okok> In this case, \x was moved to left side of =
09:03:37 <okok> In other words, an anonymous function wouldn't be necessary. Is that right?
09:06:39 <nitrix> Function extensionality lets you rewrite it this way, yes.
09:08:25 <nitrix> It maintains the same external properties, but there's a small semantic different with memoization.
09:08:36 <bwe> byorgey: You are right, I should be sensible about extending tuples if a list can hold a tuple and other values better.
09:09:22 <bwe> byorgey: I will consider a way not needing to make up a new tuple from an old one.
09:09:24 <c_wraith> lambdaman, that sounds likely to corrupt memory. 
09:10:25 <bwe> However, first I need to debug another function I rely on:
09:10:30 <lpaste> bwe pasted “Debug lesson: How can I trace where the NaN comes from?” at http://lpaste.net/3752222157229260800
09:10:55 <c_wraith> lambdaman, unless you know for a lot about what that Ptr points to.
09:11:36 <c_wraith> lambdaman, is it pointing to a static bugger? memory allocated by ghc? memory allocated by C code? 
09:11:52 <c_wraith> lambdaman, each of those cases needs to be handled differently. 
09:12:10 <c_wraith> static *buffer. darn autoincorrect
09:14:09 <c_wraith> in fact, there are arbitrarily many different ways you might need to handle memory allocated by C code. 
09:15:56 <lambdaman> Thanks c_wraith.  Yes, that makes sense. I'll have to inspect the C code...
09:19:41 <okok> Thanks!
09:19:42 <nshepperd> generally, you might write a C function to "free" the memory in whatever way appropriate, then use newForeignPtr with that function as the finalizer
09:20:20 <nshepperd> assuming the memory needs freeing or some kind of release of resources
09:20:36 <c_wraith> unless the pointer is to a static buffer, in which case you want to either copy it or use it before any subsequent call can corrupt it. 
09:20:39 * nitrix coughs; memory regions! :)
09:20:50 <Demon_Fox> Is there a full implementation of a png decoder in Haskell?
09:21:45 <nitrix> Demon_Fox: Have you looked at JuicyPixels?
09:22:24 <Demon_Fox> It was farther down in the search results I got for "Haskell png decoder library"
09:22:32 <nitrix> https://github.com/Twinside/Juicy.Pixels/blob/master/src/Codec/Picture/Png.hs
09:22:51 <nitrix> You can see every steps, deinterlacing, unpacking and all. It's not trivial.
09:23:30 <Demon_Fox> Here's a question for you, then why is it not in wide spread use?
09:23:44 <lambdaman> On closer inspection, it seems that I have to pass in an array of long longs to this C function and it will deposit results in that memory. 
09:23:48 <Demon_Fox> Given that Haskell is fast and that it's safe
09:24:14 <maerwald> is it safe?
09:24:29 <maerwald> not many research in that area I'd argue
09:24:48 <maerwald> unless you just mean "type safe"
09:24:51 <lambdaman> So, the memory can be owned by the Haskell side.  I just need to get Haskell to make such an array that is stable in memory I guess and then pass this in.
09:25:19 <Demon_Fox> I thought since Haskell's design was to eliminate side effects that it would be safe
09:25:36 <c_wraith> lambdaman, that sounds right. 
09:25:37 <maerwald> lol, no, that's too simplistic for a coherent argument
09:25:48 <maerwald> at least if you really mean "safety" in terms of a system
09:25:52 <Demon_Fox> Well, safer than C for instance
09:25:55 <maerwald> like you have in embedded development a lot
09:26:00 <nitrix> Demon_Fox: Two are two seperate questions.
09:26:08 <Demon_Fox> Sorry
09:26:27 <Demon_Fox> Immune from side effects and buffer overflow exploits
09:26:27 <nitrix> Demon_Fox: Haskell is quite safe, but if you're interfacing with C, then you bring C's concerns into the picture.
09:26:40 <Demon_Fox> Without C, is it not?
09:26:41 <maerwald> Demon_Fox: for C, industry uses a lot of tools and standards (and sometimes DSLs) to construct verifiable safe system.
09:26:54 <Demon_Fox> I C
09:27:03 <maerwald> there's decades of expertise in that area with C
09:27:09 <nitrix> Demon_Fox: It is fairly safe when C is without the equation. Provable in some cases.
09:27:10 <maerwald> not in haskell, so industry won't just switch over
09:28:03 <Demon_Fox> In one year, won't Haskell 98 be two decades old?
09:28:19 * ski doesn't really see the connection between "eliminate side effects" and "safe"
09:28:53 <nitrix> Demon_Fox: "The industry" is large. Only a small fraction seems to care about the safety; others seems the prefer the mentality of "let's throw more monkeys at the problem then".
09:28:55 <Demon_Fox> Safer from exploits, no?
09:29:23 <ski> how so ?
09:29:44 <maerwald> Demon_Fox: security != safety
09:30:00 <markus3> glguy: sorry for answering so late -- yes, using it at all. I guess I just don't want to list RankNTypes at top of files, especially if it doesn't hurt anything else.
09:30:15 <nitrix> Demon_Fox: I think you're conflating what makes an application secure with the language safety.
09:30:19 <ski> lack of side effects makes it easier to reason about code, keeping the effects more under control
09:30:31 <Demon_Fox> I may have a complete misunderstanding of Haskell since I haven't began to seriously learn it
09:30:40 <maerwald> there's language-based security, so it has an impact, but that's just one thing of many
09:30:47 <ski> that doesn't by itself imply stuff like no buffer overflow
09:31:04 <nitrix> Demon_Fox: Given you haven't started learning it, you probably have no understanding of Haskell whatsoever yet.
09:31:12 <nitrix> Demon_Fox: I'd say it's a safe statement to make, yes.
09:31:19 <Demon_Fox> I want to know if it's something I want to learn
09:31:36 <glguy> markus3: It's best to put the extensions you're using directly in the module using them. It helps when reading the module and when loading it without cabal
09:31:55 <nitrix> Demon_Fox: I can ask you if it's something you want to learn then forward your answer to you :)
09:32:20 <maerwald> I'd say security and safety are both the weakest arguments for haskell, since there is little to no experience. Although there's some interesting research wrt MAC, IFC etc
09:32:31 <ski> operations for accessing arrays in Haskell typically do bound-checking. but that's not due to Haskell lacking side-effects
09:32:31 <nitrix> Demon_Fox: I'll also try to answer whatever questions you may have too. I like when the community grows :)
09:32:41 <Demon_Fox> I want to learn something that makes making security mistakes more difficult
09:33:03 <maerwald> Demon_Fox: a language cannot really give you that
09:33:16 <maerwald> security is about the "weird machine", not just about a programming language
09:33:30 <maerwald> you're not running your program, you are running machine code that your program was translated into
09:33:42 <Demon_Fox> Very true
09:33:43 <ski> Demon_Fox : i suppose one way in which Haskell could help there is in making it easier to have more typeful code, not having to say "trust me" to the language all the time, to be able to do useful work
09:33:57 <nitrix> Demon_Fox: Even in a semantically perfect language, with the most cautious developer, you could still be subject to attack vectors like timing attacks.
09:34:00 <DrAwesomeClaws> maerwald, i agree, but i'm not sure that precludes the idea that a language can help you make better decisions 
09:34:14 <nitrix> Demon_Fox: Or man-in-the-middle for example.
09:34:17 <maerwald> DrAwesomeClaws: yes it can
09:34:37 <ski> (Demon_Fox : e.g. casts to/from `(void *)' in C)
09:34:59 <markus3> glguy: ok! Not the answer I was hoping for :) but see the upside the per-module way has
09:35:04 <maerwald> DrAwesomeClaws: but that's just one tiny bit of the whole picture and there's not a lot of experience with vulnerabilities in haskell-driven systems
09:35:15 <Demon_Fox> Examples: signedness comparisons, buffer overflows, mis-retyping, and etc
09:35:30 <DrAwesomeClaws> yeah, i suppose i'm being a bit pedantic
09:35:57 <bwe> > scanl (\x acc -> acc - logBase 2 x) 0 [789] -- first round: acc is 0, second round: 0 - logBase 2 789. Where is my mistake?
09:35:59 <lambdabot>  [0.0,Infinity]
09:36:07 <maerwald> I'd argue if you want something for security, you want something like rust (memory safe), but with a full effect system and a proof assistant baked in. There's currently nothing like that.
09:36:39 <Demon_Fox> I code a significant amount of C code and I'm often running across mistakes _so_ subtle, even when pointed out, I can't spot.
09:36:54 <maerwald> you want to be low-level (e.g. for cryptography), but still not have so much power that you randomly mess up
09:36:57 <ski> > scanl (\acc x -> acc - logBase 2 x) 0 [789]  -- bwe, arguments of callback are passed in opposite order
09:36:59 <lambdabot>  [0.0,-9.623881490013458]
09:37:24 <DrAwesomeClaws> I code a in many languages, and I'm often running across mistakes _so_ glaring, even when pointed out, I can't spot 
09:37:26 <structuralist> Probably missing something obvious here, but where are ghcjs versions posted? I read that ghcjs-0-2-1 is "out" but I don't know where to find it.
09:37:30 <niklasb> maerwald: FWIW, about 98% of browser and OS CVEs (arguably those with the highest impact) would have been prevented by simply not having memory unsafety. so the same program written in haskell would not have these (although maybe it would be too slow)
09:37:30 <kazagistar> is "baked in" mandatory? Why can't the proof system be a separate langauge?
09:37:34 <bwe> ski: grr, thanks. Would not have found that out.
09:37:35 <maerwald> haskell is just too high-level for some things to reason about wrt security (e.g. branching, clearing of memory etc etc)
09:37:36 <nitrix> bwe: scan and fold follows the convention that the direction you're folding is where you'll find the accumulator.
09:37:46 <ski> bwe : easily seen from the type signature of `scanl'
09:38:25 <maerwald> so what makes sense though would be to write DSLs that spit out verified safe subsets of C (e.g. coqasm, but also mitls-fstar)
09:38:34 <niklasb> yes, for sure
09:38:40 <bwe> It's obvious (now ;) ): 0 [789]  would mean that the first thing should be acc, not x
09:38:43 <bwe> Thanks.
09:38:56 <niklasb> but that's kinda unreasonable for big software, even rewriting part of gecko in rust is a huge effort
09:38:57 <ski> maerwald : how does ATS fare there ?
09:39:08 <Demon_Fox> I'm not talking about hardware insecurities
09:39:21 <maerwald> ski: haven't looked at it 
09:39:30 <ski> <https://en.wikipedia.org/wiki/ATS_(programming_language)>
09:39:32 <Demon_Fox> No matter how much one puts attention into them, there will always be more
09:40:01 <Demon_Fox> For example, in C 1 + 1 does not always equal 2
09:40:07 <ski> bwe : also, `scanl' callback takes argument in same order as `foldl'. mutatis mutandis for `scanlr' and `foldr'
09:40:13 <maerwald> ski: afaiu this still can't catch information flow control bugs
09:40:29 <maerwald> that's where functional programming is actually interesting 
09:40:35 <Demon_Fox> sometimes 0 - 1 = -128 for example
09:40:40 <ski> maerwald : elaborate ?
09:40:54 <Demon_Fox> I meant, 255, not -128
09:41:16 <maerwald> ski: non-interference... as in: data from higher security level don't leak to lower-security level wrt data-flow
09:41:32 <maerwald> that's pretty hard to know unless you have type-system or proof-assistant support for that
09:41:46 <maerwald> there are some libraries in haskell that provide such functionality via monads or arrows
09:41:57 <maerwald> in fstar you could probably use the SMT solver to do that
09:42:00 <ski> mhm. and reference/link to more information about such things ?
09:42:26 <maerwald> https://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf
09:42:37 <maerwald> http://www.cse.chalmers.se/~russo/publications_files/haskell11.pdf
09:42:56 <maerwald> http://www.cse.chalmers.se/~russo/publications_files/pearl-russo.pdf
09:43:34 <maerwald> I think the idea first appeared here (more or less, except for Bell-Lapaluda thing) https://www.cs.cornell.edu/~kozen/papers/lbs.pdf
09:44:49 <maerwald> for something like an SSL implementation, you really want that, which is on the TODO list of mitls: https://github.com/mitls/mitls-fstar/issues/124
09:45:12 <maerwald> "What we consider is indeed a programming discipline which ensures that the execution path is independent from the secret data."
09:45:28 <Demon_Fox> Perhaps, I should be saying, Haskell can catch certain types of undefined behavior that aren't easy to catch in language like C
09:45:36 <Demon_Fox> correct?
09:45:40 <maerwald> definitely
09:46:06 <Cale> Demon_Fox: But in those cases, -1 = 255
09:47:01 <Demon_Fox> Sometimes, I've been tempted to avoid limits.h with unsigned integers using 0 and -1
09:47:21 <Demon_Fox> Mainly to avoid having to type things
09:47:22 <Cale> Haskell has the same small integer types available, but it's good that we make all the conversions between them explicit
09:47:32 <niklasb> Demon_Fox: in C++ it's easy to catch integer overflows via type wrappers btw
09:47:42 <lambdaman> What's the best way of making an vector/array of Storeables that I can pass to a C function as the buffer in which it will write results?  The C function expects an array of unsigned long longs (which translates to CULLongs of course). 
09:47:57 <Cale> (You have to explicitly apply fromIntegral, so you know that you might be losing precision.)
09:48:25 <ReinH> 1 + 1 doesn't always equal 2 in Haskell either.
09:48:41 <bwe> > scanlr (\x acc -> acc - x) 0 [1, 2, 3] -- load 0 into acc, subtract 3, load result of -3 into acc, subtract 2, load -5 into acc, subtract 1, load -6 into acc.
09:48:43 <lambdabot>  error:
09:48:43 <lambdabot>      • Variable not in scope:
09:48:43 <lambdabot>          scanlr
09:48:49 <bwe> > scanr (\x acc -> acc - x) 0 [1, 2, 3] -- load 0 into acc, subtract 3, load result of -3 into acc, subtract 2, load -5 into acc, subtract 1, load -6 into acc.
09:48:51 <ski> maerwald : ty
09:48:52 <lambdabot>  [-6,-5,-3,0]
09:48:54 <lambdaman> I thought the Vector on Storable would help, but it expressly prohibits the writing to the memory buffer you can extract from it.
09:49:34 <bwe> ski: I do understand it, however not why the result list goes from right to left. Why not from left to right?
09:50:08 <Demon_Fox> ReinH, but Haskell warns one, correct/
09:50:15 <ReinH> No.
09:50:26 <ski> bwe : to keep the ordering of `a',`b',`c' here :
09:50:27 <ski> > foldl (**) z [a,b,c]
09:50:30 <lambdabot>  ((z**a)**b)**c
09:51:02 <ski> bwe : if you flipped the callback argument order, the result would be `c ** (b ** (a ** z))' here
09:51:19 <ReinH> data ModTwo = Zero | One; instance Num ModTwo where...
09:51:25 <ski> >  foldr (-) z [a,b,c]  -- cf.
09:51:27 <lambdabot>  a - (b - (c - z))
09:52:15 <ReinH> Then 1 + 1 doesn't equal 2
09:52:38 <ski> bwe : with `foldl' and `scanl', you start with the initial accumulator value "to the left" of the list, then combine it with one element of the list at a time (using the callback, e.g. an infix operator), walking over the list from left-to-right
09:53:07 <ski> ReinH : why not ?
09:53:11 <Demon_Fox> At the very least, does one have to do something to acknowledge this before Haskell will let them do it?
09:53:30 <maerwald> ski: also, I think a full effect system with fine-grained IO controls could also give more meaning to security critical applications. doing that yourself in haskell is annoying an incompatible with most of the ecosystem.
09:53:48 <ski> maerwald : mhm
09:54:08 <ReinH> ski: there is no 2
09:54:24 <ReinH> > 256 + 256 :: Word8
09:54:27 <lambdabot>  0
09:54:29 <ski> ReinH : `2' is `fromInteger 2', which should equal `fromInteger 0', no ?
09:54:47 <ski> > 256 == (0 :: Word8)
09:54:50 <lambdabot>  True
09:55:14 <ReinH> Ok, it isn't a mod space. I lied about the name.
09:55:48 <ski> oh, not a ring
09:55:54 <ReinH> It's categorically the same as the above Word8 example.
09:56:18 <ski> how so ?
09:56:23 <niklasb> or 
09:56:26 <niklasb> > let a = 2^64 - 1 in (a::Int) + a
09:56:28 <lambdabot>  -2
09:56:30 <ReinH> ski: I changed my mind to avoid your objection :p
09:57:15 <ReinH> Addition isn't closed in either
09:57:37 <ReinH> So we close it in an ad how way
09:57:46 <ski> > 255 + 1 :: Word8
09:57:49 <ReinH> Ad hoc
09:57:49 <lambdabot>  0
09:57:50 <ski> seems closed to me
09:58:10 <ReinH> Yes, because we decided we preferred a wrong answer to a runtime error
09:58:16 <ReinH> That's why I said ad hoc
09:58:34 <ski> why is it a wrong answer ?
09:58:43 <nitrix> ertes: How the magical flying flattapus does one implements an FRP framework?
09:58:55 <nitrix> ertes: Do you need ST?
09:58:56 <ski> (i suppose that depends on what kind of thing you want to do ..)
09:59:00 <kuribas> or it emulates machine numbers?
09:59:04 <Cale> Word8 is the ring Z/2^8Z
09:59:06 <kuribas> (not realy emulate though).
09:59:35 <ReinH> Is Word8 the nats  modulo 256?
09:59:36 <kuribas> it makes sense for fixed bit integers to behave like in C...
09:59:46 <Demon_Fox> If you don't use Word*, are you safe?
09:59:50 <Cale> ReinH: Or the integers, sure
09:59:51 <ski> ReinH : that's what Cale said, yes
09:59:51 <ReinH> What avoid integer overflow? Is that "correct" behavior?
10:00:01 <kuribas> Demon_Fox: use Integer
10:00:15 <Demon_Fox> Thanks, I think I'm understanding now
10:00:47 <ReinH> I guess you can argue that point! But 255 + 1  doesn't always equal 256
10:00:59 <Cale> 256 = 0 sometimes
10:01:18 <ReinH> s/avoid/about
10:01:29 <Cale> 256 is pretty much always 255 + 1
10:02:09 <Cale> But in some cases more equations are true than in the plain integers :)
10:02:13 <Squarism> if you want to match a constructor but dont care about its fields is "MyConstrutor {}" the shortest version?
10:02:21 <Cale> yep
10:02:27 <Squarism> thanks
10:02:32 <ski> `fromInteger' is the unique ring homomorphism from the integers into any ring
10:02:40 <Cale> yep
10:03:13 <kuribas> > 256 == (-1) :: Int8
10:03:15 <lambdabot>  error:
10:03:15 <lambdabot>      • Couldn't match expected type ‘Int8’ with actual type ‘Bool’
10:03:15 <lambdabot>      • In the expression: 256 == (- 1) :: Int8
10:03:17 <ski> it's the standard way to "consider" an integer as an element of your ring (possibly losing information along with the translation)
10:03:21 <kuribas> > 256 == (-1 :: Int8)
10:03:24 <lambdabot>  False
10:03:25 <bwe> > scanr (-) 0 [1,2,3] -- first round: 3-(2-(1-0)); as 0 will be touched as last (\x acc -> ...) is the right order for scanr. Right?
10:03:28 <lambdabot>  [2,-1,3,0]
10:03:49 <ski> > 255 == (-1 :: Int8)
10:03:52 <lambdabot>  True
10:04:06 <ski> bwe : yep
10:04:14 <ReinH> ski: I'll buy that, but I think you still see my point. :p
10:04:45 <kuribas> > scanr (-) 0 [a, b, c] -- bwe
10:04:47 <lambdabot>  [a - (b - (c - 0)),b - (c - 0),c - 0,0]
10:04:48 <bwe> ski: Thanks. Hope I've got it know for some time.
10:04:57 <ski> bwe : ditto for `foldr' .. but also remember that `foldr' and `scanr' doesn't "begin evaluation at the end of the list" (if they did, they couldn't work on infinite lists ..)
10:05:23 <ski> > 6 `div` 2 :: Word8
10:05:27 <lambdabot>  3
10:05:28 <ski> > 3 * 2 :: Word8
10:05:32 <lambdabot>  6
10:05:36 <ski> > (128 + 3) * 2 :: Word8
10:05:38 <lambdabot>  6
10:06:46 <bwe> kuribas: Now the confusion is complete - understanding is near.
10:07:16 <kuribas> bwe: what's confusing you?
10:07:22 <kuribas> :t a
10:07:24 <lambdabot> Expr
10:07:33 <bwe> kuribas: In your example the list is evaluated from left to right. In mine, I think, from right to left.
10:07:55 <ski> ReinH : if the point is that sometimes one'd prefer getting an error raised than silently wrapping around the ring, then yet
10:07:55 <kuribas> bwe: no, right to left.  Look at the order of a, b, c...
10:08:28 <Demon_Fox> I understand now
10:08:54 <kuribas> bwe: first starts with a, second with b, third with c, ...
10:09:06 <ReinH> No part of Num demands that addition wrap.
10:09:39 <ski> it certainly doesn't wrap for `Integer', so it better shouldn't
10:10:18 <ReinH> Num is a weird typeclass with hardly any laws anyway.
10:10:28 * ski nods sadly
10:11:14 <bwe> scanr (-) 0 [1,2,3] -- 1-(2-(3-0)) my above example is wrong!
10:11:20 <ReinH> My point is just that (+) is overloaded in Haskell too and can have a variety of weird behaviours if you want.
10:11:34 <ski> ok
10:11:51 <ski> > scanr (-) 0 [1,2,3] :: [Expr]
10:11:54 <lambdabot>  [1 - (2 - (3 - 0)),2 - (3 - 0),3 - 0,0]
10:13:20 <bwe> kuribas: scanr and scanl evaluate the list from left to right!
10:13:22 <bwe> > scanr (-) 0 [1,2,3] -- [1-(2-(3-0)), 2-(3-0), (3-0), 0] == [2, -1, 3, 0]
10:13:24 <lambdabot>  [2,-1,3,0]
10:13:43 <kuribas> bwe: yes
10:15:05 <kuribas> bwe: although evaluation isn't really described.
10:15:38 <kuribas> > tail $ scanr (-) 0 [undefined, a, b, c]
10:15:40 <lambdabot>  [a - (b - (c - 0)),b - (c - 0),c - 0,0]
10:16:17 <kuribas> bwe: the first elements isn't really evaluated.
10:16:48 <bwe> kuribas: What does that mean?
10:17:18 <kuribas> bwe: that the order of evaluation isn't specified.  It depends on which value gets evaluated.
10:17:29 <ski> > foldr const undefined [0 ..]
10:17:31 <kuribas> bwe: because of lazyness.
10:17:32 <lambdabot>  0
10:17:35 <ski> > scanr const undefined [0 ..]
10:17:37 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:17:47 <ski> > foldl (flip const) 0 [0 ..]
10:17:55 <lambdabot>  mueval-core: Time limit exceeded
10:17:55 <lambdabot>  mueval: ExitFailure 1
10:17:57 <ski> > scanl (flip const) 0 [0 ..]
10:18:02 <lambdabot>  [0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
10:18:06 <kuribas> bwe: you would be right in a strict language
10:18:32 <ski> (so `scanl' (in addition to `foldr' and `scanr') can also work on infinite lists. but `foldl' can't)
10:20:01 <bwe> Okay. That's too fast for me. I seriously appreciate your both efforts.
10:20:33 <bwe> I do understand the order of evalutation. I don't why undefined is not considered.
10:21:07 <ski> bwe : in kuribas' example, since they stripped off the head element of the list (before handing the list off for printing), it wasn't evaluated (since it wasn't needed/demanded by computations for other parts of the list that *were* demanded/forced)
10:21:10 <kuribas> bwe: order of evaluation in a lazy language is hard to understand.
10:21:54 <ski> bwe : what do you mean by "I don't why undefined is not considered." ? -- considered for what ? or considered to be what ? &c.
10:22:27 <bwe> ski: 'undefined' does not show up in the result.
10:22:31 <ski> (hm, perhaps you mean "I don't see why `undefined' wasn't evaluated, there.")
10:23:20 <ski> `undefined' is not a value. it can't show up in a result. attempting to evaluate it will cause abortion of the evaluation
10:23:21 <kuribas> bwe: I don't think you understand the order of evaluation.  In fact you cannot know it.  The expression might not be evaluated at all.
10:24:08 <ski> it's similar to trying to take the head of an empty list. we could have used `head []' or `error "boo !"' instead of `undefined' above
10:24:17 <reactormonk> Is there a Either a b -> Maybe b?
10:24:34 <ski> @type either (const Nothing) Just
10:24:36 <lambdabot> Either b a -> Maybe a
10:24:41 <bwe> scanr (-) 0 [undefined, a, b, c] -- [undefined - (a - (b - (c - 0))), a - (b - (c - 0)), ...]
10:25:26 <ski> @hoogle Either a b -> a
10:25:27 <lambdabot> Prelude Left :: a -> Either a b
10:25:27 <lambdabot> Data.Either Left :: a -> Either a b
10:25:27 <lambdabot> Data.Strict.Either Left :: a -> Either a b
10:25:28 <bwe> That's what I expect. Now, why is the first element kind of skipped?
10:25:49 <ski> @hoogle Either a b -> Maybe a
10:25:49 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
10:25:49 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
10:25:49 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
10:25:55 <bwe> Do you see where I hang?
10:26:03 <ski> reactormonk : seems there's one ^
10:26:58 <kuribas> bwe: in my example because of "tail".
10:27:08 <ski> bwe : perhaps you'd like to see an evaluation/reduction "trace" of the expression ?
10:28:14 <bwe> ski: Sincerely.
10:28:52 <bwe> kuribas: You are good at confusing me ;) .
10:29:27 <kuribas> bwe: "> tail $ scanr (-) 0 [undefined, a, b, c]", tail skips the undefined.
10:29:29 <shlevy> Is there a parsing lib for package.conf.d conf files?
10:29:51 <bwe> > scanr (-) 0 [undefined, a, b, c]
10:29:54 <lambdabot>  [*Exception: Prelude.undefined
10:29:56 <bwe> > tail $ scanr (-) 0 [undefined, a, b, c]
10:29:59 <lambdabot>  [a - (b - (c - 0)),b - (c - 0),c - 0,0]
10:30:27 <bwe> I learn here, the stuff is actually evaluated after tail has been applied to the result of the scanr. Is that correct?
10:30:52 <ski> bwe : yes
10:31:03 <ReinH> In this case, evaluation is triggered by printing it.
10:31:30 <Squarism> any advice regarding logging and trace statements left around in debug sessions?
10:31:55 <ski> bwe : perhaps we should take a (notationally) slighly simpler example, like `take 2 (tail (map (^2) (undefined : [0 ..])))' ?
10:32:07 <shlevy> Ah ha https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Cabal-1.24.0.0/Distribution-InstalledPackageInfo.html#%tInstalledPackageInfo
10:32:29 <kuribas> Squarism: I only use them for finding bugs.  For testing I use tasty.
10:32:38 <ski> (well, say `take 3' instead of `take 2')
10:33:05 <bwe> {1^2, 2^2, 3^2]
10:33:21 <bwe> Oh, [ instead of {
10:33:33 <ski> actually `[0,1,4]', but yes
10:33:54 <bwe> ski: Right, it starts from 0 not 1. But I've got the point.
10:34:27 <shlevy> How do I get cabal install to install the header file generated by a foreign export?
10:35:26 <ski> bwe : or, if you'll bear it, we could apply `sum' to the result, to make it slightly more interesting (and somewhat easier, by avoiding some further complications)
10:36:17 <ski> @src sum
10:36:17 <lambdabot> sum = foldl (+) 0
10:36:21 <ski> @src foldl
10:36:22 <lambdabot> foldl f z []     = z
10:36:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:36:27 <ski> @src take 2
10:36:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:36:30 <ski> @src take
10:36:30 <lambdabot> take n _      | n <= 0 = []
10:36:30 <lambdabot> take _ []              = []
10:36:30 <lambdabot> take n (x:xs)          = x : take (n-1) xs
10:36:33 <ski> @src map
10:36:33 <lambdabot> map _ []     = []
10:36:33 <lambdabot> map f (x:xs) = f x : map f xs
10:36:38 <ski> @src undefined
10:36:38 <lambdabot> undefined = error "Prelude.undefined"
10:37:11 <ski> bwe : `[0 ..]' is sugar for `enumFrom 0', which we, for the sake of this explanation, can take as being defined as
10:37:38 <ski>   enumFrom n = n : enumFrom (n+1)
10:38:32 <ski> bwe : so, i'm going to show how `sum (take 3 (tail (map (^2) (undefined : [0 ..]))))' could be evaluated, ok ?
10:39:48 <lynn> Heya! I have `f :: (MonadRandom m, MonadReader Foo m) => Text -> m Text` and `g :: Text -> Reader Foo Bool`
10:40:06 <lynn> In my do-block definition for `f word` I'm trying to write: `b <- g word`
10:40:41 <lynn> But I get an error saying actual type  Reader Foo Bool  doesn't match the expected type  m Bool
10:41:08 <lynn> This is kinda confusing -- I've said m *can* act as a Reader Foo, right? Do I need some kind of lifting function?
10:42:55 <ski> lynn : you could do `b <- runReader (g word) <$> ask', there might be some convenience function for it somewhere ..
10:42:59 <lynn> I could use `ask` in combination with `runReader` I guess, but I'm sure there's a nicer way
10:43:04 <lynn> mm
10:43:37 <bwe> ski: sum is a curried function of foldl (+)
10:43:45 <bwe> ski: Is that so far correct?
10:44:17 <bwe> > foldl (+) [0,1,4]
10:44:20 <lambdabot>  error:
10:44:20 <lambdabot>      • No instance for (Typeable t0)
10:44:20 <lambdabot>          arising from a use of ‘show_M76212482037639657730832’
10:44:31 <bwe> > foldl (+) 0 [0,1,4]
10:44:33 <lambdabot>  5
10:45:11 <ski> bwe : `sum' is not curried. `sum' is defined above as a partial application of `foldl', however
10:45:28 <bwe> ski: partial function, right.
10:45:35 <ski> partial *application*
10:45:40 <ski> partial function is something else
10:46:32 <Younder> sum could be parallelized as a map reduce. a foldl is a loop.
10:46:35 <ski> (there's also "partial evaluation" which is yet something else, having a slight connection to partial application, though. i suppose this must be confusing, until you've got the different terms and concepts correctly)
10:46:50 <ph88^> magthe, how can i check which version i am using with stack ?
10:47:05 * ski tends to often call any recursive function a "loop"
10:47:26 <ski> (or other recursive value, for that matter)
10:47:54 <bwe> ski: would a partial evaluation be something in between lazy and evaluated?
10:48:11 <Younder> silly to fall back on fold functions if there are no dependencies between iterations.
10:48:49 <bwe> ski: Is your example finished or what's left to do?
10:49:16 <ski> partial evaluation is a technique for specializing a function to some ("early") inputs, so that it won't have to interpret them later, at "run-time", when the "late" inputs are handed to it
10:49:22 <lynn> Is there a version of `runReader` that's like....  `MonadReader r m => m a -> r -> a`
10:49:29 <ski> partial evaluation can be implemented as a source-to-source translation
10:49:54 <ski> e.g. `\xs -> [0,1,2] ++ xs' could be partially evaluated to `\xs -> 0 : 1 : 2 : xs'
10:50:03 <bwe> ski: is that something like pre-evaluation?
10:50:58 <ski> `\x -> x ^ 11' could be partially evaluated to `\x -> let x2 = x^2; x4 = x2^2; x8 = x4^2 in x * x4 * x8'
10:51:52 <ski> this way, if we're e.g. `map'ping the function over a list of (late) arguments, the function won't have to inspect ("interpret") the early argument over and over again (as naive evaluation would have it)
10:52:17 <lynn> None of the functions in https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html return values that *aren't* wrapped in `m`...
10:52:19 <ski> (er, actually it should be `x * x2 * x8' there, not `x * x4 * x8' ..)
10:52:33 <ski> (because `11' in binary is `1011')
10:52:39 <dolio> Also you probably want to use * instad of ^2.
10:53:17 <lynn> So how do you run a `MonadReader r m => m a` in the first place? It looks impossible
10:53:42 <ski> dolio : hm ?
10:53:44 <glguy> dolio: There's a rewrite rule for ^2 to *
10:53:56 <ski> > x ^ 2
10:53:56 <dolio> x2 = x*x, etc.
10:53:58 <lambdabot>  x * x
10:54:20 <geekosaur> lynn: you don't use MonadReader to run it
10:54:28 <ski> (oh, i suppose you mean inlining the squaring. yes)
10:54:34 <geekosaur> that is provided by the instance, not the class
10:54:43 <geekosaur> e.g. see the definition of ReaderT
10:54:45 <ski> bwe : i'm not sure what you mean by "pre-evaluation" ?
10:54:49 <bwe> ski: So is there yet to learn for me about foldr regarding your example where you highlighted sum is nothing but foldr? What has been your intention giving the example?
10:54:57 <bwe> ski: Never mind.
10:55:23 <glguy> ./libraries/base/GHC/Real.hs:"^2/Integer"    forall x. x ^ (2 :: Integer) = let u = x in u*u
10:56:13 <ski> bwe : `foldl', not `foldr'. also that doesn't really matter much here. my intention was to hopefully give a better intuition for by-name aka lazy reduction
10:56:16 <dolio> Right, that's a really limited example of partial evaluation.
10:56:36 <dolio> Achievable by rules.
10:57:25 <ski> dolio : also `\n -> map (\x -> x ^ n)' ?
10:57:33 <bwe> ski: Can you ask me one question that allows you to see whether I do understand or not, please?
10:57:49 <ski> bwe : understand what ?
10:58:14 <dolio> ski: Eh?
10:58:41 <ski> dolio : iow, with an exponent that isn't a fixed literal natural number
10:58:51 <ski> (which you could add a specific `RULES' for)
10:58:51 <bwe> ski: lazy reduction?
10:59:29 <ski> bwe : well, i was intending to show a reduction/evaluation trace, but you haven't answered yet whether i should go ahead with it or not
11:00:12 <nitrix> bwe: What you asked earlier is not partial evaluation nor a partial function. It was partial application.
11:00:12 <lynn> geekosaur: Hm... I have one function `f :: (MonadRandom m, MonadReader A m) => Foo -> m Foo`, and it is trying to call `g :: (MonadRandom m, MonadReader B m) => Foo -> m Foo`, note the different Reader type
11:00:15 <dolio> ski: I just meant `x^2 ==> x*x` as an example.
11:00:48 <lynn> I can supply the `B` value à la runReader, and the `m` I already have can supply the randomness. But I suppose there's no way to get them to work together :<
11:00:49 <bwe> ski: Please go ahead. (my 'sincerely' was intended to tell you just that)
11:00:51 <ski> ok. i was considering the power function
11:00:56 <geekosaur> lynn: can you make a B from an A?
11:00:58 <nitrix> bwe: In haskell, the type `a -> b -> c` reads as `a -> (b -> c)`, the arrow `->` it is right associative.
11:01:06 <lynn> Yeah, precisely
11:01:17 <nitrix> bwe: This lets us consider functions as the application of one argument which yields another function as a result.
11:01:35 <geekosaur> ?
11:01:46 <lynn> (In my case A is a Map k B, actually!)
11:01:51 <ski> bwe : perhaps, since it's a bit noisy in here atm, it'd be better if we moved into #haskell-overflow for it ?
11:01:58 <dolio> ski: The 'problem' I had with your example was that it seemed weird to partially evaluate `x^m` to something that had recursive calls to `x^n`. That isn't a huge deal, though.
11:02:18 <lynn> I gotta BRB, feel free to answer my question and I'll read the answer later!
11:02:43 <geekosaur> oh wait, thinking about it wrong
11:02:55 <ski> dolio : when i wrote it, i didn't even realize that i happened to express squaring using `(^)', which was what i was partially evaluating ;)
11:03:05 <dolio> :)
11:03:35 <nitrix> bwe: Thus, `foldl (+) 0` is a partially applied function, it is missing some arguments, so the result ends up being a function. Because the result is a function, you're able to present the equality that `sum` is equal to `foldl (+) 0`
11:04:00 <nitrix> bwe: sum = foldl (+) 0
11:04:03 <nitrix> bwe: sum xs = foldl (+) 0 xs
11:04:17 <nitrix> They are extensionally the same.
11:04:39 <ski> (meaning they give equal outputs, given equal inputs)
11:04:52 <bwe> nitrix: I agree ;).
11:05:33 <bwe> Thanks guys for your awesome support. Appreciated.
11:05:55 <ski> (one could think of it as "cancelling" the `xs' at the rightmost of both sides of the defining equation there (only works if there's no other `xs' in the body, of course))
11:15:06 <monochrom> oh w00t GHC 8.0.2 finally!
11:16:42 <kadoban> It get released?
11:16:52 <purelazy> what does it do?
11:17:23 <maerwald> not on the download page
11:17:50 <purelazy> What's the smart way to read a binary file into a [Word32]?
11:17:55 <monochrom> I saw it on haskell-cafe
11:18:09 <kadoban> Ah, maybe in the works then. That's exciting news
11:18:12 <nk109> how does one declare a multiidimension array and initialize it with data? for example, if my data looks like [[4,5,7],[3,2,9],[5,2,9]]
11:18:23 <monochrom> but try http://downloads.haskell.org/~ghc/8.0.2/
11:18:33 <monochrom> maybe the main pages haven't been updated
11:18:56 <nitrix> nk109: Lists, arrays or vectors?
11:19:04 <kadoban> Ya, I'm sure there's a bit of work updating links and whatever else. Wheee, that'll be fun, I'll be looking forward to that.
11:20:12 <nk109> nitrix: I think a list would be fine -- would it be easy for someone later on to convert that to an array or vector if needed?
11:20:36 <nitrix> nk109: If you want a list, then you already have it.
11:22:00 <nitrix> [[4,5,7],[3,2,9],[5,2,9]] is a valid list of lists
11:23:17 <nk109> nitrix than
11:23:18 <nk109> x
11:23:29 <kadoban> You can make an array out of that pretty easily, yeah. Should be something like ... listArray ((0,0), (2,2)) . concat    or any of a bunch of other variations depending on which arrays you want and etc.
11:23:32 <ReinH> purelazy: [Word32] seems like a pretty awful representation of a binary file.
11:24:32 <kuribas> purelazy: why not Bytestring?
11:24:34 <purelazy> ReinH - I need to read in a file and send it to a foreign function as Ptr Word32
11:25:06 <kadoban> purelazy: If you were asking what GHC 8.0.2 does, mostly a ton of bug fixes
11:25:19 <Squarism> theres no trick to list everyting that is defined in a module in GHCI?
11:25:45 <glguy> Squarism: :browse
11:25:58 <purelazy> kadoban: OK - luckily I don't see many bugs
11:26:44 <Squarism> thanks
11:27:27 <purelazy> kuribas: I have a function which required Ptr Word32
11:27:32 <purelazy> kuribas: I have a function which requires Ptr Word32
11:28:27 <purelazy> kuribas: This is foreign function stuff
11:28:43 <kuribas> purelazy: so not a list
11:31:07 <jchia_> What does '#' mean? I see it used in the context of OverloadedLabels and I'm trying to figure that out also.
11:31:37 <jchia_> Does it have meaning apart from OverloadedLabels?
11:32:11 <kuribas> purelazy: https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#t:CString
11:32:48 <glguy> # can be a normal operator symbol, it can be part of a name with MagicHash, it can be a CPP directive, it can be the first character in an overloaded-label
11:32:58 <kuribas> purelazy: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#g:24
11:33:49 <nitrix> jchia_: As in #foo or foo# ?
11:33:59 <jchia_> nitrix: yes
11:34:10 <nitrix> jchia_: I'm asking which.
11:34:18 <jchia_> both
11:34:37 <glguy> foo# is just another name. It could just as well be foohash
11:34:59 <glguy> The MagicHash extension allow you to use the # character like that
11:35:09 <nitrix> `#` as a suffix would be from MagicHash. We use it as an indication for more primitive types or values. They are typically unboxed and of kind `#`.
11:35:11 <jchia_> glguy: So you can have Foo# and foo# and the '#' has no special meaning?
11:35:30 <nitrix> jchia_: As for `#` used as a prefix, it's for labels.
11:35:47 <glguy> By convention it typically means that it pertains to something primitive to the compiler
11:36:02 <glguy> or has a type that has kind #
11:36:05 <jchia_> So when '#' shows up in some of the definitions in GHC.OverloadedLabels, it's not because '#' has any special meaning?
11:36:27 <nitrix> I think he's ignoring me :(
11:36:27 <glguy> # shows up in overloaded labels because they wanted a "namespace" for these overloaded labels
11:37:00 <jchia_> nitrix: I hear you. The context I'm coming from is OverloadedLabels
11:37:09 <glguy> so if you enable that extension, all the names prefixed with a # get translated to a use of 'fromLabel'
11:37:39 <nitrix> "he key idea is that when GHC sees an occurrence of the new overloaded label syntax #foo, it is replaced with fromLabel (proxy# :: Proxy# "foo") :: alpha"
11:38:02 <glguy> #placeholder becomes   fromLabel (proxy# :: Proxy# placeholder)
11:38:11 <jchia_> nitrix: What is 'alpha'? where does it come from?
11:38:47 <jchia_> so, #foo becomes fromLabel (proxy# : Proxy# foo), correct?
11:39:05 <glguy> Proxy# "foo" specifically
11:39:20 <nitrix> It becomes `fromLabel (proxy# :: Proxy# "foo")`
11:39:32 <nitrix> Which has the type `alpha`.
11:39:49 <dolio> Oh man, they implemented it the way I wanted @ to work.
11:40:02 <jchia_> nitrix: alpha from which module? I only see alpha :: CharSet from charset
11:40:10 <nitrix> jchia_: `alpha` is a type variable.
11:40:25 <nitrix> jchia_: It's constrained using `IsLabel "foo" alpha => alpha`
11:40:33 <nitrix> That's documented in the next line.
11:41:00 <jchia_> what's the prerequisite to understanding OverloadedLabels?
11:41:28 <glguy> You should be about there
11:41:32 <nitrix> jchia_: Type classes and constraints I suppose. None of the proxy magic is necessary to understand to use it.
11:41:43 <nitrix> *how
11:42:07 <jchia_> is Proxy related to Proxy#?
11:42:28 <glguy> Same idea, yes.
11:42:36 <glguy> Proxy# promises not to have a runtime representation
11:44:31 <nitrix> Proxy is a data type, so as far as I know, it comes with a little overhead for tagging the constructor and will be lifted too (kind *).
11:44:50 <nitrix> :k Proxy Int
11:44:52 <lambdabot> *
11:46:21 <jchia_> :k Proxy#
11:46:23 <lambdabot> error:
11:46:23 <lambdabot>     Not in scope: type constructor or class ‘Proxy#’
11:46:23 <lambdabot>     Perhaps you meant ‘Proxy’ (imported from Data.Typeable)
11:46:35 <jchia_> what kind of thing is Proxy#?
11:46:41 <jchia_> it has no kind or type
11:46:59 <jchia_> but it's right there in the haddock
11:46:59 <glguy> Proxy# :: k -> TYPE 'GHC.Types.VoidRep
11:53:26 <nitrix> jchia_: Are you familiar with phantom types?
11:53:47 <jchia_> nitrix, yes, somewhat
11:53:56 <nitrix> Same idea, but poly-kinded.
11:54:21 <nitrix> The phantom type doesn't have to be :: *
11:55:14 <jchia_> nitrix: I'm not familiar with "poly-kinded"
11:55:58 <jchia_> In "class IsLabel (x :: Symbol) a where ...", is x a "type-level literal"? What is "Symbol"?
11:56:32 <jchia_> nitrix: Is this what it means by "poly-kinded"? https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/kind-polymorphism.html
11:56:56 <nitrix> jchia_: Yep, it's exactly a type level literal :)
11:57:52 <nitrix> jchia_: "foo" has the kind :: Symbol at that level.
11:58:20 <jchia_> nitrix: but what Symbol? I can't find it on hoogle
11:58:47 <nitrix> http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html
11:58:47 <jchia_> is it this one? https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Types.html#t:Symbol
11:58:50 <srk> heh, leakage https://hackage.haskell.org/package/inilist
11:59:18 <nitrix> jchia_: It is, but it's re-exported in base afaik.
11:59:54 <jchia_> OK
12:00:13 <nitrix> import GHC.Types( Nat, Symbol )       
12:00:25 <nitrix> module GHC.TypeLits ( ... Symbol ... )
12:00:33 <nitrix> Yeah it's re-exporting it in base.
12:02:12 <jchia_> So, I need to know DataKinds & PolyKinds only if I want to know how OverloadedLabels work but not if I just want to use, correct?
12:03:40 <nitrix> Correct.
12:04:51 <jchia_> nitrix & glguy: Thanks for your time, I'll keep digging the docs
12:05:15 <nitrix> jchia_: It's the same concept as IsString.
12:07:00 <nitrix> Only, your starting type is some `Proxy# x` instead of `String`, which lets you have types of various kinds, which enables GHC to turn "foo" into a type-level literal of kind Symbol.
12:08:07 <nitrix> (Effectively labelling stuff)
12:10:33 <lpaste> xcmw revised “Best way to work around not being apple to partially apply type families?”: “Best way to work around not being apple to partially apply type families?” at http://lpaste.net/351118
12:11:55 <bab> unpl id
12:12:17 <xcmw> I have been using that method. Does a better method exist?
12:12:38 <nitrix> bab: You want @unpl
12:13:28 <bab> @pl \(x,y) (w,h) -> (x+w, y+h)
12:13:28 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
12:13:42 <bab> thanks, ouch :)
12:13:43 <glguy> xcmw: You can look into how the singletons package handles things
12:13:43 <glguy> https://github.com/goldfirere/singletons
12:14:04 <glguy> You name all the partial applications of things and use an explicit application operator
12:14:19 <glguy> They probably talk more about it in the associated paper
12:14:47 <nitrix> bab: bimap (+) (+)
12:14:55 <xcmw> glguy: Ok thanks
12:15:20 <nitrix> bab: Oh not quite.
12:17:02 <bab> the game is on :)
12:17:45 <ski> @type (fst *** fst) &&& (snd *** snd)
12:17:46 <lambdabot> ((c, b), (c', b1)) -> ((c, c'), (b, b1))
12:18:15 <nitrix> biliftA2 :: Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f
12:18:28 <ski> @type (uncurry (+) *** uncurry (+)) . ((fst *** fst) &&& (snd *** snd))
12:18:31 <lambdabot> (Num c', Num c) => ((c, c'), (c, c')) -> (c, c')
12:18:31 <nitrix> biliftA2 (+) (+)
12:18:35 <nitrix> That'd work I think.
12:19:11 <johndcl> Has Quasiquotation anything to do with https://en.wikipedia.org/wiki/Quasi-quotation ?
12:19:47 <ski> @type (uncurry (+) . (fst *** fst)) &&& (uncurry (+) . (snd *** snd))  -- i suppose
12:19:48 <lambdabot> (Num b, Num c) => ((c, b), (c, b)) -> (c, b)
12:19:59 <geekosaur> johndcl, it's related to the other one linked at the very top
12:20:11 <bab> nitrix: nice one!
12:20:35 <nitrix> biliftA2 (+) (+) :: Biapplicative w => (a, b) -> (a, b) -> (a, b)
12:20:42 <geekosaur> where it means that code is partially quoted, with the ability to expand selected tokens
12:21:27 <nitrix> bab: Thanks. Let me know how it goes :)
12:21:45 <johndcl> geekosaur: ok, thanks
12:22:59 <bab> nitrix: join biliftA2 (+) -- :)
12:23:53 <nitrix> Meh. Biapplicatives are already overkill for this, let's not bring monads :P
12:23:59 <bab> hehe
12:24:53 <nitrix> I'd personally just have a helper foo f (x, x') (y, y') = (f x y, f x' y')
12:25:37 <nitrix> Unless it's for a library and you need to support other things than 3-tuples.
12:25:43 <nitrix> Sorry, 2-tuples.
12:25:46 <Hermit> I'm having troubles building a monad transformer meant to model stateful communication. I'm trying to define callbacks for control messages. It's all good if these events are of any layer inside or below the transformer stack, but what if I want to deal with layers above said stack? I'm guessing it's not possible, and maybe it's even a good thing that it can't be done, but... is it really so?
12:26:25 <ertes> Hermit: you can't go back up, because as far as you're concerned, there is no "up"
12:26:45 <ertes> Hermit: similar to how if you only have a coordinate, you can't see the vector it came from
12:26:47 <geekosaur> it is really so, and what you are describing sounds wrong/incorrect use case for that kind of transformer
12:27:40 <Hermit> ertes: right... that's along the lines of what I was thinking. Any layer knows of what's below, but has no way to know what may be lifted into
12:30:43 <ertes> Hermit: also what geekosaur said
12:39:17 <ski> @let foo k = k -> curry (k . (uncurry ($) *** uncurry ($)) . ((fst *** fst) &&& (snd *** snd)))
12:39:17 <lambdabot>  Parse failed: Parse error: ->
12:39:22 <ski> @let foo k = curry (k . (uncurry ($) *** uncurry ($)) . ((fst *** fst) &&& (snd *** snd)))
12:39:25 <lambdabot>  Defined.
12:39:49 <ski> @type (foo . foo) id ((+),(+))
12:39:51 <lambdabot> (Num c', Num c1) => (c1, c') -> (c1, c') -> (c1, c')
12:40:00 <ski> @type \f -> (foo . foo) id (f,f)
12:40:02 <lambdabot> (a -> a1 -> c') -> (a, a) -> (a1, a1) -> (c', c')
12:40:05 <ski> @type \f -> (foo . foo . foo) id (f,f)
12:40:07 <lambdabot> (a -> a1 -> a2 -> c') -> (a, a) -> (a1, a1) -> (a2, a2) -> (c', c')
12:41:10 <zipper> ski: Just as you said "Some texts refer to the image of f as the range of f, but this usage should be avoided because the word "range" is also commonly used to mean the codomain of f."
12:41:13 <ski> @type \f -> foo id (f,f)
12:41:15 <zipper> https://en.wikipedia.org/wiki/Image_(mathematics)#Inverse_image
12:41:17 <lambdabot> (a -> c') -> (a, a) -> (c', c')
12:41:28 <ski> @type foo id
12:41:29 <zipper> or did ski quickly edit the wikipedia page :P
12:41:30 <lambdabot> (a -> c1, a1 -> c') -> (a, a1) -> (c1, c')
12:41:40 <ski> zipper : nah :)
12:42:32 * ski idly wonders whether there's a nicer implementation of `foo'
12:52:04 <ski> @type ((fst . fst) <*> (fst . snd)) &&& ((snd . fst) <*> (snd . snd))
12:52:06 <lambdabot> ((a -> c, b -> c'), (a, b)) -> (c, c')
12:52:13 <ski> @type \k -> curry (k . (((fst . fst) <*> (fst . snd)) &&& ((snd . fst) <*> (snd . snd))))
12:52:15 <lambdabot> ((c1, c') -> c) -> (a -> c1, b -> c') -> (a, b) -> c
12:52:17 <ski> @type foo
12:52:19 <lambdabot> ((c1, c') -> c) -> (a -> c1, a1 -> c') -> (a, a1) -> c
12:52:33 <ski> not that prettier ..
12:55:33 <codfection> hello
12:55:42 <shapr> hi codfection, how's cod?
12:55:43 <shapr> er, code?
12:56:04 <codfection> cod
12:56:08 <codfection> e is missing.. sad life
12:56:56 <shapr> codfection: learned anything neat about Haskell lately?
12:57:23 <codfection> shapr, yup
12:57:56 <shapr> ooh, like what?
12:58:43 <codfection> shapr, but currently focusing on C more.. its more procedural and not functional like haskell.
12:59:25 <tdammers> as in, it's more dysfunctional, and you have to go through a lot of procedures to get anything done?
12:59:54 <codfection> shapr, haskell was getting difficult for me.. idk why.. perhaps because I am not good at maths or the structure of the language..
13:00:01 <codfection> tdammers, heh.
13:00:13 <hits1911> I'd add side-effects as well.
13:02:12 <codfection> tdammers, haskell is quick and effective I agree, but at the same time requires a bit more efforts than procedural language due to its direct application
13:02:37 <shapr> codfection: I have that problem myself sometimes. I'm also not good at math.
13:02:40 <codfection> or atleast thats what I feel.. I am trying to improve in haskell.. a bit challenging for me.
13:03:01 <ReinH> codfection: when you're better at doing one thing, that thing seems easier
13:03:09 <ReinH> that doesn't mean that it is easier in any objective sense
13:03:16 <maerwald> maybe rust is more fit for you if you're a lot into procedural but want a bit more high-level stuff
13:03:24 <ReinH> if you were better at Haskell than C, Haskell might seem easier.
13:03:49 <ReinH> I think Haskell is *much* easier than C.
13:03:55 <ReinH> But then, I am not very good at C.
13:04:04 <codfection> ReinH, I guess you're right.
13:04:10 <shapr> codfection: I've recently had some success improving my Haskell by solving advent of code problems.
13:05:24 <codfection> maerwald, I see. I am not into procedural but its just that's where I have started my basics so I have a grip on that.
13:06:03 <codfection> I found haskell to be more interesting and direct. I love haskell. I am trying to get good at it. 
13:06:18 <codfection> shapr, any specific advent of code problems?
13:06:50 <shapr> codfection: some are easy, I suggest this one: http://adventofcode.com/2016/day/3
13:07:08 <codfection> thanks shapr.
13:07:10 <shapr> some are more difficult, but writing an interpreter for day 12 was SO MUCH FUN
13:09:00 <jchia_> What's the :<: in this code? https://github.com/ocharles/blog/blob/master/code/2014-12-08-type-operators.hs
13:09:26 <drdo> xb
13:09:27 <drdo> oops
13:09:52 <c_wraith> jchia_, defined almost immediately in the file. 
13:10:00 <c_wraith> jchia_, it's the name of a class. 
13:10:55 <sboosali> codfection: shapr: configuring a window manager (xmonad.hs) and writing shell scripts (with `turtle`) can also be both challenging and rewarding.
13:11:10 <codfection> sboosali, oh yea.. I use i3wm thou :P
13:11:12 <shapr> sboosali: oh I just got started playing with turtle recently!
13:11:18 <jchia_> c_wraith: Why lowercase? I thought class names have to be uppercase?
13:11:19 <shapr> and I've been using xmonad forever, it's wonderful
13:11:22 <codfection> heard good things about xmonad
13:11:34 <codfection> shapr, have you tried i3wm?
13:11:39 <tdammers> codfection: for me, Haskell is by far the easiest language, but it took me a few years to get there
13:11:43 <c_wraith> jchia_, the name of the class is :<:
13:11:56 <c_wraith> jchia_, and : is considered to be capital
13:12:09 <codfection> tdammers, I see. is there any specific(s) advantages you see of haskell over other languages?
13:12:11 <suppi> tdammers: to me as well :o
13:12:20 <jchia_> c_wraith: Something new to me. Didn't know symbols can be class names and can appear in an infix fashion.
13:12:22 <bodisiw> tdammers, i hope to get there in a few years :-)
13:12:23 <shapr> codfection: No, I used ion, ion2, and ion3, and then switched to xmonad
13:12:30 <tdammers> codfection: the type system, mostly
13:12:55 <jchia_> c_wraith: So, I could say "class a `Foo` b where...", right?
13:13:10 <shapr> sboosali: I recently had the idea to try using turtle inside a Haskell shell, but I'm not sure how to approach that
13:13:37 <tdammers> Haskell's type system is good enough for type-driven development (and, more importantly, type-driven refactoring)
13:13:47 <c_wraith> jchia_, maybe. I don't remember how much TypeOperators enables. 
13:14:01 <tdammers> but Haskell is also mature enough and has a good enough library ecosystem to be a reasonable choice for real-world projects
13:14:26 <c_wraith> jchia_, types can't be operators in base haskell, it's what that extension is for. 
13:15:03 <shapr> sboosali: do you have any turtle scripts on github or something? I've only written one turtle script so far, and it was work to get there.
13:15:06 <jchia_> c_wraith: ok
13:15:59 <codfection> thanks for the suggestions sboosali. can you enlighten me more about turtle scripts? is it this one? https://hackage.haskell.org/package/turtle
13:16:11 <nitrix> If GHC ever dies, Haskell's going to have big issues.
13:16:26 <suppi> i might have been a more capable programmer had i not learned haskell though...
13:16:58 <codfection> lol
13:17:04 <nitrix> The ecosystem has mostly evolved to depend on the GHC extensions.
13:17:20 <nitrix> What are the chances these make it up in the official report ?
13:17:20 <kadoban> nitrix: The beauty of open source is that it kind of ... can't die, as long as there's people who care still.
13:18:14 <nitrix> Even simple things like TupleSections seems highly discussed.
13:19:29 <ski> hits1911 : ?
13:20:16 <tdammers> real-world programming is not the only driving force behind the Haskell Report
13:20:53 <tdammers> if it were, then including most GHC extensions in the standard would be a no-brainer
13:21:24 <tdammers> but there is also value in having a simpler language standard that makes it easier to implement experimental compilers for research purposes
13:21:30 <tdammers> even if none of those ever goes mainstream
13:22:40 <maerwald> I don't like the gap between the report and ghc
13:23:31 <jle`> is anyone really comfortable with the gap
13:24:15 <nitrix> Point is, I'd fix the gap by modifying the report, not the other way around.
13:24:44 <maerwald> well, there are some GHC extensions that would definitely not make it into the report (because semi-broken or sth)
13:24:58 <jle`> maybe just call ghc haskell its own language, the ghaskel
13:25:03 <nitrix> What about stuff like fundep ?
13:25:19 <jle`> haskell would be a family of languages, then
13:25:24 <nitrix> Or multiparameter type classes? It seems almost mendatory for Haskell.
13:25:26 <jle`> like lisp or ml
13:25:28 <maerwald> and also interesting debate could be: do we want the RTS to be specified in the report?
13:25:37 <jle`> *cam
13:26:04 <nitrix> maerwald: Maybe a couple notes on the lazy evaluation could be great.
13:26:52 <hits1911> ski: there was a comparison between c and haskell. I meant there are much more side-effects in c than haskell. states etc.
13:27:21 <ski> well, yes, because there are no side-effects in Haskell at all
13:27:33 <ski> (as opposed to *effects*, which are plentiful)
13:27:37 <nitrix> hits1911: Haskell allows effects, but side-effects should be impossible.
13:32:32 <hits1911> sorry if I used wrong term. I was talking about IO () etc.
13:32:50 <hits1911> Don't we call them side-effects?
13:33:54 <int-e> we call them effects
13:34:07 <geekosaur> a side effect is something non-obvious / unintentional that happens elsewhere. actions in IO are intentional
13:35:26 <hits1911> hmm. I get it now. thanks.
13:39:21 <ur_> How would you do this type of iteration in haskell?
13:45:55 <pikajude> :t for
13:45:57 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
13:46:29 <sboosali> codfection: yes, sorry for the delay! was getting stuff done lol. 
13:46:35 <cheater> hi
13:46:42 <cheater> i receive id's of objects which are in a tree-like structure. for each id i can get its parent id. i receive ids one by one and need to check that all ids i have received are located in one branch on the tree, i.e. if you start with the leaf-most one and go to the parent repeatedly you'll visit all of them. what's the best way to do that?
13:51:12 <sboosali> codfection: Yeah, let me find it. Also, today I can take a look at the script you wrote.
13:51:28 <sboosali> shapr: (not codfection)
13:52:02 <ongy> cheater: do you want to make sure they are all nodes in the sub-tree, or that all the nodes are in that sub-tree?
13:52:21 <cheater> i want to make sure that they are all nodes in a single branch of the tree
13:52:46 <cheater> i.e. they're all ancestors or successors of one another
13:52:53 <cheater> and there's no forking
13:52:59 <sboosali> shapr: As far as Haskell shells, yeah there are a few libraries, but I don't think any of them balance the convenience of bash syntax with the power of Haskell. I just write mine in a file with a "stack header" so it's standalone.
13:53:17 <Squarism> theres no set implementation that crashes if i try to add soemthing already there?
13:53:20 <Squarism> Set
13:54:37 <sboosali> Squarism: that throws an error? 
13:54:49 <Squarism> yeah
13:55:04 <sboosali> you can make your own lookup that does that
13:55:33 <Tuplanolla> I don't see an efficient way to use `Data.Set` for that, sboosali.
13:56:03 <Tuplanolla> It doesn't expose `insertR`.
13:56:48 <mizu_no_oto_work> Unfortunately, Data.Set takes advantage of data hiding.  But you *can* copy Data.Set and add in an efficient version of the operation if you want.
13:57:17 <mizu_no_oto_work> I'd do the inefficient thing first, though, since it has the same asymtptotics
13:57:41 <mizu_no_oto_work> the inefficient thing being to lookup then insert or return Nothing.
13:58:34 <mizu_no_oto_work> and if profiling reveals it as a hotspot, the fix isn't *hard*, it just comes with a maintenance cost (i.e. using your own version of Set).
13:59:14 <sboosali> Squarism: What's your use case?
14:00:17 <magthe> ph88^: use `stack exec`, something like `stack exec ghc-pkg -- list foundation` should work
14:01:06 <Squarism> sboosali, ive implemented this game and have many sets i move pieces from and to.. just scared a hard to detect bug could be propagated if the wrong items are moved from set to set
14:01:54 <Squarism> ...so would be nice with a Set implementation that crash if i try to add something already there
14:02:02 <sboosali> Squarism: Can you go into more detail, like can the sets have different types? Or are they numerical types for efficiency or something like that?
14:02:28 <Koterpillar> Squarism: how about you store a mapping from pieces to the place they are in?
14:03:29 <sboosali> Squarism: you could reexport all the set functions, but shadowing the idempotent insert with your own failfast insert (that looks up first). 
14:03:40 <Squarism> Koterpillar, good idea - except it would require "work"
14:04:36 <Squarism> sboosali, rexport?
14:04:47 <Squarism> ah ok
14:06:45 <mzabani> hi everyone, can anyone help me develop a practical database connection pool that can be used in a Servant application? I was trying to do this with some kind of MonadDB monad transformer but my amateur haskell isn't helping much
14:07:07 <sboosali> Squarism: Like you define "module data.set.once" which imports data.set and re-exports everything "hiding (insert), as well as your own insert".
14:09:05 <Squarism> sboosali, i could try that
14:09:54 <Squarism> But would S.union and S.unions use that?
14:10:55 <Cale> mzabani: perhaps https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html would interest you
14:11:33 <sboosali> Squarism: right, yeah you'd have to take a look at all callers of insert, or of all functions that transform sets generally. Can you talk more about what these different sets store, and why the same item shouldn't be inserted twice (you mentioned moving between sets)?
14:12:41 <mzabani> Cale: I've written a startPool :: IO (Pool Connection) function, but I'm having trouble understanding how to get a different handler monad in Servant and how to expose an app pool that gets created only once in all of the application's life
14:13:48 <sboosali> Squarism: Like without knowing more, I just vaguely say maybe the sets can hold items of different types, or that you should make a new type that stores multiple sets and manages them opaquely, or something like that.
14:14:12 <pikajude> mzabani: that's what enter is for, right?
14:14:37 <pikajude> http://hackage.haskell.org/package/servant-server-0.9.1.1/docs/Servant-Server.html#g:5
14:15:48 <mzabani> pikajude: I guess so, but it seems magical and I can't really understand it... also, I'm having a hard time coming up with a monad transformer that ensures rollback of any open transactions, one of my main concerns.
14:15:55 <pikajude> oh, ok
14:16:06 <mzabani> sorry if my question seems vague, but I'm pretty new to all of this
14:16:17 <pikajude> one sec, let me get my repl out
14:17:12 <pikajude> mzabani: so you have a server of type Server MyAPI right
14:18:11 <mzabani> yep, Server API
14:19:07 <pikajude> so `enter (runReaderTNat myConnectionPool) myServer` is equivalent to myServer, except it adds a ReaderT layer holding the connection pool
14:19:16 <pikajude> also, you can ask in #servant about this stuff
14:19:30 <Squarism> sboosali, thanks for input.. ill need to evaluate my options
14:20:58 <mzabani> pikajude: I didn't know there is a #servant! 
14:21:07 <pikajude> now you do
14:21:12 <mzabani> what about those crazy type signatures, how do I understand them?
14:21:34 <pikajude> i can walk you through one in #servant 
14:22:10 <mzabani> pikajude: thank you for your help! Let us continue this at #servant, then
14:33:49 <ReinH> mizu_no_oto_work: I'm not sure if it helps, but containers recently started to export internals modules
14:34:21 <ReinH> which might provide what they need to build whatever it is they wanted
14:43:56 <danza> hey all, i use often a type like [(String, Float, UTCTime)]. Do you think that it would make sense to upload a package to Hackage where i define that data type?
14:44:16 <Koterpillar> danza: what's its name?
14:44:36 <danza> well it has no name yet ... i was thinking of `Timestamped`
14:45:04 <ski> what's the `String' and `Float' for ?
14:45:08 <Koterpillar> ^
14:45:27 <Koterpillar> danza: data Timestamped a = Timestamped a UTCTime ?
14:45:41 * ski was just having that in mind
14:45:44 <danza> hum
14:46:29 <danza> alright, that makes sense, but the fact is that i use it often in that form
14:46:35 <ski> (of course, i'd name the data constructor otherwise)
14:47:23 <Tuplanolla> What is `Float` good for, besides passing data to graphics libraries, danza?
14:47:24 <ski> if you mean for it to be used by other people, higher chance of that, with allowing any custom data the user wants stamped
14:47:45 <danza> i use it for data collection
14:47:47 <ReinH> danza: data TimeStamped a = TimeStamped UTCTime a :)
14:48:07 <ReinH> then a can be, e.g., (String, Float)
14:48:32 <Tuplanolla> Koterpillar just suggested that, ReinH.
14:48:35 <ReinH> also that should probably be (Text, Double)
14:48:48 <ReinH> Tuplanolla: Yeah, I missed that while I was typing my response :)
14:49:05 * ski grins
14:49:15 <danza> well for example i have a library that draws streamgraphs ... the main function get as an input a list of data points https://github.com/danse/streamgraph/blob/master/Streamgraph.hs#L23
14:49:24 <danza> so i guess i should define that type somewhere
14:50:14 <danza> i wanted to define it outside the graphics library ... because i also want to be able to calculate a time series on it, for example ...
14:50:29 <danza> but maybe it does not make sense ... i am not sure
14:51:41 <FerdinandvW> Hey guys, I'm using the RebindableSyntax pragma so that I can use do-notation for an IndexedMonad. However, one of the consequences is that the if-then-else syntax is no longer in scope. Is there someway I can import it?
14:53:19 <FerdinandvW> Specifically the error I'm getting is as follows: "Not in scope: `ifThenElse`"
14:53:39 <Tuplanolla> @hoogle ifThenElse
14:53:41 <lambdabot> Data.Bool.HT ifThenElse :: Bool -> a -> a -> a
14:53:41 <lambdabot> Data.Boolean.Overload ifThenElse :: IfB a => BooleanOf a -> a -> a -> a
14:53:41 <lambdabot> Prelude ifThenElse :: Bool -> t -> t -> t
14:53:59 <sboosali> danza: yeah, that type comes up a lot, like https://hackage.haskell.org/package/logging-effect-1.1.1/docs/Control-Monad-Log.html#t:WithTimestamp
14:54:07 <FerdinandvW> hmm, I did try importing it from prelude
14:54:14 <FerdinandvW> i'll try again, maybe I did something wrong before
14:54:46 <FerdinandvW> ah Prelude doesn't export it, so that's  why it didn't work
14:54:54 <Tuplanolla> You can define it yourself as well, FerdinandvW.
14:55:09 <FerdinandvW> Yea I guess so
14:55:15 <FerdinandvW> thanks for the help
14:55:28 <Tuplanolla> It should be available somewhere.
14:55:51 <Tuplanolla> Using `RebindableSyntax` with GHCi is especially annoying because of this.
14:56:19 <danza> sboosali, so maybe i should also define it within my library, and not expect to define it in a dedicate package. Also, `Timestamped a` seems a good idea, but actually i use a lot `Timestamped (String, Float)`
14:57:11 <danza> i guess that my problem is that i want to reuse a precise type without polluting Hackage
14:57:23 <danza> maybe i should just use Stack and point to packages directly on Github
14:57:51 <FerdinandvW> how come if I go to hoogle and search for 'ifThenElse' nothing comes up, but apparently here you do get results...
14:57:51 <sboosali> danza: yeah, unless it's got enough functions or interesting instances, the datatype alone might not be worth it.
14:57:58 <sboosali> *utility functions
14:57:58 <ReinH> @danza ReinH> then a can be, e.g., (String, Float)
14:57:58 <lambdabot> Unknown command, try @list
14:58:03 <ReinH> oops, sorry
14:58:10 <ReinH> I guess I forgot how to irc
14:59:00 <danza> this might be the first valid reason i have to switch to Stack ... but first i'll check for referencing Github directly with Cabal
14:59:27 <byorgey> pretty sure cabal can't do that
14:59:38 <kadoban> I don't think I'd really worry about polluting hackage myself.
14:59:54 <danza> 'cause it's already polluted?
15:00:19 <kadoban> Well, that and ... it doesn't seem to matter much minor extra pollution. And if it's something that's useful, is it really pollution?
15:00:36 <ph88^> magthe, when i run that command i get this https://paste.fedoraproject.org/525835/41755801/ doesn't really tell me on which commit that version was created
15:01:09 <danza> it's useful to me, not sure it might be useful to others ... i find Hackage already polluted, but i am an idealist :P
15:01:38 <danza> also, i am new to Haskell ... not sure what the habits in the community are
15:01:58 <danza> i think that there should be a dedicate namespace/category for "uninteresting datatypes"
15:04:16 <Squarism> hslogger or logger?
15:04:27 <Squarism> which is "better"
15:08:49 <danza> anyway, the idea of a `Timestamped a` is good and it will allow me to make my time series code very generic. Thanks all!
15:09:49 <Squarism> ...ill roll with "logger"
15:10:02 <Koterpillar> danza: think about how you can make this type more useful; right now the effort to import your library from Hackage is roughly the same as just writing the definition of Timestamped
15:10:39 <danza> i'd add the code to convert `[Timestamped a]` to time series, if a is a monoid
15:11:10 <Tuplanolla> Note that your `Timestamped` is now exactly `(UTCTime,)`, danza.
15:12:30 <Tuplanolla> :k (,) Data.Time.UTCTime
15:12:32 <lambdabot> * -> *
15:18:01 <danza> alright maybe i can keep this in the context of my visualisation library. It does not seem to make much sense by itself. Thanks for the feedback!
15:20:16 <SegFaultAX> Are there any decent (for whatever definition of decent you like) stream processing libraries (akin to Flink/Samza/Spark) in Haskell?
15:20:35 <danza> SegFaultAX, like conduit?
15:20:44 <SegFaultAX> Perhaps, let me check it out. :)
15:22:31 <SegFaultAX> danza: Does conduit support windowing and triggering (a la Dataflow)?
15:22:59 <danza> i'm not sure
15:25:14 <SegFaultAX> danza: Do you know what I mean by windowing? It might be called something different in conduit but be semantically equivalent...
15:26:21 <danza> right, that's why i answering so vaguely. I am not an expert about Conduit, i just mentioned it because i think it's a streaming library, and i know it's very popular
15:26:39 <danza> *answered*
15:28:51 <danza> SegFaultAX, are you familiar with lazy evaluation in Haskell? By leveraging that you can write code that you would write with streaming libraries in other languages. But lazy evaluation is difficult to master so probably a library might still be the best way to go
15:29:45 <synaptic> hey guys, question: is there an efficient library for working with planes/3d space? pretty new to haskell and I haven't looked around much
15:34:47 <hodapp> synaptic: what sort of 3D operations are you needing?
15:36:31 <synaptic> standard linear algebra
15:37:31 <hodapp> I feel like I've used hmatrix for that in the past
15:37:57 <synaptic> gotcha, i'll check it out. thanks :)
15:39:57 <manek> Hello guys! Have anybody here used fingertrees in the past? I try to implement something but I cannot get started right :(
15:40:47 <glguy> manek: Probably lots of people have; you should ask your actual question
15:41:25 <manek> In fact, the question is - could we use fingertrees to implement interval trees in such way, that each interwal knows only about it size (not start - end segment). So we can easily scale some earlier intervals, so later would be "shifted" ?
15:41:32 <manek> glguy: ^^^ :)
15:42:45 <manek> Or fingertrees would not be the optimal solution here? Performance is important for me. I need to be able to scale the intervals, add, remove and lookup them
15:45:53 <kadoban> When you scale do you scale all current intervals? Then you could just ... whatever interval tree, and keep a separate "scale" modifier, and use that when you query, etc.
15:48:11 <shayan_> any suggestions on some introductory books on algorithms?
15:49:13 <manek> kadoban: no, these intervals are just nested expressions over input source code (this is AST <-> scr code mapping). If I change some part of the ast I want to update some part of the source code, so only this interval would be changed
15:49:21 <monokrome> Hiii!
15:49:26 <EvanR> shayan_: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:50:17 <manek> kadoban: So If I've got intervals (0,10), (11,20) and (21,30) and grow the second one about 5, I'll get (0,10), (11,25) and (26,30)
15:50:25 <shayan_> EvanR: Actually ordered that book a couple days ago!
15:50:34 <EvanR> nice
15:50:36 <manek> *(26,35)
15:50:47 <monokrome> Does anyone know what I need to cabal install to get this package? Sorry, I'm just learning Haskell :} https://gist.github.com/monokrome/9c63cd1ff07c328ba8be93487c6e7beb
15:51:30 <dibblego> monokrome: you will need to install utf8-string
15:51:51 <kadoban> Appears to be from ... yea, that package.
15:51:57 <monokrome> dibblego: Thanks! Is there an easy way to answer that question instead of bothering everyone in IRC? :}
15:52:12 <FerdinandvW> wouldn't he need to install bytestring?
15:52:15 <ertes> manek: i see no easy way to achieve that without dropping to linear complexity
15:52:21 <monokrome> she* <3
15:52:28 <FerdinandvW> sorry :)
15:52:31 <monokrome> no worries :}
15:52:33 <glguy> monokrome: You can type "Data.ByteString.UTF8" into google and it usually lists the package as one of the top results
15:53:16 <glguy> FerdinandvW: GHC comes with bytestring, and if now, cabal install utf8-string would install it as a dependency
15:53:22 <monokrome> oooh good idea
15:53:24 <geekosaur> @where hayoo
15:53:24 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
15:53:29 <monokrome> I tried that, but with the entire error instead of just the module name
15:53:31 <monokrome> Thanks a ton :}
15:53:35 <geekosaur> another good way to look these things up
15:53:44 <ertes> manek: my initial response is: if anything, it would have to be done with deltas, but that doesn't play well with the requirement that the measure is a monoid
15:53:47 <FerdinandvW> i see
15:53:49 <jstolarek> I have
15:53:58 <jstolarek> type Foo = StateT () IO
15:54:07 <manek> ertes: you can keep tree with nodes and each tree contains info about the size of its subchilds cumulated, so if you grow a child everything updates to the top. If you lookup, you can choose to go left or right based on the cumulated size. For me its log n
15:54:19 <jstolarek> how can I catch exceptions in that monad using catch?
15:54:34 <ertes> manek: yeah, but i don't think you can implement that in terms of FingerTree
15:54:42 <EvanR> catching exceptions is an IO thing
15:54:45 <EvanR> use liftIO
15:54:49 <manek> ertes: measure couldnt be just the cumulated length somehow ?
15:55:21 <ertes> manek: it can, but *shifting* will be linear, because FingerTree is inherently absolute (i.e. no deltas)
15:55:22 <jstolarek> EvanR: but liftIO seems to work in the oposite direction that I want
15:55:31 <jstolarek> catch takes and (IO a)
15:55:36 <jstolarek> while I have (Foo a)
15:55:37 <manek> ertes: hmm, I dont know fingertrees so good yet, so I was just trying to learn how they are implemented under the hood exactly. Are you sure it couldnt be done ?
15:55:38 <ertes> manek: you need something based on deltas
15:55:47 <jstolarek> with Foo being IO with a state
15:55:51 <manek> ertes hmm
15:56:02 <geekosaur> jstolarek, this is the space MonadBaseControl operates in. it's ... painful, and very bug prone
15:56:15 <ertes> manek: it's not necessarily a property of finger trees in general (i'm not sure if they would be able to support your idea), but specifically of the implementation in the fingertree package
15:56:32 <EvanR> jstolarek: look at the type of liftIO
15:56:37 <ertes> manek: perhaps a binary-tree-based approach would work better for you
15:57:00 <jstolarek> EvnaR: I did
15:57:01 <ertes> manek: unfortunately you'll most likely have to implement it yourself
15:57:12 <jstolarek> IO a -> m a
15:57:16 <EvanR> :t liftIO
15:57:18 <lambdabot> MonadIO m => IO a -> m a
15:57:23 <jstolarek> it seems to be thee opossite of what I want
15:57:30 <EvanR> no
15:57:34 <jstolarek> :t catch
15:57:36 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
15:57:45 <EvanR> liftIO (catch foo bar)
15:57:49 <manek> ertes: ok, thank you. Its not unfortunetaly, Ill do it with a pleasure. I just want to investigate the possiblities of fingertrees and would love to **understand** why std implementation (like lib fingertree) would be too limited for this use case
15:58:02 <ertes> jstolarek: you can't
15:58:14 <ertes> jstolarek: you need to unwrap the StateT first, then rewrap it again
15:58:24 <EvanR> that is what liftIO does
15:58:32 <Gurkenglas> Could the safe package implement yet another version of each *Note function that at compile-time automatically chooses as the note the source location where it was used?
15:58:36 <geekosaur> no, liftIO runs an IO action, not a Foo action
15:58:47 <jstolarek> EvanR: but foo has type (Foo ())
15:58:49 <ertes> jstolarek: however, there are libraries to do that automatically for you, e.g. exceptions (MonadCatch), mtl (MonadExcept), monad-control (MonadBaseControl)
15:58:51 <EvanR> catch is an IO action
15:58:56 <ertes> EvanR: you can't use liftIO
15:59:00 <jstolarek> catch expects IO ()
15:59:22 <geekosaur> EvanR, the point is that catch cannot run a Foo action either
15:59:27 <jstolarek> EvanR: liftIO changes the type of the result, not the argument
15:59:44 <geekosaur> unless you unwrap/rewrap, which isn't always possible
15:59:45 <EvanR> transformers, damn
15:59:53 <geekosaur> although here it may be
15:59:53 <ertes> jstolarek: if 'catch' is all you need, i'd just go with mtl's MonadExcept
16:00:00 <exio4> or anything non-IO EvanR, actually :P
16:00:06 <ertes> EvanR: transformers doesn't have a class for it =)
16:00:09 <ertes> or does it?
16:00:23 <ertes> nope, it doesn't
16:00:33 <Kirkland_Signatu> @chanstats
16:00:34 <lambdabot> Unknown command, try @list
16:00:41 <Kirkland_Signatu> uh oh spaghettioh
16:00:43 <jstolarek> ertes: yes, this looks like what I need
16:00:54 * EvanR writes down the latest reason not to use StateT over IO
16:00:57 <Kirkland_Signatu> how do i see the most active channels
16:01:27 <Kirkland_Signatu> guys
16:01:29 <Kirkland_Signatu> tells me
16:01:31 <Kirkland_Signatu> NAO!!!
16:01:32 <Gurkenglas> Hmm. We need Codensity monad transformers t where liftC :: Codensity m a -> Codensity (t m) a?
16:01:36 <Kirkland_Signatu> AAAAAAAAAAAA
16:01:39 <Kirkland_Signatu> holy shit
16:01:43 <Kirkland_Signatu> you guys are nerds
16:01:47 <Kirkland_Signatu> all u do is code
16:01:52 <EvanR> for christ sake
16:01:59 --- mode: ChanServ set +o glguy
16:01:59 --- mode: glguy set +b *!*@26-45-77-204.ar.cc.mn.us
16:01:59 --- kick: Kirkland_Signatu was kicked by glguy (noise)
16:02:06 <hodapp> ...
16:02:24 <EvanR> (referring to Gurkenglas's solution)
16:03:28 <Gurkenglas> EvanR: Got a blog post with a list of those reasons?
16:03:32 <ertes> jstolarek: should you ever need it, monad-control generalises the idea to basically arbitrary actions, e.g. forkIO
16:03:38 <EvanR> not really
16:04:09 --- mode: glguy set -o glguy
16:05:21 <jstolarek> ertes: after a closer look this is not exactly what I need
16:05:29 <jstolarek> the problem is that I need to catch error
16:05:30 <jstolarek> as in
16:05:37 <jstolarek> error "bad thing happened"
16:06:27 <jstolarek> I have a program that signalizes every possible problem by calling error
16:06:47 <jstolarek> and I wantto add an interpreter on top of that
16:07:02 <jstolarek> and I don't want it to blow in the face of the user every time something goes wrong
16:07:17 <manek> jstolarek: does not use error
16:07:21 <manek> jstolarek: seriously
16:07:53 <manek> jstolarek: use monadic exceptions, like from exceptions library
16:08:22 <manek> jstolarek: it will give you much more, custom error datatypes etc, not everything coded as string
16:08:23 <jstolarek> manek: I know
16:08:26 <ertes> jstolarek: there is no entirely safe way to catch 'error'
16:08:34 <jstolarek> in the long run this is what I'm going to do
16:08:44 <ertes> jstolarek: it might be lurking in any pure value
16:08:50 <jstolarek> but for now I will be perfectly happy with any hack that does what I want
16:09:10 <jstolarek> in other words: I want to hack this before tomorrow :-)
16:09:24 <jstolarek> and at some point in the future I will do a proper refactoring
16:09:26 <ertes> jstolarek: then switch to IO exceptions
16:09:40 <jstolarek> can I throw them from pure code?
16:09:43 <ertes> otherwise there is no upper bound on the amount of time you need to work around it
16:09:45 <Gurkenglas> *hands jstolarek a nuclear missile* https://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
16:10:05 <ertes> jstolarek: "throwing from pure code" is basically 'error' (or 'throw'), and that's exactly the problem
16:10:09 <ertes> don't throw from pure code
16:10:36 <MarcelineVQ> ertes: Do you have a good exception primer? I'm also about to have to delve into application IO exceptions and file-operation bracketing
16:11:10 <jstolarek> ertes: I know I know I know :-) It's just that I'm working with a piece of legacy code
16:11:35 <jstolarek> Priority no 1: add REPL; Long term goal: sanitize the code
16:11:48 <ertes> jstolarek: even in haskell that's a lie
16:12:07 <ertes> jstolarek: your best bet is to use 'evaluate' on every single pure value you get from the action
16:12:44 <ertes> but no guarantee that it won't blow up
16:13:53 <geekosaur> seriously, you may well be still fighting with the "quick simple" solution using "error". pure code *will* leak outside your catch, unless you take special care to force all evaluation inside it
16:14:11 <geekosaur> and you may not be able to do that if you don't have NFData instances for everything
16:15:31 <subttle> geekosaur: you gave me a suggestion the other day (I was the person who had the question on abstracting the sigma function over some language formalisms) and I just wanted to tell you I looked into the functional dependencies extension you recommended and it was exactly what I needed, so thank you!
16:20:43 <sboosali> jstolarek: spoon package can help, but I don't think it's a guarantee
16:20:53 <jstolarek> Gurkenglas: your mnuclear missle almost works
16:21:00 <jstolarek> sboosali: yes, just tested it
16:21:06 <jstolarek> like I just said, almost works
16:21:40 <jstolarek> there does not seem to be a way to recover the error message given to error
16:22:12 <Koterpillar> jstolarek: fork your process and see what happens to it
16:22:26 <jstolarek> why?
16:23:14 <Koterpillar> jstolarek: if the child encounters an error call, it will die
16:23:37 <Koterpillar> jstolarek: otherwise you can make it exit with a unique error code
16:23:49 <Koterpillar> jstolarek: so wait() on it and read its output
16:29:37 <jstolarek> Koterpillar: I think it will be eauser to rewrite it to use MonadError
16:29:52 <mjtmullen> Is there a better channel to talk about eta-lang than here?
16:34:10 <ertes> i think Koterpillar is just being sarcastic =)
16:34:22 <purelazy> kuribas: there?
16:35:06 <qmm> is there a better way of extracting out a number from a list of args?
16:35:10 <qmm> 0 + read (args !! 3)
16:35:35 <ertes> qmm: case args of …
16:35:52 <ertes> qmm: also import Text.Read and use readMaybe instead of 'read'
16:36:08 <qmm> ertes: a case expressions seems like overkill
16:36:13 <glguy> and you don't need to add 0 to it
16:36:28 <qmm> let foo = args !! 1; let bar = args !! 2
16:36:35 <qmm> ertes: maybe a case statement is safer though?
16:36:39 <mjtmullen> qmm: is this specifically for arguments from getArgs?
16:36:49 <qmm> mjtmullen: yes
16:36:57 <ertes> qmm: better scratch the word "overkill" from your vocabulary while learning haskell =)
16:37:00 <mjtmullen> @hackage optparse-generic
16:37:00 <lambdabot> http://hackage.haskell.org/package/optparse-generic
16:37:08 <mjtmullen> if you don't mind the dependency
16:37:10 <qmm> ertes: :)
16:37:38 <purelazy> what is args?
16:37:41 <Koterpillar> ertes: jstolarek: this kind of sarcastic got me to meet a deadline once
16:38:03 <EvanR> ertes: unless its about regex
16:38:09 <mjtmullen> purelazy: program arguments, like the `String[] args` in Java or `int argc, char** argv` in C
16:38:19 <purelazy> so [String]
16:38:27 <mjtmullen> right
16:39:13 <EvanR> s/what is args/what is args a/
16:39:19 <ertes> qmm: use pattern matching (i.e. 'case' or a function)
16:39:36 <qmm> ertes: is that recommendation mainly to handle failure?
16:39:40 <ertes> there are better ways to do it, but judging by your question it's probably too early for those
16:39:55 <ertes> qmm: no, also to split the arguments properly (and handle missing arguments)
16:40:20 <mjtmullen> right, my solution is if you want something robust and don't mind Generic stuff
16:40:22 <ertes> case args of arg1 : arg2 : arg3 : _ -> …; _ -> putStrLn "Not enough arguments"
16:40:25 <purelazy> :t 1
16:40:27 <lambdabot> Num t => t
16:40:35 <qmm> mjtmullen: that's neat, thanks for linking. i'm familiar with other libraries from other languages which autogenerate the cli help for you, and i was planning on looking for something like that that next
16:40:54 <ertes> qmm: alternatively define a function:  mainWith (arg1 : arg2 : arg3 : _) = …; mainWith _ = putStrLn "Not enough arguments"
16:40:57 <EvanR> qmm: optparse-applicative does this
16:41:04 <EvanR> its pure spif
16:41:07 <mjtmullen> @hackage optparse-applicative
16:41:08 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
16:41:18 <mjtmullen> it doesn't auto-generate from Generic instances, but it's also pretty good
16:41:22 <qmm> optparse-applicative and optparse-generic, hm
16:41:47 <purelazy> > 1
16:41:49 <lambdabot>  1
16:41:53 <qmm> also, glguy if writer isn't good for logging, what do you recommend?
16:42:10 <mjtmullen> optparse-generic auto-derives from a record, optparse-applicative is more flexible but requires more boilerplate
16:42:35 <ertes> qmm: for logging i generally just pass a logger function around:  mainWith args log = … log "blah" …
16:43:27 <ertes> qmm: you can then use 'mainWith' as part of 'main':  main = do args <- getArgs; mainWith args (hPutStrLn stderr)
16:43:33 <qmm> thanks for the help haskell folk!
16:44:14 <mjtmullen> cheers!
16:44:32 <ertes> there are also logging packages around, but they usually get logging wrong in my opinion =)
16:44:49 <sboosali> ertes: btw, you can use list syntax for patterns too, so: 
16:44:49 <sboosali> 	arguments"
16:44:59 <sboosali> case args of [arg1, arg2, arg3] -> …; _ -> putStrLn "Not enough
16:45:21 <mjtmullen> erter: thoughts on logging-effect?
16:45:29 <mjtmullen> I haven't had the chance to use it yet, but I liked what I saw
16:45:37 <ertes> sboosali: sure, but now you also need:  _ : _ : _ : _ : _ -> putStrLn "Too many arguments"
16:45:39 <ertes> =)
16:46:17 <ertes> mjtmullen: i see "MonadLog" and i'm immediately turned off
16:46:22 <mjtmullen> heh
16:46:37 <mjtmullen> fair enough :)
16:46:41 <ertes> there is already a class for loggers:  MonadIO =)
16:46:53 <EvanR> just do everything in IO
16:47:06 <pikajude> similarly, MonadState could just be IO
16:47:18 <pikajude> we have IORefs for a reason, guys
16:47:28 <mjtmullen> > @let type Id a = IO a
16:47:29 <ertes> but my point is not about the haskell abstractions, it's about the logging scheme itself
16:47:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
16:47:52 <EvanR> replacing FooT A . BarT B . BazT ..... IO a with IO a is one of those haskell-code-collapsing refactorings that feels so good ;)
16:48:07 <pikajude> yeah, but the logging libs i've seen have a logging action that pushes the messages into a queue that's being emptied in a separate thread
16:48:15 <pikajude> which i like not worrying about in my code
16:48:59 <sboosali> ertes: I use IO for logging a lot, but a smaller type can provide better features
16:49:07 <mjtmullen> I personally think there's enough subtlety to logging that I like having it its own thing
16:49:25 <ertes> sboosali: "smaller"?
16:49:35 <EvanR> agreed
16:49:36 <Gurkenglas> jstolarek: spoonWithHandles [Handler $ \(ErrorCall msg) -> (handle :: String -> IO (Maybe a)) msg, Handler $ \(x :: SomeException) -> throwIO x]
16:49:41 <ertes> mjtmullen: what subtlety do you expect from writing to stderr?
16:49:50 <mjtmullen> such as sys-logging vs application-logging and being able to log in terms of specific data types instead of raw strings
16:50:19 <mjtmullen> ertes: that :)
16:50:21 <ertes> yeah, that's what i mean:  i don't mind abstractions, i do mind the logging scheme…  proper unix logging = writing to stderr
16:50:25 <EvanR> if your handler is transactional, that doesnt cover logging, you want to log stuff even if the transaction fails or retries
16:50:28 <sboosali> ertes: I just mean a newtype over IO can hide a lot of function/instances. IO does a lot.
16:50:39 <glguy> You might want different logging levels and then be able to run with different levels enabled
16:50:53 <mjtmullen> glguy: yeah, also that
16:51:03 <ertes> no problem:  type Logger = Level -> String -> IO ()
16:51:25 <pikajude> all of a sudden, two threads. quick! what do you do
16:51:32 <ertes> still the same
16:51:35 <mjtmullen> for me, a big gain from logging-effect is the ability to define a data type that I need to construct to it, then it converts it to a String that gets logged
16:51:35 <sboosali> or mock out the logger, for integration testing
16:51:43 <mjtmullen> so that way, when Im writing my application, I can make sure that right info is always there
16:51:47 <pikajude> but i don't want my log messages to be mixed together
16:51:48 <sboosali> ertes: well, you might want to swap out the logging level at a later time. 
16:51:51 <EvanR> ... mock logger
16:52:05 <EvanR> do the simplest thing that could possibly work
16:52:06 <ertes> sboosali: then change the logger
16:53:12 <sboosali> then you're passing in a logging config, and you're in readert loggingconfig io
16:53:22 <ertes> no, Logger can also handle that
16:53:44 <ertes> you're desparately trying to come up with *the one* use case that validates the complexity
16:53:57 <EvanR> Logger above looks amazing
16:54:10 <EvanR> a function type is a great interface for many things
16:54:25 <sboosali> lol, I mean I don't use logging-effect, just brainstorming reasons
16:55:18 <ertes> well, perhaps there is that one huge application that really requires some complicated logging logic, at which point Logger becomes insufficient
16:55:31 <ertes> but i'm pretty sure 99.9% of applications aren't like that
16:55:44 <EvanR> i dont even see a huge application *needing* more than that
16:56:25 <nshepperd1> Where does Logger = Level -> String -> IO () get the current log level from?
16:56:42 <EvanR> its a literal you put in the site of logging
16:56:47 <ertes> nshepperd1: log Debug "My debug message"
16:57:14 <glguy> nshepperd1: When you created the logger function you could have:   makeLogger DebugLevel :: Logger
16:58:14 <EvanR> the deal is, where does the logger come from, its passed in or its in a Reader
16:58:24 <nshepperd1> glguy: right, then you're paying it down in reader
16:58:29 <nshepperd1> Passing
16:58:44 <EvanR> and since you already have a reader full of junk...
16:58:58 <glguy> It's probably just a field in a function argument that I was already passing
16:59:04 <ertes> EvanR: initially from 'main', but potentially also overridden elsewhere
16:59:09 <glguy> No need to involve Reader type
16:59:20 <EvanR> reader / argument full of junk
16:59:57 <EvanR> log "foo" would be nice (uses reader), but we already can be arsed to do console.log( everywhere
17:00:17 <EvanR> log junk "foo"
17:00:23 <ertes> log cfg Debug "blah"  -- not too terrible
17:00:40 <EvanR> for debugging that will get old
17:00:48 <EvanR> for permanent logging commands yes
17:00:53 <ertes> in fact i've never needed more than two levels, so usually i just pass two functions around
17:01:01 <ertes> e.g. 'log' and 'debug'
17:01:36 <sboosali> ertes: then you can break the type of your actions
17:01:48 <EvanR> with enough editor support, debug passed everywhere wouldnt be too terrible!
17:01:58 <sboosali> whereas if you program against an interface like MonadLogger, it's just another constraint, which might be resolved painlessly.
17:02:14 <ertes> EvanR: just make it part of that configuration argument you use everywhere anyway =)
17:02:16 <EvanR> enough constraints is just as bad as arguments
17:02:19 <sboosali> i dont want to have to deal with type errors and threading state while debugging stuff
17:02:34 <sboosali> i just want the "logging effect"
17:02:36 <Axman6> and can be trivially met by using a NoLogging monad transformer for testing
17:02:45 <ertes> sboosali: you mean i might accidentally type "debug" instead of "log"? =)
17:03:19 <EvanR> we already have debug.trace
17:03:37 <EvanR> one like it can be modified to do logging or stderr
17:03:43 <EvanR> specifically for debugging
17:03:46 <EvanR> not permanent logs
17:03:50 <EvanR> which *should* be in the ypes
17:03:50 <nshepperd1> You might, if your function calls are all like "foo debug log" in hundreds of places..
17:04:05 <nshepperd1> Or was it "foo log debug"
17:04:14 <ertes> nshepperd1: it's more likely "foo cfg"
17:04:29 <EvanR> i already have a "pure" debug in most cases which is based on trace
17:04:47 <EvanR> not for production logs
17:07:15 <Gurkenglas> Are constraints that bad, when you can use PartialTypeSignatures to replace the boilerplaty ones with _?
17:08:05 <sboosali> EvanR: i'd rather just log it, then use debug.trace
17:08:14 <EvanR> than?
17:08:19 <nshepperd1> You can do that? Write foo :: _ => m ()?
17:08:39 <sboosali> yeah
17:08:59 <EvanR> a pure thing that does the same thing as logging would assuage your issue with type signatures
17:09:14 <sboosali> you mean like an online WriterT?
17:09:18 <EvanR> specifically for debugging
17:09:35 <sboosali> Oh, you just mean debug.trace?
17:09:44 <EvanR> something like that which can be placed anywhere
17:10:12 <EvanR> trace itself is kind of klunky
17:10:39 <sboosali> Well, I tend not to trace pure code anyway, I'll just split up the functions and tested in a reptile, when I can afford to.
17:10:47 <sboosali> So I'm going to be in I/O anyway
17:11:05 <sboosali> *test in a repl
17:11:16 <mjtmullen> I've used trace in a pure interpreter, found it useful
17:11:19 <nshepperd1> Certainly, you could always unsafePerformIO your logging
17:11:41 <Gurkenglas> nshepperd1: https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/partial-type-signatures.html#extra-constraints-wildcard
17:11:41 <nshepperd1> Store the log level in a ioref somewhere...
17:11:44 <EvanR> sboosali: its not pure code, that im talking about
17:12:19 <sboosali> I don't follow, can you give an example?
17:12:20 <EvanR> which makes it much easier to predict when the debug message should show up
17:12:34 <EvanR> x <- coolAction
17:12:53 <sboosali> ...
17:13:01 <EvanR> let !y = debug whatever
17:13:07 <EvanR> z <- letsContinue
17:13:39 <EvanR> make a Monad m => m () version of that
17:13:42 <nshepperd1> Please, debugM whatever :: Monad m => m ()
17:13:55 <mjtmullen> Wait, strict let bindings work like that in do notation?
17:14:12 <sboosali> no
17:14:15 <sboosali> you need evaluate
17:14:18 <sboosali> and even then
17:14:18 <EvanR> they do
17:14:29 <Gurkenglas> I wonder whether there's a library that provides a global vault that you can unsafely use to unwrap RWST
17:14:47 <sboosali> You still might not even be able to get trace to run without doing what I said.
17:14:53 <mjtmullen> > do { let !x = fail ""; pure () }
17:14:55 <lambdabot>  <hint>:1:32: error: parse error on input ‘}’
17:15:02 <EvanR> the way it desugars, you cant evaluate the rest without evaluating the body of the let
17:15:08 <sboosali> really?
17:15:23 <EvanR> but nshepperd1 is right, it should be wrapped
17:15:36 <EvanR> debugM
17:16:07 <nshepperd1> sboosali: It's secretly let !y = debug "string" in letsContinue
17:16:20 <sboosali> right but is that a case?
17:16:23 <nshepperd1> Which is secretly having a seq in it
17:16:26 <nshepperd1> Etc
17:16:33 <Gurkenglas> Can you access an IORef in an unsafePerformIO that the main defined and kept to itself?
17:16:54 <EvanR> yes
17:17:19 <EvanR> s/kept to itself/only exposed it to the unsafePerformedIO actions closure/
17:17:22 <fu_barr> hey all. odd question perhaps... what are the dependencies of building a/the haskell compiler? I'd like to try it on IRIX, the venerable OS of old school Silicon Graphics workstations.
17:17:25 <nshepperd1> sboosali: yes, it turns into a case in core, iirc
17:17:42 <nshepperd1> Because of the !
17:18:46 <EvanR> all the best ways out of haskell purity
17:18:46 <Gurkenglas> EvanR, so instead of passing around a log state, I need to pass around a log IORef? :S
17:18:58 <EvanR> Gurkenglas: no
17:20:19 <EvanR> but you will have to pass around the constructed logging action
17:20:26 <EvanR> like ertes was saying
17:20:33 <EvanR> since it is closing over something
17:20:39 <EvanR> you could also use a global variable
17:21:55 <Gurkenglas> I don't follow. "foo = ...; main = do x <- newIORef 1; foo; readIORef x >>= print" What should ... be so that print prints 2?
17:22:45 <EvanR> youre mixing two different ideas
17:23:10 <EvanR> with global variables the global IORef is created through black magic at the top level, not initialized in main
17:23:29 <EvanR> with no global variables, you wouldnt use top level, youd use a closure and pass it around
17:23:44 <EvanR> it would be constructed in main
17:23:48 <fu_barr> okay - ignore me - found the information i need - thanks :)
17:24:20 <Gurkenglas> Ah, "x = unsafePerformIO $ newIORef 2; foo = writeIORef x 2; main = do foo; readIORef x >>= print"
17:24:21 <mjtmullen> I typically just do mainWith or something and pass the ioRef as an arg
17:24:32 <purelazy> logging shouldn't be this hard :) - oh Haskell, where did you go wrong
17:25:19 <EvanR> Gurkenglas: is all this just to save a "current logging level" lol
17:25:30 <EvanR> i figured you wanted to have the logging context, like a file descriptor
17:25:34 <EvanR> socket
17:26:14 <mjtmullen> Logging isn't that hard, there's just a lot of ways to do it :)
17:26:19 <EvanR> purelazy: for permanent system logging... i would go all the way back to the beginning of the discussion and pass the logger around
17:26:31 <ertes> i'd first check whether overriding is enough
17:26:35 <Philippa> purelazy: one of the awkward rules of haskell is that if you want to instrument stuff and have an engineering approach to it, you're going to need something in the Applicative family on up with monads being a common choice because they permit all control flow
17:26:53 <ertes> you can always *add* new constraints by overriding…  only when you need to remove constraints you need state
17:27:13 <purelazy> all I'm saying is it shouldn't be hard
17:27:14 <Gurkenglas> Nah, to implement "String -> StateT s a -> a" for a library. Hmm. Maybe the "String -> IORef s" and "IORef s -> StateT s a -> a" should be two different libraries.
17:27:15 <ertes> however, you don't need mutability…  this state can be just another piece of information you pass around
17:27:16 <EvanR> typeclasses for flow control ;_;
17:27:31 <EvanR> purelazy: the debugM thing isnt hard
17:27:50 <EvanR> as for robust system logs, every system has insane methodologies for that
17:28:12 <EvanR> youd think rails monkey patching everything with logging would make it "easy" ... wrong
17:28:12 <sboosali> purelazy: The easy stuff is still easy
17:28:18 <ertes> let me put it differently:  if you're trying to come up with an abstraction for logging and you're thinking of IORef, unsafePerformIO or an effect class, you're already falling into a trap OO engineers have been falling into for ages…  you might be the one to introduce factories and facades to haskell =)
17:29:07 <mjtmullen> Sorry, can't hear you over the sound of my Abstract Monad Factory Factory
17:29:43 <EvanR> abstract factory is quite plausibly the same thing as a smart constructor
17:29:55 <EvanR> jokes on us
17:29:57 <mjtmullen> As one of the people who uses an Effect for logging, I really don't feel any need to introduce facades :P
17:30:11 <sboosali> no, "abstract factories" can be very impure
17:30:22 <mjtmullen> EvanR yeah, they're basically functions at their core
17:30:43 <Gurkenglas> Factories like "i <- index <<+= 1"?
17:31:00 <sboosali> at least a constructor isn't gonna cache stuff or register itself or anything
17:31:12 <sboosali> *smart constructor
17:31:14 <EvanR> abstract factories, they create instances of an abstract type
17:31:37 <EvanR> or fail trying
17:32:05 <mjtmullen> I mean, any code in most languages can throw anywhere, so it's not the abstract factory's fault
17:32:07 <EvanR> sboosali: ... unless its a memocombinator!
17:32:11 <sboosali> oh, i forget, it's been a while since i did java
17:33:12 <sboosali> mjtmullen: my point was that in haskell Smart constructors like `int -> maybe natural` aren't going to do that much, no global effects. 
17:33:22 <EvanR> neither do most factories
17:33:38 <EvanR> they just take up a lot of source code space
17:34:15 <mjtmullen> \_ -> throw $ IOException "oops"
17:34:19 <mjtmullen> :P
17:34:40 <sboosali> mjtmullen: Lol, yeah don't do that
17:34:44 <mjtmullen> Just because they can throw, doesn't mean they do
17:34:57 <EvanR> its funny when complaints about haskell involve "lets you do too much, is too flexible" :)
17:35:24 <mjtmullen> :)
17:36:05 <EvanR> dont let inexperienced people use haskell, they might use crazy features. give them PHP which protects them from themselves
17:36:44 <sboosali> mjtmullen: not Exceptions, I was talking about intentionally global effects like caching/registering stuff, but I don't remember what an abstract factory is, I think I just confused it with some pattern of indirection from my workplace.
17:37:01 <mjtmullen> We use TypeScript at work.  The sheer amount of magic they do at the type level is absurd
17:37:23 <mjtmullen> Fair enough!
17:37:36 <sboosali> mjtmullen: Like what? I've never written Typescript, but it looks interesting
17:38:02 <mjtmullen> The Typescript folks had to reimplement a bunch of dependent type stuff to type the insane stuff in node land
17:38:28 <sboosali> Beyond type level set operations? 
17:39:08 <mjtmullen> https://blog.mariusschulz.com/2017/01/06/typescript-2-1-keyof-and-lookup-types
17:39:13 <sboosali> Like inferring from string keys or dynamically constructed objects? I assume that you manually annotated the boundaries like a foreign import in haskell.
17:39:22 <sboosali> Okay I'll take a look
17:39:52 <mjtmullen> Things like "take an object, map all the types of all keys to nullable" and stuff like that
17:40:05 <sboosali> cool
17:40:11 <mjtmullen> No, you just call stuff
17:40:16 <mjtmullen> Similarly to scala
17:40:30 <mjtmullen> Turns out most people want a porous ffi border
17:41:55 <mjtmullen> Anyways, the TS team made a really ugly syntax for that stuff :P
18:00:28 <qmm> mjtmullen: thanks for linking to https://github.com/Gabriel439/Haskell-Optparse-Generic-Library
18:01:06 <qmm> it's actually much easier for me to understand than optparse-applicative
18:01:26 <qmm> thanks for mentioning it. i can't recall if you linked
18:02:05 <qmm> i kind of want to read more about https://github.com/pcapriotti/optparse-applicative though to understand what is confusing about it :)
18:14:43 <babygau> : let x  = x in x
18:14:50 <babygau> > let x = x in x
18:14:56 <lambdabot>  mueval-core: Time limit exceeded
19:10:41 <trm> n
19:17:10 <Myrl-saki> Has anyone made a Parsec for parsing Haskell?
19:18:11 <MarcelineVQ> parsing it into what?
19:20:12 <Myrl-saki> MarcelineVQ: Whichever is best for syntax highlighting.
19:23:32 <glguy> Often for syntax highlighting people will just use a lexer
19:24:18 <pikajude> hey all, with a simple gloss program on macos I get a window that looks like this https://i.imgur.com/oEebiqE.png
19:24:31 <pikajude> except every other flame it's black, so it's flashing annoyingly
19:24:34 <pikajude> any idea what's going on
19:24:43 <glguy> That's not the normal behavior
19:25:06 <pikajude> no, i definitely agree
19:25:50 <abff> that's how all my windows look, you're crazy
19:25:58 <pikajude> but i'm not on windows ):
19:29:02 <Myrl-saki> glguy: That's what I was thinking too.
19:29:30 <Myrl-saki> abff: #justlinuxthings?
19:30:55 <glguy> pikajude: I just installed gloss on an up-to-date macOS and things seem to work
19:31:17 <glguy> so as a data point we should expect to be able to get things running with gloss on macOS
19:32:11 <pikajude> we should
19:32:24 <pikajude> hang on a second
19:34:52 <pikajude> maybe I shouldn't use the nixos version
19:35:44 <pikajude> we're about to find out
19:40:55 <Myrl-saki> Errr...
19:44:01 <pikajude> ah! beautiful
19:44:11 <pikajude> it works when I install a "regular" package set, just not with nix
20:00:12 <pikajude> anyone know how to combine a font file with gloss?
20:08:48 <Axman6> "combine"?
20:12:26 <Guest67669> Can someone help me understand why the types of `fmap (+) Just 3` and `fmap (+) (Just 3)` are different?
20:12:57 <Axman6> the former is ((fmap (+)) Just) 3
20:13:14 <Axman6> the latter is (fmap (+) (Just 3))
20:13:36 <Guest67669> Ohh, thanks Axman6
20:14:05 <Myrl-saki> OH RIGHHT
20:14:14 <Myrl-saki> I can just GHC as a library, can I?
20:14:19 <Myrl-saki> can't I*
20:14:45 <Axman6> yes, see also ghc-src-exts
20:15:01 <Axman6> uh, haskell-src-exts
20:15:25 <Myrl-saki> I'm only interested in the lexing.
20:15:36 <Myrl-saki> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.0.1/Lexer.html ?
20:15:46 <Axman6> https://hackage.haskell.org/package/haskell-src-exts-1.19.0/docs/Language-Haskell-Exts-Lexer.html =)
20:16:00 <glguy> I like this one http://hackage.haskell.org/package/haskell-lexer
20:16:15 <Myrl-saki> glguy: I actually had that under consideration too.
20:16:26 <Myrl-saki> glguy: Will that work with GHC extensions?
20:18:23 <glguy> I think that it might not know about all of the tokens added by extensions
20:19:11 <Myrl-saki> glguy: I guess I'll just give it a try, huh?
21:13:28 <mikeplus32> huh, HashMap is seemingly faster than IntMap -- for lookups, anyway
21:14:48 <monochrom> HashMap was newer and enjoyed a more recent, modern effort on efficiency.
21:17:30 <mikeplus32> yeah. IntMap is actually 'just' a balanced binary tree and not quite as fancy ... but it's still pretty close in terms of speed. I wonder how a specialized HashMap for Ints would go
21:18:06 <monochrom> No, I recall that IntMap is more than that.
21:18:11 <kadoban> I thought IntMap is something like a bit trie
21:18:17 <Kaidelong> yep
21:18:22 <mikeplus32> oh, ok
21:18:24 <monochrom> But still, used an older approach than HashMap
21:18:26 <mjtmullen> I haven't found a great spot where I'd rather have IntMap than Vector
21:18:43 <kadoban> mjtmullen: Mostly when it needs to be sparse probably
21:18:43 <mjtmullen> probably when I'd want a spare array or something?
21:18:47 <mjtmullen> heh
21:18:49 <kadoban> heh, ya
21:18:52 <mjtmullen> *sparse
21:18:52 <Kaidelong> in theory very large vectors will be slow
21:19:02 <Kaidelong> in practice the vector library seems to handle this fine
21:19:06 <Kaidelong> never had a problem with it
21:19:21 <kadoban> Well, just the alloc can take forever if it's huge but you're not using much of it, no?
21:19:25 <mjtmullen> I just haven't done much where I've wanted a (1.) sparse map indexed by (2.) ints
21:19:49 <Kaidelong> well you'll also force a lot of page faults if you actually try to allocate something that big continuously
21:20:10 <monochrom> the cross-over point is a moving target because ALU speed, cache speed, memory speed, and the speed of them talking to each other change every day.
21:21:04 <mjtmullen> does hackage have a decent b+ tree?
21:21:20 <Kaidelong> contiguously*
21:22:29 <mjtmullen> does an immutable B+ tree make much sense?
21:23:25 <monochrom> You seldom use sparse nat-indexed arrays because you seldom use nat-indexing to begin with. People think that everything is a string, unlike Gödel who thought everything was a nat.
21:23:33 <Kaidelong> better locality, potentially worse sharing. I'd imagine you'd use a freeze/thaw metaphor in practice, like vector does
21:23:48 <mjtmullen> that makes sense
21:23:51 <kadoban> B+-tree is usually only used as kind of like a storage-backed thing, right? I'm not sure if it'd make sense in a pure setting.
21:24:44 <mjtmullen> umm, it's often used as a storage thing, but having a mutable (or ST) array stored in page-sized chunks can be useful for (say) analyzing a large chunk of data
21:24:50 <mjtmullen> DNA maybe?
21:24:55 <monochrom> If you have a dictionary of 10 string keys, the longest string being 30 letters long, that's easily a sparse nat-indexed array of 36^30 size.
21:25:44 <kadoban> mjtmullen: Ya, in ST or IO it seems like it'd make sense to me. But I'm really just guessing.
21:26:12 <mjtmullen> might be easier and more performant if the mutable data structures proposal gets through
21:26:18 <kadoban> I don't think I've ever directly used a b+-tree. I understand they're ... related to whatever backends a few databases, but that's about as close as I've gotten.
21:26:31 <mjtmullen> Databases and File Systems use them
21:26:41 <mjtmullen> places where cache misses are extra costly
21:26:48 <mikeplus32> i'm also a bit surprised there isn't a very popular buffer/ArrayList/mutable list-backed vector type... lists are too easy :-)
21:27:17 <mjtmullen> I think the only time I did anything with a B+ tree was in school
21:27:46 <kadoban> mikeplus32: You mean a dynamic array?
21:27:53 <mikeplus32> yeah
21:28:42 <mjtmullen> I should look into using LiquidHaskell when I use Indexed structures like Vector
21:29:00 <monochrom> a dynamic array that lacks mutation operations becomes a static array.
21:31:24 <mjtmullen> Doesn't clojure use something called Transducers instead of freeze/thaw?
21:32:17 <mikeplus32> hmmm, very tangentially, has anyone benchmarked Data.Vector.Storable.[M]Vector (StablePtr a) against Data.Vector.[M]Vector a?
21:34:53 <mikeplus32> mjtmullen: dunno. attoparsec has a very cool immutable but internally mutable Buffer type (for Text and ByteString) though (https://www.stackage.org/haddock/lts-7.14/attoparsec-0.13.1.0/src/Data.Attoparsec.ByteString.Buffer.html)
21:40:08 <mikeplus32> mjtmullen: transducers seem more the clojure equivalent to fusion or maybe more accurately pipes/conduit/...
21:40:33 <mjtmullen> yeah, I took a closer look, and that seems to be the case
21:44:50 <mikeplus32> lol, attoparsec has an internal module Data.Attoparsec.Internal.Fhthagn
21:45:18 <mjtmullen> lol
21:45:26 <mjtmullen> Does it do unspeakable things? :P
21:45:32 <mikeplus32> it has inlinePerformIO
21:45:37 <mjtmullen> the dreaded `unsafePerformIO`?
21:45:39 <mjtmullen> oh, even worse
21:45:41 <mjtmullen> heh
21:55:12 <zipper> Hello
21:55:39 <lambdabot> Hello.
21:56:27 <zipper> I'm having issues seeing fmap (a -> a) (a -> a) as fmap (b -> c) (a -> b) and therefore as composition
21:56:52 <zipper> See if I have fmap (*2) (+3)
21:57:21 <zipper> I have fmap (*2)  ((->a) b)
21:57:38 <zipper> So the b according to fmap should first be applied to the *2
21:57:46 <zipper> then to the (-> a)
21:58:15 <zipper> So it should give me 11 but it gives me 14
21:58:29 <zipper> > fmap (*2) (+3) 4
21:58:31 <lambdabot>  14
21:59:02 <zipper> Hello
21:59:08 <zipper> Is anyone here?
21:59:12 <qmm> primes = filterPrime [2..] where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0] -- i'm not following. i think the first predicate is evaluating 3 `mod` 2 /= 0
21:59:27 <geekosaur> yes, I'm trying to figure out how to show it
22:00:06 <geekosaur> @unpl fmap (*2) (+3)
22:00:06 <lambdabot> fmap (\ a0 -> a0 * 2) (\ a0 -> a0 + 3)
22:00:36 <geekosaur> mm, no, that doesn't d what I want
22:01:00 <glguy> :t fmap
22:01:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:01:04 <qmm> the second time the predicate function is used, i think it is evaluating 4 `mod` 3 /= 0
22:01:14 <glguy> If we pick f to be   (->) e, we'd get:
22:01:21 <qmm> is there a way to log the steps
22:01:26 <glguy> fmap :: (a -> b) -> (e -> a) -> (e -> b)
22:01:37 <qmm> pretty sure i read about something like this before
22:01:41 <zipper> glguy: Chill
22:01:42 <geekosaur> qmm, [traceShowId x | ... ]
22:01:56 <geekosaur> zipper, ???
22:02:19 <zipper> glguy: Exactly if we pick the f to be (->) e it has to be applied last because f is in the return value of fmap
22:02:35 <glguy> so we know that the second argument has to be applied first
22:02:53 <glguy> because its type is the only one that fits
22:03:06 <zipper> glguy: Ok let's eval what you just said
22:03:10 <zipper> One sec
22:03:12 <geekosaur> qmm, or some other variant of Debug.Trace.trace that would show more information (like what p is for each one)
22:04:33 <glguy> (*2) will be in the position with type (a -> b);  (+3) will be....type (e -> a); and   4 will...type e
22:04:46 <zipper> Let's think about is as (a -> b) ((-> e) a) ((-> e) b)
22:04:56 <glguy> No, that's not the right type
22:05:01 <glguy> you're dropped some arrows
22:05:04 <zipper> So we take the a and apply it to the first arg to fmap
22:05:12 <glguy> we don't have an a
22:05:23 <zipper> (a -> b) -> ((-> e) a) -> ((-> e) b)
22:05:41 <glguy> OK, so you have two functions: (a-b) and (e->a)
22:05:45 <glguy> and one other value, e
22:05:56 <glguy> (a->b)*
22:06:05 <zipper> Yes
22:06:15 <glguy> so you have to use the second function first
22:06:20 <glguy> it's type is (e -> a)
22:06:26 <glguy> and you have an e
22:07:05 <zipper> wait according to fmap you should ((->e) a)
22:07:17 <glguy> Yes, that's the type of the second function
22:07:20 <zipper> you should pass the a to the first val of fmap
22:07:25 <zipper> OMG I think I see it
22:07:26 <glguy> No, you don't have an 'a'
22:07:35 <zipper> a that we pass to fmap is already a val
22:07:52 <glguy> Also, it's not (-> e) a
22:07:55 <zipper> the result of applying e to ((->e) a)
22:07:59 <glguy> It would be:  (e ->) a
22:08:02 <zipper> It is :P
22:08:07 <glguy> which is invalid syntax
22:08:13 <glguy> so we have to write (->) e a
22:08:20 <glguy> but (-> e) a would mean something else
22:08:24 <glguy> it would mean:   a -> e
22:08:36 <zipper> What about ((-> e) a) ?
22:08:48 <zipper> glguy: Let me work it out on paper one bit
22:08:57 <glguy> No, you can't do ((-> e) a)
22:09:04 <glguy> you can't write a function instance for: (-> e)
22:09:07 <glguy> functor*
22:09:10 <geekosaur> zipper, note that (-> e) is a right section on (->)
22:09:31 <glguy> two problems, you can't construct that type, and it wouldn't be a functor if you could, it would be a "contravariant" functor
22:09:32 <zipper> jmmmmm
22:09:48 <geekosaur> ((->) e) is left application, (-> e) is right application
22:10:11 <zipper> geekosaur: I see :)
22:10:25 <zipper> because -> is infix
22:10:29 <geekosaur> yes
22:11:53 <zipper> hmmm since I think I get that let me figure out `fmap (*) (+2)` which should give me a partially applied func
22:16:47 <lpaste> qmm pasted “No title” at http://lpaste.net/7216539617086930944
22:18:00 <qmm> is there a way to make this print to the screen the x's
22:18:29 <qmm> print $ primes seems to print the primes and not necessarily the values being evaluated by the predicate function
22:19:54 <glguy> qmm, if you want to trace the predicate, you need to put the trace on the predicate
22:20:30 <glguy> Perhaps:          p : filterPrime [x | x <- xs, traceShow (x,p) (x `mod` p /= 0)]
22:20:52 <mikeplus32> qmm: 'main = return primes' won't actually evaluate 'primes' though. you need to force its evaluation with e.g. print or length
22:21:28 <mikeplus32> like, main = length primes `seq` return ()
22:24:05 <qmm> thanks
22:24:12 <qmm> mikeplus32: why not print $ length primes
22:24:30 <zipper> I believe I got it :)
22:24:34 <zipper> thankee dudes
22:25:15 <mikeplus32> qmm: sure, why not
22:26:21 <qmm> mikeplus32: i only ask because it's something i feel that i understand
22:26:59 <qmm> i suppose `seq` return () means evaluate and throw it in an IO ()
22:27:17 <mikeplus32> qmm: yeah
22:27:35 <qmm> to be clear, i feel i understand print $ length primes, `seq` return () causes me to pause 
22:27:58 <qmm> i really am a beginner :)
22:28:19 <mikeplus32> fair enough
22:29:12 <qmm> i wonder if it's possible to be a day to day haskell developer and only to get by with beginner knowledge :)
22:30:23 <qmm> ..and for how long this could last
22:31:54 <kadoban> Depends what you mean by beginner knowledge I guess. I know from personal experience that there's a *lot* you don't necessarily need to know to write a lot of useful, working haskell code.
22:33:10 <chocopuff> dumb question, beginner. The difference between fn :: (Integral a) => a -> String and inc :: Num a => a -> a? 
22:33:23 <chocopuff> I can't seem to understand why there is parentheses and a "=>" type? 
22:34:01 <kadoban> chocopuff: When there's only one, it doesn't matter. It's not a meaning difference.
22:34:32 <kadoban> You need the parens when you have multiple  like    f :: (Num a, Eq b) => a -> b    without the parens that won't compile
22:34:59 <mikeplus32> qmm: i think so, i think the documentation available is pretty good these days. if there's an experienced person to help with unintuitive/obvious things they'd have a very good chance
22:35:42 <chocopuff> kadoban: oh so it's just difference in syntax? And that always refers to function type right?
22:36:53 <kadoban> Well, you can have them on values too if you want, like     v :: Num a => a    <newline> v = 5   is a possible thing
22:37:00 <kadoban> That one isn't particularly useful usually, but ... you can do it.
22:37:28 <kadoban> Anywhere you can have a type annotation you should be able to do typeclass constraints, AFAIK.
22:37:46 <chocopuff> kadoban: Thanks!
22:38:51 <chocopuff> wait ane last question, sorry. what is the "=>", "->" and "<-" called?
22:39:56 <GLaDER> Good morning!
22:40:07 <kadoban> Oh god, I have no idea what they're called actually, heh. There might be a name for them in the haskell report
22:41:03 <chocopuff> they're not named in the textbook either heh
22:41:17 <yushyin> https://wiki.haskell.org/Keywords
22:41:22 <mikeplus32> chocopuff: <- at least has a name, "bind"
22:42:39 <Hafydd> They are called "=>", "->" and "<-", respectively.
22:43:15 <mikeplus32> Hafydd: what about in spanish
22:43:51 <chocopuff> mikeplus32: I guess they're called "=>", "->", and "<-" respectively in Spanish
22:45:15 <Hafydd> Yes. I'm not sure it makes much sense to name lexical tokens. You might name the syntactic structures they correspond to in a particular context, though.
22:45:17 <mikeplus32> so what you're saying is that haskell operators are multilingual
22:45:25 <Hafydd> (They are not operators.)
22:45:42 <Hafydd> (Except when -> is a type operator.)
22:45:49 <chocopuff> i have much to learn
22:45:50 <mikeplus32> :kind (=>)
22:45:58 <mikeplus32> > :kind (=>)
22:46:00 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
22:46:23 <chocopuff> it's more of to ease my searching for help online
22:46:57 <nshepperd> if I was googling for these things I would probably say "right arrow", "left arrow" etc
22:46:58 <mikeplus32> i could have sworn ghci reported => as (=>) :: Constraint -> a -> a ...
22:48:39 <Hafydd> => is used to introduce a context, so I suppose you might call it a "context arrow"; -> is used to construct function types, and in view patterns, and probably in several other places - you might call it a "function arrow"; and "<-" is used in list comprehensions and in do notation to bind (as previously mentioned) a pattern to a value ("bind arrow"?).
22:49:08 <Hafydd> But you'll probably have better luck searching for the literal characters in the Haskell Report to the GHC documentation.
22:49:12 <Hafydd> *or
22:52:23 <shayan_> Are Mac users here using Xcode as their environment to code? O___O
22:53:01 <Axman6> I would be surprised if any were
22:53:27 <ReinH> Haskell? I doubt it.
22:54:06 <chocopuff> shayan_: mac user here, though i'm on arch linux
22:54:58 <ReinH> Unless you're using the FFI from ObjC or something
22:54:58 <shayan_> chocopuff: are you using the GHC compiler as well?
22:55:17 <ReinH> Everyone uses GHC
22:55:25 <chocopuff> shayan_ yes?
22:55:26 <shayan_> xD
22:55:33 <shayan_> sorry newbie here
22:55:39 <shayan_> trying to get it up and running
22:55:39 <chocopuff> no so am i lol
22:55:44 <ReinH> Well, Standard Chartered has their own in house compiler
22:56:49 <chocopuff> ReinH: wow that's interesting
22:57:52 <shayan_> So do I not need Xcode to run GHC?
22:58:01 <shayan_> On haskell.org it says: This is a distribution for Mac OS X, 10.7 or later. The package requires the command line tools package of Xcode 4 or XCode 5 to be installed. You can find Xcode at http://developer.apple.com/.
22:58:12 <chocopuff> shayan_ all you need is a text editor and a compiler
22:58:14 <fragamus> im so so rusty I'm trying to read a file and split into lines and im getting hung up on IO wrapper
22:58:47 <pie_> so people say c is close to hardware, but that isnt true because of compilers, but what if someone does want something close to hardware but not write it in assembly?
22:58:57 <fragamus> let fileContents = readFile "flooble"
22:59:09 <shayan_> chocopuff: thanks mate
22:59:19 <pie_> (awesome if someone has a satisfactory answer involving nicer languages than c :P)
22:59:35 <fragamus> import Data.List.Split
23:00:14 <kadoban> pie_: Not really clear what you're asking. If you're considering anything with a compiler "not close to hardware", you're pretty much limited to assembly or machine language.
23:00:35 <fragamus> let lines = ....whatever....
23:00:48 <fragamus> I forgot
23:00:51 <monochrom> Philosophy question: Is an assembler a compiler? :)
23:00:53 <pie_> kadoban, more like thats why i figured c isnt really actually close, but "close to hardware" isnt really a clear thing anyway
23:01:23 <pie_> i guess im looking for a counterpoint to "c is important because its close to hardware" other than "its not close to hardware"
23:01:50 <monochrom> But I think you should consider Rust.
23:02:04 <pie_> though i guess someone elaborating on "not close to hardware" would be nice because i dont have many ideas aout that either :P
23:02:23 <ReinH> shayan_: you need xcode command line tools for some tools GHC requires
23:02:32 <fragamus> let contentsToLines = (splitOn "\n")
23:02:47 <ReinH> You don't need xcode itself, and you certainly don't need to use its editor.
23:02:48 <pie_> monochrom, i guess
23:03:00 <pie_> i mean im totally pro rust even though i never used it or looked at it much
23:04:13 <fragamus> so I have an IO String and I want to apply  (String->[String]) and get IO [String]
23:04:15 <monochrom> In the cases of most people, I think "close to hardware" is an XY problem. Why do you want to be close to hardware? Different people have different and incompatible reasons.
23:05:07 <ReinH> fragamus: why are you writing your own 'lines'?
23:05:20 <monochrom> Some people want efficient generated code. In which case the ATS compiler is probably even better than most C compilers, most Rust compilers, and GHC. Yet ATS is not close to hardware. Far from it.
23:06:10 <pie_> woops
23:06:14 <pie_> dunno what i did there
23:06:28 <monochrom> Some people want hard real-time embedded systems. In which case you are looking at assembly or a dedicated compiler. You can no longer call it "C" because it is going to subtract from C and add something else.
23:06:36 <pie_> last i got was the mention of ATS
23:06:36 <fragamus> ReinH ok I'll use lines in prelude
23:06:41 <ReinH> :t fmap lines (readFile undefined) -- fragamus
23:06:42 <lambdabot> IO [String]
23:06:43 <roboguy`> monochrom: on a side note, does ATS have good documentation these days? I feel like last time I looked at it, it was pretty hard to figure out and I've been wanting to give it a shot...
23:07:05 <pie_> could you guys link ATS, ive never heard of it
23:07:26 <roboguy`> pie_: https://en.wikipedia.org/wiki/ATS_(programming_language)
23:07:40 <fragamus> thanks
23:07:50 <shayan_> how can i clear the terminal? “<interactive>:14:1: error: Variable not in scope: clear"
23:07:52 <fragamus> my brain is coming back to haskell...
23:08:08 <shayan_> fragamus: yaya!
23:08:14 <liste> http://www.ats-lang.org/Documents.html#INT2PROGINATS this documentation is pretty clear at least to me
23:08:21 <roboguy`> shayan_: inside of GHCi?
23:08:33 <shayan_> roboguy`:  yes
23:08:44 <pie_> roboguy`, oh its a language, thanks
23:08:58 <roboguy`> liste: ahh, wow. I might be misremembering but that looks a lot better than I recall
23:09:31 <roboguy`> I've also learned a decent amount about Coq since I last looked at ATS, so hopefully that will help me out a bit too...
23:09:37 <monochrom> Some people want fine-grained control on x86 floating point. (Because "tmp := x + y; answer := tmp + z" is not going to be the same as "answer := (x + y) + z".) In which case you could be screwed over by most compilers who are too clever.
23:09:46 <liste> roboguy`: it's been pretty actively updated last year
23:10:01 <monochrom> roboguy`: I haven't followed ATS since its inception.
23:10:06 <roboguy`> liste: that's cool. Yeah, it was definitely more than a year ago when I looked at it last
23:10:10 <pie_> monochrom, oh gods...ive heard things about floating point
23:10:34 <monochrom> But it is designed to be difficult because it is the logical conclusion of the curry-howard isomorphism. :)
23:11:16 <TacosNachos> l
23:11:52 <pie_> uh, be back alter :( i have to go back and finish reading 30 pages of crap
23:12:12 <shayan_> ah so it is :! clear 
23:12:51 <roboguy`> shayan_: yeah that works. It works because you can execute any shell command in GHCi with :!
23:13:14 <pie_> *later
23:37:36 <fragamus> Turtle is awesome
