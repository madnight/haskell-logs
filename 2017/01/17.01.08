00:00:08 <shayan_> I am entirely a beginner programmer
00:00:18 <ertes> nitrix: and yes, in type theory injectivity is an actual function…  it takes a function to a statement that the function is injective =)
00:00:28 <nitrix> shayan_: If you're going to buy one, my recommendation goes to http://haskellbook.com
00:00:30 <kadoban> shayan_: Personally I'd do http://haskellbook.com/  LYAH is available for free online, and ... IMO not very good.
00:01:24 <ertes> shayan_: there is also this one, which receives consistently good reviews: http://www.cs.nott.ac.uk/~pszgmh/pih.html
00:01:36 <monochrom> Actually you just need a higher-order logic for that. You don't need a type theory.
00:02:51 <nitrix> Oh, one more thing. Is there a name for the concept/property of being injective, surjective, bijective?
00:03:06 <ertes> nitrix: injectivity, surjectivity, bijectivity?
00:03:18 <monochrom> yeah, just nounify them
00:03:58 <monochrom> then again, two nounifications: injectivity --> the idea; injection --> a injective function.
00:04:06 <nitrix> ertes: I was hoping for a term that'd regroup them under some umbrella but I'm okay with it :P
00:04:12 <nitrix> monochrom: Right.
00:04:39 <ertes> nitrix: you can model those in category theory, too, but there are two possible models, which just agree on sets and types:  injective functions are monomorphisms/left-cancellative, surjective functions are epimorphisms/right-cancellative
00:04:54 <ertes> oops
00:05:06 <ertes> monomorphisms/left-invertible, epimorphisms/right-invertible
00:06:22 <monochrom> There is no word covering all three. But I feel like inventing one tonight. jectivism.
00:07:13 <nitrix> This comes from a friend of mine: *In the category of sets*, an injection is a monomorphism, a surjection is an epimorphism, and a bijection is an isomorphism.
00:07:41 <monochrom> I love epimorphism.
00:07:46 <shayan_> Thanks on the book suggestions. Are Mac users here using the Haskell for Mac?
00:07:51 <ertes> if you invent a word for bijections, you deprive yourself of the opportunity to say "my function is both monic and epic!"
00:07:57 <nitrix> ertes: Which makes a lot of sense to me, but his little annotation of "in the category of sets", makes me the more curious :P
00:09:03 <monochrom> because if you don't have sets, there is no "surjective" to talk about.
00:09:35 <monochrom> because "surjective" talks so much about set elements.
00:09:35 <nitrix> Is it because you might have duplicate elements?
00:09:53 <monochrom> No. Because you might have no such thing as "my object has elements" at all.
00:09:58 <ertes> nitrix: in CT you don't have "elements" to begin with
00:10:05 <nitrix> Oh, very true.
00:10:48 <ertes> (you can recover them in some categories, including sets and types, but they too are expressed in terms of morphisms)
00:10:55 <monochrom> Oh epimorphism has to say it pointfree: f is epic iff (forall g,h, g.f = h.f)
00:10:55 <nitrix> Even the category of sets, your sets are your objects and are supposed to be individable.
00:11:11 <monochrom> s/Oh/So/
00:11:11 <nitrix> So elements makes no sense.
00:12:01 <ertes> nitrix: the thing is: monic and epic are defined for all categories, so the definition can't make use of set/type features
00:12:11 <monochrom> Err I blew the definition.
00:12:33 * nitrix nods.
00:12:45 <monochrom> f is epic iff (forall g,h, g.f = h.f => g=h)
00:12:50 <ertes> monochrom: add an arrow for good measure =)
00:13:07 <nitrix> Thanks again, ertes and monochrom. I'll jump in bed and try to let the sponge absord it all :)
00:13:37 <monochrom> And I love epimorphism because it's a nice mirror image of monomorphism: f is monic iff (forall g,h, f.g = f.h => g=h)
00:13:59 <monochrom> Compare with how surjective looks totally out of whack wrt injective
00:14:00 <ertes>  /nick epichrom
00:14:22 <monochrom> Also I hate "forall-exists" proofs.
00:14:22 <nitrix> ertes: Try escaping your slash with another slash.
00:14:24 <nitrix> /foo
00:14:30 <ertes> //test
00:14:38 <nitrix> Weird, most clients support it.
00:14:45 <ertes> ERC apparently doesn't =)
00:15:10 <nitrix> 'night !
00:15:27 <ertes> have fun absorbing =)
00:16:08 <ertes> i hate exists-anything, mostly because proofs are awkward to write in agda
00:16:42 <monochrom> This is why you should write proofs in a real proof system.
00:16:52 <ertes> monochrom: example?
00:16:59 <monochrom> PVS. HOL.
00:17:34 <ongy> coq,isabelle/HOL I guess those are the frontends?
00:18:15 <monochrom> No, they are real proof systems.
00:18:33 <monochrom> "frontend" is when you look at Proof General.
00:18:37 <ertes> what makes them "real proof systems" compared to agda?
00:18:42 <monochrom> or some emacs modes.
00:19:00 <monochrom> Proofs are not awkward to write.
00:25:27 <ertes> hmm…  on the surfacs PVS seems more appealing, because it uses a type theory
00:26:20 <ertes> are proofs genuinely not awkward to write, or is the awkwardness just hidden behind a layer of convenience features like coq's tactics?
00:26:59 <monochrom> coq is probably going to be awkward. because it drinks the curry-howard koolaid too.
00:27:23 <monochrom> PVS doesn't. Instead, it entertains dependent types just for more convenience.
00:29:10 <ertes> monochrom: what's the "CH koolaid"?  you consider dependent types not a worthwhile direction?
00:29:23 <monochrom> If you have a function f :: Int -> Int, f x = x+1. You can state and prove this two ways. First way is dependent predicate subtype, you change my type to "f : (x:Int) -> { y:Int | y = x+1}". Second way is you keep my Int->Int type, and write a separate sentence "forall x. f x = 1".
00:30:11 <monochrom> The curry-howard koolaid means you shoehorn curry-howard into everything in your life.
00:31:03 <ertes> i'm really not sure what that means…  note: i'm not using agda's standard library
00:32:11 <ertes> what would be an example of such shoehorning?
00:33:08 <monochrom> Using a programming language like Agda to write proofs, using a proof language like Coq to write programs, and using DataKind in Haskell to write both.
00:36:04 <monochrom> And ATS.
00:36:24 <ertes> could you give me a specific example with agda?  i actually consider it a "real proof system" right now, and i don't consider it a (practical) programming language
00:37:32 <monochrom> I am too lazy to. But try a well-ordering proof some day.
00:38:34 <monochrom> Last time I saw one, it took me forever to decode what the proof (program) was saying.
00:40:08 <ertes> i'll take that as an exercise
00:40:24 <ertes> monochrom: well-ordering on naturals good enough?
00:42:35 <monochrom> You have a recursive function that goes like "f x =  .... f (x div 2) ..." in the recursive case. You need to prove its termination. You have to invoke a principle that says "well-ordered recursions terminate of course"
00:43:51 <ertes> monochrom: in other words the exercise is: "write such a function"?
00:44:03 <ertes> (agda will reject it, if it isn't convinced that it terminates)
00:46:01 <ertes> like the double-and-add algorithm for multiplication
00:46:33 <monochrom> Get one of those accepted by Agda.
00:47:26 <monochrom> Decide, ergonomically speaking, whether you have a proof or you have an encoding of a proof.
00:50:52 <ertes> monochrom: i'll try that and see how difficult it is, but i can make that decision right away:  my brain may be wired in a way not to see the difference…  i'll mostly just consider it an ugly proof (if it ends up being ugly, as you seem to predict)
00:51:26 <monochrom> It is not enough to be easy to write.
00:51:52 <ertes> monochrom: yes, i consider a proof ugly if it's difficult to *read*
00:52:06 <monochrom> It also has to be easy to read and guess what you wrote, for a reader who is an expert in natural deduction but not yet programming.
00:52:06 <ertes> too difficult/convoluted/complicated/…
00:52:38 <ertes> yeah, i see what you mean…  i'll try
00:53:26 <ertes> monochrom: just for comparison: could you point me to a HOL/PVS version of such a function?
00:54:50 <ertes> (or proof of termination, if necessary)
00:55:10 <monochrom> I think, right there, it shows how you have misunderstood what a proof system (not programming system) looks like.
00:56:03 <monochrom> In HOL or PVS, you first submit "f 0 = 0; f x = f (x div 2)". No no, it doesn't mean that HOL or PVS accepts it right there, but...
00:56:56 <monochrom> In an interactive usage, you submit that first, then the system prompts you to prove "x div 2 < x".
00:57:36 <ertes> i see
00:57:44 <monochrom> Both HOL and PVS are interactive tactical proof systems. From that point on you do something similar to Coq inside Emacs.
00:58:14 <monochrom> HOL can also be used as a batch system. You can submit f and the proof commands in one go.
00:59:21 <ertes> in that case i'll do something different:  check out one of those
01:00:24 <monochrom> The most visible difference (though also pretty superficial) against Agda is that in the Agda version you will define a type that stands for well-founded recursion, and you will thread values of that type through your f.
01:00:56 <monochrom> In HOL you don't write such a type. You just write sentences.
01:01:22 <monochrom> In PVS you can do either. But I KISS and just write sentences too.
01:01:35 <ertes> which one would you recommend?  without any guidance i'm leaning more toward PVS
01:02:10 <monochrom> PVS is less effort to install and probably start using.
01:02:17 <ertes> is there a "but"?
01:02:24 <monochrom> No.
01:02:28 <ertes> ok, thanks
01:03:01 <monochrom> Unless you repel emacs. PVS is hard-tied to using emacs for frontend. No "can I run a REPL in my favourite shell".
01:03:20 <monochrom> Hell, in fact no "can I just use stdin and stdout?"
01:03:29 <ertes> i do use emacs, so that's a plus
01:04:22 <Tuplanolla> Coq has those features, even if a bit awkwardly.
01:05:04 <ertes> but no PVS package in my distribution, so i'll try HOL first and maybe package PVS myself later
01:05:59 <ertes> what is isabelle?  i have a hol4 package and an isabelle package
01:06:29 <monochrom> Isabelle is a meta proof system.
01:06:53 <monochrom> This means you define a proof system, or maybe just a logic, in Isabelle.
01:07:30 <monochrom> "Isabelle/HOL" means someone defined a proof system called HOL using Isabelle.
01:07:45 <ertes> ok, so i should get hol4?
01:08:13 <monochrom> yes
01:08:13 <ertes> alright, thanks
01:08:18 <ertes> there is also hol_light
01:08:54 <monochrom> hol light is leaner. maybe you should go with that.
01:10:59 <ertes> how are hol and hol light related?  like haskell and helium, like GHC and hugs, or like base and a hypothetical mini-base?
01:11:47 <monochrom> I think it's like haskell and helium.
01:12:25 <ertes> in that case i'd prefer to go with hol4
01:29:59 <ertes> monochrom: out of curiosity: would you consider isabelle a "real proof system"?
01:30:50 <monochrom> no, but it is a real meta proof system.
01:31:07 <ertes> so i could use it to construct a real proof system?
01:31:08 <Younder> ertes, It's one of the best proof systems out there
01:31:25 <monochrom> yes
01:32:23 <Younder> I've used it for 25 years
01:32:23 <Younder> Which makes me pretty onl ;)
01:32:24 <Younder> old
01:32:28 <athan> Is isabelle self-hosted?
01:32:34 <Younder> Yes
01:32:53 * athan dives dives dives!!
01:33:07 <Younder> It is written in ML and a java app launces it.
01:33:30 <Younder> Not entirely sure what you man by self hosted.
01:33:35 <ongy> the entire editor (which is somewhat mandatory) is a java application
01:33:45 <athan> Does isabelle treat ML as the language to prove over then?
01:33:53 <monochrom> No.
01:34:00 <athan> or, it can establish proofs about ML?
01:34:19 <athan> oh hm
01:34:30 <monochrom> Yes, but you have to do your own definition of ML
01:34:32 <Younder> When I started using it it used EMACS. Then code general in EMACS. Then it moved to this Jaca app.
01:34:51 <ongy> afaik. the current intended way to actually run code is to write it in the internal language and then export to haskell
01:35:06 <monochrom> There is no "self hosting" for proof (not programming) languages. It is not a programmng language. What is there to compile?
01:35:27 <monochrom> The problem with the curry-howard koolaid.
01:35:34 <Younder> It has a haskabelle app that can translate haskelle to HOL. (One of it's logics)
01:36:02 <athan> monochrom: Yeah I had the feeling it was Godel related or something
01:36:23 <Younder> lol yes it is pretty cool
01:36:40 <Younder> Try it someday
01:36:44 <monochrom> No, Godel does not prevent you from using Agda to write an Agda compiler.
01:36:47 <athan> :x
01:37:02 <athan> I meant the sanity of it
01:37:05 <monochrom> Godel only says that if you do so, he can't prove soundness for you.
01:37:15 <Younder> monochrom, I am not following you, what do you mean
01:37:51 <athan> sorry, too much kool aide
01:38:04 <Younder> huh
01:39:04 <Younder> I could always bring out my dominant negative side.
01:39:06 <monochrom> But Agda is still a programming language so you can use it to write whatever compiler you like.
01:39:26 <monochrom> Isabelle probably isn't even intuitionistic.
01:39:51 <athan> Younder: Do itttt :D
01:39:53 <Younder> I don't like any existing compilers that is why I am writing Formula. 
01:41:27 <Younder> I could wine. I choose to do.
01:43:31 <Younder> athan: I am doing itttt
01:43:48 <Younder> always have relly
01:44:17 <athan> reeeeee!!!!
01:44:36 <Younder> Any of you into machine intelligence?
01:48:40 <Younder> AI is a term by Marvin Minsky. He said "What we do is emulate behavior usually associated with cognition. It does not always or even usually collate with the way humans cognate"
01:49:38 <Younder> Or at least that is my memory of it
01:50:21 <Younder> I Do machine intelligence it does all of the thing marvin sais AI doesn't ;)
01:53:59 <Younder> I am not yet a expert in Haskell. but I am aspiring to be
01:54:18 <srk> Younder: oh yes!
01:54:42 <srk> Younder: going to try tensorflow soon
01:54:47 <srk> on gtx1070
01:54:49 <Younder> srk, You are cursed with my presence now
01:54:54 <srk> :D
01:55:52 <Younder> Let's move on to math
01:59:04 <Younder> I expect you know lambda calculus. 
02:00:25 <Younder> My question concerns the Y combinator.
02:01:20 <Younder> How does it cause recursion?
02:06:36 <Younder> so much negativity. Is that really in the spirit of this group
02:06:42 <Younder> whatever
02:07:53 <cocreature> Younder: if you expand the Y combinator applied to a function f you can see that "Y f = f (Y f)" if you continue doing that you get recursion
02:14:13 <Younder> cocreature, thx
02:58:42 <ph88> anyone tried this yet? https://github.com/beijaflor-io/haskell-libui
03:01:46 <athan> welp, irssi isn't working for me no mo. This looks like a job for, IRCMonad!
03:03:19 <athan> wut
03:03:22 <athan> "The following GHC options are incompatible with GHCi and have not been passed to it: -O2"
03:03:29 <athan> ...have _not_ been...?
03:05:30 <ph88> looks like valid english to me
03:06:06 <athan> ph88: Sure, but not sure why it's necessary, given that it shouldn't be an issue
03:07:17 <ph88> well i can see why they aint using compile time optimizations for interprented code
03:07:27 <athan> er wait, I think I see the seam
03:07:29 <ph88> i think you can compile some modules before your start ghci
03:07:59 <ph88> because ghci can use mixed compiled code with interprented code
03:08:12 <ph88> i think it actually compiles some stuff on start but not sure
03:08:37 <athan> oh wow, okay. Thanks ph88
03:08:55 <ph88> eh it's just what i read in the ghci manual ^^
03:09:15 * athan needs to do that more ._.
03:09:45 <Tuplanolla> See `-fobject-code`, athan.
03:10:10 <ph88> but in case ghci compiles some code too then it should be able to get passed -O2 imo .. but probably it just isnt implemented yet
03:15:26 <portu> Does anyone use haskell-mode on emacs? I can not figure out why autocomplete doesn't work.
03:17:31 <rod> Hi , got  simple ceaser cypher program here (http://lpaste.net/351011) ... but somehow when run from console it wont encrypt Capital letters and special chars ... who can help
03:22:50 <ongy> > map chr [32..255]
03:22:52 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
03:23:41 <ongy> rod: what do you mean "won't encrypt"? Does it error, or just not change it?
03:25:06 <f-a_> I have a pattern matching like (Something _ _ _ _ _). Is there a way to avoid placing all the underscores (I am only interested if the constructor is Something)?
03:25:36 <rod> ongy, just doesn't change
03:25:49 <raduom> Hi. What framework do people usually use for haskell unit testing?
03:25:51 <ph88> f-a_, with records you can do  ..  i think
03:26:03 <f-a_> ph88: it's an extension, right?
03:26:14 <ph88> f-a_, don't think so
03:26:27 <rod> ┌─[rod@polyphem] - [~/Dev/haskell/ceasar] - [So Jan 08, 12:25]
03:26:27 <rod> └─[$]> ./ceasar 0 3                                                                                                                                                          ~/Dev/haskell/ceasar
03:26:27 <rod> abc
03:26:27 <rod> def
03:26:27 <rod> ABC
03:26:29 <rod> ABC
03:26:51 <ph88> aha, a european !
03:26:57 <AndreasK> you can use (Something {})
03:27:12 <ph88> oh yes ups it's {} not ..   :/
03:27:21 <ongy> ph88: there's even German words in the paste :)
03:27:23 <f-a_> oh my goodness, thanks AndreasK and ph88 
03:27:32 <f-a_> silly me, I should study haskell syntax more closely
03:27:40 <ph88> you can then use  .. inside of  {} i think :P
03:27:59 <ph88> {fieldOne, ..}    don't remember the syntax exactly
03:28:07 <AndreasK> Record syntax is the ugliest part of haskell imo
03:28:14 <AndreasK> syntax wise
03:28:20 <Ferdirand> but if you need to do this often, maybe your datatype definition is suboptimal ?
03:28:37 <f-a> AndreasK: do you like any of the proposed alternatives?
03:28:59 <f-a> Ferdirand: indeed it probably is
03:29:01 <athan> Do type roles line up with type variables?
03:29:38 <athan> When I look at `:info Lens`, I see `type role ReifiedLens representational nominal representational nominal`
03:29:44 <rod> ongy, starce is that in ghci , it works with capitals
03:29:48 <rod> Prelude> :l ceasar.hs
03:29:48 <rod> [1 of 1] Compiling Ceaser           ( ceasar.hs, interpreted )
03:29:48 <rod> Ok, modules loaded: Ceaser.
03:29:48 <rod> *Ceaser> crypt Crypt 3 "ABC"
03:29:48 <rod> "DEF"
03:29:53 <athan> where ReifiedLens has 4 type arguments
03:30:03 <rod> s/starce/strange/
03:30:58 <AndreasK> f-a: Aren't these mostly about resolving name clashes?
03:31:11 <athan> Hmm, what is the purpose of a RefiedLens? Just to be more discrete than a type alias?
03:32:27 <f-a> AndreasK: I confess I only peeked at a few of them
03:33:48 <lyxia> athan: you can't write [Lens s t a b] because that is an impredicative type.
03:33:51 <AndreasK> f-a: In the end even with the basic record syntax i vastly prefer haskell syntax over the redundant requirement of {<>}; in most languages
03:34:15 * f-a nods
03:34:32 <athan> Ahh! Thank you lyxia! So it just packs the existential, right on
03:36:09 <AndreasK> Is there a way to check why stack solver rejects a package version?
03:41:22 <AndreasK> cabal via stack solver is using 8 gigs of ram and spent already 7 Minutes trying to solve my dependencies, wonder if i hit a bug or if there are simply that many options ...
03:42:16 <Tuplanolla> Are you installing Yesod or something, AndreasK?
03:42:37 <AndreasK> No, actually my only requirement is wx >= 0.90
03:42:49 <Tuplanolla> Sounds like a bug then.
03:42:57 <Tuplanolla> @hackage wx
03:42:57 <lambdabot> http://hackage.haskell.org/package/wx
03:43:29 <Tuplanolla> This isn't even big.
03:43:38 <AndreasK> Without version constraint the solver pulled a version that was over 5 years old
03:44:02 <AndreasK> Yeah I would also guess it's a big it sits at 12GB now
03:44:06 <AndreasK> *bug
03:56:07 <AndreasK> I think i just hit an issue with low upper bounds for the first time, so this is the dependency hell people where talking about that stack solves xD
04:11:20 <AndreasK> Is there a way to pass flags to cabal through stack solver?
04:17:18 <eklavya> davean: hi, are you free?
04:28:50 <Eduard_Munteanu> Anybody using ghc from backports on Debian Jessie? I can't install any packages from Jessie, they seem to be incompatible with backports stuff.
04:36:46 <kuribas> athan: have you seen this?  Might be something for you: https://docs.google.com/forms/d/e/1FAIpQLSdVkckUp_Q6DzWaB7FgiaCIokR6prM6kMxnMUa-0vFbFhU2uQ/viewform?c=0&w=1
04:37:46 <athan> kuribas: :o where do you find stuff like this?!
04:37:55 <kuribas> athan: reddit/r/haskell :)
04:38:04 <athan> It's very difficult to appeal interpersonally for me
04:38:19 <athan> here let's go to -offtopic
04:38:19 <kuribas> athan: you mean remote?
04:38:23 <kuribas> yuah
05:03:19 <osa1> where is syntax of persistLowerCase etc. of persistent-template documented? 
05:04:12 <ij> monochrom, Permutation doesn't cut it, because the length is always the same?
05:18:49 <NextHendrix>  /seriousquestion
05:18:58 <NextHendrix> woops
06:18:45 <ij> What's an example of an uncompilable function that is made compilable by inference?
06:21:09 <hpc> what do you mean by uncompilable?
06:21:29 <cocreature> you can always replace inference by explicit type annotations so I don’t think such a thing exists
06:22:07 <ij> hpc, One that wouldn't compile, heh.
06:22:48 <ij> I had code that I split up into modules and since inference doesn't work over imports, something became uncompilable. I can and DID fix it, but I just want the minmal example to understand why and how that happens.
06:24:08 <hpc> uh
06:24:23 <hpc> you changed something that was broken into something that worked? ;)
06:28:41 <nomeata> Hi. We ave announcements like: https://github.com/fpco/stackage/issues/2194. What would it take for it to include information about what packages built fine with `--allow-newer=vector` and which packages did not? Almost always I am doing nothing but rebuilding the package with the new version and see if it compiles. If that were done centrally, it would take much less work to keep packages updates, as I’d just update the .cabal file on hackage instead.
06:29:25 <ij> hpc, cocreature, The scenario is roughly as follows: A.hs: "f = x; g = f y" without type annotations works. Then A.hs: "f = x", B.hs: "g = f y" stops working without type ann.
06:29:25 <Tuplanolla> Turn off `MonomorphismRestriction`, ij.
06:30:28 <ij> Okay, so can I have an example of this?
06:30:38 <ij> Because I already fixed it and don't remember how to replicate that.
06:30:44 <Tuplanolla> > let biapply (proj :: forall a. (a, a) -> a) f x = (proj f) (proj x) in biapply fst (succ, pred) (42, 13) -- Here's an example of an expression that doesn't work without the explicit type signature, ij.
06:30:47 <lambdabot>  43
06:32:08 <ij> So you type-annotated an argument there?
06:32:08 <ij> Didn't know you can do that.
06:32:35 <Tuplanolla> > let biapply :: (forall a. (a, a) -> a) -> (a -> a, a -> a) -> (a, a) -> a; biapply proj f x = (proj f) (proj x) in biapply fst (succ, pred) (42, 13) -- This is the same thing, ij.
06:32:37 <lambdabot>  43
06:35:21 <ph88> Eduard_Munteanu, did you try stack ?
06:35:21 <ij> Tuplanolla, That's some expressive code outside the context of the problem we're discussing.
06:37:04 <Tuplanolla> You asked for code that doesn't work without type annotations, ij. With `NoMonomorphismRestriction` your original problem is not such.
06:37:54 <Tuplanolla> Note that GHC can always infer the most general rank-1 type, ij.
06:41:40 <ij> Hmm, I split that in modules and it still compiles.
06:43:14 <Psychiatrist> Hey guys. Could anyone explain why I get an error when trying to run this: sqrt (14 `mod` 31) ?)
06:43:33 <hpc> :t sqrt
06:43:34 <lambdabot> Floating a => a -> a
06:43:36 <hpc> :t mod
06:43:38 <lambdabot> Integral a => a -> a -> a
06:43:57 <Psychiatrist> so I need to convert my Integral into a Floating type?
06:44:03 <hpc> Psychiatrist: the way you're using those, the type of both numbers and the result ends up being
06:44:10 <hpc> (Floating a, Integral a) => a
06:44:27 <hpc> which could technically happen, but shouldn't
06:44:50 <hpc> you'll need to fromIntegral the parameter to sqrt most likely
06:45:09 <hpc> and possibly more depending on where 14 and 31 come from
06:45:11 <Tuplanolla> For some reason `mod` doesn't support nonintegral numbers, Psychiatrist.
06:46:08 <ongy> how's modulo defined for non-integral numbers?
06:46:54 <Tuplanolla> Like this, ongy: `mod' x b = x - b * floor (x / b)`
06:47:10 <Psychiatrist> Thanks guys! Why doesn't Haskell  automatically convert the input to sqrt then, like reduce the input down or up?
06:48:47 <ongy> > let mod x b = x - b (x / b) in mod (-1) 5 
06:48:50 <lambdabot>  error:
06:48:50 <lambdabot>      • Occurs check: cannot construct the infinite type: t3 ~ t2 -> t3
06:48:50 <lambdabot>      • In the second argument of ‘(-)’, namely ‘b (x / b)’
06:49:00 <ongy> > let mod x b = x - b * (x / b) in mod (-1) 5 
06:49:02 <lambdabot>  0.0
06:49:03 <ongy> > mod (-1) 5
06:49:05 <lambdabot>  4
06:49:19 <ongy> that doesn't even work for Integers
06:51:44 <Gloomy> Hi :)
06:52:12 <Gloomy> What is the intelligent way to create error messages when you write a parser? ( from scratch, not using a library) 
06:52:51 <Gloomy> I have a <?> function (similar to the one in parsec) which allows me to specify an error message when a parser fails
06:54:01 <Gloomy> the problem is it generates monstrous (and pretty useless) errors:
06:54:40 <Gloomy>  if I do `parse (parseString "hello") "bye bye"` , since my "parseString" function is defined  as recursively calling a "parseChar" functions, the error becomes something like
06:55:37 <Gloomy> [Expected "Character 'h'", Expected "Character 'e'", ... , Expected "String: \"hello\""
06:55:39 <Gloomy> ]
06:55:59 <Gloomy> ideas welcome :)
06:56:26 <Tuplanolla> You forgot the `floor`, ongy.
06:56:57 <Tuplanolla> > let mod x b = x - b * (fromIntegral . floor) (x / b) in mod (-1) 5
06:56:59 <lambdabot>  4.0
06:57:24 <ongy> ah, I wanted it to do integers... didn't think about the /`div` difference
06:58:07 <ongy> > floor (-1.5)
06:58:10 <lambdabot>  -2
06:58:22 <ongy> which isn't the same, ok then it should work for negative numbers
06:58:35 <Psychiatrist> :r
06:58:54 <Psychiatrist> sorry
07:02:31 <danpalmer> Hi, anyone know much about Networking in Haskell? I'm debugging an issue with connecting to Redis from a Yesod app.
07:02:31 <danpalmer> Here's my investigation so far, have run out of things to try/investigate https://gist.github.com/danpalmer/710f894349f70a8b0cb9135a33a040af
07:07:56 <amx> do you have ssh access?
07:09:25 <amx> first thing I would try is: telnet redis 6379
07:09:44 <amx> i.e. make sure you can connect to redis on the host from the CLI
07:10:05 <amx> if not, then this is not specific to your program
07:11:45 <danpalmer> amx: I can connect to redis fine over telnet, and from GHCi
07:12:34 <danpalmer> I've concluded it must be specific to my program, but I have no idea what's non-standard about my program. I don't understand enough about Haskell or networking in Haskell to know what to look for - any ideas?
07:15:27 <cocreature> danpalmer: have you tried isolating the error, i.e., make a simple executable that only tries to connect?
07:16:06 <danpalmer> cocreature: not a separate executable yet, no, only tried in GHCi. Will try that now though, thanks
07:16:52 <ongy> danpalmer: you could try to strace the client and search for the bind (I think/hope strace has human-readable output for that) and see if the call is correct
07:16:55 <Tuplanolla> Relating to networking: is there a good way to mock connections when testing protocols?
07:18:27 <ongy> Tuplanolla: I have a test-system that does l2/l3 testing with tap/tun interfaces :) For tcp-based it may be easiest to set up a test-server application. If you can test on linux network-namespaces are quite useful
07:19:01 <Tuplanolla> How about doing it on the Haskell level with a type class?
07:19:39 <danpalmer> ha, strace is going to be a pain as I'm in Docker. Will have to mess about with the deployment, but will try soon
07:19:56 <amx> danpalmer: and try connecting to the redis IP both from the CLI and from your program and compare results
07:20:53 <danpalmer> amx: have tried that, cannot reproduce the connection failure in GHCi using Hedis, telnet or redis-cli
07:21:12 <danpalmer> oh yeah, if I install redis locally in the container, and point the app at localhost though, that works, which is weird?
07:25:40 <gcolpitts> using ghc why do I get a parse error in ghc when I use the "#" character?
07:26:49 <gcolpitts> e.g. :i Double#
07:26:49 <gcolpitts>  
07:26:49 <gcolpitts> <interactive>:1:7: error: parse error on input ‘#’
07:27:21 <Tuplanolla> You need the `MagicHash`, gcolpitts.
07:28:24 <Gloomy> Is there really no way to say "or" in case statements?
07:28:30 <Gloomy> like if I want to do: 
07:28:38 <Gloomy> case parsedString of 
07:29:13 <Gloomy>  "ms" || "miliseconds" || "milisec" || "msec" -> ...
07:29:16 <cocreature> Gloomy: the problem with disjunctive patterns would be that you cannot bind variables in them or you need to force variables to have the same name
07:30:07 <cocreature> Gloomy: in that case just use a guard case parsedString of s | s `elem` ["ms", "miliseconds", …] -> …
07:31:46 <ezyang> Well, I do sometimes wish we had disjunctive patterns 
07:31:46 <Tuplanolla> If your list is big, use `Map` instead of list there, Gloomy.
07:31:46 <gcolpitts> Tuplanolla: Thanks!!
07:31:46 <Gloomy> Ah, yes, didn't remember you could use guards there
07:31:46 <Gloomy> thank you :)
07:31:46 <cocreature> ezyang: heh, yeah me too. I just wanted to point out that it’s not quite as easy as it may seem at first
07:31:58 <ezyang> cocreature: But it's not that hard either :^) 
07:32:09 <cocreature> ezyang: I’ll wait for you to implement it :)
07:33:29 <cocreature> those are the moments where I wish template haskell was as convenient as lisp macros. changing your lisp pattern match macro to support this would be a lot easier than hacking this into ghc
07:34:16 <Tuplanolla> Your daily dose of Lisp envy has arrived.
07:34:36 <cocreature> :)
07:49:07 <Younder> Lisp ? here, 
07:49:49 <Younder> Ahh got it.
07:50:31 <gcolpitts> trying to use  integerLog2# in ghci but when I type integerLog2# 2 I get
07:50:38 <gcolpitts> <interactive>:3:1: error:
07:50:38 <gcolpitts>     • Couldn't match a lifted type with an unlifted type
07:50:38 <gcolpitts>       When matching the kind of ‘GHC.Prim.Int#’
07:50:38 <gcolpitts>     • In the first argument of ‘print’, namely ‘it’
07:50:41 <gcolpitts>       In a stmt of an interactive GHCi command: print it
07:50:45 <gcolpitts> (0.00 secs,)
07:50:59 <Tuplanolla> The literal is `2#`, gcolpitts. Also next time...
07:50:59 <Tuplanolla> @paste
07:50:59 <lambdabot> Haskell pastebin: http://lpaste.net/
07:51:52 <codedmart> I am looking for `(m a, b) -> m (a, b)`?
07:52:03 <codedmart> I was thinking sequenceA but that isn't right.
07:52:11 <Tuplanolla> Sounds like `sequenceA` under `swap`, codedmart.
07:52:34 <Tuplanolla> :t swap . sequenceA . swap
07:52:36 <lambdabot> Monoid a => ((a, a1), b) -> ((b, a1), a)
07:53:00 <feuerbach> :t fmap swap . sequenceA . swap
07:53:03 <lambdabot> Applicative f => (f b, a) -> f (b, a)
07:53:03 <Tuplanolla> Right.
07:54:49 <codedmart> Thanks
08:08:09 <MarcelineVQ> codedmart: that came up recently, another solution is (\(x,y) -> (,y) <$> x)      (\(x,y) -> (\a -> (a,y)) <$> x)  without TupleSections
08:26:50 <Gloomy> Hi again
08:27:23 <Gloomy> How can I say in a function signature that a type is... showable? 
08:27:30 <Gloomy> like: http://lpaste.net/351015
08:27:41 <palmfrond> Hi! is there a conventional way for me to use the original functions on types that are just wrapped? e.g. I want to use functions f :: T -> T on a type like U a = U T
08:27:53 <Gloomy> This gives me an error because it isn't sure that it will be able to "show a" 
08:28:27 <Gloomy> Which makes sense except I know that a will be showable, but how do I tell it to the compiler?
08:28:40 <palmfrond> Gloomy: not sure how to put this into your example, but maybe put something like f :: (Show a) => ... -> ....
08:28:51 <palmfrond> Gloomy: you may need to implement or derive an instance of Show
08:29:26 <Gloomy> palmfrond ah, well, that was easy :-) 
08:29:30 <Gloomy> thansks.
08:33:17 <hexagoxel> palmfrond: you mean `newtype U = U T` ?
08:33:25 <palmfrond> hexagoxel: yes, exactly
08:33:30 <palmfrond> hexagoxel: wait no
08:33:43 <palmfrond> hexagoxel: i mean like a phantom type defined as newtype U a = U T
08:34:38 <hexagoxel> palmfrond: coerce might work for that still. i.e. coerce . f . coerce
08:35:18 <palmfrond> @type coerce
08:35:20 <lambdabot> error: Variable not in scope: coerce
08:35:41 <hexagoxel> Data.Coerce
08:36:23 <palmfrond> hexagoxel: thanks for the tip, I'll try it out
08:36:35 <glguy> hexagoxel: You'd actually only need one coerce
08:36:57 <hexagoxel> coerce f ?
08:37:24 <glguy> Yeah, you shold be able to do that
08:37:39 <palmfrond> hexagoxel: is this the preferred way to deal with this problem? it seems like any way to do what I want adds a lot of wrapping and unwrapping
08:38:19 <cheshircat> Hey, I don't know if this is the right place to ask, but does anyone know of any internships using haskell?
08:38:28 <glguy> palmfrond: The point of newtypes is to make a distinct type that is incompatible with the previous one. The preferred way would be to write specific wrappers for the operations that the new type should support
08:38:39 <cheshircat> University math major here, with good computer science background
08:39:48 <hexagoxel> glguy: thanks for the remark btw, was not aware of the function Coercible instance.
08:40:22 <glguy> cheshircat: Galois has internships, and those internships often involve Haskell
08:41:08 <cheshircat> I was planning to apply there!
08:41:27 <cheshircat> good to have that re-affirmed though :)
08:43:02 <palmfrond> glguy: aren't newtypes also used to create phantom types which may be subtypes of the unwrapped type? if not, is there a better way for me to create subtypes that can use functions from the supertype?
08:47:16 <glguy> palmfrond: "phantom type" refers to the 'a' in your 'newtype U a = U t' and the fact that it's otherwise unused
08:47:23 <glguy> Haskell doesn't have subtypes
08:48:15 <c_wraith> Haskell doesn't have *nominal* subtypes.
08:48:25 <c_wraith> Though that level of extra detail is probably unimportant.
08:49:03 <palmfrond> glguy: is there anything better than ignoring subtypes entirely? it seems unsafe
08:49:35 <c_wraith> Give them *different* types
08:49:38 <c_wraith> Not subtypes
08:50:20 <palmfrond> c_wraith: so should I just suck it up and wrap/unwrap everything when I want to use functions defined on the supertype for elements of the subtypes?
08:51:05 <c_wraith> palmfrond: no, you should go the other way.  Create a small number of primitive functions that have semantic value for your new type.
08:51:19 <c_wraith> If you just go around unwrapping your type all over the place, you lose the benefits of having it be a different type.
08:51:41 <c_wraith> If you restrict yourself to a small set of semantically-meaningful functions to work with them, you don't lose the benefits
08:52:40 <palmfrond> c_wraith: right, but many of those specialized functions for operating on the new types do operations on the old type (in my case, the new type is encoded strings, and the original type is all strings)
08:53:12 <c_wraith> palmfrond: yes, those will need to unwrap.  But there usually won't be very many of them.
08:53:47 <palmfrond> c_wraith: okay, thanks for the advice
08:54:56 <kuribas> palmfrond: why not do "newtype MyWrapper = MyWrapper {unwrap :: X}", then "f . unwrap"
08:55:01 <palmfrond> c_wraith: also, you said to give them different types - does this mean for, say, encoding types E1, E2, I should have newtype E1 = E1 ByteString; newtype E2 = E2 ByteString or data E1; data E2; newtype E a = E ByteString ? does it matter? if so, why?
08:55:30 <c_wraith> palmfrond: no, the wrapper can have a type variable.  I was just pointing out that logically they aren't subtypes.  They're not interchangeable in either direction.
08:58:49 <codedmart> can you append to a tuple? If I have (1,2,3) can I append 4?
08:59:09 <c_wraith> palmfrond: the Liskov Substitution Principle is a pretty good rule here.  If it doesn't make sense to use a value of type B in every single place you could use a value of type A, then B should not be a subclass of A.
08:59:50 <palmfrond> c_wraith: hmm, thanks - I hadn't thought about that for a while
08:59:52 <c_wraith> codedmart: nope.  You have to pattern match and create a new one.
09:00:05 <c_wraith> palmfrond: err, subtype, not subclass
09:00:15 <codedmart> OK fair enought. That is what I am doing but wanted to check. Thanks!
09:03:32 <c_wraith> palmfrond: Haskell has a very limited form of non-nominal subtyping.  It's used heavily by libraries like Lens, where every Lens is a Traversal, and so on.  (It's not nominal subtyping because Lens and Traversal are type aliases for functions of particular forms, not distinct types)
10:00:27 <kuribas> > let appendTuple (a, b) c = (a, (b, c)) in appendTuple (1, 2) 3 -- codedmart 
10:00:31 <lambdabot>  (1,(2,3))
10:11:11 <Liskni_si> or this:
10:11:15 <Liskni_si> class AppendTuple a b c | a b -> c where appendTuple :: a -> b -> c
10:11:15 <Liskni_si> instance AppendTuple (a, b) c (a, b, c) where appendTuple (a, b) c = (a, b, c)
10:11:15 <Liskni_si> instance AppendTuple (a, b, c) d (a, b, c, d) where appendTuple (a, b, c) d = (a, b, c, d)
10:18:10 <kuribas> exercise: implement tail and cons :)
10:19:15 <monochrom> yikes
10:20:32 <ertes> appendTuple :: a -> b -> (a, b)
10:20:35 <ertes> appendTuple = (,)
10:21:18 <ertes> how about not making it complicated?  (,) is associative with respect to isomorphism:  ((a, b), c) ≃ (a, (b, c))
10:28:35 <Cale> ertes: One thing which came up when we were working on arrow-ish FRP was how to find optimal composites of isomorphisms between tuple types of that sort. Like, if you have two different associated permutations of the same alphabet, what's the minimal path from one to the other?
10:28:35 <Cale> (applying associativity and commutativity)
10:29:50 <deech> Hi all, can anyone recommend a Haskell Go parser? https://hackage.haskell.org/package/language-go hasn't been updated since 2011.
10:30:45 <Cale> There's this concept of an associahedron in CT, which is a polyhedron whose 0-cells are the various associations of a word, and whose edges correspond to applications of the associative law. If you add commutativity in, it'll multiply the number of vertices by n! and there will be edges between these n! copies of the associahedron corresponding to applying commutativity in various ways.
10:31:08 <Cale> It would be really interesting to have a specialised kind of generalised sorting algorithm for efficiently finding paths through that graph :)
10:31:36 <Cale> deech: I wouldn't be surprised for none to exist.
10:32:09 <Cale> deech: Has the syntax of Go changed all that much since then?
10:32:37 <deech> No idea.
10:32:59 <Cale> Might be worth giving that library a shot and see if it can parse what you want to parse.
10:35:27 <geekosaur> go was changing quite a lot in that period; they were quite proud of their conversion scripts to upgrade existing go programs
10:35:29 <hsk3> Is it possible for testing code to gain access to private functions (funcs not exposed in modules)?
10:36:19 <glguy> hsk3: No, "test" code can't access definitions that normal code can't
10:36:33 <hsk3> a'ight
10:37:13 <hsk3> a bit pity in some ways. it will make it hard to test pure private funcs without (otherwise unnecessarily) exposing them
10:39:49 <glguy> You can have your test suite not depend on the library you're defining, but rather reimport all of the library modules as part of the test suite
10:40:10 <glguy> or test the public functionality without locking down the implementatino
10:40:26 <glguy> or put the private functions in a module documented to be "Internal"
10:40:55 <hsk3> glguy, ah! the .Internal approach I've seen with many libraries
10:41:01 <hsk3> so that's why they do it
10:41:04 <hsk3> (i guess)
10:46:51 <AndreasK> Has anyone here used wxHaskell with stack?
10:47:28 <glguy> AndreasK: Unless you're taking a usage survey, it's better to ask your actual question
10:49:30 <AndreasK> Is there an up to date guide to make it work? So far I had little luck
10:50:13 <AndreasK> I did manage to build wxwidgets and the packages but there seem to be some incompatibility between dlls, it can't find a entry point for wxData
10:52:10 <glguy> I don't know, but maybe someone does. You're more likely to get help with a question like "I tried to this *this* and I got this output that i pasted to lpaste.net, can someone help?"
10:56:07 <c_wraith> hsk3: that's one reason.  I think the even more important reason is that sometimes you just get the list of things you think are primitive wrong.  Giving access to the internals means that people don't need to fork the library to use it in that case.
11:16:26 <kadoban> Anyone have a hp2ps invocation that doesn't cut off the names of cost centers in the key? I can never tell what 1/2 of them are since they get cut off too early.
11:16:50 <kadoban> Been looking at --help and trying stuff for a bit, but nothing seems to help. -M sounds good, but it doesn't appear to do anything useful, in particular I don't get two pages.
11:21:00 <Schoolmeister> Hey, can anyone help me with a question? I've got a Parser (defined as newtype Parser a = Parser (String -> [(a, String)])). When parsing fails, it returns a Parser (String -> []), since it can't find any matches. I've got a function, identifier, where I want it to not match anything based on a boolean, how could I do this? This is part of my code, even though it's really only the last function that 
11:21:00 <Schoolmeister> matters. http://lpaste.net/8809761287476084736 
11:22:40 <Schoolmeister> right now, if I try the function is returns a Parser (String -> [("","")]
11:23:58 <lpaste> prsteele pasted “install error” at http://lpaste.net/351027
11:24:05 <prsteele> hello everyone. Anyone have an idea of what this error might be caused by?
11:24:33 <prsteele> there's much more that just that message in the log file, but that seems to be the important bit  
11:25:06 <c_wraith> kadoban: I think I found an option for that once, but I have no idea what it was.
11:25:12 <cocreature> prsteele: the rest is probably important too :) that message alone doesn’t give a lot of information
11:25:52 <kadoban> c_wraith: :( it seems insidiously hard to get it to actually behave. Maybe I'll just have to guess what things are
11:27:15 <lpaste> prsteele pasted “more errors” at http://lpaste.net/5749357073418682368
11:27:20 <pavonia> Schoolmeister: I think you want "if isReserved (s:sx) then mzero else return $ s:sx"
11:27:36 <johnw> wow, i love how many servant packages there are these days
11:28:11 <pavonia> Schoolmeister: or "return (s:sx)", if you are not used to $
11:30:00 <cocreature> prsteele: that looks weird. maybe your pkg database is corrupted. you could try removing ~/.ghc (note that this will remove all globally installed packages)
11:30:38 <geekosaur> but it should be using the in-place registered xmonad library in dist/
11:30:40 <glguy> you can check if it's corrupted with ghc-pkg check
11:30:50 <Schoolmeister> pavonia: Thanks! That was indeed the problem. Just figured out I could've also just used "guard (not $ isReserved $ s:sx)", which looks a bit more tidy
11:31:05 <geekosaur> it's building the executable part, having built and in-place registered the library
11:31:37 <prsteele> rm -r ~/.ghc ~/.cabal; cabal update; cabal install xmonad # gives the same result
11:33:12 <prsteele> I'm using GHC 8.0.1 if that sets off alarm bells. The hackage page says it just needs base <5...
11:34:06 <geekosaur> 8.0.1 should work with 0.12. although I'd recommend using git instead of installing via cabal anyway, because of the strut bug (https://wiki.haskell.org/Xmonad/Notable_changes_since_0.11#.2AURGENT.2A_Bug_in_0.12_ManageDocks)
11:35:01 <prsteele> geekosaur: ah, I hadn't considered just building from Git. I can do that
11:35:44 <geekosaur> (we're working on 0.13 release)
11:35:44 <geekosaur> you will also need the X11 bindings from git
11:35:56 <prsteele> if I build from Git, will xmonad --recompile use the ghc I installed it with, or whatever ghc is on my PATH?
11:36:43 <geekosaur> the latter
11:36:50 <prsteele> wonderful, thanks
11:36:59 <geekosaur> unless you set up a build script (new in git / upcoming 0.13)
11:37:35 <geekosaur> ~/.xmonad/build will be run if it exists and is executable, instead of the built-in ghc invocation; this allows you to customize the build environment, including using cabal/stack sandbox if preferred
11:37:49 <glguy> you should basically never need to delete your .cabal
11:38:03 <prsteele> geekosaur: thanks, that sounds useful
11:38:18 <cocreature> glguy: unless you use cabal new-build :)
11:38:24 <glguy> doing that just causes you to lose your settings and cache
11:38:49 <glguy> no, you wouldn't want to then either, possibly a subdirectory of it
11:39:52 <cocreature> fair enough
11:40:44 <prsteele> this is getting further afield, but how would I instruct cabal to use a locally available source repo, rather than what is available on hackage? In this case getting xmonad to build with the git version of xmonad-contrib
11:41:26 <geekosaur> don't specify a package name, run in the directory with the cabal file
11:42:00 <geekosaur> e.g. cd xmonad; cabal install
11:42:43 <prsteele> geekosaur: thanks!
11:52:58 <stobix> ...how does sequenceA work? I can't think of a single use case - which probably mean I lack some basic understanding. Again. :)
11:53:10 <mniip> you can also 'cabal install xmonad/xmonad.cabal'
11:54:00 <Tuplanolla> :t sequenceA [print 42, print 13] -- How about this, stobix?
11:54:01 <lambdabot> IO [()]
11:54:06 <prsteele> mniip: thanks!
11:55:27 <Tuplanolla> The usefulness is more apparent when those actions return something, stobix.
11:57:02 <prsteele> wow, and ~/.cabal/xmonad --replace even worked, overriding my system-wide xmonad. Thanks everyone!
11:59:19 <stobix> Tuplanolla: Hm. Yeah, I kinda get what it does now. Now I just need to get why it has that type.
12:00:20 <stobix> > [Just 3, Just 4]
12:00:20 <lambdabot>  [Just 3,Just 4]
12:00:20 <stobix> eh, thinko
12:00:20 <stobix> > sequenceA [Just 3, Just 4]
12:00:20 <lambdabot>  Just [3,4]
12:07:00 <stobix> > fmap sequenceA [[Just 3, Just 4],[Just 3,Nothing] -- So, like this, I guess...
12:07:03 <lambdabot>  <hint>:1:79: error:
12:07:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:07:11 <stobix> > fmap sequenceA [[Just 3, Just 4],[Just 3,Nothing]] -- So, like this, I guess...
12:07:14 <lambdabot>  [Just [3,4],Nothing]
12:07:21 * stobix thinks he gets some of it
12:08:19 <gamegoblin> Is there any reason why the methods like `lookup` in Data.Map couldn’t be generalized to use some arbitrary MonadPlus rather than Maybe?
12:08:38 <gamegoblin> e.g. lookup :: MonadPlus m => k -> Map k v -> m v
12:08:53 <gamegoblin> rather than lookup :: k -> Map k v -> Maybe v
12:09:10 <Gurkenglas> Nope, except, as always, a steeper learning curve
12:09:30 <gamegoblin> true
12:09:59 <gamegoblin> wish there was a way to use the more generic one if you want but have the docs still give the Maybe example
12:10:37 <Gurkenglas> Yeah, was just about to say something like that... a haddock viewer that remembers what language feature's you've learned, and specializes classes to what you know until then
12:10:38 <hpc> plus the question of if MonadPlus is the right thing for it
12:10:46 <cocreature> MonadPlus also seems kind of arbitrary
12:11:04 <hpc> for instance, m = Set is perfectly valid here
12:11:24 <gamegoblin> Just some generic class that can represent failure a la Maybe
12:11:31 <Gurkenglas> It would obviously only be MonadPlus until the reader learns about Alternative, and then until the reader learns about Alt
12:12:30 <geekosaur> ob https://downloads.haskell.org/~ghc/6.6.1/docs/html/libraries/base/Data-Map.html#v%3Alookup
12:14:13 <hpc> there's a blast from the past
12:15:31 <Gurkenglas> The lens docs would start out beginner-friendly and hide a cascade of arcane levels of knowledge
12:15:46 <Gurkenglas> Only ekmett would know whether there's some other secret you haven't unlocked yet
12:16:11 <Gurkenglas> While he works at embedding a fractal of category-theoretical concepts into the cascade so he can join us in exploring the unknown
12:17:33 <gamegoblin> I like the way Pipes has a bunch of beginner friendly type aliases to hide some of the voodoo initially
12:17:52 <hpc> what if instead, it showed things just slightly more complicatedly than you are comfortable with?
12:17:58 <hpc> the evil haddock viewer
12:18:37 <Gurkenglas> Of course none of this makes sense until ghc also only names known concepts
12:18:57 <hpc> and the documentation itself too, which is just typed in comments
12:19:10 <hpc> we need a haddock edsl that can express all of english in a way ghc can control
12:19:31 <Gurkenglas> Would it be as theoretically easy as making ghc resolve as few type aliases as possible while unifying?
12:21:53 <cocreature> hindent prints quasiquotes as "[$ident|body]", i.e, it adds a $. in my code this results in a parse error. is this valid syntax in some cases or is hindent just broken?
12:23:05 <cocreature> haskell-src-exts mentions this $ all over the place but I can’t find it anywhere
12:23:09 <Gurkenglas> I think that has something to do with Template Haskell
12:23:31 <Gurkenglas> Try to activate it and see whether all parses?
12:23:35 <lpaste> alexashka pasted “No title” at http://lpaste.net/351028
12:24:04 <alexashka> hi guys - I'm trying to do some basic things and I'm having no luck, can someone take a look at the pastebin link I posted?
12:24:29 <cocreature> Gurkenglas: template haskell is already enabled
12:24:36 <cocreature> as is QuasiQuotes
12:24:54 <alexashka> what I'm trying to accomplish is have a generic function for multiple models, that takes an action, a model and performs a DB query, returning different types of results
12:25:34 <alexashka> I can get it to work just fine if I restrict the return type to be static, but I'd like it to be able to return different things, sometimes it returns a row id, other times a list of items,  other times nothing at all
12:28:41 <geekosaur> alexashka, Haskell doesn't really work like that
12:29:15 <alexashka> @geekosaur that's the impression that I'm getting as well - so what's the haskell way of approaching this?
12:29:15 <lambdabot> Unknown command, try @list
12:30:33 <geekosaur> for a typeclass setup like that, you need b to be part of the typeclass (which requires an extension MultiParamTypeClasses, and in turn you will need to specify types everywhere unless you use either type families or functional dependencies --- and for what you are trying to do, both prevent what you want to do)
12:31:18 <geekosaur> general polymorphism has the problem (for what you are trying to do) that (a) it's the caller that specifies (b) you can't check what type is wanted, unless you use a typeclass
12:33:07 <geekosaur> in general we just use a different function for each possible return; it's generally easier, and often you end up wanting that anyway.
12:33:07 <geekosaur> sometimes we hide this by using a record of functions, although that doesn't seem very applicable here either
12:33:07 <trepta> hi everyone
12:33:09 <trepta> i was wondering if there is already a function like this one
12:33:12 <trepta> foo :: Bool -> Maybe ()
12:33:14 <trepta> foo b = if b then return () else Nothing
12:33:53 <taktoa> `guard`, maybe?
12:33:55 <taktoa> :t guard
12:33:57 <lambdabot> Alternative f => Bool -> f ()
12:34:27 <trepta> yep 
12:34:33 <trepta> thanks taktoa :)
12:34:36 <taktoa> np
12:35:15 <alexashka> geekosaur: right, so just sticking with good old functions it sounds like
12:35:53 <taktoa> does anyone know what the most kosher way is to output a ByteString in an aeson Value?
12:36:25 <taktoa> obviously I can do Data.Text.Encode.decodeUtf8 and then use the ToJSON Text instance
12:36:29 <geekosaur> ByteString doesn't really map to anything JSON. what does the other side expect?
12:36:33 <Unode> hi all, I'm trying to write a small haskell program that launches a command via ssh and performs two-way communication with it via stdin/stdout. Are there any haskell libraries that may facilitate this task?
12:36:44 <puregreen> taktoa: if it can contain literally anything, I'd use base64, I guess
12:37:42 <geekosaur> Unode, http://hackage.haskell.org/package/posix-pty ?
12:38:13 <taktoa> geekosaur: well, the bytestring is coming out of a grep-like command (I am working on https://github.com/awgn/cgrep), and the output of grep is morally a bytestring
12:38:29 <taktoa> but I need to serialize it out to json
12:38:42 <Unode> geekosaur: I'm new at haskell so yeah, seems like this may help. I'll have a look. Thanks
12:38:55 <taktoa> base64 isn't really an option; it needs to be remotely human-readable
12:39:40 <taktoa> what I really want is something like "\uXXXX\uXXXX\uXXXX..." with exceptions for ASCII maybe
12:39:56 <geekosaur> mm, I would not consider that morally a ByteString; morally it is text with an encoding associated with it
12:40:01 <taktoa> geekosaur: you can grep a binary file
12:40:07 <taktoa> you can grep anything
12:40:16 <puregreen> if “with exceptions for ASCII”, then just `show` and `readMaybe` will do
12:40:38 <geekosaur> but cgrep specifically provides features for source code
12:40:53 <geekosaur> you could use it for a binary file, in the same way you can use a hammer to drive in a screw
12:41:12 <taktoa> I agree, but I didn't write cgrep, and it already uses BS everywhere
12:41:17 <geekosaur> (and, if you really want to do that, there is always LANG=C)
12:42:07 <Unode> geekosaur: hum, I don't think I need the full scope of a pty. I was thinking more like handling stdin/stdout as a network socket. I.e. no need to worry about terminal dimensions or anything of the sort.
12:42:15 <ph88> how can i write this in applicative style? https://paste.fedoraproject.org/523078/08088148/ i know how to do it with one field in the data type but not with two
12:42:23 <ph88> maybe i need to use <*>  ??
12:42:46 <geekosaur> Unode, in that case just use normal file primitives (and probably make sure the handles are set NoBuffering)
12:42:54 <ph88> arbitrary = DU <$> a1 <*> a2   does that make sense ?
12:43:07 <geekosaur> usually if you need anything beyond the primitives it's because you need a pty
12:43:19 <Unode> geekosaur: I see
12:43:21 <geekosaur> er, primitives is the wrong word. standard I/O library
12:43:45 <taktoa> what started this yak-shave off was me using `cgrep --json`, piping it into `jq '.'`, jq complains about the syntax, I notice that it is incorrectly escaping source code fragments, I read the source and realize that cgrep rolled its own JSON serialization, and now I am fixing that fact
12:44:17 <geekosaur> if you mean the match/respond aspect of expect, that's usually troublesome without a pty anyway (which is why expect-type libraries default to using ptys)
12:44:50 <taktoa> so naturally the question of "how do I write a function of type ByteString -> Value" for this particular use is something that requires a bit of thought
12:45:08 <Unode> Well the initial design was to actually use a network socket, but given the subprocess is to be spawned via ssh and kept under control of the parent, communicating via stdin/stdout seemed reasonable. Just wondering if some haskell module implemented something of the sort. I'd assume this sort of network based communication is common.
12:45:20 <Unode> geekosaur: thanks
12:45:37 <geekosaur> usually for this case, either the data format is designed for programs to use or it's interactive and you need a pty and expect
12:46:12 <geekosaur> taktoa, JSON is your enemy here; it's UTF-8, and if you are serious about using it for binary or for non-UTF-8 encodings, you are in a world of pain
12:46:42 <Unode> geekosaur: in this case I'm creating both programs (master and slave) so the communication system/protocol is entirely up to me.
12:46:51 <geekosaur> sounds like cgrep took the usual path (ignore it and a fairy will appear out of thin air and somehow make it all work) but JSON doesn't play that way
12:46:55 <Unode> still brainstorming about it though.
12:47:26 <Unode> I know how to do this in other languages (python) but I'm taking the exercise to learn more about Haskell.
12:47:35 <geekosaur> then you don't really need expect, just a decent packetized data protocol
12:47:59 <geekosaur> attoparsec or binary/cereal would be approaches for that, each with its own strengths and weaknesses
12:49:31 <Unode> I take it these are asynchronous by definition? plenty to read thanks
12:49:39 <taktoa> geekosaur: I mean, the impetus for using JSON here is not really correctness; it's interoperability and ease of use, so I'm okay with inefficiencies like using 5 bytes of escape sequence per 2 bytes of actual data
12:50:30 <geekosaur> Unode, they're not /per se/ but if you plumb them with conduits/pipes they can be
12:51:11 <gcolpitts> :quit
12:51:23 <gcolpitts> :quit
12:51:25 <gcolpitts> exit
12:51:50 <johnw> you're in the #haskell monad, there is no leaving
12:51:52 <geekosaur> taktoa, in that case I'd probably roll a custom one that sends 0x20-0x7e literally and maps everything else to \xXX, with the understanding that the encoded value is bytes
12:51:59 <Unode> :)
12:52:23 <geekosaur> liftIO exitChannel -- :p
12:52:30 <Unode> johnw: it's what you get for using IRC inside Emacs :)
12:52:43 <taktoa> geekosaur: thanks for the advice, I'll do that
12:52:55 <johnw> geekosaur: I didn't say we were a transformer
12:58:37 <ertes> Cale: sounds like a problem 'diff' may have solved already…  at least to some extent =)
13:07:04 <gamegoblin> Is there an extension that would let me do equality matching in patterns? e.g. I want to do something like "match lists where the first two elements are equal" by doing (x:x:xs)
13:07:52 <kadoban> Why not just use a guard?
13:08:14 <glguy> gamegoblin: No.
13:08:20 <gamegoblin> kadoban: That’s what I’m currently doing, but in my particular case a pattern match would be pretty nice looking
13:18:20 <ph88> how can i make an Arbitrary that generates a list of at least 1 item ?   to test a parser that uses the  some  combinator
13:21:16 <ertes> @check \(xs :: [()]) -> not (null xs) ==> length xs > 1
13:21:26 <lambdabot>  <unknown>.hs: 1: 15:ScopedTypeVariables language extension is not enabled. P...
13:21:30 <ertes> @check \xs -> not (null (xs :: [()])) ==> length xs > 1
13:21:33 <lambdabot>  error:
13:21:33 <lambdabot>  • No instance for (STestable Int) arising from a use of ‘==>’ • In the first...
13:21:48 <ertes> @check \xs -> not (null (xs :: [()])) ==> (length xs >= 1)
13:21:51 <lambdabot>  +++ OK, passed 100 tests.
13:21:56 <ertes> ph88: ^
13:24:06 <ph88> never seen ==> before
13:24:49 <MarcelineVQ> alternatively listOf1 is a default generator combinator in QuickCheck
13:25:50 <kadoban> Ya, ==> is pretty useful. Alternatively, you can probably use something like NonEmpty too, depending on exactly how you're using it.
13:27:02 <ertes> there is one thing i find a bit worrying about (==>) though
13:27:21 <ertes> @check False ==> False
13:27:25 <lambdabot>  *** Gave up! Passed only 0 tests.
13:27:28 <ertes> ah
13:27:52 <ertes> @check \x -> let _ = x :: Int in False ==> False
13:27:54 <lambdabot>  *** Gave up! Passed only 0 tests.
13:28:33 <ertes> so if the premise doesn't hold, it doesn't count as a passed test
13:29:09 <ertes> that's reasonable then
13:31:24 <ph88> i was using listOf1 elsewhere in my code, but i forgot about it ^^
13:32:18 <ph88> a short for   listOf1 arbitrary   would be nice
13:34:29 <ph88> i'm using a pretty printer which can concatenate Doc  with hcat  so i think it works similarly to concat and i notice i use  concat $ map a b  quite often. So i ask lambdabot
13:34:32 <ph88> @pl \a b -> concat $ map a b
13:34:32 <lambdabot> (=<<)
13:34:42 <ph88> anyone mind explaining why this is bind left ?
13:35:02 <ph88> i don't think it's gonna replace  hcat  .. or is it ?
13:36:01 <twanvl> for lists, concatMap is the same as (=<<)
13:37:00 <twanvl> @pl \a b -> hcat $ map a b
13:37:00 <lambdabot> (hcat .) . map
13:37:34 <monochrom> @type \a b -> hcat (map a b)
13:37:35 <lambdabot> (a -> Doc) -> [a] -> Doc
13:37:36 <ReinH> :t concat
13:37:38 <lambdabot> Foldable t => t [a] -> [a]
13:37:50 <ReinH> :t concat `asAppliedTo` [[()]]
13:37:51 <lambdabot> [[()]] -> [()]
13:37:55 <ReinH> :t join
13:37:57 <lambdabot> Monad m => m (m a) -> m a
13:38:10 <ReinH> concat is to join as map is to fmap
13:38:41 <ReinH> ph88: ^
13:38:53 <ReinH> :t join `asAppliedTo` [[()]]
13:38:55 <lambdabot> [[()]] -> [()]
13:39:37 <ReinH> (=<<) is a combination of join and fmap, concatMap is a combination of concat and map.
13:41:30 <ph88> oh didn't know about join ^^
13:42:59 <ReinH> > let triple = \() -> [(),(),()] in concat (map triple [(),(),()])
13:43:02 <lambdabot>  [(),(),(),(),(),(),(),(),()]
13:43:13 <ReinH> > let triple = \() -> [(),(),()] in join (fmap triple [(),(),()])
13:43:15 <lambdabot>  [(),(),(),(),(),(),(),(),()]
13:43:26 <ReinH> > let triple = \() -> [(),(),()] in triple =<< [(),(),()]
13:43:28 <lambdabot>  [(),(),(),(),(),(),(),(),()]
13:43:41 <ReinH> ph88: these are equivalent
13:44:22 <ReinH> > let triple = \() -> [(),(),()] in triple `concatMap` [(),(),()]
13:44:25 <lambdabot>  [(),(),(),(),(),(),(),(),()]
13:44:53 <ph88> cool
13:58:47 <haskell403> what is the constrain to say that a type variable "val" is of kind * ?
13:59:25 <lyxia> (val :: *) ?
14:00:01 <lyxia> Maybe you can write (k ~ *) where k is the kind of val.
14:01:19 <monochrom> Perhaps don't say it with a constraint, say it with a kind signature.
14:11:23 <epeme> hello, how do I force re evaluation of a function? GHC is optimizing this stuff away and wan't to execute it again for benchmarking purposes
14:11:32 <epeme> say I'm doing "f 50" 
14:11:52 <ertes> epeme: GHC does not memoise functions
14:12:05 <ertes> it only does sharing: not reevaluating things that have a name
14:12:24 <ertes> f x + f x  -- evaluated twice (in general)
14:12:29 <epeme> okay
14:12:32 <ertes> let y = f x in y + y  -- evaluated once
14:12:43 <ertes> @package criterion
14:12:43 <lambdabot> http://hackage.haskell.org/package/criterion
14:12:45 <ertes> epeme: ^
14:13:01 <monochrom> Still, it will skip evaluation when you want evaluation, and it will do evaluation when you least expect evaluation, and generally it foils all your benchmarking attempts.
14:13:14 <monochrom> And this is why you need the criterion library.
14:13:54 <epeme> ok im kinda lazy atm, how fast is it to actual get going with that lib? i'm doing really simple benchmarking here
14:14:21 <ertes> epeme: use defaultMain together with 'bench' and 'nf' or 'whnf', and you're already going
14:14:23 <MarcelineVQ> pretty darn fast
14:14:35 <monochrom> Oh, I haven't done that meta-benchmark :)
14:14:42 <epeme> :P
14:15:12 <epeme> in any case, here's the script. the thing is it's returning inmediately on the parallelized call while it wasn't doing this when this stuff was in a different module http://ideone.com/NHvnX9
14:17:23 <epeme> i tried compiling with -O0 and the calculations became kind of.. never ending on this machine
14:30:16 <unclechu> hey guys, I have my own `newtype` container with determined type that has kind `*`, like this `newtype MyState = MyState Int deriving (Show, Eq)` I want to apply some functions to it, like by `fmap` but to describe instance of `Functor` typeclass I must have kind `* -> *`, it there any alternative typeclass? or maybe i don't understand something?
14:32:45 <monochrom> You don't need fmap or a typeclass for this.
14:33:07 <Koterpillar> unclechu: what type would "fmap show" have?
14:34:10 <kuribas> unclechu: use a lens maybe?
14:34:13 <unclechu> monochrom: for example I have function like this: `(+ 5)`, how I can apply it to `MyState` value?
14:34:54 <unclechu> kuribas: I could, I thought may be there's another solutions for that, lens is ok for me
14:35:01 <monochrom> You don't know how to code that up?
14:35:16 <Koterpillar> can Hoogle search for a typeclass?
14:35:33 <Gurkenglas> "\(MyState x) -> 5 + x", or, using Data.Coercible, coerce (+ 5)
14:35:51 <unclechu> monochrom: I know, I could just write my own function like this: `myStateApply f (MyState x) = MyState $ f x`
14:36:12 <monochrom> Do that.
14:36:40 <unclechu> but I want more elegant solution
14:36:40 <Gurkenglas> Or using Control.Lens.Wrapped, _Wrapping MyState %~ (+ 5)
14:36:40 <Liskni_si> or deriving Num
14:36:40 <unclechu> Gurkenglas: lens is a lot better for me
14:36:40 <kuribas> unclechu: newtype MyState = MyState {_getState :: Int}; over getState (+5)
14:36:40 <Gurkenglas> (You'll have to use Control.Lens.TH's makeWrapped on MyState once, though)
14:37:06 <Koterpillar> unclechu: if you want to use MyState as an Int, just declare type MyState = Int
14:37:13 <Koterpillar> unclechu: declaring newtype is intentionally making it harder to cast to/from the underlying type
14:37:42 <monochrom> I do not know of a more elegant way. My idea of "elegant" anyway. And that's right, despite I know of lens and even coerce.
14:37:42 <unclechu> Koterpillar: I know, but I want to use `newtype` to prevent some mess with accident types compatible with wrong values
14:37:53 <Koterpillar> unclechu: then define a lens or something of type (Int -> Int) -> MyState -> MyState
14:38:25 <Koterpillar> unclechu: so that its use is explicit
14:38:30 <kuribas> unclechu: or define Num typeclass over MyState?
14:38:41 <Koterpillar> unclechu: I'd say defining a Functor or some other typeclass just adds to the mess
14:39:11 <kuribas> I wonder if Num works with generalizedNewtypeDeriving.
14:39:57 <Gurkenglas> afaik it works with even user-defined classes
14:40:14 <unclechu> I think I'll choose lens way, thanks for advice
14:44:44 <epeme> ok, using criterion didn't help at all
14:45:18 <epeme> and jesus do i curse when i have to build 30 dependency packages on this dual core.. takes ages
14:49:23 <davean> epeme: are you using new-build?
14:49:51 <epeme> i dont know what that is
14:49:56 <kuribas> unclechu: you don't even need to use the lens library to define a lens.
14:52:08 <kuribas> unclechu: "myStateLens f (MyState x) = MyState <$> f x"
14:55:04 <MarcelineVQ> epeme: what's the issue?
14:55:16 <MarcelineVQ> with your tests I mean
14:56:39 <epeme> it seems to be reusing results from different benchmarks
15:14:03 <MarcelineVQ> epeme: possibly it's just ghci. what happens if you do the tests twice in a row in main?
15:14:37 <epeme> im running the tests from the binaries
15:14:58 <epeme> i "solved" it by duplicating the computation heavy function and putting a prime at the end
15:17:08 <epeme> even then im getting strange results depending on the order of the function calls..
15:17:45 <epeme> oh well
15:17:52 <epeme> thanks for the help anyways, g2g
15:25:22 <dmj`> does anyone know what the name of that tool is, the one that shows a graphic of how all your modules are related based on their imports
15:28:25 <MarcelineVQ> graphmod perhaps
15:32:23 <Unode> dmj`: dot plots?
15:32:51 <Unode> part of graphviz
15:34:55 <unclechu> kuribas: I used `Control.Lens.Wrapped` and described instances of `Rewrapped` and `Wrapped` typeclasses and now I can modify my value like this: `over _Wrapped (+ 10)` or `_Wrapped %~ (+ 10)`
15:35:47 <MitchellSalad> hello all, I want to replace all occurrences of "&gt;" with ">" in a Text, can anyone recommend any regex or text manipulation libraries to do so?
15:36:31 <Welkin> 1620, is that a new record?
15:36:38 <Gurkenglas> unclechu, or "_Wrapping MyState" instead of "_Wrapped" if you want to make explicit which wrap you're using, and you don't need to describe those yourself if you use Control.Lens.TH's makeWrapped
15:37:26 <Gurkenglas> MitchellSalad, http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#v:replace
15:38:27 <MitchellSalad> oh... thanks!
15:39:49 <j0b> anyone in here who are pretty fluent in both haskell and python3 ?
15:39:56 <j0b> have a job for you, good pay.
15:40:02 <unclechu> Gurkenglas: thanks for advice!
15:40:13 <j0b> basically convert a bit of haskell into python
15:40:26 <Koterpillar> j0b: that's the opposite of creating nice things
15:40:37 <j0b> hehe
15:40:47 <j0b> well im paying for it so:p
15:44:47 <j0b> its 264 lines of haskell that needs to be convert into python3 :)
15:44:53 <j0b> thats it.
15:45:06 <j0b> will pay for it of course.
15:45:40 <EvanR> half now half later...?
15:46:24 <j0b> EvanR: we can talk about that in pm
15:46:33 <EvanR> nah
15:46:36 <EvanR> just curious
15:48:34 <johnw> has anyone else written a shake module for working with Docker?
15:58:18 <dmj`> Unode: hmmm, maybe
15:59:03 <johnw> dmj`: only somewhat
15:59:11 <johnw> I don't want a shake recipe for building Docker images
15:59:20 <glguy> Unode: http://hackage.haskell.org/package/graphmod
15:59:23 <johnw> I want shake entities for including Docker artefacts in a build system
15:59:32 <johnw> like dockerImage "foo" ~> ....
15:59:40 <johnw> which creates a dependency on the given docker image, etc.
15:59:42 <glguy> errr, dmj`
16:00:12 <dmj`> glguy: ooo :) very nice
16:00:39 <johnw> and how to build that image should be done via the Docker API, not shelling out to "docker build"
16:01:34 <johnw> dmj`: here's where I started: https://gist.github.com/jwiegley/02891616d62c3af26d0ed57c323c9237
16:01:45 <johnw> i just wanted to check if maybe someone here had already beat me to it
16:02:02 <Unode> glguy: I see
16:15:14 <ReinH> johnw: o/
16:30:29 <elrikdante> Hi all; I'm trying to solve this challenge and I've applied all the top of mind optimisations.  I'm still getting timeouts.  Is there anything glaringly obviious I'm missing here?  https://github.com/elrikdante/hacker-rank-hs/blob/master/httpsZZZwwwZhackerrankZcomZchallengesZarrayZsplitting.hs -- challenge: https://www.hackerrank.com/challenges/array-splitting
16:31:25 <elrikdante> as is my implementation only passed 1/12 test cases.
16:33:37 <agent_sm1th> what challenge?
16:33:58 <agent_sm1th> can you post a link?
16:34:09 <elrikdante> yeah its above challenge: https://www.hackerrank.com/challenges/array-splitting
16:34:38 <agent_sm1th> you're using ! a lot, that's usually a bad sign
16:35:00 <elrikdante> shouldn't I be getting O(1) acess?
16:35:05 <agent_sm1th> noooo
16:35:11 <elrikdante> =P
16:35:13 <elrikdante> =O *
16:35:19 <elrikdante> whaat?
16:35:23 <agent_sm1th> it's O(N) worst case, it has to traverse the whole list
16:35:30 <elrikdante> I'm using a vector
16:35:39 <elrikdante> I switched from Linked List for that reason
16:35:43 <elrikdante> but it didn't help
16:36:15 <elrikdante> then I tried caching the sums but that didn't seem to matter much either
16:39:56 <monochrom> Vector's (!) is O(1) time alright.
16:40:01 <agent_sm1th> yes yes
16:40:03 <agent_sm1th> my mistake
16:40:37 <agent_sm1th> I've never used vectors with Haskell :P
16:41:09 <agent_sm1th> OK I just read the problem
16:41:50 <agent_sm1th> And I don't think you should use vectors, but, let me think for a couple of minutes
16:42:00 <monochrom> I am unconvinced of the correctness of this algorithm to begin with. There may be multiple ways to split an array, each way leading to different final scores.
16:42:17 <agent_sm1th> yeah you need to find the maximum one
16:42:49 <monochrom> A correct brute-force approach is going to be exponential time.
16:43:24 <elrikdante> I wanted to encode it as a binary search tree, but I thought i'd give it  a shot using two shifting cursors and left and right accumulating vectors.
16:43:46 <monochrom> I don't see how binary search tree helps.
16:44:01 <monochrom> I would try dynamic programming.
16:44:14 <elrikdante> when I wrote out the transforms by hand it makes one, the discussion also says DP won't help much
16:44:58 <elrikdante> the partitions need to be continuos.  they don't change the order of the elements.  theres plenty complaints about the wording of the problem.
16:45:13 <elrikdante> https://www.hackerrank.com/challenges/array-splitting/forum
16:45:21 <agent_sm1th> > contiguous
16:45:24 <lambdabot>  error: Variable not in scope: contiguous
16:45:48 <elrikdante> ^ yes that =)
16:46:18 <monochrom> I saw "contiguous" in the problem statement already.
16:47:00 <agent_sm1th> > foldr (+) 0 [1..]
16:47:02 <lambdabot>  *Exception: stack overflow
16:47:12 <agent_sm1th> should return -1/12, filing a bug report
16:47:36 <monochrom> But you will have a type error.
16:47:50 <agent_sm1th> I'll let them figure that out
16:48:02 <monochrom> Type inference says you get an Integer but -1/12 has trouble fitting in.
16:48:28 <agent_sm1th> I disagree
16:48:31 <monochrom> The conclusion is that you probably want the bug report to be against Haskell 2010 itself.
16:48:50 <agent_sm1th> These are Nums right
16:49:04 <agent_sm1th> > :t foldr (+) 0 [1..]
16:49:06 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:49:15 <agent_sm1th> foldr (+) 0 [1..] :: (Num b, Enum b) => b
16:49:19 <agent_sm1th> Enum
16:49:28 <agent_sm1th> Yeah
16:49:31 <agent_sm1th> It's fine
16:50:00 <monochrom> The semantics of parametric polymorphism is the opposite of what you think.
16:50:25 <monochrom> The type "Num b => b" (for a simpler example) means that the user, me, gets to choose what I like for b.
16:50:33 <monochrom> And I like Integer.
16:51:24 <monochrom> Whereas you were thinking that the provider, who liked to provide -1/12, had the liberty to choose Rational for example.
16:51:37 <monochrom> But no, the liberty is on my user side, not on the provider's side.
16:51:45 <agent_sm1th> I'm going to propose getting rid of Integer then.
16:52:01 <monochrom> Yes, <monochrom> The conclusion is that you probably want the bug report to be against Haskell 2010 itself.
16:53:47 <monochrom> My freedom is your slavery. Your ignorance is my strength.
16:54:29 <jle`> agent_sm1th: it would probably only make sense to be -1/12 as a limit
16:54:33 <jle`> but [1..] doesn't compute limits
16:54:44 <jle`> er i mean, it doesn't denote limits
16:55:03 <monochrom> Ah, but it is the other limit, to muddle the water further :)
16:55:40 <monochrom> I still haven't written my much-wanted denotational tutorial. Donations welcome.
16:58:14 <ReinH> monochrom: how do I donate?
16:58:48 <monochrom> Ah, I haven't set that up, eh?
16:59:05 <EvanR> donational semantics
16:59:24 <monochrom> Oh w00t have you heard of "detonational semantics?"
16:59:34 <EvanR> haha
16:59:52 <monochrom> Let me see if gmane works so I can find you that haskell-cafe post
17:01:03 <monochrom> no, it still doesn't work.
17:01:23 <monochrom> Now let me see if mailarchive is searchable at all
17:02:19 <monochrom> https://www.mail-archive.com/haskell-cafe@haskell.org/msg86241.html
17:04:37 <ReinH> That's pretty great.
17:05:17 <ReinH> I like "looking glass semantics".
17:09:55 <ertes> elrikdante: vectors have O(1) splitting and O(1) indexing, should you decide to use them
17:10:02 <ertes> elrikdante: see 'slice'
17:10:19 <EvanR> vectors are the shit
17:10:42 <ertes> elrikdante: however, cons and snoc are super-expensive, so avoid those
17:11:28 <EvanR> you could implement vectors with extra space so cons and snoc are amortized O(1)
17:11:48 <EvanR> but it would take more memory
17:12:10 <ertes> i think if you need those operations, you should use a rope data structure instead of a raw vector
17:12:21 <EvanR> for some reason i hate ropes
17:12:26 <ertes> then "defragment" the rope from time to time to recover the speed of vectors
17:12:40 <EvanR> hashmapped trie seems to work fine for this
17:12:48 <ertes> i love them…  they are in a sense the perfect finite sequence data structure
17:12:54 <EvanR> hash array-mapped trie
17:13:17 * EvanR slips and falls into a netsplit
17:17:10 <gamegoblin> are there any major libs coded using arrows?
17:18:13 <ertes> gamegoblin: hxt (non-sensical), optparse-applicative (optional), wires (required)
17:18:25 <ertes> with the usage of arrows in parentheses
17:19:06 <monochrom> How dare you hurt my feeling by saying that hxt's usage is non-sensical!
17:19:15 <monochrom> But carry on, you're right :)
17:19:23 <ertes> sorry =)
17:19:45 <monochrom> It was someone's MSc thesis. (Unrelated to me.)
17:20:40 <monochrom> It means "someone wanted a grad student to explore what would happen. no guarantee it's a good idea, because if we knew for sure either way, we wouldn't need someone to try it"
17:20:55 <ertes> gamegoblin: i also used them in some projects i haven't published
17:21:58 <gamegoblin> ertes: still getting back up to date on the haskell ecosystem — is there still talk of some sort of arrow equivalent to do-notation?
17:22:14 <monochrom> On that tangent of the nature of MSc thesis, there was a time a lot of parallel and/or distributed computing profs were interested in giving you a seems-undistributed API for distributed memory.
17:22:28 <ertes> gamegoblin: the GHC manual has the best explanation i've seen so far
17:22:49 <ertes> gamegoblin: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation
17:23:18 <monochrom> And so a lot of MSC theses were sprung into existence on possible optimizations techniques (in the implementation details of such an API) and how they performed in reality.
17:24:27 <monochrom> And there were a lot of them because each one was "the benchmark shows that our optimization doesn't perform". (It's OK, no one knew until you tried.) And therefore there was always a need for the next thesis to look into another possible optimization.
17:24:29 <ertes> monochrom: well, hxt seems to be an outlier…  the usage of arrows is literally completely pointless…  i could have told them before they even started that it's a bad idea
17:25:53 <monochrom> So anyway the moral is that a lot of MSc theses are "we tried, we found out it fails".
17:27:46 <ertes> i would much prefer to see a redesign of hxt that switches to monads…  but given that we have more powerful approaches now i don't think it would pay off
17:41:46 <elrikdante> thanks ertes: EvanR:
17:41:46 <monochrom> ertes: What are the more powerful approaches?
17:41:57 <elrikdante> ertes: I'm using cons and snoc right now ~_~ I'll look at trie encoding after I improve the performance of the max call.
17:44:21 <EvanR> a funny structure for an array which can cons and snoc and slice fast is IntMap
17:44:36 <EvanR> er, let me make sure you can slice...
17:45:22 <EvanR> yes, split
17:46:22 <EvanR> if you remember what negative Int the "array" starts at, you could wrap it and make an array standin
17:48:22 <shapr> 264 lines of Haskell could difficult to turn into Python3
17:48:46 <shapr> Welkin: are you keeping track of the max number of clients on #haskell?
17:48:49 <dram_phone> Question: is there an easy way to parse Haskell layout *without* parsing code in full? The Haskell Report [1] does not give a way
17:49:06 <dram_phone> (It requires checking for generic parse errors)
17:49:11 <dram_phone> [1] https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
17:51:07 <dram_phone> I'm thinking about an editor extension that shows 'ghost' braces and semicolons in code so you know you got the indents right
17:55:37 <geekosaur> generic parse errors basically means watching for bracketing constructs and semicolons
17:56:49 <geekosaur> I *think* you can do those without full parsing or even full lexing (that is, none of them can be part of a larger token) --- although comments may be a problem
17:56:55 <geekosaur> (note that "bracketing construct" includes String and Char literals though)
17:58:29 <dram_phone> I *think* the authors have something vague in their minds, and someone just said 'they are all parse errors if we allowed them!'
17:58:58 <dram_phone> I'm trying to get the vague parts together...
17:59:21 <Philippa> the thing is, you actually can implement it as originally specced (aside from some ambiguities around fixities) and it Just Works
17:59:32 <Philippa> in practice you need to reparse operator expressions after your main pass anyway
17:59:51 <dram_phone> It's actually something I'm trying to avoid
18:00:22 <dram_phone> *Ideally* a 'small' parse error does not affect the big picture
18:00:25 <EvanR> "reparse" ;_;
18:00:39 <Welkin> lol secret hitler
18:00:43 <Welkin> looks like a fun game
18:01:14 <Philippa> EvanR: parse once as a flat list, then resolve operator precedence and fixity (another parsing activity) once you've had the chance to deal with fixities declared afterwards
18:02:05 <Philippa> dram_phone: so, flatten the whole operator mess down to something in the ballpark of "mixture of variables/applications and operators", keep parens and grammar related to keywords
18:02:22 <dram_phone> uh, ?
18:02:29 * dram_phone is a bit confused
18:02:48 <athan> Is there a standard typeclass for isomorphisms?
18:02:57 <Philippa> dram_phone: you're going to have to handle all the block structures. Things like let, where, case...
18:03:04 <dram_phone> Yeah
18:03:20 <EvanR> makes sense, i guess haskell really errs on the side of human friendly not implementor friendly
18:03:25 <Philippa> you actually /have/ to, because "in" for example is often the cause of a } being inserted
18:03:41 <Philippa> you don't need to deal with most of the structure of expressions that aren't that
18:03:53 <dram_phone> That makes some sense
18:04:09 <Philippa> you can look at "a b + (c d) e - f" and only care about the parens structurally speaking
18:04:10 <EvanR> speaking of implementing, i heard that write yourself a scheme in 48 hours is not compatible with modern ghc ?
18:04:57 <Philippa> I wouldn't be surprised by that given some of the core lib changes
18:04:59 <Philippa> they broke textbooks
18:05:01 <dram_phone> I would really love it if I had the ENTIRE list of 'parse-error's that can occur 'normally'
18:05:21 <Philippa> dram_phone: welcome to tedium :/
18:05:26 <dram_phone> like, as you mentioned, 'in' as in 'let { ... } in'
18:05:51 <Philippa> yeah, so what you can usefully do is look for everywhere } appears in the grammar
18:06:36 <Philippa> because anything meeting the second half of the definition is in one of those places
18:07:05 <Philippa> (I literally wrote the parser that way: I made that the biased-against choice and used parsec to "ask" the layout-lexer if it could have an implicit } if needed)
18:07:40 <Philippa> anyway, gtg for a bit
18:08:03 <dram_phone> Thanks for the information :)
18:10:50 <geekosaur> h'98 was actually ambiguous, someone came up with a legal expression that hugs and ghc both parsed... differently, but both to spec
18:12:06 <dram_phone> I wonder how the GHC people and Hugs people dealt with that rule...
18:12:27 <dram_phone> I mean the 'parse-error' rule
18:15:09 <dram_phone> I guess some parsers can somehow do error recovery by inserting tokens, and in Haskell's case the parser recovered into a perfectly normal state
18:15:27 <baordog> sup all
18:21:11 <geekosaur> the brace insertion rule is probably the most hated by compiler writers everywhere :)
18:22:24 <athan> Hey everyone, can someone see what I'm doing wrong here? http://lpaste.net/351038
18:22:48 <athan> Do i need to hammer my filesystem? :| take that you inode!
18:23:02 <ertes> monochrom: folds, traversals, stream processing, etc., depending on the use case
18:24:19 <ertes> EvanR: compared to vectors IntMap has a *massive* constant factor…  you shouldn't use it, if vectors do everything you need efficiently
18:27:34 <athan> Hmm, using a different stackage snapshot also didn't work: http://lpaste.net/351038
18:48:09 <elrikdante> thanks EvanR: split was a great idea.  no longer paying factorial cost on the recursion; and I'm not accumulating useless copies of the partition vis snoc/cons.  Now I'm getting a stack overflow.  but I'm only one solution away from solving it.
18:48:25 <elrikdante> https://github.com/elrikdante/hacker-rank-hs/blob/master/errata/PANIC6.gif
18:54:31 <EvanR> ertes: well snoc and cons might even be fine with vectors
18:56:10 <EvanR> they might be fine for lists
18:56:26 <shapr> now I want to do hackerrank challenges
18:56:26 <EvanR> we tend to jump straight to certain structures without regard to the size of the problem
18:56:46 <EvanR> for size 10 for instance, doesnt matter what you do
19:18:35 <ertes> EvanR: i never bought that kind of argument…  200 ms vs. 2 ms is still a factor of 100
19:19:10 <ertes> the thing is that i'm pretty sure there is an algorithm that doesn't require cons/snoc and only works by splitting and folding vectors
19:19:18 <ertes> that's probably easier to implement *and* much faster
19:28:28 <dram_phone> There aren't many ways to split, are there?
19:32:25 <EvanR> ertes: updating a vector of size 10 is going to be on par with updating a record
19:34:49 <ertes> dram_phone: take*, drop*, break, span, splitAt, etc…  all of these take O(1) space with vectors
19:35:24 <dram_phone> Uh, I mean 'split' as in the challenge
19:35:58 <ertes> EvanR: that's right, because a record with strict, unboxed fields is pretty much just a vector anyway =)
19:36:14 <ertes> EvanR: however, you still don't get the cheap splitting that vector has
19:36:24 <EvanR> vectors elements are boxed by default
19:36:29 <EvanR> wasnt getting into unboxing
19:36:32 <dram_phone> binary search?
19:36:48 <ertes> EvanR: "by default"?  there isn't really a default
19:37:04 <EvanR> if you import Data.Vector which is what ithought we were talking about
19:37:13 <dram_phone> The code needs a binary search!
19:37:21 <ertes> EvanR: elrikdante was using unboxed vectors
19:37:24 <EvanR> and strict fields is yet something else
19:37:28 <ertes> EvanR: IMO Data.Vector is just unfortunately named
19:37:45 <ertes> EvanR: IMO Data.Vector.Generic should be Data.Vector, and Data.Vector should be Data.Vector.Boxed
19:38:21 <EvanR> the boxed vector is a good default, its consistent with all the other normal data structures
19:38:55 <dram_phone> elrikdante: 'prefix sum', 'binary search'
19:39:00 <dram_phone> does that ring a bell?
19:39:09 <ertes> EvanR: i would agree, but boxed vectors really aren't the default, because there simply is no default
19:39:20 <EvanR> ... 
19:39:32 <EvanR> import Data.Vector gives you something
19:39:39 <EvanR> you dont have to call it a default
19:39:49 <ertes> EvanR: perhaps it's "default" in the same way Data.Map is Data.Map.Lazy
19:39:55 <ertes> which is actually rather unfortunate =)
19:41:12 <ertes> i think i have used boxed vectors exactly once to take advantage of…  what was it called…
19:41:26 <dram_phone> tying the knot?
19:41:28 <ertes> … dynamic programming
19:41:43 <dram_phone> by tying the knot
19:41:47 <ertes> but i ended up switching to unboxed vectors later, because they were vastly faster
19:42:25 <ertes> ah, i've also used them once to keep a vector of Integer
19:42:56 <dram_phone> Um, so 'everyone' is focused on Vectors and no one cares about binary search?
19:43:21 <ertes> dram_phone: actually i've used them exactly for that in the Integer case =)
19:43:26 <ertes> using vector-algorithms
19:43:36 <EvanR> ertes is the only one really talking right now and hes only talking about unboxed vectors
19:43:48 <dram_phone> =)
19:43:56 <EvanR> but there are many structures with many use cases and trade offs
19:44:10 <dram_phone> And this challenge could really use a binary search
19:44:23 * dram_phone is going to say that over and over again. Probably.
19:44:58 <ertes> i don't deny that i like vectors, but that isn't to say that i use them all the time…  in fact (unordered-)containers is a more common dependency for me
19:45:22 <dram_phone> All the numbers are non-negative, so the prefix sum is non-decreasing
19:45:30 <EvanR> the advice "use vectors unless you have a good reason not too" is really kind of anti-haskell
19:46:01 <ertes> EvanR: why?
19:46:14 <EvanR> thats like something youd say in C++
19:46:20 <dram_phone> Because you always have lots of reasons not to?
19:47:06 <EvanR> its not a functional data structure
19:47:17 <ertes> EvanR: i disagree
19:47:27 <EvanR> it doesnt let you write elegant algorithms by pattern match or views
19:47:30 <ertes> by the same logic Data.Sequence wouldn't be functional
19:47:45 <ertes> because they are basically the same thing, but with different efficiency trade-offs
19:47:49 <EvanR> that does have views
19:48:35 <ertes> EvanR: but what if you don't need reassembling?  why use the less efficient data structure for such a subjective reason?
19:49:26 <EvanR> vectors are by far not the most useful data structure available
19:49:32 <dram_phone> But what if a binary search would nail it?
19:49:59 <dram_phone> (If it didn't I guess I need more sleep...)
19:50:07 <ertes> EvanR: example use case (i had this one):  you have a large sequence of values, and you do binary search on it, and nothing else
19:50:57 <EvanR> and it happens to be unboxable
19:51:18 <ertes> not necessarily…  in my use case i needed Integer values
19:51:34 <EvanR> i think vector turns out to be an optimization in a lot of cases, and if youre not lucky you also have to make sacrifices to the generality
19:51:47 <EvanR> and the optimized algorithm is not as nice and short
19:51:58 <ertes> you don't…  i consistently use the .Generic API
19:52:05 <EvanR> i get theres performance to be gained
19:52:45 <EvanR> but general haskellism isnt "make a vector of Int to Word8s and hope you do it right"
19:52:53 * dram_phone assumes that elrikdante is afk and the channel has derailed
19:53:12 <EvanR> or "performance at all costs"
19:53:39 <ertes> the point is not only that there is a performance gain…  the point is: it's *easier* and just a better engineering choice in general…  the point is: your choice of data structure and algorithm are tightly related…  if a vector is the best choice, you should choose it
19:53:59 <ertes> the vector API and vector-algorithms made my life super-easy
19:54:10 <dram_phone> If you don't go for perf when you see 'N <= 2^14 for 100% of test cases'
19:54:55 * dram_phone failed to think of the second half of the sentence
19:55:34 <Algebr> using latest hakyll, have import Hakyll but get :   Not in scope: ‘writerStandalone’ Perhaps you meant ‘readerStandalone’ (imported from Text.Pandoc). Code was working until about a month ago, I API changed ? 
19:55:51 <Algebr> hoping someone familiar with hakyll is around
19:56:29 <Axman6> Algebr: have you checked the haddocks?
19:57:29 <Algebr> no, I'm trying to make code that compiled 2 months ago compile again today
19:57:38 <geekosaur> doesn't look like hakyll, hayoo thinks it's from Text.Pandoc.Options
19:58:16 <geekosaur> ...but current haddock thereof doesn't list it
19:58:27 <ertes> Algebr: are you trying to make a self-contained document instead of a partial one?
19:59:28 <jle`> for what it's worth, looking at the haddocks is a good way to update your code to new versions
19:59:36 <Algebr> I'm trying to make this compile again and getting that scope error on line 142 https://github.com/fxfactorial/hblog/blob/master/hblog.hs
19:59:58 <jle`> if your goal is to make old code work, looking at the haddocks is often helpful
20:00:25 <Algebr> my goal is to get this working just one more time and then I'm leaving hakyll for my own solution in React and node, or OCaml. 
20:01:04 <ertes> Algebr: well, you could go back to an older version of pandoc…  seems like writerStandalone is no longer there
20:01:25 <jle`> it looks like it's the name of a record field of whatever type defaultHakyllWriterOptions is
20:01:48 <Algebr> yea, gonna try lowering the Pandoc constraint. 
20:02:20 <jle`> http://hackage.haskell.org/package/hakyll-4.9.3.0/docs/Hakyll-Web-Pandoc.html#v:defaultHakyllWriterOptions
20:02:20 <ertes> Algebr: go back in major version steps:  try 1.18.*, then 1.17.*, etc.
20:02:33 <jle`> it looks like it's a value of type WriterOptions, which no longer has that field
20:02:41 <jle`> have you tried just not updating that field?
20:02:45 <elrikdante> dram_phone: thanks for the heads up.  not familiar with prefix sum.
20:02:56 <jle`> just removing line 141 altogether?
20:06:13 <jle`> Algebr: looking at the source of hakyll/pandoc, it looks like, yeah, you could just remove the line setting writerStandalone
20:06:18 <jle`> writerStandalone was always ignored anyway
20:08:14 <Algebr> excellent, will try that
20:26:00 <Algebr> nope, removed 141, got this new type error:http://pastebin.com/EdzmQecs
20:30:12 <Algebr> ah actually easy one, needed the option Just constructor
20:41:24 <Algebr> thanks all!
20:41:52 <Algebr> oh out the box didn't cabal install rght either, needed cabal install hakyll --enable-shared --constraint=process==1.4.2.0
21:18:17 <Idris_gt_Adga> Could someone help me figure out why this code using GADTs isn't working?
21:18:18 <Idris_gt_Adga> https://gist.github.com/Shamrock-Frost/961a12e6a3df853b0682a2d333ea9119
21:18:59 <Idris_gt_Adga> I'm getting "RBTree.hs:52:29: error: * Could not deduce: Insert lc ~ RedInsert  from the context: ('Black ~ 'Black, h ~ 'S h1)"
21:19:14 <Idris_gt_Adga> So basically it can't tell lc ~ 'Red
21:21:39 <Idris_gt_Adga> also unrelated, does anyone know any papers describing System FC/Core?
21:23:26 <dfeuer> Idris_gt_Adga: there are a lot of papers. See "OutsideIn(X): Modular type inference with local assumptions" for one that should be fairly relevant.
21:23:49 <dfeuer> ALthough actually that's more about Haskell than Core.
21:23:59 <dfeuer> But it should get you references to other stuff.
21:24:16 <dfeuer> Sorry, a bit sleepy.
21:24:43 <Idris_gt_Adga> it's cool
21:24:59 <Idris_gt_Adga> I have a project which I think will be cool involving core
21:25:22 <Idris_gt_Adga> But I don't want to describe it if it turns out to be beyond my sill
21:25:25 <Idris_gt_Adga> *skill
21:31:39 <glguy> Idris_gt_Adga: The 'l' bound on line 48 has an unknown color
21:32:04 <glguy> so then if you use it with insertN on line 49, the result of that functino application has an unknown type
21:33:37 <glguy> Idris_gt_Adga: The first two and last two patterns in lines 50 - 53 don't even all have the same type
21:35:11 <dfeuer> Blast. glguy beat me to the answer agan.
21:35:13 <dfeuer> again.
21:35:35 <dfeuer> I was just coming back to mention the same thing about l, but he is way faster as always.
21:35:43 <Idris_gt_Adga> I think I get it
21:35:53 <Idris_gt_Adga> Sorry, I'm not used to working with dependent types/GADTs
21:36:26 <Idris_gt_Adga> I started with a sum type over the Insert types and thought I could make it into a type family
22:06:09 <J_Go_Do> #machinelearning
22:20:48 <shayan_> Anyone here using Haskell for Mac? Is it worth the $35?
22:22:31 <Axman6> I think it's very good, and Manual's a great guy who's put in a huge amount of work for it, but I don't use it often because I'm building more traditional applications rather than needing an interractive platform to experiment. The times I have used it I was very impressed though (you should see Manuel's talk from Compose conf in Melbourne last year to get an idea of its power)
22:24:40 <shayan_> Axman6: What do you mean you are building more traditional applications? Can’t you build any-kind of application on that IDE? or it it only available/capable for specific projects?
22:27:25 <Axman6> it's more of a playground kind of thing than something designed for working with a repo of code you might have from elsewhere, but that might have changed
22:29:56 <Axman6> I wouldn't describe it as an IDE
22:31:12 <shayan_> Ah okay
22:31:27 <glguy> shayan_: Haskell for Mac is a sort of "workbook". Stuff you make in it is intended to stay in it
22:31:52 <Axman6> it's extremely good for experimenting with ideas, since it allows you to change previous values and later values which rely on them will also update
22:32:25 <Axman6> it's very much like iPython/Jupyter, but in some ways much more powerful
22:32:57 <shayan_> interesting
22:33:11 <Axman6> I used it to debug some crypto code I was working on and the ability to keep a sort of recipe of code I was expecting to work while editing the source was a godsend
22:34:58 <shayan_> In the conference talk, does he talk about the environment? My fear is that it’s a limited application since you cannot export/import code?
22:35:53 <Axman6> you can always export the code, but it's not stored in a git repo (it tries to make things a lot easier for the user, and also has to fight some of the restrictions of the App Store)
22:37:57 <jle`> i'm teaching an introduction to programming class and i'm describing imperative programming, and i am trying to plan a section i  call "The Curse of State"
22:38:22 <jle`> my goal was "here are the advantages, and here is the cost we pay"
22:38:33 <jle`> i thought it was a good idea, but i'm struggling now to think of the advantages
22:38:43 <jle`> ><
22:38:57 <shayan_> Axman6: Thanks, I’ll continue to look into it
22:39:08 <jle`> this might be a bit broader than #haskell, but does anybody have any suggestions
22:39:32 <teruyo> jle`: Perhaps expressing nondeterministic concurrency is one of the benefits?
22:40:47 <teruyo> jle`: Although that's a double-edged sword. Concurrency control is a frigging hard problem.
22:42:20 <jle`> yeah, 'double-edged sword' is sort of the theme
22:42:38 <jle`> that's a good example, but it might be out of scope for this course heh
22:43:10 <Axman6> jle`: "Mutable state tends to be fast because that's all compiler writers and CPU designers have considered for the last 50 years. Mutable state is not inherently good, it'd just well optimised, but this comes at a very big cost"? =)
22:43:52 <jle`> oh i was speaking from more of denotative/writing programs sort of perspective, about helping you write algorithms
22:44:22 <jle`> surely mutable state is a nice concept for programming with, from an algorithmic perspective
22:44:28 <teruyo> Axman6: That's not an inherent advantage of the programming model, though. I'd say imperative vs. functional programming is a raw power vs. cost-effectiveness tradeoff. Functional programs are easier to reason about (equational reasoning on syntax vs. first transforming statements into predicate transformers), but imperative programs can do more (nondeterministic concurrency).
22:44:47 <jle`> all i can think of at the moment is its downsides, which is making programs much more difficult to reason about
22:45:19 <Axman6> yeah I'm too "broken" by pure FP to think of the advantages
22:45:20 <jle`> in order to understand what a program is doing, you have to be able to hold the entire program state in your head at all times
22:45:22 <teruyo> So, from this POV, using functional programming whenever possible is a matter of doing the simplest thing that will do the job.
22:45:53 <jle`> i'm not sure if simplest is necessarily stateless
22:45:58 <MarcelineVQ> jle`: Have you read the out of the tar pit paper? http://shaffner.us/cs/papers/tarpit.pdf it's possibly not suuuper relevant to your question but it does explore the issues of mutable state, and where it gets entangled in oop vs functional. though overall it's really trying to tackle complexity which is why it may not be directly relevant.
22:46:45 <jle`> the paper does mostly talk about its problems
22:46:47 <MarcelineVQ> section 5 onwards may have useful sections for you
22:47:36 <teruyo> jle`: What I mean is that the techniques for reasoning about functional programs are simpler than the corresponding techniques for reasoning about imperative programs. Reasoning about a functional program is as first-order or higher-order as the program itself. Reasoning about an imperative program is always higher-order, because statements map predicates (on the program state) to predicates.
22:47:36 <jle`> section 5 would help me enhance what i already have, thanks :)
22:47:52 <jle`> the part that i'm missing is the original motivation and benefits of state as a programming concept
22:48:02 <jle`> the downsides i could talk about for days :p
22:49:13 <Rotaerk> functional programming usually requires doing something most people aren't fond of
22:49:20 <Axman6> thinking?
22:49:22 <Rotaerk> learning
22:49:23 <Axman6> >_>
22:49:33 <Axman6> same coin =)
22:49:39 <MarcelineVQ> probably something along the lines of being able to ask "What is this machine doing?" when that was a straightforward question. re: the still often used print debugging
22:49:42 <Rotaerk> as in, imperative programs tend to be written directly in terms of the raw language mechanisms...
22:50:11 <jle`> heh.  i'm considering algorithms based on mutation and algorithms/functions that aren't as two alternative and legitimate ways of thinking
22:50:11 <Rotaerk> functional programs are often built on top of abstractions
22:50:29 <jle`> so, when would you prefer algorithms based on mutation vs. algorithms that aren't?
22:50:41 <jle`> what new doors does mutation offer for crafting algorithms?
22:51:17 <jle`> i'm sure it offers SOME benefits
22:51:20 <teruyo> jle`: (0) When it's provably asymptotically faster. (1) When nondeterminism is essential to your program.
22:51:21 <MarcelineVQ> cutting the indirection fat :(
22:51:31 <dmj`> in-place mutable quicksort is the only true quicksort really
22:52:14 <teruyo> jle`: e.g., I think there's no purely functional counterpart to Tarjan's union-find data structure that isn't asymptotically slower.
22:52:27 <jle`> teruyo: (0) sounds like less of a property of using state and more as just an 'either is ok, whatever passes this unrelated benchmark'
22:54:44 <jchia> I need to parse and 'unparse', 'unparse' being the opposite of 'parse'. Conceptually, if parse :: ByteString -> Either s Foo, then unparse :: Foo -> ByteString, and the mapping is in opposite directions. Can I do both parse & unparse without repeating myself  using common libraries like megaparsec? Or is there some special library that can do this?
22:55:12 <jle`> jchia: you might want to check out bidirectional parsing
22:55:51 <teruyo> jle`: But it's precisely by using imperative state that you can pass that benchmark. (Don't get me wrong: ceteris paribus, I think functional programming is the right default.) Also, in any case, I don't think (1) can be objected to. If you're implemetning an OS or a DBMS, concurrency has to be a fundamental part of your programming model.
22:55:59 <Axman6> there was (at least one) talk at LambdaJam last year about bidirectional parsing
22:56:42 <jle`> teruyo: yeah, but it's a bit of a cop-out unless you talk about what part about imperative state lets you pass that benchmark.
22:56:45 <jchia> jle`: Do you have a library in mind?
22:57:54 <jle`> teruyo: it doesn't give any criteria on exactly what it is about state/no-state that is better
22:58:04 <jle`> jchia: i don't think there are any serious production-ready libraries at the moment
22:58:21 <jle`> from what i've gathered it's mostly just an interesting idea
22:58:53 <jle`> with toy implementations/proof-of-concepts
22:59:09 <teruyo> jle`: Dunno, neither is “better”. It's just a tradeoff. Imperative programming offers more raw power, functional programs are easier to reason about.
23:00:00 <jle`> yeah, my original question was what does imperative state give you in terms of power that programming w/o state lacks
23:00:14 <jchia> Axman6: You mean lambdajam 2015?
23:00:21 <jchia> 2016 was canceled apparently
23:00:48 <jle`> in terms of reasoning tools, i mean
23:00:56 <ertes> @package boomerang
23:00:56 <lambdabot> http://hackage.haskell.org/package/boomerang
23:00:59 <ertes> jchia: ^
23:01:17 <ertes> it's mostly used for URL parsing though, so you may find it oddly specialised to that use case
23:01:25 <Axman6> jchia: I don't think it was... I was there
23:01:49 <Axman6> bleh, lambdajam.com is not the lambdajam I'm talking about
23:02:02 <teruyo> jle`: In the sequential (single-process) case: O(1) reads from and writes to arbitrary parts of arbitrary data structures, so long as you have a pointer to it.
23:02:27 <teruyo> jle`: And in the concurrent (multi-process) case, nondeterminism.
23:03:50 <teruyo> jle`: OTOH, since the lambda calculus is Church-Rosser, the only kind of nondeterminism you can get from a purely functional program is “we eventually reach the answer” vs. “we never do”, but the answer, if there is any, is never in question.
23:04:43 <jle`> the advantages i was looking for is mostly conceptual/regarding reasoning about your program
23:05:05 <jle`> like, how is state a useful tool for writing algorithms and reasoning about them
23:06:14 <Axman6> jchia: talks are at http://lambdajam.yowconference.com.au/speakers/ (see Fraser Tweedale's and  David Laing's talks)
23:06:45 <teruyo> jle`: Mmm... If you're only interested in deterministic computations, everything you can do imperatively you can do purely functionally (although you might need to pay an asymptotic cost). So long as you only care about correctness, not efficiency, I don't see what state gives you at all. :-|
23:06:47 <Axman6> jchia: videos available at https://www.youtube.com/playlist?list=PLIpl4GKFQR6dFB0W9IzF_gcIt1VMRnuco
23:07:35 <teruyo> jle`: But I think both efficiency and nondeterminism are important.
23:11:59 <jle`> i can't accept that ;_;  there has to be some benefit in approaching problems from an imperative standpoint, in terms of "opening your mind".  other than just performance and nondeterminism
23:12:16 <jle`> hm
23:12:20 <jle`> reasoning about state machines is easier
23:12:28 <jle`> maybe?
23:17:12 <teruyo> jle`: In some cases, you want nondeterminism in the specification, even if the implementation is deterministic. For example, you don't want a priority queue user to know or care how the priority queue picks between elements of equal priority. Predicate transformers very cleanly handle not telling an abstraction user more than he needs to know.
23:19:53 <gorgi> best free vpn please help ?
23:20:37 <juliench1rch> What am I totally missing when a type is defined as `type Get = Verb 'GET 200`? What's the prime doing in there?
23:20:55 <teruyo> juliench1rch: GET is a data constructor, right?
23:21:42 <Philippa> jle`: You can't really reach "effectful programming" without having had "imperative" as a possible model at some point? But that's about all I can really think of
23:22:10 <teruyo> juliench1rch: If GET is a data constructor, which lives in the term level, 'GET is the same data constructor, except now it lives in the type level, assuming you've enabled DataKinds.
23:22:12 <jle`> teruyo, Philippa: good points, thanks for the help :)
23:22:14 <Philippa> that said: you should say "resources" rather than "performance"
23:22:42 <Philippa> (because you need an operational POV to discuss memory usage as well, and that will be something you can give an imperative feel)
23:22:54 <juliench1rch> teruyo: GET is indeed a data constructor. I don't understand what you wrote yet, but it's a huge step in the right direction 
23:22:57 <juliench1rch> :)
23:23:33 <Philippa> me, I keep meaning to try one-upping Conor McBride and take geometric algebra to datatypes or even code, but I don't really have the practiced background
23:24:06 <teruyo> juliench1rch: Things that live in the term level (e.g. 2, Just, map, etc.) have a type. Things that live in the type level (e.g., Maybe, String, etc.) have a kind.
23:28:01 <juliench1rch> teruyo: I do know some of the more basic stuff surrounding types/kinds (just to save you from elaborating too much). I'm giving DataKinds a look-through right now
23:28:11 <teruyo> Okay. Good luck!
23:32:18 <juliench1rch> teruyo: Thanks!
23:32:32 <teruyo> yw :-)
23:36:14 <jchia> Axman6: got it, thanks
