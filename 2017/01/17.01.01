00:00:44 <sophiag> Liskni_si: the issue with haskell-mode and stack-ghci can be fixed easily per instructions here: https://github.com/haskell/haskell-mode/issues/1455. just took me a while to find
00:01:54 <Liskni_si> sophiag: I'm not having those issues fortunately, just trying to comment on why you might not have had them a night ago
00:02:37 <sophiag> ah ok. i *did* just switch to debian...
00:02:50 <sophiag> that link now appears broken for me...
00:03:29 <sophiag> oh, i pasted a period onto the end...clearly almost bed time:p
00:04:21 <sophiag> anyway, it doesn't actually seem to be a new issue. more likely i was running an old version of slack due to being on centos6 :p
00:04:35 <sophiag> *stack
00:20:22 <riaqn> Hi, in a bytestring, how can I write to a certain index?
00:20:45 <riaqn> we have index:: ByteString -> Int -> Word8 for reading, I'm looking for the writing counterpart.
00:24:33 <riaqn> ah, nevermind, I will just use "drop" and "take"
00:59:14 <mounty> What's the best way to obtain a list of fields making up the primary key of a table, using Database.HDBC ?
01:00:29 <Sigynismybitch> My psyciatrist had a pet frog in his office but then my psychiatrist just had to go ask dumbass questions like whether i ever killed anythinf
01:00:39 <Sigynismybitch> i wanted be cool dude like yeah, man, i kill stuff
01:00:59 <Sigynismybitch> but i dont lie, so i had to kill something and quick
01:01:07 <Sigynismybitch> i saw the frog, opened the cage 
01:01:18 <Sigynismybitch> and cut its head off with a scissors
01:01:27 <Sigynismybitch> then i was like, yeah, dude, i kill stuff
01:01:36 <Sigynismybitch> and that was the first time i ever killed a frog
01:01:45 <Sigynismybitch> and since then i have been killing frogs
01:01:51 <Sigynismybitch> i kill frogs
01:02:03 <Sigynismybitch> in the future i intend to be killing frogs
01:02:07 <Sigynismybitch> because i kill frogs
01:02:30 <Sigynismybitch> to save the toads from eternal slavery to the frogs
01:02:35 <Sigynismybitch> any questions?
01:03:34 <Sigynismybitch> mniip: hi
01:03:43 <Sigynismybitch> i kill frogs
01:35:32 <tsahyt> hello! I'm playing around with pipes a bit and trying to get the hang of it. Is there a way to branch off something into a consumer and still using the same stuff after that? e.g. I have a socket open and I just want to dump everything to stdout or a log file or something before I process the data in some other way
01:36:51 <c_wraith> tsahyt: you could easily write a pipe that accepts a piece of data, prints it or whatever, then yields it.
01:37:30 <tsahyt> I suppose that would be a Pipe' or something like that? I'm still trying to wrap my head around the types here
01:38:10 <c_wraith> I'd write it first and figure out the type later. :)
01:39:01 <c_wraith> tsahyt: actually, I think it'd be a Pipe a b IO () or the like
01:39:34 <tsahyt> and I could compose this in using >->? a Producer >-> Pipe yields a Producer, which I think is what I want because I need something at the end that still yields
01:39:45 <c_wraith> tsahyt: they're all synonyms for Proxy
01:40:03 <tsahyt> I know, but I think they are useful synonyms for me to understand what's going on
01:40:59 <Axman6> thre's also some stuff for doing concurrency with pipes, you could fork a thread do do one of the tasks quite easily
01:52:34 <tsahyt> Is it possible to have a pipe discard some stuff coming from upstream? e.g. I have a function a -> Maybe b, and when it returns Nothing, I just don't yield and wait for the next thing? Is there a standard function somewhere in the pipes library for that?
01:53:32 <mikeplus32> hmm, will the upcoming compact region stuff allow for functions to be 'compact'd? that would make serialising/deserialising them maybe somewhat possible ...
01:54:03 <Axman6> I'm sure there's some kind of filter, you can filter on isJust
01:54:07 <mikeplus32> i guess any such "compact" region with functions would quickly not be very compact at all
01:54:44 <tsahyt> Axman6: and afterwards I could safely map fromJust I suppose
01:55:03 <tsahyt> there is a filter in Control.Pipe.Combinators that looks like something I could use
01:56:27 <Axman6> yep
01:56:35 <Gurkenglas> I'd define "(a -> Maybe b) -> Pipe a b m r" on its own line though to encapsulate the unsafety as far as possible
01:56:36 <Axman6> or you could write your own qiote easily
01:57:22 <Gurkenglas> Yes, you can just not yield :P Maybe use for_ or MaybeT for convenience
01:58:14 <hits1911> I'm trying to write a function that composes two relations. for example [(1,2), (2,3)] `myfunc` [(3,1), (2,1)] yields [(3,2), (2,2)] ? Is there a function to do it? I looked at Hoogle but failed. Or do I have to write mine?
01:59:51 <Gurkenglas> nub [(x, z) | (x, y1) <- r1, (y2, z) <- r2, y1 == y2]
01:59:59 <tsahyt> Gurkenglas: it's really just one encapsulated step. I'm parsing messages from the network. if it doesn't parse for whatever reason I have no reason to respond, i.e. I can just discard it
02:00:13 <tsahyt> maybe log the failure somewhere, but that's about it
02:01:25 <c_wraith> mikeplus32: it depends on a class.  I doubt there's an instance for functions.
02:02:34 <Gurkenglas> I'd say that the things that deserve a name are those that are used more than once (not sure about that one) and the smallest ones that encapsulate some unsafety, like discarding impossibilities unsafely, or explicit recursion
02:02:35 <c_wraith> mikeplus32: or at least, the paper describing the initial implementation used a class
02:02:45 <Gurkenglas> (inline everything else)
02:03:46 <hits1911> Gurkenglas: that'll do. thanks.
02:05:38 <Gurkenglas> (hits1911, if performance is important, an Ord instance will allow you to exchange a linear factor for a logarithmic one there)
02:22:45 <lpaste> purelazy pasted “How to code this better?” at http://lpaste.net/350718
02:24:26 <purelazy> I'm not sure if this nested lambda style can be improved upon
02:25:25 <purelazy> I have been trying to covert it to a "do" notation style, but am struggling
02:27:49 <purelazy> because withCString and with and alloca require (in this case) closures
02:34:32 <lpaste> purelazy pasted “How to code nested lambdas better?” at http://lpaste.net/350719
02:34:40 <purelazy> shorter version
02:35:04 <M-berdario> Uhm, I'm having a look inside the code of Stack itself... this seems a bit weird:
02:35:04 <M-berdario> https://github.com/commercialhaskell/stack/blob/80e530f8c56cd1f5e3e45f9c1b35972f978fa913/src/Stack/Types/StackT.hs#L300
02:36:04 <M-berdario> `This definition is top-level in order to avoid multiple reevaluation at runtime` makes sense, but why is keeping stuff at the top-level such a special thing in the first place?
02:36:11 <Axman6> purelazy: I usually stick the lambda binding on the same line as the withFoo function, and then I only need to indent a couple of spaces
02:37:13 <Axman6> M-berdario: they will only be evaluated once
02:37:23 <M-berdario> usually I always try to keep functions small, and thus hoisting functions and values to the top level
02:37:38 <Axman6> personally I'd probably just do it using TH if I needed to be sure of that
02:37:45 <purelazy> Axman6: I am really asking can the code be sugared into "do" notation somehow?
02:38:17 <M-berdario> Axman6: yeah, but the thing that puzzles me is that a lot of code in that module seems to have quite long and complex functions, that I would've split into a bunch of smaller functions
02:38:27 <purelazy> Or is it best the way it is?
02:38:40 <M-berdario> aside from the difficulty of finding a good name for all of them, I don't see any other disadvantage
02:38:43 <Axman6> purelazy: not really no
02:39:00 <Axman6> you _might_ be able to do something with the Cont monad... but I wouldn't recommend it :)
02:39:31 <M-berdario> and that comment made me thing that maybe it's not something that happened by chance, but it's instead a conscious effort to not keep stuff at the top level (except where it's needed for performance reasons, like in the `timeStampLength` case)
02:40:31 <purelazy> Axman6: Not really "the best way" or "cannot be sugared"?
02:40:45 <lpaste> Liskni_si revised “How to code this better?”: “How to code this better?” at http://lpaste.net/350718
02:40:56 <purelazy> Axman6: i.e. it is already the best way
02:41:06 <Liskni_si> oh, "edit" isn't the right button I guess
02:41:15 <Liskni_si> sorry for ruining the paste :-(
02:41:17 <Axman6> it can't be sugared no
02:44:22 <purelazy> Liskni_si: I am not worried about the lpaste
02:44:43 <Liskni_si> anyway, my edit is what I think is a slightly more readable version
02:44:59 <purelazy> Liskni_si: That is so sweet
02:45:02 * Liskni_si is now reading through lpaste source code to figure out what annotate is :-/
02:45:05 <purelazy> Thanks a million - I will try it out
02:48:34 <purelazy> Liskni-si: It works
02:48:50 <purelazy> :) Thanks for the beauty
02:49:00 <Xnuk> Why Haskell does not allow trailing commas?
02:49:50 <Xnuk> > [ 1, 2, 3, ]
02:49:53 <lambdabot>  <hint>:1:12: error: parse error on input ‘]’
02:51:45 <Liskni_si> purelazy: you're welcome :-)
02:52:28 <purelazy> Liskni_si: Thanks sooooo much. 
02:53:14 <purelazy> My Haskell-fu hit a brick wall there
02:53:42 <geekosaur> Xnuk, it's been proposed. the question is, where can you allow them without running into e.g. conflicts with section syntax?
02:55:38 <geekosaur> of course, lists are already rather magical syntax, which also complicates things --- as does the fact that there's a commonly used coding style that would likely prefer the extra comma be at the front of the list
03:01:12 <Liskni_si> purelazy: it's also possible to use "(. mkVkApplicationInfo) . flip with" instead of "\namePtr -> with (mkVkApplicationInfo namePtr)" to avoid having to name the ptr, but this is starting to get ugly :-)
03:03:01 <purelazy> Liskni_si: I am more than happy with your solution
03:07:30 <Fylwind> if I have a GADT that can only ever return "MyDataType (a, a)", is there some way to unify "forall a . MyDataType a" with "forall a . MyDataType (a, a)" ?
04:35:18 <purelazy> Main.hs:169:1: error: parse error on input ‘--/’
04:35:36 <purelazy> This was a comment, but it does like --/
04:35:44 <purelazy> What is --/ ?
04:35:54 <purelazy> does=doesn't
04:37:03 <ahihi2> it's a valid operator name
04:37:04 <arjanb> that is parsed as a custom operator, just add a space after -- to keep it as a comment
04:38:03 <purelazy> I would like to know how to find out what --/ is defined as
04:38:10 <purelazy> Hoogle doesn't know
04:38:21 <purelazy> How does one find out these things?
04:38:45 <ahihi2> I don't think it is defined as anything
04:39:34 <ahihi2> it is syntactically an operator, but that doesn't mean a definition exists for it
04:40:07 <purelazy> ahihi2: OK. Thanks
04:40:48 <Axman6> comments are specifically "-- " (or --<non-symbol>" I think) not "--"
04:41:56 <pavonia> You can even have more hyphens
04:42:08 <Axman6> right
04:42:10 <purelazy> --<alpha or num> is ok
04:42:21 <purelazy> but --<thingy> is not
04:44:42 <purelazy> but --<thingy> is not unless thingy is -
04:50:13 <cobreadmonster> Hey guys.
04:51:16 <purelazy> monster
04:54:58 <cocreature> Hey, I have a warp server that I’m starting as shown here http://lpaste.net/350722 . When I try to send a cors request from my browser I can see the OPTIONS request via logStdoutDev and it looks fine but I get a 500 for the actual POST request and that one doesn’t even appear in the log. Any idea what could be causing this?
04:55:20 <cocreature> what makes things weirder is that I am pretty sure that is the same code that I’m running on the server and there it works just fine
05:53:11 <strongBone> jce69
05:53:29 <strongBone> !jce69 inurl:shopdisplayproducts.cfn?catalogid=
05:53:38 <strongBone> !jce69 "/inurl:shopdisplayproducts.cfn?catalogid=
05:53:47 <geekosaur> o.O
05:53:59 <Tuplanolla> That's been going on for days, geekosaur.
05:55:29 <geekosaur> oh, latest version of whatever piracy bot has been hanging around in here?
05:55:55 <Tuplanolla> It seems to be mostly malfunctioning.
06:29:48 <purelazy> What does one do when a Haskell API bindings package is out of date?
06:30:16 <geekosaur> contact the maintainer listed on hackage?
06:30:21 <purelazy> FYI: The one I have in mind is the GLFW-b package
06:31:14 <purelazy> geekosaur: OK - cool. I have done that much. I will wait and see.
06:31:50 <purelazy> Thanks
06:32:31 <geekosaur> if you don't get a response, there is a procedure to take over maintainership of a package; ask in #hackage or the haskell-cafe mailing list
06:33:09 <purelazy> How many days should I wait?
06:33:46 <purelazy> It's not life threatening
06:33:58 <purelazy> A week?
06:33:58 <slack1256> order or weeks
06:34:18 <slack1256> *of
06:34:20 <purelazy> A month then
06:36:06 <slack1256> better yet, if is in your knowledge how to update them, send a patch. I've been offered some packages just for that
06:37:11 <purelazy> slack1256: How could I do it now?
06:37:26 <purelazy> I mean a local hack
06:37:58 <slack1256> well, first git clone the repo
06:38:06 <purelazy> OK
06:38:24 <slack1256> and then just hack a way.
06:38:33 <purelazy> OK
06:38:45 <purelazy> thanks
06:38:55 <slack1256> ;-)
06:39:54 <purelazy> I think I'll  wait for the mainainer to get back for a while first
06:40:30 <purelazy> *maintainer
06:41:11 <purelazy> Gives me an excuse to be lazy
06:42:29 <purelazy> slack1256: Thanks
07:06:30 <Nik05> @bot
07:06:30 <lambdabot> :)
07:10:22 <mbw> Happy new year everyone. While trying out the "compressor" example from http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html I noticed that the readline package won't build with stack. Other users seem to encounter this too, since a workaround is given in the comments under the example. So I was wondering, what is the usual procedure when you encounter this sort of thing, in terms 
07:10:28 <mbw> of letting the author of the library know etc., regarding packages on stackage?
07:13:11 <glguy> a/mentions
07:14:57 <nitrix> I personally fork the library, branch their master branch, do my fixes, open a pull request with the author, and merge my changes in a `stable` branch, which I use for my own projects until the author merges it upstream.
07:16:22 <lpaste> mbw pasted “readline package build failure” at http://lpaste.net/350724
07:19:07 <mbw> Is there an interface for that kind of thing on stackage, like on github?
07:19:11 <MarcelineVQ> do you have the GNU readline library installed?
07:20:38 <mbw> I do have readline-common...
07:21:22 <geekosaur> you need the dev library
07:22:15 <mbw> Ok, now it built.
07:22:46 <mbw> I probably read that log wrong.
07:24:19 <geekosaur> debian and rh/fedora split up the libraries used for linking from the libraries used for running
07:24:40 <mbw> I guess this should've given it away, no? "checking for GNUreadline.framework... checking for readline... no"
07:24:41 <geekosaur> (the former looks like libFOO.so, the latter libFOO.so.N for some N which may have multiple components
07:25:57 <geekosaur> the reason these are separated is because you can have more than one runtime version of a library installed at the same time, but it's difficult to have more than one dev version installed without confusing programs (which are unlikely to build against a different version than they expect)
07:26:02 <mbw> Well at least I learned something. This might actually be something worth leaving a comment about on the RWH page.
07:28:22 <mbw> So a dumb question then. What exactly is the difference between runtime and dev versions then? Both are just shared libraries, yes?
07:28:43 <mbw> Is it just a versioning thing?
07:29:08 <aidecoe> what's the easiest way to get FQDN? getHostName from hostname package returns only host name without domain.
07:30:42 <geekosaur> mbw, yes
07:30:53 <geekosaur> for example, on my system there is both readline 5 and readline 6
07:31:11 <geekosaur> the runtimes can coexist. the dev headers and libraries cannot; only one can be installed at a time
07:31:46 <geekosaur> (or, you do something so both can be installed at the same time, and then have to fight with every configure script, every cmake manifest, ... to get anything using readline to build)
07:35:07 <mbw> Ok. So hopefully I got this right. A set of runtime libraries can coexist simply because the share the same .h files, and distinct dev libraries generally introduce breaking api changes?
07:35:11 <Tuplanolla> The development package usually has some extra files, like headers, mbw. You can check the differences yourself.
07:35:12 <Tuplanolla> $ comm -3 <(dpkg-query -L libreadline6 | LC_ALL=C sort) <(dpkg-query -L libreadline6-dev | LC_ALL=C sort)
07:37:13 <geekosaur> runtimes don't have .h files, those are part of the dev package
07:37:29 <geekosaur> and the .h files for libreadline 6 are likely to be incompatible with those for libreadline 5
07:38:12 <geekosaur> (a better example there might be ncurses, where ncurses 6 is very definitely incompatible with ncurses 5 in both headers and libraries)
07:38:33 <geekosaur> but the runtimes can coexist because all you need is libncurses.so.N where N is the expected version
07:39:00 <mbw> Ok, so the runtime library is only necessary if I use another library (like the haskell readline package) which interfaces with it?
07:39:18 <mbw> where it = some header
07:39:22 <geekosaur> the runtime is used by binary programs
07:39:40 <geekosaur> if you are compiling something, regardless of language, you need the dev library
07:40:21 <geekosaur> but, for example, debian does not install from source; it installs binaries, and those have dependencies on the specific runtimes they need installed with them; those runtimes can coexist
07:40:38 <geekosaur> if you are going to compile something else against the library, you need the dev library installed, not just the runtime
07:41:28 <geekosaur> this also applies to, say, python; when you install the python interface for ncurses, you must have the ncurses dev library installed, but to use that python interface you only need the runtime library
07:42:19 <geekosaur> (I know of one exception to this, and they've been finding out over the past few months why the way they chose to handle this was a bad idea. this split is only the smallest part of the reason :)
07:43:27 <mbw> So, if a binary has been statically linked, I don't need the runtime library, if it has been dynamically linked, I need it?
07:43:34 <volhovm> Hey everyone! I wonder why i can't find any library that abstracts algebraic data structures with a good precision?
07:43:46 <geekosaur> mbw, yes, that also
07:44:18 <Tuplanolla> Do you mean like SubHask, volhovm?
07:44:35 <volhovm> Can't find a single place with semigroup, monoid, group, abel. group, semiring, ring, field.
07:44:37 <volhovm> https://hackage.haskell.org/package/numeric-prelude-0.4.2 
07:44:46 <volhovm> This one is somewhat poor.
07:44:48 <geekosaur> although you may still need runtime data, which is generally also versioned. (and sometimes that "data" is executable, which is why glibc strongly disrecommends static linking against it)
07:44:57 <mbw> Ok, so these appear to be some basics, and the other aspect is some package management specifics I should look up some more
07:45:10 <geekosaur> yes. note also that package managers differ
07:45:18 <Tuplanolla> @hackage subhask
07:45:19 <lambdabot> http://hackage.haskell.org/package/subhask
07:45:22 <geekosaur> binary-style package managers usually do things the way debian and fedora do
07:45:45 <geekosaur> but rolling release ones (e.g. arch) may not
07:45:59 <Tuplanolla> It's huge and unstable, but you might still find it interesting, volhovm.
07:46:21 <volhovm> Tuplanolla: thanks, i'll have a look.
07:46:33 <geekosaur> and ports-style package managers (freebsd ports, netbsd pkgsrc, macports, homebrew, gentoo) don't split things up either, you always get both because you generally will need both to install dependents
07:49:33 <geekosaur> ...and usually have some internal way to enable multiple concurrent versions, which will force you to mess around with configure/cmake/etc. if you need to compile stuff against them yourself; with these systems it's usually easier to create a port for whatever you are trying to install instead of trying to build separately using ports libraries
07:50:03 <mbw> Since you seem to know your stuff. At some point in the future, I am probably going to use a new distro. While this topic is of course highly opinionated, I would particularly be interested in repositories with the newest compiler/tools available. For instance, while the debian/ubuntu repos are generally well maintained, I actually had to meddle around in the libc++ string header at some point, because of a 
07:50:09 <mbw> long-known bug. Or for another example, I can't use specific valgrind tools. Are there some distros with a focus on programming? Or is installed tarballs yourself generally the way to go?
07:51:02 <lordcirth> mbw, Arch is generally pretty up to date in general.
07:51:13 <lordcirth> So is Fedora
07:51:48 <geekosaur> it depends on what you are trying to do. if you want to build for packaging in various distros, you want to build against those and deal with any bugs/outdatedness in a way compatibl with them (e.g. not hacking on package-installed headers!)
07:52:31 <geekosaur> if you just want the latest and greatest at all times, many distributions provide a way to get that (fedora rawhide, debian sid, etc.) and some distributions work that way normally (arch)
07:53:23 <mbw> So far, I was too intimidated to actually participate in open source development, so it would probably be the latter case.
07:57:34 <mbw> Any pointers on how to reasonably compare between the options mentioned? I have only used Lubuntu and OpenSuse in a more serious manner so far, so my experience is limited.
08:04:35 <mbw> That is probably asking for too much. Still, thank you all for your input. This channel is not too shabby.
08:05:25 <james_rth> I was wondering if anybody has experience recursion schemes for indexed functors.. particularly monadic catamorphisms
08:08:03 <james_rth> I'm wondering if it's possible to loosen the constraint to an applicative and have an applicative catamorphism
08:10:41 <james_rth> in fact, indexed or not, I'm wondering if it's possible to have an applicative catamorphism
08:11:38 <ertes> james_rth: you can have Applicative/Category catamorphisms
08:12:01 <james_rth> with a type sig something like: cataA :: (Traversable f??, Applicative m) => (f a -> m a) -> Fix f -> m a
08:13:16 <ertes> james_rth: but why would you need that?
08:13:53 <james_rth> I was thinking if I could use something like validation (AccValidation) which only has an applicative instance
08:14:02 <james_rth> for my catamorphism
08:14:22 <james_rth> i.e. I don't have a monad instance :(
08:15:09 <james_rth> ertes: do you have any examples? Or am I perhaps just barking up the wrong tree?
08:15:23 <ertes> :t foldr (\h1 ~(h2, more) -> (h1, hGetLine h1 >>= hPutStrLn h2 >> more)) (stdout, pure ())
08:15:25 <lambdabot> error:
08:15:25 <lambdabot>     • Variable not in scope: hGetLine :: t1 -> m a1
08:15:25 <lambdabot>     • Perhaps you meant one of these:
08:15:32 <ertes> @let import System.IO
08:15:36 <lambdabot>  Defined.
08:15:37 <ertes> :t foldr (\h1 ~(h2, more) -> (h1, hGetLine h1 >>= hPutStrLn h2 >> more)) (stdout, pure ())
08:15:39 <lambdabot> Foldable t => t Handle -> (Handle, IO ())
08:16:02 <ertes> james_rth: regular catamorphisms are capable of constructing effects
08:16:17 <ertes> there is probably no need for a special combinator
08:16:37 <james_rth> so just have some "effectful" functor
08:16:53 * james_rth pondering
08:16:55 <ertes> no…  what i just showed you is a list catamorphism
08:17:13 <ertes> but i fold it into a handle and an IO action
08:17:55 <ertes> when given [h1, h2, h3] it reads a line from h1, writes it to h2, then reads a line from h2, writes it to h3, etc.
08:20:27 <james_rth> ok
08:20:37 <james_rth> ertes: thanks a lot for your help
08:54:26 <mbw> I have another question about the "Compressor.hs" example on http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html . If I run the sample program with a path that does not exist, the exception (how can I find out about its type? I currently just print a SomeException value.) is printed correctly. However, if I give it a path to a file I don't have read access to, it just silently 
08:54:32 <mbw> does nothing and loops to the next iteration. Does this have to do with lazy evaluation? Who would one typically handle this?
08:56:44 <mbw> *How
08:59:50 <cocreature> mbw: seems like it could be related to lazy IO. the exception will then be thrown in the new thread causing it to silently die. you can try to call "evaluate content" before spawning the thread (evaluate will not read the hole file but it should be enough to detect whether it is readable)
09:00:12 <cocreature> alternatively you can use readFile from the "stict" package
09:00:26 <cocreature> but that will really read everything before spawning the thread
09:05:19 <mbw> This is weird. It works when I give it the "file-compressing.cabal". If I rename it to hugo.txt, it does not. Renaming it to hugoooooooooooooooooo.txt makes it work again...
09:06:08 <mbw> This program sucks.
09:07:07 <mbw> I'll try "evaluate". By the way, do I have to handle an AsyncException?
09:08:31 <cocreature> the exception should be synchronous
09:09:07 <cocreature> and "handle print" should take care of it
09:13:01 <mbw> Ok. Assuming this is maybe a problem of lazy IO and I don't want to read a 8Gb file, what would you usually use in this situation? Iteratee IO? My limited intuition would tell me that this kind of situation is just what ByteString.Lazy is for...
09:13:55 <cocreature> most haskellers seem to agree these days that lazy IO is the wrong solution in pretty much all situations
09:14:18 <cocreature> sadly there is no agreement on which of the various streaming IO solutions should replace it
09:14:24 <cocreature> personally I like "pipes"
09:14:34 <cocreature> "conduit" is also very popular
09:15:25 <mbw> I find it baffling that I would actually need an external library for even trivial tasks :(
09:15:54 <mbw> Or rather *another* library.
09:16:41 <cocreature> haskell tends to put a lot of things in external libraries because they are easier to swap out for a better solution when somebody finds one than swapping out the standard library
09:17:30 <mbw> But on the other hand, my program does just to the next invocation of readline, so I probably don't understand what the problem is in this particular case just yet.
09:17:50 <houli> is there a reason that monadtrans enforces only monad m but not monad (t m)?
09:18:03 <mbw> To be fair, using cabal/stack makes this easy, so I guess there's that.
09:18:03 <houli> haskell 98 compatibility?
09:20:04 <mbw> s/just/jump/
09:24:29 <cocreature> mbw: here’s what I think is happening in your program: "readFile" is executed, that opens the file (thereby checking whether it exists) but it doesn’t yet try to read from it, then you call "forkIO". "compressFile" tries to read from the file and throws an exception. this kills the forked thread. however this has no effect on your main thread so it just continues
09:27:05 <tsani> Hi all; cabal question. I have a package that needs liftIO. It's in base 4.9 but not in base 4.8 (it's in transformers historically). I would like to support building with GHC 7.10. How can I express in the cabal file that transformers is only needed for GHC <8 ?
09:28:09 <mbw> I think I got the problem with short file names to work by printing the thread id returned from forkIO
09:28:54 <ezyang> tsani: you can use an automatically toggled flag to handle this 
09:28:58 <mbw> Amazingly, files created with root are compressed as well.
09:29:29 <ezyang> intuitively, something like if flag(old-base): build-depends: base < 4.9, transformers else build-depends: base >= 4.9 
09:29:59 <mbw> Could it be that I have to force the thread created with forkIO to start its work?
09:30:05 <tsani> ezyang: awesome
09:30:26 <tsani> ezyang: can you refer me to relevant docs?
09:30:50 <mbw> Also, a non-existent file was handle correctly before.
09:31:12 <ezyang> http://cabal.readthedocs.io/en/latest/developing-packages.html#configurations 
09:31:34 <tsani> ezyang: thanks :)
09:31:36 <cocreature> mbw: have you tried calling "evaluate"?
09:31:40 <ezyang> tsani: the cabal file for Cabal has a worked example 
09:31:47 <ezyang> look for flag(old-directory) 
09:33:23 <ertes> tsani: just depend on transformers
09:33:31 <mbw> Sorry, I will try that too. Also, after *correctly* removing read permission (I just didn't have write permission before), the exception is handled correctly also.
09:33:32 <ertes> tsani: it does the right thing
09:35:45 <ertes> tsani: no need to do any of that in your own package
09:39:14 <mbw> Ok.
09:39:26 <mbw> With _ <- evaluate content it appears to work.
09:39:42 <mbw> evaluate tid >> return () does not work.
09:39:53 <mbw> tid is the thread id returned from forkIO.
09:40:18 <cocreature> "evaluate tid" is probably a noop
09:40:22 <mbw> But I get the feeling I can't be sure it will always work.
09:40:34 <mbw> This feels just as undeterministic as a thread race!
09:40:55 <michaelt> mbw: this is strange. It seems to work fine with `async` where you do explicitly "force" the result of threading http://lpaste.net/2330322828152274944
09:41:33 <cocreature> async will rethrow exceptions thrown in the spawned thread
09:41:36 <cocreature> forkIO won’t
09:41:51 <michaelt> ah that is relevant here
09:45:25 <mbw> The example michaelt posted seems to work.
09:46:47 <mbw> And I guess an exception that might occur because of a non-existent file or a file that can't be read will be thrown in the main thread in this particular example.
09:47:16 <mbw> Since readFile is invoked in the main thread.
09:47:52 <mbw> But even if there are many solutions for this particular problem, this is still very scary.
09:47:53 <tsani> ertes: that's a much simpler alternative :) thanks
09:48:27 <michaelt> the mixture of lazy io with concurrency demands too much IQ
09:48:29 <tsani> ertes: although I'd rather not have dependencies that I don't use, which would be the case for GHC >=8
09:49:41 <cocreature> mbw: basically it boils down to “don’t use forkIO unless you don’t care about errors in the thread you spawn”
09:49:41 <michaelt> mbw cocreature why is this program putting the reading and writing on different threads or whatever?
09:49:48 <mbw> michaelt, if I understand it correctly, async starts immediately, and wait blocks until it returns? Like a future/promise kind of thing?
09:50:31 <mbw> The authors make a point about the difference between concurrency and parallelism, so it's to prove a point I guess.
09:50:47 <mbw> *make a case
09:51:00 <mbw> Also
09:51:27 <mbw> On the previous page, an example is given which I should've read twice.
09:51:50 <mbw> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
09:51:52 <mbw> False
09:52:21 <michaelt> mbw: have you seen the book by simon marlowe on concurrency and parallelism? its much more up to date.
09:52:27 <mbw> This is probably exactly the thing I encountered here.
09:52:50 <mbw> I have the book, but haven't read it yet.
09:53:39 <michaelt> among other things he explains his `async` library. 
09:53:52 <janosp> very good book :)
09:56:30 <janosp> Does somebody knows a good Tutorial about Lens' and Prisms?
09:56:58 <ertes> tsani: transformers doesn't really hurt though
09:57:25 <mbw> Ok, thank you all for your help.
09:58:01 <ertes> tsani: consider it a shim, until GHC 8.2 comes out, at which point you can argue that you only support the latest two minor versions of GHC =)
09:58:36 <ertes> (honestly transformers should probably just be dumped into base)
09:59:38 <tsani> I can't think of something I've written that didn't involve transformers, so that would be nice
10:00:05 <ertes> base is an odd library anyway:  it's far too bloated to be considered minimal, but at the same time it's missing too many things to be considered "batteries included"
10:00:13 <ertes> why don't we just make a choice =)
10:00:58 <michaelt> what does it matter, transformers is a 'boot package'
10:01:30 <michaelt> my impression was that keeping things like transformers simplifies maintenance. 
10:01:46 <michaelt> keep things like transformers /separate/ does
10:13:56 <orzo> ghc needs an option to list errors in reverse order so that on the console the most relevant error is less likely to have been scrolled away
10:16:26 <srhb> orzo: -freverse-errors
10:16:49 <monochrom> it already has one? :D
10:16:53 <srhb> Yep.
10:17:55 <orzo> omg, <3
10:18:03 <srhb> Not sure when exactly it was added though, but it's in 801 for sure :)
10:18:34 <orzo> i used google to check but didn't notice i was looking at doc for 7.8.2
10:18:36 <orzo> heh
10:18:48 <monochrom> I was going to say something witty like "pipe stderr to less"
10:19:00 <srhb> Makes sense too :-P
10:19:06 <orzo> there's no need for that
10:19:10 <orzo> i'm using a console that lets me scroll
10:19:32 <orzo> it has a nice mouse-wheel interface
10:19:35 <srhb> I'm not sure how often the reverse order is more correct though. Honestly I've never thought of the order of errors and their significance.
10:19:41 <srhb> I was actually assuming source code location.
10:19:55 <srhb> But that seems to be incorrect...
10:20:16 <enferex> Hello, quesion about getting rid of the IO monad function type in my example here: http://lpaste.net/350731
10:20:59 <enferex> This code isn't 100% correct, but ultimately I want to return True|False if a simpleHTTP succeeds or fails, respectively.
10:21:19 <pikajude> you can't get rid of IO Bool there no
10:21:35 <enferex> pikajude: Ok, thanks... 
10:21:53 <pikajude> what kind of reachability are you trying to determine?
10:22:10 <monochrom> You need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
10:23:18 <enferex> monochrom: thx
10:23:43 <mbw> One more question. What exactly is the difference between an AsyncException and an Exception? Are there any rules of thumb when to use which?
10:27:56 <pikajude> mbw: may not be perfectly accurate, but my intuition is that an AsyncException can be thrown *from* anywhere
10:28:13 <pikajude> which is why AsyncExceptions are things like ThreadKilled, UserInterrupt, etc
10:28:26 <pikajude> they represent cases where "someone else" is coming in to interrupt your execution
10:28:41 <pikajude> as opposed to regular Exceptions where the code you're actually executing has caused the exception
10:30:43 <amx> http://chimera.labs.oreilly.com/books/1230000000929/ch09.html#sec_async-exceptions
10:33:26 <mbw> Ok.
10:34:03 <mbw> Seems I should really really read this book.
10:34:21 <MarcelineVQ> it's pretty great
10:34:29 <mbw> Thanks pikajude, amx
10:34:50 <mbw> I wanted to put it off until I feel more comfortable in "serial" Haskell.
10:44:38 <cocreature> even if you are only interested in serial Haskell, this book contains the best introduction to exceptions that I’ve seen
10:47:01 <octarin> What should I read after completing Lya’s tutorial ?
10:53:18 <MarcelineVQ> What is Lya's tutorial? :>
10:53:52 <c_wraith> I think a typo for LYAH
10:54:11 <MarcelineVQ> I thought so too but want to make sure
10:54:37 <MarcelineVQ> Just in case there's a cool new tutorial out there to check out
10:55:47 <c_wraith> octarin: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html gets rave reviews.  (I haven't personally checked it out, but people who have like it.  And the course instructor is frequently in here.)
10:59:42 <mbw> I also quite liked Haskell Programming From First Principles.
11:00:25 <mbw> And the book from Graham Hutton, a new issue came out in september and it's just 30$ or so
11:01:56 <mbw> Book by I guess.
11:06:20 <mbw> Is a completely static build of an executable, for use on a machine with the same isa and os possible? Or are there other factors to take into account?
11:18:02 <c_wraith> mbw: static builds are possible.
11:18:26 <c_wraith> mbw: for *completely* static, there has been some work done with building on alpine linux and linking to musl
11:18:45 <c_wraith> mbw: it can be done, but some libraries are painful to use that way
11:19:10 <octarin> MarcelineVQ: yes, it was a typo for lyah ^^
11:19:49 <c_wraith> mbw: see https://github.com/nilcons/ghc-musl for fully static builds
11:21:18 <mbw> This seems to be a non-trivial problem.
11:21:35 <c_wraith> mbw: dynamic linking is pretty firmly embraced by libc
11:21:39 <c_wraith> err, glibc
11:21:56 <c_wraith> mbw: even if you statically link in all the haskell code, there are still the system libraries
11:22:12 <mbw> And probably gmp and maybe more?
11:22:19 <c_wraith> yeah.
11:42:55 <mellon12> I'm trying to write a function that determines whether given list has transitive property i.e (a,b), (b,c) exist so (a,c) must exist too. Here is what I have written. transitive x = (x \\ nub [(a,d) | (a,b) <- x, (c,d) <- x, b == c, (a,d) `elem` x]) == [] . But it returns True even though it's not transitive. It seems correct to me.
11:44:47 <Gurkenglas> Even though what's not transitive? In general finding a minimal example for these helps.
11:45:20 <MarcelineVQ> octarin: https://github.com/bitemyapp/learnhaskell is usually reccomended as a good starting point. it also links to the resource that c_wraith mentioned, and things to do afterwards
11:46:54 <mellon12> transitive [(2,2),(4,2),(2,4),(4,4),(3,3),(1,3),(3,1),(1,1),(1,4),(4,1)] returns True. But it shouldn't. (2,4) is there (4,1) is there but (2,1) is not.
11:47:02 <MarcelineVQ> mbw: I've heard that often it's liscencing that gets in the way of making things completely static
11:48:00 <Gurkenglas> @let counterexamples x = nub [(a,d) | (a,b) <- x, (c,d) <- x, b == c, (a,d) `elem` x]
11:48:07 <lambdabot>  Defined.
11:48:21 <Gurkenglas> > counterexamples [(2,2),(4,2),(2,4),(4,4),(3,3),(1,3),(3,1),(1,1),(1,4),(4,1)]
11:48:24 <lambdabot>  [(2,2),(2,4),(4,2),(4,4),(4,1),(3,3),(3,1),(1,3),(1,1),(1,4)]
11:50:45 <Gurkenglas> > counterexamples [(1,2),(2,3),(1,3)] -- that's transitive!
11:50:49 <lambdabot>  [(1,3)]
11:52:16 <Gurkenglas> But let's presume you just want to check whether an already reflexive relation is transitive.
11:53:30 <Gurkenglas> Notice that the "(a,d) `elem` x" is superfluous because anything that's not in x is ignored by \\ anyway
11:55:32 <Gurkenglas> You check whether there's an edge in x that cannot be constructed as the composition of two edges. What does this have to do with transitivity?
11:56:00 <Gurkenglas> (If there is such an edge, you call x "not transitive"
11:56:03 <Gurkenglas> *)
11:57:02 <Gurkenglas> I should write a gurkbot that says *) when I leave a ( that starts a line unclosed.
11:58:24 <implementation_> definitely https://xkcd.com/859/
11:59:44 <mellon12> If I change the order in \\, 
11:59:47 <Gurkenglas> https://wiki.haskell.org/Roll_your_own_IRC_bot was evil because of IRC protocol violations right? What was the right way?
12:00:12 <mellon12> hmm. that wouldn't work anyway.
12:01:07 <Chatter_-1> this network is a bait/entrapment/sting platform doing law enforcement or vigilante work. (ETHICALLY CORRUPT)
12:01:45 <MarcelineVQ> quite possibly, but it's free, so just don't discuss things that are illegal on it like you shouldn't anyway
12:07:52 <Gurkenglas> Ah there http://ircbrowse.net/browse/haskell?id=23263038&timestamp=1472001656#t1472001656
12:34:10 <KraySea> hello
12:34:21 <KraySea> grep <
12:34:44 <KraySea> hello>
12:34:46 <KraySea> ?
12:35:07 <KraySea> anyone here? can someone please say something so I know if this works?
12:35:17 <ragone> It works
12:35:25 <KraySea> aw thannks, yes it does
12:35:35 <ragone> ^^
12:35:50 <KraySea> ]is this channel for haskell only or can we talk other languages too 0.0
12:36:47 <ragone> Haskell only, unless related I guess?
12:37:09 <KraySea> ok well what is haskell for? is it web development, scripting...
12:37:36 <yushyin> general purpose language
12:37:46 <KraySea> so like c#?
12:37:50 <KraySea> or java?
12:39:21 <KraySea> i personally only know HTML and CSS, and im trying to learn other languages. I was thinking JS and Python, but before I begin I want to know more on the ones I havent heard much about
12:42:01 <marutk> this code http://lpaste.net/350737   from haskellbook.com  doesn't  compile   :-(
12:42:16 <marutk>   • Expecting one more argument to ‘State [String]’
12:42:16 <marutk>       Expected a type, but ‘State [String]’ has kind ‘* -> *’
12:42:16 <marutk>     • In the type signature:
12:42:16 <marutk>         addResult :: Integer -> State [String]
12:42:18 <KraySea> %g
12:42:19 <marutk> Fa
12:43:49 <marutk> type State s = StateT s Data.Functor.Identity.Identity :: * -> *
12:43:55 <ragone> KraySea: Very different languages you are listing. You should read up on the differences between JS, Python and Haskell (Interpreted, OOP and functional) before choosing.
12:44:24 <KraySea> will do, cheers
12:44:56 <ragone> But they can all achieve the same things
12:46:49 <MarcelineVQ> marutk: it should be   addResult :: Integer -> State [String] ()   it's an error in the latest version of the book not present in earlier ones
12:48:11 <marutk>    yeah,  it  works  now,  cheers
12:49:12 <MarcelineVQ> I think I made a report about it but it wouldn't hurt if you did too:  support@haskellprogramming.zendesk.com
12:49:14 <ertes> ragone: those are weird categories though…  haskell is interpreted, too
12:49:22 <ertes> as well as compiled
12:49:48 <ertes> python supports non-OOP procedural programming and can be both interpreted and compiled
12:49:51 <yushyin> KraySea: in my personal opinion one should start with a strong and static typed language as their first language, so js or python would be a bad start IMHO.
12:50:39 <marutk> will do
12:51:15 <ragone> ertes: Oh yeah, didn't mean respectively, just what he needs to be aware of instead of focusing on syntax differences.
12:55:40 <marutk> why is module name different ? module Control.Monad.Trans.State.Lazy    https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-State.html.      But  we import Control.Monad.Trans.State
12:56:07 <amx> what/where is this ctf mentioned in the topic?
12:57:08 <yushyin> amx: 33c3 ctf
12:57:15 <amx> ah, a bit late for that
12:57:22 <yushyin> :D
12:57:59 <shapr> you can still do Advent of Code!
12:58:19 <amx> almost done with that!
12:58:47 <KaneTW> is there something like https://hackage.haskell.org/package/syntax but for binary data/
13:00:04 <agent_sm1th> I'm reading Learn you a Haskell, and you have this Tree type:
13:00:04 <agent_sm1th> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)
13:00:04 <agent_sm1th> That's made an instance of Foldable:
13:00:04 <agent_sm1th> instance Foldable Tree where
13:00:04 <agent_sm1th>     foldMap f EmptyTree = mempty
13:00:04 <agent_sm1th>     foldMap f (Node x l r) = F.foldMap f l `mappend` f x `mappend` F.foldMap f r
13:00:04 <agent_sm1th> And they create some random Tree:
13:00:05 <agent_sm1th> testTree = Node 5 (Node 3 EmptyTree EmptyTree) (Node 6 EmptyTree EmptyTree)
13:00:05 <agent_sm1th> But now I'm really puzzled why you can do:
13:00:06 <agent_sm1th> foldl (+) 0 testTree
13:00:24 <agent_sm1th> I mean, Num is not a Monoid.
13:04:05 <lifter> If I want to find the leftmost element of a list satisfying some predicate, is it more efficient to use "find" as opposed to using "filter" (w/ "case" and pattern matching to extract the head element of the results)?
13:05:03 <lifter> I suppose that in any case "find" would be more idiomatic...
13:05:19 <Akii> is this a weird way of saying you want the first matching element in a list?
13:05:30 <lifter> Yes.
13:05:37 <geekosaur> should be about the same due to laziness (and both prone to explode if the list is infinite and not lazy enough)
13:05:39 <Akii> that is O(n) anways
13:07:08 <EvanR> theres differently performing O(n) things
13:07:13 <geekosaur> agent_sm1th, take a look at the definitions of foldl and foldr
13:07:17 <Akii> actually sorry, no idea if it is equal to filter
13:07:47 <agent_sm1th> geekosaur: I'm just puzzled why a Num can act as a Monoid without having imported Data.Monoid.
13:07:51 <geekosaur> (hint: the numbert isn't the monoid)
13:08:00 <agent_sm1th> Alright I will look at the definition.
13:08:12 <lifter> I'm talking like "find ((== x) . snd) xs" vs. "filter ((== x) . snd) xs" and then in the case of "filter" using some pattern matching to get the head of the results.
13:08:40 <lifter> "find" returns the first match in a "Just"
13:09:07 <EvanR> agent_sm1th: the monoid class is in Prelude
13:09:47 <geekosaur> and just importing Data.Monoid wouldn't help; the reason numbers aren't monoids is that there are two basic options, and no good way to pick one as default
13:09:58 <geekosaur> so you must specify with the Sum or Product newtypes
13:10:00 <agent_sm1th> Ah makes sense then.
13:10:13 <agent_sm1th> (+) 4 `mappend` 3 :: (Monoid a, Num (a -> a), Num a) => a -> a
13:10:17 <lifter> I would think that "find" would be more efficient that "filter", if "filter" is always going to traverse the entire list, but given the mechanics of laziness I'm not sure.
13:10:31 <geekosaur> filter is properly lazy
13:10:32 <agent_sm1th> It definitely doesn't do that.
13:10:32 <EvanR> Num (a -> a)...
13:10:36 <geekosaur> which is why I responded the way I did
13:10:38 <Akii> lifter: I think this is where lazy comes in
13:10:48 <Akii> from what I understand they whould be equal
13:10:54 <geekosaur> agent_sm1th, if it's not clear yet, the monoid is (id,(.))
13:11:04 <lifter> OK cool, thanks!
13:11:42 <agent_sm1th> geekosaur: It wasn't, so thanks for clarifying that 'magic'. ^_^ I'll study it.
13:11:50 <Akii> lifter: could you benchmark it though?
13:12:15 <lifter> I could, yeah. Honestly tho I don't want to at the moment. :)
13:12:19 <geekosaur> functions have a similar problem to numbers only there's even more possibilities, so we hide the (id,(.)) monoid as newtype Endo
13:12:29 <geekosaur> so you have appEndo and Endo
13:12:42 <Akii> lifter: then maybe you just ran into premature optimization xD
13:13:01 <lifter> Akii: Quite possibly.
13:13:50 <EvanR> agreed
13:13:52 <Akii> though at this point I just assume everyone in here is a pro
13:14:32 <lifter> I believe geekosaur
13:14:34 <lifter> :)
13:14:36 <EvanR> but its important to learn that filter doesnt "always go through the entire list"
13:14:48 <lifter> Yeah
13:14:50 <EvanR> its probably a good situation to study the filter code and understand why
13:14:50 <Akii> EvanR: tbh this is still a mystery to me
13:14:54 <Gurkenglas> Would be nice if we had a @check that timed execution times so we could just ask lambdabot whether listToMaybe . filter or find is faster.
13:14:59 <Akii> I know it does it but I don't know how
13:15:35 <EvanR> this code isnt necessarily what you will get, but it demonstrates the phenomenon
13:15:38 <EvanR> @src filter
13:15:38 <lambdabot> filter _ []     = []
13:15:38 <lambdabot> filter p (x:xs)
13:15:38 <lambdabot>     | p x       = x : filter p xs
13:15:38 <lambdabot>     | otherwise = filter p xs
13:16:10 <EvanR> it builds a new list consisting of only items that match the predicate
13:16:17 <agent_sm1th> It doesn't go through the whole list if it doesn't have to.
13:16:23 <Gurkenglas> > filter even [1..] -- this outputs 2 before traversing the entire list. If you do not ask for the second element, it stops after outputting two.
13:16:27 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
13:16:48 <EvanR> but x : filter p xs doesnt do like eager languages and call filter p now, then build a list node
13:16:52 <Akii> so it's basically evaluating thunk after thunk
13:17:00 <EvanR> its *not* evaluating
13:17:05 <EvanR> until you look into the rest of the list
13:17:10 <agent_sm1th> take 4 $ filter ((>) 5) [1..]
13:17:12 <agent_sm1th> ok
13:17:14 <agent_sm1th> take 5 $ filter ((>) 5) [1..]
13:17:17 <agent_sm1th> problem
13:17:33 <adarqui> is there anything similar to Shellac (for creating shell like environments) out there that I don't know about?
13:17:49 <adarqui> (for creating REPL environments)
13:17:51 <lifter> So in the case of "filter" *thunks* for traversing the entire list *will* be created?
13:18:06 <geekosaur> every time a value is needed, the runtime turns the crank on the current expression and evaluates it to the next constructor (here, (:) the list constructor) which gets the next element of the list
13:18:23 <EvanR> filter ((<) 5) [1..] = 1 : filter ((<) 5) [2..]
13:18:39 <lifter> ^^ Ah I see
13:18:40 <geekosaur> as long as the list is lazy / doesn't refer to later entries in constructing the value of the current one, the evaluation stops again at that point
13:18:41 <EvanR> you have to take the 1 : filter ((<) 5) [2..] seriously
13:19:01 <EvanR> lifter: no they wont
13:19:15 <lifter> That is really cool.
13:19:16 <EvanR> a single thunk is created
13:19:31 <geekosaur> yes, there is one thunk representing the computation for the rest of the list
13:19:39 <lifter> Wow!
13:19:41 <EvanR> but thunks isnt a great way to understand this from purely syntactic leve, you can think of it as expressions that are evaluated lazily
13:19:47 <geekosaur> on each evaluation, you get (next value : thunk for the rest of the list)
13:20:14 <geekosaur> and it just keeps stepping through those until you stop requesting values, or it hits [].
13:20:25 <lifter> Right.
13:21:04 <EvanR> more generally when you look at a list you will see expr1 : expr2 or []
13:21:16 <EvanR> expr1 and expr2 might not be fully evaluated
13:21:52 <agent_sm1th> Are there any more advanced books to read after Learn You a Haskell?
13:21:53 <EvanR> in this case expr1 was evaluated because you did a test on the number
13:22:01 <EvanR> and expr2 wasnt
13:22:15 * maerwald wants to burn lyah
13:22:17 <agent_sm1th> Or am I going to have to read Haskell code to further my understanding now.
13:22:30 <agent_sm1th> I mean, without hand holding.
13:22:39 <EvanR> more like write haskell code ;)
13:22:44 <maerwald> @where learnhaskell
13:22:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:22:46 <lifter> agent_sm1th: Start writing Haskell ASAP
13:22:48 <Eduard_Munteanu> agent_sm1th, try wikibooks, they cover some advanced topic pretty well
13:23:00 <Eduard_Munteanu> @where wikibooks
13:23:00 <lambdabot> I know nothing about wikibooks.
13:23:04 <agent_sm1th> lambdabot: Thanks for the link.
13:23:04 <Eduard_Munteanu> Gr.
13:23:26 <Eduard_Munteanu> https://en.wikibooks.org/wiki/Haskell
13:26:46 <Akii> agent_sm1th: I can think of two ways: either you know nothing after LYAH or you know how to FP. I didn't know how to FP after LYAH so I went for haskellbook
13:27:03 <ggVGc> I don't think lyah is very good at all
13:27:09 <ggVGc> it's okay as an occasional reference
13:27:19 <Akii> chances are very good you get bored reading haskellbook if you know basic FP
13:27:27 <geekosaur> it's a great overview
13:27:33 <geekosaur> but overview is as far as it goes
13:27:35 <maerwald> an overview is concise
13:27:36 <Akii> even though there is awesomesauce in there
13:27:40 <maerwald> lyah is not concise
13:27:41 <geekosaur> or as monochrom put it, it's a 2 hour movie trailer
13:27:51 <agent_sm1th> Haskell Book is way too slow for me, same goes for "the craft of functional programming"
13:28:11 <Akii> agent_sm1th: I've not finished haskell book
13:28:11 <agent_sm1th> The latter is basically LYAH stretched to 600 pages.
13:28:24 <maerwald> lol
13:28:28 <Eduard_Munteanu> Wow, and I thought LYAH was stretched.
13:28:34 <EvanR> agent_sm1th: then maybe you want the yorgey course, which has exercises
13:28:38 <Akii> but I do return to it ever so often to learn insights
13:28:54 <EvanR> @where cis194
13:28:54 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
13:29:21 <Akii> there is always hoogle to ask
13:31:47 <maerwald> someone should add that review "lyah stretched to 600 pages" to the haskellbook page :D
13:31:59 <maerwald> I only read positive reviews there
13:39:50 <pie___> if i wanted to embed haskell in my application kind of like how some programs have pyhton in them, how much space would that take up?
13:41:17 <agent_sm1th> Haskell book is LYAH stretched to 1000 pages
13:41:27 <agent_sm1th> I was talking about a different book
13:41:58 <agent_sm1th> To be fair I think it covers a bit more than LYAH
13:42:31 <agent_sm1th> but the lack of critical reviews is suspicious to say the least
13:42:55 <shapr> maerwald: I think it's 1100 pages now, but the content is much more, I will give my positive review!
13:43:17 <shapr> agent_sm1th: I bought a copy of that book for myself, and one or two copies for friends.
13:43:35 <agent_sm1th> Also overwelmingly positive reviews on Goodreads I see: http://www.goodreads.com/book/show/25587599-haskell-programming
13:44:00 <shapr> I have my PDF copy of "Haskell from First Principles" open on my laptop most days.
13:44:30 <shapr> agent_sm1th: I thought an experience Haskeller like myself would find nothing new in that book, but I've learned much!
13:44:35 <jmcarthur> pie___: You mean how much larger would your binary be?
13:45:02 <pie___> jmcarthur, yeah i guess
13:45:20 <pie___> tobe honest i dont actually know what my options are so im kind of just assuming i have to have like all of ghc in it or something
13:45:26 <jmcarthur> pie___: I'm not sure, but I think it might make sense to just measure the size of a helloworld, if you just want the size of the RTS, etc.
13:45:59 <jmcarthur> pie___: Oh... it depends on what you mean by "embed."
13:46:30 <jmcarthur> pie___: I was at first thinking you just meant that you were thinking of exposing some static Haskell functions to call from another language.
13:46:59 <jmcarthur> pie___: But if you mean you want to be able to dynamically interpret or compile Haskell code... probably a lot larger of a footprint, yeah.
13:47:17 <pie___> yeah thats what i mean
13:47:36 <pie___> though before that i kind of need to figure out how one "does that right"
13:47:45 <pie___> what even is such a thing generally useful for, etc
13:47:53 <Tuplanolla> You have to use GHC as a library, pie___.
13:47:58 <pie___> because all i have right now is "i want my program to be flexible and extensible etc"
13:48:03 <Tuplanolla> It's big and messy.
13:48:44 <pie___> im kind o fhoping someone else has done most of the hard work already though :PP
13:48:51 <pie___> and i think i have seen such things
13:49:35 <pie___> so yeah, you guys know any articles or guides or whatever on adding a whole language interpreter or whatever its called to an application correctly?
13:49:41 <pie___> in terms of usability i guess
13:52:44 <Athas> Does anyone know of what the original Haskell designers thought of SML?
13:53:03 <Athas> Specifically, their arguments for deviating from ML syntax?
13:53:42 <Athas> I'm curious about which differences were because they had come up with something better (Haskell is younger, after all), and which were just subjective aesthetics.
13:54:57 <ertes> pie___: have your program be a library instead of a program
13:55:20 <ertes> pie___: see hakyll, shake and xmonad for notable examples
13:55:43 <pie___> ertes, ok but i still have to interface the stuff somehow and idk?
13:56:02 <pie___> i guess this is a very software architectury question
13:56:06 <pie___> but that makes sense
13:56:09 <ertes> you could say that xmonad is not a window manager, but a window manager *framework*…  it's a library…  you "configure" xmonad by writing a program that uses the library
13:56:34 <ertes> in the same way shake is a build system *framework*…  your "makefile" equivalent is a haskell program that uses the shake library
13:56:45 <ertes> and hakyll is a framework for static site generators
13:56:59 <pie___> i mean i also want to beable to do something like opening a repl in my app and be able to run some code in it to do something
13:57:18 <ertes> that's a different story…  in that case you need an actual interpreter like hint
13:57:20 <dunx> i like Xmonad, it's really flexible
13:57:41 <pie___> ertes, yeah you seem to have understood what i said differntly, whereas that is what i meant
13:57:44 <ertes> pie___: but ask yourself whether GHCi wouldn't already fill that role much better than a hand-crafted REPL
13:58:12 <ertes> pie___: fire up GHCi, load the XMonad module, and you have a REPL for xmonad
13:58:24 <pie___> ertes, im not saying i want to make my own, i just dont know how to go about this. sure if i can embed ghci in my app im fine with that
13:59:16 <ertes> pie___: if you want to experiment with making REPLs, there are a few libraries around to help you with that, e.g. haskeline (for the prompt) and hint (for embedding GHC)
13:59:30 <ertes> pie___: it's just not a common thing to do =)
13:59:36 <ertes> it makes sense for something like lambdabot 
13:59:39 <ertes> > 1 + 1
13:59:41 <lambdabot>  2
14:00:26 <pie___> ertes, im thinking about writing something that could benefit greatly from the ability for a user to sanely write a small bit of automation on the fly
14:00:36 <pie___> i guesssss conceptually like macros
14:01:04 <ertes> pie___: you mean something GHCi can't do?
14:01:06 <jmcarthur> Athas: I suspect it's just because Miranda's syntax was this way. I don't know the motivation for Miranda's syntax.
14:01:08 <pie___> but i dont mean i want to deviate from normal haskell stuff by that
14:01:34 <pie___> ertes, no im just trying to explain what i want to do better, keyword is trying :P
14:01:50 <ertes> pie___: an example would help =)
14:02:01 <jmcarthur> Athas: It looks like a yet earlier predecessor, SASL, also had similar syntax.
14:02:48 <jmcarthur> Athas: That in turn was based on Landin's ISWIM language (as in the Next 700 Languages paper)
14:03:10 <pie___> ertes, this might not be a very good example, just thought of it tryng to think of *something*,
14:03:20 <jmcarthur> Athas: That predates SML by quite some time.
14:03:20 <pie___> take for example the developer consoles you have in web browsers
14:03:39 <jmcarthur> Athas: So perhaps the more relevant question is why SML didn't go with that syntax. :)
14:03:42 <pie___> ertes, but maybe a better example is how emacs has that lisp thing that it has or what (ive never actually used it)
14:04:25 <ertes> pie___: now i'm imagining some kind of UI you have written that also includes a console to control it
14:04:57 <jmcarthur> Athas: Hilariously, SML is based on ML is based on ISWIM.
14:05:15 <Athas> jmcarthur: also a good question!  Maybe I think that ML was a bigger presence than it really was.
14:05:17 <ertes> pie___: that may be a valid use case for a custom REPL, if you want to have it built into the UI itself…  you can still use GHCi, but it would have to run separately
14:05:29 <jmcarthur> Syntactically, at least.
14:05:46 <Athas> jmcarthur: it's not just syntax, though.  Why type classes instead of modules?  Because they are simpler to implement?
14:05:52 <pie___> ertes, im not sure what you mean by running separately
14:06:09 <ertes> pie___: outside of your UI
14:06:16 <pie___> oh sure, i guess?
14:06:24 <ertes> pie___: i'd suggest to have a look at hakyll/shake/xmonad, just to get an idea of how the traditional approach works
14:06:29 <Athas> There are two key traits of Haskell that influenced its design: purity and laziness.  And I'm not really wondering about the consequences of those choices.  But there are a lot of other small differences.
14:06:36 <Athas> And really, Haskell has much cleaner syntax.
14:06:39 <pie___> ertes, though at the moment im more concerned with the internals things than with a UI, a UI repl cant be that hard (in theory)
14:06:48 <ertes> pie___: see if their approach solve your problem…  and if they don't, things like hint are ready for you to use =)
14:06:58 <jmcarthur> Athas: According to History of Haskell, type classes were initially just to solve the problem of overloading numeric operators and equality.
14:07:20 <pie___> ertes, but like, if i have something like this, would it be hard for the program to do introspection on itself? what do i even mean by that? how should i expose APIs/how can the rpl change the applications state?
14:07:29 <Athas> jmcarthur: right, that is a little nasty in SML.
14:07:37 <jmcarthur> Athas: You may want to read this. http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
14:07:44 <Athas> jmcarthur: thanks!
14:08:07 <ertes> pie___: GHCi supports threads, so it can remain fully responsive while the program is running
14:08:18 <ertes> pie___: then you can communicate with it using the usual concurrency abstractions
14:08:25 <geekosaur> on the flip side, iirc Wadler? has said that swapping : for :: was probably a mistake in retrospect
14:08:43 <pie___> ok hint looks very promising
14:09:08 <pie___> ertes, is there a way for me to find projects that use hint?
14:09:11 <Gurkenglas> Why is it Control.Monad.State, but Control.Monad.Trans.Maybe?
14:09:14 <geekosaur> (but it's worth remembering that, back then, cons lists were a lot bigger part of FP because of Lisp's influence)
14:09:15 <Athas> geekosaur: definitely agreed, but I think that is a leftover from Miranda.
14:09:25 <ertes> pie___: that's how i can test my xmonad configuration right from my emacs session using its integrated GHCi…  no need for a potentially clumsy custom REPL that xmonad made and that i can't integrate into my development experience =)
14:09:48 <ertes> pie___: there is a reverse dependency tool somewhere, but i don't know where
14:10:04 <ertes> pie___: lambdabot and tryhaskell are the only projects i can think of right now that use it (indirectly)
14:10:30 <geekosaur> Gurkenglas, because the point of the latter is not defining the Maybe monad (that's in Prelude), but MaybeT
14:10:42 <pie___> it would be awesome if theres something that uses it in a similar way as i want to
14:11:32 <geekosaur> whereas Control.Monad.State originally defined both State and StateT; having that simplified to StateT and a newtype over StateT Identity came from mtl2 via transformers
14:11:35 <ertes> pie___: the lack of examples of that should indicate something
14:11:55 <pie___> ertes, yeahhhhh, im not sure what its supposed to indicate though :P
14:12:24 <ertes> pie___: again: look at hakyll, shake and xmoand
14:12:26 <ertes> xmonad
14:12:32 <pie___> ok, thanks
14:12:39 <geekosaur> (MaybeT is only a very recent addition to mtl, for a very long time it was a separate package)
14:13:09 <geekosaur> so, basically, a lot of history
14:13:26 <ertes> pie___: they do *not* integrate an interpreter, yet they are extensible in haskell the way you said…  unless i misunderstood you, in which case you should come up with an example
14:13:52 <ertes> pie___: the projects that do use hint are projects that run *user-supplied* code in some way…  for example lambdabot evaluates code that is written on IRC
14:14:07 <pie___> ertes, i did try to provide some examples?
14:14:14 <pie___> ertes, maybe i can give a more concrete one
14:15:01 <pie___> ertes, hypothetically i should be able to open the javscript console in my browser on say facebook, and possible call some already loaded javascript libraries or manipulate the DOM myself or whatever
14:15:24 <ertes> pie___: so you need a javascript interpreter?
14:15:35 <pie___> ertes, i need a haskell interpreter (re: hint)
14:16:11 <ertes> pie___: you want that haskell interpreter to be embedded in your own UI?
14:16:14 <pie___> yes
14:16:26 <pie___> (if im understanding you correctly)
14:17:00 <ertes> ok, hint can do that (or preferably mueval, if the code is not trusted)
14:17:21 <ertes> pie___: the way i understood you is that you want your program to be extensible in haskell
14:17:26 <pie___> with the rest of my application in scope for the code that i run in the interpreter in, so that i can do things
14:18:13 <pie___> so for the sake of example, i have a text editor with said embedded repl, or something, i can tell it to delete every 5 letter word in the currently open document
14:18:15 <pie___> or something
14:18:38 <pie___> by writing some haskell code in the repl then executing it
14:19:05 <ertes> pie___: the editor yi is a haskell-extensible editor, but it uses the same approach that xmonad and the others use
14:19:33 <pie___> i dont actually want to write a text editor, that was just an example, but ill check it out
14:19:48 <ertes> sure…  i'm just feeding you examples =)
14:20:01 <Eduard_Munteanu> You can use ghci like emacs does.
14:20:23 <pie___> Eduard_Munteanu, problem is ive never really used emacs, i just have some vague idea of it
14:21:26 <Eduard_Munteanu> You spawn a ghci instance and talk to it. It's just not very lightweight.
14:22:07 <ertes> GHC in general is not lightweight…  a haskell interpreter can take a few hundred MiB of RAM, hint or not
14:22:19 <pie___> ok, ill keep that in mind :/
14:24:27 <Eduard_Munteanu> Can Safe Haskell sandbox code at the source level? Something like limiting importable modules and such.
14:25:43 <Eduard_Munteanu> I was thinking of a Haskell-based mechanism for limiting access in an OS that only runs Haskell code.
14:26:49 <isd> Eduard_Munteanu: look at what lambdabot does.
14:27:31 <isd> You do need to be careful about what modules/imports you allow; obviously unsafePerformIO breaks *everything*.
14:27:46 <isd> Also, language-based os protection mechansims are totally a thing
14:27:48 <Eduard_Munteanu> Yeah, I should. Though I think interpretation might hurt performance.
14:27:54 <isd> search term: "signle address space operating system"
14:28:07 <Eduard_Munteanu> Yes, I've seen stuff like that around.
14:28:11 <shapr> Did SafeHaskell start from dons' efforts with mueval?
14:28:19 <ertes> @let import System.IO.Unsafe
14:28:21 <lambdabot>  .L.hs:144:1: error:
14:28:21 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
14:28:21 <lambdabot>      The module itself isn't safe.
14:28:23 <ertes> ;)
14:28:27 <Eduard_Munteanu> I think SafeHaskell is mainly concerned with compile-time safety.
14:28:48 <Eduard_Munteanu> Hm. Cool.
14:28:49 <isd> iirc lambda just restrits the list of legal modules and adds a timeout/memory cap
14:29:23 <ertes> it's concerned with semantic safety…  lambdabot does not run IO actions, but unsafePerformIO would enable a semantic backdoor into IO
14:29:44 <Eduard_Munteanu> isd, there's also F* from MS which can generate code along with a proof of safety.
14:29:46 <isd> *lambdabot
14:29:53 <ertes> so in a way safe haskell is about "importing only modules such that the types you see actually are what you think they are"
14:30:04 <ertes> evaluating an Int does not suddenly read /etc/passwd, for example
14:30:18 <isd> But yeah, if you wanted to use SafeHaskell for an actual security mechanism, you'd need to insist on doing the compilation yourself and/or interpreting
14:30:22 <ertes> example:
14:30:25 <ertes> @let import System.IO
14:30:31 <lambdabot>  Defined.
14:30:32 <ertes> totally safe
14:30:46 <Eduard_Munteanu> Compiling yourself would be more tractable, I think.
14:31:24 <ertes> of course the real solution is a proper container around lambdabot, which is also in place (in case safe haskell fails)
14:31:49 <isd> But yes, the problem with unsafePerformIO isn't that it does IO, it's that it makes the type system unsound, so you can use it to sidestep the security mechansim
14:32:30 <Eduard_Munteanu> Well, safe code could run even on MMU-less CPUs or without address space separation.
14:32:31 <isd> And yeah, single address space OSes are a thing, but in most contexts there's not really a good reason to strip out the normal OS machinery if you've got it.
14:33:38 <bennofs> If you use Safe Haskell, beware of #9858: https://ghc.haskell.org/trac/ghc/ticket/9858
14:34:19 <isd> Probably worth disallowing most language extensions too.
14:34:29 <ertes> hmm
14:34:36 <ertes> @let import Data.Dynamic
14:34:38 <pie___> i think theres something called language theoretic securit yor somethng like that
14:34:39 <lambdabot>  Defined.
14:34:58 <isd> But yes, defense-in-depth and all: if you've *got* mmu protection, use it.
14:35:26 <Eduard_Munteanu> Hopefully it can be abstracted away, at least.
14:35:30 <ertes> @let data A = A
14:35:32 <lambdabot>  .L.hs:197:1: error:
14:35:32 <lambdabot>      Multiple declarations of ‘A’
14:35:32 <lambdabot>      Declared at: .L.hs:183:1
14:35:37 <ertes> @let data Ah = Ah
14:35:39 <lambdabot>  Defined.
14:35:54 <isd> software has bugs, even compilers. you want to minimize their impact, and that implies not being 100% dependent upon the correctness on everything in your stack.
14:35:59 <ertes> > fromDynamic (toDyn (Proxy :: Proxy Ah)) :: Maybe (Proxy 'A)
14:36:02 <lambdabot>  error: Not in scope: data constructor ‘A’
14:36:04 <bennofs> ertes: lambdabot runs ghc 8, doesn't it?
14:36:07 <ertes> > fromDynamic (toDyn (Proxy :: Proxy Ah)) :: Maybe (Proxy 'Ah)
14:36:09 <bennofs> ertes: or at least 7.10.x?
14:36:10 <lambdabot>  Nothing
14:36:16 <ertes> bennofs: just testing =)
14:36:31 <ertes> and yes, i believe it's GHC 8
14:37:02 <ertes> :t Proxy :: forall a. forall (b :: a). b -> *
14:37:04 <lambdabot> error:
14:37:04 <lambdabot>     Not in scope: type constructor or class ‘*’
14:37:04 <lambdabot> error: Operator applied to too few arguments: *
14:37:20 <ertes> :k Proxy :: forall a. forall (b :: a). b -> *
14:37:23 <lambdabot> error: parse error on input ‘::’
14:37:27 <bennofs> :k Proxy
14:37:29 <lambdabot> k -> *
14:37:38 <ertes> i just wanted to see whether TypeInType is enabled
14:39:01 <ertes> @let data X :: forall a (b :: a). b -> * where
14:39:01 <lambdabot>  Parse failed: Parse error: ::
14:39:22 <ertes> hmm…  syntax error?!
14:39:58 <Eduard_Munteanu> Do we have polymorphic sorts? :/
14:40:32 <ertes> Eduard_Munteanu: when TypeInType is enabled, then type = kind = sort = …
14:41:10 <ertes> it collapses the whole universe cascade into two levels:  values and types
14:42:44 <geekosaur> ertes, looks like hint/mueval/possibly haskell-src-exts wasn't updated for that syntax, or mueval isn't enabling it?
14:43:26 <ertes> geekosaur: i'd expect that syntax to work when at least KindSignatures is enabled, which it is
14:43:40 <ertes> ("work" syntactically…  it would still be rejected)
14:44:06 <ertes> @let data WeHaveKindSigs :: * where
14:44:06 <lambdabot>  Parse failed: Parse error: EOF
14:44:19 <ertes> @let data WeHaveKindSigs :: * where Blah :: WeHaveKindSigs
14:44:21 <lambdabot>  Defined.
14:44:23 <ertes> oh
14:44:43 <ertes> @let data X :: forall a (b :: a). b -> * where X :: X ()
14:44:43 <lambdabot>  Parse failed: Parse error: ::
14:44:46 <ertes> nope
14:45:41 <ertes> @let data X :: a -> (b :: a) -> * where {}
14:45:41 <lambdabot>  Parse failed: Parse error: ::
14:45:55 <ertes> @let data X :: forall a. (b :: a) -> * where {}
14:45:55 <lambdabot>  Parse failed: Parse error: .
14:45:59 <ertes> ok, sorry for the noise
14:46:00 <mrbackend> pl \x y -> x y
14:46:03 <geekosaur> so, nested kind sigs?
14:46:36 <ertes> @let data X a (b :: a)  -- last try
14:46:37 <geekosaur> and forall. "nice"
14:46:38 <lambdabot>  .L.hs:202:16: error:
14:46:38 <lambdabot>      Type variable ‘a’ used in a kind.
14:46:38 <lambdabot>      Did you mean to use TypeInType?
14:46:48 <ertes> hah!
14:46:52 <ertes> there we go…  TypeInType is off
14:47:02 <ertes> geekosaur: TypeInType allows that kind of stuff
14:47:06 <mrbackend> @pl \x y -> x y
14:47:06 <lambdabot> id
14:47:08 <ertes> sorry
14:47:11 <ertes> geekosaur: TypeInType allows that type of stuff
14:47:16 <ertes> =)
14:47:19 <MarcelineVQ> :X
14:47:59 <geekosaur> yeh, so no TypeInType in haskell-src-exts presumably, since that's being used to preprocess / sanity check before feeding to ghc
14:48:18 <geekosaur> or at ;east in the version last used to build lb
14:49:24 <ertes> so something like "1 + + 2" is not actually rejected by GHC?
14:49:28 <ertes> > 1 + + 2
14:49:31 <lambdabot>  <hint>:1:5: error: parse error on input ‘+’
14:50:36 <ertes> seems to reach at least hint
14:50:41 <mrbackend> @let a = Just (::)
14:50:41 <lambdabot>  Parse failed: Parse error: ::
14:51:00 <mrbackend> @let a = Just (*)
14:51:03 <lambdabot>  Defined.
14:51:34 <mrbackend> a <$> Just 2 <*> Just 3
14:51:49 <geekosaur> I think there's at least 3 levels of parsing going on: mueval, hint, ghc
14:51:51 <mrbackend> @let b = a <$> Just 2 <*> Just 3
14:51:53 <lambdabot>  .L.hs:202:5: error:
14:51:53 <lambdabot>      Ambiguous occurrence ‘a’
14:51:53 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
14:52:14 <mrbackend> @let b = Just (*) <$> Just 2 <*> Just 3
14:52:16 <lambdabot>  .L.hs:202:5: error:
14:52:16 <lambdabot>      • Couldn't match expected type ‘Integer -> Integer -> b’
14:52:16 <lambdabot>                    with actual type ‘Maybe (Integer -> Integer -> Integer)’
14:52:34 <MarcelineVQ> simple idenfitifers are reserved by SimpleReflect with lambdabot, avoid any single characters identifiers if you want to play :>
14:52:37 <geekosaur> hint needs to figure out what it will get back from ghc, mueval is just looking for potential bot bombs iirc
14:52:40 <mrbackend> @let b :: Integer = Just (*) <$> Just 2 <*> Just 3
14:52:46 <lambdabot>  .L.hs:202:16: error:
14:52:46 <lambdabot>      • Couldn't match expected type ‘Integer -> Integer -> b0’
14:52:46 <lambdabot>                    with actual type ‘Maybe (Integer -> Integer -> Integer)’
14:52:50 <MarcelineVQ> also if you're not demonstrating something you can message lambdabot privately
14:52:57 <MarcelineVQ> with /msg or /query
14:54:10 <mrbackend> Thanks!
14:54:13 <polyguy> :t (*) <$> Just 2 <*> Just 3
14:54:15 <mrbackend> 1st time here
14:54:16 <lambdabot> Num b => Maybe b
15:33:09 <libscott> Anyone here use Control.Monad.Except?
15:33:29 <libscott> kind of a drag that `fail` doesn't return a Left
15:33:51 <libscott> also it doesn't export a utility function to convert an Either to an ExceptT
15:38:51 <Cale> libscott: It's not a drag -- that allows the instance of Monad to apply to more than Either String
15:38:57 <Cale> :t fail
15:38:59 <lambdabot> Monad m => String -> m a
15:39:05 <Cale> If you tried to say that fail = Left
15:39:25 <Cale> Then it only works for Either String, and not for other types
15:42:24 <Gurkenglas> Then why don't we have MonadFail (Either String)?
15:42:49 <ertes> :t either throwError pure
15:42:52 <lambdabot> MonadError e m => Either e a -> m a
15:43:18 <Gurkenglas> fail's on track to leave Monad anyway
15:43:53 <ertes> i'm so glad about that…  i'll be a lot more comfortable using partial pattern matches once that happens
15:44:19 <Gurkenglas> (Or rather IsString e => MonadFail (Either e))
15:46:51 <Jean-Paul> Hello. I wrote fast_exp b 0=1 fast_exp b n 	|even n=fast_exp (fast_exp b (n/2)) 2 	|otherwise=b*(fast_exp b (n-1)) . Haskell induces that its type is fast_exp :: (Fractional a1,Integral a1,Num a) => a -> a1 -> a, but when I put this line above my function in the code, it would not compile. I don't understand the error.
15:48:04 <Gurkenglas> @paste the error on lpaste?
15:48:04 <lambdabot> Haskell pastebin: http://lpaste.net/
15:49:18 <lpaste> Jean-Paul pasted “Function and error” at http://lpaste.net/350745
15:50:10 <ertes> Jean-Paul: i'm not aware of any types that are Fractional and Integral at the same time
15:50:18 <libscott> Cale: yes, you're right
15:50:37 <ertes> Jean-Paul: do not use the (/) function…  instead use either 'div' or 'shiftR' from Data.Bits
15:50:40 <geekosaur> guessing the conflict there is between (/) and even
15:51:07 <ertes> > shiftR 50 1
15:51:10 <lambdabot>  25
15:51:11 <ertes> > shiftR 25 1
15:51:14 <lambdabot>  12
15:53:08 <ertes> Jean-Paul: (side note: if you use shiftR, then all you need is a Bits constraint on the exponent type)
15:53:25 <ertes> oh, and Eq/Num for comparison to 0
15:54:44 <Jean-Paul> OK, thank you. I will change this. But what makes me wonder is that (Fractional a1,Integral a1,Num a) => a was the type infered by Haskell !
15:55:39 <geekosaur> because Haskell just manipulates typeclasses, it doesn't know what they mean
15:55:54 <geekosaur> so it can't know that no law abiding numeric type can be both Integral and Fractional
15:56:06 <hpc> there's nothing built in that says Fractional and Integral are mutually exclusive
15:56:08 <ertes> actually
15:56:12 <ertes> > zeroBits :: Integer
15:56:15 <lambdabot>  0
15:56:16 <ertes> don't even need Num =)
15:56:23 <geekosaur> (there are periodic discussions about beefing up the type system to handle laws like that, but it's a Hard Problem in many cases)
15:57:47 <geekosaur> and it only discovers the problem when you actually try to use the function and it can't find a type that fits the constraints
15:58:14 <geekosaur> (or rather that no matter what type you use when applying it, at least one of those constraints will fail)
16:00:00 <Cale> Gurkenglas: Yes, that would be the sensible thing
16:00:46 <Jean-Paul> OK, I kind of get it. It compiles without the prototype but won't work.
16:00:51 <Jean-Paul> Thank you.
16:01:29 <geekosaur> even with it, it compiles the definition fine but can't compile any use of it --- you would see this if you put all the uses in a separate source file importing the one with the definition
16:01:39 <geekosaur> the definition would compile, the uses wouldn
16:01:41 <geekosaur> t
16:03:27 <ertes> Jean-Paul: i would expect this function to infinite-loop
16:04:49 <ertes> Jean-Paul: let me rename it to 'f':  f x 2 = f (f x 1) 2 = f (f (f x 1) 1) 2 = …
16:05:20 <ertes> Jean-Paul: you're using the following identity:  x^(2*e) = (x^e)^2
16:05:33 <ertes> Jean-Paul: but you should be using this one:  x^(2*e) = (x^2)^e
16:05:50 <ertes> and you know how to compute x^2 directly without recursively using your function
16:06:47 <ertes> if you want it to work the way you have written it, you need a special case for the exponent 2
16:06:57 <ertes> fastExp x 2 = x*x
16:07:51 <ertes> but then the adjective "fast" would no longer be appropriate, as it would be even slower than the naive algorithm =)
16:08:32 <ertes> hmm…  actually no, it would still be logarithmic due to sharing
16:11:11 <lpaste> Jean-Paul pasted “Code which is ok” at http://lpaste.net/350748
16:11:28 <Jean-Paul> OK, thank you. Happy new year.
16:11:46 <pie_> anyone know if arecodring of this exists? http://galois.com/blog/2009/04/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
16:12:37 <hpc> or the slides even, the link is now 404
16:14:20 <pie_> wow seriously the slides dont exist even on archive.org?
16:14:31 <pie_> s/?/./
16:22:32 <ertes> woah…  the Bits-based version is *way* faster than the built-in Integral-based (^)
16:23:37 <ertes> 3^(3^100000 :: Integer) :: Word  -- takes 6267 ms
16:23:46 <ertes> fastExp (3^100000 :: Integer) 3 :: Word  -- takes 14 ms
16:24:21 <pie_> figures that scribd has it https://www.scribd.com/doc/19502765/Engineering-Large-Projects-in-Haskell-A-Decade-of-FP-at-Galois
16:25:43 <Redrield> Is there an alternative for Scion that works with Emacs?
16:26:02 <ertes> https://gist.github.com/esoeylemez/66102bdc32c386d9e3b413b1d31f8722
16:26:10 <ertes> Redrield: what is scion?
16:26:22 <Redrield> It describes itself as a Haskell IDE library
16:26:45 <Redrield> I think it runs as a daemon and provides feedback to make editors like emacs and vi more intelligent, autocomplete, stuff like that
16:26:55 <jmcarthur> Intero?
16:26:56 <Redrield> I found it on the wiki, and it seems that the project is dead
16:26:58 <geekosaur> scion's an ancient ide toolkit. I didn't know it even built these days
16:27:02 <ertes> Redrield: there are language-specific things…  for example i use haskell-mode
16:27:18 <systemfault> Never heard of scion... the newest thing seems to be "intero" but I haven't tried it yet.
16:27:21 <jmcarthur> I think haskell-mode + intero is probably the thing.
16:27:25 <Redrield> Alright
16:27:33 <Redrield> And yeah ertes I already have haskell-mode
16:27:34 <ertes> jmcarthur: they are mutually exclusive
16:27:54 <ertes> intero is probably better than haskell-mode, if you use stack
16:28:06 <ertes> if you don't use stack, you have to use haskell-mode
16:28:14 <jmcarthur> ertes: Well, intero depends on haskell-mode.
16:28:20 <ertes> oh, it does?
16:28:33 <ertes> i always thought it's a separate project
16:29:05 <ertes> then i guess it only adds stack-specific stuff to haskell-mode
16:30:29 <jmcarthur> ertes: ;; Package-Requires: ((flycheck "0.25") (company "0.8") (emacs "24.3") (haskell-mode "13.0"))
16:32:21 <ertes> i wish Bits had a 'highestBit' function
16:32:52 <hpc> ugh, gotta sign up to download from scribd
16:32:59 <Eduard_Munteanu> By the way, by 2017, does Cabal check signatures on packages?
16:35:07 <Eduard_Munteanu> I've been running a proxy to https://hackage.haskell.org for like ages.
16:35:13 <geekosaur> iirc the machinery is there but the new hackage isn't quite because of concerns with older clients? something like that, maybe ask in #hackage
16:40:35 <Redrield> How can I specify the stack.exe installation location to intero?
16:41:53 <jmcarthur> Normally I would say you don't (on Linux), but I'm guessing from your .exe extension that you're on Windows, so I wouldn't know. :(
16:42:27 <Redrield> Well I know it's on my PATH
16:42:30 <jmcarthur> Where by "don't" I would mean "it just has to be in your PATH," which actually I think has some meaning in Windows world, too.
16:42:32 <jmcarthur> Ah.
16:42:40 <Redrield> because I just made a new project with it
16:43:08 <Redrield> Error while checking syntax automatically: (file-error "Searching for program" "No such file or directory" "stack")
16:45:30 <Eduard_Munteanu> I'll bug #hackage after I check the git logs and source. I've been bugging them enough by now.
16:47:56 <ertes> Redrield: have you added it to PATH after you started emacs?
16:48:30 <houli> quick question about MonadTrans is there a reason lift is defined "lift :: Monad m => m a -> t m a" vs "lift :: (Monad m, Monad (t m))  => m a -> t m a"? compatibility?
16:49:08 <ertes> houli: the latter requires FlexibleContexts
16:49:22 <houli> guessed it was a standards thing yeah
16:49:52 <houli> flexible contexts is still a proposal right? not in 2010?
16:50:17 <ertes> it's non-standard, but it's an implemented extension
16:50:20 <hpc> the majority of extensions are still "just" proposals
16:50:53 <ertes> houli: also it would be weird to have that constraint on 'lift' itself…  it should really be a class constraint, but that doesn't work at all
16:50:55 <Eduard_Munteanu> Very little actually went into Haskell2010.
16:51:18 <ertes> class (forall m. (Monad m) => Monad (t m)) => MonadTrans t  -- something like this (pseudo-haskell)
16:51:43 <hpc> there were one or two "big" things and then a smattering of tiny nice things
16:51:53 <hpc> i would say FFI and the blessed language extension mechanism are the big things
16:51:54 <dcoutts> Eduard_Munteanu: yes
16:52:04 <hpc> nice to have is standard GADTs and removing n+k patterns
16:52:18 <ertes> hpc: huh?  GADTs are standard?
16:52:19 <houli> and where mtl diverges from haskell 98 is just the use of functional dependencies or does it reach beyond that?
16:52:29 <hpc> ertes: lemme check
16:52:43 <Eduard_Munteanu> dcoutts, cool, out of the box on recent cabal-install versions? Or do you still need to manually tell it to?
16:52:48 <hpc> oh, pattern guards
16:53:12 <dcoutts> Eduard_Munteanu: out of the box in cabal HEAD, and with some config in latest released version
16:53:19 <ertes> houli: it also needs FlexibleInstances
16:53:25 <Eduard_Munteanu> Great, thanks.
16:53:44 <ertes> houli: (at least)
16:53:47 <hpc> oh and the module hierarchy
16:53:55 <hpc> which was always a wink and a nudge away from standard
16:54:10 <ertes> i wish the next haskell standard is far less conservative
16:54:28 <hpc> i hope it stays just as conservative, and more things reach the bar for inclusion
16:54:41 <houli> ertes: ah and MultiParamTypeClasses of course
16:54:48 <houli> cool thanks
16:54:58 <ertes> add GADTs, KindSignatures, RankNTypes, TupleSections, TypeOperators, ViewPatterns, …
16:55:01 <hpc> GADTs should have probably been 2010, but i wouldn't want undecidable instances to become standard
16:55:38 <houli> it seems there are a lot of extensions that have made their way into the lingua franca of haskell these days at least in some use cases
16:55:41 <ertes> oh and FlexibleAnything
16:55:48 <hpc> yeah, flexible++
16:55:51 <hpc> undecidable--
16:55:52 <Eduard_Munteanu> MPTCs and all that have been in base libs since forever.
16:56:01 <houli> generic deriving mechanisms by default would be nice
16:56:09 <ertes> yeah, MPTCs and FunDeps, too
16:56:44 <hpc> there might be a little more attention to put into fundeps and the family mechanism, imo
16:56:56 <hpc> because they're close to the same thing but quite different in a number of ways
16:57:23 <ertes> TypeFamilies adds far more than a fundeps equivalent…  and i'd like to have that standard, too
16:57:34 <hpc> yeah
16:57:48 <hpc> if push came to shove, i would say families are standard and fundeps aren't
16:57:56 <hpc> but fundeps stay a ghc extension until we know what to do with them
16:58:06 <ertes> fundeps are useful in their own right…  there is no reason to leave them out
16:58:45 <ertes> they are more expressive than type families, and often they're just easier to work with (much less type-level noise)
16:59:08 <Eduard_Munteanu> Fundeps are stronger than type families.
17:00:14 <ertes> (MyClass m a) => a -> m a
17:00:20 <ertes> (MyClass a) => a -> Action a a
17:00:28 <ertes> pick your favourite =)
17:00:53 <Eduard_Munteanu> Not just that, but you can't have class/instance constraints on type families.
17:01:11 <ertes> Eduard_Munteanu: not without FlexibleContexts
17:01:26 <ertes> class (Monad (Action a)) => MyClass a where type Action a :: * -> *
17:01:38 <Eduard_Munteanu> Oh, wait, that should work.
17:01:43 <ertes> it does =)
17:02:04 <ertes> but here is one case that has no (direct) type family equivalent:  class C a b | a -> b, b -> a
17:02:25 <hpc> my point is, they both solve the problem of "class where types determine other types" in just close enough ways that i feel like there's something connecting them ;)
17:02:48 <ertes> hpc: and my point is: you're right, but we still need both =)
17:03:20 <Eduard_Munteanu> ertes, hm... I wonder if it's possible with nullary type classes in a meaningful way.
17:03:46 <Eduard_Munteanu> class C where { type A b; type B a }
17:04:08 <ertes> Eduard_Munteanu: unfortunately that's not quite enough to tell the type system that they determine each other uniquely
17:04:18 <ertes> oh wait
17:04:27 <ertes> we have injective type families now
17:04:58 <ertes> class C a where type F a = r | r -> a  -- perhaps something like that could work
17:04:59 <Eduard_Munteanu> Hm.
17:05:45 <ertes> indeed, it does!
17:07:24 <ertes> @let class C a where type F a = r | r -> a; change :: F a -> a
17:07:25 <lambdabot>  .L.hs:204:24: error:
17:07:26 <lambdabot>      • Illegal injectivity annotation
17:07:26 <lambdabot>        Use TypeFamilyDependencies to allow this
17:14:22 <mounty> What's the best way to obtain a list of fields making up the primary key of a table, using Database.HDBC ?
17:14:57 <hpc> how would you do it as an sql query?
17:15:50 <mounty> SELECT \"attname\" FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\"" ++ tableNameStr ++ "\"'::regclass ORDER BY a.attnum;"
17:15:53 <mounty> ugly.
17:16:46 <mounty> HDBC provides describeTable but annoyingly that does not state which columns constitute the primary key.
17:17:39 <hpc> does postgres have nothing like mysql's "show index from"?
17:21:58 <enferex> Hello, I'm having some trouble creating a pair of (String, Network.HTTP.ResponseCode)
17:22:39 <enferex> The string is trivial (just the hostname).  However, I get the ResponseCode from "getResponseCode" which returns an IO ResponseCode
17:23:31 <enferex> What I am trying to do is to use 'try' and if I get a valid response code I use that, if I get an exception I just create a dummy response code.
17:24:23 <geekosaur> you presumably want to look at http://www.vex.net/~trebla/haskell/IO.xhtml
17:24:33 <geekosaur> but, you either use do notation or you use >>=
17:24:42 <enferex> Right, and I am.
17:24:51 <enferex> >>=
17:24:53 <geekosaur> @paste code
17:24:54 <lambdabot> Haskell pastebin: http://lpaste.net/
17:25:25 <enferex> 1 sec, cleaning it up
17:26:31 <mounty> hpc:  I don't know but it doesn't really matter.  If I have to get the information via SQL, one expression is pretty much as good as another.
17:26:51 <mounty> hpc:  I was hoping for a direct API call.
17:30:17 <enferex> geekosaur: http://lpaste.net/350752   ...  I was working on this earlier today, back at it again.
17:30:47 <enferex> geekosaur: I realize that I have to stay within the IO monad for getResultBoolean (and should return a IO Bool)
17:31:32 <enferex> but hopefully you can suggest an alternate appraoch so that i can have a type of (HostName, Bool) instead of a type that contains (HostName, IO Bool)
17:34:41 <geekosaur> if you are using issueHttpRequest (or, for that matter, try), you must be in IO
17:34:50 <dmj`> enferex: you don’t need to return HostName if you’re passing it in as an argument
17:35:00 <geekosaur> and then use >>= or do in the caller
17:36:41 <enferex> Ultimately what i want is issueHTTPRequest to return a Bool... True if there is no exception or False otherwise.
17:37:49 <geekosaur> it will need to be an IO Bool
17:38:02 <enferex> ok
17:38:11 <dmj`> try (issueRequest h) >>= \r -> pure $ case r of Right _ -> True; Left (_ :: SomeException) -> False
17:38:48 <dmj`> could use lambda case, but then you’d need to write out pure twice
17:39:24 <enferex> dmj`: Rgabjs!
17:39:30 <enferex> Thanks
17:39:57 <suzu> rgabjs?
17:40:04 <quinn95> Is it possible to do something like this: make a class that contains a field (Such as a Positional class that contains position :: (Int, Int) and an accessor function, and then have multiple classes inherit the default implementation of it?
17:40:23 <enferex> suzu: hand was shifted incorrectly :)
17:40:29 <suzu> :)
17:41:02 <ertes> quinn95: what's the purpose?
17:41:11 <quinn95> so I can have Actor { ... } deriving (Positional) and Item { ... } deriving (Positional)
17:41:13 <dmj`> enferex: yw
17:42:09 <ertes> quinn95: are you trying to have multiple types with the same field?
17:42:20 <ReinH> quinn95: it sounds like you are asking for classes as in OOP
17:42:28 <geekosaur> ^
17:42:41 <geekosaur> typeclasses are not OOP; if you try to force them to be OOP, they will bite you
17:42:58 <quinn95> pretty much, yeah. What would be the best way to implement something like this?d
17:43:11 <ReinH> What is the problem for which you think this might be a solution?
17:43:11 <ertes> quinn95: well, have multiple types with the same field =)
17:43:45 <ertes> quinn95: data A = A { aPosition :: (Int, Int), … };  data B = B { bPosition :: (Int, Int), … };  …
17:43:58 <quinn95> I want to have a field across multiple types, and a single accessor function tat works for each of them
17:44:09 <dmj`> quinn95: you can put a lens in a typeclass
17:44:12 <haskell426> can someone help me, I got an error that I dont understand.... :-( http://lpaste.net/350753
17:44:30 <ertes> quinn95: the most straightforward solution is to give all of them the same name and then use the DuplicateRecordFields extension
17:44:32 <ReinH> I don't see the need for a typeclass.
17:45:04 <ertes> quinn95: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields
17:45:21 <ReinH> Well, if you want the same lens name, yes. And templateHaskell can generate the typeclass for you as well.
17:45:39 <ReinH> If you don't want lenses, see ertes's
17:46:20 <ertes> quinn95: caveat: sometimes you need to help the compiler figure out which of the accessor functions you meant, because they are still different functions just sharing the same name
17:47:12 <mbrock> depending on how you want to use the types, it can also make sense to have, for example, data Positional = Positional { position :: (Int, Int), thing :: Thing }
17:48:03 <mbrock> or more polymorphically, data Positional a = Positional { ..., thing :: a }
17:48:07 <quinn95> ok thanks everyone. So something like class Positional a where
17:48:07 <quinn95> 	pos :: Position
17:48:07 <quinn95> 	position :: a -> Position
17:48:07 <quinn95> 	position a = pos
17:48:11 <quinn95> would never work ever
17:48:28 <ertes> quinn95: if you're writing the word "class", you're probably doing it wrong =)
17:49:00 <ertes> quinn95: a type class can only provide a common interface…  you still need to have the field in each type that is an instance
17:50:02 <dmj`> quinn95: https://gist.github.com/dmjio/f5d09dbb3aa88fd2b0c9500366dfa1c0
17:50:55 <quinn95> Ok I get it now. Thanks!
17:52:07 <pie_> ertes, this thread appears very relevant https://www.reddit.com/r/haskell/comments/2dsh1d/embedding_a_haskell_interpreter_in_a_haskell_app/cjsn87l/
17:54:20 * dmj` likes micro lens
17:54:35 <pie_> from reading the posts im not sure if this actually works or not then? snk_kid's innermost post seems to suggest that it does?
17:56:44 <ertes> pie_: your earlier problem description is too vague to answer that…  you should have a problem first
17:57:41 <pie_> this seems like a pretty good example https://www.reddit.com/r/haskell/comments/2dsh1d/embedding_a_haskell_interpreter_in_a_haskell_app/cjszhpd/
17:59:00 <pie_> ertes, ^
17:59:38 <Gurkenglas> Hmm couldn't he do data Positional a = { position :: (Int, Int), payload :: a }, make a bunch of those if he wants multiple classes, then lift them through those specific wrappers mtl-style?
18:00:51 <ertes> pie_: "I don't have a concrete application this is more hypotheticals and some ideas so don't worry about it."
18:01:19 <pie_> the paragraph right after it mentions mnipulatingmeshes in 3d modeling :/
18:03:16 <ertes> pie_: yes, but i'd prefer to give advice on solving *specific* problems that *you* are trying to solve…  honestly i don't enjoy this kind of hypothesising, at least not in this particular area =)
18:03:50 <ertes> pie_: in any case using hint is actually a lot of engineering effort
18:04:26 <pie_> but its not a specific problem :I i want to have an interactive repl to my application :I
18:07:09 <enferex> dmj`, geekosaur: Thanks for the helpl
18:07:51 <geekosaur> pie_, I imagine you think adding a repl is as easy as it would be in python --- where every program does extra work behind the scenes so everything in the program will be available to a repl
18:08:47 <geekosaur> compiled programs rarely work that way, generally if you are compiling you care about performance and therefore don't want it adding extra stuff everywhere that takes extra time to maintain, on the off chance you might add a repl to manipulate stuff
18:09:32 <geekosaur> in particular, you can use hint to add a raw repl easily enough; it will run in a context that is not your program, but a context that it creates for itself. no access at all to the rest of your program
18:10:02 <pie_> geekosaur, no i dont imagine so, which is why im trying to find out more
18:10:10 <geekosaur> if you want to enable such access, *you* must do more work. and quite a lot of it, depending on what you want to expose and how you may need to design the rest of the program so that a repl can change things at any time
18:10:43 <ertes> that's why it generally doesn't happen, unless the requirement of a REPL is inherent in the application design
18:10:51 <ertes> lambdabot and tryhaskell would be examples of that
18:10:52 <pie_> geekosaur, see this is exactly the typ of stuff i want to know more about
18:11:49 <ertes> those *inherently* need a binding to the GHC API in order to interpret haskell as part of the application logic
18:11:50 <geekosaur> in particular, if you want stuff to be changeable at arbitrary times, you will have to store that stuff in IO and probably use some kind of mutex arrangement (I recommend STM) to ensure you're not changing it while something else is actively using or modifying it
18:12:52 <pie_> and precisely why im asking about it before getting into the deep of the project, because it appears that it needs to be designed in from the start and not tacked on afterwards >.>
18:13:26 <ertes> the first question i would consider is whether it's necessary
18:13:41 <ertes> GHCi covers most of the use cases of something like that
18:14:33 <geekosaur> so a design that might have used StateT MyState now must use ReaderT (IORef MyState) and STM's atomically... and the REPL interface needs to be able to run a transaction that retrieves the data, serializes it into the REPL context, runs the expression, serializes the data back out of the REPL, and update the state. and you need to decide if this is literally oen transaction (blocking anything else) or multiple (and what to do if data are modifi
18:14:33 <geekosaur> ed by both the REPL and some other part of the program at the same time)
18:14:52 <pie_> yes i think scriptability is necessary, but in the wors case i will just use something else like python, but if the app is still coded in haskell that still leaves the same API/access/interface issues no?
18:15:55 <ertes> pie_: scriptability has nothing to do with that…  i refer you (for the fifth time) to something like xmonad, which is fully "scriptable" and does *not* have a haskell interpreter built-in
18:19:56 <pie_> ertes, i still want in-the-loop scripting though. :P but i do have a couple xmonad related pages open now
18:20:06 <pie_> geekosaur, thanks il look into that
18:21:09 <ertes> then i suggest that you write an actual application and try it out
18:21:32 <geekosaur> but it may not do what they want, anyway; if you want an interactive visualization tool that accepts expressions, xmonad is not the way to go
18:21:40 <geekosaur> whereas a hook into ghci might be
18:22:22 <geekosaur> (or even grabbing ghci-ng from hackage and looking at integrating the logic of your program into it, instead of trying to integrate a REPL into your program
18:54:53 <pie_> geekosaur, that sounds funny but plausible
18:58:17 <TommyC> Stupid question: What are numbers that can be rational/irrational (but not integers) called? :3
19:00:38 <kadoban> TommyC: You mean the reals except *without* the integers? I'm not sure that has a name.
19:01:38 <TommyC> Ok, no wonder I was having a hard time finding a name. :3
19:01:47 <TommyC> kadoban: Thank you!
19:02:33 <kadoban> I wouldn't take my word for it, I'm far from a decent mathematician. But you're welcome.
19:02:52 <nshepperd1> nonintegers, i suppose
19:16:17 <jebacja> celObjPic.field_14 = (data+4) * celObjPic.info.cel + (data+0) 
19:17:54 <wespiser> ?
19:18:42 <jebacja> dddd
19:19:28 <jebacja> taak im
19:19:58 <jebacja> hi
19:20:40 <geekosaur> pie_, pretty sure there's already a few things on hackage that are essentially designed to be run from ghci, then you use ghci to interact with them. (aside from stuff like ghc-vis... although it might well be a good model for it)
19:21:02 <geekosaur> jebacja, ... hello?
19:21:03 <jebacja> https://www.youtube.com/watch?v=bk4WUWwIshE
19:21:15 <jebacja> welcome
19:21:18 --- mode: ChanServ set +o shapr
19:21:35 <shapr> jebacja: are you here to learn Haskell?
19:22:28 <shapr> jebacja: pass your Turing Test or get punted
19:22:55 --- kick: jebacja was kicked by shapr (Kicked by shapr)
19:22:58 --- mode: shapr set -o shapr
19:24:12 <pie_> oh god floating point numbers https://www.reddit.com/r/haskell/comments/4f47ou/why_does_haskell_in_your_opinion_suck/d268xda/
19:25:14 <shapr> pie_: IEE754 makes coders sad
19:25:27 <geekosaur> floating point is terrible everywhere. the problem is, the alternatives are all worse
19:25:28 <pie_> shapr, TIL :(
19:25:42 <pie_> and im stufying physics
19:25:48 <pie_> *studying
19:25:53 <geekosaur> ...where haskell falls down is that it tries to pretend they abide by number theoretical rules
19:25:56 <pie_> so gon' be plenty'o'floats
19:25:58 <kadoban> Ya, if your major problem with haskell is floating point ... I don't know a language you'd like.
19:26:12 <shapr> pie_: these days I use QuickCheck to show people the pain of floating point numbers.
19:26:58 <pie_> shapr, my first intro to float fun was that you have to test for epsilon distance instead of equaity
19:27:00 <pie_> *equality
19:27:08 <shapr> yup
19:27:11 <pie_> my second was 0.1+0.2
19:27:31 <shapr> that totally adds up to 0.3, sort of
19:27:39 <shapr> for some value of 0.3
19:27:44 <pie_> :P
19:28:15 <pie_> >>> 0.1+0.2
19:28:15 <pie_> 0.30000000000000004
19:28:20 <pie_> thats python for the record
19:28:23 <jle`> > 0.1 + 0.2
19:28:26 <lambdabot>  0.30000000000000004
19:28:34 <shapr> consistently broken?
19:28:36 <pie_> hrhr yes
19:28:50 <jle`> > fromRational (0.1 + 0.2)
19:28:53 <lambdabot>  0.3
19:29:01 <pie_> its a number represantation thing
19:29:10 <nshepperd> > 0.1 + 0.2 == (0.3 :: Double)
19:29:12 <lambdabot>  False
19:29:26 <nshepperd> :O
19:29:29 <pie_> well its obviously false given "<lambdabot>  0.30000000000000004"
19:29:37 <pie_> haha yes guys this is a thing :)
19:29:40 <pie_> or rather :(
19:29:44 <jle`> :|
19:30:01 <pie_> which is basically the reason you testfor closeness instead of equality
19:30:05 <pie_> probably.
19:30:26 <jle`> you can use infinite precision reals, but then equality is undecidable, so there's that
19:30:49 <pie_> right im just saying with the finite precision implementation or whatever it is
19:30:56 <nshepperd> I think that's actually because 0.1 :: Double isn't 0.1, and same with 0.2
19:31:02 <jle`> > 0.1
19:31:05 <lambdabot>  0.1
19:31:08 <nshepperd> > 0.1 + 0.2 == (0.1 + 0.2 :: Double)
19:31:11 <lambdabot>  True
19:31:33 <pie_> nshepperd, thats for saying the types match right?
19:31:57 <geekosaur> no. you can't represent some decimal fractional values exactly in fractional binary
19:32:02 <pie_> ^
19:32:14 <pie_> >0.3
19:32:20 <pie_> err
19:32:24 <pie_> > 0.3
19:32:26 <lambdabot>  0.3
19:32:31 <pie_> i was just curious
19:32:45 <pie_> > 0.3 + 0.0
19:32:48 <lambdabot>  0.3
19:32:54 <pie_> > 0.1
19:32:58 <lambdabot>  0.1
19:33:05 <pie_> > 0.1 + 0.0
19:33:07 <lambdabot>  0.1
19:33:12 <dfeuer> I'm curious: would it be possible to adapt ideas from Control.Lens.Traversal.confusing to come up with a more efficiently composable version of traverse?
19:33:13 <pie_> stuffs weird yo
19:33:22 <int-e> pie_: lambdabot responds in private chat
19:33:30 <dfeuer> Hi, int-e.
19:33:40 <pie_> int-e, good point
19:33:48 * int-e isn't really here.
19:33:53 <dfeuer> Oh well.
19:35:30 <nshepperd> the Show instance for floats prints as many decimal places as necessary to get the same number back, iirc
19:45:31 <codygman> ghci doesn't do any kind of optimizations, right? So adding an inline pragma to a function should have 0 effect when run in ghci, right?
19:46:43 <geekosaur> if ghci interprets the function, yes. if it is compiled, it's already optimized (but won't be inlined into interpreted code)
19:49:32 <codygman> geekosaur: Are you familar enough with ghci to know how difficult adding inlining would be or perhaps a choice of "makes faster but compiles quick" optimizations? There is a dearth of information out there about ghci... I spent a few hours the other day going through what does exist.
19:51:15 <geekosaur> the biggest problem isn't ghci /per se/. ghci is using the bytecode backend... which is also used by TH. and there's a fair amount of potential nastiness in optimizing that without having types at TH time leak into the main program's types, if I understand what's going on correctly (but I might well not...)
19:51:33 <geekosaur> (one of the problems may be that nobody knows well enough how it would interact!)
19:52:10 <KaneTW>  y
19:52:14 <KaneTW> whoops
19:52:35 <geekosaur> so, any changes you might make, you'd have to very carefully test their effects on programs using TH
19:54:14 <codygman> If anyone is curious, I basically want to be able to work from ghci more but I deal with relatively large data. Doing a Pipes.length on 999,999 items (vinyl records) takes 97.30 seconds. I suppose that the bottleneck there is likely the construction of the vinyl records though, actually.
19:55:10 <codygman> geekosaur: TH being template haskell? Yeah, it depending on the bytecod backend would complicate things and testing none of my changes broke TH seems tedious.
19:55:18 <geekosaur> yes
19:56:46 <codygman> geekosaur: As I talk about it though, I'm beginning to realize my bottleneck is likely the creation of vinyl records. After everything is in memory any computation is mostly instant.
19:57:05 <codygman> I suppose I don't have a good guideline for what "fast" means in this case either.
19:57:38 <MarcelineVQ> codygman: I've not used it myself but this may be useful to you https://hackage.haskell.org/package/rapid
19:58:22 <codygman> MarcelineVQ: :) I'm using rapid actually. It works fine for me up to around 5^6 records, but then I'm running out of memory.
19:58:52 <geekosaur> another potential trouble spot, one of the optimizations to IO code is that the native code generator recognizes RealWorld# and doesn't codegen it at all. the bytecode backend just carries around an uninitialized value pointlessly. and... someone poking at the relevant code (unboxed tuple handling) in ghc recently for a different purpose discovered the bytecode backend doesn't get enough information to deal with them properly in some cases... *
19:58:53 <geekosaur> might* be relevant here (or possibly only relevant if you used unsafePerformIO)
19:59:45 <codygman> thanks geekosaur, I get the feeling that information will be useful to me.
20:03:34 <codygman> Anyone had the error: "Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp-1.0.0.1’?", full error: http://lpaste.net/6424763710329323520
20:04:49 <codygman> nevermind, found answer: https://github.com/commercialhaskell/stack/issues/1015
20:14:24 <pie__> another problem with a dyre based approach is that it requires having the application source code
20:35:56 <MortimerMcMire> Hey, does anyone have a damn clue how to get the full URL of a request in Happstack? I swear I've read every function in the documentation and can find nothing relevant. 
20:36:19 <MortimerMcMire> The reason I want to get the full req URL is so that I can store it in a cookie as an ultimate destination in case the user gets forced to log in.
20:36:41 <d34df00d> Hi all!
20:36:54 <d34df00d> I suddenly have a very interesting error for my stack-based package:
20:37:05 <d34df00d> http://bpaste.net/show/f1a9da3beb07
20:37:39 <d34df00d> What I did is `stack build --executable-profiling --library-profiling`, which was fine, then stack clean, then normal stack build again, and it broke.
20:37:48 <d34df00d> So how can I fix this?
20:40:21 <pavonia> MortimerMcMire: askRq gives you information about the request
20:41:59 <geekosaur> d34df00d, Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
20:42:34 <d34df00d> geekosaur: yeah, and I don't understand why. I tried explicitly putting text == 1.2.2.1 (since it seems to be complaining about it), but no luck.
20:42:43 <d34df00d> Also, funnily, stack build --executable-profiling --library-profiling still works.
20:42:49 <d34df00d> Plain stack build doesn't.
20:43:12 <geekosaur> it's not showing the package hash, which actually matters for ghc (just being the same version is not enough)
20:43:39 <geekosaur> so apparently you have matched versions of the profiling libraries, but the non-profiled ones don't match for some reason
20:43:42 <d34df00d> So I assume I've broken stuff by requesting the profiling versions of the packages.
20:43:55 <geekosaur> ... but stack is supposed to deal with this for you; I have no clue
20:44:00 <d34df00d> So what should I do?
20:44:01 <d34df00d> Oh :)
20:44:13 <kadoban> Shouldn't have happened, AFAIK, it's supposed to work if that's all you've done, but ya :-/
20:44:28 <kadoban> You can try stack clean --full maybe and then build again?
20:44:38 <MortimerMcMire> @pavonia, my god, for some reason I thought that function got removed in an old version
20:44:38 <lambdabot> Unknown command, try @list
20:44:46 <MortimerMcMire> pavonia: thank you so much
20:45:16 <pavonia> No problem
20:45:19 <d34df00d> Tried --full, no luck.
20:46:58 <d34df00d> Also, while we're on the profiling note, what's the fastest way of getting a list of img tags with a given value for the "class" attribute from an HTML document which is malformed XML? I'm using TagSoup right now, and it eats around 88% of my run time.
20:47:17 <d34df00d> (which is probably fine, since all my application does is parsing some HTML, but I wondered if I could do it faster)
20:51:07 <pavonia> Faster than what?
20:53:27 <d34df00d> TagSoup's parseTags (with parseOptionsFast), then filter over tag name and attrs.
21:23:17 <d34df00d> Ok, fixed the stack issue by rm -rf ~/.stack
21:23:32 <d34df00d> Also, Taggy seems to be around 3x faster than TagSoup.
22:08:56 <xcmw> Is it possible to write:   x @"test" 7   in infix form? Something like   @"test" `x` 7   ?
22:12:35 <geekosaur> xcmw, looks to me like not.
22:13:09 <geekosaur> or, rather, you're thinking about type application incorrectly; it's not a parameter
22:13:46 <geekosaur> I would expect that an infix x would get the application inside the ``, from the syntax I am seeing; it's a constraint applied to the name
22:14:29 <geekosaur> (however I don't know offhand if ghc actually supports that, or if infix ends up preventing type application. probably best to ask about that in #ghc)
22:15:44 <Xnuk> Can I find the packages which depends on specific package?
22:16:38 <xcmw> geekosaur: Ok. Thanks
22:16:47 <c_wraith> Xnuk: http://packdeps.haskellers.com/reverse
22:17:13 <Xnuk> c_wraith: Thank you.
22:19:18 <xcmw> It would be neat if there was a prefix operator that turned a type into a proxy
22:23:01 <riaqn> How is the ghc's ability handling tail recursion?
22:23:25 <riaqn> Do I have to manually write a function in the form of tail recursion?
22:24:48 <liste> riaqn: http://stackoverflow.com/a/13052612
22:30:12 <riaqn> liste: thanks! 
22:31:04 <riaqn> so in summary, it's hard to estimate which is faster, so just choose the clean one.
22:31:29 <geekosaur> but the tl;dr is that tail recursion as usually meant in these cases is kinda irrelevant to the way expression reduction works in lazy languages
22:33:11 <riaqn> geekosaur: ahh, that's more close.
22:33:29 <riaqn> so anyway, go hell with the manual optimization.
22:34:04 <geekosaur> right, unless you are familiar with how to manually optimize Haskell lazy code, you're at best going to do nothing and at worst going to confuse ghc into not applying all the optimizations it could
22:34:30 <riaqn> geekosaur: makes sense.
22:34:54 <geekosaur> much optimization in ghc involves adding strictness annotations, for example
22:36:47 <dfeuer> It's very helpful to get a sense of how haskell evaluation works.
22:38:06 <dfeuer> The process is called graph reduction, but you can get very far thinking about it as rewriting terms from the outside in. If you keep writing bigger and bigger terms without producing a constructor, you might be in trouble.
22:46:55 <c_wraith> Evaluation is very constructor-oriented in Haskell.  For everything, the question is "what is evaluated to produce a constructor?"
22:50:25 <buttons840> can I make a non-IO function into an IO function?
22:50:49 <c_wraith> buttons840: sure.  The exact details depend on how exactly you mean.
22:51:07 <c_wraith> buttons840: but in general, return and fmap are your friends for that.
22:53:27 <c_wraith> buttons840: so, for instance, what's the type of a function you have, and the type you need?
22:53:30 <buttons840> c_wraith: i see
22:54:02 <buttons840> c_wraith: i thought it would work as you say, and it does; it turns out that forkIO wants an IO () and I have an IO X
22:54:19 <c_wraith> :t void
22:54:21 <lambdabot> Functor f => f a -> f ()
22:54:30 <c_wraith> buttons840: that's one approach
22:54:51 <c_wraith> :t \m -> m >> return ()
22:54:53 <lambdabot> Monad m => m a -> m ()
22:56:31 <buttons840> is `pure` prefered to `return` these days?
22:56:55 <buttons840> maybe one day we'll be able to reclaim then return name if everyone uses pure?
22:56:55 <c_wraith> I don't know if there's any real determination of that yet.
22:58:49 <lpaste> Buttons840 pasted “No title” at http://lpaste.net/350755
22:59:46 <buttons840> i'm hoping this will work like I expect once it type checks
23:00:07 <buttons840> working on concurrent Pipes still
23:06:21 <dfeuer> buttons840: yes, pure is preferred.
23:10:42 <buttons840> I just have to fill in this type hole for everything to check: `Proxy x'0 x0 () Int IO () -> IO ()`...   void . pure works, thanks c_wraith 
23:12:10 <buttons840> i'll be really suprised if all this concurry works, even though it typed checked
23:38:34 <riaqn> Hi, is there something like libghc?
23:38:47 <riaqn> so programs can be dynamically linked.
23:39:00 <fProgrammer> quick question: has anybody managed to use any Kafka libraries  ( >= 0.10) for haskell? 
23:40:16 <mniip> riaqn, yes
23:40:20 <riaqn> by far we only have two options to distribute a software: statically compiled which results a huge binary, or dynamically compiled which requires the user to have ghc installed.
23:40:26 <mniip> https://wiki.haskell.org/GHC/As_a_library
23:40:28 <riaqn> mniip: ahh sorry didn't know that
23:40:32 <riaqn> mniip: great
23:41:08 <riaqn> mniip: opps. It doesn't seem like what I was asking for.
23:41:20 <mniip> huh
23:41:21 <riaqn> I'm more like asking for RTS as library.
23:42:15 <riaqn> If I'm not wrong, the a big portion of the compiled program (around 5M) is due to the RTS?
23:43:21 <mniip> well, there's libHSrts-ghc
23:43:41 <mniip> which is about 3.6M
23:44:04 <mniip> no, 0.36M
23:44:39 <mniip> there is however libHSbase which is 10M in my install, and libHSghc-prim with 2.1M
23:44:50 <riaqn> hmm. then any way, if I dynamically compile my program, it's less than 1M.
23:44:59 <riaqn> otherwise it's around 5M.
23:45:05 <fProgrammer> anyone?
23:45:09 <mniip> if I compile my program it's 1.2M
23:46:10 <riaqn> I guess it's because ghc check the features you use in the program and plug in only the static libraries you need.
23:46:27 <mniip> it might be LTO
23:46:46 <mniip> throwing out the code from base/ghc-prim that I'm not using
23:48:39 <mniip> not sure I can tell how much of that is the RTS and how much is the libraries
23:49:04 <mniip> the RTS might be much smaller than you think
23:55:56 <riaqn> mniip: yes
23:56:05 <riaqn> mniip: I just found upx and it's quite a surprise
23:56:15 <riaqn> compress 4M static binary to 1M
