00:04:11 <Lokathor> my idea is that you start on a broken ship
00:04:15 <Lokathor> or maybe you *are* the broken ship
00:04:30 <Lokathor> and then you have to do some local upgrade stuff before you can venture into the rest of space
00:05:16 <Lokathor> but when the game is doing a long running high performance thing, the UI chugs, because GHC doesn't seem to let you assign a highest priority thread
00:10:10 <Lokathor> oh i guess there's a page in the trac about this problem, sorta, https://ghc.haskell.org/trac/ghc/wiki/LightweightConcurrency
00:12:17 <orzo> In C, pthread mutexes are expensive busy loops
00:12:29 <orzo> so it's better to use condition variables for signaling
00:12:45 <orzo> is it okay to use MVar for signaling in haskell?
00:13:25 <Lokathor> orzo, you can use MVar as a communication path if you like
00:13:44 <Lokathor> but there are other options, depending on what you want to do specifically a TChan might be good
00:13:54 <monochrom> yes, MVars cause blocking and sleeping, not busy.
00:14:18 <Lokathor> monochrom, there's also tryTake
00:14:37 <orzo> does haskell have a busy loop blocker?
00:14:47 <orzo> equivelent to pthread's mutex
00:14:59 <orzo> for my info
00:15:02 <monochrom> I think you have to write one if you want
00:15:09 <Lokathor> orzo, if you tell me what that is i might be able to tell you. I think the answer is probably "yes" though?
00:15:38 <Lokathor> like you want a thread to stay stuck until another thread is ready?
00:16:05 <orzo> well i don't want a busy loop for what i'm doing atm.  Right now, i just need a one-time signal to my main thread to end the program
00:16:36 <orzo> i see mvar, STM stuff, or QSem
00:17:08 <Lokathor> well
00:17:08 <orzo> not sure which wuld be most idiomatic
00:17:22 <monochrom> all of the above
00:17:24 <Lokathor> so anyone can just signal to the main thread to kil the program?
00:18:11 <monochrom> Look at the doc of Control.Concurrency. Somewhere there is an example.
00:18:17 <codygman> > "{\"items\": [{\"album_type\": \"single\"}]}" ^? key "items" . nth 0 . key "album_type"
00:18:20 <lambdabot>  error:
00:18:20 <lambdabot>      • Variable not in scope:
00:18:20 <lambdabot>          key :: [Char] -> b0 -> [Char] -> Const (First a) [Char]
00:18:27 <monochrom> the section "Terminating the program"
00:18:34 <codygman> > import Data.Aeson.Lens
00:18:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
00:18:42 <codygman> aw :/
00:18:53 <Lokathor> orzo, I'd make an MVar in main, pass it to the workers, then have main try to take from it before finishing. Any worker can signal for an end of the program by putting into the MVar, which would end up causing the main thread to end, which kills the whole program
00:19:55 <Lokathor> oh i just described what the docs say anyway. go figure
00:20:02 <orzo> yep
00:20:19 <codygman> Anyone know how to get a list result using ^.. (toListOf) from this: "{\"items\": [{\"album_type\": \"single\"}]}" ^? key "items" . nth 0 . key "album_type"? I tried "{\"items\": [{\"album_type\": \"single\"}]}" ^.. key "items" . key "album_type" and it gave me empty, then tried to use each but got a type error with this: "{\"items\": [{\"album_type\": \"single\"}]}" ^.. each (key "items" . key "album_type")
00:20:37 <monochrom> codygman: Sometimes I go to the office and then take out my home key, and vice versa. In fact, sometimes the office door takes a key card, and I take out my credit card...
00:20:39 <codygman> oh dear that's hard to parse, sorry
00:21:01 <orzo> actually the docs describe waiting for all the workers to signal
00:21:09 <orzo> you described more what i want
00:21:33 <Lokathor> orzo, note that there's also the System.Exit module
00:21:41 <Lokathor> which lets you just call for a program exit without all the extra setup
00:22:01 <orzo> yeah, but i want main to finish
00:22:10 <Lokathor> fair
00:25:46 <ongy> monochrom: I love those keycards, have you made a copy of yours yet?
00:26:29 <Lokathor> monochrom, as I seem to be reading it
00:26:46 <Lokathor> if the StarStub type, since it's all unboxed and unpacked and there's only 1 variants
00:26:52 <Lokathor> would have no tag maybe?
00:27:03 <Lokathor> or always a tag even unboxed?
01:06:05 <orzo> Why, when I want to aply a function to a do expression, do I need to use a $ operator?
01:06:30 <orzo> it seems pretty unambiguous to just immediately say "do"
01:07:06 <cocreature> orzo: iirc there was a proposal at some point to relax the syntax so that you don’t need $ but syntax proposals always turn into a giant mess so nothing happened
01:10:06 <Cale> cocreature: Actually, I think maybe more than nothing happened
01:10:34 <cocreature> Cale: well there was a lot of discussion but I think at the end it just died, no?
01:10:52 <orzo> probably discussion turned up draw backs
01:10:58 <Cale> Someone actually implemented something
01:11:03 <Cale> O
01:11:21 <cocreature> I think the implementation happened before the proposal
01:11:27 <Cale> I'm trying to remember if it was just a preprocessor, or if there was also a patch to GHC
01:12:01 <cocreature> I think there was a patch
01:13:05 <cocreature> Cale: https://phabricator.haskell.org/D1219
01:13:38 <orzo> https://ghc.haskell.org/trac/ghc/ticket/10843
01:14:33 <cocreature> Pro “It’s easier to read than the alternative”, Con “It’s harder to read than the alternative”
01:14:40 <cocreature> that’s why syntax proposals are doomed
01:19:39 <Cale> cocreature: A little bit sad. I sort of think it always should have been that way, but I have to admit, I'm very used to seeing those $'s there, so it would take a while to get used to.
01:20:15 <cocreature> tbh I also don’t really have a problem with the $s being there
01:20:18 <orzo> reading over the cons summary has convinced me i'm 100% in favor
01:20:27 <orzo> those all seem like weak counters to me
01:24:18 <Cale> I don't have a *problem* with the $'s being there, but I think there isn't a very good reason they should be required.
01:25:38 <orzo> i think it's actually a big improvement
01:25:41 <orzo> to the syntax
01:25:50 <orzo> lots less $ in the examples
01:26:18 <orzo> consistent with haskell's feel
01:26:41 <orzo> haskell feels like the language designers went out of their way to try to make an uncluttered syntax
01:27:01 <orzo> out of their way = complex layout rules
01:28:13 <EvanR> haskell syntax is for people, lisp syntax is for machines
01:32:52 <jchia_> Lens question. How can I simplify this? over each (view _1) ((True, 'a', Nothing), (False, 'b', Nothing))
01:34:10 <jchia_> I mean simplify the use of lens. I'm trying to extract the first item of each inner tuple into a tuple.
01:36:05 <Cale> (\(x,_,_) (y,_,_) -> (x,y))
01:36:36 <Cale> Oh, it's not even that :)
01:36:44 <Cale> (\((x,_,_),(y,_,_)) -> (x,y))
01:36:47 <Cale> right
01:37:11 <Cale> But honestly, if you have a pair of triples like that, it's time to define some proper data types
01:38:25 <jchia_> I'm comparing two structured tuples in a specific way, so I extract the pertinent parts from each tuple into another tuple and compare that.
01:38:39 <jchia_> How would it be done in lens, though?
01:40:41 <Cale> I mean, lens is not doing anything different from that lambda there
01:40:41 <jchia_> More concretely: data Foo = Foo { _a :: (Int, Char), _b :: Bool, ...}. I want to extract the fst of the _a from the Foo, and use it to compare two Foos. Hence I need a (Foo, Foo) -> (Int, Int) and want to express that succintly with lens.
01:40:58 <jchia_> The lambda is not very DRY.
01:42:03 <jchia_> I could define a function Foo -> Int but I just need to use it once.
01:42:05 <Cale> Wait, why does this need to result in an (Int,Int)?
01:42:16 <Cale> fst . _a :: Foo -> Int
01:43:19 <Cale> :t comparing (fst . ?f)
01:43:22 <lambdabot> (?f::a1 -> (a, b), Ord a) => a1 -> a1 -> Ordering
01:43:36 <jchia_> (Int, Int) extracted from a (Foo, Foo)
01:43:57 <Cale> Yeah, though you said "use it to compare two Foos"
01:44:03 <jchia_> for brevity, that's all
01:44:24 <Cale> If you mean compare in the sense of
01:44:26 <Cale> :t compare
01:44:32 <lambdabot> Ord a => a -> a -> Ordering
01:44:35 <jchia_> yes
01:44:39 <Cale> :t comparing
01:44:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:44:50 <Cale> Is available from Data.Ord
01:45:01 <jchia_> OK
01:45:04 <Cale> comparing (fst . _a)
01:45:16 <Cale> will get you a comparison by the first component of the a field
01:46:16 <jchia_> I think that'll work. Then I don't need to bother with the details of tuple traversal.
01:51:37 <jle`> the magic of currying
01:51:59 <jle`> instead of (A, A) -> B, write an A -> A -> B
01:56:07 <EvanR> and then compile into a (A,A) -> B ;)
02:05:00 <Cale> EvanR: and then compile into (# A, A #) -> B
02:49:22 <bollu> (Not a -> Not b) -> b -> a from hilbert systems: what is the intuionistic logic interpretation of this?
03:28:19 <gingitsune> Hey, I'm having some haskell newb problems
03:28:21 <gingitsune> let con :: [a] -> a -> [a]; con a b = a ++ [b]
03:28:31 <gingitsune> This in ghci works as i'd expect 
03:29:07 <gingitsune> On the other hand i try to load this from a .hs file into ghci via :l filename.hs
03:29:10 <gingitsune> 'con :: [a] -> a -> [a]
03:29:27 <gingitsune> And i get this error 
03:29:38 <gingitsune> Should be of form <variable> :: <type>
03:29:55 <mikail> gingitsune, take the let out
03:30:05 <mikail> and then load
03:30:33 <gingitsune> mikail: there is no let in the file
03:30:36 <pavonia> gingitsune: Is this apostrophe part if the name in your file?
03:30:45 <mikail> let con??
03:32:07 <gingitsune> heres the full shindig
03:32:08 <gingitsune> https://hastebin.com/ofozibokad.scala
03:32:25 <gingitsune> pavonia: yes thats in the file
03:33:10 <pavonia> You can't start a function name with '
03:33:12 <gingitsune> The file is named zip with cuz I'm at the higher order section of learn you a haskell. I just wanted to define a function to test zipWith
03:33:45 <gingitsune> pavonia: are you sure? The book has suggested that sort of naming pattern for making your own implementations of standart methods
03:33:48 <gingitsune> 'zip
03:33:50 <gingitsune> 'zipWith
03:33:51 <gingitsune> etc
03:34:02 <gingitsune> and it worked so far...
03:34:02 <pavonia> No, zip', ziWith' wtc.
03:34:23 <gingitsune> pavonia: darn
03:34:30 <gingitsune> you're right
03:34:39 <pavonia> Names starting with an apostrophe are reserved for something ele
03:34:48 <gingitsune> now it loads and all is right with the world. Had a small brake since the last sessions. Slipped my mind
03:34:59 <gingitsune> Thanks!
03:42:03 <bollu> is there an inhabitant to (Cont r b -> Cont s a) -> a -> b?
03:42:17 <bollu> that is, the logic equation (Not b -> Not a) -> a -> b?
03:42:34 <bollu> sorry
03:42:50 <bollu> hilbert system's 4th axiom: (!b => !a) => (a => b)
03:43:06 <bollu> can there be an intuitionistic logic equivalent to this?
04:23:09 <Gloomy> Hi :)
04:23:21 <Gloomy> Maybe this belongs here more than in Haskell-Beginners:
04:23:27 <Gloomy> If I do: 
04:23:36 <Gloomy> testChan <- newChan 
04:23:46 <Gloomy> writeChan testChan "test" 
04:23:58 <Gloomy> I get an error:     • Couldn't match type ‘ghc-prim-0.5.0.0:GHC.Prim.Any’ with ‘[Char]’
04:24:18 <Gloomy> Why is that? 
04:25:15 <Gloomy> It's weird, it only seems to happen in GHCI. If I compile it seems to work fine.
04:33:23 <mekeor> Gloomy: could you post the working source code for GHC as well as the not-working input into GHCI?
04:33:43 <Gloomy> yes, one moment 
04:37:47 <Gloomy> Here : http://lpaste.net/351509
04:39:28 <haskell687> safetail2 :: Eq x => [x] -> [x]
04:39:32 <haskell687> what does this function input mean?
04:39:42 <haskell687> the Eq as well
04:40:31 <Gloomy> It takes an array of elements that are instances of Eq?
04:40:44 <haskell687> what's Eq do?
04:41:06 <Gloomy> It's a type constraint
04:41:19 <Gloomy> says that x has to be an instance of the class Eq 
04:41:45 <Gloomy> meaning the functions (==) and (/=) have to be defined for x 
04:42:32 <haskell687> and then you can input a list of [x] and then output [x]?
04:43:10 <mekeor> Gloomy: i really don't know what's wrong with your snippet. maybe reading the GHC manual may help? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-do-notation-at-the-prompt
04:43:56 <Gloomy> haskell687 yes, it takes a list as input and outputs another list of the same type 
04:44:16 <haskell687> cool, ty
04:44:34 <haskell687> what kind of "OR" is |||?
04:44:43 <haskell687> is that simply how you denote an OR is Haskell, as |||?
04:45:15 <Gloomy> mekeor Mmh I had read that some time ago, that's why I would expect my snippet to work
04:45:23 <haskell687> (|||) :: Bool -> Bool -> Bool
04:45:30 <haskell687> False ||| False = False
04:45:33 <haskell687> _ ||| _ = True
04:45:40 <haskell687> I've essentially defined an OR function like that
04:46:20 <mekeor> Gloomy: did you try something like do { ... } -- ?
04:46:23 <Gloomy> haskell687 Never seen that notation
04:46:47 <Gloomy> haskell687 But I'm really no reference :)
04:46:55 <Gloomy> mekeor Yes, just tried that. it works
04:47:02 <Gloomy> mekeor Which confuses me even more :_ 
04:47:29 <mekeor> Gloomy: maybe it's because in GHCI everything has to be in the IO monad?
04:47:45 <haskell687> because
04:47:47 <haskell687> if I do
04:47:49 <Gloomy> > :t writeChan
04:47:51 <haskell687> (|||) :: Bool -> Bool -> Bool
04:47:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
04:48:00 <haskell687> I mean, if I do not :: Bool -> Bool -> Bool
04:48:08 <haskell687> it won't work then, so why do I have to do (|||)?
04:48:11 * Gloomy really needs to learn this lambdabot thing
04:48:20 <mekeor> @type writeChan
04:48:23 <lambdabot> error: Variable not in scope: writeChan
04:48:33 <Gloomy> writeChan :: Chan a -> a -> IO ()
04:48:52 <Gloomy> that's still an IO action it seems
04:49:28 <mekeor> haskell687: you can define a function called 'not' of type 'Bool -> Bool'. 
04:49:54 <danilo2> Hello guys! Is this a bug or it is a "feature"? I'm asking here because based on the answer the desing of my library may change drastically and I do not know what to hink about it: https://ghc.haskell.org/trac/ghc/ticket/13161#ticket
04:49:59 <Gloomy> haskell687 normally you define infix operators with parentheses, I think.
04:50:13 <Gloomy> like (+), (==) , etc.
04:50:40 <haskell687> (not) :: Bool -> Bool 
04:50:43 <haskell687> False not False = False 
04:50:44 <haskell687> _ not _ = True
04:50:46 <haskell687> so that's wrong?
04:50:58 <haskell687> basically I want to know why it has to be ||| in the parenthesis
04:51:06 <Gloomy> haskell687 Not is a unary operator, it takes only one argument
04:51:17 <Gloomy> it doesn't make sense to say False not False
04:51:57 <haskell687> not :: Bool -> Bool
04:51:59 <haskell687>  True = False 
04:52:01 <haskell687> False = True
04:52:02 <haskell687> still wrong?
04:52:11 <Gloomy> not :: Bool -> Bool
04:52:15 <Gloomy> not True = False
04:52:20 <Gloomy> not False = True
04:52:25 <Gloomy> like this :)
04:52:41 <Gloomy> (Except not is already defined I think so it will give you a duplicate declaration error)
04:53:13 <ahihi> Gloomy: it seems that defaulting(?) in ghci causes your "t" to be of type Chan Any
04:53:40 <ahihi> try t <- newChan :: IO (Chan String)
04:54:14 <haskell687> ah ok, thanks!
04:56:04 <Gloomy> Hah
04:56:08 <Gloomy> Thanks ahihi :)
04:57:34 <Gloomy> How many threads is it o.k. to spawn at the same time ? 
04:57:41 <Gloomy> (with forkIO)
04:58:18 <Gloomy> Am I going to run into problems if I have too many threads using the same resources (network requests mainly)? 
05:13:14 <haskell687> rev1 :: [a] -> [a]  
05:13:17 <haskell687> rev1    []  = [] 
05:13:18 <haskell687>  rev1 (x:xs) = rev1 xs ++ [x]
05:13:22 <haskell687> just so I'm  understanding
05:13:30 <haskell687> if the list inputted is [] then return []
05:13:45 <haskell687> else input the xs to rev1 and add the head
05:13:57 <haskell687> but what is actually happening in the recursive process?
05:13:57 <Axman6> yes
05:14:11 <Axman6> not sure what you mean
05:14:17 <haskell687> it is recursive right?
05:14:21 <Axman6> yes
05:14:31 <haskell687> xs is the tail and [x] is the head
05:14:44 <haskell687> it's seeing it in my head
05:14:47 <haskell687> gah
05:14:57 <NextHendrix> x is the head
05:15:02 <haskell687> ok
05:15:10 <Axman6> [x] is the list with the single element x in it, which was at the head of the input list
05:15:36 <haskell687> ok
05:15:43 <Axman6> that has awful performance by the way - when reversing a list, think about how you might reverse the order of a stack of plates
05:16:13 <haskell687> take one off and put the one on the table
05:16:18 <haskell687> repeat
05:16:21 <Axman6> yep
05:16:28 <NextHendrix> Axman6: throw them in the air and catch them carefully in the right order
05:16:31 <haskell687> lmao
05:16:35 <NextHendrix> ymmv
05:16:49 <haskell687> say if I input [1,2,3]
05:16:57 <haskell687> what is the recursive process doing to that list?  step by step?
05:17:03 <Axman6> NextHendrix: quantum reverse, it'll create infinite universes and keep the ones where it's reversed
05:17:35 <haskell687> is it doing
05:17:35 <NextHendrix> Axman6: O(nlogn)?
05:17:55 <haskell687> [2,3]
05:18:02 <haskell687> then add the head
05:18:03 <haskell687> so it's
05:18:08 <haskell687> [2,3,1]
05:18:20 <haskell687> then [3, 1]
05:18:34 <haskell687> I don't think it is
05:18:36 <Axman6> rev [1,2,3] -> rev [2,3] ++ [1] -> (rev [3] ++ [2]) ++ [1] -> ((rev [] ++ [3])++[2])++[1]
05:19:41 <Axman6> -> (([] ++ [3])++[2])++[1] -> (([3])++[2])++[1]) -> [3,2]++[1] -> [3,2,1]
05:20:35 <Axman6> (might be easier to replace -> with a new line in a text editor)
05:21:45 <Axman6> haskell687: mind if we move this convo to #haskell-beginners?
05:22:02 <haskell687> yeh
05:22:42 <haskell687> I'm in
05:24:59 <ferdinandvw> hey guys, I have a question that I wrote in this pastebin: http://pastebin.com/rQMuyrBv
05:25:14 <ferdinandvw> Would be nice if someone could take a look at it :)
05:32:15 <Axman6> ferdinandvw: the premise of your question seems wrong, if you ask for the type of c you should get C a => a -> a
05:32:51 <ferdinandvw> hmm you sure? I did simplify it in this example. Let me try it out quickly
05:32:54 <Axman6> the fact that there's only one instance for the class doesn't change the type of the function
05:35:06 <ferdinandvw> ok, I fucked something up
05:35:13 <ferdinandvw> I'll try to revise
05:35:53 <Axman6> =)
05:42:01 <ferdinandvw> http://pastebin.com/y6ntXzAy
05:42:10 <ferdinandvw> I replaced D a with Show a
05:43:17 <ferdinandvw> Also, in the previous example the constraint actually "dissappeared". The type of c was simply a -> a
05:47:19 <ferdinandvw> my guess is that ghci applies some reduction rules on the constraint set
05:57:38 <saurabhnanda> has anyone gotten Rapid working for hot-reloading during web-dev? https://github.com/esoeylemez/rapid
06:01:34 <ph88> when i try to use this type  https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashSet.html#t:Set  ghci says:  Module ‘Data.HashSet’ does not export ‘Set’  can anyone tell me why that is ?
06:03:14 <pavonia> ph88: What version of that package do you have installed?
06:08:05 <ph88> pavonia, unordered-containers-0.2.7.2
06:08:41 <pavonia> That's a completely different package
06:09:49 <pavonia> and it doesn't have a Set type
06:10:22 <cocreature> it does however have a HashSet type that you can use instead
06:10:44 <WitchKnight> I've always used unordered-containers, is the hashmap package good too ?
06:12:19 <pavonia> WitchKnight: The docs for hashmap say "Deprecated. in favor of unordered-containers"
06:12:51 <ph88> ooh
06:13:26 <WitchKnight> oh well ¯\_(ツ)_/¯
06:20:58 <cbaatz> Does anyone know if there's already a failure/except/error type on Hackage whose Applicative instance aggregates up failures instead of eagerly failing (i.e. where the failure type is a Semigroup)?
06:26:36 <cocreature> cbaatz: https://hackage.haskell.org/package/validation
06:28:45 <cbaatz> cocreature: thanks!
06:45:49 <cbaatz> Is there an intuitive/concrete example of when <*> /= ap causes bad/surprising problems? Basically, I'm thinking it'd be useful to have a type that aggregates errors when used as an applicative, but fails eagerly when used as a monad (because it has to). Intuitively, this behaviour seems reasonable to me: I use applicative in my computation as long as I can and build up errors so I don't have to run things again and then fail with all
06:45:49 <cbaatz>  those errors when I hit a monad bind. It's easy to write such a type, but it violates the <*> /= ap constraint (because ap is defined in terms of bind). If I write and use it, am I setting myself up for problems? What kind of problems?
06:52:48 <ertes> saurabhnanda: if you have questions about it, feel free to highlight me
06:53:15 <saurabhnanda> ertes: about Rapid? yes, lots. How do I make it behave like Ruby or Python? Save a file, hit reload on the browser?
06:53:36 <ertes> saurabhnanda: for that you need some editor integration…  which editor?
06:56:50 <walrus> @undo do i <- [1..n]; j <- [1..n]; return (i,j);
06:56:51 <lambdabot> [1 .. n] >>= \ i -> [1 .. n] >>= \ j -> return (i, j)
06:57:33 <ertes> walrus: liftA2 (,) [1..n] [1..n]
06:57:40 <saurabhnanda> emacs
06:57:41 <saurabhnanda> ertes: emacs
06:57:57 <ertes> saurabhnanda: are you using haskell-interactive-mode?
06:58:39 <saurabhnanda> ertes: using spacemacs. How do I find out?
06:58:46 <saurabhnanda> ertes: spacemacs + intero
07:00:31 <ertes> saurabhnanda: i'm not sure how intero works, but i've been told it depends on haskell-mode…  with a bit of luck it also uses haskell-interactive-mode, in which case you can simply use haskell-process-reload-devel-main in your save hook
07:01:25 <saurabhnanda> okay
07:01:50 <saurabhnanda> and when the main function is reload -- will GHCI be intelligent enough to recompile only changed files?
07:01:59 <saurabhnanda> *main function is reloaded
07:02:23 <saurabhnanda> also, how do I prevent it from messing up GHCI when there is a compilation error?
07:02:23 <ertes> saurabhnanda: the idea is:  if there is a buffer named DevelMain.hs, just use haskell-process-reload-devel-main in after-save-hook
07:02:59 <ertes> saurabhnanda: GHCi by default reloads *all* modules…  you can stop it from doing that by compiling (-fobject-code)
07:03:02 <saurabhnanda> ertes: right, got that. If it depends on 40 different modules/files will all be compulsarily reloaded, or only the ones that changed?
07:03:20 <ertes> a compilation error shouldn't mess up GHCi
07:03:27 <ertes> at least with haskell-interactive-mode
07:03:54 <saurabhnanda> ertes: is it? I remember noticing that it was intelligent about loading only changed files. But recently that seems to have changed.
07:03:55 <ertes> it will reload all modules DevelMain depends on and skip those for which an *.o and *.hi file exist and are newer
07:03:58 <saurabhnanda> ertes: it seems to be loading all files.
07:04:17 <ertes> try this:  :set -fobject-code
07:04:21 <ertes> in the REPL
07:05:04 <saurabhnanda> okay
07:05:41 <ertes> there is a major caveat with that flag though:  it only exposes functions that are actually exposed, even for the currently loaded module…  this is no problem for DevelMain, but if you load files explicitly, you have the same limitation
07:06:05 <ertes> just see if you can live with that
07:06:21 <ertes> BTW, personally i just have a hot key for reloading
07:06:32 <ertes> C-c m
07:07:11 <saurabhnanda> ertes: got it -- it works
07:07:17 <saurabhnanda> ertes: why isn't this the default behaviour of ghci?
07:07:33 <ertes> i don't know…  likely simply because nobody has implemented it yet
07:07:41 <ertes> it could keep unchanged modules in memory
07:08:00 <octarin>  /join #haskell-beginners
07:09:42 <ertes> saurabhnanda: there is also a middle ground:  you can reload once with -fobject-code and then switch back to -fbytecode…  GHCi will use compiled objects even in bytecode mode…  it will just not produce new ones
07:09:46 <saurabhnanda> ertes: why would that be a problem? but anyways, thanks for the help -- this shortens my development cycle.
07:10:24 <ertes> i.e. reload your 40 modules with -fobject-code, then switch back to -fbytecode…  when you feel that reloading takes too long again, repeat this
07:10:31 <ertes> you can even turn this into a hot key
07:31:37 <hpc> ooh, when did the platform start including stack?
07:32:41 <lordcirth> haskell-platform including stack is kinda odd because the stack guides say don't get platform
07:35:25 <hpc> the stack guides are probably in the wrong there, i think
07:35:42 <hpc> and they should lean more on being a different way to build a project that is more reproducible
08:11:32 <OutlawStar> anyone know if i can use killThread to terminate a thread that is blocking on a socket read?
08:12:13 <hpc> try it
08:12:36 <hpc> you should be able to
08:12:40 <OutlawStar> yeah, i can. Just thought I ask real quick. Could be faster than writing the experiment :)
08:13:22 <OutlawStar> i was curious because of how throwTo is documented
08:13:50 <OutlawStar> it says that the exception raise waits for a memory allocation, if you are blocked on socket, that won't happen
08:14:43 <c_wraith> OutlawStar: it waits on an allocation if it's running haskell code
08:14:51 <c_wraith> OutlawStar: it's a bit more complicated if it's in a native call
08:15:01 <c_wraith> OutlawStar: or if it's blocking on an MVar
08:15:14 <c_wraith> OutlawStar: or something like that.
08:15:25 <tmciver> Good morning! Trying to learn some category theory and had a question regarding isomorphisms. First, is it correct to say that an isomorphism (or any morphism for that matter) is a property of a function (map) and not a propert of a datatype?
08:15:32 <OutlawStar> correct, it seems in native code it waits for return back to haskell, unless the call is marked interruptble
08:15:37 <c_wraith> OutlawStar: a socket read is secretly blocking on an mvar in the IO manager
08:15:56 <OutlawStar> oh, didn't kno wthat
08:16:06 <tmciver> I ask because I thought, for some reason, that Maybe and Either were isomorphic but I'm not sure that even makes sense.
08:16:55 <tmciver> A transformation from Either to Maybe is "lossy" which means that it's non-invertible, and I believe that means that operation is *not* isomorphic.
08:17:52 <c_wraith> tmciver: I don't know the category theory there, but they're certainly not ismomorphic in the way that term is used
08:18:18 <c_wraith> tmciver: however, it's certainly true that there are morphisms between the two that preserve some important properties
08:19:43 <jungle_savage> My Fellow Haskellers. :-)
08:19:52 <jungle_savage> I have a question about lenses... :-/
08:20:07 <tmciver> c_wraith: Are you able to say more about these preserved properties?
08:20:53 <c_wraith> tmciver: not in formal terms, but you can certainly have morphisms that preserve the short-circuiting on failure behavior their Monad instances provide
08:21:25 <tmciver> c_wraith: OK. Thanks.
08:21:32 <jungle_savage> Let's say I have the following data types: data A = B | C; data B = B {bFoo :: Foo}; data C = C {cFoo :: Foo}
08:21:48 <OutlawStar> haskell concurrency book ftw, takeMVar can be interrupted :)
08:21:55 <jungle_savage> How can I, given a list [A], produce a list [Foo]??
08:22:19 <walrus> hello everyone, I'm trying to learn about monad transformers by implement a stack data structure that can fail, where the failure is indicated using a MaybeT, however i seem to be kind of stuck on implementing pop, would anyone mind having a look? http://lpaste.net/351510
08:22:20 <c_wraith> jungle_savage: I think your definition of A might be problematic
08:22:29 <jungle_savage> I THINK that I have to use prisms somehow, but then I am stumped...
08:22:35 <jungle_savage> How come, c_wraith?
08:22:44 <c_wraith> jungle_savage: in particular, did you mean data A = AB B | AC C ?
08:22:45 <hpc> it's the same as Bool
08:22:54 <hpc> A has two elements, the constructor B and the constructor C
08:23:04 <hpc> both with no fields
08:23:04 <jungle_savage> Oh, yes. That's correct c_wraith. Sorry.
08:23:26 <jungle_savage> I meant A = AB B | AC C. :-)
08:24:23 <c_wraith> jungle_savage: the automatically created lenses for A will be prisms, yes, but that isn't an important property 
08:24:33 <c_wraith> :t failing
08:24:35 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
08:24:49 <jungle_savage> Hmmm... c_wraith
08:25:29 <jungle_savage> Yeah. That doesn't ring any bells, I'm afraid, c_wraith. lol
08:25:33 <c_wraith> I'd use a lens that looks like traverse . (_AB . _bFoo `failing` _AC . _cFoo)
08:25:34 <hpc> it always amuses me that lens types contain "fstab"
08:25:44 <jungle_savage> Let me take a look at its Haddocks.
08:26:29 <c_wraith> jungle_savage: basically, it takes two traversal-like things.  It acts like the first unless the first has no targets in the structure being traversed, in which case it acts like the second.
08:27:02 <hpc> that feels like it should be called orElse, or (<|>) or something
08:27:10 <jungle_savage> Thanks, c_wraith. That looks promising.
08:27:18 <jungle_savage> :-)
08:27:35 <c_wraith> You're welcome,  hope it works for you. :)
08:28:32 <c_wraith> hpc: it can't be (<|>) because lenses are just type aliases.  It could be orElse, but then you couldn't import it unqualified if you're using STM
08:29:19 <jungle_savage> ;-)
08:29:56 <hpc> yeah, fair
08:30:15 <hpc> failing is still not great, it sounds like it tries the second argument first
08:30:31 <hpc> "do X, failing Y"
08:31:00 <hpc> clearly it should be called otherwise
08:31:03 <c_wraith> I counter with "failing X, do Y".  stalemate!
08:31:05 <hpc> that can't possibly have any name conflicts!
08:31:16 <MarcelineVQ> what would sound like when not infix?
08:31:29 <hpc> it would sound like what c_wraith just said
08:31:37 <hpc> so that's probably the right answer then
08:31:50 <c_wraith> Don't use it the way I just did? :)
08:35:09 <ertes> just hide 'orElse' when importing STM
08:35:29 <c_wraith> I suppose it's true that STM doesn't really need orElse anymore
08:35:56 <hpc>  doesn't orElse = (<|>)?
08:36:00 <c_wraith> yes
08:36:05 <hpc> there we go then :D
08:36:08 <c_wraith> Except it's defined the other way around
08:36:12 <c_wraith> :)
08:36:15 <hpc> bah
08:36:47 <hpc> oh, you mean (<|>) = orElse
08:36:51 <hpc> not (<|>) = flip orElse
08:36:56 <hpc> you confused me there ;)
08:37:08 <c_wraith> yes, that's what I meant.  Sorry, didn't mean to confuse you. :)
08:37:24 <hpc> for once i didn't do it to myself
08:38:03 <hpc> STM may be the best thing to come out of haskell
08:38:07 <ertes> i guess a flipped (<|>) would be more human for STM:  humans always talk about the least satisfying things first
08:38:26 <c_wraith> You could have your feet chopped off, or an ice cream cone.
08:39:10 <gameer> Hey Guys. One stupid question. Is it right that "Functor" is just the name for all types, who can hold values and we can work with this values(like [],Maybe,..) ?
08:39:25 <c_wraith> gameer: not all Functor instances hold types
08:39:46 <c_wraith> gameer: for instance..  newtype Foo a = Foo (Int -> a)
08:39:53 <c_wraith> gameer: that can be made an instance of Functor
08:40:17 <ertes> (Int -> a) does hold values of type 'a' though
08:41:05 <c_wraith> not always.  If a ~ Int, for instance, it could be negate
08:41:24 <ertes> which holds Int many values of type Int
08:41:33 <ertes> you're just having a very narrow notion of "hold" =)
08:41:45 <c_wraith> or you're holding an overly wide definition...  :P
08:41:58 <c_wraith> gameer: you're sort of on to something, though
08:42:02 <gameer> But i'm on the right way with my description?
08:42:10 <gameer> okay
08:42:45 <c_wraith> gameer: There's a more sophisticated property that does apply - which is that `a' is always used in a positive position
08:44:09 <c_wraith> gameer: that covers lots of special cases, like data Bar a = Bar
08:44:35 <c_wraith> gameer: no way to get an `a' value out of that at all, but it can still be a perfectly legal Functor instance
08:44:42 <hpc> fmap _ Bar = Bar
08:45:34 <c_wraith> gameer: but you are on the right track - there are just more special cases than you had figured on.  So you need a somewhat more sophisticated definition to handle it. :)
08:45:43 <gameer> I'm reading the Functor-Chapter on lyah, but this is so long and I feel like it only says that Functors can hold something "in a box"(way they explain it) and we can work with it. And that I can give/get functions in/out the Functors via the applicative Functors <$> and <*>... is this correct in a roughly way?
08:45:45 <blair_> Hey guys, I'm introducing a friend to haskell, and I was wondering how best to introduce someone to the language (in your opinion). He has no programming experience, but he's an upper year math student who's used to writing latex
08:46:20 <blair_> He's on windows, which might add a techinical complication or two. Is haskell hard to use on windows?
08:46:33 <gameer> blair_: Best way for me is to go through learnyouahaskell.com, with windows and ghci
08:46:49 <hpc> the platform on windows is fine enough for learning
08:46:58 <c_wraith> gameer: lyah isn't very mathematically rigorous
08:47:10 <c_wraith> gameer: so it uses some hand-wavey descriptions
08:47:23 <hpc> once you start writing code that depends on foreign libraries it gets really hard on windows, and you'll want to use stack
08:47:27 <blair_> How does ghci work on windows? (I've only used it on linux)
08:47:30 <hpc> but that's beyond the learning-the-language phase
08:47:35 <hpc> ghci works identically on both platforms
08:47:39 <c_wraith> blair_: open it from a terminal window
08:47:47 <hpc> modulo terminal differences like ^C and ^Z
08:48:22 <hpc> @where cis194
08:48:22 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
08:48:31 <hpc> that course is pretty well regarded
08:48:34 <hpc> @where learnhaskell
08:48:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:48:35 <blair_> Does he need to learn how to open up a terminal (I find that intimidates newbies)
08:48:47 <hpc> that github link is a good meta-resource for "how should i learn"
08:49:10 <hpc> it'll help for sure
08:49:33 <hpc> you could set up file associations so .hs files open in ghci, but you'll eventually want to compile them and you can't have two associations
08:49:38 <gameer> c_wraith: That cis194 looks like a nice overview about each topic
08:50:03 <hpc> it's pretty easy to open a terminal though
08:50:04 <c_wraith> gameer: it is.  (Though hpc was the one who mentioned it. :P )
08:50:09 <hpc> win+r, cmd, enter
08:50:11 <gameer> I know^^
08:50:30 <hpc> or if you care what directory you're in (running ghci on a specific file)
08:50:31 <gameer> But maybe I can use it later, when I'm unsure in s.th.
08:50:42 <hpc> go to that directory in explorer, then shift-right-click in the window somewhere
08:50:47 <hpc> and one of the options will be open terminal
08:50:53 <c_wraith> gameer: yeah, it's a really nice resource.
08:51:01 <gameer> c_wraith: Ouh, now I unterstand. Sorry. Thought u wrote the link...^^
08:51:07 <hpc> er, "open command window here"
08:51:42 <hpc> blair_: at the end of the day programming involves opening lots of terminals ;)
08:52:08 <ggVGc> hpc: unless you're in an MS shop
08:52:12 <hpc> heh
08:52:17 <c_wraith> Though powershell is getting more common
08:52:35 <hpc> anyway it's worth the trouble for sure, especially if the goal is to learn math via haskell
08:52:52 <c_wraith> I've been wading through a bunch of stuff for integrating with AD in my day job - lots of the documentation talks about powershell.
08:52:56 <hpc> (and eventually things that map more closely to theory like agda)
08:53:03 <ggVGc> I think if yo're learning math through haskell there's a high chance you end up learning type theory instead
08:53:11 <hpc> type theory is math
08:53:13 <c_wraith> type theory is a branch of math. :)
08:53:25 <ggVGc> hpc: yeah, but not so useful for most math applications
08:53:32 <hpc> computer science is math, even
08:53:35 <blair_> Yeah, of course terminals are the greatest, but I find new people are intimidated by it. Since he's on windows, I can't offer all that much help to him
08:53:54 <ggVGc> I'm intimidated by terminals on windows too
08:53:58 <ggVGc> after 12 years as a software developer
08:54:09 <hpc> blair_: if he has ssh access to anything, suggest putty
08:54:14 <hpc> if he doesn't, suggest virtualbox maybe?
08:54:31 <c_wraith> blair_: you could always just create a shortcut that launches ghci without having to interact with the terminal outside it
08:54:40 <hpc> ah right, or that
08:54:49 <ggVGc> kind of feel I should take a look at that gnu subsystem in win10
08:54:52 <ggVGc> supposedly bash actually works?
08:54:53 <hpc> heh
08:55:09 <lordcirth> It does mostly work
08:55:22 <ggVGc> lordcirth: what have you been using it for?
08:55:24 <c_wraith> bash works.  ghc..  well, ghc-compiled programs work if you're running preview builds of windows...
08:55:44 <c_wraith> but even on preview builds, I can't install a binary build of ghc - make forks too much for it
08:55:47 <ggVGc> I've heard statements that ms are intending linux applications to be completely supported in windows
08:56:00 <c_wraith> I expect that in another year, it'll be excellent
08:56:02 <lordcirth> ggVGc, I haven't personally.  I've seen friends of mine use it.  You can ssh, grep, etc, but trying to do anything complicated threw odd errors
08:56:08 <c_wraith> It's not excellent yet :)
08:56:12 <ggVGc> still intersting
08:56:23 <ggVGc> maybe windows can be the GUI that linux always wanted
08:56:26 <lordcirth> It is a surprising accomplishment.  I personally have no use for it
08:56:27 <ggVGc> (not me personally, but people)
08:56:32 <c_wraith> But yeah, I could totally see myself going to windows + WSFL instead of OS X for development
08:56:38 <lordcirth> I greatly prefer proper Linux.
08:56:43 <ggVGc> because, well, I don't trust the linux community to ever actually create a decent GUI
08:56:54 <lordcirth> ggVGc, the GUIs have been decent for a decade
08:56:57 <ggVGc> nope
08:57:01 <ggVGc> I sincerely don't agree
08:57:10 <hpc> they've been pretty crap
08:57:15 <c_wraith> OS X just keeps getting worse.  It's almost like they want me to consider other OSes
08:57:19 <lordcirth> So has Windows GUI.
08:57:26 <lordcirth> All GUIs are generally crap.
08:57:45 <hpc> either there's massive input lag, or you can't tell what window is open, or it crashes, or it doesn't detect monitors, or you can't set them to their native resolution, or ...
08:57:54 <ggVGc> I mean, I really don't enjoy windows. But I have to say windows GUIs have been quite a fair bit better both to use and to develop since almost forever
08:58:01 <ggVGc> and linux distros have never been even close
08:58:10 <hpc> windows 7 was the sweet spot for GUIs
08:58:21 <ggVGc> making a gui in win32 api a decade ago was way better than creating most guis for linux today
08:58:36 <lordcirth> I have no experience in developing GUIs, I must admit
08:59:20 <lordcirth> Except a class in Visual Basic, which was horrible, but no one uses that anymore, I think.
08:59:22 <ggVGc> I think it would be really good if windows became the GUI platform for linux applications, so the linux community can focus on what they do well
08:59:30 <ggVGc> instead of wasting time and efforts playing catchup
08:59:53 <ggVGc> lordcirth: you are probably very wrong about that :)
09:00:00 <ggVGc> people still use win XP and write GUIs in pascal
09:00:13 <codedmart> I am seeing a pattern in my code where I am trying to access a `Maybe (Maybe Text)` quite a bit. I am currently doing this `join $ streetOne <$>  addresses user` Is there a better way to do this or is this pretty common/normal? Should I start using lens?
09:00:17 <lordcirth> ggVGc, I know people use the editor, but they use other languages like C#, don't they?
09:00:44 <hpc> codedmart: what does each layer of Nothing represent? you probably need to write your own data type
09:00:46 <ggVGc> the majority of software is legacy
09:01:56 <Rembane> codedmart: I usually use >>= or =<< to get rid of the extra Maybe.
09:01:59 <lordcirth> ggVGc, but your GUI has root. (it doesn't run as root, but it interprets all keystrokes and displays all output).  I would never run a Windows GUI on a machine I did anything important on.
09:02:05 <codedmart> hpc: Not sure I follow. I have data types. A `User` may or may not have `[Address]` and an `Address` may or may not have `streetOne` attribute.
09:02:29 <lordcirth> I mean, look at Qubes OS.  The GUI is the single most isolated, armored part of the system because it's the most vulnerable.
09:02:40 <codedmart> Rembane: Ah dumb me.
09:02:48 <codedmart> Thanks makes it a little more concise.
09:02:50 <Rembane> codedmart: OTOH, have you seen these: https://hackage.haskell.org/package/errors-2.1.3/docs/Control-Error-Util.html
09:02:59 <lordcirth> codedmart, a List of Address?  Why do you need Maybe?  Why not an empty list? []
09:03:12 <Rembane> codedmart: ExceptT is really nice.
09:03:22 <lep-delete> :i ExceptT
09:03:33 <ggVGc> lordcirth: this is obviously not a real life issue for most users since windows GUI applications are by far the most used type of program. So the point is moot in the discussion imo
09:03:35 <hpc> codedmart: ah, the double-Maybe is in the middle of a larger record access
09:03:40 <codedmart> lordcirth: This is a rebuild of a js app. With very inconsitant data that I can't update.
09:04:17 <lordcirth> ggVGc, most users don't know how their computers work.  Therefore, while their experience is important, their technical opinions are worthless.
09:04:19 <codedmart> And just one example of others.
09:05:48 <codedmart> Thanks guys! 
09:07:34 <monochrom> oh w00t new Haskell Platform!
09:13:23 <hasuke> I use an old T400 (dual core, 2GB RAM) with Ubuntu for doing random small programming projects. Programming in other languages is fine, Java, C, Python, Ruby, JS. However, I've been actively learning Haskell and I've never been able to get a decent project going because of how slow and memory hungry stack/cabal/GHC are. Is there a lightweight version of GHC?
09:14:01 <hpc> my machine has half the memory and does fine
09:14:15 <lep-delete> wat
09:14:24 <monochrom> If you go 32-bit, it will relief the memory pressure.
09:14:36 <lordcirth> hasuke, how much RAM are you using before you start GHC?  Firefox can take 500MB if you aren't paying attention
09:14:48 <monochrom> But yes GHC is generous in consuming memory.
09:14:55 <hasuke> i usually have about a gig free
09:14:56 <hpc> if you are paying attention, it still takes 500MB
09:15:27 <monochrom> There is JHC if you want another Haskell compiler.
09:15:40 <monochrom> There is Hugs, an old interpreter.
09:16:13 <lordcirth> hpc, do you run 32 or 64bit? And what distro?
09:16:16 <hasuke> what about hackage?
09:16:35 <hpc> 32-bit
09:16:48 <lep-delete> i use an old netbook with 1gb ram just fine
09:18:14 <ssd> @pl length . filter (<= t) . filter (>= s) . map (a+)
09:18:14 <lambdabot> length . filter (<= t) . filter (>= s) . map (a +)
09:18:30 <ssd> @pl length . filter (<= t) . filter (>= s)
09:18:30 <lambdabot> length . filter (<= t) . filter (>= s)
09:18:41 <ssd> @pl filter (<= t) . filter (>= s)
09:18:41 <lambdabot> filter (<= t) . filter (>= s)
09:30:33 <Xnuk> @pl \t s a -> length . filter (<= t) . filter (>= s) . map (a+)
09:30:33 <lambdabot> (((length .) .) .) . (. ((. (map . (+))) . (.) . filter . flip (>=))) . (.) . (.) . filter . flip (<=)
09:30:59 <Xnuk> @pl \a -> length . filter (<= t) . filter (>= s) . map (a+)
09:30:59 <lambdabot> ((length . filter (<= t) . filter (>= s)) .) . map . (+)
09:31:16 <Xnuk> esoteric haskell
09:36:42 <haskell143> is anyone free for them to check my answers on some stuff?
09:37:59 <monochrom> no guarantee
09:38:41 <haskell143> ok, what exactly is a higher order function?
09:38:50 <haskell143> it's currying right?
09:39:00 <haskell143> when you take the input of one function into the input of another function
09:39:03 <haskell143> until you get a result?  yes?
09:39:22 <monochrom> No.
09:39:41 <Unode> haskell143: when you pass a function as the argument of another function (my understanding)
09:39:48 <monochrom> Yes.
09:40:05 <haskell143> what's an example of that?
09:40:05 <Unode> not it's output, but the function itself
09:40:11 <haskell143> ah ok
09:40:28 <monochrom> There are people who say "you need both".
09:40:30 <cocreature> haskell143: map is a good example. you pass it a function that is then applied to all elements in a list
09:40:56 <haskell143> so if you did
09:41:07 <haskell143> map (+2) [0..6]
09:41:10 <monochrom> Do not think that terminology is universally standardized uniquely. People still disagree on what to do with 0^0.
09:41:12 <haskell143> the + is the function isn't it?
09:41:40 <monochrom> Hell, people still disagree on whether "True" is a non-function or a function with 0 parameters.
09:41:47 <Unode> haskell143: no the function is (+2) which is an incomplete function (i.e. requires one more argument)
09:42:00 <haskell143> ah ok
09:42:04 <haskell143> yeh makes sense
09:42:25 <haskell143> you know lazy evaluation, that just means that Haskell will not do anything unless it is explicitly told to do something yes?
09:42:33 <haskell143> so if it needs to retrieve something it won't retrieve it until the last minute
09:42:41 <Unode> haskell143: for instance: let incomplete = doWithNumbers 4 5 ; incomplete (+) ; incomplete (*)
09:43:04 <Unode> haskell143: does that make sense?
09:43:25 <monochrom> That is not what lazy evaluation means.
09:43:31 <pavonia> Unode: What would a complete function look like?
09:43:46 <monochrom> Every programming language will not do anything unless it's explicitly told to do something.
09:43:47 <osio> succ . succ 3 > ERROR, but succ . succ $ 3 > OK, why?
09:43:50 <haskell143> yeah I can see why it's incomplete
09:43:53 <haskell143> ok so what does lazy evaluation mean?
09:44:05 <Unode> pavonia: :) monochrom was talking about True
09:44:32 <Unode> haskell143: my point is, in that example, do you see what function is actually higher order?
09:44:58 <monochrom> lazy evaluation means my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:45:03 <haskell143> yeah incomplete is
09:45:07 <Layl> Hey, anyone got a link to the GHCJS API reference docs? I can't find it
09:45:46 <pavonia> osio: "succ . succ 3" is the same as "succ . (succ 3)", where the second part isn't a function
09:46:18 <pavonia> osio: While "succ . succ $ 3" is the same as "(succ . succ) 3"
09:46:49 <Unode> haskell143: exactly
09:47:18 <Unode> haskell143: but you could say the same of doWithNumbers
09:47:27 <haskell143> how come?
09:47:35 <haskell143> because there's a *?
09:47:39 <Unode> doWithNumbers 4 5 (+)
09:47:46 <Unode> is the same as incomplete (+)
09:47:48 <haskell143> oh
09:47:56 <haskell143> yeah I see
09:48:45 <osio> pavonia : I see!! thank you for your help!!
09:49:05 <haskell143> "Lazy evaluation is a method to evaluate a Haskell program. It means that expressions are not evaluated when they are bound to variables, but their evaluation is deferred until their results are needed by other computations."
09:49:12 <Unode> lazy evaluation is you wanting to be in bed 5 more minutes and only getting out of there when the alarm clock rings for the last time before you run out of time
09:49:38 <haskell143> yeah so it means it'll only evaluate something until you have to do it
09:49:42 <haskell143> right?
09:49:51 <haskell143> otherwise Haskell will keep putting it off
09:50:29 <monochrom> FSVO "results are needed"
09:50:41 <Unode> now!
09:51:07 <Welkin> what is fsvo?
09:51:12 <haskell143> for some value of
09:51:12 <monochrom> for some version of
09:51:15 <haskell143> or that
09:51:18 <Welkin> never seen that before
09:51:27 <Welkin> see!
09:51:33 <Welkin> you don't evwn know what it means
09:51:37 <Welkin> there is no consensus
09:51:41 <Welkin> even*
09:51:55 <monochrom> I know right?
09:52:02 <haskell143> lol
09:52:58 <haskell143> what's that other advantage that Haskell has compared to other languages?
09:53:02 <haskell143> no side effects right?
09:53:14 <monochrom> This is why I am sceptic of these essay writing contests. You can mince words without meaning, and this is the only way to get full marks.
09:53:47 <monochrom> And getting full marks still doesn't imply that you can correctly predict actual program behaviour.
09:54:01 <monochrom> In fact most of the time it implies that you always incorrectly predict.
09:54:34 <monochrom> Example: main = do { x <- getLine; putStrLn "thank you" }
09:54:49 <monochrom> What will this program do?
09:54:54 <haskell143> who are you asking?
09:54:58 <monochrom> you
09:55:09 <haskell143> it puts whatever you input into the console
09:55:11 <haskell143> sets it to x
09:55:13 <haskell143> then says thank you
09:55:16 <Welkin> of course haskell has side effects
09:55:21 <Welkin> otherwise you couldn't do anything with it
09:55:27 <Welkin> but the side effects are carefully controlled
09:55:30 <monochrom> OK, but you said something about lazy evaluation and "need", no?
09:56:01 <haskell143> yeah
09:56:04 <monochrom> No one needs x. Does the computer still insist on obtaining input from you?
09:56:16 <haskell143> if you write it for it to be obtained yeah
09:56:19 <haskell143> otherwise no
09:56:49 <hpc> and how is it written in this case?
09:57:19 <monochrom> Yeah, so is it a yes or is it a no?
09:57:56 <monochrom> Did I write it for it to be obtained?
09:57:59 <haskell143> yeah
09:58:41 <monochrom> OK, here is another example. main = print (if div 0 0 == div 0 0 then 4 else 5)
09:58:57 <monochrom> What will this program do?
09:59:13 <monochrom> err that's wrong
09:59:19 <haskell143> yeah I was thinking it's wrong
09:59:19 <monochrom> main = print (if div 0 0 == div 0 0 then 4 else 4)
09:59:23 <monochrom> Better.
09:59:34 <haskell143> it's gonna return 4
09:59:47 <monochrom> OK, try it on your computer.
10:00:08 <Welkin> lol
10:00:10 <hpc> (this is building up to a couple of important concepts that are distinct from laziness)
10:00:11 <Welkin> > div 0 0
10:00:13 <lambdabot>  *Exception: divide by zero
10:00:18 <haskell143> ooh
10:00:22 <haskell143> can't divide by 0
10:00:23 <haskell143> error
10:00:29 <monochrom> No, hpc, it is verily about laziness.
10:00:43 <monochrom> <monochrom> FSVO "results are needed"
10:00:45 <Welkin> `div` is a non-total function
10:00:49 <Welkin> so it can throw exceptions
10:00:50 <monochrom> The devil is in the natural language
10:00:52 <Welkin> which is not good
10:00:58 <hpc> ah, i figured you were going to roll in purity and evaluation vs execution
10:01:05 <hpc> nvm then ;)
10:01:23 <haskell143> now what?
10:01:25 <monochrom> Well, to be sure, the getLine example was about evaluation vs execution.
10:01:59 <haskell143> yeah
10:02:15 <monochrom> The problem with essay writing contests is that there are so many dimensions I can poke holes in. Every word you write, I turn it into a controversy.
10:02:34 <haskell143> lol
10:03:03 <monochrom> You write "evaluation" I'll test what you know about "evaluation". You write "need" I'll test what you know about "need". You write "I understand" I'll test what you know about "understand".
10:03:30 <haskell143> but what's your point?
10:03:31 <haskell143> I mean
10:03:33 <haskell143> I see what you're saying
10:03:37 <haskell143> you don't want any ambiguity
10:03:46 <haskell143> you want me to understand a solid definition of what it is
10:04:17 <haskell143> but that is you rpoint
10:04:20 <haskell143> :P
10:06:21 <haskell143> what kind of differences are there in Haskell compared to other languages?
10:06:28 <haskell143> of course, Haskell is functional
10:06:30 <haskell143> and declarative
10:06:43 <haskell143> so you're only interested in what needs to be done, rather than how it needs to be done
10:06:45 <haskell143> plus it's lazy
10:06:47 <Unode> haskell143: wikipedia may know best
10:11:30 <wespiser> haskell143: lazy evaluation
10:12:23 <wespiser> haskell143: sorry, that doesn't make sense
10:12:44 <monochrom> It does. it is a difference from other languages
10:13:47 <monochrom> And in case you say "but the Haskell Report says non-strictness not laziness", most teachers don't actually know that, as far as getting marks from teachers is concerned.
10:14:10 <haskell143> foldr :: (a -> b -> b) -> b -> [a] -> b
10:14:16 <haskell143> foldr f v [] = v
10:14:25 <haskell143> foldr f v (x:xs) = f x (foldr f v xs)
10:14:35 <haskell143> I think that's recursive, higher order and polymorphic
10:14:37 <haskell143> am I right?
10:14:47 <monochrom> And as far as getting the truth is concerned, you know what, by the time you read the section on "seq", you get the feeling that the committee did have lazy evaluation in mind, they just didn't want to spell it out.
10:15:44 <haskell143> I say recursive because you have a base case which is foldr f v [] = v
10:15:49 <haskell143> then recursive call that is in the last line
10:15:57 <haskell143> polymorphic because it accepts many types
10:16:01 <wespiser> haskell143: yes, it would be considered recursive
10:16:13 <haskell143> then higher order because you're using foldr as an argument to foldr
10:16:14 <haskell143> yes?
10:16:16 <monochrom> yes, all of recursive, higher-order, and polymorphic are right
10:16:26 <haskell143> cool, ty
10:16:28 <wespiser> I would consider a language that implements foldr to be able to implement recursive function
10:16:32 <wespiser> *functions
10:16:33 <Ferdirand> because you are using a function as an argument to foldr, you meAN ?
10:16:43 <haskell143> foldr f v (x:xs) = f x (foldr f v xs)
10:16:45 <haskell143> that there
10:16:47 <wespiser> no, because foldr can call itself
10:17:02 <Ferdirand> i was talking about being higher-order
10:17:12 <haskell143> oh yeah
10:17:12 <haskell143> yeah
10:17:14 <wespiser> then yes
10:17:15 <haskell143> that's what I mean
10:17:16 <wespiser> sorry
10:17:24 <haskell143> you guys are better than my teacher
10:17:24 <haskell143> lol
10:18:06 <wespiser> in defense of your teacher, Haskell is a pretty academic subject, and very different from other programming languages
10:18:24 <wespiser> if you don't know it, there's a ton to learn
10:18:27 <glguy> Yeah, you wouldn't expect a teacher to be good at academics
10:18:55 <haskell143> ah I see
10:18:57 <wespiser> if it wasn't their disciple 
10:19:05 <hpc> also your teacher has to teach this subject to 30 people who just want it to be a couple of hours from now
10:19:34 <haskell143> umm
10:19:38 <haskell143> my teacher teaches 160 students
10:19:38 <haskell143> lol
10:19:42 <hpc> close enough
10:19:50 <haskell143> my University takes too many people on
10:19:54 <haskell143> 160 people is too much
10:20:06 <haskell143> :t middle (x,y,z) = y
10:20:08 <lambdabot> error:
10:20:08 <lambdabot>     parse error on input ‘=’
10:20:08 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
10:20:10 <wespiser> well how else can they pay for all the administration?
10:20:14 <haskell143> exactly
10:20:19 <haskell143> they have to
10:20:20 <haskell143> moeny
10:20:21 <Ferdirand> :t \(x,y,z) -> y
10:20:24 <lambdabot> (t, t1, t2) -> t1
10:20:37 <haskell143> yeah that's what I have to
10:20:40 <haskell143> do
10:20:48 <haskell143> so it's a polymorphic type?
10:21:04 <haskell143> the question asks what type should it be
10:21:09 <haskell143> so polymorphic
10:21:20 <monochrom> lambdabot just gave the answer
10:21:34 <haskell143> you know when it returns
10:21:34 <haskell143> a
10:21:36 <haskell143> and then sometimes
10:21:36 <haskell143> t
10:21:39 <haskell143> what's the difference?
10:21:51 <monochrom> that's arbitrary
10:22:07 <haskell143> ah ok
10:22:13 <monochrom> like, you like to say "f(x) = x+1", I like to say "f(t) = t+1". same difference.
10:22:18 <haskell143> ahh ok
10:22:33 <wespiser> haskell has the concept of "type variables"
10:23:31 <wespiser> what really helped me understand was ben pierce's Types and Programming Languages (TAPL)
10:45:53 <fresheyeball> who wants to show me how to flatten out these call backs with the continuation monad?
10:45:54 <fresheyeball> http://lpaste.net/3067356043827740672
10:48:44 <monochrom> This looks like multiple callbacks so it's like a tri-continuation thing and so not going to fly
10:49:13 <glguy> :t ContT
10:49:14 <lambdabot> forall k (r :: k) (m :: k -> *) a. ((a -> m r) -> m r) -> ContT r m a
10:49:40 <glguy> If you have a function with the type ((a -> m r) -> m r), you can apply ContT to it. Now you're using ContT!
10:50:08 <glguy> Does 'inContext (uniqDyn (fst <$> v))' unify with that type?
10:51:07 <glguy> also it might be worth figuring out how to make that more readable before diving into continuations, which is going to involve removing a bunch of operators
10:56:41 <haskell143> if you were to write a function
10:56:52 <haskell143> that counts how many numbers are divisible by 3
10:56:59 <haskell143> and you input a list
10:57:01 <haskell143> I guess you could do
10:57:12 <haskell143> divisibleBy3 :: [Int] -> [Int]
10:57:29 <glguy> your enter key seems to be activating on its own intermittently
10:57:35 <haskell143> divisibleBy3 :: 
10:57:39 <haskell143> mine?
10:57:55 <haskell143> well I could write it all out in one line but it's a bit harder to read isn't it?
10:58:02 <monochrom> [Int] -> Int
10:59:05 <haskell143> hmm yeah I'm not sure how to do it recursively
10:59:46 <monochrom> Do you know what to do with the base case, divisibleBy3 [] ?
10:59:50 <haskell143> yeah
11:00:02 <haskell143> divisibleBy3 [] = []
11:00:09 <monochrom> And do you know what to do with the other case, divisibleBy3 (x:xs) ? (This is where you want to recurse.)
11:00:21 <haskell143> no not sure how to formulate that
11:00:42 <monochrom> Do you know what to do if x is divisible by 3? Do you know what to do if x is not?
11:00:51 <haskell143> add it to a list?
11:00:56 <haskell143> if x is not then don't
11:01:03 <glguy> haskell143, one line per sentence is fine. so you have any code that you've tried so far you could share? or are you trying to figure out how to approach this at all?
11:01:04 <pavonia> haskell143: You said you want to count, so [] can't be a result as it isn't a number
11:01:06 <monochrom> I heard "count". what list?
11:01:18 <haskell143> glguy how to approach it
11:01:32 <haskell143> I know what the base case it, but not sure how to do the recursion
11:01:57 <haskell143> let me type out the full quesiton
11:02:16 <glguy> divisibleBy3 [] = [] would mean the count is an empty list, not a count
11:02:22 <haskell143> Write a function that counts how many numbers divisible by 3 occur in a given list of numbers.  Do this in two different ways (a) recursively and (b) higher order
11:02:25 <haskell143> just worry about recursion for now
11:02:26 <monochrom> When coding up divisibleBy3 (x:xs) = ???, assume that "divisibleBy3 xs" is already done for you by a philanthropist.
11:02:56 <monochrom> Do you want to hear a tale?
11:03:01 <haskell143> aye go on
11:03:09 <haskell143> tale recursion
11:03:10 <haskell143> :P
11:03:37 <monochrom> Doraemon has to help the kid to finish homework. It's already midnight. Homework is due 8am.
11:04:23 <haskell143> tell me more
11:04:42 <monochrom> Doraemon has a cunning plan! He has a time travel machine, right? So he goes kidnap the 2am version of Doraemon, the 4am version of Doraemon, and the 6am version of Doraemon, all to the midnight time.
11:05:12 <monochrom> So you have 4 Doraemons to do the homework at maximum concurrency and parallelism and what not.
11:05:37 <monochrom> The homework is quickly done in 1.5 hours, i.e., 1:30am. Now all Doraemon can go to sleep.
11:06:00 <monochrom> Half an hour later, he is woken up and kidnapped by a past Doraemon to do homework for 1.5 more hours.
11:06:04 <monochrom> etc etc
11:06:12 <monochrom> That is recursion.
11:06:19 <haskell143> it never ends
11:06:31 <monochrom> Oh it ends at 7:30am, don't worry.
11:06:35 <haskell143> lol
11:06:46 <_sg> ))
11:07:45 <haskell143> yeah that makes sense
11:08:28 <monochrom> "divisibleBy 3 (x:xs)" is the Doraemon at midnight. The recursive call "divisibleBy3 xs" is a future Doraemon you snatch to midnight to help you.
11:09:03 <monochrom> Or something like that. Don't take the timeline too seriously.
11:09:07 <haskell143> ok
11:09:15 <haskell143> so basically
11:09:22 <monochrom> And yes it's tale recursion.
11:09:28 <haskell143> the multipe Doraemons are solving stuff in a multithreaded fashion
11:09:46 <haskell143> once the job is done
11:09:53 <haskell143> you don't do anymore
11:09:54 <haskell143> obviously
11:11:56 <haskell143> so is that basically tale recursion?
11:12:33 <monochrom> OK here is another tale.
11:12:33 <monochrom> I need to add up 10 numbers. How am I going to do it?
11:12:33 <monochrom> I'm going to make someone else add up 9 of the numbers. Then upon that answer, I add in the last one.
11:12:33 <monochrom> (But oh, that "someone else" could be me again.)
11:12:33 <monochrom> That's recursion.
11:12:33 <monochrom> Recursion is no different from other function calls.
11:12:33 <monochrom> You call a function to subcontract part of your job. That is all.
11:14:41 <haskell143> I'll give it another shot, ty
11:15:36 <MarcelineVQ> foolish doraemon, shoulda time traveled once and copied finished work.
11:17:27 <monochrom> I should finish my project of Death Star ^W^W  recursion tutorial
11:17:41 <Rembane> Yes! Most definitely!
11:17:45 <Rotaerk> sounds just as dangerous
11:21:00 <erisco> if F is a free object then do we always have some f :: a -> F a ?
11:24:15 <fresheyeball> monochrom: sorry my baby was melting
11:25:14 <fresheyeball> monochrom: why wont it fly?
11:25:33 <erisco> increase pressure to 1.5 atm
11:28:07 <sm> it's a baby not a bird, you fool
11:37:01 <vapid> is c++ better than haskell because i can write programs faster in it?
11:37:24 <Rembane> vapid: Yes
11:37:37 <suzu> yes
11:37:43 <maerwald> totally
11:37:49 <phanimahesh> If a tool works for you, it is good.
11:39:02 <phanimahesh> Better? That's a difficult question to answer, let's default to yes.
11:39:49 <Rembane> switch(Is C++ better than Haskell?) { default: Yes; }
11:42:08 <jmcarthur> All else being equal, if you are faster at writing C++ than Haskell, you should use C++ instead of Haskell.
11:42:19 <jmcarthur> Or get better at Haskell.
11:42:37 <glguy> In any case, the many virtues and benefits of C++ are off topic in #haskell
11:42:45 <suzu> such as segfaults
11:42:51 <suzu> i love my segfaults
11:43:08 <jmcarthur> Me too. That's why I go out of my way to make my Haskell programs segfault.
11:43:30 <suzu> i also write all of my haskell programs in IO
11:43:36 <suzu> so i can get that C++ feel
11:44:33 <jarlg> erisco: If you mean F is the free functor sending a generator set a to some freely generated algebraic structure Fa, then yes. (f :: a -> F a is just the inclusion)
11:46:11 <sm> faster at writing isn't necessarily good. What about lifetime cost 
11:46:23 <erisco> okay, thanks. I am not really up on the theory
11:47:12 <erisco> this is what I expect as the free object for magmas then http://lpaste.net/351513
11:48:12 <erisco> and it seems right then that if the generator actually has the structure we've additionally given for free that we realise this structure
11:48:20 <erisco> hence "capture"
11:49:18 <erisco> which makes this suspiciously like ASTs and interpreters
11:50:26 <erisco> following the same pattern I'd expect this for monads http://lpaste.net/351514
11:50:50 <erisco> the free monad people talk about is over functors and I am not sure what that means (other than the obvious)
11:52:23 <jarlg> erisco: I don't think any of this is obvious ;) In your magma example, f :: (Magma a) => a -> Free a  sends a to Leaf a.
11:52:25 <erisco> not sure if this is a gross misunderstanding or not
11:52:51 <erisco> you mean Leaf :: a -> Free a
11:53:00 <jarlg> erisco: Yes.
11:53:04 <erisco> though if it is a misunderstanding it is still a pattern nonetheless
11:53:51 <erisco> well that is why I ask because we don't see this in the Magma class
11:54:20 <erisco> so unless we require it regardless then we're just left with Branch
11:54:36 <erisco> and now there are no inhabitants
11:55:14 <jarlg> erisco: I don't understand.
11:55:34 <erisco> did you see http://lpaste.net/351514? is it clear how I am deriving the data type from the class?
11:56:26 <erisco> each constructor is derived from a class member
11:56:31 <erisco> except Leaf
11:57:45 <erisco> and it makes me wonder if I actually need  m a -> Free m a  for monads
11:57:54 <erisco> not quite sure what the objective is with * -> * kinds
11:58:13 <palo> Hey just modelt a system I wanna implement. But I want to test functions with a signature like exec :: (Context a) => a -> IO ()
11:58:36 <palo> Is there a nice way (which i could not find with google) to test IO () functions ? 
12:00:11 <palo> Right now I think I have to test all the function I call in exec, but can't test exec itself
12:00:27 <erisco> jarlg, I dunno, I'm probably too skew to relate
12:00:33 <jarlg> erisco: I had a look and I'm sorry I don't have an answer for you. My earlier answer holds if we talk about the free functor in universal algebra, I'm not sure here. :)
12:00:57 <glguy> palo: That's probably too general of a question to have an answer. (Also, IO () isn't the type of functions)
12:01:21 <glguy> How you test something is going to be tied to what it does
12:08:13 <palo> glguy: yeah I think you are right. 
12:09:29 <Schoolmeister> Hey, I've got a small question. If I unpack a value from a monad transformer, do I get the monad underneath, or do I get the value at the bottom of the stack? For example in this case: http://lpaste.net/5169673296051961856 is b of type Maybe or of type a?
12:10:02 <erisco> it is a stack, so you unpack outside in
12:10:05 <palo> glguy: thanks. I will put some energy in thinking about modeling something that is testable.
12:10:13 <Schoolmeister> So it's a maybe?
12:10:35 <hpc> :t runStateT
12:10:37 <erisco> :t runMaybeT
12:10:37 <lambdabot> StateT s m a -> s -> m (a, s)
12:10:39 <lambdabot> error: Variable not in scope: runMaybeT
12:10:52 <Schoolmeister> sorry i dc'ed
12:11:11 <Schoolmeister> Could you expain what you meant with outside in?
12:11:14 <erisco> well, anyways, it will be Maybe (m a)
12:11:24 <hpc> :t runStateT -- Schoolmeister: look at the run* functions
12:11:27 <lambdabot> StateT s m a -> s -> m (a, s)
12:11:33 <erisco> sorry I mean m (Maybe a)
12:12:27 <mmachenry> The stack documentation says that when I run "stack test" that this is supposed to run Spec.hs (the default file I was given) and print "Not yet implemented" It's not doing that on a default project. Anyone know why?
12:13:11 <erisco> Schoolmeister, I mean that you peel off the outermost transformer first
12:13:14 <Schoolmeister> erisco: why m (Maybe a)? I thought the runMaybeT returned an m (Maybe a), and then the <- operator returns the (Maybe a)?
12:13:26 <hpc> "<-" isn't really an operator
12:13:39 <erisco> I am saying runMaybeT returns m (Maybe a)
12:13:46 <erisco> and yes, <- is absolutely not an operator
12:13:48 <Schoolmeister> not sure what to call it then, I know it's syntactic sugar
12:13:53 <Schoolmeister> oh okay
12:14:38 <erisco> I think the term should be "construct"
12:14:49 <erisco> "language construct" though that is a bit clunky
12:15:09 <erisco> x <- m is m >>= \x ->
12:15:38 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/5169673296051961856#a351517
12:15:43 <erisco> so a little more sane to say  x <- m; n  is  m >>= \x -> n
12:15:49 <glguy> Schoolmeister: Check out that paste, using type wildcards is a great way to inspect types
12:15:53 <hpc> i wouldn't consider "<-" to be anything at all
12:16:01 <hpc> other than a part of the grammar
12:16:10 <hpc> it'd be like calling "{" a "block introducer"
12:16:20 <erisco> but we call { m } a block
12:16:33 <erisco> I don't know what x <- m should be called
12:16:36 <erisco> a functional statement ;)
12:16:41 <t7> what do you call a set of things you add together to get a sum
12:16:47 <Schoolmeister> erisco: yeah I know about >>=, I was getting a bit confused with the transformers though. 
12:16:50 <Schoolmeister> Thanks for the help guys
12:17:00 <erisco> t7, a series
12:17:02 <Schoolmeister> I'll take a look at the paste
12:17:17 <t7> cheers
12:29:34 <wespiser> isn't "x <- m" called a monadic binding?
12:30:07 <geekosaur> only via its desugaring to bind
12:30:12 <wespiser> where "x <- m ; f " => "m >>= \x -> f"
12:30:28 <geekosaur> "bind" being the common name of (>>=)
12:30:49 <Philippa> and by, y'know, the part where do blocks look much like ANF let blocks
12:31:33 <seagreen> What would be the best way to wrap up a bunch of non-haskell files for use by haskell libraries? For instance, there's a language agnostic test suite for json schema here: https://github.com/json-schema-org/JSON-Schema-Test-Suite. In this case it's pretty small so I could just use `file-embed` and expose it as a Haskell object, but what if it was many gigabytes of test files?
12:32:22 <hpc> does that belong in the package and not in some separately distributed thing?
12:34:17 <seagreen> hpc: I'd be making a new Haskell library for use by other haskell libs, that would hopefully be more convenient than vendoring the test suite. (One big convenience gain would be that the library would take care of parsing the files)
12:36:56 <implementation> @run iterate (+1) 9000
12:37:00 <lambdabot>  [9000,9001,9002,9003,9004,9005,9006,9007,9008,9009,9010,9011,9012,9013,9014,...
12:39:33 <seagreen> I guess I'm saying that with a small amount of files, it wouldn't be a problem to use `file-embed` and expose a `[(FilePath, ParsedFile)]`, but with a large amount of files it might be better to expose some kind of stream of `(FilePath, ParsedFile)`, is there a way to set this up at compile time?
12:49:47 <cheater> does anyone how to grep for a type such that the output type specifically does not contain the string "Foo" but one of the input types does?
12:51:12 <cheater> seagreen: you're not going to embed gigabytes of files into your repo or your library, right? that would be a very bad idea.
12:52:30 <seagreen> cheater: Right! I'm trying to figure out how to avoid that, in a hypothetical situation like one where you were trying to expose the parsed JSON Schema test suite (all .json files) from a library.
12:52:44 <cheater> you'd normally host a tarball somewhere
12:53:03 <seagreen> cheater: That's a very practical approach.
12:53:11 <erisco> I wish you could still have contexts for parameters of * -> * and higher kind classes
12:53:28 <cheater> if it's gigabytes in size you'd add a http-backed torrent download link
12:53:35 <erisco> for example, a Category where objects are Ord
12:53:41 <hexagoxel> cheater: you need some lookahead-magic for the "does not contain" part..
12:54:07 <erisco> the lack of this polymorphism is such a headache
12:54:33 <cheater> hexagoxel: like what magic?
12:55:09 <erisco> for example, Set could be a Functor if this was a feature
12:55:46 <erisco> and rather silly that it can't be
12:56:45 <erisco> when meanwhile we can make functions a Num
12:57:30 <erisco> anyone with me on this? :)
12:58:05 <glguy> if you want to make a type class for that you could
12:58:16 <glguy> it's just not what the Functor class is
12:58:21 <hexagoxel> cheater: (?!.*Foo.*) or something like that? i normally stick to regular parts of regexes, so i'd have to test..
12:58:21 <erisco> a type class per constraint set? ridiculous
12:58:35 <monochrom> Is there a short program that outputs the large file you want?
12:59:16 <hexagoxel> @hackage ConstraintKinds
12:59:16 <lambdabot> http://hackage.haskell.org/package/ConstraintKinds
12:59:22 <hexagoxel> erisco: ^ like that?
12:59:32 <erisco> no, what I am talking about is not a feature
12:59:58 <hexagoxel> that is a package name, not -XConstraintKinds
13:00:26 <hexagoxel> it probably uses the extension of course
13:00:33 <hpc> erisco: possibly the term you're looking for is indexed functor?
13:01:21 <erisco> hexagoxel, actually then yes, this seems like it, but I don't know what it is doing to make it happen
13:01:28 <erisco> I don't know what a type in a class means
13:01:58 <hexagoxel> associated types? look at the type families wiki page
13:02:34 <erisco> I know type families yet not this usage of them
13:02:44 <ludat_> what's the most common jwt library?
13:02:49 <erisco> judging by the VU.Vector instance this is exactly what I mean
13:03:05 <erisco> so then our issue is that base doesn't define the classes like this
13:03:22 <cheater> i figured it out: echo 'foo -> bar -> baz' | awk -F '->' '($NF ~ /ba/){print}'
13:03:39 <erisco> right, open type families, bleh, that is what it is
13:03:45 <cheater> so now i can go and do something like grep ...... --color=always | awk .....
13:03:47 <erisco> in my mind I am only thinking of closed
13:04:32 <fresheyeball> has anyone tried to get dimential and linear to place nice together?
13:04:55 <seagreen> cheater: Any idea at what package size I should start to think about distributing some of the data outside of the package? Not sure what Hackage's preference is.
13:05:11 <erisco> so where do I sign to get this in the next base version?
13:05:31 <erisco> absolute no-brainer
13:07:19 <glguy> it would benefit less convenient than you might be imagining
13:07:31 <glguy> meant: would be.
13:07:36 <hexagoxel> yeah break everyones code, just so you can omit this dependency.
13:07:37 <erisco> Functor Set man, what else do you need
13:07:49 <erisco> dependency? no, that isn't it at all
13:07:49 <glguy> perhaps try defining tyre class you want and try using it
13:08:01 <erisco> all code is written against the base classes
13:08:33 <monochrom> You don't sign. You bribe or blackmail.
13:08:49 <hexagoxel> erisco: and all code needs to be rewritten against those new classes, independent of whether they are in base or not.
13:08:52 <erisco> or stab someone for their shoes
13:09:19 <hexagoxel> so first you do all the rewriting based on the existing, non-base package, then we can talk about next steps :p
13:09:24 <erisco> hexagoxel, why is it breaking?
13:10:04 <hexagoxel> because all instances need adaption, base or elsewhere?
13:10:43 <erisco> no, because it has a default to the empty context, which is already what everything uses
13:11:39 <hexagoxel> won't this force everyone to use -XConstraintKinds?
13:12:15 <erisco> I don't know, I'd have to see if instancing a class defined with it also requires it
13:12:20 <erisco> even if you use the default
13:12:27 <hexagoxel> and you can define defaults for associated types?
13:12:38 <erisco> look http://hackage.haskell.org/package/ConstraintKinds-1.3.0/docs/src/Control-ConstraintKinds-Functor.html
13:19:05 <larhat> Hi, is it possible to instruct `intero-repl` (emacs) to pass `- -test`?
13:22:37 <mmachenry> I've discovered an oddity with with stack packages. If I create a default stack project and run test, it works. I get "not yet implemented" because it runs the test/Spec.hs which is listed as the main program for test-suite. This is expected.
13:23:21 <lyxia> erisco: every occurrence of (Functor f) would need to be rewritten with (Functor f, FunctorConstraint f a, FunctorConstraint f b)
13:23:25 <mmachenry> But if I add a github repo to the stack.yaml packages and do nothing else, then run stack test, it no longer runs my test/Spec.hs program. I'm surprised by that.
13:23:31 <mmachenry> Is this intended? Is this a bug?
13:24:26 <erisco> I suppose so
13:24:49 <lyxia> erisco: and it's not even possible if you're using your Functor at infinitely many or existentially quantified types 
13:25:24 <erisco> by "or" do you mean "i.e." ?
13:26:59 <lyxia> no, I mean two different situations where things break badly. 
13:29:51 <erisco> what does it mean to use a Functor at infinitely many types?
13:30:16 <lyxia> this happens with polymorphic recursion 
13:31:43 <erisco> what is an example?
13:34:38 <geekosaur> having a typeclass instance which delegates to a different instance of itself e.g. "instance Show [a] where show x = showList x" (showList being [a] -> String for Show a; this is a hack to avoid overlapping instances while sticking to Haskell98)
13:35:00 <lassulus> hey beautiful people, I tried starting lambdabot with -XGADTs but I still get the error: "Illegal generalised algebraic data declaration (Use GADTs to allow GADTs)" is there another way to activate it?
13:35:18 <geekosaur> er?
13:35:18 <lyxia> data T a f = C (f (a, Int)) | D (T [a] f)  -- try to add one to the Int 
13:35:46 <hpc> as in, ./lambdabot -XGADTs?
13:35:57 <geekosaur> lassulus, if you mean in @run then you need to add it to the state for @run
13:36:27 <lassulus> this was for @let
13:36:34 <lassulus> But I guess its the same
13:36:46 <erisco> well for starters what is the Functor instance?
13:36:53 <geekosaur> yes, would be the same
13:37:00 <geekosaur> @where L.hs
13:37:00 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
13:37:10 <geekosaur> feh, no, that's not the one I hoped
13:39:52 <geekosaur> oh, I guess it is Pristine.hs
13:40:12 <geekosaur> that is, you add the pragma to the top of state/Pristine.hs (or state/Pristine.hs/<ver>)
13:40:14 <geekosaur> ...
13:40:26 <geekosaur> state/Pristine.hs.<ver>
13:40:33 <lassulus> hmm, could be a problem with nix
13:40:36 <lassulus> but I will figure it out
13:40:38 <lassulus> thanks
13:40:54 <lyxia> erisco: this is not meant to be a Functor. You can write a function (Functor f => T a f -> T a f) that does what I asked. You can't with this fancy generalized Functor. 
13:40:57 <geekosaur> the state is mutable, if nix is messing with it then you will have bigger problems
13:41:08 <monochrom> Oh, right, remember that unrecognized pragmas are silently ignored, and misplaced implies unrecognized.
13:41:09 <lassulus> oh is it? where is it saved then?
13:41:38 <lassulus> nvm found it
13:43:03 * geekosaur kinda wants misplaced start-only pragmas to get warnings
13:43:31 <dolio> Is there no -W for that?
13:43:46 <monochrom> I don't know. Would be nice.
13:43:59 <dolio> I know they used to be errors, but I didn't realize they 'fixed' that by making them silent.
13:44:15 <geekosaur> there's a warning for unrecognized pragmas
13:44:22 <monochrom> Ah OK good.
13:44:24 <geekosaur> but this is a recognized pragma in the wrong place
13:44:30 <dolio> Oh.
13:44:56 <erisco> lyxia, I suppose you'd need x to be universally quantified in "type FunctionConstraint f x"
13:45:00 <geekosaur> possibly that gets reported with -Wunrecognized-pragmas, but that doesn't seem to be in -Wall
13:45:10 <erisco> lyxia, seems type families does too much here
13:46:57 <erisco> so I have to go back wishing for the extension that actually does what I want
13:47:49 <geekosaur> or maybe it is but people don't use -Wall enough, but people do seem to get bitten by a pragma being too late quite a lot :/
13:48:07 <geekosaur> and -Wall is a wall of noise if you need to be compatible with older ghc versions
13:49:08 <monochrom> -Wunrecognized-pragmas is an unrecognized flag (GHC 8.0.2 brand new shiny bling bling)
13:50:37 <monochrom> haha "need to be noise for compatibility"
13:51:04 <geekosaur> oh, whoops, speak Glaswegian :p -Wunrecognised-pragmas
13:51:19 <monochrom> yikes
13:51:58 <monochrom> No, I musteth protesteth. yikez.
13:53:02 <davean> monochrom: oh please 8.0.2 has been out for ages, I'm pretty sure GHC-f9ccad236fa6042a3abbb655129f47fe9dadceaf is the new hotness
13:53:21 <alproxy> Can someone please look at my code. It's a very simple code but for some reason it's not working
13:53:21 <monochrom> But I doth approve of the spelling of "hscolour", being Canadian :)
13:53:24 <alproxy> > data ModInt = ModInt Int; instance Read ModInt where readsPrec d = fmap ModInt (readsPrec d :: ReadS Int)
13:53:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
13:53:56 <glguy> type ReadS a = String -> [(a, String)]
13:53:57 <monochrom> davean: Have you been living in Narnia lately? :)
13:54:14 <glguy> So, ReadS Int = String -> [(Int, String)]
13:54:28 <hpc> monochrom: just set a cronjob that downloads the latest ghc from npm
13:54:32 <glguy> so you're using fmap on a function type
13:54:35 <monochrom> "I have been king in Narnia for 30 years since GHC 8.0.2"
13:54:41 <glguy> alproxy: That's fine, but it's not what you intended
13:55:07 <alproxy> I still didn't get it. Function type?
13:55:14 <alproxy> ReadS is a functor
13:55:18 <davean> monochrom: 8.0.2 is 10 days old! f9ccad236fa6042a is only 4 hours old, its 60 times better!
13:55:26 <glguy> alproxy: ReadS is not the functor you're thinking
13:55:27 <monochrom> \∩/
13:55:29 <erisco> why does Narnia get more CPU time? it isn't fair
13:55:33 <glguy> alproxy: ReadS is a *type synonym*
13:55:44 <alproxy> Ohh..
13:55:44 <fresheyeball> is there a name and existing module for a data structure like this:  Listish [a] a [a]
13:55:47 <fresheyeball> ?
13:55:59 <geekosaur> and it's not a parser, it's a difference list (a list encoded as a composition of functions)
13:56:00 <alproxy> So what's the correct way of deriving a show instance
13:56:06 <glguy> alproxy: If ReadS was instead a newtype, then your intuition would be right on
13:56:26 <monochrom> Create your own newtype :)
13:56:36 <glguy> alproxy: The correct way to make a Read instance is "deriving (Read)"
13:56:43 <alproxy> Am I allowed to do this>
13:56:54 <glguy> Otherwise you'll have to do something a little more complicated than fmap
13:56:55 <monochrom> Two birds in one stone. 1: Now you do have a newtype.  2: Now you can write instances.
13:57:03 <erisco> only if you have your deriving license
13:57:03 <glguy> a list comprehsion would make it look nice
13:57:11 * erisco snickers
13:57:20 <alproxy> But it will read the wrong format(like ModInt 1223)
13:57:31 <glguy> Yeah, that's the idea of Read
13:57:55 <glguy> readsPrec p str = [ (ModInt x, str') | (x,str') <- readsPrec p str ]
13:58:40 <glguy> Generally the format that Read takes should be the same as the Haskell syntax for that same thing
13:58:55 <glguy> It's a debugging tool
13:59:28 <alproxy> Thanks for the help. It's working now
13:59:33 <erisco> read what you show, show what you read
13:59:44 <monochrom> This is unfortunately because show is also the best way to pretty-print a number.
14:00:20 <alproxy> Show instance was easy as I can just print the Int
14:01:26 <glguy> If you had (and you probably should have) defined: newtype ModInt = ModInt Int, then you can have:
14:01:47 <glguy> instance Read ModInt where readsPrec = coerce (readsPrec :: Int -> ReadS Int)
14:02:14 <monochrom> yikes
14:03:02 <monochrom> . o O ( newtype X = Xtor Bool coercing (Read, Show, Coercible) )
14:03:40 <alproxy> Yeah. I should have used newtype
14:04:11 <alproxy> But still I had no knowledge of coerce so I couldn't have done that
14:04:34 <monochrom> You can always handcode code.
14:06:28 <fresheyeball> come on folks, I know this thing has to have an name in Haskell
14:06:35 <fresheyeball> it Elm its called Pivot
14:06:44 <geekosaur> zipper
14:06:45 <fresheyeball> data Pivot = Pivot [a] a [a]
14:06:55 <fresheyeball> zipper doesn't have a center
14:06:56 <monochrom> yeah zipper
14:06:58 <geekosaur> but not sure it's predefined
14:07:33 <monochrom> Actually what do they use Pivot for, and how?
14:07:59 <fresheyeball> Pivot is useful in UI dev for things like slide shows or tabs
14:08:08 <fresheyeball> where you have one thing selected from a list of things
14:08:21 <fresheyeball> and you want a guarentee that the selected thing is in the list of things
14:09:56 <geekosaur> how is that not a zipper?
14:10:16 <monochrom> Does it mean that suppose I want to walk through the sequence [a,b,c,d]. Then I go through these states: ([], a, [b,c,d]), ([a], b, [c,d]), ([b,a], c, [d]), ([c,b,a], d, [])
14:10:20 <hpc> it's the zipper for NonEmptyList
14:10:34 <fresheyeball> ok!
14:10:36 <fresheyeball> that helps
14:10:43 <fresheyeball> do you know if that is written already?
14:10:47 <geekosaur> hm, yes, that makes sense
14:10:50 <fresheyeball> or do I need to publish this?
14:10:53 <geekosaur> probably not as a standalone type
14:11:27 <monochrom> Look for a paper or talk about "differentiating a type".
14:11:42 <geekosaur> "one-hole context"
14:12:01 <monochrom> I forgot whether it's McBride's or Mitchell's or ...
14:12:07 <Tuplanolla> It's McBride's.
14:12:40 <monochrom> Believe me, pivot is just the tip of the iceberg.
14:13:04 <geekosaur> I mean, xmonad has that type but not in a way that's useful for other programs (data Stack a)
14:21:32 <lassulus> alright, another lambdabot question: how can I set the maximum lines of output? lambdabot in here seems only to output 1 line
14:24:51 <geekosaur> actually it does 3 lines in here, sometimes resumable with @more; I suspect that's hardcoded somewhere, and doesn't apply to pm
14:26:11 <lassulus> oic, is there a way to simulate this behavious if I call lambdabot with -e ?
14:28:28 <dmwit> fresheyeball: There are several zipper packages on Hackage.
14:29:27 <fresheyeball> dmwit: I looked
14:29:33 <fresheyeball> nothing that looks right so far
14:29:47 <fresheyeball> also I'm starting to think that a NonEmptyZipper is not a Monad
14:30:35 <fresheyeball> I don't think a NonEmptyZipper is a Monoid either :(
14:30:48 <c_wraith> fresheyeball: traditionally, zippers are comonads
14:30:51 <hpc> it's maybe a semigroup
14:30:53 <geekosaur> semigroup, I think
14:31:00 <fresheyeball> I don't think so
14:31:06 <fresheyeball> but I would be interested if you have an idea
14:31:13 <geekosaur> in fact I seem to recall NonEmptyList got added to base on the strength of being the reference Semigroup instance
14:31:34 <fresheyeball> data NonEmptyZipper a = NonEmptyZipper ![a] !a ![a]
14:31:50 <fresheyeball> I don't think its a Semigroup
14:32:43 <c_wraith> it is certainly a Comonad, though
14:32:52 <geekosaur> @instances-importing Data.Semigroup NonEmptyList
14:32:57 <lambdabot> Couldn't find class `NonEmptyList'. Try @instances-importing
14:33:03 <dmwit> I don't see why it can't be a Monad, using essentially the same instance as the list instance.
14:33:08 <geekosaur> whoops
14:33:18 <geekosaur> @instances-importing Data.List.NonEmoty Semigroup
14:33:20 <lambdabot> Couldn't find class `Semigroup'. Try @instances-importing
14:33:21 <geekosaur> sigh
14:33:25 <geekosaur> @instances-importing Data.List.NonEmpty Semigroup
14:33:27 <lambdabot> Couldn't find class `Semigroup'. Try @instances-importing
14:33:40 <fresheyeball> dmwit: Can you show me how you would write >>= ?
14:33:43 * geekosaur gives up, not firing on all cylinders today
14:34:06 <dmwit> fresheyeball: Give me a sec.
14:34:12 <fresheyeball> I don't think its a Monad for the same reason I don't think its a Semigroup
14:34:48 <dmwit> Okay. The complaint is that there are too many focuses after the bind, huh? Sounds like a reasonable complaint.
14:35:08 <geekosaur> oh, the zipper not the list itself
14:35:10 <geekosaur> derp
14:35:17 <geekosaur> not on all cylinders like I said :/
14:35:28 <fresheyeball> geekosaur: all good homie
14:36:50 <c_wraith> fresheyeball: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html talks about using that type as a comonad 
14:37:35 <dmwit> fresheyeball: Why doesn't `Zipper ls h rs <> z = Zipper ls h (rs ++ toList z)` make it a `Semigroup`? (With `toList (Zipper ls h rs) = ls ++ [h] ++ reverse rs`.)
14:38:30 <fresheyeball> dmwit: I like that
14:38:40 <fresheyeball> looks like it might be two Semigroups then
14:38:46 <dmwit> right
14:38:50 <fresheyeball> depending on which side we use toList
14:39:38 <taktoa> well you also have to make a choice about whether or not to use `reverse`, no? I would think it was associative either way
14:40:26 <dmwit> fresheyeball: How about `join (Zipper lss (Zipper ls h rs) rss) = Zipper ((lss >>= toList) ++ ls) h (rs ++ (rss >>= toList))` for the `Monad` instance?
14:41:48 <fresheyeball> dmwit: I don't get that one
14:44:46 <dmwit> fresheyeball: To turn a `Zipper (Zipper a)` into a `Zipper a`, take the focus of the focus as your new focus. Take all the stuff to the left as the stuff to the left, and all the stuff to the right as the stuff to the right.
14:45:37 <dmwit> Though it's possible the `lss >>= toList` bit should be something like `lss >>= toReversedList` or something.
14:45:40 <dmwit> Let's test that.
14:46:02 <hpc> in other words, Zipper [Zipper [a] b [c]] d [Zipper [e] f [g]] becomes Zipper [a, b, c] d [e, f, g]
14:46:53 <fresheyeball> ok I get it now
14:46:54 <fresheyeball> nice!
14:51:45 <dmwit> Okay, I think it should be: `join (Zipper lss (Zipper ls h rs) rss) = Zipper (ls ++ (lss >>= toReversedList)) h (rs ++ (rss >>= toList))`.
14:52:05 <dmwit> It's tricky to get it right -- I keep tying myself up in knots trying to remember which direction I'm going!
14:52:59 <dmwit> It would probably be easier using `Tsil a` in places where we want a snoc-list.
14:53:49 <NatureShade> "<command line>: can't load .so/.DLL" error with cabal and HsQml, it works fine with ghc directly, any tricks?
14:59:27 <wespiser> call by value is the dual of call by need : does anyone know the citation for this?
15:08:14 <ubsan> wespiser: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
15:09:14 <wespiser> ubsan: thanks!
15:09:35 <dolio> Note, that says "name" not "need".
15:12:09 <NatureShade> anyone have any idea of what to do with this? <command line>: can't load .so/.DLL for: /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/libQt5Widgets.so (/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/libQt5Widgets.so: symbol _ZN22QGuiApplicationPrivate20scrollNoPhaseAllowedE, version Qt_5_PRIVATE_API not defined in file libQt5Gui.so.5 with link time reference)
15:13:29 <monochrom> Yeah, I was thinking they are not duals.
15:14:04 <monochrom> But you can always cite http://www.vex.net/~trebla/humour/lmcify.html
15:17:03 <dmwit> As suspected, the construction is much more obviously correct with a proper snoc-list type.
15:18:59 <wespiser> dolio: oic, thanks
15:30:58 <dmwit> Hm. Haddock doesn't show pattern synonyms?
15:31:37 <wespiser> monochrom: I could always show they are duals, or spend a couple years trying
16:13:42 <shayan_> factors n = [x | x <- [1..n], n `mod` x == 0]
16:13:46 <shayan_> factors 100000000000000
16:14:05 <shayan_> why does it take so long to compute all the possible answers? :)
16:14:19 <hpc> it's trying all of them
16:14:57 <hpc> use rem, it'll be faster :D
16:15:37 <shayan_> not sure how yet :(
16:15:53 <hpc> :t mod
16:15:55 <hpc> :t rem
16:15:56 <lambdabot> Integral a => a -> a -> a
16:15:58 <lambdabot> Integral a => a -> a -> a
16:16:04 <hpc> > (5 `mod` 2, 5 `rem` 2)
16:16:08 <lambdabot>  (1,1)
16:16:26 <hpc> but also that list is just equal to [1..n]
16:17:02 <shayan_> what would happen if i asked lambdabot to compute factors 100000000000000 in this channel?
16:17:34 <Gurkenglas> > let factors n = [x | x <- [1..n], n `mod` x == 0] in factors 100000000000000
16:17:40 <lambdabot>  mueval-core: Time limit exceeded
16:17:54 <shayan_> :P
16:18:05 <shayan_> let factors n = [x | x <- [1..n], n `mod` x == 0] in factors 100
16:18:11 <shayan_> > let factors n = [x | x <- [1..n], n `mod` x == 0] in factors 100
16:18:14 <lambdabot>  [1,2,4,5,10,20,25,50,100]
16:18:22 <shayan_> let factors n = [x | x <- [1..n], n `mod` x == 0] in factors 1000
16:18:30 <shayan_> > let factors n = [x | x <- [1..n], n `mod` x == 0] in factors 1000
16:18:33 <lambdabot>  [1,2,4,5,8,10,20,25,40,50,100,125,200,250,500,1000]
16:18:34 <Gurkenglas> Use /query lambdabot unless demonstrating
16:18:53 <ggVGc> > print "Don't abuse me, plz"
16:18:57 <lambdabot>  <IO ()>
16:18:59 <hpc> > fix error
16:18:59 <ggVGc> oh
16:19:00 <ggVGc> :(
16:19:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:19:37 <hpc> but yeah, keep experimentation to private messages unless it has to do with the current conversation
16:19:53 <shayan_> okay :)
16:20:51 <ggVGc> > "Everything is "++everything where everything is "nothing"
16:20:59 <lambdabot>  <hint>:1:30: error: parse error on input ‘where’
16:21:02 <ggVGc> ah well
16:21:09 <ggVGc> > "Everything is "++everything where everything = "nothing"
16:21:11 <unskill> How to copulate monads with arrows?
16:21:15 <lambdabot>  <hint>:1:30: error: parse error on input ‘where’
16:21:50 <ggVGc> do people actually use arrows?
16:22:08 <unskill> I use (>>>) as a pipe operator
16:22:16 <unskill> f >>> g, you know
16:22:17 <geekosaur> Kleisli?
16:23:20 <unskill> More exact question: there is code like getLine >>= (f1 >>> f2 >>> ... >>> fn >>> return) >>= putStrLn
16:23:55 <unskill> I need (parens) because of parsing error. >>= and >>> have the same priority but different associativity
16:24:12 <lpsmith> shayan_, you can factor 100000000000000 quite quickly using naive factoring algorithms;  once you have the prime factorization,  you can generate all the factors quite quickly
16:24:12 <unskill> Is there a way to get rid of parens and return in the end?
16:24:46 <glguy> unskill: putStrLn . fn . ... . f2 . f1 =<< getLine
16:24:58 <shayan_> lpsmith: can that be accomplished on the terminal?
16:25:06 <unskill> glguy: no, I want left-to-right order
16:25:55 <unskill> I'm neither jew nor arab. I read from left to right.
16:26:13 <glguy> Apparently not a Haskell programmer, either
16:26:34 <unskill> glguy: T_T
16:27:00 <Gurkenglas> getLine >>= (f1 >>> f2 >>> ... >>> fn >>> putStrLn) is a first step; you can define your own version of >>> that associates the >>= way
16:27:21 <glguy> You should read fn . ... . f2 . f1 left-to-right too
16:27:36 <glguy> due to lazy evaluation fn is driving the evaluation of the rest
16:27:55 <glguy> and then if it forces its argument, the ... is driving it, and so on
16:29:12 <unskill> Gurkenglas: first step works.
16:29:52 <lpsmith> shayan_: yes, but it might get a bit ugly.   Better to create a .hs script of helper functions and then load that into the terminal.
16:30:57 <codygman> What do you guys think of my ascii art lens explanation? http://lpaste.net/5162996189569744896
16:31:33 <ggVGc> why is it ascii art?
16:31:36 <monochrom> Marvellous
16:31:39 <ggVGc> I think it's pretty cluttry
16:31:58 <ggVGc> it's nice, but would do better as an actual image
16:32:22 <Gurkenglas> You mean with the condition that those values are `elem` ["HK", "LU"]
16:32:32 <monochrom> ascii art is presumably because if you want to put that in comments in your source code file, ascii art is the only choice left.
16:32:48 <monochrom> because source code files must be plain text files for an unknown reason
16:33:02 <monochrom> And so I ask again: When will programming be liberated from the plain text file?
16:33:23 <ggVGc> monochrom: when we are able to make tools that process other things as easily
16:33:33 <lpaste> Gurkenglas annotated “No title” with “What do you guys think of my ascii art lens explanation?” at http://lpaste.net/5162996189569744896#a351527
16:33:46 <MissingNoIOI> When everything has changed towards UTF-8 or UTF-32
16:33:57 <monochrom> Yeah, and when will we make those tools? Answer: When programmers step out of plain text files.
16:33:58 <codygman> ggVGc: Any suggestions on improving?
16:34:07 <codygman> monochrom: Thanks!
16:34:20 <unskill> MissingNoIOI: ?
16:34:22 <ggVGc> codygman: I think it's good, but I think it would do better as an image
16:34:31 <ggVGc> but if you want ascii, then I think it's real nice
16:34:33 <lpaste> MissingNoIOI pasted “Linker errir during sanity check” at http://lpaste.net/6559619481490948096
16:34:51 <lpaste> MissingNoIOI revised “Linker errir during sanity check”: “Linker error during sanity check” at http://lpaste.net/6559619481490948096
16:34:52 <seequ_> Mathematica allows pretty much anything (images, graphs, pretty equations) in code, but the benefit is questionable.
16:35:06 <codygman> ggVGc: I might make an image later, but wanted to quickly try to make the explanation in ascii art now. Thanks for the input
16:35:14 <monochrom> Let me give you a chance to call me heretic by saying: If you put your code in Word, you can embed a picture there.
16:35:15 <ggVGc> codygman: there's already things like PureData, where you visually move things around and can create blocks in for example Lua or other languages
16:35:19 <ggVGc> eh, sorry
16:35:21 <ggVGc> monochrom: ^
16:35:59 <ggVGc> monochrom: also, the little VHDL development I did was in Xilinx tools, where you have one view to move around and connect modules which you in turn write in VHDL
16:36:07 <seequ_> Coding with a mouse? :P
16:36:12 <ggVGc> and it generates the rest of the circuit
16:36:22 <unskill> monochrom: Word is a proprietary peace of ...
16:36:24 <MissingNoIOI> Ah, sry, i thought it was about including things like emoji's in source code, the variety of unicode art is far greater than the one of ASCII art
16:36:24 <codygman> ggVGc: I'll look at PureData
16:36:33 <ggVGc> codygman: sorry, it was for monochrom 
16:36:44 <ggVGc> but feel free to look at it too :)
16:36:47 <unskill> *piece )
16:36:55 <ggVGc> it's a programming environment where you visually connect blocks
16:36:56 <geekosaur> MissingNoIOI, that's the no-pie issue, I think you need to wait for a stack update and use ghc 8.0.2
16:37:06 <MissingNoIOI> I dont have pie
16:37:06 <ggVGc> but you can write implementations of blocks with Lua, using an extension
16:37:07 <monochrom> MissingNoIOI: Yeah, but what if you want to draw a network...
16:37:08 <geekosaur> (just 8.0.2 is not sufficient, stack needs a patch)
16:37:09 <ggVGc> and in C afaik
16:37:45 <MissingNoIOI> I use Gentoo, and without the Hardened Gentoo patches my gcc doesnt even seem to support pie
16:38:08 <ggVGc> monochrom: game development environments can also be seen as not just ascii, since modern game dev is very much data driven, and often a case of building an environment in a tool and connecting it with behaviours
16:38:14 <ggVGc> same for UI of mobile apps
16:38:29 <ggVGc> I dunno, I don't think we're really doing text-only development that much anymore
16:39:10 <MissingNoIOI> geekosaur: Any idea what else it could be?
16:39:41 <monochrom> There is a unicode evil face emoji that I would really like to use in place of _|_
16:39:44 <unskill> Gurkenglas: but getLine >>= (f1 >>> f2 >>> ... >>> fn >>> putStrLn)  looks asymmetric
16:40:00 <monochrom> In fact, I just did this Wednesday during the Toronto Haskell meetup.
16:40:02 <MissingNoIOI> geekosaur: I've got ghc 8.0.1 running perfectly from the official haskell overlay
16:40:26 <geekosaur> no, sorry
16:40:45 <unskill> :t (^>>)
16:40:47 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
16:42:39 <MissingNoIOI> anyone else got any idea why the ghc install fails with a linker error when trying to setup anything with stack on Gentoo (and its not the pie error)? http://lpaste.net/6559619481490948096
16:55:42 <monochrom> Long shot: Corrupted file? Nondeterministic hard disk?
16:58:25 <MissingNoIOI> Already downloaded it again
16:58:35 <MissingNoIOI> I#m actually quite stumped by this error
16:59:18 <MissingNoIOI> So far I've resorted to using the system ghc and praying that I won't ever have to use anything but ghc 8.0.1
17:45:51 <Axman6> so with the introduction of TypeApplications, is it possible to remove from classes the use of Proxy to signify types to the compiler for "constant function" members? so where I would've had class Foo a where bar :: Proxy a -> Text, could you now have bar :: Text, and use bar @Bool to fill the type parameter in the Foo a constraint?
17:48:50 <byorgey> Axman6: yep
17:49:01 <byorgey> Axman6: though you need to turn on AllowAmbiguousTypes to allow  bar :: Text
17:51:14 <monochrom> Would this be better? bar :: forall a. Foo a => Text
17:52:28 <monochrom> err nevermind
18:49:55 <Zemyla> This is one of the simplest and most hilarious bugs I've seen https://ghc.haskell.org/trac/ghc/ticket/7697
18:50:45 <suzu> lol
18:50:48 <suzu> thats pretty funny
18:50:58 <suzu> there's also a bug from way back where GHC would just straight up delete your code
19:42:56 <lyndon> Is there a way to say that you expect the property to not hold in quickcheck?
19:43:08 <lyndon> (That there should be a counterexample?)
20:25:17 <nshepperd1> Could you directly calculate the counterexample?
20:43:19 <shayan_> monochrom: where can i go to learn more about the haskell meetups in toronto?
20:53:00 <Cale> monochrom: Also keep bothering me to come to them, eventually I will work something out :D
20:53:03 <Cale> lol
20:55:06 <Cale> oh, apparently it was last Wednesday
20:55:19 <Cale> I was pretty sick that day
20:55:23 <Cale> https://bentomiso.com/events/haskell-meetup-2017-jan
20:56:02 <Cale> bentomiso is the worst name for anything that isn't a Japanese lunch restaurant
21:02:27 <pikajude> how many things aren't that though
21:06:43 <hololeap> what is a good way to process an arbitray number of lines coming from STDIN and perform some sort of IO after each line is recieved?
21:06:51 <hololeap> *arbitrary
21:07:15 <shayan_> Cale: You live in Toronto, too?!!!!! 
21:07:26 <glguy> Oh my, maybe they're the same person!
21:07:39 <athan> Is a "closed" continuation one which you cannot simply "come back from"?
21:07:47 <shayan_> I was just looking at Bent Miso — thought it was some kind of restaurant haha. Really looks like an interesting environment
21:08:00 <athan> for instance, if your continuation has a `\continue -> ...` parameter, then you can "come back" into the main control flow
21:08:08 <shayan_> Would love to go there and code instead of staying in the house
21:08:21 <athan> if it doesn't have this, what would it be called? A one-off computation? A closed continuation? :s
21:09:57 <athan> or is it just simply _not_ a continuation?
21:11:33 <shayan_> cale: from their website: “We've changed our name! Bento Miso is now Gamma Space. Pardon the cyberdust while we make the transistion.”
21:13:46 <codygman> Anyone know if there is a C++ equivalent for Haskell's print? Can i just cout something like an stl map?
21:16:28 <pikajude> no
21:34:15 <jle`> hololeap: overkill method might be pipes, but a nice method would be to write an HOF using explicit recursion and then use it
21:34:32 <jle`> sort of a version of interact :: (String -> String) -> IO ()
21:35:14 <jle`> maybe interactIO :: (String -> IO String) -> IO ()
21:35:29 <athan> codygman: Like a trace?
21:40:59 <jle`> codygman: you're asking more about a c++ version of 'Show', right?
22:00:31 <hololeap> what is "an HOF"?
22:02:49 <systemfault> Higher-Order Function. That term usually refers to function taking functions as argument or returning one.
22:10:59 <athan> Couldn't `(Monad m, Monoid w) => Monoid (m w)`?
22:12:08 <athan> where `x <> y = do x' <- x; y' <- y; pure (x' <> y')`
22:12:17 <athan> and `mempty = pure mempty`
22:14:07 <codygman> I have a `Producer (HM.HashMap Text.Text v) m ()`, how can I get my HashMap value out? If it were a list I'd just use P.toList, but I don't know what to do for hashmap
22:14:42 <glguy> athan: Your instance satisfies the laws, but it overlaps with tons of other instances, and requires extensions to define
22:15:04 <athan> yow, right on. It checked out for me. Where would the ambiguity lie glguy?
22:15:30 <glguy> It overlaps with all the instances on types of the form: m w
22:16:28 <glguy> so more than half the instances seen here http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html#v:mconcat
22:16:31 <athan> ahhh shoot, so most instances are for each monad?
22:16:36 <athan> D:
22:16:55 <dmj`> codygman: you’d need to connect it to a consumer, or another pipe. Or use ‘for’, to create an effect, then runEffect
22:16:57 <glguy> Instances should be of the form: instance TypeClass (TypeConstructor a b c...)
22:17:02 <glguy> with zero or more type variables a b c...
22:17:44 <athan> ahh okay, that way there's no chance for overlap, because each implmenetation is distinguished?
22:18:56 <dmj`> codygman: main = runEffect $ for hashMapProducer $ \hashMap -> lift (print hashMap)
22:19:26 <glguy> Yes, if you stick to standard Haskell there's no overlap. You can get conflicts if you try to define the same instance twice, of course
22:20:22 <codygman> I'm trying to read a file line by line with pipes-text and then fold those values into a hashmap, I think I might be taking the wrong approach though: http://lpaste.net/351534
22:20:46 <codygman> dmj`: I think what you are saying would work in some cases, but like I posted above I might be more wrong than I thought
22:21:12 <athan> ahh, right. Thank you glguy
22:25:19 <athan> glguy: Doesn't my instance suit the same behavior as Maybe, [], and IO listed there?
22:25:47 <athan> wait, I am very incorrect
22:25:54 <athan> for [] it breaks the heck out of it
22:25:56 <athan> sorry!
22:36:30 <athan> Do you think there could be a newtype for it?
22:36:49 <athan> Monoidad :v
22:36:55 <athan> Monadoid?
22:37:14 <athan> I'm taking it :x
22:38:16 <dmj`> codygman: you could put the HashMap inside an IORef, and modify it in the effect
22:40:43 <codygman> dmj`: Hm, I ended up just not using pipes and using a handle/Text.getLine for now. I suppose I could use an IORef but I'd much rather get the fold working.
22:55:58 <Nick-chx> does anyone know of which os is this web browser? https://s23.postimg.org/9l7lro1az/www.jpg
22:58:20 <chaos_> wow
22:59:06 <unknownln> Looks like the browser itself is chrome... Idk how they got it to look like that though
23:02:36 <Nick-hxc> hello
23:02:42 <Nick-hxc> 0 does anyone know of which os is this web browser ? https://s23.postimg.org/9l7lro1az/www.jpg 0
23:09:10 <codygman> Does anyone know what hashing algorithm Hashable uses?
23:12:03 <nshepperd> athan: it only needs applicative, actually
23:12:11 <nshepperd> (<>) = liftA2 (<>)
23:12:38 <nshepperd> and yeah, there should be a newtype for it!
23:14:50 <nshepperd> you could do the same thing with Num, too
23:14:56 <nshepperd> (+) = liftA2 (+) etc
23:23:33 <jmorris> I'm trying to write this single byte xor function http://lpaste.net/351535
23:23:50 <jmorris> the undefined in the lambda function should xor 2 word8's
23:24:04 <jmorris> but I couldn't find a function that does that, and I don't know how to write it
23:24:27 <jmorris> the function is supposed to xor each letter of a string by a single char
23:24:40 <athan> Isn't there a Bits class or something similar?
23:24:40 <jle`> jmorris: i think you might just want 'xor'
23:24:43 <jle`> from base
23:24:49 <cocreature> codygman: I think it uses fnv-1 but you it obviously depends on the instance
23:24:55 <jle`> jmorris: xor does bitwise xor
23:25:07 <jmorris> jle`: ok let me try
23:25:10 <cocreature> codygman: also it depends on the version. at one point it used siphash but I think that changed years ago
23:25:24 <jle`> jmorris: xor :: Word8 -> Word8 -> Word8
23:25:32 <jle`> > xor (7 :: Word8) (3 :: Word8)
23:25:35 <lambdabot>  4
23:25:51 <lpaste> shayan_ pasted “Caesar” at http://lpaste.net/351536
23:26:13 <jle`> jmorris: singleByteXor = B.map xor
23:26:25 <jle`> oh, um
23:26:32 <shayan_> Can anyone tell me why I am getting “<interactive>:41:1: error:    Variable not in scope: freqs :: [Char] -> t” when I try to type freqs “abbcccddddeeeee”
23:26:32 <jle`> singleByteXor a = B.map (xor a)
23:26:47 <jmorris> jle': it worked, i didn't know there was a function in base
23:26:48 <jmorris> thanks
23:26:53 <jle`> jmorris: no problem!
23:27:01 <jle`> shayan_: did you import your module?
23:27:05 <jle`> er, your file
23:27:17 <jle`> you need to import source files into ghci before you can use what they define
23:27:21 <codygman> cocreature: Yep, it changed from siphash to fnv-1
23:27:45 <shayan_> jle`: if by that you mean :l filename.hs then yes, I have already done that
23:28:02 <codygman> I did some research and it seems that murmur is fastest these days with least collissions and best uniquness properties, fnv-1a being in second, then the one hashable uses fnv-1 is in third. Though my research was pretty light and quick.
23:28:04 <jle`> hm, does it load without incident?
23:28:19 <cocreature> codygman: the changelog makes it seem like siphash crashed for unknown reason so they just switched away from it :/
23:29:14 <jle`> @letlpaste 351536
23:29:16 <lambdabot>  .L.hs:217:16: error:
23:29:16 <lambdabot>      Ambiguous occurrence ‘shift’
23:29:16 <lambdabot>      It could refer to either ‘Data.Bits.shift’,
23:29:33 <shayan_> jle`: Actually, every was working fine until I added lines 24 and 25 (http://lpaste.net/351536)
23:29:53 <jle`> does it give you any errors when you load it?
23:30:22 <shayan_> jle`: Oh yes — “    Variable not in scope: count :: Char -> String -> Int"
23:30:34 <jle`> that might be it
23:30:36 <shayan_> caesar.hs:25:22: error:
23:30:37 <shayan_>     Variable not in scope: count :: Char -> String -> Int
23:30:38 <shayan_> caesar.hs:26:27: error:
23:30:39 <shayan_>     Variable not in scope: lowers :: String -> t
23:30:41 <jle`> if there's an error like that, it won't load anything in the file at all
23:31:14 <shayan_> I’m not sure why — I am only following the code written in a textbook :S
23:31:28 <jle`> the textbook might define lowers and count somewhere else?
23:31:37 <jle`> those aren't in scope by default in haskell
23:31:43 <jle`> maybe you need to import an extra module in your file?
23:32:39 <shayan_> jle`: not sure, but will try to look around
23:33:32 <glguy> shayan_: looks like the functions are defined in the very next line
23:33:57 <glguy> https://github.com/ssato/haskell/blob/master/gmh.book/5/caesar.hs#L45
23:34:18 <shayan_> oooo!!!!
23:36:28 <shayan_> thanks guys. it does mention it in the textbook, but i was not paying attention
23:40:47 <shayan_> i’m still getting <interactive>:47:1: error:   Variable not in scope: freqs :: [Char] -> t when i reload the file ?
23:45:20 <jle`> shayan_: are there any errors that come up when you load the file?
23:45:34 <jle`> remember, if there are any errors, nothing loads
23:46:43 <shayan_> jle`: yes — actually i’m going to replace the code with what glguy pasted, i’ll see if the problem persists 
23:49:04 <jle`> if you do get an error again, you should post the error that happens when you load the file
23:49:11 <jle`> not the error that happens when you try to use freq, heh
23:49:30 <jle`> it's nice but pretty much useless for figuring out what went wrong :)
23:53:03 <shayan_> jle`: okay, noted for next time. it’s working fine now :)
23:53:53 <shayan_> monochrom: I just got your message — will try to join. thanks so much
