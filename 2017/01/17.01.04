00:47:33 <giannisl9> Having red Learn You a Haskell for Great Good first few pages I have to say "That is how I like to learn about programming!"
00:49:03 <Insanity_> The book has some good humour in it 
00:49:09 <Insanity_> Going through the book myself atm
00:49:42 <giannisl9> Yes, I really like his writing style !
00:49:58 <giannisl9> Also, pointing to freenode :)
00:51:20 <Insanity_> Glad that you are enjoying his writing style as well :-)
00:51:47 <Insanity_> Do you have a background in other programming languages?
01:54:45 <choki> How do I do a case-insensitive compare? I've so far: `$title =~ \(?i)(firefox|google)\` but it doesnt seem to match both
01:57:53 <amx> what is this? perl?
01:58:01 <choki> i guess it is haskell
01:58:20 <choki> it's a config file for arbtt e.g https://github.com/lervag/dotfiles/blob/master/arbtt/categorize.cfg
01:58:31 <choki> arbtt is written in haskell, i installed with cabal install
02:00:50 <amx> arbtt appears to use this: https://hackage.haskell.org/package/pcre-light
02:02:19 <choki> oh
02:07:45 <amx> but (?i) should work, maybe you have to put (?i) with the two alternatives
02:08:29 <choki> /(?i)firefox|google/ works, but not global. it only matches the first one :/
02:08:43 <choki> i tried to put a /gi at the end but this syntax doesnt seem to be allowed
02:09:10 <geekosaur> no, global modifier won't work in (?...)
02:10:02 <choki> why
02:10:29 <geekosaur> because it doesn't modify the regex, it modifies how the rest of the program interfaces with the regex
02:11:18 <geekosaur> and that's also why you can't do that here, there does not appear to be a way to tell arbtt to expect or deal with multiple values --- and I'm not sure that idea is even meaningful in the context of arbtt
02:11:27 <geekosaur> what are you trying to accomplish?
02:12:00 <geekosaur> oh, I think you didn't want global, it doesn't work the way you think
02:12:36 <choki> geekosaur: im trying to configure arbtt to match `google` or `firefox` in the window title (case insensitive) in order to see how much time I've spent on browsing the web
02:13:02 <geekosaur> /(?i)(firefox|google)/ doesn't do this?
02:13:19 <choki> i tried this online generator and it seems to work but not in my config file https://regex101.com/r/PUTA9q/1
02:13:37 <choki> geekosaur: it does but only matches the first one if i put this is the online tester
02:13:41 <choki> sorry im regex newb :D
02:13:45 <geekosaur> why do you need it to match both
02:13:55 <geekosaur> your browser is not going to claim to be both google and firefox
02:14:31 <choki> oh
02:14:35 <choki> you're right!
02:14:40 <choki> it only needs to match one
02:15:52 <geekosaur> and, arbtt doesn't care how many times something matches. it just cares that it found a match
02:16:04 <geekosaur> which is why it doesn't do /g
02:16:17 <choki> geekosaur: oh thanks, you also use arbtt? 
02:16:29 <geekosaur> no, I'm just familiar with what it's doing
02:20:33 <geekosaur> btw I would actually make it match / (Firefox|Chrome|Chromium)$/ so you don't have it, say, count a browser launched from a shell in a terminal that sticks the currently running command in its titlebar. or an editor window on some path that includes "firefox" or "google"
02:21:25 <geekosaur> (that's still not a perfect regex but I'm disinclined to dig up a more precise one right now and it's likely good enough, at least if you're not me :)
02:21:46 * geekosaur is rather more likely to be doing weird stuff that might accidentally match
02:26:16 <choki> geekosaur: the dollar means to match it on the end?
02:26:23 <geekosaur> yes
02:26:25 <choki> oh
02:26:28 <choki> thanks :)
02:27:01 <geekosaur> because the browser windows will have " - (Mozilla Firefox|Google Chrome|whatever the full identifier for Chromium is)" at the end of the title
02:27:26 <choki> you're right!
02:27:45 <choki> but the cool thing with arbtt is, i can change this always later as it saves the whole window title
02:30:21 <choki> geekosaur: you write haskell on a daily base? what do you do with exactly?
02:30:34 <geekosaur> mostly? xmonad
02:30:48 <choki> oh the legendary tiling wm?
02:30:59 * geekosaur trying to coach someone through configuring xmonad for sandboxed config in #xmonad currently
02:31:08 <choki> oh sorry
02:31:17 <choki> i3 user here :D
02:31:27 <Zowlyfon> I use xmonad on my laptop, its great
02:33:31 <Sanchayan> Hello. Am new to Haskell and had a question on folds. foldr ((++) . show) "" [1..5] works but foldl does not. Am trying to follow the folds wikipedia page as well as the Haskell book.
02:35:22 <shiona> Sanchayan: foldl flips the order of parameters to the accumulating function compared to foldr.
02:35:34 * geekosaur shrugs. tiling window managers are tiny niches and everyone has their own preferences; use what works for you
02:36:08 <shiona> so your ((++) . show) applied to "" and 1 from the list ends up like '1 ++ show ""'
02:36:42 <shiona> > foldr (flip ((++).show)) "" [1..5]
02:36:45 <lambdabot>  error:
02:36:45 <lambdabot>      • No instance for (Enum [Char])
02:36:45 <lambdabot>          arising from the arithmetic sequence ‘1 .. 5’
02:36:58 <shiona> hmm, nope
02:37:59 <sdx23> > foldl (flip ((++).show)) "" [1..5] -- and the ordering
02:38:02 <lambdabot>  "54321"
02:38:18 <shiona> ah, should've probably changed the function, right
02:40:16 <Sanchayan> shiona: With foldr 's associativity foldr would have had 5 ++ show "" on right end and foldl should have had "" ++ show 1 on left end, shouldn't the foldr version not work?
02:40:49 <Sanchayan> sdx23: Yes using flip works too
02:41:17 <shiona> Sanchayan: true
02:42:45 <Sanchayan> shiona: Sorry, I meant shouldn't the foldl version not work?
02:42:58 <Fuco> geekosaur: heh, the way I use xmonad is just one fulscreen window per workspace, I almost never tile... my `awesome` using friend considers me mostly a heretic but hey... I never found any use in tiling :D mostly I'm happy that the stupid window decorations are gone :D
02:45:11 <Sanchayan> shiona: Since foldr has 5 ++ show "" which should not work and foldl which has "" ++ show 1 should?
02:47:04 <Fuco> the first argument to ++.show has to be the number yes, to create two lists to then concatenate
02:47:55 <Fuco> \x y -> (++ . show) x y = \x y -> (++ (show x)) y = \x y -> ++ (show x) y
02:48:58 <slack1256> I feel better when refactoring than writing anew code on haskell
02:49:19 <slack1256> which is exactly the opposite that happens when writing shell scripts
02:49:37 <Fuco> shell scripts are write-only languages :P
02:50:57 <sdx23> slack1256: so we need a sheel2hs converter, and you can feel good all the time ;)
02:51:19 <Fuco> Sanchayan: if not sure, draw the picture of the list with the cons constructor and then replace it with your foldr function, that is exactly the way it is going to evaluate
02:52:04 <Fuco> (and replace [] with your initial value, which is "")
02:52:07 <geekosaur> @hackage turtle
02:52:07 <lambdabot> http://hackage.haskell.org/package/turtle
02:52:59 <Sanchayan> Fuco: Yes ++.show requires first arg to be number. I am trying to use the picture of list with cons constructor to understand. 
02:53:36 <Fuco> Sanchayan: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations wikipedia has good pictures :)
02:57:31 <tsdh> I'm quite new to Haskell.  Can someone enlighten if and how I get this function compile?  http://lpaste.net/350859
02:58:20 <Sanchayan> Fuco: Yes that one. Hmm I guess I understood my confusion. The cons constructor is replaced with a prefix function and considering that ((++) . show) 5 [] is correct but not ((++) . show) [] 1, so foldl does not work since it would be latter.
02:58:27 <tsdh> As far as I understand, it's complaining that it can't fix the types at compile-time which is true.  Am I not allowed to do something like that?
02:58:49 <opqdonut> tsdh: the problem is that the a in (maxBound :: a) is not the same as the a in your type signature
02:59:03 <opqdonut> tsdh: you need a language extension called ScopedTypeVariables for it to be the same
02:59:23 <tsdh> opqdonut: Ah, obviously that has been my intension.  Thx!
02:59:50 <opqdonut> tsdh: without the extension, you can use (asTypeOf maxBound x)
02:59:54 <opqdonut> :t asTypeOf
02:59:56 <lambdabot> a -> a -> a
03:00:15 <opqdonut> asTypeOf is just const but with a more constrained type
03:00:32 <opqdonut> > asTypeOf maxBound False
03:00:38 <lambdabot>  True
03:00:53 <tsdh> opqdonut: Great, thanks!
03:02:26 <Fuco> Sanchayan: exactly
03:02:35 <geekosaur> that reads a bit more sensibly as infix, btw: maxBound `asTypeOf` False
03:03:45 <Xnuk> Can I know whether the file is hidden or not, in Haskell?
03:03:58 <liste> Xnuk: on Windows?
03:04:25 <tsdh> geekosaur: Yes, indeed.  I first questioned myself how that name's appropriate, then looked up the docs telling that it's usually used infix.
03:04:28 <Sanchayan> Fuco: Thanks.
03:04:35 <Xnuk> Linux and hopefully Windows
03:04:35 <Sanchayan> shiona: Thanks
03:05:37 <Fuco> Sanchayan: so when I'm not sure I always remember that cons is value:[] and therefore foldr, replacing the cons, must have the arguments in value accumulator order :)
03:05:52 <liste> Xnuk: on Linux, a file is hidden if its name starts with a dot
03:06:10 <liste> Xnuk: on Windows, it's a specific flag stored with the metadata of the file
03:06:29 <Fuco> ah the dot prefix... best bug in history :D
03:07:05 <Xnuk> liste: Is there any function that covers both?
03:07:45 <Xnuk> any library
03:07:57 <liste> Xnuk: none that I know of
03:08:15 <Xnuk> (._.
03:08:20 <muzzle> hi, is there any way to work around the build trouble with large parts of the haskell ecosystem on OSX Sierra?
03:08:36 <geekosaur> muzzle, wait for ghc 8.0.2 to be released
03:08:42 <geekosaur> otherwise, pretty much no
03:08:47 <muzzle> geekosaur i'm already using the release candidate
03:08:52 <muzzle> but c2hs also doesn't work
03:09:04 <muzzle> see https://github.com/haskell/c2hs/issues/176
03:09:24 <geekosaur> I suspect you're out of luck, then
03:09:27 <muzzle> and since it's my work computer I can't downgrade without trouble
03:10:01 <slack1256> muzzle: nix on macos ?
03:10:03 <jmorris> why isn't, foldr const 2 [] = [] `const` 2 ?
03:10:19 <geekosaur> Xnuk, it' actually worse than that because the Unix one is just convention and not all programs obey that convention. and the Windows one is, afaik, only visible via a function in the win32 library, and you won't get that library to install even as a stub on linux
03:10:34 <slack1256> > (foldr const 2 [] ) 3 
03:10:37 <lambdabot>  error:
03:10:37 <lambdabot>      • Could not deduce (Num t0)
03:10:37 <lambdabot>        from the context: (Num (t -> t1), Num t)
03:11:25 <geekosaur> > foldr f 2 [] :: Expr
03:11:27 <lambdabot>  2
03:11:30 <geekosaur> heh
03:11:34 <slack1256> Noice
03:11:36 <geekosaur> ah well, outwitted
03:11:51 <geekosaur> > foldr f 2 [a,b]
03:11:53 <lambdabot>  error:
03:11:53 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M403218724126...
03:11:53 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
03:12:00 <geekosaur> > foldr f 2 [a,b] :: Expr
03:12:04 <lambdabot>  f a (f b 2)
03:12:09 <jmorris> as i understand it foldr f z [a,b,c] =  a `f` (b `f` (c `f` z))
03:12:12 <Sanchayan> Fuco: Ok thanks. I will make a note of that.
03:12:30 <jmorris> so wouldnt  foldr const 2 [] = ([] `const 2) ?
03:12:46 <jmorris> because z goes at the end
03:12:58 <geekosaur> z goes at the end but [] is empty so it goes nowhere
03:13:06 <jmorris> oh
03:13:44 <jmorris> :t foldr
03:13:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:14:05 <geekosaur> so you end up with just 2, because there's nothing to apply const to in the list
03:14:13 <slack1256> if [] went to the end, it would mean the @a parameter would always be [t]
03:14:31 <slack1256> ie, not a variable
03:14:38 <jmorris> oh ok
03:14:46 <geekosaur> it doesn't even look at the function you gave it in that case, all it does is return the initial value
03:15:07 <jmorris> so foldr const 2 [] = const 2 []
03:15:16 <geekosaur> foldr const 2 [] is 2
03:15:17 <jmorris> because the list is empty
03:15:35 <jmorris> yeah, and const 2 [] = 2
03:15:36 <geekosaur> the list is a list of things to iterate over, chaining with const
03:15:45 <geekosaur> since the list is empty, it has nothing to chain const with
03:15:49 <geekosaur> it doesn't even look at const
03:15:58 <geekosaur> it just returns the 2 because empty list = nothing to do
03:16:06 <jmorris> oh ok
03:16:24 <geekosaur> the expression you are trying to build would be: foldr const 2 [[]]
03:16:29 <geekosaur> a list containing an empty list
03:16:50 <jmorris> right
03:19:36 <slack1256> > foldr (+) 2 [] 
03:19:40 <lambdabot>  2
03:19:43 <jmorris> foldl starts evaluating from the left while foldr starts evaluation from the right?
03:20:01 <jmorris> foldl -> (1 + (2 + 3) <- foldr
03:20:02 <geekosaur> they both start from the left; think about it :)
03:20:08 <geekosaur> they just associate differently
03:20:20 <jmorris> what's the difference?
03:20:52 <slack1256> foldr const 0 [1,2,3] = const 1 (const 2 (const 3 0) = 1
03:21:19 <geekosaur> has to do with laziness, and the strictness of the function you give it.
03:21:38 <slack1256> foldl const 0 [1,2,3] = const (const (const 0 1) 2) 3 = const (const 0 1) = const 0 1 = 0 
03:22:24 <geekosaur> well, the "both start from the left" part is because it can't get to the end of the list without working to it from the left, there is no magical way to avoid that
03:23:08 <jmorris> why would you prefer one over the other?
03:23:36 <jmorris> geekosaur: does const (const (const 0 1) 2) 3 = ((0 `const` 1) `const` 2) `const` 3
03:23:56 <geekosaur> one stores partial work on the heap, the other stores it on the pattern match stack. sometimes this matters. otherwise... well, it's rare to have a work function such that foldl actually makes sense
03:24:20 <geekosaur> either you want the strict version (foldl') or you want foldr, depending on what you are doing
03:25:00 <geekosaur> and, yes that looks right
03:25:00 <jmorris> im pretty sure foldLeft from the nicta course is foldl'
03:27:17 <dibblego> jmorris: https://vimeo.com/64673035
04:19:05 <ocramz> I have a container structure for numerical data, and I need two distinct instances for the real- and complex-valued case. How can I avoid the overlapping instances? I mean, the instance of `Struct (Complex a)` is a strict subset of that of a generic `Struct a`
04:19:21 <ocramz> without creating a newtype, that is.
04:21:40 <opqdonut> ocramz: that's a common problem with type classes. you need either a) a newtype b) specific instances a la Struct Float c) the OverlappingInstances extension
04:22:32 <ocramz> opqdonut: good to know, thanks :) This also means I've already exhausted all sensible options 
04:22:48 <opqdonut> I think c is the most popular option
04:23:27 <opqdonut> personally I might go with b
04:23:59 <opqdonut> is the generic instance "Num a => Struct a"? will it truly work for all Nums?
04:24:01 <ocramz> specific instances are also an option, I could do it in bulk with some CPP
04:25:23 <lyxia> you could add a phantom type to indicate which instance to choose
04:25:33 <ocramz> opqdonut : yeah, the class method is an inner product, so in the real case all it does is `sum $ zipWith (*) a b`
04:26:31 <ocramz> lyxia: thanks but I'm recycling the typeclasses from `vector-space` 
04:26:57 <ocramz> which don't have a slot for extra parameters
04:27:18 <lyxia> hm. how about putting this tag on the container then
04:27:39 <lyxia> Struct (isComplex :: Bool) a
04:28:00 <ocramz> this would require DataKinds ?
04:28:31 <lyxia> you can do without.  data T ; data F     Struct isComplex a
04:29:58 <ocramz> lyxia: right, I'll look into this and report back. Thanks :)
04:30:35 <lyxia> yw
04:30:35 <Urchin> would it be possible to run an obfuscated Haskell code competition?
04:31:36 <ocramz> of course it would. But then we'd have to clean the walls from the pieces of gray matter
04:34:13 <niklasb> Urchin: in case you like stuff like this, maybe you'll enjoy http://lpaste.net/24414037219475456
04:34:17 <niklasb> a challenge from TUM CTF 2016
04:36:10 <liste> what language is that?
04:36:26 <niklasb> liste: foolang
04:40:35 <niklasb> jk liste, I think you should be familiar with the language
04:57:08 <absence> http://lpaste.net/4042914503124320256 <- can this structure be generalised? it's kinda like a monad in that the parameters for the state computations aren't dictated by the structure and can be bound, and kinda applicative in that there's one state computation for each record field, but the pieces don't really fit
04:57:32 <jmnoz> is there any benefit to using warp-tls if I'm using nginx in front of warp?
04:59:50 <opqdonut> absence: what's o?
05:01:03 <opqdonut> absence: I think it's an applicative, it's isomorphic to length 3 ziplists AFAICS
05:01:50 <opqdonut> absence: ... hmm or perhaps not quite
05:03:47 <lyxia> absence: fa, fb, fc, are meant to be f?
05:03:55 <niklasb> jmnoz: potentially that it does not rely on a TLS implementation written in a memory-unsafe language. of course on the other hand it is likely less audited than openssl is
05:04:45 <opqdonut> absence: or is that just a monad product of three state monads ala https://hackage.haskell.org/package/monad-products-4.0.1/docs/src/Control-Monad-Product.html ?
05:05:37 <jmnoz> niklasb: good point
05:05:55 <jmnoz> maybe h2 push is an argument too... ?
05:05:59 <maerwald> niklasb: lol, it's not that easy... we know next to nothing about the suitability of crypto implementations in haskell, which has far more problems than "memory safety"
05:06:14 <maerwald> e.g. examination of execution path, branching etc
05:06:15 <niklasb> maerwald: I would agree with you
05:06:22 <maerwald> which is all non-obvious in haskell
05:06:45 <lyxia> absence: it looks like a kind of heterogeneous traversable to me
05:06:58 <maerwald> see for example https://cryptocoding.net/index.php/Coding_rules
05:07:02 <niklasb> maerwald: still it's kind of a "benefit", not saying it outweighs any of its disadvantages
05:07:52 <maerwald> I think the best we can hope for is https://github.com/mitls/mitls-fstar but that's far from being anywhere near ready
05:08:32 <maerwald> there are also attempts to generate verified C code out of it, even wrt timing
05:08:52 <maerwald> and they're trying to implement IFC at some point
05:08:54 <maerwald> afaiu
05:09:33 <maerwald> where all haskell implementations do is say "I'm memory safe" :o
05:09:44 <maerwald> which is even debatable
05:12:14 <maerwald> also see for a short discussion on haskell-cafe https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118059.html
05:13:04 <maerwald> this response was interesting https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118213.html
05:13:20 <maerwald> the rest not
05:19:12 * kuribas is surprised how well ghc is documented.
05:22:46 <kuribas> is it possible to build a html/pdf from the ghc source?
05:27:21 <schoolboy> hi, s anyone who can help me?
05:28:28 <pavonia> Depends on your problem
05:28:38 <kuribas> schoolboy: if it's money, then no.
05:28:49 <kuribas> schoolboy: haskell, maybe.
05:29:59 * janosp
05:30:18 <schoolboy> a.exe program what language is possible to write?
05:31:24 <janosp> schoolboy: .exe are executables on windows. So basically with every language which compiles on windows
05:33:36 <schoolboy> on c# how can i save it in .exe file?
05:34:35 <liste> schoolboy: use visual studio community https://www.visualstudio.com/vs/community/ and hit 'build'
05:34:43 <kuribas> schoolboy: ask in #csharp?
05:35:10 <kuribas> schoolboy: this channel is about haskell.
05:35:21 <liste> schoolboy: and the .exe file appears. for further questions ask #csharp
05:35:41 <liste> or ##programming for general (non-C#) questions, ##programming
05:36:38 <kuribas> It looks like the ghc source is written in literate haskell.  Is it possible to generate html or pdf?
05:37:30 <cmdv> Hi, I'm thinking about starting a remote free meetup for beginners trying to learn haskell. The problem I have right now is that I'm learning my self so I wouldn't be the best candidate to do small talks. I was thinking something like a talk on recursion, types, monoids..... Then once the small talk / presentation is complete people could ask questions to
05:37:30 <cmdv> better understand a subject. I would also records these videos, edit them and look after the whole show if people are short for time :) If anyone would be interested in helping out and bring new devs to the community give me a shout :) Thank you
05:37:39 <choki> O_o
05:37:56 <kuribas> cmdv: where?
05:38:10 <cmdv> also the reason for being remote is there is nowhere near me to go
05:38:21 <cmdv> kuribas: remote
05:38:27 <gingitsune> I would be down for that
05:38:50 <cmdv> we do it in Purescript https://github.com/purescript/documentation/blob/master/ecosystem/PureScript-Meetups.md
05:38:51 <kuribas> cmdv: like videochat?
05:39:23 <cmdv> cool :gingitsune :)
05:39:36 <cmdv> yeah kuribas:
05:40:28 <kuribas> ok cool
05:40:29 <cmdv> just find that I'm drowning in books and a lot of people don't have access to local Hasklee/FP meetups
05:41:06 <choki> problem is, haskell doesnt usually offer that much jobs
05:41:16 <choki> so there are not that many people like php devs :D
05:42:10 <cmdv> choki: haha very true but it is so much fun do if it's not available the internet is very big place sure it could attract lots of new learners :)
05:44:55 <cmdv> I'll come back once I have something set up but if people are interested in sharing their knowledge for half an hour then feel free to DM me :D
05:47:47 <wonderer92> how would I, at runtime, assign LT and GT tags to values in a list, so that I can then call `sort` to sort the values in the list?
05:48:10 <AndreasK> wonderer92: use sortBy
05:48:41 <wonderer92> AndreasK: thanks!
05:52:51 <absence> opqdonut: oh sorry, o = z
05:53:26 <absence> lyxia: they are different functions that return State actions
05:55:33 <absence> opqdonut: not sure about the monad product. does it allow passing the result of one state computation as parameter to another?
05:56:02 <absence> lyxia: does traversable allow passing parameters between the elements though?
06:22:04 <mekeor> (how) can i watch a directory D so that my program gets notified (by the file-/operating-system?) whenever i move a file/folder into/out_of/within this directory?
06:22:46 <Tuplanolla> See if Hackage has "inotify" packages, mekeor.
06:23:13 <mekeor> nice ^.^
06:25:05 <sm> and fsnotify, more cross-platorm
06:25:18 <sm> platForm
06:26:43 <mekeor> there's also "delta", "hinotify" and "linux-inotify", and "system-inotify", and yes, "fsnotify" :O
06:32:28 <maerwald> hinotify worked best for me
06:32:42 <maerwald> except that it uses FilePath still (which is fixed in master though)
06:36:46 <maerwald> sm: I don't think that can be done properly cross-platform, also see the note from fsnotify "NOTE: This library does not currently report changes made to directories, only files within watched directories"
06:37:15 <maerwald> proper "cross-platform" somtimes also means you cannot abstract over it, but must have two codepaths
06:37:16 <mekeor> "delta" sounds nice to me as it has a FRP interface using Sodium...
06:38:54 <Tuplanolla> I've now watched GHC 8 compile `haskell-src-exts` for two hours. How long will it take?
06:39:12 <ongy> Tuplanolla: what do you compile it on? It takes a while but 2h sounds way to long
06:39:49 <Tuplanolla> This machine is from 2004.
06:41:06 <Tuplanolla> I'll wait a bit longer.
06:41:34 <Akii> why are you building it on such an old computer?
06:42:14 <Tuplanolla> It's the only one I have besides this one and I don't want to interrupt my work here.
06:46:13 <sm> maerwald: agreed there are plenty of quirks, but it's the most cross-platform I found
06:47:23 <sm> Tuplanolla: using up all ram ?
06:47:32 <rntz> can someone explain why do { let x = 2; [x] } produces a parse error when the corresponding newline-and-indent-syntax version works fine? http://sprunge.us/FQiL?hs 
06:47:41 <rntz> am I misunderstanding how to use the curly-brace haskell syntax?
06:47:52 <Tuplanolla> Most likely, sm. There's only 1 GB there.
06:48:22 <sm> maybe the ghc +RTS -M600m trick will help, at least keep it from swapping
06:50:32 <Tuplanolla> Too late. It just completed.
06:50:55 <ongy> how long did it take?
06:51:28 <Tuplanolla> I was installing pointfree and pointful with all the basic things already in place, which took a bit under two hours.
07:01:48 <pavonia> rntz: "let" opens a new scope, so it's trying to parse [x] as a new let-binding
07:02:14 <pavonia> > do { let { x = 2}; [x] }
07:02:16 <lambdabot>  [2]
07:21:12 <absence> http://lpaste.net/4042914503124320256 <- can this structure be generalised? it's kinda like a monad in that the parameters for the state computations aren't dictated by the structure and can be bound, and kinda applicative in that there's one state computation for each record field, but the pieces don't really fit
07:21:49 * shapr starts a gofundme to send Tuplanolla a better desktop computer
07:24:49 <shapr> ptek: How are you deploying your Haskell program?
07:26:00 <shapr> ptek: maybe using stack and docker?
07:26:44 <ptek> shapr, we use cabal to build the binaries. Trying to get stack to build it, but did not get to that yet
07:27:22 <ptek> shapr, to deploy them, we want to use containers. I am trying to build the deployment around rkt actually. It just looks much more stable
07:27:26 <ptek> and consistent
07:27:32 <ptek> although not so feature rich
07:28:12 <shapr> I haven't tried rkt, only docker
07:28:45 <ptek> shapr, I was trying to look into nix-ops, but I just don't have the time to understand the nix expressions language
07:29:14 <shapr> I deploy my Haskell code by running "stack install" on my VPS, and I don't have any users other than myself.
07:29:57 <shapr> I've heard good things about nix, but I haven't tried it yet.
07:30:11 <maerwald> containers is a reasonable choice for deployment
07:30:12 <ptek> shapr, that sounds good. Does stack install create the docker images?
07:31:08 <shapr> ptek: I haven't combined stack and docker yet. I do know that stack has docker commands, but I haven't used them.
07:31:31 <shapr> But I can find the docs: https://docs.haskellstack.org/en/stable/docker_integration/
07:32:33 <ptek> shapr: yes, I've looked into that too. As I understand its more for building the code within docker images
07:33:00 <shapr> huh, I also thought it would have something to do with deployment
07:37:06 <shapr> ptek: have you tried other ways of deploying your Haskell app?
07:37:30 <shapr> I'd guess the various web app frameworks would have documents on deploying webapps.
07:37:37 <shapr> servent, snap, etc
07:37:40 <shapr> servant*
07:41:52 <ptek> shapr: we are running the webapp since long time already. And it is kind-of ok - haskell-built applications are very stable. One has to babysit the app sometimes though when the server misbehaves.
07:43:33 <ptek> What I want is to have a declarative deployment system allowing me to have all the servers the app is running on in a consistent state.
07:43:42 <ptek> thus the idea about the containers
07:43:46 <shapr> That makes sense
07:44:00 <shapr> ptek: is your webapp secret/closed, or could I get a link to it?
07:44:19 <shapr> ptek: I'd also like to know what happens, and how the server misbehaves and needs babysitting.
07:44:31 <ptek> its a closed app for my company which is a datacenter
07:45:56 <maerwald> ptek: only slightly related, but do you know https://hackage.haskell.org/package/propellor
07:45:58 <ptek> the servers are VMs with debian. And over the last several years, they all got different configs since we were managing them by hand
07:46:03 <maerwald> also has some ruidmentary docker support
07:46:03 <shapr> ptek: in that case, is the babysitting required because of Haskell? or something else?
07:46:37 <ptek> shapr: because of the underlying infrastructure. and linux
07:47:30 <ptek> maerwald: no I have not seen this yet.
07:47:37 <ptek> maerwald: thank you
07:50:54 <shapr> ptek: will you write up what you find? propellor looks like the best option, but I'm interested to hear what you discover.
07:51:14 <ptek> shapr: gladly
07:51:50 <ptek> I think this is an area where there is not so much written about in general
07:52:27 <maerwald> web app deployment? xD
07:52:31 <maerwald> I think there is a lot
07:53:12 <shapr> but usually they talk about chef
07:53:34 <eelster> shapr: Chef is Ruby, no?
07:54:04 <shapr> Yes, it is.
07:54:42 <shapr> I also heard about puppet, ansible, salt stack, and some others. They're mostly Python/Ruby. I think there's also more than one for Java, etc.
07:57:42 <sm> I'm also interested in propellor, though it's a bit rough and underdocumented
08:00:29 <ertes> ptek: i have a nix-based deployment infrastructure, but i'm not using nixops, because it uses a stateful model, which i find rather unfortunate…  i attempted once to integrate ansible into the workflow, but it didn't seem to provide an advantage in my use case
08:00:43 <maerwald> sm: I'd only use it to set up a docker host any _maybe_ fire up docker containers (that I'd probably do differently though)
08:02:57 <ertes> ptek: for the actual deployment i use a mixture of s6 and nix-copy-closure, and for the management around it i use the oldest trick in the book:  a makefile
08:03:50 <ertes> ideally i'd like to move to a hydra-based solution at some point to get real CI
08:04:07 <ertes> but that requires an actual hydra server
08:04:44 <muzzle> hi, i have a package (inline-r) that uses the c2hs build tool
08:04:52 <muzzle> is there a way to pass arguments to c2hs?
08:04:57 <muzzle> in the build (with stack)
08:04:58 <ptek> ertes: sounds reasonable
08:06:06 <ptek> ertes: do you have a monitoring around that to see if everything is running?
08:06:08 <ertes> ptek: overall i'm happy with my solution…  even though it's hand-crafted i feel confident that it won't blow up in my face, mostly because of the guarantees that nix provides…  that's why i'm not pressing too much to move to hydra
08:06:26 <ertes> ptek: yeah…  due to legacy reasons it's zabbix =/
08:06:43 <ertes> it's horrible, but it works for the time being
08:08:49 <amx> what would you pick today?
08:09:10 <ertes> amx: that's a good question…  i heard nice things about bosun, so it would probably be my first pick
08:09:29 <ptek> my dream is to have an idempotent deployment tool, and running it periodically would just "fix" the issues... One could then rely on the fact that the system is stable and monitor the user facing side to see if that is working as expected
08:10:03 <ertes> ptek: ansible and nix have idempotence built into their model
08:10:25 <ptek> ertes, looks like propellor does too
08:10:33 <ertes> in ansible it's more a philosophy:  you would design your scripts such that they are idempotent, and most of the existing stuff is written that way
08:11:49 <ertes> in nix it's enforced to the extent that it can be:  all inputs are explicit, and changing an input changes the resulting hash value…  you still have to ensure that the actual build outputs are deterministic or at least "close enough"
08:12:39 <ertes> unfortunate GHCness:  GHC is not deterministic in 8.0.1, though they are working on it, as far as i know
08:12:40 <muzzle> has anyone here sucessfuly used c2hs on OSX Sierra
08:12:42 <muzzle> ?
08:13:08 <kuribas> absence: that looks like x -> State (SomeState A B C) w 
08:14:30 <ptek> muzzle: are you running c2hs with `stack c2hs` or something similar?
08:14:52 <kuribas> absence: zoom might be usefull
08:14:53 <kuribas> :t zoom
08:14:55 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
08:15:00 <muzzle> no
08:15:12 <muzzle> ptek it's used for building a dependency (inline-r)
08:15:40 <muzzle> and it seems to have a problem with a header provided by apple
08:16:12 <ptek> muzzle: oh. I see. Sounds like trouble
08:17:42 <muzzle> ptek it seems to basically be this bug: https://github.com/tweag/HaskellR/issues/275
08:18:12 <muzzle> ptek so i recon it's a problem with the provided stdlib.h
08:18:31 <muzzle> ptek and maybe I can use an other version of that header, which does not lead to the same problem
08:18:41 <maerwald> ptek: btw. such things like propellor are actually hard to test for correctness, since they are "downstream". If a security update in debian stable breaks the configuration format of apache, then propellor doesn't know and will very likely screw up.
08:19:03 <maerwald> (and there are no such tests in propellor)
08:19:34 <ptek> muzzle: I thought I have built something with hsc2hs lately on Sierra, but now I see that that could not have been true. The build fails for me.
08:20:39 <muzzle> ptek from what I can see all builds using c2hs on sierra fail
08:21:06 <muzzle> maybe we could use a version of stdlib that is not supplied by apple
08:21:18 <muzzle> i.e. the one that comes with homebrew gcc
08:21:27 <muzzle> the only question is how do I tell c2hs that
08:23:01 <shapr> ertes: have you looked at ndm's bake for CI?
08:23:47 <ptek> maerwald: this is true. But then the "dream" of immutable infrastructure seems to be not achievable :)
08:24:44 <ptek> maerwald: I wonder how one would deal with that (broken apache configs) without manual  intervention
08:26:11 <ptek> maerwald: wouldn't containers solve the issue? But then they need to be run on some host and one has the problem there...
08:36:05 <ocramz`> hullo!
08:40:55 <ocramz`> I've started laying some groundwork for a simulator of stochastic processes such as volatility models etc. : https://github.com/ocramz/sde. It doesn't bring any new type-theoretical astronautics, but it's very compact and quite clean code, owing in no small part to `mwc-probability` and `plots`, upon which it's built 
08:41:29 <ocramz`> It's not ready for public consumption yet, though ^_^
08:42:08 <ertes> shapr: nope, haven't heard of it yet
08:42:13 <ertes> *hadn't
08:42:43 <shapr> ertes: I found it here: http://brian.uncannyworks.com/posts/2016-12-09-haskell-bake-and-kubernetes.html
08:43:05 <ertes> i have to leave now, but it's bookmarked for later =)
08:44:56 <EvanR> yeesh mixture of . and $
08:46:27 <ocramz`> EvanR : in the blog post you mean?
08:46:54 <jaarod> cabal repl file.hs doesn't load the file. i can't seem to find proper syntax in help either.
08:46:57 <EvanR> yes
08:47:06 <jaarod> can someone help?
08:47:18 <ocramz`> jaarod: what's happening?
08:47:44 <ocramz`> does file.hs load any external packages?
08:47:50 <nate_> Is there a simpler way to do "asdf xs = if null xs then Nothing else Just xs"?
08:48:42 <ertes> nate_: asdf [] = Nothing; asdf xs = Just xs
08:49:05 <ertes> nate_: why are you doing that conversion though?
08:49:47 <EvanR> Just [] feels left out
08:50:16 <nate_> ertes: That's about the same, no?  I'm doing that conversion because of two modules whose signatures are mismatched.  The lists need to get peeled out later.
08:50:39 <hexagoxel> [xs | not $ null xs]
08:50:46 <jaarod> ocramz if I try to call function defined in file.hs I am getting not in scope error
08:50:49 <hexagoxel> MonadComprehensions ftw
08:51:21 <jaarod> ocramz file.hs isn't importing any modules, if that is what you meant
08:51:57 <hexagoxel> jaarod: iirc `cabal repl` loads the first of exposed modules by default
08:51:59 <nate_> hexagoxel: that is simpler, and doesn't feel cheesy.  I'm satisfied!
08:52:53 <verement> > [listToMaybe [], listToMaybe [2]]
08:52:56 <lambdabot>  [Nothing,Just 2]
08:57:34 <buttons840> I have some async code that works almost like I want, but ends with a BlockedIndefinitelyOnMVar exception (which is semi-okay, because I wanted the program to end anyway) -- I could catch and hide the exception, but is that a sane thing to do?
08:58:24 <ReinH> Not really.
08:58:32 <buttons840> is GHCs deadlock detection robust enough to depend on, or is it just a best effort that's better than the alternative?
08:58:48 <ReinH> A program that happens to break at the right time isn't really a good program.
08:58:49 <buttons840> (the alternative being to just let it deadlock)
08:59:20 <verement> Better would be to prevent the deadlock
08:59:25 <buttons840> yeah, I agree
08:59:46 <nshepperd> buttons840: the deadlock detection is sound but not complete
09:00:27 <nshepperd> iirc it triggers when the only thread holding a reference to the mvar is the one waiting on it
09:00:42 <buttons840> okay, I don't intend any disrespect towards anyone, but the full story is this is the only way i've found to get a fairly simple program to work with the transient library
09:02:08 <buttons840> https://github.com/transient-haskell/transient/issues/38
09:03:46 <nshepperd> forkIO (proveGoldbachConjecture >> putMVar mvar ()) >> takeMVar mvar -- won't trigger deadlock detector
09:05:01 <ReinH> nshepperd: ... but that isn't a deadlock?
09:05:59 <nshepperd> well, it might be blocked indefinitely
09:06:06 <ReinH> That's true.
09:06:18 <davean> has anyone checked?
09:06:41 <ReinH> But I wouldn't expect a deadlock detector to detect it.
09:08:35 <nshepperd> I think there are more mundane examples involving multiple mvars where the deadlock detector won't detect it either
09:09:33 <davean> Interleaved with a deadlock?
09:09:51 <agocorona_> I saw just before disconnecting that there was some issue with transient and deadlocks
09:10:14 <agocorona_> keep''=  keep'  f  `catch`  \(e :: BlockedIndefinitelyOnMVar) -> return ()
09:10:37 <agocorona_> this detects the deadlock when no more threads are running inside the keep' block
09:14:51 <buttons840> yes agocorona_, I'm a haskell noob, but that looked like a strage solution to me -- the conditions that lead to the error still exist, but your just hiding the error, right?
09:15:01 <buttons840> i am the author of that issue BTW
09:15:48 <davean> pretty much
09:16:17 <davean> Thats just detecting a VERY specific case of deadlock, and doing nothing when it happens instead of waiting to do something it will never be able to
09:16:28 <leshow> trying to figure out how to expand (f .)   im seeing this expression: fmap (f .) -- i can't figure out what f . is in non-pointfree form
09:16:30 <davean> I'd really like to reiterate how narrow a case that actually catches
09:16:37 <davean> Almost no deadlocks look like what that catches
09:17:36 <agocorona_> buttons840:  it is  a perfectly valid condition: keep maintains asynchronous threads running. When there is no more threads to report an error or return () depends on what the programmer want to achieve
09:18:27 <agocorona_> for example if keep' executes a multithreaded search trough a filesystem,  no more threads running means that nothing was found
09:19:07 <buttons840> can't keep' see that there are no more threads and exit cleanly rather than throwing an exception for a common case?
09:19:27 <davean> yep
09:19:55 <davean> https://hackage.haskell.org/package/async might well be a better match for said usage pattern, and it has no need to ugly hacks like that
09:19:57 <agocorona_> buttons840: yes that is in the next version. Originally keep' was intended for debugging only
09:21:06 <agocorona_> davean async  has not the features of transient
09:24:05 <agocorona_> keep does not produce such error. It is the right runner of the transient monad
09:24:24 <buttons840> agocorona_: as a novice, I do like the transient API -- honestly, from the beginning I've thought it seems a little too good to be true, and I still have that worry a little bit, but I will be following the project at least
09:26:06 <buttons840> one point of feedback: I would potentially be interested in having the Base/Indeterminism features isolated into their own library / API -- i like the API around choose/threads/parallel/etc but wont alway need all the other features included in the library
09:26:07 <agocorona_> buttons840:  it seems too good to be true, that's right. but it works ;)
09:26:17 <sm> hi agocorona_, are there some real-world apps using transient yet ?
09:26:58 <agocorona_> sm : transient-universe uses transient fully
09:27:45 <agocorona_> apart from that, it is being evaluated by some companies. No visible stuff yet
09:28:14 <buttons840> agocorona_: i.e., isn't TransIO a StateT? is it possible to have the async API without the StateT and all the other monad transformers in the stack?
09:29:23 <agocorona_> buttons840:  state is necessary for thread control, backtracking and a lot of things
09:29:27 <ReinH> I am deeply suspicious of any suggestion to catch a deadlock error rather than restructure your program to prevent the deadlock.
09:29:34 <ReinH> That seems irresponsible to me.
09:31:08 <buttons840> ReinH: i agree, but agocorona_ said a future release will not depend on catching the deadlock exception -- he originally suggested that to me as a workaround to get my program working the way I wanted I think
09:31:18 <agocorona_> ReinH:  that means that you do not realize that controlling deadlocks of third party programs is impossible
09:31:25 <ReinH> leshow: \g -> (f . g), see https://wiki.haskell.org/Section_of_an_infix_operator
09:31:46 <ReinH> No, it means I don't use broken third party programs.
09:32:17 <ReinH> Catching a deadlock error in GHC is not a sufficient solution.
09:32:27 <agocorona_> Third party programs are provided by the programmers that use transient. Do you understand that transient is not a program, but a library?
09:32:46 <ReinH> Why does that matter?
09:33:05 <mpickering> lyxia: are you coming to Oxford with Meng next week?
09:33:07 <ReinH> Why does it matter who wrote the broken code? If you can fix it, fix it. If you can't fix it, don't use it.
09:34:19 <jophish> https://github.com/byteally/dbrecord-opaleye looks really nice
09:34:22 <buttons840> agocorona_: were you suggesting that it's OK to catch deadlock exceptions in general, or were you just giving me a workaround?
09:34:56 <ReinH> Catching a deadlock error is problematic for two reasons: First, it is a bad solution. Second, it implies that the person who uses it doesn't know how to write concurrent programs properly.
09:35:01 <agocorona_> buttons840:  it is a workaround for your case, that was not contemplated 
09:35:28 <ReinH> buttons840: I would suggest using async, which is not broken.
09:35:57 <agocorona_> as I said , keep is a call for debugging purposes and to maintain  daemons in memory
09:36:18 <agocorona_> I mean keep'
09:37:08 <agocorona_> the "official" runner of the monad is keep, which do not produce such deadlock exceptions 
09:38:27 <buttons840> agocorona_: yeah, keep did not deadlock, but didn't work for my case
09:38:53 <buttons840> well, it "worked as intend", but the way that it was intended wasn't what I wanted
09:39:00 <ReinH> Ok, so it only deadlocks when you use it.
09:39:57 <buttons840> ReinH: you seem quite emphatic (if not aggressive or rude) about a point we've all agreed on -- catching deadlocks is not a good solution
09:40:17 <ReinH> Which is why I'm surprised that people still seem to be defending it.
09:41:44 <buttons840> i don't interpret that anyone is defending it, agocorona_ said it wasn't ideal and he was working on a fix for a future version that did not involve catching deadlocks -- he does not catch deadlocks in the library as far as I know, but suggested it to me as a quick workaround (which did work as a workaround) without a lot of thought
09:42:11 <ReinH> Quick workarounds have a way of not being so quick.
09:42:36 <ReinH> Plenty of systems include code someone thought was a quick workaround years ago.
09:43:38 <lyxia> mpickering: yeah!
09:43:57 <maerwald> extra points if they still know it's a workaround xD
09:44:09 <lyxia> mpickering: thanks for reminding me!
09:44:31 <davean> ReinH: God, yes, I really wish people would never, ever use quick workarounds. They ruin my life years later
09:45:16 <davean> the more poorly founded, the more irresponsible
09:45:19 <Philippa> we have bug trackers, but technical debt tracking not so much
09:46:22 <ReinH> I mean, a recent devastating Linux kernel security vulnerability was the result of a quick workaround by Linus more than a decade ago.
09:46:49 <ReinH> TOCTOU is hard, let's go shopping
09:47:03 <agocorona_> ReinH:  here you can se how  async and transient compares implementing an example Simon Marlow in his book  https://www.schoolofhaskell.com/user/agocorona/beautiful-parallel-non-determinism-transient-effects-iii#using-the-parallel-non-determinist-effects-in-transient-to-perform-parallel-search
09:47:13 <ReinH> And now we have botnets composed of washing machines, lights, and refrigerators.
09:47:54 <maerwald> IoT incoming
09:48:23 <ReinH> At least I am confident that the async version is correct.
09:49:20 <davean> Also, all the difference I'm seeing here is async stuck to async while transient pulled in features that could be compossitionally produced from other libraries?
09:50:10 <davean> also, the sync version has a tigher loop
09:50:17 <agocorona_> ReinH:  what do you mean?
09:50:17 <buttons840> davean: aren't almost all libraries just convinient groupings of stuff you can find elsewhere?
09:50:18 <davean> where as the transient version reloops the entire thing
09:50:26 <davean> buttons840: Absolutely not!
09:50:29 <davean> buttons840: that is not the haskell way
09:50:30 <ReinH> agocorona_: That I am not convinced that the transient version is correct.
09:51:01 <ReinH> davean: Also Simon's version was designed as a pedagogic tool to teach concurrent programing fundamentals, the transient version was designed to look nicer than the async version.
09:51:19 <davean> buttons840: haskell usually produces rather nice, small, orthagonal libraries which you can pick and choose which ones produce the results you want when composed!
09:51:25 <davean> buttons840: its how Haskell gets such high code reuse
09:51:49 <davean> ReinH: I'd counter the transient version looks a lot worse with its full looping instead of the tigher loop
09:53:23 <ReinH> buttons840: not in all but the most reductive sense?
09:53:39 <agocorona_> ReinH:  Have you taken a look at the async version? It is not in the link. If you take a look at it you will see that you can not decide if it is correct or not. It is a mess. 
09:53:53 <ReinH> most libraries provide significant unique value, but all are technically produced by combining imported identifiers in certain ways.
09:53:53 <agocorona_> what is in the link is the single threaded version
09:54:39 <davean> agocorona_: findpar.hs RIGHT?
09:55:24 <ReinH> agocorona_: It is not a mess.
09:55:44 <ReinH> And I am confident that it is correct because Simon Marlow wrote it.
09:56:09 <ReinH> While the other code was written by someone who suggests catching GHC deadlock detector errros as a workaround.
09:56:15 <davean> ReinH: That last one is a bad argum,ent l)
09:56:27 <agocorona_> ReinH:  arguentum ad authoritas ;)
09:56:28 <davean> er, the "because Simon Marlow wrote it" part is a bad arguement
09:56:45 <davean> Though I agree, I look at the findpar.hs impl and it is immediately obvious why it is correct
09:56:58 <ReinH> agocorona_: Argummentum ad authoritas is valid when the expert is relevant.
09:57:08 <ReinH> davean: We all trust other people's code every day.
09:57:17 <agocorona_> ReinH:  It is perfectly valid
09:57:17 <ReinH> Without reading it.
09:57:31 <davean> ReinH: you wouldn't know it by how much time I spend reviewing the libraries I use
09:57:51 <ReinH> davean: Well, I know you spend more than most, but the point stands.
09:58:05 <davean> It does, to a degree
09:58:30 <davean> but its not relivent for considering the two solutions as representative of the libraries used
09:58:51 <ReinH> I find concurrency code written by Simon Marlow in a book about how to write concurrency code correctly to be trustworthy.
09:59:07 <agocorona_> what if I say to you that with two changes in the code can convert the search snippet into a search in a distributed filesystem?
09:59:18 <ReinH> I find concurrency code written using a library with known deadlock bugs to be less trustworthy.
09:59:46 <ReinH> To quote Gerald Weinberg, "If it doesn't have to work then you can meet any other requirement."
09:59:47 <davean> agocorona_: I'm not sure what definition you use with a distributed filesystem, but the simonmarlow code needs 0 changes?
10:01:00 <agocorona_> oh. impressive
10:01:04 <buttons840> ReinH: it is a younger project that hasn't been proven through extensive use, of course it's less trustworthy -- there seems to be a lot of trying to squash new ideas here, personally I like the transient API better
10:01:41 <buttons840> although I need to spend more time with async
10:02:03 <davean> agocorona_: "distributed filesystem" can mean many things
10:02:13 <davean> agocorona_: do you mean moving the code to the metadata?
10:02:28 <ReinH> The only thing I'm trying to squash is concurrency code in the wild with deadlock errors.
10:02:36 <davean> which isn't so much a distributed filesystem thing but an execution stratagy
10:03:05 <davean> otherwise I have no idea why you'd think any changes at all would be warrented
10:03:12 <davean> and if you mean distributed semantics on the FS ... well ...
10:03:29 <ReinH> Trying to sell me on the library's features is a lot like selling me on a car that explodes if you brake too hard. I just don't care how well it accelerates.
10:03:29 <davean> I'll probably just slap you with FLP, ask for a longer definition and go take a nap
10:04:24 <agocorona_> davean:  don't care
10:04:27 <ReinH> concurrency and distsys are hard, and I am suspicious of all attempts to make it seem easy.
10:04:34 <davean> agocorona_: I kinda figured you didn't
10:05:01 <davean> agocorona_: Its jus weird you said something with so little meaning
10:05:41 <davean> If you'd cared I really doubt you would have
10:06:14 <agocorona_> I meant distributing the search among many nodes that search in their own filesystems and return the results back to the original caller. All done by that single snippet
10:06:49 <agocorona_> but I know that you are not interested. so....
10:07:02 <davean> right, which has nothing to do with the FS and everything to do with execution, and has an issue with consistency of the results
10:07:39 <davean> which consistency model are you claiming?
10:07:55 <buttons840> ReinH: i was suspicious too, and still wonder if there will be some edge case that breaks transient, but as long as the issues are worked out I think it's a great library with a great API -- but yes, there are issues to be worked out
10:09:01 <agocorona_> I know that intermediate to expert haskellers are hostile towards transient. It is natural
10:09:25 <ReinH> buttons840: I know enough about distsys to know when I see someone selling me a free lunch.
10:09:46 <ReinH> It's "natural"?
10:10:00 <ReinH> And you assume that this is not because it's bad but because of some personal reason?
10:10:05 <davean> ReinH: well, they don't document what it actually is supposed to do, so yah, I'd say its natural
10:10:08 <agocorona_> I'm not a kid guys. I have 56 years. 30 years working in industry. 15 years working with haskell. I know what I do. right?
10:10:45 <ReinH> If the majority of good programmers that I know were hostile to some code I wrote, I would be looking really hard at the code to figure out why.
10:11:03 <davean> I can't actually say it doesn't live up to its goals because it never states the intended semantics
10:12:10 <davean> There are a ton of valid models mind you
10:12:14 <ReinH> I'm hostile towards distsys libraries that make vague, expansive claims and then deadlock when someone adds an ' to an identifier. Yep. You got me.
10:12:16 <davean> They're all just for different use cases
10:13:01 <davean> I mean, Cloud Haskell was more preciese and I took a deep, long look at that. Its failure handling leaves a lot to be desired but in the case that all the systems and the network works at least I know what it should do
10:15:51 <agocorona_> the actor model does not compose
10:16:14 <davean> I never made any claims about that?
10:16:21 <sm> we could be skeptical without being hostile, I would think ?
10:16:24 <agocorona_> it is not a functional paradigm it is object oriented (shor answer)
10:16:28 <ReinH> Sure it does, but I don't see how that's relevant.
10:16:45 <ReinH> No one said anything about the actor paradigm.
10:16:49 <davean> agocorona_: I don't see where you're going
10:16:52 <agocorona_> short answer , i mean
10:17:15 <davean> I see no relivency in this tangent
10:17:23 <ReinH> sm: agocorona_ called people "hostile", probably people who were skeptical like I am.
10:17:41 <agocorona_> I mean that cloud haskell, like many other frameworks, specially web frameworks are direct imports of a model that is not the one of functional programming
10:17:46 <sm> how about some of that good ol' #haskell tolerance
10:17:48 <agocorona_> sort of
10:17:55 <ReinH> You think Cloud Haskell uses an actor model?
10:17:56 <davean> agocorona_: So, in general, what does transient claim to do about node failures, partial, total, or byzantine?
10:18:17 <ReinH> sm: Sure, let's start with not calling criticism 
10:18:22 <ReinH> ... 'hostile'
10:18:24 <ReinH> stupid enter key
10:18:28 <agocorona_> davean: it uses wathever failure model the programmer may desire.
10:18:31 <sm> seems we treat our trolls better than our innovators :)
10:18:37 <davean> agocorona_: does it now?
10:18:44 <davean> agocorona_: what does that even mean?
10:18:54 <ReinH> How does the programmer select a failure model?
10:19:10 <ReinH> sm: I'll let you know when I meet an innovator.
10:19:35 <agocorona_> yes. there is a services module that restart services that start and re-start services on demand
10:19:45 <sm> no private messages please
10:19:49 <davean> agocorona_: how does that relate to failure models?
10:20:09 <ReinH> Another non sequitur.
10:20:19 <Pythonic_turtle> Hey I have heard that haskell  is for pussies(Will you treat me well)
10:20:36 <agocorona_> but that is because at the library level it support the backtracking effect, which allows exception handling and retry of failures
10:20:52 <ReinH> Ok, I'll bite. How are failures detected?
10:20:55 <davean> agocorona_: How does it know if something is a failure? What is its definition of a failure?
10:21:07 <davean> agocorona_: the definition of a failure is core to what its failure model is
10:21:22 <agocorona_> concretely the monitor service implement the cloud haskell model
10:21:56 <davean> Hum
10:22:00 <davean> yah, so about that
10:22:38 <davean> consider network reordering
10:23:01 <davean> what do you do to get monotonicity out of that model?
10:23:21 <agocorona_> transient does not adopt a particular distributed architecture. It is a library for creating  distributed architectures among other things
10:23:47 <ReinH> But you just said it retries failures, which implies that it detects failures.
10:23:57 <davean> Yes, but the construction of said is inherantly dependent on processing failures
10:23:59 <agocorona_> for example I programmed the  dataflow model (spark)  and the akka model with it, and made an example application that use both
10:24:52 <agocorona_> davean:  processing failures is in the hands of the programmer
10:24:57 <ReinH> No it isn't?
10:24:58 <davean> Not really
10:25:07 <davean> the underly library is the only place that has knowlege of that
10:25:13 <ReinH> Programmers can only process failures once they're detected.
10:25:23 <davean> all the programmer can really do is look at what the library tells it an impliment timeouts
10:25:35 <ReinH> Failure detection is the core of any distributed system, and the way it's done has implications for that system's behavior.
10:25:54 <ReinH> You can't just claim that your distsys library punts this to the developer.
10:25:54 <agocorona_> not If  I bring a framework that allows the creation of distributed architectures. And that is what transient brings
10:26:01 <ReinH>  That's simply not true.
10:26:08 <davean> Thats absolutely false
10:26:49 <davean> I mean, I hate to start at the begining, but I cite FLP
10:27:13 <agocorona_> if I create over transeitn it the  actor model, then yes, I have to deal with failures and solve them according with that particular model
10:27:23 <davean> Only a system that starts in a stable state can be guarrenteed to reach a stable state without a sync. network
10:27:38 <davean> No, ANY model
10:27:43 <ReinH> You always have to deal with failures.
10:28:05 <davean> FLP says that any model that doesn't start in a stable state and without a synconous network CAN NOT be guarrenteed to converge
10:28:15 <davean> It is not even a theoretical possability
10:28:35 <ReinH> davean: I was going to mention CAP but sure, we can go with FLP. :p
10:28:45 <davean> I like to start basic
10:28:53 <suppi> is there a haskell channel specifically for web programming?
10:29:06 <davean> suppi: theres a (mostly dead) mailing list at least
10:29:17 <suppi> davean: oh :(
10:29:20 <sm> #haskell-web, but it's almost dead. Also framework-specific channels
10:29:29 <buttons840> suppi: ask here
10:29:31 <suppi> something for spock maybe?
10:29:49 <ReinH> I mean, we still have the fundamental problem that transient is cllaimed to both allow users to handle failures and to not detect failures.
10:30:10 <suppi> buttons840: I'm don't know much about web so i wanted to gain some knowledge from other people's questions :)
10:30:30 <buttons840> you don't know much about haskell web, or web in general?
10:30:38 <suppi> buttons840: both
10:30:40 <davean> suppi: Is there a specific goal?
10:31:30 <suppi> davean: i have a specific and non-specific goals. i have a project in mind but also learning web programming best practices
10:31:33 <agocorona_> ReinH:  so  the socket library can never be used for distributed computing, since it does not guarantee to converge
10:31:46 <ReinH> What?
10:31:49 <davean> agocorona_: No?
10:32:01 <Tehnix`> suppi: I think you'd have the most luck either lurking in the specific framework channels, or Haskell on Reddit, where there are often web-related things coming up
10:32:20 <davean> It passes the errors through to the programmer so we know which things *can* be programmed with it though
10:32:22 <davean> and its limited
10:32:33 <davean> there are very clear theoretical boundaries on what we can use the socket interface for
10:32:43 <ReinH> The socket library doesn't make absurd claims about its failure model.
10:32:51 <suppi> one specific question though, i saw spock has a 'users' package for handling users but what if I have extra information about users? should I use the lib and keep the extra info in a different db table?
10:32:55 <ReinH> It also doesn't claim to be a framework for constructing distributed architectures.
10:33:08 <suppi> or is it better to just roll my own?
10:33:16 <suppi> or is there another option
10:33:30 <davean> So, the socket library gets into an interesting space where most of what is accomplisable is based on failure oracles
10:33:44 <ReinH> suppi: so the uesrs package doesn't let you supply your own user type? That's a shame.
10:34:08 <suppi> ReinH: i don't think so? maybe i'm mistaken
10:34:31 <agocorona_> davean: ReihH  Thank for the opportunity to explain transient. I have to do some work. I leave you in your theoretical boundaries.   
10:34:57 <davean> agocorona_: Please, when you decide what transient actually does, let us know!
10:35:11 <davean> suppi: Do you mean http://hackage.haskell.org/package/users
10:35:18 <suppi> davean: yes
10:35:21 <buttons840> suppi: by spock users do you mean spock-auth? i can't find a spock users library
10:35:23 <agocorona_> I will be very happy to answer any of your questions any time
10:35:24 <davean> thats not spock specific?
10:35:38 <suppi> davean: not really no
10:35:55 <suppi> but is written by the same author
10:35:56 <davean> agocorona_: it sounds like you mostly mean messaging and remote invocation BTW
10:36:17 <suppi> there are a few libraries that are decoupled from the main Spock project
10:36:37 <ReinH> suppi: Anyway, having a separate user info table isn't a terrible idea
10:36:45 <davean> suppi: you'd hang extra information off of the UserId
10:36:48 <ReinH> the users table is one of the most used tables, for obvious reasons
10:36:52 <davean> see up in the UserStorageBackend class?
10:36:53 <agocorona_> davean: there is an entire tutorial . look at the part of cloud computing: https://github.com/transient-haskell/transient/wiki/Transient-tutorial
10:36:59 <davean> agocorona_: I did
10:37:04 <ReinH> a user metadata table could be used much less frequently
10:37:12 <davean> agocorona_: I spent about a day looking at transient before this conversation
10:37:23 <suppi> ReinH: what do people normally do?
10:37:37 <ReinH> suppi: I'm not sure, I just rolled my own.
10:37:41 <ReinH> But that was a while ago.
10:37:48 <suppi> ReinH: alright. I see.
10:37:55 <suppi> I might consider doing the same
10:38:39 <suppi> thanks
10:39:51 <suppi> davean: what do you mean hang extra info off of the UserId?
10:40:05 <Sornaensis> he means don't circumcise it
10:40:06 <davean> suppi: thats your primary key
10:40:14 <Sornaensis> wait wrong channel sry
10:40:43 <suppi> davean: right
10:40:45 <davean> suppi: You can make a 1-1 relation from that to extend the table, or a number of other solutions, like the user table actually being larger and just having a superset of the fields
10:40:57 <davean> suppi: nothing here says the table ONLY has those fields
10:41:06 <davean> suppi: just those are only the fields that class accesses
10:42:00 <suppi> davean: does that says exactly what fields will be in the table? http://hackage.haskell.org/package/users-0.5.0.0/docs/Web-Users-Types.html#t:User
10:42:41 <davean> suppi: yes
10:42:48 <davean> or, well, close to it
10:43:04 <suppi> close to it?
10:43:05 <davean> IN theory you could put it in a number of normal forms that are equivilent
10:43:13 <davean> but you don't care about that
10:44:27 <suppi> sorry i'm getting a bit confused. I thought if I were to use this library the users table will be managed for me for the most part but it can only have the fields listed there?
10:44:27 <davean> suppi: A list of things you don't care about: https://en.wikipedia.org/wiki/Database_normalization#List_of_Normal_Forms
10:44:38 <davean> suppi: No
10:44:42 <suppi> are you suggesting adding columns or stuff?
10:44:54 <suppi> like, after the fact?
10:45:00 <davean> suppi: UserStorageBackend is a class that actually DOES the managing
10:45:10 <davean> note there are no instances listed
10:45:19 <davean> The rest is just API for that class
10:45:52 <davean> there are two backends, http://hackage.haskell.org/package/users-postgresql-simple and http://hackage.haskell.org/package/users-persistent
10:45:56 <suppi> yep
10:45:57 <davean> Those actually DO the managing
10:46:04 <suppi> right
10:46:14 <davean> That class and related show the constraints on the model that those can manage
10:46:18 <davean> not what hte model actually has to be
10:46:43 <ski> davean : "A list of things [normal forms] you don't care about" -- whyfore ?
10:46:49 <davean> ski: ?
10:47:00 <davean> http://hackage.haskell.org/package/users-postgresql-simple-0.5.0.2/docs/src/Web-Users-Postgresql.html#line-100
10:47:10 <davean> Now, if you use initUserBackend it'll create a minimal table
10:47:22 <davean> but if you don't call that method, it just cares that the table is compatable
10:47:37 <davean> ski: what is your question?
10:47:56 <ski> davean : just asking what you meant, about not caring (not needing to care ?) about normal forms ?
10:48:16 <davean> ski: Oh, I said "or equivilent", those are the equivilencies
10:48:21 <suppi> so basically i get the api and i can choose to init the backend in a different way? a way that gives it more columns?
10:48:30 <davean> suppi: or you can expand it later
10:48:40 <davean> you can't access the extra information through this class though
10:49:03 <suppi> right, but i can roll my own and just use this for basic user management?
10:49:03 <davean> ski: the main point being that there are a lot of equivilent ways to structure a relational DB but that wasn't really the point of discussion here
10:49:12 <davean> suppi: basicly
10:49:36 <suppi> alright, that makes sense. would this be something you'd do?
10:49:39 <ski> davean : equivalences between what ? (sorry for jumping in the middle of a conv., btw)
10:49:52 <davean> ski: He was talking about adding data to a user table
10:49:56 <suppi> or are there better/more common practices?
10:50:12 <davean> suppi: It depends on the task at hand? Its a decent solution
10:50:29 <davean> suppi: putting the extra data in another table might suite you better
10:50:36 <davean> suppi: and connecting them via a forgien key
10:50:41 <suppi> for example adding an `is_admin` or `want_emails` fields
10:51:22 <ski> davean : mhm. i suppose i'll be satisfied. ty for the elaboration
10:51:40 <davean> ski: I can try to explain further, I don't know which context you're missing though
10:52:41 * ski doesn't know either, probably should try to read the backlog more closely
10:53:12 <suppi> davean: thanks for your help!
10:53:19 <davean> suppi: no problem
11:22:33 <hexagoxel> can i get the dictionary out of a bounded existential?
11:24:07 <carbolymer> hi guys, i am learning haskell and I am wondering, what can I do with the follwing expression: foo = ($ 2 + 2)
11:24:18 <carbolymer> i mean, i cannod print foo
11:24:24 <carbolymer> in ghci
11:24:38 <ReinH> > :t let foo = ($ 2 + 2) in foo
11:24:41 <ReinH> :t let foo = ($ 2 + 2) in foo
11:24:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:24:43 <lambdabot> Num a => (a -> b) -> b
11:25:16 <ReinH> carbolymer: What does the type tell you?
11:27:09 <hexagoxel> i.e. is there an isomorphism between `data Foo = forall a . C a => Foo (something a)` and `data Foo = forall a . Foo (Dict C) (something a)`
11:27:34 <kuribas> :t ($ 2 + 2)
11:27:36 <lambdabot> Num a => (a -> b) -> b
11:28:19 <ski> > ($ 2 + 2) show
11:28:22 <lambdabot>  "4"
11:28:46 <ReinH> Socrates is dead. :(
11:29:45 <suzu> rip
11:30:41 <ski> (sorry if i ruined your midwifery, but i suspect that carbolymer doesn't understand how to parse the type)
11:32:04 <buttons840> ski: that's ok, "i don't know" is an acceptable answer
11:32:45 <buttons840> better to know what you don't know than not
11:32:46 <carbolymer> ski, oh, nice! thx!
11:33:00 <ReinH> ski: that's why I asked.
11:33:30 <ReinH> and learning how to parse types better would have been a worthy result
11:33:33 <hexagoxel> hmm the latter `Foo` allows for arbitrary Dicts, so there certainly is no bijection. so i am not completely certain if "isomorphism" is the right term.
11:34:01 <hexagoxel> but that fact also motivates my question - i'd prefer only allowing "valid pairings"
11:35:15 <ski> ReinH,buttons840 : i agree. i didn't read the context well enough. sorry
11:35:24 <ReinH> ski: no worries
11:36:15 <ski> unrelatedly ..
11:36:18 <ski> "Modular and Efficient Top-Down Parsing for Ambiguous Left-Recursive Grammars" in 2007-06 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.97.8915>, and
11:36:29 <ski> "Parser Combinators for Ambiguous Left-Recursive Grammars" by in 2008 at <http://richard.myweb.cs.uwindsor.ca/PUBLICATIONS/PADL_08.pdf>,<http://richard.myweb.cs.uwindsor.ca/PUBLICATIONS/APPENDICES_HASKELL.html>, both by Richard A. Frost,Rahmatullah Hafiz,Paul C. Callaghan, sounds interesting
11:36:44 <ReinH> Nice
11:37:04 <carbolymer> ski, I am still learning how to read types, anyway, thx
11:37:40 <ski>   "This paper has three objectives: 1) To make the algorithm of Frost, Hafiz, and Callaghan known to a wider audience beyond the Computational Linguistics community. In particular by the functional and logic programming communities both of which have a long history of creating parsers as executable specifications (using parser combinators and Definite Clause Grammars respectively), ..."
11:38:11 * ski idly wonders whether the code is on Hackage
11:38:12 <kuribas> I think it's wrong to treat natural languages as formal languages.
11:38:45 <kuribas> natural languages are constantly changing, and rely on context for the greater part.
11:45:39 <jonjon777> haskell
11:48:31 <ski> kuribas : perhaps augur would offer a more lively discussion on that topic ..
11:50:43 <orzo> I need suggestions on a thread pool library.  I've looked at and like parallel-io, but I have threads are free to die without returning to the caller which seems awkward with parallel-io.
11:50:53 <johnw> orzo: async-pool
11:51:01 <orzo> thanks
11:51:08 <johnw> I wrote it because I was dissatisfied with parallel-io
11:51:59 <absence> kuribas: thanks for the suggestion about zoom earlier. it's similar to %%= in that it converts e.g. State A r to State SomeState r, which means the computations aren't isolated anymore
11:53:08 <kuribas> absence: yes, you can compose them with >=>
11:59:30 <orzo> johnw: does concurrently return a lazy list as soon as a single one of the operations finishes?
11:59:40 <orzo> if not, does the library have that functionality?
12:02:25 <absence> kuribas: i can, but then i don't get a rigid applicative-like structure where state for each of the members of SomeState is evaluated exactly once
12:03:53 <kuribas> absence: what do you mean?
12:04:16 <kuribas> absence: after inlining etc.. it would be the same as your definition.
12:07:46 <Psychiatrist> Hey. Is there a way to map my own function which has two parameters to a list. Similarly to: map (2*) [1,2,3] I would like: map (myFunction arg1) [1,2,3]
12:08:28 <deank> Psychiatrist what you typed works assuming types match
12:08:50 <absence> kuribas: yes, my example doesn't explicitly contain such a restriction, it was merely applied. both in my code, and using zoom, it would be possible to evaluate the "ia" state, and then evaluate the resulting "oa" state again, and so on, any number of times. or for that matter none at all. on the other hand, with some imagined applicative code SomeState <$> ???a <*> ???b <*> ???c, each would be evaluated 
12:08:56 <absence> once, "in lockstep" sort of
12:09:04 <Psychiatrist> deank: Thanks, I will re-check.
12:09:08 <absence> "it was merely implied" i meant
12:13:36 <ski> @where boolean-blindness
12:13:36 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
12:13:46 <ski> @where algebraic-blindness
12:13:46 <lambdabot> I know nothing about algebraic-blindness.
12:13:51 <ski> @where+ algebraic-blindness https://github.com/quchen/articles/blob/master/algebraic-blindness.md
12:13:51 <lambdabot> It is stored.
12:13:53 <nitrix> Psychiatrist: As long as the second argument of `myFunction` has type `Num a => a` and `arg1` is of the same type expected for the first argument, there's no issue with partially applying `myFunction` like you're doing. It's valid Haskell.
12:14:02 <ski> @where existential-antipattern
12:14:02 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
12:14:14 <ski> @where incremental-parameter-antipattern
12:14:14 <lambdabot> "Haskell anti-pattern: incremental ad-hoc parameter abstraction" by Brent Yorgey at <http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/>
12:14:20 <geekosaur> ...there are other tricks if you want to map the first parameter instead
12:18:05 <ski> (if there some "antipattern" page about abusing type classes ?)
12:18:26 <ski> (er, s/if/is/)
12:22:55 <briansteffens> why would using encode on an Integer produce a ByteString of 5 bytes? https://gist.github.com/briansteffens/27fc3183de809a992f7dbf68057d50b0
12:23:08 <geekosaur> might be better checked with a web search. (although it'd be nice if there were a @where search since we seem to have decided to use it as @fact...)
12:25:30 <nitrix> briansteffens: put n = putWord8 1 <> put sign <> put (unroll (abs n)) -- unroll the bytes
12:26:14 <kuribas> absence: that doesn't work, since you have two type variables in your example.
12:31:53 <geekosaur> briansteffens, basically the default serialization format isn't raw. if you want to serialize for something else to read, you're likely using the Put monad directly. (for raw C stuff, you may want Storable instead)
12:33:15 <nitrix> briansteffens: In your case I think you're using: put n | n >= lo && n <= hi = putBuilder (Prim.primFixed (Prim.word8 Prim.>*< Prim.int32BE) (0, fromIntegral n))
12:33:47 <Liskni_si> is there any way to express a constraint that a type level list is nonempty? I need to write something like "class (Member' t r (FindElem t r), r ~ (x ': xs)) => Member t r where"
12:34:57 <fosskers> Liskni_si, you could try Data.List.NonEmpty
12:35:14 <fosskers> ah, pardon me, I didn't see "type level"
12:35:15 <geekosaur> that's not a type level list
12:36:53 <briansteffens> geekosaur: interesting, what format does it serialize into by default? just found 5 to be a weird number of bytes lol
12:37:24 <geekosaur> my guess would be tagged with a type/format, but that doesn't match what nitrix quoted earlier
12:37:49 <nitrix> geekosaur: It appears if the range fits within a smaller int, it lets bytestring encode it.
12:38:55 <geekosaur> you might want to think of the default as something like python's pickle format, not really intended for anything but decoding by Data.Binary
12:39:27 <nitrix> Otherwise, you'd have 1 byte (for a special prefix) + 1 byte (for the sign) + many bytes dependening on the precision of the Integer.
12:40:21 <nitrix> Which would be 6 bytes :P briansteffens 5 bytes certainly seems better than 6.
12:40:29 <geekosaur> [0,0,0,0,42] is what I got from unpacking it fwiw
12:40:57 <nitrix> You're supposed to get \0 \255 \255 \255 \214
12:41:28 <geekosaur> for 42::Int?
12:41:41 <nitrix> 42 :: Integer
12:41:49 <geekosaur> whoops, right
12:42:06 <geekosaur> oh, I did use Integer for that test
12:47:48 <briansteffens> hmm interesting, thanks guys :)
12:48:04 <nitrix> briansteffens: It's infinite precision, it's hard to not give it an overhead.
12:48:17 <nitrix> briansteffens: But the library does do its best for smaller Integers.
12:48:48 <lpaste> geekosaur pasted “42 :: Integer” at http://lpaste.net/805081779865124864
12:49:29 <nitrix> B.unpack makes little sense to me o.<
12:50:02 <geekosaur> ? should just give me the component Word8-s so I can see what it actually made
12:50:49 <johnw> orzo: not sure exactly...
12:53:28 <nitrix> geekosaur: Nvm you're fine.
12:53:32 <nitrix> geekosaur: I was testing with -42
12:53:38 <geekosaur> heh. that makes more sense
12:53:49 <geekosaur> bit inversion just seemed Wrong
12:54:03 <nitrix> Got entangled in my mess.
12:54:56 <nitrix> B.unpack, I knew I could count on you <3
12:54:58 <jackhill> Hi, I'm playing around with the units package, but am not quite sure what I'm doing, can someone point me in the right direction?
12:55:17 <jackhill> I have the following code http://lpaste.net/350878 where I set up some units, and then try to create a test value
12:55:25 <jackhill> the error is http://lpaste.net/350879
12:55:38 <jackhill> without the testValue declaration, it compiles
12:56:54 <geekosaur> jackhill, you probably need to qualify that operator; you're getting
12:56:58 <geekosaur> :t (%)
12:57:00 <lambdabot> Integral a => a -> a -> Ratio a
12:57:15 <geekosaur> or you used the wrong operator
12:59:23 <jackhill> so the import would not have overridden the one from Prelude?
12:59:43 <geekosaur> actually I'd expect an error because it doesn't know which one to use
13:00:33 <absence> kuribas: yeah, i know it's not exactly an applicative, or monad for that matter. that's why i wonder if such a structure, or similar, exists :)
13:02:13 <jackhill> geekosaur: indeed, I updated to http://lpaste.net/350878 and get the same error
13:02:22 <geekosaur> oh, hm, lloking at its type, you may be getting the right one after all. 
13:10:57 <geekosaur> not seeing it yet. I will note that the import is better written "import Data.Metrology.Poly as MP" instead of twice like that
13:15:40 <jackhill> geekosaur: noted :)
13:24:48 <EvanR> is there a rule of thumb for how much of a speedup you get from church encoding 
13:26:06 <jonascj> Having a go at xmonad-testing (https://github.com/xmonad/xmonad-testing) with some modifications to the build process. Right now with "cabal new-build" the executable lands in a 'dist-newstyle/.....". How can I specify in cabal.project or xmonad-testing.cabal specify another dir? Someone mentioned a "bindir: /where/ever" option, and the manual talks about a --bindir command line option as well. But I 
13:26:12 <jonascj> can't seem to fit it into either of those two files. Any hints?
13:26:43 <geekosaur> jonascj, I have to wonder how many times I have to say *install* not *build*
13:27:05 <geekosaur> the build targets always produce artifacts under dist/ which are of limited use for anything other than testing
13:27:23 <geekosaur> (this started some 12 hours ago in #xmonad)
13:27:39 <geekosaur> build and new-build do not do what you want.
13:28:38 <jonascj> geekosaur: the xmonad-testing readme says "cabal new-build" which works fine for its intended purpose (that closed xmonad-testing distribution)
13:29:46 <geekosaur> yes, it's expecting you to use the run-in-xephyr to run a testing setup from the build directory, which will mostly work
13:29:50 <jonascj> so that is why I continued to think along those lines. You might remember I'm out of the sandbox approach
13:29:52 <geekosaur> what will not work is a global session
13:30:03 <geekosaur> also you still will not get libraries in the right place if you only do build and not install
13:30:16 <geekosaur> if you are using new-* then you are sandboxed
13:30:24 <geekosaur> (likewise if you use stack)
13:30:24 <dgpratt> what's everyone's favorite XML parsing library these days? my use case is quite simple; I was thinking of something that works like aeson, but I'm not stuck on that idea
13:31:38 <geekosaur> and, sandbox or not, the build artifacts under dist/ only work right when used from the project directory... which for a global xmonad session means you get to change your login directory to that
13:32:02 <geekosaur> (again. xmonad-testing is set up for testing sessions under xephyr, not a user login session)
13:32:26 <codedmart> I am trying to take two text values I get `"0.03000" "3.46000"` and add them. I am use readMaybe to turn them into Double, but the result rather then `3.49000` I get `3.4899999999999998`?
13:32:46 <geekosaur> codedmart, it's called IEEE floating point
13:32:47 <jonascj> right, that is its purpose. I'll think on that global session vs. jsut the test environment again.
13:33:52 <geekosaur> jonascj, if you are using it for a user login session, you *must* use the install targets, not the build targets
13:34:01 <codedmart> geekosaur: Ah right
13:34:12 <codedmart> Hmm... what are my best options for this?
13:34:36 <geekosaur> possibly just using Text.Printf or the formatted numeric output routines in the Numeric module
13:34:57 <geekosaur> > printf "%.5f" 3.4899999999999998 :: String
13:35:01 <lambdabot>  "3.49000"
13:38:47 <dmwit> > 0.03 + 3.46 :: Rational
13:38:50 <lambdabot>  349 % 100
13:39:55 <dmwit> > 0.03 + 3.46 :: Data.Fixed.Fixed E2
13:39:58 <lambdabot>  3.49
13:40:23 <dmwit> depends a lot on what your goals are, I guess
14:08:35 <jackhill> geekosaur: I figured it out http://lpaste.net/350878 The type holding the numerical value in needs to have a Fractional instance
14:08:54 <jackhill> I think this is needed for unit conversion to work
14:23:07 <wespiser> is anyone here using Lens in production?
14:23:17 <Tuplanolla> Most likely, wespiser.
14:23:24 <newsham> now that someone's written python compiler in golang...  when's the haskell golang runtime gonna be done? :)
14:24:21 <Koterpillar> newsham: just adapt ghcjs + pyv8
14:24:48 <Wizek_> Hello! Can a Functor/Applicative instance be defined such that `((+1), (+2)) <*> (3, 4) == (4, 6)`
14:24:51 <Wizek_> ?
14:25:27 <glguy> Wizek_: Not on the (,) type, but on something like: data Two a = Two a a, then yes
14:25:58 <Tuplanolla> :t Join
14:26:00 <lambdabot> error:
14:26:00 <lambdabot>     • Data constructor not in scope: Join
14:26:00 <lambdabot>     • Perhaps you meant variable ‘join’ (imported from Control.Monad.Writer)
14:26:05 <pyon> What about Bifunctor/Biapplicative?
14:26:09 <pyon> Would that work?
14:26:15 <Tuplanolla> Looks like someone undefined it again.
14:26:24 <pyon> I mean, for the kind of thing Wizek_ was asking for.
14:26:56 <Tuplanolla> It can be done via `Bifunctor` too, pyon. You just `join bimap`.
14:28:59 <pyon> > ((+1), (+2)) <<*>> (3, 4)
14:29:01 <lambdabot>  error:
14:29:01 <lambdabot>      Variable not in scope:
14:29:01 <lambdabot>        (<<*>>)
14:29:58 * nitrix nuzzles pyon. Are you coming back to Haskell :D ?
14:31:32 <pyon> nitrix: Dunno even myself. It's nice for small things, but no hierarchical modules really hurts. :-|
14:32:30 <nitrix> Can't you achieve similar results with re-exports?
14:33:06 <nitrix> e.g. Control.Lens
14:34:10 <pyon> nitrix: Can you reexport a qualified name?
14:34:28 <ezyang> pyon: No, sorry :( 
14:34:33 <pyon> (Without having to re-quality at import site.)
14:35:57 --- mode: ChanServ set -qq *!*@gateway/web/freenode/ip.72.43.138.234 *!*@*/ip.198.7.62.204
14:36:04 <Tuplanolla> What's the `lens` way to modify a value in a `Map`, if present?
14:36:16 <glguy> over (ix theKey)
14:36:29 <geekosaur> hm? thought you could reexport qualified names, they just end up qualified (if at all) as if defined in the reexporting module?
14:37:12 <geekosaur> that is, you can't reexport a name *with its qualification*
14:37:14 <Wizek_> pyon, Bifunctor/Biapplicative may work. Although I do wonder why regular old Applicative instance couldn't be defined like `(f, g) <*> (a, b) = (f a, g b)`
14:37:35 <glguy> Wizek_: The kinds don't work out for that instance
14:37:35 <pyon> Wizek_: Because a Functor can only vary over one type.
14:37:50 <pyon> Wizek_: But (,) has two type arguments, and you want something that varies over both.
14:38:07 <Tuplanolla> Oh, so that explains `record . ix key %~ f`, glguy.
14:38:26 <Tuplanolla> Very good.
14:39:18 <pyon> ((+1), (+2)) Data.Biapplicative.<<*>> (3, 4) -- If this doesn't work, could someone add Data.Biapplicative to lambdabot's imports? I don't remember the syntax.
14:39:20 <nitrix> Wizek_: The kind of Applicative has to be `* -> *`.
14:39:22 <pyon> Errr.
14:39:22 <Wizek_> Hmm. Interesting. And could a variadic-kinded functor class be defined such that it would work on Functors and Bifunctors alike, perhaps?
14:39:27 <pyon> > ((+1), (+2)) Data.Bifunctor.<<*>> (3, 4)
14:39:30 <lambdabot>  error:
14:39:30 <lambdabot>      Not in scope: ‘Data.Bifunctor.<<*>>’
14:39:30 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
14:39:38 <pyon> > ((+1), (+2)) Data.Biapplicative.<<*>> (3, 4)
14:39:40 <lambdabot>  error:
14:39:40 <lambdabot>      Not in scope: ‘Data.Biapplicative.<<*>>’
14:39:40 <lambdabot>      No module named ‘Data.Biapplicative’ is imported.
14:39:54 <geekosaur> @let import Data.Biapplicative
14:39:57 <lambdabot>  Defined.
14:40:06 <pyon> > ((+1), (+2)) <<*>> (3, 4)
14:40:08 <pyon> geekosaur: Thanks!
14:40:08 <lambdabot>  (4,6)
14:40:23 <Wizek_> pyon, there we go :)
14:40:55 <pyon> Wizek_: I'm not familiar enough with poly-kinded stuff to tell whether you can define what you want. :-(
14:41:02 <pyon> Wizek_: But, in any case, it's probably not worth the complexity.
14:41:02 <nitrix> Wizek_: I think you could with Proxy magic.
14:44:13 <nitrix> It's poly-kinded, and then you add the recent TypeInType madness :P
14:44:16 <EvanR> on the subject of knowing whether a polynomial has a root or not in some interval, i found sturm's theorem and other methods based on decartes rule of signs
14:46:21 <codedmart> geekosaur: Is there anyway for me to get that printf value as a double in the json when I encode it?
14:46:47 <geekosaur> I think you'd need a custom ToJSON instance
14:47:46 <EvanR> whoa... printf output in the json as a number... my world is warping
14:47:55 <dfeuer> codedmart: IIRC there are some functions available to help you build a ToJSON instance with some modifications.
14:48:20 <EvanR> aeson numbers are Scientific now, so you have to go through that not text
14:49:08 <EvanR> double -> printf -> text -> parse -> scientific
14:49:25 <monochrom> geekosaur: Regarding re-exports, "module X(M.fromList) where { import [qualified] Data.Map as M }" is not going to result in "X.M.fromList". It will be only known as "X.fromList".
14:49:46 <geekosaur> yes, I thought that was what I said
14:49:50 <codedmart> EvanR: What do you  mean your world is warping?
14:49:56 <monochrom> OK neato.
14:50:21 <geekosaur> EvanR, the question was how to get it to round away FP fuzz in the low bits
14:50:42 <monochrom> In fact if you look at just the spelling "X.M.fromList" you would think that it means there is a "module X.M where ..." instead.
14:51:12 <codedmart> geekosaur: OK I think I have it working actually. Thanks for your help!
14:51:51 <monochrom> Now this is interesting because this was a design decision long before people thought of dotted module names.
14:52:57 <EvanR> geekosaur: isnt that a function of printf formatting
14:53:38 <monochrom> I mean back in 1998 or before, why didn't they allow "module X(List.elem, Map.elem)" and let you use "X.List.elem" and "X.Map.elem"? Why did they call it an error?
14:54:46 <geekosaur> presumably so you could migrate from an older module name to a newer one by reexporting
14:55:24 <ij> What's the difference between, say Megaparsec.Lexer.symbol and .Char.string?
14:56:17 <glguy> ij: did you look at the documentation for the two?
14:56:23 <ertes> helo
14:57:49 <glguy> 501
14:57:59 <EvanR> codedmart: i just was forced to comprehend printf output, which is text, as json, which i dont usually think of as text, but... it pretty much is
14:58:03 <EvanR> breaking the 4th wall
14:58:21 <codedmart> Ah I get it :)
14:58:37 <EvanR> the difference between concrete and abstract syntax as data
15:00:40 <monochrom> ertes: You should say "ehlo" next time so glguy is forced to perform an encryption :)
15:01:04 <monochrom> wait, is ehlo for encryption? or just an extended mail protocol?
15:01:12 <geekosaur> just extensions
15:01:30 <geekosaur> encryption being one of those potentially, but it has to be negotiated afterward :)
15:01:37 <monochrom> Ah Internet is too hard, I need a drink.
15:03:51 <Liskni_si> fosskers, geekosaur: Just FYI, the answer to my question is "r ~ (Head r ': Tail r)" (where Head, Tail are closed type families with an obvious impl)
15:05:24 <fosskers> Liskni_si, cool, I'm glad you found a solution
15:05:37 <ij> glguy, Okay, I looked at the source. Those combinators are dumb.
15:05:51 <ij> In the «simple», not «stupid» sense.
15:19:25 <Zowlyfon> Hi, i'm getting invalid package id from stack
15:19:31 <Zowlyfon> but I don't on my other machine
15:21:42 <kadoban> Zowlyfon: What version(s) are you using?
15:21:50 <Zowlyfon> I just did stack upgrade --git
15:22:17 <Zowlyfon> after installing the ubuntu package
15:25:33 <Zowlyfon> I may have found my own issue
15:25:44 <Zowlyfon> it looks like the stack on my path was not the stack I needed to use
15:25:56 <Zowlyfon> I called ~/.local/bin/stack and its working
15:27:00 <Tuplanolla> I have a situation where code fails to compile, but works fine with `-fdefer-type-errors`.
15:27:14 <EvanR> nice
15:27:20 <Tuplanolla> It's not fun.
15:27:23 <EvanR> i really like that feature
15:27:42 <EvanR> haskell is the best dynamic language ;)
15:27:57 <Tuplanolla> I mean I can't trigger the compile error at runtime even if I try.
15:28:39 <ggVGc> well... there are correct programs that can not be expressed within a static type system..
15:28:55 <ggVGc> afaik
15:29:11 <ggVGc> I guess depending on the definition of static type system...
15:29:21 <EvanR> within haskells system, definitely
15:29:48 <EvanR> coming to a sense of what that even means is a great lesson of haskell
15:30:39 <mckeankylej> I am defining my own list data type. Does anyone know what the operator precedence of (:) is?
15:31:04 <ski>   infixr 5 :
15:31:12 <mckeankylej> ski: thanks!
15:31:15 <Koterpillar> :i (:)
15:31:48 <ski> (you can ask the interactor with `:i :'. but lambdabot doesn't understand `:i' (nor `@info', which doesn't exist))
15:31:52 <ski> @info (:)
15:31:53 <lambdabot> (:)
15:32:11 <mckeankylej> ah that is super useful I tried :i [] but not (:)
15:32:30 <ski> oh, i see, `:i (:)' also works
15:36:33 <monochrom> @info do { x <- y; x }
15:36:33 <lambdabot> y >>= \ x -> x
15:36:42 <monochrom> That's "info" for you :)
15:36:48 <monochrom> P.S.
15:36:55 <monochrom> @stab monochrom
15:36:55 * lambdabot smacks monochrom about with a large trout
15:39:56 <lpaste> Tuplanolla pasted “Bogus Error” at http://lpaste.net/350884
15:40:00 <Tuplanolla> Can someone explain this?
15:41:08 <glguy> Tuplanolla: You likely have too many versions of containers installed
15:41:51 <Tuplanolla> How is that even possible? Don't answer. I'll investigate.
15:42:14 <geekosaur> the microlens package has an instance for a Map from a different containers package
15:43:48 <Tuplanolla> They're not listed by `ghc-pkg`.
15:44:39 <c_wraith> Tuplanolla, my read is that microlens only even has two instances for Ixed
15:44:47 <c_wraith> Tuplanolla, and neither are for Map
15:45:01 <geekosaur> ..just saw that also
15:45:08 <Tuplanolla> The code works in GHCi with `-fdefer-type-errors`, c_wraith.
15:45:29 <Tuplanolla> Some instance is in there doing the work.
15:45:36 <mckeankylej> If I have a gadt kind signature like this data SVec :: forall (n :: Nat). Vec Type n -> Type where {..} is there some way to give a newtype the same kind siganture? Like this newtype SVec forall (n :: Nat). Vec Type n -> Type = SVec {...}. Btw type in type is awesome.
15:47:53 <c_wraith> Tuplanolla, I'd call that more of a bogus success than a bogus error. 
15:49:05 <hexagoxel> Can i get `Dict (C a)` out of `data Foo = forall a . C a => Foo (something a)` ?
15:49:26 <Tuplanolla> Does the code not make sense, c_wraith?
15:50:13 <glguy> hexagoxel: I'd expect so. You couldn't let it escape the point at which you matched the "Foo" constructor without again hiding its type, though
15:51:07 <ggVGc> all programming is largely bogus anyway
15:51:09 <ggVGc> so what does it matter
15:51:54 <c_wraith> Tuplanolla, that code is clearly using Ixed on a Map, and the library doesn't provide that instance. 
15:52:18 <Tuplanolla> It did yesterday!
15:52:24 <c_wraith> Tuplanolla, so the error message from ghc seems pretty correct. 
15:53:08 <glguy> hexagoxel: Given: data Foo = forall a.  Show a => Foo [a];     (\(Foo (xs :: [a])) -> let d :: Dict (Show a); d = Dict in ())  ::  Foo -> ()
15:53:59 <c_wraith> Tuplanolla, it can't provide that instance. the library doesn't depend on containers. 
15:54:41 <Tuplanolla> It's here, so I must've screwed up some imports or dependencies: https://hackage.haskell.org/package/microlens-ghc-0.4.7.0/docs/src/Lens.Micro.GHC.html#line-105
15:55:18 <c_wraith> ah, I was looking at the microlens package, not microlens-ghc
15:55:47 <c_wraith> Tuplanolla, looks like it's an orphan instance package. 
15:56:04 <geekosaur> you'll need to import that module, then
15:56:14 <ertes> monochrom: well, of course i could request an encrypted login =)
15:56:32 <c_wraith> orphan instance packages play hell on your sanity. 
15:56:40 <Tuplanolla> Yes, that works, thanks. For some reason I expected it to be imported already.
15:57:23 <c_wraith> there's a reason why edwardk avoids them. (and hence why lens has a million dependencies) 
16:00:22 <Tuplanolla> Do I want to spend hours swapping or chasing orphans?
16:01:05 * geekosaur is actually fine with the idea of modules that contain orphans... if that's *all* they do
16:01:13 <geekosaur> because the insanity can be contained
16:02:20 <hexagoxel> glguy: how stupid of me not to think of that. thanks!
16:06:56 <dpren> With stack is there a way to quickly see which package depends on the lowest resolver version?
16:11:17 <glguy> Packages don't depend on resolvers, what're you trying to figure out?
16:15:30 <dpren> glguy: my resolver is set to lts-6.15, and I want to use the latest Turtle package which is lts-7.14   https://www.stackage.org/package/turtle
16:16:55 <dpren> glguy: and I can't remember why I set it to 6.15 - presumably due to an older package I'm using?
16:17:20 <Koterpillar> dpren: you don't have that many versions to test ;)
16:17:24 <glguy> Only you could know
16:18:29 <jonascj> geekosaur: good news, I'm finally running xmonad-git, so no more questions regarding that issue for now. Thank you for helping me out. It also solved the strut issue I was having, like you and many others thought it would.
16:22:13 <erisco> is there a way to use type aliases or newtypes in data families?
16:22:38 <glguy> The answers are probably "no", and "new"
16:22:45 <glguy> no and yes*
16:23:02 <Tuplanolla> Someone needs a nap.
16:24:56 <erisco> newtype instance  okay
16:38:49 <qmm> class MyMath a where sub :: a -> a -> a ; add :: a -> a -> a; instance MyMath Int where sub x y = x - y ; add x y = x + y
16:38:52 <qmm> what is wrong with this
16:39:01 <qmm> i'm sure there's a lot wrong with it :)
16:39:18 <qmm> i just realized i've never sat down and created my own typeclass 
16:39:31 <qmm> i usually just read them or if i create one, it's from some tutorial
16:39:40 <geekosaur> nothing obvious wrong there to me
16:39:46 <qmm> well, i have created my own typeclass, but it's been awhile
16:39:48 <Koterpillar> qmm: state its laws
16:39:58 <geekosaur> @paste actual code (in case it's indentation or something) and usage and resulting error?
16:39:58 <lambdabot> Haskell pastebin: http://lpaste.net/
16:41:42 <Squarism> im curious how one learns to be a better functional/haskell programmer focusing on non-scientific / abstract problems. Examples, make well structured and reusable webapps with GHCJS/Elm. Games. "Enterprise applications" etc. Focus on time efficiency / lack of repitition. 
16:42:44 <Squarism> Ive found that i tend to repeat myself more often in pure functional land because of some bad wierd tendency of rather writing similar functions instead of finding bits that i can reuse
16:43:05 <Squarism> non-scientific / non-abstract problems
16:45:20 <lpaste> qmm pasted “No title” at http://lpaste.net/350885
16:46:21 <Koterpillar> qmm: AFAIK typeclasses don't direct the type resolution
16:46:28 <qmm> maybe that should be main = print $ sub 2 2 :: Integer
16:46:37 <Koterpillar> qmm: so because 2 :: Num a => a, it can't figure out its concrete type
16:46:42 <glguy> You'll need parentheses
16:46:55 <glguy> print $ sub 2 2 :: IO (), but  print (sub 2 2 :: Int)
16:47:28 <jchia> I have a graph with which I want to perform some IO at run-time. The graph is known at compile-time. I want to express the graph in terms of a sequence of operations comprising adding vertices, adding arcs, and removing vertices, so certain operations are invalid (e.g. removing non-existent vertices or adding duplicate vertices). How can I make ghc check my graph operations at compile and convert it into a more regular representation like an adjacency list tha
16:47:53 <qmm> interesting
16:48:05 <qmm> i always thought you could remove the parens with $
16:48:40 <Koterpillar> qmm: apparently the type annotation has priority
16:48:56 <Koterpillar> and I can't look up its fixity with :i (::)
16:49:21 <glguy> :: is part of the syntax of Haskell, it's not an operator symbol
16:50:09 <Koterpillar> well, it can occur within expressions and all, so it must have some priority in the grammar
16:50:18 <Koterpillar> 2 :: Int + 2 :: Int :: Int
16:50:39 <Koterpillar> ...with some brackets
16:50:41 <glguy> Sure, it's part of the grammar, but it's not something that makes sense to inspect with :i
16:51:23 <qmm> is there a way to write print (sub 2 2 :: Int) without the parens?
16:51:50 <glguy> Not without defining some other helper function. There's no reason to avoid the parentheses anyway
16:52:21 <Koterpillar> qmm: let value = 2 + 2 :: Int in print value
16:52:28 <Koterpillar> well, sub
16:52:36 <qmm> i always though print (some_val) could always be turned into print $ some_val
16:52:38 <erisco> Squarism, *shrug* don't do that then ^.^
16:53:37 <ertes> jchia: your best bet is TH
16:53:45 <ertes> jchia: or rather your safest bet
16:53:47 <erisco> challenge yourself to write the solution only using functions you can find on Hoogle
16:54:41 <erisco> avoid writing any recursion or pattern matches
16:55:16 <jchia> ertes: I've used TH a few times and find it quite unwieldy. Are there other options?
16:55:20 <qmm> print v where v = sub 2 2 :: Int
16:55:24 <qmm> thanks everyone
16:55:28 <ertes> jchia: alternatively you could try rewrite rules or aggressive inlining, but firstly that doesn't play too well with the imperativeness, secondly you would basically have to reinvent haskell evaluation to some extent in the form of rewrite rules
16:56:32 <ertes> jchia: TH is not that bad for this kind of thing…  you just have to anti-quote a few things compared to regular code
16:57:44 <qmm> i think haskell is useful and practical. 
16:57:48 <Squarism> erisco, ok.. so let me express it in a different way : I find it harder (maybe tools, maybe languages) to do reuse in FP than in OO. Its like.. "-What the hell, its just an fmap + case clause and then ill be done with it." As i have no proper IDE - Trying reuse i browsing through files of 500 loc to find an interresting function
16:58:01 <hpc> a bit late but wrt the fixity of "::" syntax, parsing doesn't have a built in concept of precedence at all
16:58:21 <ertes> Squarism: every time you use 'foldr' you do FP-style reuse
16:58:32 <qmm> do others here think haskell is a difficult language to learn?
16:58:32 <Squarism> Trying reuse comes down to browsing through... even
16:58:57 <qmm> i feel that it's pretty simple, but there might be a lot to learn initially
16:59:08 <Koterpillar> qmm: remove either "here" and "difficult"
16:59:12 <Koterpillar> qmm: *remove either "here" or "difficult"
16:59:29 <erisco> Squarism, well it is a matter of knowing the common tools. These include Functor, Applicative, Monad, Monoid, folds, unfolds, fix, maybe Arrow
16:59:29 <ertes> qmm: learning haskell is actually not too difficult, but remember that most people need to *unlearn* some stuff when coming to haskell
17:00:02 <erisco> Squarism, composition i.e. (.) of course
17:00:03 <hpc> qmm: it's perhaps also that haskell has a very long tail for learning
17:00:20 <qmm> hpc: that's a great point
17:00:24 <hpc> coming from python, perl, and javascript, you could learn php in a day or two
17:00:26 <erisco> Squarism, it is few tools that solve a whole lot of problems
17:00:27 <hpc> there's really not much there
17:00:31 <qmm> ertes: i certainly did
17:00:38 <c_wraith> qmm, haskell was easily the most difficult language for me to learn in about... Uh... 30 years. but after learning it, I see that it's mostly simple concepts. enough of them were just actually new that it took me a while. 
17:01:01 <qmm> c_wraith: hah :)
17:01:12 <hpc> similarly for haskell, while it takes longer to learn initially most of the time (few people have heard of the ML language family)
17:01:17 <qmm> c_wraith: how can i convince a company to use haskell with statements like that ;)
17:01:20 <hpc> you can get up to php-level knowledge rather quickly
17:01:26 <hpc> and then keep on going for the rest of your life
17:01:27 <erisco> Squarism, for cases you are looking for the Scott encoders particularly "maybe", "either", "bool", etc
17:01:34 <ertes> qmm: i was one of the slower haskell learners (it least it felt that way), but before haskell programming to me was giving instructions to the machine
17:01:45 <hpc> this is part of what people mean when they say learning haskell makes you a better programmer
17:02:09 <c_wraith> qmm, that's the testimonial you use to convince your coworker who is always looking for a challenge. not the one to pitch to management. :) 
17:02:13 <hpc> (in addition to the general idea that knowing more languages is better than knowing fewer, etc etc)
17:02:44 <erisco> Squarism, you might think about doing case analysis. I might think about using an Applicative or Monad or Monoid instance, for example
17:02:51 <Squarism> erisco, sure, i reause all of the standard libraries. And i compose and "reuse" them. But im talking about reusing my own code. Extract functions / similarities / least-common-parts. With a +10k LOC project wo an IDE its just not very straight forward
17:02:53 <hpc> the pitch to management is something along the lines of galois' success with the language
17:03:01 <hpc> or jane street's success with ocaml, which is similar
17:03:26 <ertes> Squarism: the art of reuse in haskell is the art of recognising recurring patterns, which isn't always straightforward, because sometimes things that look very different are actually very similar, and it takes some equational reasoning to see that
17:03:36 <erisco> Squarism, well that is why you design your own programs like the standard libraries are designed
17:03:58 <erisco> Squarism, make Applicatives and Monads and Monoids, Groups, whatever you can
17:04:38 <ertes> Squarism: unlike e.g. in OO where reuse amounts to just libraries (you reuse code every time you import a module twice in that sense)…  you create an object class and reuse it…  that's all the reuse OO offers
17:04:38 <erisco> if you want good code then it needs some mathematical elegance. What are your identities? is it associative, commutative? are there some monoid homomorphisms?
17:04:54 <Squarism> erisco, do you have an example of "a program designed like a standard library" available?
17:05:00 <erisco> if you think along these lines then you'll be designing in such a way that things plug together as conveniently as the standard stuff does
17:05:22 <hpc> the usual example of a well designed package is pandoc
17:05:36 <jchia> ertes: What do you mean by rewrite rules? Actually, it's not that imperative -- I just  need to define 1. initial vertices 2. arcs 3. vertices to finally drop.
17:05:45 <hpc> which is structured as a common core that can use multiple parsers and printers
17:06:01 <Squarism> hpc, ok.. ill check that out
17:06:17 <ertes> jchia: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules
17:06:27 <erisco> Squarism, I am doing a fair amount of work to Data.Set so that intersection has an identity and so that I can then define Relation with a Category instance
17:07:24 <ertes> jchia: i don't recommend this approach though…  it's difficult to understand and control
17:08:50 <ertes> Squarism: pandoc is a practical example of…  do you remember the hangman exercise i gave you?  one common core language, many ways in, many ways out
17:09:42 <ertes> pandoc is the same thing, although the common core is just a basic AST-like type
17:10:29 <jchia> ertes: Yeah, looks messy.
17:12:19 <ertes> jchia: alternatively just don't bother, if it increases your program's startup time by only 5 ms
17:15:24 <Squarism> ertes, ofcourse i do. And in that very project i just discovered i had 3 snippets of code to remove "pieces" from, the now-not-hang-man-but-boardgame, board. I attribute that to part lazyness, part a lack of an IDE that could help 1. to extract those nested snippets. 2. to find functions applicable
17:16:29 <Squarism> But i guess its just me that havent learned how to be effective about writing FP code wo an IDE
17:20:02 <ertes> Squarism: well, why don't you just get an IDE, if you want one? =)
17:20:19 <ertes> Squarism: but i'm not sure what difference it would make in this regard
17:25:04 <Squarism> I hoped it could deliver all the refactoring support and code navigation i had in java/intellij land. I do miss that, not the language though. 
17:26:03 <Squarism> or i must learn that my gameworld is an in fact an Applicative Monoid or something.
17:27:15 <ertes> Squarism: you will get code navigation, but the refactoring support in haskell comes more from the compiler than the editor
17:27:49 <ertes> if you add a constructor to a type, quickly jump to all the places that need to be changed
17:31:11 <erisco> there are some less intuitive things to relearn as well
17:31:31 <erisco> for example, how might you print "Hello Sailor!" 10 times?
17:32:09 <hpc> :t arr
17:32:09 <erisco> we might be thinking of our for loops and counters
17:32:11 <lambdabot> Arrow a => (b -> c) -> a b c
17:32:36 <hpc> (tragically arr isn't actually useful there)
17:33:04 <erisco> but in FP we can be more lax. What would be normally do if we wanted 10 of something? Probably replicate 10
17:33:34 <erisco> the key being that printing "Hello Sailor!" is a thing, a value, not just a side effect, so we can have 10 of those if we want
17:33:46 <erisco> a list of type [IO ()]
17:33:56 <erisco> then we sequence_ and we're done
17:34:44 <ertes> memorising something like replicateM_ requires a bit more of a haskell mindset though, but you get used to it
17:35:06 <ertes> usually when i need something from an API that i'm not familiar with i'll know what word to search for
17:35:53 <ertes> that's why i'll search for "mapM" or "replicateM" in Data.Vector.Storable
17:35:58 <erisco> you wouldn't dream of allocating an array of 10 function pointers and then… iterating the array and calling the functions? crazy
17:36:44 <ertes> of course you can *always* just write the recursive function and emulate the for-loop, then (since you used explicit recursion) show the code to #haskell =)
17:37:07 <ertes> that's a quick way to find abstractions for what you're doing
17:38:05 <erisco> #haskell the fixed point finder
17:44:03 <lpaste> tippenein pasted “interpret kind error” at http://lpaste.net/350886
17:44:14 <tippenein> curious how to interpret this error - Expected kind ‘* -> * -> *’, but ‘Get’ has kind ‘[*] -> * -> *’
17:46:32 <ski> tippenein : apparently `Get' doesn't fit in that hole
17:47:15 <geekosaur> "type" mismatch, but at kind level. I have no idea what Paginate is, or Get for that matter, so can't say much else
17:47:27 <ski> (`Get' expects a list of (concrete) types as first argument, but `Paginate' insists on feeding its callback argument in that position a single (concrete) type, not a list)
17:54:32 <slaterr> how can I turn Maybe (IO ()) into IO whatever?
17:54:33 <erisco> type lists… must be some fun code
17:54:50 <erisco> :t maybe -- slaterr
17:54:52 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:55:00 <slaterr> fmap hClose maybeHandle <- I got it like this, perhaps I missed on this step as well
17:55:32 <erisco> :t maybe (return ()) id -- for example
17:55:34 <slaterr> :t maybe (return ()) hClose
17:55:34 <lambdabot> Monad m => Maybe (m ()) -> m ()
17:55:36 <lambdabot> error:
17:55:36 <lambdabot>     Variable not in scope: hClose :: a -> m ()
17:56:03 <slaterr> nice
17:56:33 <erisco> maybe you'd be more interested in MaybeT IO
17:56:35 <slaterr> hMaybeClose is a good name? 
17:56:51 <slaterr> erisco not sure? I am closing Maybe Handles I got from createProcess
17:57:22 <erisco> *shrug* up to you. If you're doing this sort of thing a lot then the monad transformer may be more convenient
17:57:54 <tippenein> ski: so I can't specify that it's a type list in the Paginate type alias?
17:57:59 <erisco> you might use the Maybe Monad as well
17:58:11 <slaterr> how
17:58:28 <erisco> fmap hClose
17:58:56 <slaterr> that gives me  Maybe (IO ())
17:59:01 <slaterr> that is what I started with
17:59:02 <lpaste> tippenein revised “interpret kind error”: “interpret kind error” at http://lpaste.net/350886
17:59:10 <erisco> yes
17:59:14 <erisco> and you keep going with it
17:59:25 <slaterr> hmm
17:59:41 <erisco> you would probably use do-notation to make it more palatable
18:00:17 <slaterr> do stdin <- maybeStdin; stdout <- maybeStdout.. ?
18:00:40 <slaterr> if one fails I still need to close others though
18:00:49 <slaterr> so I can't see how do would be useful
18:00:51 <ski> tippenein : try replacing
18:00:53 <ski>   c cts (PaginatedResponse a)
18:00:55 <ski> by
18:01:03 <ski>   c '[cts] (PaginatedResponse a)
18:01:04 <ski> ?
18:01:48 <tippenein> yeah, it doesn't let you do that. invalid syntax
18:02:47 * geekosaur wonders if this is missing an extension somewhere, PolyKinds maybe?
18:03:54 <ski> tippenein : did you enable `DataKinds' ?
18:04:38 <tippenein> yes
18:04:41 <ski> (shouldn't be `PolyKinds', from what i see)
18:04:54 <geekosaur> I'd expect that to fail much worse without DataKinds
18:05:28 <tippenein> if I rewrite it as type Paginate c cts a = .... :> c '[cts] (PaginatedResponse a)
18:05:32 * ski tries to spoof it
18:05:36 <tippenein> it compiles.. don't know if it works yet tho
18:07:49 <tippenein> eh... false alarm. Still same problem
18:11:07 <tippenein> heh, PolyKinds allows it to compile as well
18:11:32 <Lokathor> is there a library for accessing vectors as if they were dynamically sized, and having them re-allocate if you run off the end?
18:11:46 <Lokathor> basically, like how the ArrayList works in various languages
18:18:24 <tippenein> thanks ski and geekosaur. polykinds did it. Now I'll have to go read about what just happened
18:23:57 <pie_> you guys know any guides or such for reimplementing a C project in haskell?
18:24:11 <pie_> or like, well resources that would help with somethig like that
18:26:41 <Squarism> ertes, erisco thanks for input! (got an ide here id show you a file a code to illustrate my issues. Then thought i show you my project. Then started to reorganise it into fubar...) Ill digest the input you given
18:26:55 <Squarism> of code
18:28:15 <Squarism> ...
18:29:14 <Squarism> im using stack. Anyone know how to set "CWD" when executing stack commands (like stack exec)
18:29:20 <Squarism> ?
18:31:06 <ertes> pie_: yes: pretend it's a new project
18:33:23 <geekosaur> Squarism, run a script. or stack exec -- sh -c 'cd ...; whatever'
18:35:03 <pie_> ertes, i guess
18:35:57 <pie_> ertes, i suppose the question is "not even wrong" but what if i want to do so specifically for the purpose of looking for bugs/bad things/whatever in the original codebase?
18:39:18 <ertes> pie_: good question…  if you do it in haskell, chances are that the code will look quite different and that you'll focus on entirely different details…  i'd find it more likely that you will just fix bugs unconsciously
18:39:30 <pie_> yeah makes sense
18:39:58 <pie_> though i still wonder if there would be some way to "compare" the two
18:40:02 <pie_> *two implementations
18:40:11 <ertes> for example you won't discover a pointer bug or buffer overflow by rewriting it in haskell, but you might find a bug in your higher-level application logic
18:40:39 <ertes> in which case it may be apparent, just because you thought of the problem again, not particularly because you reimplemented it in haskell
18:41:26 <ertes> one reason you might be more likely to find logic bugs is that you can express your logic on a much higher level in haskell
18:41:45 <pie_> right
18:42:29 <ertes> also because you can actually inform the compiler of your logic…  C is completely oblivious to anything that goes beyond memory operations
18:42:35 <exio4> ertes: I'd say having to rethink the program is a big plus, otherwise you'd map bugs from one implementation to the other =P
18:42:35 <pie_> right
18:42:52 <pie_> exio4, cant quickcheck c (or whatever) :P
18:43:00 <pie_> well i guess you can still fuzz it thoguh
18:43:02 <ertes> can't really type-check C either =)
18:43:09 <pie_> yeah
18:43:22 <ertes> C is in a sense closer to an untyped language than something like python
18:43:40 * pie_ ponders if its even worth it assuming that the C implementation will remain the main implementation vs just fuzzing it
18:44:03 <pie_> i mean i guess fuzzing wont give you the rethingkinf/high level overview
18:44:18 <exio4> I mean, imagine rewriting some program X written in C#, in Java, you might copy (without realizing) some algorithm or code which is completely wrong - but looks right
18:44:30 <ertes> pie_: writing an intelligent fuzzer actually requires higher-level knowledge of the application logic, so it might
18:44:30 <pie_> sure
18:44:38 <pie_> hm i guess
18:45:04 <pie_> well i mean afl is kind of just fire and forget no? :P
18:45:20 <pie_> though i suppose you need to instrument the code once networking gets involved and stuff
18:45:35 <ertes> after all quickcheck is just a fuzzer, too, but it's smart enough to generate *interesting* examples, or at least you can teach it to
18:46:01 <pie_> yeah
18:46:13 <pie_> (i dont actually know anything about quickcheck just heard a few things)
18:46:56 <ertes> pie_: give it a function Int -> String -> Bool, and it will come up with random Ints and Strings and looks for cases where your function returns False
18:47:09 <pie_> well...doing it in rust might be a more likely way to inherit the project
18:47:26 <ertes> myProp :: String -> Bool; myProp xs = xs == reverse (reverse xs)
18:47:44 <ertes> quickcheck: myProp "abc" = True, myProp "blah" = True, myProp "" = True, …
18:47:58 <ertes> "100 examples true, ok, so it must be true in general" =)
18:48:04 <pie_> right
18:48:36 <ertes> @check \xs -> (xs :: String) == reverse (reverse xs)
18:48:39 <lambdabot>  +++ OK, passed 100 tests.
18:49:56 <ertes> @check \x -> abs x < 1.05 ==> x*x < 1
18:49:56 <lambdabot>  : -1: -1:Ambiguous infix expression
18:50:09 <ertes> @check \x -> (abs x < 1.05) ==> (x*x < 1)
18:50:12 <lambdabot>  *** Failed! Falsifiable (after 11 tests and 11 shrinks):
18:50:12 <lambdabot>  -1.0291338412241657
18:52:20 * ski . o O ( ".. generate random C programs that statically and dynamically conform to the C99 standard" <https://embed.cs.utah.edu/csmith/> )
18:56:52 <Squarism> geekosaur, thanks - worked perfectly
19:19:02 <slaterr> :t when
19:19:04 <lambdabot> Applicative f => Bool -> f () -> f ()
19:19:19 <slaterr> why not Applicative f => Bool -> f a -> f a?
19:19:33 <slaterr> nevermind.. :)
19:25:53 <BryanWB> oh shit, the intero repl for haskell is pretty badass
19:26:11 <slaterr> what makes it better than ghci or cabal repl
19:26:58 <BryanWB> slaterr: integrated into emacs :)
19:27:14 <BryanWB> it is just ghci nicely embedded into emacs
19:27:27 <slaterr> BryanWB ah.. so I'm using that without even knowing? :)
19:27:34 <slaterr> thought it was just regular cabal repl
19:32:34 <ertes> slaterr: i was informed recently that intero depends on haskell-mode, so it's probably just haskell-mode's built-in REPL, which is indeed pretty badass =)
19:33:11 <slaterr> yes it is awesome
19:33:50 <ertes> in fact with that knowledge i really wonder what intero adds to the mix…  haskell-mode does pretty much everything i can think of
19:38:18 <wespiser> has anyone used lens for large/complex data structures in a situation where memory/performance matters?
19:38:42 <wespiser> IMHO, lens seems overly complex
19:39:56 <ertes> wespiser: it compiles to pretty much the same thing you would have written by hand most of the time
19:44:56 <wespiser> ertes: thanks, Kmett really did a good job with them. I'll take a further look when needed
19:50:00 <ertes> wespiser: in this particular case you should probably thank twan van laarhoven…  it's not an optimisation or the way the lens library is implemented, but just a consequence of how these lenses are defined =)
19:50:22 <ertes> the lens library just does some extra work to make sure that everything is inlined
19:51:31 <wespiser> ertes: thanks for setting the record straight!
19:58:56 <nitrix> (.~ straight)
20:42:03 <jle`> i see what you did there
20:42:29 <monochrom> haha
20:44:36 <haskell8348> If I want to use an unsafe function for my own programs (e.g. not exposed to other users), should I still try to use them safely anyway (i.e. with Maybe or Either)?
20:46:25 <monochrom> You should do what is best for your sanity. Because you don't want your program to be subtly wrong. "subtly wrong" means one day you find that it does the wrong thing and you don't know why.
20:47:10 <haskell8348> monochrom: unfortunately this is what's just happened to me
20:48:50 <haskell8348> monochrom: so now I'm restructuring stuff to use Either, but it seems like a large amount of effort. Is it possible that maybe I've laid things out wrong? i'm finding it annoying to have to change many functions from a -> b to a -> m b and then go through all the places that I've composed them together to use the appropriate operators
20:51:55 <geppettodivacin> Possibly, although most of the time when I first decide to add helper monads in for whatever reason, it can take a lot of work for the first monad.
20:52:26 <haskell8348> geppettodivacin: thanks for the input, maybe I'll just slog through it for now
20:52:26 <geppettodivacin> You could use a @lpaste to show us some of it and see if there's any tips out there.
20:52:37 <geppettodivacin> @lpaste
20:52:37 <lambdabot> Haskell pastebin: http://lpaste.net/
21:14:49 <haskell8348> geppettodivacin: http://lpaste.net/350892 if you have a chance to take a look at it, here are a few functions with and without Either stuck on all the return values
21:15:48 <haskell8348> geppettodivacin: admittedly neither of them are very pretty but the one with Either is much longer imo
21:19:55 <Lokathor> MonadInterleave seems like the hot new advancement in the monad-random package by a big margin
21:37:23 <lpaste> geppettodivacin annotated “with and without Either” with “with and without Either (annotation)” at http://lpaste.net/350892#a350893
21:38:32 <geppettodivacin> haskell8348: ^ I just changed bin2base to look more like the non-monadic version. The behavior is slightly different: it only displays the first error. But it might be similar enough.
21:38:55 <haskell8348> geppettodivacin: ah that's a lot simpler
21:38:57 <lpaste> geppettodivacin revised “with and without Either (annotation)”: “with and without Either (annotation)” at http://lpaste.net/350893
21:39:06 <geppettodivacin> Except doing it right this time.
21:39:44 <geppettodivacin> Admittedly, I can't test it because I don't have the right imports set up, so you'll have to tell me if it actually works like I think it should.
21:40:54 <geppettodivacin> mapM, foldM, and other such functions fill in the nice gap where we want to be able to just plop in error checking and type safety.
21:41:29 <haskell8348> geppettodivacin: thanks for the tip, i'll try it out soon
21:41:51 <haskell8348> geppettodivacin: also, is this kind of question acceptable here or is it more suited to something like haskell-beginners
21:43:26 <geppettodivacin> haskell8348: I think it probably fits all right in either. My personal metric for which channel it should go in is whether it has big scary math terms that would scare away "beginners".
22:10:58 <wespiser> haskell8348: i just wrote a program using performUnsafeIO, to load static test files
22:12:33 <wespiser> my reasoning was that the readability and abstraction could be preserved without loss of functionality
22:16:30 <wespiser> sorry, unsafePerformIO
22:34:15 <spocot> Anybody know of any good companies with entry level haskell jobs? (I know a few procedural languages fluently and have worked through both LYAH and Real World Haskell and consider myself an eager to learn novice who picks up on stuff quickly).
22:51:18 <codygman> Is there anyway I could make a Pipes producer only do something once?
22:53:46 <codygman> I suppose it could keep a counter of some sort or I could wrap it within a state monad... but that would be pretty heavyweight for the end usage imo
22:53:50 <osa1> codygman: `doSomething >> yield x >> forever doSomethingElse`
22:55:37 <codygman> osa1: I have a csv producer and I want it to yield the headers once, then forever yield only the rows
22:56:20 <osa1> codygman: sounds easy enough using something like what I showed
22:58:12 <codygman> osa1: Oh... does it the pipe get "stuck" in the forever loop?
22:58:28 <codygman> wouldn't it never end though?
22:58:52 <codygman> I'll try it
22:59:06 <osa1> codygman: instead of `forever` use something that terminates, a tail recursive function
22:59:44 <codygman> osa1: I don't have a termination condition though, I need the producer to produce until there is nothing left
23:03:01 <osa1> codygman: I'm not a pipes expert but I don't think you signal "termination" in pipes. you just stop yielding in your producer.
23:03:25 <osa1> so when there's nothing left to yield, just return ()
23:06:36 <mounty> Is there a neater more Haskellish way of writing:
23:06:39 <mounty> maybeHead :: [a] -> Maybe a
23:06:40 <mounty> 	maybeHead (a:_) = Just a
23:06:42 <mounty> 	maybeHead [] = Nothing
23:07:38 <liste> @src listToMaybe
23:07:38 <lambdabot> listToMaybe []    = Nothing
23:07:39 <lambdabot> listToMaybe (a:_) = Just a
23:07:48 <liste> that's the official one
23:24:38 <isd> Is there a way to make aliases for contexts? I've got a few bits of code where the typeclass constraints are getting rather verbose and repetative.
23:25:24 <codygman> osa1: It worked (terminated)! :) https://github.com/codygman/Frames/commit/7bb8b8b3433477e9336c366e0d6c2c162b436109#diff-cb3db915996afc19d348ed033a8b6785R458
23:26:45 <osa1> codygman: I think `forever` in that line is wrong. you're using P.map which will await an input, map it, and yield. it'll work as long as there's an input to come
23:26:53 <dylanj_> @isd, It's just a constraint kind right? e.g. `:k forall f g. (Applicative f, Applicative g)`
23:26:53 <lambdabot>  It's just a constraint kind right? e.g. `:k forall f g. (Applicative f, Applicative g)`
23:27:37 <dylanj_> So shouldn't type aliases + Constraint Kinds work?
23:28:12 <osa1> codygman: you could do something like `forever $ x <- await; yield (... $ x)` or you do `P.map ...` for the same effect
23:28:37 <osa1> well, I guess this doesn't make that `forever` wrong, it's just redundant
23:30:30 <isd> dylanj_: Didn't know about Constraint Kinds, thanks.
23:32:50 <codygman> osa1: it works so it isn't wrong, perhaps it could be better. It's late though and I'm too tired to understand what you are saying. I'll read your comment again tomorrow
23:33:23 <dylanj_> Does anyone know if something like this is possible with typeclasses? I was playing around with nesting applicative's. Like "ap1 = (<*>)" "ap2 = ap1 . fmap ap1" "ap3 = ap1 . fmap ap2" etc
23:33:27 <osa1> codygman: OK. just try to remove that `forever` in the highlighted line and it should work the same way is what I mean :-)
23:34:12 <dylanj_> Which allow you to do stuff like this, "newtype Parser s a = P { runP :: s -> Maybe (s, a) }" "instance Monoid s => Applicative (Parser s) where (P f) <*> (P a) = P $ ap3 f a"
23:35:06 <dylanj_> It sort of lifts (or the opposite of lifts?) the function out of the nested applicative's.
23:35:22 <dylanj_> Since (->), Maybe, and (,) are all applicative.
23:35:43 <dylanj_> f (g (h (a -> b))) -> f (g (h a)) -> f (g (h b))
23:36:11 <dylanj_> So I was wondering, rather than writing out each one for each level, could you do it inductively with type classes.
23:36:40 <lyxia> dylanj_: You can probably define a typeclass on naturals that does that.
23:38:02 <dylanj_> That's what I thought too, but I keep getting stuck on either infinite types or mismatches between kinds
23:38:24 <isd> Hrm, I've got a kind annotation like (foo :: * -> Constraint), but I'm getting the error "Not in scope: type constructor or class ‘Constraint'". where is that supposed to come from?
23:39:41 <lyxia> isd: import GHC.Exts (Constraint)
23:39:58 <isd> lyxia: thanks
23:48:12 <tdammers> thinking out loud here... suppose I have some TemplateHaskell that generates functions that do, at some point, [Value] -> a, where a is passed as a Name to the TH function
23:49:08 <tdammers> and now the generated function needs to either take the first item from the list of Values and use typeclass FromItem to marshal it, or typeclass FromItems to marshal *all* the Values
23:49:13 <tdammers> depending on which type a is
23:49:44 <tdammers> I guess checking which of FromItem and FromItems a has an instance for isn't the right thing to do
23:54:16 <osa1> lens n00b here -- what lens functions should I look into for doing things like `run this Monad m action using fields of constructor C if this sum value is constructor C` ?
23:54:53 <osa1> so this in more concise way: case x of C a b c -> f a b c; _ -> return ()
