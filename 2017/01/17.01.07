00:00:10 <stobix> stdlib, testing, laziness, higher order abstractions like monads...
00:01:43 <stobix> zipper: I also think you managed to find the channel at an hour where everyone is asleep/at work/not here, so just start reading things that are good to know (or refresh, I assume you know some haskell already) and come back here in a cople of hours or so.
00:01:43 <zipper> stobix: You think testing could come into play?
00:02:16 <stobix> zipper: Idunno, usually companies like words like "test-driven" and "agile" and such.
00:02:35 <zipper> stobix: Oh yeah you're right
00:02:38 <zipper> Thanks
00:02:40 <cocreature> even if you don’t like these buzzwords, autotomated testing of your code is really useful
00:03:55 * stobix has actually never done that in Haskell. Gotta learn quickcheck one of these days.
00:04:24 <zipper> cocreature: Hello :)
00:04:35 <cocreature> hi :)
00:04:42 <c_wraith> I have used quickcheck a few times, but never the "normal" way.
00:04:55 <zipper> c_wraith: What do you mean by the normal way?
00:05:07 <cocreature> quickcheck is really great for any sort of serialization & deserialization
00:05:17 <stobix> I'd like to say that it is also good to be open about your weaknesses, like what you haven't delved into yet, at a job interview, to create a feeling of trust and sincerity, but that might just be relevant in my own imaginary world where everything is perfect.
00:05:18 <c_wraith> zipper: declaring that some property holds of a function
00:05:34 <zipper> c_wraith: Isn't that the only way to use quickcheck?
00:05:40 <zipper> Which other way exists?
00:05:40 <cocreature> zipper: where are your interviewing?
00:05:45 <zipper> Oh cocreature Said
00:05:51 <c_wraith> I've used quickcheck to do things like test that data structure invariants hold over arbitrary sequences of operations on the data structure
00:05:56 <zipper> cocreature: Unless I tell you in PM
00:06:30 * stobix 'd like to have a Haskell job one of these days
00:07:27 <zipper> stobix: So would I
00:08:25 <stobix> :)
00:08:37 <stobix> zipper: seems like you're closer than me to getting one
00:08:48 <lyxia> Do other random packages offer splitting
00:09:08 <zipper> stobix: :) crosses fingers
00:09:08 <lyxia> (not a broken one)
00:09:18 <c_wraith> lyxia: not really
00:10:55 <zipper> Gonna read this http://dev.stephendiehl.com/hask/
00:11:37 <zipper> Wait uh not sure it's good for quick reading, it's like a small book
00:11:37 <cocreature> lyxia: I think carter is trying to finally release a new version of random this weekend that contains a splittable prng
00:12:34 <cocreature> zipper: if you are short on time try to just look over the titles and read the things that you don’t understand/have never heard of
00:12:39 <stobix> zipper: Hard to find anything smaller if you want to read about everything I guess. Focus on the parts you remember the least I'd say.
00:13:52 <zipper> I'm gonna refresh on testing first then use that resource
00:17:04 <stobix> If cabal can't find a dependency that exists (that is, it works if I install the dependency first, then the thing I want, but not if I try to install the thing I want directly) what might be the cause? Since it complains about not finding the thing it wants, and then manages to install it separately, I don't see how/where the dependency is broken.
00:18:22 <cocreature> stobix: are you running "cabal install" in a project or just installing an executable globally/for the current user?
00:19:28 <stobix> cocreature: the latter
00:20:05 <xpika> when i use the plugins package and try to evaluate an IO action I get Segmentation Fault
00:21:32 <stobix> cocreature: I'm installing Agda. cabal found and installed all dependencies it needed, except alex, happy and cpphs. It complained about not being able to find any suitable version for them, but then installed exactly the version it wanted to begin with for all 3 when I installed them separately. I could then install Agda.
00:22:08 <cocreature> stobix: hm that seems weird. are you sure you haven’t run a "cabal update" in between?
00:22:34 <c_wraith> nothing weird about that.
00:22:45 <c_wraith> those are executable dependencies
00:22:48 <c_wraith> cabal doesn't install those
00:23:00 <cocreature> oh right I ignored the names of the deps
00:23:02 <cocreature> sry
00:23:27 <stobix> cocreature: I actually did exactly that after installing two of the dependencies,  just to se if it would find the third by itself. Didn't work.
00:23:43 <c_wraith> stobix: those are all executables that it was looking for, not libraries
00:24:26 <c_wraith> stobix: cabal doesn't install executable dependencies, because you can depend on non-haskell executables
00:24:36 <c_wraith> pkg-config is a common executable dependency
00:25:08 <stobix> c_wraith: Ah. Well, that kinda almost explain it - to not be able to install executables that are in cabal I see as a huge "gotcha".
00:26:54 <cocreature> iirc "cabal new-build" installs them at least in some cases
00:27:05 <c_wraith> I think it does too
00:30:32 <stobix> my cabal doesn't recognize new-build it seems
00:30:44 <c_wraith> it's new. :)
00:30:46 <cocreature> it’s only in cabal >= 1.24
00:31:03 <cocreature> in if you want a somewhat working version you should be using cabal from the master branch
00:31:19 <cocreature> also it won’t help you since it can’t install things, it can only build projects
00:33:19 * stobix apparently has 1.22.8.0
00:34:11 <c_wraith> anyway, all the new- stuff is still a bit experimental
00:34:18 <c_wraith> But I'm looking forward to its completion
00:34:29 <c_wraith> It's so much nicer of an approach than stack
00:34:32 <cocreature> there is a reason it is called "new-build" and hasn’t simply replaced "build" :)
00:35:08 * stobix installs an updated cabal, for some reason, and goes back to playing with Agda
00:47:41 <ongy> is it called debian?
01:08:13 <vininim> Apparently haskell isn't purely functional even if you factor IO out.
01:09:19 <vininim> It's interesting, but then it makes me wonder if side-effect (at language level) is necessary for self-compilation.
01:11:06 <kadoban> vininim: "apparently" based on what?
01:11:21 <kadoban> Not really clear what you're discussing, exactly.
01:11:25 <vininim> type creation
01:13:19 <vininim> I'm investigating the details of why agda rellies so much on Haskell and came to this(not related) http://semantic-domain.blogspot.com.br/2016/03/agda-is-not-purely-functional-language.html
01:15:08 <dunx> i thought haskell was purely functional
01:15:42 <vininim> I'm inclined to say it is at data level, but not at type level.
01:15:47 <dunx> since everything can be implemented in lambda calculus
01:17:13 <EvanR> haskell is purely functional. also "functional" and "purely functional" arent very well defined
01:17:59 <kadoban> It seems to be saying something about haskell isn't purely functional because ... not all functions are total, and also something about type names ... didn't really understand.
01:18:00 <dunx> vininim: to what extent do you think haskell isn't functional at a type level?
01:18:50 <dunx> if the data itself is processed in a functional manner then i'm inclined to say that the language itself is functional
01:18:56 <vininim> erm... if you remove type creation, can GHC still do the same things?
01:19:04 <dunx> what do you mean?
01:19:18 <kadoban> I can't quite tell what the definition of "purely functional" being discussed in that page is. Something about "consists entirely of sets and functions" perhaps?
01:19:23 <dunx> to what extent is type creation non-functional?
01:19:36 <EvanR> type creation?
01:20:00 <dunx> EvanR: i was addressing something they said [ i don't understand to what they refer
01:20:22 <mfukar> dunx, the blog post claims creating a type is a side-effect, by way of two identical declarations not being able to be substituted for one another
01:20:48 <dunx> hmm, that's sort of true
01:20:53 <dunx> (i think)
01:21:00 <vininim> we can't mix agda and haskell here, it's important to notice that agda should be able to unify
01:21:02 <EvanR> creating a type?
01:21:08 <vininim> while haskell doesn't even deal with that
01:21:16 <EvanR> declarations dont "happen" in any order, its not imperative
01:21:22 <EvanR> its literally declarative
01:21:55 <mfukar> don't shoot the messenger
01:22:24 <EvanR> also during runtime the system secretly mutates objects all over the place, none of it is observable to us of course
01:22:41 <EvanR> but could be another basis for a blog post to consider it not purely functional
01:23:07 <vininim> i'm talking about language level, type creation hits the expression of programs, compiler details only hit performance.
01:23:08 <kadoban> If haskell is not purely functional, I question what is. And if nothing is, what's the use of the term?
01:23:26 <vininim> kadoban: but haskell does more than just lambda calculus
01:23:32 <vininim> haskell infer types, for example
01:23:45 <EvanR> haskell is definitely not basic lambda calculus
01:23:51 <EvanR> its a form of typed lambda calculus
01:23:56 <mfukar> EvanR, so, strictly speaking, what's the error in the reasoning in the post?
01:23:59 <vininim> so type inference might require side-effects? I really am not an expert :P
01:24:08 <EvanR> inference doesnt require side effects
01:24:13 <EvanR> i havent looked at the post
01:24:19 <EvanR> i thought we were just bullshitting ;)
01:24:41 <mfukar> it could be, i don't know enough to claim it's bullshitting :P
01:24:43 <EvanR> mfukar: error wrt to what
01:25:54 <kadoban> vininim: The post says that not even agda meets its definition, so ... how useful is this definition, if nothing fits it?
01:27:01 <vininim> from the language and grammar point of view, this might indicate what can and can't be done without side-effects
01:28:58 <EvanR> nah
01:29:12 <EvanR> all of computer science has no side effects
01:29:35 <EvanR> each time you read the paper, its the same ;)
01:29:44 <vininim> heh
01:29:51 <ongy> I would say that's wrong
01:30:33 <EvanR> and when you read it ,nothing happens
01:30:38 <EvanR> \o/
01:30:59 <vininim> let me try to be more clear
01:31:00 <ongy> some information gets stored on my mutable brain in some way
01:31:12 <ongy> which can make later readings of the same (or related) papers different
01:31:17 <EvanR> thats beyond the scope of that paper
01:32:37 <EvanR> on the subject of telling lies during pedagogy
01:32:46 <vininim> from the type theoretic point of view, a function type is defined solely by domain and codomain. If we factor out dependent types, that seems "easy". 
01:32:47 <EvanR> i think that actually helps people
01:33:15 <vininim> equality of functions is then extensional, which would be prohibitive in most scenarios.
01:33:20 <EvanR> tell them a lie, and they think "wait a damned minute..." and ask "what about foo" and you say "ha... i lied, heres more info"
01:33:31 <vininim> with constructed datatypes and structural recursion, that would be doable
01:33:32 <EvanR> people like complexity until they are trained to suspect it
01:33:58 <vininim> Is newtype and its side-effect just a detail or important for some other aspect of computability in the language?
01:34:16 <EvanR> in haskell, declarations are order-independent
01:34:26 <EvanR> so having side effect would be really inappropriate
01:34:49 <vininim> that might prevent some fetures to be added to it
01:34:57 <EvanR> they are not commands to instantiate a new type like OOP
01:35:00 <vininim> like, full blown dependent types, no??
01:35:07 <EvanR> youre right
01:35:46 <EvanR> thatll be an extension and theyll have to solve it
01:35:58 <EvanR> and we already have extensions messing up that order independence (TH)
01:36:19 <EvanR> and since TH can do whatever IO or anything, that part is not purely functional at all
01:39:09 <vininim> see, it's bullshitting... but the "controlled speculative" one :)
01:57:01 <zipper> Is there a ghc extension to make all ints defaults to Integer so I don't get Int/Integer warnings?
01:58:31 <c_wraith> all ambiguous types with a Num constraint already default to Integer
01:58:34 <c_wraith> The warning is harmless
01:59:33 <ongy> "The warning is harmless" annoys me so much. If I have 15 "harmless" warnings, the 1 I should see will go invisible :(
02:03:49 <ongy> but I agree that the value of the defaulting warning is rather low, if you get it a lot, I'd consider turning that warning of
02:15:09 <zipper> c_wraith: I want to get rid of the warning
02:15:29 <zipper> They show up in my editor
02:15:31 <c_wraith> zipper: then turn it off
02:15:52 <zipper> I like -Wall
02:16:01 <c_wraith> you don't have to turn off -Wall
02:16:03 <ongy> -Wno-<something>
02:16:14 <zipper> c_wraith: Oh
02:16:57 <zipper> Let me see
02:17:24 <c_wraith> -fno-warn-type-defaults
02:18:01 <zipper> If I don't want it in the cabal file but in the source file
02:18:04 <zipper> I am trying `{-# OPTIONS_GHC Wno-type-defaults #-}`
02:18:19 <c_wraith> like I said before
02:18:23 <ongy> hm, why is -Wall/-Wextra like gcc but disabling warnings is not?
02:18:43 <c_wraith> {-# OPTIONS_GHC -fno-warn-type-defaults #-}
02:18:45 <zipper> Clearly it is failing
02:19:27 <zipper> c_wraith: Thanks
02:19:42 <zipper> c_wraith: You having a bad day though :) you don't seem very happy.
02:21:40 <c_wraith> I'm confused that I told you exactly what option to use, then you said something else wasn't working. :P
02:22:00 <ongy> that may have been my fault
02:22:38 <c_wraith> Oh, I see the clashing advice now
02:22:45 <c_wraith> ok, no longer confused. :)
02:23:31 <ongy> so I have seen -Wno-/-w/-fno-warn for the same thing now in different compilers... This is confusing
02:23:56 <c_wraith> Yeah, it's not standardized.  GHC uses -f flags to turn warnings on or off
02:24:08 <c_wraith> GCC uses -W or -w, iirc
02:25:26 <zipper> c_wraith: Because I thought the `-Wno-<something>` was better but I remember now that that was a command line arg to cabal
02:25:28 <zipper> It's not for use in files
02:25:35 <zipper> I am rusty on the tooling stuff
02:26:12 <zipper> ongy:  Is it about different compilers or where you use them?
02:26:27 <zipper> Which other compiler do you use?
02:26:31 <zipper> HUGS?
02:27:23 <ongy> zipper: not haskell compilers. I use gcc/clang often, have tried rustc/whatever go uses and a few others
02:28:57 <xpika> is there a cabal command to download dependencies for cabal test ?
02:29:56 <lyxia> hmm, cabal install --enable-tests --only-dependencies ?
02:31:32 <xpika> lyxia: thanks
02:34:12 <jchia_> When writing a library to work with different versions of GHC/base, what's a quick and easy way to find out what's included in the Prelude of that base version so that I know how to write the MIN_VERSION_base conditions?
02:34:33 <jchia_> for conditionally importing things from certain modules
02:38:22 <ongy> (pls no flame-war) what's the currently sanest way to handle paths? (I don't care about windows) I like the description of [1], but the aeson dependency looks super weird to me https://hackage.haskell.org/package/path 
02:39:40 <ongy> jchia_: I've switched to importing everything any of the supported compilers doesn't have in Prelude, with 8.0 it doesn't produce any warnings anymore (provided it's an explicit import list I think)
02:42:50 <jchia_> ongy: I'm contributing to an existing library and they have travis CI involving GHC 7.8 & GHC 7.10 and my use of (<$>) is breaking for 7.8. I don't know when (<$>) started being part of Prelude
02:44:07 <ongy> 7.10, but I'm not sure what's the best way to check, I know that from experience. Have you checked with upstream what they say about version specific warnings?
02:44:40 <jchia_> ongy: I found out it was base-4.7.0.2 by checking the source code on hackage, but it was a little tedious.
02:45:08 <jchia_> i just gotta import Data.Functor (<$>) for base < 4.8
02:46:46 <ongy> which requires CPP extension and macros afaik. In the end you/the maintainer has to decide, but this is a warning that will be specific to ghc-7.10, I'd import it without the macro
02:49:44 <jchia_> the library i'm contributing to already MIN_VERSION_base(4,8,0), so i think it's fine
02:49:47 <jchia_> "already uses"
02:50:24 <jchia_> To complicate things, though, (<$>) can be found in Data.Functor & Control.Applicative. I don't know which one I should import from.
03:10:57 <stobix>  /me guesses that Control.Applicative reexports (<$>) from Data.Functor, but he's too lazy to rtfs atm.
03:11:19 * stobix also writes a space before /me, for some reason
03:45:41 <ij> If I do (,) <$> parser <*> parser, then I'll either have both of neither of the results.
03:46:05 <ij> How could I have the first and then PERHAPS the second?
03:46:41 <srk> optional
03:47:28 <ij> I should've RTFM.
03:47:33 <ij> I rememer seeing it.
03:49:17 <srk> it's not mentioned directly at the docs of attoparsec as it comes from control.applicative
03:51:31 <ij> Text.Megaparsec has it. (should've specified.)
03:54:39 <ij> ● (read :: String -> Bool) <$> string "true" <|> string "false" or ● const True <$> string "true" <|> const False <$> string "false" or ● any other way to do it?
03:57:29 <ij> well that read one should have toLower for it to work and some parens
03:58:42 <lyxia> string "true" $> True <|> string "false" $> False
03:59:24 <lyxia> > read "true" :: Bool
03:59:27 <lambdabot>  *Exception: Prelude.read: no parse
04:00:14 <ij> Yeah, that won't quite work, I am mistaken.
04:00:43 <asdsdaas> Hello, I have a beginner question about the function "go". I have been given this simple example but I have a bit of trouble understanding things: https://paste.debian.net/907310/  I don't understand why there is a d in the middle here go (n - d) d (count + 1)
04:01:05 <ij> lyxia, The action of parsing «string -> bool» is lexing in this case?
04:01:56 <lyxia> I just call it parsing
04:02:54 <lyxia> asdsdaas: d is just the denominator
04:03:13 <lyxia> asdsdaas: you could write go without passing it as a parameter
04:04:00 <asdsdaas> but what is it doing in the middle? it's just a number it's not doing any operation or anything
04:04:55 <lyxia> it's being passed as an argument to the function (go (n - d))
04:06:09 <asdsdaas> I see so the go function has three parameters
04:06:23 <asdsdaas> (n -d) d (count + 1)
04:07:02 <lyxia> yes
04:07:34 <pavonia> ij: null . drop 4 <$> (string "true" <|> string "false")
04:07:53 <xpika> I often find myself using forever from Control.Monad when I'm using the pipes package. Is there an alternative to this?
04:07:56 <ij> pavonia, haha
04:07:56 <asdsdaas> It's still a bit confusing.., so is go like a for loop,..?
04:08:44 <lyxia> asdsdaas: in the sense that haskell uses recursion to do what other languages use loops for.
04:09:36 <asdsdaas> I guess it's just a different way of thinking. It'll be a bit until I get used to it
04:10:36 <gingitsune> Reading learn you a haskell, currently about guards
04:11:59 <gingitsune> Is = (the equals sign) kinda of like a return statement for haskell?
04:12:31 <gingitsune> I realize this statement might not hold true because its also used for declaring constatns
04:12:39 <athan> When you use `traverse` as a lens, is it automatically isomorphic (extra behavior), or does it just use traversable? :S
04:12:50 <ij> gingitsune, Everything returns something, = just assigns it.
04:13:23 <lyxia> athan: what do you mean isomorphic
04:15:32 <lyxia> athan: traverse is from Traversable, and it has the type of a Traversal
04:17:11 <athan> lyxia: Okay so, say I have some newtype `Molecule := {_atoms :: [Atom]}`
04:17:17 <athan> and I derive all the lenses
04:17:35 <Lavode> I am feeling very stupid. I want to add every item in a list to a strict map as keys with the same value (False) 
04:17:42 <athan> now, in this example (lens-tutorial), they use `over (atoms . traverse . foo . bar)` to dig deep
04:18:11 <athan> I'm just wondering why it's traversible - if I traverse with the Identity functor, is that the same as a map?
04:18:14 <athan> oh wait..
04:18:21 <Lavode> placeDefenders :: [V] -> Map V Player -> Map V Player
04:18:25 <athan> sorry v_v I need to tune this antenna better
04:18:33 <Lavode> placeDefenders [] t = t
04:18:40 <Lavode> placeDefenders [x] t = M.insert x False t
04:18:42 * athan phillips head to the teeth
04:18:48 <Lavode> placeDefenders (x:xs) t = M.insert x False (placeDefenders xs t)
04:18:54 <lyxia> Lavode: paste code in lpaste.net
04:19:00 <Lavode>  doesn't work. What am I fucking up?
04:19:53 <lyxia> Lavode: what is the error
04:20:00 <lyxia> is Player a boolean
04:20:24 <Lavode> yes. 
04:20:57 <Lavode> And the things in the list are just not getting added to the map. And I can't tell why
04:21:12 <athan> if all the records I'm lensing into were Traversable, could I just do `over (traverse . traverse . traverse . traverse)`? O_O
04:21:59 <athan> I'm guessing that would imply that I'm using the single value associated with the Functor instance of the thing though
04:23:14 <lyxia> Lavode: this function looks fine.
04:24:27 <Lavode> all right. Off to pester the TA. 
04:25:40 <lyxia> Lavode: can you paste the rest of your code
04:27:59 <cocreature> the second line is redundant but it shouldn’t cause problems
04:31:33 <Lavode> rest of the code isn't mine - exercise is to finish this project, not debug it. So there shouldn't be errors outside my bits. .. Wait, missing a just. 
04:31:57 <Lavode> Alright, thanks. Should have read the given parts better <,<
04:42:30 <govinda> Hi, I'd like to know where is stored the documentation when I activate it with "cabal --enable-documentation install mypackage" ?
04:44:27 <jaspervdj> govinda: .cabal/share/doc by default
05:33:44 <xcmw> How do you configure stack to use ghc head?
05:35:03 <carter> cocreature: which thingy? But yes:)
05:36:47 <cocreature> carter: someone was asking about a random package containing a splittable rng
05:46:02 <xcmw> I need a version at or after this commit. https://git.haskell.org/ghc.git/commitdiff/3540d1e1a23926ce0a8a6ae83a36f5f6b2497ccf
05:49:18 <carter> cocreature: there's 1ish, but soon random will too
05:49:36 <carter> Errrr.  I mean soon random will have a good one
05:50:18 <carter> A long holiday break was needed to unburnout. But I'm mostly better now :)
05:50:31 <cocreature> great :)
05:50:40 <rekado_> I’m currently trying to compile the prelude of nhc98 with nhc on top of Hugs.
05:51:07 <rekado_> This works great so far, but I’m stuck at building FFI/CTypes.hs
05:51:19 <rekado_> hugs bails out with “ERROR - Control stack overflow”
05:51:46 <rekado_> when I build Hugs with an option to report stack traces the build never terminates.
05:52:25 <rekado_> any ideas how to get Hugs to tell me what it tried to evaluate when the stack overflow occurred?
05:52:47 <carter> cocreature: now just dealing with how reflux meds all shift the effective serum level of other drugs. Which is still annoying.
05:53:13 <carter> rekado_: your an archeologist!
05:53:33 <rekado_> a Control stack overflow is usually indicative of an error in the program; I rebuilt Hugs with a much larger control stack but got the same error.
05:54:00 <rekado_> carter: I also ported Yale Haskell from ’92 to CLISP, but it’s less useful than Hugs and NHC
05:54:24 <rekado_> the goal is to eventually bootstrap GHC without GHC
05:54:43 <carter> rekado_: which code base ?  Is it possible it's a large space leak ?
05:54:44 <cocreature> bootstrap GHC from magic!
05:55:20 <carter> rekado_: what if you build it with c debug symbols and use gen?
05:55:26 <carter> GDb
05:56:16 <carter> Or is there a way to get nhc to emit logs as it runs?
05:56:20 <rekado_> hugs runs nhc98, which in turn is used as a compiler to build nhc’s prelude
05:56:25 <carter> Yes
05:56:27 <rekado_> the error is thrown by hugs
05:56:30 <rekado_> not nhc
05:56:45 <carter> Ok.  So debug symbols and gdb might be good
05:57:05 <rekado_> debug symbols for hugs, right?
05:57:21 <carter> Yes.  Also What happens if you build nhc with ghc and set a small control stack?
05:57:33 <carter> Does nhc throw the error then?
05:57:33 <rekado_> haven’t tried that yet
05:58:14 <carter> Might be easier ? Or not idk
05:58:38 <carter> It's been like a decade since i uses hugs.  Is there a copy of its manual anywhere ?
05:58:55 <rekado_> yes, it’s somewhere at haskell.org/hugs
05:59:35 <rekado_> I’ll try running hugs in gdb then.
05:59:37 <rekado_> thanks for the idea
06:02:21 <carter> I have no idea if it'll help :)
06:03:14 <rekado_> I expect it to be difficult to infer anything about the program by inspecting Hugs in gdb, but on the other hand it might just provide me with a hint.
06:23:02 <wojtek_> How many resources do I need to run stack? What my $5 digitalocean ubuntu droplet has (512MB RAM) is clearly not enough because I get "Populating index cache ...Killed"
06:24:30 <wojtek_> Or, like - how can I work productively and host it there? It needs to be deployed somewhere so it can listen to what mailserver says
06:24:41 <Tuplanolla> I recently installed Stack and GHC 8 with 1 GB of memory, wojtek_.
06:25:08 <Tuplanolla> It seems to work decently with that, although compiling some packages like `haskell-src-exts` requires some swapping.
06:26:16 <ongy> wojtek_: haskell binaries can be copied to other hosts without problems, the haskell dependencies are statically linked
06:28:18 <wojtek_> are they OS specific? I.e. if my PC run the same OS the droplet is running I should be good?
06:29:26 <Tuplanolla> The operating system and architecture need to match, approximately, wojtek_.
06:30:50 <wojtek_> Thank you!
06:46:36 <vininim>  /join #agda
06:46:39 <vininim> oops
07:08:01 <carter> wojtek_: make your swap file bigger
07:20:49 <wojtek_> @carter ... I didn't realise I can do such a thing
07:20:50 <lambdabot> Run your socks up the flag pole to see if anyone salutes them.
07:21:36 <wojtek_> I've made the droplet bigger and I'll scale it down again
07:21:53 <carter> Most cloud providers do that to encourage naive users to pick bigger vms
07:22:10 <carter> Or maybe it's because it behaves better. Idk.
07:22:16 <wojtek_> that's totally me
07:41:07 <davean> so, not all FS can handle a swap file
07:41:17 <davean> and swap partitions are overall ebtter
07:41:52 <davean> btfs for example can't have a swap file on it I think?
07:41:59 * juri_ nods.
07:42:07 <juri_> btfs cannot.
07:51:03 <nitrix> Is it normal I can't killThread a thread that's blocking on a putMVar ?
07:51:52 <nitrix> It's also blocking on Sdl.waitEvents which is a foreign call so that could also be it.
08:01:46 <danpalmer> I've got a Haskell site (built using Yesod, Stack, Hedis) that can't connect to the Redis instance for some reason. It errors with "connect: does not exist (Connection refused)"
08:02:12 <danpalmer> I've sshd into the container its running inside and tried the same connection settings in GHCI, and it works fine
08:02:55 <danpalmer> I've had a look around the web but really not sure how to progress in debugging this, especially given that I can't reproduce it outside of the application.
08:03:14 <danpalmer> Does anyone have any ideas about avenues of investigation I could try?
08:05:40 <davean> danpalmer: is redis listening on a non-local port?
08:06:00 <danpalmer> Redis is in a separate container, and linked using Docker's container linking.
08:06:14 <davean> Oh, have fun
08:06:16 <danpalmer> I can connect to it and run commands from GHCI though
08:06:30 <davean> wait, which container?
08:06:38 <davean> which container can you run ghci in to test?
08:06:38 <danpalmer> from the web app container
08:06:40 <davean> Ok
08:06:50 <danpalmer> so I can connect successfully across the container link
08:08:05 <shapr> Is there some good reason for the monoid/applicative instances for tuple?
08:08:20 <davean> shapr: well, think about Applicative
08:08:24 <davean> shapr: that should be obvious
08:08:43 <davean> danpalmer: the connect worked fine in ghci, did you actually RUN a command
08:08:50 <davean> or did you use checkedConnect?
08:09:03 <davean> danpalmer: 'connect' doesn't actually connect to the server
08:09:03 <danpalmer> I used checkedConnect and set something, read it back, and deleted it.
08:09:08 <danpalmer> all successful.
08:09:17 <davean> hum, ok
08:09:44 <davean> I'd double check your ConnectInfo then
08:09:48 <danpalmer> another data point - when I run without the link, I get a "getAddrInfo failed" kind of error, which is what I would expect, and different, so it looks like the web app can find the hostname.
08:09:58 * shapr thinks about Applicative as directed
08:10:09 <danpalmer> the webapp prints the ConnInfo on startup, and I pasted that straight into GHCI
08:11:07 <davean> danpalmer: then I have no idea
08:11:31 <danpalmer> yeah, neither do I! Thanks for your help, really appreciate it.
08:11:51 <danpalmer> I could just do with more things to test, I just don't know enough about Haskell networking to know where to start
08:12:42 <davean> shapr: so, you're refering to Monoid a => Applicative ((,) a), correct?
08:13:42 <shapr> davean: yes
08:13:59 <davean> ok, so without the Monoid you'd have no idea what to do with the a of (a, b), right?
08:14:08 <davean> but its clear we can make an Applicative for (a, b) on b
08:14:25 <davean> so, we need some way to decide what happens with a when we do that
08:14:25 <shapr> For starters, why does the functor instance for a two tuple ignore the first value? Is there an intuitive reason for that?
08:14:38 <davean> Yes, currying order
08:14:43 <shapr> oh?
08:14:45 <davean> you can't write the other order in haskell
08:14:52 <davean> try to wwrite the instance declaration
08:14:57 <davean> Haskell won't let you
08:15:02 <davean> its a limit of Haskell
08:15:52 <davean> and the "waht do we do with the other bit?" question remains in both orders
08:16:16 <davean> shapr: we don't have a general "theres a hole, here let me point to it" syntax in Haskell
08:16:21 <shapr> hm
08:16:22 <davean> shapr: we just get to look at a hole at the end of the type
08:16:41 <davean> we can't "flip" types either really (we sorta can, but not in a way that doesn't wrap?)
08:18:30 <davean> shapr: and notice, it can't be semigroup  because of "pure"
08:19:10 <davean> we have to be able to create an 'a', which really rules out Applicative without exactly monoid
08:19:51 <davean> shapr: well, following so far?
08:20:21 <shapr> I'm slowly ingesting what you've said
08:21:12 <shapr> I'm still digging into the comment "Currying order. You can't write the other order in Haskell".
08:21:51 <davean> Ok, hum
08:21:53 <hpc> you can't write the other order naively, at least
08:22:19 <davean> shapr: so we have instances "C (M hole)", right?
08:22:19 <hpc> what you can do is something like data Flip f a b = MkFlip {unFlip :: f b a}
08:22:29 <davean> hpc: thats what I said about flip wrapping
08:22:43 <hpc> but then to write that backwards Applicative instance you'd still just be writing it for Monoid a => Flip (,) a
08:22:50 <hpc> which would make a good exercise when you're done with this
08:23:08 <davean> "11:16:19 davean we can't "flip" types either really (we sorta can, but not in a way that doesn't wrap?)"
08:23:14 <davean> so the instances is actually on something different then
08:23:22 <hpc> davean: yeah, just making it a bit more explicit so shapr doesn't get the false impression that it's totally impossible ever ;)
08:23:30 <davean> ah, ok
08:24:26 <hpc> and it's a bit of a sneak peek at type-level programming :D
08:24:34 <davean> shapr: anyway, we have to bring everything down to "C (M hole)" form
08:24:49 <davean> and the only way we have of doing THAT is applying values to the type function
08:25:08 <davean> even hpc's thing is just that, just applying values to a different function
08:27:17 <jmnoz> hey folks, I put a small haskell application on Heroku and now I want some kind of health check monitoring tool. Now New Relic doesn't offer a plugin for Haskell programs and such. Does anyone have any idea about what I could use?
08:27:54 <davean> jmnoz: ekg?
08:28:20 <jmnoz> davean: ekg is great I use it thanks, I want something for looking at request times and stuff like this
08:28:37 <davean> Ah, well you CAN do that with ekg but its manual
08:28:52 <davean> what did you impliment it in?
08:28:52 <jmnoz> oh right! very good, thanks
08:29:02 <jmnoz> snap
08:29:09 <davean> hum, don't really know snap
08:29:22 <davean> there might be a pre-built wrapper that does it, there might not, sorry, no idea 
08:29:23 <jmnoz> well I just use the snap server and some snap monads
08:29:43 <jmnoz> davean: there is wai middleware for it?
08:29:43 <davean> yah, but you can see how one can automate the collection of such data on arbitrary snap services?
08:29:59 <davean> jmnoz: there was, I ahve some internally at least! but its rather custom to how I run stuff
08:30:37 <jmnoz> I'll look into it, it should be doable thanks :)
08:30:39 <davean> I can at least talk about the wai side informedly
08:31:23 <davean> shapr: I'll grab a sponge
08:32:01 * shapr soaks up the knowledge
08:32:26 <jmnoz> davean: do you have heroku experience specifically? with ekg?
08:32:28 <davean> I meant to mop up your brains
08:32:35 <davean> jmnoz: nah, I run stuff on real servers
08:32:39 <davean> more then one of them
08:32:42 <davean> rather the opposite problems
08:32:51 <jmnoz> ah okay!
08:33:08 <davean> I can't remember when the last time I had a service small enough to share with others :)
08:33:08 <shapr> davean: ha, thanks
08:33:26 <davean> Ok, I can, it was around 2006
08:33:32 <davean> somewhere in the middle of the year
08:34:10 <davean> shapr: anything your stuck on?
08:34:28 <davean> (,) :: a -> b -> (a, b)
08:35:24 <shapr> just digging along slowly
08:36:07 <jmnoz> davean: any performance hit from EKG?
08:36:17 <davean> jmnoz: not really no
08:36:35 <davean> not in a practical sense
08:36:58 <davean> clearly doing anything takes SOME cycles. Its overhead is very low though and its per request is very low
08:37:14 <jmnoz> great, thanks
08:37:54 <davean> jmnoz: it has a plugin to ship its data to statsd
08:38:47 <jmnoz> looking at it, do you use that part?
08:38:56 <davean> I have not, known people that do
08:39:07 <davean> I've got a lot of my own infastructure from days well before that sort of thing
08:40:29 <Athas> I wonder at which point the number of lines of written Haskell surpassed the number of lines written to *implement* Haskell.  (Clearly, before Haskell implementations were written in Haskell.)
08:41:42 <eklavya> how to mix different free monad interpreters ?
08:42:10 <davean> eklavya: theres nothing stopping you? I guess I don't understand the question
08:42:18 <eklavya> I mean if I have inter1 inter2 inter3, how do I make one big inter ?
08:42:26 <monochrom> Perhaps mix the different free monads first.
08:42:28 <eklavya> sorry if I am not making any sense
08:42:30 <davean> they're on different free monads?
08:42:41 <eklavya> I am brute forcing my way into understanding a lot :P
08:43:07 <davean> eklavya: they're on different free monads?
08:43:20 <eklavya> let me provide some context
08:43:46 <davean> The context doesn't really matter
08:43:51 <davean> this is an abstract question
08:43:58 <davean> I just need to know if they're different ones or not
08:44:22 <eklavya> I am sorry I am not sure
08:44:28 <shapr> ok, I'm starting to understand the type hole you mentioned.
08:44:31 <davean> Ok, then give me the context and I'll try to figure it out
08:44:38 <davean> shapr: yay!
08:46:03 <eklavya> in a lot of talks for Haskell and Scala, people suggest to make eDSLs and their interpreters to keep side effects in the outer layer
08:46:08 <eklavya> they say use Free monads
08:46:46 <eklavya> as I understood free monads are just about making big chains of execution hints (sorry no better name coming to mind)
08:46:56 <eklavya> and later interpreting them
08:47:06 <davean> Ok, then we have to start at the begining but I'll rush it
08:47:34 <davean> So, each free monad only has one interpriter, if you're using the eDSLs seperately thats not a problem and obvious
08:47:50 <davean> if you want to use them TOGETHER though, well you only get to pick one free monad
08:48:06 <davean> but thats not a problem, you'd use FreeTs to layer other things on top
08:48:12 <davean> but I assume thats what you're missing
08:48:18 <davean> Have you heard about monad transformers at all?
08:48:21 <monochrom> If you don't mix two eDSLs first, there is no "mixing two interpreters".
08:48:30 <eklavya> yes and yes
08:48:55 <davean> So, there are free monads and free monad transfomers
08:48:59 <eklavya> monochrom: I can see in any app I will inevitably have to?
08:49:12 <davean> of course you can pick Identity as your base monad
08:49:32 <davean> and just use free monad transfomers to build up a monad that has all the parts
08:49:42 <davean> and each interpriter transforms a piece of that
08:49:44 <davean> did that help?
08:49:53 <eklavya> umm
08:49:54 <eklavya> but
08:50:10 <eklavya> I have to give this big monad chain to some runner
08:50:22 <eklavya> and that will be a single interpreter?
08:50:33 <davean> maybe, maybe not
08:50:51 <davean> you can have each interpriter change the free monad to a simpler free monad 
08:50:57 <davean> or you could make one that did it all
08:51:21 <eklavya> I can make one big jumbo interpreter
08:51:26 <davean> but why would you?
08:51:33 <davean> just do each layer of the eDSLs at a time
08:51:36 <eklavya> but is there something like inter1 <|> inter2 ...
08:51:41 <davean> yes
08:51:50 <davean> "inter1 . inter2 . inter3"
08:51:53 <davean> or the reverse order
08:51:55 <davean> depending on what you mena
08:52:13 <davean> well, ok, they're probably monadic, not functions but the same idea applies
08:52:47 <eklavya> so you mean each inter will only execute the part it is concerned with? (has a case statement for it)
08:53:01 <davean> eklavya: so, your monad might be "Thing1M (Thing2M (Thing3M Identity)) a"
08:53:18 <davean> and you might call that "AllMyThings a" but its really composed of layers
08:53:50 <davean> You COULD work with all the layers at once but you could also just work with each layer seperately, removing it and then the next and next
08:54:08 <eklavya> I just got what you mean I think
08:54:28 <davean> yay!
08:54:30 <eklavya> so I would lay out the interpreters in the same sequence as I am mixing the monads, right?
08:54:36 <davean> yep!
08:54:40 <davean> well, reverse sorta
08:54:44 <davean> since you're stripping the layers off
08:55:04 <davean> You'd transform a "Thing1M (Thing2M (Thing3M Identity)) a" into a "Thing2M (Thing3M Identity) a"
08:55:32 <eklavya> I am getting that feeling that I get it and I don't get it at all :D
08:56:08 <davean> yah, my explanations could have been better here really actually
08:56:27 <davean> I sorta funbled it because I didn't take the time to udnerstand waht you already understood which is my bad
08:56:36 <davean> and then I tried to skip to the parts you cared about
08:56:56 <davean> Thats my fault not yours, sorry
08:57:11 <eklavya> davean: not at all, I am really jumping ahead
08:57:15 <eklavya> this is what I wrote
08:57:16 <eklavya> http://lpaste.net/350967
08:57:45 <drdo> How do I convince GHC that "foo ∷ If b x Void → x" "foo x = x" is fine?
08:58:00 <davean> eklavya: so, I should return and ask why you want to mix eDSLs anyway
08:58:08 <eklavya> ok
08:58:11 <davean> (I'm not saying you shouldn't)
08:58:28 <davean> (I am saying it matters)
08:58:51 <eklavya> in my head I can see that in an app I would like to have different interpreters for different db methods (users, store, etc etc)
08:59:03 <eklavya> also interpreters for a bunch of IO
08:59:14 <davean> mmm, so ... "different db methods"
08:59:16 <davean> lets start there
08:59:42 <davean> why aren't these different monadic actions built on a common DB interpreter?
08:59:42 <geekosaur> drdo, that doesn't look "fine" to me based on the types; why do you think it should be?
08:59:42 <eklavya> I can make a big db interpreter but that is not very maintainable 
09:00:00 <eklavya> so I would make one concerning Users
09:00:05 <davean> eklavya: no, no
09:00:06 <drdo> geekosaur: Because Void is empty
09:00:15 <drdo> (and If has the obvious definition)
09:00:20 <davean> eklavya: So "interacting with the DB" is generic
09:00:31 <drdo> b is of kind Bool
09:00:37 <davean> eklavya: if your commands are at that level, then you make functions "do user stuff with the DB"
09:00:45 <davean> you've factored out understanding users
09:00:52 <davean> but you haven't added a layer that just knows a bout users
09:01:04 <davean> you can even customize this based on whcih DB you're using using classes
09:01:10 <eklavya> I didn't get it
09:01:14 <davean> hum, ok
09:01:23 <davean> so say you have a PostgresT
09:01:31 <davean> Why, I don't know, I just wanted a name and thats one type of DB
09:01:38 <eklavya> ok
09:01:52 <geekosaur> drdo, then I think x should be a Proxy something and the impl is foo Proxy = Proxy
09:02:09 <geekosaur> otherwise I think you're in unsafeCoerce-land (but this is why Proxy)
09:02:28 <davean> You can make "class HasUsers (DbT a)" (Not exactly correct syntax because thats not what matters ATM) which says how to have users in that specific DB
09:02:49 <davean> now you can have an instance "instance HasUsers (PostgresqlT a)" that says how to impliment users on postgresql
09:02:56 <eklavya> ok
09:03:04 <davean> They all USE the same DB access
09:03:15 <drdo> geekosaur: What's a Proxy?
09:03:17 <davean> but if you say, used leveldb, the implimentation would vary
09:03:32 <geekosaur> a dummy value that carries a type
09:03:39 <davean> eklavya: is this making sense?
09:04:01 <davean> eklavya: now you can say you need to know how to interact with users, without knowing what sort of DB you're on
09:04:09 <eklavya> the exact implementation will vary with the underlying db
09:04:13 <drdo> geekosaur: I don't understand how that is going to help :S
09:04:20 <eklavya> but I have an interface for working with users
09:04:23 <davean> yep
09:04:29 <eklavya> that is fine
09:04:30 <davean> and its all tied to one layer of "has a database"
09:04:40 <davean> instead of seperate layers of each of the things
09:04:45 <geekosaur> um, if I understand type level better than you do, maybe you shouldn't be working at type level :)
09:04:49 <eklavya> but interacting with db means dealing with effects and exceptions and all that
09:04:56 <davean> Your problem might come if you started having different DBs for different things mind you
09:05:00 <davean> eklavya: ye[
09:05:02 <davean> yep
09:05:05 <drdo> geekosaur: I understand it just fine, what I don't understand are Haskell's limitations :)
09:05:13 <davean> but the more generic you make something, the more you have to deal with
09:05:13 <eklavya> and that's why people say push that as far later as you can
09:05:20 <geekosaur> the main limitation is that Haskell is not fundamentally a type level language
09:05:42 <eklavya> and just describe what you would do, interpret it last
09:05:43 <davean> you COULD push users out to be a full eDSL thats just more to deal with
09:05:48 <davean> eklavya: yah
09:06:02 <davean> eklavya: you always have to worry about power to weight
09:06:14 <eklavya> I am not sure if there is a better way in Haskell for this
09:06:21 <davean> the more you abstract things, the more you have to deal with, Haskell makes that efficient and lower overhead then other places but its not 0
09:06:32 <eklavya> but in the examples I have seen for Scala
09:06:48 <drdo> geekosaur: The actual problem here is that I have something roughly as described in https://arxiv.org/abs/1610.04799
09:06:52 <davean> eklavya: Oh
09:06:58 <davean> eklavya: and one more tihng before we move on
09:07:30 <davean> you can make it so that a UserT interpriter *reinterperites* User eDSL commands into the DB command language
09:07:37 <davean> To be clear
09:07:39 <geekosaur> and the problem I see you having is the same one as foo :: Maybe Int -> Maybe Char; foo (Just x) = Just (chr x); foo x = x -- this is a type error, must be foo Nothing = Nothing (the Nothing-s are *different*)
09:07:44 <davean> thats sort of splitting the difference
09:08:14 <davean> there are lots of options, I don't want to tell you "design it this way!" I'm trying to layout the options with different tradeoffs on genericness and ease of use, etc
09:08:23 <geekosaur> and the same trick involved when using Proxy to carry type level computations at value level; foo Proxy = Proxy, the two Proxy-s are not the same thing
09:08:29 <eklavya> davean: ok, this is what I had in mind, please tell me if this is correct
09:08:40 <drdo> geekosaur: There is no nothing here though, Void is empty
09:08:47 <eklavya> davean:  I would do data UserCommands = Save | Delete | Authenticate
09:08:57 <drdo> That's the whole point, this constructor is unusable in this particular version of the structure
09:08:58 <geekosaur> drdo, I'm afraid you grabbed the wrong part of what I was trying to say
09:09:02 <eklavya> davean: and then write one userinterpreter
09:09:06 <davean> I mean, Save needs to take what to save? 
09:09:10 <davean> but yes
09:09:27 <geekosaur> the point was not Nothing, the point was that at value level the x on the left of your = is not the x on the right
09:09:29 <eklavya> davean: pseudo, which would deal with all user db effects
09:09:43 <eklavya> davean: same for different groups of effects
09:09:50 <geekosaur> well, no, put that wrong. they may be the same at value level but different at type level so you can't just reuse the x
09:09:51 <drdo> geekosaur: Hold on, let me give paste the actual situation
09:09:53 <geekosaur> you need a dummy value that you can reuse
09:10:07 <geekosaur> but, I am not a type level wizard, and probably shouldn't be trying to help you :/
09:10:16 <eklavya> davean: and in any request I would have to mix effects from different groups
09:10:34 <eklavya> davean: at last I need to interpret it all
09:11:09 <eklavya> davean: that interpreter needs to understand every Command (inter1 <|> inter2 ...)
09:12:34 <lpaste> drdo pasted “Haskell is hard” at http://lpaste.net/350968
09:12:42 <eklavya> davean: how would this approach work whether it's best or not? How would you do it?
09:12:42 <drdo> geekosaur: There :)
09:12:56 <drdo> geekosaur: Consider the pattern match on line 103
09:13:18 <davean> eklavya: No, it just needs to understand each layer
09:13:27 <davean> eklavya: it CAN understand multiple but it doesn't need ot
09:13:29 <drdo> geekosaur: If that pattern matches, we know that p ∷ p, since Void is empty
09:13:32 <geekosaur> fine. I'll keep pretending I know how type level works
09:13:49 <geekosaur> drdo, but that is not correct. the *types* still differ
09:13:58 <eklavya> davean: so in each request I would layout the inters in the same way the monad has been built up?
09:14:03 <drdo> geekosaur: They don't
09:14:06 <davean> eklavya: yes
09:14:17 <geekosaur> this is because type level stuff is sort of hacked onto a value level language
09:14:29 <drdo> geekosaur: If that pattern matches, that If reduces to p
09:14:42 <eklavya> davean: isn't there a more generic way :P ? I mean can't I just say biginterp anyChain ?
09:14:44 <geekosaur> drdo, you can't have a value level discriminator that introduces If b x Void ~ x
09:14:52 <drdo> That is trivial to prove, I just need to tell GHC to shut up and trust me
09:15:31 <geekosaur> sigh. just unsafeCoerce, since apparently you don't see why we need to use Proxy here
09:15:32 <drdo> geekosaur: Alternative ways to do this would also be accepted!
09:15:44 <drdo> geekosaur: I'm not familiar with the Proxy idiom
09:15:47 <geekosaur> I tried
09:15:49 <davean> eklavya: thats less generic
09:16:01 <drdo> How would I use it in this case?
09:16:31 <davean> eklavya: Heres one piece of advice I will give clearly: Hang the functions off type classes.
09:16:32 <geekosaur> I tried to show you, you decided I meant Nothing ~~ Void
09:16:37 <geekosaur> which I didn't intend at all
09:16:39 <davean> eklavya: that way whats under it doesn't matter to the code
09:16:46 <davean> one monad, a transformer stack, whatever
09:16:49 <drdo> geekosaur: huh?
09:16:57 <geekosaur> I'm just going to shut up and let someone who actually gets type level explain it
09:17:29 <geekosaur> [07 17:08:18] <drdo> geekosaur: There is no nothing here though, Void is empty
09:17:36 <geekosaur> which was not relevant at all
09:17:48 <eklavya> davean: could you please edit my paste and give an example?
09:17:50 <drdo> geekosaur: Maybe I missed the point there
09:18:30 <drdo> geekosaur: But on that example, those types really are provably different
09:18:39 <drdo> And on my case they are provably equal
09:18:57 <davean> eklavya: ok, so, acom, bcom, ccom - are these related? Is Done?
09:19:03 <geekosaur> yes, but the proof is at value level since you used a pattern match
09:19:20 <geekosaur> Haskell is not dependently typed, a proof at value level isn't directly usable at type level
09:19:30 <eklavya> davean: just different commands for any interpreter like in cae of user api Save | Delete | ...
09:19:51 <davean> eklavya: yah, but I need to know which ones are groupped, I'll make something up
09:19:57 <davean> I have to go for 5 mintuies thoguh
09:20:14 <eklavya> davean: no problem :)
09:20:30 <drdo> geekosaur: Sure. What I'm asking then is how to convince GHC to accept that, or some alternative way to solve the problem
09:20:37 <geekosaur> so, your options are (a) unsafeCoerce which is literally "just shut up and do it", (b) use a singleton type like Proxy (or even (), but Proxy is the convention for this usage) to carry the type, so we can specify the singleton at value level and let type inference fix the type level
09:20:46 <eklavya> davean: this is just a dummy program so I can fake understand Free monads :P
09:20:55 <geekosaur> yes, and twice I told you "since you are certain you just want to make it shut up, unsafeCoerce"
09:21:03 <drdo> What I really want is some sort of structural subtyping
09:21:34 <drdo> geekosaur: Right, and I don't understand how to use a Proxy
09:21:38 <drdo> So I asked for further clarification
09:22:30 <Rotaerk> drdo, the Proxy constructor is of type Proxy t; you can constrain it to any specific t
09:22:44 <Rotaerk> (Proxy :: Proxy Int) for instance
09:23:24 <drdo> Rotaerk: I see it, but how do I use it in my case?
09:24:35 <geekosaur> so: "foo ∷ If b x Void → x" becomes "foo :: Proxy (If b x Void) -> Proxy x; foo Proxy = Proxy" and this will be accepted. if the value level actually has something in it, then you can't use Proxy directly but need to reconstruct the value allowing the compiler to fix the type, or unsafeCoerce (and you'd better be certain the types have the exact same representation including any dictionaries being carried around, or a core dump is in your n
09:24:35 <geekosaur> ear future)
09:25:09 <drdo> geekosaur: I care about the x
09:25:11 <drdo> It's not empty
09:25:18 <geekosaur> because unsafeCoerce is exactly "just shut up and do it" and it's on you to be correct
09:25:40 <drdo> Var (If (GTL_Var t) p Void)
09:25:46 <drdo> (this is a constructor of GTL)
09:26:00 <drdo> The point here is that some types of GTL can use that constructor, and some can't
09:26:33 <geekosaur> ok, at this point I have to hope one of the type level folks can step in, I get lost too quickly :(
09:26:40 <Rotaerk> what's this If type?
09:26:49 <drdo> Rotaerk: http://lpaste.net/350968
09:26:54 <geekosaur> am slowly picking it up (couldn't even have gotten this far a month ago) but still very wobbly
09:28:13 <Rotaerk> interesting
09:28:35 <drdo> Rotaerk: Roughly like the idea proposed in https://arxiv.org/abs/1610.04799
09:29:38 <drdo> I basically want to have several types of formulas, that are restrictions of the constructors in some way
09:31:48 <monochrom> Oh, so we have finally come down to unsafeCoerce.
09:32:53 <geekosaur> I only mentioned it three times...
09:33:16 <drdo> I'm still hoping for a better solution :P
09:33:17 <geekosaur> (and am suspecting it really is the only solution, if the value level is relevant)
09:33:26 <davean> eklavya: http://lpaste.net/350967
09:33:45 <drdo> geekosaur: Of course it's relevant, it's the whole point :P
09:34:05 <geekosaur> if you need the value level, then the only way around it is to have the value level rebuild the value with the expected type. which is unnecessarily slow unless there are dictionaries that need to be replaced
09:34:15 <geekosaur> (in which case it's necessarily slow...)
09:34:32 <drdo> geekosaur: The value already has the correct type
09:34:40 <eklavya> davean: we have a single interpreter here, can you please show how to mix two?
09:34:43 <drdo> Void is empty
09:34:43 <nshepperd> drdo: `If b x Void ~ x` isn't actually true, as that lets you convert from any x to y
09:34:59 <drdo> nshepperd: It is in that case
09:35:06 <geekosaur> here we go again...
09:35:11 <nshepperd> drdo: rather, If b x Void is some kind of subtype of x
09:35:47 <drdo> nshepperd: Consider line 103
09:36:18 <lpaste> xcmw pasted “Ambiguous kind problem” at http://lpaste.net/350970
09:36:37 <davean> eklavya: Sure, the point there thoguh is that HOW you impliment it becomes irrelivent if you hang the functions off classes
09:36:39 <drdo> If that pattern matches, we must be in the b~True case and If b x Void ~ x, otherwise p ∷ Void
09:36:55 <davean> eklavya: do you see how that could be done via IO if you just removed the Done and the interpriter call?
09:37:06 <davean> eklavya: so now your implimentation details aren't exposed
09:37:10 <davean> eklavya: I think thats importatn
09:37:16 <eklavya> davean: no :(
09:37:20 <davean> shapr: You getting anywhere?
09:37:26 <nshepperd> drdo: line 103 of what?
09:37:32 <shapr> davean: yes, making progress on a variety of fronts
09:37:33 <drdo> nshepperd: The paste I linked?
09:37:38 <geekosaur> drdo, and again you can't use a pattern match at value level to prove something at type level
09:37:38 <eklavya> davean: I am not getting it :(
09:37:39 <eklavya> sorry
09:37:43 <drdo> nshepperd: http://lpaste.net/350968
09:38:17 <geekosaur> well, with a GADT you can but not usefully for this case, I think
09:38:31 <davean> eklavya: Ok, I think the is point is WAY more important then the interpriter part so ... give me a sec
09:38:36 <monochrom> drdo: You need to read and consider Data.Type.Equality.
09:38:54 <geekosaur> that is, I don't think you can phrase a GADT declaration such that this case brings a (If b x Void ~ x) constraint into scope
09:39:59 <davean> eklavya: http://lpaste.net/edit/350967
09:40:29 <nshepperd> geekosaur: nor should you want to. (If b x Void ~ x) isn't actually true unless b is known to be True
09:40:53 <monochrom> or x known to be Void
09:41:11 <eklavya> davean: yes !!
09:41:21 <geekosaur> isn't that what the value level pattern match is determining? (if not, then drdo is really doing something wrong...)
09:41:57 <eklavya> davean: so Free here buys me deferred effects, right?
09:42:05 <eklavya> whereas IO would execute right there
09:42:16 <davean> eklavya: So, looking at that one then asks "Why do we care about Free anyway?" and A) Free lets us change SEMANTICS, which you're probably not interestd in. B) Free allows pure testing C) some other minor things
09:42:21 <geekosaur> monochrom, does that actually work in the case If b Void Void?
09:42:33 <drdo> p ∷ (If (GTL_Var t) p Void)
09:42:34 <davean> oh, if you're interested in defering, then yah, aybe you care about A
09:42:44 <monochrom> I haven't tried.
09:43:07 <eklavya> davean: got it
09:43:10 <drdo> If you matched on Var, we clearly have that equality
09:43:19 <drdo> This isn't controversial
09:43:25 <drdo> I don't know why we keep coming back to this
09:43:28 <monochrom> You know what, maybe I'm wrong because Haskell (and generally the Haskell community) is so bloody intuitionistic, even at the type level.
09:43:59 <davean> eklavya: This is how you get close to that "any eDSL combination" most easily because now you've really abstraced from whats going on at very low expense
09:44:01 <nshepperd> drdo: no. that pattern match only brings a value p :: (If (GTL_Var t) p Void) into scope
09:44:04 <geekosaur> drdo, because Haskell isn't realy a type level language and "obvious equalities" aren't actually
09:44:17 <nshepperd> drdo: it doesn't mean that (GTL_Var t) is True
09:44:23 <nshepperd> drdo: p could be 'undefined'
09:44:24 <drdo> nshepperd: Yes, it does, unless you used undefinde
09:44:27 <drdo> *undefined
09:44:34 <drdo> In which case all bets are off anyway
09:44:44 <geekosaur> there's a *lot* of stuff on Hackage that is about working around this kind of thing without dragging in (or, sometimes by hiding) unsafeCoerce
09:44:47 <drdo> undefined breaks the type system
09:44:50 <eklavya> davean: we have different ways to execute Commands here (via free and via IO)
09:44:51 <monochrom> 'This isn't controversial" is right. The compiler is not going to hear your eloquent argument.
09:44:53 <shapr> Is there a way to get the type of something inside a big expression?
09:44:54 <davean> eklavya: yep
09:45:07 <davean> eklavya: oh, one sec!
09:45:14 <drdo> monochrom: Yes, I'm just making it clear that the discussion is about getting it to!
09:45:16 <davean> eklavya: I fudged one of the most important parts there!
09:45:23 <nshepperd> drdo: no, undefined doesn't break the type system. it doesn't let you unsafeCoerce thigns
09:45:41 <shapr> for example, I'm pretty sure the reason <*> works in constructing values from parsers is because of partial application, but I'd like to see the type of <*> inside a line of code.
09:45:50 <lyxia> shapr: type holes. (subexpression :: _)
09:45:59 <nshepperd> drdo: you can't get segfaults just by using undefined
09:46:12 <davean> eklavya: http://lpaste.net/350967
09:46:14 * geekosaur was just thinking that and wondering if it worked (the :: _)
09:46:16 <monochrom> Wait, that is a type hole?!
09:46:30 <shapr> lyxia: I tried replacing <*> with _ but that didn't work
09:46:37 <lyxia> isn't it?
09:46:43 <shapr> oh, you mean (<*> :: _) ?
09:46:45 * shapr tries that
09:46:49 <monochrom> Oh type wildcard
09:46:54 <geekosaur> or (expr using <*> :: _)
09:46:56 <davean> shapr: also <*> is infix which makes it harder ;)
09:47:03 <monochrom> type hole is when you have (_ :: Int)
09:47:04 <kuribas> > (+) <$> [1, 2] (_) [3 4]
09:47:05 <davean> eklavya: THATS the really important part!
09:47:06 <lambdabot>  error:
09:47:06 <lambdabot>      • Couldn't match expected type ‘t0 -> [t1] -> f a’
09:47:06 <lambdabot>                    with actual type ‘[Integer]’
09:47:21 <shapr> lyxia: (<*> :: _) fails to parse :-(
09:47:22 <kuribas> > (+) <$> (_ [1, 2] [3 4])
09:47:24 <lambdabot>  error:
09:47:24 <lambdabot>      • Found hole: _ :: [Integer] -> [t0] -> f a
09:47:24 <lambdabot>        Where: ‘f’ is a rigid type variable bound by
09:47:31 <davean> eklavya: "theThingWeCareAbout" just says what things it has to be able to do and then does it
09:47:34 <davean> eklavya: implimentation unseen
09:47:40 <lyxia> hmm. that's a weird name then.
09:47:43 <geekosaur> I don't think (<*> :: _) is syntactically correct, and making it so would be painful at best
09:47:53 <kuribas> > (+) <$> (_ [1, 2] [3, 4])
09:47:56 <lambdabot>  error:
09:47:56 <lambdabot>      • Found hole: _ :: [Integer] -> [Integer] -> f a
09:47:56 <lambdabot>        Where: ‘f’ is a rigid type variable bound by
09:47:56 <monochrom> But I just tried in GHC 8.0.1
09:48:02 <davean> eklavya: now you can improve the implimentation behind the scenes as you get better and not change your actual code!
09:48:10 <monochrom> In fact, let's try lambdabot too.
09:48:17 <lyxia> > ((<*>) :: _)
09:48:19 <lambdabot>  error:
09:48:20 <lambdabot>      • No instance for (Applicative f1)
09:48:20 <lambdabot>        Possible fix:
09:48:21 <monochrom> > (Just () :: _)
09:48:23 <lambdabot>  error:
09:48:23 <lambdabot>      • Found type wildcard ‘_’ standing for ‘Maybe ()’
09:48:23 <lambdabot>        To use the inferred type, enable PartialTypeSignatures
09:48:27 <monochrom> \∩/
09:48:29 <geekosaur> you'd need to wrap it as (<*>) but then it's prefix instead of infix, and pretty sire you can't just `` the whole thing to make it infix again
09:48:29 <geekosaur> *sure
09:48:43 <eklavya> davean: the moand is inferred by usage here, right?
09:48:47 <davean> eklavya: yep
09:48:54 <shapr> ok, so _ does work in a type signature, neat
09:48:56 <davean> eklavya: we just say what properties it needs
09:49:01 <cocreature> being able to `` expressions instead of single identifiers is a feature that I’ve missed several times
09:49:12 <shapr> at least, according to lambdabot
09:49:22 <lyxia> well if it's just to debug it should be fine to use prefix operators for a minute.
09:49:31 <monochrom> > show (read (_ :: _))
09:49:33 <lambdabot>  error:
09:49:34 <lambdabot>      • Found hole: _ :: t
09:49:34 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
09:49:34 <eklavya> davean: I see that it's useful, I will really have to level up to see where to do that though :P
09:50:09 <shapr> lyxia: is there a way to put a type hole signature onto an infix op?
09:50:29 <shapr> geekosaur: that's right, I wasn't able to wrap it in `` to make it infix again
09:50:40 <shapr> > `(<*> :: _)`
09:50:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘`’
09:50:54 <lyxia> no, unfortunately
09:50:55 <davean> eklavya: doing that style also means you can just get started on your project now with one combined free monad and then go back and clean up that free monad when you get a bit better
09:51:00 <nshepperd> drdo: so anyway, you can define a function 'lift = unsafeCoerce :: (If b x Void) -> x' and use that
09:51:06 <davean> eklavya: and not hold your entire project up with understanding everything first
09:51:06 <geekosaur> hm
09:51:15 <monochrom> No, you want ((<*>) :: _)
09:51:18 <davean> eklavya: you understand free monads, great, work from there
09:51:36 <davean> eklavya: And no long term cost is inherited
09:51:43 <davean> eklavya: you've completely seperated the two parts
09:51:46 <kadoban> Optimizing stuff can be really ... fragile sometimes. I just found out that factoring out a monadic action and giving it a name in my code makes it go from 3.5s to run a particular benchmark to ~20s
09:51:49 <eklavya> right, all generic
09:51:54 <geekosaur> I thinkt hat still doesn't work
09:52:07 <davean> eklavya: and when you decide you want more performance, you'll end up writing something like "ReaderT ??? IO" and instances for that
09:52:11 <nshepperd> drdo: or you could refactor your data types to be some kind of GADTs that actually bring the relevant info into scope on pattern match (this may or may not be feasible depending what you're trying to implement)
09:52:12 <davean> eklavya: for your highest perforamnce version
09:52:18 <geekosaur> > let ?f = (<*>) in a ?f b :: Expr
09:52:20 <lambdabot>  error:
09:52:20 <lambdabot>      • Couldn't match expected type ‘(f0 (a0 -> b0) -> f0 a0 -> f0 b0)
09:52:20 <lambdabot>                                      -> Expr -> Expr’
09:52:23 <geekosaur> bah
09:52:26 <monochrom> :)
09:52:27 <davean> (unless you can get more performance by some semantic transform
09:52:36 <davean> which is perfrectly reasonable with things like DB calls)
09:52:38 <lyxia> monochrom: _ instead of an expression is a "typed" hole. I wrote type hole to mean a hole in a type.
09:52:43 <eklavya> davean: oh? then why do people suggest Free and interpreters?
09:53:03 <davean> eklavya: a large part is you can test it and simulate it
09:53:10 <lyxia> The associated extension is actually called partial type signatures.
09:53:28 <shapr> kadoban: no longer getting inlined or something?
09:53:40 <eklavya> davean: it's definitely very easily testable but is that the only practical benefit?
09:53:44 <shapr> kadoban: did you compare ghc core output between the two versions?
09:53:49 <davean> eklavya: another part is that if you CAN do semantic tricks like  start a DB call and then keep processing untill something depends on the results
09:54:00 <kadoban> shapr: Must be I guess. I'm not savvy enough to read core ... I should probably learn that skill
09:54:02 <drdo> nshepperd: Guess I could make some pattern synonyms and isolate the unsafeCoerce to one place
09:54:09 <davean> eklavya: theres a lot of flexability in the Free approch
09:54:31 <shapr> kadoban: I bet it'd take you less than an hour to learn, it's just extremely simplified Haskell
09:54:34 <davean> eklavya: it gives nice code seperation back in the intperiter
09:54:46 <eklavya> ok
09:54:48 <davean> eklavya: there is a cost in performance though
09:54:58 <davean> There are lots of reasons to use free and to not use free
09:55:00 <kadoban> Hmm, thanks for the push, I'll give it a try then.
09:55:07 <monochrom> > "abc" :: _ Char
09:55:10 <lambdabot>  error:
09:55:10 <lambdabot>      • Found type wildcard ‘_’ standing for ‘[]’
09:55:10 <lambdabot>        To use the inferred type, enable PartialTypeSignatures
09:55:10 <davean> hence not depending on e implimentation
09:55:13 <monochrom> :)
09:55:17 <eklavya> yeah, but I mean they are all long time users, surely they have weighed all the factors?
09:55:27 <shapr> kadoban: is this for your suffix array code?
09:55:29 <drdo> nshepperd: Not sure what you mean with that GADT solution though
09:55:33 <kadoban> Heh, ya
09:55:35 <davean> eklavya: and something are application specific
09:55:42 <eklavya> understood
09:55:49 <davean> eklavya: lowering throughput to decrease latency can be good
09:56:05 <davean> eklavya: taking the Free overhead to do things like reorder processing and DB calls can be a win because of that
09:56:15 <davean> all sorts of things
09:56:15 <eklavya> I should at least try each appraoch
09:56:20 <davean> right
09:56:22 <monochrom> eklavya, there is a big gap between "I have experience" with "I have time to write it all down".
09:56:39 <davean> and thats my point, the class variant lets you see what works for you and CHANGE it as your needs change
09:56:46 <davean> even if the needs just change between testing and running
09:56:49 <atc-> hello all, anyone able to help me with a static compilation issue? I'm building something that uses postgresql-simple, thus libpq under the hood, but I get these errors when compiling: http://lpaste.net/350973
09:56:51 <lpaste> atc pasted “Haskell static binary with postgresql-simple” at http://lpaste.net/350973
09:56:53 <eklavya> got it
09:57:01 <davean> eklavya: which is part of my point, needs aren't even the same inside the same program!
09:57:23 <davean> hell, I can even imagine switching between Free and (ReaderT IO) implimentations at runtime depending on load!
09:57:40 <eklavya> hopefully I will start to see where what fits :P
09:57:42 <davean> "if we get near our performance limits, sacrifice latency for throughput"
09:57:52 <davean> or other shit like that
09:58:40 <davean> hence I really strongly recomend using the class approch :)
09:58:40 <atc-> I've been banging my head against a brick wall on this for hours :( :(
09:59:06 <davean> eklavya: anyway, I'm actually impressed you understood the free stuff with so little apparent experience, you're off to a good start
09:59:46 <geekosaur> I would expect extra-libraries to either omit the "lib" prefixes or require the ".a" suffixes --- they go together, if you provide one then you provide both
09:59:46 <eklavya> davean: no, I just fake it so I don't get hopeless, I fool myself into understanding eventually :P
09:59:52 <geekosaur> that is, it's either foo or libfoo.a not a half-and-half like libfoo
10:00:15 <atc-> ok, I'll try that geekosaur . Thanks!
10:00:15 <davean> eklavya: sucessfully, which is the important part
10:00:23 <geekosaur> the "lib" is boilerplate
10:00:30 <nshepperd> drdo: it's definitely a good idea to isolate the unsafeCoerce to one place
10:00:32 <monochrom> The Chinese Room argument says that you understood. :)
10:00:34 <atc-> yeah I wasn't sure
10:00:50 <geekosaur> (and, usually not prtesent on Windows, it's a Unix convention)
10:00:51 <davean> shapr: Did you end up getting it? I'm about to actually go do real work so if you had any more questions?
10:00:59 <eklavya> davean: :)
10:01:09 <eklavya> davean: last question, if we wanted to have two interpreters?
10:01:13 <atc-> complains of "Missing C libraries: libcrypto.a, libldap.a"... :(
10:01:13 <zirman>       "Erase the current buffer."
10:01:18 <nshepperd> drdo: eg. 'lift = unsafeCoerce :: (If b x Void) -> x' is perfectly safe because (If b x Void) really is a subtype of x
10:01:26 <eklavya> davean: or if you are late I can bother you tomorrow?
10:01:38 <nshepperd> drdo: whereas unsafeCoerce itself won't give you an error if you use it in the wrong spot
10:01:38 <davean> eklavya: Yah, I'm getting late, I was supposed to start work 2 hours ago :)
10:01:41 <geekosaur> atc-, so you added the .a? try removing the lib instead
10:02:02 <atc-> * Missing C libraries: crypto.a, ldap.a
10:02:04 <davean> eklavya: Other people around here can probably show you though
10:02:07 <geekosaur> sigh
10:02:13 <drdo> nshepperd: Why do you say it's a subtype?
10:02:13 <atc-> geekosaur: * Missing C libraries: libcrypto.a, libldap.a
10:02:15 <davean> eklavya: or I can tomorrow/later
10:02:16 <geekosaur> ok, should have known I needed to be preciuse
10:02:25 <geekosaur> extra-libraries: crypto, ldap
10:02:26 <eklavya> davean: thank you so much for your time :)
10:02:28 <drdo> nshepperd: In particular it's really equal
10:02:40 <eklavya> davean: and thanks for being patient :)
10:02:45 <geekosaur> again, lib and .a are both boilerplate, you do not provuide only one or the other
10:02:51 <shapr> davean: I will continue to have real questions, but I'm also making progress
10:02:53 <shapr> davean: thanks for your help
10:02:56 <geekosaur> because on Unix it's lib and .a , on Windows it's "" and .lib
10:02:57 <shapr> I'm no longer stuck where I was stuck
10:03:19 <geekosaur> (or lib and .so/.dylib.whatever vs. "" and .dll)
10:03:30 <atc-> geekosaur: oh, sorry! My mistake entirely. Let me try those.
10:03:40 <shapr> I still wish I could get the concrete post-typeclass-lookup type signature of an infix operator in a particular piece of code
10:03:43 <eklavya> davean: it's late, I will try and catch you tomorrow :P
10:04:25 <atc-> geekosaur: thanks, cabal/stack doesn't complain any longer, but I still get the undefined reference errors from my paste :(
10:04:43 <atc-> geekosaur: it's strange, because I can find the function calls in the .a files in /usr/lib, so it's not like the libs aren't installed.
10:04:54 <geekosaur> could be link order
10:05:02 <geekosaur> for one, get rid of the copuies in --ghc-options
10:05:18 <drdo> nshepperd: Interesting, GHC does not let me write that lift
10:05:22 <geekosaur> they wll go in the wrong place
10:05:30 <geekosaur> static libraries are order dependent: they are searched for symbols if and only if those symbols are needed at that point
10:05:40 <monochrom> shapr: I think you can use 3 type wildcards and put them together yourself.  (True :: _) && (False :: _) :: _
10:06:03 <geekosaur> so -lfoo bar.o for a static libfoo.a will ignore -lfoo because no symbols are known to be required at that poinbt
10:06:11 <drdo> Turns out there's yet another extension to enable!
10:06:31 <geekosaur> (and, well, stack/cabal may also be getting ordering wrong, I have seen that before)
10:06:42 <lpaste> nshepperd pasted “((If b x Void) ~ x) ==> unsafeCoerce” at http://lpaste.net/350974
10:06:51 <shapr> monochrom: huh?
10:07:03 <atc-> geekosaur: ok, yeh. I've removed those, same error though. I thought it was a linker error earlier but not experienced enough with it to debug
10:07:11 <atc-> geekosaur: linker error as in ordering
10:07:11 <geekosaur> (everyone assumes static libs work the same way dynamic ones do. do you really expect the whole static library to be linked in?)
10:07:27 <nshepperd> drdo: it's not equal. equality would imply you can convert from x to (If b x Void).
10:07:29 <atc-> geekosaur: hehe my expectations are low, I've not done this before :)
10:07:33 <nshepperd> drdo: you can only go the other way
10:07:53 <geekosaur> atc-, possibly you can cheat and --ghc-options=-Wl,--whole-library
10:08:11 <monochrom> shapr: Imagine you are looking at "True && False" and wonder what's the type of && there. You do what I said. You will get 3 Bool's, and you put them together to get Bool -> Bool -> Bool for &&'s type
10:08:36 <drdo> nshepperd: You can
10:08:36 <atc-> geekosaur: unrecognised warning flag :)
10:08:42 <atc-> geekosaur: I'm fun, aren't I? :D
10:08:42 <nshepperd> drdo: that lpaste I posted is a demonstration of how such an equality can lead to segfaults
10:08:52 <geekosaur> it's kinda a bd way to do it, usually you use a static library so you only pull in the parts you need (you cant do that with a shared object, but it also doesn't cost you extra for the parts you don't use like static ones do)
10:09:08 <geekosaur> wow, I wonder if they broke that somehow
10:09:13 <drdo> nshepperd: let me see
10:09:18 <nshepperd> drdo: let b = False in x -> If b x Void   =>  x -> Void
10:09:24 <geekosaur> -W is newish
10:09:26 <atc-> geekosaur: perhaps: Version 1.1.2, Git revision d850a92dd3022356df475490b3ae96d92cbffbe9 (dirty) x86_64 hpack-0.14.1
10:09:40 <atc-> OH, btw, I had to not use glibc
10:09:46 <geekosaur> er, -W as a warning control option is newish, -Wphase,option has been around a long time
10:10:01 <atc-> because of an old bug, so I've had to use a docker container running alpine to build it statically
10:10:08 <geekosaur> yes, glibc and static linking don't mix very well at all
10:10:46 <geekosaur> actually when you can pull it off (sadly this usually means not with stack/cabal...) forcing static only for application libs is a good idea
10:10:55 <atc-> geekosaur: musl is what I've used
10:12:01 <geekosaur> I think you need -v3 to see what exactly it's feeding to the linker. but then there's trying to force it to do the right thing which is /o\ --- stack and cabal think they know how it works, but they only do it correctly for the dynamic linking case
10:12:09 <geekosaur> they don't understand how static library searching works
10:12:27 <atc-> geekosaur: seems that way :(
10:12:34 <geekosaur> (and... not sure it even works the same way windows vs. unix, so that may be knowledge they "shouldn't" have)
10:12:51 <geekosaur> not that anyone uses static libs on windows these days
10:14:09 <atc-> aye
10:14:16 <atc-> I'm only doing this to get something working in AWS lambda
10:14:22 <atc-> Don't want to rewrite it, it's awesome in Haskell
10:14:33 <atc-> Just really difficult to get the damn thing built
10:14:39 <atc-> Seems it's linker order at least
10:15:41 <drdo> nshepperd: Err, right.
10:16:05 <monochrom> What is the shortest string that contains all permutations of x,y,z as substrings? In general, given n symbols, what is the shortest string that contains all permutations of those n symbols as substrings?
10:16:30 <atc-> geekosaur: any more ideas? :(
10:16:59 <monochrom> Solve that, and you will have a general solution to "I want to list my static libraries in a robust order". :)
10:17:12 <drdo> nshepperd: liftIf still does not work though
10:17:12 <atc-> lol monochrom 
10:17:19 <geekosaur> aside from convincing the package using libpq to specify the dependency libs, no
10:17:19 <kadoban> monochrom: Oof, that sounds tricky.
10:17:23 <drdo> GHC says it can't match ‘If b0 p Void’ with ‘If (GTL_Var t) p Void’
10:17:27 <geekosaur> monochrom, actually back in the day we used lorder and tsort :)
10:17:32 <drdo> Which seems silly
10:17:39 <drdo> Just take b0 = GTL_Var t
10:18:04 <geekosaur> drdo, that usually means b0 has been pinned by something else and cannot unify
10:18:47 <nshepperd> drdo: hmm, can you paste
10:18:52 <geekosaur> also the fact that it has a 0 on the end means you are missing something that relates that b with the original b, so what is "pinning" is is that it has no idea what b0 is and therefore it can't unify with anything
10:19:10 <drdo> nshepperd: hold on, let me isolate it
10:19:25 <nshepperd> drdo: oh, you may need ScopedTypeVariables to pass the correct b
10:19:33 <geekosaur> yes, that was where I was leading
10:19:41 <nshepperd> as I did in my paste
10:20:03 <drdo> I didn't actually write the b
10:20:13 <drdo> The error is when using liftIf
10:20:38 <drdo> e.g.: toPresentTL (Var p) = Just $ Var (liftIf p)
10:20:55 <nshepperd> right, whoops, you need to pass the b to liftIf somehow
10:21:05 <drdo> But why?
10:21:15 <drdo> I'm already passing it, it's the universal quantifier
10:22:10 <drdo> Haskell doesn't have that as a first-class abstraction, it's always implicit
10:23:46 <monochrom> ever heard of ExplicitForall and ScopedTypeVariables?
10:23:53 <drdo> yes
10:24:15 <monochrom> To be sure, they still don't make "forall" 1st-class, you still can't pass "forall" as a parameter.
10:25:06 <drdo> monochrom: My point was that there is no explicit type-level abstraction in Haskell
10:25:32 <monochrom> I agree. Time to not do type-level programming in Haskell.
10:25:43 <drdo> monochrom: I don't want to
10:25:43 * nshepperd ponders
10:25:49 <monochrom> You don't even have lambda.
10:26:42 <nshepperd> the problem is that for type families, If b x y ~ If b1 x y doesn't imply that b ~ b1
10:26:49 <nshepperd> which messes up type inference
10:27:04 <nshepperd> even though liftIf doesn't really care what the b is :(
10:27:08 <drdo> nshepperd: But that particular case should be easy
10:27:59 <geekosaur> drdo, that's kinda the problem, "should be" isn't
10:28:19 <monochrom> The problem with people of strong convictions.
10:29:21 <drdo> nshepperd: Why doesn't simple unification work there?
10:29:26 <monochrom> The fact is, if you also add "x /~ y", then maybe you can infer b ~ b1, at least within your metalogic.
10:30:08 <drdo> monochrom: But I don't want to do that
10:30:28 <hackrilege> Hi, I'm having trouble with writing a Traversable instance for a cyclic data type, could anyone help?
10:30:36 <drdo> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
10:30:40 <monochrom> If False Void Void ~ Void ~ If True Void Void, therefore False ~ True?
10:30:51 <drdo> This example on the manual is even sillier
10:31:40 <drdo> monochrom: What are you talking about?
10:31:53 <monochrom> why b /~ b1 is a possibility.
10:31:58 <drdo> It is
10:32:05 <drdo> Nobody is saying it shouldn't be
10:32:09 <monochrom> OK, problem solved.
10:32:20 <drdo> Problem not solved
10:32:33 <drdo> monochrom: Please explain that example in the manual
10:32:42 <monochrom> I am too lazy to.
10:33:02 <drdo> I truly deeply don't understand how "Id t ~ Id t" is ever a problem
10:33:35 <drdo> It's intensionally the same
10:34:00 <drdo> *intentionally
10:34:20 <hackrilege> No
10:34:50 <hackrilege> The point of a type family is to say type Id a = r
10:35:00 <ij> `sed' has a s/1/2/g command. It takes a «g» or «i» flag in this case, but they're optional and sed doesn't tolerate multiple occurences of «g» flag. I can construct *a* parser that works like that, but is there a short megaparsec oneliner that would parse flags like that?
10:35:15 <hackrilege> It's up to the user to enforce then that r = a
10:35:26 <drdo> huh?
10:35:30 <hackrilege> Which is just a special case for this instance
10:35:47 <hackrilege> A type family associates one type to another
10:36:26 <hackrilege> So I could say, the index for a list is an Int. The point is to connect together two types that are different
10:36:48 <monochrom> ij: There is a function named "optional" somewhere.
10:36:51 <drdo> hackrilege: The point here is that it shouldn't matter what "Id t" is
10:37:20 <monochrom> Also an "option".
10:37:24 <hackrilege> The fact that a=r for type family Id is something that is enforced by the instances
10:37:52 <ij> monochrom, Just to be clear: I'm thinking of "gi"/"ig"/"i"/"g"/"" as good cases and "gig"/"gg" as bad ones.
10:38:05 <hackrilege> You could just as well implement it incorrectly and cast random types to each other, just calling out Id doesn't make it work perfectly
10:38:15 <monochrom> ho hum, then maybe "permutation" helps.
10:38:19 <drdo> hackrilege: I have no idea what you're talking about at this point
10:38:38 <monochrom> No, "permutation" doesn't cut it. I now think there is no ready-made function for this.
10:39:08 <hackrilege> The point is that so long as You can determine a from r then it checks
10:39:36 <lyxia> hackrilege: what's your datatype like
10:39:53 <hackrilege> That's my explanation, and there is one in the article, if you don't understand and I can't understand why not you will have to think of better questions
10:40:26 <drdo> hackrilege: Why on earth would you need injectivity to prove that Id t = Id t=
10:40:27 <drdo> ?
10:41:49 <hackrilege> lyxia, basically something like data CyclicList a = Cycle (CyclicList a) | Cons a (CyclicList a)
10:42:06 <hackrilege> Normally I can terminate a recursion my matching on Cycle
10:43:02 <lyxia> hm that looks tricky
10:43:19 <hackrilege> drdo, that's not how you write type family instances, you write them one at a time, and in this example only two are given so what you wrote isn't even true of this type family
10:44:06 <drdo> hackrilege: Do you understand that "Id t" is literally the same string as "Id t"?
10:45:16 <hackrilege> Only cases for Int and Bool are given, and they could just as well have been swapped in order, GHC does not know that you mean Id t = t when you only specify two cases
10:45:51 <lyxia> hackrilege: since you can't use mfix, fold to a (diff)list, and convert it back at the end.
10:46:01 <drdo> hackrilege: This has nothing to do with type families
10:46:08 <glguy> hackrilege: It doesn't matter that we're talking about the type family Id in particular
10:46:11 <drdo> Foo = Foo
10:46:14 <drdo> For any Foo
10:46:15 <glguy> for any type family, F t ~ F t
10:46:20 <glguy> where F is a type family
10:47:43 <glguy> The issue is just that we need some other way to determine what 't', it has to appear somewhere else
10:47:55 <hackrilege> lyxia, that works for this simple example but actually I have a complex Tree Zipper... :/ it's not isomorphic to list I don't think. My example structure is polystyrene
10:48:57 <hackrilege> drdo, sorry, I thought you asked for an explanation of the example in the link provided
10:49:28 <drdo> hackrilege: I did
10:50:13 <drdo> glguy: Can you elaborate on that?
10:50:23 <hackrilege> Why is the article itself insufficient explanation?
10:50:35 <glguy> drdo: Sure, which part
10:50:53 <drdo> glguy: I don't understand what the deal is with type families and inability to do simple unification
10:51:02 <lpaste> glguy pasted “for drdo” at http://lpaste.net/350975
10:51:31 <lyxia> hackrilege: polystyrene? The plastic thing?
10:51:59 <hackrilege> It has hexagonal rings along a linear backbone
10:52:24 <glguy> drdo: Can you show me an example of what simple unification issue you don't understand, I haven't been following the backlog closely
10:52:41 <hackrilege> I have a paste but it's kind of a work in progress, I'm not sure if some of my instances are right
10:53:08 <hackrilege> I could put it up anyway but I thought it might actually be easier to work without it...
10:53:15 <hackrilege> As it's a little long
10:54:35 <gfixler> I don't understand this monad morphism law: morph (return x) = return x
10:55:13 <gfixler> wouldn't return x :: m a, but morph (return x) :: n a?
10:55:15 <lyxia> hackrilege: I may look at it later.
10:55:26 <hackrilege> Ok I'll put it up
10:55:31 <hackrilege> One sec
10:55:38 <jmcarthur> gfixler: Note that the returns on either side have different types. morph_F_to_G (return_F x) = return_G x
10:55:40 <rekado_> carter: worked around the stack overflow by splitting up the module into three parts.  Hugs can’t deal with large modules.
10:56:06 <gfixler> jmcarthur: I don't see where the different types are encoded
10:56:20 <jmcarthur> gfixler: return is part of a type class. It's overloaded.
10:56:40 <hackrilege> lpaste.net/350976
10:56:43 <gfixler> jmcarthur: sure, but this is just return x on both sides
10:56:53 <gfixler> should be the same return if it's the same x, no?
10:57:01 <jmcarthur> gfixler: It's so-call "return type overloading".
10:57:04 <jmcarthur> *so-called
10:57:12 <jmcarthur> gfixler: The input type is the same, but the output type is different.
10:57:36 <gfixler> I can believe that, but it feels like information is missing in the equation
10:57:58 <jmcarthur> gfixler: It can tell what the return types should be because of morph and (==)
10:58:01 <gfixler> I see return x on each side, and then I see morph applied to one, changing its monad type
10:58:13 <hackrilege> Anyone that could help me with the traverse instance in that paste would be great
10:58:45 <jmcarthur> we know from morph that the left return should give a (F a), and we know the whole left side of the equation is a (G a), so the right side must be as well, so that return must return a (G a)
10:58:47 <gfixler> jmcarthur: that just clicked
10:59:09 <gfixler> so one side acts as the :: for the other
10:59:16 <jmcarthur> In a sense, yes.
10:59:28 <lpaste> drdo pasted “Example” at http://lpaste.net/5983315658702585856
10:59:32 <jmcarthur> :t asTypeOf   -- a direct application of this idea
10:59:34 <lambdabot> a -> a -> a
10:59:38 <drdo> glguy: http://lpaste.net/5983315658702585856
10:59:41 <gfixler> jmcarthur: was just going to say that
10:59:46 <jmcarthur> :t 5 `asTypeOf` (0 :: Integer)
10:59:47 <lambdabot> Integer
10:59:48 <jmcarthur> :t 5 `asTypeOf` (0 :: Int)
10:59:48 <gfixler> jmcarthur: or like idris' thing I forget
10:59:50 <lambdabot> Int
11:00:05 <hackrilege> Sorry dropped connection
11:00:58 <gfixler> jmcarthur: oh, I remember - `the`
11:01:36 <hackrilege> I'm aware some of the other instances are not prefect, but I'm not concerned about the traversable one which seems not to behave lazily
11:02:00 <glguy> drdo: You don't get to run run type families backward to figure out their arguments
11:02:18 <drdo> glguy: So what?
11:02:44 <glguy> drdo: So there's no way to know what type 'b' is in the type of liftIf
11:02:59 <drdo> glguy: b *is* a type
11:03:09 <glguy> with no way to know which type
11:03:15 <drdo> What do you mean?
11:03:42 <glguy> when you try to use liftIf somewhere, you'll never be able to determine which monomorphic type it has
11:04:25 <drdo> glguy: It doesn't have a monomorphic type
11:04:39 <glguy> It will if you ever want to use it
11:04:45 <glguy> like in the definition of foo
11:04:49 <drdo> glguy: The point is that b can be anything
11:05:02 <glguy> Yes, it can be anything, but it must be something
11:05:03 <drdo> So why on earth isn't (F t) ok?
11:05:13 <hackrilege> lyxia, do you see what I mean?
11:05:35 <glguy> drdo if we fix the ambiguity issue by adding proxy arguments,we run into a new issue with foo
11:05:49 <drdo> glguy: But where is the ambiguity?
11:05:55 <drdo> That's what I don't understand in the first place
11:06:02 <drdo> What's the issue here?
11:06:21 <glguy> The argument has type   If (F t) x Void, so we don't know whether its type is Void or x
11:06:43 <drdo> glguy: So what? So does map
11:06:47 <drdo> and id
11:06:50 <glguy> and until we know what F t resolves to we won't be able to reduce If (F t) x Void at all
11:07:22 <glguy> drdo: consider if you hadn't used type families at all and had: foo :: Either Void x -> x
11:07:32 <glguy> You'd have to consider the case when it was Void, or x
11:08:09 <glguy> In the case of your foo definition we don't get the opportunity to consider either case because we can never know what type F t will evaluate to
11:08:16 <hackrilege> Should I stop putting pastes up here?
11:08:18 <drdo> glguy: But why do you care?
11:08:42 <drdo> liftIf allows b to be anything
11:09:46 <lpaste> glguy annotated “Example” with “Example (annotation)” at http://lpaste.net/5983315658702585856#a350978
11:09:54 <glguy> drdo: You can do that
11:10:04 <glguy> or we can do it with type applications
11:10:38 <MarcelineVQ> hackrilege: sometimes people just don't have an answer :>
11:11:10 <lpaste> glguy annotated “Example” with “Example (annotation) (annotation)” at http://lpaste.net/5983315658702585856#a350979
11:11:21 <MarcelineVQ> those cases are great though because it means there's things to discover
11:12:49 <drdo> glguy: Oh, there's an extension to allow type application
11:12:51 <hackrilege> I guess as long as I can see this then I don't get disheartened
11:13:18 <drdo> glguy: That still doesn't answer the question though. My question isn't how to solve the problem. It's *why* is it ambiguous?
11:13:24 <lyxia> hackrilege: what's the meaning of "previous"
11:13:37 <glguy> drdo: when you use liftIf in foo like I was saying, you have to pick some particular monotype for it, in this case liftIf :: If (F t) x Void -> x
11:14:05 <glguy> That's not a normal type signature where the type variables are implicitly universally quantified
11:14:17 <glguy> that's one where the t and x are quantified by foo
11:14:47 <lyxia> hackrilege: can you describe an example of value you want to represent with this
11:15:23 <lyxia> hackrilege: like, a definition of a concrete TreeZiper
11:15:40 <hackrilege> lyxia, it's like the concept of zipper for lists, navigating around moves the nodes you pass to lie behind you, there is a little example navigation at the bottom
11:16:00 <drdo> glguy: What do you mean that's not a normal type signature?
11:16:16 <lyxia> hackrilege: I am familiar with zippers in general
11:16:23 <drdo> glguy: By the way, the example with type application doesn't work, says 't' is not in scope
11:16:31 <drdo> nevermind, forgot to enable scopedtypevars
11:16:58 <drdo> glguy: This is even more puzzling to me though
11:17:03 <hackrilege> Right, so simply extend to cyclic lists and try not to get lost! (That's what the Int contexts are for)
11:17:09 <glguy> drdo: When you try to use liftIf as the definition of foo, the type checker tries to unify:   If (F t) x Void -> x,  and If b y Void -> y
11:17:20 <drdo> right
11:17:27 <glguy> So it can figure out x~y from matching the result of the function, so that's good
11:17:51 <glguy> but that leaves it trying to unify   If (F t) x Void and   If b x Void, but now we're stuck
11:17:57 <drdo> We are?
11:17:58 <glguy> If can't evaluate any further
11:18:05 <lyxia> hackrilege: does Cycle always refer to the root of the tree?
11:18:08 <drdo> Why isn't "b = F t" ok?
11:18:12 <glguy> no
11:18:19 <drdo> But why?
11:18:42 <drdo> b is a normal unconstrained variable
11:18:44 <glguy> Type families in general aren't injective, so F a ~ F b doesn't mean a ~ b
11:18:58 <Tuplanolla> This is analogous to functions, drdo.
11:19:00 <drdo> glguy: So what?
11:19:01 <glguy> The type checker isn't trying to find any arbitrary solution that happens to work
11:19:03 <hackrilege> lyxia, no, later I'm going to make it so its a navigation from the node where the Cycle appears, or is added during growth
11:19:12 <glguy> it's trying to determine types that are exactly equal
11:19:26 <brandonbyskov> What's the appropriate haskell IRC channel for questions about category theory?
11:19:26 <glguy> maybe x was Void, b was True and F t was False
11:20:17 <glguy> Only types that are definitely equal are unified, type families don't offer that
11:20:32 <drdo> glguy: Then why does GHC happily accept "id' = id ∷ Int → Int"?
11:21:11 <geekosaur> where's the type family there?
11:21:15 <glguy> There's no type family there, and (->) is injective
11:21:26 <glguy> so  if     a->a  ~   Int -> Int, then a ~ Int
11:22:11 <MarcelineVQ> glguy: this conversation is really very interesting, is there a good resource about type families in haskell in addition to the ghc manual?
11:22:21 <MarcelineVQ> *learning resource
11:23:13 <hackrilege> Care should be taken to ensure reference to the Cycle appears in two places with opposite navigation, I'll do it after I get the traversable done
11:23:33 <drdo> glguy: How about "id' ∷ F t → F t" ?
11:23:33 <Unode_> Speaking of learning resources, does anyone know any haskell exercises for which one is given an incomplete/broken piece of code that you have to debug/fix ?
11:23:51 <drdo> (changing the kind of F t to ★)
11:23:55 <drdo> GHC accepts that
11:24:41 <drdo> Why can it suddenly unify 'a' with 'F t'?
11:24:47 <glguy> MarcelineVQ: There might be, but I don't know what to it is. Maybe someone else can offer something
11:25:00 <glguy> drdo: Maybe you can paste your new version
11:25:27 <Liskni_si> Unode_: github issues? :-)
11:25:50 <Unode_> Liskni_si: I was hoping for something a bit more "newbie friendly" :)
11:26:32 <lpaste> drdo pasted “No title” at http://lpaste.net/9177484567609606144
11:28:00 <glguy> drdo: This works because you turned off the ambiguity check
11:28:09 <Unode> I'm basically learning haskell by reading books but sometimes the examples are not intuitive. Feels like I'm learning something for the sake of learning. I.e. I don't actually grasp where/when/how will I be using said concept.
11:28:20 <drdo> glguy: I also turned it off on the other one
11:28:25 <drdo> And it still doesn't work
11:28:43 <drdo> glguy: And I still don't understand what the ambiguity is :P
11:29:22 <glguy> We're trying to use   id with type   a -> a    to implement   F t -> F t, so we can set a ~ F t
11:29:27 <drdo> This seems to me to be a simple case of a universal quantifier being instantiated
11:29:31 <glguy> but now we have no way to know what t was
11:29:47 <glguy> so we'll never be able to use id' without type applications
11:30:07 <drdo> glguy: Why not?
11:30:41 <drdo> id' ∷ ∀t. F t → F t
11:30:46 <drdo> I don't understand what the issue is :S
11:31:40 <glguy> example :: F t -> F t; example = id'
11:31:43 <glguy> consider this example
11:32:01 <glguy> We have to unify example's type:   F t -> F t   with id' renamed type:   F u -> F u
11:32:10 <drdo> Right
11:32:20 <glguy> OK, so -> is injective, so we know that F t will need to equal F u
11:32:39 <drdo> yep
11:32:43 <glguy> Now we're stuck, no way to learn about t or u
11:32:51 <glguy> because F can't evaluate any further
11:33:00 <glguy> type families aren't injective
11:33:30 <glguy> It could be the case later that type instance F Int = Bool   and type instance F Char = Bool, or not
11:33:36 <glguy> nothing requires u and t to be equal at this point
11:33:44 <glguy> and we have no way to learn anything about them
11:33:45 <drdo> glguy: But there is a clear unifier
11:34:04 <drdo> Just replace u with t
11:34:29 <glguy> The type checker doesn't do guessing
11:34:44 <drdo> glguy: What guessing?
11:34:44 <glguy> it works with things that must be equal
11:35:06 <glguy> with type families it's not necessary for u to equal to t for F u to be equal to F t
11:35:24 <nitrix> Add a type equality c:
11:35:48 <carter> @tell rekado cool / woah
11:35:48 <lambdabot> Consider it noted.
11:35:57 <carter> I wonder how big the nhc module is
11:35:57 <glguy> the unifier isn't trying to find an assignment that works, it's tryingto find the one true assignment
11:36:06 <glguy> and in this case there isn't one
11:36:29 <drdo> glguy: Oh, I think I get it
11:38:00 <drdo> glguy: Requiring u~t is too strong
11:38:10 <glguy> yes
11:38:49 <drdo> It's not in this case though, since both are unconstrained variables
11:38:56 <drdo> But I guess there are no checks for that
11:39:44 <drdo> Well, that's probably part of what the AllowAmbiguousTypes thing does
11:40:58 <glguy> allow ambiguous types allows you to defer resolution of the ambiguity at the use sites of the definition
11:46:09 <hackrilege> I guess somehow when I'm fmaping the constructor Cycle into the traversed version of the tree it breaks the ability to lazily evaluate part of the contents and it gets stuck in a loop...
11:48:09 <hackrilege> fmap show $ traverse return eg
11:48:51 <hackrilege> lpaste.net/350976
11:49:25 <hackrilege> I'll try and put together a minimal example...
11:55:41 <drdo> glguy: It turns out I still don't understand why this is a problem when type *checking* with explicit signatures
11:56:17 <glguy> OK, show a problematic example that we can talk about
12:00:40 <MarcelineVQ> glguy: thank you anyway :>
12:08:06 <hackrilege> paste.net/350980
12:08:25 <hackrilege> That should be an easy error, but I can't figure it out :(
12:10:21 <glguy> hackrilege: :+ fixity is different from how you're using it
12:10:50 <hackrilege> fixity!?
12:11:51 <hackrilege> Can I fix it with a prescidence indicator?
12:12:20 <hackrilege> precedence*
12:14:14 <geekosaur> we call those parentheses :p
12:14:31 <hackrilege> infixr 6 :+ got it
12:15:58 <t7> how do modern language parsers do precedence & operators?
12:16:13 <t7> parsing-wise
12:17:07 * EvanR wonders if haskell counts as modern
12:17:35 * suzu shakes head
12:17:45 * suzu asserts that modern =/= good
12:17:47 <t7> whates the state of the art in parsing ?
12:18:10 <suzu> maybe an earley parser?
12:18:11 <t7> and is everything context free?
12:18:25 <suzu> most programming languages are, yes
12:21:39 <hackrilege> Ok,
12:41:51 <hackrilege> Ok, here is a minimal example of the hanging traversable cyclic thing, lpaste.net/350980
12:43:44 <Gurkenglas> hackrilege, does it also crash when you use the Identity monad instead?
12:43:54 <Gurkenglas> of IO
12:44:28 <hackrilege> I'll check, hang on
12:45:20 <Gurkenglas> (just running my personal shrink)
12:46:05 <hackrilege> It works!
12:46:56 <hackrilege> Damn all that for such a simple bug, cool anyway I'll check to see if it works for the cyclic tree zipper
12:47:25 <hackrilege> Also, any idea how to write the applicative instance for CyclicTree?
12:47:44 <hackrilege> CyclicList*
12:48:53 <Guest4981> Hey guys i have a Problem, i want a datatype like this : "data Eq a => foo a = F [a]" but i get an error when i use this
12:49:08 <Guest4981> can someone help me ?
12:49:49 <Ferdirand> datatypes need to start with a capital letter
12:50:10 <Ferdirand> and constraints on data definitions do not work as you would expect
12:51:23 <Guest4981> ok the capital letter was a copy mistake :-) but what to you mean with it work not like i expect it... how do i define a comparable wildcard then ?
12:51:38 <hackrilege> Try data Foo a where F :: Eq a => [a] -> Foo a
12:52:02 <t7> Guest4981: put the constraints on the functions usually 
12:54:35 <Guest4981> hmhm it still doesnt work with this code, i try to understand what it does 
12:54:51 <hackrilege> The one I put?
12:55:08 <Guest4981> jup
12:55:49 <Guest4981> i got an "Illegal generalised algebraic data declaration for ‘Foo’" when i use this
12:56:08 <Guest4981> and i dont know where the F is actually defined in the data
12:56:24 <hackrilege> @let data Foo a where F :: Eq a => [a] -> Foo a
12:56:26 <lambdabot>  .L.hs:168:1: error:
12:56:26 <lambdabot>      Multiple declarations of ‘Foo’
12:56:26 <lambdabot>      Declared at: .L.hs:165:1
12:56:35 <hackrilege> @undefine
12:56:36 <lambdabot> Undefined.
12:56:37 <EvanR> that error usually also says "enable the extension -XGADTs
12:56:42 <hackrilege> @let data Foo a where F :: Eq a => [a] -> Foo a
12:56:44 <lambdabot>  Defined.
12:57:24 <hackrilege> If you type :set -XGADTs in ghci then it should work
12:57:45 <hackrilege> Or language pragma syntax in your source code
12:58:14 <Guest4981> nice
12:58:20 <Guest4981> it works !!!!
12:58:36 <hackrilege> https://wiki.haskell.org/Language_Pragmas
12:58:41 <hackrilege> Cool!
12:59:27 <hackrilege> Yeah that DatatypeContexts generally considered a misfeature message seems dumb since there is equivalent syntax in GADTs
13:00:45 <hpc> there's a rather critical difference though, between datatype contexts and GADT contexts
13:01:03 <Guest4981> i just need to understand how your code works :-D, what function has the "where F" in this code snipet ?
13:03:13 * hpc lpastes
13:07:29 <geekosaur> someone needs to explain to hackrilege the difference between GADTs and datatype contexts, and why the latter are nearly useless (and can't be made non-useless)
13:07:34 <geekosaur> of course they left...
13:09:43 <hpc> http://lpaste.net/1634796777720774656
13:10:09 <hpc> Guest4981: ^ for you and hackrilege
13:10:44 <Guest4981> thanks man
13:11:37 <hpc> the significant bit is that what GADTs give you is the ability to gain type information out of pattern matching
13:12:12 <hpc> in this case matching on (F xs) :: Foo a is going to add (Eq a) for the expression behind that match
13:12:14 <Guest4981> now i understand this, awesome :-)
13:12:30 <hpc> and it can do this for both types and classes
13:13:23 <hpc> if you had something like data Foo a where BoolFoo :: Foo Bool, it would add the equality constraint (a ~ Bool) when you matched on BoolFoo
13:13:39 <hpc> and that's pretty much the whole extension
13:14:22 <Guest4981> and this extention was what i needet :-D
13:16:00 <zipper> Can anyone see why Line 20 here causes this function to run forever http://lpaste.net/6921674439880867840#line20 ?
13:17:31 <glguy>                      | otherwise = times f' (s - 1) (result + f')
13:17:36 <glguy> s should be s'
13:20:02 <zipper> glguy: LOL
13:20:05 <zipper> F me!
13:20:34 <zipper> I have been staring at it for so long, even did it on paper
13:21:05 <zipper> hahahahaha 
13:21:10 <Gurkenglas> Another point for pointfree style!
13:21:45 <dolio> Or shadowing.
13:25:09 <hpc> there have been some pretty entertaining discoveries from that sort of bug though
13:25:15 <hpc> like the reverse State type
13:25:42 <hpc> er, i guess reverse State monad because the type is technically the same
13:30:11 <ongy> reverse state monad? that sounds weird
13:30:50 <geekosaur> http://hackage.haskell.org/package/tardis
13:32:31 <hpc> ongy: basically, the observation was that in the (>>=) definition for State there is a let (s', a) = ...; (s'', a) = ...
13:32:39 <hpc> where you have s, s', s'' all of the same type
13:32:58 <hpc> and you can mix it around a bit so that it's still valid with the ss going in reverse
13:33:11 <Guest4981> hpc thanks for your help i leave now :-) bye
13:33:12 <hpc> and it ends up being a form of recursion instead of just threading forward
13:33:38 <hpc> obviously it becomes extremely easy to write bottoms
13:33:46 <hpc> but you can write things like
13:33:51 <dolio> I think backwards state Applicative might be more fundamental.
13:33:53 <hpc> foo = do
13:33:56 <hpc>   x <- get
13:33:58 <hpc>   put 4
13:34:02 <hpc>   return x -- x = 4
13:34:22 <hpc> dolio: perhaps, i haven't looked at that as closely
13:34:48 <dolio> When you consider Applicative, it's kind of obvious that you can run the state either way (because every Applicative has a dual where you sequence the actions in the opposite order).
13:35:19 <dolio> And you can't implement the monad in a language without general recursion (and laziness, I think).
13:35:41 <hpc> ah
13:35:41 <dolio> But the Applicative doesn't need general recursion.
13:36:03 <ongy> this looks cool, but is there any real use to it?
13:36:24 <dolio> ongy: Did you know that mapAccumL is mapM for State?
13:36:36 <dolio> mapAccumR is mapM for backward state.
13:36:47 <hpc> :t mapAccumL
13:36:49 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:37:35 <hpc> anyway as for the tardis type, it just is able to go forward and backward
13:41:34 <M-berdario> Does anyone here have experience with using mtl for effect tracking? (that is, instead of using a concrete transformer stack with IO, or MonadIO... you define typeclasses for any interaction with the real world)
13:42:03 <EvanR> hpc: no side 2 side?
13:42:50 <Gurkenglas> :t [mapAccumL, mapAccumR] -- theres your side-to-side
13:42:52 <lambdabot> Traversable t => [(a -> b -> (a, c)) -> a -> t b -> (a, t c)]
13:43:11 <dolio> M-berdario: I've done it, but not for IO stuff.
13:44:07 <M-berdario> dolio: uh, maybe you can give me some hints, then? https://gist.github.com/berdario/c7a640d4c45c973fef1960b121d8cc95
13:45:16 <M-berdario> I wrote some code (actually, I opened a whole thread on Reddit about it, but I'm afraid that the wall of text was too much, since I haven't got any replies) and I managed to get it working... but when trying to use it "for real", when testing... I found that the different choices were not equally comfortable
13:46:27 <Liskni_si> M-berdario: not sure whether it's relevant but your use case reminds me of https://hackage.haskell.org/package/freer
13:46:34 <M-berdario> dolio: basically, these 3 Eff classes are just representing something like "readFile", in which I want to track the possible error condition with a MonadError constraint
13:46:46 <Liskni_si> (which may make what you're trying to do easier, or more difficult; hard to tell :-))
13:47:10 <dolio> M-berdario: Why MonadError SomeException?
13:47:21 <dolio> Why not Void?
13:47:28 <M-berdario> dolio: I'd prefer `MonadError e`
13:47:37 <M-berdario> dolio: why void?
13:47:59 <dolio> Because Void is the argument type you said you wanted there.
13:48:12 <M-berdario> Liskni_si: yeah, that's interesting... in the future I would also try out Extensible Effects type approaches...
13:49:01 <dolio> In the comment.
13:49:10 <M-berdario> dolio: well, I just want to use Void in a mocking instance of that class... 
13:49:22 <M-berdario> but since I cannot do it, I can either use `undefined` or write the class differently
13:49:47 <dolio> Why can't you do it?
13:49:50 <glguy> MonadError is for making it possible to throw even more errors, not for taking which errors are possible
13:50:14 <M-berdario> dolio: types don't unify
13:50:27 <dolio> Which types?
13:50:47 <M-berdario> SomeException and Void
13:51:05 <dolio> But aren't you the one who wrote SomeException?
13:51:15 <dolio> Why didn't you write Void in that spot instead?
13:51:39 <monochrom> The left brain wants Void, the right brain wants SomeException.
13:51:58 <M-berdario> dolio: because I cannot write `MonadError e m`, because of the functional dependency of e on m
13:52:24 <M-berdario> so, a solution is to use `Eff3`, which keeps the MonadError outside (in fact it's not even in the gist)
13:52:35 <dolio> Well, if you wrote 'e' instead, you couldn't use Void in throwError, either.
13:52:49 <dolio> You'd be using 'e'.
13:53:14 <M-berdario> yeah, I think you might be right... I just haven't had the chance to try it :)
13:53:46 <M-berdario> glguy: that's the first time I heard that concept, or at least stated in that way
13:54:17 <dolio> Oh I see. The problem is that MonadError SomeException is in the context of Eff1, too
13:54:52 <M-berdario> yeah.. the poin is: I want to write Eff to represent "readFile", since "readFile" can fail I want to put that in the type somewhere
13:55:14 <M-berdario> there are 3 places: constaint on the class, constraint on the function inside the class, constraint on usage site
13:55:26 <M-berdario> anyone could work
13:56:23 <dolio> M-berdario: Eff2 is almost certainly wrong. That says that f2 can throw any exception type desired by the caller of f2.
13:56:35 <dolio> The 'e' should be SomeException like Eff1.
13:56:49 <ph88> hi guys, how can i find out how this library uses these functions? and where they are being called?  https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L344-L347
13:57:57 <M-berdario> dolio: uhm... if the caller is in IO, e would be SomeException, if the caller is some mock Monad, it could be something else
13:58:45 <M-berdario> it sounds reasonable, but on further thoguht... If I got a different `e` type... what's the value in checking its value insdie the tests? 
13:58:50 <dolio> M-berdario: Anyhow, your choices are to make MockIO able to shuffle around exceptions, or to not use MonadError as a precondition, and add 'catch' to your Eff1.
13:58:51 <lyxia> ph88: look at the type class instances and the runParsec functions?
13:59:03 <dolio> The problem for you is that you only care about catching and not throwing, I think.
13:59:26 <dolio> Only the prim ops are allowed to throw.
13:59:36 <M-berdario> yeah
13:59:47 <dolio> So mtl isn't factored enough for your needs.
13:59:49 <M-berdario> of the 3 options that you just described
14:00:04 <M-berdario> 1 )make MockIO able to shuffle around exceptions, 2) to not use MonadError as a precondition, 3) add 'catch' to your Eff1
14:00:12 <dolio> You might want to test the behavior when things throw anyway, though.
14:00:16 <M-berdario> which one is the most reasonable, in your experience?
14:00:19 <dolio> So maybe you should just make your mock a little more featureful.
14:00:32 <M-berdario> yeah
14:04:00 <M-berdario> anyhow, the frustrating thing for me is that I haven't found many examples of doing this kind of things
14:04:23 <M-berdario> documentation, blog posts, books
14:04:26 <M-berdario> I got interested in trying this out after reading this:
14:04:31 <M-berdario> https://lexi-lambda.github.io/blog/2016/10/03/using-types-to-unit-test-in-haskell/
14:04:40 <dolio> M-berdario: Unfortunately, I don't think people think about using mtl this way.
14:04:57 <dolio> And all the extensible effect stuff got popular, but this is really equivalent to it.
14:05:37 <M-berdario> but this is just a toy example... real world code has Errors to be handled
14:05:41 <M-berdario> yeah
14:06:31 <xcmw> I have an ambigous kind problem. Does anyone know how to fix it? http://lpaste.net/350970
14:08:05 <M-berdario> anyhow, this is the Spec.hs that I wrote for the actual project:
14:08:09 <M-berdario> https://github.com/berdario/jira2sheet/blob/master/test/Spec.hs#L152
14:08:41 <M-berdario> (only the 1st and 3rd) tests are actually testing effects stuff
14:09:40 <M-berdario> (in the 1st, every time I do a `getWith`, I log the startparam... and then check that the sequence was `[0,4,8,10]`
14:10:57 <M-berdario> in the 3rd, I use a `data Event = Authorize | Refresh | Write FilePath`, and the state is `[Event]`, and I check that the sequence of events is the expected one)
14:11:39 <lexi-lambda> M-berdario: I would not recommend mocking MonadError or MonadThrow, honestly. I’ve found it’s easier to put TestFixtureT in a stack around Except.
14:12:05 <ph88> lyxia, you mean runParser ?   i get confused because runParserT calls runParserT' https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L1049  and runParserT' calls runParserT https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L1062
14:12:50 <M-berdario> oh, hi! yeah... it's less painful (but I was not sure if it was only because test-fixture was designed like that)
14:13:16 <M-berdario> lexi-lambda: are you aware of other examples of people using test-fixture?
14:14:40 <lexi-lambda> Currently, no… other people might be, but aside from you (from reporting issues) and us using it internally, I don’t know if other people are using it.
14:17:10 <lexi-lambda> My rule of thumb is to avoid mocking out classes that involve changing control flow. Mock out things that are semantically I/O effects, but generally stuff that alters control flow is easier to test by using the relevant monad transformer directly.
14:18:33 <M-berdario> lexi-lambda: I see. Are you also aware of people using mtl for tracking effects (even if not with the goal of testing stuff with pure instances)?
14:19:47 <M-berdario> if you have any suggestions for me on how to clean up my code, I was also thinking that it might be useful to leave it somewhere/point at it as some example for your library
14:20:48 <lexi-lambda> Yes, I’ve talked to people who have told me they have done similar things, though I’m not sure how popular that style is compared to using free monads in 2017. IMO the mtl style is simpler for a lot of use cases, but they have pros and cons.
14:22:39 <srhb> lexi-lambda: Stoked about Hackett! Didn't know you were in this channel. That's all. :-)
14:22:59 <M-berdario> yeah... I found starting with mtl (without any real prior experience with mtl or free monads) easier, just because I've already had exposure to the classes defined in mtl in several codebases
14:24:40 <lexi-lambda> srhb: Thank you! I’m actually sort of not in this channel… I barely even look at it unless I get pinged. Which I did, from my other blog post getting posted. :)
14:27:42 <lyxia> ph88: runParserT = ... runParserT'  ;   runParserT' = ... runParsecT
14:27:52 <lyxia> ph88: rT rT' cT
14:28:25 <lexi-lambda> M-berdario: We mostly don’t use mkFixture with typeclasses from other libraries, honestly, we define our own mtl-style typeclasses and wrap other libraries in simpler interfaces. That’s a subjective decision, though, so you might be able to make it work more directly.
14:29:46 <M-berdario> lexi-lambda: I see, I ended up doing the same in my code (but I just realized that I left there a stray MonadThrow that is not in use anymore)
14:30:11 <M-berdario> thanks again for test-fixture, btw :)
14:32:30 <lexi-lambda> I’m glad you’re getting some use out of it! Your bug reports have been helpful; I think the new interface using the ts quasiquoter is a lot better.
14:35:07 <M-berdario> :) I just wish I could use Haskell at work for web stuff, to apply all of these tools that I enjoyed in side projects
14:39:17 <maerwald> I wish there was no web stuff
14:40:47 <xcmw> I have an ambigous kind problem. Does anyone know how to fix it? http://lpaste.net/350970
14:41:55 <lpaste> xcmw revised “Ambiguous kind problem”: “Ambiguous kind problem” at http://lpaste.net/350970
14:59:24 <xcmw> Will I have to use proxies or VTA at the type level?
15:07:09 <xcmw> xcmw: Is it even possible to fix
15:17:34 <ph88> does anyone know how to find out if any input was consumed by a parser in megaparsec ?
15:26:28 <ph88> what does   \v -> fmap (:) v  do ?
15:27:12 <jle`> ph88: for parsers?
15:27:28 <ph88> i'm looking at the implementation of  many
15:27:37 <ph88> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#many
15:27:40 <jle`> ph88: it takes a parser that parses a value of type 'a', and returns the same parser but applies (:) to 'a' before it returns it
15:27:48 <jle`> *it returns the result
15:28:44 <ph88> i'm trying to make a new  many  parser with the following logic:  if argument parser fails then many fails, if it succeed and consume input then try again, if it succeed but consume no input then fail
15:29:52 <ph88> so it creates a list of parser functions ?
15:30:27 <geekosaur> it turns a parser for <something> into a parser of lists of <something>, very roughly
15:31:01 <ph88> oooh because of fmap
15:31:03 <ph88> ok got it
15:31:18 <jle`> (\v -> fmap (:) v) would turn a parser of <something> into a parser of <a function that conses something to the start of an input list>
15:31:54 <jle`> if 'x' would normally parse a 1, fmap (:) x would return ((:) 1), or (\xs -> 1 : xs)
15:32:14 <jle`> i guess it turns a parser of an item into a parser of a prepender
15:32:38 <jle`> oh sorry my comment is outdated
15:42:19 <ph88> can someone give me some feedback on this code?  https://paste.fedoraproject.org/522138/32476148/  i didn't try to compile it yet, but just to check my way of thinking
15:54:43 <wespiser> ph88: sure, I'll take a look!
15:54:51 <ph88> ok thx
15:55:00 <xcmw> Can some help me fix this error? http://lpaste.net/350970
15:55:39 <wespiser> ph88: within a 'do' block, you don't need to run a case statement when the candition of the case is the same type as the do block
15:56:25 <wespiser> ph88: lines 4-6 are essentially handled by the definition of the monad bind function for Either
15:56:50 <wespiser> (>>=) (Left x) f = Left x
15:57:02 <wespiser> (>>=) (Right x) f = Right $ f x
15:57:46 <ph88> you want me to put >>= in a do-block?? i never seen that before
15:58:27 <ph88> by the way i see i forgot  Right on line 9 and 11
15:59:16 <EvanR> >>= in a do block for fun and profit
15:59:19 <wespiser> ph8: " do{x <- fn; return x;}" => fn >>= (\x -> return x;) 
15:59:40 <wespiser> ph88: the do block is desugared into bind
16:00:08 * Axman6 uses >>= and =<< in do blocks all the time
16:00:36 * Clint nods.
16:00:42 <EvanR> in d{x <- foo; ... foo is an "m a". a chain of >>= or =<< or >=> all produce an "m a"
16:00:59 <EvanR> gotta love referential transparency
16:01:11 <ph88> ok but i need to check if it's Left or Right
16:01:20 <Axman6> pattern match or use either
16:01:32 <ph88> p >>= case   ?
16:01:35 <EvanR> or use lambda case!
16:01:39 <EvanR> p >>= \case
16:01:57 <Axman6> which is sugar for  p >>= \x -> case x of ...
16:02:11 <EvanR> or that if you dont want to use the extension
16:02:18 <EvanR> LambdaCase
16:02:56 <EvanR> do
16:02:59 <EvanR>   x <- p
16:03:01 <EvanR>   case x of
16:03:06 <EvanR> hurts my soul
16:03:22 <justatech> what is dl.hexchat.com what is dl in here instead of www
16:03:38 <ph88> this hurts mine https://paste.fedoraproject.org/522161/83833790/
16:03:49 <ph88> 1 line less but a lot of stuff moved to the right
16:03:57 <EvanR> yeah why is that indented so far?
16:04:18 <EvanR> i usually put 2 spaces more on the next line
16:04:21 <ph88> well i learned you have to put the cases to the right of the case keyword
16:04:25 <EvanR> beyond the previous indentation
16:04:32 <EvanR> you dont
16:04:49 <wespiser> ph88: write it w/o the case statement!
16:04:54 <ph88> justatech, it's just a subdomain, www is there for historical reasons but it's not special
16:05:16 <EvanR> since youre doing Left x -> Left x, thats just fmap
16:05:22 <justatech> ph88 :)
16:05:27 <wespiser> ph88: you don't need lines 3,4,5
16:05:47 <M-berdario> ph88: Maybe you could also make use of something like https://www.stackage.org/haddock/lts-7.14/monad-loops-0.4.3/Control-Monad-Loops.html#v:unfoldWhileM
16:06:22 <ph88> there is a more fundamental problem i think as well .. the last line tries to   x : many2 p    but many2 p  return Either .. so that's not gonna cons
16:07:00 <EvanR> you cant return Right something OR x : something
16:07:03 <M-berdario> something like `map fst . unfoldWhileM (\_ p1 p2 -> p1 == p2) `
16:07:22 <EvanR> you need to wrap it in Left or Right
16:07:27 <EvanR> at least
16:07:34 <wespiser> ph88, try using an fmap in the last line?
16:08:36 <M-berdario>  (x : )  <$> many2 p
16:09:15 <M-berdario> btw, why there's a need to extract sourceLine and sourceCol ?
16:10:02 <M-berdario> if those are the only 2 attributes in the record (is it a record?), you could just make it an instance of Eq (which is what I'd rely on in my snippet a few lines above
16:11:10 <ph88> this is my latest version https://paste.fedoraproject.org/522176/34231148/
16:11:22 <ph88> didn't understand the stuff about unfoldWhileM by the way
16:11:50 <ph88> M-berdario, https://hackage.haskell.org/package/megaparsec-5.1.2/docs/Text-Megaparsec.html#t:SourcePos
16:12:07 <ph88> yeah i see i can compare them directly ^^
16:12:30 <ph88> the sourceName doesn't change
16:12:52 <ph88> or actually it could change but then the comparison is like it should be
16:14:03 <M-berdario> another alternative could be to `pos2{sourceName="something that you know is fixed"}`
16:14:55 <M-berdario> (set the sourceName, to ensure it's the same ... )
16:15:52 <M-berdario> anyhow, do you understand the type signature of unfoldWhileM ?
16:16:34 <ph88> totally not
16:16:37 <isovector> anyone ever look at fix points on comonads? i'm trying to make pascal's triangle but it loops forever :/ https://gist.github.com/isovector/cd4660c784689077b0750664404e6be2
16:17:35 <ph88> M-berdario, ok i looked at it, don't see how that applies here !
16:17:57 <M-berdario> ph88: Monad m => (a -> Bool) -> m a -> m [a] 
16:17:57 <M-berdario> it means it takes a function to decide when to stop extracting values (\_ p1 p2 -> p1 == p2)
16:17:58 <M-berdario> and a monadic action m a
16:20:10 <M-berdario> https://matrix.org/_matrix/media/v1/download/matrix.org/gbVmaULCauIBJaaJePOmMXWJ - M-berdario_2017-01-08_00:19:47.txt
16:20:52 <M-berdario> do {pos1 <- M.getPosition {- its sourceName is "whatever"-}; x <- p pos2 <- M.getPosition; return (x, pos1, pos2{sourceName="whatever"})}
16:21:17 <M-berdario> (the Right/Left stuff is missing from here)
16:23:04 <M-berdario> (but you just need to `sequence` its result)
16:24:58 <M-berdario> :ty \(x :: [Either String Int]) -> sequence x
16:25:42 <M-berdario> :t \(x :: [Either String Int]) -> sequence x
16:25:44 <lambdabot> [Either String Int] -> Either String [Int]
16:29:10 <ph88> M-berdario, you mean something like this?  https://paste.fedoraproject.org/522213/48383531/
16:36:57 <M-berdario> ph88: something like this
16:36:58 <M-berdario> https://paste.fedoraproject.org/522228/
16:37:43 <mbeid> Has anyone used Content-Type “application/xml” with servant?
16:38:46 <M-berdario> a better name for `check` would be `arePositionsDifferent`, or `areNotSamePosition`
16:39:05 <M-berdario> anyhow, I'm afraid that my didactic approach is a bit poor :/
16:39:17 <ph88> @pl sequence . map
16:39:17 <lambdabot> sequence . map
16:39:42 <Clint> @src mapM
16:39:42 <lambdabot> mapM f as = sequence (map f as)
16:39:48 <ph88> it's nice to get some ideas :)
16:41:01 <xcmw> Can someone help me fix this error? http://lpaste.net/350970
16:46:03 <slack1256> on the green threads post, it is said that IO action on haskell are non-blocking
16:46:20 <slack1256> maybe I don't understand whay they mean with non-blocking, but recv on a socket look really blocky
16:46:59 <geekosaur> slack1256, the socket is set non-blocking. what you are actually seeing is that threadWait{Read,Write} deschedule your thread until the socket becomes ready for read or write, respectively
16:47:19 <Clint> xcmw: presumably nobody knows what you're trying to do
16:48:12 <slack1256> geekosaur: so it is making recv (on ghc lingo) a syncronization point
16:49:58 <xcmw> Clint: Have the code not error :)
16:50:42 <xcmw> and be polykinded. I don't understand it either.
16:51:47 <xcmw> Why does it work when I replace et with Field?
16:52:34 <geekosaur> slack1256, roughly. instead of letting recv prevent *any* green thread from running, other threads can run and the I/O manager periodically uses select or epoll or etc. to see if the socket has data to read; only when it does, will your thread run again
16:57:07 <slack1256> Mmm maybe I lack experience with how C does it, but I thought every lang did it that way
16:57:18 <nshepperd> wait - does that mean that when doing ffi stuff with multiple haskell threads, you should avoid calling blocking ffi calls? because they will block _all_ haskell green threads
16:57:33 <geekosaur> C just calls the recv system call, which blocks in the kernel
16:58:03 <geekosaur> which means no userspace code for the process can run at all, unless you have used pthreads (which are machine threads, not green threads)
16:58:25 <glguy> nshepperd: Or use the threaded runtime
16:58:56 <xcmw> Do type level proxies exist (a type which holds a kind)?
16:59:20 <geekosaur> nshepperd, even without the threaded runtime, ghc uses a few machine level threads --- one of them will run ffi calls that are marked "safe" thus requesting extra handling to ensure things work even if they block or allocate memory, etc.
16:59:29 <slack1256> I got a more clear view on the subject know, I will keep investigating. Thanks geekosaur
17:00:05 <geekosaur> if it's marked "unsafe", it just calls it --- if it blocks, you lose.
17:02:03 <nshepperd> ah, so it has a special os thread for calling ffi with
17:02:32 <nshepperd> and if you do many ffi calls at once it just sort of queues them up on that thread, or?
17:04:10 <glguy> It can make additional threads
17:06:10 <nshepperd> cool
17:08:09 <kennysp> in parsec is it possible to get characters that the current parser removed from the stream to complete parsing?
17:08:35 <geekosaur> slack1256, fwiw some languages work the way ghc does, some do not. perl, python, and ruby work the way C does and the only way you get threads is by creating them (and for at least python and perl, this means creating a new language context separate for each thread; neither language threads at all well)
17:08:54 <geekosaur> kennysp, you may want the "try" combinator
17:09:33 <geekosaur> if you wrap a parser in "try" and the parser fails, the parser state is unwound to before the failing parser ran so you can re-parse past whatever it failed on
17:09:45 <geekosaur> (note that backtracking in this way is somewhat expensive_
17:10:37 <kennysp> geekosaur I'm not trying to unwound, I want to get all the characters that hte parser used to complete parsing. parser = do {- some parsing -} {- parsing succeeded, can I get all the characters removed from the stream in here? -}
17:11:43 <kennysp> oh, did you mean to try to slurp everything before attempting to parse?
17:11:46 <geekosaur> this sounds like what ph88 was asking for earlier... but I'd guess you can use the same mechanism try uses underneath to save both the starting and ending parser states and then reparse by looping on anyChar until you get back to the ending state
17:12:02 <glguy> kennysp: Depends on the parser. attoparsec can do that, for example http://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString.html#v:match
17:12:13 <kennysp> glguy can parsec do it?
17:13:01 <glguy> I don't think it can do it efficiently
17:13:34 <glguy> You could use getInput before you start and check the position before and after parsing and attempt to recover the parsed part that way
17:13:56 <glguy> It's not intended to be used like this, though, afaik
17:13:59 <kennysp> ok. I am probably complicating this too much. I'll try another away of solving it
17:14:42 <nshepperd> why can't you just write your (some parsing) bit to return whatever it parsed
17:14:47 <nshepperd> as the result
17:18:28 <kennysp> nshepperd I had a brainfart. I already have the string since I am passing it to parsec's parse function. so there's no reason to retrieve it from within the parser just to build the object
17:19:24 <alvarosevilla> hello
17:20:06 <lambdabot> Hello.
17:21:29 <kennysp> this is probably a horrible mess I am doing.. suggestions appreciated. I need the ability to change types at runtime, I am parsing many websites and I don't know what data I'll get until it is inspected by the user. I am having this: data Any = Any { anyStr :: String , anyObj  :: AnyObj} data AnyObj = Double Double | String String | Strings [String] | Integer Integer
17:21:51 <kennysp> I feel like there should be a nicer way to do it
17:23:05 <kennysp> anyStr is the string used to attempt to parse into desired object type (selected by the user). I am keeping a string because I may have to reparse it again if the type changes from, say, a String to Integer
17:34:22 <mekeor`> how well distributed is randomness from System.Random?
17:34:48 <glguy> not
17:35:49 <kadoban> I think it's good enough for casual use, not cryptographically strong or anything, AFAIK.
17:35:59 <mekeor`> damn. i think i don't have dice at home...
17:36:38 <glguy> http://hackage.haskell.org/package/mwc-random is supposed to be better
17:36:48 <mekeor`> i want to choose random words from a list of words to generate a password ("diceware method") (https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt)...
17:37:20 <kadoban> mekeor`: What OS? Most have a secure random generator around somewhere.
17:37:32 <mekeor`> debian gnu/linux
17:38:00 <kadoban> Oh, use /dev/random  there's even a diceware wordlist for bits instead of dice, though you might have to do a bit of conversion somehow.
17:38:43 <mekeor`> cool!
17:38:53 <kadoban> If you want to be lazy you could just base64 encode a few hundred bytes of it, and ignore anything that's not in the range 1-6, that'll be pretty high quality
17:39:06 <kadoban> Though probably not ideal, it should be decent.
17:40:33 <mekeor`> nice hack, thank you, kadoban – and sorry folks for #-offtopic
17:41:55 <M-berdario> kennysp: have you looked into Typeable?
17:44:49 <kennysp> M-berdario I have used it in the past, but I'm not sure if it would help m e? I don't have any unsafe casts. if user decided to interpret a row in a table as some other type, I'll reparse the string in all the cells in that raw.
17:48:34 <M-berdario> kennysp: sure... I was just thinking that `data Any = forall v. (Typeable v) => Any { anyStr :: String , anyObj :: v}
17:48:59 <M-berdario> looks nicer than having to use that AnyObj type you showed
17:49:33 <kennysp> indeed. need to brush up on my Typeable knowledge it seems
17:50:06 <kennysp> what would the value be if parsing fails?
17:50:11 <kennysp> of Typeable v
17:50:49 <kennysp> perhaps I should use Maybe v?
17:50:53 <M-berdario> well, I think it would be the same as in the code you currently have
17:51:51 <M-berdario> the user wants to reparse as Integer, you dispatch to an eitherDecode (if it's Json, or whatever) that returns Either String Integer
17:51:58 <kennysp> oh, I didn't paste my entire AnyObj definition. There's also NotAnyObj
17:52:23 <M-berdario> then you just put it into Any
17:52:23 <kennysp> I see
17:52:24 <M-berdario> oh
17:53:18 <M-berdario> also, do you have to reparse only one Any, or do you have to reparse all of them at the same time if the users changes type?
17:53:54 <kennysp> all of them in the row where the type changed
17:55:50 <kennysp> to give a bigger picture.. i am scrapping ad websites, and I am pulling all kind of data from different websites. so I thought I'd populate Gtk table with Any object, and then just let user pick how to interpret those cells, and do some simple calculations on them (sorting, calculating average, etc)
17:56:40 <c_wraith> But you don't really mean any type.  You mean any of a small set of types you know how to deal with.
17:56:52 <kennysp> yes
17:57:34 <c_wraith> You should probably just use a sum type with constructors for each different thing you know how to deal with.
17:58:42 <kennysp> now sure how far above did you read. i have a sum type, and also a type that contains the sum type and the original string (to reparse if different type is selected)
17:58:59 <c_wraith> Ah.  I didn't read far enough.
17:59:16 <kennysp> data Any = Any { anyStr :: String , anyObj  :: AnyObj}
17:59:21 <kennysp> data AnyObj = Double Double | String String | Integer Integer | NotAnyObj
17:59:46 <c_wraith> Ah, I was looking at the existential suggestion.  That's what I was warning against.
17:59:55 <kennysp> NotAnyObj would probably be more useful to contain parsing error
17:59:59 <kennysp> does this seem at all reasonable?
18:00:02 <c_wraith> yes
18:00:50 <M-berdario> yeah, sorry... my suggestion was not a good fit if you have only 3 types
18:01:08 <M-berdario> I thought that was only an example (and sometimes I get some bad ideas :P )
18:01:32 <kennysp> I have a few more, but no more than 6 or so
18:01:40 <M-berdario> anyhow, I think I would discriminate types at the level of the collection of `Any` that you have
18:03:06 <kennysp> M-berdario, I'm not quite sure what you mean
18:03:35 <M-berdario> that is, `data Objects = Doubles [(String, Maybe Double)] | Strings [(String, Maybe String)] | Integers [(String, Maybe Integer)]`
18:03:48 <kennysp> ah
18:03:49 <M-berdario> if `NotAnyObj` means a parse error
18:03:55 <kennysp> yes
18:04:09 <M-berdario> on second thought
18:05:00 <M-berdario> I started writing this because I thought that pattern matching on the type of every elment... when you already know the type in advance seems redundant/wasteful
18:05:41 <M-berdario> but at the end of the day, you still have to pattern match for the parse error (Nothing or NotAnyObj) ... so it doesn't feel like a big improvement
18:07:02 <M-berdario> (and I used list of tuples only for brevity)
18:08:36 <kennysp> maybe your approach is still better, I remove any possibility of different type getting into the mix somehow
18:09:32 <M-berdario> yeah, instead of a tuple, btw:
18:09:53 <M-berdario> data ParsedObject v = ParsedObject String (Maybe v)
18:10:18 <M-berdario> data Objects = Doubles [ParseObject Double] | Strings [ParsedObject String] | etc.
18:10:52 <kennysp> looks good
18:31:48 <kennysp> what about known fields that are common in all the websites, like adSubject :: String, adText :: String, adItemPrice? would you make those just a regular fields with plain haskell types? 
18:32:23 <ludat> hi guys, I'm gitlabci for a project and the builds using stack take too long, I've tried to use the cache but doesn't work for some reason
19:16:23 <biglambda> How can I tell ghc which linker to use on Ubuntu?
19:18:48 <biglambda> My issue here: http://lpaste.net/351004
19:27:39 <geekosaur> there is a file "settings" in the ghc lib directory that specifies how to run the linker, among other things
19:28:47 <geekosaur> ...under what circumstances are you getting that error?
19:29:24 <biglambda> I just cloned a project that I've been developing on OSX to a fresh Ubuntu install
19:29:43 <biglambda> I'm using stack to build
19:30:02 <geekosaur> I suspect you need to "stack clean" everything
19:30:53 <biglambda> trying that
19:31:38 <geekosaur> but that sounds kinda messed up, you probably need someone who knows more about what stack is doing internally --- if you are using a stack-installed ghc, it shouldn't need help with that, and if it's a system-installed ghc it would be peculiar indeed for it to have problems with the linker
19:32:33 <biglambda> Cleaning didn't do it.
19:33:40 <biglambda> Why would it be sending an option to gcc that it doesn't have -h
19:34:40 <geekosaur> because it fell back to using gcc to run ld for it, but doesn't know it needs to prepend "-Wl," to linker options like -h (which sets the internal name of a shared object)
19:35:16 <geekosaur> which also seems peculiar, but then I don't think anyone expected that fallback mechanism to be needed
19:36:47 <geekosaur> (I suspect someone forgot to update the fallback at some point while working on shared library support)
19:43:13 <biglambda> It says in the documentation that ghc actually uses gcc to link
19:43:53 <biglambda> I tried changing the linker option to ld and that fails because ld doesn't recognize -Wl
19:47:54 <geekosaur> which thing did you change?
19:49:12 <geekosaur> ("C compiler link flags" was the wrong one)
19:59:27 <biglambda> -pgml ld
20:00:00 <biglambda> under ghc-options
20:00:28 <biglambda> in my cabal file.
20:39:29 <monochrom> -pgml ld would have its own problem. because GHC is just going to assume that whatever you set -pgml to is compatible with gcc commandline-wise.
20:44:24 <geekosaur> which iirc is even an open bug (but hard to solve...)
20:49:19 <tswett> Hey folks.
20:49:52 <tswett> I want to write some neural net stuff in Haskell. I want to write the formulas myself, with no pre-packaged neural net stuff.
20:50:22 <tswett> So that means I'm looking for a library for Haskell which does fast number crunching, especially matrix multiplication.
20:53:13 <wespiser> tswett: I just saw a great neural net tutorial
20:53:31 <tswett> wespiser: specific to Haskell?
20:53:31 <ezyang> well, BLAS/LAPACK bindings are http://hackage.haskell.org/package/hmatrix 
20:53:49 <tswett> ezyang: that looks really helpful, thank you.
20:53:52 <wespiser> https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html
20:54:28 <wespiser> tswett: https://github.com/HuwCampbell/grenade
20:54:31 <ezyang> I can't vouch for the stability/maintenance/etc of the package 
21:02:49 <ReinH> ezyang: o/
21:07:33 <tswett> Yeah, I kind of get the idea that BLAS and LAPACK are the big names in numerical computing, and hmatrix is the big Haskell library for BLAS and LAPACK.
21:10:14 <gamegoblin> Can anyone think of a good way to get a lazy stream of non-repeating pseudorandom ints?
21:11:46 <glguy> start with a lazy stream of ints and filter it for uniqueness
21:12:06 <kadoban> gamegoblin: Could do it with filterM to make them unique, probably with a Set or something, but ya, that ^
21:12:14 <gamegoblin> What’s the memory complexity of that?
21:12:27 <glguy> of remembering all the ints you have seen?
21:12:32 <gamegoblin> exactly
21:12:33 <gamegoblin> it’s linear
21:12:43 <kadoban> linear in the number of different values you yield I suppose, not great
21:12:46 <gamegoblin> was wondering if anyone could think of something that didn’t need to remember what it’s seen along the way
21:12:59 <gamegoblin> it only needs to be very, very roughly pseudorandom
21:13:22 <glguy> how important is it that they're definitely unique?
21:13:24 <gamegoblin> e.g. more random than [1..]
21:13:26 <gamegoblin> very
21:13:32 <kadoban> You probably have to get really really cute with stuff like a bloom filter, and the problem is ... if you start taking too many, you'd end up infinitely waiting and no values coming out.
21:13:52 <gamegoblin> something I was thinking was some deterministic bit rotations
21:14:02 <gamegoblin> bit rotations/flips or whatever
21:14:10 <gamegoblin> and apply that to [1..]
21:14:25 <glguy> If you don't care if they're random just unique you can do a linear feedback register
21:14:32 <kadoban> You could do uhm, exponentiation mod a large prime or something
21:14:43 <kadoban> Probably better plans than mine
21:14:48 <glguy> https://en.wikipedia.org/wiki/Linear-feedback_shift_register
21:16:00 <kadoban> Haha ... I made a criterion report so big that the JS stuff in the HTML output takes forever xD
21:19:38 <tswett> gamegoblin: I feel like I've got something here.
21:19:48 <gamegoblin> tswett: ya?
21:19:54 <tswett> If "it only needs to be very, very roughly pseudorandom", then here's my suggestion.
21:20:15 <tswett> Each number is the last number, times a constant, modulo 2^32 or whatever.
21:20:23 <tswett> Where the constant is pretty much any arbitrary odd number.
21:23:23 <ertes> gamegoblin: trying to create a stream of unique random numbers?
21:23:54 <gamegoblin> ertes: yes, just something that someone observing the stream would not be able to trivially see how it was generated
21:24:06 <ertes> gamegoblin: how about a block cipher?
21:24:28 <ertes> in counter mode
21:24:50 <gamegoblin> ertes: might be a bit heavy weight compared to the bit rotation / flip method I mentioned earlier
21:25:17 <ertes> gamegoblin: sure, but at least that one is super-easy to implement…  just use a crypto library =)
21:25:31 <ertes> in fact DRBG has exactly that
21:25:32 <tswett> Here, let me implement the RANDU algorithm real quick.
21:26:05 <tswett> > 2^31
21:26:09 <lambdabot>  2147483648
21:26:14 <tswett> > iterate (\x -> (65539 * x) `mod` (2^31)) 1
21:26:16 <ertes> there is also some merit to kadoban's suggestion, because it lets you choose the period
21:26:17 <lambdabot>  [1,65539,393225,1769499,7077969,26542323,95552217,334432395,1146624417,17223...
21:26:38 <ertes> > iterate (\x -> mod (2*x) 101) 1  -- period 100
21:26:41 <lambdabot>  [1,2,4,8,16,32,64,27,54,7,14,28,56,11,22,44,88,75,49,98,95,89,77,53,5,10,20,...
21:27:12 <ertes> wait, not necessarily
21:27:12 <kadoban> Ya. It's not super random looking at all, but ... it fits the requirement of being better than [1..]
21:27:18 <tswett> kadoban's suggestion and my suggestion are pretty similar.
21:27:38 <tswett> I'm using a power of 2 as the modulus and an odd number as the base.
21:27:51 <ertes> replace multiplication by squaring, then it's actually fairly random…  the resulting random number generator is called blum-blum-shub
21:27:52 <tswett> kadoban is using a prime number as the modulus and any smaller number as the base.
21:28:06 <ertes> but that one no longer guarantees a period
21:28:40 <tswett> Personally, I like my solution...
21:28:49 <tswett> But I'm obviously biased. :D
21:29:35 <kadoban> Ya, blum-blum-shub, that's the name I was trying to think of
21:29:39 <ertes> tswett: just make sure you calculate the order of your base, then yours is fine as well…  it does waste two bits, but in exchange it's much faster =)
21:30:09 <ertes> > iterate (3*) (1 :: Word32)  -- period 2^30
21:30:12 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
21:30:22 <ertes> perhaps use a larger base =)
21:30:32 <tswett> I'm not sure how to calculate the order of the base, actually.
21:30:33 <kadoban> If you do larger bases does it look more randomish? It should right
21:30:43 <kadoban> I wasn't confident what the period of that is though, does that kill it?
21:30:56 <ertes> > iterate (131101*) (1 :: Word32)  -- period 2^30
21:30:59 <lambdabot>  [1,131101,7603017,330719045,4197632721,3982686637,3616557209,4236917077,2402...
21:31:05 <tswett> But according to Wikipedia, the period with my method will "usually" be large.
21:31:24 <kadoban> Yeah, that looks like it's starting to look not bad after the first few
21:31:31 <tswett> Something along the lines of: half the time, the period will be 2^30; if not, then half the time, the period will be 2^29; if not, then half the time, the period will be 2^28; ...
21:31:45 <kadoban> Depending on what base?
21:31:53 <ertes> tswett: hint: 1. the size of every subgroup is a divisor of the size of the group, 2. every base generates a subgroup
21:32:18 <tswett> Yep. I'm stating what will happen if you choose the base randomly.
21:33:14 <tswett> ertes: yeah, but I wasn't sure what the multiplicative group modulo 2^32 would look like. For all I knew before reading Wikipedia, maybe it has no elements of order greater than, say... 32.
21:34:00 <tswett> But no, Wikipedia says that that group is isomorphic to C_2 * C_(2^30).
21:34:15 <ertes> tswett: worst case:  try 1000 bases, and pick the one with the largest order =)
21:34:34 <ertes> tswett: if you pick a random element, most of the time it will be a maximal-order element
21:34:42 <ertes> there is a theorem for that, but i forgot its name
21:34:49 <tswett> Right.
21:35:22 <ertes> it's related to lagrange's theorem, so you might find it by reading about that one
21:35:48 <tswett> I think I know how to calculate the order. Just take your element and repeatedly square it until you get 1, and... the order is 2 to the power of (the number of times you had to square it)?
21:36:45 <ertes> tswett: even easier:  exercise: what's the order of multiplication modulo 2^32?
21:36:51 <tswett> The order of that group? It's 2^31.
21:37:24 <tswett> So... half of its elements have order 2^31.
21:37:51 <tswett> Is that right? That sounds...
21:38:02 <ertes> the maximal subgroup order is 2^30…  now if find that x^(2^29) ≡ 1, you know that it can't be a maximal order element
21:38:17 <ertes> "it" being x
21:38:18 <tswett> Right. Half of its elements have order 2^30, then.
21:39:19 <gamegoblin> Going to go with "randomize rotation mask = map (\x -> (rotate x rotation) `xor` mask)" used like "randomize 7 73478313 [1..]"
21:39:25 <gamegoblin> which yields [73478185,73478569,73478441,73478825,73478697,73479081,73478953,73479337,73479209,73479593] for the first 10
21:39:35 <tswett> > let order 1 = 0; order (x :: Word32) = 1 + order (x*x) in map order [1000000001, 1000000003, 1000000005, 1000000007, 1000000009, 1000000011]
21:39:37 <lambdabot>  [23,30,30,29,29,30]
21:39:41 <gamegoblin> not monotonically increasing or decreasing for long stretches
21:40:11 <ertes> the reason i don't like LFSRs is that i don't understand them =)
21:40:28 <ertes> never really got into the algebra of polynomials
21:40:51 <kadoban> Hah ... if you pause a criterion benchmark with ctrl+z or anything and then start it up later, it totally doesn't work correctly ...
21:41:08 <kadoban> Probably should have expected that.
21:41:08 <tswett> gamegoblin: yeah, if that's random enough for you.
21:41:27 <ertes> kadoban: really?  i would expected it to have one massive outlier, but otherwise work rather robustly
21:42:09 <kadoban> ertes: I assume that's what's causing my output at least. I have one bar that's *massive* for something that I know doesn't take very long, and the rest of the bars are ... invisibly small.
21:42:28 <kadoban> And I'm like 80% sure it's the benchmark I paused it on :-/
21:42:29 <ertes> ah, you're looking at graphs
21:42:32 <ertes> check the terminal output
21:42:39 <tswett> I'd say that that "doesn't look very random" because all the numbers are really close to each other. But I can't tell how it works just by glancing at the output.
21:42:58 <kadoban> Ah, ya. I like the prett graphs, hehe. But ya, that's a decent plan, I'll check the terminal scrollback.
21:43:16 <ertes> gamegoblin: i'm prefer the multiplicative group approach…  it's efficient, and the period is under your control
21:43:16 <tswett> > iterate (1000000003*) (1 :: Word32) -- period 2^30
21:43:18 <lambdabot>  [1,1000000003,218414089,332877339,1415919697,1733923571,1261336281,215785099...
21:44:00 <ertes> tswett: btw, another method to figure out an element's order is:  fire up 'gp' (from PARI/GP) and type:  znorder(Mod(1000000003, 2^32))
21:44:01 <ertes> =)
21:44:40 <kadoban> And I did 'git clean' incorrectly and nuked my .stack-work ... I am doing well tonight.
21:44:58 <tswett> Y'know, I want to install Linux in a VM under Windows.
21:45:05 <tswett> But before I do that, I want to buy a new laptop to do it on.
21:45:28 <tswett> And before I do that, I should buy a car.
21:45:28 <ertes> tswett: PARI/GP is available for windows =)
21:45:33 <tswett> I had a car, but then it quit, and it's too badly damaged to repair.
21:50:23 <tswett> I mean, I shouldn't say "I had a car". I still have the car.
21:50:44 <glguy> Cars are a better #haskell-offtopic topic
21:55:21 <jmnoz> tswett :: car -> laptop -> linux vm -> haskell
21:55:49 * jmnoz apologizes
21:59:39 <ertes> looks like tswett is partial
22:00:14 <tswett> Right. I won't produce Haskell for all combinations of car, laptop, and Linux VM.
22:26:55 <shayan_> Is Haskell the best language for web applications?
22:27:43 <Zemyla> Do you mean server-side or client-side?
22:29:36 <ertes> shayan_: of course…  what other answer did you expect from #haskell? ;)
22:30:16 <shayan_> Zemyla: is it okay to say, both?
22:31:33 <dmj`> shayan_: yes
22:32:05 <shayan_> I am very new to programming. Studied a bit of perl a few days ago, and now finally received my books on C, and have started learning C. Just heard about Haskell and wanted to learn a little bit more about it. I want to be able to learn programming to ship products/services to the world
22:32:21 <ertes> shayan_: server-side: check out the following frameworks: happstack, scotty, servant, snap, yesod…  i chose this list, because i think that each of them have unique philosophies and corresponding values, so you might get an idea of how server-side web programming is approached in haskell
22:32:41 <dmj`> shayan_: haskell can do that
22:32:50 <Zemyla> The best language for server-side is actually optimized Brainfuck.
22:32:59 <ertes> shayan_: i'd say scotty is the easiest of those, so you may want to start with that one
22:33:04 <ertes> followed by snap perhaps
22:33:55 <ertes> shayan_: for client-side see reflex-dom…  just search for "reflex-dom" on youtube, and you should find a few talks by ryan trinkle, and watch one of those
22:34:56 <ertes> shayan_: however, if you're new to programming, you may not want to start with web programming right now, because it requires knowledge of multiple concepts with varying learning curves
22:35:15 <monochrom> At some point you will have to accept that "best" depends on you, too.
22:35:32 <shayan_> Why don’t we, or rather, I, hear about Haskell in the news? I see more news regarding Java, Ruby on Rails, and Python? I mean, I am just surprised to hear about Haskell just today
22:35:43 <monochrom> Haskell is best for me for a lot of things. And I'm sure the worst for Dennis Ritchie.
22:36:19 <ertes> shayan_: the popularity of a language is almost completely unrelated to its quality
22:36:35 <ertes> shayan_: people like shiny things, not good things =)
22:36:52 <shayan_> ertes: I can’t. My first product I have been working on (on paper) is purely based on the web. 
22:37:20 <monochrom> In fact Ritchie finds that C is the second best for most everything. So that's something you may consider if you want to follow his footsteps.
22:37:41 <srk> maybe if he knew that he can generate safe C from haskell..
22:37:45 <monochrom> Which brings us to: Why isn't C in the news when it comes to web apps, too?
22:37:48 <ertes> shayan_: well, go ahead…  it's just that you're making your learning curve steeper than it needs to be, but of course you might consider that to be a challenge rather than a problem =)
22:38:30 <monochrom> I.e., is that something wrong about C? or something wrong about web apps? Or, in fact, something wrong about news?
22:38:32 <srk> monochrom: https://lh3.googleusercontent.com/-DYbWMtH301k/VD5CDjv9dQI/AAAAAAAAE1U/xXBMtug3cfY/w506-h662/webdev-assembly.png
22:38:55 <monochrom> Haha, "with his therapist"
22:38:57 <srk> and yeah, there's a lot of wrong with web apps
22:39:07 <shayan_> monochrom: the plan was to learn C so then I could learn php and mysql more “swiftly”, to be able to develop what a web application. I took this advice from Mark Zuckerberg’s tip to Dustin Moskovitz, when he just started learning programming
22:39:11 <monochrom> I think news are wrong.
22:39:24 <ertes> is PHP still the most popular language for the web?  it's definitely one of the worst languages for…  everything
22:39:33 <monochrom> I don't think C first PHP second is more swiftly.
22:39:56 <shayan_> xD\
22:40:01 <kadoban> shayan_: Learning C so that it's easier to learn other things strikes me as ... learning quantum dynamics so that it's easier to learn how to play pool.
22:40:21 <shayan_> kadoban: I’ll take that!
22:40:31 <monochrom> I think you've exaggerated the gap.
22:40:44 <kadoban> Ya, a bit
22:40:57 <Cale> shayan_: Here's a talk by my boss on one of the frameworks we've been working on https://www.youtube.com/watch?v=dOy7zIk3IUI
22:41:01 <monochrom> But C will have you chasing after your own pointer bugs forever. You will never finish.
22:41:26 <monochrom> Whereas PHP does not require you to know about those pointer bugs.
22:41:51 <shayan_> monochrom: I’ll be finished with C after I finish Ritchie’s (2e) book, it’s not that large 
22:42:02 <monochrom> In fact PHP has automatic garbage collection and C doesn't. Meaning C is so much harder and the experience you gain there has no use.
22:42:04 <shayan_> question now is, after C, should I learn Haskell or PHP?
22:42:24 <shayan_> Cale: Will watch this, thank you
22:42:31 <monochrom> Oh well if you have a low bar for "learning" then sure.
22:42:55 <monochrom> By that standard it takes only 20 days to "learn" Haskell too. Just "read" LYAH.
22:42:55 <ertes> learning C to better understand PHP?  i think it's more like learning a wannabe-physicist's esoteric theory of "particle self-awareness" to learn a wannabe-athlete's made up game that has the most complicated and awkward rules you can imagine
22:43:12 <Cale> hahaha
22:43:19 <shayan_> XD
22:44:18 <monochrom> You should learn everything and then decide what's best for you.
22:44:22 <shayan_> Jeez, not only did I put away my studying, but now it seems that I’ve trapped myself :( I feel more lost now… 
22:44:47 <monochrom> I mean until there is technology for you upload your brain for a full analysis.
22:44:51 <ertes> shayan_: honestly?  pick any language that you find interesting and learn it
22:45:03 <kadoban> shayan_: Haskell is far more esoteric than PHP is, but ... PHP isn't very well regarded as a language. I'd suggest haskell if you want a better tool eventually, PHP if you have very little time. Or just ... learn both, if you want.
22:45:04 <ertes> shayan_: don't try to put them in any order or anything…  just pick one and learn
22:45:22 <ertes> shayan_: and then comes the most important second step:  learn a second language
22:45:22 <shayan_> I don’t have a low bar for learning, I really enjoy learning, and would like to enjoy everything. I also have a product I want to show to everyone, as soon as possible. what I lack the most is my environment, which might be why it seems I come off uberly nubbie
22:45:30 <kadoban> That's pretty good advice ^
22:45:40 <monochrom> The problem with people who plan their lives and demand the best.
22:46:04 <davean> kadoban: funny you should say that, one of my complaints against PHP is how esoteric it is!
22:46:38 <Cale> I actually picked up a bit of PHP at around the same time I started learning Haskell -- a friend and I used it to write a search engine to index the local shared files on our dorm network (to help circumvent the draconian bandwidth limits for traffic outside it)
22:47:02 <Cale> That was back around 2001 or so :)
22:47:27 <davean> Cale: funny, I did that in C, reported a bug about memory freeing in libsamba, had it turned down, and then they fixed it 7 years later :)
22:47:40 <kadoban> davean: Not sure I agree. I mean it used to be like, the *one* language everyone used for server-side, just about. Thankfully no longer the case, but it's still ... more popular than I would prefer.
22:47:50 <ertes> who knows…  maybe you will learn PHP and find it really enjoyable…  although it's easier and cheaper just to hire someone to beat you up with a whip if you're into that sort of thing
22:47:59 <kadoban> Haha
22:48:04 <shayan_> hahaha
22:48:20 <davean> kadoban: Have you seen its massive inconsistency in argument order? The fact that it tried to GUESS argument order for some functions once upon a time?
22:48:22 <monochrom> "esoteric" depends on whom you hang up with, too.
22:48:29 <monochrom> err, s/up/out/
22:48:30 <davean> Its almost as esoteric as some esoteric langs :)
22:48:59 <monochrom> Like, IRC is esoteric to most Twitter users.
22:49:01 <kadoban> davean: Oh, if we're talking about it being "esoteric" meaning it makes no goddamn sense, then yeah.
22:49:08 <monochrom> And conversely, Twitter is esoteric to me.
22:49:09 <Cale> Yeah, the thing about PHP is that if you know some imperative programming languages, it's trivial to sort of get started writing things in an undisciplined way, and it feels very productive to a point. Then it becomes super annoying and awful.
22:49:29 <kadoban> I meant it as a measure of how well known the language is, the size of the userbase essentially.
22:49:37 <Cale> Because it just does nothing to help you defend against many common bugs.
22:50:21 <davean> Cale: sure it does! Getting argument order mixed up is a common bug! ;)
22:50:27 <kadoban> xD
22:50:34 <davean> (That was the weirdest thing I've ever encountered anywhere)
22:50:55 <kadoban> So many fun weird PHP anecdotes out there.
22:51:04 <monochrom> I think "esoteric" is about unfamiliarity, and if you want to describe making no sense, the phrase is "line noise".
22:51:37 <ertes> well, it does help you in a very effective way:  it makes your production site blow up…  you really take a lesson from that not to repeat that particular mistake…  repeat around 10000 times and you're almost in a position to write safe PHP code
22:52:14 <ertes> as they say:  good support is expensive
22:52:24 <Koterpillar> I'm getting "Missing C library: Xft" when doing "stack build X11-xft", but I have xft (lowercase). How do I fix this?
22:53:22 <Cale> Koterpillar: look for a package like libxft-dev?
22:53:51 <Koterpillar> I have it
22:53:54 <Cale> hmm
22:54:01 <Koterpillar> pkgconfig --cflags xft works
22:54:05 <Koterpillar> pkgconfig --cflags Xft doesn't
22:54:12 <Koterpillar> but https://hackage.haskell.org/package/X11-xft-0.3.1/src/X11-xft.cabal references xft and not Xft
22:54:59 <kadoban> Would modifying the .cabal file be a ridiculous suggestion?
22:55:42 <Koterpillar> is that to me?
22:55:59 <ertes> Koterpillar: alternatively you could symlink Xft to xft at the necessary locations
22:56:24 <Koterpillar> well, the cabal file references the package I *have* - xft (lowercase)
22:56:25 <ertes> i don't know how pkgconfig works, but if you could just teach it about Xft by a bunch of symlinks…
22:56:33 <arw> I get 'qtah-examples-0.2.0/dist/build/qtah-examples/qtah-examples: error while loading shared libraries: libqtah.so.0: cannot open shared object file: No such file or directory
22:56:36 <ertes> ah
22:56:44 <kadoban> Koterpillar: Yes. Oh ... that sounds confusing.
22:56:58 <arw> although I just installed the dependencies before via cabal install and then did cabal run
22:57:06 <ertes> Koterpillar: is it a configuration error or a linker error?
22:57:09 <shayan_> A very strong point that Cale mentioned earlier regarding the use of Haskell was that it is used on both the frontend and backend, communicating the same language, and thus preventing a lot (90% of Cale’s web application problems) of communication issues having to do with the frontend and backend. This alone really convinces me that I should really invest the time to learn Haskell over PHP, as it may be a 
22:57:09 <shayan_> more sustainable language over the long-term
22:57:11 <arw> shouldn't cabal run set the right LD_LIBRARY PATH?
22:57:28 <Koterpillar> I'll paste
22:58:10 <lpaste> Koterpillar pasted “X11-xft build issue” at http://lpaste.net/351006
22:58:29 <ertes> shayan_: another point against PHP is that you have an actual running program…  PHP scripts are invoked per-request, which leads to all sorts of super-ugly hacks
22:59:16 <Koterpillar> ertes, kadoban: see paste
22:59:16 <Koterpillar> also, I've just copied pkgconfig so that pkg-config Xft works... but that doesn't help
23:00:38 <Cale> shayan_: Yeah, our team of like 5 to 7 people (it varied a bit) built something roughly like Slack, except with a bunch more features (some light task management, integration with external email, surveys, and a bunch of other organisational features), and it's been about a year to get from nothing to beta, and overall things have gone pretty smoothly despite some pretty large changes in spec along the way.
23:00:49 <Koterpillar> How do I see what did it try to configure, the cabal file?
23:00:52 <Cale> Well, beta is soon :)
23:01:22 <Cale> It's deployed in alpha at a couple places and working fairly well.
23:02:40 <shayan_> Cale: Is development with Haskell exponentially much longer, than other web development languages?
23:02:48 <shayan_> Why are social platforms like Facebook, Quora, and other high-traffic websites, not programmed in Haskell? Can it be that there is a short supply of experienced Haskell programmers, and as as a result, the cost to hire such programmers much more expensive than, say, PHP programmers? I don’t see many platforms being developed in Haskell, or maybe I just haven’t been paying attention.
23:03:06 <Cale> shayan_: Well, Slack took about 4 years with a larger team to do something similar ;)
23:03:39 <arw> shayan_: I guess PHP programmers are a dime a dozen or something ;)
23:03:46 <ertes> shayan_: some of those are starting to adopt haskell…  the most notable recent example is facebook, which rewrote their abuse filtering system in haskell
23:03:54 <rblaze> shayan_: facebook uses haskell extensively
23:04:08 <ertes> shayan_: in other words: every message people write on facebook passes through a large-scale haskell program right now =)
23:04:39 <monochrom> Facebook started with PHP because that's all Zuckerburg knew. (A way to say that he knew even less than Bill Gates.)
23:05:05 <Cale> shayan_: But yeah, mostly, it's that Haskell is pretty different from most of the very popular languages, which means that it requires a fair amount of effort to learn
23:05:05 <monochrom> But Zuckerburg did hire Simon Marlow to switch over the spam filter to Haskell.
23:05:05 <ertes> shayan_: they won't rewrite the whole site in haskell any time soon though, because it would be too expensive
23:05:05 <monochrom> Or something new, close to Haskell.
23:05:09 <Cale> shayan_: So there are only so many people who actually know it well -- it's not *that* hard to find people to hire though.
23:05:23 <Cale> But they're not exactly a uniform commodity
23:05:29 <monochrom> Networking effects dominate. (A way to say that choices are pretty random.)
23:06:26 <shayan_> This is such interesting information
23:06:39 <shayan_> I definitely think I will be getting rid of plans to learn php now
23:07:35 <shayan_> can you guys paste websites that are coded mostly in Haskell? your favorites, maybe? or somewhere where I could find a list of some?
23:07:44 <Koterpillar> where does stack keep the downloaded packages?
23:08:03 <monochrom> I have no real quarrel with PHP. If you want to code for money, you will have to know PHP. And a ton of other things.
23:08:04 <Cale> shayan_: Haskell's been around since 1989 or so, but for many years -- up to around 2004-2005 or so, it was more of a platform for programming language research than something which was practical to write real software in.
23:08:37 <monochrom> But that's also an antithesis to your mental health. You have to choose one: money, or mental health. Choose your poison.
23:08:38 <shayan_> Cale:  why the sudden switch in 2004-2005? 
23:09:15 <shayan_> monochrom: I don’t want to code for money. I want to learn programming to bring a product that I really love and share it with everyone else, that’s all :)
23:09:18 <ertes> well, there is little reason to start your own business or your personal/open-source things in PHP
23:09:31 <Koterpillar> OK, stack isn't the problem now
23:10:21 <ertes> the reason PHP is money is mostly legacy and that some people start new things in PHP even today
23:10:37 <Cale> shayan_: Well, around that time, an efficient library using low-level techniques to manage strings of bytes efficiently (ByteString) got written, and a lot of practical consequences started coming out of that quickly.
23:11:26 <arw> and maybe generally more attention from non-academia?
23:11:37 <kadoban> Cale: That's an interesting answer. I never considered ByteString to be that important before.
23:11:46 <Cale> shayan_: But why did ByteString come out then and not sooner or later? Well, I guess it just reached enough semi-realistic semi-toy projects at that point that people started wanting to really use it.
23:12:17 <ertes> and in 2017 people really want to get rid of String as the default =)
23:12:25 <zipper> Good morning all o/
23:12:34 <ertes> high-low zipper!
23:12:43 <Cale> Yeah, ByteString and Text are what you use if you care about performance
23:13:30 <Cale> I still have a soft spot for lists, but lazy linked lists of 32 bit Char values just can't perform well :)
23:13:58 <arw> its still nice to explain things to students in that fashion.
23:14:02 <zipper> Cale: Funny you say that, so I have this bot that reads URLs right? Running on a 512 MB RAM VM. It reads URLs for the purpose of fetching page titles.
23:14:10 <zipper> It already uses lazy byestrings
23:14:44 <zipper> but what I have noticed is, it still fetches the entire page into memory and sometimes 
23:14:57 <zipper> e.g for gifs it takes up too much memory and crashes.
23:15:05 <zipper> or some web pages
23:15:16 <zipper> Well zsh/OS kills the process
23:15:17 <ertes> zipper: which HTTP library are you using?
23:15:40 <zipper> ertes: wreq
23:15:53 <Koterpillar> Here's my problem, it turns out: /usr/lib/libharfbuzz.so.0: undefined reference to `FT_Get_Var_Blend_Coordinates'
23:16:15 <zipper> Not entirely sure but I think this is where it happens https://github.com/nairobilug/nairobi-bot/blob/master/src/Bot/URL.hs#L64
23:16:20 <ertes> zipper: wreq uses http-client…  you need stream processing in order not to read the pages into memory
23:16:26 <zipper> I haven't investigated it much
23:16:50 <ertes> zipper: http-conduit makes this easy enough
23:16:50 <ertes> you just use conduit stream processing
23:16:57 <zipper> ertes: hmmmmmm thanks m8 :) I'll definitely look into it
23:17:27 <zipper> ertes: So this couldn't have been solved with using a lazy bytestring as I thought, which is what I had done.
23:17:48 <monochrom> lazy-whatever is necessary but insufficient.
23:18:10 <ertes> zipper: nope…  ironically if you use stream processing, you only work with strict chunks
23:18:14 <Younder> Lattices and order has finally arrived
23:18:16 <Cale> zipper: Maybe if the HTTP library was properly lazy all the way through it could manage, but that might be tricky.
23:18:28 <monochrom> actually come to think of it, conduit etc don't rely on lazy-whatever. so lazy-whatever is unnecessary too.
23:18:35 <Younder> (book)
23:18:41 <shayan_> Guys, I am actually so excited to start learning Haskell. Thing is, I am still on Chapter 1 on my newly arrived C book by Ritchie and Kernighan… I must pay respects and finish that book before Haskell…or… Am I wasting time on C if I am most excited about Haskell?
23:18:42 <zipper> monochrom: What are you saying?
23:19:33 <Cale> shayan_: Unless there's a project that's already written in C which you're excited about being able to contribute to, I would just skip to doing Haskell
23:19:34 <Younder> shayan_, welcome! I hope your math is good because you will need it.
23:19:40 <zipper> ertes: Thanks a ton :) I have never used pipes/conduit but I have heard of them.
23:19:50 <zipper> I didn't know I'd ever have a use case for them
23:20:01 <zipper> Now I do :) the best way to learn a lib
23:20:04 <arw> shayan_: learning things is never wasted time. but if your priority is getting started with haskell, then just get started with haskell. C won't help you there.
23:20:05 <zipper> Have a use case
23:20:09 <Cale> shayan_: Personally, there are *very* few projects which I would recommend C for.
23:20:12 <ertes> shayan_: you're not wasting your time, but you should understand C's limitations, and i have a feeling the book you bought might not be entirely honest about them: "C gives you a lot of control over resources" vs. "C requires tedious and error-prone manual memory management that might just cause your code to have a gaping security hole, if you get even the tinest thing wrong"
23:20:18 <zipper> Cale: :)
23:20:43 <Cale> It's sort of been squeezed out of its niche by higher level languages such as Haskell and others on one side, and by lower level languages like LLVM on the other.
23:20:43 <shayan_> Younder: I’m not at all, but I will try? :X
23:20:59 <monochrom> Well K&R was written long before buffer overrun tricks.
23:21:00 <ertes> zipper: perhaps start by learning pipes…  it's the simpler library (and disclaimer: also my personal favourite)
23:21:13 <Cale> Yeah, I prefer pipes as well.
23:21:50 <zipper> Cale: I wish to know C to understand GHC or the runtime
23:22:01 <zipper> but I've never had the time to learn C
23:22:03 <ertes> although sometimes i have trouble choosing between pipes and machines…  i actually prefer the way machines works, but there is just a lot of existing stuff for pipes
23:22:15 <zipper> There's always a new JS framework to learn lol
23:22:34 <zipper> Oh react, oh react native....
23:22:42 <shayan_> As much as I am excited to learn about Haskell, I am even more excited to be able to start programming the web application I have wanted to for a while now. 
23:22:46 <Cale> zipper: reflex-dom :D
23:22:47 <ertes> shayan_: regarding math: haskell needs you to use your brain…  it doesn't need you to understand topology
23:23:16 <monochrom> Oh everything needs your brain. The question is how, specifically.
23:23:24 <shayan_> ertes: using your brain is so vague!
23:23:37 <arw> shayan_: well, for a web application, there is also the question about how much html and css (and possibly javascript) you already know.
23:23:40 <shayan_> Guys, I bought GEB, will this help? :P
23:23:57 <ertes> shayan_: let me put it this way:  if you don't use your brain in C, your code will blow up…  if you don't use your brain in haskell, the compiler will likely reject it
23:23:57 <monochrom> Specifically, Haskell requires you to respect equality and solve type equations. http://www.vex.net/~trebla/haskell/prerequisite.xhtml
23:24:02 <zipper> shayan_: For me not knowing C has hurt my understanding of some Haskell internals, literally internals.
23:24:10 <zipper> shayan_: but to write haskell you don't need C
23:24:14 <zipper> imo
23:24:51 <ertes> shayan_: here is another interesting note: knowing C might actually hinder your haskell performance, because you have to unlearn pretty much everything you have learned while studying C =)
23:24:56 <Younder> I'm fluent in C/C++. Have been for many years. I don't think it helps in Haskell though
23:25:07 <monochrom> GEB is a lengthy book to say a few points.
23:25:29 <Younder> If you need some pointers I would e happy to help
23:25:51 <arw> imo, especially as a beginner, knowing C might be rather distracting when learning haskell. you will always look for C constructs that just aren't there in haskell and things will generally work in a totally different way.
23:26:06 <arw> its like knowing spanish doesn't help your japanese
23:26:16 <kadoban> Even imperative code in haskell doesn't feel much like C
23:26:35 <Cale> otoh, the people who I taught Haskell first didn't seem to have too much difficulty picking up C
23:27:06 <ertes> shayan_: working in haskell feels like doing math, mostly because haskell doesn't try to deny that programming *is* math…  but it doesn't need you to understand any actual math topics, just a logical way of thinking
23:28:22 <ertes> and yeah, picking up C after haskell is fairly easy, although the experience will be rather disappointing…  even annoying
23:28:39 <shayan_> Wow
23:28:49 <Younder> dont know aboy that. I actally like C
23:28:55 <kadoban> I'd be interested in what it feels like to learn C after haskell ... can't quite imagine that.
23:29:04 <Younder> But to each his own
23:29:17 <ertes> kadoban: just try to translate any of your haskell code to C =)
23:29:33 <kadoban> I think things like C are quite fun ... but, not very useful usually, in terms of productivity.
23:29:45 <kadoban> Heh, I should do that and see what happens.
23:29:59 <shayan_> You all have convinced me so well on Haskell. I think I will be returning my books on C tomorrow then
23:30:03 <ertes> "why does this have to be so difficult?", "why can't the damn compiler figure this out for me?", "why do i have to write this ultra-redundant code?!"
23:30:26 <ertes> up to: "i don't trust my code at all"
23:30:33 <shayan_> xD
23:30:44 <zipper> this is encouraging to hear "Cale | otoh, the people who I taught Haskell first didn't seem to have too much difficulty picking up C"
23:30:52 <kadoban> Oh yeah, whenever I do C now, I am paranoid as hell ... which is probably actually an improvement.
23:31:18 <Younder> I think Haskellers are right that imperative languages are dying and that applicative languages are where you want to be.
23:32:06 <Cale> Yeah, being used to programming in Haskell makes you a better C programmer (or programmer of more weakly typed languages generally) in a way that can otherwise take decades of experience to really get to.
23:32:07 <ertes> or even just: "wow, those braces and semicolons annoy me to no end", although i hear that SPJ might not agree on that =)
23:32:19 <Younder> Anyhow haskell is elegant and cool. enjoy
23:32:34 <ertes> i think djb is the only person on this planet who can write decent C code
23:32:53 <ertes> well, perhaps the guy/girl behind skarnet.org, too
23:33:13 <Younder> There is no such thing as decent C code ;)
23:33:48 <monochrom> I can write decent C code. But I can only write short code.
23:33:51 <Younder> It get's to wrapped up in details.
23:34:12 <ertes> monochrom: that's kind of a contradiction
23:34:30 <ertes> there is no such thing as "short C code"
23:34:57 <Younder> ertes, There is. It just doent do much
23:35:14 <ertes> oh, yeah…  i remember
23:35:20 <ertes> int random() { return 4; }
23:35:30 <ertes> that one is indeed short
23:35:43 <monochrom> That is not decent. You forgot a "void".
23:35:49 <Younder> ertes, That's not C.
23:35:56 <monochrom> But it does count as decent C++, eh :)
23:36:05 <shayan_> monochrom: I just went through the Prerequisite for Learning Haskell. Thanks so much. But is this really all the math? A few people have said “you better be good at math”, this material did not seem to be extremely complex, or maybe, I might just be speaking too early?
23:36:19 <ertes> what is it then?  C99?
23:36:36 <monochrom> C before there was a standard at all.
23:36:43 <Younder> For the record there are plent of good programmers out there that use C
23:36:47 <dmj`> shayan_: who said, “you better be good at math” ?
23:37:16 <Younder> dmj`, That would be me
23:37:28 <monochrom> shayan_: You know how "good at math" is wildly relative, no?
23:37:36 <ertes> shayan_: as i said, you don't need any actual math subjects, just a mathematical/logical mind
23:37:44 <nitrix> Just validating quickly. Given `f :: a -> b`, the function is injective if for all possible values of `a`, there exists a distinct result in `b` ?
23:38:37 <nitrix> And surjective if all possible results `b` are covered?
23:38:37 <ertes> nitrix: more precisely:  f x = f y -> x = y
23:38:37 <monochrom> Terrence Tao is going to say "you don't need math for Haskell". Paris Hilton is going to say "Haskell is so mathy, let's go shopping". You understand that?
23:38:37 <ertes> nitrix: for all x, y
23:38:37 <Younder> dmj`, I guess I ment lattice theory and some category theory. Basic undergraduate stuff
23:38:37 <nitrix> ertes: How does I read that?
23:38:37 <nitrix> *do
23:38:41 <shayan_> monochrom: hahahaha
23:39:00 <ertes> nitrix: you does read that as: "a function f is injective, if for all x, y the following holds:  if f x = f y, then x = y"
23:39:22 <dmj`> Younder: hm, I see.
23:39:28 <ertes> nitrix: example: succ is injective:  succ x = succ y = 7 -> x = y = 6
23:39:43 <monochrom> Because Paris Hilton's "math" is just a bit of algebra skills (which is useful as I wrote there), but to Terrence Tao this barely counts as math, you are not even taking limits.
23:39:50 <shayan_> After reading the prereq for Haskell, it seems that the material went as far up to Calculus covered in first year university
23:39:55 <ertes> nitrix: that holds regardless of which x and y you pick
23:40:12 <ertes> nitrix: surjective means:  for all y there exists an x such that f x = y
23:40:44 <nitrix> ertes: And then bijective, for all x and y there exists f x = f y = x = y ?
23:41:04 <ertes> nitrix: no, a function is bijective, if it's injective and surjective
23:41:13 <nitrix> That I got, the notation throws me off :S
23:41:51 <ertes> nitrix: 'succ' for Integer is bijective:  1. if succ x = succ y, then x = y, 2. for every y there exists an x such that succ x = y
23:42:17 <ertes> nitrix: 'succ' for Natural is only injective:  there exists no x such that succ x = 0
23:42:31 <Younder> ertes, This is sounding more like Isabelle
23:42:45 <nitrix> ertes: That was a lot more clear.
23:42:58 <ertes> nitrix: 'length' is only surjective on lists:  for every possible length, there exists a list that has that length
23:43:12 <arw> ertes: succ for integer isn't surjective because there is no integer x such that succ x = 1.
23:43:16 <ertes> nitrix: but from two lists having the same length you can't conclude that the lists are equal
23:43:16 <nitrix> So, making a terrible attempt at the notation, lets see if I get it right.
23:43:37 <ertes> nitrix: the latter means that 'length' is not injective for lists
23:43:52 <ertes> arw: x = 0
23:44:17 <arw> ertes: ah, wait. integer is -\infty to \infty?
23:44:23 <ertes> arw: yep
23:44:27 <arw> ertes: sorry, you are right of course
23:44:46 <arw> ertes: thought it was naturals starting from 1 vs 0.
23:45:27 <ertes> naturals starting at 1 is just a historical mistake anyway =)
23:45:45 <ertes> (i'm glad i didn't say that in ##math)
23:46:08 <nitrix> ertes: Injective:  forall x y ∈ A, f x = f y  =>  x = y   (If the result of applying f on x is the same as the result of applying f on y, then x must be the same as y).
23:46:24 <nitrix> ertes: Is the notation good?
23:46:25 <monochrom> There was a time "number" started from 2.
23:46:29 <ertes> nitrix: you probably want to allow different sets for the domain and codomain
23:46:52 <MarcelineVQ> monochrom: well, there's no need to count 1, it's right there
23:46:55 <nitrix> ertes: I have A as domain, how do I bring a B for the codomain?
23:46:55 <ertes> nitrix: oh, wait, you did
23:46:58 <ertes> sorry
23:47:16 <nitrix> So `f y` makes the codomain implicit, right?
23:47:20 <ertes> nitrix: yes, your notation is fine
23:47:30 <nitrix> :D
23:47:52 <ertes> nitrix: you just implied f there, because you didn't bind it explicitly:  for all f : A → B, f is injective iff: …
23:48:05 <nitrix> Oh I see.
23:48:10 <ertes> that would make the codomain explicit as well
23:49:32 <ertes> nitrix: (side note, not terribly important:  in the context of haskell you might want to use types rather than sets as your model)
23:51:49 <nitrix> Surjective: forall y ∈ B, exist x ∈ X, f x = y
23:52:07 <ertes> nitrix: style note: rename X to A =)
23:52:21 <monochrom> I hate A and a.
23:52:26 <nitrix> Oh yeah. I'm all over the place hah :P
23:52:51 <nitrix> I also need unicode substitution for forall and exist, but anyway.
23:53:23 <nitrix> ertes: How would that become if I bring it in the "context of haskell" and use types?
23:53:29 <monochrom> http://www.vex.net/~trebla/symbols/select.html may help you
23:53:45 <ertes> nitrix: you don't need it, as long as you're precise…  "for all" and "there exists" is just something you use so much that it pays off to have short symbols for them
23:54:00 <monochrom> I think you just change ∈ to ::
23:54:05 <ertes> nitrix: well, for now it's really only a notational difference
23:54:36 <ertes> nitrix: you're only using membership, so they behave very similarly for you
23:56:31 <nitrix> forall y. y :: B, exist x. x :: A, f x = y ?
23:56:55 <nitrix> Ideally with also f :: A -> B
23:57:13 <monochrom> delete ". y" and ". x"
23:57:23 <ertes> nitrix: the most common notation is:  forall (y : B). exists (x : A). f x = y
23:57:49 <nitrix> ertes: I'll try to remember.
23:58:22 <nitrix> ertes: monochrom Very appreciated to both of you. I think it's finally clicking. It was a fairly important piece missing to my CS :)
23:59:04 <ertes> nitrix: if you want to get deeper into this, you may want to pick up a proof assistant like agda
23:59:47 <nitrix> Not really, just wanted to understand the terminology as I've been seeing it thrown around a lot lately.
23:59:52 <shayan_> I am planning to buy some books on Haskell. Would Learn You a Haskell for Great Good!; and Programming in Haskell (2e) be the best places to start?
23:59:54 <ertes> nitrix: here is the agda version:  Injective f = ∀ y → ∃ (λ x -> f x = y)
23:59:56 <nitrix> (On hackage and #haskell as well)
