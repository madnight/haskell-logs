00:15:13 <Cale> fred-fri: The compiler will typically let you know when you need to turn on extensions for stuff.
00:15:49 <Cale> fred-fri: Usually the extensions introduce new syntax, and when you go to use the syntax, the compiler will complain that you need to turn the extension on if you want it.
00:17:20 <Cale> Beware of anything of the form *Instances, apart from FlexibleInstances though. Undecidable and Overlapping instances can be used to good effect, but you kind of have to know what you're doing not to make a mess with them, and usually a complaint from GHC that you need them is just a sign you're approaching things incorrectly.
00:17:54 <Cale> (IncoherentInstances is mostly just dumb)
00:21:18 <fred-fri> cheers
00:42:16 <fred-fri> http://www.happstack.com/page/blog last post is from 2013... is there any haskell webapp library that is more actively maintained than the others?
00:45:57 <ertes> fred-fri: non-exhaustive list in no particular order: scotty, servant, snap, Spock, wai (low level), yesod
00:46:13 <ertes> fred-fri: happstack is also still maintained
00:47:03 <fred-fri> scotty seems simple and without too much magic, a good candidate framework for making a first haskell webapp
00:47:26 <ertes> fred-fri: yeah, and snap-server (not snap) is similar in that regard
00:47:45 <fred-fri> might try both :)
00:50:19 <doubleleft> If a function is implemented with Monad, does it have side effect?
00:50:48 <geekosaur> depends on the monad
00:50:58 <ertes> doubleleft: you mean only with a Monad constraint?  like:  (Monad m) => (a -> m b) -> [a] -> m [b]
00:51:32 <doubleleft> ertes: yeah
00:51:47 <ertes> doubleleft: then it won't have any *effects* (not *side* effects)
00:52:03 <ertes> doubleleft: monads don't allow *side effects* anyway
00:53:43 <doubleleft> what if a IO monad?
00:54:14 <mniip> functions in the IO monads don't have any side effects either
00:54:19 <mniip> IO *values* though
00:54:52 <mniip> I mean, putStr as a function is pure
00:55:29 <doubleleft> mniip: Thanks
00:56:12 <ertes> doubleleft: those are IO effects…  they can't violate haskell's sense of purity: equational reasoning still works
00:56:40 <ertes> doubleleft: for example if you write line = getLine, then 'line' and 'getLine' are both the same IO action: the one that reads a line
00:57:18 <doubleleft> ertes: Thanks , I can understand this.
00:58:35 <doubleleft> ertes: but is an *act*  meaning a function?
00:59:06 <ertes> doubleleft: in haskell a function is a value of type (A -> B) for some A and B
00:59:21 <ertes> nothing else is a function
01:00:11 <ertes> doubleleft: for example (putStr :: String -> IO ()) is a function, but (getLine :: IO String) is not
01:00:46 <ertes> the hallmark of a function is that you can apply it:  putStrLn "blah"  -- the function putStrLn applied to "blah"
01:00:51 <doubleleft> ertes: oh , yes 
01:03:26 <doubleleft> ertes: putStrLn::String->IO () is a function and an action?
01:03:48 <ertes> doubleleft: it's a function that returns an IO action
01:04:08 <ertes> given a string, it returns the action that prints that string
01:08:28 <doubleleft> ertes: well, i'm always wrong. I'm a pure noob in haskell.
01:08:45 <ertes> doubleleft: you're learning =)
01:09:10 <nshepperd> hmm, IO actions are a bit like procedures... such as in C, 'void PrintHello() { ... }'
01:09:22 <nshepperd> but no-one uses the word 'procedure' any more, it seems
01:09:43 <ertes> doubleleft: the idea is: your "haskell program" is actually just a single IO action called 'main'
01:10:09 <ertes> your program *is* that action:  main = putStrLn "hello"  -- your program is the action that prints "hello"
01:10:56 <ertes> doubleleft: you can compose actions by using do-notation or monadic combinators like (>>) and (>>=)
01:11:10 <ph88^> glguy, i was thinking to use this package https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html with function getContents to read the binary file in chunks, is that the right way to go ?
01:11:31 <ertes> putStrLn "hello" >> putStrLn "world"  -- this is an IO action that first does what (putStrLn "hello") does, then what (putStrLn "world") does
01:11:45 <ertes> main = putStrLn "hello" >> putStrLn "world"  -- you can make this your program
01:12:00 <doubleleft> I can't understand monad now . it seems so complex
01:12:11 <ertes> don't understand "monads"…  understand IO
01:12:28 <ertes> monads can come later
01:12:51 <ertes> doubleleft: does your brain accept the fact that "actions" are just values like every other value?
01:13:05 <doubleleft> ertes: Yeah, I can use IO now. 
01:13:28 <ertes> doubleleft: so you have no trouble with composing IO actions using regular functions like (>>)?
01:14:04 <doubleleft> ertes: I didn't use (>>) 
01:14:20 <doubleleft> just do-notation
01:14:37 <ertes> well, then try it:  given two IO actions c and d, (c >> d) is the action that first performs c, then d
01:15:02 <ertes> just like:  given two integers x and y, x + y is the integer that's the sum of x and y
01:15:48 <ertes> do-notation is just syntactic sugar:  (do c; d) = c >> d  -- it makes your program *look* side-effecting, when in fact you're just composing IO actions
01:16:32 <doubleleft> So , a program like main is just a value composing with some actions ?
01:16:41 <ertes> exactly
01:17:20 <doubleleft> ertes: Thanks a lot.
01:17:50 <ertes> doubleleft: here is a more detailed and expanded explanation: https://www.vex.net/~trebla/haskell/IO.xhtml
01:20:36 <doubleleft> ertes: thx, I 'm reading the paper Monads for funtional programming and trying to understand monads. 
01:22:01 <doubleleft> I'll read it
01:35:11 <makalu> I'm slightly confused about stackage. We can see from here https://www.stackage.org/lts-7.14/package/mtl-2.2.1 that lts-7.14 (GHC 8) has mtl 2.2.1 which requires transformers==0.4.* but lts-7.14 has transformers 0.5.2.0 https://www.stackage.org/lts-7.14/package/transformers-0.5.2.0
01:37:34 <lyxia> where do you see it requires transformers==0.4.*
01:38:04 <lyxia> makalu: I see >=0.4 && < 0.6
01:38:16 <makalu> https://github.com/ekmett/mtl/blob/ba6960330f25aff2dbb9e9400829a5bb128846ec/mtl.cabal
01:39:42 <lyxia> this is a commit from 2014
01:40:28 <lyxia> seems it's been modified on hackage since then
01:41:22 <lyxia> makalu: OK so this is the update that took place https://hackage.haskell.org/package/mtl-2.2.1/revisions/
01:42:11 <fred-fri> doubleleft, this is the best explanation ive come across https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/3-pure-functions-laziness-io
01:42:52 <fred-fri> this section especially
01:42:54 <fred-fri> main = putStrLn "Hello World!" Run this code and you'll see that it miraculously makes text appear on your screen. A pure function can't do that -- it cannot have side effects! So what's happening here? Haskell runtime evaluates main (it's really just an expression). The trick is that main evaluates not to a simple value but to an action. The runtime then executes this action. So the program itself has no side effects, but 
01:42:54 <fred-fri> the action does. And this so called IO action is invoked after the Haskell program has run, so we don't break the functional nature of the program.
01:43:25 <makalu> lyxia: unfortunately the .cabal file in the hackage archive still has the old constraint :S
01:46:31 <fred-fri> doubleleft, hopefully that illustrates the point to you. also, note that there isnt necessarily any connection between monads as a concept and IO. there are non-monadic ways which IO could have been done in haskell, and there are other monads than the IO monad.
01:47:11 <lyxia> makalu: that may be an issue to report to hackage
01:48:16 <makalu> there are a whole bunch of packages like that. For example, old-locale has base<4.9 and the metadata has been changed https://hackage.haskell.org/package/old-locale-1.0.0.7/revisions/
01:54:44 <M0000> anyone here?
01:55:22 <Rembane> M0000: Yes.
01:55:49 <M0000> I’m a haskell beginner and running into some trouble, I’ll trying to hpaste it and put the link here
01:57:19 <M0000> oh wait I think I may have solved it. I was using “type T a = State SomeData a” and later trying to make T an instance of a class.
01:58:09 <M0000> I changed it to “type T = State SomeData” and it’s working better, or at least getting past that point in compiling my application. I have to deal with a few more things, but it looks better.
02:00:33 <magneticduck> is there a typeclass for something similar to an inner product space in any base or well-used libs? 
02:00:35 <Rembane> M0000: Sweet!
02:01:24 <M0000> I’ll come back here if I still have trouble, but for now it seems to work
02:01:47 * magneticduck wishes (+) weren't in the Num typeclass ...
02:11:02 <Cale> M0000: 'type' only defines a synonym, rather than a distinct type, you could also just write the instance for State SomeData directly (or if I can guess correctly what you're doing, State s)
02:12:10 <Cale> M0000: It's not possible to have different instances for synonyms as for the type you're defining a synonym of, since you've only defined a new name for an existing type, which will be treated in all respects by the typechecker as identical.
02:13:36 <M0000> hmm, I’m not sure I follow. The first thing I did in my app, a long time ago, is define this type synonym for convenience in using a state monad. type T a = State SomeData a"
02:14:11 <M0000> then later I defined some of my own pseudorandom number processing functions and wanted to keep the StdGen state in SomeData.
02:15:40 <M0000> hmm this isn’t hte best way to explain it, but I think it’s going to work for now, so I’ll just carry on with my project and let you know if I need more help
02:16:05 <pavonia> I guess the problem was that the instance definition required T to be used as kind * -> * while the definition requires it to be fully applied to type parameters
02:16:26 <M0000> pavonia: that seems right
02:17:11 <Cale> Yes, that's the problem -- well, and I think you'd need an extension to be able to define an instance for the synonym in the first place?
02:17:34 <merijn> Instances for synonyms requires FlexibleInstances
02:18:13 <Cale> TypeSynonymInstances, isn't it?
02:18:20 <M0000> I was using TypeSynonymInstances and FlexibleInstances already
02:18:25 <merijn> Really? Is that new?
02:18:34 <merijn> I coulda sworn it used to be FlexibleInstances
02:18:36 <M0000> I’ve always needed both
02:18:42 <Cale> FlexibleInstances is for instances which specialise the parameters to a type constructor
02:19:10 <Cale> Like, if you wanted to define an instance C (Foo Bar) rather than  instance C (Foo a)
02:19:41 <Cale> You shouldn't ever really *need* TypeSynonymInstances, because you can always unfold the definition of the instance yourself
02:19:54 <Cale> which is probably something you should usually do anyhow
02:20:27 <miladz89> question -> I have a project in a sandbox and it has a dependency (mongoDB). when I build the project it build fine but when I want to load a .hs file into ghci it says "Failed to load interface for ‘Database.MongoDB’". what is going on here ?
02:20:32 <maerwald> ertes: I think last time we spoke about IFC/MAC and I thought about it a bit... it's actually similarly problematic to what we have in cryptography: even if you wipe out sensitive memory regions, you still have little to no control about where on the stack and in what registers things end up.
02:20:32 <maerwald> ertes: so, how can we know that what we express at type level actually holds on the lower level wrt IFC/MAC? Does the memory model of GHC implicitly give that?
02:20:33 <Cale> Type synonyms sometimes serve a purpose, but mostly they just make documentation and type errors harder to understand.
02:20:44 <merijn> Cale: Perhaps FlexibleInstances implies TypeSynonymInstances? Because I've never used type synonym instances :)
02:20:56 <geekosaur> miladz89, use the sandbox's ghci wrapper or it won;t be able to see the sandbox
02:21:03 <geekosaur> (cabal repl or stack ghci)
02:21:05 <Cale> Perhaps, or maybe you just never bothered writing an instance for a type synonym
02:21:13 <magneticduck> can anybody convince me why it doesn't make sense to instance a typeclass for a particular specialization of a higher-kinded type? so e.g. instance Show (MyContainer Char)
02:21:15 <merijn> Cale: I coulda sworn I have a bunch of times ;)
02:21:23 <miladz89> I also created a question on stackoverflow http://stackoverflow.com/questions/41825586/cabal-dependency-is-not-recognized-by-ghci
02:21:47 <magneticduck> (while it makes perfect sense to do "instance Show a => Show (MyContainer a)"
02:21:53 <merijn> magneticduck: Because that overlaps with the instance "Show a => Show (MyContainer a)"?
02:21:58 <miladz89> geekosaur: ok, I will search about that
02:22:07 <magneticduck> merijn: I only have one of them defined
02:22:07 <Cale> merijn: ah, yeah, it appears to
02:22:42 <Cale> magneticduck: It may make sense...
02:22:55 <merijn> magneticduck: Well, the main argument against only defining "Show (MyContainer Char)" is that it makes it impossible for someone else to define "Show a => Show (MyContainer a)"
02:22:58 <geekosaur> sandboxes hide stuff from ghc, that's the point. ghci is ghc; it won't see inside the sandbox unless specifically run within the sandbox. which means the wrappers I mentioned, or stack/cabal exec ghci)
02:23:20 <merijn> magneticduck: Now, you maya rgue that "no one should define that instance", but how solid that argument is depends on context :)
02:24:10 <magneticduck> merijn: I see. So how do things work if I, after deciding that Show a => Show (Container a) is reasonable, want to implement StrongerTypeclass a => Show (Container a)?
02:24:22 <merijn> magneticduck: Well, they don't :)
02:24:36 <miladz89> geekosaur: it worked like magic, thank you.
02:24:45 <geekosaur> also neither cabal-install nor stack is known to ghc/ghci, so it can;t automatically figure out which one you wanted and load its sandbox
02:24:48 <Cale> magneticduck: Then you replace the original instance
02:24:53 <merijn> magneticduck: Which you can, depending on religious considerations consider either a bug or a feature :)
02:25:24 <Cale> You should basically never need to implement Show by hand anyway :P
02:25:26 <merijn> magneticduck: Haskell requires instances to be globally unique (which is why overlap is disallowed, because that means there are types where two instances could be valid"
02:25:48 <magneticduck> I'm asking this because it was unintuitive to me that no-extension GHC wouldn't permit my original attempt at an instance
02:25:53 <magneticduck> but okay, it makes a little more sense now
02:26:02 <Cale> always use the derived instance of Show unless you're not exporting the data constructors of your type and want the Show instance to provide working code for generating the values externally to the module
02:26:05 <merijn> magneticduck: Scala, for example, does not require uniqueness for typeclasses, but that means you often have to 1) explicitly specify the instance and 2) things like order of imports can affects interpretation of code
02:26:21 <Cale> magneticduck: Some things to realise:
02:26:49 <Cale> When you have an instance (...) => C (T a)
02:27:08 <Cale> It looks the same to the instance resolver as instance C (T a)
02:27:08 <merijn> magneticduck: The main gripe I've heard about Scala is how hard non-uniqueness of instances makes it to reason about what code is doing. So I agree that it is often a pain when you want a nice specialisation, but it also makes life simple in lots of ways you don't currently notice
02:27:30 <Cale> i.e. the type class constraints on an instance do *nothing* to affect which instance is selected
02:27:41 <merijn> magneticduck: As for the "what do I do if I want another/special/custom instances for reason X?", the usual solution is to use a newtype and write an instance for that
02:27:47 <Cale> They only affect whether you're allowed to use the instance after it gets picked
02:28:43 <Cale> This is because type class instances are open -- the decision procedure for selecting which instance applies never relies on the fact that some instance is missing
02:28:59 <Cale> because it might be provided in a future module which hasn't been compiled or hasn't been written yet
02:29:49 <Cale> (So, if it did compile code making use of that fact, it would result in confusing or incoherent behaviour in those future modules when the instance later becomes available)
02:31:02 <magneticduck> typeclasses definitely aren't vtables :P
02:31:11 <magneticduck> they're just syntatic sugar for dictionaries at some level, right?
02:31:13 <Cale> The system is generally designed such that only one instance should ever apply to a given type -- there is an OverlappingInstances extension, and a few others along with it, which will let you write instances that overlap with each other, and resolve which one to use on various criteria... but generally don't use those.
02:31:24 <merijn> magneticduck: In GHCs implementation, yes
02:31:47 <merijn> magneticduck: Well, with the added advantage that statically known dictionaries can be inlined completely and thus become overhead free
02:32:07 <Cale> Yes, however, more importantly, they're specifications of effectively global conventions for how operations are to be implemented on a type-by-type basis
02:32:27 <iphy> https://hackage.haskell.org/package/expiring-cache-map is a caching map that recomputes its value by performing an action and storing the result after N time units
02:32:29 <Cale> If you want multiple behaviours for a single type constructor, you should just define a record type for the methods and not bother with type classes.
02:32:38 <merijn> magneticduck: Such as "plus :: Int -> Int -> Int; plus = (+)", here GHC can preemptively just replace all the dictionary passing, etc. with the inlined implementation of + for Int
02:32:47 <iphy> this is great, but the problem is that accessing the data will  take up to as long as the action to compute it takes
02:33:53 <iphy> is there a way to configure it to return the old data immediately and then recompute the new value in the background?
02:35:54 <magneticduck> so "instance C (T Concrete)" would be saying "T is a C. Its inner type must be Concrete if this is to make any sense."
02:37:13 <Cale> magneticduck: yeah, pretty much
02:37:37 <iphy> magneticduck: what is a vtable if not a dictionary of function names to addresses?
02:38:08 <Cale> Well, it's saying that T Concrete is an instance of C, but it's also implying that there won't be a general instance -- there may be some other concrete ones.
02:38:55 <magneticduck> iphy: well vtables can be used for sorts of runtime polymorphism
02:38:58 <Cale> You might also have instances for T Integer and C (T a) => C (T [a]) or something
02:41:16 <Cale> iphy: I don't know how far I'd trust that package... I mean, it doesn't look too terrible, but there's some code in it that looks slightly beginner-ish
02:41:54 <iphy> Cale: no idea, I haven't looked at the code - I just searched for some cache map and found this
02:42:13 <iphy> I need an expiring cache for a web app
02:42:37 <iphy> the web app presents something that takes 5 seconds and a lot of backend calls to compute
02:42:41 <Cale> If I had to guess, the author probably has experience with other functional programming languages, but is somewhat new to Haskell, looking at how the types are defined using newtypes of tuples rather than data declarations...
02:42:51 <iphy> but it's ok for the data presented to be slightly stale
02:43:15 <iphy> Cale: I don't really care, I just care about that it does what it's supposed to
02:43:19 <Cale> sure
02:43:30 <iphy> if it's implemented in BASIC, I'm fine with that as well
02:44:43 <Cale> I might use this too, but I also wouldn't be surprised if I ended up having to reimplement it in anger :)
02:44:52 <iphy> the package does as advertised
02:45:12 <iphy> but now I would like to do something it doesn't advertise: return the cached value immediately, and recompute in the background
02:45:43 <iphy> that obviously requires concurrency and some management thereof inside the library
02:45:51 <iphy> which is a lot more complex than just the expiring cache map
02:46:27 <Cale> It does expose its internals somewhat
02:50:26 <Cale> iphy: Hmm, it appears to require you to set up which IO action will be used to obtain new values at the outset. However, you might be able to do something cheesy with async and unsafeInterleaveIO there.
02:51:16 <Cale> iphy: i.e. set that IO action to be something which uses async to fire off a thread to do the work in the background, and immediately  unsafeInterleaveIO (wait a)
02:51:39 <Cale> Which will return to you a magical value whose evaluation will wait on that async
02:51:56 <Cale> (and produce the result of the async immediately if it was finished)
02:52:14 <Cale> Not the prettiest solution, but it'd probably work.
02:52:22 <atondwal> what's the name of that tool that fills in holes with code?
02:52:32 <Cale> Agda ;)
02:52:40 <atondwal> haha
02:52:54 <atondwal> there's a haskell tool that like guesses what goes in the hole based on the type
02:53:03 <atondwal> it's like genie or something?
02:53:08 <atondwal> some too-clever name...
02:53:12 <Cale> Are you thinking of djinn?
02:53:31 <atondwal> yes!
02:53:34 <atondwal> thank you!
02:53:45 <Cale> djinn writes code based on the type, though I'm not sure it works in-place
02:53:49 <MarcelineVQ> possibly better off with https://github.com/lspitzner/exference
02:54:00 <Cale> (and it's not quite Haskell code)
02:54:21 <Cale> Well, it's moderately reasonable to call it a subset of Haskell
02:54:56 <atondwal> ghc-mod seems to massage it into something that works in-place
02:55:15 <cbaatz> What's the risk with creating a type where <*> /= ap for the Applicative and Monad instances respectively? I'm thinking I'd like an error type that aggregates when used as an applicative, but fails immediately when used as a monad (because it can't bind without a value). That functionality seems intuitively reasonable to me: use applicative when I don't need monad and get all errors, but accept failure and only the first error when I need
02:55:15 <cbaatz>  the stronger monad bind. Such an error type is easy to write, but it violates the <*> /= ap law (because ap is defined in terms of bind). What I don't understand is what problems are likely to occur if I wrote something where <*>  is not the same as ap -- would I get unpredictable behaviour?
02:56:01 <roxxik> no
02:56:11 <roxxik> people using your code will get confused
02:56:39 <roxxik> and maybe something breaks if some rewrite rule fires
02:57:43 <quchen> cbaatz: Classical example: concurrent IO.
02:57:49 <cbaatz> OK, so it could be that the compiler is relying on <*> == ap and if it rewrites something I would get unexpected behavior?
02:58:05 <quchen> There used to be a newtype wrapper in Async that had parallel <*>, but the monadic ap was obviously not parallel.
02:58:07 <roxxik> generally it is (sometimes) ok to break the laws if you tell anyone so. There are some examples for this in some major packages
02:58:34 <cbaatz> quchen: Could you elaborate on what you mean by concurrent IO?
02:58:35 <quchen> Refactoring code from ap to <*> meant all of a sudden things ran in parallel, and chaos ensued.
02:59:18 <iphy> Cale: but that will still delay the actual http response
02:59:33 <iphy> even though it looks magical, it'll just delay at a different point in the program
03:00:23 <quchen> cbaatz: Let me write something up, hold on.
03:00:35 <Faucelme> cbaatz: I would use some kind of newtype in your case, perhaps with some helper function.
03:00:46 <cbaatz> quchen: Thanks!
03:01:09 <cbaatz> Faucelme: You mean around existing Except or something instead of writing a new type from scratch?
03:04:09 <Faucelme> If you are already using Except, it seems reasonable. Control.Applicative.Lift in transformers already has an error-accumulating type: type Errors e = Lift (Constant e)
03:04:57 <Faucelme> Perhaps you could write a function that went from Compose (Errors [e]) IO r to ExceptT [e] IO r. 
03:05:03 <Grisha> Hi guys, I’m drowning in Persistent types and typeclassses, any particular read beyond the hackage pages and the yesod online book you could recommend?
03:09:36 <quchen> cbaatz: Consider this, http://lpaste.net/
03:09:44 <Axman6> my experience with Persisten has lead me to the point where I'm not going to use it any more. the schema definitions and stuff you get "for free" are nice to begin with, but end up hosting a lot once you start needing to do things it wasn't deigned for. Esqueletto helps a wee bit, but it's more a bandaid than a solution
03:09:53 <Axman6> Persistent*
03:10:02 <quchen> It defines a »Concurrent« wrapper around IO. The Applicative is implicitly parallel, evaluating mf and mx at the same time.
03:10:16 <cbaatz> Faucelme: Does using Control.Applicative.Lift somehow get around the problem of ap /= <*>?
03:10:32 <Axman6> I've been toying with hasql this week, which takes a little getting used to, but once you do it's really nice, and lets you write the exact queries you want to run without too much effort
03:10:55 <Axman6> oh, Grisha left :(
03:11:06 <cbaatz> Since Lift isn't a monad, I'm not sure how that would work -- it sounds like Lift would modify the behaviour of <*> for the applicative (to accumulate) but that would leave it inconsistent with the ap from the ExceptT monad?
03:11:22 <quchen> cbaatz: Now consider the code  »readFileStuff "foo.txt" `ap` readFileData "foo.txt"«. This might be fine, because ap is sequential (being from Monad). If you change the ap to <*> you’re in Hell’s kitchen, because you’re reading and writing from/to the same file.
03:11:48 <cbaatz> quchen: The link is blank..
03:11:50 <MarcelineVQ> quchen: your lpaste link is empty
03:11:52 <MarcelineVQ> :>
03:12:00 <quchen> Huh?
03:12:00 <quchen> http://lpaste.net/351594
03:12:12 <quchen> Woops.
03:12:17 <quchen> cbaatz: That one ^
03:12:23 <cbaatz> :)
03:13:00 <quchen> cbaatz: Point is, the ap=<*> is a law users rely on. If you violate it, you should make it very clear that it is violated, and encapsulate the violation in your library so it’s not observable from the outside.
03:13:11 <Faucelme> cbaatz: Your could have a helper function to move from Errors to ExceptT. I would not put it in the same monad.
03:13:15 <MarcelineVQ> Concurrent(ly) is already a newtype in async btw, in case it matters
03:13:28 <quchen> MarcelineVQ: Yes, but the Monad instance was removed :-)
03:13:52 <quchen> cbaatz: For a famous example, consider Haxl, which does violate the Monad laws, and you have to be careful as a programmer not to do things in the wrong order.
03:14:57 <quchen> cbaatz: Violating the laws takes away a form of (socially enforced) safety given by the class laws, so you (and all users) have to think. Thinking is not something we want to do, that’s the compiler’s job ;-)
03:15:38 <quchen> cbaatz: That said, the Haskell Report is very clear in stating that class laws are *not* mandatory, and may be violated if required.
03:16:11 <quchen> cbaatz: Point is, you’re venturing into unsafe territory, which should be avoided if you can. If you can’t go for it, but add lots of warning signs ;-)
03:16:51 <quchen> cbaatz: If you tell us more about your use case we could try figuring out something more specific
03:16:52 <cbaatz> quchen: Thank you! It sounds to me though that this is more about <*> being expected to not be parallel than <*> needing to equal ap?
03:17:22 <quchen> cbaatz: This is just an example of where <*> is observationally different compared to ap.
03:17:44 <quchen> cbaatz: Other example, imagine the List Applicative being ZipList-y, and the Monad with the usual behaviour.
03:18:00 <quchen> Everything typechecks and what not, but if an innocent programmer replaces ap with <*> or vice versa everything breaks.
03:19:07 <quchen> cbaatz: Every Monad in Haskell gives rise to a unique Applicative (which is why we have Applicative => Monad in the first place), so the expectation that it is that very Applicative for a certain Monad is expected by most people.
03:19:42 <cbaatz> quchen: Yep, ok, that makes sense. So you're saying the main risk is people using the type would just expect ap and <*> to be equivalent, but there's nothing in GHC or similar that will cause unexpected behaviour?
03:19:49 <quchen> I can’t tell you what breaks specifically (or whether something breaks at all) in general, just that things might break, and that you have to be careful.
03:20:22 <quchen> cbaatz: No, GHC will happily accept law-violating instances. As I mentioned, it’s valid Haskell to violate class laws.
03:20:47 <quchen> »Instances of Functor should satisfy the following laws:« – Haskell Report
03:21:03 <cbaatz> quchen: Ok, that I'm curious about -- is it theoretically wrong (I'm getting out of my depth here) to have a type with a "parallel" applicative and also has a monad (because the monad can never be parallel)?
03:21:05 <quchen> »All instances of Functor defined in the Prelude satisfy these laws.«
03:21:25 <lyxia> Now you have to be aware about whether a function is using Applicative or Monad...
03:21:39 <lyxia> liftA, liftM, replicateM...
03:21:48 <cbaatz> quchen: OK, good to know GHC doesn't rely on the laws for anything.
03:21:54 <quchen> cbaatz: It depends! When all you do is reading from a database, then parallelization is fine. Sequentially and parallel...y asking gives the same results.
03:22:21 <quchen> It would be wrong for GHC to rely on laws, even! And that won’t change.
03:23:11 <quchen> cbaatz: The Applicative/Monad instances don’t have to do the same things as long as the results are always consistent.
03:23:42 <quchen> So if you know that your problem parallelizes (to stay in our example domain) then having Applicative implement a more efficient (parallel) ap is fine.
03:24:23 <quchen> This is precisely what Haxl does: Applicative is faster, but might do something different if you’re querying the same resource at the same time in special ways. So it’s up to the programmer to avoid doing that.
03:26:14 <cbaatz> quchen: Perhaps my underlying question/confusion is about whether `ap` really should be defined in terms of the monad or whether it would be valid to have it removed and just use <*> when you want the applicative behaviour (whose semantics will differ from type to type, e.g. parallel/concurrent). More pointedly is having ap a "legacy" from when Monad didn't require Applicative?
03:27:02 <quchen> cbaatz: If everything is law-abiding, ap has precisely one use case left, and that’s defining Applicative instances if you already have a Monad.
03:27:24 <quchen> namely »instance Applicative Foo where pure = ...; (<*>) = ap«.
03:27:42 <quchen> Similarly, liftA and liftM are only useful for defining fmap.
03:27:52 <quchen> Other uses I consider code smells.
03:28:00 <cbaatz> quchen: But that seems like the "wrong way around"?
03:28:21 <cbaatz> I.e. it would be better to define Applicative first.
03:29:01 <quchen> cbaatz: But if you’re lazy and you wrote the Monad, you get Functor/Applicative for free in 5 lines of copy+paste :-)
03:30:21 <cbaatz> quchen: OK, fair, but would you then say that in an ideal world, ap would only be use as a shortcut to define <*> and never used anywhere else?
03:30:22 <quchen> cbaatz: Lunch’s over I’m afraid, but we can go on later :-)
03:30:36 <ski> cbaatz : it can be easier (possibly also more efficient in some cases ?) to define `Applicative' (or `Functor') in terms of `Monad' (or `Applicative')
03:31:04 <cbaatz> quchen: Thanks for your help, much appreciated!
03:32:46 <ski> cbaatz,quchen : another possible use for `ap',`liftA',`liftM',`return',`map',&c. is to use it in a context where you're already requiring (or want to enforce requiring) the narrower context (or more specialized type). so the idea is that by using the more specific operation, readability of the code may be helped
03:32:47 <cbaatz> ski: understood, and I get the use case for having ap to define <*>, but it seems perfectly reasonable/valid to have an applicative whose behaviour isn't the one you'd get from the monad implementation.
03:33:17 <cbaatz> I.e. that the requirement that ap == <*> seems too strong.
03:33:28 * jstolarek needs help with monad transformers
03:33:58 <ski> (e.g. distinguishing between one applicative functor, and a monad, that you're using simultaneously. instead of using `liftA' for both, you can use `liftA' for the former and `liftM' for the latter, so that the reader more easily can follow which operation pertains to which "structure" of the applicative functor and the monad)
03:34:06 <jstolarek> I need to combine Error ans State in such a way that I either get (Either error (result, state))
03:34:14 <jstolarek> type M = StateT S (Except E)
03:34:26 <jstolarek> is that correct wai fo doing this or should I go the other way around?
03:34:38 <ski> cbaatz : i'm not seeing why you can't just use a `newtype' or something, if you want a different `(<*>)' there ..
03:34:39 <merijn> @unmtl StateT s (Except e) a
03:34:40 <lambdabot> s -> Except e (a, s)
03:35:10 <merijn> hmmm
03:35:21 <merijn> Does it only do one layer or does it not know Except?
03:35:25 <ski> cbaatz : iow, afaiui, you're only asking for the convenience of not having to `newtype' stuff to distinguish between (the externally observable behaviour) of `(<*>)' vs `ap'
03:35:26 <merijn> @unmtl s -> Except e (a, s)
03:35:26 <lambdabot> s -> Except e (a, s)
03:35:42 <jstolarek> merijn: that actually looks right
03:35:45 <ski> merijn : it doesn't know `Except', substitute `Error' for it, when using `unmtl'
03:35:51 <jstolarek> here's a second question
03:35:51 <merijn> @unmtl StateT s (Error e) a
03:35:52 <lambdabot> s -> Error e (a, s)
03:36:09 <merijn> ski: Looks like it doesn't know Error either :p
03:36:11 <jstolarek> I need to run an action in my monad with a different state
03:36:19 <jstolarek> withState :: S -> M a -> M a
03:36:21 <ski> sorry, it should be `ErrorT'
03:36:26 <ski> or else `Either' :)
03:36:30 <jstolarek> I came up with:
03:36:32 <merijn> @unmtl StateT s (ErrorT e m) a
03:36:32 <lambdabot> s -> m (Either e (a, s))
03:36:32 <jstolarek> withState state thing = lift (evalStateT thing state))
03:36:56 <jstolarek> but I'm not sure if it correctly handles the state
03:37:10 <jstolarek> ie. I don't want the state to be altered after the execution
03:37:18 <ski> @unmtl ErrorT e (StateT s m) a
03:37:18 <lambdabot> s -> m (Either e a, s)
03:37:26 <ski> that ^ obviously doesn't do what you want
03:38:48 <cbaatz> ski: well, I'm asking about why a type can't have an applicative instance that's different from the ap function, other than because people expect it. That is, is there a theoretical reason for why having a parallel applicative behaviour is inconsistent with also having a monad instance.
03:39:21 <ski> jstolarek : if you want the state to die on exception, then `StateT s (ExceptT e m) a' (or s/ExceptT e m/Either e/, if you prefer not having a "lower" monad in the transformer stack)
03:39:44 <jstolarek> ski: yes, that seems to be what I want
03:40:49 <ski> jstolarek : for the second question, do you want to revert to the original state, or revert to the provided state argument, or continue with the final state after the inner computation ?
03:41:20 <merijn> cbaatz: I don't think that, functionally, there's a difference between paralle applicative and a monad, I think the main reason why that's usually avoided (i.e. Concurrently in async) is that people might write code that is accidentally sequential when it could be parallel
03:41:28 <ski> iiuc, you want one of the former two options, but i'm not sure which of them
03:41:49 <merijn> cbaatz: So by preventing sequential (i.e., monadic) code from being written you protect users from that pitfall
03:41:50 <jstolarek> ski: revert to original state
03:42:13 <ski> cbaatz : it makes it harder to reason about and refactor code
03:42:58 <cbaatz> merjin, ski: alright, got it, that seems to answer my questions. Thank you!
03:43:11 <ski> jstolarek : the original state, which was in effect before setting to the provided argument state ?
03:44:58 <jstolarek> ski: yes, exactly
03:45:23 <ski> jstolarek : in that case, your `lift' is the right way : it just passes the implicit state through (into the "box" and out of it), unchanged (not passing through the internal computation, which instead uses a different state, the provided argument, which is an "extra wire" that's plugged into the internals, and dropped after that has finished)
03:46:03 <merijn> cbaatz: Althought it can be annoying too, I had a orphan Monad instance for concurrently in some throwaway code so I could use it as base in a transformer stack
03:46:21 <ski> (the "outside" implicit state is bypassing the internal computation)
03:47:38 * jstolarek sighs
03:47:44 <jstolarek> looks like I got it right
03:51:04 <ski> cbaatz : .. generally speaking, we prefer more ways to reason and refactor (usefully) about code -- often we'd be better off with all the help we can get in this department -- obviously subject to the restriction that we may *need* certain expressivity properties for handling ("covering") our problem domain well enough
03:51:13 <ski> cbaatz : but in this case, it seems to be only a convenience argument, so i'd a priori prefer erring on the side more "reasonability" (and somewhat less convenience)
03:55:12 <ski> (typically, increasing expressivity tends to decrease "reasonability" (of which modularity and composability is a part), and vice versa. in this context, convenience is generally of less importance, though it may make an important difference in particular cases (cf. constant factors in complexity theory; ..
03:55:19 <ski> .. and the ease, or lack of it, to express some language/library feature (say local functions, or polymorphism) syntactically can affect how eagerly one's to reach for it)
03:56:04 <ski> Cale : "This is because type class instances are open -- the decision procedure for selecting which instance applies never relies on the fact that some instance is missing","because it might be provided in a future module which hasn't been compiled or hasn't been written yet"
03:56:12 <ski> Cale : well, there are FDs, which prohibit certain instances to cohabit the same class .. perhaps there should be a way of specifying that certain patterns of multiple instances for multiple type classes (e.g. "overlap"/"non-disjointness") should never occur ?
03:56:24 <maerwald> ski++ wrt expressivity
03:56:32 <cbaatz> merijn, ski: yeah, I get the argument for making things as easy to reason about as possible, but going so far as making it a "law" that ap == <*> doesn't seem right in the cases you want a different trade-off.
03:58:41 <merijn> tbh, I think 'ap' should be relaxed to be <*>
03:58:51 <merijn> Like has been done with other operators
03:59:01 <merijn> Same for liftM<N>
03:59:28 <merijn> oh, wait, I think I remember why that wasn't done :\
03:59:31 <ski> cbaatz : well, i don't think we (or at least I) have enough data on the situation to be able to set in stone a decision one way or the other here .. but i'm certainly leaning towards the "make it a law" position
03:59:53 <cbaatz> ski: yeah, I get that, but I guess I disagree about this particular case -- it seems perfectly reasonable to have a parallel applicative of something that's also a monad. I don't see why that's particularly hard to reason about?
04:00:00 <merijn> cbaatz: There's only one reason ap even still exists as it is, and that's part of the AMP migration plan to appease people
04:00:50 <ski> cbaatz : iirc, Cale had some cituation where it seemed to be nicer/better to not have that law, perhaps you could ask for more info on the circumstances ..
04:01:00 <maerwald> I wonder if there's a formal system to categorize/quantify "reasonability", beyond just the chomsky hierarchy stuff
04:01:53 <cbaatz> merijn: if that's the reason it exists that would explain a lot of my confusion. :)
04:02:40 <merijn> cbaatz: Normally you'd simply change the definition of 'ap' to (<*>) and be done, since Applicative is a superclass of Monad now
04:03:28 <merijn> cbaatz: But to make the AMP migration easier people suggested keeping 'ap' so that you could do "instance Applicative Foo where pure = return; (<*>) = ap" to make code work if they already had a Monad instance
04:03:30 <ski> merijn : but that's `ap' as a library-provided export, rather than `ap' as a certain thing you can always build personally from `(>>=)' and `return'/`fmap'
04:03:31 <Cale> Well, I can understand why they went that way -- it is nice to have more laws to rely on, and to know that you can always replace things written using Monad operations to use Applicative notation (when possible) and vice versa
04:06:18 <cbaatz> merijn, ski: providing ap as a library export for convenience to define <*> seems perfectly reasonable, but going from there to say ap == <*> is to forbid at least some very reasonable programs.
04:06:55 <Cale> cbaatz: Well, it forbids some instances, but it doesn't come up so often.
04:08:34 <Cale> The main examples of things I've seen were cases where your monad was such that things would be happening concurrently with one another, and as the results of actions changed, the subsequent actions would be switched out dynamically (whereas there would also be a natural Applicative instance which didn't involve the switching)
04:08:37 <merijn> cbaatz: I'm not saying it's the right trade-off, just saying that's the one that was made and that's what people expect of you as a library author :)
04:08:43 <cbaatz> Cale: The idea of a dependency tree where some computations are parallel and others are sequential  seem pretty ubiquitous to me?
04:09:50 <cbaatz> merijn: Understood. :)
04:10:59 <merijn> cbaatz: As for depedency trees of computations, have you looked at Haxl?
04:11:37 <merijn> cbaatz: That's Simon Marlow's work at facebook, aimed at exactly that
04:12:32 <merijn> Actually, this has me wondering...
04:12:47 <merijn> Has someone worked on being able to combine Haxl and persistent?
04:13:06 <cbaatz> Cale: It's basically saying, unless I need the result (i.e. monad bind) of a computation, do things in parallel as much as you can (applicative). So with ApplicativeDo, we could basically get parallelism for free for existing code/convenient syntax if the type supports it (i.e. if we don't need the results).
04:13:39 <cbaatz> merijn: Yes, Haxl is one example of that structure I think.
04:14:57 <cbaatz> I meant to say "if the type supports it *and* we don't need the result".
04:17:06 <cbaatz> merijn: I'd be curious what Marlow thinks of requiring ap == <*> given his work on Haxl and ApplicativeDo.
04:18:24 <jaspervdj> I think the problem with it is if you refactor `guard noInvalidState >> someComputation` into `guard noInvalidState *> someComputation`
04:19:17 <ski> cbaatz : in one sense, in general "I need the result" is undecidable
04:19:36 <Cale> I actually really dislike ApplicativeDo
04:20:03 <Cale> It's too much magic for too little gain
04:21:35 <ski> maerwald : monochrom's comment at <http://lambda-the-ultimate.org/node/4816#comment-77080> is also relevant, he there named the concepts "cavalier power" vs. "predictive power"
04:22:37 <Cale> The best case with ApplicativeDo is that the law that ap = (<*>) really holds and the extension doesn't matter.
04:22:55 <maerwald> heh
04:23:31 <Cale> In other cases, you're just introducing a lot of confusion about how everything desugars.
04:23:34 <ski> maerwald : i think there was also another discussion on IRC (on #scheme ?) that touched on the topic. i'm not sure i found it, but perhaps the ones at 2012-12-07,2004-03-11,2004-04-04 could also be interesting (see <http://tunes.org/~nef/logs/old/> for logs of those dates)
04:24:26 <cbaatz> ski: in what sense is it undecidable? I was referring to the sense that the monad bind needs a result.
04:26:12 <ski> (presumably other people have also talked about "reasonablility", but i don't know more references)
04:26:33 <maerwald> I don't find anything on google scholar though
04:26:59 <cbaatz> Cale: you mean it's too much magic in the sense that it becomes hard to see what the code will do by inspection? Because it's unclear whether the applicative or monad instance will be used?
04:27:17 <cbaatz> Cale: If so, I think that's fair.
04:28:18 <ski> maerwald : well, there's "On the Expressive Power of Programming Languages" by Matthias Felleisen in 1991 at <http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz> discusses "expressivity" (emphasizing the difference between a feature which can be translated away locally from one which requires a global transformation)
04:28:35 <cbaatz> Cale: I think it's nice to have a way to bind applicatives to names, but that could be done without merging it with the existing do I guess?
04:32:41 <maerwald> ski: I'm interested on whether one could draw conclusions from expressivity/reasonability to software security (a little bit like langsec, but more about programming languages in practice)
04:33:03 <ski> cbaatz : in `... >>= \x -> ..x..', it can be undecidable whether `..x..' *actually* (semantically, not just syntactically) depends on the value of `x'. in case it doesn't, one could want that expression to be equivalent to `... *> ..undefined..'
04:33:06 <maerwald> formally ofc, not just smart talk :P
04:34:31 <ski> cbaatz : point
04:38:06 <ski> maerwald : elaborate on "langsec" ?
04:39:11 <maerwald> ski: treating input as a language and solving security problems (such as SQL injection) by defining sub-languages and writing parsers for those
04:39:41 <ski> Cale : .. i suppose that my idea for a unifying syntax for expressing "effectful computations" relying on `Functor',`Applicative',`Monad' would also depend on such laws
04:39:42 <maerwald> your program then becomes the "machine" for that input
04:39:42 <cbaatz> ski: Fair enough, but I don't mind having things enforced sequential if I use a bind -- if I want it parallel it's reasonable to ask me to use the applicative functions I think.
04:40:25 <ski> (reminds me i should check again the details of the `ApplicativeDo' translation, to see how it compares to my idea, wrt how complicated it is to predict the result)
04:41:07 <cbaatz> ski: what's your idea, out of curiosity?
04:41:11 <ski> maerwald : hm .. related to "weird machines" ?
04:41:16 <maerwald> yes
04:41:38 <maerwald> because not just your code is part of the machine, but everything else as well (kernel, hardware, ...)
04:41:43 <ski> maerwald : any suggestions for further reading, to learn more about this kind of stuff ?
04:41:58 <maerwald> and viewing it as one machine is not done by any programmer (just by hackers)
04:42:09 <maerwald> ski: the papers etc are here http://www.langsec.org/
04:42:35 * ski encountered a paper "The Page-Fault Weird Machine: Lessons in Instruction-less Computation", and some papers by Bratus, Becker, and some more
04:42:38 <ski> maerwald : ty
04:44:00 <maerwald> funnily, industry more goes for "methodical" stuff like "let's stuff security crap into every step of the development cycle" instead of listening to researchers that the root problem is really something different
04:45:38 <ski> ("methodological" ?)
04:45:47 <maerwald> yeah, sth like that^^
04:46:03 <maerwald> things that make project managers happy
04:46:22 <maerwald> "we have 3000 coding rules" ... "wow, such secure"
04:46:54 <ski> i suppose the same kind of managers that measures productivity in lines of code being added ..
04:46:58 <maerwald> therefore I think it could be interesting to analyze the properties of (e.g. haskell) wrt expressivity in the light of the security problem
04:47:21 <maerwald> I think the result will probably be something like "write DSLs as much as you can"
04:49:31 * ski . o O ( <https://en.wikipedia.org/wiki/Rule_of_least_power>,<https://en.wikipedia.org/wiki/Principle_of_least_privilege> )
04:50:11 <maerwald> yeah, something like that
04:50:56 <merijn> persistent-sqlite is thread safe, I assume?
04:51:10 <maerwald> ski: but that is more about chomsky hierarchy and complexity
04:51:15 <ski> (cf. e.g. restricting the module language in a Scheme system from being a particular use of the expression/command language into making it a separate language, thereby making it possible to supply nonstandard interpretations e.g. for a cross-references to chase identifiers through dependencies to sources, without having to evaluate/execute the code)
04:51:28 <maerwald> I think expressiveness is more broad and might give other insights
04:52:50 <ski> (this is related to using a deep (or deeper, at least) embedding, rather than a shallow embedding, for an EDSL)
04:54:35 <ski> cbaatz : i've been pondering it now and then, over some years. the inspiration is quasiquotation, e.g. as in the Lisps, OCaml (Camlp4/Camlp5), MetaML/MetaOCaml, TemplateHaskell quasiquotation, &c. (iirc, there's something that allows you to embed HTML in Haskell code ..)
04:56:42 <ski> cbaatz : the basic idea is to add a "sublanguage" for expressing (syntactically *local* !) *side*-effects, together with ways to switch between this language and ordinary Haskell. this language looks like (a restricted version of) Haskell, perhaps with a couple of extra new constructions, apart from the conversion ones
04:58:53 <ski> cbaatz : i haven't really decided on a concrete syntax that i'm happy with, but let's say we use `<|...|>' for "quasi-quotation" and `{|...|}' for "unquotation" the sake of the discussion
04:59:49 <ski> cbaatz : the other inspiration of it was the "idiomatic syntax" by Conor McBride (and perhaps also Ross Paterson ?), for more easily coding with applicative functors, aka idioms in the paper(s)
05:02:39 <ski> cbaatz : when using "applicative operations", `(<*>)',`(<*)',`(*>)',`(<**>)',`(<$>)' (strictly speaking `Functor', but commonly used together with the former), one issue is that you have to "annotate/instrument" every *path* in your expression tree down to a subexpression where you *actually* want to express an effect (as opposed to merely inheriting effects from subexpressions)
05:03:30 <ski> cbaatz : so, if you have a deep expression, and decide you want to plug in another effect in a certain place, inside a non-effectful expression, you have to annotate the whole path down through it
05:04:19 <ski> cbaatz : obviously this also applies to cases using `liftA2',`liftA3',&c., and also monadic counterparts, `ap',`liftM2',`liftM3',&c.
05:05:29 <ski> cbaatz : in the "idiomatic application" syntax, you'd write something like (i don't recall exact concrete syntax on the top of my head) `[| f e0 e1 e2 |]' to express `f <$> e0 <*> e1 <*> e2'
05:06:02 <ski> cbaatz : however, the problem with this, from my POV, is that it doesn't go far enough, it doesn't apply recursively to the subexpressions `e0',`e1',`e2'
05:07:57 <Philippa> ski: this is the point at which you start reinventing something like Frank, yeah
05:08:21 <Philippa> (but it's a trade-off vs "escape-back-to-pure" brackets that aren't ordinary parens)
05:09:20 <cbaatz> ski: Are you saying you somehow want to hide the effects (e.g. monad, applicative, or IO computation) from the types "up the path"?
05:11:03 <ski> cbaatz : if you want to express `f <$> (g x <$> e0 <*> pure y) <*> pure z <*> (i <*> (h <$> e1) <*> e2)', you could then do that as `[| f [| g (pure x) e0 (pure y) |] (pure z) [| id i [| h e1 |] e2 |] |]' (perhaps you could actually write `[| g (pure x) e0 (pure y) |]' as `[| (g x) e0 (pure y) |]', with the first pair of round brackets mandatory. i'm sure how this detail of the syntax is handled)
05:11:28 <ski> cbaatz : iiuc what you're saying (or vice versa), yes
05:12:32 <ski> cbaatz : anyway, the problem here, from my POV, is that we have to keep adding all these `[| ... |]' "noise brackets" all over our expression, distracting from where the (basic/atomic/primitive, wrt this expression) effects actually (may) occur
05:13:35 <Axman6> just use (dowhatImean| f g x e0 y z...|) :P
05:15:30 <ski> cbaatz : btw, note that if the operator in an "iterated effectful application" also should be effectful, then we need to add an `id' (or `($)', if you prefer) (before `i' above) to effect that intent
05:17:02 <ski> cbaatz : so, with the for-purposes-of-present-discussion syntax i mentioned, my version of this expression would be `<| f (g x {| e0 |} y) z ({| i |} (h {| e1 |}) {| e2 |}) |>'
05:17:23 <cbaatz> ski: sorry, I'm probably missing something, but are you saying you want a kind of "do" notation for non-monads? Some syntax that makes it more convenient to use applicatives (in your example)?
05:19:10 <ski> cbaatz : `<| ... |>' ("quasi-quotation") around the whole expression is for going back to ordinary *side*-effect-free (but still effectful, capable of expressing effects, with "enhanced" types) Haskell, from this alternative sublanguage, that looks like Haskell, apart from being side-effectful
05:20:29 <michaelt_>  I seem to remember McBride's preprocessor writing [| g (pure x) e0 (pure y) |] as (| g ~x e0 ~y |) fwiw
05:20:34 <ski> cbaatz : while `{| ... |}' ("unquotation") is wrapping the *exact* spots at which we want to "splice" in some "effectful computation" (a value *expressing* an effect) of type `T X', `T' being a monad, an idiom (aka applicative functor), or perhaps only an ordinary functor
05:21:37 <ski> cbaatz : no, this is not "a kind of \"do\" notation" at all. you could think of it as an alternative for `do' (though meant to also be applicable to `Applicative' and `Functor', hence some similarity with the `ApplicativeDo' extension)
05:23:25 <ski> cbaatz : btw, i think it's paramount that if you don't see a literal syntactic `{| ... |}' expression, in some "side-effectful expression" of this type (like the expression wrapped inside `<| ... |>' above), then that subexpression introduces *no* (side-)effect !
05:24:03 <ski> there will be no such thing as a call to a function implicitly including side-effects into the expression here
05:24:55 <ski> the point is that this side-effectful sublanguage should be "lexical/local", you should be able to spot at a glance all the sources of effects in the expression, without having to chase the signatures of the called functions e.g.
05:26:27 <ski> (well, either literal syntactic `{| ... |}' expressions, or perhaps one or two other special forms which could also introduce side-effects)
05:27:47 <ski> it's all about changing the POV between viewing it as talking about "recipes" (values) that expresses effects, together with final results, and viewing it as talking about side-effectful expressions that compute to a result, but may also perform some effect "on the side"
05:27:56 <ski> cbaatz : anyway, here's a very simple concrete example
05:28:13 <ski>   data Person = MkPerson Name Age Address
05:28:21 <ski>   parseName :: Parser Name
05:28:27 <ski>   parseAge :: Parser Age
05:28:36 <ski>   parseAddress :: Parser Address
05:28:46 <ski>   parsePerson :: Parser Person
05:29:03 <ski>   parsePerson = MkPerson <$> parseName <*> parseAge <*> parseAddress
05:29:27 <ski> with my idea, this implementation would be expressed instead as
05:30:00 <ski>   parsePerson = <| MkPerson {|parseName|} {|parseAge|} {|parseAddress|} |>
05:30:18 <ski> one could also allow the alternative form
05:30:27 <ski>   {|parsePerson|} = MkPerson {|parseName|} {|parseAge|} {|parseAddress|}
05:30:45 <ski> which might sometimes be preferable, in terms of readability, reasonability
05:31:32 <ski> cbaatz : `parseName' has type `Parser Name', but `{|parseName|}', a *side*-effecting expression, has type `Name' (with the added information that it may perform `Parser' side-effects)
05:31:34 <michaelt_> I see so its a bit like the !parseName in Idris except MkPerson is pure
05:32:03 <ski> cbaatz : therefore the types match when we apply `MkPerson' to `{|parseName|}', and similarly for the other arguments
05:33:06 <ski> cbaatz : finally, going from `MkPerson {|parseName|} {|parseAge|} {|parseAddress|}', of type `Person', with `Parser'-side-effects, we *reify*/quasi-quote/"freeze" the side-effects in it, getting back to `<| MkPerson {|parseName|} ... |>' of type `Parser Person'
05:33:16 <cbaatz> ski: Ah, OK, I think I see. You want a syntax for turning side-effect types into pure types for a while so you can combine them conveniently with other pure types, but then surfacing the side effect type at the "top level" expression?
05:35:36 <ski> michaelt_ : iiuc, in Idris, there's no explicit outer delimiter (my `<| ... |>' "quasi-quotation"/reification. cf "Representing Monads" in 1994-01,"Representing Layered Monads" in 1999-01, both by Andrzej Filinski at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>), which i consider essential for composability, reasonability
05:36:54 <michaelt_> yes, I think the !m thing is viewed as a limited convenience. 
05:37:03 <ski> cbaatz : exactly. but *importantly* with no way to sneak an effect / side-effect into the expression, without a clear syntactic marker that highlights the location. and also with a minimum of other distracting noise that could cause one to overlook such locations
05:37:43 <cbaatz> ski: Understood.
05:37:44 <ski> cbaatz : anyway, this goes a bit further, so far what i've described is just "iterating idiom brackets for all subexpressions"
05:37:46 <michaelt_> writeFile "a.txt" !getLine 
05:38:19 <dramforever> Umm, are you talking about just Applicatives or Monads in general?
05:38:57 <ski> cbaatz : i also want e.g. `<| if e then e0 else e1 |>' to mean the same as `<|e|> >>= \b -> if b then <|e0|> else <|e1|>', and similarly for `case'
05:39:36 <ski> cbaatz : also, i want `<| let x0 = e0 in e |>' to mean the same as `<|e0|> >>= \x0 -> <|e|>' 
05:39:57 <dramforever> I think there's a scala library that does this: https://github.com/ThoughtWorksInc/each
05:40:24 <dramforever> What you're talking about really resembles 'async/await', TBH
05:40:58 <ski> cbaatz : so, now you can write `do x <- m; y <- f x; g x y' as `<| let x = {|m|}; y = {|f x|} in {|g x y|} |>', so this is now more or less an alternative to `do'
05:41:28 <ski> dramforever : i'm talking about all of `Functor',`Applicative',`Monad'
05:41:49 <michaelt_> dramforever: dunno that isn't giving me the compact surveyable expressions I was hoping for from ski's higher idiom brackets ...
05:41:54 <dramforever> Ok
05:42:29 <dramforever> But you do agree that it's kinda like async/await right?
05:43:19 <ski> cbaatz : in cases which looks like `<| ab {| ia |} |>' or `<| {| iab |} a |>', where there's only one `{|...|}' subexpression (i think there need to be a slightly more complicated restriction), we'd prefer to only requiring a `Functor' constraint, so this would get translated into using `fmap'/`(<$>)' only
05:43:20 <michaelt_> I have to say McBrides idiom brackets got really hairy once you get past the first few beautiful sorts of examples.
05:44:13 <dramforever> michaelt_: It seems that the translation is comprehensive (pun intended)
05:44:30 <ski> cbaatz : so, for that reason, i'd really want the applicative laws to hold (specifically here the ones relating `(<*>)' and `pure' to `(<$>)'/`fmap'). and i think there are similar cases here for wanting `ap = (<*>)'
05:45:29 <ski> dramforever : ty for the link
05:45:45 <dramforever> Step 4: Use [ monadic[F] / <| |> ] to create a monadic expression
05:46:07 <ski> michaelt_ : well, i've tentatively called it "reflective syntax" (named after the terminology from the aforementioned Filinski paper)
05:46:12 <dramforever> Step 5: In the [ monadic / <| |> ] block, use [ .each postfix | {| |} ] to extract each element in a F
05:46:26 <dramforever> Sounds like exactly what you want
05:46:35 <dramforever> Now let's see what structure it supports...
05:46:54 <ski> dramforever : i haven't seen those `async'&`await' before, so i can't answer how similar it is, and what would possibly be the important differences, if any
05:47:28 <dramforever> Oh
05:48:01 <quchen> cbaatz: Re »other than people’s expectations«, I remember hearing that Applicative is mathematically not a »superclass« of Monad – they’re orthogonal concepts, and only in the special case of Hask(ell) they come together in a hierarchy.
05:48:02 <ski> i'll try to remember checking it out in more detail later
05:48:13 <ski> (adding more stuff to already long "to-read list" ;)
05:48:22 <dramforever> Basically you put 'async' around a function definition and sprinkle 'await' inside it
05:48:44 <dramforever> And the compiler or something transforms your function from direct style into callback style
05:48:48 <ski> dramforever : from the superficial description, it sounds similar
05:48:48 <quchen> cbaatz: So it’s only Haskell convention, and not math convention, that those have to be related. I think during the AMP someone brought this point up as well.
05:49:29 <ski> dramforever : i suppose i started thinking about my idea around 2006 .. haven't revisited it very much last years (other things have kept my attention)
05:49:52 <michaelt_> ski I missed the beginning but <| ... |> means the parser is looking for {| ... |} expressions inside. It then 'does' these and inserts the result in the larger expression which is thus effectful>
05:49:56 <michaelt_> ?
05:50:21 <dramforever> heck, maybe you can even implement this in template haskell
05:50:34 <ski> quchen : it'd be interesting to see how something like this could apply to, or compare to, an internal language in a cartesian closed category, or monoidal closed, or whatever (or some weaker variant, e.g. without closedness)
05:50:47 <dramforever> $(transform [| something expression whatever |])
05:51:38 <dramforever> get an identifier 'bind' somewhere so (bind expr) is treated differently
05:52:09 <x1n4u> does anyone have experience with chromes native client messageing system, and how to use it with haskell ?
05:52:38 <ski> michaelt_ : the idea is that these new syntactic constructs could be translated away, and preferably without having to know about types. also, imho, it's important that the rules for translation (or at least their observable effect) be simple and predictable enough so that one can internalize and *rely* on it (rather than "trying it out, possibly checking code generated/expanded by the compiler")
05:53:06 <quchen> ski: I know some of these words. ;-)
05:53:27 <mniip> internal language in a category?
05:53:51 <quchen> CCC is something I never understood. The definition is trivial (has sums and products and terminal and initial?), but the implications seem to be profound.
05:54:30 <ski> (similar to how the rules for what is a tail call in Scheme are clear and simple, and tail calls implemented properly is not an "optimization"(/improvement) *possibly* done in some cases, but a language guarantee, that you can predict and reason about ("reasonability" again), that you can rely on)
05:54:53 <michaelt_> x1n4u I saw someone ask about this just recently - or maybe it was you?
05:54:59 <ski> mniip : yep
05:55:14 <mniip> what kind of "language" are we talking about
05:55:28 <ski> quchen : monoidal closed, and friends, is sortof a more advanced generalization of cartesian closed
05:56:02 <dramforever> It's awfully similar to doing a CPS transform, just look at the types
05:56:07 <dramforever> :t (?f >>=)
05:56:09 <lambdabot> (?f::m a, Monad m) => (a -> m b) -> m b
05:56:10 <ski> quchen : cf. going from a classical or intuitionistic logic to a substructural one, like linear logic, relevant/relevance logic, affine logic, ordered logic (Lambek)
05:57:07 <dramforever> Please don't end up completely reinventing CPS
05:57:32 <ski> Philippa : ty for suggesting Frank may be related to this, i should investigate
05:57:48 <ski> Philippa : elaborate on "but it's a trade-off vs \"escape-back-to-pure\" brackets that aren't ordinary parens"
05:58:47 <ski> .. anyway, there are some conceptual things (extensions, rather than the basic stuff, of which i haven't mentioned all) in this "reflective syntax" which i'm not sure how to handle best
05:59:26 <ski> (which i assume is one thing that has dissuaded me from attempting to code up a simple TH translator yet)
05:59:40 <ski> dramforever : reinventing CPS how ?
06:00:06 <quchen> ski: … subcategorical category theory?
06:00:34 <Philippa> ski: at some point you're going to want to write "just plain old haskell syntax" somewhere in the middle. That's what I mean by "escape-back-to-pure" brackets. Inside idiom brackets, parens are /just/ parens (though you'll probably need to apply pure somewhere)
06:00:40 <dramforever> :t (?f >>=)
06:00:43 <lambdabot> (?f::m a, Monad m) => (a -> m b) -> m b
06:01:10 <Philippa> quchen: subcategories are a thing, otherwise 0-categories are sets :-)
06:01:28 <dramforever> For {| |} brackets, They *should have been* of type 'a', they are *actually* of type 'm a'
06:01:28 <Philippa> and yeah, extensible syntax is a PITA
06:02:03 <dramforever> We bind them, and an (f >>=) is of type '(a -> m b) -> m b'
06:02:06 <quchen> I don’t know what a set is it seems. Or 0-categories. I don’t think I know anything. :-( But I do know that there’s another way I don’t understand sets, thanks HoTT.
06:02:18 <ski> quchen : i haven't heard that term, before :)
06:02:54 <quchen> 0-categories are categories where functors are umm not in?
06:03:11 <Philippa> where you've only got identity arrows
06:03:17 <ski> Philippa : well, one one hand "just plain old haskell syntax" is what `{| |}' is for, you can always escape back to ordinary Haskell (possibly using `(<*>)', &c. if you want to)
06:03:23 <Philippa> (and that only because they're kinda hard to remove)
06:03:26 <dramforever> Philippa: from where to where?
06:04:06 <Philippa> dramforever: you've still got a bunch of distinct objects, that's why they're [equivalent to] sets
06:04:34 <ski> Philippa : otoh, the point is that the "side-effectful Haskell" (new syntactic category) should look like ordinary Haskell as much as possible, so that if there's no `{| |}' in a subexpression, it can be translated to a call to `pure'/`return', applied to that exact same expression, but now seen as an ordinary (side-effect-free) Haskell expression
06:05:11 <ski> Philippa : .. or perhaps you meant something else by "just plain old haskell syntax" than these two things ?
06:05:16 <Philippa> nope
06:05:30 <Philippa> was just pointing at a design trade-off you've taken your pick on
06:05:38 <dramforever> phileas: oh perhaps
06:05:59 <Philippa> quchen: functors aren't "in" most categories
06:06:49 <Philippa> (Cat, the category of small categories, is your most obvious exception. But when you're working in n-categorical terms it's more useful to see that as a 2-category where functors are the 2-arrows)
06:07:36 <Philippa> (hop up one more level to see natural transformations and you've finally hit the level of abstraction category theory existed to discuss in the first place)
06:07:45 <ski> dramforever : *nod*, this is also related to the "Reflecting Monads" paper, which detail how to implement ("refect") an *arbitrary* side-effect in a language (such as parsing side-effects, possibly with backtracking, or exploring multiple alternatives in the grammar at the same time, &c.), ..
06:07:50 <ski> dramforever : .. given only (a) a (computable) implementation of the corresponding monad; and (b) the presence of delimited continuations (alternatively ordinary continuations, plus state) in the language
06:08:09 <dramforever> Yeah
06:09:07 <Philippa> which is cute, but arguably an effect too many still if you're into total programming
06:09:22 <dramforever> Atry, the author of 'each', must know a great deal about this
06:09:35 <ski> quchen : have you seen the comments about "material" vs. "structural" sets, at <http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html> )
06:09:36 <Philippa> tl;dr: navigating lots of mutually-embedding languages is a complicated and messy task
06:09:38 <ski> ?
06:11:29 <ski> Philippa : i'm sorry for being dense, but what "poles" are the trade-off you were mentioning interpolating between ?
06:12:26 <ski> (s/refect/reflect/)
06:13:00 <ski> dramforever : `each' ?
06:13:24 * ski catches up with discussion
06:13:35 <ski> Philippa : ok, ty
06:13:40 <dramforever> https://github.com/ThoughtWorksInc/each
06:14:02 <dramforever> 'I think there's a scala library that does this: https://github.com/ThoughtWorksInc/each '
06:14:49 <ski> (if the "extensible syntax" was for me, then i wasn't really considering a general framework for that, as opposed to this particular application/use, namely adding this particular new syntax)
06:16:08 <ski> dramforever : ok, ty
06:16:24 <dramforever> The General Framework (tm) could be just 'Template Haskell' /s
06:17:23 <ski> michaelt_ : btw, do you happen to know what this `!' thing in Idris is called ?
06:18:23 * ski supposes they should look into <http://www.idris-lang.org/documentation/effects/>
06:18:54 <dramforever> Perhaps not, that's builtin syntax
06:20:56 <quchen> ski: Idris bang notation.
06:21:23 <quchen> I think it’s pretty cool and would like to see it land in GHC.
06:26:28 <roxxik> I like bang notation way more than applicativeDo
06:27:08 <roxxik> and if i understand correctly you can write applicative code quite easily using bangs
06:29:32 <Squarism> Naive prophecy - Elm makes FP mainstream
06:29:47 <merijn> Squarism: I'd bet on Swift over Elm any day
06:29:54 <maerwald> merijn: xD
06:30:19 <merijn> Squarism: Swift is being pushed by a major corporation that has repeatedly shown it's perfectly happy to force devs to conform to it's ecosystem
06:30:20 <roxxik> Squarism: isn't React already a step in the right direction?
06:30:21 <Squarism> im totally cut of from apple-world
06:30:48 <maerwald> Swift interaction with C is soooo pleasent
06:31:53 <Squarism> roxxik, i dont know, ive never tried it. I thought React was more of an architectural thing. Elm feels like a subset of haskell
06:32:24 <merijn> Squarism: Apple is known for ruthlessly dropping backwards compat if they wanna get rid of a technology, so saying "Swift is the new language" means anyone wanting to do iOS/watchOS/etc. has to learn Swift and unless those markets crumble plenty of the devs will
06:32:46 <merijn> Squarism: Elm competes with JavaScript and there's no external force that is requiring JS devs to change
06:33:05 <roxxik> Squarism: i had to look into it for a project in Purescript using it. And React already embraces Immutability and central handling of State
06:35:44 <Squarism> merijn, My thought was: I cant imagine a language with more day-to-day users than javascript. If Elm breaks through, which i hear evidence of daily, it would win alot of programmers.
06:36:20 <Squarism> ...well never mind. Just a thought
06:37:36 <Squarism> merijn, i didnt know that. Sounds good for evolution though. Hopes for Java 9 and VB 21 cant be high
06:37:42 <mettekou> Is there a way to handle variables with keyword prefixes (for example "letx" or "casex") with parser combinators without resorting to banning them outright?
06:42:58 <merijn> Squarism: It is, imo. Swift is a mostly sane language (it has lots of tools for dealing with legacy Objective C for obvious reasons) developed by competent people. I'm not really excited by it, but it's a language based on PL research from like the 80s/90s
06:43:18 <merijn> Squarism: Which sounds bad, until you realise the other recent languages like Go are basically ignoring everything since the 60s...
06:43:31 <merijn> Rust is also rather modern, but clearly aimed at a different use case
06:43:59 <merijn> mettekou: What do you mean by that?
06:45:09 <merijn> mettekou: Usually you define a set of "reserved" identifiers like the keywords of your language and basically compare all variables against that set and ban matches
06:45:23 <mettekou> merijn: Well, allowing variable names with a prefix equal to a keyword (as Haskell does) without too much backtracking in the parser, if at all possible.
06:45:49 <lpaste> TPC pasted “syntax error” at http://lpaste.net/351597
06:45:51 <merijn> mettekou: Which parser library are you using?
06:46:01 <mettekou> merijn: Megaparsec.
06:46:25 <TPC> it's probably something stupid, but I can't spot the problem, can someone tell me what the syntax error is in the above paste?
06:46:31 <TPC> the error message is error: parse error on input ‘Left’
06:46:52 <merijn> mettekou: Basically, I would define a list of reserved words somewhere in your code and then have a variable parser basically parse any string and then fail if it's an element of that list/set
06:47:19 <thatguy> how does ghc know what parts to apply functions to, e.g. map (\x -> 7*x + 2) . filter (>3) how does it know here that the function on the left of . is "map (\x -> 7*x + 2) " and not just "(\x -> 7*x + 2) "
06:47:27 <mettekou> merijn: That is what I currently have set up, but it doesn't work for variables with names of which a keyword is a prefix.
06:47:31 <merijn> TPC: Left is not indented more than rawList
06:47:49 <ski> thatguy : application binds tighter than any (normal) binary operator
06:47:51 <merijn> mettekou: Why does it not work? Or are you saying you want to ban variables starting with keywords?
06:48:01 <TPC> merijn, okay, thanks :)
06:48:12 <ski> thatguy : so `map (\x -> 7*x + 2) . filter (>3)' parses as `(map (\x -> 7*x + 2)) . (filter (>3))'
06:48:26 <thatguy> ski, is binary operator == infix operator?
06:48:30 <merijn> TPC: I recommend reading this wikibook chapter on how indentation works https://en.wikibooks.org/wiki/Haskell/Indentation
06:48:43 <ski> thatguy : yes, sorry, binary infix operator
06:48:58 <thatguy> ski, ah ok that explains it, thanks :)
06:49:13 <ski> thatguy : one can think of application as an "invisible" operator ("juxtaposition"), having precedence level `10', which is higher than the precedences allowed for any defined operators
06:49:29 <TPC> merijn, okay, I'll check it out
06:49:50 <ski> thatguy : however, you should note that the record construction&update syntax binds even tighter, and so does the `~',`@',`!' constructions in patterns
06:50:26 <thatguy> ski, is there some good link giving an overview of what binds how tight? I have the feeling my tutorial doesn't cover it
06:50:28 <ski> thatguy : so `foo Node {rootLabel = x,subForest = f}' parses as `foo (Node {rootLabel = x,subForest = f})', not as `(foo Node) {rootLabel = x,subForest = f}'
06:50:30 <mettekou> merijn: No, banning them would be easier, but I'd like to allow them. The problem seems to be that I parse terms starting with keywords (let x : T := t in t', fun x : T => t...) before variables, but parsing variables first makes  parsing any such term fail.
06:52:17 <mettekou> merijn: Backtracking with try ('choice [try variable, function, let, ...]' instead of 'choice [variable, function, let...]') doesn't resolve the issue either.
06:52:19 <ski> thatguy : and `f x@(C y) !z ~(D w)' (to the left of `=' in a defining equation), parses as `(((f (x@(C y))) (!z)) (~(D w)))', not as `(f x)@((C y) (!z ~(D w)))' or whatever
06:52:44 <merijn> mettekou: Looks like your try is in the wrong spot
06:53:13 <thatguy> ski, haha thanks for the effort, I think you are going a bit to far for me, I haven't even covered ! and ~ operators yet
06:53:19 <merijn> mettekou: Have you read this? http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
06:53:37 <ski> thatguy : you should also note that the `->' in a lambda expression `\<pat> ... -> <expr>' binds very loosely, and so does `::' in `<expr> :: <type>' (type ascription/annotation, not type signature)
06:53:45 <mettekou> merijn: Yeah, a long time ago.
06:54:21 <merijn> mettekou: Also, maybe you wanna look at how the parser for my minimal functional language is structured: https://github.com/merijn/lambda-except/blob/master/Parser.hs
06:54:33 <merijn> mettekou: It's using trifecta, but most of it should be obvious
06:55:04 <merijn> mettekou: The parser is perfectly fine, but the rest of that implementation (i.e. typechecker) is...suspect at best :p
06:55:34 <mettekou> merijn: Uhu, I had a look at it when you last recommended it to me and that helped me sort out function application and independent function types (variable not free in codomain).
06:56:12 <merijn> mettekou: The thing is that "choice [variable, function]" looks like it's wrong :)
06:57:07 <merijn> mettekou: Note how variables are primExpr which do not occur in "expr"
06:57:24 <mettekou> merijn: I already had a 'try' in the definition of 'variable', but I think I need to bring it further down.
06:57:29 <merijn> mettekou: primExpr are only ever parsed by appExpr (which is part of expr)
06:57:55 <mettekou> merijn: Uhu, I have a similar set-up for both application and function types.
06:58:08 <merijn> mettekou: Can you put your current code online somewhere?
06:58:47 <ski> mettekou : hmm .. i wonder whether your problem could perhaps be due to failure of right-distribution law to hold, for `Megaparsec'
07:01:02 <merijn> hmmm
07:01:45 <merijn> So if I have, say, 10 functions that use 'foo' and I want to to provide alternate versions that use a slightly modified 'foo' can I somehow avoid duplicating all 10?
07:04:27 <ski> i suppose `TypeOfFoo -> (TypeOfFun0,TypeOfFun1,...)'
07:04:47 <ski> (an ML module functor could be nice here, perhaps)
07:05:20 <merijn> ski: Yes, but this is haskell, so I need a different solution than that :)
07:06:43 <seequ_> Can I somehow enable pattern-exhaustiveness checking?
07:07:18 <ski> merijn : returning a record of functions is too cumbersome ?
07:07:27 <kadoban> seequ_: -Wall includes it, I'm sure there's a flag just for it as well, but I don't know it. You can always use -Werror as well if you really want
07:07:34 <ski> merijn : could you use implicit parameters ?
07:08:46 <ski> seequ_ : see `-fwarn-incomplete-patterns',`-fwarn-overlapping-pattern'
07:09:20 <merijn> ski: Could I, probably, but I don't see an implicit parameter solution getting merged upstream :p
07:09:52 <ski> heh
07:10:15 <merijn> ski: The problem is that I currently have this API: https://hackage.haskell.org/package/xml-conduit-1.4.0.2/docs/Text-XML-Stream-Parse.html
07:10:34 <seequ_> kadoban, ski: Thanks!
07:11:18 <merijn> ski: But the 'tag' function which everything is based on treats a failing attribute parser as parse error, rather than moving on to the next parse. For backwards compat reasons changing 'tag' was not acceptable, so now I need to duplicate all functions that use 'tag' to use the new behaviour I need
07:11:32 <merijn> ski: But I'd rather not duplicate more code than strictly necessary...
07:12:16 <merijn> ski: I guess I can rename the existing versions and generalise them and then provide both as specialisations of those
07:12:47 <merijn> ski: But then I end up essentially writing 20 lines of "fooX = genericFoo X; fooY = genericFoo Y;"
07:13:32 <merijn> Which is better than duplicating the code, but not ideal
07:13:41 <Eduard_Munteanu> merijn, there's CPP, but :/
07:15:14 <ski>   MkFooRec {fX = fooX,fy = fooY,...} = genericFoo tag  -- ?
07:15:38 <ski> (where `genericFoo' (not exported) returns a record of functions (record type also not exported))
07:18:26 <merijn> ski: I'm not sure how introducing the record would reduce the duplication?
07:19:42 <ski> merijn : only having to call `genericFoo' once, per variant of `tag' ?
07:20:20 <ski> so, calling it twice, instead of twenty times, if it works out
07:45:00 <jstolarek> how do I write a function with following signature:
07:45:20 <jstolarek> foo :: ExceptT () Identity a -> ExceptT () IO a
07:45:43 <jstolarek> in other words, I have a monad transformer built on top of Identity and I want to replace Identity with IO
07:47:44 <merijn> jstolarek: You want mmorph
07:47:47 <merijn> @hackage mmorph
07:47:48 <lambdabot> http://hackage.haskell.org/package/mmorph
07:48:38 <merijn> jstolarek: Specifically "hoist generalize"
07:51:20 <jstolarek> merijn: thanks
07:51:26 <jstolarek> no simpler solution?
07:51:38 <jstolarek> simpler = not requiring me to add a dependency to the project
07:52:43 <merijn> You could probably duplicate the code from mmorph, I suppose
07:52:53 <jstolarek> yes, I'm looking into that
07:53:07 <merijn> but mmorph itself has basicallly 0 dependencies (only mtl and transformers), so it's not such a big dependency
07:53:52 <ski> jstolarek : you could build it with `runExceptT',`runIdentity',`return :: forall a. a -> IO a',`ExceptT' manually ..
07:54:05 <reactormonk> Is `trace` a reasonable way to implement application logging, so I have at least some idea what happened in case I get a 500 back?
07:54:18 <jstolarek> ski: tried but failed :-/
07:55:04 <ski> @type ExceptT . return . runIdentity . runExceptT
07:55:06 <lambdabot> Monad m => ExceptT e Identity a -> ExceptT e m a
07:55:15 <jstolarek> ski: ah
07:55:22 <merijn> reactormonk: Define "logging"
07:55:23 <ski> pick `m' as `IO'
07:55:34 <jstolarek> I didn't figure out I can use ExceptT
07:55:34 <merijn> reactormonk: If it's for debugging, sure. For long term logging, no
07:55:38 * ski leaves for the while
07:55:45 <reactormonk> merijn, long term logging?
07:55:45 <jstolarek> that's the bit I was missing
07:55:46 <jstolarek> thanks
07:55:54 <reactormonk> merijn, ... as in, what would you recommend for it.
07:56:11 <merijn> reactormonk: No clue, I don't do logging, because YOLO :p
08:00:43 <dmwit> jstolarek: I would like to suggest an alternate solution.
08:01:25 <dmwit> jstolarek: Instead of trying to turn an `ExceptT () Identity a` into something, why not rewrite your term of that type so that it can work in any monad that can throw `()`, as in give it type `MonadError () m => m a`?
08:01:48 <dmwit> jstolarek: Then `ExceptT () Identity a` and `ExceptT () IO a` are just two specializations of that type.
08:02:31 <laz> reactormonk: there is monad-logger
08:05:13 <ertes> maerwald: i have barely touched memory safety with haskell…  all i can say right now is that it's difficult, even if limit yourself to Storable operations…  i believe that GHC-side support is necessary to fix this
08:05:30 <ertes> maerwald: alternatively make sure that GHC never gets to see the data by FFIing into C
08:07:42 <ertes> but even then, say in a crypto setting, GHC gets a hold of plaintext first, before it passes it on to C, so there is potential for data leakage, too
08:32:49 <ongy> afaik even using bytestring would be hard, since every edit will make copies
08:33:28 <ongy> does the GC copy-collect the bytestring, or just the pointer to the bytestring? (The actual haskell-level value is pointer/size/offset iirc)
08:40:45 <houli> getting a bit fuzzled about some MTL typeclass stuff if someone is willing to take a look http://lpaste.net/4409795664725147648
08:41:33 <houli> basically trying to generalise functions to work for Readers that have the data but also Readers that have the data but within some other structure
08:42:24 <glguy> houli: No, you can't write that instance
08:42:27 <merijn> houli: Not really, I think you want something like "zoom" from lens
08:42:51 <glguy> Yeah, lens has "magnify" for readers
08:43:29 <houli> ok i'll take a look, lens has always scared me whenever I went looking though, is there examples of similar code somewhere?
08:43:30 <glguy> houli: You can't write that instance because it violates the functional dependency that MonadReader has
08:43:43 <houli> glguy: yeah that was the error i was getting
08:43:59 <glguy> houli: even better is you can just name the value: asks configToConnectionPool
08:44:25 <houli> name which value?
08:44:44 <ertes> ongy: you would use ForeignPtr, so far so good, but as soon as you use Storable you get values from the memory into GHC-land, at which point it's hard to predict where they will end up
08:44:46 <glguy> better than that is to not expose the mtl typeclasses at all and just name the operations and types you need while possibly using ReaderT internally to implement that
08:45:01 <glguy> houli: this one 'asks configToConnectionPool'
08:45:54 <houli> right, but then i couldn't use it with a  ReaderT ConnectionPool Handler then?
08:46:03 <houli> because i've specialised it to work for Config
08:46:50 <glguy> Sure, you'd just use the right one for the context
08:46:54 <houli> maybe i'm trying too hard to use this function over multiple different types, i could just rewrite it every time i'm using a different structure in the reader
08:47:07 <ongy> ertes: sure. How are the guarantees on foreign pointers beeing cleaned up? Can we use the destructor of those to clean memory?
08:47:27 <glguy> If you're really set on finding a way to use the same name to mean a bunch of different things, you can have a typeclass that extracts the connection pool from a value
08:47:34 <ertes> ongy: you can invoke finalisers early and have them wipe the memory
08:47:41 <glguy> class HasConnectionPool a where connectionPool :: a -> ConnectionPool
08:48:05 <glguy> then you can name 'asks connectionPool :: ConnectionPool a => ReaderT a m ConnectionPool'
08:48:16 <glguy> err, :: HasConnectionPool...
08:48:19 <houli> yeah
08:48:27 <ongy> ertes: so probably a lot of bracket and Rank2 functions to make things sane
08:50:52 <houli> glguy: thanks for the help, think i'll go with the typeclass method right now seeing as i'm most comfortable with that
08:50:53 <houli> thanks
08:51:02 <glguy> houli: In general it's better to define your own classes like: class MonadConnectionPool m where askConnectionPool :: m ConnectionPool, than to expose mtl classes
08:51:28 <houli> sure
08:51:44 <houli> off the ground now so can look into nicer ways eventually
09:31:44 <janosp_> Hi guys, I am still struggling to build a executable with Stack and deploy it in a small docker container. Has anybody experience with that and can help me?
09:31:57 <janosp_> btw I am running Stack on OS X
09:32:06 <janosp_> but want to deploy obviously on linux
09:36:05 <glguy> I hadn't thought about it, but ?pl doesn't find the smallest obfuscation
09:36:24 <glguy> :t \x y z w -> x (y (z w))
09:36:26 <lambdabot> (t -> t1) -> (t2 -> t) -> (t3 -> t2) -> t3 -> t1
09:36:30 <glguy> ?pl  \x y z w -> x (y (z w))
09:36:30 <lambdabot> (. (.)) . (.) . (.)
09:36:34 <glguy> :t ((.).).(.)
09:36:36 <lambdabot> (b -> c) -> (a1 -> b) -> (a -> a1) -> a -> c
09:38:20 <cbaatz> quchen: Ah, interesting that Applicative isn't a superclass of Monad in maths -- another good reason for me to read up on the maths.
09:44:03 <sflux> @help
09:44:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:44:16 <sflux> help list
09:44:37 <sflux> list
09:44:48 <glguy> sflux: you can explore the help system in private messages
10:02:26 <janosp> .
10:12:44 <roxxik> @list
10:12:44 <lambdabot> What module?  Try @listmodules for some ideas.
10:12:56 <roxxik> @help list
10:12:56 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:22:45 <gwern> hi everyone. I'm trying to use array-memoize to do fast memoization of a 3-argument (Double -> Double -> Int) function representing a decision tree: http://pastebin.com/whrEAdCH I tried using 'memoize' first but it doesn't support Doubles or Floats (which I need to represent wealth and probabilities) and when I tried hacking in an instance, it just caused the memoized answers to be wrong....
10:22:51 <gwern> ...'Data.Function.ArrayMemoize' does support doubles via discretizing, but I'm unable to figure out how to make it work for my case. I can memoize *single* arguments like 'let x = discreteMemo (0, 1) 0.00001 (\p -> value 1 p 10)' and then 'x 5000' gives me what looks right for 'value 1 0.50 10' so I've memoized different probabilities there, but when I try to nest memoization it fails. for...
10:22:57 <gwern> ...example, memoizing wealth as well: 'let x = discreteMemo (0, 1) 0.00001 (\p -> discreteMemo (0, 1000) 0.01 $ (\w -> value w p 10))' gives 'No instance for (ArrayMemoizable (Int -> EV)) (maybe you haven't applied enough arguments to a function?) arising from a use of ‘discreteMemo’'. I've been out of haskell long enough that these errors no longer really make sense to me...
10:23:45 <gwern> (I've also considered just trying to switch to a hashmap since doubles/ints should be easily hashable)
10:24:20 <geekosaur> doubles are actually a pain point for hashable, because NaN
10:24:35 <geekosaur> (well, they're just a pain point period because of NaN)
10:25:00 <gwern> oh. what about float then? that should work about as well since I don't expect the numbers to get extremely large or small
10:25:30 <monochrom> Float has NaN too. But I don't think you should worry about NaN.
10:25:45 <gwern> anyway, my intuition is that there should be some wya to make 'quantizedMemoFixMutual' memoize 'value' and 'f', but the types have gotten over my head
10:42:22 <gwern> I wish array-memoize had some more documentation about how you're supposed to use it. reading it over and the source, I can't find any hints about how you're supposed to memoize multiple-argument functions. it's always stuff of the form f::a -> b... is the idea that you're packing everything into a constructor or a tuple to define 'a' and inferring instances?
10:45:53 <byorgey> gwern: I was just wondering the same thing myself.  I agree with your assesment.  I don't understand what the ArrayMemoizable class is for at all, because the implementations are all identical, and arrays are completely polymorphic in the element type
10:46:29 <gwern> byorgey: I also didn't see anyone actually using it when I looked in google, which is odd since this doesn't look like a 5-minute doodle of a library
10:46:31 <byorgey> so you could make an instance of ArrayMemoizable for any type at all just by defining  newArray_ = MArray.newArray_ , writeArray = MArray.writeArray
10:47:09 <byorgey> I do note it hasn't been updated since April 2014, though its dependencies are simple enough that perhaps it genuinely hasn't needed any
10:47:49 <ertes> gwern: why don't you memoise explicitly?  let f = \x y -> … where table = …
10:48:23 <gwern> ertes: I was hoping to have a library abstract that away
10:48:33 <gwern> I also don't really get that kind of memoization
10:48:46 <ertes> gwern: it's hardly even "memoisation"…  it's simply sharing
10:49:23 <ertes> > let f = (* x) where x = 3^1000 :: Word in map f [1,3..9]
10:49:24 <byorgey> gwern: I do think it should work to uncurry your multi-argument function and use array-memoize with a new instance of ArrayMemoizable for your tuple argument type
10:49:26 <lambdabot>  [6203307696791771937,163179016665764195,12569794410249308069,652966573012330...
10:49:39 <ertes> gwern: the value 'x' will be shared, because 'f' is shared
10:50:17 <ertes> gwern: it's important not to write it this way:  f y = y*x where x = 3^1000  -- because now the 'where' is attached to the *result*, not the *function*
10:50:31 <byorgey> ertes: personally I think you are making it sound a lot simpler than it is.  Getting sharing/memoization stuff right is genuinely tricky.
10:50:41 <ertes> > let f y = y * x where x = 3^1000 :: Word in map f [1,3..9]  -- not shared
10:50:43 <lambdabot>  [6203307696791771937,163179016665764195,12569794410249308069,652966573012330...
10:50:48 <byorgey> you are relying on operational aspects of GHC's Haskell implementation.
10:51:16 <ertes> byorgey: yeah, i'm relying on sharing, but memoisation like in MemoTrie does that as well, for the most part
10:51:32 <byorgey> of course it does, but the point is some library writer has gotten it right for you.
10:53:05 <ertes> byorgey: well, consider this:  you still need to understand the difference between (map (\x -> memo f x)) and (map (memo f)), so i think you need to understand this anyway, library or not
10:53:17 <kadoban> Even if you get that stuff right, how you memoize something as "simple" as a Char or Int or whatever is ... nontrivial.
10:57:13 <kadoban> (though is easier when something like array-memoize applies sanely)
11:03:32 <gwern> (memo-trie doesn't support float or double, incidentally)
11:15:03 <gwern> byorgey: looks like it's not as simple as defining ArrayMemoizable because then you run into MArray needing Ix instances for Double
11:28:31 <jophish> What's the most compelling case for backpack aside from strings?
11:29:17 <johnw> jophish: filepaths
11:32:47 <jophish> johnw: that's a pretty good one. Hopefully it'll give is a path away from FilePath = String
11:33:17 <johnw> I end up using RawFilePath = ByteString everywhere, because it's the most honest thing, but I'd prefer to work with "platform appropriate" paths
11:36:06 <ysangkok> if a module does not export the field accessors of a record, is it impossible to access the fields of an instance from another module?
11:36:44 <crobbins> ysangkok: correct, except i think you might be able to get around it with TemplateHaskell
11:38:50 <geekosaur> infamously http://hackage.haskell.org/package/true-name
11:39:45 <crobbins> ha wow, nice geekosaur 
11:40:35 <jophish> geekosaur: I'd not seen that before, it looks (regrettably) useful
11:53:57 <gwern> https://hackage.haskell.org/package/uglymemo-0.1.0.1/docs/src/Data-MemoUgly.html#memoIO huh. this actually seems to work reasonably well with the tuplized version of my code?
11:57:13 <gwern> hm. this uses concurrent.mvars. I wonder if this means you can do something like 'mapM [1..n] (forkIO . f)' 
11:58:04 <gwern> (now there's a haskell idiom I haven't written in a long time...)
12:03:29 <knupfer> Has anyone already tried dhall to make nix a bit more sane?
12:04:12 <jophish> knupfer: I was thinking about this just earlier
12:04:28 <athan> knupfer: like the dhall grider? :v
12:04:29 <jophish> knupfer: you may be interested in this : https://github.com/Gabriel439/Haskell-Dhall-Library/issues/4
12:04:53 <jophish> https://hackage.haskell.org/package/dhall-nix
12:05:10 <athan> ! What is dhall exactly? I've heard it mentioned here a few times
12:05:20 <athan> (I don't have access to high speed internet right now sorry :x)
12:05:35 <dmj`> gwern: I’d checkout replicateM_ from async or lifted-async
12:06:39 <gwern> dmj`: hm. 'replicateM :: Monad m => Int -> m a -> m [a]'. that doesn't work here, I'm calling it for its side-effects to evaluate different parts of the decision tree in parallel
12:06:52 <knupfer> athan: it's a configuration language
12:07:12 <athan> knupfer: oh that's all? Like yaml or something?
12:07:16 <knupfer> from gabriel, so it has got a solid theoretical background
12:07:26 <athan> i swear I heard it mentioned regarding system F
12:07:27 <athan> oh!
12:07:43 <dmj`> gwern: ah, my fault. I got the name wrong. It’s replicateConcurrently, and it’s in the async package
12:07:48 <dmj`> gwern: http://hackage.haskell.org/package/async-2.1.1/docs/src/Control.Concurrent.Async.html#replicateConcurrently
12:08:08 <ertes> knupfer: hmm?  i don't really see an overlap between dhall and nix…  how does dhall help to make nix saner?
12:08:19 <knupfer> that would be so much better than nix, where you can lump nearly any thing together with the most useless errormessages
12:08:45 <knupfer> ertes: one of the goles of dhall is to be a typed nix
12:08:54 <gwern> dmj`: still looks wrong. 'replicate cnt'. what I want is to say evaluate the decision tree for all possible values of t, which will make various threads evaluate/explore different parts of the tree
12:09:04 <ertes> knupfer: that's quite a goal =)
12:09:21 <gwern> dmj`: so one thread is exploring descendents of (99.5,0.3,3) and o
12:09:28 <gwern> thers are xploring different possible settings
12:09:53 <knupfer> some variables in nix can be filled with: a number, null, or any string ( *scream* )
12:09:54 <ertes> i've seen a fund-raising campaign on nix-dev to add a type system to nix…  now that would be really amazing
12:10:07 <jophish> regnat in #nixos is behind that
12:10:10 <athan> gwern: if you can't enumerate the decisions of t, then you can hand-enum them with `async` can't you?
12:10:31 <gwern> athan: I certainly can hand-enum them. that's what my little forkIO suggestion does
12:10:41 <knupfer> ertes: I'm trying the other way round, write a nix clone in haskell...
12:10:59 <ertes> knupfer: i do agree that nix really needs a type system, and eelco agrees as well (there is a long-standing issue)…  not sure if reinventing nix in haskell is really the way to go though
12:11:04 <ertes> remember that nix is much more than just a language
12:11:53 <knupfer> yeah, the ecosystem with all the packages is quite attractive
12:12:10 <ertes> it's not just attractive…  it's practically required
12:12:16 <jophish> guix has a certain following, which is an alternate frontend to nix
12:12:26 <ertes> jophish: and also untyped (scheme)
12:12:32 <knupfer> yeah, but guile isn't really typed
12:12:36 <athan> gwern: fastestDecision <- raceAll $ mapM async [t1..tn]
12:13:16 <jophish> sorry, I meant that an alternate frontend to the nix ecosystem is possible
12:13:34 <athan> I think nix would be better as strictly typed for the same reason why haskell / purescript are
12:13:51 <knupfer> yeah
12:14:06 <athan> it would just take a lot more work, but might be worth it :x I've been wishing for it for years lol
12:14:32 <jophish> I think there was an effort to type it a few years ago
12:14:32 <knupfer> I'd wish as well that I could compile nix expressions, some of my nix-shells take 5s to enter, albeit nothing has to be done
12:14:40 <jophish> I don't remember it ever getting off the ground though
12:14:41 <ertes> me, too…  i've tried to do some serious engineering with nix, but it's impossible without a type system…  lazy FP really needs types
12:14:55 <athan> ahh that's a good idea knupfer
12:14:59 <ertes> and annotations in comments don't help either
12:15:04 <jophish> knupfer: you can nix-instantiate them
12:15:15 <jophish> not always the same though
12:15:39 <ertes> nix-instantiate works for haskell, as long as you're using Setup…  it doesn't work with cabal, because PATH is lost
12:16:05 <ertes> s/cabal/cabal-install/
12:16:58 <ertes> knupfer: compiling wouldn't help too much, i think, because you still have to traverse nixpkgs and build the dependency tree…  the only real solution to that is instantiation
12:17:11 <jophish> hmm, I've never had a problem using cabal with nix
12:17:49 <ertes> jophish: i suppose you could omit --pure
12:18:14 <knupfer> ertes: 5s for finding stuff in a hashmap?
12:18:43 <jophish> ertes: what I do is edit the .env attribute to insert packages such as cabal-install and hdevtools
12:18:48 <ertes> knupfer: dependency resolution is more than "finding stuff in a HashMap" =)
12:19:22 <jophish> I'm not sure we'll get compiled nix for some time. IFD really complicates that
12:19:47 <ertes> yeah, nix has some weird language features, which make stuff like callPackage work…  i find them really unfortunate
12:20:03 <knupfer> ertes: is it? all packages are hashes
12:20:26 <knupfer> even this one takes 0.2s:   nix-shell --pure -p --command 'echo a'
12:21:00 <ertes> knupfer: you need to evaluate nixpkgs regardless…  what you *can* save is disk I/O by compiling all of it into code
12:24:36 <ph88^> i added foundation package to my build-depends but when i try to import Foundation.IO.File i still get a ghci error that the interface is part of a hidden module in the package .. anyone know what i can do about that ?
12:25:17 <ertes> ph88^: yes: read the error message
12:25:53 <ph88^> ertes, i've read it .. normally i put it in my cabal file build-depends and the error goes away i don't know what to do now
12:26:01 <ertes> ph88^: no, you didn't
12:26:05 <ertes> not *all* of it
12:26:50 <ph88^> are you talking about the -v flag ?
12:27:05 <ertes> ph88^: "… hidden module in …" – keep reading
12:27:45 <ph88^> foundation-0.0.3
12:28:06 <ertes> that package does not have a Foundation.IO.File module
12:28:48 <ph88^> ghci says it's a hidden module in the package foundation-0.0.3 and you say it doesn't have that module
12:29:02 <ertes> hackage agrees with me: https://hackage.haskell.org/package/foundation
12:29:14 <ertes> maybe it's a bug?
12:29:33 <ph88^> i use stack nightly-2017-01-17
12:30:44 <ph88^> https://www.stackage.org/haddock/nightly-2017-01-17/foundation-0.0.3/Foundation-IO.html
12:30:57 <ertes> ph88^: ah, there we go:  the module is internal
12:31:00 <ertes> you can't access it
12:31:03 <ph88^> ah ok
12:31:10 <ertes> you can only access exposed modules
12:31:59 <ph88^> ertes, how did you figure that out ?
12:32:20 <ertes> ph88^: it's "hidden module" vs. "hidden package"…  i figured it out by looking at the cabal file of foundation
12:32:32 <ph88^> aaaaaahhhh
12:32:41 <ph88^> i was just triggered on "hidden"
12:32:51 <ertes> ph88^: see the "package description" link at: https://hackage.haskell.org/package/foundation
12:33:16 <ph88^> ok so normally with a hidden package i can add it to the cabal file .. but a hidden module i can't fix it myself  right ?
12:33:24 <ertes> correct
12:33:31 <ph88^> ok thank you ertes 
12:34:08 <ertes> GHC could make the error message less confusing by calling other-modules "unexposed" rather than "hidden"
12:34:18 <ph88^> yeah
12:48:14 <mckeankylej> I think I found a bug with type in type. http://lpaste.net/351604 am I doing something wrong or should I report this bug? I feel like r ~ b => r should be obivous to deduce.
12:58:26 <gwern> just benchmarked two versions, one with forkio and the other not... near identical wallclock times despite way higher CPU use with the parallel one :(
13:01:07 <ph88> does anyone have an idea how i can abstract away the class instance for  Arbitrary a  in these cases? https://paste.fedoraproject.org/535850/14852915/  the implementation of arbitrary is always the same  get  this is is already handled by another typeclass. The only information that is non-boilerplate is the addition of [Version1]
13:10:44 <sssilver> hey guys, anyone here knows functional programming?
13:11:12 <mizu_no_oto_work> sssilver: most people here do, I'd wager.
13:11:24 <mizu_no_oto_work> Any specific reason you ask?
13:11:37 <sssilver> cool, I had an interesting debate with a coworker about the merit of pure functions
13:11:49 <sssilver> and I wanted to share it with you and see what you think
13:12:04 <sssilver> so this is a debate about UI testing vs. unit testing
13:12:23 <sssilver> he's saying even if your individual functions work well, that doesn't mean that together they work well
13:12:32 <dfeuer> That is true.
13:12:38 <sssilver> and his example is that imagine you have two identical doors standing next to each other
13:12:39 <markasoftware> i think unit testing/pure testing is good for haskell
13:12:51 <markasoftware> but for my node.js project i had a lot of trouble doing it well
13:12:51 <sssilver> each door separately functions perfectly well, but if one is open, the other one won't open coz it's blocked
13:12:55 <markasoftware> because i had A LOT of glue code
13:13:03 <dfeuer> sssilver: that is an awful analogy.
13:13:08 <sssilver> dfeuer I agree
13:13:13 <dfeuer> Pure functions don't "block" each other.
13:13:22 <sssilver> dfeuer so what are your thoughts on the door analogy?
13:13:41 <sssilver> I argue that you introduce state by saying that the other door was opened
13:14:15 <dfeuer> I just told you. It makes no sense. There are real challenges putting pieces together (in any language/paradigm) but these doors are not an issue for pure functional programming.
13:14:19 <dfeuer> Yes.
13:15:01 <mizu_no_oto_work> A door doesn't function perfectly well if something in the floorplan is in its way.  There's a reason blueprints have the door's path on them, and nothing else goes there.
13:15:12 <dfeuer> Unless you're getting into questions about program optimizationt.... Inlining and such can lead to performance complications.
13:15:17 <sssilver> dfeuer so how would one program the doors in a pure functional paradigm and have it be perfectly testable and still be pure functions?
13:15:29 <sssilver> you'd say "I'd pass the state of the world to openDoor() function"
13:15:30 <julienchurch> I’m trying to create a type that basically has two classes. I’m going to go with the example of web pages which either require authentication or don’t. Given `data Page = Home | Dashboard`, is there a way that I can attach some semantic meaning to `Home` such that it doesn’t require authentication and `Dashboard` such that it does in some polymorphic function `access :: Page -> Bool`?
13:15:44 <sssilver> but then that becomes pretty crazy
13:16:16 <julienchurch> (Sorry, my terminology is a little mixed up in what I wrote.)
13:16:17 <dfeuer> If you want the doors? You probably want to use some sort of state representation, yes. If the states interact in complicated ways, it may be helpful to use State or StateT. If the state itself is complicated, you may even jump to ST.
13:16:50 <dfeuer> julienchurch: yes, you can. But Bool is a pretty meaningless return type.
13:16:58 <mizu_no_oto_work> sssilver:  Purely functional programming typically passes around state explicitly
13:17:00 <lpaste> jstolarek pasted “State monad issue” at http://lpaste.net/351605
13:17:04 <mizu_no_oto_work> Which is what makes it testable
13:17:06 <sssilver> dfeuer OK so his argument is, what if you didn't code your door that way? what if your door is coded to function in a vacuum, and then suddenly you find out that when two doors are open next to each other, the app crashes?
13:17:08 <dfeuer> Why not data AuthRequirement = NeedsAuth | NoAuthRequired
13:17:10 <jstolarek> it seems that I cannot parametrize state monad
13:17:26 <mizu_no_oto_work> You don't need magical initialization steps
13:17:34 <dfeuer> sssilver: what do these doors have to do with anything in reality. What?
13:17:36 <jstolarek> I mean parameterize state monad's state with the type of things returned by that monad
13:17:36 <dfeuer> Hi jstolarek
13:17:50 <jstolarek> Hi there dfeuer :-)
13:18:07 <dfeuer> jstolarek: that paste doesn't compile.
13:18:12 <mizu_no_oto_work> sssilver: "suddenly you find out that when two doors are open next to each other, the app crashes?" - because pure functions are pure, that doesn't happen. 
13:18:14 <dfeuer> It has unbound identifiers.
13:18:16 <lpaste> jstolarek annotated “State monad issue” with “State monad issue (annotation)” at http://lpaste.net/351605#a351606
13:18:30 <jstolarek> dfeuer: exactly
13:18:34 <jstolarek> that's my problem
13:18:39 <dfeuer> jstolarek: I mean "what is get"?
13:18:44 <jstolarek> oh
13:18:48 <jstolarek> you mean import
13:18:50 <jstolarek> imports
13:19:01 <jstolarek> import           Control.Monad.State.Strict
13:19:10 <dfeuer> Those are always nice.
13:19:14 <lpaste> jstolarek revised “State monad issue”: “State monad issue” at http://lpaste.net/351605
13:19:32 <julienchurch> dfeuer: The Bool here is just a placeholder for a command. As for `data AuthRequirement ...`, I had something similar in `data Page = Restricted PageContent | Unrestricted PageContent`, but I don't want a value `Restricted Home` to be possible in the first place
13:19:52 <mizu_no_oto_work> sssilver: because of the common dependence on implicit state, "I have two of these and now everything blew up" is associated with imperative programming.
13:21:23 <mizu_no_oto_work> sssilver: That said, there's no guarantee that combining two pure functions will do what you wanted it to do, any more than having two adjacent loops is guaranteed to do what you want it to.
13:21:42 <julienchurch> It's part of a larger `Model` that tracks the current page `{ ..., page :: Page, ... }` 
13:23:09 <mizu_no_oto_work> sssilver: "I'd pass the state of the world to openDoor() function" -- you don't neccessarily need to pass it the state of the whole world, just the part of the world it cares about
13:24:18 <mizu_no_oto_work> For example: openDoor could take a Room and return a Room.
13:24:43 <dfeuer> jstolarek: you have a bona fide mistake.
13:24:59 <jstolarek> dfeuer: please explain
13:25:16 <dfeuer> jstolarek: you can't get an `a` from an M (MyState a). You can only get a (MyState a).
13:25:36 <dfeuer> Er...
13:25:37 <dfeuer> Actually,
13:25:54 <jstolarek> that sounds right
13:26:02 <jstolarek> and I think this is what I've been trying to do
13:26:05 <dfeuer> It's that you can't get   (MyState a)  from  M (MyState a).  You can only get a (MyState (MyState a))
13:26:15 <jstolarek> o_O
13:26:33 <dfeuer> M (MyState a) = State (MyState (MyState a)) (MyState a)
13:26:43 <dfeuer> But get is    State s s
13:28:55 <jstolarek> but if I say
13:29:14 <jstolarek> getState :: M a
13:29:20 <jstolarek> then this will also not work
13:29:52 <jstolarek> I mean, I think it is intuitively obvious what it is that I am trying to achieve. The question is whethere there is a way of doing this
13:30:18 <dfeuer> You mean something like   getState <$> get?
13:31:47 <jstolarek> what I want to have is to have a state that is parameterized by the value returned by the monadic computations
13:31:58 <jstolarek> I'm implementing an interpreter
13:32:21 <jstolarek> and it might be the case that the state stores Env Value and returns a Value
13:32:47 <jstolarek> but it might also be the case that the state stores Env AValue and retursna an AValue
13:33:08 <dfeuer> What do you mean by "returns"
13:33:27 <jstolarek> I mean the last type parameter to State
13:33:30 <dfeuer> I'm guessing you may need your own MonadState instance to get what you want.
13:33:33 <jstolarek> or StateT
13:34:12 <jstolarek> ugh
13:35:27 <dfeuer> newtype MyStateT s m a = MyStateT {getMyStateT :: StateT s m a}
13:35:51 <chishiki> close
13:36:13 <dfeuer> instance Monad m => MonadState v (MyStateT (Env a) m) where ....
13:36:28 <dfeuer> There are actually several ways you can do something like that. I may have made mistakes.
13:36:58 <dfeuer> ^^ jstolarek
13:37:07 * jstolarek thinks
13:38:57 <jstolarek> I fail to see what is the motivation for such a restriction
13:38:59 <danilo2> Hello! I suspect the answer will be sadly "no" but maybe I dont know about something! :) Is it possible to derive instance of a class for newly created newtype and "override" some of the derived class methods?
13:39:40 <merijn> danilo2: No, it's all or nothing for deriving
13:40:07 <merijn> danilo2: That being said, you can trivially implement class functions for your newtype by calling the original
13:40:18 <dfeuer> danilo2: not now, but there's been talk of adding support for that!
13:40:48 <dfeuer> And even to derive some methods using one mechanism and others using another.
13:41:18 <danilo2> merijn: yeah, I can do it, but I hate such boilerplate. dfeuer: nice to know that! :)
13:41:57 <danilo2> dfeuer: If we allow for default associated type families definitions then I'll be super-happy! :D
13:42:20 <danilo2> maybe it will be possible in the future too :)
13:42:58 <dfeuer> danilo2: we do allow for default associated type family definitions!
13:43:20 <dfeuer> Which is precisely the one and only reason I've found for having associated families at all.
13:43:56 <merijn> I'm a bit confused why all the persistent stuff uses NoLoggingT?
13:44:16 <dfeuer> To avoid logging tea? Tea is supposed to be drunk.
13:44:28 <merijn> What's the point of having a explicitly non-logging transformer and forcing it in there?
13:45:25 <nshepperd> NoLoggingT adds a MonadLogger instance that throws away log messages?
13:46:09 <danilo2> dfeuer: are you joking? Do we? Why I missed that feature?!
13:46:11 <merijn> Right, but what if I do want logging?
13:46:45 <ertes> merijn: yesod stuff thrives on TH and sky-high monad stacks, which is why i tend to avoid it
13:46:45 <nshepperd> I dunno. that certainly seems like a strange this to put in the api
13:46:55 <merijn> ertes: I'm not using yesod
13:47:04 <ertes> merijn: yes, but persistent is "yesod stuff" =)
13:47:18 <dfeuer> danilo2: no joke at all. It's pretty much essential for generic definitions.
13:47:26 <merijn> ertes: I'm open to recommendations for "better" database interaction
13:48:03 <merijn> ertes: It's ok, it's just woefully underdocumented, since everything is just a pile of generic constraints it's not helpful that half the functions have no explanation of wtf the constraints are for
13:48:18 <ertes> merijn: depends on your standard of "better"…  personally i would model the application rather than "databases":  write a type class for your application's data model and write backends using the various DB libraries like postgresql-simple directly
13:48:26 <danilo2> dfeuer: It solves so much pains that I had that I feel like getting a christmas surprise right now. Huh, why I was missing that info! Thanks santa dfeuer ! :D 
13:48:46 <dfeuer> danilo2: check out https://github.com/ekmett/adjunctions/blob/master/src/Data/Functor/Rep.hs#L120
13:48:48 <merijn> ertes: I've looked at the various SQLite bindings...I was not impressed
13:49:01 <ph88> hey guys, when i run my program after a while i just see   [1]    22164 killed     stack ghci    how can i debug this ?
13:49:22 <danilo2> dfeuer: yep, I've already opened some examples. thanks!
13:49:30 <dfeuer> :D
13:50:49 <ertes> merijn: what do you need from a binding other than SQL with proper substitution and a streaming result interface?
13:51:20 <merijn> ertes: Some type safety stuff and not having to write tedious boilerplate would be nice
13:51:25 <nshepperd> 'Class which witnesses that backend is essentially the same as BaseBackend backend. That is, they're isomorphic and backend is just some wrapper over BaseBackend backend.' too many backends
13:51:45 <geekosaur> ph88, "killed" almost always means the OOM killer. since ghci is unoptimized, you might do better to compile the program instead of running from ghci; many memory-saving/fusing optimizations simply cannot be done
13:53:01 <ertes> merijn: what kind of type safety?  sqlite is inherently stringly typed, and sqlite-simple makes sure that those strings actually parse as the haskell type that you want
13:54:06 <merijn> I'm actually kinda happy with persistent, aside from the abysmal explanation of WTF all the different classes/families are
13:54:46 <ertes> merijn: one nice feature of my approach is that i can write an STM backend for testing =)
13:55:01 <dfeuer> WTF even is this shit.
13:55:06 <dfeuer> Pardon my language.
13:55:31 <ertes> merijn: the STM backend serves as a reference implementation, so you can test other backends against it
13:55:51 <merijn> ertes: But I don't wanna implement backends :(
13:56:23 <ertes> merijn: you're already implementing one…  you just haven't abstracted it, so it doesn't feel like implementing a backend =)
13:56:38 <ertes> persistent doesn't model your application, it only models "database"
13:56:52 <merijn> Sure, but in this case that's basically all I have anyway
13:56:56 <implementation> as long as you can use TemplateHaskell, persistent is nice. But hell will catch you if the TH doesn't fit your needs :)
13:57:15 <jstolarek> dfeuer: even with my own instances I end up with exactly the same problem
13:58:14 <dfeuer> jstolarek: you'll have to lpaste.
13:59:11 <lpaste> jstolarek pasted “more stateT” at http://lpaste.net/351608
13:59:34 <ertes> i think the only thing persistent really adds is migrations
13:59:44 <zennist_> one question regarding lens library: why are many functions taking in specialized versions of lens/traversals
13:59:54 <ertes> everything else is basically like using the database backend directly, except covered in a black box that is impossible to penetrate
13:59:58 <lpaste> jstolarek revised “more stateT”: “more stateT” at http://lpaste.net/351608
14:00:09 <lpaste> jstolarek revised “more stateT”: “more stateT” at http://lpaste.net/351608
14:00:16 <ertes> i wish there was a migration library – a library that does nothing other than migrations
14:00:30 <zennist_> e.g., view takes specifically (a -> Const a) -> (b -> Const b); why not a: forall f. Applicative f => (a -> f a) -> (b -> f b)
14:00:42 <zennist_> probably not a lot of practical difference, but still would like to know
14:00:42 <jstolarek> dfeuer: done
14:01:24 <dfeuer> jstolarek: you need   instance Monad  => MonadState a (MyStateT (Env a) m) where ....
14:02:01 <zennist_> gurus, please save this troubled soul...
14:03:01 * dfeuer is confused. He thought jstolarek was one of the people who knew all there was to know about Haskell.
14:03:16 <jstolarek> dfeuer: I tried but couldn't get it to typecheck
14:03:24 <jstolarek> dfeuer: sorry to disappoint you :-)
14:03:36 <dfeuer> OK. Let me try.
14:03:49 <jstolarek> monad transformers is a place where I rarely venture
14:04:28 <ph88> geekosaur, i compiled my program now but i still get the saem
14:04:32 <dfeuer> jstolarek: what is Env, btw?
14:04:36 <jstolarek> Map
14:04:43 <dfeuer> What sort of Map?
14:04:58 <dfeuer> Show me the definition of Env!
14:05:35 <lpaste> jstolarek annotated “more stateT” with “more stateT (annotation)” at http://lpaste.net/351608#a351612
14:08:16 <hth313> Does anyone else have problem with haskell-mode in Emacs? I get "Haskell process command errored with: (error "Unexpected response from haskell process.")" very often, started a couple of days ago
14:08:44 <dfeuer> jstolarek: how am I supposed to get an a out of a Map Var a?
14:10:25 <ertes> hth313: doesn't it ask you to review the output?
14:10:28 <jstolarek> lookupEnv :: Env a -> Var -> a -> a
14:10:37 <jstolarek> dfeuer: ^^^
14:10:42 <ertes> hth313: it usually happens when your cabal file is messed up
14:10:49 <dfeuer> jstolarek: but get doesn't take a Var. Where do I get the Var from?
14:11:01 <jstolarek> this is Map.findWithDefault with different order of arguments
14:11:12 <jstolarek> no no
14:11:30 <dfeuer> You can't get an  `a` from an `Env a` without having a Var...
14:11:32 <jstolarek> the intention of getState is to get the whole environment'
14:11:37 <prohobo> pretty sure he's racist
14:11:42 <jstolarek> so Env a
14:11:46 <jstolarek> not any particular a
14:12:36 <dfeuer> jstolarek: so you can just use StateT, and use   type M a = StateT (Env a) IO (Env a) ?
14:13:03 <dfeuer> You're confusing me a bit.
14:13:32 <dfeuer> What type do you want your state blob to store? What type do you want get to return?
14:13:56 <jstolarek> state is supposed to be an (Env a), the return thing is supposed to be an a
14:14:04 <jstolarek> I'm implementing an interpreter
14:14:12 <jstolarek> and state stores variables in scope
14:14:35 <dfeuer> jstolarek: getEnvM :: Ma, so  getEnvM :: MyStateT (Env a) IO a
14:14:39 <jstolarek> since the semantics of my language are strict, the state is (Env Value)
14:14:57 <dfeuer> That means that getEnvM uses a state of type Env a to produce something of type a.
14:15:05 <dfeuer> But that's impossible without a Var in its pocket.
14:15:05 <jstolarek> the result of evaluation is just a single Value
14:15:28 <jstolarek> not necesarily
14:15:37 <dfeuer> Very.
14:16:04 <jstolarek> the final value does not have to be stored inside the state
14:16:12 <dfeuer> That's ... not the point?
14:16:16 <jstolarek> it can be computed based on the values in the state
14:16:24 <dfeuer> OK, let's just start over from scratch?
14:16:25 <jstolarek> but it does not necesarilly have to be one of them
14:16:39 <dfeuer> You're implementing an interpreter for a stateful language.
14:16:40 <jstolarek> sure
14:17:04 <dfeuer> So typically, that means you have some sort of store (giant state blob).
14:17:15 <jstolarek> well, the interpreter is stateful, in a sense that it has to store values of variables that are currrently in scope
14:17:21 <jstolarek> yup
14:18:11 <dfeuer> If you want a notion of scope, then you probably want more.
14:18:33 <dfeuer> Do you support references and such, or do you just have local state?
14:19:02 <jstolarek> no references yet
14:19:11 <dfeuer> Are you going to add them?
14:19:14 <jstolarek> I'll be adding them once I sort out that mess ;-D
14:19:32 <dfeuer> OK, so that means you're going to want to separate "store" from "environment".
14:20:02 <dfeuer> Typically, "store" is going to be one state blob that threads through the whole interpreter.
14:20:20 <dfeuer> It's a map from "locations" to values.
14:20:51 <jstolarek> certainly, yes. I fail to see connection to my problem yet, but please continue
14:21:25 <dfeuer> And then typically the environment will be something like   [Map Var Loc]
14:21:34 <dfeuer> (for a basic example, anyway)
14:21:47 <jstolarek> yes, that's right
14:22:03 * dfeuer is dredging things up from long-ago memory; have patience!
14:23:16 <jstolarek> dfeuer: if you like to have a concrete discussion on this I can point you to the code
14:23:25 <jstolarek> I mean, the actual code that I'm working on
14:23:34 <hth313> ertes: It just gives me this 'Unexpected response from haskell process'. Good idea on the cabal file. I normally build with 'ghc --make' when generating binaries, my (generated) cabal is mostly there to make haskell-mode work for interactive development, I will investigate that.
14:23:36 <dfeuer> Sure.
14:23:39 <jstolarek> bt the whole problem really boils down to these few lines of code
14:23:44 <dfeuer> But I do have to get back to my own crud soon.
14:23:49 <jstolarek> so I think it will only obscure the point
14:23:53 <jstolarek> sure
14:24:04 <dfeuer> Link?
14:24:34 <jstolarek> https://github.com/jstolarek/slicer/tree/monad-refactoring
14:24:50 <jstolarek> more specifically
14:24:54 <ph88> i run my program with   stack exec -- program -prof -fprof-auto  and i expect a .prof file to show up, but i don't see it .. anyone know what could be wrong ?
14:24:54 <jstolarek> https://github.com/jstolarek/slicer/blob/monad-refactoring/src/Language/Slicer/Monad/Eval.hs
14:24:56 <dfeuer> Oh, BTW, have you read "monad transformers step by step"? I don't remember it, but I definitely remember that working through it was informative.
14:25:20 <dfeuer> (although there's one aspect that's out of date, having something to do with failure I think)
14:25:27 <jstolarek> yes, I did. That and some other transformer tutorials as well
14:26:37 <seequ_> I didn't understand monads nor monad transformers before implementing StateT and ExceptT from scratch
14:26:51 <seequ_> I recommend doing it
14:28:53 <dfeuer> jstolarek: so what's going wrong with the code in that blob?
14:29:35 <dfeuer> Oh, just the type of getEnv?
14:29:50 <dfeuer> No,
14:29:52 <dfeuer> not that.
14:29:52 <jstolarek> dfeuer: so that code happens to work
14:29:53 <dfeuer> Sorry.
14:30:04 <dfeuer> Yeah.
14:30:09 <dfeuer> That looks fine.
14:30:11 <jstolarek> but now imagine I want to generalize the state to store (Env a)
14:30:22 <jstolarek> and all hell breaks loose
14:31:44 <dfeuer> jstolarek: can you show the broken real code too?
14:32:40 <jstolarek> give me a second, I need to write it 
14:34:58 <jstolarek> dfeuer: https://github.com/jstolarek/slicer/blob/monad-refactoring-broken/src/Language/Slicer/Eval.hs
14:37:03 <dfeuer> jstolarek: that looks like an entirely separate lump of code.
14:37:39 <jstolarek> ?
14:37:48 <jstolarek> oh
14:37:50 <jstolarek> sorry
14:37:50 <dfeuer> jstolarek: different module.
14:38:03 <jstolarek> https://github.com/jstolarek/slicer/blob/monad-refactoring-broken/src/Language/Slicer/Monad/Eval.hs
14:38:40 <dfeuer> jstolarek: aha! The probeb begins on the first line.
14:39:08 <dfeuer> You meant   type EvalM a = StateT (EvalState a) (ExceptT SlicerError IO)
14:39:15 <dfeuer> (without the final `a`)
14:40:10 <dfeuer> I personally prefer just not to use type synonyms except when I want to wrap them around type families. Type synonyms confuse everything.
14:40:37 <dfeuer> One of my challenges learning the GHC code base is that it is completely stuffed with type synonyms.
14:42:53 <jstolarek> dfeuer: ah, you're right~
14:43:10 <jstolarek> that's what happens when you code all day :-/
14:43:16 <dfeuer> Yeeeeeah.
14:43:25 <dfeuer> Or when you use type synonyms.
14:43:29 <dfeuer> Just Say No.
14:43:31 <jstolarek> or that :-)
14:43:49 <jstolarek> I can probably go for newtypes
14:43:56 <dfeuer> Yes!
14:44:05 <dfeuer> That is why Dog invented GeneralizedNewtypeDeriving.
14:44:17 <megaTherion> is it possible to use pattern matching in record syntax?
14:44:40 <dfeuer> megaTherion: yes, in several ways, two of them standard.
14:45:07 <megaTherion> dfeuer: Im looking for something like e = e { fieldA = x, field B = ... | ...
14:45:31 <dfeuer> megaTherion: you could use       case e of E x y -> ....
14:45:47 <dfeuer> Or you could use   case e of E {fieldA = x, fieldB = y}
14:45:54 <dfeuer> Or you could leave out some fields if you don't care about them.
14:46:01 <dfeuer> (with the second syntax)
14:46:27 <megaTherion> dfeuer: well I want an either or thing, fieldB = if fieldB > fieldA then fieldZ else ...
14:46:44 <dfeuer> megaTherion: I really don't know what you mean.
14:47:11 <megaTherion> guess I can make just another function of course
14:47:22 <dfeuer> I just actually don't understand what you're asking.
14:47:37 <megaTherion> dfeuer: I want to assign fieldB either the value Z or Y depending on the expression J
14:47:53 <dfeuer> What's that have to do with pattern matching?
14:48:29 <megaTherion> dfeuer: with pattern matching (eg. guards) it would work too but it seems I cant use it this way
14:49:01 <dfeuer> megaTherion: I'm sorry; you need to be much more concrete and specific if you want meaningful help. I still have no idea what you're asking.
14:49:27 <megaTherion> nevermind, Im not good with explaining ^^
14:49:30 <dfeuer> And I'm starting to get grumpy for some reason. Hrmmmmmm....
14:50:20 <megaTherion> oh noes please dont, no need to :)
14:50:47 <Guest8376> Hi
14:52:13 <Guest8376> Is there a way to convert this Tree in a functor? -> http://lpaste.net/351613
14:53:28 <dfeuer> megaTherion: my grumpiness is mostly not related to you. It's just w hat's happening.
14:53:29 <Cale> Guest8376: You mean add a Functor instance for it? Sure.
14:53:33 <geekosaur> Guest8376, is this homework?
14:53:42 <Jello_Raptor> hmm if I have a function `foo x = ... where bar = <value that doesn't depend on x>` will the thunk for bar be saved for multiple calls of foo or will it be discarded and regenerated with each call
14:54:00 <dfeuer> geekosaur: best to assume not, and answer "deriving (Functor)" :-P
14:54:27 <Jello_Raptor> I figure the latter, since you can get a space leak out of something like that, but I'm not sure? 
14:54:27 <dfeuer> Or if it's the right sort of newtype, "fmap = coerce".
14:54:28 <Guest8376> Yes a Functor instance
14:54:47 <Guest8376> geekosaur, yes, it's a bad homework :(
14:55:02 <dfeuer> Jello_Raptor: it probably *will* be saved if you compile with optimizations.
14:55:11 <hpc> Jello_Raptor: yeah, assume it's not shared, and that -O may or may not make it shared
14:55:15 <dfeuer> Jello_Raptor: it can be somewhat difficult to *prevent* it from being saved.
14:55:38 <Guest8376> Cale, yes
14:55:46 <geekosaur> doesn't sound like a bad homework, it's checking if you understand what a functor is supposed to do
14:55:51 <dfeuer> It's almost always easier to convince GHC to share something than to convince it not to.
14:55:58 <dfeuer> Perfectly good homework.
14:56:13 <Jello_Raptor> right, in my current case `bar` is very compute heavy and I'd like it to stick around without having to clutter the top level declarations 
14:56:39 <Guest8376> I know but I'm in trouble with the use on `[]` near `Node a`
14:56:47 <dfeuer> Jello_Raptor: you can use    foo = \x -> ...    where expensive = blah
14:56:57 <atondwal> does anyone know ghc-mod well? It's clear how to use djinn with it in emacs, but the vim command is unclear?
14:57:13 <Jello_Raptor> dfeuer: cool, thanks
14:57:19 <hpc> Jello_Raptor: or!
14:57:22 <hpc> foo = foo
14:57:23 <hpc>   where
14:57:27 <hpc>     foo' x = ...
14:57:29 <hpc>     bar = ...
14:57:38 <hpc> er, foo = foo'
14:57:45 <ij> Does stack install binaries?
14:57:47 <dfeuer> Guest8376: well, what do you need to do with the list?
14:57:53 <Koterpillar> ij: if you ask it to
14:58:17 <ij> How do I?
14:58:30 <Koterpillar> stack install ...
14:58:48 <Guest8376> dfeuer, I want to map a function over it using `fmap` and `f`
14:58:55 <Jello_Raptor> hpc,dfeuer: I've been using both of those depending on which looks more elegant in each use case
14:59:00 <dfeuer> Guest8376: sounds like a plan!
14:59:07 <ij> Koterpillar, Thanks, didn't know.
14:59:12 <geekosaur> "stack install" will install to ~/.local/bin unless you have a project layout that creates an "install" directory (which is intended for distribution)
14:59:44 <ij> noooooo~~, dependencies don't match for fix-imports. :(
14:59:49 <dfeuer> Jello_Raptor: it's not 100% reliable; GHC could accidentally inline it, but that's relatively unlikely.
15:00:16 <Guest8376> dfeuer, `fmap f (Node x list) = Node (f x) [fmap f node | node <- list]` make sense?
15:00:21 <Jello_Raptor> cool
15:00:36 <dfeuer> Guest8376: nope.
15:00:54 <dfeuer> Guest8376:   fmap f (Node x list) = Node (f x) _   is right, but the rest is off.
15:01:05 <dfeuer> You want to map a function over the list, right?
15:01:10 <dfeuer> So .... do that?
15:01:37 <dfeuer> Guest8376:   fmap f (Node x list) = Node (f x) (fmap _ list) 
15:01:37 <Guest8376> dfeuer, let me think :D
15:01:49 <Taneb> dfeuer, I think that definition works, even if it's a bit awkward
15:01:49 <dfeuer> Oh, sorry.
15:01:59 <dfeuer> Taneb: no, it does not.
15:02:07 <dfeuer> Taneb: it will give a type error.
15:02:49 <dfeuer> Taneb: but you're right that there are two different parts each of which can be erased to produce a correct answer.
15:02:52 <Guest8376> dfeuer, what _ means inside ` (fmap _ list)` ?
15:02:59 <dfeuer> Guest8376: it's a hole.
15:03:08 <Taneb> Guest8376, something for you to fill in
15:03:11 <dfeuer> If you compile that, then ghc will tell you the type of what's supposed to b e in the hole.
15:03:13 <dfeuer> *be
15:03:18 <Guest8376> dfeuer, ahah ok
15:03:21 <dfeuer> Which is a terrifically useful feature.
15:03:26 <hpc> for sufficiently recent ghc
15:03:33 <dfeuer> You can also *name* the hole, like  _a
15:03:40 <dfeuer> Which is useful if you have several holes at once.
15:03:53 <dfeuer> Yes, you should certainly never use a version of GHC from before typed holes!
15:04:01 <dfeuer> That's ancient times garbage!
15:04:22 <geekosaur> was gonna say, you were assuming a recent ghc and not, say, ghc7.6 from debian. or an old winghci. or hugs, which some courses *still* use
15:04:26 <Guest8376> dfeuer, ` fmap f (Node x list) = Node (f x) (fmap f list)`
15:05:06 <dfeuer> Guest8376: yes, that is the cleanest way. You can do it with a list comprehension instead, and you should try figuring out that alternative for practice.
15:05:11 * dfeuer goes away to work....
15:05:26 <Taneb> geekosaur, heh, I have a textbook which starts by "Please install hugs"
15:05:27 <vapid> trump did nothing wrong
15:05:46 <geekosaur> please take that elsewhere
15:05:49 <Taneb> A lot better than the time I tried to learn APL and it started with "Please connect your telephone to your typewriter"
15:05:52 <geekosaur> this is not a political channel
15:06:08 <vapid> trump did nothing wrong and strings as lists of char was a bad idea
15:06:10 --- mode: ChanServ set +q *!*@85.255.13.137
15:07:00 <geekosaur> right, thought I recognized that nick. saw that crap in backscroll.
15:07:23 <ph88> i made a profile of my program https://paste.fedoraproject.org/535887/29915814/raw/ can anyone suggest a way to figure out why certain functions get called over 2.6 million times ?
15:08:12 <erisco> cabal install sbv failed ghc 8.0.1 http://lpaste.net/351614
15:08:59 --- mode: ChanServ set +o geekosaur
15:08:59 <vapid2> https://thepasteb.in/p/j2hlKNPMBJjcP
15:09:05 <vapid2> truly you have no sense of niceness
15:09:21 --- mode: ChanServ set +o glguy
15:09:21 --- mode: glguy set +b *!*@*/ip.95.168.45.50
15:09:31 <geekosaur> where "niceness" is as always defined as "puts MEEEEEEE first"
15:09:57 --- mode: glguy set -qb *!*@85.255.13.137 *!*@85.255.13.137
15:10:04 <dyreshark> but what if i'm a special snowflake and deserve immediate attention?
15:10:19 --- mode: geekosaur set -o geekosaur
15:10:33 <glguy> dyreshark: in that case I have lots of space left in the ban list
15:10:33 <bitemyapp> I guess the days of letting a native do the troll-whisperer routine are over. Can't blame you.
15:11:15 <Guest8376> dfeuer, Thanks a lot!
15:12:34 <Cale> bitemyapp: He wasn't trolling about Haskell though, so it wasn't really the same
15:14:38 <geekosaur> erisco, GHC.SrcLoc isn't in 8.0.1. looks like the guts are now in GHC.Stack
15:14:57 <erisco> never mind, updated my package list and got sbv 5.14 which works
15:15:30 <geekosaur> (sorry for delay, troll was a bit of a distraction >.<)
15:18:27 <erisco> slick, found 256 solutions to \x -> x .== (x :: SInt8)
15:18:46 <erisco> glad this module exists... gives a tolerable interface to SMT solvers
15:19:52 --- mode: ChanServ set -o glguy
15:23:10 <erisco> how is it doing anything other than brute force though
15:23:36 <erisco> say you have \x -> f x < n  for some f and n
15:23:55 <erisco> it knows no property of f other than it is a function
15:25:25 <erisco> in fact it doesn't even know f is there
15:25:48 <erisco> all the lib can do is apply the function and see  y < n  where y = f x
15:26:46 <erisco> ah, it must be in the "symbolic" types
15:27:34 <erisco> if f is \x -> x + x then I imagine the Num instance for SInt8 is just an addition constructor
15:28:43 <erisco> and they have their own comparison operators because they send to Bool or Ordering... gotcha
15:29:22 <erisco> excellent then!
15:31:17 <erisco> so really we have an eDSL for SMT solvers
15:31:41 <erisco> also using higher order abstract syntax
15:51:51 <athan> Can I merge an exhaustive set of prisms into a lens, given that the latter type is the same?
15:52:31 <athan> for instance, a few prisms of `Prism foo a`, where both `foo` and `a` are constant between the prisms
15:56:55 <glguy> You can assert that it's a lens with singular and failing: singular (_Left `failing` _Right) :: Lens' (Either a a) a
16:00:43 <dfeuer> :t failing
16:00:46 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
16:04:33 <athan> O_O thank you dfeuer
16:05:01 <athan> thank you glguy!!
16:05:49 <dfeuer> athan: what did I do?
16:07:52 <athan> sorry yours was the first I saw
16:07:57 <athan> your response*
16:23:58 <nshepperd> :t singular
16:24:00 <lambdabot> (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
16:24:37 <Welkin> conjoined twins? O.o
16:25:19 <dfeuer> Conjoined profunctor, whatever that means.
16:26:31 <glguy> It means that it's either a function or a function carrying an index
16:27:33 <lpaste> Ste1891 pasted “Odd non - error” at http://lpaste.net/351616
16:27:40 <Ste1891> Hey.  I've come across an odd thing while working through a modification of the 3D game engine I'm working on.  In the function I've posted I allocate memory and store the pointer in p_wtc_matrix, then write data into the allocated buffer with the load_array function, but (erroneously) free the pointer before passing it to certain openGL function bindings.  I must have been on the drink at the time, but the odd thing is the program works in 
16:27:40 <Ste1891> a way it couldn't without that data being accessible to those functions.
16:28:21 <Ste1891> Is it just me, or is something a bit odd happening there?
16:30:01 <Rembane> Ste1891: Maybe the data is in the right place, not overwritten, and accessible even though it is deleted?
16:30:29 <geekosaur> incorrect free is one of the hardest things to debug specifically because, unless the malloc implementation is specifically designed to trash such data, it remains valid until something reuses the memory
16:31:39 <geekosaur> (thta is, free() specifically overwrites the memory with garbage... which is not common as it has a performance impact)
16:34:13 <lordcirth_> why not zero it?  Seems safer
16:35:23 <geekosaur> "safer" but it's not a free operation, it takes time to zero a block of memory
16:35:27 <hpc> memory management is a silly thing
16:35:45 <hpc> geekosaur: the question is why write random garbage instead of writing zeroes
16:36:07 <Koterpillar> write a known bad value
16:36:19 <geekosaur> because that might not necessarily be sufficient to mark it as no longer valid, depending on use case
16:36:46 <Koterpillar> I think some compilers, in debug mode, filled with 0xFEEE, meaning it's FREE
16:36:54 <geekosaur> if you are on a glibc-based system you can use `export MALLOC_PERTURB_=1` to force malloc/free to zap allocated and freed memory (see `man mallopt`)
16:37:18 <geekosaur> it's not really up to the compiler, it's up to the malloc implementation
16:39:08 <geekosaur> oh, 1 is not the best idea, the value is significant... freed bytes are set to the value mod 256, allocated bytes are set to its complement
16:39:47 <geekosaur> so MALLOC_PERTURB_=255 would clear memory allocated by malloc() and set it to all-bits-set on free()
16:40:41 <hpc> i like the random underscore right at the end
16:40:46 <hpc> makes it feel really __pythonic__
16:41:20 <Ste1891> Well, I've learned something new.  I had thought that making that kind of error would cause a seg fault.
16:41:20 <hpc> also does that mean when the value is 0 it does nothing, or that it does the opposite of 255?
16:42:00 <Zemyla> Huh, you can do finger trees tagged with just a Semigroup.
16:42:18 <hpc> Ste1891: 's why buffer overflows are a security bug instead of a 2AM nuisance
16:42:22 <geekosaur> 0 means don't do anything, since the behavior is only triggered for nonzero values
16:42:38 <hpc> ugh, who needs out of band values ;)
16:42:47 <geekosaur> Ste1891, sometimes it does, depending on memory allocation patterns. that's what makes such errors so annoying to track down
16:43:36 <geekosaur> it's the kind of bug that might happen completely randomly, or might happen every time, or only happen at 0330 Sunday after a full moon >.>
16:47:02 <Ste1891> So, are you saying that this kind of error could cause undefined behaviour such as an intermittant fault that doesn't depend entirely on your program's semantics?
16:47:30 <geekosaur> right, because you also have to know exactly what the runtime is doing, including potentially details of scheduling other threads to run
16:48:04 <geekosaur> because they all allocate memory from a common pool, and ghc's runtime will malloc() more heap as needed
16:48:30 <geekosaur> but, this is what you let yourself in for when you start using malloc and free directly for FFI stuff
16:48:52 <geekosaur> it's very much "safeties are OFF" territory
16:50:31 <hpc> at this low level things are so thin on guarantees that i would say "unsafeties are ON"
16:54:52 <Ste1891> Hmmm...I might have just got to the bottom of a rather disturbing bug then.  I don't see the point in wrapping interfaces to low level libraries such as openGL with layers of abstration though, as you're actually taking yourself conceptually further away from what's happening.
16:55:24 <hpc> you wrap them to get rid of the terrible edge cases that violate safety
16:55:50 <hpc> basically we make those table saws that detect a static charge and automatically emergency stop
16:55:56 <hpc> because most of the time that static charge is your finger
16:56:42 <polll> Hey is anyone here using Windows? Trying to launch an external .exe using the system function but I'm getting path errors. Any ideas as to what I'm doing wrong? http://lpaste.net/351617
16:56:56 <dfeuer> Well, Ed Kmett decided it was really important to have a totally low-level OpenGL binding library, so he made one....
16:57:43 <geekosaur> polli, what's the & and extra quoting supposed to be doing?
16:58:06 <geekosaur> hm, I don't even know if system uses cmd.exe or a sh-oid
16:58:08 <hpc> dfeuer: it's important to have both
16:58:30 <hpc> i wish gpipe would get more maintenance
16:58:35 <geekosaur> cmd.exe. that's going to not work well
16:58:37 <dfeuer> Yes, both.
16:59:14 <Ste1891> I guess it's a matter of personal preference.  Thanks for the advice though.  I'm going to bed now.  Bye...
17:01:56 <geekosaur> polli, since that is fed to cmd.exe, (a) single quotes do not work (b) I suspect you intended \\ instead of \" (c) that & doesn't look right, and on my system gets me "& was unexpected at this time"
17:05:33 <polll> Ah, I wasn't escaping quotes properly. Thanks so much, geekosaur!
17:33:38 <nitrix> What kind of performance can I expect for a 2D video game, whose event waiting, event processing, the rendering and networking, all happens in different threads, coordinated via MVar?
17:34:12 <nitrix> Are MVar overkill, too expensive or whatnot that I need to worry about?
17:34:20 <EvanR> overkill compared to what
17:34:25 <EvanR> IORefs ?
17:34:54 <EvanR> i think the concurrency is your least concern in that situation
17:36:59 <nitrix> EvanR: Well, like IORef, you know you have to be careful for contention, because it's an atomic operation and it'll just repeat the operation until it succeeds.
17:37:20 <EvanR> dont you mean TVars ?
17:37:34 <nitrix> If that's the case, I'm even more confused than I thought.
17:37:42 <EvanR> atomic modify IORef doesnt retry, it just does
17:38:46 <nitrix> I'm inquiring about MVar, since they are the foundation of the engine I'm building and I'll get tons of these events (for example, just mouse movements).
17:39:15 <EvanR> it makes sense to me to use MVars
17:39:35 <nitrix> Am I going to pay some cost of thread waking up, sleeping, back and forth, even though there are more events to be written via putMVar or similar?
17:39:41 <hpc> have you looked at Chan?
17:39:43 <EvanR> if the one event processor isnt ready to process more events, then things handing events from the OS to it might as well be blocking too
17:40:02 <EvanR> for example if you use Chan, and you cant handle events fast enough, they will just pile up and waste memory
17:40:14 <EvanR> (so might as well let them keep piling up in X11?)
17:41:05 <EvanR> as i understand it, switching threads is pretty efficient in GHC
17:41:14 <EvanR> which is why you can have so many
17:41:23 <nitrix> EvanR: That's something I thinkered about too. At least X11 will handle the overload of event and mark the window unresponsive until it unbuffers instead of sending more window events and making the problem worse.
17:41:33 <hpc> switching threads is virtually free, to the point where you can consider threads themselves to have only a memory footprint
17:41:53 <hpc> (plus the cost of the computation within those threads, ofc)
17:42:03 <EvanR> i cant imagine X11 events showing up fast enough for any of this to matter. perhaps network events might?
17:42:14 <EvanR> if youre getting DDOsed
17:42:25 <nitrix> EvanR: Possibly, but I'll have bigger problems at this point.
17:42:37 <nitrix> EvanR: hpc Thanks for the answers. That seems to ease my worries.
17:43:11 <EvanR> "dont worry its incredibly fast" ... haskell is the only good system ive used where this answer comes up this much
17:43:45 <EvanR> unless its speed of compilation
17:43:53 <hpc> EvanR: i love reading the ghc manual and finding where it says some particular internal function is faster than malloc
17:44:02 <nitrix> I've never considered compilation speed an issue.
17:44:14 <EvanR> for live coding its an issue
17:44:28 <hpc> compiling isn't really that slow until you start doing -O or pulling in huge dependencies
17:44:29 <EvanR> or rebuilding everything on hackage
17:44:55 <EvanR> hpc: even before haskell i imagined malloc as this semi-beast of a routine
17:45:34 <hpc> it's certainly a beast conceptually
17:45:48 <hpc> you can fill up your memory with 0-byte mallocs, which is particularly entertaining
17:46:02 <EvanR> what ._.
17:46:39 <hpc> iirc, before the address it returns to you after allocation, there's some data about that allocation that is kept
17:46:47 <hpc> that says how long it is and whatnot
17:48:08 <nitrix> https://github.com/vendu/OS-Zero/blob/8487d6b116fdc80ebde21ef0150654ba4f1c7ad0/usr/lib/c/malloc.c#L169
17:48:12 <hpc> if you think about it, it's gotta know what memory you've allocated somehow
17:48:37 <nitrix> Beating GCC's malloc isn't too hard apparently. I have a friend who wrote a much better slab allocator for his operating system project.
17:48:48 <nitrix> Granted he's a really clever guy.
17:49:17 <kadoban> It's usually quite possible to beat general purpose code for a specific purpose, often by a lot.
17:49:25 <EvanR> crazy ass ad hoc C data structures... shudder
17:49:33 <hpc> see also, ghc's insane allocation algorithm
17:49:50 <hpc> most of the time, all it does is increment a pointer
17:50:02 <EvanR> <3
17:50:21 <hpc> all you need is the mother of all RTSs on top of it
17:50:38 <EvanR> how i learned to stop worrying and love sweeping GC (rather than reference counting)
17:54:14 <ertes> nitrix: benchmark it…  i would expect MVar to be the slowest solution with TVar and IORef the fastest and TMVar somewhere in the middle
17:54:42 <EvanR> the use-case calls for MVar or TMVar
17:55:06 <EvanR> i.e. Chan1
17:55:13 <nitrix> Curiously, what makes all the STM stuff so fast?
17:55:14 <ertes> the game world would rather be a TVar/IORef
17:55:24 <EvanR> nitrix: lack of mutex locking
17:55:43 <ertes> nitrix: STM is just really clever about not acting like STM when the transactions are not transactional =)
17:55:56 <EvanR> o_O
17:56:08 <ertes> the reason that TMVar is faster than MVar is that the latter has some fairness guarantees that TMVar does not have
17:56:36 <ertes> but it depends…  in this particular use case i would expect TMVar to outperform MVar
17:56:53 <EvanR> its because TMVar is based on TVars not MVars which are basically locks
17:56:54 <ertes> in other applications the fairness guarantee is actually desirable for speed
17:57:44 <nitrix> In my case, they are all independent threads waiting on that single MVar, so I'm assuming the fairness of the scheduler is enough?
17:58:07 <nitrix> I seem to always have a single writer and singler reader.
17:58:28 <ertes> nitrix: if that's invariant, then they probably perform equally well
17:58:41 <ertes> nitrix: but this is all speculation…  benchmark!
17:58:46 <EvanR> the different in performance comes with amount of contention
17:58:59 <EvanR> high contention, TVars start to waste time
17:59:00 <ertes> nitrix: after all you can easily switch from MVar to TMVar, etc.
17:59:00 <nitrix> Except for the renderer, which has multiple writers, but I let them override one another. I chose a MSampleVar for that.
17:59:21 <EvanR> low contention, MVars are wasting time with locking
17:59:31 <nitrix> ertes: Mhm. I agree with the benchmarks. I'll definitely test things out more once the game has a little more gut to it.
17:59:41 <nitrix> ertes: Otherwise it's hard to have a realistic idea.
17:59:55 <ertes> nitrix: also don't use MVar/TMVar if you actually need a mutable variable…  in that case use TVar or IORef
17:59:56 <nitrix> ertes: By the way, I'm integrating reflex in the framework of my game.
18:00:16 <nitrix> ertes: It'll be probably a questionable mix of ECS and Reflex.
18:00:37 <ertes> nitrix: i like reflex, but check twice that it fits your use case…  most notably regarding randomness
18:01:20 <ertes> the only point where you can validly introduce randomness is outside of the reactive part
18:01:57 <nitrix> ertes: I just like that the performance concern shows directly in the API. Events are push-based in that PushM monad, and Behaviors are pull-based in that PullM monad.
18:02:31 <nitrix> ertes: You're able to do sampling additionally, but it seems a lot easier to reason about the implications.
18:02:52 <ertes> also i recommend that you use a single root event and make sure that you trigger it often enough due to this: https://github.com/reflex-frp/reflex/issues/63
18:02:59 <nitrix> ertes: Whereas with pull-based or push-based frp frameworks, I always felt like I was making a performance compromise.
18:03:00 <EvanR> i have a feeling thats not the exact right place to put the "performance tuner"
18:03:23 <EvanR> you have this algebraic way to move the push pull boundary either way
18:03:30 <EvanR> but isnt reflected in the api
18:04:00 <nitrix> EvanR: Are there any FRP frameworks that don't leak :P ?
18:04:13 <ertes> "leak"?
18:04:20 <EvanR> im still not sure what that refers to
18:04:25 <nitrix> Seems like they all have space or time leaks.
18:04:47 <ertes> reactive-banana and wires don't have any leaks to the best of my knowledge
18:04:58 <EvanR> the concern might have been leaks from using the library a certain way that the api doesnt stop you from doing
18:05:18 <ertes> but reactive-banana is not really suitable either:  it doesn't fix the randomness problem, and it's callback-based
18:05:20 <EvanR> and by making it more low level, it still doesnt stop you
18:07:06 <EvanR> the only specific instance i heard about is in Fran, if you try to "save" a thing that refers to an event (to restore it later), you have an increasing history of events being held on to
18:10:20 <ertes> also there are two kinds of leaks involved here: there are time leaks, which are a conceptual weakness found in earlier FRP frameworks, and there are memory leaks, which are simply bugs that need to be fixed
18:11:09 <EvanR> theres an "FRP zoo" github with 99% javascript stuff
18:11:27 <ertes> and 95% of them aren't FRP =)
18:11:27 <EvanR> we need an FRP zoo with facts and research into the actual deal with haskell libraries
18:12:12 <Zemyla> ertes: What is a time leak?
18:12:28 <Zemyla> Sounds like something you call The Doctor for.
18:12:38 <ertes> Zemyla: that's surprisingly accurate
18:12:53 <ertes> Zemyla: imagine a behaviour that denotes the value of another behaviour five seconds ago
18:16:18 <miscyb> how can i get haddock for gi-gtk?
18:16:34 <miscyb> i'm guessing it's not on hackage because it's dynamically generated or something
18:16:55 <glguy> add /docs
18:17:51 <miscyb> glguy: what do you mean by that? is it a cabal option?
18:18:34 <glguy> no on Hackage
18:22:08 <miscyb> glguy: oh interesting. why is is laid out like that and not linked on the main page?
18:25:35 <glguy> because the module list is dynamically generated
18:26:26 <glguy> they aren't listed in the .cabal file and hackage doesn't know about them
18:27:43 <Sornaensis> how do I profile my program without installing profiling libraries for all of its dependencies
18:28:06 <glguy> no
18:41:43 <darbaga> Hm, why is ghc so big? downloading with stack it's ruffly 140m without msys..i'm just curious, i can download it
18:42:30 <Welkin> ghc is not that large o.o
18:45:28 <monochrom> Yes 140MB compressed, approaching 1GB uncompressed.
18:45:42 <monochrom> I forgot why it's big, but it sure is.
18:46:07 <monochrom> Of course it's all relative. First-world citizens tend to say "come on my phone is 1000 times bigger than that".
18:47:11 <darbaga> When you're on a 100k/s connection, it sure is painful ;p
18:47:23 <geekosaur> "kids these days" :p
18:47:29 <glguy> Everything is painful on such a connection these days
18:49:27 <glguy> Rust is a 82MB download compressed expanding to 342MB, JDK is 223.21 MB compressed (both on macOS)
18:49:33 <glguy> GHC seems like it's in the right ballpark
18:50:25 <monochrom> hugs trumps all of the above plus the cabal hell problem :)
18:50:30 <systemfault> Compiler toolchains are big...
18:52:25 <darbaga> hm nod i am not blaming ghc, i'm just curious why it's so big. Compiled libraries? something else?
18:52:53 <monochrom> Part of GHC's bigness is duplication. You have a *.a file and then a *.so file, containing pretty much the same code twice.
18:53:05 <glguy> and then the profiling version for third
18:53:11 <monochrom> oh yeah
18:53:14 <darbaga> Ah nod
18:53:16 <lordcirth> How big was the first C compiler?  Not finding it easily
18:53:28 <monochrom> But it still doesn't make sense.
18:53:28 <hpc> and then the actual executable which statically links it all togehter
18:53:39 <lordcirth> It must have been less than 3MB, since I think that's the HDD size it was written on
18:53:59 <glguy> and then all the inlined source code in the interface files to help with optimization via cross module inlining
18:54:31 <hpc> the first lisp interpreter was a room full of grad students
18:54:31 <monochrom> Here is why: Haskell Platform is only 10%-20% bigger than GHC. This means even after adding a ton of libraries, you only get 20% bigger, not 200% bigger. This suggests that the compiler itself takes the lion share.
18:55:15 <monochrom> haha hpc
18:55:27 <monochrom> @remember hpc the first lisp interpreter was a room full of grad students
18:55:27 <lambdabot> Okay.
18:55:49 <hpc> ghc does an awful lot of things
18:56:25 <hpc> parser, code generator (its own and hooking into llvm), rts with its own allocation, concurrency
18:56:29 <hpc> debugger
18:56:30 <hpc> ghci
18:56:33 <hpc> bytecode generator
18:56:40 <darbaga> Oh...nod
18:56:57 <hpc> and language extensions
18:57:17 <hpc> and it has the word "glorious" in its name
18:57:25 <hpc> that's gotta count for at least a few of those bytes
18:57:29 <monochrom> True. You know what? If it takes half an hour to build GHC, it's got to be big.
18:57:58 <hpc> and it optimizes
18:58:20 <hpc> and it's actually like 8 different code generators because of the multiple stages of compilation
18:58:24 <hpc> some of which have their own type checker too
18:58:30 <hpc> oh yeah, also a type checker
18:58:30 <lordcirth> https://www.bell-labs.com/usr/dmr/www/primevalC.html looks like an early C compiler was about 40kb of source!!
18:58:47 <darbaga> ..Wow, ghc is really really big
18:59:19 <hpc> it's a contender for the most advanced compiler ever written, imo
18:59:59 <hpc> the jvm might have a leg up on some garbage collection techniques, and DT languages have it beat on static expressiveness
19:00:47 <johnw> darbaga: big compared to what?  Have you seen llvm+clang?
19:02:36 <hpc> fwiw too, gcc's hello world compiles to something nuts like half a megabyte
19:03:12 <darbaga> Shrug this wasn't aimed at ghc in particular (i didn't clarify that, sorry), just compilers in general. But compilers do a lot, so i can see why they're big ;)
19:03:29 <hpc> heh
19:03:47 <darbaga> Wait, gcc? hello world? half a meg? I sincerely hope you can drop that size with esotaric flags or something?
19:04:05 <johnw> --esoteric
19:04:19 <darbaga> Oh
19:04:23 <darbaga> nod
19:04:49 <systemfault> Perhaps with -O99 in addition to --esoteric
19:05:09 <hpc> --mona-lisa-compression
19:06:03 <johnw> -O99 sends your program to lab filled with gov't researchers who are paid to beat the laws of information density; until the day we find out they've been gaming the results to keep their funding
19:06:09 <hpc> (hmm, can't find it, there's a joke about a perfect compression algorithm for a test case that's the mona lisa)
19:06:20 <darbaga> English is my third language, so sometimes I can't spell correctly, but i'm working on it.
19:06:33 <hpc> (if the only byte is 0, it decompresses to the mona lisa reference, if the first byte is anything else it gets dropped and the rest returned as is)
19:06:51 <johnw> hpc: haha
19:09:19 <monochrom> hpc: I almost thought you were on to a Dan Brown thing :)
19:17:03 <Wizek> > let f (length -> b)@(last -> c) = (b, c) in f "DummyText" -- Anyone knows if/how `@` sign (maybe called parameter synonym?) can be made to work together with the -XViewPatterns extension?
19:17:06 <lambdabot>  <hint>:1:20: error: parse error on input ‘@’
19:18:26 <glguy> Wizek: the "as-pattern" doesn't work like you're getting
19:18:39 <glguy> You get to write a variable on the left side of the @
19:18:50 <glguy> like you're guessing*
19:19:03 <glguy> variable @ pattern
19:20:08 <Wizek> glguy, yes, I do use it in that way occasionally. Although I do wonder how to use multiple ViewPatterns together -- if not with 'as-pattern's
19:21:05 <Zemyla> I'm having problems with idempotence. Is there some kind of injection I can take for that?
19:21:09 <Zemyla> Or maybe even a bijection?
19:21:30 <Wizek> > let f ((,) <$> length <*> last -> (b, c)) = (b, c) in f "DummyText" -- e.g., is this the 'only' way, glguy?
19:21:32 <lambdabot>  (9,'t')
19:21:42 <MarcelineVQ> it's so weird, doing the work on the pattern side. foo ((length &&& last) -> b) = b
19:26:03 <dramforever> Perhaps you should try pattern guards?
19:26:20 <monochrom> Use pattern guards to inflict two patterns simultaneously.
19:26:39 <monochrom> > let {f xs | 0 <- length xs, [] <- reverse xs = ()} in f []
19:26:41 <lambdabot>  ()
19:27:35 <monochrom> We are members of the Secret Society for Low-Tech Solutions
19:28:20 <dramforever> Wizek: A pattern guard should fit in nicely
19:28:37 <glguy> A where or a let found fit even more nicely
19:28:41 <glguy> would*
19:28:46 <ludat_> is someone using the haskell image from dockerhub, I'm getting `/app/.stack-work/downloaded/iebvxEEk7yIO/: getDirectoryContents: does not exist (No such file or directory)`. Has anyone seen something like this?
19:29:00 <dramforever> glguy: What if b and c are not variables but actually patterns?
19:29:27 <dramforever> If they don't match I'd want it to fall into the next 'branch'
19:30:32 <ertes> alternatively take two parameters as singleton types and an equality witness, pattern-match on the witness to get type refinement, recover the values of the singletons and use view patterns on those
19:31:00 <ertes> add some reflection, vinyl and an arbitrary language extension for good measure
19:32:38 <polll> Is there a way to install network 2.6.3.1 on Windows without installing cygwin/additional programs? (In the context of trying to install wai & warp through cabal)
19:32:40 <glguy> dramforever: The length can be checked with a guard: f x | length x == something
19:32:47 <glguy> same for the predicate on last
19:33:44 <dramforever> sounds okay
19:52:46 <johnw> on a 64-bit Intel machine, can I unsafeCoerce a Ptr Word to/from an Int?
19:53:05 <acowley> I'd expect so
19:53:17 <johnw> well, I'll see what happens
19:59:48 <codygman_> any idea why this returns 1 rather than 1! : echo 1 | ghc -e 'System.IO.interact (\s -> s ++ "!")'
20:02:11 <monochrom> johnw: In fact GHC conspires to have Int# = signed machine word, 32-bit in 32-bit GHC, 64-bit in 64-bit GHC.
20:03:15 <acowley> codygman_: I think you're getting a newline character at the end of s
20:03:50 <acowley> codygman_: Try (\s -> take 1 s ++ "!")
20:04:33 <codygman_> acowley: you are right. That was driving me up a wall! Thanks
20:07:06 <monochrom> IIRC there is "echo -ne" to omit the newline
20:07:26 <dramforever> -n is omit newline
20:08:09 <monochrom> Ah right, -e is about escapes.
20:10:28 <Maxdamantus> evaluate escapes.
20:20:13 <eklavya> I am following https://github.com/algas/haskell-servant-cookbook/blob/master/doc/Logger.md
20:20:23 <eklavya> and I am able to log the requests
20:20:37 <eklavya> but I am not able to figure out how to log request body
20:20:49 <eklavya> can someone please help?
20:25:44 <qmmm> glguy: round 2?
20:29:19 <qmm> in case you ignore nick changes, it was changed
20:30:11 <Axman6> eklavya: why do you want to log the request body? that's usually a good way to fill up disks very quickly
20:30:33 <eklavya> Axman6: only in dev
20:31:11 <Axman6> there's a wai middleware for logging all requests, and It has a few options for the format, can't remember if that includes the body though
20:31:19 <eklavya> Axman6: just want a way to quickly see, what's actually received
20:31:29 <Axman6> that's how I do all my request logging with servant though
20:31:47 <eklavya> Axman6: yeah I just figured out it's all wai
20:32:04 <eklavya> checking if I can supply my own ApacheLogger
20:32:11 <Axman6> oh, hmm, that's what the thing you linked to is using, sorry :)
20:32:47 <Axman6> so the thing is, the request body might be something that gets streamed in, and it still needs to be available to the application too
20:33:10 <Axman6> can you not just add a RequestBody ByteString to the endpoints you care about in Servant?
20:34:13 <eklavya> Axman6: I am sorry I didn't understand, what do you mean by "it still needs to be available to the application too", will logging prevent this?
20:34:50 <eklavya> plus apachelogger seems like a one time thing for all APIs
20:34:55 <Axman6> well, if it's a streaming post request for example, then somehow that needs to be available to the Application and the logging, it's hard to stream to two places at once
20:35:33 <eklavya> got it
20:35:39 <eklavya> no it's not streaming
20:35:44 <eklavya> simple json requests
20:35:52 <Axman6> you don't necessarilly know that
20:35:52 <eklavya> nothing heavy
20:36:02 <Axman6> but it should be ok by the sounds of it
20:36:13 <Axman6> (more importantly, Wai doesn't know that)
20:36:23 <eklavya> it's so small I wouldn't imagine any streaming would happen :P
20:37:18 <eklavya> bbiab
20:40:56 * Miblo leaps into the air and slams lambdabot a 05thunderous HiFive1
20:43:26 <MarcelineVQ> @bot you have a fan
20:43:26 <lambdabot> :)
20:45:02 <Axman6> @bot how's the hand?
20:45:02 <lambdabot> :)
20:45:36 <Miblo> :D Just been introduced to me by his/her maker in the Handmade.Network IRC
20:47:22 <Miblo> @type map
20:47:24 <lambdabot> (a -> b) -> [a] -> [b]
21:13:52 <glguy> qmm: Hello
21:15:11 <qmm> glguy: hello!
21:15:46 <glguy> (I don't ignore nick changes; they fold into the status lines: https://imgur.com/a/jU7Lq )
21:16:04 <qmm> i ignore joins and parts, but i don't ignore nick changes
21:16:20 <qmm> good to know though
21:17:50 <glguy> We were talking about how the function arrows are how we knew when we could apply one thing to another, and what we'd get back
21:18:00 <qmm> pretty irc configuration
21:18:12 <glguy> thanks
21:19:55 <glguy> and to replay a bit, if I have 'ord :: Char -> Int', can I apply ord to True?
21:20:39 <qmm> no
21:20:42 <glguy> and why
21:20:52 <qmm> first param is a Char
21:21:10 <glguy> and True has type Bool, ok
21:21:18 <qmm> correct :)
21:21:46 <glguy> given 'plus :: Int -> Int -> Int' what is the type of applying plus to 42?
21:23:06 <qmm> it's a partially applied function, one more param is needed for the function to output an Int
21:23:41 <glguy> OK but forget about partial application, functions really just have one argument
21:23:57 <glguy> Int -> Int -> Int  is    Int -> (Int -> Int)
21:24:09 <qmm> (+) 42 
21:24:16 <glguy> we just get to drop the parentheses out of convenience
21:24:21 <qmm> plus is just an alians for (+)
21:24:24 <glguy> sure
21:24:32 <qmm> given plus is just an alias for (+)
21:24:45 <qmm> oh
21:24:56 <qmm> understood
21:25:08 <glguy> OK, so plus applied to 42 has type?
21:25:56 <glguy> argument -> result
21:26:00 <qmm> Int -> Int
21:26:03 <glguy> Right
21:26:18 <glguy> When we see the -> , we know we can apply something once
21:26:27 <qmm> Int -> Int because it needs one more argument to return an Int
21:26:27 <glguy> if we get an arrow back as a result we can apply it again
21:26:56 <glguy> OK, so this deal with the arrows translates to types, too
21:27:11 <glguy> values like plus and 42 have types, types like Maybe and Int have kinds
21:27:32 <glguy> When we see a type with a function kind, we know we can apply it to an argument of the matching kind
21:27:36 <glguy> and we know what kind we'll get back
21:27:53 <glguy> So what kind does Maybe have?
21:28:35 <qmm> Maybe is * -> *
21:28:51 <glguy> What kind does this have: 'Maybe Maybe' ?
21:29:05 <qmm> *
21:29:08 <qmm> hmmm
21:29:10 <qmm> trickery
21:29:20 <glguy> right trick question, it's not *
21:29:30 <glguy> what's the trick?
21:29:31 <qmm> that would fail, correct?
21:29:38 <glguy> correct, it's a *kind error*
21:29:41 <qmm> the second maybe isn't applied to anything
21:29:54 <glguy> right, so since it's not we get a mismatch
21:30:01 <glguy> Maybe expected a * kinded argument
21:30:07 <glguy> but we gave it a * -> * kinded argument
21:30:08 <qmm> i don't think "applied" is correct, but thanks for nodding
21:30:32 <glguy> I interpreted what you said to mean, "We should have applied it as follows: Maybe (Maybe something)
21:30:39 <qmm> correct
21:30:49 <glguy> yeah, so I think you were just correct
21:30:58 <glguy> OK, so now what kind does Either hav?
21:31:18 <qmm> i actually fell asleep thinking about this last night
21:31:32 <qmm> also, i think i was dreaming about kinds yesterday
21:31:36 <glguy> ^_^
21:32:11 <qmm> well i cheated, ghci tells me * -> * -> *
21:32:32 <glguy> OK, what does a kind of * -> * -> * tell us?
21:32:45 <qmm> that's kind of why i looked it up
21:32:57 <qmm> i knew it took two params
21:33:10 <glguy> and what do we know about those params?
21:33:17 <qmm> i had a mental lapse and couldn't think of the return type
21:33:57 <qmm> they can be of two different types or the same type
21:34:02 <glguy> You mean you couldn't think of the return *kind*? :)
21:34:17 <glguy> So can I write: Either Maybe Maybe   ?
21:34:31 <qmm> strangely, i did look up the kind first, but i was really wanting to do :info Either
21:34:49 <qmm> no you cannot
21:34:59 <qmm> brb, fetching power cord
21:35:00 <glguy> pfft :)
21:35:07 <glguy> (regarding the no, not the brb)
21:36:11 <qmm> ooooh you can :)
21:36:15 <qmm> that makes sense
21:36:25 <qmm> Either (Maybe foo) (Maybe bar)
21:36:35 <glguy> Right, we need to get a type with kind *
21:36:39 <glguy> but what I'd written wasn't that
21:36:50 <glguy> can I write: Either Int ?
21:37:06 <qmm> that doesn't seem right, you need two params
21:37:28 <glguy> the function types are the same as the function values, they all take exactly one argument
21:37:49 <glguy> but they might return a function type / kind as a result
21:37:55 <glguy> Either :: * -> (* -> *)
21:38:07 <glguy> and Int :: *
21:38:19 <glguy> So if I apply Either to Int, I get: ?
21:39:19 <qmm> oh, * -> *
21:39:25 <glguy> Right
21:39:36 <glguy> Now there are NO VALUES of this type
21:39:48 <glguy> Only types with kind * have values
21:40:07 <glguy> but it's still a type that we can name
21:40:26 <glguy> If I apply this (Either Int) type to Char, what kind will it have?
21:41:49 <qmm> *
21:42:06 <glguy> and we get the type (Either Int Char). this type can have values because it has kind *
21:42:14 <glguy> for example:   Left 42   and   Right '!'
21:42:41 <glguy> When we only had (Either Int), that doesn't mean that it has values like Left 42
21:42:59 <glguy> It just has no values, it must be applied to another type first
21:43:20 <glguy> If you wrote:  awesome :: Either Int; awesome = Left 42
21:43:44 <glguy> You'd just get a kind error. The compiler knows that for a value like awesome to have a type, that type must have kind *
21:44:15 <glguy> OK but let's find a way to productively use this Either Int type
21:44:24 <glguy> :t fmap
21:44:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:44:47 <glguy> It's not written, but we can work out the kinds of these variables a, b, and f
21:45:18 <glguy> functions take value arguments and produce value results
21:45:24 <glguy> so since a and b are used in (a -> b)
21:45:31 <glguy> we know that a and b have kind *
21:45:57 <glguy> Does it make sense why a and b are types with kind *?
21:46:52 <qmm> i think so
21:47:08 <glguy> OK, using this logic, what kind must (f a) and (f b) have?
21:47:47 <qmm> both should have type *
21:47:50 <qmm> er, kind *
21:47:54 <glguy> Right
21:48:06 <glguy> OK, now the big test, what kind does  f  have
21:48:48 <dramforever> Is this an existential antipattern or easy-to-use API? http://hackage.haskell.org/package/escape-artist-1.1.0/docs/Text-EscapeArtist.html
21:49:08 <dramforever> The use of existentials feels 'wrong' to me, the author doesn't think so, blah blah
21:49:19 <dramforever> What's the best way to do this?
21:49:39 <qmm> f is a function, it has to return a value, i'm pretty sure its *
21:49:49 <qmm> glguy^
21:49:56 <dramforever> qmm: f is not a function
21:50:21 <qmm> dramforever: ok
21:50:22 <glguy> qmm: Yes, f has a function arrow in its kind
21:50:39 <glguy> we're applying it to a and to b
21:50:43 <glguy> so it can't just have kind *
21:51:17 <qmm> oh, that makes sense
21:51:24 <qmm> it isn't applied yet
21:51:46 <glguy> yes, the type 'f' hasn't been applied yet, but we know the kind of its arguments and the kind of its result
21:51:47 <qmm> but we saw in increment that its kind was *
21:52:00 <dramforever> 'increment'?
21:52:02 <qmm> increment x = x + 1 -- has kind * right?
21:52:07 <glguy> no, it doesn't have a kind
21:52:21 <qmm> i'll reread that log
21:52:22 <dramforever> values have types, types have kinds
21:53:00 <glguy> OK, so we know that f is a type that can be applied to types with kind * and that if we do that we'll get a type with kind *
21:53:08 <dramforever> (values here have types but suddenly :: types go here and types have kinds)
21:53:37 <qmm> Int -> Int :: *
21:53:45 <dramforever> Yes
21:53:55 <dramforever> :k Int -> Int
21:53:57 <lambdabot> *
21:54:28 <glguy> qmm: Yes, incrememnt has type Int -> Int, and Int -> Int has kind *, but increment does not thus have kind *
21:54:50 <qmm> okay
21:55:24 <glguy> increment was a function that could be applied to values with type Int, and when applied to such values returned a value of type Int
21:55:25 <qmm> glguy: what you said makes sense: we know that f is a type that can be applied to types with kind * and that if we do that we'll get a type with kind *
21:55:34 <glguy> yes, but we didn't do that yet
21:55:39 <glguy> so what kind does f on its own have?
21:55:43 <qmm> * -> *
21:55:46 <glguy> right
21:55:51 <glguy> OK and what kind did Either Int have?
21:56:08 <qmm> * -> *
21:56:20 <glguy> OK, so Either Int would be an acceptable choice for f
21:56:32 <glguy> fmap :: (a -> b) -> Either Int a -> Either Int b
21:56:42 <glguy> fmap :: (a -> b) -> (Either Int) a -> (Either Int) b
21:56:48 <glguy> fmap :: (a -> b) -> f a -> f b
21:58:14 <glguy> yesterday you were asking about a type like: (,) Int
21:58:25 <qmm> both Either and (,) e are Traversables 
21:58:40 <glguy> Only types with kind * -> * can be traversable
21:58:54 <qmm> from ghci
21:58:55 <qmm> instance Traversable (Either a) -- Defined in ‘Data.Traversable’
21:58:56 <qmm> instance Traversable ((,) a) -- Defined in ‘Data.Traversable’
21:59:10 <glguy> Right, it's important that it's the type: Either a, rather than Either
21:59:21 <qmm> :D
21:59:26 <qmm> nice catch
21:59:49 <qmm> ya know, that thing you've been saying for 10 mins
22:00:00 <qmm> i feel terrible
22:00:04 <qmm> okay
22:00:26 <dramforever> Don't worry it's normal for Haskell learners
22:00:36 <glguy> There are no values of these types like (,)e  and  Either a
22:00:47 <glguy> they'll still need to be further applied to other types
22:00:53 <glguy> like we saw in fmap
22:00:55 <glguy> :t traverse
22:00:57 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:01:02 <glguy> or like you brought up with Traversable
22:01:27 <qmm> neat
22:01:28 <glguy> But they are still useful to talk about because we can write definitions that make sense no matter what type you applied them to
22:01:32 <glguy> :t map
22:01:34 <lambdabot> (a -> b) -> [a] -> [b]
22:01:36 <qmm> so (,) e has kind * -> *
22:01:43 <glguy> yes
22:02:19 <ertes> it is helpful to see why something is valid by also looking at things that are invalid
22:02:27 <qmm> it's a partially applied tuple, if only i knew a better way to say "partially applied" 
22:02:39 <dramforever> It *is* a partially applied tuple
22:02:41 <qmm> ertes: yeah, thanks for the help last night
22:04:45 <qmm> "half contstructed tuple" i like that better
22:05:19 <dramforever> half constructed tuple *type* :)
22:05:24 <qmm> i think my original question was what is a half constructed tuple typically used for and where can i read more on it?
22:05:43 <qmm> glguy: and then you've been *really* patient in helping me to understand kinds 
22:06:12 <glguy> You can't do much of anything with a "half constructed tuple type"
22:06:17 <glguy> You can finish constructing it
22:06:24 <qmm> glguy: in order to understand how the half constructed tuple type* is used, i suspect
22:06:29 <dramforever> qmm: :i (,) in GHCi shows quite a bit of information
22:06:36 <dramforever> i.e. the instances
22:06:57 <ertes> remember: it's the *type* that is half constructed…  only fully constructed types (i.e. types of kind *) can have values
22:09:00 <ertes> qmm: exercise: why are there no values of type Maybe?
22:11:42 <qmm> because it's half constructed :)
22:12:06 <ertes> qmm: i don't know what that means…  answer in terms of kinds
22:12:44 <qmm> Maybe has kind * -> *, you mentioned only fully constructed types have kind of *
22:13:26 <ertes> qmm: go on
22:14:32 <qmm> all values of should have kind *, right?
22:14:36 <qmm> s/of//
22:14:46 <ertes> qmm: why is that a non-sensical statement?
22:15:17 <qmm> no clue
22:15:35 <qmm> ah
22:15:42 <qmm> because Maybe can be a value
22:15:47 <ertes> nope
22:16:01 <qmm> Maybe 3 is a value
22:16:08 <qmm> Maybe is a type i suppose
22:16:19 <qmm> i suppose that is what i meant to say
22:16:33 <ertes> ok, side quest:  alice is claiming that (True :: *)…  bob is claiming that it's wrong…  carol is claiming that the statement itself is non-sense, so it's neither right nor wrong
22:16:35 <ertes> who is right?
22:16:37 <qmm> why do i put off learning haskell right before bedtime (terrible idea)
22:17:53 <qmm> alice's claim seems correct
22:18:10 <ertes> is True a value or a type?
22:18:24 <qmm> value
22:18:31 <ertes> do values have kinds?
22:19:07 <qmm> now i don't know
22:19:13 <qmm> i guess i never knew
22:19:27 <ertes> what did you think before i made you unsure?
22:19:32 <qmm> *
22:19:38 <qmm> i thought all values were *
22:19:58 <ertes> nope…  here is the correct version:  values are of types
22:20:02 <ertes> and those types are of kind *
22:20:12 <ertes> the values themselves don't have a kind
22:20:20 <ertes> True :: Bool
22:20:22 <ertes> Bool :: *
22:20:31 <qmm> True is type Bool and Bool is of kind *
22:20:36 <ertes> correct
22:20:47 <ertes> so who's the winner?  alice, bob or carol?
22:20:52 <qmm> the value True doesn't have a kind
22:21:01 <qmm> the value True has type Bool though and Bool has kind *
22:21:11 <qmm> better way of putting it, that's useful
22:21:47 <qmm> ertes
22:21:50 <qmm> i mean carol ;)
22:22:18 <ertes> =)
22:22:20 <ertes> correct
22:22:51 <qmm> thanks for the quest
22:22:58 <ertes> side quest completed…  now let's return to your statement: "all values should have kind *, right?"
22:23:01 <ertes> right?
22:23:05 <ertes> wrong?
22:23:08 <ertes> non-sense?
22:23:24 <qmm> ertes! (non-sense)
22:23:43 <ertes> there you go…  and now to the original exercise:  why are there no values of type Maybe?
22:25:04 <qmm> because no values have kinds?
22:25:30 <ertes> correct statement, but not the correct answer
22:26:07 <ertes> values do have types, and Maybe is a type…  yet there are no values of type Maybe…  why?
22:28:18 <roboguy`> qmm: one (mostly) correct thing is that the only types of kind * have values
22:29:22 <qmm> ertes: i'm stumped unfortunately
22:29:55 <ertes> qmm: read what roboguy` just spoi… wrote =)
22:30:06 <roboguy`> oops, sorry :)
22:30:26 <dramforever> (x :: y), y is a type, and it must have kind * [1]
22:30:49 <dramforever> ([1]: There are 'unusual' things there. Period. Let's not talk about this)
22:31:40 <roboguy`> Yeah, the exception to the rule isn't super relevant to understanding the idea and its also a bit involved these days...
22:31:41 <dramforever> The only passage from values to types is this 'is of type' notation val :: ty
22:31:49 <qmm> dramforever: what's weird, i'll talk about it in #haskell-in-depth :)
22:31:50 <dramforever> roboguy`: stop
22:31:54 <roboguy`> ha, ok
22:31:57 <dramforever> stop
22:32:00 <roboguy`> ok
22:32:04 * dramforever shouldn't have done that
22:32:23 <qmm> the entire statement is kind of weird looking to me (x :: y), y
22:32:28 <qmm> i'll ask later
22:32:40 <dramforever> oh no no
22:32:45 <dramforever> x :: y
22:32:53 <dramforever> and the rest is an English sentence
22:33:00 <dramforever> 'y' is a type
22:33:03 <qmm> oh
22:33:04 <dramforever> 'y' has kind *
22:33:16 <ertes> qmm: ok, let's dissect the exercise: what's the kind of Maybe?
22:33:24 <qmm> * -> *
22:33:40 <ertes> qmm: do you see why Maybe can't be inhabited by values?
22:34:25 <qmm> no
22:34:37 <ertes> qmm: only types of kind * can be inhabited
22:34:46 <dramforever> qmm: Can you give such a value?
22:34:52 <ertes> qmm: so why can't Maybe be inhabited?
22:35:46 <qmm> oh i see
22:36:06 <qmm> only types of kind * can be inhabited but Maybe is of kind * -> * -- i feel silly
22:36:06 <dramforever> qmm: Do you know C++?
22:36:20 <qmm> dramforever: i've used it in the past
22:36:24 <ertes> qmm: and more importantly it's *not* of kind *
22:36:42 <dramforever> qmm: Why doesn't 'std::vector v;' make sense?
22:37:17 <dramforever> That's an 'invalid use of template-name 'std::vector' without an argument list', according to g++
22:37:46 <dramforever> And Maybe has this kind: * -> *
22:37:59 <dramforever> See how it's missing something akin to an 'argument list'?
22:38:27 <ertes> qmm: new exercise: the type (,) is inhabited…  correct or incorrect?
22:39:44 <lisper22> greetings, I am trying to use the 'Parsec' library. It was recommended I use stack so I ran 'stack install parsec' which seemed to install something but 'import Text.ParserCombinators.Parsec' does not seemed to find anything. Does anyone know what I am doing wrong?
22:40:14 <kadoban> lisper22: Do you have a .cabal file for your project?
22:40:20 <dramforever> How are you using 'import Text.ParsecCombinators.Parsec'?
22:40:58 <dramforever> How's 'stack repl --package parsec'?
22:41:45 <qmm> dramforever: i guess, it's been too long i guess
22:41:47 <systemfault> dramforever std::vector has kind       * -> *   ;)
22:41:49 <qmm> ertes: incorrect
22:41:55 <ertes> qmm: why?
22:42:10 <qmm> only types of kind * can be inhabited but (,) is of kind * -> *
22:42:14 <qmm> well...
22:42:15 <qmm> no
22:42:21 <qmm> it's of kind * -> * -> * i bet
22:42:27 <qmm> since it takes 2 params
22:42:30 <ertes> correct
22:42:38 <dramforever> systemfault: it has kind 'template<typename> class' :P
22:42:50 <ertes> qmm: the type (Int -> Bool) is inhabited…  correct, incorrect or non-sense?
22:43:45 <qmm> nonsense i suppose since it isn't applied yet
22:43:52 <qmm> it has * -> * currently
22:43:56 <ertes> does it?
22:44:17 <ertes> :k Int -> Bool  -- let's see
22:44:18 <dramforever> What's 'Int -> Bool' in English?
22:44:19 <lambdabot> *
22:44:36 <lisper22> I am new to Haskell and am following the 'Write Yourself a Scheme in 48 Hours' tutorial. I don't have a .cabal file.
22:44:39 <dibblego> (,) takes on parameter, like every haskell function
22:44:41 <ertes> qmm: lambdabot disagrees =)
22:44:43 <dibblego> *one
22:44:50 <geekosaur> lisper22, you need one if you are using stack
22:45:04 <geekosaur> otherwise it will not expose packages to your sandbox and all you will have is the packages that come with the compiler
22:45:16 <kadoban> lisper22: In what context are you trying to import that module? Do you have a .hs file, or?
22:45:30 <lisper22> yes, I am using a .hs file
22:45:47 <dramforever> lisper22: Does 'stack repl --package parsec' run?
22:46:21 <kadoban> The best way is probably to start with a .cabal file, in which you put dependencies like 'parsec' in the correct place. A decent way to start is  'stack new someproject' which will create a template you can mess with
22:47:55 <kadoban> Another option is to use a specially formatted comment at the start of the .hs file, like https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter in which you list the packages you depend on
22:48:17 <lisper22> yes 'stack repl --package parsec' produces some output and drops me in the repl
22:48:21 <qmm> ertes: i guess i have a lot to reread and think about
22:48:27 <qmm> it's past my bedtime
22:48:48 <qmm> i think when i was talking to glguy i was mistaking the f for a function instead of thinking it was a functor
22:49:43 <qmm> the function type that has * -> * ... maybe that's part of the confusion
22:49:44 <ertes> qmm: yeah, you should probably get some sleep, but don't count sheep tonight…  instead repeat to yourself the following sentence over and over: "it's a purely symbolic game"
22:50:06 <ertes> (Int -> Bool :: *)  -- it's a concrete type…  the type of functions from Int to Bool
22:51:04 <qmm> tomorrow, i'll come back to this way before bedtime :)
22:51:09 <ertes> a *value* of that type (which is a function) takes an argument, but the type itself doesn't
22:51:28 <lisper22> ok, thanks! I will run 'stack new' and will look into configuring the .cabal file
22:51:46 <dramforever> lisper22: ok, as a 'quick' fix, everywhere you see 'ghc', use 'stack ghc --package acid-state --'
22:51:51 <dramforever> Uh, sorry
22:51:57 <dramforever> stack ghc --package parsec --
22:52:16 <dramforever> Everywhere you see 'ghci', use 'stack ghc --package parsec -- --interactive'
22:52:52 <qmm> ertes, glguy: thanks again for your patience and willigness to teach. i won't forget it 
22:53:01 <qmm> willingness
22:53:30 <ertes> i'm super-willig
22:54:22 <lisper22> dramforever: thanks for the tip. I will try this method as well
22:55:42 <dramforever> The 'stack new' is the way to go if you want to create a 'proper' Haskell project
23:33:26 <begriffs> Does anyone know if this package is still maintained? https://github.com/hvr/cassava The pull requests are piling up and nobody has answered my own issue for months.
23:34:52 <monochrom> Yikes. Make a post on haskell-cafe.
23:49:14 <begriffs> monochrom: good idea, will do.
23:49:31 <quchen> Hm, Herbert is still active
23:49:46 <quchen> So there technically is a maintainer that still does Haskell.
23:51:26 <begriffs> Yeah actually I see there is a commit on Jan 2. But major work seems to have stopped since April.
23:53:37 <quchen> Herbert only has so many hands to write code with
23:55:25 <saurabhnanda> anyone familiar with STM? Need some help with https://gist.github.com/saurabhnanda/3cc39f1e0a646254dd8819b01cd04ac3
23:55:50 <saurabhnanda> Especially this line -- createChan = atomically newBroadcastTChan -- is it alright to "escape" the STM monad in this way?
23:56:22 <quchen> Sure
23:56:49 <EvanR> thats not really escaping it
23:57:09 <quchen> It’s even advantageous to create small transactions and not big ones
23:58:41 <EvanR> and that one can never retry
23:59:18 <EvanR> newBroadcastTChanIO is another way to do that
23:59:30 <saurabhnanda> why is `newBroadcastTChan` result wrapped in `STM` monad?
23:59:57 <quchen> STM is a type, this has nothing to do with monads.
23:59:59 <EvanR> so you can compose actions that create channels with other actions
