00:07:34 <haskell002> if I have a type level list l =  Proxy :: Proxy ('[Bool]), so l is of kind [*], is there a way to get a typeRep for each of the entries ?
00:12:46 <haskell002> ok I can just type level map, then call typeRep :)
00:19:14 <jle`> haskell002: l still has kind *
00:19:34 <jle`> :k Proxy
00:19:35 <lambdabot> k -> *
00:20:49 <fragamus> Hi I need some advice
00:21:27 <fragamus> I have a program that needs to read a big file before it can do anything usedful, and
00:22:06 <fragamus> I am thinking of having it support some sort of message protocol 
00:23:03 <fragamus> requests are a line of text and responses are also a line of text
00:23:26 <fragamus> whats the simplest approach 
00:44:38 <EvanR> https://en.wikipedia.org/wiki/Effective_results_in_number_theory
01:08:16 <Micamo> Hey, does the pl command still work
01:08:28 <cocreature> @pl \x -> x
01:08:28 <lambdabot> id
01:08:35 <cocreature> Micamo: does that answer your question? :)
01:08:54 <Micamo> @pl \f g x (a,b) -> (f x a b, g x a b)
01:08:55 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . liftM2 (liftM2 (liftM2 (,)))
01:09:38 <Micamo> @pl \x a b -> (x, b) : a
01:09:38 <lambdabot> flip . ((:) .) . (,)
01:09:51 <Micamo> huh, i've been working at both of these all night
01:10:05 <Micamo> I'd never have figured out the first one on my own but the second was rather simple
01:10:43 <cocreature> we should rename @pl to @makemycodeunreadable
01:15:10 <bakibour> hidiho
01:16:16 <bakibour> I was just wondering if there is an eDSL written in Haskell for platforms like the gameboy. https://www.youtube.com/watch?v=CImyDBJSTsQ
01:16:45 <bakibour> Since the input is mapped to memory directly also you should be completely side effect free even with IO right?
01:18:07 <bakibour> Even output to the screen is memory mapped.
01:21:41 <EvanR> bakibour: a DSL which compiles to gameboy bytecode literally?
01:21:55 <EvanR> or to be used for gameboy like games on the PC
01:21:56 <bakibour> Byte code or intermediate C
01:22:23 <bakibour> No no i mean for that hardwere specifically, since everything even IO an be done side effect free.
01:22:55 <EvanR> yes DSLs like that dont do any IO as an effect, theres a few like that
01:23:01 <EvanR> also IO itself is such a DSL
01:23:27 <EvanR> i dont know of any that target gameboy specifically
01:24:03 <bakibour> Might be fun to get some fp on a console platform of that scale.
01:24:45 <EvanR> if you want to use the full power of haskell in the embedded program, thats going to be a research project
01:25:17 <EvanR> realistically you would probably reduce the scope of what you can do inside the DSL
01:25:48 <merijn> Depends on how stubborn you are :)
01:25:56 <EvanR> first thing, so you dont need memory management since theres almost none of a gameboy, second thing closures are pretty much a no
01:26:12 <merijn> EvanR: Why are closures a no?
01:26:23 <bakibour> I of course want C in the end.
01:26:33 <bakibour> I would not like to run Haskell directly on the GB
01:27:09 <merijn> bakibour: At this point we're basically talking "implementing a compiler", whether it's via a DSL or an actual compiler with a parser :)
01:27:19 <bakibour> Yep
01:27:43 <bakibour> Is Haskell big in embedded systems?
01:27:52 <merijn> Which, to be clear, is not something I'm saying not to do. In fact, I wholly recommend writing compilers, just be aware of the entire scope of things :)
01:28:14 <bakibour> Sure i do not intend to do it anyway, im just sporting the idea in general.
01:28:18 <merijn> bakibour: Not really, GHC isn't really designed for embedded systems and as such makes lots of assumptions that are...poor for that
01:28:34 <EvanR> merijn: closures might work if we limit the scope somehow
01:28:43 <bakibour> I dont want to run Haskell on the embedded system but use Haskell to generate the code.
01:28:44 <EvanR> so theres no memory management issues
01:28:48 <merijn> bakibour: But there are DSLs written in haskell for writing embedded/crypto code, and projects based on Haskel for bare metal
01:29:21 <bakibour> Thats what i am talking about, since you have so little memory etc it should be pretty cool to get a lot of the stuff into the type system.
01:29:49 <merijn> bakibour: Some projects that (may) be relevant to your interest: House (haskell on bare metal), HaLVM (haskell on Xen), Habit (an, afaict, defunct design for "strict haskell for systems programming" it has a 100 or so page design document that's interesting to read)
01:30:15 <merijn> bakibour: Ivory (a DSL for safe systems programming: http://ivorylang.org/ivory-introduction.html)
01:30:43 <EvanR> were gameboy programs really written in C ?
01:30:50 <EvanR> if not, i would not bother going through C
01:30:55 <merijn> EvanR: No, I think it had it's own assembler
01:31:01 <EvanR> yes Z80
01:31:04 <merijn> EvanR: GBA/DS might use C? Not sure
01:31:09 <EvanR> probably
01:31:26 <merijn> EvanR: FWIW, I don't see why you'd need to limit closures for things to work/
01:32:00 <EvanR> a full blown haskell-like functional language is going to put too much pressure on managing the 1K of ram or however much it had
01:32:07 <EvanR> its just not feasible
01:32:27 <merijn> EvanR: For the actual GB, maybe not, but closures aren't *that* expensive
01:32:32 <ahihi> it's got 8 whole kilobytes!
01:32:43 <EvanR> its just that they require allocating an object
01:33:08 <EvanR> of some sort, be it the environment, or a wrapper for the function pointer
01:34:56 <EvanR> i have this resurrected gameboy right here... i really wanted to do something with it
01:35:20 <bakibour> EvanR: :)
01:35:20 <ahihi> I use mine for music, but I would like to learn to write programs for it as well
01:35:30 <ahihi> just can't find the time
01:35:32 <bakibour> Check that 33c3 talk
01:35:43 <bakibour> 1h and you got all the cool stuff covered
01:36:34 <ahihi> ah nice
01:36:35 <ahihi> bookmarking
01:36:38 <bakibour> There is a whole series (the ultimate series) for different platforms, i hope they will have the SNES next year.
01:37:21 <EvanR> i thought the SNES sound chip was so bad ass... based on donkey kong country, but really, its just the sound designer was an insane genius
01:37:30 <EvanR> so many terribly sounding other games
01:37:39 <ahihi> it's entirely sample-based
01:37:54 <EvanR> well, i extracted the samples as best i could they sound terrible
01:37:56 <bakibour> I think that the SNES is the best console ever made.
01:37:59 <muzzle> hi, does anyone know when stackage nightly will switch to ghc 8.0.2?
01:38:27 <ahihi> but yeah David Wise is a legend
01:39:00 <bakibour> The name says it all ;)
01:41:36 <reactormonk> `readFile "foo"` runs the IO, but `try (readFile "foo")` doesn't - ideas?
01:41:54 <EvanR> readFile does "lazy IO"
01:42:05 <EvanR> which means it doesnt run the IO
01:42:06 <reactormonk> ... talking about ghci
01:42:33 <EvanR> try returns the answer wrapped in an Either
01:42:36 <reactormonk> Sorry. I get a compiler error on ghci on the second statement, no instance for Show
01:43:10 <EvanR> ... whats the entire error
01:44:11 <merijn> EvanR: Depends on which readFile, only 3 out of 5 common ones are lazy IO
01:44:25 <EvanR> 2 out of 5 aint bad
01:44:49 <reactormonk> https://gist.github.com/reactormonk/ad94720679972a196984982593cb7c11
01:44:50 <merijn> strict Text/BS have a strict readFile (because anything else would be silly)
01:45:21 <EvanR> interesting, ghci didnt want to execute that IO action
01:45:26 <merijn> reactormonk: You didn't specify which exception you wanted "try" to catch, so GHCi can't see if it's printable
01:45:52 <EvanR> ... but why would it be printing the IO action
01:45:54 <reactormonk> merijn, isn't that via tryJust?
01:45:55 <merijn> Try 'try (readFile "foo") :: IO (Either SomeException String)'
01:46:07 <merijn> :t Control.Exception.try
01:46:08 <lambdabot> Exception e => IO a -> IO (Either e a)
01:46:16 <reactormonk> merijn, also, Exception has a Show instance by default
01:46:18 <cocreature> muzzle: you can take a look at https://github.com/fpco/stackage/issues/2203. I don’t think there’s a date yet
01:47:23 <EvanR> "Becher and Figueira proved in 2002 that there is a computable absolutely normal number, however no digits of their number are known." o_O
01:47:26 <merijn> reactormonk: ghci prompt is a weird place, my first assumption when something that seems like it should work, doesn't, is that the prompt is wonky, not the code
01:48:09 <EvanR> maybe the algorithm is really slow
01:48:13 <merijn> reactormonk: Note that your error is saying that "IO" isn't printable, so it seems like it's not evaluating your action at all for some weird reason
01:50:29 <reactormonk> merijn, works if you tell it it's an IOException
01:57:12 <reactormonk> Which combinators would I use for [FilePath] -> Either IOException String via readFile and try?
01:57:40 <jmorris> how could i write a function that takes [a] -> [[a]] where [[a]] is all possible combinations of 3 elements from [a]?
01:59:09 <niklasb> jmorris: do you mean subsets, combinations or permutations? i.e. is 1,2 the same as 2,1? do you allow 1,2,2 etc
01:59:29 <reactormonk> Eh, it's [FilePath] -> IO (Either IOException String)
01:59:44 <jmorris> niklasb: don't repeat the same element but have all possible orders of 3
01:59:59 <niklasb> so, permutations
02:00:11 <cocreature> there is a "permutations" function in Data.List
02:00:24 <cocreature> > permutations [1,2,3]
02:00:31 <lambdabot>  mueval-core: Time limit exceeded
02:00:34 <EvanR> theres more than 3 things in the list though
02:00:42 <niklasb> jmorris: and if you want to figure it out yourself, maybe it helps to find a recurrence for the problem
02:00:57 <merijn> reactormonk: I'm not sure what you're asking?
02:01:07 <jmorris> yeah permutations is what i need, thanks
02:01:59 <merijn> reactormonk: Note that these are "just" unchecked exceptions like you're used to from other languages (presumably) and the only real caveat is "use throwIO, never throw". For example this code works fine:
02:02:57 <merijn> reactormonk: 'try $ do { content <- readFile "foo"; x <- doStuffWith content; return x }' with type 'IO (Either IOException a)' 'a' being whatever doStuffWith returns
02:03:35 <merijn> reactormonk: So just use readFile as any other IO action and only wrap with try/catch where you plan to actually handle any exceptions
02:03:36 <reactormonk> merijn, I want to try to load a specific file from multiple locations.
02:06:23 <reactormonk> So now I have [IO (Either IOException String)] and I would like the first that is Right
02:06:42 <niklasb> reactormonk: you can use iterate
02:06:48 <niklasb> sry sequence
02:07:00 <merijn> reactormonk: ok, so then you'd do something like: 
02:07:05 <lpaste> merijn pasted “No title” at http://lpaste.net/351293
02:07:18 <merijn> sequence is wrong
02:07:23 <merijn> sequence will fail is any of them fail
02:07:32 <tabaqui1> where can I place notes for hackage packets?
02:07:39 <tabaqui1> ByteString as a fact
02:07:51 <niklasb> merijn: well but he caught all the interesting exceptions already. although I agree that it's not ideal
02:08:06 <merijn> reactormonk: That's only a rough sketch of one way to do it
02:08:08 <niklasb> plus it would open stuff even after a file is found. so getting the list in the first place is fishi
02:08:10 <niklasb> *fishy
02:08:16 <merijn> reactormonk: You might want to limit which exceptions you catch, etc.
02:08:31 <tabaqui1> :t Data.ByteString.length
02:08:31 <merijn> oh, wait
02:08:33 <lambdabot> BSC.ByteString -> Int
02:08:38 <tabaqui1> :t Data.ByteString.Lazy.length
02:08:40 <lambdabot> BSLC.ByteString -> Int64
02:08:42 <tabaqui1> wtf?
02:08:49 <merijn> I used openFile which I meant to implement locally, but turns out readFile is enough for
02:08:55 <domenkozar> does someone have stack.yml compiler settings for GHC 8.0.2?
02:08:56 <merijn> reactormonk: So replace openFile with readFile
02:09:39 <reactormonk> merijn, I was hoping for some fancy function combinations :-)
02:10:44 <EvanR> what is Int64 doing there
02:11:03 <niklasb> maybe it's because BSL can potentially be longer? because it has multiple BS chunks?
02:11:27 <niklasb> (which are in turn limited in size by the word size). just a guess
02:11:37 <EvanR> yes lazy BS can be longer
02:11:44 <EvanR> infinite
02:12:13 <niklasb> I guess that's not the worrysome case for length ;)
02:12:13 <EvanR> this seems like a java-type decision
02:14:04 <niklasb> seems logical to me. BS.length x == MAX_INT-1 => BSL.length (BSL.fromChunks [x, x]) > MAX_INT on 32-bit
02:15:06 <niklasb> should be future-safe for at least 4 or 5 more yuears :P
02:15:41 <niklasb> until somebody builds a 4 exabyte bytestring
02:16:11 <tabaqui1> :t Data.Foldable.length
02:16:13 <lambdabot> Foldable t => t a -> Int
02:16:31 <tabaqui1> *well, strings aren't foldable, actually
02:16:44 <tabaqui1> but there are many length-alike functions, that return Int
02:16:53 <EvanR> yes its incongruous
02:17:00 <tabaqui1> and just BSL return Int64
02:18:13 <niklasb> text too
02:18:13 <EvanR> list concat returns something of length all its constituents added
02:18:35 <EvanR> is it not Int64 just because that would cause a contradiction that it be a bigger type than itself
02:19:16 <EvanR> which one will have more entries, a linked list or a lazy BS
02:20:04 <reactormonk> Is there a Either a b -> Either a b -> Either a b which gives me the first one that's Right?
02:20:41 <pavonia> (<|>)
02:20:41 <merijn> reactormonk: oh, maybe the MonadPlus instance of Either (assuming it has one)
02:21:30 <merijn> hmmm, doesn't look like Either is MonadPlus
02:22:05 <merijn> I suppose you could newtype it
02:22:38 <tabaqui1> pavonia: Either hasn't Alternative instance
02:22:48 <tabaqui1> and it is strange
02:22:53 <merijn> reactormonk: You could probably either 1) max a fancy combinator for it or 2) find some library that has one, but then you need to ask yourself whether the added dependency is worth avoiding like 3-4 lines of code to write it by hand :)
02:23:12 <reactormonk> merijn, already got ClassyPrelude, maybe it's in there?
02:23:22 <merijn> tabaqui1: I'm guessing because there's two valid MonadPlus possible?
02:26:52 <pavonia> I'm pretty sure I've used Either e as Alternative before, but I can't find the instance anywhere
02:27:52 <niklasb> pavonia: it would be weird because the monad/applicative instances have different semantics
02:28:19 <pavonia> Different from what?
02:28:57 <niklasb> oh nevermind, it would actually work
02:29:55 <cocreature> pavonia: there is an instance in Control.Monad.Trans.Error
02:31:27 <pavonia> Right, that was it
02:32:18 <cocreature> it’s a weird place for that instance
02:33:32 <merijn> cocreature: I don't think so
02:33:59 <cocreature> merijn: Either and Alternative are in base, so why would you make an orphan instance in transformers?
02:34:01 <merijn> Like I said, I think MonadPlus has 2 valid MonadPluses and the only way you can decide on that one is if you decide "Left == error", which is not universally true
02:34:16 <merijn> cocreature: Because who are you to say that is the right instance?
02:34:31 <merijn> Why not stop at the first Left?
02:35:35 <merijn> Actually, now that I think about it, there's probably at least 4 valid instances, rather than 2. The only way left-biased ending on the first right is the "right" instance if you canonicalise the meaning of "left == error"
02:35:49 <cocreature> merijn: I think transformers is too much of a core package for that argument. if the instance is in transformers, it might just as well be in base
02:36:07 <merijn> cocreature: I think the right way would be to add newtypes for Either in base
02:36:18 <merijn> That way we could also have Validation in base
02:36:40 <niklasb> cocreature: I think that module is about to be removed
02:37:25 <merijn> cocreature: Control.Monad.Trans.Error is deprecated and Control.Monad.Trans.Except (the replacement) does not have an instance for Either
02:37:55 <cocreature> fair enough
02:46:58 <reactormonk> hmm, figured I could also do it with a find. Doesn't accumulate errors, but should work.
03:17:53 <niklasb> Can I define an "atexit" handler for a forkIO'd thread? I want an IO action to be performed after the thread gets killed. I tried finally, but apparently if I SIGTERM the whole program, the handler is not run.
03:20:43 <quchen> niklasb: forkFinally
03:21:03 <quchen> Not sure what that does on sigterm either though
03:21:16 <niklasb> oh nice, I'll check that out
03:22:41 <cocreature> niklasb: you need to wait for the thread to terminate. otherwise your finalizers can get killed. once your main thread dies all other threads die immediately so your finalizers can be interrupted.
03:23:15 <niklasb> cocreature: so I need a finalizer for the main thread which waits for all the other threads?
03:23:31 <cocreature> niklasb: yep
03:23:32 <niklasb> *that terminates and waits
03:23:59 <cocreature> niklasb: or just something like "withAsync" instead of forkIO and let async handle this for you
03:24:04 <cocreature> *just use
03:24:20 <niklasb> ok cool
03:24:56 <cocreature> but you need a relatively recent version. previously async only guaranteed that your finalizer is called but it didn’t wait until it finishes
03:25:32 <niklasb> that seems like a pretty weak guarantee
03:25:44 <cocreature> that’s why it was changed :)
03:26:11 <niklasb> good to know. that's not a problem, I can use the newest version
03:26:35 <cocreature> according to the changelog the new behavior exists since 2.1.1
03:36:44 <quchen> Is it possible to have multiple modules of the same name inside transitive dependencies?
03:36:47 <quchen> Like this: http://lpaste.net/3989941415877541888
03:37:21 <quchen> It’s not possible for direct dependencies, because then the module is ambiguous. But what if it can be uniquely resolved in theory?
03:47:03 <edwardk> quchen you an have them even in direct dependencies using packageimports
03:47:21 <edwardk> but yes
03:47:36 <quchen> edwardk: Sure, but without packageimports?
03:48:06 <quchen> (In the transitive case)
03:48:08 <edwardk> without packageimports what you suggest works just fine
03:49:04 <reactormonk> Still wondering if there's a better way than find isRight <list of eithers> to get the first Right out
03:49:07 <quchen> Excellent! That means I can provide compatibility modules for the old wl-pprint libraries, and people can include those along with the originals in large projects
03:49:09 <edwardk> MonadCatchIO-transformers supplies instances for mtl and monads-tf -- nobody gives af about monads-tf but the imports it makes of those alternate Control.Monad.Reader modules and the like to get classes don't interfere with everyone who uses that package and also imports Control.Monad.Foo
03:50:08 <edwardk> that should serve as an example from the wild
03:50:58 <edwardk> reactormonk: preview (folded._Right)   using lens ;)
03:51:17 <reactormonk> edwardk, library? hmm
03:51:42 <edwardk> @hackage lens
03:51:42 <lambdabot> http://hackage.haskell.org/package/lens
03:51:51 <edwardk> bit overkill for your purposes, but hey
03:56:55 <merijn> reactormonk: listToMaybe . rights
03:57:04 <merijn> :t listToMaybe . rights
03:57:06 <lambdabot> [Either a1 a] -> Maybe a
03:58:37 <merijn> edwardk: I think mine is simpler and only uses base :p
04:01:27 <ski> edwardk : SYN
04:05:53 <dramforever> :t listToMaybe
04:05:59 <lambdabot> [a] -> Maybe a
04:06:13 <dramforever> Looks wrong
04:07:07 <merijn> drbean: Why?
04:07:13 <dramforever> reactormonk: Do you want one 'Right' or all 'Right's?
04:07:17 <merijn> eh, s/drbean/dramforever
04:07:26 <merijn> dramforever: He said "first Right"
04:08:03 <dramforever> oh!
04:08:11 <dramforever> It's good then.
04:08:31 <dramforever> Sorry it just happens every now and then...
04:10:42 <ski> @type sequence :: [Either a b] -> Either a [b]  -- with some mirroring ..
04:10:44 <lambdabot> [Either a b] -> Either a [b]
04:11:06 <merijn> ski: THat's the wrong thing
04:11:13 <merijn> ski: That fails if any value is Left
04:11:16 <ski> it picks the first `a'
04:11:29 <ski> (that's why i said "mirroring")
04:12:59 <reactormonk> Is there a Maybe a -> b -> Either a b ?
04:13:49 <merijn> reactormonk: I'm not quite sure why you're going through all this effort instead of using the fairly simple example I wrote?
04:14:27 <xnull> reactormonk: No, there isn't
04:14:42 <ski> @type flip ((`maybe` Left) . Right)
04:14:44 <lambdabot> Maybe a -> b -> Either a b
04:15:10 <reactormonk> merijn, learning to use combinators. And also possibly for the experience on when not to use them.
04:15:44 * ski would use `listToMaybe' or pattern-matching here, after using `rights' or a list comprehension to skip the `Left's
04:16:10 <reynir> Is it possible to configure it to print »[] (Either a b)« instead of »[Either a b]«?
04:16:50 * ski suspects not
04:17:16 <merijn> ski: He was iterating over different paths to find the first one that has a specific file, so I'd use a direct recursive loop instead
04:17:31 * ski nods
04:17:48 <reactormonk> merijn, after all that code, yeah, your solution looks better.
04:19:07 * ski . o O ( `data Vel s d = Sinister s | Dexter d' )
04:34:06 <reactormonk> Gives me `Not in scope: data constructor 'SomeException'`, but I'm importing it via `import ClassyPrelude (SomeException)` - huh?
04:34:37 <merijn> reactormonk: That's just the type, not the data constructor :)
04:35:19 <merijn> reactormonk: When importing datatypes you want "import Data.Blah (Foo(Bar))" to import the Foo type and it's Bar constructor or "import Data.Blah (Foo(..))" to import *all* Foo constructors
04:35:39 <merijn> reactormonk: Note that the error says "data constructor" :)
04:36:28 <reactormonk> merijn, good to know, I was wondering about that distrinction.
04:36:37 <reactormonk> Is there more than one data constructor per type? For ADTs?
04:37:09 <opqdonut> sum types
04:37:22 <opqdonut> e.g. "data Maybe a = Nothing | Just a"
04:37:31 <ski> data constructors are values, belongs to the value level
04:37:31 <opqdonut> Nothing and Just are two separate constructors
04:37:38 <ski> type constructors are types, belongs to the type level
04:38:24 <ski> sometimes, if a data type has just a single data constructor, and no better name has suggested itself, it is named the same as the type constructor of the data type
04:38:39 <ski> sometimes a prefix like `Mk' is prepended to the data constructor
04:39:04 <ski>   data Person = MkPerson Name Age Address
04:39:56 <reactormonk> Does return $ return $ indiciate I should be switching to MTs?
04:40:15 <ski> not necessarily
04:40:26 <ski> but it could be indicating that, yes
04:41:44 <ski> (e.g., often, if you find yourself using `IO (Maybe Blah)' much, it can make code simpler to switch to using `MaybeT IO Blah', at least for some parts of that code)
04:42:43 <reactormonk> Is there a (a -> b) -> Either a c -> Either b c, aka leftmap?
04:42:48 <ski> reactormonk : if we knew which the two monads were, perhaps we could give more specific and useful advice
04:42:57 <reactormonk> ski, IO and Either.
04:43:20 <reactormonk> But given the rest of the code, I don't think it'll make much sense.
04:44:10 <merijn> :t lmap
04:44:12 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
04:44:16 <merijn> wrong one...
04:44:28 <merijn> reactormonk: You want Bifunctor :)
04:44:28 <opqdonut> :t Control.Arrow.left -- reactormonk 
04:44:31 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
04:44:48 <ggVGc> is it more professional to use profunctors over normal functors_
04:44:49 <ggVGc> ?
04:45:00 <merijn> :t Data.Bifunctor.first
04:45:01 <opqdonut> > left not $ Left False
04:45:02 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
04:45:06 <lambdabot>  Left True
04:45:18 <merijn> opqdonut: I think Arrow should be deprecated for this sort of thing
04:45:27 <opqdonut> yeah I agree that Bifunctor is cleaner
04:45:28 <merijn> Now that Bifunctor is in base
04:45:42 <opqdonut> but old habits die hard :(
04:45:43 <merijn> > Data.Bifunctor.first not $ Left False
04:45:46 <lambdabot>  error:
04:45:46 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
04:45:46 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
04:45:52 <merijn> hmmm, old GHC?
04:48:16 <reactormonk> So I've got eitherDecode from aeson, and I want to wrap said left result into CustomError, and I'm starting out from IO (Either CustomError ByteString) - how would you combine the functions?
04:48:21 <ski> @let import Data.Bifunctor
04:48:23 <lambdabot>  Defined.
04:48:29 <ski> > Data.Bifunctor.first not (Left False)
04:48:32 <lambdabot>  Left True
04:49:20 <merijn> reactormonk: Is that an exception you're catching with 'try' to get the Either?
04:49:50 <reactormonk> merijn, CustomError has two members - NoConfigFile (which comes from the exception part) and InvalidJson, which comes from Aeson.
04:50:10 <reactormonk> I might collect the errors from the first part for better error messages.
04:50:40 <merijn> Probably either bifunctor or just explicit case
04:50:53 <ski> reactormonk : for `IO (Either e a)' (where you often want to collect any paths generating an `e' together into a "failure case"), i'd generally suggest `ExceptT e IO a' (not `ErrorT e IO a')
04:51:42 <reactormonk> ski, I've got a non-fail-fast semantics here, so not sure if ExceptT will work.
04:52:07 <ski> reactormonk : where you try another thing on failure ?
04:53:08 <reactormonk> ski, exactly.
04:54:43 <reactormonk> Hm, no constructors for IOException around?
04:55:02 <merijn> no
04:55:13 <reactormonk> What should I match on instead?
04:55:16 <merijn> use the isFooError functions to determine what it is
04:55:24 <MasseR> woah, they have complexified containers Map merging
04:55:46 <lpaste> merijn pasted “Nested types and persistent” at http://lpaste.net/351299
04:55:56 <pwmosquito> :t Functor
04:55:57 <lambdabot> error: Data constructor not in scope: Functor
04:56:03 <merijn> Suppose I have a nested ADT like that, what would be the best way to model that in persistent?
04:56:06 <ski> @kind Functor
04:56:07 <lambdabot> (* -> *) -> Constraint
04:56:09 <pwmosquito> @help
04:56:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:56:42 <pwmosquito> :t 1
04:56:43 <merijn> I'm ok with turning the ADT into two separate tables, but I'm not sure how I'd make sure the separate tables get turned into a nested data type
04:56:44 <lambdabot> Num t => t
04:56:53 <merijn> Anyone have experience with that?
04:56:58 <reactormonk> merijn, so after the Left (SomeException e), how do I only handle the IOException?
04:57:58 <merijn> reactormonk: Instead of doing "Left (SomeException e)" just do "Left e | isEOFError e -> {- code here -}" and let type inference select the right exception type for e
04:58:00 <ski> reactormonk : where is the `SomeException' coming from ?
04:58:11 <reactormonk> ski, try
04:58:14 <merijn> reactormonk: I had it in my initial example, because I was lazy :)
04:58:17 <merijn> eh
04:58:23 <merijn> s/reactormonk/ski
04:58:28 <ski> @type tryJust
04:58:30 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
04:58:34 <thomasjoy> Hi, in ghc 8 there's a DuplicateRecordFields extension, but it seems to create ambiguous. The doc says 'an ambiguous field must be exported as part of its datatype', so is it not possible to export both funtions at the same time?
04:58:45 <pwmosquito> preflex: seen pwm
04:58:51 <ski> @type handleJust
04:58:53 <lambdabot> Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
04:58:56 <merijn> pwmosquito: preflex has been dead for a long time
04:59:18 <pwmosquito> ah ok tnx, 1st time here, just experimenting
04:59:20 <ski> preflex: xseen mmorrow
05:00:35 * ski . o O ( TheHunter,ddarius,Pseudonym,.. )
05:01:04 <reactormonk> merijn, can't seem to figure it out :-(
05:01:55 <reactormonk> @type tryIOError
05:01:57 <lambdabot> error: Variable not in scope: tryIOError
05:02:04 <reactormonk> From System.IO.Error
05:02:06 <maerwald> are there any real sources for haskell hacking (including cracking, vulnerabilities, attacks on machine code level)
05:02:14 <reactormonk> ... should I be using that one instead?
05:02:16 <lpaste> merijn revised “No title”: “No title” at http://lpaste.net/351293
05:02:31 <merijn> reactormonk: That, but use whatever relevant function instead of isEOFError
05:03:18 <reactormonk> merijn, using Data.ByteString.Lazy.readFile, not sure if that's relevant here.
05:03:26 <merijn> reactormonk: Shouldn't really matter
05:04:28 <reactormonk> I think the try is too general, isDoesNotExistError only works with tryIOError
05:04:35 <quchen> preflex was by mauke, no?
05:04:38 <quchen> Where did he go to?
05:04:39 <merijn> quchen: Yeah
05:04:49 <merijn> quchen: He's still around sometimes, I saw him not too long ago
05:04:54 <niklasb> in persistent-postgresql, is it possible to have a dangling transaction holding a lock on a table? I want to lock the DB for writing during the runtime of my program
05:04:55 <merijn> quchen: preflex ran on his desktop, which died
05:05:01 <merijn> quchen: He never brought it back
05:05:23 <quchen> Pity! Preflex was quite useful.
05:05:23 <merijn> reactormonk: What makes you say that?
05:05:29 <quchen> Although I never used anything but @seen.
05:05:37 <merijn> reactormonk: try works with any exception, including IOError
05:05:55 <merijn> reactormonk: lpaste your code + error
05:06:03 <reactormonk> merijn, coming right up
05:07:00 <merijn> No persistent users either atm? I must be hacking at the wrong times >.>
05:08:24 <reactormonk> merijn, SQL really doesn't like ADTs. You'll have to consider how you wanna map them down there, or depends which option persistent chooses for you.
05:08:36 <reactormonk> Got persistent in this codebase, but I haven't looked at it yet...
05:08:59 <niklasb> maerwald: well there's my 33C3 CTF challenge :P
05:09:28 <niklasb> I believe it's the first of its kind, but not sure: https://github.com/niklasb/33c3ctf-coercive
05:09:50 <niklasb> but of course it features known bugs
05:10:21 <merijn> reactormonk: I know, the problem I have is that I basically want to capture that two tables have a subset that's common and I'm not really sure how to most conveniently get what I want. I could manually wrap those columns every time I query, but that idea does not make me happy
05:11:02 * ski . o O ( "Using Algebraic Datatypes as Uniform Representation for Structured Data" by Markus Mottl in 2003 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.5712>,<https://web.archive.org/web/20100131042843/http://www.ocaml.info/oefai/papers/algebraic_dts/> )
05:11:43 <niklasb> maerwald: there have also been reversing tasks featureing haskell, see for example http://sctf.ehsandev.com/reversing/lambda1.html 
05:12:17 <ski> (2003-03-10)
05:13:03 <ski> ACTION . o O ( "Modelling Large Datasets Using Algebraic Datatypes: A Case Study of the CONFMAN Database" by Markus Mottl in 2002-05-15 at <http://citeseerx.ist.psu.edu/showciting?doi=10.1.1.16.9023>,<https://web.archive.org/web/20100131042914/http://www.ocaml.info/oefai/reports/TR-2002-27/>,<http://www.researchgate.net/profile/Markus_Mottl/publication/2496829_Modelling_Large_Datasets_Using_Algebraic_Datatypes_A_Case_Study_of_the_CONFMAN_Database/links/0fc
05:13:27 <ski> (hrm, possibly cut off "<http://www.researchgate.net/profile/Markus_Mottl/publication/2496829_Modelling_Large_Datasets_Using_Algebraic_Datatypes_A_Case_Study_of_the_CONFMAN_Database/links/0fcfd5093c52145995000000.pdf> )")
05:14:10 * ski . o O ( "Algebraic Data Types for Language-Integrated Queries" by George Giorgidze,Torsten Grust (ProfTeggy),Alexander Ulrich,Jeroen Weijers in 2013 at <http://db.inf.uni-tuebingen.de/staticfiles/publications/ddfp2013.pdf> )
05:14:53 <merijn> ski: I'm assuming this was related to my question, but I don't think those papers are likely too be directly applicable :)
05:15:04 * ski nods
05:15:26 <merijn> Because I'm sure as hell not going to implement something from scratch :p
05:15:29 <ski> just general association on ADTs vs. RDBMSs
05:15:40 <merijn> And I have more of a direct "how to make this not suck" issue :)
05:16:18 <merijn> I seem to have a magical skill at wanting things that seems rather common but magically no one else seems to have document doing on the web :p
05:16:23 <ski> merijn : "I could manually wrap those columns every time I query, but that idea does not make me happy" -- iiuc, could you (define and) use a view ?
05:16:32 <merijn> Maybe other people are just less stubborn and give up
05:17:04 <merijn> ski: I dunno? Does persistent have views? I've so far spent a grand total of 1 hour and 1 tutorial on looking at persistent, so I have no clue what it can and can't do :)
05:17:24 * ski can unfortunately not help there :/
05:17:55 <maerwald> niklasb: I really should have attended 33C3
05:18:27 <merijn> ski: Yeah, I'd just expect *someone* to have needed this and wrote up a blogpost or whatever, but apparently not >.<
05:18:44 <niklasb> maerwald: well if you want to restage the challenge, just run the docker file without looking at the source code
05:19:25 <niklasb> (or at any of the files except the Dockerfile, for that matter)
05:20:09 <niklasb> merijn: you can create views manually (or via rawExecute) and define a persistent schema for them if that helps. I haven't seen your original question though
05:20:44 <niklasb> in fact, I've found that to be very useful for slightly more complex applications
05:20:55 <reactormonk> maerwald, was fun :-)
05:21:17 <merijn> niklasb: Basically I currently have this ADT http://lpaste.net/351299 where Info represents say, 4 or 5 columns
05:22:01 <niklasb> merijn: isn't that just a standard 1:1 relation?
05:22:04 <merijn> niklasb: I'm okay with splitting Bar and Baz into separate tables, but I would like to have those Info columns turned into a separate datatype, rather than having the same list of 4-5 fields in both the Bar/Baz constructor
05:22:28 <merijn> niklasb: I don't want to store the Info as separate in the database
05:23:16 <niklasb> merijn: to me this looks like naturally you would have 3 tables, Bar, Baz and Info. what is the reason that you do not want to model it that way?
05:23:28 <merijn> niklasb: Ideally I would keep the Bar/Baz in the same datatype too
05:24:07 <merijn> niklasb: Because I always want the info when querying a Bar or Baz, I only moved them into a separate ADT so I can write code that works on both
05:24:27 <merijn> Although I suppose that code breaks anyway if I split it into two ADTs :\
05:25:16 <niklasb> merijn: I wouldn't try to duplicate the structure of your data types in the relational database. I usually write some glue code that converts between the two representations, but maybe that's just preference
05:25:48 <niklasb> from a relational database perspective, I feel like Bar, Baz, Info would be a good representation, with 1:1 or even 1:n relations between Bar/Baz and Info
05:25:51 <merijn> niklasb: Right, but I can't find anywhere how to nicely create that kinda glue
05:26:14 <merijn> niklasb: 1:1, can't have multiple properties for the same thing
05:26:33 <niklasb> merijn: yeah I meant sharing info between Foo's, but that's not really important
05:27:05 <niklasb> merijn: maybe it could work to create two views representing the combation of Bar+Info and Baz+Info and than converting between those and Foo
05:27:18 <reactormonk> merijn, https://gist.github.com/anonymous/3714451e9c109c874c5b05107d1ba626
05:27:21 <merijn> niklasb: The doesn't really make sense as one of the things in the info is, for example, the name. :)
05:27:48 <merijn> reactormonk: That code immediately makes no sense to me :)
05:28:13 <reactormonk> merijn, trying to accumulate the exceptions.
05:28:17 <merijn> reactormonk: On line 1 and 2 exceptions is a variable (not idea what type...) and on line 5 you attempt to use it as a type
05:28:38 <reactormonk> merijn, oops. What's the cons constructor
05:29:03 <merijn> reactormonk: The type constructor depends on what you're trying to catch
05:29:22 <merijn> oh, wait, I see what's going on
05:29:29 <merijn> reactormonk: It still makes no sense
05:29:55 <merijn> oh, wait, maybe it does
05:29:55 <reactormonk> merijn, I'm trying to accumulate errors on each level, so I have something to report in case something goes wrong.
05:30:14 <merijn> reactormonk: What happens when you fix the ::
05:30:20 <reactormonk> merijn, ... what should it be?
05:30:21 <niklasb> merijn: well yeah you would duplicate the fields for info in both views
05:30:45 <niklasb> but if you want to update too, I don't think that is going to work anyways...
05:30:46 <merijn> reactormonk: Well you wanted a list, no? Then write a list constructor
05:30:55 <merijn> niklasb: Why?
05:31:11 <niklasb> merijn: because you can't update views?
05:31:17 <reactormonk> merijn, compiles.
05:31:33 <merijn> niklasb: hmmm
05:55:38 <ertes> :t traverse (\fp -> tryJust (\e -> if isDoesNotExistError e then Just e else Nothing) (readFile fp))
05:55:43 <lambdabot> Traversable t => t FilePath -> IO (t (Either IOError String))
05:55:47 <ertes> reactormonk: ^
05:57:34 <ertes> reactormonk: in particular don't use try this way…  if you need an exception filter *always* use tryJust (or catchJust when appropriate)
05:59:15 <reactormonk> ertes, now I'm also capturing the errors, any way to do that with a traverse?
06:03:12 <merijn> niklasb: Not entirely related, but since you seem to have persistent experience, do you know if there's a nice way to template schemas? i.e. I have the same pattern of schema repeating like 10 times, I wonder if there's a way to "map" like a 'String -> String' or 'String -> Schema' thing over a list of entries to make it less repetitive
06:07:32 <niklasb> merijn: what is a template schema
06:07:42 <niklasb> or a Schema for that matter
06:08:47 <merijn> niklasb: You have the schema's you define in the quasiquoter, i.e. the "[persistLowerCase| MyType " part
06:08:59 <merijn> I basically have a bunch of definitions that are similar
06:09:20 <ski> @type let open paths = asum (map (\path -> ExceptT (tryJust (\e -> guard (isDoesNotExistError e) >> Just [e]) (BSL.readFile path))) paths) in open
06:09:23 <lambdabot> [FilePath] -> ExceptT [IOError] IO BSLC.ByteString
06:10:00 <ski> reactormonk : perhaps something like that ^ could be useful ? (use `runExceptT' to get back to `IO (Either [IOError] BSLC.ByteString)')
06:10:35 * ski idly wonders whether it would be a nice idea to add synonyms for `(asum .) . map' and `(msum .) . map'
06:11:12 <lpaste> merijn pasted “persistent” at http://lpaste.net/351303
06:11:21 <merijn> niklasb: i.e., like that
06:11:41 <merijn> niklasb: I'd like to eliminate the repetitiveness there, but not sure if it's possible
06:11:59 <ski> reactormonk : this is using the `Monoid' instance on lists to collect all the errors (which all are known to satisfy `isDoesNotExistError') in the list, using `asum' to try the next alternative when previous ones have failed
06:12:21 * ski must leave ..
06:18:46 <niklasb> merijn: what repetitiveness specifically
06:18:52 <niklasb> by the way, those things are called Entities
06:19:11 <niklasb> if I understand persistent terminology correctly
06:19:13 <merijn> niklasb: They're all basically the same except for a name
06:20:47 <niklasb> merijn: ok no, I have no idea
06:21:10 <niklasb> doesn't look too bad to me though. You kind of want stuff to be really explicit here so you don't screw up migrations
06:21:26 <niklasb> but again, that's probably preference
06:22:34 <merijn> niklasb: In that example maybe, but I have like 15 of them
06:28:09 <reactormonk> How do I set things like DeriveGeneric in ghci=
06:28:23 <niklasb> merijn: ok. If it helps, for the project where I used persistent the most, I defined a type class for all the entities to capture the common functionality, such as the accessor for some ID columns and such. but I guess that is obvious
06:29:09 <c_wraith> reactormonk: you can set them on the command line when you start ghci, or you can set them at runtime with things like :set -XDeriveGeneric
06:29:42 <reactormonk> No Alternative instance on Either?
06:30:35 <reactormonk> ... right, makes sense
06:31:26 <ertes> reactormonk: also you should use :seti instead of :set most of the time
06:31:49 <c_wraith> reactormonk: one thing to note with extensions and ghci - if you load a file in ghci that uses LANGUAGE pragmas, those pragmas won't be enabled in ghci itself
06:31:54 <reactormonk> Is there an Identity Monad?
06:31:58 <reactormonk> c_wraith, I assumed as much.
06:32:08 <c_wraith> I always forget that myself
06:32:17 <c_wraith> Yes, there is Identity
06:32:39 <c_wraith> look in Data.Functor.Identity
06:33:34 <reactormonk> ski, I think that does the wrong thing.
06:34:03 <thatguy> could someone explain me why I am getting the error msg (code and msg here: http://lpaste.net/351304 ). It is only 5 lines of code, I am very new, so probably easy to see for anyone
06:35:13 <c_wraith> thatguy: you're matching a Node against the (,) constructor
06:35:37 <c_wraith> thatguy: findNeighbors (Node lbls ajs) = ...
06:35:55 <thatguy> c_wraith, ahhh yeah thanks
06:37:31 <c_wraith> thatguy: you're welcome. :)
06:41:19 <reactormonk> ski, ... no it does the right thing. huh.
06:47:16 <reactormonk> ski, I see how the rest of the code works, but I don't see how asum does its duty.
06:53:12 <moteutsch> Hey there If I have a "data" type which I would like to be an instance of functor, but my implementation requires the type signature (Ord a, Ord b) => (a -> b) -> (f a) -> (f b) Is there a way to overcome this?
06:54:15 <c_wraith> moteutsch: there are things you can do to work around it, but they have performance implications
06:54:22 <merijn> moteutsch: not really, tbh
06:54:31 <c_wraith> moteutsch: that's why Data.Set is not a Functor
06:56:17 <reactormonk> Is there a (a -> Either e b) -> ExceptT e m a -> ExceptT e m b ?
06:57:42 <opqdonut> that's just "\f m -> m >>= return . f" right?
06:58:21 <reactormonk> Probably.
06:59:08 <c_wraith> I don't think so, because that'd just be f <$> m, which has the wrong type
06:59:18 <reactormonk> No, complier complains.
07:00:45 <opqdonut> :t \f m -> m >>= ExceptT . return . f -- reactormonk 
07:00:47 <lambdabot> Monad m => (a -> Either e b) -> ExceptT e m a -> ExceptT e m b
07:01:21 <c_wraith> Ah.  Sneak the constructor in, and fmap no longer works
07:01:31 <opqdonut> there could be a function "liftEither :: Either e b -> ExceptT e m b" but I can't find it
07:01:39 <opqdonut> would seem pretty natural to me
07:02:17 <opqdonut> there's throwError :: e -> ExceptT e m b though
07:04:35 <reactormonk> f $ e - what's the equivalent with e <something> f?
07:05:02 <opqdonut> that's sometimes called &
07:05:18 <Tuplanolla> It's provided in `Data.Function` and `Control.Lens`, reactormonk.
07:05:21 <c_wraith> It's even in base under that name
07:13:43 <exio4> opqdonut: either throwError return ? :P 
07:31:22 <Micamo> @pl \v -> concat $ map (\z -> foldr (\x y -> map (\w -> x:w) y) z) v
07:31:22 <lambdabot> (foldr (map . (:)) =<<)
07:34:16 <Micamo> @pl \v -> foldr (\l -> concat . map (\z -> map (\y -> y : z) l)) [[]] v
07:34:16 <lambdabot> foldr ((join .) . map . flip (map . flip (:))) [[]]
07:39:35 <haskell971> [x | xs <- [[(3,4)].[(5,4),(3,2)]] , (3,x) <- xs]     means what ?
07:42:40 <haskell971> I get the simpler list comprehensions.
07:43:33 <hpc> > [x | xs <- [[(3,4)].[(5,4),(3,2)]] , (3,x) <- xs]
07:43:34 <geekosaur> (3,x) <- xs         means only the tuples whose first element == 3 will be selected
07:43:37 <lambdabot>  error:
07:43:37 <lambdabot>      • Couldn't match expected type ‘b0 -> c0’
07:43:37 <lambdabot>                    with actual type ‘[(Integer, Integer)]’
07:43:44 <hpc> > [x | xs <- [[(3,4)],[(5,4),(3,2)]] , (3,x) <- xs]
07:43:48 <lambdabot>  [4,2]
07:43:51 <geekosaur> (assuming the . is supposed to be a comma)
07:44:22 <geekosaur> and then we extract the second element of the selected tuples by pattern matching it as x and returning it
07:44:46 <haskell971> Comma
07:46:45 <haskell971> Got it.
07:50:38 <theduke> mhm, why doesn't the Data.String.IsString class contain something like toString ? Is there a canonical way to convert a IsString to a string?
07:56:25 <geekosaur> no, and there isn't guaranteed to be one for some things that have IsString instances
08:09:52 <ski> reactormonk : `asum' just combines all the elements of the input list of type `i a' (for some applicative (actually "alternative") functor `i', and some "result type" `a') together into a single `i a', using `(<|>) :: i a -> i a -> i a'. in the empty list case, it uses the "default/base" value `empty :: i a'
08:10:56 <reactormonk> ski, and <|> is defined in Either with validation semantics?
08:11:29 <reactormonk> Or why exactly does it accumulate on the left side, but not the right side?
08:14:50 <reactormonk> I need to do some simple string interpolation (string in string), just use ++ ?
08:15:03 <ski> reactormonk : in the case where `i' is `ExceptT e j', for some "exceptions" type `e' (`[IOError]' in your case), and some "underlying" applicative (not necessarily alternative) functor, called `j' (in your case `IO') to avoid confusion here, `(<|>)' on this `ExceptT e j' calls the *monoid* combination function `mappend,(<>) :: e -> e -> e' combine "exceptions" (from multiple branches) of type `e' together (in your case, since `e = [IOError]', this is just l
08:15:46 <ski> (er, cut off near ".., `(<|>)' on this `ExceptT e j' calls the *monoid* combination function `mappend,(<>) :: e -> e -> e' combine "exceptions" (from multiple branches) of type `e' together (in your case, since `e = [IOError]', this is just list concatenation)")
08:15:52 <ski> (similarly, `empty' on `ExceptT e j' calls `empty :: e' as default/base/empty case case (in your case, this "initializes" the exceptions list as the empty list))
08:16:47 <Rodenbach> The famous  factorial 0 = 1   and   factorial n = n * factorial (n - 1)    – is there a way to make it so that a type of Int is used that only works for non-negative numbers? `n` has to be >= 0
08:16:56 <reactormonk> ski, so the fancy logic comes from ExceptT
08:17:11 <ski> reactormonk : "Or why exactly does it accumulate on the left side, but not the right side?" -- `ExceptT e j' will accumulate together (using the monoid operations) all the values of type `e', as long as the actions keep failing (iow generating a value of type `e', rather than a "normal result")
08:17:16 <ski> reactormonk : yes
08:17:18 <hpc> Rodenbach: more recent versions of base have Nat and Natural types
08:17:22 <reactormonk> got it, thanks. Nice.
08:17:26 <hpc> iirc
08:18:08 <hpc> Rodenbach: ah, http://hackage.haskell.org/package/base-4.9.1.0/docs/Numeric-Natural.html
08:18:30 <hpc> implemented with libgmp as well
08:18:36 <Rodenbach> hpc: ah good, that seems to be it!
08:19:27 <hpc> oh right, and the unsigned version of Int is Word
08:19:31 <ski> reactormonk : so, `do'-notation (really `(>>=)') will give you shortcut failure here, while using `(<|>)'&`empty' / `asum' will give you "non-fail-fast semantics" or "validation semantics", or however you called it
08:19:46 <hpc> so you can take your pick from either of those
08:20:17 <ski> reactormonk : `MaybeT' is useful in similar cases, but where you don't care about differentiating between different kinds of failure (and so you don't collect a list of them, either)
08:21:02 <hpc> it might be nice to have type Nat[8,16,32,64] = Word[8,16,32,64]
08:21:14 <hpc> in a future release
08:21:58 <ski> reactormonk : btw, note that `asum' could be defined as `foldr (<|>) empty', so that `asum [act0,act1,act2]' is `act0 <|> (act1 <|> (act2 <|> empty))', which should amount to the same as `act0 <|> (act1 <|> act2)', due to monoid^Walternative laws
08:22:52 <ski> reactormonk : btw, `asum',`(<|>)',`empty' is for applicative functors / idioms, having a notion of "try alternatives" (the `Alternative' type class)
08:22:54 <reactormonk> ski, got it. I was looking for Alternative on Either first.
08:23:59 <ski> reactormonk : `msum',`mappend',`mempty' are the corresponding thing, for monads (the type class `MonadPlus', which existed before `Applicative' and `Alternative' was introduced)
08:24:02 <ski> @src msum
08:24:03 <lambdabot> msum = foldr mplus mzero
08:25:42 <hpc> ooh, MonadPlus has gotten a lot cleaner
08:26:09 <hpc> i remember it used to have some pretty weird pick-which-laws-to-follow thing going on
08:26:16 <ski> er, i'm confusing the names
08:26:29 <ski> `msum',`mplus',`mzero' is for `MonadPlus'
08:26:49 <ski> `mconcat',`mappend',`mempty' is for `Monoid'
08:27:39 <hpc> oh no, i was thinking of haskellwiki
08:52:38 <anohigisavay> hello!
08:54:38 <hpc> anohigisavay: this is a programming channel, RFC 1831 clearly states you must introduce yourself with "hello world" ;)
08:54:44 <anohigisavay> is it possible to make TypeRep an instance of Lift?  (as in Template Haskell)
08:55:15 <anohigisavay> _(:з」∠)_
08:58:20 <anohigisavay> basically i want to generate some record data that has TypeRep field
09:00:44 <sm> hpc: no it doesn't :)
09:06:28 * ski . o O ( "RPC: Remote Procedure Call Protocol Specification Version 2" (obsoleted by RFC 5531) by R. Srinivasan in 1995-08 at <https://tools.ietf.org/html/rfc1831> )
09:26:04 <theduke> geekosaur: thanks
09:27:57 <qmm> c_wraith: help me
09:28:08 <qmm> everyone, please help*
09:28:17 <qmm> i might use erlang
09:28:38 <c_wraith> qmm: I'm around, but in general it's better to just ask your question.  (I'm about to go shopping - who knows how long I'll stick around?)
09:28:57 <c_wraith> And there are lots of other helpful folk around. :)
09:29:07 <qmm> c_wraith: yeah, sorry, i really didn't mean to ping you
09:29:18 <qmm> that was from me about to respond in another channel
09:29:28 <c_wraith> It's all good. :)
09:29:50 <qmm> i just found out that the authors of http://community.haskell.org/~simonmar/papers/conc-substrate.pdf expected you to not worry about GC
09:30:47 <qmm> i can't think of a way around the stop the world garbage collector, and i think GC per process is more scalable
09:31:13 <qmm> these people weren't able to get around their problems either: https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/
09:31:16 <c_wraith> Experiments with per-process GC for GHC have shown it to not be especially compatible with laziness.
09:32:02 <c_wraith> However, pusher's case is both uncommon and trivially solved by an upcoming feature that they weren't willing to wait for.  Which is a fine choice.
09:32:17 <qmm> c_wraith: what is the upcoming feature?
09:32:53 <c_wraith> http://ezyang.com/compact.html
09:33:18 <c_wraith> The basic feature is that you can compact an entire data structure into a single block of memory that the garbage collector treats as atomic
09:33:27 <c_wraith> iirc, that should be in GHC 8.2
09:34:15 <mjtmullen> Is 8.2 still considered primarily a 'performance' release?
09:34:26 <qmm> 8.2 also has backpack
09:35:29 <mjtmullen> 8.2 has quite a few features actually, from what I've seen
09:35:38 <c_wraith> pusher's use case was a very large graph data structure that was almost never updated.
09:35:52 <c_wraith> The GC choked following all the pointers in it.
09:36:08 <c_wraith> But if it was compacted, the GC would never follow pointers within it.
09:36:58 <mjtmullen> It would also be nice to have a latency-sensitive GC in GHC
09:37:07 <meditans`> hmm, I have a problem regarding Show and Show1, and would like to know if this problem has been solved somewhere
09:37:24 <geekosaur> anohigisavay, I suspect that Lift-ing a TypeRep is problematic. you likely want to ask in #ghc or on glasgow-haskell-users because I would suspect some "fun" interactions are involved
09:38:53 <meditans`> let's say that I have a type family: `Associated a`, and I know how to describe a Show instance for `f a`, where f :: * -> *, only if I have an instance `Show a` and an instance `Show (Associated a)`
09:39:08 <meditans`> so, the natural thing to write would be:
09:39:34 <meditans`> instance (Show a, Show (Associated a)) => Show (F a) where ...
09:40:02 <meditans`> this unfortunately can't be cast in the form that Show1 wants (depending only on `Show a`)
09:42:08 <meditans`> so, if now I wanted to talk about structure parametrized on this kind of `f`s, I have to define another show class and make all the common functor instance of it, or am I mistaken?
09:46:34 <meditans`> I posted a minimal version of my problem at http://lpaste.net/351309
09:47:28 <anohigisavay> geekosaur, thanks :)
09:48:24 <geekosaur> ftr, specifically I m worried about the Fingerprint buried within a TypeRep --- I could see it being involved in the process somewhere, leading to a strange loop when trying to Lift one
09:48:42 <geekosaur> (multiple Fingerprint-s, even, if the type is parameterized)
09:49:23 <glguy> meditans`: Yes, it's the case that you won't be able to provide a Show1 F instance, if you're only able to show F a when you can show (Associated a) values
09:49:48 <geekosaur> (ghc uses Fingerprint internally to represent types, so it can avoid inadvertent type puns)
09:50:14 <meditans`> glguy: has this problem been solved somehow elsewhere?
09:50:31 <glguy> meditans`: Which problem?
09:51:17 <meditans`> glguy: is there a more general class than Show1, maybe something parametrized on a constraint?
09:51:30 <glguy> Show1 is a class for types F where given a 'Show a', that 'F a' can be shown. This 'F' just isn't one of those
09:51:33 <meditans`> so that I don't have to rewrite all the instances?
09:51:39 <glguy> I doubt it
09:52:03 <glguy> In the extreme case you could package a "Show (Associated a)" dictionary inside your F type
09:52:42 <glguy> Therefore all values of   F a   would be showable because it would only be inhabited by types supporing   Show (Associated a)
09:53:36 <glguy> meditans`: What's not working with your Show instance?
09:54:12 <glguy> Oh, I see, you can't use instance (Show1 f) => Show (CShaped f) where
09:54:23 <meditans`> exactly
09:54:23 <meditans`>  
09:54:30 <meditans`> why not something like
09:54:41 <meditans`> class Show1' (c :: * -> Constraint) (f :: * -> *) where
09:54:41 <meditans`>   showsPrec1' :: (c a) => f a -> ShowS
09:54:41 <meditans`>  
09:54:48 <glguy> You can also turn on some extensions and write: instance (Show (f A), Show (f B), Show (f Text)) => Show (CShaped f)
09:55:57 <meditans`> I mean, I imagine that there is some problem with the above, I'd like to understand exactly what could go wrong
09:56:04 <anohigisavay> _(:з」∠)_ ghc: panic! (the 'impossible' happened)
09:56:13 <meditans`> yes, thanks, this is probably what I'm going to do, glguy 
09:56:25 <qmm> i turned to the lens library this weekend to solve a problem that required updating record fields thanks to this helpful blog post  http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
09:56:30 <qmm> how do you solve this problem of updating state in erlang is interesting: you use either processes, gen_server, or turn to your db (probably riak), and i think all of these solutions are inherently made for massively scaling.
09:56:36 <qmm> it isn't clear to me how compact normal form reduces latency, nor is it clear to me how to use it in a distributed setting such as cloud haskell
09:56:40 <qmm> all of this is a big deal, becaue i've spent a good part of my life studying haskell and building side projects in the hopes of using it daily in my profession work, and then yesterday it occurred to me that it may not be a great fit if i have to meet serive level agreements which state that response times are less than so many milliseconds
09:56:53 <qmm> good part of my life over the past few years* :)
09:59:59 <meditans`> thanks again glguy, I will do as you suggested writing the instances I need with generics
10:00:25 <Layl> Hey, I'm trying to set up Haste on Windows, but when trying to install it through cabal, it fails to install the curl package, any solution for this?
10:00:50 <qmm> Layl: what's the error you receive?
10:01:11 <Layl> one sec, I'll grab a full log
10:01:23 <Layl> https://gist.github.com/LaylConway/a5a26865058f24551e9bba20049b09b4
10:03:28 <Layl> qmm: the above log comes from cabal installed through the 64-bit platform installer
10:05:58 * geekosaur wonders if that is using mingw-w64 --- because there are a *lot* of complaints about libcurl link errors in the web search I just did
10:06:18 <Layl> it's not using mingw
10:06:34 <glguy> Layl: curl is a C library you have to have installed before you can install the unmaintained curl Haskell package. Do you have the curl library installed already?
10:07:04 <Layl> glguy: I don't have it installed, what's the best way to install it so the curl lib can find it?
10:07:47 <qmm> Layl: http://scoop.sh/
10:08:03 <glguy> Layl: I don't know, I use Windows for Steam
10:08:10 <Layl> qmm: you are a lifesaver, this is exactly what I've always wanted
10:08:29 <geekosaur> mm, also for msys2 which looks like it's bundled with the platform
10:09:13 <qmm> Layl: i haven't used a windows in ~7 years, but that looks better than chocolatey or anything available 
10:09:54 <Layl> I've used chocolatey before and it seems to just dump files into a seemingly random folder for every tool without anything being able to find it
10:10:27 <hpc> i have given up on understanding windows development at all, and just go with stack
10:10:30 <geekosaur> sounds about par for windows, sadly
10:10:51 <geekosaur> it has no conventions at all for locations of development headers/libraries
10:10:56 <MarcelineVQ> mysys has pacman as well iirc
10:11:07 <qmm> would someone be willing to address my concerns above without hurting my feelings too much :) 
10:11:11 <hpc> it's not the same as arch's pacman though
10:11:16 <Layl> I would stick to linux a lot more if I weren't so dependent on windows tools for gamedev
10:11:31 <hpc> and imo both pacmans are extremely difficult to use
10:12:11 <MarcelineVQ> I've never had a problem but that doesn't mean much in the wider world :>
10:12:37 <Layl> qmm: unfortunately no dice, installed curl but cabal can't find it
10:13:07 <geekosaur> it likely installed native libraries instead of msys2 libraries (yes, they are different)
10:13:28 <hpc> MarcelineVQ: it certainly can be used without issues, i would just have to consult the manpage for it every single time i went to do anything
10:14:01 <Layl> egh how do I open up the msys2 shell bundled with haskell
10:14:38 <fragamus> Hi I have a large set of integers and I need to load it from storage in a high performance way - what do you recommend
10:15:12 <Unode> fragamus: storage?
10:15:17 <fragamus> disk
10:15:31 <Unode> depends on the format.
10:15:46 <hpc> how large? are they true mathematical integers or the "eh, close enough" C types?
10:15:55 <geekosaur> Layl, so my msys2 shows devel libs not installed by default, pacman -S libcurl-devel
10:16:02 <hpc> and what's considered performant depends on how it's being used
10:16:13 <Layl> geekosaur: I first need to get at msys2, I don't know how to open the one bundled with haskell
10:16:18 <geekosaur> (I did not install via the Platform though)
10:18:47 <Layl> I'm increasingly getting the feeling that the platform installer is just plain useless for using cabal
10:18:49 <hpc> if you just need to load a million or so machine ints into memory, you can probably get away with something simple using https://hackage.haskell.org/package/cereal-0.5.4.0/docs/Data-Serialize.html
10:19:02 <Layl> given the extreme difficulty I'm having doing such a simple thing of installing a package
10:19:44 <hpc> if your large set of integers is something in the billions or trillions, then you start to want some way of streaming them
10:20:02 <geekosaur> Layl, I'm afraid the problem here is Windows
10:20:02 <hpc> which gets into finding the behavior that is suitable for how you consume them
10:20:40 <fragamus> hpc the integers are presently stored as decimal text. they are haskell Int
10:20:50 <Layl> geekosaur: I understand that but I'm not about to set up either a VM or a dual-boot just to use a darn haskell package
10:20:54 <fragamus> one per line of the text file.
10:21:23 <geekosaur> mingw/msys/cygwin are attempts to solve the problem, all with their own problems. since there is no native/msvc based Haskell, I suppose you can conclude that for your purposes Haskell is the wrong language
10:21:37 <geekosaur> because it requires the OS be sane about development libraries and Windows is noit
10:22:00 <Layl> I've gone, over the last two weeks, over 5 different languages for my purposes
10:22:08 <jmcarthur> ouch
10:22:16 <geekosaur> this should tell you something
10:22:20 <Layl> I've installed about 10 build tools and package managers
10:22:39 <jmcarthur> I was actually about to say I think geekosaur is being too harsh on Windows, but 5 languages over 2 weeks...
10:22:43 <Layl> And still, I would argue
10:22:49 <Layl> It's worth it for not having to write JavaScript
10:23:06 <Unode> :)
10:23:15 <hpc> you're using native windows development to get away from writing javascript?
10:23:37 <Layl> I'm playing a game where you need to control little units with javascript
10:23:41 <jmcarthur> I'd rather write JavaScript (or better, compile some other language to JavaScript), I think.
10:23:44 <Layl> but I don't want to use javascript
10:23:53 <Layl> Now, I realize I may have picked the wrong game for that
10:23:57 <Unode> Layl: must be one heck of a game...
10:24:00 <Layl> But darn it I'll find a way
10:24:03 <Layl> Unode: it's called Screeps
10:24:17 <hpc> yeah, javascript is a few dozen better syntactic choices away from being scheme
10:24:30 <hpc> it's pretty okay if you can get the translation right in your head
10:24:43 <markasoftware> What about ES6? It looks pretty nice
10:24:46 <Layl> so, now my options are: either find a way to get Haskell working which seems to be impossible without finally getting around to cleaning up my arch partition to be working again
10:24:47 <Unode> Layl: for having you go all around like that while still trying to play it but fighting hard not to do it via JavaScript.
10:24:50 <Layl> or go back to clojurescript
10:25:28 <Layl> Unode: I set up Rust to compile using emscripten just for this
10:25:36 <Layl> it took a heck of a lot of work to get that working on windows
10:25:44 <Unode> Layl: that's motivation :)
10:25:56 <markasoftware> so don't use Windows!
10:26:11 <Layl> I would love to
10:26:26 <hpc> i can't tell if you're making things needlessly hard for yourself or you're about to become the best windows developer ever
10:26:30 <Layl> unfortunately, I'm a game developer/player who works with a lot of art software
10:26:40 <Layl> windows is kindof a requirement
10:27:15 <EvanR> games work great on not windows
10:27:15 <Layl> hpc: I've learned over my years of programming that windows developer is a game where the only winning move is not to play
10:27:22 <EvanR> art software works great on not linux
10:27:26 <jmcarthur> I would take the hit to art software and use the less powerful alternatives available on Linux over having to use entire dev environments that suck.
10:27:42 <hpc> ^
10:27:43 <Layl> jmcarthur: that's just not an option
10:27:46 <Unode> Layl: http://robocode.sourceforge.net/ http://grobots.sourceforge.net/ https://robotgame.net/ and the list goes on...
10:27:51 <jmcarthur> In "real" projects I'd end up paying real artists who use their own OS of choice anyway.
10:27:55 <Layl> not only will that cripple my productivity and product quality
10:28:03 <Layl> that's also going to make it impossible for me to work with other artists
10:28:04 <markasoftware> Layl: which art software
10:28:08 <markasoftware> photoshop?
10:28:15 <Layl> mainly adobe products yes
10:28:15 <Unode> Layl: also https://www.codinggrace.com/events/robocode/23/ which a friend played and recommended.
10:28:32 <hpc> gimp can open psd files
10:28:44 <glguy> The general benefits and perils of using Windows are off topic on #haskell, fortunately
10:28:47 <markasoftware> you can run photoshop in wine fairly well
10:28:48 <Layl> Unode: Screeps is amazing though, it's MMO RTS except programming
10:28:52 <jmcarthur> Actually in a "real" game project I'm likely to try to make it cross platform, so I'd have to be able to build/test in Windows anyway.
10:29:05 <EvanR> games regularly exist on not windows, the only reason they dont is unfamiliarity with the platforms (couple of platform specific things, and the bundling)
10:29:08 <jmcarthur> But my primary OS would still be non-windows
10:29:28 <Unode> Layl: I can only imagine.
10:29:28 <Xyliton> Are there any recommended things I could write in Haskell to get myself introduced to Haskell's features? I were trying to read an online book about Haskell but it became rather boring to just "absorb" the information written there, and sometimes it just didn't make any sense to me.
10:29:46 <johnw> Xyliton: pick a project for yourself in an area you already know well
10:29:49 <Layl> But yea, I *just* need curl to work in some darn way, what the heck can I do?
10:30:01 <johnw> Xyliton: then solve it using the simplest Haskell features (data type, functions), and gradually keep making it more fancy
10:30:07 <EvanR> why curl?
10:30:16 <Layl> because haste-compiler requires it
10:30:20 <Xyliton> johnw: but I have no idea how "fancy" is defined in the Haskell world
10:30:22 <EvanR> o_O
10:30:31 <glguy> Xyliton: There are exercises in http://cis.upenn.edu/~cis194/spring13/ ; adventofcode.com ; and others, if you need something to start with
10:30:32 <Layl> don't ask me, ask haste-compiler
10:30:40 <Rodenbach_> Is there a way to turn off type inference in ghc/ghci? While learning Haskell I would like to explicitly declare all functions. When turning it off I can’t accidently forget this.
10:30:46 <johnw> Xyliton: it's an nearly infinite ceiling that almost no one fully achieves except for maybe one or two people
10:30:51 <EvanR> time to set up unix on windows
10:30:51 <glguy> Rodenbach_: no
10:31:10 <johnw> Xyliton: there's a huge spectrum; so just start out simple, and add features and you learn about them and they sound useful
10:31:10 <jmcarthur> Rodenbach_: -Wall will turn on a warning about top level definitions with no signature
10:31:13 <glguy> Rodenbach_: but you can explore with -Wall and you'll get warnings about top-level definitions
10:31:18 <johnw> Xyliton: you don't need to know all of Haskell to use it quite effectively
10:31:28 <Rodenbach_> Good, that sounds helpful, thx.
10:32:27 <Layl> oh.
10:32:31 <Layl> Haste has a windows installer.
10:32:32 <hpc> Xyliton: my first project was an irc bot - it had a pretty annoying up-front difficulty of just connecting to a network, but then it opened up a lot for experimentation
10:32:37 <Layl> This would have been good to know 2 hours ago
10:32:56 <hpc> such is life in windows land
10:33:02 <Xyliton> johnw: the most advanced stuff I wrote in Haskell yet were a simple Hangman game (using bricks) and a cat clone. (ignoring my attempt at solving an algorithm problem for school)
10:33:12 <Xyliton> hpc: that sounds interesting!
10:33:36 <theduke> what's the timeline for 8.0.2?
10:33:49 <johnw> Xyliton: was first project was a "universal unarchiver"; not an original problem, but I still use my solution regularly, many years later
10:34:05 <hpc> theduke: christmas of 2007
10:35:14 <Xyliton> johnw: is it using implementations of the (un-)archivers like 7zip at it's core, or is everything self-made? :o
10:35:35 <hpc> theduke: (but actually 5 days ago, https://www.haskell.org/ghc/)
10:35:48 <johnw> Xyliton: it just dispatches to one of like 20 different unarchivers
10:36:19 <johnw> Xyliton: and it supports recursive nesting of archive formats
10:38:08 <johnw> Xyliton: point is, it was easy to write, and very useful to me, so that motivated the learning process
10:38:53 <theduke> hpc: ah yeah i just found that, thanks. arch is not updated yet :/
10:39:32 <Layl> slight note on windows causing issues with libraries, I like the rust solution to that issue, where small libs are just included as .c files with the package and built using the platform's compiler for the project
10:40:13 <jmcarthur> Xyliton: I like to write a little chat server/client when learning a new language.
10:40:52 <jmcarthur> Xyliton: With an established protocol like IRC or something, so I have to think about some of the more realistic constraints.
10:41:41 <johnw> yes, it's important to not really have to define the solution at the same time you're trying to implement it in a new language, that just makes life harder than it needs to be
10:42:00 <glguy> Xyliton: If working on IRC programs sounds fun, you could extend an existing IRC program, like my client, to do something extra you want
10:42:00 <johnw> "build on knowledge"
10:42:42 <Layl> what's the Haskell solution for setting up a project (like `cargo new` in rust, `npm init` in node, etc)?
10:42:56 <glguy> cabal init
10:43:37 <jmcarthur> And for practicing performance in semi-realistic situations, I like to rewrite common Unix utilities while supporting most features and benchmark them vs. the standard C implementations.
10:43:39 <Layl> glguy: does this also work with haste?
10:43:56 <glguy> I don't know; I've never used haste.
10:44:22 <jmcarthur> I save the performance stuff for after the chat program though.
10:55:38 <Layl> since haste asks for "ghc >=6.4" should I install the highest 6.x version rather than 8.x, or should I install 8.0.1?
10:56:13 <markasoftware> 8>6.4
10:56:15 <markasoftware> so 8 should work
10:56:17 <markasoftware> i think
10:56:30 <markasoftware> im pretty sure ghc is backwards compatible
10:56:45 <Layl> following semver, it's not backwards compatibile, but I don't know if haskell uses semver?
10:56:52 <ski> johnw : ooc, does it support Arc,LHa,LZH,Zoo,PowerPacker ?
10:57:10 <glguy> No, the Haskell ecosystem doesn't use semver, generally
10:57:32 <glguy> >=6.4 probably tells you more about when the project started than which version you should use
10:57:40 <Layl> any other common pattern that's used for versioning in haskell?
10:57:56 <glguy> pvp.haskell.org
10:58:11 <ski> @where pvp
10:58:11 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
10:58:33 <Layl> Ah I see
10:58:33 <hackrilege> How do I add a constraint to an associated type family?
10:58:36 <c_wraith> though the pvp is basically a more-precisely-defined version of semver.
10:58:51 <c_wraith> With a bigger major version number.
10:59:23 <geekosaur> hackrilege, you can include it in the class declaration. class Foo b => Bar a b where { type b; ... }
10:59:25 <hackrilege> I get parse error on =>
10:59:50 <glguy> hackrilege: You'll have ot fix the syntax error, then
11:00:35 <amx> If I need a data structure only to support `member` and `insert`, is there something efficient already available?
11:00:41 <hackrilege> I'm trying to write type family A a => B a :: *
11:01:05 <nitrix> amx: A Set seems enough.
11:01:29 <c_wraith> hackrilege: put it on the class
11:01:34 <c_wraith> hackrilege: like geekosaur suggested
11:01:49 <nitrix> amx: I'd personally implement a set + a bloom filter on top.
11:02:06 <amx> well I could just hash the elements and use a Set, yes
11:02:15 <nitrix> amx: As the bloom filter will help determine probabilistically if an element is possibly in the set or not, and gain a huge performance improvement.
11:02:30 <nitrix> amx: Why do you need to hash?
11:02:38 <amx> I do not want to keep the data around
11:03:32 <geekosaur> hackrilege, if you are using a non-associated type family, it doesn't look like you can constrain it. I'm also not sure such a constraint would be meaningful.
11:03:37 <hackrilege> Oh, no I mean type family A (B a) => B a where
11:03:48 <glguy> hackrilege: When you're defining an *associated* type family, the lexeme 'family' doesn't occur
11:04:03 <glguy> 'family' is for type families that are *not* associated with a class
11:04:06 <nitrix> amx: Then a bloom filter seems even more appropriate, with its own hashing function.
11:04:09 <geekosaur> closed type family? I think it's on you to enforce since you're defining all the instances
11:04:23 <hackrilege> Oh ok, I'll drop the family lexime
11:04:41 <nitrix> amx: If you don't want to prematurely optimize, a Set is fine too.
11:04:58 <geekosaur> and as such there is no point in having a constraint
11:05:28 <infandum> How come "pure (+) <*> (Just 3) <*> Nothing" works but "foldl (<*>) (pure (+)) [Just 3, Nothing]" does not?
11:05:39 <infandum> pure (+) <*> (Just 3) <*> Nothing
11:06:04 <glguy> infandum: Because foldl expects that first argument (<*>) to have exactly one, monomorphic type
11:06:28 <hackrilege> Sorry, client dropped connection
11:06:30 <glguy> The length of the list argument doesn't feature in type-checking
11:06:56 <mjtmullen> aka, what should it do here: foldl (<*>) (pure (+)) [Just 3, Nothing, Nothing]
11:07:13 <infandum> glguy: it expects (a -> b -> a), what's wrong with that?
11:07:29 <hackrilege> I get error can't deduce A (B a), I'm wondering how to write an instance for the associated type
11:07:31 <mjtmullen> or here: foldl (<*>) (pure (+)) []
11:07:36 <glguy> infandum: what exact type do you expect (<*>) to have in this situation?
11:07:45 <Layl> hm, how can I resolve the error " haste-cabal.exe: At least the following dependencies are missing: base ==4.9.*"?
11:07:45 <infandum> mjtmullen: it should take pure (+), do pure (+) <*> Just 3, then apply that to Nothing
11:08:08 <hackrilege> Basically I wish to constrain my associated type
11:08:11 <infandum> mjtmullen: Well it should pattern match [] to be []
11:08:15 <infandum> wait
11:08:16 <infandum> no
11:08:21 <infandum> oh, good point
11:08:26 <geekosaur> Layl: use the appropriate ghc version; base cannot be replaced or upgraded/downgraded
11:08:32 <glguy> infandum: when you give me the type for your use of (<*>) you don't get to use any type variables
11:08:33 <mjtmullen> The types don't work out, because you cannot constrain the size of the list :)
11:09:03 <Layl> geekosaur: so turns out 8.0.1 wasn't the right platform to install after all?
11:09:10 <Layl> or do I have to run some command to downgrade
11:09:20 <infandum> then how can one have a list of applicatives and use (<*>) on it to have f <$> that list?
11:10:10 <geekosaur> Layl, 8.0.1 is base-4.9.0.0. can you run haste-cabal with -v3?
11:10:11 <glguy> sequence :: Applicative f => [f a] -> f [a] -- specialized to lists
11:10:29 <geekosaur> also this sounds like something haste is doing wrong...
11:10:54 <Layl> geekosaur: https://gist.github.com/LaylConway/b10707a2e9eeadbd192364d52678b4fa
11:11:19 <c_wraith> I was under the impression haste was pretty well-maintained.
11:11:21 <infandum> glguy: oooohhhhh
11:11:23 <infandum> brilliant
11:11:39 <Layl> c_wraith: me too, last update 3 days ago on github in master
11:11:51 <hackrilege> I guess I'm forced to provide it as a parameter to the class, then I can constrain it. I don't understand why I can't constrain an associated type though
11:13:29 <hackrilege> If I add an extra parameter, I get errors about it appearing more often in constraints than in the instance head
11:13:32 <c_wraith> Layl: that's a bit odd.  It's saying it's finding base 4.8..
11:13:43 <geekosaur> does haste have its own base?
11:13:58 <geekosaur> (that would seem likely to me)
11:14:03 <shayan_> Hey, can you guys review Grokking Algorithms? Was it worth the purchase? Importantly, what did you most take away from that book?
11:14:06 <c_wraith> base 4.8 was with ghc 7.10, right?
11:14:10 <geekosaur> yes
11:14:16 <Layl> "wired-in package base mapped to base-4.9.0.0" according to `ghc -v`
11:14:22 <infandum> glguy: btw, I'm using ZipList, so I need sequenceA
11:14:43 <c_wraith> Layl: haste-pkg must be looking someplace different than ghc-pkg
11:14:44 <glguy> OK
11:15:02 <Layl> great, this is getting increasingly frustrating
11:15:21 <c_wraith> Layl: I'd be frustrated too.  That's weird.
11:15:28 <Layl> who would think that computers are so complex
11:16:02 <Layl> any ideas for what to try next?
11:17:39 <Layl> oh! haste ships with an older base
11:17:50 <Layl> "These packages require a 64 bit OS and a somewhat recent (GHC 7.6+) version of GHC installed and visible on your $PATH"
11:18:19 <c_wraith> I guess a year isn't enough time for them to have decided to support ghc 8.0
11:18:36 <c_wraith> Not that I don't understand.  8.0.1 felt experimental.
11:18:47 <c_wraith> and 8.0.2 has only been out a couple days
11:19:29 <Layl> so I just downgraded base in the .cabal file
11:19:39 <Layl> now it's compiling... to a .exe
11:19:45 <Layl> of which the contents are .js
11:20:23 <Layl> i.imgur.com/7o6eCyg.png
11:20:27 <Layl> I guess that works...?
11:20:51 <c_wraith> It probably made more sense on linux, where the output didn't have a file extension
11:21:00 <Layl> what the... it dropped the output file into src
11:21:04 <Layl> why the hell would it do that
11:21:16 <Layl> the one single place an output file isn't supposed to be
11:21:42 <Layl> why would it just... what
11:21:54 <Layl> in haskell are build artifacts supposed to be placed next to source files?
11:22:04 <c_wraith> no
11:22:30 <glguy> They're placed wherever you tell the compiler to place them. If you don't tell it it will place them next to the source files, but there are flags to control it
11:22:44 <glguy> cabal manages that automatically
11:23:02 <Layl> glguy: this is built with cabal though, shouldn't it tell the compiler where to place it?
11:23:04 <geekosaur> Layl, if you use gcc directly it also places the .o next to the .c
11:23:36 <geekosaur> but haste-cabal should be telling it to use -odir to redirect artifacts under dist/
11:23:59 <ongy> gcc also calles it a.out
11:24:24 <mjtmullen> It would be nice if lambdabot type checking used TypeApplications
11:24:40 <Layl> is there an active IRC chat for haste somewhere?
11:24:52 <Layl> geekosaur: they're both there *and* under dist/
11:24:54 <thatguy> hey guys
11:25:01 <thatguy> can someone explain me the error message here?
11:25:02 <thatguy> http://lpaste.net/351315
11:25:44 <thatguy> I kind of don't get that function finished
11:25:48 <thatguy> I always get a new error
11:25:49 <glguy> thatguy: map label adjs :: [a], but you said that findNeighbors :: Node a -> [Node a]
11:26:02 <glguy> so now the type checker is trying to reconcile [a] and [Node a]
11:26:21 <glguy> for [a] and [Node a] to unify,   a and Node a would have to, they aren't going to
11:26:43 <thatguy> but adjs is a list of nodes or not
11:26:48 <thatguy> it is the adjacents
11:27:10 <glguy> Yes, adjs is a [Node a], but   map label :: [Node a] -> [a]
11:27:28 <monochrom> why is it label, not adjacent?
11:27:45 <thatguy> glguy, thanks I got it!
11:27:56 <thatguy> monochrom, I want the labels of the neighbors
11:28:37 <haskell336> hi, what's the best way to render some String or Text to HTML ?
11:29:28 <Layl> okay sweet, I've got haste running in node
11:29:46 <Layl> with one little tidbit, it's trying to run main using window.onload
11:29:57 <Layl> so I have to suffix the code with a bit more stuff when I'm copying it
11:30:14 <Layl> which is fairly annoying
11:30:53 <Layl> but, the output is pretty small even unminified, don't even have to run google closure over it
11:31:15 <c_wraith> you know, there are easier ways to run haskell on the server. :)
11:33:05 <thatguy> won't the graph structure proposed here return an infinite graph if A is a neighbor of B and B is a neighbor of A?
11:33:33 <thatguy> http://stackoverflow.com/a/9732857
11:33:50 <thatguy> that is what I meant with "here"
11:34:07 <zipper> hmm has anyone looked at `insertWith` vs `insertWithKey`? They seem to have pretty much the same effect. If key and value don't exist add them if they do, perform `(function new_value old_value)`
11:34:20 <thatguy> ah no only the print will be infinite right
11:34:27 <thatguy> because it prints all neighbors with all its neighbors
11:34:31 <thatguy> which can't end
11:34:40 <thatguy> ok I think I got it
11:35:06 <c_wraith> thatguy: sounds right to me
11:35:14 <hackrilege> :t insertWithKey
11:35:16 <lambdabot> error:
11:35:16 <lambdabot>     • Variable not in scope: insertWithKey
11:35:16 <lambdabot>     • Perhaps you meant one of these:
11:35:31 <hackrilege> Sorry
11:35:43 <thatguy> c_wraith, is there a simple way for me to tell the console to only print the "label" of the data type and not also the adjacent attribute
11:36:33 <thatguy> or what would I google to find how to do that
11:36:39 <nshepperd> thatguy: well, you could consider it a finite graph if labels are one-to-one with nodes and you can compare labels for equality
11:36:41 <c_wraith> thatguy: you can use label as an accessor to pull out just that part of the record
11:37:16 <nshepperd> you could recursively explore the graph by keeping a set of visited labels
11:37:53 <thatguy> nshepperd, I don't understand what you mean by "consider"
11:38:27 <thatguy> do you mean it is only finite in the sense if I identify a node with its label?
11:38:34 <nshepperd> yes
11:38:36 <Layl> okay, a bit of build script messyness and I've got a working build
11:38:39 <thatguy> but as a haskell structure it actually isn't
11:38:41 <nshepperd> the data structure is finite in memory
11:39:54 <thatguy> ah but if I have two nodes, A and B with an edge in both directions then the neighbor of the neighbor of A is not the same object in memory?
11:39:58 <nshepperd> > cycle [1, 2]
11:40:01 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
11:40:23 <nshepperd> this is the same sort of thing. it only takes up two cons cells, because the end of the list points back to the start
11:40:25 <thatguy> I am a bit to much used to object oriented thinking probably
11:40:34 <nshepperd> there's a circular reference
11:41:02 <nshepperd> thatguy: it will be the same object in memory, yes
11:42:10 <thatguy> ok I will play around a bit
11:42:15 <nshepperd> https://wiki.haskell.org/Tying_the_Knot
11:43:24 <nshepperd> it's not a good representation for graphs though, because it's very easy to mess up the knot-tied-ness when modifying the graph
11:44:00 <thatguy> nshepperd, could you tell me a better one?
11:44:28 <thatguy> thanks for the link, it's interesting
11:44:37 <thatguy> its
11:45:12 <nshepperd> I prefer to just identify each node by a number and use 'Map NodeId (a, [NodeId])' or something
11:45:24 <nshepperd> where a is whatever label you want for each node
11:46:00 <nshepperd> or 'Vector (a, [Int])' for super efficiency (having NodeId = Int)
11:46:13 <thatguy> I don't need super efficiency yet
11:46:32 <c_wraith> if you want something prebuilt, fgl is a pretty nice graph library
11:47:07 <thatguy> thanks but I want to try to use something simple which I can implement myself s.t. I see how its done
11:47:21 <thatguy> when I master haskell a bit more there is plenty of time for using the prebuilt packages
11:47:35 <Xyliton> according the "learnyouahaskell.com" a value constructor is just a function returning a value of their type. But how is it possible that one, for example, shape has 3 values, and another one has 4? Wouldn't that break haskell's ability to be "type-safe", because a function might only operate on 3-value shapes, but you could give it 4-value ones?
11:47:58 <thatguy> nshepperd, I don't really understand your first example to be honest
11:48:09 <glguy> Xyliton: A "value constructor" is a class of names in haskell that start with a capital letter
11:48:16 <glguy> or which are operator symbols starting with a :
11:48:19 <thatguy> you map the function NodeId on the tuple?
11:48:26 <thatguy> shouldn't the second argument be a list
11:49:37 <Xyliton> glguy: now I'm confused. They are giving a concrete example: data Shape = Circle Float Float Float | ...
11:49:51 <Xyliton> I understand this is, Circle is a shape and takes 3 floats
11:49:53 <Xyliton> *as
11:50:00 <Layl> could someone give me some insight into what I'm doing wrong here: http://i.imgur.com/3JaHKaS.png
11:50:00 <glguy> OK, the name "Circle" is a value constructor because it's capitalized
11:50:03 <monochrom> No, stop right there.
11:50:04 <nshepperd> thatguy: the first example is a key-value map. the keys are NodeIds, and the values are: a label of type 'a' associated to the node (this is optional, really, maybe you don't want/need a label) and a list of NodeIds that this node is connected to
11:50:17 <monochrom> "Circle" is not a shape. "Circle 1.0 2.0 3.0" is a shape.
11:50:40 <monochrom> And Circle will never accept 4 parameters.
11:50:47 <Xyliton> that's my problem
11:50:51 <glguy> :: means "has type", Circle :: Float -> Float -> Float -> Shape
11:51:16 <glguy> It happens to have a function type because when it was declared it had some fields (in this case those fields all have Float type)
11:51:17 <nshepperd> thatguy: Map with a capital M is a type https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Map.html
11:51:33 <Xyliton> but what if there's a second shape defined as "Rectangle Float Float Float Float"
11:51:45 <glguy> You'd get a distinct value constructor, Rectangle
11:51:52 <monochrom> Sure, then Rectangle takes 4 parameter. But Circle still takes 3.
11:52:01 <Xyliton> I can't use Circle or Rectangle in function signatures though, only Shape
11:52:05 <glguy> Rectangle :: Float -> Float -> Float -> Float -> Shape, when used as a function
11:52:06 <Xyliton> (AFAIK)
11:52:09 <Apocalisp> /query lambdabot
11:52:24 <monochrom> And yeah, "Circle 1.0 2.0 3.0" is one shape, "Rectangle 0 0 1 1" is another shape.
11:52:24 <glguy> Correct, neither Circle nor Rectangle are type constructors
11:52:28 <glguy> they only live at the value level
11:52:39 <glguy> Shape is the type constructor
11:52:57 <Xyliton> so I can't be sure that a function is given a Circle or a Rectangle, unless I use guards, a "case", or some other way to filter it
11:53:00 <Xyliton> right?
11:53:05 <monochrom> Right.
11:53:07 <thatguy> nshepperd, ah ok thanks
11:53:13 <Xyliton> but why?
11:53:18 <glguy> Right. If you want to distinguish between Circle and Rectangle values, they need to have their own types each
11:53:21 <monochrom> Why not?
11:53:31 <thatguy> nshepperd, c_wraith thanks for taking the time
11:53:36 <thatguy> haskell is a beautiful language
11:53:39 <glguy> The only way to distinguish things by type is for them to have different types
11:53:59 <geekosaur> Layl, you need to use pack to convert a String to a JSString
11:54:24 <Layl> geekosaur: how does that work?
11:54:38 <Xyliton> monochrom: what if I have a function which only works with circles, but all my other ones can operate on both?
11:54:45 <Layl> oh, I just saw what makes the example work, apparently "{-# LANGUAGE OverloadedStrings #-}" is needed at the top of the file
11:54:56 <glguy> Xyliton: Then do not give that function a type: Shape -> _
11:55:01 <monochrom> That's going to be tough.
11:55:02 <nitrix> Xyliton: Then you'll need to still handle the two remaining cases in that function.
11:55:19 * geekosaur was just trying to figure out if haste supported OverloadedStrings :)
11:55:28 <glguy> Xyliton: If you want to have functions on circles, you can have: data Shape = RectShape Rectange | CircShape Circle
11:55:35 <nitrix> Xyliton: As the value it receives maybe be one of the three options, that possibility must be taken into account, even though the implementation might not do much about it.
11:55:37 <glguy> and then two separate types for Circle and Rectangle
11:55:43 <geekosaur> since that way it will wrap it in fromString and if JSString has an IsString instance it'll Just Work
11:55:56 <monochrom> Equivalently, what if you want to write a function that only works for 0 and 1, and other functions that work for all integers? Answer: Tough.
11:56:31 <nitrix> monochrom: Nat :D
11:56:52 <monochrom> Nat is still to broad
11:56:54 <Xyliton> I guess I just have the wrong understanding of types...
11:57:11 <nitrix> monochrom: Nat used as a type-level literal :)
11:57:49 <monochrom> Well yeah but I can always ramp it up and say something like "only works for prime numbers and Carmichael numbers"
11:58:01 <nitrix> monochrom: Oh sorry, KnownNat is what I had in mind.
11:58:04 <geekosaur> Xyliton, data Shape = Circle ... | Rectangle ...  ... is no different from data Maybe a = Nothing | Just a
11:58:05 <monochrom> Actually that's too easy.
11:58:49 <nitrix> monochrom: I don't even know what a Carmichael number is :<
11:59:01 <Xyliton> I'm thinking a bit too much about it using the OOP-like mindset. It kinda feels like types are the equivalent of "super"/"parent" classes, and the value constructors "extend" it
11:59:26 <geekosaur> that would be wrong for Haskell, yes
11:59:30 <Xyliton> I guess I should've started with functional programming from the beginning
11:59:57 <monochrom> No, you just need to understand OOP better, so as to see how it doesn't carry over to Haskell.
12:00:33 <monochrom> If your OOP is typeless, for example javascript, then well it's typeless, Haskell is typeful.
12:00:33 <nitrix> Xyliton: You can form a hierarchy of types, but there's not going to be any of the inheritance stuff like what happens with the ad-hoc polymorphism in class-based OOP.
12:00:59 <monochrom> If your OOP is typeful, for example Java, then it has subtyping, but Haskell has no subtyping.
12:01:35 <thatguy> nshepperd, I looked at Map, I think it is already a bit to "mighty" for me, I'd like to just use the basic stuff and do all the rest myself for first
12:01:41 <monochrom> Also, that neither OOP story has algebraic data types. But Haskell's "data XXX = ..." is algebraic data type.
12:03:19 <Xyliton> ugh, algebra. I'm not that far into math yet :/
12:03:38 <monochrom> Oh algebra is easy. It's just addition and multiplication.
12:04:20 <nitrix> Xyliton: Algrebaic data types let you create algebra specific to your problem. If you want to separate different concepts in their own types and have functions operate on those, you can. Then you can combine some of these types into other more complex sum/product types, and have other functions that works on those too.
12:04:23 <Layl> this is... odd
12:04:30 <Layl> haste gives me a compile error....
12:04:33 <Layl> but it did correctly compile it
12:05:10 <hpc> haskell and java have the same type/value distinction, by the way
12:05:21 <geekosaur> Xyliton, "algebraic" here doesn't quite mean the stuff in lower level math classes. and you can mostly ignore the theoretical basis that justifies calling it "algebraic"
12:05:26 <hpc> Object is a type, as is Array<Boolean>
12:05:45 <glguy> hpc: What if I want an Array with only True values??
12:05:45 <hpc> [1, 2, 3] is a value of type Array<Integer>, and so forth
12:06:21 <Ternary> Does anyone have any experience with build foreign libraries with Haskell?
12:06:34 <Ternary> building*
12:06:35 <monochrom> Eh? The "theoretical basis" is trivial. It's exactly what I said, addition and multiplication.
12:06:44 <Xyliton> hpc: ohhh, like that
12:06:55 <Xyliton> monochrom: no subtraction or division?
12:07:10 <monochrom> I didn't need to call it "the academic theoretical theorem-proving foundation".
12:07:20 <nitrix> Xyliton: As far as haskell is concerned, there are only product and sum types.
12:07:25 <hpc> Xyliton: not in general - https://en.wikipedia.org/wiki/Ring_(mathematics)
12:07:29 <nitrix> No intersections or unions.
12:08:18 <Xyliton> damn, I really have to re-learn my fundamental math stuff
12:08:30 <hpc> er, https://en.wikipedia.org/wiki/Algebraic_structure
12:08:49 <monochrom> "data Whee = Case1 X Y | Case3 Y" is analogous to "X*Y + Z".
12:08:50 <hpc> Xyliton: conveniently, you'll find a lot in common with things you already know
12:08:55 <nitrix> Xyliton: For one, you can stop thinking it's math-related. Let's just say it's math-inspired and it's part of learning Haskell.
12:09:09 <hpc> abstract algebra is a lot like high school algebra, just with things other than numbers
12:09:19 <hpc> like boolean algebra, or the algebra of sets
12:09:28 <niklasb> and with tons of field extensions apparently 
12:09:40 <monochrom> In fact, if you just look at the number of possible values, it works out nicely: (# of possibilities of X)*(# of possibilities of Y) + (# of possibilities of Z)
12:09:43 <hpc> or the algebra of types which is where ADTs get their names
12:10:27 <hpc> (also you don't really need to know that much of that giant wikipedia page, but it makes a nice overview)
12:10:46 <Xyliton> monochrom: but Z isn't defined anywhere, is it?
12:11:03 <monochrom> I am sceptic to "you don't need math". 3*5 + 1 = 16 is math, too.
12:11:09 <nitrix> Xyliton: I'd be glad to explain what makes algebraic data types algebraic, but I think you need to solidify value constructors and pattern matching first.
12:11:24 <monochrom> In fact, when people say "do the math", they do mean "3*5 + 1 = 16"
12:11:28 <nitrix> Yeah, monochrome's example would require existantial quantification to work.
12:11:39 <monochrom> Assume that X, Y, Z are already defined elsewhere.
12:12:04 <monochrom> What existential quantification?
12:12:11 <nitrix> Oh my bad, `X`, `Y`, `Z`, not `x`, `y`, `z`/
12:12:12 <glguy> monochrom: YOu needed : Case3 Z
12:12:26 <Xyliton> hpc: what is "highschool algebra"? I have no idea about the american curriculum
12:12:40 <Xyliton> also, why no "Case2"?
12:12:55 <parsnip> Xyliton: like, up to solving quadratic equations
12:12:58 <monochrom> I already wrote "Case3 Z" didn't I?
12:13:14 <Xyliton> monochrom: nah, you defined Case3 as "Case3 Y"
12:13:17 <glguy> monochrom: Maybe, I just saw "12:08 monochrom       : "data Whee = Case1 X Y | Case3 Y" is analogous to "X*Y + Z".  "
12:13:28 <glguy> and then people got confused about Z
12:13:49 <monochrom> Oh! Yes typo. Sorry.
12:13:55 <nitrix> Wee, monochrom turn to typo :P
12:13:58 <monochrom> data Whee = Case1 X Y | Case3 Z
12:14:09 <Xyliton> but why is there no second case?
12:14:19 <Layl> All things considered, Haste so far took me less time to get working than ClojureScript did
12:14:21 <glguy> the names of the cases aren't the point of the exercise
12:14:25 <monochrom> That's another typo but WontFix
12:14:25 <Layl> so there's a positive
12:14:31 <Layl> its output is also much smaller so far
12:14:40 <parsnip> Xyliton: usually it's clear, because there's three years of math between algebra courses
12:15:44 <nitrix> Mentioned earlier, I'd be glad to explain what makes algebraic data types algebraic, as well a product and sum types, but I think you need to solidify value constructors and pattern matching first.
12:16:03 <kuno_luno> Peeps.
12:16:09 <kuno_luno> I need help. :-/
12:16:10 <nitrix> As you were confused earlier with how you'd have functions work on specifically some cases but not all cases.
12:16:50 <kuno_luno> I think I'm basically trying to do OOP runtime polymorphism in Haskell, but the typechekcer disagrees...
12:17:13 <monochrom> Try not to.
12:17:28 <nitrix> kuno_luno: Is you code full of Typeable?
12:17:36 <glguy> kuno_luno: Yeah, you'll have to defer to the type checker. It's going to win. If you have a specific question about some code, you can paste that code to http://lpaste.net
12:18:40 <nitrix> kuno_luno: You might accidently implement a form of dynamic classification if you're not careful; which is what a long of interpretated languages claim to have as their type system.
12:18:42 <kuno_luno> Nah nitrix.Trying to avoid stuff like that.
12:18:53 <nitrix> *lot
12:19:35 <Layl> am I right in assuming that a function that returns IO () and has "do" will evalulate to the end when called as opposed to being lazily evalulated?
12:19:55 <Layl> probably all terminology wrong, this is my first venture into haskell
12:20:18 <davean> Layl: I mean not exactly? It'll return an IO (), and it can return that lazily - it'll be interprited strictly though
12:20:38 <glguy> Layl: a function like "putStrLn" won't do any actual printing when it's applied to a string, for example. It will simply produce an action that prints
12:20:50 <glguy> do let x = putStrLn "test"; this; that
12:20:52 <glguy> no printing
12:20:52 <nitrix> Layl: What do you mean `evaluate to the end`? It's possibly for an IO to throw an exception and interrupt the monad.
12:20:57 <glguy> do let x = putStrLn "test"; x; x
12:20:59 <kuno_luno> nitrix and  gluy : http://lpaste.net/351317
12:20:59 <glguy> prints twice
12:21:07 <Layl> glguy: I see, hm
12:21:30 <glguy> and it only prints if the thing we just defined is executed
12:21:33 <kuno_luno> The question is, how can I manipulate the children's properties, given that I only know that each one is of class Default?
12:21:40 <glguy> like maybe it was the definition of main, or main used it
12:21:48 <Layl> so would `setLoop = ffi "(function(func) {module.exports.loop = func;})"` produce an action that evaluates that?
12:21:50 <kuno_luno> I literally just want to get the default value of each one and store that in a list.
12:21:57 <Layl> or does haste ffi work differently
12:22:07 <davean> "a >>= b >>= c" <-- assuming this is run, not just defined, everything in b will happen before c if they're in IO and theres no forking or anything
12:22:15 <nitrix> Layl: When you're working with IO computations, you're never actually executing them. You're simply building more complex IO out of other IOs, all the way up to your `main`, which is given to the runtime system, and that system finally executes it.
12:22:31 <Layl> I see
12:22:32 <nitrix> Layl: But all along, you're just manipulating computations. It's all lazy.
12:22:49 <glguy> kuno_luno: j doesn't work because the elements of children wrapped by Child don't necessarily have the  same type
12:22:57 <kuno_luno> I hear that I should be using GADTs instead, or something. In that case I can't even produce the children list.
12:23:03 <glguy> kuno_luno: so you can't produce a [a] which says that all the values in the list have the same type 'a'
12:23:10 <kuno_luno> Oh. glguy
12:23:14 <glguy> kuno_luno: and not only that it says that the caller gets to pick that type 'a'
12:23:18 <glguy> not the body of 'j'
12:23:26 <Layl> I really should wrap my head around this properly, so I understand it the right way and not accidentally forget to execute vital code in this :P
12:23:28 <glguy> caller -> user
12:23:35 <davean> j would have to have a forall also
12:23:53 <kuno_luno> I'm stumped....
12:24:00 <nitrix> Layl: You are guaranteed that they are executed in order though, so you're able to reason, or even pretend that it's strict and imperative if it helps you get started, but you should loose that mentality as soon as possible because it's a lie :)
12:24:07 <davean> kuno_luno: [a] says the 'a's in that list are all the same type
12:24:24 <kuno_luno> At least with existential quatification children can compile. With GADTs I can't even make a list of children...
12:24:32 <Xyliton> nitrix: I kinda understand the difference between between types and value constructors now. A type defines a group of stuff which has common algebraic functions, right?
12:24:43 <Layl> nitrix: my main goal right now is to understand how haste FFI fits into all of this and how to most efficiently call back into JS in a way that fits with Haskell's assumptions about execution
12:24:44 <kuno_luno> Oh, yeah. davean. Makes sense... :-/
12:24:46 <nitrix> Xyliton: Bzzt.
12:24:58 <davean> kuno_luno: you can put a "forall" there also
12:25:06 <Xyliton> am I at least nearer to the goal than before?
12:25:09 <nitrix> Xyliton: A type would just be a name given to a set of values.
12:25:11 <davean> kuno_luno: I think this showsyour thinking is bad though - its almost always a bad idea
12:25:27 <kuno_luno> davean: Where??
12:25:27 <kuno_luno> Oh. :-/
12:25:27 <glguy> There's no simple fix for 'j', it's just the wrong approach
12:25:31 <Xyliton> I thought they you can also define addition and multiplication for types?
12:25:37 <nitrix> Xyliton: e.g. True is of type :: Bool.
12:25:39 <davean> kuno_luno: it almost definately means you haven't found the right type for 'a'
12:25:43 <nitrix> Xyliton: Bool being the set {True, False}
12:26:00 <nitrix> data Bool = True | False
12:26:09 <davean> kuno_luno: you should sitdown and think more
12:26:21 <reactormonk> Is there a way to add a custom message when a specific typeclass is not found?
12:26:38 <glguy> reactormonk: Do you mean typeclass instance?
12:26:39 <nitrix> Xyliton: You could, if you want the type to belong in the Num type class, implement the instance for (*) and (+) yeah.
12:26:43 <monochrom> @quote monochrom river
12:26:43 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
12:26:43 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
12:26:43 <lambdabot> show the_boolean, show the_character, show the_integer]
12:26:46 <reactormonk> glguy, yeah.
12:26:46 <nitrix> Xyliton: Int does this for example.
12:27:32 <kuno_luno> So, glguy, what I want is to make a list of workers, where each worker needs to have state (StateT), the states are different for each worker, but the state is maintained by the caller. That is, the caller can initate them (using def from Data.Default), call each one in turn, and remember their states for the next invocation...
12:27:33 <glguy> reactormonk: Yes, you can use OverlappingInstances and GHC.TypeLit's TypeError
12:27:45 <Xyliton> so, to give an example (just to see if I finally understood it): ComplexNumber = ComplexNumber Float Float. This would define a type called ComplexNumber which describes all the complex numbers possible to achieve with floats, right?
12:27:56 <nitrix> Xyliton: So does Double and Integer. They have an instance of the Num type class, which allows you to do use (+) or (*) on values of that type.
12:28:04 <davean> kuno_luno: then why isn't the def internal?
12:28:20 <kuno_luno> davean: huh?
12:28:21 <reactormonk> glguy, why would oyu need the overlapping instances?
12:28:38 <davean> kuno_luno: why does the caller call def instead of the thing that knows what type it wants to be?
12:28:45 <glguy> Because you'll need that to make an extremely generic instance that results in the custom error message
12:28:53 <glguy> and then all the non-error instances will overlap with it
12:28:56 <S11001001> kuno_luno: if your workers have existential state type, you need to box up the state together with them
12:29:08 <nitrix> Xyliton: You'd obtain the product of all possible values of type Float, with all possible values of type Float, and that'd give you a very large set of values for the type ComplexNumber introduced.
12:29:32 <nitrix> Xyliton: e.g. {ComplexNumber 0.0 0.0, ComplexNumber 0.0 0.00001, ....} and so on.
12:29:34 <glguy> reactormonk: Example: http://hackage.haskell.org/package/gi-gobject-2.0.11/docs/GI-GObject-Objects-Object.html#t:IsObject
12:30:06 <kuno_luno> davean & S11001001 The parent needs to maintain the state. That is, call a worker's action with the worker's previous state. Am I not thinking about thi s the right way??
12:30:15 <Layl> Arrghg, the haste readme says to look at "doc/js-externals.txt", which doesn't exist anymore
12:30:24 <Xyliton> nitrix: isn't float just like integers, but with decimal points added?
12:30:27 <S11001001> kuno_luno: keeping a separate list of states won't work, unless you introduce existential hlist type. That still ties the value representing workers to the value representing states
12:30:51 <nitrix> Xyliton: Did I accidently hint something else?
12:31:11 <kuno_luno> S11001001: I think maybe I see what you mean. The parent should maintain the WORKERS as states?? That might just be it!
12:31:13 <Xyliton> nitrix: whoops, no, I just messed up
12:31:50 <Xyliton> nitrix: but why the product? (unless I just derped another time and misinterpreted the word "product")
12:32:04 <nitrix> Xyliton: Can you join #haskell-beginners :) ?
12:32:09 <Xyliton> sure
12:32:24 <kuno_luno> S11001001 So each worker "changes" after every invocation. I guess I wasn't thinking OOP enough -- I forgot I could keep functions AND state on the workers! :-D
12:32:41 <infandum> So is there a generic zipWith (not a zipList)?
12:32:47 <infandum> in base
12:32:58 <kuno_luno> Thank, S11001001, nitrix, and davean. :-)
12:33:11 <dfeuer> Generic zipWith?
12:33:28 <infandum> zipWithN
12:33:31 <glguy> infandum: There's ParallelListComp extension, kind of a generic zipWith
12:33:43 <dfeuer> There's MonadZip, which has a most unfortunate Monad constraint.
12:35:01 <infandum> dfeuer: How does that work?
12:35:23 <infandum> oh sorry, I think you thought I meant something else by generic
12:35:43 <Edith> @pl \(x:y:ys) = y : x : ys
12:35:43 <lambdabot> (line 1, column 11):
12:35:43 <lambdabot> unexpected "="
12:35:43 <lambdabot> expecting operator, pattern or "->"
12:35:49 <Edith> @pl \(x:y:ys) -> y : x : ys
12:35:49 <lambdabot> ap ((`ap` tail) . (. head) . flip ((.) . (:)) . (:) . head) tail
12:36:12 <monochrom> "generic" is too generic.
12:36:36 <monochrom> data Generic = forall a. GCtor a
12:36:49 <Edith> @pl \(x:y:ys) -> y : (f $ x : ys)
12:36:49 <lambdabot> ap ((`ap` tail) . (. head) . flip ((.) . (:)) . (f .) . (:) . head) tail
12:37:07 <infandum> no, drat, I need something else
12:37:40 <infandum> I just realized what I really need is a lot more difficult
12:38:34 <infandum> basically, zipWithN f as bs cs [rest]
12:38:56 <infandum> as is, rest is a list of more lists
12:39:04 <infandum> and as bs cs are all lists of different types
12:39:06 <infandum> wow what a mess
12:39:27 <glguy> Edith: You can play with @pl in /msg lambdabot
12:40:01 <monochrom> And the upshot is, if f is 4-ary, then zipWithN f as [bs,cs,ds] = zipWithN f as bs cs [ds] = etc
12:40:32 <monochrom> that is so bloody vararg in multiple dimensions
12:40:51 <infandum> wait
12:40:52 <infandum> wait
12:40:53 <infandum> YES
12:41:04 <infandum> thank you! wow I can't believe I didn't see that
12:42:19 <infandum> it was all so simple this whole time
12:42:25 <Edith> glguy: Ok, thank you
12:50:39 <Ternary> Does anyone know anything about creating foreign libraries?
12:51:23 <hpc> as in to call haskell from c?
12:51:32 <Ternary> Yes
12:51:50 <Ternary> Dynamically, not compiled with the C
12:52:17 <Phyx-> sure
12:52:23 <hpc> search for "foreign export" in the documentation for the FFI
12:52:59 <Phyx-> also, search for building dynamic libraries in the GHC manual.
12:53:18 <Ternary> I've been through all the documentation, but whenever I do what it looks like I'm supposed to be doing (ghc -dynamic -shared -fPIC), I get runtime errors
12:53:29 <Ternary> undefined symbols in libHSghc-prim
12:53:38 <Phyx-> which symbol?
12:53:59 <hpc> that's a whole different issue than "how do i foreign library"
12:54:44 <Phyx-> On linux, the rts isn't linked into the final so. so you have to load the rts before your library if I remember correctly
12:54:56 <hpc> you have to link in the rts, and you have to start it
12:55:00 <hpc> it doesn't just run on its own
12:55:34 <Ternary> Well I figured I'd open with checking if anyone had experience with it
12:55:55 <Ternary> I did get it to work with manual linking, but does that mean I have to distribute the entire rts with my program?
12:56:07 <Ternary> Why don't regular binaries need that?
12:56:30 <Phyx-> static binaries will have a copy of the rts linked in
12:56:41 <Phyx-> dynamic ones need the rts lib distributed
12:57:09 <hpc> even binaries compiled from c have their own rts (though obviously much more minimal)
12:57:14 <reactormonk> Is there a way to have specific code / files compile on ghc versions?
12:57:21 <reactormonk> ... specific ghc versions
12:57:37 <Phyx-> reactormonk: in?
12:57:41 <hpc> reactormonk: within the same project?
12:57:45 <reactormonk> hpc, yeah.
12:57:51 <Ternary> Can I do the same thing with my library? Compile the more minimal version of the rts into it?
12:57:58 <hpc> i would start by questioning what you are doing
12:58:07 <hpc> because having multiple active ghcs at a time is rarely the solution
12:58:26 <reactormonk> hpc, library supporting different ghc versions, TypeError is pretty new.
12:58:27 <hpc> no
12:58:29 <Phyx-> reactormonk: do you mean at the library or source level?
12:58:41 <hpc> to run code compiled by ghc, you need the ghc rts
12:58:49 <mbw> Hello. I was trying to build https://www.stackage.org/package/hsdev . After an initial 'stack install' failed, I tried 'stack unpack, stack init, stack solve, stack build'. It will use resolver 6.27, add 4 external dependencies, and ultimately building fails. The corresponding logfile itself only shows warnings about tab characters and missing LICENSE files, whereas stack suggests an indication about which 
12:58:55 <mbw> source file contains the Main module is missing in the .cabal file. There are several issues which I find weird. 1. Latest Version on stackage is 0.2.0.0, latest on hackage is 0.2.1.0., which seems to be what 'stack unpack' pulls. 2. There is a succesfull build report here https://hackage.haskell.org/package/hsdev-0.2.1.0/reports/ , but I have no idea on how to reproduce it. Use cabal directly? 3. The 
12:58:56 <hpc> either statically linked into the executable file, or dynamically linked and distributed alongside it
12:59:01 <mbw> directory structure differs from what is found in the git repo. I am probably doing something fundamentally wrong again, no?
12:59:05 <reactormonk> Phyx-, I wanna use TypeError, but skip as needed to make sure old ghc versions can still compile it.
12:59:18 <Ternary> Alright, thanks
12:59:39 <hpc> reactormonk: this might be a good chance for you to learn stack, if you haven't already
12:59:44 <Phyx-> reactormonk: yes, it's used often in GHC's own source code. GHC ships a few version macros. You'll have to enable {-# LANGUAGE CPP #-} and then you can ifdef them out
12:59:52 <Phyx-> reactormonk: https://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
12:59:58 <hpc> among other things, it is able to manage its own versions of ghc for you
13:00:12 <reactormonk> hpc, can't really do that as a library author.
13:00:41 <pikajude> i need a datatype that can represent both cartesian and polar coordinates
13:00:44 <pikajude> at the same time
13:00:58 <hpc> oh, i see
13:01:05 <hpc> yeah, Phyx- has the answer then
13:01:15 <hpc> though you meant just being able to test the library on multiple versions
13:01:41 <Phyx-> reactormonk: or rather https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/intro.html#ghc-version-numbering-policy
13:03:20 <reactormonk> Can I ask spec to install test dependencies too?
13:03:34 <Phyx-> reactormonk: though since you're talking about TypeError, what you actually want to check, if the base version, not the ghc version,so #if MIN_VERSION_base(4,0,0) etc
13:03:43 <pikajude> oh, gloss already has this!
13:03:46 <pikajude> nice
13:04:32 <hpc> pikajude: gloss might be pulling it in from another package too
13:04:51 <pikajude> nah, it's just in the source code
13:05:01 <hpc> and polar/cartesian are really just two different apis to a generic cartesianCoordinates type anyway ;)
13:05:06 <pikajude> it's missing the ability to subtract a finite amount from the magnitude
13:05:13 * pikajude wishes he remembered geometry
13:06:26 <Layl> hm, I guess `setLoop :: (IO ()) -> IO ()` and `setLoop :: IO () -> IO ()` would have slightly different but important meanings
13:06:46 <glguy> No, they are identical
13:06:51 <Layl> oh
13:08:09 <glguy> Int, (Int), ((Int)) are all the same type. Parentheses only help to reassociate application of types, which is normally left associative
13:08:26 <Layl> aah right I'm being a bit confused on syntax, and I think meaning overall
13:08:46 <glguy> f x y --is--  (f x) y,   but we can write   f (x y)   and get a different meaning
13:09:02 <glguy> but that's the extent of what the paretheses mean
13:09:03 <Layl> glguy: would `Int` as a parameter take a function that produces an Int as well as equivalent?
13:09:22 <glguy> No, Int and a -> Int   are quite distinct from each other
13:09:34 <glguy> or maybe you mean something else
13:09:44 <Layl> essentially what I'm trying to do is register a callback in JS
13:09:57 <reactormonk> Uhm, how would you write tests for type errors?
13:10:02 <Layl> `setLoop = ffi "(function(func) {module.exports.loop = func;})"`
13:10:02 <mbw> Their the same up to isomorphism :P
13:10:11 <Layl> so I'm wondering what type setLoop should take as parameter to make that happen
13:10:31 <Layl> currently it takes `IO ()` which I think only works by accident
13:10:53 <Layl> because all the function I'm passing right now does is `putStrLn "Hello from tick!"`
13:12:41 <reactormonk> What's the simplest function to summon an arbitrary typeclass?
13:13:03 <merijn> reactormonk: What does "summoning a typeclass" mean?
13:13:14 <EvanR_> Layl: you can close over arbitrary data needed for the callback, "IO () can do anything"
13:13:24 <reactormonk> merijn, sorry, scala speak. I want to write a function that requires a specific typeclass.
13:13:37 <hpc> it costs 20 mana and you can only have 3 at a time
13:13:43 <hpc> :t (+)
13:13:45 <merijn> reactormonk: Typeclass instances are, unlike Scala, globally unique
13:13:45 <lambdabot> Num a => a -> a -> a
13:13:51 <hpc> ^ like that
13:13:59 <merijn> reactormonk: So there is no notion of a "specific" typeclass
13:14:08 <Layl> EvanR_: the tricky thing is that this function will need to access JS data, it has some form of input that I can't give it as a parameter
13:14:11 <nate_> I have a "StateT a Maybe b" that I would like to call a function on until isNothing is true, returning the last Just value.  I can't figure out how to use "until" to accomplish this.  Is there another way?
13:14:19 <reactormonk> merijn, ah, good to know. That would explain a few design decisions... and also why scalac is slow.
13:14:43 <Layl> essentially, the function has to be re-executed every time, it's not a "pure" function
13:15:01 <EvanR_> Layl: an IO () isnt a function
13:15:06 <Layl> I know that
13:15:08 <Layl> that's the problem
13:15:25 <hpc> :t \_ -> putStrLn "foo"
13:15:26 <lambdabot> t -> IO ()
13:15:28 <EvanR_> so provide whatever it needs "each time" as part of its closure
13:15:31 <merijn> reactormonk: The advantage is that you never have to worry about "which instance", because there is only one (unless you try really hard and it will quickly blowup in your face ;))
13:15:59 <Layl> EvanR_: I'm not sure I understand, the part where the callback is registered will only run once
13:16:10 <EvanR_> sounds good
13:16:21 <EvanR_> do you want to register it over and over?
13:16:42 <Layl> no, I want it to register once but the actual data from JS has to get into the function somehow
13:16:52 <merijn> nate_: I don't think there is a simple way to accomplish that using until, probably easier to do the recursion by hand
13:17:03 <Layl> that data isn't provided as arguments, it's in global objects that change every time the callback's called
13:17:10 <EvanR_> Layl: you access it within the action
13:17:16 <ph88> between haskell.org and haskell-lang.org which was the old and which was the new website ?
13:17:25 <Layl> EvanR_: what would "within the action" mean here?
13:17:29 <EvanR_> you know like jquery $('whatever i want')
13:17:29 <merijn> ph88: haskell.org is the "old" one
13:17:43 <EvanR_> thats effectively an IO action
13:17:50 <ph88> it looks newer ^^
13:17:55 <merijn> Layl: Well, why do you think that's a problem?
13:17:58 <nate_> merijn: yeah, I didn't think so.  It wasn't clear, though, how to access the "Maybe" from within the "StateT".  I seem to only be able to access the "b"
13:17:58 <Layl> EvanR_: so I need to pass the data from the JS side, using a JS closure?
13:18:07 <geekosaur> it's not old vs. new, it's some kind of political stupid
13:18:08 <merijn> nate_: Yes
13:18:09 <reactormonk> so testTC :: Foo () => () should fail if there is no typeclass instance of Foo (), right?
13:18:18 <Layl> merijn: if the function's only evaluated once nothing changes the second time it runs
13:18:32 <EvanR_> Layl: if its coming from the DOM, that makes no sense. you need to query it from inside the callback
13:18:47 <merijn> ph88: haskell.org was redesigned, some people involved in the redesign disagree with the politics behind haskell.org, they threw a fit, withdrew their design and a slightly different one was adopted
13:19:06 <Layl> EvanR_: there's no DOM in the context it's running in, it's running in a weird node.js environment
13:19:14 <Layl> but, equivalent thing basically
13:19:20 <EvanR_> how does a JS callback run without a JS context
13:19:25 <Layl> I think my problem is that I simply don't understand how the code that would do this would look like
13:19:30 <theduke> there are quite a few web server options out there... I'm writing an API server and basically all I need is: routing and handlers for reading and responding JSON (+ a helper for file uploads and serving files from disk would be appreciated). nothing more. any recommendations for a fast and well-maintained library?
13:19:33 <ph88> merijn, which one should i show to people who want to know about haskell ?
13:19:51 <Layl> EvanR_: it's running in node.js, there's no document for there to be a DOM of
13:19:59 <mbw> At what specific point is build failure with 'stack unpack x', 'stack init', 'stack resolve (--update-config)' and 'stack build' considered a bug? And what's the difference between 'stack init' and 'stack init --resolver'?
13:20:03 <EvanR_> Layl: now im sort of confused, what does this have to do with haskell
13:20:28 <Layl> EvanR_: I'm compiling Haskell to JS using Haste
13:20:39 <Layl> that JS' supposed to be running in a node.js environment
13:20:42 <glguy> ph88: Which ever one you like better. Haskell.org is still the main website. If you like something about haskell-lang.org you can share that, too
13:20:46 <EvanR_> Layl: so, where do you think the data is supposed to come from?
13:20:59 <nate_> marijn: is it possible to access the Maybe inside StateT?  If so, how?
13:21:01 <Layl> EvanR_: the data's provided in the node.js enviornment as objects in global
13:21:12 <EvanR_> ok, then use need to give yourself access to the global env 
13:21:18 <EvanR_> as an IO action
13:21:27 <nate_> merijn: is it possible to access the Maybe inside StateT?  If so, how?
13:21:31 <merijn> nate_: Not really
13:21:36 <merijn> nate_: Note the following:
13:21:42 <merijn> @unmtl StateT b Maybe x
13:21:42 <lambdabot> b -> Maybe (x, b)
13:21:53 <EvanR_> Haste might have something like that built in
13:21:56 <Layl> EvanR_: I see, the Haste docs on FFI are a bit lacking so I'm not sure how to do that
13:21:57 <merijn> nate_: You can't really get the result of a function without running it :)
13:22:01 <EvanR_> if not you have to make bindings of some sort
13:23:33 <nate_> merijn: I'm happy to run the function, I just need the final result.  I thought about doing it within [], but I couldn't wrap my head around that.
13:23:35 <Layl> EvanR_: would such a binding function have as return type "IO JSAny"? I know the JSAny part for sure but it's the IO I'm not sure of
13:24:00 <merijn> nate_: Can you lpaste the code you're trying to do this with?
13:27:03 <nate_> merijn: Prooooobably not easily.  It's pretty huge and interwoven.  Ultimately, I want to iterate a function from within StateT, passing its result back in, until the function fails, at which point I would return the previous value.  So, pretty much like "until"
13:27:37 <merijn> nate_: If you have a huge existing StateT b Maybe bit, then you'll probably want to repeatedly "runStateT" and check if you get Nothing or Just
13:27:43 <merijn> nate_: And then keep the last Just
13:28:30 <EvanR_> Layl: sure, sounds good
13:28:40 <nate_> merijn: Won't that not use the same state?  I need the state to be preserved.
13:29:00 <merijn> nate_: Sure, but runStateT returns the state, so just pass the old state in as start
13:29:39 <nate_> merijn: Huh, yeah.  Fair point.  And you think that's probably the simplest way to do this?
13:30:04 <Layl> EvanR_: alright that's one part of the puzzle then, then say I wanted to pass the result of that into another function, since it returns an IO JSAny rather than a JSAny, how would I do that (I realize this is an extremely basic Haskell question, but that's the level I'm currently at)
13:30:48 <merijn> nate_: tbh, just using a function would be simpler than repeated runState calls, but since you said you have a large amount of code I will assume the current "StateT" is not a trivial function, so yes. Simplest to just repeatedly runState
13:31:06 <EvanR_> Layl: right, to link a IO a to an a -> IO b, you use do notation or >>=
13:31:17 <sm> ph88: it's your call, the community does not agree on this
13:31:36 <ph88> this is about stack and haskell platform isn't it ?
13:31:56 <merijn> ph88: Amongst other things, yes
13:32:46 <Layl> EvanR_: >>= create a thread of functions and do a monadic operation, right?
13:32:52 <nate_> merijn: Correct, the StateT is smeared over some 20 mutually-recursive functions in this module, and I only call evalStateT in the interface
13:33:13 <merijn> nate_: Right, then just repeatedly runStateT is easier than rewriting everything ;)
13:33:49 <EvanR_> :t (>>=) -- Layl 
13:33:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:33:55 <merijn> nate_: case runStateT act s of Nothing -> return oldS; Just s -> {- call again with new state -}
13:34:01 <nate_> merijn: Hey, that's why I asked.  My gut said there was probably something "elegant" I was missing, but I can live with "works"
13:34:47 <Layl> EvanR_: that result doesn't tell me much right now, either way I saw that the do notation does get me what I want I think
13:34:59 <merijn> nate_: In general for this sorta thing you can have a look at the monad-loops package, but I don't think it has this specific one
13:35:32 <EvanR_> Layl: in particular (>>=) :: IO a -> (a -> IO b) -> IO b
13:35:53 <EvanR_> action 1, handler-for-action-1's-result, combine!
13:36:16 <EvanR_> do notation is just syntactic sugar for that
13:36:40 <nate_> merijn: I tried a couple things in monad-loops, and started to tear my hear out because it was just slightly the wrong screw thread, as it were...
13:37:07 <merijn> nate_: Yeah, Like I said, you can't really check for "Just" vs "Nothing" without running the State :)
13:37:13 <Layl> EvanR_: I just verified that I am indeed getting the result I want, and can access changing variables
13:37:24 <Layl> Thanks for the help, this is a lot of fun to get working actually
13:37:31 <nate_> merijn: I think I am now comfortable with that.  Thank you for the assistance!
13:37:49 <Layl> I've been meaning to learn haskell, this is a perfect excuse to do so :P
13:40:05 <glguy> merijn: one minor work around for detecting the failure: untilFailure m = (m >> untilFailure m) <|> pure ()
13:40:47 <glguy> (though I think that the repeated use of runStateT is the cleanest)
13:40:50 <merijn> glguy: It's too late and I've had too much beer to decide whether that's obvious :)
13:40:53 <Layl> Funnily enough, I tried haskell years ago and couldn't get into it
13:41:02 <Layl> Since then I got really deep into Rust
13:41:13 <merijn> Layl: Took me 3 attempts before it stuck ;)
13:41:15 <Layl> And now things just seem to sortof click in my head, Rust's a gateway language :P
13:41:42 <merijn> Layl: Rust is simultaneously very different and very much the same :)
13:42:17 <merijn> ugh, time for the hardest task of the day...invent a good name for a type
13:42:23 <Layl> Type342032
13:42:25 <Layl> problem solved
13:42:49 <merijn> @quote first.26
13:42:50 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
13:42:59 <Layl> my programming teacher had a saying, there's only one hard things in programming
13:43:03 <Layl> naming things and off by one errors
13:43:25 <merijn> Layl: Oh, I heard it as "two hard things: naming things, cache invalidation, and off by one errors" :)
13:44:25 <Layl> merijn: I would extend it to "two hard things: naming things, cache invalidation, off by one errors, and buffer overflows#@da,#@*()ADM@#)@"
13:44:53 <merijn> buffer overflows are easy
13:44:59 <merijn> Just don't use an unsafe language >.>
13:45:10 <monochrom> hahaha "only one ... off by one errors"
13:45:42 <lyxia> Does haskell have type level floating point operations
13:45:47 <monochrom> No.
13:45:56 <monochrom> Thank God.
13:46:04 <lyxia> I want to implement generic-random in the types.
13:46:10 <lambdabot> You're welcome.
13:46:15 <monochrom> hahaha
13:53:18 <aravart> I had a really noobish question... I'm trying to take an infinite list, drop half the elements at random, take the first however many... dropHalf = filterM (const (fmap (< 0.5) (randomIO :: IO Float))). But liftM (take 10) (dropHalf [1..]) doesn't terminate.
13:53:35 <aravart> There's something about laziness+IO I don't understand.
13:54:26 <merijn> lyxia: God, you have no idea what kinda rat's nest you dodged by Haskell not having type level floats...
13:54:53 <aravart> On the other hand... liftM (take 10) $ ((return [1..]) :: IO [Int]) works just fine.
13:55:46 <jle`> aravart: rembember that fmap for IO doesn't change the effects of the action
13:55:54 <monochrom> aravart, it is best to assume that IO is not lazy.
13:56:14 <jle`> aravart: if an IO action needs to do an infinite amount of IO to generate something
13:56:18 <jle`> then fmapping over it won't change that
13:56:18 <Layl> oh my god ha ha, I submitted an issue to Haste about the missing FFI docs file that's mentioned in the readme
13:56:21 <merijn> I don't get why everyone seems to think IO is lazy, there's like 4 or 5 lazy IO operations in base, max
13:56:23 <Layl> my issue number for it is 404
13:56:28 <jle`> that's sort of the "point" of IO and sequencing IO
13:56:31 <glguy> aravart: You can generate an "infinite" [Bool] with randoms, and then combine that with your fininite list
13:57:36 <glguy> keepSome g xs = go (randoms g) xs where go (True:xs) (y:ys) = y : go xs ys; go (False:xs) (_:ys) = go xs ys
13:57:37 <monochrom> merijn, our propaganda people have done too great a job to promote "haskell is great! there is much laziness! functions compose magically and do what you want magically!"
13:57:49 <jle`> aravart: you might be creating an IO action that does an infinite amount of IO actions
13:58:02 <jle`> er, that does an infinite non-terminating sequence of effects
13:58:19 <jle`> fmap over IO says, "give me a new action with the same effects, but with this function mapped over the results"
13:58:37 <jle`> `fmap (const 1) (forever (putStrLn "hello"))` will still print "hello" forever
13:59:08 <monochrom> So successful that the audience are taken in and complete forget the obvious empirical observation that "main = getLine" does not postpone demanding input from you, and "main = putStrLn blah" still produces output even if you are not looking.
13:59:25 <glguy> monochrom: How can we know??
13:59:49 <monochrom> :)
14:00:12 <merijn> glguy: We pay a grad student to look for us
14:00:23 <glguy> OK, that makes more sense
14:00:45 <Layl> god help us if we run out of grad students, we will never be able to collapse superpositions anymore
14:01:11 <merijn> Shit...I am a grad student...
14:01:21 <InferiorCoder> anyone here know how to calculate the Q in a kalman filter? should it be continously updated?
14:01:29 <merijn> Layl: You don't run out of grad students
14:01:37 <merijn> Layl: You just run out of grants to pay them
14:01:43 <InferiorCoder> that is... the 'variance of process model noise'
14:04:31 <aravart> glguy, an infinite IO [Bool] and then return [a] and lift some kind of zip function over them?
14:04:55 <glguy> aravart: No IO at this point, did you see the "keepSome" code I pasted?
14:05:16 <sm> IO is the easiest way to *prevent* laziness (print the thing) :)
14:05:18 <aravart> glguy, now i did thanks
14:05:31 <glguy> aravart: You can get a StdGen with newStdGen :: IO StdGen
14:08:25 <ph88> why is there a  stack install  but no  stack uninstall  ?
14:09:19 <sm> the underlying tools don't support uninstall (ghc-pkg)
14:09:46 <monochrom> Patches welcome.
14:09:54 <Koterpillar> ph88: for uninstall, remove the binaries from ~/.local/bin?
14:10:10 <sm> I guess because it takes more work to know what uninstalls can be done safely
14:10:14 <Koterpillar> ph88: unbuild is problematic, because packages are shared
14:10:21 <Koterpillar> stack gc would be nice
14:10:24 <monochrom> But stack doesn't do ~/.local/bin
14:10:24 <ph88> ooh like that
14:10:36 <ph88> ah ye i guess stack can't know about the other projects
14:10:40 <Koterpillar> monochrom: it does
14:10:50 <monochrom> OK!
14:11:07 <geekosaur> yeh, that's where it "stack install"s binaries
14:12:58 <dmwit> `randoms` is fine as long as you treat its generator argument as unusable. This is very easy to screw up.
14:13:30 <DemiMarie> I was looking through the source code of the process package and it seems like it has a bug in it
14:14:36 <monochrom> dmwit: Is that "un-reusable" or is it really unusuable? :)
14:15:40 <merijn> DemiMarie: not entirely unlikely
14:16:08 <DemiMarie> merijn: https://github.com/haskell/process/issues/83
14:19:05 <Layl> am I committing a cardinal sin if I set a JS value from haskell
14:19:12 <aravart> glguy++ thanks. i will write it with a RandomGen. That's easy to understand.
14:19:24 <DemiMarie> Layl: JS = JavaScript?
14:19:29 <Layl> DemiMarie: yes
14:22:08 <EvanR_> Layl: if its in IO, nobody can say anything
14:22:11 <DemiMarie> Layl: What JS engine are you using?
14:22:23 <Layl> DemiMarie: V8, the code's it's running inside node
14:22:28 <Layl> *the code's running inside
14:23:36 <EvanR_> DemiMarie: Haste
14:23:48 <DemiMarie> Layl: As long as it is in IO you are fine.  With some JS engines (ChakraCore, JavaScriptCore, SpiderMonkey) you would hit problems as soon as the JS engine did a GC, but not in this case.
14:24:02 <DemiMarie> EvanR_: explain?
14:24:12 <EvanR_> you asked what Layl is using
14:24:30 <DemiMarie> EvanR_: Ah
14:25:05 <DemiMarie> I thought that Layl was using Haskell bindings to the V8 C++ API.
14:25:14 <DemiMarie> hence my comment about GC
14:25:53 <Layl> hmmmm...
14:26:12 <EvanR_> that sounds mildly terrifying
14:26:15 <Layl> I could mess around with emscripten to call into V8 from Haskell running in V8
14:26:35 <Layl> now, I'm not sure exactly *why* would do this
14:26:54 <Layl> I'm sure there's a good reason for it
14:26:59 <Layl> perhaps to try to win a dailywtf contest with it
14:27:18 <DemiMarie> Layl: I was thinking of using V8 as a C++ library, writing C wrappers for the API functions, and then calling them from Haskell via the FFI.
14:27:41 <merijn> DemiMarie: ...why ?!?
14:28:03 <DemiMarie> merijn: So you can use JS to script your Haskell application
14:28:19 <EvanR_> you should use haskell to script the haskell application
14:28:26 <merijn> DemiMarie: I refer to my previous question ;)
14:28:47 <DemiMarie> EvanR_: true, but what if your clients don't know Haskell, but do know JS?
14:29:04 <monochrom> Use Haskell to write a JS interpreter.
14:29:13 <DemiMarie> monochrom: That's sloooooooooooooooow.
14:29:46 <Koterpillar> and not DRY
14:29:48 <EvanR_> what if clients are used to the speed of rails
14:29:57 <DemiMarie> EvanR_: make that Node
14:30:50 <EvanR_> then they might welcome the speed of haskell
14:31:56 <DemiMarie> EvanR_: That's assuming that they know Haskell
14:32:14 <DemiMarie> There are (unfortunately) far more JS programmers than Haskell programmers
14:32:40 <glguy> OK, DemiMarie can script the application with rails or JS and ... merijn can use Haskell
14:33:14 <DemiMarie> glguy: I would rather use Haskell too.  It's just that in some cases business realities would not allow it.
14:33:31 <glguy> OK, let the record show that DemiMarie is flexible
14:33:34 <glguy> :-p
14:35:11 <Layl> can I add a compile option to a .cabal file?
14:35:21 <Layl> I've got a need to add a specific option
14:35:36 <monochrom> You know, at the beginning, "everyone" knew Java and "no one" knew Javascript. So you would that all webapps were Java Applets and no one would use Javascript for the same purpose, right?
14:35:49 <monochrom> s/you would that/you would predict/
14:35:50 <glguy> That was the beginning?
14:36:13 <monochrom> Yes! Relativity says that every point could be the beginning :)
14:37:52 <DemiMarie> monochrom: Nope!  From the perspective of anyone moving slower than light, and given two events A and B such that a signal from A could have reached B travelling slower (or at the same speed) as light, the observer will observe that A happened before B.
14:39:13 <monochrom> Oh bother, so Haskell could have been invented before Turing machines...
14:40:17 <Layl> how can I excape a "--" in a cabal file?
14:40:20 <Layl> *escape
14:40:38 <EvanR_> in GR you cant make statements like that
14:41:19 <Layl> seems code highlighting was just pretending the string was commented out, neverind
14:41:36 <monochrom> Use – (U+2013 en dash) instead
14:51:45 <EvanR> how do you go about proving a particular turing machien doesn't halt
14:52:49 <monochrom> Let me think what are the usual approaches.
14:53:05 <nshepperd> find a loop, and prove an invariant that makes the exit condition always false
14:53:22 <Gurkenglas> You find a turing machine that transforms each input of a universal turing machine into an input of yours such that the outputs are equivalent
14:54:22 <monochrom> It does depend on the machine because there are usually two different classes of non-halting machines. One satisfies an invariant and the invariant causes "I can go on again". The other satisfies an increasing variant and it causes "I have to work harder again".
14:54:46 <monochrom> The respective examples being "f x = f x" and "f x = f (x+1)"
14:55:25 <EvanR> increasing variant, interesting
14:55:38 <Gurkenglas> aka reduction to halting problem. unless you mean given a particular input?
14:55:52 <EvanR> wait, what is Gurkenglas solving
14:56:08 <monochrom> Gurkenglas is solving a much more general problem than yours.
14:56:09 <Gurkenglas> *from halting problem. also yea looking at it again that doesn't look like what you asked. Sorry just woke up.
14:57:52 <EvanR> busy beaver numbers are defined in terms of "n-state machines that halt" the only way i see to set that up for some n is to prove half of them halt and the other halt dont (not necessarily to scale)
14:57:58 <Gurkenglas> ("There is no turing machine that solves the halting problem and always halts, so one way to prove your machine doesn't always halt is to make it the last component of a halting oracle, the other components of which always halt")
14:58:06 <EvanR> i asssume this means we chose some input uniformly
14:58:39 <Gurkenglas> *"a component", I guess.
15:00:24 <EvanR> "doesnt always halt" wouldnt help in that case
15:00:55 <monochrom> I think I misstated and misthought the two classes.
15:00:57 <Gurkenglas> You can't in general compute the nth busy beaver number, of course. Busy beaver grows faster than every computable function by definition.
15:00:58 <EvanR> it needs to split into always halts and alwyas doesnt halt
15:01:31 <EvanR> dunno about by definition, but i saw the proof
15:01:32 <Gurkenglas> No, remove the always quantor, you are choosing some particular input for all machines, say epsilon.
15:01:46 <monochrom> The first class should be: from the initial config you will reach a certain config X. From X you will reach X again.
15:02:06 <EvanR> a loop seems like the easiest situation
15:02:51 <Gurkenglas> The second class can be refactored into a splitting of the configs into equivalence classes between which you prove a loop again?
15:03:18 <monochrom> Yes but I think it begs the question.
15:03:33 <EvanR> and hard situation seems like, machine encodes something about an unresolved question in math
15:03:40 <EvanR> i dont know what "hardest" siutation is
15:04:30 <EvanR> maybe hardest is cant be proved or disproved to halt in the one true foundation of math from across the hall
15:04:57 <Gurkenglas> For each axiom system, there's a busy beaver number whose value you can't prove
15:05:06 <monochrom> For example "f 0 = 0; f x = f (x+1)". Sure it will end with two equivalence classes, "0" and "positive numbers". But how did you know this split in the first place?
15:05:08 <nshepperd1> Well, the second class can be from the initial config you reach config X(n). From config X(n) you reach config X(n+1)
15:05:21 <Gurkenglas> (unless it's complete, in which case it's inconsistent, etc)
15:05:39 <nshepperd1> A co induction sort of thing?
15:05:51 <monochrom> Whatever reason you found to do that splitting, you can use that reason directly to prove non-termination and skip the splitting business.
15:05:54 <EvanR> Gurkenglas: specifically because turing machines can talk about integers?
15:06:10 <Gurkenglas> Related: BB(8000) is independent of ZF http://www.scottaaronson.com/blog/?p=2725
15:06:46 <EvanR> wait, the specific numbers depend on the axiom system?
15:06:56 <EvanR> (in addition to details of turing machine)
15:07:18 <EvanR> or the answers to what halts or doesnt depends on the axiom system
15:08:24 <monochrom> Yes nshepperd1.
15:09:43 <nshepperd1> monochrom: i think the equivalence classes here are just whatever sets of states you can make a useful uniform theorem about
15:11:02 <nshepperd1> Which is easy for a mathematician to see, maybe not so easy for an algorithm to quantify what is "useful"
15:12:29 <EvanR> "your programs are no good here, we only accept arguments"
15:15:07 <EvanR> the value of valid arguments is guaranteed (up to the nth busy beaver number) by the central bank of ZFC
15:15:53 <EvanR> who has never defaulted (yet) 
15:16:49 <Gurkenglas> Afaik the dichotomy between axiom systems is always between "doesn't halt" and "you can't prove it doesn't halt"
15:17:09 <Gurkenglas> No two consistent ones should prove you different running times
15:17:30 <EvanR_> makes sense
15:17:50 <EvanR_> otherwise that stands as a relative inconsistency
15:27:27 <bentanweihao> Ohai! I have a Spacemacs + Haskell question
15:27:28 <roconnor> EvanR: BB(8000) is a well defined specific number.  It's just that for every numeral n, the set theory formula for 'BB(8000) = n' is unprovable in ZF(C).
15:27:36 <bentanweihao> I can't seem to get into debug mode
15:27:54 <roconnor> EvanR_: some people will argue that BB(8000) isn't a well defined number, and they are wrong. ;)
15:28:28 <bentanweihao> I'm getting "wrong type argument commandp, haskell-debug"
15:29:38 <EvanR> roconnor: is there a set of axioms which let you prove what BB(8000) is
15:31:45 <magneticduck> roconnor: that's not quite true -- I think I might be able to prove that "BB(8000) = 0" is false
15:31:49 <EvanR> if its value is relative, that would be a sign of non well defined ness
15:31:49 <EvanR> or non specificness rather
15:32:08 <roconnor> magneticduck: I carefully worded my claim to cover that case.
15:32:44 <roconnor> EvanR: Yes, there is some axiom of the form 'BB(8000) = n' that you can add and the system will be consistent and sound.
15:33:12 <roconnor> (I'm guessing that 'BB(8000) = n' is a Pi_1 axiom, so soundness and consistentcy are probably the same in this case)
15:33:22 <magneticduck> "unprovable", alright
15:33:55 <EvanR> what, is n a placeholder for some numeral, or literally a meaningless symbol n
15:34:01 <roconnor> magneticduck: I had to catch myself to avoid making that mistake.
15:34:18 <roconnor> n is a placeholder for some specific numeral.
15:34:52 <roconnor> One of these axioms is true.  It's hard to know which one. ;)
15:35:03 <EvanR> i think ive seen arguments of this form before, and they made no sense
15:35:48 <roconnor> EvanR: after 10 years of careful study, I am now have the skills to make these ridiculous arguments.
15:37:33 <EvanR> i think i will stop at the place several miles back where we still need to know what it means to know which machines halt and which dont
15:37:47 <EvanR> and how axiomatics affects that
15:37:55 <lpaste> qmm pasted “No title” at http://lpaste.net/1796671664155525120
15:38:12 <qmm> ^ helpful if a few of you could chime in
15:38:13 <roconnor> Presumably the axioms don't change whether your program actually halts or not.
15:38:36 <roconnor> just what you can "prove" about them. (and your proof is meaningless if your axioms are unsound).
15:38:41 <EvanR> if it halts, presumably it doesnt change how long it takes to halt
15:38:51 <roconnor> right.
15:39:10 <EvanR> so i would find it interesting if we can patch up the picture by switching to different systems
15:40:02 <roconnor> If you assume your original system is sound, you can patch it up, but never completely.
15:40:12 <EvanR> no?
15:40:15 <aweinstock> 'BB(8000) = n' is provable in http://inutile.club/estatis/falso/
15:40:19 <aweinstock> (for all n)
15:40:36 <roconnor> Arithmetic is essentially incomplete.
15:40:55 <EvanR> im not talking about all n
15:41:30 <aweinstock> in case it wasn't clear, Falso is mathematician humour
15:43:14 <EvanR> how does adding "BB(8000) = n" which i dont even accept as valid, differ from adding "BB(8000) = 9" or whatever actual numeral that we know is wrong?
15:44:35 <roconnor> EvanR: will the difference is that ZFC can presumably prove that BB(8000) != 9.
15:44:53 <roconnor> so adding 'BB(8000) = 9' as an axiom would lead to an inconsistent, hence unsound, system.
15:45:02 <EvanR> how does = n avoid that
15:45:15 <roconnor> oh I don't mean a variable n.
15:45:17 <EvanR> since its not an actual value you have nothing to go on?
15:45:43 <roconnor> I just mean there is some specific for which ZFC doesn't prove 'BB(8000) != n'.
15:45:53 <roconnor> and if you add that axiom, you are golden.
15:46:00 <roconnor> We just don't know what it is.
15:46:06 <EvanR> it doesnt prove not equal
15:46:13 <roconnor> right.
15:46:16 <EvanR> so basically using excluded middle?
15:46:36 <roconnor> I'm working with excluded middle here, but it doesn't really matter.  This all works constructively too.
15:46:39 <aweinstock> is there a sense in which we can know what it is (e.g. relative to a stronger axiom system than ZF)?
15:46:43 <aweinstock> or at least bound it
15:46:59 <roconnor> (we can prove, even cosntructively that forall n m, n = m or (n != m) by using induction.
15:47:02 <EvanR> aweinstock: that is what i was asking, or at least trying to
15:47:19 <EvanR> how?
15:47:40 <EvanR> halts or doesnt halt isnt a thing
15:48:02 <roconnor> aweinstock: I'm not certain.  I suspect the answer is no.
15:48:32 <aweinstock> EvanR: can you elaborate on 'halts or doesnt halt isnt a thing'? that's just LEM, right?
15:48:57 <EvanR> the most recent point was, we can prove n = m or n!=m for all n, m constructively
15:49:19 <EvanR> so "just LEM" isnt on topic
15:49:46 <roconnor> The proof is just double induction.
15:49:56 <EvanR> and a constructive proof would amount to a program
15:50:15 <EvanR> oh, literally equality
15:50:18 <roconnor> we can also write a program to test if two numbers are equal or not.
15:50:25 <EvanR> i thought we were talking about beusy beaver numbers
15:50:39 <EvanR> how is this relvant
15:50:52 <roconnor> er, sorry it isn't relevent.  My mistake.
15:51:14 <roconnor> I forgot that 'BB(8000) != n' is notation for some universally quantified statement.
15:51:24 <roconnor> er, I forgot that 'BB(8000) = n' is notation for some universally quantified statement.
15:51:43 <aweinstock> existentially, rather?
15:52:02 <EvanR> for a given finite n, there may be some machines in the original basket which end up being independently halting or not, and so you cant exlcude them, messing up the whole "max" process
15:52:07 <aweinstock> do we agree on 'exists n. BB(8000) = n'?
15:52:34 <EvanR> i was saying, it would be interesting if you could switch systems to figure that out, then you get a max after all
15:52:38 <EvanR> thereby patching it up for that particular n
15:52:42 <roconnor> aweinstock: maybe not, since it isn't constructive
15:52:45 <EvanR> you said its incomplete
15:52:54 <roconnor> we can agree '~~exists n. BB(8000) = n' ;)
15:53:49 <EvanR> given the "particular n" context, what would that mean? or were you talking about the entire universe of supposed busy beaver numbers
15:54:49 <roconnor> It would be a numeral; one of 0, 1, 2, 3, 4, etc .
15:55:00 <aweinstock> is pushing negation through quantifiers a constructive technique? (i.e. '~forall n. ~(BB(8000) = n)')?
15:55:30 <roconnor> aweinstock: you can push through the existential like that, but not through the forall.
15:55:56 <EvanR> there exists x s.t. not P x implies not all x satisfies P x
15:56:00 <EvanR> but not the reverse
15:56:18 <roconnor> no the otherway
15:56:25 <EvanR> no
15:56:29 <roconnor> oh wait
15:56:41 <roconnor> yes you are right
15:56:45 <EvanR> you cant get something for nothing
15:56:46 <roconnor> I misread the first time.
15:58:21 <EvanR> so assuming ZFC and friends are consistent, you might be able to patch up a given BB(n) analysis for some n by switching among them
15:58:42 <EvanR> since we cant prove termination in some of them, but not others
15:58:58 <roconnor> It might be possible.
15:59:13 <roconnor> well it depends on what you mean by patch it up.
15:59:29 <EvanR> you try it, and 2 are independent, the rest are known
15:59:31 <roconnor> there exists *some* patch that works.
15:59:33 <EvanR> you cant do a max until you know
15:59:53 <EvanR> so you switch to FOO and one of those becomes provable, either way
16:00:03 <roconnor> but you presumably want a patch that you have reason to believe works.
16:00:10 <EvanR> some other become independent, but you still have 1 unknown left
16:00:30 <EvanR> you switch to BAR, the last one becomes provable one way or the other
16:00:38 <EvanR> now you can do the max
16:01:10 <EvanR> assuming ZFC and friends are consistent with each other, youre done
16:01:34 <EvanR> which is provable aiui
16:02:04 <DemiMarie> Note that ZFC proves excluded middle
16:02:48 <EvanR> thats fine, an implied part of this plan is to get actual numbers for the machines that do halt
16:03:03 <EvanR> so worst case scenario after you proved them all one way or the other, you just measure the ones that are left
16:03:17 <EvanR> note LEM doesnt prove them one way or the other
16:03:57 <aweinstock> 'just measure' things that run longer than we expect the universe to exist?
16:04:01 <EvanR> the measurement wont necessarily work
16:04:06 <EvanR> aweinstock: correct
16:04:44 <EvanR> if you use the age, size, market price, or whatever of the universe in your proof... whats that, finitism
16:05:18 <nshepperd1> Well, if you know that a particular machine's haltingness is independent of ZF, you know that it does not halt
16:05:27 <EvanR> really?
16:06:03 <aweinstock> nshepperd1: that's nonobvious, proof sketch?
16:06:05 <EvanR> ... thats handy
16:06:08 <EvanR> if true
16:06:39 <nshepperd1> Because if it did halt, it would have a proof of such (namely, one that just simulates the program, by proving every step)
16:07:13 <EvanR> hmm
16:07:30 <EvanR> that counts as a proof?
16:07:48 <EvanR> (probably not a colloquial valid proof IRL)
16:08:35 <EvanR> programs that halt stand as proof that they halt??
16:09:00 <Squarism> My stack build just stopped : http://lpaste.net/351323
16:09:13 <Squarism> any good idea how to fix?
16:09:34 <nshepperd1> Each step of the proof would consist of something like "after step n, the state of the machine is [....]"
16:09:34 <Squarism> (im not very vetted in stack)
16:09:43 <Koterpillar> Squarism: as in, you got a prompt?
16:09:50 <Koterpillar> Squarism: or is it still munching CPU?
16:09:56 <Squarism> still munching
16:10:08 <EvanR> i suppose by assumption it *is* checkable on the computer
16:10:15 <EvanR> seems circular
16:10:28 <aweinstock> EvanR: I guess 'provable in ZF' doesn't require 'provable in ZF with a proof of length small enough to be readable in a human lifetime'
16:10:32 <Squarism> oh.. it continued
16:10:54 <nshepperd1> The next step would apply the dynamics of the machine and modus ponens to get the state after step n+1
16:10:55 <Squarism> it might be my digital ocean 1G server
16:11:08 <Squarism> or if its 512
16:11:13 <nshepperd1> Such a thing is basically a simulation. But it's also a proof
16:11:35 <EvanR> we ask the computer to check things much smaller in scope all the time so i guess so
16:11:43 <dmwit> EvanR: "This program halts in 512 steps" is perfectly valid and computer-checkable.
16:11:53 <EvanR> if you give the number yes
16:12:02 <dmwit> EvanR: "This program halts; try it and see" is valid only in a system where proofs need not terminate. =)
16:12:04 <EvanR> that wasnt what we were talking about
16:12:55 <EvanR> good clarifying point
16:13:37 <aweinstock> dmwit: is a system with non-terminating proofs necessarily inconsistent?
16:13:40 <EvanR> since the number isnt given, i am back to doubting nshepperd1 argument
16:14:12 <EvanR> aweinstock: theres no such thing as non-terminating proofs, thats a joke
16:14:31 <glguy> aweinstock: Hold on, I'll let you know later
16:14:41 <nshepperd1> Generally, zfc can prove anything that can be calculated by a halting program, by the same basic method
16:15:11 <nshepperd1> You don't need to know the number to just run a program until it stops
16:15:22 <dmwit> aweinstock: I suppose not, so long as you fully evaluate the proof before accepting its conclusion. =)
16:15:51 <EvanR> nshepperd1: does this "fact" stand in contradiction that its not provable one way or the other
16:16:19 <nshepperd1> EvanR: no.
16:16:26 <EvanR> conclude that it must not halt, thus, its a proof of its not halting
16:16:41 <EvanR> since if it didnt, it would be a proof that it did halt
16:16:50 <EvanR> gotta be wrong
16:17:07 <nshepperd1> ZF can't prove that things are independent of ZF
16:17:40 <EvanR> what the heck set theory do they use to show these results ?
16:18:13 <EvanR> it seems like a meta set theory, another copy of ZF or something
16:19:01 <nshepperd1> I said that you know the machine doesn't halt
16:19:10 <nshepperd1> Not that zf can prove such
16:19:27 <EvanR> how does your argument fail?
16:20:25 <glguy> This might be a good topic for #haskell-offtopic, the topics there are allowed to be interesting
16:25:42 <johnw> glguy: lol
16:26:48 <glguy> (to be specific I think that it's sometimes perceived that a discussion is not worth having when it's redirected there)
16:31:08 <johnw> I would more say "not worth expecting 1500 people to read here"
16:33:30 <monochrom> We need more mathematics (interesting and unifying) and less politico-economics (boring and divisive) in #haskell-offtopic.
16:34:18 <monochrom> politico-economics already has #haskell-blah
16:35:12 <EvanR> rename to haskell-math and haskell-politics
16:39:29 <acowley> Anyone know what this type is?: Applicative f => t f a -> f a
16:39:32 <acowley> It's something less than an indexed asum
16:40:01 <acowley> But I called it asumI in some code, and now I feel bad
16:40:05 <monochrom> t may be an "applicative transformer"
16:40:09 <glguy> t :: (* -> *) -> * -> * -- ?
16:40:16 <acowley> glguy: ye
16:40:17 <acowley> s
16:40:39 <acowley> monochrom: wouldn't that give a liftA :: f a -> t f a?
16:41:08 <monochrom> yes, except the name "liftA" is already taken
16:41:17 <acowley> right
16:41:53 <glguy> raise and hoist are spoken for, too. elevate?
16:42:09 <acowley> It feels like it's going down to me
16:42:20 <acowley> It's eliminating the t structure into the f
16:42:22 <pikajude> what about `aggrandize`?
16:42:25 <glguy> Oh, I meant for that liftA one
16:42:54 <glguy> I don't know that your operation necessarily has any common name
16:43:03 <acowley> I think it is something like an indexed foldable
16:46:29 <acowley> It came about because I was trying to tease apart a design that uses what I guess would be called indexed F-algebras
16:46:53 <acowley> But perhaps I should just stick with that rather than try to break it down into IFunctor and this IMNotReallySure
16:47:36 <monochrom> :)
17:09:11 <Gurkenglas> Wouldn't "t f a -> f a" be lower rather than lift?
17:09:47 <Gurkenglas> See http://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Control-Monad-Codensity.html#v:lowerCodensity
17:10:09 <glguy> probably. the lift discussion came from monochrom's "liftA :: f a -> t f a"
17:10:22 <Gurkenglas> See https://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad-Trans-Class.html#t:ComonadTrans
17:11:25 <monochrom> Generally it is a bad idea to chip in to a conversation that ended an hour ago. Because you cannot trust yourself to actually read that conversation carefully.
17:14:19 <acowley> The codensity connection is well taken. There, t ~ ((->) a) for some a
17:33:11 <qmm> any work being done on an equivalent for riak_core?
17:50:54 <qmm> i'll take that as a no
17:51:14 <qmm> how long does it take to create a random number?
17:51:21 <qmm> using a standard generator
17:51:43 <markasoftware> 1 year
17:51:55 <geekosaur> System.Randfom is slow and not very random; mwc-random should be faster; one can also use /dev/random on Linux
18:00:43 <miscyb> does there exist a function like "monadIOBracket :: MonadIO m => m a -> (a - m b) -> (a -> m c) -> m c"?
18:01:02 <miscyb> and it's just bracket that works on MonadIO instead of just IO
18:01:49 <ddere> theres a bracket that works on MonadMask i think
18:02:15 <davean> miscyb: see monad-peel?
18:02:31 <ddere> https://hackage.haskell.org/package/exceptions-0.8.3/docs/Control-Monad-Catch.html#v:bracket
18:04:56 <miscyb> ddere: how can i turn MonadMask into MonadIO?
18:05:11 <miscyb> davean: similarly how can i turn MonadPeel into MonadIO?
18:05:16 <dmwit> miscyb: no
18:05:22 <davean> You can't, MonadIO isn't strong enough
18:05:24 <davean> can't be strong enough
18:05:30 <ggVGc> poor monadio
18:06:06 <dmwit> davean is more helpful than me. =)
18:07:20 <davean> miscyb: it should be obvious why too, MonadIO knows how to run an IO action, you need more then running an IO action to run IO's version of bracket - you need to be able to restart your monad inside bracket. This is actually extreamly tricky
18:08:08 <davean> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:08:16 <davean> bracket only knows how to run IO actions :(
18:08:23 <davean> what if you've got a StateT transformer?
18:09:03 <miscyb> so i'm confused, is it impossible to write a function like "withResource :: MonadIO m => (Resource -> IO a) -> IO a"?
18:09:08 <miscyb> oops
18:09:11 <miscyb> m instead of IO
18:09:42 <geekosaur> it's tricky and prone to resource leaks and bugs
18:09:56 <miscyb> i would have to use MonadMask, MonadPeel, or MonadBaseControl IO
18:10:00 <miscyb> or something?
18:10:16 <davean> its possible with sometihng more then MonadIO, those are what those other type classes are
18:10:31 <davean> they're varios ways to improve the MonadIO feature set to allow it
18:10:42 <davean> for example, take StateT
18:10:54 <davean> you need to "rotate" the state of StateT in and out of the inner actions
18:11:00 <davean> you can't run a StateT without the state!
18:11:20 <davean> so you have to know enough to save the state, restore it inside, save the state from inside and restart the outside with it ...
18:11:22 <geekosaur> even MonadBaseControl has its problems though, it's not like "just use this fancy wrapper and everything Just Works"
18:11:30 <davean> otherwise it would stop being state
18:12:18 <davean> geekosaur: right, which is the benefit of expcetions (I'd fogotten harmless wrote that)
18:12:22 <davean> its not as general
18:12:53 <davean> General solutions to specific problems can be great, but sometimes they suck
18:13:19 <miscyb> alright i'm just going to leave this stuff as IO then
18:13:37 <davean> miscyb: whats wrong with using MonadMask?
18:15:03 <miscyb> davean: i don't understand it yet and there's other stuff i need to do
18:20:49 <winter_> Would someone please help review a piece of concurrent code? i'm not sure if there's any race condition
18:21:28 <winter_> here's the code, https://github.com/winterland1989/diesel/blob/master/Diesel/Pool.hs
18:21:56 <spear2> hi all, i have two lists of strings, how can i do a set comparison to find strings in one list but not both ? XOR i suppose
18:23:22 <Luke> hello
18:23:25 <Luke> is anyone here
18:25:34 <geekosaur> no
18:25:38 <geekosaur> :)
18:27:03 <fred-fri> my questionable beginners intuition for monoids is "combining things into sums" (where sum doesnt necessarily mean 1+1 sum), is there a similar intuition for applicatives and monads?
18:30:02 <geekosaur> monad resists that kind of simple intuition; it's a generalization in a way people don't seem to handle well. best is probably just to see it as a pair of operations (return, bind) on an Applicative with some simple rules.
18:30:40 <geekosaur> Functor is generalized mapping ( fmap :: (a -> b) -> (f a -> f b) )
18:32:38 <Edith> Monads are the sort of thing that will make perfect sense to you once you've completely rewired your brain around functional programming and absolutely zero sense up until that point. Best to just think of it as return and >>=, like geekosaur said
18:32:55 <geekosaur> Applicative is Functor extended with apply :: f (a -> b) -> (f a -> f b)  (we normally spell that as an infix operator <*>)
18:33:06 <NextHendrix> that haskell from first principles book does a pretty good job of explaining monoid functor applicative and monad
18:33:11 <spear2> *guess i figured it out using Data.Set* :)
18:34:34 <geekosaur> Monad further extends Applicative with bind :: f a -> (a -> f b) -> f b   (and we generally spell bind as infix >>=, and use m instead of f when expressing it in types)
18:35:07 <fred-fri> so when presented with some problem that has an lends itself well to solving with a monad, to the extent experienced haskellers intuitively know to use monadic solution, its less about them knowing to use monadic solution (in general) and more about them knowing to use a specific monad? ie unlike monoids, which have a lend themselves to a fairly generalized intuition, monad intuitions are case by case depending on the monad, and knowing well when to 
18:35:08 <fred-fri> use one doesnt necessarily give you intuitions about when to use another?
18:36:10 <davean> fred-fri: I frequently realize I need a monad with specific properties and go out and get one with them or write said
18:36:34 <fred-fri> davean, interesting, mind giving an example?
18:36:43 <geekosaur> so Applicative extends Functor with the ability to apply an action coming from *inside* the functor (instead of imposing it from outside), and Monad extends Applicative with the ability to make decisions "inside" an application instead of blindly imposing a single operation from outside
18:37:13 * geekosaur probably phrsed that last part either wrong or confusingly due to 8 hours of sleep in the past 72 :/
18:37:34 <geekosaur> or, I can point you here instead: https://wiki.haskell.org/Typeclassopedia
18:37:41 <fred-fri> geekosaur, i think i understand what you mean, eg in the case of maybe let maybe decide if nothing or just kind of thing?
18:38:35 <davean> fred-fri: Like I had a thing which could be modeled as a multi-level tree with constraint statisfaction for reachability and I wanted to write rules for exploring it (thats not a great explanation)
18:38:59 <davean> fred-fri: it was obvious it was a monad, I knew a few things about the monad so I ended up writing one
18:40:04 <davean> it obviously was MonadPlus, with some ability to query state
18:40:16 <davean> the rules clearly would create progressive scoping
18:42:23 <orzo> I want to keep -Wunused-imports but override it for an intentional redundant import
18:42:27 <orzo> is that doable?
18:43:13 <glguy> I don't think so. can you fix the redundant import by adding the () import list to it?
18:46:29 <orzo> yes
18:46:59 <orzo> really i could just remove it
18:47:07 <orzo> i've some reason to worry about an old ghc though
18:48:05 <orzo> before the Foldable prelude functions
18:49:44 <orzo> i've got a really crufty code base that I was planning to use warnings to clean up
18:50:14 <geekosaur> fred-fri, the thing Monad can do that Functor and Applicative can't is make use of the "f" (or "m" as we usually specify it for Monad). the Maybe Monad still doesn't let you check explicitly for Nothing in the (a -> m b).
18:51:23 <fred-fri> and the m has its own logic kind of thing
18:52:01 <fred-fri> in the case of maybe its pretty intuitive how deferring to the maybe to decide what happends when chaining stuff
18:52:16 <fred-fri> but its not immidiately obvious there are similar intuitions for eg list or other monads
18:53:49 <geekosaur> the Maybe monad lets you produce a Nothing, where fmap and <*> force you to produce a Just. the IO monad lets you do I/O. the State monad lets you access a state. etc. what you can do depends on the m; the Monad interface does not restrict it, so you can have things as different as Maybe, IO, and Cont.
18:54:14 <geekosaur> (Cont will likely break any intuition you come up with. But then, it will break your brain anyway. :)
18:54:41 <fred-fri> right, which leads me to think to the degree people have intuitions about monads, they are specific to the monad and not general monad intuitions
19:01:25 <fred-fri> geekosaur, can i bug you for an intution about eg the list monad? some problem that is obvious that it can be solved using list monad?
19:02:00 <orzo> think of the list mode as a kind of logical parallelism
19:02:15 <geekosaur> we generally refer to it as the "nondeterminism monad". it's logic in parallel: all possible options are evaluated "at the same time"
19:02:20 <orzo> x <- list -- means choose x from the set
19:02:59 <geekosaur> and the action is done to every element "at the same time" and the results combined into a new list, on which further operations can be performed
19:03:57 <geekosaur> you don;t see it used much because many times you want a transformer over IO, and ListT is broken for that (it's only valid for commutative monads); but there is LogicT which is valid, and packages that use it
19:04:07 <orzo> it's a pretty nice syntax relative to for-loops
19:04:56 <orzo> ListT is bad, but i use list monad often enough in pure code
19:05:59 <geekosaur> also, many potential uses of the list monad are simpler with list comprehensions. (in fact that's general, and older Haskell had monad comprehensions. ghc re-added them some time back with the MonadComprehensions extension)
19:06:48 <safinaskar> please, give me some arguments or links on problem "haskell sum and product types vs ml sum and product types". ml has separate sum type and product type. haskell has keyword "data" which is both, i. e. it declares sum of products. how this problem should be solved in hypotetical ideal language? separate sum and product types? or combined?
19:07:52 <geekosaur> safinaskar, I'm not sure an ideal there can be reached
19:10:56 <Gurkenglas> Don't forget exponential types, which Haskell has the separate (->) for
19:20:11 <orzo> geekosaur: do you prefer new code avoid list monad and use MonadComprehensions if they want generality?
19:20:33 <geekosaur> I feel like the reintroduced MonadComprehensions never reached their potential
19:21:11 <geekosaur> there was this whole thing about how the syntax was a natural match for database queries (think SQL)... but that never really happened
19:22:55 <geekosaur> so, anyway, they end up not being used very often. I don't know if that's just inertia or if they have problems in practice
19:23:08 <safinaskar> is there any argument for (or against) separate sum and product types (as in ml) at all?
19:23:17 <lyndon> Is there a reason why Servant's ClientM doesn't have an alternavie instance?
19:23:26 <lyndon> *alternative
19:24:24 <lyndon> Also, is anybody maintaining Needle?
19:25:01 <orzo> lyndon: the version of servant i have seems to have alternative for ClientM
19:25:13 <lyndon> Interesting, what's the version?
19:25:31 <orzo> 0.8.1
19:25:39 <lyndon> I'm using servant-client 0.9.1.1
19:25:47 <lyndon> (& servant)
19:26:28 <lyndon> Unless I need to import something else...
19:27:16 <orzo> looks like they made a newtype in later versions
19:27:29 <orzo> in 0.8.1 ClientM was just a type alias for a transformers type ExceptT
19:27:41 <orzo> so they lost the Alternative instance along the way
19:28:26 <lyndon> ahhh
19:28:42 <lyndon> Should probably add that one back in :)
19:30:51 <lpaste> qmm pasted “is there a vulnerability with the hardcoded number 4537 here?” at http://lpaste.net/9051076859680260096
19:34:05 <monochrom> Perhaps you can read TAOCP and see what Knuth says.
19:34:27 <orzo> ghc should let you declare optional orphan instances that will be ignored if the imported library already has an instance
19:35:32 <lyndon> orzo: Sounds like that would get hairy fast
19:35:45 <orzo> how do you mean?
19:36:29 <lyndon> Say the library decides to add an instance
19:37:07 <orzo> that's what the feature is for
19:37:12 <lyndon> ah I see
19:38:12 <orzo> you're explicitly telling the compiler that you only wrote this instance to support linking against some older version of an imported library
19:38:54 <lyndon> That could actually be quite cool.
19:39:04 <lyndon> Avoid some of that CPP
19:39:05 <orzo> without having to get the version numbers right in some #if MIN_VERISON_* macro
20:31:31 <anohigisavay> hello. what's the difference between standalone deriving and an empty instance declaration?
20:32:26 <Layl> why does Haste wrap all ffi in eval()?
20:32:30 <codygman> at line 140 I have an error with this viewpattern for some reason, any ideas? http://lpaste.net/5734373062099337216
20:32:39 <dfeuer> anohigisavay: the first tells GHC to derive the class implementation using one of several deriving methods; the second tells GHC to use the default method definitions (if they exist) and otherwise leave methods undefined.
20:32:56 <markasoftware> what are your favorite haskell functions everybody
20:33:17 <dfeuer> markasoftware: that's a bad question.
20:33:32 <Layl> "succ" obviously
20:34:23 <dfeuer> codygman: you forgot {-# LANGUAGE PatternSynonyms #-}
20:34:25 <codygman> answering myself, I was confusing viewpatterns with patternsynonyms
20:34:28 <anohigisavay> dfeuer, so for some custom class, if having -XDeriveAnyClass enabled, they are the same?
20:34:31 <codygman> dfeuer: Thanks :)
20:35:28 <dfeuer> anohigisavay: if you have DeriveAnyClass enabled, and GHC does not know a better way to derive it, then it will do the "defaults only" thing. I really don't recommend DeriveAnyClass.
20:35:44 <dfeuer> I mean, maybe it's okay?
20:35:47 <dfeuer> But it scares me.
20:36:07 <dfeuer> Unless they've improved warnings and error messages for it, which they might have.
20:36:13 <dfeuer> I haven't paid enough attention lately.
20:36:24 <geekosaur> I gather DeriveAnyClass is specifically useful if you use a lot of Generics-based default methods
20:36:46 <geekosaur> and otherwise a bug waiting to happen
20:37:57 <dfeuer> geekosaur: did they ever get the partial contexts thing working?
20:38:09 <geekosaur> no idea
20:38:45 <anohigisavay> dfeuer, thanks a lot :D
20:38:59 <dfeuer> anohigisavay: no problem.
20:39:03 <Layl> oh sweet, eval's compiled out when optimizations are on
20:40:26 <dfeuer> Layl: what are evals?
20:40:43 <Layl> dfeuer: I'm talking about evals() calls emitted by Haste in the output JS
20:40:49 <Layl> specifically, on FFI
20:40:57 <dfeuer> Oh... I know nothing about Haste.
20:41:18 * dfeuer is struggling to learn GHC internals, and is not going to worry about Haste at all for the foreseeable future.
20:41:31 <Layl> I just want to not use JS
20:41:33 <Layl> and sleep
20:47:04 <codygman> I'm having a problem with a pattern synonym not being bi-directional. I'm trying to inline the frames/vinly library into one file and I'm confused as to why this works in the resulting library but not my inlined file. I either need to figure how to fix it as is or make it bi-directional: http://lpaste.net/3212681369004015616
20:48:38 <geekosaur> codygman, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#syntax-and-scoping-of-pattern-synonyms
20:48:44 <geekosaur> <- is explicitly unidirectional
20:48:51 <codygman> geekosaur: Thank you
20:48:56 <geekosaur> unless you use where
20:49:17 <geekosaur> = is bidirectional simple pattern, <- ... where lets you do more complex things
20:50:32 <dfeuer> really  want to be able to give pattern synonyms and constructor synonyms independent constraints.
20:51:57 <glguy> dfeuer: Can't you?
20:52:24 <geekosaur> uh. I thought there was that hinky foo => foo => syyntax for that
20:52:33 <glguy> You can give different constraints for matching and construction with current pattern synonyms using what geekosaurjust wrote, is that what you wanted?
20:56:04 <dfeuer> glguy: you get to give constraints the pattern match requires, and constraints the pattern match needs. Those get lumped together to give the constraints for the constructor. Which is flat-out bogus.
20:56:55 * geekosaur thinks one of those was intended to be "provides"?
20:57:03 <dfeuer> geekosaur: yeah, that.
20:57:11 <geekosaur> but yes, that sounds a bit off
20:57:25 <dfeuer> It's wrong both ways.
20:57:46 <dfeuer> Terribly sad.
20:58:49 <dfeuer> Why doesn't IRC have a /resurrect command to bring back a user who's parted? 
20:58:53 <geekosaur> but they really need better syntax before adding that. ghc accepts (granted, this was not intended) constraint => constraint => ... pretty much everywhere and they get combined, then suddenly in patterns they're distinct
20:59:12 <geekosaur> best place to put the other one is probably in the where clause...
20:59:24 <geekosaur> (with current behavior applied to the = form)
20:59:25 <dfeuer> geekosaur: that would work, yes.
20:59:34 <dfeuer> Oh...
20:59:46 <dfeuer> No, I don't want the current behavior for the = form either.
21:00:15 <dfeuer> Because sometimes I want to actually *hide* type information.
21:00:27 <glguy> What's an example of something you'd like to be able to write?
21:01:10 <geekosaur> the = form is already simplified (and I think 7.10 compatible?). the where form is more flexible
21:01:12 <dfeuer> Or maybe I'm confused? 
21:01:37 <geekosaur> they extended the syntax because the original form was too limited
21:03:22 <dfeuer> glguy: suppose I have  newtype Hidden a = Hidden [a]; data Hide where Hide :: [a] -> Hide,  hide :: [a] -> Hidden a, peer :: Hidden a -> Hide
21:03:33 <geekosaur> wow, the 7.10 manual looks horrid compared to 8.x :)
21:04:02 <dfeuer> Now imagine I want a constructor synonym for hide which is also a pattern synonym for peer.
21:04:34 <geekosaur> hm, looks like the where form was also in 7.10, I thought they added that later because the original = form was too simplistic
21:04:36 <glguy> Oh, you want it to have a completely unrelated type in one direction from the other?
21:04:43 <dfeuer> glguy: no.
21:04:57 <dfeuer> I mean I don't want to have the Hide type at all.
21:05:35 <dfeuer> I want a pattern synonym so that   Secret "hello" :: Hidden String,
21:05:56 <dfeuer> but if I match on   (Secret x), I only can see that x is a list of some sort.
21:06:11 <dfeuer> Can I do that today?
21:08:34 <teruyo> Is there a way to rewrite this without using (++)? http://ideone.com/Am2Rja
21:09:21 <geekosaur> oh, derp, they were origonally in 7.8
21:10:09 <glguy> dfeuer: Would there be some other secret function :: Hidden String -> [String] then?
21:10:54 <glguy> rather: Hidden a -> [a]
21:12:24 <dfeuer> glguy: maybe? Maybe the API doesn't want to reveal that. Obviously this *specific* example is completely useless, but there may be less useless ones.
21:12:48 <dfeuer> Certainly there are *very* realistic examples of non-simple pattern synonyms that the current rules don't handle well enough.
21:12:59 <dfeuer> Simple pattern synonyms I'm less sure about.
21:13:13 <dfeuer> But I'm nervous about "Who would need *that*?" thinking.
21:13:55 <glguy> Yeah, you should avoid that for now
21:14:57 <dfeuer> glguy: my own *personal* preference is to completely sever pattern synonyms from constructor synonyms (except for import/export lists).
21:16:03 <dfeuer> There's just no *inherent* reason for them to be tied to each other; they basically live in different namespaces.
21:16:22 <dfeuer> [oh, and fixity declarations, of course]
21:31:40 <glguy> dfeuer: It doesn't address your pattern synonym concerns (I don't know how to do what you suggested using pattern synonyms as they exist now, but it had me wondering how one could achieve your example otherwise
21:31:53 <glguy> with this http://lpaste.net/351327 you seem to get close
21:32:16 <glguy> and we can control who can seee the hidden data by controling who can see the "equal" class method
21:36:56 <dfeuer> glguy: my example was wrong, because we can do that today.
21:37:03 <dfeuer> I think.
21:37:11 <glguy> cool, paste it!
21:37:14 <dfeuer> I had a better example, but I don't remember what it was.
21:37:37 <dfeuer> I think I did anyway?
21:37:50 <dfeuer> Oh wait, something is off....
21:38:55 <dfeuer> Oh no, that works.
21:39:27 <dfeuer> glguy: the problems come from things like what we do with numeric literals.
21:40:04 <dfeuer> And I noticed a dual issue for the NF type in the nf package (I think it's called that)
21:43:13 <dfeuer> glguy: no, I'm wrong.
21:43:22 <dfeuer> It doesn't work at all. I got confused.
21:43:25 <dfeuer> Ffff..
21:46:23 <kadoban> If a library provides a function  f :: A -> B -> C    and applying the first argument to it is really expensive, but then the second isn't at all, is there a common way I should signal to users (or maybe to GHC itself) that this is true, and that they should prefer to memoize the result after applying the first argument?
21:46:35 <dfeuer> But *why* doesn't this work?
21:46:44 <dfeuer> I wonder if this is a bug.
21:47:08 <glguy> kadoban: You can have: f a = \b -> ... where stuffThatOnlyUsesA
21:47:44 <glguy> and then the resulting function \b ->... can take advantage of reusing the expensive computation being done on 'a'
21:48:54 <kadoban> glguy: Right, but that looks the same to users of the function, right?
21:49:10 <dfeuer> Oh, I see why that doesn't work. Right, the same stupid thing.
21:49:15 <kadoban> I mean I can write in the documentation for this thing that they should apply the first argument and carry that around, but ... is that it?
21:49:18 <dfeuer> I keep getting mixed up.
21:49:21 <glguy> kadoban: Yeha, that's it
21:49:38 <kadoban> Hm, alright. Thanks
21:49:42 <dfeuer> Yeah, glguy, without a separate constructor synonym type (or at least constraints!) I can't get what I want.
21:53:10 <glguy> kadoban: if you want to signal it to your users explicitly you can newtype BtoC = BtoC (B -> C) and have a special application function that people have to use and won't know about , forcing them to look at your documentation :)
21:55:14 <dfeuer> glguy: for the NF type, we want the constructor synonym to have an NFData constraint, but the pattern synonym not to. For a lot of other things, we might be interested in having an Eq constraint on the pattern synonym, but not on theconstructor.
21:58:42 <kadoban> glguy: Hmm, that seems like a decent idea perhaps
22:01:50 <dfeuer> glguy: I'm always a bit nervous of functions like that. Especially considering the weird GHC options Roman Cheplyaka had to put in his regex-applicative to prevent GHC from "optimizing" the sharing away.
22:03:44 <glguy> a lot of the cleverness I've seen GHC do was to add sharing I didn't want
22:03:55 <dfeuer> Yup.
22:03:57 <dfeuer> It does both!
22:04:02 <dfeuer> :-/
22:04:02 <glguy> any kind of performance questions are going to require careful review of what ghc did
22:06:10 <dfeuer> I think I confused meld.
22:18:41 <Squarism> what cabal version are people running? Ive started using stack so i guess i can disregard that i only had 1.22 installed before that
22:19:08 <Squarism> (i mean, in your build files - what cabal version requirement are you specifying
22:23:00 <Squarism> or does stack rely on the installed cabal?
22:23:39 <dmj`> Squarism: stack relies on the Cabal library
22:25:21 <Squarism> dmj`, yeah ive understood that - but what is it running, something in the LTS or what ive got installed on my computer?
22:27:24 <dmj`> Squarism: are you asking where stack gets its Cabal dependency?
22:27:38 <Squarism> dmj`, i guess
22:28:00 <Squarism> Whatever it uses to digest the .cabal files
22:28:54 <dmj`> It probably uses a Cabal that is hosted on stackage
22:28:57 <dmj`> https://www.stackage.org/lts-7.16/package/Cabal-1.24.2.0
22:29:39 <Squarism> oh ok
22:36:59 <athan> Anyone here mess with GHC on raspberry pis by chance?
22:37:19 <athan> I've got a pi 3B, so hopefully won't take a decade to compile things :x
22:37:36 * ertes is looking for a library for rings (Num with explicit ring laws and without fromInteger, abs and signum)
22:37:58 <athan> so far, haskell platform is the only thing that works haha
22:38:10 <monochrom> Eh? fromInteger is a fundamental consequence of ringness.
22:38:45 <ertes> monochrom: ah, of course
22:39:20 <ertes> i guess abs and signum aren't show-stoppers…  i'll go with Num
22:40:06 <dfeuer> ertes: abs and signum are very sad indeed :(
22:40:29 <dfeuer> Also the fact that you can't rely on instances to be rings, because someone decided that floating-point representations are "numbers"
22:40:42 <ertes> dfeuer: well, you can always just say:  abs = id; signum 0 = 0; signum _ = 1
22:40:56 <Cale> dfeuer: Well, it would be pretty impractical to exclude them, I think.
22:41:16 <ertes> more practically i wish there was Num with multiplicative inverses:  recipMaybe :: (NumInverses a) => a -> Maybe a
22:41:25 <dfeuer> ertes: since there aren't too many laws (if any!) officially attached to Num, you can do whatever you like.
22:41:26 <Cale> That's the main reason I prefer the name "Num" over "Ring" because ring is supposed to mean something :P
22:42:13 <dfeuer> ertes: what's wrong with Fractional?
22:42:23 <dfeuer> Oh, does it assume a field?
22:42:27 <ertes> dfeuer: Fractional requires a field(-like?) structure
22:42:52 <dfeuer> ertes: only for an unambiguous (/), right?
22:43:00 <dfeuer> (or something like that?)
22:43:12 <ertes> dfeuer: NumInverses would support e.g. Word
22:43:23 <dfeuer> Oh, you want *that*.
22:43:29 <dfeuer> Wait, Word?
22:43:35 <monochrom> It depends on whether you have in mind "every nonzero number has an inverse" or "I just want the integers adjoined with 1/5"
22:43:53 <dfeuer> I thought that would only work for modular whatchahoozits with a prime number of elements.
22:44:10 <dfeuer> Oh, and there's that.
22:44:13 <dfeuer> Feh.
22:44:40 <ertes> @let recipWord32 :: Word32 -> Maybe Word32; recipWord x | even x = Nothing | otherwise = Just (x^(2^31 - 1))
22:44:42 <lambdabot>  .L.hs:168:1: error:
22:44:42 <lambdabot>      The type signature for ‘recipWord32’ lacks an accompanying binding
22:44:47 <ertes> @let recipWord32 :: Word32 -> Maybe Word32; recipWord32 x | even x = Nothing | otherwise = Just (x^(2^31 - 1))
22:44:49 <lambdabot>  Defined.
22:44:56 <ertes> > recipWord32 5
22:44:58 <lambdabot>  Just 3435973837
22:45:06 <ertes> > 5 * 3435973837 :: Word32
22:45:08 <lambdabot>  1
22:47:00 <ertes> dfeuer: it doesn't have to be prime, but only numbers coprime to the modulus (in this case only even numbers) have inverses
22:47:21 <dfeuer> ertes: so then you want recip to make a Maybe or something.
22:47:25 <dfeuer> Hrmph.
22:47:27 <dfeuer> OK.
22:47:39 <ertes> yeah…  i need to handle missing inverses
22:49:03 <monochrom> instance Fractional Bool where ... :)
22:49:07 <dfeuer> Well, I guess 0 is alwasy an inssue too.
22:49:20 <dfeuer> In other news, I MUST SLEEP. Meeting at 10, I think.
22:49:26 <dfeuer> Night all.
22:50:19 <ertes> me too, i guess, because actually only odd numbers have inverses =)
22:51:21 <jchia> Is it a good idea in Haskell to prefix constants with 'k', e.g. kMagicNumber?
22:51:59 <jchia> Is it arguably a bad idea? I find that it's an effective hint to the reader that the kMagicNumber is a special value.
22:52:11 <ertes> jchia: you mean as a convention for constants in general?
22:52:15 <jchia> yes
22:52:34 <ertes> jchia: haskell is pure, so everything is a constant anyway
22:53:05 <monochrom> What's special about them? Answer: They are defined at the top level.
22:53:36 <monochrom> Conclusion: Prefix every top-level-defined name by k to remind people "it's from the top level, not a local thing"
22:53:57 <ertes> i wouldn't use any particular prefix
22:55:33 <jchia> ertes, monochrome: If I don't prefix with 'k' then when I read part of a file and check whether the magic number is correct, I'll have two variables, magicNumber and magic, the former being the expected value and the latter being the actual read value. How do I make that less confusing?
22:56:12 <ertes> jchia: do magic' <- getMagic; if magic' /= magic …
22:56:33 <monochrom> standard_speed_of_light and measured_speed_of_light
22:57:15 <ertes> jchia: i would imagine in haskell that magicNumber has a fairly narrow scope anyway, so it's easy enough to see what's going on
22:57:45 <jchia> ertes: It's not too confusion, but in C++, the 'k' prefix is like an idiom that makes it really clear
22:57:53 <jchia> "not too confusing"
22:58:14 <ertes> jchia: if you like that, feel free to use it
22:58:44 <ertes> C++ programmers should feel warm and fuzzy about your code, while haskell programmers keep wondering what that "k" means =)
22:59:07 <jchia> i mean in the c++ coding convention that i use
22:59:10 <monochrom> "k" is unclear. Also lack of "k" is also unclear. What does "k" stand for? Why is it not "c"? Or "const"? Or ...
22:59:24 <monochrom> However, "standard" and "measured" are clear.
22:59:47 <jchia> OK
22:59:56 <ertes> yeah, or "expected" and "given" or something like that
23:00:13 <monochrom> And maybe s/standard/theoreticl/
23:00:41 <ertes> or even just "thrtcl"
23:02:13 <jchia> I'm going to use 'expected'
23:02:17 <YellowOnion> I'm trying to fill a KdTree (from kdt) with 6 million points, (from a 900MB json file) and it's using far too much memory (6GB+), this is one of the things I'm starting to really hate about haskell, is stopping space leaks.
23:02:47 <monochrom> Use longer, more complete names. Do not compress.
23:02:59 <monochrom> I tell you what's wrong with abbreviations.
23:03:22 <monochrom> What's wrong with abbreviations: Everyone thinks that their homebrew abbreviation is universally guessable.
23:03:45 <ertes> YellowOnion: it's not really a leak in your program, but the way GHC represents ADT values in memory…  if you want to reduce memory consumption you need to switch to a more compact representation on some level
23:04:21 <monochrom> True story: I have a computer tech-support friend who went to a small company to install new software. The people in the small company asked: "Will this be compatible with 1048?"
23:04:57 <ertes> YellowOnion: for example i have represented IntMap as a sorted unboxed vector in the past to get the memory usage under control
23:05:16 <monochrom> What the hell is "1048"? It's their homebrew abbreviation for "1024x768 monitors". They thought everyone in the world thought like them.
23:05:49 <YellowOnion> ertes, 6GB is the limit where the program starts to swap to disk, 6 million points should be about 60MB at most, the file I'm importing has a lot of extra info, I really don't understand how the ADT could ever get to be so excessively huge without a space leak.
23:06:05 <ertes> monochrom: i was just joking about your typo =)
23:06:17 <monochrom> yeah I know, don't worry :)
23:06:32 <YellowOnion> ertes, I was hoping I wouldn't have to make my own KdTree too.
23:07:02 <ertes> YellowOnion: well, make a memory benchmark of IntSet…  i found memory size factors around 10 in my last benchmark
23:07:12 <monochrom> "k" is really an unguessable abbreviation. When it appears in a physics program, I would guess that it means "has a factor of kilo"
23:08:01 <ertes> YellowOnion: and IntSet is already very compact in memory…  any data structure that uses pointers to substructures is bound to have a bad constant factor in memory efficiency
23:09:09 <ertes> YellowOnion: however, you don't need to 'vector' all the way down…  for example you could have a vector of things at the bottom of your k-d-tree and just make sure that the tree does not split all the way down to single objects
23:10:38 <jchia> How can I have a fixed-size array (not vector) in Haskell? The size (N) is known at compile-time. I want to make it impossible to use an out-of-range constant index. When serializing the array, I don't want to deal with the imaginary situation that the size is something other than N which would exist if I were using a Vector.
23:10:46 <ertes> YellowOnion: (you will face this engineering challenge not just in haskell, although probably with better constant factors)
23:12:07 <jchia> Just keep it simple and use a Vector and error out if the size is unexpected?
23:13:06 <ertes> YellowOnion: another noteworthy thing is that the kdt package is implemented rather inefficiently…  *everything* is boxed…  unboxing some (or even all) of the fields could have helped your memory situation a lot
23:14:03 <YellowOnion> ertes, my point is that I can't find anything to help me find what my issue is, very few tutorials how to actually debug, and rationalise space usage in haskell.
23:15:19 <YellowOnion> ertes, maybe I can have a look at modifying the package.
23:15:51 <ertes> YellowOnion: i couldn't point you to one either, although it's worth reading this section of the GHC manual: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/sooner.html
23:17:05 <ertes> YellowOnion: if you want to approach memory efficiency from a debugging (deconstructing) direction, profiling may be your best bet
23:17:39 <ertes> from a constructive direction it mostly boilds down to using strict fields and in some cases avoiding ADTs altogether
23:17:52 <ertes> *boils
23:19:10 <MarcelineVQ> how interestingly on-topic, I'm completing an edit on a lib atm (weigh) that measures memory useage
23:19:12 <sdx23> YellowOnion: http://neilmitchell.blogspot.de/2015/09/detecting-space-leaks.html
23:19:24 <ertes> YellowOnion: also keep this in mind:  anything that makes your code faster by a constant factor most likely also reduces its memory consumption…  so you should optimise for *speed* most of the time
23:19:36 <MarcelineVQ> the edit is to also measure residency, currently it mesures allocations
23:20:07 <YellowOnion> ertes, oh thank you! this looks promising.
23:25:08 <YellowOnion> ertes, I run a profile yesterday, though I suspect it's not the correct type: http://i.imgur.com/CKBw7Sv.png
23:26:12 <YellowOnion> that looks like a space leak to me, not even related to the tree.
23:26:58 <ertes> YellowOnion: i have no experience with haskell profiling, sorry =/
23:27:37 <YellowOnion> ertes, ahh all good.
23:27:37 <ertes> perhaps the article sdx23 linked could help you track it down
23:28:31 <YellowOnion> oh whoops, sdx23 thanks!
23:28:36 <ertes> at least until MarcelineVQ has finished their library (interestingly i have a similar project lying around that i started and then abandoned)
23:28:59 <ertes> the idea was to make something like criterion, but for space instead of time
23:29:45 <MarcelineVQ> it's chisdone's and that's exactly what he did, but it's lacking that (imo) fairly important part
23:29:59 <MarcelineVQ> https://www.fpcomplete.com/blog/2016/05/weigh-package
23:30:21 <MarcelineVQ> And it's a little fragile due to using stdout so that's another thing I'm looking at
23:30:49 <Squarism> if i have an executable and a library in same cabal file, how can i make the executable depend on all dependencies that the library depends on. Stack/cabal wants me to re-specify them it seems
23:30:56 <ertes> it was supposed to use statistical methods to guess the space usage curve of a function based on its arguments, so you could test for stuff like "this function is linear in x and quadratic in y"…  if the measured curve disagrees, the test fails
23:32:20 <ertes> Squarism: i'm afraid that's what you need to do
23:33:29 <Squarism> Oh, ok. Theres a good reason for it I assume?
23:33:39 <YellowOnion> ertes, ahh that's a good idea, I wonder if this eta project will help, but I suspect jvm will make it a small overlap with ghc
23:34:22 <YellowOnion> Anyone here work at microsoft, I would like to complain about the recent inclusion of Memory compression :-|
23:34:30 <ertes> Squarism: not really…  cabal could totally allow a "common-build-depends" field or even macros
23:34:58 <Squarism> ok
23:35:53 <ertes> YellowOnion: hmm?  i like memory compression (at least on linux)…  it makes 2 GiB systems usable =)
23:36:00 <YellowOnion> ertes, Windows tries to bulk compress about 2GB of memory on the system thread, everything locks up for 3-4 seconds, so debugging this is a pain ha.
23:36:21 <ertes> yeah, that sounds like a terrible way to do it =)
23:37:20 <YellowOnion> ertes, the working set memory for my app drops to about 3-4MB, its extremely heavy purge, and I have a shitty Phenom II so it cries everytime it happens.
23:40:04 <sanotehu> when using stack, do I really need to put every module in the cabal file under `other-modules` even if I have no intention of exposing these modules?
23:40:37 <ertes> YellowOnion: oh, BTW, aeson has a strict mode that makes sure that everything is actually parsed *and* converted…  if you don't use it, the file you read will hang around in memory until you have visited everything in the resulting Value
23:40:53 <ertes> sanotehu: yes (and it's unrelated to stack)
23:41:17 <sanotehu> for example I've put some types in separate files, but I've then had to list every single one in the cabal file to stop a linker error
23:42:00 <YellowOnion> ertes, I'm not using aeson directly, I'm using json-stream to keep the parsers memory down.
23:42:24 <YellowOnion> maybe I'll try pipes-aeson
23:46:10 <ertes> YellowOnion: json-stream might be fine, if it does what i think it does: split the input stream into individual JSON constructs, then feed each of them individually to aeson to produce a stream of values
23:47:05 <ertes> YellowOnion: but you still need to use decode' (the strict variant), otherwise e.g. numbers will only be verified, but not yet parsed into numbers, which means that the corresponding string will stay in memory until you actually access the number
23:48:50 <YellowOnion> ertes, json-stream provides it's own "decode"
23:49:10 <ertes> YellowOnion: example:  x :: Integer; x = parseIntegerPrefixAndIgnoreRest someHugeTextWithAnIntegerPrefix  -- imagine that this has the last reference to someHugeTextWithAnIntegerPrefix, but you have not yet forced 'x'…  then the huge text value will actually stay in memory until you do
23:53:32 <ertes> YellowOnion: yeah, json-stream doesn't seem to do what i thought it would do…  pipes-aeson seems to do it though
23:54:04 <ertes> YellowOnion: i assume your input file just has a bunch of objects written one after another?
23:54:12 <ertes> { … } { … } { … } …
23:54:47 <YellowOnion> ertes, it's a json list [{..}, {..}, ..]
23:55:20 <ertes> hmm, then pipes-aeson won't work
23:57:45 <dmj`> io-streams would work too
23:57:59 <YellowOnion> ertes, https://www.edsm.net/en/nightly-dumps this is the file (2nd option)
