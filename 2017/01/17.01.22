00:03:13 <Cale> shayan_: I live in Brantford
00:03:27 <ishmael> running grsec, when i try to start ghci, i get an operation not permitted. how do i get around this?
00:07:55 <shayan_> Cale: Nice!!! I thought you were in NYC because that‚Äôs where Obsidian Systems is?
00:10:13 <Cale> shayan_: I work remote from my house
00:12:01 <shayan_> Nice. Can I come  8) 
00:12:28 <glguy> ishmael: you'll need to disable and grsec enforcement settings for the ghc executable
00:12:47 <glguy> disable some*
00:14:02 <glguy> Google will have to help, i don't know the process. ghc does a small amount of run time code generation for ffi
00:14:50 <codygman> What is the preferred mutable hashmap in Haskell? Is there one?
00:15:39 <ishmael> hm. maybe someone in ##kernel knows how
00:33:14 <geekosaur> ishmael, try execstack -q /path/to/ghci and if it says exec stack is enabled, use sudo execstack -c /path/to/ghci
00:34:02 <geekosaur> iirc execstack gets set for some reason (possibly libffi) but hasn't been found to actually be needed --- however it is conceivable that some ffi calls will fail
00:36:08 <ishmael> geekosaur: i got it to work. i added "m /usr/lib/ghc-8.0.1/bin/ghc" to /etc/paxd.conf
01:02:03 <jmorris> could someone help me write this frequency analysis for http://cryptopals.com/sets/1/challenges/3
01:02:08 <jmorris> http://lpaste.net/351539
01:02:31 <jmorris> i need to decrypt a message encrypted using the singleByteXor function with frequency analysis
01:05:12 <jle`> codygman: i don't think there's an accepted preferred one right now at the moment
01:05:25 <jle`> i think that's been the point of some recent complaints
01:05:50 <ertes> helo
01:05:56 <ertes> jmorris: do you know how the method works?  (indepedent of how it's implemented)
01:06:26 <jmorris> ertes: I know how to decrypt with frequency analysis by hand
01:06:37 <ertes> codygman: IORef (HashMap k a)?
01:07:08 <ertes> jmorris: ok, then the second step is to write a function to count each "character"
01:07:24 <ertes> jmorris: the first step is to get the "characters" from the hex string
01:07:33 <ertes> jmorris: String -> Maybe [Word8]
01:07:51 <jmorris> wouldn't it be ByteString -> Maybe [Word8]?
01:08:17 <ertes> jmorris: what's the argument?  a ByteString of hex digits?
01:08:45 <jmorris> I don't know, i've just been using bytestrings for the other challenges
01:08:58 <jmorris> and singleByteXor returns a bytestring
01:09:50 <ertes> jmorris: well, you can certainly replace [Word8] by ByteString
01:10:15 <jmorris> no, because you said String -> Maybe [Word8]
01:10:23 <jmorris> i asked if it should be ByteString -> Maybe [Word8]
01:10:27 <ertes> jmorris: the input string should be Text or String, but since the hex encoding uses only ASCII, too, ByteString is fine
01:10:51 <vaibhavsagar> @codygman: the "hashtables" package? http://hackage.haskell.org/package/hashtables
01:10:51 <lambdabot> Unknown command, try @list
01:11:04 <jmorris> so the function needs to return a list of all the characters? ertes 
01:11:18 <ertes> jmorris: ByteString -> Maybe ByteString  -- this is fine
01:11:36 <jmorris> what is the function supposed to be doing?
01:12:37 <ertes> jmorris: here is a test case:  hexDecode "4121" = "A!"
01:12:40 <ertes> err
01:12:43 <ertes> jmorris: here is a test case:  hexDecode "4121" = Just "A!"
01:13:16 <ertes> jmorris: another test case: hexDecode "x" = Nothing
01:15:59 <jmorris> ertes: ok, i did that
01:16:30 <ertes> jmorris: good, the second step may have this type:  ByteString -> HashMap Word8 Int
01:16:58 <jmorris> I don't know what a HashMap Word8 Int is
01:18:04 <ertes> jmorris: then just go with (ByteString -> Map Word8 Int)‚Ä¶  pretty much the same thing in this case
01:19:09 <jmorris> i also don't understand
01:19:14 <jmorris> what is a map word8 int
01:19:44 <ertes> jmorris: a Map (from Data.Map.Strict) is an association table similar to [(Word8, Int)]‚Ä¶  it associates Word8s with an Int
01:20:40 <jmorris> ertes: ok, so what does the function do? count the letters in the string?
01:20:46 <ertes> yep
01:22:03 <ertes> jmorris: you can actually implement this as a short one-liner‚Ä¶  read the documentation of Data.Map.Strict.fromListWith to learn how
01:23:19 <ertes> jmorris: https://hackage.haskell.org/package/containers-0.5.9.1/docs/Data-Map-Strict.html#v:fromListWith
01:23:37 <jmorris> so that returns the same type
01:24:19 <jmorris> I think
01:24:31 <jmorris> but i still don't know how to count the frequencies in the bytestring
01:25:28 <ertes> jmorris: fromList takes a list of key/value pairs and builds a Map from it
01:25:46 <jmorris> yes
01:25:47 <ertes> > M.fromList [('a', 1), ('b', 5), ('c', 7)]
01:25:50 <lambdabot>  fromList [('a',1),('b',5),('c',7)]
01:26:21 <ertes> now, if you imagine that a string only contains unique characters, you can use it to count characters
01:26:51 <ertes> > M.fromList (map (, 1) "helo thr!")
01:26:53 <lambdabot>  fromList [(' ',1),('!',1),('e',1),('h',1),('l',1),('o',1),('r',1),('t',1)]
01:27:04 <ertes> as you see, this correctly gives you the counts
01:27:04 <jmorris> oh
01:27:20 <jmorris> > M.fromListMap (, 1) "hello"
01:27:24 <lambdabot>  error:
01:27:24 <lambdabot>      Not in scope: ‚ÄòM.fromListMap‚Äô
01:27:24 <lambdabot>      Perhaps you meant ‚ÄòM.fromList‚Äô (imported from Data.Map)
01:27:33 <ertes> now a map cannot contain duplicate keys, so here is a question: what happens if characters aren't unique?
01:27:37 <jmorris> > M.fromListWith (, 1) "hello"
01:27:41 <lambdabot>  error:
01:27:41 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò(t, Integer)‚Äô with ‚Äòt -> t‚Äô
01:27:41 <lambdabot>        Expected type: t -> t -> t
01:28:00 <jmorris> ertes: it adds to the count
01:28:01 <ertes> that's where fromListWith comes in:  it takes a function as its first argument that determines how an existing value is combined with a new one
01:28:35 <jmorris> oh
01:28:39 <ertes> so, imagine that map currently contains the association ('a', 5) meaning that 'a' was seen 5 times so far
01:28:48 <ertes> now it receives another ('a', 1)
01:28:55 <ertes> how would you combine 5 and 1?
01:29:31 <jmorris> +
01:29:35 <ertes> exactly
01:29:48 <ertes> > M.fromListWith (+) (map (, 1) "hello there!")
01:29:54 <lambdabot>  fromList [(' ',1),('!',1),('e',3),('h',2),('l',2),('o',1),('r',1),('t',1)]
01:30:29 <jmorris> oh
01:30:32 <jmorris> ok
01:31:39 <ertes> so first you go from a ByteString to a [Word8], then you convert each Word8 to a (Word8, Int) to include each byte's contribution to the count, then you use fromListWith
01:32:29 <ertes> > map (, 1) "hello"  -- the second step is this: each character contributes 1 of itself
01:32:31 <lambdabot>  [('h',1),('e',1),('l',1),('l',1),('o',1)]
01:33:11 <jmorris> is that prelude map?
01:33:17 <ertes> yeah
01:35:17 <jmorris> ertes: i got this error Illegal tuple section: use TupleSections
01:35:37 <jmorris> countFrequency ::
01:35:38 <jmorris>   ByteString
01:35:38 <jmorris>   -> Map Word8 Int
01:35:38 <jmorris> countFrequency s =
01:35:38 <jmorris>   fromListWith (+) (P.map (, 1) s)
01:35:48 <ertes> jmorris: oh, yeah‚Ä¶  standard haskell does not allow (, 1)‚Ä¶  put this at the top of your file:  {-# LANGUAGE TupleSections #-}
01:36:14 <ertes> jmorris: or write this: (\b -> (b, 1)), or this: flip (,) 1
01:37:07 <jmorris> i got a new error
01:37:22 <jmorris>  Couldn't match expected type ë[Word8]í with actual type ëByteStringí  In the second argument of ëP.mapí, namely ësí
01:37:27 <ertes> jmorris: expectedly so‚Ä¶  'map' takes a list, but you're giving it a ByteString
01:38:15 <ertes> there is a step just before using 'map':  convert the ByteString to a list of bytes via 'unpack'
01:39:36 <jmorris> ertes: I think it's working now
01:39:57 <jmorris> but it returns their ascii number not the char
01:40:02 <jmorris> i don't know if that matters
01:43:23 <jmorris> ertes: I'm going to stop for now
01:43:27 <jmorris> thanks for the help
01:45:10 <ertes> jmorris: i'm overly pedantic about distinguishing between bytes and characters
01:45:26 <jmorris> ertes: what do you mean?
01:45:52 <ertes> jmorris: if you want to use Char instead, you'll have to assume an encoding, because at this point you have only raw bytes
01:46:08 <mniip> octets*
01:46:13 <mniip> :)
01:46:15 <ertes> jmorris: if you assume ASCII, you can use the infamous Data.ByteString.Char8 module
01:47:41 <jmorris> ertes: is there something wrong with it?
01:49:52 <ertes> jmorris: in this case probably not, because you need to make an assumption anyway
01:51:54 <jmorris> ertes: ok thanks
02:23:12 <geekosaur> vaibhavsagar, codygman: the hashtables package is *very strongly* deprecated and only exists as a compatibility shim for ancient programs. use Data.HashMap.{Strict,Lazy} from unordered-containers; it's *much* faster and better in almost every way
02:24:35 <ertes> (would be nice to have a good hash table implementation though‚Ä¶  they are genuinely useful in certain cases)
02:25:25 <geekosaur> emphasis on "good"
02:25:31 <geekosaur> Data.Hashtable wasn't
02:25:59 <Rembane> And now there are none?
02:27:24 <ertes> at least i couldn't find one
02:28:32 <Rembane> Is a hashtable the same thing as a hashmap?
02:29:21 <ggVGc> ertes: when are you releasing your hashtable lib?
02:29:33 <geekosaur> hashtables are mutable
02:29:58 <Rembane> I see.
02:42:38 <EvilMachine> Hi. Is there a way to limit LLVM‚Äôs memory usage when using it with GHC?
02:43:19 <EvilMachine> I‚Äôm on a small ARMv7hf machine with no native code gen, and cabal-install won‚Äôt build because of it.
02:44:16 <Tuplanolla> Try `cabal +RTS -M512M -RTS`, EvilMachine.
02:45:02 <EvilMachine> Tuplanolla: Hmm, ok. That sounds good. Now I have to find out how to get this through when using my system‚Äôs package manager. :)
02:45:11 <ggVGc> is it hard to cross compile for arm?
02:45:33 <EvilMachine> ggVGc: No, especially not with Gentoo. But‚Ä¶
02:46:56 <EvilMachine> ggVGc: In practice, it is very hard to always have the exact same libraries on the cross-compiling system, with the exact same settings. And even if, you still often strangely end up with different binaries. In any case, it leads to weird errors. And I had enough of them to just build on the ARM system and be done with it. :)
02:48:17 <ggVGc> yeah, I know what you mean
02:48:30 <EvilMachine> ggVGc: On Gentoo, one can generate cross-compiling environments with a single call of `crossdev`, and distcc enables automatically using systems where it‚Äôs available, and I never got it to work reliably.
02:48:41 <vaibhavsagar> EvilMachine: would Nix help here?
02:48:52 <ggVGc> I used to work in game development, and for a while I was doing cross compilations, but even with desktop systems I soon gave up and set up build servers for each supported platform
02:49:23 <EvilMachine> Besides, the ARM system is surprisingly powerful. I mean GHC takes between 7 and 24h to build, but most everything else doesn‚Äôt feel much different than my last PC. :)
02:49:40 <ggVGc> nowadays I only cross compile if I absolutely have to, which lately has only been for android(which is easy since there's an official cros compiler)
02:49:45 <EvilMachine> vaibhavsagar: What‚Äôs Nix? (Unix minus the U? The German word for ‚Äúnothing‚Äù?) :D
02:49:49 <ggVGc> I even gave up cross compiling thigns for raspberry pi
02:49:55 <ggVGc> or rather, didn't really attempt it
02:50:01 <ggVGc> because it's almost never worth the issue
02:50:11 <EvilMachine> ggVGc: :D Btw: Are you writing games in Haskell?
02:50:11 <ggVGc> worth the bother*
02:50:34 <EvilMachine> ggVGc: Yes, for Android it works.
02:50:45 <ggVGc> EvilMachine: nah, I've made a few prototypes recently, and I started writing one in purescript. But I don't really make games much anymore
02:51:15 <ggVGc> I can recommend purescript for game frontends though. And if you write a backend in haskell, there's at least some code sharing that's possible
02:51:28 <ggVGc> but not sure the code sharing part is worth the effort
02:51:39 <ggVGc> purescript as a frontend language is real nice though, imo
02:51:46 <ggVGc> and suitable for games
02:52:25 <ggVGc> the FFI is great, so you can optimize things if needed, and because of strict evaluation, the generated code is easy to inspect and executes fast enough
02:52:47 <EvilMachine> ggVGc: :/ I don‚Äôt have the time for games either. Currently I‚Äôm building a purely mechanic music box with a squirrel that jumps from tree to tree with every beat, and lyrics that scroll by. ^^
02:53:01 <ggVGc> the downside is that no one can work on your project since like 3 people know haskell/purescript :)
02:53:11 <ggVGc> EvilMachine: sounds great
02:53:28 <ggVGc> you should share some pictures/videos when there's something to show
02:54:00 <EvilMachine> ggVGc: I‚Äôm planning on using Godot for games though. Their main developer is so smart that it gives me a warm and fuzzy feeling to look at his work. :)
02:54:17 <ggVGc> yep, godot is what I would recommend nowadays
02:54:50 <ggVGc> EvilMachine: I actually started making this because I was about to write a game with Godot a while back, https://github.com/ggVGc/nim-godot
02:54:51 <EvilMachine> ggVGc: I never heard of purescript though. Is it a Haskell-like scripting language?
02:55:13 <ggVGc> not haskell, but Nim, which is pretty nice and has a lot of functional concepts
02:55:20 <ggVGc> and compiles to ansi C so works perfectly with godot
02:55:52 <ggVGc> EvilMachine: Purescript is heavily haskell-inspired, but quite different. Syntactically it is similar, but it has strict evaluation, and has extensible records and an effects system
02:55:55 <EvilMachine> ggVGc: I‚Äô making videos and photos of every step in the project. But frankly, it doesn‚Äôt show the insane amount of researching building materials and pondering how to solve this and that problem that was required.
02:56:03 <ggVGc> those three things make it quite different in practice than haskell
02:56:20 <ggVGc> EvilMachine: display of end results never show that :)
02:56:38 <ggVGc> EvilMachine: when you see a great piano player, do you often think "wow, that guy spent several hours per day for 40 years to achieve that"
02:56:41 <ggVGc> probably not
02:56:45 <ggVGc> and all the study of music theory etc.
02:57:31 <EvilMachine> ggVGc: Nice! Godot is supposed to get arbitrary language support, I heard. But I must say, Juan is right that a specially optimized language has big advantages. Plus, it‚Äôs basically Python anyway. ^ 
02:57:33 <EvilMachine> ^^
02:58:26 <EvilMachine> ggVGc: extensible records kinda follow from it being a scripting language‚Ä¶ as would variable data types‚Ä¶ kinda the whole difference to full programming languages.
02:58:52 <ggVGc> what's a scripting language?
02:59:09 <ggVGc> purescript compiles to javascript, but I don't consider it "less of a language" than haskell
02:59:16 <ggVGc> in many ways it's more advanced
02:59:20 <ggVGc> but obviously less mature
02:59:46 <ggVGc> EvilMachine: purescript has type classes and most other things that you'd associate with haskell
03:00:14 <ggVGc> a lot of haskell theory applies, but execution model does not
03:01:10 <EvilMachine> ggVGc: Ha, my best friend in school was a Turkish Sas player. (Think of a guitar with a very narrow neck, that allows playing quarter tones.) He was crazy good, but he spent 4 hours EVERY day on it. Plus he was great at karate, *and* had the equivalent of A++s in school. He had nearly zero childhood. :/
03:01:55 <Rembane> EvilMachine: Was he a happy person?
03:02:12 <EvilMachine> ggVGc: A scripting language? Well, a programming language that‚Äôs interpreted, has Variant (or String) as its only perceived data type, and is slow as fuck. :P)
03:02:23 <EvilMachine> Rembane: Not really.
03:02:25 <ggVGc> EvilMachine: none of those apply to purescript
03:02:42 <Rembane> Purescript isn't as fast as vanilla Javascript though.
03:03:05 <ggVGc> Rembane: yeah, but it's fast enough, and when it isn't it's super easy to use the FFI to optimize things
03:03:16 <ggVGc> I've been enjoying it
03:03:16 <Rembane> OTOH you can write slower Javascript than the Purescript compiler can generate.
03:03:32 <EvilMachine> ggVGc: I‚Äôd prefer if it‚Äôd use LLVM as a backend. Which also supports compiling to JS, I think (‚ÜíEmscripten), and soon to WebAssembly. Not that I find anything of that not evil and wrong. :)
03:03:36 <ggVGc> although, I often mostly use JS still, because not having a build step and toolchain need is better for most projects
03:03:37 <Rembane> ggVGc: Indeed. 
03:04:53 <ggVGc> EvilMachine: a fairly large goal afaik of purescripts though is to generate JS that closely matches the original code, so it's easy to read if needed
03:04:58 <ggVGc> which you won't get through llvm
03:05:29 <EvilMachine> ggVGc: Is purescript less of an annoyance to write? I mean I love Haskell, but the hoops one has to jump through are insane‚Ä¶ And for all of that, it stil has an amazing load of boilerplate. (The whole record syntax and usage is just plain wrong IMHO.)
03:06:19 <EvilMachine> ggVGc: Btw: How does FFI usage fit into compiling into JS? I mean foreign interface to what language? JS? C?
03:06:28 <ggVGc> EvilMachine: so, purscript has extensible records as I said, which is a lot better than haskell's records imo. But sure, you do not get as rapid initial development as if you just used JS. On the other hand you get the benefits of a statically typed code base. You have to weigh it for your project
03:06:36 <ggVGc> FFI to JS of course
03:06:44 <ggVGc> the purescript FFI has no overhead
03:06:51 <ggVGc> since it's native data types are JS types
03:07:05 <ggVGc> hence why it's so easy to interact with other JS code
03:09:03 <EvilMachine> ggVGc: I don‚Äôt consider JS *that* rapid btw. More like raBid. ;) It feels like wading through a thick slurry where your feet never touch anything resembling reliable ground.
03:09:45 <ggVGc> well, I've had a lot of practice..
03:09:49 <bengt_> webassembly can't come soon enough
03:10:04 <ggVGc> JS is a pretty decent functional language if you ignore 70% of it
03:10:42 <EvilMachine> ggVGc: Do you have something to quickly convey the extensible records and that effects thing? Something the size of one paragraph plus example code?
03:10:53 <mannen> heylo
03:11:16 <mannen> I need the program to pause for x minutes, and every minute, print how many minutes are left until the loop exits. how should I approach this problem in haskell?
03:12:29 <ggVGc> EvilMachine: this function for example accepts a record that has at least the field "dudes" of type "StrMap", https://gist.github.com/3502b7b3fb18db7a9b5fc7fb40f8868f
03:12:46 <ggVGc> EvilMachine: that means I can send in any record with that field, rather than using a type class or something
03:12:50 <EvilMachine> bengt_: Yes. Although it strengthens that whole inner-platform effect even more. I thought about creating a graphical shell (window manager, theme) that resembles a browser, and make a parody of the extreme reverse of what e.g. FirefoxOS or ChromeOS is. :)
03:13:36 <EvilMachine> mannen: Have you looked for some thread sleep function?
03:13:40 <ggVGc> EvilMachine: you can also create records on the fly, and pass them around in a type safe way. A type declaration is just an alias for a specific set of record fields
03:13:48 <AzurTek> I am looking at haskell for the next web service at work. I would like to use minimal "magic" i.e. no yesod style frameworks - instead I'd like to build my own stack using individual packages, (http library, router, templating etc.), kind of like one does so in Clojure or Go, is this sort of approach used in Haskell or are frameworks the way to go here?
03:14:13 <EvilMachine> mannen: I think Posix has a Posix-only one, but I think there‚Äôs a generic one in the libraries for supporting threading.
03:14:42 <ggVGc> EvilMachine: and this function type means "processes a GameWorld, while using the effect RANDOM": https://gist.github.com/aba8bd81ffb9489055931c671465d9cf
03:14:55 <Tuplanolla> There's a monotonic clock in the `clock` package, mannen.
03:15:43 <ggVGc> EvilMachine: the "e" in that line is for other effects, so you can combine two effectful functions and then they'll have the type of effects from both of them. This is enabled by extensible records
03:15:55 <EvilMachine> ggVGc: Aaah, those extensible record types look nice. They make me think they‚Äôre just disguised on-the-fly typeclasses.
03:16:11 <EvilMachine> ggVGc: (Overlapping typeclasses though.)
03:16:41 <codygman> Can anyone give feedback on my json parsing with lens tutorial? https://github.com/codygman/concise-json-parsing-in-haskell
03:17:43 <EvilMachine> ggVGc: Hmm ‚Ä¶ So basically records become first-class literals, as natural as if they were tuples with named fields. I like that approach. And I think ‚Äúnamed tuples‚Äù would be a nice approach to use in Haskell.
03:18:05 <EvilMachine> ggVGc: (‚Äútuples with named fields‚Äù to be precise)
03:18:21 <ggVGc> EvilMachine: yep, I thought about that when I started getting into haskell too. "Why aren't records just named tuples". On that note, because of extensible records, purscript doesn't have tuples
03:18:26 <ggVGc> which I think is actually a good move
03:18:32 <ggVGc> because it forces you to be more clear
03:18:40 <ggVGc> and create records on the fly with named fields instead
03:19:06 <EvilMachine> ggVGc: Forgive me, but I don‚Äôt know what effects themselves actually are‚Ä¶
03:19:11 <ggVGc> EvilMachine: I think doing some purscript gives a better perspective on haskell. They're different, and each have strong and weak sides. Knowing both is useful I reckon
03:19:31 <ggVGc> EvilMachine: they are just a more granular version of IO
03:19:46 <ggVGc> instead of saying IO, you say "I use randomness" or "I do file reading"
03:20:10 <EvilMachine> ggVGc: effects doesn‚Äôt mean side-effects does it? Because I already dislike monads for the obfuscation they cause. 
03:20:42 <EvilMachine> ggVGc: (I consider anything that happens in an implied and not explicit way an obfuscation.)
03:20:44 <ggVGc> and if you use those two functions together you get a type saying for example Eff(RANDOM, FILE_IO)
03:21:11 <ggVGc> EvilMachine: yes, it means side effects. But in Haskell if you use any side effect you're in IO, and there's no way of knowing which side effect is occuring
03:21:19 <ggVGc> using randomness is the same as running system commands
03:21:28 <ggVGc> while in purescript you're forced to be more specific
03:21:58 <ggVGc> which in turn means that parts of your code can all be in a fairly low-risk Eff monad, like random, and you'll know that it doesn't do anything else than random
03:22:11 <ggVGc> while in haskell using any random value would put you in IO
03:22:28 <EvilMachine> ggVGc: :)) We definitely need that in Haskell‚Ä¶ Not with the record syntax though. those curly braces will always feel wrong to me. :)
03:23:05 <ggVGc> the reason it's like that in purescript is because of implementation simplicity. The effects system is built upon the extensible records
03:23:16 <ggVGc> which simplifies a lot of things
03:24:09 <ggVGc> anyway, I'm not sure the effects system of purescript is great, and others in here have said they don't like it. But I think also everyone agrees "everything in IO" is also not great
03:24:21 <ggVGc> that's why I said it's a good perspective even if you mostly do haskell
03:25:38 <EvilMachine> ggVGc: Yes, I agreex just like knowing Haskell made me a *much* better programmer in general, no matter the language. (Hell, my bash shell now has map, filter, foldl/foldr and a bit of lambda functions too.
03:25:39 <EvilMachine> )
03:27:14 <EvilMachine> ggVGc: Yes, unnamed fields in tuples, to me, is bad for the same reason that variant data types are bad. The purpose of the fields is not enforced. And function matching a tuple can name them however it pleases.
03:28:24 <EvilMachine> ggVGc: Ah, ok, more granular IO sounds very very sensible and needed. When one thinks about it, generic all-access IO is ridiculously insecure.
03:30:03 <EvilMachine> ggVGc: Although I must say, I liked the view that RealWorld is just a data type inside Haskell, and there are actually no side-effects at all. I‚Äôd prefer extending that philosophy when making things more granular.
03:32:10 <EvilMachine> ggVGc: I guess one could just create typeclass front-ends to IO, and never export IO for users ever though. That would give the same restrictedness.
03:32:23 <ggVGc> pretty sure things like that have been done
03:32:28 <EvilMachine> There‚Äôs probably already a library doing that.
03:32:31 <EvilMachine> yep lol
03:35:25 <EvilMachine> ggVGc: Thank you for a lot of new insights today. :) 
03:36:01 <ertes> ggVGc: mine?  i don't have one
03:36:28 <ggVGc> ertes: well, that's the issue then
03:46:45 <mannen> EvilMachine: the issue isn't sleeping, but rather looping
03:46:59 <mannen> I honestly don't know how to go about solving the problem other than in some imperative way
03:49:42 <EvilMachine> mannen: Looping is just recursive calls, e.g in the IO monad. :)
03:50:05 <mannen> are they tail-call-optimized or actual recursion calls?
03:50:25 <EvilMachine> mannen: Depends on what you pass along‚Ä¶
03:50:42 <mannen> ok, so the compile is intelligent enough to do tco if it makes sense?
03:50:45 <mannen> compiler*
03:51:25 <Tuplanolla> It's guaranteed to happen whenever it's possible, mannen. Otherwise nothing would work.
03:51:36 <mannen> thanks. 
03:51:59 <mannen> considering that you can run haskell from hs files directly, AND compile it, and the fact that it is really, really fast, I'm curious why haskell isn't more widely used.
03:52:19 <mannen> I mean, outside the realm of comp.sci., it's considered somewhat esoteric I think
03:52:29 <Tuplanolla> I guess people perceive it as academic and difficult.
03:52:57 <bengt_> it's kind of hard to pick up and most I know people consider it to be "academic", i.e. not useful for anything in the real world
03:53:06 <bengt_> *most people I know
03:53:15 <EvilMachine> > let tick = do { putStr "."; threadDelay 1000000; tick }
03:53:17 <lambdabot>  <no location info>: error:
03:53:17 <lambdabot>      not an expression: ‚Äòlet tick = do { putStr "."; threadDelay 1000000; tic...
03:53:23 <EvilMachine> > tick = do { putStr "."; threadDelay 1000000; tick } in tick
03:53:26 <lambdabot>  <hint>:1:6: error:
03:53:26 <lambdabot>      parse error on input ‚Äò=‚Äô
03:53:26 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:53:34 <EvilMachine> > let tick = do { putStr "."; threadDelay 1000000; tick } in tick
03:53:36 <lambdabot>  error:
03:53:37 <lambdabot>      Variable not in scope: threadDelay :: Integer -> IO a0
03:53:53 <EvilMachine> > import Control.Concurrent; let tick = do { putStr "."; threadDelay 1000000; tick } in tick
03:53:56 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äòimport‚Äô
03:54:01 <EvilMachine> :D
03:54:08 <EvilMachine> mannen: ‚Üë
03:54:14 <mannen> thanks
03:54:14 <vaibhavsagar> EvilMachine: https://nixos.org/
03:54:42 <EvilMachine> mannen:  tick = do { putStr "."; threadDelay 1000000; tick } -- This will print a dot every second.
03:54:57 <vaibhavsagar> declaratively specify *all* dependencies
03:55:14 <EvilMachine> mannen: also look at the ‚Äúforever‚Äù function: https://www.stackage.org/lts/hoogle?q=forever
03:55:42 <Tuplanolla> Note that `threadDelay` has skew, EvilMachine and mannen, so accurate timekeeping should be done with a persistent monotonic clock.
03:56:17 <EvilMachine> mannen: Haskell isn‚Äôt used more, because it‚Äôs hard. Where I‚Äôm from, it‚Äôs the main reason for university CS dropounts.
03:56:31 <Heffalump> anyone know about the new custom-setup section in .cabal files? Specifically, what can go wrong if you have a custom Setup.hs but no custom-setup section.
03:56:59 <EvilMachine> mannen: If you want precision, I‚Äôd probably use the Posix functions. Which use the OS functions. Which are as precise as you make your OS. :)
03:58:21 <EvilMachine> mannen: Also, yes, as Tuplanolla said, delays will always be inexact, simply because the rest of the code takes a variable and unknown amount of time too.
03:58:22 <mannen> thanks‚Äîgood to know, although in this case, precision isn't needed. :-)
03:59:14 <mannen> EvilMachine: I think saying Haskell is hard is simplifying things. I mean, why would it be hard? probably because almost all other approaches to programming are imperative and less strict
03:59:18 <mannen> Haskell *is* pretty academic
04:00:24 <EvilMachine> mannen: I‚Äôm just thinking of JavaScript‚Äôs distinction between setTimeout() and setInterval(). The equivalent of the latter, combined with something that fires off threads (or thread sparks), will give you nicely even frame rates.
04:02:46 <mannen> weight = 3.0 :: Double <-- that gives me 'top-level binding with no type signature'. I'm not sure why since I explicitly declare the type of the value
04:02:55 <mannen> do I really need to put weight :: Double on a separate row?
04:03:48 <EvilMachine> mannen: Haskell is hard because its code is very compact and very abstract. In both cases, a lot is simply implied, and not verbosely or explicitely shown. Just think about the combination of monads (esp with multiple transformers), type classes, weird operators and one-letter variables/functions. This is my personal nightmare.
04:04:24 <mannen> why is it so well suited for academia though?
04:06:06 <EvilMachine> mannen: the variable won‚Äôt tell you what it is, by looking at it. The type can be completely implicit yet utterly strict, the operator is ever worse, as it can‚Äôt even be googled for, plus what it does depends on the class instance, and thanks to the monad it does magic stuff behind your back that might turn everything on its head. (Just look at the Tardis monad. ;)
04:06:47 <EvilMachine> mannen: Hmm, maybe the 3.0 has a type signature, but the weight doesn‚Äôt.
04:07:01 <EvilMachine> mannen: Yes, you probably need to.
04:07:25 <Tuplanolla> It's a silly technicality that the type of `weight` is inferred from the type of `3.0 :: Double`, mannen.
04:07:36 <mannen> rather *
04:07:41 <mannen> rather *isn't* inferred
04:07:46 <Axman6> ls
04:08:13 <Tuplanolla> No, mannen. It's inferred.
04:08:24 <mannen> so why is it asking me to explicitly declare it?
04:08:55 <EvilMachine> mannen: It‚Äôs well-suited for academia, because (and here comes the circular reasoning / self-fulfilling prophecy), it is used as academia‚Äôs go-to pet experiment language. Everything new and cool is put into it. (Well, not everything, but it‚Äôs usually the case.) And that makes it a lot of fun to play with to test those faaar-out ideas and ways that academia gets a huge and raging boner for. (Not that I don‚Äôt und
04:08:55 <EvilMachine> erstand that. Quite the contrary. :(
04:08:57 <EvilMachine> :)
04:09:19 <EvilMachine> mannen: Inferred doesn‚Äôt mean explicid.
04:09:23 <EvilMachine> explicit
04:09:41 <mannen> I'm thinking inferred means that it figures out the type of the constant from the value
04:09:49 <mannen> which has an explicit type
04:10:19 <EvilMachine> mannen: if you say { f :: T; f = something; g = f }, then g still doesn‚Äôt have an explicit type.
04:10:42 <mannen> no, but it can be inferred, so it shouldn't ask for it to be explicitly declared, right?
04:11:03 <Tuplanolla> All rank-1 types can be inferred.
04:11:22 <EvilMachine> mannen: basically, you can see { weight = 3.0 :: Double } as { x :: Double; x = 3.0; weight = x }
04:11:30 <mannen> I should probably read up on this and not bother you about it‚Äîsorry. kind of eager to learn haskell. :-)
04:12:17 <mannen> I see. I don't really understand the warning though since the type for weight (in my example) is blatantly obvious
04:13:31 <EvilMachine> mannen: It should not ask you to explicitely declare it. That is optional. There‚Äôs only some corner cases where not explicitely declaring types for top-level declarations causes errors that are hard to understand and to debug. Which is why GHC recommends always setting them. You can just not turn that warning on though. :)
04:13:46 <mannen> ahh, I see
04:14:00 <EvilMachine> mannen: You could rightfully see that as a weird implementation problem.
04:14:01 <mannen> this is flycheck in emacs btw, but maybe it uses ghc as its backend, I don't know
04:14:09 <cocreature> it does iirc
04:14:40 <cocreature> mannen: also note that it‚Äôs not so obvious that the type of 3.0 is Double, floating point literals have a more general type
04:14:42 <EvilMachine> mannen: You aren‚Äôt bothering us. This is why we‚Äôre here for.
04:14:43 <cocreature> :t 3.0
04:14:45 <lambdabot> Fractional t => t
04:15:08 <mannen> :-)
04:15:31 <EvilMachine> cocreature: In this example it is.
04:15:44 <EvilMachine> cocreature: He said { weight = 3.0 :: Double }
04:15:47 <cocreature> oh sorry then. I haven‚Äôt looked too closely
04:15:54 <EvilMachine> :)
04:16:19 <Tuplanolla> There's a corner case here I'd like to see fixed.
04:16:33 <EvilMachine> Tuplanolla: :) Yes.
04:16:43 <Tuplanolla> With `ScopedTypeVariables` the warning still appears with `weight :: Double = 3`.
04:17:02 <EvilMachine> Tuplanolla: Wait, you can write code like that?
04:18:18 <mannen> weight :: Double = 3.0 -- kg <-- gives me illegal type signature
04:18:46 <EvilMachine> Tuplanolla: You know, the worst thing when learning haskell, was falling over all the non-standard code all the time. Often I didn‚Äôt even know how to parse that stuff in my mind, not where to look it up. Even now, I would first have to learn all of all used extensions‚Äô syntax. Which is no fun, if you‚Äôre still a good bit away from that guru 9001 level.
04:19:03 <EvilMachine> mannen: It is a compiler extension
04:19:37 <EvilMachine> mannen: You have to put a {-# LANGUAGE ScopedTypeVariable #-} at the beginning of the file.
04:19:53 <geekosaur> ScopedTypeVariables
04:19:54 <EvilMachine> mannen: oops, I meant ScopedTypeVariables
04:20:01 <EvilMachine> geekosaur: thanks
04:20:07 <geekosaur> otherwise it gets silently ignored unless you have the right warning options
04:20:35 <EvilMachine> geekosaur: Nah, it get a illegal type signature error. As mannen stated.
04:20:39 <EvilMachine> +s
04:20:50 <geekosaur> I mean the pragma itself is ignored silently
04:20:57 <EvilMachine> geekosaur: Ah, yes.
04:21:54 <EvilMachine> geekosaur: It shouldn‚Äôt though, should it? I mean as long as the rest of the pragma is valid, the compiler should imply that the code won‚Äôt do what you want unless the extension with that specific name is used.
04:22:51 <geekosaur> I prefer to find out I typoed the pragma directly instead of having to infer it. for this one it might be simple; for others, not so much
04:23:36 <EvilMachine> geekosaur: Uuum, that‚Äôs what I‚Äôm saying.
04:23:42 <geekosaur> (in particular, if you're actually using scoped type variables (as opposed to pattern type signatures) but typoed the pragma, you will get odd type errors
04:23:45 <EvilMachine> unless I misunderstood you
04:24:11 <geekosaur> anyway the haskell standard says to ignore unknown pragmas
04:24:19 <EvilMachine> geekosaur: I‚Äôm saying: If the compiler doesn‚Äôt know the extension, it should not be silent about it but throw an error and exit.
04:24:31 <geekosaur> (because, for example, you don;t want an experimental compiler to throw fits over a RULES pragma for ghc)
04:24:34 <EvilMachine> hmm, they probably had a reason for it.
04:24:43 <EvilMachine> ah, ok
04:24:49 <geekosaur> or SPECIALISE, etc.
04:24:56 <EvilMachine> geekosaur: makes sense.
04:25:45 <EvilMachine> Still, I only accept a solution where *both* problems are addressed without compromises. Silently implying is as bad as using non-strict typing.
04:26:25 <EvilMachine> And falling over foreign but non-code-meaning-altering pragmas either.
04:26:28 <geekosaur> I think it should be a warning that is on by default
04:27:19 <geekosaur> which fits the intent of the standard (don't abort compilation on a macro that only does optimization in compilers that support it) while providing useful information
04:27:31 <EvilMachine> Maybe there should be two kinds of pragmas. Those that alter the meaning or syntax of the code and cannot result in the right code on a compiler that doesn‚Äôt have that extension, and those pragmas that don‚Äôt do that.
04:27:42 <EvilMachine> geekosaur: Yes, good solution.
04:29:09 <EvilMachine> Sensible conversations ‚Ä¶ People making great points and agreeing ‚Ä¶ This channel truly is a bubble of negative space in the Internet.
04:29:12 <geekosaur> especially since there's an edge case that happens fairly often: you put a pragma that changes how source is compiled too late (after it's started parsing code), it's silently ignored and you potentially get weird errors
04:29:31 <vapid> i am the negativest
04:29:59 <EvilMachine> vapid: No I am!!11one(lim (x‚Üí0) ((sin x)/x))
04:30:27 <geekosaur> ...of course that meme had to have a mathy variant >.>
04:30:56 <MarcelineVQ> or possibly even more commonly people mispell parts of pragmas
04:31:07 <EvilMachine> geekosaur: Maddox is the source: http://www.thebestpageintheuniverse.net/images/holy_shit_iphone2.gif
04:31:14 <EvilMachine> geekosaur: From http://www.thebestpageintheuniverse.net/c.cgi?u=iphone
04:32:11 <EvilMachine> MarcelineVQ: That was my argument in the discussion. :)
04:40:56 <duairc> I have an (injective) type family TF, and its inverse UnTF. What I'd really like to do is declare an instance of ~ like instance UnTF (TF a) ~ a... but I can't declare instances of ~. What's the best workaround?
04:46:50 <mniip> duairc, declare a constraint synonym to use everywhere
04:47:15 <mniip> type TF' a b = (b ~ TF a, a ~ UnTF b)
04:47:40 <mniip> I don't know of a better way
04:48:28 <duairc> mniip: Yeah, I'm essentially doing that. Even that gets a bit unweildy though. I just wish I could teach GHC to automatically reduce UnTF (TF a) to a. I wish there was some super unsafe way I could just declare an instance of ~ and let it infer the rest.
04:48:58 <Heffalump> ~ is a primitive, it doesn't feel like the kind of thing you should be able to declare an instance of
04:49:14 <mniip> ~ is an element of syntax
04:49:17 <duairc> I also have another type family, let's say X, and I want to be able tell GHC that it distributes over TF and UnTF, i.e., X (TF a) ~ TF (X a) and X (UnTF a) ~ UnTF (X a)
04:49:19 <mniip> it isn't a constraint operator
04:49:39 <mniip> duairc, you have to drag those constraints around with yourself
04:49:47 <mniip> by yourself*
04:50:31 <duairc> mniip: Heffalump: It actually isn't built-in, it's defined (as a class) in https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Type.Equality.html
04:50:40 <duairc> ~~ is built-in
04:51:15 <mniip> I would treat everything "declared" in base with a bit of skepticism
04:51:19 <Heffalump> duairc: ok, I think that's a new change because of the kind system
04:51:41 <duairc> mniip: I know, obviously it's a special case
04:52:06 <mniip> notice how ~ isnt exported from the module
04:52:48 <duairc> My life would just be so much easier though if I could just say "pretend this equality holds". Because it's not just those constraints I have to drag around, but in many cases everything implied by them as well
04:53:31 <mniip> constraint synonyms
04:53:45 <duairc> In a lot of places actually I've been getting away with using PartialTypeSignatures have _ => at the start of my type signatures
04:54:26 <duairc> (The functions where I do that are polymorphic... when they're called with a specific type, GHC is able to do the reduction itself.)
04:54:28 <mniip> uhhuh
04:54:30 <ertes> :k (~)
04:54:33 <lambdabot> k -> k -> Constraint
04:54:35 <ertes> mniip: ^
04:54:42 <mniip> that's because it's wired in
04:55:03 <wz1000> Does anyone know what is the status of Summer of Code this year?
04:56:24 <ertes> duairc: what about not using type families, but fundeps?  class C a b c | a -> b c, b -> c, c -> b
04:56:35 <geekosaur> duairc, I think currently you have to use plugins for that. or possibly RULES
04:56:45 <ertes> duairc: then expressing equality is merely an act of reusing a type variable:  (C a b b) => ‚Ä¶
04:56:51 <ertes> oh, wait
04:56:55 <ertes> that's not what you're asking for
04:57:13 <geekosaur> hm, no, if that;s tyoe level then RULES won;t do it
04:57:21 <ertes> yet equality just falls out of it naturally, because there are no actual type-level functions involved‚Ä¶  it's just logic
04:58:40 <duairc> geekosaur: Oh, plugins! Well, I don't think I actually mind using a plugin for this, even if it's a bit overkill. Are there any existing plugins for this kind of thing or do I have to write my own? Are there any guides for that?
04:58:59 <geekosaur> afaik you have to write your own
04:59:17 <geekosaur> people have written plugins for this kind of thing but they all tend to be special purpose
05:00:01 <duairc> I suppose this probably wouldn't be a bad starting point, it's not a million miles away from what I'm doing: https://hackage.haskell.org/package/ghc-typelits-natnormalise 
05:00:55 <mannen> so s <- getLine "calls" getLine and stores the result in s. how can I do that without saving the result? just curious
05:01:14 <geekosaur> one of the problems with plugins is the interface is still in flux
05:01:35 <geekosaur> mannen: use (>>=) directly instead of do syntax
05:01:49 <geekosaur> :t getLine >>= putStrLn
05:01:52 <lambdabot> IO ()
05:02:07 <mannen> geekosaur: what if I want to throw away the result
05:02:42 <geekosaur> pattern match to _, use Data.Functor.void, or use >> instead of >>=
05:02:54 <mannen> ie _ <- getLine?
05:03:05 <geekosaur> (or just say getLine and turn off the warning)
05:03:08 <geekosaur> yes
05:03:16 <mannen> thanks
05:05:59 <ertes> mannen: "<-" really just gives the result a name‚Ä¶  if you don't care about it, just don't give it a name "ln <- getLine" vs. just "getLine"
05:06:02 <nitrix> How do I #define a constant before an inclusion; using the FFI for C ?
05:06:25 <mannen> is there a non-blocking getChar? ie, one that returns a char if one is available in the input stream,otherwise some null value?
05:06:38 <ertes> mannen: use hReady
05:07:00 <ertes> mannen: or use multiple threads (preferred)
05:07:14 <mannen> oh, is that really preferred? I was thinking the other way around
05:07:32 <MarcelineVQ> nitrix: are you asking about -D flags? e.g. cpp-options:    -DSomethingNowDefined
05:07:55 <ertes> mannen: a haskell thread does not correspond to an OS thread‚Ä¶  haskell translates its threads to basically what you would have done in most other languages using select/poll/epoll
05:08:06 <mannen> wow, that's amazing
05:08:14 <ertes> mannen: so nothing wrong with creating tens of thousands of threads
05:09:46 <ertes> mannen: to learn more read from chapter 7: http://chimera.labs.oreilly.com/books/1230000000929/
05:10:08 <mannen> I think that's too complex for me right now as I started haskell yesterday, but I'll def. keep it in mind for later
05:11:55 <mannen> so I want to wait for x minutes, and every minute, say how many minutes are left. my default approach is the imperative one, but could I reason abuot this in a different way?
05:12:31 <mannen> there are no syntactic loops in haskell so I'm thinking I'd do a recursive function and assume that it rolls itself out into a loop with tail-call-optimization
05:13:03 <ertes> mannen: it literally translates to such a loop, so yeah, just go with recursion
05:13:21 <ertes> mannen: you could also make a list of delays, and then use mapM_
05:13:46 <ertes> ah, not quite
05:13:55 <ertes> nevermind, use recursion for now
05:22:29 <mannen> is there any convention for how to use $? ie putStrLn $ show n ++ " mins left" vs without $, what's preferred?
05:22:52 <nitrix> mannen: In this example, I'd use parens.
05:23:08 <nitrix> mannen: I only use $ when I'd get a ridiculous amount of nested parens.
05:23:10 <mannen> nitrix: I need to know why :-)
05:23:10 <mannen> ok
05:23:11 <benmachine> I think there's no universal convention, it's a matter of style / opinion
05:23:54 <geekosaur> ^
05:24:12 <geekosaur> there are people who strongly dislike it and people who use it everywhere
05:28:00 <mannen> there are so many different ways of doing the same thing in haskell, how do I know which one is right? just experience?
05:29:33 <cocreature> mannen: there can be several ways that are just fine :) but yeah in general only experience can help you there
05:30:30 <MarcelineVQ> you (I) tend to stumble into simpler patterns after trying convoluted things and then smack your head for not doing it sooner
05:30:34 <sbrg> mannen: there is no universal 'right' when it comes to style and personal choice
05:30:55 <sbrg> I used to use $ way too much. it becomes ugly, so I try to use parens when it is more readable now
05:31:15 <Tuplanolla> It seems that everyone goes through that `$` phase.
05:31:43 <Berra> Except lispers
05:31:48 <cocreature> sbrg: be careful, otherwise you‚Äôll find yourself writing lisp before you know it
05:36:51 <sbrg> liskell
05:36:54 <sbrg> hasp?
05:36:56 <sbrg> lispell?
05:37:21 <sbrg> or maybe just hathkell
05:40:15 <mannen> lol @ hathkell
05:41:40 <mannen> how can I run a function in a separate thread?
05:41:43 <Tuplanolla> I had a Lisp-like language project at one point that I called Solispsism, but I got sick of writing that name, so I put it on indefinite hold.
05:42:04 <mannen> really clever name though
05:42:12 <Tuplanolla> You `forkIO $ do ...`, mannen.
05:42:20 <mannen> I like hy, but the name is horrible lol
05:43:50 <mannen> Tuplanolla: is ghc clever enough to use green threads for that if possible?
05:44:26 <Tuplanolla> So says the documentation.
05:46:39 <haskell143> can someone explain clearly what a recursive type is?
05:48:18 <sbrg> haskell143: It's a type that refers to itself.
05:48:29 <sbrg> data Foo = FooThing Int FooThing
05:48:36 <sbrg> uh
05:48:38 <sbrg> data Foo = FooThing Int Foo
05:49:27 <haskell143> so what's that saying?\
05:49:53 <sbrg> This defines a new type called 'Foo'. It has one value constructor called 'FooThing', and that value constructor takes two parameters: an integer, and another value of type 'Foo'
05:50:41 <sbrg> Because there is only one way to construct a value of this type, and it has a reference to itself, that type is basically isomorphic to an infinite list of Ints
05:51:14 <sbrg> (If I want to create a Foo, I use FooThing, which takes an Int and another Foo, and if I want to create a Foo, I use FooThing, which takes an Int and another Foo, etc etc)
05:52:15 <haskell143> so it's creating an infinite list of Ints?
05:52:21 <haskell143> because you keep using Foo
05:53:07 <sbrg> the type itself isn't creating anything, but if I want to create a value of that type, the resulting value can only be an infinite list of integers. Mind, because of laziness, the infinite part doesn't really matter(i don't create an infinite list of integers and store it in memory)
05:53:34 <sbrg> Another example would be: data MyIntList = IntItem Int MyIntList | EndOfList
05:53:47 <haskell143> if I did
05:53:51 <haskell143> [1,2,3] = Foo
05:53:56 <haskell143> or the other way around
05:53:58 <haskell143> is that valid?
05:54:11 <dramforever> You've got a problem over there
05:54:25 <dramforever> You know what's an 'Algebraic Data Type'?
05:54:34 <haskell143> you talking to me now?
05:54:47 <dramforever> yep
05:54:50 <haskell143> no
05:54:52 <sbrg> Nope. but you can write a function that could do it, more or less. Except for the fact that it can never match the pattern [1,2,3] since it's an infinite list
05:54:52 <haskell143> I don't
05:54:53 <dramforever> You know how 'data' works?
05:54:58 <haskell143> sure
05:55:13 <haskell143> if I did [1..] = Foo
05:55:15 <haskell143> that's valid right?
05:55:36 <sbrg> No. 
05:55:38 <dramforever> Either don't understand how 'data' works, or you're being really sloppy with notation
05:55:53 <dramforever> Let's see. What if I had this: data Foo = FooThing Int
05:56:05 <dramforever> How do I make something so that it has type Foo?
05:56:27 <sbrg> Foo here is a type. FooThing is a value constructor of that type. Trying to do [1,2,3] = Foo is basically saying 'I think Foo is a function which returns a list of integers' but it isn't
05:56:32 <sbrg> since Foo is a type
05:56:36 <sbrg> It wouldn't be valid using FooThing either.
05:56:49 <dramforever> --- Check your understanding ---
05:57:05 <haskell143> when would there be a case where Foo is ok?
05:57:15 <haskell143> because types are just constraints
05:57:20 <haskell143> so how can I apply Foo to an infinite list?
05:57:24 <haskell143> or assign
05:57:25 <dramforever> Yes, but after you understand how 'data' works
05:57:43 <haskell143> data is just anything
05:57:48 <haskell143> it can be numbers, strings etc
05:58:04 <dramforever> I mean the 'data Foo = FooThing Int'
05:58:07 <haskell143> oh
05:58:12 <dramforever> You know what's the deal about it?
05:58:27 <haskell143> yeah it just makes a data type called Foo with a constraint that takes one Int as a param
05:58:51 <dramforever> That's not quite right
05:59:16 <Axman6> s/constraint/constructor, no?
05:59:18 <dramforever> It means it makes a type Foo, and a 'constructor' that takes an Int and constructs a foo
05:59:30 <dramforever> I suppose you may understand this: FooThing :: Int -> Foo
05:59:38 <haskell143> yep
05:59:49 <dramforever> How do I make something of type Foo?
05:59:52 <haskell143> declare a function that takes an Int
05:59:55 <haskell143> output a Foo
06:00:08 <Axman6> with `FooThink 7`
06:00:12 <Axman6> G*
06:00:33 <dramforever> haskell143: you've been programming C or C++ for life, right?
06:01:38 <dramforever> Okay, forget about it. Do you understand how FooThing 7 works?
06:01:52 <dramforever> or rather, understand that 'it works'?
06:02:28 <haskell143> umm
06:02:35 <haskell143> does it take 7 and make an infinite list from 7?
06:02:42 <dramforever> That's going too far
06:02:46 <Axman6> there are no lists
06:02:49 <dramforever> data Foo = FooThing Int
06:02:54 <dramforever> nothing recursive here
06:02:58 <haskell143> oh
06:03:00 <dramforever> just plain old data type
06:03:11 <haskell143> I mean
06:03:16 <haskell143> if you just input 7 into FooThing
06:03:23 <dramforever> And?
06:03:27 <haskell143> it's going to output 7?
06:03:36 <haskell143> because there isn't much being done
06:03:37 <dramforever> Let's see for sure!
06:03:43 <haskell143> ok
06:03:51 <dramforever> @let data Foo = FooThing Int deriving (Show)
06:03:54 <lambdabot>  Defined.
06:03:55 <Axman6> FooThing is a function which, when given an Int, gives back a Foo
06:04:03 <dramforever> > FooThing 7 -- What will it be?
06:04:08 <lambdabot>  FooThing 7
06:04:12 <dramforever> Hmm that's interesting
06:04:30 <Axman6> anf the constructor for that Foo is FooThing (which happens to be the only constructor for a Foo)
06:04:40 <haskell143> so it gives back 7?
06:04:43 <dramforever> (The 'deriving (Show)' part basically means 'generate printing functions for me')
06:04:56 <dramforever> haskell143: Read the whole thing. FooThing 7
06:04:58 <Axman6> no, it gives back FooThing 7, which has type Foo
06:05:20 <Axman6> @let data Bar = L Int | R Bool deriving Show
06:05:21 <dramforever> #haskell duetto
06:05:23 <lambdabot>  Defined.
06:05:26 <Axman6> > L 7
06:05:30 <lambdabot>  L 7
06:05:37 <Axman6> > R True
06:05:40 <lambdabot>  R True
06:05:53 <Axman6> these are both pieces of data of type Bar
06:06:03 <Axman6> :t R
06:06:04 <dramforever> haskell143: You *do* know C right? Or what about C++?
06:06:05 <lambdabot> Bool -> Bar
06:06:11 <Axman6> :t R True
06:06:12 <haskell143> I know a little of C and C++
06:06:13 <lambdabot> Bar
06:06:17 <haskell143> I've been taught in Java though
06:06:17 <dramforever> Good enough
06:07:12 <haskell143> right so whatever you input is the output
06:07:31 <dramforever> struct Foo { int x; Foo(int x_): x(x_) {} };
06:07:37 <dramforever> What's Foo(5)?
06:07:48 <haskell143> 5
06:07:57 <dramforever> What's the type of 5?
06:07:59 <haskell143> Foo
06:08:10 <haskell143> well
06:08:12 <haskell143> it's an int
06:08:14 <haskell143> sorry
06:08:28 <dramforever> Then where did Foo go?
06:08:32 <haskell143> oh no
06:08:35 <haskell143> when you input it
06:08:37 <haskell143> it's 5
06:08:40 <haskell143> but then when you output it
06:08:41 <haskell143> it's FOo
06:08:45 <dramforever> Great
06:08:53 <haskell143> so it's int first, then Foo last
06:09:37 <dramforever> (Note. Nothing is sequenced that much in Haskell, but it's not important here)
06:10:11 <dramforever> In Haskell, data types and constructors don't have to have the same name, because a type can have several differently-named constructors
06:10:18 <dramforever> data Foo = FooThing Int
06:10:36 <dramforever> FooThing is the constructor, Foo is the type
06:11:08 <dramforever> and data types are very data, so the constructos just put its arguments together. 
06:11:20 <haskell143> much like C
06:11:24 <dramforever> Hmm. Let's see if this is a good analogy:
06:11:25 <mannen> how do I wait for a forkio thread to finish?
06:11:33 <dramforever> data Pair = MakePair Int Int
06:11:44 <dramforever> vs. std::pair and std::make_pair
06:11:47 <Axman6> you may also give the arguments names, so the anlogue with the Java example would be data Foo = FooThing {x :: Int}
06:12:16 <Axman6> mannen: if you can, you're better off using Control.Concurrent.Async
06:12:26 <dramforever> mannen: 1) You may use the 'async' package, or 2) write to an MVar after the child thread finishes
06:12:29 <mannen> Axman6: how?
06:12:43 <dramforever> haskell143: I'm glad you understand it better
06:12:50 <dramforever> let's go back to the recursive example
06:12:53 <haskell143> ok
06:12:55 <dramforever> @undefine
06:12:55 <lambdabot> Undefined.
06:12:56 <Axman6> mannen: if you don't want the etra library, you can make an empty MVar, and have the thread put any value into it, and wait on that MVar in the forking thread
06:13:10 <dramforever> @let data Foo = FooThing Int Foo
06:13:12 <lambdabot>  Defined.
06:13:46 <mannen> I'm spawning a separate thread to run getLine in it since it is blocking. I want to either way x minutes, OR for the getLine thread to return, whichever happens first
06:13:52 <mannen> I don't know how to go about doing that at all
06:14:01 <mannen> either wait*
06:14:05 <Axman6> mannen: look at the sync package
06:14:24 <Axman6> it exists for exactly these sorts of problems
06:14:32 <dramforever> mannen: http://hackage.haskell.org/package/base-4.9.1.0/docs/System-IO.html#v:hWaitForInput
06:14:55 <mannen> oh
06:14:57 <dramforever> 'Do not multiply entities beyond necessity'
06:15:06 <dramforever> Do read the 'NOTE for GHC users'
06:15:17 <dramforever> haskell143: Still there?
06:15:21 <haskell143> yep
06:15:58 <mannen> oh
06:16:13 <YellowOnion_> mannen, mannen you want poll, and cancel functions from async I think.
06:16:32 <dramforever> So clearly we need a (FooThing _ _)
06:16:38 <dramforever> underscore means 'TODO'
06:16:56 <dramforever> The first one is easy, let's put 7 over there
06:17:01 <haskell143> ok
06:17:16 <dramforever> Now the second one gets interesting. We need another 'Foo'
06:17:21 <dramforever> Where can I find one?
06:17:44 <YellowOnion_> mannen, there's also "race" which might simplify it depending on what you're trying to do.
06:18:00 <haskell143> well you gotta declare it first
06:18:04 <dramforever> You can't write an infinitely long program, but there's a Foo out there already, see if you can see it...
06:18:19 <dramforever> No we don't need to declare it
06:18:33 <dramforever> It's an expression and we're talking about its value
06:18:42 <haskell143> uhh
06:18:49 <haskell143> data Foo = FooThing Int Foo
06:18:51 <haskell143> Foo is that
06:18:55 <haskell143> yes?
06:18:55 <dramforever> Nothing to declare for 1+1 right?
06:18:59 <haskell143> no
06:19:01 <dramforever> yes Foo is that
06:19:21 <dramforever> Okay that was actually half a trick question
06:19:31 <dramforever> The Foo we already have is the one we are defining
06:19:42 <dramforever> It's called 'recursion'
06:19:49 * dramforever makes the quoting guesture
06:19:53 <haskell143> so you're re-defining a definition?
06:20:02 <dramforever> where?
06:20:05 <dramforever> Foo?
06:20:07 <haskell143> nah I mean
06:20:09 <mannen> how do is use an IO Bool in an if statement?
06:20:13 <haskell143> you already have Foo defined
06:20:17 <dramforever> No I deleted that
06:20:18 <haskell143> so you're redefining it again?
06:20:20 <haskell143> oh
06:20:22 <haskell143> so what do you mean sorry?
06:20:25 <dramforever> I sent @undefine and deleted that
06:20:31 <haskell143> ok
06:20:56 <dramforever> We are now at this: FooThing 7 _
06:21:08 <dramforever> We need a 'Foo' for the second 'hole'
06:21:20 <dramforever> Where is it?
06:21:22 <Eduard_Munteanu> mannen, you don't... x <- myIOBool; if x then y else z;
06:21:41 <dihuteno> is there something like newtype that lets you make (a) shorten an annoyingly verbose type (b) make it instances of classes which the underlying type isn't an instance of; and (c) retain the ability to use functions on the underlying type without pattern matching the newtype away?
06:22:13 <geekosaur> dihuteno, no
06:22:33 <haskell143> it's just
06:22:34 <haskell143> Foo
06:22:36 <haskell143> FooThing 7 Foo
06:22:37 <haskell143> surely?
06:22:40 <Eduard_Munteanu> dihuteno, you can use TypeSynonymInstances with 'type' in some cases
06:22:43 <geekosaur> in particular (c) is not going to happen
06:22:44 <dramforever> dihuteno: 'shorten', well do you mean a simple alias 'type Foo = LongTypeType'?
06:22:46 <dihuteno> geekosaur: is the best thing to do to use newtype and just make a convenient funnction for extracting the underlying type?
06:22:51 <dramforever> haskell143: Nope
06:22:55 <haskell143> wtf
06:22:57 <dramforever> Foo is just a type
06:23:12 <haskell143> FooThing 7 7?
06:23:20 <dramforever> You can't expect to literally call void fn(int r); like fn(int) right?
06:23:27 <dihuteno> dramforever: can I make type aliases an instance of a class which overrides the instance of the underlying type?
06:23:32 <dramforever> But 7 isn't a Foo
06:23:35 <haskell143> no you gotta pass something in
06:23:39 <dramforever> dihuteno: uh not quite
06:23:45 <haskell143> Foo(7)?
06:23:56 <geekosaur> Eduard_Munteanu, TypeSynonymInstances doesn't let you make a `type` an instance of something that the expansion isn't
06:24:02 <dramforever> FooThing 7 (FooThing 7 _)
06:24:07 <haskell143> oh
06:24:13 <dramforever> You're still having a 'todo' there!
06:24:15 <haskell143> OOOH
06:24:16 <haskell143> ok
06:24:21 <mannen> using getCurrentTime, how can I calculate the difference in minutes between two such values?
06:24:24 <Eduard_Munteanu> No, but you can declare new instances using the type synonym instead of the possibly lengthy expansion.
06:24:25 <dramforever> dihuteno: try coerce?
06:24:26 <geekosaur> (more precisely, it makes the expansion an instance. `type` is exactly an alias; it has no separate existence)
06:24:48 <dramforever> dihuteno: http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Coerce.html
06:24:59 <dramforever> haskell143: well the trick kicks in
06:25:11 <dramforever> We are going to *recurse* it all up
06:25:22 <haskell143> ok
06:25:41 <dihuteno> a specific example which is giving me grief is Data.Map.Map being a monoid, but where a conflict of keys results in the second map overriding the first, my values are all monoids so I want to mappend the values instead
06:25:42 <dramforever> 'let'. You know what 'let ... in ...' does?
06:26:14 <dramforever> haskell143: ^
06:27:03 <dramforever> dihuteno: When you use it as a Monoid, wrap it. When you get a wrapped thing back, unwrap it
06:27:21 <haskell143> uh yeah
06:27:28 <haskell143> let something in something do something
06:27:29 <haskell143> basicalyl
06:27:39 <dramforever> uh, no not the do part
06:27:47 <haskell143> oh
06:27:47 <dramforever> > let x = 2 in x + x + 3
06:27:49 <lambdabot>  7
06:27:53 <haskell143> yeah ok
06:28:21 <dramforever> @let deriving instance Show Foo
06:28:23 <lambdabot>  Defined.
06:28:55 <dramforever> > let x = FooThing 7 x in x -- lo and behold:
06:28:59 <lambdabot>  FooThing 7 (FooThing 7 (FooThing 7 (FooThing 7 (FooThing 7 (FooThing 7 (FooT...
06:29:17 <dihuteno> dramforever: yeah, type synonym for general convenience and then a monoidal wrapper sounds like it might be the best
06:29:18 <dramforever> Horray looks like it worked
06:29:23 <dihuteno> I'll give it a shot, thanks all
06:29:52 <dramforever> dihuteno: it only makes sense if some other function needs monoids
06:29:56 <haskell143> ok so it's just repeating a load of FooThings
06:30:06 <dramforever> but why, you may ask?
06:30:15 <dramforever> you do want to ask right?
06:30:19 <haskell143> yeah,
06:30:20 <haskell143> why
06:30:21 <haskell143> :P
06:30:36 <dramforever> because x = FooThing 7 x
06:30:49 <haskell143> and you're passing the x back in all the time
06:31:02 <dramforever> It's a *cycle* there!
06:31:07 <haskell143> yes
06:31:13 <dramforever> You understand the thing called 'linked lists'?
06:31:21 <haskell143> yeah it's just arrays
06:31:27 <haskell143> with pointers to addresses in memory
06:31:35 <haskell143> then you get the value in that address
06:31:38 <haskell143> pretty much
06:31:44 <dramforever> You can have a cyclic linked list, right?
06:31:48 <haskell143> sure
06:31:56 <dramforever> That's what's happening here
06:32:00 <dramforever> just without the pointers
06:32:09 <dramforever> (They are abstracted away)
06:32:16 <haskell143> so uh
06:32:24 <haskell143> you're just creating a looped linked list?
06:32:29 <dramforever> yeah
06:32:34 <haskell143> interesting
06:33:05 <dramforever> so, now we've got the 'list' part clear
06:33:21 <haskell143> yeh
06:33:59 <dramforever> So what's a recursive type, again?
06:34:10 <haskell143> it's a type that references itself
06:34:10 <dramforever> It's nothing unusual! It
06:34:14 <dramforever> Sorry
06:34:26 <dramforever> It's more like an ability rather than a property
06:34:42 <mannen> how do I retrieve the number of seconds from a NominalDiffTime?
06:35:31 <haskell143> yeh ok
06:36:00 <jaspervdj> mannen: you can use `round` to convert it to an Integer
06:36:32 <mannen> thanks
06:38:47 <dramforever> Learn your standard library! NominalDiffTime is Real, and there's a...
06:38:52 <dramforever> :t realToFrac
06:38:54 <lambdabot> (Real a, Fractional b) => a -> b
06:39:38 <dramforever> And it's also RealFrac, which is why you can use...
06:39:40 <dramforever> :t round
06:39:42 <lambdabot> (RealFrac a, Integral b) => a -> b
06:42:36 <dramforever> Or rather, learn your numeric classes...
06:44:14 <haskell143> dramforever thanks dude
06:44:45 <dramforever> you're welcome
06:46:14 <knupfer> Is it possible to drop from a haskell program into bash (not haskline)?
06:49:01 <hexagoxel> knupfer: yes. Some System.Process function will do that if you inherit stdout/in/err
06:49:45 <knupfer> hexagoxel: ok, thanks!
06:51:12 <knupfer> I'm writing a nix clone in haskell, and after just about 3 days of work it already compiles emacs :)
06:51:48 <knupfer> (without gtk)
06:53:11 <jaspervdj> knupfer: sounds interesting -- what language do you write the compilation configurations in?  A haskell EDSL?
06:54:21 <knupfer> jaspervdj: At the moment it's a custom monad layered over shake
06:54:33 <knupfer> (the custom monad is to prohibit liftIO)
06:55:28 <hexagoxel> knupfer: System.Process.callProcess "/usr/bin/bash" []
06:55:43 <vapid> lists were a mistake
06:55:47 <knupfer> no
06:56:36 <knupfer> jaspervdj: a package is just an adt, so you can define packages in terms of others with record updates
06:57:36 <knupfer> and for every package with a free license it tries to download it via ipfs and adds it automatically if only found via a conventional url
06:58:02 <jaspervdj> neat
06:58:05 <dramforever> vapid: Yes
06:58:15 <vapid> dramforever: indeed
06:58:21 <knupfer> hexagoxel: thanks, works like a charm
07:00:10 <knupfer> perhaps in a month I'll make my implementation public, at the moment it's still a bit wonky
07:10:36 <mannen> how do I do local function constants? just assign them with let?
07:10:55 <bennofs> knupfer: is there a repo?
07:11:15 <bennofs> knupfer: oops, should've read your last sentence :)
07:11:52 <Welkin> you don't assign anything
07:12:07 <bennofs> mannen: you can use let or where, yes
07:12:12 <Welkin> you can use let (or where) to accomplish what you want
07:12:28 <Welkin> > let a = 5 in a + 2
07:12:31 <lambdabot>  7
07:30:12 <wespiser> jaspervdj: Thanks for Hakyll, i used to host my website, wespiser.com
07:31:43 <jaspervdj> wespiser: glad you like it!
07:33:34 <wespiser> It allowed to me host a ton of content on Haskell, using Haskell, very quickly. I'll move away from the default styling once I learn more about css/js/web
07:59:36 <tsmish> I wonder why "let f n = if n == 0 then 1 else f (n-1) in f k" allocates more memory as k grows.
08:05:09 <cocreature> tsmish: have you tried adding an explicit type signature? at least for Int memory usage should be constant as far as I can see
08:07:36 <tsmish> cocreature: added it now, memory usage seems constant now. still wondering about Integer case. 
08:08:41 <cocreature> tsmish: Integer will show a logarithmic growth but that should be really slow
08:09:18 <cocreature> tsmish: I‚Äôm more worried about a "(Num a, Eq a) => ‚Ä¶) signature than Integer
08:09:31 <cocreature> tsmish: how are you measuring?
08:09:37 <tsmish> cocreature: +RTS -s
08:09:44 <geekosaur> or maybe just compile with optimization
08:10:28 <tsmish> geekosaur: memory usage seems linear even with -O2. i'm using ghc.
08:11:23 <cocreature> hm
08:11:34 <cocreature> n == 0 should force the evaluation so there shouldn‚Äôt be a spaceleak
08:13:04 <tsmish> cocreature: gc collects all memory. 3Gb allocated. 1M in use.
08:14:37 <cocreature> tsmish: can you show us the exact program that you are compiling & running using "+RTS -s"? 
08:14:48 <c_wraith> tsmish: does that report max resident, or only max allocatd?
08:15:33 <c_wraith> tsmish: because allocated vs resident is a very important difference.
08:15:58 <tsmish> cocreature: http://lpaste.net/351541
08:16:19 <c_wraith> tsmish: can you also paste how you're running it and the full output?
08:17:07 <tsmish> c_wraith: ./t +RTS -s
08:17:17 <c_wraith> tsmish: what compiler options?
08:17:38 <tsmish> c_wraith: ghc t.hs -O
08:17:55 <c_wraith> can you put something on lpaste with the full output?
08:20:59 <tsmish> c_wraith: http://lpaste.net/351541
08:21:45 <c_wraith> tsmish: that looks to me like you're reading the allocation number, instead of the max resident number
08:22:33 <c_wraith> tsmish: with Int, the strictness analyzer can determine the value is always used strictly, unpack it, and compile it down to a value stored in a register
08:23:11 <c_wraith> tsmish: Integer isn't like Int, though.  It can't be unpacked because it has multiple constructors (and isn't fixed-size anyway)
08:23:20 <c_wraith> tsmish: so it can't optimize the allocation out
08:24:08 <c_wraith> tsmish: But that doesn't mean that tons of memory is used.  basically every GC run should be in the nursery generation only.
08:24:23 <c_wraith> tsmish: almost nothing should get promoted to the next generation.
08:25:21 <c_wraith> tsmish: the important numbers in this case are productivity and max resident
08:25:33 <c_wraith> tsmish: and both of those numbers are fine.
08:26:33 <c_wraith> tsmish: as you can see, the nursery generation was collected 6000 times, but the next generation was only collected twice
08:27:15 <c_wraith> tsmish: if you think about the program behavior, that makes approximate sense.  Whenever a collection runs, exactly 1 Integer is still in memory
08:27:27 <c_wraith> tsmish: so only one value is copied out of the nursery
08:30:32 <erisco> anyone got a favourite sat solver?
08:30:49 <mniip> the list monad?
08:31:13 <c_wraith> that's a very slow sat solver
08:31:19 <tsmish> c_wraith: thanks for anwser 
08:32:55 <vapid> String = [Char] was a mistake
08:33:02 <erisco> my problem can be expanded into a sat problem but maybe it becomes too large, not sure
08:33:10 <erisco> hundreds of variables might be a problem
08:36:28 <erisco> but only one way to discover that
08:36:58 <erisco> seems like a few here but I don't really want to sift through each one http://hackage.haskell.org/packages/search?terms=sat
08:38:36 <sm> c_wraith: because.. it just blindly evaluates all possibilities, where a real sat solver prunes them cleverly.. ?
08:43:58 <erisco> um, wow, 100 seconds for 250 variables https://github.com/shnarazk/mios
08:44:08 <erisco> well I won't bother with that approach then
08:45:25 <erisco> alternatively I write a sat solver optimised for my type of problem
08:46:31 <erisco> one day we can lub all the solvers together and have something generally decent
08:48:12 <erisco> many of my variables are mutually exclusive
08:48:54 <erisco> basically if you want to encode a choice from n things then you can write that with n variables
08:49:09 <yhhko> erisco: isn't it reasonable to interface with something like minisat?
08:49:31 <erisco> in sop as a¬¨b¬¨c ‚à® ¬¨ab¬¨c ‚à® ¬¨a¬¨bc  for example
08:49:44 <erisco> partly why the number of variables is so high
08:50:33 <erisco> well if it isn't too much work I can try using the solver anyways, but it has to pick up on these exclusions
08:50:35 <eschnett> :t :+
08:50:37 <lambdabot> error: parse error on input ‚Äò:+‚Äô
08:50:53 <erisco> :k (:+)
08:50:55 <lambdabot> a -> a -> Complex a
08:51:25 <cocreature> erisco: it‚Äôs definitely worth a try. 
08:53:52 <yhhko> erisco: professional sat solvers do all kinds of neat tricks
08:53:56 <erisco> oh gross, it is done in IO
08:53:59 <yhhko> if you need efficiency, don't reinvent the sat solver
08:54:36 <erisco> that's what you get for interfacing with C
09:00:15 <c_wraith> sm: yep.
09:02:41 <erisco> nah I'll need something else
09:03:15 <cocreature> good luck writing your own sat solver :)
09:03:42 <erisco> well if you have any problem that can be expressed as a sat problem then you're writing a sat solver
09:03:46 <erisco> so that isn't saying much
09:03:55 <cocreature> sure
09:04:22 <erisco> the expression size grows much quicker than I first thought
09:04:37 <erisco> I was thinking hundreds of variables but it is more like millions to billions
09:04:49 <cocreature> SAT solvers are basically a really clever form of brute force search. if you can get away without doing a brute force search that‚Äôs better in almost all cases
09:05:16 <erisco> or not that many variables, but that high in number of occurrences
09:06:32 <erisco> can't really avoid the brute force but I can choose a more succinct representation
09:21:57 <erisco> I can shorten it up substantially with some predicates
09:22:57 <erisco> I know some SAT solvers are augmented with some
09:24:14 <erisco> equality and set membership would go a long way
09:24:45 <erisco> smt solvers iirc
09:41:57 <haasn> Is there an Alternative/MonadPlus without identity?
09:42:02 <haasn> I need one that works for any Either
09:43:27 <erisco> what are the laws, out of curiosity?
09:45:19 <haasn> ah, that's just plain old Semigroup
09:46:12 <erisco> or a magma for less
09:57:27 <Phillemann> I'd like to create thumbnails of jpg (or png) files in Haskell. Juicypixels seems to be fine to read and write images, but how do I transform them?
09:58:17 <c_wraith> what sort of transformations do you want to do?
09:58:24 <c_wraith> Just scaling?
09:58:33 <Phillemann> Just scaling, yes.
09:58:48 <Phillemann> There seems to be friday-devil.
09:59:08 <c_wraith> Hmm.  I don't know offhand.  What I do know about scaling is that it's actually sneakily hard to get right.
09:59:33 <systemfault> There's no imagemagick bindings for haskell? (It's the commonly used lib for that kind of stuff)
09:59:58 <c_wraith> In all honesty, I wouldn't miss them.  ImageMagick is surprisingly frequently exploited
10:00:42 <Phillemann> I could be more strict and just require jpg downscaling.
10:01:10 <c_wraith> http://entropymine.com/imageworsener/gamma/ is why I say image scaling is surprisingly complicated
10:01:25 <Phillemann> Ok, and it doesn't have to be perfect. ;)
10:01:39 <Phillemann> Maybe I can even write it myself, but...I really don't want to.
10:12:50 <ertes> Phillemann: i'm not aware of a library that does everything for you, but it's actually surprisingly easy to reinvent, if you represent pictures as functions of position
10:14:08 <ertes> Phillemann: start with, say, (V2 Int -> Colour) with a suitable Colour type (if you want to get colour spaces right, there is the 'colour' package)
10:14:21 <ertes> (V2 is from the 'linear' library)
10:14:38 <ertes> first step: interpolate:  (V2 Int -> Colour) -> V2 Double -> Colour
10:15:16 <Akii> might as well directly ask here; is there a mathematical term for this? http://lpaste.net/351544
10:15:20 <ertes> second step: express your transform as a matrix, invert it, then apply the inverse transform to map points in the transformed image to points in the interpolated image
10:15:49 <ertes> last step: rasterise:  (V2 Double -> a) -> V2 Int -> a
10:16:52 <lyxia> Akii: is x really meant to be infinite there
10:16:58 <Akii> lyxia: no
10:17:04 <Akii> otherwise reverse wouldn't really work
10:17:12 <ertes> Phillemann: (the 'linear' package inverts matrices for you, see in this particular case inv22 or inv33)
10:17:16 <Akii> (just wanted to come up with some sort of list)
10:17:31 <Akii> (let me quickly make that finite)
10:17:52 <lyxia> Akii: did you mean, "for all x, that equality holds"?
10:18:05 <Akii> lyxia: both folds have the same end result
10:18:08 <Akii> or should have
10:18:52 <lyxia> I don't think it has a name
10:19:09 <lyxia> but it should restrict f and f' by quite a bit if you look at lists of length 1.
10:19:15 <lyxia> or 2
10:19:55 <monochrom> associative and commutative
10:20:15 <Akii> monochrom: right
10:20:41 <Akii> like I'm doing event sourcing
10:20:54 <erisco> what if I have a ‚â† b ‚àß b ‚â† c ‚áí a ‚â† c ? does this have a name?
10:21:19 <Akii> where you have a series of events (data) and you basically fold left over it to derive state
10:21:45 <Akii> and in my case at least I'm able to actually reverse the stream of events
10:21:48 <Akii> and build up as I go
10:22:08 <Akii> that must have a name
10:22:24 <Akii> note that it would not work if I just make this a monoid
10:22:31 <monochrom> erisco: I don't think there is a name. It's pretty uncommon.
10:22:56 <monochrom> Oh! Akii, maybe time-symmetry
10:22:57 <mniip> erisco, transitivity of inequality?
10:23:12 <erisco> yes, that is the property, but then what kind of relation is it
10:23:43 <monochrom> Yes, what kind of relation is it? Do you even have an example?
10:24:10 <erisco> say you have a set of variables and each is distinct
10:24:11 <monochrom> I need to tell you a joke.
10:24:21 <Akii> monochrom: this? https://en.wikipedia.org/wiki/T-symmetry
10:24:40 <monochrom> I think yes Akii
10:24:42 <mniip> erisco, it is a subset of an equiv relation
10:24:48 <Akii> monochrom: will look into it, thanks!
10:24:51 <erisco> if we say this with equality then we say  ¬¨(a = b) ‚àß ¬¨(a = c) ‚àß ¬¨(b = c)  for a b c
10:25:29 <erisco> we need n(n+1)/2 clauses for n variables
10:25:33 <mniip> erisco, actually
10:25:37 <monochrom> Stop.
10:25:44 <mniip> that relation doesn't hold for anything above 1 element
10:25:44 <erisco> halted
10:25:49 <mniip> assume a ~ c
10:26:20 <monochrom> When you say "a ‚â† b ‚àß b ‚â† c ‚áí a ‚â† c", do you mean this is a property of ‚â†? Do you mean this is a property of (a,b,c)?
10:26:48 <erisco> monochrom, a property of ‚â†
10:27:00 <monochrom> So you have "forall a,b,c" in mind?
10:27:23 <erisco> yes
10:27:36 <monochrom> Then it's transitivity.
10:27:56 <erisco> yes I know, but I am wondering if this relation has a name
10:28:30 <erisco> the point is that we can say the variables are distinct with n-1 clauses rather than n(n+1)/2
10:29:26 <erisco> or I guess "clause" isn't the right word
10:29:35 <erisco> subexpressions
10:29:40 <monochrom> There are millions of relations with this property.
10:30:27 <monochrom> These relations have a name: transitive relation. There is no "this".
10:31:08 <erisco> you put reflexivity, symmetry, and transitivity together and you get an equivalence relation
10:32:01 <erisco> then I can look up "equivalence relation" and learn more about it
10:32:06 <monochrom> Sure. There are still hundreds of thousands of equivalence relations.
10:33:05 <monochrom> Tell me more about your variables.
10:33:38 <erisco> they have a finite domain
10:33:43 <monochrom> What is a "clause"? Why are there n-1 clauses sometimes, but n(n+1)/2 clauses some other time?
10:34:04 <erisco> I mean expression/subexpression not clause
10:34:17 <erisco> okay I will start again
10:34:33 <erisco> you have a set of variables. lets say for example this is {x, y, z}
10:35:10 <erisco> we want to write the expression that says "all variables are distinct"
10:36:12 <erisco> say we have an equivalence relation on the domain of these variables, D
10:36:35 <erisco> then we can say ¬¨(x = y) ‚àß ¬¨(x = z) ‚àß ¬¨(y = z)
10:36:53 <erisco> you can see from this that as we add more variables that the size of the expression grows quadratically
10:37:10 <erisco> there will be n(n+1)/2 subexpressions of the form ¬¨(m = n)
10:37:43 <erisco> so lets say instead we have a relation ‚â† which is the usual "not equal to" but also transitive
10:38:01 <erisco> then we can reduce this expression to just n-1 subexpressions
10:38:38 <erisco> in the example, ¬¨(x = z) can be derived from ¬¨(x = y) ‚àß ¬¨(y = z)
10:39:05 <monochrom> Let D = {0, 1}. Write down what your ‚â† looks like for this D.
10:39:52 <erisco> the symmetry foils me
10:40:08 <monochrom> Yes. There is no such ‚â†
10:40:19 <monochrom> The name is "does not exist".
10:40:47 <monochrom> I do think you are stuck with n(n+1)/2 clauses.
10:42:36 <monochrom> If your formal language is rich enough, do not use n variables. Use 1 variable, of array[n] type. Then the sentence has O(1) length: forall i,j. i/=j implies v[i] /= v[j]
10:43:01 <monochrom> hey that's injectivity!
10:44:09 <erisco> how is this injectivity?
10:44:21 <monochrom> v[i]=v[j] implies i=j
10:45:33 <erisco> right, okay, I wasn't thinking of the formalisation of injectivity correctly
10:47:00 <monochrom> I promised you a joke. Here it goes. A math grad student has thought up a fantastic kind of monoids, i.e., adding some fantastic axioms of his invention to the monoid axioms. It is fantastic because with these extra axioms we can prove very nice theorems.
10:47:17 <monochrom> So he made it his PhD thesis.
10:47:32 <jajajaja> hi all, how would I write `mfix (\xs -> return (1:xs))` with mdo notation? `mdo { xs <- return (1:xs) }` or `mdo { xs <- return (1:xs) ; return xs }`?
10:48:26 <monochrom> At the PhD oral exam, he showed all this and all the nice theorems and proofs. When he finished, someone in the committee asked, "do you have an example monoid that satisfies your extra axioms?"
10:48:41 <monochrom> He said no, he hadn't spent time on that.
10:49:00 <Akii> monochrom: this is basically the essence of what I was talking about http://lpaste.net/351547
10:49:13 <monochrom> Then the someone went up to the board and proved that the only monoid satisfying the extra axioms is { [] }.
10:49:40 <erisco> well I didn't commit the idea that hard :P
10:50:09 <erisco> first we assume true is false and then look at what we can prove
10:50:47 <ongy> > let 0 = 1 in 0 == 1
10:50:51 <lambdabot>  False
10:51:26 <pikajude> > let x@0 = 1 in x
10:51:29 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@0
10:51:34 <pikajude> oh, that's how that works
10:51:49 <monochrom> yes
10:51:52 <erisco> I am not so fond of indexes‚Ä¶ not sure how to work with them well
10:52:04 <monochrom> it becomes: case 1 of ~0 -> 0==1
10:52:07 <erisco> it gets ugly when you have bounds and if you start doing arithmetic with them
10:52:50 <monochrom> indexing = function application
10:53:27 <monochrom> You don't have to do arithmetic to indexes.
10:53:55 <erisco> yes, you don't, and maybe here I can just treat the indexes as a finite domain of somethings
10:54:01 <monochrom> Mathematicians use arbitrary sets for indexes all the time. Have you ever seen them adding two sets?
10:54:03 <erisco> rather than integers
10:54:30 <erisco> adding sets? no
10:55:40 <erisco> only need an equivalence relation on the indexes which is no big deal‚Ä¶ okay I will think about it
11:03:50 <ertes> monochrom: that sounds more like a sad short story than a joke
11:04:19 <ertes> but i guess comedy and tragedy are two sides of the same coin =)
11:04:52 <pikajude> for sale: two sets, never added
11:05:04 <monochrom> a true story of that kind would be a tragedy. a manufactured story of that kind is a comedy.
11:05:27 <monochrom> I doubt it's a true story because thesis supervisors exist.
11:07:33 <erisco> I haven't given up on it yet
11:16:46 <erisco> I'm just not thinking about it correctly, is all, and am trying to untangle it
11:18:14 <erisco> it is that if I write a ‚â† b ‚àß b ‚â† c that a ‚â† c is inferred, but I am wrong to think that this needs to be a property of ‚â†
11:19:21 <mniip> erisco, assume your is antireflexive?
11:19:28 <mniip> forall a !(a ‚â† a)
11:19:33 <erisco> it is antireflexive, yes
11:19:52 <mniip> then the universe containing a,b,c can at most contain one element
11:20:02 <erisco> 0 ‚â† 1 is true, and 1 ‚â† 0 is true, this is fine‚Ä¶ it isn't addressing what I am really trying to imply about variable assignment
11:20:18 <mniip> suppose there are two elements, let a=c=A, b=B
11:20:22 <erisco> yes yes I know
11:20:46 <mniip> A ‚â† B ‚àß B ‚â† A => A ‚â† A, but !(A ‚â† A)
11:21:00 <mniip> so where are you going with this
11:21:14 <monochrom> Two hours from now, Cale will give a 3rd lecture to you on this. :)
11:21:22 <erisco> I can't wait
11:21:40 <mniip> has ski done that yet
11:21:48 <monochrom> No.
11:22:21 <erisco> I think what I want to do is treat the variables opaquely here
11:22:22 <monochrom> But I'm sure ski will do it from a fresh angle involving combinatory logic and category theory.
11:24:12 <monochrom> mniip, the question is: I have 10 names and I want to say that they refer to pairwise-different values. Is there a way to formalize that, shorter than 10*11/2 inequalities?
11:26:36 <mniip> "= is a diagonal matrix"
11:26:48 <yhhko> monochrom: in what language?
11:27:04 <mniip> or rather, "= is a unit matrix"
11:27:24 <monochrom> preferrably in a language that only has: the names, = or /=, and-or-not
11:30:44 <yhhko> suppose there were such a sentence phi, pick an assignment of 10 values, change into an assigment of 9 values (so two the same, namely the one whose inequality is missing), induction on the structure of the sentence, yadda yadda, contradiction
11:31:09 <monochrom> Yeah.
11:31:18 <yhhko> TODO fill in the details
11:31:45 <mniip> indeed
11:32:06 <monochrom> But maybe you can make a modest, benign extension to the language and get something nicer.
11:32:38 <phadej> if you want to say "these n values are distinct", way or another you have to do that n(n-1)/2 comparisons
11:33:09 <monochrom> For example erisco had already tried "add ‚àÄ, so I can state a general axiom". It didn't work out though.
11:34:05 <mniip> there is not a way to state that without writing out the n(n-1)/2 inequalities
11:34:07 <yhhko> phadej: that sounds reasonable. this probably relates to some binary tree of comparisons which necessarily has n(n-1)/2 levels
11:34:10 <mniip> in full or compressed form
11:35:30 <monochrom> I added an array type and ‚àÄ, so that I have only one name (of array[10] type) and state injectivity.
11:36:03 <monochrom> mniip added a matrix type, which is like my array idea but on even more steroid
11:37:06 <monochrom> Combinatoric is too hard. Let's go shopping.
11:37:26 <mniip> I'm afraid if you do formalize my matrix idea you're going to run into circular reasoning
11:37:34 <mniip> because ultimately the definition of delta
11:39:50 <ertes> monochrom: couldn't you express that simply as injectivity?
11:40:03 <monochrom> Yes, I just did.
11:40:28 <ertes> monochrom: ah, i didn't read that far‚Ä¶  although i would have used a function
11:40:29 <monochrom> <monochrom> If your formal language is rich enough, do not use n variables. Use 1 variable, of array[n] type. Then the sentence has O(1) length: forall i,j. i/=j implies v[i] /= v[j]
11:40:34 <monochrom> <monochrom> hey that's injectivity!
11:41:01 <ertes> monochrom: yeah, same thought
11:54:13 <paolino> hi, is UndecidableInstances something dangerous ?
11:54:48 <ertes> paolino: only in the sense that it could make instance resolution loop
11:54:56 <Tuplanolla> Only if you find the compiler hanging indefinitely dangerous, paolino.
11:55:38 <paolino> is there a standard technique to eliminate it ?
11:56:08 <Tuplanolla> You mean like `NoUndecidableInstances`, paolino?
11:56:23 <paolino> no to eliminate the need 
11:57:43 <monochrom> dependent types :)
11:58:17 <ertes> paolino: if the compiler asks for it, you probably need it
11:58:38 <ertes> paolino: i think you could create newtype wrappers, but that's an ugly solution
11:59:34 <_d0t> hai. Is it possible to make shared libraries in haskell that are linked only to system libraries?
11:59:47 <_d0t> e.g. no libHsBase-blahblah.so dependencies
11:59:49 <ertes> paolino: instance (C a) => C (Id a)
12:00:08 <yhhko> _d0t: theoretically, yes. but the build system is still somewhat in development.
12:00:30 <yhhko> or i guess i should say "very much"
12:00:38 <_d0t> yhhko: any relevant links?
12:01:23 <yhhko> _d0t: cabal recently got support for building "foreign libraries", so that's .so files on linux, .dylib on mac, and (static) .lib on windows
12:01:43 <_d0t> yhhko: what about calling ghc directly?
12:02:00 <paolino> ertes,  https://gist.github.com/paolino/d79754d217e2dee02ea0a6e618438db2
12:02:17 <yhhko> _d0t: if you know how to call ghc directly to build what you want, you wouldn't need to ask if it's possible
12:02:28 <yhhko> _d0t: ask the cabal or ghc devs how to do it
12:02:31 <_d0t> good point
12:02:52 <yhhko> it's probably possible, but it's probably somewhat tricky
12:02:55 <paolino> ertes, they are needed in the Peek F a b instance
12:08:15 <ph88> good evening all :)
12:08:55 <d_tox> Suppose I define a funciton with guards that look something like this foo | auxPred == True = True | auxPred == False = False where auxPred = ...
12:09:27 <d_tox> Is there a better way of rewriting the repetition of the branches and the bools
12:09:29 <yhhko> d_tox: you mean foo = auxPred?
12:09:32 <ph88> seems that if else is a better match here
12:10:19 <phadej> foo | auxPref = ... \n  | otherwise = ... 
12:11:26 <d_tox> yhhko: Yes! I am just dumb ^o^ 
12:11:43 <d_tox> phadej: Mhm, I have third gurad so otherwise is what I am using ^^ 
12:12:25 <d_tox> phadej: I am trying to escape the nesting and branching etc
12:13:00 <phadej> d_tox: how there can be third case
12:13:16 <phadej> p :: Bool, it's only p == True or p == False
12:13:29 <phadej> (well, p == undefined but you cannot test that)
12:13:45 <d_tox> phadej: I am checking the input before doing any calculations
12:16:08 <yhhko> d_tox: you mean user input? hint: put that in a separate function
12:16:35 <d_tox> yhhko: Yup! Thanks for the tip!
12:21:13 <erisco> d_tox, that is an impressive anti-pattern you've got there
12:22:08 <d_tox> erisco: That's why I asked ^o^ 
12:23:45 <erisco> phadej, sure you can, it is just also undefined ^.^
12:24:25 <ertes> paolino: well, UndecidableInstances is not *unsafe*‚Ä¶  it just makes instance resolution undecidable in general, so you're probably fine
12:24:47 <erisco> it is as safe as an infinite loop
12:24:54 <haasn> UndecidableInstances is harmless as long as you don't care about your compiler entering an infinite loop
12:25:51 <ertes> paolino: if you interpret type classes as a logic language (like curry/mercury/prolog), then making sure that instance resolution is decidable amounts to avoiding things like tautologies
12:26:06 <ertes> instance (C a) => C a  -- obvious tautology
12:26:36 <ertes> paolino: BTW, GHC will not even loop‚Ä¶  it will just tell you that it has reached its maximum recursion depth
12:27:09 <phadej> well, you can lift that restriction as well
12:27:36 <hpc> UndecidableInstances can create effectful imports
12:27:46 <hpc> er no, that's OverlappingInstances
12:28:03 <erisco> C++-style?
12:28:40 <hpc> basically you would write in some module a specific instance that overlaps with a general one
12:28:55 <hpc> then write code in another module that uses the generic instance in that specific way
12:29:13 <hpc> when you import the module with the specific instance, it replaces the general one
12:29:43 <hpc> the extension has its behavior restricted to prevent this if you turn on {-# LANGUAGE Safe #-}
12:30:38 <ongy> how is it restricted?
12:31:08 <hpc> don't remember, it was weird and more specific than i cared about
12:31:18 <hpc> my brain compressed it down to "don't use overlapping instances" ;)
12:38:47 <ph88> does anyone know a trick so that ghci scrolls up to show the first error ?
12:39:00 <sm> use ghcid
12:39:27 <sm> or if you're running ghci in emacs, C-c C-r
12:39:52 <sm> or move point (cursor) up one line immediately after pressing enter
12:41:49 <haasn> is there any trick to get GHC/GHCi to highlight stuff? monochrome text is so difficult for me to parse nowadays that I have trouble even going through the :info output
12:42:02 <haasn> something as simple as coloring in the instance and class names with different colors would make it so much easier
12:42:48 <sm> haasn: you mean, in error messages ?
12:42:58 <sm> it would be nice, indeed
12:43:07 <haasn> every output
12:43:30 <sm> if you're in emacs, again: set up custom highlight regexps
12:43:31 <haasn> my rule of thumb is ‚Äúif it gets printed to stdout, it should be color-coded‚Äù
12:44:04 <sm> that causes trouble when ansi is not supported. I think it's generally possible to autodetect that though
12:44:40 <ongy> there isatty, which detects if stdout is a terminal
12:44:53 <ongy> (or any fd iirc, but useful for stdout here)
12:45:02 <ij> So for each "data Foo = Bar String | Baz Int deriving (Eq)" I must make a isBar and isBaz if I don't know what's inside?
12:46:10 <ongy> or pattern match on the value
12:46:51 <ij> Yeah, I wish there was a way that could be fit within an if.
12:47:21 <erisco> use a guard
12:47:44 <sm> I was playing with some PHP tools yesterday and did notice and enjoy their large red/green status outputs, fancy textured progress bars etc.
12:48:19 <erisco> lipstick for a pig
12:49:08 <sm> actually no, there was a lot to like there
12:50:06 <erisco> ever use node.js? lot of the same style there
12:50:06 <ongy> in php? heretic
12:50:30 <sm> erisco: I'm sure.. I seem to remember it starting especially with ruby
12:53:38 <sm> it happens in mature heavily-used ecosystems. When pretty coloured output becomes common in haskell land, we'll know haskell has arrived :)
12:54:43 <erisco> I don't know. In a perverse way I like the seclusion
12:55:34 <sm> I'd rather be more productive and enjoy my tools more, personally
12:55:35 <erisco> if it happens I hope it comes from programmers working their way here rather than Haskell working its way to more programmers
12:56:00 <sm> nd there's always a quieter language further up
12:56:23 <erisco> something you get in the largest communities is a lot of crap
12:57:21 <sm> but also a lot of good stuff
12:57:25 <koala___> hello, by chance someone could explain me what's wrong? http://pastebin.com/QmF5KRFV
12:57:57 <rgrinberg> parens? (test4 . test5) 5
12:58:07 <sm> and haskell has some strong culture and tooling which I think helps
12:58:23 <koala___> rgrinberg: thanks!
12:59:57 <yhhko> > let test x = x + 1 in test . test $ 1
13:00:00 <lambdabot>  3
13:00:33 <erisco> the only acceptable dollar is ($)
13:01:27 <glguy> > let test x = x + 1 in ($) ($) test . test $ 1 -- erisco, like this?
13:01:29 <lambdabot>  3
13:01:36 <erisco> maybe a section if you're feeling risque
13:02:26 <seequ_> :t ($) ($)
13:02:28 <lambdabot> (a -> b) -> a -> b
13:02:39 <erisco> better known as id
13:11:21 <kuribas> :t ($) ($) ($) ($)
13:11:23 <lambdabot> (a -> b) -> a -> b
13:11:35 <kuribas> :t ($) ($) ($) ($) ($) ($) ($) ($)
13:11:37 <lambdabot> (a -> b) -> a -> b
13:11:48 <yhhko> well that's not very interesting
13:12:19 <fresheyeball> :t show
13:12:21 <lambdabot> Show a => a -> String
13:13:20 <kuribas> :t ($) ($) ($)
13:13:22 <lambdabot> (a -> b) -> a -> b
13:25:43 <erisco> what is it called again‚Ä¶ not higher order syntax tree
13:29:03 <epta> How to convert 'StateT g (Either E) T' to 'ExceptT E (StateT g Identity) T' ? 
13:30:10 <erisco> you know that thing where they treat variables in a funny way
13:30:55 <epta> erisco: four letters?
13:31:01 <Earthlinger> If I want to profile some code, do I really have to download all dependencies' source files and manually recompile with profiling enabled?
13:31:30 <erisco> I don't know
13:31:52 <geekosaur> stack or cabal new-build will do it automatically
13:32:18 <Tuplanolla> Even with old Cabal you can reconfigure it to install profiling libraries, Earthlinger.
13:33:02 <Earthlinger> Oh, thanks Tuplanolla 
13:33:05 <erisco> it looks like it might be called "higher order syntax" but it doesn't seem quite right
13:33:15 <erisco> it isn't digging up the stuff I remember reading not a year ago
13:33:30 <Tuplanolla> I have instructions for that here, Earthlinger: http://users.jyu.fi/~sapekiis/install-ghc/
13:33:40 <Tuplanolla> These days Stack's a better option though.
13:34:18 <Earthlinger> Hmm, I guess the Haskell wiki page on profiling is very outdated then
13:34:27 <erisco> I mean "higher order abstract syntax"
13:34:44 <erisco> it is the right idea though
14:07:36 <lumo_e> anybody knows what "Invalid package ID" message means on stack? when doing stack build
14:08:00 <lumo_e> uhm maybe it's stack
14:08:47 <Ashton> I'm having a little issue with ghc-mod. Anyone seen this one?
14:08:50 <Ashton> https://github.com/DanielG/ghc-mod/issues/867
14:11:53 <mitchty> out of curiosity, is anyone using http/2 in warp yet
14:13:44 <stew> what is the rigth way to report a bug in a haskell package?
14:13:55 <stew> or propose a bugfix?
14:14:07 <Clint> depends on the package
14:14:14 <stew> Data.Dates
14:14:28 <hpc> stew: usually the package links to a github repo
14:14:40 <stew> this one lists a repo that doesn't exist
14:14:49 <stew> and a homepage which doen't exist
14:14:55 <Clint> does the email bounce?
14:14:57 <stew> yes
14:15:21 <hpc> have you tried turning it off and on again?
14:15:27 <Clint> whine at the hackage trustees
14:16:03 <stew> who is that?
14:16:06 <Clint> https://github.com/haskell-infra/hackage-trustees/issues
14:16:38 <Ashton> Well, that's a nice resource to have.
14:17:04 <stew> I suppose I'll write my own date parser?
14:18:27 <Clint> stew: is the one in Data.Time.Format too rigid?
14:19:11 <stew> oh, no, I can make that work
14:20:33 <stew> thanks Clint 
14:20:41 * Clint nods.
14:47:52 <ij> Does this code have any effect? http://vpaste.net/4VI6Q
14:48:10 <ij> Umm, it's so short I can tell you: data Foo = X | Y; makeLenses ''Foo
14:49:14 <monochrom> You will need to import the required lens modules and turn on Template Haskell.
14:50:56 <ij> I know about lens in general. So sorry, the important part was having a Something in Y ‚Äî and getting a y that I could export it with, so I can avoid making y (Y x) = x.
14:53:34 <marfoldi> Hi haskellerz!
14:56:07 <Rembane> Good morning marfoldi !
14:59:38 <stobix> Why would I ever want to use a profunctor? Is it useful at all?
15:01:22 <hpc> when amateur functors just won't do
15:02:13 <stobix> Well, yeah, I guess.
15:02:39 <monochrom> Have you needed to use a profunctor? If not, why worry about it? Out of sight, out of mind.
15:02:46 <monochrom> I certainly haven't needed it.
15:02:54 <hpc> but if you need it, it's there
15:03:13 <monochrom> I have only barely needed lens, but it's beautiful when I need it.
15:03:14 <hpc> also as a mathematical concept, you have it for anything more useful that builds on it
15:03:27 <lame_duck> Can someone help me?
15:03:41 <hpc> http://conal.net/blog/posts/semantic-editor-combinators -- dimap covers a few of the things in this post
15:03:53 <stobix> Well, I like learning what tools I have and how to use them. How would I know if I ever needed a profunctor if I didn't know how it worked?
15:04:30 <stobix> Just like I  never need to use anything else than bare recursion, I don't need profunctors. ;)
15:04:32 <lame_duck> I need help understanding an assignment given.  My professor would like us to to take two inputs of type integer, compare them, and count down from the larger argument to the lesser one
15:04:56 <hpc> stobix: if you find something that looks like it, try it out and see if it fits
15:05:05 <lame_duck> The code that I have so far is downList x y = reverse{x..y] 
15:05:14 <lame_duck> However, I don't know how to check if y > x 
15:05:22 <monochrom> Recall balanced binary search trees (e.g., AVL trees) needing a left-rotation and a right-rotation. Their code are exact mirror images of each other. How to parameterize and write just one master copy? Answer: You are parameterizing first-class references, i.e., lenses.
15:05:55 <stobix> hpc: well, I guess. I think my problem is that I don't intuitively feel how the different "directions" in the profunctor interact, so I don't really understand how it is even a thing, not just a functor tuple.
15:06:20 <kuribas> stobix: just code the way you are used to, and if you see a recurring pattern, try to find out what it is.
15:06:28 <stobix> lame_duck: you have an if x>y then ... else ...
15:06:33 <hpc> stobix: you should learn up on covariance and contravariance
15:06:47 <monochrom> lame_duck: Can you write an if-then-else?
15:06:51 <hpc> stobix: if you're comfortable with Functor, this might succinctly explain it for you: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Contravariant
15:06:56 <lame_duck> @stobix: Thanks hopefully it works.  We just started Haskell
15:06:56 <lambdabot> Unknown command, try @list
15:07:01 <hpc> stobix: it's the same as Functor, but just a smidge backwards
15:07:55 <lame_duck> Is Haskell picky about spacing?
15:07:59 <stobix> hpc: yeah, it kinda looks like the reverse state monad in a way.
15:08:00 <nshepperd> a profunctor 'p a b' sucks in an 'a' and vomits out a 'b'. in some sense. so that you can apply a function at either end
15:08:03 <monochrom> Sometimes.
15:08:17 <koala_man> I have this program to write "hi" with slanted quotes: main = putStrLn $ map chr [8220,104,105,8221] . It works, but it produces a second line of unicode garbage on Windows: https://gist.github.com/koalaman/f11433526a9687e15f5dd2dc8973ed77
15:08:31 <hpc> lame_duck: it's layout-based
15:08:33 <koala_man> Why am I getting two extra missing glyph thingies?
15:08:50 <lame_duck> Ok, so my function declaration is downList x y
15:08:53 <hpc> lame_duck: a very rough description of it is things need to be in the same column, wherever that is
15:08:58 <stobix> hpc: And I guess one of the "directions" of the profunctor does the same - but I don't understand how/why the directions interact. Is there ever a point to not just having a Functor and a Covariant?
15:09:05 <hpc> a less rough description is indent your code right and it generally works out
15:10:10 <monochrom> koala_man: That's strange. I think you've already done "chcp 65501", no? Because if you have, then I don't know how to explain it.
15:10:13 <stobix> nshepperd: ah, so whereas a functor only can "build up" from one end, the profunctor can build up from both?
15:10:35 <Fylwind> Is there a name for this Applicative? data P e f a = P e (f a) with Monoid e, Applicative f
15:10:47 <monochrom> You know what, if you haven't, I still don't know how to explain it :)
15:10:51 <lame_duck> downList x y if x>y then reverse[y..x] else reverse[x..y]
15:10:53 <nshepperd> stobix: the directions don't really interact "as such"
15:10:57 <lame_duck> This is the code I have written
15:11:10 <monochrom> Oh I know! Redirect to a file. Then use a hex editor.
15:11:29 <stobix> lame_duck: ah, nice. Have fun learning haskell! Also, notice that the if clause returns a value, so the value of "if True then 3 else 4" is 3.
15:12:20 <koala_man> monochrom: yes, I have. by default, I just get an awful error
15:12:41 <nshepperd> stobix: Profunctor p is really the same as saying that 'p a b' is contravariant functor in 'a' and covariant functor in 'b'
15:12:51 <koala_man> monochrom: if I redirect to file and cat the file, it's fine
15:13:12 <stobix> nshepperd: I think that's what have me confused. Kinda like I have two things, and they only interact implicitly by some strange rule, and then I call the two things one thing.
15:13:29 <nshepperd> stobix: but, for instance, simply 'Functor (p a)' doesn't work to express the second half there, because you really want 'forall a. Functor (p a)'
15:13:59 <nshepperd> stobix: ie. Profunctor p says that 'p a' is a functor *forall a*
15:14:27 <monochrom> Yikes.
15:14:28 <nshepperd> that you can map over the second argument no matter how you map over the first argument
15:14:49 <nshepperd> and vice versa
15:14:50 <monochrom> I wonder if one of them is ctrl-z
15:14:58 <koala_man> if I chcp 437 and try to write unicode, I get an IOException "<stdout>: commitBuffer: invalid argument (invalid character)". how can I robustly recognize this exceptions (regardless of user's language) so I can tell them to chcp 65001?
15:15:27 <stobix> nshepperd: Ah, yeah, that's a difference. I guess. Maybe. How is it different from having two separate functors in e.g. a tuple, mapping over each separately?
15:16:11 <nshepperd> stobix: well, the canonical example of a profunctor is a function
15:17:11 <nshepperd> stobix: 'a -> b' eats an a and produces a b, so you can map over the input or the output
15:17:12 <fresheyeball> hey, is there a package for verifying typeclass laws with quickcheck?
15:17:32 <nshepperd> eg. you can apply dimap to (+1) :: Int -> Int
15:17:40 <athan> fresheyeball: o/
15:17:50 <athan> I think there is actually
15:17:54 <fresheyeball> athan: erp?
15:18:01 <nshepperd> stobix: you can't implement (+1) using a pair of two different functors in a tuple together
15:18:15 <fresheyeball> I expect there to be such a thing
15:18:23 <athan> there should be :x
15:18:24 <fresheyeball> we have the `laws` package in purescript
15:18:48 <athan> @hackage ClassLaws --?
15:18:48 <lambdabot> http://hackage.haskell.org/package/ClassLaws --?
15:19:11 <Fylwind> koala_man: Control.Exception.catch ?
15:19:47 <nshepperd> stobix: the analogy I think of is that a Profunctor is a machine that accepts some input and produces some output. it may have some insides that connect the input to the output, but profunctor does not expose the insides. it just lets you map the input/outputs
15:19:51 <stobix> nshepperd: Ah, yes, true. But in this example you clearly have a case where the two "directions" interact in a way, building up around a common core.
15:20:03 <fresheyeball> athan: looks like that thing hasn't been touched since 2012
15:20:22 <athan> :x
15:20:28 <athan> laws are eternal! :v
15:20:42 <athan> well, it shouldn't be too difficult to flesh them out at least
15:20:49 <stobix> nshepperd: ah. Yeah, so the mapping is the important part, and the rest is up to implementation.
15:20:50 <MarcelineVQ> fresheyeball: http://hackage.haskell.org/package/checkers
15:20:56 <athan> there's just a number of them (in applicative, for instance) that aren't obvious
15:21:06 <athan> MarcelineVQ in with the 3 pointer
15:21:26 <fresheyeball> not cool
15:21:29 <nshepperd> stobix: right, Profunctor is for the case where you only care about mapping on the input/output and don't care what the 'core' is
15:21:37 <koala_man> Fylwind: that lets me catch IOException, but how do I know that it's this issue and not a full disk or something?
15:21:37 <fresheyeball> well this is unexpected and super disappointing
15:21:44 <athan> fresheyeball: The one MarcelineVQ linked looks legitimate - it's by Conal
15:21:52 <fresheyeball> I half expected a Kemett maintained package
15:22:19 <lame_duck> Got it thanks everyone!
15:22:55 <Rotaerk> kemett?
15:23:32 <Rotaerk> you mean ekmett?
15:23:32 <Fylwind> koala_man: you have to inspect the type of the exception using the functions in System.IO.Error; I'm not sure what kind of exception your particular situation causes, but if you're unlucky you might have to dig into (the source code of) GHC.Exceptions, which contains a more *complete* listing of all exceptions, including internal ones that aren't exposed in System.IO.Error
15:23:35 <stobix> nshepperd: ah, nice! I think I actually get it now. 
15:24:55 <Earthlinger> Should it take more than an hour to compile the matrix cabal package in with profiling enabled in stack?
15:25:32 <Fylwind> to partly answer my own question: it seems (Monoid e, Applicative f) => (e, f a) ‚âÉ Compose (Writer e) f a, so it's sort of like a "Writer applicative transformer"
15:28:13 <monochrom> kemett was what ekmett was before he was kissed by a princess :)
15:30:13 <stobix> ...wouldn't that be a coprincess?
15:31:02 <monochrom> No no, I am saying a princess turned kemett into ekmett.
15:31:24 <monochrom> A coprincess would turn ekmett into kemett.
15:31:48 <stobix> ah. My brain thought that the words "what" and "was" needed to be filtered out.
15:31:50 <monochrom> But you have made a great discovery in category theory. A witch is a coprincess.
15:32:33 * stobix 's brain basically did s/what ekmett was/ekmett/ before passing the information on to the more cognitive parts.
15:32:38 <monochrom> And this completely explains why witches always seem to have quarrels with princesses.
15:32:56 <stobix> haha, nice
15:36:27 <stobix> Often, it seems like either the princess or the witch has some kind of identity problem, which explains why they don't want to coexist. 
15:37:05 <stobix> (Often, one of them end up "coexisting" in the end anyways.)
15:38:40 * stobix is done now. You can all come back.
15:45:03 <fresheyeball> athan: you have any idea why the `functor` function takes `m (a, b, c)`?
15:46:29 <athan> fresheyeball: Can you link me?
15:47:54 <fresheyeball> athan: http://hackage.haskell.org/package/checkers-0.4.6/docs/Test-QuickCheck-Classes.html#v:functor
15:51:08 <Alex__> hello
15:51:24 <Zef> Hey folks; Real quick question; How can I write an instance over [] using a qualified prelude import?
15:51:25 <athan> fresheyeball: Well, it's thrown away with `const`, so I'm guessing it's just to pin-down the actual monomorphic types when the time comes
15:51:30 <athan> like an anti-Proxy
15:51:36 <fresheyeball> athan: oic
15:51:39 <fresheyeball> ok that works
15:51:45 <Zef> I get errors doing things like (instance Mappable (P.[]))
15:51:59 <athan> fresheyeball: Also, lets Arbitrary decide which instance
15:52:09 <Zef> assuming: import qualified Prelude as P
15:52:30 <Alex__> Does someone know about codensity/DList-like datatype that improves asymptotic of both (>>=) and mappend?
15:52:48 <Zef> I think it's just because the list type is written as symbols; is there a type alias I can use or something?
15:59:50 <mannen> so I'm looking at the docs, specifically https://hackage.haskell.org/package/time-1.7.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime . I can see that diffUTCTime returns a NominalDiffTime, but looking at NominalDiffTime, how am I supposed to know that realToFrac works on it?
15:59:58 <mannen> what do the different instances mean?
16:00:41 <geekosaur> :t realToFrac
16:00:43 <lambdabot> (Real a, Fractional b) => a -> b
16:01:04 <mannen> geekosaur: that doesn't really answer my questions
16:01:05 <geekosaur> you do pretty much have to memorize how the Num hierarchy works, sadly
16:01:26 <mannen> how, looking at the docs, can I tell that NominalDiffTime is a real?
16:01:31 <geekosaur> well, a Real instance is listed there
16:01:40 <geekosaur> expand the Instances
16:01:58 <mannen> yes, but so are Enum, Num, Data, Fractional, RealFrac and NFData
16:02:12 <mannen> how am I supposed to know that diffUTCTime gives me a Real NominalDiffTime instance?
16:02:16 <fresheyeball> athan: annnd my Applicative instance was bad
16:02:24 <hpc> it gives you NominalDiffTime
16:02:29 <hpc> which is an instance of all those things
16:02:32 <athan> heh
16:02:33 <geekosaur> mannen, all of those instances are simultaneously present
16:02:36 <mannen> oh
16:02:40 <athan> Applicate all the things!
16:02:45 <hpc> ;)
16:02:46 <geekosaur> it;s not "this one is Eq, that one is Ord, that one is Real"
16:02:53 <athan> Does lambdabot no longer advertise hackage uploads?
16:03:00 <athan> or does it have a cool chatter detector? :D
16:03:01 <geekosaur> no, the bot was discontinued
16:03:03 <mannen> ok that makes sense then, thanks
16:03:06 <hpc> it never did, that was hackagebot
16:03:10 <athan> oh derp
16:03:20 <hpc> aw, i liked that bot
16:03:27 <geekosaur> and yes, hackagebot not lambdabot. there was discussion in -cafe
16:03:42 <hpc> why was it removed?
16:04:00 <hpc> just the line noise?
16:04:38 <mannen> when's the last haskell standard from and when is the next one planned to be released?
16:04:42 <geekosaur> https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125828.html
16:04:56 <geekosaur> start of the discussion by the former hackagebot maintainer
16:05:44 <geekosaur> mannen, last one was Haskell 2010 released in late 2009; the committee disbanded a few years later, but there is a new one. I don't know its current status
16:06:06 <athan> I think it would be cool to see it state batches of uploads when it's quiet
16:06:27 <geekosaur> mm, that's a bad sign, hackage-prime list no posts since november
16:06:40 <geekosaur> wonder if the committee stalled again
16:07:30 <geekosaur> https://mail.haskell.org/pipermail/haskell-prime/2016-October/thread.html has a few relevant things
16:08:03 <hpc> do you know if hackagebot is opensource?
16:08:30 <geekosaur> ...but not much *useful* things (notably, comment about uploading a meeting recording but nothing about it happening)
16:09:21 <hpc> oh, it seems to just be rss2irc with a specific nick
16:10:02 <geekosaur> https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125859.html says Chris Wong volunteered to take over hackagebot. nothing since then though
16:11:27 <Kit_> Hey guys, i'm trying to install inline-r on Windows but I keep getting this error that `C library missing: R`
16:11:44 <Kit_> I can't for the life of me figure out what to do, does anyone have any suggestions
16:11:45 <Kit_> ?
16:11:46 <Kit_> Thanks!
16:12:06 <athan> Kit_: That usually means you need the shared libraries for R installed in your system
16:12:08 <geekosaur> you need to figure out where R's DLLs live and point toe build to that with --extra-lib-dirs
16:12:12 <athan> .dll's I think :s
16:12:24 <geekosaur> *point the build
16:12:49 <geekosaur> it is likely looking for R.DLL specifically
16:12:54 <Kit_> awesome thanks so much I'll try that!
16:16:29 <dfeuer> Is there an example online somewhere of how the bound package might be used to implement a typed language (e.g., System F)? The entirety of Ermine is a bit much.
16:57:28 <lame_duck> This is a function I have written that takes x, y, z as arguments
16:57:42 <lame_duck> I want to check if x < y < z and include it in the function
16:57:52 <lame_duck> isRight x y z =     if x^2 + y^2 == z^2     then putStr "The sides are a right triangle" else putStr "The sides are not of a right triangle"
16:58:06 <lame_duck> The function works so far
16:58:16 <moet> i'm using stack to compile a project, and sometimes it "runs out of space" in its tempdir location (it reaches 100mb) .. i've fixed it until now by re-running with `-j1` so that only one package at a time is being compiled in that tempdir.. is there a way to increase the tempdir size?
16:59:36 <geekosaur> moet, that will be up to the OS. on Linux you can try setting $TMPDIR to somewhere with enough space, on Windows try %TEMP%
17:01:30 <geekosaur> that is, Linux: export TMPDIR=/path/to/large/enough/space                               Windows: SET TEMP=C:\path\to\large\enough\space
17:03:57 <lame_duck> I tried when x < y < z
17:03:57 <moet> geekosaur: as far as i can tell, my /tmp is the same volume as / and has 60gb free..
17:05:56 <geekosaur> moet, check that. /tmp is often a tmpfs, which is using free memory as a swap-backed ramdisk
17:06:00 <geekosaur> df /tmp
17:06:41 <moet> ah, i just realised it's not /tmp.. it's /run/user/1000/, which does appear to be different from / .. i'll check it out..
17:07:19 <geekosaur> oh dear, that sounds like yo're also having a fight with systemd
17:07:31 <geekosaur> anyway $TMPDIR *should* help... hopefully
17:08:55 <monochrom> lame_duck: I don't understand the question. What is the exact code that currently has a problem? Exact code.
17:10:09 <Ashton> Okay, I need some help on this. I'm trying to import a module from my executable target in my test-suite.
17:10:14 <glguy> lame_duck: You can't write: x < y < z. You can write: x < y && y < z
17:10:17 <lame_duck> @monochrom I want to see if x<y<z, then I can call the function 
17:10:18 <lambdabot> Unknown command, try @list
17:10:23 <lame_duck> @monochrom I want to see if x<y<z, then I can call the function 
17:10:23 <lambdabot> Unknown command, try @list
17:10:23 <Ashton> And I keep getting "Failed to load interface for"
17:10:35 <glguy> lame_duck: @ is for bot commands, not addressing people
17:10:38 <lame_duck> #glguy That might be the issue
17:10:54 <lame_duck> glguy: Thanks!
17:14:00 <Ashton> o
17:15:35 <Ashton> I've tried adding the modules to the "other-modules" list and everything.
17:16:07 <geekosaur> Ashton, afaik the test can depend on the library but not the executable
17:16:22 <Ashton> So I have to put all the code in a Lib?
17:17:35 <glguy> Ashton: Yes, the most common pattern is for most of the executable to be a library with a small wrapper in an executable section around the library
17:17:47 <Ashton> Okay, I'll give that a go then.
17:17:52 <Ashton> Thank you
17:20:00 <moet> geekosaur: so, stack will examine $TEMPDIR and use that as my build location?
17:25:58 <monochrom> I think yes. It may have to be spelt $TMPDIR
17:31:57 <pavolzetor> I am trying to migrate my ray tracer to linear package, and I can't decide if to use Point or V3 for positions. Is there specific reason to choose the Point representation? It becomes extremely clunky if I want to do num class operation for the catmull clark rules
17:32:38 <ertes> dfeuer: something based on a typed lambda calculus (e.g. system F or haskell core) works the same way as the untyped case, except that you need to annotate the lambda constructor with the argument type
17:32:52 <pavolzetor> basically I end up doint origin .-^ and lensP
17:33:22 <pavolzetor> for all vertices in the table for a patch (16 + 1-rings)
17:35:31 <ertes> dfeuer: Lam :: Scope () (Exp ta) a -> Type ta -> Exp ta a  -- example for when term variables and type variables live in separate name spaces ('a' and 'ta' resp.)
17:37:45 <moet> monochrom: geekosaur. thanks! stack is building in /tmp, where it should, via `env TMPDIR=/tmp stack build`
17:37:53 <ertes> s/spaces/types/
17:38:27 <monochrom> '
17:39:59 <ertes> dfeuer: interestingly dependently typed languages are easier to represent, because Type and Exp are the same type
17:40:25 <ertes> dfeuer: Lam :: Scope () Exp a -> Exp a -> Exp a
17:41:23 <dfeuer> Hi ertes.
17:41:37 <ertes> helo =)
17:42:15 <dfeuer> ertes: how do you deal with the type lambda (GHC Core's /\)?
17:43:04 <ertes> dfeuer: you need a Pi constructor that has the same shape as Lam, but in Type
17:43:18 <dfeuer> ertes, sorry I was unclear.
17:43:30 <dfeuer> I meant for type lambdas in terms.
17:44:12 <dfeuer>  /\ t . \x . ...
17:44:49 <ertes> dfeuer: if you want to have that explicitly, then this is another extra constructor TLam with the same shape as Lam, but its argument type is of type Kind, not Type
17:45:10 <ertes> dfeuer: in the dependent case it's just Lam itself
17:47:13 <dfeuer> ertes: right, but it has to extend a different environment, and so then I'm unclear on how to make substitutions in it.
17:47:26 <dfeuer> Do I need to look to Bitraversable or something?
17:49:00 <ertes> dfeuer: yeah, perhaps‚Ä¶  i'm not entirely sure how TLam would be useful though, because type variables don't really exist on the term level in non-dependent languages
17:50:00 <dfeuer> ertes: how else do you represent a term of type, say,  forall a . a -> a ?
17:51:18 <dfeuer> What type do you assign the argument?
17:51:32 * dfeuer knows very little baout this stuff.
17:52:10 <ertes> you're right‚Ä¶  i don't really have much experience with the non-dependent case
17:52:42 <ertes> honestly i would just use a dependent core, even if you only use it for a non-dependent language‚Ä¶  it's much simpler
17:53:44 <dfeuer> ertes: so you wouldn't use the type system to ensure that terms don't appear as types and types don't appear as terms?
17:53:54 <dfeuer> Just throw an assertion failure if erasure doesn't work?
17:55:13 <ertes> you can write a type checker that also verifies strict level separation
17:55:44 <dfeuer> No idea how that works yet, but sounds Coq/Agdaish?
17:56:48 <ertes> i think it would suffice to check that Pi expressions never refer to term variables
17:57:34 <dfeuer> ertes: I'll give it a whirl. Thanks.
17:57:39 <dfeuer> Just trying to learn some basic stuff.
17:59:03 <ertes> dfeuer: if you don't mind, i'd like to know how it went when you're done
18:00:05 <dfeuer> ertes: for sure.
18:00:24 <moet> quit
18:01:22 <ertes> dfeuer: also i recommend to give the pi-sigma paper a read‚Ä¶  it has a super-simple encoding for ADTs that requires just enumeration types and a primitive sigma type
18:03:50 <ertes> dfeuer: http://www.cs.nott.ac.uk/~psztxa/publ/pisigma-new.pdf
18:04:32 <ertes> ah, wrong link, i think
18:04:38 <ertes> https://www.andres-loeh.de/PiSigma/PiSigma.pdf
18:06:38 <ertes> if you use this core, you can no longer use a non-dependent subset, because the representation of ADTs is inherently dependent‚Ä¶  in that case you need to make sure that your concrete AST type has proper level separation
18:07:59 <dfeuer_> ertes: my computer went boom. The first thing I saw after was "ah, wrong link".
18:08:18 <dfeuer_> (The first thing after I told you I'd let you know how it went)
18:08:27 <ertes> <ertes> dfeuer: also i recommend to give the pi-sigma paper a read‚Ä¶  it has a super-simple encoding for ADTs that requires just enumeration types and a primitive sigma type
18:09:17 <Gurkenglas> Anyone know what caused this? https://www.reddit.com/r/haskell/comments/5p1y09/code_review_hobby_package_would_like_some_feedback/dcs1lhl/?context=3#dcs10n5
18:09:19 <dfeuer_> OK.
19:04:26 <Vaelatern> Anybody got a favorite guide of a new programmer (never written a line of code) to learn haskell?
19:09:04 <byorgey> Vaelatern: https://github.com/bitemyapp/learnhaskell/blob/master/README.md
19:13:56 <Vaelatern> What about the learn you a haskell guide?
19:17:53 <dramforever> It's not that good
19:18:22 <kadoban> Vaelatern: http://haskellbook.com/ would be my recommendation, especially to a new programmer.
19:18:32 <kadoban> (it's not free though)
19:19:44 <Kristof_HT> well after reading around and comparing resources I just went and ordered Programming in Haskell by Graham Hutton  
19:23:30 <glguy> Vaelatern: How'd you get from never programmed to wanted to learn Haskell?
19:24:22 <glguy> (I can't imagine some scenarios, just wondering)
19:24:31 <dunx> i think it's good for new programmers
19:24:42 <dunx> makes you actually think in the right manner
19:25:17 <Vaelatern> glguy: asking for a friend
19:25:23 <Moto-chan> It's a fun language, in fairness.
19:25:39 <glguy> Oops
19:25:39 <Moto-chan> Why not go for it on the first go :P
19:25:42 <Vaelatern> namely I think it'd be more interesting sooner than C
19:25:43 <glguy> (I *can* imagine some scenarios, just wondering)
19:26:11 <Moto-chan> Tbh glguy, not having learned procedural or OO first, it'd probably be easier to learn Haskell.
19:26:12 <Vaelatern> the person currently likes C but doesn't know where to go or what to do, which fairly is an issue with lower level code
19:26:27 <Vaelatern> And isn't incredibly familiar with C
19:26:58 <Moto-chan> Vaelatern: When I was learning C, I wrote my own calculators, traditional starting program. Except I insisted on writing the pow, log, exp fucntions etc from scratch for lulz xD
19:27:00 <dramforever> By 'never written a line of code', do you mean never Haskell? Or not any sort of programming?
19:27:05 <glguy> Moto-chan: Maybe, I was just specifically wondering about the circumstances, not if it was a good idea
19:27:57 <Vaelatern> I'm aiming at 'no code ever'
19:28:28 <Vaelatern> This person has compiled code and loves using vim for all assignments, so isn't a total stranger to the command line.
19:28:56 <Vaelatern> But is somewhat a stranger to the magics that are programs
19:29:34 <monochrom> I agree with Haskell as the first language. But you will need a very thorough book written for the purpose of first language.
19:29:44 <monochrom> Learn You a Haskell is not such a book.
19:30:11 <monochrom> Most textbooks that cost money are.
19:30:52 <Vaelatern> Okay, relaxing the constraints a little: What about a person who is familiar that you can assign things to names like variables?
19:31:19 <Vaelatern> And that functions exist, though not extremely comfortable with that
19:31:24 <monochrom> But there are two opposite kinds of "can assign things to names".
19:32:22 <glguy> "can name things" vs "can assign things to names"?
19:32:43 <Vaelatern> The latter, which isn't what haskell does iirc
19:32:45 <monochrom> "Given f(x)=x+x, I can deduce f(3)=3+3" is one kind. "I have a global variable x, I can initialize it to 0, then I can keep increasing it by x=x+1" is the opposite kind.
19:33:27 <monochrom> If you only know the imperative kind, you are equivalent to knowing nothing.
19:34:05 <monochrom> Unless you're Dijkstra or something.
19:34:25 <glguy> A lot of people will fall into the "or something" branch of that
19:34:46 <monochrom> Sure, for example Dana Scott and my thesis supervisor.
19:37:05 <monochrom> I added that branch because it is for those who know how to give a denotational semantics to imperative programming, or in more elementary terms, how to encode the second kind by the first kind.
19:38:29 <monochrom> In fact Dijkstra did it the most scary way. "x:=x+1" is a function from Powerset(post-states) to Powerset(pre-states).
19:47:38 <Myrl-saki> class Monad m => MonadReader r m | m -> r where
19:47:40 <Myrl-saki> Why the fundep?
19:48:14 <Myrl-saki> Errr. wait. Ignore that.
19:48:15 <monochrom> To reduce the need to annotate more types by hand.
19:48:23 <glguy> Makes type inference easier in the intended use-case
19:48:48 <Myrl-saki> Yeah. I thought that r was the monad and m was the value.
19:48:56 <monochrom> oh heh
19:49:18 <Myrl-saki> Hmmm
19:49:25 <Myrl-saki> Okay, this one's a better question.
19:50:01 <Myrl-saki> Do I have to change the ioctl code(check the type-safe ioctl package) to allow integers?
19:50:33 <Myrl-saki> The code I'm concerned with uses int(char?) as an argument.
19:51:11 <monochrom> C's int becomes Haskell's CInt
19:51:41 <Myrl-saki> Hmmm...
19:51:45 <Myrl-saki> I see.
19:52:16 <Myrl-saki> monochrom: The declared type in the ioctl package for ioctl is `:: fd -> req -> Ptr ()`
19:52:21 <Myrl-saki> monochrom: The declared type in the ioctl package for ioctl is `:: fd -> req -> Ptr () -> IO ()`
19:52:30 <monochrom> You can add one more layer that calls fromIntegral if you like. But it's optional, and you still start with CInt underneath.
19:52:52 <Myrl-saki> ioctl is a vararg.
19:52:56 <Myrl-saki> How would I do this
19:53:09 <monochrom> Are you sure "fd" is lowercase (type variable)?
19:53:15 <Myrl-saki> Oh wait. Fd.
19:53:27 <monochrom> How is Fd defined?
19:53:34 <Myrl-saki> posix package.
19:53:36 <Myrl-saki> Err
19:53:38 <Myrl-saki> unix?
19:53:52 <glguy> base, probably
19:54:20 <monochrom> Then again the code in the ioctl package has already done the right conversions, likely.
19:54:31 <Myrl-saki> Apparently, there's libffi.
19:54:38 <Myrl-saki> http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
19:54:51 <Myrl-saki> Now the question is type safety.
19:55:13 <glguy> libffi is only needed when you're selecting from an unbounded number of vararg combinations at runtime
19:55:21 <dramforever> I suppose importing once per type-of-call is good?
19:55:32 <Myrl-saki> glguy: Right.
19:55:47 <Myrl-saki> The best thing to do would probably just make my own package lol
19:55:59 <monochrom> I don't know libffi, but I guess it comes down to [Arg]
19:56:42 <monochrom> Type safety has to be handcoded by hand.
19:56:54 <dramforever> 'Note that for a C function defined to accept a variable number of arguments, all arguments beyond the explicitly typed arguments suffer argument promotion. However, because C permits the calling convention to be different for such functions, a Haskell system will, in general, not be able to make use of variable argument functions. Hence, their use is deprecated in portable code.'
19:56:58 <dramforever> Bad...
19:57:29 <Myrl-saki> I guess I'll just do it myself.
19:57:44 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html?highlight=capiffi#the-capi-calling-convention
19:58:30 <dramforever> oh yeah1
19:58:31 <dramforever> yeah!
19:59:10 <monochrom> How CAPI help vararg?
19:59:29 <glguy> It generates some C code to call the vararg function at the type you specify
19:59:50 <glguy> You get a helper function that deals with the argument promotion
20:00:19 <glguy> You still need 1 import per type, but it will work
20:00:35 <monochrom> I see
20:20:31 <mmachenry> I have a performance problem that I think a refactor with better understanding of MonadPlus might help. Anyone want to take a crack at it? http://lpaste.net/351552
20:31:07 <glguy> mmachenry: I don't think that that encoding is going to get much more efficient, at least not with a better understanding of MonadPlus
20:31:50 <glguy> Perhaps you could make it more efficient by exposing the 'interpret' function from the finite-domain module rather than reinterpreting all the FDExprs every use of #== and #\=, though I don't know how expensive that is
20:33:09 <glguy> You could avoid generating such a large expression by detecting when count == 0 in Haskell instead of in the FD type
20:33:25 <glguy> without that you'll be generating a larger expression than is necessary
20:34:01 <mmachenry> Hm
20:34:10 <mmachenry> Not sure I understand the last bit.
20:35:20 <glguy> once you get to: tally xs 0 n, you should just check that for all xs: x. x #\= n
20:37:01 <mmachenry> Yeah I see. 
20:38:44 <mmachenry> I'm looking into using the interpret function directly in FD. It is exposed I think.
20:39:42 <mmachenry> Have you used this library before, glguy?
20:39:59 <glguy> no, I glanced at it last time you asked about it
20:40:26 <glguy> I've used systems that encode stuff like this, though
20:44:49 <mmachenry> Ah. Cool. thanks for the help. I'm reprofiling now.
20:45:16 <mmachenry> Doesn't seem to be much better. 95% of all time is spent in this one function.
20:48:27 <glguy> It's making a (huge) tree of all the possible ways that there could be exactly that many elements in the list
20:49:38 <glguy> You could perhaps work to reuse some of the sub-expressions
20:50:15 <glguy> so if you remembered the expression for how to count each number of elements from each tail of the list you could reuse them rather than regenerating them
20:50:42 <glguy> Or you could think about how to restructure your problem so that it doesn't rely on counting the number of occurences
20:51:42 <mmachenry> Hm yeah. Reusing that sub expression is weird to me given that this is FD and not typical values.
20:51:50 <mmachenry> But maybe that applies equally. 
20:51:59 <glguy> it still applies
20:52:18 <mmachenry> Shouldn't it not be generating a huge tree in the first place?
20:52:29 <glguy> It's necessarily generating a huge treee
20:53:29 <glguy> every list element branches in two directions
20:55:21 <mmachenry> Yeah fair enough.
21:36:50 <mmachenry> glguy: I tried pulling this out of the FD, where I can write a much more efficient algorithm, and it's sadly much less efficient. Pretty expected because the rejection of a solution is not in the FD and therefor many more solutions are generated.
21:37:03 <mmachenry> But it goes through the list linearly.
22:24:50 <_sras_> Is there a haskell library/package that has functions to format currency values (eg 1,00,000.00)
22:32:14 <johnw> _sras_: I have code that can do that
22:32:36 <johnw> http://hackage.haskell.org/package/commodities
22:33:23 <johnw> hasn't been updated in a while, so if you run into problems, please submit a bug report
22:38:27 <Jello_Raptor> Is there any good way to `Fractional a => a -> Double`? 
22:42:03 <nshepperd> I think you may need fromRational . toRational :: Real a => a -> Double
22:43:38 <runeks> I get an error "cannot eta-reduce the representation type enough" when trying to derive Monad for a newtype: http://lpaste.net/351558
22:43:47 <runeks> Source file: https://github.com/runeksvendsen/bitcoin-payment-channel/blob/master/test/Main.hs#L19
22:45:19 <jle`> runeks: ah yeah, that's not how GeneralizedNewtypeDeriving works
22:45:58 <jle`> GND says, roughly, if the thing on the inside of your rwapper is an instance of what you're deriving, then the wrapped type's instance is just the same instance
22:45:58 <runeks> jle`:  what am I missing?
22:46:08 <jle`> it doesn't actually write a Monad instance for you
22:46:14 <jle`> it just uses the Monad instance of whatever your newtype is wrapping
22:46:20 <runeks> Oh, I see.
22:46:25 <jle`> in this case, your newtype isn't wrapping any monad instance
22:46:40 <runeks> jle`: thanks!
22:46:52 <jle`> it's basically a mechanism of saying 'use the newtype as if it were the value it's wrapping'
22:47:00 <jle`> not a way of writing instances automatically
22:47:05 <jle`> just to remove boilerplate, kinda
22:47:08 <jle`> runeks: no problem!
22:47:22 <jle`> runeks: if your type was newtype MonadTest a = MonadTest { runTestM :: Identity a }, then GND would work
22:47:30 <jle`> runeks: because it'd use the Monad instance of Identity
22:48:21 <runeks> jle`: Ah! Identity is the one to use. thanks again!
22:49:15 <_sras_> johnw: These functions ? http://hackage.haskell.org/package/commodities-0.2.0/docs/Ledger-Commodity-Print.html
22:49:27 <johnw> yes
22:49:42 <johnw> you can use the parser to read in commoditized amounts with thousands-markers, and then print them back
22:50:23 <johnw> you can also do math on them as vector spaces, since it supports values with multiple commodities
23:18:25 <geppettodivacin> johnw: Is there any example code of how to use commodities? The documentation is pretty sparse.
23:22:03 <mmachenry> glguy I think I need this implemented in my language: http://www.cs.toronto.edu/~fbacchus/Papers/B-CP2007.pdf
23:22:11 <mmachenry> Specifically the among predicate. 
23:25:14 <mmachenry> Or rather, this: http://web.emn.fr/x-info/sdemasse/gccat/Camong.html
23:34:58 <fresheyeball> anyone up?
23:35:08 <fresheyeball> I'm doing my first ever upload to hackage
