00:00:23 <Lokathor> lifting up withAsync is much harder than I expected
00:02:36 <aragorn123> Hi, this might not be the right place for this question, so I apologize in advance. I've been learning category theory lately, mostly from Bartosz Milewski's blog and video lectures. Having completed the video lectures, I'm looking for a textbook with a good number of exercises. Does anyone have any recommendations? Thanks
00:04:36 <Philippa> ooh. This /is/ a good place, but I'm about 5 years out of date on good recs
00:05:28 <zipper> What is the easiest way to set a field in an existing record value?
00:05:57 <Maxdamantus> zipper: values aren't something you can set things on.
00:06:13 <zipper> type Hooman = Hooman {name :: String}; let n = Hooman "John";
00:06:19 <Maxdamantus> zipper: but you can do something like `foo{ bar = baz }` to produce another value like `foo` but with the `bar` field set to `baz`.
00:06:30 <zipper> I want to take n and name to something
00:06:43 <zipper> Maxdamantus: Yes I would like not to mutatate
00:06:48 <zipper> Set was the wrong word
00:06:54 <Maxdamantus> n{ name = something }
00:07:07 <Philippa> aragorn123: I don't know how heavy Categories for the Working Mathematician is on exercises, for example
00:07:18 <zipper> Maxdamantus: Thankee
00:07:26 <Philippa> knowing whether your background is more "typical mathematician" or "typical compsci" might help too
00:07:41 <Philippa> (I'm the latter: I need topology examples explained in detail)
00:09:04 <aragorn123> Definitely more compsci than math, but my interest is in understanding category theory in a wider context than just programming
00:11:09 <nanoz> can someone please help me on this
00:11:11 <nanoz> thanks
00:11:16 <Philippa> sure - it's just that textbooks for mathematicians often assume you're already literate in topology
00:11:59 <cocreature> aragorn123: awodey’s book has exercises iirc but I think there are no solutions available.
00:13:14 <Lokathor> So, how does one go about lifting withAsync into using MonadIO instead of just IO
00:13:24 <Philippa> nanoz: do you need help doing it in haskell, or at all?
00:14:10 <cocreature> Lokathor: you are probably looking for the "monad-control" package but it will add an additional constraint not just MonadIO
00:14:25 <cocreature> Lokathor: if you just want to use it and not lift it yourself, take a look at the lifted-async package
00:15:05 <aragorn123> Someone recently suggested Category Theory in Context by Emily Riehl to me
00:15:15 <aragorn123> Does anyone know if it's any good?
00:15:26 <Philippa> that's certainly one I'd like to read and have heard good things about, but haven't had the spoons to try it myself
00:15:48 <Philippa> nanoz: one hint I can give you - which moves create new capture opportunities?
00:16:15 <Philippa> (it's an optimisation problem, you need a better strategy than trying all possible moves)
00:16:20 <Lokathor> cocreature, how... do i use lifted-async? I have a type that's a newtype over ReaderT with derived Functor, Applicative, Monad, MonadIO
00:16:37 <Lokathor> I've never heard of MonadBaseControl
00:16:44 <Philippa> bbiab
00:17:08 <cocreature> Lokathor: if it’s just a newtype you can probably get the MonadBaseControl instance for free since ReaderT already has one
00:17:34 <cocreature> Lokathor: then just use "withAsync" from lifted-async and everything should work aout
00:17:37 <cocreature> *out
00:20:02 <Lokathor> cocreature, oh no, it won't let me auto-derive the instance it seems
00:20:14 <Lokathor> wrong Kind
00:20:41 <cocreature> Lokathor: could you show me the code and the error?
00:20:43 <jmorris> is there a function that gets the first n elements of a list? e.g. foo 5 [1,2,3,4,5,6,7,8,9,10] = [1,2,3,4,5]
00:21:00 <ubsan> :t take
00:21:02 <lambdabot> Int -> [a] -> [a]
00:21:06 <ubsan> jmorris: ^
00:21:35 <jmorris> thanks ubsan 
00:21:51 <Lokathor> cocreature, http://lpaste.net/351268
00:23:55 <cocreature> Lokathor: you need to derive "MonadBaseControl IO" not just MonadBaseControl, but it looks like gnd doesn’t work with classes that have associated types. let me write the instance for you
00:24:12 <Lokathor> okay
00:30:21 <samuel> anybody have any experience putting together custom network protocols?
00:31:18 <cocreature> Lokathor: http://lpaste.net/351269
00:32:37 <nanoz> Philippa i need to brute force otherwise may end up wrong soln
00:33:43 <Philippa> nanoz: you should still work out what you can do to cut down the search space
00:34:00 <Lokathor> it works
00:34:06 <Philippa> 5 seconds across 1000 problems one of which will be 50 long is gonna hurt
00:34:39 <Philippa> that said: you can at the least keep track of what changes about which captures you can make as you make a capture. Hope that helps?
00:35:07 <Lokathor> cocreature, i've still no idea why it works :P
00:35:33 <cocreature> Lokathor: sorry I’m busy right now so I can’t explain it but iirc there are some blogposts that explain monad-control
00:35:47 <Lokathor> that's fine
00:36:03 <Lokathor> lets me use lifted withAsync is all i'm worried about at the moment
00:38:17 <nanoz> RxB→xR
00:38:17 <nanoz> BxR→xB
00:38:17 <nanoz> RxB→Bx
00:38:17 <nanoz> BxR→Rx all this combination 
00:43:21 <Philippa> nanoz: I read the question. That's not what I'm saying
00:44:09 <Philippa> You're dealing with a potentially-ambiguous parsing problem. So you want to either work out what can introduce ambiguities (so you can find the maximum number of captures), or brute-force efficiently by keeping good track of which moves you can make /with the string you have/
00:44:46 <Philippa> a given capture may create or remove possible captures because it changes relationships involving pieces a space further away
00:45:12 <Philippa> (the piece that captured may become capturable, for example)
00:45:23 <Philippa> those are your branches, you don't want to calculate them afresh each time
00:48:05 <kadoban> Just brute-force with memoization would probably be a decent place to start
00:49:01 <Philippa> the nature of the problem means how you store circumstances affects memoisation somewhat, though
00:50:16 <kadoban> Sure, it usually does. There's really compact and easy-to-compare representations of that though ... or even just a list might be okay, though might waste a lot of time.
00:50:50 <Philippa> a string's the obvious example of it, yeah. It just forces you to find all the legit captures/reductions the slow way
00:51:47 <Philippa> (I'd probably start with it anyway while experimenting with other things)
00:52:24 <Philippa> oh, right. Don't use a string, use a [Bool]. Makes it a lot easier to build specialised memoising if you need it
00:53:12 <Lokathor> https://hackage.haskell.org/package/async-2.1.1/docs/Control-Concurrent-Async.html is it just me or is the indentation on the withAsync totally invalid?
00:53:23 <Lokathor> the withAsync example that is
00:55:18 <MarcelineVQ> it's lined up with the example above it
00:55:27 <MarcelineVQ> but the do is kinda weird
00:55:40 <Lokathor> when i try to indent like that GHC says my indentation is off
00:56:02 <Lokathor> normally, one would have to have the more inner do blocks indented an extra level, i'm not sure how that example is supposed to work
00:59:05 <geekosaur> Lokathor, do you do something that disables -XNondecreasingIndentation?
00:59:16 <geekosaur> (like, explicitly select Haskell98 or Haskell2010)
00:59:36 <Lokathor> ah, default-language:   Haskell2010
01:00:00 <Lokathor> i thought that was what you were supposed to put in every cabal file :(
01:00:03 <Lokathor> it burned me
01:00:49 <kadoban> I wouldn't really call the burned, personally. I guess it's all taste, but that indentation (or lack thereof) would bug me.
01:01:10 <Lokathor> kadoban, it depends on how often you plan to be spawning side threads
01:01:16 <MarcelineVQ> fwiw the async package is explicitly haskell2010
01:01:23 <Lokathor> in my case, 99% of all work will have to happen in side threads
01:02:57 <Lokathor> speaking of which, is there a way to give one thread higher priority over others?
01:05:14 <Philippa> re the earlier problem, I'm wondering if "always capture with the less-frequent colour" is a sufficient heuristic to get you to "most possible captures"
01:05:14 <geekosaur> don't see any priority support in there
01:05:30 <Lokathor> yeah, i also came up mostly empty
01:05:32 * geekosaur poking GHC.Conc
01:05:47 <Lokathor> a proposed patch from 3 years ago that people seemed to reject :/
01:05:48 <Philippa> ("don't capture the last of a colour unless there's no other move" should be obvious)
01:06:31 <Philippa> priority and cooperative threads isn't an easy combination
01:07:00 <Lokathor> yeah. It would be nice if i could have the main thread be higher priority for better responsiveness, but if that's not possible it'll be alright
01:07:18 <Lokathor> UI responsiveness that is
01:07:28 <Philippa> having some base clock that everything gets n pops at the scheduler in might work
01:07:45 <Philippa> eg "main thread gets twice as many shots as everything else"
01:08:05 <Lokathor> hmm
01:08:48 <Lokathor> part of the problem is that the main thread is usually off in an FFI call, so you can't interact with it using normal thread things i guess
01:09:02 <Lokathor> at least, that's what i've been lead to believe about thread control and the FFI
01:10:00 <Lokathor> oh well, it's fine. When the game is computing a bunch at once it's just a little less responsive. I don't think that any key presses get dropped entirely though
01:10:15 <Philippa> (that parsing problem also has an RLE encoding that it might be possible to do useful proofs about)
01:10:43 <Philippa> (the equivalent of "11111111111" is a done problem, any number >1 indicates possible captures)
01:11:02 <Philippa> ...I am too bored
01:11:23 <shayan_> is  t1 -> t2 understood as: t1 is a function of t2?
01:11:38 <Lokathor> Philippa, i'm listening to The Witcher 2 soundtrack, and incidentally there's a Philippa in The Witcher 2
01:11:47 <Lokathor> there's a perhaps-boredem-lifting fact for you
01:12:02 <Lokathor> shayan_, i wouldn't say so
01:12:27 <shayan_> Lokathor: t2 is a function of t1?
01:12:42 <Lokathor> I think that (foo :: t1 -> t2) would best be expressed as "foo is a function from a t1 value to a t2 value"
01:13:13 <shayan_> Lokathor: this makes sense. thank you
01:13:16 <Philippa> Lokathor: eh, mostly The Witcher hasn't grabber me from reviews? Admittedly my overall gaming tastes lean a bit Japanese - my favourite WRPG series're Fallout (1,2,NV) and Mass Effect so far
01:13:21 <Cale> shayan_: If you want to use that kind of speak, f :: t1 -> t2 would read as "f is a function of t1 with values in t2"
01:13:32 <Cale> Or "f is a t2-valued function of t1"
01:13:57 <Philippa> ah well. I hope my namesake isn't too godawful :-)
01:14:25 <shayan_> Cale: noted :)
01:15:00 <Lokathor> Philippa, I can suggest 2 and 3 with confidence. 1 was not at all good in comparison. The Philippa in the series is a scheming sorceress. But everyone but the main guy is scheming in that series
01:17:15 <Philippa> *nods* - yeah, this is more or less why it's not quite my thing
01:17:47 <Philippa> (Dragon Age isn't either, but it goes "hi, everything is horrific!" pretty quickly at you)
01:18:27 <Lokathor> so i tried NondecreasingIndentation and it still gave me parse errors
01:19:43 <geekosaur> there's some chained alloca-s in xmonad that are indented that way and it works fine; we don't use most extensions (at least not in core; every so often you find scary stuff in contrib...)
01:20:00 <Lokathor> ah
01:20:06 <Lokathor> docs on that extension say "if the previous token was do, but not if it was let, where or of."
01:21:43 <Lokathor> yeah, got it working now
01:24:30 * Lokathor wonders if the console IO from Text is faster than from String...
01:27:35 <geekosaur> at a guess, marginally. if you;r;e not writing to a file, the main bottleneck is the tty / pty and terminal / emulator :)
01:27:52 * Lokathor shakes fist at sky
01:27:53 <geekosaur> switching to block buffering may help
01:28:13 <Lokathor> block buffering?
01:28:27 <geekosaur> (there is also write to file, run "tail -f thatfile" in terminal
01:28:49 <Lokathor> ha, hmm, but i don't think that works so well in windows
01:28:53 <Lokathor> :3
01:29:06 <geekosaur> oh, right, windows. that will be even weirder
01:29:32 <geekosaur> (like, you can expect performance difference between cmd.exe and the pipe hack mingw/cygwin terminals use)
01:30:39 <geekosaur> buffering is still a thing on windows and console windows will still default to line buffering; block buffering like files use will be faster but output may be "choppy" if other parts of the program are slow
01:31:06 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/System-IO.html#t:BufferMode
01:31:50 <Lokathor> well the big problem is that it's computing 10 million random calls in the background as a test... currently I'm using nobuffering on stdout i think
01:31:51 <geekosaur> (p.s. dear ghc folks, please put up 8.0.2 docs now it's out :)
01:32:17 <geekosaur> that's by far ythe slowest, yes
01:32:20 <Lokathor> (p.s. dear stackage folks: please get 8.0.2 out so that i can use glfw on windows)
01:32:29 <Lokathor> oh that's the slowest? damn
01:32:40 <geekosaur> they still havent released a *stack* for 8.0.2
01:32:50 <Lokathor> i know i want them to get on it
01:32:51 <geekosaur> yes, one I/.O call per character
01:33:06 <geekosaur> even with Text, likely
01:33:22 <Lokathor> yikes
01:33:41 <MarcelineVQ> what do you mean yikes, you wrote it specifically to do things one char at a time :>
01:33:52 <geekosaur> (because unless they are specifically avoiding the normal interfaces, hPutStr loops over hPutChar and each one forces an I.O operation)
01:34:34 <geekosaur> dunno about windows but on unix one syscall per character is visible even on fast CPUs
01:34:58 <Lokathor> let's try BlockBuffering Nothing
01:35:08 <geekosaur> (granted that's mostly because the terminal emulators are fancy and being composited >.> )
01:35:23 <Lokathor> you hear about the new high performance terminal?
01:35:30 <MarcelineVQ> By which I mean that the interface you defined is in terms of supplying an operation that reads a single character
01:35:31 <Lokathor> written in OGL, runs in 4k if you want
01:35:51 <Lokathor> MarcelineVQ, oh that's input though
01:36:27 <Lokathor> i didn't define how ReadConsoleInput works, that's all windows.h
01:36:31 <MarcelineVQ> Ah alright yes
01:37:06 <geekosaur> the ugly bag of mostly water is the performance bottleneck on input :p
01:37:50 <bec> Hello
01:37:54 <bec> I'm trying to install bytestring in a sandbox with --enable-tests, but I'm running into a dependency cycle. Right now, I believe my best chance to run the test is to try combinations of specific versions for the conflicting deps, but that looks odd. Am I missing something ?
01:39:42 <Lokathor> BlockBuffering is _not_ the way to go it seems >_>
01:41:22 <geekosaur> then your problem is likely elsewhere in the program; consider profiling
01:41:39 <Lokathor> no, by that i mean that i didn't have a single hFlush in the program
01:42:14 <Lokathor> so the entire program basically just locked up until there was a page of text in the buffer
01:42:46 <geekosaur> yes, that's what I meant by "choppy"
01:42:53 <geekosaur> if you are prompting, do explicitly hFlush
01:44:39 <Lokathor> so does BlockBuffering with the occasional hFlush beat LineBuffering?
01:45:04 <geekosaur> as long as you're not prompting on every other line or something
01:45:21 <Lokathor> uh, actually the user is being prompted every line >_>
01:45:36 <geekosaur> the more characters you can buffer up before the write, the faster it'll go --- but you do want to force that write (flush) before reading input
01:46:08 <geekosaur> oh. stick to LineBuffering and flushes, but even NoBuffering is not much mroe terrible than what your;e already doing to yourself
01:46:54 <Lokathor> well what's really happening is that the user can type at any time, and then background processes are also occasionally being allowed to print things while that's happening
01:47:01 <Lokathor> so the user is never *not* being prompted, effectively
01:47:04 <Lokathor> :P
01:48:08 <ongy> what are you doing? this sounds like torture instruments
01:48:41 <geekosaur> ah, last time I did something like that I batched the output from the background processes --- but that was in a different language where I could count on the standard library to batch certain kinds of writes instead of splitting them all into individual characters
01:49:31 <Lokathor> ongy, it'll be cool i swear
01:49:39 <geekosaur> (monitoring console for a filesystem torture test)
01:50:14 <ongy> wouldn't ByteString.IO or text give us at least single write() syscall for each hPutStr?
01:50:46 <geekosaur> (on an old centos, I didn't hate myself enough to use ghc6.ancient and the "raw" linux binary installer wanted newer versions of a bunch of libs)
01:51:11 <Lokathor> well, it seems.... a hair more responsive now
01:51:33 <Lokathor> the background work is clearly a major offender. Once it finishes its task the program becomes notably more responsive
01:53:13 <geekosaur> ongy, not if it is using ghc's buffered I/O implementation; and mixing biffered and unbuffered I/O on the same filehandle is asking for trouble. I am not sure if theywere expecting things to fuse, but that's unlikely to happen as the implementation goes from what I've seen
01:54:12 <ongy> ... fun
01:55:01 <Lokathor> ongy, https://github.com/Lokathor/galaxy-break if you want to have a look at what's going on
01:55:11 <Lokathor> (only compiles on windows at the moment)
01:55:27 <geekosaur> (actually handling mixed buffering like that --- optimizing hPutStr --- poses some interesting issues especially in the presence of threading. I was working in perl so threading was not an issue (it pretty much doesn't))
01:57:33 <MarcelineVQ> Lokathor: you sure about that?
01:57:54 <Lokathor> oh gosh there's my inbox with a pull request
02:08:13 <ongy> haha
02:09:45 <shong> iset
02:31:03 <Lokathor> so does haskell have an interface for a Vector-like type that makes it like an ArrayList?
02:31:27 <Lokathor> that is, a contiguious memory type that also grows as necessary if it is added beyond capacity
02:34:02 <MarcelineVQ> contiguous for locality?
02:34:44 <Lokathor> yeah
02:35:22 <Lokathor> basically a Vector, but like, also with some capacity number, and "add" puts one on the end and bumps capacity by 1, and then if you add enough it reallocates them all to a new, bigger vector
02:37:36 <MarcelineVQ> that could be fun to make, like an okasaki queue, so you'd double the size of it and copy to the new big one if you go over, but act like you only added 1, which saves you time if you go over 'the limit' again
02:38:15 <MarcelineVQ> since you can just keep bumping the fake limit until you need to copy to another bigger one
02:38:27 <Lokathor> it's like, a Java 101 type project, so i kinda just assumed that it already existed somewhere
02:38:50 <Lokathor> but i can also make it if i end up actually needing it.
02:41:32 <MarcelineVQ> mutable vector has 'grow' so it could be pretty straightforward to make
02:47:31 <nanoz> https://www.hackerearth.com/practice/basic-programming/implementation/basics-of-implementation/practice-problems/algorithm/jumping-tokens/ i really dont know how to solve this problem intially thought of doing this format RxB→xR
02:47:31 <nanoz> BxR→xB but all the answers i got ended up wrong
03:01:58 <shayan_> http://imgur.com/a/LzQ4g Am I suppose to be running each line in the GHCi?
03:02:06 <shayan_> I’m trying to download the Cabal sandbox
03:02:22 <Lokathor> shayan_, those are for the normal terminal, not for ghci
03:04:03 <shayan_> ah ! 
03:05:12 <shayan_> how can I overide this error message: fatal: could not create leading directories of '/path/to/cabal': Permission denied
03:05:21 <shayan_> :S
03:05:42 <Lokathor> you have to pick a new path i guess?
03:05:53 <Lokathor> i wish i was more help but it is 4am where iam
03:05:58 <Lokathor> and i think i must sleep
03:06:44 <shayan_> Lokathor: thank you!
03:10:19 <MarcelineVQ> shayan_: /path/to/cabal is an example path, you're supposed to put there where you want to download it to
03:11:35 <shayan_> MarcelineVQ: Okay. Does it matter where I put it? Is it good practice to put it in the same folder where my Haskell/GHC files are?
03:12:22 <nomotif> whats the beginners channel?
03:12:23 <MarcelineVQ> I believe it doesn't matter in this case, you won't need it once it's done installing since it'll make its own directories
03:13:22 <shayan_> MarcelineVQ: thanks so much
03:13:46 <MarcelineVQ> nomotif: beginner questions are welcome here, there is a #haskell-beginners which is good for if it's pretty busy in this channel, but you're as likely to get help in either place
03:14:11 <MarcelineVQ> I'd ask in both if I had a question :>
03:14:36 <nomotif> Thanks MarcelineVQ 
03:45:17 <shayan_> I am having difficulty saving a file as a .cabal extension
03:45:25 <shayan_> when i save it in plain text editor, i save it as “todo.cabal”, and when i try running it on the terminal, i get this error message: cabal: todo.cabal:1: Parse of field 'name' failed.
03:47:12 <pavonia> shayan_: What's the content of your file?
03:48:05 <shayan_> pavonia: http://imgur.com/a/9v78B
03:48:14 <HugoDaniel> that error message needs improvement though
03:48:20 <shayan_> i’m following a guide over at http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
03:49:20 <HugoDaniel> oh ok
03:49:37 <HugoDaniel> shayan_: start from an empty folder
03:49:43 <HugoDaniel> and do a "cabal init" there
03:49:47 <pavonia> shayan_: And what exactly means "when I try to run it"?
03:50:17 <HugoDaniel> answer the questions, and then you should have a good to go cabal file :D
03:51:02 <HugoDaniel> shayan_: if you *really* want to do your cabal file by hand, then paste it using hpaste or something and let us have a look at it (maybe some fscke-up utf-8 characters ?)
03:52:50 <HugoDaniel> it is very easy in mac to produce utf-8 invalid spaces :/
03:53:06 <shayan_> HugoDaniel: woah. something interesting is happening
03:53:15 <shayan_> xD
03:53:35 <shayan_> i ran cabal init in a new folder as advised
03:54:00 <shayan_> and now it’s askiing me the questions that i previously had created
03:54:05 <HugoDaniel> yes
03:55:11 <HugoDaniel> btw, using scotty, blaze-html and persistent is not the best approach to learning haskell, or doing a website btw
03:55:40 <shayan_> Warning: no package found providing Web.Scotty. :(
03:55:41 <MarcelineVQ> still pavonia's question is important, you don't run a .cabal file, it's read automatically when you use other cabal commands so what did you type that made that error come up?
03:55:54 <HugoDaniel> shayan_: yes, its an old tut
03:56:26 <HugoDaniel> indeed, can you list the commands you are typing ?
03:56:28 <shayan_> HugoDaniel: I am actually learning through Programming in Haskell but Hutton. I am just taking a short break. Really wanted to make something :)
03:56:40 <shayan_> *by
03:57:15 <HugoDaniel> those are 3 complex libs, each with their own set of nuances, i would strongly advise against their use in the early stages of coding with haskell
03:57:59 <HugoDaniel> also if you want to build a website and stay close to the haskell ideology go all the way to the client side (thats where the fun is at) and give it a go with purescript
03:59:14 <shayan_> pavonia MarcelineVQ before I was running cabal install in the terminal
03:59:43 <shayan_> pavonia MarcelineVQ and I was getting the message “todo.cabal:1: Parse of field 'name' failed.” that is what i mean’t by getting an error when running it
04:00:37 <MarcelineVQ> alrighty
04:02:08 <shayan_> D218:test shayanbozorgmanesh$ cabal install
04:02:09 <shayan_> cabal: Error reading local package.
04:02:09 <shayan_> Couldn't find .cabal file in: .
04:03:44 <HugoDaniel> hmm ls -a there
04:03:49 <HugoDaniel> do you have the .cabal file there ?
04:03:59 <HugoDaniel> or anything .cabal ?
04:04:09 <HugoDaniel> proj.cabal would be the ideal
04:04:16 <HugoDaniel> where proj = the name you gave
04:05:31 <shayan_> HugoDaniel: yes the .cabal file is in there
04:06:11 <shayan_> this is the right command to be running: cabal install
04:06:12 <shayan_> ?
04:06:14 <HugoDaniel> do you have any other file there ?
04:06:17 <HugoDaniel> yes the command is ok
04:06:36 <shayan_> yes i have other files
04:06:44 <shayan_> start new empty folder?
04:07:48 <HugoDaniel> no, its not necessary if you already did that and run cabal init
04:08:01 <shayan_> i have 2 .cabal files
04:08:15 <HugoDaniel> ok, now thats unexpected
04:08:23 <shayan_> xd
04:08:28 <shayan_> i deleted one
04:08:44 <HugoDaniel> can you start fresh, create a new folder, say "my-haskell-baby-steps"
04:08:48 <HugoDaniel> go to that folder
04:08:51 <HugoDaniel> cabal init in there
04:08:59 <HugoDaniel> answer the questions, say you want to do an executable
04:09:07 <HugoDaniel> let it create the Main.hs file
04:09:46 <HugoDaniel> then run "cabal build" instead
04:10:04 <HugoDaniel> it does not try to install anything in your $HOME, it just builds the project and produces the executable file
04:10:06 <shayan_> Package name?
04:10:12 <HugoDaniel> just keep on pressing enter :D
04:10:26 <HugoDaniel> use my-haskell-baby-steps, or whatever the suggestion it gives you
04:10:49 <HugoDaniel> you dont need a package name, you wont be uploading it to hackage or anything like that, its just to try out some haskell basics
04:10:59 <HugoDaniel> but just keep a simple default one
04:11:08 <shayan_> Warning: no synopsis given. You should edit the .cabal file and add one.
04:11:09 <shayan_> You may want to edit the .cabal file and add a Description field.
04:11:15 <HugoDaniel> yes, nevermind that
04:11:32 <HugoDaniel> when you are going to code your master piece in haskell then you can write a proper synopsis
04:11:43 <shayan_> okay xD
04:11:54 <HugoDaniel> until then just let it go blank, again: you are not going to upload it to hackage, no synopsis is useful at this stage
04:12:07 <HugoDaniel> ok, cool
04:12:24 <HugoDaniel> now instead of trying to install it in your local haskell system
04:12:26 <HugoDaniel> just build it
04:12:30 <HugoDaniel> with "cabal build"
04:12:36 <shayan_> yes, just finished doing that
04:12:50 <HugoDaniel> cool
04:13:01 <HugoDaniel> it should have created a dist folder with your executable in it
04:13:08 <HugoDaniel> nice
04:13:11 <HugoDaniel> now do a "cabal run"
04:13:19 <HugoDaniel> and see if it runs the Main.hs file
04:13:26 <shayan_> yes! works
04:13:27 <shayan_> :)
04:13:35 <HugoDaniel> alright!
04:13:40 <HugoDaniel> so everything is good to go
04:13:48 <HugoDaniel> now edit your Main.hs as you see fit
04:13:52 <HugoDaniel> and keep away from complex libs
04:14:00 <shayan_> why can’t i view it in http://localhost:3000
04:14:09 <HugoDaniel> well this is just a simple example
04:14:20 <HugoDaniel> it is only outputing a string in your terminal
04:14:34 <shayan_> ah
04:14:39 <HugoDaniel> if you want to run a webserver you need to include a web server lib in your Main.hs
04:14:42 <HugoDaniel> and properly set it up
04:14:56 <shayan_> i misunderstood the todo for an app that would be developed on the localhost:3000
04:14:57 <shayan_> :X
04:15:05 <HugoDaniel> nah, dont read that blog post
04:15:12 <shayan_> okay
04:15:25 <HugoDaniel> understand that most haskell tutorials are very bad and should be totally ignored
04:15:33 <shayan_> can you tell me more about purescript or where i can find information on it?
04:15:40 <shayan_> understood.
04:15:48 <HugoDaniel> thats because people that start to code in haskell tend to feel they are smarter than everyone else and write about doing complex unecessary things
04:16:06 <HugoDaniel> thats a bit out of the scope of this #
04:16:37 <HugoDaniel> purescript is a language that is very similar to haskell, but produces javascript instead of binary code
04:16:41 <HugoDaniel> so you can use it on the web
04:16:53 <HugoDaniel> try out their site: http://www.purescript.org/learn/
04:18:44 <shayan_> HugoDaniel: will check it out, thank you
04:18:48 <HugoDaniel> np
04:19:05 <lpaste> purelazy pasted “I'm trying to learn Applicative style” at http://lpaste.net/351272
04:19:20 <purelazy> Hi guys
04:19:29 <HugoDaniel> ei purelazy :)
04:19:47 <purelazy> Can someone please help with a little problem
04:19:54 <purelazy> HugoDaniel: Yo 
04:20:47 <HugoDaniel> what problem ? 
04:21:26 <purelazy> Couldn't match expected type ‘VkPipelineShaderStageCreateInfo’
04:21:27 <purelazy> --                       with actual type ‘Ptr VkPipelineShaderStageCreateInfo’
04:21:32 <HugoDaniel> ouch
04:21:34 <HugoDaniel> yes
04:21:38 <Boomerang> purelazy: just looking at the types in the comments it looks like you don't need the applicative <$> and <*>
04:21:47 <HugoDaniel> yes, keep away from applicative style
04:22:00 <Boomerang> Or maybe you want to change the type signature of your function to a Ptr _
04:22:00 <HugoDaniel> also, why using a Ptr ?
04:22:29 <purelazy> I'm using an FFI
04:22:38 <purelazy> calling C code
04:23:26 <HugoDaniel> cool, keep applicative away from it, put it in its own module, and use applicative only *after* in other modules
04:23:30 <HugoDaniel> and only if necessary
04:23:46 <HugoDaniel> you see this: (<*>) :: Applicative f => f (a -> b) -> f a -> f b  ?
04:24:01 <purelazy> yep
04:24:28 <HugoDaniel> this means: only use <*> if you happen to be coding by hand a few functions with a signature similar to this: f (a -> b) -> f a -> f b
04:24:30 <purelazy> I am happy to not use Applicative in this instance
04:24:39 <HugoDaniel> a few = more than 3
04:25:07 <HugoDaniel> cool :D
04:25:14 <HugoDaniel> KISS it then :)
04:25:47 <HugoDaniel> haskell is an amazing language without the functor, applicative, monads useless mambo-jambo
04:25:59 <HugoDaniel> you don't need to use it to enjoy the language :)
04:26:52 <purelazy> As I have a perfectly good working function, I'm happy to drop the applicative stuff in this case
04:27:03 <HugoDaniel> do it :)
04:27:14 <purelazy> HugoDaniel: Thanks m8
04:30:59 <MarcelineVQ> you can write it without the record syntax if that's what you're after, it'd just be regular function application
04:48:54 <mbw> Is there a search function in haddock html documentation? I am looking for some equality primitives for floating point data, since manually "abs (x - y) < threshold"ing feels kinda wrong.
04:49:23 <mbw> This is about HSpec in combination with QuickCheck.
04:49:42 <mbw> You guys do write tests right?
04:49:44 <mbw> Right?
04:51:11 <purelazy> MarcelineVQ: I am aware of that, Thanks anyway ;o)
04:51:26 <purelazy> tests?
04:53:16 <purelazy> mbw: It's actually hard to write code that doesn't work
04:53:22 <mbw> I want to do some property tests with floating point values, associativity, idempotence and the like.
04:54:29 <mbw> I'm not doing TDD or anything.
04:54:39 <purelazy> OK
04:55:10 <sm> mbw, yes we do. And the search engine is hoogle
04:55:10 <purelazy> equality primitives for floating point data, like ==
04:55:22 <mbw> Yeah.
04:55:37 <purelazy> > 1.2 == 1.2
04:55:40 <lambdabot>  True
04:55:54 <mbw> > 0.1 == 0.3 - 0.2
04:55:57 <lambdabot>  False
04:56:42 <purelazy> > abs (1.2 - 1.1) < 0.001
04:56:44 <lambdabot>  False
04:56:53 <purelazy> > abs (1.2 - 1.1) < 0.2
04:56:55 <lambdabot>  True
04:57:08 <purelazy> :t 1.2
04:57:10 <lambdabot> Fractional t => t
04:57:28 <mbw> abs ((1.2 - 1.1) - 0.1) < 1e-6
04:57:31 <mbw> > abs ((1.2 - 1.1) - 0.1) < 1e-6
04:57:33 <lambdabot>  True
04:58:06 <mbw> I was hoping there was something like f1 `shouldBeApproximately` f2 or something.
04:58:55 <mbw> Testing with hardcoded thresholds is inherently wrong, since the distance between successive representable floating point values increases with magnitude.
04:59:21 <purelazy> mbw: indeed
05:00:05 <mbw> I wrote a general purpose function like that in C++ once, but it's hard to get right.
05:00:27 <mbw> Taking Inf and NaN etc. into account.
05:00:32 <purelazy> I personally have never come across a kind of "relative" threshold function
05:00:56 <purelazy> What weird stuff are you up to mbw
05:02:20 <mbw> I'm reimplementing the purescript numeric typeclass hierarchy and later want to slap modules and vector spaces on top of that.
05:02:54 <purelazy> what is purescript?
05:03:33 <javjarfer> Hi all! Monadic question here, there is plenty of literature of "Why free monads", but there isn't almost nothing about "Why and where not free Monads". Any idea about when and why would you prefer a custom monad over a free monad?
05:04:35 <mbw> It's similar to haskell, but compiles to javascript. I don't use it myself, but I found their approach interesting, especially because their numeric typeclass hierarchy is a little more nuanced than Haskell's, but less "bloated" than the numeric prelude or one of Edward Kmett's libraries, which are overwhelming.
05:06:26 <c_wraith> I feel like purescript missed the whole point, though.  A strict haskell loses so much of what makes haskell good.
05:06:45 <mbw> I don't know too much about purescript.
05:07:11 <mbw> And I have an "opinion" about javascript.
05:07:59 <mbw> But I could imagine if you run a server side application, that strictness might be a viable option, considering the problems with Haskell's lazy IO.
05:08:28 <purelazy> I agree  with c_wraith regarding strict
05:09:46 <purelazy> better to have lazyscript
05:10:14 <purelazy> or purelaztscript
05:10:43 <purelazy> or purelazyscript
05:10:44 <mbw> I don't think I really understand the main selling arguments of lazy evaluation to be honest. If I had to explain it to a C/Fortran programmer, who never works with infinite data and doesn't believe in "provable" correctness, how would you argue in favor of it?
05:12:29 <mbw> I actually have that kind of background. While I really like many aspects of Haskell, I never really got what lazy eval "does for me".
05:16:04 <mbw> No really, that is an honest to lambda unbiased question.
05:16:38 <purelazy> mbw: can you answer the question "What does strict eval do for me?" :)
05:16:45 <javjarfer> mbw, that is because it is a silent hero that never ask for credit.
05:17:00 <Rembane> mbw: you can implement stuff with less code.
05:17:15 <Rembane> mbw: Than you would have to use with strict evaluation
05:17:49 <dramforever> mbw: Mainly composability
05:17:53 <purelazy> there is someone "just cool" about not doing anything unless it is necessary
05:17:56 <mbw> Actually, I think I can. At least to some extend you can reason about evaluation order, and there are no unexpected space leaks, if you work disciplined.
05:18:10 <purelazy> ^one^thing
05:18:24 <ongy> mbw: no space leaks? C? sorry
05:18:25 <dramforever> You can safely (correctness-wise) move stuff around *without* worrying about evaluation order
05:18:47 <s4ke> hi guys. anyone here working on the parallel computing field with haskell?
05:18:59 <ongy> if they are independant that's always the case, isn't it? That's more "no side effects" side of things
05:19:18 <mbw> But doesn't composability come mainly from the strict barrier between referential transparent functions and applicative/monadic actions?
05:19:20 <purelazy> mbw: In pure Haskell, evaluation order has no meaning
05:19:53 <dramforever> mbw: Purity + Lazy = :) over there
05:20:11 <purelazy> typically any order will do, notwithstanding data dependencies
05:20:13 <mbw> Would you say that pure functions fundamentally have to be non-strict?
05:20:23 <dramforever> say you've got 'if check then oneBranch else theOther'
05:20:32 <dramforever> No
05:20:57 <dramforever> Hmm that's going to be confusing, let's do it again
05:21:02 <mbw> ok
05:21:13 <dramforever> if check then one branch else some other branch
05:21:47 <Rembane> s4ke: A bit, what can I do for you?
05:22:17 <dramforever> if 'one branch' is going to crash when 'check == False' you are not going to factor it out into another variable like 'let ob = one branch in if check the ob else some other branch'
05:22:24 <dramforever> *unless* you have lazy-evaluation
05:22:38 <purelazy> When I first got in Haskell, I remember being freaked out by "Infinite Lists" - WTF
05:23:03 <purelazy> > let ones = 1:ones
05:23:05 <lambdabot>  <no location info>: error: not an expression: ‘let ones = 1:ones’
05:23:19 <purelazy> for example
05:23:29 <purelazy> > ones = 1:ones
05:23:31 <lambdabot>  <hint>:1:6: error:
05:23:31 <lambdabot>      parse error on input ‘=’
05:23:31 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:23:55 <purelazy> I am useless with lambdabot
05:23:57 <niklasb> > let ones = 1:ones in ones
05:24:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:24:02 <dramforever> > let ones = 1 : ones in ones -- Let's just make it an expression and things will be fine
05:24:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:24:37 <purelazy> thanks guys
05:24:37 <purelazy> :P
05:24:52 <mbw> dramforever I am trying to wrap my head around your branch example. Could you please make it more concrete?
05:25:10 <mbw> > repeat 1
05:25:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:25:23 <purelazy> that too mbw
05:25:31 <purelazy> now your getting the hang of it
05:25:44 <purelazy> take 10 (repeat 1)
05:25:48 <purelazy> > take 10 (repeat 1)
05:25:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
05:25:57 <mbw> But there is some intellectual overhead involved if it's in a nested expression.
05:25:58 <niklasb> purelazy: so, how often have you used infinite lazy lists in production code? :P
05:26:09 <purelazy> once
05:26:30 <niklasb> so then, wouldn't stricy by default, lazy on demand be the more reasonable choice?>
05:26:37 <niklasb> *strict
05:27:39 <dramforever> foo n = if n > 0 then 1 + foo (n - 1) else 1
05:28:12 <s4ke> Rembane: i have no real problem, just wanted to chat :). what stuff did you use?
05:28:42 <purelazy> niklasb: What is the benefit of strict by default
05:28:47 <dramforever> I hope you don't consider this too contrived
05:29:01 <hexagoxel> javjarfer: you can always reimplement the free monad structure in your custom monad which makes it kinda hard to answer that question. or easy..
05:29:07 <purelazy> Surely, "only do what you have to" is a good default
05:29:28 <hexagoxel> "use a free monad if what you want to express matches what a free monad gives you"
05:29:30 <mbw> Well you contrived it, not me. So it's still enough to make me think
05:30:18 <dramforever> if I need to add a variable 'm = 1 + foo (n - 1)', in a strict language I would have to put that variable definition inside the 'then' branch
05:30:30 <hexagoxel> javjarfer: nonetheless i agree that the common related tutorials don't explain the relative benefits compared to other approaches very well.
05:31:06 <hexagoxel> e.g. when to use some trivial monad transformer stack, some monad-typeclass interface or a free monad.
05:31:19 <dramforever> because otherwise it would blow up
05:31:19 <dramforever> in a lazy language it's absolutely no problem
05:31:20 <dramforever> mbw: In the real world sure you'll encounter expressions you don't want to evaluate
05:32:11 <Rembane> s4ke: I read a course in Parallell Functional Programming, so basically everything in the parallell part of Simon Marlow's book 
05:32:16 <mbw> I think I'm going to open my trusty Test.hs for this
05:32:26 <niklasb> purelazy: the amount of ! in our programs kind of suggests otherwise
05:32:35 <niklasb> but maybe that's just me
05:32:38 <dramforever> A recursion like this is actually quite common if you're working on numbers (counts)
05:32:55 <s4ke> Rembane: ah ok. well I am working on a new parallel Haskell that is based on Arrows instead of Monads
05:33:04 <Rembane> s4ke: That sounds fun. Why Arrows?
05:33:21 <s4ke> Rembane: arrows are more extensible than monads
05:33:37 <Rembane> s4ke: didn't they become out of fashion a couple of years ago?
05:33:43 <purelazy> niklasb: I guess that is because of FFI
05:33:58 <s4ke> Rembane: well for parallelism they are a good fit though. also FRP uses Arrow notation
05:34:21 <niklasb> purelazy: nope, no FFI. mostly we just started making all of our data structures strict after we had tons of space leaks before
05:34:34 <niklasb> (that was before the StrictData pragma existed)
05:35:09 <purelazy> niklasb: Oh I see.
05:35:25 <s4ke> Rembane: with arrows i was able to introduce a new operator that i called |***| for now, with which i  can parallelize quite easy: (+1) |***| (*2) 
05:35:27 <s4ke> for example
05:35:49 <mbw> dramforever: Ok I think I got your example
05:35:59 <Rembane> s4ke: Aha, that seems like a really good fit. Nice!
05:36:23 <s4ke> Rembane: working on a paper about it currently :)
05:36:49 <Rembane> s4ke: Sweet!
05:36:58 <mbw> While you could declare a lambda function and invoke it in the 'then' branch in C++, it would be less elegant.
05:37:00 <s4ke> currently i have 3 working backends (Multicore Haskell, ParMonad, Eden) and I just recently ported it to Frege
05:37:09 <purelazy> niklasb: Space leaks. Did you complain to the Haskell people?
05:37:36 <niklasb> purelazy: complain about what?
05:37:39 <hexagoxel> javjarfer: a free monad allows the implementer to pause interpretation and even to switch to a different interpreter in the middle. That is the flexibility it provides. (but please take this view with some caution; my experience with free monads is limited.)
05:37:47 <purelazy> space leaking?
05:37:58 <mbw> But you'd use loops anyway :/
05:38:02 <niklasb> purelazy: that's not haskell's problem, it's because stuff didn't get evaluated
05:38:13 <s4ke> Rembane: have you tried HdpH?
05:38:13 <niklasb> because it hadn't been forced
05:39:07 <Rembane> s4ke: I haven't, it sounds a bit like Cloud Haskell. Do you build your abstraction on top of hdph?
05:39:43 <s4ke> Rembane: I haven't managed to figure out how to write a backend based on HdpH yet. Eden works on Clusters though
05:39:46 <niklasb> purelazy: if you store the result of some computation in some global data structure, like an STM var, and you don't force it all the way through, you might have unevaluated thunks all over the place that references stuff which then cannot be GC'ed
05:40:03 <niklasb> even though it's not actually needed once you have the final result
05:40:13 <s4ke> but it's quite outdated. They require a specific compiler and their last release was some while ago. 7.8.2
05:40:58 <mbw> I wanted some convincing arguments in favor of lazy evaluation, be it only for the case when I have to explain it to someone else.
05:41:08 <purelazy> niklasb: I guess STMs are the culprit here
05:41:16 <mbw> Please let's not get religious, there's pros and cons...
05:42:39 <dramforever> mbw: Correctness-wise, lazy is more 'just works' than strict
05:43:02 <mbw> That's actually a usable slogan lol
05:43:34 <mbw> By the way there's an optimization technique called "Expression Templates" used in C++ that makes use of lazy evaluation as well.
05:43:34 <Rembane> s4ke: Is hdph very different from Clusters?
05:43:56 <s4ke> Rembane: hdph uses MPI in the background
05:44:02 <s4ke> Eden does that too
05:44:08 <purelazy> mbw: if you replace "convincing arguments" with "arguments" then you have had many arguments "for" - whether or not they are convincing is depends on the convincee
05:44:28 <s4ke> Rembane: you can think of HdpH as the "non-hacky but more complicated" version of Eden
05:44:32 <Rembane> mbw: You can also use it for constant memory stuff, but that might be more fusion than laziness... hm...
05:44:33 <mbw> It's used by linear algebra libraries for simplifying expressions and automatically dispatching to a BLAS backend if desired.
05:44:58 <Rembane> s4ke: Ah. So more complete and production ready? 
05:45:19 <s4ke> Rembane: well Eden works good, it just requires a separate compiler
05:45:36 <Rembane> s4ke: Good point. 
05:45:41 <s4ke> it's just a different starting point. Eden is much much easier to read and learn
05:46:06 <mbw> I personally take the "tautological" route when it comes to these kinds of discussions. Each idea has its place. Like particle/wave duality I guess.
05:46:59 <s4ke> with Eden you even have stuff like spawnF :: [a -> b] -> [a] -> [b]
05:47:29 <Rembane> s4ke: That combinator makes things so much easier.
05:47:33 <s4ke> which is just plain awesome (and made my life really easy :D)
05:47:44 <Rembane> :D
05:48:22 <s4ke> Rembane: the cool thing about the library i am writing is also that you can write your program and test it against a simple backend that doesnt require MPI or a specific compiler
05:48:36 <s4ke> and if you want it to run on a cluster you just switch out an import statement. 
05:48:58 <Rembane> s4ke: does that mean that you could switch out the backend and compile it for say for instance the Erlang vm?
05:49:05 <s4ke> i have to work on more Cluster friendly stuff though as the root node can become a bottleneck
05:49:35 <s4ke> Rembane: it's still Haskell
05:50:04 <s4ke> or wdym?
05:50:41 <Rembane> s4ke: Okay, so it's a EDSL rather than a compiler? :)
05:50:45 <mbw> Regarding purity and effects. Is there some formal classification of "effects" like static/dynamic, commutative etc. ? This would be useful for reasoning about imperative code, especially in a parallel context.
05:50:48 <javjarfer> hexagoxel, thanks for you explanation, I was aware of that awesome properties they give you, but... then "why not to use always free monads?". One argument could be that left-association could lead to quadratic runtime with them... but I don't know any more drawbacks, and if your evaluation is right associative, you solve the previous cited issue... so... I really don' know any other drawbacks they could have instead of the classical approach.
05:51:10 <s4ke> Rembane: yes. it's just a new way to compose your parallel programs
05:51:51 <Rembane> s4ke: Okay, that's lovely. 
05:52:12 <s4ke> Rembane: hehe nice to hear :)
05:53:08 <mbw> I think I read that effects associated with Applicatives are called static somewhere, and the use of bind makes them dynamic. Then there's commutative Monads like Maybe, and non-commutative like State. Is there a more fine-grained classification?
05:55:06 <s4ke> Rembane: in the benchmarks i have done so far, it performs the same as Multicore and the simon marlow's Par monad. For Eden Benchmarks, I will have to try it again on the cluster
05:56:24 <s4ke> for single node Eden "clusters" it worked just fine so far
06:01:02 <Rembane> s4ke: That's very good. the Par monad is quite fast in my opinion.
06:04:19 <Gurkenglas> Is there a variant on MonadBase / MonadBaseControl that allows you to lift a map between bases?
06:04:41 <c_wraith> Between bases?
06:05:58 <Gurkenglas> Yeah, like zoom allows you to lift a lenslike between states into a map between transformer stacks.
06:06:03 <ph88> is show the recommended way to serialize haskell types ? or are there smarter ways that are faster in parsing and smaller size ?
06:06:17 <c_wraith> Gurkenglas: but every transformer stack only has one base...
06:07:32 <Gurkenglas> Something like "_ => (forall a. m a -> n a) -> x a -> y a", where (x, y) could be for example (MaybeT (MaybeT m), MaybeT (MaybeT n))
06:07:59 <mbw> > (read . show) pi
06:08:01 <lambdabot>  *Exception: Prelude.read: no parse
06:08:07 <c_wraith> Gurkenglas: that just looks like the mmorph package
06:08:10 <mbw> > (read . show) pi :: Double
06:08:13 <lambdabot>  3.141592653589793
06:08:29 <mbw> > it == pi
06:08:32 <lambdabot>  error:
06:08:32 <lambdabot>      • Variable not in scope: it :: Double
06:08:32 <lambdabot>      • Perhaps you meant one of these:
06:08:59 <Gurkenglas> c_wraith, that one only lifts such a map through one layer at a time
06:10:22 <mbw> ph88: There are serialization libraries, like binary and cereal.
06:10:35 <Gurkenglas> Complete the rectangle: MonadTrans - MonadBase; mmorph - ?
06:10:40 <ph88> oh ok
06:10:45 <mbw> Since show works with [Char], it's not performant.
06:11:01 <mbw> But I think the invariant "read . show = id" holds.
06:11:37 <mbw> So it should be ok for Quick'n Dirty I guess.
06:12:12 <ph88> i think it would be nice to use a good serializer lib and then compress it's output as well
06:13:55 <mbw> Maybe here's something https://hackage.haskell.org/packages/#cat:Serialization
06:14:39 <mbw> Hard choices suck, though...
06:14:53 <ph88> yeah that's always the case with haskell packages :|
06:15:16 <mbw> Well that, and API documentation only.
06:15:31 <mbw> That swallowed most of my day yesterday.
06:15:49 <ph88> what were you reading ?
06:17:12 <mbw> I was trying to work wrap my head around the numerical prelude and some of Edward Kmett's libraries. These are huge, but since only the API is documented and there's no tutorial or something like that, it's hard to find an entry point.
06:17:39 <ph88> ah yeah
06:17:53 <ph88> i was trying to use foundation as prelude
06:18:03 <mbw> I b*tched about it in here yesterday, too :)
06:18:08 <ph88> yes i saw it xD
06:18:55 <ph88> anyone mind explaining this piece of code by glguy ?  https://paste.fedoraproject.org/527668/14844898/
06:19:32 <ph88> i'm not sure in which order i should be reading things to understand the flow of the program
06:22:14 <Gurkenglas> I wanted to suggest "roguelike :: MonadIO m => m (Integer -> Integer -> Char) -> (Event -> m ()) -> Integer -> m ()" for Gross, but it's based on the Curses, not IO, monad
06:23:13 <mbw> ph88 There's stuff missing, specifically Parser, Arbitrary (I guess for QuickCheck or something) and GenericClause.
06:24:24 <Gurkenglas> So it'd have to be either "MonadBase Curses" instead of "MonadIO" with an orphan instance for MonadBase Curses Curses, or "MonadBase IO" if there is a way to lift that IO into Curses on his side
06:24:46 <mbw> Otherwise, M seems to be a "decorator" for extending an arbitrary Monad with two methods.
06:24:52 <Gurkenglas> (And if there is such a way, MonadIO also ought to be isomorphic to MonadBase IO?)
06:24:56 <mbw> I guess this is the purpose of this demo?
06:24:57 <c_wraith> ph88: I really think that's the wrong approach to the problem.  It introduces more boilerplate than you were trying to remove.
06:26:38 <ph88> :(
06:27:08 <c_wraith> I think all you needed was a higher-order function with a... lot... of arguments
06:27:28 <ph88> mbw, that code was a possible solution after i asked earlier how i could abstract this code https://paste.fedoraproject.org/527194/14844211/
06:28:27 <Gurkenglas> What's genericList?
06:28:35 <ph88> a parser function
06:28:53 <ph88> genericList :: Parser GenericList
06:29:55 <ph88> but i was asking to just understand that code to know a bit more about haskell and so i can think for myself whether i would like this solution or not ^^
06:31:21 <ph88> especially lines 7 and 8
06:31:26 <ph88> don't know how to read that
06:32:11 <ph88> the first class and first 2 instances i understand
06:32:58 <Gurkenglas> ph88, a 'C' is a type 'a' that allows you to generate an 'f a' for any monad 'f' that is an 'M'
06:35:06 <ph88> i think i'm missing a piece of code here actually .. how line 22 is gonna know whether it should use chr or str .. i think the calling code is missing
06:35:19 <Gurkenglas> That means to generate the 'f a', any instantiation of 'C' can only use monad operations and the generic 'chr' and 'str' functions
06:35:46 <ph88> i mean how to decide WHICH chr or str from the 2 possible options
06:36:58 <Gurkenglas> line 22 is going to use the instance "C GenericList", which gl guy left as an exercise to the reader, probably because you didn't provide the implementations of 'instance Arbitrary GenericList' and 'genericList' either :P
06:37:13 <ph88> yes for sure
06:39:07 <Gurkenglas> How do I fill in the "???"s on http://lpaste.net/351259 , without manual type inference?
06:39:32 <ph88> how can  gen  produce either a type  Parsec e s a  (for megaparsec)  or  Gen a  (for quickcheck)  ?
06:40:20 <ph88> it's gonna do type inference to decide that ?
06:41:07 <Gurkenglas> yup
06:41:43 <Gurkenglas> (You mean "either a type 'Parser a' or 'Arbitrary a'", right? Or are lines 10 and 14 wrong?)
06:42:06 <ph88> Parser  is an alias for   Parsec e s a
06:42:24 <ph88> and Arbitrary i think it's a mistake because the arbitrary function should yield  Gen a
06:43:43 <ph88> c_wraith, where do you see boilerplate in this ?  line 18-25 is what i have to repeat about 150 times now, but still that's half of what i have to type now
06:44:07 <c_wraith> ph88: yes, that's exactly the boilerplate
06:44:21 <ph88> but it replace this  https://paste.fedoraproject.org/527194/14844211/
06:44:31 <ph88> 17 lines of code replaced by 7 ..
06:44:39 <ph88> times 150 x
06:45:13 <c_wraith> Oh, I see. You were asking about a slightly different thing than I was answering.
06:45:46 <ph88> oh i didn't understand your answer so that might be possible yeah :P
06:46:44 <ph88> this is the first time i find out you can use typeclasses for this kind of generic programming ^^
06:46:52 <ph88> i wish someone would have told me sooner
06:47:13 <ph88> nice decorator pattern or whatever it's called
06:47:32 <Yuras> how to pass -optl-no-pie to GHC when doing "stack build"? --ghc-options doesn't seem to work
06:48:54 <ph88> so i can just change the monad  (Parser or Gen)  and the all it's functions that are needed will change too, that's great !
06:49:26 <ph88> is it also possible to  get a different  underlying type?  so instead of  Parser a  and  Gen a  i get  Parser a  and  Gen b   ?
06:49:40 <ph88> Yuras, try --
06:50:46 <Yuras> ph88: doesn't work
06:51:16 <ph88> Yuras, i use this command for build with optimization:   stack build --ghc-options="-O2 -fexcess-precision -optc-O3 -optc-ffast-math -rtsopts"
06:51:23 <Gurkenglas> ph88, you'd need to do something like "class Monad f => M f a where ..." that gives you the tools to generate an a or b depending on f is Parser or Gen
06:51:28 <ph88> so ok it was not  --  :P
06:51:32 <Gurkenglas> *whether
06:51:36 <mbw> ph88: You have to ask yourself the general question in which dimension your program will "grow". If you do an oop kind of thing where you keep adding types that should have the same functionality, typeclasses are a good choice to abstract that. If you keep adding new function, make an algebraic data type. Another route is the use of higher-order functions, which I would consider as well since I think it's 
06:51:42 <mbw> often a simple and direct solution.
06:52:31 <mbw> People trying to be clever with class hierarchies is a common pitfall in oop after all.
06:52:53 <ph88> how would the higher order function look like ?
06:52:54 <Gurkenglas> These higher-order functions would in this case turn out to be a manual passing around of "typeclass" dictionaries, right?
06:53:52 <ph88> well you see for each type i would like to have 1 pretty printer, 1 generator and 1 or 2 parsers, and then later i probably need a bunch more functionality on the same types
06:54:48 <mbw> To be honest, when creating my own higher-order functions, I try to program with a squinted eye and let the compiler infer a type first. If it's overly complicated and the function has like 10 arguments, it's probably not a good approach.
06:55:43 <mbw> In your example, it's three monadic actions which you can pack inside a data type
06:56:11 <mbw> Though I only saw what you pasted erlier.
06:56:15 <ph88> with higher order functions ?
06:56:17 <mbw> Üearlier
06:58:19 <ph88> oh i think i know what you mean, i pass around the functions that make it a monad  so for example   pure (T.singleton char)   to make a generator for a single character and  T.singleton <$> M.char char  to make a parser for a single character
06:58:24 <StarsC> @help
06:58:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:58:44 <StarsC> @help list
06:58:45 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:58:49 <catern> hey #haskell
06:58:53 <StarsC> @help pointfree
06:58:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:58:53 <ph88> hai
06:59:11 <ph88> StarsC, you mind send a query to lambdabot directly?  /query lambdabot 
06:59:42 <ph88> mbw, how do you decide whether to use higher order functions or typeclasses ?
06:59:44 <catern> is it accurate to say that in Haskell, I can load untrusted extensions/code into my program, into the same process/address space, and be assured that it can't do anything malicious not contained in its type signature?
07:00:04 <StarsC> @pl (f x = if (even x) then x else (2*x))
07:00:04 <lambdabot> (line 1, column 7):
07:00:04 <lambdabot> unexpected " "
07:00:05 <lambdabot> expecting operator
07:00:05 <catern> because of type safety?
07:00:06 <ph88> tbh i feel like typeclasses are a good fit here but i can't explain why
07:01:21 <ph88> catern, don't think haskell provides a sandbox for untrusted binary code
07:01:58 <catern> sure but that's not what I mean, if I have some untrusted Haskell code meeting an interface and I use GHC to compile/link it into my program, is it safe?
07:02:19 <StarsC> @pl \x -> if (even x) then x else (2*x)
07:02:19 <lambdabot> ap (if' =<< even) (2 *)
07:02:25 <StarsC> what is this if'??
07:04:19 <Gurkenglas> If you're zipping that list with [1..], try zipWith (*) (cycle [1,2])
07:05:04 <Gurkenglas> if' is just a Bool combinator that @pl introduces because if-then-else isn't pointless
07:06:05 <Gurkenglas> "if' <$> even <*> id <*> (2*)"
07:06:20 <StarsC> so there is no way to make it point free?
07:08:59 <StarsC> Gurkenglas: ^
07:09:54 <Gurkenglas> Data.Bool introduces bool which is if' but with arguments swapped around
07:10:13 <Gurkenglas> :t bool <$> (2*) <*> id <*> even
07:10:15 <lambdabot> Integral b => b -> b
07:10:27 <Gurkenglas> > map (bool <$> (2*) <*> id <*> even) [1..6]
07:10:31 <lambdabot>  [2,2,6,4,10,6]
07:11:58 <StarsC> Gurkenglas: ty!
07:16:32 <phz_> hey, I’d like to update a dependencies using stack install; how shall I do that?
07:26:42 <codedmart> Is there already a function for going from `IO [Either String SomeData]` -> `IO (Either String [SomeData])`?
07:28:34 <codedmart> Nevermind I see.
07:28:57 <niklasb> codedmart: fmap (mapM id)
07:29:23 <pavonia> @pl mapM id
07:29:23 <lambdabot> mapM id
07:29:24 <niklasb> fmap sequence
07:30:07 <niklasb> :t fmap sequence 
07:30:09 <lambdabot> (Traversable t, Functor f, Monad m) => f (t (m a)) -> f (m (t a))
07:30:16 <niklasb> yeah that should work
07:30:40 <pavonia> :t mapM id
07:30:42 <lambdabot> (Traversable t, Monad m) => t (m b) -> m (t b)
07:30:56 <niklasb> pavonia: it's the same as sequence
07:31:15 <pavonia> Yeah, @pl doesn't seem to be up to date
07:31:40 <daisy> what is a haskell?
07:32:30 <suppi> daisy: www.haskell-lang.org :)
07:33:00 <phz_> no one for the stack stuff? :(
07:35:50 <Geekingfrog> phz_ a dependency inside a project ?
07:35:54 <phz_> yeah
07:36:00 <phz_> I juste updated the upper bound
07:36:05 <phz_> now I want to use the latest version
07:36:11 <Tuplanolla> Change your resolver, phz_?
07:36:12 <phz_> but it’s already installed as the old one
07:36:23 <phz_> ah
07:36:34 <phz_> it’s for a new stackage lts stuff
07:36:45 <phz_> I guess I have to add it the extra-deps then?
07:37:27 <Gurkenglas> pavonia, mapM id is already pointfree
07:37:28 <Geekingfrog> Yes, if you update the version there it should automatically install the new one
07:37:45 <Gurkenglas> How do I fill in the "???"s on http://lpaste.net/351259 ?
07:38:21 <niklasb> Gurkenglas: have you tried just putting an _ there or Int?
07:38:26 <niklasb> ghc should now
07:38:28 <niklasb> *know
07:44:58 <pavonia> Gurkenglas: Sure, but @pl is also doing some optimizations
07:45:24 <pavonia> @pl flip . flip
07:45:24 <lambdabot> id
08:12:32 <mbw> ph88: Sorry I had to leave for a while. Personally I think if I would like to capture an algorithmic skeleton, I would use a higher order function, since it's very flexible. You could also take lists of functions/actions and arguments and sequence/traverse as you see fit. It probably boils down to personal taste. I am conservative about creating typeclasses, since when you look at what things like Functor, 
08:12:38 <mbw> Monad, Foldable etc. provide in terms of abstraction and how hard it would be to come up these things yourself (think laws for example), there's probably much room for making mistakes.
08:14:21 <contiver> Hi there. I'm currently using attoparsec, but I'm looking for another parser library that uses Text and has good diagnostics. I thought about trifecta, but it seems it is not so simple to use Text with it. Anybody got any recommendations?
08:14:58 <Rembane> contiver: What's your use case?
08:15:11 <contiver> a css parser.
08:15:12 <mbw> In oop languages, people often used the class approach for implementing algorithmic skeletons, because it wasn't until lambda abstractions came along that you could implement it like that and you would have to use function objects, which was by far less elegant.
08:15:31 <contiver> I need to deal with utf-8
08:15:44 <niklasb> contiver: parsec?
08:15:45 <Rembane> contiver: Use parsec. It handles Text.
08:16:19 <mbw> I would also like to restate a question I asked earlier.
08:16:46 <contiver> niklasb, Rembane: how is the performance with parsec? and does it support monad transformers?
08:17:21 <niklasb> contiver: well there is ParsecT. not sure about perf, I think that's one of the issues that attoparsec is trying to solve
08:17:24 <Rembane> contiver: How much performance do you need and why?
08:17:27 <mbw> Is there some formal classification of computational effects? Like static effects (Applicatives) and dynamic effects (Monads), commutative (Maybe/Reader), non-commutative (Writer,State) etc.?
08:18:02 <contiver> Rembane: I'd say not that much, was just wondering.
08:22:31 <Rembane> contiver: It's generally good enough, but if you need something really fast, use attoparsec. On the other and attoparsec sacrifices a lot on the altar of performance.
08:22:49 <Rembane> contiver: ...and is generally designed to parse network protocols and other byte-centric things.
08:23:25 <contiver> Rembane: the problem is I already did everything in attoparsec, and although it works, I'd really like some better diagnostics, so I'm trying to see which other library to use.
08:24:14 <contiver> Rembane, I'm asking around gathering opinions because porting everything to use another library will take a couple of hours, so I'd prefer using the right one from start.
08:24:48 <Rembane> contiver: I see. I'd use Parsec, it's a good library.
08:34:00 <Tuplanolla> If you're looking for good error messages, Trifecta or Megaparsec should be the way to go, contiver.
08:34:56 <contiver> Tuplanolla, I'd love to use trifecta, but it doesn't support Text (at least that's the idea I got after going through the docs and a repository issue).
08:35:49 <contiver> Tuplanolla, particularly, based on this: https://github.com/ekmett/trifecta/issues/51
08:42:54 <Tuplanolla> There's Earley too, but I haven't touched it, contiver.
08:44:25 <contiver> Tuplanolla, I'll probably end up with megaparsec based on what I've read and been told so far. Thanks for the input :)
08:44:56 <Tuplanolla> That's the one I mostly use as well, contiver.
08:46:21 <ertes> is there a ready-made library for rings with multiplicative inverses?  i need something like:  recipMaybe :: (RingInverses a) => a -> Maybe a
08:47:58 <ertes> contiver: you could use trifecta with UTF-8
08:48:14 <theduke> how can I get an existential type to implement Show? || class (Show a) => Cls a ... | data ClsInst = forall a. Cls a => ClsInst a 
08:48:20 <contiver> ertes, with ByteString?
08:48:25 <ertes> contiver: yeah
08:49:21 <ertes> theduke: the way you've written it you can't implement a Show instance that can show the inner 'a'
08:49:34 <contiver> ertes: I've never used ByteString, I'm dealing with human-readable input (css), would it be advisable to change everything from Text to ByteString?
08:49:43 <ertes> theduke: ah, you can…  my bad
08:50:24 <ertes> contiver: no, just encode to UTF-8 (Data.Text.[Lazy.]Encoding) just before feeding it to the parser
08:51:31 <theduke> ertes: and ... how? ^^
08:55:20 <ertes> contiver: https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
08:55:23 <ertes> see 'encodeUtf8'
08:56:53 <contiver> ertes, I'll take a look, thanks
08:56:57 <jfelice> How does one time a function these days?
08:57:19 <jfelice> criterion?
08:57:25 <ertes> jfelice: yep
09:01:48 <theduke> ertes: ah well, instance Show ClsInst where show = Prelude.show 
09:02:00 <theduke> that was easy enough...
09:02:09 <pie_> this isnt the place to ask but i dont have any better ideas, anyone know how to read a google groups mailing list from thunderbird? :P
09:05:14 <Tuplanolla> I expect not reading Google Groups to be the more pleasant option of the two, pie_.
09:06:21 <pie_> meh, i wish idris didnt use google groups. apparently they used something else a while back because gmane has up to 2014 :I
09:07:24 <xnull> How did Google Groups settle into the state it's in today? 
09:07:35 <xnull> I'm more scared of it than onion sites. 
09:07:51 <pie_> xnull, what, why? xD
09:22:51 <sangy> I already [search-engine-verb] around and found a couple of tutorials on the haskell, but I wanted to know if there are any "community endorsed" ones. 
09:26:31 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html is supposed to be pretty good
09:27:44 <Cale> sangy: If you wouldn't mind a dead tree book, perhaps check out Graham Hutton's "Programming in Haskell"
09:28:01 <sangy> Cale: thanks! I'll take a look at both :)
09:30:02 <ddellacosta> I guess it's not a good way to get started but good to file away for later--his explorations of folds, for example, are great
09:31:18 <ddellacosta> oh not sure if my previous comment showed up: sangy: Graham Hutton's got a ton of great papers up here too: http://www.cs.nott.ac.uk/~pszgmh/bib.html
09:31:53 <ertes> theduke: that's a bad way to define a Show instance
09:32:01 <ertes> theduke: always define it in terms of showsPrec
09:32:14 <sangy> ddellacosta: thanks! I'll bookmark this then :)
09:33:21 <ddellacosta> sangy: yeah, I learned a lot from Graham Hutton's work. Also if you are into MOOCs I found this one helpful: https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0
09:33:45 <ddellacosta> it is ostensibly about functional programming in the large, but is very much an Intro to Haskell in many ways
09:34:25 <theduke> is there a way to use Text.Regex.PCRE with Data.Text without converting?
10:02:44 <DirtyAxe> Hey
10:16:07 <cocreature> theduke: you can use Text.Regex.PCRE.Heavy from the pcre-heavy package but that will just convert internally
10:16:12 <cocreature> hey DirtyAxe 
10:29:20 <Benzi-Junior> hey I have a question regarding Unboxed types 
10:29:41 <Benzi-Junior> on the wiki it says that these are raw values of kind #
10:31:12 <Benzi-Junior> yet in the vector library there are a number of instances declared such as (Unbox a, Unbox b) => Unbox (a,b) 
10:32:11 <Benzi-Junior> which as far as I can tell is of kind * -> * -> *
10:32:34 <Benzi-Junior> I feel like I'm missing something
10:32:46 <glguy> The Unbox class has instances that have the ability to be stored unboxed into the vector
10:32:56 <glguy> It's not types that "are unboxed" but that "can be unboxed"
10:33:16 <glguy> An 'Int' can be stored in the vector as an 'Int#'
10:33:22 <glguy> but you never deal with the Int# yourself while using that vector
10:35:58 <Benzi-Junior> so (Int,Int) can be unboxed to (Int#,Int#)
10:39:44 <mheinzel> I have a tail-recursive function, where my accumulator is an Int. Do I need to force it with every iteration? I thought so, but see no difference in performance.
10:40:15 <cocreature> Benzi-Junior: it looks like it vector unboxes a pair (a,b) by using two vectors and for each of them it uses the unboxed representation of a or b
10:40:35 <cocreature> Benzi-Junior: the source is here I think https://github.com/haskell/vector/blob/49396e1e54084ce9fd3982b99030ca316ad05856/internal/unbox-tuple-instances#L2
10:40:41 <davean> cocreature: yah
10:41:43 <davean> Theres also hybrid-vectors
10:42:09 <Lokathor> sangy, http://haskellbook.com/ if no one said it yet
10:42:10 <hexagoxel> Benzi-Junior: logically it would be (#Int#, Int##) even, unboxed tuples. but what cocreature said.
10:42:24 <sangy> Lokathor: I dno't think so, thanks!
10:43:33 <davean> mheinzel: Many strictnesses are infered, and performance isn't so bad when it isn't forced. Additionally the read threat is overflow
10:44:53 <cocreature> mheinzel: it could also be the case that you force it for some reason, e.g. your basecase depends on the accumulator so it is evaluated in each step
10:44:54 <mheinzel> davean: I don't see increased memory usage... It seems to be inferred.
10:45:09 <geekosaur> mheinzel, aside from tail recursion being a dubious concept when evaluation is by graph reduction, often the compiler can determine strictness itself. in general you don't throw strictness annotations around willy-nilly, if you actually have performance or heap size issues you check the generated core (ghc-core or dump-core packages are easiest for this) and add them where needed
10:46:07 <davean> though after a moderate amount of experience one might not need to do such and would know what the compiler would probably do
10:46:53 <mheinzel> Okay, thank you.
10:47:59 <davean> mheinzel: after a moderate amount of experience though you'll probably have forgotten you ever care as you find that in practice you never actually have performance issues
10:49:30 <mheinzel> davean: Yes, I very rarely needed it. Just wanted to make sure I don't tell something wrong (it's in a teaching context).
10:49:34 <davean> (of course eventually after that you might wonder how anyone ever lived without MutVar# but thats different ...)
10:52:39 <plotnus> quit
10:57:02 * pharaun gives out /
10:57:38 <hexagoxel> /quit
11:04:30 <mbw> I am currently working on a simple stack project involving a typeclass hierarchy and some tests. However I don't think I got it quite right. While it compiles and runs, the plugins I use for vim (ghcmod-vim, syntastic, neco-ghc and haskellmode, I think) seem to require some specific project layout if I recall correctly. Also I don't know if the cabal file corresponds well to my project layout or if my 
11:04:36 <mbw> distribution of properties to test (modules inside src) and the tests themselves make sense.
11:05:09 <mbw> Does anybody have some experience in that regard?
11:05:14 <mbw> http://lpaste.net/7211747696304979968
11:05:48 <mbw> Any pointers would be appreciated (though not of the 0x... kind)
11:06:37 <cocreature> mbw: looks reasonable
11:07:30 <mbw> It's just that vim autocompletion works only inside the src directory, and not inside the test directory, which led me to believe there's something off.
11:08:07 <mbw> And of course I don't know if it's a plugin compatibility problem or something more subtle that has to do with the project layout.
11:16:36 <implementation_> can someone recommend a nice library for working with quaternions?
11:20:00 <ssd> @pl (subtract 1) . product . map (1+) . map (2 ^)
11:20:01 <lambdabot> subtract 1 . product . map ((1 +) . (2 ^))
11:20:58 <ssd> @pl print . (subtract 1) . product . map ((1+) . (2 ^)) $ map (read :: String -> Integer) . words
11:20:58 <lambdabot> (line 1, column 77):
11:20:58 <lambdabot> unexpected '>'
11:20:58 <lambdabot> expecting operator
11:21:24 <ssd> @pl print . (subtract 1) . product . map ((1+) . (2 ^)) $ map read . words
11:21:25 <lambdabot> print (product (map ((1 +) . (2 ^)) (map read . words)) - 1)
11:21:47 <ssd> @pl  product . map ((1+) . (2 ^)) $ map read . words
11:21:48 <lambdabot> product (map ((1 +) . (2 ^)) (map read . words))
11:21:56 <ssd> @pl  product . map ((1+) . (2 ^)) . map read . words
11:21:57 <lambdabot> product . map ((1 +) . (2 ^)) . map read . words
11:22:12 <nanoz> any mod here
11:22:33 <monochrom> yes?
11:25:35 <hpc> implementation_: if you want to do it the traditional way, pick a matrix library
11:25:55 <hpc> i couldn't tell you what's considered better than that though
11:26:37 <nanoz> hi monochrom are you mod here ?
11:26:42 <monochrom> yes
11:27:15 <nanoz> i've lost my way on solving a problem hope you can help me on it
11:28:12 <monochrom> That qualifies as "calling the name of a mod in vain".
11:32:30 <geekosaur> um, we're social moderators, not TAs
11:33:21 <hpc> nonsense, you rule all of computer science
11:33:30 <hpc> i read about this on wikipedia, you're the church of encoding
11:33:50 <implementation_> hpc: thanks, I'll have a look at it
11:40:19 <Squarism> is it ghc 8 or a new version of cabal that lets you have different "executables" per project?
11:41:28 <geekosaur> hm? neither cabal (unless you mean new-build) nor ghc does "project". multiple executables per cabal file has been around pretty much from the original cabal-install
11:41:37 <geekosaur> (it's multiple *libraries* that is not supported)
11:53:16 <ph88> when i make a typeclass can i supply a default implementation ?
11:53:45 <mheinzel> ph88: Yes.
11:53:57 <ph88> oh that's good
11:54:02 <mbw> Does anyone here use vim with hdevtools?
11:54:06 <mheinzel> Just specify it below the type signature.
11:55:18 <ph88> thx
11:55:48 <sternenseemann> ph88: see https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html
11:56:34 <ph88> yeah i was planning to use generic functions
11:57:25 <sternenseemann> ph88: https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html#g:13
11:58:31 <ph88> what does the doc mean by this:  We need the 'default encode' signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.
11:59:02 <ph88> maybe to prevent needing a generic instance for all a's ?
12:00:08 <geekosaur> yes, otherwise you'd need to specify Generic as a prerequisite class for all instances if you tried to use Generic in the default method
12:00:27 <geekosaur> which is kinda overkill
12:00:41 <Athas> Finally!  I am ditching GHC 7.8 support in my code.
12:01:25 <monochrom> Will you add 8.2 support soon? :)
12:02:10 <mbw> I get the feeling nobody actually uses Vim in here...
12:02:25 * xnool does
12:02:25 <monochrom> Many vim users here.
12:02:39 <xnool> vim + tmux is my universal dev setup
12:03:43 <Rembane> 7me uses vim
12:03:43 <xnool> they made me use emacs at 21st century fox though... 
12:04:07 <Aruro> has evil mode though
12:04:19 <mbw> What plugins do you use? I am really struggling with vim+stack and believe a lot of stuff you find online (blog posts, stackoverflow questions, ...) is outdated.
12:04:22 <hpc> for me, emacs is exclusively an agda ide
12:04:39 <Rembane> mbw: gitgutter
12:05:03 <xnool> mbw: absolutely nothing. 
12:05:09 <xnool> just a syntax highlighter
12:05:22 <xnool> note, however, that i also forage my own berries
12:06:20 <mbw> I was feeling comfortable before I made use of stack, so maybe that's the problem...
12:06:55 <Aruro> byorgey: is it possible to put course materials from your recent course in one file? :)
12:10:08 <mbw> xnool: How does your workflow look like? Do you have a seperate ghci window open?
12:10:16 <xnool> yes
12:10:41 <xnool> vim, ghci, an empty shell in the same tmux window filling one monitor
12:10:48 <xnool> the other has a web browser
12:11:06 <mbw> You must have sharp eyes then.
12:11:20 <xnool> 10pt terminus
12:11:26 <xnool> err 10px
12:11:34 <Aruro> wow
12:11:59 <xnool> mbw: i shave with them
12:12:01 <Aruro> why not smaller?
12:12:16 <xnool> Aruro: it's been so long since i checked. does terminus have 8px?
12:12:49 <pitcomplete_> Hi, I've got next to none understanding of Haskell, but guys at #fsharp are not very talkative and I am looking for a pure functional solutions so this seems like a better place to ask anyway...
12:12:54 <pitcomplete_> I've got a heavily nested record and want to build it up over a series of instructions.
12:13:01 <pitcomplete_> One solution would be to use maybe monad with Nothing for (sub)parts that are not yet available
12:13:11 <pitcomplete_> In F# this would be something like that:  { part1 = None; part2 = { subPart1 = Some <subPart>; subPart2 = None }; ...}
12:13:23 <pitcomplete_> This makes it cumbersome to use the record later on though. 
12:13:23 <pitcomplete_> I was thinking about a State Monad, but the state type here seems to be changing (partial functions with different number of args at different times)
12:13:38 <pitcomplete_> any idea how to solve this elegantly?
12:14:06 <mbw> Can you use cabal only and still use the newest ghc etc. without having to install manually or rely on well-mainted distro repos?
12:14:37 <Aruro> works fine on arch with ghc 8
12:14:56 <sternenseemann> mbw: i do, but shitty haskell setup tbh
12:15:37 <Rotaerk> pitcomplete_, why do you want to build it up over several instructions rather than all at once
12:16:38 <mbw> Wait sorry I seem to have phrased it wrong. I was wondering if you can for example install cabal once via the package manager, and then use update/upgrade to keep ghc and packages up to data?
12:16:42 <mbw> *date
12:17:28 <mbw> I found cabal harder to use than stack, but stack kind of stands in my way regarding my vim "workflow"
12:18:01 <niklasb>  mbw what part of your vim workflow
12:19:02 <kadoban> mbw: As far as I know, cabal-install doesn't help you install ghc in any way, so no.
12:19:53 <pitcomplete_> Rotaerk, because parts of it are available at different times. f.e. constructing partA happens over a timespan of a minute and constructing partB is interweaved within that 
12:20:10 <mbw> I use vim with syntastic, hlint, hdevtools || ghc-mod. With a stack-installed ghc, error high-lighting doesn't work with ghcmod, but it does with hdevtools. But hdevtools doesn't allow automatic pattern expansion, insertion of types and the like. Also autocompletion via ctrl+space only works for some modules and doesn't when nesting is involved, I get the feel.
12:20:19 <pitcomplete_> as data comes I can fill parts of it. I sort of want to define the "recipe" of constructing the record upfront and then run the interweaving filling of the record
12:20:55 <kadoban> mbw: Personally I abandoned ghc-mod and hdevtools, they're too hard to get and keep working, ended up spending more time on that than they saved.
12:21:15 <mbw> Everything worked fine with the distro-provided stuff, but that's not bleeding-edge and cool...
12:21:28 <Rotaerk> pitcomplete_, one thing that comes to mind is monoids
12:21:35 <Rotaerk> you familiar with the abstraction?
12:21:43 <pitcomplete_> I want to functionally control the state but the state is nested and complex
12:21:54 <pitcomplete_> I know it in math :)
12:22:07 <mbw> kadoban: So how do you do it then?
12:22:50 <kadoban> Do what? I just use vim and stack and ghci and not a lot else. I have hlint and syntastic and non-language-specific completion, but not much of it is really haskell specific.
12:23:20 <Rotaerk> pitcomplete_, a type for which there is an "empty" value (mempty in haskell), and a way of combining two values into one (mappend).  there's also mconcat which takes a list of values and combines them into one, defined in terms of mempty and mappend by default
12:23:40 <mbw> And when you're inside a stack project, autocompletion works with project-local modules?
12:24:16 <kadoban> I don't use that type of autocompletion. I use snippets and the kind of autocomplete that just autocompletes what I've typed already.
12:24:17 <mbw> Like when you type "import P+ctrl+space", will it show project local modules?
12:24:32 <Rotaerk> pitcomplete_, say you have a type like { x :: Maybe X, y :: Maybe Y }
12:24:40 <mbw> Or "import Somemodule (+ctrl+space", will it show the modules contents?
12:24:54 <Rotaerk> you can define mempty for it to be:  { x = Nothing, y = Nothing }
12:25:22 <mbw> So how do you keep track of what's where?
12:25:32 <tsahyt> Hello! I'm working on a small pastebin using servant (0.8.1) for fun. I have an endpoint type Paste = "paste" :> ReqBody '[PlainText] Text :> Post '[PlainText] URL, and a server etc for it. but when testing I can't reach the endpoint using curl. This is what I've been trying: curl -X POST -d "test" -H "Content-type: text/plain" localhost:8081/paste/
12:25:58 <tsahyt> I'm unsure what I'm doing wrong here. I have put a print into the handler for tracing to make sure that it's being called, but it isn't showing up
12:25:59 <mbw> I quickly get lost when the project gets a little larger, say it's split over 3-4 *.hs files or so.
12:26:50 <pitcomplete_> Rotaerk, but I am trying to avoid using maybe monad in the record itself, because after it is constructed I want to use it simply 
12:27:01 <Rotaerk> pitcomplete_, and mappend to be:  mappend left right = { x = mappend (x left) (x right), y = mappend (y left) (y right) }
12:27:30 <Rotaerk> then the thing that produces the x would just return mempty { x = Just myX }
12:27:39 <Rotaerk> and so on for the y, and then you just mappend the results
12:28:16 <Rotaerk> pitcomplete_, okay, but how would you represent an incomplete data structure without Maybe?
12:28:34 <Rotaerk> unless the types of your fields are, themselves, monoids, that is
12:28:40 <hexagoxel> pitcomplete_: i use a data structure with a type parameter of kind (* -> *) for a somewhat similar usecase. The parameter is Maybe during construction, but then mapped to Identity. So i have flexibility of Maybe at start, the relatively easy use of Identity later on, and still only have one structure.
12:29:28 <Rotaerk> F#, the language he's using, doesn't support higher-kinded types, unfortunately
12:30:20 <ongy> would things break if we had a type of kind (* -> *) that's closer to id? so (T A) ~ A?
12:30:26 <mbw> Ok, an entirely different question then. Is it possible in Haskell to have nested modules without putting them into subdirectories?
12:30:33 <pitcomplete_> Rotaerk, I thought that there's some monad already for this type of thing since monad can be thought of as recipes (often involving complex compositions) for constructing some type 
12:30:51 <hexagoxel> pitcomplete_, Rotaerk welp nevermind then.
12:31:03 <Rotaerk> should just abandon F# *cough*
12:31:03 <hexagoxel> ongy: like Identity?
12:31:21 <ongy> Identity adds a wrapper I have to add syntax around unwrapping
12:31:25 <Rotaerk> you can't come into #haskell and *not* expect to be tainted (or rather, purified?) by it
12:31:36 <pitcomplete_> hehe
12:32:18 <pitcomplete_> I am dipping my toes in pureness but I am not prepared to jump into the water yet ;)
12:32:26 <Rotaerk> pitcomplete_, the question right now is not *how* to construct the type, but how the intermediate values of that type should look
12:32:26 <xnool> I... I just wish haskell flipped the names of cons and hastype
12:32:37 <xnool> That would satisfy my primal urges
12:32:45 <Rotaerk> if it shouldn't contain Maybes, then how should it look when something is not yet set
12:32:52 <tsahyt> the server returns 415 Unsupported Media Type, but I'm setting the content-type
12:34:29 <pitcomplete_> Rotaerk, yes exactly. this seems to be a type that could be represented as a set of partial functions with different set of parameters at different stages in the computation
12:34:38 <tsahyt> oh apparently it *needs* to be charset=utf-8
12:35:20 <Rotaerk> pitcomplete_, it would result in extra boilerplate, but you can use one with Maybes for intermediate results, then convert to an equivalent type, minus the Maybes, at the end; the brute force approach...
12:35:46 <Rotaerk> I think that's what hexagoxel's suggestion would do, but without the boilerplate
12:35:50 <Rotaerk> but you can't do that in F#
12:35:52 <pitcomplete_> yes, that's exactly what I want to avoid because the hierarchy in this record is pretty deep
12:36:13 <ph88> monochrom, ghc 8.2 is already on the horizon ?
12:36:14 <pitcomplete_> I would need to maintain two hierarchies and map between them
12:36:29 <monochrom> No, I was joking.
12:36:38 <Rotaerk> pitcomplete_, is there any chance that one of the fields would fail to be set?
12:36:59 <pitcomplete_> no
12:39:09 <Rotaerk> pitcomplete_, what about something like this:  do { xTask <- async getX; yTask = async getY; x <- xTask; y <- yTask; return { X = x, Y = y }; }
12:40:13 <Rotaerk> I'm assuming here that the values for your fields are being determined by parallel asynchronous tasks though
12:40:21 <Rotaerk> concurrent *
12:41:51 <hexagoxel> Rotaerk: is that like futures already? because it seems to head in that direction.
12:42:09 <Rotaerk> it's just based on https://hackage.haskell.org/package/async-2.1.1/docs/Control-Concurrent-Async.html
12:44:17 <EvanR_> a future is a data type, a functor, applicative etc, which has to be explicitly forced
12:44:35 <EvanR_> but it could be a value which only gets forced when evaluated
12:45:35 <EvanR_> or blocks if its not done evaluating
12:45:47 <tnks> I'm still working on my mental model of GHC's runtime; here's a question I have:  if I mark an FFI call "safe" and use it with -threaded, then how different is that from marking it "unsafe" (still using -threaded) and using forkOS?
12:46:14 <pitcomplete_> Rotaerk, I'll think about it. In the back of my mind I already was considering Futures.
12:46:29 <ph88> i would like to use megaparsec 5.1 with stack, but stack gives me version 5.0.1 is there anything i can do to start using version 5.1 ?
12:46:30 <pitcomplete_> maybe this will work
12:47:07 <niklasb> ph88: yeah you can specify a different version in extra_deps in your stack.yaml
12:47:14 <ph88> oki
12:48:25 <ph88> does that except wildcards such as 5.1.*  ? or must i specify a specific version ?
12:48:47 <ph88> hhmm well for sure that aint working
12:49:09 <niklasb> ph88: I've never tried
12:49:16 <niklasb> maybe just 5.1?
12:49:16 <ph88> oki
12:49:25 <ph88> that was the first thing i tried ^^
12:49:27 <niklasb> I've only ever specified single versions
12:49:35 <ph88> alright np
12:49:42 <ph88> i'll just take the latest then for the moment
12:51:04 <geekosaur> ph88, re 8.2 it is in fact on the horizon, as in code freeze planned for next month
12:51:24 <ph88> oh that's nice :)
12:51:43 <ph88> i'm happily surprised they are still putting good new features in
12:52:01 <c_wraith> The new features are just getting more ambitious.
12:52:28 <c_wraith> With -XDependentHaskell in process, and expected to land sometime between 8.4 and 8.8
12:52:36 <geekosaur> tnks, "unsafe" just calls it, which takes that capability out of service while it's running and doesn't arrange for it to be able to call back into Haskell.
12:53:05 <tnks> geekosaur: yeah, I've got an FFI dependency that's declared almost everything "unsafe"
12:53:06 <geekosaur> (and if it does then it will likely get you "Scheduler entered unsafely!" panic)
12:53:09 <EvanR> it wasnt long ago when channel concensus was "haskell will never have dependent types"
12:53:26 <tnks> so I'm reading this in the docs for `forkOS`:  It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case.
12:53:39 <c_wraith> It'll still never have a termination checker!  (take that, contrary universe!)
12:53:53 <geekosaur> tnks, also forkOS does not get you a dedicated thread, it just ensures that that Haskell thread will always run on the same OS thread
12:54:04 <tnks> but that statement only says that you "don't need to use forkOS"... it doesn't quite answer whether you can or not.
12:54:09 <EvanR> "GHC 8.9 on schedule for having a termination checker"
12:54:22 <tnks> geekosaur: okay, that's what I was thinking.
12:54:36 <EvanR> 8.14 will solve the halting problem
12:54:48 <tnks> geekosaur: so there's no great way to "safe-ify" an unsafe import, right?
12:54:49 <Rembane> The bright future is here.
12:55:29 <davean> EvanR: I thought solving the halting problem would allow a major version bump
12:55:41 <geekosaur> tnks, differet code is generated for safe vs. unsafe calls, you can;t really change that at runtime
12:56:09 <tnks> geekosaur: well, I was hoping to change it at compile time, but as a consumer of the library.
12:56:26 <tnks> but it's also fine to just do the FFI again on my side and build up what I need.
12:56:46 <EvanR> woe be to any consumer of a library who has to understand FFI import semantics
12:56:47 <tnks> eventually submitting patches upstream if I prove it's a good idea.
12:57:10 <tnks> EvanR: I think that's eventually everyone, though, right?
12:57:26 <EvanR> usually you have "bindings" which "just works"
12:57:30 <tnks> I mean Haskell has a lot of libraries, but at some point, you have to bind to C for some interesting things.
12:57:53 <tnks> EvanR: hmm, at least for Kafka, I found it might more satisfying to "trust but verify"
12:58:36 <EvanR> ive found theres usually a right answer for whether you need to import safe or unsafe, and the final end user probably shouldnt be the one to figure that out, for a given thing youre binding to
12:58:55 <davean> tnks: Not many people deal with FFI ever
12:59:17 <davean> EvanR: The only case of there really being options on safe vs. unsafe I think of is hblas
12:59:29 <davean> either a call is safe or it isn't
12:59:46 <EvanR> except in hblas?
13:00:02 <davean> EvanR: hblas changes based on how large the computation is
13:00:20 <ph88> i have a data type called Terminal which holds a value Text, i have a quickcheck instance for it but i put the minimal implementation of arbitrary on undefined because i have a bunch of separate functions then yield Gen Text  depending on the context. Is this bad to leave arbitrary on undefined ?
13:00:23 <davean> EvanR: it estimates the runtime and sometimes decide it can run the call safely instead of using the unsafe call
13:00:33 <tnks> I don't know, Kafka is mostly non-blocking calls, so they decided on "unsafe" as a default.
13:00:46 <davean> EvanR: I think the class of cases where there is an estimatable time like that is probably rare
13:00:52 <tnks> but there's some callbacks, and also some calls that block.
13:01:02 <EvanR> what does time have to do with safety
13:01:32 <davean> EvanR: starvation
13:01:57 <Rotaerk> well everyone dies in time, starvation aside
13:02:12 <EvanR> are we talking non -threaded, everything in the world blocks
13:02:29 <xnool> EvanR: In business settings computers have P probability over span of time T in which the machine may randomly have a bit flipped due to unexpected quantum phenomena
13:02:36 <tnks> for the sake of this discussion, can we please assuming -threaded?
13:02:42 <EvanR> o_O
13:02:46 <pharaun> kafka sounds kafkaesque
13:03:11 <EvanR> business and quantum in the same sentence
13:03:19 <xnool> Intel did it first
13:03:27 <xnool> Wait, no, that's Pentium
13:04:42 <geekosaur> one of the shipping/logistics companies did it first :)
13:06:00 <tnks> anyway, my rule of thumb as been:  if a foreign call blocks for enough time to affect responsiveness, it should probably be "safe"; and it needs to be "safe" if it invokes Haskell-side callbacks
13:06:10 <tnks> is that flawed?
13:07:01 <geekosaur> tnks, additional consideration is memory allocation should be safe as well, because Haskell runtime allocates heap chunks from C's heap
13:07:02 <EvanR> going by the names safe and unsafe, i would look for a rule for when its ok, rather than imperative to use unsafe, otherwise always use safe
13:07:22 <abhiroop> Blogpost targeted towards beginners explaining the power set function in Haskell: https://abhiroop.github.io/Haskell-Powerset/ Building on Brent Yorgey's https://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/ to explain the function in more detail.
13:07:51 <tnks> geekosaur: good point.
13:07:52 <geekosaur> also should be "blocks at all" / "if it makes a syscall it should be done safe since it will affect thread scheduling"
13:08:26 <EvanR> so, use case for unsafe is when condition X is satisfied, and you want to have more performance?
13:09:30 <geekosaur> my usual rule is that you can get away with unsafe if the function is pure (outputs depend deterministically on inputs; remember that for pointer values, it is the pointer itself that matters and not what is pointed to!) and neither allocates nor makes system calls
13:09:41 <geekosaur> otherwise, play it safe
13:10:07 <EvanR> what about pointers? if the result is a pointer that doesnt count as pure?
13:10:47 <EvanR> makes sense
13:10:48 <tnks> geekosaur: then librdkafka is making syscalls all over the place for every call -- but it's imported "unsafe" in haskakafka (and other bindings, I'd guess)
13:11:04 <geekosaur> the thing about pointers is you have lots of C APIs that return a static pointer: the result value is effectively constant but the values on the other end of the pointer change
13:11:22 <geekosaur> which means it is impure
13:11:46 <geekosaur> because something changed that was not a parameter value or a result value, but something designated by one of them
13:12:05 <tnks> "safety" in the FFI sense if different from "purity" in the IO sense, though, right?
13:12:08 <EvanR> if the pointed-to thing changes, that seems fine
13:12:19 <EvanR> its like IORef
13:13:30 <geekosaur> well. the problem here is that the ffi stuff conflates too many things into "safe"/"unsafe"
13:13:50 <tnks> yean, I agree.
13:14:25 <tnks> but one point I'd like to understand is the observed problems from marking a syscall'ing C function as "unsafe" (in the FFI sense)
13:14:32 <geekosaur> I *really* wish they;d separated it out, but they wanted to not add keywords to the FFI spec when they expanded it to cover things like threading which introduces a lot of the complexity
13:15:34 <davean> I really wish they a lot of things
13:15:44 <tnks> actually, in the case of Kafka, I think most of the syscalls are happening in isolated threads on the C side.
13:16:00 <hpc> you could probably come up with a general notion of safety
13:16:15 <tnks> most of the calls, I think are just loading requests onto in-memory queues.
13:16:29 <hpc> based on the property of preserving other properties
13:16:50 <hpc> which could make it easier to remember what the ffi keywords mean
13:16:54 <EvanR> earthbound 3 "absolutely safe capsule"
13:17:27 <davean> Honestly a lot of the lower level stuff is just terribly documented.
13:18:05 <geekosaur> yes
13:18:07 <tnks> anyway, this conversation has been helpful.
13:18:15 <EvanR> a general notion of safety would be interesting / scary... and it would be an at least 3rd form of "safe" in haskell already
13:18:32 <geekosaur> much of what I know about the FFI stuff --- which is no everyhting, not by a long shot --- is from code diving in the runtime
13:18:46 <hpc> it would have some nice applications in -XSafe though
13:18:51 <Athas> monochrom: I hope!  GHC 8.2 is supposed to add quality-of-life improvements rather than yet more language extensions, right?
13:19:01 <hpc> or at least in refining the design and maintaining/documenting it
13:21:46 <reactormonk> How do I find the documentation of Monad.Control.Except in hoogle?
13:21:57 <dolio> Plenty of extensions are quality-of-life improvements.
13:22:14 <davean> Athas: What would a quality of life improvement be that wasn't an extension? :)
13:22:31 <geekosaur> performance, bug fixes
13:22:31 <kadoban> compilation speed or something? better error messages?
13:22:35 <Athas> davean: faster compile times, better error messages.
13:22:40 <kadoban> Heh
13:22:43 <geekosaur> error messages would be a good candidate, yes
13:22:44 <davean> Athas: Oh, I guess I have no complaints about either
13:22:49 <hpc> better base library too
13:22:54 <Athas> Maybe GHCi features.
13:23:04 <davean> Oh, yah, actually
13:23:07 <kadoban> GHC has pretty good erorr messages, but there's always room for improvement.
13:23:08 <maerwald> removing FilePath madness and implementing AbstractFilePath proposal
13:23:10 <davean> ghci printing the actual types
13:23:21 <EvanR> almost anything ghci related
13:23:21 <hpc> it'd be pretty cool if ghci's :print and :sprint weren't quite so strict
13:23:36 <davean> maerwald, hpc: I consider library stuff seperate ... but I see why you'd say those
13:23:42 <hpc> they have trouble with showing the unevaluated parts of [a] values
13:23:47 <mbw> Holy shit it works.
13:23:48 <Athas> More robust optimisations, maybe.
13:23:53 <davean> I can't even rememberor figure out how to get ghci to print the real types
13:23:57 <davean> I tried earlier today even
13:24:05 <mbw> sry
13:24:08 <niklasb> mbw: whatdoes? your hdevtools setup with stack?
13:24:31 <niklasb> if so, I'd be happy to see your vim cfg for that:)
13:24:46 <davean> Talking about which, does anyone have a magic invocation to have ghci print out the actual types for stuff?
13:24:48 <EvanR> kadoban: error messages when it comes to certain uses of certain extensions...
13:24:51 <mbw> I decided to switch back to ghcmod. What didn't work was error being highlighted.
13:25:19 <mbw> But apparently you can ctrl+l into the quickfix window and press enter on one of the output lines of ghc.
13:25:24 <EvanR> essentially prohibits clients of such code from using it as a library
13:25:32 <mbw> Then not only will you jump to the error, but highlighting suddenly works as well.
13:25:33 <hpc> davean: how is :t deficient for you?
13:25:56 <reactormonk> So for catching IO errors thrown by readFile, do I Control.Monad.Except or Control.Monad.Error?
13:26:01 <davean> hpc: it seems to show simplified types
13:26:08 <mbw> Regarding the autocompletion thing, I have no clue. I think I will just flatten the module hierarchy and not try to be fancy.
13:26:26 <davean> hpc: specificly in cases of kind # and such
13:26:30 <hpc> ah
13:26:35 <niklasb> reactormonk: you probably want to use Control.Exception
13:26:42 <davean> hpc: so it seems pretty broken
13:27:20 <dolio> davean: You mean # instead of something involving "TYPE" or something?
13:27:31 <davean> dolio: mmm, or when it takes either
13:27:54 <hpc> so levity polymorphism isn't shown either
13:28:02 <dolio> Oh, like `error :: [Char] -> a`?
13:28:24 <davean> yah, I have no idea how to get it to not lie to me
13:28:34 <mbw> Funny thing is, now highlighting even works after exiting and reentering. Seems to have kickstarted it.
13:28:39 <dolio> davean: Actually, one issue, I think, is that ghci only reports type of expressions.
13:28:42 <hpc> have you tried turning on the extensions that let you express those types?
13:29:08 <davean> hpc: I tried
13:29:41 <dolio> So it's impossible to tell what arguments can be applied by type application, for instance, because that information is in the type of the function, but once that function appears in an expression, the type becomes different with regard to type application.
13:29:51 <dolio> That might also be true for levity stuff.
13:30:10 <Liskni_si> davean: dwarf (-g flag, backtraces in gdb) is an example of a quality-of-life improvement that isn't an extension, and is expected to maybe somewhat work in 8.2
13:30:41 <hpc> hmm
13:31:00 <davean> Its ok, I've found a pad of (virtualized) paper, but its annoying to have to do it all by hand
13:31:10 <davean> It would be a lot faster if ghci just worked :/
13:34:35 <mbw> niklasb: If it's of interest: I found out that it's a limitation of ghcmod (large parts of which went into hdevtools, and on which relies autocompletion via neco-ghc) that it can't autocomplete local functions and modules.
13:34:43 <mbw> But only installed ones.
13:35:23 <monochrom> wait, local modules? :)
13:35:46 <mbw> Project local, i.e. not Data.Functor for example.
13:36:18 <Cale> I don't use ghc-mod, but somehow that seems kind of surprising
13:36:26 <mbw> But I was completely fine before using submodules via subdirectories.
13:36:51 <mbw> Is not relying on Data.Sub.Modules a code smell?
13:37:50 <mbw> Cale: There appears to be a workaround using a cabal sandbox and install it locally.
13:38:06 <mbw> I don't know whether that works with stack though.
13:57:44 <ertes> what is dwarf used for?  people seem to love it
13:59:17 <davean> ertes: its a debugging file format, some debuggers know how to read it
14:03:06 <ertes> i can't even imagine how that could be useful in haskell
14:04:02 <geekosaur> it's trying to make debuggers actually useful with haskell
14:04:56 <ertes> yeah, but i have no mental image for what that would even look like…  the debuggers i have seen view a program as imperative with mutable state all over the place
14:08:36 <niklasb> ertes: there's an example in the GHC docs: https://ghc.haskell.org/trac/ghc/wiki/DWARF
14:10:25 <mbw> Ok now I'm really feeling stupid. One more question. I wanted to try out "fast-tags" https://hackage.haskell.org/package/fast-tags . I did a "stack install fast-tags", which resulted in a "fast-tags" binary inside .local/bin, which is in my path. But when I set it up like described, it appears to look for an init-path executable...
14:10:44 <mbw> Is this not how you install these kind of things?
14:11:55 <mbw> *init-tags sry
14:14:10 <geekosaur> I see no init-tags in the package
14:14:16 <mbw> Should I just have git cloned it?
14:14:27 <mbw> There appears to be some bash script named like that.
14:14:28 <ertes> the profiling stuff seems useful
14:14:31 <mbw> In the git repo
14:15:04 <mbw> or zsh
14:15:11 <geekosaur> yeh, just found that
14:15:33 <geekosaur> along with the vimrc cited by the readme but not in the hackage package
14:16:07 <geekosaur> so it sounds like they changed things and didn't add those files to the cabal file; might indeed be better off working from git until they fix it
14:17:19 <mbw> Ok, so this is not standard procedure then.
14:17:53 <mbw> Thanks.
14:19:32 <mbw> So, do I have to git clone, cabal build, cabal install?
14:19:56 <mbw> Or stack init and the same?
14:20:07 <geekosaur> yes. and probably have to copy the init-tags script yourself since haskell toolchain isn't set up to install shell scripts
14:20:17 <mbw> Oh.
14:20:34 <mbw> How could the author have gotten it right, then?
14:21:31 <epeme> hi guys, i can't get parallelism to work on this snippet http://lpaste.net/2929721433120571392
14:21:52 <kekpons> Receiving address 169cqw2NxkAiZMVf37B6yBe5U6DrLdirpw
14:21:56 <epeme> it worked fine when i hand coded the rpar/rseq monadic stuff myself but not when i changed it to use the public functions from the lib
14:22:41 <kekpons> sorry
14:24:16 <ertes> epeme: how did you verify that it's not parallel?
14:24:36 <epeme> the parallel version runs in sequential time
14:25:06 <epeme> for reference, here's the version that does work: http://lpaste.net/2198286660070801408 notice the change in the parallel function
14:26:28 <ertes> epeme: does it work with parTuple2 rdeepseq rdeepseq?
14:27:49 <epeme> ertes: no, same result
14:29:08 <epeme> could this be a bug in the library? i don't get it, it's supposed to be pretty straightforward
14:30:18 <ertes> ah, it's the same thing anyway
14:31:02 <ertes> not necessarily…  it may just be a misunderstanding…  unlike your 'parallel' implementation, evalTuple2 only sparks, but doesn't actually wait
14:31:47 <epeme> hmm, well that's odd
14:31:50 <epeme> changing it to: parallel = (heavyCalc' lightAm, heavyCalc' heavyAm) `using` (parTuple2 rseq rseq)
14:31:58 <epeme> that did the trick, what's the deal with rdeepseq?
14:32:17 <ertes> ah, yeah…  you're using rseq in 'parallel'
14:32:24 <ertes> but i wouldn't expect it to make any difference for Int
14:32:33 <epeme> me either
14:34:49 <epeme> on a related note, how do i generate an eventlog file using stack? i tried but the exec cmnd keeps complaining i haven't specified -eventlog in the build options even though it's there
14:34:58 <ertes> note that in your custom version you're using Integer
14:35:33 <ertes> it's technically a different type, but they're both similar in the sense that rdeepseq = rseq
14:35:50 <epeme> wait nvm, it stopped working now. what the heck
14:36:15 <epeme> this is very strange
14:36:42 <ertes> what does 'time' tell you?  execute: time ./myprog
14:36:48 <ertes> does it report CPU usage beyond 100%?
14:37:29 <ertes> uhm
14:37:35 <ertes> time ./myprog +RTS -N
14:38:11 <epeme> nope, not really
14:38:22 <epeme> but i can tell looking @ htop and CPU usage
14:38:30 <epeme> and my own timings
14:39:03 <epeme> it seems to work randomly
14:39:08 <ertes> your own timings might not be able to distinguish between a sequential run and a bad parallel run
14:39:53 <epeme> i doubt it. here: http://lpaste.net/4090185359860695040
14:41:43 <ertes> hmm, your version of 'time' does not report CPU usage
14:42:02 <epeme> doesn't really matter, user is higher than real => more than one CPU right?
14:42:20 <epeme> i assume real = wall time, user = cpu time
14:42:51 <Maxdamantus> user = cpu time spent in userspace
14:45:53 <epeme> well, i don't know, it seems to be random. some runs it parallelizes, some it doesn't
14:46:06 <epeme> i guess the runtime is deciding if it can use a spare core or not based on whatever
14:46:48 <ertes> weird…  parTuple2 doesn't seem to work for me either
14:47:01 <ertes> main = let (!x, !y) = (3^(3^30000) :: Word, 5^(3^30000) :: Word) `using` parTuple2 rdeepseq rdeepseq in print (x, y)
14:47:20 <epeme> you're using the right RTS/compile options? try running it a couple of times 
14:47:53 <ertes> of course…  i use strategies in other places, but i've never used parTuple* before
14:47:57 <epeme> oh ok
14:49:25 <ertes> if i do it manually, it works just fine
14:49:33 * nshepperd . o O (criterion)
14:49:36 <ertes> let (x, y) = (3^(3^30000) :: Word, 5^(3^30000) :: Word) in x `par` y `pseq` print (x, y)
14:52:46 <epeme> well for me it just works randomly
14:53:32 <ertes> that's weird…  i also see that random behaviour with the explicit implementation
14:53:49 <epeme> how many cores does the machine you're running it on have? 
14:54:32 <epeme> cause im only running on 2 and i don't think it likes taking them all if using -N. maybe forcing it to -N2 will do the trick?
14:55:12 <epeme> ok, it didn't :/
14:55:48 <ertes> this machine has two cores
14:56:21 <ertes> sometimes it works and shows almost 200% CPU usage, and sometimes it pretty much runs sequentually
14:56:29 <ertes> i wonder if this is one of the bugs fixed with 8.0.2
14:56:47 <nshepperd> it might not be deterministically assigning tasks to cores evenly. try the same thing with more elements
14:58:58 <ertes> it's too long for that to happen…  each task needs ~680 ms here
14:59:27 <ertes> and it's only two tasks, so distribution should be trivial
14:59:42 <epeme> is ghc8.0.2 on stack?
14:59:48 <epeme> i can't find it
14:59:49 <geekosaur> not yet
15:00:17 <epeme> ertes: are you using 8.0.1?
15:00:19 <geekosaur> stack needs revision before it can support 8.0.2 (on macOS at least)
15:01:49 <ertes> epeme: yeah
15:01:59 <epeme> ah nvm, im on lts 7.14 which has ghc8 already
15:02:01 <epeme> no clue then
15:02:15 <ertes> the release notes don't seem to mention anything about parallelism other than something unrelated
15:02:29 <ertes> i recommend posting this on haskell-cafe
15:03:39 <ertes> i've also verified just now that longer computation times don't make a change:  it still randomly selects between sequential and parallel
15:04:13 <ertes>   real 13.735  user 11.954  krnl 2.180  cpu% 102%  mem 5m  ./test +RTS -N2
15:04:14 <ertes>   real 7.096  user 13.128  krnl 0.358  cpu% 190%  mem 5m  ./test +RTS -N2
15:04:33 <ertes> interestingly in the sequential run a lot of time is spent in the kernel
15:05:01 <ertes> Linux deimos 4.8.12 #1-NixOS SMP Fri Dec 2 08:11:45 UTC 2016 x86_64 GNU/Linux
15:05:33 <epeme> im not really active in the mailing lists to post about this
15:06:25 <ertes> just do the thing you do here, but prefix it with "hi everybody" and follow it with "best regards" and your name =)
15:06:52 <epeme> heh, alrighty
15:07:26 <ertes> name/nickname =)
15:22:59 <epeme> ertes: i just realized im using par 0.1.0.0. what version did you use?
15:24:02 <ertes> 3.2.1.0
15:24:24 <epeme> hm
15:24:37 <epeme> ah nvm, i was reading this wrong
15:25:04 <ertes> ah, you read your own package's version number =)
15:25:13 <nshepperd> criterion benchmark doesn't find any randomness
15:25:17 <epeme> yea
15:25:29 <epeme> how can i tell what package versions it's using?
15:26:21 <lpaste> nshepperd pasted “parTraversable” at http://lpaste.net/351285
15:27:08 <nshepperd> i wonder if its a start up time sorta thing
15:28:19 <ertes> i don't see the randomness behaviour when i do parMap
15:28:30 <ertes> main = print (parMap rdeepseq (^(3^30000)) [3, 5 :: Word])
15:28:31 <MarcelineVQ> epeme: using stack?  stack exec -- ghc-pkg latest monad-par
15:29:21 <epeme> MarcelineVQ: stack list-dependencies did the trick thanks :)
15:29:22 <ertes> it only happens with tuples for some reason
15:30:39 <ertes> i wonder if the strictness analyser is interfering in some way, though i can't imagine it
15:31:06 <excelsiora> hi, haskell! anyone want to know how executing a haskell file in orgmode is solved? I found a guy who did it...
15:31:25 <ertes> no, that can't be right…  it's random behaviour across runs of the same program (i.e. no compilation inbetween)
15:31:27 <excelsiora> (actually haven't tried his complete solution yet...)
15:32:13 <ertes> epeme: can you confirm the long kernel times in your version when it fails to work?
15:32:17 <excelsiora> Anyhow, here's the link: https://translate.google.com/translate?hl=en&sl=ja&u=http://quickhack.net/nom/blog/2012-08-31-org-babel-and-haskell.html&prev=search
15:32:34 <epeme> ertes: how do i get kernel time?
15:32:42 <ertes> epeme: 'time'
15:32:57 <epeme> i don't get it there, tried changing the format with -f and it says -f is not a command 
15:33:20 <ertes> epeme: 'time' is most likely built into your shell
15:33:33 <ertes> if you're using zsh, you need to define the TIMEFMT variable
15:33:59 <epeme> im using bash and 'man time' said -f was an option and all :/
15:34:12 <ertes> try this:  command time ./myprog …
15:34:16 <ertes> uhm
15:34:21 <ertes> try this:  command time -f … -- ./myprog …
15:37:11 <mbw> Is it normal that nobody ever responds on the other haskell channels? Or are they just really slow?
15:37:32 <MarcelineVQ> depends on the channel, some are slow, others are quiet
15:37:57 <mbw> Hey I know you, you are in all those channels!
15:37:58 <MarcelineVQ> also bear in mind that the tendency for people around here is not to respond if they don't know the answer to your question
15:38:04 <MarcelineVQ> s-some of them
15:38:07 <mbw> Fair enough :)
15:38:29 <epeme> ertes: i see high kernel time only when there's over 100% cpu usage
15:38:38 <epeme> eg
15:38:49 <epeme> cpu: 179% user: 7.98 kernel: 3.31 wall: 6.28
15:38:49 <epeme> cpu: 100% user: 4.75 kernel: 0.09 wall: 4.82
15:39:38 <ph88> is it possible to place a variable on stack with haskell ?
15:39:47 <epeme> anyways, i sent an email to haskell-cafe
15:40:28 <mbw> I still wasn't able to subscribe to the mailing lists. Is there some maintainer I should contact?
15:40:41 <begriffs> I've haven't done much with monad transformers, looking for advice. How would I modify the linked type so that it is StateT Bool <original type>? https://github.com/nikita-volkov/hasql-transaction/blob/master/library/Hasql/Transaction/Private/Transaction.hs#L16-L18
15:41:08 <epeme> mbw: i just did it through the mailman web interface
15:41:16 <begriffs> Does the StateT go inside the newtype somewhere?
15:41:31 <mbw> I did that as well. Before christmas...
15:41:42 <lyxia> StateT Bool B.Session a  ?
15:42:24 <mbw> Though I used an email alias, but that hasn't been a problem with other mailing lists, like Boost for instance, which uses mailman as well afak
15:42:27 <mbw> *afaik
15:43:04 <epeme> mailman is just the software, the mailing server is the one that might have a problem with your address
15:43:10 <teirm> exit
15:43:59 <mbw> Maybe it's just really lazy.
15:45:05 <begriffs> lyxia: thanks, I'll try pushing ahead with that.
15:46:28 <begriffs> Hmm, "Expected a type, but ‘StateT Bool (B.Session a)’ has kind ‘* -> *’"
15:47:04 <lyxia> What I wrote (no brackets) is equivalent to (StateT Bool Session) a
15:47:40 <lyxia> It's just like function application, but at the type level.
15:48:18 <begriffs> Ah OK. Now I'm getting errors in other parts of the code as expected. It's a good start.
15:48:50 <lyxia> begriffs: Session is a monad (and a type of kind * -> *), StateT s is a monad transformer: it has kind (* -> *) -> (* -> *), so: (StateT s Session :: * -> *)
15:49:24 <lyxia> "StateT s" maps a monad to a monad.
16:04:36 <jle`> ph88^: what stack?
16:05:27 <ertes> ph88^: what's the use case?  (there is no call stack in the traditional sense in haskell)
16:06:28 <cosimone> anyone wanna recommend a good book about haskell for someone who already knows other programming languages like ocaml?
16:07:36 <agent_sm1th> Learn You a Haskell is quite good, but some find it too slow paced.
16:07:46 <ertes> cosimone: in that case i'd read the quickest intro possible and then just do exercises…  CIS194 might be a both-in-one package, or you could try the haskell wikibook: https://en.wikibooks.org/wiki/Haskell
16:07:47 <athan> Hey all, GHC is telling me I need the "tinfo" C headers, when I already have downloaded `libtinfo-dev` and their related packages. What should I look into?
16:09:04 <ertes> cosimone: you mostly need to figure out the haskell syntax (easy) and how to translate ocaml's paradigm to haskell's (more involved)
16:09:10 <Tuplanolla> Just guessing, but maybe you need `libtinfo5-dev` or `lib32tinfo-dev` instead, athan?
16:09:24 <cosimone> thank you my n-words agent_sm1th and ertes, i'll check those out!
16:09:53 <athan> Tuplanolla: This is an ARM machine :\
16:10:26 <ertes> cosimone: there is also the NICTA course, which is even more hands-on than both of them, but seems to require an external learning source that goes along with it
16:13:35 <xcmw> What is the haskell equivalent of the javascript function split? "1ab2ab3".split("ab") = ["1", "2", "3"]? I assume it would have the type Eq a => [a] -> [a] -> [[a]]. Hoogle had no good results.
16:14:08 <Tuplanolla> @hackage split
16:14:09 <lambdabot> http://hackage.haskell.org/package/split
16:14:14 <Tuplanolla> Look in there, xcmw.
16:14:15 <ertes> xcmw: first step: switch to Text
16:14:19 <ertes> xcmw: second step: https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#v:splitOn
16:14:20 <athan> xcmw: `filter isDigit` might be nicer though
16:14:47 <ertes> @let import qualified Data.Text as T
16:14:49 <lambdabot>  Defined.
16:15:05 <ertes> > T.splitOn (T.pack "ab") (T.pack "1ab2ab3ab45x6")
16:15:07 <lambdabot>  ["1","2","3","45x6"]
16:15:15 <xcmw> athan: That was just a made up example
16:15:50 <athan> hmm, I obviously have libtinfo.so.5 in /lib, and libtinfo.a in /usr/lib ... hrm
16:16:22 <geekosaur> "C headers" means stuff under /usr/include
16:16:24 <ertes> i'm pretty sure lambdabot has…
16:16:32 <ertes> > T.splitOn "ab" "1ab2ab3ab45x6"
16:16:34 <lambdabot>  error:
16:16:35 <lambdabot>      • Couldn't match expected type ‘T.Text’ with actual type ‘[Char]’
16:16:35 <lambdabot>      • In the first argument of ‘T.splitOn’, namely ‘"ab"’
16:16:38 <ertes> or not
16:16:49 <athan> thanks geekosaur
16:17:25 <geekosaur> but tinfo is a bit weird, the relevnt headers are actually in libncurses-dev
16:18:16 <geekosaur> (libtinfo is likely to be a compatibility library, linked to or a linker script for libncurses)
16:19:06 <athan> hrm, still nothing
16:19:28 <athan> I've got libtinfo-dev, libncurses5-dev, libncursesw5-dev, and libtinto5
16:19:34 <athan> all installed lol
16:19:51 <xcmw> Are there any downsides to switching to text?
16:20:31 <Koterpillar> xcmw: from what?
16:20:34 <ertes> xcmw: none that i know of…  lazy Text (Data.Text.Lazy) behaves pretty much like a more efficient version of String
16:21:03 <geekosaur> oh, wonder if it is actually looking for libtinfo.so (if cabal is producing that message then it says something about "C headers and libraries" iirc) which may not exist if libtinfo.so.5 is a compatibility library
16:21:31 <ertes> xcmw: in some/many cases (depending on your style/philosophy) you would use the strict variant though, which is not like String…  it always corresponds to an array in memory
16:21:54 <geekosaur> hackaround would be to find libncurses.so (without a version suffix) and symlink it to libtinfo.so in that directory (which will vary depending on how the distro does things)
16:22:16 <athan> geekosaur: Oh! Okay, so symlink libtinfo.so -> libtinfo.so.5?
16:22:26 <athan> ahh sweek okay
16:22:30 <athan> I'll give it a shot
16:22:39 <geekosaur> that is bnot what I said
16:22:59 <geekosaur> but I guess you're doing your own thing since I can;t see how you got that from what I said
16:24:00 <xcmw> ertes: Which one do I use? Do I have to convert back and forth? I am using megaparsec and ghcjs-dom if that matters. I don't care about preformance.
16:24:01 <athan> hm, check it out: http://lpaste.net/351286
16:24:05 <codygman> Can anyone give me a concrete example of using Data.Functor.Compose? I'm having a hard time understanding it's use. 
16:24:13 <athan> geekosaur: ^
16:24:42 <ertes> xcmw: ideally you never go through String…  megaparsec supports Text by itself (Text.Megaparsec.Text)
16:25:19 <geekosaur> that doesn't make a lot of sense unless somehow whatever is looking for it has the wrong abi
16:25:25 <athan> do you understand function composition codygman?
16:25:34 <xcmw> ertes: Do I use lazy or strict text? I am processing a very small amount.
16:25:41 <athan> shoot, I'm guessing that's the case geekosaur
16:25:48 <athan> I used haskell platform :x
16:25:55 <athan> trying to bootstrap to a modern ghc now
16:26:16 <ertes> xcmw: as far as i know megaparsec is not an incremental parser anyway, so just go with strict
16:26:27 <codygman> athan: I think I do, I can use it for my purposes at least ;) Though a friend asked me if I knew what the type signature of 'fmap const' was the other day and it was a bit hard to work out in my head.
16:26:28 <ertes> well…  if it were incremental, you would go with strict, too =)
16:27:13 <xcmw> ertes: Ok. Thanks.
16:27:36 <ertes> xcmw: most of the time strict Text is a safe choice, since the 'text' library has stream fusion (intermediate Text values will be eliminated if possible)
16:27:50 <geekosaur> athan, but it should be using the C compiler to check, I'd think. multiple gccs around?
16:28:29 <ertes> xcmw: lazy Text is useful, if you have a pure Text generator and you want to consume it lazily in constant space
16:29:00 <athan> hmm, it looks like I have some versions between 4.6 and 4.9
16:29:05 <athan> like 7 of them
16:29:11 <codygman> athan: So the function composition (fmap Just . fmap Just) would be like the type level functor composition of (Compose Just) right?
16:29:16 <athan> should I prune all but the last one you think?
16:29:32 <Tuplanolla> Here's a "concrete example", where `Compose` is used to perform substitutions inside a syntax tree, codygman: https://github.com/Tuplanolla/ties341-schemes/blob/master/Implicit.hs#L41
16:29:41 <geekosaur> start by pruning the ones not for arm-linux-gnueabihf
16:29:50 <athan> codygman: Well, type composition and function composition have different meaning
16:30:01 <athan> but they both turn into `f (f x))`
16:30:04 <codygman> Tuplanolla: Thanks, will look at it
16:30:08 <geekosaur> or at least kick those out of $PATH for now
16:30:21 <athan> they're all for arm :(
16:30:29 <geekosaur> great
16:30:37 <geekosaur> there's about 12 ARM ABIs
16:30:42 <geekosaur> "arm" is not good enough
16:30:44 <athan> D:
16:30:50 <ertes> codygman: Compose is useful, if you're using "data types a la carte", i.e. you construct your functors by combining existing functors via sums, products and composition
16:31:06 <athan> the "hard float" abi?
16:31:13 <athan> that's what they are all under
16:31:22 <ertes> codygman: in practice that's rarely done, and rarely necessary due to -XDeriveFunctor, so you won't find it widely used
16:31:24 <Tuplanolla> The idea is to put a `Functor` into the second half of a pair, codygman. The resulting thing is not a `Functor`, but `Compose` makes it one.
16:31:26 <geekosaur> "gnueabihf" which includes hard float and gnu extensions and such
16:31:30 <codygman> ertes: I might have to re-read that paper. I read it early on but probably didn't understand it well.
16:31:46 <athan> yeah that's the one
16:32:53 <geekosaur> because one possible cause for this is it's iusing a compiler that is not for the exact string arm-linux-gnueabihf
16:33:07 <codygman> Tuplanolla: So the ((,) a) isn't a functor, but Compose makes it one in the example you gave? Then you can do other things with it? Tieing that into what ertes said about it not being used because of -XDeriveFunctor, would that mean you could also accomplish your task with newtype FP = (, a) deriving Functor ?
16:33:19 <geekosaur> so it's looking in /usr/lib/_whatever_arch_string_here
16:33:24 <ertes> codygman: ((,) a) is a functor
16:33:52 <ertes> codygman: but with (a, Maybe b) fmap does not map over the 'b', but over the 'Maybe b'
16:33:58 <athan> Ahh that makes sense
16:34:06 <athan> I'll try with more verbose logging
16:34:07 <Tuplanolla> I mean that `Functor f => (a, f a)` is not automatically a `Functor` the way you want, codygman.
16:34:21 <ertes> codygman: Compose ((,) a) Maybe b  -- this one's fmap maps over the 'b'
16:35:18 <Tuplanolla> It's what ertes is saying, but my example has `FormF` in place of `Maybe`, codygman.
16:35:33 <ertes> codygman: in other words: Compose gives you a ready-made tool to cross multiple functor layers
16:35:52 <codygman> Tuplanolla: Can you explain more what you mean by "`Functor f => (a, f a)` is not automatically a `Functor` the way you want"? Is it not what you want just because the right side wouldn't be mapped over?
16:36:03 <codygman> ertes: cross in what way?
16:36:14 <ertes> > fmap (+ 1) (Compose (15, Just 7))
16:36:16 <lambdabot>  error:
16:36:16 <lambdabot>      • Data constructor not in scope:
16:36:16 <lambdabot>          Compose :: (Integer, Maybe Integer) -> f b
16:36:24 <ertes> @let import Data.Functor.Compose
16:36:26 <lambdabot>  Defined.
16:36:26 <ertes> > fmap (+ 1) (Compose (15, Just 7))
16:36:28 <lambdabot>  Compose (15,Just 8)
16:37:12 <ertes> > fmap (fmap (+ 1)) (15, Just 7)
16:37:12 <epta> Having 'f :: Either A a -> Either B a', how to 'StateT g (Either A) X -> StateT g (Either B) X'?
16:37:15 <lambdabot>  (15,Just 8)
16:38:31 <ertes> codygman: fmap (fmap f)  -- this crosses two functor layers explicitly…  in the Compose case it's done within the fmap implementation…  and that's really all there is to it
16:38:33 <codygman> ertes: Oh, I've ran into needing to do fmap (fmap f) before
16:39:10 <ertes> codygman: Compose is mostly useful not when you're using fmap yourself, but when you're giving a value to someone else, and *they* are using fmap (and you don't get to tell them to use (fmap . fmap))
16:39:53 <Tuplanolla> Here's another way to think about it, codygman: if you wanted to make `(a, Maybe a)` a `Functor`, you'd need a `newtype` wrapper for the instance; however `Compose` is a reusable wrapper that already has the instance for you.
16:40:32 <ertes> codygman: if you give them a value of type (a, Maybe b), they will map over the (Maybe b), but if you give them a value of type (Compose ((,) a) Maybe b), they will map over the 'b'
16:41:14 <ertes> (think of using a library with a Functor constraint somewhere…  Compose gives you more control over which part of your structure they map over)
16:41:51 <codygman> ertes: I think I understand. The reason for wanting to understand Compose was it's usage within Vinyl: https://github.com/VinylRecords/Vinyl/blob/29d7268fd46c4739e481786f80c6debb07ed8109/Data/Vinyl/Core.hs#L194
16:42:14 <epta> by any chance, could compose be helpful to map over `m' in `StateT s m a'? :)
16:42:24 <codygman> in my case it looks like fmap will applie to the "f" in `(Dict c :. f)` where :. is a type alias for Compose
16:43:00 <codygman> Tuplanolla: Alright that makes sense
16:43:46 <codygman> Ah it looks like Compose is used to ignore the constraints and then just map over the functor which the constraints have been applied to
16:43:59 <codygman> containing the record columns
16:44:07 <ertes> codygman: no, you don't see to what fmap would apply (if it would apply to anything at all…  not sure if the first argument to Rec is a functor)
16:44:30 <codygman> ertes: The first argument to Rec is a functor
16:44:31 <ertes> codygman: Rec expects a type of kind * -> * as its first argument, so you don't even get to say something like "(a, Maybe b)"
16:44:58 <ertes> it expects something which it can apply to a 'b' later
16:44:58 <codygman> ertes: Right, it accepts things like: Just, Either, or Identity
16:45:21 <ertes> yep…  so in this particular case you don't even have a choice but to define your own functor or use Compose to make one
17:00:42 <epta> answering my own question: hoist
18:34:21 <Lokathor> in reviewing what i wrote last night
18:34:25 <Lokathor> {-| This is magic that I don't fully understand, all the thanks go to
18:34:25 <Lokathor> cocreature of #haskell.
18:34:25 <Lokathor> -}
18:34:25 <Lokathor> instance MonadBaseControl IO ConConsole where
18:47:03 <tombert> howdy all; Does anyone have a good idea on when the OverloadedRecordFields extension is making it to GHC? 
18:47:15 <tombert> I noticed that it doesn't appear to work in 8.0.2
18:55:22 <geekosaur> nobody knows yet. it doesn't appear to be slated for 8.2.1 either
19:03:26 <jchia> how can I derive Enum for a sum type but with an offset? E.g. I want the first item to correspond to 0 instead of 1.
19:06:35 <geekosaur> you can't; you'll have to write the instance yourself
19:06:56 <geekosaur> although, that question sounds wrong
19:07:04 <geekosaur> > fromEnum False
19:07:06 <lambdabot>  0
19:07:20 <geekosaur> > fromEnum LT
19:07:22 <lambdabot>  0
19:07:29 <tombert> geekosaur: d'oh.  I guess I'll have to continue my dependence on lens
19:07:41 <jchia> I don't know whether there's a requirement that it has to start at 0
19:08:27 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18400011.2 you do now :)
19:08:58 <jchia> isn't that only the spec for the derivation?
19:09:20 <jchia> i mean i don't know whether it's a requirement of the Enum class that the first Int is 0
19:09:28 <Lokathor> could a manually written instance allow for a non-0 base value?
19:10:29 <jchia> One could implement toEnum & fromEnum with a non-zero base value but i don't know that violates any requirement by the language
19:11:52 <geekosaur> jchia, it is not a requirement, although some usages may rely on it (incorrectly)
19:12:09 <geekosaur> if they actually care, they should also require Bounded and use minBound and maxBound
19:12:36 <geekosaur> (and if *you* care, manually write that Bounded instance, those are the only two methods)
19:14:15 <jchia> OK
19:19:20 <Lokathor> (toEnum . fromEnum) <$> thingHere
19:19:29 <Lokathor> get almost any type you like as the output!
19:20:47 <markasoftware> I'm not a haskell expert but that sounds like a horrible idea
19:20:53 <EvanR> lol
19:21:09 <EvanR> undefined <$> undefined, almost any type you like as the output
19:21:33 <geekosaur> https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Hooks/DebugEvents.hs#L1246 :p
19:21:36 <Lokathor> markasoftware, i used this as a serious bit of code to convert int values into characters
19:21:50 <Lokathor> (but note that you should never convert ints to chars like that, it's all sorts of silly)
19:22:10 <EvanR> convert ints to chars... and back with ord / chr
19:22:31 <geekosaur> ..which is just toEnum/fromEnum with a type signature as a constraint :p
19:23:13 <iceden_> Hey guys!
19:23:23 <Lokathor> right now my program doesn't support unicode or arrow keys
19:23:30 <Lokathor> iceden_, hey hey
19:23:34 <iceden_> Whatsup
19:23:36 <iceden_> ?
19:23:44 <iceden_> ^^
19:23:51 <Lokathor> ever tried to lift async manually?
19:23:53 <Lokathor> that's a nightmare
19:30:00 <iceden_> So what are we allowed to discuss here
19:30:03 <iceden_> Im New :)
19:30:26 <Lokathor> Haskell, the programming language. Also Haskell the mathimatician
19:30:36 <Lokathor> and other closely related things
19:30:38 <geekosaur> This channel is about the Haskell programming language. There are several thousand other channels available with as many topics
19:30:38 <iceden_> Magicians?
19:30:56 <iceden_> xD
19:31:01 <iceden_> Oh nice
19:31:04 <Lokathor> mathematician*
19:31:52 <u900> With Data.Typeable.funResultTy I'm doing simple type checking of function application at runtime, but this only works for monomorphic types. Is there a way to do this with polymorphic types?
19:32:25 <iceden_> I know
19:32:41 <iceden_> Im just kidding
19:33:03 <iceden_> So do you guys discuss hacking or only haskell
19:33:07 <geekosaur> u900, not yet. I think polymorphic Data.Typeable is slated for 8.2.1
19:34:46 <u900> geekosaur: Ok, thanks. Any idea when 8.2.1 is coming out?
19:35:25 <geekosaur> code freeze scheduled for middle of February, tentative release in April (but they've been slipping a lot of late)
19:36:21 <monochrom> So they don't envision a lot of 8.0.x versions before they go 8.2?
19:38:47 <geekosaur> no. 8.0.2 was mostly about dealing with Windows and macOS changes, with only a small number of actual ghc bugs needing to be dealt with
19:41:30 <lpaste> tippenein pasted “arbitrary persistent instance” at http://lpaste.net/351288
19:42:10 <tippenein> question about persistent arbitrary instances
19:45:20 <tippenein> how can I get arbitrary-ness when these database entities have foreign key constraints
19:46:38 <begriffs> Having trouble with monad transformers still. I've got "newtype Transaction a = Transaction (StateT Bool B.Session a)" which derives Monad. Also have a function "query :: a -> A.Query a b -> Transaction b". Tried to add a "return" in it like "return $ B.query params query" but I get an error.
19:46:47 <begriffs> Expected type: Transaction b, Actual type: Transaction (B.Session b)
19:47:20 <begriffs> I want to get that value b out of the session somehow, like remove one of the monads almost like a join except they are not the same monads.
19:48:56 <begriffs> I guess the magic conversion would be "StateT Bool B.Session b -> StateT Bool b"
20:22:04 <Cale> begriffs: What's the type of B.query?
20:22:37 <begriffs> Cale: I actually figured it out. Should have been "Transaction . lift $ B.sql sql" in my function.
20:22:47 <Cale> yeah, that looks reasonable
20:23:32 <glguy> missed a chance to operator: Transaction . lift . B.sql $ sql
20:24:03 <begriffs> :)
20:24:08 <Cale> you might even be able to eliminate the sql parameter in that case
20:24:47 <begriffs> You're totally right. It builds fine as "sql = Transaction . lift . B.sql "
20:25:07 <begriffs> I should just auto-run hlint on save...
20:25:25 <glguy> aww, lost an operator!
20:26:20 <tippenein> any direction on generating arbitrary foreign key constraints for persistent data?
20:28:41 <Cale> begriffs: Not all of hlint's advice is worth taking, but it's nice to see the suggestions sometimes
20:28:53 <knx32542> Hello, does anyone have trouble with `stack new` throwing an httpexceptionrequest?
20:29:26 <Cale> knx32542: Network failure? What does the exception say?
20:29:28 <knx32542> For me, it works again after removing directories from my ~/.stack, but I do not want to do that everytime I make a new project.
20:29:34 <Cale> hmm
20:30:26 <knx32542> Cale: this: http://pastebin.com/155HUDDu
20:31:08 <knx32542> At the moment it works when I delete ~/.stack/{templates, build-plan-cache, indices}
20:31:25 <knx32542> but the directories come back after using `stack new` once
20:33:46 <knx32542> I asked about the question #gentoo, and was told that stack may not obey etag or if-none-match directives. I am not quite sure what that means, but the more information for the solution the better.
20:34:17 <Koterpillar> knx32542: this looks like a bug in Stack
20:34:30 <Koterpillar> knx32542: version?
20:34:44 <Cale> Yeah, 304 is "A conditional GET or HEAD request has been received and would have resulted in a 200 OK response if it were not for the fact that the condition evaluated to false."
20:34:55 <knx32542> Koterpillar: Version 1.1.2 x86_64 hpack-0.14.1
20:34:56 <knx32542>  
20:35:14 <Koterpillar> knx32542: try upgrading, the latest one is 1.3.2
20:35:55 <knx32542> *breaks a sweat* the latest one in the main Gentoo portage tree is 1.1.2...
20:36:15 <knx32542> Oh well, at least I know the reason now.
20:36:44 <Koterpillar> It _might_ be the reason
20:36:55 <Koterpillar> https://github.com/commercialhaskell/stack/releases
20:38:09 <knx32542> I guess if I needed to I could build stack from one of those. Don't worry, I know that there is no way to be completely sure of the reason. I won't hold you aginst it being the reason.
20:47:16 <danno_2> Hi, does anyone have five-ish minutes to help me out with a university assignment? I need to ask someone who's working as a software developer three questions to "identify what are the desired skills for a software developer in industry".
20:51:39 <knx32542> Alright. I tracked down my problem to be specifically ~/.stack/templates/new-template.hsfiles.etag. At least I only have to delete one file to get everything working temoporarily.
21:51:51 <S11001001> Hi all, I was wondering where to report GHC bugs.  I found that when I unsafeCoerce "h" + unsafeCoerce "i", I just get this "Out of memory." error message, and the program exits! I was hoping it would return "hi", or at least throw a ClassCastException or something like that.
21:58:10 <glguy> It's not a GHC bug if you misuse unsafeCoerce
21:59:27 <glguy> S11001001: You can read more here: http://hackage.haskell.org/package/base-4.9.1.0/docs/Unsafe-Coerce.html
21:59:40 <S11001001> glguy: ;)
21:59:41 <glguy> The short version is that you won't need this function
22:02:33 <S11001001> In all seriousness, I came to Haskell from a culture that taught me that it was impractical not to runtime-tag every value with some Typeable evidence, e.g. Java
22:02:43 <S11001001> it's refreshing to...not
22:07:25 <liste> :t (unsafeCoerce "h" + unsafeCoerce "i")
22:07:27 <lambdabot> error:
22:07:27 <lambdabot>     Variable not in scope: unsafeCoerce :: [Char] -> a
22:07:28 <lambdabot> error:
22:08:05 <liste> it's Num a => a, how is the instance even picked?
22:08:57 <liste> S11001001: also, + doesn't concatenate strings in Haskell
22:09:20 <S11001001> liste: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#index-26
22:09:21 <geekosaur> probably defaulting, since unsafeCoerce hides all other evidence and there's nothing to block defaulting
22:09:33 <S11001001> liste: default default is Integer
22:09:53 <geekosaur> but yes, it will explode in fun ways; it's roughly what C++ calls reinterpret_cast
22:10:09 <geekosaur> but most things can't be reinterpreted safely that way
22:11:09 <S11001001> liste: it does if you use the awesome Num instance from https://hackage.haskell.org/package/acme-php-0.0.5/src/Prelude/PHP.hs
22:12:05 <S11001001> eh I guess that would just return "0"
22:12:23 <geekosaur> (in particular, iirc constructor tag 0 of an Integer requires a pointer to a gmp integer
22:12:27 <geekosaur> @src Integer
22:12:27 <lambdabot> data Integer = S# Int#
22:12:27 <lambdabot>              | J# Int# ByteArray#
22:12:50 * geekosaur wonders how far to trust that
22:13:44 <EvanR> or does ctor tag 0 require an unboxed Int
22:14:05 <S11001001> @src Int
22:14:05 <lambdabot> data Int = I# Int#
22:14:06 <geekosaur> it does
22:14:07 <EvanR> and if not, is it a pointer or gmp data
22:14:21 <S11001001> a Int default wouldn't be quite as exciting
22:14:31 <EvanR> is Int# used for pointers?
22:14:52 <geekosaur> looks like it's S# Int# | Jp# BigNat | Jn# BigNat
22:15:12 <geekosaur> oh, right, but a String is a list so tag 0 is []
22:15:29 <geekosaur> so who knows what it found after
22:16:05 <EvanR> unsafeCoerce () :: CoolestMMOFullyImplementedAndPolished
22:16:15 <nshepperd> lambdabot's Integer seems to be from an old integer-gmp version
22:16:34 <geekosaur> wait, thinking wrong, that means it used the Jp# constructor which is likely to have been optimized to a ByteArray#
22:17:13 <geekosaur> yes, that's why I asked how far I could trust that --- @src is notoriously far from the truth in many cases
22:17:30 <EvanR> what is BigNat
22:17:37 <geekosaur> (built from an ancient Prelude back when it was trying to serve ghc, hugs, and nhc98 at the same time)
22:17:47 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/integer-gmp-1.0.0.1/GHC-Integer-GMP-Internals.html#t:BigNat
22:17:54 <geekosaur> BN# ByteArray#
22:18:28 <geekosaur> and since it's strict in Jp# and probably built with optimization, I expect it inlined the ByteArray#
22:18:42 <EvanR> ByteArray#
22:19:12 <EvanR> interesting ByteArray# knows how big it is
22:19:20 <geekosaur> yeh
22:19:48 <EvanR> whats State#
22:20:00 <EvanR> the RealWorld hack?
22:20:50 <geekosaur> data State# s a = s -> (# a, s #) -- iirc. used by IO and ST at least
22:23:06 <geekosaur> huh. no, it's not just an unboxed State, it is the current state hack indeed
22:23:55 <EvanR> it must allow mutable arrays without an IO monad
22:24:32 <EvanR> Addr# is pretty refreshing... no C virtual machine dogma 
22:24:54 <geekosaur> dats State# s -- that's it
22:24:56 <geekosaur> er
22:25:00 <geekosaur> data State# s -- that's it
22:25:20 <geekosaur> "It is represented by nothing at all"
22:25:35 <EvanR> that might be the modern way to say RealWorld
22:27:19 <geekosaur> no, it's the modern way to say the phantom state of IO and ST. RealWorld still "exists" for the purpose of defining IO as a special case of ST
22:27:45 <geekosaur> so there is State# RealWorld as essentially the only usage of RealWorld
22:34:11 * geekosaur reads on in GHC.Types and snickers at "This is a temporary solution (if you're reading this in 2023 then things went wrong)"
22:34:34 <EvanR> clocks ticking
22:34:35 <kadoban> Hah, that's a nice comment
22:34:50 <GLaDER> Morning!
22:57:32 <ReinH> geekosaur: "This is a temporary solution", famous last words.
23:07:26 <geekosaur> yep
23:31:15 <dyreshark> hi! i have code that looks like http://pastebin.com/68SkJJTK (without the typo ;) ), and hGetChar seems to wait until `bar` exits to return. how do i make it give me output as the output is written to stdout? i've tried using hSetBuffering in three different ways, and it doesn't help :/
23:33:45 <pavonia> dyreshark: What OS are you on?
23:33:53 <dyreshark> pavonia: linux
23:34:09 <geekosaur> dyreshark, you likely need to control buffering *in bar*
23:34:38 <geekosaur> see the "stdbuf" program
23:38:17 <dyreshark> geekosaur: changing it to "stdbuf", ["--output=0", "bar"] gave the same wait-until-bar-terminates result, sadly
23:47:01 <EvanR> is there a square root algorithm which terminates if there is a rational answer
23:51:25 <EvanR> answer, yes, the long-division-sortof algorithm
