00:00:12 <av_> the other sentence in the docs is even more confusing: "If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions."
00:00:51 <Lokathor> av_, between a read and a write, someone else might perform a write, is what's being said there
00:00:59 <av_> as I understand it, even if I have multiple IORefs, using atomicModifyIORef to modify one of them at the time prevents race conditions, right?
00:01:17 <ongy> av_: low level synchronication primitives aren't encouraged in the Haskell world, so MVar/TVar are prefered
00:01:25 <av_> assuming I don't care about the others...
00:02:05 <av_> ongy: sure, I just want to understand why the docs say what they say, from what I'm told now it looks like the docs are misleading
00:02:15 <cocreature> av_: yeah you are right. the docs refer to atomic operations that access multiple IORefs
00:02:35 <av_> cocreature: thanks, it all makes sense now
00:04:46 <ongy> also, memory model makes things even more fun
00:05:09 <av_> ongy: yes, so I'm told...
00:05:27 <Lokathor> and hsqml also doesn't seem to actually build with stack
00:05:31 <av_> thanks everyone
00:05:32 <Lokathor> not lucky today i guess
00:06:27 <geekosaur> Lokathor, you have multiple versions of the Cabal library installed and they're getting mismatched. probably nothing (or very little) will build correctly in that config
00:06:51 <Lokathor> this is all stack's fault!
00:06:56 <Lokathor> also, many packages are building just fine
00:07:17 <Lokathor> just not the actual GUI toolkits that I want
00:07:49 <geekosaur> urgh, gtk2hs, right, this has special build requirements because it does Evil Things(tm) in its Setup.hs
00:07:53 <Lokathor> http://lpaste.net/351818 unless stack is lying that most of the dependencies built
00:08:06 <geekosaur> iirc there is a ticket open about dealing with it
00:08:14 <Lokathor> oh well
00:39:21 <Lokathor> ooh
00:39:29 <Lokathor> seems FLTK might work out
00:40:09 <Lokathor> does enough type magic to take longer than rust to compile though
00:46:30 <antalsz> Is there a “destructive `map`” operation on mutable `MVector`s?  With type `inPlaceMap :: (PrimMonad m, Storable a) => (a -> a) -> MVector (PrimState m) a -> m ()`?
00:48:03 <Lokathor> looks like you'd have to build it
00:57:55 <zipper> ord "a"
00:58:01 <zipper> > ord "a"
00:58:04 <lambdabot>  error:
00:58:04 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
00:58:04 <lambdabot>      • In the first argument of ‘ord’, namely ‘"a"’
00:58:12 <ongy> :t "a"
00:58:14 <ongy> :t 'a'
00:58:14 <lambdabot> [Char]
00:58:16 <lambdabot> Char
00:58:22 <zipper> > map ord "a"
00:58:24 <lambdabot>  [97]
00:58:33 <zipper> ongy: yaaayz!!
01:51:00 <quchen> antalsz: I’m not sure. Mapping is typically something that can be stream-fused away so it can be done on pure vectors without overhead compared to the mutable version.
01:51:13 <quchen> So I wouldn’t be surprised if the library didn’t have it.
01:51:52 <antalsz> quchen: Fair enough.  Do you have any good resources for trying to understand when fusion will fire?
01:52:09 <quchen> antalsz: When the documentation says »subject to fusion« :-)
01:52:22 <antalsz> quchen: :-)
01:52:34 <quchen> Eeeek okay Vector does not say that
01:52:34 <quchen> (Text does)
01:53:04 <antalsz> But, for instance, avg v = V.foldr (+) 0 v / V.foldr (\_ n -> 1 + n) 0 v won’t fuse, I presume
01:53:18 <antalsz> because you’re foldring twice
01:53:35 <quchen> In that case: look at the Core output. But before that, make sure you care enough about the performance.
01:54:12 <quchen> It’s perfectly fine to implement your own average function in ST, but you’re venturing into unsafe territory, so it requires care.
01:54:27 <quchen> For »average«, you can solve the problem with a single fold.
01:54:32 <antalsz> quchen: Indeed, root of all evil and all that
01:55:02 <antalsz> also, V.foldr (+) 0 v / V.length v, since length doesn’t need a fold – it was just the first not-totally-silly example I could think of
01:55:40 <antalsz> anyway, thanks for the pointers; I’ll see whether mutable or immutable feels like the better model
01:55:53 <quchen> The standard deviation of a vector needs length, sum and sum-of-squares. That one can’t be implemented that easily.
01:56:24 <quchen> But even this case can be done using a single fold, because you can consume the input element-wise. :-)
01:56:26 <orion> What functions should I consider if I want to write an application which can load/execute other haskell shared libraries at runtime, given some "Plugin" typeclass?
01:57:28 <quchen> antalsz: But the general answer to »did fusion work« is looking at the GHC debug output of what rules did fire, or studying the core output.
01:57:53 <quchen> If you see stream/unstream a lot in core, chances are fusion did not fire. So that gives you a »grep -n« level estimate :-)
01:58:06 <antalsz> quchen: ooh, rules that fired seems like a nice choice, as does stream/unstream!
01:58:22 <quchen> I don’t know the GHC flag that prints all firing rules, but there is one.
01:58:38 <quchen> Gotta go, good luck! @tell me or ask others around here if you want to know more :-)
02:01:19 <geekosaur> -ddump-rule-firings and maybe -ddump-rule-rewrites for gory details
02:06:32 <roxxik> is it possible for the exf bot to join #haskell.de?
02:06:36 <roxxik> :exf (a,b) -> a
02:06:41 <ph88^> what would be the idiomatic haskell way to write this piece of IO code ?  https://paste.fedoraproject.org/541401/14858571/
02:07:08 <exferenceBot> could not find expression
02:07:08 <roxxik> yesterday it worked :(
02:07:22 <roxxik> :exf a -> a
02:07:22 <exferenceBot> parse error: more than one input
02:07:34 <roxxik> :exf a -> a -> b
02:07:34 <exferenceBot> parse error: more than one input
02:07:40 <roxxik> :exf f :: a -> a -> b
02:07:41 <geekosaur> ph88, `if` isd an expression, not a statement, even in do syntax
02:07:41 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 3) "Parse error: ::"
02:07:45 <ph88^> what's this bot ?
02:07:54 <roxxik> it generates code from types
02:08:00 <geekosaur> and you have to use another `do` in the `else`
02:08:22 <roxxik> i had it generate the bind function of state (minus newtype conversions)
02:08:33 <miladz89> any snappers here ? how can I send a synchronous (or any request) request using snap ?
02:09:08 <geekosaur> ph88^, exferenceBot is djinn on steroids, https://github.com/lspitzner/exference
02:09:22 <roxxik> :exf (s -> (a,s)) -> (a -> s -> (b,s)) -> s -> (b,s)
02:09:23 <exferenceBot> \ f1 f2 c -> let ((,) g h) = f1 c in f2 g h
02:10:45 <ph88^> cool bot :P
02:10:52 <ph88^> now we can all go home and let exferenceBot do the work
02:11:07 <roxxik> :exf ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
02:11:08 <exferenceBot> \ f1 f2 f3 -> f1 (\ f -> f2 f f3)
02:11:20 <ph88^> roxxik, maybe you can query the bot directly
02:11:41 <roxxik> i wanted to show off something, and don't wanted to spam the #haskell channel ;)
02:11:52 <roxxik> but there is #exference, i'll use that one next time
02:13:10 * athan saw nothing o_o
02:13:15 <ph88^> it's your bot ?
02:13:54 <geekosaur> I think hexagoxel maintains it currently?
02:14:27 <ph88^> geekosaur, is it possible to skip the  pathExist <- doesPathExist path   part and use   doesPathExist path  directly in the if clause ?
02:14:36 <geekosaur> ph88^, no
02:14:44 <geekosaur> an IO Bool is not a Bool
02:16:52 <jophish> ph88^: often in these cases I do something like: getArgs >>= \case {[] -> putStrLn "no args"; _ -> putStrLn "some args"}
02:17:50 <jophish> so you could do: `doesPathExist >>= bool (doesn't exist) (does exist)` or `doesPathExist >>= \case {True -> ...; False -> ...}`
02:17:52 <roxxik> this i where i use \case most often too
02:28:40 <ph88^> anyone know how i can fix this problem with the types ?  https://paste.fedoraproject.org/541411/14858584/
02:29:24 <geekosaur> do you ever plan to learn Haskell, or just rely on #haskell to fix things for you?
02:30:09 <BernhardPosselt> monad transformers are about combining monads, correct?
02:30:31 <ph88^> well i already learned a lot i think
02:30:33 <geekosaur> mm, actually, that ... ph88^, what version of ghc are you using?
02:30:46 <ph88^> geekosaur, you want to see my biggest program? it shows what i already understand
02:30:55 <geekosaur> you haven't learned how do notation works yet, still, per your last but one paste
02:31:04 <ph88^> true
02:31:11 <BernhardPosselt> how extensive is the built in monad transformer lib?
02:31:25 <BernhardPosselt> does it cover all built in monads?
02:31:26 <ph88^> geekosaur, ghc 8.0.1
02:31:27 <Ferdirand> Couldn't match type '[Char]' with 'String'
02:31:29 <Ferdirand> what ?
02:32:31 <geekosaur> ... wat. I was thinking this was an 8.2 prerelease since they've been talking about making FilePath abstract... but
02:32:41 <ph88^> maybe i can use a type conversion function  [Char] -> String
02:32:56 <geekosaur> did you redefine String?
02:33:03 <jophish> https://hackage.haskell.org/package/foundation-0.0.3/docs/Foundation.html#t:String geekosaur 
02:33:14 <ph88^> foundation package might have redefined string, otherwise all of my source code is in that paste
02:33:22 <jophish> ph88^: it's due to the use of Foundation, that redefines 'String'
02:33:43 <geekosaur> oh brother
02:34:00 <ph88^> yeah i made an issue about it, but i thought maybe if i can figure out how to fix it i can contribute something back or something
02:34:25 <jophish> ph88^: you can use 'toList' to convert to [Char] I think
02:34:25 <roxxik> Foundation: newtype String = String (UArray Word8)
02:34:42 <roxxik> but the constructor is not exported
02:35:02 <merijn> ph88^: Obligatory "doesPathExist is a TOCTOU-race" warning
02:35:13 <ph88^> ok ill search for some conversion function, thx guys
02:35:50 <jophish> ph88^: toList
02:36:06 <jophish> and presumably fromList
02:36:09 <ph88^> merijn, what are you saying? should i check time and build in a warning ?
02:36:32 <geekosaur> you should let the operation using the file fail and check forthat, not test it beforehand
02:36:41 <jophish> ph88^: you might check that it exists, and between that check and you using the file it could have been removed
02:37:07 <merijn> ph88^: TOCTOU = Time-of-check, Time-of-use
02:37:08 <geekosaur> or swapped with a different one so any tests you did beforehand are against the wrong file
02:37:17 <merijn> ph88^: It's similar to "doesFileExist" in that sense
02:37:33 <miladz89> any one who knows snap ?
02:37:34 <ph88^> jophish, i solved it, with  getCurrentDirectory >>= \x -> putStrLn (show x)  documentation says it's slow, but it works nevertheless
02:37:44 <merijn> ph88^: What happens if you run "doesPathExist", it returns True and now someone deletes the path before you can actually run the action using the path
02:39:22 <ph88^> so i should use openFile immediately and then start catching exception ?
02:40:13 <merijn> ph88^: Yeah, it's the only sane way
02:40:40 <ph88^> ok i better read up on exception handling then, haven't looked into that yet ^^
02:40:46 * geekosaur so wants to replace all the stuff that throws synchronous exceptions with proper implementations
02:41:03 <roxxik> try? anyone
02:41:05 <roxxik> :t try
02:41:07 <lambdabot> Exception e => IO a -> IO (Either e a)
02:41:22 <ph88^> go for it geekosaur ! :D
02:41:25 <jophish> geekosaur: I'd use a package that supplied things like "readFileOrNothing :: FilePath -> IO (Maybe ByteString)" and friends
02:41:41 <jophish> I've implemented that quite a bit in my own code but never abstracted it out
02:42:22 <ph88^> jophish, that might be a good suggestion for a new prelude, you mind if i copy paste that on github ?
02:42:53 <geekosaur> well, probably it'd be ExceptT
02:43:02 <jophish> ph88^: I'm not sure we need any more preludes :)
02:43:03 <ocharles> Any advice on whether one should use writeIORef or atomicWriteIORef?
02:43:04 <noan> Does mappen have a general name when abstracted away from haskell?
02:43:08 <noan> mappend* 
02:43:15 <merijn> geekosaur: tbh, I just want to remove unchecked exceptions and make Haskell have checked exceptions
02:43:22 <jophish> geekosaur: sure
02:43:24 <ph88^> jophish, :(
02:43:25 <ocharles> Assume usage in a concurrent environment
02:43:55 <merijn> ocharles: Is the IORef shared? What consistency model do you require?
02:44:16 <ocharles> yes, shared, it's a counter that web requests increment to log the total amount of requests served
02:44:18 <roxxik> merijn: do you mean all exeptions, or only the synchronous ones?
02:44:18 <ocharles> (for example)
02:44:20 <merijn> noan: Not really, mappend is common in algebra, but it doesn't really have a name
02:44:20 <cocreature> ocharles: in that case, I would use atomicWriteIORef unless it is a performance bottleneck. it’s easier than having to figure out if writeIORef is really safe
02:44:32 <merijn> roxxik: I haven't decide yet
02:44:40 <noan> merijn, okay, I couldn't find anything on the wikipedia semigroup or monoid topics so I wasn't sure
02:44:42 <ocharles> That was my thinking. It's a shame, because writeIORef allocates 0 bytes, but atomicWriteIORef allocates 80
02:44:44 <ocharles> but not the end of the world
02:44:50 <merijn> cocreature: writeIORef is afe, it just might not have the consistency you want :p
02:45:05 <merijn> ocharles: What sort of consistency do you want?
02:45:08 <ocharles> incrementing the counter takes 120 bytes anyway, it's just "setting to a known value" that would have been allocation free
02:45:09 <merijn> and/or need
02:45:18 <ocharles> merijn: I don't know enough about consistencies to answer that question
02:45:30 <laz> noan: it can be called monoid product
02:45:32 <ocharles> or more, I don't know what my options are
02:45:47 <noan> laz, thanks
02:45:49 <laz> noan: according to http://math.chapman.edu/~jipsen/structures/doku.php/monoids
02:46:11 <roxxik> laz: i often see it being called product
02:46:19 <merijn> ocharles: Well an absolute consistency would be that every thread always agrees on the exact order in which things have happened
02:46:21 <roxxik> and written by x in a circle
02:46:30 <merijn> ocharles: I believe writeIORef is sequential consistency
02:47:19 <cocreature> there is a "Memory Model" section at the bottom of the Data.IORef haddocs
02:47:20 <merijn> ocharles: Which translates to "in hindsight threads agree on *A* sequential order of operations which explains the observed behaviour, but that is not necessarily the actual behaviour"
02:48:01 <jophish> for logging an incrementing counter that shouldn't be a problem at all I'd think
02:48:06 <merijn> ocharles: That is, "thread A writes an IORef, thread B reads an IORef (at a later point in absolute time)", but thread B might (in sequential consistency) see the old unupdated value
02:48:32 <merijn> ocharles: Since there is a valid sequential ordering of operations in which 'B' reads before 'A''s write happens.
02:51:33 <merijn> iow, the wallclock ordering of events does not have to map to the logical ordering of events, as long as the logical ordering is a unique sequential order that accurately reproduces the observed behaviour
02:51:39 <ocharles> jophish: you mean you think non-atomic variations are probably ok?
02:52:11 <merijn> ocharles: Yeah, for logging it's usually fine to have sequential consistency
02:52:34 <ocharles> 10x less allocation pressure is nice
02:53:03 <roxxik> i think MVar's are way simpler here, just treat them as mutex (empty: lock is taken, full: lock is released), don't know about allocation pressure
02:53:29 <clinton> is there a library that gives composition functions like this: (b -> c) -> (a1 -> ... -> an -> b) -> a1 -> ... -> an -> c?
02:53:39 <merijn> ocharles: Lemme put it this was: suppose your logging thread appears to have polled your IORef magically slightly before an operation happened (albeit factually happening slightly after), does that impact you?
02:54:03 <clinton> they're coming up frequently in my code, and whilst I could write my own I suspect someone already has and I'd rather stick with their conventionn
02:54:08 <clinton> hoogle comes up with nothing though
02:54:26 <merijn> clinton: Writing something like that isn't something you can do in general
02:54:30 <ocharles> clinton: I would advise against composition operators here. They might seem appealing, but imo they just introduce code noise
02:54:39 <merijn> clinton: Consider this: what if 'b' or 'c' are function types themselves?
02:56:44 <mrkgnao> sup, #haskell
02:57:07 <mrkgnao> I have a sorta-embarrassing question.
02:57:30 <clinton> merijn: indeed they are function types. In my actual problem I'm unwrapping an argument and forwarding it to about a dozen class functions. In all of these functions the unwrapped argument needs to be passed as the last argument
02:58:10 <clinton> So I actually need stuff like this: (b -> c) -> (a -> b -> d) -> a -> c -> d
02:58:23 <clinton> which is close to "." but not quite
02:59:05 <clinton> or this (b -> c) -> (a1 -> a2 -> b -> d) -> a1 -> a2 -> c -> d
02:59:05 <Axman6> mrkgnao: we're all friends, unless you've written some javascript and no longer remember how it works and under what conditions
02:59:14 <ocharles> sweet, with just writeIORef incrementing the request counter takes 0.5 nanoseconds (95% quantile). I think I can handwave that as "no performance impact"
02:59:54 <Ferdirand> :t \f g -> (((f.).).).g
02:59:55 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
03:00:06 <Ferdirand> it's not very pretty, but...
03:00:24 <Axman6> isn't that just contramap g?
03:00:53 <Axman6> oh not at all
03:00:55 <roxxik> isn't IORef basically a nice wrapper around direct memory access?
03:00:59 <Axman6> hmm
03:01:14 <mrkgnao> Axman6: :)
03:01:16 <Axman6> roxxik: not quite, it's more like a mutable pointer
03:01:50 <mrkgnao> so my problem is that I want to update an element of a list that's a field in a record datatype
03:01:53 <roxxik> ocharles: so your modifyIORef r (+1) should get compiled down to some inc instruction, depending on architecture. and those are fast :)
03:01:53 <Axman6> so you can mutate what it points to, not mutate a itself
03:02:04 <mrkgnao> what I want is basically a pointer. :(
03:02:04 <Axman6> mrkgnao: sounds like you need lenses
03:02:11 <ocharles> roxxik: yep, pretty much :)
03:02:27 <mrkgnao> I am using lenses, but I don't know how to use them to change elements of lists
03:02:37 <roxxik> ix ?
03:02:44 <Axman6> mrkgnao: can you give a more concrete example? 
03:02:50 <mrkgnao> yeah
03:02:55 <Axman6> do you need to modify a specific element?
03:03:10 <mrkgnao> Yes, but not by index (although I can do that).
03:03:27 <Axman6> :t ix 3 . _Just %~ (+3)
03:03:29 <lambdabot> (IxValue t ~ Maybe a, Ixed t, Num (Index t), Num a) => t -> t
03:03:41 <mrkgnao> whoa
03:03:51 <Axman6> :t ix 3 . _Just %~ (+3) `asApliedTo` (undefined :: [Maybe Int]
03:03:51 <roxxik> how do you find your element?
03:03:53 <lambdabot> error:
03:03:53 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:03:57 <Axman6> :t ix 3 . _Just %~ (+3) `asApliedTo` (undefined :: [Maybe Int])
03:03:59 <lambdabot> error:
03:03:59 <lambdabot>     • Couldn't match type ‘IxValue t0’ with ‘Maybe a0’
03:03:59 <lambdabot>       Expected type: (Maybe a0 -> Identity (Maybe a0))
03:04:08 <Axman6> :t ix 3 . _Just %~ (+3) `asAppliedTo` (undefined :: [Maybe Int])
03:04:11 <lambdabot> [Maybe Int] -> [Maybe Int]
03:04:41 <mrkgnao> Axman6: what does your first example do?
03:04:43 <Axman6> mrkgnao: do you need to modify elements matching a specific predicate?
03:05:04 <thatguy> Can anyone explain me the difference between ! and !! when evaluating an array element
03:05:07 <clinton> is there a way to do a signature search of all of hackage?
03:05:17 <Axman6> [Nothing, Just 7, Just 3,Nothing] & ix 1 . _ Just %~ (+3)
03:05:23 <Axman6> > [Nothing, Just 7, Just 3,Nothing] & ix 1 . _ Just %~ (+3)
03:05:29 <lambdabot>  error:
03:05:29 <lambdabot>      • Found hole:
03:05:29 <lambdabot>          _ :: (a0 -> Maybe a0)
03:05:36 <Axman6> > [Nothing, Just 7, Just 3,Nothing] & ix 1 . _Just %~ (+3)
03:05:40 <lambdabot>  [Nothing,Just 10,Just 3,Nothing]
03:05:43 <Axman6> bloogy hell, I am bad at typing tonight
03:05:51 <mrkgnao> bloogy hell indeed :)
03:05:58 <mrkgnao> I think I'll work with indices for now
03:06:01 <Axman6> clinton: that's hoogle
03:06:09 <mrkgnao> in which case the last one should work
03:06:10 <roxxik> clinton: hayoo or hoogle
03:06:14 <Axman6> mrkgnao: what did you actually want to do? =)
03:06:52 <Axman6> mrkgnao: so that expression will increment the value in the second element of a list, as long as it is a Just constructor
03:08:22 <roxxik> just for fun: how would you increment the value in the second just value of a list?
03:09:00 <mrkgnao> Axman6: I have a VM datatype that has a [Process] list.
03:09:43 <mrkgnao> I want to step each Process, which changes some state associated with the VM as well as increments a counter associated to the Process.
03:09:54 <Axman6> roxxik: you'd probably use an indexed traversal for that (an optic that provides both the element, and its index)
03:10:15 <Axman6> mrkgnao: for all processes? or a specific one?
03:10:23 <mrkgnao> all
03:10:44 <mrkgnao> but the increment depends on the result of the step function.
03:10:59 <Axman6> then you probably don't need the ix, you can yse traverse . _Foo . bar to focus on all the elements of the list
03:11:26 <roxxik> just write a function Process -> Process and map that?
03:11:45 <Axman6> the proper answer will depend on several things though, like if the step function is stateful or monadic or something
03:11:55 <Axman6> yeah this sounds an awful lot like map =)
03:11:58 <mrkgnao> roxxik: but the step function also has to modify other parts of the VM state.
03:12:23 <mrkgnao> Axman6: it's inside what is my first real monad transformer stack!
03:12:28 * mrkgnao makes excited noises
03:13:01 <Axman6> :o
03:13:19 <Axman6> do you need any monadic context in this step function?
03:13:23 <roxxik> you need to do two things? step and inc? step needs access to VM and updates a Process? and afterwards you want to update (inc) each process? with some information gathered during step?
03:13:29 <Axman6> or can you just use Process -> Process?
03:14:10 <Axman6> traverse will be useful if you need the monadic context
03:14:12 <Axman6> :t traverse
03:14:13 <mrkgnao> no, as I said, the step function modifies other parts of the VM state, not just the part associated to the specific process.
03:14:13 <roxxik> maybe `c -> Process -> Process` where c is the context you need 
03:14:14 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:14:21 <roxxik> ah it modifies those too
03:14:45 <Axman6> :t traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
03:14:47 <lambdabot> (a -> Maybe b) -> [a] -> Maybe [b]
03:15:04 <Axman6> substitute Maybe with your awesome monad stack
03:15:24 <mrkgnao> okay, let's see where this gets me!
03:15:42 <roxxik> step updates stuff outside of the list... so you definitly need more than traverse
03:15:50 <mrkgnao> (it's an ExceptT and a StateT. nothing fancy, but I think things are starting to make sense)
03:15:50 <Axman6> (also note that traverse doesn't need Monad, only Applicative, whch is pretty nice)
03:15:51 <roxxik> (i think)
03:15:58 <mrkgnao> roxxik: yes
03:16:13 <mrkgnao> maybe using indices is the way to go. :(
03:17:05 <roxxik> nah if you have Process -> State VM Process then you could use traverse, but that's not particularly nice, because now you have the process two times 
03:17:59 <roxxik> do you need to access the whole VM or other processes or just some specific stuff?
03:20:48 <mrkgnao> roxxik: the VM has a Memory field that I need to change, that's all
03:21:34 <roxxik> then go with State (Memory,Process) () or similar
03:21:48 <Axman6> you probably don't need to process the lsit twice, just use (fmap inc . statefulProcessor) as the first argument to traverse
03:21:52 <roxxik> or Process -> State Memory Process and use traverse
03:22:08 <zipper> NOT STATE! OMG NOT STATE! I DON'T UNDERSTAND STATE!!! :(
03:22:19 <Axman6> state's so easy though
03:22:31 <roxxik> State a <=> s -> (s,a)
03:22:37 <roxxik> State s a <=> s -> (s,a)
03:22:50 <roxxik> State s a <=> s -> (a,s)
03:24:09 <zipper> Axman6: Is it? :( well maybe I need to squint harder.
03:27:38 <Ferdirand> why s -> (s,a) and not s -> (a,s) indeed ?
03:27:56 <mrkgnao> pretty sure that's just how it's defined
03:28:02 <Ferdirand> given that the functor instance for 2-tuples operate on the second element
03:28:11 <Ferdirand> sorry i got that reversed
03:28:27 <Ferdirand> s -> (s,a) looks more natural to me
03:36:46 <usman> join
03:37:29 <usman> is it helpful for haskell?
03:38:09 <usman> hey? anybody there?
03:38:13 <quchen> zipper: State is something that has get and put. You don’t need to understand the internals to use it.
03:38:20 <Xnuk> > join (Just Nothing)
03:38:23 <lambdabot>  Nothing
03:38:30 <quchen> It is instructional to implement State yourself, but not required at all.
03:38:40 <Xnuk> > join (Just (Just 3))
03:38:43 <lambdabot>  Just 3
03:38:51 <ski> Ferdirand : yes, i'd say it's more natural from a theoretical standpoint
03:38:54 <ski> also cf.
03:38:55 <ski> @type mapAccumL
03:38:57 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
03:39:00 <ski> (and `mapAccumR')
03:39:37 <merijn> roxxik: The best homework for understanding State is just reimplementing it yourself: https://gist.github.com/merijn/098106abd45c940dab09
03:40:08 <roxxik> yup
03:40:16 <quchen> usman: Example: a worker thread receives a computation (type IO a) from the scheduler. Reading from the worker thread gives it an »IO <channel contents>«. Since the channel contains »IO a«, reading from the channel is an action of type »IO (IO a)«. Executing this thing in the worker then looks like »result <- join (readChannel chan)«.
03:40:36 <roxxik> i just stumbled on Cont's Applicative instance (because i played around with exferenceBot)
03:40:39 <ski> (in the `Writer' case, it would be nicer to use `(w,a)', since then it would fit better with a "raw" `Monoid w => MonadWriter w (w,)')
03:40:41 <merijn> roxxik: Incidentally, the best homework for understanding transformers is generalising State like StateT like in that gist :)
03:40:50 <roxxik> :exf (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
03:40:50 <exferenceBot> \ f1 f2 f3 -> f2 (\ f -> f1 (\ f9 -> f3 (f9 f)))
03:40:51 <exferenceBot> \ f1 f2 f3 -> f1 (\ f6 -> f2 (f3 . f6))
03:40:52 <merijn> roxxik: Cont still perpetually confuses me :p
03:41:10 <quchen> That was … =<<?
03:41:11 <roxxik> why is the second version in use and not the first (or better: what's the difference?)
03:41:21 <roxxik> i think it is something about ordering...
03:41:36 <ski> `ContT' can be good when you're doing "dynamic resource wrappers" (`withCString',&c.), and "quantifiers"
03:41:41 <roxxik> i really like how exf can infer ap for state: :exf (s -> (a -> b,s)) -> (s -> (a,s)) -> s -> (b,s)
03:41:42 <roxxik> :exf (s -> (a -> b,s)) -> (s -> (a,s)) -> s -> (b,s)
03:41:43 <exferenceBot> \ f1 f2 c ->
03:41:43 <exferenceBot>   let ((,) f7 h) = f1 c
03:41:43 <exferenceBot>       ((,) k l) = f2 h
03:41:43 <exferenceBot>     in (f7 k, l)
03:41:43 <exferenceBot> \ f1 f2 c ->
03:41:45 <exferenceBot>   let ((,) g h) = f2 c
03:41:47 <exferenceBot>       ((,) f11 l) = f1 h
03:41:49 <exferenceBot>     in (f11 g, l)
03:41:52 <ski> quchen : no `(<*>)'
03:42:02 <roxxik> one for forward state and one for backward state
03:42:04 <quchen> Ah, right.
03:42:06 <merijn> ski: I know what it's good for, but I try really hard not too think about it too much, because thinking hard about Cont(T) has a tendency to fry my brain
03:42:56 <ski> some months ago, someone had some code in here, where i suggested using `ContT' to avoid boilerplate code
03:43:02 <ski> they seemed to be happy with it
03:43:44 <ski> (they came looking for a better way to express what they were doing, cutting down on the "noise" and inconvenience)
03:43:48 <merijn> ContT with bracket is nice, although I usually think the ContT wrapping adds about as much noise as just the regular version
03:44:06 <ski> it certainly depends on the situation
03:45:06 <ski> roxxik : you should (learn to) be able to derive those implementations yourself, by "following the types"
03:45:18 <Cale> :t runCont . sequence . map cont
03:45:21 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
03:45:35 <Cale> ^^ stuff like this can be pretty cute at times
03:46:59 <roxxik> ski: i did that with other stuff, just found out about exference bot and i'm wondering where the difference between the two versions is
03:47:08 <ski> in "Selection Functions, Bar Recursion, and Backward Induction" by Martín H. Escardó,Paulo Oliva in 2009-11-11 at <http://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf>, they do "products" of quantifiers, like Cale is alluding to, for reasoning about games (game theory) .. iirc including infinite games
03:47:26 <ski> roxxik : there's also `djinn'
03:47:41 <ski> @djinn-add type NotNot a = Not (Not a)
03:47:55 <ski> @djinn NotNot (a -> b) -> (NotNot a -> NotNot b)
03:47:56 <lambdabot> f a b c = void (b (\ d -> void (a (\ e -> c (e d)))))
03:48:13 <roxxik> sure, but that does not change the result: there are two possible ways to implement <*> for Cont and i'm wondering why only one is used
03:49:36 <ski> (obviously you can do the version with a final answer / result type ⌜ω⌝ (your `r'), instead of an "uninformative" (in some sense with information content of ⌜-∞⌝) `Void' answer type)
03:50:44 <merijn> Cale: You're a math-y person! I have a problem which I'm fairly sure *someone* has solved, but I don't have a clue which terminology to use to search for it, if you have a sec to listen to my description and see if it rings any bell I'd be grateful
03:52:03 <ski> roxxik : given one sequential ordering, you can derive the other one by changing the ordering, in a similar way to how for a `Monoid' instance, you can get the opposite ordering by using `Dual'
03:52:07 <ski> > getDual (Dual (First (Just 2)) <> Dual (First (Just 3))) :: First Integer
03:52:10 <lambdabot>  First {getFirst = Just 3}
03:52:48 <ski> roxxik : so it's about whether to first execute the first argument, or the second one
03:53:30 <roxxik> i just skimmed through the other one and saw that it's doing weird things with it's arguments...
03:53:56 <roxxik> `\f v c -> v \g -> f \h -> c (h g)`
03:53:57 <Cale> merijn: go for it
03:54:01 <merijn> Cale: So I have an N-dimensional space which I'm partitioning into a number of hypercubes (they're effectively bounding boxes of min/max pairs in each dimension). Now, given this I can pick a point in dimension D and compute the "cross-section" (i.e., which hypercube this plane bisects), and I would like to find out all the points where this crosssection "changes" (i.e., one of the hypercubes is no longer 
03:54:07 <merijn> intersected or a new hypercube is intersected), preferably I'd like to compute these points for every single dimension
03:54:44 <ski> roxxik : for a monad, you have a dynamic dependency of the second on the first, so there's only one possibility there (well, for state, there's the "backwards-in-time" version, but you need to tie a knot to do that, and it's easy to fall down the bottom of the well, if you're not careful (still it can be careful, e.g. for automatic differentiation, iirc). anyway, afaik, there's no such thing for `Cont')
03:55:41 <roxxik> f :: (((a -> b) -> r) -> r), v :: ((a -> r) -> r), c :: (b -> r), g :: a -> r, h :: (a -> b) -> r    (i inffered some stuff here myself, based on the lambda the variable is used in
03:55:57 <ski> roxxik : as i said, the two solutions exferenceBot gives are the two execution orderings (i just checked to make sure, but i was all but certain before foing that)
03:56:03 <Cale> merijn: like, the D-th projection of all the bounding coordinates of the hypercubes?
03:56:53 <ski> roxxik : for some reason, exferenceBot chose to obfuscate the second solution (iow first executing the action yielding the function), by using function composition ..
03:56:54 <Cale> merijn: well, wait, you said "plane"...
03:56:58 <roxxik> but what's the difference between the two solutions then? if ordering won't make a difference
03:57:20 <Cale> merijn: oh, no, I get what you mean there
03:57:26 <merijn> Cale: Maybe I'm describing things wrong, I'm generalising my own 3d intuition to >3 dimensions
03:57:41 <Cale> merijn: Yeah, seems like the Dth projection of the coordinates of the vertices of the cubes
03:57:42 <roxxik> ski: this is from transformers: f <*> v = ContT $ \ c -> runContT f $ \ g -> runContT v (c . g)
03:57:54 <ski> roxxik : so it's a choice between `\iab ia kb -> iab (\ab -> ia (\a -> kb (ab a)))' (the second solution exferenceBot gave) and `\iab ia kb -> ia (\a -> iab (\ab -> kb (ab a)))'
03:57:59 <Cale> merijn: they're axis-aligned, right? :)
03:58:19 <ski> roxxik : the former of these first executes `iab', then `ia'. the latter does the opposite order of execution
03:58:25 <Cale> Yeah, "min/max pairs in each dimension"
03:58:38 <roxxik> i saw that, i'm wondering what difference this makes
03:58:43 <merijn> Cale: Yeah
03:58:55 <ski> roxxik : that `ContT' version is the "first execute first/left argument" choice, which i think is reasonable as the "default"
03:59:13 <Cale> So, when you project along the Dth axis, your cross section always changes when you're hitting a vertex of some hypercube
03:59:18 <ski> roxxik : the difference is between executing left-to-right, or right-to-left
03:59:34 <Cale> Er, I could have worded that better
03:59:57 <roxxik> sure, but in a lazy language that difference won't matter. question is: can i use both versions interchangeable?
03:59:57 <Cale> As you select cross sections along the Dth axis
04:00:24 <Cale> So that'll be when you hit the min or max for one of the cubes in that direction.
04:00:28 <Cale> right?
04:00:34 <merijn> Cale: Right
04:00:41 <ski> roxxik : if `iab' in `iab <*> ia' expresses a universal quantifier, and `ia' an existential quantifier, then using left-to-right will express something of the shape `forall a. exists b. ..a..b..', while right-to-left will express something of the shape `exists b. forall a. ..a..b..' -- obviously these two are very different
04:01:37 <roxxik> oh
04:01:41 <ski> roxxik : "but in a lazy language that difference won't matter" is irrelevant. the language that `ContT' *expresses* is not that simple lazy language where order of execution doesn't matter. it definitely *does* matter !
04:02:25 <roxxik> i think i need some example to see how Cont behaves to understand this better...
04:02:39 <ski> roxxik : of course, we're expressing this *in* Haskell, and as Haskell expressions, it doesn't matter which order you *evaluate* (not execute) expressions (as long as you require the result of both)
04:02:55 <roxxik> yah
04:03:24 <roxxik> how can i "expresses a universal quantifier"?
04:04:01 <ski> roxxik : but just like you wouldn't think `do putStrLn "A"; putStrLn "B"' was the same as `do putStrLn "B"; putStrLn "A"', you shouldn't think `foo <$> ia <*> ib' is the same as `flip foo <$> ib <*> ia', in the case of `Cont'/`ContT' (or `State'/`StateT' or parsers, or ...)
04:04:01 <merijn> Cale: I was thinking of building an interval tree for each dimension and then storing, for each hypercube, it's range in the Dth dimension in its corresponding interval tree and then scanning for points where the set of intervals in the stabbing query changes, but I wasn't sure whether there's more sensible solutions
04:05:27 <Cale> Well, you can also just store the set of points
04:06:17 <Cale> (you probably need the intervals for other purposes, but it may for some purposes be more straightforward to lose them and just retain their endpoints)
04:06:20 <ski> @let forEach :: Foldable t => t a -> Cont Bool; forEach = cont . flip all
04:06:26 <lambdabot>  .L.hs:166:33: error:
04:06:26 <lambdabot>      • Expecting one more argument to ‘Cont Bool’
04:06:26 <lambdabot>        Expected a type, but ‘Cont Bool’ has kind ‘* -> *’
04:06:27 <merijn> hmmm
04:06:30 <ski> er, right
04:06:33 <ski> @let forEach :: Foldable t => t a -> Cont Boola ; forEach = cont . flip all
04:06:35 <lambdabot>  .L.hs:166:38: error:
04:06:35 <lambdabot>      Not in scope: type constructor or class ‘Boola’
04:06:35 <lambdabot>      Perhaps you meant ‘Bool’ (imported from Data.Bool)
04:06:45 <ski> @let forEach :: Foldable t => t a -> Cont Bool a ; forEach = cont . flip all
04:06:47 <lambdabot>  Defined.
04:06:49 <ski> @let forSome :: Foldable t => t a -> Cont Bool a; forSome = cont . flip all
04:06:52 <lambdabot>  Defined.
04:07:11 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
04:07:13 <lambdabot>  Defined.
04:07:24 <ski> @let evalContT :: Monad m => ContT o m o -> o; evalContT = (`runContT` return)
04:07:26 <lambdabot>  .L.hs:176:14: error:
04:07:26 <lambdabot>      • Couldn't match type ‘o’ with ‘m o’
04:07:26 <lambdabot>        ‘o’ is a rigid type variable bound by
04:07:33 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
04:07:35 <lambdabot>  Defined.
04:08:45 <ski> > evalCont (do x <- forEach [0,2,3,5]; y <- forSome [2,5,6]; return (x < y))
04:08:49 <lambdabot>  False
04:09:27 <ski> sorry, that should be
04:09:31 <ski> > evalCont (do x <- forEach [0,2,3,5]; y <- forSome [2,5,6]; return (x < y))
04:09:34 <lambdabot>  True
04:09:46 <ski> (`forSome' should of course use `any', not `all')
04:10:44 <ski> > evalCont (do x <- forEach [0,3,5]; y <- forSome [1,2,3,4,6]; return (x + 1 == y))
04:10:47 <lambdabot>  True
04:10:56 <ski> > evalCont (do y <- forSome [1,2,3,4,6]; x <- forEach [0,3,5]; return (x + 1 == y))
04:10:59 <lambdabot>  False
04:11:17 <ski> for each `x' in the given list, there's an `y' which is the successor of it
04:11:31 <ski> but there's not single `y' which is simultaneously the successor of all the `x's
04:11:49 <ski> roxxik : so that's a trivial example of when the ordering matters
04:18:51 <simli> I have some problems doing network communication with conduit, specifically combining it with protobuf and cereal-conduit
04:19:47 <simli> symptom is that about 50% my (simple) test works just fine, but the other half the connection closes before the server has read what it "should" have read
04:20:31 <simli> trying to figure out what is happening, I turned to the strace tool only to find that very little relevant information is printed
04:21:01 <simli> is there some trick to using strace with haskell programs? Or some other tool I can use to see what is going on?
04:21:21 <merijn> simli: strace only shows syscalls, though, so I wouldn't expect that to show much
04:21:44 <simli> merijn: I was looking for networking syscalls to see errnos and such
04:21:50 <merijn> simli: Well, one relevant thing would be
04:21:53 <merijn> @quote oasis
04:21:53 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:22:08 <merijn> simli: i.e. Debug.Trace.traceM
04:23:17 <merijn> simli: Connection closing before the server has read what it should sounds like there might be a bug in your parser? But I'm not too familiar with conduit, so I can't say much
04:23:21 <simli> merijn: that's a funny quote :D
04:24:06 <merijn> simli: Debug.Trace is a great module to ease printf debugging (with the usual caveat being horribly unsafe for production)
04:24:52 <simli> merijn: Thing is I've barely implemented any logic myself, protobuf can (and do in my case) use generics to derive instances... That said I have an even simpler example that works better
04:24:55 <merijn> simli: I'm thinking maybe your conduit exits before consuming all data, resulting in the connection closing
04:25:23 <simli> so it's certainly possible I've made a mistake. So i need insight into what my code does, so... tool :)
04:25:53 <merijn> simli: instrumenting your conduit with traceM could help see where it's terminating
04:26:12 <simli> merijn: I'll have a look at that for sure!
04:30:00 <roxxik> ski: i'll type those into my repl and see if i can make sense of the alternative <*> implementation, but thanks for the example
04:32:56 <ski> roxxik : i think there's something like `newtype Opposite i a = MkOpposite {runOpposite :: i a}' with `instance Applicative i => Applicative (Opposite i)' doing `i', but in the opposite order, but i'm not sure about the name, and in which package it would be
04:33:15 <roxxik> i'll search for it later
04:34:06 <roxxik> somethink like f <*> v = do { v' <- v; f' <- f; f v } ? (if it had a monad constraint)
04:34:22 <roxxik> return (f' v')
04:35:09 <simli> merijn: well reading some, I guess trace is a great tool to have, but most of my code actually has access to IO already. But get this, now I can't reproduce it anymore
04:35:21 <ski> roxxik : well, `MkOpposite iab <*> MkOpposite ia = MkOpposite <$> (flip ($) <$> ia <*> iab)' would probably be the simplest, readable, way of implementing it
04:35:40 <ski> roxxik : so, your basic idea was the right one, yes
04:35:47 <simli> scary race-like kind of problem, and it just vanishes. Also kind of like a race condition :S
04:36:31 <roxxik> hmm interesting... then it should always be possible to find an alternative Applicative ?
04:36:35 <roxxik> instance*
04:38:12 <roxxik> this would be the newtype wrapped cont: \f v -> cont $ \c -> runCont v $ \g -> runCont f $ \h -> c (h g)
04:38:16 <roxxik> :t \f v -> cont $ \c -> runCont v $ \g -> runCont f $ \h -> c (h g)
04:38:18 <lambdabot> Cont r (t -> a) -> Cont r t -> Cont r a
04:39:42 <ski> roxxik : compare with how `Dual' can be used, to get a `Monoid' instance with the opposite combination order, <https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html>
04:40:20 <roxxik> yah
04:42:26 <roxxik> my alternative apply behaves exactly the same as the original apply
04:42:36 <roxxik> (at least for the forEach, forSome examples
04:43:48 <roxxik> no it doesn't
04:44:03 <ski> how's your alternative defined ?
04:44:14 <thatguy> I have downloaded hoogle and searches like "hoohle map" do return something, but "hoogle [a] -> a" doesn't return anything
04:44:17 <roxxik> @let altAp f v = cont $ \c -> runCont v $ \g -> runCont f $ \h -> c (h g)
04:44:18 <thatguy> does anyone know why?
04:44:19 <lambdabot>  Defined.
04:44:36 <roxxik> > evalCont (((\x y -> x + 1 == y) <$> forEach [0,3,5]) `ap` forSome [1..6])
04:44:39 <lambdabot>  True
04:44:45 <roxxik> evalCont (((\x y -> x + 1 == y) <$> forEach [0,3,5]) `altAp` forSome [1..6])
04:44:54 <roxxik> > evalCont (((\x y -> x + 1 == y) <$> forEach [0,3,5]) `altAp` forSome [1..6])
04:44:57 <lambdabot>  False
04:45:15 <ski> looks fine, to me
04:45:34 <ski> those are supposed to give different answers (showing that the ordering matters)
04:45:46 <roxxik> the ordering of what?
04:45:56 <roxxik> what is the effect here?
04:46:08 <ski> the ordering of the action `forEach ...' wrt the action `forSome ...'
04:46:15 <roxxik> hmmm
04:46:18 <ski> the effect in this particular case is quantification
04:46:47 <alexv19> How is this module supposed to be used http://hackage.haskell.org/package/constraints-0.9/docs/Data-Constraint-Deferrable.html ? Can I use it to check if some instance is defined?
04:47:40 <ski> "Every pot has a lid." could be interpreted as saying that for each pot, there is a corresponding lid (which lid you take presumably depends on the pot chosen). or as saying that there is a lid which fits on every pot
04:48:02 <ski> in this particular example, the first reading would be the intended one
04:49:28 <ski> > (,) [0,1,2] `ap` "ab"
04:49:30 <lambdabot>  error:
04:49:30 <lambdabot>      • Couldn't match expected type ‘[Char -> b]’
04:49:30 <lambdabot>                    with actual type ‘b0 -> ([Integer], b0)’
04:49:41 <ski> > (,) <$> [0,1,2] `ap` "ab"
04:49:44 <lambdabot>  error:
04:49:44 <lambdabot>      • No instance for (Typeable a0)
04:49:44 <lambdabot>          arising from a use of ‘show_M15407747453764654999268’
04:50:01 <roxxik> > ((,) <$> [0,1,2]) `ap` "ab"
04:50:06 <lambdabot>  [(0,'a'),(0,'b'),(1,'a'),(1,'b'),(2,'a'),(2,'b')]
04:50:21 <ski> oh, brackets
04:50:24 * ski nods
04:50:31 <ski> > ((,) <$> [0,1,2]) `altAp` "ab"
04:50:34 <lambdabot>  error:
04:50:34 <lambdabot>      • Couldn't match type ‘[]’ with ‘ContT r Identity’
04:50:34 <lambdabot>        Expected type: Cont r (t -> (a, t))
04:50:36 <roxxik> :t altAp
04:50:38 <lambdabot> Cont r (t -> a) -> Cont r t -> Cont r a
04:50:39 * ski sighs
04:50:43 <ski> yeah, right
04:51:09 <ski> @let iab `pa` ia = flip ($) <$> ia <*> iab
04:51:11 <lambdabot>  Defined.
04:51:16 <ski> > ((,) <$> [0,1,2]) `pa` "ab"
04:51:18 <lambdabot>  [(0,'a'),(1,'a'),(2,'a'),(0,'b'),(1,'b'),(2,'b')]
04:51:53 <ski> in this case, the ordering of the actions in the list monad corresponds to "nesting" (outer "loop" vs. inner "loop")
04:52:03 <roxxik> i see
04:52:27 <ski> something similar, iow nesting, holds for the `Cont' case
04:53:41 <roxxik> so pa will behave the same for Maybe?
04:53:45 <roxxik> (as ap)
04:54:23 <ski> yes, since ordering doesn't matter there (at least if we ignore bottoms)
04:54:36 <ski> hm, actually ..
04:54:39 <ski> @type (<**>)
04:54:41 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
04:54:44 <ski> is `pa'
04:54:57 <ski> (hm, well almost, it's `flip pa')
04:55:16 <roxxik> ((,) <$> [0,1,2]) (flip <**>) "ab"
04:55:24 <roxxik> > ((,) <$> [0,1,2]) (flip (<**>)) "ab"
04:55:27 <lambdabot>  error:
04:55:27 <lambdabot>      • Couldn't match expected type ‘(f0 (a0 -> b1) -> f0 a0 -> f0 b1)
04:55:27 <lambdabot>                                      -> [Char] -> t’
04:55:50 <roxxik> > (flip (<**>)) ((,) <$> [0,1,2]) "ab"
04:55:52 <lambdabot>  [(0,'a'),(1,'a'),(2,'a'),(0,'b'),(1,'b'),(2,'b')]
04:56:01 <roxxik> ah ok
04:57:53 <ski> so `(<*>)' and `(<**>)' execute the actions in the visual order given (the second of them taking the function-yielding action after instead of before), while `pa'/`flip (<**>)' takes arguments of the same types as `(<*>)', but reverses the execution order to the reverse of the visual order
04:58:53 <ski> which makes sense, i think. i think it'd normally be more sensible to stick within a context to a single execution order, and then use `(<**>)' if you want the function-yielding action to be executed afterwards
04:59:36 * ski isn't really happy about the names `<$>',`<*>',`<*',`*>',`<**>', though ..
04:59:58 <roxxik> ah now i see a bit clearer, i can define the evaluation order of effects in an applicative
05:00:12 <ski> s/evaluation/execution/
05:00:30 <roxxik> where f <$> a <*> b  will evaluate a's effect first and b's second f <$> a <**> b will do it the other way around
05:00:44 <roxxik> ok execution order
05:01:04 <ski> for some idioms (`Maybe',`Reader r'), the execution order doesn't actually matter, but for some other idioms (`Writer w',`State s',`[]',`Cont o') it does matter
05:01:40 <ski> `f <$> a <**> b' will still execute the effect of `a' before the effect of `b'
05:01:40 <roxxik> i'd still need to know the effect of cont... it always confuses me :(
05:01:54 <merijn> roxxik: Feeling confused about Cont is normal :)
05:02:08 <roxxik> ski: shouldn't be
05:02:20 <ski> (or, stated another way : the compound/composite action will have effects composed from the effects of `a' before the effects of `b')
05:02:46 <roxxik> merijn: what's Cont actually useful for? haven't seen it in the wild
05:03:01 <merijn> roxxik: ContT is nice for capturing the pattern of nested brackets
05:03:31 <ski> `(<*>)' is `liftA2 ($)', while `(<**>)' is `liftA2 (flip ($))', the only difference is the result types of the two actions, and how we combine the two resulting values. the execution order of the arguments is the same
05:03:35 <merijn> roxxik: This has a nice example: https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
05:03:36 <roxxik> merijn: and where does that happen
05:03:55 <merijn> roxxik: When dealing with resource allocation/freeing (like opening files, FFI, etc.)
05:04:06 <roxxik> hmm ok
05:04:36 <merijn> roxxik: See also Tekmo's 'managed' package
05:04:51 <roxxik> ski: b <**> (f <$> a) i flipped the type D:
05:05:06 * ertes prefers Codensity of kan-extensions over 'managed'
05:05:14 <merijn> roxxik: https://hackage.haskell.org/package/managed-1.0.0/docs/Control-Monad-Managed.html <- this is basically a version of ContT
05:05:41 <merijn> ertes: Perhaps, but I doubt anyone will argue that that's more beginners friendly than Managed :p
05:06:46 <merijn> ertes: Because I still don't understand wtf kan extensions are
05:06:49 <ertes> merijn: you're underestimating beginners =)
05:07:01 <merijn> ertes: And Codensity (to me) is still just "DList generalised"
05:07:04 <ertes> merijn: me neither, but i can use Codensity anyway =)
05:08:10 <ski> merijn : that's funny, since i think of `DList' as a specialized version of continuation stuff :)
05:08:59 <roxxik> merijn: so nesting callbacks is the usecase of Cont?
05:09:11 <merijn> ski: I learned and understood DList first and then looked at Codensity (before it was called that) and went like "I'm thoroughly confused" and had the epiphany "this is just DList, but more general"
05:09:49 <merijn> roxxik: Cont can be used to use callbacks while writing "imperative/non-callback code"
05:11:30 <ski> Kan extensions are adjoints of precomposition functors (of the shape `(. g)', for some functor `g') ..
05:11:40 * ski idly wonders if/when/how adjoints of postcomposition functors turn up
05:12:04 <merijn> I don't understand what adjoints are either :p
05:12:14 <merijn> Or wtf precomposition functor means, for that matter :p
05:12:18 <roxxik> (how do i so this * <name> thing)? *  roxxik  still wonders what adjoints are
05:12:21 <ertes> roxxik: one way to use ContT is to "register" actions to be run after the whole ContT action
05:13:16 <ertes> roxxik: ContT (\k -> k 5)  -- this is a ContT action that does nothing and returns 5 (by calling the continuation with 5)
05:13:30 <merijn> roxxik: "/me <stuff here>"
05:13:32 <ski> if `g' is a functor from `C' to `D', then the precomposition with `g', `(. g)', is a functor from `E^D' to `E^C' (or from `D -> E' to `C -> E', if you prefer)
05:13:33 * merijn <stuff here>
05:13:38 <ertes> roxxik: now that 'k' is "the rest of the ContT action"
05:13:59 * roxxik has an aha-moment
05:14:01 <ertes> roxxik: ContT (\k -> k () `finally` putStrLn "Ok, done.")  -- so you can do this
05:14:15 <roxxik> those category things look like the functor instance for (->)
05:14:20 <ski> given any object in `E^D', which is a functor, say `f', from `D' to `E', it precomposes `f' with `g', iow `f . g' (so `g' "modifes" the input before it's passed to `f')
05:14:35 <ski> and that is a functor from `C' to `E', iow an object in `E^C'
05:14:43 <merijn> roxxik: If you're interested in Category Theory, have you seen Bartosz' blog series on it?
05:14:56 <c_wraith> roxxik: in that category (.) is standard function (.), which is also fmap for Functions, sure. :)
05:15:13 <merijn> roxxik: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
05:15:17 <ski> roxxik : i used `ContT' once to do cooperative multi-tasking
05:15:20 <roxxik> merijn: i' read some bits of it but as i arrived at adjoints i was already a little confused
05:15:41 <ski> merijn : makes any sense ?
05:16:05 <roxxik> so (. g) is a functor functor?
05:16:14 <ertes> roxxik: this is of course only one use case for ContT (and better handled by Codensity), but there are many other use cases…  sometimes it's used to provide an escape hatch out of a 'forever'
05:16:19 <merijn> ski: Honestly, not really :) Too abstract for me :)
05:16:49 <orion> What functions should I consider if I want to write an application which can load/execute other haskell shared libraries at runtime, given some "Plugin" typeclass?
05:17:07 <roxxik> ertes: sounds like this is needed for the more complex control flow, that i hadn't any need of yet
05:17:22 <ertes> roxxik: it's never *needed*, but sometimes it's convenient
05:18:14 <ertes> roxxik: remember that ContT is just a layer over regular functions…  anything you can implement with ContT can also be implemented without it
05:19:04 <ertes> just like ReaderT, which is also a layer around functions, except that ReaderT is never useful =)
05:19:31 <ski> merijn : if we have `foo :: forall a. F (G a) -> H a', a function that somehow traverses an `F' structure, with `G' structures inside, and produces an `H' structure as result, then by using a right Kan extension (`Ran'), we can "view" this as `toRan foo :: forall b. F b -> (Ran G) H b'. so now we appear to only be working on an `F' structure, and we've "instrumented" the outputted `H' structure with a `Ran G' annotation, meaning that eventually, the `b' ele
05:19:49 <ski> cut off near ".., and we've "instrumented" the outputted `H' structure with a `Ran G' annotation, meaning that eventually, the `b' elements should be (or be converted to) `G' structures of `a'"
05:20:04 <merijn> ski: My problem is that I need to generalise from concrete examples and CT is horrible for generalising from concrete examples :)
05:21:32 <ski> merijn : so, in a sense, by using `toRan', we've "curried" the formulation `(F . G) >---> H' into `F >---> (G -> H)', where `G -> H' here is the `(Ran G) H' above, and `>--->' is just "natural transformation", defined as `type NT f g = forall a. f a -> g a' (sometimes written as `~>', infix)
05:22:03 <roxxik> so Ran g h = g ~> h?
05:22:18 <ertes> merijn: if you want a less abstract explanation, just stare at the types from kan-extensions for five minutes
05:22:22 <ski> no, `blah >---> bleh' in my notation is `blah ~> bleh' in some other notation
05:23:10 <ertes> under all the CT terminology they are really useful *tools*
05:23:15 <ski> `(Ran g h) b' is in fact implemented as `forall a. (a -> g b) -> h b' .. but i'm not sure how much that helps
05:23:27 <roxxik> this looks like the laws of basic currying on a functor level
05:24:04 <merijn> ertes: Probably, but they're not tools I have much use for at this exact time and I don't have the time to invest in my free time to learn more :)
05:24:09 <ski> we've curried the transformation from a `G's-nested-inside-`F' structure to an `H' structure, to one which first only sees the `F' structure, and only after that gets to see the "inner" `G' structure
05:24:21 <ertes> merijn: Coyoneda TVar -- TVar with a functor interface =)
05:24:28 <ski> possibly this could be useful if the transformation can do useful work while only seeing `F'
05:25:28 <ski> (cf. defining `frob :: A -> (B -> C)', that analyzes `A' completely (usually recursively), before generating the function from `B' to `C'. e.g. `A' could be a description of a regular expression, and `frob' "compiles" it into a matcher)
05:25:32 <roxxik> ertes: but you need a Functor instance to lower it... how do you then use a Coyoneda TVar?
05:25:50 <ski> ertes : but `Yoneda' also adds a functor instance :)
05:25:51 <ertes> roxxik: you just pattern-match on it
05:25:55 <roxxik> oh
05:26:03 <mutsig> Does anyone have a good 'rule-of-thumb' of when to use Lazy Text vs Text?
05:26:12 <ski> roxxik : "this looks like the laws of basic currying on a functor level" -- exactly
05:26:40 <ski> roxxik : however, what the ramifications of this would be in practice, i'm not fully sure of, yet
05:27:10 <roxxik> ertes: Coyoneda just stores all the fmapped functions and won't apply them? i need to have a look at the implementation
05:27:29 <ski> yep
05:27:56 <ski> it'll leave to you how to actually get your `a' "out" of your `TVar a'
05:28:02 <ertes> mutsig: if in doubt lazy Text acts very much like an efficient String
05:28:10 <roxxik> ski: I've seen it being discussed somewhere in the context of Free encodings of monads, having quadratic runtime at worst...  and using Coyoneda / Codensity it was resolved...
05:28:29 <ertes> mutsig: while you would use strict Text in most cases, it's never wrong and a good default to use lazy Text, if you don't know how to pick
05:28:49 <merijn> mutsig: lazy Text allows for a sort of "stream" processing using lazy IO, which I'm personally not a fan of (issues with resource freeing, etc.), so i would almost always use strict Text and one of the stream processing libraries (pipes or conduit) if I wanted to do streaming
05:28:49 <ski> (in this case by converting it to `STM a', and then `fmap'ping your functions over that. iow you're "`fmap'"ping a conversion from `TVar' to `STM', over `Coyoneda TVar', getting `Coyoneda STM', which you can then trivially lower)
05:29:48 <systadmin> hi
05:30:04 <puregreen> I want something like 'isolate' from binary, but only enforcing the upper bound (i.e. “don't consume more bytes than X”). I haven't found anything in binary that could do that, so I wrote my own by ripping out the code of 'isolate' and modifying it in an obvious way. Are there any pitfalls that I don't know about? (Because I kinda feel that if it's not in 'binary', there might've been some reason for that.)
05:30:29 <ski> roxxik : basically, it's the same problem as left-associating `(++)', `(((xs0 ++ xs1) ++ xs2) ++ xs3) ++ xs4' will traverse `xs0' (or rather copies of it) four times, `xs1' three times, `xs2' two times, `xs3' one time
05:31:15 <merijn> puregreen: Well, if you allow consumption of less than X you need to remember to "put back" the leftover input
05:31:23 <puregreen> yep, I have done that
05:31:27 <ertes> ski: Yoneda is just the precomposition version of Coyoneda, right?
05:31:29 <ski> roxxik : only that here, it's left-associating `(>>=)', or doing repeated `fmap' traversals after each other, or .. -- where in each case you're only interested in the "final answer", you don't want to look at the intermediate results
05:32:15 <ertes> like: Yoneda precomposes in negative position, Coyoneda postcomposes in positive position (so it has the function as a field)
05:32:28 <ski> ertes : `CoYoneda f b = exists a. (f a,a -> b)',`Yoneda f a = forall b. (a -> b) -> f b'
05:33:12 <ski> ertes : so, looks like you're right
05:33:14 <roxxik> yah, i know, but it was discussed there that codensity is more then needed and a simple yoneda is enough yielding an encoding of F f = forall r. (a -> r) -> (forall x. (x -> r) -> f x -> r) -> r, which is a bit hard to untangle if not viewed through it's CT abstration
05:33:29 <mutsig> ertes, merijn : thx
05:34:12 <merijn> puregreen: Well, the only real downside would be "it could be expensive to compute"
05:34:17 <ertes> roxxik: understanding church encoding can help you understand something like that from a different angle
05:34:34 <puregreen> merijn: what do you mean by “expensive to compute”?
05:35:02 <ertes> roxxik: type List a = forall r. (a -> r -> r) -> r -> r  -- how is this a list type?
05:35:25 <merijn> puregreen: Well, grabbing a section and running a new parser on that could be expensive, depending on the size and subparser
05:35:28 <roxxik> :t foldr
05:35:30 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:36:02 <roxxik> :t \l f z -> foldr f z l
05:36:04 <lambdabot> Foldable t => t a -> (a -> b -> b) -> b -> b
05:36:17 <roxxik> fromList
05:36:43 <roxxik> :t \cl -> cl cons [] -- toList
05:36:44 <lambdabot> Cons s s a a => ((a -> s -> s) -> [t1] -> t) -> t
05:36:56 <roxxik> :t \cl -> cl (:) [] -- toList
05:36:59 <lambdabot> ((a -> [a] -> [a]) -> [t1] -> t) -> t
05:37:23 <roxxik> :t \cl -> cl (:) []  :: [a] -- toList
05:37:25 <lambdabot> error:
05:37:25 <lambdabot>     • Couldn't match expected type ‘(a0 -> [a0] -> [a0])
05:37:25 <lambdabot>                                     -> [t0] -> [a1]’
05:37:27 <roxxik> meh
05:37:29 <ski> @type GHC.Base.build
05:37:30 <roxxik> w/e
05:37:31 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
05:37:40 <ski> (it needs rank-2)
05:37:55 <roxxik> that can't be inferred?
05:38:07 <ski> well, technically i think it can, but GHC doesn't try
05:38:12 <roxxik> ah ok
05:38:12 <merijn> roxxik: In *theory* Rank2 is inferrable
05:38:24 <merijn> roxxik: But the implementation of Rank2 inference is hell, so GHC doesn't do it
05:38:36 <merijn> roxxik: RankN (with N>2) is proven impossible to infer
05:39:23 <ski> roxxik : hmm, your `F f a' looks like `Yoneda (\r -> Cont r (Coyoneda f r)) a' ..
05:40:02 <roxxik> you have a type level lambda there :O
05:40:12 <ski> well, yes
05:42:29 <ski> so for some reason we're making `f' into a functor (in one way) before feeding to `Cont', picking `r' both as final result type, and as "action result element type", and then turning the result of that into a functor (in the other way), before setting the "elemenr type" "viewed externally" to `a'
05:42:34 <quchen> :t \n c -> foldr c n -- ski, roxxik: no, it cannot be inferred, because it still typechecks when we float out the ∀, so the type is ambiguous with rank-2
05:42:36 <lambdabot> Foldable t => b -> (a -> b -> b) -> t a -> b
05:42:44 <quchen> :t build
05:42:45 <lambdabot> error:
05:42:46 <lambdabot>     • Variable not in scope: build
05:42:46 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
05:43:07 <quchen> Eh, see above. Anyway, both the existential-build and the universal-build typecheck.
05:43:17 <quchen> (And they are the same term.)
05:44:13 <ski> quchen : so you're saying "In *theory* Rank2 is inferrable" is false ?
05:44:47 <ertes> quchen: inferring an ambiguous type ≠ being unable to infer
05:45:27 <quchen> Okay, »uniquely inferrable«.
05:45:41 <ski> quchen : weren't we talking about `\cl -> cl (:) []', not `\n c -> foldr c n' (nor `\as n c -> foldr c n as') ?
05:45:45 <roxxik> ski: so expressed in haskells limited language what would that be? \r -> f r   <=> f ?
05:46:11 <quchen> ertes: Although in practice, making arbitrary choices during type inference is awkward.
05:46:25 <quchen> As in »Choose the one with the outermost foralls« or something.
05:46:35 <ski> roxxik : i'm not sure where this type `F f a' you mentioned comes from. were you suggesting that it was a representation of `CoDensity f a' ?
05:46:57 <roxxik> so \r -> Cont r (Coyoneda f r)  == type ContCoyoneda f r = Cont r (Coyoneda f r)
05:47:05 <roxxik> no it's a representation of Free
05:47:06 * ski . o O ( type inference with backtracking )
05:47:26 <roxxik> it's directly from https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free-Church.html specialized to Identity
05:48:07 <ski> (in L-lambda unification, there may be several "most general" unifiers (iow with a minimum of assumptions))
05:48:15 <reactormonk> Does someone have a good documentation about lenses? I have a rough idea how they work, but that's about it.
05:48:41 <merijn> reactormonk: There's a good talk by edwardk on youtube (and I think SPJ has a talk too)
05:48:44 <merijn> @where lens
05:48:44 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
05:49:04 <reactormonk> merijn, I wanted to avoid a talk, so I can read it at my own pace
05:49:34 <ertes> reactormonk: if you want the quickest possible intro, i can give you my patented Three Lens Exercises =)
05:49:46 <reactormonk> ertes, go ahead
05:49:54 * ski . o O ( "that's patently false" )
05:50:17 <roxxik> ski: so F f a = Yoneda (ContCoyoneda f) a?
05:50:29 <ertes> reactormonk: 1. write a function that maps over the fst of a tuple:  mapFst :: (a -> b) -> (a, c) -> (b, c)
05:50:46 <reactormonk> ertes, using which functions?
05:50:53 <ertes> reactormonk: whatever you like
05:51:00 <ski> roxxik : yep
05:51:43 <roxxik> ski: that's not looking particularly enligthening to me... but i'll look into it
05:51:47 <ski> @where SEC
05:51:47 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
05:51:58 <ski> reactormonk : ^ might be interesting
05:52:05 <ski> reactormonk : i don't think so, either ..
05:52:12 <ski> er
05:52:14 <reactormonk> :t fun f t = (fst t, snd $ f t)
05:52:15 <ski> roxxik ^
05:52:16 <lambdabot> error:
05:52:16 <lambdabot>     parse error on input ‘=’
05:52:16 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
05:52:25 <reactormonk> hmmm, how do I put them in there?
05:52:32 <ski> (the first suggestion was for reactormonk, though)
05:52:37 <ertes> :t \f t -> (fst t, snd (f t))
05:52:39 <lambdabot> ((t, b) -> (a, t1)) -> (t, b) -> (t, t1)
05:52:48 <ertes> reactormonk: doesn't look right
05:52:57 <reactormonk> ah, first
05:53:05 <ski> @type let fun f t = (fst t,snd $ f t) in fun  -- alternative
05:53:07 <lambdabot> ((t, b) -> (a, t1)) -> (t, b) -> (t, t1)
05:53:42 <reactormonk> :t \f t = (f $ fst t , snd t)
05:53:43 <lambdabot> error:
05:53:43 <lambdabot>     parse error on input ‘=’
05:53:43 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
05:53:56 <reactormonk> :t \f t -> (f $ fst t , snd t)
05:53:58 <lambdabot> (a -> t) -> (a, t1) -> (t, t1)
05:54:07 <ski> good
05:54:15 <ertes> reactormonk: correct (hint: you can pattern-match: \f (x, y) -> (f x, y)
05:54:33 <reactormonk> :t \f (a, b) -> (f $ a, b)
05:54:37 <lambdabot> (t2 -> t) -> (t2, t1) -> (t, t1)
05:54:40 <ertes> reactormonk: 2. write a function that extracts the fst using a function:  getFst :: (a -> r) -> (a, b) -> r
05:54:49 <reactormonk> :t \f (a, _) -> a
05:54:54 <lambdabot> t -> (t1, t2) -> t1
05:54:59 <ertes> nope
05:55:04 <reactormonk> ah, a function
05:55:06 <reactormonk> :t \f (a, _) -> f a
05:55:09 <lambdabot> (t1 -> t2) -> (t1, t) -> t2
05:55:11 <ertes> correct
05:55:18 <reactormonk> Now make a lens out of it?
05:56:02 <ertes> reactormonk: 3. generalise the function from exercise 1 to a traversal and see if you can come up with an 'f' that also supports the second kind of usage:  traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
05:56:23 <ertes> this is like mapFst, but supports effects for the function
05:58:33 <reactormonk> Can I have anonymous functions with TC constraints?
05:58:49 <ertes> reactormonk: sure, they will be inferred
05:59:57 <ski> (unless you want your higher-order function to pick the constraint for the callback operation, in which case you need rank-2 ..)
06:00:52 <reactormonk> gotta, go, I'll scroll back in a few hours.
06:01:37 <ertes> reactormonk: once you get back and solve exercise 3 here is the fun part:  traverseFst is a lens into the fst of tuples =)
06:03:02 <roxxik> :t _1 :: Lens (a,b) a
06:03:04 <lambdabot> error:
06:03:04 <lambdabot>     • Expecting two more arguments to ‘Lens (a, b) a’
06:03:04 <lambdabot>       Expected a type, but ‘Lens (a, b) a’ has kind ‘* -> * -> *’
06:03:09 <roxxik> :t _1 :: Lens' (a,b) a
06:03:11 <lambdabot> Functor f => (a -> f a) -> (a, b) -> f (a, b)
06:04:04 <ertes> reactormonk: the idea is that with different choices for 'f' this will be either mapFst or getFst
06:14:47 <merijn> Is there a typeclass to show directly to Text or should I just do "T.pack . show"?
06:15:35 <roxxik> :t traverseOf
06:15:35 <ertes> merijn: the latter is fine most of the time…  showsPrec is surprisingly efficient
06:15:37 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
06:15:50 <merijn> ertes: It's only for logging errors anyway
06:15:57 <merijn> ertes: It's just so annoyingly verbose :p
06:16:31 <ertes> merijn: well, you don't have to use Show to use ShowS…  just show the parts you care about =)
06:17:30 <ertes> showString "Got " . maybe (showString "nothing") (showsPrec 10) mx
06:20:11 <merijn> ertes: If only I had something that elegant :p
06:22:30 <merijn> ertes: Suggestions on how to make this suck less welcome: http://lpaste.net/2233214326259318784 :p
06:23:05 <merijn> hmm, maybe mconcat with a list of elements
06:24:45 <merijn> Is there some haskelly version of printf/format strings?
06:25:02 <zipper> merijn: I think from Data.Text there is
06:25:08 <zipper> :t Data.Text.printf
06:25:10 <lambdabot> error:
06:25:10 <lambdabot>     Not in scope: ‘Data.Text.printf’
06:25:10 <lambdabot>     No module named ‘Data.Text’ is imported.
06:25:14 <zipper> What?
06:25:28 <zipper> :t Text.printf
06:25:30 <lambdabot> error:
06:25:30 <lambdabot>     Not in scope: ‘Text.printf’
06:25:30 <lambdabot>     No module named ‘Text’ is imported.
06:25:40 <zipper> merijn: https://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Printf.html
06:25:48 <zipper> idk why lambdabot is being mean
06:26:07 <merijn> Text.Printf is rather ugly, though since there's no validation
06:26:42 <zipper> Oh you asked a haskelly version idk what that even means :P you mean like validation that %s is taking a string?
06:26:47 <zipper> and %d an int?
06:26:53 <zipper> etc?
06:27:24 <merijn> Text.printf doesn't even check it gets the right number of arguments
06:27:40 <zipper> Oh
06:27:52 <ertes> merijn: if you lay out that code properly it doesn't look so ba
06:27:53 <ertes> bad
06:28:12 <merijn> ertes: I'm not sure how to lay it out properly, though, that's my problem :)
06:30:05 <zipper> merijn: I'm debugging JS from my DOM using XPath right now stop making me feel bad :(
06:30:22 <ertes> merijn: see annotation
06:31:14 <merijn> ertes: Yeah I was thinking of doing similar, but with mconcat and a list
06:31:52 <ertes> merijn: BTW, i would expect this to be more efficient, if you do all of the rendering with ShowS
06:32:11 <zipper> ertes: ShowS?
06:32:30 <ski> @src ShowS
06:32:31 <lambdabot> type ShowS = String -> String
06:32:34 <ertes> logErrorN . ($ "") $ showString "Wrong duplicate rating for game #" . shows k . …
06:32:44 <ski> @src Show
06:32:44 <lambdabot> class Show a where
06:32:45 <lambdabot>     showsPrec :: Int -> a -> ShowS
06:32:45 <lambdabot>     show      :: a -> String
06:32:45 <lambdabot>     showList  :: [a] -> ShowS
06:32:51 <ski> @type showParen
06:32:51 <ertes> alternatively you can use the Builder interface for Text
06:32:52 <lambdabot> Bool -> ShowS -> ShowS
06:32:54 <ski> @type showString
06:32:55 <lambdabot> String -> ShowS
06:32:58 <ski> @type showChar
06:33:00 <lambdabot> Char -> ShowS
06:33:13 <merijn> ertes: Probably, but from my one small sample to end up with say 2 errors per 200-300 entries, so not too worried about performance
06:33:46 <ski> @type [showFFloat,showEFloat,showGFloat]
06:33:48 <lambdabot> RealFloat a => [Maybe Int -> a -> ShowS]
06:33:53 <merijn> ertes: Additionally, I have plenty of time for processing, since my queries are rate limited anyway :p
06:35:25 <ski> see `Numeric' for a couple of more
06:35:58 <merijn> oh, this seems like a good application of "appEndo . mconcat . coerce" :p
06:36:00 <ertes> merijn: it's probably also easier to write, because you have all the rendering options =)
06:36:14 <merijn> :t appEndo . mconcat . coerce
06:36:16 <lambdabot> error:
06:36:16 <lambdabot>     Variable not in scope: coerce :: a1 -> [Endo a]
06:36:18 <ertes> not sure if it's useful in your case though
06:36:19 <merijn> aww
06:37:05 <merijn> :t appEndo . mconcat . coerce $ [id]
06:37:07 <lambdabot> error:
06:37:07 <lambdabot>     Variable not in scope: coerce :: [a0 -> a0] -> [Endo a]
06:37:18 <merijn> Shouldn't that work?
06:37:23 <ertes> @let import Data.Coerce
06:37:25 <lambdabot>  .L.hs:80:1: error:
06:37:25 <lambdabot>      Data.Coerce: Can't be safely imported!
06:37:26 <lambdabot>      The module itself isn't safe.
06:37:38 <merijn> oh, misread the error
06:38:06 <ertes> you've fallen for "there's a type, so it must be a type error" =)
06:38:37 <c_wraith> I always think appEndo sounds like a spell from Harry Potter 
06:38:49 <merijn> c_wraith: Well, it is basically magic...
06:41:04 <merijn> Magic oneliner: "renderString = T.pack . ($"") . appEndo . mconcat . coerce"
06:41:12 <merijn> The only ugly bit is ($"")
06:41:44 <ertes> merijn: if you want to go overboard, you can implement a printf-style interface for logErrorN =)
06:49:08 <merijn> ertes: That bleeds into too much work territory :p
07:14:04 <ertes> merijn: https://gist.github.com/esoeylemez/2d5f25681c3a41c3633bd2566ce61501
07:14:12 <ertes> not too much work =)
07:14:44 <ertes> printf "Blah % and blubb %." 3 5 :: String
07:15:31 <merijn> ertes: Yes, but that's terribad, because you don't check arguments ;)
07:15:45 <ertes> merijn: what do you mean?
07:16:15 <ertes> i'm only doing placeholdering, so there is really nothing to check
07:22:50 <tsahyt> Is there a way to get a heap profile from an application that I abort on the command line? 
07:23:40 <tsahyt> nevermind, -hc actually works, it's -p that doesn't.
07:24:52 <merijn> It's time for my monthly "I wish Haskell had multi-patterns like Ocaml" dream
07:25:36 <lep-delete> example?
07:26:19 <merijn> case foo of { Foo | Bar -> doX; Baz | Quux -> doY; Xyzzy -> doZ }
07:27:15 <lep-delete> i c
07:27:34 <merijn> In haskell you end up having to write doX and doY twice
07:27:54 <nitrix> The compiler would be able to distinguish the multi-pattern from guards because of the capital letter...
07:28:09 <merijn> nitrix: Could even invent different syntax for multi-patterns
07:28:14 <nitrix> Yet I think it'd made the code harder to read. I'm too used to guards being associated to |
07:28:25 <merijn> I don't necessarily want the same syntax, just multi-patterns :)
07:28:49 <nitrix> merijn: Do we have patterns being able to fall through on success?
07:29:00 <merijn> nitrix: No
07:30:13 <Billifischmaul> hi, im new to Haskell and heard foldr can handle infinite lists, but when I try to feed foldr an infinite list it will freeze. What did I do wrong? http://lpaste.net/4324348858034290688
07:30:55 <nitrix> isFooOrBar Foo = True; isFooOrBar Bar = True; isFooOrBar _ = False;     case () of _ | isFooOrBar -> ...
07:31:04 <nitrix> merijn: "Multi-patterns" :D
07:31:05 <lpaste> merijn pasted “simplify?” at http://lpaste.net/351824
07:31:21 <merijn> I have that, which annoys me to no end...
07:31:43 <nitrix> merijn: What about having the two patterns which simply calls the same body implementation in both cases?
07:31:54 <nitrix> I think that'd read nice too.
07:32:26 <merijn> nitrix: Yeah, usually, and that's mostly what I already have (see paste), but it still bothers me
07:33:42 <nitrix> Ah I see. 
07:33:54 <nitrix> merijn: Could it be a sign that your data type needs to be split differently?
07:34:18 <merijn> nitrix: I could split it into a two-level ADT, but that'd make my SQL table annoying to work with
07:34:26 <merijn> nitrix: So if this was just Haskell, yes
07:34:33 <nitrix> data Foo = Board Bool | Video Bool -- Where Bool relates to the property of being an expension or something.
07:34:37 <nitrix> Now you could do:
07:34:51 <nitrix> case ty of Board _ -> ...; Video _ -> ...
07:34:59 <ClaudiusMaximus> Billifischmaul: what does 'distinct' do?  if i remove distinct, i get a stack overflow, which i can solve by moving (h :) in front of the ifs instead of within each case
07:37:29 <ertes> Billifischmaul: (==) is your culprit
07:37:38 <ertes> Billifischmaul: use 'null'
07:37:44 <ClaudiusMaximus> Billifischmaul: in fact moving the  h:  outside the ifs is required to make the folded function productive, and thus the take 20 of the foldr terminate - otherwise it has to traverse the whole list to see whether t is null or not
07:37:54 <ertes> Billifischmaul: ah, no…  it should work in this case
07:38:17 <ertes> Billifischmaul: anyway, your fold is strict in the second argument
07:38:28 <Billifischmaul> <ClaudiusMaximus>: distinct is just a copy/past error, sorry. What do you mean by moving h: outside?
07:38:59 <ClaudiusMaximus> Billifischmaul: instead of if ... then h:... else h:...  why not  h : if ... then ... else ...
07:39:46 <ertes> > foldr (\x ys' -> case ys' of [] -> [x]; (y:ys) -> if x == y then y:ys else x:y:ys) [] "abbcddeeeeeef"
07:39:49 <lambdabot>  "abcdef"
07:39:54 <ertes> > foldr (\x ys' -> case ys' of [] -> [x]; (y:ys) -> if x == y then y:ys else x:y:ys) [] [0..]
07:39:57 <lambdabot>  *Exception: stack overflow
07:42:15 <Billifischmaul> <ClaudiusMaximus>: thanks! thats smart
07:42:52 <ertes> > foldr (\x go -> maybe (x : go (Just x)) (\y -> (if x == y then id else (x :)) (go (Just x)))) (const []) "abbcddeeeeeef" Nothing
07:42:54 <lambdabot>  "abcdef"
07:42:58 <ertes> > foldr (\x go -> maybe (x : go (Just x)) (\y -> (if x == y then id else (x :)) (go (Just x)))) (const []) [0..] Nothing
07:43:00 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:43:09 <ertes> as far as i see this can only be done with a stateful fold
07:43:52 <ClaudiusMaximus> > take 20 (foldr (\h t -> h : case t of [] -> [] ; yys@(y : ys) | h == y -> ys | otherwise -> yys) [] [x `div` 3 | x <- [1..]])
07:43:52 <orion> Are there any batch/job scheduling libraries/programs available specifically for Haskell?
07:43:54 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
07:45:05 <ertes> ah, of course
07:48:10 <ertes> orion: none that i know of, but i've implemented a function that waits until a certain point in time, which you might find useful
07:48:42 <ertes> orion: https://hackage.haskell.org/package/timelike-0.2.2/docs/Data-Time-Class.html#g:5
07:48:47 <ertes> see delayUntil
08:01:15 <tsahyt> ertes: I've been looking at the wires github repo again lately. Is it still being developed?
08:03:48 <Guest74313> Hi
08:04:25 <Guest74313> Does anyone have a simple example for how to build a boolean expression parser in haskell?
08:05:10 <tsahyt> Guest74313: what parser library are you using?
08:05:39 <tsahyt> if you're using Megaparsec, you might want to look at the Text.Megaparsec.Expr module, which aids in building expression parsers
08:05:56 <orion> ertes: Thank you.
08:06:13 <Guest74313> tsahyt: but I need a library for do that?
08:06:38 <tsahyt> Guest74313: you don't *need* a library to do anything, but usually you'd use a library for building parsers, yeah.
08:06:50 <tsahyt> Even just using the stuff in base is technically using a library
08:07:48 <Guest74313> Ok, but I have to do the parser using the standard library as an exercise for school course
08:07:57 <Guest74313> So I don't think that I can use an external library
08:08:10 <tsahyt> there's stuff to build parser combinators in base too. Look at Text.ParserCombinators.ReadP
08:08:36 <tsahyt> in particular I think the chain* combinators are what you want for expression parsing
08:08:56 <Guest74313> tsahyt: thanks
08:10:23 <tsahyt> @hoogle assertM
08:10:24 <lambdabot> module Test.Framework.AssertM
08:10:24 <lambdabot> Test.Framework.AssertM class Monad m => AssertM m
08:10:24 <lambdabot> Control.Error.Safe assertMay :: Bool -> Maybe ()
08:10:34 <byorgey> Guest74313: if you are supposed to build a parser using stuff in the base library, then probably the intention is not for you to use ReadP.
08:10:47 <byorgey> Guest74313: without knowing more about your assignment and what you have tried already it is very hard for us to help.
08:10:54 <tsahyt> hmm, I suppose when I want assertions in monadic code, I should use assert foo (return ()) then or so?
08:12:14 <byorgey> tsahyt: sure
08:12:25 <byorgey> you can put anything as the second argument.
08:12:40 <tabaqui1> question for an interview:
08:12:43 <tsahyt> with optimizations on, this gets transformed to return (), which should get optimized out in a next step then, right?
08:13:04 <reactormonk> Anything against just using the lens hackage package?
08:13:05 <tabaqui1> is (_:x:_) a butt-sign or a valid Haskell construction?
08:13:28 <tsahyt> tabaqui1: it's valid
08:13:30 <byorgey> tsahyt: quite possibly, but if it really matters you would have to look at the generated core
08:13:34 <MarcelineVQ> when you just want number 2...
08:13:37 <tabaqui1> tsahyt: I know)
08:13:44 <tabaqui1> first comment from thread
08:13:55 <tabaqui1> butt is a valid Haskell construction
08:13:57 <byorgey> tabaqui1: if that was supposed to be a joke, it's not very funny.
08:17:20 <Guest74313> byorgey: "without knowing more about your assignment" the only assignment is to build a parser for boolean expression. Nothing more
08:17:39 <byorgey> Guest74313: your assignment literally says "Build a parser for boolean expressions." ?
08:17:46 <Guest74313> Yes
08:17:54 <byorgey> just those six words?
08:18:36 <Guest74313> nothing more
08:19:07 <byorgey> Guest74313: have you talked about boolean expressions in class?  have you talked about parsers?
08:19:27 <merijn> If I wanna rate limit, e.g. outgoing HTTP requests any suggestions? Do I just allocate a QSem and have a thread periodically incrementing it while all HTTP queries requiring a decrement on it before sending the request?
08:19:59 <Guest74313> byorgey: Yes but not in haskell. we have built a parser in java
08:20:39 <Guest74313> byorgey: so I'm looking something to start to create my own parser
08:20:45 <byorgey> Guest74313: ok.  And how did the java parser work?
08:21:04 <byorgey> Was it a recursive descent parser?  Or did you use some kind of parser framework?
08:21:42 <mrkgnao> I'm working with a simple monad transformer stack for the first time, and it seems like things are finally making sense. Plus lenses, woo!
08:22:51 <mrkgnao> I'm so happy %= exists. I had a ton of modify $ thing %~ f lines everywhere.
08:23:50 <byorgey> mrkgnao: =D
08:24:56 <joeyh> bitemyapp: you fixed esqueleto?!
08:24:59 <joeyh> big hug!
08:30:57 <reactormonk> Is there `a -> List a`?
08:32:01 <byorgey> reactormonk: sure, e.g.   \x -> [x]
08:32:15 <byorgey> reactormonk: you can also write  return  or  (:[])
08:32:16 <reactormonk> so no built-in function?
08:32:19 <kadoban> 'pure' or '(:[])' or that, or repeat (you probably don't want that one though)
08:32:27 <byorgey> > return 1 :: [Int]
08:32:30 <lambdabot>  [1]
08:32:30 <reactormonk> ah, works
08:32:36 <orzo> does it have a runtime cost to add a bang (!) to something that will be evaluated strictly anyway?
08:33:29 <tsahyt> orzo: will it be evaluated right then and there?
08:34:03 <orzo> well suppose you use $! to apply a function that itself used ! on the argument
08:34:48 <tsahyt> as far as I know that shouldn't incur any extra cost
08:35:22 <tsahyt> orzo: but when in doubt, benchmark
08:43:17 <c_wraith> it can add extra cost. 
08:43:47 <c_wraith> it may not, depending on whether the optimization passes notice the same thing is being done twice in a row. 
08:45:32 <tsahyt> but surely it's only ever going to be evaluated once
08:46:40 <c_wraith> there's a non-zero cost to checking that something is already evaluated, even if it's less than the cost of doing the evaluation 
08:46:56 <tsahyt> hmm I hadn't thought of that
08:55:03 <reactormonk> Does something like [(a, Maybe b)] -> [(a, b)] already exist?
08:56:50 <kadoban> :t catMaybes . map sequence
08:56:53 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
08:57:16 <kadoban> :t catMaybes . map sequence :: [(a, Maybe b)] -> [(a, b)]
08:57:18 <lambdabot> [(a, Maybe b)] -> [(a, b)]
08:57:38 <kadoban> Ya, that unifies. So you convert it into [Maybe (a, b)]   and then just use catMaybes
09:02:44 <tsahyt> @djinn (a, Maybe b) -> Maybe (a,b)
09:02:44 <lambdabot> f (a, b) =
09:02:44 <lambdabot>     case b of
09:02:44 <lambdabot>     Nothing -> Nothing
09:02:44 <lambdabot>     Just c -> Just (a, c)
09:02:45 <reactormonk> Is there a better way to write `fmap ("redirect_uri",) $ fmap serializeURIRef' $ oauthCallback oa`
09:02:55 <tsahyt> well that wasn't as helpful as I hoped
09:05:33 <tsahyt> @hoogle (a, f b) -> f (a,b)
09:05:34 <lambdabot> Music.Theory.Tuple t2_sort :: Ord t => (t, t) -> (t, t)
09:05:34 <lambdabot> Data.Vector.Hybrid projectFst :: Vector u v (a, b) -> u a
09:05:34 <lambdabot> Data.Vector.Hybrid projectSnd :: Vector u v (a, b) -> v b
09:05:49 <tsahyt> hmm, surely there must be something like that somewhere
09:06:02 <roxxik> :t _2 :: Lens' (a,b) b
09:06:04 <lambdabot> Functor f => (b -> f b) -> (a, b) -> f (a, b)
09:06:19 <tsahyt> :t sequenceA
09:06:21 <MarcelineVQ> tsahyt: yes it's called sequence as kadoban used :>
09:06:23 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:07:29 <tsahyt> I gotta remember that, I have this sort of transformation happening way too often
09:08:23 <tsahyt> and (,) <$> pure (fst x) <*> snd x is very unsatisfying
09:08:45 <tsahyt> sometimes I can't see the forest for all the trees I suppose
09:09:09 <mwl> hey haskell, um, i have a question
09:09:15 <MarcelineVQ> reactormonk: fmap f . fmap g = fmap (f . g)    so if I'm reading your text correctly, an improvement could be:   fmap (("redirect_uri",) . serializeURIRef') $ oauthCallback oa
09:10:42 <roxxik> :t \k (a,b) -> (, a) <$> k b
09:10:44 <lambdabot> Functor f => (t2 -> f t) -> (t1, t2) -> f (t, t1)
09:10:59 <tsahyt> mwl: just ask
09:12:12 <roxxik> :t _2 id `asAppliedTo` ("hello", pure 2)
09:12:14 <lambdabot> (Applicative f, Num b) => ([Char], f b) -> f ([Char], b)
09:13:53 <mwl> so, while running with ghci, and ":load"ing the haskell code, the lines print out exactly how I want them, but when compiling with ghc, it seems to skip one line of execution, then print two lines in the same line
09:14:04 <mwl> let me grab the code so you can see what im talking about
09:14:41 <mwl> import Control.Monad
09:14:41 <mwl> main :: IO ()
09:14:41 <mwl> main = forever loop
09:14:41 <mwl> loop = do
09:14:41 <mwl>     putStr ">> "
09:14:44 <mwl>     cmdInput <- getLine
09:14:46 <mwl>     putStrLn ( "you said: " ++ cmdInput)
09:14:49 <phadej> use pastebins
09:14:57 <mwl> shit, my b
09:15:07 <phadej> e.g. http://lpaste.net/
09:15:14 <phadej> np
09:15:31 <mwl> the code: http://pastebin.com/n6HQGWCa
09:18:35 <ph88^> mwl, maybe after cmdInput you need to print another ln ?
09:18:43 <MarcelineVQ> possilby some sort of buffering issue in your terminal :X your code works for me in ghci and compiled
09:19:01 <ph88^> MarcelineVQ, maybe try without ghci
09:19:13 <zipper> How do you guys mock network calls?
09:19:42 <mwl> yeah it works exactly how i want in ghci, but actually compiling it seems to not work
09:19:57 <zipper> Is this a thing https://haskell-servant.readthedocs.io/en/stable/ ?
09:20:07 <mwl> i thought it may be a terminal buffering thing but i'm not sure how to test that
09:20:16 <mwl> zipper: checking that out
09:20:41 <MarcelineVQ> zipper: what are you asking? :>
09:21:10 <mwl> oh my b zipper, thats something else
09:21:20 <zipper> MarcelineVQ: I have a function that reads a lazy bytestring off the network, I probably want to use pipes for this though.
09:21:38 <zipper> Anyway I want to be able to test that it only reads part of the file and such
09:22:09 <glguy> mwl: The stdout in a compiled program using LineBuffering by default
09:22:11 <MarcelineVQ> ah I meant about servant sorry, it is indeed a thing and quite interesting
09:22:18 <zipper> I need to make e.g a get request for a larger then 32 kb resource and check that it only read 32 kb
09:22:27 <glguy> mwl: If you want to print a partial line you'll need to use hFlush stdout
09:22:38 <zipper> MarcelineVQ: Oh ok is it easy to use servant to mock a webserver?
09:22:49 <zipper> mwl: What do you mean?
09:22:51 <glguy> mwl: GHCi disables buffering
09:23:49 <mwl> glguy: ah, ty. i'll try to use hFlush and see if that works
09:24:16 <mwl> zipper: sorry, thougt your question was a suggestion for my question, but it was completely unrelated...
09:25:10 <zipper> MarcelineVQ: As I read the doc I see the :> pun haha
09:25:27 <MarcelineVQ> coincidence but fitting
09:26:08 <tsahyt> mwl: http://sprunge.us/HOWS an alternative way to disable the buffering
09:26:27 <MarcelineVQ> it's easy to get a webserver started with servant, I don't have enough experience with it and servers in general to say much more than that though
09:27:20 <MarcelineVQ> possibly better off with scotty if you want something to just get working on right away, not sure
09:29:34 <mwl> glguy: using hFlush worked, ty :)
09:29:53 <tsahyt> mwl: you can just disable the buffering altogether too if you need to
09:29:55 <tsahyt> in some cases that makes sense
09:30:13 <dfrown> What is the current, best way to learn Haskell? Is haskellbook good enough?
09:30:33 <mwl> tsahyt: i think i prefer your solution actually, for what i'm trying to do
09:30:40 <bitemyapp> joeyh: Barely, I just picked up maintenance.
09:30:56 <bitemyapp> joeyh: upgrading to 2.5 was a matter of reusing an existing fork I'd been kicking around (I didn't write that)
09:31:29 <bitemyapp> joeyh: Persistent 2.5 that is. mrkkrp brought it up to persistent 2.6 and base 4.9
09:31:41 <ryantrinkle> does anyone know of a utility that can automatically split a package into two (or more?) packages?
09:31:51 <ryantrinkle> e.g.: suppose I have a package with Foo.Bar and Foo.Baz
09:31:56 <ryantrinkle> and i'd like Foo.Bar to be in its own package now
09:32:08 <MarcelineVQ> dfrown: if you mean haskell programming from first principles, yes it's certainly good enough
09:32:31 <mwl> yeah tsahyt, ty, i like that 
09:32:43 <stephaner> hi everyone, I have the impression that stack clean then stack build does not reflects my code modifications in the generated executable. And if I do stack clean, then stack exec my-executable still works. Any idea what I should check to know what's wrong ?
09:33:00 <dfrown> MarcelineVQ thanks! That's all the confirmation I need
09:33:55 <tsahyt> mwl: keep in mind that in some cases buffered output is more performant for when you're doing a lot of print calls
09:35:24 <MarcelineVQ> stephaner: you might need   stack clean --full  I'm having trouble finding in the documentation what stack clean actually cleans
09:36:07 <kadoban> stephaner: Check 'stack exec -- which my-executable'
09:36:51 <mwl> tsahyt: if i left buffered output on, whats the best way to avoid messing up the print order like i had before?
09:37:07 <tsahyt> mwl: explicitly flushing when you need to
09:37:24 <tsahyt> you could of course also define a putStr' that is "strict" in its output, i.e. flushes immediately
09:37:27 <mwl> tsahyt: so use hFlush pretty much?
09:37:43 <tsahyt> putStr' x = putStr x >> hFlush stdout
09:38:06 <mwl> ahh ic ic
09:39:18 <stephaner> kadoban: stack exec --which my-executable doesnt seem to work. the command does seem to accept the --which flag
09:39:29 <MarcelineVQ> the space after -- is important
09:39:42 <kadoban> stephaner: There's a space that was intended
09:41:44 <MarcelineVQ> stack clean doesn't delete  .stack-work/install so your exe will still exist after a clean, you could try  stack build --force-dirty  and see if that rebuilds things
09:43:15 <MarcelineVQ> you should check in a basic way whether modifcations to your code produce a changed executable, something simple like spitting out a string in main or from the module you suspect isn't being recompiled
09:43:57 <lpaste> qmm pasted “my first stack overflow with haskell :) (help very much appreciated)” at http://lpaste.net/351827
09:44:34 <MarcelineVQ> qmm https://wiki.haskell.org/Foldr_Foldl_Foldl'
09:45:25 <MarcelineVQ> allthough, second infinite?
09:45:27 <kadoban> "second" appears to be an infinite list, and you're apparently using the result
09:45:50 <kadoban> (all of the result that is)
09:48:59 <qmm> MarcelineVQ: oop, didn't mean to put in there like that.  
09:49:21 <qmm> funnily using sum instead of folr (+) 0 hasn't caused a stack overflow :)
09:49:46 <kadoban> That's because of foldr instead of foldl', which would be more appropriate
09:50:02 <kadoban> (I believe anyway)
09:51:44 <MarcelineVQ> foldl' forces the evaluation of + each step so it'll just keep adding forever instead of using up all the stack space making an expression of nested (+)'s
09:51:58 <MarcelineVQ> you still run into a problem of not getting anywhere though
09:52:13 <qmm> that was supposed to be [1 .. total]
09:52:15 <kadoban> You do get somewhere, just not to infinity ;)
09:52:18 <MarcelineVQ> :>
09:52:22 <qmm> use of sum worked just fine
09:52:44 <qmm> thanks for instrucing me to look into fold further
09:52:56 <qmm> i keep meaning to really dive into computing with fold
09:54:14 <monochrom> It is not clear how sum does it. You will have to deep dig into the source code.
09:55:54 <Boomerang> @src sum
09:55:54 <lambdabot> sum = foldl (+) 0
09:56:30 <kadoban>  @src isn't really to be relied upon for anything where the exact implementation matters
09:56:44 <Boomerang> Ah fair enough!
09:57:53 <qmm> i thought there was a paper on the universality of fold
09:58:04 <kadoban> (it just pulls from a manually-created text file is why, so it's both missing a lot and full of small lies)
09:58:18 <qmm> oh, there is this paper http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
09:58:36 <qmm> i need to read through that 
09:58:43 <kadoban> Yep, that's a quite interesting one.
10:00:56 <dunx> ;
10:34:25 <HKei> Hey, so I've been trying hint and I'm having some weird 'issues' (maybe just my brain being stupid)
10:35:01 <HKei> First of all, `interpret somethingsomething (as :: a)` compiles for me even if a isn't an instance of Typeable
10:35:04 <HKei> which is weird
10:37:31 <HKei> and then if I try to load a module that uses a non-interpreted module from my package, it can import that module but it apparently doesn't see its symbols (I get 'type constructor or class not in scope' kind of errors)
10:41:34 <Naughtmare[m]> Everything is automatically an instance of Typeable iirc
10:43:17 <HKei> Ok well, that solves that mystery then
10:55:06 <chrisdone> monochrom: http://ircbrowse.net/day/haskell/today/?id=24080763&timestamp=1485820912#t1485820912
10:55:09 <chrisdone>  
10:55:16 <chrisdone> monochrom: you might be able to find it easier with the little preview on the browse page now: http://lpaste.net/browse?author=monochrom
11:01:48 <shiona> which regex would I want to install? My usecase is to search for a line in a file that matches a programmatically generated regex string
11:08:13 <sm> shiona: any of them will do that. You might want to avoid ones that require C code. I like regex-tdfa
11:08:52 <shiona> Right. I found a page on google that promised to help with "Should you use Text.Regex, Text.Regex.Base, Text.Regex.PCRE or Text.Regex.TDFA? And how do you use them?"
11:09:03 <shiona> So I went with its help
11:10:19 <sm> fair enough. That one requires C, so may be harder to build on windows
11:17:34 <Cale> shiona: When you say "programmatically generated" is it your program which is generating the regex string?
11:18:16 <Cale> shiona: Because if so, you might as well use a parser library such as attoparsec, which will generally be much more pleasant, and skip the regex altogether.
11:20:11 <shiona> well, it's a hacky substitution cipher solver (that doesn't remove spaces). I just assume a few words and other letters leave as dots
11:20:31 <shiona> and I have a pretty good idea what material the stuff is from, so I can just look through that
11:45:47 <dmp450> hey all, I have a question. I'm doing a homework assignment and I'm new to Haskell. My assignment has me check for whether a number is even or odd using if-else, guards, and pattern matching.
11:46:13 <dmp450> I'm unable to figure out how to do the pattern matching bit. Is anyone able to give a hint on this?
11:46:55 <dmp450> I know I can't use `mod` on the left hand side, I can't use ==, I couldn't find a way to just check the last digit
11:47:29 <tdammers> you can use `mod`, you just can't use it as a pattern to match on
11:47:55 <kadoban> dmp450: You can pattern match on 0 and then use that to give answers for everything else. It's not really a *good* idea per se, but it should work. It's not quite clear to me if that's what you're supposed to do though.
11:47:58 <tdammers> but something like case number `mod` 2 of { 0 -> "it's even!"; 1 -> "this is odd" }
11:48:13 <tdammers> would work
11:48:38 <tdammers> remember that case introduces a pattern matching context
11:49:10 <dmp450> kadoban: what do you mean by pattern match on 0?
11:49:34 <kadoban> even 0 = something
11:50:47 <ongy> I wonder how ghc would react if I had a function that matches on every possible Int (let's say Int16, to not explode my storage)
11:51:21 <kadoban> I can only imagine poorly xD
11:51:28 <dmp450> tdammers: I don't think we've been intoduced to case yet
11:51:47 <tdammers> dmp450: then you'll need a helper function
11:52:30 <tdammers> or you could have 3 patterns to match against: 0, 1, and anything else
11:52:44 <tdammers> the "anything else" case would do the `mod` and recurse into the 0 or 1 case
11:52:51 <tdammers> isEven 0 = True
11:52:55 <tdammers> isEven 1 = False
11:53:04 <tdammers> isEven n = isEven (n `mod` 2)
11:53:04 <dmp450> tdammers: I was thinking of using a helper function, but couldn't think of how
11:53:16 <tdammers> with the helper:
11:53:18 <dmp450> oh, interesting method
11:53:20 <tdammers> helper 0 = True
11:53:24 <tdammers> helper 1 = False
11:53:31 <tdammers> isEven n = helper (n `mod` 2)
11:53:55 <tdammers> but now that I think about it, there isn't really a reason to have the helper at all
11:54:07 <tdammers> plus the helper is partial, which is kind of a smell
11:54:32 <dmp450> ultimately what I'm doing is taking two inputs, n and k, and I raise n to the power of k, but in two different ways depending if k is even or odd
11:55:00 <dmp450> https://bpaste.net/show/f0a20aea9b84
11:55:20 <orzo> is there a run-time cost for using 'or' with a list rather than || for mere stylistic reasons?  Particularly if there is only two conditions to combine?
11:58:42 <kadoban> Seems like potentially sure. I have no idea if it can be optimized away ... kind of doubt it. But it should be a tiny difference.
11:59:29 <Unode> Is there any way have stack with "docker: true" work globally? I.e. some way to avoid "Cannot determine project root directory for Docker sandbox." when running stack ghci; or any "stack exec" from outside a project dir?
12:15:32 <orzo> it's odd that deriving Ord doesn't also derive Eq
12:16:02 <orzo> shouldn't Eq be a required parent class for Ord?
12:19:14 <tsahyt> the call to or doesn't seem to get inlined in my tiny test
12:20:10 <dolio> It is required. But just because you derive Ord doesn't mean you derive Eq.
12:20:25 <ertes> helo
12:25:37 <orzo> well the error I got wasn't on the deriving line telling me i was missing Eq.  It was when i tried to use Eq somewhere, giving me the impression that if i used Ord instead, all would be fine.
12:30:27 <dolio> If you derive Ord without somehow implementing Eq, you will get an error saying that you're not allowed to derive Ord without implementing Eq.
12:31:03 <dolio> I don't know if it will always be the first error you get, or if some other error won't cause it to not occur.
12:31:25 <dolio> But it will be an error eventually if you don't fix it.
12:39:36 <ClaudiusMaximus> ugh, installing ghc-8.0.2 has broken my ghc-8.0.1 which now errors like ../lib/ghc-8.0.2/package.conf.d/package.cache: GHC.PackageDb.readPackageDb: inappropriate type (not enough bytes)
12:40:03 <ClaudiusMaximus> was hoping not to have to reinstall my sandbox tonight
12:40:36 <ClaudiusMaximus> maybe it's a problem with cabal
12:49:19 <dcoutts> ClaudiusMaximus: you can use ghc-pkg to re-generate that cache, but certainly it should not get corrupted in the first place. cabal is always careful to check that the version of ghc & ghc-pkg match to avoid such issues.
12:49:32 <dcoutts> ClaudiusMaximus: use ghc-pkg-8.0.1 recache --package-db= ...
12:49:58 <dcoutts> if you find out what causes it then do report it
12:54:00 <ClaudiusMaximus> dcoutts: ah, i used   cabal exec -- runghc   in a sandbox built with ghc-8.0.1 forgetting i had installed ghc-8.0.2, then cabal exec -- ghc-8.0.1  spat out that error (the directory is in the prefix where i have ghc installed, not the sandbox)
12:54:18 <ClaudiusMaximus> dcoutts: but i deleted the sandbox already and am recreating it with ghc-8.0.2
12:55:28 <ClaudiusMaximus> dcoutts: it's a cabal issue (perhaps limited to cabal exec), as ghc-8.0.1 alone works fine (but doesn't see the sandbox)
12:56:35 <dcoutts> ClaudiusMaximus: cabal exec sets up the environment to point to the package db in the sandbox, but yes if you run a different version of ghc in that context then it's not going to work
12:57:08 <dcoutts> it's unclear how cabal could prevent you from doing that
12:58:53 <ClaudiusMaximus> dcoutts: sandbox was working fine iwth ghc8.0.1 until i installed ghc-8.0.2, then cabal exec -- ghc-8.0.1 spat out the error, but ghc-8.0.1 (without cabal exec) didn't, and the path mentioned was in my ~/opt/lib/ghc-8.0.2/...
12:59:22 <ClaudiusMaximus> dcoutts: so perhaps cabal exec is adding paths from the current ghc version, instead of the ghc version corresponding to the sandbox?
12:59:42 <dcoutts> hmm, that's plausible
13:00:05 <dcoutts> ClaudiusMaximus: if so, this is something that'll work properly with the new-build stuff, since it's much more deliberate about what its configuration is
13:00:20 <ClaudiusMaximus> cool
13:00:23 <dcoutts> ClaudiusMaximus: but please do file a ticket with whatever details you have
13:00:50 <ClaudiusMaximus> ok
13:00:52 <dcoutts> ClaudiusMaximus: can't promise someone will fix it for the old sandbox code, but we can at least check it doesn't still happen with the new stuff
13:01:01 <ClaudiusMaximus> where should i file it?
13:01:28 <dcoutts> ClaudiusMaximus: the cabal github instance, see cabal info cabal-install
13:01:32 <ClaudiusMaximus> cool
13:16:52 <ClaudiusMaximus> dcoutts: filed, https://github.com/haskell/cabal/issues/4287
13:16:59 <dcoutts> ta
13:19:24 <dcoutts> ClaudiusMaximus: could you add one more thing, the result of: cabal exec -- echo '$GHC_PACKAGE_PATH'
13:19:55 <dcoutts> to confirm exactly what that gets set to, or if that escaping doesn't work, use cabal exec bash, and then use echo $GHC_PACKAGE_PATH from within that shell
13:31:35 <Zemyla> How do I kill a Haskell Platform installation on Windows and replace it with Stack?
13:33:39 <Rem_> :)
13:35:18 <ClaudiusMaximus> dcoutts: ok
13:51:09 <ocharles> Hello! Does anyone know why: addFinalizer () (putStrLn "Hello!") >> performGC  doesn't print anything?
13:52:16 <ocharles> I guess it's because that "key" () is never actually allocated?
13:53:58 <Liskni_si> or maybe it points to some global () that's not being deallocated yet
13:54:31 <luite_> yeah CAFs like that are statically allocated and shared a lot
13:56:36 <ocharles> ah, that makes sense
13:56:44 <ocharles> I think this point is the bit I overlooked:
13:56:58 <ocharles> WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. 
13:57:56 <ocharles> I'll try a different approach with weak IORefs
13:58:21 <luite_> right. yes use something like mkWeakMVar or MkWeakIORef to be safe, they attach the ref to the underlying object
13:59:16 <luite_> (that's MVar# or MutVar#, the MVar or IORef wrapper may be optimized away)
14:02:16 <ocharles> Yea, I roughly know how those work
14:03:24 <reactormonk> Is there a way to fully qualify a type? https://www.haskell.org/hoogle/?hoogle=URI.ByteString.URIRef+a+-%3E+Request
14:03:58 <reactormonk> Slightly related, if I were to write that function, should I stick it into a new hackage packet?
14:07:17 <ocharles> Slick. I have a little metrics library that if you don't actually use the metrics (they have a "registry" which is a map of name -> metric), they erase their own code to just be no-ops. And it literally works - perform a GC and `weigh` reports incrementing a counter allocates 0 bytes - but if you hold on to the registry it allocates 16 bytes (needed to
14:07:17 <ocharles> increment the underlying Double)
14:11:51 <acowley> ocharles: That's awesome!
14:12:26 <ocharles> acowley: yep! If this really does work, I'll write it up
14:15:22 <acowley> ocharles: I have a couple weak pointer-based resource management libraries that I've started over time but never pushed all the way through. People are understandably wary of promptness when it comes to the GC, but I like the idea of deliberately poking the GC.
14:16:52 <ocharles> Yea, this is pretty non-intrusive I think. You would normally run "buildRegistry", get a registry, and then pass it on to something to serve/push the metrics. But I can just have "discardMetrics" which builds a registry, discards it, and then runs performGC. Now all your instrumentation is a single pointer indirection to a chunk of code that does nothing
14:32:42 <ocharles> https://gist.github.com/ocharles/02df63b3c21648b04662f635a7fb3b74 benchmarks confirm it works :)
14:33:00 <ocharles> https://gist.github.com/ocharles/47b1f1f7dc445b3212f37f3f29557055 is the source
14:38:48 <mbrock> any experiences with or pointers to resources about using QuickCheck for verifying the behaviors of systems with resources that point at other resources with IDs?
14:39:55 <mbrock> that might be vague, but basically, I have a bunch of records containing maps of FooID to Foo, BarID to Bar, and so on -- implicit dependencies that don't seem to fit obviously into the Arbitrary paradigm
14:50:04 <c_wraith> mbrock, you can always use quickcheck to create models that it's more suited for, them convert those models to actual data structures in the properties it's testing. 
14:53:58 <janos> Hi, has somebody expierence with the Spock Library?
14:54:51 <janos> runDb :: (HasSpock m , SpockConn m ~ ConnectionPool) =>
14:54:51 <janos>             Action IO a -> m a
14:54:53 <janos> or does somebody know what a ~ in the function definition means? E.g.: 
15:03:48 <mbrock> c_wraith: yeah, I'm starting to make scenario data types with more specialized arbitrary generators, but the way you formulate it gives me some more hints, thanks
15:06:39 <Koterpillar> janos: it means the types on both sides of ~ are the same
15:07:18 <Koterpillar> janos: so this constraint reads as: m must be an instance of HasSpock, and its associated SpockConn type must be ConnectionPool
15:07:19 <HallaSurvivor> Hey! What are some of the arguments for laziness? All I can really find online is infinite data structures, but I don't know how useful those are in practice
15:07:31 <Koterpillar> HallaSurvivor: you don't want to compute what you won't use
15:08:19 <HallaSurvivor> Koterpillar: so you get an efficiency boost in some cases. Are there others?
15:08:45 <HallaSurvivor> Koterpillar: especially since it makes parallelism more verbose/impossible
15:09:26 <Koterpillar> how does it make it impossible?
15:12:12 <mbrock> it's been said that laziness kept Haskell necessarily pure, and by that story, it's one of the things that made Haskell different and interesting, leading to a lot of innovation
15:12:12 <lambdafan> somone better go tell Simon right away!
15:12:57 <janos> Koterpillar: Thank you!
15:14:02 <janos> Koterpillar: you don't know by chance how to use Spock Library?
15:14:26 <Koterpillar> janos: are you expecting me to summarize the answer in one sentence?
15:14:35 <kadoban> HallaSurvivor: Just to be clear, it doesn't make parallelism impossible, far from it. Parallelism is actually quite nice in haskell.
15:14:52 <barrucadu> Koterpillar: Parallelism is incredibly simple in Haskell, but that's because of purity, not laziness
15:15:14 <lambdafan> janos: what party of the Spock tutorial are you having trouble with?
15:15:18 <lambdafan> erm part
15:15:33 <barrucadu> Whoops, HallaSurvivor, not Koterpillar
15:15:37 <janos> Koterpillar: I don't understand
15:15:57 <barrucadu> No, I was right the first time. Ugh, it's too late
15:16:20 * barrucadu gives up
15:16:21 <Koterpillar> janos: what is it that you don't understand?
15:16:25 <janos> lambdafan: actually the Spock tutorial is very short. I am trying to use MongoDB with Spock, but I think my Haskell knowledge is too limited
15:17:56 <lambdafan> janos: my first thought is maybe you want to use something like Yesod which handles alot of things for you. I'm thinking in exchange for a little heavyweghtness, you can get going with mongodb faster.
15:17:58 <janos> Koterpillar: Actually how to create a connection/connectionpool for MongoDB in Spock
15:18:21 <janos> lambdafan: mhmm.. 
15:18:44 <Koterpillar> janos: OK, sorry, no idea about that. But maybe someone here knows the answer, now that you've formulated the question.
15:19:05 <lambdafan> the thing about Spock and Scotty is it leaves alot of details to you, details that you maybe at this point in your learning curve, would be better off leaving until later. Yesod handles much of that. But, it is a bit heavy, and opinionated.
15:19:08 <janos> Koterpillar: OK no problem
15:20:03 <lambdafan> I was able to get going with postgres on yesod doing nothing more than reading tutorials and making the types match. mongodb would be no different I expect.
15:20:20 <janos> lambdafan: yeah, I see what you mean. Actually I don't even need pooling, just doing simple requests would be enough :)
15:21:51 <janos> lambdafan: OK I see.
15:25:31 <dmj`> janos: do you feel comfortable with monad transformers and concurrency
15:25:52 <janos> concurrency yes, monad transformers meh :D
15:26:30 <janos> dmj`: concurrency yes, monad transformers meh :D
15:32:12 <hpc> janos: ever put a whole bunch of fmaps together in order to apply an operation really deeply in a data structure?
15:33:02 <hpc> transformers are an abstraction over something like that except for Monad
15:33:26 <Jello_Raptor> Is there an HList style Either somewhere? Where the element being held can be one of any type in the list? 
15:34:48 <janos> hpc: I see, I am just reading a bit about transformers
15:36:07 <hpc> a good place to start as far as documentation is https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#g:3
15:36:48 <hpc> (and pay attention to the MonadTrans class instance)
15:37:16 <hpc> and you'll eventually need to know about https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Functor-Identity.html
15:37:31 <hpc> which is usually what is used to mark the "end" of composing transformers
15:37:57 <hpc> other than that just read about them and mess with them in ghci
15:39:35 <janos> hpc: ok thanks for the reading. 
15:43:56 <dmj`> @google transformers step by step
15:43:57 <lambdabot> https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
15:45:28 <antalsz> Does `Data.ByteString.Lazy.writeFile` do lazy IO?  If so, is there a good way to force it?
15:47:34 <janos> dmj`, lambdabot, hpc: thanks guys! No I have something to read. 
15:47:39 <janos> *now
15:53:44 <jle`> Jello_Raptor: there's one in type-combinators
15:53:51 <jle`> type-combinators has an HList too
15:54:37 <hpc> antalsz: ".Lazy" refers to the ByteString data type, not the IO
15:54:49 <hpc> antalsz: a lazy bytestring is a list of strict bytestring "chunks"
15:55:10 <antalsz> @hpc: And `writeFile` will force the whole thing and write it out?
15:55:10 <lambdabot> Unknown command, try @list
15:55:23 <Jello_Raptor> jle`: Thanks :) 
15:55:32 <glguy> antalsz: @ is for bot commands
15:55:40 <hpc> yes, unless the documentation says it uses lazy IO
15:55:52 <hpc> which is usually very explicit because it's a source of bugs
15:55:54 <antalsz> glguy: I know, I’ve just been using Slack too much lately :-)
15:56:11 <antalsz> hpc: And that even answered my second question about how to know the answer!  Thanks :-)
15:56:18 <antalsz> s/know/learn/
15:56:45 <hpc> https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html#v:hGetContents - an example of lazy IO documented
15:58:43 <antalsz> awesome
15:58:54 <Jello_Raptor> jle`: This looks more like a type level Either, I want something like `HEither :: [*] -> *` with stuff like `_3 :: HEither (_:_:c:_) -> Maybe c` 
16:09:35 <erisco> how can I tell ghci to run lifted IO without printing (because it then complains there is no Show instance)
16:11:26 <Koterpillar> erisco: void?
16:12:16 <erisco> never mind there should be a function in the lib somewhere
16:12:42 <Koterpillar> :t void
16:12:44 <lambdabot> Functor f => f a -> f ()
16:12:46 <mr_sm1th> Is there a Haskell function that groups concurrent occuranses in a list and makes a list of list out of them?
16:12:54 <Koterpillar> erisco: that is the function you want
16:12:55 <jle`> Jello_Raptor: that's this here http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Sum.html
16:12:59 <erisco> no, it isn't
16:13:14 <kadoban> :t group -- mr_sm1th, this?
16:13:15 <mr_sm1th> e.g. "ssdddabb" -> ["ss", "dd", "a", "bb"]
16:13:16 <lambdabot> Eq a => [a] -> [[a]]
16:13:17 <jle`> Jello_Raptor: your HEither = HList Identity
16:13:28 <kadoban> Ya, group
16:13:50 <mr_sm1th> Nice.
16:13:53 <mr_sm1th> Thx.
16:14:00 <Koterpillar> erisco: hmm, I could run my function in GHCi without problems
16:14:04 <kadoban> Anytime
16:14:29 <Koterpillar> erisco: http://lpaste.net/351838
16:15:18 <erisco> no, I have  m ()  for some MonadIO
16:15:55 <Koterpillar> and you want to liftIO it?
16:16:04 <erisco> no
16:16:22 <Koterpillar> well, GHCi can't run any MonadIO, just IO
16:16:49 <erisco> yes that's right, so I need to locate the correct function to tear away Symbolic
16:16:55 <erisco> from this heap of stuff http://hackage.haskell.org/package/sbv-5.15/docs/Data-SBV.html#t:Symbolic
16:17:16 <Koterpillar> Oh. So this is not about "without printing" or a Show instance
16:17:32 <erisco> it was
16:17:38 <erisco> then I realised I needed something else
16:19:33 <erisco> unfortunately I am mystified oO
16:25:54 <barrucadu> erisco: I think you might need to get a `Symbolic SBool` and then use `prove`, `sat`, or `allSat` to get the variable assignment the solver comes up with.
16:26:20 <erisco> seems so barrucadu
16:27:03 <Sonolin> I'm starting to learn lenses, and can anybody explain why "view (_ix 3)" requires a list of Monoids?
16:27:06 <Sonolin> https://ptpb.pw/YUZO/haskell
16:27:37 <Sonolin> I tried inspecting the :i of Const, and it seems there's a Monoid instance for Const... not sure if that's related, but I can't for the life of me figure out where Monoid comes in here
16:30:30 <Sonolin> ah! I think I get it now :)
16:30:37 <Sonolin> Applicative requries Monoid (for Const)
16:30:37 <pikajude> Sonolin: view requires a Monoid iirc
16:30:51 <noan> oh wow I feel a certain special sort of dumb. I can't get a haskell hello world happening for me with stack right now
16:31:05 <Sonolin> yea I understand now thanks pikajude :)
16:31:18 <pikajude> Sonolin: because if the getter fails, it needs to return mempty
16:31:35 <Sonolin> ...which completely makes sense... I was just trying to wrap my head around why my custom code was requiring Monoid
16:31:48 <pikajude> oh
16:32:06 <Sonolin> (i.e. I implemented view with "\l s -> getConst (Const l s)" and was confused)
16:32:15 <noan> got it.
16:33:01 <Sonolin> erm "getConst (l Const s)"
16:33:02 <noan> haskell exec somefoo-exe just needed to be haskell exec somefoo-exe.exe because windows.
16:33:16 <glguy> Sonolin: The issue is specifically that: instance Monoid m => Applicative (Const m)
16:33:40 <Sonolin> cool thanks for clarification glguy
16:45:59 <qmm> a = [188.38354691296536,180.9969223840326,173.89993154565036,167.08121769837453,160.5298694453072,154.23540323155294,148.187746568276,142.3772219145808,136.79453119137543,131.43074090246682]
16:46:03 <qmm> sum a / length a
16:46:12 <qmm> i would like to know how to do something like this...
16:46:37 <qmm> toInteger (sum a) / realToFrac $ length sum
16:47:05 <glguy> sum a / fromIntegral (length a)
16:47:23 <qmm> (sum a) :: Fractional a => a
16:47:46 <qmm> ah, i did the exact opposite
16:47:58 <qmm> fromIntegral $ sum a / length a
16:48:40 <qmm> Could not deduce (Foldable ((->) (t0 a0)))
16:48:41 <qmm>         arising from a use of ‘length’
16:48:50 <qmm> from the context: Fractional a
16:49:00 <qmm> bound by the inferred type of it :: Fractional a => a
16:49:09 <qmm> oh, right a pastebin, sorry 
16:49:13 <glguy> qmm: That's because you wrote:   length sum
16:49:28 <qmm> doh!
16:51:39 <qmm> glguy: i really appreciate you helping me. i now feel so embarassed, i will have to study https://wiki.haskell.org/Converting_numbers
16:54:27 <Taslem> I'm running into an incomprehensible error for what I think is a relatively simple use-case for GADTs:
16:54:29 <Taslem> http://lpaste.net/351841
16:54:52 <Taslem> (I'm using GHC 7.8.3 for the record)
16:55:51 <Taslem> The gist is that I want a length-encoded result list with a different type of element than the input to a certain function; but ghc explodes when I try to pattern match on the result, even though it knows what type it is
16:57:07 <glguy> Taslem: Add a type signature to example'
16:57:44 <Taslem> @glguy Wow, thanks. Why didn't ghc infer it as Bool?
16:57:44 <lambdabot> Unknown command, try @list
16:58:16 <glguy> Taslem: Because you're on an outdated GHC
16:58:34 <Taslem> Well that's simple. Thanks!
16:59:22 <glguy> pattern matching on GADTs tends to require explicit type signatures because of the restrictions around information flow of type information
16:59:51 <glguy> and it's an area that GHC is getting smarter about over time
17:00:02 <Taslem> I see. Does current GHC need a signature there?
17:00:06 <glguy> no
17:20:10 <barryburd> Dumb question alert!! I’ve defined k = (1, 2, “xyz”)       When I do :type k, the result is (num t1, Num t) => (t, t1, [Char])     Why isn’t the result (Num, Num, [Char]) and why isn’t the result (Num t1, Num t, Num t2) => )[t, t1, [t2]) ?
17:22:24 <Welkin> Num is not a type
17:22:27 <Welkin> it is a typeclass
17:22:35 <Boomerang> barryburd: Num is a type class, when on the left of => it is a constraint on t and t1. For example t and t1 could be Int, Float...
17:22:58 <barryburd> Type vs. typeclass. Thank you.
17:23:51 <Boomerang> barryburd: In your second example it cannot be [t2] because Char don't have a Num instance
17:24:45 <barryburd> Yeh, I meant (Num t1, Num t, Char t2), but I see why that wouldn’t work.
17:26:03 <Boomerang> Right, haskell doesn't infer that 1 and 2 are Ints but rather that they have a Num instance, this way they could be Int, Float, Double or other depending on the use case
17:26:39 <barryburd> Thank you.
17:30:03 <Welkin> hi zipper 
17:30:11 <Welkin> are you building anything lately?
17:35:25 <noan> is there a stack command to build and run on file change?
17:37:41 <Koterpillar> noan: --file-watch
17:39:13 <noan> Koterpillar, is there a way to compose that will run? sorry, very new to stack and coming from sbt
17:39:27 <Koterpillar> noan: stack build --file-watch --exec ...
17:39:41 <noan> ah thanks
17:40:28 <Welkin> sbt?
17:40:33 <noan> Scala Build Tool
17:40:36 <Welkin> ew
17:40:39 <noan> XD
17:40:56 <noan> Koterpillar, got it working, thanks
17:41:10 <noan> .... why is atom crashing with my haskell project open O.o
17:41:29 <Welkin> could be anything
17:41:39 <Welkin> but if you want a stable haskell editor, use emacs with haskell-mode
17:42:26 <noan> I've never been able to get into emacs. Maybe with evil mode I could try. I'll look around for a decent editor
17:42:43 <Sonolin> spacemacs + haskell-mode + evil = bliss 
17:42:44 <markasoftware> vim <-- found one right here
17:42:55 <Sonolin> but yea vim works just as well (maybe not as shiny)
17:42:58 <markasoftware> noan: rearrange the letters of your name to find a decent editor
17:43:06 <markasoftware> ;)
17:44:02 <noan> markasoftware, but nano sucks. also my name is a bad attempt at writing nån XD
17:44:13 <markasoftware> nano .vimrc
17:45:06 <markasoftware> are emacs keybindings as bad for your hand as the legend says
17:45:10 <markasoftware> ?
17:45:26 <Koterpillar> vim with haskell-mode isn't bad either
17:48:20 <noan> should hoogle be a local dependency, or a global install, as it is a user choice? I assume the later, and then gitignore all project-local hoogle data?
18:02:48 <Jello_Raptor> is there a package where I can find `newtype Fix f = In (f (Fix f))` defined somewhere? 
18:03:22 <Jello_Raptor> It's easy enough to add my own, but I'd rather use a standard one somewhere if possible. 
18:04:21 <Koterpillar> Jello_Raptor: http://hayoo.fh-wedel.de/?query=Fix -> data-fix?
18:06:01 <Jello_Raptor> huh, I guess it's not in stackage yet 
18:08:55 <noan> anyone around doing haskell on windows?
18:09:45 <markasoftware> hopefully not
18:09:57 <markasoftware> hopefully nobody's doing anything on windows
18:10:13 <Cale> Eh, some people do -- SPJ works on Windows, from what I recall
18:10:30 <Cale> and Neil Mitchell
18:11:03 <Cale> I don't know about anyone who is around right now :)
18:11:04 <noan> markasoftware, I am because game development. Was thinking of doing the rest backend in haskell, but a lot of dependencies can't install via stack
18:11:33 <markasoftware> well, i guess with game dev you don't have much of a choice
18:11:34 <noan> fast-logger build results in this. Trying to install hoogle...
18:11:34 <noan>          error: macro names must be identifiers
18:11:34 <noan>          #ifdef !MIN_VERSION_win32(2,3,1,0)
18:11:34 <noan>          ^
18:11:34 <noan>     `gcc.exe' failed in phase `C pre-processor'. (Exit code: 1)
18:11:43 <Koterpillar> noan: you can add arbitrary packages with stack.yaml
18:12:58 <ROBOT9001> Is this the place to ask for help?
18:13:15 <Koterpillar> ROBOT9001: with Haskell, surely
18:13:27 <sm> noan: basically, a certain portion of hackage includes C as well as haskell, and these often won't build easily on windows
18:14:01 <sm> so when choosing packages, you should scan their dependencies (eg for "unix")
18:14:11 <Cale> That right there is kinda weird though, because I wouldn't expect that macro name to be an issue
18:14:11 <noan> sm, sooo, am I SOL or is there a workaround that isn't such a pain in the ass that I just swap off haskell for this project entirely?
18:14:28 <sm> well, why do you need fast-logger ?
18:14:42 <noan> it is a dependency of hoogle, which I kind of wanted to use.
18:15:03 <sm> I see it does also depend on Win32, which means it almost certainly should work on windows. Also hoogle's author uses windows
18:15:20 <sm> how did you set up your haskell environment
18:15:41 <noan> installed stack. Stack setup.
18:15:51 <ROBOT9001> I'm having trouble opening WinGHCi, it opens, but it stops responding as soon as it does. Then after clicking in the window,  Windows 7 just asks to close the program.
18:17:27 <sm> noan: installed stack using the installer from https://haskell-lang.org/get-started I guess ?
18:17:30 <Welkin> to fix windows problems, use linux
18:17:36 <Welkin> you could even just install a vm
18:18:12 <Koterpillar> Welkin: and tell your customers to?
18:18:19 <noan> Welkin, https://www.stackage.org/stack/windows-x86_64
18:18:20 <sm> please let's not waste time going down that thread :)
18:18:28 <noan> er, wrong response. sm sorry
18:19:03 <noan> Welkin, I generally prefer linux, but flipping between windows and a VM would drive me mad.
18:19:43 <sm> noan: well, you seem to be doing the right things and like Cale I'm surprised it's not working. Time to search/report in fast-logger & stack issue trackers perhaps
18:19:44 <noan> that's a recipe for a really shitty frustrating workflow in my eyes
18:20:04 <noan> sm, it's not -just- fast-logger though
18:21:14 <noan> or, it is this time. last time I tried from git-bash I got a full page of different errors out
18:21:47 <sm> hm. Have you tried from a regular cmd prompt
18:24:54 <noan> sm, yes, fast-logger still throws a shitfit. a friend found the error report somewhere that said it had recently been fixed specifically for fast-logger. Gonna try using nightly as a resolver just for a second and see if that gets me anywhere.
18:25:38 <noan> sadly she didn't link me and has since gone to shower
18:26:41 <sm> https://github.com/kazu-yamamoto/logger/issues/118
18:27:57 <noan> *cheers nightly on*
18:39:39 <noan> hoogle has successfully installed via nightly resolver. 
18:39:50 <noan> incase anyone asks you later the same question, sm
18:40:45 <sm> thanks noan, I figured it would from fast-logger's changelog etc.
18:41:07 <noan> I just feared additional dependencies may fail.
18:42:04 <sm> glad you got it resolved. A little alarming I guess if you're used to things in stackage LTS just working
18:42:56 <Cale> sm: haha "resolved"
18:43:56 <sm> eh what I can't hear you
18:44:39 <sm> well, it does seem resolved ?
18:44:49 <noan> sm, he was making a pun
18:44:52 <noan> resolved via a resolver.
18:44:55 <sm> Owwwww
18:44:56 <noan> I belive.
19:04:12 <noan> https://gist.github.com/AlexaDeWit/5cb6b2a6c0462f53cde300c3fa110813
19:04:17 <Squarism> ive learned i can define functions in this manner : \n data Lal = Lal { a :: Int } \n let f Lal { a = x } = 2*x
19:04:28 <noan> so close, got so far, but in the end, fucking tls problems
19:05:20 <Squarism> but if i make Lal a lens.. compiler complains ’_a’ is not a (visible) field of constructor of Lal
19:06:23 <Squarism> sorry.. my bad
19:06:49 <Cale> Squarism: you figure out what was wrong?
19:07:00 <Squarism> yep
19:07:05 <Squarism> thanks anyway
19:09:38 <noan> sm, don't suppose you've seen anything like that before? Firefox seems happy with the cert from haskell.org....
19:11:53 <Koterpillar> noan: GHC might be using the certificate store from mingw or somewhere like that (guessing, I'm not using windows)
19:12:05 <Koterpillar> noan: I wanted to say strace, but heh
19:13:46 <noan> thanks
19:14:08 <noan> For now, since it's just a baby test project, I'll just use the shitty workaround. I'll worry about real fixes later.
19:14:08 <sm> noan: your paste is truncated, but it gives the appearance of the first failure being a timeout
19:14:14 <sm> I assume you've retried a few times
19:15:26 <noan> commented it in full properly, sorry
19:15:36 <sm> oh, maybe not a timeout
19:16:07 <noan> nope, it just doesn't accept the CA from haskell.org, but does from stackage and others.
19:19:33 <sm> noan: I see some related-looking discussion eg at https://github.com/commercialhaskell/stack/issues/1922, but no mention of how to fix on windows
19:20:39 <sm> I'd open an issue in the hoogle tracker
19:21:39 <Squarism> ive learned that cabal-the-library is quite a primitive building framework dont offering much in conveniance. Like complete rebuilds happening when the arent needed. Issues where you have to restate your dependendencies even if information is available. I wonder why its so - is it extra hard to build a builder for haskell code?
19:24:57 <sm> noan: one or two possible workarounds mentioned at https://github.com/commercialhaskell/stack/issues/234
19:25:48 <sm> "It can be fixed by opening the correct webpage in Internet Explorer (which automatically adds the certificate)"
19:26:22 <noan> yet firefox doesn't
19:26:22 <noan> lol
19:27:31 <geekosaur> doesn't firefox use its own cert store?
19:28:57 <Welkin> Squarism: use nix
19:29:34 <noan> opening it in ms edge really did fix it. What a laugh
19:29:46 <Squarism> Welkin, many people do that? Or is it highly experimential / bleeding edge? 
19:30:47 <Welkin> nix is popular
19:34:06 <Squarism> ok.. good to know. Ill try it
19:47:59 <fiddlerwoaroof> Set of tests for compliance to the standard?
19:48:16 <fiddlerwoaroof> s/^/Is there a /
19:48:54 <Koterpillar> which standard?
19:49:13 <fiddlerwoaroof> I was thinking of the Haskell98 report
19:55:09 <geekosaur> it'd be the haskell2010 report, but ghc is known noncompliant in several areas (Num no longer requires Eq or Show; Monad requires Applicative and thereby Functor)
19:56:48 <fiddlerwoaroof> Yeah, I've been doing some archeology to try to get the yale-haskell compiler running
19:57:16 <fiddlerwoaroof> Mostly for fun, and because I'm interested in embedding functional languages in a common lisp environment.
19:57:32 <fiddlerwoaroof> I sort of wanted to see how complete it is.
20:17:22 <mrkgnao> is there a way to not have to use liftIO when using monad transformers?
20:17:50 <mrkgnao> I guess what I want is things like putStrLn :: MonadIO m => String -> m () 
20:21:27 <Koterpillar> mrkgnao: http://hackage.haskell.org/package/safer-file-handles
20:24:51 <steve___> If one were creating a module that had multiple types that all required a similar field, say "name" and there were a need to have dedicated types for each one, what is the canonical way to create several types that share the same field? Do I create the various types, all with prefixes to the name? use Ghc8s duplicate record label feature? For example data Book = Book { name :: String} data Movie = Movie 
20:24:57 <steve___> { name :: String}. I often see this problem and think I must be needing to use a feature like typeclasses...but i'm not sure. Hope that makes sense! :)
20:31:01 <mrkgnao> steve___: you might want to check out what haskell-gi does with overloaded labels
20:35:02 <steve___> So I took a quick look, but I don't see anything special. What am I missing? :(
20:47:37 <Squarism> theres no easy way to create a singleton list wo using [...]
20:47:38 <Squarism> ?
20:48:22 <kadoban> pure, return, or what's wrong with using [a] ?
20:48:44 <jle`> > pure 10 :: [Int]
20:48:46 <lambdabot>  [10]
20:52:30 <jchia_1> Where can I go to learn what exactly exceptions are in Haskell from first principles? Neither modules like Control.Monad.Error nor packages like safe-exceptions, nor any of the schools of thoughts about how exceptions should be used, nor how async exceptions should handled, per se, but mainly the meaning of exceptions, async exceptions, masks, they relationship to one another and to the RTS, and what they mean for the behavior of a program?
20:53:18 <jchia_1> once i understand these, i can understand those modules and packages in their context
20:54:34 <jchia_1> i know what it means in another language like C++ to catch and throw. in haskell, it seems it's not so straight-forward given the existence of 'async' and 'mask' and I'm not sure what those mean exactly to program behavior.
20:56:26 <jle`> jchia_1: for me, it was that exceptions chapter in Parallel & Concurrent haskell
20:56:38 <Squarism> kadoban, sometimes you want to cram a big expression in that that list constructor.. then it just gets messy with matching brackets
20:57:08 <Jello_Raptor> Hmm, do any of you know if it's possible to get TypeApplication to play nicely with infix operators? or failing that a suggestion that lets me get a vaguely nice syntax for my edsl? http://lpaste.net/351856 line 4 and 9 are what I want, but line 38 is the only thing that works. 
20:57:10 <Squarism> ...sure, one could argue, defenine the element first. But it could be good to know a non infix(?) version
20:57:12 <jchia_1> jle`: OK, I'll look that up.
20:58:10 <jle`> jchia_1: http://chimera.labs.oreilly.com/books/1230000000929/ch08.html#sec_exceptions
20:59:18 <Jello_Raptor> Right now, it seems like TemplateHaskell is the only way to get something approximating record syntax and that's horrible overkill for what I'm aiming to do
21:00:26 <steve___> :q
21:02:15 <kadoban> Squarism: Well, pure or (:[]) then ?
21:02:26 <geekosaur> Jello_Raptor, I don';t think anything requires TH for this; it's a convenience to auto-derive typeclass instances
21:02:44 <Squarism> kadoban, thanks
21:09:57 <Jello_Raptor> geekosaur: I'm not looking for an actual record syntax, it's just that my edsl uses a lot of record-like structures and I want a nice looking way to enter record-like data. I've updated the paste with some examples http://lpaste.net/351856
21:12:59 <Jello_Raptor> barring that, some way to get nice looking for record-like things would be nice 
21:36:05 <Squarism> running stack to compile it seems cpu utilization is mostly 100% on 1 and like 2-4% on the 3 rest cores. Does one need to do something to get a better spread/utilization?
21:36:23 <Squarism> core 
21:36:25 <Squarism> that is
21:36:56 <Squarism> 100% on 1, just barely alive on the 3 rest
21:37:01 <qmm> what is the difference between Float, Double, and Rational?
21:38:17 <Squarism> rational numbers are integer/integer right?
21:39:06 <Squarism> float and double are just different precision - float beeing of less
21:39:07 <Jello_Raptor> yup
21:39:55 <Jello_Raptor> Squarism: also yes, with the caveat that there's more precision the closer you are to 0 with floating point. 
21:40:17 <Squarism> oh ok, didnt know that
21:40:26 <MP2E> yep. Floating point corresponds to a 32-bit floating point value, Double corresponds to a 64-bit floating point value, and Rational represents it in fractional form using integers
21:40:38 <MP2E> float*
21:41:08 <MP2E> Float and Double would usually be faster than Rational, but may (read: most likely will) lose some precision
21:42:19 <Squarism> Jello_Raptor, but isnt the mantisa larger for double - regardless of exponent?
21:45:09 <mrkgnao> I wrote a function with this signature:
21:45:11 <mrkgnao> instAt :: Int -> Lens' VMState AsmInst
21:45:37 <mrkgnao> and the typechecker wants me to expand this out into the (a -> f a) -> b -> f b form and add an Applicative constraint
21:46:02 <mrkgnao> should I change this to a Traversal'? I don't know anything about those though
21:46:49 <jle`> mrkgnao: have you turned on RankNTypes?
21:47:28 <jle`> oh, but yeah, if your function only works on Applicative f, it'd be Traversal'
21:47:37 <mrkgnao> I have, at intero's suggestion
21:47:45 <jle`> Traversal' is basically Lens' constrained to all Applicatives instead of just all Functor's
21:48:50 <jle`> Lens' a b = forall f. Functor f => (b -> f b) -> (a -> f a)
21:49:01 <jle`> Traversal' a b = forall f. Applicative f => (b -> f b) -> (a -> f a)
21:49:37 <mrkgnao> uh, why does my a-type need to be a Monoid?
21:49:50 <mrkgnao> pretty sure I'm making a dumb mistake somewhere
21:51:43 <jle`> hm, what do you mean?
21:52:02 <mrkgnao> jle`: I'm trying to get an AsmInst from a VMState
21:52:31 <mrkgnao> so I tried doing vm ^. instAt i, and it says AsmInst doesn't have a Monoid instance
21:58:11 <mrkgnao> I'm very confused now
22:04:58 <mrkgnao> oh, I should've done vm ^?! instAt i instead. huh.
22:43:39 <_sras_> Using TH, how can I generate a toplevel call to a template haskell function. I mean, I want to generate a bunch of code, one of which is a call to an external TH function....
22:54:13 <kqr> Is "const (f . g) = f . const g" true? May be the lack of morning coffee but I'm really struggling to see it, yet there is some intuitive sense to it
22:57:03 <kqr> Types check out so I'll roll with it! 
22:57:32 <kqr> Wait no they don't 
22:57:58 <kqr> Or wait yes they do 
22:58:05 <kqr> (you see my suffering!) 
22:59:19 <nshepperd> :t \f g -> (const (f . g), f . const g)
22:59:21 <lambdabot> error:
22:59:21 <lambdabot>     • Occurs check: cannot construct the infinite type: b1 ~ a -> b1
22:59:21 <lambdabot>       Expected type: b2 -> b1
23:00:05 <nshepperd> :t \f g -> (const (f g), f . const g) -- actually this i think
23:00:06 <kqr> Hm
23:00:07 <lambdabot> (a -> c) -> a -> (b -> c, b1 -> c)
23:03:02 <nshepperd> (f . const g) x = f (const g x) = f g -- checks out
23:12:49 <kqr> yeah you're right. they don't line up quite as neatly as I'd like them to
23:26:58 <orzo> is a case statement matching String compiled similarly to an if-else chain?  Or does the compiler do a binary search or something?
23:28:32 <Cale> It's compiled to a guard that uses (==)
23:29:50 <orzo> well, i mean beyond core
23:30:10 <orzo> i guess an == guard would be hard to do a binary search with
23:33:10 <Cale> It's sort of a weird thing to worry about because if you cared about performance, you likely wouldn't be using String. You can use string-literal pattern matches with Text, using the OverloadedStrings extension, and in that case, the fact that it compiles to a guard with (==) is reasonably good.
23:34:15 <orzo> it's not that i'm woried, i just like to know the run-time effects when i reorganize code
23:34:18 <nshepperd> it would most likely be a chain of == calls, at asm level
23:34:51 <orzo> changing a case to a dumb traveral over a list
23:36:32 <nshepperd> for data types with lots of options like data X = A | B x | C y | D, case match could be compiled into one of those fancy array dispatch thingys based on the constructor tag
23:36:35 <orzo> if case match is always an order-n scan, then i should feel freer to write it that way
23:36:47 <nshepperd> but i dunno if that ever really happens
23:38:16 <jchia_> When I do the following, it's possible to get back "defabc" as well as "abcdef" when I enter "abc\ndef\n" on the console, correct?
23:38:17 <jchia_> (++) <$> getLine <*> getLine
23:38:34 <orzo> no
23:38:49 <orzo> it'll always give you abcdef
23:39:02 <jchia_> orzo: Why? >>= has sequencing, but <*>?
23:39:42 <orzo> well, you mean <*> for IO right
23:39:44 <Cale> af <*> ax = do f <- af; x <- ax; return (f x)
23:39:47 <jchia_> orzo: yes
23:39:52 <nshepperd> 'mf <*> mx' runs mf first, then mx, then applies the result of the first to the second
23:39:54 <nshepperd> in IO
23:40:10 <jchia_> so the sequencing is because of how <*> is defined for IO, right?
23:40:13 <orzo> and probably all other side-efecting monads
23:40:51 <orzo> you mean, does doing different break the applicative rules?
23:41:04 <Cale> Yeah, generally if something is an instance of Monad, you'll have (<*>) = ap
23:41:45 <jchia_> orzo: I mean generally in a Monad, >>= enforces a an order between the LHS & RHS but <*> does not, but IO defines <*> in a way that there's also an order.
23:42:35 <jchia_> i mean if you define <*> with ap, you get the sequencing, but generally you don't have to.
23:42:45 <orzo> but <*> does and I'd be surprised if i encountered a <*> that reversed it
23:42:46 <jchia_> for IO it happens to have the sequencing
23:43:20 <orzo> the documentation describes <*> with the word "sequence": sequence computations and combine their results (<*>).
23:43:36 <Cale> jchia: Well, the documentation for Applicative now states that if the functor in question is also an instance of Monad, it should satisfy (<*>) = ap
23:44:01 <Cale> jchia: This is mildly controversial, but a reasonably nice thing to be able to assume.
23:44:58 <orzo> what was the argument against
23:45:34 <Cale> Well, there are some very rare cases where you might want the Applicative and Monad instances to disagree.
23:45:46 <nshepperd> jchia_: 'f <*> g' should always be thought of as 'running' f before g, whenever there's a difference between that and the opposite
23:46:06 <nshepperd> jchia_: but there are applicatives where order doesn't matter
23:46:08 <Cale> You sort of gave an example there -- it would be possible to define a concurrent Applicative instance.
23:47:46 <jchia_> Let's say i'm making a Monad for expressing reading something from some kind of database system, Haxl being a possible example. I could issue multiple queries in parallel in one batch or sequentially, with one query per batch. The query result is the same but the underlying activity is different. If I use >>=, I issue one query at a time. If I use <*>, I can combine all the terms into one batch query. Does that make sense?
23:47:46 <nshepperd> newtype Par a = Par { getPar :: IO a }
23:48:34 <nshepperd> you could define a 'f <*> g' for that that runs both things simultaneously in two threads, then combines the results
23:48:47 <geekosaur> wasn't someone messing with that a month or so back? (and rediscovered that the overhead swamps the gain in the vast majority of cases)
23:50:00 <quchen> nshepperd: The Concurrently type in Async does exactly that
23:50:23 <orzo> well if the compiler had a super algorithm, it might be able to decide on a per-use bases whether <*> is concurrent
23:51:32 <Cale> Decide?
23:52:11 <orzo> that's the word i used
23:52:33 <Cale> orzo: But the two programs behave differently
23:52:37 <mrkgnao> how do I make a lens that reads a value from a Reader environment?
23:52:38 <orzo> compiler decides to emit concurrent code or sequential code based on some fancy heuristics
23:52:40 <Cale> I don't think you'd want it to decide, generally
23:53:15 <orzo> they both behave the same: with concurrent semantics
23:53:19 <kadoban> Cale: Don't we already let the compiler decide how our programs should run, exactly? I don't get to choose evaluation order.
23:53:19 <mrkgnao> say I wanted to write func i = f . ix i . g, where j has to be read from 
23:53:22 <Cale> mrkgnao: I'm not sure what that means. You can use ordinary lenses with asks or local
23:53:24 <orzo> under this hypothetical
23:53:24 <mrkgnao> whoops, sorry
23:53:47 <cocreature> mrkgnao: it can’t be a lens because you can’t set the value of a reader environment
23:53:49 <Cale> kadoban: That's very different from the order of execution of IO actions
23:54:00 <Cale> kadoban: Every evaluation order will produce the same result
23:54:01 <mrkgnao> say I wanted to write func i = f . ix' i j . g, where ix' i j = ix (i % j) and j has to be read from a reader env
23:54:06 <mrkgnao> can this be done?
23:54:08 <Cale> But executing IO actions in different orders won't.
23:54:13 <Gurkenglas> :t local -- cocreature, you can :/
23:54:16 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
23:54:21 <Cale> (and will generally look very different to the user of the program)
23:54:22 <orzo> Cale, i mean if we adopted the <*> is concurrent rule, you wouldn't (couldn't) use it to sequence IO actions
23:54:34 <orzo> and then the compiler would be free to decide whether it is actually concurrent
23:54:41 <Cale> Oh, I see what you mean
23:54:51 <kadoban> Cale: But that's precisely why IO's Applicative and Monad agree, right? Because it could give different results if you start messing with that, but aren't we talking about a Monad/Applicative pair where it doesn't particularly matter, except for performance?
23:55:29 <mrkgnao> I tried doing something like func i = do j <- ask; f . ix' i j . g, but it ended badly 
23:55:30 <cocreature> Gurkenglas: not really. local requires that you have the rest of your program available. it’s not just a single action in the reader monad like setting the value in the state monad is
23:55:36 <Cale> I still don't think I like that very much, but it's debateable I suppose.
23:55:40 <Gurkenglas> mrkgnao, func i = do i <- ask; return $ f . ix (i % j) . g
23:56:01 <Cale> Having the compiler arbitrarily decide that it wasn't going to make your program concurrent despite the fact that you asked for that sounds pretty annoying.
23:56:05 <Gurkenglas> This, of course, places the returned value in the reader context.
23:56:39 <Cale> There won't in general be a way for the compiler to know that sequentialising the actions will meet the requirements of your program
23:56:55 <mrkgnao> Gurkenglas: I was missing the return. :/
23:57:00 <Cale> You might have concerns about the latency of those actions occurring which the concurrency is meant to solve.
23:58:10 <nshepperd_> Also, preventing deadlock might be incompatible with sequentialising
23:59:01 <mrkgnao> how would I use this like a normal lens that works in a State context?
23:59:08 <Cale> nshepperd: Yeah, if it didn't involve solving the halting problem, you could almost imagine a sufficiently smart compiler checking for that
23:59:57 <mrkgnao> I don't want to have to >>= everywhere if I can help it
