00:25:28 <Guest76551> good evening - now I know it may be a horrible question to ask - but I must ask it anyway as I am compeltely new to Haskell - what is the best first book (or learning resource) to start with, and commit to, on path to best understanding language and principles first and foremost (as opposed to resource that will get you to slapping some code together without understanding it well) 
00:27:05 <Hafydd> Guest76551: the Haskell 2010 Report.
00:27:13 <Schoolmeisterr> how new are you to programming?
00:27:30 <kadoban> Guest76551: Seems like a pretty good question to ask, to me. http://haskellbook.com/ would be my recommendation, though it's not free.
00:27:43 <Guest76551>  sued Python for math and 3d graphics so far,
00:27:54 <Guest76551> used*
00:27:57 <Hafydd> These frivolous lawsuits are getting out of hand.
00:28:08 <Guest76551> :D
00:28:43 <EvanR> illegal use of math
00:28:51 <EvanR> unfortunately exists
00:29:18 <Schoolmeisterr> I'm quite new also. I used the learn you a haskell book, it's free online. It seemed very clear, not sure what more experienced Haskell programmers think about it though.
00:29:57 <Schoolmeisterr> not quite new* more like very new
00:29:57 <EvanR> the pictures are about as funny as "happy learn haskell tutorial"
00:30:20 <kadoban> LYAH is in my opinion not very good. Most obviously, it completes lacks exercises. At best it's kind of an overview of stuff you can learn if you use a better resource.
00:31:44 <Guest76551> i'm ok with paid resources
00:32:17 <Schoolmeisterr> Yeah, that's very true. Didn't really bother me since I've got functional programming as a course though, uni provided the exercises.
00:32:43 <Guest76551> i see haskellbook has a sample to downlaod - i'll start with that
00:33:26 <kadoban> Sounds good, good luck. Questions always welcome, this place is a great resource.
00:33:57 <EvanR> IRC university
00:36:33 <Kristof_HT> is this a good place for even beginer questions , or is there  another room for that purpose?
00:36:34 <osa1>  is there a way to use an existing acid-state db after moving event types to a new module (or renaming the existing module with events? )
00:37:05 <EvanR> Kristof_HT: this is a good place
00:37:08 <kadoban> This is a fine place really.
00:37:17 <Schoolmeisterr> From what I've seen, all questions are welcome here. You'll also get near-instant response
00:37:33 <EvanR> osa1: when renaming... you need to migrate your database
00:37:46 <EvanR> which means having the old-named one around
00:37:57 <EvanR> safe-copy is the recommended library for dealing with that
00:38:05 <osa1> EvanR: oh so I need to migrate manually?
00:38:21 <EvanR> safe-copy hoists that process
00:38:53 <EvanR> if you didnt set that up already though, i dont think you can retroactively slap in on your DB
00:39:40 <osa1> what do you mean by set up? I need safecopy instances to be able to use acid-state, right? so I must have those already
00:39:45 <EvanR> so it sounds like youd be doing it manually this time
00:39:51 <EvanR> oh
00:40:24 <Kristof_HT> thanks to all who answered, glad to see people willing to help 
00:40:28 <dmj`> osa1: unless you’re using the memory backend, you probably have them
00:40:29 <osa1> EvanR: `class SafeCopy st => IsAcidic st`
00:40:53 <osa1> EvanR: I'm using `makeAcidic` so I think I'm using SafeCopy instances
00:40:57 <EvanR> yes
00:42:10 <osa1> EvanR: so I need to somehow query the whole database and generate a new acid-state db using my new event types?
00:42:39 <EvanR> no
00:43:13 <EvanR> if you open it, make a checkpoint, and close it, the events dont matter anymore
00:43:29 <EvanR> only the state type needs to mess with safecopying
00:43:50 <EvanR> after checkpointing, you should be able to rename the events
00:44:02 <EvanR> or add new ones
00:44:18 <osa1> oh so if events are the same according to safecopy I should be able to use new event types after making a checkpoint?
00:44:36 <osa1> but I still need the old module until I save a checkpoint
00:45:04 <EvanR> events arent involved in safecopy
00:45:31 <EvanR> you need the old module to open an uncheckpointed db
00:45:47 <EvanR> youll see it wont load if you modify the events
00:48:20 <osa1> EvanR: am I getting this right: I need checkpoints to be able to make any changes in the event types?
00:49:10 <EvanR> the database contains 1) some state of your database value 2) update events since that point
00:49:30 <osa1> yeah I got that part
00:49:33 <EvanR> when you checkpoint you effectively fold over the events and replace the value, making 2) disappear
00:49:44 <osa1> OK, makes sense
00:49:47 <taktoa> suppose I have `foo :: (MonadThrow m) => m (Maybe Text)` and `bar :: (MonadThrow m, Read r) => Text -> m r` and I want to get a `(MonadThrow m) => m (Maybe Int)`... what combinator do I need to do this? I'm sure it's simple; my brain is just failing me right now.
00:49:56 <EvanR> if you dont, then change the code, your program will reject the database as is
00:50:10 <EvanR> unrecognized event
00:50:19 <osa1> EvanR: so I can use completely different event types after a checkpoint?
00:50:25 <EvanR> i think so
00:50:33 <osa1> OK, thanks a lot EvanR
00:51:33 <taktoa> to clarify, the Int is the concrete type resulting from instantiating r with the Read Int instance
00:53:32 <osa1> taktoa: you need to catch partial read errors in a wrapper
00:54:12 <taktoa> so I need to involve the catch function from MonadCatch?
00:55:01 <osa1> taktoa: yes, otherwise `bar` will throw an exception because of partial `Read` functions and you need to get a `Nothing` in that case
00:55:09 <sdx23> depending on what you want, readMaybe may be an Option.
00:55:11 <osa1> s/otherwise/because
00:55:27 <osa1> it can't be an option, bar is a black box here
00:55:55 <osa1> it'll fail with an exception because return value is not a Maybe, Either etc.
00:56:22 <boombanana> 3233331jjiiii3543353//quit
00:59:21 <taktoa> osa1: wait, to clarify, foo and bar are total functions (up to exceptions in m, e.g.: if you instantiate m at Maybe, they are definitely total)
01:00:01 <osa1> taktoa: it doesn't matter, you need `catch` because you don't know specifics of `m`
01:00:21 <osa1> err wait
01:00:38 <osa1> you can of course instantiate m with Maybe
01:01:00 <osa1> I'm assuming you need a general combinator that works for all MonadThrow m
01:01:03 <taktoa> yes
01:01:46 <taktoa> I was just ensuring that you weren't referring to exceptions called in `read` (which is inevitably called by anything with type `Read r => Text -> r` or similar)
01:01:52 <taktoa> *exceptions triggered in
01:03:50 <taktoa> so does it just boil down to the fact that `MonadThrow m => m` and `Maybe` don't commute (e.g.: there exists no function of type `MonadThrow m => Maybe (m a) -> m (Maybe a)`), whereas `MonadCatch m => m` and `Maybe` do commute?
01:06:55 <taktoa> wait sequenceA seems to have the right type (but maybe the wrong semantics?)
01:07:18 <osa1> taktoa: I gotta leave for lunch now but I think Maybe (m a) -> m (Maybe a) is possible. just `catch` the `m a`, then return a Maybe
01:07:43 <osa1> :t sequenceA
01:07:45 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
01:08:29 <osa1> right
01:41:11 <Squarism> haskell compiler is a bit slow isnt it?
01:41:36 <sbrg> Squarism: ghc? there may have been some performance regressions in the past few years
01:42:04 <Squarism> im on 7.10
01:42:09 <Squarism> ghc right
01:42:33 <kadoban> It would be nice if it were faster. It usually doesn't impede my productivity though.
01:45:30 <sbrg> same
01:45:38 <sbrg> i hardly feel it since I use the repl so much when developing
01:51:08 <wespiser> we need more people to hack ghc for optimizations!
01:51:56 <EvanR> who optimizes the optimizer?
01:52:14 <kadoban> I wonder how approachable GHC is to work on ... never really looked myself.
01:52:34 <wespiser> kadoban: its a little tricky, I've been reading up on it last weekend
02:00:20 <osa1> optimizer optimizes itself in bootstrapping compilers ;-)
02:06:43 <osa1> kadoban: it's difficult at first. if you could find yourself a mentor that'd help immensely. I've never worked on non-Haskell compilers (wokred on Fay, GHCJS, GHC, lots of toy compilers) so I can't compare but I think it's fine once you get past the the getting started phase
02:07:39 <kadoban> I'll look into it. Most of the stuff I'm working on currently is a total waste of time, really should find something productive.
02:09:28 <maerwald> kadoban: why?
02:09:37 <maerwald> it's ok not to be productive
02:10:17 <kadoban> Yeah, but a healthy mix seems like a better idea, probably more satisfying than all nonsense.
02:10:20 <mszczygiel> ~
02:11:51 <osa1> that's why I work on weekends *sigh*
02:14:05 <maerwald> osa1: that's a great balance
02:14:53 <wespiser> i've found Stephen's intro to be quite helpful: http://www.stephendiehl.com/posts/ghc_01.html for laying out the ghc project
02:15:29 <kadoban> Nice, thanks
03:33:22 <superlinux> how can i add in my stack project the "gtk" under build-depends in my project cabal file?
03:34:51 <lyxia> superlinux: you can add it under extra-deps, gtk-exact.version
03:36:36 <superlinux> lyxia, i am asking for the syntax of adding it
03:38:06 <lyxia> actually gtk is already on stackage. Why do you need to add it?
03:39:30 <lyxia> extra-deps:
03:39:35 <lyxia> - 'gtk-14.6'
03:39:44 <lyxia> superlinux: is that what you're asking
03:46:09 <superlinux> lyxia, yep!
03:46:17 <superlinux> exactement
04:20:49 <domenkozar> anyone knows if it's possible for stack to leave build folder alive after build failure?
04:34:01 <vaibhavsagar> why is (\\) in Data.List implemented using foldl instead of foldl'?
04:34:31 <vaibhavsagar> that seems like a bug
04:41:31 <mfukar> maybe because foldl' would hang on infinite lists?
04:42:06 <mfukar> not being condescending, I don't actually know. thinking out loud.
04:43:04 <vaibhavsagar> would (\\) even work on infinite lists anyway?
04:43:44 <vaibhavsagar> yeah, I guess it might
04:44:06 <osa1> foldl also hangs on infinite list
04:44:28 <osa1> > foldl (\l _ -> l) 0 [1..]
04:44:29 <vaibhavsagar> oh hey, you're right
04:44:36 <lambdabot>  mueval: ExitFailure 1
04:44:56 <osa1> it's about how strictly you accumulate the result
04:44:58 <vaibhavsagar> this matters to me because HSpec's shouldMatchList uses (\\) under the hood
04:45:08 <vaibhavsagar> and I'm trying to reduce space leaks
04:45:37 <vaibhavsagar> so I've been trying http://neilmitchell.blogspot.co.id/2015/09/detecting-space-leaks.html
04:46:03 <vaibhavsagar> but I can't get past the stack overflow in my test suite
04:49:30 <osa1> (\\) is a bad idea unless your lists are very very small. generating sets + taking diff + generating list is probably a better idea for most lists. I actually had a benchmark about that, it's somewhere in my github page
04:49:48 <osa1> the problem with set-based approach is that you need Ord instances
04:49:49 <vaibhavsagar> that's a bug in hspec then?
04:50:02 <vaibhavsagar> what about unordered-containers?
04:50:23 <osa1> I probably wouldn't call it a bug
04:50:34 <osa1> unordered-containers needs hash methods, right? I don't remember
04:50:47 <vaibhavsagar> yeah, I think you're right
04:50:51 <osa1> yeah it needs hash methods
04:51:12 <vaibhavsagar> might open an issue anyway
04:51:27 <osa1> vaibhavsagar: send a pull request, it should be simple enough. see what will the mantainers say
04:52:30 <Shou> vaibhavsagar, \\ would only work if the RHS is finite. It wouldn't be productive otherwise, since it needs all elements of the RHS to see whether they're in the LHS and whether to remove them.
04:55:30 <osa1> Shou: that's only true if you don't want Ord instance for elements
04:58:06 <Shou> You mean if the infinite lists are ordered?
04:59:02 <osa1> being infinite or not doesn't matter -- if you have some kind of sorted list or ordered data structure like containers's Set you don't need to traverse the whole thing
04:59:30 <osa1> well
05:00:01 <osa1> umm
05:00:05 <osa1> well it doesn't work on lists
05:00:07 <osa1> ignore
05:00:24 <osa1> if you have (repeat 5) and look for 6
05:03:52 <Psychiatrist> Hey. Is there a way to list all sub-modules of Data in GHCI? I can list the functions via :browse Data.List but I'd like to see a list of all the sub-modules inside Data, e.g List, Maybe, Tree etc.
05:08:04 <iphy> I've seen cabal dependency resolution failures several times, and I still can't read them
05:08:09 <iphy> https://travis-ci.org/TokTok/website#L235 what does this mean?
05:10:17 <maerwald> maybe the old base version is locking too much
05:11:25 <iphy> I'm pretty sure there is at least one solution to the constraint problem
05:11:40 <iphy> because I'm using it locally with stack
05:15:08 <iphy> cabal 1.18 doesn't seem to have freeze
05:16:11 <ClaudiusMaximus> Psychiatrist: type ":m Data." (without quotes) and press the tab key followed by y
05:17:06 <vaibhavsagar> Thanks @osa1 https://github.com/hspec/hspec-expectations/issues/28
05:17:26 <Psychiatrist> ClaudiusMaximus: Thanks!
05:21:49 <osa1> vaibhavsagar: good. btw you can see if that works for you by replacing `(\\)` with `foldl' (flip delete)`
05:25:40 <Psychiatrist> ClaudiusMaximus: Is there a way to get the list of all the packages as well in GHCI? Like Data, Control etc?
05:32:57 <Shou> Psychiatrist, import <tab> lists them all
05:33:32 <Shou> Or :module <tab>
05:35:36 <Psychiatrist> Shou: This is pretty neat, thanks.
05:38:12 <Shou> No problem :)
05:50:36 <s4ke> i am getting a weird stack behaviour... I want to be able to access a module from a hidden package, but if i add it to the *.cabal file, it gets removed
05:51:08 <s4ke> s/a/
05:57:43 <how> Right now, if I want to use both semigroup and monoid interface, is the recommended method (Semigroup a, Monoid a) => ...
06:00:41 <ertes> how: if you need Monoid, use Monoid
06:01:43 <pavonia> What does it mean that Semigroup has two different (<>)'s here? https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Semigroup.html#t:Semigroup
06:02:01 <ertes> how: you might get an additional Semigroup constraint via transitive class dependencies, but you shouldn't ask for both deliberately
06:03:20 <ertes> pavonia: the latter is actually the default signature…  seems like haddock misinterpreted the source
06:03:43 <pavonia> Default for what?
06:03:48 <how> ertes: I get error Could not deduce (Data.Semigroup.Semigroup v)
06:04:14 <ertes> pavonia: (<>) = mappend -- default definition, which requires a Monoid constraint, which requires -XDefaultSignatures
06:04:18 <ertes> pavonia: see the source code
06:04:26 <how> ertes: The thing is I have type a that uses the moniod interface and type b that uses the semigroup interface
06:04:45 <pavonia> ertes: I saw the source, but I don't know what the meaning of that is
06:05:05 <ertes> how: if you import Data.Semigroup, then (<>) refers to the Semigroup one, not the Monoid one…  it's a bit unfortunate
06:05:29 <ertes> pavonia: you know what default definitions in type classes are?
06:05:41 <pavonia> No
06:06:19 <ertes> pavonia: example:  class Num a where …; (-) :: a -> a -> a; x - y = x + negate y; …
06:06:44 <ertes> so if you define (+) and 'negate' in your instance, you get (-) for free
06:07:06 <pavonia> Since when does that requie the default keyword?
06:07:22 <ertes> it doesn't…  that's regular defaults
06:07:35 <ertes> now sometimes the default definition requires a stricter type
06:08:06 <ertes> class Semigroup a where (<>) :: a -> a -> a; default (<>) :: (Monoid a) => a -> a -> a; (<>) = mappend
06:08:35 <ertes> you get (<>) for free if your type is also a Monoid
06:08:45 <pavonia> Ah, I understand
06:09:01 <pavonia> Thanks ertes!
06:22:48 <ertes> if a C function has the attributes "MT-Safe locale" it just means that it might see partial changes to a concurrent locale update…  but it is actually a 'safe' FFI call, right?
06:24:14 <ertes> (the function in question is 'wcwidth' from glibc)
06:41:03 <f-a> hello #haskell: I recall in the past having browsed a haskell repository where all testing was contained in .txt files. Basically the file was divided in two halves (by a series of ---), in the upper part there was some data and in the lower part the expected output
06:41:56 <f-a> Was that a particular feature of a particular testing library? Or handrolled?
06:43:07 <tdammers> probably shelltestrunner
06:44:00 <f-a> thanks tdammers , I'll check that
06:46:39 <ocramz> hullo
06:46:47 <Akii> can someone tell my why GHC can't deduce type `t` here? http://lpaste.net/350816
06:48:36 <ocramz> Akii : because `t -> ev` but the compiler doesn't know which `t` you want to use ..?
06:49:15 <Akii> can I tell the compiler that there is only one `t` somehow?
06:49:34 <ocramz> in some cases you can have a two way fundep, like `t -> ev, ev -> t`
06:50:08 <ocramz> or you could use a type family parametrized by `ev`
06:50:27 <Akii> so I'm at least digging into the right direction this whole time xD
06:50:45 <Akii> thanks! I'll dig into type families more then
06:51:45 <ocramz> my pleasure :)
06:52:10 <ocramz> Akii : perhaps you could write a concrete instance of `TypedEvent` ? 
06:52:46 <Akii> I'm still fiddling around; right now I'm glad that I've gotten to the core problem
06:52:55 <Akii> which is this relation between "event type" and "event"
06:53:07 <Akii> what do you mean by that?
06:53:23 <Akii> oh you mean an example?
06:57:11 <ocramz> Akii: yep, an example instance
06:58:31 <Akii> ocramz: got it to compile; example usage is below http://lpaste.net/350818
06:59:00 <Akii> (yay ^.^)
07:00:32 <ocramz> Akii : nice :)
07:01:37 <Akii> pretty sure this can be improved; time to check out type families
07:03:42 * shapr adopts Akii into his type family
07:05:20 <c_wraith> shapr: what kind of family is that?
07:08:29 <c_wraith> ...  I was expecting * -> * as an answer.
07:08:49 <Akii> what a kind family
07:08:50 <shapr> c_wraith: aw, I went away to make coffee and missed the straight line
07:08:55 <shapr> Akii: haha!
07:08:57 <Akii> xD
07:10:17 * maerwald disables the type family extension
07:11:24 <Akii> so back to the Pokémon blog post then
07:12:01 <shapr> Akii: are you parsing pokemon?
07:12:43 <Akii> nope but there is this Pokémon blog post introducing type families
07:13:26 * maerwald blinks
07:13:49 <Akii> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon
07:14:09 <maerwald> oh dear
07:14:23 <geekosaur> (be careful what you ask for...)
07:14:33 <mettekou> I find myself folding structures to build a function a lot lately, for example at: https://github.com/lapis-lang/lapis/blob/develop/src/Lapis/Grammar.hs#L34. I feel like I'm rediscovering some functional programming folklore here, but am I? Is this a common technique? Are there any known disadvantages?
07:14:54 <Akii> maerwald: pika pikaa!
07:16:06 * maerwald smells something weird and walks off to -offtopic
07:20:14 <c_wraith> mettekou: that should probably be a foldr instead of foldl'
07:20:34 <c_wraith> mettekou: that preserves laziness better
07:21:43 <mettekou> c_wraith: Is there a reason to preserve laziness on structures which I know not be infinite (terms of a programming language input by a user)?
07:22:01 <c_wraith> mettekou: and it's not like forcing functions to whnf does anything unless seq was used to make something else depend on the evaluation of the function
07:23:26 <c_wraith> mettekou: sure it matters. it allows laziness in the underlying function to be preserved.
07:23:49 <ertes> any ideas on how to tie the knot with recursive free monads more elegantly?  data Lang x = With (A -> x) (F Lang A)
07:24:17 <ertes> the free monad of Lang supports an operation 'with' that takes a free-of-Lang action as its argument
07:24:45 <ertes> i'd prefer not to have that hardcoded F in there (from Control.Monad.Free.Church)
07:26:10 <ertes> mettekou: implement 'take' in terms of 'foldr' vs. 'foldl'
07:26:19 <ertes> mettekou: the former does not insist on traversing the whole list
07:26:55 <ertes> which is an advantage, even if the list is finite
07:27:14 <janosp> Hi, short question about Parsec: I try to parse Formulae like "(p^p)" where "^" an infix connector. Problem is: I want to parse "p", "(p^p)" but not "p^p"
07:27:35 <janosp> but I am struggling to get "p^p" rejected
07:27:57 <c_wraith> janosp: I think you need to make the grammar for infix connectors require parens.
07:28:00 <janosp> anyone experience with writing such a parser?
07:28:12 <c_wraith> janosp: that is, don't even parse infix connectors without parens.
07:28:57 <janosp> c_wraith, how to I do that, I mean to require parens?
07:28:57 <Ferdirand> atom = identifier | '(' expression ')' 
07:29:19 <Ferdirand> expression = atom [ '^' atom ]
07:29:22 <Ferdirand> or something like that
07:29:42 <Ferdirand> add other operators within the expression production
07:30:39 <janosp> what does the "]" stand for?
07:30:53 <c_wraith> optional
07:32:23 <janosp> no idea how to use this information tbh :D
07:32:29 <Ferdirand> then if you want left-associative operators it gets messy
07:32:29 <Ferdirand> there are combinators for that
07:32:30 <Ferdirand> yes sorry that was not valid haskell
07:32:30 <Ferdirand> i'm just showing how to achieve this effect within the bnf
07:32:45 <Ferdirand> okay so this is not really a parsec question, it's more that you don't know the formal specification of your grammar yet ?
07:33:19 <c_wraith> Or else the question is "how do I do anything at all with parsec?"
07:33:20 <janosp> Might be :)
07:33:36 <Ferdirand> do you want to accept (p^p)^p, (p^p)^(p^p), (p^p^p) ?
07:33:48 <janosp> ah
07:33:51 <janosp> no
07:34:04 <Ferdirand> and for the latter, should it be ((p^p)^p) or (p^(p^p)) ?
07:34:22 <c_wraith> I think it's supposed to always have parens, and always be binary
07:34:30 <c_wraith> No associativity questions
07:34:47 <janosp> Ferdirand, both should be possible
07:35:03 <c_wraith> You know, a typical super-formal system.  Leave nothing that even looks potentially ambiguous.
07:35:24 <Ferdirand> i meant, which of these two should (p^p^p) translate to
07:35:29 <c_wraith> neither
07:35:32 <c_wraith> it should be rejected
07:35:33 <janosp> the only cases without parens should be p and -p
07:35:34 <Ferdirand> great, that's even easier
07:36:01 <janosp> c_wraith, correct
07:36:03 <Ferdirand> so, you can distinguish between two things you are attempting to parse
07:36:05 <c_wraith> that's what I mean..  I think the question is actually "How do I use parsec?"
07:36:10 <Ferdirand> expressions and atoms
07:36:27 <Ferdirand> or terms maybe
07:36:32 <Ferdirand> don't know the proper name in english
07:36:33 <c_wraith> Because this grammar is intended to have no thought required at all to parse.
07:37:10 <janosp> ok, I mean I got the base cases working
07:37:16 <Ferdirand> let's say expressions and terms
07:37:26 <janosp> just my problem is, that it doesn't reject p^p 
07:37:38 <janosp> Ferdirand, ok 
07:37:47 <Ferdirand> p is a term
07:37:53 <Ferdirand> p^p is an expression
07:37:58 <Ferdirand> (p^p) is a term
07:38:05 <c_wraith> janosp: that would be because you're not requiring parens when you parse infix connectors.  They should be part of the same parser.
07:38:17 <janosp> why 
07:38:27 <c_wraith> because that's how you solve it. :)
07:38:27 <Ferdirand> because that is what you asked for ?
07:38:33 <janosp> sorry, why is p^p a expression?
07:38:46 <c_wraith> Oh.  It shouldn't be.  I think that's a wild goose chase.
07:38:56 <Ferdirand> well first
07:39:05 <Ferdirand> do you have any symbols other than the letter p ?
07:39:10 <Ferdirand> and any operators other than ^ ?
07:39:29 <c_wraith> I think Ferdirand is handling more complex cases than are necessary here.
07:39:29 <janosp> any letter except 'v' :)
07:39:32 <c_wraith> This is simpler.
07:40:00 <ertes> i'm going with explicit delimiters for my free monad problem now:  data Lang x = Start x | Stop (A -> x)
07:40:16 <ertes> not a particularly elegant solution though
07:40:29 <Ferdirand> another question is
07:40:34 <Ferdirand> do you want to accept (p) ?
07:40:44 <Ferdirand> and ((p)), (((p))), etc ?
07:40:48 <janosp> Ferdirand: operators are ^ v > and prefix is -
07:41:00 <Akii> ocramz: now with type families! http://lpaste.net/350819 thank you again :D
07:41:05 <janosp> Ferdirand: ((p)) should be rejected
07:41:11 <Ferdirand> but not (p) ?
07:41:20 <janosp> Ferdirand: correct
07:41:29 <Ferdirand> then it gets messy
07:41:40 <c_wraith> janosp: are you sure about that?  That's an extreme complication of the grammar
07:41:53 <c_wraith> janosp: which otherwise seems to have been chosen to be as simple as possible
07:42:10 <janosp> c_wraith: yes, I didn't design the grammar
07:42:28 <janosp> actually I solved it without using parsec already
07:42:42 <janosp> but I thought there is a more elegant solution by using parsec
07:43:15 <c_wraith> The thing is, allowing (p) means the grammar isn't ll(1) anymore.
07:43:41 <c_wraith> Everything else about the grammar seemed to be designed to make it trivially ll(1)
07:44:12 <c_wraith> Wel, ok, it's probably still ll(1), but only in a far more complex manner.
07:44:34 <janosp> It is a definition from propositional logic where: fmla = prop | -prop | (fmla ^ fmal) |  (fmla v fmal) |  (fmla > fmal) 
07:44:49 <c_wraith> janosp: where does that allow (p)?
07:45:03 <janosp> c_wraith: it doesn't
07:45:10 <c_wraith> So reject it!
07:45:17 <janosp> c_wraith: ah I see
07:45:21 <c_wraith> janosp: I mean, that grammar is more or less the solution to your problem.
07:45:37 <janosp> c_wraith:  I meant with "correct" that (p) should be rejected :)
07:45:41 <janosp> sorry for the confusion 
07:45:46 <c_wraith> Oh, whoops. :)
07:45:47 <Ferdirand> ah
07:45:53 <Ferdirand> no sorry I worded the question weirdly
07:46:05 <c_wraith> Ok, with that cleared up..  :)
07:46:54 <ertes> Akii: i sometimes use the following scheme:  data MyEvent f = SomeEvent (f Int) | SomeOtherEvent (f String)
07:46:57 <c_wraith> janosp: do you see how in that bnf, you only ever have parens around an infix operator?  Just make sure your parsec parser does the same thing.
07:47:26 <ertes> Akii: this is equivalent to your MyEvent if f = Identity and equivalent to MyEventType if f = Const ()
07:47:39 <ertes> Akii: it eliminates the need for the whole TypedEvent class
07:48:14 <janosp> yes, but how :D
07:48:25 <janosp> I am using buildExpressionParser
07:48:29 <ertes> Akii: http://ertes.eu/tutorial/config-monoids.html
07:48:33 <janosp> but this didn't make it clearer for me
07:48:35 <c_wraith> janosp: oh.  Don't use buildExpressionParser
07:48:41 <c_wraith> janosp: it's *far* more complicated.
07:48:41 <janosp> ok
07:49:06 <janosp> https://github.com/jpotecki/LogicTableauChecker/blob/master/src/FmlaParser.hs
07:49:10 <c_wraith> janosp: buildExpressionParser is for things that work like arithmetic.  It handles lots of special cases.  You don't have special cases. :)
07:49:10 <janosp> I tried it like that 
07:50:30 <c_wraith> janosp: where is allBins defined?
07:50:39 <c_wraith> and allProps
07:51:01 <c_wraith> Oh, are they just strings, allBins = "v^>"?
07:51:03 <c_wraith> etc
07:51:06 <janosp> allProps :: [Char] allProps = delete 'v' ['a'..'z'] 
07:51:08 <janosp> allBins :: [Char] allBins = "^>v"
07:51:13 <c_wraith> got it
07:51:48 <c_wraith> janosp: that looks more or less correct.  How is it breaking down?
07:52:22 <janosp> I'll run quickcheck
07:52:24 <janosp> one moment
07:52:38 <janosp> he accepts "p^p"
07:53:22 <c_wraith> I can't see how.
07:53:34 <Akii> ertes: I see
07:54:08 <c_wraith> janosp: oh!  I see how it could do that.  I don't remember enough about parsec...
07:54:19 <janosp> parseExpr =  parseNeg          <|> parseBinConn          <|> parseProp
07:54:20 <c_wraith> janosp: I think it's saying "yes, it's the proposition 'p'".
07:54:29 <c_wraith> janosp: and not parsing the rest of the input.
07:54:30 <janosp> excactly
07:54:42 <Ferdirand> add eof
07:54:42 <c_wraith> janosp: so make sure the parse uses the full input.
07:54:46 <shapr> Anyone doing machine learning in Haskell?
07:54:59 <janosp> Ferdirand: then he doesn't parse (p^p) anymore
07:55:10 <janosp> c_wraith: how?
07:55:15 <c_wraith> janosp: not in parseExpr
07:55:52 <ertes> shapr: i've done some binary and multinomial logistic regression, and i've used a genetic algorithm on one occasion
07:56:25 <shapr> ertes: so, separate libs but nothing like scikit learn?
07:56:42 <ertes> shapr: i've implemented everything myself, because i wanted a pure haskell solution
07:56:50 <c_wraith> janosp: add another parser..  Something like fullExpr = parseExpr <* eof
07:57:08 <c_wraith> janosp: and use that in your parsing functions instead of parseExpr
07:57:26 <ertes> shapr: the code is really messy, but if you need some of it, i'm happy to clean it up and put it online
07:57:29 <Ferdirand> applicative style for parsers is very nice
07:57:31 <janosp> lambdabot: <*
07:57:36 <c_wraith> :t (<*_
07:57:38 <lambdabot> error:
07:57:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:57:38 <c_wraith> :t (<*)
07:57:41 <lambdabot> Applicative f => f a -> f b -> f a
07:57:51 <janosp> thanks :)
07:58:17 <shapr> ertes: I don't need it right away, but I would love to see the code
07:58:53 <Ferdirand> parseNeg = Neg <$> P.char '-' *> parseExpr
07:59:07 <janosp> c_wraith: This seems to work
07:59:13 <Ferdirand> parseProp = Prop <$> props
07:59:16 <janosp> I don't understand why
08:00:03 <ertes> shapr: my genetic framework is actually pretty clever…  it lets you design the population freely using an applicative language:  winners *> mutations 100 *> randoms 5 *> …  -- it automatically determines how much to sort and when to stop based on your criteria
08:00:19 <c_wraith> janosp: it's just requiring that the entire input is used.
08:00:33 <shapr> ertes: ooh, that sounds nifty!
08:01:08 <ertes> shapr: i'll put the code online this week then =)
08:01:40 <janosp> :t (<*>)
08:01:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:01:53 <mkoenig> why does Data.Serialize.decode $ Data.Serialize.encode ("test" :: String) return Right () instead of Right "test"?
08:03:27 <janosp> Ferdirand: so parseNeg = Neg <$> P.char '-' *> parseExpr  means that , that if the parser pattern matches on '-' he will take the rest and parse it again?
08:05:07 <janosp> parseNeg :: P.Parser Fmla parseNeg = Neg <$> P.char '-' *> parseExpr
08:05:09 <c_wraith> janosp, when you parsed "p^p", it was completing after the first character, with "^p"  left over. parsec considers that to be a successful parse, and reported it as such. 
08:05:14 <janosp> that doesn't work :D
08:05:57 <janosp> c_wraith: yes, and *> parses the rest and fails right?
08:06:23 <c_wraith> janosp, no. it parses both and returns the second. 
08:11:14 <mkoenig> it's related to ghci... works properly with ghc
08:11:15 <Ferdirand> janosp: sorry, you need ()
08:11:31 <Ferdirand> <$> and *> are left-associative
08:11:37 <Ferdirand> so either
08:11:52 <Ferdirand> P.char '-' *> Neg <$> parseExpr
08:12:03 <Ferdirand> or Neg <$> (P.char '-' *> parseExpr)
08:12:34 <Ferdirand> <$> is fmap, so it applies a pure function to the result of a parser
08:13:04 <Ferdirand> <* and *> sequence two parsers and keep respectively the first or second result only (what's pointed by the arrow)
08:13:53 <Ferdirand> P.char '-' *> (Neg <$> parseExpr) sorry damnit
08:14:22 <janosp> Ferdirand: oh thanks, now i understand :)
08:15:06 <Ferdirand> or maybe a weirder way to write it
08:15:48 <Ferdirand> Neg <$ P.char '-' <*> parseExpr
08:16:39 <Ferdirand> <$ is (fmap . const), so it replaces the result of the parse with a constant
08:17:35 <Ferdirand> and <*> is ap, it parses two things in sequence and do function application on the results
08:19:15 <shapr> ertes: thanks!
08:27:14 <janosp> This Applicative stuff is still a bit new for me
08:54:48 <mmachenry> janosp: I really like chapter 11 of LYAH: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
08:59:58 <janosp> mmachenry: thanks :)
09:06:30 <Philippa> Supposing I want a "polymorphic map" (ie values have varying types) and I'm okay letting the same data structure do key generation: are branding/rank-2 tricks ala runST to create the map going to be adequate to let me write the thing without coercions etc?
09:07:04 <Philippa> (I don't want to use Data.Vault, if things are that messy I'd rather just play in ST overtly)
09:08:28 <Philippa> ...you'd need to make the brand distinct again each time you generate a key, wouldn't you? Damn.
09:09:31 <lyxia> what is messy in Vault
09:10:00 <Philippa> I didn't say "this is messy in Vault". If the situation is messy enough that using Vault is something to suggest, I don't want to use Vault
09:10:31 <Philippa> (please take "Vault is not an option" as axiomatic)
09:10:59 <hackrilege> Can I use | with record syntax?
09:11:13 <lyxia> hackrilege: in what context
09:11:37 <hackrilege> As if I wanted to redefine eg Either
09:11:47 <c_wraith> anything with a module named Data.Unique.Really seems pretty suspect. 
09:12:36 <ertes> Philippa: let yourself be inspired by the dependent-map library…  and perhaps you find utility in dependent-sum for the actual implementation
09:13:04 <hackrilege> data Either a b = Left {unleft :: a} | Right {unright :: b}
09:13:11 <ertes> Philippa: in fact dependent-map might just be what you're looking for
09:13:16 <MarcelineVQ> mkoenig: ghci has -XExtendedDefaultRules that are probably coming into play causing `a` to default to ()
09:13:23 <Philippa> c_wraith: yeah, what's actually going on is I want to do some serious manipulation of applicative-style parsers for... as it happens something weaker than CFGs but that contains the relevant problems? Which means you need a way to talk about all those non-terminals that yield different results
09:13:44 <Philippa> ertes: cool. Yeah, I'm massively out of the loop in terms of what exists, who's done what with the new extensions already etc
09:13:48 <lyxia> hackrilege: it works
09:14:22 <hackrilege> Great thanks!
09:14:25 <lyxia> partial field accessors are bad though
09:14:37 <hackrilege> Yeah, I thought it might throw errors
09:14:51 <Philippa> they're the equivalent of single-case pattern-matches
09:33:54 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706 | CTF hint: pattern matching'
09:33:54 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Thu Dec 29 08:06:48 2016]
09:34:18 <MarcelineVQ> janosp: have a look at the source for sample and sample' to see what lyxia meant about using generate directly
09:34:45 <qmm> does anyone use https://halcyon.sh ?
09:35:00 <qmm> why would you use halcyon instead of stack?
09:35:20 * qmm is trying to figure out the relationship between the two projects
09:35:30 <Philippa> okay, dependent-map and Data.Typeable sounds like that should be all I need for now and then safe keygen is "my problem" for now?
09:36:08 <Philippa> (plan: stash a Refl in my key type when I do the equivalent of a newRef, done and dusted)
09:36:25 <ertes> Philippa: what's the application?
09:36:27 <qmm> https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal "Because stack is just Cabal under the hood, other tools such as Halcyon for deployment and Nix are good fits complement stack nicely, or indeed cabal-install for those who prefer to work with a UI that they know well."
09:37:09 <Philippa> ertes: first one'll probably be letting me do grammar manipulation without losing the results part. Odds are I'll do some constraint-solving stuff later too though
09:37:18 <saurabhnanda> is there a version of digestive-functors which works with JSON directly? IIUC digestive-functors-aeson converts each possible Value to a FormInput and then processes it (FormInput has only two things -- TextInput and FileInput). Which basically means that parsing+validating native JSON types becomes unnecessarily harder.
09:37:24 <Philippa> (the latter /can/ be done in ST just fine, but you can't really take ST apart and watch it work)
09:37:41 <ertes> Philippa: you can take Free (ST s) apart
09:37:52 <ertes> that's a version of ST with breakpoints =)
09:38:04 <janosp> MarcelineVQ: Thanks, will look into the source!
09:38:08 <Philippa> sure, but that's not the thing I mean
09:38:22 <Philippa> you can't, for example, print all-that's-printable in the heap
09:38:43 <Habib_> Does anyone here use multiple language package managers for their projects? I've got a problem I need a bit of help on.
09:39:05 <ertes> Habib_: it's best just to ask
09:39:30 <ertes> Philippa: what do you need it for?  debugging?
09:40:03 <Habib_> I've got the cabal file for my app which is supposed to follow PVP. But I also have a package.json for my JS dependencies, which is supposed to follow semver. How do I reconcile these two seemingly incompatible versioning schemes.
09:40:16 <danilo2> Hello guys! Why such error can even occur in GHC? Is there ane special case when this could not be true? ` Couldn't match type ‘Abstract t’ with ‘Abstract t’`  ?
09:40:29 <Habib_> I even have an elm-package.json, but I think that's just semver as well, though I'd have to double check.
09:40:31 <Philippa> ertes: amongst other things, yeah. When you're doing the whole LARPing-academia thing, sometimes it's useful to be able to show an actual middle-of-runtime state of the entire computation to explain what's going on
09:40:34 <danilo2> both `t` have the same kind
09:40:43 <danilo2> and `Abstract` is just a type family
09:40:52 <Philippa> I can do that for the pen'n'paper version just fine ofc, but that's not really ideal
09:41:57 <lyxia> danilo2: does it say something about the type family not being injective
09:42:07 <Philippa> also, tbh I think "I want to see the output of this stage, not just the final stage of my eventual goal" goes beyond debugging? If I'm constraint-solving I'd be compiling typed CHRs for example
09:42:36 <Philippa> seeing the compilation in progress has value, even if you eventually swap half of it for a final-style representation
09:42:45 <ertes> Philippa: well, the ugly solution is Debug.Trace…  alternatively we have constraint kinds and equality constraints now, so you can do this:  myAction :: (Debug s) => A -> ST s B
09:42:52 <Philippa> (tbh, I strongly dislike final style as a thing for people to read)
09:43:11 <Philippa> ertes: you can safely assume I know what I'm doing when it comes to instrumenting the hell out of Haskell code
09:43:18 <danilo2> lyxia: yep it tells about it, but I donth think injectivity will have any efect here. Look, this are jsut two "evaluations" of this type family for the same argument, why injectivity could play a role in this situation?
09:43:23 <ertes> Philippa: now write two modules Debug and Prod, such that Debug exports:  type Debug s = s ~ RealWorld;  debug :: String -> IO ()
09:43:42 <ertes> Philippa: and Prod exports:  type Debug s = ();  debug :: String -> ST s ()
09:44:10 <Philippa> ertes: which is cute and all, but underestimates what happens when I get serious about effectful programming :-)
09:44:11 <ertes> Philippa: if you import Prod, then myAction becomes an ST action…  if you import Debug it becomes an IO action
09:44:37 <ertes> Philippa: well, i don't know your application, so i can only provide ideas =)
09:44:55 <Philippa> ertes: just to be clear: I may be rusty, but there was a time when I was one of the people you talked to when you're looking to push the edge of what's possible :-) I've got the thing I need (and thank you very much!)
09:45:07 <ertes> Philippa: yes, i remember you ;)
09:45:19 <lyxia> danilo2: the error is saying that these may not be the same arguments
09:45:34 <ertes> Philippa: in fact i've been wondering about you a while back
09:45:51 <Philippa> "Real Life Happened" is the short version. Admittedly opping in here isn't exactly fun either
09:46:32 <Philippa> I managed a talk for Conor McBride's lot a few months ago about stuff I'd been talking to people about for a few years (Conor included), otherwise not much activity
09:46:32 <maerwald> qmm: last commit in 2015
09:46:53 <danilo2> lyxia: are yout talking about these two `t` ? That they "couldn ot be the same"?
09:47:07 <lyxia> danilo2: it's t and t'
09:47:21 <lyxia> oh no it's t
09:47:22 <Philippa> I think information effects are still percolating in terms of their sheer consequences for how we can understand programming and in some regards I'm becoming more of a logic programmer than a functional one but in ways that are very closely related
09:47:32 <lyxia> danilo2: sorry
09:48:19 <danilo2> lyxia: I'm almost sure uits the same t, even thinking that the renamer could have a bug, it seems it the same t
09:48:31 <Philippa> as I think everyone else is learning given the current popularity of free monads: you can't instrument pure code, you can do /all kinds/ of stuff the moment you've taken apart the recursion on something and every effect is an opportunity for further instrumentation etc
09:48:49 <Philippa> (or to put it another way: if you have control of how something's run, every effect can be given a context as well as an interpretation)
09:49:26 <ertes> Philippa: i'll be happy to learn more about this, when i get back
09:49:29 <Philippa> free monads aren't currently my favourite way to do things, but that's partly because if I get serious about the sweng I want to take all the recursion apart :-)
09:49:50 <Philippa> heh. I can't promise to be on top teaching form, but I'll not /part for a while I guess
09:49:53 <ertes> i'm a major fan of free monads =)
09:50:24 <Philippa> I can see that there are things to be done with them that go beyond what the average tutorial shows? Those are mostly the things that'll sell me when I'm finally sold
09:50:36 * johnw is also a huge fun and user of free monads
09:50:39 <johnw> fan*
09:50:48 <Philippa> we have a major problem with free monad articles taking over the google search space re writing interpreters in haskell though
09:50:58 <ertes> so see you later =)
09:51:03 <johnw> Philippa: once you separate building an expression from evaluating it, you can do almost anything
09:51:07 <Philippa> beginners looking for how to write an interpreter get free monad all over the place
09:51:19 <Philippa> johnw: old news, but yeah
09:51:26 <johnw> really, really old news :)
09:52:02 <johnw> Free is just a convenient way to generate "the obvious structure"
09:52:08 <Philippa> let's face it: we're /still/ doing old lisp tricks only managing to do it typefully
09:52:20 <johnw> Greenspun ftw
09:52:23 <Philippa> I'm at the point of seeing it as "less inconvenient than usual" still
09:52:40 <Philippa> but my tolerance for overhead is notably (possibly still infamously?) low
09:52:44 <johnw> now that we have pattern synonyms, all the inconvenience can be removed from the user
09:53:03 <johnw> for library authors, there is still some boilerplate, but TH can eliminate that too
09:53:15 <johnw> actually, there's a library idea, if it has been done
09:53:30 <Philippa> eh. I'm inclined to agree with Conor McBride's agitation there? And I'm normally library author often /enough/ to get bitten
09:53:37 <johnw> given a functor, auto-generate its Free type and all the smart constructors and pattern synonyms needed
09:53:38 <maerwald> pattern synonyms still suffer from the exhaustiveness check no? and TH is simply not typsafe
09:53:54 <johnw> no, but what TH generates still must type check
09:54:32 <Philippa> johnw: yup. I'm at the point where building something of approximately "standard" haskell's power or even ML's with some of that built in would let me write a lot of fun stuff
09:54:38 <saurabhnanda> any idea how I can use ".:" as a qualified import?
09:54:43 <Philippa> but often Fix is enough for my purposes or even the more directly appropriate thing
09:55:01 <Philippa> (because often the type-level fixpoint corresponds with a term-level one I want to manipulate too)
09:55:36 <johnw> if I write this TH library, it will reduce the code size of parsec-free considerably
09:55:43 <Philippa> *nods*
09:55:47 <kadoban> saurabhnanda: You mean an explicit import? import   Blah.Blah ((.:))    ?
09:56:03 <Philippa> I guess TH works on ARM these days too
09:56:09 <Philippa> (spot who's used Haskell in anger on a raspi...)
09:56:21 <saurabhnanda> kadoban: import qualified Data.Aeson as A((.:)) -- how do I use A..: now?
09:56:25 <MarcelineVQ> saurabhnanda: something like this you mean?  import qualified From.Somewhere as S ((.:))
09:56:30 <geekosaur> (A..:)
09:56:35 <MarcelineVQ> oh
09:57:12 <geekosaur> or as an infix, A..:
09:57:12 <saurabhnanda> thanks
09:57:15 <geekosaur> looks horrid but works
09:57:29 <saurabhnanda> btw, why will this not compile (getting an ambiguous type error) -- formlet = (Form..:) 
09:57:43 <geekosaur> monomorphism restriction
09:58:01 * geekosaur will usually do a top level binding to rename it, to hide the ugly in one place
09:58:27 <geekosaur> either -XNoMonomorphismRestriction, add an explicit type signature, or eta expand it
09:58:56 <Philippa> I'm surprised none of my coding yesterday resulted in a NoMonomorphismRestriction LANGUAGE pragma, come to think of it
09:59:27 <Philippa> then again, the MR is one of those things that would be utterly needless if we did JIT inlining
09:59:57 <Philippa> (big project, not one I'm offering to undertake, but the fact a "completely removes the need" technique exists is still significant IMO?)
10:01:24 <Philippa> ...huh. In the presence of laziness, do we actually have a good way to use TH to stage the evaluation of something static that's big enough to not trust the inliner on?
10:01:51 <Philippa> "good way" implies "I don't want to have to write deepSeq for every structure involved"
10:02:55 <Philippa> (example thing I might do that with: I've got a completely static grammar and I don't want to have to write a "parser generator" in the spits-out-source-code sense but I've got everything but the pretty-printer)
10:03:24 <Philippa> (and I don't want to pay the price of its optimisations lazily on startup each time...)
10:08:53 <Athas> Oh man, intero-mode is really good.
10:09:11 <Athas> This is much better than my old patchwork of haskell-mode addons.
10:09:33 <Athas> (Although it couldn't load my program until I got 16GiB of RAM.)
10:09:43 <blackdog> Philippa: i've done it a few times with TH. the difficulty is that you're still relying on Lift instances, a lot of which are pretty inefficient anyway..
10:10:55 <blackdog> Philippa: (you think you're going to get some nice packed representation of a Vector but it's usually just piggybacking on lists)
10:11:01 <Philippa> blackdog: ouch. What exactly needs doing? I mean, ultimately I'd like to be able to write what amounts to an "eager splice"
10:11:17 <Philippa> blackdog: which bit?
10:11:48 <Philippa> I mean, I don't trust anything representationally that I haven't poked at :-)
10:11:50 <blackdog> https://gist.github.com/mwotton/19b4223911ceda0c46a603af377c7e1f this sort of thing
10:12:47 <blackdog> well, i think if you wrote better Lift instances than the ones at https://github.com/bennofs/th-lift-instances/blob/master/src/Instances/TH/Lift.hs it could work, but i'm not exactly sure what's possible
10:13:28 <blackdog> i got mine to the point where i had an ascending list at compile time, and could put a Map together in linear time. not perfect, but better than what i hadddd.
10:13:36 <Philippa> *nods*
10:13:45 <Philippa> yeah. Really this is one of those things that should be a TH feature
10:13:49 <blackdog> oh god i wish
10:13:56 <Philippa> "I am telling you that this damn thing terminates, go evaluate it already"
10:14:17 <blackdog> right. it's really annoying that you have to handle it at one remove as serialisable data
10:15:18 <Philippa> yeah. If you get things to a point where I'm actually happy trusting the final-stage inliner with the rest that's fine? Which is why I'm happy spitting out a grammar datatype rather than a pile of functions that it can't actually evaluate...
10:15:20 <blackdog> and if you hang the compiler, you get to keep the broken bits :)
10:15:40 <Philippa> there are still things to be said for initial representations and that is firmly one of them
10:16:31 <blackdog> yeah.
10:17:34 <Philippa> letting an inline-the-hell-out-of-it traversal turn that into the pile of functions is both easy and something we know how to talk to GHC about already
10:18:20 <blackdog> i hadn't thought about it in those terms - tbh i haven't got a good handle on when GHC will inline vs when it won't.
10:19:06 <blackdog> Philippa: do you need to do anything special in terms of INLINABLE, or does it just do a reasonable job?
10:20:25 <Philippa> blackdog: okay, so arguably I'm one of the people who shouldn't be saying "we"? I know it can be made to happen when you've flattened the data structure enough though, and even fairly early versions of parsec used techniques designed to exploit the inliner and other simple optimisations (notably "case/ctor", aka case analysis of a constant)
10:21:05 <blackdog> Philippa: cool, TIL :)
10:22:30 <blackdog> i do feel like this is an area where we could do better - explicit control of staged computation would be absolutely lovely.
10:22:51 <Philippa> blackdog: inline followed by case/ctor basically nets you a single level of deforestation? You jump to the function case your data would invoke
10:22:53 <Philippa> yeah, definitely
10:23:12 <blackdog> jdegoes was needling me a bit about data/codata vs laziness this morning - maybe that'd actually make this easier :/
10:36:55 <shapr> Has anyone tried to use Turtle inside a Haskell shell?
10:51:24 <shapr> Athas: now you've got me wanting to try intero
10:52:10 <fosskers> shapr, it's very good
10:54:11 <shapr> Hm, maybe I can find time to try intero today
10:56:13 <DemiMarie> Has anyone thought of improving the packaging situation of Haskell?
10:57:12 <mathk001> Hi I have a compiler issue using stack. In cabal file I have add `extension: cpp`  to enable conditional compiler.  But when invoking stack build I hand a syntax error on  the "#if MAX_VERSION_base..."
10:57:14 <lyxia> DemiMarie: what's the problem with it
10:57:26 <DemiMarie> lyxia: Fedora at least is almost always a version or two behind GHC HEAD
10:57:34 <DemiMarie> not sure about other OSs
10:57:43 <lyxia> oh package in that sense
10:57:47 <lyxia> no idea
10:58:14 <DemiMarie> lyxia: I suspect that the need to rebuild the Haskell world every time GHC is upgraded is the culprit
10:58:58 <DemiMarie> I know that Fedora's solution for Rust (which has the same issues) is to simply distribute all Rust libraries as source code only.
10:59:15 <mathk001> 3@
11:08:18 <robstewartUK> This is a segment of my stack.yaml file: http://lpaste.net/6732845627186610176
11:08:36 <robstewartUK> I'd like to depend on wx-0.92.3.0 , but I'm getting the error:
11:08:45 <robstewartUK> The following package identifiers were not found in your indices: wx-0.92.3.0
11:08:53 <robstewartUK> Possible candidates: wx-0.92.0.0, wx-0.92.1.0, wx-0.92.2.0.
11:09:02 <robstewartUK> Those found candidates are on hackage.
11:09:18 <robstewartUK> But I want to depend on the github version, i.e. 0.92.3.0
11:09:37 <robstewartUK> Why is `stack build` throwing this error? 
11:11:16 <kadoban> robstewartUK: You don't put things in extra-dep like that that are from git repos. Also I think you need a tad more config in the packages part to tell it that wx is in a subdirectory
11:11:56 <kadoban> robstewartUK: (and also you should probably turn on the extra-dep: true flag in the packages part, though it won't really be causing errors, just better for later.
11:12:03 <geekosaur> extra-deps seems wrong anyway, docs seem to think it's an array not a hash
11:13:13 <kadoban> Oh, you have the subdirs part in the packages section, I'm blind. Disregard that part.
11:13:42 <geekosaur> ah, ok, yaml detail accepts either
11:14:00 <kadoban> So yeah, just remove it from extra-deps and try.
11:21:58 <robstewartUK> kadoban: ok, I've removed it from extra-deps and now I'm getting "wx must match ==0.92.3.0, but the stack configuration has no specified version"
11:23:07 <robstewartUK> (my cabal file specificies wx==0.92.3.0 )
11:23:34 <kadoban> robstewartUK: Is there more to the error? And what does your stack.yaml look like now, just the same without the extra-deps part?
11:24:53 <robstewartUK> kadoban: http://lpaste.net/6732845627186610176
11:25:23 <kadoban> And that's the entirity of the error?
11:26:10 <robstewartUK> I've added the error message to that lpaste.
11:27:14 <kadoban> Hmm. I don't understand that error message. What stack version are you using? Relatively modern?
11:27:27 <robstewartUK> yes, 1.3.0
11:28:09 <taktoa> is there any conceivable reason a program could be made *faster* by adding HasCallStack constraints?
11:28:52 <kadoban> robstewartUK: Out of curiosity, what if you remove the version bounds for wx in the .cabal file? But I don't know what the problem is there, it looks fine to me. I gotta run for a few minutes, I'll be back in not too long if nobody else sees the problem though.
11:28:54 <taktoa> because I just benchmarked my program (with the `bench` tool) with and without them, and it seems consistently slightly faster with them added, weirdly
11:29:33 <taktoa> my best guess is that they are preventing an ill-advised optimization from triggering
11:34:06 <robstewartUK> kadoban: thanks, I'll keep looking into it.
11:34:38 <geekosaur> taktoa, quite possible. you can use -ddump-simpl to look at the core
11:34:49 <taktoa> oh, good idea
11:35:04 <geekosaur> (other options will make it more readable. or cabal install ghc-core and use ghc-core to get cleaned core for comparison)
11:35:27 <Tuplanolla> I recommend `-dsuppress-all` too, taktoa.
11:36:47 <robstewartUK> My bad! I had another `packages` entry further down the stack.yaml file. Sorted now.
11:37:26 --- mode: ChanServ set +o geekosaur
11:37:32 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706' by geekosaur
11:37:34 --- mode: geekosaur set -o geekosaur
11:37:45 <geekosaur> think the 33c3-ctf hint can go away now :p
11:46:54 <HelgeS> I want to learn Parsec, and to parse the string "[thestring]" to get "thestring". Is it a good idea to use 'between' from http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html?
11:47:11 <Tuplanolla> Yes, HelgeS.
11:47:13 <HelgeS> because I don't understand how to use it.
11:48:56 <Tuplanolla> Try `between (char '[') (char ']') (many letter)`, HelgeS.
11:49:11 <Fuco> I'm downloading web pages with `simpleHttp`.  I have a bunch these URLs in a list so my mapM over it... now I figured I could just mapConcurrently over it (from import Control.Concurrent.Async) and it will run in parallel... butonly the unevaluated thunks seem to be returned and then I download sequentially when I print the result
11:49:19 <Fuco> how can I force the download to happen in the "download" action?
11:49:31 <HelgeS> The cited web page says
11:49:33 <HelgeS> braces  = between (symbol "{") (symbol "}")
11:49:43 <HelgeS> and that doesn't seem to work.
11:49:48 <tdammers> HelgeS: not on its own
11:49:55 <tdammers> HelgeS: you need to supply another argument
11:49:58 <HelgeS> but between (symbol lexer "[") (symbol lexer "]") works
11:50:07 <tdammers> oh, wait
11:50:12 <tdammers> what's the type of symbol?
11:50:44 <geekosaur> HelgeS, generally theres a bit of boilerplate with the lexer stuff where you import it qualified and then have a bunch of local definitions e.g. symbol = L.symbol L.lexer
11:50:45 <HelgeS> symbol is from https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Token.html
11:50:53 <Ferdirand> if i remember correctly, you may also have brackets = between (symbol "[") (symbol "]") ?
11:51:48 <geekosaur> s/lexer stuff/token parsers/
11:52:18 <HelgeS> I've written this, which is accepted by ghci, but I don't understand how to write a type declaration for it.
11:52:19 <HelgeS> ph3 = do
11:52:19 <HelgeS>   h <- between (symbol lexer "[") (symbol lexer "]")
11:52:19 <HelgeS>   return h
11:52:42 <HelgeS> :t ph3     gives somehting that doesn't work
11:52:44 <lambdabot> error:
11:52:44 <lambdabot>     Variable not in scope: ph3 :: t0 -> t1 -> t2 -> t3 -> t4 -> t
11:52:44 <lambdabot> error: Variable not in scope: gives
11:55:44 <lyxia> between takes 3 arguments
11:57:06 <DemiMarie> Is it possible that explicit type applications and IORefs could cause a type system hole?
11:57:32 <Tuplanolla> Explain, DemiMarie.
11:58:07 <DemiMarie> Tuplanolla: It is well-known that with unsafePerformIO one can write unsafeCoerce, by creating a polymorphic IORef
11:59:27 <lyxia> DemiMarie: type applications should be safe
11:59:30 <geekosaur> I don't think a type application can cause a problem unless the IORef is already polymorphic? else it'd be a type error
11:59:57 <DemiMarie> But could one make a polymorphic IORef?
12:00:36 <DemiMarie> lyxia: I know
12:00:54 <geekosaur> afaik type applications only remove polymorphism, not add it
12:01:16 <DemiMarie> geekosaur: They also allow one to apply functions at polymorphic types
12:01:56 <lyxia> you would need newIORef :: IO (forall a. IORef a) which is not allowed
12:02:55 <lyxia> All TypeApplications does is remove the need to use proxies to disambiguate types.
12:03:29 <DemiMarie> lyxia: can you explain why that doesn't work?
12:03:58 <danpalmer> Hey, does anyone know where the stack docker images (fpco/stack-build, fpco/stack-run, etc) come from? I can't find where they come from?
12:04:19 <danpalmer> (have asked in #haskell-stack but it's a little quiet there)
12:08:01 <lyxia> DemiMarie: can you show me an example where you apply a function to a polymorphic type
12:16:13 <DemiMarie> Am I correct that type variables cannot escape a constructor?
12:19:19 <DemiMarie> Duh!  If type variables could escape constructors, then one could wind up passing them to functions that are lazy
12:20:44 <DemiMarie> and then break the type system by passing the result to functions that use the data at different types
12:21:56 <kuribas> DemiMarie: type variables are type level, and constructors value level.
12:21:57 <shapr> I think implicit parameters did that, sort of.
12:22:33 <Philippa> DemiMarie: type applications in Haskell don't let you do anything that couldn't be done in GHC's Core language already
12:22:53 <Philippa> in fact, inferring type applications is a large part of what the typechecker spends its time doing
12:23:29 <Philippa> you can't create a "polymorphic IORef" with them: forall a. IORef a is still exactly that and a type application strips the forall off
12:23:44 <DemiMarie> Philippa: got it
12:24:11 <ski> DemiMarie : are you referring to data constructors or type constructors ?
12:24:12 <Philippa> and it's the forall that type variables can't escape: that's their "binder" :-)
12:24:33 <geekosaur> that's what I was trying to say (poorly) earlier
12:25:49 <DemiMarie> So why does `newIORef undefined >>= \x -> writeIORef x (1 :: Int) >> readIORef` have type Int, not type forall a. a?
12:27:03 <DemiMarie> ski: type constructors
12:27:16 <geekosaur> [03 20:22:31] <Philippa> in fact, inferring type applications is a large part of what the typechecker spends its time doing
12:28:09 <orion> Has anyone gotten a chance to play with dhall?: https://hackage.haskell.org/package/dhall-1.0.1/docs/Dhall-Tutorial.html It's a configuration file language by Gabriel Gonzalez.
12:28:10 <geekosaur> so it used the (1 :: Int) to infer a type application at all other use sites, which as mentioned "strips" the forall
12:29:00 <ski> `x' is a lambda-bound variable, so is not polymorphic, and is inferred to have type `IORef Int'
12:29:16 <Philippa> DemiMarie: because the undefined can be anything, doesn't constrain the possible type, whereas when you write 1 :: Int, that constrains the type to be Int
12:29:30 <Philippa> notice that none of those functions will take a "forall a. IORef a"
12:29:40 <DemiMarie> Philippa: Ah, I see
12:30:02 <Philippa> their types go forall a. (IORef a -> ...), not (forall a.IORef a) -> ...
12:30:02 <DemiMarie> So if they did take such a type, they would be unsound
12:30:10 <Philippa> the latter would be requiring it to be polymorphic
12:30:35 <Philippa> the type "forall a.a" is only inhabited by things that crash, yeah
12:31:46 <Philippa> (the simplest definition of undefined is undefined = undefined. Which until recently made it alpha-equivalent to brexit, but we now know brexit :: forall a.(Red a, White a, Blue a) => a
12:34:06 <Athas> shapr: as long as your code fits in RAM... ghci can be a hungry one.
12:34:40 <shapr> Athas: I have 64GB of RAM that is (almost) always enough for my Haskell dev.
12:35:07 <shapr> when it's not enough, I've done it wrong :-(
12:35:32 <dolio> Did you just buy a new machine or something?
12:35:43 <dolio> Or did you buy a really expensive one a while ago?
12:35:48 <Athas> shapr: that'll do!  Until today, I only had 8GiB on my work laptop, which was a just below what is needed for my 40k SLOC codebase.
12:35:55 <Athas> And ghci is not a good swap citizen.
12:36:16 <shapr> dolio: I bought a really expensive laptop back in April (ThinkPad P50)
12:36:34 <shapr> Athas: you have 40k lines of Haskell?
12:36:50 <Athas> shapr: well, maybe more like 38k.
12:36:50 <DemiMarie> Athas: That is true of (almost) any GCd language
12:37:24 <Athas> DemiMarie: how so?  I'm talking about code size.  I used to have 100k+ lines of Lisp loaded on my old 512MiB machine.
12:37:47 <DemiMarie> Athas: I mean that the vast majority of GCs slow to a crawl once swapping occurs
12:37:55 <Athas> Oh, sure.  Definitely so.
12:38:18 <Athas> But compacting GCs are the worst of the lot.
12:38:27 <DemiMarie> Athas: That just means that GHC is inefficient at storing Haskell programs, which makes sense
12:38:43 * shapr steals Athas' garbage out of his trashcan
12:38:55 <DemiMarie> MLton can store ~200k of SML in memory at once with no problems
12:38:56 <Athas> Well, ghci, technically.  Which surprises me.  Bytecode is usually small, isn't it?
12:39:11 <DemiMarie> Athas: I don't think the bytecode is what takes up space
12:39:18 <Athas> Type information maybe?
12:39:26 <DemiMarie> Athas: That's what I suspect
12:39:46 <Athas> Either way, I'm surprised the commercial users haven't been bothered by this.  My code base is probably small by their standards.
12:40:10 <DemiMarie> Athas: Try starting GHCi with +RTS -M<slightly less than physical memory>
12:40:16 <shapr> Athas: I know simon marlow did some things to speed up ghci use for facebook
12:40:20 <dolio> Lines of code in your overall codebase doesn't have much to do with how much memory GHC uses.
12:40:21 <Athas> However, I have one happy-generated parser module, and I notice that loading that is *way* slower than anything else in my program.  I suspect it hits a worst case in ghci.
12:40:26 <Jello_Raptor> Is there some way to set a project wide set of default-extensions in a .cabal file? At the moment I've got duplicate lists for the application, libraries, and tests 
12:40:39 <Athas> DemiMarie: that's what I used to do, but then ghci would just die.  Better than killing the machine, that's for sure.
12:40:46 <DemiMarie> Athas: ah
12:41:00 <dolio> At least, in my experience.
12:41:10 <Athas> Now I have 16GiB of memory, so I can finally use intero.
12:41:26 <DemiMarie> Athas: Did you try +RTS -c?
12:42:03 <Athas> No.
12:42:31 <DemiMarie> Athas: That forces the RTS to use in-place compaction instead of copying
12:42:51 <DemiMarie> That avoids the 2x space penalty
12:43:09 <Athas> Hm.  Maybe that'd work.  I solved it with brute force (RAM upgrade) instead.
12:43:14 <DemiMarie> The RTS should switch to compaction before dying, though, if you use +RTS -M
12:43:28 <DemiMarie> Athas: I wonder how much RAM Facebook's dev machines have.
12:44:24 <DemiMarie> Athas: Would you mind reporting a bug regarding the parser?
12:44:56 <DemiMarie> Check how many lines the generated code is; if it takes way longer to load than it should for its size, that's a bug most likely
12:45:03 <Athas> DemiMarie: sure, I might do that one of those days.  It's just a hunch of mine, the slow load may be unrelated.
12:45:18 <Athas> Although memory usage *does* go through the roof during loading that module, too.
12:50:04 <DemiMarie> Athas: According to bgamari over at #ghc 8G RAM consumption isn't normal for GHCi on a 38k line codebase
12:51:54 <Dansvidania> Hello everyone, I need a few pointers on Trifecta, is there anyone available to help>
12:51:56 <Dansvidania> ?
12:52:34 <DemiMarie> Athas: whoops, @bgamari thought the codebase was 38k bytes
12:53:24 <bgamari> Dansvidania, I have used trifecta in the past
12:53:35 <bgamari> Dansvidania, it's generally best to just ask your question
12:54:08 <bgamari> DemiMarie, Athas, 8GB sounds a bit high even for 38kLoC though
12:56:18 <Dansvidania> fair enough. Is there a way to get the input passed to a Parser from within the monad itself?
12:57:04 <bgamari> Dansvidania, what subset of the input would you like?
12:57:58 <Dansvidania> the currently unconsumed string, or the whole thing, both would work
12:58:46 <Dansvidania> I tried to go through the documentation without success, so I would be happy even just with pointers on what to look for 
13:01:26 <ski> edwardk ^
13:04:12 <Athas> bgamari: if you want to see for yourself, it's https://github.com/HIPERFIT/futhark and a 'stack ghci' will do the trick (pick candidate #1).  I see growing memory usage all throughout the loading, although I can't seem to isolate the parser's contribution anymore.  Weirdly, once loading is done and I get the ghci prompt, memory usage rapidly increases by 2GiB.
13:04:45 <Athas> Only uses 7.1GiB, not 8, though.
13:06:39 <JordiGH> People in HN are insinuating that category theory is very useful for using and understanding Haskell. Real or malarkey?
13:07:10 <Athas> JordiGH: it is useful at least because many Haskell libraries are built on category-theoretical concepts.
13:07:29 <Athas> But for Haskell itself, you could view it using a different formalism.
13:07:48 <JordiGH> So to use and understand those libraries, I need to know what a universal object in the category of zygomorphisms look slike?
13:07:49 <isd> I find it's frequently overstated.
13:08:09 <Athas> JordiGH: for a sufficiently abstract library, yes.  But those are very rare and not necessarily useful.
13:08:18 <isd> You can get pretty darn far without it
13:08:19 <freak0t> sluts
13:08:27 <freak0t> HACK THE GIBSON DUDE
13:08:29 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.188.72.118.25
13:08:30 <Tuplanolla> Math is everywhere, so it's always useful, JordiGH.
13:09:31 <t7> nerd alert
13:09:36 <isd> Certainly not the place to start if your interest is learning the language.
13:10:27 <JordiGH> It always seemed pretty foreign to me, to be honest. My biggest interest in category theory is in homological algebra, but that's utterly irrelevant for Haskell, I think.
13:10:40 <JordiGH> Or are there some interesting chain complexes somewhere around here?
13:10:51 <Athas> JordiGH: not if you create some incomprehensible language with homological algebra as its unifying theory!
13:10:55 <t7> haskell is just function application and pattern matching... 
13:11:01 <Athas> s/language/library
13:12:03 <JordiGH> Haha: https://hackage.haskell.org/package/Homology
13:12:17 <JordiGH> I guess someone does care about this crap, but not for Haskell itself.
13:12:24 <gillesmajor>  
13:13:40 <Squarism> ideally you need a PhD in maths and computerscience to persue haskell. If you want to write pure fibonacci evaluators
13:15:00 <JordiGH> That's so weird, that dude's research interests are in optimisation and computer vision.
13:15:13 <t7> after you write your first monad blog post, you are well on your way 
13:15:14 <JordiGH> I guess he wrote a homology package for Haskell just for the lols.
13:15:16 <Athas> Maybe chain complexes are just a hobby?
13:15:43 <JordiGH> I prefer knitting, myself.
13:16:09 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.188.72.118.25
13:17:11 <Fuco> gods JordiGH stop with the haskell trolling already :)
13:17:29 <JordiGH> Fuco: HN started it!
13:18:06 <Fuco> turns out my -threaded binary is twice as slow... paralellism is insane in lazy languages :/
13:18:36 <Tuplanolla> I see `brick` doesn't offer layout managers like Swing for Java. Is there a textual user interface library that does?
13:18:36 <geekosaur> JordiGH, so you're into tying the knot?
13:18:44 <Athas> Haskell makes parallelism correct, but not fast.
13:19:15 <Fuco> I'll just wait 20 years till SPJ makes it fast enough :P
13:19:59 <DemiMarie> Fuco: You will probably be waiting until RAM is much faster than it is now
13:20:05 <DemiMarie> which could be a long time
13:20:09 <JordiGH> geekosaur: Dear lord, no. If I have a big knot in my yarn, that's sadness.
13:20:20 <geekosaur> try crochet instead :p
13:20:29 <Athas> RAM is only getting slower.
13:20:35 <DemiMarie> Athas: yup
13:21:00 <DemiMarie> Athas: That's why parallelism requires excellent use of caches to be profitable
13:21:13 <DemiMarie> Otherwise you hit the memory bandwidth wall
13:21:14 <Athas> And Haskell doesn't really have a good locality story, or even that good data-parallel facilities.  Although libraries can paper it over, hopefully.
13:21:44 <DemiMarie> Athas: Agreed.  From what I can tell the best choice is to use Data.Array.Accelerate
13:21:50 <Fuco> all I'm doing now is downloading 5 websites in parallel and parsing the HTML to extract some part
13:21:56 <Fuco> which basically is completely independent
13:22:10 <Athas> Accelerate is decent, but it's not very expressive, and the ergonomics (type errors, conceptual simplicity, etc) are quite bad.
13:22:31 <DemiMarie> Fuco: Ah, that sounds like a different problem.  That seems I/O bound
13:22:33 <Athas> Fuco: oh, that kind of stuff is what Haskell is going to be excellent at.  Haskell is the best language for managing IO and concurrency that I know of!
13:22:54 <Fuco> then I must be doing something wrong :D
13:22:56 <Psychiatrist> Hey guys. Could someone explain why deleteBy doesn't iterate over the whole list and delete all matching element but stops immediately after the first match?
13:23:08 <Fuco> I'll try to come up with some minimal working example and post it
13:23:23 <Tuplanolla> Because that's what it's supposed to do, Psychiatrist?
13:23:30 <Athas> Psychiatrist: you want filter.
13:23:31 <Sornaensis> Psychiatrist: «filter»
13:24:00 <Psychiatrist> ugh
13:24:02 <Psychiatrist> indeed
13:24:07 <Psychiatrist> Thanks!
13:24:16 <Fuco> being the heretic I am I rewrote it in php-react and it is about 3 times as fast as single-threaded... (I only have two cores)
13:24:25 <Fuco> so it's very likely I'm doing something silly in haskell
13:25:01 <Athas> Fuco: are you using the String type?
13:25:32 <Fuco> I'm using Text.HTML.TagSoup which uses bytestrings
13:26:56 <bgamari> Fuco, you may want to have a look at my html-parser package
13:27:07 <bgamari> Fuco, assuming you are parsing HTML5
13:27:30 <bgamari> apparently I don't know the name of my own package: https://hackage.haskell.org/package/html-parse
13:28:56 <lpaste> Fuco pasted “parallel download” at http://lpaste.net/350827
13:29:16 <Fuco> the problem is with strictness I think
13:30:05 <Fuco> oh... in my paste replace mapM with mapConcurrently :)
13:30:14 <Fuco> from import Control.Concurrent.Async
13:30:34 <DemiMarie> Athas: I think that F# is better in the locality department, and Rust might be even better
13:31:09 <lpaste> Fuco revised “parallel download”: “parallel download” at http://lpaste.net/350827
13:31:27 <geekosaur> compact regions supposed to help with locality iirc?
13:31:46 <DemiMarie> Athas: in general, numerical code is usually a bunch of tight loops over arrays
13:32:12 <Athas> DemiMarie: I know, that's what I do with my life.
13:32:18 <DemiMarie> Athas: ah
13:32:26 <Athas> I think functional (array) programming is a really promising avenue of attack.
13:32:33 <DemiMarie> DPH?
13:32:43 <Athas> For example, yes, although DPH specifically is dead.
13:32:44 <Fuco> I was considering go but I'm trying to write as much in haskell as possible... even when it is downright insane idea :D
13:32:44 <ski> Data-Parallel Haskell
13:33:34 <Athas> geekosaur: compacting GCs are a good idea for normal code, but for actual high-performance computation, anything like that will kill you.
13:33:34 <DemiMarie> Fuco: GHC does IO asynchronously so even without -threaded you will still be making the web requests in parallel
13:33:48 <Athas> Fine-grained memory management is a terrible idea at that level of performance.
13:33:49 <Fuco> bgamari: that looks slick, I might try to switch over :)
13:34:08 <DemiMarie> Athas: What is a GOOD idea at that level of performance?
13:34:29 <DemiMarie> Other than just making a bunch of calls to highly tuned libraries that someone has already written
13:34:34 <Athas> DemiMarie: bulk allocation in advance, deallocation when you're done.
13:34:37 <Fuco> DemiMarie: right, but then the parsing would be the bottleneck... which is what I think I'm seeing because after a second or two it just starts printing the URLs one by one instead of all at once (which you would expect if they evaluated all in parallel)
13:34:50 <Athas> No allocation inside the inner loops.
13:35:01 <Athas> And no traversing object graphs for doing bookkeeping or whatnot.
13:35:19 <Athas> But yeah, get someone else (or a compiler) to do that for you...
13:36:01 <Athas> DPH got it right, as it focused on big arrays that were treated as atomic units by the GC, and typically didn't contain their own points.  That gives you a pretty small GC graph.
13:36:19 <DemiMarie> Athas: What killed DPH?
13:36:34 <Athas> Nested parallelism is bloody hard in languages built for it, and Haskell is pretty big.  DPH was probably too ambituous for the time/funding they had.
13:36:35 <DemiMarie> Fuco: How big are the web pages?
13:36:41 <Fuco> JordiGH: by the way, we use some haskell at work and my collegue who barely finished high school works with it quite effortlessly... all we do is pure ADT in, ADT out... which is where haskell excells and is super bug-safe
13:37:03 <JordiGH> Fuco: Great, HN is wrong! I knew it!
13:37:04 <Athas> I think DPH is still in GHC, but nobody's maintaining it.  I don't think it has worked in years.
13:37:05 <Fuco> DemiMarie: varying, <4 megs usually
13:37:44 <DemiMarie> Fuco: Sounds like either 1) something is downloading stuff it shouldn't (<script>, <image>, etc)
13:37:57 <DemiMarie> or 2) switching to html-parse would fix the problem
13:38:04 <dolio> I don't see what that has to do with the quote.
13:38:05 <Fuco> I'll do that, thanks for the tips
13:38:06 <Athas> Fuco: you are passing unevaluated thunks back to the main thread, aren't you?
13:38:25 <DemiMarie> Fuco: Athas is probably right
13:38:28 <Athas> Everything after simpleHttp looks like it will be lazily evaluated by the print in the main thread.
13:38:31 <dolio> The alleged hacker news statement was that category theory is useful for understanding Haskell, not that you cannot understand Haskell without knowing category theory.
13:39:05 <Fuco> I tried placing deepseq at various places but it didn't help much 
13:39:15 <Athas> Did you place it at the right places?  It can be subtle.
13:39:20 <Fuco> right
13:39:25 <Athas> It doesn't help if you just pass back a thunk containing deepseq calls.
13:39:28 <DemiMarie> Try using -XStrict
13:39:36 <Fuco> I'll play more with it
13:39:41 <Athas> You are now discovering why Haskell is the only parallel lazy language!
13:40:12 <shapr> Athas: it's hard to contain that much fun
13:40:25 <DemiMarie> Fuco: -XStrict is a sledgehammer (it makes everything in that module strict)
13:40:28 <Fuco> right, so if I place it after the head in the fist map for example... that won't do anything because it will be wrapped in the thunk, correct?
13:40:28 <shapr> We put the Funk in Funktionell
13:40:42 <Athas> Fuco: yes, place it outside the return.
13:40:48 <carter> Also making nested parallel computation automatic is tricky
13:40:48 <EvanR> Funk Chanel
13:40:58 <shapr> EvanR: I like it
13:41:13 <Athas> let res = map (S.replace "embed/" "watch?v=") youtubeUrls in deepseq res (return res)
13:41:14 <shapr> EvanR: that's the name of the official #haskell cologne/parfum
13:41:16 <carter> I kinda favor other approaches that are more reason-able
13:41:18 <Fuco> outside the return, so like: return $! map ... ?
13:41:28 <Fuco> (except with $! replaced by deepseq I guess)
13:41:31 <Athas> Fuco: what I wrote up there, kind of.
13:41:46 <Fuco> I see
13:41:49 <DemiMarie> carter: Can you explain?
13:42:26 <Athas> Fuco: usually, I'd expect there to me a strict version of mapConcurrently.
13:42:59 <carter> DemiMarie: automatic stuff isn't very customizable. 
13:43:13 <carter> Also kinda only supported dense arrays
13:43:33 <Fuco> seems to be working, but still only one core is at 100% and the time didn't go down much
13:43:42 <Fuco> but at least the stuff is delivered at once :P
13:44:05 <Fuco> well I have to go, but thanks for all the tips.  I'll be back tomorrow :)
13:44:18 <Athas> Fuco: are you passing the +RTS options necessary for multithreaded execution?
13:44:28 <Athas> It used to be that the GHC runtime would only use one thread unless you asked it nicely.
13:44:33 <Fuco> -N2, but only to the ghc... do I need to pass that to executable too?
13:44:38 <geekosaur> yes
13:44:42 <Fuco> baah
13:44:46 <geekosaur> unless you mean -with-rtsopts
13:45:13 <Fuco> jolly, now it works like magic!
13:45:23 <DemiMarie> carter: That makes sense – most of what you do on dense arrays is linear algebra which is best done by dedicated libraries
13:45:32 <Athas> Fuco: congratulations on your new parallel Haskell scars!  Wear them with pride.
13:45:41 <Fuco> 153%CPU :D finally some effort
13:45:53 <DemiMarie> Fuco: I guess the rest is I/O
13:45:57 <Fuco> yea
13:46:15 <carter> DemiMarie: I should get the Hblas master ready for release
13:46:17 <geekosaur> (you may want `-with-rtsopts -N` to tell it to set the default rtsopts to use all available capabilities)
13:46:45 <Fuco> thumbs up to everyone! (and free beer if you ever come to my pub :D)
13:46:56 <carter> I have some neat sparse stuff that I think should play nice with nested array computation , but still needs more work
13:46:56 <maerwald> your pub? :o
13:47:05 <carter> Fuco you have a pub?!
13:47:10 <DemiMarie> carter: I'm curious!
13:47:12 <maerwald> a haskell pub?!
13:47:28 <Fuco> I'm following JWZ's path :D
13:47:44 <Athas> Anyone here going to the Lambda Days conference in Poland?
13:47:49 <Fuco> not a haskell pub... only when there are some haskell people :)
13:48:14 * ski . o O ( "Rain Funk" by JCH/Vibrants in 1989 at <http://hvsc.etv.cx/?info=please&path=C64Music/MUSICIANS/J/JCH/Rain_Funk.sid> )
13:48:20 <shapr> Fuco: srsly? where is this?
13:48:28 <Fuco> czech republic
13:48:32 <shapr> Fuco: Tell me you called it the RNA Lounge?
13:48:42 <Fuco> haha no :) that would be too bold
13:48:47 <shapr> but so very funny
13:48:50 <carter> DemiMarie:  google numerical haskell and or hblas for the sparse friendly WIP and the blas binding
13:48:50 <Fuco> true
13:48:53 <carter> latter is on hackage already
13:49:16 <DemiMarie> carter: Are you wellposed on GitHub?
13:49:23 <carter> and cartazio
13:49:23 <Fuco> so next I'll buy a dance place, call it DNA Lounge...
13:49:24 <carter> both
13:49:33 <carter> wellposed is where i put my neat applied math tooling stuff
13:49:34 <carter> :)
13:49:36 <carter> but yeah
13:50:09 <Fuco> good night o/
13:50:19 <DemiMarie> carter: I just noticed that the last commit is from July
13:50:24 <DemiMarie> is the project dead?
13:50:24 <carter> DemiMarie:  for which
13:50:28 <carter> hblas or numerical?
13:50:33 <DemiMarie> wellposed/numerical
13:50:36 <carter> DemiMarie:  i have a day job
13:50:40 <carter> and more than one repo i work on
13:50:43 <DemiMarie> carter: got it
13:50:52 <carter> look at how much other stuff i poke at
13:51:01 <carter> cartazio is main stuff in general
13:51:08 <carter> plus oss hs stuff thats community hosted
13:51:11 <carter> plus work stuff
13:51:14 <carter> plus other stuff
13:51:21 <seagreen> Is there a These but but three values instead of two?
13:51:28 <carter> seagreen:  write it
13:51:38 <DemiMarie> carter: Sorry, I didn't mean to imply anything
13:52:23 <carter> The core design done. Just lots of skeleton to skin.
13:52:45 <carter> G2G
13:52:59 * shapr waves to Fuco 
13:53:04 <DemiMarie> carter: Bye!
13:53:22 <shapr> seagreen: ?
13:54:14 <seagreen> shapr: Data.These.These is from the `these` package, it's like an Either except in addition to allowing one or the other it can also allow both values to exist.
13:55:26 <shapr> oh interesting
13:55:32 <seagreen> carter: Well I'd rather not duplicate it if it exists. And if it doesn't I'm actually not sure the best way to write it, `these` uses a sum types, but for three values you'd have 7 constructors to your sum type, which is right at the edge of being totally unwieldy.
13:58:19 <carter> Subsets :)
14:02:35 <EvanR> wasnt there a subsequences "built in" list function
14:09:45 <kadoban> filterM (const [True, False]) ?
14:13:42 <ij> Does (:: Parser a) *> (:: Parser b) will parse concatenations of sentence of a and of b or can it the b be within a?
14:14:42 <nitrix> kadoban: Did you come up with it on top of your head?
14:14:58 <nitrix> kadoban: That's such a cleaver way to do it. The list monad seems to be my weakness :(
14:15:19 <ski> ij : the former
14:15:34 <jonascj> Hi all. I'm fiddling with cabal-install, sandboxes and xmonad. I've initiated a sandbox inside my working copy xmonad git repo. Inside the sandbox dir I issued "cabal install --only-dependencies" and it installed x11-1.7. 
14:15:59 <ij> ski, i see
14:16:00 <kadoban> nitrix: Well, largely from memory. I think it was in NICTA, I remember it taking me *quite* a while the first time.
14:16:12 <jonascj> Now I'm wondring why there is also some x11-1.7 stuff in ~/.cabal. I thought it would only be in the sandbox dir
14:16:54 <nitrix> > do { p <- [True, False]; x <- [1,2,3]; return (p, x) }
14:16:56 <lambdabot>  [(True,1),(True,2),(True,3),(False,1),(False,2),(False,3)]
14:17:31 <ij> kadoban, What's nicta?
14:17:38 <ski> @where NICTA
14:17:38 <lambdabot> https://github.com/nicta/course
14:17:48 <nitrix> That's fascinating, then it seems it removes the eleemnts when they're False.
14:17:50 <kadoban> That ^   It's quite cool if you've never seen a lot of that stuff
14:18:57 <ski> > mapM (\x -> "tf") "012"
14:18:59 <lambdabot>  ["ttt","ttf","tft","tff","ftt","ftf","fft","fff"]
14:19:29 <sm> jonascj: I would think so too. Maybe you ran it outside the sandbox too ?
14:20:00 <ski> nitrix : time to learn Prolog ?
14:20:04 <nitrix> > filterM (const [True]) [1,2,3]
14:20:06 <lambdabot>  [[1,2,3]]
14:20:08 <nitrix> > filterM (const [True, True]) [1,2,3]
14:20:10 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
14:20:25 <nitrix> I'm not sure I understand the [True, True] case. There are 8 elements?
14:20:54 <Tuplanolla> > 2 ^ 3
14:20:56 <lambdabot>  8
14:21:01 <ski> yes, `2^3', each char gets assigned either `True' or `True'
14:21:11 <ski> (s/char/number/)
14:22:10 <ski> (in both cases, the element is kept, and there's eight possibilities in total)
14:22:43 <nitrix> Shouldn't that give 6 pairings?
14:22:57 <jonascj> sm: I don't think so, but then again, what defines if I'm in the sandbox or not? Do I just need to have working dir in the sandbox when issuing the "cabal install --only-dependencies" (i.e. cd into the dir which contain .cabal-sandbox) ?
14:23:15 <sm> jonascj: yes that's it
14:23:24 <ski> `1' is either kept, or kept. then `2' is either kept or kept. then `3' is either kept or kept
14:23:32 <ski>   2 * 2 * 2 = 8
14:23:58 <nitrix> Oh.
14:24:02 <jonascj> sm: there is no additional "cabal sandbox activate" or similar? just reside in the sandbox dir?
14:24:05 <jonascj> alright
14:24:23 <sm> yup. Compare the file dates I guess, and see if you can reproduce it
14:25:19 <jonascj> if I want to undo everything I've done I just delete ".cabal" and the sandbox dirs?
14:30:07 <nitrix> sm: So it's doing a product of all permutations of the first list with all the permutations of the other list, and doing a zipWith (\x _ -> x) ?
14:30:20 <nitrix> ski: ^ *
14:31:07 <nitrix> Err, more like a filterZipWith ._.
14:32:47 <ski> nitrix : not permutations (there'd be six of them, then)
14:33:30 <nitrix> filterM (const [True, True, False]) [1,2]
14:33:39 <nitrix> What are the pairings obtained?
14:33:47 <nitrix> (Before them being filtered)
14:35:04 <ski> `1' is assigned one of `True',`True',`False'
14:35:06 <ski> `2' is assigned one of `True',`True',`False'
14:35:31 <nitrix> Oh.
14:35:56 <ski> so, three choices/alternatives for the first part, and three for the second part. since these are independent choices, multiplication principle tells us there's nine possibilities in total
14:36:41 <nitrix> That'd be my mistake. I was thinking [(1,True), (1, True), (1, False), (2, True), (2, True), (2, False)]
14:36:52 <Zemyla> Man, it's really interesting that call/cc implies the law of the excluded middle.
14:37:45 <ski> itym "Peirce's law"
14:37:57 <DemiMarie> Zemyla: Yup.  That's why Idris can't ever get it (Idris dysproves the excluded middle)
14:38:31 <ski> DemiMarie : proves its negation, or just doesn't prove it ?
14:38:33 <dolio> It's not very surprising if you consider how close Peirce's law looks to double negation elimination.
14:38:44 <DemiMarie> ski: Proves its negation
14:38:49 <ski> (its universally quantified negation, obviously)
14:38:50 <EvanR> ski: if you assume LEM... you can get Void
14:39:08 <ski> DemiMarie : that's interesting. which anti-classical principle(s) allows it to do that ?
14:39:12 <EvanR> because of type ctor injectivity
14:39:21 <EvanR> and impredicativity
14:39:27 <Zemyla> @newtype CallCC = CallCC (forall a b. ((a -> b) -> a) -> a)
14:39:28 <lambdabot> Unknown command, try @list
14:39:29 <EvanR> GHC has had issues with that
14:39:35 <ski> oh, type ctor injectivity :(
14:39:40 <dolio> It has type constructor injectivity and impredicativity?
14:39:47 <dolio> I thought those two were inconsistent together.
14:39:53 <EvanR> indeed
14:40:08 <EvanR> so you have not LEM
14:40:11 <Zemyla> @let newtype CallCC = CallCC (forall a b. ((a -> b) -> a) -> a)
14:40:13 <lambdabot>  Defined.
14:40:22 <dolio> Well, you have everything.
14:40:30 <ski> Zemyla : if you want to play with it, you can use SML/NJ ..
14:40:34 <EvanR> then maybe im not characterizing the problem right
14:40:41 <ski> it's easy to implement
14:40:53 <ski>   val excludedMiddle :: unit -> ('a cont,'a) either
14:41:05 <ski> (er, s/::/:/, of course)
14:41:15 <Zemyla> :t \(CallCC cc) -> cc $ \v -> Left $ \a -> v (Right a)
14:41:17 <lambdabot> CallCC -> Either (b1 -> b) b1
14:41:58 <dolio> EvanR: I'm saying just injectivity and impredicativity are inconsistent. No need for LEM.
14:42:10 <dolio> As I recall.
14:42:18 <nitrix> ski: So it's more akind to do { x <- [True, True, False]; y <- [True, True, False]; return (x, y) }, if that tuple was a mask going to be applied to filter elements.
14:42:32 <ski> nitrix : yep
14:42:33 <EvanR> if you write some code that uses those to cause havoc ill try and put it into idris
14:42:38 <DemiMarie> ski: The reason that Idris is anticlassical is because it is not meant as a proof assistent, but as a programming language
14:42:47 <dolio> EvanR: I can find an old agda thread, probably.
14:42:57 <DemiMarie> and excluded middle is not very helpful in proving the correctness of programs
14:43:05 <EvanR> i beg to differ
14:43:15 <DemiMarie> EvanR: Explain?
14:43:34 <ski> DemiMarie : i was wondering if they maybe had put something like Church's thesis or (perhaps more probable ?) bar recursion (or a related continuity principle) in it ..
14:43:36 <EvanR> LEM can simplify a proof that does have a constructive proof
14:43:56 <EvanR> a proof of a theorem that
14:44:20 <EvanR> and since many proofs dont exist any runtime anyway, it doesnt matter that its got no computation
14:44:21 <dolio> EvanR: http://okmij.org/ftp/Haskell/impredicativity-bites.html
14:44:53 <DemiMarie> EvanR: Injectivity of type constructors also makes coding easier though
14:44:55 <EvanR> i saw that... ill see if i can make idris barf
14:45:01 <absence> http://lpaste.net/4042914503124320256 <- can this structure be generalised? it's kinda like a monad in that the parameters for the state computations aren't dictated by the structure, and kinda applicative in that there's one state computation for each record field, but the pieces don't really fit
14:45:06 <ski> EvanR : iiuc, Idris doesn't prove `forall a. Not (Either a (Not a))', but rather `Not (forall a. Either a (Not a))'
14:45:32 <EvanR> the first one wouldnt make sense
14:45:38 <ski> oh, also "type case analysis" ..
14:46:03 <EvanR> you dont have type case analysis in idris
14:46:08 <Zemyla> Does LEM imply Peirce's Law?
14:46:15 <ski> Zemyla : iirc, yes
14:47:04 <ski> EvanR : then i'm not seeing the relevance of your "LEM can simplify a proof of a theorem that does have a constructive proof" here ?
14:47:16 <EvanR> i was responding to DemiMarie 
14:47:29 <dolio> EvanR: http://coq-club.inria.narkive.com/iDuSeltD/agda-with-the-excluded-middle-is-inconsistent
14:47:32 <EvanR> LEM can be used as a shortcut to prove stuff
14:47:58 <dolio> There's a Coq proof in there using impredicativity.
14:48:10 <EvanR> this proof was translated into idris
14:48:29 <EvanR> hmm... but it only went as far as showing not LEM
14:48:41 <dolio> EvanR: Yeah, look at roconnor's one, I think.
14:48:56 <Zemyla> Well, the callCC form of LEM doesn't seem to work immediately.
14:49:10 <dolio> Geeze, this was 7 years ago?
14:50:02 <ij> Could I do "foo \" bar" with Text.Megaparsec.Combinator.between and something inside the between?
14:50:33 <Zemyla> It returns Not a at first, and if you manage to produce an a, and pass it to Not a in hopes of producing a Void, then instead time rewinds and you always had an 'a' the whole time.
14:51:08 <DemiMarie> https://groups.google.com/forum/#!topic/idris-lang/wpUsCbyJOck
14:52:03 <EvanR> that proof uses LEM as a hypothesis to get Void
14:52:17 <EvanR> so we typically blame the hypothesis not the system 
14:52:30 <DemiMarie> EvanR: Agreed
14:52:33 <nitrix> I have no knowledge of the subject, but I'm curious. What's Not and how would it be defined in Haskell?
14:52:46 <ski>   type Not a = a -> Void
14:52:53 <nitrix> Ah, gotcha.
14:52:58 <ski>   data Void where
14:53:10 <DemiMarie> (that is, no constructors)
14:53:42 <nitrix> The dual of absurd :P
14:53:45 <ski> @djinn Not (Either a b) -> (Not a,Not b)
14:53:45 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
14:53:46 * nitrix chuckles
14:53:56 <DemiMarie> @list
14:53:56 <lambdabot> What module?  Try @listmodules for some ideas.
14:54:01 <DemiMarie> @listmodules
14:54:01 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
14:54:01 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
14:54:07 <ski> @help djinn
14:54:07 <lambdabot> djinn <type>.
14:54:08 <lambdabot> Generates Haskell code from a type.
14:54:08 <lambdabot> https://github.com/augustss/djinn
14:54:35 <ski> @list djinn
14:54:35 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
14:54:42 <ij> Oh, would this work? `between symbol symbol many (notChar "\" <|> (char "\" *> anyChar))`
14:54:47 <ski> @djinn Either (Not a) b -> (a -> b)
14:54:48 <lambdabot> f a b =
14:54:48 <lambdabot>     case a of
14:54:48 <lambdabot>     Left c -> void (c b)
14:54:48 <lambdabot>     Right d -> d
14:54:48 <Zemyla> @djinn Not (a, b) -> Either (Not a) (Not b)
14:54:48 <lambdabot> -- f cannot be realized.
14:55:04 <nitrix> void (c b) -- ?
14:55:10 <ski>   void :: Void -> a
14:55:15 <ski> cf.
14:55:20 <nitrix> Oh, so `absurd`.
14:55:21 <ski> @type either
14:55:22 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:55:52 <Zemyla> It's the principle of explosion in handy function form.
14:56:01 <ski> @djinn-add type NotNot a = Not (Not a)
14:56:04 <ski> `NotNot' is a monad
14:56:28 <ski> @djinn a -> NotNot a
14:56:28 <lambdabot> f a b = b a
14:56:34 <ski> @djinn NotNot a -> (a -> NotNot b) -> NotNot b
14:56:35 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
14:56:50 <DemiMarie> nitrix: @djinn NotNot a -> a
14:56:55 <ski> (the `void's there are actually not necessary)
14:56:58 <dolio> EvanR, DemiMarie: https://lists.chalmers.se/pipermail/agda/2010/001543.html
14:56:59 <DemiMarie> @djinn NotNot a -> a
14:56:59 <lambdabot> -- f cannot be realized.
14:57:03 <dolio> There's another example.
14:57:05 <ski> (djinn is just a bit trigger-happy with `void', it seems)
14:57:14 <dolio> Without LEM. Just impredicative Prop.
14:57:16 <ski> @djinn Not (Not (Not a)) -> Not a
14:57:16 <lambdabot> f a b = void (a (\ c -> c b))
14:57:17 <Zemyla> @djinn Not (Not (Not a)) -> Not a
14:57:17 <lambdabot> f a b = void (a (\ c -> c b))
14:57:21 * ski smiles
14:57:32 <DemiMarie> @djinn Not (Not a) -> a
14:57:32 <lambdabot> -- f cannot be realized.
14:57:39 <dolio> Probably about the same as the one on coq-club.
14:57:58 <ski> djinn also doesn't handle higher-rank
14:57:58 * nitrix is entertained. Thanks.
14:57:59 <Tuplanolla> Which array package should I use if I want to perform lots of cropping and indexing?
14:58:18 <DemiMarie> Tuplanolla: What is the application?  How important is performance?
14:58:23 <ski> (and also not polymorphic class methods, as a consequence of that)
14:58:33 <Tuplanolla> Not that important, DemiMarie. I just want convenience.
14:58:35 <kadoban> Tuplanolla: Immutable or mutable?
14:58:57 <kadoban> I think vector and array both allow slicing and indexing with good perf
14:59:02 <Tuplanolla> Immutable or bulk mutable, kadoban.
14:59:34 <Tuplanolla> I can't find high-dimensional cropping functions for any of them.
14:59:37 <ski> @where djinn
14:59:37 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
15:00:01 <EvanR> dolio: ok. idris doesnt have impredicative Prop either
15:00:03 <Zemyla> How does Coq handle recursion if fix is inconsistent?
15:00:24 <dolio> What does it have that's impredicative?
15:00:24 <Tuplanolla> It tracks "decreasing" parameters, Zemyla.
15:00:44 <kadoban> Hmm, I don't see the function I thought existed in 'array'
15:01:05 <Tuplanolla> That's possible since all data types are inductive, so the compiler knows how to work towards the base case, Zemyla.
15:01:08 <EvanR> dolio: in the both proofs theres this thing  data I : (Set -> Set) -> Set where, "I has a size problem"
15:01:30 <Tuplanolla> It's not in Repa either, kadoban.
15:01:50 <kadoban> I wonder if you can do it with 'ixmap'
15:02:06 <EvanR> the universe structure of idris isnt really clear to me
15:02:19 <Tuplanolla> :t Data.Array.ixmap
15:02:20 <Nik05> thought i was in #coq for a moment
15:02:21 <EvanR> the repl doesnt help
15:02:21 <lambdabot> (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
15:03:18 <Tuplanolla> I don't see, kadoban.
15:03:20 <kadoban> Oh, yeah, right, you just give a new range and use 'id' ?
15:03:26 <kadoban> Or am I mucking that up
15:03:57 <Tuplanolla> That doesn't handle boundary conditions either.
15:04:00 <kadoban> I think 'slice' is  flip ixmap id, as long as your new range is smaller that the original?
15:04:33 <kadoban> Or a subset of anyway
15:04:42 <Tuplanolla> I'd expect to be able to specify drop, fill or wrap for the boundaries.
15:05:01 <DemiMarie> Tuplanolla: Which packages in other languages have you used?
15:05:15 <kadoban> Hmm
15:05:28 <dolio> EvanR: I would guess that idris doesn't actually have impredicativity.
15:07:14 <jonascj> sm: issuing that "cabal install --only-dependencies" inside the sandbox dir results in something going into ~/.cabal
15:09:51 <Tuplanolla> I guess I should use `array` and implement this myself. It's just strange that the interfaces are so lacking.
15:14:08 <kadoban> Does seem unfortunate. Maybe there's wrappers out there. I'm not actually sure that's going to fit what you want either, I don't know how it works exactly.
15:15:32 <Tuplanolla> I can work with `STArray`.
15:28:10 <DemiMarie> I was thinking about Haskell performance
15:29:07 <DemiMarie> It seems that Haskell has some extremely high-performance libraries (ByteString, Attoparsec, Accelerate, Warp)
15:29:16 <DemiMarie> but most code is many, many times slower
15:29:42 <kadoban> Where "many many" is like ... what 5 or less usually?
15:30:22 <c_wraith> that's true in every language. performance doesn't just happen, it takes lots of engineering work and really understanding both the problem domain and the solution domain. 
15:30:27 <pacak> DemiMarie: Those fast libraries are your building blocks. Use them and profile  your code if you think about performance.
15:33:36 <Squarism> what is the closest to List.concatMap (bind?) and Map.mapMaybeWithKey for Set
15:33:37 <Squarism> ?
15:34:05 <taktoa> oh I completely spaced out but I ended up running ghc-core-html on the code that was performing faster with `HasCallStack`s added; here's a link if anyone was interested https://ipfs.io/ipfs/QmVLJcR4WFnapWm84CHGsyPf6TdKL7Fy5U5UMLCCCV6Cjm
15:41:19 <ski> @type \f -> S.unions . S.toList . S.map f  -- Squarism ?
15:41:21 <lambdabot> Ord a => (a1 -> S.Set a) -> S.Set a1 -> S.Set a
15:41:45 <Squarism> ski, thanks. Ok.. so you need to do a bit of unboxing
15:41:59 <Squarism> .../conversion
15:52:01 <Zemyla> :t \f -> flip foldMap `asTypeOf` (>>=)
15:52:03 <lambdabot> (Monoid (m b), Foldable m, Monad m) => t -> m a -> (a -> m b) -> m b
15:52:30 <Zemyla> ski: That's probably more intuitive.
15:54:19 <eelster> Zemyla: I feel like intuition and compactness seem to go hand-in-hand a lot of the time in Haskell.
15:54:20 <Zemyla> :t \f -> foldMap :: ((Ord b) => (a -> S.Set b) -> S.Set a -> S.Set b)
15:54:22 <lambdabot> Ord b => t -> (a -> S.Set b) -> S.Set a -> S.Set b
15:55:00 <eelster> :t (>=>)
15:55:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:55:16 <Zemyla> @let newtype SetM a = SetM { runSetM :: forall r. (Ord r) => (a -> S.Set r) -> S.Set r } deriving (Functor)
15:55:18 <lambdabot>  Defined.
15:55:42 <eelster> Zemyla: can this pretty much be used as ghci?
15:57:11 <Zemyla> eelster: Yes, but anyone can @undef your definitions at any time.
15:57:35 <eelster> Zemyla: I feel like some game could be made out of this
15:59:31 <Zemyla> @let instance Applicative SetM where { pure a = SetM ($ a); SetM mf <*> SetM ma = SetM $ \c -> mf (\f -> ma (c . f)); SetM ma *> SetM mb = SetM $ \c -> ma $ const $ mb c }
15:59:32 <lambdabot>  Defined.
16:00:15 <Zemyla> @let instance Alternative SetM where { empty = SetM $ const S.empty; SetM ma <|> SetM mb = SetM $ \c -> S.union (ma c) (mb c) }
16:00:17 <lambdabot>  Defined.
16:00:57 <Zemyla> @let instance Monad SetM where { return = pure; (>>) = (*>); fail = const empty; SetM m >>= f = SetM $ \c -> m $ \a -> runSetM (f a) c }
16:00:59 <lambdabot>  Defined.
16:01:06 <Zemyla> @let instance MonadPlus SetM
16:01:08 <lambdabot>  Defined.
16:01:42 <Zemyla> @let toSetM :: S.Set a -> SetM a; toSetM s = SetM (`foldMap` s)
16:01:44 <lambdabot>  Defined.
16:02:10 <Zemyla> @let fromSetM :: Ord a => SetM a -> S.Set a; fromSetM (SetM m) = m S.singleton
16:02:12 <lambdabot>  Defined.
16:03:17 <Zemyla> @let order = toSetM . fromSetM
16:03:19 <lambdabot>  Defined.
16:03:58 <Zemyla> Now you can use SetM as a Monad, and use order whenever possible to minimize the size of the sets produced.
16:09:09 <athan> Zemyla++
16:09:29 <athan> the monotone monad? :s
16:09:38 <athan> would the behavior be zippy?
16:09:53 <Zemyla> Nope. Monads aren't zippy.
16:10:08 <Zemyla> It's basically the same as the list monad, except it prunes duplicates at some point.
16:10:48 <Zemyla> @let instance (Show a, Ord a) => Show (SetM a) where showsPrec p = showsPrec p . fromSetM
16:10:50 <lambdabot>  Defined.
16:11:59 <athan> ahh oops, that is really cool
16:12:19 <athan> Zemyla: Do you happen to have this in a lib I can use?
16:12:26 <athan> I really like this idea
16:12:58 <Zemyla> > fromSetM $ toSetM (S.fromList [1, 2, 3]) >>= (\a -> toSetM (S.fromList [a, 2 * a.. a * a]))
16:13:02 <lambdabot>  fromList [1,2,3,4,6,9]
16:13:22 <Zemyla> No I don't, and I stole it from Oleg anyway.
16:14:32 <athan> oop, right on :)
16:14:56 <athan> You could probably make it an `IsList` instance too huh
16:34:19 <wespiser> does anyone know of "wrapper induction" or similar libs in Haskell?
16:34:56 <eelster> wespiser: What do you mean by wrapper induction? 
16:35:27 <wespiser> eelster: a la Giles, 2009: https://clgiles.ist.psu.edu/pubs/CIKM2009-wrapper-induction.pdf
16:37:08 <wespiser> from my understanding, the process infers commonalities between DOM trees for more efficient feature extraction
16:37:12 <eelster> wespiser: It's possible, but I'm not sure if it exists. I feel like it would be so monadic. 
16:37:50 <wespiser> eelster: what do you mean by "so monadic" ? thnx
16:38:54 <eelster> wespiser: I mean that it would probably involve a whole lot of monads to write a lib like that because it involves a ton of scraping and interpreting if I'm reading this paper correctly and those are mostly implemented through monads in Haskell. It would be neat, but I'm not 100% sure if Haskell would be the optimal language for this. 
16:39:33 <wespiser> Haskell is pretty good with abstract operations over data structures
16:39:46 <wespiser> referential transparency makes this a lot easier
16:40:48 <eelster> wespiser: That's true with referential transparency. Unfortunately, the other side to RT is that with RT it makes operations like scavenging for data hard because they must still be done in a pure manner.
16:41:34 <wespiser> eelster: I think thats where monad transformers, extensible effects, and other approaches really shine
16:41:40 <wespiser> :t liftIO
16:41:41 <lambdabot> MonadIO m => IO a -> m a
16:41:53 <Cale> eelster: That sounds like a pure function to me...
16:42:10 <eelster> I'm not saying it's unimplementable. I'm saying it would involve a lot of Monads. 
16:42:16 <Cale> hm?
16:42:19 <Cale> Which monads?
16:42:19 <wespiser> or one, good monad!
16:42:34 <Cale> Anything which can be done with monads can be done without them.
16:42:39 <NextHendrix> a supermonad
16:42:46 <wespiser> one monad to rule them all!
16:42:56 <NextHendrix> neomonad-ng
16:42:58 <eelster> Cale: Wait really? 
16:43:02 <Cale> Monad is just an abstraction we use to avoid implementing certain functions over and over in different settings.
16:43:07 <wespiser> eelster: I really don't see monads as a problem at all here
16:43:30 <wespiser> eelster: In fact, I would rather organize a project with monads for many different effects, then alternatively use object orientation
16:43:32 <eelster> I might also be entirely misinterpreting this concept. 
16:43:52 <eelster> wespiser: That's quite fair and probably is a good argument to be honest. 
16:44:05 <wespiser> eelster: it took me a long time to understand this
16:44:22 <eelster> wespiser: I'm, if you can't tell, not an expert in haskell
16:45:42 <wespiser> eelster: no problem! Control.Monad.RWS combines nearly all the effects we would be using in object oriented programming into a singular monad
16:46:14 <eelster> wespiser: I now know what I'm going to spend my free time reading about. This seems enthralling. Haskell is by far the most fun language to read about.
16:46:34 <Cale> eelster: Also, the problem we're describing here is fundamentally a pure function, and the paper obscures this somewhat by giving algorithms which perform destructive mutations of trees for no apparent fundamental reason.
16:46:53 <Cale> You could just as well compute the same trees in a way which didn't involve destructively mutating others.
16:47:17 <eelster> Cale: The destructive mutation was what concerned me as well. I'm happy to hear that it is unneccesary though
16:54:14 <wespiser> destructive mutation would have to be written out of the algorithmic specs
16:57:38 <EvanR> nice, where you would use Rational you could use Fixed if you only evaluate polynomial functions
16:58:12 <EvanR> if the argument were representable by a fixed
17:19:55 <NalanAmram> Hi all
17:20:02 <eelster> NalanAmram: Howdy
17:21:34 <NalanAmram> Do you happen to know if there's a good type for accumulating morphisms?
17:22:26 <NalanAmram> nvm my question makes no sense right now
17:25:50 <DemiMarie> Does anyone wish that String was not the same as [Char]?
17:26:04 <suzu> yes
17:26:05 <athan> DemiMarie: What would you rather want?
17:26:06 <suzu> all the time
17:26:18 <DemiMarie> athan: Text
17:26:26 <DemiMarie> or something like it
17:26:29 <athan> Check out monoid subclasses :v
17:26:39 <athan> @hackage monoid-subclasses iirc
17:26:40 <lambdabot> http://hackage.haskell.org/package/monoid-subclasses iirc
17:26:55 <DemiMarie> The reason is simple: performance
17:27:06 <yushyin> I just use Text if I want Text
17:27:21 <DemiMarie> yushyin: Does String have any advantages?
17:27:52 <athan> Lists are just convenient to work with, but iirc String is pretty ratchet in terms of performance.
17:28:04 <athan> especially for stuff like `isInfixOf`
17:28:11 <eelster> Isn't String just a synonym for [Char] or am I missing something?
17:28:18 <athan> you are correct eelster 
17:28:18 <dfeuer> Yup.
17:29:24 <Philippa> DemiMarie: it's partly historical accident, partly [Char] having overt recursive structure you can pattern-match on. The latter's good for teaching, which was also a major concern when Haskell was first designed
17:29:39 <Philippa> Text and even ByteString were late additions
17:29:48 <eelster> Is there a way to get haskell to deal with c-style strings? As in could ['H','e','l','l','o','\0'] somehow be "Hello" instead of "Hello\NUL"?
17:31:49 <Philippa> I'm not quite sure why you'd want that?
17:32:14 <eelster> Philippa: It was more a question of interest than a question of actual need. I was just trying to mess around with Haskell
17:32:21 <c_wraith> If you're doing FFI stuff, there are functions for handling C strings
17:32:43 <c_wraith> If not..  Eh, it doesn't help with anything.
17:33:11 <Philippa> yeah. So: you can work with actual C-style strings, you can write functions that implement C-style strings in Haskell arrays... it's just not worth it. For FFI purposes, 99% of the time you want to either get stuff out of that format ASAP or not manipulate it directly
17:33:46 <Philippa> (because away from C it's one of the worst string representations possible - though admittedly Haskell's [Char] is another candidate)
17:34:08 <Philippa> (if you represent strict lists as ropes, OTOH, that's a good representation)
17:34:14 <eelster> c_wraith: I'm not doing FFI. The one idea I had was to possibly use "\0" in some recursive algoritm I had to see if haskell would instantly stop iteration with type String if '\0' was the end but that didn't work
17:34:25 <eelster> It was just an experiment, but thanks for the FFI info!
17:34:40 <Philippa> it's just another character to Haskell
17:34:49 <eelster> Probably for the best
17:35:00 <Philippa> the list/string functions work on list structure, mostly they ignore what's inside unless you gave them the tools to do something with it
17:35:14 <Philippa> (when you call map, you're telling it how to manipulate the items: it doesn't know how on its own)
17:35:35 <Philippa> back to bed for me, anyway
17:35:37 <eelster> Philippa: Certainly. Now that I thnk about it; it would be a lot more problematic the other way around
17:36:15 <c_wraith> eelster: one of the nice things about haskell is that you can tell from the type several things a function can't do
17:36:21 <c_wraith> :t map
17:36:23 <lambdabot> (a -> b) -> [a] -> [b]
17:36:47 <c_wraith> eelster: for instance, map is polymorphic in the types a and b
17:36:49 <eelster> c_wraith: Oh certainly. GHCi is a very helpful tool
17:36:58 <eelster> (Especially with :t and :i)
17:37:11 <c_wraith> eelster: that means that its behavior *cannot* vary depending on the exact types.
17:37:33 <c_wraith> eelster: and that also means it can't vary depending on the specific values present.
17:37:37 <eelster> c_wraith: I think that's probably been one of the bigger challenges I've had in haskell.
17:38:01 <c_wraith> eelster: it's really nice to have that as a guarantee, though.
17:38:08 <eelster> c_wraith: I think it's brillian
17:38:16 <eelster> I am frustrated I didn't learn it early. 
17:38:39 <c_wraith> I'm not sure you can learn it early.  It seems like it depends on getting some experience with the system first.
17:38:51 <eelster> Learning Java threw me off because of it's overriding. Ruby actually helped me prep for Haskell pretty well.
17:39:13 <eelster> c_wraith: Certainly, I just regret having learnt java before. I love Ruby and think that it was a great first language. 
17:39:15 <Rotaerk> java's concept of "types" in general is different
17:39:29 <eelster> Java's polymorphism is very messy
17:39:57 <eelster> Ruby's idea of modules, while not that close to Haskell's classes, helped me better understand classes in Haskell.
17:39:59 <Schoolmeisterr> how's java's polymorphism messy? Serious question
17:40:19 <c_wraith> just like it's so hard to just explain what the Monad class is all about. It's simultaneously very simple, and yet more abstract than people tend to be able to handle until they get some practice.
17:40:34 <Schoolmeisterr> i've got experience with java, c++ and python but I'm not sure what's wrong with Java's system
17:41:01 <c_wraith> I mostly tell people who ask about it to just table the question until they're comfortable with Haskell's type system.
17:41:02 <eelster> Schoolmeisterr: I personally have trouble understanding some things in java's polymorphism when it related to static methods
17:41:12 <ertes> helo
17:41:32 <c_wraith> ertes: EHLO ESMTP supported
17:42:09 <eelster> I find the rules related to static methods relatively arbitrary in Java
17:42:30 <Rotaerk> a type in haskell is, roughly, a collection of immutable values, but in java, C#, etc., types are definitions/patterns/templates for creating state-holding, interface-driven objects
17:42:37 <ertes> Schoolmeisterr: for one thing all type variables in java have to be concrete types
17:42:44 <eelster> I think that the classes in Haskell are brilliant. 
17:43:07 <ertes> Schoolmeisterr: that doesn't make it "messy", but impractical
17:43:10 <eelster> Things like Eq, Ord, etc are really really cool. 
17:43:15 <Rotaerk> *some* types in C# can be immutable values, but that's a small set of them
17:43:26 <ertes> then there is the whole co-/contravariance issue with subtyping, which does make it messy
17:43:53 <eelster> On the whole, I prefer haskell's type system. Even if I don't fully understand it.
17:45:00 <Schoolmeisterr> ertes: yeah, I do agree about your last point. It's powerful but it gets messy and is especially hard when a lot of overloading etc is being done.
17:45:42 <ertes> Schoolmeisterr: powerful?  subtyping or java's polymorphism?
17:45:45 <Schoolmeisterr> I do prefer Java's way of handling multiple inheritance though
17:46:01 <eelster> Schoolmeisterr: That's true. The lack of direct multiple inheritance is logical.
17:46:48 <Rotaerk> inheritance is sugar; it's ultimately unnecessary, and you can emulate multiple inheritance through the less-sugared mechanisms
17:47:03 <Schoolmeisterr> ertes: I thought they pretty much refer to much and the same thing?
17:47:19 <ski> Rotaerk : s/types are/classes are/ ?
17:47:39 <ertes> Schoolmeisterr: ah, you mean inheritance, not parametric polymorphism…  the latter is called generics in java
17:47:54 <Rotaerk> ski, types; classes are one kind of type; there's also structs (in C#) for instance
17:48:04 <ertes> Schoolmeisterr: i don't know how powerful java's OOP is relative to OOP in general, but i should note that i consider the entirety of OOP to be an anti-pattern that does not solve an actual problem
17:48:12 <ski> a class is a type, and some more stuff
17:48:25 <eelster> Are we talking about Java right now or Haskell?
17:48:30 <ski> both ?
17:48:32 <Rotaerk> yea, classes are kind of an abomination
17:49:01 <ski> in Java, the type part of a class is known as an interface
17:49:03 <eelster> It's just confusing because class has a different meaning in Java vs. Haskell
17:49:25 <Rotaerk> well, in haskell it's really "type class" ... a class of types
17:49:30 <Rotaerk> whereas in Java it's a class of objects
17:49:41 <ertes> in fact OOP seems to be mostly busy with solving problems it has constructed by itself
17:50:07 <ski> OO in O'Caml is nicer, imho
17:50:44 <eelster> ski: OCaml is great. I was using it for a while then moved to F#.
17:50:51 <ski> there you don't need to have a class, to make objects
17:51:20 <ski> what matters is what messages your object can respond to, and what the types of the arguments and results of them are
17:51:23 <Schoolmeisterr> I always found classes (OOP in general) helpful to create an ordered, structured overview of your program. But then again, I've barely had any experience with other paradigms.
17:51:23 <Rotaerk> ertes, the specific meaning of OOP differs based on who you ask; some variants are useless, others not so much
17:51:53 <ski> so, the objecs are structurally typed, not nominally. so it's "duck typing" (but sane)
17:51:58 <eelster> If I'm going to use an OO language, I want to use something that's trully OO like Ruby.
17:52:18 <eelster> OO languages with primitives are annoying to me
17:52:19 <ertes> Rotaerk: that's true…  i'm specifically talking about encapsulation + "subclassing" + inheritance
17:52:31 <ertes> i.e. what most people would understand as OOP these days
17:52:32 <ski> eelster : "with primitives" ?
17:52:40 <eelster> ski: Like java. 
17:52:55 <ski> eelster : hm, you mean one that doesn't embrace "everything is an object" ?
17:52:57 <ertes> there is that other kind of OOP, which honestly to me sounds like more of a special case of coroutines
17:52:59 <eelster> ski: Yeah. 
17:53:09 <ertes> the way smalltalk used the term OOP, for example
17:53:10 <ski> actually, i think that's a sensible attitude
17:53:34 <ski> (it's just that the common examples of it have messed other things up)
17:53:45 <eelster> I don't really get why 'a' is not an object in Java but "a" is.
17:53:49 <ertes> in that sense you might consider haskell's concurrency a form of OOP, but that has nothing to do with the kind of OOP you do in java
17:54:03 <Rotaerk> ertes, well, encapsulation is good, you do it all the time in haskell; it's just that OOPers frequently approach it ... backwards
17:54:08 <eelster> I mean, I understand it from a techincal perspective, but it makes no sense. 
17:54:20 <Rotaerk> subclassing is fine, but has very limited utility...
17:54:35 <ski> contrary to the impression some newbies have gotten, we don't say "everything is a function" in functionall programming (unless you're doing pure lambda calculus, Church-encoding everything .. which is painful (cf. Visitor pattern in OO))
17:54:56 <Rotaerk> i.e. if you have an interface and it's implemented by class A, but you want to reimplement it to be slightly different, you inherit A and then override its implementation in a few ways
17:55:05 <eelster> ski: What is not a function in Haskell? I'm just wondering. 
17:55:07 <ertes> Rotaerk: i think subclassing is problematic, because subtyping is problematic in general
17:55:39 <ski> eelster : `True' is not a function. a list is not a function. a pair is not a function. `Nothing' is not a function. an I/O action is not a function
17:56:07 <ski> eelster : functions are just one (important) kind of values. there are many other useful kinds of values as well
17:56:32 <Rotaerk> ertes, well one of the problems is that OO programmers tend to think that their goal is to define a "class hierarchy", which is ultimately a *taxonomy* of objects ... "okay, I've got my animal class, and derived from that is mammal and fish, and from them are dog, cat, shark, and goldfish"
17:56:32 <c_wraith> eelster: only values that have (->) as their top-level type constructor are functions.
17:56:51 <Rotaerk> ertes, except taxonomy is a horrible application of subclassing...
17:56:54 <ski> "everything is an object" is about trying to shoehorn everything into being a record (of functions, or of delayed values, if you prefer)
17:57:11 <eelster> I was under the impression that everyting could theoretically be classified as a function, but most are those with no arity. 
17:57:13 <Rotaerk> a square is taxonomically a rectangle, but whether it can derive from rectangle depends on the rectangle's interface
17:57:14 <ski> it's just as silly to attempt to shoehorn everything into being a function
17:57:32 <ski> or into being an algebraic data type (or a variant/sum type, using different terminology)
17:57:53 <c_wraith> church encode all the things!
17:58:04 <ertes> Rotaerk: now take all of this to its conclusion, and you've basically reduced "classes" as they're used in java as an awkward module system and nothing more
17:58:06 <Rotaerk> anyway, the mechanisms of OO languages aren't horrible (albeit, the fact that they're native mechanisms is a bit silly, since they really shouldn't be needed that often), but they're definitely a bused
17:58:09 <ski> eelster : in Haskell, every function takes exactly one argument. consequently, there is no such thing as a function of no arguments, in Haskell
17:58:12 <ertes> Rotaerk: awkward, because it's super-noisy
17:58:26 <eelster> ski: That's true! 
17:58:38 * ski cochurch-encodes c_wraith
17:58:51 <eelster> That makes a lot of sense. I should unlearn the 0-arity notion because it doesn't work in Haskell.
18:00:04 <Rotaerk> eelster, generally your "function that takes no arguments" in java would be a *procedure*, a sequence of actions... and this can be represented as an IO x where x is the result of your action
18:00:05 <ski> eelster : anyway, my point is that the idea of using records (usually of functions) is a sometimes useful and nice approach to structuring code. functional programming people could probably learn to use more OO-idioms based on that
18:00:30 <c_wraith> ski: I've done that in production code!
18:00:41 <ertes> ski: i use that a lot actually
18:00:41 <Rotaerk> in java you learn that function == procedure, but in haskell function is just a value that varies based on an argument.  if you DONT vary based on a parameter, then you don't need a function
18:00:57 <ski> (iow, OO isn't all bad. it's just that you don't want to force it everywhere. just like you don't want to force algebraic data types everywhere ..)
18:01:07 <Rotaerk> (well, not exactly true; there are functions that take but ignore their argument...)
18:01:18 <ertes> ski: in fact we all do…  it's just that we make these record types implicit and call them "type classes", because it saves a ton of code =)
18:01:19 * ski smiles towards c_wraith,ertes
18:01:29 <c_wraith> are functions technically not algebraic?
18:01:31 <eelster> Thank you guys so much for explaning all of this. I've been reading through Haskell from First Principles, but I clearly have missed some stuff. 
18:01:36 <ski> ertes : well, that's not *quite* the same thing, now :)
18:01:51 <eelster> c_wraith: Algebraic in what sense?
18:02:13 <c_wraith> eelster: in. the sense that algebraic data types are algebraic.  :)
18:02:24 <ski> c_wraith : `\(a :: *) -> (a -> a)' certainly isn't
18:03:15 <c_wraith> eelster: which is a somewhat advanced topic that I barely have studied.
18:03:18 <c_wraith> (which is why I'm asking others about it)
18:03:19 <eelster> c_wraith: From a mathematical standpoint, there are certainly functions within algebra (in fact that's an important part of Galois theory)
18:03:19 <Rotaerk> is that legal in some extended form of haskell, ski?
18:03:30 <eelster> But I'm not sure how that actually extends to Haskell.
18:03:36 <ski> Rotaerk : i wanted to avoid saying `Endo'
18:04:02 <Rotaerk> k
18:04:12 <ertes> ski: why would that not be algebraic?
18:04:42 <ertes> ah, because it's dependent
18:05:45 <ski> eelster : yes, but the point is that in algebra, the signature for an operation typically is of the form `A_0 * ... A_{n-1} >---> X_i', `X_i' being one of the carriers, and each `A_j' (for `0 =< j < n') is either a carrier, or a "constant" set (e.g. the field in vector spaces)
18:05:56 <ski> eelster : because `a' is mentioned in the exponent
18:06:21 <ski> or even, because the exponent is not finite (if you want to be stricter)
18:06:36 <ertes> ski: was that for me?
18:06:37 <eelster> Are we referring to a specific function? I'm quite confuse. 
18:06:44 <ski> ertes : er, the last one, yes
18:06:53 <ertes> ski: i see
18:07:03 <eelster> Oh ah. 
18:07:15 <ertes> ski: i wouldn't require finiteness, would you?
18:07:19 <eelster> There exist algebraic functions, but not all functions are algebraic .
18:07:53 <ski> eelster : for each carrier `X_i', we can collect the operations together like `A_0 * ... * A_{n-1} + B_0 * ... * B_{m-1} + ... >---> X_i', so we have a sum of products in the domain
18:08:15 <eelster> ski: I understand. I was confused about the `a' part at first but then realized that wasn't related.
18:08:31 <ski> eelster : if we have repeated carriers, we could abbreviate the notation by writing `X_k ^ s', `s' being the number of repeats, &c.
18:08:40 <eelster> ski: Certainl y
18:09:06 <ski> eelster : anyway, this corresponds to defining an algebraic data type in Haskell (the data constructors corresponding to the operations)
18:09:34 <eelster> ski: The amount of modern algebra in Haskell is truly amazing to me. I absolutely love the way it is incorporate. 
18:10:59 <ski> (of course, algebraic data types doesn't have a way of expressing the laws/relations of the algebra in question (Miranda had something there, but i'm not sure how well it worked. perhaps higher inductive types will work satisfactory, ..))
18:11:46 <ski> ertes : if we just start from universal algebra, then i think they usually assume that the operations have finite arity
18:13:04 <ertes> ski: i wonder if we're talking about the same notions…  i'm thinking of types as algebraic in the sense that they form a commutative semiring w.r.t. isomorphism
18:13:30 <ertes> and that simply doesn't capture the notion of polymorphism
18:13:37 <EvanR> theyre an initial F-algebra for some F
18:13:53 <eelster> ertes: I am siding with you here. I did a lot of my work in commutative algebra.
18:13:59 <ski> eelster : anyway, it's not so much any specific kind of algebra (like groups, abelian groups, lattices, rings, monoids, vector spaces, normed vector spaces, &c.), but rather the whole framework in something like universal algebra, or `F'-algebras, that "algebra" in "algebraic data type" refers to, iiuc
18:14:18 <eelster> Ah
18:14:57 <EvanR> or final F-coalgebra
18:15:10 <ertes> EvanR: makes sense, yeah
18:19:24 <EvanR> speaking of algebraic... im tryng to write a recursive algorithm to find all the roots of a polynomial on some interval
18:19:57 <eelster> EvanR: If it's more than quartic good luck.
18:20:37 <eelster> Are you trying to find exact solutions for the roots or are you using a root finding algorithm? 
18:21:08 <EvanR> exact real arithmetic
18:21:47 <eelster> EvanR: I wish you good luck. ]
18:22:04 <EvanR> but i got stuck because at one step i need to see if the value of the monotonic interval has max and min of different signs
18:22:31 <EvanR> to say "no roots here"
18:22:54 <EvanR> but generally the boundaries of the subdivided interval are irrational
18:23:03 <jchia> I'm getting a compilation error with DeriveAnyClass. Is this expected or is it a bug with GHC or mono-traversable? http://lpaste.net/350846
18:23:41 <eelster> EvanR: If you're using exact arithmetic, then wouldn't you need to be able to handle irrationals? 
18:24:12 <EvanR> i am, but i cant decide if a number is greater, less or equal to zero 
18:24:55 <ski> are you using some variant of improving intervals ?
18:25:02 <EvanR> yeah
18:25:06 <eelster> EvanR: Use Rolle's Theorem potentially? 
18:25:10 <Squarism> how 
18:25:27 <Squarism> should i map an Either's left part elegantly
18:25:28 <EvanR> type R = [(Q,Q)]
18:25:41 <Squarism> like is there a "fmap" for lefts 
18:26:42 <Squarism> bifunctor "first" ?
18:27:05 <EvanR> basically i dont really know where my monotonic interval really ends
18:28:19 <EvanR> i felt like restricting to polynomials should earn me a few bones with the computability 
18:30:41 <eelster> EvanR: Because you're using polynomials you should be able to get the first and second derivatives rather trivially. Use those to your advantage.
18:30:51 <EvanR> i have all the derivatives
18:31:08 <EvanR> at some point the derivative looks like a linear function and its clear whats going on
18:31:09 <eelster> EvanR: Ah. Nevermind.
18:40:12 <ertes> Squarism: yeah
18:40:44 <ertes> Squarism: if you've imported Control.Lens, you can also use the _2 lens
18:41:00 <ertes> > (_2 +~ 5) (3, 4)
18:41:03 <lambdabot>  (3,9)
18:41:07 <ertes> whoops
18:41:08 <Squarism> good to know
18:41:12 <ertes> Squarism: the _1 lens =)
18:41:16 <ertes> > (_1 +~ 5) (3, 4)
18:41:17 <erisco> am I bad for exploiting classes so I don't have to use a Hungarian notation for names?
18:41:18 <lambdabot>  (8,4)
18:41:31 <erisco> same operation, different types
18:42:15 <ertes> erisco: it's a somewhat common kind of abuse…  see e.g. Data.Default
18:42:35 <eelster> erisco: No. You're completely fine for doing that. Hungarian notation is, to quote Linus Torvalds, Encoding the type of a function into the name (so-called Hungarian notation) is brain 
18:42:43 <eelster> damaged "
18:42:49 <eelster> That quote got messed up
18:43:00 <EvanR> that quote is brain damaged
18:43:00 <Squarism> btw ertes. That hangman-reworked-into-boardgame ive worked on, has now been approved by the publisher for release! All thanks to you main mentor! =D
18:43:19 <eelster> I just personally like quoting Linus Torvalds.
18:43:39 <ertes> erisco: however, note firstly -XDuplicateRecordFields, secondly the module system (module prefixes)
18:44:07 <eelster> but actually, listen to ertes on this one.
18:44:18 <erisco> I haven't had DuplicateRecordFields inference work predictably
18:44:34 <ertes> erisco: it's completely predictable…  it's just awkward =)
18:44:50 <erisco> let me substitute "predictably" for "intuitively"
18:45:08 <ertes> it doesn't use type inference to its full extent unfortunately
18:45:17 <ertes> in fact i'm not sure it uses inference at all
18:48:00 <erisco> yes that is what Hungarian notation does
18:48:10 <erisco> it is just elaborate to use classes in this way
18:48:21 <geekosaur> eelster, my counterargument is that the thing that's really braindamaged in that case is the type system that makes you hack around its limitations (types in the name as bankrupt "polymorphism")
18:48:31 <erisco> but organisationally it makes more sense… all the suffixes were making my eyes bleed
18:48:51 <eelster> I don't actually agree with the quote 100% (although Hungarian Notation is abused).
18:49:30 <erisco> though it is a bit skew to the usual circumstance
18:49:58 <erisco> it isn't that I am using one data type for multiple meanings, such as having Int mean dimension, age, balance, and so forth
18:50:05 <ertes> both hungarian notation and type classes are the wrong approach here…  i really wouldn't mind ad hoc polymorphism the way C++ does it…  yes, it introduces potential for mistakes, but i'd say that potential is negligible
18:50:19 <erisco> it is that I have multiple data types with their own meaning but a common operation for all of them
18:50:38 <ertes> in other words: i view this is a shortcoming of haskell that really needs to be fixed
18:50:59 <erisco> yeah it is really just a fix for function overloading, which other languages have
18:51:12 <ertes> not an earth-shattering one, just an annoying one
18:51:36 <geekosaur> they're also used by people who aren't quite used to types; that;s acceptable as long as the training wheels come off at some point
18:53:12 <ertes> also all the work that is being done around making this work for records seems like a huge waste of time to me…  add -XAdHocPolymorphism and the problem goes away by virtue of a feature that may be useful in many ways…  in particular it would make the whole data-default package obsolete
18:57:50 <erisco> well if people are going to abuse TC's anyways then what is the harm
18:58:49 <EvanR> good reasoning, you could probably justify a lot that way
18:58:51 <EvanR> useful
19:00:58 <erisco> roll with the punches EvanR
19:01:06 <ertes> erisco: the harm is that type classes always come with authority
19:01:17 <ertes> erisco: someone needs to define the class
19:02:22 <ertes> the sole fact that the class needs to be defined is a problem
19:03:39 <erisco> no, I mean what is the harm in adding adhoc poly when people are already abusing TC's for the same effect
19:03:40 <EvanR> typeclasses vs the world
19:03:52 <ertes> the fact that instances need to be defined is a problem as well…  it's a lot of extra code just to work around a language limitation that most other languages have long solved
19:04:03 <ertes> ah
19:04:15 <ertes> erisco: i don't think there is any harm in adding ad-hoc polymorphism
19:04:21 <erisco> the problem with using TC's for adhoc poly is in part what you've said, and the other part is that the big TC feature is contexts
19:04:46 <erisco> if there is no sense in writing a generic function with your TC then it doesn't seem like a good TC
19:05:08 <ertes> i agree
19:05:18 <ertes> that's why i created the acme-default package as a parody of data-default
19:09:04 <EvanR> is it possible for a polynomial function with rational coefs to come arbitrarily close to the x-axis yet not be equal to zero for any rational x
19:09:28 <ertes> data-default is a manifestation of a decades old shortcoming of haskell…  and everybody seems to be obsessed with solving all those special cases of it…  ok, we got record puns, but what's next?  after a lot of people have asked for constructor puns and waited another 5 years to finally get it, someone will ask for operator puns…  then function puns…  then an escape from the heat death of the universe
19:09:33 <EvanR> but remain on one side or the other
19:10:21 <EvanR> dont see how default solves anything really
19:12:29 <ertes> EvanR: it does:  it establishes a convention…  one that really shouldn't require a package
19:12:39 <nshepperd> EvanR: no
19:13:31 <Axman6> ertes: it's also pretty widely considered to be a bad idea
19:13:33 <EvanR> nshepperd: are you sure
19:13:43 <nshepperd> all polynomials except for constant ones go to infinity at x -> ∞ or -∞
19:14:01 <ertes> Axman6: "it" being …?
19:14:11 <Axman6> Data.Default
19:14:13 <EvanR> even polynomials can remain on one side of the xaxis
19:14:59 <ertes> Axman6: i wouldn't say it's a "bad idea"…  i would call it an ugly workaround
19:15:14 <nshepperd> and if it has a limit to 0 at any finite location, then it hits 0, since polynomials are always continuous
19:15:19 <ertes> Axman6: there is nothing *technically* wrong with the type class…  it doesn't try to emulate OO or anything
19:15:31 <EvanR> nshepperd: talking about rational x
19:15:49 <EvanR> i.e. it hits 0 at an irrational
19:15:51 <nshepperd> oh
19:16:05 <nshepperd> um, then yes!
19:16:21 <nshepperd> x^2 - 2
19:16:33 <EvanR> that crosses
19:16:43 <Axman6> laweless classes are generally frowned upon. it's kinda sorta a little bit like the identity element in Monoid, but there's no operations so no laws
19:17:37 * nshepperd reads all of the lines again
19:17:56 <ertes> Axman6: well, not every class comes with laws…  the important bit is that it should be an actual abstraction:  if there is no point in abstracting over the class, then the class itself is pointless
19:18:06 <wespiser> is there a way to limit the memory used in a stack executable?
19:18:22 * ski . o O ( s/xaxis/abscissa/ )
19:18:41 <Axman6> ertes: right, but it's considered by many that classes should definitely come with laws
19:18:44 <EvanR> it seems plausible but i couldnt come up with an example
19:19:05 <Koterpillar> EvanR: so you want f(x) = f'(x) = 0 at an irrational point
19:19:16 <EvanR> yes
19:19:25 <ertes> Axman6: sure, it's just that not every type class represents some algebraic structure…  and sometimes the type system itself is just enough to enforce what would otherwise be laws
19:19:26 <EvanR> with rational coefficients
19:19:38 <ertes> Axman6: imagine a Magma type class…  there are no laws to formulate
19:19:55 <ertes> all the Magma laws are already enforced by the type system
19:20:12 <EvanR> all zero of them ;)
19:20:29 <ertes> well, there is one:  it needs to be a closed binary function =)
19:20:35 <EvanR> thats... a silly law
19:20:39 <nshepperd> EvanR: (x^2 - 2)^2
19:20:48 <EvanR> ok...
19:20:57 <ertes> EvanR: 'replicate' is not a magma, but (+) is…  that makes it a law
19:21:08 <ertes> some things don't satisfy it
19:22:41 <ski> imho, "'replicate' is not a magma" is not a well-typed statement
19:22:58 <ertes> class Magma a b c | a -> b c, b -> a c, c -> a b where (<>) :: a -> b -> c  -- all instances must satisfy the following law: a = b = c
19:22:59 <ertes> =)
19:23:01 <EvanR> before laws comes types
19:23:13 <nshepperd> it's the sort of law that haskellers turn their noses up at, since anything that can be enforced by the type system is boring
19:23:42 <ertes> ski: would you consider "() is not a Bool" an ill-typed statement?
19:23:49 <EvanR> maybe were just bored with what haskells type system can enforce
19:23:56 <EvanR> nshepperd: that example does it... yep...
19:24:04 <EvanR> the world is doomed
19:24:46 <ertes> ski: if you're thinking of type theory, then you might not consider it a statement at all
19:25:02 <EvanR> if you leave your formal system behind, its ambiguous in many ways
19:25:18 * nshepperd does math by throwing examples at the wall until something sticks
19:25:19 <EvanR> please put the context back and press any key to continue
19:25:47 <EvanR> "error: context not found"
19:26:04 <ertes> well, actually it can still be a statement, because type equality is a thing
19:26:32 <ertes> there exists no A such that () :: A and A = Bool
19:27:06 <ski> hm, i was just concluding you were talking about the type `()'
19:30:26 <EvanR> in a sequence of intervals converging to sqrt(2), that example shows we have no hope of asking what the behavior within the interval is. does it cross zero, does it have positive and negative values inside the interval, what is the maximum
19:30:55 <ertes> record Magma {a} : Set (lsuc a) where field A : Set a; B : Set a; C : Set a; closed-A-B : A ≡ B; closed-B-C : B ≡ C; f : A → B → C
19:31:18 <EvanR> what is even a bound
19:31:22 <ertes> why use the type system if you can use proofs =)
19:31:47 <EvanR> thats...
19:32:11 <EvanR> much shorter to just say Sigma(t : Type) (t -> t -> t)
19:32:34 <EvanR> Magma = that
19:33:24 <ertes> EvanR: the point is that it's still a law…  it's just trivially enforced by the type system, so it might just be below your radar =)
19:33:37 <EvanR> we can make things as complex as you want
19:33:44 <EvanR> its unbounded
19:34:06 <EvanR> id say a good goal is to make it as uncomplex 
19:37:44 <EvanR> ertes: given how much we use the type system, we would be drowning in a ocean of closed-ness laws everywhere
19:38:20 <ertes> EvanR: that's right, but it doesn't change the fact that it's a law…  in fact you're actually stating it when you define the class by giving a type signature
19:38:27 <EvanR> and non-closedness doesnt even make sense
19:39:06 <ertes> class SomeFunctionThatMayNotBeAMagma a b c where func :: a -> b -> c
19:39:13 <EvanR> it assumes you already have types to differentiate things
19:39:54 <EvanR> ive never seen a magma defined between different types
19:40:22 <ertes> SomeFunctionThatMayNotBeAMagma is more general than Magma…  it includes magmas, but may include other functions
19:40:37 <EvanR> what does a b and c range over
19:40:46 <ertes> *
19:40:56 <EvanR> types
19:41:26 <ertes> class (SomeFunctionThatMayNotBeAMagma a a a) => Magma a
19:42:04 <EvanR> call edk we might need to redesign the ecosystem ;)
19:42:49 <ertes> i can easily name an instance of SomeFunctionThatMayNotBeAMagma that is not a Magma…  Magma is clearly stronger =)
19:43:19 <EvanR> without laws, all were doing is calling stuff stuff
19:43:52 <ertes> what's your definition of "law"?  "constraint that i have to describe in prose"?
19:43:53 <EvanR> and just the name of stuff melts away when you apply isomorphism goggles
19:44:40 <ertes> ok, let's put on the isomorphism goggles
19:44:43 <EvanR> type class machinery is really getting in the way when the specification is "something of type a -> b -> c"
19:44:51 <EvanR> i.e.
19:44:54 <EvanR> a -> b -. c
19:44:57 <ertes> type BinaryFunction a b c = a -> b -> c
19:45:04 <ertes> type Magma a = a -> a -> a
19:45:19 <EvanR> right, just names
19:45:22 <EvanR> abbreviations
19:45:28 <ertes> perhaps make those existential, so that we can talk about isomorphisms
19:45:33 <EvanR> (which in this case is probably making it more verbose)
19:46:13 <ertes> in any case any one-to-one correspondence you come up with will miss functions in BinaryFunction
19:46:40 <EvanR> its a type synonym
19:47:16 <ertes> ok, i don't really care anymore =)
19:47:57 <EvanR> do these polynomials even *have* roots?
19:48:03 <EvanR> constructively
19:52:21 <ski> ertes : "it doesn't change the fact that it's a law" -- you could introduce a spurious law for it, but stated as `a -> a -> a', i'd not agree it's a law
20:00:48 <ertes> ski: we might be in disagreement as to what exactly a law is
20:02:08 <ertes> ski: in agda i can define Magma as a stronger version of BinaryFunction that includes the equality as an explicit law just the same way other laws are stated
20:02:19 <ski> agreed
20:03:36 <ski> you could even add another field, and an extra law for equating it to `->'
20:04:34 <ertes> ski: i see your point, but wouldn't you consider the function itself with the type signature as a law in itself?  that one isn't redundant
20:05:30 <ski> i wouldn't
20:06:22 <ertes> ski: due to a formal notion of "law"?
20:06:34 <ertes> or just intuitively?
20:07:54 <ski> afaiu, a law is at the very least a property (or type, if you'ren't proof irrelevant) that may or may not hold for some free variable(s)
20:08:50 <ski> i suppose you could consider the case with zero variables of interest, then you'd basically have a law "about" the empty tuple. but it didn't sound like you had that in mind
20:10:16 <ertes> ski: record Monoid {a} : Set (lsuc a) where field A : Set a; mappend : A → A → A  -- that makes mappend a law
20:10:27 <ertes> (insert "…" appropriately)
20:11:37 <ski> "at the very least" was meant to specify a lower bound on the requirements :)
20:12:05 <ski> (more specifically, not meant to be a complete characterization)
20:12:15 <ertes> ski: but you see how fuzzy this notion is =)
20:12:23 * ski nods
20:13:25 <ertes> i'd consider every non-redundant field a law…  simple and precise (or can be made precise when put against the wall)
20:13:40 <ertes> +up
20:13:55 <ski> but even if you consider `A → A → A' a law there (being named `mappend'), i'd still not agree that it expresses the "law" that "`mappend' is a closed binary function" (i'm sure you see why)
20:14:24 <ertes> yes
20:14:37 <ertes> "binary" itself is not well-defined here
20:15:04 <ertes> and "closed" isn't really a thing anyway in type theory
20:15:44 <ski> (if you wanted to, you could state a law that the image of `append', when restricted to some subset `S' of `A', is also `S'. that would express "closedness", imho)
20:16:44 <ertes> sounds like a continuity notion more than closedness
20:17:49 <ski> well, a statement like "addition is closed under the even integers" would refer to something along these lines, no ?
20:17:59 <ertes> yeah, indeed
20:18:51 <ertes> but i'd rather just leave it up to the user to embed that notion into A instead of bloating the definition of Monoid
20:19:04 <ski>   add : |Z -> |Z -> |Z
20:19:52 <ski>   add-closed-under-evens : (m :) |Z -> (n :) |Z -> even m -> even n -> even (add m n)
20:20:35 <ski> or, baking them together
20:21:11 <ski>   add-evens : {m : |Z | even m} -> {n : |Z | even n} -> {o : |Z | even o}
20:21:32 <ski> (possibly also saying that it agrees with `add')
20:22:06 <ski> ertes : embed which notion into `A' ?
20:22:14 <ertes> record BloatedMonoid {a p} : Set (lsuc (a ⊔ p)) where field A : Set a; P : A → Set p; mappend : (x y : A) → {Pred x} → {Pred y} → A; closed : (x y : A) → Pred x → Pred y → Pred (mappend x y); …
20:22:15 <ertes> =)
20:22:57 <ertes> rather have:  A = ∃ Even
20:23:02 <ertes> where Even : ℤ → Set
20:23:31 * ski nods
20:26:13 <qmm> i've never seen this before. anyone have an idea what's going on? https://github.com/haskell-servant/example-servant-minimal/blob/master/src/App.hs#L48 
20:26:19 * ski idly wonders what it would mean for an operation to be open wrt a set
20:26:27 <qmm> i would expect to read "case foo of"
20:26:34 <Koterpillar> qmm: https://github.com/haskell-servant/example-servant-minimal/blob/master/src/App.hs#L3
20:27:05 <ski> qmm : short for `\foo -> case foo of ...', for a fresh variable name `foo'
20:27:19 <qmm> thanks Katerpillar!
20:27:32 <ski> it's the language extension `LambdaCase', as Koterpillar indicates
20:28:56 <ski> (in SML, it'd be `fn 0 => return exampleItem | _ -> throwE err404', and something similar in O'Caml)
20:39:20 <qmm> "data a + b = Foo a b" is also a first
20:48:11 <qmm> https://github.com/haskell-servant/example-servant-minimal/blob/master/src/App.hs#L67
20:49:47 <subttle> Hi, I have a question on this code snippet: http://pastebin.com/juTKxfah
20:49:56 <ski> `TypeOperators'
20:49:59 <qmm> i'm aslo not sure why the TypeOperators was iported
20:50:00 <qmm> ah
20:50:15 <ski> s/imported/enabled/
20:50:25 <qmm> thanks for the correction
20:50:26 <subttle> is there a reason why I should have to annotate the type as I did or is that a bug?
20:51:44 <monochrom> have you ever asked for :t sigma testDFA ?
20:51:56 <monochrom> ah you have.
20:52:03 <subttle> yep :)
20:52:31 <monochrom> and you see there is an "s" to be determined
20:53:37 <ski> subttle : perhaps you meant `sigma :: formalism s -> Set s' and `sigmaStar :: formalism s -> [[s]]' (and then also `instance (Ord s, Enum s) => Σ (DFA q) s',&c.) ?
20:53:58 <subttle> monochrom: yes, but shouldn't it be able to deduce that because the class specifies s twice that it is the same?
20:54:29 <monochrom> I don't understand that logic.
20:54:31 <ski> subttle : it does no such thing
20:55:19 <subttle> ski: adding the `s` won't compile
20:55:19 <monochrom> it sounds to me like "I said 's' twice therefore the computer ought to know what I want to plug into s". Tell me I am reading it wrong.
20:55:50 <ski> subttle : you need to adapt the instances as well
20:56:30 <ski> subttle : .. however, it's not clear to me that what i suggested is what you want to do ..
20:56:41 <subttle> I mean that because I specified the `s` in `DFA q s` is the same that it should be able to work without the type annotation
20:56:53 <monochrom> sorry, is the same as what?
20:57:12 <monochrom> Are you saying "I specified that s is the same as s"?
20:57:22 <ski> subttle : do you, so to speak, want the "`s' in `formalism'" to be the same as the other `s', in `Σ formalism s' ?
20:57:57 <subttle> i.e. because I wrote `instance (Ord s, Enum s) => Σ (DFA q s) s where` and not `instance (Ord s, Enum s) => Σ (DFA q s) s' where`
20:58:17 <subttle> ski: if I understood you correctly, then yes :)
20:59:13 <ski> subttle : and do you want this to (unconditionally) be the case for *all* instances of `Σ' ?
20:59:32 <geekosaur> mm, doesn't this need a way to relate formalism and s for sigma to work? (fundep or type family)
20:59:48 <ski> (not just for `DFA', and the other three instances you listed, but also for every future instance)
21:00:09 <subttle> ski: yes
21:00:17 <ski> geekosaur : yes, or "abstracting it out", which is the take i'm following atm
21:00:47 <geekosaur> ah, ok (follwoing slightly behind, just switched back to irc window)
21:00:58 <ski> subttle : then it seems to me to be better to use `instance (Ord s, Enum s) => Σ (DFA q) s' (note, no `s' in the first argument), together with `sigma :: formalism s -> Set s' and `sigmaStar :: formalism s -> [[s]]'
21:02:37 <subttle> ski, I think that would require me to change some code, e.g. for `PDA q s z`
21:02:44 <ski> subttle : then, actually "the class specifies s twice" holds, because `s' is mentioned twice in `sigma :: formalism s -> Set s', once in the return type, and once passed to `formalism' (being e.g. `DFA q', so that the whole argument type then becomes `DFA q s')
21:03:08 <ski> subttle : yes, you'd need to have `s' as the last argument for this to work
21:03:19 <subttle> ski but yes I just tried that and it works :)
21:03:28 <subttle> thanks for all your help by the way, everyone
21:04:08 <ski> subttle : an alternative you could try (which can't be used in quite the same circumstances, but might work in your case) is functional dependencies as geekosaur suggested
21:05:36 <ski> subttle : then you'd not muck around with passing `s' to `formalism', instead changing the class "header" to `class (Ord s, Enum s) => Σ formalism s | formalism -> s where', to claim that `formalism' (e.g. `DFA q s' or `PDA q s z') (funtionally) *determines* `s'
21:05:51 <subttle> geekosaur, ski: okay, I'll have to look that up 
21:05:52 <ski> (cf. functional dependencies in relational database theory)
21:06:43 * ski doesn't atm see how it would help with the ambiguous type problem showed in the paste, though
21:08:05 <ski> subttle : now, if you have nothing to state after the `where', then you can just omit it
21:08:57 <subttle> ski: good to know, thanks!
21:09:00 <ski> (but perhaps you've just omitted the instance body in the paste. or perhaps you have (or intend to make, or at least allow making) instances with non-empty bodies)
21:09:58 <ski> subttle : do you have any method in `Σ' which doesn't have a default implementation, or for which you actually want to override the default implementation ?
21:11:16 <ski> subttle : .. since, if not, then i think it would make more sense to move any such methods out of the class
21:11:17 <subttle> not for `Σ`, but I have a very similar class, `Q` which abstracts all my functions which operate on states (essentially graph functions) 
21:11:47 <ski> (but keeping the class constraint in their type signature)
21:12:27 <subttle> ski: one of my attempts was something like that, ditching the class altogether
21:12:29 <subttle> sigma :: (Ord s, Enum s) => proxy s -> Set s
21:12:42 <monochrom> I think you should go fundep.
21:12:52 <subttle> but I don't like that it silently "works" on `PDA q s z` and gives the wrong answer
21:13:14 <subttle> monochrom: I'm looking it up as we speak, any suggested articles?
21:13:52 <monochrom> The reason is that if you made a formalism a * -> * kind thing, there would be no philosophical reason for preferring that type parameter to be for the alphabet rather than the states.
21:14:13 <ski>   sigma :: Σ formalism s => formalism s -> Set s
21:15:58 <monochrom> OK, maybe there is a philosophical reason. The states is an implementational detail, maybe you even have a formalism that doesn't talk about states; but the alphabet is the (only) interface to the outside world, you always have an alphabet, it is the only compulsory thing.
21:15:59 <ski> (oh, now i see why FDs would make the ambiguous type there disappear. i suppose i'm tired)
21:16:26 <ski> monochrom : "maybe you even have a formalism that doesn't talk about states', that would be `RegExp', iiuc
21:17:14 <subttle> yep :)
21:18:19 * ski isn't sure subttle has learned about kinds, yet
21:19:00 <monochrom> OK, here is a new reason for fundep. You are not even sure you want every formalism to be parametrizable on the alphabet type.
21:20:06 <ski> "language formalisms" (in this sense) doesn't necessarily involve an alphabet ?
21:20:10 <monochrom> It's the exact same objection you could raise to the Foldable class. "Why isn't ByteString a Foldable instance?" Oh it's only because of the technicality that ByteString has only Word8 elements and not any other types of elements.
21:20:51 <subttle> I wouldn't say I'm an expert on Kinds, I think most of the docs on that are scarier than Agda stuff, so I've invested in my time so far in starting to learn Agda rather than learn all the GHC extensions :/
21:21:50 <monochrom> A language formalism always involves an alphabet (like I said it's your only interface to the world) but you don't always leave it parametrized. Maybe tomorrow you want to define a formalism that is hardcoded to do Char only.
21:22:52 <ski> ah, i see
21:23:18 <monochrom> The same way ByteString is of course a "container" but it only contains Word8. And so parsec has to use a fundep.
21:23:48 <ski> subttle : i'd say kinds are a relatively basic type system topic in Haskell
21:24:11 <buttons840> any transient users among us? I tried using it to parallelize some web requests and it worked, but it prompts the user to enter "end" at the terminal before the program ends, why? I don't want to prompt the user for input
21:24:50 <ski> subttle : kinds are roughly "types of types". `[Maybe]' doesn't make sense, you need to apply `Maybe' to a type, e.g. `Int', so `[Maybe Int]' makes sense
21:25:06 <subttle> ski: clearly I know the basics about kinds, I'm not exactly up to speed on all the latest in GHC 8.0 though
21:26:05 <ski> subttle : well, above we went from `formalism :: *' to a proposed `formalism :: * -> *' (since `s :: *' in `sigma :: formalism s -> Set s')
21:26:07 <kadoban> Is it worth figuring out the "detailed-0.9" interface for test suites? I use tasty. I don't see a lot initially in searching ... should I just use exitcode-stdio?
21:28:04 <subttle> geekosaur, monochrom, ski: thanks for your help and comments
21:28:44 <ski> np
21:35:57 <ski> la la la
21:36:47 <Axman6> I guess matrix.org just died...
21:38:12 <saurabhn_> any type-extension gurus around? How to derive instances for records with type-families -- http://stackoverflow.com/questions/41456841/how-to-derive-instances-for-records-with-type-families
21:39:02 <saurabhn_> and another one? How to make lenses for records with type-families: http://stackoverflow.com/questions/41456869/how-to-make-lenses-for-records-with-type-families
21:42:33 * ski doesn't see how `NewTag' (presumable the "record" you mentioned) is related to the instance deriving ..
21:43:36 <ski> did you mean something like `deriving instance .. => Show (NewTag Validated); deriving instance .. => Show (NewTag ValidationErrors)' ?
21:45:26 <ski> in any case, `instance Show baseType => Show (Incoming Validated baseType)' amounts to `instance Show baseType => Show baseType'
21:45:36 <ski> and i don't think that can work
21:45:55 <saurabhn_> updating my code samples on stackoverflow to be more complete
21:47:20 <saurabhn_> ski: edited both the questions
21:48:03 <gamegoblin> is there anything that goes from :: (a -> b) -> [[a]] -> [b] 
21:48:24 <gamegoblin> (hoogled it but found nothing, any fancy combinators you can come up with?)
21:48:50 <ski> @type (concat .) . map . map
21:48:52 <lambdabot> (a1 -> a) -> [[a1]] -> [a]
21:49:30 <gamegoblin> lol
21:50:01 <ski> (another satisfied customer), next question ?
21:50:28 <gamegoblin> ski: doesn’t that visit each element twice? Or does laziness save you here?
21:51:18 <ski> twice, why ?
21:51:42 <gamegoblin> ski: because it’s possible to do with visiting each element once
21:52:30 <ski> i'm not sure whether you're referring to it making an intermediate data structure (list), which it then traverses again ?
21:52:48 <gamegoblin> I have a way to do it by visiting each one once, but it’s not super pretty (which is why I asked here)
21:52:51 <ski> (it doesn't traverse the original list (of lists) twice, in any case)
21:53:17 <ski> yes or no ?
21:53:39 <gamegoblin> ski: you go from [[a]] to [[b]] and then to [b]
21:53:49 <ski> right, so there's an intermediate list
21:53:55 <gamegoblin> ski: but it’s possible to write a specialized function that goes directly from [[a]] to [b]
21:54:09 <gamegoblin> that concats as it maps
21:54:28 <ski> (which i wouldn't express as "visiting each element once", especially since the elements themselves are new, since we're mapping from one type to another)
21:54:29 <gamegoblin> I just can’t figure out a super sexy definition for it
21:55:40 <ski> gamegoblin : however, `map' is incremental, so (because of non-strictness, as you indicated) this intermediate list won't be materialized all at once, but rather only as much as needed by the consumer
21:56:11 <gamegoblin> ski: I guess I am more concerned about cache effects, a little hard to reason about with laziness
21:56:33 <ski> gamegoblin : e.g. if you have a list containing 1000000000 elements, each containing 1000000000 elements, it's possible that the list won't reside in memory all at once
21:56:50 <ski> rather, the start of it will start getting GCed before the end of it has been constructed
21:57:17 <ski> this is assuming the consumer is consuming the result list in a linear fashion, e.g. summarizing the information in some way, as it goes
21:58:32 <ski> in case the above use of `concat' and `map' fuses (list fusion), then the intermediate list will be completely optimized away
22:01:49 <ski> gamegoblin : i suspect that your specialized function is basically what list fusion would generate here
22:08:19 <quatro> #list
22:16:54 <buttons840> has anyone had success with the transient package? I've been trying it but can't get my simple program to run to completion and end without a "thread blocked indefinitely in an MVar operation" error
22:17:54 <lpaste> Buttons840 pasted “Short Transient code that won't end gracefully.” at http://lpaste.net/350851
22:19:20 <buttons840> the transient API looks like it's almost too high level, it would be great if it works, but part of me suspects there some details that got glossed over to make such a simple concurrency api
22:28:31 <codygman> Anyone know how I could format this so alignment "just works" in haskell mode? http://lpaste.net/350852
22:30:40 <ocramz> I have a container structure for numerical data, and I need two distinct instances for the real- and complex-valued case. What principled ways are there to avoid the overlapping instances? I mean, the instance of `Struct (Complex a)` is a strict subset of that of a generic `Struct a`
22:33:24 <codygman> posting again because of join spam: Anyone know how I could format this so alignment "just works" in haskell mode? http://lpaste.net/350852
23:03:02 <erisco> ocramz newtypes
23:36:57 <erisco> @tell gamegoblin Haskell lists are singly linked lists. Indirection on every element will not lend to great caching. If that were really the concern then try something other than lists
23:36:57 <lambdabot> Consider it noted.
23:41:05 <erisco> why is university filled with the micro-optimisation questions
23:41:52 <erisco> some relics from ages past no doubt
23:48:16 <geekosaur> there's still an academic preoccupation with Lisp-inspired notions (like everything being based on cons cells at heart)
