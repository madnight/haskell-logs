00:00:15 <saurabhnanda> too much voodoo for me
00:00:22 <EvanR> which potentially obviate the creation of that channel
00:00:27 <saurabhnanda> so, if this compiles, I'm doing the right thing?
00:00:47 <EvanR> not necessarily
00:01:23 <quchen> There’s no voodoo in STM. STM simply promises that if you run an STM action with »atomically«, then the whole thing will be run without observable intermediate states.
00:01:47 <saurabhnanda> hmm
00:02:05 <saurabhnanda> the problem with this type of concurrent programming is that it's not easy to know if you've done something incorrectly
00:02:12 <quchen> newBroadcastTChan is in STM so it can be grouped in one atomic transaction with other STM actions, such as updating a counter of how many channels there are, or creating other channels.
00:02:33 <EvanR> if you are familiar with transactions or transactional programming, its easy
00:02:37 <quchen> saurabhnanda: STM is pretty much IO with an additional safety guarantee, if that helps
00:03:27 <quchen> saurabhnanda: If you haven’t read Marlow’s book on concurrency, it’s highly recommended. It’s a really nice book with simple, yet thorough explanations.
00:03:47 <quchen> And it kills all the magic ;-)
00:04:00 <EvanR> kill -s KILL magi
00:04:02 <EvanR> c
00:04:15 <EvanR> no magic beyond this point
00:04:40 <saurabhnanda> okay, will give it a thorough read, then
00:05:34 <EvanR> atomically causes side effects, unlike runST. It's different. it's not escaping
00:05:45 <EvanR> the key is that ... its atomic
00:05:53 <EvanR> all effects happen or none of them do
00:22:54 <saurabhnanda> should I expect Opaleye.runQuery to be exported here? https://gist.github.com/saurabhnanda/b4177c13729a5d51b1e3048ff8e95ae5
00:39:35 <haskell159> why doesn't the base haskell library have homogenous tuples ?
00:40:27 <quchen> What is a homogeneous tuple?
00:40:34 <Axman6> type Tup3 a = (a,a,a)?
00:40:46 <Axman6> why would we need that?
00:40:46 <xpika> Axman6: yep
00:40:56 <xpika> it has the added property that you can fold it
00:41:24 <xpika> provided its a monoid
00:41:41 <quchen> Foldable things don’t have to be monoids
00:42:56 <Axman6> they're so easy to implement (and easy to implement things like lenses to work with them), but also not particularly commonly needed, so I guess that's why they're not in base/the Prelude
00:43:18 <cocreature> you can view a homogeneous tuple as a fixed size vector and then they are quite common
00:45:12 <xpika> cocreature: that only sounds sensible if dealing with numbers
00:45:21 <cocreature> xpika: why?
00:45:58 <xpika> cocreature: in the same way you can store characters in Complex numbers
00:46:18 <cocreature> you are rarely going to use them since you want different Functor instances and so on so usually you do something like "data Vec3 a = Vec3 !a !a !a" instead of using a tuple
00:46:22 <cocreature> xpika: sorry I’m not following
00:46:26 <xpika> > 'a' :+ 'b'
00:46:28 <lambdabot>  'a' :+ 'b'
00:47:53 <cocreature> I don’t see why that’s only useful for numbers. as soon as you want to perform the same operations on a fixed number of things, putting them in something in a fixed size vector and mapping the same function over all of them is useful
00:49:12 <Axman6> actually, Conor McBride gave a great talk at Yow LambdaJam last year hich made great use of datatypes like that: https://www.youtube.com/watch?v=3U3lV5VPmOU
00:49:21 <xpika> cocreature: i wouldn't want to confuse a datatype with geometric associations with just a regular container.
00:49:32 <Axman6> which means there's likely a library with it somewhere
00:49:38 <cocreature> xpika: I guess I just don’t have the geometric associations :)
00:51:09 <xpika> >  (V2 1 2) * (V2 3 4) 
00:51:11 <lambdabot>  error:
00:51:11 <lambdabot>      • Data constructor not in scope: V2 :: Integer -> Integer -> a
00:51:12 <lambdabot>      • Perhaps you meant variable ‘_2’ (imported from Control.Lens)error:
00:52:13 <cocreature> xpika: I know what you mean by “geometric associations”. but I tend to use fixed size vectors ase a regular container way more often than using them as linear algebra objects
00:52:21 <cocreature> obviously that depends on your usecase
00:52:38 <xpika> cocreature: ok interesting to know
00:53:16 <cocreature> xpika: the "vector" library we have in Haskell is also hardly specific to the geometric interpretation
00:54:42 <xpika> cocreature: Haha. In java land that would be called an arraylist
00:55:17 <cocreature> xpika: in c++ land it’s also called "vector" :)
00:55:53 <cocreature> and the dependently typed crowd calls fixed size linked lists vectors
01:06:26 <athan> could lenses and recursions schemes have a baby? ._.
01:10:25 <xpika> cocreature:that is true. seems like most people are conflating maths terms with containers.
01:11:50 <roxxik> athan: what would that look like :O
01:11:57 <xpika> xpika: if i designed a dependently typed language . Vectors would be fixed length lists.
01:13:53 <athan> roxxik: frickin sharks with frickin lasers on their frickin heads
01:14:09 <saurabhnanda> In `allTags :: (HasDb m) => m [Tag]` can I use `m` in the function definition? What extension should I enable to do this?
01:14:45 <liste> saurabhnanda: you mean use it in type annotations inside the definitions?
01:14:51 <saurabhnanda> liste: yes
01:14:51 <liste> saurabhnanda: -XScopedTypeVariables
01:14:55 <cocreature> saurabhnanda: enable ScopedTypeVariables and use "forall m. (HasDb m) => m [Tag]"
01:15:01 <athan> saurabhnanda: You should see `m` as like the context for which your result lives in
01:15:02 <cocreature> the "forall" is important here
01:15:11 <saurabhnanda> Or how do I enable this? `(rows :: [ClientTagRead]) <- runQuery conn query`
01:15:16 <roxxik> athan: but it sounds facinating. i also liked to bridge Folds to use Folds (quite confusing, but look at Foldl's foldOver)
01:15:37 <athan> oh that's right! I forgot about Fold
01:15:48 <dramforever> saurabhnanda: Surprise! It's the same extension!
01:15:52 <saurabhnanda> ah okay
01:15:57 <saurabhnanda> it's a safe extension, right?
01:16:01 <roxxik> athan: disclaimer: i wrote foldOver just a few days ago
01:16:04 <saurabhnanda> I'm using it blindly to solve my current problem
01:16:31 <dramforever> Which in general doesn't work
01:16:44 <dramforever> but if you *are* sure you need 'm' in the function definition just go for it
01:16:52 <athan> oh herp sorry saurabhnanda, yes scoped type variables can solve this, but you have to declare your `m` with forall at the top scope of your term
01:17:14 <saurabhnanda> athan: okay, got it
01:17:23 <saurabhnanda> it won't force me to use `forall` everywhere, right?
01:17:26 <athan> that's like the lambda which other `m`'s reference their scope to. Without -XRankNTypes & -XScopedTypeVariables, it would generate fresh for every term :)
01:17:32 <athan> well, that's the trick
01:17:39 <athan> you have to use it once at the top level
01:17:53 <dramforever> saurabhnanda: no
01:17:59 <dramforever> that's another thing
01:18:12 <athan> foo :: forall m. ...; foo = let bar :: m -- same `m`
01:18:19 <saurabhnanda> great - thanks
01:20:23 <roxxik> athan: isn't deepOf some kind of combinator doing something like recursing through a data structure (i'm not sure what it's used for)
01:20:35 <athan> oh lord I have no idea haha
01:20:52 <athan> I was just entertaining the thought, I'm not a power user of lens yet :x
01:33:59 <tabaqui1> Can stack place executables in some specific directory?
01:34:32 <tabaqui1> If I just "stack build", it place them in .stack-work/build/......
01:34:46 <tabaqui1> if "stack install" - ~/.stack/bin
01:34:52 <tabaqui1> it want neither
01:35:01 <tabaqui1> *I want neither
01:37:09 <roxxik> there was some work-dir directive
01:37:44 <roxxik> it's called --work-dir
01:38:26 <maerwald> anyone knows about a resource that actually studies the likeability of bugs/complexity wrt stateful vs "stateless" (as in: functional, haskell, ...) programming? 
01:39:53 <maerwald> like... not just witty thoughts from a haskell fanboy :P
01:43:11 <kadoban> likelihood? Not many. Last I looked I didn't find much concrete that was convincingly well done.
01:46:24 <maerwald> I mean... how do you actually argue pro stateless (ignoring the fact that we can do a lot of stateful stuff), except for your own feeling as a programmer
01:46:45 <athan> maerwald: quickcheck for other language's asts :D
01:47:46 <athan> you could also measure productivity through sampling workplaces
01:48:03 <athan> through how much backtracking is needed, work-hours, progres to goal completion, etc
01:48:19 <saurabhnanda> I'm trying to see if my broadcastTChan code leaks memory. What's the easiest way to test that out?
01:48:38 <athan> because under that limelight, wouldn't all people be considered "the same", because this is a subjective study?
01:48:39 <merijn> maerwald: If you do any sort of formal analysis you quickly learn that state itself isn't so bad, but every bit of state you add exponentially increases the statespace you need to cover, making formal analysis exponentially harder too
01:49:07 <merijn> maerwald: Programmers reasoning about code is just sloppy and ad hoc formal reasoning, so suffers from the same exponential blow up
01:49:12 <athan> saurabhnanda: You can do some heap profiling, but there's a small cost iirc, you have to be clever with it
01:49:18 <merijn> maerwald: From which it follows that stateful code == hard to reason about
01:49:38 <merijn> maerwald: And then from "hard to reason about" leads to "hard to use without introducing errors"
01:49:39 <athan> and I _think_ threadscope only registers time allocated.. right?
01:50:24 <merijn> saurabhnanda: tbh, with the amount of time you've invested on mailing lists I would recommend just reading Simon Marlow's book on Parallel and Concurrent Haskell and looking at the implementation of TChan :p
01:50:42 <merijn> saurabhnanda: The entire implementation is like 50 lines
01:55:12 <maerwald> merijn: yeah, I guess that would be an angle... any resources popping up in your head?
01:56:34 <merijn> maerwald: Not any in the sense of studies, as most studies on programmer productivity are...flawed at best, to put it mildly
01:56:53 <merijn> maerwald: Although, I actually do remember a rather pragmatic study on formal methods in a real world system
01:57:28 <merijn> "Software Engineering with Formal Methods: Experiences with the Development of a Storm Surge Barrier Control System"
01:58:28 <merijn> maerwald: It's an analysis of the use of formal methods during the Delta Works project in the Netherlands
01:59:42 <merijn> The main conclusion of the engineers was "We don't think formal methods caught/prevented any problems, but thinking about and making the system amenable to formal analysis DID prevent lots of issues"
02:04:53 <maerwald> interesting, that's surprisingly practical
02:16:34 <dramforever> Is *that* why the type system of Haskell doesn't prevent mistakes but you write less buggy code?
02:17:56 <mmm_> I am looking for remote paid job. Anyone have something please send me. 
02:18:41 <quchen> Type systems can increase confidence in the code, but proving something *correct* is utopic.
02:19:04 <quchen> A bad type system doesn’t let you prove much.
02:19:14 <quchen> Improve it, and you get a good type system. That lets you prove things.
02:19:41 <quchen> Proving means proving that there are properties that hold within the type system.
02:19:50 <merijn> dramforever: I'd say that purity does that
02:19:52 <quchen> Climbing the ladder: is the type system even sound?
02:20:05 <quchen> Who verifies that? The inventor? People studying it?
02:20:06 <merijn> dramforever: The type system both enforces purity and catches trivial errors to save you from wasting brain cycles on them
02:20:23 <merijn> dramforever: Humans have limited power, best conserve it for the important bits
02:20:30 <quchen> Okay, so everyone who uses the system thinks it’s sound. Is mathematics sound? (We don’t know) Is the implementation sound?
02:21:04 <merijn> quchen: Checking the implementation is hard :p
02:21:23 <quchen> In summary, Haskell lets you write less buggy code because it feels that way on multiple different levels, and we haven’t found many counterexamples.
02:21:51 <quchen> It’s like writing tests that don’t find many counterexamples, but in a much more principled way.
02:23:08 <quchen> merijn: Not sure what kind of »hard« you mean, but I’m sure there’s a point where Gödel ruins everything, as usual
02:24:00 <merijn> quchen: I meant that "I'm implementing a system from a paper, but not sure whether I'm actually implementing it, because implementation details make that hard to see" :p
02:24:10 <merijn> Gödel isn't really an issue here
02:24:28 <merijn> As many languages throw out completeness early on anyway
02:24:37 <merijn> As in, not everything is expressible
02:24:46 <quchen> Oh sure! »Is my system sound« requires you to have a metatheory within you can prove things, and when that metatheory becomes all-of-math then you need to prove math sound
02:25:13 <quchen> Suppose we did that, the next step is proving your processor sound, and that requires QFT to be sound
02:25:38 <quchen> And all of a sudden you need to have quantum gravity (soundly) to show that »a + b = b + a« is correct for integers
02:27:53 <quchen> The worst part about this is that Gödel is provably right, so we’re eternally doomed. :-S
02:28:37 <quchen> »One day I’ll be dead and this will all be somebody else’s problem« – arianvp’s shirt :-)
02:28:55 <merijn> quchen: Not necessarily!
02:29:09 <merijn> The universe/law of physics might turn out to not be Turing-complete
02:29:38 <merijn> So then we can at least be sure from the hardware on up :p
02:30:32 <noan> Does there exist a decent/recommended dev env for windows or would I be better off with a VM?
02:31:06 <quchen> I’d go with a VM if I could not run Linux natively.
02:31:57 <noan> I'm planning to use it as a server backend for a game, the game being developed on windows. Haskell Platform a shit then?
02:32:06 <merijn> noan: If you have Windows 10 I think you could try the beta linux compat layer, I heard GHC should now work with that? Also, I suppose it depends on what you're used too, SPJ works on GHC from Windows all the time, so
02:32:23 <tabaqui> roxxik: thanks
02:33:13 <noan> @merijn, what's spj? and yeah I'm on ten. I can look into it
02:33:13 <lambdabot> Unknown command, try @list
02:33:28 <merijn> noan: Simon Peyton Jones, one of the main GHC devs :)
02:33:38 <noan> oooh, gotcha
02:34:04 <noan> sorry, I'm sort of doing this as a haskell learning thing at the same time, so I'm ignorant of a great deal
02:34:31 <merijn> I'm too used to unix tools like grep/find/etc., so for me Windows wouldn't work. If you're used to working on Windows already, I think it'd be fine
02:34:59 <merijn> noan: Really 90% of what I need is a shell and an editor, so just powershell and whatever editor you're used too should work
02:35:08 <noan> I prefer linux as well, but I can make do. Cygwin for grep etc
02:35:41 <merijn> noan: In that case a VM would be reasonable. VirtualBox works pretty well on the desktop
02:56:06 <dramforever> merijn: I've found that creating types and types and types really helps
03:36:38 <old1101> hello, can anybody tell me the (initial) trace of this infinite data? http://lpaste.net/8285575703118741504
03:40:40 <merijn> old1101: Note that the recursive call in interleaveStreams keeps switching the order of arguments
04:04:30 <orzo> i have a long-running haskell program.  I let it run for 5 hours and it reached "45%" memory usage according to "top" on linux.  I stopped it and restarted and now it is 0.4%.  My system has 8gig of ram.  I wasn't using the ram for anything else though, so is this just normal ghc gc behavior?
04:04:58 <orzo> or is it far more likely i have a leak in my code?
04:05:05 <orzo> a very slow leak heh
04:05:52 <cocreature> orzo: sounds like a memory leak
04:06:18 <merijn> It depends
04:07:09 <merijn> tbh, it's almost impossible to say *especially* if you're using top for info, because top reports all sorts of things which, while accurate, don't mean what people think they do
04:07:27 <orzo> yeah, i have a hard time understanding top
04:07:38 <orzo> i was looking in the "%MEM" column on linux
04:08:11 <merijn> tbh, top on OSX doesn't have that, so no clue what it reports
04:09:20 <merijn> Is it RES, VIRT, shared, wired, private, COW, etc.
04:09:48 <cocreature> iirc it’s RES
04:10:22 <orzo> in one of top's interactive dialog pages, it describes %MEM as RES: "* %MEM    = Memory Usage (RES)"
04:10:26 <MarcelineVQ> RES divided by total physical memory
04:10:49 <merijn> That makes a leak more likely, but really you want to run a profiling version and check the heap report
04:12:03 <cocreature> ~4gig in 5 hours is also not that slow. depending on the memory usage you expect, running it for 15min can be enough to find the problem
04:28:41 <reactormonk> Where exactly do I find aeson documentation?
04:29:17 <reactormonk> Ah, hackage as usual.
05:01:01 <reactormonk> In a case/of statement, how do I match against variable content? E.g. case num of pi -> ...
05:02:12 <lyxia> Best you can do is a guard.  case num of _ | num == pi -> ...
05:02:40 <lyxia> though if you're just matching a number it's not much better than "if"
05:02:47 <reactormonk> kk, thanks
05:04:30 <jophish> reactormonk: also be careful about matching against Floating point numbers like that
05:04:44 <reactormonk> jophish, just an example, actually using json
05:04:51 <jophish> cool, no worries then :)
05:04:57 <reactormonk> ... without any floating point magic
05:13:48 <tabaqui1> why List length works with O(n) asymptotic?
05:14:20 <tabaqui1> it's common operation and can be improvement with additional 4 byte of memory
05:14:34 <tabaqui1> *bytes
05:14:42 <maerwald> 4 bytes?
05:14:47 <tabaqui1> Int32
05:14:53 <tabaqui1> oh, + pointer
05:14:58 <M2tias> maerwald: update a field that contains the length
05:15:02 <M2tias> tabaqui1: less error prone?
05:15:02 <tabaqui1> dunno, not much, anyway
05:15:12 <maerwald> M2tias: what's the length of [1..]?
05:15:12 <lyxia> tabaqui1: but if you don't need it you're wasting work.
05:15:21 <M2tias> tabaqui1: also, what maerwald just said
05:15:25 <M2tias> maerwald: inf?
05:15:40 <tabaqui1> f.e. or..
05:15:53 <tabaqui1> "length returns the length of a finite list as an Int. "
05:16:08 <tabaqui1> (from documentation)
05:16:20 <jophish> What was that package called which allows one to use haskell expressions easily from the cli?
05:16:35 <jophish> something like: foo '++ "hello"'
05:16:52 <jophish> to append "hello" to something on stdin
05:16:55 <M2tias> tabaqui1: yeah, but it gets very complicated. only finite lists can be calculated beforehand and then what is finite?
05:17:11 <dibblego> length = map (const ())
05:18:11 <lyxia> tabaqui1: that would also break the uniformity of representation of haskell data types.
05:18:16 <karroffel> > finite
05:18:18 <lambdabot>  error:
05:18:18 <lambdabot>      • Variable not in scope: finite
05:18:18 <lambdabot>      • Perhaps you meant one of these:
05:18:24 <karroffel> [1..] isn't finite
05:18:29 <tabaqui1> > 1 / 0
05:18:29 <karroffel> so it returns "bottom" (which means it doesn't really return)
05:18:32 <lambdabot>  Infinity
05:18:32 <merijn> jophish: interact?
05:18:40 <tabaqui1> lyxia: Infinity, yes
05:18:46 <MarcelineVQ> karroffel: ​3> finite
05:19:09 <tabaqui1> *oh, M2tias: i mean
05:19:31 <karroffel> Ah I forgot about lambdabot
05:19:56 <tabaqui1> lyxia: what's the uniformity?
05:20:02 <M2tias> > length [1..]
05:20:09 <lambdabot>  mueval-core: Time limit exceeded
05:20:18 <tabaqui1> there are overheads in data.map, hashmap and other
05:20:39 <tabaqui1> these types not in base, right, but can be included in the future
05:21:47 <reactormonk> Any examples for Generic on Aeson? I want to build an ADT with a "tag not found" class.
05:22:31 <Ferdirand> :t (++)
05:22:34 <lambdabot> [a] -> [a] -> [a]
05:23:29 <Ferdirand> oh well
05:23:35 <jophish> merijn: nah, it was a package. It took a string and evaluated it as though it was haskell, with a bunch of useful packages in scope
05:24:08 <vaibhavsagar> can I simplify sequence <$> traverse f t?
05:24:30 <merijn> :t traverse
05:24:30 <vaibhavsagar> it seems wasteful to traverse the structure twice
05:24:31 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:24:47 <roxxik> :t \f t -> sequence <$> traverse f t
05:24:50 <lambdabot> (Traversable t, Applicative f, Monad m) => (a1 -> f (m a)) -> t a1 -> f (m (t a))
05:24:54 <merijn> vaibhavsagar: eh, just do "traverse (sequence . f) t"?
05:25:34 <roxxik> :t \f -> traverse (traverse f)
05:25:37 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
05:26:18 <roxxik> :t \f -> traverse (sequence . f)
05:26:20 <lambdabot> (Traversable t1, Traversable t, Monad f) => (a -> t1 (f a1)) -> t a -> f (t (t1 a1))
05:26:29 <roxxik> no that's not quite it
05:26:48 <vaibhavsagar> that doesn't seem to work @merijn, thank you though!
05:27:32 <vaibhavsagar> this is the line I'm trying to simplify: https://github.com/vaibhavsagar/duffer/blob/master/src/Duffer/WorkObject.hs#L32
05:28:03 <vaibhavsagar> for posterity: https://github.com/vaibhavsagar/duffer/blob/2d2503f199538c7b36e10258982fe226a4813c00/src/Duffer/WorkObject.hs#L32
05:28:11 <roxxik> already seems pretty simple for what it's doing
05:28:50 <roxxik> oh surely you could use alaF Compose traverse f or similar... idk
05:29:08 <vaibhavsagar> it bothers me that it's doing two traverses, makes me feel like there's something I'm missing
05:29:51 <roxxik> :t alaF
05:29:53 <lambdabot> error:
05:29:54 <lambdabot>     • Variable not in scope: alaF
05:29:54 <lambdabot>     • Perhaps you meant one of these:
05:30:03 <vaibhavsagar> thanks though, it makes me feel better that it's not blindingly obvious to people here
05:30:04 <roxxik> :t ala
05:30:06 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
05:30:24 <roxxik> :t ala Compose
05:30:29 <lambdabot> error:
05:30:29 <lambdabot>     • Data constructor not in scope: Compose :: Unwrapped s -> s
05:30:29 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
05:30:45 <roxxik> i'll make a gist of it...
05:31:07 <vaibhavsagar> Thanks! I appreciate it :)
05:31:16 <roxxik> can we import Compose to lambdabot?
05:33:21 <quchen> :t Data.Functor.Compose.Compose -- roxxik 
05:33:23 <lambdabot> forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
05:33:53 <roxxik> ah k
05:34:04 <roxxik> do you need sequence in there or would sequenceA be ok too?
05:34:11 <roxxik> because Monads won't compose
05:34:17 <roxxik> :t sequence
05:34:17 <vaibhavsagar> I think sequenceA would work
05:34:19 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
05:34:20 <roxxik> :t sequenceA
05:34:23 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
05:34:35 <roxxik> :t \f -> getCompose . traverse (Compose . f)
05:34:37 <lambdabot> error:
05:34:37 <lambdabot>     Variable not in scope: getCompose :: f0 (t b0) -> c
05:34:37 <lambdabot> error:
05:34:54 <roxxik> :t \f -> Data.Functor.Compose.getCompose . traverse (Data.Functor.Compose.Compose . f)
05:34:56 <lambdabot> forall k (f :: k -> *) (g :: * -> k) (t :: * -> *) b a. (Traversable t, Applicative (Data.Functor.Compose.Compose f g)) => (a -> f (g b)) -> t a -> f (g (t b))
05:34:58 <quchen> ?let getCompose = Data.Functor.Compose.getCompose
05:34:59 <lambdabot>  .L.hs:164:14: error:
05:35:00 <lambdabot>      Not in scope: ‘Data.Functor.Compose.getCompose’
05:35:00 <lambdabot>      No module named ‘Data.Functor.Compose’ is imported.
05:36:35 <MarcelineVQ> goodness gracious
05:36:41 <MarcelineVQ> @let import qualified Data.Functor.Compose
05:36:43 <lambdabot>  Defined.
05:36:46 <roxxik> or lensy: auf (iso Compose getCompose) traverse f
05:37:10 <roxxik> :t auf (iso Compose getCompose) traverse f
05:37:12 <lambdabot> error:
05:37:12 <lambdabot>     • Data constructor not in scope: Compose :: s0 -> f0 b0
05:37:12 <lambdabot>     • Perhaps you meant one of these:
05:37:17 <vaibhavsagar> still haven't gotten my head around lenses
05:37:33 <Billifischmaul> Hi, I want to create a recursive parametrized data type, but I get this error: http://lpaste.net/8670056854719561728 What did I do wrong?
05:37:36 <roxxik> it saves you from wrapping and unwrapping manually ;)
05:37:53 <vaibhavsagar> I've tried a couple of times
05:38:01 <roxxik> :t auf (iso Data.Functor.Compose.Compose Data.Functor.Compose.getCompose) traverse f
05:38:03 <lambdabot> forall k (f :: k -> *) (g :: * -> k) (t :: * -> *) a b. (FromExpr (f (g b)), Traversable t, Applicative (Data.Functor.Compose.Compose f g), Show a) => t a -> f (g (t b))
05:38:27 <roxxik> where is the Show contraint coming from :O
05:38:41 <vaibhavsagar> maybe that's just GHCi?
05:38:43 <roxxik> :t \f -> auf (iso Data.Functor.Compose.Compose Data.Functor.Compose.getCompose) traverse f
05:38:46 <lambdabot> forall k (f :: k -> *) (g :: * -> k) (t :: * -> *) a b. (Traversable t, Applicative (Data.Functor.Compose.Compose f g)) => (a -> f (g b)) -> t a -> f (g (t b))
05:38:52 <roxxik> yeah... i forgot a parameter
05:39:31 <roxxik> and the iso is best in it's own definition so its even shorter
05:40:00 <roxxik> something like `auf composing traverse f`
05:40:47 <roxxik> bonus: it's only traversing once, because we go through both Applicatives at the same time ;)
05:42:30 <vaibhavsagar> my lens-fu is weak, but thank you for this!
05:43:25 <roxxik> then it is: `getCompose . traverse (Compose . f) $ t`
05:47:53 <erisco> lol the one thing I want... existential arrays... sbv doesn't support XD
05:48:28 <reactormonk> In Aeson, I want to provide a "fallback decoder" - what would I be looking for here? An Alternative instance?
05:52:09 <erisco> well, the Sudoku example fills in the quadratic inequalities, which is 1000 something of them, and it seems adequate
05:52:26 <erisco> lets see if it can take a few thousand more
05:55:22 <vaibhavsagar> awesome!
05:57:34 <Axman6> Billifischmaul: you need (FAE n) in AddE
05:59:51 <gargawel> Hi ! Given the following type family, which defines the type of functions taking n a's and returning a b:
05:59:53 <gargawel> type family NFun n a b where NFun 0 a b = b NFun n a b = a -> (NFun (n-1) a b)
05:59:57 <gargawel> Woops
06:00:21 <gargawel> better: https://gist.github.com/anonymous/32ff64c4127f663e0642674dd2d393f4
06:00:35 <gargawel> (UndecidableInstances, DataKinds and TypeOperators required)
06:01:01 <Billifischmaul> Axman6: oh, thanks
06:01:13 <gargawel> is there a way to define a function of type:  (b -> c) -> NFun n a b -> NFun n a c ?
06:01:22 <gargawel> (sort of fmap for NFun n a)
06:02:07 <gargawel> It would be kinda handful for an experimental DSL I'm trying to develop
06:02:57 <Axman6> might be possible with an intermediate type, like  type level list
06:03:05 <Axman6> a*
06:03:51 <roxxik> there was a similar question sometimes, somewhere and one solution was to convert NFun to a dependent vector and a function taking in this vector...
06:04:08 <Axman6> reactormonk: yeah, I believe alternative is defined for Aeson decoders
06:04:09 <roxxik> and then it's just a . away to apply a another function
06:04:32 <reactormonk> Axman6, "No instance for (Alternative ((-> Value))"
06:04:45 <reactormonk> Ehh, (Alternative ((->) Value))
06:04:49 <gargawel> Hmmm
06:04:51 <Axman6> reactormonk: looks like you're doing something wrong =)
06:05:19 <Axman6> if you share the code we might be able to help
06:05:27 <reactormonk> https://gist.github.com/reactormonk/500d0f444f5fa20e3d5804d9771a3afb
06:05:31 <gargawel> that's not entirely satisfying, I guess
06:07:04 <Axman6> reactormonk: parseJSON x = (generic...) x <|> (withObject ...) x
06:07:30 <reactormonk> Axman6, aww, no pointless tyle?
06:07:44 <reactormonk> Yeah, works. Thanks.
06:07:51 <Axman6> (<|>) <$> ... <*> ...
06:08:25 <Axman6> kinda surprised there isn't an instance Alternative b => Alternative (a -> b)
06:08:40 <reactormonk> -> means function, right? So I'm basically an application away?
06:09:04 <roxxik> gargawel: but it was defined by a ADT and not by a type family...
06:09:16 <Axman6> I don't understand the question but  I think the answer is yes :P
06:09:42 <reactormonk> oke ^^
06:09:52 <erisco> Axman6, wrong kind
06:10:06 <Axman6> erisco: eh?
06:10:14 <erisco> your suggested instance
06:10:27 <Axman6> it has kind * no?
06:10:31 <roxxik> gargawel: it was here (currently not loading) somewhere in the comments i think: http://www.twanvl.nl/blog/haskell/non-regular1
06:10:34 <erisco> that's right, no ;)
06:11:02 <Axman6> :t (<|>)
06:11:03 <gargawel> roxxik: I think just wrapping that NFun into a datatype should work and allow me to define the correct Functor instances, I'm trying that right now
06:11:04 <lambdabot> Alternative f => f a -> f a -> f a
06:11:08 <Axman6> oh right
06:11:11 <gargawel> (granted, that's pretty hackish)
06:11:14 <erisco> :t (<>)
06:11:14 <Axman6> Alternative is not Monoid
06:11:15 <lambdabot> Monoid m => m -> m -> m
06:11:46 <erisco> I forget this too
06:12:23 <Axman6> reactormonk: btw, you know know oauth implementations exist already right?
06:12:31 <roxxik> gargawel: look at this ;) it already has a functor instance: https://web.archive.org/web/20170116115943/http://twanvl.nl/blog/haskell/non-regular1
06:12:33 <reactormonk> Axman6, for wai?
06:12:47 <erisco> not sure why Applicative had to be a super class of Alternative
06:12:51 <Axman6> definitely for things on top of wai
06:13:19 <roxxik> gargawel: but it's a list of a's and a function consuming them
06:13:36 <reactormonk> Found one that's 3 years old
06:13:39 <erisco> sans the constraint, you cannot form an Applicative from an Alternative
06:13:40 <gargawel> roxxik: looking into this :)
06:13:57 <Axman6> I feel that Wai is probably the wrong level to be implementing oauth
06:14:13 <reactormonk> Axman6, oauth client
06:14:20 <reactormonk> Currently doing it on the servant level.
06:14:33 <reactormonk> No oauth flows.
06:14:41 <Axman6> oh right
06:14:41 <erisco> the point of sub classes is they are supposed to be an example of their super class
06:14:42 <gargawel> Ah, yes, that's pretty easy in that form
06:14:55 <erisco> otherwise you are just using inheritance for composition
06:15:01 <gargawel> roxxik: it doesn't look very good, though, which is important for a DSL...
06:15:30 <roxxik> just wanted to through some similar idea in here
06:16:43 <Axman6> reactormonk: so https://hackage.haskell.org/package/hoauth2 isn't suitable?
06:17:54 <orzo> Is there an IO action to instruct the runtime to perform a major garbage collection immediately?
06:18:08 <reactormonk> Axman6, according to the error type, I'd need said decoder anyway ^^
06:18:17 <ertes> orzo: performGC or performMajorGC from System.Mem
06:18:31 <reactormonk> The error type is a ByteString
06:18:34 <orzo> ertes: thanks
06:28:29 <ertes> gargawel: what's wrong with (->)?
06:30:38 <Darwin226> Is there a way to specify a stack.yaml file to use as a parameter to the stack executable?
06:31:30 <quchen> Darwin226: --with-yaml I think
06:31:42 <quchen> --stack-yaml.
06:31:59 <Darwin226> Ye, that works. Thanks
06:32:01 <gargawel> ertes: nothing, it's more a matter of enabling some syntax in a DSL. I'd like the users to be able to write things such as: scan @3 $ \x y z -> ...
06:32:08 <Darwin226> Isn't documented in the stack build --help though
06:32:33 <MarcelineVQ> it applies to most things so it's part of stack --help
06:32:51 <quchen> Darwin226: It’s a stack flag, try »stack --help«.
06:33:25 <ertes> gargawel: i'm pretty sure you can do it with (->) and without DataKinds/TypeApplications simply by using a type class
06:34:10 <Darwin226> quchen: you're right
06:34:30 <Profpatsch> How would you write it, if you have mf :: a -> b -> m c ; a :: m a ; and b :: b ?
06:34:49 <Profpatsch> That is the first element is monadic instead of plain.
06:34:54 <gargawel> ertes: maybe... I'm still in the exploratory phase :)
06:35:05 <Profpatsch> If mf was a plain function, I’d use <$> <*>
06:35:28 <Profpatsch> But there seems to be no nice application-like syntax for that?
06:35:57 <ertes> Profpatsch: cf <*> cx <*> pure y
06:36:09 <Profpatsch> ertes: Oh, that matches?
06:36:25 <ertes> Profpatsch: pure :: a -> m a
06:36:33 <ertes> that turns your 'b' into (m b)
06:36:48 <ertes> oh, wait
06:36:53 <ertes> your mf has the wrong type
06:37:00 <Profpatsch> Yeah
06:37:08 <Profpatsch> It’s a monadic functino.
06:37:12 <ertes> Profpatsch: join (cf <*> cx <*> pure y)
06:37:12 <Profpatsch> as in a -> m b
06:37:21 <quchen> do { a <- ma; mf a b }
06:37:26 <ertes> :t \cf cx y -> join (cf <*> cx <*> pure y)
06:37:28 <lambdabot> Monad m => m (a2 -> a1 -> m a) -> m a2 -> a1 -> m a
06:37:46 <ertes> err
06:37:48 <Profpatsch> a >>= flip mf b
06:37:49 <ertes> :t \cf cx y -> join (cf <$> cx <*> pure y)
06:37:55 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> a1 -> m a
06:38:02 <ertes> there we go
06:38:10 <lynn> What quchen wrote is nicest, I think
06:38:22 <quchen> O:-)
06:38:56 <lynn> in that I don't have to think about it! it's just there
06:38:58 <ertes> it's useful to know the join pattern though:  join . atomically $ …
06:39:28 <ertes> STM (IO a)  -- a very nice way to express transactions and reactions in one
06:39:29 <quchen> For running IO actions retrieved over a channel?
06:40:41 <ertes> quchen: not necessarily:  let go x = join . atomically $ … <|> pure () <$ takeTMVar v <|> … <|> go <$> someOtherTransaction <|> …
06:41:06 <ertes> it just lets you specify the reaction to each possible transaction right within it
06:41:36 <quchen> ಠ_ಠ Applicative syntax jungle
06:41:43 <ertes> do x <- takeTMVar v1; y <- takeTMVar v2; pure (print x y >> go …)
06:42:12 <roxxik> quchen: through bang notation or idiom bracket ontop ;)
06:42:23 <roxxik> quchen: throw*
06:42:45 <ertes> instead of:  result <- atomically (do x <- takeTMVar v1; y <- takeTMVar v2; pure (GotV1V2 x y));  case result of …
06:44:31 <ertes> quchen: (<|>) is infixr 3, everything else is infixl 4 =)
06:44:44 <ertes> that makes parsing applicative jungle easy enough =)
06:44:49 <Profpatsch> What’s the extension for having the same type variables in where clauses as in the signatures called?
06:45:01 <quchen> Profpatsch: Scoped type variables
06:45:02 <roxxik> ScopedTypeVariables
06:45:05 <Profpatsch> quchen: Thanks.
06:45:28 <Profpatsch> And why isn’t that the default? :)
06:45:44 <ertes> Profpatsch: history
06:46:02 <merijn> Also, not sure that's an ideal default
06:46:07 <quchen> forall isn’t even standard so it’d be hard to put that in
06:46:22 <ertes> merijn: why?
06:46:39 <merijn> ertes: Because then I'd have to invent unique type variables in all where clauses?
06:46:57 <ertes> merijn: no, you just need to bind them
06:47:00 <ertes> where f :: forall a. …
06:47:10 <ertes> that's a new 'a'
06:47:13 <quchen> ?quote first.26
06:47:13 <merijn> ertes: That's more typing, so also not ideal ;)
06:47:13 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
06:47:34 <ertes> merijn: well, you don't have to explicitly bind type variables everywhere, you know =)
06:47:53 <ertes> if you don't use forall, you get the usual behaviour
06:56:31 <maerwald> quchen: lol, why 26 :o
06:56:52 <merijn> maerwald: Because unicode letters are hard to type
06:57:00 <Profpatsch> ∫∀∃ℕℝ∂
06:57:15 <merijn> Profpatsch: Pretty sure the first of those aren't letters
06:57:42 <Profpatsch> merijn: http://neo-layout.org/index_en.html :p
06:57:43 <merijn> > map (\c -> (c, generalCategory c)) "∫∀∃ℕℝ∂"
06:57:46 <lambdabot>  [('\8747',MathSymbol),('\8704',MathSymbol),('\8707',MathSymbol),('\8469',Upp...
06:58:05 <Profpatsch> ιαενχλψγφ
06:58:11 <merijn> Those are letters, yes
06:58:32 <Profpatsch> > map (\c -> (c, generalCategory c)) "ιαενχλψγφ"
06:58:35 <lambdabot>  [('\953',LowercaseLetter),('\945',LowercaseLetter),('\949',LowercaseLetter),...
06:58:38 <Profpatsch> heh
06:59:06 <merijn> Yeah, I forgot you need to use text to get lambdabot to actually output utf-8
06:59:25 <Profpatsch> > fmap (\c -> (c, generalCategory c)) ("ιαενχλψγφ" :: Text)
06:59:28 <lambdabot>  error:
06:59:28 <lambdabot>      Not in scope: type constructor or class ‘Text’
06:59:36 <merijn> Profpatsch: No, on the Char
06:59:53 <Profpatsch> You mean pack it in a text string?
07:00:01 <merijn> > T.singleton 'α'
07:00:03 <lambdabot>  error:
07:00:03 <lambdabot>      Not in scope: ‘T.singleton’
07:00:03 <lambdabot>      Perhaps you meant one of these:
07:00:17 <merijn> > Data.Text.singleton 'α'
07:00:19 <lambdabot>  error:
07:00:19 <lambdabot>      Not in scope: ‘Data.Text.singleton’
07:00:19 <lambdabot>      Perhaps you meant one of these:
07:00:24 <merijn> hmm, odd
07:00:31 <merijn> No, I meant
07:00:39 <merijn> > "ιαενχλψγφ"
07:00:42 <lambdabot>  "\953\945\949\957\967\955\968\947\966"
07:00:43 <merijn> vs
07:00:47 <merijn> > text "ιαενχλψγφ"
07:00:50 <lambdabot>  ιαενχλψγφ
07:00:53 <merijn> :t text
07:00:53 <ggVGc> uhm
07:00:55 <lambdabot> String -> Doc
07:01:26 <ggVGc> I think there should be a breaking version of GHC where String == Text
07:01:27 <merijn> Show sticks to ASCII for Char, I think, so you end up getting unicode escapes
07:01:28 <ggVGc> once and for all
07:01:50 <merijn> ggVGc: Naah, I'd rather see base parameterised over string type using backpack
07:02:05 <ggVGc> okay, let's wait another decade
07:02:23 <merijn> ggVGc: Replacing String with Text now won't make things better >.>
07:02:37 <ggVGc> that's true
07:02:57 <ggVGc> the more I've used haskell, the more annoyed I've been by Prelude
07:03:03 <ggVGc> there's so much weird shit
07:03:18 <merijn> ggVGc: Make your own Prelude! With blackjack! And hookers!
07:03:22 <merijn> In fact, forget the Prelude!
07:03:27 <ggVGc> been contemplating using one of the prelude replacements
07:03:34 <ggVGc> but haven't taken the dive
07:03:59 <ggVGc> import Prelude hiding (...)?
07:04:08 <merijn> Unrelated question
07:04:10 <Profpatsch> ggVGc: Protolude is amazing
07:04:18 <ggVGc> Profpatsch: yeah, been looking at it
07:04:23 <Profpatsch> I’ve been using it and it takes away most of the pain.
07:04:29 <Profpatsch> Especially the toS function.
07:04:32 <merijn> If I have a long composition of '.' followed by a do block, how to nicely linewrap it?
07:04:38 <ggVGc> Profpatsch: but what dilemmas does it put you in when interfacing with libraries?
07:04:41 <ggVGc> maybe not much?
07:04:52 <Profpatsch> Introduces pain though, since print & show are rather polymorphic, so you have to annotate sometimes.
07:05:00 <Profpatsch> ggVGc: None at all.
07:05:29 <Profpatsch> To the contrary, it feels like stuff got easier since I started using it.
07:05:33 <ggVGc> Profpatsch: how much would you say your life in general has improved since you started actively using protolude?
07:05:45 <ggVGc> would you recommend it for children?
07:05:49 <Profpatsch> Basic programming tasks 50–80%
07:05:51 <Profpatsch> Yes, definitely.
07:06:15 <ggVGc> cool
07:06:17 <bwe> Hi, I want to read a csv file. For this, I wanted to try `readCSVFile` from http://hackage.haskell.org/package/csv-conduit-0.6.7/docs/Data-CSV-Conduit.html#g:1 . As it turns out, I cannot make the second parameter to fit that is of `FilePath` type. So, for instance `readCSVFile defCSVSettings "myfile.csv" `raises this error: http://lpaste.net/9045721241620578304 (myfile.csv does exist and is a 1 col `\n` 
07:06:23 <bwe> line separated file.
07:06:24 <ggVGc> I'll try it out for my next haskell project
07:06:25 <Profpatsch> Apart from the string polymorphism stuff you don’t have to much genericity.
07:06:26 <ggVGc> whenever that is
07:06:27 <merijn> Relatedly, how to linewrap long imports?
07:06:37 <Profpatsch> *too
07:06:48 <bwe> How can I read a CSV file seamlessly?
07:07:14 <Profpatsch> bwe: cassava
07:07:26 <Profpatsch> bwe: Depends on how much error handling you want.
07:07:45 <Profpatsch> For machine-generated csv you definitely want to use cassava
07:08:17 <Profpatsch> For hand-written you’d have to switch to the cassava stream-based module I think.
07:08:27 <Profpatsch> Because otherwise the errors are rather poor.
07:08:37 <Eduard_Munteanu> bwe, just enable FlexibleContexts
07:08:38 <Profpatsch> Or look at another csv package.
07:08:38 <ggVGc> bwe: are you sure your executable runs in the same working directory as your csv file?
07:08:44 <ggVGc> oh, wait, this is not a runtime error
07:08:50 * ggVGc backs
07:09:08 <Profpatsch> bwe: Oh, I missed that you are using a specific package.
07:10:48 <Cale> bwe: The error you posted just says to turn on FlexibleContexts
07:10:56 <Cale> bwe: Just do that ;)
07:11:35 <EvanR> enable FlexibleContexts and break the lever off
07:11:35 <ggVGc> afaik FlexibleContexts are pretty much always safe?
07:12:09 <merijn> ggVGc: Yes
07:12:18 <ggVGc> (except that one time when it isn't)
07:12:23 <bwe> How can I enable FlexibleContexts in ghci?
07:12:38 <Eduard_Munteanu> :set -XFlexibleContexts
07:14:16 <Cale> EvanR: For years, FlexibleContexts was simply enabled all the time in GHC until someone noticed that it didn't quite comply with what the Report said.
07:14:29 <bwe> Eduard_Munteanu: Thanks.
07:14:48 <bwe> So now I encounter http://lpaste.net/edit/9045721241620578304
07:15:19 <bwe> To me this approach of reading a CSV file is a little to complicated. Is it? Does it need to be?
07:15:55 <merijn> bwe: Conduit is specifically for *stream* processing, so this library avoids ever loading the entire file at once
07:16:15 <merijn> bwe: Which is more complicated than the "simple" read the entire thing approach, but means you can process very large files
07:17:10 <bwe> That's overkill for me. So first get it running, and then optimize it — to the worse ;).
07:17:29 <merijn> bwe: Right, but then you might be using the wrong library? :)
07:17:37 <Eduard_Munteanu> bwe, v <- readCSVFile defCSVSettings "wkzs.csv" :: IO (Vector String)
07:18:50 <Eduard_Munteanu> Then you can print v or whatever.
07:20:05 <bwe> Eduard_Munteanu: Not in scope: type constructor or class ‘Vector’
07:20:28 <bwe> http://hackage.haskell.org/package/csv-conduit-0.6.7/docs/Data-CSV-Conduit.html does not link Vector to any other location.
07:22:26 <glguy> bwe: someone updated the docs manually without having vector's docs installed
07:23:07 <EvanR> Cale: bah bureaucracy
07:25:32 <Eduard_Munteanu> bwe, import Data.Vector should do
07:27:17 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
07:27:22 <merijn> I wish GHC had fallthrough/multi-patterns like OCaml :\
07:27:27 <Cale> bwe: Generally, you'll have a much harder time with ambiguity if you're trying to write things line by line into GHCi, since it can't look at how you're going to use the results of an operation to decide what the types are.
07:28:06 <ertes> bwe: use :seti to enable extensions in GHCi, otherwise you're changing how files are interpreted
07:28:36 <ertes> bwe: to enable it for a module, use the following above the first non-comment of your module file:  {-# LANGUAGE FlexibleContexts #-}
07:29:31 <bwe> Cale: I agree. So I wanted to try out the switches of csv-conduit lib intending to transferring the working pieces into a file. Which approach would be better?
07:30:31 <merijn> bwe: I almost always code inside a file and then have ghci in a separate window and do ":l file.hs" and ":r" to load/reload the code
07:31:53 <ggVGc> I tried writing code directly in ghci for about 3 minutes before I stopped that forever
07:31:55 <bwe> merijn: Okay, I did so a couple of times in the past. So I will do exactly this from now.
07:32:17 <ertes> bwe: i have a file ~/src/var/test.hs that i open whenever i need to do a quick experiment…  it's just easier than typing stuff into GHCi, if only to have a real editor instead of GHCi's haskeline
07:32:47 <ertes> if you have GHCi integrated into your editor, that's even more convenient
07:33:08 <sync> Hi. Im having trouble with practice exercise. Any idea how to make prime number tuble (by 3) list
07:33:25 <bwe> ertes: So, which editor do you use?
07:33:26 <ertes> sync: could you elaborate?
07:33:33 <ertes> bwe: emacs with haskell-mode
07:33:56 <merijn> bwe: I'd guess the majority here is split evenly between emacs and vim
07:34:03 <nitrix> bwe: vim with hdevtools is also great.
07:34:28 <bwe> nitrix: I'll try that before learning emacs.
07:34:55 <sync> priTubListBy3 ==> [(2,3,5),(7,11,13),...] - end result shoult be something like that..
07:34:58 <bwe> merijn: I wonder why there has not emerged a distinct haskellian approach, since.
07:35:08 <ertes> sync: what have you tried so far?
07:35:11 <nitrix> bwe: It used to be quite complicated to setup, but I've re-done it recently and it was flawlessly easy.
07:35:14 <merijn> bwe: If you're already comfortable with vim then just vim + hdevtools or ghc-mod works great
07:35:32 <ertes> bwe: the same reason why there is no distinct C++ian approach =)
07:35:45 <merijn> bwe: I basically have a split-screen terminal, half vim, half ghci and that's all I use
07:35:52 <ertes> some prefer emacs, others vim, and those are by far not the only ones
07:36:06 <bwe> merijn: Sounds familiar to me ;).
07:36:33 <nitrix> I let vim find the type/syntax errors, but I too, have a split screen with my editor and GHCi.
07:36:36 <EvanR> half vim, half ghci, half regular shall
07:36:43 <EvanR> shell
07:36:46 <ggVGc> half functioning
07:37:59 <jophish> I'd like to serialize Language.Haskell.TH.Exp if possible, has anyone done this before?
07:38:31 <jophish> I could go down the whole tree deriving ToJSON/Serialize/any other generic machinery
07:38:47 <jophish> but obviously that's a little horrible.
07:39:21 <qmm> ertes: (Int -> Bool :: *)  is a a concrete type, a value of that type, which is a function, takes an argument, but the type itself doesn't
07:39:35 <qmm> ertes: why does the type not take an argument?
07:39:56 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
07:40:27 <merijn> qmm: Time for my usual complaint that "concrete type" is an ill-defined term and should not be used :)
07:40:29 <roxxik> jophish: generically derive via Generic/Typeable? (just guessing)
07:41:44 <jophish> roxxik: the annoying thing about that is that I have to derive it for every type in L.H.TH
07:41:56 <jophish> perhaps I'll use haskell-src-exts instead
07:42:00 <qmm> the type of functions from Int to Bool
07:42:42 <merijn> qmm: Well, why do you think there should be any relationship at all between whether a type takes an argument and whether a value of that type does?
07:43:15 <qmm> from https://wiki.haskell.org/Concrete_data_type (the first sentence has a grammar error) "A concrete data type is an opposite of an Abstract data type. "
07:43:23 <qmm> s/an/the
07:43:30 <bwe> Hm. No instance for (CSV Data.ByteString.Internal.ByteString String) arising from a use of ‘readCSVFile’. -- what does it mean?
07:43:35 <merijn> qmm: Ugh, time to check whether I have a wiki account
07:44:15 <qmm> merijn: i'm regurgitating what ertes told me last night. maybe he was making it simplistic so that i can reach enlightenment
07:44:56 <qmm> glguy and ertes have been very, *very* patient with me the past couple of nights. figure i'd give this matter my full attention at least once in the morning time
07:45:08 <merijn> qmm: ertes should know better :p The problem is that we essentially have multiple categories of types: 1) 'Int' 2) 'a', 3) 'Maybe', 4) 'Maybe Int', 5) 'Maybe a', and people who throw around the term 'concrete type', seem to never agree which of those types are concrete and which are not
07:46:10 <sync> ertes - infite prim calculation and limited list to tuple.. but not bouth together
07:46:27 <merijn> qmm: There's essentially 2 axes, 1) monomorphic vs polymorphic, monomorphic being the opposite of polymorphic, so 'Int', 'Maybe', and 'Maybe Int', are all monomorphic types and 'a' and 'Maybe a' are polymorphic
07:46:27 <Eduard_Munteanu> bwe, it means it doesn't support decoding to a Vector of Strings, but you could use ByteString instead.
07:47:22 <Eduard_Munteanu> bwe, wait, no, look at these instances here: http://hackage.haskell.org/package/csv-conduit-0.6.7/docs/Data-CSV-Conduit.html#t:CSV
07:47:44 <merijn> qmm: The second axis is the kind of said type. The kind of types that can have values is '*', but others can have other types, so 'Int :: *', 'Maybe a :: *', 'Maybe Int :: *', 'Maybe :: * -> *', and 'a' would normally default to '*', but could in theory be any kind
07:48:09 <merijn> qmm: Anyway, back to your question, so we have 'Int -> Bool' which is a monomorphic type of kind *
07:48:38 <merijn> qmm: And your question is 'why does a value of that type take an argument when the type does not?', right?
07:49:18 <qmm> merijn: correct
07:49:41 <merijn> qmm: Right, so my first question is: Why do you think those two facts are related at all? :)
07:50:14 <qmm> merijn: because ertes told me so
07:50:35 <qmm> ..and he was playing off glguy helping me out
07:50:51 <qmm> and nobody grabbed a pitchfork while they were talking
07:51:17 <merijn> qmm: You're sure you didn't misundertand what he said? Because it's actually impossible to have a value that takes an argument when it's type takes one
07:51:40 <qmm> that is certainly possible
07:51:43 <qmm> i'll take another look
07:51:49 <merijn> qmm: Specifically because values can only ever have types with kind '*'
07:51:58 <qmm> 01:49 < ertes> (Int -> Bool :: *)  -- it's a concrete type…  the type of functions from Int to Bool
07:52:01 <qmm> 01:50 < ertes> a *value* of that type (which is a function) takes an argument, but the type itself doesn't
07:52:01 <merijn> In other words, values never have types that take arguments :)
07:54:43 <qmm> merijn: all of this is related to me asking about (,) e and not understanding kinds it seemed
07:54:44 <merijn> bleh...turns out proper foreign key constraints are a hassle when scraping data in a random order...
07:54:55 <bwe> Eduard_Munteanu: I don't understand how to use `class CSV`. Neither `CSV`, `r` nor `s` are used in the examples 1 and 2.
07:55:42 <merijn> qmm: For the sake of avoiding lets avoid using (,) (since it's the same for the type AND the value)
07:55:55 <merijn> qmm: Let's introduce "data Tuple a b = MkTuple a b" <- with me?
07:56:39 <Eduard_Munteanu> bwe, you don't need to use it directly, but you need to know what sort of result you can expect from decoding. It should probably be a Vector (Row ByteString).
07:57:00 <qmm> merijn: yeah
07:58:02 <merijn> qmm: Right, so the starting point is '*' which is the kind of all types that have values, so 'Int :: *', 'Bool :: *', etc.
07:58:24 <qmm> merijn: there has been most likely some confusion on my part in distinguishing between  a -> a :: * and (->) :: * -> * -> *
07:58:52 <qmm> Int :: *, Maybe Int :: *, etc. ok
07:59:02 <qmm> Maybe being * -> *
07:59:04 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
07:59:06 <bwe> Eduard_Munteanu: Now, it works.
07:59:15 <Eduard_Munteanu> Nice.
08:00:41 <qmm> Tuple being * -> * -> *
08:01:00 <qmm> easy to spot since it's similar to Either
08:01:27 <merijn> qmm: The problem is that we have two different -> there :)
08:01:33 <qmm> oh
08:01:47 <merijn> qmm: You have "(->)" the type , which has kind "* -> * -> *"
08:02:02 <qmm> right
08:02:06 <qmm> i can follow
08:02:06 <merijn> qmm: But the '->' in '* -> *' is a completely different '->'!
08:02:14 <merijn> Because that one is a kind
08:02:33 <merijn> And has zero relation to the type version of '->'
08:02:37 <sync> Hi. Has anyone little time (in pm) to help haskell beginner join 2 functions
08:02:47 <merijn> qmm: Maybe in an ideal world we'd used ~> for kind level ->
08:02:48 <qmm> merijn: yep, that definitely isn't clear to me
08:03:07 <merijn> So you'd get 'a -> a :: *' and '(->) :: * ~> * ~> *'
08:06:02 <merijn> And as a result we get (assuming 'a :: *') '(->) a :: * ~> *'
08:06:45 <merijn> Similarly, 'Tuple :: * ~> * ~> *' while 'MkTuple :: a -> b -> Tuple a b'
08:08:21 <merijn> qmm: Still following?
08:08:41 <qmm> yeah
08:10:40 <merijn> qmm: Does that explain things or are you still confused about something?
08:11:58 <reactormonk> I've got an Either a b from a library, now I'm adding another possible error case c, how should I do this?
08:12:26 <reactormonk> Currently I'm adding a new data type with has two types, either a or b, and a type alias with a new Either.
08:18:35 <merijn> reactormonk: What are a, b, and c?
08:18:47 <reactormonk> merijn, a and c are error types of some sort, b is a value
08:19:07 <merijn> Can't you make a sumtype for 'a' and 'c'?
08:19:21 <reactormonk> that would be a new sum, right?
08:19:25 <reactormonk> ehh new data
08:20:03 <merijn> yes
08:25:38 <qmm> merijn: what does it mean for a kind to be inhabited?
08:27:07 <merijn> qmm: A type is inhabited if there exists at least one value of that type (in Haskell 'bottom' is a value of every type, so every type is inhabited, which makes Haskell both Turing complete, as well as unsound as a logic). By extension, a kind is inhabited if there is at least one type of that kind
08:27:35 <merijn> qmm: As far as I know, not every kind is inhabited, at least not in Haskell without extensions
08:28:07 <EvanR> or with extensions
08:28:32 <EvanR> data Void -- data kind Void, no types
08:28:43 <qmm> thank you
08:28:50 <glguy> undefined only inhabits types with kind *, rather than all types,
08:29:00 <merijn> glguy: Ah, true :)
08:29:04 <Cale> Well, it doesn't on its own make Haskell Turing complete, but Turing completeness is an obstruction to avoiding that :)
08:29:06 <merijn> Fucked up my own pedanticism :)
08:29:39 <qmm> i think i've reached enlightenment, i'll wait for glguy or ertes to quiz me and prove my understanding to be incorrect
08:29:55 <merijn> Ok, let's rephrase
08:29:57 <EvanR> hehe, add bottom to cause turing completeness
08:30:07 <EvanR> like a secret ingredient
08:30:18 <merijn> 'bottom' inhabiting everything is a necessary, but not sufficient, precondition for being Turing complete
08:30:23 <EvanR> "you used ... what?!"
08:30:58 <merijn> Presumably you can have bottom inhabit everything without being Turing complete, but you can't be Turing complete without bottom inhabiting everything
08:31:15 <EvanR> we will require an example
08:31:40 <merijn> EvanR: The trivial language that has only a single value, 'bottom' has bottom inhabiting every type, but is not Turing complete
08:32:08 <EvanR> languages have values?
08:32:13 <merijn> Thus, 'bottom' inhabiting every type is not a sufficient condition for Turing completeness. QED.
08:32:42 <merijn> EvanR: Yes, never heard of Sapir-Whorff? *stops trolling with outdated linguistics*
08:33:00 <EvanR> exactly what is the trivial language with bottom in every type but isnt turing complete
08:33:15 <hodapp> what's wrong with Sapir-Whorf?
08:33:31 <merijn> hodapp: Besides having been discredited for several decades, you mean?
08:34:00 <reactormonk> how do I make a literal ByteString?
08:34:18 <merijn> reactormonk: Depends on how literal you want to ;)
08:34:28 <reactormonk> as in ghci
08:34:34 <glguy> Without extensions, you don't. You can use OverloadedStrings, however, to make a latin1 encoded bytestring of your string literal
08:34:45 <glguy> You can use pack to construct one from a list
08:34:49 <merijn> reactormonk: "Data.ByteString.pack :: [Word8] -> ByteString"
08:35:10 <merijn> glguy: What makes you say latin1 encoded?
08:35:12 <hodapp> merijn: we're talking about the Star Trek episode where the one character become super-smart, right?
08:35:38 <merijn> hodapp: I don't do Star Trek, so I have no clue wtf you're talking about :)
08:35:42 <EvanR> > "ab¢" :: ByteString
08:35:45 <lambdabot>  error:
08:35:45 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
08:35:45 <lambdabot>      Perhaps you meant one of these:
08:35:46 <glguy> merijn: the haddock
08:36:09 <EvanR> hodapp: nth degree
08:36:15 <hodapp> EvanR: ehhh?
08:36:23 <EvanR> thats the name of the episode
08:36:24 <Cale> reactormonk: If you're only concerned with ASCII characters, it may be convenient to turn on OverloadedStrings, at which point you can use a string literal as a ByteString -- but if your literals have non-ascii characters in them, you'll want to use Data.Text and something like encodeUtf8 (from Data.Text.Encoding)
08:36:41 <merijn> glguy: No, it's just dropping codepoints higher than \255, which just happens to include latin1 by sheer coincidence
08:36:45 <reactormonk> Cale, got it, thanks.
08:36:51 <Cale> reactormonk: and of course, if it's not text at all, then using pack directly is probably more convenient
08:37:02 <glguy> merijn: It's certainly not coincidence that unicode was defined like that
08:37:22 <merijn> glguy: No, but it is that ByteString is :p
08:37:39 <glguy> No, this is the documented intention of the .Char8 module
08:37:50 <EvanR> latin1 only matters for higher than 127 lower than 256, not higher than that
08:39:06 <merijn> Documented is not the same as "design", your use of the word "encoded" implies (to me), that ByteString uses some form of encoding from String, while it's really doing "filter ((<=255) . ord)"
08:39:25 <EvanR> it is definitely being encoded
08:39:27 <glguy> I'm not sure what your point is
08:39:33 <EvanR> ord is an encoding function
08:39:35 <glguy> but I don't think it matters for the question
08:44:20 <Profpatsch> What is the current recommended way of creating a simple stack around e.g. IO?
08:45:09 <EvanR> [IO a]
08:45:24 <Profpatsch> Err, have to go to the train.
08:45:40 <Profpatsch> Will continue the question in 15min. :p
08:57:06 <merijn> Right, time for a game of "how do I make this nicer?"
08:57:31 <merijn> I have 'requireAttr "value" >>= fmap Just . decimal' which looks awful
08:57:43 <merijn> Any suggestions on how I can rewrite it less sucky?
08:59:37 <jophish> merijn: fmap Just . decimal =<< requireAttr "value" -- for a start
08:59:54 <jophish> then you don't have to read it backwards and forwards
09:00:10 <jophish> you could replace '.' with '<<<'
09:00:31 <merijn> It's unfortunate that <$> binds tighter than >>=
09:00:41 <haskell277> yes hello
09:00:51 <glguy> Just <$> (decimal =<< requireAttr "value)? do-notation?
09:00:54 <merijn> Else I could've done 'Just <$> requireAttr "value" >>= decimal'
09:00:54 <haskell277> ye, i'm trying to install LLVM through Cabal
09:00:57 <haskell277> is not working
09:01:01 <haskell277> send hekp
09:01:02 <haskell277> help*
09:01:07 <haskell277> @everyone
09:01:07 <lambdabot> Unknown command, try @list
09:01:20 <merijn> glguy: do notation turns a short thing into two lines, I thought about the <$> before, but it's not great
09:01:37 <pavonia> haskell277: "is not working" is not a helpful problem description
09:01:53 <glguy> merijn: there's always ; for one-liners
09:02:01 <haskell277> "cabal: At least the following dependencies are missing: llvm-general >=3.5.0.0", why is this happening?
09:02:24 <glguy> haskell277: Paste the command you're running and all the output to http://lpaste.net
09:02:37 <dolio> You could even `value >>= \x -> Just <$> decimal x` if you think that looks better.
09:03:08 <merijn> haskell277: Well, do you have llvm installed?
09:03:10 <jophish> merijn: I wouldn't bat an eye at "fmap Just . decimal =<< requireAttr "value""
09:04:17 <haskell277> yes
09:04:19 <haskell277> fixed it
09:04:19 <haskell277> http://lpaste.net/351629
09:04:24 <haskell277> didn't fix it
09:04:29 <haskell277> put it in ther
09:04:30 <haskell277> e
09:05:06 <glguy> haskell277: You haven't installed the kn package's dependencies, and "cabal run" doesn't install dependencies
09:05:08 <haskell277> I've gotten "llvm-general-pure >=3.5.0" to work, but it's missing some things found in the non-pure
09:05:16 <glguy> You can "cabal install --dep" to install the current package's dependencies
09:06:23 <haskell277> right
09:06:30 <haskell277> this is what happens when I try to install
09:06:31 <haskell277> http://lpaste.net/351630
09:06:43 <haskell277> there's something with my llvm-config
09:07:08 <merijn> haskell277: Looks like you have a version of llvm that's too new
09:07:23 <haskell277> hm
09:07:26 <haskell277> how do I fix that?
09:08:43 <Profpatsch> merijn: err, how about Just <$> (requireAttr "value" >>= decimal)
09:08:58 <geppettodivacin> You can sandbox your build by using 'cabal sandbox' and then rerunning 'caball install --deps' and 'cabal install'
09:09:07 <merijn> Profpatsch: Yeah, that's looking like the most acceptable
09:09:23 <haskell277> right right
09:09:39 <Profpatsch> Most Haskellers forget that parens *do* have value in making it easy for the eyes. :D
09:09:57 <merijn> Profpatsch: I said acceptable, not good :p
09:10:00 <haskell277> hm
09:10:06 <bitemyapp> Cale: fair enough
09:10:18 <Profpatsch> As long as it’s not more than two or maybe three depths of parens.
09:10:35 <haskell277> how does sandbox work?
09:10:48 <Profpatsch> And you can’t spell “infix operator” without “paren” :P
09:11:53 <geppettodivacin> haskell277: It will install dependencies in .cabal-sandbox in your current directory instead of using your system-wide installed libraries.
09:14:20 <haskell277> right
09:14:21 <haskell277> now this
09:14:21 <haskell277> http://lpaste.net/351631
09:14:26 <haskell277> tried doing sandbox
09:15:07 <tsahyt> Hello. I've got some bindings to a C library. You can register a callback function with it and during its calculation this callback function can be called from several threads. It works fine when I only use it with one thread, but with more than one it tells me "schedule: re-entered unsafely" and suggests changing a foreign import. There are some 150 or so imports though, and I was wondering whether there
09:15:09 <tsahyt> was some good way to find out which one to look at
09:15:16 <Profpatsch> Okay, back to my question from before: 
09:15:34 <Profpatsch> What is the current recommended way of creating a simple stack around e.g. IO?
09:16:00 <Profpatsch> I can either do ReaderT Env (IO a)
09:16:07 <Sync26> hi. Is there any good guide for signature to function
09:16:26 <Profpatsch> Or use something like (MonadIO m, MonadReader Env m) => m a
09:16:44 <Profpatsch> I have seen the second version kind of often recently.
09:17:00 <glguy> Profpatsch: You can make a newtype for your simple stack and provide the exactly operation you want that type to support
09:17:05 <Profpatsch> For the first kind of pattern I’d define a newtype, yes.
09:17:11 <glguy> exposing the mtl constraints is a mess
09:17:28 <Profpatsch> glguy: You think? The stack codebase is based on it for example.
09:17:28 <glguy> If you need constraints it's better to make constraints specific to the problem you're solving
09:17:40 <glguy> Profpatsch: Yeah, it's a bad example
09:18:15 <Profpatsch> glguy: You think the stack code is bad Haskell?
09:18:23 <lyxia> Sync26: What does that mean
09:18:24 <glguy> exposing mtl constraints is bad haskell
09:18:31 <haskell420> yes hello
09:18:38 <haskell420> I've got this problem: http://lpaste.net/351632
09:18:43 <haskell420> trying to install llvm-general
09:19:07 <Profpatsch> glguy: It looked to me like it’s a way to have something like extensible effects.
09:19:11 <tsahyt> glguy: why would those constraints be bad haskell?
09:19:21 <tsahyt> it really depends entirely on the usecase, doesn't it?
09:19:39 <geppettodivacin> haskell420: It looks like you're missing an external library. I would guess llvm requires some llvm development packages.
09:19:43 <geekosaur> haskell420, it's what the error says. you are missing some or all of the C libedit
09:19:45 <geppettodivacin> Check the docs to see what it requires.
09:19:53 <haskell420> libedit
09:19:55 <haskell420> hm
09:19:58 <haskell420> should I install
09:19:58 <Profpatsch> tsahyt: What’s a good use case for one or the other?
09:20:01 <glguy> Profpatsch: its much better to define your own extensible effect classes specific to the problem being solved
09:20:03 <haskell420> llvm-dev or something?
09:20:18 <geekosaur> it's not part of llvm
09:20:32 <glguy> MonadReader and MonadState exposing get/put or ask are rarely the right abstraction
09:20:38 <glguy> they are implementation details
09:20:39 <geppettodivacin> haskell420: Try libedit-dev
09:20:42 <Profpatsch> glguy: Hm, my problem is that I’m using ghcjs-dom and you need the document and the window practically everywhere.
09:20:53 <tsahyt> Profpatsch: not hogging the MonadReader instance on any concrete stack is an argument against that version, because there can only be one. not forcing your users to use some specific stack would be one for the other.
09:20:57 <geppettodivacin> haskell420: It depends on which distro you're using, so I can't say for sure.
09:21:03 <haskell420> ubuntu
09:21:04 <haskell420> v good
09:21:11 <tsahyt> I mean most of the time it's probably a good idea to wrap your stuff in something specific
09:21:41 <tsahyt> for a public facing API that is. I think for actual internal implementation the constraints are preferable especially when you don't need all of them on every function.
09:21:48 <glguy> Profpatsch: If you want to provide those operations at multiple types, it would be a good idea to make a class specific to monads that provide documents and windows
09:21:52 <Profpatsch> So having a DOMT is a good idea?
09:22:27 <glguy> if you're consistently using one type, DomT is fine
09:22:52 <tsahyt> Is there something I can read about providing re-entrant functions via FFI, e.g. in callbacks?
09:23:20 <Profpatsch> And a document :: DomT Document function?
09:23:43 <geekosaur> tsahyt, it sounds like the binding was done with all "unsafe" bindings. unless you specifically know you can get away with it, they should all be "safe"
09:24:00 <tsahyt> geekosaur: I didn't actually annotate them with either unsafe or safe
09:24:10 <tsahyt> I thought it'd default to safe actually
09:24:26 <geekosaur> it should have
09:24:39 <tsahyt> e.g. this file https://github.com/tsahyt/clingo-haskell/blob/master/src/Clingo/Raw/Propagation.hs#L40
09:24:41 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html 
09:25:09 <geekosaur> but this isn't the first time that this has happened, so I wonder if this is a ghc bug that slipped under the radar somehow
09:25:47 <geekosaur> (people not specifying safe vs. unsafe and getting what acts like unsafe --- although the FFI is a bit overloaded, so who knows the default may be "semisafe" :/ )
09:26:11 <tsahyt> as far as I can tell it happens on the callback made from C to Haskell. wouldn't I have to annotate the wrappers then?
09:26:41 <tsahyt> or the function that starts the computation that invokes the callbacks
09:27:15 <geekosaur> it's when you go from Haskell to C that things need to be set up so that a call back into Haskell will work
09:27:29 <Cale> Marking an FFI call as "safe" is less efficient, but it guarantees to leave the Haskell runtime in a state that allows callbacks from the external code.
09:29:35 <tsahyt> I see
09:29:55 <Cale> "Unsafe" is usually a reasonable default actually -- it's just things that may want to call back into Haskell code that need to be marked safe.
09:30:31 <tsahyt> I suppose I also strictly need to link with -threaded?
09:30:53 <glguy> It's important that "unsafe" ffi calls are short, because they block the thread they run on from executing any more haskell code until they return
09:31:25 <Cale> ah, that too
09:31:53 <tsahyt> hmm, just using -threaded got rid of it
09:32:05 <tsahyt> or at least it looks like it. It's using multiple cores and I get no error
09:33:04 <tsahyt> Cale: how much of a performance difference does safe/unsafe make?
09:33:09 <glguy> The 2010 report specifies that the default foreign import is "safe"
09:34:09 <geekosaur> tsahyt, worth noting is that the threaded runtime is much better tested than non-threaded. so this could be a bug in non-threaded runtime
09:34:27 <tsahyt> why is non-threaded the default then anyhow
09:34:33 <tsahyt> I keep forgetting to enable -threaded
09:34:43 <geekosaur> ask the ghc devs >.>
09:35:17 <glguy> because for code that doesn't need the threaded runtime, the nonthreaded one is faster
09:36:45 <tsahyt> what's the sanest way to return from a monadic function early? right now I've got unless condition $ do ...lots of indented stuff...
09:37:06 <tsahyt> I'd really prefer a C-style return, like when (not condition) $ cReturn ()
09:37:21 <tsahyt> I suppose I'd have to use a ContT or something?
09:37:38 <geekosaur> it's hard to call direct use of Con tT sane :p
09:37:55 <tsahyt> but is there any other option really?
09:38:05 <geekosaur> generally we'd use a monad which has shortcircuiting (e.g. MaybeT)
09:38:48 <Cale> tsahyt: I just do what you're already doing
09:38:53 <tsahyt> hmm, I already use short-circuiting in this monad stack, but with different semantics. some functions from the C library require that if they return false no other functions of this and that sort are being called anymore in the callback
09:39:07 <Cale> I actually prefer it, because it's clear from the outset that possibly not all the code will run
09:39:30 <tsahyt> I think I'll just factor out the indented stuff and have GHC inline it back or so, that at least gets rid of this ugly floating indentation there
09:39:32 <Cale> Just by looking at the indentation level, you can get a better sense of the control flow
09:39:46 <tsahyt> I suppose that's true as well
09:39:48 <Cale> Or indeed, you can just pull the thing out into a separate definition
09:40:47 <ludvig> q
09:41:39 <haskell420> hello
09:41:53 <haskell420> i'm not sure about how to derive new type functors
09:41:54 <haskell420> http://lpaste.net/351633
09:41:58 <haskell420> this is my problem
09:42:11 <haskell420> my code looks like this: 
09:42:13 <haskell420> ```
09:42:15 <haskell420>  newtype LLVM a =   LLVM { unLLVM :: State AST.Module a        } deriving (Functor, Applicative, Monad, MonadState AST.Module)
09:42:17 <haskell420> ```
09:42:53 <Cale> tsahyt: A nice thing about not having C-style return is that it means the associativity law for Monad is satisfied, which in turn means that you can refactor do-blocks, chopping a bunch of stuff out of the middle of one without looking too hard at what's going on
09:43:25 <mmachenry> haskell420: Put {-# LANGUAGE GeneralizedNewtypeDeriving #-} at the top of your program.
09:43:29 <haskell420> Ah
09:43:30 <haskell420> right
09:43:34 <haskell420> thx a lot
09:43:39 <mmachenry> np
09:44:18 <Cale> If you introduce a C-style return with an implicitly specified continuation to return to, it's not legal to blindly chop the middle of a do-block out and pull it into its own definition
09:44:38 <Cale> (since you'd be implicitly returning to a different continuation then)
09:44:59 <tsahyt> most of the time, I prefer not having an actual return, but sometimes it just seems so useful
10:12:07 <bwe> Eduard_Munteanu: :t v -- gives me `v :: IO (Vector (Row ByteString))`
10:13:36 <bwe> Eduard_Munteanu: `v` is nothing but [["56.56145325"],["99.42876163"], ...]. I want to transform it in a list like [56.56145325, 99.42876163]. However, that seems to be a little tricky: It's not a list, it's an IO: http://hackage.haskell.org/package/base-4.9.1.0/docs/System-IO.html#t:IO. How do I start?
10:14:14 <Eduard_Munteanu> bwe, did you do let v = ...? You should use v <- ...
10:14:45 <bwe> Eduard_Munteanu: I didn't. May I ask you for the difference?
10:14:51 <codedmart> Where does EpochTime come from? This page mentions it but when you click EpochTime it results in a not found.
10:15:14 <bwe> Eduard_Munteanu: I mean I did `v = ...` and not `v <- ...`. I change to `v <- ...`.
10:15:16 <Eduard_Munteanu> @undo { v <- foo; f v }
10:15:16 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
10:15:21 <Eduard_Munteanu> @undo do { v <- foo; f v }
10:15:21 <lambdabot> foo >>= \ v -> f v
10:15:34 <Eduard_Munteanu> @undo do { let v = foo; f v }
10:15:34 <lambdabot> <unknown>.hs: 1: 23:Parse error: }
10:15:57 <pikajude> hmm, undo is really having a tough time
10:16:18 <bwe> Eduard_Munteanu: I still don't understand the differenc.
10:16:19 <Eduard_Munteanu> let v = foo; f v   is equivalent to    f foo
10:16:21 <geekosaur> for good reason
10:16:29 <glguy> @undo do { let {v = foo}; f v }
10:16:29 <lambdabot> let { v = foo} in f v
10:16:53 <geekosaur> remmeber that let also introduces layout, and if you are using braces in lieu of layout then you must use them in internal layout-controlled syntax as well
10:16:54 <Eduard_Munteanu> bwe, are you comfortable with IO and monads?
10:17:07 <bwe> Eduard_Munteanu: No. Completely new for me.
10:18:26 <bwe> Eduard_Munteanu: Current state is   readCSV.hs:10:3: error: parse error on input ‘<-’ Perhaps this statement should be within a 'do' block?
10:19:35 <Eduard_Munteanu> bwe, https://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
10:20:19 <dmwit> bwe: Are you using cassava?
10:20:31 <dmwit> If so, you probably just need to change a few type signatures here and there to get what you want.
10:20:36 <dmwit> Have you posted your code somewhere?
10:20:58 <dmwit> ?paste in case you haven't
10:20:58 <lambdabot> Haskell pastebin: http://lpaste.net/
10:21:24 <Eduard_Munteanu> They're using csv-conduit.
10:21:34 <lpaste> bwe revised “Conduit  readCSVFile”: “Conduit  readCSVFile” at http://lpaste.net/9045721241620578304
10:21:42 <bwe> dmwit: No. See ^^.
10:22:47 <Eduard_Munteanu> You need to wrap that stuff in a do block, unless you're typing it at the ghci prompt.
10:23:21 <dmwit> bwe: `v :: IO (Vector (Row Double)); v = fmap (fmap (fmap read)) (readCSVFile ...)`
10:24:30 <lpaste> Eduard_Munteanu annotated “Conduit  readCSVFile” with “Conduit  readCSVFile (annotation)” at http://lpaste.net/9045721241620578304#a351640
10:26:06 <Eduard_Munteanu> bwe, try that ^^
10:30:25 <Ainieco> hello
10:30:41 <Eduard_Munteanu> Hi, Ainieco.
10:30:59 <Ainieco> why [],(x:[]) and (x:y:xs) are non exhaustive patterns for [a] type?
10:31:40 <Ainieco> it's either empty or there is one element or two+?
10:31:56 <Ainieco> in (x:y:xs) xs could be [], isn't it?
10:33:45 <barrucadu> Ainieco: Those patterns are exhaustive
10:34:28 <dmwit> Ainieco: At a guess: you are defining a function in ghci, and put the clauses on separate lines. Each line overrode the previous one instead of extending it.
10:34:50 <dmwit> Ainieco: Try `:{` to start a multiline definition (and `:}` to end it).
10:35:10 <Ainieco> dmwit: ah, that was it, thank you!
10:47:14 <bwe> Eduard_Munteanu: That works. However, I want to understand `<-` notation.
10:47:29 <bwe> Eduard_Munteanu: v <- readCSVFile ... -- is `v` here an alias for the result of readCSVFile ... ?
10:47:47 <geekosaur> no
10:48:03 <geekosaur> hm. suppose depends on how you're thinking of those...
10:48:23 <geekosaur> <- roughly becomes >>=
10:48:50 <bwe> geekosaur: what's `>>=` ?
10:49:09 <bwe> So then, when do I want `<-` and when `=`?
10:49:22 <geekosaur> the "fun" part is that you're actually declaring a callback. there is no actual "result" happening; you are saying what should happen at some unspecified point in the future, not under your control
10:49:22 <bwe> <- in a do statement?
10:49:32 <geekosaur> = is exactly an alias
10:50:41 <EvanR> bwe: on the right of <- is an IO Foo, on the left is a Foo
10:51:12 <geekosaur> <- (really >>=) means "if/when this action is *executed* (not evaluated!) bind its result and do something with it". it looks like you are getting a Foo from an IO foo --- but this may not happen until some unspecified later time
10:51:45 <EvanR> it certainly doesnt happen when you merely look at the source code, or type it into the editor
10:51:54 <EvanR> but thats not the case in most languages
10:53:04 <bwe> geekosaur: executed means order in the do block? evaluation means calculated when some cascade of other functions really need the value? 
10:54:06 <EvanR> evaluation = the general decrypts his orders "attack at dawn", execution = the general attacks at dawn
10:55:02 <bwe> EvanR: Checked.
10:55:36 <geekosaur> bwe, have you ever programmed in Javascript? there is a lot of wrapping things in function(){} so that it will happen in the future in response to a server or user action; very little happens when the Javascript is actually read, it's all instructions waiting to be triggered by future conditions
10:55:57 <bwe> geekosaur: Never.
10:57:11 <bwe> geekosaur: Where do I see that I am declaring a callback?
10:57:44 <geekosaur> @undo do { x <- foo; y x }
10:57:44 <lambdabot> foo >>= \ x -> y x
10:57:47 <vapid> hi
10:57:57 <bwe> print v -- as v has since not been executed but print requires it, it will now be executed. Is that correct?
10:58:03 <geekosaur> the `\ x ->` is an anonymous function --- a callback
10:58:48 <geekosaur> "at some point `foo` will hopefully produce a value. if/when it does, perform this function on the value"
10:59:31 <bwe> Hold on, please, I can't follow.    y x -- function y is called with argument `x`.
10:59:54 <geekosaur> yes?
10:59:59 <bwe> x <- foo -- result of foo will be bound at some later point to x.
11:00:26 <geekosaur> which means foo >>= \x -> <something goes here>
11:00:30 <geekosaur> the something being `y x`
11:02:10 <bwe> foo >>= \x -- foo will be bound to x at some later point?
11:02:43 <geekosaur> `\x -> y x` is a function
11:03:01 <geekosaur> you're not saying do this now you're giving it a function to run at some point in the future
11:04:37 <bwe> x <- foo    to     foo >>= \x -> <something goes here>   confuses me.
11:04:41 <srhb> bwe: Perhaps it needs to be emphasized that (>>=) is a function, too (with foo and (\x -> y x) as its two arguments, in this case) if you're building the "dependency" in your mind.
11:05:20 <Ptival> hey #haskell, what is the 2017 way of interpolating "this is ${a} and this is ${b}"?
11:05:24 <bwe> srhb: where's the foo?
11:05:36 <srhb> bwe: It's an operator, the left hand argument is foo.
11:05:41 <srhb> foo >>= ...
11:05:46 <Ptival> I have searched and there are too many results http://hackage.haskell.org/packages/search?terms=string+interpolation
11:06:08 <glguy> bwe, suppose getAndPrintSomething :: IO (); getAndPrintSomething = getSomething >>= \x -> printSomething x ---- We've defined an action and named it "getAndPrintSomething". If this action is executed later it will do two things. First it will execute getSomething. Then it will execute the result of applying the function (\x -> printSomething x) to whatever the result of getSomething was
11:06:43 <sm> Ptival: same as last year I think - import Text.Printf (printf), 
11:07:12 <tsahyt> Ptival: depends on how involved and robust you need the solution to be. printf is nice, but has obvious type safety issues. but it does get the job done.
11:08:00 <bwe> srhb: Checked.
11:08:16 <tsahyt> just writing the thing out using ++ or <> also works of course
11:09:04 <joshsyn> why isn't haskell used much?
11:09:21 <Ptival> tsahyt: really, I am just tired of writing "this " ++ show a ++ " and this " ++ show b ++ " etc"
11:09:56 <Ptival> I don't care for any %d or fancy things, just want things to be "shown" and concatenated
11:10:02 <tsahyt> Ptival: printf is your friend then. printf "this %s and this %b etc" a b, for when a,b are strings.
11:10:06 <bwe> foo >>= bar -- bind foo to bar?
11:10:08 <srhb> bwe: And perhaps, to make the translation a bit clearer: `do { x <- foo; ... }` is the same as `foo >>= \x -> ...` 
11:10:10 <Ptival> tsahyt: ok
11:10:14 <Ptival> thanks!
11:10:17 <tsahyt> Ptival: when they aren't you'd need show still
11:10:23 <Ptival> yeah
11:10:28 <Ptival> that I can deal with
11:10:34 <srhb> bwe: No, that would be `foo >>= \bar -> ... `
11:10:35 <tsahyt> I wonder whether there's a formatter that can do that actually
11:10:49 <srhb> bwe: If you were considering `do { bar <- foo; ... }`
11:11:07 <MarcelineVQ> > fold ["this ", show a, " and this ", show b, " etc"] -- not much shorter :> often I find myself using intercalate with a list of things like this
11:11:10 <lambdabot>  "this a and this b etc"
11:11:30 <bwe> `do {bar <- foo; ...}` is equivalent to `foo >>= \bar -> ...`?
11:11:39 <srhb> bwe: Yes!
11:11:49 <sm> tsahyt: printf handles non-strings, no ?
11:11:51 <tsahyt> Ptival: "%v" apparently
11:11:59 <tsahyt> sm: yeah, but I had %s in the format string above
11:12:01 <glguy> tsahyt: There can't be with the current printf design (not that I know an alternative one that works). But you could perhaps add instances of PrintfArg
11:12:21 <tsahyt> what's the %v for then? the docs list v      default format          any type
11:12:40 <glguy> tsahyt: That'll only work for instance of PrintfArg, not "any" type
11:12:48 <glguy> which are things like: String, Int, Double, etc
11:12:58 <bwe> srhb: Oh, I've just seen you had written it earlier ;).
11:13:10 <srhb> bwe: Well, better that you arrive there on your own :-)
11:13:32 <tsahyt> glguy: ah right. why couldn't you have some instance Show a => PrintfArg a?
11:13:41 <tsahyt> other than overlapping instances
11:13:47 <glguy> tsahyt: It would overlap with all the existing instances
11:14:02 <tsahyt> newtyping doesn't help either, because then you might as well use show
11:14:27 <tsahyt> on a related note, is there a properly typesafe printf already?
11:14:46 <tsahyt> i.e. something that gives compile time errors for printf "%d" "string" etc
11:15:05 <glguy> It would have to use a more interesting type than String for the format
11:15:12 <glguy> like some kind of HList
11:15:23 <glguy> or template haskell
11:15:31 <tsahyt> yeah, quasiquoting would work I guess
11:16:06 <tsahyt> I suppose C compilers have a special case just for printf then?
11:16:13 <tsahyt> and related functions like scanf etc
11:16:21 <glguy> yeah
11:17:57 <glguy> tsahyt: Check out the "format" attribute https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes
11:23:06 <bwe> getAndPrintSomething :: IO (); getAndPrintSomething = getSomething >>= \x -> printSomething x -- getAndPrintSomething interacts with outside world as its type is `IO`. IO does return `()` which is an empty tuple, in other words there is no return value.
11:23:33 <Akii> (), Unit, is a value
11:23:39 <Akii> just not a very useful one
11:25:53 <bwe> Akii: Agreed.
11:26:58 <bwe> getSomething is bound to x. printSomething takes x as an argument. In other words: `printSomething getSomething` -- where is my mistake?
11:28:23 <c_wraith> bwe, if getSomething and printSomething are polymorphic, you have an ambiguous type error. 
11:28:33 <Akii> :t getLine
11:28:36 <lambdabot> IO String
11:28:38 <Akii> :t putStrLn
11:28:40 <lambdabot> String -> IO ()
11:28:45 <monochrom> I don't understand the question. Where was the actual code posted again?
11:28:55 <Akii> you're missing bind
11:29:06 <cloudhead> is there a way to know where a 'Exception: divide by zero' error comes from? ie: what file/line?
11:29:19 <Akii> :t getLine >>= putStrLn
11:29:21 <lambdabot> IO ()
11:29:46 <Akii> computeA >>= computeB
11:30:15 <bwe> Akii: That I do understand clearly.
11:30:26 <Akii> then I'm not sure :D
11:30:46 * Akii sneacks back into #haskell-beginners
11:32:28 <glguy> bwe: assuming 'getSomething :: IO Something' and 'printSomething :: Something -> IO ()', it would be a type error to apply printSomething to getSomething
11:32:39 <glguy> printSomething's type requires that it's applied to things with type Something
11:32:58 <glguy> but getSomething has type IO Something.   IO Something    does not equal   Something
11:32:59 <monochrom> OK, I take it that no one saw the actual code, ever.
11:33:32 <monochrom> I want to tell you a tale about a group of monks trying to understand elephants.
11:33:43 <bwe> monochrom: Go ahead: http://lpaste.net/9045721241620578304
11:34:15 <bwe> monochrom: I want to understand when I want `<-` over `=`.
11:35:45 <Sonolin> b <- getChar is equivalent to getChar >>= (\b -> ... )
11:35:52 <Sonolin> :t (>>=)
11:35:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:35:59 * bwe sneacks back into #haskell-beginners.
11:36:00 <monochrom> = is for definitions. <- is when you really mean >>=; >>= is for composing two actions. Once you believe this, there is pretty much no relation (therefore no ambiguity) between = and <-
11:36:36 <monochrom> Read my http://www.vex.net/~trebla/haskell/IO.xhtml for why you need >>= and/or think in terms of "composing two actions".
11:37:12 <Akii> bwe: don't if they help you here :P
11:45:23 <monochrom> And read my http://www.vex.net/~trebla/haskell/prerequisite.xhtml for what = means.
11:45:37 <bwe> monochrom: Your analogy of a radio reading a signal from the environment to propagate that to the loudspeaker that takes a signal and outputs sound, is revealing. In particular with regard to the better known programming languages. 
11:46:05 <tsahyt> About IO (). You can consider the () as a guarantee that the action actually returned I suppose. So there's at least some information in that ().
11:46:26 <bwe> tsahyt: True.
11:46:37 <bwe> getLine >>= putStrLn -- how do I read this correctly?    bind the output of getLine to putStrLn?
11:46:46 <glguy> tsahyt: How would you use that () as a guarantee?
11:46:59 <monochrom> I think my article explains that too?
11:47:38 <tsahyt> glguy: it's not very useful, I mean you could pattern match on it or just write () <- foo, but if foo never returns the pattern match never occurs either
11:47:49 <monochrom> I have doubts about your wording, because it means something else to some other people, but if it means the right thing for you then it is right for you.
11:48:33 <tsahyt> bwe: getLine >>= putStrLn is equivalent to getLine >>= \x -> putStrLn x. so >>= takes the output of getLine and uses it as input for putStrLn.
11:48:46 <tsahyt> it's quite explicit in the type of >>=
11:48:48 <tsahyt> :t (>>=)
11:48:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:49:13 <monochrom> Because I have doubts with "output".
11:49:23 <tsahyt> there's only one way to obtain an a for the function (a -> m b). so it *must* come from the thing on the left of >>=
11:49:30 <monochrom> What does getLine output? What does putStrLn "hello" output? See the conflict?
11:50:41 <tsahyt> monochrom: what would you call it? return value?
11:51:14 <monochrom> Usually "return value" works for most people. But it has its limitation too.
11:51:31 <monochrom> See my article for what I settled on.
11:51:40 <bwe> getLine >>= putStrLn -- propagate whatever getLine returns to putStrLn ?
11:52:56 <srhb> bwe: What would you call the version that binds the result of getLine to a name explicitly?
11:53:14 <srhb> bwe: Then work your way from that to a terminology for argument-less version.
11:53:48 <tsahyt> monochrom: how about IO String is an I/O action yielding a String when executed?
11:54:11 <monochrom> I think I can agree with that.
11:54:21 <srhb> yield is great because it's so vague.
11:54:23 <srhb> :-)
11:54:41 <monochrom> In the great picture I think that essay writing contests are vain.
11:55:02 <sedeki> do you guys recommend Haskell: From first principles?
11:55:16 <glguy> I've been recommending "Programming in Haskell"
11:55:18 <monochrom> There is no observable difference between keep improving wording and keep mincing words.
11:55:19 <tsahyt> I think about those things in a variety of different ways in day to day programming. Sometimes IO String is a String dependent on IO, sometimes it's an action yielding a String, etc.
11:55:47 <sedeki> glguy by Graham something?
11:55:51 <glguy> Hutton
11:55:54 <sedeki> right
11:55:58 <simendsjo> sedeki: I'm on my second readthrough and really like it. It wont be my only source to learn Haskell, but I find both the text, level, structure and excercises to be good.
11:56:18 <monochrom> But there is much observable difference between writing correct code and writing incorrect code, between correct predicting the behaviour of someone else's code and incorrectly predicting.
11:56:21 <sedeki> simendsjo why not your only source? to complex?
11:56:29 <sedeki> too*
11:57:10 <sedeki> simendsjo I have read RWH and LYAHFGG, didn't really get it. with this one, it seems like I have a shot
11:57:40 <sedeki> also the one by Graham Hutton... it's a bit too naive for me in some sense. I know how to program, just not functionally
11:57:42 <simendsjo> sedeki: It's 1200 pages, but it's still just showing the language and some basic patterns. There's too little on tooling, ecosystem, patterns and libraries. But for the language I like it.
11:59:27 <simendsjo>  sedeki: It's my second time trying to learn Haskell too :) I gave up while reading RWH the last time, but Haskell from first principles got me going again, and I've gotten much further this time. This book is working for me, and as I understand, plenty of others too.
11:59:32 <sedeki> simendsjo since I don't even know what a monad is yet, I'd rather go with 1200 pages covering the language
11:59:46 <sedeki> yeah
11:59:59 <sedeki> i think this might be *it* (the book where I get it)
11:59:59 <tsahyt> I wish people would stop getting hung up about the M word all the time when learning haskell
12:00:11 <sedeki> tsahyt sorry, but it is still true
12:00:28 <simendsjo> sedeki: Thats some of it's beauty - it explains from the ground up. I think that's very important when there are so many foreign concepts.
12:00:36 <sm> simendsjo: how about Haskell Tutorial And Cookbook
12:00:55 <sedeki> simendsjo  are you doing the exercies?
12:01:01 <monochrom> The 5th book you read explains it most clearly.
12:01:08 <NextHendrix> haskell from first principles is really great
12:01:17 <tsahyt> sedeki: my point is that you don't learn why monads are useful by reading about them a lot. people tend to get scared of these abstractions because they're.. well.. abstract. and they don't know what on earth this stuff would be good for.
12:01:22 <simendsjo> tsahyt: Thats probably because IO is something you see early on, which makes you trying to learn Monad. But the "documentation" you find doesn't explain all the other concepts which is useful.
12:01:46 <NextHendrix> theyre just monoids in the category of endofunctors :^)
12:02:08 <tsahyt> sedeki: instead they should just use them for a while. IO is a perfect example. haskell IO code looks a lot like code in any imperative language and as a beginner you can just treat it as such and develop some intuition for what is going on.
12:02:09 <sedeki> tsahyt yeah, i understand the frustration
12:02:18 <tsahyt> NextHendrix: yes. basically.
12:02:19 <simendsjo> sedeki: Yes, I'm doing the excercises and experimenting a lot. It takes a lot of time to learn, but I'm only able to sit a couple of hours a day tops.
12:03:47 <sm> btw it's interesting, recommending this book is like talking against a strong wind. Since noone else is talking about it yet, you tend to get no response
12:04:20 <sedeki> sm  the book you mentioned above?
12:04:32 <sm> ISTR finding the same when recommending HPFFP over LYAH a while back
12:04:36 <sm> sedeki: yup
12:04:48 <tsahyt> sm: I never heard of it
12:05:04 <sm> why not check it out ? it's real
12:05:22 <sm> and I think many folks will find it very good
12:05:39 <monochrom> There are more books than there are reviewers.
12:06:07 <tsahyt> sm: I just skimmed the table of contents. The cookbook part has some nice applications, I'll keep it in mind for when I come across such a task.
12:06:11 <monochrom> And there are fewer reviewers because there is less demand.
12:06:19 <tsahyt> but what I'm really looking for is a book on advanced type wizardry
12:06:38 <monochrom> And I infer that there is less demand for reviewers because I see no one offering a price for reviews.
12:06:44 <sm> ok, I would not have recommended it for that
12:06:55 <tsahyt> and something going in depth on some of the less common abstractions. Monads have been written to death, but say Profunctors etc haven't.
12:07:33 <tsahyt> also something going in depth about ways to encode strong invariants in types etc.
12:07:57 <tsahyt> unfortunately the knowledge out there is scattered over a myriad of blog posts and papers
12:08:09 <umib0zu> Are category theory questions appropriate here? I’m looking to learn how denotational semantics fit with category theory. I’ve also asked this question in #categorytheory if you want to move the discussion there.
12:09:06 <tsahyt> umib0zu: usually yes. the worst that can happen is that you won't get an answer
12:09:17 <monochrom> umib0zu: Look for "O-categories". It adds enough restricts so that each object and each arrow corresponds to things in denotational semantics.
12:09:45 <umib0zu> Are o-categories Operads?
12:09:50 <monochrom> No.
12:10:22 <monochrom> Each homset has to be a CPO or something.
12:10:29 <monochrom> The O is for order.
12:10:34 <umib0zu> Ok well I didn’t want to annoy you all with specifics
12:10:55 <umib0zu> I’m actually wondering, what’s the difference between denotational semantics and category theory
12:11:14 <monochrom> The difference between computings and oranges?
12:12:00 <umib0zu> I’ve never read about denotational semantics so you have to explain what computing and oranges mean.
12:12:07 <simendsjo> sm: Regarding "Haskell Programming from first principles", it has it's own website, haskellbook.com, and the IRC channel #haskell-beginners. It's still in early access (at full price), which is maybe why there's not a lot of talk about it. I've found it a very valuable book for learning Haskell from scratch though. But it's probably useless for those who already know quite some Haskell.
12:12:18 <monochrom> OK, you already know category theory.
12:12:45 <umib0zu> Haha well I’ve read a book on category theory. To say I “know” CT would be a wild stretch.
12:12:57 <dolio> Do you know what model theory is?
12:13:18 <sm> simendsjo: there's an extreme amount of talk about it
12:13:22 <monochrom> A denotational semantics is you pick a math set (or poset) and you say you have a function from programs to that set. The function has to be defined by structural recursion (structural on grammar).
12:13:23 <umib0zu> I ran the reddit reading group for going through CTFS. It basically told me 1. I don’t know anything. 2. I’m still a bad programmer.
12:13:58 <simendsjo> sm: Ah, just shows how little I'm involved in Haskell :)
12:13:58 * geekosaur pretty sure the only programmers that don't know that (1) and (2) are the *really* bad ones >.>
12:14:06 <sm> HTAC is the one not yet talked about; it's two months old
12:14:15 <sm> welcome :)
12:14:37 <geekosaur> (the ones that don;t yet know enough to realize how much they don't know)
12:15:37 <umib0zu> True. So are you saying a denotational semantic(s???) fits into a category? It sounds like you’re describing a poset and a functor from [Programs] to a Poset.
12:15:47 <monochrom> sm: what is HPFFP?
12:16:00 <sedeki> haskell programming: from first principles
12:16:03 <sedeki> a book
12:16:14 <monochrom> Oh, that.
12:16:39 <sm> because it's impractical to keep typing out these long similar-sounding names after a while :0
12:16:54 <umib0zu> monochrom that question was for you btw
12:17:12 <umib0zu> also, if I should just read an n-lab for it, please link it
12:17:18 * sm mentally catalogues: PIH, RWH, LYAH, HPFFP, HTAC..
12:17:29 <monochrom> Yeah but your IRC client probably has an "auto-correct-spelling" feature which really just means it has a lookup table for substring replacements.
12:17:54 <monochrom> So for example I set up mine to map yay to \∩/
12:18:17 <monochrom> You can probably set it up to map CCCP to Haskell Programming from First Principles
12:18:23 <monochrom> Also,
12:18:31 <monochrom> @quote monochrom CCCP
12:18:31 <lambdabot> monochrom says: in Soviet Russia, you have current-continuation-calls-procedure (CCCP)
12:20:00 <monochrom> umib0zu: When doing denotational semantics, you do not have to use a category. But sometimes you can, when it gives you the benefit of generality.
12:20:46 <suppi> does anyone know how to use lets encrypt's certbot keys with warp-tls?
12:21:05 <suppi> i got a privkey.pem and cert.pem
12:21:12 <umib0zu> monochrom hm… interesting
12:21:15 <umib0zu> so final question
12:21:25 <monochrom> If you have to talk about a family of posets, you could go category theory and say "I have a category, each object is a poset". Or you could stay ZF and just say "a family of posets".
12:21:51 <umib0zu> Hm… so should I have some understanding of denotational semantics before… reading GEB?
12:21:59 <suppi> but when i try to use them in warp-tls i get "no keys found"
12:22:09 <monochrom> If you have so many posets that you can't say "I have a set of posets", you can go category theory, or you can stay low-tech with "I have a class of posets".
12:22:43 <umib0zu> Ok
12:22:58 <monochrom> No, GEB is optional. GEB is one way to gain some experience in recursion. But any other way to gain experience in recursion is equally good.
12:23:19 <monochrom> But you do want to know recursion before you see why denotational semantics is so hard.
12:24:08 <umib0zu> Ah ok.I honestly am asking for a link to CT because I’m wondering how much to I have to dive into denotational semantics before understanding GEB.
12:24:23 <monochrom> Oh, that's the other direction.
12:24:39 <umib0zu> haha recursion I have an idea about that. I seem to be able to solve Polya’s coin problem in coding interviews so…
12:24:41 <monochrom> You won't need denotational semantics before GEB.
12:24:55 <dolio> What does any of this have to do with GEB?
12:25:27 <dolio> Isn't GEB a pop math book? Why would it have advanced mathematics as a prerequisite?
12:25:40 <monochrom> dolio, perhaps we're in an XYZ problem situation?
12:26:15 <monochrom> "I want to read GEB. I think I need prerequisites D, C, and R. Let me ask about D, C, and R in #haskell"
12:26:49 <monochrom> This is how rabbit holes are built in one day.
12:27:27 <monochrom> The logical conclusion being "you need to read GEB before you are ready to read GEB"
12:28:04 <monochrom> Or one of those "<a long story>  And the doctor says, why don't you get a dog?" jokes.
12:28:05 <geekosaur> GEB doesn't really have prerequisites, it's reasonably self-contained (because it was aimed at modern philosophers, most of whom don't have any math background)
12:28:40 <monochrom> But Hofstadler would be proud of my logical conclusion!
12:29:00 <monochrom> err Hofstadter!
12:29:42 <dolio> Is he into things that sound like logically unsatisfiable statements, but actually aren't?
12:30:04 <monochrom> I don't know. Probably yes.
12:31:01 <bwe> monochrom: there's a typo: Not very attractive, bu not too bad, actually.
12:39:42 <lynnard> I'm reading this fantastic paper The Essence of the Iterator Pattern; does anyone know if there is a copy of the haskell code for the examples inside somewhere?
12:40:56 <suppi> ok so i'm running exactly these commands at the bottom but still get "no keys found": https://github.com/yesodweb/wai/tree/master/warp-tls#warp-tls
12:49:29 <shapr> lynnard: link to the paper?
12:49:43 <MarcelineVQ> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
12:49:45 <chris_> hallo; what's a good library to perform http requests?
12:50:30 <umib0zu> monochrom, dolio: I watched a video on GEB and it seemed to talk about the idea of stones and rocks and I’m like… what programming language is this? Apparently the point is that you don’t need to talk about programming languages and that you simply need to understand there’s a way to describe how languages are equivalent.
12:50:48 <umib0zu> Essentially, that whole D F G thing is exactly what I thought.
12:51:13 <Rembane> Turing rocks?
12:52:02 <umib0zu> Yeah it’s when you’re bored on a beach so you create a turing machine with sand and your wits. I heard it’s the new programming language challenge they’re giving out at Google.
13:11:28 <ascinskii> exit
13:19:18 <monochrom> umib0zu: I have only read the book. But you understand that GEB is meant to be self-contained, so if it needs to talk about programming then it has to reinvent it from scratch, no?
13:19:45 <umib0zu> maybe? I’m not sure
13:20:05 <geekosaur> [25 20:27:43] <geekosaur> GEB doesn't really have prerequisites, it's reasonably self-contained (because it was aimed at modern philosophers, most of whom don't have any math background)
13:20:17 <monochrom> Also, Hofstadter really want to give you a feeling that recursion happens in surprising ways, so if he is to invent a programming language or a computing mechanism, he is going to be subtle.
13:20:25 <geekosaur> they don't have a programming background either. it has to build the whole thing up from zero
13:21:21 <monochrom> And since the book is also for the general public, it may as well use rocks papers shotguns.
13:21:39 <monochrom> Or basically any daily objects that don't intimidate anyone.
13:22:42 <monochrom> When he talks about axiomatic logic, he creates a letter game and calls it just a letter game, because "logic" is going to scare away people.
13:23:02 <monochrom> Similarly when he wants a scheme-like language.
13:23:51 <monochrom> And he has to throw in some Bach music because that's what attract people.
13:24:29 <monochrom> OK, that last one may be a stretch. He is probably genuinely fascinated by Bach's music.
13:25:35 <geekosaur> he is, because there's a strong thread of mathematics and self-referentiality in it
13:27:39 <monochrom> Also "logic" doesn't scare away people. I got that wrong. It is still in the same vein as trying to give you a surprising punchline later. He wants you to underestimate the letter game first, so that 500 pages later you will be surprised when you see that it's equivalent to logic.
13:29:31 <umib0zu> Interesting. So is it really pop sci?
13:29:58 <geekosaur> no
13:30:23 <umib0zu> Cause if I read it and find it’s more like A New Kind Of Science I will be annoyed.
13:30:44 <geekosaur> it's a compact "stealth" course in propositional logic and leading up to (a subset of) number theory
13:31:15 <umib0zu> wow that makes me not want to waste my time at all
13:31:21 <geekosaur> it's not a New Science by any means. but it is also not complete; it's bringing in the things he wanted to use in his argument
13:32:04 <geekosaur> GEB is an odd duck. its real purpose has nothing to do with math or programming, it's m,aking a *philosophical* argument and bringing in programming and math through the side door to support that argument
13:32:49 <geekosaur> they are presented correctly, not as some new-agey thing; and the way they are presented/introduced is fairly interesting
13:33:03 <shapr> I much enjoyed GEB.
13:33:15 <geekosaur> but then you hit the last couple chapters where the actual philosophical argument is made and go *wha*
13:33:51 <geekosaur> (you'll know you;re there when he starts talking about Lucas, the philosopher whose assertions he was countering)
13:49:54 <xpika> Is there a typeclass simply to take f a  -> a ?
13:50:52 <glguy> Comonad has f a -> a, and f a -> f (f a)
13:50:54 <monochrom> Comonad does more than that. So Comonad has that, but probably also a lot of things you won't want.
13:51:23 <monochrom> But Comonad is not common enough for people to further cut it up.
13:51:54 <monochrom> (Whereas Monad, even Applicative, is common enough that now people talk about splitting out the a -> f a part, "Pointed")
13:52:39 <xpika> how about a pointfree class ? 
13:53:12 <monochrom> You know what, you can invent it and see how many people adopt.
13:53:21 <monochrom> But I don't think anyone did yet.
13:53:54 <Tuplanolla> @hoogle Pointed
13:53:57 <lambdabot> module Data.Pointed
13:53:57 <lambdabot> Data.Pointed class Pointed p
13:53:57 <lambdabot> Compiler.Hoopl data Pointed t b a
13:55:21 <Tuplanolla> They're both defined in the first result.
13:55:32 <xpika> I found it. https://hackage.haskell.org/package/pointed-5/docs/Data-Copointed.html
13:55:35 <xpika> copointed
13:55:44 <monochrom> Ah nice
13:55:56 <xpika> can lambdabot import packages of hackage ? 
13:56:10 <monochrom> I think there is a way yes. I forgot the command.
13:56:11 <johnw> yay, extract without laws!
13:56:27 <barrucadu> What sort of operations are useful to write generically over a "copointed" class?
13:56:34 <Tuplanolla> @let import Data.Pointed as Pointed
13:56:35 <lambdabot>  .L.hs:115:1: error:
13:56:35 <lambdabot>      Failed to load interface for ‘Data.Pointed’
13:56:35 <lambdabot>      Use -v to see a list of the files searched for.
13:56:38 <monochrom> I think the parametricity is enough laws, yes?
13:56:54 <johnw> barrucadu: if 'f' is a predicate, then copointed means "there exists something that satisfies the predicate, here is the witness"
13:57:08 <johnw> (type predicate)
13:57:53 <monochrom> instance Copointed ((,) e) where copoint (_, a) = a  is perfect lawful, and not because of "lack" of laws.
13:58:18 <monochrom> not only lawful but also sensible and fully expected
13:58:46 <monochrom> And no one would do "instance Copointed Maybe" so don't you worry.
13:59:28 <ongy> you underestimate my stupidity
13:59:34 <monochrom> But now let's play with "instance HasDefault e => Copointed ((->) e)" teeheehee!
13:59:42 <dolio> data T a where TI :: T Int ; instance Copointed T where copoint TI = 5
13:59:58 <ongy> Monoid a => CoPointed (Maybe a) where copoint Nothing = mempy; copoint (Maybe x) = x
14:00:03 <johnw> monochrom: is there anything that can be Copointed but not be a Comonad?
14:00:15 <monochrom> I don't know!
14:00:27 <dolio> johnw: T is not a comonad.
14:00:32 <acowley> I don't like the choice of 5. Going to write a change proposal.
14:00:41 <johnw> dolio: thanks
14:01:04 <glguy> dolio: Could you make a package for that in case I need a 5 later?
14:01:12 <acowley> DRY
14:01:14 <dolio> Sure, I'll get right on it.
14:01:20 <monochrom> Make it 4.
14:01:27 <ongy> @src HasDefault
14:01:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:01:32 <ongy> @src Default
14:01:32 <lambdabot> Source not found. Sorry.
14:09:00 <dpakj> hey
14:09:06 <dpakj> i have a question regarding monoids
14:09:29 <johnw> give me two such questions, I'll give you one back
14:09:32 <dpakj> would it be true to say that "Endo" refers to the monoid of functions of type(a->a)
14:09:45 <johnw> correct
14:09:49 <dpakj> alright thanks
14:10:07 <dpakj> also another question, what do people mean when they say that a monad is a monoid on endofunctors
14:10:10 <johnw> functions of type a->a are monoids under composition and identity
14:10:18 <monochrom> hahaha
14:10:27 <dpakj> all functions of a-> a regardless of what a is is a monoid
14:10:28 <dpakj> right?
14:10:31 <johnw> yes
14:10:37 <dpakj> cool
14:10:58 <dpakj> so when people say a monad is a monoid over endofunctors
14:11:12 <dpakj> what category are the endofucntors mapping from/to
14:11:27 <johnw> in Haskell, the categeory of Haskell types and functions
14:11:36 <dpakj> there are monads like IO etc that take many different types right?
14:11:42 <dpakj> hwo can those be endofunctors?
14:12:01 <delYsid> Hmm, is there something like m () -> [a] -> m a that picks the element from the list according to how often m () matched?
14:12:02 <johnw> IO maps 'a', a Haskell type, to 'IO a', another Haskell type
14:12:07 <Tuplanolla> Looks like there's some confusion between endomorphisms and endofunctors, dpakj.
14:12:32 <johnw> delYsid: how do you determine "match" in that function?
14:12:37 <dpakj> so an endo functor is a endomorphism one kind higher?
14:12:44 <monochrom> "monoid on endofunctors" happens at the type level, unlike the Monoid class which happens at the value level
14:13:01 <Tuplanolla> Yes, but it also has some extra structure, dpakj.
14:13:19 <delYsid> johnw: m is a parser
14:13:28 <dolio> monochrom: I'm not sure that's accurate.
14:13:31 <dpakj> so whats the identity element of the monoid on endofunctors on "Hask"
14:13:43 <monochrom> Yeah, probably I got it wrong too.
14:14:09 <Cale> dpakj: In order to understand that, you need to understand what a "monoid object" in a category is -- ordinary monoids are monoid objects in the category of sets.
14:14:20 <johnw> dolio: have your parser return [()] or Int, then you can pick from the original list
14:14:35 <glguy> dpakj: Mostly when people talk about monads being monois in the category of endofunctor's they're repeating a phrase they've seen online and don't mean anything beyond that by it
14:14:40 <Tuplanolla> You might want to read or watch Bartosz Milewski's explanation of this, dpakj.
14:14:48 <dpakj> i cant understand anything that guy writes
14:15:02 <monochrom> So don't read that guy. Read Cale.
14:15:12 <johnw> dpakj: https://arxiv.org/abs/1406.4823
14:15:19 <Cale> dpakj: How much category theory do you know?
14:15:19 <ski> dpakj : "so whats the identity element of the monoid on endofunctors on \"Hask\"" -- it's `return :: Identity ~> m'
14:15:33 <Cale> Are you familiar with categories and functors? Natural transformations?
14:15:35 <dpakj> I know just bits and pieces on wikipedia
14:15:46 <dolio> Cale doesn't produce any easily accessible long-term things to read. :P
14:15:47 <ski> dpakj : `join :: Comp m m ~> m' is the "multiplication"
14:16:11 <Cale> dolio: lol, mostly interactive performance art from me
14:16:19 <dpakj> whait whats the type Identity and type m
14:16:23 <dpakj> in that definition of return
14:16:25 <ski> dpakj : `(~>)' here is defined by `type f ~> g = forall a. f a -> g a'
14:16:41 <monochrom> Wikipedia is an encyclopedia. Encyclopedia means every article assumes that you already have the prerequisite knowledge.
14:16:59 <dpakj> i havent found a decent free source on category theory
14:17:07 <ski> dpakj : and we have `newtype Identity a = MkIdentity a' and `newtype Comp f g a = MkComp (f (g a))' -- these are identity and composition of type (endo)functions (on `*')
14:17:20 <monochrom> Corollary being you won't have much luck quoting any sentence.
14:17:21 <johnw> dpakj: there are jokes in that statement you will somebody become aware of :)
14:17:24 <johnw> someday*
14:17:26 <delYsid> johnw: hmmm, length <$> many p, but how do I constrain that to the number of elements in my list to choose from?
14:17:40 <NextHendrix> dpakj: https://ptpb.pw/rxNE.pdf
14:17:57 <dpakj> thanks!
14:17:58 <johnw> delYsid: you'll need to use foldM instead of many p
14:18:05 <Cale> dpakj: It's not actually meant to be free, but I recommend Awodey's "Category Theory" -- available online from here: https://people.mpi-sws.org/~dreyer/courses/catlogic/awodey.pdf
14:18:12 <NextHendrix> i hoarde pdfs
14:18:16 <ski> dpakj : presumably johnw meant to address you, not dolio, four minutes ago
14:18:31 <johnw> ski: correct
14:18:36 <monochrom> pdf hording is an infectious disease.
14:18:45 <johnw> actually, I meant delYsid 
14:19:01 <johnw> NextHendrix: how big is your Hoarde?
14:19:08 <dolio> Cale: You might want to check out Tom Leinster's book and see how it is (I haven't looked yet).
14:19:14 <dolio> Since it's supposed to be free now.
14:19:58 <dpakj> so whats the identity functor
14:20:03 <johnw> NextHendrix: I have 9,054 PDFs in my Haskell database
14:20:04 <dpakj> is it a functor that just maps and objhect to itslef
14:20:39 <Cale> dolio: It's probably good, but I doubt it's aimed at as broad an audience as Awodey's
14:20:42 <johnw> davean: my own personal collection of the cross-section between Haskell and the Internet
14:20:54 * NextHendrix bows at the feet of johnw
14:21:07 <dolio> Cale: I don't know. The blurb he wrote for it sounded pretty broad.
14:21:10 <NextHendrix> not that big, i have a lot of 1000+ page textboots and whatnot
14:21:18 <NextHendrix> *textbooks
14:21:58 <Cale> dpakj: yeah, and every arrow to itself as well
14:22:15 <monochrom> "At the heart of this short introduction to category theory is the idea of a universal property, important throughout mathematics."  I like that sentence.
14:22:46 <Cale> dpakj: So, the first thing to understand is that given some fixed category C, the functors C -> C form the objects of a category, whose arrows are natural transformations.
14:22:59 <monochrom> And a couple of other sentences.
14:23:15 <Cale> dpakj: But not only is that a category, but it has some additional structure: we can also compose functors
14:23:41 <dpakj> Can you use a concrete category like Integer and repeat that statement
14:23:49 <monochrom> oh w00t Creative Commons license so you can fork it too
14:23:55 <Cale> How is Integer a category?
14:24:14 <Cale> You mean the ordering category, or one of the monoid ones?
14:24:28 <monochrom> w00t I can change notation!
14:25:27 <Cale> dpakj: Well, hang on, before we bother with any details, let me give you the really vague picture of what the monoid object phrase is referring to
14:26:01 <Cale> dpakj: So, what is an ordinary monoid? It's a set M together with
14:26:15 <dpakj> an operation
14:26:15 <Cale> 1) An element e in M which is the identity of the monoid
14:26:22 <dpakj> and identity
14:26:25 <ski> delYsid : can you use `zipWith const myList <$> many p' ?
14:26:30 <dpakj> so the set (Integer, +, 0) is a monoid
14:26:48 <Cale> 2) An operation *: M x M -> M called multiplication (which is required to be associative, and have e as its identity element)
14:27:08 <Cale> dpakj: Since we have our category theory hats on, we don't like talking about elements
14:27:22 <Cale> dpakj: So, we can rephrase this a bit first:
14:27:25 <dpakj> ok
14:27:32 <Cale> A monoid is a set M together with
14:27:56 <Cale> 1) A function  e: 1 -> M  (where 1 is a one-element set)
14:28:05 <delYsid> johnw: foldM?  I basically want this pattern: fmap (l !!) $ p *> (p *> (p $> 3 <|> pure 2) <|> pure 1), does foldM give me that somehow?
14:28:07 <Cale> 2) A function m: M x M -> M
14:28:23 <dpakj> can you explain
14:28:25 <dpakj> 1)
14:28:43 <dpakj> so lets say i have a function e 1-> m
14:28:48 <Cale> So, an element of M is basically the same thing as a function from a one-element set to M, which picks out our chosen element, yeah?
14:28:50 <dpakj> what does that look like for monoid of addition
14:28:59 <dpakj> how do you get from one element set to 0
14:29:25 <johnw> delYsid: foldM will let us build manyOr 10 p, to parse p 0-10 times
14:29:33 <dpakj> i thoguht it would be a function from a 0 element set to M
14:29:42 <dpakj> like [] -> 0
14:29:46 <dpakj> for adiditon
14:29:48 <ski> that contains no information
14:29:51 <dpakj> or [] -> 1 for multiplication
14:29:54 <Cale> There's exactly one function from a 0 element set to any set
14:29:55 <ski> there is only one such function
14:29:57 <dpakj> well isnt the identiy constant
14:30:02 <Cale> Let's give the unique element of 1 a name, say u
14:30:05 <Cale> So 1 = {u}
14:30:32 <Cale> Then the function here for Z will be e: 1 -> Z
14:30:33 <Cale> e(u) = 0
14:30:38 <dpakj> wait when you say a function from one element set to a
14:30:46 <dpakj> do you mean an arbitrary 1 element set
14:30:56 <Cale> yeah, it doesn't really matter which one element set you pick
14:30:57 <dpakj> or a function where the domain is one elemnt
14:31:02 <Cale> The domain is one element
14:31:05 <dpakj> ohhh
14:31:18 <dpakj> i was thinking it was a function that maps, [1] -> sopmething [2] -> something
14:31:27 <dpakj> ok that makes sense
14:31:36 <ski> delYsid : if you write `[] -> 0',`[] -> 1' (where `[]' presumably is meant to denote the 0-element set, the empty set, which is more commonly written as `{}'), then `0' and `1' there has to be *set* -- while you were intending to talk about *elements* `0' or `1', right ?
14:31:40 <ski> argh
14:31:42 <ski> dpakj ^
14:32:20 <ski> dpakj : did you confuse the `->' (function type arrow, or morphism arrow here) and the `|->' (maps-to arrow) arrows with each other ?
14:32:31 <dpakj> i have no idea what the second arro wmeans
14:32:33 <Cale> dpakj: Okay, so now, instead of sets, we're going to talk about functors
14:33:01 <Cale> and instead of functions, we'll have natural transformations between functors
14:33:09 <dpakj> can u explain natural transformation
14:33:15 <Cale> and instead of Cartesian product of sets, we'll have composition of functors
14:33:19 <dpakj> is ee that thrown around alot i thoguht it was just a function
14:33:19 <Ptival> has anyone had an issue where GHC.Prim was supposedly not exposing Any?
14:33:28 <ski> dpakj : in math, `x |-> ..x..' means basically the same as `\x -> ..x..' in Haskell, iow it describes a mapping that given any input, call it `x', produces the output `..x..' (some expression which may depend on / mention `x')
14:33:33 <Cale> and instead of the one element set 1, we'll have the identity functor (conveniently also commonly referred to as 1)
14:33:50 <glguy> Ptival: How are you determining that it's not being exposed?
14:34:06 <glguy> and on which GHC version are you trying?
14:34:25 <Cale> dpakj: I can explain natural transformations in a moment -- they're mappings of a certain sort between functors
14:34:33 <Cale> But let me get through the analogy
14:34:41 <Cale> So, what do we have?
14:34:49 <Cale> We have some endofunctor M: C -> C
14:34:51 <ski> dpakj : if you want to talk about some particular element of the domain (iow input type) being mapped (by some given function) to some particular element of the codomain (iow output type), then you can use `|->'. e.g. for the squaring function, we have `3 |-> 9'
14:35:02 <Cale> and we have natural transformations  e: 1 -> M
14:35:04 <Ptival> glguy: some other package complained about it. I believe I am using ghc-prim-0.5, I was trying to build constraints-0.8
14:35:09 <Cale> and m: M . M -> M
14:35:32 <Cale> (where . there is functor composition)
14:35:41 <Ptival> Not in scope: type constructor or class ‘Prim.Any’, Module ‘GHC.Prim’ does not export ‘Any’.
14:35:44 <Cale> So, in Haskell, natural transformations F -> G are rendered as polymorphic functions forall a. F a -> G a
14:35:46 <dpakj> i see ski thanks
14:36:12 <glguy> Ptival: I'm  able to build constraints-0.8 using ghc-8.0.2 which includes ghc-prim-0.5.0.0 . Could you paste more details about what you're seeing to lpaste.net ?
14:36:22 <Cale> So, the two things we're providing will become a polymorphic function forall a. a -> M a
14:36:32 <Cale> and a polymorphic function forall a. M (M a) -> M a
14:36:44 <Cale> which will be return and join respectively :)
14:36:48 <Ptival> glguy: will investigate a little. It seems I am using ghc-8.1.20161115, might be a transient issue
14:37:26 <dpakj> so
14:37:37 <Cale> So, natural transformations, what are they really?
14:37:38 <glguy> Ptival: Any time you're using a development version of GHC you should specify that when asking questions
14:37:46 <ski> dpakj : when you said "i thoguht it would be a function from a 0 element set to M","like [] -> 0","for adiditon","or [] -> 1 for multiplication" , "i was thinking it was a function that maps, [1] -> sopmething [2] -> something", it sounded like you were really thinking of which input value(s) a function maps to which output value(s), iow you probably ought to have used `|->' for that ..
14:37:48 <delYsid> johnw: I wish I'd see how :-)  But thanks for the pointer, maybe I am just too tired already.
14:37:59 <Cale> If we have two functors between the same pair of categories, say F and G are both functors C -> D
14:38:03 <glguy> Ptival: It looks like Any might be moving to GHC.Types 
14:38:07 <Ptival> glguy: yeah, I'm switching to 802, hopefully that was the issue
14:38:10 <Cale> Then a natural transformation F -> G consists of:
14:38:18 <dpakj> you are correct ski, im not used to the notation :O
14:38:29 <Ptival> glguy: yeah it seems so, I was following code from "Trees that grow"
14:38:34 <Cale> Er, I want a name for it
14:38:40 * ski nods
14:38:46 <Cale> Then a natural transformation eta: F -> G consists of:
14:38:55 <dpakj> Can you give a concrete example of natural transformation
14:39:03 <Cale> For each object X of C, an arrow eta_X: F X -> G X
14:39:03 <dpakj> using category of integer and string
14:39:05 <dpakj> or something like that
14:39:11 <Cale> dpakj: What categories are those?
14:39:22 <dpakj> they aren't categories?
14:39:38 <Cale> Well, they might be, but not normally
14:39:46 <dpakj> what are categories in haskell
14:39:49 <Cale> There are a few ways to turn them into categories
14:39:52 <dpakj> like examples other than "hask"
14:39:53 <johnw> delYsid: https://gist.github.com/dd15dff9dd81d91321337034c7b355f5
14:40:00 <johnw> delYsid: instead of foldM, I just wrote it using plain recursion
14:40:11 <Ptival> glguy: indeed, that was the issue, it works with 802.
14:40:21 <ski> dpakj : fwiw, the unicode symbol for `|->' is the symbol ⌜↦⌝ (or ⌜⟼⌝ if you want a longer version)
14:40:39 <dpakj> ah i see thanks
14:40:45 <Cale> ski: heh, I like the switch to unicode quoting ;)
14:40:56 <dpakj> ahhh so categories
14:41:48 <dpakj> Example category would be like: (1,2,3,4) and (\x -> x + 1 % 4)
14:41:49 <dpakj> ?
14:42:24 <dpakj> Example category would be like: (1,2,3,4) and (\x -> (x + 1 % 4) + 1)
14:42:35 <dpakj> ?
14:43:43 <dpakj> also, isn't the "hask" category incomplete if you can keep adding arrows to it?
14:43:53 <ski> dpakj : "what are categories in haskell" -- instead of picking types of kind `*' as objects, and functions between those types as morphism, forming a category, sometimes called `Hask'; you can pick objects as types of kind `* -> *' (e.g.), and as morphisms from an object `f' to an object `g', you pick functions of type `forall a. f a -> g a'
14:45:28 <Cale> dpakj: I don't understand your example categories
14:45:36 <Cale> dpakj: What are the objects and arrows of those?
14:45:41 <Cale> How are the arrows composed?
14:45:48 <dpakj> object is numbers 1, 2, 3, 4
14:45:54 <Cale> okay
14:45:55 <dpakj> arrow is the +1 mod 4 + 1
14:45:59 <Cale> hm?
14:46:11 <dpakj> take any object add one, mod 4 and then add one again
14:46:17 <Cale> and then what?
14:46:18 <dpakj> just one arrow
14:46:29 <dpakj> and composition is just composing that arrow with itself
14:46:30 <Cale> Okay, so there's exactly one arrow 1 -> 2
14:46:32 <dpakj> yea
14:46:34 <dpakj> 1 arrow
14:46:37 <Cale> and one arrow 1 -> 3
14:46:41 <Cale> and so on
14:46:55 <dpakj> well you could transform any object to any other one
14:47:02 <Cale> Or are there more?
14:47:02 <dpakj> by doing func(func(1))
14:47:03 <dpakj> etc
14:47:07 <ski> dpakj : a variant is to pick as objects types of kind `* -> *' that are endofunctors on `Hask' (possibly even requiring them to be instances of `Functor') (non-examples of such types would be e.g. `To b', defined by `newtype To b a = MkTo (a -> b)'; `IORef'; and `T', defined as `data T a where TI :: T Int' by dolio earlier. this last one is a GADT)
14:48:09 <ski> dpakj : "also, isn't the "hask" category incomplete if you can keep adding arrows to it?" -- it is defined to contain all the arrows that you *can* define which would fall under the definition of the collection of arrows in the category
14:48:16 <Cale> dpakj: So that's just the indiscrete category on {1,2,3,4} then?
14:48:21 <ski> dpakj : iow, the category also contains all future functions that you could define
14:48:48 <Cale> (there's exactly one arrow for any ordered pair of objects)
14:49:00 <dpakj> yea we can do tha ttoo
14:49:07 <Cale> Too?
14:49:12 <Cale> Isn't that what you described?
14:49:24 <Cale> Or did you intend for there to be fewer arrows somehow?
14:49:29 <dpakj> it was initially just a set of 4 numbers with modulo increment
14:49:31 <Cale> But there will have to be composites?
14:49:39 <dpakj> with modulo increment being the only arrow
14:49:52 <Cale> So, if there's an arrow 1 -> 2 and 2 -> 3, there must be at least one arrow 1 -> 3
14:50:04 <Cale> to serve as the composite of the first two
14:50:12 <glguy> dpakj: YOu don't get to provide a function, you have to provide arrows from one object to another
14:50:33 <dpakj> i see
14:50:34 <glguy> like literally this specific object to that object
14:50:41 * ski figures in dpakj's example, there's an endofunctor `func', and a natural transformation `succ : id -> func'
14:51:14 <dpakj> how is succ a natural transformation
14:51:22 <dpakj> which are the two categories
14:51:26 <ski> (`func' is defined as `\x -> (x + 1) % 4', iiuc)
14:51:30 <Cale> dpakj: Like, here's the canonical example of a category, Set: it has sets as its objects (all of them, or some suitable universe of them anyway)
14:51:55 <Cale> dpakj: and then given any pair of sets A, B, the arrows A -> B are the functions whose domain is the set A and whose codomain is B
14:52:03 <ski> dpakj : it's an endofunctor on your category with objects `1',`2',`3',`4', so that is both the domain and codomain category of the functor
14:52:13 <Cale> dpakj: and composition of arrows is function composition
14:53:37 <dpakj> So for Set
14:54:08 <dpakj> the type of A and B in that second sentence
14:54:19 <dpakj> do they comprise all the potential As and Bs in the universe?
14:54:25 <ski> glguy : i was thinking the category was to be generated from this collection of objects, and the morphisms that the natural transformation `succ' -- but on second thought, i suppose we'd not necessarily have `succ . succ . succ . succ = id', so by a free generation without extra laws, there'd be more than four non-identity arrows
14:55:14 <ski> .. so i suppose we *also* take `succ . succ . succ . succ = id' as a law/relation for the presentation of the category ?
14:55:17 <dpakj> and do all the arrows comprise all the possible mappings from A to B for all possible As and Bs in the universe
14:56:26 <ski> (sorry, s/four/eight/ .. i was forgetting the two arrows inbetween `1' and `4', and the two inbetween `2' and `3')
14:57:21 <ski> dpakj : "So for Set","the type of A and B in that second sentence","do they comprise all the potential As and Bs in the universe?" -- yes
14:57:31 <ski> dpakj : "and do all the arrows comprise all the possible mappings from A to B for all possible As and Bs in the universe" -- yes
14:58:57 <ski> dpakj : anyway, going back to "Example category would be like: (1,2,3,4) and (\x -> (x + 1 % 4) + 1)" -- i think this is possibly another misunderstanding
14:58:57 <dpakj> ah
14:59:55 <dpakj> yeah would appear to be wrong
14:59:59 <dpakj> since if thats the function
15:00:05 <dpakj> then there is an arrow between every pair of elements
15:00:06 <ski> dpakj : `\x -> (x + 1 % 4) + 1' (which i *think* you really intended to be `\x -> (x + 1) % 4', no ?) looks like it is describing a function/mapping/morphism of some kind
15:00:07 <dpakj> via composition
15:00:48 <dpakj> i mean we can think of it as the set (0,1,2,3) and use the function you described
15:00:53 <dpakj> the plus 1 makes it confusing
15:01:14 <dpakj> and its proibaly wrong
15:01:15 <ski> dpakj : since you shouldn't be talking about "innards of morphisms" in this way if you're thinking of stuff purely from a category theoretical perspective, i was *assuming* that you were describing an *(endo)functor* on this category
15:01:48 <dpakj> i honestly have very little concept of what an endo functor is
15:01:52 <dpakj> but from my current understand
15:01:57 <dpakj> its like a functor from sets to sets
15:02:01 <dpakj> or from hask types to hask types
15:02:19 <dpakj> also why cant integer or any concrete type be a category
15:02:21 <ski> dpakj : if you want to describe the arrows/morphisms/maps of the category, then you could be specifying for each one of them : (a) what is its domain object and codomain object ?; and (b) for each pair of composable arrows, which arrow is the composition of them ?
15:02:45 <lpaste> orzo pasted “Why does one version leak and not the other?” at http://lpaste.net/351645
15:03:33 <orzo> I've found a leak in my code that goes away if i use fix instead of forever to make an endless loop
15:03:52 <orzo> anyone have any idea on why that might be?
15:04:11 <lingxiao> hey all
15:04:19 <ski> dpakj : e.g. "Example category : objects are `1',`2',`3',`4, and arrows are `a_{i,j} : i -> j' for each possible object `i' and `j', where identity and composition is defined in the only possible way"
15:04:49 <lingxiao> how would you impoelemnt map2 using foldr?
15:04:52 <codedmart> I have never seen this. I had something like `if (someBool) then [someInfo] else []` and hlint said I could do `[someInfo | someBool]`
15:05:02 <nick99> hi. is there mapIf :: (a -> Bool) -> (a -> a) -> [a] -> [a]?
15:05:03 <lingxiao> WHERE map2 :: (a -> b -> c) -> [a] -> [b] -> [c]
15:05:15 <ski> dpakj : "i honestly have very little concept of what an endo functor is" -- an endofunctor is simply a functor which has the *same* category as domain and codomain
15:05:21 <orzo> codesmart, that's a list comprehension
15:05:26 <nick99> :t map
15:05:29 <lambdabot> (a -> b) -> [a] -> [b]
15:05:30 <codedmart> Ah duh
15:05:41 <ski> dpakj : just like an endomorphism *in* a category is a morphism/arrow/map which has the same *object* as domain and codomain
15:06:11 <codedmart> orzo: Thanks I just had a brain fart.
15:06:18 <lingxiao> or implement zip using foldr
15:06:28 <ski> dpakj : so if we have a function `map toUpper :: String -> String', then we could say this is an endofunction, since both the domain and codomain type is `String'
15:06:35 <dpakj> so for the category of set
15:06:38 <orzo> codedmart: can you figure why my code leaks with forever but not with fix? http://lpaste.net/351645
15:06:41 <dpakj> whats an example endomoprhism
15:06:45 <dpakj> and an example endofucntor
15:07:07 <codedmart> orzo: Is this is test?
15:07:15 <orzo> no
15:07:31 <dpakj> and why is toUpper an endofunctor vs a endomoprhism
15:07:42 <ski> dpakj : and if we have a functor `Either String :: * -> *' (which is an instance of `Functor'), then we could say this is an endofunctor, since both the domain and codomain is `*' (being more or less the same as `Hask', the category -- with some caveats that doesn't matter for the main point here)
15:07:56 <ski> dpakj : not `toUpper', i said `map toUpper'
15:08:00 <ski> @type map toUpper
15:08:02 <lambdabot> [Char] -> [Char]
15:08:16 <ski> `[Char]' is another way to spell `String'
15:08:18 <codedmart> orzo: I have never used fix sorry I don't know the answer to that.
15:08:23 <dpakj> why is map toUpper not an endomorphism
15:08:42 <ski> it *is* an endomorphism
15:09:14 <Tuplanolla> Endo just means the domain and the codomain are the same, dpakj.
15:09:15 <orzo> ski: got any ideas on my paste?
15:09:58 <Tuplanolla> Thus you're basically after the difference between morphisms and functors, dpakj.
15:10:22 <dpakj> oh
15:10:25 <ski> orzo : perhaps related to lambda-lifting ? i dunno
15:10:27 <dpakj> so endofunction = endomorphism?
15:10:45 <Tuplanolla> Yes, it's one instance of endomorphisms, dpakj.
15:11:10 <dpakj> is any type of * -> * an object of the Hask category?
15:11:18 <ski> dpakj : in the categories `Set' and `Hask', morphisms are functions. in other categories, morphisms could be something else
15:11:30 <dpakj> i see
15:11:54 <ski> in `Mat', the category of finite dimensional vector spaces, the morphisms are matrices
15:12:06 <lingxiao> ping anyone
15:12:12 <ski> in `Rel', the objects are sets, but the morphisms are binary *relations* between the sets
15:12:20 <lingxiao> implement map2 :: (a -> b -> c) -> [a] -> [b] -> [c] using foldr
15:13:01 <Tuplanolla> :t zipWith
15:13:04 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:13:12 <Tuplanolla> @src zipWith
15:13:12 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:13:12 <lambdabot> zipWith _ _      _      = []
15:13:25 <Tuplanolla> You almost got lucky, lingxiao.
15:13:33 <lingxiao> hm?
15:13:51 <lingxiao> no it makes sense to impelemnt with zip
15:14:05 <lingxiao> but now the problem is how do you implement zip using foldr
15:14:17 <dpakj> is any function of kind * -> * an object of the Hask category
15:15:20 <ski> dpakj : in the category with objects `1',`2',`3',`4', and morphisms `a_{i,j} : i -> j' (for every object `i' and `j') i described above (which i suspect is what you intended to pick as a suggestion for an example), the morphisms `a_{i,j}' (one for each `i' and `j') are (not necessarily) functions. they're something we haven't specified further
15:15:25 <ski> dpakj : one could possible best think of them as data constructors, with no extra information associated with them
15:15:55 <ski> lingxiao : that's a fun exercise, at least if you use `foldr' (and nothing else) to traverse both input lists ..
15:16:34 <lingxiao> yeah ... http://lpaste.net/351649
15:16:36 <lingxiao> this is what i have so far
15:16:54 <lingxiao> no surprisingly it's only taking the head from the 2nd list
15:18:50 <lingxiao> @ski i dont know if you want to critique me
15:18:50 <lambdabot> Maybe you meant: wiki src ask
15:20:02 <lpaste> glguy pasted “zip2 with foldr” at http://lpaste.net/351650
15:20:35 <glguy> lingxiao: You can't keep using the same "bs" like you were
15:20:45 <lingxiao> yeah that's where i was stuck
15:20:51 <ski> lingxiao : that doesn't work, because you don't use the inner `bs', so you're only (repeatedly) checking the *first* constructor/cell of the given argument `bs'
15:21:01 <dgpratt> what are folks using these days for regex?
15:21:06 <lingxiao> yeah i didnt know how to get around taht
15:21:31 <ski> lingxiao : also, in what i said, you're not allowed to use `case' on `bs' like that, only destructuring and traversing it with `foldr'
15:22:45 <lpaste> athan pasted “Cabal compile failure on raspberry pi” at http://lpaste.net/351652
15:23:01 <athan> can anyone see what's going wrong here? ^
15:23:14 <ski> dpakj : "is any function of kind * -> * an object of the Hask category" -- since you say "of kind * -> *", you must be referring to a *type* function (such as `Maybe',`Either String',&c.) -- and then the answer is no, the objects of `Hask' are the types of kind `*' -- there is no type having kind both `*' and `* -> *' (afaik)
15:23:48 <ski> (is it possible to describe a type `Undefined' of kind `forall k. k', with extensions ?)
15:23:49 <athan> I mean, obviously the file is missing, but what creates it?
15:23:58 <dpakj> i see
15:24:15 <ski> dpakj : have you seen any GADTs before ?
15:24:20 <dpakj> nope
15:24:22 <dpakj> no idea what they are
15:24:32 <dpakj> are all Haskell Functors endofunctors of Hask
15:24:41 <ski> they're an alternative (and more powerful) way to define data types in Haskell
15:24:49 <ski> consider
15:24:53 <ski> @src Maybe
15:24:53 <lambdabot> data Maybe a = Nothing | Just a
15:25:03 <monochrom> athan: "Ignoring unknown section type: custom-setup" is that a good thing?
15:25:11 <athan> :s
15:25:28 <dpakj> is that a gadt?
15:25:32 <dpakj> i thoguth thats just a adt?
15:25:37 <ski> this is an ADT (Algebraic Data Type). we can say this use of `data' is using "ADT syntax"
15:25:54 <ski> we can define the same thing, using GADT (Generalized Algebraic Data Type) *syntax*, as :
15:25:58 <ski>   data Maybe a
15:26:00 <ski>     where
15:26:11 <ski>     Nothing ::      Maybe a
15:26:19 <ski>     Just    :: a -> Maybe a
15:26:25 <dpakj> ah
15:26:32 <dpakj> so basically injecting type parameter in
15:26:45 <ski> so, instead of using the BNF-inspired syntax, we explicitly just list the type signatures that we want for the data constructors, in a `where'-clause
15:26:47 <athan> monochrom: they just look like some different bounds on dependencies that are less restrictive
15:27:11 <ski> dpakj : however, by using this GADT syntax, we can now do things which we can't do with the plain syntax
15:27:12 <athan> er.. and also demand the same Cabal version you're building, too
15:27:34 <dpakj> what are some  examplez/
15:27:51 <ski> here's one example
15:27:54 <ski>   data Foo a
15:27:55 <ski>     where
15:28:07 <ski>     ItsInt  :: Int  -> Foo Int
15:28:18 <glguy> athan: Are you trying to build a cabal-install for your rpi3?
15:28:18 <ski>     ItsBool :: Bool -> Foo Bool
15:28:26 <athan> I am glguy
15:28:34 <ski> using this, we can write a function
15:28:36 <glguy> Did you try cabal-install's bootstrap.sh first?
15:28:43 <athan> I can't seem to get modern versions to work, because they rely on GHC < 8
15:28:47 <ski>   foo :: Foo a -> a
15:29:02 <ski>   foo (ItsInt  n) = n + 1
15:29:02 <athan> and so far I've only got GHC >= 8.0.1 working on here, even with your custom settings
15:29:09 <athan> I didn't!!! >< doh
15:29:11 <ski>   foo (ItsBool b) = not b
15:29:18 <glguy> athan: OK, try the bootstrap.sh
15:29:27 <athan> wait, that doesn't exist
15:29:47 <athan> not in master
15:29:51 <dpakj> so it allows you to return certain paramenrs on certain constructors?
15:29:57 <glguy> no, you shouldn't be using unreleased versions of things
15:30:08 <athan> wait no I'm being silly too
15:30:10 <dpakj> you can use ints in the int section and bool func on bool section of constructor
15:30:18 <athan> but I'm using their stack.yaml also
15:30:19 <dpakj> oh thats pretty cool
15:30:28 <ski> dpakj : so, the strange thing here is that, while `Foo a' is *parameterized* (the type parameter is `a'), the *return* type of the data constructors now don't have a type variable in the position of the parameter. instead they have specifically provided `Int' and `Bool'
15:30:36 <athan> eh, it's worth a shot. Not much has been
15:30:39 <dpakj> so you allow the constructors to map to subtypes
15:30:40 <ski> dpakj : this can't be done with plain ADTs ..
15:30:44 <glguy> athan: You don't need to involve stack
15:30:49 <athan> if not whatevs :)
15:30:56 <dpakj> yeah
15:31:07 <athan> Eh, I kinda do, I haven't been able to get a modern version of cabal on this machine
15:31:10 <dpakj> for plain adts theyd only have access to the functions defined in the type class for that type variable
15:31:26 <glguy> athan: you'll have a modern version once you build it with bootstrap.sh
15:31:26 <dpakj> but in gadt i see you can have type constructors for specific types use functions on those types
15:31:34 <glguy> so no, you don't
15:31:37 <nick99> I could swear there was something like: mapIf :: (a -> Bool) -> (a -> a) -> [a] -> [a]   or   mapIf :: (a -> Bool) -> (a -> b) -> b -> [a] -> [b].
15:31:45 <nick99> or am I confusing haskell with some other language?
15:31:56 <ski> dpakj : not subtypes, but you allow the data constructors to not map into the general parameterized type, but rather into a more specialized version, where some parameter(s) have been "refined" by inserting some type constructors, possibly (as in this case) making them fully specific, by removing all type variables from the return type of the data constructors
15:32:01 * monochrom chips in. There is a reason the file is called "bootstrap.sh"
15:32:04 <dpakj> however
15:32:07 <dpakj> for your foo type
15:32:22 <glguy> monochrom: Is that reason associated with a tale?
15:32:28 <dpakj> hmm
15:32:36 <dpakj> nvm
15:32:37 <dpakj> i get it
15:32:44 <monochrom> Not yet. But maybe I'll have to make one up!
15:32:50 <ski> dpakj : in the `foo' function, note that in the first case, i know that `n' is an `Int', and i also know that the type variable `a' in the type signature *must* be `Int' here, so that i can return the `Int' `a + 1' as return value from `foo
15:33:04 <athan> I think this is a build failure with Cabal, not cabal-install
15:33:29 <dpakj> can u use this to implement a list of two types of elements with only one type parameter?
15:33:45 <ski> dpakj : similarly, in the second case, i know that the type variable `a' *must* be `Bool' (since otherwise the pattern `ItsBool b' wouldn't have matched on the input), so that in this case i know the return type `a' is really `Bool', so i can return `not b' (which definitely has type `Bool')
15:33:48 <athan> yeah it is :x
15:33:52 <monochrom> Yes. But I think the section "custom-setup" is important for building Cabal.
15:34:04 <monochrom> If stack doesn't understand it, kill stack.
15:34:11 <dpakj> right
15:34:15 <monochrom> If Buddha doesn't understand it, kill Buddha.
15:34:24 <ski> dpakj : if you tried to write `foo' with an ordinary ADT, you'd get complaints about the first clause returning an `Int', the second a `Bool', while the type signature said it must be polymorphic
15:36:07 <dpakj> ski, how did you learn so much about category thoery?
15:36:59 <glguy> nick99: Someone might have defined that once, but it's not in the standard libraries
15:37:00 <ski> dpakj : sometimes it's useful to define a GADT like `data TellMeTheType a where ItsInt :: TellMeTheType Int; ItsString :: TellMeTheType String'. note that in this case the data constructors have no arguments of type `Int' or `String'. however if in another function you have a list of type `[a]', and you also get a `TellMeTheType a' from somewhere, then magically you can *discover* which type `a' is (namely `Int' or `String'), by matching on the value of typ
15:37:13 <ski> er, cut off near ".., then magically you can *discover* which type `a' is (namely `Int' or `String'), by matching on the value of type `TellMeTheType a'"
15:37:31 <nick99> glguy does hoogle search outside of standard libraries?
15:37:36 <ski> @remember monochrom <monochrom> If stack doesn't understand it, kill stack.  <monochrom> If Buddha doesn't understand it, kill Buddha.
15:37:36 <lambdabot> Done.
15:37:51 <nick99> maybe it was in those third party utility libs
15:37:52 <glguy> nick99: I don't know
15:37:59 <dpakj> i see
15:38:01 <monochrom> How to learn much about anything: Reading books and "academic" papers, doing exercises, staying away from blogs (incomplete and incoherent), reddit (incomplete and incoherent), and IRC (incomplete and incoherent).
15:38:17 <ski> dpakj : picked up bits and pieces on IRC, looking at some web pages, attempting to read papers, books, &c.
15:38:20 <dpakj> so to like map different functions to the list of [a] for strings and integers
15:38:24 <johnw> lol
15:38:35 <glguy> If you take monochrom's advice, you won't take monochrom's advice
15:38:57 <mettekou> monochrom: The incompleteness is as much a property of papers as it is of blogs. At least in computer science, where conference proceedings dominate over journal publications.
15:38:58 <ski> dpakj : anyway, i wanted to show how we could define an example category in Haskell, using GADT syntax for the arrow/morphism data type
15:39:50 <monochrom> If you take "incomplete" as an absolute boolean, not a reletive extent, sure.
15:40:04 <ski> dpakj : "so to like map different functions to the list of [a] for strings and integers" -- yes .. in some practical situations, GADTs can be very handy, for removing potential error cases at run-time, removing the need for run-time checking (with potential for failure) in that case
15:40:33 <ski> dpakj : with some extensions, you could in Haskell define :
15:40:36 <dpakj> im assuming they are used in parsers?
15:40:39 <ski>   data Obj = One | Two | Three | Four
15:40:47 <ski> and
15:40:52 <ski>   data Mor i j
15:40:54 <ski>     where
15:40:55 <monochrom> But even conference papers set up much more context and preparations than blogs. Blogs just jump into whatever the author is crazy about at the moment.
15:41:20 <ski>     where A_1_1 :: Mor One   One  ; A_1_2 :: Mor One   Two  ; A_1_3 :: Mor One   Three; A_1_4 :: Mor One   Four
15:41:23 <ski> er
15:41:26 <ski>     A_1_1 :: Mor One   One  ; A_1_2 :: Mor One   Two  ; A_1_3 :: Mor One   Three; A_1_4 :: Mor One   Four
15:41:34 <monochrom> Recall that conference papers still went through some pretense of peer review. They have to make sense to someone first.
15:41:46 <ski>     A_2_1 :: Mor Two   One  ; A_2_2 :: Mor Two   Two  ; A_2_3 :: Mor Two   Three; A_2_4 :: Mor Two   Four
15:41:58 <ski>     A_3_1 :: Mor Three One  ; A_3_2 :: Mor Three Two  ; A_3_3 :: Mor Three Three; A_3_4 :: Mor Three Four
15:42:14 <ski>     A_4_1 :: Mor Four  One  ; A_4_2 :: Mor Four  Two  ; A_4_3 :: Mor Four  Three; A_4_4 :: Mor Four  Four
15:42:29 <dpakj> i see
15:42:37 <dpakj> so the cross rpoduct
15:42:50 <ski> dpakj : so, i'm just enumerating all the combinations for arrows between `One',`Two',`Three',`Four', one morphism for each ordered pair of two such objects
15:43:46 <ski> dpakj : now, to make this a category, we need to define the identity, and the composition, and also check that the identity is a neutral element for the composition, which should be associative
15:44:01 <ski> dpakj : ideally, we'd like to be able to define
15:44:11 <ski>   identity :: Mor i i
15:44:54 <ski> however, unfortunately, this doesn't work, we need to be able to know (at *run-time*) which `i' was wanted, to be able to pick the correct alternative of `A_1_1',`A_2_2',`A_3_3',`A_4_4'
15:45:22 <ski> so, we may do the earlier `TellMeTheType' trick, by defining a data type :
15:45:35 <dpakj> oh wow
15:45:36 <dpakj> lol
15:45:38 <ski>   data ObjIs i
15:45:40 <ski>     where
15:45:53 <ski>     ItsOne   :: ObjIs One
15:45:58 <ski>     ItsTwo   :: ObjIs Two
15:46:04 <ski>     ItsThree :: ObjIs Three
15:46:11 <ski>     ItsFour  :: ObjIs Four
15:46:16 <ski> so, now we can define
15:46:20 <dpakj> but in this case isn't the identity 4 -> e
15:46:29 <ski>   identity :: ObjIs i -> Mor i i
15:46:39 <ski>   identity ItsOne   = A_1_1
15:46:45 <ski>   identity ItsTwo   = A_2_2
15:46:51 <ski>   identity ItsThree = A_3_3
15:46:57 <ski>   identity ItsFour  = A_4_4
15:47:40 <ski> so, for each object `i' (which can be any one of `One',`Two',`Three',`Four'), we get a morphism from `i' to `i', represented here as a value in the type `Mor i i'
15:48:23 <ski> we can only pick the `A_i_j' constructors which have the same object `i' being equal to `j' as "domain" and codomain
15:48:36 <ski> so we can't pick `A_1_2' and put into `identity', since the types wouldn't match
15:49:01 <dpakj> right
15:49:23 <dpakj> but now doesn't the domain of the identy have cardinality 4
15:49:25 <dpakj> instead of 1
15:49:26 <ski> in the first case, since we match on `ItsOne', the type signature `identity :: ObjIs i -> Mor i i' essentially is refined into `identity :: ObjIs One -> Mor One One', and the only (total) value (in this case) of type `Mor One One' is `A_1_1'
15:49:42 <ski> for each `i', we pick *one* morhism
15:49:50 <ski> s/morhism/morphism/
15:50:36 <ski> (in general, there could be several candidates, but `identity' should only pick one of them. in this case, there was no choice, this was how `identity' *had* to be defined, given how `Mor' was defined)
15:51:38 <ski> anyway, note how by inspecting the data constructor `ItsOne'/`ItsTwo'/`ItsThree'/`ItsFour' at *run-time*, we learn that the type variable `i' must be one of `One',`Two',`Three',`Four'
15:52:14 <xpika> Is there any way to use hackage packages on lambdabot ?
15:52:16 <dpakj> eyah
15:52:27 <ski> this can feel like we're magically transmitting information from run-time back to compile-time (namely when the bodies of the clauses / branches are type-checked)
15:53:11 <dpakj> but its more or less giving you an extremely granular typeclass no?
15:53:25 <ski> since at compile-time, it knows that e.g `A_1_2' won't fit into the `identity ItsOne   = ...' case, despite not knowing what `i' is at compile-time
15:54:10 <ski> more specifically, at the level of the whole `identity' (before going into the branches for pattern-matching), we don't know `i', but *after* that, inside each branch, we *do* know which thing `i' is in each case
15:55:24 <ski> dpakj : it's a bit similar to a type class, the data constructors corresponding to the instances, except that type classes are open (and can have at most one instance for each specific combination of type arguments for the type class) ..
15:55:38 <ski> .. data types are closed, can't be extended after the fact, without modifying the original source code
15:55:44 <dpakj> right
15:56:38 <dpakj> so will the compiler know that if I hav ea function Foo a -> a
15:56:46 <dpakj> that a must but an int/bool
15:57:20 <ski> dpakj : anyway, let's consider composition, say we write it as infix `...'
15:57:25 <ski>   infixr 1 ...
15:57:44 <ski>   (...) :: Mor j k -> Mor i j -> Mor i k
15:58:00 <ski>   A_1_1 ... A_1_1 = A_1_1
15:58:05 <ski>   A_1_2 ... A_1_1 = A_1_2
15:58:08 <ski>   A_1_3 ... A_1_1 = A_1_3
15:58:16 <ski>   A_1_4 ... A_1_1 = A_1_4
15:58:28 <dpakj> oh dear
16:00:49 <dpakj> :S
16:00:53 <ertes> helo
16:00:53 <ski> oops :/
16:01:09 * ski has notices this kind of thing another time, with another user
16:01:20 <ski> (which i helped get the ban lifted swiftly from)
16:01:26 <dpakj> haha
16:01:39 <ski> perhaps someone could joing #freenode and ask an operator to look into the matter ?
16:01:57 <dpakj> hey ski, thanks for all the help man
16:02:02 <dpakj> it was very enlightening
16:02:10 <dpakj> i gotta head out now, again thanks so much
16:02:10 <ski> (i fear that if i identify again, i'll be killed by Sigyn again)
16:02:16 <dpakj> :S
16:02:50 <ski> (same if i continue the next few lines (i meant only to give the next four or so, showing the pattern for how `(...)' is defined) of the definition)
16:03:12 <geekosaur> this is another reason why we use lpaste
16:14:51 <dgpratt> using Haskell on Windows is always a unique challenge :/
16:15:55 <dgpratt> trying to use regex-pcre, which depends on the pcre lib, which I downloaded and mentioned the lib dir in --extra-lib-dirs
16:16:12 <dgpratt> still no dice, "* Missing C library: pcre"
16:16:24 <davean> dgpratt: was it really necessary to add the Haskell qualifier?
16:16:30 <dgpratt> :P
16:24:30 <ski> dpakj : anyway, the point is that you can think of the morphisms of this category as just data constructors, uninterpreted, which each happen to have associated with it a domain object and a codomain object
16:26:06 <ski> dpakj : you *could* also use a plain `data Arr = A_1_1 | A_1_2 | ... | A_4_4', but then it is possible to pass non-composable morphisms at run-time to `(...) :: Arr -> Arr -> Arr' .. also, you also now have to separately specify functions `domain :: Arr -> Obj' and `codomain :: Arr -> Obj', which now "happen" at run-time rather than at compile-time
16:29:49 <ski> dpakj : another thing i meant to say : `(...)' doesn't need any argument(s) having type like `ObjIs i',&c., because in this case we can determine which result value to return (related to the "object" type variables `i' and `k') just by pattern-matching on the two inputs of type `Obj j k' and `Obj i j' (matching on them will tell us what `i',`j',`k' are, we don't need to use the `ObjIs' trick in this case to do that)
16:35:19 <f-a> I see apfelmus' reactive-banana moved away from an applicative interface. Are there still FRP using an applicative interface? I am not the biggest fan of arrows
16:35:40 <Squarism> Heres my messaging code for a 2 player network game : http://lpaste.net/351653 - It works very well. I wonder if you see any obvious things i should focus on - Like is this an apperent case for a RWS monad? 
16:37:19 <Squarism> ...or, any other pointers welcome - if its possible to understand whats going on
16:41:13 <ertes> f-a: i'm not sure what you mean…  reactive-banana is and has always been a monadic FRP interface
16:41:38 <f-a> ertes: from 1 to 2 there has been a change in interface (or 0 to 1)
16:41:53 <ertes> f-a: yes, but not to arrows
16:42:17 <ertes> f-a: the main change is that the safety type argument from Behaviour and Event has disappeared
16:42:27 <f-a> ertes: yeah, I mistyped :S I meant *monads*
16:43:01 <ertes> f-a: well, you need a monad (or an arrow)…  how else are you going to express any interesting application?
16:43:15 <f-a> ertes: yeah and an M appeared
16:43:37 <ertes> f-a: you mean MonadMoment?
16:43:43 <f-a> yes, ertes 
16:44:04 <f-a> the phantom type allowed a different style
16:44:16 <ertes> f-a: it has been there all along, but in a different guise (it was a specific monad, not an effect class)…  the new interface is more convenient
16:44:30 <ertes> f-a: the phantom type didn't allow anything…  it *disallowed* some things
16:44:41 <ertes> (related to switching)
16:49:23 <f-a> ertes: this repo was written with the old version https://github.com/gelisam/ludum-dare-31 
16:50:19 <f-a> with the new, I had to switch from <$> <*> to >>= and imho it made the code more cumbersome (I am sure there is a good reason to have MonadMoment)
16:50:39 <f-a> I would point to a specific line but my connection decided to get all flaky grrrr
16:51:15 <ertes> f-a: but for what?  if it were possible to use applicative style before, it should still be possible
16:51:54 <ertes> i don't see anything in the API that became more effectful
16:52:29 <ertes> (i might be wrong, i just don't see anything)
16:55:40 <f-a> ertes: accumB sig was, as an example, accumB :: a -> Event t (a -> a) -> Behavior t a
16:55:50 <f-a> now accumB :: MonadMoment m => a -> Event (a -> a) -> m (Behavior a)
16:56:27 <ertes> ah, you're right
16:58:24 <ertes> well, i guess there is a good reason for that change that isn't necessarily related to the new API…  reflex has the same constraint
16:58:51 <f-a> sodium too
16:59:15 <ertes> (the reflex equivalent is foldDyn or accum* in the git version)
16:59:53 <ertes> i think it makes sense…  one way to implement accumulation is by observing values recursively, which requires the underlying monad
17:06:41 <f-a> nj
17:08:41 <f-a> thanks for the chat ertes , I'll try to sleep now
17:09:49 <ertes> sure…  good night =)
17:30:44 <orzo> does a combinator like strict f x = seq x (f x) exist somewhere for me already?
17:31:03 <monochrom> yes, $!
17:31:14 <orzo> cool
17:31:31 <barrucadu> The eternal Haskell problem: you can't tell if someone is just being enthusiastic in their answer, or if they're telling you the name of an operator.
17:31:52 <monochrom> yes.
17:31:55 <Jinxit> lmao
17:32:24 <monochrom> <Q> Can I get the ith item in a list?  <A> Yes !!
17:34:33 <hpc> "how do i interact with lambdabot?" "?"
17:34:49 <Welkin> insert coins into the slot
17:35:07 <biglambda> When does stack run Setup.hs
17:35:15 <hpc> when cabal does
17:35:25 <biglambda> On cabal build?
17:35:32 <hpc> dunno, never needed it ;)
17:35:47 <biglambda> Hmmm…
17:35:54 <monochrom> "cabal configure" also runs Setup.hs
17:54:42 <jmorris> when i use the commented out function in all possibilities from here http://lpaste.net/351654
17:54:45 <jmorris> i get the error
17:55:15 <codygman> I'm writing a Haskell to X transpiler, any reason not to use haskell-src-exts? It looks like hlint uses it successfully.
17:55:19 <jmorris>   Couldn't match expected type Integer -> (Word8, ByteString)
17:55:19 <jmorris>                   with actual type ByteString
17:55:19 <jmorris>      In the first argument of P.map, namely s
17:55:19 <jmorris>       In the expression: P.map s [1 .. 255]
17:55:19 <jmorris>       In an equation for allPossibilities:
17:55:20 <jmorris>           allPossibilities s = P.map s [1 .. 255]
17:55:33 <jmorris> and im not sure why
17:56:04 <biglambda> jmorris are u missing an argument to P.map?
17:56:15 <biglambda> What is the type of P.map?
17:56:30 <glguy> jmorris: Perhaps you meant to use singleByteXor?
17:56:37 <jmorris> (a -> b) -> [a] -> [b]
17:56:44 <jmorris> :t map
17:56:46 <lambdabot> (a -> b) -> [a] -> [b]
17:56:59 <biglambda> So the type of s is a function
17:57:09 <ski> @type BS.map
17:57:12 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
17:57:15 <jmorris> oh lol
17:57:21 <biglambda> But in your type annotation it’s ByteString
17:57:39 <biglambda> Try removing the type annotation
17:57:44 <jmorris> when i put singlebytexor in i still get the error
17:57:46 <jmorris> biglambda: ok
17:57:52 <biglambda> See what the compiler thinks it is
17:58:12 <glguy> jmorris: Now that you've fixed that, you're using the wrong map function as ski is pointing out
17:59:05 <jmorris> i think it worked
17:59:11 <jmorris> i didnt change the map though
17:59:28 <jmorris> I forgot to put parentheses around singleByteXor s
17:59:57 <jmorris> so i think it is working
18:00:31 <jmorris> so i think it is working
18:00:43 <jmorris> oops sorry
18:34:08 <fresheyeball> is there a simple subset function in Haskell?
18:34:36 <fresheyeball> I have a (Set a) and a (NonEmpty a) and just need to know if the NonEmpty contents are a subset of the Set
18:36:23 <kadoban> fresheyeball: isSubsetOf
18:36:30 <kadoban> Or isProperSubsetOf
18:36:42 <monochrom> Did you go through the Data.Set doc?
18:36:45 <kadoban> Usually used inline, like  a `isSubsetOf` b
18:36:55 <monochrom> infix?
18:37:02 <kadoban> Heh, ya that.
18:37:17 <barryburd> Hello, I have a question for anyone who wants to answer it. In ghci I intentionally typed a syntactically incorrect line and got a response that I wasn’t expecting….
18:37:24 <fresheyeball> kadoban: I was hoolging
18:37:27 <fresheyeball> didn't find that one
18:37:54 <barryburd> With the variable a being a list, I typed      (head tail) a     knowing that this wouldn’t be correct….
18:37:54 <fresheyeball> barryburd: do tell
18:37:57 <monochrom> To tell you the truth, I still haven't used hoogle.
18:37:58 <kadoban> monochrom: Oh hey, thanks for that code from the other day, I finally understand it. Never would have come up with it myself I don't think.
18:38:05 <monochrom> :)
18:38:11 <barryburd> The response was as follows:
18:38:19 <barryburd>  Couldn't match expected type ‘[[Integer] -> t]’
18:38:20 <barryburd>                   with actual type ‘[a0] -> [a0]’
18:38:38 <barryburd> The part I don’t understand is the [[Integer] -> t] part.
18:39:25 <glguy> head tail [], you're attempting to pull a function out of the (not)list tail and apply that function to a list
18:39:42 <david__> I'm trying to model a pong ball (in 1d - just moves left-to-right) with reactive banana, but I'm having trouble defining it. I want to say that it is simply a "Behavior Int", defined in terms of the initial value (0), and two "Event ()"s corresponding to when the ball hits the left and right sides of the game
18:39:48 <glguy> so for that to work, tail would have had to have the type [[Integer] -> t]
18:39:55 <glguy> but it doesn't have that type, it has [a0] -> [a0]
18:39:59 <glguy> so we have a conflict
18:40:04 <david__> but I'm having trouble figuring out how to make these "Event ()"s... as Events seem to only come from outside the model
18:40:09 <glguy> > head [sum] [1..3]
18:40:11 <lambdabot>  6
18:40:41 <glguy> barryburd: See how in this case if we replaced tail with something having a type: [ [Integer] -> Integer ]  things work out?
18:41:46 <barryburd> glguy, thanks. I’ll think about it. I was expecting it to say that it was expecting something of type [a] because the head function wants to act on a list.
18:43:43 <glguy> barryburd: That's what it said it expected
18:43:58 <glguy> [[Integer] -> t] is of that form
18:45:18 <barryburd> Ah, yes. The part that I have to keep thinking about is why each element of that list should be of the form [Integer] -> t
18:45:47 <glguy> barryburd: when you wrote: (head tail) theList, you were applying the result of (head tail) as a function to theList
18:46:28 <barryburd> Yes! Thanks.
18:52:54 <monochrom> Was the list of type [Integer]?
19:00:10 <codedmart> Is there a package already I can use to diff two of the same data types. When a change is made I want to diff to find what has changed.
19:07:32 <Guest64067> Hey guys I have a very dumb question
19:08:10 <Guest64067> I can do newtype Example m a = Example (ReaderT Int m a) deriving (Applicative, Functor, Monad)
19:08:30 <Guest64067> and that all works fine but as a learning exercise I tried to implement the Monad functions by hand
19:08:41 <Guest64067> and I realize I have no idea how to do it
19:10:24 <glguy> Sounds like a good exercise then
19:11:18 <monochrom> Could you do Functor and Applicative? Maybe they are easier and gives you more ideas.
19:13:12 <glguy> You could also start by implementing those instances for: newtype Reader r a = Reader (r -> a)
19:13:18 <glguy> and then move on to ReaderT
19:13:25 <glguy> and then move on to your newtype around ReaderT
19:14:30 <monochrom> >>= of Example m will end up calling >>= of m somewhere
19:17:26 <glguy> Or at least of ReaderT Int m
19:17:53 <glguy> Depending on how much you want to implement yourself
19:19:17 <Guest64067> Hmm ok I will try those thanks
19:22:55 <dramforever> Guest64067: That 'deriving' clause just wraps the instances of ReaderT
19:23:06 <dramforever> You could probably read the ReaderT code to get somet idea of it
19:23:14 <dramforever> s/somet/some
20:06:59 <type_hole> I understand some of the problems with type classes and I read the opinions of some people talking about the problems with type classes (laws for example)... but what's the alternative?
20:07:55 <monochrom> I don't know what those opinions are and what they said.
20:09:06 <monochrom> But I would find alternatives from what they said. Or if they said nothing, then I would move on. There is not enough time for idle opinions.
20:10:02 <tmciver> type_hole: Here's an alternative that I recently discovered and have been working to understand: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
20:10:41 <tmciver> type_hole: basically you have to manually create and pass around a function map.
20:11:12 <type_hole> tmciver: thanks! that's the type of stuff I was looking for
20:12:05 <monochrom> Now you can pass around two incompatible MonadI records (but the computer doesn't know this problem) and confuse yourself.
20:12:29 <monochrom> That is the limitation of that approach.
20:12:44 <monochrom> And unlike other authors, I will also tell you the alternative.
20:12:45 <codygman> How do you guys expose your modules to your tests? How do you test unexported code?
20:13:08 <monochrom> The alternative is going back to type classes, with which the computer checks uniqueness.
20:13:18 <tmciver> monochrom: Do you mean the user can accidentally use two different records?
20:13:23 <monochrom> Yes!
20:13:30 <tmciver> Ah, yes, I see.
20:13:43 <monochrom> This is one reason why Data.Map does not let you do dictionary-passing by hand yet.
20:14:10 <tmciver> monochrom: well . . . buy beware! :)
20:14:17 <tmciver> s/buy/buyer
20:24:07 <glguy> codygman: by exposing the modules
20:24:22 <codygman> glguy: Simple enough I suppose ;)
20:36:10 <dramforever> I guess: export them, say versioning rules and consistency guarantees don't apply, and... Profit?
20:38:06 <nshepperd> I think normally make Foo.Internal.Bar modules
20:38:18 <Sornaensis> today, I programmed in haskell
20:38:21 * Sornaensis drops the mic
20:38:52 <kadoban> Haha
20:51:18 <maybefbi> has anyone used this in production: https://github.com/begriffs/postgrest
20:51:50 <codygman> It looks like haskell-src-exts doesn't have type information available. I'm guessing that the AST ghc uses will? Or will I need to use something like haskell-src-exts and haskell-type-exts for this?
20:53:41 <Cale> codygman: Yeah, the GHC API will give you access to that -- after having run the typechecker
20:53:58 <Cale> haskell-src-exts is only a parser
20:54:04 <Cale> (and prettyprinter)
20:54:50 <Cale> There's basically nothing you can do apart from using the GHC API or writing a separate typechecker for Haskell (which would be way less trivial than the parser)
20:55:28 <codygman> Cale: Okay, I'm guessing haskell-type-exts is a wrapper over the GHC API then
20:56:00 <codygman> I'll see how far I can get with it because I've heard the GHC API being undocumented makes using it very painful
20:56:24 <Cale> codygman: Nah, it looks like a really simple typechecker for basic Haskell
20:56:36 <Cale> https://hackage.haskell.org/package/haskell-type-exts-0.1.0/docs/src/Language-Haskell-TypeCheck-TypeCheck.html
21:02:45 <codygman> Cale: You are right. It looks like my only option is the GHC API, know of any good examples for typechecking a simple expression?
21:22:23 <Axman6> reactormonk: so https://hackage.haskell.org/package/hoauth2 isn't suitable?
21:34:18 <dmwit> Is there a canonical `data Exists c where Exists :: c a => a -> Exists c`? If not... why not?
21:39:10 <glguy> I don't know of one myself. It seems like something that would happily be merged into the constraints package, though
21:40:35 <glguy> Perhaps it doesn't exist in a common place because there aren't many interesting operations to define on it?
21:40:43 <glguy> so everyone just make them as needed
21:41:15 <dmwit> Well.
21:41:53 <dmwit> It's got the obvious operation, `(forall a. c a => a -> b) -> Exists c -> b`, I guess.
21:49:15 <dmwit> constraints seems like a neat package. Thanks for pointing me at it.
21:49:28 <dmwit> No idea what I'd do with it, though.
21:49:55 <glguy> Here's me playing around with it https://github.com/glguy/operations/blob/master/src/Example.hs
21:55:19 <lpaste> glguy pasted “An operation that Exists supports” at http://lpaste.net/351658
21:55:23 <glguy> dmwit: There's that one :)
21:56:45 <dmwit> Ah, nice. Then you can do `instance Show (Exists Show)` and have it actually be useful.
21:57:14 <dmwit> (and similar for other classes)
22:01:55 <glguy> good idea
22:02:26 <glguy> *Example> producer2 :: [Object '[Num,Show]]
22:02:27 <glguy> [Object 100,Object 1]
22:05:51 <fresheyeball> glguy: I've had this window open for days now
22:05:59 <fresheyeball> you are an absolute helpfulness machine
22:06:02 <fresheyeball> mass respect
22:06:39 <glguy> fresheyeball: thanks :)
22:06:45 <glguy> dmwit: Check this one out  https://github.com/glguy/operations/commit/b63008b0c23e5439a8adf3d5d467a868d37237bb
22:07:42 <nshepperd> 2/url 1
22:08:06 <glguy> nshepperd: Any chance that's a glirc command?
22:08:39 <dmwit> Yeah, Object seems like a pretty handy generalization of Exists. Having the list of constraints reified like that makes the type-level subset be the really common case for what :- can only give you at the term level.
22:08:57 <nshepperd> glguy: weechat
22:09:30 <glguy> Ah, OK :) I had my fingers crossed
22:09:38 <glguy> https://imgur.com/a/DEmaR
22:09:43 <nshepperd> heh
22:11:01 <nshepperd> I can't think of any classes you'd be able to lift over Object like that apart from Show
22:11:30 <nshepperd> Num (eg. +) wouldn't work because the enclosed things being added would be different types
22:12:30 <dmwit> Typeable?
22:13:00 <dmwit> Well, other serialization classes, of course.
22:13:12 <glguy> nshepperd: Yeah, in the target usecase for this there aren't binary operations
22:13:18 <glguy> mostly query and update operations
22:13:49 <glguy> mostly/exclusively :)
22:14:06 <nshepperd> I suppose you could [Num, Typeable] ⊂ c => Num (Object c) and have it be all dynamic and crashy like python :)
22:14:20 <dmwit> That's what acme-php is for
22:15:27 <dmwit> Oh, neat, haddock will show orphan instances. I wonder how long it's been capable of that.
22:17:18 <glguy> nshepperd: It might become more useful as: data Object f cs = forall a. All cs a => Object (f a)
22:17:36 <glguy> or a similar variant, for these classes like Num. f could be [] or V3 or something
22:17:44 <glguy> so you could support more than one element of the type
22:18:41 <glguy> :t fromInteger
22:18:43 <lambdabot> Num a => Integer -> a
22:19:00 <glguy> and I think this is what might make Num harder to implement than (+)
22:20:08 <dmwit> But that one's easy.
22:20:16 <dmwit> fromInteger n = Object n
22:22:40 <dmwit> Now readsPrec on the other hand...
22:22:52 <glguy> restrict my instance as: instance (All cs Integer, Num ∈ cs) => Num (Object cs)
22:23:03 <glguy> That would^
22:23:21 <dmwit> why?
22:23:34 <dmwit> Oh, yes, it would.
23:57:41 <quchen> Can someone explain Uncle Bob to me? He’s some guy who wrote a book about his code style, and somehow everyone seems to think he’s knowledgeable about programming concepts
23:58:10 <quchen> Most things he says make me angry.
23:59:03 <quchen> Did he invent something? A language? A technology?
