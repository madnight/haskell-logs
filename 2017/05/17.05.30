00:09:30 <nshepperd> i guess the actual + in your program may be not commutative to the extent that it doesn't implement IEEE 754 due to "tricks" like 80 bit registers
00:10:06 <mniip> like I said, x87
00:11:04 <nshepperd> but then, i dunno. if a + b != a + b because in one case a is an 80 bit register variable, is it really the same a?
00:12:21 <mniip> the case that can be exhibited on a modern compiler is a + b = load(store(a + b))
00:13:06 <mniip> where store :: 80bit -> Word64; load :: Word64 -> 80bit
00:13:54 <defstryker> hello people
00:14:02 <thang1> hello person
00:14:33 <defstryker> just starting out haskell for project euler :D
00:14:48 <thang1> Neat! Any prior experience with Haskell?
00:14:49 <nshepperd> (a + b) - x != load(store(a + b)) - x, where x cancels most of the bits of a + b?
00:15:39 <defstryker> Just a little. Going through real world haskell and lyah
00:16:00 <defstryker> Might look at the writing a compiler using haskell
00:16:38 <mniip> nshepperd, without x even
00:16:48 <mniip> you can get != due to rounding induced by 'store'
00:16:54 <mniip> if you use 80-bit comparison
00:17:01 <nshepperd> != by 80 bits standards, sure
00:17:14 <thang1> You might have a touch of trouble writing haskell Euler solutions concisely, but you should be able to get there hopefully!
00:17:51 <defstryker> have done the first five this morning, hopefully the rest goes well too.
00:18:31 <thang1> What was your solution for problem 1? Just out of curiosity :p
00:19:44 <nshepperd> i guess you shouldn't be surprised if a random 80 bit format fails to obey any axioms after being mutilated by rounding it through float64
00:20:38 <defstryker> @thang1 this i believe: sum [x | x <- [1..999], mod x 3, mod x 5]
00:20:38 <lambdabot> you are welcome
00:21:05 <mniip> nshepperd, yes but it C it looks like a + b != a + b
00:21:42 <EvanR> laws shmaws
00:21:46 <mniip> int test(double a, double b, double ab) { return a + b == ab; };   test(x, y, x + y);
00:22:04 <EvanR> you dont want to be limited by laws do you, be more dynamic
00:22:10 <thang1> defstryker: that's a pretty good solution, actually.
00:22:22 <defstryker> thanks
00:22:35 <mniip> defstryker, you forgot == 0
00:23:16 <mniip> defstryker, your nickname seems familiar...
00:23:24 <kadoban> It becomes a much more interesting problem when n is much much greater than 1000, heh.
00:24:39 <thang1> Then you want to do things like generating lazy wheels :p
00:25:46 <kadoban> Naw, you can do better than that. There's a closed form solution, no looping at all.
00:26:11 <thang1> Oh right, because you're finding the sum
00:26:25 <kadoban> Yep
00:26:28 <nshepperd> if you're going to apply 80 bit standards, that is a + b != roundToFloat64(a + b)
00:26:41 <thang1> sum . takeWhile (<10000) $ filter (\n -> (n `mod` 3 == 0) && (n `mod` 5 == 0)) [1..] -- My super lazy and ugly solution without  list comprehensions
00:26:50 <nshepperd> what C makes it looks like is C's problem :p
00:29:44 <thang1> damnit, kadoban, ya nerd sniped me
00:29:58 <thang1> Now I gotta know what this closed form is :p
00:30:40 <kadoban> ;)
00:31:23 <kadoban> Want hints?
00:31:54 <thang1> Hmm... Divisible by 3 and 5 is equivalent to multiples of 15, yes?
00:32:28 <kadoban> I think the actual problem is the sum of the numbers divisible by 3 *or* by 5, but I could be wrong. But it's not much harder either way I don't think.
00:32:50 <thang1> oh whoops, it is 3 or 5
00:33:01 <pacak> That's 3 or 5, not and.
00:33:55 <thang1> In that case you can just do the individual closed form sum of numbers mod 3 and closed form sum of numbers mod 5 and add the two together, yes?
00:34:05 <pacak> thang1: No.
00:34:06 * thang1 should stop ending sentences with 'yes'
00:34:15 <kadoban> Almost, need a correction
00:34:24 <thang1> Oh right, throw out duplicates first :p
00:36:00 <\u> konhow to typeset the ArrowChoice law $left (f \ggg g) = left f \ggg left g$ in latex? 
00:36:40 * nshepperd draws a venn diagram
00:37:01 <\u> Are there any Arrow papers using (+++ ||| &&& ...) available in latex...
00:38:40 <thang1> kadoban: Is there a direct closed form that computes the answer in one summation? Or is it the two summations added together?
00:39:47 <kadoban> Mine would be based on "the sum of the multiples of k up to n" used 3 times. I assume there's other ones though.
00:41:03 <thang1> 3 times? So sum of multiples of 3, sum of multiples of 5, minus the sum of multiples of 15? That's a lot neater than what I was thinking of :p
00:41:12 <kadoban> Yeah
00:41:33 <thang1> I was thinking of embedding the subtraction of the third sum inside the iteration condition of one of the other two somehow
00:41:48 <pacak> You don't need iterations.
00:42:53 <kadoban> Ah. That's probably possible, but then you have to actually do iteration most likely. You only need a constant number of multiplications, divisions and additions totaly
00:44:39 <pacak> [3, 6 ... n] => 3 * [1, 2 ... n / 3] => 3 * [1 + n / 3, 2 + n/3 - 1, ...] => ....
00:44:57 <thang1> I know I don't need iterations, which is why it was bugging me that I was only thinking of that solution :p
00:46:21 <thang1> Well, my (sum []) + (sum []) - (sum []) takes up 1/6th the memory that my sum . takeWhile ... solution does
00:46:29 <thang1> seems to be a touch faster too
00:47:10 <Guest13355> faster how? due to the number of computations?
00:47:24 <thang1> "touch faster" nvm it's waaaay faster
00:47:44 <thang1> sum . takeWhile (<100000) $ filter (\n -> (n `mod` 3 == 0) || (n `mod` 5 == 0)) [1..] -- This is my "original solution"
00:47:45 <kadoban> It should be way way faster, yeah. It's considering fewer numbers, and it's only doing additions
00:48:02 <pacak> Like O(n) vs O(1) faster.
00:48:08 <kadoban> Well, and a subtraction, but w/e. It avoids `mod` anyway.
00:48:21 <thang1> You have 2 mod functions, 3 comparisons, a filter, a takeWhile comparison, and a sum
00:48:40 <kadoban> pacak: I think they're talking about just directly doing the iteration for each, though I'm not sure.
00:48:40 <thang1> (sum [3,6..100000]) + (sum [5,10..100000]) - (sum [15,30..100000]) -- This is the "closed form" solution
00:49:22 <thang1> Direct summations, no comparisons, nothing like that, just raw optimized assembly loops and plain integer arithmetic
00:49:27 <pacak> I think there's one more task on project euler with the same description but with something much bigger than 100k so it can't be calculated with loop in same time.
00:49:30 <pacak> *sane
00:49:49 <kadoban> Ah, is there? That's good. I couldn't remember if there was.
00:50:38 <thang1> Disappointed that ghci is only using one core...
00:50:50 <merijn> thang1: ghci is shit if you want speed anyway
00:51:01 <merijn> thang1: It's interpreting bytecode and doesn't do much optimisation
00:51:16 <merijn> thang1: Simply compiling is basically always significantly faster
00:51:31 <thang1> eh, fair
00:51:37 <Itkovian> shapr: next attempt at introducing some haskell at work https://hackage.haskell.org/package/hnormalise
00:53:02 <pacak> merijn: There's  -fobject-code
00:53:22 <merijn> pacak: Right, but that's basically the same thing as compiling and then loading compiled code into ghci :p
00:53:27 <merijn> pacak: So you might as well compile
00:55:31 <thang1> interesting...
00:55:31 * nshepperd wonders what pacak is saying with [1 + n / 3, 2 + n/3 - 1, ...]
00:55:46 <nshepperd> can't you just apply the triangle formula already?
00:56:22 <pacak> nshepperd: You can if you know it. If you don't - from what I wrote it should be obvious what to do next.
00:56:53 <thang1> I think I'm using some compiled code in ghci
00:57:59 <nshepperd> oh, you're doing the summing from both ends trick
00:58:26 <thang1> @let fibs = (1 :: Integer) : scanl (+) 1 fibs
00:58:27 <lambdabot>  Defined.
00:59:03 <thang1> > sum . takeWhile (<4000000) $ filter (even) fibs -- Is this supposed to be stupidly fast and memory efficient?
00:59:05 <lambdabot>  4613732
00:59:37 <kadoban> Well, probably because there's not many fibs less than that and it's computing them quite efficiently.
00:59:54 <merijn> thang1: parens around even are redundant
01:00:04 <merijn> thang1: It's just "filter even fibs"
01:00:32 <thang1> Thanks. It's a force of habit from doing things like filter (/= thing)
01:00:37 <merijn> thang1: I would expect that to be stupid fast, yes
01:01:08 <merijn> thang1: It's building the list fairly efficiently, and I think scanl, takeWhile and sum are all "well-behaved" producers/consumers (i.e. they can be fused)
01:01:10 <thang1> Okay, because to me it looks like it's optimizing away the list entirely and I wanted to make sure I wasn't thinking about it wrong :p
01:01:19 <merijn> So I would expect GHC to fuse the entire thing and optimising the list generation away
01:01:32 <merijn> thang1: I would expect it to optimise the list away, yes
01:01:41 <nshepperd> (i bet there's a fancy O(log n) constant memory solution for that too)
01:01:59 <thang1> > sum . takeWhile (<40000000000000000000000) $ filter (even) fibs -- Yeah this takes like 0.01 seconds on my computer
01:02:01 <lambdabot>  21783388129427422369052
01:02:25 <merijn> thang1: I would expect GHC to turn that into a crazy optimised libgmp loop :)
01:02:36 * thang1 is highly amused that he typed the exact same amount of zeros by holding down repeat and eyeballing it
01:02:36 <merijn> thang1: And GHC is pretty damn good at using GMP
01:02:55 <nshepperd> or maybe log (log n), what with fibs getting exponentially bigger
01:03:00 <thang1> To be fair, gmp is pretty great
01:03:17 <merijn> thang1: Yeah, but have a look at how amazing GHC is at using it: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
01:03:28 <nshepperd> the normal "linear" solution would be log n already, because of that
01:03:31 <thang1> nshepperd: Well, there is a closed form of the fibonacci sequence
01:04:30 <kadoban> Note that it barely matters if it gets rid of the list or not. A list of what, a couple of hundred items is nothing.
01:04:43 <thang1> True, that's a good point that I was missing
01:04:58 <merijn> kadoban: Also true
01:05:23 <merijn> > length . takeWhile (<40000000000000000000000) $ filter even fibs
01:05:25 <lambdabot>  36
01:05:32 <merijn> oh...that's shorter than I expected
01:05:37 <thang1> hah, that surprised me too
01:05:38 <kadoban> Yeah, me too
01:05:51 <merijn> > length . takeWhile (<40000000000000000000000) $ filter odd fibs
01:05:52 <lambdabot>  73
01:06:10 <thang1> ahh there we go. Fibonacci just heavily favors odd numbers
01:06:24 <merijn> Even then, that's short :)
01:06:35 <merijn> So even just summing the entire thing will be quick
01:07:03 <thang1> So apparently the closed form of the summation of the fibonacci numbers is F_(2n+2) - 1  if I'm reading this stack overflow exchange thing right
01:07:57 <kadoban> This is what amuses me about fibs, the comparative interest in really quick solutions to nth fib ... when if you actually go high enough for it to matter, you're well on your way to using all of physical memory. Unless you do them modulo some number or whatever.
01:08:08 <ventonegro> Doing `:sprint fibs` after the summation still prints `_`
01:08:20 <ventonegro> Is that due to fusion?
01:08:32 <thang1> kadoban: you should see people furiously computing busy beaver functions :p
01:08:41 <kadoban> :)
01:08:47 <thang1> "yeah so we can't even represent this number in ZFC... but isn't it totes cool?"
01:08:59 <MarcelineVQ> ventonegro: use a concrete type for your numbers, chances are the use of some typeclass is causing _
01:09:11 <merijn> ventonegro: Sounds like DMR to me :)
01:09:16 <merijn> Or rather
01:09:18 <ventonegro> oh
01:09:27 <merijn> The absence of monomorphism restriction in ghci
01:10:13 <nshepperd> kadoban: it's important to fill up your physical memory efficiently!
01:10:25 <kadoban> nshepperd: Haha, indeed
01:10:29 <ventonegro> Setting the type to [Integer] did it
01:10:54 <kadoban> It's also funny when the computational model breaks to hell, when you assume that addition is constant cost.
01:11:17 <thang1> Oh, whoops. Sum_{i = 1}^n F_i = F_{n + 2} - 1
01:12:04 <thang1> kadoban: you mean to say that constants matter in algorithmic complexity? Blasphemy. CS only cares about the numbers - inf, 0, 1, 2, inf /s
01:12:13 <thang1> (and -1 sometimes)
01:12:44 <merijn> ventonegro: Incidentally, this is why the monomorphism restriction is a good thing. In compiled files it prevents you from accidentally recomputing that list every time (since it either 1) specialises the type or 2) produces a compile error)
01:13:24 <kadoban> Well, more saying that it matters what your computational model is, and that it does something approximating sanity. But yes that too.
01:13:26 <nshepperd> thang1: is the story more complicated if the fibs are filtered for even?
01:13:51 <thang1> Vaguely so, but fibs are pretty nice in this regard
01:14:03 <kadoban> Every third one is even, right?
01:14:12 <kadoban> Which could help, but it still seems complicated.
01:14:16 <thang1> Sum of first odd fibs are F_(2n), sum of first even fibs is F_(2n + 1) - 1
01:14:45 <thang1> And the sum of the squares of the first n fibs is F_n * F_(n+1)
01:15:38 * hackage prettyprinter 1, prettyprinter-compat-ansi-wl-pprint 1, prettyprinter-compat-annotated-wl-pprint 1, prettyprinter-ansi-terminal 1 (quchen): https://qbin.io/e5ao072
01:16:44 <nshepperd> convenient
01:17:59 <nshepperd> i think by default I would reach for... a six by six matrix, or something. to add up the sum of every third directly
01:18:33 <merijn> quchen: \o/
01:18:38 <quchen> merijn: :-)
01:19:03 <quchen> merijn: Ran out of reasons not to release it officially. Reddit etc. coming soon.
01:19:30 <merijn> quchen: Now to hassle edwardk into updating Trifecta so I can migrate my language's prettyprinter ;)
01:20:10 <quchen> Hehe
01:20:22 <thang1> Why Trifecta over megaparsec?
01:20:43 <merijn> thang1: Prettier error reporting
01:21:07 <thang1> Like, more useful or just prettier?
01:21:18 <merijn> Mostly just prettier :p
01:21:30 <nshepperd> huh. the matrix trick really works for any loop where the iteration step is a linear function
01:21:51 <thang1> Seems like a silly reason to yank in all of lens just for a parser :p but, more power to you
01:21:54 <merijn> thang1: Like, coloured/underlined output highlighting the parser error location (similar to what e.g. clang produces)
01:22:20 <thang1> Oooh, that's actually pretty neat tbh. I would've thought megaparsec did that
01:23:11 <merijn> thang1: trifecta/parsec are really for "library parsers" anyway, more userfacing/application parsers (i.e. compilers, in my case), so who cares about dependencies, only build them once anyway :)
01:25:21 <quchen> thang1: Prettier errors means a dramatically better parser lib.
01:25:38 <quchen> thang1: Try using Idris, and compare its errors to Haskell’s.
01:25:51 <merijn> quchen: GHC8 and later are improving *a lot*
01:25:53 <quchen> Idris uses Trifecta, and its errors are pretty awesome.
01:26:13 <quchen> Improving isn’t enough to compete here – Idris is *way* ahead of GHC.
01:26:25 <quchen> Not to bash on GHC, but to emphasize how useful good parser errors are.
01:29:31 <cocreature> quchen: yeah \o/
01:30:02 <thang1> merijn: makes sense. I wouldn't have thought about the dependency issues that way
01:30:21 <cocreature> quchen: what kind of changes do you need in trifecta?
01:30:29 <kuribas> What's a good image processing library?  I looked at hackage, but I find a lot of fragmentation.
01:30:44 <merijn> cocreature: I think it's just replacing the dependency with the compat shim?
01:31:00 <Xion_> GHC aren't too bad tbh, and I'm comparing them with rustc which has *marvellous* error reporting.
01:31:15 <Xion_> One thing that would be useful was quoting the line instead of just giving a number.
01:31:17 <thang1> I wonder what rustc uses for their errors
01:31:20 <quchen> cocreature: Change the dependency mostly
01:31:22 * nshepperd finds that the best way to deal with libraries depending on lens is to already have lens built :p
01:31:30 <cocreature> oh right, I forgot that trifecta includes pretty printing
01:31:33 <thang1> And tbh the things I would like most with ghc's errors is just reducing the amount of data that's shown
01:31:50 <quchen> cocreature: The drop-in compatibility modules solve the migration problem, but it would need maybe 15 minutes of work to do the proper switch
01:31:50 <cocreature> Xion_: GHC’s compile errors aren’t so bad. GHC’s parse errors are terrible
01:32:01 <merijn> The One Prettyprinter, that binds them all ;)
01:32:02 <Xion_> Yeah, all these "in the second argument of" could be just shown visually with an ASCII art arrow
01:32:07 <thang1> Right, their parse errors make me want to shoot myself :p
01:32:40 <Xion_> cocreature: I've mostly seen them as "parse error at line X", and the X was correct more often than not :)
01:33:07 <thang1> like 4 lines of boilerplate before you even get to the error, then there's an entire pargraph describing where in the code in the error was, and the 5 words of relevant information are buried somewhere in the middle
01:33:42 <thang1> repeat for /every/ single parse error, of which there will likely be at least 2-4 for every typo you make because haskell is very terse and if you mess one thing up you probaby messed up a few others too
01:34:08 <MarcelineVQ> the ghc team is always looking for a hand if you find the desire to improve the error messages
01:34:32 <thang1> Sure. My proposal got shot down for summer of haskell anyway.
01:34:56 <thang1> What does ghc use for error messages anyway? Parsec internally?
01:34:59 <cocreature> MarcelineVQ: well improving the parser errors would probably require moving away from alex/happy and that has quite a few downsides as well
01:35:02 <cocreature> thang1: alex/happy
01:35:20 <thang1> right... alex and happy.
01:35:48 <thang1> So, what are some of the downsides to not using alex and happy? They seem like huge projects in haskell lore yet I almost never see anyone talk about them
01:36:40 <merijn> thang1: alex/happy are basically "haskell lex & yacc"
01:36:54 <cocreature> thang1: you need to left factor your grammar
01:37:10 <merijn> So, parser generators. The advantage of those is: They generate efficient parsers. The downside, it's a pain
01:37:21 <merijn> cocreature: I think both happy and bison are GLR nowadays
01:37:47 <cocreature> merijn: I was talking about the downsides of _not_ using alex/happy, i.e., using parsec or something like that
01:37:57 <thang1> ah, right.
01:38:24 <merijn> Well, you don't have to left-factor your grammar, you could just write a REALLY slow parser :p
01:38:59 <thang1> Is there no way to use something like alex and happy and then just plug things into a pretty printing capable parser?
01:39:20 <cocreature> merijn: well your error messages also become crappy if you just use "try" everywhere so you loose one important benefit of using them over alex/happy
01:39:39 <merijn> cocreature: Well, that's why you should be careful with where you put try :p
01:39:39 <thang1> Because, generating efficient parsers is cool, but the pain definitely comes from error messaging and handling anything that's not super "generatable"
01:40:13 <thang1> (If I'm thinking correctly on downsides/benefits of generating vs writing your own parser)
01:40:14 <cocreature> merijn: which means that you need to left-factor your grammar :P
01:41:53 <ventonegro> Is there a book or other comprehensive material about EDSLs in Haskell?
01:42:14 * nshepperd_ . o O (write a total grammar and explicitly handle every possible parse error)
01:42:19 <ventonegro> I know there are plenty of papers lying around
01:44:42 <quchen> cocreature: The documentation on Hackage built faster than I could have locally. There was some magic involved
01:45:14 <merijn> ventonegro: What kinda material are you looking for?
01:45:53 <cocreature> quchen: sometimes it works pretty well. I’ve just gotten used to not trusting it :)
01:48:16 <merijn> thang1: Well, if you need other usefull Haskell work that's less intimidating, I've got some suggestions ;)
01:48:25 <merijn> (less intimidating than GHC, that is)
01:48:56 <kuribas> Does anyone have experience with image processing?
01:49:04 <thang1> I'm definitely open to suggestions :p
01:49:35 <thang1> kuribas: programatically? Eh, not really. I can photoshop stuff pretty well but that's not really what you're looking for, I'm assuming?
01:49:48 <thang1> I know how to use feh to set my wallpaper, does that count? :p
01:49:55 <kuribas> thang1: I'd like to know what is a good library for haskell...
01:50:48 <Xion_> I was messing with my meme generator code last weekend to optimize the captioning of animated GIFs; does that count? :)
01:51:18 <kuribas> Xion_: sure
01:52:25 <ventonegro> merijn: Something that starts simple but builds up and deals with sharing, using the type systems for proving that no memory access is out of bounds, etc.
01:52:38 <ventonegro> I am thinking about generating C
01:53:03 <merijn> thang1: I've been adding a bunch of stuff to criterion, including a (VERY!) basic tool that can produce HTML reports from JSON result files (so you don't have to rerun benchmarks to generate plots from them), but there's a bunch of stuff that I want to add to it and I have a hard time finding the time :p
01:54:30 <thang1> oooh neat, HTML
01:54:43 <thang1> I've always wanted to use some of haskell's regex libraries
01:54:55 <merijn> thang1: Specifically, the ability to filter, combine, reorder, and group JSON output (i.e. sorta preprocessing the JSON results)
01:55:05 <cocreature> thang1: trust me you don’t want to use them
01:55:08 <merijn> thang1: afaict it shouldn't be all that hard to do implement
01:55:23 <thang1> cocreature: It was a joke about how everyone tries to process HTML with regex :p
01:55:55 <cocreature> although chris dormamn seems to be working on making regex in haskell less horrible
01:56:32 <jambon69> hi o/
01:56:34 <thang1> merijn: so currently you run the benchmarks once to generate JSON result files and then run them again to generate plots from those files?
01:57:57 <merijn> thang1: No, you can produce JSON and plots at the same time and I added a tool to basically plot the resulting JSON files (so you don't have to immediately plot them). What's lacking is the ability to filter, combine, reorder, and group reports from existing JSON file and plotting those
01:58:29 <hanna> I usually find it much easier and more long-term viable to use parsec combinators instead of regex
01:58:47 <thang1> hanna: the regex was definitely a tongue-in-cheek joke :p
01:58:57 <hanna> ah
01:59:24 <Xion_> Since Parsec et al. are pretty easy to use, I'm not sure not having a great regex library is such a problem.
01:59:35 <merijn> But there's plenty of low hanging fruit like this in many libraries, I think. Just needs people to pick it up and be stubborn enough to get it merged :)
01:59:59 <hanna> Xion_: unless you want to accept user regex input
02:00:06 <hanna> like as a config option
02:00:08 <thang1> merijn: makes sense. So basically, doing all that in haskell is simply loading up the json and pre-processing it a bit and then running the output tool?
02:00:25 <Xion_> But yeah, a lib which works for all three of (1) string regexes (2) applicative style operators (3) TH-based in-language regex syntax would be great
02:01:43 <thang1> And I'm guessing an ideal workflow for the end user would be something like: Write up small 'config' file to group, filter, etc., the charts/graphs. Run the benchmarks and have the output give you the JSON and the html seamlessly, using the config file?
02:02:03 <merijn> thang1: I mean this https://github.com/merijn/criterion/blob/master/app/Report.hs already loads the reports and produces the report. Some things to do would be: 1) the ability to filter the loaded reports 2) load multiple files to read data from 3) output new "combined" JSON from loaded files, etc.
02:02:48 <merijn> thang1: I'm not even sure a config file would be necessary. If you can conveniently recombine/split/filter JSON files and output new JSON you can easily shell script that sorta thing :)
02:03:37 <thang1> I'm just thinking that the venn diagram of users who a) "can easily shell script stuff" and b) "want pretty graphs for benchmarking analysi" is kinda small :p
02:04:36 <merijn> thang1: Criterion isn't really aimed at naive users. It's for programmers who want to benchmark their code, so I'd assume 100% can shell script
02:04:48 <merijn> Also, who doesn't want pretty graphs? Have you seen criterion's output? It's awesome
02:05:07 <thang1> Besides, I'm not really sure how one would integrate a recombine/split/filter JSON file utility into the project (to be used with shell scripting) without ending up with a general JSON manipulating tool that's got a bunch of shortcut functions and helper functions defined
02:05:21 <thang1> I have. The output is beautiful and your site/documentation is top notch too :p 
02:06:36 <merijn> thang1: Well, the thing is it already has functions in the library to read/write them :)
02:06:47 <merijn> "readJSONReports :: FilePath -> IO (Either String ReportFileContents)"
02:06:55 <merijn> "writeJSONReports :: FilePath -> [Report] -> IO ()"
02:07:19 <merijn> So, really just fiddling/manipulating the resulting [Report] list to only contain what you want is all that needs to be done :)
02:08:02 <merijn> pandoc can probably also use additions
02:08:14 <merijn> Are you can badger people into migrating to quchen's prettyprinter :p
02:08:20 <thang1> http://www.serpentine.com/criterion/fibber.html So for this example, the only kind of customization of output you're thinking of is choosing which of the fib/1 fib/5 fib/9 fib/11 graphs to show and what order to show them in?
02:09:25 <merijn> thang1: Well, for example, I currently have a set of 3.8k benchmarks, and I don't want to rerun all of them if one of them changes, so I want to basically manipulate things so I can just easily include the newly run benchmarks and generate the new plots I want
02:09:48 <merijn> Probably not all of those are useful, but I'm not sure which ones I wanna keep yet :p
02:11:13 <thang1> ahh, I gotcha
02:13:04 <thang1> So just looking at the fib html page, intuitively the kinds of things I would "do" to the graph page is I would like to be able to collapse all of one type of chart into a single chart. So for example, plotting 1, 5, 9, 11, ..., of the fib time densities on a single chart to easily compare them
02:14:08 <merijn> thang1: carter was doing some similar work, see: https://github.com/bos/criterion/issues/62
02:14:21 <thang1> Another thing that would be really useful is (idk the right term for it) showing commonalities among different benchmark sizing? The regression chart, for example, has a very similar distribution of dots for a lot of things
02:14:24 <merijn> thang1: i.e. instead of having one big group, create smaller subgroups
02:15:43 <thang1> right, that sort of customization is very useful
02:16:17 <thang1> It seems separate to the issue of only compiling a subgroup of charts, but now that I think about it, I do think they're linked together a bit
02:17:05 <merijn> quchen: You had some stuff you didn't have time for, right?
02:19:42 <sternmull> what is the most elegant way to define a function that subtracts one? Is "\x -> x - 1" the best i can get?
02:20:25 <thang1> f x = x - 1 is exactly equivalent to \x -> x - 1
02:20:26 <cdornan_> cocreature: absolutely -- regex should be quite usable now -- continuing to work on it and suggestions always welcome
02:20:58 <Xion_> :t (- 1)
02:20:59 <lambdabot> Num a => a
02:21:08 <Xion_> ;/
02:21:18 <Xion_> :t ((-) 1)
02:21:20 <lambdabot> Num a => a -> a
02:21:25 <Xion_> Well too bad that's the other way around
02:21:33 <cdornan_> Fwiw I would suggest Haskellers give regex a try if it looks applicable
02:21:38 <sternmull> Xion_: yes, i tried that already :)
02:21:53 <Xion_> :t (`-` 1)
02:21:55 <lambdabot> error: parse error on input ‘-’
02:22:00 <Xion_> mkay
02:22:08 <thang1> You have to wrap - in its own parenthesis because (-1) is syntactic sugar for (negate 1) aka "negative 1"
02:22:28 <thang1> :t ((-1) 1) -- this does what you want
02:22:29 <lambdabot> (Num (t -> t1), Num t) => t1
02:22:42 <Xion_> You'd have to define    minus = (-) and then use (`minus` 1) I guess
02:22:43 <cdornan_> For a long time Haskellers have been avoiding it, which looks like a wrong turn
02:22:48 <yushyin> :t (subtract 1)
02:22:49 <lambdabot> Num a => a -> a
02:22:53 <Xion_> Ah
02:23:19 <thang1> > ((-)1) 1 
02:23:21 <lambdabot>  0
02:23:33 <thang1> > (subtract 1) 1
02:23:35 <lambdabot>  0
02:23:57 <sternmull> yushyin: Thanks! Thats what i was looking for.
02:24:01 <thang1> It's a bit annoying, but in the grand scheme of things, I don't really know if it's worth the bike shedding...
02:24:30 <EggsHendrix> does anyone here write haskell professionally?
02:24:41 <thang1> Now the thing that really messes with me is this
02:24:46 <thang1> > foldr (-) 0 [1..10]
02:24:48 <lambdabot>  -5
02:25:11 <thang1> > foldr subtract 0 [1..10]
02:25:13 <lambdabot>  -55
02:25:33 <Xion_> EggsHendrix: I kiiinda do (or at least will soon).
02:26:18 <thang1> Does anyone have a sane reason for why those two foldrs behave so differently?
02:26:51 <ventonegro> > foldr (flip subtract) 0 [1..10]
02:26:53 <lambdabot>  -5
02:27:19 <thang1> Literally just as I figured that out :p okay, I'm not crazy, woo
02:28:23 <thang1> > foldr (flip (-)) 0 [1..10] -- Shame you have to write it this way
02:28:54 <thang1> > foldr (+) 0 [1..10] -- so much nicer
02:29:11 <thang1> o.O did lambdabot die?
02:29:45 <EggsHendrix> Xion_: neat, a new job or convincing current people to let you?
02:30:15 <lambdabot>  55
02:30:15 <lambdabot>  -55
02:31:33 <Xion_> EggsHendrix: New job, still in the so-called "bootcamp" where we do things for different teams and decide which one we want to join. I did some stuff for a team that uses Haskell and strongly considering joining it.
02:32:20 <merijn> Right!
02:32:23 <EggsHendrix> sounds like a cool oppurtunity man
02:32:31 <merijn> New initiative, people! https://wiki.haskell.org/Yak_shaving
02:32:48 <merijn> Add your small projects/tasks that you don't have time for!
02:32:52 <thang1> woo! My specialty
02:33:13 <EggsHendrix> lol
02:33:27 <thang1> dude you got no idea how many dozens of hours of work I should've done by now
02:33:40 <thang1> However, I am halfway through chapter 14 in the Haskell Book so I got that going for me, which is nice
02:33:41 <EggsHendrix> looks cool, what's with the name
02:33:54 <merijn> thang1: You're talking to the person writing a "bash history daemon" to fix his shell history
02:33:57 <EggsHendrix> thang1: which book
02:34:14 <thang1> oh, yak shaving is a popular term for "I need to be doign something productive, but instead I'm going to do (insert shiny useless thing as a way to procrastinate)"
02:34:20 <EggsHendrix> i wrote an irc bot to procrastinate exam revision
02:34:27 <merijn> EggsHendrix: https://www.techopedia.com/definition/15511/yak-shaving
02:34:27 <thang1> nice
02:34:35 <merijn> thang1: Not quite
02:34:44 <EggsHendrix> now i've finished exams, im procrastinating fixing the bot by actually reading the books i should have been revising from
02:34:51 <thang1> EggsHendrix: Haskell From First Principles
02:34:59 <EggsHendrix> thats a cool book
02:35:04 <thang1> EggsHendrix: amazing how our brains work, innit?
02:35:08 <merijn> thang1: It's a term for "I'm doing something which SEEMS unrelated to my actual work, but is actually solving a problem 20 steps removed to help my original task"
02:35:14 <thang1> Have you read it at all?
02:35:25 <thang1> merijn: ahh right.
02:35:26 <EggsHendrix> i've been through most of it yeah
02:35:37 <EggsHendrix> i like the approach it takes
02:36:12 <EggsHendrix> was useful to go through before heading back to real world haskell and doing the things that didn't make a whole lot of sense
02:37:49 <thang1> My favorite example of this: http://i.imgur.com/rQIb4Vw.gifv 
02:38:16 <thang1> Isn't real world haskell mostly outdated and not super great anymore?
02:38:59 <Xion_> EggsHendrix: It's also gonna involve some C++ (C++14 fortunately which is pretty okay) and PHP but I'm willing to endure that :)
02:39:30 <merijn> thang1: Real World Haskell is kind of old, and not great forlearning Haskell. But it's still decent as a library documentation thing
02:39:47 <merijn> thang1: Most libraries have evolved a bit, so the examples don't work as-is, but the high-level explanation is still valid
02:40:02 <merijn> thang1: So it's still, e.g. a decent intro to "how do I Parsec?"
02:40:05 <thang1> Gotcha. Hopefully Joy of Haskell and/or some of the intermediate stuff coming out will offer a compelling replacement to it :p
02:40:20 <merijn> The profiling stuff is also still useful
02:40:27 <merijn> But I'd mostly recommend it as a reference book
02:40:57 <EggsHendrix> RWH is pretty good for the hugely extended little case studies it has
02:41:19 <EggsHendrix> quite useful for wasting a not inconsiderable amount of time while also feeling productive
02:41:23 <EggsHendrix> which i guess is the real goal
02:44:47 <kuribas> merijn: it would be great if updated, and including Applicative/Monoid, etc...
02:45:08 <EggsHendrix> the wikibook was surprisingly good for a lot of stuff
02:45:25 <EggsHendrix> https://en.wikibooks.org/wiki/Haskell
02:45:46 <EggsHendrix> a bit higgeldypiggeldy in true wikibook fashion, but there's some nuggets in there
02:47:06 <EggsHendrix> on an unrelated note, i've yet to write a typeclass in anger, and I want to rectify that
02:51:26 <thang1> anger the language or the motion?
02:54:40 <reactormonk[m]> What's the syntax on class constraints with data constructors?
02:55:38 <merijn> reactormonk[m]: What do you mean?
02:56:47 <d3f5tryk3r> anyone got a good resource for getting my feet wet with abstract algebra (groups, rings and stuff) ?
02:57:53 <reactormonk[m]> e.g. data OAuth2Service (MonadResource m) err = OAuth2Service {
02:58:05 <EggsHendrix> thang1: i mean while writing any code that isn't following a guide
02:58:22 <wz1000> d3f5tryk3r: There's a nice harvard lecture series by Benedict Gross on youtube.
02:58:40 <Xion_> data OAuth2Service (MonadResource m) => err = OAuth2Service { -- iirc
03:00:29 <d3f5tryk3r> wz1000, thanks will check it out. For number theory im looking at the book by Hardy & wright. any better choices?
03:00:51 <d3f5tryk3r> Just starting out in both..
03:02:39 <Taneb> d3f5tryk3r, hardy and wright's book goes into quite the detail, but from what I recall, it's pretty good
03:02:45 <reactormonk[m]> merijn: https://gist.github.com/16632c2f2ee7990957bac7c4d6d4c2a4 ?
03:02:53 <Taneb> Certainly helped me pass my number theory module at uni
03:03:24 <d3f5tryk3r> Would it be comprehensible to someone just starting out? 
03:06:02 <dawei> test
03:06:04 <Taneb> d3f5tryk3r, it should be, although you may have to take your time with it
03:06:11 <thang1> Hmm...
03:06:29 <thang1> my kingdom for the ability to paste code into emacs and have the haskell code be indented correctly
03:13:54 <quchen> merijn: »Stuff I didn’t have time for«?
03:14:38 <fendor> hey, did someone try to integrate coveralls into the travis build process for haskel?
03:21:34 <angerman> quchen: congrats to the release!
03:21:51 <quchen> Thanks! Was long overdue :-x
03:22:13 <angerman> ahh well, good things take time ;-)
03:35:45 <thang1> What are we congratsing about again?
03:36:39 <thang1> reactormonk[m]: that's one hell of a datatype ...
03:46:09 <fendor> hey, did someone try to integrate coveralls into the travis build process for haskel?
03:46:32 <thang1> Well I haven't tried to do that, so that's one less person you have to ask :p
03:46:49 <fendor> :( 
03:47:07 <thang1> sorry :(
03:47:11 <fendor> it's ok :( 
03:47:20 <thang1> I know someone's working on the testing suite for haskell's summer of code
03:47:22 <fendor> i like you anyways
03:47:31 <fendor> haskell's summer of code?
03:47:34 <thang1> and you can check some of the other stuff on the summer of code accepted projects to see if corvallis is on there
03:47:40 <mekeor> fendor: idk. what is this?: https://github.com/guillaume-nargeot/hpc-coveralls
03:47:49 <thang1> summer.haskell.org
03:47:58 <thang1> https://summer.haskell.org
03:48:00 <fendor> thang1, cool looking into that
03:48:11 <fendor> mekeor, only works with cabal and i have troubles using this with stack
03:49:45 <fendor> in the meantime, using HPC, are there some way to make pull requests to improve the webinterface?
03:51:51 <Eduard_Munteanu> How do you get to the angular scope from plain HTML?
03:52:06 <Eduard_Munteanu> Oops, wrong channel.
03:57:16 <merijn> quchen: We were discussing like pretty printer, interactive web version of stgi, etc. and you mentioned you didn't have time for like the web version of stgi.
03:58:21 <merijn> quchen: So I figured, let's make a wiki page to write down these sorta small/medium projects, so next time someone asks "what's something I can implement in haskell?" we can just point them there :p
03:58:25 <merijn> quchen: https://wiki.haskell.org/Yak_shaving
04:03:36 <quchen> Hehe
04:04:02 <quchen> merijn: That sounds less like yak shaving but rather than work delegation.
04:04:26 <thang1> Well the yak shaving comes from why we made the page in the first place
04:04:27 <merijn> quchen: Well, it's where you put the yak shaving that you keep putting off ;)
04:04:29 <quchen> I thought about donating to Haskell.org given someone fixes something – 100€ for documenting Trifecta for example :-
04:04:51 <merijn> quchen: I don't suppose copy/pasting my parser using Trifecta would qualify? ;)
04:04:53 <thang1> "I should do this -> instead of doing this I'm gonna complain on irc -> Or I could make a wiki page on things I want fixed...."
04:05:11 <quchen> merijn: Haha, that’s how STGi’s parser was made
04:05:17 <merijn> thang1: Well, the thing is, I'm not doing it because I have other stuff I need to finish first :)
04:05:33 <merijn> quchen: I know, I think at least 10 people learned trifecta from my parser :p
04:05:56 <quchen> merijn: I’m still impressed you did not have that code to learn from
04:06:15 <quchen> Trifecta isn’t even hard to use, but there are too many classes involved and there are no docs
04:06:18 <merijn> quchen: I just started at edwardk's stuff for a long time
04:06:23 <merijn> s/started/stared
04:06:27 <quchen> The initial hurdle is way too high, after that it’s smooth sailing
04:06:48 <thang1> Ahh, followed the Feynman method, eh?
04:07:03 <thang1> Step 1: Write down problem. Step 2: Think very hard. Step 3: Write down solution.
04:07:47 <merijn> So I basically reverse engineerd Ermine's parser :)
04:19:30 <quchen> merijn: Rewriting STGi for the browser wouldn’t even be that difficult I think, the main problem is you have to like frontend work
04:20:01 <merijn> quchen: Prime candidate for outsourcing ;)
04:20:31 <quchen> It would make a decent Bachelor’s thesis I guess.
04:20:47 <quchen> For those German universities that stick to the rules about them, i.e. not over 2 months.
04:21:00 <merijn> ooooh...
04:21:08 <merijn> I should sucker some bachelors into doing my work...
04:21:28 <quchen> It’s a valid and useful task, you don’t need to make it sound so negative!
04:21:49 <quchen> Learning about the STGi was – by a huge margin – the most useful thing I’ve done in Haskell in the last years
04:22:05 <quchen> s/STGi/STG/
04:22:08 <merijn> quchen: No, I meant more for my own more trivial things :)
04:22:25 <quchen> I hope you’re not a PhD student somewhere
04:22:34 <merijn> >.>
04:22:39 <quchen> Otherwise you’re that horror supervisor ;-)
04:22:49 <hpc> i was about to say, if you're going to make students do your boring crap do it right and hire grad students :D
04:23:59 <merijn> I am a grad student, I don't have money to hire grad students :(
04:34:50 <campezzi> hey folks. I'm working through the Haskell from First Principles book and got a question about the Applicative instance for the State monad. can anyone give me a hand?
04:38:13 <lpaste> campezzi pasted “State Monad - Applicative Instance” at http://lpaste.net/355936
04:39:27 <campezzi> If someone can take a look at that applicative instance... I'm wondering if I got it right. specifically <*>
04:44:22 <Xion_> I'm not sure but I think it's a wrong order of application
04:45:22 <campezzi> exactly
04:45:32 <Xion_> Your state is being propagated backwards
04:45:45 <campezzi> I think this is the correct way... paste incoming
04:46:16 <lpaste> campezzi pasted “Applicative, Corrected” at http://lpaste.net/355938
04:48:47 <quchen> campezzi: Looks good to me.
04:48:57 <lyxia> both are technically correct in that they satisfy applicative laws, but the standard instance is the second one
04:49:09 <quchen> campezzi: There are indeed two state Applicatives (and also two Monads). One is sensible, the other one is crazy and confusing.
04:49:09 <campezzi> I like this book, but they should really have a companion repo with the solutions. It's a little frustrating to not know if I got it right
04:50:45 <campezzi> I've been following along checking my results against this guy's repo, but I think he got the Applicative instance wrong here by discarding the state with fst: https://github.com/lukleh/haskell-book-exercises/blob/gh-pages/ch23/ch23_23.6_1.hs#L21
04:51:10 <vbCrLf> Hey, say I have a polymorphic function like "func a = show a". How can I change its behavior depending of an argument type?
04:51:29 <vbCrLf> For example, in this case I want to return "Hello" for Num, and "show a" for everything else
04:53:28 <quchen> vbCrLf: That will do whatever »show« does for that type.
04:53:40 <quchen> func a = show a, that is.
04:53:41 <Xion_> I don't think Haskell permits ad-hoc function overloading.
04:54:07 <Xion_> You'd have to define a typeclass where `func` is a method and then define instances for the types you want to "overload" it for.
04:56:03 <lyxia> campezzi: indeed it's wrong
04:56:23 <campezzi> I'll submit a PR
04:58:12 <itsu> Hi guys, beginner question here. I want to bind both a ReaderT and a Maybe. I have a a=`ReaderT a b (Maybe c)` and a b=`c -> ReaderT a b (Maybe c)`. Is there a way to do something like `a >>= b` and binding both the Reader and the Maybe monad ?
04:58:29 <itsu> if it helps a bit, I have this pastebin http://lpaste.net/355939
05:00:31 <lyxia> itsu: when you write   a >>= \x ->   x has type Maybe c, so you can pattern match on it
05:02:40 <Xion_> Shouldn't that be `ReaderT r Maybe a` if you want a monad stack with `Reader r` and `Maybe a`?
05:03:22 <itsu> lyxia: yeah I could do that indeed but if I have many successive functions, then I have to pattern all of them 
05:03:45 <itsu> which is bit tedious, I'd rather do a >>= b >>= c 
05:04:04 <itsu> but maybe this is impossible ?
05:04:21 <lyxia> then this is the MaybeT monad transformer
05:04:28 <vbCrLf> Xion_: Maybe it can be done with typeOf? Will it have any performance penalty?
05:04:42 <Xion_> Yeah it seems you want `ReaderT r MaybeT IO a`
05:04:45 <vbCrLf> I could do "typeOf a == typeOf 4"
05:05:01 <vbCrLf> (it wouldn't be Num but an Integer, but it might be enough)
05:05:10 <Xion_> :t typeOf
05:05:11 <lambdabot> Typeable a => a -> TypeRep
05:05:18 <Xion_> Oh that's the Typeable stuff
05:05:28 <Xion_> No idea, maybe :) Haven't work with Typeable
05:05:39 <vbCrLf> Okay :) Thanks! I'll try
05:05:40 <lyxia> vbCrLf: Typeable has a performance penalty
05:05:58 <Xion_> Yeah, I imagien it's the equivalent of typeid/dynamic_cast from C++
05:06:00 <lyxia> and it won't allow you to tell whether a Num instance exists
05:06:16 <vbCrLf> If I compile it, wouldn't it be in compile time?
05:06:26 <itsu> lyxia: Xion_ thank you for that, I'll try with MaybeT
05:07:24 <lyxia> vbCrLf: Typeable is precisely for types you can't check at compile time
05:08:16 <lyxia> vbCrLf: you shouldn't need it in the first place in a situation where you have enough information at compile time for it to be optimized away
05:10:41 <vbCrLf> lyxia: Pattern-matching on type can be optimized at compile-time, but I don't see how to do it
05:11:00 <vbCrLf> I mean, it does have enough information at compile-time
05:11:16 <vbCrLf> haskell knows the type of everything
05:11:44 <NextHendrix> @let (😂) = `fmap`
05:11:45 <lambdabot>  Parse failed: Parse error: `
05:12:18 <NextHendrix> @let (😂) = (<$>)
05:12:19 <lambdabot>  Defined.
05:12:36 <NextHendrix> > (+1) 😂 [1..5]
05:12:38 <lambdabot>  [2,3,4,5,6]
05:12:43 <NextHendrix> amazing
05:14:46 <NextHendrix> til custom emoji operators work fine
05:18:22 <dawei> test
05:23:08 <ventonegro> This gives a whole new meaning to undecipherable operators :)
05:28:10 <NextHendrix> ventonegro: https://ptpb.pw/Cxen.png
05:29:08 * hackage google-oauth2-jwt 0.2.0 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.2.0 (MichelBoucey)
05:30:42 <Xion_> Someone should write a semi-serious category theory paper introducing a Chat category where the operators are emoji.
05:43:36 <mettekou> Has anyone implemented (quasi)quotation through either the bound or unbound library?
05:51:08 * hackage google-oauth2-jwt 0.2.1 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.2.1 (MichelBoucey)
05:54:38 * hackage teleshell 0.1.0.0 - Telnet client and other things  https://hackage.haskell.org/package/teleshell-0.1.0.0 (andrewthad)
06:00:39 <tfc[m]> hi there. i have a program that does a Control.Monad.Parallel.mapM_ on some functions that loop over work packets. now i added an MVar that is set to True by a sigInt handler. then, the threads in the MP.mapM_ shall check if that mvar is true on every loop iteration. if it is, abort the loop. now the problem that i observe is that they are all interrupted during their work (falling out of a tryIOError call, which i would like
06:00:39 <tfc[m]> to avoid!)
06:01:34 <Xion_> Not familiar with parallel monad but sounds like you need to setup a signal mask for each thread but the main one?
06:02:32 <tfc[m]> i see. i will try that.
06:02:59 <tfc[m]> i hoped my signal handler would be called and each thread (whoever received the signal!) would just continue wherever it was.
06:03:33 <Xion_> I think the problem is that Unix makes it undefined which thread receives a signal.
06:04:14 <tfc[m]> Xion_ but if i run on that MP.mapM_ and mask for every thread, i think there will be no thread left that receives it, right? is it possible that i need to do a forkIO so at least the main thread can receive it?
06:04:27 <Xion_> You'd still have the main thread, right?
06:04:47 <Axman6> tfc[m]: for that an IORef may be more appropriate btw - you're not really relying on the properties MVars give you, while introducing contention (this isn't related to your problem though)
06:05:21 <tfc[m]> Xion_ the main thread just blocks on the the MP.mapM_
06:05:37 <tfc[m]> Axman6: ok i see. so if i get my signal problem fixed i will ahve a look at the ioref. thx.
06:05:52 <Xion_> http://www.linuxprogrammingblog.com/all-about-linux-signals?page=11
06:06:12 <Xion_> Yes, but it is still a thread, meaning it can received signals if it has them unmasked
06:06:17 <Xion_> receive*
06:06:23 <tfc[m]> ok i see.
06:07:36 <Xion_> You can also use this approach: http://www.serpentine.com/blog/threads-faq/mixing-threads-and-signals-unix/
06:08:53 <tfc[m]> wow this really sounds like what i need. thanks Xion_!
06:13:32 <Xion_> Cool :)
06:15:10 * shapr hops cheerfully
06:15:13 <shapr> yay Haskell!
06:20:05 <Rembane> Haskell <3
06:20:10 <ertes-w> tfc[m]: signals are received by processes, not threads, and the signal handler runs in a new thread
06:20:17 <ertes-w> the latter is haskell-specific
06:21:03 <ertes-w> i think it wouldn't even really make sense for it to run in an existing thread…  that would make it semantically questionable
06:22:04 <ertes-w> tfc[m]: the boolean is kind of a "quit now!" flag?  if yes, why don't you just kill the threads?
06:22:18 <tfc[m]> ertes-w: i am currently studying documentation to do what the link says that Xion_ sent. 1.) mask sigINT for all threads initially. 2.) fork another thread that receives just that signal and modifies my MVar 3.) launch all the threads
06:22:40 <merijn> Interesting question, actually
06:22:48 <tfc[m]> ertes-w: it shall work with the semantic like "please quit as soon as you're done with your current work."
06:22:49 <merijn> I'm not quite sure how the RTS deals with signals
06:22:58 <ertes-w> tfc[m]: you can do that with killing
06:23:02 <tfc[m]> so it's fine if the app quits 3 minutes after hitting ctrl-c
06:23:46 <tfc[m]> ertes-w: so how can you kill a thread "softly"?
06:24:08 <ertes-w> tfc[m]: all kills are soft in haskell:  killThread merely throws a ThreadKilled exception at the thread
06:24:15 <ertes-w> it's an async exception that you can handle
06:24:31 <sternmull> In GHC with DuplicateRecordFields the code "data Foo = Foo {x :: Int}; data Bar = Bar {x :: Int}; fcn :: Foo -> Int; fcn foo = x foo" fails with "It could refer to either the field ‘x’ ...". How the heck can GHC not know what i mean? x :: Bar -> Int is obviously no candidate in this place...
06:24:33 <NextHendrix> tfc[m]: https://youtu.be/oKOtzIo-uYw
06:24:37 <ertes-w> well, there is one exception:  when the main thread exits, all secondary threads are hard-killed
06:24:59 <merijn> ertes-w: Not even that
06:24:59 <tfc[m]> hm yeah the problem is that i have tryIOError $ withTimeout... hRead calls. it drops out of those, and i really do not want those threads to even know about signal handling.
06:25:25 <merijn> ertes-w: I think it's just that when the main thread exits it just exits the process, there's no step terminating threads in between, afaik
06:27:29 <sternmull> changing it to "fcn foo = x (foo::Foo)" satisfies GHC. But that seems redundant to "fcn :: Foo -> Int" which already is there.
06:33:27 <sternmull> Obviously this is the expected behavior (https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#selector-functions). But i don't see why one would want this.
06:34:16 <ertes-w> merijn: yeah, that's what i mean by "hard-killed"
06:34:38 <ertes-w> basically they just stop executing no matter what they were doing or whether they were masked, etc.
06:34:56 <ertes-w> honestly i find that quite unfortunate
06:36:17 <lyxia> sternmull: it requires changes to the type checker or to the way the extension is implemented (which probably does name resolution before type checking).
06:38:02 <sternmull> lyxia: Ok. That is sad. Would lenses solve such problems?
06:38:47 <lyxia> The lens package has such a mechanism but it's orthogonal to the concept of lenses.
06:39:04 <Xion_> ertes-w: Oh, so Haskell runtime spawns its own thread for signal handling, meaning whatever handlers you setup using standard library calls are proxied through that thread?
06:39:40 <sternmull> maybe its time to play around with lens.
06:40:00 <ertes-w> Xion_: no, it just sets up a signal handler, and when a signal is received, it creates a temporary thread
06:40:06 <ertes-w> as far as i know/understood it
06:40:45 <Xion_> Okay. So regular signal reception mechanics still apply.
06:41:37 <ertes-w> a haskell thread of course
06:41:43 <ertes-w> not an OS thread
06:41:49 <lyxia> sternmull: the makeClassy TH function creates type classes to use the same lens name for many types
06:41:55 <merijn> ertes-w: That sounds wrong
06:42:10 <angerman> if anyone has questions re Android, I'll be around for a bit.
06:42:15 <merijn> ertes-w: Mostly because there's almost no way it could safely launch a Haskell thread from a signal handler
06:42:30 <tfc[m]> ertes-w: Xion_: i tried `setSignalMask <$> flip (foldr addSignal) [sigINT, sigTERM] <$> getSignalMask` in order to mask ctrl-c completely before starting a handler thread. unfortunately it is completely without effect? am i doing something wrong?
06:43:53 <ertes-w> merijn: i don't know the exact mechanics, but i can imagine that it just sets up a "launch this thread whenever you have an opportunity" RTS note or something
06:44:22 <merijn> I should really have a look at how the RTS does signals...
06:46:45 <ertes-w> merijn: try this: main = do myThreadId >>= print; installHandler sigINT (Catch (myThreadId >>= print)) Nothing; threadDelay 10000000
06:47:12 <ertes-w> press ^C a few times during the wait period, so you can see the changing thread ids
06:50:08 <tfc[m]> any idea on the `setSignalMask` thing?
06:50:21 <cocreature> merijn: I’m not sure the RTS actually does anything special for signals. I think it’s just uses the standard FFI mechanisms to convert the handler to a FunPtr and then passes that to signal which can then call back
06:50:34 <maerwald> anyone knows how to determine entry and exit points (both direct and indirect) in a haskell codebase? For direct ones, there's already the problem that I need to account for IO-like transformers, IO-like classes, or even extensible-effects stuff.
06:50:34 <maerwald> For indirect ones I can't just rely on those types being propagated, because they could turn out to be more abstract than IO (as in: they are transformed into IO at some other place, via "runner"-functions or whatnot).
06:51:24 <maerwald> maybe it's more useful to examine the call-graph, but then... there is no call graph
06:53:36 <merijn> cocreature: Which is kinda bad, because then you have no idea which capability signals get sent too
06:55:12 <cocreature> merijn: right. although GHC does workaround this for the default install signal handlers it installs and guarantees that things like UserInterrupt are always thrown in the main thread
06:55:39 <merijn> cocreature: This kinda thing should probably be more thoroughly documented, though :)
06:56:03 <tfc[m]> cocreature: i have the impression that all my threads get a userinterrupt, not only the main one.
06:56:15 <merijn> tfc[m]: Why?
06:56:16 <cocreature> tfc[m]: I would be very surprised by that
06:56:39 <merijn> I have a theory why you think that, but lemme confirm :)
06:56:47 <cocreature> tfc[m]: take a look at the source of runMainIO here http://hackage.haskell.org/package/base-4.9.0.0/src/GHC/TopHandler.hs
06:56:55 <cocreature> it’s pretty clear that it only throws the exception to the main thread
06:57:20 <c_wraith> I have a theory that I have the same theory as merijn 
06:57:46 <merijn> c_wraith: Is it "blocked main thread gets interrupted and the entire program exits"? ;)
06:58:00 <tfc[m]> my main thread has installed a handler that just sets an MVar to true (this works), and then calls MP.mapM_ on some functions that most of the time wait on "tryIOError .... ". the problem is that they ALL drop out of this tryIOError as soon as i hit ctrl-c.
06:58:15 <c_wraith> merijn: oh, I have a simpler version.  "the program exits when the main thread does"
06:58:33 <merijn> c_wraith: Right, but it's the interrupt waking up from mapM_ that triggers that :)
06:58:54 <merijn> tfc[m]: Interrupting the mapM_ interrupts the main thread, which then happily continues after the mapM_ and exits
06:59:10 <merijn> tfc[m]: When the main thread exits, the whole program terminates, regardless of other running threads
06:59:23 <tfc[m]> ok, i see.
06:59:44 <tfc[m]> so now i would like to start another thread which blocks on "awaitSignals" and then sets my MVar to true.
07:00:04 <tfc[m]> while blocking sigINT for all other threads, including main.
07:00:45 <tfc[m]> the problem is that `blockSignals $ addSignal sigINT emptySignalSet` is completely without effect. my app quits immediately on ctrl-c. i am really stuck here.
07:00:53 <cocreature> I’m really happy that async now waits for exception handlers fo finish executing. it was really awkward to ensure that finalizers are run in all threads if your main thread dies because even "waitAnyCatch" didn’t help
07:01:02 <cocreature> eh "waitAnyCatchCancel"
07:01:08 <cocreature> or whatever that function is called
07:04:32 <tfc[m]> anyone ever used blockSignals?
07:06:43 <bollu> cocreature: ping, I wasn't around over the weekend. 
07:08:39 <ertes-w> maerwald: what do you mean by "entry point"?  so far the only thing i know as the entry point is 'main'
07:09:20 <maerwald> ertes-w: http://reports-archive.adm.cs.cmu.edu/anon/anon/usr/ftp/2008/CMU-CS-08-152.pdf page 22
07:10:12 <Profpatsch> A theoretical question:
07:10:21 <ertes-w> maerwald: i can't read a PDF now…  do you have a one-line summary?
07:10:22 <maerwald> simplified: "receive data from the system's environment"
07:10:30 <ertes-w> ah
07:10:35 <maerwald> in C that is done by checking for syscalls
07:10:42 <Profpatsch> If I can implement fix :: (a -> a) -> a in a language, does that mean the language must be Turing-Complete?
07:10:44 <maerwald> and then generating a callgraph
07:11:53 <ertes-w> maerwald: i don't think there is an equivalent in haskell…  you need to check for primitive operations that pass RealWorld# around
07:12:02 <ertes-w> but even that's not exhaustive, i think
07:12:08 * hackage http-client-tls 0.3.5 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.5 (MichaelSnoyman)
07:12:09 <merijn> Profpatsch: No, consider the language where "fix" is the *only* legal expression. You can trivially implement fix in it, but it's not Turing complete
07:12:26 <Profpatsch> heh
07:12:38 * hackage safeio 0.0.2.0 - Write output to disk atomically  https://hackage.haskell.org/package/safeio-0.0.2.0 (luispedro)
07:13:07 <merijn> Profpatsch: i.e., the ability to implement 'fix' (afaik...) is necessary, but not sufficient
07:13:22 <Profpatsch> merijn: What would still be needed?
07:13:34 <Profpatsch> A way to call fix with a starting input?
07:13:41 <merijn> I have no clue what the 'sufficient' is
07:14:07 <merijn> Profpatsch: Well, a Turing complete language should be able to compute any computable thing. But a language where only 'fix' is legal, can only compute 'fix' and nothing else
07:14:10 <bollu> Profpatsch: I think simply typed lambda calculus + fix
07:14:14 <bollu> Profpatsch: is sufficient
07:14:22 <bollu> Profpatsch: don't know if that is minimal
07:14:22 <noctux> well, wouldn't it be a SKI-calculator thing?
07:14:40 <Profpatsch> Is simply-typed lambda calculus not Turing complete?
07:14:52 <merijn> Profpatsch: No
07:14:54 <noctux> Profpatsch: no, without fix it afaik isnt
07:15:02 <Profpatsch> afaik the y combinator can’t be expressed, right?
07:15:03 <merijn> Simply-typed lambda calculus is strongly normalising
07:15:10 <Profpatsch> because the type (a -> a) -> a is invalid
07:15:29 <bollu> ueaj
07:15:32 <bollu> yes*
07:15:43 <bollu> Profpatsch: which was why I hand-wavily said "add fix to it" :) 
07:15:46 <cocreature> bollu: pong
07:16:00 <bollu> cocreature: hey, I want to work on the coroutines thing tonight. What do I help with?
07:16:13 <noctux> Profpatsch: basically, you need a S and K combinator, (which together can implement fix) or an alternative to which you can reduce S and K
07:16:29 <cocreature> bollu: finish the parser, write the generator for the adt and write the FFI part
07:16:30 <noctux> Profpatsch: http://dev.stephendiehl.com/fun/003_lambda_calculus.html <- i found this quite enlightning on the topic
07:16:34 <bollu> cocreature: OK
07:17:07 <bollu> does anyone know how they originally came up with S & K? and the proof of universailty?
07:17:09 <bollu> I find it crazy
07:17:09 <Profpatsch> But an untyped lazy lambda calculus like nix expressions is probably near-trivially turing complete, right?
07:17:51 <shapr> bollu: schoenfinkel and curry? https://en.wikipedia.org/wiki/SKI_combinator_calculus
07:24:39 <tfc[m]> wow, i just realized that "blockSignals ...keyboardSignal" has no effect in my app if i link it with "-threaded -rtsopts -with-rtsopts=-N". "stack new project_name" sets up a cabal file with such settings.
07:24:59 <tfc[m]> any idea how i can get it blockSignals working WITH threaded settings, or should i remove that generally?
07:33:00 <ZuluKing> Hello guys!
07:33:23 <ZuluKing> I have a quick question regarding HashMaps, can someone tell me what I am doing wrong?
07:33:35 <lpaste> ZuluKing pasted “HashMap” at http://lpaste.net/355941
07:34:08 * hackage transient 0.5.5 - composing programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.5.5 (AlbertoCorona)
07:34:21 <c_wraith> ZuluKing: I'd guess the problem is that in the recursive case, *all* you're doing is recursing.
07:34:33 <c_wraith> ZuluKing: you probably want to be inserting the current pair, too
07:34:58 <ZuluKing> c_wraith I am doing that in the second case, no?
07:35:11 <c_wraith> ZuluKing: the second case only matches single-element lists.
07:35:26 <c_wraith> ZuluKing: if you get a two-element list, you throw away the first pair, then insert the second.
07:35:36 <kadoban> insertWith (++) looks a bit suspicious too, since I don't think you're actually inserting lists
07:40:01 <ZuluKing> guys, so does HashMap.insertWith insert a new value if no existing value is found?
07:40:38 <c_wraith> ZuluKing: you should try to rewrite it with only two cases.  Pretend the syntax for matching on fixed, non-zero length lists doesn't exist.
07:41:07 <c_wraith> ZuluKing: no idea.  What HashMap are you using?  (ie, what package is it from?)
07:41:38 <ZuluKing> c_wraith, yeah I got that, trying to do a two case solution only
07:41:52 <ZuluKing> c_wraith Data.HashMap.Strict from unordered-containers package
07:42:02 <ZuluKing> c_wraith, is there any other I should use?
07:42:44 <c_wraith> No, that's the best one for general use.  I just wanted to be sure that's the one you were using.  There's an older package that isn't nearly as good.
07:43:16 <kadoban> ZuluKing: Note that if this isn't just for exercise, there's fromListWith
07:43:41 <kadoban> But yeah, insertWith will insert a new value if none exists.
07:44:29 <kadoban> Beware the function you're giving it has to actually make sense on the value type, so if you're using (++) you need to be inserting lists.
07:45:26 <ZuluKing> kadoban, thanks man, it's not for exercise, I didnt know fromListWith exists
07:45:42 <ZuluKing> kadoban, dumb me :(
07:45:57 <kadoban> It's easy to miss
07:53:37 <itsu> hey guys, just wanted to know. Is there a way to do something like this in Haskell:
07:53:37 <itsu>  
07:53:37 <itsu> data App = App { dir :: FilePath, file :: FilePath }
07:53:37 <itsu> app = App { dir = "/home/test/", file = dir <> "hey" }
07:53:38 * hackage transient-universe 0.4.4 - Distributed computing with algebraic/monadic composability, map-reduce  https://hackage.haskell.org/package/transient-universe-0.4.4 (AlbertoCorona)
07:54:30 <lyxia> , file = dir app <> "hey" }
07:55:00 <itsu> oh wow... really? that easy ?!
07:55:02 <ahihi> or use a let/where
07:55:55 <itsu> thanks lyxia ahihi 
07:56:06 <uiop> > let app = ("/home/test/", fst app ++ "a.txt") in app
07:56:08 <lambdabot>  ("/home/test/","/home/test/a.txt")
08:01:58 <uiop> > let app@(xxx,_) = ("/home/test/", xxx ++ "a.txt") in app
08:02:00 <lambdabot>  ("/home/test/","/home/test/a.txt")
08:18:55 <tfc[m]> Xion_: still there?
08:34:08 * hackage matplotlib 0.5.0 - Bindings to Matplotlib; a Python plotting library  https://hackage.haskell.org/package/matplotlib-0.5.0 (AndreiBarbu)
08:36:08 * hackage som 9.0.3 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0.3 (AmyDeBuitleir)
08:42:22 <shapr> konichiwa halogenandtoast
08:42:29 <shapr> ohio gozymous
08:42:49 * Clint twitches.
08:43:49 <shapr> Clint: good morning!
08:44:33 <Clint> shapr: i can't disagree
08:44:41 <sm> ohayou gozaimasu!
08:46:01 <Xion_> tfc[m]: Yep
08:47:05 <tfc[m]> Xion_: no matter what i do... if i have a handler catching my ctrl-c, ALL threads that sit on a "hGetLine" receive an EOF immediately.
08:47:19 <ertes-w> haskell bindings to a python library?  how does that even work?
08:48:06 <ongy> ertes-w: there is (well, last I tried I didn't get it to build) a cython binding for haskell
08:49:10 <shapr> ongy: that sounds interesting
08:50:00 <cocreature> this seems to generate python code and then call the external "python" executable
08:50:23 <Xion_> tfc[m]: Le sigh. I think this is where my capabilities end, sorry ;/
08:50:38 <Xion_> You may want to wait until more US folks wake up or post on SO
08:50:46 <tfc[m]> hm right
08:51:07 <ongy> This I think https://john-millikin.com/articles/ride-the-snake/
08:51:11 <ertes-w> ah…  my first guess would have been that it fires up a python program and RPCs into it
08:52:44 <sternmull> i think matplotlib is messy enough. Someone should write a Haskell package that is better :)
08:53:04 <shapr> some sort of wrapper for diagrams?
08:55:56 <sternmull> hm, diagrams looks interesting.
09:08:26 <glguy> tfc[m]: Do you have a small example module you can share that exhibits the problem you're trying to solve?
09:09:13 <tfc[m]> glguy: before i get crazy with this i should really write one.... give me a moment.
09:13:41 <siiky> Q: can it happen that functions defined in GHCi dont work, but defined in a file (and loaded afterwards) do work?
09:14:13 <Sonolin> siiky I noticed ghci buffer mode is not the same as the ghc buffer mode (by default)
09:14:20 <Sonolin> just my $0.02
09:14:56 <siiky> https://paste.rs/sgf i was playing with these on GHCi but it was complaining about non exaustive patterns. when i put them in a file to ask here, they worked as expected :/
09:14:59 <glguy> siiky: The most common reason for that is writing multi-line definitions in GHCi on separate GHCi lines
09:15:18 <siiky> ah ok... then thats it glguy 
09:15:24 <glguy> siiky: You can't just paste a .hs file line by line into GHCi and expect it to work, that's not what GHCi does
09:16:34 <siiky> i didnt paste them, i loaded the file...
09:17:07 <glguy> You're comparing loading the file to what?
09:17:46 <siiky> defining them after opening ghci
09:17:53 <glguy> in GHCi?
09:17:57 <siiky> yes
09:18:08 <shapr> ph88: did you see Legion? https://github.com/aviaviavi/legion
09:18:18 <glguy> OK, writing one-key at a time and pasting is the same thing from GHCi's point of view
09:20:13 <siiky> i get your point... 
09:20:27 <siiky> glguy: how do i do multiple line definitions inside ghci then?
09:20:37 <glguy> siiky: Generally you shouldn't
09:20:40 <siiky> although i think ive done it before...
09:20:46 <glguy> but there's :{   and :}
09:21:20 <glguy> and then GHCi has a multi-line hack with :set +m
09:22:26 <siiky> ah, i didnt know about :{ and :}
09:22:41 <siiky> thanks glguy 
09:24:14 <tfc[m]> glguy: finally got it reproduced in a minimum sample. interested in seeing it? where shall i paste it?
09:24:24 <glguy> http://lpaste.net
09:24:51 <glguy> I might not have time to play with it, but maybe someone does. We won't know until you paste it :)
09:27:22 <tfc[m]> glguy http://lpaste.net/355946
09:28:43 <tfc[m]> that is my headache for hours now. :D
09:29:01 <tfc[m]> i just want the bloody hGetLine to not EOF after i pressed ctrl-c
09:34:53 <ongy> tfc[m]: try to fork into something that also prints about signals on stderr, this looks like something forwards the signal to the shell that's spawned which then exits, which gives you the eof
09:35:54 <Unode> reading some documentation on conduit, it often uses "strict accumulator". Can someone explain what 'strict' means in this context and provide one example of an accumulator?
09:36:01 <tfc[m]> wow i just realized if i give createProcess also a "create_group = True" flag, it works...
09:36:02 <tfc[m]> seems like my ctrl-c was forwarded...?
09:37:21 <ongy> I'm not 100% sure on process groups, but there's ways to signal the entire group. Not sure if the shell does that
09:37:26 <Xion_> tfc[m]: ctrl+c sends SIGINT to the entire process group
09:37:44 <Xion_> But you never mentioned multiple processes which is why it didn't seem relevant
09:37:54 <tfc[m]> Xion_: this is something new to me that looks REALLY relevant here... :D
09:38:07 <tfc[m]> Xion_: yes, sorry. i was too chaotic about this.
09:38:10 <ongy> Unode: strict is often used as opposite of lazy
09:38:28 <Xion_> Unix is hard, let's go for dinner
09:38:34 <Unode> ongy: I see
09:38:38 <Xion_> Or $TIMEZONE_APPROPRIATE_MEAL
09:38:51 <ongy> unix, posix, or anything any kernel does
09:38:55 <tfc[m]> Xion_: yeah i owe you a beer. :D
09:41:37 <bbaren> Unode: You probably should read Johan Tibell’s laziness slides (https://johantibell.com/files/bayhac-2011.pdf).
09:42:16 <Unode> bbaren: I understand laziness. It's conduit that I'm still trying to wrap my head around.
09:42:23 <Unode> but thanks for the link
09:42:58 <bbaren> Ah, gotcha. Yeah, somebody else is going to have to help with the conduit parts.
09:43:49 <Unode> specifically, I'm trying to use conduit to split a file into chunks of at most X bytes. I managed to get as far as splitting into multiple files, now the tricky part is how to read the chunk-size and decide when to move to the next sink.
09:44:24 <Unode> I'm still new to haskell so my brain tends to think imperative and I hit a wall.
09:51:52 <Faucelme> Unode: from where do you read the chunk size? Do you mean, when reading back the files?
09:54:00 <Unode> Faucelme: the chunk size will be user specified. At this time it's an hardcoded value. Perhaps chunk is a misleading term, what I want to go for is number of bytes. So say the user asks for 10Mb splits, gives a 95Mb file, ends up with 10 splits.
09:54:30 <Unode> sort of similar to the unix' split command.
09:56:22 <Faucelme> Unode: what happens if the size of a split is bigger than the available RAM? Do you need to keep the whole split in memory at some point?
09:56:41 <Unode> Faucelme: that's the whole point of using conduit
09:57:20 <lambdamu_> Is there a type class that has an instance for all types? It is easy to make, but maybe there is a canoncial one
09:58:16 <Unode> Faucelme: again, I think you are considering "chunk" to be what is being read from the file. It's not, it's what is used to decide when to move to the next split. The input/output file is still read/written in smaller chunks.
09:58:36 <Unode> Faucelme: which is why I figured 'chunk' was a confusing term.
09:59:34 <cocreature> lambdamu_: I don’t think so (I also don’t know why you would want that)
10:02:24 <ertes-w> lambdamu_: in GHC-haskell Typeable would be such a class
10:02:29 <lambdamu_> cocreature: I have asocciated type in type class of kind :: * -> Constraint. But for some instances there is no constraint so i need a value for that
10:02:35 <ertes-w> lambdamu_: at least with recent GHCs
10:02:41 <Faucelme> Unode: the "streaming" library has a nice way of modelling "splitted streams". I suppose conduit offers something similar.
10:03:06 <lambdamu_> or rather a type, not a value
10:03:43 <Unode> Faucelme: from my limited understanding, conduit IS a streaming framework.
10:04:50 <Faucelme> Unode: yes. There are others like "pipes" and "streaming". I'm more familiar with these two.
10:05:10 <geekosaur> lambdamu_, Typeable
10:05:41 <geekosaur> but I wonder if you can rephrase that so you can use a dummy type equivalence constraint like () ~ () instead
10:05:57 <Unode> Faucelme: ok. Conduit was already being used in the codebase I'm trying to modify so it was an 'obvious' choice :)
10:06:08 <geekosaur> (it might even work as is currently, because * and Constraint are presently conflated in the typechecker... but it would be wise not to rely on that)
10:06:35 <byorgey> geekosaur, lambdamu_: can't you just define    type Foo = ()  ?
10:06:41 <byorgey> () is the trivial Constraint
10:06:46 <lambdamu_> http://lpaste.net/355947 that's what I have currently
10:07:17 <cocreature> yeah byorgey is right
10:07:23 <cocreature> use () if you don’t care about the constraints
10:07:54 <lambdamu_> I don't think () works, at least in my setting because i can't write type ValueConstraint IORef a = ()
10:08:08 <lambdamu_> too many parameters
10:08:21 <cocreature> remove the a
10:08:28 <nshepperd> ValueConstraint (IORef a) = ()
10:08:53 <lambdamu_> Now its the wrong kind
10:09:26 <lambdamu_> nshepperd: doesn't work either, maybe I can rephrase the type class such that it works
10:10:22 <geekosaur> this would be why I said "rephrase"
10:10:57 <lambdamu_> I thing the problem here is that there are no type level lambdas, another thing I can't do is pack multiple constraints together
10:11:21 <geekosaur> the latter I think you can. type level tuple
10:11:37 <lambdamu_> yes but not in the setting right now
10:11:40 <geekosaur> althoguh again you might need to rephrase the AT
10:12:01 <cocreature> you can pack multiple constraints together, but what you are trying to do is pack multiple things of kind * -> Constraint together
10:12:55 --- mode: ChanServ set +o glguy
10:12:56 --- mode: glguy set -bbo *!*@104.129.28.10 *!*@gateway/web/freenode/ip.40.132.243.84 glguy
10:13:00 <lambdamu_> Yeah that's what I meant I'd like to do \x -> (Storable x, Typeable x) as an example
10:13:10 <lambdamu_> but of course doesn't work
10:17:18 <nshepperd> class Container (f :: * -> *) where { type family ValueConstraint f a :: Constraint; ... }
10:18:06 <nshepperd> now it's a type family of two arguments, instead of a type family of one argument producing a type constructor
10:19:24 <lambdamu_> nshepperd: Nice that works
10:20:51 <nshepperd> weirdly, with type families the difference between 'F (a :: k1) :: k2' and 'F :: k1 -> k2' is significant, because of the restriction on partially applied families
10:22:21 <lambdamu_> Hm yeah I think there is basically no partial application for type families
10:23:14 <byorgey> nshepperd: oh, does that work? Interesting, I thought it would complain because 'a' is not in scope
10:25:18 <lambdamu_> thought that too
10:25:50 <lambdamu_> btw. any good idea what to name the last combinator here or does there exist a package who does that already?
10:25:51 <lambdamu_> http://lpaste.net/355948
10:26:53 <lambdamu_> lens scraped the namespace for operators pretty thorougly
10:31:06 <kadoban> Alright, I can't seem to search for this, so anyone able to save me: with GHCJS with a pretty simple project, my lib.js and rts.js include LGPL code (judging by explicit copies of the LGPL license). Someone apparently using the same version of GHCJS on the same OS doesn't have those in their lib.js or rts.js. What would be causing that? Can I avoid it somehow?
10:31:30 <kadoban> It's annoying beacuse it complicates my distribution
10:33:52 <glguy> which package is the license for?
10:36:00 <sm> I'm running ghci -prof -fprof-auto ... so that traceStack will produce output. No effect so far. Should this work ?
10:36:05 <kadoban> The license text says "GNU C Library" in some places, I didn't check them all. It could be from integer-gmp? That's mentioned soon after. "GHCJS bignum library for integer-gmp package"
10:43:02 <sm> aha, needs -fexternal-interpreter. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#stack-traces-in-ghci
10:57:38 * hackage foldl 1.3.0 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.3.0 (GabrielGonzalez)
10:59:25 <sm> stack, why do you insist data-default-class is not built with profiling ?
11:08:30 <sm> because you're picking it up from an old snapshot, willy nilly
11:16:05 <AWizzArd> I am looking for a small existing project (preferrably less than 2k loc) which doesn’t require a SPJ level understanding of Haskell, but which is written very cleanly, so that I can study its code and see what really good Haskell looks like.
11:17:35 <shapr> AWizzArd: https://github.com/aviaviavi/legion ?
11:17:43 <shapr> howdy AWizzArd, how's code?
11:18:24 <shapr> AWizzArd: have you read the xmonad sources? or pandoc, or shellcheck, or ?
11:18:46 <shapr> as much as I enjoy using GHC, it wasn't easy to read the last time I did so.
11:18:53 <shapr> mind you, that was a long time ago :-/
11:19:33 <AWizzArd> I didn’t read much sources yet. But thanks for the tip, I will have a look at legion!
11:20:25 <EvanR> ive read some stdlib source, surprised at how easy it is
11:21:14 <EvanR> i fixed some bugs in hdbc-mysql not really knowing much about haskell
11:21:21 <EvanR> way back
11:21:41 <EvanR> it had this "it is what it is, what you see is what etc" feel to it
11:22:03 <EvanR> the types are staring right in the face, they cant be denied
11:22:25 <spoonm> question: I have an `X [Window]', how can I get just the `length' of the `[Window]' part?
11:23:16 <qmm> in my javascript code, i can do this: Promise.all([ r.table('foo').insert({label: 'bar'}).run(), Promise.reject() ]).then(...).catch(...) and i don't insert anything into the database because one of the actions in the list of actions that return a promise returns a rejection. how can i do the same in haskell?
11:24:27 <EvanR> dont you want to use normal transactions for this
11:24:40 <qmm> i don't think the rethinkdb client has transactions
11:25:09 <EvanR> omg
11:25:16 <qmm> EvanR: if i could go back in time and tell myself to not use rethinkdb, i would
11:25:43 <Xion_> You would have... rethink'd your decision? :)
11:26:01 <Gurkenglas> You want Monad m => [m Bool] -> m (), which executes the actions if they all return True? That's not possible, by the time you have a boolean the "damage" is done
11:26:03 <sm> it was right there, in the name! :)
11:26:19 <qmm> :)
11:26:34 <EvanR> given that, i dont understand what you want to do
11:27:52 <Gurkenglas> Maybe you want [s -> (Bool, s)] -> s -> s, which applies all the state transformations if they all return true, and rolls back to the old state otherwise?
11:28:44 <qmm> Gurkenglas: that would be ideal, but i don't know how you roll back
11:29:36 <Gurkenglas> First off, this can be separated into composing [s -> (a, s)] into s -> ([a], s) which collects the results, and turning s -> (Bool, s) into s -> s, which uses the new s if the Bool is True and the old one otherwise
11:30:30 <Gurkenglas> (And turning the [Bool] into Bool in between)
11:30:49 <Gurkenglas> :t mapAccumL
11:30:51 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:31:40 <Gurkenglas> Hm, that one has all the argument orders and tuple orders the wrong way round. Let's reimplement it with more fitting type signatures as an exercise.
11:36:38 <Gurkenglas> @let mapAccumLGurk :: (a -> s -> (b, s)) -> [a] -> s -> ([b], s); mapAccumLGurk f [] s = ([], s); mapAccumLGurk f (a:as) s = let (b, s') = f a s; (bs, s'') = mapAccumLGurk f as s' in (b : bs, s'')
11:36:39 <lambdabot>  Defined.
11:36:55 <Gurkenglas> :t mapAccumLGurk id -- There's our first component
11:36:57 <lambdabot> [s -> (b, s)] -> s -> ([b], s)
11:38:14 <Gurkenglas> :t runState . traverse state -- (Note that if we want to implement this for all Traversables, we'll need an Applicative that can carry the state around for us so we can use traverse. This is just what the State monad is for.)
11:38:15 <lambdabot> Traversable t => t (s -> (b, s)) -> s -> (t b, s)
11:38:40 --- mode: ChanServ set +o glguy
11:40:28 <Gurkenglas> @let iftrue :: (s -> (Bool, s)) -> s -> s; iftrue f s = let (b, s') = f s in if b then s' else s -- The rest is simple:
11:40:30 <lambdabot>  Defined.
11:42:09 <qmm> Gurkenglas: i wouldn't know how to get the state prior to the insertion or update attempt
11:42:44 <Gurkenglas> :t iftrue . ((.) . first) or . mapAccumLGurk id -- ((.) . first) takes or :: [Bool] -> Bool and lifts it into a function on tuples and then into a function on functions producing tuples.
11:42:46 <lambdabot> [s -> (Bool, s)] -> s -> s
11:42:49 <qmm> the only thing i can think of is to parse the command, look for the table about to be manipulated and have that stored and ready to be restored
11:42:57 <qmm> but that would be insanely expensive :)
11:44:04 <Gurkenglas> You could keep track of a stack of changes you did, and revert them if False occurs; that's one way databases implement transactions
11:44:41 <glguy[m]> @yow
11:44:41 <lambdabot> I'm a fuschia bowling ball somewhere in Brittany
11:45:32 <ongy> glguy[m]: I'm confused :0
11:45:47 <glguy> Just testing
11:48:18 <ongy> I hope you don't abandon glirc for glmatrix :)
11:51:38 <glguy> ongy: No, I wouldn't want to stop using my client. I'm just making sure I understand what the bridge experience is from the other side
11:53:38 <mauke> unfortunately, no one can be told what matrix is. you have to see it for yourself
11:58:21 <dmwit> Such a copout. I could have explained the matrix to Neo in just a few seconds.
11:58:48 <kadoban> But would they believe you?
11:59:03 <kadoban> Also, that wouldn't sound as cool.
11:59:41 <qmm> Gurkenglas: i don't understand how i could programmatically keep a running list of the opposite of each command 
12:00:13 <dolio> Neo seems pretty gullible. He'd probably believe.
12:00:38 <qmm> an insertion would return an id, i could keep track of the id and delete the document if i need to revert. an update, on the other hand, or a deletion from the table seems more complicated
12:03:04 <dolio> How does the javascript roll back the effects that it does?
12:03:09 <dolio> Just do the same thing it does.
12:06:40 <EvanR> a running list of the opposite of each command doesnt make any damn sense
12:06:51 <EvanR> unless you are the only person in the world using this database
12:07:29 <EvanR> which would seem to defeat the performance promises that all these nosql's are based on
12:10:07 <DamianNadalesGit> Suddenly this channel starts getting a lot of traffic :) 
12:10:32 <merijn> DamianNadalesGit: The activity of this channel varies a lot depending on the hour of the day
12:11:39 <DamianNadalesGit> Is all this traffic coming from the official Haskell irc? 
12:12:27 <kadoban> Well, we're in the official freenode haskell IRC channel at least, so yes? Might not be understanding the question.
12:14:31 <DamianNadalesGit> Yes, that's what I meant. Anyway, nice to see more people around 
12:15:34 <EvanR> DamianNadalesGit is using a gateway
12:15:52 <AWizzArd> I have added an import for a type. This type has a data constructor which is called the same.   import my.Module (Typex)   doesn’t work. It tells me that the data constructor Typex isn’t known.
12:15:55 <EvanR> and may see something we dont
12:16:04 <kadoban> Oh
12:16:09 <AWizzArd> How can I import a data constructor?
12:16:17 <merijn> AWizzArd: That only imports the type, yes, you want "Typex(..)" to import all data constructors
12:16:23 <kadoban> AWizzArd: (Typex(..)) or (Typex(Typex))
12:16:30 <merijn> AWizzArd: Or "Typex(Foo,Bar)" to only import the Foo and Bar constructors of Typex
12:16:45 <AWizzArd> oki thx
12:18:38 <shapr> DamianNadalesGit: do you have questions about Haskell? WE HAVE ANSWERS!
12:18:41 * shapr hops excitedly
12:18:46 <shapr> coffee is so great
12:18:54 <ongy> shapr: tea is better!
12:19:09 <shapr> tea is different ... equally awesome
12:19:28 <shapr> ongy: I've been drinking irish breakfast tea in the afternoons, death wish coffee in the mornings; but haskell ALL THE DAY
12:19:34 <merijn> ongy: What is your opinion on lapsang souchong? (This may or may not affect my opinion of you :p)
12:19:58 <nshepperd_> If 1. your database doesn't have transactions and 2. there are concurrent updates and 3. the "cancel" condition depends on database state, then I think you're boned
12:20:19 <shapr> nshepperd_: sounds like a recipe for sadness
12:20:39 <nshepperd_> So, find out which one of those is false and solve accordingly
12:21:15 <shapr> I enjoyed the comments on https://news.ycombinator.com/item?id=14439789 I didn't know distributed-process and distributed-process-p2p could be used outside of Cloud Haskell!
12:21:16 <ongy> merijn: I'm a pleb, and I don't think I have seen that one in the small tea shop I tend to buy from
12:21:40 <merijn> ongy: I like it, it's smoked tea :)
12:21:56 <hexagoxel> given something like `data ArgType = ArgInt | ArgFloat | ArgBool` can i express a function with a type similar to `func :: [ArgType] -> Input -> HList ts -> Maybe Output` but with the constraint that `ts` matches the types passed in via the ArgType list?
12:21:57 <ongy> oh they have it, and it's cheap
12:22:35 <ongy> I have had some smoke tea (black). I'd call it an aquired taste. The first 2 or 3 cans it was weird, but to the end 50g I really liked it
12:22:45 <merijn> ongy: I know two kinds of people: 1) people I got into smokey whiskey from lapsang souchong and 2) people I got into tea from smokey whiskey :p
12:22:46 <hexagoxel> is making ArgType an appropriate GADT the solution? any other approaches to consider?
12:23:00 <ongy> merijn: I think we are a bit off topic for this channel
12:25:25 <hexagoxel> and further, can i use Typeable for this, to make this more open instead of closed on (Int+Float+Bool) ?
12:27:35 <merijn> hexagoxel: Well, you can't relate the 'ts' to the opaque type [ArgType], so not directly
12:27:52 <merijn> hexagoxel: No chance of converting [ArgType] into an HList too?
12:30:36 <hexagoxel> merijn: not sure yet .. it would be some ArgType/HList hybrid.
12:31:20 <Sonolin> so, I'm assuming it would be preferred to use STRefs over TVars when the state is initialized empty?
12:31:20 <merijn> hexagoxel: I've tried similar things, so it depends a lot on exactly what you're trying to do
12:31:32 <Sonolin> (I don't care about performance)
12:31:41 <hexagoxel> data ArgTypes ts where Empty :: ArgTypes '[]; ConsInt :: ArgTypes ts -> ArgTypes (Int ': ts); etc.
12:32:40 <merijn> hexagoxel: If you're going GADT then why bother having explicit "ConsInt"? "Cons :: a -> ArgTypes ts -> ArgTypes (a ': ts)" would work
12:33:19 <merijn> hexagoxel: This might be relevant for you: https://gist.github.com/merijn/dc00bc7cebd6df012c5e#file-gistfile1-hs-L29-L35
12:33:29 <hexagoxel> merijn: because I don't have the value of that type yet.
12:34:06 <merijn> hexagoxel: ah, even then there should be better ways, I think?
12:34:09 <hexagoxel> but perhaps.. Cons :: Typeable a -> Proxy a -> ArgTypes ts -> ArgTypes (a ': ts)   hmm.
12:34:43 <hexagoxel> I can inspect that via the Typeable.
12:35:49 <hexagoxel> merijn: ah nice, yeah that link might become useful too.
12:36:30 <kadoban> When does GHCJS output end up with LGPL stuff in it? Do I have control over that? On apparently the same version of GHCJS (0.2.1, GHC 8.0.2) my lib.js and rts.js have LGPL stuff in them, and someone else says theirs doesn't. Would be nice if I could deploy just using all.js, but as I understand it I can't with LGPL stuff in there unless I want to be LGPL in my own code.
12:36:31 <hexagoxel> oh, i meant   Cons :: Typeable a => Proxy a -> ArgTypes ts -> ArgTypes (a ': ts)
12:37:01 <merijn> kadoban: I think with JS it's not relevant
12:37:22 <merijn> kadoban: The LGPL says you can't statically link stuff, but you can't statically link stuff anyway in JS
12:38:05 <kadoban> Is LGPL that specific about technical details? I would think an all.js that's all crammed together wouldn't meet the spirit of LGPL, or probably the letter?
12:38:08 <merijn> kadoban: You could argue that it means you can't distribute a compressed/closure-compiled/packed/whatever-the-cool-kids-do version
12:38:08 * hackage transient-universe 0.4.4.1 - Distributed computing with algebraic/monadic composability, map-reduce  https://hackage.haskell.org/package/transient-universe-0.4.4.1 (AlbertoCorona)
12:38:38 <merijn> kadoban: Which LGPL stuff is winding up in it?
12:38:43 <kadoban> Yeah, I think closure-compiled and compressed is nearly a requirement for decent performance, otherwise the JS files are pretty huge.
12:39:00 <hexagoxel> merijn: does the above usage of `Proxy` make at least some sense?
12:39:10 <kadoban> My best guess is that it's something to do with libgmp? I can't really tell for sure. It's really hard to search for and I can't tell if I'm reading the weird mix of sources correctly.
12:39:33 <merijn> hexagoxel: It does seem like Proxy would waste a bunch of space, but other than that I don't see an issue
12:39:49 <merijn> kadoban: Is it compiling the C code of libgmp to JS, or what?
12:39:58 <merijn> kadoban: I don't see how you could use libgmp from JS?
12:40:09 <hexagoxel> merijn: ok, i'll see if i can get this to compile as a first step. thanks for the input.
12:41:04 <kadoban> merijn: Honestly I have no idea and googling isn't giving me much, I think that's what I'm asking ... where is this coming from and how can I make it ... not?
12:41:45 <kadoban> GHCJS and LGPL are too common terms, and even in combination, it gives a lot of stuff about windows and GHC that doesn't seem to apply to this, or maybe it's related somehow? (though I'm not on windows)
12:42:04 <merijn> kadoban: Well, what tells you there's LGPL stuff in there?
12:42:32 <kadoban> merijn: The LGPL license peppered throughout
12:42:41 <merijn> kadoban: Try pinging luite?
12:43:18 <kadoban> Will do. Hm, I wonder if there's an issue in github or somewhere, I don't think I actually looked there which I should have.
12:43:22 <paolino> and #ghcjs
12:44:02 <kadoban> Ya I tried #ghcjs an hour back but nothing yet, got impatient xD Though I'll still wait there
12:44:21 <VamsiAmpoluGitte> Hey guys, I have got:
12:44:21 <VamsiAmpoluGitte> ```hs
12:44:22 <VamsiAmpoluGitte> clientGender :: Client -> Gender
12:44:23 <VamsiAmpoluGitte> clientGender client = case client of
12:44:24 <VamsiAmpoluGitte>                           Company  _ _ (Person _ _ gender) _ -> gender
12:44:24 <VamsiAmpoluGitte>                           Individual (Person _ _ gender) _   -> gender
12:44:25 <VamsiAmpoluGitte>                           _                                  -> Unknown
12:44:26 <VamsiAmpoluGitte> ```
12:44:26 <VamsiAmpoluGitte> and the type:
12:44:33 <kadoban> :(
12:45:04 <pikajude> too bad markdown doesn't work in IRC
12:45:16 <dolio> No, it's not too bad.
12:45:26 <pikajude> yes it is
12:45:40 <dolio> Unless you like getting banned.
12:45:41 <ongy> well, there's some amount of text formatting you can do
12:46:00 <pikajude> why would you get banned for using markdown
12:46:21 <dolio> If you're going to use it to dump a bunch of formatted lines, you'll get banned.
12:46:31 <pikajude> yeah, but that's a terrible idea
12:46:38 <EvanR> colors should work
12:46:54 <ongy> so should bold and italic
12:47:05 <EvanR> italic not so much
12:47:10 <pikajude> I'm just thinking of gitter here
12:47:12 <MarcelineVQ> bold and italic?
12:47:18 <pikajude> where you can paste code inline and it looks nice
12:47:23 <EvanR> italic didnt work
12:47:52 <dolio> Anyhow, you could use an IRC client that let you use markdown syntax but formatted in a way that IRC clients will understand.
12:47:57 <ongy> I think that depends on the clients. But I'd wager that enough people are on terminal clients for it to be useless
12:48:01 <pikajude> indeed
12:48:08 <dolio> Terminals can do italics.
12:48:14 <pikajude> not these days
12:48:22 <dolio> Mine can, at least.
12:48:27 <pikajude> nice
12:48:35 <kadoban> Yeah, I dunno, I don't see anything on the relevant-seeming github issue trackers, too bad.
12:48:37 <[exa]> most terms nowadays mistake emphasize for underline
12:48:52 <EvanR> IRC is for 1970s terminals, not 2017 browsers, or 2037s "infonet experiences"
12:49:00 <dolio> Actually, I'm not sure if this one (putty) can, but the one at home can.
12:49:12 <pikajude> but who chats in a browser
12:49:16 <ongy> putty.... :0
12:49:23 <pikajude> I suppose that's what discord and slack are
12:49:28 <EvanR> pikajude: people who think markdown makes sense...
12:49:31 <MarcelineVQ> it's quite interesting to me that the irc problem isn't solved by now, the most obvious example being how web-clients still often silently cut off text that's too long instead of multi-lining it or telling the person writing it that it's too long.
12:49:37 <pikajude> what do you mean by "makes sense"?
12:49:44 <pikajude> markdown seems pretty straightforward to me
12:50:14 <EvanR> its some kind of weird compromise among various tech limitations
12:50:24 <ongy> is that the webclients doing or the server? Just cutting it off
12:50:28 <dunx> but ^Bthen^B lots ^Bof^B words would look weird ^Band then if^B ^Iwe want to write normal stuff  shit happens
12:50:33 <dunx> er
12:50:38 <dunx> s
12:50:43 <dunx> ooppps
12:50:51 <ongy> exactly that one :D
12:53:25 <mauke> ongy: probably the server. IRC has a hard message size limit of 512 bytes
12:53:52 <ikane> Hi #haskell, has anyone here used Bas Van Dijk's USB package to wrap libusb-1.0 bindings in an application who might be willing to share their experience and answer some questions about it?   
12:54:04 <dolio> Yeah, the client's doing is not detecting that the server will truncate it.
12:54:13 <dolio> Most likely.
12:56:36 <ongy> mauke: according to the standard, but from what I read most servers are a bit more flexible. mostly since extensions and tags add to the message size
12:56:57 <mauke> tags?
12:57:29 <ongy> irc 3.2 iirc, http://ircv3.net/specs/core/message-tags-3.2.html
12:58:24 <Benzi-Junior> what does http-conduit do that http-client doesn't ?
12:58:31 <Clint> conduits
12:58:47 <mauke> ongy: does anyone implement that?
12:59:14 <ongy> mauke: twitch (ab)uses it. And I think the server-time extension uses it, but I'd have to check on that
12:59:53 <ongy> jup, server-time does it. And at least znc can do server time, not sure about any networking ircd
13:01:02 <Tuplanolla> I'll remain pessimistic until I get TeX equation support.
13:01:11 <ongy> in irc?
13:01:28 <Tuplanolla> In that or in a proper replacement.
13:01:56 <fDev2179> I second Tuplanolla.  TeX support would be amazing...
13:04:44 <NextHendrix> anyone procrastinating as hard as me? https://ptpb.pw/6jie/hs
13:07:24 <Logio> Tuplanolla: there is https://github.com/patrickxia/latexify (and probably others like it)
13:07:54 <Tuplanolla> Unicode is a terrible compromise though.
13:08:20 <EvanR> NextHendrix: way harder http://lpaste.net/355953
13:09:04 <Logio> Tuplanolla: well, if text is the medium of choice for chat, can you really do better?
13:09:21 <EvanR> where text means, unicode?
13:09:25 <shapr> byorgey: did your student make any progress on getting GHC -> Reduceron?
13:09:30 <Tuplanolla> Pidgin most certainly could do better.
13:09:45 <NextHendrix> EvanR: lol
13:09:48 <NextHendrix> been there
13:10:25 <NextHendrix> "let's define geometry from scratch once again"
13:12:11 <shapr> someone I know is procrastinating hard by adding shields https://code.world/#PJdNIjE6ggCeJxsra51yTdQ
13:12:33 <EvanR> wow
13:14:09 --- mode: glguy set -o glguy
13:18:29 <shapr> code.world is really cool
13:21:28 <fDev2179> shapr, that's amazing.
13:29:18 <Benzi-Junior> Clint, what are those ?
13:30:28 <Clint> Benzi-Junior: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
13:34:39 <Benzi-Junior> Clint: so the difference is primarily in the internals of the libraries not their capabilities at the networking side of things ?
13:35:59 <Clint> Benzi-Junior: do you know about lazy io?
13:37:25 <Benzi-Junior> Clint, not more than I saw on that page
13:37:34 <Clint> Benzi-Junior: i wouldn't worry about it until you need it
13:38:17 <fresheyeball> anyone in here used servant-router?
13:38:36 <Benzi-Junior> Clint, so the two libraries should be doing pretty much the same networking stuff
13:39:03 <Clint> Benzi-Junior: http-client was split out of http-conduit and then http-conduit was rebuilt on top of http-client
13:39:39 <Clint> Benzi-Junior: so if you don't need to use conduits, you don't need http-conduit
13:39:56 <ertes-w> i wish http-client could handle TLS by itself just like http-conduit
13:40:06 <Benzi-Junior> Clint, ok thanks
13:40:14 <ertes-w> that's why i'd go for http-conduit in most cases
13:40:27 <Clint> eh, http-client-tls is easy to use
13:41:15 <ertes-w> yes, but say the user enters a URL…  now you need to check if it's HTTPS and branch on that
13:41:57 <Clint> ah, i see
13:46:05 <puregreen> have you got any examples where even a person who usually uses NonEmpty, length-indexed vectors, etc would be forced to resort to `error`? 
13:46:09 <sternmull> lyxia: Some hours ago you suggested makeClassy to get lenses for data definitions that have duplicate records. Now i try this and get "Multiple declarations of ‘myFieldName’". Do i have to do something special to make this work? I can't find anything in the docs.
13:46:32 <puregreen> i.e. examples where it's nearly impossible to encode data invariants / algorithm invariants in types
13:49:14 <ertes-w> puregreen: keeping Rational normalised
13:50:13 <lyxia> sternmull: do you have an example to share
13:50:43 <sternmull> wait a second
13:52:28 <sternmull> lyxia: http://lpaste.net/4410657797805441024, File and Ctx have duplicate fields and makeClassy leads to errors like "Multiple declarations of ‘_elems’".
13:53:25 <lyxia> Hm, it looks like makeFields is actually what I was thinking of
13:53:39 <EvanR> puregreen: all the time
13:54:24 <lyxia> sternmull: you're still not allowed to have duplicate fields without the extension
13:55:33 <sternmull> lyxia: Thanks! makeFields with DuplicateRecordFields compiles. Hopefully it also does what i want :)
13:57:18 <glguy> sternmull: For it to do what you wanted it to do, you'll probably need to change the default naming rule that makeFields uses to something else
13:57:49 <joe9> I have a HashMap Double Value, When I have a 2.4 as the key, the hashmap key (when I do a Show) is 2.40000004. When I test this, HashMap.lookup 2.4, it returns Nothing.
13:58:05 <glguy> sternmull: If you're going to go with makeFields, you don't even need to bother with DuplicateRecordFields
13:58:06 <joe9> Any suggestions on how I can use Double values as keys of a HashMap, please?
13:58:23 <joe9> Convert it to Rational?
13:58:46 <puregreen> EvanR: could you give an example if it's not too complicated / hard to explain?
13:59:02 <int-index> ertes-w, where do 'error' invocations occur when keeping Rational normalized?
13:59:47 <sternmull> glguy: But lyxia was right that i need DuplicateRecordFields to compile with duplicate fields and makeFields. Although i did not yet successfully accessed a field via lens. Maybe i do something wrong.
14:00:12 <glguy> sternmull: You don't need the duplicate fields extension when going the makeFields route
14:00:18 <LordBrain> what is the proper way in haddock to indicate a link to another heading? I tried using anchors and its not working.
14:00:28 <LordBrain> anyone know?
14:00:38 <glguy> sternmull: Instead you're expected to use a unique prefix for each of the records
14:00:54 <sternmull> glguy: Oh, ok.
14:00:57 <glguy> data A = A { aField1 :: T }; data B = B { bField1 :: T }; makeFields ''A; makeFields ''B
14:01:02 <LordBrain> i tried #HLF# to indicate the achor and then MY.Module.Name#HLF to indicate the link, but it's not working
14:01:50 <ertes-w> int-index: you need normalisation for certain Rational operations like (==)
14:01:51 <sternmull> glguy: Actually i hoped for the generated typeclasses that would me allow to access my fields by name, even if the use the same name for fields in different data definitions.
14:02:11 <AWizzArd> Does the Haskell compiler rewrite if expressions into case? Or is it the other way around?
14:02:11 <EvanR> puregreen: specifically error outside-the-box, or using partial functions?
14:02:12 <LordBrain> if anyone answers my question, be sure to tag it with my nick, so i know.
14:02:14 <EvanR> like head and fromJust
14:02:19 <glguy> sternmull: yeah, the typeclasses don't include the prefix in the generated names
14:02:26 <ertes-w> int-index: Rational's answer is to keep the constructor hidden and make sure that the invariant is never broken
14:03:11 <sternmull> glguy: But using makeClassy leads to redefinitions for the duplicates... i don't get it.
14:03:25 <lyxia> AWizzArd: yes if expressions get rewritten to case
14:03:27 <glguy> sternmull: makeClassy isn't intended for this usecase
14:03:33 <EvanR> puregreen: anything involving a Data.Map which contains data you "know" is there, youll probably be skirting the hazardous use of fromJust or erroring lookup to get the data
14:03:50 <lyxia> AWizzArd: case is one of the constructs in Core
14:03:52 <EvanR> since you "know" its there, anything else will result in you using error later when you get the Just
14:04:18 <sternmull> glguy: Ok. I am completely new to lens. Is there a makeXxx that does what i want?
14:04:48 <glguy> sternmull: no, not by default. this isn't a route that's encouraged
14:05:13 <EvanR> like ertes-w is saying its nice when you can encapsulate the non-compiler-checked stuff inside of some kernel of trust, like the Rational type does
14:05:23 <glguy> If you want to pursue it you'll have to build a custom LensRules value that does what you wanted and pass that to makeLensesWith
14:05:29 <ertes-w> int-index, puregreen: the point is that proving that a rational is normalised is insanely difficult through curry-howard
14:05:37 <sternmull> glguy: Damn. Is there a way to painlessly use duplicate fields (and ideally lens at the same time) at all?
14:05:58 <ertes-w> or rather proving that certain operations like (+) *maintain* the normalisation
14:06:05 <EvanR> ertes-w: which operation requires that the rep be normalized or else it should error
14:06:15 <ertes-w> EvanR: (==)
14:06:22 <EvanR> that wouldnt error
14:06:26 <EvanR> it would give the wrong answer
14:06:31 <ertes-w> well, yeah
14:06:43 <AWizzArd> lyxia: okay nice, wasn’t sure about that.
14:07:03 <EvanR> a simpler example of == is, numerator
14:07:12 <EvanR> its supposed to give the normalized numerator
14:07:28 <EvanR> but i dont see where error comes in
14:08:00 <ertes-w> yeah, i guess you don't need 'error' here
14:08:35 <EvanR> but if you have the opportunity in your module to detect violations of invariants
14:08:45 <EvanR> you could put error "bug in my module line 999"
14:08:57 <ertes-w> but it's easy enough to come up with some sequence of rationals that should never be empty, then take the 'head' of that
14:09:28 <EvanR> yeah partial functions for situations that you "know" are right come up often enough
14:09:39 <EvanR> which isnt exactly answering a question about error
14:10:10 <ertes-w> well, you could either prove that the list will never be empty
14:10:15 <ertes-w> or you could use 'head'
14:10:28 <EvanR> i recall in my early days of haskell knowingly putting in partial functions a lot, thinking "itll never be so and so", and then it usually happened ;)
14:10:32 <ertes-w> proving will involve all kinds of arithmetic properties
14:10:47 <EvanR> you mean you could either prove it will never be empty, or not before using head? ;)
14:11:00 <EvanR> either with proof assistant or in your head
14:11:47 <EvanR> and then when you go back to work and use a normal language, you do these proofs in your head nine times a minute
14:12:02 <ertes-w> by "prove" i mean: construct it in such a way that the empty list wouldn't be a valid pattern
14:12:16 <EvanR> prove it to the compiler
14:12:32 <EvanR> what a pain in the ass!
14:13:45 <ertes-w> i have an example…  a few months ago i wrote an implementation of the exact fibonacci formula
14:14:14 <ertes-w> avoiding line 63 is very difficult: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
14:14:30 <maerwald> EvanR: well, languages that don't make the use of partial functions easy are annoying
14:14:44 <maerwald> because then you end up doing error handling in places where it makes no f*ing sense
14:14:45 <ertes-w> → proving that the resulting rational is always an integer
14:15:56 <EvanR> maerwald: annoying for that reason, and annoying for being a language that lets me potentially talk nonsense on the subject ;)
14:16:08 <EvanR> like head []
14:16:25 <ertes-w> puregreen: you might find this one interesting…  proving that line 63 is unreachable is so expensive that i'd rather not do it, even though i would know how to approach it
14:16:36 <maerwald> EvanR: yes, that's where proof assistants come into play as you said. But they open another can of worms. 
14:16:57 <EvanR> i was thinking more, i wish i was using a language that makes sense for this one line of code, or something
14:17:03 <EvanR> not a proof assistant
14:17:17 <maerwald> like, returning None object? :P
14:17:31 <EvanR> huh
14:17:37 <joe9> centsToDollars = printf "%0.2f" . (/ 100) -- is what I want to use to convert cents (Integer) to a dollar amount. Is there a better way of doing this?
14:17:58 <maerwald> "main is mostly a function"
14:18:06 <EvanR> > 123 / 100 :: Centi
14:18:08 <lambdabot>  1.23
14:18:08 <joe9> error: http://codepad.org/RHOTAg3M
14:18:20 <joe9> EvanR: cool, Thanks. will check out Centi
14:18:30 <EvanR> > '$' : show (123 / 100 :: Centi)
14:18:32 <lambdabot>  "$1.23"
14:18:41 <ertes-w> joe9: the actual conversion is just the (/ 100) part, which looks fine to me
14:19:01 <joe9> EvanR: Is Centi in Data.Fixed?
14:19:05 <EvanR> yeah
14:19:12 <EvanR> i would be suspicious of using Double here
14:19:25 <ertes-w> Rational =)
14:19:29 <EvanR> or Rational
14:20:37 <joe9> ok, Thanks. will stick with Centi. It seems the more rational way of doing it.
14:21:51 <EvanR> its basically integer-number-of-cents but with a different division
14:22:13 <EvanR> conversion to and from Integer should be cheap
14:22:42 <EvanR> and the show instance is convenient
14:23:27 <joe9> EvanR http://codepad.org/gowPcGTs is my function definition  error is : http://codepad.org/1i936deJ
14:23:46 <puregreen> ertes-w: I haven't managed to figure out what “5” means in your example :)
14:23:49 <joe9> EvanR: Is there a better method of defiining the Price data type. I want to use it as a HashMap key
14:23:54 <EvanR> what are you trying to do even
14:24:00 <joe9> when I use double, some of the hashmap lookups fail.
14:24:13 <EvanR> type Price = Centi ?
14:24:35 <joe9> I have a price coming in. The lowest denomination is Cents.
14:24:45 <EvanR> 0.01
14:25:17 <EvanR> formatPrice = fromString . show
14:25:20 <joe9> and, Centi would work fine with HashMap lookups, correct? as, it is just an integer representation. (unlike double)
14:25:42 <EvanR> the question is if it has a Hasable instance
14:25:44 <EvanR> Hashable
14:26:24 <EvanR> it does
14:26:31 <joe9> EvanR: :info Centi does not show a Hashable instance
14:26:37 <EvanR> import Data.Hashable
14:26:56 <joe9> ok, Thanks.
14:28:46 <joe9> EvanR: It appears that Data.Fixed is more reliable than using Float or Double values. Is that so?
14:29:12 <EvanR> depends
14:29:21 <pikajude> for doing fixed point calculations
14:29:23 <sternmull> lyxia, glguy: It seems makeFields with FlexibleInstances finally works.
14:29:23 <pikajude> it certainly is
14:29:27 <EvanR> > 1/3 :: Pico
14:29:29 <lambdabot>  0.333333333333
14:29:46 <EvanR> > 3 * (1/3 :: Pico) == 1
14:29:48 <lambdabot>  False
14:30:20 <EvanR> its a numeric salad bowl... rather than a hierarchy
14:31:00 <joe9> EvanR: That sucks about the 3 * 1/3 == 1. Is there a representation where it matches?
14:31:05 <EvanR> Rational
14:31:25 <joe9> why not Rational then instead of Centi?
14:31:38 <ertes-w> puregreen: the exact fibonacci formula involves computing with sqrt(5)
14:31:45 <EvanR> but 9 dollars divided by 3 .... doesnt make sense
14:31:49 <ertes-w> puregreen: so my approach is to compute in the number field with sqrt(5)
14:31:50 <geekosaur> there's also CReal and possibly Scientific
14:32:06 <geekosaur> but these will both have problems with sqrt(5)
14:32:10 <pikajude> what do you need to use it for
14:32:27 <geekosaur> in short: there is no representation that 100% works perfectly that I am aware of; there are some that come closeish
14:32:36 <ertes-w> puregreen: even though it involves the extra irrational, all arithmetic is exact and fast
14:32:55 <EvanR> joe9: im skeptical about a show instance for rational values that dont have denominator power of 10
14:33:04 <geekosaur> if you're spending most of your time in transcendentals, there are representations optimized for that although I don't know if there are Haskell implementations
14:33:08 <EvanR> or divides 10
14:33:13 <EvanR> or vice versa
14:34:00 <EvanR> joe9: when you split the bill into 3... you get 3 numbers that add up to original, but they arent equal...
14:34:04 <EvanR> unlike Rational
14:35:01 <ertes-w> geekosaur: i think the number field is both the best choice and a good choice: the number (NF x y) represents the number (x + y*sqrt 5)
14:35:37 <joe9> EvanR: makes sense. So, Centi is the way to go in this instance.
14:36:02 <EvanR> for ordinary money Centi makes damn sense... oh a pun
14:36:39 <ertes-w> BTW, (NF (-1)) is the complex numbers =)
14:36:56 <ertes-w> well, the complex rationals =)
14:37:09 <EvanR> NF e where e^2 = 0 is dual numbers
14:37:12 <pikajude> NF (-1) 0
14:37:14 <pikajude> isn't that just -1
14:37:28 <ertes-w> pikajude: yeah
14:37:37 <ertes-w> i mean the type (NF (-1))
14:37:40 <pikajude> oh
14:38:05 <ertes-w> (NF (-1) Rational)  -- the type of complex numbers (x + i*y), where x and y are rational
14:41:45 <foojin> How does one check for "knots" in data structures? I'm learning the "tying the knot" technique and I can't devise a way to check the results.
14:42:12 <lyxia> you don't
14:42:13 <joe9> EvanR: Thanks a lot.
14:43:11 <geekosaur> foojin, the problem with this is that sharing is not observable except in IO
14:43:29 <johnw> foojin: a knot is like a data structure that unfolds on itself as you examine it, giving the impression of an infinite series, like let xs = [1,2] ++ xs in xs.  It seems like the infinite series [1,2,1,2,1,2], but all you've done is tie the knot using a self reference.
14:44:10 <pikajude> you could implement a knot-checking function using unsafePerformIO (getRandom :: IO Bool)
14:44:14 <pikajude> may not be very helpful though
14:44:58 <foojin> geekosaur: How would you go about doing it in IO then?
14:45:13 <geekosaur> it'd likely invlve reallyUnsafePtrEquality#
14:45:23 <geekosaur> or whatever that function is
14:45:45 <foojin> johnw: It surely makes a huge difference when the result is infinite, but you can use it for graphs/doubly-linked lists too.
14:45:51 <geekosaur> (and as the smae suggests you need to be careful with it: a gc while evaluating one of the two parameters could produce either a false positive or a false negative)
14:46:15 <mauke> foojin: from the perspective of haskell, those are just infinite structures
14:46:20 <geekosaur> s/smae/name/ sheesh
14:46:31 <c_wraith> I'd look at however compact regions do it. since one of the functions for creating a compact region needs to discover sharing (or else be in danger of using infinite memory...) 
14:46:51 <lyxia> If you need to observe sharing you shouldn't tie knots.
14:47:05 <geekosaur> ...and you can't just force it because if you *do* have the kind of sharing that leads to an infinite structure, it'll obviously diverge
14:47:21 <geekosaur> basically, what lyxia just said
14:48:52 <EvanR> you can attempt to do obbservable sharing
14:49:07 <EvanR> ah, lag
14:49:42 <foojin> lyxia, geekosaur: It kinda defeats the purpose of observing. If there are no knots, I wouldn't even care because it works the same no matter the low-level detals, right?
14:49:58 <EvanR> the ghc magic for this is StableNames and requires IO
14:50:23 <geekosaur> right. you should use it as an optimization and not assume or test it, or do explicit sharing which requires working in IO
14:50:33 <geekosaur> (or possibly ST)
14:51:25 <EvanR> the issue in haskell is that sharing isnt part of the semantics, so it "doesnt exist"... but in another language with the same syntax, it makes sense to treat recursive expressions as graphs
14:51:40 <EvanR> and exploit it for fame and glory!
14:52:34 <EvanR> which amounts to hacking the compiler backend, see LambdaCCC
14:54:18 <foojin> EvanR: Thanks, I'll check StableNames out. By the way, what language are you talking about?
14:54:28 <EvanR> hypothetical
14:54:40 <EvanR> or LambdaCCC
15:16:09 <sternmull> how do i make a function that works for all Seq types? I want to use the |> operator on an argument that is expected to be a Seq a.
15:17:11 <sternmull> actually it gets an argument that is a function that is expected to return a Seq.
15:20:24 <mauke> just ... do it?
15:21:37 <EvanR> decoding the rquirements step by step... a function. so it will have type A -> B for some A and B
15:21:50 <EvanR> an argument that is a function
15:21:55 <sternmull> At the moment i have "append acc x ctx = acc .~ (ctx ^. acc |> x) $ ctx". Where acc is will be an accessor generated by lens. I don't know how to tell haskell that |> will be valid.
15:21:57 <EvanR> so A = C -> D for some C and D
15:22:02 <EvanR> (C -> D) -> B
15:22:19 <EvanR> return an Seq E for some E
15:22:24 <EvanR> (C -> Seq E) -> B
15:22:32 <mauke> sternmull: what do you mean, tell haskell?
15:23:13 <EvanR> hmm, maybe steering the wrong way
15:23:13 <sternmull> mauke: Making clear to the compiler that |> is indeed a good idea at this spot.
15:23:23 <mauke> what
15:23:30 <mauke> you just write the code
15:23:57 <sternmull> yes. And i am stuck at a point where i don't know how to express my intention.
15:24:25 <mauke> how are you stuck?
15:24:42 <mauke> you said you have append acc x ctx = acc .~ (ctx ^. acc |> x) $ ctx
15:25:41 <sternmull> yes, and that doesn't typecheck because GHC does not agree with me that |> is valid where i use it.
15:25:59 <mauke> what's the actual error message?
15:26:01 <lyxia> paste your code, paste the error message
15:28:03 <sternmull> there it is: http://lpaste.net/5761942689100595200 error message at the end.
15:29:02 <Tuplanolla> Half of the Internet along with lpaste.net seems to be down for me. Is it just me?
15:29:26 <EvanR> its just you lpaste is up
15:29:45 <EvanR> that feel when down for everyone or just me is down
15:30:35 <dmwit> sternmull: Yikes. Is it possible to cook up an example with fewer dependencies?
15:32:16 <glguy> sternmull: Instead of ns .~ (ctx ^. ns |> vn); you should be writing: ns %~ (|> vn)
15:32:21 <sternmull> dmwit: Sorry... i just pasted my current code. Maybe i could reduce it to a version that only needs lens and sequence...
15:33:33 <sternmull> glguy: The lines without "append" in "builder" work. The problem came up when i tried to factor out the append stuff into the append-function.
15:33:34 <glguy> sternmull: Your problem with "append acc x ctx = acc .~ (ctx ^. acc |> x) $ ctx" stems from using acc at two different types
15:33:50 <glguy> You'll need to take an ALens here and cloneLens it
15:33:57 <glguy> or take a ReifiedLens argument
15:34:01 <sternmull> glguy: Ah, yeah. That makes sense.
15:34:21 <glguy> If you just fixed the code to use the argument once, a la (%~), aka over, then you wouldn't need to do that
15:34:38 <sternmull> at least "using acc at two different types". The rest is not so clear to me.
15:35:10 <glguy> The type of the arguments that (^.) and (.~) expect are not directly compatible
15:35:27 <glguy> so you can't use both of them with the same acc parameter
15:36:33 <glguy> sternmull: A similar example would be if you had: example f = (f 'a', f True)
15:36:50 <glguy> There's no monomorphic type that f can have here that's good enough
15:36:54 <sternmull> glguy: Thanks. I think i get it. Will try "over".
15:41:08 * hackage versions 3.0.2.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.0.2.1 (fosskers)
15:42:43 <sternmull> nice! That works. And %~ turns out to be succinct enough make my append function unnecessary.
15:43:40 <mauke> I love it when a flan comes together
15:44:38 <sternmull> that was my first nice experience with lens. Figuring out how to make it work with duplicate fields was... not so nice.
15:46:42 <EvanR> is Data.Vault efficient, like Data.Map ? or is it like an assoc list or hlist?
15:50:01 <EvanR> also there seems to be some abuse of IO or ST in Data.Vault
15:50:17 <EvanR> you need IO or ST to generate keys
15:50:59 <lyxia> a Vault is defined as a Map
15:51:05 <lyxia> http://hackage.haskell.org/package/vault-0.3.0.7/src/src/Data/Vault/ST/backends/GHC.hs
15:51:48 <EvanR> nevermind, its using IO to get a StableNames backed version of Unique
15:51:48 <joe9> How do I convert a Double to Centi? realToFrac?
15:51:54 <EvanR> yes
15:52:36 <EvanR> still seems like other monads could be more convenient to generate unique IDs
15:53:20 <EvanR> > 1.1 - 1
15:53:22 <lambdabot>  0.10000000000000009
15:53:31 <EvanR> > realToFrac (1.1 - 1) :: Centi
15:53:33 <lambdabot>  0.10
15:56:40 <joe9> EvanR, How do I get the Integer from Centi value?  :t (fromIntegral (realToFrac (00.0204 :: Double) :: Centi)) :: Integer
15:56:55 <joe9>     • No instance for (Integral Centi)
15:56:55 <joe9>         arising from a use of ‘fromIntegral’
15:57:07 <EvanR> floor
15:57:17 <joe9> EvanR: Thanks.
15:57:24 <EvanR> > 0.99 * 100
15:57:26 <lambdabot>  99.0
15:57:35 <EvanR> must be an integer so floor or ceil or round or truncate will work
15:58:10 <Gurkenglas> "import qualified Data.HashMap.LAZINESS as Map" <- intero says no such module. I agree.
16:04:10 <EvanR> /topic LAZINESS
16:06:46 <Welkin> what does intero know?
16:07:24 <MarcelineVQ> #define LAZINESS Lazy
16:07:48 <Gurkenglas> Ah, makes sense. Thanks.
16:07:57 <MarcelineVQ> it's just Data.HashMap.Lazy from probably unordered-containers
16:08:27 <Gurkenglas> Why doesn't intero run cpp before complaining?
16:10:36 <Welkin> ...
16:10:37 <MarcelineVQ> dunno, I've no idea what your end looks like ehe, are you playing with the unpacked vault source in intero?
16:10:53 <Welkin> did someone seriously write `#define LAZINESS Lazy`??
16:11:03 <MarcelineVQ> ye https://hackage.haskell.org/package/vault-0.3.0.7/docs/src/Data-Vault-Lazy.html
16:11:07 <Welkin> wtf...
16:11:16 <Welkin> what is the purpose of that? O.o
16:11:20 <MarcelineVQ> lets the swap it out easily
16:11:29 <hpc> i wonder how many naively featureful irc clients just auto-joined #define
16:12:09 <Welkin> MarcelineVQ: that's a terrible hack
16:12:20 <Welkin> abuse of the cpp
16:12:39 <MarcelineVQ> yes, and the include is a hack to not export the backend stuff I suppose, it's probably silly
16:12:58 <EvanR> i clicked source and got that almost blank page
16:13:03 <EvanR> was mad
16:13:30 <MarcelineVQ> I tend to use https://hackage.haskell.org/package/vault-0.3.0.7/src/ type lists these days so I don't miss as much hidden stuff :(
16:14:23 <EvanR> oh nice
16:15:44 <Welkin> so it's like redis
16:15:48 <Welkin> but in haskell
16:16:06 <EvanR> its a Map that holds things with different types
16:16:19 <Welkin> yes
16:16:24 <EvanR> but you have to use keys generated in IO
16:16:50 <EvanR> if youre already in IO gues its great
16:17:30 <Gurkenglas> Why not just use Map k Dynamic?
16:17:40 <EvanR> Vault is type safe
16:18:17 <EvanR> lookup :: Key a -> Vault -> Maybe a
16:18:57 <EvanR> i guess Dynamic could do the same thing but for a different reason, you get Nothing when you have a bug in your code
16:19:10 <EvanR> and requires an extra runtime test
16:19:43 <Gurkenglas> If you have to pass around a key, why not pass around the value?
16:20:12 <EvanR> because the key doesnt change, whats at that position in the vault may change
16:20:27 <EvanR> like pointer to Int vs Int itself
16:20:44 <Gurkenglas> Ah, and passing around the one value of a changing vault is less hassle
16:21:45 <EvanR> well the Vault is immutable too
16:22:14 <Welkin> what about vault hunters?
16:22:33 <Gurkenglas> just like the value. instead of passing around the value after it changed, you pass around the vault, which allows you to pass around multiple changing values.
16:22:53 <Welkin> use State
16:23:03 <Welkin> or is there a Vault monad
16:23:04 <EvanR> its like passing around a Map, but heterotypal
16:23:36 <EvanR> this seems like less work than DMap if you have IO
16:38:02 <orzo> If I use splitAt some other method of breaking up a contiguous bytestring and then use append to reassemble them, will Data.Bytestring be smart enough to reproduce the original contiguous buffer without copying?
16:38:58 <lyxia> I don't think so
16:40:51 <orzo> i have a large bytestring that i need to filter a single chunk out of, i want to break it into chucnks, perform a predicate filter, and reassemble
16:41:11 <orzo> I'd rather not a bunch of unnecessary allocations
16:42:25 <orzo> how do I go about that?
16:43:18 <mauke> write the algorithm as simple as possible, then benchmark it
16:43:31 <nshepperd> you could only prevent allocations if the result is a contiguous subarray of the original bytestring
16:43:58 <orzo> well i'll need one allocation as it's strict
16:44:49 <orzo> Hmm. I guess toStrict on a lazy bytestring consisting of my filtered chunks will do the right thing
16:45:33 <orzo> it'll copy the chunks one at a time, but only to the output buffer, so not a big deal
16:46:46 <nshepperd> oh, just for concatening the result efficiently, mconcat should do the right thing, too
16:46:54 <orzo> by the way, i noticed the strict concat sucks compared to toStrict . fromChunks
16:47:23 <orzo> my version of concat will just fold the <> operation
16:47:40 <orzo> which would perform intermediat copies
16:48:29 <orzo> i'm using bytestring 0.10.8.1.  DOn't know if its fixed in latest
16:49:54 <nshepperd> should be right in 0.10.8.1... https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Internal.html#line-455
16:51:27 <nshepperd> the Foldable instance for lists doesn't point fold to mconcat though, that's weird
16:53:25 <orzo> er, well, the code you linked looks right, but i guess i was confused by the multiple indirections and ifdefs from the public source which defines concat as mconcat
16:53:43 <orzo> s/public/non-internal/
16:54:16 <dmwit> :t fold
16:54:17 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:54:34 <orzo> i guess I should stick with S.concat even if it looks like there's a build path where it might do the wrong thing?
16:55:27 <nshepperd_> There's a public concat, which points to mconcat, which points to the internal concat, which is fast
16:55:44 <nshepperd_> \(0.o)/
16:56:15 <Welkin> public?
16:56:23 <Welkin> oh, you mean exported
16:56:32 <orzo> Welkin: Data.Bytesring.concat rather than Data.Bytestring.Internal.concat
16:57:04 <Welkin> shouldn't you use Builder if you need to concat long sequences of strings?
16:57:30 <nshepperd_> :t mconcat
16:57:32 <lambdabot> Monoid a => [a] -> a
16:57:42 <orzo> dunno, i have it as a large bytestring to begin with, i'm filtering chunks out to create a new contiguous bytestring
16:57:53 <orzo> should i really reach for builder in that case?
16:58:05 <nshepperd_> Seems like fold = mconcat for the case where t = [] would be an easy performance win
16:58:25 <dmwit> I wonder whether it still makes sense for `mconcat` to be in `Monoid`. I guess this is so that particular monoids can choose between `foldr (<>)` and `foldl' (<>)`?
16:58:43 <Welkin> builder will give you your new string in a linear number of operations
16:58:57 <Welkin> no matter how many conacts you would otherwise be performing
16:59:03 <Welkin> concats*
16:59:06 <nshepperd_> dmwit: sure, and so that they can do stuff like preallocating the final result
16:59:38 <Welkin> dmwit: where else would you put mconcat?
16:59:41 <dmwit> nshepperd_: Ah, that last one can't easily be done in Foldable at all.
17:00:01 <dmwit> Welkin: Foldable. But it's now clear to me why that's not a good fit.
17:00:06 <dmwit> :t fold
17:00:08 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:01:15 <dmwit> nshepperd_: Okay, now convince me we shouldn't generalize `mconcat` to have `fold`'s type. =)
17:01:56 <Welkin> :t mconcat
17:01:58 <lambdabot> Monoid a => [a] -> a
17:02:00 <EvanR> seems obvious
17:02:04 <EvanR> given the burning bridges
17:02:04 <Welkin> huh
17:02:10 <Welkin> I thought it *Was* more general
17:02:15 <nshepperd_> fold and mconcat serve rather dual purposes. Fold is there to use special knowledge about the foldable structure; mconcat is there to take advantage of knowledge about the monoid
17:02:16 <EvanR> still not
17:02:43 <Welkin> :t mappend
17:02:45 <lambdabot> Monoid a => a -> a -> a
17:03:40 <nshepperd_> You can't put mconcat in foldable, because it becomes pointless if the monoid is unknown :p
17:03:51 <EvanR> i mean change the type of mconcat
17:03:57 <dmwit> nshepperd_: Yes, you already convinced me of that.
17:04:06 <dmwit> Now I'm pondering keeping mconcat in Monoid but generalizing its type.
17:04:21 <nshepperd_> dmwit: I dunno, you could generalise the type of it like that I suppose
17:04:36 <Welkin> huh
17:04:56 <Welkin> it seems like the definition for Monoid [a] should be more general too o.o
17:04:58 <Welkin> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Monoid
17:05:13 <Welkin> <> vs ++
17:05:24 <dmwit> Welkin: huh?
17:05:25 <Welkin> oh wait, nevermind haha
17:05:34 <Welkin> that would be infintely recursive
17:05:37 <nshepperd_> Seems not very useful though because you would usually just call toList first? If you're going to do anything special
17:06:19 <dmwit> nshepperd_: I wouldn't. I'd `foldMap (Sum . length)` or whatever, pre-allocate my buffer, then `foldr` or `foldl'`. No sense converting to `[]`.
17:06:26 <EvanR> just make class Foldable where toList :: f a -> [a] ?
17:06:50 <dmwit> nshepperd_: So that way you get the Foldable instance's special knowledge of the structure, and Monoid's special knowledge of the monoid.
17:06:58 <Gurkenglas> EvanR, what if it's a left-degenerated infinite tree?
17:07:14 <pikajude> shouldn't be too much of a problem
17:08:40 <Gurkenglas> EvanR, http://comonad.com/reader/2015/free-monoids-in-haskell/
17:08:52 <johnw> monoids that cost nothing
17:09:42 <EvanR> readit
17:10:04 <EvanR> if its that important, then moncat should operate on a foldable ?
17:12:32 <Gurkenglas> There might be a more efficient implementation for mconcat for [] than for foldables
17:12:34 <nshepperd> hm. data BuilderForMyMonoid = Single | ...; mconcat xs = finalizeMyBuilder (foldMap Single xs)
17:13:04 <Gurkenglas> Could an implementation of mconcat for foldables possibly be something other than fold?
17:13:17 <dmwit> ?hackage fmlist -- the free monoid as a package, in case you're into that
17:13:17 <lambdabot> http://hackage.haskell.org/package/fmlist -- the free monoid as a package, in case you're into that
17:13:28 <nshepperd> Gurkenglas: it can be a fold for a different monoid, like I just wrote!
17:13:37 <EvanR> i kind of dont get the difference between [ ] and foldable
17:14:16 <EvanR> what you can and cant do with either
17:14:21 <dmwit> EvanR: If the free monoid post didn't at least give an example of a `Foldable` instance that is qualitatively different from `[]`, I'm not sure it's possible to.
17:14:23 <EvanR> i thought anything you can do with list, you can do with foldable
17:14:31 <Gurkenglas> EvanR, [...,3,2,1,0] can be foldMap'd, but not by going through toList
17:15:05 <EvanR> i dont see how that cant be toListed
17:15:07 <nshepperd> there are some things you can do with foldable that you can't do with lists
17:15:23 <Gurkenglas> EvanR, what's the first element of the list?
17:15:24 <nshepperd> toList [...,3,2,1,0] = ⊥
17:15:26 <EvanR> 0
17:15:26 <dmwit> EvanR: It can't be toList'd because it computing its head takes infinitely long.
17:15:37 <dmwit> EvanR: That's toList . reverse ;-)
17:15:41 <Gurkenglas> EvanR, monoids aren't commutative in general, you have to preserve the order
17:15:43 <EvanR> seems like foldable is broken then?
17:15:50 <nshepperd> EvanR: no, 0 is the last element
17:16:12 <EvanR> is that supposed to be a tree?
17:16:32 <dmwit> EvanR: think `data SnocList a = Lin | Snoc (SnocList a) a`.
17:16:32 <EvanR> what does this have to do with Monoids
17:16:42 <Gurkenglas> nshepperd, Single isn't a function, that doesn't compile in my head :I
17:16:56 <EvanR> "Lin" ?
17:17:03 <dmwit> Backwards nil. ;-)
17:17:13 <nshepperd> Gurkenglas: lol, you're right i misspelled the type definition
17:17:40 <EvanR> ok, because foldable requires you do it through Monoid
17:17:41 <Welkin> basketball?
17:17:45 <dmwit> instance Foldable SnocList where foldMap f Lin = mempty; foldMap f (Snoc xs) x = foldMap f xs <> f x
17:17:56 <Welkin> lol
17:17:58 <Gurkenglas> > getFirst $ foldMap (First . Just) [0..]
17:17:58 <EvanR> not "fold however you can"
17:18:00 <lambdabot>  Just 0
17:18:00 <Welkin> I like snoc
17:18:33 <dmwit> Oh, I missed an opportunity there. Can I name it `data Tsil` instead? =D
17:19:07 <EvanR> i am not so far seeing a difference between this and list
17:19:17 <EvanR> due to alpha equivalence
17:19:35 <Gurkenglas> EvanR, the monoid values are combined the other way
17:19:41 <EvanR> ok
17:19:48 <dmwit> EvanR: They are not alpha equivalent. For lists, `foldMap f (x:xs) = f x <> foldMap f xs`; for Tsil, `foldMap f (Snoc xs x) = foldMap f xs <> f x`.
17:19:49 <Welkin> you could as easily reverse before doing that
17:19:54 <dmwit> EvanR: The arguments to `(<>)` come in the other order.
17:19:57 <EvanR> ok so a different Foldable instance
17:20:04 <Welkin> lol
17:20:19 <Welkin> foldl vs foldr
17:20:27 <dmwit> EvanR: In particular, `foldMap First` for lists would terminate quickly, and never for infinite Tsils. `foldMap Last` would terminate quickly for Tsil and never for infinite lists.
17:20:52 <Gurkenglas> EvanR, the linked article you said you read explains all this :I
17:20:56 <Welkin> what would be a use case for a SnocList?
17:20:59 <EvanR> i did read it
17:21:06 <EvanR> in 2015 ;)
17:21:20 <EvanR> and at this point seems not that interesting
17:21:30 <dmwit> Welkin: It's common to just use [] for this, and "remember" that we're building the list backwards. Then do one big `reverse` at the end. I've used Tsil in such situations in the past to remind myself whether I was thinking of a list as forwards or backwards.
17:21:35 <EvanR> the take away is not to call [] free monoids
17:21:37 <nshepperd> snoc lists are a rather artificial example, i'd never imagine myself using one
17:21:48 <nshepperd> but infinite trees happen all sorts of cases
17:21:53 <dmwit> Welkin: e.g. the poor-man's queue is naturally thought of as `([a], Tsil a)` rather than `([a], [a])`.
17:21:53 <Welkin> dmwit: if you need a data structure like this, why not use Sequence.Seq?
17:21:59 <nshepperd> and has the same effect
17:22:24 <Gurkenglas> dmwit, you mean zipper, not queue, right?
17:22:31 <Welkin> dmwit: I see, given the queue example
17:22:41 <Welkin> but Seq is still a nicer data structure
17:22:43 <dmwit> Gurkenglas: I don't mean that, but a zipper is another good example.
17:22:58 <EvanR> "poor mans queue" is pretty nice
17:23:01 <dmwit> Gurkenglas: There I think I would want `(Tsil a, [a])`, though. =)
17:23:18 <EvanR> in terms of performance and complexity
17:23:21 <nshepperd> foldMap (Last . Just) (toList tree) != foldMap (Last . Just) tree, if tree has any infinite parts in it
17:24:24 <Welkin> and a Map/Set is a poor-man's priority queue
17:26:05 <EvanR> if you insert near the beginning... list is a great priority queue ;)
17:27:12 <lyxia> the ultimate LIFO queue
17:28:43 <edwardk> evanr a sorted list is a unary heap
17:30:22 <nshepperd> anyway, as to the original question, you could foldMap byteStringToBuilder, and then finalize the result, which is maybe more explicit for the reader about the performance expectations, rather than just doing mconcat
17:30:24 <nshepperd> but, meh
17:32:43 <edwardk> welkin: you can have infinite snoclists, but an infinite Seq is always _|_
17:33:03 <edwardk> different data structures allow different infinite cases to work
17:33:46 <nshepperd> oh, it looks like Data.ByteString.Builder only produces lazy bytestrings anyway, so that's useless
17:35:03 <edwardk> welkin: i'll use random access lists based on skew binary even though Seq offers the same operations for most things for pure constant reasons
17:36:38 <edwardk>  or because it provides me with a fixed shape for a given number of elements. i can use that to zip spines together https://www.schoolofhaskell.com/user/edwardk/online-lca
17:37:16 <edwardk> the poor man's queue is quite fast for ephemeral use
17:37:40 <edwardk> you can tweak it a very small amount to get access to be worst case O(1) as well
17:38:14 <edwardk> er access to head and tail
17:40:07 <EvanR> skew binary random access lists? fixed shape? pure constant?
17:42:39 <edwardk> skew binary: count with digits 0,1,2 but only allow 2 to be the least significant non zero in your number. digits are worth 2^(k+1)-1 = 1,3,7,15... each number has a unique representation like in binary. incrementing by 1 only ever causes a single "carry" though
17:43:00 <edwardk> fixed shape, there is a unique representation for each number, like in binary
17:43:09 <EvanR> oh neat
17:43:19 <edwardk> pure constant i meant purely for constant factor reasons not a technical term
17:44:08 <edwardk> skew binary: 0,1,2,11,12,20,100,101,102,110,111,112,120,200,1000
17:44:22 <edwardk> notice how slow the move up to the next length is?
17:44:32 <edwardk> 11,12,20,100
17:45:41 <EvanR> still 8 terms with 3 digits
17:45:46 <Welkin> o.o
17:45:48 <Welkin> never heard of it
17:46:00 <Welkin> what is the use case for skew binary?
17:46:14 <EvanR> but we already covered 6 numbers by that point
17:46:20 <EvanR> sweet
17:46:48 <edwardk> data T a = Tip a | Bin (T a) (T a); data L a = Cons !Int  (T a) (L a) | Nil
17:47:27 <nshepperd> skew binary is great because you never get cascading carries
17:48:05 <EvanR> would this make faster hardware adding if we have trinary bits?
17:48:10 <EvanR> in electronics
17:48:21 <edwardk> cons a (Cons n l (Cons m r xs) | n == m = Cons (2*n+1) (Bin a l r) xs; cons a as = Cons 1 (Tip a) as
17:48:21 <Welkin> trits
17:48:28 <Welkin> bits = binary integers
17:48:36 <edwardk> fix the Bin constructor to have an a in it
17:48:47 <edwardk> O(1) cons but log n indexing
17:48:48 <nshepperd> in binary: 1111111 + 1 = 10000000 -> a whole lot of work to add 1, that kills your worst case time (non amortized)
17:48:50 <edwardk> log n drop
17:48:51 <EvanR> skeptical of that retroactive etymology
17:49:09 <edwardk> skew binary adders in general suck
17:49:15 <edwardk> skew binary increment is cheap
17:49:22 <EvanR> ok
17:49:24 <nshepperd> "terits". ternary digits
17:49:40 <Welkin> oh yeah, not integers
17:49:42 <Welkin> digits
17:49:58 <edwardk> anyways if you look at the cons above it is non recursive
17:50:00 <Welkin> bi(nary) (digi)ts
17:50:19 <edwardk> but it builds log n trees over n operations each full, and of height log n
17:50:25 <edwardk> at most
17:50:49 <ReinH> or is it b(inary) (dig)its
17:50:55 <EvanR> so
17:51:00 <EvanR> this is like a better list
17:51:12 <edwardk> if you dont need infinite lists, yes
17:51:39 <Welkin> ah
17:51:45 <ReinH> it's either terts or trits.
17:51:48 <Welkin> I remember this concept from Okasaki
17:51:50 <Welkin> skew heaps
17:52:15 <edwardk> welkin he wrote a paper on them and had a chapter in his thesis/book
17:52:21 <edwardk> not heaps
17:52:27 <edwardk> skew binary random access lists
17:52:34 <edwardk> he uses the recurrence multiple times
17:52:55 <edwardk> you can use the leonardo number recurrence to the same end
17:53:22 <edwardk>  https://www.schoolofhaskell.com/user/edwardk/fibonacci/leonardo
17:53:34 <mauke> <ningu> fun fact, you can't fold constants more than 7 times
17:53:40 <edwardk> same asymptotics, slightly more skewed
17:53:57 <edwardk> which can ironically be useful
17:55:04 <Welkin> oh yeah I see it here
17:55:18 <Welkin> 9.3 Skew Binary Numbers
17:55:29 <Welkin> I only read as far as Leftist Heaps though
17:55:32 <Welkin> which seems similar
17:57:21 <edwardk> the main thing here is that skew binary represents a given number of elements in exactly one shape, same with the leonardo list i mentioned
17:58:41 <edwardk> for me that matters because given an O log k time drop and O(1) or even log n time lengh, i can compute things like lowest common ancestors in logarithmic time just given two paths down a tree and i can extend the paths in O(1)
17:59:10 <edwardk> this is quite useful for a monad i like
18:00:18 <edwardk> leftist and skew heaps just "tend to lean"
18:00:33 <edwardk> so the relationship is very very weak
18:15:57 <edwardk> fwiw- why i'm sort of stuck on this topic, i have a thing i've been writing where i need to have a type aligned thing that could be a skew binary random access list or a sequence, etc whrere i need a well typed "drop"
18:16:18 <edwardk> and that drop needs to be O(log k) where k is the number of elements dropped
18:16:46 <edwardk> i can meet most of the requirements with Seq, except the type manipulation
18:17:03 <edwardk> (Seq modified reflection without remorse style)
18:17:36 <edwardk> see i either accept log n becoming n, an unsafeCoerce, or i find a better data structure :)
18:19:20 <edwardk> if i can get those i have a nice variant on a suspension calculus that is cheaper than existing literature
18:19:51 <edwardk> which'd be a nice way to pay back bitonic for nerd sniping me with the problem
18:22:47 <joe9> I am trying to figure out how to use this package? http://hackage.haskell.org/package/text-format . There are not any samples there. Any suggestions, please? I want to format a double with the shortest fixed precision. For example, 100.222333 to 100.222, and, 100.00 to 100 (only show 3 decimals)
18:26:55 <ReinH> what does 'shortest fixed precision' mean?
18:28:17 <NextHendrix> having some real trouble grokking the Functor instance of State
18:28:47 <ReinH> NextHendrix: where are you having the trouble?
18:29:20 <NextHendrix> i think i might have stared at the code for too long and im totally looking through it
18:29:42 <NextHendrix> newtype State s a = State { runState :: s -> (a, s) }
18:30:27 <NextHendrix> that whole line just doesn't compute at all in my head
18:30:51 <NextHendrix> could you break it down
18:30:53 <edwardk> Remove the new type and just try writing the function
18:31:53 <edwardk> fmapState ab s2as s = _
18:31:53 <ReinH> iow, fmap :: (a -> b) -> (s -> (a, s)) -> (s -> (b, s))
18:31:55 <pacak> NextHendrix: When you run this monad  you'll have to pass s as extra parameter. Monadic instance will ensure that this s will be passed all the way
18:32:25 <pacak> NextHendrix: with some extra function you'll be able to get/set/modify it.
18:32:41 <NextHendrix> well im in the part of this book where it says "write the Functor instance" and im just wound up
18:32:51 <ReinH> NextHendrix: try to write fmapState
18:32:55 <EvanR> NextHendrix: runState :: State s a -> s -> (a, s)
18:32:57 <edwardk> Now you need to supply a b and an s in tuple form
18:33:04 <EvanR> runState is an accessor
18:33:22 <edwardk> But to get a b you need an a
18:33:59 <edwardk> s2as gives you an a given an s
18:34:11 <edwardk> But you have an s!
18:34:59 <edwardk> fmapState ab s2as s = _ where (a,s') = s2as s
18:35:39 <edwardk> So now you just need to tuple up ab a and one of your s's, either s' or s
18:35:58 <edwardk> The laws for fmapState force you to pick s'
18:37:04 <edwardk> Add newtype noise, stir and season to taste
18:37:17 <ReinH> This is too much work, let's just ask a computer to write it for us.
18:37:19 <ReinH> @djinn (a -> b) -> (s -> (a, s)) -> s -> (b, s)
18:37:19 <lambdabot> f a b c =
18:37:19 <lambdabot>     case b c of
18:37:19 <lambdabot>     (d, e) -> (a d, e)
18:37:40 <ReinH> Interesting that it chooses the one that uses the correct state.
18:37:51 <edwardk> Got lucky
18:37:57 <ReinH> We could have helped it with @djinn (a -> b) -> (s -> (a, s')) -> s -> (b, s')
18:38:09 <ReinH> edwardk: interesting because I would have expected the other one to show up in first in the search
18:38:10 <edwardk> Djinn works best with indexed types
18:38:16 <edwardk> Yeah
18:38:23 <ReinH> like it does for <*> iirc
18:39:05 <edwardk> Opening the case pushed the s earlier in the environment
18:39:16 <ReinH> Hmm
18:40:19 <edwardk> Mostly luck :)
18:40:45 <edwardk> When writing cont etc I always index for djinn
18:41:32 <ReinH> do you have a fancy indexing trick or do you just add primes?
18:42:13 <edwardk> I just add the newtype for the atkey style indexed monad
18:42:28 <ReinH> Which one is that? The one Conor likes?
18:42:44 <edwardk> I like i and j not s and s'
18:42:52 <ReinH> right
18:43:06 <edwardk> The 2 param version
18:43:20 <ReinH> ah yes
18:43:26 <edwardk> Atkey not McBride
18:43:45 <ReinH> I couldn't remember if McBride used Atkey's or a different one
18:43:53 <edwardk> 1 param needs higher rank and djinn gives up
18:44:11 <ReinH> Oh I'll just ask him https://stackoverflow.com/a/28696299/2225384
18:45:44 <edwardk> Heh my reply is there too
18:46:18 <edwardk> Add's orchard's version
18:46:40 <edwardk> Er adds
18:46:45 <ReinH> :)
18:47:23 <ReinH> Ah yes, any excuse McBride can find to use a binary operation of three arguments.
18:50:09 <EvanR> :t proxy
18:50:10 <lambdabot> error:
18:50:11 <lambdabot>     • Variable not in scope: proxy
18:50:11 <lambdabot>     • Perhaps you meant data constructor ‘Proxy’ (imported from Data.Typeable)
19:33:38 * hackage aur 6.0.0.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-6.0.0.1 (fosskers)
20:29:54 <fresheyeball> I have a weird error
20:30:04 <fresheyeball> I know that (Either a) is an Alternative Functor
20:30:11 <fresheyeball> but when I try to use it I get this error
20:30:35 <fresheyeball> "No instance for (Control.Monad.Trans.Error.Error a) arising from use of <|>
20:30:38 <fresheyeball> what gives?
20:30:53 <glguy> fresheyeball: Which part of that don't you understand?
20:31:00 <fresheyeball> I don
20:31:13 <fresheyeball> I don't understand how my Either literal is somehow this other type
20:31:18 <fresheyeball> or why Error is not alternative
20:32:00 <glguy> Control.Monad.Trans.Error defines: instance (Error e) => Alternative (Either e)
20:33:20 <jle`> fresheyeball: try pasting some code
20:33:26 <fresheyeball> I'm just confused
20:33:31 <jle`> oh, ah
20:33:32 <fresheyeball> I didn't import Trans.Error
20:33:45 <jle`> yeah, the Alternative instance you're using requires an Error instance for the 'e' parameter
20:34:04 <glguy> fresheyeball: Can you explain what the instance I pasted means?
20:34:51 <jle`> fresheyeball: even if you didn't import that module, you might be importing a module that imports that module
20:34:57 <jle`> typeclass instances in haskell are global
20:34:59 <fresheyeball> ick that did it
20:35:30 <jle`> if you import any module that imports any module that imports Control.Monad.Trans.Error, you'll get that instance
20:35:55 <jle`> and, yeah, `forall a. Either a` indeed has no possible Alternative instance
20:36:15 <jle`> although Error is a weird constraint to have on that
20:36:29 <jle`> i'd expect an instance for forall a. Monoid a => Either a
20:36:37 <fresheyeball> yeah, it messes with my intuition
20:37:12 <glguy> The Monoid behavior is handled by Except and ExceptT
20:38:00 <fresheyeball> so how should I solve this?
20:38:06 <fresheyeball> Error is depcricated
20:38:07 <jle`> it depends on what you want to do
20:38:13 <fresheyeball> should I just use the deprecated one?
20:38:20 <jle`> what do you want to do
20:38:25 <fresheyeball> my error type is very simple
20:38:32 <glguy> fresheyeball: You can ignore the deprecation message if Error is the behavior you want, or you can use Except if Monoid is the behavior you want
20:38:34 <fresheyeball> data MyError = MyError
20:38:52 <fresheyeball> I would rather go with Except
20:38:55 <glguy> Or you can make a new type and not use Either that has the correct behavior
20:39:08 <glguy> If your error type is that simple, you should use Maybe
20:39:23 <fresheyeball> glguy: I like that 
20:39:25 <fresheyeball> ok
20:42:38 <Welkin> :k Nat
20:42:39 <lambdabot> error:
20:42:39 <lambdabot>     Not in scope: type constructor or class ‘Nat’
20:46:06 <jle`> @let import GHC.TypeLits
20:46:07 <lambdabot>  Defined.
20:46:11 <jle`> :k Nat
20:46:12 <lambdabot> *
20:46:16 <jle`> heh
20:48:29 <riaqn> I got an idea: is there some typesetting library in Haskell such that the source code of the article is composable monads?
20:48:52 <riaqn> so, writing an article is composing monad in Haskell.
20:48:55 <Welkin> riaqn: pandoc?
20:49:14 <Welkin> it parses your markdown (or other format) into an AST that you can manipulate
20:49:36 <riaqn> pandoc includes typesetting? didn't know that.
20:49:43 <riaqn> I mean, pixel-level manipulation.
20:50:03 <riaqn> AFAIK, pandoc just converts among markdown, orgmode, etc..
20:50:12 <Welkin> oh
20:50:19 <Welkin> in that case, no
20:50:25 <Welkin> that is handled by css (or latex)
20:50:44 <Welkin> what exactly are you asking for?
20:50:46 <riaqn> yeah, but latex is like, 40 years old?
20:50:54 <Welkin> latex is very powerful
20:51:00 <Welkin> but a huge pain to set up and use
20:51:08 <riaqn> Welkin: just some more reusable/composable typesetting system.
20:51:12 <Welkin> css is much easier
20:51:25 <EvanR> css for typesetting
20:51:34 <EvanR> mamamia
20:51:36 <Welkin> css gives you a lot of control for typesetting
20:51:58 <Welkin> it's what epub uses
20:52:03 <riaqn> Welkin: I'm sure lots of people here wouldn't love CSS for type setting..
20:52:04 <Welkin> epub is just html+css
20:52:16 <riaqn> especially when it comes to math formulas.
20:52:23 <Welkin> use mathjax
20:52:33 <riaqn> which, latex claims to be good at.
20:52:35 <Welkin> these are solved problems
20:52:38 * hackage interpolate 0.1.1 - String interpolation done right  https://hackage.haskell.org/package/interpolate-0.1.1 (SimonHengel)
20:52:41 <Drakonis[m]> how's computational algebra on haskell?
20:53:13 <riaqn> Welkin: human solved transportation when borned, walking. But we invented cars/trains anyway..
20:53:26 <riaqn> just some better alternatives.
20:53:38 <Welkin> I'm listing some options available to you
20:53:58 <Welkin> check out mathjax if you want something like latex without any hassle
20:54:09 <Welkin> you can embed it in html, which means epub
20:54:40 <riaqn> I'm not trying to solve a specific problem I encounterd, but discussing using haskell to improve the workflow of typesetting.
20:55:18 <riaqn> mathJax I knowed and using. What I'm trying to say is, is there some better representation of an structred article than latex syntax.
20:55:19 <Welkin> so you are looking for a solution to a problem that you do not have
21:41:41 <algebra4life> Can anyone help me with this DList implementation?   https://www.reddit.com/r/haskellbook/comments/6aztst/_/   
21:44:12 <lyxia> algebra4life: your benchmarks should append new elements at the end
21:44:29 <lyxia> and you should evaluate your list to normal form
21:46:45 <algebra4life> Hmm.. the benchmarks come directly from the exercise. Do you think it's an error in the book?
21:47:00 <MarcelineVQ> the benchmark setup is from haskellbook.com and comes up every once in awhile, I think tickets have been filed asking about it but dunno if an update is forthcoming
21:47:24 <algebra4life> Ah. Okay, thanks
21:49:36 <ef> I started learning Haskell today. Why doesn't `printNum = [print n | n <- [0..5]]` work? Error is "No instance for (Show (IO ())) arising from a use of ‘print’".
21:49:55 <glguy> ef: What did you think it might do?
21:50:40 <geekosaur> :t [print n | n <- [0..5]]
21:50:42 <lambdabot> [IO ()]
21:50:55 <MarcelineVQ> algebra4life: even just a little paren change in schlemiel is a big difference iirc,  go (n-1) ([n] ++ xs)  vs  (go (n-1) [n]) ++ xs  for example, so it's hard to say exactly what the author intended it to look like
21:51:25 <geekosaur> ef, take a look at the type there and consider what it means
21:52:08 * hackage influxdb 1.1.2.2 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.1.2.2 (MitsutoshiAoe)
21:52:10 <algebra4life> Good point
21:53:25 <ef> Yeah, I got the feeling the IO type was wrong, but wasn't too sure about.
21:53:55 <algebra4life> Ef, evaluation to a list of io actions is just that. In order to print to the screen, you need precisely an io action, not a list of them.
21:53:59 <MarcelineVQ> the idea of schlemiel is to show the slowness of repeated left biased appends though, so you can proceed with that in mind. the exercise is intended to show that dlist of a b c d .. is faster than (((a ++ b) ++ c) ++ d) ..
21:55:12 <algebra4life> Yeah I see what you're saying, I'll try that out
21:55:37 <geekosaur> ef, the expression "print n" is an expression with an IO type. an expression that can be manipulated to some extent and even dropped/ignored; it only does something when linked to main :: IO a
21:56:28 <glguy> ef: What's unique here is that merely applying the print function to a number doesn't print anything, it just builds an action that prints when executed
21:56:35 <geekosaur> this linking is via "bind", and variants thereof. in this case, you can use "sequence" to bind each IO action in the list, creating a new IO action which can be bound (ultimately) within main, or at the ghci prompt where it acts like "execution"
21:57:06 <glguy> ef: In GHCi, if you enter an IO action as your value, GHCi will execute that for you (if it's got a type like IO a)
21:57:29 <glguy> otherwise it will try and generate a string representation of the value and print that value for you
21:57:45 <glguy> In this case you had a [IO ()], which isn't of the form IO a (because of the outer list part [])
21:58:08 <glguy> so GHCi tried to render that list to a string, which it can't, because while it knows how to render lists, it doesn't know how to render IO actions
21:59:50 <glguy> ef: In this case Show is the name of the class for types that can be rendered to String (at least it's the class that GHCi uses to do that)
22:00:01 <glguy> so that's why you got the error about no instance of the Show class for IO ()
22:03:09 * hackage ghc-events 0.6.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.6.0 (MitsutoshiAoe)
22:11:26 <halogenandtoast> Anyone ever see "Error parsing targets: Component CLib does not exist in package" when compiling?
22:15:26 <halogenandtoast> sorry it's not while compoling
22:15:34 <halogenandtoast> I'm trying to run yesod devel
22:15:39 <halogenandtoast> compiling works fine
22:16:19 <halogenandtoast> and running the binary directly works fine.
22:17:19 <halogenandtoast> I think I see
22:19:20 <et09> know how you make a pair of eyes and a nose in haskell?
22:20:01 <et09> > mapM (putStrLn) ["",""]
22:20:03 <lambdabot>  <IO [()]>
22:20:22 <et09> sigh, i wanted [(),()]
22:20:43 <MarcelineVQ> :>
22:21:21 <jle`> > map (const ()) ["",""]
22:21:23 <lambdabot>  [(),()]
22:22:04 <halogenandtoast> > [(),()]
22:22:06 <lambdabot>  [(),()]
22:22:10 <halogenandtoast> mine is easier
22:22:20 <et09> yeah but it has to be a surprise
22:22:26 <halogenandtoast> no it doesn't
22:22:31 <halogenandtoast> :p
22:23:12 <et09> well thhat's all for me
22:23:31 <Lokathor> i have a tuple that holds two values, which are themeslves 3 values each, and which are themselves 4 values each
22:24:10 <c_wraith> Lokathor: why stop there?  you should go all the way to 7
22:24:10 <Lokathor> lenses can let me edit them all quite easily when i need to adjust the same field of all six quadruples to the same value
22:24:22 <Lokathor> cellPair.each.cellTriangle.each.vertexEntry._3 and such
22:24:38 <Lokathor> but when i need to adjust each vertex individually, i've hoisted myself
22:25:07 <pacak> Lokathor: http://hackage.haskell.org/package/linear
22:25:09 <pacak> No?
22:26:00 <c_wraith> Lokathor: would https://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Lens.html#v:-38--126- be of use?
22:26:39 <Lokathor> pacak, I've got vertexes which are V2 V2 V3 V4, and three of those makes a Triangle, and two of those make the CellPair (one triangle pair cell of the grid)
22:27:15 <Lokathor> and what i need to re-assign is each of the second V2 values to be a different values (well, one of four values technically, but each of the 6 vertexes needs an update when updates happen)
22:27:57 <Lokathor> I think the easiest thing to do is actually to just do a single function that's one huuuuuge pattern match that unwraps the entire structure at once, then pick my new values and return a single new structure that copies most of the data forward.
22:27:57 <halogenandtoast> Fixed my problem for earlier, yesod devel needs a library built, which I didn't have
22:28:24 <cocreature> Lokathor: maybe "partsOf" is helpful?
22:28:25 <Lokathor> basically what a lens does, but since it's manually you can update 6 targets in a single de-structure / re-structure
22:28:36 <Lokathor> cocreature, not familar with that one...
22:29:05 <c_wraith> Lokathor: did you look at my link?
22:29:07 <Lokathor> also not familar with &~
22:29:11 <Lokathor> hmmmmmm
22:29:25 <Lokathor> how much does it rebuild in the middle when it chains?
22:29:27 <c_wraith> Lokathor: it's specifically for doing multiple nested edits with a single traversal into the shared part.
22:29:32 <Lokathor> cool
22:29:38 <cocreature> > set (partsOf (each . _2)) [42,23] ((1,2), (3,4))
22:29:40 <lambdabot>  ((1,42),(3,23))
22:29:59 <Lokathor> cocreature, is partsOf the word form of &~ ?
22:30:05 <c_wraith> No, it's totally different
22:30:08 <c_wraith> But it would also work
22:31:15 <cocreature> I’m never sure if partsOf is awesome, crazy or both
22:31:23 <cocreature> I’m still too scared to look at the implementation
22:31:26 <c_wraith> and I suppose technically &~ is only half the story when used - it'd also have to use zoom.  partsOf is certainly easier to write.
22:31:38 <pacak> @src partsOf
22:31:38 <lambdabot> Source not found.
22:40:59 <Lokathor> so
22:41:00 <Lokathor> uh
22:41:11 <Lokathor> lemme start by saying that no one will like the solution
22:41:20 <Lokathor> it's deeply gross and unsatisfying
22:41:23 <Lokathor> http://lpaste.net/355957 but here you go
22:41:38 <Lokathor> that's the "base", and then i can add the lets and updates
22:41:56 <Lokathor> actually i can unwrap less
22:42:09 <NextHendrix> > fromMaybe[()]$sequence$(\_->lookup 1[(1, ())])<$>["eyes","nose"]
22:42:11 <lambdabot>  [(),()]
22:42:16 <NextHendrix> heh
22:44:04 <Lokathor> lpaste updated
22:44:08 <heath> runP2P takes two params: port and bootstrapNode, but on this line it is called with a third argument (return ()) https://github.com/aviaviavi/legion/blob/master/app/Main.hs#L129 i'm not quite understanding it, and i was wondering if someone might chime in and help me to understand 
22:45:12 <glguy> heath: runP2P takes two parameters and then returns a function
22:46:01 <glguy> > let example x = map (+x) in example 5 [1,2,3]
22:46:03 <lambdabot>  [6,7,8]
22:46:13 <c_wraith> heath: unfortunately, it's defined without a type signature, which would make that more clear.
22:49:22 <heath> oh, yeah, bootstrapNonBlocking takes 5 parmams and is given 4, maybe somehow (return ()) is this last param
22:49:46 <heath> s/parmans/params
22:52:54 <c_wraith> Not "somehow".  Just how functions in haskell work :)
22:58:16 <heath> i can how that can be possible. it's quite different from what i've seen
22:58:58 <heath> missed a word! i can +see how that can be...
22:59:54 <c_wraith> it's called currying.  instead of bundling all the arguments together, "multiple parameters" are actually chained function results.
22:59:55 <glguy> heath: Did you notice the example I made for you above?
23:00:52 <c_wraith> So a function with a type like A -> B -> C -> is the same as A -> (B -> (C -> D))
23:01:19 <c_wraith> err, pretend I put the D after that third arrow. :)
23:01:47 <c_wraith> And calling a function with multiple arguments is calling each returned function in turn.  f a b c = ((f a) b) c
23:04:08 <heath> guess it would be a good idea to start thinking in terms of currying a little more
23:04:48 <Axman6> it's a pretty handy concept, andquite important in understanding how to write Haskell
23:05:25 <heath> glguy: i did, though it wasn't immediately clear when i saw it how it was related. seems you were implying currying though
23:06:28 <glguy> Then it would help if you asked questions about it! You were confused how a definition with one two parameters could be applied to 3 arguments
23:06:39 <glguy> That example has a definition with one parameter being applied to two arguments
23:07:02 <c_wraith> sometimes the problem is knowing what question to ask. :)
23:07:44 <glguy> or to ask at all
23:18:28 <brachiel> Hi there. Is there a clever way to write (\x -> (f x, g x))? I thought about something like (f,g) but I can't quite figure it out
23:20:01 <c_wraith> brachiel: clever, sure.  Better?  eh.  :)
23:20:26 <c_wraith> > liftA2 (,) (+1) (*2) 3
23:20:28 <lambdabot>  (4,6)
23:21:07 <pacak> @pl \x -> (f x, g x)
23:21:08 <lambdabot> liftM2 (,) f g
23:21:24 <c_wraith> In my younger days, I wrote code like that much more than I would now.
23:21:42 <brachiel> Ah, alright :). Thanks, c_wraith, I'll look into it. Also thanks, pacak for the pointer to pl
23:21:58 <pacak> brachiel: Don't write like that, it's not very readable.
23:22:17 <jle`> brachiel: there's (f &&& g), which used tob e pretty popular
23:22:18 <peddie> :t bimap
23:22:19 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
23:22:20 <jle`> but it's fallen out of favor
23:22:36 <jle`> > ((+1) &&& (*2)) 3
23:22:38 <lambdabot>  (4,6)
23:22:45 <pacak> &&& is nice.
23:23:13 <cocreature> peddie: bimap is different. it takes a tuple and applies functions two both sides instead of applying two functions to the same argument
23:23:16 <jle`> advantage is that it's in the 'base'
23:23:53 <peddie> cocreature: yeah, I know it doesn't solve the problem in one go, I just wanted to see what it did exactly
23:24:04 <peddie> seemed like it could be related
23:30:01 <brachiel> Uh, &&& is indeed nice. Thanks for the pointer to Arrows :)
23:31:15 <EvanR> Arrow shenanigans is like the bell bottoms of haskell
23:31:54 <cocreature> I just pretend Arrows don’t exist
23:33:35 <glguy> Oh no, did bell bottoms go out of style?
23:38:03 <quchen> Here is a cool function that applies two different functions to an argument and tuples the results up:
23:38:15 <quchen> :t \f g x -> (f x, g x)
23:38:16 <lambdabot> (t2 -> t1) -> (t2 -> t) -> t2 -> (t1, t)
23:38:27 <EvanR> not esoteric enough
23:38:52 <quchen> :t \x xx xxx -> (x xxx, xx xxx)
23:38:54 <lambdabot> (t2 -> t1) -> (t2 -> t) -> t2 -> (t1, t)
23:39:00 * angerman is around should there be questions regarding the android post ;-)
23:39:03 <quchen> ?pl \x xx xxx -> (x xxx, xx xxx)
23:39:03 <lambdabot> liftM2 (,)
23:39:20 <EvanR> (c -> a) -> (c -> b) -> c -> (a,b)
23:40:13 <EvanR> x's ? emoji haskell plz
23:41:19 <glguy> quchen: If I want to layout a sentence in paragraph form with prettyprinter, do I need to first split it into words and then fillSep that?
23:41:19 <Lokathor> https://gist.github.com/Lokathor/7aecc85eb75730f96835b57cf26caca2
23:41:34 <Lokathor> there we have it folks, the grossest legit function i've ever written in any programming language
23:42:00 <quchen> glguy: Yes, unfortunately. There is a function for that in the Doc.Util module though, called »reflow«.
23:42:19 <quchen> glguy: You can’t inspect a Doc, so you can’t insert newlines in retrospect :-/
23:42:26 <glguy> quchen: Oh, thanks for the pointer to reflow!
23:42:53 <quchen> glguy: I don’t really like the Util module, but some definitions I had to redefine so often I added it there.
23:43:11 <quchen> FWIW it’s just what you suggested: words and fillSep.
23:43:42 <quchen> glguy: The »paragraph« function in GenerateReadme.hs also uses this idea to generate the README.
23:43:45 <Lokathor> c_wraith, seems that (&~) isn't in microlens actually
23:45:52 <quchen> glguy: Your ticket says »add version bounds to everything«, right? Is there any downside to editing the .cabal file on Hackage to do this?
23:47:08 <glguy> No, it's a good idea to add them to the stuff you released without them. What will happen in the future is if you start adding them only to later packages, when things stop being compatible in the future the solver will then just default back to the unconstrained initial release
23:47:34 <quchen> I see.
23:47:50 <glguy> and then simply not adding them turns the package into a timebomb
23:48:29 <glguy> This can help, too https://matrix.hackage.haskell.org/package/prettyprinter#GHC-7.6/prettyprinter-1
23:50:52 <quchen> glguy: Interesting, I did not plan to support GHC 7.6, I wonder why it finds and install plan and then fails.
23:50:58 <glguy> I'm interested in how you have the ansi support split into a second package. I have a library where I want to provide Doc values and having the option to generate ansi colored output is great
23:51:17 <quchen> glguy: To avoid the dependency on the ANSI terminal library
23:51:27 <quchen> glguy: Rendering to HTML for example does not require that
23:51:35 <glguy> Yeah, I like that
23:52:00 <glguy> quchen: It tried to build with 7.6 because you said it was supported
23:52:01 <quchen> Only the backends that can be written with the stock library are included.
23:52:06 <quchen> I said?
23:52:19 <glguy> Yeah, you said all versions of base less than 127 are supported
23:52:26 <quchen> ಠ_ಠ 
23:52:43 <quchen> But the tested-with field does not mention GHC 7.6.
23:52:51 <quchen> But yes, I get your point, sorry about that.
23:54:21 <EvanR> if i have associated type Cl w :: * -> *, then later in an instance it wont let me write type CL T a = ()
23:54:33 <EvanR> instead i can write type Cl T = Const ()
23:54:50 <glguy> quchen: Regarding your need for an example of pretty on Void:   pretty (Right "example" :: Either Void Text)
23:54:54 <EvanR> is there any way to use () there?
23:55:01 <glguy> or something like that
23:55:29 <glguy> or:  pretty (Nothing :: Maybe Void)-- since you actually have the Maybe instance
23:56:38 <quchen> glguy: The Void docstring is just a joke ;-)
23:56:57 <quchen> But you’re right, maybe Maybe is a better example.
23:59:21 <glguy> quchen: It might be worth making the generate_readme not buildable unless a flag is set
23:59:34 <glguy> Most people are unlikely to need it installed in their ~/.cabal/bin/
23:59:50 <quchen> Right.
