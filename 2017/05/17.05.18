00:00:04 <osa1> yeah that's what I mean
00:00:14 <anoLB> get haddocks source and hack it for us
00:00:17 <anoLB> :)
00:00:28 <anoLB> save yourself the annoyance... and gain karma too
00:00:32 <osa1> I'd love to if I had time ;-)
00:00:59 <anoLB> haddocks interface is hairy seeming to me, i usually just run cabal haddock
00:27:38 <riaqn> hello, can I define the predecence of an infix data constructor to be higher than 0? like (-1)
00:27:51 <merijn> riaqn: eh, -1 is lower
00:28:00 <whoman> ^_^
00:28:14 <merijn> fixity is 0-9, higher being stronger binding
00:28:14 <riaqn> ahh.. yes but it's actually "higher predecence"
00:28:29 <riaqn> yeah, I want it weaker binding.
00:28:38 <merijn> riaqn: No, 0 is the lowest
00:29:12 <riaqn> OK, then I cann't use things like (a `op` b $ c), where I hope b $ c bind first?
00:29:33 <merijn> eh...
00:29:50 <riaqn> hey, I can define op to be infixr 0, right?
00:29:52 <merijn> if you want b $ c to bind first, why don't you juse write 'a `op` b c'
00:29:58 <riaqn> it works at least in this case.
00:30:19 <riaqn> merijn: that would be too complex..I avoid backquote.
00:30:30 <int-e> There have been some proposals for generalised fixities (I seem to recall a propsal to have fractional fixities as well) but I have never seen much support for any of them... so no you can't do that
00:30:42 <jle`> not saying that the fixity system is perfect, but binding something looser than $ would throw off a lot of expectations
00:31:07 <int-e> well, actually, since $ is right associative, you can
00:31:25 <kadoban> Even if you could,   a `op` b $ c    where (b $ c) goes first would be *horrible* to read for most.
00:31:26 <merijn> riaqn: I don't understand what you're saying
00:31:33 <int-e> <riaqn> hey, I can define op to be infixr 0, right? <--- yes.
00:31:46 <merijn> riaqn: You give an example where you use backquotes and then say that's to complicated?
00:32:08 <merijn> I wrote literally the same thing you did, but without the $ and that should do what you want
00:32:38 <riaqn> merijn: ahh sorry, I wrote backquote just meaning it's infix. But I hope to avoid the backquote.
00:33:11 <jle`> `op a (b c)` is probably pretty readable if you want to have op not be infix
00:33:31 <merijn> riaqn: How can op be infix without backquotes
00:33:46 <merijn> It's either an operator or you use backquotes, else it can't be infix anyway
00:34:04 <riaqn> it's not op.. it's things like :=
00:34:23 <riaqn> some EDSL of assembly language.
00:34:45 <merijn> riaqn: Well, what's the problem with using 'a := b c' then?
00:35:22 <riaqn> merijn: sometimes it's a := b $ c d
00:37:10 <glguy> `seq` has very low precedence as surprises go
00:37:29 <glguy> `elem` is another surprise
00:52:12 <merijn> hvr: ping?
00:52:20 <hvr> oink?
00:52:56 <merijn> hvr: I was looking at your multi-GHC travis thing and it claims to support 8.2.1 prerelease and GHC HEAD, but I'm unsure what Tested-With syntax I need to actually trigger those?
00:54:14 <merijn> Doesn't seem to get 6.12.3 either, which supposedly is included in the setup :)
00:54:44 <hvr> merijn: 6.12.3 is kinda out of support by now; I should update the docs about it
00:54:56 <hvr> merijn: as for 8.2.1; just refer to ==8.2.1
00:55:17 <merijn> I have GHC == 8.2.1 but it doesn't end up generating anything for it
00:55:20 <hvr> the RCs are packaged in such a way that they smoothly transition to the final release 
00:55:35 <hvr> merijn: which script did you use? the _2.sh one?
00:55:49 <merijn> No, should I?
00:55:52 <hvr> yes...
00:55:53 <hvr> :-)
00:56:01 <glguy> I've been playing with making a demo tool for my configuration language and schema system: https://glguy.net/~pi/result/
00:56:22 <merijn> As for 6.12 being out of support...I figured, if I'm going out of my way to be stupidly backwards compatible, I might as well include it :p
00:56:24 <glguy> Uses GHCJS to allow the user to try out the parser in their browser directly
00:56:45 <hvr> glguy: fwiw, I'm mildly torn between Dhall and config-{schema,values} nowadays :)
00:57:09 <hvr> (they have totally different tradeoffs, which is why I'm torn)
00:57:18 <merijn> hvr: -2.hs has a parse error on line 1 :p
00:57:25 <glguy> Dhall doesn't appeal to me at all for configuration, but it certainly looks fun
00:57:26 <hvr> merijn: you're on Apple
00:57:37 <merijn> hvr: Yes
00:57:44 <hvr> merijn: I learned about that issue just yesterday
00:57:59 <hvr> merijn: remove the #! line, and compile it via ghc --make or use the .cabal file to generate a binary
00:57:59 <merijn> oh, I think I can manage this bug :)
00:58:19 <hvr> I'll probably have to get rid of #! thanks to Clang
00:58:48 <hvr> (the reason is that Clang's CPP adds whitespace to #!, whcih then causes GHC to not recognise the #! anymore)
00:58:52 <merijn> hvr: The weird thing is...the old script seems to use the same shebang and does work...
00:59:07 <hvr> merijn: the old one didn't need -XCPP yet
00:59:09 <merijn> Well, modulo space
00:59:28 <hvr> but in order to support Cabal < 2.0 and >= 2.0, I needed CPP
00:59:37 <merijn> GHC should really just ditch CPP and define it's own preprocessor
00:59:56 <hvr> merijn: https://ghc.haskell.org/trac/ghc/wiki/Proposal/NativeCpp =)
01:00:43 <hvr> hrm... I need to update the page
01:00:59 <merijn> Honestly, cpphs is not big improvement
01:01:11 <hvr> we'd likely go with 'hpp'
01:01:13 <mniip> glguy, looks an awful lot like YAML
01:01:26 <hvr> mniip: it's a more sane YAML-ish syntax
01:01:32 <hvr> w/ less weirdness
01:01:41 <mniip> yaml is good enough by me
01:01:48 <hvr> mniip: then keep using it =)
01:02:07 <mniip> alrighty
01:02:11 <glguy> mniip: then you can focus on the schema definition and documentation part of the demo
01:02:45 <merijn> ok, now it seems to grab 8.2.1 and head too
01:02:55 <merijn> hvr: So head is just "8.3.*"?
01:03:13 <mniip> glguy, so, a value tree walking monad?
01:03:22 <glguy> mniip: No, not a monad, but similar
01:03:39 <mniip> I see a do, is it ApplicativeDo?
01:03:42 <glguy> yes
01:04:03 <mniip> any particular reason it's not a monad?
01:04:12 <glguy> so that you can extract the structure
01:04:27 <glguy> like optparse-applicative
01:04:29 <mniip> ah so it's bidirectional?
01:04:51 <mniip> right that makes sense
01:05:24 <merijn> hvr: Also, is there a way to selectively disable the "--enable-benchmarks" flag? I need it disabled for old cabal versions, because old cabal is stupid
01:05:52 <glguy> The generated .travis.yml has one env section for each compiler
01:06:00 <glguy> where you can turn off benchmarks
01:06:32 <merijn> oh, wait
01:06:39 <hvr> merijn: that's why there is a env-variable provided in the generated template; you can set/override it in the per-version matrix config
01:06:40 <merijn> the new one already seems to disable benchmarks
01:06:44 <merijn> \o/
01:07:27 <glguy> mniip: also beyond Yaml it distinguishes quoted strings from unquoted "atoms" so you can use them like an enumeration 
01:07:37 <merijn> I basically just uncomment the env entries, right?
01:07:46 <glguy> The string "default" can be distinct from a special atom default
01:07:59 <glguy> (for example)
01:08:09 <mniip> sounds like an insignificant encoding perk
01:08:25 <glguy> No, it turns out to be quite useful
01:08:39 <glguy> and helps avoid common errors in yamls permissive coersions
01:10:11 <ph88^> Gurkenglas, the thing with catchC and handleC is that it will continue the conduit (you can just change the flow depending if there was an exception or not) .. in my case i would like the conduit to stop and print to stderr. snoyberg suggested that i rethrow the exception with my own message attached to it (possibly as my own exception type)
01:10:31 <merijn> Actually, seems it might be moot. if I understand the new travis script correctly it always uses cabal-install-head, which already fixes my issue anyway :)
01:10:52 <glguy> hvr: is the travis script self-hosting yet?
01:10:55 <glguy> ^_^
01:11:09 <hvr> glguy: what'ya mean by self-hosting? :)
01:11:19 <merijn> hvr: Presumably testing itself :p
01:11:19 <glguy> It should be used to build itself on travis
01:11:23 <hvr> heh
01:11:29 <hvr> soon!
01:12:21 <merijn> Fingers crossed, time to see on how many GHC's it's broken
01:15:51 <glguy> hvr: if you do use dhall for something I'd be interested to see it
01:23:39 <Mibaz> Any Netwire gurus around?
01:25:12 <merijn> Mibaz: I think he's on later in the day. Also, pretty sure netwire has been deprecated for wires
01:25:53 <Mibaz> merijn: Ok thanks. And is "wires" a different module?
01:26:21 <merijn> Mibaz: https://hackage.haskell.org/package/wires
01:29:07 <Mibaz> merijn: Thanks a lot. Is wires the best FRP implementation to use, in your opinion?
01:29:21 <merijn> Best strongly depends on what you're trying to do
01:30:58 <Mibaz> merijn: definitely does. 
01:38:34 <kamyar> Hello guys!
01:38:48 <kamyar> I have a stack question
01:38:53 <kamyar> anyone here to answer?
01:39:00 <electrocat> kamyar: don't ask to ask
01:39:03 <electrocat> just ask ;)
01:39:39 <kamyar> electrocat: Ok! it is because sometimes people say 'I dont know anythin about x'
01:39:55 <kamyar> I want to move my lts-8.12 to lts-8.14
01:40:11 <kamyar> Do I have to redownload all packages and install all packages with --resolver option?
01:40:38 <electrocat> move what exactly?
01:40:40 <merijn> How do I find out which GHC version first supported a given extension?
01:41:11 <kamyar> electrocat: I wanna migrate, sorry for choosing bad word
01:41:26 <electrocat> kamyar: migrate what? a project of yours?
01:41:36 <kamyar> I have a working project on stackage 8.12 and wanna upgrade it to stackage 8.14 for some reason
01:41:57 <kamyar> electrocat: Is tehre any single command to migrate?
01:42:05 <electrocat> kamyar: just change the version in the stack.yaml file
01:42:24 <kamyar> electrocat: The required dependencies wiill eb downloaded automatically? Like Maven?
01:42:38 <electrocat> yeah stack will do all that kind of work for you 
01:43:03 <kamyar> electrocat: Wow! I thought the .stack directory is the inventory for packages
01:43:15 <kamyar> electrocat: I mean ~/.stack
01:43:38 <electrocat> it is, but it can hold multiple versions
01:44:01 <electrocat> of the same package
01:44:34 <kamyar> You mean stack will check project fodler first and then .stack?
01:45:53 <kamyar> electrocat: ?
01:46:55 <electrocat> no ~/.stack holds everything related to dependencies
01:47:10 <electrocat> for every project
01:47:23 <electrocat> so it can reuse compiled packages over multiple projects
01:47:38 <kamyar> electrocat: But dependencies are packages by themselves
01:48:13 <kamyar> electrocat: Why not to save them beside the main project?
01:48:35 <kamyar> electrocat: I am familiar with Python (+venv) and Ruby (gem, bundle) ecosystem of build
01:48:41 <electrocat> so they can be shared across multiple projects
01:48:49 <kamyar> electrocat: Which of them are more similar to haskell's?
01:49:16 <kamyar> electrocat: So the .stack directory is similar to site-packages of python
01:49:43 <electrocat> possibly, i don't know that much about other package ecosystems
01:50:31 <kamyar> electrocat: Python tries current project (venv) at first and then tries site-packages,
01:50:52 <kamyar> electrocat: So if the same dependency exists in site-packages, it does not redownload it
01:51:17 <kamyar> electrocat: Except when the version differs
01:51:29 <Saizan> kamyar: afaiu
01:52:00 <kamyar> Saizan: u=use?
01:52:04 <electrocat> ah, i see, stack is quite similar in that regard
01:52:12 <Saizan> kamyar: you could just try and see what happens when you change the version in your .yaml file
01:52:43 <electrocat> well yes, the point of stack is that you don't really have to worry about dependencies :p
01:53:13 <kamyar> electrocat: Son in compare with Ruby ecosystem, I guess cabal=gem and stack=bundle
01:53:25 <kamyar> Does cabal do the same thing or not?
01:54:26 <kamyar> electrocat: I just used stack since I noticed stack is bacisally created to resolve cabal lacks and shortages
01:54:42 <maerwald> like what?
01:54:43 <kamyar> electrocat: But I am not master at them
01:54:44 <bennofs> kamyar: cabal supports sandboxing since quite some time
01:55:19 <kamyar> maerwald: You are talking to me? 
01:55:22 <sjpet> is there something like a deep <- that can be used in do notation?
01:55:24 <bennofs> kamyar: a major difference I can think of in terms of featuresis that cabal doesn't manager ghc versions for you though
01:55:24 <maerwald> yeah
01:55:36 <sjpet> to bind an IO (IO a)
01:56:01 <sjpet> for example, I have a function myFunction :: [MyType a] -> IO a
01:56:06 <kamyar> maerwald: I mean cabal-install in fact not cabal itself since stack uses cabal package internally
01:56:20 <sjpet> what if my a is an IO b?
01:56:33 <Myrl-saki> :: IO a -> IO [Maybe a]
01:56:37 <kamyar> maerwald: And the point bennofs told! I wanna use GHC 8.0.2 not GHC 7
01:56:38 <Myrl-saki> how
01:56:46 <electrocat> kamyar: cabal doesn't handle dependencies very well and doesn't have stable snapshots of packages, sandboxes kindof solve that problem but not entirely. stack just does all of that a lot better
01:56:56 <bennofs> kamyar: ? you can use ghc 8.0.2 with cabal but you'd need to install it some other way
01:57:05 <maerwald> kamyar: you want multiple GHCs or just one?
01:57:07 <Myrl-saki> Whoops.
01:57:13 <Myrl-saki> :: [IO a] -> IO [Maybe a]
01:57:17 <bennofs> electrocat: you can use stackage with cabal though
01:57:22 <electrocat> bennofs: good point
01:57:27 <kamyar> maerwald: I need multiple GHC for multiple projects in fact
01:57:31 <bennofs> electrocat: just drop the cabal.config provided by stackage into your project and you should be fine
01:57:51 <Myrl-saki> (Yes, that is pretty much `select` in C.
01:58:09 <kamyar> Another problem
01:58:20 <kamyar> Has anyone used INtellijIDEA for haskell here? I mean the plugins
01:58:28 <sjpet> I have
01:58:29 <jle`> sjpet: you can always use join :: IO a -> IO a, but there might be a more natural way too
01:58:41 <kamyar> I am currently using HaskForce, is tehre any other better one out?
01:58:44 <jle`> Myrl-saki: (fmap . fmap) Just . sequence  ?
01:59:06 <hvr> electrocat: I think you drank too much koolaid ;-)
01:59:23 <sjpet> kamyar: I've tried two, one was pretty bad, let me check which one I stuck with
01:59:29 <electrocat> hvr: koolaid? o.O
01:59:31 <merijn> Cabal handles dependencies just great, it's developers who don't :)
01:59:41 <maerwald> merijn++
01:59:48 <kamyar> sjpet: My problem is that HaskForce does not support stack fully!
02:00:13 <bennofs> kamyar: you can use multiple ghc versions with cabal as well
02:00:16 <kamyar> sjpet: You can create stack project but when trying to run on IntellijIDEA you have to use caba
02:00:23 <maerwald> people think it's a tool problem and add more abstraction for something that is not actually a tool problem
02:00:25 <bennofs> kamyar: just install them, and pass them to cabal configure -w ghc-$VER
02:00:29 <sjpet> kamyar: Yeah, HaskForce has it's problems, but it worked better than that other one
02:00:41 <hvr> electrocat: you seem to consider Stack to way superior to cabal in a way that sounds exagerated :)
02:00:46 <Myrl-saki> jle`: lol
02:01:03 <electrocat> merijn: not sure if i agree, installing two packages with different requirements for dependencies can often fail
02:01:15 <bennofs> electrocat: cabal has sandboxes
02:01:25 <bennofs> electrocat: and in the future, new-build 
02:01:27 <kamyar> sjpet: Yes! BUt the plugin named "Haskell" has been downloaded more! Maybe since it is older
02:01:47 <merijn> electrocat: Well yes, if those requirements contradict each other, there is no solution to the dependencies. This can happen in exactly two scenarios: 1) wrong bounds set by developers or 2) incompatible packages
02:01:54 <kamyar> electrocat: bennofs is cabal's advoctae! :)
02:02:03 <kamyar> advocate I mean
02:02:27 <electrocat> hvr: it just makes my life so much easier :p
02:02:30 * hvr leaves the defense to bennofs  then
02:02:32 <maerwald> electrocat: that's mostly because of a) unmaintained packages (there are a lot) and b) upper bounds which are just bad, see https://thefeedbackloop.xyz/thoughts-on-dependency-hell-is-np-complete/
02:02:50 <bennofs> kamyar: sorry, just trying to point out what cabal features are nowadays because IMO there's a lot of outdated/ inaccurate info out there :) I don't particularly care myself if people use cabal or stack :D
02:03:02 <Myrl-saki> jle`: Types are not enough to explain this, I guess.
02:03:20 <sjpet> jle`: Thank you. really, hoogling for that should've been my first thought, dunno why it didn't occur to me
02:03:37 <jle`> * join :: IO (IO a) -> IO a, sorry
02:03:43 <kamyar> bennofs: Just kidding! Bu in fact what made me migrate was GHC versioning. At least your point is not well documented in cabal world! So I wuickly migrated to stack
02:03:47 <kamyar> quickly
02:03:54 <hvr> maerwald: if you consider upper bounds bad, then you're basically ok w/ letting cabal pick random install-plans
02:04:10 <maerwald> hvr: nah, I'm saying the solution is something else
02:04:27 <maerwald> there are some proposed solutions in that link
02:04:27 <hvr> maerwald: but the solution isn't stackage eitehr
02:04:28 <electrocat> sure, supporting multiple versions would also solve that issue, sandboxing does that for us, but i dont want to recompile everything for every project
02:05:33 <bennofs> kamyar: yeah, I agree that stack is a lot more "user friendly" in that a) I feel its command line interface is easier to use (although I cannot actually say why :D) and its docs feel a bit better thus more works "out of the box". cabal-install has more ways to shoot yourself into the foot 
02:06:05 <merijn> bennofs: Last time I looked at stack I got confused about how to make the CLI do what I wanted, so I just gave up, so that's debatable at best
02:06:35 <bennofs> merijn: yes, me too. stack works better for simple use cases out of the box, if you want something concrete and know exactly what you want, cabal is often easier
02:06:53 <hvr> maerwald: anyway, that link is interesting; *adding it to my literature research list*
02:07:11 <merijn> bennofs: I thought stack worked better for complex use cases, as I consider my usecases pretty simple
02:08:30 <maerwald> hvr: releases/branches are a solution that has been used in distros for a few decades now and it works well with proper maintenance (as in: no version dependencies). I don't see how that would work on something like hackage though. It basically moves the "version selection problem" to the packaging stage
02:08:32 <bennofs> merijn: hmm. I think the difference is that stack is way more opinionated which leads to less ways to screw up but also less flexibility / may make it hard to use if you want full control
02:08:50 <maerwald> and it needs a lot of manpower
02:09:03 <merijn> bennofs: It also requires a fair amount of "setup" in terms of projects, etc. to get simple things working
02:09:29 <hvr> maerwald: hackage actually does something that I consider to be in a local optimum; but we need better tooling (which I'm working on)
02:10:15 <hvr> maerwald: and there's something to having two "channels" I'm also working on
02:10:21 <hvr> +distribution channels
02:10:33 <bennofs> merijn: hmm are you talking of new projects or starting on an existing project? do you have examples of the setup required?
02:11:02 <merijn> bennofs: my quick hack projects, patching existing packages, etc.
02:12:37 <bennofs> merijn: patching existing packages seems to be harder with cabal? at least if you don't use the user db
02:12:59 <merijn> bennofs: huh, is there anyone who doesn't use the user db?
02:13:03 <hvr> new-build
02:13:07 <bennofs> merijn: sandboxing?
02:13:07 <merijn> I never ever installed something globally with cabal
02:13:30 <merijn> I use sandboxing nowadays, but even before that existed almost no one use the global db
02:13:47 <merijn> hvr: I only just have a GHC and cabal that support it and I don't know how to actually use it :p
02:13:48 <bennofs> merijn: if you use sandboxing you don't use the user db
02:13:52 <hvr> bennofs: patching packages w/ cabal new-build is just a matter of 'cabal unpack'ing them, patching em, and pointing cabal.project to them
02:14:01 <maerwald> hvr: I think the main problem is about how people understand the dependency version spec. A lot of people write down upper bounds based on what they have tested, not based on what is actually the known case. I only add upper bounds when a) I know it doesn't build with later versions and b) I can't be bothered to fix it in a timely manner
02:14:03 <merijn> bennofs: I've used cabal for years before sandboxing existed :p
02:14:09 <maerwald> mostly I just do b) and still have no upper bounds
02:14:29 <hvr> maerwald: writing down upper bounds on what they know to work is the proper way
02:14:30 <maerwald> (as in: just fix it)
02:14:50 <hvr> maerwald: that's the whole point of semver et al
02:15:05 <maerwald> well, that's not how rolling release distros do it
02:15:28 <maerwald> you add upper bounds when you get build failures
02:15:31 <hvr> but that's how the hackage/cabal ecosystem is designed and optimsed for ;)
02:15:39 <hvr> maerwald: that's too late
02:15:47 <maerwald> and I think that's a wrong decision, which is why we end up with the dependency problem
02:16:04 <hvr> maerwald: if everybody did it that way, we'd always fluctuate into breakage on hackage
02:16:11 <maerwald> not if you have channels
02:16:17 <hvr> maerwald: as there's a) a response latency invovled with detecting the breakage
02:16:24 <hvr> which sometimes doesn't even result ina  build failure
02:16:32 <hvr> but the code just behaves wrongly even though it compiles
02:16:43 <bennofs> merijn, hvr: I think one advantage of stack is simply that it is "new", so if you google "stack XXX" you're probably getting the right way (TM) to do XX in stack, while with cabal you're likely to end up on 3 year old SO posts that are out of date right now :)
02:17:12 <hvr> maerwald: different major versions of a package are to be treated like different packages; the only thing they share formally is the package name
02:17:26 <hvr> maerwald: that's the whole premise of semver
02:17:52 <merijn> btw, are Hackage candidates publically visible? i.e. if I upload a candidate + docs can I have people sanity check the docs?
02:17:56 <hvr> merijn: yes
02:17:59 <maerwald> hvr: that's implemented via slots in some distros, so you can still have a dependency that says "all slots"
02:18:10 <hvr> merijn: that's the point of them :) to share prereleases
02:18:12 <maerwald> unless you know it only works with one of them
02:18:38 <bennofs> maerwald: how is stackage different from channels?
02:18:53 <maerwald> bennofs: is it rolling?
02:18:59 <bennofs> maerwald: stackage nightly?
02:18:59 <electrocat> I'm quite suprised quite a few people here still vouch for cabal-install
02:19:03 <hvr> maerwald: well, that's what we got --allow-newer for; you can opt out of the known-to-work domain
02:19:14 <maerwald> bennofs: then that could be called a channel
02:19:28 <hvr> maerwald: we just have a different way to accomplish what other ecosystems do via e.g. slots
02:19:45 <maerwald> hvr: well no, because I never know if someone meant "it DOESNT work with later version" or just "I don't know if it works with late versions", so --allow-newer doesn't do what I want
02:19:49 <bennofs> electrocat: I actually use both, stack when I don't care and cabal when I need more control
02:20:42 <hvr> maerwald: there's been discussions to add the distinction between hard/soft bounds to the .cabal syntax
02:20:44 <electrocat> bennofs: could you give an example of needing more control
02:20:54 <maerwald> hvr: that could be interesting
02:21:11 <merijn> ugh, one pet peeve left over, beating haddock into adding a kind signature :\
02:21:19 <maerwald> but that would basically be an "emulation" of channels
02:21:44 <maerwald> I am still of the opinion this problem cannot be solved just by tooling, it needs a proper platform, workflow and people dedicated in doing the work
02:21:52 <hvr> maerwald: but tbh, I think that maintainers are already having a hard time using the current system, increasing the expressivity would only set the bar of the information matinainers need to provide higher
02:21:54 <merijn> Is there a way to have a module's haddock "intro" be shared with cabal's description so I don't have two maintain two pieces of text separately?
02:22:20 <bennofs> electrocat: it is easier to use cabal-install when you already have a GHC with the correct packages installed (through other ways, such as nix) than coercing stack into using the packages from GHC
02:23:33 <hvr> maerwald: fwiw, .cabal 2.0 has learned a new operator '^>=' which is currently just syntax sugar, but one can conceive a way to infer some additional knowledge from it
02:24:10 <ongy> wouldnt ^<= be the more interesting one?
02:24:11 <hvr> and have e.g. a specific variant of --allow-newer that aacts only on ^>= 
02:24:12 <electrocat> bennofs: ah very true, that's why i use stack for everything haskell related
02:24:15 <bennofs> maerwald: I'm still not understanding how stackage is not what you want?
02:24:25 <hvr> ongy: what would it mean?
02:24:41 <ongy> hvr: that seems more intuitive for less then, but may be more
02:24:45 <maerwald> bennofs: I'm not even disagreeing, maybe only on details. It's one solution to the dependency problem
02:24:53 <bennofs> maerwald: I don't think there are a enough resources to have more than one stackage
02:25:24 <hvr> ongy: it's inspired by the "caret operator" you see in e.g. npm or other package managers; ^>= 1.2.3 then means, allow versions API compatible w/ 1.2.3
02:25:59 <bennofs> hvr: ^<= X could mean "defintely doesn't work with newer than X"
02:26:28 <hvr> bennofs: that's what <X already would convey
02:26:38 <maerwald> then we have --allow-newer and --really-allow-newer xD
02:26:58 <hvr> maerwald: we can bikeshed names
02:27:16 <bennofs> hvr: but the other approach also sounds interesing. if I understand correctly, you meant that --allow-newer would only *ignore* those new bounds, and not the other ones?
02:27:43 <bennofs> ("act on" was ambiguous. does it rely on them for solving or is it ignoring them? :)
02:27:47 <hvr> bennofs: so if you warite '>= 1.2.3 && < 1.3' you'd provide hard-bounds; but if you say '^>= 1.2.3' you say I know this works w/ 1.2.3 and nothing more
02:27:59 <cspollard> is there a general way to do (MonadTrans t, MonadTrans f, Monad m) => (f m a -> m b) -> t (f m) a -> t m b ?
02:28:14 <cspollard> it seems this should exist already somewhere!
02:28:25 <cspollard> maybe MonadTrans is not the correct class
02:28:43 <hvr> bennofs: (the 'nothing more' refers to knowledge)
02:29:11 <bennofs> hvr: ah ok so ^>= 1.2.3 would replace the current >= 1.2.3 && <1.3 PVP 
02:29:17 <bennofs> hvr: makes sense
02:29:43 <hvr> bennofs: yeah; and w/ a variant of allow-newer which only acts on ^>= relations
02:29:46 <maerwald> ideally, there should be NO difference between tested versions and hard-bounds
02:29:52 <maerwald> everything else means the maintainer was lazy
02:30:04 <bennofs> hvr: like --allow-unknown or something ?
02:30:22 <bennofs> (to allow versions where we don't know if it works)
02:30:23 <hvr> bennofs: I don't have a concrete bikeshed name for it... whatever name makes sense :)
02:30:45 <bennofs> cool
02:31:12 <hvr> bennofs: the point being is that it's very useful information to know which versions a package has been vetted by its author to be compatible with
02:31:28 <hvr> bennofs: as form that you can infer a lot
02:31:52 <hvr> and there's some related machinery I'm working on to increase the amount of additional knowledge you can infer from that
02:32:14 <maerwald> what I'd find more interesting is an "alarm system" that would tell me that some library maintainer bumped a version which broke my package (at compile time)
02:33:03 <maerwald> as in: the CI doesn't just test the package, but also reverse dependencies
02:33:24 <hvr> maerwald: to some degree that's what the matrix-builder will help with
02:33:29 <maerwald> if it breaks a lot, it could be put automatically into an "unstable" channel
02:34:01 <hvr> as I plan to hook it up to the hackage candidate feature
02:35:08 <merijn> hvr: Is there a cabal new-build write up somewhere, btw?
02:35:39 <merijn> Interesting...
02:35:52 <merijn> I'm panicing 7.4.2, apparently...
02:36:01 <maerwald> hvr: and in turn, it would be interesting if the library maintainer would be able to keep track of the progress of people fixing their packages to work with his new version
02:36:13 <maerwald> this is all done manually via bug reports and trackers in rolling release distros
02:37:56 <maerwald> and when the amount of packages which are still broken is very low, it can be discussed if the package is moved to the stable channel, triggering a new CI run first
02:38:44 <hvr> maerwald: otoh, I wouldn't put a package in unstable if it clearly signalled the breakage via the appropraite version increment
02:39:06 <hvr> that's what version bounds are for... ;)
02:39:17 <maerwald> and I want to get rid of them ;)
02:39:32 <hvr> then we have diametral design goals
02:39:42 <maerwald> only partly
02:40:22 <hvr> I want correctness, and a way to encode that at the package-level declaratively
02:40:38 <hvr> and semantic versioning is currently the best tool I know to accomplish that
02:40:39 <maerwald> yes, but only hard bounds that are _true_ are "correct"
02:41:00 <hvr> as otherwise you'd have to vet *every* single new version
02:41:28 <hvr> or fly blind and detect breakages only in production in the worst case
02:41:28 <maerwald> so when lens is bumped and breaks 1000 packages, it MUST be put in unstable, unless maintainers either a) fix their packages to work with the new version as well or b) add true upper bounds
02:41:54 <hvr> what does 'lens is bumped' mean?
02:42:01 <maerwald> version bumped
02:42:13 <hvr> which kind of version bump? are we talking minor or major?
02:42:24 <maerwald> both
02:42:39 <hvr> well, a major bump that breaks 1000 packages is no reason to put it in unstable
02:42:50 <hvr> unless you're assuming a stackage-snapshot model
02:42:53 <maerwald> it is, because I assume that people add no upper bounds
02:42:58 <hvr> where each channel contains exactly one version of each package
02:43:34 <maerwald> no no
02:43:35 <hvr> maerwald: ok, but then we don't need any versioning scheme whatsoever, just use timestamps instead of version numbers, or natural numbers
02:43:56 <hvr> as then there's no need for any kind of structure in the versioning system
02:44:14 <maerwald> I am basically projecting something similar to the gentoo/exherbo/sabayoon rolling release model to hackage
02:44:27 <maerwald> I think we are misunderstanding slightly
02:44:29 <hvr> but that's a totally different paradigm
02:44:45 <Athas> Those have only one "current version", right?
02:44:53 <maerwald> no
02:44:59 <hvr> a rolling rleease system pays almost no attention to version numbers
02:45:04 <Athas> Right, that's what I mean.
02:45:05 <maerwald> yes it does
02:45:18 <Athas> Gentoo didn't last time I used it (in 2007), and surely nothing can change in ten years.
02:45:19 <maerwald> hvr: it depends which one, I'm not talking arch linux
02:45:35 <merijn> bollocks...
02:45:37 <hvr> maerwald: ok, how would rolling systems take into account version numbers?
02:45:48 <hvr> merijn: btw, the cabal user guide isn't enough of a writeup?
02:45:52 <merijn> Does anyone know how I can investigate why GHC7.4.2 would be panicing on some fairly simple code
02:46:00 <maerwald> hvr: as I said: upper bounds still exist, but are only used for "we know it doesn't work with later versions"
02:46:04 <merijn> hvr: I dunno? I think I keep getting the old one when I google stuff
02:46:13 <maerwald> and when that happens, people put a lot of effort into fixing that problem, in order to remove the upper bounds
02:46:21 <maerwald> because they know it's problematic for the dependency solver
02:46:27 <hvr> merijn: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
02:47:28 <maerwald> hvr: and the process of detecting real upper bounds, fixing reverse dependencies and so on is something that can be improved with tooling, CI, platform and so on. A lot of that can be automated
02:47:46 <maerwald> and still be _rolling_, not freezing releases
02:48:05 <hvr> maerwald: yes, much can be automated, but not all.
02:48:42 <hvr> maerwald: especially, you can't automate detecting semantic incompatilities
02:49:27 <maerwald> run the test suite? :P
02:49:27 <hvr> (unless we encode those at the type-level...)
02:49:49 <hvr> maerwald: not feasable for matrix-builder due to the combinatorics invovled
02:50:17 <hvr> I've thought about it, but matrix-builder won't be able to ever run th4em
02:50:32 <maerwald> you're basically concerned about some library changing the behavior of IO code in a fundamental way without renaming the function but just bumping major version?
02:50:47 <hvr> maerwald: yes, not the least, because I do that sometimes
02:50:57 <hvr> (and I bump major versions for that)
02:51:07 <hvr> but not only IO code
02:51:15 <hvr> even pure functions
02:51:21 <maerwald> well, I think people in the C/C++ world are more strict about those things and don't do it
02:51:41 <hvr> yes, because they don't have a version policy and constraint solving and declarative version bounds
02:51:48 <maerwald> which is why distros don't randomly break, although they run very different combinations of software
02:52:12 <hvr> but in a semver world, you have the tools to signal such breakage
02:52:23 <hvr> so you don't have to cripple yourself when evolving your API
02:52:57 <Athas> C/C++ people also tend to use far fewer (but bigger) libraries, which means you don't need to be as careful about versioning policies.
02:53:01 <maerwald> but then you have to deal with upper bounds, np-complete, add more tools to manage that mess etc ;)
02:53:38 <hvr> maerwald: well... I guess cabal's solver is quite great at tackling the np-completeness of version constraint solving :-)
02:53:40 <Athas> Pretty sure my moderately-sized Haskell project has at least a 100 (transitive) dependencies, and I'm not even using any of the big lens-hierarchies.
02:54:02 <merijn> ugh, 7.4 dies on my DataKinds usage :\
02:54:04 <hvr> maerwald: otherwise matrix-builder would be always stuck in the solving phase ;-)
02:54:19 <hvr> merijn: that sounds plausible... there were a few bugs in there back then
02:54:31 <merijn> Is it ok for package to expose a different interface for different GHC versions via e.g. CPP?
02:55:15 <Younder> It is hard to take a math lanuage serios if it makes it so hard to use matrixes and vectors
02:55:18 <merijn> I can probably ifdef out my DataKinds usage and replace it with regular phantoms, but that means the API isn't quite exactly the same for 7.4
02:55:36 <hvr> merijn: it's not ideal; but it's tolerable if you can't do it differently; the downside is that it may force consumers to mirror the CPP
02:55:53 <Athas> Is it important to support 7.4?
02:56:04 <merijn> Athas: No, but it's trivial to do :p
02:56:20 <hvr> merijn: it's tolerable because the GHC version is part of the static compile environment, so it doesn't cause too big problems
02:56:41 <merijn> hvr: Well, basically the only real change is that a single ADT gets dropped and some of it's DataKinds uses just get replaced with phantoms
02:57:09 <merijn> So the same code should still be valid, even without the DataKinds, so consumers shouldn't need CPP I think
02:57:41 <hvr> merijn: what's less ok is if your package API becomes dependent on the version of another dependency which then appears to be a hidden degree of freedom of your API
02:58:01 <hvr> merijn: that causes real bad problems on Hackage
02:59:08 <Guest40398> purely functional language
03:01:39 <maerwald> hvr: I don't like it... we're breaking the "it compiles, so it works" with that philosophy :( and then we build a safeguard around that so people don't get to compile code that compiles, but doesn't work
03:01:44 <maerwald> but that's just me
03:02:17 <maerwald> (wrt the semver stuff discussion)
03:02:43 <hvr> I'd argue it's the other way round, SemVer gives you the formal basis for 'it compiles, so it works'
03:03:01 <maerwald> well, unless you use --allow-newer :P
03:03:46 <hvr> yeah... because you're disabling the safe-guard and deliberatly ignoring compatiblity information
03:04:25 <maerwald> yeah, that's what I mean... it's a safeguard
03:04:27 <hvr> I mean, there is different ways to rome
03:04:31 <maerwald> I think we understand each other
03:04:53 <hvr> the SemVer paradigm is one way to address it
03:05:13 <hvr> but there's also different schemes that would work w/ different tradeoffs
03:05:25 <maerwald> yeah and it's probably not practical to try to change the paradigm. The ecosystem is too far into it
03:06:21 <hvr> and it's not like that the current scheme wouldn't work at all.. :-)
03:06:51 <hvr> personally I don't experience all that cabal hell many talk about
03:07:24 <maerwald> me neither, just with a few packages that are undermaintained
03:07:40 <maerwald> and those usually also fail at compile-time with --allow-newer
03:07:41 <maerwald> very hard
03:08:09 <hvr> the biggest problem is undermaintained packages which the package author doesn't want to pass on
03:08:30 <hvr> as those will effectively force you to fork or vendor them
03:09:11 <hvr> (or not use them at all)
03:43:22 <jacereda> how can I tell stack to use a package version newer than the one in the plan?
03:44:10 <jacereda> I tried with `extra-deps` but didn't work
03:44:15 <quchen> jacereda: Add it to your stack.yaml
03:44:48 <jacereda> quchen: where? 
03:44:56 <quchen> jacereda: Hold on, looking for an example
03:45:03 <merijn> hvr: This should be fine, right? https://github.com/merijn/broadcast-chan/blob/master/BroadcastChan.hs#L51-L71
03:45:17 <quchen> jacereda: The extra-deps entry: https://github.com/quchen/prettyprinter/blob/master/stack-older-snapshots.yaml
03:45:40 <quchen> jacereda: In my case, this adds something that wasn’t in the snapshot before, but you can also override packages this way.
03:46:02 <quchen> jacereda: Here I’m overriding packages with local ones, https://github.com/quchen/stgi/blob/wl-pprint-dependency-rewritten/stack.yaml
03:46:35 <jacereda> quchen: I've added dependencies not in the snapshot before and it worked fine, but in this case there's already an old version in the snapshot
03:47:04 <merijn> Let's see if my testing finally goes green :>
03:50:28 <jacereda> quchen: ok, I'll try using the second approach, thanks!
04:01:59 <Jinxit> what are the benefits of having a newtype instead of just type?
04:02:05 <Jinxit> and drawbacks
04:03:20 <phadej> type doesn't add any type-safety, only convenience
04:03:40 <phadej> type Km = Int; type Mile = Int; and you can still add kilometers and miles
04:04:44 <phadej> with newtypes you couldn't. The drawback, is that you have to write some amount of boilerplate (instances etc. though GeneralizedNewtypeDeriving helps a lot)
04:05:01 <Jinxit> ah
04:05:04 <Jinxit> thanks
04:05:31 <Jinxit> so when i see newtype used plainly for aliasing it might as well use type?
04:06:34 <phadej> `type` is useful to make complicated type signatures less complicated; if that is what you mean by aliasing: then yes.
04:06:48 <Jinxit> yeah okay
04:06:59 <phadej> but type Age = Int is most likely just programmer laziness
04:07:48 <phadej> yet `type State = StateT Identity` makes type-signagures simpler
04:07:58 <phadej> and you cannot really have newtype there (it won't make sense)
04:08:24 <Jinxit> the one i saw was "newtype TypeEnv = TypeEnv (Map.Map Var Scheme)"
04:09:20 <phadej> Jinxit: that's a good use of `newtype`. TypeEnv is more then a map from vars to schemes
04:09:33 <phadej> as there can be maps from vars to schemes which aren't typeenvs
04:09:59 <phadej> which you don't want to mix
04:11:03 <phadej> another way to see it, newtype creates a layer of abstraction; if you talk about Age you don't care how it's implemented
04:11:11 <Jinxit> to me it's such a specialized type that i doubt it'll reappear
04:11:16 <Jinxit> that's a better argument though
04:11:35 <Jinxit> means it doesn't necessarily have to be a Data.Map
04:13:54 <phadej> Jinxit: especially it's important i`type e Var = String` and `type Scheme = Either ... `
04:14:42 <Jinxit> not sure i follow
04:14:43 <matrium> Hi, I just don't get how to use NonNull from mono-traversable. How can I construct a singleton of it? 
04:15:18 <phadej> Jinxit: if you have `type TypeEnv = Map Var Scheme`, and `type Var = String` and so one, than `TypeEnv` isn't a specialised type at all
04:15:36 <phadej> it's a map from strings to (maybe other map or list)
04:16:34 <Jinxit> ah, because it cascades down
04:16:35 <Jinxit> i see
04:16:47 <Jinxit> then yeah you're right, it matters
04:16:51 <phadej> matrium: https://www.stackage.org/haddock/lts-8.14/mono-traversable-1.0.2/Data-MonoTraversable.html#t:MonoPointed
04:20:23 <joakim`> /?
04:25:14 <matrium> phadej: Thanks! That's what I was looking for!
04:29:50 <_sras_> What exactly happens when a "OVERLAPPING" local pragme resolves an overlapping instance situtation?
04:32:44 <phadej> _sras_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
04:43:19 <torstein> Is there any way to get IO.hGetLine to block until there's a line ready?
04:43:35 <mauke> torstein: isn't that what it does?
04:44:59 <torstein> mauke, Yes, I meant ByteString.hGetLine
04:45:08 <mauke> ... isn't that what it does?
04:45:27 <torstein> I'm getting end of file error
04:45:37 <torstein> trahs: fd:5: Data.ByteString.hGetLine: end of file
04:45:41 <mauke> then you've reached the end of the file
04:46:28 <torstein> What determines that? I'm just putting strings out with IO.hPutStrLn on the other end
04:46:50 <mauke> what other end?
04:46:52 <kuribas> :t foldl (liftA2 (*)) [1]
04:46:53 <lambdabot> (Num c, Foldable t) => t [c] -> [c]
04:47:17 <torstein> Well I have a client and server communicating with handles over SSH
04:47:29 <mauke> so this is a socket?
04:47:45 <torstein> i use handles
04:47:53 <mauke> irrelevant
04:48:00 <mauke> does the handle refer to a socket?
04:48:26 <torstein> I don't think so
04:48:39 <torstein> std_in and out from a process
04:48:41 <torstein> ssh process
04:49:16 <mauke> it's probably either a socket or a pipe
04:49:27 <torstein> Yes, a pipe
04:49:30 <torstein> Like this: http://lpaste.net/355642
04:49:46 <mauke> in either of those cases, you get EOF from reading when the write end shuts down / is closed
04:50:21 <torstein> So only if the write end process terminates or the handle is closed manually?
04:50:59 <mauke> er... maybe?
04:51:31 <mauke> more precisely, it's when all write ends have been closed
04:52:10 <mauke> terminating a process is one way to close all its open handles
04:52:31 <mauke> on the other hand, fork() also clones all open file descriptors in the new process
05:05:31 <piyush-kurur> what happens if I do an hIsEOF on a handle that is a socket. Does it wait till the other end of the socket is closed or does it check whether the socket is closed right now?
05:14:03 <piyush-kurur> okey got the answer from the docs
05:14:08 <piyush-kurur> sorry for the noise
05:14:39 <piyush-kurur> it says hIsEOF may block to make sure that there is no more data. 
05:22:12 <piyush-kurur> alanz: ping
05:22:25 <alanz> piyush-kurur: pong
05:23:11 <piyush-kurur> alanz: I hope you have some time. I managed to get liquid haskell to compile using stack
05:23:22 <swerve> am I suppose to use MonadIO in order to print a string within a function that returns a different monad?
05:23:24 <alanz> nice
05:24:22 <piyush-kurur> alanz: but liquidhaskel-cabal seems to have some compilation problem (does not look like a difficult one to fix). 
05:24:39 <alanz> I have never used that, so cannot comment
05:25:18 <piyush-kurur> so what do you think is the easiest way to integrate liquidhaskell into a package like raaz. Can it do cross module verification, i.e. specs in one module, the code to be verified in another?
05:25:38 <torstein> Sometimes, though not always, doing "IO.hPutStrLn stderr" behaves as if drunk. Printing "Running as server on dir:" becomes "Ruunnninnign g aass  scelirevern t oonn  ddiirr::" any idea why?
05:25:38 <tuturto> swerve: yes, if you want to print on screen, you need IO monad
05:25:39 <Athas> swerve: yes.
05:25:56 <Athas> swerve: you can only do that if your monad is really a wrapper around IO.
05:26:41 <alanz> piyush-kurur: I have only ever experimented with LH, I am by no means an expert. And I have never tried to integrate it into the build process
05:27:31 <swerve> Athas, the monad's run function returns an IO ( ....) but it's an instance of Monad not MonadIO right now
05:28:29 <piyush-kurur> alaz: sorry I will try it out myself. Incidently there is a liquidhaskell channel. Let me try my luck there
05:29:45 <alanz> good luck
05:30:29 <bloogie> is this outdated? https://wiki.haskell.org/Implement_a_chat_server
05:31:12 <Athas> bloogie: doesn't look that way from a quick skim.
05:31:35 <swerve> Athas, ah ha, figured it out. liftIO works
05:31:54 <bloogie> Athas: thanks, and do you think this would be a good introduction to network programming in Haskell?
05:31:57 <Athas> bloogie: it's a very low-level way of doing it, though.
05:32:03 <quchen> bloogie: I have a working version of a simple client/server app here: https://github.com/quchen/talks/tree/master/beginner-workshop_rolling-update/src/ClientServer
05:32:14 <quchen> bloogie: See the two Main.hs files in app/
05:32:18 <Athas> Sure, for actual socket-level programming.  If you want web services, then there are more high-level libraries (I hope).
05:32:41 <bloogie> quchen: thanks, looking at it
05:33:20 <mauke> torstein: sounds like two threads printing at the same time
05:33:34 <quchen> bloogie: You can try it out first by following the instructions in the readme :-)
05:35:01 <torstein> mauke, Aaahh.. Of course.. Any way to make it block until the line is finished printing?
05:35:43 <quchen> Let only one thread print at a time.
05:36:09 <quchen> Simple solution: global lock.
05:36:21 <mauke> alternatively, switch stderr to line buffering
05:36:22 <quchen> Downside is that if one thread dies your lock stays locked.
05:36:27 <quchen> Or that.
05:36:40 <quchen> Or use a dedicated printing thread, which is what I like to do.
05:36:59 <torstein> Why doesn't it block by default? It's printing lines after all
05:37:24 <quchen> The buffer behaviour is part of the handle, not of putStrLn.
05:38:14 <mauke> torstein: the deeper reason is that strings are lazy lists
05:38:19 <torstein> Would "hSetBuffering stderr LineBuffering" work? 
05:38:26 <quchen> Yes.
05:38:40 <quchen> mauke: I don’t think so, you’d probably have the same issue with Text.
05:38:48 <mauke> unlikely
05:38:56 <torstein> That changes the stderr handle globally, right, or do I need to pass it around?
05:39:02 <mauke> torstein: it's a global setting
05:39:06 <quchen> mauke: Well, Text is much faster, making the race condition less likely to be observable.
05:40:00 <mauke> quchen: the issue is that stderr is unbuffered. in other languages that means every write() or print() call is seen immediately
05:40:24 <mauke> but in haskell strings are lazy lists, and you never know if you have a next character
05:40:37 <mauke> (or maybe you'll get it eventually but it will take a long time)
05:40:51 <mauke> so you get a separate write() syscall for every single character you output to stderr
05:41:00 <quchen> Wait, really?
05:41:05 <mauke> sure
05:41:06 <torstein> wouldnt hPutStrLn force the string before passing it to the handle?
05:41:10 <mauke> torstein: no
05:41:23 <mauke> hPutStrLn (repeat "y\n") works fine
05:41:26 <quchen> Ah, I remember reading this in the GHC source and being equally surprised as I am now
05:41:28 <mauke> hPutStrLn stdout (repeat "y\n") works fine
05:41:58 <mauke> quchen: try running strace on a haskell program that writes to stderr :-)
05:42:03 <quchen> torstein: Better suggestion, don’t ever use String.
05:42:15 <quchen> Use Text instead.
05:42:22 <quchen> String is for Hello World, exclusively.
05:42:30 <quchen> mauke: Eww. Okay, hold on.
05:43:59 <osa1> is there a way to give a test suite target to `stack repl` ?
05:45:22 <quchen> mauke: Ewwwewewww..!!!
05:46:11 <mauke> can you taste the performance?
05:46:25 <quchen> write() is in C so it’s very fast
05:46:50 <mauke> write is a syscall so it does a context switch into the kernel
05:47:06 <merijn> quchen: That's like the opposite of correct :p
05:48:05 <quchen> merijn: write is not in C so it’s very fast?
05:48:19 <merijn> quchen: No, it's not very fast :p
05:48:31 <merijn> quchen: At least, not if you call it repeatedly with small data
05:49:02 <quchen> mauke: I just repeated it with Text and it’s the same amount of writes. :-s
05:49:30 <mauke> that's interesting
05:49:33 <quchen> main = hPutStrLn stderr "hello world" >> T.putStrLn stderr "hello world"
05:49:42 <quchen> That’s strange.
05:50:02 <mauke> how about ByteString.Char8?
05:50:21 <quchen> Changing it to STDOUT gives me one write call each
05:50:38 <quchen> So Text is written char-buffered as well! Eww
05:50:48 <quchen> I thought Text would do the chunking
05:50:56 <quchen> Or at least some of it
05:50:57 <merijn> That doesn't sounds right...
05:51:45 <quchen> lpaste.net/355643
05:52:02 <merijn> quchen: And you're seeing how many writes?
05:52:11 <quchen> stack ghc Test.hs --package=text && strace ./Test
05:52:26 <quchen> merijn: Two "hello world" writes to STDOUT
05:52:39 <quchen> Two chains of hello-world-charwise to STDERR
05:52:50 <merijn> hmmm
05:53:01 <merijn> oh
05:53:10 <merijn> bingo
05:53:11 <merijn> https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-IO.html#hPutStr
05:53:19 <merijn> (NoBuffering, _)        -> hPutChars h str
05:53:23 <merijn> That's the offender
05:53:35 <merijn> So it should work if you change the buffering of stderr
05:54:05 <quchen> If I change the buffering of stderr then Text looks efficient, and String does as well :-þ
05:54:08 <mauke> they should just fix their code
05:55:47 <quchen> No buffering meaning charwise printing is awkward, yes
05:56:51 <mauke> they could just implement it as a block write
05:57:23 <Jinxit> if i'm inside an RWST (with Except), how do i throw an except including the entire RWST state? do i have to grab it piece by piece?
05:57:59 <Itkovian> any idea if Aeson's toEncoding = genericEncoding defaultOptions should provide similar performance compared to manually specifying the pairs or would the former be worse?
05:58:34 <mauke> sometimes I feel like Haskell is similar to C++ in that its standard IO handles are crazy and you're better off implementing your own abstraction on top of raw fds yourself
05:58:49 <maerwald> mauke: heh, exactly what I did
05:59:57 <quchen> mauke: RFC, https://github.com/bos/text/issues/179
06:05:16 <mbrock> fun expression: [0..n-1] where n is a Word256 and sometimes accidentally is 0...
06:07:12 <ongy> and that's why we need integer intervals in types
06:07:31 <quchen> The joy of implicit overflows is only eclipsed by the joy of implicit exceptions on overflow
06:07:41 <quchen> The joy of implicit overflows is only eclipsed by the joy of explicit exceptions on overflow
06:07:42 <quchen> Grr.
06:08:42 <kuribas> Is sorting a (almost) sorted list cheaper?
06:09:08 <ongy> depends on your algorithm
06:09:13 <quchen> Depends on the algorithm. Data.List.sort? Yes, it’s massively cheaper.
06:09:25 <quchen> It has run detection built-in.
06:09:36 <kuribas> quchen: like O(n)?
06:09:42 <kuribas> for a sorted list?
06:09:48 <quchen> Yes.
06:10:02 <quchen> Or reverse-sorted.
06:10:10 <mauke> I only remember that head . sort is O(n)
06:10:14 <quchen> It’s mergesort with run detection.
06:10:33 <quchen> The algorithm is quite nice and worth a read
06:10:35 <kuribas> mauke: minimum will be faster...
06:10:39 <quchen> Not complicated at all
06:10:49 <kuribas> right, thanks
06:10:50 <mauke> kuribas: why?
06:11:05 <kuribas> mauke: because it's just a fold?
06:11:26 <kuribas> mauke: can't go faster than that.
06:11:45 <kuribas> right?
06:11:54 <mauke> that's not evidence. it's not even logically correct
06:13:57 <kuribas> well, you need to examine every element at least once, so the fastest way to do it is once...
06:14:15 <kuribas> if (<) is strict at least
06:24:18 <quchen> mauke: Are you sure about the head thing?
06:25:02 <quchen> I would expect a list of n elements to require O(log(n)) merges until the final merge, which then results in a O(1) first element
06:26:19 <mauke> as it turns out, I'm not sure, no
06:26:22 <mauke> http://stackoverflow.com/questions/40820093/haskell-head-mergesort-for-min-element-in-linear-time
06:36:46 <ph88^> how can i make my own exception type (with a string) and then throw it ?
06:37:26 <lyxia> Declare a new data type, implement Exception
06:38:00 <ph88^> no minimal implementation for Exception class ?
06:39:10 <lyxia> the minimal implementation is empty
06:39:31 <lyxia> and I can't see a reason not to let it so
06:39:50 <ph88^> are unused instances of typeclasses removed by the compiler ? if i derive Show and don't use show
06:40:29 <byorgey> ph88^: probably
06:40:54 <Maxdamantus> Well, it would be a bit wasteful if the compiler included the infinite number of Show instances that typically exist
06:40:57 <quchen> I’d say no, because of the open world assumption
06:41:12 <Maxdamantus> otherwise we'd have binaries that are infinitely large.
06:41:13 <quchen> I.e. a module could be imported and always has to export its instances
06:41:27 <Maxdamantus> Show Char, Show [Char], Show [[Char]], Show [[[Char]]], ...
06:41:31 <byorgey> quchen: good point
06:41:44 <quchen> Maxdamantus: There is no Show [[Char]] instance definition.
06:42:03 <ph88^> is it possible to run main in ghch with command line options ?
06:42:05 <byorgey> Maxdamantus: type class instances in Haskell aren't like template instances in C++.  You don't need a different version of the code for each type.
06:42:08 <quchen> Maxdamantus: Similarly, we don’t have to export »id :: Int -> Int« and »id :: (a -> b) -> (a -> b)« and so on
06:42:52 <quchen> ph88^: »:main arg arg arg«
06:43:37 <Maxdamantus> Mm, I guess.
06:43:49 <byorgey> ph88^: more generally you can also use System.Environment.withArgs
06:44:28 <quchen> byorgey: Woah! I didn’t know about that one, but I’ve been looking for it for a long time!
06:44:33 <byorgey> =)
06:44:45 <byorgey> I learned about it from fryguybob 
06:44:48 <quchen> Is it new?
06:45:03 <quchen> I wrote countless hacky ways of cutting off certain parameters
06:45:04 <byorgey> I don't know how long it's been around
06:45:37 <quchen> https://hackage.haskell.org/package/base-4.5.0.0/docs/System-Environment.html#v:withArgs
06:45:40 <quchen> Ookkkayyy
06:45:49 <byorgey> hahaha
06:45:51 <quchen> I guess the error is on my side
06:46:00 <quchen> 4.5 was what, 7.4?
06:46:20 <byorgey> yep
06:46:36 <ph88^> what did i do wrong in this optparse-applicative option ?  https://bpaste.net/show/4381b835fc7b
06:47:14 <byorgey> quchen: https://hackage.haskell.org/package/base-4.0.0.0/docs/System-Environment.html#v:withArgs
06:47:30 <byorgey> that would be.... GHC 6.10
06:47:40 <byorgey> 9 years ago
06:47:48 <quchen> I wasn’t around at that time.
06:48:04 <quchen> Long time!
06:48:48 <ph88^> you are 8 ? :P
06:49:13 <byorgey> ph88^: yes, quchen is very precocious
06:49:18 <lyxia> ph88^: auto uses Read (Maybe Int)
06:49:30 <quchen> I’m turning 8 in August
06:50:18 * byorgey is... almost 12, I think. Or maybe 11.
06:50:32 <quchen> Oh, Haskell-wise, hmm.
06:50:37 <quchen> I’d have to look it up.
06:50:41 <quchen> But I can point it down to the second!
06:50:54 <quchen> Not nearly 12 though. More like 5.
06:51:10 <quchen> Cold and boring winter recess 2012.
06:51:26 <quchen> January, that is.
06:56:37 <byorgey> what do you know, it looks like today is exactly the 10-year anniversary of the first time I said something in this channel =)
06:57:10 <exio4> byorgey: so cool! I wish I was here ten years ago!
06:57:29 <exio4> ok, that doesn't really sound grammatical, ignore it :P 
06:57:50 <mbrock> byorgey: congrats! how did you find out? ircbrowse.net seems down
06:58:22 <byorgey> I have a bunch of old #haskell logs stored on my HD
06:59:16 <Sh4rPEYE> Hello. I'm doin the parsing chapter in Haskell Book and I don't quite get what the "stop" and "eof" mean. I guess 'char' means 'read this one char from a string', and 'unexpected "stop"' might mean something like 'throw an exception and stop reading the string. But eof?
07:00:08 <phadej> Sh4rPEYE: eof "at this point the input should be empty, otherwise raise parse error"
07:00:30 <phadej> "expecting end-of-input; trailing data found" or something like that
07:01:05 <Sh4rPEYE> Thanks
07:03:53 <quchen> »EOF« stands for »end of file«, if that helps.
07:04:34 <quchen> It’s typically a parser that succeeds only if there is nothing left in the input stream.
07:30:32 <erisco> luite_, is ghc-8.0 branch of ghcjs working on Windows with GHC 8+ or is it still in development? tried it but had issues
07:41:31 <merijn> Did anyone ever write a nice blog post on writing efficient (recursive) monadic loops?
07:46:58 <erisco> hope this still works... deleted a patch during ghc-boot so it wouldn't fail on it
07:47:39 <erisco> nope, fails later on on something else... I'm done
07:48:07 <erisco> can't get my Haskell compiled to JavaScript :( now what
07:51:56 <cocreature> erisco: write js like a peasant
07:52:10 <erisco> I already have written the Haskell program, though, and I like it
07:54:26 <shapr> erisco: using ghcjs?
07:54:27 <ventonegro> write a PureScript port
07:54:40 <erisco> shapr, yeah, can't get it running on the Windows
07:54:47 <shapr> oh, I don't know
07:54:48 <erisco> ventonegro, doesn't have the language features I am using
07:56:22 <erisco> if there was a prebuilt for GHC 8+ that I could run with Vagrant... maybe...
07:58:56 <athan> Can I use IO in QuickCheck's Gen? Or will I need to do some unsafe stuff?
07:59:31 <erisco> maybe I will just make this a desktop program... lol...
08:00:37 <merijn> So, starting from transformers-0.5.2 MonadIO is just a reexport of base, right?
08:00:48 <lyxia> athan: you can't
08:02:18 <lyxia> athan: If you're writing tests, ioProperty may be useful
08:03:05 <erisco> what are the hot and awesome UI libs?
08:03:20 <torstein> Is it possible to have sub-tests with arguments in HSpec? e.g. a HSpec test function "testDir :: FilePath -> IO" which is only called in other tests and not run standalone 
08:05:46 <athan> erisco: pux from purescript :v
08:05:57 <MitchellSalad_> hello all, been a while since I did any SYB programming... is uniplate still preferred?
08:06:22 <erisco> no GADTs, no DataKinds... I'd have to lose too much
08:07:47 <lyxia> GHC.Generics > SYB   but I don't know of any uniplate equivalent.
08:09:20 <MitchellSalad_> yeah? why is generics > SYB? (I assume by SYB we mean Data.Data?)
08:10:27 <mrkgnao> MitchellSalad_: are you Neil Mitchell?
08:10:55 <MitchellSalad_> no, haha
08:10:55 <mrkgnao> I'm asking because, in that case, your Uniplate post was my introduction to the library, of a sort
08:11:11 <mrkgnao> oh :)
08:11:28 <lyxia> Yes I mean Data.Data. the problem is that the Constr representation loses all type information
08:11:39 <int-e> mrkgnao: he's no longer on IRC I think; ndm used to be the nickname.
08:12:08 <int-e> @quote ndm
08:12:09 <lambdabot> ndm says: As always, the most useful thing in the error message is the line number.
08:13:05 <lyxia> So SYB is unsafe because you can mix up your types, and slow because of dynamic typing.
08:15:14 <_sras_> I am trying to represent a Nonempty value using Swagger Schema. Is this the right way to go about this http://lpaste.net/355647 ?
08:17:16 <paolino_> erisco, reflex
08:17:39 <EvanR> i just used foldl for something
08:17:51 <erisco> "Reflex is a high-performance, deterministic, higher-order Functional Reactive Programming system
08:17:51 <erisco> "
08:17:55 <erisco> doesn't sound like UI to me
08:18:03 <EvanR> but its essentially a list reverse, but on a different data type
08:18:13 <paolino_> erisco, reflex-dom
08:19:30 <erisco> well I don't want to write a web server and I can't get GHCJS working
08:19:59 <paolino_> it compiles also gtk 
08:20:42 <erisco> reflex platform does not support Windows... do I need that?
08:21:24 <paolino_> never used Windows, sorry
08:23:31 <kuribas> erisco: gi-gtk and wxHaskell?
08:24:21 <paolino_> erisco, by writing for the browser you can overcome some platform related issues
08:24:53 <erisco> yeah, I tried that, but not to the extent that I stop using Haskell
08:24:56 <erisco> and all options failed
08:25:04 <ventonegro> erisco: what about threepeny-gui?
08:25:14 <ventonegro> penny, even
08:25:41 <erisco> sounds interesting but it is too much to have the user start a server and connect to it with the browser
08:26:18 <erisco> kuribas, I will take a look
08:26:21 <EvanR> why is ghcjs not a solution?
08:26:37 <erisco> paolino_, what provides the gtk backend for reflex?
08:26:48 <erisco> EvanR, I can't get it compiled, that's why
08:26:54 <EvanR> thats...
08:27:17 <EvanR> sounds like surrender
08:27:33 <erisco> yes. I am tired of dealing with it
08:27:39 <kuribas> erisco: wxHaskell is useable but incomplete.
08:27:44 <ventonegro> doesn't stack have a ghcjs template?
08:27:54 <EvanR> erisco: are you trying to make a haskell GUI for windows?
08:27:57 <fizruk> _sras_: there's minItems property that you can set to 1
08:28:03 <kuribas> erisco: gtk is more complete but is only native on linux.
08:28:04 <EvanR> "at any cost" ?
08:28:05 <erisco> EvanR, that's the fallback plan now, yes
08:28:22 <EvanR> then you can write the GUI in C# and use FFI to make haskell control it
08:28:42 <EvanR> .net bridge
08:28:57 <EvanR> it will look nice and native
08:29:17 <erisco> looking nice is not a requirement... easy for me and easy for the user is
08:29:19 <EvanR> or like i did, not FFI, but STDIO to control it
08:29:23 <kuribas> EvanR: why not the win32 API?
08:29:29 <fizruk> _sras_: btw, I think NonEmpty is in dependencies of swagger2, so it makes sense to add that instance directly to swagger2
08:29:50 <EvanR> kuribas: have you used win32 directly to make a gui app?
08:29:57 <paolino_> erisco, gi-gtk
08:30:01 <kuribas> EvanR: long time ago yes :)
08:30:14 <EvanR> yeesh
08:30:17 <_sras_> fizruk: I am completly lost. How can I do this. Also, Where is the minItems thing you mentioned earlier?
08:30:34 <kuribas> EvanR: for win 3.1 :)
08:31:03 <_sras_> fizruk: Right now I have this http://lpaste.net/355648
08:31:16 <kuribas> erisco: for something native wxHaskell is probably the easiest.
08:31:34 <kuribas> erisco: as long as you don't need the newest features.
08:32:03 <erisco> I need some basic forms and basic drawing
08:32:31 <kuribas> should be no problem
08:33:24 <lpaste> fizruk revised “No title”: “No title” at http://lpaste.net/355647
08:33:27 <EvanR> that kind of thing, specifically on windows, could use a simple direct haskell solution as a library
08:33:33 <fizruk> _sras_: should be something like this: http://lpaste.net/355647
08:33:49 <EvanR> win32 bindings cant be the answer
08:34:03 <fizruk> _sras_: it's best to use lenses to work with Swagger data model
08:34:26 <kuribas> EvanR: wxHaskell?
08:34:46 <EvanR> wx anything has never worked out for me, and from the stories in here
08:35:21 <orion> Is there a more idiomatic way of writing the following?: modifyFoo f = f & someFieldInFoo %~ (<*>) (pure bar) -- where someFieldInFoo is a Maybe Foo?
08:35:43 <fizruk> _sras_: mapped is basically lens version of fmap, allows me to get to NamedSchema of (m NamedSchema)
08:35:55 <orion> is a Lens over a Maybe Foo*
08:36:00 <fizruk> _sras_: schema then goes to Schema in NamedSchema
08:36:33 <kuribas> EvanR: I wrote a simple canvas in wx: http://hackage.haskell.org/package/wxSimpleCanvas
08:36:37 <kuribas> EvanR: it works ok
08:36:56 <fizruk> _sras_: then description and minItems go to corresponding properties of the Schema
08:37:23 <fizruk> _sras_: (?~) operator sets optional value to (Just something)
08:37:45 <EvanR> kuribas: the good thing about my gui in cocoa (in haskell) was that i got any and all toolkit features provided by the platform, everything worked the way it was supposed to...
08:38:15 <EvanR> there was no fiddling with WX
08:38:21 <kuribas> EvanR: you build it in objective C?
08:38:24 <EvanR> "native is best"
08:38:28 <EvanR> yes
08:38:29 <fizruk> _sras_: now you may be wondering how to know which lenses are there
08:38:32 <_sras_> fizruk: I had tried something like your paste eralier..But got so many errors...
08:38:36 <EvanR> just the thin outer layer
08:38:45 <_sras_> fizruk: http://lpaste.net/355649
08:38:59 <kuribas> EvanR: yes, but you get the other platforms for free with wx
08:39:07 <EvanR> i dont know how well that would work on windows, since win32 is noticably more crunchy
08:39:22 <EvanR> kuribas: ... that is what the brochure says
08:39:32 <EvanR> "its so easy, call now"
08:39:45 <EvanR> "satisfaction guaranteed"
08:40:06 <fizruk> _sras_: I'm not sure, but that's probably because you lack some spaces, try this: mapped . Swagger.schema . description
08:40:41 <kuribas> EvanR: is .NET so much better then?
08:41:11 <fizruk> _sras_: wait, no
08:41:23 <EvanR> kuribas: its not going to look exactly right, its not going to have all the features of your OS in case you change your mind about something, you have to deal with WX the actual C++ library
08:41:23 <erisco> I agree that native UIs are the best way to go (speaking from mobile dev experience)
08:41:42 <erisco> but doing it with FFI would be such a PITA
08:41:50 <EvanR> like i said, i used stdio
08:41:57 <EvanR> which was a mild pain in the ass
08:42:59 <EvanR> since the target for this project is specifically windows, it might be a good idea to exploit that
08:43:07 <fizruk> _sras_: the root problem is this:   The type variable ‘b0’ is ambiguous
08:43:27 <erisco> I am not sure how I'd do the communication really
08:43:44 <_sras_> fizruk: Yes
08:43:51 <fizruk> _sras_: that is the type of description is ambiguous, you can fix that by adding an explicit annotation to the description
08:44:02 <fizruk> _sras_: description ?~ ("description" :: Text)
08:44:19 <erisco> I would... what... need to invent a small language to communicate between the UI and Haskell programs
08:44:36 <fizruk> _sras_: that's a bit weird since I thought there's a functional dependency to prevent that ambiguity
08:44:55 <erisco> and all the care I've taken with the types in Haskell means nothing
08:45:38 <EvanR> erisco: the UI layer would be concerned only with showing graphics, getting particular events
08:45:53 <EvanR> as much as possible would be in haskell
08:45:57 <EvanR> and it would be pure haskell
08:46:11 <erisco> yes, but I've taken care to model what to show well with types
08:46:15 <erisco> none of which would matter now
08:46:17 <fizruk> _sras_: hmm... which versions of lens and swagger2 do you build with?
08:46:39 <_sras_> fizruk: After annotation http://lpaste.net/355650
08:46:41 <EvanR> im not sure i understand, you wrote the GUI in haskell without a working GUI ?
08:47:09 <EvanR> i dont really understand how whatever you have cant be used with a proper driver
08:47:23 <EvanR> assuming it just types and not drivery stuff you already have
08:47:33 <erisco> the states and flow of states is done
08:47:37 <erisco> it is just a matter of putting a head on it
08:47:41 <EvanR> there you go
08:47:56 <_sras_> fizruk: Is minitems part of Schema? I am not seeing that property...
08:48:37 <erisco> yes but I lose everything over the bridge
08:48:45 <EvanR> you can think of it like an FFI, if you have foreign objects that should be deleted if they are gc'ed over here, finalizers, etc
08:48:47 <erisco> I have to serialise and deserialise on the other side
08:48:48 <_sras_> fizruk: I am using resover:  nightly-2017-03-01
08:48:56 <erisco> which means I have to emulate the types on the UI side
08:49:07 <erisco> but C# is not strong enough... so not only do I have to redo the work but it will be worse
08:49:21 <EvanR> if its not "just a head" and a lot of functionality is in the forms and panels... might not work
08:49:46 <EvanR> if the gui is just there to provide controls and display info... could work
08:50:32 <kuribas> EvanR: that still sounds more complicated than using wxWidgets...
08:50:33 <erisco> how did you use stdio? I haven't done IPC much
08:50:37 <fizruk> _sras_: it's in ParamSchema which is a part of Schema
08:51:02 <EvanR> kuribas: well, we can go over my gripes about that again if you want, they are orthogonal to complexity
08:51:35 <kuribas> EvanR: but if erisco just wants some forms?
08:51:35 <EvanR> just doing something now in wx may work, right now
08:51:52 <EvanR> if all you really care about is throwing something up
08:51:54 <kuribas> it's true that it's not very active, and not so well supported...
08:52:12 <fizruk> _sras_: this does not make sense: Could not deduce (HasDescription Schema (Maybe Text))
08:52:32 <ph88^> with optparse-applicative, how can i make an option that takes integers on the command line and transforms them into Just integer, and Nothing when the option was not given?
08:52:41 <fizruk> _sras_: there's exactly this instance in swagger2-2.1.3 which is in nightly-2017-03-01
08:52:54 <EvanR> my gripes were the quality of the wx project, the quality of the resulting front end, the flexibility of the app wrt to the particular platforms
08:53:25 <EvanR> and theres only one platform in this case
08:54:03 <EvanR> not claiming itll be a cheaper up front amount of effort
08:54:31 <erisco> maybe this? hrm http://hackage.haskell.org/package/hs-dotnet
08:54:50 <lyxia> ph88^: replace auto with (Just <$> auto) ?
08:54:59 <erisco> little worried that it is 8 years old
08:55:39 <erisco> "All reported builds failed as of 2017-01-01" yeah no... and docs talk about GHC 6
08:55:45 <_sras_> fizruk: Do you know how to check installed package version using stack?
08:56:14 <erisco> EvanR, if you can explain the IPC then I can consider it
08:56:25 <ph88^> thanks lyxia 
08:57:19 <EvanR> erisco: well, i spawned my gui process using an exec pipe from System.Process and get two fds, which were stdin and stdout in the child. which was written in objC
08:57:24 <ph88^> lyxia, eh it didn't quite do the right thing .. now i need to supply to option
08:57:31 <ph88^> it's not optional anymore
08:57:40 <EvanR> the protocol consisted of commands, two sets of commands one for each direction
08:57:48 <EvanR> the commands had a simple format
08:58:00 <EvanR> command arg1 arg2 arg3 newline
08:58:16 <erisco> okay, so you spawned a child process and communicated via pipe?
08:58:27 <EvanR> if there was a large amount of binary data, then it would be sent in hex and cached on one end, with an ID to refer to it later
08:58:49 <EvanR> erisco: two children actually, one for the GUI one for CoreAudio
08:58:53 <erisco> yes I don't care so much about the protocol
08:59:02 <erisco> just the mechanism to do IPC
08:59:09 <EvanR> yes exec pipe
08:59:38 <EvanR> so the child processes could easily be tested separately on stdio
08:59:46 <EvanR> and typing commands by hand
08:59:59 <mrkgnao> does kind! not reduce type family applications inside constructors?
09:01:27 <erisco> okay, thanks
09:02:14 <kuribas> EvanR: I just install wx with cabal, without any problems.  On ghc-8.2.
09:02:33 <EvanR> and you alread have wx the c++ lib?
09:02:43 <kuribas> EvanR: naturally
09:03:10 <erisco> I never had a positive experience with non-native UIs (except web) so I am hesitant to go that route
09:03:11 <ph88^> lyxia, i got it, i used   optional
09:03:21 <EvanR> and youre happy with what wx produces, great
09:03:24 <kuribas> erisco: wxwidgets is native
09:03:45 <erisco> by native I mean proprietary to the platform
09:04:32 <erisco> they have all the features and are specially designed and tested to work on that platform
09:05:07 <fizruk> _sras_: stack exec ghc-pkg -- list | grep swagger2
09:06:11 <kuribas> EvanR: is Win32 not supported anymore?
09:06:26 <EvanR> i think it is, and there are haskell bindings for it
09:06:32 <erisco> there is inconsistency with web but there is so much attention given that you're not usually hard pressed to find a solution
09:06:42 <EvanR> i just assumed erisco would want the modern version and he knows c#
09:07:18 <erisco> I do but I haven't made desktop UIs... not even sure what the toolkit for that is nowadays
09:07:23 <EvanR> but if you want to write this front end in C ...
09:07:36 <EvanR> erisco: heh, C, win32 ;)
09:07:45 <EvanR> with special microsoft C
09:08:04 <erisco> there is WinForms which I think is older
09:08:06 <EvanR> whatever is more comfortable
09:08:18 <kuribas> EvanR: there is mingw
09:08:28 <EvanR> some people are really good with a particular weird old API
09:08:46 <kuribas> you couldn't call that native though
09:08:57 <EvanR> mingw, the c compiler
09:09:01 <EvanR> should work
09:09:25 <erisco> ah and I think Windows Presentation Foundation (WPF) is the new one
09:09:32 <EvanR> hell you could write the front end in visual studio
09:09:43 <erisco> of course I'm doing that
09:09:44 <EvanR> or .net 
09:09:54 <EvanR> or the latest greatest
09:09:57 <erisco> it is actually a good IDE for C#
09:10:22 <erisco> the build system can be a quagmire but so are most...
09:10:26 <kuribas> is it free?
09:10:41 <erisco> they have free editions with limited features and license
09:12:17 <erisco> I happen to have VS 2015 pro licensed from work I did a while ago
09:12:59 <EvanR> i think this way youre sort of taking windows and haskell seriously at the same time
09:13:08 <EvanR> no diluting the spirit of each other ;)
09:13:36 <erisco> ah yes... the XAML stuff... been a long time since I've done any of this
09:13:44 <erisco> last time was Silverlight when I was doing WP dev
09:15:10 <_sras_> fizruk: It seems that I have both swagger and swagger2...
09:15:47 <_sras_> fizruk: http://lpaste.net/355651
09:15:59 <fizruk> _sras_: although you probably don't need swagger, it shouldn't conflict
09:16:08 <ph88^> i have an IO action which returns () and i want to use `try`, i'm only interested to do something in the case of Left, is there some nice syntax for this so i don't have to put a dummy case for Right in a case statement?
09:16:22 <EvanR> ph88^: onException
09:16:33 <EvanR> instead of try
09:16:59 <erisco> heh... though dynamic UI never worked that well with visual editors
09:17:20 <EvanR> youll have to use actual code then to add and delete widgets
09:17:26 <erisco> mhm
09:17:37 <ph88^> nice one EvanR 
09:19:53 <ph88^> EvanR, how do i get the actual exception with onException ? i want to put the exception string to stderr
09:20:37 <fizruk> _sras_: can you try loading this code into GHCi? https://gist.github.com/fizruk/bef0d81d5d6f4422bfed9631b08087e3
09:20:47 <fizruk> _sras_: stack ghci
09:21:03 <EvanR> ph88^: actually then you might want to do catch or handle
09:21:32 <ph88^> aah catch  ok  ok
09:21:39 <EvanR> but catching all exceptions, printing it out and ignoring it is probably bad unless youre doing threads?
09:21:54 <EvanR> in which case async makes this reall yeasy
09:22:45 <matrium> hi, is there any type in base or containers that guarantees a infinite stream of values?
09:22:56 <EvanR> @src Stream
09:22:56 <lambdabot> Source not found. Sorry.
09:23:06 <EvanR> Stream package
09:23:17 <_sras_> fizruk: Yes
09:23:26 <EvanR> capital S
09:23:38 <EvanR> data Stream a = Stream a (Stream a)
09:24:09 <matrium> EvanR: thanks!
09:24:47 <fizruk> _sras_: does it load fine?
09:25:06 <_sras_> fizruk: Yes. It loads fine
09:25:27 <byorgey> matrium: http://hackage.haskell.org/package/streams
09:25:40 <byorgey> I don't think there's anything in base or containers.
09:26:15 <byorgey> Oh, I didn't know about the Stream package.  It looks much simpler.
09:26:49 <fizruk> _sras_: then there's some other problem in your actual code
09:27:17 <EvanR> byorgey: whoa... anti-causal ;)
09:28:57 <matrium> Unfortunately, capital Stream is not on stackage
09:29:06 <EvanR> o_O
09:29:27 <EvanR> maybe people tend to make their own Stream
09:29:37 <EvanR> which seems silly.  or stackage is lacking
09:29:42 <sproingie> doesn't a plain old list from an unfold express a stream pretty well?
09:29:59 <EvanR> like Integer represents Naturals
09:30:15 <EvanR> and ByteString represents Ascii text
09:30:27 <sproingie> ok, so a Stream class then
09:30:33 <EvanR> o_O
09:30:46 <EvanR> which is broken for [] ?
09:31:04 <sproingie> so, guaranteed infinite then?
09:31:11 <EvanR> that was the question
09:37:01 <_sras_> fizruk: Yes...
09:37:41 <fizruk> _sras_: can you share the whole module that has that type error?
09:38:02 <fizruk> _sras_: just in case, do you have swagger (without 2) in your .cabal?
09:42:25 <_sras_> fizruk: It works now. Was a stupid error.  'description' instead of 'Swagger.description'....
09:43:38 <fizruk> _sras_: is there a reason you use Swagger qualified?
09:44:14 <fizruk> _sras_: also, where does description come from if not from Swagger?
09:44:37 <carter> johnw: I'll be compose this afternoon.
09:44:52 <carter> Be at
09:45:31 <merijn> Any blog posts/whatever on "Things You Should Know for Writing Fast Monadic Loops"?
09:45:41 <fizruk> _sras_: can you open an issue about ToSchema (NonEmpty a) ?
09:47:39 <_sras_> fizruk: other description comes from my own code.
09:48:09 <_sras_> fizruk: What is the issue about ToSchema (NonEmpty a)?
09:48:20 <fizruk> _sras_: to add it directly to swagger2
09:49:38 <_sras_> fizruk: Yes. 
09:54:21 <fizruk> _sras_: btw, I don't think that was really a stupid error
09:56:02 <_sras_> fizruk: It was obvious that it was some other "description" because I can access it unqualified, right?
09:56:22 <fizruk> _sras_: yeah, but it's easy to miss this kind of error
09:56:57 <fizruk> _sras_: luckily it still happens at compile time
09:57:14 <_sras_> fizruk: Yes. 
09:58:47 <merijn> hmmm, one of my criterion benchmarks isn't outputting a bar plot for my benchmarks. In fact, it's not even producing graphs for every benchmark?
09:58:53 <merijn> Any clues what could be going wrong?
09:59:04 <fizruk> _sras_: I hope it'll get better when we have OverloadedRecordFields
09:59:14 <Philonous> Are there good resources on program design ("design patterns") in dependently typed settings? 
10:00:05 <_sras_> fizruk: how does it relate in this case?
10:00:23 <fizruk> Philonous: Type Driven Development with Idris? :) honestly I don't know though
10:00:41 <Philonous> Looking
10:00:49 <Philonous> Looks interesting
10:01:10 <fizruk> _sras_: there'd be one "description" for both your lenses and Swagger's
10:01:43 <fizruk> _sras_: it's still possible to reuse Swagger's HasDescription class in your makeClassy
10:01:51 <Philonous> And once again libgen saves the day. Thanks :)
10:02:03 <fizruk> _sras_: you just have to bring it into scope afaik
10:02:50 <_sras_> fizruk: Yes. I think so too.
10:03:47 <fizruk> _sras_: but that approach won't work if you have HasDescription in two different libraries you depend on :)
10:06:48 <merijn> oh...
10:06:59 <merijn> maybe my benchmarks just break the JS plotting library criterion uses...
10:07:17 <merijn> And I was hoping to conveniently use the bar chart for comparisons :\
10:07:57 <_sras_> fizruk: You mean, if it is not generated via TH?
10:09:02 <_sras_> fizruk: btw, is there any way to generate a Swagger schema for a type from a Digestive functor's Form for the same type?
10:09:10 <merijn> oh...$10 says the JS is barfing on NaN
10:13:50 <Philonous> merijn, If you have the data as csv or json or something you could just plot them in R
10:15:09 <merijn> Philonous: That involves first installing and learning R....
10:15:21 <Philonous> You have a point there
10:15:34 <merijn> And not be automatable from cabal as easily
10:20:40 <fizruk> _sras_: I don't really know digestive-functors, but it can be possible I guess
10:21:23 <_sras_> fizruk: If it is possible, that would be really amazing...
10:24:30 <bonz060> Hi people!
10:24:47 <lyxia> hi
10:27:05 <_sras_> fizruk: Is there a way using lenses, to add/modify a description of a path/method pair inside a Swagger value?
10:28:14 <_sras_> fizruk: I have something atrocious like this now. http://lpaste.net/355656
10:39:11 <fizruk> _sras_: yes, to peak into an endpoint (called operation in Swagger terminology) see Data.Swagger.Operation
10:39:48 <fizruk> _sras_: if you're using servant-swagger, see also subOperations from Servant.Swagger
10:40:26 <fizruk> _sras_: subOperations allows you to select endpoints of a subAPI within a Swagger spec of an API
10:40:44 <fizruk> _sras_: it's easy and safe
10:40:46 <_sras_> fizruk: Yes. Will look.
10:47:25 <fresheyeball> what is the easiest way to ping a host in haskell
10:47:33 <fresheyeball> more or less like the ping command in bash
10:47:43 <fresheyeball> I just want to know if the host is reachable at all
10:48:35 <Athas> fresheyeball: it may be reachable, but not listening to pings.
10:48:53 <Athas> The easiest solution is to use System.Process to launch the 'ping' program, but that's not portable.
10:48:57 <fresheyeball> sure, but I think that is the bestI can do
10:49:16 <sproingie> open a tcp connection to it.  if you get a connection or even "connection refused" it's up
10:49:31 <sproingie> ping itself uses icmp and has to be setuid root, it's yuck.
10:49:47 <sproingie> s/up/reachable/
10:49:52 <fresheyeball> I'm used to using servant for communication have not touch the low level
10:50:57 <Athas> fresheyeball: you need to handle the case where the host goes down after your initial check anyway, so is there value in doing an initial check at all?
10:51:15 <Athas> This is like checking whether a file exist, then trying to open the file.  You still need to check whether the open succeeds.
10:51:23 <sproingie> host availability isn't exactly that kind of race condition
10:51:24 <fresheyeball> Athas: I'm just writing an integration test service
10:51:42 <fresheyeball> so I just want to check connectivity at the start of the tests
10:52:43 <Athas> I think sproingie's suggestion is the best (opening a TCP connection).
10:52:49 <Athas> But you still need to handle the host going down later.
10:52:57 <sproingie> that said i'd just run a really "sanity" test that involved opening a connection
10:53:03 <fizruk> _sras_: looked at digestive-functors
10:53:04 <sproingie> and make all the other tests dependent on that passing
10:53:11 <fresheyeball> Is there a package you recommend for opening a simple tcp connection?
10:53:29 <fresheyeball> yeah this is just a sanity check
10:53:40 <_sras_> fizruk: Found something?
10:53:44 <fizruk> _sras_: apparently conditions and checks are just haskell functions
10:53:55 <sproingie> test sanity first, if that fails, skip all other tests
10:54:15 <fizruk> _sras_: so you can't derive restrictions for Swagger Schema for those
10:54:44 <sproingie> program sanity that is.  should probably test programmer sanity too, but i don't know how to automate that :)
10:55:17 <fresheyeball> https://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html
10:55:19 <fresheyeball> this looks good
10:55:21 <monochrom> Fortunately, dailywtf can be your reference for programmer sanity :)
10:55:28 <fresheyeball> but I can't tell what happens if the connection fails
10:55:30 <_sras_> fizruk: Yes. But every `Form` has a bunch of possible errors inside it. Like "Field x should be less than 10" which are displayed when a validation fails. If I can get all possible such errors for a filed, I think that should be enough..
10:55:37 <sproingie> eh.  i think programming at all tends to make one's sanity suspect
10:56:03 <fizruk> _sras_: as a part of description you mean?
10:56:14 <_sras_> fizruk: Yes.
10:59:20 <fizruk> _sras_: ah, those errors are not statically available
10:59:33 <fizruk> _sras_: they depend on input
11:00:12 <cocreature> fresheyeball: if you only need the client side, the "connection" package is quite nice
11:00:36 <_sras_> fizruk: How did you figure that out?
11:01:54 <fizruk> _sras_: there's this example in the docs: http://lpaste.net/3766601716326203392
11:02:19 <fizruk> _sras_: see how validate returns Error based on the input it gets
11:03:59 <fizruk> _sras_: also, if you look at FormTree definition you see that (Result v a) (a type that contains Error constructor) only appears in Map constructor like this
11:04:01 <_sras_> fizruk: Yes
11:04:10 <fizruk> _sras_: Map :: (b -> m (Result v a)) -> FormTree t v m b -> FormTree t v m a
11:04:39 <fizruk> _sras_: and you cannot extract Error's from a value of type (b -> m (Result v a))
11:04:58 <_sras_> fizruk: Yes.
11:05:02 <_sras_> See it now
11:07:43 <bloogie> Is it ever the case for any Monad that pure and return are different?
11:08:16 <geekosaur> no
11:08:52 <geekosaur> the current arrangement allows it to be possible, which is a wart because a _lot_ of stuff will break if someone accidentally does make them different
11:09:37 <geekosaur> but the current arrangement is a compromise between history and correctness, intended to make it easier to adapt old code to the new Monad constraints
11:10:14 <bloogie> I saw someone use pure inside IO, is that weird?
11:10:38 <geekosaur> that is: you can currently retrofit an Applicative instance onto an old Monad that lacks one with: instance Applicative MyOldMonad where pure = return; <*> = ap
11:10:38 <pikajude> not really
11:10:41 <pikajude> it's 2 letters shorter
11:11:44 <geekosaur> as for using pure with IO, that is not weird and there are arguments for making that the default arrangement (specifically: we made Applicative a prerequisite for Monad for a reason; using 'pure' instead of 'return' supports that reason)
11:12:06 <geekosaur> but, currently it causes a bit of confusion, again relating to that compromise I mentioned
11:12:07 <ggVGc> isn't pure always "return" in the context of monads?
11:12:16 <pikajude> yes
11:12:17 <ggVGc> I mean, foramlly?
11:12:21 <geekosaur> that was what started this line of discussion, ggherdov 
11:12:21 <geekosaur> er
11:12:26 <geekosaur> that was what started this line of discussion, ggVGc 
11:12:40 <ggVGc> alright
11:12:43 <ggVGc> this confused me "if someone accidentally does make them different"
11:12:43 <pikajude> does ggVGc mean delete everything?
11:12:47 <ggVGc> but now I see "accidentally"
11:12:55 <ggVGc> because, it would be an error to do so, right?
11:13:02 <ggVGc> pikajude: http://ggvgc.com
11:13:09 <bloogie> pikajude: and start editing 
11:13:44 <ggVGc> personally I never use return
11:13:49 <geekosaur> it would logically be an error, but the compiler can;t check it for you because that would also prevent, or at least complicate, the Applicative retrofit I mentioned
11:13:51 <ggVGc> I think pure makes much more sense
11:13:59 <ggVGc> even if the name isn't that great either
11:14:10 <ggVGc> geekosaur: yeah . I understand the discussion now
11:14:15 <bloogie> "makes much more sense" what does this mean?
11:14:26 <geekosaur> it's better than 'return'. I mean we still get newcomers who think 'return' is a control structure
11:14:29 <ggVGc> bloogie: for me personally, "pure" is more what it actually is
11:14:33 <ggVGc> "return" feels awkward
11:14:43 <bloogie> what is it, *actually*?
11:14:49 <EvanR> in parsers, return reads sanely
11:15:08 <geekosaur> I file the naming of 'return' into "cute idea. too cute."
11:15:11 <EvanR> i <- parseNumber; s <- parserString; return (i,s)
11:15:33 <bloogie> geekosaur: but confusing to newbies, no?
11:15:33 <ggVGc> bloogie: in my understanding the identity value of a context
11:15:34 <EvanR> like a control structure
11:15:37 <EvanR> but not
11:15:40 <ggVGc> or, well
11:15:42 <geekosaur> siiigh
11:15:43 <ggVGc> yeah, my theory isn't that strong
11:15:44 <bloogie> ggVGc: isn't that what eta also is?
11:15:48 <ggVGc> I don't know how to express myself
11:16:00 <geekosaur> bloogie, that;s what I said about 3 messages earlier...
11:16:18 <bloogie> geekosaur: heh, sorry
11:16:19 <ggVGc> bloogie: I don't think I have a strong argument for why I prefer pure over return. It just feels more reasonable tome
11:16:35 <ggVGc> I don't understand the reasoning behind naming "return" that
11:16:44 <ggVGc> I mena, I kind of do
11:16:47 <ggVGc> but it doesn't feel right
11:16:48 <EvanR> its what all the cool kids are doing
11:16:50 <Tuplanolla> We should rename `pure` to the even shorter `bye`.
11:17:12 <fizruk> Tuplanolla: "ok"
11:17:21 <Tuplanolla> Also `threadDelay` should be `relax`.
11:17:24 <EvanR> overloaded whitespace
11:18:11 <Tuplanolla> I haven't found a spot for `expandafter` yet though.
11:18:34 <ggVGc> pureM = pure
11:19:27 <monochrom> Did the v and V commands exist in vi before vim?
11:19:33 <ggVGc> no idea
11:19:38 <ggVGc> I'm not that ancient here on earth :)
11:20:05 <monochrom> Because I learned vi 25 years ago, and didn't learn v or V, and if it existed back then, this is very embarrassing.
11:20:06 <ggVGc> I feel dirty every time I use visual mode
11:20:06 <fresheyeball> https://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html
11:20:10 <ggVGc> but I still like having it around
11:20:27 <fresheyeball> `connect "localhost" "8080"` fails with `NoSuchThing`
11:20:36 <fresheyeball> but the servant client there works!
11:20:50 <fresheyeball> AND I'm getting the info for both from the same ClientEnv type
11:20:53 <ggVGc> monochrom: I've been using vim daily for about a decade, but I still learn new embarressing things
11:20:53 <fresheyeball> wtf yo!
11:21:03 <ggVGc> it took me years to learn zz, za, z<cr>
11:21:09 <ggVGc> and since then I use it all the time
11:21:21 <monochrom> Because I have always had to use m ' a to mark a region and call it a (without the aid of highlighting) before I copied and pasted.
11:21:25 <ggVGc> wait, not za
11:21:28 <ggVGc> that's folds and that's crap
11:30:43 <Tuplanolla> People always praise Vim's expressiveness, but I find myself often wishing it was more complete consistent, like Haskell with J syntax.
11:31:30 <Tuplanolla> Complete and consistent.
11:34:54 <Sonolin> yea vim isn't that great on consistency
11:35:00 <Sonolin> I mean, its consistent with itself I guess..
11:35:28 <Tuplanolla> There's no reason not to treat the key binding scheme as a programming language.
11:35:58 <Sonolin> I quite like how qutebrowser does keybindings
11:36:24 <Sonolin> unfortunately it leads to some things not being quite possible due to leaky Abstraction
11:54:12 <MitchellSalad_> hey, is uniplate still the preferred/recommend SYB library?
11:55:42 <glguy> umiplate has been subsumed by lens
11:55:56 <ph88> and for some things you can use GHC.Generics
12:01:43 <eacameron> My memory escapes me. Didn't Michael Snoyman make a library with MonadBracket or something similar?
12:01:49 <eacameron> Recently?
12:04:32 <eacameron> Oh, he added it to foundation. :( I want it! But I'm not using foundation.
12:04:32 <cocreature> eacameron: he wrote a blogpost on it. I haven’t seen a library
12:04:33 <MitchellSalad_> i think that was a blog post about what the type of bracket might be generalized to
12:04:46 <eacameron> I found the post: https://www.fpcomplete.com/blog/2017/02/monadmask-vs-monadbracket
12:06:17 <eacameron> Is foundation gaining a lot of traction then?
12:06:50 <eacameron> I've seen PRs from snoyberg and ndmitchell recently
12:07:34 <MitchellSalad_> last I looked (around when it was first uploaded), the api seemed sloppy
12:08:05 <MitchellSalad_> i mean, what's the point of this... https://hackage.haskell.org/package/foundation-0.0.9/docs/Foundation-VFS.html
12:08:59 <eacameron> :shrug:
12:10:34 <davean> eacameron: Its in the FPCO "group" so you'd always expect PRs from them
12:11:05 <eacameron> davean: You mean fpco has adopted it?
12:12:50 <myhask> hi all, is there a haskell expert who has time to help a beginner for some minutes? :)
12:13:16 <cocreature> myhask: just ask your question directly :)
12:13:28 <MitchellSalad_> myhask: I'm an expert
12:14:21 <myhask> i had my first lecture in functional programming. we are using haskell to develop some code. after about 2 hours of our lecture, we got a task what we have to solve until next week.
12:14:42 <myhask> We have to create a function which return the derivative of an rational function
12:15:03 <Tuplanolla> Is this really an expert-level question, myhask?
12:15:10 <myhask> i don't know ..
12:15:27 <Tuplanolla> Considering it's homework the answer is no.
12:15:40 <myhask> yeah, but no one knows how to solve that ..
12:15:56 <eacameron> Tuplanolla: I can imagine PhD homework that would be expert ;)
12:16:05 <myhask> the lecture was very confusing ..
12:17:00 <james999> myhask: what country are you in?
12:17:07 <myhask> germany
12:17:29 <james999> ah ok i didn't think that many ppl there spoke eng
12:18:48 <myhask> MY current code:
12:19:18 <myhask> data Term = Monom(Int, Int)
12:19:19 <myhask>             | Addition[Term] deriving Show;
12:19:26 <myhask> diff :: Term -> Term
12:19:26 <myhask> diff (Monom(a,b)) = if b>0 then Monom(a*b, b-1) else Monom(0,0)
12:19:32 <myhask> diff (Addition(x:xs)) = diff(x)
12:19:38 <cocreature> myhask: please use http://lpaste.net/ and only post the link here
12:20:12 <myhask> https://thepasteb.in/p/oYhlWXr5POZfZ
12:20:14 <james999> also i hate to be the buzzkill here, but this homework q is so ivory tower
12:20:17 <davean> myhask: thats just symbolic differentiation?
12:20:20 <Tuplanolla> Are the anti-spam measures less stringent these days?
12:20:30 <james999> how often do you do symbolic differentiation in practice
12:20:30 <myhask> yes, symbolic differentiation
12:20:41 <Tuplanolla> I've seen less people getting kicked out for pasting code lately.
12:20:57 <davean> myhask: Its a very well explored area, I'm not sure what you mean "no one knows how to solve that"
12:21:04 <davean> myhask: its solved all over the place
12:21:30 <shapr> james999: I think only when you do math
12:21:38 <myhask> no one in my class.. i know a lot of people already solved that, but using code whats not allowed for use
12:21:57 <geekosaur> Tuplanolla, that is something that is pretty much impossible to automate
12:22:07 <geekosaur> it was tighter than that some time back.
12:22:10 <JakePeralta> hi
12:22:13 <davean> myhask: you know how to do a symbolic derivative, right?
12:22:18 <geekosaur> people using evalbots were getting kicked
12:22:23 <myhask> sure
12:22:35 <davean> myhask: Then I'm confused as to what your question is
12:22:45 <davean> myhask: theres ways to make it prettier
12:22:53 <shapr> My 300 person employer makes money entirely off doing derivatives of audio.
12:23:05 <davean> myhask: are you asking how to make it not need special encoding?
12:24:42 <myhask> using GHCI and calling "diff(Addition([Monom(1,2), Monom(2,3)]))", it returns "Monom(2,1)", but i would like to see "Monom(2,1),Monom(6,2)"
12:25:48 <davean> what is Monom?
12:26:16 <pgiarrusso_> Monom(a, b) represents monomial a * x^b, right?
12:26:23 <myhask> yes
12:26:52 <pgiarrusso_> myhask: diff (Addition(x:xs)) = diff(x) seems wrong, why?
12:27:07 <pgiarrusso_> and explains why diff(Addition([Monom(1,2), Monom(2,3)])) does not work
12:27:31 <myhask> that's what i don't know and would like to learn -.-
12:27:57 <pgiarrusso_> I think you might want diff (Addition (xs)) = Addition (map diff xs)
12:28:19 <myhask> map keyword is not allowed to use :O
12:28:29 <davean> map isn't a keyword
12:29:04 <pgiarrusso_> myhask: sorry, I read up on your description
12:29:15 <pgiarrusso_> does your task say to not use map?
12:29:31 <davean> ... in which case does it say not to use fmap?
12:29:45 <pgiarrusso_> that's cheating
12:29:56 <davean> pgiarrusso_: its implimenting it with quality :-p
12:30:24 <myhask> the only "keywords" we learned are: [], head, tail, let, where, nameles functions, type, data
12:30:34 <myhask> all other "keywords" or functions are not allowed
12:30:49 <pgiarrusso_> you're using (x:xs), seems like that's forbidden
12:30:56 <davean> myhask: none of those are keywords, and its important they aren't keywords, but at least we understand the requirements now :)
12:31:16 <davean> myhask: So, its ugly but you can impliment map with that
12:31:28 <davean> you just need to use head and tail
12:31:31 <davean> and recuse
12:31:37 <pgiarrusso_> myhask: they taught you recursion also?
12:31:42 <myhask> yes
12:32:07 <myhask> but only 1 simple example
12:32:29 <pgiarrusso_> OK, given you had 2 hours of Haskell, maybe the next thing you should do
12:32:42 * shapr recuses himself
12:32:46 <pgiarrusso_> is implement mapDiff :: [Term] -> [Term]
12:33:10 <pgiarrusso_> mapDiff should take a list of terms and return a list of differentiated terms
12:33:39 <pgiarrusso_> if the example was a recursive function on lists, this one is probably going to be similar
12:33:46 <pgiarrusso_> would you paste the example you got?
12:34:11 <myhask> this one? diff(Addition([Monom(1,2), Monom(2,3)]))
12:34:16 <pgiarrusso_> myhask: just to phrase the answer in terms close to what you learned
12:34:21 <pgiarrusso_> no, I mean the example of recursion
12:34:48 <pgiarrusso_> recursive functions on lists are similar
12:34:58 <myhask> ok, moment
12:35:02 <pgiarrusso_> (An important class of recursive functions)
12:36:27 <myhask> https://thepasteb.in/p/76hE7mAw4OKCV
12:38:00 <pgiarrusso_> myhask: OK, mapDiff is somewhat similar to len0 there
12:38:22 <mniip> huh
12:38:26 <mniip> len0 is not strict in n
12:38:30 <mniip> you get no gain
12:38:46 <pgiarrusso_> mniip: he got 2 confusing hours of Haskell
12:38:52 <mniip> ah alright
12:39:00 <pgiarrusso_> as a skeleton, I'd use
12:39:01 <pgiarrusso_> mapDiff [] = ?
12:39:21 <pgiarrusso_> mapDiff x : xs = ... x ... mapDiff xs ...
12:39:32 <pgiarrusso_> those on the right are placeholder where to put code
12:40:13 <pgiarrusso_> and now, you want to write mapDiff so that it creates a new list, where each x was transformed with diff
12:40:47 <byorgey> pgiarrusso_: need parens around (x : xs)
12:40:49 <myhask> yes, it's still confusing :O
12:40:51 <pgiarrusso_> myhask: my idea is to use mapDiff to implement diff (Addition xs)
12:41:08 <pgiarrusso_> byorgey, you're right, sorry
12:41:23 <pgiarrusso_> mapDiff (x : xs) = ...
12:41:48 <pgiarrusso_> myhask: don't worry, that's normal...
12:42:10 <pgiarrusso_> first, did they actually explain len0? Probably not well I guess
12:42:37 <mniip> whoever wrote that len0...
12:42:51 <myhask> len0 is to count the number of elements of a list
12:43:10 <pgiarrusso_> myhask: good, but can you explain (to yourself) how it works?
12:44:24 <myhask> yes, when i see the code, i can understand what happens and why
12:44:34 <pgiarrusso_> myhask, BTW: I'm not sure what your doubts are, so feel free to explain what is clear and what isn't
12:45:00 <Guest10> Is there a type class for "flipped" profunctors (covariant in first type argument, contravariant in the second)?
12:45:53 <myhask> Ok, looking at this example, i don't know how to "call" the function diff for all elemnts of x:xs
12:45:53 <myhask> diff (Addition(x:xs)) = diff(x)
12:46:04 <pgiarrusso_> myhask: BTW, let me add that diff (Monom(a,b)) = if b>0 then Monom(a*b, b-1) else Monom(0,0) is correct :-)
12:46:11 <pgiarrusso_> myhask: OK, good question.
12:46:45 <pgiarrusso_> But you call it on x, right?
12:47:00 <pgiarrusso_> you did that already, indeed
12:47:38 <pgiarrusso_> myhask: in my template, I wasn't clear probably
12:47:43 <pgiarrusso_> when I write mapDiff x : xs = ... x ... mapDiff xs ...
12:47:49 <pgiarrusso_> sorry
12:48:01 <pgiarrusso_> mapDiff (x : xs) = ... x ... mapDiff xs ...
12:48:34 <pgiarrusso_> I mean that the code after the equal (the right hand side of the equation) uses mapDiff xs
12:49:15 <pgiarrusso_> myhask: because the idea is that, to call diff on all elements of x : xs, you call it on one element x
12:49:33 <pgiarrusso_> and then you call some helper function (mapDiff)
12:49:35 <lyxia> Guest10: that doesn't sound very useful
12:50:07 <pgiarrusso_> myhask, and that helper function calls diff on all elements of xs
12:50:22 <myhask> how do i have to extend my code?
12:50:52 <Guest10> lyxia: Useful-ish if you want to have a `Contravariant` instance on the partially applied type constructor? But yeah, agreed, just wanted to make sure I wasn't saying something technically incorrect to a friend I'm helping
12:51:02 <pgiarrusso_> let me try one more hint before the solution:
12:51:31 <pgiarrusso_> one thing you can write (though it's not the right one)
12:51:34 <pgiarrusso_> is
12:52:02 <pgiarrusso_> mapToZero [] = []
12:52:13 <pgiarrusso_> mapToZero (x : xs) = Monom(0,0) : mapToZero xs
12:53:13 <pgiarrusso_> myhask: this function transforms all elements of the input list, by replacing each with Monom(0, 0) (a stupid transformation, yes, sorry I don't have a better example).
12:53:39 <myhask> hm..
12:53:49 <pgiarrusso_> Then you can write (again, not correct)
12:53:50 <pgiarrusso_> diff :: Term -> Term
12:54:00 <pgiarrusso_> iff (Monom(a,b)) = if b>0 then Monom(a*b, b-1) else Monom(0,0)
12:54:02 <pgiarrusso_> sorry
12:54:04 <pgiarrusso_> diff (Monom(a,b)) = if b>0 then Monom(a*b, b-1) else Monom(0,0)
12:54:16 <lyxia> Guest10: Okay. I don't know of any standard one.
12:54:19 <pgiarrusso_> diff (Addition xs) = Addition (mapToZero xs)
12:54:48 <pgiarrusso_> myhask: this is *not* the solution (you need mapDiff instead)
12:54:55 <pgiarrusso_> but it's close
12:55:00 <pgiarrusso_> and you can run it and see what it does
12:55:40 <pgiarrusso_> what matters is that mapToZero xs does something for each element of xs by calling itself recursively
12:56:01 <myhask> ok, i run this code..
12:56:11 <Guest10> lyxia: Thanks! By the way, do you know if anything would go wrong if you could do things like `instance Contravariant (_ -> b) where ...`? My feeling is that it would be consistent but resolution might be tough
12:57:13 <myhask> load failed due to "variable not in scope: mapToZero "
12:58:10 <lyxia> Guest10: I haven't thought about this before, but that sounds pretty interesting.
12:59:44 <pgiarrusso_> myhask, ah wait
12:59:58 <pgiarrusso_> did you give first the definition of mapToZero I typed?
13:00:09 <pgiarrusso_> mapToZero [] = []
13:00:09 <pgiarrusso_> mapToZero (x : xs) = Monom(0,0) : mapToZero xs
13:00:22 <byorgey> Guest10, lyxia: that opens a giant can of worms.  type-level lambdas can make type inference undecidable.  Also, Scala allows this kind of notation at the term level and it is terrible because you have to introduce all sorts of heuristics to determine the scope
13:00:26 <Darulo> hello
13:00:32 <Darulo> i was wondering
13:00:35 <pgiarrusso_> only then you can try to define diff, because it uses mapToZero
13:00:38 <Darulo> what is haskell
13:00:42 <myhask> ah, ok. i added this definition and now i compiles
13:00:47 <pgiarrusso_> myhask +1
13:01:00 <byorgey> Darulo: Haskell is a programming language
13:01:11 <byorgey> Darulo: https://www.haskell.org/
13:01:30 <myhask> we are coming closer :) im getting 2 results back :)
13:01:39 <pgiarrusso_> myhask, what's important is that you understand the idea
13:02:11 <Guest10> byorgey: Thanks for the response! To be clear, is the `_ -> b` notation the problem or would a type-level lambda notation make scope simple to determine?
13:02:21 <Darulo> byorgey , what sets haskell apart for all the other programming languages
13:02:47 <pgiarrusso_> myhask, but those results are the wrong Monom, they are Monom(0,0)
13:03:06 <pgiarrusso_> also, mapToZero does not call diff
13:03:13 <byorgey> Guest10: using underscores for implicit lambda arguments causes scope problems.  If you had a notation like  (\a => (a -> b))  that wouldn't have scope problems, just the usual problems with type-level lambdas
13:03:36 <pgiarrusso_> but you want mapDiff to call diff
13:03:44 <myhask> ok, so i have to replace "Monom(0,0)" with "diff(x)"?
13:03:50 <Darulo> byorgey , what sets haskell apart for all the other programming languages
13:03:52 <pgiarrusso_> myhask, yep
13:04:00 <ertes> Darulo: put with as few technicalities as possible: it puts a lot of emphasis on principled abstractions and makes them exceptionally cheap, both in terms of code size and performance
13:04:02 <byorgey> Darulo: it is functional, lazy, and strongly typed
13:04:20 <Darulo> like perl
13:04:21 <pgiarrusso_> (you can write it diff x instead of diff(x) BTW)
13:04:24 <lyxia> Guest10: You have to give up the fact that `f a ~ g b` implies `f ~ g` and `a ~ b`, I can't imagine working without that.
13:04:58 <myhask> it works!!
13:05:00 <ertes> Darulo: abstractions not in terms of "hide this thing and make a safe interface", but in terms of: "these things are instances of this common concept, so we can stop repeating ourselves"
13:05:04 <myhask> thank you very much!!
13:05:09 <ertes> Darulo: so it's not the perl kind of "abstraction"
13:05:25 <Guest10> byorgey: OK, got it! Is it different in kind to type inference problems with GADTs or RankNTypes, or similar?
13:05:27 <pgiarrusso_> myhask: I'm happy it helped
13:06:19 <Guest10> lyxia: Oh wow! Could you say a little bit more about why or point me somewhere where I can find out?
13:07:44 <byorgey> Guest10: it's worse.  What lyxia said.
13:07:49 <shapr> I guess Darulo was unimpressed.
13:08:11 <byorgey> I am not at all clear whether Darulo was genuinely curious, or trying to troll
13:08:18 <myhask> @pgiarrusso_ So the logic is: we create an empty variable "map to zero" and calculate the diveration by and resursive function
13:08:18 <lambdabot> Unknown command, try @list
13:08:19 <ertes> me neither
13:08:28 <byorgey> *shrug*
13:08:29 <shapr> byorgey: I think he ended up in the wrong channel entirely.
13:08:38 <myhask> pgiarrusso_: right?
13:08:38 <ertes> but if they were trying to troll, we resisted very well =)
13:09:11 <shapr> We've had a surprising number of people who just joined all the largest channels on this irc network, and have no idea.
13:09:42 <pgiarrusso_> myhask, well, "mapToZero" wasn't a great example... and not sure what's the diveration (differentiation?)
13:10:01 <pgiarrusso_> but well, the recursive skeleton is the important part
13:10:36 <lyxia> Guest10: you have "(_ -> b) a = (a -> _) b", and now you can't just decompose the application.
13:11:05 <pgiarrusso_> to do something on all elements of a list, you write your recursive function
13:11:12 <pgiarrusso_> f [] = something
13:11:18 <myhask> pgiarrusso_ thanks again for your help! i spent about 5 hours to solve this "little problem".. i'll try to understand it tomorrow..
13:11:22 <pgiarrusso_> f (x : xs) = do something with x, and f xs
13:11:38 <Guest10> lyxia: Ah right, of course. Would there maybe be an equivalent to pattern synonyms / views that could avoid this?
13:11:57 <pgiarrusso_> myhask after only two hours I'm not surprised
13:12:14 <ertes> perhaps it was a bot that was running an algorithm to populate its facts database:  join #x, say: "what is x?", wait for "x is an A", respond "what sets x apart from other A?", collect responses, leave, repeat with a different x
13:12:32 <myhask> pgiarrusso_ yes, but my prof says he'll evaluate our results..
13:12:42 <pgiarrusso_> myhask, I'd recommend trying to work with others (students, teachers, ...) if you can somehow...
13:12:47 <pgiarrusso_> ah right, that's homework
13:13:15 <pgiarrusso_> still, you need some chance to practice with others sitting next to you, so you can help each other
13:13:34 <myhask> pgiarrusso_ yes, but as you said, it's hard to solve such an excercise after only 2 hours of lecture
13:14:01 <pgiarrusso_> this course seems a bit too fast, but I won't second-guess teachers with so little info
13:14:49 <Guest10> (Looks like type lambdas could exist in instance heads without such severe undecidability: https://link.springer.com/chapter/10.1007/978-3-319-39110-6_4)
13:15:15 <myhask> pgiarrusso_ thanks again! i'll leave this channel now! bb
13:16:50 <Ulrar> So, dumb question, how do I use writeIORef ? Seems like it wants an IO Integer, so I need to add IO to my Integer ?
13:17:19 <ertes> :t writeIORef
13:17:21 <lambdabot> error:
13:17:21 <lambdabot>     • Variable not in scope: writeIORef
13:17:21 <lambdabot>     • Perhaps you meant ‘writeSTRef’ (imported from Data.STRef)
13:17:27 <ertes> :t Data.IORef.writeIORef
13:17:28 <lambdabot> GHC.IORef.IORef a -> a -> IO ()
13:17:49 <ertes> Ulrar: do you understand this type signature?
13:17:51 <Ulrar> Yeah, that's not what the doc says
13:18:03 <Ulrar> Still : Expected type: IO Integer
13:18:09 <ertes> it probably is, but without the "GHC.IORef."
13:18:11 <lyxia> Guest10: oh, good find!
13:18:20 <ertes> Ulrar: do you have code that fails?
13:18:25 <Ulrar> Oh, wait.
13:29:34 <WarmCookie> Applying two arguments (your reference and the val to write) as in `writeIORef foo val` is supposed to give you an action of type :: IO ()
13:30:05 <glguy> (Functions are applied to arguments)
13:30:44 <WarmCookie> s/Applying/Supplying/
13:32:01 <Ulrar> Yeah it's my bad, looked at it again and I realised I actually changed a bit of code, and line numbers changed
13:32:07 <Ulrar> I was looking at the wrong line for that error :)
13:32:33 <byorgey> Guest10: oh, interesting indeed.  I wasn't aware of that paper.
13:32:54 <WarmCookie> Ulrar: Any way we can help with the line that's bogus then?
13:35:31 <geekosaur> (also, it's incorrect, twcc dropped one world sports for it. but their sked says all three scheduled games are oostende-anderlecht...)
13:39:45 <Tuplanolla> Foreign code question: is `void (*)(void*, int*)` equivalent to `void (*)(void* restrict, int* restrict)`?
13:41:07 <monochrom> Yes.
13:41:28 <james999> "foreign code"... o_0
13:41:40 <Ulrar> WarmCookie: Figured it out, I was using map instead of mapM
13:41:40 <monochrom> For type sigs. But I think you mean type sigs.
13:41:55 <Ulrar> Made a lot more sense when I realised the line with the actual problem
13:43:19 <Tuplanolla> Yes. I wasn't sure how `void*` aliases other pointers.
13:43:24 <ReinH> Ok, who is Guest10?
13:43:59 <monochrom> Actually this one is "in type sigs, parameter names are optional"
13:44:26 <Tuplanolla> How is that related?
13:44:51 <monochrom> Hrm, I guess I am wrong. I thought "restrict" was parameter name. Is it a keyword?
13:44:54 <Guest10> ReinH: ?
13:45:08 <geekosaur> monochrom, remember ritchie's "noalias must go"? he lost
13:46:32 <ReinH> Guest10: just wondering if you usually go by a different name
13:46:58 <geekosaur> (restrict means the pointer is "guarateed" not to be an alias, which in this case means the memory referenced by the (void *) will not overlap that of the (int *)
13:47:01 <ReinH> other than, you know, guest
13:47:07 <Guest10> ReinH: No, I don't use IRC. Just visiting :)
13:47:13 <ReinH> Ok :)
13:47:40 <geekosaur> or at least that the compiler is free to generate code with that assumption
13:48:24 <monochrom> Then I don't know whether the two type sigs are equivalent. But I know that Haskell FFI doesn't know the difference. No such concept there.
13:48:47 <geekosaur> anyway I think there is no guarantee given by the FFI that that is true, so I would not expect you can say those are equivalent
13:49:16 <monochrom> Hell, it is not even going to tell apart int* and void*
13:49:25 <geekosaur> I mean, the ffi doesn't check that you didn't use castPtr to pass the same array as both parameters
13:49:31 <geekosaur> so it can't assert "restrict"
13:49:44 <glguy> Tuplanolla: Is the question if the calling convention is the same for those two types of function pointers?
13:49:51 <geekosaur> that said, note that "restrict" is an optimization hint, not a storage modifier
13:50:17 <geekosaur> the calling convention does not change, all it does is tell the compiler it can make some otherwise questionable optimizations
13:50:36 <Tuplanolla> I was just wondering if it's safe to treat the the same, like the case of `void (*)(long int*, int*)` and `void (*)(long int* restrict, int* restrict)`.
13:50:54 <monochrom> Haha, the open problem of static analysis of C has been closed by human annotation.
13:51:11 <geekosaur> now, if the actual question is "can I call a function declared that way?", the answer is "yes, but it;s on you as the caller to make sure the (void *) and (int *) are not overlapping"
13:51:14 <glguy> Tuplanolla: It's safe import them and use them from the Haskell FFI the same way
13:51:31 <Tuplanolla> Okay, great.
13:54:29 <EvanR> i see how you can memoize function results using recursion, but is it also possible to forget using recursion, depending on the memoization and current input?
13:54:40 <bonz060> Just a very random question. I'm sort of new here. Why is haskell so amazing?
13:54:43 <EvanR> i.e. undo the memoization to save space
13:55:05 <monochrom> Haskell is not amazing. But I like Haskell anyway.
13:55:14 <monochrom> No programming language is amazing. Period.
13:55:47 <Ronja2> can anyone help me with the differentiation of a product?
13:55:47 <EvanR> the haskell project and ghc is kind of amazing
13:55:51 <monochrom> Do not be so easily amazed. Lest I could amaze you by simply running a fizzbuzz program.
13:55:56 <glguy> I mentioned it earlier, but maybe someone will find this neat, its a browser-based demonstration of my config-schema package that compiles either to javascript via ghcjs or an app bundle for mac via ghc: https://github.com/glguy/config-app/blob/master/Main.hs https://glguy.net/~pi/result/ (the app bundle half is new since last time I mentioned it)
13:56:09 <Ronja2> I already got help from the community concerning the differentiation of a sum, now I am struggling again :(
13:57:58 <byorgey> EvanR: https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Mem-Weak.html
13:58:37 <byorgey> EvanR: though that doesn't really give you control over what gets deleted when
13:59:14 <Mibaz> Trying to learn FRP. Want to avoid arrows. Tried Netwire but I was told it was deprecated. Are wires and reactive-banana the two implementation options currently?
13:59:38 <koala_man> tbh, even fizzbuzz is amazing. we shouldn't take computers for granted.
13:59:53 <byorgey> Mibaz: there's also reflex and frpnow
13:59:55 <EvanR> byorgey: right... i mean i could also unsafePerformIO over an MVar too
13:59:58 <monochrom> Ah, next time I'll try Eliza instead.
14:00:57 <byorgey> EvanR: ok, right.  Well, I'm not sure I understand well enough what you mean by "memoize using recursion" to answer your real question then.
14:01:28 <EvanR> https://wiki.haskell.org/Memoization memoized_fib on this page
14:01:30 <Mibaz> byorgey: thanks!
14:02:21 <EvanR> im sure if i understood how this memoized fib worked i could answer my own question
14:02:31 <Mibaz> If anyone has preferences on banana / wires / reflex / frpnow please let me know so I don't waste a bunch of time again ;)
14:02:48 <byorgey> EvanR: ok, then no, it's not possible to undo memoization in that case.  It works by creating an infinite table of all results, and evaluating it lazily.
14:03:01 <byorgey> Lazily evaluated things only ever become more defined, not less.
14:03:02 <EvanR> interesting
14:03:27 <EvanR> this kind of ties into another thing, undoing lazy evaluation, returning thunks to an uncomputed state (to save space0
14:03:33 <EvanR> trade space for time
14:04:01 <kadoban> Mibaz: reflex is cool as hell, I haven't used any of the others. I looked at reactive banana briefly, but didn't really do anything with it.
14:06:40 <Mibaz> kadoban: it does look cool. Just glancing at the platform readme I don't see any types more than 3 lines long so that's already an improvement 
14:06:54 <EvanR> how to turn a boiled egg back into a raw egg ;)
14:07:20 <EvanR> haskell analogies ftw
14:08:16 <monochrom> nanotechnology could go in, repair the proteins, and rejuvenate the egg again.
14:09:32 <Mibaz> frpnow doesn't look that well tutorial-ed for someone like me so I'll go Reflex. Wires barely has documentation
14:09:44 <hexagoxel> Mibaz: i am familiar with reflex and reactive-banana. imho banana is better for getting familiar with frp, while reflex seems a bit more "lower level".
14:09:50 <Mibaz> monochrom: How does this fit into the monad burrito?
14:10:54 <monochrom> It doesn't.
14:10:58 <hexagoxel> reflex tutorials are focused on web dev, but reflex+reflex-host are very similar to the reactive-banana interface; you can almost mechanically translate between the two in many cases.
14:11:57 <hexagoxel> (i.e. reflex is not limited to web-dev at all)
14:12:22 <Mibaz> hexagoxel: Got it. Is reflex the library actually organized around web dev or just the community? 
14:12:50 <hexagoxel> for the most part, the web-dev part is in reflex-dom.
14:13:19 <fresheyeball> Mibaz: reflex itself is just a library for reactivity
14:13:23 <fresheyeball> but its mostly used for web dev
14:13:33 <hexagoxel> although reflex-dom also contains some helper functions that have there uses for general-purpose UI dev.
14:14:06 <Mibaz> hexagoxel: fresheyeball: cool I just wanted to make sure it was general-purpose. 
14:14:22 <ertes> nitpick: the API of reflex is actually very different from reactive-banana, but both are general purpose FRP libraries
14:14:48 <fresheyeball> ertes: frp-zoo ftw
14:14:55 <EvanR> heh
14:15:05 <hexagoxel> ertes: because reflex has Dynamic?
14:15:10 <EvanR> which is mostly js frpish things
14:15:29 <fresheyeball> EvanR: what is?
14:15:33 <EvanR> frp-zoo
14:15:43 <fresheyeball> its all haskell no?
14:15:46 <Mibaz> I also want to avoid arrows after being warned away. I didn't see any arrows on the Readme, but Reflex doesn't use them heavily, does it?
14:16:14 <fresheyeball> Mibaz: I see RecursiveDo in reflex, and not really Arrows
14:16:17 <EvanR> this is a different frp zoo
14:16:19 <ertes> hexagoxel: no, the controller interface is very different…  reactive-banana is very much designed for callback-based toolkits, while reflex makes no such assumption and is more likely used in a "main loop" kind of way
14:16:35 <EvanR> what was i thinking of
14:16:53 <monochrom> frp botany?
14:17:10 <ertes> hexagoxel: in other words: reactive-banana takes control, and events fire by callbacks, while with reflex you fire the events imperatively within the loop
14:17:33 <fresheyeball> ertes: with Reflex how do you fire events?
14:17:43 <ertes> Mibaz: both are arrow-free
14:17:55 <ertes> "free" in the sense of "without" =)
14:18:13 <ertes> fresheyeball: you use the fireEvents* functions from Reflex.Host.Class
14:18:31 <Mibaz> fresheyeball: ertes: arrow-without, excellent!
14:19:20 <ertes> fresheyeball: reflex gives you an explicit state-machine-like interface
14:19:20 <fresheyeball> I've not used Arrows, but I hear people complain about them
14:19:24 <fresheyeball> what is so wrong with Arrows?
14:19:32 <hexagoxel> ertes: even with reflex-host? reactive-banana's newAddHandler is the same as reflex-host's newExternalEvent
14:20:13 <ertes> fresheyeball: they are inconvenient, and values (results/inputs) in arrows are not actually first class, but arrow notation pretends that they are
14:20:22 <ertes> hexagoxel: i'm not really familiar with reflex-host
14:20:27 <ertes> i use reflex directly
14:21:18 <hexagoxel> ertes: yeah, well. when just comparing reflex to reactive-banana, i'd probably agree with your assessment.
14:22:42 <lifter> Is it common for people to essentially throw an unhandled exception for pattern match cases that they would consider to be "impossible" cases?
14:23:13 <monochrom> I would do that.
14:23:24 <glguy> Are you people?
14:23:27 <lifter> I guess I'm asking if doing so is a code smell.
14:23:45 <monochrom> I am people. :)
14:23:48 <lifter> glguy: Are you asking me?
14:23:53 <glguy> monochrom
14:24:12 <lifter> By "people" I just mean "Haskell programmers."
14:24:17 <monochrom> I am Caesar. Caesar does represent "people" in "senate and people of Rome" :)
14:24:19 <Tuplanolla> It depends on how impossible we're talking about here, lifter.
14:24:38 <tommd> I see it frequently.  Some people take this as motivation to rework types, add a GADT, etc.
14:25:02 <lifter> OK
14:25:55 <monochrom> To be sure, I would also review "is there a better way?". But often there is no significantly better way.
14:26:06 <lifter> Right.
14:26:16 <glguy> It'd be easier to give feedback if you had a particular example in mind. Otherwise it's up to everyone's imagination to determine what impossible means
14:27:33 <lifter> I'm afraid I don't have a specific example at the moment. Sounds like it's rather case-by-case, and that makes sense.
14:28:13 <monochrom> I don't think in terms of "code smell". I don't understand what the hell it is.
14:28:31 <jle`> lifter: by throw an exception, do you mean leave a case branch as undefined/bottom?
14:28:34 <lifter> What the hell what is?
14:28:35 <jle`> like 'error' ?
14:28:35 <monochrom> What I understand is "is perfection worth my time" and "is imperfection worth my time".
14:28:50 <jle`> or do you mean throwing an actual IO exception in IO
14:29:09 <lifter> jle`: Yeah I was thinking of calling "error".
14:29:10 <Tuplanolla> How about "everything is written in French", monochrom?
14:29:23 <monochrom> I don't know French.
14:29:30 <jle`> ah yeah.  "throwing an exception" has a specific meaning in haskell
14:29:32 <monochrom> (But I will go watch Bon Cop Bad Cop anyway.)
14:29:53 <jle`> lifter: in that case if you are sure that the case is impossible, then you can use 'error' with a very good reason why you believe this case is impossible
14:30:15 <jle`> maybe even including a human-readable proof explaining why the case is logically impossible
14:30:43 <jle`> but, in many cases in haskell, you can avoid such a situation by using better types.
14:30:47 <monochrom> Put the proof inside the error message, for maximum potential irony :)
14:30:59 <Tuplanolla> > error "nope" -- Good enough.
14:31:01 <lambdabot>  *Exception: nope
14:31:19 <jle`> in many languages with weaker types, errors like what you describe come up often
14:31:32 <lifter> How about `error "sorry"`
14:31:46 <jle`> but in haskell, 90% of the time, you can have the *compiler* prove that certain cases are impossible, and so you don't need to explicitly handle it
14:31:53 <lifter> Or better yet `error "I'm sorry"`
14:32:04 <monochrom> That's the best error message ever. No one will kill you when you say "sorry" :)
14:32:07 <jle`> but that doesn't mean that there's the few exceptions in haskell where you have to not trust the compiler
14:32:22 <jle`> um no pun intended
14:32:36 <monochrom> oh haha didn't spot that one
14:33:29 <lifter> These days the trend is to serve up error messages with cute mascots and shit, so I guess I ought to consider how to do that. Like "Oops we're sorry something went wrong!" with a pic of a cute bunny or some shit.
14:33:41 <ertes> lifter: throwing exceptions gets rid of the non-exhaustiveness warning, so i do that, too
14:34:00 <lifter> ertes: Yep.
14:34:02 <EvanR> imagine if video games did that
14:34:03 <ertes> lifter: however, sometimes it's possible to handle a case, even if it will never be seen in practice
14:34:15 <ertes> lifter: in that case i prefer to handle the case properly
14:34:19 <EvanR> sorry your save was deleted
14:34:43 <ertes> EvanR: if you consider GHC a video game…
14:34:59 <ertes> GHC had a bug once that deleted your source files, if you had a type error
14:35:02 <EvanR> heh right, the legend that 
14:35:03 <EvanR> yeah
14:35:20 <monochrom> then you can you TH to play a cute bunny video at compile time!
14:35:31 <monochrom> s/can you/can use/
14:36:13 <ertes> "are you stupid?  expected A, inferred B…  try again, idiot!"
14:36:24 <lifter> Haha just searched google images for "cute error messages", it's kind of barfy.
14:36:24 <ertes> that…  reminds me of someone…
14:36:29 <ertes> who was it again?
14:36:31 <ertes> oh yeah!
14:36:33 <ertes> @src fnsiugnsig
14:36:33 <lambdabot> Source not found. My brain just exploded
14:36:53 <ertes> @src fnsiugnsig
14:36:53 <lambdabot> Source not found. Sorry.
14:36:56 <ertes> come on
14:36:57 <ertes> @src fnsiugnsig
14:36:58 <lambdabot> Source not found. Are you on drugs?
14:37:01 <monochrom> Make it cute lamb.
14:37:03 <ertes> there we go
14:37:32 <ertes> i think, we should have made that bug optional
14:37:43 <lifter> Every 404 pg has to have some cute graphic that a designer was paid $500 to make.
14:37:49 <EvanR> put the bug back and make it a flag
14:37:58 <EvanR> haskell hardcore mode
14:38:09 <ertes> -fnightmare
14:38:23 <ertes> -fi-am-death-incarnate
14:38:24 <glguy> It could be like Dark Souls, after the first type error you get one shot to fix the error
14:38:28 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg94712.html
14:38:44 <EvanR> didnt somebody hookup their ghc to twitter, if you fail to check tweet it
14:39:13 <EvanR> publically shaming you
14:40:34 <monochrom> Oh God, that mascot thread degenerated into bringing up GADT.
14:40:54 <ertes> if i did that, i would probably be banned for flooding
14:41:02 <ertes> "Found hole: …"
14:41:04 <ertes> "Found hole: …"
14:41:05 <ertes> "Found hole: …"
14:41:13 <monochrom> A drinking game for Haskell will just need to say "drink when you hear one of: GADT, data kinds, type families".
14:41:34 <EvanR> from the compiler?
14:42:55 <geekosaur> heh
14:43:00 <Hafydd> Drink for each type error.
14:50:48 <ertes> take a shot each time the phrase "you can" is used in a programming language channel, and vomit each time "you can't" is used
14:50:57 <WarmCookie> ertes: -fvia=PHP
14:51:07 <ertes> don't do it too long though…  you might turn into a black hole
14:51:34 <geekosaur> WarmCookie, http://hackage.haskell.org/package/acme-php
14:52:22 <int-e> > "you can" `isInfixOf` "you can't"
14:52:24 <lambdabot>  True
14:52:29 <tosun> When I look at the `Core` AST type for a simple integer declaration e.g., `a :: Integer; a = 1`, I see that the corresponding Core type is a `(TyConApp AlgTyCon ...))` whereas I was expecting it to be a type literal. Can anyone explain why?
14:52:41 <monochrom> ertes, you can't turn into a black hole.  <duck> :)
14:53:00 * ertes vomits
14:53:04 <monochrom> Oh haha good eyes, int-e
14:53:15 <monochrom> This is so fizzbuzz.
14:53:35 <monochrom> "Say fizz when you see 'you can'. Say buzz when you see 'you can't'"
14:53:54 <ertes> int-e: of course…  that's why you will eventually turn into a black hole, because you can never vomit faster than you drink
14:54:16 <ertes> now take a shot!
14:54:27 <monochrom> s/you can never/you can't/
14:54:28 <EvanR> oh god stop
14:55:12 <Tuplanolla> I just calculated the can-to-can't ratio of my logs from this channel.
14:55:29 <Tuplanolla> > 28727 / 6997 :: Double
14:55:31 <lambdabot>  4.105616692868372
14:56:00 <monochrom> That's good news.
14:56:12 <geekosaur> tosun, integer literals are wrapped in fromInteger by the compiler
14:56:45 <geekosaur> this is how you can use he kliteral 1 as Integer or Int or Double or ...
14:57:13 <geekosaur> tosun, https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
14:57:44 <glguy> I think tosun's asking about the representation of the Integer type in core
14:58:33 <tosun> glguy: yes
14:58:57 <geekosaur> but in that case its representation is more or less what I described, no? raw compile to fromInteger @Integer, then with optimization that should hopefully go away
14:59:17 <geekosaur> but without optimization the inner workings get exposed
14:59:33 <glguy> the fromInteger layer lives at the value level
15:04:27 <glguy> tosun: I'm sure sure what you had expected specifically, but all the primitive types in core appear to be introduced with: TyConApp TyCon [Type]
15:04:52 <glguy> and if the particular type constructor has no parameters then it will have an empty list in the second field
15:06:02 <tosun> glguy: thanks. But why isn't it a literal?
15:06:26 <glguy> I don't know what you mean actually
15:06:40 <glguy> What would it look like if the type was a "literal"?
15:07:16 <tosun> glguy: there is a `LitTy` constructor.
15:07:35 <glguy> That's for DataKinds extension
15:07:46 <glguy> You can have the type "Example" with kind Symbol
15:08:20 <glguy> Or the type 10 with kind Nat
15:08:29 <glguy> These types have no values
15:08:48 <glguy> But the type of any Integer, even if its the integer literal 1, is always going to be Integer
15:11:05 <glguy> @kind 1
15:11:06 <lambdabot> GHC.Types.Nat
15:11:21 <glguy> @type (1::Integer)
15:11:23 <lambdabot> Integer
15:12:42 <tosun> glguy: I see, thanks.
15:12:53 <mniip> hmm, curious
15:13:09 <mniip> does ghci do TH splices?
15:13:36 <glguy> hi
15:13:37 <glguy> err, yes
15:18:17 <EvanR> i just wrote (> t) and then suddenly became dyslexic or something, and didnt know whether the symbol was "greater than" or "less than"
15:18:49 <EvanR> its less than t
15:19:06 <glguy> It's greater than t...
15:19:12 <EvanR> uhg
15:19:26 <EvanR> right but the t is on the small side heh
15:19:44 <EvanR> maybe (t <) works better
15:20:45 <EvanR> oh well
15:21:24 <ski> (rarely) sometimes when i'm writing something, i'm suddenly unsure about the spelling of a word which i know i usually know the spelling of ..
15:21:53 <MarcelineVQ> like apricot
15:22:07 <glguy> I get that feeling if I stop to actually think about the letters in the word
15:23:34 <_cyril_> Is https://hackage.haskell.org/package/protobuf the recommended library to encode/decode protobufs in Haskell?
15:23:42 <Tuplanolla> I had that today with "scratch".
15:24:18 <mniip> hmm
15:24:27 <mniip> I guess you can create an unlifted kind
15:24:32 <mniip> but it has no inhabitants
15:38:58 <erisco> ski, well it is not as annoying as my condition where I type completely the wrong word or the wrong conjugation
15:39:34 <erisco> I turned off spell correct but it still haunts my life
16:34:47 <iqubic> How hard is it to create a simpel game in Haskell.
16:36:18 <iqubic> Like how hard would it be create a Tic-Tac-Toe game in haskell?
16:36:28 <lyxia> main = putStrLn "You lost the game."
16:37:17 <iqubic> lyxia, I more wanted a way to save the state of the game.
16:37:20 <monochrom> No harder than soft water.
16:37:21 <ertes> main = do putStrLn "Guess my random integer between 1 and 2!"; getLine; putStrLn "Wrong."
16:37:27 <iqubic> LOL
16:38:56 <iqubic> So how would I update and save the current state of the game?
16:39:22 <ertes> and i *know*, this being #haskell, that at least a few people tried to exploit my number notation to claim that my game is unfair
16:39:38 <aussie> Check out code.world, it supplies a bunch of graphics capabilities for you
16:40:27 <ertes> iqubic: if your game state is a value, you can serialise it to binary (binary/cereal), JSON (aeson), YAML (yaml), etc.
16:41:05 <iqubic> ertes, I don't want to serialize my data. I just want to update it on the fly.
16:41:13 <aussie> How would I convert Just (Just 5) to a single just?
16:41:28 <iqubic> > join Just (Just 5)
16:41:29 <monochrom> consider join
16:41:30 <aussie> I tried "maybe Nothing fromJust" but that gives an error
16:41:30 <lambdabot>  error:
16:41:30 <lambdabot>      • Couldn't match expected type ‘Maybe Integer -> t’
16:41:30 <lambdabot>                    with actual type ‘Maybe a0’
16:41:42 <iqubic> > join $ Just (Just 5)
16:41:44 <lambdabot>  Just 5
16:41:47 <aussie> Ah awesome
16:41:52 <iqubic> Join works
16:42:00 <iqubic> Works for any monad m.
16:42:03 <iqubic> :t join
16:42:04 <lambdabot> Monad m => m (m a) -> m a
16:42:16 <ertes> iqubic: "update"?  in memory?  on disk?
16:43:08 <monochrom> "state" is a red herring.
16:43:12 <iqubic> update in memory
16:43:30 <ertes> iqubic: every time you recursively call a function with a different value, you're "updating"
16:43:51 <ertes> printFrom n = print n >> printFrom (n + 1)
16:44:29 <iqubic> How would you store the current board position of a Tic-Tac-Toe game in Haskell? And how would you update that position when the user makes a move?
16:45:05 <aussie> You could use a small 2D list
16:45:18 <aussie> And then just work off that representation
16:45:19 <monochrom> Instead of "store", you should speak of "represent" or "model", so that you are not stuck in the "state" red herring.
16:45:21 <ertes> iqubic: your board state is a value, right?
16:45:47 <iqubic> Sure. Type position = [[Piece]]
16:45:49 <monochrom> And yeah it is going to be a value.
16:46:07 <iqubic> Data Piece = X | O | Empty
16:46:14 <ertes> iqubic: and your game is a recursive "loop" that takes the current board state as its argument, right?
16:48:18 <iqubic> No. Should it be
16:48:53 <ertes> iqubic: do you have code?
16:50:20 <Logio> iqubic: you would update the board using some function like: move :: Position -> Board -> Board, which takes a given move and the current board and returns the altered board
16:51:08 <Logio> the "game state" at each point is just the Board configuration
16:52:28 <c0d3x> Hi
16:52:39 <monochrom> I seem to remember that a month ago someone asked about representing Tic-Tac-Toe at the type level.
16:54:05 <ertes> type TicTacToe = Ordering -> Ordering -> Ordering
16:55:07 <monochrom> How does that work?
16:55:46 <ertes> type TicTacToe = Maybe (Ordering -> Bool) -> Maybe Bool
16:56:39 <ertes> monochrom: a board is just a function from 2D coordinates to a cell state
16:57:01 <ertes> > [minBound..maxBound] :: Ordering
16:57:03 <lambdabot>  error:
16:57:03 <lambdabot>      • Couldn't match expected type ‘Ordering’ with actual type ‘[t0]’
16:57:03 <lambdabot>      • In the expression: [minBound .. maxBound] :: Ordering
16:57:03 <monochrom> Ah yes.
16:57:12 <ertes> > [minBound..maxBound] :: [Ordering]
16:57:14 <lambdabot>  [LT,EQ,GT]
16:59:32 <jle`> Ordering ~ 3
16:59:47 <jle`> i prefer Maybe Bool
17:00:17 <jle`> or Either () (Either () ())
17:03:59 <ertes> type TicTacToe = (Ordering -> Ordering, Ordering -> Ordering, Either Bool (Bool -> Either Bool Ordering))
17:30:25 <Squarism> can one unload all modules in ghci ? Google only told me for single modules
17:30:37 <Squarism> when i run stack it keeps loading all exposed modules
17:31:03 <geekosaur> the whole point o 'stack ghci' is to build and load all modules, which is hard to do otherwise
17:31:20 <geekosaur> if you want a bare ghci in your stack project, try 'stack exec ghci'
17:31:54 <Squarism> thanks
17:32:02 <geekosaur> (this will however leave you missing e.g. any ffi objects needed, and no good way to load them)
17:32:45 <geekosaur> anyway I suspect something like ':m Prelude' will reset the module list
17:32:51 <geekosaur> seems to here
17:40:53 <athan> Is there a concept in QuickCheck which is like Arbitrary, but for explicit collections of values (a Data.Set for instance, as the thing to choose values from, rather than a type)?
17:41:33 <lyxia> oneof ?
17:42:04 <lyxia> it's not very efficient, you'll have to write your own generator otherwise
17:42:05 <EvanR> elements :: [a] -> Gen a
17:52:38 <bitf> clear
18:04:19 <iqubic> How does QuickCheck work. Is there a guide anywhere. It's a testing suite right. I need on of those for Haskell.
18:08:17 <peddie> iqubic: I googled 'quickcheck examples' and got https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html 
18:09:03 <peddie> @hackage QuickCheck  -- iqubic
18:09:03 <lambdabot> http://hackage.haskell.org/package/QuickCheck  -- iqubic
18:22:33 <vaibhavsagar> can anyone help me create a static executable with stack?
18:22:51 <mjora7> Hey, could someone help me out with a quick question about stack? I'm trying to get a "Hello, world!" project for Scotty working, so I made a new stack project, `stack new hello-scotty; cd hello-scotty; stack setup; stack build;`, now I'm wondering how do I get it to include the scotty package?
18:23:25 <vaibhavsagar> mjora7: edit the hello-scotty.cabal file and add scotty to the "build-depends: "
18:24:17 <mjora7> vaibhavsagar: Ok, there's no way to get a tool to automatically do that by some sort of command? Like in Node.js you can go `npm install scotty --save` and it will install that package and save it as a dependency.
18:25:08 <mjora7> vaibhavsagar: Also, I see three `build-depends:`, one under library, one under executable, and one under test-suite. I guess I put it under executable?
18:25:40 <vaibhavsagar> no, library
18:26:17 <vaibhavsagar> my question has to do with statically linking libpq
18:26:45 <mjora7> vaibhavsagar: Ok. This indentation in the .cabal file is scaring me. Is it just for visual appearances or does it actually matter logically a la python?
18:27:31 <vaibhavsagar> mjora7: I think it's just for show, but here is an example: https://github.com/vaibhavsagar/suppandi/blob/master/suppandi.cabal
18:28:03 <mjora7> vaibhavsagar: Ok cool. So I added my dependency, now I run `stack-build`?
18:28:11 <vaibhavsagar> yup
18:28:43 <vaibhavsagar> are you on #haskell-beginners? it's more active than this channel atm
18:28:54 <mjora7> vaibhavsagar: Nope, I should go there.
18:29:09 <mjora7> vaibhavsagar: I am now!
18:29:22 <vaibhavsagar> yay :)!
18:29:44 <vaibhavsagar> just as long as you know it's there
18:30:54 <mjora7> vaibhavsagar: So I see that you can run your program with `stack exec hello-scotty-exe`, but where does it dump the exe?
18:31:36 <clamchowder> hello
18:31:59 <clamchowder> I have a simple question: say I define a function:
18:32:02 <vaibhavsagar> it's under `.stack-work/install/<os>/<lts>
18:32:17 <clamchowder> f :: Monad m => a -> m a
18:32:17 <Koterpillar> stack path —local-install-root
18:32:29 <clamchowder> f x = return x
18:32:47 <clamchowder> how do I pass the type of m to f?
18:32:50 <mjora7> vaibhavsagar: Hey btw, the build-depends under library didn't work but it did under executable.
18:33:10 <Koterpillar> clamchowder: it will be inferred from the invocation
18:33:22 <vaibhavsagar> mjora7: I forgot to ask if you were using scotty in Main.hs or Lib.hs, you must be using it in Main.hs
18:33:51 <clamchowder> Koterpillar: say at one time I want m to be list, and at another time I want it to be Maybe
18:34:00 <clamchowder> Without any context
18:34:13 <vaibhavsagar> you can add a type annotation
18:34:17 <Koterpillar> clamchowder: annotate it with a type
18:35:24 <clamchowder> Koterpillar: how do I do that
18:35:32 <Koterpillar> either as f 0 :: [Int], or as f @[]; for latter, you'll have to enable an extension
18:35:44 <Koterpillar> > return 0 :: [Int]
18:35:46 <lambdabot>  [0]
18:35:51 <Koterpillar> > return 0 :: Maybe Int
18:35:53 <lambdabot>  Just 0
18:36:06 <jle`> @[] is "literally" passing the type, since it's called a type application
18:36:07 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
18:36:13 <jle`> sorry lambdabot
18:36:20 <Koterpillar> ah yes, TypeApplications
18:36:37 <jle`> it treats f as f :: forall m. Monad m => a -> m a
18:36:42 <jle`> and so like 'm' is an argument
18:37:42 <clamchowder> Koterpillar, vaibhavsagar, jle`: thanks.
18:41:41 <iqubic> But isn't ScopedTypes a pragma you'd need in order to do that?
18:42:11 <iqubic> > return 0
18:42:13 <lambdabot>  error:
18:42:13 <lambdabot>      • Ambiguous type variables ‘m0’, ‘a0’ arising from a use of ‘show_M36851...
18:42:13 <lambdabot>        prevents the constraint ‘(Show (m0 a0))’ from being solved.
18:42:27 <iqubic> > return 0 :: Either String Int
18:42:29 <lambdabot>  Right 0
18:42:54 <iqubic> > join $ Right $ Left 50
18:42:57 <lambdabot>  Left 50
18:43:10 <iqubic> > join $ Right $ Right $ Right 50
18:43:12 <lambdabot>  Right (Right 50)
18:43:18 <mjora7> vaibhavsagar: Ah yes, in Main.hs. What is the difference between Main.hs and Lib.hs? I guess Main.hs is an entry point that has the main function?
18:43:19 <clamchowder> that's weird. in my ghci return 0 gives me 0
18:43:30 <sleblanc> :t join
18:43:31 <lambdabot> Monad m => m (m a) -> m a
18:43:43 <iqubic> > join $ join $ Right $ Right $ Right 50
18:43:45 <lambdabot>  Right 50
18:44:26 <vaibhavsagar> mjora7: yup, and Main.hs is managed by the 'executable' section whereas Lib.hs is managed by the 'library' section
18:44:41 <Koterpillar> clamchowder: I think GHCi is trying to interpret it as IO Int, and runs the resulting action
18:44:50 <geekosaur> ^
18:44:51 <mjora7> Ok
18:45:05 <mjora7> So I guess this means that I should study Cabal in additional to Stack to understand how this all works.
18:45:08 <iqubic> Is there a way to take an m (m (m (m ... a))) and turn it into an m a? So a thing like join that takes an arbitrarily nested monad, an un-nests it?
18:45:17 <jle`> it is ill-typed
18:45:21 <jle`> what would its type be?
18:45:26 <iqubic> I don't know.
18:45:30 <geekosaur> ghc speculatively tries a type as IO x to see if it should run it and produce the result. since that typechecks, it's what ghci does
18:45:33 <jle`> there is no type it could be
18:45:41 <iqubic> I'm thinking that this is similar to lift.
18:45:42 <jle`> so it cannot exist
18:45:44 <Koterpillar> or, each one of those will be a different type
18:45:46 <geekosaur> ghc itself, or wrappers like mueval (what lambdabot uses), will not do that
18:45:57 <iqubic> :t lift
18:45:58 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:46:04 <clamchowder> Koterpillar: ah I see
18:46:22 <Koterpillar> iqubic: if you know how many layers there are, use that many joins
18:46:26 <iqubic> > lift Maybe 1 :: MaybeT IO Int
18:46:28 <lambdabot>  error:
18:46:28 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
18:46:28 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
18:46:36 <Xnuk> @hoogle Network.OAuth.Http.Request
18:46:36 <lambdabot> Network.Wai data Request
18:46:36 <lambdabot> Network.Wai.Internal data Request
18:46:36 <lambdabot> Network.Wai.Internal Request :: Method -> HttpVersion -> ByteString -> ByteString -> RequestHeaders -> Bool -> SockAddr -> [Text] -> Query -> IO ByteString -> Vault -> RequestBodyLength -> Maybe
18:46:36 <lambdabot> ByteString -> Maybe ByteString -> Maybe ByteString -> Maybe ByteString -> Request
18:46:37 <jle`> Maybe is not a data constructor, heh
18:46:38 <geekosaur> er, "ghci speculatively..."
18:46:48 <jle`> iqubic: also 'lift' takes only one argument
18:46:53 <iqubic> > lift $ Maybe 1 :: MaybeT IO Int
18:46:55 <lambdabot>  error:
18:46:55 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
18:46:55 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
18:47:02 <Koterpillar> iqubic: otherwise you can build _something_, but where did you ever get that type?
18:47:13 <jle`> iqubic: there is no data constructor 'Maybe'
18:47:16 <jle`> at least not in any standard library
18:47:18 <iqubic> Koterpillar: I'm just asking abstract questions.
18:47:21 <jle`> or non-standard ones
18:47:25 <iqubic> > lift $ Just 1 :: MaybeT IO Int
18:47:26 <lambdabot>  error:
18:47:27 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
18:47:27 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
18:47:31 <jle`> check the type of lift
18:47:37 <iqubic> :t lift
18:47:39 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:47:39 <jle`> and see why that doesn't work
18:47:42 <Xnuk> Can I find package name with module name?
18:47:56 <iqubic> jle`: What am I doing wrong?
18:48:15 <jle`> you're using MaybeT IO Int as the result
18:48:20 <jle`> so the type of the input is ...?
18:48:44 <jle`> if 't m a' is MaybeT IO Int, what is t, what is m, and what is a ?
18:49:02 <Xnuk> :t lift $ Maybe 1
18:49:03 <lambdabot> error:
18:49:04 <lambdabot>     • Data constructor not in scope: Maybe :: Integer -> m a
18:49:04 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
18:49:14 <Xnuk> :t lift $ Just 1
18:49:14 <jle`> Xnuk: you can use hoogle maybe if you want to search online
18:49:15 <lambdabot> (Num a, MonadTrans t) => t Maybe a
18:49:15 <geekosaur> Xnuk, for installed packages, ghc-pkg find-module
18:49:26 <geekosaur> Xnuk, for packages not installed, hoogle and hayoo can be used
18:49:33 <iqubic> t ~ MaybeT, m ~ IO, a ~ Int
18:49:46 <iqubic> > lift $ IO 1 :: MaybeT IO Int
18:49:48 <lambdabot>  error:
18:49:48 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
18:49:48 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
18:49:51 <jle`> iqubic: yes, so what is the input 'm a' ?
18:49:54 <jle`> IO is not a data constructor
18:50:03 <jle`> IO is an abstract data type
18:50:09 <iqubic> > lift $ read getLine :: MaybeT IO Int
18:50:11 <lambdabot>  error:
18:50:11 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
18:50:11 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
18:50:16 <Xnuk> geekosaur, jle`: thanks a lot
18:50:18 <iqubic> :t getLine
18:50:19 <lambdabot> IO String
18:50:26 <iqubic> :t read
18:50:28 <lambdabot> Read a => String -> a
18:50:34 <jle`> :t lift getLine
18:50:35 <lambdabot> MonadTrans t => t IO String
18:50:35 <Koterpillar> :i StateT
18:50:43 <Koterpillar> :t StateT
18:50:44 <jle`> lambdabot has no :i
18:50:44 <lambdabot> (s -> m (a, s)) -> StateT s m a
18:50:55 <jle`> @let import Control.Monad.Trans.Maybe
18:50:56 <lambdabot>  Defined.
18:51:01 <iqubic> > lift $ read getLine :: MaybeT IO Int
18:51:02 <Koterpillar> iqubic: try StateT something as the result type, you're close… ah, that's better
18:51:02 <jle`> :t lift getLine :: MaybeT IO Int
18:51:03 <lambdabot> error:
18:51:03 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘Int’
18:51:03 <lambdabot>       Expected type: MaybeT IO Int
18:51:03 <lambdabot>  error:
18:51:03 <lambdabot>      • Couldn't match type ‘IO String’ with ‘[Char]’
18:51:05 <lambdabot>        Expected type: String
18:51:07 <jle`> heh sorry
18:51:16 <jle`> :t lift getLine :: MaybeT IO String
18:51:17 <lambdabot> MaybeT IO String
18:51:27 <jle`> but yeah, back to your original question, no, the thing you are talking about has no type
18:51:30 <iqubic> I just want to undserstand when lift is useful.
18:51:31 <jle`> so it cannot be done
18:51:49 <jle`> iqubic: well, like any typeclass instance, it's best understood as something useful for each instance
18:52:01 <jle`> it's not very frutiful to attempt to understand it first as a general concept
18:52:27 <iqubic> Why would one need to use lift ever?
18:52:41 <jle`> like i said, that's not too useful of a question
18:52:45 <jle`> you should undersatnd it for a specific instance
18:52:52 <jle`> every instance uses 'lift' in its own way
18:52:59 <geekosaur> iqubic, to implement more specific lisfters
18:53:19 <iqubic> I have written lift for a MaybeT
18:53:42 <jle`> 'MaybeT IO a' is an IO action that might return nothing.  so lift :: IO a -> MaybeT IO a, it lets you use a normal IO action in a MaybeT IO action
18:53:48 <geekosaur> e.g. instance (MonadTrans m, MonadIO m) => MonadIO MyTransformer m where liftIO = lift . liftIO (which is what deriving MonadIO does, more or less)
18:53:56 <iqubic> In fact, I wrote myself a whole thing a while ago
18:54:25 <jle`> `lift :: IO a -> MaybeT IO a` just turns an IO action into a MaybeT IO a that always returns Just a.  (without thinking about exceptions)
18:54:41 <jle`> so you can use an IO action in a MaybeT IO do block
18:54:47 <iqubic> http://termbin.com/3sfr
18:55:02 <iqubic> Yeah, see the last function in that file.
18:55:14 <iqubic> It's my version of MaybeT
18:55:22 <jle`> yes, it appears that you already see why 'lift' is useful for MaybeT
18:55:28 <iqubic> I know.
18:55:33 <iqubic> Lift is helpful
18:56:06 <iqubic> I have to use lift, because getNonEmpty line might return Nothing
18:56:20 <jle`> that's not quite why you have to use lift
18:56:27 <jle`> you have to use lfit becase putStrLn "hello" :: IO ()
18:56:33 <jle`> but your do block is MaybeT IO ()
18:56:40 <iqubic> Right.
18:57:10 <iqubic> That TestMaybeT aborts if I type in an empty line ever.
18:58:09 <jle`> mhm. that's because of the Monad instance fo r MaybeT and how it implements >>=
18:59:03 <iqubic> Yep. I wrote that myself with the help of glguy.
19:04:13 <iqubic> I just realized that my Monad instance was a little verbose
19:04:54 <iqubic> Or sorry, my Applicative was the verbose one.
19:05:11 <iqubic> http://termbin.com/l3564
19:05:15 <iqubic> That's better.
19:07:42 <EvanR> the dsp package seems to waffle between lists and Array... and i was thinking of doing dsp by passing immutable Vectors around... so...
19:08:05 <heath> :)
19:08:07 <EvanR> Array seems like the worst of both worlds
19:08:34 <heath> i have three general questions i'd like some feedback on from the channel: what are some methods you use to maintain a clean codebase? how does haskell help you to maintain a clean, decoupled codebase? what system design benefits do you receive from a statically typed, pure language such as haskell, that you wouldn't in a dynamically typed, but immutable language? 
19:09:43 <dunx> heath: using git to keep track of changes usually keeps your code as clean as it would otherwise be.
19:09:57 <dunx> then you don't forget where you put rubbish
19:10:12 <heath> i disagree :)
19:10:13 <c_wraith> heath: for the last question, the big answer is that when you change something, the compiler tells you everywhere to fix.  No guessing, no hoping you remembered everything.
19:10:49 <heath> c_wraith: that's fair
19:12:18 <c_wraith> heath: it's a *slight* exaggeration.  Not all refactorings catch the attention of the typechecker when done incompletely.  But you can often write code in a way that makes it feel magical.  (Keep everything as polymorphic as possible, use different type variables for everything, etc)
19:15:32 <heath> c_wraith: have you written tightly coupled haskell code before?
19:17:54 <c_wraith> heath: yeah.  It kind of was a necessity.  When the project starts at 0 lines of code, the first line goes well, but the second line ends up pretty tightly coupled to the first.
19:18:44 <heath> :)
19:19:04 <c_wraith> heath: The project probably reached the minimum viable state around a couple thousand lines.  After that, a couple years of constant maintenance and adding new features meant basically no original code or design survived.
19:19:29 <heath> tony morris had a nice response just now to the three questions: they all seem to be the same question to me. without static types, you never see any non-trivial level of generalisation. That's because it's humanly intractable. Dynamically-typed languages are simply compiler outputs and should never be handwritten. Those generalisations are what it means (afaic) to keep a code base clean, maintainable, and 
19:19:35 <heath> decoupled.
19:20:18 <EvanR> i noticed trying to treat haskell like a dynamic language, or trying to usual corner cutting just fails early
19:20:29 <dibblego> hai
19:20:37 <EvanR> it seems to reject any attempt to "just do it"
19:21:00 <EvanR> you are really encouraged to do it right
19:21:01 <c_wraith> heath: The overall opinion I formed on that project was that you can do things just as badly as in any other language - but when you decide to improve things, it works so much better.
19:21:17 <c_wraith> heath: and for what it's worth, dibblego chimed in up there because he's Tony Morris. :)
19:25:30 <heath> the dynamic crowd points me to: https://valbonne-consulting.com/papers/classic/Liskov_72-Design_Methodology_for_Reliable_Software_Systems.pdf and https://mitpress.mit.edu/books/engineering-safer-world
19:26:49 <EvanR> im thinking a lot about reliability right now, since this program is supposed to run in an arcade cabinet with no real option to sit down in front of it and debug if it fails
19:27:01 <heath> dibblego: are you saying that decoupling ≡ generalization?
19:27:27 <EvanR> its really good that certain parts of the code (the "pure" parts) sort of obviously cant fail
19:27:30 <dibblego> generalisation (done well, principled, etc etc) leads to decoupling
19:28:04 <dibblego> look at all the generalisations in e.g. lens. I use lens because it leads to decoupling, better maintenance, and other reasons
19:28:21 <monochrom> Decoupling also requires generalization.
19:29:02 <dibblego> when the "dynamic crowd" point me to sources like that, I like to debunk it in such a way that they will never propose such a sillu argument again.
19:29:38 <dibblego> seems a waste of time otherwise
19:29:42 <monochrom> I don't think Liskov would speak against types, actually.
19:29:54 <heath> that same crowd also pointed me to: https://arxiv.org/ftp/arxiv/papers/1703/1703.10863.pdf
19:30:03 <dibblego> the best way to do that, is to first defer the argument, then teach your opponents the tools and vocabulary to debunk it, then ask, "so what now?"
19:30:50 <heath> dibblego: how do you debunk those first two sources?
19:31:46 <dibblego> well clearly, we have found the point of agreement: we both agree that "software reliability" is a worthwhile goal. Then I show that no, you didn't actually achieve that, not even close, and catch up. I do that by teaching the tools to understand just how far behind achieving that goal my opponents actually are.
19:32:21 <pikachoo> Hello, is there a name for: c -> [a] -> (c -> a -> (c, b)) -> [b] ?
19:32:39 <dibblego> looks almost like traverse
19:33:46 <ezyang> @hoogle c -> [a] -> (c -> a -> (c, b)) -> [b] 
19:33:47 <lambdabot> Data.List.HT mapAdjacent1 :: (a -> a -> b -> c) -> a -> [(a, b)] -> [c]
19:33:47 <lambdabot> GHC.OldList mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:33:47 <lambdabot> GHC.OldList mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:34:09 <ezyang> mapAccum? 
19:34:17 <heath> pikachoo: are you looking for a generic term?
19:35:12 <pikachoo> Yeah.  Will look at mapAccum, thanks.
19:35:39 <pikachoo> I guess it's also scanl + zipWith?
19:41:45 <pikachoo> The definition of mapAccumL is totally crazy.  Is there a way to simplify it for [a] instead of Traversable?
19:42:16 <pacak> :t mapAccum
19:42:18 <lambdabot> error:
19:42:18 <lambdabot>     • Variable not in scope: mapAccum
19:42:18 <lambdabot>     • Perhaps you meant one of these:
19:42:22 <pacak> :t mapAccumL
19:42:23 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
19:42:45 <pacak> :t mapAccumL :: a -> b -> (a, c) -> a -> [b] -> (a, [c])
19:42:46 <lambdabot> error:
19:42:47 <lambdabot>     • Couldn't match type ‘(b1, (a1, c0))’
19:42:47 <lambdabot>                      with ‘a1 -> [b1] -> (a1, [c1])’
19:42:55 <pacak> :t mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
19:42:56 <lambdabot> (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
20:09:10 <n_blownapart> hi anyone know if there are (still) issues running haskell on the atom ide ? I was learning haskell and had a tough time configuring Atom for stack et al. 
20:21:45 <slack1256> why is important to check that laws are being respected to cases like (Just bottom)?
20:22:07 <slack1256> wouldn't fast a loose reasoning be enough for the cases we actually care?
20:23:35 <EvanR> yes
20:23:48 <EvanR> caring about stuff and not caring changes a lot
20:24:26 <EvanR> if bottom doesnt happen and laws work ignoring bottom, then last work
20:24:33 <EvanR> laws work
20:32:57 <slack1256> I worry that because making something completely law abiding, I incur in code that must use a lot of stack levels or is operationally not optimal
20:33:26 <EvanR> example?
20:33:50 <slack1256> I was thinking on the fmap instance for lazy state
20:34:28 <slack1256> it lazy patterns on the tuple, nothing wrong with that. But references are being maintained instead of evaluated and collected
20:34:36 <slack1256> *it's
20:35:08 <EvanR> isnt that why youd choose lazy state, so it works in the presence of things that require extra laziness
20:35:16 <EvanR> maybe you want strict state
20:35:53 <slack1256> didn't strict state meet less laws?
20:36:51 <EvanR> like what, i have not heard of this
20:38:56 <slack1256> I think it was the left identity one, let me check
20:41:07 <EvanR> o_O
20:43:49 <glguy> m >>= return  =  m
20:43:52 <glguy> but for State
20:44:04 <glguy>  (undefined >>= return :: State a b) `seq` ()
20:44:08 <glguy> ()
20:45:33 <EvanR> how is that a consequence of strictness?
20:46:20 <glguy> That one's not different for Strict vs Lazy State, that's just it not following the monad laws
20:46:49 <EvanR> o_O
20:46:51 <slack1256> @info State
20:46:51 <lambdabot> State
20:46:54 <EvanR> is haskell a lie
20:47:05 <Clint> :-O
20:47:40 <glguy> same on the other side
20:47:41 <slack1256> (\s -> undefined) `seq` ()
20:47:41 <glguy> (return () >>= undefined :: State a b) `seq` ()
20:47:41 <glguy> ()
20:47:49 <slack1256> basically what is happening
20:48:12 <glguy> return a >>= k  =  k a
20:48:28 <slack1256> > (\s -> undefined :: State a b) `seq` ()
20:48:30 <lambdabot>  ()
20:49:18 <slack1256> yet this is only related to my point. What if in trying to make instance abide by all the laws, I end up with code that is operationally not optimal
20:49:36 <glguy> Then don't do that?
20:49:44 <slack1256> just for trying to handle cases like `undefined >> return = undefined` correctly
20:49:57 <EvanR> fast and loosely reasoning is precisely about this
20:50:20 <EvanR> if bottom isnt happening, then all the work youre doing to understand it isnt doing anything
20:50:29 <slack1256> usually is not clear to me at the writing moment. After pondering a while I get it
20:56:19 <slack1256> Mmm the whole point of "fast & loose" is that if I say "bottom isn't happening", no other effect in the analysis happens at haskell level other than the lack of bottom right?
20:56:28 <primal_> Yop [REGEX] I get a format like TTTTXYUUUXYIIIXY and i just whant to replace the first XY some idea ?
20:57:09 <primal_> my problem, it'"s i what he replace only one occurence of XY
20:57:22 <primal_> i can replace, but he will replace all of thream
20:57:24 <EvanR> lack of bottom cant make a program that worked with bottom not work... where work means _
20:57:39 <EvanR> not freeze up
20:57:40 <primal_> try stuff like {1} but still replace all
20:58:22 <slack1256> I wonder how many non esoteric programs work like that
20:58:22 <platz> I got the techempower blues, woa-ah-o-wah
20:58:29 * slack1256 remember the fix definition
20:58:29 <slack1256> dman
20:59:37 <primal_> i found Regex.Replace(input, replacement, count); but i need to send a count ? i can't solve the problem via only a regex ?
21:01:38 <EvanR> platz: referring to web framework benchmarks or?
21:14:16 <platz> EvanR: pretty much - bummed, though I'm fairly sure I lack the skills to contribute
21:19:19 <EvanR> platz: well, i wonder what a non-framework web solution would look like
21:19:26 <EvanR> performance wise
21:20:02 <EvanR> or it doesnt matter because people would rather see a framework being fast and just use that, at whatever cost
21:21:14 <EvanR> otoh, if its 5x slower and ur-web is 2x slower... this is sort of cutting hairs from a big-O perspective
21:21:20 <EvanR> (than the fastest)
21:21:35 <platz> i wonder what a pure wai/warp stripped down solution would look like too
21:21:46 <EvanR> i was thinking snap
21:22:27 <platz> the discussion shows a real dollar cost difference in additional instances needed to support a given traffic volume relative to others
21:24:03 <platz> even so, if there is some badness in DB, or JSON parsing.. i mean those are common ops
21:24:09 <`Guest00000> why are exceptions not monoid?
21:24:12 <platz> the websocket shootout didn't end well either
21:24:14 <EvanR> your bands website traffic? medium to large name business traffic? 
21:24:40 <pacak> `Guest00000: How would you combine two exceptions?
21:24:42 <platz> well, you got me there. no i don't have such requirements. thinking more as a selling point
21:24:50 <EvanR> heh
21:25:11 <`Guest00000> the problem with the "finally" blocks, when there's an exception and control goes into the "finally" block and another exception happens there
21:25:13 <EvanR> "pay no attention to practical issues, see here the theoretical savings"
21:25:25 <`Guest00000> one of exceptions is dropped
21:25:46 <EvanR> platz: man i remember a great websockets lib... i think bitrotted way back
21:26:29 <EvanR> an exception during your finally block?
21:26:34 <glguy> `Guest00000: Being a monoid wouldn't help, the exceptions can be different types
21:26:59 <`Guest00000> sorry, this is sort of offtop, i don't mean in haskell specifically
21:27:56 <glguy> `Guest00000: My answer wasn't Haskell specific
21:29:00 <kaychaks> Is there some reference (other than the backtracking paper) / posts / tutorials on how Logic Monad can be used in Logic Programming ?
21:29:52 <jle`> how is the package documentation?
21:30:34 <kaychaks> jle` : package doc points to the paper
21:32:45 <peddie> kaychaks: https://github.com/atzeus/reflectionwithoutremorse/blob/master/TicTacToe.hs  https://github.com/atzeus/reflectionwithoutremorse/blob/master/MCPT.hs
21:33:34 <kaychaks> peddie : thanks I will go through them
21:49:30 <`Guest00000> what is a portable way to redirect stdout to void (/dev/null, NUL, etc)?
22:01:16 <EvanR> redirecting is part of your shell functionality
22:01:29 <EvanR> the thing that is spawning the process in the first place
22:01:53 <EvanR> so you could write a portable shell...
22:45:52 <hexfive> is it possible to use typeclasses in a type synonym declaration?
22:46:45 <glguy> What are you trying to do, there are a couple of answers.
22:46:48 <jle`> what do you mean
22:47:07 <jle`> typeclasses are just first-class things at the type level, so with ConstraintKinds you can use them as teh results of a typesynonym
22:47:13 <hexfive> something like (Integral i, [i])
22:47:33 <glguy> hexfive: What would that mean?
22:47:54 <hexfive> essentially a point in multidim space
22:48:04 <glguy> I mean in Haskell...
22:48:09 <hexfive> ah, sorry
22:48:38 <hexfive> right now i have `type FT = (Int, [Int])`
22:48:53 <glguy> OK, you can do this:   type FT i = (i, [i])
22:49:00 <glguy> the constraints will go on the things that use FT
22:49:29 <hexfive> ahh, okay. I was looking for the syntax in defining the constraints. thanks!
22:59:28 <thang1> sup
23:00:28 <mrkgnao> are there any type-level extensible records libraries?
23:04:00 <jle`> what is a type-level extensible record?
23:04:51 <glguy> It's like a value level extensible record (vinyl and friends) but for types instead of values
23:05:25 <glguy> (unfortunately we don't have a nice solution for non-extensible records at the type-level, either)
23:05:50 <jle`> we also don't even have a nice solution for value-level extensible records
23:05:56 <thang1> Does anyone?
23:06:01 <glguy> Such disappoint
23:06:25 <EvanR> the language infernu ?
23:06:44 <EvanR> theres also an extensible record library for idris that uses syntax sugar and dependent types 
23:07:09 <jle`> (type-level) (extensible) records, pick 0
23:07:25 <EvanR> and in idris, thatd work for values and types, or both at the same time
23:16:03 <mrkgnao> glguy: jle`: well, I'd be happy just being able to use a list of key-value pairs (normalized by sorting the keys), but I'm looking for a way to not have to repeat myself
23:17:03 <mrkgnao> Previously, I had ways of doing what I want where it'd be enough to be able to use a type family in an instance head, or promote a data family, but both of those are out.
23:18:12 <mrkgnao> if I could just sort the list in instance heads (so I don't have to sort them myself when declaring the instances, which is error-prone), I'd be a happy camper
23:19:15 <mrkgnao> There's a Sort type family which does the thing, but I can't write instance (Foo a, Foo b) => Bar (Sort ["b" := b, "a" := a])
23:24:11 <_sras_> In Servant, is there an easy  way to extract path from the type of an endpoint?
23:54:44 <ertes-w> Philonous: software design in a dependently typed language is a new and for the most part unexplored area, so i wouldn't expect there to be a blog post or tutorial that can give you any definitive directions
