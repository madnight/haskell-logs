00:00:00 <baldrick1> Just sort out the first error (i.e. find the library it is in and append that to the link line), then repeat
00:00:20 <baldrick1> Yes, you need -lldap
00:01:04 <baldrick1> Try installing libldap2-dev if you are on a Debian based system
00:02:30 <vaibhavsagar> okay, I did that (on the Ubuntu VM I'm using) and I am still getting the same error about the undefined reference to ldap_init
00:03:01 <vaibhavsagar> the command I'm running is stack build --ghc-options '-optl-static -optl-pthread -lssl -lcrypto -lldap -lpq -fPIC' --force-dirty
00:03:43 <cocreature> halogenandtoast: http://sprunge.us/hXVj?haskell
00:03:51 <baldrick1> vaibhavsagar: append to link line: it should go after -lpq
00:04:00 <halogenandtoast> cocreature: oh
00:04:09 <halogenandtoast> I don't think I ever would have guessed that
00:04:17 <halogenandtoast> I'm bad at type-tetris it seems
00:04:25 <vaibhavsagar> ah, no wonder, thanks baldrick1
00:04:40 <vaibhavsagar> wait, same error though
00:04:48 <cocreature> halogenandtoast: you need this because getDomain is just of type Maybe a and not of type IO (Maybe a)
00:04:54 <Axman6> baldrick1: sorry, for running aray after pinging you, my machine went crazy just as I had to run away to a meeting! Looks like you and vaibhavsagarmanaged to (maybe) sort things out, so all good!
00:05:01 <cocreature> halogenandtoast: there is also a hoistMaybe function that you can use instead of MaybeT . return
00:05:04 <baldrick1> maybe!
00:05:43 <vaibhavsagar> now my command is `stack build --ghc-options '-optl-static -optl-pthread -lpq -lssl -lcrypto -lldap_r -fPIC' --force-dirty`
00:06:22 <vaibhavsagar> thanks for your help with this :), definitely feel free to eject at anytime
00:06:57 <halogenandtoast> cocreature: Thanks so much, I'll check it out
00:09:12 <halogenandtoast> Going to spend some time reading the previous error message until I can understand to add the `return` there.
00:14:27 <matrium> hi, is there some kind of until that iterates as long as the accumulated value changes (old != new)?
00:14:57 <vaibhavsagar> matrium: sounds like `fix`
00:16:37 <vaibhavsagar> you could use `iterate`
00:18:34 <matrium> vaibhavsagar: Thanks, fix seems to be what I was looking for! I'll give it a try as soon as my haddock-build is finished :-)
00:21:01 <matrium> vaibhavsagar: just looked at the fixed implementation and it's kind of ... unexpected. Does it rely on lazy evaluation and memoization?
00:21:37 <vaibhavsagar> matrium: lazy evaluation
00:22:21 <bartavelle> is there a fundamental reason why HList hasn't been updated, or just lack of manpower?
00:28:24 <ertes-w> matrium: neither…  'fix' is really just a way to write a recursive function anonymously
00:33:14 <Axman6> :t let f g  = takeWhile (uncurry (/=)) . zipWith g `ap` tail in f
00:33:15 <lambdabot> error:
00:33:16 <lambdabot>     Precedence parsing error
00:33:16 <lambdabot>         cannot mix ‘.’ [infixr 9] and ‘ap’ [infixl 9] in the same infix expression
00:33:37 <Axman6> :t let f g  = takeWhile (uncurry (/=)) . (zipWith g <*> tail) in f
00:33:39 <lambdabot> Eq a => (a1 -> a1 -> (a, a)) -> [a1] -> [(a, a)]
00:34:03 <Axman6> :t let f g  = takeWhile (uncurry (/=)) . (zip <*> tail) . map g in f
00:34:04 <lambdabot> Eq b => (a -> b) -> [a] -> [(b, b)]
00:34:53 <Axman6> :t let f g  = takeWhile (uncurry (/=)) . (zip <*> tail) . iterate g in f
00:34:54 <lambdabot> Eq a => (a -> a) -> a -> [(a, a)]
00:35:17 <Axman6> :t let f g  = head . dropWhile (uncurry (/=)) . (zip <*> tail) . iterate g in f
00:35:18 <lambdabot> Eq a => (a -> a) -> a -> (a, a)
00:37:11 <quchen> matrium: There is no »repeat until unchanged« function, no.
00:37:20 <quchen> You can easily write it yourself though.
00:37:49 <Axman6> (I think) the above does that... but would not recommend using it because I probably wouldn't understand it in a day
00:37:52 <quchen> Prelude has the related »until«, but that checks a predicate instead of comparing the last two values.
00:37:53 <quchen> :t until
00:37:55 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
00:38:15 <quchen> > until (== 0) (subtract 1) 100
00:38:17 <lambdabot>  0
00:39:02 <matrium> quchen: currently my expression looks like this: "coreOf' = until (null . removable) (\g -> G.delNodes (removable g) g)"
00:39:02 <Axman6> need a (a -> a -> Bool) I think
00:39:35 <matrium> "As long as there are deletable nodes in the graph, delete them"
00:40:54 <matrium> but that requires two evaluations of "removable", first in the predicate and then in the function
00:43:39 <opqdonut> matrium: I'd just write out the recursive function: coreOf' g | null r = coreOf' (delNodes r g) | othwerwise = g where r = removable g
00:52:31 <ertes-w> matrium: note that you can write something like that using 'until'
00:52:40 <ertes-w> you just need some post-processing
00:54:30 <quchen> > reverse (until (\(x:_) -> x == 1) (\(x:xs) -> (if even x then x `div` 2 else 3*x+1) : x : xs) [15])
00:54:32 <ertes-w> > until (uncurry (==)) (\(x, _) -> (x^2, x)) (9  :: Word16, 3)
00:54:32 <lambdabot>  [15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
00:54:34 <lambdabot>  (1,1)
00:54:39 <ertes-w> > fst $ until (uncurry (==)) (\(x, _) -> (x^2, x)) (9  :: Word16, 3)
00:54:41 <lambdabot>  1
00:55:13 <ertes-w> matrium: pretty much the same pattern you would use with 'iterate' e.g. to construct the fibonacci sequence
00:55:40 <quchen> »until plus postprocessing« is probably the same work, but less clear, than just going directly for it.
00:55:51 <ertes-w> > map fst (iterate (\(x, y) -> (y, x + y)) (0, 1))
00:55:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:56:30 <matrium> my goal was to avoid passing additional "artificial" arguments around
00:56:52 <ertes-w> i don't think there is anything artificial about it…  your state *is* 2-dimensional
00:57:14 <quchen> Or you can just define your own until function that has a predicate on the last two values.
00:57:16 <quchen> :t let until2 p f x = let fx = f x in if p x fx then x else until2 p f fx in until2
00:57:17 <lambdabot> (t -> t -> Bool) -> (t -> t) -> t -> t
00:58:04 <quchen> > let until2 p f x = let fx = f x in if p x fx then x else until2 p f fx in until2 (==) cos 1
00:58:05 <lambdabot>  0.7390851332151607
00:58:11 <quchen> > cos it
00:58:13 <lambdabot>  error:
00:58:13 <lambdabot>      • Variable not in scope: it
00:58:13 <lambdabot>      • Perhaps you meant one of these:
00:58:24 <quchen> > cos 0.7390851332151607
00:58:26 <lambdabot>  0.7390851332151607
00:58:56 <quchen> (Crazy that cos has a fixed point, by the way)
00:58:59 <vaibhavsagar> > fixed f x = if (f x) == x then [] else (x : fixed f (f x))
00:59:01 <lambdabot>  <hint>:1:11: error:
00:59:01 <lambdabot>      parse error on input ‘=’
00:59:01 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:59:08 <vaibhavsagar> > let fixed f x = if (f x) == x then [] else (x : fixed f (f x))
00:59:10 <lambdabot>  <no location info>: error:
00:59:10 <lambdabot>      not an expression: ‘let fixed f x = if (f x) == x then [] else (x : fixe...
00:59:16 <vaibhavsagar> :(
00:59:22 <matrium> let s = iterate (^2) [0..] in fst $ find (uncurry (==)) (s, tail s) 
00:59:32 <ertes-w> > sin 0
00:59:34 <lambdabot>  0.0
00:59:41 <ertes-w> quchen: sin has one, too =)
00:59:45 <vaibhavsagar> let fixed f x = if (f x) == x then [] else (x : fixed f (f x))
00:59:50 <quchen> ertes-w: :-þ
00:59:54 <ertes-w> not that crazy if you consider what they mean
01:00:22 <ertes-w> also not that crazy, if you consider that they are continuous
01:00:31 <quchen> ertes-w: It’s not crazy that the cosine function has a fixed point, but it’s crazy that (cos :: Double -> Double) has one
01:00:38 <ertes-w> ah
01:00:42 <ertes-w> yeah, indeed
01:01:37 <ertes-w> but i think that's a 1/2 chance…  either you land in the half bit that will flip-flop, or you land in a stable half-bit =)
01:02:13 <ertes-w> matrium: don't use lists for this
01:02:26 <quchen> > let until2 p f x = let fx = f x in if p x fx then x else until2 p f fx in until2 (==) (\x -> cos (x + 0.1)) 1
01:02:28 <lambdabot>  0.698081601397311
01:02:36 <ertes-w> matrium: use streams, if you want something data-like
01:02:49 <quchen> ertes-w: BREAKING NEWS physicist shows that probably all trigonometric functions have fixed points
01:03:09 <quchen> For physicist’s value of »all« and »trigonometric«.
01:04:43 <ertes-w> haskell programmers are physicists in that regard
01:04:47 <ertes-w> :t toRational
01:04:48 <lambdabot> Real a => a -> Rational
01:20:53 <jakub_> Hi, why do I need to give Typeable constraints in https://pastebin.com/igRBmKvJ when X is always typeable (I especially despise the constraint in SB constructor, is there a way to not pollute the data SX with constraints like this)?
01:31:05 <Philonous> jakub_, Class-constraints are implicit arguments that pass the class dictionary around. Without them you can't use the class methods
01:40:01 <Philonous> jakub_, In your program, the class dictionaries carry the (runtime representation) of the types for you. Types are erased during compilation, that's why you need to pass them around as (implicit) arguments.
01:40:47 <Philonous> So, the compiler may know your types are all in Typeable, but it can't invent the class dictionary from whole cloth, that's why yo have to pass it around 
01:42:55 <jakub_> Philonous: ok, so there is no trick to keep typeable constraint separated from the data declaration?
01:43:49 <Philonous> Not unless your want to make your data type parametric in it's arguments. 
01:45:59 <Philonous> Why does it bother you, though>
01:46:00 <Philonous> ?
01:47:14 <kuribas> what's a recommended library for doing image manipulation (for example canny edge detection)?
01:47:21 <kuribas> repa?
01:49:42 <quchen> kuribas: Lumiguide has bindings op libopencv
01:49:50 <quchen> s/op/to/
01:50:03 <quchen> They use it to detect whether there is a bicycle in a picture. :-)
01:50:19 <kuribas> right
01:50:57 <kuribas> this one?https://github.com/LumiGuide/haskell-opencv
01:52:20 <kuribas> Is lumiguide completely written in haskell?
01:53:04 <quchen> kuribas: Most of it. They had a Python prototype initially, but I think they’ve been using Haskell exclusively for new features, with a strong focus on migrating away from Python, for over two years.
01:53:12 <quchen> You’d have to ask Bas about the details.
01:53:16 <quchen> Or Roel.
01:53:27 <kuribas> Nice
01:53:39 <quchen> I’d say they’re Haskell-only.
01:54:07 <kuribas> I want to build a system for converting scanned music scores to vector formats.
01:54:11 <kuribas> Preferably in haskell.
01:54:56 <kuribas> Well the prototype at least.
01:56:21 <kuribas> There has been interest from the IMSLP project, so funding may be possible.
01:58:18 <jakub_> Philonous: it bothers me, because the data itself (SX) does not care about typeable and yet I need to include this constraint to be able to use the data in some particular context
02:00:16 <jakub_> Philonous: I would like to separate all dynamic "typeable" pollution from the nice statically typed things
02:12:26 <Philonous> jakub_, Well, you _can_ recover the Typeable instances by pattern-matching on SX
02:13:30 <Philonous> jakub_, Like this http://lpaste.net/355750 
02:13:37 <jakub_> Philonous: I can show you my entire codebase if you want (and are willing to take a look at it), maybe it would be more clear to you
02:14:29 <Philonous> Actually, you don't need the Typeable constraint on the function in that case, edited it
02:17:35 <jakub_> Philonous: http://goo.gl/MBd8sp this is where I actually need to know something is Typeable
02:18:54 <jakub_> Philonous: There is an existential DynamicallySorted data containing something of type array and I want to match the array index type with another argument and the array element type with the return type (performing access to the array under a given index)
02:19:50 <bartavelle> what's the extension that gives puts in scope all records content when you pattern match on Record{} already?
02:20:51 <Axman6> RecordWildcards?
02:21:12 <bartavelle> yes!
02:21:14 <bartavelle> thanks
02:22:13 <Axman6> might also find record puns useful
02:22:29 <Philonous> jakub_, Looking at it, might take a moment, that's a lot of stuff going on there :)
02:23:00 <bartavelle> Axman6: wildcards is sufficient here, just couldn't remember its name :/
02:23:55 <jakub_> Philonous: i totally understand, i tried to simplify but the resulting example may have obscured some of my intentions, I am very grateful for your effort to help me, I am in no big hurry
02:26:23 <Philonous> jakub_, SSort is the singleton for Sort, isn't it? 
02:26:31 <jakub_> Philonous: yes
02:26:48 <Philonous> jakub_, Well in that case you can recover the Typeable instance just by pattern-matching on it
02:27:28 <Myrl-saki> f (C {a, b = 4}) = a
02:27:32 <Myrl-saki> What pattern is that? ._.
02:27:36 <jakub_> I seem to be unable to do that, I tried and tried
02:28:00 <Philonous> jakub_, Did you see my paste?
02:28:21 <Philonous> jakub_, http://lpaste.net/355750
02:28:27 <Philonous> See toSomeX
02:28:32 <jakub_> I am already pattern matching on it on line 158, I did see your paste, maybe I missed something
02:29:36 <jakub_> I fail to see how typeable would be recovered for the arguments i and e of SArraySort
02:31:15 <Philonous> jakub_, You have to actually take the singleton apart. GHC (statically) knows the type of the scrutinee on the right hand side of pattern matches.
02:32:20 <Philonous> Let me write an example for SSort, sec
02:33:21 <jakub_> Philonous: thx i will have to leave for a moment but i will read the example as soon as possible
02:57:01 <merijn> So, suppose I want to put all Prelude shadowing names into a separate module intended to be imported qualified, what'd be a good name for that module? Foo.Prelude (like pipes), Foo.Traversal (it's mostly traversals like folds/maps), something else...
03:14:34 <Myrl-saki> `($ x) . f` or `flip f x` ?
03:15:57 <mauke> (`f` x)
03:18:23 <quchen> \y -> f y x
03:18:34 <Myrl-saki> mauke: Oh true, that also exists.
03:18:39 <Myrl-saki> quchen: Not PF. 0/10
03:19:56 <quchen> Neither were your suggestions.
03:20:19 <quchen> ?pl \x f -> ($ x) . f
03:20:19 <lambdabot> flip flip
03:20:21 <quchen> There you go.
03:20:40 <mauke> quchen++
03:20:41 <Myrl-saki> Pointfree with bound variables?
03:21:22 <mauke> flip ask x <$> f
03:25:10 <CyberShadow> Hello
03:25:18 <CyberShadow> Here, where is the value of sys coming from? https://github.com/koalaman/shellcheck/blob/master/ShellCheck/Parser.hs#L1847
03:25:34 <CyberShadow> Mr is 'import qualified Control.Monad.Reader as Mr'
03:26:45 <quchen> CyberShadow: SCParser is a Reader it seems. Reader gives you »ask«, which allows you to query your environment.
03:26:58 <quchen> CyberShadow: The value is »put into« the ask when running the reader.
03:27:17 <quchen> In this case, there ought to be a »runSCParser« function somewhere that executes the parse.
03:27:30 <mauke> https://github.com/koalaman/shellcheck/blob/master/ShellCheck/Parser.hs#L2803
03:28:19 <quchen> Side remark, that code is some of the uglier Haskell I’ve seen :-s
03:28:36 <CyberShadow> How does readSource have access to the SCParser? I only see it figuring in the return type
03:29:10 <mauke> what do you mean, access to?
03:29:20 <mauke> it creates/returns an SCParser
03:29:21 <CyberShadow> Sorry, I'm very new to Haskell
03:31:09 <quchen> CyberShadow: In Java-like notation, it’s signature is   SCParser<m, Token> readSource(SourcePos …, Token …)
03:31:25 <Philonous> jakub_, I've created a commit in which I got of the Typeable in DynamicSort : https://github.com/Philonous/sorted-expressions-ala-carte/commit/1eadc31d0315c1c9bf05e2aefd7b30d07106c2a7
03:31:38 <quchen> s/it’s/its/
03:31:45 <CyberShadow> Ah, OK, that's what I thought too. I don't see where the return value is initially created though
03:31:57 <Philonous> jakub_, (Also the ones on SArraySort) 
03:32:19 <Philonous> jakub_, I've added two examples that show how to construct Typeable dictionaries. 
03:32:22 <CyberShadow> But... if SCParser is created in that function, how could that function get the value of sys from its caller?
03:32:40 <mauke> CyberShadow: it doesn't
03:32:43 <mauke> the SCParser does
03:32:59 <Philonous> jakub_, However, I'm fairly sure you don't need Typeable anywhere, you can just work with the singletons directly. See sortEq 
03:33:35 <mauke> CyberShadow: the return value is created in https://github.com/koalaman/shellcheck/blob/master/ShellCheck/Parser.hs#L1827: it starts with 'do' and continues for the rest of the body
03:33:50 <quchen> CyberShadow: A Reader carries a »hole to fill« around, that’s its entire point. It’s similar to how (\x -> foo x) does not require »x« to be there, it is left open as a parameter.
03:34:05 <quchen> CyberShadow: »ask« gives you access to the hole’s contents.
03:34:31 <Philonous> jakub_, Feel free to ask questions ;)
03:34:32 <quchen> And when running the reader (via parseShell or what it’s called), you have to specify what to put into the hole (here: sys).
03:35:03 <CyberShadow> Thanks. I'm going to need to stare at this for a while longer... :)
03:36:01 <quchen> CyberShadow: Reader on its own is pretty simple, but the code is a) written with no taste in style whatsoever, and b) the reader is packed togehter with other stuff, making the »this is reader« part a bit hard to see if you’re not familiar with it.
03:36:22 <CyberShadow> That makes sense
03:37:17 <CyberShadow> FWIW my goal is to make an expression in that function conditional on a value I need to pass from another part of the program
03:40:38 <quchen> Passing a value from one part of the program arbitrarily to another is pretty hard in Haskell. (It should be.)
03:48:08 <merijn> So, suppose I want to put all Prelude shadowing names into a separate module intended to be imported qualified, what'd be a good name for that module? Foo.Prelude (like pipes), Foo.Traversal (it's mostly traversals like folds/maps), something else?
03:51:24 <hanna> Is there a way to force-import hidden packages from ghci? I want to poke around in some .Internals
03:51:44 <hanna> hidden module, I mean
03:53:19 <CyberShadow> Aah, monad transformers
03:53:22 <Philonous> hanna, You can grab the whole package and load it into ghci
03:53:30 <Philonous> Then you have access to all modules
03:53:51 <quchen> CyberShadow: Monad transformers are just a way of combining different effects; in your example, Reader is one of them.
03:54:07 <quchen> CyberShadow: But transformers are an orthogonal concept to Reader.
03:54:10 <CyberShadow> Yeah. I was confused how it was able to do all these different things with a single monad
03:54:18 <quchen> :-)
03:54:29 <Philonous> hanna, AFAIK there's no way to import hidden packages from dependencies, though
03:54:46 <CyberShadow> (I hadn't gotten to that chapter yet)
03:55:30 <hanna> fair enough; in this case the constructors are fortunately exported as well so I can just copy paste the utility functions I'm interested in
03:57:00 <Philonous> hanna, I had to resort to that a few times myself. If you need that function, someone else might as well, so you could create a PR? :>
04:00:18 <bollu> cocreature: you have new issues :)
04:06:55 <jakub_> Philonous: thanks a lot, soon i will be back at my computer to read it
04:16:21 <will_> I'm trying to write a simple parser using Parsec.  I expected the following code to work on "blahfirst" and "blahfore", but it only works on "blahfirst" - on "blahfore" it gives "Unexpected end of input, expecting 'first' or 'fore'".
04:16:22 <will_> manyTill anyChar (string "first" <|> string "fore")
04:16:30 <will_> Can anyone tell me what's wrong?
04:17:15 <bollu> I believe you need a "try", since the <|> will alternate between parsers that may consume input
04:17:22 <bollu> I believe that the "first" parser will consume the "f"
04:17:38 <bollu> and then when the "fore" parser kicks in, it will not have access to the "f" anymore
04:18:01 <bollu> manyTill anyChar (try (string "first") <|> string "fore") should work IIRC
04:20:35 <will_> bollu: Thanks a lot, that works perfectly
04:20:44 <bollu> will_: you're welcome
04:20:55 <bollu> will_: keep in mind that try will lead to worse error messages
04:21:05 <bollu> will_: so use it sparingly, and try to factor out the backtracking
04:21:14 <tobiasBora> Hello,
04:21:17 <bollu> will_: and another thing: I'd recommend MegaParsec
04:21:34 <bollu> will_: it seems to be more actively developed. In fact, I'm personally migrating from Parsec to MegaParsec as well :)
04:21:41 <will_> bollu: OK, thanks for the tip!
04:21:42 <bollu> tobiasBora: hey
04:23:12 <tobiasBora> I'd like to generate all the possible lists that have n elements chosen in a given list of reference L
04:23:21 <tobiasBora> for small n, I can do of course:
04:23:38 <tobiasBora> [[i,j] | i <- l, j <- l]
04:23:57 <exarkun> Why is `let a = (System.Process.proc "foo" []){ std_in = CreatePipe, std_out = CreatePipe }` leading to `‘std_in’ is not a (visible) constructor field name`?
04:24:16 <tobiasBora> but it does not scale for a random n
04:24:40 <tobiasBora> By the way, I would like to produce a lazy list, because the list will be too big to stay in my memory...
04:25:14 <tobiasBora> (and if possible, I'd love to be able to use multicore/multithreading capabilities to apply a function on it)
04:25:18 <Philonous> exarkun, Seem slike you have imported them qualified, try System.Process.std_in and System.Process.std_out 
04:25:37 <tobiasBora> but let's first focus on doing such a list for a given n
04:26:01 <Philonous> or import them unqualified: import System.Process (std_in, std_out) 
04:26:06 <exarkun> Philonous: Ah.  Because they're just more functions in some module.  I see. Thanks.
04:26:18 <Philonous> exarkun, Yeah, exactly
04:26:57 <Philonous> Well, truthfully they are actually more than functions, you can also use them in record syntax, but they behave like other values wrt. importing
04:48:32 <merijn> Is there an up-to-date vim syntax highlight file for cabal somewhere?
04:59:51 <zaquest> merijn, is haskell-vim not up to date?
05:01:55 <merijn> zaquest: What do you mean by haskell-vim? There's several different repo's with similar, but not quite that name
05:02:14 <zaquest> merijn, https://github.com/neovimhaskell/haskell-vim
05:02:59 <merijn> zaquest: I've just been using the files that shipped with vim so far, lemme try that
05:04:09 <saeidw> hi everyone, I'm confused about some type class syntax I found in a blog post: http://lpaste.net/355754
05:04:38 <saeidw> I don't understand what `type Vertex g` means when it's inside the type class definition like that
05:04:55 <mauke> associated type
05:05:13 <hpc> look up type families
05:05:16 <saeidw> I couldn't find anything online that talks about it, even in the haskell report under type definitions
05:05:22 <hpc> it's a language extension
05:05:54 <saeidw> ah, thanks, that helps!
05:05:55 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-families
05:06:10 <saeidw> somehow putting "haskell type" into google wasn't very helpful ;)
05:06:22 <hpc> yes... somehow :P
05:06:22 <zaquest> saeidw, https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
05:09:03 <Logio> tobiasBora: I think you might want something like concat . permutations . subsequences
05:10:13 <Logio> filtering the subsequences by length
05:12:36 <Logio> ah nvm, that's not right
05:13:14 <Logio> you want all the combinations, not just subsequences
05:15:57 <osa1> :k reduces type families, right?
05:15:59 <lambdabot> error: parse error on input ‘type’
05:16:47 <wz1000> osa1: I think you need to use :kind!
05:17:03 <osa1> wz1000: ahh, right. thanks
05:20:07 <jakub_> Philonous: thanks for the commit, I am very much interested in your statement that I don't need typeable, you refer to sortEq but that uses (:~:) and Refl, I also use gcast in my code, could you elaborate?
05:22:05 <Philonous> jakub_, :~: and Refl aren't specific to Typeable 
05:23:00 <Philonous> (:~:) is just a GADT: data a :~: b where (a ~ b) => Refl 
05:24:22 <mauke> data Lol a b where (a ~ b) => Rofl
05:24:47 <Philonous> Errr data a :~b where Refl :: (a ~ b) => a :~: b
05:25:30 <mauke> oh, I should have remembered that parameters in the head are decoration
05:25:49 <jakub_> Philonous: I got it the first time, no worries
05:25:51 <jakub_> :)
05:25:52 <ertes-w> or simply:  data a :~: b where Refl :: a :~: a
05:25:59 <Philonous> Yeah, same thing
05:26:10 <ertes-w> which is why i don't like using variables in GADT syntax
05:26:22 <ertes-w> data (:~:) :: * -> * -> * where Refl :: a :~: a
05:26:26 <mauke> data (:~:) :: * -> * -> * where Refl ... dammit
05:28:28 <jakub_> Philonous: what does the comment "this shouldn't be necessary..." mean?
05:30:00 <Philonous> DynamicallySorted shouldn't need the Typeable either, so you don't have to bring the instance into scope to use the Constructor. But I only changed DynamicSort, so you can have some of the fun ;)
05:30:56 <Philonous> It's the same trick, though: Remove the "Typeable s" from DynamicallySorted and bring Typeable inso scope with e.g. withTypeableSort instead
05:31:02 <Philonous> Where it's needed
05:31:07 <Philonous> Or work with singletons directly
05:33:18 <jakub_> Philonous: thanks a lot, I really appreciate it
05:35:12 <Philonous> jakub_, gcast is a little trickier. You need to reify the return type into a singleton to pattern-match on it. For that you need a class. (Typeable fulfills that role at the moment). 
05:36:35 <Philonous> jakub_, You could define that class by hand, or you can just use the singletons library which has TH to auto-derive it (and other things like propositional equality) for you.
05:37:58 <jakub_> Philonous: ok, I have exactly zero experience with singletons library so this will take time :) expect to here from me :D (just kidding)
05:38:07 <jakub_> *hear
05:38:31 <Philonous> jakub_, Well, it does pretty much the exact thing we've been doing. 
05:39:30 <jakub_> Philonous: yes, but I have been doing it for mere hours, I am not sure I know what all the implications of having a singleton type are :)
05:44:11 <jakub_> Philonous: since you did read my code, could you please tell me your impression? I never got a review of non-trivial haskell code base (I know this is probably still trivial but less trivial than snippets I posted on SO)
05:46:15 <Philonous> jakub_, I didn't see any atrocities. Two things I notices: You're using "rec" as a variable, which I would have avoided because it's a reserved word in some extension or another and your line width is > 80, which makes my editor wrap them
05:50:25 <pie_> anyone know any good intro for z notation?
05:50:30 <jakub_> Philonous: line length is something I didn't bother with, true, I intend to polish it later, and I didn't know about rec, I thought more about bad FP design, non-idiomatic code
05:50:42 <pie_> or whatever i should read wrt that and not knowing much about verification and the like
05:50:46 <jakub_> no attrocities sounds fine :)
05:52:08 <Maxdamantus> My editor wraps at 80 characters so I think it's only fair that the wrapping be hardcoded into the file so everyone else has to suffer as I do.
05:52:29 <BernhardPosselt> is extensible effects in haskell a thing?
05:53:48 <Philonous> Maxdamantus, Line length of 80 is a common convention. See also https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
05:55:18 <quchen> BernhardPosselt: Not really. There exist implementations, but I found them impractical. In practice I think most people still use transformers.
05:55:40 <quchen> Not that we don’t want extensible effects, it’s just hard to get right, and never as streamlined as in e.g. Idris.
05:56:04 <BernhardPosselt> is idris lazy as well?
05:56:14 <quchen> Idris is eager by default.
05:56:25 <quchen> It supports laziness with a wrapper.
05:56:34 <BernhardPosselt> i see
05:56:53 <quchen> (&&) :: Bool -> Lazy Bool -> Bool
05:57:12 <quchen> This is what it would look like in Haskell notation. (Well, Idris notation is almost identical.)
05:57:13 <Maxdamantus> s/::/:/
05:57:15 <BernhardPosselt> laziness seems to have big downsides which seems to make it impractical for production use
05:57:19 <Maxdamantus> oh, nvm
05:57:52 <quchen> BernhardPosselt: That’s FUD spread by nobody-knows. It has very clear upsides, but all you ever hear about is ominous space leaks.
05:58:04 <quchen> I’ve never had one, and I don’t know anyone who’s had one for longer than half a day.
05:58:08 <BernhardPosselt> quchen: right thats what i was hearing
05:58:43 <quchen> Laziness has saved me an infinite amount of work multiple times – literally.
05:58:53 <BernhardPosselt> like?
05:58:58 <quchen> > head [1..]
05:59:00 <lambdabot>  1
05:59:03 <quchen> Infinite work saved!
05:59:06 <BernhardPosselt> i mean compared to explicit laziness
05:59:09 <capisce> being too lazy to go to work
05:59:16 <cocreature> has anybody tried getting wordsBy into Data.List in base? it seems unlikely to cause a lot of breakage and I find myself using that function quite often and I get annoyed everytime I have to add split to my deps just for that
05:59:27 <BernhardPosselt> you would use generators for that in other languages, right?
05:59:30 <Philonous> quchen, *cough*Bob Harper*cough*
05:59:39 <quchen> Philonous: You mean Harrop?
05:59:50 <BernhardPosselt> or iterators
05:59:53 <quchen> BernhardPosselt: Plus it’s fairly easy to make a lazy language eager, but very hard to make an eager one lazy.
06:00:16 <BernhardPosselt> quchen: eager as in?
06:00:22 <BernhardPosselt> lambdas?
06:00:26 <quchen> BernhardPosselt: The opposite of lazy.
06:00:44 <BernhardPosselt> i mean how you make it eager :)
06:00:45 <quchen> »Strict« is not the opposite of lazy, it’s the opposite of non-strict. ;-)
06:00:56 <quchen> Oh, by adding bangs and seqs.
06:01:39 <BernhardPosselt> oh, compiler flag
06:01:43 <exarkun> these writes don't ever seem to happen (according to strace).  <https://github.com/LeastAuthority/spake2-interop-test/blob/master/TestInterop.hs#L42-L44>.  I'm not really sure why.
06:01:47 <quchen> seq is standard Haskell.
06:01:57 <quchen> BangPatterns is nicer syntax for it, but nothing new otherwise.
06:02:02 <Philonous> quchen, Dunno, is that his pseudonym? I mean the CM prof
06:02:36 <bollu> cocreature: so you don't know how to fix it?
06:02:44 <cocreature> bollu: no
06:02:57 <bollu> cocreature: hm, unfortunate
06:03:02 <quchen> Philonous: Oh, nevermind then. Harrop is a troll (intellectually dishonest business idiot) that loves to write crap about Haskell. He then usually continues promoting F# and his consulting firm.
06:03:58 <Philonous> quchen, Oh no, Harper is a serious guy. He's actually really worth listening to, but he has this (IMO irrational) antipathy towards Haskell
06:04:15 <quchen> Yes, I know Harper, I have nothing bad to say about him.
06:04:25 <opqdonut> his blog is certainly food for thought
06:04:26 <quchen> But he’s sometimes confused with Harrop and his incoherent rambling.
06:04:40 <quchen> Poor clash of names I guess :-/
06:05:29 <BernhardPosselt> btw, found this one last week https://philipnilsson.github.io/Badness10k/posts/2017-05-07-escaping-hell-with-monads.html
06:05:40 <BernhardPosselt> very well explained
06:05:54 <bananu7> is it another Monad tutorial?
06:06:01 <BernhardPosselt> not really
06:06:16 <BernhardPosselt> as in it shows what issue they solve
06:06:20 <Philonous> Ah, that one was cute. I liked the punchline where the Haskell code looks identical in all the examples
06:06:26 <BernhardPosselt> and doesnt throw around mathematical laws
06:06:47 <bananu7> I wrote something similar a while ago actually
06:06:58 <cocreature> bollu: I can’t even reproduce it atm. "stack ghci" fails for me but it fails with a different error and "cabal new-repl" works
06:07:00 <bananu7> non-theoretical PoV 
06:07:14 <bollu> cocreature: interesting
06:07:17 <bollu> cocreature: this is so weird
06:07:21 <cocreature> bollu: but please upgrade llvm-hs, I really don’t want to spend time figuring out why things break in older versions :)
06:07:34 <bollu> cocreature: yes, I will :) I went back because some of my code brke
06:07:40 <bollu> cocreature: s/broke/didn't compile
06:07:45 <bollu> cocreature: I was fixing my parser
06:07:52 <BernhardPosselt> and this one made me go "ah, wow functors are useful" https://www.youtube.com/watch?v=R4w-ITMOOBY
06:07:53 <bollu> cocreature: now that that's done, I'll upgrade
06:08:11 <BernhardPosselt> basically shows that you can have functors of functors and make it compose well
06:08:31 <BernhardPosselt> as in: recursive map
06:08:56 <bananu7> BernhardPosselt: next up - Free and recursion schemes ;)
06:09:00 <Philonous> How do I export a data family instance
06:09:06 <Philonous> ?
06:09:49 <BernhardPosselt> the theory is nice if you already understand it :D
06:10:03 <quchen> BernhardPosselt: Unfortunately, monads do not compose – two monads nested are not a monad, while two functors nested are again a functor.
06:10:08 <BernhardPosselt> however the "why" seems to be lacking in most docs
06:10:20 <bananu7> quchen: that's why we have transformers
06:10:26 <BernhardPosselt> quchen: yep, thats the essence of the talk
06:10:26 <bollu> quchen: are not / may not be?
06:10:29 <cocreature> bollu: but tbh, given the number of linker errors triggered in llvm-hs that turned out to be ghc bugs, I doubt there is anything we can do in llvm-hs itself to fix this.
06:10:38 <bollu> cocreature: I see
06:10:40 <quchen> bollu: Cannot be
06:10:47 <bollu> cocreature: well, if it's a GHC bug, then it is a GHC bug
06:10:48 <BernhardPosselt> but monad transformers are tedious once you need to compose more than 2
06:10:49 <quchen> bollu: Applicative on the other hand composes
06:11:02 <bollu> quchen: I haven't seen this Applicative composing stuff. Do tell?
06:11:06 <quchen> bananu7: Yes, but transformers aren’t generic.
06:11:11 <bananu7> in what sense?
06:11:33 <cocreature> bollu: the problem is that if you want a reasonable chance of getting GHC bugs fixed you need a minimal example and llvm-hs is _very_ far away from that and isolating it takes a shitload of time
06:11:46 <cocreature> bollu: given that stack and cabal seem to behave differently it might also be a bug in one of those
06:11:49 <bananu7> quchen: MonadTrans seems pretty "generic", don't know how you define it in this context
06:11:53 <quchen> bollu: instance (Applicative f, Applicative g) => Applicative (f . g) where pure = pure . pure; (<*>) = liftA2 (<*>) -- *any* two Applicatives composed are a new Applicative
06:12:19 <bollu> quchen: ah, neat
06:12:23 <quchen> bananu7: You have to write a new transformer for each monad, you can’t have one thing that puts together any two monads and gives you a new monad
06:12:30 <bollu> quchen: right
06:12:31 <bananu7> I see
06:12:32 <BernhardPosselt> so tl;dr: thats the reason for applicative fucntors?
06:12:39 <BernhardPosselt> composition
06:12:39 <quchen> bananu7: Compare that to the above Applicative code: it’s one piece of code and works for all Applicatives
06:12:48 <quchen> bananu7: That’s why we don’t have ApplicativeTrans :-)
06:12:59 <BernhardPosselt> "weaker" than monads but more composable?
06:13:01 <bananu7> fair enough I suppose
06:13:19 <bananu7> now that we have ApplicativeDo it starts to make way more sense anyway
06:13:40 <bollu> quchen: Is there a monad from which we can derive every other monad by quotienting?
06:13:47 <quchen> BernhardPosselt: It’s one reason. Applicative has other benefits.
06:13:48 <bollu> quchen: the way we do with free groups
06:13:55 <quchen> bollu: I know some of these words.
06:13:55 <bananu7> I mean, to consciously use Applicative. I never bought into "but this requires less" - so what, if I know I'm working on monads?
06:14:04 <bollu> quchen: :)
06:14:28 <BernhardPosselt> quchen: like? 
06:14:30 <bollu> quchen: like, if you have a group, you can write it by taking the free group and then imposing constraints on it. Don't think this works on all groups (finitely generated?)
06:14:36 <bollu> quchen: is there something similar you can do for monads?
06:14:48 <bananu7> bollu: isn't that what Free tries to do?
06:15:04 <BernhardPosselt> saving you from pattern matching Maybes?
06:15:10 <tsani> You can't generate every monad with Free though
06:15:17 <tsani> (You can generate a lot of them though)
06:15:19 <quchen> Applicative often means that you can parallelize things. Applicative means your grammar is context-free. Applicative can be inspected more by the compiler (since you don’t have an unknown function call like bind does).
06:15:43 <bollu> bananu7: is it? I don't see the "quotienting". Free seems to "add" structure on top of a functor. I want to be able to impose constraints
06:15:55 <bollu> tsani: example of monad which cannot be written as Free <some functor> ?
06:16:03 <fendor> hey, i'm trying to write a program using the 2dstencil module of the repa library. But i can't write double values in the quasiquoter, is there any reason for this behaviour or do i miss someting? 
06:16:19 <quchen> Having a <- in code that’s otherwise applicative means you’re using a new kind of power that you may not need. Monads should be avoided if you can, just like Applicative should be avoided when Functor is enough.
06:16:21 <tsani> bollu: I don't remember the specific example, but if I had to guess: Cont
06:16:33 <bollu> tsani: lol
06:17:06 <bananu7> quchen: Again, I don't buy that. The code doesn't necessarily strictly benefit from that, esp. if you don't have AppplicativeDo
06:17:07 <glguy> Proxy
06:17:21 <bollu> glguy: is that the monad that cannot be written as functor?
06:17:25 <tsani> Also you can parse non context-free languages using applicative by using an infinite grammar
06:17:27 <bananu7> <- is there for one reason and the reason is readability
06:17:47 <bananu7> just because you can infix fmap everything doesn't mean you should
06:17:48 <quchen> <- or >>=, whatever you like
06:18:01 <glguy> that's the simplest example that comes to mind
06:18:51 <bananu7> quchen: I think the best bikeshed example is <- vs liftA2/liftM2 (,)
06:18:59 <bananu7> (in real use)
06:19:11 <quchen> I don’t follow.
06:19:13 * shapr hops
06:19:37 <bananu7> From the pure "what's clearer to the reader" perspective
06:20:12 <quchen> If you have a monad, do-notation is fine. If you don’t have a monad, it’s a code smell.
06:20:53 <quchen> Because with do-notation you get the Monad constraint despite not doing anything that requires monad.
06:21:01 <cocreature> quchen: just use ApplicativeDo :)
06:21:18 <quchen> cocreature: Sure, that often helps!
06:21:36 <bananu7> quchen: and what I'm trying to say (aside from ApplicativeDo) that the constraint can be worth added readability
06:21:51 <quchen> cocreature: But this is independent of do-notation, really.
06:22:25 <quchen> cocreature: If a parser says »monad« I get a hunch it’s hard to understand the grammar. If it says Applicative I’m good ;-)
06:23:04 <bananu7> All of my parsers are "monads" :F
06:23:43 <bananu7> I guess the only time I actually utilised that fact was for traceShowM
06:25:00 <quchen> many :: Monad m => m a -> m [a] -- Why Monad? Does it inspect the »a«? It can’t … maybe it forces it?
06:25:12 <quchen> MonadPlus, rather.
06:25:22 <quchen> many :: Alternative m => m a -> m [a] -- okay
06:25:44 <quchen> Stuff like that.
06:33:25 <Philonous> jakub_, I took the liberty of porting the code to the singletons library. Should get you started to play around with it: https://github.com/Philonous/sorted-expressions-ala-carte/commit/d7fb7c7be98584faefacb00199a39bc73677e270
06:35:01 <jakub_> Philonous: This is great, it will take me a lot of time to study the change but I am ever so grateful!
06:38:14 <Philonous> jakub_, Btw. with any luck with the next major release GHC will get proper pi types and won't have to tolerate singletons any longer :D
06:39:53 <bollu> Philonous: what? :O seriously?
06:40:08 <bollu> Philonous: haskell is getting more dependant typed? :)
06:42:30 <jakub_> Philonous: I know very little about dependent types, but I think I heard someone say that Haskell would never get really dependently typed (I might have misunderstood terribly, it might have been exaggeration, someone being too harsh, ...)
06:43:10 <Philonous> bollu, Yes! See Richard Eisenberg's thesis http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
06:43:42 <cocreature> Philonous: is that really planned for the next release? I thought it was still a few years away
06:43:44 <jakub_> Philonous: still, next major release is probably very far
06:44:22 <Philonous> jakub_, You can already write dependently typed programs in Haskell. In fact, that's what you've been doing.
06:47:10 <jakub_> Philonous: well, as is the case with many different math objects, trivial instances are still instances, so any "regular" type falls under dependent types (or is this not true?). the question is whether what one can express in haskell can in reality represent arbitrary dependent type
06:47:15 <Philonous> cocreature, goldfirere said he planned on implemented it withing a year. Of course it's still vaporware es of yet
06:48:14 <Sh4rPEYE> I'm going through the "20 Intermediate Haskell Problems", where you basically rewrite common monadic (and other) functions. Is there any way to simplify "moppy" (= traverse)?
06:48:46 <cocreature> Philonous: between having some prototype implementation and having a ghc release that contains it, there can still be some time :)
06:48:55 <jakub_> Philonous: and of course I realise you meant that there are facilities (like singletons) that allow you to express dependent types
06:49:02 <Sh4rPEYE> unicorn = return, banana = bind, Misty = Monad
06:49:03 <Sh4rPEYE> moppy :: (Misty m) => [a] -> (a -> m b) -> m [b]
06:49:03 <Sh4rPEYE> moppy [] _ = unicorn []
06:49:05 <Sh4rPEYE> moppy (a:as) f = jellybean $ banana (\ b -> unicorn (banana (\ bs -> unicorn $ b:bs) (moppy as f))) (f a)
06:49:18 <shapr> I like those names.
06:49:20 <Sh4rPEYE> Oh, and jellybean = join (I think)
06:49:32 <Sh4rPEYE> Yeah it is pretty fun :-D
06:49:41 <shapr> have you seen the bananas and lenses paper?
06:49:54 <Philonous> jakub_, Haskell has been able to express more than HM for a long time. And It's been etching ever closer to full-spectrum dependent types. With 8.0 and the arrival of TypeInType and lifted GADTs I think it's possible to encode arbitrary DT programs. 
06:50:09 <Philonous> Although I'm not sure of that, so don't hold me to it :>
06:50:11 <Sh4rPEYE> Nope. I've yet to finish the Haskell Book - I'm complete beginner. No lenses for me
06:50:50 <Sh4rPEYE> I'm glad I finished these Intermediate exercises; so I'm technically Intermediate now (no lenses for some while anyway, though)
06:51:11 <Philonous> cocreature, We can hope :>
06:51:25 <cocreature> Philonous: I haven’t even used TypeInType in actual code yet :)
06:51:33 <shapr> Sh4rPEYE: Jeremy Gibbons chose a bunch of names similar to yours in his bananes, lenses, and barbed wire paper.
06:52:11 <Sh4rPEYE> shapr: Sounds fun. I can't wait to dive in this more advanced stuff!
06:52:24 <shapr> yeah, there's so much cool stuff!
06:52:27 <halogenandtoast> If I want to concat two texts, should I use (<>) from Data.Monoid?
06:52:40 <exarkun> This doesn't actually seem to write anything to a_stdin, b_stdin - https://github.com/LeastAuthority/spake2-interop-test/blob/e46fdb293c9b519d772d0f6730dc61f4bf3b89f8/TestInterop.hs#L47-L52 - What am I missing?
06:52:42 <Sh4rPEYE> shapr: Any idea about the simplifying?
06:52:55 <BernhardPosselt> is there some sort of record inheritance?
06:52:56 <Philonous> cocreature, I've been meaning to go through some of McBride's old stuff and implement it in Haskell, but I haven't had the time yet :/
06:53:06 <Philonous> Spent it all procrastinating on IRC :(
06:53:20 <BernhardPosselt> e.g. User record and Employee record
06:53:32 <BernhardPosselt> employee is a user record + a few additional fields
06:54:05 <BernhardPosselt> so you dont have to redefine type class instances as well
06:54:14 <bollu> shapr: that paper is horrible, it introduces so much notation
06:54:22 <mniip> aren't haskell summer results supposed to be published today
06:54:28 <byorgey> BernhardPosselt: no
06:54:32 <shapr> bollu: yeah, I found it very frustrating at first, but I asked a bunch of questions here and learned much.
06:54:40 <shapr> Sh4rPEYE: not off the top of my head, sorry
06:54:41 <bollu> shapr: I see
06:54:46 <bollu> shapr: perhaps I should do the same
06:55:03 <jakub_> Philonous: you helped me to understand these first steps toward dependent types so much!
06:55:35 <exarkun> BernhardPosselt: Put a user record in your employee record.  Composition.
06:55:52 <jakub_> Philonous: would you recommend using the purely singleton approach or typeable approach to casting things?
06:56:05 <Philonous> jakub_, Well, now I've got you hooked there's one more voice pestering Richard to implement pi types. Mission accomplished :P
06:56:08 <BernhardPosselt> exarkun: thats what i thought too
06:56:12 <Sh4rPEYE> shapr: No problem. Well, whatever, I can do with this. On to Parser Combinators!
06:56:19 <shapr> Sh4rPEYE: w00t!
06:56:40 <Philonous> jakub_, Well since you've already gone to the trouble of using Singletons, I'd go all the way with them.
06:56:40 <jakub_> Philonous: :D count me in! :)
06:56:41 <BernhardPosselt> exarkun: then you have to use lenses right?
06:56:47 <BernhardPosselt> to update record fields
06:56:51 <byorgey> Sh4rPEYE: you can write that much more simply if you have fmap and ap
06:57:02 <exarkun> BernhardPosselt: You probably don't _have_ to but maybe it's helpful.
06:57:07 <byorgey> Sh4rPEYE: I don't know if you have already implemented combinators with those types
06:57:16 <exarkun> BernhardPosselt: Not that I really know much about lenses.
06:58:00 <byorgey> BernhardPosselt: right, you don't have to, but if you compose records by nesting them, the way to access/update them compositionally is with lenses.
06:59:30 <byorgey> Sh4rPEYE: anytime you have a unicorn (return) immediately following a banana (bind) you might as well use fmap instead
07:00:00 <byorgey> halogenandtoast: sure
07:00:19 <halogenandtoast> byorgey: ha thanks, I almost figured my question would go unanswered.
07:00:42 <halogenandtoast> So many options to do the same thing it seems
07:00:48 <byorgey> halogenandtoast: it almost did, I just happened to glance back and notice it =)
07:00:53 <halogenandtoast> mconcat, mappend, Text.append, Text.concat
07:00:56 <shapr> monoids for all the things!
07:00:58 <halogenandtoast> (<>)
07:01:09 <shapr> tie fighter operator
07:01:37 <Philonous> (<>) and mappend are the same 
07:01:43 <ertes-w> halogenandtoast: i always use (<>)
07:01:46 <BernhardPosselt> no idea why ¯\_(ツ)_/¯ is not yet an infix operator
07:01:54 <BernhardPosselt> for asum
07:02:20 <ertes-w> halogenandtoast: mostly because i can use it unqualified, and because i don't need to change anything when i switch Text flavours
07:02:24 <Sh4rPEYE> byorgey: I do have both
07:02:38 <halogenandtoast> ertes-w: it conflicts with Data.Semigroup
07:02:47 <ertes-w> halogenandtoast: yet =)
07:02:51 <halogenandtoast> If you care about that kind of thing.
07:03:19 <Philonous> (<>) It also works on ByteStrings and Strings (and other lists). One operator to append them all
07:03:27 <ertes-w> halogenandtoast: not overly worried about that, because i'm pretty sure that conflict is going away sooner or later
07:03:28 <Philonous> -It
07:03:33 <byorgey> Sh4rPEYE: should I tell you the simpler way to implement moppy, or do you want to think about it some more?  You can do it using only fmap, ap, and recursion
07:03:47 <halogenandtoast> I've only recently learned what a Semigroup was, not sure I'll ever use them myself.
07:03:50 <halogenandtoast> I like my lists empty
07:04:09 * shapr surreptitiously empties all of halogenandtoast's lists
07:04:21 <shapr> oh man, no mutation :-(
07:04:22 <halogenandtoast> Yay now I have no chores left!
07:04:39 <halogenandtoast> Also no money in my bank account
07:04:43 <shapr> whoops!
07:04:51 <shapr> halogenandtoast: how'd you get into Haskell?
07:05:18 <ertes-w> halogenandtoast: you're using semigroups all the time
07:05:32 <halogenandtoast> shapr: When I used to work at thoughtbot I had a bunch of coworkers who got on the Haskell bus. At first I thought they were crazy (as a Rubyist) but eventually I saw the light.
07:05:42 <halogenandtoast> Too many ways for Ruby to go critically wrong.
07:05:53 <halogenandtoast> ertes-w: You don't know me.
07:06:10 <ertes-w> halogenandtoast: but i know that you're using semigroups =)
07:06:10 <BernhardPosselt> well the issue is more that its very hard to write good OO code
07:06:23 <BernhardPosselt> we basically write functional OOP all the time
07:06:29 <halogenandtoast> BernhardPosselt: it's very hard to write good code.
07:06:41 <BernhardPosselt> where our objects are either data and our functions are "services"
07:06:44 <shapr> Yeah, I get paid to write Python, and I end up using lits comps where others build a fake ADT with objects and work with that.
07:06:49 <shapr> list comprehensions*
07:06:50 <ertes-w> "functional OOP" =)
07:06:59 <ertes-w> "negative natural number"
07:07:08 <halogenandtoast> shapr: I'm trying to get my current company using more Haskell
07:07:15 <BernhardPosselt> whats the point in OO when using OO like it was intended is bad practice :D
07:07:16 <ertes-w> "composite prime"
07:07:23 <halogenandtoast> I just built a small service I'm going to try to make them use/launch for internal things.
07:07:27 <shapr> halogenandtoast: yeah, code is hard, I always want more crutches.. anything that catches my mistakes so I can go faster and try more options.
07:07:29 <ertes-w> "smart PHP lover"
07:07:45 <ertes-w> ok, sorry…  that was inappropriate
07:08:05 <shapr> halogenandtoast: that's awesome! I've written some Haskell for simple network traffic analysis, that saved us a bunch of time.
07:08:57 <shapr> Hold my coffee and watch me write a parser and analyzer in three hours!
07:09:04 <halogenandtoast> shapr: That's pretty cool. Most of my stuff has been fairly lame. A bunch of command line games, one yesod app, and one spock app.
07:09:41 <shapr> oh, I'm writing a simple exercise tracking rest api in both spock/python flask for a talk I'm giving in three weeks.
07:10:23 <shapr> This is the first time I've done a detailed comparison of duplicate features, I now have far more detail on why I prefer writing Haskell over Python.
07:10:44 <halogenandtoast> Nice if you have any questions about Spock I've done some of the simple stuff.
07:11:20 <ertes-w> halogenandtoast: the way i do it is: come up with something that will bring value (a.k.a. money), implement it in haskell…  by the time anyone objects to doing it in haskell, it will already be done, so rewriting it in something else will be pointless
07:11:21 <shapr> I made about fifteen typos while writing the Python Flask code, and found them all at runtime :-(
07:12:01 * shapr hops around sproingie 
07:12:37 <shapr> I made a few typos in the spock code, but the compiler immediately complained.
07:13:39 <exarkun> The answer: no explicit hFlush.
07:14:13 <halogenandtoast> shapr: Most of my errors with Spock was figuring out types.
07:14:23 <halogenandtoast> I decided to add Persistent and Data.Yaml.Config
07:14:28 <halogenandtoast> my old friends from Yesod
07:15:21 <halogenandtoast> If you're interested: https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs
07:15:30 <halogenandtoast> Always thankful for feedback on making it better.
07:15:37 <halogenandtoast> but not required of course.
07:15:55 <athan> Am I correct in thinking that MVars can only be "used productively" if there are a symmetric number of `take`s and `put`s across the active threads interacting with the MVar? I heard that GHC will throw BlockedIndefinitelyOnMVar to threads if it believes there isn't enough symmetry in the `take`s and `put`s
07:16:21 <merijn> athan: No, that's attributing too much intelligence to GHC
07:16:35 <sproingie> every producer eventually needs a consumer.  ensuring that happens is up to you
07:16:43 <quchen> BlockedIndefinitely means that there is no thread that can reach the MVar but someone is waiting for it, or something simple along those lines
07:16:55 <athan> merijn: do you know how exactly that exception is thrown?
07:17:02 <sproingie> statically verifying that would be an interesting problem.  probably impossible with just MVar alone
07:17:05 <quchen> Basically »this could be GC’d if only nothing was waiting for it«
07:17:05 <merijn> athan: BlockedIndefinitelyOnMVar triggers when: an MVar has no references *EXCEPT* threads currently blocking on it
07:17:41 <merijn> athan: i.e. if all threads with live references to an MVar are blocked on that same MVar, it's obviously impossible any of them will ever wakeup
07:18:07 <athan> quchen: yeah, I'm calling `put` at some asynchronous time, when I thought I could `forever $ r <- takeMVar ...` or something, to block until the receiving end arrives 
07:18:21 <halogenandtoast> shapr: what was the path that led you to Haskell (since you asked me).
07:18:22 <merijn> athan: Counter example where you'll get screwed over: you have a thread that does "forever (putStrLn "hey!") >> takeMVar mvar"
07:18:49 <merijn> athan: That thread holds a reference to the MVar and isn't blocked on it, so GHC will never tell that other threads blocked on that MVar are stuck
07:18:57 <merijn> Despite out thread never actually reading from the MVar
07:19:21 <shapr> halogenandtoast: Ah, I was writing a bunch of Python, and was somewhat influenced by elisp. I slowly started writing purely functional Python code but had never heard the term. A friend of mine asked me why I was writing Haskell in Python.
07:19:28 <shapr> So I started reading about Haskell and WOW
07:20:05 <merijn> athan: So if you have a reference to the MVar alive somewhere (so that you can asynchronously "put" to it), GHC will never see that MVar as blocked indefinitely
07:20:22 <byorgey> halogenandtoast: shapr is too modest to mention it, but you should ask him what year that was =)
07:20:23 <athan> thanks merijn & quchen, I think I'm understanding :S
07:20:24 <merijn> Since the alive reference, could theoretically do something with it at any point
07:20:34 <ertes-w> athan: if you just go with the default behaviour, then a thread that is killed due to indefinite MVar blocking will be indistinguishable from a thread that just blocks forever, except that the former is able to free resources
07:20:46 <ertes-w> athan: so if you don't need any special handling, just ignore it
07:20:59 <halogenandtoast> byorgey: sure, shapr what year was that?
07:21:02 <ertes-w> athan: caveat: make sure it doesn't happen in the main thread
07:21:21 <shapr> halogenandtoast: ha, that was 1999
07:21:34 <Sh4rPEYE> byorgey: Thanks. This is the function it simplified to:
07:21:44 <Sh4rPEYE> moppy :: (Misty m) => [a] -> (a -> m b) -> m [b]
07:21:44 <Sh4rPEYE> moppy [] _ = unicorn []
07:21:44 <Sh4rPEYE> moppy (a:as) f = apple (moppy as f) (furry' (:) (f a))
07:21:50 <shapr> I had a bunch of trouble trying to learn Haskell, so I figured I'd start an irc channel for it and see if I could get people to show up and chat.
07:22:07 <byorgey> Sh4rPEYE: that's it =)
07:22:41 <Sh4rPEYE> Thanks a lot :-)
07:22:56 <byorgey> Sh4rPEYE: moppy and apple both have strange argument orders, but that's not your fault of course
07:23:25 <halogenandtoast> shapr: That's a good way to learn.
07:23:41 <shapr> yeah, lots of people here chatting :-)
07:24:40 <halogenandtoast> I'm planning on starting a (second) meetup about Haskell in Tokyo.
07:24:55 <halogenandtoast> Thinking about giving a talk about Spock.
07:24:56 <shapr> halogenandtoast: oh, I was going to ask if you were near Atlanta, but I guess not.
07:25:03 <halogenandtoast> shapr: I used to live there
07:25:10 <sproingie> i'm liking that new monad "tutorial" recently linked on reddit.  unlike a lot of folks, i like reasoning from use cases to the underlying theory and not the reverse.
07:25:10 <halogenandtoast> About 7 or 8 years ago now.
07:25:14 <shapr> yeah, I like spock. I'm sad scotty is no longer maintained, but spock is better overall.
07:25:29 <shapr> sproingie: Escaping Hell with Monads?
07:25:30 <Sh4rPEYE> Oh, I forgot to ask. Is there anyone here from Czech Republic?
07:25:34 <sproingie> shapr: that's the one
07:25:43 <Sh4rPEYE> (I don't have my hopes high, but... one never knows)
07:25:46 <shapr> sproingie: I agree, problem -> solution
07:26:02 <sproingie> it follows the process that anyone not formally trained uses: concrete to abstract
07:26:08 <shapr> sproingie: the comments on lobste.rs are good, someone gave a short description of how to build monads in C
07:26:29 <sproingie> hell i invented Writer in perl before i'd even heard of functional programming
07:28:30 <james9999> link?
07:28:47 <shapr> james9999: https://lobste.rs/s/xl0jik/escaping_hell_with_monads
07:28:59 <shapr> That's the lobste.rs comment thread, you can get to the article at the top
07:29:16 <shapr> james9999: or did you specifically want the comment on monads in C?
07:29:46 <ertes-w> monads in C?
07:29:53 <james9999> yes
07:30:17 <shapr> james9999: this one: https://lobste.rs/s/xl0jik/escaping_hell_with_monads#c_hc3hi3
07:30:23 <james9999> thx
07:30:49 <ertes-w> void *bind(void *m, void *c, void *(*f)(void *));
07:30:52 <ertes-w> have fun =)
07:31:05 <byorgey> Sh4rPEYE: I think there is actually a #haskell.cz IRC channel.  I don't know if anyone is there
07:31:26 <Sh4rPEYE> I'll check it out
07:31:33 <halogenandtoast> ertes-w: sadly I wrote a lot of c in my day, mainly due to trying to write compilers, and I can understand that line without a problem :(
07:31:41 <byorgey> there is also a haskell.cz  website, but I don't know if it is maintained.  I think it might have been a single person that created it
07:32:01 <ertes-w> i maintain that monads are pointless in a language without HKT, but if it doesn't even have good support for functions in the first place, then don't even bother
07:32:13 <shapr> HKT?
07:32:17 <MitchellSalad_> higher-kinded types
07:32:19 <shapr> ohh
07:32:38 <ertes-w> in other words: yes, F# does have monads, but they're pointless
07:32:44 <ertes-w> because you can't abstract over them
07:32:59 <sproingie> the Monad type is fairly useless then.  composing kleisli arrows is something you can do anywhere
07:33:32 <sproingie> you don't always need fully generic code
07:33:32 * shapr fills his quiver with kleisli arrows.
07:34:15 <shapr> oh hai peti!
07:34:17 <c_wraith> I remember a paper titled something about Kleisli Arrows of Outrageous Fortune, but I have no idea what the paper was about..
07:34:27 <ertes-w> well, you can use some abstractiosn for the sake of using something well known and well understood, but with monads it's a different story: they require a fair bit of language support in order to be useful even on this level
07:34:29 <shapr> wow that's a great title, I must find that paper.
07:34:48 <ertes-w> c_wraith: the title isn't exactly enlightening either =)
07:34:49 <shapr> oh man: https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
07:35:09 <c_wraith> Conor McBride?  Then you know it's gonna be good. :)
07:35:29 <MitchellSalad_> that paper is about indexed monads that get close to dependent-typed seeming stuff
07:35:51 <MitchellSalad_> tho now we have baaasically have dependent types, so *shrug*
07:36:02 <ertes-w> i wish that were true
07:36:09 <sproingie> been going back and reading a lot of old papers now that i can understand them.  long as they're not stuffed with pages of greek anyway
07:36:15 <MitchellSalad_> it is true, with singletons!
07:36:16 * peti has a question about FFI. My understanding is that a "newtype Foo = Foo (Ptr ())" is essentially the same thing as a "Ptr ()". That this mean that I can import a C function that returns a void pointer -- Ptr () -- as returning a type Foo instead?
07:36:29 <shapr> Are there codependent types?
07:36:54 <ertes-w> MitchellSalad_: not really…  they are as expressive as DTs, but they aren't DTs…  they're incredibly verbose and awkward to work with
07:37:16 <geekosaur> peti: that sounds like you are confused somewhere
07:37:21 <MitchellSalad_> as-expressive-but-aren't is what i meant by "baaasically" :P
07:37:25 <sproingie> shapr: hm, two types that can't function without each other.  add some fun methods and you have an Acme module :)
07:37:28 <c_wraith> For what it's worth, I think there's value in knowing about the Monad pattern in languages that don't support abstracting over it.  It lets you know what principled combinators behave like, so you can avoid almost-but-not-quite monadic abstractions that fall over in some way.  Like, say, the upcoming javascript Promises stuff.
07:38:02 <geekosaur> however that convention is used to mean we get an opaque pointer to be kept distinct from other pointer types, so if that is what you meant, then yes
07:38:07 <shapr> broken promises
07:38:26 <peti> shapr: Hi there. :-)
07:38:35 <peti> geekosaur: Care to elaborate? 
07:38:38 <sproingie> c_wraith: just call it a Design Pattern and yer all set ;)
07:39:44 <c_wraith> sproingie: how can it be a design pattern? It doesn't have any boilerplate!  :)
07:40:02 <sproingie> not when it's built-in, eh?
07:40:03 <geekosaur> peti, not sure how to elaborate without some context. the problems are (a) C is not strongly typed, and (void *) is a hack of sorts (b) which means hacks on the Haskell side if you want to simulate strong typing or just try to keep the C-side merry tangle of nonsense straight
07:42:26 <sproingie> monads in C++ are doable (and been done).  more syntax sugar and better type system too
07:42:34 <sproingie> (than C that is)
07:42:53 <peti> geekosaur: OpenSSL has function EVP_MD_CTX_new() that allocates and returns an opaque pointer type EVP_MD_CTX*. Now, my question is can I define a "newtype Foo = Foo (Ptr ())" and use that type everywhere instead of the naked pointer and rely on the fact the the newtype is just a pointer when it's passed forth and back from/to C?
07:43:10 <geekosaur> peti, yes
07:43:29 <peti> geekosaur: Is that guarateed by the standard? Or does it "just work"?
07:44:58 <mauke> hah. which standard?
07:45:04 <geekosaur> peti, ... ok, I guess that is your confusion then. the standard doesn't guarantee anything because there is nothing to guarantee. the guarantee is that Ptr represents a C pointer and carries a possibly phantom type that Haskell code can use if marshaling/demarshaling of the pointer is needed.
07:45:19 <geekosaur> beyond that, you;d need guarantees on the C side which is impossible
07:45:37 <peti> geekosaur: OK. Thank you.
07:45:40 <geekosaur> (because Haskell doesn't get to dictate to arbitrary C code)
07:45:59 <mauke> I'm pretty sure the Haskell FFI isn't compatible with full standard C
07:46:31 <mauke> so what you get is basically "it happens to work on some common platforms"
07:47:00 <merijn> GHC follows the ABI of the platform
07:47:11 <merijn> At least, that's what it's supposed to
07:48:03 <mauke> what if the ABI actually uses different kinds of pointers?
07:48:28 <merijn> mauke: Well, GHC only supports posix platforms, so that doesn't happen on supported platforms :p
07:49:19 <sproingie> if one's platform has differing pointer widths, usually there's one that's "suitable for export" for a FFI
07:49:27 <cocreature> merijn: if you claim ghc only supporst posix platforms, Phyx will come and find you :)
07:49:36 <mauke> wait, since when is Windows POSIX?
07:49:43 <sproingie> and it's up to the one compiling it on the C side to get it right
07:49:58 <mauke> sproingie: not just widths. widths are the easy part :-)
07:50:00 <merijn> ok, posix + windows :p
07:50:44 <sproingie> mauke: can't think of other pointer types that a C compiler would output
07:50:54 <mauke> sproingie: isn't the whole point of a FFI to be able to bind to existing interface without having to write glue code?
07:51:14 <sproingie> ideally.  sometimes it needs help.
07:51:56 <sproingie> varargs is often a sticky wicket
07:52:13 <mauke> basically there are the following pointer kinds: function pointers, byte pointers (char * variants and void *), struct pointers, and every other type of pointer
07:52:26 <cocreature> you already need glue code if the C code passes structs by value
07:52:27 <tobiasBora> Logio: I found sequences, it's what I want right ?
07:52:42 <mauke> i.e. AFAIK int * and double * aren't required to have anything in common
07:52:46 <mauke> or int * and int **
07:53:29 <sproingie> that's what the ABI is all about
07:53:54 <mauke> merijn: do you have a link to what POSIX says about pointer requirements?
07:54:02 <merijn> mauke: Pretty sure the only pointers that get to be different are function pointers
07:54:09 <merijn> (in C11)
07:54:15 <mauke> that would surprise me
07:54:26 <Myrl-saki> Fundep. `| (n, v, s) -> t, (n, t) -> v`
07:54:29 <mauke> because that would break compatibility with C99/C89 in a major way
07:54:34 <Myrl-saki> Is there a clearer way to represent that?
07:54:41 <merijn> mauke: Well, at the very least void* can represent everything pointer to non-functions
07:54:41 <sproingie> pretty sure posix doesn't say anything about ABIs
07:54:53 <merijn> mauke: And void* can be directly cast to the relevant pointer type
07:54:56 <mauke> merijn: well, yes. but that just means void * is a common serialization format
07:55:01 <merijn> So, if your ABI deals with void* you're fine
07:55:08 <mauke> that does not follow
07:55:12 <merijn> posix further requires that void* is big enough to store function pointers too
07:55:30 <Myrl-saki> If you ABI is void*, that seems even worse...
07:55:31 <mauke> you still have to apply the right serialization/deserialization steps
07:55:48 <Myrl-saki> From an API perspective.
07:55:58 <Myrl-saki> (And like, technically, every ABI is void*)
07:56:24 <sproingie> merijn: the C standard doesn't require that, not sure where posix would
07:56:38 <merijn> sproingie: The last bit I'm 100% sure about
07:56:45 <merijn> posix mandates void* can hold function pointers
07:56:53 <mauke> sproingie: dlsym()
07:57:28 <Myrl-saki> Interesting.
07:57:38 <sproingie> posix needs that for dlsym (and a lot of other things) to work at all, yes
07:58:11 <sproingie> not sure it spells it out chapter and verse, but i obviously haven't read the whole thing
07:58:20 <Myrl-saki> Question. How can it be impossible for void* to hold a function pointer?
07:58:32 <mauke> Myrl-saki: it could be too small, for example
07:58:33 <merijn> Myrl-saki: Because function pointers are not required to fit in void*?
07:58:48 <mauke> e.g. 2 byte data pointers, 4 byte function pointers
07:58:55 <Myrl-saki> Ahh
07:58:58 <Myrl-saki> Makes sense.
07:59:12 <mauke> http://c-faq.com/null/machexamp.html
07:59:24 <sproingie> usually such platforms have a "far pointer" type
07:59:35 <sproingie> (storage class, whatever)
07:59:42 <Myrl-saki> x86. :D
07:59:56 <sproingie> in DOS maybe
08:00:19 <Myrl-saki> Mhm. 16-bit x86.
08:00:21 <sproingie> real OS's run in a saner mode
08:00:37 <Myrl-saki> sproingie: DOS was pretty real for its time. :P
08:01:38 <sproingie> DOS was a minor BIOS extension ;p
08:01:52 <Myrl-saki> mauke: Thanks for the link. That was pretty interesting.
08:02:02 <Logio> tobiasBora: depends on what sequences you found :)
08:03:47 <geekosaur> if you have a linux kernel with big page support, it uses far pointers internally. nothing to do with "real oses"
08:04:03 <geekosaur> (you're conflating storage type/pointer size with the lack of memory protection)
08:05:32 <sproingie> yah i guess there was only a brief time in 32-bit land where everything was gloriously uniform
08:08:08 <twopoint718> What's the current state of deploying stack-ified Haskell applications to Heroku (or similar buildpack-using services)?
08:08:23 <twopoint718> Is there a preferred solution?
08:13:09 <sproingie> googling around there do look to be maintained buildpacks using stack
08:18:43 <twopoint718> sproingie: Yeah, I'm looking at this one: https://github.com/mfine/heroku-buildpack-stack and I was just wondering if anyone had tried it.
08:19:04 <sproingie> the script looks simple enough
08:20:31 <twopoint718> Cool, I'll give it a shot
08:20:37 <twopoint718> sproingie: thanks
08:26:52 <Logio> tobiasBora: do you need all the possible orderings of n elements, or just the n-length subsets?
08:27:29 <heath> https://github.com/juhp/stackage-query
08:27:49 <tobiasBora> Logio: All the lists of size n containing as elements the elements from the incoming list.
08:50:26 <buglebudabey> is hmatrix the most efficient matrix library?
08:54:16 <lpaste> Logio pasted “Selecting sublists of size n” at http://lpaste.net/355756
08:54:27 <Logio> tobiasBora: ^
08:55:51 <Logio> that's one solution, though not very efficient if n is large
08:57:21 <zacts> hi is haskell well-suited for web development?
08:57:23 <Logio> there is probably a cleverer way to do it by iterating selections but it gets too messy for my brains at this moment
08:57:30 <zacts> when should I use Haskell / Clojure / Elixir?
08:58:25 <ph88> i have a Vector Unboxed Double with numbers like 1.0 2.0 3.0  .. what function can i use to get the sum per element ?, so   1.0, 3.0, 5,0
08:59:04 <ph88> zacts, haskell is statically typed, elixir and clojure dynamically typed .. it's a big difference
08:59:17 <zacts> ph88: how does this affect web devel?
08:59:18 <sproingie> zacts: it's extremely suitable, though it does take a little more discipline up front
09:00:12 <lyxia> ph88: http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html#v:sum
09:00:25 <zacts> sproingie: ok
09:00:35 <sproingie> zacts: same as other static typed systems for any app: it takes a different discipline up front (thinking in types), but your debug cycle will be shortened like crazy
09:00:42 <zacts> oh nice
09:00:49 <sproingie> also doesn't hurt that haskell has concurrency that gives erlang a run for its money
09:00:49 <zacts> so Haskell offers this advantage over other systems
09:01:05 <zacts> oh cool, so Haskell also has nice concurrency versus even erlang?
09:01:14 <ph88> lyxia, that computes the sum of all elements .. but i need the sum PER element
09:01:49 <ph88> zacts, with dynamically typed you need to write unit tests for stuff which are already checked by the compiler if statically typed
09:01:58 <lyxia> ph88: what is a sum per element
09:02:11 <sproingie> it has crazy good concurrency, and now there's cloud haskell which makes it distributed like erlang.  not as mature in erlang in that last category, but it'll get there
09:02:33 <ph88> lyxia, when input is  1 2 3 4   output is  1 (1 + 2) (1 + 2 + 3) (1 + 2 + 3 + 4)  = 1 3 5 9
09:02:41 <zacts> oh wow, nice
09:02:44 <lyxia> ph88: that's a scan
09:02:53 <ph88> aha a scan !
09:02:57 <sproingie> er, as mature *as* erlang
09:02:58 <lyxia> 1+2+3 = 6 by the way
09:02:59 <zacts> sproingie: ph88 I'm going to give haskell + web devel a go
09:03:10 <zacts> I don't have a professional job, so I can just try it out anyway with no worries
09:03:11 <ph88> lyxia, which scan is best suitable ?
09:03:14 <zacts> but it is a time investment for me
09:03:18 <lyxia> ph88: scanl
09:03:19 <zacts> so I thought I would ask :-)
09:03:38 <ph88> sproingie,  "also doesn't hurt that haskell has concurrency that gives erlang a run for its money"  --> can you elaborate ?
09:03:38 <sproingie> zacts: i'd say start with spock, though possibly pick up scotty too since there may be more tutorials for it
09:03:45 <zacts> ok
09:03:45 <lyxia> ph88: scanl starts from the left, scanr starts from the right
09:04:37 <ph88> zacts, i went with spock .. but i haven't finished it yet
09:05:04 <ph88> lyxia, well the new vector be allocated in one go ?
09:05:05 <sproingie> ph88: haskell's (ok, actually ghc's) thread and i/o scheduler scales like mad.  millions of sparks is doable on mid-range hardware
09:05:11 <lyxia> ph88: postscanl if you don't want the initial accumulator
09:05:12 <shapr> zacts: I'm using spock at the moment, it's nice.
09:05:12 <zacts> thanks
09:05:16 <zacts> :-)
09:05:19 <shapr> zacts: but it depends on how much magic you want
09:05:22 <lyxia> ph88: yes
09:05:31 <zacts> shapr: semi-define magic. :-P
09:06:18 <ph88> lyxia, scan with strict accumulator would that help with performance ?
09:06:20 <shapr> zacts: spock has minimal magic, larger frameworks have much magic where they do everything for you, but that can make the error messages difficult to understand if you don't know what's happening under all the magic.
09:06:32 <sproingie> i learned about magic the hard way with lift
09:07:25 <ph88> shapr, can i ask you some questions about spock later ?
09:07:42 <shapr> ph88: sure, no guarantees I can answer, I've been out of Haskell webdev for years.
09:07:46 <shapr> but I'll do what I can!
09:07:47 <ph88> ok
09:08:05 <zacts> oh I see
09:08:14 <zacts> shapr: so spock is like Sinatra, and other frameworks are like Rails
09:08:41 <ph88> kind of ye
09:08:46 <sproingie> i'm looking to jump in to haskell web dev myself.  gave it a weak stab with snap and yesod way back, but i ended up using spray in scala instead
09:09:02 <shapr> zacts: roughly, yes but there are still many differences :-)
09:09:10 <zacts> ok
09:09:22 <zacts> Haskell is magic already
09:09:28 <zacts> like I mean I would probably start with something minimal
09:09:47 <zacts> because the language itself provides really powerful ways to abstract ideas
09:09:47 <shapr> I used scotty before, but spock is the spiritual successor, imo
09:09:54 <shapr> yeah! I agree!
09:10:05 <lyxia> ph88: hm, it's weird that there is a distinction for unboxed vectors at all.
09:10:10 <zacts> I'm also interested in doing music composition with Haskell
09:10:16 <zacts> a la https://overtone.github.io
09:10:18 <shapr> zacts: ooh, good support for that
09:10:23 <shapr> zacts: have you seen TidalCycles?
09:10:28 <zacts> oh and visual processing
09:10:33 <zacts> a la https://processing.org
09:10:36 <lyxia> ph88: I would go with the strict accumulator to be safe
09:10:38 <zacts> no re: TidalCycles
09:10:42 <shapr> There are several really fascinating music composition frameworks for Haskell
09:10:50 <zacts> looks cool
09:11:01 <shapr> TidalCycles is specifically designed for live performance
09:11:10 <zacts> nice
09:11:21 <sproingie> something like Processing with an actually decent language would be nice.  i'd love a good spiritual successor to logo that was statically typed
09:11:31 <shapr> but .. oh, what's the name of Thompson's successor to Hascore?
09:11:35 <zacts> logo is that turtle language right?
09:11:41 <shapr> zacts: yup, that's right.
09:11:45 <zacts> cool
09:11:55 <zacts> well there is a clojure interface into processing-lang
09:12:00 <zacts> I think because processing is on the JVM
09:12:07 <zacts> can GHC interact with the JVM?
09:12:12 <sproingie> clojure ain't static either.  better language than processing's DSL tho
09:12:23 <zacts> and better than Java
09:12:30 <sproingie> i dunno at least that is static
09:12:42 <sproingie> but yeah java isn't the language for a DSL
09:13:07 <zacts> well I think the processing DSL extends into full java if you want more power
09:13:11 <zacts> it's like a subset I think
09:13:26 <zacts> and then if you want more then you just extend that subset into full java, or another JVM language
09:13:47 <monochrom> No, Haskell doesn't have a JVM story. The irony is that Haskell FFI has reserved a place for it for 17 years.
09:14:06 <ggVGc> there's frege...
09:14:12 <zacts> hehe
09:14:16 <sproingie> haskell has a few JVM stories, not just frege
09:14:35 <zacts> is it theoretically possible to implement in reasonable fashion?
09:14:38 <james9999> did someone mention gottlieb frege?
09:14:39 <alx741> and eta...
09:14:43 <zacts> or would it be totally convoluted?
09:14:52 <sproingie> the JVM isn't as compelling a platform as it used to be.  maybe java 9 will fix that, the deployment story gets a lot better with that
09:15:02 <ph88> lyxia, i don't understand the difference between prescan, postscan and scan .. but i looked at the samples with (+) at it seems that postscan is what i wanted, and you also recommended that so i choose   postscanl'  with strict
09:15:34 <zacts> anyway, thanks. I'll bbl. I'm beginning this haskellbook.com now
09:15:42 <sproingie> since java9 can bundle a jre into the app, and jigsaw makes that jre not quite so bloated
09:15:59 <james9999> I recall reading about the jre in a tech book once - Write once, run anywhere!
09:16:24 <james9999> the bytecode is platform-independent!
09:16:26 <reactormonk[m]> s/run/debug/
09:16:34 <lyxia> ph88: the difference is whether to keep elements at the ends.
09:16:48 <sproingie> WORA, big whoop.  the JVM is still very nice tech though.
09:17:05 <monochrom> ASCII is also platform-independent. (After EBCDIC fell out of favour.)
09:17:57 <ph88> lyxia, if my input vector is of length 5 i would also like an output vector of length 5
09:18:23 <lyxia> ph88: yes postscanl' does that
09:18:29 <ph88> :)
09:19:14 <monochrom> Some Pascal compilers back then also used bytecode (called P-code). I played with one briefly. UCSD Pascal.
09:19:20 <monochrom> On Apple II, no less.
09:20:08 <hugo> Does anyone have any experience getting mouse input with hscurses?
09:21:25 <sproingie> jvm bytecode wasn't the new idea so much as the verification stuff.  which also didn't turn out well but that had more to do with the deliberate backdoors built into the java standard lib
09:21:30 <jle`> hm turns out that training ANN's using 'vectors' in ghcjs is pretty slow
09:21:41 <jle`> i sort of expected it to be so, but i had some hopes
09:21:53 <jle`> i guess it's time to write ffi wrappers over js linear algebra libraries
09:32:33 <buglebudabey> is Float or Double better in practice? if it depends, what does it depend on
09:32:48 <exarkun> depends on what you're doing with it. ;)
09:33:01 <buglebudabey> exarkun see second question :P
09:33:17 <exarkun> yea that's what I was answering
09:33:27 <buglebudabey> oops, ha
09:33:34 <buglebudabey> i'm doing matrix operations like page rank
09:33:41 <exarkun> but, I dunno, it may not really depend.  I'm not sure single precision floating point is _worse_ for anything these days.
09:33:52 <exarkun> You pay an extra memory cost for using double precision.
09:33:53 <kadoban> Double should be a better default I'd think, especially in haskell where they're both going to take a decent amount of space. (that being usually the only benefit of Float)
09:33:57 <exarkun> But everyone has plenty of memory now.
09:35:31 <sproingie> use Double, unless you're doing GPU programming
09:36:07 <sproingie> or just plain need to pack a lot of them and don't need much precision
09:36:47 <sproingie> otherwise they're going to get upconverted anyway
09:37:09 <buglebudabey> alright
09:53:43 <chrissound> Hello! Are dynamic tags supported well by other panels or is this an xmobar feature?
09:54:03 <chrissound> I'm trying to get it to work with tint2, but I'm not too sure how to integrate tint2 with a logHook?
10:07:03 <chrissound> Ah! XMonad.Actions.DynamicWorkspaces instead of XMonad.Actions.WorkspaceNames. It works! :D
10:09:59 <tobiasBora> Logio: Thank you. I also ended up with this solution: sequence [ possibleValues | i <- [1..n]]
10:10:15 <tobiasBora> By the way, I've a question:
10:10:43 <tobiasBora> I've a pure function, that, given an input, gives me an output (whaoooo really ?)
10:11:03 <tobiasBora> and I'd like to count the number of different output this function gives me
10:11:27 <tobiasBora> for now I use something like a map on a list of input
10:11:40 <WhereIsMySpoon> How come this doesnt work? https://gist.github.com/Jarob22/23fbed05deba32f87dae4ee6389e455c
10:11:44 <codygman_> [True, False] ^.. filtered _False -- i expected [False] but got a sizeable type error
10:12:01 <tobiasBora> and then I do a pattern matching to get only the first occurence
10:12:17 <codygman_> Eh, bad example. I'm trying to filter a list of products with a prism
10:12:20 <WhereIsMySpoon> updated it with the error
10:12:32 <tobiasBora> but here if I'd like to compute everything and sort the output, what would be the more efficient way to proceed ? A map and a sort ?
10:14:04 <koala_man> WhereIsMySpoon: x:xs is a list. [] is a list. [x:xs] is therefore a list in a list. just use (x:xs)
10:14:33 <WhereIsMySpoon> oh ffs
10:14:49 <WhereIsMySpoon> hm..still an error
10:15:11 <WhereIsMySpoon> updated
10:15:32 <koala_man> WhereIsMySpoon: it's a cons list, so you can do element:list but not list:element
10:15:53 <WhereIsMySpoon> so do i need to use ++ instead?
10:16:04 <koala_man> yes, you can do ++ [x] 
10:16:06 <glguy> codygman_: There's no _False provided by lens, did you write your own?
10:16:39 <WhereIsMySpoon> yay!
10:17:00 <WhereIsMySpoon> and i dont need that [x] constraint either
10:17:21 <WhereIsMySpoon> koala_man: can you explain what you meant by its a cons list and that : wont work?
10:18:26 <glguy> :t (:)
10:18:27 <lambdabot> a -> [a] -> [a]
10:18:40 <WhereIsMySpoon> :t (++)
10:18:42 <lambdabot> [a] -> [a] -> [a]
10:18:47 <WhereIsMySpoon> ah
10:19:18 <WhereIsMySpoon> i see
10:19:21 <WhereIsMySpoon> cool thanks all
10:19:25 <koala_man> WhereIsMySpoon: it's a singly linked list if you're familiar, so given the first node there's no immediate way of appending something after the last
10:20:45 <quinor> hey, do you possibly know any good resources on writing functional language interpreter in haskell? I'm mostly interested in stuff about implementing type inference
10:21:29 <quinor> for now I've got H-M typed lambda calculus with algorithm W and inferring type of recursive lets (especially generalization) was quite rough
10:22:50 <sproingie> wasn't there a t-shirt with "What part of [written out algorithm W] don't you understand?"
10:24:48 <quinor> sproingie: the deal is there are some gimmicks if you add recursion
10:24:54 <quinor> without that it's all fine and simple
10:24:55 <cocreature> quinor: http://dev.stephendiehl.com/fun/006_hindley_milner.html
10:25:37 <quinor> cocreature: nothing on recursion and algebraic datatypes, already read that :/
10:25:45 <quinor> thanks though, that's a good one
10:29:11 <codygman_> glguy: nope. New example: [Right 1, Left "a"] ^.. filtered _Right
10:29:27 <codygman_> > [Right 1, Left "a"] ^.. filtered _Right
10:29:30 <lambdabot>  error:
10:29:30 <lambdabot>      • Couldn't match type ‘p a’ with ‘[]’
10:29:30 <lambdabot>        Expected type: Getting
10:29:38 <glguy> codygman_: Have you looked the type of filtered yet?
10:30:08 <codygman_> Yes, though it was very ​quickly right before lunch
10:30:08 <glguy> or the documentation for it?
10:30:17 <glguy> I'd recommend going back to that first
10:30:44 <cocreature> > [Right 1, Left "a"] ^.. traverse . _Right
10:30:46 <lambdabot>  [1]
10:30:49 <glguy> Until you get more experienced with the lens package, guessing will be tougher
10:31:09 <cocreature> the important part of the type of filtered is even understandable :)
10:33:18 <codygman_> Will go back and reread, thanks glguy
10:33:58 <cocreature> codygman_: the short answer is: filtered expects a predicate "a -> Bool" not a prism
10:35:57 <sproingie> maybe it's my brain operating on a 5 year old level, but my hardest time reading all the greek in papers is not really knowing how to read them aloud
10:36:20 <exarkun> it makes a difference
10:36:35 <exarkun> if you don't know what they sound like, it's a lot harder to remember them, tell them apart, etc
10:36:44 <exarkun> it's how human brains work
10:36:51 <EvanR> sproingie: heh... can you read haskell aloud?
10:36:58 <exarkun> go memorize the greek alphabet :/
10:37:01 <sproingie> i end up looking at my greek alphabet printout then stumbling.  "gamma implies alpha with type tau therefore ..."
10:37:27 <EvanR> and some professors have weird ways of saying some of them
10:37:46 <codygman_> cocreature: thanks as well!
10:42:09 <monochrom> Good thing I put "Ω is Greek capital Omega" in my lecture slides.
10:42:14 <sproingie> anyway it's less the greek letters so much as the connectives, the whole sentence if you will
10:42:26 <EvanR> ah ohms
10:43:33 <dmwit> Perhaps a fun sigbovik paper would be using all the wrong metavariable conventions in an otherwise perfectly conventional paper.
10:43:45 <sproingie> ξ (xi) is one that throws me.  excessive squiggliness.
10:43:56 <dmwit> Oh, that's not just pronounced "tornado"?
10:44:54 <EvanR> ξ zai? ksai? 
10:44:58 <lyxia> depending on the font it looks like an epsilon which hit a wall
10:45:03 <EvanR> xi isnt really english
10:45:10 <EvanR> its a roman numeral
10:45:11 <sproingie> i suspect it's greek :)
10:45:16 <monochrom> dmwit: Oh w00t! Let h be a group, G be its identity element, e be a homomorphism...
10:45:19 <sproingie> well romanized greek
10:45:31 <sbrg> lyxia: so it's a persian epsilon
10:45:40 <dmwit> monochrom: Let * \in h and consider *+*2
10:45:44 <sproingie> i thought "bananas, lenses and barbed wire" was a parody of mathematical notation
10:45:48 <sproingie> even today i'm not sure
10:46:23 <paolino> ksee
10:46:35 <monochrom> But the real disease is mathematicians refusing to use multiple-letter identifiers.
10:46:39 <wayne> i just wanted to say that i love pandoc.
10:46:53 <sproingie> zee i thought.  then there's chi, where according to knuth, saying it should make your screen slightly moist
10:47:06 <monochrom> And that somehow CS people refuse to improve upon it.
10:47:11 <sproingie> doh, *zeye*
10:47:47 <dmwit> monochrom: I did that in a draft of a paper once. My coauthors made me change it to avoid confusing people or having to add a sentence saying "we use multiple-letter variable names"...
10:47:59 <sproingie> monochrom: mathematicians and haskell library developers yes.  but types are documentation, right?
10:48:05 <Tuplanolla> Engineers and economists have adopted multiple-letter variables like FWHM that are impossible to distinguish from products, monochrom.
10:48:28 <sproingie> we should just switch to chinese
10:48:36 <csaurus> I have a question about doing a list of actions, but stopping after some condition is reached. Would lazy evaluation forgo evaluating calls before the first 'Just' in the following code:
10:48:43 <csaurus> foldl (<|>) Nothing [Nothing, Nothing, Just 1, Just 2, Nothing, Just 3]
10:48:51 <monochrom> Tuplanolla, I am with Dijkstra on this. Multiplication needs a visible operator.
10:49:02 <csaurus> *calls after the first 'Just'
10:49:04 <briansteffens> i'm getting a parse error on a file compiled with 'cabal build' but it works with 'ghc'. does cabal build not use ghc internally?
10:49:15 <dmwit> > foldl (<|>) Nothing [Nothing, Nothing, Just 1, undefined]
10:49:17 <lambdabot>  Just 1
10:49:22 <dmwit> csaurus: GHC says yes!
10:49:24 <sproingie> monochrom: i thought that was ×
10:49:29 <monochrom> Yes.
10:49:38 <monochrom> So write it out all the time.
10:49:44 <dmwit> csaurus: Well. The calls will probably still happen. But the arguments won't get forced.
10:49:48 <csaurus> dmwit: oh yay! thank you! I think this is a pattern I can work with
10:49:54 <sproingie> monochrom: that'd make high school algebra awful noisy
10:49:56 <dmwit> > foldl (<|>) Nothing (Nothing:Nothing:Just 1:undefined)
10:49:58 <lambdabot>  *Exception: Prelude.undefined
10:50:18 <dmwit> csaurus: The above highlights the distinction, I think. Your foldl isn't going to work on an infinite list, e.g.
10:50:41 <dmwit> csaurus: (foldr is the canonical fold for lazy languages)
10:50:53 <dmwit> > foldr (<|>) Nothing (Nothing:Nothing:Just 1:undefined)
10:50:55 <lambdabot>  Just 1
10:51:04 <briansteffens> nevermind, used 'cabal build -v' to see the command line args to ghc, think i can figure it out
10:51:16 <csaurus> dmwit: hmm okay - is there a reason foldr is? I always thought that would result in a long change of thunks
10:51:47 <dmwit> csaurus: https://wiki.haskell.org/Foldr_Foldl_Foldl'
10:51:48 <hexagoxel> briansteffens: default extensions seem the most likely culprit of differences.
10:52:21 <csaurus> dmwit: Thanks, also is there a more idiomatic way to express what I wrote? The idea of going through a list but stopping early on some condition?
10:52:41 <dmwit> csaurus: Oh, actually, https://wiki.haskell.org/Fold is probably better.
10:52:45 <dmwit> :t asum
10:52:47 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:53:07 <monochrom> I will just link you to what Dijkstra wrote: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1300.html
10:53:08 <dmwit> > asum (Nothing:Nothing:Just 1:undefined)
10:53:10 <lambdabot>  Just 1
10:53:42 <sproingie> they're both good pages, but the latter is kind of required reading for the former
10:53:46 <csaurus> > asum (Nothing:Nothing:Just 1: Just 2:undefined)
10:53:48 <dmwit> csaurus: foldr (or manual recursion) is the canonical way to stop early on some condition when processing a list. But in most cases there is a more specific function that is more idiomatic.
10:53:48 <lambdabot>  Just 1
10:54:15 <csaurus> dmwit: okay, thank you! I will do some reading
10:55:18 <Zaghie> anybody home?
10:56:09 <cocreature> Zaghie: just ask your questions directly :)
10:56:32 <sproingie> the magic of foldr is laziness.  if you don't use the second arg, the whole thing short-circuits
10:56:57 <Tuplanolla> @let wrap a b x = let c = b - a in x - c * floor ((x - a) / c) :: Double -- This thing periodically shifts `x` between `a` and `b`.
10:56:58 <lambdabot>  .L.hs:167:39: error:
10:56:58 <lambdabot>      • No instance for (Integral Double) arising from a use of ‘floor’
10:56:58 <lambdabot>      • In the second argument of ‘(*)’, namely ‘floor ((x - a) / c)’
10:57:09 <Tuplanolla> (Close enough anyway.)
10:57:19 <Tuplanolla> How should I define an analogous function for `Word8`?
10:59:20 <csaurus> sproingie: Thanks! that's kind of what I was going for with Maybe and Alternative, better to use foldr though
10:59:25 <Zaghie> cocreature thanks I'm new to this. could somoene explain what a monad is?
10:59:48 <dmwit> Tuplanolla: wrap a b x = a+b-x -- ?
10:59:55 <sproingie> csaurus: these days you can fold over damn near anything, so you might end up using both
10:59:56 <Zaghie> tutorials tend to be very confusing and/contradictory on Monads
11:00:15 <sproingie> Zaghie: they're kind of infamous in that way
11:00:19 <cocreature> Zaghie: do you already understand Functor and Applicative?
11:00:32 <Tuplanolla> No, dmwit.
11:00:40 <Zaghie> Not really, wanted to start with Monads, should I do those first?
11:00:46 <Cale> Zaghie: Do you know about data types with parameters?
11:00:49 <sproingie> monads are simply endotortillas in the category of burritos
11:00:58 <Zaghie> yes I know about datatypes with parameters
11:01:15 <cocreature> Zaghie: yeah, I recommend first learning Functor, then Applicative and then look at Monad
11:01:19 <dmwit> Tuplanolla: Can you expand that rejection a bit with a reason?
11:01:20 <Cale> Zaghie: A monad is a data type with a single parameter (i.e. it has kind * -> *) which has a particular interface defined on it.
11:01:23 <cocreature> Zaghie: do you understand typeclasses?
11:01:32 <Zaghie> I understand typeclasses
11:01:47 <Cale> Specifically, if M is our parametric type, we need definitions of:
11:01:51 <Cale> return :: a -> M a
11:01:52 <Cale> and
11:02:00 <Cale> (>>=) :: M a -> (a -> M b) -> M b
11:02:06 <dmwit> @let wrap a b x = let c = b - a in x - c * fromInteger (floor ((x - a) / c)) :: Double
11:02:07 <Cale> which satisfy some properties
11:02:07 <lambdabot>  Defined.
11:02:13 <sproingie> (not that said capitalization scheme will work in haskell)
11:02:18 <dmwit> > (wrap 5 10 10, wrap 5 10 5)
11:02:20 <lambdabot>  (5.0,5.0)
11:02:29 <dmwit> ?let wrap' a b x = a+b-x
11:02:30 <lambdabot>  Defined.
11:02:36 <dmwit> > (wrap' 5 10 10, wrap' 5 10 5)
11:02:38 <lambdabot>  (5,10)
11:02:46 <Cale> This pattern shows up a fair amount, when, say M a is supposed to represent some sort of computations whose result will have type a
11:02:49 <Tuplanolla> The idea is to find the `k` that solves the equation `m == n - a + k * a` with the constraint `a <= m < b`, dmwit.
11:02:59 <sproingie> for some examples of the pattern: https://philipnilsson.github.io/Badness10k/posts/2017-05-07-escaping-hell-with-monads.html
11:03:02 <Zaghie> Cale: ok, so we wrap a in M?
11:03:10 <Cale> Then return v will be the computation which does nothing, but produces v as a result
11:03:13 <sproingie> it doesn't explain what monads are, but it does explain what (some of them) do
11:03:51 * shapr hops randomly
11:03:53 <Zaghie> monads are used to wrap values?
11:04:04 <monochrom> Zaghie, wrapping is usually a very misleading model.
11:04:10 <Cale> and x >>= f will be the computation which, when run, will first run x :: M a, obtaining its result v of type a, and then applies f :: a -> M b to decide which action to take next
11:04:20 <Cale> (and produces the result of that second action as its own)
11:04:24 <sproingie> it's more used to wrap *types*
11:04:33 <dmwit> > wrap 5 10 11
11:04:35 <lambdabot>  6.0
11:04:42 <monochrom> I recommend just following Cale without any presumption or jumping to conclusion.
11:04:54 <Tuplanolla> So for example `fmap (\ n -> f n 7 11) [0 .. 255]` would be `repeat [8, 9, 10, 7]`, dmwit.
11:05:17 <Tuplanolla> Sorry, `wrap` instead of `f` there.
11:05:31 <Cale> Zaghie: There are a lot of specific examples of monads, and you'll understand what the abstraction means best just by picking up examples over time.
11:05:48 <Zaghie> thanks, ok so it performs f over type a and combines it with b in M as the result? thanks for explaining this Cale
11:05:59 <sproingie> Zaghie: you got it
11:06:14 <Cale> Zaghie: You shouldn't usually think of M as "wrapping" something.
11:06:19 <dmwit> ?let wrap'' a b x = ((x - a) `mod` (b-a+1)) + a
11:06:21 <lambdabot>  Defined.
11:06:23 <Cale> It could, but that would be a boring example.
11:06:35 <dmwit> > map (wrap'' 5 10) [5,6,7,8,9,10,11,12,13]
11:06:37 <lambdabot>  [5,6,7,8,9,10,5,6,7]
11:06:40 <Zaghie> Cale: haha, what's a more appropriate example?
11:06:42 <dmwit> Tuplanolla: ?
11:06:46 <Cale> Zaghie: Consider for example, the type IO, which happens to be a monad
11:06:52 <Cale> We have  getLine :: IO String
11:07:05 <dmwit> > map (wrap'' 7 11) [0..255]
11:07:07 <lambdabot>  [10,11,7,8,9,10,11,7,8,9,10,11,7,8,9,10,11,7,8,9,10,11,7,8,9,10,11,7,8,9,10,...
11:07:11 <Cale> Its result will be the string that the user types
11:07:14 <sproingie> IO is hard to use as an example since there's no looking under the hood unless you want to go explain ST RealWorld
11:07:18 <Cale> So the result can't be wrapped up in there
11:07:30 <Cale> sproingie: Well, I could make a simple version of IO
11:07:45 <Zaghie> true, so how is it handled in that case? or what's the mental model in IO?
11:07:50 <monochrom> IO is an excellent example because you can't look under the hood.
11:07:59 <dmwit> Tuplanolla: Oops, off-by-one. =)
11:08:16 <dmwit> ?let wrap''' a b x = ((x-a) `mod` (b-a)) + a
11:08:17 <lambdabot>  Defined.
11:08:19 <sproingie> monochrom: no, it implies that all monads are about keeping types in a jail they can't escape from
11:08:23 <dmwit> > map (wrap''' 7 11) [0..255]
11:08:25 <lambdabot>  [8,9,10,7,8,9,10,7,8,9,10,7,8,9,10,7,8,9,10,7,8,9,10,7,8,9,10,7,8,9,10,7,8,9...
11:08:31 <sproingie> and that's only true for IO (well ST really)
11:08:35 <Cale> One mental model would be something like:  data IO a = Done a | GetLine (String -> IO a) | PutLine String (IO a) | ...
11:09:02 <Cale> and then we'd have  getLine = GetLine (\str -> Done str)
11:09:10 <codygman_> Is there a way to preserve the Prism matched on in: data A { a :: Int }; [A 1] ^.. traverse . _A --gives [(1)] but I'd rather have the type as well.
11:09:11 <mniip> sproingie, how is "an <...> example" related to "all monads"
11:09:11 <Tuplanolla> > and (zipWith (==) (fmap (\ n -> wrap''' n 7 11) [0 .. 255]) (concat (repeat [8, 9, 10, 7])))
11:09:13 <lambdabot>  False
11:09:25 <Cale> and  putStrLn s = PutLine s (Done ())
11:09:31 <Tuplanolla> > and (zipWith (==) (fmap (\ n -> wrap''' n 7 11) [minBound .. maxBound :: Word8]) (concat (repeat [8, 9, 10, 7])))
11:09:33 <lambdabot>  False
11:09:39 <Tuplanolla> Doesn't seem to hold, dmwit.
11:09:45 <dmwit> > and (zipWith (==) (fmap (wrap''' 7 11) [0..255]) (concat (repeat [8,9,10,7])))
11:09:47 <lambdabot>  True
11:09:48 <sproingie> mniip: human nature to fixate on the first example as representative of the whole
11:09:55 <dmwit> Tuplanolla: My argument order is just different than yours.
11:09:57 <EvanR> > take 3 $ foldl (flip (:)) [] [1,undefined,3,4,5]
11:09:58 <mniip> doesn't have to be the first
11:09:59 <lambdabot>  [5,4,3]
11:09:59 <sproingie> god knows i did, as did many others
11:10:08 <Tuplanolla> Oh, whoops.
11:10:11 <Cale> Zaghie: Another example would be a type of parsers:
11:10:21 <dmwit> Tuplanolla: Also: `cycle` is better than `concat . repeat`. ;-)
11:10:33 <EvanR> > take 3 $ foldl' (flip (:)) [] [1,undefined,3,4,5]
11:10:35 <lambdabot>  [5,4,3]
11:10:43 <Cale> With a value of type Parser a being something which knows how to consume the initial portion of a String to produce a result of type a
11:10:54 <Tuplanolla> Yeah. I forgot the name in hurry, dmwit.
11:11:08 <dmwit> Tuplanolla: By the way, there is `mod'` if you want a similar implementation for `Double`.
11:11:15 <Cale> (possibly -- maybe even in multiple ways, if you want backtracking)
11:11:24 <sproingie> mniip: is why i like to start with Maybe.  but i'm drowning out Cale's signal with my kibitzing :)
11:11:31 <sproingie> http://www.willamette.edu/~fruehr/haskell/seuss.html
11:11:40 <Tuplanolla> I just don't see how your solution works with wrapping, since `x - a` already goes around if `x < a`, dmwit.
11:12:01 <mniip> that's a terrible parser type
11:12:07 <dmwit> Tuplanolla: mod don't care
11:12:13 <Zaghie> Cale: ah that makes sense. So Parser a can consume the first, and subsequent parts of a String to return a
11:12:14 <Cale> sproingie: Well, the misconception I was trying to address was the thought that M t is supposed to "wrap" some value of type t
11:12:20 <mniip> ok, maybe not terrible but at least it's not perfect
11:12:25 <Cale> sproingie: So Maybe would perhaps not have done as well at that :)
11:12:26 <sproingie> mniip: oh FFS it's baby's first parser, it's for an educational lecture
11:12:39 <Tuplanolla> What if I worked modulo a prime number instead of 256, dmwit?
11:12:51 <Zaghie> Cale: thank you, it illustrates the point perfectly :)
11:12:55 <Cale> Zaghie: Yeah, return v will be the parser which consumes none of the input, and produces v as its result
11:13:36 <Cale> Zaghie: and x >>= f will be the parser which eats the initial portion of the input with x, obtaining some result(s) v, and then uses f v to parse the remainder of the input
11:13:49 <dmwit> Tuplanolla: Hm, now I'm curious.
11:14:33 <dmwit> ?check \(Positive n) -> ((-n) `mod` 7) == fromIntegral (fromInteger (-n) `mod` 7 :: Word8)
11:14:35 <lambdabot>  *** Failed! Falsifiable (after 1 test):
11:14:35 <lambdabot>  Positive {getPositive = 1}
11:14:45 <Zaghie> oh wow, and a "portion" of the string is a character?
11:14:50 <dmwit> Tuplanolla: You're right. `x - a` does seem dangerous.
11:14:55 <Zaghie> or defined by f?
11:14:58 <dmwit> ?src String
11:14:58 <lambdabot> type String = [Char]
11:15:03 <dmwit> Zaghie: ^^
11:15:06 <Cale> mniip: The Dr Seuss one?
11:15:41 <Zaghie> thanks dmwit, Cale and everyone else!
11:16:11 <Cale> mniip: It's great for learning from -- actually, I was half considering launching into a full explanation of how to write that Monad instance...
11:16:17 <dmwit> Tuplanolla: Well, you could convert to an Int16 first...
11:16:35 <Tuplanolla> And when using `Word64`...
11:16:35 <dmwit> Tuplanolla: (Which should be big enough to faithfully hold the result of a Word8 - Word8, I think.)
11:16:40 <mniip> Cale, now that I think about it my original argument might have been invalid
11:16:45 <dmwit> Tuplanolla: Integer. ;-)
11:16:50 <Zaghie> Cale: that would be awesomne
11:16:59 <Zaghie> if you want to do that :)
11:17:07 <Tuplanolla> Then `Word64#`...
11:17:10 <EvanR> can foldl get the last element of a list "lazily", i.e. without consuming all the thunks it makes
11:17:14 <mniip> Cale, the problem with stuff like (\s -> (reverse s, ()))
11:17:33 <sproingie> i remember A Gentle Introduction introducing the state monad from first principles, which goes and abbreviates the constructor as ST
11:17:48 <sproingie> so i went looking into ST and was utterly baffled
11:18:17 <dmwit> Tuplanolla: Well, you could look into the usual mathematical representation of integers in terms of nats and see if you can abuse it.
11:18:19 <sproingie> not helped by them being related ideas
11:18:31 <monochrom> "ADT" will also get you into much trouble.
11:18:34 <EvanR> > foldl (const id) 5 [0..1000000]
11:18:37 <lambdabot>  1000000
11:18:41 <Tuplanolla> There's a trivial recursive implementation, but it's unsatisfying, dmwit.
11:18:55 <EvanR> ok
11:18:58 <Tuplanolla> That is, add or subtract `b - a` until done.
11:19:05 <monochrom> algebraic data type vs abstract data type. Complete bipolar opposites.
11:19:06 <dmwit> Tuplanolla: namely you introduce `-` as a formal symbol and take the equivalence class under the usual equality, so `a-b = c-d` means `a+d = b+c`.
11:19:09 <Cale> Also, if you replace String with Text, it's really not so bad at all. I've written at least one parser we're using in production in (more or less) that way.
11:19:44 <dmwit> Dunno how hard mod is in that representation, though, never thought about it before.
11:19:47 <dmwit> Probably pretty hard.
11:20:00 <Tuplanolla> Man, I always get sidetracked into number theory.
11:20:17 <dmwit> ```(a-b) `mod` (c-0)``` is probably pretty easy, though, so if you believe your mod is going to be positive... =)
11:21:00 <Cale> Zaghie: okay, perhaps we should hold it in #haskell-overflow just because it's best if the definitions don't scroll away too quickly :)
11:21:20 <Zaghie> ok, I'll meet you there :)
11:22:03 <dmwit> ?check \a b x -> ((x-a) `mod` (b-a)) == ((x `mod` (b-a)) - (a `mod` (b-a)) `mod` (b-a :: Integer))
11:22:05 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
11:22:05 <lambdabot>  0 0 0
11:22:17 <dmwit> ?check \(Positive a) (Positive b) (Positive x) -> ((x-a) `mod` (b-a)) == ((x `mod` (b-a)) - (a `mod` (b-a)) `mod` (b-a :: Integer))
11:22:19 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
11:22:19 <lambdabot>  Positive {getPositive = 1} Positive {getPositive = 1} Positive {getPositive ...
11:22:27 <monochrom> sproingie: I am not sure what you mean by "jail of types", but my interpretation is that it's exactly what the monad operations (or rather, what they lack) suggest, so nothing wrong. I have disagreement on "wrap a type", for every time I write "data X a = ..." X wraps a type, but depending on the "..." I might not even have a functor.
11:23:08 <dmwit> ?check \(Positive a) (Positive x) (Positive m) -> ((x-a) `mod` m) == ((x `mod` m) - (a `mod` m) `mod` (m :: Integer))
11:23:11 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 3 shrinks):
11:23:11 <lambdabot>  Positive {getPositive = 4} Positive {getPositive = 2} Positive {getPositive ...
11:23:52 <monochrom> To be sure, "jail of types" even when it's right it's putting the focus on the wrong guy. In "IO Int" the most interesting part is the "IO" part not the "Int" part.
11:24:19 <monochrom> Likewise in "[] Int" the most interesting part is the "[]" part.
11:24:42 <dmwit> ?check \(Positive a) (Positive x) (Positive m) -> ((x-a) `mod` m) == (((x `mod` m) - (a `mod` m)) `mod` (m :: Integer))
11:24:44 <lambdabot>  +++ OK, passed 100 tests.
11:24:45 <dmwit> Tuplanolla: So that should help.
11:25:06 <ph88> when i use Vector Unboxed and i get  index out of bounds (101,101)   what do those 2 numbers mean ?
11:25:15 <Tuplanolla> It's for unbounded integers though, dmwit.
11:25:16 <dmwit> Tuplanolla: Now you just have to check whether ```x `mod` m``` or ```a `mod` m``` is bigger.
11:25:31 <dmwit> Tuplanolla: Yes, but the fact that it teaches you can be used on bounded, positive integers.
11:25:46 <Tuplanolla> Oh, right.
11:25:56 <wayne> what's it called when you build your own pseudo type system in a type system?
11:26:06 <wayne> say i'm writing an attribute system for transactions
11:26:06 <exio4> wayne: masochism?
11:26:14 <wayne> attributes can be Strings, Ints, DateTime, etc.
11:26:16 <wayne> hah
11:26:30 <sproingie> wayne: programming
11:26:43 <wayne> well, yes, i'd agree
11:27:00 <wayne> i was wondering if there was a more specific term for it. i've seen it crop up in a variety of large software systems
11:27:16 <sproingie> well consider almost all programming is an exercise in extending the built-in facilities
11:27:29 <wayne> yeah, or even creating new DSLs per program
11:27:45 <sproingie> complete reinvention i suppose you could call greenspunning
11:28:14 <sproingie> slightly ironic term considering it normally applies to a dynamically typed language
11:28:29 <cocreature> wayne: I think I’ve heard it called “type universe pattern” or something like that
11:28:37 <wayne> but this paticular style of implementation involves creating something like a new AttrString type with special abilities
11:28:45 <monochrom> wayne, user-defined types?
11:28:53 <wayne> yeah maybe, thanks for the suggestions
11:29:12 <monochrom> It's a known concept since 1960 or something. See Algol 60.
11:29:20 <sproingie> "inner platform effect"
11:30:02 <sproingie> (probably why i equated it with programming.  ad hoc inner platforms seems to be all i do now)
11:30:38 <monochrom> Also "abstract data type" if you mean for example "internally it's a string but I'm exposing a limited API".
11:31:26 <sproingie> "abstract" is itself kind of abstract
11:31:27 <monochrom> and "oh one day I might change the internal implementation while keeping the external promises. I may use a number instead and pull a Goedel trick"
11:32:35 <monochrom> which is also a known concept since 1960. See Algol 60 again.
11:32:48 <Tuplanolla> @let wrapHarder a b n = let c = b - a in mod (mod n c - mod a c) c + a
11:32:50 <wayne> an example of usage would be constructing a computation graph with typed nodes. maybe this node takes three Int-output nodes and outputs an Int itself: Node :: AttrInt -> AttrInt -> AttrInt -> AttrInt
11:32:50 <lambdabot>  Defined.
11:32:54 <sproingie> isn't the collection of operations itself a simple algebraic type?
11:33:00 <monochrom> To be sure, CLU did abstract types best.
11:33:01 <james999> In java class they always talked about separating interface from implementation like it was gospel.
11:33:20 <Tuplanolla> > and (zipWith (==) (fmap (wrapHarder 7 12) [minBound .. maxBound :: Word8]) (cycle [10, 11, 7, 8, 9]))
11:33:22 <lambdabot>  False
11:33:49 <sproingie> it is gospel.  java was just not the best preacher of it til generics rolled around.
11:34:14 <monochrom> sproingie, there are two kinds of "algebra"s. So yes, it is one kind.
11:34:17 <wayne> you can't just use Int because the function would be setting up a node that does computation, and not running a computation directly
11:34:38 <Tuplanolla> > and (zipWith (==) (fmap (wrapHarder 7 12) [0 .. 255]) (cycle [10, 11, 7, 8, 9]))
11:34:40 <lambdabot>  True
11:34:54 <Tuplanolla> It still wraps around at some other point, dmwit.
11:36:37 <Tuplanolla> I need a napkin for this.
11:36:42 <monochrom> In Haskell, the "algebraic" in "algebraic data type" just means sums and products. (Oh, and then they decided to support exponentiation and recursion too. Now it gets a bit too analytic to be algebraic.)
11:37:35 <sproingie> exponentiation is ... parameterized type?
11:37:39 <wayne> monochrom: when you say exponentiation do you mean recursion within a product type?
11:38:14 <monochrom> Outside Haskell, "algebraic" often refers to the same sense as "universal algebra". In short it means user-conceived operators and writing equational laws. See for example "algebraic specification".
11:38:15 <sproingie> i need to re-watch those CT lectures
11:38:34 <monochrom> wayne, it means "Int -> Double" for example. Functions.
11:39:00 <monochrom> data X = X1 (Int -> Double) | X2 (Double -> X)
11:39:51 <monochrom> well this example features both exponential and recursion. If you have only X1, it's expoenentiation.
11:40:02 <monochrom> And I can't spell.
11:40:40 <wayne> thanks for clarifying
11:41:26 <Tuplanolla> Nobody reads beyond exp anyway, monochrom.
11:41:48 <monochrom> Anyway, sums and products get called "algebraic" because simply "polynomials!"
11:42:01 <wayne> does that make partial function application the equivalent of log?
11:42:11 <monochrom> No.
11:42:12 <shapr> polynameial
11:42:36 <sproingie> polyamourous functions
11:43:28 <shapr> Is that multiple dispatch?
11:44:00 <sproingie> heh seems appropriate
11:45:00 <EvanR> is unsafe the right word for a primitive that if used incorrect can cause bad performance
11:45:05 <EvanR> or really bad performance
11:45:09 <EvanR> if not what is
11:45:41 <monochrom> No no, you get it the other way round.
11:45:41 <sproingie> considering an actually unsafe implementation might be faster ...
11:45:48 <monochrom> Yeah :)
11:46:10 <EvanR> safeABitTooSafeFoo ?
11:46:11 <sproingie> if you really want to deprecate it ... maybe just "slow"
11:46:13 <Tuplanolla> You can call it `slow`, EvanR. There's no need to play word games.
11:46:19 <monochrom> "unsafe" means it always performs better, but if used incorrectly you break equational reasoning or types or ... those semantics things.
11:46:40 <EvanR> its not slow, it uses infinite memory but only if you mess up
11:46:57 <sproingie> sounds like most of haskell to me :)
11:47:02 <EvanR> right...
11:47:05 <monochrom> Oh, 50% of safe pure functions do that already.
11:47:13 <sproingie> thunkedUp
11:47:23 <monochrom> Consider foldl (+) 0 infinitelist
11:47:25 <sproingie> makeItThunky
11:47:27 <Tuplanolla> I nominate the prefix `gluttonous`.
11:47:32 <EvanR> hrmmm
11:48:05 <sproingie> we should have prefixes using all seven deadly sins
11:48:06 <monochrom> So use the prefix "verySafe" :)
11:48:06 <EvanR> totallyNormalFunctionNothingToSeeHereFoo
11:48:13 <sproingie> lustfulFoo
11:48:17 <sproingie> wrathfulBar
11:48:27 <Tuplanolla> @hoogle lewd
11:48:27 <lambdabot> No results found
11:48:35 <Tuplanolla> What a wasted opportunity.
11:49:09 <sproingie> in EvanR's case, you could call it slothfulFoo
11:49:44 <barrucadu> Would a function which can break sharing be "envious"?
11:50:17 <monochrom> narcist :)
11:50:20 <torstein> One character in a standard bytestring is a Data.Word.Word8, right? How can I check, for example, if the first character of a bytestring is uppercase?
11:50:43 <monochrom> privatization :)
11:50:44 <sproingie> barrucadu: i'm a fan of the word "covetous" :)
11:50:56 <Tuplanolla> What do you mean by character, torstein?
11:51:06 <sproingie> in fact i've heard "covetous APIs", they want to own everything you pass in to them
11:51:11 <sproingie> mostly a C++ idiom
11:51:14 <glguy> Word8 doesn't have a notion of upper case
11:51:55 <torstein> So does everything become lowercase when converting to a standard Bytestring and back to string?
11:52:07 <sproingie> one would hope not
11:52:08 <monochrom> :)
11:52:18 <Tuplanolla> In Haskell "char" like the "charred remains of single-byte encoding" is a foreign concept, torstein.
11:52:29 <monochrom> Will glguy also say "doesn't have lower case either"?
11:52:37 <barrucadu> How characters map to bytes is up to the character encoding
11:52:52 <chrissound> How can I get the index of the current workspace? 
11:52:54 <geekosaur> and a huge part of the problem here is everyone assumes that 'a character is a character'
11:53:09 <barrucadu> If you're using ASCII, one character is one byte.  If you're using unicode, that's not true.
11:53:14 <geekosaur> encodings make that... complicated and sometimes undefined
11:53:15 <monochrom> Just yesterday we just taught someone how Int8 doesn't have a notion of 253 either.
11:53:44 <sproingie> and for an encore, went on to prove that black is white and got yourself run over at the next zebra crossing?
11:53:46 <torstein> I'm working on Stanfords haskell course; they want me to write a parser with bytestrings
11:54:01 <Taneb> barrucadu, Haskell report says Char represents Unicode characters
11:54:16 <chrissound> I've tried deriving an instance by `deriving instance Eq (Layout Window)` and then using elemIndex but I get a type error of sorts. 
11:54:17 <geekosaur> chrissound, if that's about xmonad, (1) might be better to ask in #xmonad (2) withWindowSet (W.tag . W.current) (where: import qualified XMonad.StackSet as W)
11:54:28 <shapr> torstein: sounds like fun
11:54:42 <chrissound> Ooops sorry I thought I was in #xmonad.
11:54:49 <barrucadu> Taneb: A Haskell Char is not the same as the abstract concept of a character
11:54:54 <geekosaur> and you likely want to read the haddock for XMonad.StackSet instead of making assumptions about how things work
11:54:57 <torstein> Whether I use ASCII or unicode is the same for me; is there anyway to check if a character is upper or lowercase?
11:55:11 <sproingie> unicode codepoints anyway.  "character" is way ambiguous when talking about unicode
11:55:18 <geekosaur> torstein, you just proved my point
11:55:24 <sproingie> torstein: isUpper
11:55:25 <torstein> Then lets say it's ASCII
11:55:33 <Tuplanolla> Nooo! UTF-8 everywhere.
11:55:35 <Taneb> barrucadu, my point was, there is an encoding that is specified
11:55:45 <Taneb> torstein, Data.Char.isUpper
11:55:57 <sproingie> technically you need both isUpper and isLower
11:56:05 <Taneb> > any isUpper "torstein"
11:56:08 <lambdabot>  False
11:56:10 <Taneb> > any isUpper "Torstein"
11:56:12 <lambdabot>  True
11:56:31 <monochrom> torstein, show us where to read the assignment verbatim so we can either tell you what they want or we tell them they are wrong.
11:57:20 <torstein> monochrom, http://www.scs.stanford.edu/16wi-cs240h/labs/lab2.html You'll have to look into the source code for the ByteString requirement
11:57:51 <torstein> isUpper takes a Char, but decomposing a standard ByteString with cons yields a Word8
11:57:54 <monochrom> Did you see this? "Your parser should support ASCII input files; UTF-8 is fun but not required."
11:58:12 <sproingie> looks like it doesn't actually require bytestring either, it just recommends it
11:58:15 <monochrom> It's like merely the 10th line.
11:58:25 <sproingie> if you're doing unicode, use Text
11:58:50 <sproingie> (or just plain String if it doesn't have to be fast)
11:59:19 <monochrom> Haha it also has "suggested music"
11:59:48 <sproingie> flaming lips?  could be worse, i suppose.
11:59:53 <EvanR> torstein: you can convert a Word8 to a Char using an ascii decoder (which may fail)
12:00:48 <torstein> I think a solution is to assume ASCII; use ByteString.Char8 instead of standard BS, then decomposing with cons yields a Char character instead of a Word8 character
12:00:56 <EvanR> you can also assume no byte over 127 appear and use ByteString.Char8
12:01:40 <sproingie> make it work with ascii and unicode will be pretty trivial.  polymorphic string types FTW.
12:02:04 <EvanR> you mean the other way around?
12:02:11 <sproingie> well it
12:02:17 <sproingie> well it's totally trivial then
12:02:20 <EvanR> yes
12:02:58 <EvanR> assuming ascii is a great way to make your life hell when mr Thévenin calls pissed about his name misspelled
12:03:03 <sproingie> but still easy enough to switch unless you're doing something really silly
12:03:37 <EvanR> or mojibked
12:03:39 <monochrom> sproingie: To a large extent the starter code and more importantly the test cases have ByteString written all over it.
12:04:09 <exarkun> Extra credit for fixing the test suite.
12:04:25 <EvanR> make a test suite test suite
12:04:40 <monochrom> I'm actually OK with "ByteString and it stores UTF-8".
12:04:47 <sproingie> > fix testSuite
12:04:48 <lambdabot>  error:
12:04:49 <lambdabot>      Variable not in scope: testSuite :: a -> a
12:04:49 <EvanR> or a fix ("test suite "++)
12:05:15 <monochrom> But last thing you want is live the 1970s pipe dream of "it's just one byte per char".
12:05:31 <Tuplanolla> Half, even!
12:05:43 <EvanR> other national encodings use the whole byte
12:05:52 <sproingie> i'd expect you'd be working with just Strings for the most part, not individual chars
12:06:01 <EvanR> america was just that alphabetically poor
12:06:14 <sproingie> use the polymorphic string functions and it's just a type change away
12:06:31 <monochrom> Now, is there any reason parsing INI requires knowing "this is uppercase"?
12:08:04 <torstein> monochrom, No, but converting to lowercase is necessary since most of the INI is supposed to be case insensitive
12:08:07 <monochrom> Ah I guess you need to treat "Yes" and "yes" as the same thing.
12:08:51 <EvanR> yeah in my program im trying to figure out how to handle text which case does not matter
12:08:52 <sproingie> so convert, not test.  guessing regexes are out of the question.
12:09:07 <monochrom> Case conversion is a very lazy way to do this.
12:09:28 <sproingie> eh, it works out the same
12:09:35 <EvanR> lazy, is that good or bad
12:09:49 <sproingie> EvanR: i'll let you know when you actually need the answer
12:10:19 <EvanR> if the answer is bottom keep it to yourself
12:10:35 <sproingie> don't worry, i'm not showing my bottom :)
12:10:55 <monochrom> What you really need is to accept [89 or 121, 69 or 101, 83 or 115]
12:12:56 <sproingie> ah, says don't change the interface of ParseIni.hs ... stuck with Bytestring after all
12:13:41 <sproingie> some profs are all right with improving the assignment with the answer, but they might hand it off to a TA who isn't
12:13:53 <bollu> monochrom: why do you want multiplication to be explicit?
12:13:56 <monochrom> Then again could do ByteString -> Text -> ByteString and have a party of XYX problems.
12:14:19 <monochrom> Because Dijkstra said so. No, because it play better with long variable names.
12:14:28 <bollu> monochrom: do tell?
12:14:33 <bollu> ah, I understand
12:14:40 <bollu> xyz is ambiguous
12:14:45 <bollu> xy * z or x * yz or ...
12:14:56 <sproingie> one reason we have programming languages in the first place
12:15:28 <shapr> sproingie: so we can be explicit about our confusion?
12:15:39 <monochrom> Dijkstra has great examples like sin(s+i+n) and 3½, 3y, 32.
12:15:46 <bollu> lol
12:15:53 <bollu> I see
12:15:55 <sproingie> 32 == 6, obviously
12:15:58 <ph88> hey cocreature i was able to speed that calculation up by 60x !!
12:16:04 <monochrom> The link is http://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1300.html again
12:16:31 <bollu> monochrom: on the other hand, it would make a lot of things quite large, methinks: eg: ut + 1/2 a t^2 becomes u * t + 1/2 * a * t^2
12:16:50 <sproingie> it's almost like different notation is useful for different things
12:17:07 <monochrom> I have actually heard someone made the outrageous rationalization "in 3y, consider 3 means the function (\x -> 3*x)"
12:17:07 <bollu> sproingie: then you need to keep track of which notation you're using when..
12:17:39 <monochrom> People really can use all of their creativity to defend a wrong entrenched convention.
12:17:51 <bollu> monochrom: not that outrageous :) that's how you can define the scalars acting on a vector space for example
12:18:17 <sproingie> just a humble polynomial would be way cluttered with explicit multiplication
12:18:39 <ph88> if i do   (5 - 2)  will ghc optimize this to 3 ? or will it make a thunk on runtime ?
12:18:50 <sproingie> ghc will fold constants
12:20:56 <sproingie> might need -O to do it, though that one's trivial enough it might do it anyway
12:21:35 <monochrom> It's best to read the Core.
12:21:54 <sproingie> wasn't sure if it optimized before or after generating core
12:22:30 <monochrom> Ah, true, read the asm too. :)
12:23:48 <monochrom> I usually dump all of Core, Cmm, asm at once. If Core answers my question, cool; else, Core is still a good guide when I try Cmm and asm.
12:24:26 <cocreature> ph88: nice, how so?
12:24:35 <monochrom> Especially with all those sat_xyz123abc unique names
12:25:22 <sproingie> numbers being overloaded, even that simple case has some twists to it
12:28:12 <sproingie> SPJ's lecture on Core was really informative.  a statically typed IR, how nifty.
12:28:16 <ph88> cocreature, line 30 https://bpaste.net/show/5ae7ec7d31b9 the important insight was that each part of the formula there is a sliding window over the vector. The index i is only offset by n or n*2 .. then all the values of those 3 windows are summed then   (sumA - sumB + sumC) ^ 2    .. but i just precalculated the sum per element with a scan (line 39)
12:28:42 <cocreature> nice
12:29:01 <ph88> cocreature, suppose the vector hold numbers 1 to 10, and i want the sum of a window that starts at 3 and ends at 7   i do value[7] - value[3 - 1]
12:33:38 <EvanR> sproingie: statically type all the things
12:35:15 <sproingie> speaking of types, is there any IDE integration for haskell that can fill in typed holes for you?
12:35:29 <monochrom> OK, for the sake of scientific reporting: I tried "module G where x :: Num a => a; x = 5 - 2". Core made it "x = fromInteger 5 - fromInteger 2". Cmm and asm didn't improve on it.
12:35:52 <sproingie> (where emacs is an IDE, yes)
12:36:03 <EvanR> how could it improve?
12:36:06 <monochrom> But this is only when I insist polymorphic Num a. If you nail it to Int or Integer or whatever, I'm sure it's 3.
12:36:20 <ph88> sproingie, what if i first do   one = 1   two = 2   and then   three = two - one  ?  will three be constant fold to 3 ?
12:36:51 <sproingie> i wouldn't have been surprised if it turned into "fromInteger 3", just assuming that even polymorphic numbers exist in a sane world
12:37:02 <EvanR> the top level number will be lazily evaluated and stay that way at run time
12:37:13 <sproingie> but you know what they say, assuming makes an ass of u and ming
12:37:13 <monochrom> actually I only tried -O. Let me now try -O2.
12:37:14 <EvanR> sproingie: you cant do that...
12:37:21 <merijn> EvanR: Only if not polymorphic or DMR is enabled
12:37:35 <EvanR> DMR?
12:37:46 <Cale> Dreaded Monomorphism Restriction
12:37:47 <merijn> EvanR: Dreaded Monomorphism Restriction ;)
12:37:48 <monochrom> -O2 isn't better.
12:37:54 <EvanR> right
12:38:03 <EvanR> well i was talking about not polymorphic
12:38:09 <EvanR> how does "DMR" apply to that
12:38:25 <merijn> EvanR: If you leave of the type signature DMR forces it to be not polymorphic
12:38:33 <merijn> EvanR: By specialising to the first usage of the value
12:38:34 <sproingie> DMR normally is enabled.  i used to hate it, then realized it was basically nagging me to write better signatures
12:38:44 <EvanR> so it doesnt apply if i set the signature, so i can make it not polymorphic at all
12:39:02 <merijn> EvanR: If you write an explicit signature DMR never applies, no
12:39:06 <EvanR> good
12:39:17 <EvanR> since its top level, id put a signature
12:39:33 <sproingie> DMR doesn't apply to let-bindings either, right?
12:39:35 <merijn> EvanR: But even if it did, DMR can only improve things. It stops you from silently making stuff worse
12:39:53 <EvanR> not sure what that means
12:39:54 <merijn> sproingie: DMR only applies to top-level "value-like" (i.e. non-function) things without a signature
12:39:57 <monochrom> DMR applies to let-bindings.
12:40:15 <merijn> monochrom: Really? I thought it was only to top-level bindings
12:40:23 <monochrom> I'm going to check again.
12:40:27 <EvanR> and where clauses
12:40:38 <merijn> EvanR: DMR ensures something is only evaluated once and produces an error when that's not possible.
12:40:58 <EvanR> got it
12:41:07 <sproingie> so basically it's "hey dude, your constant isn't"
12:41:08 <merijn> EvanR: So unless for some bizarre reason you hate efficiency and want to recompute things all the time, DMR either 1) makes stuff better or 2) is a compile error
12:41:15 <c_wraith> monochrom, beware of interference from MonoLocalBinds, which is automatically enabled by GADTs and a couple other extensions 
12:41:34 <EvanR> merijn: a bizarre reason like, the top level value is infinite
12:41:38 <monochrom> DMR applies to all bindings, local or global.
12:41:53 <EvanR> and ive been off and on wanting a way to turn values back into thunks...
12:41:54 <merijn> sproingie: basically, yes
12:42:20 <monochrom> You just don't usually feel its effect in local ones, because you explain the momorphism of the local ones by its context.
12:43:26 <sproingie> i learned ocaml before haskell, i hated the MR in that.  haskell's is way less onerous
12:43:33 <Cale> DMR applies only to pattern bindings which don't have explicit type signatures though
12:43:53 <Cale> and among those, only the ones whose type is constrained by a type class
12:45:25 <monochrom> Oh heh OCaml's and SML's are because of the Haskell equivalent of "x :: IORef Int; x = unsafePerformIO (newIORef 0)"
12:45:27 <Cale> Depending on which extensions you have enabled, your let bindings might be monomorphic for the reason that GHC will turn off the generalisation step altogether though.
12:46:24 <monochrom> Or rather, "x :: IORef [a]; x = unsafePerformIO (newIORef [])"
12:46:47 <monochrom> from which you can play type tricks.
12:47:20 <sproingie> haskell, the best imperative language
12:47:44 <EvanR> i kind of want "the best imperative language"... to see what its like
12:48:41 <sproingie> an imperative duck-typed EDSL
12:49:09 <EvanR> sounds awful
12:49:48 <sproingie> i should write it.  call it "Wrong"
12:50:01 <EvanR> writing wrongs?
12:50:10 <sproingie> ya beat me to it :)
12:50:12 <EvanR> wrong programs
12:50:20 <sproingie> it's full of wrong
12:50:20 <monochrom> Hahaha
12:51:10 <sproingie> stuff it full of every bad idea in programming
12:51:13 <monochrom> When you create your project, it's "writing wrong". Later when you debug it, it's "righting wrong".
12:51:22 <sproingie> hell, it worked for PHP
12:51:38 <manek> Hello guys! :) I need to have an interval tree. I've got a list of NOT overlapping intervals and associated values and I want a structure with fast insert and lookup. I've found several libraries but all seem not touched for a long time. Is there any library that you would personally recommend ? :)
12:52:22 <monochrom> Oh! Almost thought you need an explanation so you could code it yourself.
12:52:28 <EvanR> sounds like the intervals are ordered, put them in a Map
12:52:39 <merijn> sproingie, monochrom: Seems like this link is highly relevant to the discussion: http://colinm.org/language_checklist.html
12:52:51 <sproingie> was just looking at that yesterday
12:53:04 <kadoban> manek: Not sure about libraries. But when you have non-overlapping intervals, you can just do that thing where you use a Data.Map and the keys are the left of the interval, and the vaules are a tuple of the right of the interval and the associated value.
12:53:05 <sproingie> let's see how many boxes we can tick with wronglang :)
12:53:08 <merijn> EvanR: Naah, that doesn't work, because Map assumes non-overlapping
12:53:13 <sproingie> "you're using the wrong language"
12:53:31 <sproingie> oh man now i actually want to do this
12:54:13 <manek> kadoban: sure, but the performance is ugly then. I want to search for value in a particular point, so I would need to iterate over everything before that point. In interval trees it could be amortizedto nlogn
12:54:43 <monochrom> Not just amortized. Worst case lg n.
12:55:02 <manek> monochrom: yeah, right
12:55:09 <kadoban> manek: You can look in Data.Map for the greatest key that's less than or equal to a given one in O(lg n) time (and then check the right of that interval and see if it still matches)
12:55:15 <monochrom> I don't know of a library for this.
12:55:40 <kadoban> You can also use an IntMap for this I think, it also has lookupLE
12:55:46 <manek> monochrom: I found these: https://hackage.haskell.org/package/SegmentTree-0.3/docs/Data-SegmentTree.html#t:Interval
12:55:47 <manek> and
12:55:57 <manek> https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-IntervalMap-FingerTree.html
12:56:17 <manek> but looking at the source code, it seems not the highest quality and they are not updated for long time
12:56:27 <manek> kadoban: hmm, interesting, I'll look into it, brb
12:57:28 <monochrom> Ah, when I said "lg n" I just had "find just one interval" in mind.
12:58:03 <monochrom> I think the fingertree one is worth a bet.
12:58:22 <manek> kadoban: Ok, that would work, but my specification in the question was not good enough (I just realized it, sorry for that)
12:58:41 <kadoban> manek: Oh, what part is it missing, just out of curiosity?
12:58:59 <cfricke> Ahoy! Is anyone successfully building/running intero with stack in NixOS? Seem to have some issues with terminfo and its ncurses dependency.
12:59:09 <manek> kadoban, manek : I would love to be able to change some interval in the middle sometimes, so it would be great if these intervals would be relative and update "parents". I dont know however if sometihng like that exist somewhere
13:00:20 <kadoban> Hmm, not 100% sure what you mean. Something like you have an interval A and then child intervals B and C that modify that? And you want to be able to move the whole bunch to the right by x units or something?
13:00:21 <EvanR> merijn: thats what manek said
13:00:24 <EvanR> non ovrelapping
13:00:26 <manek> kadoban: So I will have interval lengths, not start and end points
13:01:16 <manek> merijn: yeah, right, it will work. I have no overlapping segments here. This are segments of text and they will never overlap
13:01:23 <kadoban> Sounds kind of interesting, though I'm not sure I'm quite getting the jist.
13:01:47 <EvanR> ah, not absolutely position intervals
13:02:02 <manek> kadoban: I've got list of segments and values. Each segment is just a length (assume Word64) and a value. I want to lookup for a specific point and insert new segment in a specific point
13:02:07 <sproingie> oh like regions.  you might want something specialized for this that will handle inserts and deletes gracefully
13:02:15 <sproingie> yi might have something
13:02:45 <kadoban> manek: Oh, and it like moves everything else to the right or something?
13:02:53 <manek> kadoban: right
13:03:15 <EvanR> theres Sequence
13:03:17 <manek> kadoban: it just inserts new segment somewhere (like inserting text into a given position)
13:03:24 <monochrom> Ah, that's different from what I thought.
13:03:29 <kadoban> Hmm, there should be a good datastructure for that *ponders*
13:03:45 <EvanR> you can also use Map with Rational keys
13:04:07 <manek> yeah it looks like it should be handled by something so I thought I would ask here before trying to implement something from scrtch
13:04:13 <EvanR> to insert something between q1 and q2, use (q1+q2) / 2
13:04:36 <manek> EvanR: but then I would not be able to easily lookup for a particular position, right?
13:04:48 <EvanR> i thought there were no positions
13:05:00 <EvanR> its all relative
13:05:28 <kadoban> So you need to be able to do uhm ... "insert X units, with associated value V, at point Y" and you need to be able to query what the associated value is an a certain point?
13:05:29 <manek> EvanR: yeah it's relative, but I want to be able to ask what value was on position "147" and then lookup all relative segments for it. 
13:05:38 <EvanR> now it sounds like a spatial parition
13:05:55 <EvanR> no it does, since it moves everything
13:06:00 <EvanR> erhg
13:06:10 <manek> I need to be able to 1) insert segment in a given fixed position (segment has length and value) and 2) remove given segment 3) lookup for a value in a given fixed position
13:06:29 <EvanR> without changin everything to the rights data
13:07:03 <manek> EvanR: If I insert a segment in a position it moves all the later segments to the right with the offset of its length
13:07:15 <EvanR> conceptually, not lierally right
13:07:17 <sproingie> looks like Yi uses a fingertree
13:07:20 <EvanR> since tehy dont have position stored
13:07:32 <manek> EvanR: these segments are just text fragments, so if you insert a text span in a given char position it "moves" all the later text right
13:07:42 <kadoban> manek: So it's totally dense, right? Or are there spaces between intervals?
13:07:50 <manek> kadoban: yep, its totally dense
13:08:04 <manek> kadoban: its really a Text, or something like a String. whatever, its dense :)
13:08:52 <manek> EvanR: but these segments are dense and know their lengths so you should be able to ask what was in a fixed position knwoing all the segments lengths
13:09:34 <kadoban> Something like a fenwick tree almost works, but ... doesn't quite. Hm. That weird RMQ tree thing that competitive programmers use almost works too, but ... kinda doesn't either.
13:10:06 <monochrom> RMQ does a subtly different thing.
13:10:19 <monochrom> Or maybe not. :)
13:10:25 <EvanR> manek: fingertree seems to be the underlying structure for Sequence, which could do this if you do it Char by Char
13:10:46 <buglebudabey> do i have to rebuild my stack project every time i make a minor change or can i run it anyway
13:10:46 * Tuplanolla pokes dmwit.
13:10:47 <kadoban> monochrom: I think it could be modified to work, but the way I'm thinking of modifying it would have really bad performance in the worst case :-/
13:11:13 <manek> EvanR: I don't really want to do uit char by char - these segments would be 50-100 chars long, so there is no point in storying char by char segments :(
13:11:27 <sproingie> buglebudabey: "stack run" will rebuild if necessary
13:11:28 <EvanR> the point would be simplicity?
13:11:36 <buglebudabey> sproingie thank you
13:12:05 <kadoban> You need like, prefix sums with insertion ... hmm.
13:12:13 <EvanR> manek: alternatively adapt the fingertree structure for your own purposes, fingertree package
13:12:20 <nshepperd> a fingertree would do this, with metric ~ segment length
13:12:42 <Tuplanolla> @tell dmwit `let (%) = mod in let wrapHardest a b n = let c = b - a in if n < a then (n % c + c - a % c) % c + a else (n - a) % c + a in and (zipWith (==) (fmap (wrapHardest 7 12) [minBound .. maxBound :: Word8]) (cycle [10, 11, 7, 8, 9]))`
13:12:42 <lambdabot> Consider it noted.
13:12:46 <buglebudabey> sproingie stack run doesn't seem to be available as a command, could it be it's not added to my path?
13:13:12 <kadoban> Oh right, this could be like an order statistics tree, but instead of "number of elements in here", you store "amount of segment units in here", I guess?
13:13:33 <manek> EvanR, nshepperd : I'm not sure if we are able to define right metric for fingertree, because we need to lookup all the segments to the left to know currents segment position (or cache it somewhere in the parent). I'm not sure if such flexibility would be possible there
13:13:51 <kadoban> That totally sounds like it'd work
13:13:56 <manek> I'm asking because I've been never touching fingertrees but thinking about the ones I've found just raised this concern in my head
13:14:15 <nshepperd> manek: the metric for a subtree is the sum of the lengths of segments in it
13:14:40 <nshepperd> you never worry about or store 'absolute' position
13:15:04 <sproingie> buglebudabey: ah yes, stack install stack-run
13:15:08 <EvanR> too bad its not absolute or https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-IntervalMap-FingerTree.html
13:15:19 <buglebudabey> sproingie ok, done, now when i run the command it still doesnt work
13:15:44 <sproingie> be outside of a stack project when you stack install stack commands
13:16:31 <manek> nshepperd: that sounds like it should work, however, if I'm not wrong, looking at the types here: https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-FingerTree.html
13:16:47 <manek> nshepperd: you are not allowed to define metrics that "looks over" the underlying elements, are you ?
13:17:38 <nshepperd> manek: the metric just has to be a monoid. it is aggregated over the underlying elements automatically
13:17:53 <nshepperd> measure :: Segment -> v, where v is a Monoid
13:19:10 <manek> nshepperd: oh well, right. So yeah it seems like it would work. So in fact this "v" is just a segment length and I should be able to isnert relative segments etc ? huh that is simpler than I thought if I'm not wrong here!
13:19:45 <nshepperd> yeah
13:20:34 <manek> nshepperd: and If I understand correctly insertion should be then implemented using `split` ?
13:21:16 <nshepperd> yep
13:21:21 <manek> nshepperd, EvanR, kadoban, merijn: thank you guys so much for the help!!
13:21:38 <manek> I'm really thankful for it! thanks again! :) 
13:21:55 <buglebudabey> sproingie got it now, thanks, you were right AND it wasn't on the path
13:21:56 <kadoban> manek: Good luck, pretty interesting
13:22:25 <nshepperd> the basic primitive is that you split the sequence into (prefix ++ suffix) with the shortest prefix matching some monotonic predicate
13:23:15 <nshepperd> in this case it would be \total_length -> total_length >= where_you_want_to_insert
13:23:23 <nshepperd> or something like that
13:24:37 <tobiasBora> Hello,
13:25:58 <tobiasBora> I don't understand how to use strategy in the Control.Parallel framework
13:26:02 <tobiasBora> I've a function f
13:26:07 <tobiasBora> a list l
13:26:22 <tobiasBora> and I would like to compute efficiently "map f l"
13:28:58 <lyxia> map f l `using` parList
13:31:52 <glguy> that looks like it might have a type error
13:33:46 <glguy> parMap with the desired element Strategy is probably the most direct
13:34:10 <glguy> parMap rnf, for example
13:36:16 <tobiasBora> lyxia: oh really strange, thank you! Does it work also with filter?
13:36:55 <manek> nshepperd, kadoban : by the way, how it is done that Fingertree does not have any Ord constraint on the measurements (I mean the things that need to be monoid). Doesnt it compare them to make the tree?
13:37:35 <pikajude> no
13:37:45 <kadoban> I don't actually know fingertrees. I'd have implemented it using something else.
13:37:55 <shapr> fingertrees are surprisingly simple
13:37:59 <nshepperd> manek: no, you only need to compare them when you're writing your split predicate
13:38:26 <kadoban> Yeah, I should really learn them ...
13:39:08 <manek> nshepperd: oh, thats interesting. I should learn how they work too1
13:40:41 <dmwit> There's a very readable paper. It's probably linked in the documentation, even.
13:40:52 <dmwit> confirmed
13:41:17 <nshepperd> the measure is not really used in the finger tree at all, it is just metadata about the elements that is carried along and cached in each node so that the user can access it for choosing where to split
13:42:07 <manek> dmwit: yeah I see it, I would definitely read it as soon as I grab some free time! But I see that fingertrees could just builld trees based on the number of spns, not their "measurements" and itm akes perfect sense then no to have any Ord defined 
13:43:13 <dmwit> Tuplanolla: Glad you got it working. =)
13:43:30 <Tuplanolla> You can even eliminate the other branch if division is fast, dmwit.
13:45:24 <dmwit> I'm glad you came up with the trick of comparing n and a first (rather than after the mod). I think that's probably clearer syntactically, and maybe faster too.
13:46:36 <Tuplanolla> The "final final" version is just `wrap a b n = let c = b - a in (n % c + c - a % c) % c + a`.
13:46:45 <tobiasBora> for parList on filter, should I first apply the map, and then the filter ?
13:46:52 <Tuplanolla> Now nobody will ever have to derive this again.
13:54:23 <tobiasBora> glguy: I tried P.parMap P.rdeepseq and P.parMap P.rpar, but nothing happened, there is only one thread really active, the others one hardly reach 13% of usage
13:54:59 <tobiasBora> I use:
13:55:03 <tobiasBora> filter (==True) ((P.parMap P.rpar (\alphas -> refMatrix == matrixSeveralJ alphas) allAlphaSeq))
13:55:11 <tobiasBora> where allAlphaSeq = sequence [ possibleAngles | i <- [1..n]]
13:56:21 <nshepperd> are you compiling with -threaded and running with +RTS -N
13:57:05 <Zer000> In terms of code style is it better to declare instances of a class where you define the class or where you define your types?
13:58:07 <nshepperd> you want 'parMap rseq' or 'parMap rdeepseq' here (they're the same for Bool anyway)
13:58:15 <Itkovian> does any know of a Parser Hostname that checks if a piece of Text is a valid hostname and if so returns it?
13:58:35 <quchen> Zer000: Both ways are fine.
13:58:40 <Aruro> Zer000: can be advantage to have all instances in one place
14:01:39 <nshepperd> if they're in the same file I guess it's down to personal style. otherwise it will sometimes be more natural for the place where the type is defined to import the class, or vice versa
14:04:51 <ph88> is it possible to go from  Conduit  to  Vector  without going through  List  first ?
14:19:11 <c_wraith> I assume you mean efficiently? because it's trivial to do really inefficiently. 
14:19:49 <ph88> c_wraith, yes :D
14:21:06 <c_wraith> worst case you could always go with exponential resizing of mutable vectors followed by a freeze. you can probably do better, but that much is at least possible. 
14:22:48 <ph88> what is the allocation strategy for an immutable vector that is growing in size?
14:25:02 <c_wraith> immutable vectors don't grow in size. 
14:25:24 <ph88> well conduit can be streaming
14:25:28 <ph88> so where do the values go
14:26:43 <c_wraith> if the conduit is producing vectors, each chunk is independent 
14:27:15 <ph88> consume values from stream and return a single immutable vector
14:28:25 <ph88> https://hackage.haskell.org/package/vector-conduit-0.5.0.0/docs/src/Data-Conduit-Vector.html#consumeVector  ??
14:28:26 <dmwit> Zer000: I put instances next to types I defined, and next to the class declaration for types from dependencies.
14:28:40 <ph88> there is an M.grow there 
14:29:18 <buglebudabey> if i have a stack project with an image i want to use in my code, where's the best place to keep that, src?
14:31:04 <dmwit> buglebudabey: How about `images/` or `resources/`?
14:31:10 <dmwit> Or do you actually intend to compile the picture? =)
14:31:31 <buglebudabey> dmwit what i really mean is when i am providing a path, what's it relative to?
14:31:49 <dmwit> the .cabal file
14:31:59 <dmwit> or, wait
14:32:12 <dmwit> When you are providing a path *to what tool*, and *in what way*?
14:33:22 <dmwit> The `data-files` clause in your .cabal file is relative to the .cabal file. The path you get from the `Paths_foo` module is also relative to the .cabal file, I think?
14:33:27 <buglebudabey> dmwit like if i'm reading in a bmp from src/BMPReader.hs should my path be "images/picture.bmp" where images and src are both directories in my main project folder?
14:33:43 <dmwit> But in reality it's relative to some installed directory that you don't really ever get to know precisely.
14:34:21 <dmwit> buglebudabey: Read the `data-files` section of https://www.haskell.org/cabal/users-guide/developing-packages.html and the linked info on finding those files at runtime.
14:34:32 <buglebudabey> ok thanks
14:34:35 <dmwit> I'm not a stack expert but I very strongly suspect the information will be relevant to stack usage as well.
14:36:05 <codygman_> Is there some function that recursively applies a fold to itself? I'm telling to generate dependencies.
14:36:33 <dmwit> :t foldTree -- ?
14:36:34 <lambdabot> error:
14:36:34 <lambdabot>     • Variable not in scope: foldTree
14:36:34 <lambdabot>     • Perhaps you meant ‘unfoldTree’ (imported from Data.Tree)
14:37:26 <dmwit> foldTree :: (a -> [b] -> b) -> Tree a -> b -- from the documentation
14:38:50 <codygman_> Yeah, i could probably just store it all as a tree and get children, but I'd still be curious with my original question
14:38:59 <dmwit> I don't understand your original question.
14:40:37 <codygman_> Perhaps i don't either yet, I'll think on it
14:41:59 <dmwit> :t unfoldTree -- also possible you meant this
14:42:00 <lambdabot> (b -> (a, [b])) -> b -> Tree a
14:42:49 <EvanR> hmm as part of the build process, maybe convert the bmp file into source code, then compile it into the binary
14:42:59 <dmwit> You can combine them to get `hyloTree`. ;-)
14:43:17 <EvanR> then in some sense your data is an expression
14:43:25 <dmwit> EvanR: That approach seems to have few advantages and many disadvantages.
14:43:31 <EvanR> oh?
14:43:54 <dmwit> e.g. it makes it much harder to experiment with different textures (you have to rebuild the whole program!).
14:44:17 <EvanR> well if were talking about dynamic changes to code... 
14:44:28 <EvanR> i would like a better solution than use external image files
14:44:38 <tobiasBora> nshepperd: Yes, I run it using  -threaded -rtsopts -with-rtsopts=-N in the ghc-options of the executable in the cabal file
14:44:45 <EvanR> then finally make a final version
14:44:48 <torstein> Does anyone use Emacs/Spacemacs and know how to get Haddock lookup? There's Hoogle lookup but it only shows function signatures, not function and argument description
14:46:01 <dmwit> Or, for another example: this prevents you from choosing at runtime what image to use. This rules out "texture packs", and probably badly affects how long it takes your program to start (a big problem with modern games, IMO).
14:46:10 <tobiasBora> nshepperd: parMap rseq also do not work, 3 threads only reach 12% of CPU, while one 1 100%
14:46:13 <dmwit> I don't know. I just don't see why it's a good idea.
14:46:44 <EvanR> dmwit: for a single image... distributing a binary vs distributing a binary and an image file...
14:47:03 <EvanR> the image is really part of the program
14:47:17 <EvanR> development is a different story
14:47:21 <dmwit> I don't see why distributing a binary and an image is hard.
14:47:29 <EvanR> its 2x as many files
14:47:38 <EvanR> and is easily modified by the end user
14:47:42 <dmwit> It's one zip file...
14:47:48 <EvanR> windows?
14:47:57 <dmwit> Who cares? zip works everywhere.
14:48:05 * ski . o O ( partial evaluation )
14:48:08 <EvanR> no it doesnt
14:48:42 <EvanR> it works on windows, on *nix it wont find the image file when you run the program from just anywhere
14:48:55 <hpc> this is why i only publish software as MIME containers
14:49:00 <nshepperd> tobiasBora: hm. should be working. are you certain that this map is really the cpu intensive part? could allAlphaSeq be expensive?
14:49:33 <dmwit> EvanR: I think you either give Windows too much credit, or the program author not enough.
14:49:35 <hpc> dmwit: you've just entered the strange world of packaging
14:49:41 <tobiasBora> nshepperd: Well, the definition of allAlphaSeq is simple : allAlphaSeq = sequence [ possibleAngles | i <- [1..n]]
14:49:46 <EvanR> to go the other way with it, id like to be able to distribute all the source code as modifiable modules that runs
14:49:46 <tobiasBora> so I don't think it's intensive
14:50:11 <Tuplanolla> If only you could distribute software as a textual description, which would then read itself...
14:50:14 <dmwit> hpc: I refuse to believe that shipping a program with an image is not a solved problem.
14:50:20 <EvanR> Tuplanolla: brilliant
14:50:29 <hpc> it's very solved
14:50:33 <hpc> the solution is packaging :P
14:50:41 <EvanR> dmwit: yes, for lots of resoruces, thers all kinds of installation wizards and framework for it
14:50:46 <EvanR> package managers, installation scripts
14:50:52 <dmwit> EvanR: So why are you claiming it's hard???
14:50:53 <EvanR> downlaoable content
14:51:04 * ski . o O ( `allAlphaSeq = replicateM n possibleAngles' )
14:51:12 <EvanR> why are you ignoring my criteria for the context?
14:51:12 <tobiasBora> I tried: P.withStrategy (P.parListChunk 1000)
14:51:16 <tobiasBora> it's way more efficient :D
14:51:29 <EvanR> one bmp file
14:51:33 <tobiasBora> ski: Hum interesting
14:52:30 <EvanR> i find it  silly to set up a zeroconf cross platform platform to facilitate 1 exe and 1 bmp to actually work on the target
14:53:03 <EvanR> AAA gaming with updates, plugins extensions, whatever is another story
14:53:04 <nshepperd> tobiasBora: or possibly there is something in the implementation of your mapped operation that is having some shared lock...
14:54:07 * EvanR begins thinking about dynamic updating of code modules
14:54:13 <sproingie> not unusual these days for games to download the rest of their assets on first launch
14:54:15 <nshepperd> chunked parallel mapping is always good if the operation is cheap, so that you don't spend a ton of time just making sparks
14:54:19 <tobiasBora> nshepperd: I found the solution using chunk
14:54:31 <sproingie> even AAA games, though those tend to be of the MMO variety
14:54:36 <tobiasBora> P.withStrategy (P.parListChunk 1000 P.rdeepseq)
14:54:45 <nshepperd> tobiasBora: does it have good parallel utilization now?
14:55:03 <tobiasBora> nshepperd: yes, now all the threads are 98% :D
14:55:11 <tobiasBora> thank you !
14:55:28 <nshepperd> ah. so it was just the single threaded overhead in scheduling each cheap element
14:55:40 <tobiasBora> yes
14:56:08 <buglebudabey> if i have a game i wrote in haskell is there anyway to make it playable in the browser as is?
14:57:59 <sproingie> ghcjs perhaps, but you'd be targeting a very different type of display
14:58:13 <sproingie> so no, not "as is"
14:59:56 <nshepperd> on *nix you can bundle your executable and assets into one container with the assets just appended onto the end, and have the program load them whenever. like those self extracting shell scripts
15:00:28 <tobiasBora> Is there any more efficient version of nub ? Because n^2 to remove duplicate when a sort is in O(n log n) is a bit expensive...
15:00:52 <sproingie> opengl would be a good bet for a game targeting desktop and browser.  ombra might be something you could use, never tried it myself
15:00:54 <erisco> tobiasBora, why not use sort, then?
15:01:12 <tobiasBora> erisco: because I also want the uniqueness property
15:01:20 <ski> @type map head . group . sort
15:01:22 <EvanR> tobiasBora: you could do it more efficiently for Ord types... using a Set during a fold
15:01:22 <lambdabot> Ord b => [b] -> [b]
15:01:39 <EvanR> or that
15:01:42 <erisco> tobiasBora, sorry, I thought you had figured out how to solve it with sort already
15:02:59 <EvanR> ski: i wonder whats the complexity of that
15:03:14 <nshepperd> nubOrd from Data.List.Extra
15:03:37 <nshepperd> (map head . group . sort) is nice of course but it reorders the list and also isn't productive
15:03:51 <erisco> you can also just change what it means for two lists to be equal :)
15:05:18 <ertes> tobiasBora: if you want uniqueness, why don't you just use Set in the first place?
15:05:21 <erisco> :t S.toList . S.fromList -- this is another easy one
15:05:23 <lambdabot> Ord a => [a] -> [a]
15:05:36 <ertes> > S.fromList [2,5,6,5,1,2,2,8]
15:05:38 <lambdabot>  fromList [1,2,5,6,8]
15:05:59 <EvanR> a set is not as convenient if you think its a list
15:06:16 <ertes> then don't think it's a list
15:06:24 <EvanR> dont think!
15:06:30 <erisco> just don't
15:06:59 <maerwald> thought this is #java for a second
15:07:09 <nshepperd> :t let setNub xs = foldr (\x k seen -> if Set.member x seen then k seen else x : k (Set.insert x seen)) (const []) xs Set.empty in setNub
15:07:10 <lambdabot> error:
15:07:11 <lambdabot>     Not in scope: ‘Set.member’
15:07:11 <lambdabot>     Perhaps you meant one of these:
15:07:18 <nshepperd> darn you, lambdabot
15:07:33 <Tuplanolla> @let import qualified Data.Set as Set
15:07:35 <lambdabot>  Defined.
15:07:48 <ertes> nshepperd: S, not Set
15:08:06 <EvanR> Set seems better
15:08:23 <Tuplanolla> I dislike single-letter module aliasing.
15:08:28 <nshepperd> > setNub "hello world"
15:08:30 <lambdabot>  "helo wrd"
15:08:46 <nshepperd> > setNub [1..]
15:08:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:08:54 <erisco> doesn't matter if you like it or not because it inevitably causes conflicts
15:08:57 <tobiasBora> hum... set may also be a good idea, I don't know what's the best
15:09:12 <tobiasBora> is it possible to do a map from a list to a set :D
15:09:36 <erisco> this is called Set.fromList
15:10:00 <nshepperd> of course, maybe you should just be using a Set in the first place!
15:10:09 <ertes> tobiasBora: alternatively just start with a Set to begin with
15:10:10 <nshepperd> they do have a nice interface
15:10:38 <ertes> tobiasBora: use 'mempty' (the empty set) instead of [], and use 'insert' instead of (:)
15:10:54 <ertes> > S.insert 2 (S.insert 3 (S.insert 2 mempty))
15:10:56 <lambdabot>  fromList [2,3]
15:11:03 <tobiasBora> ertes: well I get my input from "replicateM n possibleAngles"
15:11:42 <erisco> > S.singleton 1 <> S.singleton 2
15:11:44 <lambdabot>  fromList [1,2]
15:11:47 <tobiasBora> so it means that I need to do "fromList $ replicateM ..." and it seems pretty heavy here, since the list representation is way more efficient than the array representation here
15:12:29 <ertes> tobiasBora: Set will become more efficient as you increase the number of duplicates
15:12:58 <tobiasBora> ertes: in my input there is no duplicate
15:13:13 <tobiasBora> in my output I think there are lot's of duplicate
15:13:13 <ertes> ah
15:13:43 <ertes> tobiasBora: so you start with a list of unique items and then you transform it in some way that generates duplicates?
15:13:49 <tobiasBora> yes
15:14:22 <EvanR> you could use a set throughout
15:14:29 <EvanR> each operation would modify a set, which is auto deduped
15:14:49 <ertes> tobiasBora: is the transform local enough?  i mean: do you only ever look at a single item, or do you need multiple list items to map a single one?
15:15:28 <tobiasBora> ertes: local map only
15:16:03 <erisco> I think ertes is shopping in the morphism catalog
15:16:09 <ertes> tobiasBora: then i suggest that you don't use a list anyway, but use some kind of stream processing…  or use a recursive loop instead of replicateM
15:16:28 <tobiasBora> ertes: I need to use multithreading also,
15:16:33 <ertes> tobiasBora: transform each item as it comes up and add the result to a set
15:16:43 <ertes> tobiasBora: that's fine, Set is a monoid =)
15:16:46 <tobiasBora> that's why recursive loop may be difficult to use
15:17:20 <ertes> "is a monoid" = "i can parallelise this"
15:17:45 <tobiasBora> ertes: and I keep the input as a list or not ? I'm not sure to see how I can change this replicate code
15:17:47 <EvanR> a list is a stream processing!
15:18:10 <EvanR> a list is a monoid that isnt parallizable
15:18:19 <ertes> tobiasBora: what form of multi-threading do you need?  concurrency (to do multiple things at once) or parallelism (to compute faster)?
15:18:31 <tobiasBora> ertes: parallelism
15:19:04 <tobiasBora> EvanR: So how would you transform the "replicateM n l" code?
15:19:07 <ertes> tobiasBora: with effects or pure?
15:19:17 <nshepperd> the list method with setNub seems fine to me
15:19:36 <Maxdamantus> Well, the list monoid is parallelisable, but parallelising doesn't necessarily improve performance.
15:19:48 <tobiasBora> ertes: for now pure. I'm using Control.Parallel.Strategies for my parallelisation
15:20:38 <nshepperd> maybe revisit the choice if walking down the list to get to the next chunk reaches a *significant* amount of the parallelizable work
15:21:04 <nshepperd> it sounds like it is currently negligible cost
15:21:14 <Maxdamantus> It might help if the concatenation tends to be left branching.
15:21:49 <erisco> concurrency is doing multiple things and parallelism lets you do them at once... just being annoying :)
15:21:57 <Maxdamantus> (but that's just because left branching concatenation of lists is really inefficient)
15:22:56 <EvanR> parallelism lets you do things in parallel
15:23:31 <ertes> tobiasBora: as long as it's pure, using lists is fine, if you make sure that the list is lazy enough
15:23:35 <EvanR> this terminology stinks, who came up with this, euclid?
15:24:15 <ertes> tobiasBora: for example if you use replicateM with a state monad, be sure to use a lazy state monad
15:24:32 <nshepperd> it's parallel because you're doing multiple copies of the same thing in a different place at the same time
15:25:10 <EvanR> contemporaneous
15:26:06 <Tuplanolla> Just call it blast processing.
15:26:07 <ertes> tobiasBora: then you can map, then break the list into chunks of a fixed length, 'transpose' it and eagerly convert each sublist individually into a Set…  at the end you just take the union of all sublists
15:26:33 <nshepperd> there isn't a word for doing *different* things at the same time in order to make it faster
15:26:36 <ertes> :t chunksOf
15:26:37 <lambdabot> Int -> [e] -> [[e]]
15:26:52 <EvanR> theres pipelining
15:26:55 <tobiasBora> ertes: Not sure to understand... And example with "replicateM 4 [1,2,3,4,5]"
15:26:58 <tobiasBora> ?
15:27:16 <EvanR> but that adds extra connotation
15:27:35 <ertes> > transpose . chunksOf 3 $ [0..20]
15:27:37 <lambdabot>  [[0,3,6,9,12,15,18],[1,4,7,10,13,16,19],[2,5,8,11,14,17,20]]
15:27:51 <Tuplanolla> Orthogonalization, nshepperd?
15:27:57 <ertes> let's say that you do an expensive map before you break it into chunks
15:28:03 <EvanR> and i didnt think parallel suggested uniformity
15:28:10 <EvanR> 5k in parallel with 10k
15:28:23 <ertes> > transpose . chunksOf 3 . map (^100001) $ [(0 :: Word8)..20]
15:28:25 <lambdabot>  [[0,131,0,9,0,15,0],[1,0,7,0,141,0,147],[0,133,0,139,0,17,0]]
15:28:46 <ertes> tobiasBora: now you have three sublists that you can process in parallel
15:29:16 <ertes> > parMap rdeepseq S.fromList . transpose . chunksOf 3 . map (^100001) $ [(0 :: Word8)..20]
15:29:18 <lambdabot>  error:
15:29:18 <lambdabot>      • Variable not in scope:
15:29:18 <lambdabot>          parMap :: t0 -> ([()] -> Set.Set ()) -> [[Word8]] -> c
15:29:25 <ertes> > map S.fromList . transpose . chunksOf 3 . map (^100001) $ [(0 :: Word8)..20]
15:29:27 <lambdabot>  [fromList [0,9,15,131],fromList [0,1,7,141,147],fromList [0,17,133,139]]
15:29:33 <ertes> just pretend that the final 'map' is actually a parMap
15:30:08 <tobiasBora> what's the difference between that and P.withStrategy (P.parListChunk 1000 P.rdeepseq) ?
15:31:06 <ertes> tobiasBora: the idea is that you never produce the list in memory, but use it in a very lazy way…  the 'fromList' is the function that actually forces the computation of the initial 'map'
15:31:50 <ertes> and that one is parallelised very coarsely, ideally by using a chunk length of the number of cores you have
15:31:51 <tobiasBora> ertes: where do I use fromList ? 
15:32:14 <ertes> see the snippet above
15:32:53 <tobiasBora> I don't get it
15:33:11 <tobiasBora> maybe parListChunk use under the hood the same method as you no?
15:33:19 <tobiasBora> uses*
15:34:27 <ertes> tobiasBora: it does, but i would expect the explicitly chunking approach to yield better results, because it uses far coarser parallelism
15:34:40 <ertes> *explicit
15:35:12 <tobiasBora> I see
15:35:26 <tobiasBora> and transpose on a list is really efficient ???
15:36:08 <ertes> yes
15:36:32 <ertes> it doesn't really do much other than rearranging the cons cells
15:36:53 <ertes> if the original list is lazy, transposition is very cheap
15:40:00 <tobiasBora> really? ok why not
15:41:10 <EvanR> @src transpose
15:41:10 <lambdabot> transpose []             = []
15:41:10 <lambdabot> transpose ([]   : xss)   = transpose xss
15:41:10 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:41:28 <EvanR> such lazy
15:41:31 <nshepperd> let src = initial_work_items; f = function_that_produces_duplicates; easy_solution = setNub (map f src `using` parListChunk 1000 rseq)
15:42:58 <nshepperd> if easy_solution is not fast enough, it's because: 1. parListChunk has to jump 1000 elements before getting to the next chunk/spark, and might start too many sparks compared to your number of cpus and 2. setNub is sequential
15:44:26 <nshepperd> so you can explicitly chunk src sort of like ertes is describing, then apply Set.fromList . map f on each chunk in parallel, then merge the sets later, which should be fast since there are only a small number of sets
15:52:23 <Zer000> can I just point out that on this page https://wiki.haskell.org/Lifting in the first paragraph the type definition of fmap is wrong afaik. It's Functor f => (a -> b) -> (f a -> f b) but should be Functor f => (a -> b) -> f a -> f b
15:52:47 <hpc> both are the same
15:52:48 <c_wraith> those are the same. 
15:53:06 <hpc> x -> (y -> z) = x -> y -> z
15:53:14 <tobiasBora> nshepperd: setNub is defined in a library ?
15:53:17 <hpc> (x -> y) -> z /= x -> y -> z
15:53:46 <hpc> this is related to currying
15:54:21 <nshepperd> tobiasBora: it's called Data.List.Extra.nubOrd from package `extra`
15:55:26 <Zer000> interesting thank you
15:59:05 <hanna> setNub is also in `containers`, where it's called toList . fromList
15:59:20 <hanna> from Data.Set
16:01:21 <dmwit> NB `toList . fromList` does not preserve order. `nub` does.
16:02:40 <dmwit> Hoogle finds `ordNub` in a few different packages, but none that seems "canonical".
16:04:07 <ketil_> Anybody use travis-ci?  I get an error message from importing containers:
16:04:36 <ketil_>     containers-0.5.10.2:Data.Map.Internal.DeprecatedShowTree can't be safely imported! The module itself isn't safe.
16:05:06 <ketil_> Anything I can do about this?  As far as I can tell, this is just cabal installing containers from hackage.
16:05:39 <ketil_> ...and it works on my PC, same GHC-version and containers version. Could it be a different cabal-install?
16:06:05 <dmwit> That sounds like an error associated with the Safe language extension. Do you think it could be enabled for some reason on the CI?
16:06:44 <dmwit> (Perhaps by a different version of one of the packages that depends on containers?)
16:07:23 <ketil_> No idea.  Also, travis-ci claims ghc 7.10.3, but then it runs ghc --version, which claims 7.4.1.  Hmm..
16:09:32 <tobiasBora> nshepperd: Oh ok thank you
16:13:15 <zachk> does this look ok for a randomSelection function from a list: randomSelection :: [a] -> IO a
16:13:15 <zachk> randomSelection list = do
16:13:15 <zachk>   let len = length list
16:13:15 <zachk>   i <- randomRIO (0,len-1)
16:13:15 <zachk>   return $ list !! i
16:14:21 <ski> i suppose so
16:14:56 <zachk> managed to get an index too large out of it at runtime maybe an empty list or something
16:15:32 <EvanR> basically randomRIO (0, -1)
16:15:35 <byorgey> zachk: you could use http://hackage.haskell.org/package/MonadRandom-0.5.1/docs/Control-Monad-Random-Class.html#v:uniform instead of writing it yourself
16:15:40 <EvanR> something looks fishy there
16:15:55 <ski> > fst (randomR (0,-1) (mkStdGen 1234)) :: Int
16:15:56 <lambdabot>  0
16:16:21 <kadoban> For randomR, the docs say "It is unspecified what happens if lo>hi"
16:16:29 <kadoban> So, yeah that's a problem.
16:16:40 <ski> possibly you want to throw an exception in that case ?
16:16:42 <kadoban> You'd have to throw an exception I suppose, based on that type signature.
16:17:12 <EvanR> or require a non empty list, or a default value to return in case of empty list
16:17:32 <ski> .. or a failure continuation
16:18:57 <hpc> also "exception" outside of IO pretty much just means "crash"
16:19:02 <hpc> because they are unpleasant to catch
16:19:11 <ski> @unmtl ReaderT (IO o) (ContT o IO) a
16:19:11 <lambdabot> IO o -> (a -> IO o) -> IO o
16:19:51 <EvanR> crash early, crash often, right?
16:20:01 <EvanR> or is that another language
16:20:12 <Eduard_Munteanu> I wonder if the weights must sum up to 1.
16:20:15 <ski> or "fail fast"
16:20:42 <EvanR> yeah if the only ways it can fail are fast, thats great
16:20:56 <Eduard_Munteanu> Erlang?
16:21:07 <ski> better waste less computing resources
16:21:21 * ski was thinking of Prolog
16:22:31 <zachk> is there a way to check and see if a Thread from Control.Concurrent is still running?
16:22:54 <ski> Eduard_Munteanu : for `fromList' ?
16:23:20 <Eduard_Munteanu> ski, I was asking about 'weighted', I suppose fromList also does.
16:24:14 <ski> Eduard_Munteanu : i suppose they normalize the weights
16:25:17 <Eduard_Munteanu> Hm, looks like it... uniformMay = fromListMay . map (flip (,) 1) . F.toList
16:27:56 <EvanR> zachk: do you have the threadId ?
16:29:25 <tobiasBora> Is there any way to quickly provide an efficient ordering if I don't mind which ordering it uses ?
16:29:34 <zachk> EvanR yea I can get the threadId at creation time via threadId <- forkIO stuff
16:29:44 <zachk> so how do I see if that threadId is still alive?
16:30:05 <EvanR> right, here it is
16:30:12 <EvanR> https://stackoverflow.com/questions/9475392/is-there-a-way-in-haskell-to-query-thread-state-using-threadid-after-a-forkio
16:30:26 * ski idly wonders whether this Ramsey categorification makes sense
16:30:56 <EvanR> threadStatus :: ThreadId -> IO ThreadStatus
16:31:01 <EvanR> in GHC.Conc
16:31:27 <nilof> Is the IO monad's instance of (>>) equivalent to seq with constrained types, or is there some subtle difference between the two?
16:31:49 <nilof> > :t (>>)
16:31:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:31:57 <ski> not even a subtle difference. a large difference, i'd say
16:32:13 <ski> `seq' is about evaluation
16:32:41 <tobiasBora> Because I'd like to define "Ord (Matrix Mytype)", but I don't want to define a dirty hand-made operator
16:32:43 <ski> (not even *sequencing* evaluation. there's `pseq' for that)
16:32:55 <ski> `(>>)' is about sequencing execution
16:33:14 <ski> evaluation and execution are different things
16:33:39 <ski> @type (>>)
16:33:40 <lambdabot> Monad m => m a -> m b -> m b
16:34:00 <lyxia> tobiasBora: have you tried deriving it
16:34:08 <dmwit> ?quote sprynge
16:34:08 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
16:34:19 <dmwit> Corollary: Beware of the function [a] -> IO a.
16:34:34 <tobiasBora> lyxia: It's possible to derive when Matrix has already been explicited in another lib?
16:34:58 <dmwit> tobiasBora: `deriving Ord` if that works. Otherwise, no, not really.
16:35:19 <lyxia> there's still standalone deriving
16:35:21 * ski looks at nilof
16:35:45 <tobiasBora> dmwit: I tried: "type MatrixCell = M.Matrix Cell deriving Ord" but it does not work
16:35:55 <tobiasBora> lyxia: what's that ?
16:36:04 <nilof> Ah, so are there cases where >> does not evaluate its first argument?
16:36:10 <dmwit> tobiasBora: `{-# LANGUAGE StandaloneDeriving #-}; deriving instance Ord a => Ord (M.Matrix a)`
16:36:24 <dmwit> nilof: No. Also, it does much more than evaluate its first argument.
16:36:54 <dmwit> (In contrast to `seq`, which *only* evaluates its first argument, and sometimes not even that.)
16:37:40 <dmwit> To wit: ```print 3 `seq` return ()``` doesn't print anything. ```print 3 >> return ()``` does.
16:38:35 <tobiasBora> dmwit: Can't make a derived instance of ‘Ord (M.Matrix a)’, The data constructors of ‘M.Matrix’ are not all in scope so you cannot derive an instance for it
16:38:37 <dmwit> tobiasBora: But you will need enough stuff in scope to be able to write the instance yourself. No getting around the module boundaries with this extension. ;-)
16:38:44 <nilof> ah okay, so seq is quite a lot weaker
16:38:48 <dmwit> tobiasBora: Oh, dang, you typed just too fast for me to appear prophetic.
16:38:59 <nilof> while >> is stricter
16:39:20 <monochrom> Fortunately, there exists an inertial frame that says you're prophetic :)
16:39:32 <tobiasBora> dmwit: Ahah, maybe you will have another idea to solve this problem, and recover you wizart power?
16:39:45 <Eduard_Munteanu> nilof, no, (>>) isn't strict at all
16:39:47 <hpc> "stricter"
16:39:50 <dmwit> tobiasBora: Yes, write the instance yourself using functions exposed by whatever `M` is.
16:39:56 <dmwit> tobiasBora: (sorry)
16:40:00 <hpc> i assume you meant "more specific" ;)
16:40:02 <EvanR> as in, "boa con"
16:40:02 <glguy> yeah, there are cases where >> doesn't evaluate its first argument
16:40:15 <glguy> > undefined >> Proxy -- is the simplest, but there are less degenerate cases
16:40:17 <lambdabot>  Proxy
16:40:24 <dmwit> glguy: The conversation context explicitly specifies `IO` as the monad of interest.
16:41:03 <monochrom> For very non-strict >> and >>=, try Control.Monad.State.Lazy. http://lpaste.net/41790/
16:41:10 <Eduard_Munteanu> Even there, it's kinda conflating evaluation with execution.
16:41:11 <tobiasBora> dmwit: Hum... So you mean I must copy paste all the stuff defined in the Data.Matrix module in my code?
16:41:35 <dmwit> tobiasBora: No, I would not do that.
16:42:11 <dmwit> > undefined >> undefined :: Proxy ()
16:42:13 <lambdabot>  Proxy
16:42:15 <dmwit> neat
16:42:17 <Eduard_Munteanu> > return undefined >> print "hello"
16:42:19 <lambdabot>  <IO ()>
16:42:26 <monochrom> Oh! IO. Then consider unsafeInterleaveIO :) http://lpaste.net/77374
16:42:37 <EvanR> > undefined >> print "hello"
16:42:38 <dmwit> > (return undefined :: IO ()) `seq` print "hello"
16:42:39 <lambdabot>  <IO ()>
16:42:41 <lambdabot>  <IO ()>
16:42:52 <Eduard_Munteanu> Hrmpf.
16:42:58 <dmwit> > undefined :: IO () -- can't tell with this stupid lazy bot ;-)
16:43:00 <lambdabot>  <IO ()>
16:43:06 <EvanR> :thumbsup:
16:43:15 <dmwit> > (return undefined :: IO ()) `seq` ()
16:43:17 <lambdabot>  ()
16:43:32 <dmwit> > (return undefined >> print 3) `seq` ()
16:43:34 <EvanR> >> in IO is that lazy
16:43:34 <lambdabot>  ()
16:43:45 <monochrom> main = unsafeInterleaveIO main >> putStrLn "done"
16:43:48 <Eduard_Munteanu> > (undefined :: IO ()) `seq` ()
16:43:51 <lambdabot>  *Exception: Prelude.undefined
16:44:54 <Eduard_Munteanu> Heh.
16:45:09 <EvanR> wtf
16:45:13 <EvanR> i give up
16:45:23 <dmwit> tobiasBora: I'd probably write `instance Ord a => Ord (Matrix a) where compare = compare . toLists`.
16:46:06 <EvanR> lambdabot is playing games with my denotational heart
16:46:07 <dmwit> (If I didn't care about efficiency or semantics, that is.)
16:46:21 <dmwit> EvanR: Really? What surprised/confused you?
16:46:32 <nilof> but if I have something that returns an IO due to side effects and I feed it as the first argument of (>>), I do have a guarentee that it will be executed?
16:46:36 <monochrom> dmwit: If toLists is lazy enough, I think it is not too bad.
16:46:41 <EvanR> (undefined :: IO ()) `seq` () is undefined, but undefined :: IO () is not
16:47:22 <monochrom> That's false.
16:47:27 <glguy> EvanR: How did you determine that (undefined :: IO ()) was not undefined?
16:47:29 <dmwit> EvanR: because the latter is actually `show (undefined :: IO ())` and the `Show` instance completely ignores its argument.
16:47:31 <monochrom> I mean the second sentence is false.
16:47:37 <EvanR> > undefined :: IO ()
16:47:39 <lambdabot>  <IO ()>
16:47:46 <glguy> EvanR: Why do you think that's relevant?
16:47:48 <EvanR> ah
16:47:53 <tobiasBora> dmwit: I though to use the lists (even if I didn't know that compare was usable for list), is it also efficient?
16:47:54 <dmwit> > let ignoreIO _ = "no, lol" in ignoreIO (undefined :: IO ())
16:47:54 <monochrom> Yeah it's show being non-strict.
16:47:55 <lambdabot>  "no, lol"
16:48:05 <Eduard_Munteanu> nilof, execution is ordered by (>>), yes
16:48:07 <monochrom> You almost used const to prove that everything is defined.
16:48:24 <EvanR> glguy: context being what lambda says, i assume it shows the evaluation of what you asked for
16:48:53 <Eduard_Munteanu> EvanR, it's just the show instance for IO stuff
16:48:59 <EvanR> > undefined :: ()
16:49:01 <lambdabot>  *Exception: Prelude.undefined
16:49:03 <EvanR> see
16:49:12 <monochrom> That's ()'s show being strict.
16:49:13 <EvanR> but now i see thats totally wrong
16:49:32 <EvanR> what you see is not what you get
16:49:47 <monochrom> I do not actually know why the Haskell comittee wanted it, but they did it.
16:49:48 <dmwit> What you see is one `show` away from what you get. =)
16:50:02 <EvanR> its like shadows on a cave wall
16:50:19 <dmwit> All the world's a stage, a `show` in every corner.
16:50:20 <monochrom> And programmers are supposed to be the people best aware of WYSI not WYG.
16:50:55 <Eduard_Munteanu> Positivism: What You See *Is*
16:51:32 <monochrom> That sounds more like tautologism than positivism :)
16:51:55 <dmwit> I suspect some people have seen things that isn't.
16:52:08 <nilof> ah, also, I'm wondering, in the case when I write foldr (>>) , will it cause stack overflow with the IO monad? Afaik I'd expect it to overflow for the writer monad?
16:52:56 <glguy> I wouldn't expect either of those to be the case
16:53:01 <monochrom> That depends on a few more variables than that question acknowledges.
16:53:36 <monochrom> Consider foldr (>>) undefined (repeat (putStrLn "hello"))
16:53:47 <monochrom> Runs forever but O(1) space.
16:53:49 <glguy> > execWriter (foldr (>>) (return ()) (repeat (tell [42])))
16:53:52 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
16:53:59 <glguy> That's foldr on an infinite list in Writer
16:54:19 <monochrom> And yeah, Writer depends on whether you use execWrite or evalWriter
16:54:38 <monochrom> So, more variables than the question is aware of.
16:55:01 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
16:55:25 <monochrom> Oh I still need to add the picture I took the other day for #0.
16:55:33 <hpc> if you want to be really obnoxious, you can answer the question as asked with "it will never overflow because you haven't posited anything that evaluates it"
16:55:48 <monochrom> The picture is of a sign posted outside a pub. It said "Tuesday is like Monday, but different. =)"
16:56:04 <monochrom> haha hpc wins.
16:56:11 <glguy> nilof: foldl is more likely to have trouble with IO
16:56:35 <thang1> glguy: is that because it's not strict? Would foldl' work fine?
16:56:46 <wayne> hey if i want to write a language runtime in haskell, are there any libraries that give me low-level memory management facilities?
16:56:54 <glguy> I'd expect foldl' to have a similar amount of trouble
16:56:56 <monochrom> foldl is too strict, foldl' even worse
16:57:28 <wayne> the memory for the program itself is pretty hands-off, but maybe there's a library that will let me manage blocks in the heap maybe?
16:57:38 <monochrom> foldl is strict on the input list (so infinite list will cause trouble) and foldl' on top of that is strict on one more thing and it's a complete disaster.
16:57:40 <wayne> a memory monad wouldn't be the worst thing
16:57:46 <hpc> monochrom: there's actually a kernel of truth in there too, that evaluation never happens unmotivated (and in fact neither does execution)
16:57:57 <hpc> IO is a data structure! :D
16:58:12 <Eduard_Munteanu> wayne, you can allocate memory for a Ptr and manage it yourself.
16:58:40 <Eduard_Munteanu> Heap in a heap.
16:58:47 <monochrom> Yeah! const () (undefined `seq` undefined `seq` undefined `seq` foldl' seq undefined undefined)  is not going to bottom out despite all the seqs in the world you put there.
16:58:51 <EvanR> wayne: theres the FFI which includes such vagaries as "malloc"
16:59:08 <EvanR> careful not to segfault
16:59:33 <wayne> Eduard_Munteanu: that's the approach i was going to try...but i was wondering if there were any popular libraries that would provide some higher-level functionality than casting/alloc/dealloc
16:59:41 <EvanR> you can also use a better data structure
16:59:48 <wayne> i want to stay away from FFIs if possible
16:59:49 <EvanR> IntMap to represent memory
16:59:54 <EvanR> or a TotalMap Int
17:06:27 <adamCS> Is it possible to write a type family (or something) that would turn a type-level-list of length n into the equivalent tuple?  E.g., '[a, b, c] -> (a,b,c) ?  
17:08:05 <wayne> adamCS: i think the GHC has/had a tuple limit of 60 or something
17:08:13 <wayne> even if the language standard didn't?
17:08:28 <wayne> and most of the tuple instances are only supported up to 15 elements
17:08:28 <adamCS> wayne:  Suppose I'm comfortable with that limitation?
17:08:48 <adamCS> I don't think I need to actually do anything with the tuples.
17:09:05 <wayne> hardcoding could be the easiest, but if you must, you can probably do something with templatehaskell
17:09:20 <adamCS> Can't hardcode.  I need to do it in general.  
17:09:36 <wayne> i think i saw one on SO before..
17:09:43 <athan> hmm. Say I'd like to block forever on some TChan. How should I do this, without making GHC freak out about it blocking forever?
17:09:44 <wayne> https://stackoverflow.com/a/2923574
17:09:48 <wayne> ^ adamCS 
17:10:58 <adamCS> Not a regular list. I'm asking about an operation on types.  I have a typelist, a list of types, of kind [*] and I want something "equivalent" of kind *, a normal type.
17:11:20 <adamCS> TH might still work, though I've no idea how to do TH on a type-level-list.
17:11:38 <glguy> adamCS: You'll need to write one type instance for each length of list
17:11:44 <athan> hmm. Say I'd like to block forever on some TChan. How should I do this, without making GHC freak out about it blocking forever?
17:11:47 <athan> agh sorry
17:12:18 <monochrom> If GHC freaks out, that means all writers have died.
17:12:36 <adamCS> glguy:  That is painful.  Not the writing but having to be limited. But is probably good enough.  And simpler.   Thanks!  
17:12:36 <monochrom> Do you still want to block on a dead end?
17:12:57 <glguy> adamCS: The different length tuples have nothing to do with one and other
17:14:02 <adamCS> glguy: True.  But I can do other wacky things by writing recursive type families so I thought maybe there was a way.  Like, I think I could do type-list to nested tuples: '[a, b, c] -> (a, (b,c))
17:14:12 <adamCS> But that wouldn't really solve my problem.
17:14:16 <athan> monochrom: ideally yeah, so long as it doesn't consume many resources
17:14:33 <monochrom> I forgot how to do it.
17:14:35 <athan> if it could just "wake up" when I write to it some long time in the future or something
17:14:50 <athan> there's some kind of trick you can do I think
17:14:58 <athan> ezyang has a cool blog post on it
17:15:33 <monochrom> If there is a possible future writer, then GHC doesn't freak out.
17:15:47 <athan> but what if I want my code symmetric ._.
17:16:21 <athan> I'm using them as mock i/o channels from some arbitrary user, and in my unit tests I don't use all of them, if that makes sense
17:20:58 <Brunplunsu> Hi! I'm going to buy a book about Haskell, but I do not lknow which; any suggestion?
17:35:46 <tobiasBora> dmwit: Thank you, the compare using lists seems to work... But I've now some problems with explosion of memory, I'll try to figure why I've that problem
17:36:23 <thang1> Brunplunsu, I'd recommend "Haskell from first principles" as the first book. By the time you're done with that, some good intermediate stuff should be out there
17:36:28 <tobiasBora> However, to do so, I'd need to force the *full* evaluation, (like a deep seq), not just the head normal form of my list
17:36:46 <tobiasBora> to see if the problem is the list itself, or the ordering
17:38:03 <tobiasBora> I saw deepseq from the deepseq package
17:38:09 <tobiasBora> is it what I need ?
17:38:45 <dfeuer> Strange fact about my brain: I hate overlapping instances with a *passion*. Although I definitely understand that there are situatiions where people find it quite useful, I want to see it removed altogether.
17:38:47 <dfeuer> And yet
17:39:25 <dfeuer> I kind of think it might make sense, sometimes, to allow multiple method defaults, with the choice determined by what instances are available.
17:40:06 <thang1> Eh, most people's brains work in contradictions. Not strange at all :p
17:46:39 <tobiasBora> ok, deepseq seems to do the job
17:58:03 <hanna> I have an acid-state problem: I was working on a project, let's say FooBar.hs, and I had everything inside a single big file. I now decided to refactor this and split it up into modules, e.g. FooBar.Types, which is where my acid-state stuff went. Trying to re-open the database from the previous version of the project now fails with this error: `This method is required but not available: "Main.UpdateSite".
17:58:05 <hanna> Did you perhaps remove it before creating a checkpoint?”
17:58:19 <hanna> Of course, UpdateSite still exists - it's just now called FooBar.Types.UpdateSite
17:58:50 <hanna> And apparently acid-state is very stringent when it comes to the full name; is there any solution other than rolling back my code, opening the database, creating a checkpoint, closing it, rolling forwards my code? Would that even work?
17:59:28 <hanna> Indeed, that seems to have done the trick
17:59:31 <hanna> Much ado about nothing
18:15:38 <hanna> I realize this is probably a very open-ended question but what is the premier “parse command line options” package these days? Still optparse-applicative?
18:16:30 <hanna> I don't need much more than a few boolean --flags and a [String] (list of names provided on the command line)
18:20:43 <Zer000> I have a few function definitions that look like this: http://dpaste.com/3PS4W68  it's kind of messy, how should I format/indent them?
18:20:51 <hanna> Actually come to think of it, I don't want just a [String], I also want to parse them for validity (and I can return a list of valid names on error)
18:24:27 <hanna> Seems like optparse-applicative is the way to go, I guess
18:27:20 <lpaste> glguy pasted “for zero000” at http://lpaste.net/355766
18:27:27 <glguy> Zer000: That's a start
18:29:50 <Zer000> glguy, that is better, thanks
18:42:37 <Axman6> is there no unions function? or, foldr union <some empty value> [bd "y" "q", bd "q ...]?
18:42:53 <Costar> Hey all
18:44:36 <Axman6> hello!
18:54:14 <byorgey> Axman6: unions of what?  sets? maps?
18:54:33 <glguy> byorgey: It's in regard to a question about laying out some code earlier
18:54:39 <Axman6> whatever is in Zer000's paste from above
18:56:04 <Axman6> hanna: yeah optparse-applicative IIRC should be able to provide what you want. It's curious that acid-state fix worked!
19:00:03 <joe9> I have an old package that I renamed. but, stack gives me an error about Ambiguous name with the old package name and the new package naem. Any suggestions on how I can clean up the ~/.stack folder? I rm -rf .stack-work in the local package and it did not help.
19:03:07 <Lokathor> so here's a question: how big a deal is it to get a function added to base?
19:05:14 <Zer000> Axman6, nope there's no unions function, just union
19:08:26 <hanna> One thing I can't seem to figure out how to achieve with optparse-applicative is to have a situation where you need to *either* specify --update *or* at least positional argument, or both
19:08:28 <c_wraith> Lokathor: it's not that hard in the best case.  you send an email to the libraries mailing list, there's some discussion, and everyone votes it in.
19:08:37 <hanna> But having no positional arguments and not specifying --update would be illegal
19:08:40 <c_wraith> Lokathor: the hard part is when not everyone is in favor of it. :)
19:09:24 <Lokathor> c_wraith, well, my proposal is simple I think: readFile (and the like) are lazy, and there should simply be a readFile' version that's strict
19:09:42 <Lokathor> I'm sure there are already deep flaws in my logic :P
19:10:12 <glguy> Better than to add that to is for it to be in a package so that you don't have to wait a few years to be able to us it in a backward compatible way
19:10:21 <joe9> Lokathor: protolude might be using the strict version.
19:11:23 <Lokathor> glguy, there is a package with it, and it's a 1 liner really. you just seq length on the contents and then give back the contents and it's all forced right away
19:11:29 <glguy> Not using String based file IO is even better
19:11:39 <Lokathor> glguy, well sure I guess :P
19:12:15 <Lokathor> joe9, i'm not familiar with protolude, but i assume it's one of the many "alternate prelude" things?
19:12:26 <Costar> Monads and Applicatives model computation, right? In what sense this computations is? Automata? Lambda Calculus? Turing Machines?
19:12:33 <Costar> maybe its a silly question
19:12:42 <Costar> but i cannot stop thinking about it
19:14:18 <glguy> Why do you think they model computation?
19:14:30 <Costar> glguy: they dont?
19:14:49 <glguy> Are you changing your mind?
19:14:56 * hackage portager 0.1.1.0, portager 0.1.0.0 (JiriMarsicek): https://qbin.io/hx7701hc2
19:14:57 * hackage hopenssl 2.2, titlecase 1, hopenssl 2.1 (PeterSimons): https://qbin.io/arv5zahj7
19:14:59 * hackage hexml 0.3.2, hlint 2.0.8 (NeilMitchell): https://qbin.io/9ezf22o
19:15:01 * hackage Villefort 0.1.0.8 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.8 (ChrisReuter)
19:15:04 * hackage lame 0.1.1, identicon 0.2.2, htaglib 1.1.1, flac-picture 0.1.1, flac 0.1.2, data-check 0.1.1, cue-sheet 0.1.1 (mrkkrp): https://qbin.io/h0o58dioy
19:15:05 * hackage xturtle 0.2.0.0, yjsvg 0.2.0.1 (YoshikuniJujo): https://qbin.io/xkrmknjel
19:15:07 * hackage sitepipe 0.1.0 - A simple to understand static site generator  https://hackage.haskell.org/package/sitepipe-0.1.0 (ChrisPenner)
19:15:10 * hackage threepenny-editors 0.2.0.8 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.8 (PepeIborra)
19:15:12 * hackage unfoldable 0.9.3 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9.3 (SjoerdVisscher)
19:15:13 <glguy> bye hackage :(
19:15:13 * hackage telegram-api 0.6.3.0, telegram-api 0.6.2.0 (klappvisor): https://qbin.io/9xmvhd7m6
19:15:16 * hackage persistent-relational-record 0.1.1.0 - relational-record on persisten backends.  https://hackage.haskell.org/package/persistent-relational-record-0.1.1.0 (TakahiroHimura)
19:15:19 * hackage feature-flipper 0.1.0.0 - A minimally obtrusive feature flag library  https://hackage.haskell.org/package/feature-flipper-0.1.0.0 (toddmohney)
19:15:21 * hackage ngx-export 0.3.1.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.3.1.0 (lyokha)
19:15:22 <Costar> glguy: im taking a automata/computability class
19:15:22 * hackage fltkhs 0.5.1.6 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.1.6 (deech)
19:15:29 <Costar> glguy: and made me think
19:15:34 <glguy> mniip: ^
19:15:59 <mniip> dammit
19:17:03 <Costar> glguy: probably im wrong
19:17:46 <mniip> well at least I've figured out the problem
19:18:29 <glguy> Costar: I was just asking why you thought that
19:18:59 <glguy> mniip: Cool :) Is the problem easy to explain?
19:19:20 <mniip> basically, it fails to parse a certain row in an rss feed
19:19:25 <Costar> glguy: I read it somewhere. And when this class started, i remembered that.
19:19:29 <mniip> and so it chokes until the row disappears from "recent"
19:19:44 <mniip> and once it does the whole "recent" is new packages so it dumps them at once
19:20:14 <glguy> mniip: Does it have any way to limit the announcement rate for the case where there are actually 20 unique packages released all at once?
19:20:17 <glguy> from different authors
19:20:29 <mniip> uhhh not really
19:20:43 <mniip> I should probably add something like that?
19:20:57 <mniip> assuming we aren't going to see a unique package every minute in near future
19:21:03 <glguy> I guess it's not that common, but it could save it from Sigyn
19:21:15 <mniip> well, there are other ways to save it from sigyn
19:22:27 <mniip> and the reason it failed to parse is pretty stupid
19:22:43 <mniip> someone back in the day decided it's a good idea to make . not match newlines...
19:23:28 <glguy> Which package has a newline in its synopsis?
19:23:53 <mniip> '<i>Added by BryanOSullivan, Sun May 21 01:54:39 UTC 2017.</i><p>Generator and shrink functions for testing\nUnicode-related software.'
19:23:57 <mniip> whatever package that was
19:24:45 <mniip> http://hackage.haskell.org/package/quickcheck-unicode
19:36:08 * hackage HStringTemplate 0.8.6 - StringTemplate implementation in Haskell.  https://hackage.haskell.org/package/HStringTemplate-0.8.6 (SterlingClover)
19:42:32 <glguy> We're already allowed to use type synonyms when declaring GADTs, but not or declaring their fields (e.g. Allowed: type S = T; data T where C :: Int -> S -- but not -- data T where C :: S; type S = Int -> T )
19:42:43 <glguy> I wonder if that's intentional or an oversight
19:46:48 * ski would assume the latter
19:54:19 <Lokathor> I'm trying to transform all these matrixes
19:54:27 <Lokathor> but the linear package isn't making it easy
19:54:33 <Lokathor> it makes me /actually learn math/ instead
19:54:34 <Lokathor> booo
20:04:14 <thang1> Lokathor: what part are you getting stuck on?
20:04:52 <Lokathor> thang1, well it's just that i'm following along with some tutorals that use a C++ lib called GLM, which is specifically oriented to matrixes that control OpenGL
20:05:13 <thang1> ahh right, so you have to convert a bunch of shortcuts and helper functions into the "real math" :p
20:05:15 <Lokathor> so they've got a lot of functions that are, in haskell terms, doThing :: ThingDescription -> Matrix -> Matrix
20:05:28 <Lokathor> yeah
20:05:56 <thang1> Love the documentation for the linear package. Just read the types bro /s
20:06:16 <Lokathor> well, in the case of linear, it's what i'd call justified
20:06:32 <Lokathor> if there was a package about quadratic equations, it'd hardly be able to tell you in a haddock all bout why you'd use one
20:06:37 <Lokathor> same for linear algebra
20:06:52 <thang1> True, it's literally just functions that implement linear algebra
20:07:25 <EvanR> is there an extension i need to enable to make (\(e :: ExceptionX) -> ...) valid syntax?
20:07:30 <Lokathor> thankfully, the module names and opengl terms match up enough that i was able to fumble my way about
20:07:38 <thang1> That's nice
20:08:33 <EvanR> monadicD1ck: hmm might want to fix your nick
20:08:40 <Lokathor> I think I'll still end up writing some sort of, (adjustMatrix :: [AdjustmentOperation] -> Matrix -> Matrix) helper if I end up doing a lot of 3d
20:08:52 <thang1> Change it to monadicR1ch4rd
20:09:06 <Lokathor> monadicGumsho3
20:09:32 <duckqlz> it is suppose to be duck someone took my name sorry
20:09:33 <duckqlz> >_<
20:10:07 * hackage tmapmvar 0.0.3 - A single-entity stateful Map in STM, similar to tmapchan  https://hackage.haskell.org/package/tmapmvar-0.0.3 (athanclark)
20:10:33 <thang1> Lokathor: maybe you can just write a translation of the GLM library into Haskell?
20:10:44 <EvanR> linear man
20:10:57 <EvanR> it seems almost made for opengl
20:11:05 <Lokathor> thang1, unlikely, since I don't know crap about C++, and when I looked at the source it was like 20 template files :P
20:11:19 <Lokathor> EvanR, since the same author made gl, perhaps there was a logic behind it
20:11:24 <EvanR> yes
20:11:34 <Lokathor> though linear uses a row-major ordering, and OGL uses a column-major ordering, i'm told
20:11:35 <thang1> Right, I just meant that GLM has a binch of shortcut functions and helper functions and stuff like that and I just meant more defining those same shortcuts in a module and calling it a library
20:12:00 <EvanR> Lokathor: i recall just doing a transpose before dumping to gl
20:12:08 <Lokathor> yeah taht's what i did
20:12:31 <thang1> Why the hell would anyone ever use column major ordering?
20:12:57 <EvanR> its kind of arbitrary
20:12:59 <Lokathor> thang1, a theoretical "adjustMatrix" would take a list of adjustments (data AdjustOperation = Rotate axis angle | Translate vector | Scale scale) and then fold them down onto the starting matrix
20:13:23 <thang1> Row major ordering has much nicer memory layouts on the hardware for most things, so it's almost always much faster
20:13:29 <EvanR> Lokathor: hmm, thats just 3 separate functions
20:13:33 <Lokathor> that would probably be simple enough to write, and also simple enough to use in pracice
20:13:39 <EvanR> you dont really need a data type to select that
20:13:57 <Lokathor> EvanR, but I like the part where you can put them in a list as a single call
20:14:06 <EvanR> you can put the functions in a list
20:14:10 <EvanR> if you wanted
20:14:11 <Lokathor> hmm
20:14:17 <Lokathor> true
20:14:27 <EvanR> the completed calls that is
20:14:35 <EvanR> which is what those really are
20:14:52 <Lokathor> well you could have a [Matrix -> Matrix], and fold that down onto your starting Matrix, just as easily
20:15:08 <EvanR> yep
20:15:24 <EvanR> foldl' ($)
20:15:34 <Lokathor> hmm
20:15:49 <Lokathor> left?
20:15:57 <EvanR> more importantly '
20:15:58 <Lokathor> yeah left
20:16:16 <Lokathor> oh well the result would almost immediately be dumped into a Ptr value, so it's forced anyway
20:16:36 <EvanR> for 3 matrices dunno if it matters
20:16:54 <EvanR> but i just use ' by default when doing a fold of this kind
20:17:00 <Lokathor> time for lots of microbenchmarks!
20:17:01 <Lokathor> surely
20:21:08 <thang1> woo! bikeshedding!
20:25:23 <dfeuer> I do not like unsafePerformIO. I really wish we had some cleaner way(s) to accomplish its purposes.
20:26:30 <EvanR> like, more things like it that did something more specific or
20:26:50 <EvanR> did something in a more well define way, or whats the issue with UPIO
20:28:03 <thang1> I'm guessing it's more along the lines of "if we had more functions for UnsafePerformX we could make certain guarantees for things, and so limit the potential danger when using them"
20:31:10 <EvanR> i just noticed that the docs say "atomically cannot be used inside of unsafePerformIO"
20:31:18 <EvanR> and that i am doing it anyway, and its working
20:31:35 <EvanR> as long as i dont try to begin a transaction while inside another
20:31:56 <EvanR> mamamia
20:32:06 <Cale> dfeuer: The point of unsafePerformIO is to save you from having to modify GHC in order to obtain some of those things
20:32:21 <CyberShadow> given funa $ funb $ func x, what's the simplest way to make funb conditional on a bool?
20:32:53 <Cale> CyberShadow: if/then/else?
20:33:15 <CyberShadow> Okay. func is longer in my code though
20:33:37 <CyberShadow> Wondering if there's a simple way that doesn't involve defining a function
20:34:00 <Cale> CyberShadow: I don't know what you mean
20:34:07 <CyberShadow> Sorry
20:34:19 <Cale> case would also do it
20:34:28 <dfeuer> Cale: thang1, EvanR, what bothering me is noDuplicate#.
20:34:30 <Cale> If you prefer pattern matching on the Bool
20:34:33 <dfeuer> (at the moment)
20:34:43 <CyberShadow> funa $ (if cond then funb else id) $ func x
20:34:49 <CyberShadow> Does that make sense?
20:34:54 <Cale> yes
20:34:58 <CyberShadow> Thanks
20:35:07 <dfeuer> It's not easy to understand noDuplicate# from a source Haskell perspective.
20:36:01 <dfeuer> And that gets into the weirdness of unsafePerformIO, which makes you have to think about when/where thunks are created, and how to make sure that you're talking about the thunk you want to be.
20:36:38 <EvanR> youre doing something that depends on sharing or not?
20:36:43 <Cale> dfeuer: Well, it exists to prevent the case where two threads both begin evaluation of the expression within a few cycles of one another, and so bypass the blackholing mechanism
20:36:55 <dfeuer> Yes.
20:37:01 <dfeuer> But it's all terribly awkward.
20:37:42 <Cale> There's unsafeDupableIO iirc, if you don't want that check.
20:37:42 <dfeuer> Here's an alternative to unsafePerformIO that feels like it should be less horrible:
20:38:34 <dfeuer> (Slightly less horrible, anyway):  unsafePerformIO' :: IO a -> (# a #)
20:38:55 <Cale> what is that?
20:39:08 <dfeuer> So instead of    let res = unsafePerformIO m in e, you'd have  case unsafePerformIO m of (# res #) -> e
20:39:17 <Cale> An unboxed 1-tuple... containing a polymorphic value somehow?
20:39:37 <dfeuer> Polymorphic?
20:39:41 <hanna> It's 2017, is there a good way to call C++ from haskell yet or is the status quo still writing your own C library?
20:39:53 <EvanR> the way anything calls to C++
20:39:55 <dfeuer> Cale: unboxed tuples can hold polymorphic values....
20:40:09 <EvanR> via extern C linkage
20:40:37 <Cale> hanna: heh, you could do what Ed Kmett is working on and compile Haskell to C++... then you'd get a pretty good story for C++ FFI.
20:40:40 <dfeuer> The vague idea (which may or may not be the right one)
20:40:48 <hanna> “The FFI specification mentions, but does not require, an alternative calling mechanism for C++; no Haskell compiler has ever implemented this.” heh
20:41:13 <tefter> problem is name mangling that is compiler specific
20:41:36 <Cale> Yeah, C++ isn't exactly designed to be easy to FFI to
20:41:53 <tefter> yep
20:42:02 <glguy> dfeuer: How does the unboxed tuple help with replacing noDuplicate#?
20:42:32 <Cale> dfeuer: Oh, I suppose I can see that -- it's the tuple itself which is unboxed after all.
20:43:06 <dfeuer> glguy: the idea (which may or may not really make sense) is to replace noDuplicate# (check that no other thread is evaluating any thunks I am) with creation of a thunk that, on entry, blackholes itself.
20:43:37 <Cale> dfeuer: Every thunk does that already though...
20:44:05 <dfeuer> Cale: no, blackholing only happens when a thread is descheduled, generally (as I understand it).
20:44:15 <Cale> uhh... that's interesting
20:45:21 <Cale> Well, at one point in time, I'm certain it was the case that every thunk entry caused blackholing to occur
20:45:32 <dfeuer> glguy: that thunk is the one that's extracted from the unboxed tuple. So instead of having a thunk created *around* weirdness, it's created *inside* it. The semantics surely still suck, but it feels more manageable.
20:45:35 <Cale> and this machinery was still needed in the presence of unsafePerformIO
20:46:27 <tefter> heh idris compiler does not turns recursion in a loop always
20:46:39 <dfeuer> Cale: there have been several design changes over time, but I couldn't tell you exactly what the history is.
20:46:43 <tefter> so cycle repeat take all blow up stack
20:46:46 <Cale> because even if you do the blackholing, you can have the rare case where one thread enters a thunk, then the other, and then the first thread does the blackholing, and so does the second, and so they're both in there, evaluating away
20:47:37 <dfeuer> Cale: ah, yes, blackholing isn't sufficient. You're right.
20:47:39 <thang1> One thing I'd much rather see is a Rust FFI instead of a C++ FFI. Them types would help a lot... 
20:47:54 <dfeuer> But....
20:48:12 <dfeuer> Maybe the thunk would use a different approach (CAS) to blackholing itself?
20:48:48 <dfeuer> I'm forgetting some details.
20:48:54 <dfeuer> And never learned others.s
20:49:41 <Lokathor> so is using WebGL practical at the moment?
20:49:53 <Lokathor> (in Haskell that is, of course)
20:51:32 <Cale> Lokathor: I haven't tried it, but my understanding is that it is somewhat doable
20:52:05 <Cale> Lokathor: Hey, check this out https://hackage.haskell.org/package/ombra
20:52:08 * hackage haskus-utils 0.6.0.0 - Haskus utility modules  https://hackage.haskell.org/package/haskus-utils-0.6.0.0 (SylvainHenry)
20:53:45 <Lokathor> oh my
20:53:59 <Lokathor> silly me, forgetting that i'd need to use GHCJS
20:54:05 <Lokathor> I'll step away from that dragon for now
21:03:24 <thang1> Maybe purescript?
21:13:05 <duckqlz> no use elm
21:13:59 <Axman6> for a week, until you get sick of writing the same function again and again
21:14:55 <codygman> I have a list of dependencies [("a","b"),("a","c"),("a","d"),("b","e"),("c","e"),("d","f"),("d","e"),("f","e")] and I'd like to be able to get the full list of dependencies for a given dependency. I think I need a Graph, but Data.Graph.buildG seems to only take ints. 
21:15:40 <glguy> Data.Graph's graph is just for tracking nodes and edges. You'd need to keep a separate mapping of nodes or edges to labels
21:15:59 <glguy> fgl is probably the easiest way to go
21:16:04 <Axman6> it's a little gross, but you could hash the values
21:16:26 <duckqlz> Data.Graph.Inductive.Graph can have labeled nodes
21:16:28 <glguy> You'd have to make sure the hashes didn't collide
21:18:28 <Axman6> yeah
21:19:45 <athan> Hey all - when I try running an action in a `MonadIO m => m ()`, but before I do the thing, I run `liftIO $ putStrLn ""` and get different results (a locking mvar, or weird blocking, for instance). Is there a good name for code that behaives like this?
21:20:13 <Sh4rPEYE> Hey. What does it mean to parse "decimal" number? What's the difference between that and an integer?
21:20:36 <glguy> Sh4rPEYE: decimal is specifying that it's a base 10 number, using the digits 0-9
21:20:52 <Sh4rPEYE> And that's it?
21:20:53 <erisco> codygman, can there be cycles?
21:20:56 <Sh4rPEYE> Ok, thanks.
21:21:23 <Welkin> lol duckqlz 
21:21:25 <Welkin> why elm?
21:21:42 <codygman> erisco: No
21:21:44 <athan> basically - doing IO before the thing produces different results (due to garbage collection or something). What would you call this?
21:21:52 <duckqlz> athan: decimal ∈ R , integer ∈ N ??
21:21:56 <Welkin> I built an app that is online right now using elm, and I decided to never use it again
21:22:21 <duckqlz> I really enjoy elm 
21:22:22 <athan> duckqlz: kinda more like
21:22:36 <Welkin> duckqlz: try purescript, you will leave elm behind
21:22:44 <athan> duckqlz: decimal \in positiveDecimals , integer \in positive integers
21:22:51 <athan> given that \in is backwards :v
21:23:00 <erisco> > (Map.fromListWith Set.union . (fmap . fmap) Set.singleton) [("a","b"),("a","c"),("a","d"),("b","e"),("c","e"),("d","f"),("d","e"),("f","e")]
21:23:02 <lambdabot>  error:
21:23:02 <lambdabot>      Not in scope: ‘Map.fromListWith’
21:23:02 <lambdabot>      Perhaps you meant one of these:
21:23:10 <erisco> @import qualified Data.Map as Map
21:23:10 <lambdabot> Unknown command, try @list
21:23:14 <athan> Welkin: atta boy
21:23:24 <erisco> what...
21:24:27 <erisco> I thought someone did this earlier
21:24:45 <erisco> > (M.fromListWith Set.union . (fmap . fmap) Set.singleton) [("a","b"),("a","c"),("a","d"),("b","e"),("c","e"),("d","f"),("d","e"),("f","e")]
21:24:46 <Welkin> try Data.Map.fromListWith
21:24:47 <lambdabot>  error:
21:24:47 <lambdabot>      Not in scope: ‘Set.union’
21:24:47 <lambdabot>      Perhaps you meant ‘S.union’ (imported from Data.Set)
21:24:54 <erisco> I don't understand
21:24:59 <Welkin> fully qualify the names
21:25:01 <erisco> > (M.fromListWith S.union . (fmap . fmap) S.singleton) [("a","b"),("a","c"),("a","d"),("b","e"),("c","e"),("d","f"),("d","e"),("f","e")]
21:25:03 <lambdabot>  fromList [("a",fromList ["b","c","d"]),("b",fromList ["e"]),("c",fromList ["...
21:25:07 <Welkin> :t Data.Map.fromListWith
21:25:09 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
21:25:28 <erisco> no, someone imported these as qualified earlier
21:25:34 <athan> artisanal hotdogs
21:25:35 <erisco> or I am grossly misremembering
21:26:16 <duckqlz> Welkin: Just read a bit a bout purescript and I am already hooked.  Thanks for the advice!
21:26:25 <erisco> codygman, so the next question is if you actually want the transitive closure
21:26:54 <codygman> erisco: TBH I don't know what that means
21:27:06 <erisco> codygman, do you know what transitivity is?
21:27:23 <Welkin> I have been laughing as I've been reading the docs for purescript
21:27:39 <Welkin> it feels like it was written by a category theorist
21:27:56 <Welkin> but the weird thing is that it's not over my head (mostly)
21:28:23 <codygman> erisco: No
21:28:51 <erisco> codygman, transitivity is the property that if a R b and b R c then a R c
21:29:03 <erisco> codygman, a common place you see this is with R as =
21:29:03 <thang1> yay math!
21:29:09 <erisco> or ==
21:29:30 <erisco> in your scenario, R is "depends on"
21:29:55 <Sh4rPEYE> In the chapter about parsers in Haskell Book they say:
21:29:57 <Sh4rPEYE> try :: m a -> m a
21:29:57 <Sh4rPEYE> This takes a parser that may consume input and, on failure, goes back to where it started and fails if we didn’t consume input
21:30:17 <codygman> erisco: Actually, I slightly remember that one from a logical fallacy.
21:30:33 <Sh4rPEYE> So, well, if the parser doesn't consume the input, it goes to the beginning f the input and... fails everytime? 
21:30:35 <codygman> or perhaps just logic
21:31:30 <vaibhavsagar> Sh4rPEYE: it only runs once, not in a loop
21:31:34 <erisco> codygman, the "closure" part is not that important here. That just acknowledges that you have some set of objects which you're forming the dependency relation on
21:32:06 <erisco> codygman, more simplistically we can just ask if your relation is transitive, and if it is not then how do we make it so
21:32:17 <erisco> or, maybe you do not need it to be
21:34:07 <Sh4rPEYE> vaibhavsagar: I worded it badly. I know it runs only once, I just didn't understand how it is useful when it fails if we fail to cosume the input. But I guess the parser can consume the whole input, but don't return Success, in which case the try "returns" back to the beginning of the parsed string. 
21:34:31 <monochrom> Sh4rPEYE: consider "try x <|> y"
21:35:16 <joe9> can anyone please help with this error? http://codepad.org/mIx7tGYq . I am trying to install stack for the first time.
21:35:39 <Sh4rPEYE> monochrom: Actually, I've written this and been surprised it'd worked. That's why I came here :-D 
21:35:42 <Sh4rPEYE> (Right <$> try parseFraction) <|> (Left <$> parseDecimal)
21:36:09 <Lokathor> is there a reason for there to not be an Ix instance that allows any Bounded Enum to be used as Ix, other than sanity?
21:36:30 <glguy> Mainly because that's not how instances work
21:36:57 <codygman> erisco: I'm not quite sure, perhaps if I give the problem I'm trying to solve you or others can help me fill in other holes in my knowledge as well? I have some chronos  (job scheduler) jobs which have parents. I start job A which has no parents, then when it finishes all the jobs that list A as a parent are started. then each of the jobs that list those as parents are started. I want to get every single dependency in that chain (
21:36:58 <glguy> You provide them for specific types
21:36:59 <codygman> and check their status
21:37:10 <codygman> then do an action when the entire dep chainc ompleted
21:37:15 <Welkin> joe9: looks like maybe a corrupt configuration? How are you installing stack?
21:37:33 <Welkin> joe9: I'd recommend just downloading the binary for your system
21:37:41 <Lokathor> glguy, ah, so you can't make a type have an instance as long as it supports some other set of instances?
21:37:49 <Welkin> from there you can upgrade to a newer version if necessary
21:38:22 <joe9> Welkin:  ok, Thanks.
21:38:29 <Welkin> joe9: https://docs.haskellstack.org/en/stable/README/#how-to-install
21:38:30 <monochrom> Sh4rPEYE: Ah. So actually, compare "(p >> q) <|> y" and "try (p >> q) <|> y".
21:38:34 <erisco> codygman, ah, then the transitive closure is probably not what you want
21:38:58 <erisco> you want to just take immediate dependencies
21:39:13 <athan> is there a `x :: IO ()` that is semantically == pure (), but contributes a touch into the IO environment?
21:39:21 <monochrom> Suppose p consumes input and succeeds. Then "(p >> q) <|> y" will commit to q and forget y. If q fails, there is no backtracking to y.
21:39:24 <erisco> in that case  Map.fromListWith Set.union . (fmap . fmap) Set.singleton  should work well
21:39:51 <athan> like a unitary operation, but is actually an IO operation that could cause other code to be discombobulated or something
21:40:00 <Welkin> erisco: not <$$>?
21:40:15 <codygman> erisco: Hm, alright I'll try that
21:40:16 <erisco> this is a more natural progression to lens
21:40:21 <erisco> or something... I don't know lens :P
21:40:26 <monochrom> "try (p >> q)" fixes that. When q fails, now "try" resets to the point before p started and waives the commitment. Now y will be attempted.
21:42:30 <monochrom> What is discombobulated? :)
21:42:49 <erisco> an inculcating word
21:42:49 <Welkin> scrmabled
21:42:57 <Welkin> scrambled about*
21:43:06 <CyberShadow> Given an IO String and a Bool, how do I convert them to an IO (String, Bool) ?
21:43:18 <joe9> Welkin:  I got the static build for linux (which I am on). http://codepad.org/bSUQvSJ1 when I run ./stack install stack.  I have ghc 8.0.2 installed by my package manager http://codepad.org/DVZUdg9Z
21:43:29 <Sh4rPEYE> monochrom: Yes, thank you
21:43:30 <EvanR> not uncombobulated
21:43:37 <joe9> Welkin: but, I still get the same error http://codepad.org/WLBWu7jR
21:43:59 <vaibhavsagar> CyberShadow: fmap (,boolean) <$> ioString
21:44:12 <joe9> https://gist.github.com/2033169fdfb44bea864c36ca904f57b5 Welkin, this is the global-project/stack.yaml file
21:44:21 <vaibhavsagar> actually you don't need the fmap
21:44:27 <cocreature> joe9: by default stack ignores installations of ghc not managed by itself
21:44:51 <joe9> http://codepad.org/mglMBvFp this is from the ./stack/config.yaml
21:44:56 <Welkin> joe9: all you need to do is run `curl -sSL https://get.haskellstack.org/ | sh`
21:45:12 <Welkin> I don't know why you are using ./stack install stack
21:45:22 <duckqlz> [question] What are haskellers using for a backend for web apps?
21:45:23 <CyberShadow> vaibhavsagar: I get "Illegal tuple section: use TupleSections"
21:45:24 <joe9> Welkin: but, that wants root password and I do not want to give it that.
21:45:25 <cocreature> joe9: the error message pretty much covers the options you have, either install ghc via stack  using "stack setup" or use --system-ghc or set that option permanently using "stack config set system-ghc --global true"
21:45:42 <Welkin> joe9: then download the file and inspect it yourself
21:45:57 <Welkin> of course it needs root permission, because it writes outside of your home directory
21:46:01 <joe9> cocreature: yes, I set the stack config system-ghc --global true,  http://codepad.org/AIEKtf7b
21:46:42 <vaibhavsagar> CyberShadow: try fmap (flip (,) boolean) ioString
21:46:49 <Welkin> you can alos always install stack from your package manager too
21:46:53 <Welkin> and then run `stack upgrade`
21:46:56 <Welkin> lots of options here
21:47:05 <codygman> > (fmap . fmap) (+1) $ [(0,0)] -- Why does this increment the second 0?
21:47:07 <lambdabot>  [(0,1)]
21:47:09 * hackage haskus-binary 0.6.0.0 - Haskus binary format manipulation  https://hackage.haskell.org/package/haskus-binary-0.6.0.0 (SylvainHenry)
21:47:14 <cocreature> it seems like joe9 already has a stack binary so you can just copy that to ~/.local/bin/stack and be done with it
21:47:16 <cocreature> and maybe run stack upgrade
21:47:34 <EvanR> > (fmap . fmap) (+1) $ [(True,0)]
21:47:35 <lambdabot>  [(True,1)]
21:47:54 <EvanR> the first component can be any other type
21:48:01 <monochrom> codygman: The inner fmap is (a,?)'s
21:48:01 <cocreature> > fmap fmap fmap (+1) $ [(True, 0)]
21:48:03 <lambdabot>  [(True,1)]
21:48:09 <Welkin> cocreature: are you asking or teaching?
21:48:16 <CyberShadow> vaibhavsagar: That works, but wow
21:48:24 <CyberShadow> Why is it so complicated?
21:48:33 <Welkin> er
21:48:36 <monochrom> Or rather, ((,) a)'s. instance Functor ((,) a) where ...
21:48:37 <Welkin> codygman: ^
21:48:58 <monochrom> ... fmap f (x,y) = can only do (x, f y)
21:49:02 <EvanR> oh wait is the nick supposed to be co-dynman
21:49:12 <joe9> cocreature: ok, got it. Thanks. Welkin.
21:49:42 <cocreature> EvanR: dynman as in the opposite of staticman?
21:49:59 <codygman> > fmap (+1) (0,0) -- I *kind* of understand, but I think this one was closer to my question and it's because ((,) a)'s Functor instance as monochrom said. 
21:50:01 <lambdabot>  (0,1)
21:50:36 <EvanR> > bimap (+1) (+1) (0,0)
21:50:38 <lambdabot>  (1,1)
21:50:48 <EvanR> lets you use both sides
21:50:50 * cocreature waits for someone to complain about the Foldable instance of (a,)
21:51:01 <Welkin> > (fmap . fmap . fmap) (+1) (Just [("lofi", 0)])
21:51:03 <lambdabot>  Just [("lofi",1)]
21:51:03 <codygman> EvanR: Oh, cool.
21:51:05 <EvanR> we need a bifoldable
21:51:07 <Axman6> Can I anti-complain?
21:51:17 <cocreature> EvanR: is that really not a thing already?
21:51:23 <monochrom> Yes! You can praise!
21:51:24 <EvanR> haha i dont know
21:51:31 <cocreature> EvanR: https://hackage.haskell.org/package/bifunctors-5.4.2/docs/Data-Bifoldable.html#t:Bifoldable
21:51:37 <codygman> Welkin: lol, well that makes sense.
21:52:04 <EvanR> Bifoldable ((,,,) x y)
21:52:08 <EvanR> :|
21:52:29 <Axman6> too many ,'s?
21:52:34 <Axman6> hmm, maybe not
21:52:35 <EvanR> the right number
21:52:40 <Axman6> yeah
21:52:41 <halogenandtoast> Does anyone know how to do a 301 redirect in Spock, the `redirect` command seems to do a 302.
21:52:51 <glguy> Maybe the right number is also too many?
21:52:57 * EvanR sends this package to bifrost
21:53:02 <Welkin> halogenandtoast: you can specify explicit status codes using wai
21:53:55 <Axman6> I feel we're approaching https://raw.githubusercontent.com/mxswd/flip-plus/master/Control/FlipPlus.hs
21:54:04 <Axman6> @where+ flip-plus https://raw.githubusercontent.com/mxswd/flip-plus/master/Control/FlipPlus.hs
21:54:04 <lambdabot> Done.
21:54:07 <Welkin> halogenandtoast: http://hackage.haskell.org/package/http-types-0.9.1/docs/Network-HTTP-Types-Status.html#t:Status
21:54:14 <monochrom> What you need is "class NFoldable (n :: Nat) f | f -> n" and "instance NFoldable 3 (,,,)"
21:54:42 <halogenandtoast> Welkin: Alright, I'll try to figure that out.
21:54:58 <halogenandtoast> I assume I have to wrap that in an Action somehow.
21:55:13 <benzrf> Axman6: hahahha
21:55:28 <Welkin> halogenandtoast: well, spock (like almost every other haskell web server library) is built on warp/wai
21:55:32 <Welkin> so you can always use these
21:55:35 <benzrf> Axman6: but why are they operators?
21:55:42 <Welkin> some libraries (not sure about spock) will have higher level wrappers
21:55:46 <Welkin> or you can build your own
21:55:57 <Axman6> ¯\_(ツ)_/¯ 
21:58:58 <Welkin> halogenandtoast: this could be useful http://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html#v:responseLBS
22:01:08 <Welkin> halogenandtoast: inside of Network.Wai.Application you can use this `respond $ responseLBS HTTP.status301 headers ""`
22:02:47 <halogenandtoast> Thanks Welkin I'll try that out.
22:02:55 <halogenandtoast> Seems better than what I was trying to do
22:05:13 <EvanR> checked the source code for getContents, still dont really understand how it works. unsafeInterleaveIO doesnt seem to explain its streaming capability
22:08:08 <glguy> Do you not understand what unsafeInterleaveIO does or not understand how it's used? something else?
22:09:02 <EvanR> it returns an unevaluated value, evaluating it causes the IO to happen
22:09:10 <EvanR> once
22:09:55 <EvanR> but there must be lots of IO happening to get all the contents
22:09:59 <EvanR> multiple times
22:10:04 <glguy> Yeah, so you use lots of unsafeInterleaveIO
22:10:06 <monochrom> You need to dig deeper. The source code of unsafeInterleaveIO itself.
22:10:25 <glguy> It's used one per chunk read
22:10:33 <glguy> each use is nested within the previous
22:10:35 <monochrom> Eventually you will run into a primitive, at which point you need to dig into GHC itself, too.
22:10:47 * EvanR looks again
22:11:22 <opqdonut> seems to me call chain is getContents -> hGetContents -> lazyRead -> lazyReadBuffered which recurses to lazyRead
22:12:01 <opqdonut> and the unsafeInterleaveIO is in lazyRead, so it gets called for every recursion
22:12:25 <opqdonut> I'm reading it from here: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.IO.Handle.Text.html#hGetContents
22:12:43 <glguy> consider a simple example: getChars = unsafeInterleaveIO (liftA2 (:) getChar getChars)
22:13:06 <EvanR> i see it now, lazyRead is being called from within itself
22:13:08 <opqdonut> yeah that should be equivalent
22:13:23 <EvanR> which = unsafeInterleaveIO $ some stuff
22:17:00 <EvanR> well
22:17:10 <hanna> In general, can I assume fromIntegral will be rewritten to more efficient implementations for common cases like converting between Word sizes, or converting between Int and Int64 etc.?
22:17:14 <EvanR> then the actuall appending is somehow happening in unpack
22:17:34 <EvanR> the 4th argument is a "lazy" rest of string...
22:18:38 <halogenandtoast> Seems better than what I was trying to do
22:18:44 <halogenandtoast> oops O_o
22:19:19 <monochrom> hanna: I think yes.
22:26:17 <Axman6> yeah I believe there are rewrite rules for all of those
22:26:46 <EvanR> i see, so basically, UIIO, read a char, rest<-loop, return c : rest
22:27:18 <EvanR> but with a bunch of crunch buffering going on because of unicode
22:27:22 <EvanR> crunchy
22:27:46 <EvanR> that is wacky
22:28:00 <Lokathor> i give up
22:28:17 <Lokathor> where is the thing to normalize a vector in the linear package
22:28:29 <Lokathor> it seems like it'd be there, but it's seemingly not
22:29:08 <peddie> Lokathor: Linear.Metric I think
22:29:31 <peddie> Lokathor: https://hackage.haskell.org/package/linear-1.20.6/docs/Linear-Metric.html#v:normalize
22:30:02 <peddie> Lokathor: hit #3 when I hoogle search `normalize` . . . :P
22:30:09 <Lokathor> oh that hoogle
22:30:21 <EvanR> man linear has gotten a lot more lensy these days
22:30:58 <hanna> Aaw, I can't use ForeignPtr "Xapian::Document"
22:35:46 <Altair_Baltair> Good afternoon
22:42:14 <Axman6> EvanR: Lens exists because of Linear
22:42:25 <Axman6> so sayeth edwardk
22:42:40 * edwardk looks up
22:42:42 <EvanR> and linear exists because of gl ?
22:42:52 <EvanR> or what is the lineage legend
22:42:59 --- mode: ChanServ set -qq *!*@*/ip.216.66.6.76 *!*@*ip.73.190.88.83
22:43:05 <edwardk> linear exists because i needed a way to talk about physics in a purely functional physics engine for an aborted game engine
22:43:41 <edwardk> every time i obsess about graphics in between larger projects the haskel community gets something interesting. =)
22:43:49 <edwardk> gl happened because of another such obsession window
22:43:58 <edwardk> but it was later
22:46:47 <Axman6> If only you were interested in making a game backed by a database and decided you needed a type safe database library which isn't a pain
22:52:34 <LiaoTao> *hint hint*
22:55:39 <Axman6> >_>
22:56:46 <systemfault> What do you people think of free monads? Some articles are basically saying they're the best thing since sliced bread.
22:58:27 <hanna> I'm trying to wrap a pure C++ function that has the signature std::string fun(double val) -- and I want to get it as a CStringLen so I can convert it to String; what would be the best approach to do this? When something expects std::string as a parameter I've just been passing (const char *str, size_t len) to the function and applying the std::string constructor in the C wrapper, but this doesn't work in the
22:58:29 <hanna> opposite direction due to lack of multiple return
22:58:41 * hackage preamble 0.0.36 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.36 (markfine)
22:59:09 <hanna> While I *could* do something ugly like passing a *size_t to write the size into, I don't know how to safely “unpack” a std::string for consumption by Haskell
22:59:34 <EvanR> please use a C string instead
22:59:41 <Axman6> I don't believe the FFI supports C++ directly, so you'd probably need at least a C wrapper around that, and probably to convert it to a char*
23:00:25 <hanna> Well I can't change the API of the library, so I *must* somehow take a std::string and make haskell happy with it
23:00:41 <LiaoTao> hanna: A wrapper seems appropriate
23:00:43 <Axman6> I'm pretty surer you can't
23:00:47 <hanna> LiaoTao: A wrapper is what I'm trying to write
23:00:54 <hanna> But I don't know how
23:00:59 <Axman6> the C++ ABI isn't compatible with the C ABI the FFI supports
23:01:00 <EvanR> you need some C shims
23:04:18 <cocreature> strdup your way to glory
23:06:01 <cocreature> hanna: allocate a Ptr (Ptr Char) on the Haskell side, pass that to your C wrapper. the C wrapper strdups s.data() where s is your std::string to that pointer and returns the length of the string
23:06:20 <cocreature> hanna: on the haskell side, you first marshal the string to a Haskell value and then free it
23:07:19 <ongy> you also need a small std::string -> Word function to get the size
23:07:32 <ongy> unless you know you can just allocate X amount of bytes for all your strings
23:07:34 <hanna> cocreature: Ah, that seems sensible
23:09:17 <hanna> I'm not familiar with C++, if I just have a std::string str = result_from_function(); then it's stack-allocated and would get freed when I leave the function, right?
23:09:56 <ongy> the string is on the stack and will call it's destructor, which does free the value
23:10:05 <cocreature> the std::string object is stack allocated but for larger strings the actual data will be heap allocated
23:10:19 <cocreature> however it will still be freed because the destructor is called it the end of the function
23:10:34 <hanna> Hmm; so either as ongy said the haskell code needs to know how big the string is going to be or I need to allocate it from C++ and then include a second call to free() the string afterwards
23:10:52 <cocreature> right, strdup is the solution for the latter
23:11:29 <ongy> hanna: if you have an upper bound (and don't expect to get to memory bounds) there's nothing stopping you from allocating a few kilobytes first, and then trim it later on the haskell side
23:11:46 <hanna> I do have a reasonable upper bound
23:14:00 <hanna> It's annoying because the Double -> String function is basically pure
23:14:14 <cocreature> unsafePerformIO :)
23:14:17 <hanna> So having to go through malloc() and free() and land in IO hell just because of it is annoying
23:14:24 <ongy> there's something like createAndTrim (not sure on exact name) for ByteString, I'd expect something similar for Text (with string thing's are even more fun)
23:15:09 <cocreature> the FFI is one of the few cases where using unsafePerformIO can be sane
23:15:44 <ongy> but be careful with inlining and stuff, it's not trivial
23:18:25 <cocreature> if your API is actually pure, then I don’t think you need to worry about inlining
23:20:16 <hanna> You know what, I think it's easier to just move my abstraction a bit and avoid the problem altogether
23:20:43 <EvanR> howl's moving abstraction
23:20:50 <hanna> instead of having a Double -> String and a String -> IO () I'll just make specialized Double -> IO () that keeps the std::string in C++
23:20:59 <hanna> More overhead but less work
23:21:01 <hanna> and less brain damage
23:21:35 <cocreature> that seems like less overhead instead of more. you avoid an additional roundtrip via the ffi
23:21:51 <ongy> cocreature: There was some weird thing when unsafePerformIO is inlined, but I read that back when I didn't have an as good idea of what happens in the haskell world
23:22:14 <cocreature> ongy: that weird thing is about performing effects more than once. but if your API is pure you don’t care about that
23:22:20 <hanna> overhead as in number of functions I need to wrap
23:22:51 <cocreature> ongy: i.e., you might call your ffi function twice but who cares if it always returns the same result
23:23:15 <cocreature> (from a correctness point of view. for performance it can ofc still matter)
23:23:24 <ongy> cocreature: I do, maybe it's expensive to compute :)
23:23:46 <ongy> but I guess then I should explicitly let bind it either way
23:24:05 <cocreature> ongy: but then it’s not really different from any other Haskell computation that you don’t want to accidentally recompute
23:24:19 <duckqlz> seems misguided to import an expensive function through ffi :P
23:38:56 <ongy> duckqlz: why? If I have a library that does a task, why wouldn't I call it over FFI?
23:54:55 <hanna> Hmm. So all said and done; I wrote my C shim, I wrote my haskell FFI front-end, the C shim compiles (gcc -c), the haskell code compiles, but `cabal build` fails: /usr/lib/gcc/x86_64-pc-linux-gnu/6.3.0/libstdc++.so.6: error adding symbols: DSO missing from command line
23:55:49 <LiaoTao> hanna: You need -lstdc++
23:56:25 <hanna> Hmm - that's what's throwing me off though; I looked at other examples of C++ wrappers for haskell and they don't mention stdc++ in the list of extra-libraries
23:56:30 <jakub_> Hi what is the name of the extension that lets you select types using '@' (I hope I remember that right)
23:56:44 <jakub_> ahh typeapplications right?
23:57:20 <ongy> hanna: do those include a .o file, or .so? and what are you doing?
23:57:28 <hanna> With the stdc++ added, it still fails linking: lots of “undefined reference `my_function`”
23:57:57 <LiaoTao> hanna: Use g++ instead of gcc?
23:58:05 <LiaoTao> That should add libstdc++ by default
23:58:06 <hanna> LiaoTao: I'm not invoking gcc/g++ manually at all
23:58:15 <hanna> This is Cabal's doing
23:58:21 <LiaoTao> Yeah, I figured as much
23:58:52 <hanna> ongy: I don't know, look at for example https://github.com/ocharles/Xapian-Haskell/blob/master/xapian-haskell.cabal
23:59:08 <cocreature> hanna: is my_function in an "extern C" block?
23:59:11 <hanna> it just has c-sources: <list of .cc files>, extra-libraries: xapian and that's more or less it
23:59:15 <hanna> cocreature: oh, no
23:59:22 <LiaoTao> cocreature: Good catch!
23:59:43 <LiaoTao> hanna: Yeah, be careful of the C++ name mangling 
