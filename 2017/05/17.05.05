00:00:04 <ReinH> unless there's some deeper connection I am unaware of
00:01:19 <thang1> jchia: weird. I used lts-8.13 but it shouldn't have done anything special
00:01:50 <ReinH> mrkgnao: a subobject classifier is a generalization of the characteristic function for set membership.
00:02:03 <jchia> thang1: So 'stack exec which -- blah' doesn't mess up your terminal?
00:02:37 <thang1> Nope
00:03:01 <thang1> I'm assuming at this point that you have a semi-decently customized terminal shell?
00:03:03 <jchia> thang1: OK, I'll try again later on my Arch Linux.
00:03:11 <thang1> open up sh and then try stack exec which -- blah
00:03:18 <jchia> thang1: Yeah, I think there's some customization.
00:03:41 <thang1> If my hypothesis is right, you have some weird color escaping going on that's messing with escape sequences
00:03:59 <jchia> thang1: Same problem in sh
00:04:23 <jchia> Does stack automatically clear out old files in ~/.stack/ and .stack-work/ that are used only by really old resolvers? (I suppose it doesn't.) Is there a reliable way to clear them out without messing things up for the latest resolver I'm using?
00:04:30 <thang1> weird... Can you reproduce the problem by not using stack exec which -- blah, but rather just running some arbritrary thing that will get you a very long line of text?
00:05:06 <thang1> jchia: stack installs are ideally idempotent
00:05:10 <glguy> tonight I've been working on a module for describing how to extract fields from a configuration file, as well as how to generate documentation about that configuration file format that seems to be working well.  http://lpaste.net/355216  there's an example at the top of some output from it. (this is the config language my client and other projects use)
00:05:27 <thang1> So you can just nuke your entire ~/.stack directory
00:05:47 <thang1> and then build and install everything all over again. This time it'll only install what you actually use, of course
00:06:15 <ReinH> glguy: neat
00:06:27 <jchia> thang1: You mean like 'echo `for f in 1 2 3 4 5 6 7 8 9 10; do for g in 1 2 3 4 5 6 7 8 9 10; do echo abcdefghijklmnopk; done; done`'?
00:06:45 <jchia> thang1: If so, it doesn't repro
00:07:07 <thang1> Odd. It's most likely not a term escape sequence issue then
00:07:39 <thang1> (lines that are longer than the terminal width often cause breaking issues with color escape code)
00:08:12 <Maxdamantus> yes abcdefghijklmnopk | head -100
00:09:06 <thang1> I find it really odd that it's that one specific command
00:09:22 <Myrl-saki> Bash? In a Haskell channel? I've seen everything.
00:10:13 <dysfun> yesterday someone wanted to generate bash in haskell
00:10:16 <jchia> Maxdamantus: yes , I did not know that I could use yes with arguments
00:10:26 <thang1> Well I'm trying to debug why terminal escape sequences aren't being interpreted right after someone runs a stack command, it's about as relevant as it gets
00:10:29 <Maxdamantus> Haven't you heard? GHC 9 is going to be rewritten in bash.
00:10:51 <dysfun> Maxdamantus: no, that's 'bashkell'. a whole new paradigm of development awaits
00:10:52 <ReinH> dysfun: they can use the bash monad.
00:10:54 <thang1> I thought it was going to just be one giant perl 5 regular expression?
00:11:22 <dysfun> well perl 5 res *are* turing complete...
00:11:59 <ertes-w> Myrl-saki: it translates into: traverse_ putStrLn (do replicateM_ 2 [1..10]; pure "abcdefghijklmnopk")
00:12:01 <thang1> damn straight they are. Nothing says "I regret my life choices" by forcing regex to be able to parse html and validate email addresses
00:12:03 <Maxdamantus> jchia: if you're willing to assume bash, you might also be interested to know that you can just write `for ((x = 0; x < 100; x++)); do echo abcdefghijklmnopk; done`
00:12:29 * dysfun has pondered disproving "you can't safely parse html in regex" in turing-complete REs
00:12:46 <jchia> Maxdamantus: That's almost like C, except for the double parantheses
00:13:06 <ertes-w> dysfun: turing-complete REs?  you mean like irrational natural numbers?
00:13:14 <Maxdamantus> Yeah, the double parentheses indicate something C like in various contexts in bash.
00:13:26 <dysfun> ertes-w: perl allows the embedding of perl code
00:13:48 <Maxdamantus> x=5; ((x++)); echo $((x*5 + 2))
00:13:51 <ertes-w> dysfun: sure, but the proposition is: "you can't safely parse HTML in *regex*" ;)
00:14:04 <thang1> Maxdamantus: ideally I'd like the forloop to append everything so you get one giant line of text, not 100 lines of text
00:14:11 <ertes-w> dysfun: perl regex can parse super-regular grammars
00:14:16 <dysfun> ertes-w: that perl code is totally in my regex
00:14:35 <Maxdamantus> thang1: well, you can use `echo -n ..`
00:14:45 <dysfun> and actually you don't even need to go that far, they extended the regex engine to be much more powerful anyway
00:14:59 <ertes-w> dysfun: that's because "regex" has been highly overloaded
00:15:14 <thang1> of course you can. I always forget about that one
00:15:15 <Maxdamantus> If you're just looking for random input, I'd just do something like `tr -dc a-z </dev/urandom | head -c 10000`
00:15:17 <thang1> thanks
00:15:20 <dysfun> things i do not consider 'regex' include: posix regex, posix extended regex...
00:15:20 <ertes-w> dysfun: the original "regular expressions" can only parse regular grammars, hence the name
00:15:52 <thang1> jchia: can you run that line of code that Maxdamantus gave and then try the sleep 100 thing?
00:15:53 <dysfun> are they regular? oh hell no, they don't even look it
00:16:01 <ertes-w> dysfun: much like most modern "relational databases" aren't really "relational" =)
00:16:15 <dysfun> i've taken to calling them 'pseudo-relational'
00:16:50 <thang1> Or you could call them disfunctional :p
00:16:55 <ReinH> ertes-w: haven't you heard, words don't mean things any more
00:16:59 <Maxdamantus> note though that the `tr` command above won't produce a newline on its own, so if you pipe it to something it might sit in a buffer forever.
00:17:21 <jchia> thang1: You mean the `tr ...`? No, it doesn't repro
00:17:43 <dysfun> still, i'm not convinced a proper relational database is 'better', as such than postgres
00:17:47 <thang1> But you can still do it with stack exec... ?
00:18:08 <thang1> I gotta admit, I'm stumped. Short of nuking your entire stack environment and reinstalling everything, I'm out of suggestions :p
00:18:41 <thang1> dysfun: I find relational databases to be really nice for things that are modeled really well with relationships
00:19:01 <ertes-w> ReinH: yeah, natural language is stupid…  let's talk in holish
00:19:12 <thang1> But they feel like the OOP of databases. It's "THE" way to do things, so there's all this tons and tons of information about it and nobody ever bothered to ask why we even do things that way
00:19:27 <ertes-w> or perhaps some day we'll talk in hottish
00:19:41 <thang1> and it turns out that people like google, facebook, etc., and basically any super high performance high end "database" system is using stuff that looks literally nothing like a database
00:20:39 <thang1> In fact, all of their data structures in general are just huge mashes of maps, graphs, weird crap sprinkled all over the place, caches out the wazoo, and so on. It's ridiculous, but wicked fast and way more powerful than any old school database
00:20:51 <ertes-w> thang1: recently someone got me really intrigued about mongodb, so i checked it out and did a few minor experiments…  just about when it was going to get interesting, i found myself asking: "ok, how do i code a transaction?"
00:21:02 <ertes-w> 15 minutes later i went back to relational databases
00:21:15 <thang1> Yeah that pretty much sums up mongoDB for me, too
00:21:37 <thang1> "oh neat, this is so cool! Wait... it's useless? Really? Well that's a shame"
00:22:13 <ertes-w> i wouldn't go as far as to call it useless, but it's not much more than a fancy key/value store
00:22:25 <dyreshark> who needs correctness when you have efficiency?
00:22:43 <cocreature> just use /dev/null as a high-performance database
00:22:52 <thang1> Yeah, it's not useless, you just have to have a very good reason to use it.. Even then, there are some other databases out there that do what Mongo does but do it better (at least, it seemed that way last tiem I checked)
00:23:34 <thang1> Garbage collector? Pffh, who needs that. Can't make garbage if your language can't do anything!
00:24:23 <dyreshark> if your app doesn't make garbage quickly, the OS can be your garbage collector
00:24:29 <dyreshark> just restart it when it runs out of memory
00:24:31 <ertes-w> now if you give me something like mongo that can do transactions (and doesn't hold all the data in RAM constantly, i.e. no acid-state), i'd probably use it =)
00:24:50 <thang1> ertes-w: isn't that just postgress?
00:25:44 <ggVGc> dyreshark: or run new processes for each short term task
00:26:04 <dyreshark> true
00:26:30 <ertes-w> thang1: the ability to just dump arbitrary JSON and have it indexed for fast search is nice…  i can see the appeal…  also my application has a schema, i don't need a copy of it in the DB, because that only makes me write migration code…
00:26:34 <ertes-w> [incoming rant]
00:26:49 <ertes-w> … AND THERE IS NOTHING I HATE MORE THAN DATABASE MIGRATIONS!
00:26:56 <dysfun> dyreshark: fast-staring microservices and unikernels
00:27:02 <dysfun> starting*
00:27:25 <ertes-w> anyway, this is getting way off-topic =)
00:27:40 <bartavelle> thang1, postgresql gives you the ability to just dump arbitrary json and have it indexed (sort of, only the top level keys of an object I think)
00:27:43 <bartavelle> erm
00:27:43 <dysfun> monads! applicatives! functor laws!
00:27:47 <bartavelle> that was for ertes-w 
00:28:22 <dysfun> bartavelle: nope, arbitrary json operator expressions actually ("partial indexes")
00:28:50 <thang1> That's the appeal of mongodb. It's all the benefits of a database without any of the hard work*  (*not actually)
00:28:59 <bartavelle> dysfun, ah!
00:29:22 <thang1> But if you need a database and you're a startup and you want something semi function in 2 seconds and you're going through ultra rapid major functionality changing prototyping of data aggregation services...
00:29:27 <ertes-w> bartavelle: postgres has expression indices, yeah…  not quite as convenient though
00:29:35 <thang1> mongoDB is what you want in that case
00:29:38 <dysfun> but of course if you want them indexing, you have to write the indexing code. so you're back to 'looks like work'
00:29:51 <ertes-w> also i'm slowly moving toward doing most things with sqlite instead of postgres =)
00:30:23 <bartavelle> ertes-w, that's not really comparable though, "sqlite was designed to compete with fopen"
00:30:54 <dysfun> most of us can't get away with sqlite, sadly
00:30:57 <ertes-w> bartavelle: yeah…  it's a better fit for me in most cases
00:31:09 <ertes-w> i don't need concurrent access 99% of the time
00:31:28 <dysfun> why don't you just use acid-state then?
00:31:35 <bartavelle> memory usage?
00:31:51 <ertes-w> dysfun: because acid-state is not a "database"…  it just keeps a persistent copy of *in-RAM* data
00:32:09 <dysfun> ah, ok
00:32:38 <ertes-w> i would quickly scale down the number of containers i can run on a single host, if i used acid-state =)
00:32:53 <dysfun> heh
00:34:09 <ertes-w> also acid-state's checkpoints are full database rewrites…  because sqlite has more structural information about the data, it can do checkpoints much more efficiently
00:34:57 <ertes-w> (you could probably teach acid-state how to do that, but not with the current safecopy-based approach)
00:36:08 * dysfun has been trying to do something datomic-like in haskell, but doesn't know enough advanced ghc extensions
00:37:38 <phadej> dysfun: you don't need advanced ghc extensions for that
00:37:47 <dysfun> what?
00:38:00 <phadej> dysfun: to do "datomic" in Haskell
00:38:14 <dysfun> please, enlighten me :)
00:39:42 <bartavelle> dysfun, datomic is written in clojure, which isn't known for its advanced type extensions
00:39:58 <dysfun> yes, but unityping makes it much easier to implement
00:40:14 <phadej> dysfun: i'm not sure you are talking about the client or the server part
00:40:32 <dysfun> both
00:40:37 <phadej> but in both, you can get quite far without an extensions (and my gut feeling says to the end)
00:41:15 <dysfun> well, i can explain some of the things i've run up against and where my thoughts are and maybe you can suggest alternative approaches?
00:41:25 <phadej> except /if/ you want to encode schemas in type-level to make schema-violating queries impossible to construct
00:41:53 <dysfun> maybe later, but for now this isn't a concern
00:42:45 <phadej> and for the rest, there might be invariants you would like to enforce with types; but sometimes it's better ergonomics not to try to
00:42:56 <phadej> stick to GADTs and RankNTypes should get you quite far
00:43:04 <dysfun> the first difficulty is that a datom is effective a tuple of (E,A,V,T,Bool) and V is dependent on A. i couldn't figure out how to solve that without a type family
00:43:17 <phadej> GADT
00:44:29 <dysfun> a GADT would require me to define upfront all the typs that can be stored, wouldn't it?
00:44:52 <phadej> well, in datomic the types of V are closed universe
00:45:07 <phadej> which is only partially open as you can have references (but they are untyped)
00:45:10 <dysfun> the types are, but the attributes aren't
00:45:34 <phadej> dysfun: Use DataKinds and type-level string
00:45:50 <phadej> and make user of the library to provide the V (a :: A) GADT
00:46:01 <phadej> as the mapping is defined by the user
00:46:12 <phadej> (and you cannot really pass in type-families anyway)
00:46:19 <dysfun> okay, that could work, since i already have the user defining type instances
00:47:01 <dysfun> alright, i'll go play a bit more and i'll be back in a bit ;)
00:47:05 <dysfun> thanks
00:47:46 <phadej> dysfun: yet you probably need some V (e :: E) (a :: A) gadt actually, as different attribute may have different type depending on entity
00:48:15 <phadej> but not necessarily of course, if you decide so that same attribute has always the same type, whatever entity has it
00:48:20 <phadej> design choices :)
00:49:13 <dysfun> yeah. datomic likes this namespaced keywords thing. to get that in haskell would mean using module namespaces which means a new module per entity. i think not
00:50:43 <phadej> dysfun: you cannot pass modules in Haskell, so it won't work anyway
00:50:45 <phz_> hey, what is the de facto library for natural transformations?
00:50:53 <phadej> phz_: natural-transformations? :)
00:50:53 <phz_> I have a monad transformer like this:
00:50:58 <phz_> Foo a m
00:51:02 <dysfun> phadej: no, but you could use User.Name instead of UserName
00:51:02 <phz_> and I want to run Foo a n
00:51:07 <jle`> i don't think you need a library for natural transformations
00:51:10 <phadej> without `s`
00:51:18 <phz_> maybe I can go with MonadTransControl?
00:51:25 <phz_> I’ve never used that before
00:51:36 <phadej> phz_: that sounds like you want hoist from mmorph
00:51:38 <jle`> phz_: you might want mmorph
00:51:42 <phadej> ^ :+1:
00:51:49 <phz_> well, that’s a natural transformation, right?
00:52:02 <jle`> it is indeed a natural transformation
00:52:05 <tasslehoff> Trying to compile and run a haskell program on windows (I do not know haskell) I get:
00:52:06 <tasslehoff> C:/Program Files/Haskell Platform/7.10.3/mingw/x86_64-w64-mingw32/include/_mingw.h:542:34:  syntax error before `:'
00:52:34 <jle`> phz_: hoist :: (forall x. m x -> n x) -> Foo w m a -> Foo w n a
00:52:35 <phz_> the type is not the same
00:52:40 <phz_> no it’s not
00:52:53 <phz_> hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
00:52:55 <phz_> well actually
00:53:00 <phz_> I guess it is :D
00:53:06 <jle`> i'm assuming `Foo a` is your monad transformer
00:53:12 <jle`> so it'd be 't' there
00:54:00 <jle`> it is indeed a natural transformation, but that doesn't mean that mmorph is a de facto library for natural transformations
00:54:04 <jle`> there are many natural transformations in base...
00:54:11 <jle`> listToMaybe, maybeToList
00:54:31 <jle`> that's like saying that because hmatrix uses Int, hmatrix is the de-facto library for Ints
00:54:43 <phz_> jle`: well
00:54:47 <jle`> but it's not really; Int is everywhere
00:54:53 <phz_> I’m looking for the “natural transformation” library
00:55:00 <phz_> a bit like :~> from servant, you know
00:55:12 <jle`> what would such a library contain?
00:55:18 <phz_> typeclasses, mostly
00:55:23 <phz_> a bit like mtl / transformers
00:55:49 <jle`> a natural transformation is just any forall a. f a -> g a
00:55:57 <jle`> what kind of typeclasses are you talking about?
00:56:03 <phz_> that exactly
00:56:07 <jle`> just...one type?
00:56:37 <jle`> the entire library is type Nat f g = forall a. f a -> g a? :)
00:56:53 <phz_> well, I don’t know what the library would be
00:57:00 <phz_> but it’d be a generalization of natural transformations
00:57:07 <phz_> a bit like Arrows generalize functions
00:57:32 <phz_> anyway, the transformer is called ProdT actually
00:57:35 <jle`> so it wouldn't be about natural transformations...it'd be some typeclass, of which natural transformations are an instance of?
00:57:37 <phz_> ProdT a m b
00:57:47 <jle`> doesn't really sound like a natural transformation library
00:57:48 <phz_> it implements MonadBaseControl and MonadTransControl
00:57:56 <phz_> can I do what I want with those typeclasses?
00:57:59 <phz_> or do I need hoist?
00:58:19 <jle`> hoist is the most appropriate tool
00:58:26 <jle`> it lifts natural transformations to monad transformers
00:58:29 <phz_> I have ProdT a IO and ProdT a Handler (Handler from servant)
00:58:48 <phz_> I want to run the ProdT a IO in ProdT a Handler
00:58:53 <phz_> which should be “easy”
00:58:58 <phz_> since Handler implements MonadIO
00:59:08 <jle`> yes, sounds like just `hoist liftIO`
00:59:10 <phz_> I should be able to do that by passing through liftIO
00:59:11 <phz_> yeah
00:59:18 <phz_> so hoist seems to be the right tool
00:59:34 <phz_> thank you very much little bird :)
00:59:42 <jle`> mhm.  hoist lifts natural tranformations on monads to natural transformations on monad transformers
00:59:42 <phz_> I’ll add mmorph as a dependency
00:59:56 <phz_> but is not possible with liftWith?
01:00:01 <phz_> (from MonadTransControl)
01:00:11 <jle`> it might be possible but hacky
01:00:18 <phz_> I always find it hard to read signatures from Monad{Base,Trans}Control
01:00:49 <jle`> using :~>, hoist :: (m :~> n) -> (ProdT a m :~> ProdT a n)
01:00:54 <lpaste> av pasted “MMap space leak” at http://lpaste.net/355221
01:01:00 <av> Hi guys, I need some help with this: http://lpaste.net/355221
01:01:21 <jle`> you might be able to use a MonadTransControl tools, but it'd definitely be the wrong too
01:01:23 <jle`> l
01:01:45 <av> This is meant to be a way of writing a very large data set (that doesn't fit in RAM) into a file on disk
01:01:49 <jle`> hoist conveys the meaning that you want
01:01:54 <phz_> liftWith :: Monad m => (Run t -> m a) -> t m a
01:02:02 <phz_> type Run t = forall n b. Monad n => t n b -> n (StT t b)
01:02:09 <phz_> this is so hard to parse :D
01:02:22 <phz_> but yeah, I’ll add mmorph as dep.
01:02:50 <jle`> phz_: the "better" way to fix your problem would be to never have ProdT a IO in the first place
01:02:57 <jle`> but to always use `MonadIO m => ProdT a m`
01:03:02 <av> but is has a space leak -- I expected the amount of memory used to be mostly constant, but it increases with runtime, and quite significantly (400MB for the example code)
01:03:09 <phz_> jle`: well
01:03:16 <jle`> that way it would already unify with ProdT a Handler
01:03:19 <phz_> I have a type working in ProdT a Handler
01:03:25 <av> can anyone tell me what I'm doing wrong?
01:03:30 <phz_> and I’m writing a function expecting something
01:03:39 <phz_> running in ProdT a ?
01:03:49 <phz_> I can put (MonadIO m) => m if I want
01:03:52 <phz_> not sure how it’d react though
01:04:10 <jle`> this is actually the method that mmorph advices in its documentation
01:04:19 <phz_> where?
01:04:44 <jle`> http://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html
01:04:50 <jle`> see the section titled 'Tutorial'
01:05:20 <phz_> yeah, but I still need hoist, right?
01:05:36 <jle`> you would not need hoist if you had MonadIO m => ProdT a m
01:05:44 <jle`> because that already unifies with ProdT a Handler
01:05:53 <phz_> I’m trying
01:05:56 <jle`> you can just use it directly with ProdT a Handler
01:06:02 <phz_>         • Couldn't match type ‘m’ with ‘Handler’
01:06:03 <jle`> no hoist necessary :)
01:06:04 <phz_> nope
01:06:31 <jle`> you might need to change some more type signatures
01:06:39 <phz_> yeah, it’s a bit tricky:
01:06:43 <phz_>                             ProdT args m Health -> ServerT HealthApi (ProdT args Handler)
01:07:02 <phz_> I never know what that ServerT resolves to in servant
01:07:07 <phz_> generally, it resolves to the monad
01:07:12 <phz_> so ProdT args Handler
01:07:16 <jle`> you can make it ProdT args Handler Health -> ...
01:07:35 <phz_> well I don’t want that
01:07:51 <phz_> because the parameter is passed from something that knows nothing about servant
01:07:55 <phz_> (and it should not)
01:08:20 <phz_>           Expected type: ServerT HealthApi (ProdT args Handler)
01:08:20 <phz_>             Actual type: ProdT args m NoContent
01:08:31 <phz_> I wonder how I can get away from that
01:08:46 <jle`> ah.  yeah, then you have two options if the person calling doesn't have to know about servant
01:08:52 <phz_> that’s weird because they don’t even have the same kind
01:08:56 <jle`> you can have it take ProdT args IO Health and use hoist liftIO
01:08:59 <phz_> the former looks like it’s * -> *
01:09:01 <phz_> the latter is *
01:09:18 <phz_> yeah, that’s the first plan
01:09:46 <jle`> the second is to have it take a (forall m. MonadIO m => ProdT args m Health)
01:09:51 <jle`> which would already unify
01:10:17 <jle`> then the user would just be forced to provide something that is polymorphic for all MonadIO m
01:10:25 <jle`> the first is probably nicer overall/less burden to the user
01:10:44 <jle`> mmorph is arguably for the case where you don't control the types you receive
01:11:02 <phz_> hm
01:11:05 <jle`> s/don't control/have constraints on
01:11:09 <phz_> what is the syntax for forall again?
01:11:13 <phz_> I mean
01:11:15 <phz_> the language pragma
01:11:18 <phz_> not the syntax
01:11:27 <jle`> it's RankNType
01:11:30 <phz_> ah yeah
01:11:33 <jle`> but not because of the forall necessarily
01:11:35 <phz_> ghc also tells me
01:11:38 <jle`> but because it would be a RankNType
01:11:44 <phz_> Rank2Type should make it
01:11:44 <jle`> yes, ghc is good at telling you what you need to do :)
01:12:00 <jle`> yeah, it would be a rank-2 type if you used it
01:12:00 <phz_> yeah!
01:12:06 <phz_> it works with Rank2Types
01:12:12 <phz_> neat
01:12:13 <phz_> thanks 
01:12:14 <jle`> RankNTypes is usually preferred these days
01:12:20 <phz_> yeah, well
01:12:23 <phz_> I don’t need that much power
01:12:32 <phz_> I actually never saw anyone needing it
01:12:32 <jle`> but yeah, this imposes some burden to the user because they *have* to provide something polymorphic on all MonadIO m
01:12:41 <phz_> well
01:12:46 <phz_> they have to provide a signature like
01:12:55 <phz_> foo :: (MonadIO m) => ProdT args m b
01:12:58 <phz_> which is fine to me
01:13:01 <jle`> yeah
01:13:08 <phz_> hm
01:13:09 <phz_> actually
01:13:10 <phz_> it’s not
01:13:12 <jle`> that's exactly the burden
01:13:24 <phz_> damn.
01:13:33 <phz_> I guess I should go with IO.
01:13:44 <phz_> so, IO + hoist
01:13:58 <jle`> yeah, let the user provide ProdT args IO a
01:14:03 <jle`> and then hoist it internally when you receive it
01:15:07 <phz_> so I need to write the MFunctor instance for ProdT
01:15:13 <phz_> it should be easy
01:15:54 <jle`> good luck!
01:16:02 <phz_> thank you for your precious help
01:16:05 <jle`> no problem
01:16:08 <phz_> this is for my job work :)
01:16:18 <jle`> actually in this case, ProdT doesn't already have a MFunctor instance?
01:16:19 <phz_> it’s so great doing that for a living :)
01:16:24 <phz_> no, it’s not
01:16:31 <phz_> but it’s just a ReaderT wrapped in a newtype
01:16:38 <phz_> so writing the instance will be easy peasy
01:16:41 <jle`> so "use hoist" probably is not 100% technically correct advice
01:16:48 <jle`> since you still have to implement the lifting functionality
01:16:53 <phz_> yeah
01:17:03 <phz_> but I guess my colleagues won’t find it damaging
01:17:06 <jle`> hoist would just be a nice everyone-understands-it polymorphic way of offering it
01:17:26 <phz_> I guess I could write the hoist “myself” without mmorph
01:17:35 <phz_> but offering it for future uses is ace
01:17:39 <phz_> I’ll write that in the MR.
01:17:40 <phz_> :P
01:17:42 <jle`> like if you defined a new numeric type, "how to add it? use +" would not be technically correct advice
01:17:52 <phz_> sure
01:17:55 <jle`> the real solution is to implement addition, and then you can write a Num instance and use (+) = add
01:18:00 <jle`> so people have a commonly accepted API
01:18:11 <jle`> but yeah, you get it :)
01:18:42 <jle`> actually, whatever ProdT is a newtype wrapper over might already have an MFunctor instance
01:18:56 <phz_> MFunctor (ReaderT * r)
01:18:56 <jle`> definitely lucky to be able to do haskell for work though :)
01:18:58 <phz_> yep :D
01:19:07 <phz_> so I guess I can derive it automatically
01:19:09 <phz_> let’s see.
01:19:11 <phz_> yeah I’m lucky
01:19:17 <phz_> and I have cool colleagues :)
01:19:22 <phz_> haskellers as well
01:19:26 <jle`> :D
01:19:49 <phz_> YES
01:19:52 <phz_> automatically derived
01:19:56 <phz_> that’s so ace
01:19:58 <phz_> jesus I love it.
01:20:18 <jle`> haskell is the best
01:28:31 <_sras_> I have Servant web app that have handlers that run in a custom Monad. I also have a `body check` that runs in `IO`. Is there anyway to run the body check to run in the same Monad as that of the handlers......?
01:29:22 <opqdonut> _sras_: is IO part of your custom monad stack? then use liftIO
01:29:41 <opqdonut> :t liftIO
01:29:43 <lambdabot> MonadIO m => IO a -> m a
01:31:06 <_sras_> opqdonut: That is not the issue. My custom monad requires a reader Environment that contans a couple of stuff. I can run the App monad in the body check if I am willing to duplicate all the work setting up the evn for the reader. I am looking for a way around that.
01:32:40 <_sras_> The app Monad is also not an instance of  MonadIO...
01:38:14 <ReinH> Is the base of the app monad IO?
01:46:56 <_sras_> ReinH: Yes
01:47:12 <ReinH> Then why not make it an instance of MonadIO?
01:47:29 <kuribas> Why does ghc complain about TypeApplications? http://paste.lisp.org/display/345840
01:47:41 <kuribas> I already have it as a language pragma
01:48:15 <ReinH> since that's the only way you're going to run an IO action in it without unwrapping it and rewrapping it manually, which is what you seem to be trying to avoid
01:48:34 <ReinH> (or something equivalent but more complex like monad-base-control)
01:48:35 <rightfold> How do I import (+) from GHC.TypeLits?
01:49:12 <ReinH> kuribas: you should include the error message
01:50:00 <kuribas> ReinH: "Pattern syntax in expression context: read@Double Did you mean to enable TypeApplications?"
01:50:26 <alexbiehl> kuribas: try a space between read and @Double
01:50:33 <alexbiehl> *inserting
01:50:47 <jle`> rightfold: import GHC.TypeLits ((+)) ? if that doesn't work, import GHC.TypeLits (type (+))
01:51:10 <rightfold> Do I need an extension for that?
01:51:18 <jle`> one way to find out
01:51:34 <rightfold> (+) gives an error because it can't find the value (+), type (+) gives a syntax error with no mention of an extension
01:51:34 <kuribas> alexbiehl: thanks, that seems to be it!
01:52:47 <jle`> rightfold: ah yeah, you need TypeFamilies it seems
01:52:53 <av> anyone who could help me with this? http://lpaste.net/355221
01:54:17 <jle`> av: it looks like it's cause you're using 'length d'
01:54:24 <_sras_> ReinH: isn't liftIO used to run IO in an instance of MonadIO? I want to run a function that is in different Monad in IO...
01:54:27 <jle`> which forces the entire list spline into memory
01:54:43 <jle`> that's my suspicion
01:54:59 <jle`> av: i would just pattern match on the result of splitAt
01:55:14 <_sras_> ReinH: The body check should run in IO. But by validation function should run the the custom app monad...
01:55:15 <ReinH> _sras_: what different monad?
01:55:31 <rightfold> jle`: thanks I'll try it
01:55:38 <_sras_> ReinH: You can assume that it is just a Reader.
01:55:42 <jle`> av: if you splitAt 65536, then the second item will be [] if the list is too short
01:55:45 <jle`> > splitAt 1000 [1..10]
01:55:48 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[])
01:55:48 <rightfold> Seems weird though, I think I need TypeOperators
01:55:49 <ReinH> what's the type of this 'body check'?
01:56:04 <jle`> rightfold: you shouldn't need TypeOperators unless you actually use (+) as a type operator
01:56:34 <jle`> if you use it in prefix form then there should be no trouble
01:57:43 <jle`> not that TypeOperators is an extensio you should avoid
01:57:58 <jle`> my point was just that you don't need to have it to import t :)
01:58:46 <_sras_> ReinH:         bodyCheck :: () -> DelayedIO a
01:59:04 <rightfold> > In types, an operator symbol like (+) is normally treated as a type variable, just like a.
01:59:06 <lambdabot>  <hint>:1:9: error: parse error on input ‘,’
01:59:12 <ReinH> Well, then you'll need some way of converting that to an IO action.
01:59:29 <ReinH> I'm not sure what DelayedIO is, or why it's a function from ().
01:59:43 <rightfold> jle`: seems I need ExplicitNamespaces
01:59:48 <_sras_> ReinH: Yes. that is my question....
01:59:57 <jle`> you shouldn't need explicit namespaces
02:00:12 <ReinH> Well, we can't tell you how to do that without knowing what DelayedIO is.
02:00:18 <_sras_> ReinH: I know how to convert it to IO. But I am looking for a way not to duplicate it...
02:00:32 <ReinH> duplicate what?
02:01:14 <kuribas> > printf "%.1f" 4.0 -- how do I get "4.0"?
02:01:14 <jle`> oh, hm, yes, it's ExplicitNamespaces, i just never used it because TypeFamilies includes it
02:01:16 <lambdabot>  error:
02:01:16 <_sras_> ReinH: Say. My AppMonad is a Reader, you need an Environment to run this reader and get a value in IO, right?
02:01:16 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M304655720505...
02:01:17 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
02:01:26 <kuribas> > printf "%.1f" (4.0::Double) -- how do I get "4.0"?
02:01:29 <lambdabot>  error:
02:01:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M705704316461...
02:01:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
02:01:40 <jle`> > printf "%.1f" (4.0 :: Double) :: String
02:01:42 <lambdabot>  "4.0"
02:01:49 <jle`> kuribas: what are you getting?
02:01:52 <jle`> if not 4.0 ?
02:01:54 <kuribas> "4"
02:02:03 <jle`> huh
02:02:09 <ReinH> _sras_: I assume you mean ReaderT Env IO a or similar?
02:02:15 <_sras_> ReinH: Yes. 
02:02:28 <ReinH> @unmtl ReaderT Env IO a
02:02:28 <lambdabot> Env -> IO a
02:02:55 <jle`> rightfold: i tested it on my end and you should only need TypeFamilies
02:03:09 <ReinH> if you're running a ReaderT Env IO a, action, you have already supplied an Env
02:03:10 <jle`> or well, TypeFamilies should be sufficient, at least
02:03:24 <ReinH> if you're *constructing* one, you haven't.
02:03:34 <av> jle`: thanks so much, I think you pushed me in the right direction
02:03:37 <ReinH> so I'm not sure what you think would be duplicated
02:03:41 <jle`> av: no problem!
02:03:48 <jle`> av: yes, usage of length for lists is often a red flag
02:03:50 <kuribas> > (printf "%.1f" (4.0::Double)) :: IO ()
02:03:52 <lambdabot>  <IO ()>
02:04:06 <jle`> av: especially if you use streamy things on it like take/drop/splitAt
02:04:28 <ReinH> it's best not to think of lists as a structure with a length, but rather as an inductive structure defined by nil and cons
02:04:32 <_sras_> ReinH: I have a validation function that runs the body check. If that is in IO, then there is no issue. But I want it to be in the Reader monad.  
02:04:45 <jle`> kuribas: not sure why you are getting 4, it is 4.0 on everything i'm testing it on :/
02:04:56 <ReinH> Again, if you mean ReaderT Env IO a, that's what liftIO is for.
02:05:03 <kuribas> jle`: I am inside the editor on hackerrank
02:05:21 <jle`> av: note also for 'if n == 0'
02:05:28 <jle`> av: you probably really wanted case d2 of [] -> ...
02:05:53 <_sras_> ReinH: What is liftIO for?
02:05:54 <jle`> er, well, case d of [] -> ...
02:06:01 <ReinH> :t liftIO
02:06:03 <lambdabot> MonadIO m => IO a -> m a
02:06:08 <jle`> liftIO :: IO a -> ReaderT Env IO a
02:06:12 <kuribas> jle`: erm never mind, I am reading the wrong output :-P
02:06:15 <ReinH> converting an IO action to an action in a monad that is an instance of MonadIO
02:06:57 <_sras_> I want to run a Reader in IO. Not the other way around.
02:07:03 <kuribas> jle`: I actually "need" 4 as output
02:07:09 <ReinH> That's not what you've been saying though
02:07:10 <jle`> heh
02:07:17 <kuribas> jle`: sorry about that...
02:07:41 <ReinH> :t runReaderT
02:07:42 <lambdabot> forall k (a :: k) (m :: k -> *) r. ReaderT r m a -> r -> m a
02:07:43 <kuribas> So now I need to know how to remove the 0
02:08:03 <ReinH> runReaderT converts your ReaderT Env IO a into Env -> IO a
02:08:13 <jle`> > printf "%.0f" (4.0 :: Double) :: String
02:08:15 <lambdabot>  "4"
02:08:57 <_sras_> ReinH: Yes. So I have to run this runReaderT here, in this 'body check' function, right?
02:09:02 <ReinH> No
02:09:13 <_sras_> ?
02:09:17 <kuribas> > printf "%.0f" (4.425 :: Double) :: String
02:09:19 <lambdabot>  "4"
02:09:21 <ReinH> you do the opposite, use liftIO to convert body check to run in ReaderT Env IO a
02:09:36 <ReinH> since the ReaderT monad is the Servant monad, that's the context you need to run it in
02:09:57 <jle`> kuribas: is that not what you want?
02:10:06 <_sras_> ReinH: This happens *before* the execution hit the handlers. Tht is the whole issue.
02:10:19 <kuribas> jle`: unfortunately I need 4.4 in this case
02:11:11 <jle`> so you want 4.0 => "4", 4.425 => "4.4" ?
02:11:12 <ReinH> What do you mean, before the execution hit the handlers?
02:11:26 <jle`> round to one decimal place, and drop the .0 if it's .0 ?
02:11:33 <kuribas> jle`: yeah, that's what hackerrank expects.
02:11:54 <kuribas> jle`: yeah, I suppose I need something custom
02:12:47 <jle`> > reverse . stripPrefix "0." . reverse $ "4.0"
02:12:49 <_sras_> ReinH: Body check does not happen inside the handlers....
02:12:49 <lambdabot>  error:
02:12:49 <lambdabot>      • Couldn't match type ‘Maybe [Char]’ with ‘[a]’
02:12:49 <lambdabot>        Expected type: [Char] -> [a]
02:13:00 <jle`> aw
02:13:14 <ReinH> Then what does the ReaderT have to do with it?
02:13:30 <ClaudiusMaximus> > {- print . -} reverse . dropWhile (=='.') . dropWhile (=='0') . reverse . printf "%.1f" $ 4.0
02:13:32 <lambdabot>  "4"
02:13:50 <ClaudiusMaximus> oh probably putStrLn, as it's a String by then
02:14:06 <_sras_> ReinH: I want the validation function to use the Env in reader T. So I am looking for a way to carry the environment created at this point (Body check), all the way into the handlers...
02:14:46 <ReinH> it's an env, so it's read-only anyway. Just pass it around until you wrap it up in the ReaderT via runReaderT?
02:14:51 <jle`> @let stripPrefix' p x = fromMaybe x (stripPrefix p x)
02:14:52 <lambdabot>  Defined.
02:14:53 <ReinH> er, it's a reader so it's read-only
02:14:58 <jle`> > reverse . stripPrefix' "0." . reverse $ "4.0"
02:15:00 <lambdabot>  "4"
02:15:04 <jle`> > reverse . stripPrefix' "0." . reverse $ "4.1"
02:15:06 <lambdabot>  "4.1"
02:15:13 <kuribas> > putStrLn $ takeWhile (/= ".") $ printf "%.1f" (4.24::Double)
02:15:15 <lambdabot>  error:
02:15:15 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
02:15:15 <lambdabot>        Expected type: String
02:15:20 <_sras_> ReinH: Body check is part of the Servant's infra. I am looking for a way to
02:15:28 <_sras_> pass it around...
02:15:32 <kuribas> > putStrLn $ takeWhile (/= '.') $ printf "%.1f" (4.24::Double)
02:15:34 <lambdabot>  <IO ()>
02:15:37 <ReinH> fmap reverse . (stripPrefix =<<) . fmap reverse . pure ?
02:15:40 <kuribas> > takeWhile (/= '.') $ printf "%.1f" (4.24::Double)
02:15:42 <lambdabot>  "4"
02:16:07 <Xnuk> > show . floor $ read "4.1"
02:16:09 <lambdabot>  "4"
02:16:46 <kuribas> nvm
02:16:57 <_sras_> ReinH: The body check happens inside an Type class instance definition, which apprently get used by Servant at some point. I don't know how to pass stuff out of it...Which is what i am looking for.
02:18:20 <ReinH> I'm not sure what you're asking at this point. It doesn't seem to bear much resemblance to your original question.
02:19:03 <ReinH> You said you have a body check that runs in IO, but it does not run in IO.
02:19:13 <ReinH> You said you need to run it in a ReaderT, but you do not need to run it in a ReaderT
02:19:36 <jle`> > reverse . (fromMaybe <*> stripPrefix "0.") . reverse $ "4.1"
02:19:38 <lambdabot>  "4.1"
02:19:43 <jle`> > reverse . (fromMaybe <*> stripPrefix "0.") . reverse $ "4.0"
02:19:45 <lambdabot>  "4"
02:20:01 <ReinH> At this point, I think you should work on coming up with a better problem description.
02:22:11 <_sras_> ReinH: Sure. I think It  should be clear for someone familiar with Servant...
02:22:41 <ReinH> Well, I think it would be clear once you state your problem clearly. I've used Servant.
02:24:10 <_sras_> ReinH: I think most people who use Servant does not have to bother with things like this...
02:24:35 <ReinH> The body check is part of the routing internals
02:24:53 <_sras_> Yea..
02:25:02 <ReinH> I'm not sure why you would need to access it in an application
02:25:23 <ReinH> generally, internal modules are not meant to be consumed by library users
02:25:44 <_sras_> ReinH: I am adding Validations to json payloads before it hits the handlers...
02:27:27 <kuribas> > let writeDouble d = show ip ++ if fp == 0 then "" else "." ++ show (truncate (fp*10)) where (ip, fp) = properFraction d in writeDouble 4.24 -- jle` this works too
02:27:29 <lambdabot>  "4.2"
02:27:30 <ReinH> I believe that sort of thing is usually done by writing a custom HasServer instance
02:27:39 <qqwy> Good day everyone!
02:27:56 <ReinH> Ah yeah, this sort of thing https://github.com/haskell-servant/servant/issues/24
02:28:01 <_sras_> ReinH: That is exactly what I am doing
02:28:36 <_sras_> ReinH: This body check happens inside that instance definition..
02:29:05 <ReinH> But you don't need to use a body check, you can just add your validation to route resolution
02:29:12 <ReinH> by implementing route appropriately
02:29:25 <ReinH> you can run arbitrary IO in that context
02:30:13 <ReinH> and then have return a failing response if the validation fails
02:30:20 <ReinH> s/have //
02:31:48 <qqwy> I am in the process of reading the 'what I wish I knew when learning Haskell' guide. (What a wonderful guide!)
02:32:00 <qqwy> I was wondering: When/where are bifunctors used/useful in practice?
02:32:18 <ReinH> The suggestion for dealing with some config at that point seems to be an IORef o_O
02:32:26 <_sras_> ReinH: Yes. I can run arbitrary IO.  But I need to create the env for the Reader monad (my App monad, which I want the validation to run in)...
02:32:31 <ReinH> but I don't really see much alternative, given the way it's designed
02:32:54 <_sras_> ReinH: Ok. I thought about that option...
02:35:19 <ReinH> Yeah, I don't know if servant has a better way to handle this now, but this isn't awesome.
02:35:49 <ReinH> validation should really run in the handler so it has access to your app context
02:37:47 <ReinH> Combinators at one point were explicitly designed to only offer the request context
02:38:50 <ReinH> I think you might be looking for Context
02:39:10 <ReinH> https://hackage.haskell.org/package/servant-0.1/docs/Servant-Context.html
02:39:21 <ReinH> wait no that's old
02:40:45 <ReinH> http://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html#g:9
02:40:51 <ReinH> Yeah, that
02:40:58 <tsahyt> how would I go about short-circuiting a fold?
02:41:07 <ReinH> tsahyt: depends on the fold
02:41:15 <ReinH> foldr is guarded, foldl is not
02:41:35 <ReinH> > foldr (||) False (repeat True)
02:41:37 <lambdabot>  True
02:41:40 <tsahyt> I've got say a [Either Foo Bar]. I want to return on the first Right encountered, but in case there is no Right I need to do a monoid operation over all the Foos encountered
02:41:41 <ReinH> so anything non-strict will short-circuit
02:41:52 <ReinH> if the argument isn't scrutinized
02:42:07 <ertes-w> tsahyt: http://ertes.eu/tutorial/foldr.html#example-take
02:42:48 <ReinH> You can do that with a folding function that is appropriately non-strict
02:42:59 <_sras_> ReinH: Yes. Will  take a look
02:43:23 <tsahyt> ertes-w: thanks, I'll read that
02:44:26 <ReinH> foldr (either mappend const) (Left mempty)
02:44:53 <ReinH> might be what you want
02:45:05 <tsahyt> looks about right, yes
02:45:07 <ertes-w> tsahyt: here is another one: http://ertes.eu/tutorial/foldr.html#example-null
02:45:20 <tsahyt> ertes-w: I think I should set some time aside to read the whole thing actually
02:45:23 <ertes-w> tsahyt: yet another one: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
02:45:50 <ertes-w> tsahyt: yeah, i think it's the most comprehensive foldr tutorial available right now =)
02:45:57 <tsahyt> ertes-w: bookmarked
02:46:08 <ertes-w> and you can easily transfer the knowledge to other algebraic data structures
02:46:12 <ertes-w> like folding trees
02:46:29 <tsahyt> ertes-w: does any Foldable support short-circuiting behavior for foldr?
02:46:38 <tsahyt> or rather does *every* Foldable support it
02:46:47 <ertes-w> tsahyt: no
02:46:56 <tsahyt> hmpf. I guess I can enforce it by doing toList though
02:47:04 <ReinH> er, bimap
02:47:04 <ertes-w> tsahyt: a snoc-list will support it with foldl
02:47:26 <ertes-w> tsahyt: using toList will not help =)
02:47:48 <ReinH> ertes-w: I guess that depends on whether you think foldr is for right-associative folding or guarded folding
02:47:49 <tsahyt> ertes-w: why not?
02:47:54 <ReinH> which happen to coincide for lists
02:47:58 <ReinH> but not for snoc lists
02:48:38 <ertes-w> tsahyt: if you want to be safe, the only option is to use fold/foldMap with a suitable short-circuiting monoid
02:48:43 <ertes-w> that short-circuits on both sides
02:49:01 <tsahyt> hmm that'd have to be a custom monoid I guess
02:49:34 <ertes-w> tsahyt: but if your data structure is list-like or tree-like, then honestly i would just assume that foldr does the usual left-to-right thing
02:50:00 <ertes-w> the counterexamples are mostly theoretically interesting edge cases
02:50:22 <ertes-w> like snoc lists…  nobody uses snoc lists =)
02:50:31 <tsahyt> ertes-w: the public facing API requests a function (a -> t b) where t is Foldable and a Functor. I was expecting to just keep working on what I'm being supplied. though in reality anything that isn't somewhat list-like probably doesn't make too much sense
02:50:42 <tsahyt> it'd either be Sets or HashSets or [] etc
02:50:51 <ReinH> I use snoc lists :p
02:50:54 <tsahyt> it's basically the successor function for a graph search algorithm
02:51:24 <ReinH> snoc vects make vect zippers correct by construction
02:51:32 <Gurkenglas_> tsahyt, Control.Monad.Trans.Either has the Alternative instance such that asum has the behavior you specified
02:51:48 <ertes-w> well, yeah…  you can always go safe and use foldMap
02:53:08 <ReinH> ertes-w: personally, I think foldr is unfortunate because guardedness is often more important that associativity
02:53:24 <ertes-w> ReinH: yeah
02:53:27 <ReinH> I'd rather have foldr on snoc lists be a guarded left fold, but then it's named wrong.
02:53:42 <tsahyt> ertes-w: that reduces the problem to finding a suitable monoid
02:53:56 <ertes-w> personally i think there should be a variant of foldMap that abstracts over (<>) and mempty instead of Monoid
02:54:03 <ertes-w> and that one should be primitive
02:54:15 <ReinH> I think we should characterize folds by guardedness or tail recursiveness tbh
02:54:20 <ReinH> "tail recursiveness"
02:54:47 <tsahyt> I wonder whether I can somehow get away without writing a custom monoid for it
02:55:00 <tsahyt> i.e. cobbling it together from existing pieces
02:55:23 <ertes-w> tsahyt: if you're going to end up with a product monoid, you can use the 'generic-deriving' package
02:55:23 <ReinH> i.e., there's a guarded tree fold that is neither a foldl nor a foldr by left-to-right travesal order
02:55:31 <ReinH> for binary trees
02:55:36 <ertes-w> tsahyt: it will write product monoids for you automatically
02:55:43 <ertes-w> (or you can just use tuples, of course)
02:56:01 <ertes-w> ReinH: i agree
02:56:13 <tsahyt> ertes-w: since it's just a temporary structure I wouldn't mind using tuples
02:56:25 <tsahyt> time to investigate the monoid zoo then
02:56:33 <ReinH> ertes-w: at least, I don't want to have to guess at guardedness because my only choices are right or left
02:56:38 <ReinH> (or foldMap, ok)
02:56:41 <ertes-w> tsahyt: this one is predefined: instance (Monoid a, Monoid b) => Monoid (a, b)
02:57:07 <ertes-w> tsahyt: only if you need custom semantics you need to write your own instance
02:57:27 <ReinH> Hmm, is there something in These?
02:58:11 <ertes-w> ReinH: foldMap is unfortunate, too, because it loses all information about the "sequenceness" of the structure
02:58:37 <ertes-w> implementing 'take' in terms of foldMap makes you question your own function, and with good reason
02:59:02 <ertes-w> while 'take' for lists is perfectly reasonable, for Foldable it's questionable
02:59:15 <ReinH> heh
02:59:39 <ReinH> ertes-w: yeah, if only we could program generically over eliminators
02:59:43 <ReinH> I guess I just want Epigram
02:59:45 <tsahyt> why does Either in base not have an Alternative instance to begin with?
02:59:50 <rightfold> Why do I need standalone deriving for Eq when using existentials?
03:00:04 <ertes-w> in particular, if the structure is tree-like, i would expect something like a Foldable-based 'take' to do depth cutoff, not "get number of elements"
03:00:21 <Gurkenglas_> :t partsOf -- why isn't it "(Functor f, Traversable g) => Traversing (->) f s t a a -> LensLike f s t (g a) (g a)"?
03:00:22 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
03:00:23 <tsahyt> i.e. Monoid e => Alternative (Either e)
03:00:31 <rightfold> tsahyt: what would empty be?
03:00:36 <tsahyt> rightfold: mempty
03:00:41 <tsahyt> Left mempty
03:00:42 <ReinH> ertes-w: Hmmm, you can get this for those foldables which are cofree comonads, I believe
03:00:50 <ReinH> you can write levels, which is take for lists and levels for trees
03:01:00 <ertes-w> ReinH: you can't, because you can't reconstruct
03:01:16 <ReinH> ok, you can get something else which is better anyway :p
03:01:18 <rightfold> tsahyt: that's rather arbitrary
03:01:27 <tsahyt> rightfold: that's also taken from the either package
03:01:51 <ertes-w> ReinH: to be honest, Foldable is a really odd class…  but it the same time it's quite useful, if you just pretend that it's a fancy version of toList =)
03:02:08 <Gurkenglas_> I don't think it's arbitrary, Monoid has exactly the tools you'd need for Alternative (Either m)
03:02:10 <ertes-w> the proper way to do this is with bananas, lenses, something else and barbed wire =)
03:02:13 <tsahyt> rightfold: but there it is defined for EitherT
03:02:18 <ReinH> ertes-w: Foldable is mostly there for Traversable.
03:02:32 <Gurkenglas_> Consider the monoid instance required for Writer
03:02:51 <ReinH> For example, the best answer to "Why is (a,) Foldable?" is "So that it can be Traversable."
03:03:10 <ertes-w> "why is (a,) Traversable?"
03:03:11 <ertes-w> =)
03:03:13 <ReinH> As a Foldable, it is silly. It's a useful Traversable, though.
03:03:22 <ertes-w> "so that you can use it as a lens"
03:03:25 <ReinH> Because (a,) is things with a label
03:03:30 <ReinH> haha
03:03:35 <ReinH> touché
03:03:41 <tsahyt> ReinH: silly or not, everything that is required from a Foldable can be done on (a,), so the instance should exist imo
03:04:04 <ReinH> tsahyt: That's a silly reason for things to exist
03:04:34 <tsahyt> ReinH: I'd rather have that than having to deal with orphan instances and whatever alternatives to that I can cook up for when I might have need for such an instance
03:04:49 <ertes-w> more importantly there are only two implementations of (Foldable (a,)), and only one of them is useful
03:05:02 <ertes-w> ah, no…  you can actually have infinitely many implementations
03:05:05 <ertes-w> but only one is useful =)
03:05:17 <ReinH> I mean, length is another poorly named holdover from centering lists
03:05:19 <ertes-w> so yeah, i agree: it should exist
03:05:34 <ertes-w> ReinH: i think 'length' is fine
03:05:36 <ReinH> it makes perfect sense that (a,b) contains one b
03:05:43 <ReinH> but people get hung up on kength
03:05:48 <ReinH> because (a,b) contains two things
03:05:52 <tsahyt> ReinH: I always thought the only reason to put length into the class was that it allows for efficient implementation in many cases
03:06:00 <tsahyt> e.g. for vectors or Set. things that store their size
03:06:03 <ertes-w> it contains one point
03:06:08 <ertes-w> (and one label)
03:06:17 <ReinH> Yeah, but the name length is confusing
03:06:24 <ReinH> because it's not the length of the structure
03:06:34 <ReinH> it's the count of the points in the structure
03:06:39 <ReinH> it's closer to cardinality than length
03:06:48 <ReinH> maybe size would be better
03:07:05 <tsahyt> I guess points would be somewhat accurate
03:07:19 <rightfold> foldsucc
03:11:15 <Gurkenglas> takeCPS :: Foldable f => Int -> f a -> (forall g. Foldable g => g a -> b) -> b
03:22:11 <kuribas> Does :: have higher precendence than $?
03:22:42 <Gurkenglas> The precedence of $ is low, and that of :: is lower
03:23:32 <kuribas> right, thanks
03:24:02 <kuribas> I expected :: to have the same precedence as application, but I was wrong.
03:24:45 <jeltsch> I am experiencing a weird problem with “untouchable” type variables.
03:24:59 <jeltsch> The code that exposes this problem and the error message are at http://lpaste.net/355224.
03:26:29 <jeltsch> I have no clue what “untouchable” type variables are and why GHC is introducing the type variable c0 mentioned in the error message, given that the type variable c is defined at the outermost level and has nothing to do with the type family F.
03:30:38 * geekosaur suspects this requires an impredicative type somewhere
03:35:11 <niez> Gurkenglas, precedence of :: ? kuribas is talking about 'has type'? in this context talking about precedence doesn't makes sense to me, what am I missing?
03:35:41 <ertes-w> ReinH: you don't assume that "size" will be any less confusing than "length", do you? ;)
03:35:56 <ertes-w> ReinH: it's the "what's a good name for 'return'?" thing all over again =)
03:36:05 <ReinH> it is
03:36:12 <Gurkenglas> niez, does "a $ b :: c" behave like "a $ (b :: c)" or "(a $ b) :: c"?
03:36:26 <ertes-w> i think 'length' is fine, after you have explained Foldable
03:36:40 <ertes-w> it also fits with its iterative nature
03:37:13 <kuribas> niez, Gurkenglas yes, I suppose you cannot mix (::) with operators
03:37:17 <kuribas> > 1 :: Int + 2
03:37:20 <lambdabot>  error:
03:37:20 <lambdabot>      Not in scope: type constructor or class ‘+’
03:37:36 <kuribas> > (1 :: Int / 2)
03:37:38 <lambdabot>  error:
03:37:39 <lambdabot>      Not in scope: type constructor or class ‘/’
03:37:45 <Gurkenglas> kuribas, obviously we restrict ourselves to compiling expressions
03:37:48 <ReinH> > 1 + 2 :: Int
03:37:51 <lambdabot>  3
03:38:03 <niez> ah, ok, so it's about 'has type', not an ordinary function (::)
03:38:36 <jeltsch> geekosaur: Can you elaborate on this? What has this to do with impredicativity?
03:38:53 <Gurkenglas> There are other operators where you can talk about precedence but switching them around stops compilation
03:40:26 <hexagoxel> let type (+) = Either
03:40:30 <hexagoxel> > Left 1 :: Int + Bool
03:40:33 <lambdabot>  Left 1
03:41:30 <hexagoxel> isn't that "mixing with operators"?
03:42:16 <hexagoxel> only thing is the "precedence" of "::" (it is syntax, but the concept still makes sense)
03:42:53 <kuribas> hexagoxel: here + is a type constructor?
03:43:05 <niez> :: isn't part of the expression, is is a type _annotation_, just a hint to the compiler, it isn't used to compute a value, I belive kuribas meant this
03:43:41 <hexagoxel> kuribas: yes
03:43:47 <kuribas> > (1 :: Int) + (2 ::Int) -- this is an expression
03:43:50 <lambdabot>  3
03:44:14 <hexagoxel> but aren't we talking syntax? why does the value/type distinction matter?
03:44:17 <kuribas> niez: I think it's still part of the expression
03:45:32 <kuribas> hexagoxel: I think (::) parses as (expr :: type), so maybe no precedence is used in the parser...
03:45:40 <jeltsch> kuribas, niez: If e is an expression and t is a type, then e :: t is also an expression. The point is that :: is not an operator. So the construct e :: t is not application of an infix operator; it is a different kind of expression.
03:46:25 <tsahyt> any reason other than historical that mconcat /= fold?
03:46:28 <niez> ok, anyway, :info (::) gives an error, so from my point of view it has no precedence at all
03:46:45 <niez> am I wrong?
03:46:46 <jeltsch> The :: binds less than anything else, I think. At least less than any operator and λ-expressions.
03:46:51 <ReinH> It isn't an operator
03:46:53 <hexagoxel> a valid stance. then "function application" has no precedence either.
03:46:55 <balor> I have an Aeson object.  I'd like to descend the object looking for the value of certain keys. Is there a way to map over the object with an accumulator?
03:46:58 <ReinH> operators have precedence
03:47:16 <ReinH> its parse is defined by the grammar
03:47:23 <ReinH> as is function application
03:47:37 <jeltsch> Operators and :: have precedence, so to say. This does not mean that you can use :: with :info.
03:47:48 <cocreature> balor: just write a recursive function?
03:47:52 <jeltsch> :info is only for identifiers and operators, AFAIK.
03:48:04 <jeltsch> You also cannot say :info data or :info let.
03:48:20 <balor> cocreature, Thanks. I just thought there may be a more elegant approach.
03:48:35 <cocreature> balor: what exactly do you mean by “map over the object”?
03:49:48 <balor> cocreature, by that I mean descent each of the objects and arrays from the parent, looking for objects with key=value.
03:51:15 <cocreature> balor: you might be able to use transformM from uniplate and keep the accumulator in a State monad
03:51:27 <balor> cocreature, thanks.
03:51:28 <cocreature> but whether that’s worth the effort is questionable
03:59:52 <xificurC> is there some sort of summary (or can someone summarize here) the state of haste, ghcjs and purescript regarding - completeness, maintenance, userbase, packages, using js packages, FFI, resulting size? These are some of the important things that come out of the top of my head but it takes a while to look for answers on each of them for each impleme
03:59:52 <xificurC> ntation. I'm lazy :)
04:11:34 <tsahyt> is there a way to set a memory limit in ghci?
04:11:53 <tsahyt> like with +RTS -M1G when calling an executable
04:22:06 <Gurkenglas> balor, can it happen that a key with the specified value maps to another object that might contain the key again?
04:22:17 <balor> Gurkenglas, yes.
04:25:08 <Gurkenglas> balor, the accumulator is a Monoid and it's fine if recursively deeper occurences appear first in the mappending?
04:25:39 <balor> Gurkenglas, Yes. Order is not important.
04:25:56 <hexagoxel> tsahyt: afaik calling ghci with +RTS -M1G is the only option; the rts does not provide the api to change things at runtime (to ghci or others).
04:34:35 <quchen> Is Alex Thiemann here? (Or his father, or any of the Freiburg ogas)
04:43:20 <Myrl-saki> Is it only me, or are build times wayyyy slower in ghcjs?
05:01:33 <Guest45040> anyone online?
05:02:18 <cocreature> Guest45040: just ask your question directly and stack around for a while :)
05:03:11 <Guest45040> okay
05:03:15 <ongy> is it also possible to cabal around? :)
05:03:26 <Guest45040> how can i change my name im new in irc
05:03:30 <cocreature> ongy: heh, typing is hard :)
05:03:33 <ongy>  /nick <newnick>
05:03:53 <Whoamii> thanks
05:21:53 <ongy> yo
05:22:00 <ongy> ahh, wrong chat :/
05:34:34 <hvr> cocreature: "stack around"? :-)
05:35:58 * hvr .oO( http://www.smartplay.us/ingenio/images/ablocks_03.jpg )
05:41:58 <xificurC> I'll give this one more go here - is there some sort of summary (or can someone summarize here) the state of haste, ghcjs and purescript regarding - completeness, maintenance, userbase, packages, using js packages, FFI, resulting size? These are some of the important things that come out of the top of my head but it takes a while to look for answer
05:41:58 <xificurC> s on each of them for each implementation. I'm lazy :)
05:42:26 <cocreature> hvr: in my defence, I use a weird keyboard layout where 'a' and 'i' are right next to each other :)
05:42:51 <quchen> cocreature: \/{}*?()-:@?
05:43:05 <quchen> uiaeosnrtdy
05:43:19 <cocreature> quchen: I guess I’m not the only one using that layout :P
05:43:40 <quchen> I tried, but couldn’t do it. I use the 3rd layer with QWERTZ
05:43:46 <quchen> Never looked back
05:44:01 <quchen> Wish I could type Neo though, but the pain of learning it (fluently) is huge
05:44:34 <cocreature> quchen: add layer 4, 5 and 6 to that and you have the important parts of neo :)
05:45:16 <quchen> Come to think of it, I could make Neo my IRC layout
05:45:41 <quchen> Jeez that took long to type
05:46:05 <quchen> 5 and 6 are nonsense
05:46:22 <quchen> 4 … maybe, one day
05:47:11 <cocreature> 5 and 6 are great if you need to type math
05:50:36 <quchen> Which nobody ever does outside of LaTeχ
05:51:09 <cocreature> I often take notes outside of latex
05:51:39 <quchen> Plus it’s incredibly annoying to watch someone struggle with Neo instead of using Agda’s mode because of reasons
05:52:01 <quchen> The only thing words is watching Vim users trying to find and open a file.
05:52:10 <quchen> s/words/worse/
05:52:30 <quchen> Anyway, I’m not a fan of the 5th and 6th layer. :-)
05:53:40 <cocreature> fair enough :)
05:55:08 <NinjaTrappeur> quchen: CTRL-p CTRL-f and done ;)
06:20:55 <greymalkin> I find myself doing something like `maybe (fail $ "message") return` a lot these days.  Hoogle hasn't shown me any cleaner way to do this.
06:36:22 <NickHu> Anybody got any advice for debugging segfaults?
06:37:44 <c_wraith> depends on the source.
06:38:06 <ertes-w> greymalkin: maybe (throwIO (userError "message")) pure  -- this way is cleaner, but i'm pretty sure that's not what you're looking for =)
06:39:12 <c_wraith> ertes-w: it's also only correct if it's in IO.  What if greymalkin was talking about some other context where fail is defined sensibly?
06:40:37 <ertes-w> s/throwIO/throwM/
06:40:41 <ertes-w> from 'exceptions'
06:40:58 <ertes-w> at least until we finally get MonadFail
06:57:10 <ADG> how to remove "stack" if I installed via "https://get.haskellstack.org/" (sh) - Ubuntu 16.04 64 bit
07:00:43 <mekeor> ADG: maybe this helps? https://docs.haskellstack.org/en/stable/faq/#how-do-i-reset-remove-stack-such-as-to-to-do-a-completely-fresh-build
07:00:47 <mekeor> ADG: where is the stack binary you are using located? (`which stack`)
07:01:10 <ADG> usr/local/bin/stack
07:01:24 <ADG> I removed ~/.stack but still stack command works
07:01:30 <cocreature> remove the binary
07:02:24 <cocreature> the stack binary should be statically linked so it really should just be that one binary (plus dotfiles in .stack)
07:02:53 <ADG> that is ok, so now I should also have remove it from bash entry or something?
07:05:47 <c_wraith> I mean..  if you've removed the binary, bash won't be able to run it.
07:23:27 <greymalkin> ertes-w: Fail is just the shortest IRC line; I'm actually using throwM in most cases, but having to repeat the `pure` at the end feels hacky, and I'm on the edge of just making a `guardJust` function which takes the error type and the maybe value.
07:24:07 <ertes-w> greymalkin: well, you could just use throwM without doing the Maybe roundtrip
07:24:37 <ertes-w> greymalkin: or use Alternative instead of Maybe
07:25:47 <mrkgnao> is there any way to get overloaded numeric literals for non-Num types?
07:25:53 <ADG> running "$ stack upgrade" is stuck on  "Fetching package index ... ", is it normal (takes much time?)
07:26:09 <greymalkin> ertes-w: Interfacing with other libraries, though, so that's not quite an option for most of my cases.
07:26:11 <MarcelineVQ> it can take awhile the first time
07:26:13 <mrkgnao> for instance, can I get 0 to be interpreted as a Monoid a => a?
07:26:37 <ertes-w> greymalkin: if all else fails just write your own utility function
07:26:47 <cocreature> mrkgnao: RebindableSyntax allows you to provide your own fromInteger function
07:26:54 <mrkgnao> oh?
07:27:01 <mrkgnao> oh?!
07:27:11 <MarcelineVQ> or if you deleted .stack/indices/ it has to get it fresh
07:27:32 <ertes-w> greymalkin: at the caveat that it makes your code less direct and thus harder to follow
07:27:51 <mrkgnao> cocreature: I am so happy right now. always assumed that was one place that GHC went "okay, this is final"
07:28:03 <glguy> the initial download is around 240mb
07:28:37 <ADG> my ~/.stack was empty I removed it
07:28:43 <cocreature> mrkgnao: imho it’s kind of an ugly extension since just replacing builtin syntax can be confusing but it’s nice that it’s possible
07:28:57 <ADG> 240MB, fuck~ can I get a progress bar?
07:29:30 <Cale> mrkgnao: Don't *actually* do that.
07:30:22 <cocreature> Cale: overloaded integer literals is the only use of RebindableSyntax that is at least close to being reasonable :)
07:30:33 <Cale> I suppose
07:30:44 <mrkgnao> cocreature, Cale: I'm just playing around with something subhask-ish. doing this in anything remotely close to being used practically would be ... interesting.
07:31:18 <mrkgnao> I guess it's better than partial Num instances that only match one fromInteger pattern :)
08:26:30 <nshepperd_> If you use RebindableSyntax there it will apply to all numeric literals though
08:26:36 <nshepperd_> Not just 0
08:30:31 <nshepperd_> So whatever you do we'll probably be partial if you don't have a good definition for 1
08:31:12 <qqwy> Guys, when a piece of Haskell code compiles, what is left of the types? Do values of a type contain a vpointer to the type's typeclass implementations?
08:31:19 <qqwy> How does Haskell know at runtime what type a value has?
08:32:01 <EvanR> it doesnt
08:32:02 <Sornaensis> I don'
08:32:06 <Sornaensis> t know about interpreted
08:32:09 <EvanR> and doesnt need to
08:32:12 <Sornaensis> but haskell code has the types erased
08:32:17 <Sornaensis> after compilation
08:32:40 <qqwy> Does someone know where to find more information about this?
08:32:50 <qqwy> I've been browsing the GHC webpages for the last 30 minutes
08:32:54 <EvanR> for type class implementations, you can think of constraints as being extra arguments which point to the record of class implementations
08:33:00 <Sornaensis> the purpose of a strict and static type system is that once the application is compiled you do not care what the types are at runtime
08:34:14 <qqwy> Thank you, Sornaensis
08:34:21 <qqwy> for confirming my gut feeling
08:34:28 <EvanR> qqwy: in machine code, you dont check what the type of something is before doing the instructions, you just assume
08:34:31 <qqwy> Someone was comparing OCaml and Haskell in a rather unfair way
08:35:00 <Sornaensis> type erasure is common to most compiled languages
08:35:01 <EvanR> and either hope youre right, or you have a proof youre right, which is what a type system does
08:36:02 <nshepperd_> qqwy: Num a => a -> a is compiled into Num a -> a -> a
08:36:07 <Sornaensis> qqwy: in what way
08:36:36 <qqwy> EvanR: C++'s object-orientation constructs work with a dynamic vtable pointer. I guess this is mostly the case because a piece of compiled code might be linked into by another piece of code that inherits one or multiple of those classes.
08:36:49 <EvanR> that is how haskell works too
08:36:51 <qqwy> (Not counting CRTP-style OOP)
08:36:54 <nshepperd_> The Num a value is a record type containing all the Num functions for that type, and is passed as a normal parameter
08:36:56 <EvanR> see nshepperd_'s post
08:37:08 <qqwy> Ah!
08:37:18 <EvanR> its just not called a vtable
08:37:20 <qqwy> So 'Num a' is passed around as extra construct
08:37:26 <qqwy> extra argument*
08:37:33 <EvanR> in the worst case yeah
08:37:35 <nshepperd_> If your code is monomorphic, that is usually inlined and nothing will even be passed
08:37:46 <qqwy> wonderful, I see! :D
08:40:27 <EvanR> that reading of Num a => a -> a seems really far from whatever the types are supposed to mean denotationally... i wonder why it never came up when i was learning haskell. seems like a great way to explain haskell to a C++er
08:40:56 <EvanR> i wonder if its a big coincidence
08:43:07 <nshepperd_> Well, -> and => are both implication arrows in curry Howard. If a, then b
08:44:49 <EvanR> but with => your supposed to think "will check if and only if for your choice of a theres a unique choice of Num"
08:45:11 <nshepperd_> But => has some restrictions that make is more like witnessing a "fact", such as instance coherence
08:45:12 <EvanR> which seems difference 
08:45:38 <nshepperd_> "Num a" is a fact that has a unique proof
08:46:12 <Lokathor> in a haskell type, => can be read as "allows"
08:46:17 <Lokathor> (though that's not the only word you could stick there)
08:46:28 <EvanR> erm
08:46:41 <EvanR> doesnt really capture the reverse uniqness
08:47:06 <Lokathor> reverse uniqueness?
08:47:20 <EvanR> which agda and idris dropped, so it really is just like ->
08:48:42 <nshepperd_> instance coherence means that the compiler can thread these implicit arguments around for you, since there's only one possible choice of argument
08:57:35 <mrkgnao> nshepperd_: I know, I've been trying to figure out if something sneaky can be done to dynamic-ish-ly select the typeclasses, i.e. a multiplicative monoid for 1 and an additive monoid for 0
08:59:20 <mrkgnao> there must be some way using reflection, but ... "'tis a silly place", etc
09:11:26 <qqwy> Thank you, EvanR, nshepperd_ and Lokathor
09:11:27 <qqwy> :-)
09:33:06 <Hjulle> Does the function "\f x -> fmap ($x) f :: Functor f => f (a -> b) -> a -> f b" have a name? It is useful for writing things like "f <$> pure a <*>  b <*> pure c <*> pure d" without needing to flip the order of the arguments or needlessly requiring Applicative.
09:37:32 <byorgey> Hjulle: no
09:37:34 <ski> Hjulle : it has been called .. `flip'
09:38:14 <byorgey> ski: ?
09:38:36 <byorgey> oh, I get it, it's a generalized flip
09:38:39 <ski> lambdabot had that type for `flip', for some time
09:39:04 <byorgey> @let flip' f x = fmap ($x) f
09:39:06 <lambdabot>  Defined.
09:39:16 <byorgey> > flip' (-) 3 5
09:39:18 <lambdabot>  2
09:39:34 <Hjulle> ah, nice.
09:39:35 <byorgey> > flip' [(+1), (*3), const 8] 2
09:39:38 <lambdabot>  [3,6,8]
09:40:32 <byorgey> I'm not sure I like that name though.  The name is too tied to the ((->) a) instance and IMO doesn't really give much intuition for what it does in general.
09:41:02 <ski> iirc, i've also seen this operation in a paper
09:41:14 <Hjulle> I was thinking about something like <*$>, but that looks ugly.
09:41:21 <ski> (can't recall how it was called or notated)
09:42:59 <Hjulle> I also tried searching hoogle, but that only gave me fmap, <*>, etc., that do not have the correct type. Why is hoogle's type search so fuzzy?
09:44:26 <starmix> exit
09:44:33 <starmix> oops sorry
09:45:12 <byorgey> Hjulle: because sometimes you don't know the precise type you want, and fuzzy type search is useful.
09:45:33 <byorgey> or sometimes you think you know what type you want, but there is actually something more general that will work.
09:46:14 <Hjulle> byorgey: I'm fine with more general, but not with types that don't match at all.
09:49:51 <viper97> totally new to haskell. any good books?
09:51:33 <monochrom> Graham Hutton's textbook. RIchard Bird's textbook. Chris Allen's textbook.
10:04:38 <tabaqui> I'm receiving messages from my program:
10:04:50 <tabaqui> ProgName: unable to decommit memory: Invalid argument
10:05:01 <tabaqui> what does it mean?
10:05:34 <tabaqui> I've found bug in old version ghc, but it was closed few years ago
10:05:36 <monochrom> Yes, this is a known issue, but it only happens when the program exits, it is considered no harm but will be fixed next time.
10:06:01 <tabaqui> oh, that's fine then
10:06:09 <monochrom> Let me think where I read about it.
10:07:38 <monochrom> At program exit, the run time system calls a deallocation syscall, and the syscall didn't like the parameter. (Not sure who's fault.)
10:08:01 <cocreature> tabaqui: are you using 8.0.1? I vaguely recall seeing that 8.0.2 fixes this at least in some circumstances
10:09:08 <tsahyt> how can I run ghci through stack with rts options? stack ghci -- +RTS .. doesn't work
10:09:15 <tsahyt> oh nvm, --ghc-options
10:09:27 <cocreature> tsahyt: you might need --ghci-options
10:09:38 <cocreature> but tbh I’m not sure what exactly the difference between those is
10:09:47 <cocreature> ah --ghc-options applies to both
10:09:50 <cocreature> I should just read --help :)
10:10:04 <tabaqui> cocreature: I compile it with 8.0.2, but run on other machine
10:10:08 <tsahyt> hmm, neither actually works
10:10:09 <Gurkenglas> Hjulle, https://hackage.haskell.org/package/distributive-0.5.2/docs/Data-Distributive.html#v:distribute
10:10:42 <tabaqui> cocreature: stack lts-8.9
10:11:56 <Gurkenglas> Hjulle, also "f <$> pure a <*> b <*> pure c <*> pure d" is "f a <$> b <*> pure c <*> pure d"
10:12:22 <cocreature> tabaqui: I think https://ghc.haskell.org/trac/ghc/ticket/12865 is the fix. judging from that ticket it’s only in 8.2 so maybe my memory is wrong here and it’s not fixed in 8.0.2
10:12:28 <Gurkenglas> Hjulle, http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Lens.html#v:-63--63-
10:12:37 <Hjulle> Gurkenglas: Thanks
10:13:26 <Hjulle> Gurkenglas: Yes, I know, but that doesn't solve the problem with c and d.
10:14:00 <cocreature> tabaqui: the good news is, 8.2 should be out relatively soon (1-2 months is probably realistic)
10:14:37 <tabaqui> cocreature: but our team will release in three weaks)
10:14:45 <tabaqui> *weeks
10:15:12 <cocreature> tabaqui: well as monochrom said it’s mostly harmless
10:15:24 <Hjulle> Gurkenglas: The last one was exactly what I was looking for and the first one is a cool generalisation. :)
10:15:28 <tabaqui> btw, bug with hWaitForInput is still open
10:16:18 <tabaqui> I thought it will be fixed in April and I can use it soon
11:19:45 <Gurkenglas> stack unpack has nothing to do with the git projects the maintainers use, right? Can stack help me make pull requests to libraries?
11:25:50 <cocreature> Gurkenglas: I don’t think there is something like "stack unpack" that clones the source-repository. ofc you can just manually search for it and build it using stack so in that sense stack can help but it has no specific functionality for prs
11:34:35 <jle`> 'stack unpack' is a command
11:35:08 <jle`> oh but yeah it doesn't do that
11:36:21 <mojjo> hi!! is there anyone who could help me out with some simple aeson parsing?
11:36:45 <cocreature> mojjo: just ask your question directly and stick around for a bit :)
11:37:57 <mojjo> I'm basicall trying to parse the keys of a json object into a list of strings, I think it's not possible to derive that.
11:38:23 <jle`> you can just parse your json string into an Object
11:38:26 <jle`> and then get the keys
11:38:46 <EvanR> after you have an Object, getting the keys is a regular function, of the HashMap 
11:39:00 <jle`> you could even parse it as a regular ol Data.Map
11:39:40 <cocreature> converting to a different map type just to extract the keys seems a bit overkill
11:40:05 <jle`> it'd just be `fmap M.keys . decode`
11:40:25 <jle`> fmap M.keys . decode :: ByteString -> Maybe [String]
11:40:27 <mojjo> jle' alright, I'll try your suggestion...
11:40:52 <jle`> maybe [] M.keys . decode :: ByteString -> [String]
11:40:53 <cocreature> jle`: right but it’s just as simple if you use M.keys where M=Data.HashMap :)
11:41:15 <jle`> yeah heh. there's really no reason to prefer one over the other
11:41:24 <jle`> hashmap might be slightly more performant for this
11:41:35 <jle`> but from an API perspective there is no difference
11:41:46 <cocreature> right, I was talking about performance/unnecessary conversions
11:41:53 <jle`> ah
11:42:18 <jle`> operational junk
11:42:21 <cocreature> it probably doesn’t matter but since the API is the same, just use the potentially faster one :)
11:43:29 <EvanR> is there binding form like do notation where after i bind whatever variables, i "finalize" by entering an expression that uses the variables, but i cant continue on like do notation
11:44:06 <jle`> applicative do ?
11:44:09 <monochrom> an inner do block.
11:44:25 <EvanR> i can continue on after an inner do block
11:44:29 <EvanR> hmm applicative do
11:44:54 <monochrom> oh, that kind of "continue"
11:44:56 <EvanR> also inner do is irrelevant
11:45:07 <EvanR> the final expression isnt necessarily a monad
11:45:07 <jle`> but you can't force a do block to be applicative-only if you have a specific type tho
11:45:48 <monochrom> let-in
11:46:01 <EvanR> like exp(x), exp(y), exp(z) |- final(x,y,z)
11:46:21 <EvanR> oh ok let... *thinks*
11:47:11 <cocreature> "let x = expx; y = expy; z = expz in final <$> x <*> y <*> z"
11:47:35 <EvanR> uh huuuuuh....
11:47:44 <monochrom> Or maybe it's just final x y z
11:47:55 <cocreature> I’m not sure I really understand your question tbh
11:48:13 <monochrom> I mean at this point the question has become vague enough that any truism is a legit answer.
11:48:29 <mojjo> jle`: I could parse the json to `Maybe Object`, I'm still wondering how to acces the keys. fmap over Object maps over its values..
11:48:34 <EvanR> all this is literally answering my question
11:49:47 <EvanR> so like, could x cause a non deterministic computation, y cause a quit-early, ...
11:49:53 <cocreature> mojjo: you fmap over "Maybe Object"
11:50:03 <cocreature> mojjo: or just pattern match and don’t fmap in the Just case
11:50:14 <EvanR> probably
11:50:15 <cocreature> EvanR: depends on the Applicative instance
11:50:31 <EvanR> seems like list monad with just applicative notation
11:50:35 <cocreature> EvanR: for "Either a", a Left would cause a quit-early
11:50:56 <monochrom> Do you actually have an example x, example y, and example final?
11:51:59 <EvanR> if x is an object of class X, and y is true in the context, and z is some unique object (if it exists), then f(x,y,z) occurs
11:52:14 <EvanR> so this potentially does nothing, or does something for each x
11:52:35 <monochrom> No I mean actual code.
11:52:38 <EvanR> no
11:53:18 <cocreature> EvanR: you got me interested. what are you working on?
11:53:29 <EvanR> video games
11:54:13 <cocreature> huh, what do you use that for in a video game? rules that define how game state progresses?
11:54:32 <EvanR> the rules of inferences are the rules of the game, the axioms are the starting position
11:55:25 <mojjo> cocreature: ok, concretely, say : `x = decode $ "{\"key1\":\"\"}" :: Maybe Object` then x is `Just (fromList [("key1",String "Dave")])`. How to get/pattern match the "key1" out of the structure?
11:55:30 <monochrom> Then I am not convinced that "can't continue" is true.
11:55:33 <LordBrain> i had an idea occur to me yesterday, that a videogame could be used to teach haskell.
11:55:52 <monochrom> But meh, I don't even know what's "continue".
11:56:02 <mojjo> cocreature: (the Dave string is a typo)
11:56:09 <EvanR> i did something like this in this video https://www.youtube.com/watch?v=p1xUViqtYFA but i used monads to say these phrases, and it worked but really its a little weird 
11:56:23 <cocreature> mojjo: case decode … of Just obj -> Map.keys obj; Nothing -> handleParseFailure
11:57:25 <kamyar> Hello friends!
11:57:40 <kamyar> Can we write this better: (||) <$> Just True <*> Just False
11:57:56 <kamyar> I wanna use infix notation if possible
11:58:19 <monochrom> consider "liftA2 (||) xxx yyy"
11:58:30 <kamyar> Note that the real code is not so easy! 
11:58:34 <cocreature> > let (|||) = liftA2 (||) in Just True ||| Just False
11:58:36 <lambdabot>  Just True
11:58:41 <monochrom> If you want infix, create your own infix operator and define it to be liftA2(||)
11:58:45 <cocreature> but I wouldn’t call that better
11:59:03 <monochrom> Yeah, it's only the first step towards better.
11:59:23 <monochrom> To complete the journey, create your own infix operator.
11:59:29 <kamyar> IN real code True and Flase are expressions
11:59:36 <monochrom> WE KNOW
12:00:06 * cocreature removes monochrom’s capslock license
12:00:17 <Tuplanolla> Technically they're always expressions...
12:00:21 <glguy> cocreature: he's going to need that back to turn it off...
12:00:42 <cocreature> glguy: oh right
12:00:44 * cocreature hands it back
12:01:35 <monochrom> haha
12:02:18 <kamyar> Here is my real code: http://lpaste.net/355245
12:04:04 <monochrom> My answer stands.
12:04:17 <mojjo> cocreature: had to parse directly to `Maybe (Map String String)` in order to get it done.. nice..
12:04:48 <cocreature> kamyar: I made an annotation
12:05:41 <EvanR> cocreature: so... objectOfClass :: Class a -> Ante a, isTrue :: (Context -> Bool) -> Ante (), onEvent :: Event b -> Ante b, and f could be :: a -> () -> b -> Consequent. the applicative combination would be Ante Consequent which has interpretation ???
12:06:31 <greymalkin> Is there a non-deprecated way to do something like the following? newtype Currency currency => Money currency = Money Scientific
12:07:01 <MitchellSalad> greymalkin: yeah, put the constraint on all the functions involving Money, but not the data type itself
12:07:02 <kamyar> cocreature: Thnx really!
12:07:53 <c_wraith> > let x <^ f = (fmap f x <*>) ; (^>) = id in Just 1 <^(+)^> Just 2 -- kamyar
12:07:55 <lambdabot>  Just 3
12:07:56 <LordBrain> greymalkin, are you using an existential envelope in this code?
12:08:09 <c_wraith> kamyar, but don't really do that. :) 
12:08:59 <kamyar> cocreature: Your annotation worked!
12:09:17 <LordBrain> greymalkin, i mean like dynamic... where you get the type variable omitted on the left side, so that you postpone the type error...
12:09:35 <cocreature> LordBrain: that syntax is DataTypeContexts and doesn’t exist anymore
12:09:57 <monochrom> c_wraith: That's cute!
12:10:02 <cocreature> or is at least deprecated I don’t remember
12:10:25 <LordBrain> i brought it up because when i have wanted to reach for things in the past, i was doing something similar
12:10:25 <c_wraith> monochrom, it kinda looks like a Kirby variant, too. :) 
12:10:30 <mojjo> now, I'm facing the bit more complex parsing task: `{"key1":"abc", "key2": ["abc","abc"]}` Unfortunately aeson cannot just parse this to `Maybe (Map String (Either String [String]))` Does anyone have a hint how to archive this?
12:11:53 <monochrom> mojjo: This is why Map String String is a bad idea. Go back to Object which is Hashmap Text Value. There is a reason it's Value.
12:11:53 <EvanR> if thats the type you want, you can implement it with the json parser monad
12:12:08 <EvanR> oh if you just want the keys, then yeah, HashMap
12:16:00 <greymalkin> mojjo: I actuall have a wrapper that I use for that: http://lpaste.net/355247
12:16:14 <greymalkin> Well, not quite the same thing.
12:17:07 <greymalkin> mojjo, consider matching on whether the `Value` you're parsing is a (String t) vs an (Array a)
12:17:43 <greymalkin> You might also, instead, make the "key1":"abc" a singleton list when it's parsed, rather than Eithering it if they don't have different meanings.
12:18:53 <greymalkin> LordBrain: I'm really not sure what you mean -- this is a pattern I've mostly just intuited up to this point.
12:19:41 <greymalkin> But I'm having trouble with my Currency typeclass's function `currencyCode` which takes a proxy (since I don't necessarily have access to one of the `Money` objects at the time that I need to determine the currency code.
12:19:53 <greymalkin> The proxy is not working as I expected it to.
12:20:12 <monochrom> Show actual code?
12:21:48 <LordBrain> greymalkin, well this may or may not apply to you, but consider whether classes should be cut down... and instead using a pattern of records of functions which act as explicit dictionaries if you will.
12:22:11 <santosst> hello
12:22:31 <mojjo> monochrom: I'm still stuck in getting the xs out of the Object. I'm missing a function like `toList`..
12:22:39 <EvanR> down with class
12:22:41 <LordBrain> so for example, data Currency = Currency { function1:: a -> Currency -> b; function2 :: Currency -> b -> d} etc
12:22:54 <greymalkin> LordBrain: https://pastebin.com/f5ptUzZX
12:24:03 <monochrom> "type Object = Hashmap Text Value". Have you ever seen that from the docs or from the :info command?
12:24:35 <cocreature> mojjo: can you show us the code you currently have?
12:25:50 <ADG> doing "stack upgrade" (-v) since 3.5 hrs, first install, reached progress 109/185 stuck since 1 hr.. what to do? getting this at last https://hastebin.com/uhakoruver.pl
12:26:24 <cocreature> greymalkin: try enabling ScopedTypeVariables
12:26:57 <cocreature> greymalkin: the reason this doesn’t work is that without ScopedTypeVariables you can’t refer to the type variables in the instance declaration in the definitions of the individual bindings in the instance
12:28:15 <greymalkin> mojjo: this is what EvanR meant by using the parser monad
12:28:17 <greymalkin> https://pastebin.com/PP0RT3NV
12:29:09 <EvanR> yes but this really isnt necessary right now
12:29:15 <EvanR> afaict
12:29:49 <greymalkin> cocreature: Thank you. That makes sense, and seems to be almost necessary when using Proxys
12:30:37 <cocreature> greymalkin: you Proxies without ScopedTypeVariables are no fun
12:31:38 <cocreature> greymalkin: note that if you want to refer to the type variables in the type signature of an ordinary definition you need to explicitely use "forall". otherwise you have the same behavior as without ScopedTypeVariables
12:31:44 <mojjo> cocreature: ok, I'm slightly getting an idea. So it' basically the same beast like a simple `type MyString = String`. I'm just having trouble with getting Hashmap in scope...
12:31:57 <monochrom> 90% of questions are answered 10x faster when monochrom says "show actual code"
12:32:27 <EvanR> the 90 10 rule
12:32:34 <monochrom> Pay monochrom to say "show actual code" for you! At the new low price of 0.01 bitcoin per instance.
12:32:41 <cocreature> even better: show code that is sufficiently self-contained that people can load it in ghci
12:34:44 <mojjo> monochrom: alright.. I'll wrap my repl stuff into a file and pastebin it...
12:35:18 <monochrom> Yours may be in the other 10%.
12:35:28 <monochrom> But you need to know that Hashmap totally has toList.
12:38:14 <BernhardPosselt> hi i was wondering if you use something like spring that lets you switch out functions by using configuration
12:38:32 <BernhardPosselt> e.g. not happy with cart calculation? replace it with another function
12:38:43 <BernhardPosselt> shopping cart*
12:42:19 <cocreature> BernhardPosselt: there is not really a framework for that. just make your code a function that takes the things as arguments that you want to replace
12:43:03 <BernhardPosselt> so what if there is pre-existing code that has a default function
12:43:21 <BernhardPosselt> then somewhere we have a part that passes the default function, right?
12:43:37 <cocreature> you can’t magically replace parts of existing code
12:43:45 <BernhardPosselt> well in spring you can
12:44:20 <cocreature> I don’t think you can replace arbitrary parts of code that doesn’t use spring either, right?
12:44:30 <BernhardPosselt> i think you can
12:44:44 <cocreature> huh ok. well you still can’t do that in haskell :)
12:44:58 <BernhardPosselt> well i think you can do it :D
12:45:17 <BernhardPosselt> e.g. you use a function based on some configuration in a text file
12:45:21 <BernhardPosselt> e.g.
12:45:36 <BernhardPosselt> Company.Cart.calculateCart
12:45:39 <BernhardPosselt> instead of
12:45:45 <BernhardPosselt> Default.Cart.calculateCart
12:46:45 <BernhardPosselt> that is if you can dynamically pass functions by absolute package?
12:49:11 <BernhardPosselt> so basically you want a system that is extensible 
12:49:36 <cocreature> even if you could (which you can’t, at least not without terrible hacks), that would still require that the code that uses “calculateCart” reads the text file to figure out which implementation to call so at that point it could just take a parameter that represents the implementation of “calculateCart” that it uses
12:49:59 <BernhardPosselt> cocreature: correct :)
12:50:10 <cocreature> so I don’t really understand what you’re asking for
12:50:15 <BernhardPosselt> however how can i switch out default behavior
12:50:34 <cocreature> as I said, you can’t if the author didn’t have that in mind
12:50:37 <monochrom> You need two layers.
12:51:13 <monochrom> Front layer (responsible for parsing config file) knows about defaults and reads config file to override defaults.
12:51:56 <monochrom> But regardless of whether defaults are chosen or vetoed, this front layer tells the second layer which function to use, explicitly.
12:52:08 <BernhardPosselt> yep, thats what i mean
12:52:17 <monochrom> The second layer doesn't know what "default" means. No such thing there. It just uses whichever function the front layer says.
12:52:21 <BernhardPosselt> however how is the front layer going to choose the correct function?
12:52:28 <BernhardPosselt> if its not written by you
12:53:02 <monochrom> Example. Front layer reads config file. If config file empty, call "map sin [1,2,3]". If config file non-empty, call "map cos [1,2,3]".
12:53:22 <monochrom> More accurately, it's really "map (if config file empty then sin else cos) [1,2,3]".
12:53:26 <BernhardPosselt> ok, but sin and cos need to be hard coded right?
12:53:27 <cocreature> BernhardPosselt: are you looking to change the function without recompiling and without having only a fixed set of functions available?
12:53:36 <monochrom> Second layer is simply \f -> map f [1,2,3]
12:53:55 <monochrom> Yes.
12:54:04 <BernhardPosselt> ok, real world example
12:54:22 <cocreature> it sounds like you’re looking for dynamic loading of Haskell modules
12:54:27 <BernhardPosselt> im working with hybris which is a java based product management/shop system
12:54:40 <BernhardPosselt> they have a default shop implementation with controllers and all the stuff
12:54:48 <monochrom> Oh, real world example is going to be "the code comes from another config file because we love security holes". I know that one. wontfix.
12:54:50 <BernhardPosselt> so you can start up a webshop very quickly with no code
12:55:11 <BernhardPosselt> but if you want to adjust things you simply change xml and overwrite "objects" by using the same keyword
12:55:40 <EvanR> hmm the web with no code, would be nice
12:55:52 <BernhardPosselt> so a customer wants us to add additional price calculations to the cart for instance
12:55:59 <cocreature> BernhardPosselt: I think you might be looking for something like https://hackage.haskell.org/package/plugins or if you need a minimal example I have a blogpost https://purelyfunctional.org/posts/2016-05-20-dynamic-loading-haskell-module.html
12:56:19 <BernhardPosselt> sounds good :)
12:56:36 <monochrom> cocreature, does plugin still work today? I mean today's GHC 8
12:56:49 <cocreature> monochrom: afaik it does. it has been updated fairly recently
12:57:07 <cocreature> monochrom: you need to use some weird linker tricks that I figured out for that blogpost
12:58:00 <cocreature> BernhardPosselt: but unless you have a very strong reason not to, the usual solution in Haskell is to just make hybris a library and your config file the Main.hs file that calls that library with the implementations you want. if you want to change the implementation you just have to recompile that single file and that’s it
12:58:14 <cocreature> dynamic loading is rarely done in Haskell and is quite painful
12:59:05 <BernhardPosselt> so tl;dr: if you want to build something similar in haskell you would ship a default frontend and if you want to adjust one part you have to throw that away and rebuild everything :D?
12:59:34 <cocreature> why would you need to throw everything? just change the parts you care about
12:59:55 <BernhardPosselt> right but what if the parts you care about are nested more deeply?
13:00:22 <BernhardPosselt> kinda sounds like you would create a record with all functions in Main.hs
13:00:36 <cocreature> create a nested record? :)
13:00:41 <monochrom> Your hardware is flat memory and flat disc sectors. There is no depth.
13:01:12 <BernhardPosselt> so if i wanted to change one function id go to Main.hs and write a new function into that record?
13:01:15 <monochrom> If the part I want changed is on sector 001, I just change sector 001. There is no depth.
13:01:31 <cocreature> BernhardPosselt: if you are trying to say that it’s more painful to build that kind of system in Haskell than it is in Java you’re probably right :)
13:01:55 <BernhardPosselt> im interested in the functional approach/equivalent :D
13:02:20 <BernhardPosselt> could be painful in haskell but who knows maybe its common practice in another functional language
13:02:23 <monochrom> It is painful but be careful what the reason is.
13:02:47 <Tuplanolla> I could imagine doing that in Scheme quite easily, BernhardPosselt.
13:02:51 <monochrom> The reason is not an artificial definition of "depth". The reason is an after-thought hot-code-loading system.
13:03:08 <Tuplanolla> I could also imagine it quickly becoming completely unmanageable.
13:03:23 <monochrom> Erlang for example is sufficiently functional too but it's also designed for hot-code-loading from day 1.
13:03:46 <BernhardPosselt> i mean it could also work at compile time :)
13:03:57 <monochrom> So the reason is not an artificial dichotomy of "language paradigms" either.
13:04:03 <BernhardPosselt> compile this list of files but ignore that file and use my custom file :D
13:04:26 <EvanR> compile time hot code loading
13:04:27 <BernhardPosselt> that wouldnt require hot reloading
13:04:31 <BernhardPosselt> oh :)
13:04:36 <EvanR> now ive seen it all
13:04:55 <Tuplanolla> If you don't need portability, you can always do it at the foreign level, BernhardPosselt.
13:05:01 <monochrom> No, you haven't seen edit time hot code loading.
13:05:47 <Fendor> hey, does anyone know how to use the ghc-llvm backend on windows?
13:05:50 <Tuplanolla> Just because it's possible doesn't mean it's a good idea though: https://github.com/Tuplanolla/ld-prehaskell
13:06:08 <monochrom> If it's just compile time, you just control it from your main.hs or something.
13:06:18 <cocreature> Tuplanolla: that can’t really work if GHC inlines definitions, right?
13:06:22 <monochrom> which is what cocreature said.
13:06:22 <cocreature> and GHC does that a lot
13:06:46 <Tuplanolla> You need to do the trick at linktime, cocreature.
13:07:04 <BernhardPosselt> what would Main.hs look like? calculate_cart = custom_calculate_cart?
13:07:05 <Tuplanolla> That's why I said foreign.
13:07:38 <monochrom> Hot swapping is so passe. We need to move forward to thermonuclear swapping.
13:08:21 <EvanR> java clojure erlang elixir seem to think its a good idea
13:08:35 <cocreature> Tuplanolla: inlining happens way before linking so the code might not even reference the symbols you are replacing at link time
13:08:48 <Tuplanolla> I know all this, cocreature.
13:08:56 <monochrom> Yes BernhardPosselt, or change "import Calculator1" to "import Calculator2".
13:09:04 <monochrom> Or both.
13:09:04 <BernhardPosselt> i see :)
13:11:22 <BernhardPosselt> another question: some companies think its a good idea to distribute only binaries to you (who cares, everyone uses a decompiler)
13:11:30 <BernhardPosselt> in that case you probably cant use a Main.hs
13:12:07 <cocreature> then you can still use the dynamic loading approach the “plugins” package takes
13:12:15 <EvanR> haskell decompiler, interesting
13:12:22 <cocreature> EvanR: I think there is one
13:12:30 <BernhardPosselt> at least for java it works incredibly well :D
13:12:39 <BernhardPosselt> everything except enums
13:12:49 <cocreature> EvanR: to annoy haskellers it’s written in python https://github.com/gereeter/hsdecomp
13:13:04 <EvanR> haha
13:13:33 <EvanR> how in the world could it work
13:14:40 <mojjo> monochrom: alright, here's a source file which demonstrates my aeson parsing task: http://lpaste.net/355248
13:17:28 <monochrom> Object is Hashmap Text Value. You can use Hashmap's toList to get [(Text, Value)].
13:17:51 <monochrom> Value is an algebraic data type. Read the doc or use the :info command to see what are its possibilities.
13:18:20 <monochrom> Use pattern matching and conditional branching and whatnot to determine whether you want to output a Left or a Right.
13:18:27 <Fendor> so, someone tried using llvm on windows?
13:18:42 <cocreature> Fendor: what problems are you running into?
13:19:18 <Fendor> cocreature, i installed llvm 3.7 via the installer, but when i try to stack build, ghc says, it couldnt execute 'opt'
13:20:41 <cocreature> Fendor: you can specify the path to opt via "-pgmlo path" iirc
13:21:10 <Fendor> cocreature, i'm not sure what the path might be, i have no program named opt in the installation directory
13:22:11 <cocreature> Fendor: that seems more of a problem with your llvm installation. llvm should definitely include opt _somewhere_. sadly I don’t have a lot of experience with llvm on windows so I don’t know where it is supposed to be
13:23:02 <Fendor> cocreature, ok, thanks, then i know what i have to look for
13:23:11 <cocreature> Fendor: which installer did you use? I only see an installer for clang and none for llvm itself
13:23:46 <Fendor> cocreature, used the one for clang, thought this would work out. I tried to compile llvm from source
13:24:01 <Fendor> still couldn't find any executable with the name opt...
13:24:10 <cocreature> Fendor: iirc the clang installer statically links against llvm so it doesn’t help here.
13:24:28 <cocreature> Fendor: how exactly did you compile it?
13:24:36 <cocreature> and what did you compile?
13:25:26 <Fendor> i downloaded the sources, opened it in clion, previously installed cygwin with gcc, and executed `build all`
13:27:15 <cocreature> I just used ninja the last time I build llvm on windows. I have no idea what exactly clion does
13:27:36 <mojjo> monochrom: unfortunately that does not do the trick. Data.HashMap.toList is not working on Object. `Expected type: Maybe (Map k a); Actual type: Maybe Object`
13:27:38 <cocreature> but you should probably try talking to llvm guys about this :)
13:28:17 <cocreature> mojjo: are you sure you are using Data.HashMap.toList and not Data.Map.toList?
13:28:29 <Fendor> as far as i know, clion should execute cmake and then make :/ 
13:28:42 <Fendor> cocreature, is there a llvm irc as well?
13:28:49 <cocreature> Fendor: yes #llvm on oftc
13:29:23 <Fendor> cocreature, ok, will ask there afterwards, thank you!
13:30:46 <mojjo> cocreature: yes: http://lpaste.net/355248
13:32:05 <cocreature> mojjo: you need to use Data.HashMap.Lazy and change the import to that as well
13:33:48 <mojjo> cocreature: alright, that was it...
13:34:23 <mojjo> I guess it's why I'm explicity using the lazy bytestring..
13:34:38 <mojjo> why->because
13:34:45 <cocreature> it’s not about lazy bytestrings. it’s about lazy hashmaps
13:34:52 <pikajude> this is a confusing flowchart
13:35:05 <cocreature> aeson is representing Object as a lazy hashmap so you have to work with that
13:35:16 <mojjo> cocreature: alright..
13:35:43 <hylo> i tried to run this ST example, but it panicked: http://lpaste.net/355251 is this the same bug as https://ghc.haskell.org/trac/ghc/ticket/13106 ?
13:40:41 <hylo> whoops, i didnt add imports...
13:43:54 <hylo> now it works fine. interesting error though
14:05:18 <c_wraith> a ghc panic is a bug, not matter how invalid the input. 
14:05:24 <c_wraith> *no matter 
14:06:16 <c_wraith> making ghc's brain explode, on the other hand, is perfectly normal for some mistakes. 
14:08:10 <mojjo> cocreature: getting closer and closer with the parsing.. Atm, I'm stuck with coercing Data.Aeson.Text to String... 
14:09:30 <pikajude> why are you coercing that to String?-
14:09:48 <pikajude> doesn't it contain a Text already
14:11:13 <mojjo> pikajude: good question, I though it's better to get that out of the 'JSON world' but yeah.. maybe it's not needed
14:14:04 <pikajude> well what do you want to do with it
14:15:45 <LordBrain> Would it be sensible to classify x86 machine code under Codec ?
14:16:15 <dmwit_> There's a "Language" category...
14:16:17 <monochrom> There is no such thing as Data.Aeson.Text
14:16:23 <pikajude> it's a module monochrom 
14:16:37 <LordBrain> dmwit, langauge is the assembly tho right... not the bits
14:16:53 <monochrom> Ah. Still, the Text type is not an aeson internal thing.
14:17:02 <LordBrain> oh were you not talking to me?
14:17:05 <mojjo> pikajude: atm I just want to parse the json into a 'clean' haskell data structure. Performance is not important, so'll try to coerce the keys to strings.
14:17:05 <pikajude> oh i guess it's actually called String inside aeson
14:17:10 <dmwit> I can't think of a meaning for "x86 machine code" for which Codec would be a sensible classification.
14:17:22 <LordBrain> why not
14:17:54 <dmwit> Codecs are *usually* about compression, and especially audio and video.
14:18:24 <LordBrain> they're about encodings, take base64, has nothing to do with audio or video
14:18:34 <dmwit> (s/and especially/especially of/ makes that sentence a bit more sensible)
14:18:38 <monochrom> Codec.Aeson?
14:18:56 <Tuplanolla> Here's another definition: codes are those things only codec developers care about.
14:19:18 <Tuplanolla> What an opportune typo there.
14:19:19 <monochrom> Codec.Church.SystemF
14:19:38 <LordBrain> well, i dont think its so clear cut, but i asked for opinions and you offered, so thanks
14:20:53 <mojjo> ok, I see. It's Data.Text from the text pkg that is used by Aeson
14:20:58 <dmwit> I don't know what you're doing. But with the little data you've given, I would strongly suggest Language.
14:21:11 <LordBrain> i've seen encryption stuff being put in codec
14:21:24 <athan> biTraverse :: (a -> m c) -> (b -> m d) -> f a b -> m (f c d) -- is this a thingy?
14:22:08 <monochrom> Does your package decode x86 machine code to Prolog?
14:22:13 <MarcelineVQ> athan: https://hackage.haskell.org/package/bifunctors-5.4.2/docs/Data-Bitraversable.html#v:bitraverse
14:22:15 <LordBrain> no
14:22:23 <LordBrain> it doenst even fully dissassemble it
14:22:36 <LordBrain> it just tells you things like, X is a valid instruction
14:23:03 <monochrom> This sounds like a developer's tool.
14:23:08 <LordBrain> yeah
14:23:40 <LordBrain> it nearly is a complete disassembler, but not quite
14:23:49 <athan> MarcelineVQ: Thank you ._.
14:23:49 <monochrom> It does seem that Language.* is collecting developer's tools.
14:24:03 <MarcelineVQ> athan: it should be in base in the not too distant future as well so you can feel confident writing code using it
14:24:32 <dmwit> LordBrain: Given that there's an "Encryption" category, I find that odd.
14:24:53 <dmwit> LordBrain: There's also "Testing", "Compliers/Interpreters", and "Development".
14:25:09 <dmwit> Whoops, Compilers, not Compliers, of course. =)
14:25:22 <Tuplanolla> Tag-based module system when?
14:26:04 <monochrom> YES!
14:26:31 <MarcelineVQ> hackagebooru
14:27:10 <LordBrain> alright
14:27:22 <LordBrain> well i'm just going to leave it as it is presently, which is none of the above
14:27:27 <LordBrain> heh
14:27:30 <monochrom> It's a bit unfortunate that it is not too easy to ask hackage for a complete list of packages (under a given prefix).
14:27:30 <dmwit> Come to think of it, "Testing" doesn't seem like a very good suggestion. Scratch that one.
14:28:04 <dmwit> monochrom: https://hackage.haskell.org/packages/ ?
14:28:19 <dmwit> Click a category to get all the packages in that category...
14:28:44 <dmwit> (Or: what do you mean by "prefix"?)
14:28:49 <MarcelineVQ> monochrom: it's not too hard either though, but you end up asking through Cabal, or I have anyway
14:29:01 <monochrom> Because what you should do is the social norm thing rather than the conceptual-linguistic analysis thing. I.e., you should just find the prefix that already contains the most packages most similar to yours, and not care about what the words mean.
14:30:59 <monochrom> I guess I mean category
14:31:08 <Tuplanolla> If I was the first person to write quantum computing packages, I'd put them under `Ponies`.
14:32:56 <monochrom> You can still choose from Control, Quantum, and Scientific :)
14:33:05 <pikajude> Control.Ponies
14:34:06 <monochrom> Oh neat numeric-quest has all the linear algebra computations I want.
14:34:17 <LordBrain> lol
14:34:40 <LordBrain> i'm going to put it there pikajude, thanks for the suggestion
14:34:58 <monochrom> onoes
14:40:00 <Gurkenglas> Do we have a benchmark file that generates lens errors that ought to look better?
14:48:16 <EvanR> you have functor, applicative, monad
14:48:25 <EvanR> where does contrafunctor lead?
14:48:37 <EvanR> contraapplicative?
14:49:14 <c_wraith> I'm pretty sure there's something that covers that. 
14:49:43 <c_wraith> https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
14:49:54 <monochrom> contrafunctor leads to fear, fear leads to anger, anger leads to using Haskell in anger.
14:50:21 <monochrom> Eh! Divisible. That sounds interesting.
14:51:01 <monochrom> I think I saw an edwardk video on that.
14:51:16 <c_wraith> yeah, I know he's done at least one. 
14:51:28 <c_wraith> and it is one of his libraries 
14:51:58 <EvanR> so uh
14:52:07 <EvanR> do you get a free Divisible with a Contrafunctor?
14:52:54 <c_wraith> no. 
14:53:44 <c_wraith> unless you mean category-theoretical free, in which case.. Maybe. 
14:54:46 <EvanR> conquer :: f a
14:54:52 <EvanR> uhm... 
14:55:49 <EvanR> not sure how something implements that
14:56:17 <iqubic> How does this type signature look: firstMatch :: [(a -> Bool, b)] -> a -> Maybe b
14:56:20 <EvanR> ok it could ignore the given a, in the case of a -> b
14:56:23 <Gurkenglas> The compiler unpacks type aliases if that lets it pull constraints contained in the aliases to the front of a type. Can that be disabled?
14:56:35 <iqubic> It's supposed to return the b of the first a that passes.
14:56:41 <monochrom> If you can find that lecture video, there are concrete examples and how the generalization emerges.
14:56:57 <monochrom> Actually let me see if I can recall it.
14:57:11 <iqubic> Or nothing if all the test fail.
14:57:42 <c_wraith> EvanR, Predicate is one of the provided instances. newtype Predicate a = Predicate (a -> Bool) 
14:57:53 <iqubic> Predicate is a thing
14:57:54 <iqubic> ??
14:58:06 <iqubic> That will help me in my task
14:58:29 <c_wraith> EvanR, so.. Yeah, const True and const False both fit that type. 
14:59:00 <iqubic> c_wraith: How does Predicate work?
14:59:09 <EvanR> oh right Predicate
14:59:21 <c_wraith> iqubic, it's a thing in the contravariant package. if you want to import that package, it's there.. 
14:59:28 <iqubic> @index Predicate
14:59:29 <lambdabot> bzzt
14:59:47 <c_wraith> https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Predicate
15:00:05 <iqubic> Why is that a thing?
15:00:18 <iqubic> Why not just use a -> Bool?
15:00:30 <c_wraith> probably more for pedagogical reasons than practical. 
15:00:46 <iqubic> How does this type signature look: firstMatch :: [(a -> Bool, b)] -> a -> Maybe b
15:00:50 <iqubic> It's supposed to return the b of the first a that passes.
15:00:56 <iqubic> Or nothing if all the test fail.
15:01:07 <iqubic> I'm not sure how to write that though.
15:01:35 <c_wraith> the type certainly is coherent. 
15:01:50 <iqubic> What does that mean?
15:02:12 <c_wraith> it can be implemented in a way that has meaning. 
15:02:12 <sedeki> how can I learn the algebra that most Haskellers seem to know
15:02:17 <sedeki> or, where can I learn it?
15:02:55 <c_wraith> sedeki, I learned most of what I know by just watching people chat here. :) 
15:02:56 <iqubic> c_wraith: I don't know how to write that function.
15:03:01 <Tuplanolla> @djinn (a -> bool, b) -> (a -> (bool, b)) -- You could first define this, iqubic.
15:03:01 <lambdabot> Cannot parse command
15:03:06 <Tuplanolla> @djinn (a -> bool, b) -> (a -> (bool, b))
15:03:06 <lambdabot> f (a, b) c = (a c, b)
15:03:24 <sedeki> c_wraith really?
15:03:39 <Tuplanolla> Map that, apply each one to your argument and find the first match, iqubic.
15:03:52 <c_wraith> iqubic, just start writing it. write out the pattern matching structure, then see what you have to work with. 
15:03:52 <iqubic> Tuplanolla: Is that the way to do it?
15:04:03 <Tuplanolla> That's one easy way, iqubic.
15:04:16 <byron1> part
15:04:19 <ski> join
15:04:49 <c_wraith> sedeki, yep. eventually I started watching a few videos that came up on reddit, but I still think half of them are incomprehensible. :) 
15:05:40 <iqubic> How do I write this: (a -> bool, b) -> (a -> (bool, b))
15:05:53 <Tuplanolla> I just showed you, iqubic.
15:06:04 <iqubic> Oh.
15:06:18 <iqubic> So how does that help me solve firstMatch?
15:06:20 <sedeki> c_wraith what books have you read about haskell?
15:06:50 <sedeki> c_wraith are you pursuing haskell on a hobbyist level or working with it?
15:07:01 <c_wraith> in their entirety? none. and most books I read about it, I read to evaluate how much they get wrong. :) 
15:07:15 <c_wraith> I picked up haskell entirely on the job. 
15:07:45 <Tuplanolla> @let djinn_f (a, b) c = (a c, b)
15:07:47 <lambdabot>  Defined.
15:08:25 <c_wraith> not my current job, mind you. 
15:08:48 <Tuplanolla> :t \ fs x -> find fst (fmap ($ x) (fmap djinn_f fs))
15:08:49 <lambdabot> (Functor t, Foldable t) => t (a -> Bool, b) -> a -> Maybe (Bool, b)
15:09:04 <Tuplanolla> Like so, iqubic.
15:09:23 <sedeki> c_wraith very cool
15:09:57 <iqubic> I don't want the end result to to be Maybe (Bool, b), but just b
15:10:05 <iqubic> or rather Maybe b
15:10:17 <Tuplanolla> :t \ fs x -> fmap snd (find fst (fmap ($ x) (fmap djinn_f fs)))
15:10:18 <lambdabot> (Functor t, Foldable t) => t (a -> Bool, b) -> a -> Maybe b
15:10:42 <Tuplanolla> I'm sure better ways exist too.
15:11:04 <c_wraith> iqubic, I really think the best way for you to learn is to just write the pattern matches out by hand and work with what they give you. 
15:11:17 <sedeki> c_wraith I've read like 2 books on haskell already, and half-way through a 3rd. still don't get certain things.
15:11:34 <iqubic> c_wraith: How would you write the pattern matches for this?
15:11:35 <sedeki> but I think it will make sense if I just start making some projects
15:12:20 <c_wraith> sedeki, haskell is a constant learning experience, if you want to keep up with what people are doing. there are always more things to learn. 
15:14:10 <c_wraith> iqubic, I find starting out with the simplest possible thing is a good strategy. then add bits of additional elaboration when you see that you can. 
15:15:23 <c_wraith> iqubic, you have a function that takes two arguments, so write out a function definition that takes two arguments. you can leave the body undefined to start. 
15:18:09 <c_wraith> iqubic, then you can start refining. the first argument is a list. you know you can match whether that list is empty or not, so split the definition in two for each case. see if you have enough information to implement the body in either case. proceed with refinements like that. 
15:18:35 <c_wraith> err, split the definition in two *to handle* each case. 
15:18:35 <iqubic> c_wraith: I have something that almost works, but not quite.
15:18:48 <c_wraith> iqubic, so put it on lpaste.net 
15:18:57 <joe9> I am building a table data structure, where I traverse sequentially and add the (row,column) cell. Are there any library packages that can help? I found tabular. Just want to check if there is something better out there.
15:20:43 <lpaste> iqubic pasted “Almost works” at http://lpaste.net/355252
15:21:21 <iqubic> So, the first part is the solution I can up with. The second part is the error I get when trying to compile my thing.
15:22:14 <joe9> I also found this https://hackage.haskell.org/package/table-layout
15:22:15 <ReinH> iqubic: don't wrap the : constructor in []
15:22:40 <iqubic> Why not?
15:22:54 <ReinH> Because it is just :
15:23:03 <iqubic> Oh. I see.
15:23:18 <glguy> The pattern   [_]   is equivalent to   (_ : []), it matches a single-element list
15:23:35 <ReinH> (x:xs) is a list. [x:xs] is a list of lists.
15:23:37 <iqubic> Ah.
15:24:39 <ReinH> [x:xs] matches a list containing one element: a non-empty let.
15:24:55 <c_wraith> iqubic, that's a pretty common mixup. other than that, everything looks right. 
15:25:31 <lpaste> iqubic pasted “Second Try” at http://lpaste.net/355253
15:25:44 <iqubic> Thanks for being real helpful error message.
15:25:51 <ReinH> You still need to wrap : with ()
15:26:19 <iqubic> Oh.
15:26:19 <c_wraith> that is, (x:xs) is the common match pattern. 
15:26:38 <iqubic> Now it works
15:26:52 <ReinH> (x:xs) is a pattern, x:xs is a parse error, [x:xs] is a pattern, but the wrong one.
15:27:42 <iqubic> https://www.willamette.edu/~fruehr/haskell/evolution.html 
15:27:56 <iqubic> How does the Junior Solution work.
15:28:04 <c_wraith> well.. There's a bit more subtlety to it than that, but it's basically true when defining functions. 
15:28:18 <iqubic> You can pattern match on (n+1)?
15:28:34 <c_wraith> iqubic, oh, that was removed from haskell 2010
15:28:51 <c_wraith> that page is *old* and not updated 
15:29:24 <monochrom> The problem with learning from the Internet.
15:33:24 <iqubic> Did people know that lambda bot can do this:
15:33:36 <iqubic> @unmtl StateT s IO a
15:33:36 <lambdabot> s -> IO (a, s)
15:33:41 <iqubic> That's so cool.
15:33:42 <monochrom> No.
15:34:01 <iqubic> It unwraps a monad transformer.
15:34:57 <ReinH> Have we taught it about ExceptT yet?
15:35:15 <iqubic> > ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
15:35:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘++++++++++’
15:35:22 <iqubic> Darn it.
15:35:59 <c_wraith> the > prefix only kicks off haskell evaluation. BF evaluation is a different command. 
15:36:08 <monochrom> Did people know that lambdabot doesn't know Morse code?
15:36:44 <iqubic> c_wraith: DO you know the BF evaluation command?
15:36:59 <monochrom> No.
15:37:12 <ski> @help bf
15:37:12 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
15:37:34 <c_wraith> i wasn't even sure it didn't get removed in the last winnowing 
15:37:41 <iqubic> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
15:37:42 <lambdabot>   Hello World!
15:37:44 <iqubic> Cool
15:38:08 <iqubic> @fact
15:38:08 <lambdabot> Maybe you meant: part faq
15:38:39 <iqubic> @dice 1 1
15:38:39 <lambdabot> unexpected '1': expecting operator or end of input
15:38:43 <iqubic> @dice 1 
15:38:43 <lambdabot> unexpected end of input: expecting operator or end of input: no rolls in expression
15:38:45 <iqubic> @dice
15:38:45 <lambdabot> unexpected end of input: expecting number, "d" or "("
15:38:49 <iqubic> @dice 2d2
15:38:49 <lambdabot> iqubic: 1+2 => 3
15:39:14 <Tuplanolla> Maybe you want your own little lambdabot, iqubic.
15:39:20 <iqubic> I really do.
15:39:28 <iqubic> Can I get that as stack program?
15:39:29 <glguy> You can spam lambdabot in /msg
15:39:55 <iqubic> I want it as an offline thing.
15:40:02 <Tuplanolla> That can be arranged.
15:40:04 <glguy> It's on hackage
15:40:48 <sedeki> hehe.
15:40:49 <Gurkenglas> "stack install lambdabot", I think
15:42:00 <iqubic> But it needs a ton of dependecies
15:43:17 <iqubic> And those don't want to install themselves.
15:54:20 <monochrom> Perhaps you should offer to pay for someone to do it for you.
16:00:50 <iqubic> Can't I do it myself?
16:03:02 <suzu> lmao
16:15:15 <dmwit> ReinH: https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/UnMtl.hs#L135-L157
16:15:25 <dmwit> Should be pretty mechanical to add ExceptT. You should totally do it!
16:16:12 <noexcept1> I don't understand the difference between let and where. Why do we need two different syntaxes for replacing something within a scope?
16:17:34 <ReinH> @google haskell let vs where
16:17:35 <lambdabot> https://wiki.haskell.org/Let_vs._Where
16:18:20 <ReinH> The second result is also good: http://stackoverflow.com/questions/4362328/haskell-where-vs-let
16:18:23 <c_wraith> noexcept1, they are in different parts of the syntax. let...in is an expression. where clauses can only attach to a couple of places. 
16:19:49 <ReinH> For the same reason that mathematicians do, I suppose.
16:20:26 <wizwizwizwiz> so can i use haskell to make something imitating a "database" with "queries" and all of that... and ideally in a manner superior to existing SQL databases
16:21:41 <dmwit> I assign high probability to the answer "no". Given how vague your question is, it suggests you know little about just how much work has gone into existing SQL databases, and therefore *you* are unlikely to do better.
16:22:15 <c_wraith> as soon as you define what "better than SQL" means, you can certainly do it in Haskell. 
16:23:59 <c_wraith> you can usually find a way to do something faster than a traditional RDBMS does, but at the expense of basically everything else they provide. usually all the ACID properties get lost. 
16:24:55 <dmwit> Ugh, that was incredibly rude. I'm sorry. Something about your question rubbed me the wrong way, and I responded badly.
16:26:06 <jao> yes!
16:26:16 <jao> (sorry, wrong emacs buffer)
16:27:47 <noexcept1> How would I go about understanding Haskell's evaluation strategy?
16:27:59 <Welkin> noexcept1: read docs for ghc
16:28:11 <ReinH> @where lazy
16:28:11 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
16:28:26 <ReinH> noexcept1: that one is good too
16:28:32 <noexcept1> I understand that not everything is evaluated right away, rather only as needed, but that's very hand-wavy.
16:28:59 <ReinH> Or read Introduction to Functional Programmming Using Haskell by Richard Bird if you can find a copy
16:29:16 <ReinH> or read the Haskell report
16:30:03 <Cale> noexcept1: The basic idea of lazy evaluation (which isn't *quite* what GHC does, but is generally close enough)
16:30:03 <ReinH> If you want even more, read the GHC commentary on the runtime system
16:30:11 <Cale> is that expressions are evaluated outermost-first
16:31:13 <Cale> but any work done to evaluate an expression to which a variable has been bound will remain completed so long as that variable remains in scope (and is shared between the occurrences of it)
16:32:10 <Cale> I'll do my usual example: suppose we have a function double x = x + x, and we wish to evaluate double (double 5)
16:32:55 <Cale> Under innermost-first evaluation, this would proceed as:
16:33:03 <Cale>    double (double 5)
16:33:08 <Cale> -> double (5 + 5)
16:33:12 <Cale>  -> double 10
16:33:22 <Cale> -> 10 + 10
16:33:25 <Cale> -> 20
16:33:46 <rotaerk> hmm I've decided I don't like LaTeX-style literate haskell; the tags and stuff make it harder to read than simply using plain text and bird-style code quoting
16:33:55 <Cale> With plain outermost-first evaluation, it would be:
16:34:01 <Cale> double (double 5)
16:34:04 <rotaerk> the LaTeX style would be useful if you were writing a compilable code-containing article though
16:34:11 <Cale> -> (double 5) + (double 5)
16:34:17 <Cale> -> (5 + 5) + (double 5)
16:34:24 <Cale> -> 10 + (double 5)
16:34:27 <Cale> -> 10 + (5 + 5)
16:34:30 <Cale> -> 10 + 10
16:34:31 <Cale> -> 20
16:34:56 <Cale> and here we see that double 5 gets evaluated twice because it was duplicated when the x in the body of double occurred twice
16:35:08 <Cale> So lazy evaluation avoids that by sharing the work:
16:35:13 <Cale> double (double 5)
16:35:24 <noexcept1> how does it know that (+) requires its operands to be evaluated while double does not?
16:35:53 <Cale> Ah, I'm glossing over that. Really it's that (+) would pattern match on its arguments
16:36:10 <Welkin> Gloss
16:36:16 <ReinH> what gets evaluated is determined by the pattern matching in the definitions
16:36:18 <Cale> Evaluation ultimately gets driven forward by pattern matching
16:37:47 <noexcept1> why do the parameters of + not bind to the unevaluated (double 5)?
16:37:49 <ReinH> I'm not quite sure what "(+) requires its operands to be evaluated while double does not" means but it doesn't sound correct.
16:38:12 <Cale> noexcept1: They do, it's just I didn't want to unfold the definition of (+)
16:38:42 <noexcept1> so that pattern matching is not what forces the evaluation yet?
16:38:49 <Cale> Also, it's really the outermost (+) which gets evaluated, and since it immediately pattern matches on both its arguments...
16:39:41 <Cale> you end up needing to evaluate each of them to proceed
16:40:13 <noexcept1> hm, I don't see why it couldn't just leave the whole thing unevaluated
16:40:28 <Cale> and do what?
16:40:32 <ReinH> let's say we're printing the result
16:40:52 <ReinH> if nothing scrutinizes the result, you're right that it won't need to be evaluated
16:41:31 <Cale> Yeah the only reason that we would be evaluating this expression in the first place is to be able to match it against a pattern, perhaps in the definition of 'show', for example.
16:41:42 <ReinH> print (const 5 (double (double 5))) won't evaluate double
16:41:57 <dmwit> > error "this blows up"
16:41:59 <lambdabot>  *Exception: this blows up
16:42:03 <dmwit> > const 5 (error "this doesn't blow up")
16:42:03 <ReinH> because const doesn't scrutinize it
16:42:05 <lambdabot>  5
16:42:10 <ReinH> @src const
16:42:10 <lambdabot> const x _ = x
16:42:29 <noexcept1> but what kind of pattern can only bind to a fully-evaluated integer?
16:43:03 <ReinH> We can use nats if you prefer
16:43:05 <Cale> Well, integers are again a weird example, because you don't usually think of their internal implementation.
16:43:16 <noexcept1> if I write `double :: Int -> Int` shouldn't the x in `double x = x + x` also force evaluation because it's doing "pattern-matching"?
16:43:20 <Cale> (if we want to continue digging that deeply)
16:43:36 <Cale> Ah, no, because we're not matching against a constructor there
16:43:41 <monochrom> No, not all patterns trigger evaluation.
16:43:56 <monochrom> > case undefined of x -> "thanks"
16:43:58 <lambdabot>  "thanks"
16:44:08 <monochrom> Uneventful.
16:44:50 <ReinH> > case undefined of (x : xs) -> "oh no"
16:44:52 <lambdabot>  "*Exception: Prelude.undefined
16:45:01 <Cale> Also, just because it fits here, pattern matching against a newtype's data constructor similarly doesn't cause evaluation to occur
16:45:06 <noexcept1> so Int is a constructor and show will pattern-match it? like `show (Int x) = ..."
16:45:13 <ReinH> Int is a type.
16:45:22 <Cale> There is an internal data constructor for Int, I believe it's called I#
16:45:39 <Cale> You don't typically interact with that directly, but it's there.
16:46:00 <monochrom> Built-in numbers (and Char) are really bad examples. They receive special treatment.
16:46:11 <ReinH> noexcept1: you can imagine that we are working with natural numbers data Nat = Z | Suc Nat instead of integers here
16:46:28 <ReinH> and imagine what (+) would do, how it would pattern match on its arguments.
16:46:28 <Cale> Or we could just define integers like:
16:46:54 <Cale> data Integer = Neg Nat | Zero | Pos Nat
16:47:13 <ReinH> three zeros for three times the fun
16:47:15 <Cale> Where Pos n represents n+1, and Neg n represents -n-1
16:47:19 <ReinH> (I know, I know)
16:47:57 <ReinH> See, this is why Cale wanted to hand wave the integer pattern matching...
16:47:58 <monochrom> No, you want: (I know, I know, I know). :)
16:48:04 <ReinH> monochrom: :p
16:48:11 <Cale> If we want to be somewhat more practical, perhaps a binary representation would be better...
16:48:23 <Cale> But it doesn't really matter exactly how Integer is defined.
16:48:32 <noexcept1> ReinH: ah okay, well if it receives special treatment that explains why I don't understand how the rules could work there.
16:48:37 <ReinH> data Int = Int Bool Nat -- don't @ me
16:48:47 <Cale> It only receives a little bit of special treatment in practice.
16:49:28 <Cale> There's a data type with a data constructor still, and then the special bit is that the only field of that data constructor is an unboxed machine int
16:49:35 <Cale> data Int = I# Int#
16:50:46 <noexcept1> So is there a function in the prelude somewhere that pattern-matches this I# constructor? `show #I x = stringFromInt x`
16:51:30 <Cale> Yeah, the Num and Show instances and such will actually match on I# and use primitive operations on the unboxed representation.
16:51:43 <erisco> how did Data.Tree end up with unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a  rather than  unfoldForest :: (b -> [(a, [b])]) -> b -> Forest a ?
16:52:06 <Gurkenglas> I've cloned lens and tweaked a bit. What stack command will let me use ghci on this not-a-stack-project?
16:52:40 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/src/GHC-Num.html#%2B
16:52:56 <erisco> sorry I mean  unfoldForest :: (b -> [(a, b)]) -> b -> Forest a
16:53:28 <noexcept1> Cale, ReinH: Awesome, thanks. That helped me a lot with understanding. :)
16:53:37 <ReinH> noexcept1: also read this
16:53:39 <ReinH> @where lazy
16:53:39 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
16:53:45 <ReinH> it's monochrom's and it's very good
16:54:32 <Cale> noexcept1: Anyway, I didn't actually show the lazy evaluation of our example -- if you'll permit the use of let to indicate the sharing, that would look something like:
16:54:37 <Cale> double (double 5)
16:54:50 <Cale> -> let x = double 5 in x + x
16:54:53 <erisco> nothing else that is an unfold looks like what is in Data.Tree
16:55:00 <Cale> -- note that we still unfolded the outermost one here
16:55:08 <Cale> -> let x = 5 + 5 in x + x
16:55:14 <Cale> -> let x = 10 in x + x
16:55:16 <Cale> -> 10 + 10
16:55:17 <Cale> -> 20
16:55:31 <Cale> and so we save performing the evaluation of double 5 twice in that way
16:55:32 <mojjo> is there a safe version of System.Directory.createDirectory, that returns e.g an Bool indicating success/failure of the op instead of throwing an exception?
16:55:53 <erisco> otherwise I've found that Forest is an edge labeled tree
16:55:59 <Cale> Under innermost-first evaluation, each argument to a function is evaluated exactly once.
16:56:13 <Cale> Under outermost-first evaluation, each argument to a function is evaluated zero or more times.
16:56:27 <Cale> Under lazy evaluation, each argument to a function is evaluated zero or one times.
16:57:24 <erisco> assuming totality
16:57:50 <ReinH> mojjo: wrap it in try?
16:58:11 <ReinH> there generally aren't safe versions of everything that can throw an exception because try exists
17:01:53 <Strikingwolf> question: is there a way to express in contexts that a is not congruent b?
17:02:02 <mojjo> ReinH: ok, i'll try it
17:02:14 <Strikingwolf> so like instead of (a ~ b) => you would have some way to do (a !~ b)
17:02:21 <monochrom> erisco: Can you use your version of unfoldForest to produce the same thing as: Data.Tree.unfoldForest (\b -> (b, if b==0 then [] else [b-1])) [3,1,4,5]
17:02:29 <Cale> Strikingwolf: nope
17:03:10 <erisco> monochrom, I don't know but that isn't the point
17:03:16 <erisco> monochrom, how do they get that shape as an unfold?
17:03:33 <monochrom> I disagree. The answer is the point.
17:03:48 <erisco> how so?
17:04:17 <Cale> Strikingwolf: Generally that wouldn't be so useful
17:04:28 <Strikingwolf> Damn
17:04:31 <Cale> Strikingwolf: There's nothing you can actually do with the information that two types are unequal
17:04:40 <Strikingwolf> Well, there is *one* thing I can do
17:04:48 <Strikingwolf> I'm building a record type
17:05:22 <Strikingwolf> and so using that would allow me to restrict that only one field is allowed with a particular name
17:05:53 <Cale> ah, right, "lacks" constraints
17:15:19 <erisco> monochrom, the answer is yes
17:16:32 <erisco> monochrom, if we call mine unfoldForest2, then theirs unfoldForest = unfoldForest2 . fmap
17:17:03 <Strikingwolf> I wish you could tell Haskell which instance is "preferred"
17:17:15 <Strikingwolf> so if one of them matches the other one won't
17:17:17 <dmwit> data Int = Nat :- Nat
17:17:44 <EvanR> Strikingwolf: there is support for controlling overlapping instances, but its best to just avoid them
17:18:08 <dmwit> (a :- b) + (c :- d) = (a + c) :- (b + d) -- has its own kind of beauty
17:18:17 <ReinH> Strikingwolf: it seems like whatever you're doing is probably a bad idea...
17:18:18 <monochrom> erisco, not the direction I'm asking.
17:18:23 <taktoa> dmwit: I read the (:-) constructor as "entails" rather than "minus" and got really confused for a second
17:18:30 <erisco> monochrom, then I do not understand your question
17:18:52 <taktoa> although funnily enough you can interpret LEM as meaning that implication is kind of like subtraction
17:19:02 <monochrom> Rewrite Data.Tree.unfoldForest (\b -> (b, if b==0 then [] else [b-1])) [3,1,4,5] using unfoldForest2.
17:19:24 <taktoa> !P \/ Q becomes -P + Q
17:19:29 <erisco> yes, it is easy, because unfoldForest = unfoldForest2 . fmap
17:19:43 <dmwit> taktoa: cute!
17:20:00 <Strikingwolf> ReinH: oh I'm not doing it for practicality or for using it
17:20:04 <Strikingwolf> just for fun and learning
17:20:07 <Strikingwolf> it's a horrid idea :P
17:20:11 <ReinH> :)
17:20:16 <Strikingwolf> Also, got it working
17:20:20 <Strikingwolf> type families to the rescue
17:20:32 <Strikingwolf> I'm amazed I haven't had to call on UndecidableInstances for this
17:21:14 <erisco> monochrom, how does that not qualify?
17:22:00 <monochrom> OK, I misread, it's the right direction. Now I have to carefully check it.
17:22:01 <taktoa> dmwit: relatedly https://en.wikipedia.org/wiki/Residuated_lattice
17:22:45 <monochrom> So you're saying unfoldForest2 (fmap f  [3,1,4,5])?
17:23:01 <erisco> unfoldForest2 (fmap f) [3,1,4,5]
17:24:07 <lyxia> I think (not _) being (1 - _) is more common than (- _)
17:24:16 <erisco> this fmap is specialised to lists, so same being unfoldForest2 (map f) [3,1,4,5]
17:24:39 <monochrom> OK, I am skeptical. Even about the types. Do you have an implementation for testing?
17:25:19 <erisco> well I ran into it because I defined a different type and later realised it is exactly that of Forest
17:25:29 <erisco> and then was confused as to why our unfolds didn't match
17:25:32 <erisco> so sure I'll pastebin it
17:26:18 <erisco> http://lpaste.net/355256
17:27:15 <monochrom> Can you modify it so that it is for Data.Tree.Tree rather than your Tree?
17:27:54 <Welkin> isn't that a rose tree?
17:28:04 <erisco> it is Forest
17:28:25 <monochrom> Or rather Data.Tree.Forest
17:28:38 <Strikingwolf> Oh god this works
17:28:59 <dmwit> erisco: I don't know if you literally meant "how did we get unfoldForest :: blah", but if you did, I have a pretty good guess: it arises very naturally while implementing `unfoldTree`.
17:29:15 <lpaste> Strikingwolf pasted “Record Evil” at http://lpaste.net/355257
17:29:39 <Strikingwolf> Cale and ReinH you might be interested
17:29:45 <erisco> dmwit, I do. I also implemented it naturally and had a different answer
17:29:50 <monochrom> What Scott Aaronson said about mathematicians and computer scientists are very creative in naming things.
17:29:57 <erisco> monochrom, I am working on it
17:30:16 <dmwit> erisco: From your paste, you implemented a more different `unfoldForest`, but not an `unfoldTree`.
17:30:25 <dmwit> erisco: And yes, there can be multiple natural implementations of a thing.
17:30:36 <erisco> dmwit, I also defined Tree above. I came to the definition of Forest differently
17:30:46 <erisco> it is also just a tree with labeled edges, which is what I intended
17:31:30 <dmwit> I'm not sure what you're trying to convince me of. Do you disagree that this is the most likely explanation for how we got an `unfoldForest` of the type we have?
17:31:33 <monochrom> I think unfoldForest doesn't even need inspiration from the internal code of unfoldTree. They are just one map away. unfoldForest f = map (unfoldTree f)
17:33:00 <erisco> monochrom, let unfoldTree f z = fmap (\(a,b) -> Data.Tree.Node a (unfoldTree f b)) (f z) in unfoldTree  I think
17:33:58 <monochrom> unfoldTree? unfoldForest2?
17:34:19 <erisco> you asked me to rewrite my unfold to work on Data.Tree.Tree
17:34:30 <erisco> er, Data.Tree.Forest
17:34:48 <erisco> too much foliage
17:36:22 <monochrom> @type let u f z = fmap (\(a,b) -> Data.Tree.Node a (u f b)) (f z) in u
17:36:24 <lambdabot> (t -> [(a, t)]) -> t -> Forest a
17:36:36 <monochrom> OK that looks like your proposed type.
17:37:27 <monochrom> > let u f z = fmap (\(a,b) -> Data.Tree.Node a (u f b)) (f z) in u (\b -> (b, if b==0 then [] else [b-1])) [3,1,4,5]
17:37:30 <lambdabot>  error:
17:37:30 <lambdabot>      • Couldn't match expected type ‘[(a, [t0])]’
17:37:30 <lambdabot>                    with actual type ‘([t0], [[t0]])’
17:38:09 <erisco> > let u f z = fmap (\(a,b) -> Data.Tree.Node a (u f b)) (f z) in u (fmap (\b -> (b, if b==0 then [] else [b-1]))) [3,1,4,5]
17:38:11 <lambdabot>  [Node {rootLabel = 3, subForest = [Node {rootLabel = 2, subForest = [Node {r...
17:38:39 <monochrom> Ah right.
17:40:12 <monochrom> OK, I think their design was firstly to stick to (b -> (a, [b])) because unfoldTree did it, and not suddenly switch to (b -> [(a, b)])
17:40:46 <erisco> mine was based on how I expect unfolds to look
17:40:52 <monochrom> Once that's decided, it became a case of fmapping from b->Tree to [b]->[Tree]
17:41:15 <monochrom> That is not an accurate statement.
17:41:31 <monochrom> The accurate statement is "based on how Forest is defined"
17:41:55 <erisco> which statement is it correcting?
17:42:06 <monochrom> "based on how unfolds look"
17:42:18 <erisco> I knew nothing of Forest when I made my definition
17:43:32 <erisco> I am expecting unfolds to look like  (b -> F b) -> b -> F  for some F
17:43:46 <benzrf> erisco: u mean Fix F at the end there?
17:43:55 <erisco> sorry I have a little kind error there
17:44:06 <monochrom> But there are two different F's.
17:44:21 <monochrom> "they are equivalent" is still not going to cut it.
17:44:30 <erisco> benzrf, yeah that would clean it up the best, thanks
17:44:54 <monochrom> Or rather, "their respective Fix F's are equivalent" is not going to cut it.
17:45:03 <erisco> what is equivalent?
17:45:19 <benzrf> like isomorphic but respecting higher morphisms
17:45:22 <erisco> you mean when I pointed out my Tree is the same as their Forest?
17:45:22 <monochrom> Not to mention that it is more complicated than two Fix F's.
17:46:00 <monochrom> There is one functor F2, such that your type is Fix F2.
17:46:34 <erisco> I've tried to make this clear from the start but it hasn't got through
17:46:43 <erisco> which is why I was questioning this entire line of investigation
17:46:48 <monochrom> Data.Tree.Forest, on the other hand, is stranger than that. There is a functor G1, such that Data.Tree.Tree is Fix G1; and then Forest is [Fix G1].
17:46:49 <erisco> I am not claiming the way I did it is the correct way
17:46:59 <erisco> I am asking how they derived their answer so I have some basis to compare the two
17:47:05 <erisco> because I haven't a clue how they did
17:47:42 <monochrom> OK, did you see what I said about <monochrom> I think unfoldForest doesn't even need inspiration from the internal code of unfoldTree. They are just one map away. unfoldForest f = map (unfoldTree f)
17:48:04 <monochrom> unfoldTree is likely what you expect out of Fix G1.
17:48:42 <monochrom> But what to do with [Fix G1]? Looks to me lifting b->FixG1 to [b]->[FixG1] is pretty natural.
17:49:55 <erisco> then maybe it is because they're only treating Forest as an alias for [Tree a]
17:51:00 <erisco> I am not sure how unfolding would generally apply to such cases, but this is what they did, okay
17:53:03 <erisco> it gives me little reason to use the Data.Tree module for this scenario though... hm
17:53:18 <erisco> I've been rather annoyed with trying to find some umbrella for these tree-like things
17:54:38 <erisco> not sure if that even practically exists or if we just have to accept a zoo of them
17:54:55 <monochrom> The umbrella is Fix.
17:55:41 <monochrom> All recursive algebraic data types in which the recursion happens at only positive (covariant) positions are trees, and vice versa.
17:55:58 <monochrom> So all of them are Fix Something
17:56:08 <erisco> well the annoyance is trying to find how much or little structure is necessary, and what that structure is, to define the interesting algorithms
17:56:39 <erisco> yes they are all a Fix of something but the somethings are significant
17:56:56 <monochrom> But you will never be able to escape from this nightmare. Functors H1 and H2 are non-equivalent, but Fix H1 and Fix H2 are. But your cata and ana formulas depend on H1 and H2 directly. Now you have two conflicting stories.
17:57:54 <erisco> I tried approaching it with zippers, or something inspired by that
17:58:21 <erisco> so I may not know the actual tree type, say, but I have some type which can let me zoom around any tree
17:58:39 <monochrom> For example "data H1 r = Nil | Cons Int r", "data H2 r = None | One Int r | Two Int Int r", for redundancy's sake.
17:58:43 <erisco> and then you can define algorithms on that
17:59:50 <monochrom> Actually I guess this is not an example.
18:01:31 <erisco> this is the type I started working with
18:01:32 <erisco> http://lpaste.net/355259
18:02:11 <erisco> for example, 'Location Pair a' can be the locations in a list
18:02:46 <erisco> 'Location Triple a' can be the locations in a binary tree
18:03:35 <erisco> so by knowing just a little bit about j I can write useful algorithms for it... or at least that is the hope
18:03:54 <monochrom> This is an interesting type. Like free monad but different.
18:04:10 <erisco> the only charge is to convert your type to Location J A for some J and A
18:04:48 <erisco> the first thing I started thinking about is routes
18:05:03 <erisco> for example, with lists, we have both forwards and backwards available to us
18:05:14 <erisco> so a route may be to always go forward, for example
18:05:26 <monochrom> OK yeah I see that Fix is too unspecific. Free monads are Fix's too but we can say so much more about free monads.
18:05:45 <erisco> and maybe this is done by providing an f :: Pair a -> a which projects the forward location
18:06:05 <erisco> yeah I also looked at Free and Cofree
18:07:21 <erisco> then you might have more sophisticated routes which are stateful
18:07:58 <erisco> at least that was the initial thinking... some route through the locations, then some fold over the locations
18:08:08 <EvanR> can i have syntax for chaining U a -> (a -> V b) -> V b's
18:08:15 * ski . o O ( aka `newtype List ref a = MkList (ref (Cell ref a)); data Cell ref a = Nil | Cons a (List ref a)' )
18:09:21 <erisco> but I was also realising that in my specific use my route splits
18:09:49 <erisco> I am actually interesting in the paths of the tree in my particular case
18:10:08 <erisco> but not just a list of paths as I have to cull them early as I explore them
18:10:19 <erisco> otherwise my program simply takes too long :)
18:22:12 <erisco> okay here is another curiosity... maybe some thoughts on it http://lpaste.net/355260
18:22:21 <erisco> lets not get hung up on whether it resembles a mux or not :P
18:22:52 <erisco> so we have the recognisable [m a] -> m [a] type which we know as sequence, but this is doing something else
18:24:07 <erisco> and I am not sure yet if this is something particular to State or if there is really something generic like sequence going on, possibly with something more than just a Monad
18:24:19 <ski> erisco : that `join' there must be wrong ..
18:24:34 <erisco> I did a quick retrofit... did I mess up? let me check
18:24:56 <ski> (or else the type signature is wrong)
18:25:48 <ski> `Monoid s => [State s a] -> State s [a]' might be more fun, btw
18:26:13 <erisco> yes that should not have been there at all, thanks. I removed it
18:27:16 <erisco> it generalises from list to any Functor as well
18:27:44 <erisco> mm perhaps yes, but then if your state is not a Monoid then not so much, heh
18:27:45 <ski> not with `Monoid'
18:28:04 <ski> you need `Foldable', i suppose
18:28:19 <erisco> I was commenting prior to your message
18:28:39 <erisco> multiplex :: (Functor f) => f (State s a) -> State s (f a)
18:28:59 <erisco> so another way to look at this, maybe, is interchanging functors
18:29:04 <erisco> f (g a) for g (f a)
18:29:48 <erisco> :t sequence
18:29:50 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:30:08 <erisco> that's not such a great way to distinguish it from sequence though, hm
18:30:14 <erisco> since Monad and Traversable both are Functor
18:31:31 <erisco> I suppose all I can do is figure out the properties of it and go from there
18:32:05 <erisco> it is crucial for searching the paths of a tree
18:36:42 <erisco> EvanR, yeah, if you also have bind for V
18:36:58 <EvanR> oh?
18:37:02 <erisco> EvanR, then you do the unthinkable and make a bogus class for the purposes of overloading an operator
18:38:18 <ski> is `U = State sr' and `V = Reader sr' ?
18:38:31 <EvanR> no
18:39:12 <EvanR> but good point, it would be a monad if there was an embeding of U into V
18:39:14 <erisco> class Heresy f g where (><=) :: f a -> (a -> g b) -> g b; instance Monad m => Heresy m m where (><=) = (>>=)
18:50:41 <kv_> Hey haskell list! I'm working on a compiler with multiple AST transformations for a little language. I want some of the passes to put a placeholder for another transform to fill in eventually. Currently I am accomplishing this with strings and I feel like there are better type-safe approaches. Any suggestions to google or blog posts I should check out?
18:52:04 <lyxia> kv_: How about defining an ADT for your placeholders
18:52:35 <lyxia> That would be safer
18:53:06 <kv_> Yeah i was think about potentially using a phantom type in the AST parameterized over the placeholder ADT
18:54:09 <DrMentats> kv_: I asked a similar question a while ago and people sent this my way
18:54:09 <erisco> that's good instinct. can you provide more detail on what these placeholders are?
18:54:12 <DrMentats> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
18:54:15 <DrMentats> maybe it helps you
19:10:33 <Xnuk> t
19:13:03 <kv_> @DrMentats thanks for the link! The context is I am try to create a program that ultimately gets localized to multiple versions. The AST for the program is essentially the same up until the localization step and I need to insert some language specific into parts of the AST
19:13:03 <lambdabot> Unknown command, try @list
19:31:35 <rotaerk> is there some way to disable latex awareness in vim for .lhs files?
19:32:14 <rotaerk> its syntax highlighting is thrown off by the presence of $ in the text of my document...
19:32:25 <rotaerk> since $ is a special character in latex
19:33:07 <rotaerk> I'd rather the lhs be nothing more than a plain-text file with the occasional code indicated by >s
19:43:51 <sophiag> i'm trying to write a monad transformer as an exercise and wondering why MonadState, MonadWriter, MonadReader, etc. aren't showing up in Control.Monad.Trans.State, etc.?
19:44:24 <glguy> That module is from transformers, but those classes are from mtl
19:44:51 <dmwit> rotaerk: :syn off
19:45:03 <sophiag> is the problem i'm using the wrong constructors and it should be StateT instead of MonadState?
19:45:14 <glguy> transformers provides all of the types and operations. mtl adds the classes.
19:45:32 <dmwit> sophiag: import Control.Monad.State instead.
19:45:54 <rotaerk> dmwit, think that turns off all highlighting; I just mean, the only highlight should be on the code sections
19:45:54 <glguy> MonadState and StateT are just two different things
19:46:01 <glguy> first will be to figure out which one you actually needed
19:46:08 <rotaerk> it's currently highlighting non-code sections because of latex
19:46:17 <dmwit> rotaerk: Ah, yeah, that change is much more involved. You'd need to find the syntax file being used and strip out the bits you don't like.
19:46:20 <rotaerk> although ... it just stopped when I did :filetype off and :filetype on ...
19:46:26 <rotaerk> not sure why
19:46:27 <sophiag> dmwit: thanks. for some reason i thought i tried that...
19:47:04 <dmwit> rotaerk: vim doesn't parse the whole file by default. So sometimes it needs to update its parse to either look at less context or more.
19:47:40 <rotaerk> ah
19:48:05 <glguy> You can press ^L to redraw/update that
19:49:06 <rotaerk> thanks
19:57:16 <sophiag> sorry, another question about monad transformers...the whole reason i went back and did a refresher on them was to try and understand Oleg's version of a zipper that uses continuations. he uses a custom transformer for delimited continuations in that example, but i was hoping to modify it to use ContT
19:59:41 <sophiag> this is my sad attempt at just creating a type synonym with ContT stacked over his Zipper data type: http://lpaste.net/355263 
20:00:33 <sophiag> i should mention i've yet to go through his continuations tutorial, although i've used ad hoc shift and reset a little bit
20:08:00 <EvanR> where is Fix...
20:08:43 <ADG> should doing stack upgrade make it to latest version but performing this again does the same thing
20:13:22 <MarcelineVQ> the new stack binary, and any other executable created with stack upgrade or stack install, is placed at ~/.local/bin you need to point your path there to be using the latest one
20:15:01 <MarcelineVQ> oh, he didn't stick around :(
20:20:19 <MarcelineVQ> sophiag: you forgot to ask your question :o
20:22:42 <sophiag> it was more of the stupid child from passover sort of question
20:22:55 <sophiag> "doesn't know enough to ask one..."
20:24:16 <sophiag> i'm going to go through Oleg's continuations tutorial, but often it's amazingly helpful when someone here is in the mood to walk you through things. i learn a lot just by keeping this channel open in a buffer when i'm working tbh
20:24:53 <c_wraith> sophiag: that was a large part of my initial effort in learning haskell, too
20:41:37 <Welkin> what is oleg's continuations tutorial? link?
20:45:00 <sophiag> http://okmij.org/ftp/continuations/implementations.html
22:17:07 <jchia_3> Monad transformer question. I'm making a conduit based on IO that updates state (StateT) and uses some fixed config information (ReaderT). Which stack makes more sense? Consumer (Id, ss) (ReaderT r (StateT s (ResourceT m))) rs or Consumer (Id, ss) (StateT s (ReaderT r (ResourceT m))) rs ? Or it doesn't really matter?
22:17:53 <jchia_3> Basically, which ordering of ReaderT and StateT is better?
22:19:02 <glguy> ?unmtl StateT s (ReaderT e IO) a
22:19:02 <lambdabot> s -> e -> IO (a, s)
22:19:08 <glguy> ?unmtl ReaderT e (StateT s IO) a
22:19:08 <lambdabot> e -> s -> IO (a, s)
22:19:15 <glguy> Doesn't matter
22:20:05 <jchia_3> glguy: Can I expect an difference in performance?
22:22:51 <glguy> I wouldn't. There shouldn't be, but of course it's possible that it somehow affects an optimization somewhere and there's a slight difference
22:26:14 <jchia_3> OK
22:36:32 <EvanR> k my code literally has fmap (fmap (fmap f)) d in it
22:36:44 <EvanR> this is silly
22:37:27 <EvanR> and its the base of a small pyramid of fmaps 
22:38:16 <EvanR> DeriveFunctor should really just be locked into enabled
22:42:23 <ghatom> am I gonna get booted from here for saying: "Sorry, Blackberry - Loved you, but GTFO"?.... sure did at irc.twit.tv -- F-Leo
22:44:35 <ghatom> deb rc3 + tmux + irssi + mocp + yup still: lynx = decent fri night.....
22:45:06 <glguy> ghatom: This channel is for discussing the Haskell programming language. Are you here about that?
22:45:07 <ghatom> X is for fools..... lol
22:45:21 <glguy> It's not for general chatter
22:45:34 <ghatom> another douche to boot for open speak.... thx
22:45:49 <ghatom> glguy = gay-lovin guy
22:45:57 --- mode: ChanServ set +o glguy
22:45:57 --- mode: glguy set +b *!*@75-133-226-247.dhcp.aldl.mi.charter.com
22:45:57 --- kick: ghatom was kicked by glguy (offtopic)
22:49:49 <dmwit> EvanR: Learn to love Compose.
22:50:01 <dmwit> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Compose.html
22:51:09 <EvanR> heres another one... i wrote the Monoid instance... now im going to implement Applicative by writing first f a -> f b -> f (a,b). and the code is basically the same
22:51:19 <EvanR> something fishy
22:51:48 <EvanR> guess i could implement Monoid with Applicative
22:52:19 <Costar> Is possible a function ((a -> x) -> x) -> a ???
22:52:22 <dmwit> There's got to be an `instance (Applicative f, Monoid a) => Monoid (SomeNewtypeWrapper f a)` somewhere.
22:52:51 <dmwit> :t \f -> f id
22:52:52 <lambdabot> ((a -> a) -> t) -> t
22:53:08 <dmwit> Costar: If you can pick `x ~ a`, then sure.
22:53:15 <EvanR> @djinn ((a -> x) -> x) -> a
22:53:15 <lambdabot> -- f cannot be realized.
22:53:23 <glguy> Costar's type looks too much like double negation elimination to be realizable
22:53:27 --- mode: glguy set -o glguy
22:53:49 <dmwit> :t runCont
22:53:50 <lambdabot> Cont r a -> (a -> r) -> r
22:54:06 <Costar> I got it right so
22:54:18 <Costar> I tought x ~ a was bad
22:54:47 <dmwit> But yeah, you can't implement that type in its full generality. As the other folks are saying.
22:55:02 <Costar> Thank you
22:55:15 <EvanR> heh, but then implementing pure is easy with mempty
22:55:19 <Costar> Im just trying to catch Yoneda Lemma for the Identity Functor
22:55:59 <EvanR> pure x = fmap (const x) (mempty :: f ())
22:56:26 <jchia_3> Another monad transformer question. I have a ReaderT r somewhere in the middle of my monad transformer stack. How do I change it to ReaderT (r, a)? Basically, the idea is that you can give me a (r, a) from outside, but I'm still just going to read the r. Concretely, how can I change `ConduitM i o (ReaderT r m) ()` to `ConduitM i o (ReaderT (r, a) m) ()`? Can I accomplish that using the right combination of hoist and withReaderT?
22:56:32 <EvanR> feeding off of each other
22:57:12 <glguy> withReaderT fst :: ReaderT r m a -> ReaderT (r, b) m a
22:57:40 <dmwit> EvanR: Do you have `pure id <*> v = v`?
22:58:22 <jchia_3> glguy: Yeah, but withReaderT fst expects a "ReaderT ...", not a "ConduitM ...". What else do I need?
22:58:40 <EvanR> yeah
22:59:13 <glguy> jchia_3: You'll need ConduitM's version of 'mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b', maybe that's the hoist you mentioned?
23:01:23 <jchia_3> glguy: Yeah, except I'm not sure what exactly it is.
23:02:59 <glguy> I don't have that library memorized, I don't use it
23:03:44 <glguy> It seems that it is hoist http://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#t:MFunctor
23:05:45 <EvanR> :t fst <*> snd
23:05:46 <lambdabot> (b -> b1, b) -> b1
23:08:22 <Sh4rPEYE> Hello. Is there a way to achieve coloring in GHCi, similar to this: https://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
23:09:07 <Sh4rPEYE> The method described there doesn't work when a module is loaded in GHCi. Is there a better way now, after 4 years?
23:09:26 <cocreature> jchia_3: I think "hoist (withReaderT fst)" should do what you want
23:12:43 <cocreature> :t hoist (withReaderT fst)
23:12:45 <lambdabot> (Monad m, MFunctor t) => t (ReaderT r m) b1 -> t (ReaderT (r, b) m) b1
23:13:00 <osa1> anyone know if "Simple unification-based type inference for GADTs" is the most recent paper on GHC GADT type checking?
23:21:19 <osa1> ugh, that paper doesn't even mention desugaring to Core/SystemFC
23:21:34 <[exa]> osa1: actually I'd suggest reading THIH
23:21:42 <osa1> what's that?
23:21:51 <[exa]> Typing Haskell In Haskell
23:22:00 <osa1> does that mention desugaring to Core?
23:22:06 <[exa]> nope
23:22:15 <[exa]> but it gives hints to most complicated situations
23:22:24 <[exa]> aaaaaaaaaaaand has typeclasses.
23:22:54 <[exa]> btw desugaring isn't that hard, is there something specific you're looking for?
23:23:24 <osa1> I don't think that paper has GADTs in type system
23:24:47 <[exa]> oh I see, misunderstood your question, sorry :]
23:24:54 <cocreature> osa1: maybe there is some paper that explains desugaring of existentials? gadts are just existentials with type equality constraints
23:24:56 <osa1> I found something relevant: "System FC with Explicit Kind Equality"
23:25:18 <osa1> cocreature: type equality constraints part is especially important in my case :)
23:25:24 <osa1> but I think I found the paper I'm looking for
23:28:54 <rotaerk> hmm the > prefixes in literate haskell ruin my ability to indent/unindent lines...
23:29:02 <rotaerk> since it wants to add/remove the spaces *before* the >
23:29:12 <EvanR> reprogram the editor
23:29:26 <rotaerk> I suppose, I mean I can do it with substitutions
23:30:33 <cfoch-always> hi
23:30:42 <cfoch-always> can I use Diagrams in other language?
23:31:32 <Cale> cfoch-always: That sounds like a difficult plan.
23:31:49 <Cale> Even just porting the library will be tricky given how extensively it relies on type classes
23:33:55 <cfoch-always> Cale: can I write a software interactive diagrams with Diagrams? I want to create a software to create conceptual maps
23:38:00 <Cale> Probably, though it would depend on what you're doing -- it's not totally ideal for fast animations.
23:40:57 <jchia_3> glguy, cocreature, yeah, it's hoist that I need.
23:42:38 <jchia_3> When I get a type error from ghc, is there an easy way to tell whether it's because I have wrong types or it's because ghc needs some help from type annotation? I just spent 30 minutes scratching my head over a compilation error where it turned out that ghc just needs help with type annotation. The error is "Couldn't match type ... because type variable 'o' would escape its scope"
23:43:39 <cocreature> jchia_3: experience helps but apart from that there is no magic trick that tells you whether you need a type annotation or not
23:43:41 <jchia_3> At first I thought I had wrong types
23:43:43 <dysfun> that sounds like the errors you get when doing universal quantification accidentally wrong
23:44:23 <EvanR> you need type signatures when using RankNTypes probably
23:44:23 <Hafydd> jchia_3: not having the correct type annotations is a form of having wrong rtpes.
23:44:26 <Hafydd> *types
23:44:45 <dysfun> types and code are two halves of the same coin
23:44:59 <jchia_3> Hafydd: By 'wrong' I mean it cannot possibly make sense no matter what types are assigned to the different parts
23:45:07 <EvanR> that error message should say "type inference epically failed due to use of higher ranked type"
23:45:13 <EvanR> "put a type signature"
23:45:22 <Hafydd> Oh...
23:45:38 <jchia_3> I am indeed using RankNTypes
23:46:17 <jchia_3> EvanR: Yeah, that would be a more helpful message
23:46:20 <EvanR> i usually have to do this when i use a higher ranked type function in a where clause
23:46:30 <EvanR> and then i have to enable ScopedTypeVariables too
23:46:44 <EvanR> fun for the whole family
23:46:48 <cocreature> in general adding type signatures when you’re confused about a type error is always a good first step
23:47:13 <cocreature> EvanR: and then you forget to add explicit foralls and wonder why enabling ScopedTypeVariables didn’t help :)
23:47:21 <EvanR> well, i know that now
23:47:25 <EvanR> but yeah
23:47:47 <EvanR> thats a "gotcha"
