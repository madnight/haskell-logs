00:43:30 <Cooler> which is the current standard haskell 98?
00:43:51 <Cooler> haskell 2010?
00:44:24 <Cale> btw, those two are almost the same thing
00:44:49 <quchen> Cooler: Haskell 2010, yes.
00:44:55 <Myrl-saki> > 2010 - 98
00:44:57 <lambdabot>  1912
00:45:10 <Cooler> is there a formal grammar for Haskell 2010?
00:45:15 <Cale> Haskell 2010 mostly just consolidated some extensions to the standard which had been made since Haskell 98, and made a few small changes here and there.
00:45:27 <Cale> It's in the Report.
00:46:11 <merijn> Cale: Of course it skipped like half of the things it could have usefully consolidated :p
00:46:15 <Cale> yes
00:47:00 <Cale> Also, it's not so much the consolidating which needs doing, but just producing documents in the first place which describe what's been implemented in a precise way.
00:47:06 <merijn> hmmm, I wonder if criterion assumes measurements are uniformly distributed around the mean, I suppose that could fuck things up...
00:47:21 <Cale> I didn't think it did
00:47:49 <Cale> It produces kernel density estimates, doesn't it?
00:47:51 <quchen> You mean »gaussian around the mean«?
00:48:01 <quchen> Or at least symmetric
00:48:21 <merijn> Cale: Well, the issue I'm having is that, given only positive timing results (obviously, since it clamps negative to zero...) it ends up predicting ranges who start in the negative runtime
00:48:31 <merijn> quchen: Yeah, something like that...it's early...
00:51:18 <merijn> Looks like I'll have to reverse engineer statistics from this code >.>
00:51:35 <Cale> merijn: It's probably producing an estimate of the PDF which is a sum of Gaussians -- which doesn't necessarily make total sense for something which is supposed to be a length of time.
00:52:09 <merijn> Cale: Especially for small runtimes with big (relatively) outlies
00:52:33 <merijn> Because you get things like:
00:52:36 <merijn> time                 8.926 ms   (-3.289 ms .. 14.23 ms)
00:52:36 <merijn>                      0.935 R²   (0.703 R² .. 1.000 R²)
00:52:48 <merijn> Pretty confident about that negative runtime there...
00:53:34 <Cale> There's a way, iirc, to have it plot a graph of the PDF it estimated
00:53:41 <tsahyt> negative runtime sounds sweet. Just run this function often enough and negate the cost of anything else.
00:53:50 <quchen> Most basic statistical analysis is based on Gaussians, so this wouldn’t surprise me.
00:54:13 <johnw> negative runtime will mean management expecting me to retroactively meet deadlines
00:54:25 <Cale> tsahyt: Note that if you run it enough though, it will tend to take an amount of time closer to the mean which is positive, so you'd have to luck out
00:54:27 <Cale> ;)
00:54:40 <quchen> johnw: Not like that’s any different with positive runtime
00:55:02 <johnw> yeah, true
00:55:32 <merijn> So...what are the odds of me finding a way to clamp the statistics to positive values? Basically 0?
00:55:45 <johnw> your odds are -0.3%
00:56:08 <Myrl-saki> merijn: What does R^2 mean.
00:56:19 <Cale> merijn: ah, try running your program with --output foo.html
00:56:48 <Cale> Myrl-saki: That's the https://en.wikipedia.org/wiki/Coefficient_of_determination
00:57:00 <merijn> Myrl-saki: Statistic mumbo jumbo about likelihood of the timing estimate being nonsense :p
00:57:09 <merijn> Cale: Yeah, I know about that one :)
00:57:20 <Cale> merijn: What does the graph look like?
00:57:30 <Myrl-saki> Thanks.
00:58:34 <Cale> But yeah, the 0.703 suggests that the low end of that interval is meaningless.
00:59:04 <merijn> Cale: Well it also seems to be bootstrapping based on a mere 4 samples, which seems...wrong?
00:59:21 <Cale> yeah, that's odd
01:00:06 <merijn> Presumably based on the fairly long runtime
01:00:40 <Cale> Maybe increase the timeLimit in the config?
01:01:19 <merijn> Cale: http://files.inconsistent.nl/AtomicCounter.html
01:02:05 <merijn> Cale: I dunno how to increase that for a single benchmark, rather than all of them, though :\
01:03:17 <Cale> That mean line on the KDE is pretty weird looking
01:04:02 <Cale> timeLimit :: Double	
01:04:02 <Cale> Number of seconds to run a single benchmark. (In practice, execution time will very slightly exceed this limit.)
01:04:14 <Cale> It's a field of Config
01:04:19 <merijn> Yeah there's a a -L flag for that
01:04:33 <merijn> Defaults to 5s, I think
01:05:54 <merijn> 10 fold increase over the number of samples still results in only like 5 samples
01:07:20 <merijn> This might also just be me having half-broken criterion. Since it tries to benchmark batches of N runs for better accuracy. But this is basically forcing batches of N runs to be N individual runs added together
01:08:46 <merijn> Anyway, I guess I should just ignore the low end estimate, given how noisy this entire thing is
01:08:54 <merijn> ls
01:10:33 <merijn> Only a hanful of benchmarks seem really affected anyway and those are all noisy to begin with
01:10:50 <merijn> Althought the upperbound time estimate of "NaN s" is interesting too...
01:26:02 <j03_k> what does the _ mean in haskell
01:26:10 <merijn> j03_k: wildcard pattern
01:26:24 <MasseR> Or a hole
01:29:52 <j03_k> what is the co-domain of the mod function?
01:30:34 <quchen> The codomain is what a function maps to.
01:31:10 <Cale> :t mod
01:31:12 <lambdabot> Integral a => a -> a -> a
01:31:34 <Cale> It's some type a -> a where a is an instance of Integral
01:33:15 <quchen> Cale: Nitpicky, but does mod even have a codomain? Isn’t it a family of functions parametrized over a constrained type?
01:33:28 <quchen> Depends on whether we interpret => as a function arrow or not I suppose
01:33:57 <Cale> My answer was relative to the type a that we choose.
01:34:39 <Cale> quchen: Or perhaps on whether we interpret forall a. as a function arrow :)
01:34:59 <quchen> Heh!
01:35:30 <quchen> Cale: What kind is the »a« in »forall a«? I think we should first consider the »forall kind.« part
01:48:26 <Cale> quchen: a :: * here, it can't be kind-polymorphic
01:50:46 <quchen> Hm, right.
01:50:58 <quchen> Bad joke :-(
01:52:52 <Cale> But yeah, if it were kind-polymorphic, then we might have to consider that too
01:53:43 <ZuluKing> hey, can someone who is familiar with vscode+haskero or actually even intero, tell me why does it keep complaining failed to load interface for local modules?
01:54:06 <ZuluKing> I have included them in other-modules in my .cabal already
01:55:11 <Taneb> ZuluKing, are the modules installed on your system?
01:55:31 <ZuluKing> yes, they are part of my program, just not exposed ones.
01:55:40 <merijn> Right, so I think I have more timing data on concurrent synchronisation than anyone could ever want :p
01:55:47 <c_wraith> ZuluKing: I don't know specifically, but I can tell you that error specifically means that it can't find the .hi files ghc creates during compilation where it expects to
01:56:03 <c_wraith> ZuluKing: err, I can't tell you what that means in the context of those programs
01:56:09 <ZuluKing> where does it usually expect it to be?
01:56:09 <lpaste> merijn pasted “Concurrent synchronisation primitives benchmarks” at http://lpaste.net/355415
01:56:16 <ZuluKing> in local .stack-work?
01:56:44 <c_wraith> that's the part I can't tell you.  It depends on the flags passed in, and there are a lot of ways to control it.
01:56:57 <merijn> Conclussion AtomicCounter, despite going wack at higher contention is by far the best, IORef is pretty solid, TMVar is terribad
01:57:18 <merijn> Although I think the higher contention numbers are really to unstable to say anything sane
01:57:20 <ZuluKing> so I just checked all the .hi files are there in the .stack-work directory
01:57:39 <c_wraith> merijn: STM really is quite slow under contention.  striping is often a huge win when working with any STM data structure, if you can find a way to do it.
01:58:00 <merijn> c_wraith: Actually, TVar and TSem do pretty well
01:58:10 <merijn> As does TQueue
01:58:53 <merijn> c_wraith: TSem is 20 ms vs 15 for MVar, TMVar is a whopping 5 s, of by like 3 orders of magnitude...
01:59:03 <merijn> For 10k threads
01:59:18 <c_wraith> ZuluKing: that would suggest that something is misconfigured somehow - that ghc is looking in the wrong place for the .hi files
02:00:22 <c_wraith> ZuluKing: but I can't be more specific as I don't use any of the tools you're using.
02:00:31 <ZuluKing> c_wraith I just followed the standard instructions
02:00:38 * hackage transformers-lift 0.2.0.1 - Ad-hoc type classes for lifting  https://hackage.haskell.org/package/transformers-lift-0.2.0.1 (int_index)
02:00:55 <ZuluKing> c_wraith I am just using stack, vscode+haskero
02:01:09 <c_wraith> Yep.  I don't use any of those. :)
02:01:12 <ZuluKing> c_wraith I can stack build and stack exec with no problems
02:01:25 <ZuluKing> just that intero keeps reporting these errors
02:01:31 <ZuluKing> and it's midly irritating
02:02:12 <ZuluKing> c_wraith thanks for helping anyways :)
02:02:29 <merijn> Anyone that can think of any primitives I missed out on? Especially ones that might be able to contend with AtomicCounter/IORef?
02:12:43 <merijn> Can I turn an unbound thread into a bound thread somehow?
02:18:13 <merijn> oh, runInBoundThread solves my issue, I guess :)
02:45:15 <nuskin> hey everyone, currently I'm trying to do an exercise and am really struggling to understand how haskell abstract data types work
02:45:53 <nuskin> we're trying to make a type safe version of printf and this is what we're given to start off with http://lpaste.net/4565166523269775360
02:46:32 <nuskin> now ideally on line 11 I'd want L (x:xs) :: Format '[String ': Format xs]
02:47:07 <nuskin> but the compiler complains error: parse error on input ‘(’
02:55:08 * hackage mbox-utility 0.0.1 - List contents of an mbox file containing e-mails  https://hackage.haskell.org/package/mbox-utility-0.0.1 (HenningThielemann)
03:00:21 <Itkovian> I'm trying to get my head wrapped around conduit. the end goal is to have the input converted and send to one port (or sink?) if the conversion succeeds and to another port (or sink?)if it fails. any pointers to (recent) docs explaining this a bit more?
03:07:58 <cocreature> nuskin: can you explain what the L constructor is supposed to do or how it is supposed to be used?
03:10:30 <Cooler> i am looking at the lexical syntax given here https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
03:10:39 <Cooler> why do comments have weird rules?
03:11:05 <quchen> Cooler: »--|« is a valid operator name.
03:11:24 <quchen> Cooler: https://github.com/quchen/articles/blob/master/fbut.md#comment-syntax
03:11:26 <Cooler> you  mean >>--|<< ?
03:12:07 <quchen> No, I did not mean that, but »>>--|<<« would also be a valid operator name.
03:12:24 <quchen> > let (--|) = "hello Cooler" in (--|)
03:12:27 <lambdabot>  "hello Cooler"
03:13:09 <quchen> > let (--|) = (<>) in "hello" --| "Cooler"
03:13:11 <lambdabot>  "helloCooler"
03:13:23 <pacak> > let (☭) = (+) in 10 ☭ 20
03:13:25 <lambdabot>  30
03:14:54 <pacak> > let (☭--+-) = (+) in 10 ☭--+- 20
03:14:56 <lambdabot>  30
03:15:57 <Cooler> what about ncomment?
03:16:09 <sophiag> why would ghci be telling me it can't load Control.Monad.Either?
03:17:44 <nuskin> cocreature: so L defines string literals, I integers, X is a terminating state and S for string
03:17:44 <Cooler> that page says theres no special cases with ncomment
03:17:53 <Cooler> but the rules are still weird
03:18:04 <quchen> Cooler: {- comments can be nested -}
03:18:18 <cocreature> nuskin: so what parameters am I supposed to pass to L as a user? a String and the rest of the format string?
03:18:28 <cocreature> or only the rest of the format string?
03:18:45 <cocreature> I guess probably the latter
03:19:22 <nuskin> cocreature: the former
03:19:26 <Cooler> ncomment	→	opencom ANY seq {ncomment ANY seq} closecom
03:19:26 <Cooler> ANY seq	→	{ANY }⟨{ANY } ( opencom | closecom ) {ANY }⟩
03:19:41 <Cooler> wth is ANY seq
03:19:41 <cocreature> nuskin: so it’s a string constant instead of a string parameter?
03:20:05 <cocreature> nuskin: try http://lpaste.net/355416
03:20:20 <nuskin> cocreature: so my understanding from the examples is you need to take the string that's given as the first parameter, and then recursively call Format onto the second paramter
03:20:59 <nuskin> though I could be completely wrong
03:21:30 <nuskin> I haven't been able to find any good textbook explanations of this and our lecturer simply said 'just think hard about the type magic and you'll get there eventually'
03:21:40 <cocreature> nuskin: does my code make sense to you?
03:21:53 <cldr> Hi there, newbie question. I'm in ch15 of the haskell book. Implementing monoids. My imports of Data.Semigroup and Data.Monoid conflict on (<>). Any way round this?
03:22:42 <nuskin> cocreature: what does the -> mean?
03:23:21 <mojjo> hi.. how would you implement a fn that behaves like this: ` f '-' ['A'..'C'] --> ["--A", "-B-", "C--"] ` I have a working implementation, but it looks quite awkward to me.. (http://lpaste.net/355417)
03:23:22 <cocreature> nuskin: constructors in Haskell are just functions. so this declares the constructor L as a function that takes a String, a format string (the rest of your format string) and returns a new format string
03:24:16 <nuskin> cocreature: so this is a type constructor, not a data constructor correct?
03:24:24 <cocreature> nuskin: no it’s a data constructor
03:25:31 <nuskin> cocreature: so are X L S I the constructors or is Format (fmt :: [*]) the constructor?
03:25:48 <cocreature> nuskin: Format is a type constructor, X L S and I are data constructors
03:26:43 <cocreature> note that DataKinds gives you type constructors corresponding to data constructors if you prefix the names with ' (prefixing is not strictly always necessary but it’s good practise)
03:28:59 <nuskin> cocreature: hmm I see. but I'm more confused now by the fact that the S and L type constructors being identical (in my head)
03:29:28 <cocreature> nuskin: ah I think I messed up the L constructor. what you really want is http://lpaste.net/355418
03:29:37 <nuskin> because they're both going to have a String as their first parameter and then a Format type as their second
03:29:39 <cocreature> L is a literal so it doesn’t add anything to the list of parameters "fmt"
03:29:58 <cocreature> http://lpaste.net/355418 might be what you’re looking for
03:32:23 <Cale> @let separate [] = []; separate (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separate xs]
03:32:25 <lambdabot>  Defined.
03:32:36 <Cale> > map (\(us,v,vs) -> map (const '-') vs ++ v : map (const '-') us) (separate "ABCD")
03:32:38 <lambdabot>  ["---A","--B-","-C--","D---"]
03:32:43 <nuskin> cocreature: that makes sense
03:34:47 <nuskin> cocreature: I find that the syntax makes concepts like these a lot more convoluted than they ought to be 
03:35:14 <nuskin> or that could be me just not used to haskell itself coming from a conventional programming background
03:35:23 <Cale> mojjo: ^^
03:35:41 <cocreature> nuskin: the fact that this fancy typelevel stuff was later bolted on to Haskell always makes it feel slightly awkward
03:35:48 <Cale> mojjo: Probably can do better still... somehow
03:36:05 <cocreature> nuskin: it’s easier in a language designed for this such as Idris
03:36:19 <nuskin> I'd never heard of it before 
03:36:56 <cocreature> nuskin: btw what kind of course is that? that’s a very advanced exercise for a Haskell course imho
03:38:27 <lazyunclebob_> Hey haskellers, I've recently found my way to functional programming, and specifically Haskell, enjoying my trip so far.
03:38:38 <nuskin> cocreature: it's the introductory functional programming/software design course at my uni 
03:38:59 <lazyunclebob_> Professionally I'm a web developer, specifically building API's, and I'd love to use Haskell to build API's, looked into Scotty, too barebones, looked into Yesod, but it has no API templates in Stack.
03:38:59 <cocreature> nuskin: puh, that’s some heavy stuff for an introductory course 
03:39:20 <lazyunclebob_> Any recommendations for good frameworks?
03:39:41 <nuskin> cocreature: I feel slightly better about myself you having said that
03:39:45 <Cale> lazyunclebob_: Snap and Happstack are two that I usually recommend
03:39:46 <Philonous> Is there any advantage to using :r in ghci over :l <filename> ?
03:39:57 <nuskin> you should see our second assignment... 
03:40:04 <lazyunclebob_> Cale: does Snap have a good template for building an API?
03:40:22 <Cale> lazyunclebob_: I'm not exactly sure what that means.
03:40:42 <Cale> It should be easy enough to build whatever web API you want with it.
03:40:42 <nuskin> our first one was to write up some basic math equations to fulfill what physics dictates in a particle simulator 
03:41:16 <lazyunclebob_> Cale: looking to build a RESTful API, PHP is too slow and inconsistent, so got into looking for some alternatives, Haskell seems just right.
03:41:22 <Cale> lazyunclebob_: There's also servant now -- I can never decide if it's brilliant or insane. It might be a bit of both. You construct a type which specifies how your API works, and it implements the server for you.
03:41:25 <nuskin> our second is creating a finite domain solver 
03:41:29 <Philonous> lazyunclebob_, I really like servant. It makes good use of Haskell's type system 
03:41:49 <Cale> I worry about recommending Servant to beginners though
03:42:00 <lazyunclebob_> I do feel like I qualify as a beginner.
03:42:19 <lazyunclebob_> I really like Yesod, but I'm really disappointed they do not have a pure template, well, they do, it's "yesod-pure", but it's 5 years old.
03:42:24 <Philonous> Yes, that's possibly a problem. If you're not used to a powerful type system it might be overwhelming. 
03:42:25 <lazyunclebob_> And no longer supported or included in Stack.
03:42:30 <cocreature> nuskin: creating a finite domain solver might be difficult but you can probably implement it using a relatively small subset of Haskell. the typesafe printf function you’re supposed to write requires 5 extensions or so
03:43:18 <Cale> lazyunclebob_: But anyway, Snap and Happstack and Servant all don't really have templates of any sort. They're just collections of libraries which make it relatively simple to build web servers.
03:43:33 <lazyunclebob_> Hmmm, I guess it's gonna be a bit of tinkering then.
03:43:47 <lazyunclebob_> Might go as far to create my own API template for Yesod or Snap.
03:43:54 <nuskin> cocreature: 5 extensions to make a finite domain solver or? the finite domain solver has a number of sub-tasks that they've given us
03:43:56 <Cale> I guess Snap has Snaplets, which I've never used.
03:44:31 <cocreature> nuskin: I doubt you need any Haskell extensions to write a finite domain solver. but you do need them to write your printf function since standard Haskell does not allow for this kind of typelevel tricker
03:44:32 <cocreature> y
03:44:44 <Cale> lazyunclebob_: Most of the web applications I work on for work use Snap, but it's total overkill, since our applications are all single page applications which do most of their communication with the backend over a websocket connection.
03:45:08 <Cale> (so the webserver itself is pretty simple, with only maybe 5 or 6 routes to handle)
03:45:12 <Ulrar> Cale: So is snap any good ? I've been using yesod a lot
03:45:18 <Cale> It's okay
03:45:19 <lazyunclebob_> Cale: the company I work for builds almost everything as an API, which communicates with JS frontends.
03:45:33 <Ulrar> I have to say, having played with ocsigen (ocaml) a bit, I loved it
03:45:37 <Cale> lazyunclebob_: We use reflex-dom to write our frontends in Haskell
03:45:37 <Ulrar> so much simpler
03:45:55 <nuskin> cocreature: namely; turning untyped represantations into typed, writing a matching evaluator, checking for satisfiability and computing a solution set for logical formulas 
03:46:13 <Cale> lazyunclebob_: It's very very nice to be able to write the frontend and backend in the same statically typed programming language, and have a guarantee that we'll never have issues with JSON encoding mismatch between them.
03:46:27 <nuskin> cocreature: ah as in Haskell extensions that we import, understood. I thought you were referring to extensions to the function printf that I'd have to create 
03:46:49 <Cale> (because the JSON encoders and decoders are constructed together automatically from the structure of the types, in code which is shared between the two)
03:46:57 <cocreature> nuskin: iirc the first exercise in the fp course at my university was to implement a "max" function that takes the maximum of 3 arguments instead of 2 like the builtin one :)
03:47:10 <lazyunclebob_> Cale: I can imagine, but our front-enders are weakly-typed fanatics
03:47:32 <Philonous> Cale, So you're using ghcjs for compiling Haskell to JS? 
03:47:48 <Cale> Actually, the fact that we use JSON at all is a bit funny -- we could just as easily use a binary protocol, but it's easier to see JSON in Chrome's debugger.
03:47:55 <Cale> Philonous: yes
03:47:57 <nuskin> cocreature: what a time to be alive :)
03:48:17 <lazyunclebob_> Well I guess it's decided, I'll make my own Yesod template for API's.
03:48:20 <merijn> JSON is all fun and games until two files get the same inode because JS doesn't support actual integers
03:48:23 <Cale> and ghc to compile largely the same frontend code to ARM for mobile as well
03:48:25 <lazyunclebob_> With blackjack and wenches.
03:48:31 <Guest22651> I'm sorry to be disturbing. Could anyone tell me about the logic of groupBy, or how [[1],[2,3],[4],[5,6],[7],[8,9]] comes to be the result of 'groupBy (\x -> \y ->(mod (x*y) 3 ==0))) [1,2,3,4,5,6,7,8,9]'?
03:49:00 <Philonous> Cale, I was thinking about trying that out, but the last time I checked the generated JS was gigantic. Is that solved, or do you just bite the bullet and hope caching will make load times not completely excruciating? 
03:49:09 <Cale> Guest22651: groupBy will compare the first element of each group to the successive elements in the list to determine if they belong in the group or not
03:49:32 <Cale> Philonous: It's not so bad if you run it through the closure compiler and then zopfli it.
03:49:53 <Cale> But yeah, there are things which could yet be done to improve it.
03:50:10 <Philonous> Cale, Ah, so the trick is to post-process it. Do you happen to know what size you roughly end up with?
03:50:17 <Cale> also, the generated JS size is only constant term large, it's not like it grows rapidly with program size
03:50:26 <Cale> ~500kb or so
03:51:16 <Philonous> Sure, but even just 1 or 2 megabytes are already really bad for page load times
03:51:32 <Philonous> 500kb is still sizeable, but maybe still OK
03:51:47 <Philonous> That's uncompressed, right?
03:51:51 <Cale> Our largest application is perhaps 3 MB, and that has a *lot* of stuff in it.
03:51:56 <Cale> No, that's compressed.
03:51:59 <Philonous> Oh
03:52:13 <Cale> Er, the 3MB is uncompressed actually
03:52:14 <Guest22651> @Cale Looks like your reply does make sense. Thank you so much :-)
03:52:15 <lambdabot> Unknown command, try @list
03:52:15 <Philonous> Right, you said zopfli
03:52:40 <Cale> actually, I'm uncertain, let me double check that
03:52:46 <nuskin> cocreature: thanks for your help so far, I'm gonna keep working on the second part to actually output a proper string given a format string 
03:52:52 <Guest22651> Cale: Looks like your reply does make sense. Thank you so much :-)
03:53:14 <Cale> Guest22651: no problem
03:54:18 <Cale> Yeah, the 3MB was the compressed size. It's like 30MB uncompressed
03:55:06 <cldr> Hi, going through the haskell book. Confused. Is it possible to make a monoid with the type `newtype Identity a = Identity a`? It seems to me there's no obvious implementation for mempty? Am I missing something?
03:55:23 <Philonous> 30MB... blimey 
03:55:31 <Cale> I'm fairly sure a lot of stuff could be done to get that down further, but it hasn't been a top priority thus far, because it's just a static file.
03:55:44 <Cale> Most YouTube videos are well above that :P
03:56:12 <Philonous> Sure, but you can watch while you stream. On a residential 3MBit line downloading the JS would take 10 seconds. 
03:56:28 <Guest22651> :quit
03:56:38 <Guest22651> exit
03:56:42 <Guest22651> quit
03:56:42 <liste> Cale: you can do "instance Monoid a => Monoid (Identity a)"
03:57:17 <liste> cldr: ^
03:57:19 <liste> not Cale
03:57:20 <liste> sorry
03:57:45 <Cale> Philonous: We also can run the frontend code on the backend in a static page generation mode, and switch them to the live app once it's downloaded.
03:58:11 <cldr> Hmmm. OK, let me try that. Having a tough time with these exercises. So, out of interest, how would you implement `mempty` for `Identity a`
03:58:15 <cldr> ?
03:58:28 <Philonous> Cale, Yes, I suppose could use a trick like that to make it bearable. 
03:58:51 <Philonous> I guess I'll just have to try it and see where I end up. 
03:58:52 <Cale> Philonous: I've never had any issue with the size anyway
03:59:33 <liste> cldr: there's not many ways to implement that
03:59:47 <Cale> Then again, I usually have no difficulty getting 80 Mbps.
04:00:17 <cldr> liste: :) are there any at all?
04:00:26 <Philonous> I'm on a 100mbit line, so it's not a problem for me personally, but I can't assume everyone is.
04:01:14 <liste> cldr: there is, if you have the Monoid a constraint
04:02:07 <liste> just "instance Monoid (Identity a)" is not possible
04:02:41 <cldr> I see, good clue. Thank you.
04:04:41 <padfoot_maudrer> hey 
04:05:09 <Cale> Philonous: It would be nice if it were more often reasonable to run the web application in a browser on mobile. We just compile a corresponding app for that, but perhaps if the size were a lot smaller, we could more often get away with it.
04:05:32 <padfoot_maudrer> can please someone suggest some good haskell projects for beginners ?
04:07:10 <ADG> when performing "do contents <- readFile "txt/13.txt";print . take 10 . show . sum . map read . lines $ contents"  how to specify show (Intgeer/Double/etc?)
04:07:18 <ADG> it prints the first 10 digits of the sum
04:07:55 <Cale> padfoot_maudrer: I dunno, it really depends on what sort of programs you enjoy writing.
04:08:47 <Cale> ADG: You could put the (sum . map read . lines $ contents) in parens, and then add a type annotation inside the parens, for which type you wanted the sum to be
04:09:10 <Cale> Or you could add a type signature to just the read or show
04:09:16 <Cale> (show :: Double -> String)
04:10:03 <mojjo> Cale: thanks for the code you send some half an hour ago. I'm still with the prob, I actually have something that looks ok clean (http://lpaste.net/355420)
04:11:13 <Cale> mojjo: Rather than take i pad
04:11:27 <Cale> You could write  replicate i x
04:11:49 <ADG> Cale: like this "print . take 10 . show $ ((sum . map read . lines $ contents) :: Integer)"
04:11:50 <Cale> Oh, of course, you'd have to not shadow x there :)
04:11:56 <mojjo> Cale: oh true
04:12:06 <padfoot_maudrer> Cale will game development in haskell be a good place to start ?
04:12:12 <Cale> ADG: (sum . map read . lines $ contents :: Integer)
04:12:42 <ADG> what is the preecedence of "::" then?
04:12:51 <ADG> is there any preecedence table for haskell?
04:12:58 <Cale> padfoot_maudrer: Apart from the fact that games are among the most involved and complicated things one can write, it shouldn't be too bad
04:13:18 <mojjo> Cale: well, I thought when taking from the same list twice (or more time) it might be faster.. but that's just a guess
04:13:39 <merijn> padfoot_maudrer: Not worse than in other languages. But I think games are one of the worst things to start with to learn programming, since they're *hard*
04:13:57 <merijn> padfoot_maudrer: If you already have experience writing games in other languages it should mostly be fine
04:14:01 <Cale> ADG: :: isn't an infix operator -- it extends over the entire expression to its left (as far as it can go), and the entire type to its right
04:14:16 <ADG> thanks!
04:14:29 <ADG> well is there any table then?
04:14:46 <Cale> ADG: I think the Report might have a summary table
04:14:51 <Cale> you can also ask ghci with :info
04:15:01 <Cale> since anyone can define new infix operators at any point
04:15:29 <Cale> for example if you write  :info (*)
04:15:35 <Cale> you'll see  infixl 7 *
04:16:03 <Cale> The higher the number, the more tightly it will bind to its arguments
04:16:16 <Cale> and the 'l' indicates left associativity
04:17:00 <padfoot_maudrer> Cale Since I am new I am looking for a project through which I learn the basic and core concepts of Haskell and functional Programming especially MONADS
04:18:33 <padfoot_maudrer> merijn I do not have prior experience in game development
04:19:02 <Cale> padfoot_maudrer: Perhaps something which involves a parser would be good. Pick up a library like attoparsec which defines a monad of parsers.
04:19:11 <merijn> padfoot_maudrer: Then I'd probably recommend starting with some simpler tasks
04:19:50 <Cale> I think I didn't properly appreciate the monad abstraction until I had used a parser combinator library.
04:20:51 <padfoot_maudrer> Cale Cool!! Thank you so much for the help ... any links you would suggest ?
04:22:59 <agis> Hey guys! I am trying to force a data type to hold only instances of Eq, but it seems that I am not doing it properly (ghc complains about "illegal qualified types"). I guess that this is impossible to do or I'm getting the syntax wrong
04:23:10 <agis> I am trying to do something like: data Test a = Test { myField :: (Eq a => a) }
04:23:33 <Cale> padfoot_maudrer: My problem is that all the resources I learned this stuff from are no longer around because it was over 10 years ago :)
04:23:33 <merijn> agis: Yeah, you generally don't want to do that
04:23:48 <merijn> agis: What do you hope this will accomplish?
04:24:09 <Philonous> «Eq a => a» means  the value has the type a _for all possible a_. So it's an Int, a String, a Bool etc. all at the same time
04:24:24 <Cale> n... no it doesn't
04:24:33 <merijn> Philonous: That's not right
04:24:51 <Cale> a is still the type parameter there
04:24:51 <padfoot_maudrer> Cale: Okay cool.. 
04:24:56 <Philonous> I stand corrected
04:25:08 <merijn> What he has right now isn't legal Haskell. I have a suspicion of what he *thinks* he wants, but he shouldn't want that :p
04:25:16 <agis> merijn: afterwards I use that data type in different functions that require a to Eq a
04:25:27 <Philonous> Oh, I read a forall where there was none. My bad
04:25:42 <merijn> agis: Right, but those functions will then have an "Eq a" constraint, so having that in the datatype is useless :)
04:25:42 <Rembane> \o/ GADTS \o/
04:26:10 <agis> Ok, I was trying to move it to the datatype, bad idea I guess? Hahaha
04:26:39 <merijn> agis: Well, you *can* restrict a datatype to only work with 'Eq a', however that *doesn't* let you remove the Eq a from the functions
04:26:58 <merijn> agis: So instead of reducing how much you have to type 'Eq a', you're only uselessly making your datatype less flexible
04:27:38 * hackage swish 0.9.1.8 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.9.1.8 (DouglasBurke)
04:27:57 <agis> merijn: oooh ok, now the cryptic explanation I read before makes much more sense hahaha
04:28:29 <agis> Thanks merijn, that was super useful!
04:28:44 <Cale> padfoot_maudrer: https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
04:28:56 <merijn> Golden rule: Beginners wanting to restrict datatypes almost ALWAYS want to avoid typing constraints on functions, but that's not possible :p
04:29:01 <Cale> padfoot_maudrer: That looks like a fairly decent tutorial
04:30:56 <agis> Just curious, how could I restrict the datatype in case it was part of a module?
04:31:25 <merijn> agis: The main way to restrict things is to not export the constructor
04:31:25 <agis> In case it was exposed and I wanted to make more explicit that it is going to be useless if you build something in the datatype without it being Eq
04:31:30 <padfoot_maudrer> Cale Thanks! 
04:31:42 <Cale> Oh, sorry Philonous -- it *does* implicitly forall there.
04:31:49 <Cale> That's interesting
04:31:51 <Rembane> Hey! The hackage bot is back! Good times!
04:31:57 <merijn> agis: You could have "makeFoo :: Eq a => a -> Foo a" and hiding the constrctor of Foo
04:32:31 <Cale> Philonous: I was thinking of something like  data T a = Eq a => T a
04:32:36 <agis> merijn: oooh cool. Super easy! Thanks man
04:33:26 <merijn> agis: Although it doesn't make much sense, if all functions require Eq a anyway
04:33:32 <Cale> which btw agis, will actually mean what you wanted it to mean, but requires an extension.
04:33:34 <merijn> agis: For example, have a look at Data.Set
04:33:38 <Cale> (GADTs)
04:33:51 <Cale> @let data T a = Eq a => T a
04:33:53 <lambdabot>  Defined.
04:34:07 <merijn> agis: You have "Data.Set.singleton :: a -> Set a" which doesn't require Ord
04:34:07 <Cale> @let f :: T a -> T a -> Bool; f (T x) (T y) = x == y
04:34:08 <Philonous> Cale, Then I was right purely by accident. I thought there was an explicit forall because I didn't read it properly. 
04:34:09 <lambdabot>  .L.hs:181:1: error:
04:34:09 <lambdabot>      Multiple declarations of ‘f’
04:34:09 <lambdabot>      Declared at: .L.hs:174:1
04:34:16 <Cale> @let foo :: T a -> T a -> Bool; foo (T x) (T y) = x == y
04:34:18 <lambdabot>  Defined.
04:34:21 <Cale> :t foo
04:34:22 <lambdabot> T a -> T a -> Bool
04:34:26 <Cale> ^^ no constraint!
04:34:30 <merijn> agis: Bus since things like "union :: Ord a => Set a -> Set a -> Set a" require Ord you're indirectly forced to use it anyway
04:34:48 <Cale> We can do that because the dictionary for Eq gets packed up in the data constructor T
04:34:55 <merijn> agis: The typechecker will stop people from using any "Test a" which doesn't have "Eq a" anyway :)
04:35:01 <ADG> how to make memoizable fibonacci numbers in hakell
04:35:21 <Rembane> ADG: There's a oneliner. 
04:35:30 <merijn> Is there a least common multiple function somewhere in base?
04:35:38 * hackage HFitUI 0.1.0.0 - The library for generating a graphical interface on the web  https://hackage.haskell.org/package/HFitUI-0.1.0.0 (QSpider2017)
04:35:39 <Cale> :t lcm
04:35:41 <lambdabot> Integral a => a -> a -> a
04:35:45 <Cale> It's in the Prelude
04:35:50 <merijn> Cale: \o/
04:35:55 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:35:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:36:06 <Rembane> > let f a b = b:f a+b in f 1 1 
04:36:09 <lambdabot>  error:
04:36:09 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
04:36:09 <lambdabot>      • In the second argument of ‘(:)’, namely ‘f a + b’
04:36:18 <agis> merijn: Yeah, you're right, and it seems that it will mess with other parts of what I'm doing, so I'll just stick to restricting the functions
04:36:20 <Rembane> > let f a b = b:f b a+b in f 1 1 
04:36:23 <lambdabot>  error:
04:36:23 <lambdabot>      • Occurs check: cannot construct the infinite type: a1 ~ [a1]
04:36:23 <lambdabot>      • In the second argument of ‘(:)’, namely ‘f b a + b’
04:36:27 <Rembane> Gah! 
04:36:28 <Cale> > let lucas a b = a : lucas b (a+b) in lucas 0 1
04:36:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:36:39 <Rembane> lucas is strictly better than f.
04:36:42 <merijn> oh, wait...I suppose using lcm will fuck with my results...back to the "think hard" solution, then :)
04:37:08 <ADG> how does it work? in general for a function where i need to memoize what should i do?
04:37:27 <Rembane> ADG: Do not recurse over the same things more than once.
04:37:45 <Cale> ADG: Well, in general, you might want to define a list or array or *some* datastructure containing the results
04:37:45 <Rembane> ADG: Maybe that's a quite hand wavy advice... hm...
04:37:56 <merijn> quot and div are identical for positive values, right
04:38:18 <Cale> ADG: so long as that data structure remains in scope, its entries, once computed, will remain computed
04:38:26 <ADG> ok
04:38:58 <Cale> ADG: You can even define an array whose entries recursively refer to other entries of the same array, to do dynamic-programming style stuff.
04:39:07 <ADG> nice
04:39:18 <Philonous> That only works for boxed arrays though, doesn't it?
04:39:22 <Cale> yes
04:39:41 <Cale> boxes are what enable polymorphism and laziness
04:41:01 <mniip> Cale, I might have a better solution!
04:42:28 <Cale> Oh, I should also mention data-memocombinators :)
04:42:48 <Cale> https://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html
04:42:58 <Cale> https://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/src/Data-MemoCombinators.html#bool
04:43:09 <mniip> > map peel [0..]
04:43:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:43:21 <Cale> This library defines a bunch of functions whose job it is to memoise the function they're given
04:43:38 <Cale> and which work on different domains
04:43:38 * hackage cabal2nix 2.2.1 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.2.1 (PeterSimons)
04:43:59 <maambmb> guys, haskell noob, trying to sink my teeth into some IO. I'm trying to write a function that reverses the bytes in a file: https://pastebin.com/xwV9mPWP. I'm getting a "handle closed" error. how do I force the handle to stay open until I explictly close it at the end. Thanks!
04:44:03 <Cale> If you can understand the implementation of bool, the rest is just taking that same idea to various other types
04:44:08 <Unode> How do you usually deal with "BAD signature" errors when pulling dependencies (on stack).
04:44:33 <mniip> > let lucas a b = a : lucas b (a+b) in lucas 0 1 !! 1000000
04:44:36 <lambdabot>  *Exception: stack overflow
04:44:40 <mniip> > peel 100000
04:44:41 <Cale> So what bool does, given some function g, is that it gives you back the result  cond (g True) (g False)
04:44:42 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
04:44:50 <Cale> where  cond t f True = t
04:44:51 <mniip> > peel 1000000
04:44:53 <mniip> oops
04:44:54 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
04:44:57 <Cale> and  cond t f False = f
04:45:00 <mfukar> Unode report it to the package maintainers
04:45:24 <mfukar> The stack maintainers might want to know about it too
04:45:36 <Cale> Since (g True) and (g False) are bound to variables, once those variables are evaluated, they will remain evaluated so long as they don't get garbage collected
04:45:49 <Cale> and if you hang on to the resulting function, they won't be
04:46:07 <Cale> (i.e. the parameters t and f)
04:46:55 <quchen> mniip: I was about to ask you why the first one produces a stack overflow, and then remembered talking to you about the STG yesterday. :-)
04:46:57 <Cale> list does a similar trick, but for lists, and where it applies a memoiser for the elements.
04:47:23 <mniip> quchen, my peel is a logarithmic matrix exponentiation thingy
04:47:48 <mniip> It can compute 'peel 1e7' on lambdabot before timing out
04:48:19 <Cale> and so using those two, you have  list bool :: Memo [Bool]  which is a memoiser for functions of binary strings, so at that point, any function whose argument can be turned into a binary string can be memoized.
04:49:37 <mniip> quchen, actually it's not apparent to me immediately. Does it stack overflow during evaluation of a bunch of additions that it built up
04:49:53 <quchen> Yup
04:49:56 <mniip> said additions being non-tail recursive and whatnot
04:50:13 <quchen> Make it »lucas a !b = …« and it should work
04:50:20 <quchen> (Up to Lambdabot timeouts)
04:50:54 <mniip> > let lucas a !b = a : lucas b (a+b) in lucas 0 1 !! 1000000
04:51:00 <lambdabot>  mueval-core: Time limit exceeded
04:51:11 <quchen> Tail recursion is not an issue in GHC. Function calls are not what blow up the stack, pattern matching is
04:51:22 <mniip> sure
04:51:33 <mniip> I'm talking about tail recursion in the imperative code
04:51:37 <mniip> not haskell code
04:51:37 <quchen> Ah, ok.
04:52:04 <mniip> like, to add two numbers is to enter them in sequence and then do magic on the boxes they evaluate to and then pop continuation
04:52:26 <ertes-w> maambmb: don't use hGetContents
04:53:47 <ADG> Cale: what about thi https://hastebin.com/nayamewutu.pl?
04:54:55 <mniip> ADG, I would bind the 'map ... [1..]' to a global identifier
04:55:15 <ADG> will it work?
04:55:22 <mniip> also the body of collatzLength' is slightly terrible in terms of '1 + (1 + (1 + ...'
04:55:23 <Cale> ADG: Ah, collatzLength is interesting because you almost certainly *don't* want to memoize all of the values you come across
04:55:43 <ADG> I want to, after all I am taking a maximum
04:55:44 <ertes-w> maambmb: you need to use B.hGet and B.putStr, and i recommend that you use strict ByteString in this case (mostly because there is no benefit in using the lazy one)
04:55:50 <ADG> but not all above 1000000
04:56:10 <Cale> ADG: There will be occasional large values (way above the range you're exploring)
04:56:15 <Cale> yeah
04:56:17 <mniip> was it 27 that jumped up to a few hundred k in the process?
04:56:40 <Cale> So let's do this the straightforward way by hand, defining an array
04:57:09 <ertes-w> maambmb: (i'm assuming that you want to reverse the file in constant memory)
04:57:25 <mniip> > takeWhile (!= 1) $ iterate 27 (liftA3 (`div` 2) ((+ 1) . (* 3)) even)
04:57:28 <lambdabot>  error:
04:57:28 <lambdabot>      • Variable not in scope:
04:57:28 <lambdabot>          (!=)
04:57:32 <mniip> > takeWhile (/= 1) $ iterate 27 (liftA3 (`div` 2) ((+ 1) . (* 3)) even)
04:57:35 <lambdabot>  error:
04:57:35 <lambdabot>      • No instance for (Typeable c0)
04:57:35 <lambdabot>          arising from a use of ‘show_M908406693332334994111434’
04:58:32 <mniip> > takeWhile (/= 1) $ iterate (liftA3 bool ((+ 1) . (* 3)) (`div` 2) even) 27
04:58:34 <mniip> there
04:58:35 <lambdabot>  [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,...
04:58:36 <Cale> ADG: Oh, sorry, I didn't read your program carefully -- yes that sort of thing will work
04:59:00 <Cale> ADG: but you may want to lift that map collatzLength' [1..] out
04:59:27 <Cale> (into its own definition)
04:59:56 <Cale> You're sort of relying on the compiler to do something there which isn't always an optimisation, but which it might do anyway
05:00:19 <mniip> > maximum $ [1..1000] >>= (takeWhile (/= 1) . iterate (liftA3 bool ((+ 1) . (* 3)) (`div` 2) even))
05:00:22 <lambdabot>  250504
05:00:35 <ADG_> there is something wrong because it hung up my system I had to restart
05:00:45 <mniip> ADG_, you ate all the ram
05:00:47 <mniip> probably
05:01:15 <quchen> mniip: Woah, that code was Collatz!?
05:01:28 <mniip> yes
05:01:29 <quchen> I understand it now, but wow is that a strange version
05:01:37 <quchen> Cool use of liftA3 though!
05:01:39 <mniip> well, I wrote the lambda
05:01:42 <mniip> and I was like
05:01:50 <mniip> obviously this needs some liftA3
05:02:40 <ADG_> anyone know about time & memory limiting in linux... I found `timeout` thoguh
05:02:43 <mniip> premature pointfreeization
05:03:02 <mniip> ADG_, there's ulimit, but with modern ghc you want to use the RTS heap size
05:03:20 <quchen> ADG_: https://github.com/quchen/dotfiles/blob/master/bin/util/limitmem
05:03:34 <quchen> ADG_: That file is there precisely for GHC. :-þ
05:03:42 <quchen> But GHC RTS settings are probably better.
05:04:07 <maambmb> ertes-w, correct
05:04:22 <maambmb> my approach is to read the file in chunks, going from the bottom back to the top
05:04:24 <maambmb> reversing as I go
05:05:58 <Cale> ADG_: however, the (!!) there really slows things down a whole lot
05:06:05 <Cale> xs !! n takes O(n) time
05:06:12 <mniip> ADG_, found it
05:06:20 <mniip> +RTS -M4G -RTS
05:06:21 <ADG_> thinking of using hashmap!
05:06:24 <Cale> and you end up building much longer lists tham you'd want
05:06:33 <ADG_> mniip: what does it do
05:06:36 <maambmb> it seems as if I do readChunk more than once the handle closes
05:06:40 <mniip> limits the heap to 4 gib
05:06:47 <mniip> ADG_, your approach is inherently flawed
05:07:09 <mniip> while evaluating collatz length of N you will occasionally stumble into numbers on the order of N^2
05:07:10 <lpaste> Cale pasted “collatzLength memoised with an array” at http://lpaste.net/355422
05:07:20 <ADG_> so ./bin/a.out +RTS -M4G -RTS ?
05:07:29 <ertes-w> maambmb: hGetContents basically ruins the handle for future use
05:07:43 <mniip> ADG_, yes
05:08:00 <ertes-w> maambmb: if you want to use it, you should read its docs carefully, but i suggest that you simply don't use it
05:08:00 <Cale> ^^ that is *much* faster and doesn't consume nearly so much space
05:08:08 <ADG_> "Most RTS options are disabled. Link with -rtsopts to enable them"
05:08:11 <Cale> You could do the same by limiting the length of the list
05:08:20 <ertes-w> maambmb: lazy input is a bad idea in most cases
05:08:28 <Cale> but best to save lists for jobs they're good at
05:08:46 <Cale> Lists are basically only good for jobs where you're going to be iterating over those elements in order.
05:08:48 <maambmb> ertes-w, I've read that I should use the "iteratees" library
05:08:53 <maambmb> is that where I should look?
05:08:55 <Cale> They're terrible for random access
05:08:58 <maambmb> is that appropriate for what I'm doing
05:09:22 <Cale> maambmb: Perhaps more modern would be to use pipes
05:09:26 <hpc> "lists are loops waiting to happen" ;)
05:09:30 <maambmb> okay wicked
05:09:30 <maambmb> thanks
05:09:33 <maambmb> I'll check out "pipes"
05:09:47 <Cale> maambmb: But wait, what was your actual question? :)
05:10:00 <Cale> maambmb: I based that off of the fact you mentioned iteratees
05:10:36 <maambmb> why does my pasted code not work (trying to reverse a file in constant memory by reading it backwards in chunks). Ertes-w pointed out that when I read a chunk using getContents, I'm also closing the handle, causing future reads to fail
05:10:40 <ertes-w> maambmb: we have quite a few stream processing libraries available, my favourites being machines and pipes
05:10:49 <Cale> maambmb: Oh, your actual problem is just that you're not allowed to hClose a handle which has been passed to hGetContents there.
05:11:09 <ertes-w> maambmb: i don't think you will benefit from stream processing here though, because if you read in blocks, you have shared state
05:11:24 <Cale> hGetContents will close the handle when you're done with the magic string it gives you.
05:11:44 <ADG_> Cale: you didn't use collatzLength ?
05:12:07 <Cale> ADG_: collatzLength' uses it
05:12:09 <ADG_> oh sorry you did
05:12:23 <ADG_> why not use it from cL~s
05:12:41 <Cale> ADG_: The idea is that it looks in the array if the value it's looking up has an appropriately small index
05:13:47 <Cale> ADG_: cL~s?
05:13:59 <ADG_> collatzLengths
05:14:08 <Cale> ADG_: Oh, because then you end up with an infinite loop
05:14:17 <ADG_> nice
05:14:31 <Cale> collatzLengths at the index i is defined to be collatzLength i
05:14:46 <Cale> and so collatzLength i can't just immediately try to look up the array at index i
05:14:52 <Cale> No work would get done
05:15:22 <Cale> There are other ways we could wire up the same thing though
05:17:25 <Cale> also, I could have used an otherwise guard, not sure why I didn't -- actually, I think it's just because I added that case with the guard at the top and didn't revise what I had below it
05:18:17 <mniip> also, to follow up, I did write a nonogram solver
05:18:31 <mniip> and it looks hella cool because it is slow and you can see the progress
05:19:47 <ertes-w> maambmb: practical note: it's not just easier, but also much safer to do the reversal using a separate file =)
05:20:29 <maambmb> ertes-w + Cale, thanks again for all the guidance
05:20:33 <maambmb> appreciate it
05:22:34 <Cale> I do sort of think that it would be good for hClose on a semi-closed handle to result in an exception.
05:22:38 * hackage sqlcipher 1.0.0.0 - Haskell binding to sqlcipher  https://hackage.haskell.org/package/sqlcipher-1.0.0.0 (figo)
05:23:09 <Cale> Though I'm sure there's probably someone out there who would be very upset with that change
05:24:10 <Cale> mniip: Backtracking, or does it mostly solve them the way a human might?
05:24:18 <merijn> Cale: There's people who get upset about literally every sane change to Haskell libraries :)
05:24:49 <mniip> no backtracking
05:24:55 <mniip> absolutely deterministic
05:25:54 <mniip> for every marked row, calculate all possible positions of the runs, filter those that match with the known picture, take known set or known unset elements and integrate them into the picture marking columns that were modified
05:26:01 <mniip> and vice versa
05:32:00 <lpaste> mniip pasted “nonogram solver” at http://lpaste.net/355423
05:32:08 * hackage sqlcipher 1.0.1.0 - Haskell binding to sqlcipher  https://hackage.haskell.org/package/sqlcipher-1.0.1.0 (figo)
05:32:09 <mniip> it's a bad-ish mix of lists and arrays tbqh
05:35:44 <stevenxl> Hi folks. I am trying to get my terminology straight. let's say I have the following data declaration: data Person = Person Name. Is the Person data constructor a unary data constructor?
05:40:20 <Cale> stevenxl: Yes, you could say that
05:40:27 <schzwump> can an applicative be alternatively  defined so as to apply the (a -> b) to corresponding a's, instead of applying everything to everything?
05:40:42 <schzwump> can Applicative*
05:41:01 <Philonous> When writing web APIs I keep needing related bu slightly different records, each of with needs lens and aeson instances. Is there a good solution to get rid of that boilerplate? 
05:41:03 <Cale> schzwump: Applicative itself doesn't specify anything like that
05:41:18 <schzwump> Cale: I know, let's say specifically with list
05:41:25 <Cale> schzwump: If you're talking about what happens with the list instance, yeah, see ZipList
05:41:32 <stevenxl> Cale: thanks. I was confused because I didn't see a type variable. However, `Person` (the data constructor) still has to be applied to an argument. The fact that there is no type variable in the declaration just means we know what type the argument must have.
05:43:42 <schzwump> Cale: nice thanks, are there any other sensible Zip types?
05:43:57 <Philonous> So far I've come up with template haskell to create them automatically and a WithField (name :: Symbol) (field :: *) (b :: *) gadt, but neither seemed satisfactory 
05:44:37 <Cale> schzwump: Certain sorts of trees with labelled leaves would work
05:45:18 <shlevy> The pattern synonyms docs suggest you should be able to give a type signature, but I'm getting a syntax error. Do I need some extra extension?
05:45:57 <Cale> Philonous: Why related but slightly different?
05:46:22 <Cale> You can generate lens and aeson instances using Template Haskell
05:46:45 <Cale> ah, you mentioned that
05:48:05 <schzwump> what about  ((->) r)? Are there alternative Applicative instances of that?
05:48:34 <Cale> Try to write one
05:48:41 <schzwump> :/
05:48:46 <Cale> No really :)
05:48:52 <Philonous> Well, for example say I want to handle users, so I have a User type. When querying users I want to return the time when they where created, so I have data User = User {name :: Text, created :: UTCTime}, but when creating new users it makes no sense to specify the creation time, so I need data CreateUser = CreateUser{ name :: Text }
05:48:58 <Cale> You'll be forced to come up with the existing instance
05:49:00 <schzwump> "theorems for free" or some such?
05:49:06 <Cale> If you just follow the types
05:49:49 <Cale> (r -> (a -> b)) -> (r -> a) -> r -> b
05:49:56 <phadej> the Monoidal version makes it quite obvious, mult :: (r -> a) -> (r -> b) -> r -> (a, b)
05:50:05 <Cale> So, imagine we're writing this
05:50:17 <Cale> We have f :: r -> (a -> b)
05:50:21 <Cale> and g :: r -> a
05:50:24 <Cale> and x :: r
05:50:27 <Cale> and we want b
05:50:37 <Cale> The only way to get b would be by using f
05:51:07 <phadej> @djinn (r -> (a -> b)) -> (r -> a) -> (r -> b)
05:51:07 <lambdabot> f a b c = a c (b c)
05:51:12 <Cale> So we know that our right hand side looks like  f (... :: r) (... :: a)
05:51:37 <Cale> we only have one thing of type r, and we have no way to get other things of type r
05:51:43 <Cale> namely x
05:51:51 <Cale> So we know that our right hand side looks like  f x (... :: a)
05:51:58 <mniip> about time I'd ask...
05:52:04 <mniip> what *are* free theorems
05:52:07 <Cale> and now we only have one way to get something of type a, namely g
05:52:20 <Cale> So we know that our right hand side looks like  f x (g (... :: r))
05:52:38 <Cale> and so f x (g x) is the only option
05:52:41 <mniip> what makes a theorem free, and how are they proven
05:53:04 <Cale> https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf
05:53:07 <phadej> mniip: "from a type of a polymorphic function we can derive a theorem that it satisfies"
05:53:18 <phadej> mniip: it's quite mechanical process
05:53:21 <Philonous> mniip, http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875
05:56:37 <fryguybob> merijn: You can never have enough timing data for concurrent primitives :D
05:57:39 <merijn> fryguybob: Well, this started as me trying to benchmark different channel implementations, because the benchmarks on, for example, unagi-chan are ridiculously unrealistic
05:58:14 <merijn> fryguybob: But benchmarking conccurent channel operations means I need a cheap way to synchronise threads. And before you know it, you're handwriting spinloops...
06:02:12 <Sh4rPEYE> I have a question about do-notation. I understand that I can simply call an action on the current monad, but I don't get how that action can have any influence if I don use "<-". Example: I have defined a type Stack = [Int], push that pushes something onto it and pop which pops the first value.
06:02:22 <Sh4rPEYE> stackManip :: State Stack Int
06:02:36 <Sh4rPEYE> stackManip = do
06:02:36 <Sh4rPEYE>     push 3
06:02:38 <Sh4rPEYE>     pop
06:02:38 <Sh4rPEYE>     pop
06:02:49 <merijn> Sh4rPEYE: I would generally recommend beginners avoid do notation and use explicit >> and >>= until you get comfortable with that, which avoids this kinda confusion
06:03:12 <Sh4rPEYE> How does this work? Push 3 pushes "3" on the stack, but doesn't pass it along, does it? Newline is suger for >>
06:03:14 <merijn> Sh4rPEYE: See this explanation of do notation (and how to write things without it) https://en.wikibooks.org/wiki/Haskell/do_notation
06:03:33 <Sh4rPEYE> I've read that. Unfortunately this bit doesn't seem to be explained
06:03:41 <Guest80542> stackManip = push 3 >> pop >> pop 
06:03:43 <merijn> Well, let's desugar
06:04:09 <merijn> "push 3 >> pop" -> "push 3 >>= \_ -> pop"
06:04:33 <merijn> What's push 3? presumably like "push x = modify (x:)" right?
06:04:39 <Sh4rPEYE> push :: Int -> State Stack ()
06:04:39 <Sh4rPEYE> push a = state $ \st -> ((), a : st)
06:04:45 <Sh4rPEYE> SOmething like "put"
06:04:48 <merijn> Right
06:04:52 <merijn> So
06:05:14 <merijn> "state (\st -> ((), 3 : st)) >>= \_ -> pop"
06:05:16 <merijn> What's pop?
06:05:21 <Sh4rPEYE> get
06:05:26 <mniip> phadej, explain like I'm 5 years into haskell?
06:05:28 <Sh4rPEYE> pop :: State Stack Int
06:05:28 <Sh4rPEYE> pop = state $ \(x:xs) -> (x, xs)
06:05:49 <Sh4rPEYE> Not rly get actually *
06:05:52 <merijn> "state (\st -> ((), 3 : st)) >>= \_ -> state (\(x:xs) -> (x, xs))"
06:06:07 <merijn> Let's see what >>= does
06:07:04 <Sh4rPEYE> Chain two "stateful functions" 
06:07:21 <merijn> simplified version is "State x >>= f = State $ \s -> let (a, newState) = x s in f a newState"
06:08:22 <merijn> State $ \s -> let (a, newState) = (\st -> ((), 3 : st) s in (\_ -> state (\(x:xs) -> (x, xs)) x newState"
06:08:40 <merijn> Let's simplify
06:09:00 <merijn> State $ \s -> let (a, newState) = ((), 3 : s) in (\_ -> state (\(x:xs) -> (x, xs)) x newState
06:09:03 <merijn> and again
06:09:36 <merijn> State $ \s -> let (a, newState) = ((), 3 : s) in (\(x:xs) -> (x, xs)) newState
06:10:06 <phadej> mniip: is that sarcasm or not (I'm only 5 years into haskell myself)
06:10:07 <merijn> State $ \s -> (\(x:xs) -> (x, xs)) (3:s)
06:10:22 <merijn> State $ \s -> (3, s)
06:12:20 <Guest80542> (>>=) "bind" in your case takes a State, applies a function to that State and returns that new State. And additionally could do something with an extra value passed arround
06:12:47 <kuribas`> Suppose I want to implement an interface for games.  I have a datatype "data Game state move = Game {initState :: state, validmoves :: state -> [move], doMove :: state -> move -> state}".  If I want a collection of games, do I need existential quantification to "hide" the type variables?
06:13:08 <mniip> phadej, I'm somewhere around 4
06:13:18 <Sh4rPEYE> Of course, now I see it.
06:13:54 <kuribas`> Or is there a better way?
06:14:10 <mniip> wait
06:14:21 <Sh4rPEYE> merijn: Thanks. 
06:14:24 <mniip> is the free theorem the universality condition on the profunctor end?
06:14:29 <mniip> the "forall" in the type
06:14:35 <phadej> mniip: I'd say the the paper explains it well enough; cannot really condense into IRC message
06:14:36 <mniip> (I'm only half a paragraph into the paper)
06:15:05 <[exa]> kuribas`: what about saving it recursively? like a state that contains some state identification and list of valid moves together with next states
06:15:18 <[exa]> (nothing wrong with infinity here)
06:15:34 <kuribas`> [exa]: yeah, also possible
06:16:19 <kuribas`> So that would become: data Game  = forall state move . Game {initState :: state, validmoves :: state -> [move], doMove :: state -> move -> state}
06:16:22 <[exa]> kuribas`: maybe if doMove would do something side-ish I'd go with doMove instead
06:16:53 <kuribas`> [exa]: ?
06:18:06 <kuribas`> [exa]: of course I could represent the game simply as a big tree.
06:19:22 <[exa]> side-ish as in  doMove :: state->move->IO state  or so
06:20:04 <[exa]> but if you don't need it, I'd go with pregenerated structure of states, like State = [(Move, State)]
06:20:16 <kuribas`> [exa]: right.  My idea was to keep it purely functional, but to have hooks into the UI for representing pieces, performing the actual moves, etc...
06:21:49 <whoisxy> I'm very new to haskell I'm trying to implement an expresion which alternates between 2 values each time it's evaluated so far I have managed to produce a list of alternating values however I'm at a los on how to get anything but one of the values from it. I realise I'm probably running before I can walk but its a customazation I'm eger to implement now before I've finished learning the language this is 
06:21:55 <whoisxy> my alternating list "[["hello", "bye"] !! (x `mod` 2) | x <- [0,1..]]" any ideas how I can use this as some kind of stack or any other better ways to alternate the value of an expression 
06:22:49 <kuribas`> > concat $ repeat [1, 2]
06:22:52 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
06:22:54 <whoisxy> by customization I mean to some software I'm currently running, I realize that word is out of context otherwise 
06:23:21 <kuribas`> > cycle [1, 2]
06:23:23 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
06:23:37 <whoisxy> kuribas`: no I need to acces alternating value as I said I've already got the list but if you read the first value its always the first value 
06:23:52 <Philonous> whoisxy, What you are describing is impossible. Expressions always evaluate to the same value.
06:24:01 <kuribas`> whoisxy: yes, you need to remember the state.
06:24:41 <Philonous> whoisxy, That said, you can have _actions_ that return different values
06:25:14 <pacak> "Expressions always evaluate to the same value."
06:25:16 <pacak> Hold my beer!
06:25:46 <pacak> https://github.com/tibbe/unordered-containers/issues/147 + https://ghc.haskell.org/trac/ghc/ticket/13615
06:27:32 <Philonous> Bugs and exceptions notwithstanding. You can also do some mischief with unsafePerformIO etc. of course. But I don't think this is relevant here
06:28:01 <kuribas`> nor would it work
06:28:16 <kuribas`> at least not as intended.
06:28:39 <whoisxy> kuribas`: what would be the best way to maintain the state 
06:29:08 <pacak> whoisxy: state monad, unsafePerformIO + a global variable
06:29:12 <kuribas`> whoisxy: you have many options.  Threading it, using a State monad, using IORef (if you are already inside IO).
06:29:16 <pacak> (state monad is better)
06:29:32 <kuribas`> pacak: it depends
06:29:33 <Philonous> Don't listen to pacak. Don't touch unsafeperformIO
06:29:42 <Philonous> You can use an IOref
06:30:19 <whoisxy> global vairables aren't possible atleast from what I'm imagining I coulding use this expression as a function for many diffrent functions if they all reference the same variable
06:30:44 <whoisxy> s/coulding/couldn't/
06:31:39 <kuribas`> whoisxy: is the code in IO, or is it pure?
06:32:47 <whoisxy> kuribas`: don;t know what you mean "in IO"
06:32:49 <Axman6> whoisxy: "functions" which behave differently each time they are called are fundamentally not functions - the result of a function is determined by _only_ their arguments
06:32:52 <whoisxy> *don't
06:33:40 <Axman6> this a very important concept to understand. If you need a function to return two different values you need to pass it the information to tell it which one of the two computations to perform
06:34:48 <quchen> »Procedure« is a better word for »functions with side effects«.
06:34:49 <mniip> phadej, I think I'm missing something
06:34:56 <Axman6> whoisxy: are you following a book to learn Ha?skell
06:35:00 <mniip> how is parametricity defined if not with profunctor ends?
06:36:14 <whoisxy> Axman6: sortof http://learnyouahaskell.com , however this isn;t part of the book this is to do with xmonad It has keybindings and I want to create some keybindngs which alternate
06:37:37 <Axman6> well it sounds like you want a bool that is passed around 9or better yet, a data type which represents the two states better - data RedBlue = Red | Blue)
06:37:42 <whoisxy> Axman6: having functions always return the same output given the same input is fine with me but somewhow I need to alter the input of the next evaluation
06:38:04 <Axman6> whoisxy: then you need to give the function more information.
06:38:34 <Axman6> I'm not familliar enough with how Xmonad works to know how to do that though I don't know if there's some user defined state which is passed around
06:41:25 <Axman6> I believe there's an Xmonad channel though
06:41:49 <whoisxy> Axman6: is it not somethign thats really viable to do using haskell alone
06:42:28 <Axman6> what isn't?
06:42:36 <Axman6> uh, misread
06:43:16 <Axman6> of course it's possible, but magic functions which do different things each time you use them are better known as "bugs". 
06:44:32 <whoisxy> Axman6: I don;t care if its a function or any other way I can achive the same result
06:45:13 <whoisxy> for example similar to how python has generators
06:46:25 <mmo> If anyone finds this useful: https://github.com/marcelmoosbrugger/hsudoku - An illustration of haskell-gi 's GTK bindings with a native sudoku game. It's one of my first haskell project. So feedback is appreciated.
06:47:10 <Axman6> whoisxy: I'm trying to see if I can see how to do what you're after
06:48:52 <whoisxy> Axman6: thank you 
06:49:38 * hackage snap-core 1.0.2.1 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.2.1 (GregoryCollins)
06:50:38 * hackage snap-server 1.0.2.1 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.0.2.1 (GregoryCollins)
06:52:32 <Axman6> hmm, It's not obvious how you'd do it, maybe someone in #xmonad would know, and I have to go to sleep
06:53:08 <whoisxy> Axman6: okay thanks for your help
06:53:08 * hackage openssl-streams 1.2.1.1 - OpenSSL network support for io-streams.  https://hackage.haskell.org/package/openssl-streams-1.2.1.1 (GregoryCollins)
06:58:34 <simplething> im having troubles with a simple list comprehension task summed up here: https://pastebin.com/h7kGr460
06:59:17 <simplething> having troubles with the syntax for adding another condition (and accessing the inner integers)
07:00:08 <c_wraith> man, that just reminds me why I never use list comprehensions.  I'm sure it's possible, but it's so much harder to think about than just using the map and filter functions
07:00:28 <seequ_> simplething: [[x | x <- sublist, x >= 6] | sublist <-xs, length sublist > 1]
07:00:39 <zaquest> whoisxy, seems like keybindings are monadic actions of type X () and X is a MonadIO, so you can use IORef. Or since X is also a MonadState XState (http://hackage.haskell.org/package/xmonad-0.13/docs/XMonad-Core.html#t:XState) where XState contains an extensibleState map that could be used to store something too.
07:02:19 <kuribas``> > let task xs = [sublist | sublist <- xs, length sublist > 1] in task [[1,4,76,3,23,6,3],[6],[8],[4]]
07:02:22 <lambdabot>  [[1,4,76,3,23,6,3]]
07:02:41 <seequ_> simplething: Alternatively: map . filter (>= 6) $ filter (\s -> length s > 1) $ xs
07:02:53 <Grisha> hi everyone
07:02:53 <simplething> seequ_ while your solutions works for the example input, another example input results in a wrong answer: [[1,4,76,3,23,6,3],[2,6],[2,3,6,9,8],[2,3,4]]
07:03:15 <seequ_> simplething: how so?
07:03:20 <epilys> I'm using Network.Simple.TCP's recv (up to 500KB), and I send a 320K file with netcat to the socket, but recv only returns 28.0K. Anyone know what's up? I made it recursive (recv'ing till result is Nothing) but then it just blocks
07:03:23 <c_wraith> seequ_: you did the operations backwards
07:03:28 <simplething> [[1,4,76,3,23,6,3],[2,6],[2,3,6,9,8],[2,3,4]]
07:03:28 <simplething>  results in a list containing empty lists
07:03:40 <simplething> but one of the conditions was not having lists with less than 2 elements
07:03:46 <Axman6> I think it's supposed to filter out lists which have < 2 elements after filtering out all the numbers < 6
07:03:50 <Grisha> I’m trying to de-serialize (with the help of Aeson) data X = X {x_field1 :: Int, x_field2 :: String}
07:03:52 <seequ_> Ah, right.
07:04:25 <Grisha> with defaultOptions { fieldLabelModifier = (“x_” ++)}
07:04:40 <Grisha> since in json there is no “x_” prefix
07:04:44 <Grisha> am I doing it right?
07:04:45 <whoisxy> zaquest: thanks but that I'm unsure how any of that helps me
07:04:57 <Grisha> I’m wondering what exactly fieldLabelModifier does
07:05:19 <lyxia> Grisha: fieldLabelModifier = drop 2  it goes the other way around
07:05:32 <simplething> any suggestion as to why another example input results in a wrong answer?
07:05:40 <seequ_> > filter (\s -> length s > 1) . map (filter (>= 6)) $ [[1,4,76,3,23,6,3],[2,6],[2,3,6,9,8],[2,3,4]]
07:05:42 <lambdabot>  [[76,23,6],[6,9,8]]
07:06:20 <zaquest> whoisxy, if you have figured how to create a keybinding at all it shouldn't be too difficult to do what you want using http://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Util-ExtensibleState.html if you understand what typeclasses and monads are, otherwise you really should learn about them first
07:06:20 <Grisha> lyxia: the funny part is that my fieldLabelModifier has another part, namely, converting `type` into `typ` and `instance` into `instanc` and this part seems to be working :)
07:06:22 <simplething> oh, and im supposed to use primarily list comprehension. forgot to mention that one.
07:07:14 <whoisxy> zaquest: thanks again
07:08:13 <Grisha> lyxia: is that the map from the labels in JSON to field names in Haskell or the other way around?
07:08:56 <lyxia> Grisha: from Haskell to JSON field names.
07:09:19 <Axman6> that seems backwards to me
07:09:45 <Axman6> @hoogle stripPrefix
07:09:46 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:09:46 <lambdabot> GHC.OldList stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:09:46 <lambdabot> Data.ByteString stripPrefix :: ByteString -> ByteString -> Maybe ByteString
07:09:52 <Grisha> lyxia: then I’m really wondering why my mapping “type” -> “typ” works…
07:09:57 <zaquest> whoisxy, if you don't understand typeclasses and monads yet, it might be easier to do it with IORef. show what you have in your config now, maybe i'll be able to tell something more specific.
07:10:18 <Axman6> >  Data.List.stripPrefix "x_" "x_field1"
07:10:21 <lambdabot>  Just "field1"
07:11:00 <Grisha> Axman6: so if my Haskell fields have a prefix, I’ll have to add it, when reading in json with non-prefixed fields?
07:11:13 <seequ_> > let task xs = [s | sub <- xs, let s = [x | x <- sub, x >= 6], length s > 1] in task [[1,4,76,3,23,6,3],[2,6],[2,3,6,9,8],[2,3,4]]
07:11:15 <lambdabot>  [[76,23,6],[6,9,8]]
07:11:21 <Grisha> those binary errors...
07:11:21 <seequ_> simplething: ^
07:12:21 <lyxia> Grisha: it wouldn't make sense in the docs to write "fieldLabelModifier = map toUpper" otherwise
07:12:33 <simplething> seequ_ beautiful, thank you very much.
07:13:13 <seequ_> simplething: we have different concepts of beauty :)
07:13:15 <exarkun> trying to meet the challenge in learnyouahaskell to implement fmap for Data.Map, don't really understand this error I've encountered: http://codepad.org/ydDIq8wk
07:13:22 <lyxia> Grisha: can you paste your code
07:14:22 <lyxia> exarkun: instance Ord k => Functorx (Map k)
07:14:24 <Grisha> lyxia: this one works: http://lpaste.net/355425
07:15:10 <mauke> exarkun: right now you're saying all types k are an instance of class Map, provided the type Ord k is also an instance of Functorx
07:15:24 <mauke> small problem: Map is not a class and Ord is not a type
07:15:45 <whoisxy> zaquest: as you say it's porbably best I learn more before I attempt this http://bpaste.net/show/07ba6ba84dbc
07:15:49 <Grisha> lyxia: if this works, then adding `(“x_” ++) . ` in front of myMapper in the last string should also work
07:16:17 <Grisha> where’s the flaw in my logic?
07:17:20 <Grisha> Axman6: does that look alright to you: http://lpaste.net/355425 ?
07:17:52 <exarkun> lyxia, mauke: okay, thanks, that kinda makes sense, though I guess it means I don't really understand the `instance` syntax.
07:19:59 <mauke> exarkun: instance EXTRA_CONSTRAINTS => CLASS TYPE where ...
07:20:06 <mauke> exarkun: the "EXTRA_CONSTRAINTS =>" part is optional
07:20:34 <lyxia> Grisha: what's your type and instance like
07:20:38 <mauke> exarkun: in other words, the word after "=>" or "instance" is the class name you're trying to define an instance of
07:21:38 <exarkun> mauke: okay, thanks
07:21:39 <mauke> it looks like you were trying to do 'instance CLASS EXTRA_CONSTRAINTS => TYPE' but that's not how it works
07:21:47 <lyxia> Grisha: it doesn't work here. http://lpaste.net/355426
07:21:57 <Grisha> for the piece of code above `data X = X { typ :: String}`, `instance FromJSON X where parseJSON = genericParseJSON customJSONOptions`
07:22:28 <Grisha> hm
07:23:04 <lyxia> what's the JSON value? how are you parsing it?
07:23:32 <Grisha> wait a sec
07:23:41 <Grisha> seems it’s not working here either
07:24:05 <Grisha> lyxia: sorry about that, I was convinced the code was alright
07:24:24 <Grisha> you’re right, not working at
07:24:33 <Grisha> tremendeously not working
07:25:24 <Grisha> lyxia: you were 100% correct, it’s the other way around
07:25:25 <Grisha> stupid me
07:25:41 <lyxia> Don't worry.
07:26:35 <Grisha> lyxia: thanks a lot
07:27:13 <Grisha> lyxia: the fields were all optional with Maybe, so I thought `there certainly was no field in json`
07:29:36 <Lokathor> if only the cabal file format could specify C files that things depended on, and then stack and cabal could try to download them automatically
07:32:08 * hackage rethinkdb 2.2.0.10 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.10 (codedmart)
07:35:20 <cocreature> Lokathor: if the number of C files is reasonably small, you can just bundle it in your cabal project.
07:35:41 <Lokathor> cocreature, in this case, I'm thinking about things like SDL
07:36:54 <cocreature> yeah you probably don’t want to bundle that
07:36:59 <glguy> Certainly cabal shouldn't need to know about all of the package managers and operating systems and maintain ways to install various c library packages on various operating systems
07:38:43 <Lokathor> glguy, if they knew about pacman, apt-get, and homebrew, they'd cover most cases. it'd even be helpful if there was a line that it could print when things went wrong, "the project says you probably want this C library, do you have it?"
07:39:13 <Lokathor> of course, i understand that, as the glguy and not the sdlguy, you don't see the need, since GL drivers are already on most systems by default
07:39:19 <Lokathor> but trust me this would be handy
07:39:57 <glguy> yeah, it just would make sense
07:40:01 <glguy> not*
07:40:04 <Lokathor> ha
07:40:07 <Lokathor> good fix
07:40:41 <cocreature> also I’m not sure if the number of packages between the ones that you can just bundle and the ones that cabal wouldn’t be able to install automatically (packages like LLVM) is actually that large
07:43:03 <Lokathor> well perhaps custom scripts per package might be appropriate then
07:44:59 <cocreature> at that point you are reinventing system-level package managers
07:45:24 <cocreature> system-level is a bad term. but you are implementing a full package manager for C libs
07:46:07 <Lokathor> i don't... what? It's not reinventing the package manager for, say, sdl2 to have a script that attempts to get the sdl2 files when it's installed in a local way, since there is almost always a way to attempt that on windows and linux at least (often on mac as well)
07:46:38 <cocreature> so it should just fail if you don’t have the right version in your repo?
07:47:02 <WhereIsMySpoon> Hi, quick question to make sure I’m understanding terminology correctly - is a recursively implemented length function a monoid?
07:47:14 <Lokathor> it should print a warning that it couldn't find what it was expecting and that your use of the package is a lot less likely to work
07:47:15 <cocreature> I guess I don’t really see the problem with the current state. manually having to run "apt-get install" or whatever seems pretty painless
07:47:49 <Lokathor> cocreature, because windows and mac are less pretty painless, essentially
07:48:26 <cocreature> fair enough
07:51:39 <cocreature> I guess I got confused because you said “pacman, apt-get and homebrew” would cover most cases but those seem exactly like the cases where there is only a very small benefit over just using them directly
07:51:46 <WhereIsMySpoon> Sorry, I got disconnected for some reason
07:52:21 <WhereIsMySpoon> I’ll repeat my question since I dont have a bnc :) is a recursively implemented length function (for a list, say) a monoid?
07:52:31 <lyxia> WhereIsMySpoon: no. A monoid is a set.
07:52:57 <Grisha> lyxia: functions :: a -> a form a monoid under composition though, but it’s not the case
07:53:04 <Grisha> lyxia: is it true?
07:53:23 <Lokathor> Grisha, what's mempty for (a -> a) i wonder
07:53:30 <cocreature> id
07:53:31 <Grisha> Lokathor: id?
07:53:37 <lyxia> the set of endofunctions on a given type is a monoid
07:53:48 <Lokathor> i guess id counts
07:53:50 <WhereIsMySpoon> oh, I thought a monoid was an operation on a set
07:53:51 <WhereIsMySpoon> the heck is an endofunction
07:53:51 <WhereIsMySpoon> ive just started haskell
07:53:52 <lyxia> it makes no sense to say that a single function is a monoid
07:54:01 <WhereIsMySpoon> so be gentle :P
07:54:01 <Grisha> that’s true
07:54:19 <Lokathor> WhereIsMySpoon, Monoid is an interface that some data types support which lets you mush values together
07:54:20 <Grisha> I was hoping he was meaning smth like that
07:54:23 <cocreature> a monoid is a set and a binary operation on that set
07:54:35 <cocreature> e.g. integers and +
07:54:35 <Lokathor> things like String (++), Sum (+), Product (*), and so on
07:54:49 <Grisha> a) monoid is an interface b) monot is a set
07:54:57 <Grisha> that’s why Haskell is highly popular :-)
07:55:02 <Grisha> *monoid
07:55:15 <lyxia> WhereIsMySpoon: we don't use "monoid" to refer to the operation itself
07:55:21 <Lokathor> cocreature, particularly in the case of pacman, there's a version of it bundled into msys2 with ghc, which stack can use or you can use yourself, but which is totally unobvious and that most guides do not talk about
07:55:47 <cocreature> Lokathor: oh I thought you were talking about archlinux’s pacman
07:56:06 <Cooler> why is this correct?
07:56:06 <Cooler> push :: State [a] ()
07:56:07 <Cooler> push a = State $ \as -> (() , a:as)
07:56:12 <WhereIsMySpoon> In case it wasnt clear, I was talking about monoids in a general sense, not in any particular type sense
07:56:26 <Cooler> State doesn't take any arguments
07:56:30 <Lokathor> cocreature, the pacman program that msys2 bundles is based on the pacman from archlinux, because windows is so hopeless that bolting linux on top of it was all they could do :P
07:56:37 <Grisha> lyxia: now I’ve got a bunch of data types with fields with ugly prefixes (prefices?), but reading in json works like charm
07:56:58 <WhereIsMySpoon> Grisha: prefixae, surely :P
07:57:03 <lyxia> Cooler: the argument of State is a function
07:57:04 <cocreature> Lokathor: yeah, the fact that I keep forgetting that pacman is also a thing on windows hints at how often I use windows :)
07:57:31 <Lokathor> well if haskell had a better windows story I think its adoption rate could be a lot better over time
07:57:52 <WhereIsMySpoon> so to clarify - a monoid is a combined entity of a set and an operation on that set
07:57:59 <Cooler> lyxia, i mean push = State $ \as -> (() , a:as)
07:58:03 <WhereIsMySpoon> binary operation*
07:58:14 <Cooler> push shouldn't take arguments
07:58:27 <Cooler> actually push a = State $ \as -> (() , as)
07:58:36 <Cooler> actually push = State $ \as -> (() , as)
07:58:40 <lyxia> WhereIsMySpoon: by abuse of language we often call the set alone a monoid, with the binary operation being implicit
07:58:44 <Lokathor> WhereIsMySpoon, sorta. But "set" in the purely math sense, not like "set" in the computer science data type sense
07:58:57 <WhereIsMySpoon> Lokathor: yes, thats what I meant by set :)
07:59:09 <Lokathor> :3
07:59:25 <lyxia> WhereIsMySpoon: the length function isn't a binary operation
07:59:31 <WhereIsMySpoon> re-learning mathematical notation is teh thing i look forward to least about re-learning haskell :P
08:00:34 <Grisha> WhereIsMySpoon: each time you can two things and combine it by a rule into a third thing of the same kind, you’ve got a monoid. For example, logs of, say, a http-server are not a monoid (in a useful way), but they summaries are: you can take summary of day1 and day2 and make another summary for both days
08:01:45 <Cooler> i am missing something why not       push :: State [a] ()
08:01:46 <Cooler>       push = State $ \as -> ((), as)
08:01:59 <mrkgnao> Additionally, we also want there to be a thing e that is an "identity" for the rule, i.e. applying the rule to e and anything else gives you back the latter.
08:02:11 <Lokathor> Grisha, I'd imagine that the logs are a list of entries of some sort though, and the List type is a Monoid at least
08:02:13 <Grisha> Cooler: check the definition of `data State`
08:02:40 <cocreature> Cooler: that doesn’t do anything.
08:02:41 <Cooler> where
08:02:46 <cocreature> you want push to push something
08:02:46 <Grisha> Lokathor: you’re right, of course, they are monoid in the sense of being strings of bytes
08:02:50 <WhereIsMySpoon> lyxia: whys that, or what makes an operation binary
08:02:50 <WhereIsMySpoon> right
08:02:50 <WhereIsMySpoon> makes sense
08:02:50 <WhereIsMySpoon> thanks!
08:02:55 <cocreature> so it has to take the argument that is being pushed
08:03:07 <Cooler> cocreature, i know but why can push take arguments? its just a value of type State [a] ()
08:03:21 <cocreature> Cooler: it’s not. it’s a function a -> State [a] ()
08:03:28 <Grisha> Cooler: given a (what to be pushed), push returns a state
08:03:38 <Grisha> `State` being a misnomer
08:03:57 <Cooler> cocreature, what? thats not the type signature push :: State [a] ()
08:04:00 <Grisha> it’s rather StateTransformer
08:04:05 <cocreature> Cooler: then that’s a type error :)
08:04:10 <Lokathor> Grisha, I don't mean the entries themselves are Monoids. i mean the logs as a whole are, since logs are lists of entries, essentially
08:04:16 <Cooler> cocreature, http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
08:04:35 <cocreature> Cooler: even blogposts can contain mistakes :)
08:04:59 <Grisha> Lokathor: hm, what if those entries are not like each othe? some are warnings, some are errors and some are normal events with diff structure?
08:05:12 <cocreature> Cooler: try it out. GHC will yell at you
08:05:17 <WhereIsMySpoon> Grisha: theyre still all loggable events
08:05:34 <lyxia> WhereIsMySpoon: it should be a function that maps two elements of the set to an element of the set.
08:06:40 <WhereIsMySpoon> sure, like ++ does for lists
08:07:07 <Grisha> WhereIsMySpoon: how would you compose a warning entry and an error entry into one entity?
08:08:26 <WhereIsMySpoon> i dont think it really matters
08:08:45 <WhereIsMySpoon> this is all a hypothetical situation anyway, ive gotten the point
08:12:21 <Cooler> is this correct?
08:12:21 <Cooler> put :: s -> State s ()
08:12:22 <Cooler> put s = State $ \_ -> (s,())
08:12:50 <Cooler> put s = State $ \_ -> ((), s) seems more correct
08:13:05 <mauke> depends on the definition of your State type
08:13:07 <Cooler> since its s -> (a, s)
08:17:57 <Cale> Cooler: If it's s -> (a,s), then you want the second one, yeah
08:18:16 <Cooler> Cale, isn't that the standard definition?
08:18:35 <Cale> Cooler: s -> (s,a) is a very slightly better definition, but it's not the one we inherited from mtl
08:18:51 <Cooler> what mtl standard for btw?
08:18:56 <Cooler> does*
08:19:03 <Cale> Monad transformer library
08:19:28 <Cale> The reason it's better is that (,) s is also an instance of Functor
08:19:47 <Cale> So State s decomposes into (->) s and (,) s
08:24:10 <Cooler> why doess the state from Control.Monad.State start with a small letter?
08:24:13 <Cooler> does*
08:24:20 <Cale> Because it's not a data constructor
08:24:24 <Cooler> it says variable state
08:24:40 <Cale> State s is defined as a type synonym for StateT s Identity
08:24:55 <Cale> So the only data constructor there is StateT
08:25:09 <Cale> In the past, there was a separate newtype State
08:25:41 <Cale> But at some point along the way, it got dropped in favour of just always using StateT
08:25:45 <Cooler> Cale, well theres a type State s
08:26:19 <Cooler> type State s = StateT s Data.Functor.Identity.Identity :: * -> *
08:26:20 <Cooler>         -- Defined in `Control.Monad.Trans.State.Lazy'
08:28:19 <Cooler> why can't i use State as a data constructor?
08:29:12 <pavonia> There's not data constructor State
08:29:17 <Cale> You could if it were actually defined anywhere
08:29:21 <Cale> But it's not
08:29:31 <Cale> Not in transformers or mtl anyway
08:29:36 <Cooler> State is type aliased to StateT
08:30:49 <Cooler> if its type aliased why can't i use State
08:32:04 <pavonia> It's a type alias, so you can use it as a type
08:32:33 <pavonia> But there is no new data constructor introduced here
08:33:03 <Cooler> but theres a new type constructor?
08:33:19 <Cale> Just a type synonym
08:33:31 <Cale> type State s = StateT s Identity
08:33:31 <Cooler> how do i use StateT\
08:33:58 <Cale> If you're learning and you just want to focus on the implementation of State alone, I would recommend just defining one for yourself
08:34:25 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
08:35:16 <Cale> It's just like State, except that instead of merely producing a pair of the result and final state, you produce a computation in the monad m which will compute those things
08:36:49 <Cooler> you guys use an IDE? i get tried of switching back and forth between notepad++ and ghci  in console
08:36:56 <Cooler> tired*
08:37:01 <Cale> nope
08:37:04 <Grisha> I find it confusing though that in order to appreciate StateT, you’ve got to understand what State is for and what a transformer is good for
08:37:09 <Cale> I just use a bunch of terminals and Sublime Text
08:37:35 <Cale> I also sometimes use ghcid
08:37:39 <frontendloader> haskell's really lacking in the editing tools department :(
08:38:10 <Cale> which is a simple tool that displays the current errors/warnings, and updates itself whenever a file is changed
08:38:21 <Cale> It's the main useful part of an IDE
08:38:43 <Cale> For getting around in the code, I use hasktags to generate a tags file
08:39:09 <buglebudabey> what libraries do you all use for high level GUI stuff? any FRP stuff you recommend?
08:39:20 <Cale> Reflex is pretty sweet :)
08:39:36 <dysfun> transient looks cool but i haven't had a proper play yet
08:40:22 <dysfun> can you get hot reloading in dev going with reflex?
08:41:43 <Cale> I'm not sure what hot reloading refers to -- depending which branch and compiler you're using, you'll have different options.
08:41:43 <buglebudabey> Cale, would reflex be useful for let's say a client side GUI app?
08:42:02 <Despite> Question regarding lazy evaluation. Supposed to write a program that creates a list xs of tuples (x,y,z) with x, y and z coming from infinite lists of natural numbers using list comprehension. For every x,y and z, the term ‘elem‘ xs should terminate at one point. How do i manage that?
08:43:06 <Cale> buglebudabey: Sure, so long as the UI for your app is something that you can imagine building as a web application, it'll work. You can compile with GHC to get a native code application that manipulates the DOM directly inside a webkit browser.
08:43:36 <Cale> Or compile with GHCJS to get Javascript, and run your app in a web page.
08:44:06 <Cale> You could also use Reflex but not Reflex-DOM in a more general way 
08:44:22 <Cale> with other GUI libraries or even not for GUIs at all
08:44:47 <Cale> But Reflex-DOM is the most well-developed way so far because it's how we make money
08:46:17 <buglebudabey> Cale just reflex is what I had in mind because I'm not crazy about running it on a web page, but would you say reflex dom is easier to use as a result of it being most well-developed? at the end of the day i'm looking for something to make for me and my friend to use but to have it scalable for others down the line
08:46:43 <Cale> Well, it's easier because you won't have to build your own reflex binding to some other GUI library
08:48:01 <buglebudabey> Cale ok I think that's enough to convince me to use it. I could host it on my hakyll blog you think?
08:48:04 <Cale> I'd love to see someone do reflex-gtk, but it's quite a large amount of work to start in on.
08:48:17 <Cale> Yeah, sure.
08:48:28 <buglebudabey> awesome, thank you
08:49:38 <buglebudabey> Cale it's capable of doing simple stuff like drawing shapes and stuff?
08:51:17 <Cale> buglebudabey: You could use SVG for that -- I've dynamically constructed SVG with Reflex -- you have to be aware of the element namespaces, but otherwise it's doable.
08:51:43 <buglebudabey> alright, thanks
08:52:43 <Cale> If drawing simple shapes is the main thing you want to do, you might also have a look at gloss (and there's also reflex-gloss)
08:52:48 <zq> i'm getting an error from invoking `cabal install --deps-only`: 'ghc: could not execute: /usr/bin/gcc' why is ghc looking gcc, and what's the flag to tell it the right path?
08:55:10 <lyxia> --with-gcc=mygcc
08:55:51 <lyxia> Does one of your dependencies have some C stuff
08:56:54 <zq> lyxia: that's not ghc flag, or at least not listed in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html
08:56:57 <clamchowder> has anyone looked into the pandoc code? I have a question about it: What does Text.Pandoc.Parsing do, compared to the code of the specific reader / writers?
08:57:09 <zq> the problem is ghc, not cabal
08:57:18 <zq> i've already set the gcc location in .cabal/config
08:57:45 <zq> i've tried --ghc-options='-pgmc alternate-gcc' but that has no effect
08:58:32 <clamchowder> Which one converts a file into an AST, Text.Pandoc.Parsing, or a specific reader, say Text.Pandoc.Reader.MediaWiki?
08:58:32 <Cale> zq: Which platform?
08:58:41 <zq> Cale: linux
08:58:50 <zq> why does that even matter
08:59:03 <zq> x86_64-unknown-linux-gnu
08:59:04 <Cale> Just curious, I've never seen that.
08:59:13 <zq> /usr/local/bin/ghc -c /tmp/1804289383846930886.c -o /tmp/16816927771714636915.o -pgmc clang -pgml clang -fllvm
08:59:16 <zq> ghc: could not execute: /usr/bin/gcc
08:59:16 <zq> from cabal --verbose
08:59:25 <Cale> It can matter, because, e.g. OS X is rather weird about where it puts gcc
08:59:49 <zq> the problem is ghc not obeying the flag, which implies either the wrong flag or idk
09:01:30 <lyxia> zq: have you tried -pgmP clang too
09:01:35 <Cale> ah
09:01:45 <Cale> ghc --print-libdir
09:01:56 <Cale> and then go to that directory and have a look at the file called "settings"
09:02:14 <Cale> There will be a line in there with the path to the C compiler
09:03:58 <zq> Cale: that worked. thank you!
09:07:24 <Cooler> i get a variable not in scope error
09:07:35 <Cooler> State $ \s0 -> (f a, s2) where
09:07:35 <Cooler>                                                          (f, s1) = statef1 s0
09:07:35 <Cooler>                                                          (a, s2) = statef2 s1
09:08:18 <Cooler> it says s0 isn't in scope
09:08:49 <monochrom> Use let. where is not for this.
09:10:41 <Cooler> monochrom, well that works
09:10:44 <Cooler> but why
09:10:47 <monochrom> In "f x = expr where y=z" the where clause is outside the expr. The where clause cannot see local vars inside expr. The where clause can only see f and x.
09:11:12 <monochrom> The where clause "belongs" to "f x =". It does not belong to expr.
09:11:34 <monochrom> Despite what Landin would love to do.
09:18:16 <Cale> Yeah, the difference between where and let is that where is actually part of the syntax of pattern matching constructs -- it exists to scope over multiple guards
09:20:49 <Despite> Hello everyone, problem: Im having a list xs of all triples (x,y,z), where x y and z are natural numbers. So basically an infinite list. My task is to be able to calculate with this list, so that (a,b,c) elem xs terminates for any a, b and c. How do it do that? right now im having: https://pastebin.com/9snzL8xH which isnt terminating, nor is it sav
09:20:49 <Despite> ing it to xs. Any volunteers?
09:22:03 <Despite> I know it has something to do with lazy evaluation, but i cant make a connection quite yet.
09:22:30 <monochrom> Will not terminate in the False case.
09:22:46 <monochrom> Will only be True or nontermination.
09:23:57 <Despite> i know, but the conditions are that both (x,y,z) are natural numbers, and the request (a,b,c) are natural numbers. So it has to terminate at one point, depending how high the request is
09:24:37 <Despite> My task is to basically create a list of (x,y,z) that allows the termination to happen
09:24:38 <monochrom> Oh! Right, I misread, what I said was not the reason.
09:24:57 <LKoen> I think your list is correct
09:25:27 <LKoen> maybe it "doesn't terminate" because you typed it in somewhere where the compiler thought you might want it to be displayed
09:25:35 <LKoen> which won't work well if it's infinite
09:26:08 <monochrom> > [(x,y,z) | x<-[0..2], y<-[0..2], z<-[0..2]]
09:26:11 <lambdabot>  [(0,0,0),(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1,...
09:26:14 <Despite> if i try to check if (a,b,c) is element of this list xs, its never terminating. So my solution, unforunately, is not correct. Seems to easy, too.
09:26:14 <Cale> That list is incorrect, because it'll never get past x = 0 and y = 0
09:26:30 <Cale> You want to diagonalise in some fashion
09:26:33 <LKoen> ohhhhhh right, I get the question now
09:26:49 <Cale> You might do this by iterating over the possible sums x + y + z
09:27:04 <monochrom> Yeah, you will be stuck in (0,0,0), (0,0,1), (0,0,2) ... (0,0,n), (0,0,n+1).... this part does not end so there is no (0,1,0) to speak of.
09:27:07 <Cale> and then for each possible x from 0 up to the sum, iterate over the possible sums y + z
09:27:17 <monochrom> Look up "dovetailing" for how to do this right.
09:27:31 <EvanR> monochrom: non standard numbers ftw
09:27:33 <monochrom> It's precisely why "dovetailing" is a thing.
09:27:57 <monochrom> nonstandard numbers are irrelevant.
09:28:13 <Cale> > [(x,y,z) | s <- [0..], x <- [0..s], s' <- [0..s-x], y <- [0..s'], let z = s' - y]
09:28:16 <lambdabot>  [(0,0,0),(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,0,0),(0,0,1),(0,1,0),(0,0,2),(0,...
09:28:19 <Cale> oops
09:29:34 <Cale> > [(x,y,z) | s <- [0..], x <- [0..s], y <- [0..s-x], let z = s' - y]
09:29:37 <lambdabot>  error:
09:29:37 <lambdabot>      • Variable not in scope: s'
09:29:37 <lambdabot>      • Perhaps you meant one of these:
09:29:49 <Cale> > [(x,y,z) | s <- [0..], x <- [0..s], y <- [0..s-x], let z = s - x - y]
09:29:51 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,0,2),(0,1,1),(0,2,0),(1,0,1),(1,1,0),(2,...
09:29:51 <Cale> there
09:30:21 <Cale> don't need to enumerate sums of the last two obviously -- we already know it's got to be s - x
09:32:21 <Cale> So that's a relatively fair way to do it
09:32:26 <Cale> There are also less fair ways
09:32:59 <Cale> "fairness" being measured in terms of how rapidly we explore new values for each of the components
09:33:27 <Cale> We can define an interleaving operator on lists
09:34:03 <Cale> @let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs)
09:34:05 <lambdabot>  Defined.
09:34:54 <Despite> very interesting. Ill look into that, thank you!
09:35:50 <Cale> > foldr (/\/) [] [[(x,y) | y <- [0..]] | x <- [0..]]
09:35:53 <lambdabot>  [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0,...
09:36:16 <Cale> Note that every other element of this list has 0 as its first component
09:36:32 <Cale> and then every other element of those which remain have 1 as their first component
09:36:34 <Cale> and so on
09:36:44 <Cale> and of course, we can extend this once more
09:37:57 <LKoen> if you define a function f such that f n = (power of 2 in prime factorization of n, n / 2^x), then this should work:      [(x, y, z) | n <- [1..], let (x, n') = f n, let n'' = (n'-1)/2, let (y, n''') = f n'', let z = (n'''-1)/2 ]
09:38:15 <Cale> > foldr (/\/) [] . foldr (/\/) [] $ [[[(x,y,z) | z <- [0..]] | y <- [0..]] | x <- [0..]]
09:38:17 <lambdabot>  [(0,0,0),(1,0,0),(0,0,1),(0,1,0),(0,0,2),(1,0,1),(0,0,3),(2,0,0),(0,0,4),(1,...
09:38:50 <LKoen> it uses the bijection NxN -> N\{0}   (i, j) -> 2^i (2j+1)
09:40:28 <LKoen> hmm, actually it doesn't work, because n'' can be zero
09:41:52 <LKoen> this can be fixed by defining n'' = (n'-1)/2+1 instead
09:42:15 <LKoen> I don't know why anyone would want to use this method, though
09:48:10 <monochrom> A bijection is preferrable because it has no redundancy.
09:48:31 <EvanR> is there any use in making a function field strict
09:49:38 <monochrom> Yes if the function term is "if blah blah then (\x -> x+1) else (\x -> x * 4)"
09:50:37 <monochrom> where blah blah may be "insert 42 into my set. does my set have more than 20000 elements now?"
09:50:52 <EvanR> mkay
10:07:14 <dkk> hello all...
10:11:38 * hackage HSet 0.0.1 - Faux heterogeneous sets  https://hackage.haskell.org/package/HSet-0.0.1 (athanclark)
10:12:18 <dkk_> hello all...
10:12:46 <dkk_> I have a question that I am working on a project to do form filling to a particular website programatically is there a way to use haskell for it 
10:13:17 <orzo> As a default rule of thumb, is it better to put a record into an ioref or is it better to put an ioref as a field of a record?
10:13:38 <c_wraith> orzo, it's better to do whichever means the right thing for your use case. 
10:14:44 <orzo> well what are the tradeoffs
10:15:39 <davean> Well, for what what memory gets dirtied on a change, and what you get a reference to
10:16:01 <nshepperd> an ioref containing a record lets you have atomic updates of the whole record, compared to a record containing several iorefs
10:16:49 <c_wraith> I don't really even see "tradeoffs". they mean sufficiently different things that it's rare they could even be used interchangeably
10:17:05 <davean> what c_wraith said
10:18:17 <orzo> I've an object that will alternate between two configurations, two fields swapped, very frequently.  Less frequently.
10:18:28 <orzo> er s/less frequently//
10:19:34 <orzo> i was figuring i could put a Bool in an IORef to maintain the state, that would require some if branching to actually simulate the swapped fields
10:19:48 <c_wraith> orzo, should someone holding a record value see those changes, or should they see a consistent view? 
10:19:49 <orzo> or I could just put the fields directly in the record and do an atomic update 
10:20:17 <orzo> i dont understand your question
10:21:46 <c_wraith> say I have one of these records. is it correct for me to see changes made to them from elsewhere, or correct for me to always see the same thing? 
10:21:56 <dkk_> seems like no one has seen my question
10:22:08 <dkk_> please help me with
10:22:29 <dkk_> I have a question that I am working on a project to do form filling to a particular website programatically is there a way to use haskell for it
10:23:15 <orzo> c_wraith, this isn't really a multithreaded application.  Object will alternate states and code will see the current state
10:23:38 * hackage one-liner 0.9 - Constraint-based generics  https://hackage.haskell.org/package/one-liner-0.9 (SjoerdVisscher)
10:23:41 * hackage hsx2hs 0.14.1 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.14.1 (JeremyShaw)
10:23:43 <Taneb> orzo, do you need an IORef at all
10:23:47 <orzo> i'm using mutable data because i'm intereacting with the gpu anyway
10:23:58 <c_wraith> orzo, it doesn't need multiple threads. it just needs to be shared at all. 
10:24:16 <Taneb> I find IORefs tend to make things trickier than they need to be 95% of the time
10:24:44 <orzo> i don't need an ioref, but considering all the closely related global state, it seems odd to program this without it
10:27:07 <orzo> would you go out of your way to avoid mutable state when you are maintaining something synced with GL library and GPU mutable state?
10:27:14 <dkk_> hello if someone listening to my voice ...
10:27:39 <orzo> i mean, is there a good reason for me to avoid a ref here?
10:29:35 <EvanR> orzo: no reason to avoid IORefs if youre in IO
10:29:54 <mivael> dkk_, for me, your question seems to be too broad to provide you with a useful answer
10:30:06 <EvanR> though some "state" forms are simpler without them, to me
10:30:27 <EvanR> in other cases, (in IO), its like the obvious choice
10:30:49 <Cale> dkk_: By "form filling" do you mean making POST requests?
10:31:40 <robkennedy> dkk_: I use wreq for posting, it's good, but the API is lower level than I pythons request
10:34:23 <dkk> hello suffered from a connection error
10:34:32 <dkk> cale : yes
10:34:42 <robkennedy> Especially if you're doing file upload with additional parameters, you'll probably have to experiment a bit. BOS also made its interface fairly lens dependently​, but his tutorial on serpentine is nice 
10:35:18 <dkk> if someone told something then please repeat so that i could read
10:35:42 <robkennedy> I said you should look at the wreq library
10:36:34 <dkk> robkennedy: did you told to me ...
10:37:25 <robkennedy> Yeah...
10:38:26 <dkk> robkennedy: do you have any prior experience with this
10:41:04 <dkk> help
10:42:04 <dkk> If some here has used Haskell for web-form filling automation task for a given website
10:43:00 <Cale> wreq is probably a bit easier, but I've used http-conduit directly to make POST requests before
10:43:07 <Cale> and that wasn't so bad either
10:43:30 <EvanR> dkk is talking about selenium type stuff
10:44:41 <dkk> EvanR: yes something like that
10:45:31 <dkk> Cale : can you help me in that a little please....
10:46:47 <Cale> dkk: If you're talking about simulating keypresses in a running browser or something, I have no experience with that
10:47:37 <dkk> Cale : I just want to do posting  in a given website 
10:49:29 <Cale> There are examples of how to form POST requests here. https://hackage.haskell.org/package/wreq-0.5.0.1/docs/Network-Wreq.html
10:49:56 <dkk> Cale: ok
10:50:40 <Cale> You probably will want to use the version which looks like:  post "http://httpbin.org/post" ["num" := 31337, "str" := "foo"]
10:51:09 <Cale> to post urlencoded form data.
10:52:50 <dkk> Cale: let me see 
10:54:11 <dkk> Cale: can we do a private chat please...
10:55:11 <Cale> sorry, I'm busy with work
10:58:19 <lyxia> yay hackagebot is back
10:58:22 <dkk> hey
10:59:11 <dkk> Cale: do you have 2 mins plzz
11:01:24 <dkk> Cale: I want just a guidance to how to do this job with Haskell 
11:01:30 <EvanR> dkk: there is a package on hackage for that page automation stuff, if you jsut search for it
11:01:44 <EvanR> beyond that, you just need to learn haskell
11:02:55 <dkk> EvanR: I am old with haskell 2 years  and Haskell is my fav lang , my mother programming lang... 
11:03:01 <Cale> dkk: I linked you a bunch of examples... you're going to have to be more specific what you're having trouble with
11:03:04 <EvanR> well then this shouldnt be a big deal
11:03:32 <dkk> EvanR: I would do it any how just want an initial kickstart
11:03:43 <EvanR> i think thats too much to ask for IRC
11:04:09 <EvanR> especially with this topic, which is often used for exploiting/abusing web pages
11:04:12 <dkk> Cale: but where are the examples
11:04:50 <dkk> EvanR: no EvanR I am not going to use it for ... actually its for promotion 
11:12:51 <Cale> dkk: In the documentation I linked... https://hackage.haskell.org/package/wreq-0.5.0.1/docs/Network-Wreq.html
11:13:08 <Cale> all the boxes with a blue background
11:13:14 <dkk> Cale: ohk that's one..
11:13:40 <dkk> Cale: sorry I thought you are talking about something else
11:15:18 <dkk> Thanks for all your support ... that's great about Haskell community
11:16:39 <dkk> byee
11:43:42 <duck_08> hello, anyone there for a quick question ?
11:44:30 <phadej> duck_08: just ask
11:46:30 <duck_08> phadej can you help me understand catamorphism and anamorphism ?
11:47:27 <phadej> that's an intersting topic
11:47:52 <phadej> at which point you get lost?
11:49:05 <monochrom> That is not a quick question.
12:08:12 <c_wraith> the Greek roots are actually somewhat informative. ana -> up, cata -> down. an anamorphism builds something up, a catamorphism tears something down. 
12:08:48 <sbrg> yeah I just read that the other day as well. 
12:08:55 <sbrg> hadn't thought about it like that
12:18:38 * hackage statistics 0.14.0.0 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.14.0.0 (AlexeyKhudyakov)
12:19:41 <Tuplanolla> Whoa, a new Hackage bot!
12:19:56 <EvanR> level up
12:20:41 <Tuplanolla> Does this one collect similar updates together?
12:21:21 <t7> No instance for (Traversable Set.Set) really?
12:21:57 <glguy> t7: such an instance can't be written, so it doesn't exist
12:22:20 <t7> theres a low view function or whatever
12:22:54 <glguy> I don't know what that means
12:23:53 <t7> glguy: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Set.html#v:minView
12:24:12 <t7> wait
12:24:13 <Tuplanolla> It's because of the `Ord`, t7.
12:24:29 <Tuplanolla> Can't have `Functor`, so can't have `Traversable` either.
12:25:20 <t7> what about Set.map ?
12:25:31 <glguy> That has the wrong type to be an implementation of fmap
12:26:26 <t7> oh wait
12:27:04 <t7> no wait i dont get why Set cant be a functor
12:27:19 <dmwit> fmap :: (a -> b) -> Set a -> Set b
12:27:23 <glguy> You'd need to be able to write a function with type:  (a -> b) -> Set a -> Set b
12:27:32 <dmwit> But `Set.map :: Ord b => (a -> b) -> Set a -> Set b`.
12:27:40 <t7> aha!
12:29:14 <EvanR> is there a standard name for strict pair
12:29:33 <Tuplanolla> Mathematicians get away with it, because everything they work with has equality and performance doesn't matter, t7.
12:30:46 <np356> I'm writing a parsar for a DSL, and I have the following structure for describing the syntax tree: http://lpaste.net/355442. Every node (except a translation unit) has a parent SyntaxNode that is its first argument to the constructor. Is there a more elegant way to write this?
12:31:46 <glguy> The more elegant way would be to not have that SyntaxNode field
12:31:57 <np356> how?
12:32:17 <EvanR> data Pair a b = !a :!: !b ?
12:32:29 <np356> what does this syntax mean?
12:32:32 <glguy> np356: Remove the "SyntaxNode" field from each constructor that has one
12:32:52 <glguy> np356: EvanR's comment wasn't related to your problem
12:33:42 <np356> http://lpaste.net/355443
12:33:52 <np356> now I lost information about the parent node
12:33:57 <np356> right?
12:34:04 <glguy> Yeah, this is how it should look
12:34:21 <glguy> If you need a notion of parent, you can track that while processing the value
12:34:30 <np356> but now gien a syntax node I can't navigate to its parent
12:34:47 <glguy> That's something you'd track while processing such a node
12:34:56 <np356> hmm...
12:34:57 <dmwit> EvanR: Yes, the strict package offers one, I think.
12:35:07 <glguy> Tracking the parent in the node means that updating the structure will be a disaster
12:35:10 <dmwit> EvanR: And of course there's unboxed pairs as well, `(# a, b #)`.
12:35:23 <glguy> np356: it's extremely uncommon to do that
12:35:33 <np356> glguy: the structure is immutable, its the parsed script
12:35:43 <glguy> np356: OK
12:36:13 <dmwit> np356: Perhaps you are looking for the concept of zippers.
12:36:32 <dmwit> np356: Normally the type you care about navigating around in and the type you use for tracking where you are/actually doing navigation are separated.
12:38:13 <dmwit> np356: Have you started using this structure yet? What is motivating a need for parent pointers?
12:38:26 <np356> dmwit: thats an excellent point.
12:38:30 <glguy> If TranslationUnit was only supposed to occur at the top-level, it probably shouldn't be in the SyntaxNode type
12:38:47 <paolino> can someone write an example on using http://hackage.haskell.org/package/hetero-map-0.21/docs/HeteroMap-Map.html ?
12:38:54 <np356> not yet actually, i just think that I would need it at some point. Right. I'll wait until I actully need it
12:39:06 <sbrg> I wrote a haskell implementation of a tree data-structure for a class, which traditionally uses parent pointers. I solved it using zippers and some knot-tying
12:39:13 <EvanR> "you might not need it"
12:39:25 <jle`> paolino: fair warning, it looks pretty out of date
12:39:27 <Taneb> sbrg, could I see that?
12:39:37 <jle`> paolino: the techniques it uses are ancient
12:39:40 <jle`> try dependent-map instead
12:39:47 <jle`> or even better, don't use heterogeneous maps
12:39:48 <jle`> hehe
12:40:16 <sbrg> Taneb: sure, I guess. it's called a scapegoat tree. I'm not sure my implementation (which is unfinished due to various reason I cba going into) meets all the performance requirements etc, and it's not fully tested. 
12:40:24 <paolino> mh I want the constraint In, which seems dependent-map is missing
12:40:47 <paolino> is it ?
12:41:09 <paolino> let me recheck :-)
12:41:54 <dmwit> paolino: The obvious example seems like it would be `newKey $ \k -> lookup k (singleton k 3)` or so.
12:42:13 <dmwit> paolino: That said, I haven't tried it in ghci so I could be wrong.
12:42:14 <cocreature> paolino: dependent-map doesn’t track what’s in the map at the typelevel so that constraint is not possible
12:43:08 <paolino> I wanted to use HList , but it's so complex
12:43:33 <cocreature> paolino: HList as in the HList package or as in the general idea of heterogenous lists?
12:43:47 <paolino> in the package yes
12:44:07 <paolino> just not to rewrite the wheel
12:44:47 <cocreature> sadly I think reinventing the wheel might be your best solution
12:44:48 <dmwit> Are you suuuuure you wanted to use HList? =P
12:45:26 <dysfun> i'm still not convinced hlist the library actually solves a problem
12:45:47 <dmwit> (You don't have to defend yourself. But if you feel like it, you could describe what makes you think you want HList or similar, and folks here may be able to help you design things in a way that avoids heterogeneity.)
12:45:50 <bennofs> it certainly creates some problems
12:46:05 <paolino> dmwit, I want to express the presence of an aspect in a context, for modularity
12:46:19 <dmwit> Okay. Can you unpack that jargon a bit for us?
12:47:36 <cocreature> if you ignore all the record stuff, vinyl is actually a pretty usable implementation of hlists but as long as you need all of it, it’s often still easier to implement it yourself
12:47:44 <paolino> write functions like In MyAspect Context => a -> Reader Context b
12:48:19 <paolino> write functions like In MyAspect context => a -> Reader context b
12:49:03 <ZuluKing> if I have a function Transform :: x -> y and I need to make a list of y using a list of x, how can I do it using map?
12:49:19 <bennofs> paolino: would it be feasible to create a new type class and manually write an instance for each aspect / context pair?
12:49:24 <cocreature> ZuluKing: map transform
12:49:31 <paolino> dmwit so I can define context structure later
12:49:45 <bennofs> paolino: like: HasMyAspect ctx => a -> Reader ctx b
12:49:48 <dmwit> paolino: Perhaps you are looking for `lens`, and especially the zoomy stuff therein.
12:50:01 <dmwit> Or just `asks`...
12:50:30 <dmwit> :t asks
12:50:32 <lambdabot> MonadReader r m => (r -> a) -> m a
12:50:40 <ZuluKing> cocreature it wouldn't give a list of y, would it?
12:51:00 <dmwit> ?let data X; data Y
12:51:01 <lambdabot>  Defined.
12:51:06 <cocreature> ZuluKing: why not?
12:51:08 <cocreature> :t map
12:51:10 <lambdabot> (a -> b) -> [a] -> [b]
12:51:12 <dmwit> :t let transform :: X -> Y; transform = undefined in map transform
12:51:14 <lambdabot> [X] -> [Y]
12:51:31 <cocreature> if you provide a function a -> b and a list of as you get a list of bs
12:51:40 <cocreature> replace a by x and b by y and you have what you want
12:54:12 <ZuluKing> cocreature, if I understand correctly, if z :: [y] and let z = map Transform [x,x,...x] is correct?
12:54:35 <paolino> bennofs, it doesn't seem very different from HList
12:55:04 <paolino> but it introduces new classes and instances
12:55:07 <dmwit> paolino: (I admit that I still don't really understand what you're trying to do.)
12:55:23 <cocreature> ZuluKing: I think it would be helpful if you provide some concrete example of what you are trying to do
12:55:34 <dmwit> ZuluKing: That seems plausible. Have you done some experiment that makes you believe that is incorrect?
12:55:35 <cocreature> you might be confusing types and values here
12:57:41 <bennofs> paolino: it is a lot less complex, gives better type errors and doesn't require tons of ghc extensions
12:58:34 <paolino> dmwit I'm writing some functions and I know they are going to ask from a context. I want them to express what they want to be be in form of a constraint on the context
13:00:53 <paolino> I see I can pass the lenses in the context, together with it
13:00:58 <dmwit> To me, that sounds like a proposal for how to achieve your goals, not a goal in itself.
13:01:07 <lpaste> ZuluKing pasted “FooBaz” at http://lpaste.net/355444
13:01:35 <ZuluKing> cocreature, dmwit, can you look?
13:01:48 <dmwit> ZuluKing: I looked. Do you have a question associated with the code?
13:01:53 <dmwit> ?let data A
13:01:55 <lambdabot>  Defined.
13:02:30 <ZuluKing> someFunc needs a list, map Transform won't build one
13:02:35 <dmwit> ?let someFunc :: [Y] -> A; someFunc = undefined; transform :: X -> Y; transform = undefined; list1 :: [X]; list1 = undefined
13:02:37 <lambdabot>  Defined.
13:02:43 <dmwit> :t someFunc $ map transform list1
13:02:44 <lambdabot> error:
13:02:45 <lambdabot>     Ambiguous occurrence ‘transform’
13:02:45 <lambdabot>     It could refer to either ‘Lens.transform’,
13:02:50 <dmwit> oh, bugger
13:02:52 <cocreature> ZuluKing: it definitely will
13:03:00 <dmwit> ?let transformZuluKing :: X -> Y; transformZuluKing = undefined
13:03:02 <lambdabot>  Defined.
13:03:07 <dmwit> :t someFunc $ map transformZuluKing list1
13:03:09 <lambdabot> A
13:03:22 <dmwit> ZuluKing: GHC appears to disagree with you. Can you say why you believe what you just asserted?
13:03:25 <dmwit> ?undefine
13:03:25 <lambdabot> Undefined.
13:04:19 <ZuluKing> sorry guys, sleep deprived.
13:04:29 <ZuluKing> and confused
13:04:36 <ZuluKing> thanks a lot
13:34:57 <Lambda_> Hey
14:00:49 <Lazersmoke> Right now, I have a typeclass like `class C a where {perInstance :: String, perObject :: a -> Int}`, which has both a property that is the same across every object of the same type and a property that differs between individual objects. I want to model this without using a typeclass like this to avoid using existentials. How can I encode `perInstance`?
14:01:37 <Lazersmoke> In other words, I want: `data C = MkC {perInstance :: {- What goes here? -}, perObject :: Int}`
14:01:38 <jle`> the traditional way is to have it take a dummy parameter
14:01:53 <Lazersmoke> right now I am pulling it out with type applications
14:02:03 <Lazersmoke> perInstance @SomeTypeThatIsAnInstance
14:02:08 * hackage safecopy 0.9.3.2 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.3.2 (JeremyShaw)
14:02:09 <jle`> yeah, that's the newfangled way
14:02:11 <monochrom> perInstance :: p a -> String
14:03:00 <monochrom> A user can then request: perInstance ([] :: [X]) or perInstance (Nothing :: Maybe X) or perInstance (Proxy :: Proxy X).
14:03:05 <monochrom> (See Data.Proxy)
14:03:13 <jle`> or even perInstance @SomeType Proxy
14:03:48 <jle`> or perInstance (Proxy @SomeType)
14:04:51 <Lazersmoke> I don't want to use this method, though, because it requires me to use existentials: `[forall a. C a => a]` or whatever if I want a list of them
14:05:04 <jle`> how does it require you to use existentials
14:05:10 <Lazersmoke> or is this a valid use case for existentials?
14:05:26 <jle`> existentials here is an unrelated concept
14:05:30 <jle`> to an orthogonal concept
14:05:36 <jle`> why do you think you need them?
14:05:50 <jle`> *orthogonal problem
14:05:52 <monochrom> existential is caused by wanting a heterogeneous list, not caused by method type sigs.
14:06:26 <lyxia> Can you reorder the variables in a MultiParamTypeClass, such that if you have some    class Foo a b where foo :: stuff   and foo @B @A would select the Foo B A instance? I know you can write a separate foo', but I'm wondering whether you can somehow put an explicit forall in the Foo class declaration.
14:06:28 <jle`> why do you think you need a [forall a. C a => a] ?  that's the real problem, not the typeclass
14:06:32 <monochrom> For example if your class had no method at all, your heterogeneous list would still incur the same existential.
14:06:57 <Lazersmoke> what I'm really modeling here is an Item type. I need to store Items in collections, lists, etc
14:07:10 <jle`> is Item a type?
14:07:11 <lyxia> uh, actually I want foo @B @A to select Foo A B
14:07:20 <jle`> then you can just have [Item] ...
14:07:25 <jle`> no existentials required
14:07:31 <Lazersmoke> no Item is the typeclass :P
14:07:34 <Lazersmoke> that's the problem
14:07:41 <Lazersmoke> perInstance = itemId
14:07:48 <Lazersmoke> perObject = objectData
14:07:49 <monochrom> Consider not using a type class at all.
14:07:52 <jle`> so what do you want to do
14:08:20 <Lazersmoke> I want to enforce the same typing garuntees from the typeclasses `perInstance` in a normal data type
14:08:38 <monochrom> With 99.9999% probability it is wrong to translate [OOP class, OOP object] to [Haskell class, Haskell type].
14:09:58 <Lazersmoke> yeah I'm trying to do [OOP class, OOP object] to [Haskell type, value with that Haskell type]
14:10:15 <jle`> then why do you need a typeclass?
14:10:21 <monochrom> So no class necessary.
14:10:47 <monochrom> Delete the class now.
14:11:35 <Lazersmoke> how I currently have it is that for example a stick always has itemId 4, but sometimes has different data associated with it
14:11:49 <Lazersmoke> so I have the extra data be a function `Stick -> ExtraData`
14:12:12 <Lazersmoke> and `itemId :: forall i. Item i => Int`
14:13:15 <Lazersmoke> but itemId with normal datatypes would be `itemId :: Item -> Int`, as well as `extraData :: Item -> ExtraData`
14:13:52 <Lazersmoke> so now my value represents a specific stick instead of a stick in general
14:15:34 <Lazersmoke> oh I just realized I can't do that properly because of the lack of dependent types :(
14:15:48 <Lazersmoke> ideally I would move itemId to a type parameter
14:22:36 <jle`> Lazersmoke: what would you want to do with a container of general items, anyway
14:22:48 <jle`> the only thing you could do with it is storeitem id's
14:22:53 <jle`> so why not just have [Int]s
14:23:07 <jle`> instead of [exists a. C a => a]
14:23:23 <jle`> (btw, there are no actual values of forall a. C a => a)
14:23:53 <Lazersmoke> Item has other methods as well, like `onClick :: (Member Stuff r, Member OtherThing r, ...) => i -> BlockCoord -> Eff r ()`
14:24:37 <monochrom> Time for shameless plug.
14:24:41 <monochrom> @quote monochrom river
14:24:41 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
14:24:41 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
14:24:42 <lambdabot> show the_boolean, show the_character, show the_integer]
14:25:27 <monochrom> Existential is also fine. But you remember it is caused by you wanting heterogenity.
14:26:32 <monochrom> I would start with anti-OOP altogether. data Item = Stick | Pen | Cup. (Add fields as needed.)
14:26:46 <Lazersmoke> it also must be extensible
14:27:08 <monochrom> Until proven otherwise, I would not consider "oh so open subclassing system" at all.
14:27:37 <monochrom> I disbelieve in extensibility.
14:27:41 <Lazersmoke> there are also a large number of items
14:27:48 <monochrom> 99.999% of claims of "need to be open" turn out to be false.
14:28:15 <Lazersmoke> like 450+
14:29:10 <monochrom> You will write Θ(450) lines of code one way or another.
14:29:12 <hpc> in open systems like that, the programming language turns into the configuration language
14:29:59 <Lazersmoke> yeah that's the plan actually hpc
14:30:18 <Lazersmoke> like xmonad
14:30:21 * ski . o O ( `[exists a. C a *> a]' )
14:31:26 <hexagoxel> Lazersmoke: this recent post seems relevant: https://two-wrongs.com/dynamic-dispatch-in-haskell-how-to-make-code-extendable
14:31:42 <Lazersmoke> yeah already read that
14:32:23 <Myrl-saki> My `stack install`'s target binary is broken. What file should I delete?
14:32:39 <Myrl-saki> stack install foo; foo; --> command not found: foo
14:33:16 <jle`> Lazersmoke: instead of having a typeclass, have a data type that can be configured to have the behavior you want
14:33:21 <Myrl-saki> Ah. snapshots.
14:34:17 <Myrl-saki> Or not.
14:34:26 <Myrl-saki> I just got a `couldn't find executable` :C
14:35:14 <Lazersmoke> yes that is what we have been discussing. Should I keep the type class head as a type variable on my data type?
14:35:25 <Lazersmoke> I think that might solve the problem, but I'm not sure
14:35:39 <jle`> if there are two solutions, and one of them involves a typeclass while the other doesnt...
14:35:44 <jle`> the solution without the typeclass is the better one
14:35:53 <jle`> you should be avoiding new typeclasses at all reasonable costs
14:36:38 * hackage persistent-ratelimit 0.3.0.0 - A library for rate limiting activities with a persistent backend.  https://hackage.haskell.org/package/persistent-ratelimit-0.3.0.0 (jp_rider)
14:36:47 <jle`> oh hey i didn't notice hackagebot was back
14:36:56 <jle`> welcome back hackagebot
14:37:46 <lyxia> mniip++
14:37:53 <mniip> what
14:38:53 <np356> cmake ..
14:38:58 <np356> fuck, sorry, wrong window
14:39:07 <lyxia> mniip: for hackage!
14:39:19 <mniip> ah yes
14:41:13 <Myrl-saki> I'm 2 years, I feel a bit better now.
14:41:27 <mniip> old?
14:41:48 <Myrl-saki> Still a bit salty that mniip didn't remember me though.
14:42:16 <mniip> Myrl-saki, who are you again
14:42:23 <Myrl-saki> see
14:42:36 <marvin2> jle` why? what is wrong with typeclasses?
14:43:31 <EvanR> subject oriented programming?
14:44:18 <EvanR> urg missed the whole convo
14:44:44 <monochrom> What's wrong with typeclasses: Its name contains "class" and people think it's a meaningful name.
14:46:27 <jle`> marvin2: it quickly leads to unmaintainble and unreadable code if it's used in an undisciplined way
14:46:31 <jle`> and it's usually the wrong design pattern
14:49:05 <monochrom> Num shows you what Haskell classes are for. So you can say the same name (+) for a lot of different types. Operator overloading.
14:49:50 <EvanR> they can also convert types into values at runtime, which is another way of saying the same thing
14:50:58 <monochrom> Compare to SML where they make you say + for int (fixed width), .+. for floating point, and yet another name for unbounded integers.
14:51:02 <jle`> marvin2: https://www.reddit.com/r/haskell/comments/3mhbuq/so_i_was_working_on_putting_some_math_im_learning/cvezu3w/
14:51:07 <ReinH> It's a bit funny that vanilla Haskell doesn't even *need* typeclasses if it infers functions from types like idris or agda do. It's the language extensions that make it interesting.
14:51:23 <ReinH> otoh that doesn't play well with inference
14:51:41 <ReinH> but I'm usually pretty happy to give up inference
14:52:23 <jle`> TDNR is either the best thing in the world or the worst thing in the world depending on who you ask
14:52:57 <monochrom> Ask me!
14:53:01 <EvanR> good if it works big if?
14:53:33 * jle` asks monochrom
14:53:42 <monochrom> Answer: http://www.mail-archive.com/haskell-cafe@haskell.org/msg84162.html
14:53:45 <monochrom> :)
14:53:55 <hpc> sometimes i think it's bad because it makes figuring out a function call hard
14:54:03 <hpc> sometimes i think it's good because at least they have types
14:54:14 <ski> (TDNR ?)
14:54:19 <hpc> type-driven name resolution
14:54:45 <EvanR> type directed name disambiguation
14:55:09 <ReinH> jle`: :p
14:55:28 <ReinH> It's good when it works but when it doesn't work it's terrible.
14:55:48 <Myrl-saki> I think XMonad is arcane magic with its typeclasses.
14:55:53 <ReinH> how terrible it is depends on how good the error messages are.
14:56:01 <ReinH> or, rather, how bad they are.
14:56:21 <Myrl-saki> I have no idea how XMonad's typeclasses works. I just trust that it will.
14:56:22 <jle`> every once in a while someone comes in here and asks, "hey, i mean, 'lookup' has different types for lists, lazy maps, strict maps, hashmaps etc.  why not just import them unqualified and let haskell figure out which one you want based on type inference'
14:56:34 <jle`> "why can't haskell do this"
14:56:42 <Myrl-saki> jle`: I still wonder that. Why?
14:56:48 <ryandv> @pl \x -> x
14:56:48 <lambdabot> id
14:56:55 <jle`> that's TDNR, and idris and other languages do that
14:57:07 <hpc> Myrl-saki: imagine someone defines a module that has lookup = unsafeCoerce
14:57:13 <ryandv> @pl f >> (\x -> g >> return x)
14:57:13 <lambdabot> f >> (g >>) . return
14:57:20 <jle`> and like i said, you either hate it or love it
14:57:20 <hpc> Myrl-saki: when you your type-directed name resolution, does lookup always resolve to it, or never?
14:57:35 <jle`> there are also pretty big issues with readability
14:57:44 <Myrl-saki> hpc: Ah, true.
14:57:47 <hpc> basically polymorphism is the problem
14:57:54 <monochrom> They are conflating type inference with the opposite direction of type inference.
14:58:21 <monochrom> Type inference does not mean "from types deduce value choice". It means "from value choice deduce types".
14:58:34 <monochrom> Another example of flawed reasoning by meaningful words.
14:58:39 <ReinH> jle`: my main point was that vanilla typeclasses could be obsoleted by TDNR.
14:58:57 <jle`> well
14:59:00 <ryandv> @pl f >>= (\x -> g >> return x)
14:59:00 <lambdabot> (g >>) . return =<< f
14:59:05 <jle`> how would you write preludie functions like 'sum'
14:59:09 <hpc> ReinH: i would argue vanilla type classes /are/ TDNR
14:59:11 <jle`> or 'print'
14:59:13 <hpc> with a layer of type safety on top
14:59:30 <ReinH> hpc: with a layer of making the human compute things on top
14:59:30 <jle`> how does 'print' have a type w/o typeclasses
14:59:45 <hpc> well, the human has to compute things anyway
14:59:58 <hpc> and more or less the same things, without a framework to help out
14:59:59 <ReinH> the human compute fewer things if the computer computes more things
15:00:04 <ReinH> *can compute
15:01:33 <Myrl-saki> hpc: Let's assume a "most specific type" first, how would that fail? I'm guessing it's because we're going to be doing C++ arcane magic.
15:02:08 <hpc> Myrl-saki: you run into the same issue as overlapping instances, actually
15:02:19 <hpc> which already have a concept of "most specific" that isn't entirely unambiguous
15:02:45 <hpc> the solution in that case is instances are global and you can always solve for "this isn't a clear hierarchy of instances" and fail
15:03:19 <hpc> which you could... maybe technically emulate with TDNR
15:03:33 <hpc> but i wouldn't want to be the one to implement it
15:04:13 <Myrl-saki> I see.
15:04:57 <hpc> it might not be north of "it's not possible", but it's definitely north of "why would you?"
15:05:01 <hpc> ;)
15:15:11 <doomlord_> does haskell 'maybe' have an optimization similar to Option<T> in Rust, where if T is a pointer type (where null is invalid) it doesn't need an extra slot to store the flag that says 'none vs some(T)
15:16:29 <monochrom> No.
15:17:55 <doomlord_> is it a possible retrofit , or is it simply not needed for other reasons, or what
15:18:17 <monochrom> It is a flawed translation from Rust to Haskell.
15:18:42 <monochrom> null is invalid for all types, since there is no null.
15:19:12 <monochrom> Therefore if a programmer bothers to request Maybe T, then it is reasonable to believe that the programmer will actually use Nothing.
15:19:33 <dgpratt> it's not hard to find explanations of how folks use Nix with Haskell, but I get the impression that significant changes have happed to how Haskell gets packaged for Nix to the extent that it changes some of the..."best practices"; can anyone point me to a relatively recent resource on the subject?
15:20:05 <monochrom> Another way to put it: Unlike Rust, Nothing is always valid, regardless of T.
15:20:11 <doomlord_> this is kind of what rust is doing:  there's no null pointer;  anything that might return a null pointer returns a None.. and ti just happens to optimise the storage of Option<Box<T>> to recognize the bitpattern 0x000000000   as 'None'
15:21:00 <doomlord_> monochrom absolutely,  an Option<Box<T>> may well be 'None'  (nothing)
15:21:36 <doomlord_> it's just it can store that as one pointer sized object, which happens to represent nothing as 0x00000 , or any other value is 'something'
15:21:56 <glguy> No, GHC doesn't use this trick of a special pointer encoding for "Nothing" to avoid an indirection, but there are examples of doing such a thing
15:22:01 <doomlord_> the optimization could be generalized perhaps, e.g. floating point numbers could represent 'None' as NaN perhaps
15:22:12 <glguy> for example https://github.com/ekmett/structs/blob/master/src/Data/Struct/Internal.hs#L105-L132
15:22:56 <np356> alright, a bit of a philosophical question: I have a tree, I know exactly how many levels it will have and what type of node it will have at each level. what is the kosher way of describing it?
15:23:02 <glguy> You can't do this "with Haskell" but you can do it "with GHC", but GHC doesn't promise that it will work, so you have to be quite careful to check that it works out on any version you're using
15:23:04 <np356> something that is type-safe
15:23:44 <monochrom> But GHC does a related different thing. Look for "pointer tagging".
15:24:55 <doomlord_> ok i recall something like 'pointer tagging' in lisp / ML ..
15:25:03 <doomlord_> using the low bits for ...
15:25:43 <monochrom> "Just x" still takes two words, one for Just one for x. But after I have built that on the heap and give you the address, I give you real_address+1.
15:26:24 <lyxia> np356: this is still pretty vague... how about one type per level?
15:26:34 <monochrom> So you do monochrom's_return_value & 7 and you know that I'm giving you a Just.
15:27:12 <lyxia> np356: If the nodes look uniform in some way, GADTs are a more compact option
15:27:27 <monochrom> real_address is always a multiple of 8 (nice alignment anyway) so this scheme works.
15:29:23 <monochrom> This is done for all algebraic data types of 7 constructors or fewer. Therefore it is more general than Rust. But it does not aim to save space, therefore it is different from Rust's.
15:30:03 <monochrom> Also, on Tuesday I walked by a pub that put up a sign that said "Tuesday is like Monday, but different".
15:30:46 <monochrom> Actually, real_address+2.
15:31:42 <lyxia> why do you still need the word for Just
15:31:43 <monochrom> +1 for Nothing, +2 for Just, +3 for the 3rd data constructor (if exists). +0 for "possibly not in WHNF yet".
15:32:08 <Rembane> So the maximum is +7, and then something happens?
15:32:51 <monochrom> Because the value may start out as an unevaluated thunk at conception time.
15:33:29 <drdo> Does anyone happen to know if the Eq instance of Data.Set is the usual extensional equality?
15:33:33 <monochrom> One day later, it evaluates to Just, sure, but most stakeholders haven't been notified yet.
15:33:59 <EvanR> two sets are equal if they are subsets of each other
15:34:11 <monochrom> They are still holding on to real_address+0 because when they received it, the value was still unevaluated.
15:34:24 <drdo> EvanR: Great, thanks
15:34:43 <EvanR> which suggests the next question
15:34:43 <monochrom> So they need the heap object to tell them "it is now a Just. This happened just 5 seconds ago"
15:34:51 <monochrom> (OK, they don't care about the time.)
15:35:44 <monochrom> The next time GC comes along, which will be next month, this will be fixed, the stakeholders will receive the shiny new real_address+1 version.
15:35:51 <monochrom> But that's for next month.
15:37:07 <monochrom> Err, +2!
15:38:12 <monochrom> I forgot what happens to 8 constructors or more. But you can always code up an example and see the Cmm code.
15:38:19 <Rembane> ^________^
15:38:38 <monochrom> Some jump table seems to be involved.
15:38:54 <Rembane> Good stuff
15:39:51 <monochrom> The design of GHC (and STG) follows a fundamental philosophy of uniform treatment over WHNF and thunks.
15:40:44 <monochrom> For example, the machine word spent on Just is a tag in the conventional sense. It is a pointer to a piece of code again. So as to be on par with thunks.
15:41:31 <monochrom> Except Just's piece of code is a trivial "return real_address+2" so that it also unifies with the pointer tagging scheme.
15:41:58 <Rembane> It seems like a whole lot of pointer indirection. Doesn't that make Haskell slow?
15:42:32 <mniip> iirc what happens for 8+ constructors is you get the 0 tag always
15:42:59 <EvanR> thats pretty much everything a computer is doing nowadays, and speed depends critically on cache use
15:43:11 <monochrom> After code optimization, it is not. There are 3 cases.
15:43:22 <mniip> the function is tagForCon
15:43:51 <c_wraith> it would be really slow naively. the history of ghc is more or less "how can we make this compile to efficient code?" 
15:43:56 <Rembane> :D
15:44:11 <monochrom> A. If your ADT is comparable to a Java record or Java tree node, Java isn't having fewer pointers than yours.
15:44:48 <mniip> https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmClosure.hs#L359-L368
15:45:00 <monochrom> B. If your ADT is really just an enum, "data V = A | B | C", pointer tagging reduces it to a C enum.
15:45:08 <thang1> Dataflow diagrams are the bane of my existance ಠ_ಠ
15:45:14 <monochrom> (Add strictness to make it happen more often.)
15:46:06 <monochrom> C. If your ADT is "data Int = I# Int#", if you look at a tight loop, code optimization is very likely to work with Int# directly and not incur the I# at all. Until you exit the loop.
15:46:26 <Rembane> What happens when I exit the loop?
15:46:47 <Rembane> And the C in the B-case, is that the C. or does strictness reduce enums to the last element in the enum?
15:46:53 <monochrom> Build the I# 42# heap object and return real_address+1
15:47:04 <Rembane> Ah
15:47:27 <monochrom> Ah, "reduces it to a C enum" refers to the C language.
15:48:02 <monochrom> Pointer tagging for V gives you x+1, x+2, x+3 respectively.
15:49:58 <Rembane> Oh, there were many C:s there for a while.
15:50:11 <Rembane> That's nice.
15:51:30 <EvanR> its interesting in the comments for realToFrac rules, it mentions that using primitive conversions for converting Float an Double and back gives like 1000x speedup, and the C backend is even faster (than native)
15:52:18 <EvanR> not sure why i thought C backend would be slower
15:52:39 <EvanR> or if that comment is out of date
15:52:40 <Myrl-saki> EvanR: native -> opcodes?
15:53:00 <EvanR> ghc direct code generation instead of through C
15:53:07 <Myrl-saki> Ah.
15:53:33 <Myrl-saki> Didn't realize the "backend".
15:59:59 <drdo> Is there a good reason why there is no "standard" fold that works for any size of container yet does not require a starting value?
16:00:45 <Rembane> drdo: Like, even if the size is 0?
16:00:55 <Rembane> drdo: There is foldMap, but then your container needs to be a Monoid
16:01:09 <marvin3> :t foldr1
16:01:10 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
16:01:19 <drdo> Rembane: yes
16:01:33 <EvanR> > foldr1 (+) []
16:01:35 <lambdabot>  *Exception: Prelude.foldr1: empty list
16:01:36 <marvin3> ^ if by "works" you meant "returns bottom". because that is the only thing it can return without a default value
16:01:38 <drdo> foldMap doesn't take the folding function
16:03:17 <Rembane> :t foldM
16:03:18 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
16:03:26 <drdo> Nevermind what I said, I was thinking of a special case where this actually makes sense
16:10:11 <nil> Hey, does anyone know why I'm getting this message from a blacklisted intero project in Emacs? "Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc returned non-zero exit code 1, but its output contained no errors: Cannot determine project root directory."
16:13:38 * hackage shellmate 0.3.4.2 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.4.2 (AntonEkblad)
16:21:37 <orion> Under what conditions would you use the free package, and when would you use the monad-coroutine package?
16:21:49 <orion> (If your goal is to suspend and resume computations)
16:22:27 <EvanR> or would you make your own based on thethe oleg freer monad tutorial
16:23:23 <orion> http://okmij.org/ftp/Computation/free-monad.html <-- This?
16:23:52 <EvanR> yeah
16:24:18 <EvanR> i.e. your type for effects doesnt even need to be a Functor
16:30:27 <EvanR> what do you call a data type whose two values are East and West
16:30:53 <erisco> ThreeNine
16:31:44 <Tuplanolla> Obviously `T`.
16:31:52 <EvanR> T_T
16:33:32 <erisco> could call it Lateral
16:34:11 <monochrom> OldWorld
16:34:35 <Rembane> PortugalSpain
16:34:55 <monochrom> Berlin <duck>
16:35:28 <erisco> MarioStory
16:35:40 <MarcelineVQ> Spin | AntiSpin
16:36:02 <geekosaur> Sun
16:36:19 <monochrom> erisco: Oh haha I get it now.
16:36:24 <erisco> ;)
16:36:53 <monochrom> I did take advantage of HMV closing sale to buy West Side Story blu-ray at a very low price.
16:37:52 <pacak> How would you go about figuring out unused definitions/modules in a big project?
16:39:37 <EvanR> DirEW
16:40:14 <Tuplanolla> Be a good C programmer and call it `HrzCmps`.
16:40:33 <monochrom> heh
16:40:43 <robkennedy> Everytime I read about Free Monads, I feel like I ought not trust them - that some inline failure will happen, or that the applicative for my class isn't the trivial one from Monad. How did you overcome that?
16:41:15 <monochrom> Wth is "inline failure"?
16:42:59 <robkennedy> The bane of Vector code
16:43:52 <monochrom> No understand.
16:47:42 <robkennedy> Ie `f x = case x of {Left _ -> g x; Right y -> y}; g x = case x of {Left y -> y; Right _ -> f x}`. Here we ought to be able to say `reallyUnsafePointerEquality# f (either id id) == 1`
16:48:29 <robkennedy> *modulo bottoms, sure
16:48:47 <monochrom> No. GHC code optimization does not include de-duplicating code.
16:49:05 <monochrom> In fact I think I saw more duplicated identical code than less.
16:50:07 <monochrom> All of them highly optimized. But still separate clones.
16:50:21 <robkennedy> First, this is tangential to my point, which is about how well GHC can analyze Free. And second, I think you're wrong
16:51:17 <robkennedy> Hold up while I look up the example
16:51:21 <glguy> GHC optimizes that to:   g = f; and f t x = case x of { Left ds -> ds; Right y -> y }
16:51:38 <glguy> Though I don't know what the point of that was
16:51:53 <glguy> oh and the t was a type argument, so ignore that
16:52:23 <erisco> it is strange to begin with the speculation of compiler bugs
16:53:20 <robkennedy> https://youtu.be/jcL4bp4FMUw at 12
16:53:48 <robkennedy> Yeah, GHC well get `g = f`
16:54:25 <monochrom> But still not reallyUnsafePointerEquality# f (either id id) == 1
16:56:16 <robkennedy> ... okay, it might only get `f === (either id id $!)`
16:56:43 <edwardk> monochrom you need joachim breitner's toy for that
16:57:16 <glguy> Hay, it worked!
16:57:20 <glguy> they are equal :)
16:57:21 <monochrom> Also, I have watched from 12:00 to 13:00, and still no sign of unsafeWhatever. Or core code for that matter.
16:57:41 <robkennedy> But, my original question is about how much other users worry that Free might obscure these sorts of (to be honest incredible) optimizations
16:58:07 <monochrom> If you use Free, you have already lost the performance war.
16:58:19 <robkennedy> You'll get it by 1518, it's worth the wait
16:58:28 <edwardk> monochrom: =P
16:58:32 <robkennedy> Right, that's the exact concern :-(
16:59:04 <edwardk> i tend to start with free then rewrite my code into whatever interpretwtion i'm putting on the original Free thing
16:59:37 <glguy> https://paste.fedoraproject.org/paste/XLM-0kohGMP7NQZQRLy8L15M1UNdIGYhyRLivL9gydE=
16:59:37 <EvanR> like a church encoded version
17:00:41 <monochrom> glguy, what if you don't make g a top-level definition?
17:01:03 <edwardk> i basically start with free definitions, either using Free or a boring data type that should be, then replace things in uppercase with lowercase stuff and inline my interpreter
17:01:24 <erisco> what is inherently the problem with Free?
17:01:29 <monochrom> I am also interested in reallyUnsafePtrEquality# (either id id) (either id id)
17:01:32 <glguy> monochrom: It's not magic! ;) Then you get 0
17:01:36 <robkennedy> glguy: ty based SPJ 
17:02:01 <glguy> monochrom: but with the two (either id id)'s it works out
17:02:01 <edwardk> erisco the only real problem is you need to construct that intermediate data type then interpret it in 2 steps
17:02:13 <edwardk> if you get lucky it might fuse away
17:02:29 <erisco> you need to construct Fix? but it is a newtype, yes?
17:02:45 <edwardk> free isnt fix
17:02:47 * ski would like unboxed variant types
17:02:53 <erisco> oh derp
17:03:05 <erisco> well they both start with F, so there :P
17:03:34 <robkennedy> ekmett: That's what I meant by the inline failure. But if you prototype in Free, it can't be too bad
17:04:02 <erisco> I don't think you can be so sure it is strictly a negative
17:04:56 <robkennedy> I'd thought Free was the deeper program, but if the goal is a simpler interface for experimenting, that's interesting
17:05:05 <edwardk> i dont write free cod for performance i write because i can be sure i havent boxed myself in with a bad assumption
17:07:07 <erisco> what if we make the functor component strict?
17:07:38 <erisco> and, can we use pragmas to specialise?
17:08:09 <glguy> What are you hoping to make strict to which effect?
17:08:29 <glguy> That won't change the representation, it will only change the behavior of the constructor when used as a value
17:08:44 <monochrom> Strictness may beget nontermination for this.
17:09:39 <monochrom> Because (>>=) goes: Free x >>= f = Free (stuff here)
17:09:45 <erisco> well instead of chasing that let me instead say that there should be some way to have Free as a meta-ADT
17:09:49 <halogenandtoast> So as someone who is relatively new to Haskell (only one Yesod app online), does it make sensse to try and learn something like the Free monad
17:09:59 <halogenandtoast> Oh good, I'm already jumping into a Free conversation
17:11:00 <erisco> for example, we can manually inline the Functor into the definition of Free and this obviates the possibility of automation
17:11:48 <monochrom> Yeah. Which is why ski brought up unboxed sums for the same goal.
17:11:56 <erisco> halogenandtoast, nope I wouldn't say a beginner needs to know Free
17:12:28 <Welkin> I still don't really understand Free
17:12:40 <Welkin> but I have bookmarks for it when I need it (if ever)
17:12:51 <erisco> I am learning of recursion schemes now and that provides a good reason to understand Free and Cofree
17:13:09 <erisco> and at some point everyone needs to learn recursion schemes I think. based on what I am seeing in it
17:14:19 <erisco> monochrom, unboxed sums? like tagged unions C-style?
17:14:22 <monochrom> I learned them because I researched in formal methods and I needed to know all theory and practice of fixed points.
17:15:25 <monochrom> I really doubt that programmers outside formal methods need to care as much.
17:15:29 <robkennedy> halogenandtoast: I made it about a year before I felt the need for a real function of type `lookupM :: (Monad m, C v) => T -> K -> m v` (where case indicates concreteness). You can get far without real abstractions. 
17:19:38 <erisco> I imagine the challenge is finding some way to define Free so that Free f is semantically the same as the manually inlined version while also fitting into our usual syntaxes (pattern matching, constructors, etc)
17:20:46 <erisco> you could imagine banging something out with TH but you really still want it so that you can talk generically about Free
17:21:58 <halogenandtoast> erisco: robkennedy: Thanks, I'm getting the feeling that there is some motivation of Free (at least as represented in the articles I've been reading) that have a lot of value perhaps outside of Free
17:22:07 <erisco> the moral of the story is to remove the wedges between performance and genericity
17:22:14 <halogenandtoast> The idea of representing your problem as some algebra sounds revolutionary to my OOP mind.
17:22:44 <halogenandtoast> But that probably isn't exclusive to Free.
17:22:50 <Myrl-saki> halogenandtoast: I've "exclusively" used Haskell for 2 years, and everything still blows my mind.
17:22:51 <EvanR> halogenandtoast: yes! a tiny language to describe solutions which are correct by construction!
17:23:48 <EvanR> though it seems that Free is specifically for imperative style solutions
17:25:06 <ski> erisco : "unboxed sums? like tagged unions C-style?" -- no, not at all
17:25:24 <ski> the *continuation* should be unboxed
17:25:47 <erisco> what is the continuation in this context?
17:26:06 <ski> the context expecting to receive a value of the type in question
17:26:47 <erisco> I don't see it... I don't know enough about the internals, I imagine
17:27:38 <ski> the context of a value of type `Either a b' will typically involve using a `case', with two branches, one for `Left', and one for `Right'
17:28:23 <ski> the expression of type `Either a b' will need to package up the result in one location, and then the `case' will need to look there and unpack, choosing the branch
17:29:16 <ski> i want to avoid this, i want to pass the two branches directly to the computation of type `Either# a b', so that as soon as it uses `Left#' or `Right#', it selects the appropriate one of the two given continuations (discarding the other one)
17:29:35 <ski> there is never a value of type `Either# a b' materialized
17:30:14 <monochrom> yikes, you're going to do bi-continuation passing style
17:30:34 <erisco> this is the dual of unboxed tuples, then? am I getting it right?
17:31:19 <erisco> I am not sure what the implications of this are
17:31:25 <ski> there's a paper by Olin Shivers', "Multi-return Function Call" <http://ccs.neu.edu/home/shivers/papers/mrlc-jfp.pdf>, that's about this idea
17:31:28 <ski> erisco : yep
17:32:01 <erisco> so, say we write  f (Left x)  then I expect the optimiser to evaluate f to the Left branch
17:32:16 <ski> however .. it's not that clear to me how to generalize this nicely to recursive types (e.g. lists, so that one is *guaranteed* that it's "fused", that there is no intermediate representation ..)
17:32:16 <monochrom> Err, wth is "capsule review"? :)
17:33:47 <erisco> but the same could be said of tuples
17:34:01 <erisco> so I don't know enough about the compiler optimisations... maybe it doesn't do these things
17:34:33 <edwardk> erisco making the functor in free strict and changing the free constructor to match jst makes left associated binds both slow and cache inefficient rather than just slow
17:34:54 <ski> erisco : well, this wouldn't be an optimization, per se. it would be a guarantee
17:38:42 <erisco> how does unboxed sums connect to Free?
17:41:22 <ski> <http://lpaste.net/13302> is an example of it could possibly look (translated from the example <http://lpaste.net/13299> from the paper)
17:44:06 <ski> .. the idea here is that we (for whatever reason) want a `filter' that will share as long a tail as possible with the input list
17:45:09 <ski> so the worker has two alternative return cases, one indicating that no element was dropped from the input list (and therefore no new list is returned), the other alternative indicating the changed list
17:46:22 <ski> the interesting thing is that we get what's called "semi-tail calls" : we call (recursively) with *one* of the two continuations being the same as the one we got ourselves, and the other not
17:47:13 <ski> one could write this explicitly, using CPS .. but that's a bother. i'd rather write it in direct style
17:48:27 <ski> (in the explicitly CPS version, the type of the worker `recur' would be `[a] -> ([a] -> o) -> o -> o')
17:49:50 <ski> there almost surely needs to be syntactic restrictions of some kind regarding how things of type `Either# a b' (or other unboxed variant types) can be handled; in order to be able to guarantee that the continuations will be unboxed
17:49:59 <ski> (cf. restrictions for unboxed tuples)
17:50:02 <shlevy> suppose I have 'instance Foo a => C a' and 'instance Bar a => C a', is there any way with the overlapping mechanisms ghc has to get an error when both Foo and Bar are met and we try to solve for C but succeed when only one is met?
17:51:29 <erisco> I don't know of it and I don't think that makes sense with the open nature of type classes
17:52:38 <erisco> you can't generally say that an instance is impossible and if you merely want that an instance is not defined that is dubious
17:52:52 <shlevy> Why not? type classes are open yes but a change that breaks something that used to work would not just require a new instance, it would require a new orphan
17:53:20 <ski> anyway, `Free' is recursive. i suspect that if one could handle recursive unboxed variants, then such a version of `Free' would remove the overhead (or at least some of it) of using `Free' over a specialized version
17:53:35 <shlevy> I already have Foo, Bar, C, and a in scope at the relevant call site so the only way an extra import breaks things is if it defines an orphan for Foo or Bar a.
17:54:36 <erisco> yes, that is a problem with it
17:54:47 <erisco> but also it is a problem with what this constraint would mean as I outlined above
17:55:15 <erisco> it is like saying "foo is not a function"
17:55:49 <erisco> well, yeah, we can technically look at the list of functions we have defined, or are in scope, but this is a strange and dubious thing
17:57:07 <erisco> if we could be stronger and say "this is not implementable" that would be much better
17:57:17 <shlevy> If X has no Show instance and I call "show x" for "x :: X", I get an error. If I then import a module that defines an orphan Show instance for X, the error goes away
17:57:19 <erisco> unfortunately that is also much more work
17:59:08 <erisco> yes, but in that case your program either has a meaning or none
17:59:23 <erisco> versus having different meanings depending on whether an instance is defined
17:59:29 <shlevy> That's the exact dichotomy I want
17:59:52 <erisco> no, it is different
18:00:00 <erisco> if your program compiles then it is a valid program and so has some meaning
18:00:04 <shlevy> There are no different meanings in my case
18:00:07 <erisco> if you get an error then your program is nonsense, i.e. has no meaning
18:00:18 <shlevy> "error" meant compile time error in my original question
18:01:21 <erisco> sorry I must have been distracted with these chocolate chip cookies :P
18:03:43 <erisco> let me explain it this way
18:04:30 <shlevy> Related but different question: If some term matches the head of two instances, but only satisfies the constraint of one, why is that an overlapping instance in the first place?
18:04:43 <erisco> say we have class C x and class D x and instances instance C x => D x, instance ~(C x) => D x
18:05:02 <erisco> where the ~ is standing in for our desired "doesn't have an instance" constraint
18:05:13 <erisco> can you see now that depending on whether x has an instance of C that we change meanings?
18:06:03 <shlevy> erisco: But that's not what I'm asking for :D I don't think you can turn my actual example which doesn't rely on a fictitious "doesn't exist constraint" into allowing that
18:06:48 <EvanR> heh hackage package Stream and stream are different
18:07:15 <erisco> shlevy, I don't know what you are asking for then, because it seems to be the same thing to me
18:07:30 <erisco> you are asking for the instances of Foo excluding Bar and Bar excluding Foo
18:08:05 <erisco> what is your proposed change to the language?
18:08:26 <shlevy> erisco: See my "related but different question" above
18:08:56 <shlevy> erisco: Or, to restate: If some term matches the head of two instances, but only satisfies the constraint of one, it should not be considered an overlapping instance and thus should compile fine
18:09:19 <geekosaur> it can't reliably check that across modules
18:09:37 <shlevy> geekosaur: Because of orphans?
18:10:18 <shlevy> geekosaur: We already allow changing compile status due to orphans. If X has no Show instance and x :: X, show x will fail to compile unless I import a module defiing an orphan
18:10:59 <erisco> shlevy, because that would be answering the same kind of question
18:11:24 <erisco> instance A x => F x, instance B x => F x
18:11:42 <erisco> this would let us answer whether x has an A instance or a B instance
18:12:20 <erisco> my point that even if this was all possible it is still aesthetically unpleasing as a system
18:12:44 <erisco> the intent of type classes are to be open and to that end we can't be talking about the non-existence of things
18:12:56 <shlevy> But you can't change behavior based on non-existence
18:12:58 <Welkin> open source typeclasses
18:13:00 <shlevy> You either compile or you don't
18:13:10 <Welkin> free and open source
18:13:12 <geekosaur> but you can compile separately
18:13:36 <geekosaur> if I compiled one module 6 months ago and it made a decision about nonexistence, then link against that 6 months later in aprogram that *does* define the instance...
18:14:01 <geekosaur> (we do this with packages all the time. heck, it's stack's main schtick)
18:14:10 <shlevy> Ah, fair
18:14:10 <shlevy> OK
18:14:36 <erisco> instance A x => F x, instance B x => F x, instance (B x, C x) => F x   my program is different if I only have instance B X versus having both instance B X and instance C X
18:15:23 <shlevy> I mean, I hate that haskell allows orphans and if it didn't this wouldn't be an issue, but this does break modularity given that it does
18:15:26 <erisco> your resolution scheme is depending on the non-existence of instances
18:15:42 <geekosaur> this isn't even orphans
18:15:49 <erisco> by the very nature of saying "why does it match if it doesn't satisfy this context"
18:16:03 <erisco> that is exactly saying "these instances do not exist"
18:16:38 <shlevy> erisco: I'm agreeing this feature is bad, but note that under my desired semantics the third instance could never be satisfied since it would always overlap
18:16:56 <shlevy> I'm *not* asking for the most specific constraint
18:18:00 <geekosaur> I define a new type somewhere and give it instances, these are not orphans. And then link against your package that made a nonexistence decision when it was compiled.
18:18:16 <shlevy> My package can't have made a nonexistence decision for your new type
18:19:13 <geekosaur> instance Foo x => Bar (Maybe x) where...
18:19:14 <shlevy> If my call site is too polymorphic to be sure a given constraint isn't satisfied then again it would fail
18:19:25 <shlevy> But anyway
18:19:40 <shlevy> A new orphan down the road would break modularity
18:19:46 <shlevy> So this is a bad idea regardless
18:19:59 <edwardk> shlevy: in general learning a new instance would mean that existing fully compiled code should change semantics if you allow discrimination on whether or not an instance exists. this violates the open world assumption that adding new instances and new data types doesn't affect modules that have already been compiled, which is key to incremental compilation
18:21:01 <shlevy> edwardk: But modulo orphans, if the only semantics change is failing to compile or not, and we only allow compilation when we *know* the given constraints aren't met, wouldn't this still be modular?
18:22:08 <edwardk> the usual whipping boy is something like instance Monad m => Applicative m
18:22:24 <edwardk> which overlaps every alternative definition
18:22:35 <edwardk> but would let you fill it in
18:23:05 <edwardk> but in the absence of backtracking instance selection forces us to believe that all instances arise from this form
18:24:20 <c_wraith> is there a connection between the linear and affine as used to describe substructural typing and the linear and affine used to describe transformations? 
18:24:23 <edwardk> but if you can backtrack then you get cases where adding the instance changes semantics. now that instance would have to live with the data type or else be an orphan, but only because Monad and Applicative are so high in the partial order of module imports
18:24:43 <edwardk> c_wraith yes
18:25:43 <c_wraith> edwardk, is there a convenient reference discussing the connection anywhere? 
18:25:48 <edwardk> mx.   vs b + mx.   the former the x is used, in the latter its buried in a sum
18:27:37 <edwardk> affine traversals are of the form  s ~ b + m*x for instance. lenses are linear traversals s ~ m*x for some pseudo complement m
18:27:54 <edwardk> traversals look like more general polynomials
18:28:08 <edwardk> relevant traversals drop the x^0 term
18:28:45 <Mibaz> There are a few different implementations of the state monad in the platform, it seems. Is there a rule of thumb for selecting one to use?
18:28:47 <edwardk> c_wraith maybe old chat logs that shouldnt exist of #haskell-lens?
18:29:23 <edwardk> control.monad.state is laziest control.monad.state.strict is less lazy but less leaky
18:30:00 <c_wraith> and everything in mtl is a re-export of the versions in transformers 
18:30:15 <Mibaz> edwardk: so stick to control.monad.state in applications that aren't performace critical?
18:30:15 <c_wraith> so those aren't actually different. 
18:30:18 <edwardk> and yeah the mtl just reexports the transformer code with some instances attached
18:30:37 <edwardk> mibaz or where you might have tricky recursion
18:30:48 <Mibaz> Got it. Thanks guys
18:31:23 <edwardk> foo = do foo; modify (1:)   -- works with C.M.S despite folks intuitions
18:31:33 <edwardk> but with the .strict variant bottoms out
18:31:42 <edwardk> head recursion!
18:32:05 <nicootto> Hi, how can I know what is reffering a type synonyms. I mean, String makes reference to [Char], but how can I see that in ghci?
18:32:20 <edwardk> if i wasnt on an ipad i'd feed that to lambdabot here
18:33:51 <ChaiTRex> nicootto: :i String
18:34:17 <Axman6> where :i is short for :info
18:34:21 <ChaiTRex> :i String
18:34:30 <nicootto> Thanks you! I was traing with :t but without success
18:34:42 <ChaiTRex> lambdabot is on vacation.
18:34:56 <edwardk> :t is asking the type of a value, you have a type there
18:34:57 <lambdabot> error: parse error on input ‘type’
18:35:11 <ChaiTRex> nicootto: You're welcome.
18:35:14 <edwardk> :t undefined :: String
18:35:16 <lambdabot> String
18:35:26 <edwardk> ^- not helpful
18:35:54 <edwardk> :t "wat"
18:35:56 <lambdabot> [Char]
18:36:04 <edwardk> ^- slightly more helpful
18:36:17 <nicootto> okay, I got it
18:36:18 <geekosaur> lambdabot has no :i
18:36:21 <edwardk> but :i is the way to go
18:36:42 <edwardk> @i String
18:36:42 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
18:36:48 <edwardk> drat
18:37:12 <edwardk> int-e: you should add :i :)
18:37:22 <nicootto> that makes sense
18:37:30 <nicootto> thanks again!! 
18:37:45 <edwardk> of course me asking that backfires as he'll probably start bugging me to fix lens up for safehaskell again
18:38:02 <geekosaur> heh
18:38:46 <erisco> tit for tat
18:38:53 <ezyang> Anyone here have recommendations for Haskell libraries for generating C programs involving loops? 
18:39:17 * Clint squints.
18:40:41 * edwardk suddenly finds himself in a western
19:00:32 <erisco> the world stops spinning when lpaste stops responding
19:00:46 <Clint> nooooooooooo
19:02:28 <erisco> 2/2 paste sites are timing out lol
19:03:50 <Welkin> even github gist?
19:04:31 <erisco> Welkin, that's a reasonable one, thanks
19:06:19 <erisco> edwardk, here are the initial thoughts I had for a compiler extension to give a more efficient Free. Not sure if this just goes in a big useless circle... hoping your superior knowledge of the internals can give me a clue https://gist.github.com/erisco/65e2d098172ba86c8324f28053e76721
19:09:05 <edwardk> have you seen the work that is going into unboxed sums?
19:09:20 <erisco> the goal is to have your cake (the generic Free) and eat it too (the performance of inlining)
19:09:42 <erisco> ski just talked about it but I didn't see the obvious connection here
19:09:49 <edwardk> you're only getting rid of the overhead between Free and f here
19:10:05 <edwardk> not the overhead between the interpreter and the separate construction
19:10:11 <cheshircat> does anyone have a good setup for ghc-mod and vim in nixos with nix-shells?
19:11:21 <erisco> edwardk, because I reconstruct with Just and Nothing anyways?
19:11:39 <edwardk> if you could ask ghc to do data Free f a = Pure a | Free {-# unpack #-} !(f(Free f a)). then you'd be getting the same as your proposal
19:12:03 <erisco> right, that was as far as I was thinking about it
19:12:07 <edwardk> but that would need unboxed sums and the ability to unpack polymorphic things
19:12:25 <edwardk> the former is coming, the later is hard
19:12:29 <edwardk> er latter
19:13:03 <edwardk>  ut that still doesnt address the needless data co struction followed by a separate interpretation step
19:13:12 <erisco> well I also intended Pure&&Maybe, Pure&Nothing, Pure&Just to be actual constructors as well, but I am not sure how small of a point this is
19:13:16 <edwardk> er sorry for typos, walking with ipad
19:13:53 <erisco> yes you have Free . Just and Free Nothing but generally I didn't see GHC figuring this out
19:14:08 <erisco> so instead when you're working concretely you have those constructors available
19:14:31 <glguy> The issue is that there are any constructors at all
19:14:35 <edwardk> the issue is what happens when f is unknown
19:15:01 <erisco> yes, so then you're working with Free generically
19:15:04 <edwardk> but the other issue is why are we constructing anything just to interpret it separarly later like glguy said
19:15:20 <erisco> so that is when you use Pure and Free and the pattern matching implementations I gave
19:15:44 <edwardk> the point is constructing anything produces overhead
19:15:52 <erisco> which, yes, don't seem to provide any benefit, but I am not sure how you'd have any benefit in the generic case
19:16:29 <erisco> hm? how are we going to construct nothing at all? we're still talking about some data type
19:16:43 <erisco> I thought the issue was that we have two layers of constructors
19:16:50 <erisco> one for Free and another for the Functor
19:17:49 <erisco> okay, so I see where unboxed sums can fit in on line 57/58 of my example
19:18:00 <erisco> if n takes an unboxed sum then we automatically select the correct branch in n
19:18:57 <erisco> I am still thinking the optimiser is going to easily pick up on the constant Just or Nothing, but I don't know how hairy it can get
19:19:25 <edwardk> the overhead of free is vs instead using combinators that build whatever thr final intepretation you were going to use in the first place
19:19:57 <edwardk> the fact that free adds a little overhead on top of the base functor is just adding insult to injury
19:20:06 <edwardk> the patient is already dying
19:20:18 <erisco> okay, I've missed the plot entirely then
19:20:45 <edwardk> np
19:21:23 <edwardk> the hell with free is picking one of 4 implementations, the adding the interpreter overhead
19:21:27 <erisco> how does this relate to combinators? we can construct Free from combinators... not sure where that is headed
19:22:44 <edwardk> i can work with Free MyTerminal a with GetLine and PutStrzln constructors or i can call getLine and putStrLn directly
19:23:00 <edwardk> if all im going to do is interpret the latter is a win
19:23:14 <edwardk> if that is the only interpretation i need that is
19:23:37 <edwardk> if i need introspection / alternate usecases i need somehing closer to the former free construction
19:23:57 <edwardk> but if all i want to do is interact wi the user the latter is less than half price
19:23:59 <erisco> okay... so is this something like a fusion problem?
19:24:07 <edwardk> yes
19:25:16 <erisco> what I am not sure on then is what Free has to do with it
19:25:18 <edwardk> going finally tagless with specialization you might convince he compiler to compile down from conmbinators in classes to whatever form. you want to interpret with, offering a middle ground
19:25:34 <erisco> it seems you can come up with the same dilemma with any intermediate representation
19:25:49 <edwardk> free is just 'as close to an initial encoding as possible for a given set of operations'
19:25:51 <erisco> such as any AST
19:25:52 <glguy> Finally tagless and specializations on everything works well enough, except that you have to specialize everything
19:26:16 <glguy> (manually)
19:27:03 <edwardk> the discussion was generally about building an adt and interpreting vs. directly calling through final encoding via combinators
19:27:22 <edwardk> free is a shorthand for talking about the former approach in all its myriad forms
19:28:37 <erisco> I see... well that is a problem I can appreciate
19:30:42 <codygman> Are there any notes or documentation on the implementation of template haskell?
19:30:57 <edwardk> the hell of it is there are like 5-6 different tricks to use here, and each of them sucks at something different
19:32:20 <edwardk> Free f sucks at left associated binds, the church free fixes that but has multiple interpretation overhead, finally tagless sucks for multiple interpretation and MAY suck for left associated binds depending on the specialization, codensity is too big, reflection without remorse gives you massive constants
19:32:33 <edwardk> pick your poison
19:32:59 <glguy> If you want two interpretations of tagless, you jsut interpret it as two interpretations!
19:33:14 <glguy> with some more specializations
19:33:56 <edwardk> same issue as multiple interpretation under church free or codensity though
19:34:05 <glguy> It's not so good at inspecting it while you're building it
19:34:08 <edwardk> getting one constructor out costs full price
19:34:21 <edwardk> that is what i'm getting at
19:35:06 <c_wraith> have you tried Scott encoding? I figure it must be isomorphic to one of those. 
19:35:23 <edwardk> see church free
19:36:17 <c_wraith> Scott supposedly has the advantage of not having to pay full price to examine the outermost layer. 
19:36:18 <edwardk> any of the cps'd free encodings suffers the "full price inspection" problem
19:37:06 <edwardk> you either pay to inspect the outermost constructor or you pay to >>= or you explicitly manage a catenabke output restricted deque
19:37:47 <edwardk> so the scott encoding would be equivalent to the basic Free version then
19:38:00 <c_wraith> that seems right. 
19:38:08 <erisco> funny because it doesn't sound so hard without knowing anything about it
19:38:35 <EvanR> did he say catenabke or
19:38:49 <c_wraith> he's typing on an iPad. :P
19:38:54 <edwardk> 99.9% of the time you never notice nor care
19:39:06 <edwardk> catenable
19:39:06 <EvanR> what is it supposed to say
19:39:11 <glguy> catenable
19:39:21 * EvanR gets out the dictionary
19:39:34 <c_wraith> and is really quite fast at it. :) 
19:39:35 <edwardk> can be concatenated
19:39:45 <glguy> (efficiently)
19:40:22 <edwardk> O(1) worst-case catenable output restricted deques exist
19:40:29 <edwardk> even without output restriction
19:40:33 <EvanR> yet another way to lose at scrabble
19:41:22 <c_wraith> EvanR, the official Scrabble dictionary rejects it. 
19:41:54 <edwardk> i have only ever suffered one defeat at "words with friends", sadly most of my day to day vocabulary is rejected by it
19:41:54 <erisco> Scrabble Programmer's Edition
19:42:11 <erisco> all words plus all abbrevations plus all jargon plus all the previous with vowels removed
19:42:36 <edwardk> and rot13 versions
19:42:48 <edwardk> like funpuns
19:42:49 <glguy> rot13 scrabble sounds rough
19:43:01 <edwardk> so many more z and q words
19:43:03 <erisco> and reversed, fi, dne, etc :)
19:43:25 <glguy> cte? ;-)
19:43:37 <EvanR> ktp
19:43:39 <edwardk> hungarian notation lets you prefix each word with lp, etc
19:43:41 <erisco> compile-time evaluation
20:03:55 <thang1> Hungarian notation has always been something I disagree with. It was fine for languages that weren't sane unless you used it... but really, c'mon.
20:06:59 <edwardk> thang1: thats a what a decent type inference engine and tool support are for, after all
20:09:33 <ZuluKing> how can I combine two lists, ['1','2','3'] and ['a','b','c'] as ['1','a','2','b','3','c']? I tried zipWith (:) list1 list2, doesnt work
20:12:29 <edwardk> twist (a:as) bs = a:twist bs as; twist [] bs = bs
20:12:52 <Welkin> > flatten $ zip ['1','2','3'] ['a', 'b', 'c']
20:12:54 <lambdabot>  error:
20:12:54 <lambdabot>      • Couldn't match expected type ‘Tree a’
20:12:54 <lambdabot>                    with actual type ‘[(Char, Char)]’
20:13:03 <erisco> > (\xs ys -> concat (zipWith (\x y -> [x, y]) xs ys)) ['1','2','3'] ['a','b','c']
20:13:03 <Welkin> > concat $ zip ['1','2','3'] ['a', 'b', 'c']
20:13:05 <lambdabot>  "1a2b3c"
20:13:05 <lambdabot>  error:
20:13:05 <lambdabot>      • Couldn't match type ‘(Char, Char)’ with ‘[a]’
20:13:05 <lambdabot>        Expected type: [[a]]
20:13:29 <Welkin> ZuluKing: the short answer is `concat . zip`
20:13:45 <erisco> is it now
20:13:49 <edwardk> concat doesnt work with tuples the way you want
20:14:11 <Welkin> oh, oops
20:14:19 <Welkin> I have been writing too much javascript
20:14:34 <erisco> I also give this definition for it https://github.com/erisco/acrid-parser/blob/master/parser/common.hs#L100
20:14:49 <edwardk> the teist thing above interleaves and keeps going after one cuts short
20:14:49 <erisco> not sure how the strictness compares... wrote that a long time ago when I was learning
20:15:03 <edwardk> erisco's version does exactly wha is asked
20:15:10 <ZuluKing> I see
20:15:12 <edwardk> what you want lis at one extreme or the other
20:15:27 <ZuluKing> thanks, I need to implement a function then, thanks!
20:15:30 <edwardk> er twist thing
20:15:32 <erisco> yeah, the interleave I linked keeps going too
20:16:39 <ZuluKing> erisco, please take a look at this http://stackoverflow.com/questions/3938438/merging-two-lists-in-haskell
20:17:01 <ZuluKing> erisco, is the second answer better in anyway to your solution?
20:17:01 <edwardk> > let twist (a:as) bs = a:twist bs as; twist [] bs = bs in twist ['1','2','3'] ['a', 'b', 'c']
20:17:04 <lambdabot>  "1a2b3c"
20:18:35 <czyborra> > words "my name is lambdabot"
20:18:37 <lambdabot>  ["my","name","is","lambdabot"]
20:18:38 <edwardk> the second answer is my twist above, notice the question asks with lists of different lengths, so erisco's version would cut off the extra bits
20:18:54 <czyborra> cool!
20:18:58 <edwardk> if that is what you want then great
20:19:06 <edwardk> if not then use the other
20:19:55 <ZuluKing> thanks both of you
20:49:41 <Mibaz> If I made a function that should be private in an OOP language, should it just be in a where clause?
20:51:17 <EvanR> or you don't export it from the module
20:51:57 <EvanR> otoh in real life people want access to this stuff so you could put it in an My.Module.Internal other module
20:53:26 <Mibaz> Alright thanks
20:57:18 <thang1> Mibaz: I also find that generally in FP vs OOP, you don't really need to hide your functions in the same way.
20:58:26 <EvanR> you certainly have the implementation vs the interface
20:58:46 <Mibaz> thang1: Makes sense, since the whole point of objects is hiding functions
20:59:02 <Mibaz> ("The whole point") ;)
20:59:03 <EvanR> it is?
20:59:13 <Mibaz> EvanR: Beat you to it
20:59:23 <thang1> Objects aren't meant to hide functions, they're meant to hide "global" variables/data. Think of them as really terrible namespaces if you want
20:59:41 <EvanR> i do vaguely remember that introduction to C++ classes a jillion years ago
20:59:45 <EvanR> "hide your shit"
20:59:52 <thang1> The reason certain functions should be private in objects is because they deal with data that shouldn't be exposed (ie, implementation details that are irrelevant to the app)
21:00:15 <Mibaz> thang1: EvanR: If you do some mental gymnastics the statement makes more sense. But obviously you guys are right.
21:00:58 <thang1> A classic example: A binary tree class often has a "root" pointer. This should be private of course, as all data should be. However, while a getData() function might be public, a recursive add(data) function would call a helper function add(data,root) which would be private.
21:01:02 <EvanR> later in ruby it was explained differently, "use all the global state you want, locally"
21:01:31 <thang1> The add(data,root) is private because it's an implementation detail that's irrelevant to the concept of adding data to a data structure (which is the point of the BST class)
21:02:27 <EvanR> the Data.Map implementation is probably a more relevant subject for this hiding discussion
21:02:38 <EvanR> it contains lots of routines that arent in the API
21:06:54 <thang1> And all of the stuff not in the API is in  Data.Map.Internal, yes?
21:08:50 <EvanR> yeah
21:09:05 <EvanR> "use at your own risk"
21:09:28 <Lokathor> people ping me in channel
21:09:35 <Lokathor> why oh why do they do that instead of sending me a PM
21:09:37 <Lokathor> i don't get it
21:09:51 <EvanR> get a plugin to help
21:09:57 <Lokathor> bleh
21:11:03 <thang1> Lokathor: why can't I just ping you if it's a public question? :p
21:11:36 <Lokathor> thang1, well you can as long as you don't ever expect a response
21:12:12 <Lokathor> for example, i got home just now and the hexchat window had a notification effect on it, but the message that pinged me was no longer in the history buffer, so i will never know what it was about, and can't respond to it
21:12:26 <EvanR> plugin
21:12:46 <Lokathor> poo
21:12:52 <thang1> /plugin/
21:12:58 <thang1> *plugin intensifies*
21:13:20 <dyreshark> i think you could solve this problem with unsafePerformIO
21:13:29 <thang1> I have a plugin that turns all >text into green meme text because I'm stupid like that
21:13:49 <dyreshark> 03>what about the >text i turn into the green meme on my own?
21:13:49 <thang1> s/plugin/simple regex filter/
21:14:08 <thang1> That's actually dark red to me... But anyway, it'll show up fine, I guess?
21:14:18 * dyreshark shrugs
21:15:17 <thang1> anyway see y'all. Time to journey to my girlfriend's house
21:26:08 * hackage hpack-convert 0.14.7 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.7 (yamadapc)
21:27:07 <ADG> I have a function `Int -> IO Int` how to check x = f(f(x))
21:28:53 <edwardk> ADG: you'd need to know _something_ about what it does. it isn't exactly safe to probe in that form
21:29:17 <ADG> It reads a textfile of primes and then returns the sum of divisors using that
21:29:40 <ADG> I had to make it IO Int because generating primes was quite tedious and slow rather than directly reading them
21:29:49 <edwardk> might make sense to split it into two parts, one being the 'read the file' part and the other being the 'use the file part'
21:30:02 <edwardk> then you can test the latter using something more like quickcheck, etc.
21:30:33 <ADG> indded I have a function `getPrime :: [Int]` and `f :: Int -> Int` which uses get Prime
21:31:30 <jle`> ADG: is 'f' the Int -> IO Int   ..?
21:31:43 <ADG> let me paste it... w8
21:32:35 <edwardk> anyways if you have getPrimes :: IO [Int]   and f :: Int -> IO Int  because f x = f' x <$> getPrimes  you could factor out the call to getPrimes and test f'
21:33:24 <ADG> Here it is https://hastebin.com/asufamodux.hs
21:33:52 <edwardk> do you mean product of divisors?
21:35:51 <edwardk> modify sumOfproperDivisors n = do   to take 'primes' as an input and then you can test it as a pure function
21:36:08 <edwardk> what you are passing to 'return' is the function you want to test
21:36:35 <edwardk> hard to exhaustively check of course, but you can quickcheck, smallcheck, etc. it
21:36:54 <edwardk> each of those will help you gain confidence in its correctness
21:40:08 * hackage hpack-convert 1.0.0 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-1.0.0 (yamadapc)
21:49:53 <Lokathor> do many people find "do-blocks" distracting?
21:50:03 <Lokathor> i'm reading a blog post where at least one person does
21:50:13 <erisco> I avoid them where I can
21:50:31 <EvanR> the phrase "do-blocks" ?
21:50:49 <Lokathor> they present "(+) <$> Just 4 <*> Just 5" as an example, which to me is a borderline gross expression that i'd rather have in do notation most of the time
21:51:05 <erisco> those are not equivocal
21:51:17 <EvanR> liftA2 (+)
21:51:18 <erisco> your example requires only Applicative whereas do requires Monad
21:51:36 <EvanR> unless you have ApplicativeDo
21:51:36 <Lokathor> well ignore that for one moment, since Maybe implements both :P
21:51:59 <erisco> yes, unless you have that :)
21:52:25 <erisco> but that's not even how you'd see it
21:52:36 <Lokathor> it's not?
21:52:37 <erisco> you're more likely to see  (+) <$> x <*> y
21:52:47 <erisco> or as EvanR said  liftA2 (+) x y
21:52:56 <Lokathor> hmmm
21:53:14 <pavonia> I find do-bocks distracting when they introduce unnecessary boilerplate (as they would in the example about)
21:53:15 <erisco> no one is going to write the expression you gave because they'll just simplify to Just 9 ;)
21:53:19 <Lokathor> well I guess just I'd never write it like that :P
21:53:33 <erisco> if we're talking aesthetics of syntax it matters
21:53:37 <Lokathor> erisco, it's just an example after all :P
21:53:43 <ADG> how to get words from "apple","ball","cat", something like `wordsBy (not . isLetter)` ?
21:54:42 <Lokathor> pavonia, can you elaborate on the word "distracting"?
21:54:44 <EvanR> or perhaps aesetics of syntax
21:55:38 * hackage stack-run 0.1.1.4 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.1.4 (yamadapc)
21:55:43 <Lokathor> i would often like to see it as a 3 line block myself.
21:56:38 <pavonia> Lokathor: It's like when I read a do-block I expect something with monads, but often ist's just an Applicative expression bloated with additional variables
21:56:39 <Lokathor> yamadapc, what are the odds that stack-run will ever switch to haskeline instead of vty?
21:58:11 <Lokathor> pavonia, fair point. I'm perhaps guilty of having very "vertical" haskell code
21:58:31 <Lokathor> lots of lets, lots of expressions that could probably be compressed down
22:02:23 <pavonia> Clearly a matter of personal preference. But I've also seen things like "do { x <- doSomething; return x }" being used a lot in package code (probably for consistency with other code) which I found somewhat confusing
22:02:50 <Lokathor> i catch myself doing that, and cut it back down
22:03:20 <Lokathor> i think, possible, that block *used to be* bigger with more in between
22:03:33 <Lokathor> and iterations cut it down until they forgot to do the final cut down
22:07:53 <Cale> pavonia: It makes sense if you expect to add additional actions there
22:11:50 <pavonia> Hhm, I would probably still skip the do-block then until the additional actions actually have been added
22:13:31 <jle`> Lokathor: do blocks are sometimes more readable and sometimes less readable
22:13:59 <jle`> ^ pavonia
22:14:10 <jle`> it's not an always better or always worse kind of thing
22:14:45 <Lokathor> I'm not often writing code where I can imagine how to write it without a do block
22:14:56 <Lokathor> because i end up writing big batches of IO code
22:15:50 <jle`> `(+) <$> x <*> y` is probably more readable because it doesn't introduce extra points
22:15:58 <jle`> compared to the do block version
22:16:06 <jle`> or liftA2 (+) x y
22:16:15 <jle`> the points here would mostly be line noise
22:16:22 <jle`> but sometimes extra variable names make things more readable
22:16:42 <Lokathor> well yeah
22:16:54 <Lokathor> i almost never think about Applicative >_>
22:17:30 <EvanR> lots of things turn out to be applicative
22:17:54 <EvanR> anything you can thing of zipping is a kind of applicative in that way
22:18:10 <EvanR> any functor you can think of zipping
22:18:17 <Lokathor> uh
22:18:18 <Lokathor> hmm
22:18:30 <Lokathor> let's get out my most recent haskell example
22:18:59 <Lokathor> oh no
22:19:01 <Lokathor> lpaste is being slow!
22:19:06 <Lokathor> 504!
22:21:13 <Lokathor> https://gist.github.com/Lokathor/75dfac554bae514fd1e32a9385441027 alright EvanR, I invite you to advise me on any Applicatives I'm missing out on
22:22:23 <halogenandtoast> Why does lpaste frequently seem to have issues.
22:22:30 <halogenandtoast> s/./?/
22:22:44 <Lokathor> you can only ask so much of the gods
22:22:47 <Lokathor> they have their ways
22:22:55 <EvanR> Lokathor: most of this code is basically FFI
22:23:18 <Lokathor> EvanR, I could pick another example, but I end up writing a lot of FFI crap I think
22:23:36 <EvanR> youre not really using any data structures except IO (which is applicative) and Ptr
22:24:54 <Lokathor> well this is my problem i suppose
22:26:33 <EvanR> youre doing OpenGL so theres not any obvious ways to do any abstraction here
22:26:48 <EvanR> i mean, theres making a DSL for shaders, which exist
22:26:57 <EvanR> but thats not even what your code is concerned with
22:27:16 <Lokathor> yeah once i've done more i'll probably throw some abstractions on. at the moment i want it to look as close to the C++ examples as possible for when i need to fix bugs
22:27:36 <EvanR> youre in the crunchy outer shell of the app at this point
22:27:46 <EvanR> you want to get to the nice pure interior ;)
22:27:51 <jle`> Lokathor: on line 52, those let things can be where declarations
22:28:57 <Lokathor> jle`, i've experimented with "where" a few times
22:29:04 <jle`> line 60-62 can be `(,) <$> newArray [linesPtrs] <*> newArray [linesLength]`, or `liftA2 (,) (newArray [linesPtrs[) (newArray [linesLengths])` i suppose
22:29:05 <Lokathor> usually drift back to let
22:29:30 <Lokathor> ah, now that's interesting
22:29:43 <jle`> not that it's a huge gain
22:29:45 <EvanR> thats stretching.. but its definitely an example of applicative syntax
22:29:46 <jle`> since you're already in a do block
22:30:07 <jle`> but, it prevents you from thinking of frivolous names like linesPtrsPtr and lengthsPtr
22:30:13 <jle`> don't tell me that it wasn't painful to think of those names
22:30:24 <EvanR> gratuitous <$><*> where its "not appropriate" is a good way to frighten or annoy non haskellers
22:30:34 <Lokathor> what, i like those names >_>
22:30:37 <Lokathor> i like names on things
22:30:48 <EvanR> put a name on it
22:31:00 <jle`> names are usually good
22:31:05 <Lokathor> nomopihlia?
22:31:09 <jle`> some names are painful
22:31:29 <jle`> case x of Just x' -> case x' of Just x'' -> x'' + 3
22:31:29 <heath> is it really possible to get away with using https://hackage.haskell.org/package/extensible-effects and avoiding monad transformers? :)
22:31:31 <Lokathor> the best part about those names is that the GL docs are usually kinda bad, so I name my things what I'm actually attempting to do
22:31:53 <EvanR> what gl docs are you ready
22:31:57 <EvanR> reading
22:32:04 <Lokathor> jle`, sounds like time for (fmap.fmap.fmap) (+3)
22:32:11 <Lokathor> EvanR, the official spec ones
22:32:31 <EvanR> i mean, at least youre reading the actual docs
22:32:35 <heath> i'm curious what other opinions are on this
22:33:17 <Lokathor> as someone who lacks a period of C coding in their history, lots of C docs are all gibberish
22:33:54 <EvanR> i had the exact opposite experience back when i had no experience with C or pretty much anything
22:34:16 <EvanR> man pages and big library docs were very impressive by PHP standards (which i didnt even know yet)
22:34:23 <Lokathor> "const GLchar **string" is something i have to stop and think about every single time
22:34:40 <EvanR> that doesnt even look right
22:34:50 <Lokathor> that's an exact quote my buddy
22:34:58 <Lokathor> https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml
22:35:00 <EvanR> ill ask you again, what docs are you rea...
22:35:01 <EvanR> ok
22:35:24 <EvanR> ok now its right, missing context ;)
22:35:33 <Lokathor> :P
22:35:38 <EvanR> that argument is to return a pointer to an array of strings
22:35:44 <EvanR> welcome to C
22:36:07 <EvanR> ive been using these http://docs.gl/
22:36:11 <Lokathor> ah well
22:36:44 <Lokathor> i only need to look at the actual C stuff every once in a while if it's not immediately how the C++ tutorial should be in Haskell
22:36:54 <Lokathor> marashaling strings, fiddling pointers, etc
22:40:00 <Lokathor> https://github.com/Lokathor/pcgen-hs/blob/master/src/Data/PCGen.hs EvanR, this is the least-IO code i've written lately
22:40:52 <EvanR> i would use mostly where rather than let in there
22:41:42 <EvanR> besides that, its all numbers and nothing with the right kind to be applicative. If your generator could output random values of any type however
22:42:00 <Lokathor> i favor let over where because then it's all "forward", and also because do block are already using lets some of the time, so it's more consistent to me
22:42:11 <EvanR> its not really forward though
22:42:13 <Lokathor> EvanR, perhaps i'll never be applicative :P
22:42:17 <Mibaz> Anyone use "Haskeline"?
22:42:24 <EvanR> the way you wrote your lets are all mutually recursive
22:42:38 <EvanR> to get "forward" you need to do this
22:42:43 <EvanR> let x = foo in
22:42:45 <EvanR> let y = bar in
22:42:49 <EvanR> z
22:43:08 <EvanR> but theres not really any need in your code
22:43:12 <Lokathor> EvanR, they're.. not really? like that stepGen is a very literal translation from a C version, so i'm confident it's not mutually recursive
22:43:35 <EvanR> it totally is
22:43:43 <EvanR> if you rearrange the lines, itll still work
22:43:47 <Lokathor> Mibaz, I've looked at it a little. what's the question?
22:44:21 <Lokathor> EvanR, oh, well, they're orderless sure, but they're still not recursive.
22:44:22 <EvanR> > let {x = y + 1; y = 1} in x
22:44:24 <lambdabot>  2
22:44:26 <Mibaz> Lokathor: Trying to get at console keystrokes, but my value is wrapped in "MonadException". I can't for the life of me figure out where to go next
22:44:34 <EvanR> Lokathor: well, until you mess up and use a variable name twice ;)
22:44:46 <EvanR> you get recursion instead of shadowing
22:45:07 <Lokathor> Mibaz, MonadException is a class, you're actually working within some monad that implements MonadException
22:45:16 <EvanR> > let {x = y + 1; y = x + 1} in x
22:45:20 <Lokathor> probably InputT, in this case, wrapped over IO
22:45:22 <lambdabot>  mueval-core: Time limit exceeded
22:45:55 <Lokathor> care to make a paste of your situation?
22:46:30 <EvanR> Lokathor: i tend to write complex algorithms out with a = answer where, and put the equations in order of "what will they want to know the definition of next"
22:46:50 <EvanR> but its not not having to worry about the order
22:46:55 <Lokathor> an earlier version of this exact library did that actually
22:46:58 <EvanR> also you can define functions easier that way
22:47:08 <EvanR> new functions with let is annoying
22:47:09 <Mibaz> Lokathor: Ah, right, it is a class. Are you asking me to paste or the other fellows here?
22:47:15 <Lokathor> next gen = outInt where ...
22:47:42 <Lokathor> Mibaz, you should paste the function you've got partly written, and any compile error if you have one
22:49:48 <Lokathor> lpaste is down, but a gist or a pastebin will also work
22:51:06 <Mibaz> Lokathor: I'll try the jist first:     :t runInputT defaultSettings (getInputChar "")       :: MonadException m => m (Maybe Char)      I'm trying to get at that Char.
22:51:28 <Lokathor> ah, a classic question
22:51:45 <Mibaz> gist* ;)
22:52:17 <Lokathor> so what you want to do is similar to the example in the docs
22:52:18 <jle`> Mibaz: it's polymorphic for all MonadExceptions
22:52:24 <jle`> Mibaz: so just pick an instance you want
22:52:33 <jle`> preferably a convenient instance
22:52:42 <Lokathor> http://hackage.haskell.org/package/haskeline-0.7.4.0/docs/System-Console-Haskeline.html the loop part there
22:53:09 <Lokathor> except you'll be getting a Maybe Char instad of a Maybe String out of the action of course
22:53:30 <Mibaz> Lokathor: Yeah, that's what I was trying to get done.
22:53:33 <Lokathor> then you can case match or whatever on the Maybe Char to get at the Char inside (when it's there)
22:53:48 <Mibaz> jle': How do I "Pick an instance"?
22:54:12 <jle`> kind of like sort :: Ord a => [a] -> [a]
22:54:16 <jle`> sort is polymorphic for any instance of Ord
22:54:23 <jle`> so what you gave can be used for any instance of MonadException
22:54:43 <Mibaz> jle': ah, got it
22:55:03 <Mibaz> Lokathor: Once I have the Maybe I can handle it. Let me look at that example again.
22:55:05 <Lokathor> https://gist.github.com/Lokathor/f67eff00afc705c963c4144044112e06 perhaps like this
22:55:14 <jle`> https://ghcguide.haskell.jp/libraries/haskeline-0.7.3.0/System-Console-Haskeline-MonadException.html#t:MonadException
22:55:26 <jle`> it looks like 'IO' is a proper instance
22:55:29 <jle`> so it can be an IO (Maybe Char)
22:55:54 <Mibaz> Lokathor: wow didn't know you could put type signatures in where clauses. Neat.
22:56:17 <EvanR> its a good way to figure out wtf ghc is talking about sometimes
22:56:31 <Lokathor> Mibaz, the signature just has to start at the same indentaiton as the definiton it goes with like with a normal func and GHC will accept it
22:56:40 <EvanR> otherwise what it infers from your where clauses may be nothing what you intended and you can be confused
22:56:55 <Lokathor> note that the signature on loop is also not actually required in this case, GHC can figure that much on its own if you want
22:57:53 <Mibaz> EvanR: That's how I spend most of my Haskell time tbh
22:58:11 <Lokathor> yes to what EvanR said, if your stuff starts stacking several layers deep it can be hard to understand what typo GHC has misunderstood and turned into a wild type
23:01:16 <Lokathor> https://github.com/Lokathor/ludolib/blob/master/src/Util/PPFOV.hs EvanR here I'm using a little more data structure.. but I've gone and done the whole thing in ST so :/
23:02:56 <EvanR> not only are you now not only using unparameterized data structures, but they also unboxed ;)
23:03:37 <Lokathor> assuming you're using a data type that can be unboxed, is an Unboxed Vector somehow better than a Storable Vector? or is there no difference?
23:03:45 <Lokathor> for example, if you have Int
23:04:10 <Mibaz> Alright, I got it to compile. I'll hopefully understand it completely at some point.
23:04:13 <Mibaz> thanks guys
23:05:13 <EvanR> unboxed vector is for unboxed items, which is limited to primitives and unboxed tuples (i think), while storable vector works with any storable
23:05:35 <Lokathor> well i get that unboxed are a subset of storable, but does it go faster?
23:05:44 <Lokathor> otherwise, why have it at all instead of having only storable?
23:06:00 <EvanR> i looked into unboxed vector to see if your unboxed computations around it somehow avoid boxing Ints
23:06:14 <EvanR> i either didnt figure the answer out or the answer was, it doesnt and seemed pointless
23:06:35 <Lokathor> neato, i'll just stick to storable then
23:15:25 <wolfsif> anyone know if there are any physics libraries (2D or 3D) that don't resort to FFI bindings?
23:18:11 <wolfsif> I'd like to be able to do physics inside an FRP system, and having all the calls be unsafe would kinda defeat the purpose
23:21:03 <cocreature> wolfsif: I sadly don’t know of a pure Haskell implementation. can you explain why having the calls marked as unsafe causes problems for you? it seems like that should work just fine
23:21:05 <jle`> it would not necessarily defeat the purpose
23:21:18 <jle`> as long as it exports a pure API
23:22:04 <wolfsif> true -- although aren't all FFI calls impure?
23:22:12 <EvanR> or if it doesnt, because FRP could conceivably allow hooks into an impure system
23:22:28 <wolfsif> I'm looking at hipmunk, and the interface is certainly not pure
23:22:39 <EvanR> after all how else would `mouse' work
23:23:44 <conal> every "pure" operation in Haskell (e.g., Int addition) is essentially FFI'd and then declared pure.
23:24:40 <jle`> wolfsif: not necessarily
23:25:01 <jle`> pure API's can be implemented using FFI
23:25:13 <conal> if the foreign physics library has pure denotation, then declare it so. if not, wrap it in one that does. or maybe find a different physics library.
23:25:20 <jle`> and yeah, you can also itnerface with external IO sources in FRP as well
23:25:48 <conal> it'd be a shame to treat physics as imperative. it's naturally mathematical & continuous.
23:26:05 <EvanR> structure and interpretation of classical mechanics
23:26:23 <wolfsif> conal: yeah, that was my intuition, it seems there's no reason to have to do it imperatively
23:26:23 <conal> also, once you go imperative, you lose the compositionality and reasoning power of denotative/functional programming.
23:27:13 <conal> wolfsif: many libs package for imperative languages are imperative in nature, just by habit.
23:28:00 <wolfsif> i wasn't aware you can implement pure APIs using FFI though
23:28:02 <conal> and the imperative paradigm inescapably treats time discretely, and so doesn't fit physics.
23:31:42 <wolfsif> conal: what do you mean by pure denotation?
23:32:08 <jle`> wolfsif: like conal mentioned, almost all pure API's in haskell are implemented with FFI's underneath at some level
23:32:24 <ZuluKing> can someone help me use this: https://hackage.haskell.org/package/iCalendar-0.4.0.3/docs/Text-ICalendar-Parser.html ? 
23:32:57 <ZuluKing> I cannot understand how to use the parseICalendar function
23:33:35 <wolfsif> jle: yeah, that's interesting, I wasn't aware. can you point me to more info about how I might do that myself?
23:33:52 <cocreature> wolfsif: basically “unsafePerformIO” :)
23:33:54 <jle`> it's basically just FFI + unsafePerformIO
23:34:01 <wolfsif> ah i see
23:34:11 <jle`> reasoning with the purity is up to the person who designs/implements the API
23:34:33 <cocreature> in fact FFI was the original reason why unsafePerformIO was included in the haskell standard afaik
23:34:39 <jle`> the operations don't become magically pure because you use unsafePerformIO
23:34:48 <wolfsif> right, of course
23:35:01 <wolfsif> what happens if something goes wrong in a function you've wrongly declared pure
23:35:02 <jle`> but, if the operation *behaves* externally pure, then unsafePerformIO lets you 'declare' it to the world
23:35:11 <jle`> yeah, hence 'unsafe'
23:35:13 <conal> wolfsif: a denotation is a precise interpretation of a language, expression, type, etc as a mathematical value, e.g., function, pair, etc. what people often call the "pure" subset of Haskell is those parts that have such an interpretation/meaning/denotation. Haskell's IO & friends have no such denotation. They're essentially Fortran.
23:36:42 <cocreature> now we only need to make them as fast as Fortran and then Haskell can conquer hpc
23:37:13 <conal> wolfsif: functional programming was about giving programming a precise & tractable basis. So-called (misleadingly named) "monadic IO" is not functional in this sense and so muddied the waters.
23:38:17 <wolfsif> right
23:38:30 <ReinH> conal: hi
23:38:43 <conal> ReinH: howdy!
23:38:50 <ReinH> :)
23:39:09 <wolfsif> my understanding was that IO is basically a type constructor like any other, except for there is some magic going on underneath that allows interaction with the external world
23:39:30 <Cale> If you like, it's the execution of IO actions which is impure
23:39:32 <wolfsif> and now that you've pointed out that all pure functions are basically FFI calls + unsafePerformIO, that distinction seems less meaningful
23:39:35 <Cale> their representation could be pure
23:40:04 <cocreature> Cale++ the fact that execution is a separate concept in Haskell took me way too long to understand
23:40:31 <adarqui> anyone here good with esqueleto ?
23:41:03 <cocreature> adarqui: do you have some concrete question? if so just ask that directly :)
23:41:05 <mniip> how do I make ghci print kinds in explicit foralls?
23:41:24 <mniip> I'm currently at :set -fprint-equality-relations -fprint-expanded-synonyms -fprint-explicit-coercions -fprint-explicit-foralls -fprint-explicit-kinds -fprint-explicit-runtime-reps
23:41:29 <mniip> and it doesn't
23:41:44 <Cale> The monad operations and construction of IO actions doesn't need any effects -- it's carrying out the effects which are thus described which does. It's a little bit of a shame that IO is an opaque type (and internally implemented using low level hackery rather than some pure representation). Of course, it does probably buy us a whole bunch of good performance to do that hackery.
23:42:12 <Cale> But yeah, morally, it could be an algebraic data type much like any other
23:42:51 <wolfsif> Makes sense
23:43:20 <conal> wolfsif: it's that "magic" that I'm talking about. IO has an implementation but no denotation. If you only think about execution, and only in terms of an imperative model of computation, then it's hard to appreciate the fundamental divide between IO and the "denotative"/"genuinely functional" heart of Haskell (to use Peter Landin's terms). If instead you think about what programs mean in simple & precise math terms---independent
23:43:21 <conal>  from execution---it becomes much clearer.
23:43:55 <wolfsif> Right, that makes sense
23:44:32 <wolfsif> and you say "monadic IO" is a misleading term because 'monadic' kind of implies purity, and haskell's IO is not pure?
23:44:57 <MarcelineVQ> mniip: what are you examining?
23:44:57 <mniip> hmm
23:45:13 <mniip> not much just impredicative kind polymorphism
23:45:34 <Cale> I think "monadic IO" is misleading just because the fact that IO happens to be a monad is a bit of an afterthought to what it is.
23:46:25 <wolfsif> ah
23:46:25 <Cale> The more interesting distinction is that there is a type of IO actions at all -- the fact that you can implement the Monad operations is nice, but even if we didn't recognise this, there would be some other means of combination available.
23:46:27 <conal> wolfsif: "monadic IO" is misleading because it's not at all clear what it would mean for Haskell's IO to be a monad, let alone whether it's true.
23:46:39 <Cale> hm?
23:46:49 <adarqui> cocreature: trying to lpaste my stuff but lpaste is lagging ;d
23:47:10 <mniip> alright
23:47:13 <Cale> conal: IO can just be a free monad on a functor which is able to describe various primitive interactions with the outside world
23:47:13 <conal> wolfsif: because the monad laws are equational, and equality is undefined for IO.
23:47:14 <mniip> I'll just -dppr-debug
23:47:32 <wolfsif> ahh, that is true
23:47:33 <conal> wolfsif: for all types with a denotation, there is a natural notion of equality, namely equality of denotations.
23:47:50 <Cale> The IO type *can* have a denotation.
23:47:56 <adarqui> ok so i'll use hastebin: https://hastebin.com/elibewupew.vbs     so basically, i'm trying to figure out how to add some 'grouping' in my where clause, so i have the proper precedence and stuff with my query.. The esqueleto code at the top, becomes the first query
23:48:01 <adarqui> but the AND's are all grouped together
23:48:04 <conal> Cale: IO could be a lot of things, but it isn't.
23:48:05 <Cale> I could invent one which would be sufficient, anyway.
23:48:24 <Cale> By the same measure, Haskell hasn't had a denotation since Haskell 1.0
23:48:32 <Cale> since nobody's bothered to keep that up to date
23:48:55 <Cale> (which is sad!)
23:49:26 <mniip> can I TypeApplications on kind level?
23:49:32 <Cale> But in principle, it wouldn't be too hard -- certainly not a whole lot harder than giving any other aspect of the language a denotation.
23:49:37 <wolfsif> that is sad, I assumed there was some formal specification for everything except IO
23:49:42 <conal> The purpose of IO is as a repository for everything that we do not understand (denotationally) --- the "sin bin" as Simon PJ put it.
23:49:50 <wolfsif> hahah
23:49:54 <Cale> But then giving the *execution* of IO actions a denotational semantics, that would be something else.
23:49:57 <adarqui> maybe i can rework my query to get the desired result, without having the AND / OR grouping stuff
23:50:19 <cocreature> I think the deepspec people, specifically the ones at upenn are working on formal specs of at least GHC core
23:50:47 <conal> sure, one can give anything a trivial denotation that offers no insight --- essentially taking syntax and calling it semantics.
23:51:01 <Cale> Right.
23:51:13 <conal> remember, e.g., that IO is concurrent and non-deterministic.
23:51:26 <Cale> Yep, I'm thinking of IO as being something like:
23:51:37 <wolfsif> conal: do you think IO, as implemented in haskell, should have been done differently?
23:52:03 <conal> having any old denotation isn't the important part. rather having a denotation that is precise, simple, and useful.
23:52:14 <Cale> data IO a = Pure a | GetChar (Char -> IO a) | PutChar Char (IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
23:52:51 <mniip> hm, this is bad
23:52:57 <Cale> Presumably what you'd actually want to do is to find some basic FFI primitives which would be sufficient, and make constructors for those rather than really having GetChar/PutChar, but that gives some sort of idea
23:53:02 <mniip> impredicative polymorphism in kinds
23:53:26 <mniip> does neither work nor give you any sort of warning before exploding with an undecipherable type errror
23:53:38 <conal> Cale: yes, that's an example of trivial "syntax-as-semantics" denotation. which also applies to Fortran and C.
23:53:48 <Cale> That type will have a denotation which is still *somewhat* useful. More useful than nothing.
23:54:14 <Cale> and more useful than the CPP stuff, due to the fact that it involves the semantics of functions
23:54:26 <conal> Cale: remember that that data type has hundreds of thousands of constructors, growing all the time via FFI.
23:54:46 <Cale> You can still compute *some* things mathematically about the behaviour of IO actions, just from this quasi-syntactic level
23:54:55 <Cale> It's not quite the same as source-level syntax
23:55:15 <conal> wolfsif: in the 80s, we were really searching for denotative understandings of I/O, OSs, etc. that progress slowed to a crawl with the invention of the current non-denotative alternative.
23:55:48 <Cale> conal: Well, you'd have some constructors which take descriptions of how FFI is to be done, and whose types depend on those descriptions. Probably needs a GADT
23:56:32 <Cale> You wouldn't just keep adding constructors really -- you'd just have some which were sufficiently general to capture the interface to C calls.
23:56:55 <Cale> I think Idris actually does this, doesn't it? Maybe not. I forget.
23:57:13 <conal> Cale: still, what you describe is just a side-stepping of denotation. all of those imperative operations/constructors are valuable exactly because their specific operation, and you're ignoring those specifics.
23:57:35 <Cale> Yes, what I'm suggesting does miss *most* of the point of talking about IO actions, to be sure.
23:57:53 <Cale> and usually you would want to strive for something better
23:58:20 <Cale> But while there are a lot of C libraries out in the world we might want to take advantage of, it does help to have a well-specified language to describe communication with them.
23:58:29 <wolfsif> Interesting
23:58:47 <Cale> I'd still like to see all this *properly* written out.
23:59:11 <Cale> rather than just existing informally in our mental models of what's going on :)
23:59:11 <wolfsif> I'm having trouble imagining what formal denotation for IO would even look like, intuitively it seems like a black box by nature
23:59:15 <conal> This is an old conversation, going back further than my old posts http://conal.net/blog/posts/the-c-language-is-purely-functional and http://conal.net/blog/posts/notions-of-purity-in-haskell .
23:59:26 <Cale> wolfsif: Well, did you see my fake data declaration?
23:59:33 <Cale> data IO a = Pure a | GetChar (Char -> IO a) | PutChar Char (IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
23:59:35 <wolfsif> No, I haven't
23:59:38 <wolfsif> oh, that, yes
23:59:52 <Cale> wolfsif: So that's rather oversimplified, but not by too much!
