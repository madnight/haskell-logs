00:00:10 <Guest19237> dysfun: run it
00:00:46 <dysfun> what, algol 60?
00:01:03 <dysfun> nah, i'm good :)
00:09:26 <v0latil3> pacak: thank you
00:47:15 <ph88_> can anyone give me a hint what i could do to get these parsing and conduit functions right?  https://bpaste.net/show/4d799bce2cd8
00:52:01 <bartavelle> ph88_: you could break the input in lines before running parseAndSelect
00:52:07 <bartavelle> that way you'd have line by line parsing
00:54:50 <bartavelle> or even just running plain attoparsec functions with CL.map btw
00:55:29 <ph88_> bartavelle, at the moment  selectColumn is a conduit  .. if i split it by line then each line will become a conduit as well .. but a conduit with only 1 value .. this is not what i want
00:55:47 <ph88_> i want 1 conduit with many Double values
00:56:17 <bartavelle> ph88_: there is a conduit for line splitting
00:56:27 <ph88_> where ?
00:56:51 <bartavelle> ph88_: http://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Binary.html#v:lines
00:57:23 <bartavelle> there's the same thing for Text
00:57:52 <ph88_> i'm working with ByteString
00:58:26 <ph88_> so i put  lines conduit   into    conduitParserEither parseLine .| selectColumn   ?
00:59:01 <bartavelle> I'm not sure what conduitParserEither does, is it supposed to apply the supplied parser forever on the input ?
00:59:26 <bartavelle> ie. is your problem that it's only applied once, or that you'd like to ignore the end of lines ?
00:59:37 <bartavelle> that is, what comes after the parsed data*
01:00:49 <bartavelle> brb
01:08:13 <ph88_> bartavelle, my problem is just that i'm parsing a single line at the moment as you can see on the paste on line 26. i wrote a parseFile function (line 6) but i haven't used it yet ..
01:08:27 <ph88_> https://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Attoparsec.html#v:conduitParserEither
01:09:54 <bartavelle> that documentation is unclear to me :)
01:12:04 <pacak> Suppose I have Prism' a (b, c), how do I apply Prism' b d to that to get Prism' a (d, c) ?
01:12:39 <dysfun> is Generic preferred over Data ?
01:13:04 <bartavelle> pacak, is that even possible? shouldn't the second be an iso ?
01:13:07 <pacak> dysfun: Generics are newer and faster.
01:13:25 <dysfun> faster? that's nice
01:13:58 <pacak> bartavelle: Hmm... I don't know if it's possible or not, but I can imagine how to implement that using primitives, at least for my case.
01:14:03 <bartavelle> no what I say is wrong
01:14:18 <bartavelle> i had it the other way around
01:14:58 <pacak> dysfun: Problem with generics - about compilation time is about cubic to data size.
01:15:12 <dysfun> wonderful
01:15:46 <dysfun> so every time i change the data structures i'm being generic about, i will get to wait a while to test them?
01:15:46 <pacak> 200 fields product time for a relatively simple deriving can easily take 5-10 minutes.
01:16:27 <dysfun> that doesn't sound very appealing
01:16:32 <pacak> Also yes, at some point ghc can say "screw you guys I'm going home" and will stop trying to optimize stuff.
01:17:04 <dysfun> well, i can see why they might for Data, but Generic is supposed to be new and shiny
01:17:23 <pacak> dysfun: Generics are usually nice. They misbehave if you do stupid things.
01:17:40 <dysfun> but how do we define stupid?
01:17:57 <dysfun> what are the parameters of this cubic slowdown?
01:18:56 <ph88_> bartavelle, this is my attempt to use the lines conduit   https://bpaste.net/show/3e7114ac6b49
01:19:22 <ph88_> it works but then when i want to pipe that into parseLine it stops to work
01:19:48 <dysfun> i.e. where is the tipping point between Data and Generics seeming like better options
01:20:25 <bartavelle> ph88_, please include your whole file so that I can play with it
01:20:26 <pacak> dysfun: 200 fields product type
01:20:48 <dysfun> so it's cubic on the number of fields in a single type?
01:20:50 <pacak> dysfun: data Foo a = Foo a a a
01:20:53 <pacak> that's 3
01:21:01 <pacak> dysfun: yes
01:21:16 <dysfun> but if i define 10 types of 10 fields, it's fine?
01:21:25 <ph88_> bartavelle, i would have to setup a new project
01:21:26 <pacak> if they are separate types = sure
01:21:35 <dysfun> okay. i can arrange for that to be the case
01:22:11 <pacak> Dont forget -O/-O1/-O2 otherwise performance will be ugh.
01:22:19 <dysfun> heh
01:22:20 <dysfun> yes
01:22:46 * dysfun has -O2 when the dev flag isn't set
01:24:37 <dysfun> what about algebraic datatypes? do i just add the total fields of the cases to approximate it or is it more complex?
01:25:09 <pacak> More or less. It's just if at some moment you see that your code takes ages to compile - you know what to blame.
01:25:21 <ph88_> bartavelle, i also think i loose line information this way
01:25:30 <dysfun> yeah, i'm just trying to get started on the right foot :)
01:25:44 <bartavelle> ph88_, yes, you do
01:25:57 <ph88_> that sux
01:34:14 <lpaste> bartavelle pasted “ping _ph88_” at http://lpaste.net/355182
01:34:23 <bartavelle> ph88_, ^^
01:34:37 <bartavelle> this one works because it drops eol
01:42:32 <muchoo> in what state if ghc crosscompiler for arm CPUs? is it usable?
01:43:02 <bartavelle> AFAIK, you don't get template haskell when you cross compile
01:43:03 <muchoo> i'm not even sure how to get stated.. i had to jump through hoops to get arm gcc working
02:22:00 <ertes-w> are there any alternatives to the 'language-bash' library for *generating* shell scripts?  an sh library would be good enough
02:22:22 <kuribas> muchoo: I think it would be very hard, if at all possible.
02:22:45 <muchoo> kuribas I see.. too bad
02:23:05 <kuribas> muchoo: you could buy a raspberry pi, and compile there...
02:23:23 <ertes-w> i would use language-bash, but it has a failing test case
02:23:25 <muchoo> oh, so it is crosscompiling part that is the issue?
02:23:33 <kuribas> yes
02:24:26 <bennofs> ertes-w: don't run the test suite? :)
02:25:23 <muchoo> this is for satellite receiver that runs linux. quad 1500 Mhz, 3GB of ram. not sure how i'd go about installing ghc on it though
02:27:03 <kuribas> muchoo: it seems someone did a succesful cross-compile: https://github.com/ku-fpg/raspberry-pi/wiki/GHC-Cross-Compiler-for-Raspberry-Pi
02:29:28 <ertes-w> bennofs: sure, but…  you know…  there is a reason why the test fails =)
02:29:49 <ertes-w> it's only about brace expansion, which i could live without, but still…
02:29:55 <bennofs> ertes-w: hmm
02:29:57 <bennofs> ertes-w: Test suite logged to: dist/test/language-bash-0.7.0-tests.log
02:29:59 <bennofs> 1 of 1 test suites (1 of 1 test cases) passed.
02:30:06 <bennofs> language-bash-0.7.0
02:30:16 <kuribas> muchoo: also this page: https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi
02:30:26 <ertes-w> bennofs: i guess it doesn't always fail
02:30:43 <muchoo> thanks for the links
02:30:46 <ertes-w> bennofs: https://github.com/knrafto/language-bash/issues/17
02:31:02 <muchoo> I'd really like to get ghc going. it is a shock going back to C or C++
02:31:16 <NickHu> How do I call a LoggingT IO a from another LoggingT IO a without runStderrLoggingT? What's the runLoggingT function supposed to do? I can't quite understand its signature
02:31:54 <ertes-w> NickHu: (>>=)?
02:31:57 <NickHu> I tried logger <- askLoggerIO, which gives me something I can pass to runLoggingT, but how can I pass the logger from the first function to the next
02:31:59 <mrkgnao> what exactly do you mean by "call"? if you have f :: LoggingT IO a, then a simple f' <- f inside a do block should work
02:32:36 <ertes-w> NickHu: (LoggingT IO) is a monad, so you can use (>>=) (or do-notation)
02:36:44 <mrkgnao> I think my reply may have been a bit flippant. :(
02:37:08 <kuribas> muchoo: just out of interest, what are you making?
02:37:40 <NickHu> This is the code I'm trying to make work http://lpaste.net/355185
02:37:55 <mrkgnao> NickHu: Once you have written a "complete" LoggingT IO a, you would use runLoggingT to "run" it and produce something of type IO a
02:38:08 <NickHu> This compiles fine, I just don't like the runStderrLoggingT there - is there a way to ask for whatever logger I already have in that do block and pass it along
02:38:14 <muchoo> kuribas channel bug removal plugin to prevent screen burn-in
02:38:34 <mrkgnao> NickHu: what is the type of askLoggerIO? IO Logger?
02:38:49 <kuribas> muchoo: for a tablet?
02:38:53 <mrkgnao> and what is the type of runStderrLoggingT?
02:39:23 <muchoo> kuribas for 65" oled =)
02:39:27 <NickHu> askLoggerIO :: m (Loc -> LogSource -> LogLevel -> LogStr -> IO ()) - it doesn't do anything at all in the code I linked
02:39:41 <NickHu> runStderrLoggingT :: MonadIO m => LoggingT m a -> m a
02:39:43 <muchoo> I suffered burn in issues on my old plasma set, so I am bit OCD about it
02:40:23 <kuribas> muchoo: ah cool!  Keep in mind that haskell needs a lot of memory, and isn't really suited for low memory, low speed devices.
02:40:29 <NickHu> This is in the monad-logger package
02:40:30 <NickHu> And I have getReact :: M.Map Text Text -> Maybe Text -> URI -> LoggingT (MaybeT IO) FacebookReacts
02:41:06 <julian_rubin> @pl \x y -> x y
02:41:07 <lambdabot> id
02:41:16 <muchoo> kuribas true.. think it will  be an issue with 3GB? obviously other things need to run on the box as well
02:41:55 <mrkgnao> NickHu: okay. I think you shouldn't have to use askLoggerIO in this function, as you've realised
02:41:56 <kuribas> muchoo: lol no... I was thinking a few MB
02:42:06 <muchoo> hehe
02:42:41 <NickHu> mrkgnao: Yeah..
02:42:43 <muchoo> yeah, "embedded" devices today are like top desktop models a few years ago
02:43:23 <mrkgnao> NickHu: so, does this not typecheck?
02:44:06 <NickHu> It does
02:44:12 <dysfun> muchoo: that depends. at the low end of the spectrum, things are often still powered by chips that don't support paging!
02:44:34 <NickHu> It just forces me to select the stderr logger in getReacts
02:44:35 <NickHu> Which is already in a LoggingT
02:44:44 <NickHu> So I'd rather do something like, pull the logger from this monad and pass it forward
02:45:24 <jchia> There's intercalate and words, but how can I split a comma-delimited string? I can't find anything in base. What's the cleanest way to get the splitting functionality? I'm not sure whether I want to use the 'split' package or MissingH package just because of this one function.
02:46:30 <jchia> Am I missing something from base?
02:46:30 <mrkgnao> the LoggingT (MaybeT IO) thing looks a bit suspicious to me.
02:46:48 <mrkgnao> what exactly do you want the monad to do? accumulate a list of results?
02:47:21 <NickHu> why?
02:47:48 <NickHu> Which one, in getReact or getReacts?
02:47:49 <dysfun> jchia: Data.List.break can be used recursively
02:48:34 <NickHu> I want getReact to be able to fail, short circuiting IO with Maybe monad, and to log this, and getReacts to have a list of results, with failures represented as Nothings
02:50:23 <jchia> dysfun: Thanks, so define my own split using break?
02:50:48 <dysfun> i think that's your best option without resorting to hackage, yes
02:52:13 <cris_> hi, i have a question about STM　ＢＡＮＫ　ａｃｃｏｕｎｔ　ｅｘａｍｐｌｅ，　https://hastebin.com/icoxuwotaf.hs
02:52:14 <mrkgnao> I mean, if you're not looking to do *logging* and just want to build up a list of results, you'd be better served with a (strict!) Writer monad.
02:52:14 <mrkgnao> NickHu: okay.
02:52:14 <mrkgnao> notice that the lift and runStderrLoggingT functions are sort of inverses to each other
02:52:17 <mrkgnao> one moves from LoggingT IO into IO, and lift moves back 
02:52:41 <cris_> ｈｏｗ　ｄｏ　Ｉ　ｄｏ　ｔｈｅ　”ｒｅｔｒｙ”　ａｓ　ｉｎ　ｔｈｅ　ｅｘａｍｐｌｅ？
02:53:08 <NickHu> mrkgnao: Yes, I understand that
02:53:43 * mrkgnao finds the A E S T H E T I C refreshing
02:54:09 <NickHu> Oh are you saying I can do something like fmap over mapConcurrently?
02:54:19 <mrkgnao> NickHu: there should be some way to lift the async concurrency functions into LoggingT
02:54:31 <kadoban> cris_: I think you might have switched to IME or something
02:54:31 <mrkgnao> yes
02:55:59 <mrkgnao> I'm not sure, but is there an analog of takeMVar/wait in STM? (Or would that break STM?)
02:56:11 <cris_> hi kadoban, the font is now fine
02:56:18 <kadoban> Yep, all better
02:57:12 <mrkgnao> lol, my terminal takes around a second to render the prompt if I'm in the GHC repo
02:57:37 <NickHu> mrkgnao: fwiw mapConcurrently has effectively the same type as mapM
02:57:58 <cris_> do you have any idea of the bank account example , most of the examples just said that STM will retry and wait, but when i try to draft the example in hastebin, it waits indefinitely and have error , without doing the second transfer action
02:58:04 <muchoo> :t mapConcurrently
02:58:05 <lambdabot> error: Variable not in scope: mapConcurrently
02:58:38 <NickHu> mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)
02:58:51 <NickHu> It's obviously not the same, but we're in the IO monad in this instance
03:06:54 <mrkgnao> NickHu: you might want to look at lifted-async
03:07:01 <mrkgnao> :where lifted-async
03:08:15 <NickHu> How would I restructure the last call using mapConcurrently from there?
03:14:00 <NickHu> I need some way of going from LoggingT (MaybeT IO) -> MaybeT (LoggingT IO)
03:14:50 <rightfold> NickHu: I think sequence
03:15:05 <rightfold> Maybe not. It's early.
03:15:59 <NickHu> Sequence doesn't seem to work
03:20:55 <mrkgnao> rightfold: hoist and friends?
03:21:47 <rightfold> http://stackoverflow.com/questions/41796511/swap-inner-and-outer-monads
03:23:58 <torstein> I'm getting some kind error when trying to instantiate a type class: http://lpaste.net/355186
03:27:24 <rightfold> torstein: class NotFinished (a :: State)
03:27:29 <rightfold> It defaults to Type
03:27:35 <torstein> ah okay
04:13:24 <ertes-w> NickHu: honestly i would dispense with the LoggingT altogether
04:13:55 <ertes-w> having a "logging monad" is much more complexity for little gain in most cases
04:19:04 <Faucelme> I have read somewhere that ContT should always be the outermost transformer in the stack or bad things might happen. Is that true?
04:20:23 <ertes-w> Faucelme: not really, but you need to understand the implications of transforming ContT
04:21:06 <ertes-w> MaybeT (ContT r m a) ≃ (Maybe a -> m r) -> m r
04:21:07 <ertes-w> pretty safe
04:21:31 <ertes-w> probably even safer than ContT r (MaybeT m) a
04:21:43 <ertes-w> because understanding what (<|>) does in the latter one is far from trivial
04:23:26 <Faucelme> Good, I was mostly concerned about breaking the monad laws, Not about non-obviousness :)
04:23:52 <ertes-w> i don't think that's possible with proper transformers
04:24:45 <ertes-w> there are some improper transformers like the original ListT, which doesn't always give you a monad, even when its argument is one
04:29:42 <robertkennedy> I really love stm
05:00:37 <quchen> Corollary. All monads beginning with »ST« are awesome.
05:00:39 <quchen> Proof: obvious
05:17:52 <ph88_> bartavelle, did you run that code that you paste for me ?
05:20:55 <ph88_> bartavelle, since you didn't put the many/some combinator on parseLine .. i think that code still parse a single line only .. 
05:22:33 <ertes-w> robertkennedy: you love haskell STM
05:23:28 <bartavelle> ph88_, yes I ran it, and it works
05:23:40 <ph88_> bartavelle, how does it go over multiple lines ?
05:23:47 * ertes-w can't find the documentation of ExtendedDefaultRules
05:24:39 <bartavelle> ph88_, conduitParserEither runs the parser as long as it gets input
05:24:57 <ph88_> oooh ok
05:25:38 <quchen> ertes-w: There are other languages with STM?
05:25:59 <quchen> Clojure, which has »unsafeIOtoSTM« around every STM action, sure
05:26:14 <quchen> But that’s it, no?
05:26:31 <quchen> I remember the C# paper that basically concluded that STM is impossible in C#
05:26:51 <ph88_> bartavelle, do you know how i can consume any leading spaces at the start of the first line at the file ? then on my parseLine parser i can consume spaces on the end of the line + new lines + spaces leading the next line with just 1 whiteSpace parser
05:26:51 <ertes-w> quchen: a lot of them do, but it's not haskell's super-STM
05:27:00 <ertes-w> quchen: it's really just "memory transactions"
05:27:12 <quchen> STM without transactional guarantees is … IO?
05:27:25 <ertes-w> quchen: you do get those, and you also get blocking
05:27:27 <bartavelle> ph88_, yeah, that's what I pasted should do
05:27:43 <ertes-w> but you don't get composable transactions, and you don't get the "orElse" monoid
05:28:12 <bartavelle> ph88_, parseLine does skip leading and ending spaces
05:29:14 <bartavelle> ph88_, skipEol skips the \n and \r
05:29:15 <ph88_> bartavelle, parseLine doesn't need to skip leading spaces if i can remove the first leading spaces in the file
05:29:40 <bartavelle> ph88_, I don't know how to only skip a single space with the conduitParseEither function
05:29:55 <ph88_> ok
05:30:20 <ertes-w> could someone briefly explain ExtendedDefaultRules?  either i'm completely stupid, or it's not in the GHC user guide
05:30:22 <ph88_> i think i can just run attoparsec first and then give the unconsumed part as input to conduit
05:30:50 <ph88_> anyway not really important to optimize so soon already :P
05:30:55 <bartavelle> ph88_, there should be a "drop" function in conduit
05:31:18 <ertes-w> in particular: when i say something like "default Text", how does it know that i mean IsString?
05:31:36 <bartavelle> ph88_,  if you wanna optimize it, I would suggest http://hbtvl.banquise.net/series/Efficient%20parsing.html
05:31:41 <bartavelle> (self promotion)
05:31:42 <ertes-w> *"default (Text)"
05:32:27 <ph88_> ok nice i put it in my source file to read later
05:32:39 <ph88_> first i want to finish the program and then profile it's performance :P
05:33:57 <ph88_> i'm impressed though :P
05:34:04 <ph88_> nice looking table in part 4
05:34:29 <ph88_> good job bartavelle 
05:35:46 <bartavelle> hehe
05:38:27 <robertkennedy> Are you guys saying the clojure STM couldnt ie encode TQueue?
05:42:37 <ertes-w> robertkennedy: not as far as i know…  clojure has the equivalent of TVar and 'atomically', but lacks the equivalent of 'empty'
05:43:26 <ertes-w> something like this, as far as i can tell, is impossible in closure:  readTVar v >>= check
05:43:39 <robertkennedy> What's the point of it then?
05:43:59 <ertes-w> well, technically it's still "STM" =)
05:45:31 <robertkennedy> In what way? I guess they could still gaurentee that something like `atomically $ writeTVar x 1 >> writeTVar y 2` won't see x as 1 unless it also sees x as 2?
05:45:47 <robertkennedy> also sees y, sorry
05:46:56 <ertes-w> yeah
05:48:06 <robertkennedy> Damn. Well, I accept the pull request: I love Haskell STM
05:49:42 <ertes-w> there are surprisingly many implementations of STM for surprisingly many languages, but as far as i know the "orElse" monoid is unique to haskell's STM
05:50:12 <ertes-w> which makes it insanely more powerful than pretty much everything else
05:53:19 <masse> ertes-w: and retry as well I think
05:53:54 <robertkennedy> How do other languages create "events", ie `b <- newTVarIO False; concurrently_ (threadDelay 100000 >> atomically (writeTVar b True)) (atomically (readTVar b >>= check) >> putStrLn "wait show")`
05:54:30 <ertes-w> MasseR: 'empty' alias 'retry' is the identity of the 'orElse' alias (<|>) monoid
06:39:59 <jabesed> regarding naming standards, the StudlyCaps convention seems to be recommended 
06:40:42 <jabesed> how do you use it though, when the first 'word' is supposed to be all caps (e.g. an acronym)?
06:41:05 <jabesed> for instance, a variable named BNF Form
06:41:18 <jabesed> BNFForm? BNFform?
06:41:55 <ertes-w> jabesed: BNFForm or BnfForm; the latter is often more convenient, because you can use your editor's word jumping
06:42:03 <ertes-w> if it supports camelcase
06:44:11 <jabesed> ertes-w: I see... hmm the later is much more readable too
06:44:17 <jabesed> latter*
06:44:31 <jabesed> guess I'll use that
06:48:09 <robkennedy> When people talk about free, is it in the context of wadler's theorems for free?
06:50:51 <quchen> Lots of things can be »free«.
06:51:03 <quchen> The term without context could be any of them.
06:51:48 <GreySunshine> Hello, I've been trying to setup 'interactive-haskell-mode' on haskell-mode from the haskell-mode documentation. I want it to suggest imports statements and suggest completions from the imported modules. Here is my .emacs file(http://lpaste.net/938582110887739392). I think line 10, 11, 12 does what I ask for but it doesn't work. How have you done it?
07:05:50 <ertes-w> GreySunshine: does the interactive shell start properly?
07:05:58 <ertes-w> i.e. can you load your module, ask for types, etc.?
07:08:30 <lambdafan> I want to do a project where I am measuring the similarity of two tweets. How similar is teet A to tweet B. I've familiarized myself with "In defense of MinHash over SimHash",  But I am still not certain if my use case favors minhas. Any thoughts?
07:12:35 <ertes-w> lambdafan: similar in what sense?  edit distance?  semantic similarity?  similar wording/punctuation?  …?
07:15:32 <lambdafan> ertes-w semantic similarity
07:15:33 <mathk> @pl (\f g x -> (f x) + (g x))
07:15:33 <lambdabot> liftM2 (+)
07:15:40 <lambdafan> ertes-w: semantic similarity
07:16:23 <mathk> @pl (\g x ->  x + (g x))
07:16:23 <lambdabot> ap (+)
07:21:12 <GreySunshine> ertes-w, I did not start the interactive shell. Now I did M-x haskell-process-load-file and it suggests functions from imported modules. It still doesn't suggest modules to import.
07:23:58 <ertes-w> lambdafan: then you need to study NLP and machine learning…  the modern approach to "these two people are talking about the same thing and making similar statements" is deep learning
07:24:36 <ertes-w> GreySunshine: ah, you want it to auto-import modules…  i don't know how to do that
07:26:03 <GreySunshine> ertes-w, Thank you, a part of it works and that is very helpful!
07:37:48 <jabesed> the most straightforward way to build extensible data types would be with a dummy field, e.g. data DExt ext = D | Ext ext  
07:38:23 <jabesed> so, e.g. for no extension one would define type D = DExt Void 
07:38:53 <jabesed> the obvious problem with this is nesting of data constructors 
07:39:43 <jabesed> so one could have DExt (D2Ext (D3Ext (D4Ext val)))
07:40:12 <jabesed> is there some extension that allows definition of synonyms to pattern a sequence of constructors?
07:40:58 <lyxia> pattern synonyms
07:41:25 <quchen> Or view patterns.
07:41:38 <quchen> Pattern synonyms are more modern, view patterns more compatible.
07:43:53 <jabesed> lyxia, quchen: thanks, I hadn't heard of pattern synonyms will look it up! I did look into view patterns a long time ago, a bit forgotten now, but didn't think it would apply here
07:44:03 <jabesed> will check it out
07:44:54 <quchen> jabesed: View patterns are like unidirectional pattern synonyms.
07:45:05 <quchen> Lenses+viewpatterns are roughly like pattern synonyms.
07:45:20 <quchen> s/lenses/prisms/
07:46:08 <jabesed> quchen: don't know prisms either... looks like I have a lot of catching up to do 
07:46:54 <quchen> jabesed: Then don’t worry about prisms.
07:47:00 <quchen> Just look up pattern synonyms. :-)
07:47:15 <jabesed> am I thinking correctly that this would be a sane way to go about defining extensible data types? 
07:47:41 <jabesed> i.e. dummy fields + pattern synonyms (to "get rid of" nesting) 
07:50:01 <jabesed> I've noticed there's more powerful approaches, e.g. using heterogeneous lists, but that seems overkill, particularly given my data types are already (fake) 'dependent' 
07:57:43 <jabesed> checked a tutorial just to see what prism was, funny how it talks about a "big clever hack" to simulate subtyping to share combinators for Lens, Prism, etc
07:58:28 <jabesed> funny since my need to extend data types somehow results precisely from the lack of subtyping in the language
07:59:08 <jabesed> I know subtyping affects decidability, but not having it available is also be a big pain :/
07:59:32 <jabesed> s/decidability/type inference
07:59:35 <byorgey> it's not a hack.  Subtyping really wouldn't help with sharing combinators for lens, prism, etc.
08:00:46 <jabesed> ok will have to see what is done, they don't go into details in the tutorial, just make that claim
08:01:50 <jabesed> this one by the way: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
08:05:02 <byorgey> I think that tutorial is far too apologetic.  "Oh, sorry, there's some complicated types, don't worry, it's just a big hack"
08:05:46 <byorgey> But the fact that you can express lenses in this particular way using higher-order functions is quite amazing and beautiful, and leads directly to the idea of generalizing to other sorts of things (prisms, traversals, etc.)
08:06:06 <byorgey> and the ability to compose them just sort of falls out for free.
08:06:37 <byorgey> The tutorial makes it sound like we started out wanting to compose these things, but we don't have subtyping, so we had to resort to this hack to make it work.  But that's not at all what happened.
08:06:56 <jabesed> got it
08:16:44 <NickHu> Is there a stdlib function that will roughly split a list into n lists?
08:17:52 <lyxia> nope
08:18:02 <MarcelineVQ> not in base that I'm aware of but you can craft one with unfoldr and splitAt pretty quickly if you'd like to give it a try
08:18:15 <MarcelineVQ> if not there's the split package
08:19:02 <quchen> ?hoogle chunksOf
08:19:02 <lambdabot> Data.Sequence chunksOf :: Int -> Seq a -> Seq (Seq a)
08:19:02 <lambdabot> Data.Sequence.Internal chunksOf :: Int -> Seq a -> Seq (Seq a)
08:19:02 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
08:19:05 <quchen> … roughly
08:21:07 <NickHu> That splits things into lists of n
08:21:31 <NickHu> Basically I have a bunch of actions, and I want to split them into n lists which I can pass to mapConcurrently (i.e. n worker threads)
08:22:33 <quchen> NickHu: You can use semaphores to implement a work limiter as well.
08:22:51 <quchen> All threads will be forked, but only N are allowed to work concurrently.
08:22:58 <quchen> The others block.
08:23:14 <quchen> ?hoogle Sem
08:23:14 <lambdabot> SDL.Raw.Types type Sem = Ptr ()
08:23:14 <lambdabot> module Data.Semigroup
08:23:14 <lambdabot> Data.Semigroup class Semigroup a
08:23:18 <quchen> Hmm.
08:23:30 <NickHu> quchen: Does that fit nicely with mapConcurrently?
08:24:01 <NickHu> Mm, I see it now
08:24:04 <quchen> NickHu: Yup. 
08:24:15 <NickHu> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent-QSemN.html this package?
08:24:31 <NickHu> I don't need to worry about spurious wakeups in haskell do I/
08:25:03 <quchen> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent-QSem.html
08:25:17 <quchen> NickHu: Not with standard concurrency, no. With STM, yes.
08:25:42 <Bobopolis42> hi!
08:27:19 <quchen> NickHu: The standard scheduler has a notion of fairness, i.e. eventually all blocked things will get a chance to do some work.
08:27:41 <quchen> In STM, this is not the case: everyone is woken up at the same time and starts trying to work and annoys the other threads.
08:28:01 <quchen> »Stampending herd problem«
08:28:16 <jabesed> Are Lens and friends 'compatible' with 'dependently typed' structures? For instance, if I decorate the types of an AST with meta-types for the expressions it encodes, would it still be feasible to define the required instances for Lens et al?
08:28:46 <bartavelle> this discord library doesn't build for me, but in which world does it build? https://github.com/jano017/Discord.hs/blob/dev/src/Network/Discord/Rest/Prelude.hs#L77-L80
08:35:17 <lyxia> bartavelle: is there a reason you linked to these few lines specifically
08:35:41 <bartavelle> lyxia, yes, because they cause a compilation error, and because I don't know why the author had them working
08:36:08 <bartavelle> I mean, how
08:36:17 <MarcelineVQ> well how are you compiling it
08:36:30 <bartavelle> stack build, but how could that even work?
08:36:39 <bartavelle> Fetched has kind *, how can it be a functor ?
08:36:42 <lyxia> oh I see how can it be a functor
08:36:56 <lyxia> I mean, I see that this is absurd
08:37:10 <athan_> Hey all, I'm getting a GHC panic on 8.0.2 :\ - something like "translateConPatVec: lookup". Do you think I could fix it locally?
08:37:12 <bartavelle> ah, this is not some magic I know nothing about?
08:38:03 <bartavelle> lyxia, and for information, while this is a git repo, the latest hackage version has the same code, yielding to the same error
08:39:47 <lambdamu_> athan_: Do you have minimal example?
08:40:07 <lambdamu_> athan_: It's certainly possible to work around GHC panics in most cases
08:40:49 <lambdamu_> athan_: If you know what causes them, it would also be nice if we had report for it on the bug tracker
08:40:59 <lyxia> bartavelle: yeah, this is a mistake on their part
08:41:07 <MarcelineVQ> bartavelle: interesting, the commit that made that instance has a travis failure too :X
08:41:38 <bartavelle> MarcelineVQ, yeah, I noticed it too, why did they push to hackage :/ will file an issue
08:42:27 <black0range> Hello, is it possible to easily convert data types (ex: data Vec2 = Vec2 Int Int) to a pointer to a c array? :)  
08:43:30 <black0range> Whops messed up the last part of that sentence
08:44:43 <lyxia> black0range: http://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-Marshal-Utils.html#v:new ?
08:44:45 <bartavelle> black0range, I suppose it depends of what you mean by "easy" :)
08:46:39 <black0range> i was hoping for some kind of automagic :D 
08:47:36 <black0range> How are datatypes stored anyhow? I mean technicly the Vec2 example i did before could be the same of a c-struct with two elements in memory?
08:48:02 <bartavelle> black0range, no, because of lazyness
08:48:30 <bartavelle> black0range, then *I think* there is also a tag that identifies the constructor
08:49:39 <black0range> well thansk for the answer :)
08:49:39 <lambdamu_> black0range: well something like that is possible, with unpacked strict fields, but you have to watch out for the garbage collector and don't do stuff that breaks referential transparency
08:50:24 <lambdamu_> black0range: e.g. Data.ByteString.Unsafe has unsafeUseAsCString
08:50:28 <NickHu> quchen: It doesn't seem to work with mapConcurrently
08:50:36 <bartavelle> black0range, what's your C data type ?
08:51:37 <lambdamu_> black0range: it basically just pulls a pointer out, bytestrings datatypes are also pinned on the heap which isn't the default for data types
08:51:42 <NickHu> I guess they're not thread-safe semaphores... (why would that even exist?!)
08:52:26 <bartavelle> black0range, you could use http://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-Marshal-Array.html#v:newArray  : store (Data a b) = newArray [a,b] if you don't want to bother writing the storable instance
08:52:59 <black0range> bartvelle: I was hoping to create vectors / matricies that i could send to opengl 
08:54:11 <Cale> black0range: See Storable and StorableArray
08:54:12 <bartavelle> black0range, aren't there already good opengl bindings for that kind of stuff ?
08:54:55 <lambdamu_> black0range: the vector package has unsafeWith which should be O(1), too, but I don't think the memory is pinned
08:56:00 <eugenez> Hello friends! Is it possible to shorten the following structure (list1 !! idx1, list1 !! idx2)?
08:56:52 <Taneb> eugenez, my first thought is, if you're using (!!) a lot, lists probably aren't the data structure you want to be using
08:56:53 <Cale> eugenez: Shorten, I'm not sure, but I would generally try rather hard to avoid using !!
08:57:02 <bartavelle> eugenez, (,) <$> (!! idx1) <*> (!! idx2)
08:57:10 <bartavelle> eugenez, ((,) <$> (!! idx1) <*> (!! idx2)) list1
08:57:14 <bartavelle> but this is longer :p
08:57:31 <black0range> bartville: Well for the standard stuff but there seems to be some problems for example when sending vetrtex data over. Theres of course the posiblity that I've missed something 
08:57:36 <eugenez> Yeah, I know about !!, i rewrote that part like three times, was waaay worse x)
08:58:04 <eugenez> but impossible to do away with !! imo
08:59:23 <Cale> eugenez: Well, maybe you can do away with the list itself? If you're doing random accesses, you'd rather have a Map or Array or something like that.
08:59:54 <bartavelle> black0range, I know next to nothing about opengl, except that there is a kmett package, which I expected to be at least partially working
09:00:27 <edwardk> both gl and OpenGL work these days
09:00:59 <edwardk> me shipping gl forced OpenGL to adopt the same approach we use in gl. which is parsing the spec to produce all the code
09:02:30 <edwardk> Er gl and OpenGLRaw
09:02:32 <eugenez> Cale: Thank you, I'll think about it! :)
09:02:52 <MarcelineVQ> impressive, does that get complicated with the arb and extentions?
09:02:57 <Grisha> hi everyone
09:03:04 <Grisha> I’ve got a newbie question
09:03:28 <Grisha> having a :: ReaderT Config (Maybe IO) Int
09:03:46 <mrkgnao> How do I get GHCi to print constraints "properly"? what that means, sort-of-arbitrarily, is that I don't want it to do All The Inference and reduce the constraints in a function's type as far as possible
09:03:50 <Grisha> a does some IO and the last step in a is a function call that returns Maybe Int
09:04:05 <edwardk> The OpenGL package remains nigh unusable
09:04:19 <Grisha> how to promote this Maybe Int result to what ReaderT Config (MaybeT IO) Int demands?
09:04:24 <edwardk> e.g. note how things like http://hackage.haskell.org/package/OpenGL-3.0.2.0/docs/src/Graphics-Rendering-OpenGL-GL-VertexSpec.html#TexCoordComponent have a ton of unexported internals
09:04:38 <edwardk> so if you run into a situation that the authors of OpenGL didn't expect, you're screwed
09:04:53 <edwardk> MarcelineVQ: yes. =)
09:05:09 <edwardk> gl is the largest package on hackage
09:05:29 <edwardk> it broke builds on windows because it exceeded command line length limits, etc. for a while
09:05:38 <mrkgnao> so, e.g. if I have (nullary) classes Super t => A t, Super t => B t, (A t, B t, D t) => C t, then I would like a function of type C t -> t -> t to not show up as (Super t, D t) => t -> t 
09:05:41 <edwardk> because of the sheer number of modules
09:05:47 <edwardk> we had to adopt shorter module names to fix it
09:06:08 <MarcelineVQ> ehe, does that spec approach extend to opencl? by which I mean do you know if there spec is consistent enough to do the same thing
09:06:12 <mrkgnao> edwardk: did you hear about the cargo NUL mess?
09:06:27 <mrkgnao> well, maybe not "mess"
09:06:37 <edwardk> MarcelineVQ:  not sure.
09:06:58 <edwardk> mrkgnao: yeah. cabal has had code to reject such package names for years
09:07:02 <MarcelineVQ> a person can do a number of tasks opencl does using opengl but it can be complicated from what I've seen
09:07:11 <lambdamu_> Grisha: I don't think ReaderT (Maybe IO) Int is a valid type
09:07:18 <kamyar> Hello fellows
09:07:25 <kamyar> Please help me fix this code part
09:07:26 <lambdamu_> Grisha: I mean ReaderT Config (Maybe IO) Int is a valid type
09:07:27 <kamyar> http://lpaste.net/355194
09:07:29 <merijn> Any stack users that can help me fix this test failure? https://travis-ci.org/bos/criterion/jobs/226556679
09:07:34 <mrkgnao> hmm.
09:07:37 <MarcelineVQ> using shaders for gpgpu computing I​ mean
09:07:43 <Grisha> lambdamu_: sorry, you’re correct, that should read `ReaderT Config (MaybeT IO) Int`
09:07:46 <NickHu> If I have a LoggingT (MaybeT IO) a, how do I go about actually detecting when the MaybeT IO has failed (Nothing), in order to log it? 
09:07:48 <ioer324> hello every one
09:07:59 <ioer324> how i learn haskell fast
09:08:00 <ioer324> ?
09:08:17 <edwardk> MarcelineVQ: https://www.khronos.org/registry/OpenCL/xml/ has a cl.xml
09:08:28 <merijn> Grisha: Probably something like "lift . lift . return" or something
09:08:32 <edwardk> assuming it is as consistent as the gl.xml we use in gl then yes
09:08:49 <glguy> merijn: lift . return should be return, right?:
09:08:49 <ioer324> everyone hear me?
09:08:50 <merijn> Grisha: retur to make it "IO (Maybe Int)" two lifts to lift through the transformers, or "liftIO . return" I suppose
09:08:59 <edwardk> MarcelineVQ: if you don't care about macs then its probably easier to use opengl compute shaders these days.
09:09:19 <Grisha> merijn: I’m trying it out
09:09:21 <mrkgnao> yes, ioer324. what have you read so far?
09:09:23 <merijn> glguy: Not if he has "Maybe Int" and needs "MaybeT IO Int" wrapped with something else
09:09:25 <mrkgnao> :where haskellbook
09:09:39 <edwardk> glguy: lift is a monad homomorphism, so yes
09:09:41 <mrkgnao> @where?
09:09:41 <lambdabot> Maybe you meant: where+ where
09:09:41 <glguy> merijn: lift :: IO a -> MaybeT IO a, not Maybe a -> MaybeT IO a
09:09:42 <merijn> glguy: He needs to get an "IO (Maybe Int)" first and lift that
09:09:42 <MarcelineVQ> edwardk: thank you, I'm just barely getting into this stuff again so anything is helpful
09:09:49 <mrkgnao> @where haskellbook
09:09:49 <lambdabot> http://haskellbook.com
09:09:57 <glguy> merijn: MaybeT :: IO (Maybe a) -> MaybeT IO a
09:09:57 <merijn> glguy: Right, which is why there's a return first
09:10:36 <merijn> oh, I suppose MaybeT, yeah
09:10:54 <lambdamu_> Grisha: lift . MaybeT . pure should work
09:11:01 <merijn> Anyway, "liftIO . return" is simpler
09:11:15 <Grisha> lambdamu_, merijn: thanks a lot guys
09:11:17 <edwardk> merijn: lift . return = return by law
09:11:22 <glguy> liftIO . return is return
09:11:28 <mrkgnao> edwardk: are there any places I can see `constraints` being used?
09:11:30 <edwardk> liftIO . return = return by law
09:11:42 <Grisha> lambdamu_, merijn: does this problem represent smell of bad type design?
09:11:43 <merijn> Clearly I'm too tired to say sensible things
09:12:05 <edwardk> liftIO (m >>=f) = liftIO m >>= liftIO . f
09:12:08 <lambdamu_> Grisha: not necessarily
09:12:08 <mrkgnao> I'm looking to do something like "guided instance resolution"
09:12:12 <edwardk> mutatis mutandis for lift
09:12:19 <lambdamu_> Grisha: if you do that all the time then yes
09:12:44 <edwardk> mrkgnao: hrmm. http://packdeps.haskellers.com/reverse/constraints
09:12:47 <Grisha> lambdamu_, merijn: thanks a lot guys, I’ve got to go now, you saved my back
09:13:32 <edwardk> http://hackage.haskell.org/package/folds-0.7.3/docs/src/Data-Fold-M.html#line-61 uses it
09:13:34 <merijn> Any stack users that know how this stack.yaml stuff is supposed to work that can shed a light on how to fix this failure? https://travis-ci.org/bos/criterion/jobs/226556679
09:13:45 <MarcelineVQ> edwardk: shucks son this compute shader is great, I'm way out of the loop, thank you
09:13:59 <edwardk> er actually that part uses reflection
09:14:22 <edwardk> MarcelineVQ: you can do some fancy fancy stuff with it
09:14:23 <ExpHP_> "error: No instance for (Control.Monad.Zip.MonadZip Vector)" <-- but it DOES have an instance...
09:15:18 <edwardk> MarcelineVQ: e.g. https://github.com/ekmett/vr/blob/master/shaders/poppy_scan.comp computes a poppy style succinct index in parallel using all your gpu compute units
09:15:41 <edwardk> and it can share code with the code that i use to use the index in normal gl https://github.com/ekmett/vr/blob/master/shaders/poppy.glsl
09:16:12 <merijn> ExpHP_: Are you sure? For example, are you looking at docs for the version that you're actually building with? If that instance was added in a newer version than you're using...
09:16:18 <edwardk> so for 3.15% space overhead i can compute an index that lets me do prefix sums on bitvectors in O(1)
09:16:51 <edwardk> ExpHP_: old version of vector?
09:16:51 <ExpHP_> merijn: It's possible since I'm using stack, I'll have to check
09:19:01 <ExpHP_> yep, I'm on 0.11, which lacks MonadZip. Damn
09:19:35 * ExpHP_ pokes at his cabal file and waits for explosions
09:19:59 <lyxia> merijn: the stack.yaml lists a very old resolver
09:20:09 <MarcelineVQ> edwardk: that little bit has given me at least 5 new subjects to examine that all seem immedaitely applicable for me, another good day in #haskell :>
09:20:20 <edwardk> heh
09:20:46 <ioer324> how write a game with haskell?
09:21:24 <merijn> lyxia: I'm unsure how to fix that, though. I don't actually have/use stack, so I keep patching issues one at a time as TravisCI outputs them, so I'm not sure how to update the stack.yaml or even whether I'm supposed to wrt the tests :)
09:21:56 <lambdamu_> ioer324: How would you do it in another language?
09:22:09 <edwardk> ioer324: there is a #haskell-game channel dedicated to the libraries folks are using in haskell to build game stuff, but in general like in any other language, you figure out what your game needs then bind to appropriate libraries for sound, etc.
09:22:22 <edwardk> there are more options for doing things entirely purely in haskell though, stuff like gloss
09:23:20 <merijn> lyxia: stack.yaml lists lts-6.1, so that seems fairly new?
09:23:20 <mrkgnao> btw, I'm getting a lot of mileage out of reflection for dabbling-around-with-elliptic-curves purposes
09:23:54 <mrkgnao> like adding points while deferring the actual choice of curve till later, etc
09:23:57 <edwardk> ExpHP_: the vector-instances package probably supplies an instance of Zip from 'keys' at that version
09:24:06 <edwardk> but sadly i dont think i thought about MonadZip
09:24:24 <mrkgnao> I have to think hard about how constraints and reflection interact.
09:24:45 <edwardk> mrkgnao: they work together with no headaches and no unsoundness issues
09:25:02 <edwardk> at least if you avoid Given and unsafeFoo
09:25:59 <ExpHP_> edwardk: looking at keys right now I must say that "zap" is the greatest method name ever
09:26:04 <edwardk> if you look at Data.Constraint.Nat in HEAD i use reflection like techniques
09:26:08 <edwardk> =)
09:26:40 <javjarfer> hi! edwardk, first thanks for everything you do for this and other communities, and second, have you ever looked inside all reactive libraries, they almost always do some kind of trick for hiding the node datatypes in the reactive tree
09:27:04 <javjarfer> have you ever wonderer if that need could be removed with the use of a dependent-map?
09:27:22 <mrkgnao> Ah. I'm thinking about how I can achieve some kind of controlled instance resolution with those. Trying to get something of type a :==> b be reflected to a globally available instance, etc.
09:27:53 <edwardk> i've looked at a bunch of them, but i confess i tend to avoid FRP as a technique as they just don't tend to scale to the problems i'm interested in. for simple guis and the like its fine
09:28:05 <mrkgnao> Can TH be used to enumerate all in-scope instances of a class at compile time? For, say, quickcheck-ish testing?
09:28:09 <kamyar> Please help me fix the code : http://lpaste.net/355194 
09:28:16 <edwardk> mrkgnao: oh, you want the internal hom for kind Constraint
09:28:34 <mrkgnao> wait, is that internal hom like the sheaf kind?
09:28:36 <edwardk> mrkgnao: i have support for that in my hask package, but you have to explicitly "lower" it to use it
09:28:53 <lyxia> merijn: the snapshot is older than the code-page library.
09:29:04 <edwardk> or am i misparsing you
09:29:38 <edwardk> in hask i have code for producing a type p |- q , where (|-) :: Constraint -> Constraint -> Constraint
09:29:51 <edwardk> is an implication arrow in the category of constraints itself
09:29:55 <mrkgnao> I mean, I want to construct instances "by hand" from other instances, and then make them available so that other stuff can use those instances
09:29:58 <edwardk> with eval, apply, etc. morphisms
09:30:29 <edwardk> mrkgnao: well, you have to be careful because its easy to violate the thinness of the category of constraints that way, what you are asking for it unsound in general.
09:30:30 <ExpHP_> ok good it looks like Vector 0.12.0.1 is still compatible with all of my 40-something dependencies \o/
09:30:38 <edwardk> er is
09:30:43 <javjarfer> edwardk, do you mean performance scaling?
09:30:49 <javjarfer> or model scaling?
09:30:51 <wayne> Prelude Data.Monoid> Product 10 `mappend` 40  
09:30:52 <wayne> Product {getProduct = 400}
09:30:53 <edwardk> javjarfer: performance
09:31:03 <wayne> why does this work, even if 40 isn't (Product 40)?
09:31:10 <javjarfer> edwardk, yes, that is normally the issue
09:31:16 <edwardk> wayne: there is a Num instance for Product
09:31:18 <ExpHP_> wayne it probably implements Num
09:31:23 <wayne> ah got it!
09:31:24 <wayne> thanks
09:31:25 <mrkgnao> I know, but how do I utilize the thinness? That's one of my biggest problems
09:31:29 <mrkgnao> I mean
09:31:44 <mrkgnao> I have "diamond"-shaped class hierarchies
09:32:15 <edwardk> thinness gets utilized every time you construct a Data.Set and don't have to stuff the 'Ord' dictionary into the Set, and can do hedge unions because its sound because every instance of Ord [[[[[[[Int]]]]]]] will be the same as any other
09:32:16 <javjarfer> edwardk, well, just for the record, I have found that almost always, they are constructed using some kind of type erasure technique to build a polymorphic tree
09:32:17 <mrkgnao> and I have trouble convincing GHC that it's the same however you descend them when my classes are MPTCs.
09:33:05 <edwardk> mrkgnao: um, i think you have some other issue, in general the thing you describe is perfectly sound
09:33:33 <edwardk> mrkgnao: have you seen: https://www.youtube.com/watch?v=hIZxTQP1ifo ?
09:36:17 <mrkgnao> What I'm fighting with isn't exactly what I described, now that I think of it. It's actually an overlapping instance problem with classes that have too many "free variables".
09:36:43 <mrkgnao> Idris has the problem I described; I confused the two. Sorry.
09:36:55 <kamyar> Please help me fix my code: http://lpaste.net/355194
09:37:45 <mrkgnao> kamyar: what's the problem, and what have you tried?
09:38:08 <mrkgnao> ekmett: the talk looks interesting
09:38:26 <kamyar> mrkgnao: See the error below
09:40:10 <kamyar> mrkgnao: I have pasted error below the code in the lpaste
09:40:43 <lpaste> lambdafan pasted “stack.yaml not pulling in dependency from github” at http://lpaste.net/7227508542654119936
09:41:12 <lambdafan> http://lpaste.net/7227508542654119936
09:41:31 <lambdamu_> kamyar: you use (||) which has the type Bool -> Bool -> Bool
09:41:39 <lyxia> lambdafan: I think this should be in extra-dep
09:41:52 <kamyar> lambdamu_: I wanted to omit if
09:41:59 <lambdamu_> kamyar: but the second argument you pass is certainly no Bool
09:42:47 <lambdamu_> kamyar: I believe it is IO something
09:42:53 <kamyar> lambdamu_: v is bool
09:43:16 <lyxia> merijn: you can use this stack.yaml instead http://lpaste.net/355195
09:43:25 <lambdafan> lyxia : I can put git commits in extra-dep?
09:43:52 <lambdamu_> kamyar: but if the result type of checkToken is IO a for some a you can bind the action you try to pass to (||) and use the result
09:44:09 <kamyar> lambdamu_: Ok u r right. How can I overcome this?
09:44:24 <monochrom> Use "if".
09:45:34 <Cale> kamyar: Run the action.
09:46:02 <Cale> If x :: IO Bool, then, in a do-block for an IO action, you can write b <- x and then b :: Bool in whatever follows.
09:46:03 <kamyar> Cale: What do u mean
09:46:20 <Cale> and the do-block as a whole will have type IO t for some other type t
09:46:39 <lambdamu_> kamyar: use res <- action; return (a || b) instead of return (a || b)
09:46:39 <Cale> (it'll be the same type as the action on the last line of the do-block)
09:46:56 <lambdamu_> kamyar: use res <- action; return (a || b) instead of return (a || action) i mean
09:47:00 <Cale> You mean return (res || b)?
09:47:03 <mrkgnao> Can TH be used to find all in-scope instances of a class at compile time?
09:47:05 <Cale> or something?
09:47:17 <lambdamu_> yes sorry very bad at writing code on irc
09:47:26 <glguy> mrkgnao: See 'reifyInstances'
09:47:36 <lyxia> lambdafan: I was wrong. try indenting the bit below "location".
09:47:50 <mrkgnao> glguy: thanks for the pointer
09:48:55 <glguy> mrkgnao: Try: Prelude Language.Haskell.TH Language.Haskell.TH.Syntax> mapM_ putStrLn $(lift . map show =<< reifyInstances ''Show [VarT (mkName "a")])
09:48:56 <lambdafan> lyxia: indenting had no effect
09:49:29 <Cale> kamyar: Now, if you really wanted to, you *could* return an IO action which could be run at a later time, but I'm going to assume you don't want that, and just want to do the test straight away
09:49:51 <lambdafan> lyxia: stack doesn't complain about stack.yaml syntax, it just ignores the entry (I think)
09:49:59 <Cale> kamyar: You should just do the conn <- ... and runRedis outside of the return, on the lines above
09:50:15 <lambdafan> such that, cabal has no way to recognize that lsh is a package
09:51:19 <lambdafan> this is the first time I've ever seen bad behavior from stack, I'm pretty sure I'm following directions
09:51:58 <lyxia> lambdafan: that's odd because my stack is complaining about the syntax
09:54:17 <lyxia> lambdafan: it's also complaining about the extra-dep field and ignoring the package. so perhaps your version of stack doesn't have good enough error messages? Try indenting and removing the extra-dep field.
09:54:23 <lambdafan> lyxia: can you give me a gist of your stack.yaml that you are using?
09:54:37 <lambdafan> my version of stack is the latest
09:55:03 <lambdafan> okay maybe not
09:55:07 <lambdafan> my version is 1.1.0
09:56:45 <lambdafan> alright installing stack 1.4.0
10:15:51 <Myrl-saki> @pl \f g x -> f (g x) x
10:15:52 <lambdabot> flip flip id . liftM2
10:16:06 <Myrl-saki> @pl \f g x -> f x (g x)
10:16:07 <lambdabot> ap
10:17:35 <merijn> lyxia: Adding the optparse-applicative thing won't fix the code-page error, I think?
10:18:06 <Myrl-saki> @pl \(n, x) -> (== n) . length . show $ x
10:18:06 <lambdabot> uncurry ((. (length . show)) . (==))
10:26:58 <uglyfigurine> Given data EitherOr a b = Hello a | Goodbye b, why can i do "Hello 2 :: (Num a, Fractional b) => EitherOr a b" but not "Hello 2 :: (Num a, Char b) => EitherOr a b"?
10:28:00 <merijn> uglyfigurine: Char is not a typeclass
10:29:17 <uglyfigurine> How would i express that its an EitherOr of Num or Char? 
10:29:32 <bartavelle> uglyfigurine: Num a => EitherOr a Char
10:29:53 <EvanR> Char is a type
10:29:57 <merijn> uglyfigurine: "Num a => EitherOr a Char"
10:30:00 <EvanR> one of the simplest ones too
10:30:09 <EvanR> :t 'x'
10:30:10 <lambdabot> Char
10:30:15 <EvanR> what you see is what you get
10:30:19 <merijn> EvanR: Not sure I'd call unicode characters anything resembling simple ;)
10:30:27 <uglyfigurine> How do i know if a type is a typeclass or a type?
10:30:35 <EvanR> unicode may not be simple but this data type is
10:30:55 <bartavelle> :t '❦'
10:30:56 <lambdabot> Char
10:31:02 <uglyfigurine> :t 2
10:31:04 <lambdabot> Num t => t
10:31:20 <EvanR> uglyfigurine: you can ask ghci for info on a capital word, like Char or Num
10:31:22 <EvanR> by doing
10:31:25 <EvanR> :i Char
10:31:26 <EvanR> :i Num
10:31:30 <EvanR> doesnt work in here though
10:31:41 <merijn> Anyone know how (on github) I can figure out who has commit access to a repo?
10:31:55 <uglyfigurine> so type classes are always defined with Class and types are data's?
10:32:10 <EvanR> if you own the repo, check settings, go to collaborators
10:32:21 <merijn> EvanR: Not my repo, no
10:32:35 <EvanR> then id be interested in the answer too ;)
10:32:53 <merijn> EvanR: I wanna figure out who to badger into merging a pull request and publshing a new version on Hackage >.>
10:32:56 <EvanR> theres a repo im ostensibly in charge of but dont own, and i cant even see the settings for it
10:34:57 <uglyfigurine> merijn: I am guessing Contributors is the list of people who did commit not the who has rights but that might help regardless
10:35:23 <uglyfigurine> note to self - use commas
10:35:33 <EvanR> push access is the collaborators list, and you cant see it without owning it, it seems
10:35:45 <merijn> uglyfigurine: Yeah, I know about contributors, but unsure how to figure out who, if any, has access to actually update the repo :)
10:36:32 <uglyfigurine> merijn: check past PR's. It may tell u who merged it
10:37:18 <merijn> Looks like it's only bos with commit access, so that doesn't bode well for the timeliness :)
10:39:59 <Rembane> merijn: Fork it! Revolution! Freedom! Beer!
10:40:19 <merijn> Rembane: But I don't even wanna maintain my own stuff, let alone someone else's :(
10:40:36 <Rembane> merijn: Fair enough.
10:40:38 <EvanR> merijn: the best people to be put in charge is people who dont wanna be!
10:40:40 <merijn> That's why I wanna get it merged, so I can start depending on it and let someone else worry about maintenance :p
10:41:07 <merijn> EvanR: That's already the case, bos is maintaining it and he's far too busy, that's the problem :p
10:41:45 <EvanR> then the board of shadowy figures will need to replace him, with you ;)
10:42:18 <uglyfigurine> #makehackagegreatagain
10:44:20 <merijn> I'd much prefer to stick to my unreasonable yak shaving via small, incremental improvements and let someone else deal with version madness :p
10:47:39 <codedmart> What is the best way to print a diff comparing vars?
10:48:34 <merijn> codedmart: I'm unsure what that means?
10:49:58 <codedmart> merijn: Something along these lines: https://gist.github.com/codedmart/9e2298df9ea3e2cfb1940832b715b162
10:50:22 <codedmart> I just want to compare and see what is different.
10:50:55 <merijn> Presumably some scary lens voodoo exists for that
10:55:56 <richardcq> Hi guys. I'm trying to rewrite a function that takes f :: a -> a -> [b] and gets head $ f x y into a function in point free style, but head . f ends up with type [a -> a -> b] and not type a -> a -> [b]
10:56:12 <Cale> (head .) . f
10:56:22 <Cale> But... just don't
10:56:23 <Cale> heh
10:56:44 <geekosaur> sometimes pointfree means comprehension-free >.>
10:57:58 <jle`> s/sometimes/in most cases
10:58:32 <richardcq> I'm not sure I understand why (head .) . f works the way it does. Doesn
10:58:41 <richardcq> doesn't head . :: b-> c?
10:58:52 <EvanR> :t (head .)
10:58:52 <ExpHP_> the evil apostrophe key strikes again
10:58:54 <lambdabot> (a -> [c]) -> a -> c
10:59:53 <EvanR> takes a function that returns a list and returns that function post-processed with head
11:03:07 <richardcq> Oh, I see. I was misremembering the type of (.). So (x .) :: (a->b) -> a  -> c and doing ((x .) . f) applies x to the a parameter?
11:03:59 <davean> richardcq: I feel it bears reiterating though "Don't do that"
11:05:13 <EvanR> someone in here was remarking that hlint should tell you when you are accumulating recursively and do a final reverse on it, that you should be done a right fold
11:05:31 <EvanR> im in this situation and now im wonder how to pull that off
11:05:33 <richardcq> I'm mostly doing it to get a better feel for the type system. I don't intend to maintain this code. Thanks though guys.
11:08:51 <EvanR> when my accumulator is of type ([A], Bool)
11:08:56 <Tuplanolla> @let (.:) = fmap fmap fmap -- You might eventually encounter this for the same purpose, richardcq.
11:08:57 <lambdabot>  Defined.
11:10:10 <Tuplanolla> > (negate .: (*)) 42 13
11:10:12 <lambdabot>  -546
11:10:50 <monochrom> EvanR: Ah that's much more complicated. The advice was for accumulator [A] simply.
11:11:01 <EvanR> hrm
11:11:15 <byorgey> EvanR: I think it depends on how you are computing the Bool.
11:11:21 <monochrom> Yeah.
11:11:26 <EvanR> monoiding at each step
11:11:30 <EvanR> with ||
11:12:12 <richardcq> Tuplanolla: Like if I wanted f ( g ( k x y z ) ) <=> ((f . g) .: k) x y z?
11:12:22 <monochrom> Sometimes you use flip on the monoid operator. But in general, it depends, don't feel bad if the advice is inapplicable.
11:12:38 <lyxia> merijn: I changed the resolver to a more recent one, containing code-page. optparse-applicative is another error that appears in the same error message on travis.
11:12:40 <byorgey> || is commutative so no flip should be necessary.
11:12:41 <EvanR> dangit im going to feel silly doing reverse
11:12:45 <Tuplanolla> It's just `f .: g = (f .) . g`, richardcq.
11:12:50 <monochrom> :)
11:13:20 <monochrom> Ah but || is not commutative in the face of bottom. (Operationally, in the face of laziness.)
11:13:30 <byorgey> good point.
11:13:43 <EvanR> im not going to have bottom
11:13:58 <richardcq> Oh, I see. 
11:14:06 <monochrom> But are you going to have laziness?
11:14:39 <EvanR> i will process the output list lazily, and when im done, check the bool
11:14:49 <monochrom> "friendly to bottom" is just a theoretical way to say "friendly to infinite list"
11:15:49 <monochrom> Watch this mathemagic:
11:16:01 <monochrom> > foldr (||) undefined (repeat True)
11:16:04 <lambdabot>  True
11:16:10 <monochrom> > foldr (flip (||)) undefined (repeat True)
11:16:13 <lambdabot>  *Exception: stack overflow
11:16:18 <monochrom> See what I mean?
11:17:28 <EvanR> when doing a basic loop in haskell leads directly to solving a web of related semantical nonsenses!
11:17:43 <Jonathan222> Hello. I am supposed to implement a function, that takes a list of anything and replaces every number with a 1 and everything else with a 2. Here is what i have so far: https://pastebin.com/05nCEUGh and i cant identifiy the problem.
11:17:49 <Tuplanolla> Nonsensices?
11:18:23 <Cale> Jonathan222: I don't understand the description of that problem
11:18:34 <Cale> Jonathan222: All the elements of a list in Haskell will have the same type
11:18:57 <monochrom> There is no "isNumber".
11:19:06 <monochrom> Haskell is not Lisp.
11:19:07 <Jonathan222> there is in Data.List
11:19:09 <Cale> Jonathan222: You could write a type class, something like:
11:19:16 <Cale> class Foo a where
11:19:17 <Tuplanolla> Clearly this calls for some `TypeRep`, Cale and monochrom.
11:19:21 <Cale>   foo :: a -> Integer
11:19:31 <Cale> instance Foo Integer where
11:19:34 <Cale>   foo x = 1
11:19:39 <monochrom> No, there is no "isNumber".
11:19:44 <LordBrain> Jonathan222, if you use lpaste, the bot posts the link for us
11:19:44 <Cale> and so on for other numerical types
11:20:03 <Cale> and similarly, add instances with foo x = 2 for some non-numerical types
11:20:05 <Unode> Hi guys, I'm getting a little bit stumped with some basic question. If I have 2 functions I'd like to call in a "do A and B" fashion how would you go about writing this? In particular I'm trying something along the lines of "bracket (A and B) (C) (D)"
11:20:08 <Cale> and then map that function over a list
11:20:17 <EvanR> monochrom: so can you still right fold this?
11:20:17 <Cale> But it's always going to result in a list of all 1's or all 2's
11:20:40 <monochrom> EvanR: I can, I just have to be careful about the operator.
11:20:43 <LordBrain> Unode, you can't do A then B?
11:20:59 <byorgey> Unode: what types do your two functions have?
11:21:07 <LordBrain> Unode, like, A>>B, not an option?
11:21:13 <Cale> Jonathan222: What are you actually trying to accomplish through this?
11:21:15 <MitchellSalad> Cale: data SomeFoo = forall a. Foo a => SomeFoo a
11:21:22 <MitchellSalad> Cale: that's clearly the answer to this beginner's problem ;)
11:21:33 <Cale> MitchellSalad: Well, might as well store the Integer results then.
11:22:01 <LordBrain> Jonathan222, is it possible the assignment expects to be given a list of strings?
11:22:14 <Cale> Jonathan222: Perhaps you want to define a data type which has various cases for different types of data that your list can hold?
11:22:34 <LordBrain> Jonathan222, and then to recognize whether the string contains numeric characters?
11:23:36 <LordBrain> Jonathan222, are you learning about typeable and dynamic?
11:23:46 <Cale> Actually, apparently the assignment is to take a single String
11:23:47 <Unode> LordBrain: byorgey A :: IO () , B :: (FilePath -> m a) -> m a
11:23:53 <Cale> and do things with the characters
11:24:02 <Cale> digits become 1, other characters become 2
11:24:34 <LordBrain> he said 'any type tho
11:24:35 <Unode> LordBrain: Checking if >> is an option
11:25:53 <LordBrain> i imagine it would be much more fun to teach yourself haskell than to learn in a class setting
11:27:28 <Cale> LordBrain: Yeah, he misspoke (gave me more details in PM)
11:27:46 <LordBrain> maybe if the assignments were organized into a video game where they give you more points and you level up or something
11:27:47 <Unode> LordBrain: fun is relative
11:28:21 <Unode> I've been going at it for a while it still looks far from "getting there".
11:28:41 <LordBrain> well i already knew several languages when i started on haskell i admit
11:28:52 <LordBrain> and that was like over a decade ago
11:29:01 <Unode> there's just too many things I don't know how to do and coming from an imperative background, my first approach tends to be wrong.
11:29:30 <LordBrain> okay, well, yeah, but thats the coolness of it too
11:29:35 <EvanR> yeah you either have to unlearn all that, or relearn what you know knowing more
11:29:48 <EvanR> which i liked
11:30:06 <Unode> well I guess I'll start liking when things "click".
11:30:25 <Unode> For now there's just too much w.t.f going on. And I don't mean function composition.
11:30:35 <LordBrain> hehe
11:30:50 <EvanR> wait till you get the "brain explode" sort of w.t.f.s
11:30:57 <MitchellSalad> Unode: yeah, been there (and btw, lots of people come to this channel and express very similar angst and frustration)
11:31:00 <LordBrain> well, start out by being purist... over time the imperative stuff becomes relevant again
11:31:01 <pikajude> EvanR: great movie
11:31:09 <MitchellSalad> how about let's get back to your specific problem? plenty of people are around to help
11:31:24 <Unode> MitchellSalad: yeah your example yesterday was plenty helpful, but to be honest I still don't fully get it
11:31:40 <Unode> but I guess that's also in part due to how the framework works.
11:31:46 <LordBrain> Unode, its probably the types really that are getting you, not the functionalness per se
11:31:46 <MitchellSalad> Unode: that's fine, I'm still here to clarify and/or give more examples... just ask
11:32:32 <Unode> LordBrain: well, right now it's really something as simple as how to chain two functions, one of which is simply IO (), inside a "bracket".
11:32:45 <Unode> It's part of trying to get a test to run on hspec.
11:33:01 <ExpHP> > let !() = assert False ()
11:33:02 <LordBrain> Unode, you can put a (do { function; function; function;}) as a parameter to bracket
11:33:03 <Unode> Let me paste the tiny example I'm trying to work at
11:33:04 <lambdabot>  <no location info>: error:
11:33:04 <lambdabot>      not an expression: ‘let !() = assert False ()’
11:33:13 <ExpHP> > let !() = assert False () in ()
11:33:15 <lambdabot>  *Exception: Assertion failed
11:33:16 <lambdabot>  CallStack (from HasCallStack):
11:33:16 <lambdabot>    assert, called at <interactive>:3:11 in interactive:Ghci1
11:33:26 <Unode> right, the { } syntax is also something I still haven't quite understood.
11:33:40 <LordBrain> okay
11:34:00 <ExpHP> > let () = assert False () in ()
11:34:02 <lambdabot>  ()
11:34:12 <Unode> when can you actually use the {}? Cause I've seen it in two contexts that seem different. As part of type definitions and in cases like the do you showed now.
11:34:30 <ReinH> Anywhere you can use layout.
11:34:43 <LordBrain> i dont wnat to go into that here, there's a nice right up somewhere you should read
11:34:54 <Unode> I read that {} is sort of like the curly braces in imperative languages and a replacement to indentation, but when I tried using this at an "maybe here it works" location, I couldn't get it right.
11:34:55 <LordBrain> its a simple substitution rule
11:35:19 <lyxia> it's also in the syntax for records
11:35:38 <EvanR> two different uses for { } correct
11:35:41 <Unode> lyxia: yes, that's what I was referring but didn't remember the right word.
11:35:45 <ExpHP> why on earth does GHC have a warning for patterns like () that bind no variables?
11:35:46 <EvanR> layout and record syntax
11:36:02 <Unode> ok, layout. Can you explain what that means exactly?
11:36:07 <pikajude> > case of
11:36:09 <lambdabot>  <hint>:1:6: error: parse error on input ‘of’
11:36:12 <pikajude> darn it lambdabot 
11:36:16 <mrkgnao> can reifyInstances be used with a multiparameter class?
11:36:21 <LordBrain> Unode, i only used the do{;} syntax here, because it is easier to convey on IRC than layout
11:36:23 <monochrom> ExpHP, there is human judgment and personal opinion glorified behind a lot of warnings.
11:36:32 <ReinH> @google Haskell layout
11:36:34 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
11:36:34 <davean> Unode: do {putStr "hello "; putStrLn "world!"}
11:36:44 <LordBrain> Unode, in most cases, in actual code, i'd use layout
11:36:48 <davean> Unode: not that I think I've ever seen it actually used
11:36:53 <mrkgnao> davean: ghc
11:36:55 <ExpHP> monochrom: I'm trying to figure how somebody could do that by accident though, and just can't think of anything
11:37:01 <davean> mrkgnao: I try not to look at SPJ's code
11:37:02 <Unode> LordBrain: what does "layout" mean. That's my question.
11:37:11 <gaze__> hey guys. what's the best way to implement a nanopass style compile in haskell, where the AST changes slightly from phase to phase?
11:37:18 <gaze__> I'm used to having one gigantic AST datatype
11:37:30 <Unode> (a link to some docs is also fine)
11:37:38 <LordBrain> Unode, it means haskell, like python, is sensitive to white space, you have the wrong number of spaces on a line, and it dont compile.
11:37:42 <MitchellSalad> gaze__: does this help, or not really? http://blog.ezyang.com/2013/05/the-ast-typing-problem/
11:37:42 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
11:37:45 <ReinH> Unode: I already linked you
11:37:49 <Tuplanolla> That sounds like subtyping, which is awkward, gaze__.
11:37:57 <Unode> LordBrain: so layout == indentation?
11:38:00 <ReinH> You can also Google "Haskell layout"
11:38:08 <Unode> geekosaur: thanks
11:38:13 <LordBrain> Unode, yeah, or "rules for indentation syntax"
11:38:18 <LordBrain> learn them
11:38:30 <EvanR> the translation of {;} back from newlines and tabs
11:38:45 <gaze__> MicheellSalad: Nah. That's for decorating ASTs
11:38:54 <LordBrain> i think most haskellers avoid tabs
11:39:01 <EvanR> oh right
11:39:05 <EvanR> not tabs, spaces
11:39:09 <Unode> I'm used to avoid them also, so I'm fine with that
11:39:18 <EvanR> i press the tab key and forgot im not using tabs ;)
11:39:18 <MitchellSalad> gaze__: ah, right. Hrm, would one AST per phase be so bad?
11:39:19 <ReinH> Newlines and indentation.
11:39:40 <lyxia> ExpHP: It looks very suspicious because the binding contributes absolutely nothing to the program, it is equivalent to not having it.
11:39:47 <MitchellSalad> gaze__: lots of boilerplatey 'AST1 -> AST2' conversions, but compared to alternatives, might be the most sane option
11:39:58 <ExpHP> lyxia !() can be bottom, but still warns
11:40:27 <lyxia> hm
11:40:33 <ExpHP> > let !() = assert False () in ()
11:40:35 <lambdabot>  *Exception: Assertion failed
11:40:35 <lambdabot>  CallStack (from HasCallStack):
11:40:35 <lambdabot>    assert, called at <interactive>:3:11 in interactive:Ghci1
11:40:40 <ReinH> gaze__: is the process monotonic? I.e., does it only add data to the AST?
11:40:54 <monochrom> To be fair, bottomness is not something you can easily conditional-branch upon.
11:41:10 <gaze__> ReinH: No. The end result is assembly, which for instance has no type information.
11:41:25 <ReinH> Ok
11:41:55 <lyxia> ExpHP: I guess the warning could be dropped in that case, and nobody got around to do it yet.
11:45:37 <Unode> ok so, and regarding my initial question, lets say I have this: http://lpaste.net/355197 . Is that the correct way of doing it?
11:46:31 <Cale> Unode: That's not even syntactically correct -- do-blocks aren't allowed to end in a let
11:46:44 <Unode> Cale: that's half of my question :)
11:47:04 <EvanR> do has to end in an expression
11:47:27 <monochrom> Also let is wrong there.
11:47:52 <Cale> Unode: withSystemTempDirectory takes a string (which is used as a prefix for the names generated), and then a function which accepts a FilePath (the temp directory created), and produces an action to be performed with that directory
11:48:10 <monochrom> Also, bracket (do {putStrLn "Before"; withSystemTempDirectory "custom.file"}) (putStrLn "After") action
11:48:38 <monochrom> Err nevermind, what Cale said.
11:48:43 <Cale> That now is syntactically correct, but doesn't typecheck :)
11:48:55 <monochrom> You know what? withSystemTempDirectory already uses bracket.
11:49:00 <Cale> yes
11:49:10 <Cale> You can wrap it in another bracket if you want
11:49:19 <Unode> yes an how do I go about keeping that function and passing it on to action?
11:49:32 <Unode> *and
11:49:55 <Cale> withSystemTempDirectory "custom.file" (\tmpPath -> action tmpPath)
11:50:13 <Cale> If you want another bracket, it can go on the outside or the inside there
11:50:17 <Mibaz> Hey guys; I just got an index out of bounds exception in Data/Vector/Generic.hs. How do I debug something like this?
11:51:11 <lyxia> Mibaz: try to get a stack trace https://wiki.haskell.org/Debugging
11:51:16 <Cale> Mibaz: look for places where you're explicitly indexing Vectors
11:51:58 <Unode> Cale: ok then maybe I'm misusing bracket but, what I want to get at is: show "Before", create the tmpdir, (eventually, copy a file there), run "action" on that tmpdir, cleanup everything even if 'action' fails.
11:52:39 <LordBrain> well, i dont know a canonical technique, but you can hide the index operator on import of Vector, and define your own that chains to the original (imported qualified) with a trace
11:52:47 <Unode> as part of the cleanup I'm also showing "After" just to be sure that that part of the code executes.
11:52:51 <LordBrain> ^ Mibaz, that suggestion wa for you
11:53:19 <ExpHP> I wonder if I should raise a bug about !().  I'm searching the tracker about unused patterns and don't see anything for this...
11:53:59 <Mibaz> Lyxia, Cale, LordBrain: Lyxia got it, my counting was off. Sorry for the ignorance I panicked ;) thanks!
11:53:59 <monochrom> Unode: You are not misusing bracket, you are not internalizing the fact that withSystemTempDirectory already does bracket for you.
11:54:37 <ExpHP> oh bother, there it is https://ghc.haskell.org/trac/ghc/ticket/9127
11:54:39 <Unode> monochrom: processing ....
11:54:53 <LordBrain> yeah, a lot of with functions uses bracket
11:55:39 <Unode> monochrom: so but if I want to "putStrLn" before entering that bracket (i.e. before the directory gets created), how should I go about it?
11:55:42 <ExpHP> actually, huh, that bug really only targeted wildcard patterns...
11:55:55 <Unode> LordBrain: yes, I read that in the docs.
11:56:28 <Unode> but got confused once I wanted to define my own "with..." function that needed to cooperate with withSystemTemp...
11:56:50 <monochrom> What Cale said, your extra bracket layer, and this time withSystemTempDirectory is the action.
11:57:09 <monochrom> f a = bracket (print before) (print after) (use withSystemTempDirectory here)
11:57:41 <Unode> ok, let me try that
11:58:39 <monochrom> Or copy and modify withSystemTempDirectory's source code.
11:59:07 <monochrom> God why did you choose one with such a long name? :)
11:59:35 <Unode> monochrom: call it withTmp
11:59:50 <Unode> monochrom: but really, modifying the code?
12:00:15 <MarcelineVQ> sure why not, there were other options mentioned first though
12:00:51 <Unode> ok, still trying it out. currently fighting with types.
12:00:58 <Cale> :t bracket
12:00:59 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:01:46 <Cale> The second (and third) argument to bracket are going to be a functions which receive the result of executing the action which is the first argument
12:01:50 <Cale> -a
12:02:18 <Cale> So you could have something like  bracket (print before) (\_ -> print after) (\_ -> ...)
12:02:38 <AWizzArd> What is the difference between type classes and Backpack? Both seem to offer a way to define an interface and let users implement specific versions.
12:02:41 <Cale> however, you probably just want to print the stuff before using do-notation, rather than bracket
12:02:55 <Cale> and the stuff after, well, if you're concerned with exceptions, you can use finally
12:02:58 <Cale> :t finally
12:02:59 <lambdabot> IO a -> IO b -> IO a
12:03:12 <monochrom> Yeah.
12:03:35 <monochrom> If you really want to use bracket in a meaningful way, learn from withTmp's source code.
12:05:32 <Unode> I used finally in one situation before. The docs pointed me that bracket handled the same scenario with slightly better chaining of functions.
12:06:33 <monochrom> I wouldn't thinking of it as a chaining issue.
12:06:47 <monochrom> bracket has many more knobs. That's what it is.
12:08:10 <Unode> :)
12:12:54 <lyxia> AWizzArd: http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/ see comments
12:16:48 <AWizzArd> lyxia: thx
12:17:56 <Unode> geekosaur: thanks for the link. I think I get it now.
12:20:26 <lyxia> AWizzArd: he also talks about this in the introduction of his thesis
12:26:36 <miviotros[m]> I wanted to play a bit with the state monad in a stack project yesterday. I was quite surprised to see that it does not exist in stackage. Why is that? I don't think it is deprecated but it is difficult to imagine what other reason could have lead to its omission. Am I missing something?
12:27:20 <lyxia> transformers is where you find State and it's on stackage
12:28:31 <miviotros[m]> So I should be looking for StateT, right?. Thank you. Can you explain why transformers?
12:28:42 <AWizzArd> lyxia: possibly I will have a look at that too.
12:29:23 <Geekingfrog> miviotros[m] because State is a simple specialisation of StateT
12:29:50 <geekosaur> State stopped being a standalone monad when mtl2 was released; it is now SateT Identity
12:29:59 <geekosaur> *StateT Identity
12:30:50 <dmj`> type State s a = StateT s Identity a
12:30:51 <geekosaur> because it was silly to have standalone State, Reader, Writer that weren't quite compatible with the transformer versions
12:31:29 <geekosaur> the next release fo transformers (or maybe mtl) will apparently have pattern synonyms to restore the old State, Reader, Writer names (currently mtl exports lowercase versions)
12:32:12 <miviotros[m]> so the same applies to reader and writer?
12:32:12 <miviotros[m]> ah, apparently yes
12:33:36 <Myrl-saki> Yayyy
12:33:48 <Myrl-saki> Whoops. Wrong channel. Sorry.
12:33:58 <MarcelineVQ> yayyy
12:33:59 <shapr> Myrl-saki: hey that fits here too
12:34:16 <Tuplanolla> No fun allowed.
12:34:23 <Myrl-saki> Happiness is off-topic.
12:34:54 * mrkgnao engages in loud tsk-ing
12:35:01 <Jonathan222> If im having a list of lists of lists of Integers, and i only want to concat the 2 inner parts, is there a smart way to do it? concat xs concatenates the outer parts.
12:35:20 <Myrl-saki> Jonathan222: fmap concat.
12:35:22 <mrkgnao> fmap concat?
12:35:38 <Jonathan222> thank you ill look into that.
12:36:32 <EvanR> in order to catch a SomeException, add my own string to the beginning of the message, and rethrow it, do i need to make a whole new Exception type
12:37:11 <mrkgnao> does anyone know how I can get my local haddocks to look as pretty as the Stackage ones?
12:37:37 <mrkgnao> is it some fpco-proprietary CSS?
12:37:52 <MitchellSalad> how can CSS be proprietary...?
12:38:16 <EvanR> CSS that works in your browser but not someone elses
12:39:24 <mrkgnao> I guess that could be made a thing.
12:46:49 <rblaze> :w
12:47:32 <ExpHP> :e rblaze <CR> ggdG
12:57:14 <EvanR> heh man... i used a continually being-killed watchdog thread to let my game do things during the time when the main thread is blocked on vsync, with sdl2
12:57:24 <EvanR> that ended up being a lot more complicated than i was hoping for
12:58:54 <EvanR> also the name userError is pretty bad, if it shows up anywhere
13:01:56 <Jonathan222> is there an easy way to simulate fmap when fmap itself is not (yet) allowed to use?
13:02:17 <EvanR> how is that possible
13:02:37 <MarcelineVQ> for lists fmap is known as map, so you can use that if you're familiar with it
13:03:32 <Jonathan222> well, we are allowed to use map and concat and with an input like [[[Integers]]] the 2 inner lists are supposed to be concatenated.
13:04:00 <Jonathan222> simply using concat concatenates the 2 outer lists, and map concat doesnt seem to work
13:05:26 <Jonathan222> nvm im stupid
13:05:29 <Jonathan222> solved itself
13:06:06 <Arizona6882> problems of the form -> "U can not USE" are really stupid
13:06:38 <Arizona6882> instead of creativity they pose constraints
13:07:06 <MarcelineVQ> sometimes, other times it forces you to show you understand the concepts, you can use traverse without knowing how to write it
13:07:21 <Cale> I don't know if I'd categorically agree with that -- there are many cases in which the exercise is to build something up from more primitive notions, and if you were allowed to use pre-existing things in the libraries, it would miss the point of the exercise.
13:08:23 <shiona> Arizona6882: well, a novice exercise might be "Implement map for lists". Being able to answer "map" does not require much thought on what's going on.
13:08:47 <shiona> (just a different wording for Cale's point, I assume)
13:09:09 <Ptival> is ekmett ever around? the package bound on hackage seems completely unbuildable :(
13:09:25 <johnw> Ptival: he is, more often in #haskell-lens
13:09:39 <johnw> or let him know via Twitter
13:09:56 <Ptival> johnw: thanks, will try to reach out!
13:09:56 <Arizona6882> Ptival: he was around 4 hours ago
13:10:10 <Arizona6882> Ptival: so ever does not apply :)
13:10:33 <Arizona6882> Cale: i did not see good problems of this sort, but bad patter is clearly visible.
13:10:50 <Ptival> Arizona6882: I didn't mean it as a bad "ever", was just wondering if he still came around here or not, w/o knowledge :)
13:12:33 <Arizona6882> Cale: some CT theorist would say that fmap is more fundamental than map.
13:13:38 <Arizona6882> i dont like whole premise of teachen somebody something by forbidding stuff
13:13:57 <Arizona6882> curious people will learn everything good themselfs, only small nudge is needed
13:17:40 <EvanR> ok, and now that i have exceptions even happening and crashing my program
13:18:00 <EvanR> how do i get some indication of where in the program it crashed from?
13:18:12 <EvanR> right now it says "Prelude.undefined" in my test
13:19:36 <MarcelineVQ> grep -r undefined src/
13:19:53 <EvanR> which may or may not actually work
13:20:29 <Cale> Yeah, don't use undefined.
13:20:44 <EvanR> well i dont get a choice of what bugs were written as
13:21:06 <EvanR> like division by zero in some arithmetic somewhere, is there no hope?
13:21:23 <Cale> When you find the package responsible, stop using that package, or fork it.
13:21:24 <MitchellSalad> EvanR: check out https://wiki.haskell.org/Debugging
13:21:24 <MarcelineVQ> that's a difference exception
13:21:55 <MitchellSalad> (specifically, section 1)
13:22:29 <MarcelineVQ> fire up a stack trace for a chance at a hint, ghci -prof -fexternal-interpreter
13:23:04 <EvanR> imagine the final program is running live, on a taco bell drive through manifest display. it has no bugs supposedly. then it crashes with an exception message. hopefully that message is helpful, but if its not, you have no idea what happened?
13:23:04 <MarcelineVQ> undefined is usually in your own source though, grep should catch it
13:23:10 <EvanR> i am not asking about undefined.
13:24:29 <MitchellSalad> EvanR: so would a stack trace be sufficient?
13:24:41 <MitchellSalad> or are you saying, "what if there's no stack trace and I can't re-run the program?"
13:25:13 <EvanR> a file and line number would be better than nothing
13:25:23 <EvanR> so profiled build
13:25:29 <EvanR> which will reduce performance right
13:25:53 <MitchellSalad> definitely
13:25:55 <EvanR> i guess this is how C fails too right
13:26:00 <EvanR> segmentation fault, thats it
13:26:19 <Cale> If you write a pattern match, you'll get a file and line number
13:26:33 <EvanR> well pattern match failure is one way to fail
13:26:55 <EvanR> im not sure i understand all the possible ways to fail
13:27:01 <Cale> There's also a package called 'loch-th' which uses Template Haskell to get you file and line numbers
13:27:17 <EvanR> hmm.
13:27:23 <Cale> It's generally better to write (\(x:_) -> x) than to write head
13:27:43 <Cale> because if that lambda fails, you get a much better message
13:27:55 <EvanR> ok, so that takes care of situations where you use a partial function and "know" it cant crash
13:28:27 <EvanR> wait, how is head implemented if not by pattern matching?
13:28:45 <MitchellSalad> head [] = error "Prelude.head: empty list"
13:28:53 <Cale> > head []
13:28:56 <lambdabot>  *Exception: Prelude.head: empty list
13:28:59 <EvanR> so it would be better to not define head [] ?
13:29:03 <Cale> > (\(x:_) -> x) []
13:29:05 <lambdabot>  *Exception: <interactive>:3:2-12: Non-exhaustive patterns in lambda
13:29:06 <EvanR> (and get warnings)
13:29:10 <Cale> No, that wouldn't fix things
13:29:32 <Cale> The point is that by implementing head in-place, you get a line number where the actual failure occurred
13:29:48 <EvanR> alright
13:29:50 <MitchellSalad> > catch (evaluate (head [])) (\(e :: PatternMatchFail) -> putStrLn "I'm alive!")
13:29:52 <lambdabot>  <IO ()>
13:29:55 <EvanR> so how about arithmetic errors
13:30:19 <Cale> Those are so rare, I don't have any special strategy for them
13:30:29 <EvanR> well, i see them all the time
13:30:37 <Cale> If there's a division by zero failure, I'll go to the one division in my entire application and fix it :P
13:30:38 <EvanR> i have a case and then error "its negative dummy"
13:30:58 <EvanR> so its better to replace that with (\(x:_) -> x) [] ??
13:31:16 <Cale> Nah, use loch-th to provide a good message there
13:31:31 <Cale> It'll also add the line number and file to the message
13:31:34 <EvanR> theoretically sounds good
13:32:04 <EvanR> i was trying to avoid TH due to cross compilation being experimental
13:32:06 <MitchellSalad> 'error' should give call stacks, too, these days
13:32:12 <MitchellSalad> > error "sup"
13:32:14 <lambdabot>  *Exception: sup
13:32:23 <MitchellSalad> on a new enough base
13:32:34 <EvanR> and on undefined?
13:32:43 <MitchellSalad> yeah, since undefined = error "undefined"
13:32:52 <EvanR> i guess that should solve it then
13:32:54 <ezyang> note that you stil need to have HasCallStack to get useful stacks 
13:33:14 <EvanR> im not sure i even see the point of a "full" stack trace
13:33:27 <Cale> A full "stack" trace
13:33:30 <EvanR> and HasCallStack
13:33:41 <Cale> I kind of hate that name actually
13:33:52 <Cale> It has nothing to do with a call stack :P
13:33:58 <EvanR> file and line number, if even that makes sense, is all we really should expect by default
13:34:13 <MitchellSalad> ezyang: my stack traces seem to exist even when I don't write HasCallStack in my code
13:34:39 <MitchellSalad> just running 'main = undefined' shows a stack trace, for example
13:35:03 <ezyang> yes, but do you get info about the caller? 
13:35:51 <MitchellSalad> ah, good point
13:36:12 <c_wraith> Cale, would you prefer PretendsToHaveACallStack? 
13:36:15 <EvanR> i tried throwIO from an sdl audio callback thread
13:36:33 <EvanR> surprisingly it crashed my program as if the except were raised in the main thread
13:36:41 <EvanR> i wonder how it did that...
13:36:47 <ezyang> this is why type IO a = HasCallStack => Prelude.IO a is magic!!! 
13:37:48 <MitchellSalad> haha
13:37:55 <Cale> c_wraith: :)
13:38:13 <Cale> c_wraith: I actually think it would be really cool to have a way to visualise the real stack
13:38:35 <Cale> i.e. as a sequence of mostly pattern matches
13:38:46 <MitchellSalad> ezyang: do you know if something along those lines is planned for a future GHC?
13:38:55 <c_wraith> isn't that supposed to be available by hooking into the DWARF debugging data? 
13:38:57 <MitchellSalad> having to write 'HasCallStack =>' everywhere is... yeahh
13:39:05 <Cale> c_wraith: Possibly, I have no idea
13:39:31 <Cale> c_wraith: But the real trick is preserving enough bits of the source code to render it in a nice way... maybe they do that, I don't know
13:39:46 <ezyang> no, because there is a nontrivial cost to passing an actual parameter 
13:40:11 <c_wraith> do debug builds pass that parameter everywhere? 
13:40:41 <MitchellSalad> you mean -prof?
13:40:57 <c_wraith> hmm, yes. that is all there is. 
13:41:27 <c_wraith> may be time to add a compiler flag to implicitly add HasCallStack to everything 
13:41:48 <MarcelineVQ> cafs cafs cafs spooky cafs at a distance http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
13:45:49 <EvanR> calls to error are often lifted to the top level as CAFs.. which breaks the stack trac simulation
13:46:18 <EvanR> its interesting that conceptually optimization is at odds with comprehensibility
13:46:46 <EvanR> people else where want both, and id like to settle for comprehensibility
13:47:06 <EvanR> and some people want optimization first
13:58:51 <istvan> I am looking to write a function that returns UUIDs but instead of random data I want an incrementing number. What is the best way to do that?
13:59:21 <EvanR> er, an incrementing UUID?
13:59:57 <EvanR> if you want the effect of a UUID but that increments, you can begin a counter at a random very large integer
14:00:12 <EvanR> and the ID is the digits of that number
14:00:51 <kuribas> Why do I get parse error line 26? http://paste.lisp.org/display/345818
14:01:03 <kuribas> I cannot find it (I must be getting tired...)
14:01:04 <istvan> EvanR, so I store that counter in global state and update its value?
14:01:17 <EvanR> i wouldnt store it in a global state
14:01:28 <EvanR> you want to pass around the generator somehow
14:02:21 <EvanR> but why do you not want to use UUIDs instead
14:02:29 <monochrom> Best of both worlds: Pass around global state :)
14:02:43 <kuribas> It says "Parse error in pattern replicatem_, probably caused by a missing do"?
14:02:49 <EvanR> down with the global state
14:03:16 <geekosaur> kuribas, I see a place where it does look like either you missed a do or you didn;t unindent
14:03:22 <istvan> EvanR, This is more of a thought excercise. Maybe UUID isn't really what i'm trying to understand how to do, even a number that increments from 0 would do.
14:03:28 <EvanR> ah
14:03:36 <kuribas> geekosaur: where?
14:03:42 <EvanR> right, this is a "supply" pattern
14:03:49 <MarcelineVQ> I
14:03:49 <geekosaur> after `graph <-`
14:04:08 <kuribas> geekosaur: right, thanks!
14:04:22 <MarcelineVQ> istvan: 've come across that pattern just recently and saw a really quite interesting take
14:04:46 <EvanR> istvan: the simplest possible thing is, if you have an infinite list of values. you can pattern match to take the next one and get the rest as the next generator state
14:04:59 <kuribas> geekosaur: bad error reporting from ghc...
14:05:04 <rcat> anyone knows if there is a HTTP/2 client available?
14:05:07 <EvanR> newId :: [ID] -> (ID, [ID])
14:05:34 <istvan> EvanR, how do you store the next generator state? I was hoping to write a module with a function getNextNumber or something of the sort
14:05:38 <MarcelineVQ> https://hackage.haskell.org/package/neet-0.4.0.1/src/src/Control/Monad/Fresh/Class.hs   instances defined here https://hackage.haskell.org/package/neet-0.4.0.1/src/src/Neet/Population.hs
14:05:56 <EvanR> yeah you can use basically a State monad as described in MarcelineVQ's link
14:06:02 <MarcelineVQ> another way is global IORef but this was cooler
14:06:14 <EvanR> the Supply monad has been around a while
14:07:30 <EvanR> https://hackage.haskell.org/package/monad-supply-0.6/docs/Control-Monad-Supply.html
14:07:49 <lambdamu_> http://lpaste.net/355200 this should be an injective type family, no?
14:10:00 <jle`> what the heck @ this Supply monad
14:10:20 <EvanR> yep
14:10:46 <jle`> peek and supply are partial for the instance for Supply and SupplyT
14:10:54 <EvanR> right
14:11:07 <EvanR> not Maybe
14:11:22 <EvanR> which is more convenient for supplies that never run out
14:12:22 <jle`> then StateT [s] m a is the wrong implmenetation
14:13:19 <EvanR> why
14:13:39 <jle`> `StateT (NonEmpty s) m a` at best
14:13:41 <jle`> *at least
14:14:02 <EvanR> then how would you know if it was empty
14:14:23 <EvanR> exhausted
14:14:37 <jle`> it is also a bad implementation but it is better :o
14:15:05 <EvanR> it kind of makes exhausted pointless, so youre really asking to redesign the API
14:15:13 <MitchellSalad> yeah this library is crap
14:15:17 <jle`> exhausted is not pointless for many instances
14:15:20 <jle`> just for that specific instance
14:15:48 <jle`> but at least it'd be total
14:16:15 <EvanR> evalSupply :: Supply s a -> [s] -> a
14:16:29 <EvanR> youd need to change that API
14:16:36 <jle`> evalSupply is literally partial
14:17:05 <EvanR> yeah
14:17:46 <EvanR> a version of this whole thing that is based on Stream would make more sense strictly speaking
14:17:59 <EvanR> the possibility of running out is a whole nother world really
14:25:52 <viran> Hey, a bit off topic, looking at lecture notes saying NFA that accepts L = {0} has two states. I figure out a 3 states NFA/DFA ... is it possible with 2 states?
14:27:21 <Tuplanolla> What does that notation mean, viran?
14:27:47 <viran> Tuplanolla: Language L, with one word "0"
14:28:21 <monochrom> Maybe "two states" doesn't include the reject state.
14:28:34 <monochrom> There is #haskell-offtopic if you like.
14:29:35 <EvanR> i dont see this function in the docs... Ordering -> Ordering which gets the opposite?
14:30:04 <Tuplanolla> Start in A, which is not a final state; on 0 move to B, which is a final state, viran.
14:30:40 <MarcelineVQ> EvanR: are you asking about Down?
14:30:44 <Tuplanolla> Nonexhaustiveness implies rejection.
14:30:45 <EvanR> no
14:30:54 <EvanR> foo LT = GT
14:30:58 <EvanR> foo GT = LT
14:31:58 <Cale> EvanR: compare EQ would do it, but usually you just flip the comparison function.
14:32:01 <viran> Tuplanolla: Thanks
14:32:09 <EvanR> oh duh
14:32:22 <EvanR> er
14:32:52 <monochrom> > compare EQ LT
14:32:54 <lambdabot>  GT
14:33:05 * monochrom jaw-drops
14:33:22 <panovia> > sort $ map Down [2,1,4,3,6,5]
14:33:24 <lambdabot>  [Down 6,Down 5,Down 4,Down 3,Down 2,Down 1]
14:33:25 <EvanR> compare arg1 arg2 = compare arg2 arg1 for the last leg of a Ord instance wont give the right answer
14:33:43 <EvanR> i have to compare arg1 arg2 = flipordering (compare arg2 arg1)
14:34:48 <EvanR> compare EQ is funny
14:35:00 <c_wraith> now I want a Sorted monoid wrapper so that sorting can be a foldMap 
14:36:46 <c_wraith> hmm. that works out to be a trivial bottom-left mergesort 
14:37:11 <c_wraith> thanks autocorrect. *bottom-up 
14:39:05 <c_wraith> well, no. it's only a bottom-up mergesort if you foldMap over a relatively balanced tree structure. over a list, it would be an insertion sort. woo, flexible sorting tech! 
14:39:22 <EvanR> flexsort
14:39:30 <EvanR> patent pending
14:40:11 <c_wraith> you can also use it to convert screen doors into boats. 
14:40:19 <monochrom> @type foldMap
14:40:21 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
14:41:31 <monochrom> So is it (Ord x, Foldable t) => (a -> Sorted x) -> t a -> Sorted x?
14:41:59 <c_wraith> yeah 
14:42:46 <c_wraith> and newtype Sorted a = Sorted [a], with appropriate instances and smart constructors. 
14:43:13 <c_wraith> that's probably already on hackage 
14:44:00 <EvanR> haskellisms win flawless victory
14:44:09 <jle`> would be useful with Writer too i suppose
14:44:34 <jle`> but, what you're proposing looks like it's just `Map a Int`, or multisets
14:44:54 <jle`> with the approprite Monoid instance
14:45:19 <c_wraith> http://hackage.haskell.org/package/sorted-list-0.2.0.0/docs/Data-SortedList.html oh there it is. 
14:47:17 <jle`> @let newtype MMap k v = MMap { getMMap :: M.Map k v } deriving Show; instance Monoid v => Monoid (MMap k v) where mempty = MMap M.empty; mappend (MMap x) (MMap y) = MMap (M.unionWith x y)
14:47:18 <lambdabot>  .L.hs:166:43: error:
14:47:18 <lambdabot>      • Couldn't match expected type ‘M.Map k v’
14:47:18 <lambdabot>                    with actual type ‘M.Map k v -> M.Map k v’
14:47:25 <jle`> @let newtype MMap k v = MMap { getMMap :: M.Map k v } deriving Show; instance Monoid v => Monoid (MMap k v) where mempty = MMap M.empty; mappend (MMap x) (MMap y) = MMap (M.unionWith (<>) x y)
14:47:26 <lambdabot>  .L.hs:166:43: error:
14:47:27 <lambdabot>      • Could not deduce (Ord k) arising from a use of ‘M.unionWith’
14:47:27 <lambdabot>        from the context: Monoid v
14:47:43 <jle`> @let newtype MMap k v = MMap { getMMap :: M.Map k v } deriving Show; instance (Ord k, Monoid v) => Monoid (MMap k v) where mempty = MMap M.empty; mappend (MMap x) (MMap y) = MMap (M.unionWith (<>) x y)
14:47:44 <lambdabot>  Defined.
14:48:18 <jle`> > M.toList . getMMap $ foldMap (\x -> MMap (M.singleton x (Sum 1))) "hello"
14:48:20 <lambdabot>  [('e',Sum {getSum = 1}),('h',Sum {getSum = 1}),('l',Sum {getSum = 2}),('o',S...
14:48:46 <jle`> > concatMap (\(x,n) -> replicate n x) . M.toList . getMMap $ foldMap (\x -> MMap (M.singleton x (Sum 1))) "hello"
14:48:48 <lambdabot>  error:
14:48:48 <lambdabot>      • Couldn't match type ‘Sum Integer’ with ‘Int’
14:48:48 <lambdabot>        Expected type: MMap Char Int
14:48:59 <jle`> > concatMap (\(x,Sum n) -> replicate n x) . M.toList . getMMap $ foldMap (\x -> MMap (M.singleton x (Sum 1))) "hello"
14:49:01 <lambdabot>  "ehllo"
14:49:10 <jle`> > concatMap (\(x,Sum n) -> replicate n x) . M.toList . getMMap $ foldMap (\x -> MMap (M.singleton x (Sum 1))) "sorting done as fold map using map"
14:49:12 <lambdabot>  "      aaaddefggiilmmnnnooopprssstu"
14:49:23 <MarcelineVQ> you've gone mad with power
14:49:46 <jle`> i think this should be faster than the merge-sort-recombine
14:50:20 <EvanR> merging sorted lists is fast though...
14:50:31 <c_wraith> on a flat data structure, sure. I'm not sure about on a tree. 
14:50:51 <EvanR> sort list of trees?
14:51:11 <c_wraith> ie, I think that will beat the insertion sort degenerate case, but I'm less sure about when it actually gets to be a merge sort. 
14:51:24 <jle`> well, union from Data.Map is specialized to combining sorted sets of keys
14:51:35 <jle`> so i assume that whatever it does is the fastest way of doing it
14:52:03 <c_wraith> also, that fails utterly when used with a type where "equal" values can vary.
14:52:28 <jle`> yes but those are degenerate instances of Eq anyways right
14:52:35 <jle`> i guess this is not a stable sort
14:52:54 <c_wraith> but they happen and sometimes are *really* useful. :) 
14:53:39 <jle`> i recognize only the purest eq instances
14:53:42 <EvanR> equal values always vary. you could even compare two things for equality if they didnt differ somehow, like where on the screen you typed them ;)
14:53:51 <EvanR> couldnt even*
14:55:44 <bla_> a
15:47:52 <iqubic> Hello
15:47:56 <iqubic> I am here.
15:49:44 <iqubic> I love haskell and functional programming.
15:49:53 <jle`> same
15:50:44 <iqubic> I'm taking a Computer Science Course at school and I'm having to use Java
15:51:19 <iqubic> And I really think that our current project would be a lot easier if Java were lazy.
15:53:09 <monochrom> Use Iterator to regain lazy list.
15:55:22 <iqubic> monochrom: That's not what I want to do. I want to have a list of functions, that I call in a particular order.
15:55:37 <iqubic> And they all have the same signature.
15:55:55 <iqubic> It's like having this [a -> b]
15:56:58 <monochrom> Sure. Any particular reason why what you said can't be done in Java?
15:57:02 <ertes> be sure to use the latest design patterns…  and keep up with the news, because they change every week
15:57:23 <ertes> if your directory structure is not at least 20 levels deep, you're doing it wrong
15:57:44 <niez> iqubic, maybe you want a list of functors?
15:57:46 <iqubic> However some of the functions have an additional parameter or two.
15:58:06 <iqubic> niez: I want the java equvalent of that.
15:58:12 <ertes> monochrom: well, for one thing java doesn't really have first-class functions
15:58:25 <glguy> Fortunately, the benefits and contraints of programming in Java are off-topic in #haskell
15:59:13 <niez> iqubic, I mean the functor from object oriented world, not a functor like in haskell
15:59:14 <iqubic> I'll take this elsewhere.
15:59:29 <iqubic> niez: What kind of data would that be?
16:00:50 <iqubic> Is it possible to have optional parameters in Haskell
16:00:54 <iqubic> ???
16:00:58 <Jona222> Hello everyone. I am given a String with mixed characters: "abc123def456" for example. Is there a way to add up every number in it using only pattern matching? Advice is appreciated
16:01:45 <Sonolin> lol I just took what iqubic said as an excercise in another language, and was starting at the code for like 5 minutes wondering why I can't just do "f a" 
16:02:09 <Rembane> iqubic: Yes, and no, they are not built into the language in the same way as they are in for instance C++ or Java, but you can have an OptionalArg data type that has a Monoid instance which will let you combine all the optional parameters you need.
16:02:14 <kadoban> Jona222: I'm never sure what that means, "only feature X". Is there something specific you're trying to avoid? I'd just filter it so it's only digits and then sum those.
16:03:28 <iqubic> Rembane: Java doesn't have optional arguments either.
16:03:59 <Rembane> iqubic: Oh, well, C++ then, or Python.
16:04:22 <Koterpillar> Jona222: yes, note that a string is a list of characters
16:04:50 <Koterpillar> Jona222: …or did I misunderstand you? What result do you want on "abc123def456"?
16:05:02 <niez> iqubic, http://stackoverflow.com/questions/7369460/help-with-understanding-a-function-object-or-functor-in-java
16:05:13 <Jona222> Koterpillar 21
16:05:17 <iqubic> For that he'd want 1 + 2 + 3 + 4 + 5 + 6
16:05:19 <thang1> Java can have optional arguments if you use a builder type of pattern
16:05:28 <Jona222> what i have right now: g2 xs = filter isDigit xs
16:05:42 <Jona222> which gives me a string "123456"
16:05:47 <iqubic> thang1: Can I use those in a list?
16:05:51 <Jona222> and i am only allowed to use pattern matching from here
16:05:51 <jle`> you can mapMaybe readMaybe
16:06:03 <thang1> So you build up the thing you want by saying objConstructor().arg1().arg2().arg3().arg4(); for example
16:06:05 <jle`> you aren't allowed to use any functions?
16:06:23 <iqubic> Jona222: Why do you have to use pattern matching there?
16:06:26 <jle`> that is...difficult
16:06:30 <Koterpillar> Jona222: and not even ord?
16:06:34 <Jona222> Unfortunately, the task says so.
16:06:36 <jle`> not even + ?
16:06:39 <thang1> This is also how java composes functions. So if you want to take a stream and filter on the stream you just compose the entire process "builder-like"
16:06:45 <kadoban> I'm not even really sure what that means, yeah can you use "+" ? Because without that ...
16:06:46 <jle`> are you expected to implement your own decimal addition on Char's?
16:06:57 <Jona222> "The following functions are to be implemented using Pattern Matching: [...]
16:06:57 <jle`> add '1' '1' = '2'
16:07:08 <Koterpillar> doesn't say only
16:07:08 <iqubic> What task are you working Jona222?
16:07:08 <Jona222> one of them being add every number in a string
16:07:24 <jle`> it doesn't say only, so you can probably use things besides pattern matching too
16:07:25 <glguy> solved "abc123def456" = 579
16:07:32 <Koterpillar> jle`: add '9' '9' = ?
16:07:33 <glguy> pattern matching!
16:07:45 <ChaiTRex> Koterpillar: Obviously '18'.
16:07:46 <jle`> add :: Char -> Char -> (Char, Char)     -- carry digit
16:07:56 <iqubic> Jona222: It says you have to use Pattern Matching as one of your tools. Not as the only tool
16:08:14 <jle`> > mapMaybe readMaybe "abc123def456" :: [Int]
16:08:16 <lambdabot>  error:
16:08:16 <lambdabot>      Variable not in scope: readMaybe :: Char -> Maybe Int
16:08:27 <jle`> @let import Text.Read
16:08:29 <lambdabot>  Defined.
16:08:29 <thang1> My gut reaction is that the pattern matching is going to be of the form "if this character is a '1'", "if this character is a '2'", "if this character is a '3'",... etc
16:08:31 <jle`> > mapMaybe readMaybe "abc123def456" :: [Int]
16:08:33 <lambdabot>  error:
16:08:33 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
16:08:33 <lambdabot>        Expected type: [String]
16:08:35 <jle`> aw
16:08:37 <Digit> ^_^
16:09:08 <jle`> > mapMaybe (\c -> readMaybe [c]) "abc123def456" :: [Int]
16:09:10 <lambdabot>  [1,2,3,4,5,6]
16:09:21 <jle`> > sum . mapMaybe (\c -> readMaybe [c]) $ "abc123def456"
16:09:23 <lambdabot>  21
16:09:41 <iqubic> jle`: That uses no pattern matching. LOL
16:10:11 <thang1> Sure it is!
16:10:30 <iqubic> Your pattern matching on a character.
16:10:32 <thang1> "sum" is a pattern, mapMaybe is a pattern, lambda functions are a pattern... /s
16:10:40 <pacak> > mapMaybe ((:[]) . readMaybe) "abc123def456" :: [Int]
16:10:42 <lambdabot>  error:
16:10:43 <lambdabot>      • Couldn't match type ‘[Maybe a0]’ with ‘Maybe Int’
16:10:43 <lambdabot>        Expected type: String -> Maybe Int
16:10:52 <ChaiTRex> > let digit '1' = 1; digit '2' = 2; digit '3' = 3; digit '4' = 4; digit '5' = 5; digit '6' = 6; digit '7' = 7; digit '8' = 8; digit '9' = 9; digit _ = 0 in map digit "abc123def456"
16:10:54 <lambdabot>  [0,0,0,1,2,3,0,0,0,4,5,6]
16:11:02 <jle`> basically reimplement digitToInt, yeah
16:11:08 <pacak> > mapMaybe (readMaybe . (:[])) "abc123def456" :: [Int]
16:11:09 <ChaiTRex> Now just implement 32-bit addition in pattern matching.
16:11:11 <lambdabot>  [1,2,3,4,5,6]
16:11:48 <Jona222> Thanks everyone, but we didnt get to use "Maybe" yet, so im not sure if i am allowed to do so.
16:11:49 <pacak> > let 1 + 1 = 3 in 1 + 1
16:11:51 <lambdabot>  3
16:11:56 <ChaiTRex> You can even do it with the second operand allowing only a single digit.
16:12:08 <pacak> ChaiTRex: Done. Works for _some_ 32-bit ints.
16:12:21 <iqubic> Jona222: What is this activity for?
16:12:31 <ChaiTRex> Probably best to write a code generator for it rather than doing it by hand, though.
16:12:34 <thang1> Jona222: look at ChaiTRex's answer, now take that and implement it using pattern matching with guards instead of let statements. After you're done, you can sum the list just fine
16:13:36 <thang1> If you need to reinvent sum, you can do that with pattern matching and explicit recursion, too.
16:14:30 <ChaiTRex> It would be nice if they handed in a 50-page document mostly taken up by sum using pattern matching.
16:15:33 <iqubic> Jona222: What is this activity for?
16:15:57 <iqubic> It seems way to constricted for any useful purposes.
16:15:57 <Jona222> Its homework basically.
16:16:28 <ertes> 'sum' is a 2-liner for inductively defined natural numbers…  the trouble is that you can't add Integer without using some kind of primitive
16:16:43 <ertes> by "sum" i mean (+)
16:17:08 <Digit> goodness
16:18:01 <Jona222> I do believe i am allowed to use simple addition here, though
16:18:43 <ertes> Jona222: not that you have a choice anyway…  you have to use it
16:29:33 <biglambda> Does anyone know the syntax for an injective type family within a typeclass?
16:29:52 <hpc> class Foo a where
16:30:01 <hpc>   type F a
16:30:08 <hpc> instance Foo Int where
16:30:12 <hpc>   type F Int = Bool
16:30:40 <ertes> biglambda: class C a where type F a = b | b -> a
16:30:55 <hpc> ertes: type family, not fundep ;)
16:31:03 <ertes> hpc: *injective* type family
16:31:04 <hpc> oh
16:31:06 <hpc> oh derp
16:31:14 <hpc> i didn't even know you could do that
16:31:26 <ertes> biglambda: note that data families are injective by construction
16:31:36 <biglambda> Maybe I should describe what I need.
16:31:55 <ertes> hpc: -XTypeFamilyDependencies
16:32:15 <biglambda> I have a class Container and a class Selection
16:32:39 <biglambda> for each instance of container I define it’s selection type
16:32:47 <ertes> biglambda: like a search type?
16:32:59 <ertes> or an associated key type?
16:33:04 <biglambda> yes a traversal type basically
16:33:15 <biglambda> It’s really a path through a tree
16:33:21 <ertes> biglambda: yeah, i would go with a data family there
16:33:38 <biglambda> I’d like the selection type to refer back to the container type
16:34:46 <biglambda> I see, it means I have to box the actual contructor though right?
16:35:34 <ertes> biglambda: do you have types that share a selection type?
16:35:42 <biglambda> Both the container and the selector have kind *->*
16:35:44 <ertes> well, no, you don't
16:35:49 <ertes> otherwise it wouldn't be injective =)
16:35:54 <biglambda> :)
16:36:09 <ertes> biglambda: you don't need to box, as data instances can be newtype
16:36:43 <ertes> instance C F1 where data Selection = F1Sel1 A | F1Sel2 B
16:36:57 <ertes> instance C F1 where data Selection F1 = F1Sel1 A | F1Sel2 B
16:37:12 <ertes> instance C F2 where newtype Selection F2 = F2Sel C
16:37:19 <ertes> biglambda: this is allowed
16:38:23 <biglambda> If it’s newtype in the instance does it need to be newtype in the class def?
16:38:33 <ertes> no
16:38:44 <ertes> data families are always "data"
16:38:57 <ertes> newtype is an instance-specific implementation detail
16:39:18 <nshepperd_> Huh. So you need to know the type before you can pattern match?
16:39:32 <ertes> nshepperd_: yeah
16:39:45 <glguy> all the constructors are specific to a particular type
16:39:58 <glguy> so by using the constructor to pattern match you're declaring what the type is
16:40:04 <thang1> It makes sense, really. Suppose you have a data type Bool = True | False and you want to pattern match on Bool
16:40:15 <thang1> how do you pattern match on it if you don't know what's inside Bool?
16:40:32 <robkennedy> Do you guys know linear types? In "retrofitting​ linear types", they say this is invalid: `f :: a -o a; g :: (a -o a -> b) -> a -o a -> b; g k x y = k y (f x)` is invalid. But the result of `f x` is unrestricted, right?
16:40:39 <biglambda> I think the fact that my container and my selector have kind *->* makes this complicated.
16:40:45 <ertes> i think nshepperd_ is asking whether you need to know the fully saturated type, and the answer is: you need to know all type arguments that are relevant to instance selection
16:40:56 <ertes> biglambda: not really
16:42:08 <thang1> robkennedy: linear types can only be used once in the code, right?
16:42:49 <rightfold> thang1: you need to be more careful in your wording
16:43:00 <ertes> biglambda: the only caveat is that you can't easily have a single Functor instance for the whole family, but Functor instances have to be instance-specific, unless you code the machinery to derive the family instance by using an extra type class
16:43:16 <ertes> biglambda: instance (FunctorHelper a) => Functor (MyFamily a)
16:43:47 <ertes> biglambda: but in most cases you might as well just use instance-specific functor instances
16:43:47 <rightfold> thang1: a value of linear type must be consumed exactly once. This is not equivalent to lexical occurrences (for example, a lambda may close over such a variable, and then the lambda must be applied exactly once)
16:44:09 <biglambda> Ok so if I have: class Container c where data Selector c :: *-> *
16:44:20 <ertes> biglambda: instance C F where data Selection F a = …  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
16:44:56 <biglambda> And then: instance Container Tree where data Selector = TreePath
16:44:57 <rightfold> robkennedy: the result of f x is of linear type if x is of linear type, because f returns its input
16:45:20 <biglambda> Tree, Selector and TreePath are all functors
16:45:43 <rightfold> robkennedy: there is no function of type :: a -o (a, a), for example. You can't write it
16:46:13 <rightfold> Can't eat a cake and have it too
16:46:50 <EvanR> (:[]) cake
16:47:43 <robkennedy> rightfold: I see why you want the semantics to be like that, or you'd want some semantics to be like that. But like, `f x = let y = copy x in (y,y)` seems fine with linear typing
16:48:56 <rightfold> robkennedy: for most use cases of linear types, copy is presumably not safe and can lead to "double free" bugs
16:49:26 <rightfold> Unless it does more than just return its input :p
16:49:40 <EvanR> i.e. do an actual copy?
16:49:46 <rightfold> (Compare Rust Copy vs Clone)
16:49:49 <robkennedy> Sure, but you could certainly write a real copy
16:49:53 <pacak> I suspect copy should exist.
16:50:02 <glguy> You probably couldn't write a copy that works for all types 'a'
16:50:21 <glguy> you might be able to get: CanCopy a => a -o (a,a)
16:50:27 <pacak> Otherwise it limits whatever can be written in linear types
16:50:58 <glguy> pacak: Linear types doesn't mean you only have -o
16:51:13 <glguy> or at least I didn't think it did..
16:51:48 <pacak> glguy: Yea, you can mix them.
16:52:42 <nshepperd> yeah, I was imagining data families as sort of like an open GADT, but I guess the way it works makes sense
16:52:59 <glguy> They are like an open GADT
16:54:24 <rightfold> pacak: limiting what can be written is the primary job of type systems :P
16:54:27 <robkennedy> I should finish this paper 
16:54:43 <EvanR> no!
16:54:56 <rightfold> Having a general copy mechanism is probably not something you want. It's a bit like universal nulls/equals
16:55:11 <pacak> rightfold: Type system should allow good program and disallow bad ones.
16:55:39 <nshepperd> glguy: well, they are in that constructors are restricted to particular types. but GADTs also let you bring type information into scope by pattern matching
16:55:53 <pacak> Without that allow part - best type system is `const (error "typecheck failed")`
16:56:28 <pacak> Need to read  linear types paper
16:56:36 <pacak> All of it, not just first few pages :)
16:57:50 <rightfold> Affine types are really cool
16:58:19 <robkennedy> rightfold: idk about that. Adding something like `withCopy :: a -o (a -o a -o b) -o b` which would allow finite uses seems fine so far
16:59:01 <robkennedy> But like pacak said, I should finish this before stating more
16:59:08 <rightfold> It defeats some of the major use cases of linear types
16:59:21 <rightfold> For example referentially transparent mutations
16:59:59 <rightfold> withCopy $ \a b -> (mutate a, b) -- dangerous!
17:00:04 <robkennedy> Sorry, that last time I mean `withCopy :: ... -> b`
17:00:45 <thang1> rightfold: and the reason you want that referentially transparent mutation with linear types is so that you can keep reasoning but also allow the compiler ot do some awesome witchcraft and potentially negate the need for a GC for certain parts of the code entirely, right?
17:00:59 <rightfold> Yes
17:01:12 <rightfold> A mutation is safe if nobody can observe it. Mutations are super fast.
17:02:21 <pacak> Btw, in paper and in all discussion I've seen they used unicode dot rather than o. Is there established ascii version? -o looks odd.
17:02:32 <thang1> Mutations are also safe if people can observe but can't change and you ensure that all viewing references have updates, or something like that? (Rust has done a lot of work into this kinda stuff iirc)
17:02:53 <pacak> this type signature is valid o -o o -o o - but ugly.
17:03:04 <thang1> -o is the closest to an established ascii version as we're going to get, I think
17:03:07 <rightfold> pacak: it's also known as "lollipop" and "multimap"
17:03:08 <suzu> safe if everybody can observe the new value, nobody can observe the old one, and hence nobody can observe that there was a mutation
17:03:43 <pacak> rightfold: How do you type it in ascii? Actuall -o?
17:03:45 <thang1> suzu: right, that makes sense. Atomic and instantaneous mutations that can be safely treated as not-a-mutation as far as reasoning goes
17:03:54 <suzu> yup
17:04:01 <EvanR> turing machine is based on observable mutation and is perfectly safe
17:04:19 <rightfold> thang1: in Rust, you cannot dereference any reference except the unique reference-to-mutable, if such a reference-to-mutable exists. This ensures a certain degree of safety, but not referential transparency that we are interested in with functional programming
17:04:36 <thang1> Yeah but you can't have some random non-local other turing machine kamakazi into the middle of your first turing machine and wipe out half of it because of a buffer overflow
17:04:42 <nshepperd> nothing infinitely big is perfectly safe
17:05:16 <EvanR> Z ?
17:05:41 <thang1> rightfold: thanks. I really need to get off my butt and learn Rust so I can internalize some of these concepts better.
17:06:46 <nshepperd> I've been wanting linear types in my embedded DSL for automatic differentiation, so that I can require certain type class constraint only when something is used twice (or zero times)
17:06:50 <rightfold> If you have a function A -> A, that mutates its input, and you have a guarantee that the input is the ONLY reference to the value, then the function call referentially transparent.
17:07:05 <nshepperd> but you only need indexed monads to do that, and i haven't bothered yet
17:07:22 <rightfold> thang1: you may want to look at Mercury too
17:08:36 <rightfold> nshepperd: do you have a link to info on this EDSL?
17:09:45 <biglambda> ertes: So it turns out the simplest solution was to move the typeclass function into the dependant class. If that makes any sense.
17:09:57 <nshepperd> no, I only have code. i'm using it for machine learning, and the DSL is for composing differentiable functions (neural networks)
17:10:03 <biglambda> That’s one to file away into the bag of tricks.
17:11:43 <rightfold> nshepperd: ok!
17:12:45 <thang1> rightfold: thanks! I've seen it before in some research as well. I'm also interested in Erlang style languages for that actor model stuff
17:13:35 <EvanR> still waiting for an abstract version of the actor model
17:15:51 <nshepperd> you don't need linear types if you use a Category/Arrowish interface for composition, as the only way you can copy things would be 'copy :: Copyable a => c a (a,a)'. but doing everything in pointless style is a pain in the ass
17:19:42 <monochrom> Linearity by too much hassle to clone. :)
17:19:59 <EvanR> nshepperd: but wait! you could use a quasi quoter to convert expressions of the form x y z -> z x y into the proper swaps and copies
17:20:24 <rightfold> pointfree quasiquoter
17:21:53 <EvanR> and then your compile time goes through the roof
17:25:00 <nshepperd> EvanR: I could write my own ArrowSyntax, yeah
17:25:36 <EvanR> well what i suggested takes up a lot less space
17:26:04 <pacak> :t aside
17:26:06 <lambdabot> (Applicative f, Choice p) => APrism s t a b -> p (e, a) (f (e, b)) -> p (e, s) (f (e, t))
17:26:29 <pacak> aside operates on second element of a tuple. How do I get something that operates on the first one?
17:38:11 <thang1> (,) is not a tuple it is a pair
17:38:28 <haskell-beginner> parse error (possibly incorrect indentation or mismatched brackets)
17:38:48 <EvanR> and (,,) is not a triple?
17:38:49 <thang1> haskell-beginner: thx bro
17:39:07 <pacak> A tuple is a finite ordered list of elements. In mathematics, an n-tuple is a sequence (or ordered list) of n elements, where n is a non-negative integer.
17:39:09 <EvanR> er, i mean to say, tuple
17:39:15 <pacak> pair = 2-tuple
17:39:21 <thang1> Right
17:39:35 <haskell-beginner> please can you help me
17:39:39 <EvanR> so a square is not a rectangle
17:39:44 <EvanR> because its not non-square
17:39:58 <thang1> > length (4,5) -- I'm just saying, thinking of this as a "tuple" is going to make things weird 
17:40:00 <lambdabot>  1
17:40:02 <pacak> haskell-beginner: Paste full error message somewhere?
17:40:04 <haskell-beginner> how do I make a haskell functio find the value of a quadratic
17:40:37 <EvanR> the result of length (4,5) in haskell is a pretty bad excuse to change what we call tuples
17:40:46 <pacak> What's the least perverted way of making left aside?
17:40:48 <haskell-beginner> where: quadratic = x^2 +5x + 1
17:41:31 <pacak> > [x | x <- [-10 .. 10], x*x + 5 * x + 1 == 0]
17:41:33 <lambdabot>  []
17:41:40 <EvanR> theres the quadratic formula and some tweaks to attempt to migitigates its bad numeric behavior
17:41:44 <antoine9298> “left aside”?
17:42:14 <EvanR> mitigate?
17:42:17 <pacak> > [x | x <- [-10,-9.9 .. 10], abs (x*x + 5 * x + 1) < 0.1]
17:42:19 <lambdabot>  [-4.8000000000000185,-0.20000000000003482]
17:42:26 <thang1> EvanR: sure, but if you want a true programming convention of "n-tuple" in the language to be denoted by (,,, ... ,), we don't really have a way to do that right now.
17:42:29 <pacak> haskell-beginner: here :)
17:42:37 <haskell-beginner> hello_world.hs:1:1: error:     Parse error: naked expression at top level     Perhaps you intended to use TemplateHaskell
17:43:03 <EvanR> thang1: since youre shaking some established jargon here, i have no idea what youre talking about
17:43:03 <pacak> antoine9298: aside applies prism to second element of a tuple. I want to modify first one.
17:43:38 <dogbits> haskell-beginner, can you post link lamda lpaste.net
17:43:48 <thang1> EvanR: http://bitemyapp.com/posts/2015-10-19-either-is-not-arbitrary.html I just read this today, so that has something to do with it :p
17:44:16 <antoine9298> hmm, not sure about “prism” either, but, ok, I guess so
17:45:04 <EvanR> thang1: ah, some polemic blog post from chris ;)
17:45:18 <thang1> But the main point is really that anything with Functor is going to act on the second part of the "tuple". If you want to modify both parts, you want a bifunctor, and if you want some arbritrary choice, you want a lens
17:45:54 <thang1> EvanR: I do freely admit that am easily influenced by shiny examples...
17:45:56 <pacak> :t _Left
17:45:58 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
17:46:03 <haskell-beginner> http://lpaste.net/355203
17:46:09 <pacak> > preview _Left (Right 1)
17:46:11 <lambdabot>  Nothing
17:46:12 <haskell-beginner> dogbits: http://lpaste.net/355203
17:46:16 <pacak> > preview _Left (Left 1)
17:46:16 <haskell-beginner> pacak: http://lpaste.net/355203
17:46:18 <lambdabot>  Just 1
17:46:30 <pacak> antoine9298: Kind of pattern match thingy.
17:46:55 <thang1> That being said, a n-tuple is (,) or (,,) or (,,,) for any n number of arguments. If I were expecting length (a,b) to give me 2, I would be expecting a tuple structure to be arbritrary amounts of arguments
17:46:58 <Sonolin> do lens type signatures ever get easier to read?
17:47:03 <haskell-beginner> hello_world.hs:5:1: error:     parse error (possibly incorrect indentation or mismatched brackets)
17:47:03 <Sonolin> lol 
17:47:07 <haskell-beginner> hello_world.hs:5:1: error:     parse error (possibly incorrect indentation or mismatched brackets)
17:47:10 <robkennedy> Status Report: It turns out that later in the paper they define `copy :: (a -> r) -o a -o r`
17:47:11 <thang1> But in haskell, there's only (,) by "default"
17:47:24 <pacak> haskell-beginner: first two lines - they do nothing. Last line - you don't need let.
17:47:40 <pacak> Sonolin: Well... They are flexible.
17:47:41 <thang1> robkennedy: mah gawd, have they gone completely mad?
17:47:42 <haskell-beginner> pacak: I'm using the $ ghc 
17:47:48 <pacak> > :t _Left
17:47:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:47:58 <pacak> :t _Left
17:47:58 <haskell-beginner> pacak: bc I don't know how to get the IDLE thingy
17:47:59 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
17:48:19 <pacak> :t _Left :: Prism' (Either a b) a
17:48:20 <lambdabot> (Applicative f, Choice p) => p a (f a) -> p (Either a b) (f (Either a b))
17:48:58 <EvanR> thang1: i dont expect length (x,y) to be 2
17:49:19 <EvanR> i dont expect it to be anything, i dont plan on using this god forsaken Foldable instance
17:52:01 <robkennedy> I hate that instance as much as I hate `length $ Just [1,2,3]`
17:52:23 <robkennedy> > length (Just [1..5])
17:52:26 <lambdabot>  1
17:53:04 <antoine9298> > liftM lenght (Just [1..5])
17:53:06 <lambdabot>  error:
17:53:06 <lambdabot>      • Variable not in scope: lenght :: [Integer] -> r
17:53:06 <lambdabot>      • Perhaps you meant one of these:
17:53:09 <pacak> > sum (1,2)
17:53:11 <lambdabot>  2
17:53:14 <antoine9298> > liftM length (Just [1..5])
17:53:16 <lambdabot>  Just 5
17:53:20 <pacak> > sum ("string", 2)
17:53:21 <antoine9298> yay!
17:53:22 <lambdabot>  2
17:53:31 <haskell-beginner> how do I call the custom function
17:53:35 <haskell-beginner> doesn\t seem to work
17:53:39 <haskell-beginner> x 3
17:53:42 <haskell-beginner> quadratic.hs:5:1: error:     Parse error: naked expression at top level     Perhaps you intended to use TemplateHaskell
17:53:59 <thang1> > fmap length (Just [1..5])
17:54:01 <lambdabot>  Just 5
17:54:06 <pacak> haskell-beginner: You don't just call a function, you need to do something with results
17:54:16 <haskell-beginner> http://lpaste.net/355203
17:54:23 <EvanR> one does not merely call a function?
17:54:29 <EvanR> nvm
17:54:30 <kernelj_arch> > length <$> Just [1..5]
17:54:32 <lambdabot>  Just 5
17:54:37 <pacak> haskell-beginner: replace second line with
17:54:41 <pacak> main = print $ x 3
17:54:55 <EvanR> main = print (x 3)
17:55:25 <pacak> main = let (☭) = ($) in print ☭ x 3
17:55:30 <haskell-beginner> pacak: quadratic.hs:2:16: error:     • Couldn't match expected type ‘Integer -> a0’                   with actual type ‘[Integer]’     • The function ‘x’ is applied to one argument,       but its type ‘[Integer]’ has none       In the second argument of ‘($)’, namely ‘x 3’       In the expression: print $ x 3
17:55:55 <pacak> Hmm...
17:56:00 <pacak> You don't need 3
17:56:04 <pacak> so
17:56:07 <pacak> main = print x
17:56:11 <thang1> @import Data.Bifunctor
17:56:11 <lambdabot> Unknown command, try @list
17:56:18 <thang1> >import Data.Bifunctor
17:56:25 <thang1> :t first
17:56:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
17:56:48 <thang1> :t Bifunctor.first
17:56:50 <lambdabot> error:
17:56:50 <lambdabot>     Not in scope: ‘Bifunctor.first’
17:56:50 <lambdabot>     No module named ‘Bifunctor’ is imported.
17:57:00 <thang1> ಠ_ಠ
17:57:26 <antoine9298> any practical differency between fmap and liftM (except that one works with functors and the other one with monads)?
17:57:41 <EvanR> fmap works with all of the above
17:57:43 <EvanR> liftM doesnt
17:57:50 <haskell-beginner> pacak: what do you mean
17:57:50 <pacak> antoine9298: fmap is shorter to type.
17:58:04 <thang1> antoine9298: pretty sure there's not any major difference now that we've screwed with our typeclasses a bit. liftM feels like a backwards compatibility thing that we still have hanging around
17:58:12 <EvanR> fmap doesn't require an import
17:58:13 <antoine9298> EvanR why ?
17:58:18 <pacak> And you can type it even if your shit/capslock keys are broken.
17:58:24 <EvanR> because all Monads are Functors anyway
17:58:48 <pacak> haskell-beginner: replace first line with
17:58:51 <pacak> main  = print x
17:58:57 <pacak> haskell-beginner: second  line
17:59:00 <jordan39593> hi
17:59:01 <jordan39593> https://ideone.com/QqoLSW
17:59:08 <antoine9298> EvanR …and that’s harder to get a monad instead of a functor, right?
17:59:09 <jordan39593> why does this short program give me an error
17:59:39 <haskell-beginner> pacak: then what do I do to use the function with x = 3 ?
17:59:39 <pacak> jordan39593: funktion is too short, it lacks body.
17:59:42 <EvanR> antoine9298: i guess Monads are less common, but precisely, all Monads are Functors but not all Functors are Monads
17:59:57 <jordan39593> what do you mean too short
18:00:12 <jordan39593> what do i need to do to make it work
18:00:13 <pacak> haskell-beginner: Are you trying to evaluate a quadratic formula?
18:00:23 <pacak> jordan39593: type more stuff.
18:00:30 <antoine9298> → So there can’t be more monads, so they are more functors
18:00:37 <jordan39593> is it because i use " | " ?
18:00:59 <antoine9298> have you got examples of things that can be functors but not monads?
18:01:00 <latro`a> haskell-beginner, why did you re-use the symbol x in the definition of x? don't do that...
18:01:03 <EvanR> antoine9298: im not sure you can really counter the number of either, its infinite
18:01:07 <pacak> jordan39593: No, it's a guard pattern, that's perfectly valid. But you are not telling it what to do.
18:01:18 <latro`a> antoine9298, iirc ZipList
18:01:36 <antoine9298> yeah, of course, but from a practical PoV
18:01:43 <jordan39593> what do i have to change to make it work for example?
18:01:53 <latro`a> what's not practical about ZipList?
18:02:13 <haskell-beginner> pacak: These were the instructions we were given: 1) Use a text editor such as Notepad ++ to write a function to find the value of quadratic where: quadratic = x^2 +5x + 1 Save your function as quadratic.hs
18:02:22 <antoine9298> just like, there is an infinite number of numbers, and an infinite number of primes, but from a practical PoV, there is less primes
18:02:23 <ryantrinkle> any news on when linear types might be showing up?
18:02:27 <pacak> jordan39593: Switch to a different language, haskell is static typed one.
18:02:34 <pacak> haskell-beginner: I see, Try this
18:02:43 <latro`a> oh, you weren't talking to me, I gotcha
18:02:55 <pacak> main = print (f 3)
18:02:56 <pacak> f x = x * x + 5 * x + 1
18:03:05 <pacak> haskell-beginner: Just two lines.
18:03:05 <jordan39593> its a task i have to do
18:03:09 <haskell-beginner> 2) Load and run your program to find the value of quadratic when x = 3
18:03:12 <jordan39593> i cant switch languages lol
18:03:26 <EvanR> antoine9298: well, i can give you an example. but im not going to support imprecise "practical" terminology
18:04:00 <antoine9298> jordan hmm, you’ll have to get the “haskell way”, I guess
18:04:04 <pacak> jordan39593: What is your task then?
18:04:26 <jordan39593> i want  to filter numbers from a list
18:04:35 <jordan39593> the list is a string
18:04:56 <antoine9298> why would you need more that statical types?
18:05:03 <pacak> > filter isDigit "123abc45"
18:05:05 <lambdabot>  "12345"
18:05:14 <haskell-beginner> pacak: it just says [1 of 1] compiling main then linking quadratic...
18:05:14 <haskell-beginner> pacak: 
18:05:14 <haskell-beginner> nothing prints
18:05:36 <antoine9298> I love that bot
18:05:47 <pacak> haskell-beginner: Did you executed the program itself?
18:05:56 <pacak> ghc only compiles stuff
18:06:52 <pacak> jordan39593: By numbers you probably mean digits.
18:07:07 <jordan39593> yes
18:07:12 <haskell-beginner> pacak: So I have to compile it each time then sudo chmod +x then ./filename?
18:07:17 <pacak> And in your paste you apply characters, not strings to function
18:07:21 <haskell-beginner> pacak: that's a lot of effort
18:07:22 <pacak> haskell-beginner: simply ./filename will do
18:07:26 <jordan39593> how can i like save all digits in the string to a new list
18:07:29 <jordan39593> in my function
18:07:38 <kernelj_arch> haskell-beginner: there's a 'runhaskell' command that can run your script directly
18:07:42 <haskell-beginner> pacak: what's the .hi one for
18:07:49 <pacak> jordan39593: funktion = filter isDigit
18:08:14 <pacak> haskell-beginner: It contains the essense of divine haskellness, you don't need it at the moment.
18:08:25 <jordan39593> that doesnt do anything
18:08:40 <haskell-beginner> pacak: what do you use this language for  practically?
18:08:53 <pacak> haskell-beginner: Making money.
18:09:23 <haskell-beginner> pacak: lol but what do they want you to create for them
18:09:28 <thang1> (☞ﾟヮﾟ)☞ excellent answer, pacak 
18:10:09 <haskell-beginner> pacak: or what programs generally could work exclusively off haskell
18:10:23 <EvanR> haskell is a general purpose programming language
18:10:24 <pacak> haskell-beginner: You can write all sorts of stuff in Haskell
18:10:39 <kernelj_arch> You can also write all sorts of stuff in any other language
18:10:45 <haskell-beginner> pacak: outside academia though?
18:11:00 <pacak> haskell-beginner: Yes.
18:11:46 <pacak> kernelj_arch: Right, but in inferior languages it can be painful.
18:12:08 <jordan39593> "inferior languages"
18:12:08 <pacak> kernelj_arch: http://stackoverflow.com/questions/43740037/datetime-converts-wrong-when-system-time-is-30-march - take this for example
18:12:20 <EvanR> probably the wrong way to put it
18:12:20 <kadoban> haskell-beginner: It has great support for web stuff, especially server side. There's GHCJS for doing client-side web stuff in it, you can use it for any general application programming you can think of. It's really general purpose.
18:12:28 <pacak> jordan39593: php, javascript.
18:12:45 <EvanR> if i was doing this game is javascript, itd probably be done by now
18:12:47 <pacak> kernelj_arch: https://i.imgur.com/6aclmM6.png - or this
18:13:16 <kernelj_arch> is that javascript?
18:13:40 <haskell-beginner> kadoban: it's gonna take me a while to see how math functions are more useful to write web apps in than high level language
18:13:42 <pacak> kernelj_arch: second link - yes.
18:13:57 <haskell-beginner> *non-functional high level
18:13:58 <EvanR> haskell-beginner: dont look now, web page templates are pure functions
18:14:15 <EvanR> web forms are applicative functors
18:14:15 <haskell-beginner> EvanR: well yes technically all computer science is maths
18:14:17 <haskell-beginner> EvanR: but
18:15:04 <haskell-beginner> EvanR: from the backend development side, why would I need lambda
18:15:14 <EvanR> the response of a webserver is (unless you need to wait for secondary responses) a response body and a transaction
18:15:15 <kadoban> haskell-beginner: It seems weird as hell at first, but it'll make perfect sense eventually. It's really just a more sound way of modelling the computation that you probably already know how to do in other languages, plus some extra guarantees that you can't quite get in other lanugages.
18:15:23 <EvanR> and if you do, you have a free monad
18:16:05 <haskell-beginner> kadoban: so basically just efficiency?
18:16:09 <yepo> Is Haskell good for machine learning / AI?
18:16:33 <EvanR> haskell-beginner: after i realized templates are "just functions" it became much easier to actually write the template, because so much redundancy was removed. higher order functions really let you factor out a lot of repeated code
18:16:48 <kadoban> haskell-beginner: No, though haskell is pretty efficient in terms of speed for a high level language. I'd say safety and sanity/flexibility of expressing patterns and thoughts.
18:18:16 <kernelj_arch> pacak: I don't see much wrong with that javascript one given how in javascript everything is treated like a string pretty much, but string + string = concatenated string
18:18:30 <haskell-beginner> kadoban: doesn't it also mean a lot more work. I can understand how it is safer for development since you know exactly what when and how the program will execute but for ordinary web devs there is a huge cost in terms of time if they write their own engines
18:18:50 <yepo> not Haskell in particular but Functional Programming in general. Most languages are capable to some degree for FP ammirite?
18:19:00 <kadoban> haskell-beginner: No, over time it's far less work for me. A type system is a tool that helps you reason about and work with code. A really nice tool once you get used to it.
18:19:08 <EvanR> haskell-beginner: well, theres are several engines
18:19:20 <EvanR> and i have spent plenty of time fixing or understanding bugs in rails
18:19:32 <pacak> kernelj_arch: Well... It leads to some unexpected conversions for one.
18:19:49 <pacak> I'd rather have a type error when I try something like this
18:19:52 <pacak> > 1 + "3"
18:19:54 <lambdabot>  error:
18:19:54 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
18:19:54 <lambdabot>      • In the expression: 1 + "3"
18:20:01 <pacak> lambdabot: Thank you.
18:20:02 <haskell-beginner> kadoban: we use frameworks so that we don't waste time in the more technical details. What's the point in writing everything as f(x) = x | x -> ... etc
18:20:08 <kernelj_arch> pacak: I didn't find any of them unexpected because like I said, javascript can treat everything as a string
18:20:14 <pacak> kernelj_arch: In javascript there's... http://dorey.github.io/JavaScript-Equality-Table/
18:20:43 <EvanR> haskell-beginner: you really get used to code not crashing at runtime
18:20:47 <EvanR> its kind of a game changer
18:21:11 <EvanR> but it does require you to think differently
18:21:29 <EvanR> and that difference can be transported back to normal languages
18:21:32 <jordan39593> https://ideone.com/Pk9sP4
18:21:39 <jordan39593> why cant i run the simplest program
18:21:41 <haskell-beginner> EvanR: I'm not sure what you've been using that's crashing all the time due to something other than your code
18:21:50 <dyreshark> haskell-beginner: haskell has frameworks. many of them. https://wiki.haskell.org/Web/Frameworks
18:21:52 <EvanR> haskell-beginner: pretty much
18:22:26 <EvanR> *my* code crashes a lot less in haskell
18:22:39 <haskell-beginner> It only makes sense if you're doing a very different kind of web app
18:22:48 <jordan39593> Parse error: naked expression at top level
18:22:48 <jordan39593>     Perhaps you intended to use TemplateHaskell
18:23:00 <jordan39593> haskell gives the most useless errors i have ever seen
18:23:01 <haskell-beginner> but for normal web apps there's really nothing wrong with PHP w/ laravel on an NGINX
18:23:02 <pacak> EvanR: Not crashing at runtime? Hmmm.... Can you imagine situation where this function can crash?
18:23:02 <pacak> derp :: Int -> Int -> Int
18:23:02 <pacak> derp a b = if a == b `xor` show a == show b then undefined else a + b
18:23:26 <EvanR> pacak: my tea timer for someone to chime in and say haskell can crash just went off
18:23:52 <pacak> jordan39593: Here, take dis! "="
18:24:10 <EvanR> haskell-beginner: there you go thn
18:24:25 <dyreshark> haskell-beginner: see also http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html for a thing that shows you actual code that uses (some of) those frameworks
18:24:29 <jordan39593> wow
18:24:31 <dyreshark> though it's potentially a bit out of date
18:24:32 <jordan39593> it worked
18:24:46 <EvanR> 2013 web haskell, man thats old
18:24:59 <dyreshark> still has concise examples
18:25:04 <kadoban> haskell-beginner: Frameworks exist in haskell, seems like a false dichotomy.
18:25:33 <haskell-beginner> kadoban: not really a false dichotomy when they are extremely different
18:25:49 <kadoban> In what way are they extremely different (and from what?)
18:25:56 <haskell-beginner> kadoban: haskell just adds unnecessary work
18:26:10 <pacak> haskell-beginner: Saves you from one actually.
18:26:11 <haskell-beginner> kadoban: why would you need to do this
18:26:13 <dyreshark> depends on your definition of unnecessary
18:26:20 <haskell-beginner> dyreshark: for common use
18:26:38 <EvanR> broken PHP is still in production use, wasting peoples time
18:26:38 <kadoban> I strongly disagree.
18:26:44 <dyreshark> if i'm deploying something, i want as much assurance as possible it's not horribly broken
18:26:49 <dyreshark> haskell's type system helps with that
18:26:56 <dyreshark> it doesn't guarantee anything, mind you
18:26:58 <dyreshark> but it helps
18:27:06 <EvanR> legacy PHP is a time sink that keeps on sinking
18:27:15 <pacak> haskell-beginner: it compiles therefore it works is much more likely to apply to haskell rather than javascript. Or php.
18:27:24 <haskell-beginner> EvanR: it is possible to make a secure PHP app
18:27:46 <EvanR> i found it very difficult personally, even thinking i was proficient with it
18:28:00 <haskell-beginner> EvanR: have you used frameworks
18:28:05 <haskell-beginner> with PHPp
18:28:07 <EvanR> yeah several PHP frameworks
18:28:13 <kadoban> It's possible to make a secure app in machine language, by manually flipping one bit at a time. It's just not very easy. A better question is which tool helps do so better.
18:28:14 <haskell-beginner> Hmm
18:28:14 <EvanR> and write my own, like many people
18:28:25 <EvanR> custom CMS
18:29:10 <rotaerk> hmm would I be "weird" if I started using literate haskell by default
18:29:31 <kadoban> For some definitions of weird I suppose.
18:29:41 <kernelj_arch> I've got an interview with Jane Street and I don't know whether to learn OCaml in a hurry, do Haskell which I have recent experience with or stick with C++
18:30:14 <haskell-beginner> how do I pass in values when I executed the compiled code
18:30:16 <kernelj_arch> they say to use the language you're most comfortable with, and I can't figure out how much they mean it
18:30:23 <EvanR> cramming on C++, Haskell, or OCaml for an interview in the near future?
18:30:34 <haskell-beginner> ./file --variable1 "bhnmd,'"
18:30:42 <haskell-beginner> like that
18:30:49 <kadoban> haskell-beginner: Same was as in any program. Via command line arguments, read from files or stdin, via sockets, etc.
18:30:55 <kernelj_arch> EvanR: yes
18:31:03 <pacak> :t getArgs
18:31:05 <lambdabot> error: Variable not in scope: getArgs
18:31:05 <kernelj_arch> probs within 2 weeks
18:31:16 <EvanR> haskell-beginner: theres is a library which gives you nice option parsing for this, optparse-applicative
18:31:32 <taktoa> kernelj_arch: I used haskell on my phone interview and I didn't get another interview, though I was a freshman at the time
18:31:41 <thang1> https://github.com/groupoid/om this looks super neat
18:31:45 <pacak> haskell-beginner: Might be tricky for beginners. You'll have to use scary M-word.
18:31:47 <johnw> does anyone know why z3 would be giving me "invalid usage" on this code: https://gist.github.com/259ae8ffb9cb7452949e1a190ec08744
18:32:01 <johnw> I find examples on the web where exists and forall are nested...
18:32:03 <kernelj_arch> taktoa: mind divulging what sort of stuff they asked?
18:32:10 <EvanR> pacak: the task doesnt have much to do with Monads
18:32:40 <pacak> EvanR: IO monad at least.
18:32:49 <EvanR> IO doesnt have much to do with "Monad"
18:32:58 <MP2E> it uses the IO type, it doesn't necessarily require knowledge of the Monad instance :p
18:33:05 <EvanR> you need to use IO, thats for sure
18:33:11 <EvanR> and probably do notation
18:34:10 <EvanR> and with optparse-applicative, youre not using much of either
18:35:25 <pacak> "If not, don't worry! All you really need to learn are a few basic parsers, and how to compose them as instances of Applicative and Alternative."
18:35:51 <EvanR> you kind of dont even need to understand those classes
18:36:09 <EvanR> just do like in other languages and translate from the examples!
18:36:50 <EvanR> (which dont even show you the types)
18:36:56 <EvanR> (so its not scary at all)
18:37:06 <pacak> =<<, <>, <**>...
18:37:25 <pacak> I'm not even sure myself what <**> is.
18:37:31 <pacak> :t (<**>)
18:37:32 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
18:37:45 <ChaiTRex> It's a spider.
18:37:48 <pacak> k, something stupid.,
18:38:00 <haskell-beginner> is there an IDLE like thing for haskell
18:39:13 <EvanR> the repl is ghci
18:39:28 <haskell-beginner> Why's it called prelude
18:39:32 <haskell-beginner> prelude>
18:39:35 <EvanR> it comes first
18:39:39 <haskell-beginner> is there an interlude then
18:39:40 <benzrf> it sounds cool
18:39:43 <EvanR> probably
18:39:49 <haskell-beginner> probably?
18:39:51 <EvanR> there are many alternative preludes
18:40:07 <EvanR> which should cut down on some more common imports
18:40:24 <haskell-beginner> 'it comes first' ? what comes after?
18:40:29 <EvanR> your code
18:40:35 <haskell-beginner> oh so this is for testing
18:40:36 <EvanR> your imports
18:40:52 <kamyar> hello guys
18:40:53 <EvanR> no, its an invisible import before any of the others in all modules
18:41:10 <kamyar> I have a simple question 
18:41:15 <johnw> ah, found it, I had counted off the de Bruijn indices wrong
18:41:31 <benzrf> haskell-beginner: Prelude is the name of the module that is imported without you saying so
18:41:37 <benzrf> haskell-beginner: python has this too, it's just not named
18:41:44 <haskell-beginner> benzrf: oh fair
18:41:51 <kamyar> How can we determine if a block of code is running strict or lazy?
18:42:06 <benzrf> kamyar: all code is lazy in haskell unless it is using bang patterns or seq
18:42:15 <haskell-beginner> putStrLn
18:42:18 <haskell-beginner> What is Ln
18:42:22 <EvanR> line
18:42:22 <pacak> Line
18:42:31 <pacak> end of line specifically
18:42:36 <yepo> I'm (re)learning programming and Haskell is a breath of fresh air
18:42:38 <haskell-beginner> put string to end of line?
18:42:40 <kamyar> benzrf: what is bang?
18:42:46 <pacak> kamyar: !
18:42:49 <benzrf> kamyar: an extension
18:43:11 <EvanR> ! is called bang, # is called octothorp
18:43:34 <kamyar> benzrf: I have heard we can change parts of code behavior
18:44:17 <kamyar> benzrf: for example for IO monad
18:45:42 <haskell-beginner> how does haskell do these factorials of huge numbers so quickly 
18:46:00 <kamyar> It surely depends on how I code and which types I use e.g. Text or Lazy Text
18:46:02 <EvanR> its just repeated multiplication
18:46:05 <katsura> hi
18:46:26 <kamyar> but I need a general queue
18:46:27 <EvanR> but with arbitrary precision integers
18:46:48 <kamyar> sorry clue
18:46:52 <haskell-beginner> yeah but these are huge numbers and usually it would be a time complexity problem
18:47:10 <haskell-beginner> let fac n = if n == 0 then 1 else n * fac (n-1)
18:47:11 <EvanR> multiplication of large numbers has efficient algorithms
18:47:19 <haskell-beginner> fac 100000
18:47:33 <EvanR> > product [1..100000]
18:47:39 <lambdabot>  mueval-core: Time limit exceeded
18:47:57 <haskell-beginner> so is there a nice one liner for calculating pi to x many digits
18:48:04 <kamyar> I have heard neglecting lazy evaluation can be a killer e.g. menory leak
18:48:06 <EvanR> > pi :: CReal
18:48:08 <lambdabot>  3.1415926535897932384626433832795028841972
18:48:53 <EvanR> > pi
18:48:55 <lambdabot>  3.141592653589793
18:48:58 <kamyar> is therr any tools or manual methods to check code?
18:49:11 <haskell-beginner> pi
18:49:27 <haskell-beginner> pi to maybe 100 digits
18:49:30 <EvanR> kamyar: ghc has a built in profiler
18:49:49 <EvanR> CReal gives you reals to however many digits
18:49:58 <yepo> Noob question: what's the difference between > b = 32  VS. > let b = 32 ??
18:50:15 <kamyar> EvanR: does it check leaks or bad laziness?
18:50:25 <pacak> kamyar: you can use vacuum to see if stuff is evaluated or not.
18:50:27 <EvanR> you can look at graphs of memor usage
18:50:43 <EvanR> if you dont think its supposed to be growing growing, you may have done something wrong
18:50:49 <kamyar> pacak: how does it work?
18:50:51 <EvanR> but thats a big if
18:51:34 <pacak> kamyar: http://hackage.haskell.org/package/vacuum-2.2.0.0/docs/GHC-Vacuum.html
18:51:51 <pacak> There's vacuumLazy that gives you a node map that you can walk around
18:52:09 <pacak> Version on hackage is outdated but I maintain my own version.
18:52:12 <benzrf> yepo: in ghci?
18:53:10 <yepo> benzrf: yes
18:53:27 <benzrf> yepo: former is an error before ghc 8
18:53:53 <kamyar> pacak: thnx!
18:54:01 <yepo> benzrf: so then both are valid in the latest versions? Thanks!
18:54:10 <benzrf> yepo: yup
18:56:38 <monochrom> Wait, what?!
18:56:40 * monochrom tries
18:56:52 <benzrf> :)
18:57:11 <monochrom> I be damned.
18:57:17 <benzrf> now u can do this:
18:57:19 <benzrf> :{
18:57:21 <benzrf> a :: Int
18:57:23 <benzrf> a = 3
18:57:25 <benzrf> :}
18:57:48 <Unode> with all those smilies, it's hard to keep a straight face
18:57:49 <monochrom> Now I can't wave my "the REPL is not an editor" anymore.
18:58:01 <monochrom> err, "the REPL is not an IDE".
18:58:11 <Unode> the multiline edit is still cumbersome
18:58:24 <MarcelineVQ> it's nice for pasting in though
18:58:47 <Unode> :set +m , is what I learn on the book.
18:59:17 <monochrom> To be fair, supporting "b = 3" is uncontroversial, there is no ambiguity as far as GHCi grammar is concerned.
19:00:34 <Unode> there's also ipython with the haskell kernel. But getting it to work is a bit of a PITA.
19:06:14 <benzrf> mmm, pita
19:06:51 <Unode> there's docker, but that's kind of throwing away everything else you might have setup.
19:06:58 <yepo> > [2,2..20]
19:07:00 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
19:07:15 <yepo> Why is this?
19:07:20 <benzrf> yepo: i'm sure it'll get there eventually o3o
19:07:32 <geekosaur> "for sufficiently large values of 2"
19:07:46 <EvanR> what in the
19:07:46 <benzrf> yepo: that means, "starting from 2, let the next thing be 2, and keep going up by the same amount, stopping when you reach 20"
19:07:47 <geekosaur> the syntax expands to enumFromThenTo
19:07:53 <ChaiTRex> GHC is, for some reason, really slow compiling 720000-line functions.
19:07:57 <benzrf> ChaiTRex: lol
19:08:02 <yepo> benzrf: thanks
19:08:09 <benzrf> no problem :)
19:08:37 <EvanR> benzrf: it does this by subtraction?
19:09:17 <EvanR> > [2,4..7] :: [Double]
19:09:19 <lambdabot>  [2.0,4.0,6.0,8.0]
19:09:33 <benzrf> i think so
19:09:40 <EvanR> gnarly
19:09:41 <benzrf> dunno
19:10:05 <ChaiTRex> > [2,4..7::Int]
19:10:07 <lambdabot>  [2,4,6]
19:10:15 <ChaiTRex> O-o
19:10:16 <benzrf> what in the heck
19:10:41 <Unode> so 8.0 < 7 ?
19:10:44 <EvanR> i guess enumFromThenTo can do whatever it wants since its in the Enum class
19:10:50 <pacak> > [1.0, 2.0 .. 10]
19:10:52 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
19:10:53 <glguy> counting by 2 , you won't reach 7
19:11:00 <pacak> > [1.0, 2.0 .. 9.99]
19:11:02 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
19:11:02 <ChaiTRex> > fromEnum (8.0 :: Double)
19:11:04 <lambdabot>  8
19:11:11 <ChaiTRex> > fromEnum (7.0 :: Double)
19:11:13 <lambdabot>  7
19:11:36 <pacak> Because everyone knows that 10.0 < 9.99
19:11:41 <pacak> All heil satan!
19:11:56 <Unode> interesting features
19:12:32 <EvanR> yes
19:12:45 <pacak> (haskell report is strange)
19:12:50 <EvanR> quotes around various parts of that phrase
19:13:40 <Engen> hey guys I'm trying to do some exercises regarding GADTs and I'm having trouble understanding both how they help and some syntax
19:13:59 <Engen> to start off with, I've been given a definition for a binary tree http://lpaste.net/355206
19:14:40 <EvanR> that is just GADT syntax and isnt using GADTs extra features
19:14:52 <EvanR> so the way its used there is just for looks
19:15:10 <kernelj_arch> what are the extra features?
19:15:26 <EvanR> the type of the result of construction can be something besides BinaryTree a
19:15:28 <Engen> I don't understand line 3 how we begin with a BinaryTree and take two two more BinaryTrees to return another BinaryTree
19:15:49 <benzrf> Engen: you're just writing the type of the constructor
19:15:52 <kernelj_arch> you mean like BinaryTree b or something completely different?
19:16:17 <benzrf> Engen: in GADT syntax, you just straight up write the type of each constructor. if it's not a type you can assign to a constructor, you;ll get an error
19:16:18 <EvanR> BinaryTree Char, BinaryTree (a, Char), BinaryTree (ArbitraryTypeLevelExpr)
19:16:55 <EvanR> kernelj_arch: or just b, yeah, which could do interesting things if only a is in scope
19:17:20 <benzrf> Engen: note that the 'a' in the type of Leaf is bound implicitly just like in the type of a function; the 'a' in the first line of the data declaration is a separaet variable - try changing one of them, it will still work
19:17:55 <Engen> benzrf: ah I get you, it's just a placeholder
19:18:49 <benzrf> Engen: in the first line, yeah
19:18:52 <EvanR> if you wrote data BinaryTree a = Leaf a | Branch a (BinaryTree a) (BinaryTree a) and check Branch's type, itd look just like that
19:19:16 <benzrf> the 'a' in the first line merely serves to indicate BinaryTree's arity
19:19:29 <glguy> It's best to enable the KindSignatures extension and write: data Tree :: * -> * where ...
19:19:35 <benzrf> in languages like coq, you could write [Inductive BinaryTree : Type -> Type] and it would mean the same thing
19:19:41 <glguy> than to have the confusing variable there
19:19:42 <benzrf> jinx!
19:20:34 <EvanR> clearly haskell doesnt like "theres only one way to do it"
19:20:48 <benzrf> tim toady
19:22:45 <monochrom> GHC 8 allows Type->Type too
19:23:08 <benzrf> sick
19:23:18 <monochrom> There are always at least two ways to do it. Do it yourself or hire someone else.
19:23:28 <Engen> yeah, I'm just trying to understand what this allows for 
19:23:36 <Cale> "There's never less than infinitely many ways to do it"
19:23:52 <Cale> maybe not as catchy
19:24:15 <thang1> monochrom: Type->Type where? In the `data X where` line?
19:24:37 <monochrom> Tree :: Type -> Type
19:24:44 <monochrom> In general, * is Type
19:25:41 <EvanR> are they trying to eventually shift from * to Type?
19:25:44 <Engen> benzrf: because the next part says to make a data type called Tag that has two variants, Empty and NonEmpty. to my understanding, this simply is data Tag = Empty | NonEmpty 
19:25:49 <benzrf> whose bright idea was it in haskell to call it :: instead of :
19:25:51 <EvanR> something about making it easier to parse
19:25:59 <benzrf> EvanR: probably they want you to use gadt syntax
19:26:01 <kernelj_arch> coq has that weird hierarchy though where the types of things in programs are represented by 'Set' which has a type of 'Type' which has a type of 'Type' in the next universe up
19:26:01 <Engen> and then it says to adjust the GADT type of BinaryTree to be indexed by one of those two types
19:26:02 <monochrom> I think yes, they said * is a parsing nightmare.
19:26:03 <benzrf> *engen
19:26:09 <benzrf> oh i see
19:26:17 <monochrom> or maybe just grammatical nightmare but still
19:26:18 <benzrf> Engen: yeah the ordinary way should be fine then
19:26:20 <Engen> how does one index on whether something is Empty or NonEmpty
19:26:49 <thang1> benzrf: historical gafe. When Haskell was invented, everyone had a giant hardon for linked lists, so of course the best way to express that is to make linked lists as easy as humanely possible to create
19:26:56 <benzrf> Engen: add another argument to BinaryTree so that it's 2-ary
19:27:04 <benzrf> thang1: yeah i figured
19:27:09 <benzrf> still!
19:27:18 <benzrf> Engen: make that argument of kind Tag
19:27:26 <kernelj_arch> thang1: so that's why haskell uses : and not :: for cons, I see
19:27:44 <thang1> Why use :: for list when you can use : ? And thus, oh no, : can't be used for types anymore... darn... well there's always ::. And so forever and ever amen will Haskell be weird and slightly wrong :p
19:27:44 <monochrom> Consider it Huffman code. The more frequent thing is given the shorter name.
19:28:08 <thang1> (completely ignoring the fact that types should be more frequent than lists)
19:28:13 <EvanR> yet i have way more types in my code than lists
19:28:34 <glguy> I'm happy with the arrangement of : and ::, I'm more likely to match a couple of cons cells like x:y:z than I am to do something like that with type signatures
19:28:42 <thang1> Like I said, original Haskell design team was in the 80s. Everyone had a giant fetish for linked lists back then :p
19:28:44 <monochrom> That was a time when lists were more frequent than types.
19:28:54 <EvanR> thang1: and i suspect not writing any type signatures
19:28:56 <monochrom> Type inference plus "we use lists for everything"
19:28:58 <EvanR> if not necessary
19:28:59 <Cale> Lists are *still* really quite important
19:29:27 <EvanR> you will see ocaml and F# code without any signatures at all
19:29:29 <Cale> (even once you eliminate all the things they're bad at)
19:29:30 <thang1> Cale: they're an excellent tool for control flow, but they're terrible for storing data
19:29:32 <Cale> yes
19:29:39 <benzrf> hue
19:29:57 <monochrom> SML is the reverse because you write all top-level types twice.
19:29:57 <thang1> So you shouldn't be encouraging the construction of lists, then, you should encourage their consumption :p
19:30:12 <Cale> But consumption involves pattern matching against conses
19:30:19 <Cale> Often enough
19:30:21 <benzrf> owned
19:30:32 <thang1> eh, true. Good point
19:30:50 * thang1 puts on tinfoil hat of crazy-talk
19:30:51 <EvanR> you dont need pattern matching!
19:30:59 <EvanR> just use the list destructor
19:31:24 <thang1> What if we got rid of ::, made : for types if it's surrounded by whitespace and : for list pattern matching if it's got no white space?
19:31:38 <benzrf> thang1: you have to die now
19:31:48 <EvanR> agda did that
19:32:00 <thang1> function : [a] -> a; function (x:xs) = x
19:32:02 <monochrom> parsing nightmare
19:32:12 <thang1> EvanR: Agda uses : for types, and unicode :: for list though?
19:32:23 <EvanR> ive never tried lists in agda
19:32:27 <thang1> monochrom: I am in no way being serious with this suggestion :p
19:32:33 <monochrom> haha ok
19:32:46 <thang1> That's why I put my crazy-talk tinfoil hat on lol
19:32:57 <thang1> Further, Agda uses a ton of unicode everywhere
19:33:00 <EvanR> you have to have space on both sides of every operator
19:33:19 <EvanR> which i didnt realize was really annoying until it was made illegal not to
19:33:25 <thang1> http://www.cse.chalmers.se/~nad/repos/lib/src/Data/List.agda 
19:33:47 <glguy> thang1: The use of unicode everywhere just depends on which libraries you pick from, the agda-prelude doesn't the "stdlib" does
19:33:48 <thang1> ∷ <-- this unicode symbol is used for list Cons in Agda
19:34:11 <Cale> When they can just use ,
19:34:25 <thang1> glguy: I should rephrase more to say that the Agda culture is a huge fan of unicode and I see it used darn near everywhere in user code as well
19:34:35 <kernelj_arch> ∷ʳ for append, how cute!
19:34:37 <glguy> For example Ulf avoids it
19:35:14 <glguy> It's not built into the language, in particular, so cons can be whatever you want
19:35:43 <thang1> Cale: why would you use , for lists?
19:35:48 <kernelj_arch> I preferred using the unicode syntax in Coq which you had to enable, it just makes more sense in these sorts of languages
19:36:14 <thang1> Definitely. The more mathematical and expressive a language gets, the more limiting the ASCII subset is
19:36:27 <yepo> Why do Haskell users strive to be lazy?
19:36:31 <EvanR> eventually unicode gets limiting
19:36:37 <Cale> thang1: Because you can :)
19:36:55 <glguy> yepo: I'll tell you later
19:36:55 <EvanR> like there is only a subset of latin letter subscripts for some reason
19:36:57 <thang1> it becomes more about the transformation of patterns and composition, and you really need a very large and expressive inputset for that
19:37:00 <MP2E> haha
19:37:24 <thang1> yepo: laziness is efficiency
19:37:34 <thang1> so named by people who don't understand efficiency
19:37:36 <yepo> glguy: lol
19:38:44 <thang1> EvanR: What I would really like is a programatic way to design glyps and stuff like that so literally anything can be a subscript, literally anything can be a superscript, etc. Writing and designing 2D layout of text or even 3D layout
19:38:58 <thang1> Now that would be cool, to see a language that was 3D...
19:39:03 <EvanR> o_O
19:39:12 <EvanR> well you have that already, postscript
19:39:23 <thang1> postscript is 3D?
19:39:37 <Unode> perspective
19:39:56 <EvanR> im not even going to think about 3D text
19:40:02 <EvanR> right now
19:40:24 <EvanR> how many dimensions of text are you on
19:40:28 <thang1> a 2D language is actually really useful
19:40:51 <thang1> I'd consider written 'standard' text (english, chinese, etc) all "1D"
19:40:52 <Unode> 1.58 dimensions I'd say
19:41:10 <monochrom> Why did Einstein want more dimensions? To get more corners for his Einstein notation.
19:41:21 <Unode> :)
19:41:29 <thang1> However, there's actually a written language being developed for sign language right now and it's epic
19:41:40 <Engen> benzrf: does this make sense? http://lpaste.net/4440987087323267072
19:41:50 <Unode> thang1: ? so you code with hand glyphs?
19:41:59 <fosterite> we already have a written language for sign language: the language the sign language is based on
19:42:29 <thang1> No, I don't lol
19:42:31 <thang1> https://en.wikipedia.org/wiki/SignWriting#/media/File:Jack_and_Jill.gif
19:42:47 <Unode> fosterite: well but if you can show the finger to your webcam and your computer tells you "Hello World!" it's a whole new dimension.
19:42:56 <thang1> This is the Jack and Jill poem in ASL but then written in SignWriting
19:42:57 <benzrf> Engen: that's a valid type! but it's not what they want, probably
19:43:15 <benzrf> Engen: here's where gadts have power: you can write type signatures that are impossible to create with the normal syntax
19:43:33 <benzrf> e.g.: "Leaf   :: BinaryTree NonEmpty b"
19:43:44 <thang1> Signwriting used to be a 1 dimensional language, but it was changed to a 2D language because its linearity was dramatically slowing down the rate of comprehension that was possible
19:43:46 <glguy> Empty?
19:43:50 <benzrf> glguy: er, yes!
19:43:54 <kernelj_arch> shoud it not be "top :: BinaryTree a b -> b"
19:44:09 <benzrf> Engen: (here we're promoting Empty to a type-level value with kind Tag)
19:44:13 <Engen> benzrf: so you can explicitly say exactly what you expect where as normally you can't?
19:44:17 <Unode> thang1: looks like another variation of Chinese/Japanese/<insert (asian) language based on glyphs>
19:44:38 <thang1> Unode: it's different in this case. Chinese and Japanese are merely vertical, they're not two dimensional
19:44:42 <MarcelineVQ> Unode: the difference is due to it communicating actions you can skip some of the language barrier
19:44:50 <MarcelineVQ> at least one difference anyway
19:44:56 <thang1> Each column represents one "word"
19:44:58 <benzrf> Engen: exactly what you'll *return*
19:45:15 <Unode> well I'd still need to learn it cause I've no idea what that .gif is conveying
19:45:27 <thang1> However in Sign Language, you can't just express the sign, you have to give the hand shape, the body movement, the facial expression, etc
19:45:31 <MarcelineVQ> frankly I don't like it at all but there's merits to it
19:46:05 <thang1> The key concept with SignWriting is that each sign in ASL has 3-5 necessary characteristics that all must be interpreted "at once" to have a correct sign.
19:46:20 <thang1> So rather than writing a1 a2 a3 a4 a5 b1 b2 b3 b4 c1 ...
19:46:52 <thang1> It's much more powerful and understandable to group every characteristic of a sign into one column so that your brain can parse column-wise and row-wise at the same time
19:47:28 <thang1> (because in each column, seeing how each item changes over time is also important, so you want a clear path to map things over time in your head)
19:48:44 <thang1> So there's an entire category of expression that is enabled with sign language and with ASL that's either incredibly verbose or just plain not really possible in spoken languages. And a 2D written form is necessary to clearly describe that extra dimensin of expression
19:49:10 <Engen> benzrf: I see
19:50:02 <thang1> MarcelineVQ: 2D language or the other conversation that's going on? :p
19:51:21 <MarcelineVQ> mostly just the example image above
19:52:56 <thang1> ah got it. Yeah it can take some getting used to. If you want, I can translate it?
19:53:26 <MarcelineVQ> sure, if it translates into haskell :>
19:53:56 <EvanR> 2D language? or 2D script?
19:54:34 <thang1> Sorry, 2D script and a 3D language
20:00:26 <et09_> how suitable is aeson for making a gtk json editor?
20:00:50 <c_wraith> It's fine, but it's a hilariously small part of that project
20:01:02 <et09_> what project?
20:01:16 <et09_> my hypothetical project?
20:03:03 <c_wraith> yes
20:03:23 <et09_> you mean because gtk is a nightmare
20:03:54 <c_wraith> No, I mean because it gives you a parser, a printer, and a tree data structure to represent parsed JSON
20:04:09 <c_wraith> Every part of any gui is far more work than those
20:04:46 <et09_> gtk does? GtkTreeView ?
20:05:03 <c_wraith> No, aeson's Value type is a parsed JSON tree
20:05:52 <et09_> it seems like you set up a big FRP machine and send signals to gtk converting that json tree into a GtkTreeView, no?
20:06:09 <et09_> well, the changed parts
20:06:56 <EvanR> if that sounds easy, then aeson should be a cinch
20:07:04 <et09_> lol ok
20:13:14 <Engen> benzrf: still around?
20:14:01 <benzrf> Engen: yeagh
20:14:37 <Engen> I don't understand why this compiles http://wklej.org/hash/7e167b49153/
20:15:03 <Engen> there's no Tag data in line 8 for the function top to take into account
20:15:30 <EvanR> the Tag is not in the data itself, its only in the type
20:16:04 <EvanR> it doesnt exist at runtime
20:16:34 <Engen> so the reason I ask this is when I run top Leaf in ghci, I get a non-exhuastive patterns in function top exception
20:16:48 <EvanR> theres no case for Leaf
20:17:06 <Engen> and I've been trying to figure out how to place Empty and NonEmpty types inside of it...
20:17:15 <Engen> oh...
20:17:36 <EvanR> you dont because Empty and NonEmpty are types
20:18:44 <EvanR> you should change the signature to top :: BinaryTree NonEmpty b -> b
20:18:49 <Engen> yeah, I'm trying to understand this and I apologise for you guys repeating yourselves
20:19:12 <EvanR> because it looks like you wont be able to get anything out of a Leaf 
20:19:33 <biotty> independent question from me, a pre-newb.  haskell has runtime info on which type-constructor a value used right?  but not the type, because that was all matched at compile-time and erased.  is my understanding not too far off?
20:20:07 <EvanR> types are used at compile time for various things and then erased
20:20:21 <biotty> that answers one part of my question
20:20:27 <EvanR> the data constructors will be there at runtime so your case expressions will work
20:20:44 <biotty> so i got it right, phew
20:20:50 <EvanR> pretty much
20:21:11 <biotty> this is all kind of a mind blower, i have been reading a couple of haskell intros
20:21:45 <EvanR> but ex. Leaf and Branch might be something as simple as 0 and 1
20:25:09 <biotty> as i imagined
20:25:31 <biotty> just like a tagged union from dirty c
20:26:48 <EvanR> its the same thing, just with a type system that reflects that usage pattern
20:27:09 <biotty> yes.  i like it.
20:28:03 <EvanR> you wont have the opportunity to accidentally access the wrong field of the union
20:28:41 <biotty> i am not a new to the world of programming ; )
20:29:25 <biotty> was kinf of digging to the bottom of c++ and now saw haskell and introduced myself to category theory with that too
20:30:04 <EvanR> as simple as this seems... im still kind of amazed its not a thing in the big OOP languages
20:30:08 <EvanR> even dynamic ones
20:30:34 <biotty> which concept of haskell do you refer to?
20:30:50 <EvanR> in clojure, the pattern would be [:mytag component1 component2] and use pattern match macro to case on it
20:30:56 <EvanR> sum types
20:31:21 <EvanR> but in OOP its like... an object inheritance hierarchy or something
20:31:28 <biotty> right.  i dont know clujure sorry.  was pretty new to functional programming languages just now
20:31:37 <EvanR> and you put the case body inside the class
20:31:48 <biotty> inheritance hierarchy is from the 80s, its crapp
20:31:52 <EvanR> so every case you ever do with a sum type is in the class
20:31:55 <EvanR> each class
20:32:19 <EvanR> haskell is from the 80s ;)
20:32:28 <biotty> sure, but its from the future
20:32:33 <EvanR> haha
20:32:48 <biotty> its good
20:33:02 <EvanR> haskell is from the future of bill and ted, be excellent to each other
20:41:55 <thang1> biotty: inheritance is pretty great
20:42:23 <thang1> Java and C++'s instance on ruining inheritance by making it unusable is a real shame because the idea itself has tons of merit
20:43:34 <biotty> sure it has its uses.  i feel it has had its overuse thats all.  hey, how do they ruin -- i am not aware of this
20:44:05 <thang1> Inheritance is the idea that things with identical properties can share implementations of "methods" that act on those properties
20:44:49 <thang1> So for example, Int is a number, and Fraction is a number. They're both numbers, so why must I define addition separately for both?
20:45:17 <thang1> Even worse, without inheritance, if I want addition to work "intuitively" I have to define it for Int + Int, Int + Fraction, Fraction + Int, Fraction + Fraction
20:45:34 <thang1> With inheritance, it "just works"
20:46:16 <thang1> C++ and Java thought "oh golly gee willikers, this is the best thing ever" and promptly forced you to write classes that tightly bind the concept of inheritance, methods, variables, etc., all together.
20:46:36 <begriffs> Is there a function to escape a Text or ByteString value for being inside a double quotes? i.e. replacing \ with \\ and " with \" ? I can write my own and all but thought maybe there would be one readymade.
20:46:47 <thang1> So you can't talk about inheritance without all of the baggage of OOP and now any "inheritance" is in the context of entire classes, not properties of classes
20:47:51 <thang1> After all the damage had been done, people discovered that interfaces were way better than inheritance. Haskell, however, has always had "interface style inheritance" and so avoids the whole mess by only considering inheritance hierarchies of /types/, not methods
20:48:27 <biotty> thang1: i feel inheritance of implementation should be separated from inheritance of interface somehow better
20:48:41 <EvanR> you dont even need inheritance of implementation
20:48:47 <EvanR> because implementations are values, functions
20:48:57 <EvanR> you can make other functions out of functions
20:49:01 <EvanR> reuse of code
20:49:23 <thang1> Which is the magic of haskell's style of inheritance. /True/ polymorphism rather than the brittle polymorphism of OOP code
20:49:24 <biotty> yes.
20:49:24 <EvanR> what was revealed to me a few years ago was that reuse of code isnt the point, its access to locally-global variables
20:49:40 <EvanR> your methods have access to all the "globals" of its ancestor classes
20:49:45 <EvanR> you cant really do that in haskell
20:49:57 <EvanR> and a lot of people would say you dont want to
20:50:24 <thang1> And yet over and over OOP is taught in universities and books as "omg this inheritance". Really, nobody cares. You want the encapsulation of globals in OOP
20:50:44 <thang1> Which is conveniently handled by modules in Haskell
20:50:50 <EvanR> its not
20:51:01 <EvanR> because mutable 
20:51:18 <thang1> You never really mutate anything in haskell anyway?
20:51:25 <EvanR> i wish
20:52:09 <thang1> Well sure there's monad transformer stacks and all that jazz, but I've never gotten the point of lexically scoped mutable globals if it means bringing in all that other crap that OOP delivers
20:52:23 <EvanR> agreed
20:52:23 <DrMentats> begriffs: applying show to a string should do it I think
20:53:00 <thang1> biotty: anyway, rather than wanting to inherit implementation of things, you can just write functions that work on everything that shares certain properties (which is really what you want in the first place)
20:53:23 <thang1> So you /could/ write addition as Int + Int = Int
20:53:51 <thang1> Or you can write addition as (all objects 'a' that implement the Number interface) => a + a = a
20:54:26 <thang1> and voila, every type you ever define for the rest of your life just needs to implement Number and you get addition for /free/
20:54:36 <biotty> sorry i have a question.  if you have addStuff = do   a <- (*2)   b <- (+10)   return (a+b)
20:55:09 <biotty> then, how should i think about the a and b.  what are they?
20:55:27 <jle`> biotty: in that case, addStuff :: Num a => a -> a
20:55:29 <biotty> what are the pure a and b in there?
20:55:39 <jle`> biotty: 'a' and 'b' are the result of applying (*2) to whatever input you call addStuff with
20:55:46 <thang1> so a and b can be anything that implements "Num"
20:55:58 <jle`> biotty: so if you call `addStuff 11`, then a is 22 and b is 21
20:56:01 <begriffs> DrMentats: oh yeah...of course! thanks.
20:56:08 <jle`> if you call `addStuff 3`, then a is 6 and b is 13
20:56:53 <biotty> i see.  so for the function monad, do means we're inside a function kind of
20:57:02 <DrMentats> begriffs: you may need to trim the quotes from both sides of the resulting string though
20:57:11 <thang1> sort of. This is where the "monads are burritos" nonsense comes from
20:57:22 <jle`> biotty: yea,h you're inside a world that's "awaiting" an input, kinda
20:57:24 <begriffs> I was adding those outside quotes before, so I just removed that part of the code.
20:57:28 <jle`> you're describing what you'd do with an input if you got it
20:57:49 <biotty> not far from a future
20:58:20 <jle`> like, if i got an input, i'd multiply it by 2 and call it 'a'.  i'd also add 10 to it and call it 'b'.  and the final reply will be a+b
20:59:04 <biotty> by the way, is haskell, like ghc, running thunks on different threads?
20:59:51 <jle`> i don't think it evaluate thunks in different threads by default
21:00:13 <ChaiTRex> > let addStuff = do { a <- (*25); b <- (+13); return (a + b) } in addStuff 5
21:00:16 <lambdabot>  143
21:00:24 <biotty> would be a good leverage to exploit purity to get parallelism for free, that other languages struggle with
21:00:39 <thang1> biotty: Haskell already exploits purity very strongly to get concurrency
21:00:46 <thang1> (which is not the same as parllelism)
21:00:51 <jle`> not implicitly, though
21:01:01 <biotty> ok, not sure on my terminology with prallelism.
21:01:09 <jle`> apparently implicit concurrency is trickier than what it might seem to be
21:01:29 <thang1> Immutable gets you concurrency much easier
21:01:48 <jle`> haskell's really good at explicit and dataflow concurrency
21:01:53 <jle`> and parallelism
21:01:54 <thang1> Immutable doesn't get you parallelism easier, it lets you refactor code more aggressively to make it parallel, but this depends on a fancy compiler.
21:02:29 <biotty> so, for a composed mathematical calculation, with composed separate outputs, stuff does not get computed in different threads i guess.
21:02:37 <thang1> Functional programming is more declarative and the more declarative your code is the less it expresses to a compiler "how" to do things and more "what" to do, so the compiler has more freedom to parallelize. This can be done with mutable or immutable stuff
21:02:41 <biotty> or can i start ghc with a j-factor or alike?
21:03:30 <jle`> biotty: well, if you compose them linearly, there isn't much room for parallelism.  but it's useful when you have parallel data dependencies.  ghc just doesn't do it implicitly/automatically
21:03:36 <jle`> but it's very easy to do it explicitly
21:03:40 <biotty> sorry about "composed separate".  i mean, if there are separate mathematical tasks
21:03:52 <biotty> s/mathematical/pure/
21:04:04 <pacak> How would you go about debugging "hGetContents: illegal operation (delayed read on closed handle))" that pops up very randomly considering you don't even use Handles?
21:04:22 <biotty> is there a thread monad
21:04:24 <thang1> https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/lang-parallel.html biotty 
21:05:05 <thang1> tl;dr is link the program with -threaded, then run it with the RTS -N option
21:05:34 <jle`> pacak: readFile etc. all use file handles
21:05:51 <jle`> anything that works with files or the disk uses file handles 
21:06:27 <jle`> what you gave sounds a lot like a complication with lazy IO
21:06:46 <pacak> jle`: I mean not using them directly. Isn't it supposed to be keept open until there are references to computation that can read more stuff from the file?
21:06:59 <pacak> s/until/while/
21:07:03 <jle`> the picture is complicated with lazy IO
21:07:29 <jle`> GHC tries to guess when you're done with the handle but it often guesses wrong except in the extreme simple cases 
21:07:37 <biotty> my question about "thread monad" is really awkward but there's the IO monad ...
21:08:06 <pacak> jle`: I know that it's lazy IO  to blame, I'm curious how to debug this stuff.
21:08:06 <jle`> biotty: there's Par, a pure parallelism monad
21:08:23 <jle`> check out http://chimera.labs.oreilly.com/books/1230000000929/index.html :) 
21:08:25 <ReinH> There's also a free book on parallel and concurrent programming in Haskell
21:08:28 <ReinH> yes that
21:08:44 <jle`> pacak: find out where you're using lazy IO
21:08:48 <jle`> and switch to strict IO
21:08:51 <jle`> hehe
21:10:32 <pacak> I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail. 
21:10:32 <jle`> but in general it's difficult to control how Lazy IO executes except in the extreme simple toy cases 
21:10:38 <thang1> jle`: step 1. Draw circle. Step 2. Draw rest of owl
21:10:40 <pacak> I guess that works.
21:11:56 <jle`> one simple hack would be to use evaluate to make sure things are being parsed/read when you think they are
21:12:09 <jle`> evaluate w/ deepseq
21:12:35 <jle`> that can some some simple issues 
21:12:41 <pacak> jle`: The problem is that shake uses  lazy io all over the place.
21:13:06 <pacak> readFile' :: FilePath -> Action String
21:13:06 <pacak> readFile' x = need [x] >> liftIO (readFile x)
21:13:33 <jle`> one thing that can happen is that you do an operation in file contents to produce a value, but you don't use the value until after the handle is closed 
21:13:34 <pacak> I'm pretty sure it can use some pounding...
21:13:52 <jle`> so immediately forcing the value instead of a let binding fixes that
21:14:19 <jle`> but yeah it's hard to say exactly without seeing code
21:14:22 <pacak> readFile' x = need [x] >> liftIO (readFile x >>= v -> length v `seq` return v)
21:14:24 <pacak> So this.
21:14:31 <pacak> :(
21:14:42 <pacak> jle`: It's not even my code :)
21:15:15 <jle`> you can make some changes on your end maybe
21:17:31 <pacak> Yes, decorate every read operation with force...
21:17:42 <pacak> Or replicate a bug and submit a bugreport.
21:29:50 <thang1> Is there any work in implementing a dynamic GC in Haskell that can switch between thorouput prioritizing and latency prioritizing?
21:37:27 <thang1> ahh okay, Haskell's GC uses the same collection algorithm in all of its generations
21:56:11 <adarqui> anyone use haskell-vim-now? any idea how to switch it 'off' completely for .go files for example .. want to use vimgo for that
21:59:01 <clever> thang1: https://making.pusher.com/latency-working-set-ghc-gc-pick-two/
22:22:32 <wow12321> anyone here
22:24:19 <pacak> wow: Your lack of patience disturbs me.
22:25:15 <HelpSeeker> morning everyone, i am looking for someone preferably german-speaking to give me a hint in a task i am given. :-)
22:26:06 <suzu> tell us about your task
22:27:32 <pacak> Preferably in English :)
22:28:28 <HelpSeeker> I summed it up here with an example: https://pastebin.com/HKtZPf8n
22:29:17 <pacak> the first value of each tuple not being > 3
22:29:29 <pacak> :t all (<3)
22:29:31 <lambdabot> (Num a, Ord a, Foldable t) => t a -> Bool
22:30:00 <pacak> if it's 0, then the second value has to be 0 aswell
22:30:54 <pacak> :t \(a, b) -> a == 0 && b == 0 || a /= 0
22:30:56 <lambdabot> (Num a, Num a1, Eq a, Eq a1) => (a1, a) -> Bool
22:31:04 <jle`> pacak: what a lovely operator
22:31:08 <pacak> :t all ((<3) . fst)
22:31:10 <lambdabot> (Num a, Ord a, Foldable t) => t (a, b) -> Bool
22:31:22 <pacak> :t and
22:31:24 <lambdabot> Foldable t => t Bool -> Bool
22:31:40 <pacak> :t all
22:31:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
22:31:51 <pacak> Hmmm...
22:32:21 <pacak> :t all (\(a, b) -> a < 3 && (a == 0 && b == 0 || a /= 0)
22:32:23 <lambdabot> error:
22:32:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
22:32:28 <pacak> :t all (\(a, b) -> a < 3 && (a == 0 && b == 0 || a /= 0))
22:32:30 <lambdabot> (Num a, Num a1, Eq a, Ord a1, Foldable t) => t (a1, a) -> Bool
22:32:46 <pacak> > all (\(a, b) -> a < 3 && (a == 0 && b == 0 || a /= 0)) [((3,20),(3,20),(3,20)), ((3,20),(3,19),(2,25)), ((3,19),(3,19),(3,19)),          ((3,20),(3,19),(2,25)), ((2,25),(2,25),(2,25))]
22:32:48 <lambdabot>  error:
22:32:48 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer)’
22:32:48 <lambdabot>                    with actual type ‘((Integer, Integer), (Integer, Integer),
22:32:51 <pacak> o_O
22:33:17 <pacak> Ugh, those are pairs inside of 3 tuples...
22:33:23 <pacak> HelpSeeker: How?
22:33:49 <HelpSeeker> ? :(
22:34:18 <jle`> why isn't there a Functor instance for 3- and 4- etc. tuples?
22:34:30 <jle`> and Applicative/Foldable/Traversable/Monad/etc.
22:35:52 <pacak> HelpSeeker: Your task description says nothing about outer tuples
22:36:24 <HelpSeeker> what do you mean
22:36:51 <pacak> Or I don't understand the problem.
22:36:59 <HelpSeeker> its basically a darts game
22:37:13 <Axman6> jer1: see the recent duscission on the... -libraries mailing list I think it was. Many people advocate strongly for having them, and some people say it makes life harder for newcomers
22:37:19 <Axman6> uh, jle`
22:37:25 <HelpSeeker> 3 throws per player
22:37:28 <pacak> jle`: Can be useful. Merge requests are accepted. With that in place it can result in even more confusing results :)
22:37:37 <pacak> > length (1,2,3)
22:37:39 <lambdabot>  error:
22:37:39 <lambdabot>      • No instance for (Foldable ((,,) t0 t1))
22:37:39 <lambdabot>          arising from a use of ‘length’
22:37:48 <HelpSeeker> (3,20) meaning triple 20 on the first one
22:38:10 <thang1> I'm of the opinion that if we have (,) we should have ( , ... ,) where you can have n number of , inside a generic n-tuple
22:38:16 <HelpSeeker> and after 3 throws it's the next players turn
22:38:25 <thang1> makes no sense to stop at (,) and go "that's it! We're done! Wrap it up here, folks, no more needed"
22:38:39 <Axman6> yeah, it's nonsense to not have them
22:38:40 <pacak> thang1: up to 62-tuples? :)
22:38:42 <jle`> Axman6: that's fair i suppose
22:39:12 <jle`> i wouldn't ever use the Functor or Foldable instance
22:39:18 <jle`> but the Applicative, Traversable, Monad instances are useful
22:40:11 <Axman6> but what if a beginner has to learn something! that would be horrible!
22:40:32 <jle`> Traversable instance might be done away with if we had Bitraversable in base
22:40:34 <pacak> jle`: There are tuples up to 62-tuples that means adding _a crapton_ of new instances. That will most likely affect compilation time
22:40:35 <thang1> pffh, a beginner already has to learn that length (,) is always going to be 1
22:40:54 <Axman6> exactly
22:41:10 <jle`> i don't think that affects compilation time
22:41:14 <thang1> pacak: Idk, I feel like there's a way to recursively define n-tuples
22:41:49 <jle`> some lbiraries do it using TH
22:41:51 <Axman6> I think the whole argument is just crazy, there is an obvious right thing to do which makes the language more usable, and learning why length <tuple> == 1 must be the case is very valuable
22:42:00 <jle`> but n-tuples aren't really meant to be worked with inductively
22:42:24 <pacak> thang1: Sure, (a,b,c) is isomorphic to  (a, (b,c)), but on run time it will result in a bunch of indirections
22:42:33 <thang1> Base case: Tuples are a container that hold some values (a,b)
22:42:45 <thang1> you can do stuff to b, you can do stuff to a (sorta)
22:42:57 <thang1> Inductive step: Now... imagine there are numbers higher than two
22:42:58 <jle`> you can think of them that way, and some libraries do.  but the tuple type in haskell isn't structured inductively like that
22:43:03 <Axman6> (you probably want to define them as being isomorphic to ((a,b),c) I think
22:43:12 <Axman6> )
22:43:15 <thang1> Suddenly, the world expands. Heavens open, angels cry tears of joy
22:43:22 <jle`> the typical approach is as a monoid with (,) and () as identity
22:43:25 <thang1>  ... Behold:  ( , , )
22:43:31 <pacak> Axman6: It's still isomorphic.
22:43:32 <Axman6> :o
22:43:47 <thang1> Axman6: merely an implementation detail /s
22:43:48 <Axman6> pacak: sure,  but it makes the induction easier I think
22:43:55 <jle`> but it isn't that hard to make an actual inductive tuple type
22:43:59 <jle`> in haskell
22:44:11 <pacak> But for that you'll pay either on  compile time or on run time
22:44:49 <thang1> clever: that is actually the very article that prompted my GC question
22:45:06 <clever> heh
22:45:50 <pacak> Axman6: Easier - yes, but if it suddenly takes 10 times longer to compile or it runs 10 times slower - I don't want it.
22:46:08 <pacak> Also behold - generics!
22:46:27 <Axman6> oh I agree, you definitely want tuples to actually be product types with n elements, not a list at runtime
22:46:48 <pacak> So you pay on compile time.
22:47:17 <Axman6> yeah
22:47:31 <Axman6> Ideally you pay once at the compile time of GHC
22:47:36 <Axman6> +base
22:47:51 <cocreature> being able to define tuples inductively while avoiding indirections at runtime is one of the few things I envy c++ for
22:47:51 <thang1> Still, I don't really see how generic n-tuples would literally explode the compile time of GHC
22:48:08 <thang1> cocreature: is that because of templates?
22:48:11 <pacak> ghc will need to keep all this stuff around when compiles code - just in case you want to get length of 62-tuple
22:48:30 <pacak> so you'll have to pay on compile time for all the things.
22:49:37 <thang1> I guess I'm just not really seeing how going from 1 to 62 is going to make a giant difference :p
22:49:53 <pacak> Let'
22:50:33 <pacak> Let's see... Functor, Foldabe, Applicative, Traversable, Monad with 2-3+ methods in each
22:50:45 <pacak> multiply that by 62
22:50:51 <thang1> https://wiki.haskell.org/Accessible_layout_proposal also this is the kinda stupid insanity I like to see
22:50:58 <pacak> Thus much stuff you'll have to keep in memory. All the time.
22:51:29 <thang1> It's got everything. 1) ugly hack due to backwards compatibility. 2) bikeshedding to make the language prettier to look at. 3) More confusing weird crap for beginners motivated by said backwards compatibility nonsense
22:53:38 <thang1> But with Functor,  Foldable, Applicative, Traversable, etc... you don't have to define different instances for lists of different sizes
22:54:08 <thang1> [,] = [,,] = [,,,] = [, ... ,] as far as writing instances goes
22:54:18 <thang1> write it once for the list container, it works on lists of all sizes
22:54:31 <pacak> thang1: Not really. There are different pattern matches all over the place
22:54:42 <cocreature> thang1: sort of, it’s obviously a template type but that alone is not sufficient. iirc most implementations these days abuse multiple inheritance where they inherit from "TupleElement<index, value_type>" and then getting the nth element is just a cast
22:54:45 <pacak> > fmap show (1,2)
22:54:48 <lambdabot>  (1,"2")
22:55:06 <pacak> this needs to pattern match against (1,x)
22:56:24 <thang1> cocreature: most implementations of n-tuples? Or most implementations of foldable/etc instances?
22:56:39 <suzu> > (\(1,x) -> x) (1,5)
22:56:41 <lambdabot>  5
22:57:13 <suzu> > (\(1,x) -> x) (8,5)
22:57:15 <lambdabot>  *Exception: <interactive>:3:2-12: Non-exhaustive patterns in lambda
22:57:46 <suzu> > (\(1,x) -> x) (1,(5, undefined))
22:57:49 <lambdabot>  (5,*Exception: Prelude.undefined
22:58:05 <Cale> thang1: That's because functions on lists are recursively defined to work that way. Code for tuples of different sizes is physically different for each size of tuple.
22:58:36 <Cale> (you can't just run code which was compiled for triples with 5-tuples and expect anything to work)
22:58:55 <thang1> Cale: True. I guess I just don't really see why it necessairly has to be that way by default. If you want to write a magic function that works differnt on triples than 5-tuples, sure, why not. But generic functions should be generic
22:59:20 <thang1> fmap is generic, so to me it seems like you should only need one fmap instance for any n-tuple, in theory
22:59:21 <Cale> If tuples were more list-like in memory, then perhaps you could act on them generically.
23:01:52 <jle`> thang1: in haskell, tuples are just unrelated types
23:01:59 <jle`> like data T1 a = T1 a
23:02:03 <jle`> data T2 a b = T2 a b
23:02:07 <jle`> data T3 a b c = T3 a b c
23:02:13 <jle`> can you write a generlic fmap for all of those?
23:02:26 <jle`> (you can with ghc generics, but)
23:02:36 <Cale> Also, it's a bit of a moot point, since anything larger than a pair is hardly ever used.
23:03:02 <Cale> Once you get beyond pairs, you should probably write your own data type.
23:03:16 <deank> lens provides a generic way of accessing tuples, I just can't recall the name of the lens
23:03:18 <ReinH> you can get arbitrarily large tuples lisp style if you want
23:03:31 <jle`> GHC.Generics gives you a generic way of accessing tuples
23:03:38 <thang1> It still feels pretty ugly to me that nobody ever uses more than 2, that so much stuff is hard coded into 2,3,X-tuple functions, and so on
23:03:51 <jle`> ideally no things are hard-coded into 3+ tuples
23:04:00 <jle`> using 3+ tuples is sort of bad practice
23:04:04 <ReinH> I can access arbitrarily large tuples with fst and snd ;)
23:04:10 <ReinH> I just build my tuples differently
23:04:12 <Cale> thang1: It makes sense. It'd be far *more* ugly if people did use larger tuples.
23:04:38 <Cale> thang1: You have to remember what the tuple components mean. It's much better to define a record type and name them, usually.
23:06:20 <ReinH> do you have a moment to talk about cdddaddadr
23:06:24 <deank> > view _1 (10, 20)
23:06:26 <lambdabot>  10
23:06:30 <deank> > view _1 (10, 20, 30)
23:06:32 <lambdabot>  10
23:06:47 <thang1> lol
23:06:49 <jle`> yeah, _1 doesn't quite do that using inductive definitions
23:06:51 <Cale> Yeah, that's just a bunch of type classes with a ton of instances
23:06:54 <jle`> it just makes a typeclass that tuples are instances of
23:07:07 <Cale> :t _1
23:07:08 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
23:07:10 <jle`> and makes instances for bunches of tuples
23:07:30 <pacak> :t _62
23:07:31 <lambdabot> error:
23:07:32 <lambdabot>     • Found hole: _62 :: t
23:07:32 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
23:07:36 <pacak> Nope.
23:07:38 <ReinH> let cdddaddadr = view (_2._2._2._1._2._2._1._2)
23:07:52 <Cale> iirc the highest is _9?
23:07:54 <Cale> :t _9
23:07:55 <lambdabot> (Functor f, Field9 s t a b) => (a -> f b) -> s -> f t
23:08:13 <deank> if you are using 10 element tuple you have bigger problems than _10 not being defined (:
23:08:20 <thang1> lol true
23:08:55 <cocreature> thang1: most implementations of std::tuple in c++
23:09:02 <Cale> Perhaps a complete lack of taste being foremost among them ;)
23:09:17 <Axman6> ReinH++
23:10:00 <ReinH> You can write lisp in any language if you try hard enough
23:10:59 <Axman6> you've reminded me of: https://raw.githubusercontent.com/mxswd/flip-plus/master/Control/FlipPlus.hs
23:11:08 <thang1> oh wow
23:11:13 <ReinH> I notice that most references only go up to cddddr. They are weak.
23:11:30 <jle`> beautiful
23:11:41 <ReinH> yes this is significantly better
23:11:57 <Cale> such utility
23:12:14 <ReinH> very mnemonic
23:12:29 <jle`> i ... actually see the pattern now
23:12:39 <ReinH> free your mind
23:12:59 <thang1> Drink the koolaid
23:13:27 <ReinH> that's actually a pretty awfully morbid reference if you stop and think about it
23:13:41 <ReinH> I recommend not stopping and thinking about anything
23:13:53 <jle`> tried uploading it to lpaste
23:13:56 <jle`> but it's too large
23:14:04 <ReinH> hahaha lpaste is weak
23:14:08 <jle`> i deserved this
23:14:14 <ReinH> it can't handle the magnificence
23:14:19 <ReinH> it is unworthy
23:16:06 <Cale> https://hackage.haskell.org/package/these-0.7.3/docs/Control-Monad-Chronicle.html
23:16:14 <thang1> Okay, so records are what you want instead of n-tuples...
23:16:31 <Cale> yeah, generally
23:16:33 <jle`> @let instance Field1 [a] [b] a b where _1 = ix 1
23:16:34 <lambdabot>  .L.hs:173:14: error:
23:16:34 <lambdabot>      • Couldn't match type ‘a’ with ‘b’
23:16:34 <lambdabot>        ‘a’ is a rigid type variable bound by
23:16:35 <jle`> thang1: yes lol
23:16:52 <thang1> What do people actually legitimately use (,) tuples for, then?
23:17:04 <jle`> when they're too lazy to create a new data type
23:17:13 <thang1> I'm used to using and thinking about tuples as basically heterogenius lists
23:17:14 <jle`> you can think of (,) as an anonymous product
23:17:25 <thang1> ahh, okay
23:17:25 <jle`> just like how lambda (\x -> ...) are anonymous functions
23:17:38 <jle`> you use lambdas when you're too lazy to name the function
23:17:49 <Cale> thang1: I tend to think of (l,x) as being like a labelled container with a single value (x), and a label (l)
23:17:52 <jle`> you use tuples when you're too lazy to name your product
23:18:21 <ReinH> Yeah, that's the (a,) functor/foldable/traversable
23:18:26 <Cale> All the instances are defined in such a way as to support that (and really, that's kind of forced)
23:18:33 <jle`> and Applicative/Monad too
23:18:36 <santoast> I'm am looking at the definition for unzip and it says that it's > unzip' = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) ....my question is what does that (~) "tilda" symbol do in the lambda expression?
23:18:43 <Cale> > fmap (\x -> 10*x) ("hello", 5)
23:18:45 <lambdabot>  ("hello",50)
23:18:49 <ReinH> jle`: yeah I just got tired of typing the :p
23:18:53 <jle`> santoast: look up lazy or irrefutable pattern matches
23:19:01 <ReinH> *them
23:19:04 <santoast> okay
23:19:14 <jle`> it tells ghc to don't check if the (,) constructor was really used
23:19:17 <jle`> and go down that case immediately
23:19:20 <jle`> without verifying the pattern
23:19:26 <Cale> santoast: It makes the pattern lazy -- it will match immediately without the pair being evaluated, and only when as and bs are used will it evaluate that argument.
23:19:47 <Cale> With pairs, it's pretty safe
23:20:07 <santoast> ah okay! thank you :)
23:20:07 <thang1> So when do you actually use lazy matches? Sweet talking the compiler into more efficient code?
23:20:09 <Cale> With types that have multiple constructors, it can result in exceptions if the pattern didn't really match after all
23:20:29 <thang1> Cale: that's a good way to think about tuples in haskell, thanks.
23:20:32 <jle`> well, sometimes you don't want to force the resolution of the pattern
23:21:18 <Cale> thang1: It also fits in with Map
23:21:22 <Cale> :t fromList
23:21:24 <lambdabot> IsList l => [Item l] -> l
23:21:29 <Cale> :t M.fromList
23:21:31 <lambdabot> Ord k => [(k, a)] -> M.Map k a
23:21:35 <Cale> there we go
23:22:04 <Cale> So, you build a Map out of a bunch of pairs, each of which has a key and a value
23:22:20 <thang1> ooh neat. I see, now. So disregard entirely any mathematical concept of tuple, and think of them only as (key,val) pairs
23:22:30 <ReinH> No, they're useful as tuples too
23:23:11 <Cale> They are pairs, it's just that there's a natural bias to the order in which the components come, which is induced by the way that type classes work
23:23:21 <thang1> It works for my brain better if I think of them exclusively as (label, data) pairs
23:23:37 <ReinH> well, that's unnecessarily limiting yourself
23:23:45 <ReinH> products are nice to have around
23:23:59 <Cale> Not everything out there will follow this nice pattern unfortunately
23:24:01 <Cale> :t runState
23:24:02 <lambdabot> State s a -> s -> (a, s)
23:24:09 <Cale> That ought to be (s,a)
23:24:49 <thang1> My brain will autoamtically generify the concept after a bit, but for now it's more accurate to think of it as (k,v) rather than "heterogenius list of values that got limited to 2 because the language wasn't designed cleverly enough in the first place"
23:25:10 <ReinH> eh, that's not what anyone is suggesting?
23:25:59 <thang1> I know. Right now those are the two definitions of tuple floating in my head. I'll pick the more correct one and let the even more correct definition absorb over time through osmosis and what not
23:26:45 <Cale> I dunno, in mathematics, when you form a Cartesian product of a bunch of sets, it tends to only specify those tuples of a particular size and shape, and if you define a function out of such a product, it doesn't automatically work for other Cartesian products :)
23:27:09 <ReinH> > [(a,b) | a <- "hello", b <- "world"] -- it's nice to have products
23:27:11 <lambdabot>  [('h','w'),('h','o'),('h','r'),('h','l'),('h','d'),('e','w'),('e','o'),('e',...
23:27:18 <Cale> There's a lot more freedom to define families of functions there though.
23:27:52 <ReinH> if you think the tuple situation is bad, you should see what people get up to with indexed functor families.
23:27:53 <Cale> We don't have dependent types in Haskell, so you can't easily say "oh, let the type depend on this number which is a separate argument to the function"
23:28:35 <thang1> Right, and I'm more used to that freedom, so rather than trip myself up and get frustrated at a lack of a very specific type of freedom, I'd rather artifically restrict myself in one area and increase my brain's ability for thinking in a different pattern (namely creating record types)
23:28:59 <Cale> That's fair, I think
23:29:03 <suzu> > do { a <- "hello"; b <- "world"; return [a,b]; }
23:29:05 <lambdabot>  ["hw","ho","hr","hl","hd","ew","eo","er","el","ed","lw","lo","lr","ll","ld",...
23:29:33 <Cale> thang1: Another thing you can imagine is that tuples are just very unopinionated, distinct, record types
23:29:56 <suzu> > sequenceM ["hello", "world"]
23:29:58 <lambdabot>  error:
23:29:58 <lambdabot>      • Variable not in scope: sequenceM :: [[Char]] -> t
23:29:58 <lambdabot>      • Perhaps you meant one of these:
23:30:02 <suzu> wut
23:30:12 <Cale> Sometimes, if you just have two things you need to produce as the result of a function, it isn't *quite* worth it to define a new type
23:30:13 <suzu> oops
23:30:16 <ReinH> sequence or sequenceA, there is no sequenceM
23:30:17 <thang1> I do it all the time, it's great for learning things. Pick the simplest heuristic that is a strict subset of the "real" idea, then explore as much as possible. Your brain's automatic refining of heuristics will converge to the correct and nuanced concept; additionally, you'll learn how to think in different patterns easier
23:30:22 <suzu> > sequence ["hello", "world"]
23:30:25 <suzu> thats the one
23:30:25 <lambdabot>  ["hw","ho","hr","hl","hd","ew","eo","er","el","ed","lw","lo","lr","ll","ld",...
23:30:57 <Cale> thang1: But as soon as you have more than 3, it's quite clear that you should be defining some type to organise the various parts of the result of your function.
23:31:05 <paolino> > sequence . sequence $ ["hel","wo"]
23:31:07 <lambdabot>  ["hheell","hheelo","hheewl","hheewo","hheoll","hheolo","hheowl","hheowo","hh...
23:31:29 <thang1> Right, just like you want to abstract out modular inner functions as quickly as possible
23:32:38 <jle`> thang1: the Functor/Foldable/Applicative/etc. instances treat them as (k,v) pairs, but that's just those specific instances
23:32:48 <paolino> also (a,(b,(c,.... are useful sometimes
23:33:02 <thang1> sometimes :p
23:33:05 <jle`> thang1: just like how the Applicative instance treats lists like "possible values"
23:33:12 <jle`> thang1: but that's just that particular instance's semantics
23:33:21 <jle`> lists are also useful for other things, as well
23:33:31 <jle`> like, holding things, or being streaming data sources
23:33:58 <ReinH> > iterate sequence ["hel", "wo"]
23:34:00 <lambdabot>  [["hel","wo"],["hw","ho","ew","eo","lw","lo"],["hheell","hheelo","hheewl","h...
23:34:04 <thang1> Right, that's a cool way to think about those
23:35:34 <Cale> haha, iterate sequence
23:35:37 <thang1> Now, dumb category theory question. Are Functor,Applicative,etc all categories in of themselves? I know you don't need to define a class that's an actual category in CT, but I'm assuming all of the "standard" ones have very strong CT theory behind them?
23:36:24 <Cale> Well, there is a category of all functors and natural transformations
23:36:52 <Cale> (between a given pair of categories, in this case, they'd be the endofunctors Hask -> Hask)
23:37:29 <Cale> and then you can define a notion of which natural transformations are homomorphisms of applicative functors or monads, and define suitable subcategories of those
23:38:01 <jchia> Is anyone encountering a problem where after running a program compiled with ghc, the terminal gets messed up so that backspace does not erase buffered input? In other words, while sleep 1000 is running, if I presse 'a' followed by backspace, the backspace does not erase the a but shows up as '^?' on the terminal.
23:38:14 <jchia> The problem goes away only after I run reset.
23:38:16 <ReinH> Hmm... The question "is Applicative a category?" is probably either a deep question about monoidal functors or a misunderstanding of what a category is.
23:38:46 <ReinH> jchia: ghc or ghci?
23:38:52 <Cale> Or the shallow question that I answered :)
23:38:55 <jchia> ReinH: ghc. i haven't tried ghci
23:38:56 <thang1> neat
23:39:08 <Cale> The type class itself isn't a category
23:39:25 <ReinH> jchia: well, your program could be printing escapes to stdout that could cause that
23:39:26 <thang1> I figured, it didn't seem quite right for the type class to be one
23:39:30 <ReinH> but ghc itself wouldn't
23:39:40 <Cale> It's just that the functors which are instances of it can be arranged as the objects of a category -- which isn't saying a whole lot, most things can be.
23:39:42 <jchia> ReinH: No, my main is just 'pure ()'.
23:39:49 <paolino> there i a commuting graph in Hask -> Hask for each one of them ?
23:40:24 <jchia> ReinH: Maybe it's something that the runtime system does, if that counts as 'my program'.
23:40:42 <ReinH> jchia: how are you running it?
23:40:46 <thang1> So type classes bear a passing resemblance to the categories and are related to categorial concepts, but there's not much outside of that?
23:41:14 <ReinH> type classes do not resemble categories per se. They are sometimes used to describe things that resemble categories.
23:41:18 <ReinH> Like functors.
23:42:24 <thang1> Right. And categories offer useful ways to speak generically and broadly about concepts, so well designed type classes often end up resembling categories but merely out of coincidence than any deeper necessity or meaning
23:42:33 <thang1> (if I'm understanding everything right)
23:43:04 <ReinH> Well, category theory is the abstract algebra of abstract functions. Type classes define a collection of functions.
23:43:06 <Cale> Well, the type class doesn't do that on its own -- we have to put in a bunch of stuff.
23:43:25 <ReinH> When you do well-behaved things with functions, there's often a way to make sene of it categorically
23:43:29 <Cale> It's not those functions though...
23:43:31 <Cale> heh
23:44:16 <Cale> Natural transformations between functors f and g are roughly polymorphic functions of type forall a. f a -> g a
23:44:40 <jchia> ReinH: http://lpaste.net/355217
23:45:13 <ReinH> jchia: well that's odd
23:46:09 <Cale> They're really families of functions eta_X :: F X -> G X for each type X, such that for any function h :: X -> Y, you have fmap h . eta_X = eta_Y . fmap h
23:46:23 <Cale> and those are then the arrows in your category of functors
23:46:42 <jchia> ReinH: Well, GHC is associated with libtinfo, which looks like something related to the terminal, so I suspect the runtime system is causing this.
23:46:43 <ReinH> I mean. I guess Show induces a slice category or something but it isn't very interesting.
23:47:22 <Cale> ah, okay, yeah, there's often a way to derive what the "obvious" sort of homomorphism would be for a given type class
23:49:55 <thang1> jchia: well
23:50:05 <jchia> ReinH: Turns out it's not my program. Turns out it stack itself.
23:50:09 <thang1> I just ran and compiled your test program on my computer. I have no sleep issues or backspace issues at all
23:50:13 <ReinH> jchia: neat
23:50:18 <jchia> ReinH: (stack which)
23:50:20 <thang1> I also used stack :p
23:50:51 <jchia> ReinH: I mean stack exec which
23:50:54 <ReinH> Cale: speaking of which, I'm trying to muddle my way through Jon Sterling's topos notes and oh my god
23:51:04 <ReinH> good thing I have Mac Lane's book lying around
23:51:18 <jchia> thang1: I'm using stack on Fedora 22. What about you?
23:51:24 <thang1> Arch linux
23:51:30 * thang1 tips fedora, scratches neckbeard
23:51:43 <jchia> thang1: Let me try this on my Arch Linux later.
23:51:48 <thang1> I'm also using Protolude as the template
23:51:57 <ReinH> something something subobject classifier, something something Yoneda, and apparently now we have type theory.
23:52:10 <thang1> what version of stack and what resolver are you using? I'm using lts-8.13
23:52:32 <thang1> ReinH: type theory fascinates me
23:53:19 <thang1> I've been going down a deep rabbit hole lately trying to connect stronger type theories like HoTT, Uniqueness Types, Dependent Types, etc., with logical programming with functional programming
23:55:10 <ReinH> Cale: he has a paragraph titled "Understanding Ω using Yoneda’s Lemma as a weapon"
23:56:42 <thang1> (cue "when you have a hammer..." quote)
23:57:27 <ReinH> it's a pretty good hammer
23:57:29 <mrkgnao> ReinH: like, a loop space?
23:58:12 <ReinH> mrkgnao: which?
23:58:31 <ReinH> Oh, Ω
23:59:35 <ReinH> No, I think it's just a namespace collision on Ω
23:59:38 <jchia> thang1: stack 1.4.0, lts-8.12
